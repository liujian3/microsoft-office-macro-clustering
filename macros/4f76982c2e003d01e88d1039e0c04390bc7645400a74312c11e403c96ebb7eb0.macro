Attribute VB_Name = "DieseArbeitsmappe"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit
Private module



Private Sub DoAutoopenShow()
  TabInfos.Visible = xlSheetVisible
  TabInfos.Select
  TabInfos.Worksheet_Activate
  ButtonInfoClick
End Sub




Private Sub Workbook_Open()
Dim i As Byte

  For i = 1 To TabData.BundeslaenderCount
    TabInfos.ComboBoxBundeslaender.AddItem TabData.Bundeslaender(i)
  Next i
  
  
  If TabData.Registrierungscode <> "" Then
    If Not TabData.RegistrierungscodeOk(TabData.Registrierungscode) Then TabData.Registrierungscode = ""
  End If
  If Registered Then
    If TabInfos.AutoopenShow Then DoAutoopenShow
  Else
    TabSettings.Gesperrt = True
    DoAutoopenShow
  End If
  ' evt. werden die Dropdownkn|fffd|pfe nicht angezeigt...
  ActiveWorkbook.DisplayDrawingObjects = xlDisplayShapes

  
  ActiveWorkbook.Saved = True
  
End Sub



Attribute VB_Name = "Feiertage"
Option Explicit
Option Private Module


Global Const CEasterDepIndex_Karfreitag     As Byte = 0
Global Const CEasterDepIndex_OsterSonntag   As Byte = 1
Global Const CEasterDepIndex_Ostermontag    As Byte = 2
Global Const CEasterDepIndex_ChrHimmelf     As Byte = 3
Global Const CEasterDepIndex_Pfingstsonntag As Byte = 4
Global Const CEasterDepIndex_Pfingstmontag  As Byte = 5
Global Const CEasterDepIndex_Fronleichnam   As Byte = 6

Global Const CEasterDepIndexFirst           As Byte = CEasterDepIndex_Karfreitag
Global Const CEasterDepIndexLast            As Byte = CEasterDepIndex_Fronleichnam




'***************************** interne Deklarationen ***********************

' Defininitionen und Deklarationen zum Cache:
Type TOsterCache
       Jahr As Integer
       Datum As Long
End Type
Const COsterCacheCount = 3
Dim fOstercache(COsterCacheCount) As TOsterCache
Dim fOsterCacheIndex As Byte
Dim fEasterDepOffsets As String



'************************** EasterDepPublic ********************************
Function EasterDepPublic(AYear As Integer, EasterDepIndex As Byte) As Long
' Liefert einen von Ostern abh|fffd|ngigen Tag gem|fffd||fffd| *EasterDepIndex*
  'If fEasterDepOffsets = "" Then fEasterDepOffsets = Chr(-3) + Chr(0) + Chr(1) + Chr(40) + Chr(50) + Chr(51) + Chr(60)
  Select Case EasterDepIndex
    Case CEasterDepIndex_Karfreitag
      EasterDepPublic = EasterSunday(AYear) - 2
    Case CEasterDepIndex_OsterSonntag
      EasterDepPublic = EasterSunday(AYear)
    Case CEasterDepIndex_Ostermontag
      EasterDepPublic = EasterSunday(AYear) + 1
    Case CEasterDepIndex_ChrHimmelf
      EasterDepPublic = EasterSunday(AYear) + 39
    Case CEasterDepIndex_Pfingstsonntag
      EasterDepPublic = EasterSunday(AYear) + 49
    Case CEasterDepIndex_Pfingstmontag
      EasterDepPublic = EasterSunday(AYear) + 50
    Case CEasterDepIndex_Fronleichnam
      EasterDepPublic = EasterSunday(AYear) + 60
  End Select
End Function






Private Function OsterCacheHave(ByVal AYear As Integer, ByRef AOsterSonntag As Long) As Boolean
Dim i As Byte
  For i = 0 To COsterCacheCount - 1
    If fOstercache(i).Jahr = AYear Then
      OsterCacheHave = True
      AOsterSonntag = fOstercache(i).Datum
      Exit Function
    End If
  Next i
  OsterCacheHave = False
End Function



Private Sub OsterCacheAdd(ByVal AYear As Integer, ByVal AOsterSonntag As Long)
 If fOsterCacheIndex = COsterCacheCount Then fOsterCacheIndex = 0 Else fOsterCacheIndex = fOsterCacheIndex + 1
 fOstercache(fOsterCacheIndex).Datum = AOsterSonntag
 fOstercache(fOsterCacheIndex).Jahr = AYear
End Sub



Public Function EasterSunday(ByVal Jahr As Integer) As Long
'***************************************************************************
' Berechnet den Ostersonntag im angegebenen JAHR. Dies muss das Jahrhundert
' enthalten.
' Zur Berechnung siehe: http://www.th-o.de/kalender.htm
' oder http://www.ptb.de/de/org/4/43/432/oste.htm
'***************************************************************************)
'Dim a As Integer, b As Integer, c As Integer, d As Integer, e As Integer, f As Integer, m As Integer, n As Integer, ostertage As Integer
Dim a As Integer, d As Integer, k As Integer, m As Integer, OE As Integer, OG As Integer, r As Integer, s As Integer, SZ As Integer
Dim ADate As Long

  If OsterCacheHave(Jahr, ADate) Then EasterSunday = ADate: Exit Function
 
  k = Int(Jahr / 100)
  m = 15 + Int((3 * k + 3) / 4) - Int((8 * k + 13) / 25)
  s = 2 - Int((3 * k + 3) / 4)
  a = Jahr Mod 19
  d = (19 * a + m) Mod 30
  'r = Int(d / 29) + (Int(d / 28) - Int(d / 29)) * Int(a / 11)
  r = Int((d + a / 11) / 29)
  OG = 21 + d - r ' M|fffd|rzdatum des Ostervollmonds (= 14. Tag des ersten Monats im Mondkalender, genannt Nisanu)
  SZ = 7 - (Jahr + Int(Jahr / 4) + s) Mod 7     ' Datum des 1. Sonntags im M|fffd|rz
  OE = 7 - (OG - SZ) Mod 7
  ADate = DateSerial(Jahr, 3, 0) + OG + OE
  OsterCacheAdd Jahr, ADate
  EasterSunday = ADate
  


'  f = Jahr / 100 - Jahr / 400
'  a = Jahr Mod 19
'  b = Jahr Mod 4
'  c = Jahr Mod 7
'  m = (f - (Jahr / 300) + 15) Mod 30
'  n = (f + 4) Mod 7
'  d = (19 * a + m) Mod 30
'  e = (2 * b + 4 * c + 6 * d + n) Mod 7
'  If (e = 6) And ((d = 29) Or ((d = 28) And (a > 10))) Then
'     ostertage = 15 + d + e
'  Else
'    ostertage = 22 + d + e
'  End If
  
End Function
Attribute VB_Name = "FormHolidaySelect"
Attribute VB_Base = "0{30435646-8DEE-46B5-A1A1-6882BB11517F}{D36B24B7-17B2-4898-B745-AB6879BFF68C}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private OldCursor As Long

Private Sub CheckBoxSelectall_Click()
  If CheckBoxSelectall Then
    CommandButtonOk.Enabled = True
    ListBoxFerien.Enabled = False
  Else
    CommandButtonOk.Enabled = ListBoxFerienHaveSeclected
    ListBoxFerien.Enabled = True
    ListBoxFerien.SetFocus
  End If
End Sub



Private Sub ComboBoxBundeslaender_Change()
Dim i As Integer
  
  ListBoxFerien.Clear
  i = 0
  While TabHolidaysAll.BundeslandNextLine(ComboBoxBundeslaender.Listindex + 1, i)
    ListBoxFerien.AddItem CStr(TabHolidaysAll.Jahr(i))
  Wend
End Sub

Private Sub CommandButtonCancel_Click()
  Unload Me
End Sub





Private Sub CommandButtonOk_Click()
On Error GoTo Err_CommandButtonOk_Click
Dim i As Integer, Jahr As Integer, ZeileSrc As Integer, ZeileDest As Integer, EntriesWritten As Integer
Dim j As Byte
Dim DoOverwrite As Boolean, HaveAsked4Overwrite As Boolean, OldScreenUpdating As Boolean
Dim s As String

  OldScreenUpdating = Application.ScreenUpdating
  Application.ScreenUpdating = False
  If ComboBoxBundeslaender.Listindex + 1 <> TabData.BundeslandIndex Then
    If MsgBox("Das ausgew|fffd|hlte Bundesland entspricht nicht dem voreingestellten Bundesland." & vbNewLine _
      & "Trotzdem eintragen?", vbYesNo Or vbExclamation, CTitleMsgBox) = vbNo Then Exit Sub
  End If
  
  
  DoOverwrite = True
  For i = 0 To ListBoxFerien.ListCount - 1
    If ListBoxFerien.Selected(i) Or CheckBoxSelectall Then
      If Not TabHolidays.DefaultHaveYear(ComboBoxBundeslaender.Listindex + 1, ListBoxFerien.List(i, 0)) Then
        Select Case MsgBox("Mindestens einer der vorhandenen Ferieneintr|fffd|ge entspricht nicht den Voreinstellungen f|fffd|r das ausgew|fffd|hlte Bundesland. Sollen alle nicht |fffd|bereinstimmenden Eintr|fffd|ge |fffd|berschrieben werden?", vbYesNoCancel Or vbExclamation, CTitleMsgBox)
          Case vbCancel
            GoTo Exit_CommandButtonOk_Click
          Case vbYes
            DoOverwrite = True
          Case Else
            DoOverwrite = False
        End Select
        Exit For
      End If
    End If
  Next i
  
  
  For i = 0 To ListBoxFerien.ListCount - 1
    If ListBoxFerien.Selected(i) Or CheckBoxSelectall Then
      EntriesWritten = EntriesWritten + TabHolidays.DefaultSet(ComboBoxBundeslaender.Listindex + 1, ListBoxFerien.List(i, 0), DoOverwrite)
    End If
  Next i
  If EntriesWritten = 1 Then s = "Eintrag" Else s = "Eintr|fffd|ge"
  MsgBox EntriesWritten & " " & s & " geschrieben", vbOKOnly, CTitleMsgBox
  GoTo Exit_CommandButtonOk_Click
  


  
Err_CommandButtonOk_Click:
  MsgBox Err.Description, vbCritical, CTitleMsgBox
  Resume Exit_CommandButtonOk_Click
  
Exit_CommandButtonOk_Click:
  Application.ScreenUpdating = OldScreenUpdating
  Unload Me
  
  
End Sub


Private Function ListBoxFerienHaveSeclected() As Boolean
Dim i As Integer
  For i = 0 To ListBoxFerien.ListCount - 1
    If ListBoxFerien.Selected(i) Then ListBoxFerienHaveSeclected = True: Exit Function
  Next i
  ListBoxFerienHaveSeclected = False
End Function


Private Sub ListBoxFerien_Change()
  CommandButtonOk.Enabled = ListBoxFerienHaveSeclected
End Sub


Private Sub UserForm_Initialize()
Const CLabelBundeslandDefaultCaptionPreStr = "Vorausgew|fffd|hlt: "
Dim i As Byte
  
  OldCursor = Application.Cursor
  Application.Cursor = xlDefault
  
  For i = 1 To TabData.BundeslaenderCount
    ComboBoxBundeslaender.AddItem TabData.Bundeslaender(i)
  Next i
  
  Me.ComboBoxBundeslaender.Listindex = TabData.BundeslandIndex - 1

  If ComboBoxBundeslaender.Listindex >= 0 Then
    LabelBundeslandDefault.Caption = CLabelBundeslandDefaultCaptionPreStr & ComboBoxBundeslaender.List(ComboBoxBundeslaender.Listindex, 0)
  Else
    LabelBundeslandDefault.Caption = CLabelBundeslandDefaultCaptionPreStr & "(kein)"
  End If
  CheckBoxSelectall.Value = True
  
End Sub

Private Sub UserForm_Terminate()
  Application.Cursor = OldCursor
End Sub
Attribute VB_Name = "FormImportExport"
Attribute VB_Base = "0{5DF33EAF-7416-4075-BBC3-4B7A8B37B478}{1926A99B-8292-4EB5-9508-3533AB2E0F19}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private fCancelPressed As Boolean


Private Sub ButtonOKCheck()
Dim result As Boolean

  result = False
  If Filename <> "" Then _
    If CheckBoxTreatAll.Value Or CheckBoxPublics Or CheckBoxHolidays Or CheckBoxYearly Or CheckBoxCyclic Or CheckBoxSettings Or CheckBoxLizenzschl|fffd|ssel Or CheckBoxOther Then result = True
  
  ButtonOK.Enabled = result
End Sub



Private Sub ButtonCancel_Click()
  fCancelPressed = True
  Hide
End Sub


Private Sub CheckBox_Dataselect(ByVal CheckboxChecked As Boolean)
  If CheckboxChecked Then
    TreatAllCheck
  Else
    CheckBoxTreatAll.Value = False
  End If
  ButtonOKCheck
End Sub

Private Sub ButtonHelp_Click()
  Help "#importexport"
End Sub


Private Sub ButtonOk_Click()
On Error GoTo Err_ButtonOk_Click
Const CIniKey_Lizenzschl|fffd|ssel   As String = "Registercode"
Const CIniKey_BundeslandIndex   As String = "BundeslandIndex"
Const CIniKey_KalenderBeginn    As String = "CalendarBegin"
Const CIniKey_KalenderEnde      As String = "CalendarEnd"
Const CIniKey_LastChoosenSchema As String = "Schema"

Dim l As Long, ItemsCount As Long
Dim HasError As Boolean
Dim s As String
  
  
  ItemsCount = 0
  HasError = False
  
  
  TabData.LastFilenameImportExport = Filename
  If Import Then
    Inifile.InifileOpen Filename, False
  Else
    If FileExists(Filename) Then
      If MsgBox("Die Datei existiert bereits. |fffd|berschreiben?", vbQuestion Or vbYesNo, CTitleMsgBox) <> vbYes Then Exit Sub
      Kill Filename
    End If
    Inifile.InifileOpen Filename, True
  End If
  
  UpdateBegin
  If CheckBoxLizenzschl|fffd|ssel Then
    If Import Then
      TabData.Registrierungscode = decodeURI(LoadFromOpenIniFileString(CIniSection_Global, CIniKey_Lizenzschl|fffd|ssel), True)
    Else
      SaveToOpenIniFileString CIniSection_Global, CIniKey_Lizenzschl|fffd|ssel, encodeURI(TabData.Registrierungscode, True)
    End If
    ItemsCount = ItemsCount + 1
  End If
    
    
  If CheckBoxHolidays Then
    If Import Then
      If Overwrite Then TabHolidays.Clear
      HasError = HasError Or Not TabHolidays.LoadFromOpenIniFile(ItemsCount)
    Else
      HasError = HasError Or Not TabHolidays.SaveToOpenIniFile(ItemsCount)
    End If
  End If
    
  If CheckBoxPublics Then
    If Import Then
      If Overwrite Then TabPublics.Clear
      HasError = HasError Or Not TabPublics.LoadFromOpenIniFile(ItemsCount)
    Else
      HasError = HasError Or Not TabPublics.SaveToOpenIniFile(ItemsCount)
    End If
  End If
    
  If CheckBoxYearly Then
    If Import Then
      If Overwrite Then TabYearly.Clear
      HasError = HasError Or Not TabYearly.LoadFromOpenIniFile(ItemsCount)
    Else
      HasError = HasError Or Not TabYearly.SaveToOpenIniFile(ItemsCount)
    End If
  End If
    
    
  If CheckBoxCyclic Then
    If Import Then
      If Overwrite Then TabCyclic.Clear
      HasError = HasError Or Not TabCyclic.LoadFromOpenIniFile(ItemsCount)
    Else
      HasError = HasError Or Not TabCyclic.SaveToOpenIniFile(ItemsCount)
    End If
  End If
    
    
  If CheckBoxSettings Then
    If Import Then
      If Overwrite Then TabSettings.Clear
      HasError = HasError Or Not TabSettings.LoadFromOpenIniFile(ItemsCount)
    Else
      HasError = HasError Or Not TabSettings.SaveToOpenIniFile(ItemsCount)
    End If
  End If
    
    
  
  If CheckBoxOther Then
    If Import Then
      If Overwrite Then TabInfos.Clear
      HasError = HasError Or Not TabInfos.LoadFromOpenIniFile(ItemsCount)
      TabData.BundeslandIndex = LoadFromOpenInifileInteger(CIniSection_Global, CIniKey_BundeslandIndex, 0)
      ItemsCount = ItemsCount + 1
      l = LoadFromOpenInifileLong(CIniSection_Global, CIniKey_KalenderBeginn, -1)
      If l > 0 Then
        TabData.LastChoosenDate(True) = CDate(l)
        ItemsCount = ItemsCount + 1
      End If
      l = LoadFromOpenInifileLong(CIniSection_Global, CIniKey_KalenderEnde, -1)
      If l > 0 Then
        TabData.LastChoosenDate(False) = CDate(l)
        ItemsCount = ItemsCount + 1
      End If
      TabData.LastChoosenSchema = decodeURI(LoadFromOpenIniFileString(CIniSection_Global, CIniKey_LastChoosenSchema), True)
      ItemsCount = ItemsCount + 1
    Else
      HasError = HasError Or Not TabInfos.SaveToOpenIniFile(ItemsCount)
      SaveToOpenIniFileInteger CIniSection_Global, CIniKey_BundeslandIndex, TabData.BundeslandIndex
      ItemsCount = ItemsCount + 1
      If TabData.LastChoosenDateHave(True) Then
        l = CLng(TabData.LastChoosenDate(True))
        ItemsCount = ItemsCount + 1
      Else
        l = -1
      End If
      SaveToOpenIniFileLong CIniSection_Global, CIniKey_KalenderBeginn, l
      If TabData.LastChoosenDateHave(False) Then
        l = CLng(TabData.LastChoosenDate(False))
        ItemsCount = ItemsCount + 1
      Else
        l = -1
      End If
      SaveToOpenIniFileLong CIniSection_Global, CIniKey_KalenderEnde, l
      SaveToOpenIniFileString CIniSection_Global, CIniKey_LastChoosenSchema, encodeURI(TabData.LastChoosenSchema, True)
      ItemsCount = ItemsCount + 1
    End If
  End If
    
  Inifile.InifileClose
  If HasError Then s = "mit Fehlern" Else s = "ohne Fehler"
  MsgBox CStr(ItemsCount) & " Eintr|fffd|ge " & s & " behandelt.", vbInformation Or vbOKOnly, CTitleMsgBox
  GoTo Exit_ButtonOk_Click
  
  
Err_ButtonOk_Click:
  MsgBox Err.Description
  Resume Exit_ButtonOk_Click
  
  
Exit_ButtonOk_Click:
  UpdateEnd
  Me.Hide
  
End Sub



Private Sub ButtonSearch_Click()
Const CDefaultExt As String = "ini"
Const CFileFilter As String = "INI-Dateien (*.ini)|*.ini|Alle Dateien (*.*)|*.*"
Dim s As String
Dim SaveFlags As Long
Static Filterindex As Long
  s = Filename
  If Import Then
    If Not FileOpenDLG(CDefaultExt, CFileFilter, s, "Importdatei ausw|fffd|hlen", Filterindex:=Filterindex) Then Exit Sub
  Else
    SaveFlags = COFNFlags_Save And (Not OFN_OVERWRITEPROMPT)
    If Not FileSaveDLG(CDefaultExt, CFileFilter, s, "Exportdatei ausw|fffd|hlen", SaveFlags, Filterindex:=Filterindex) Then Exit Sub
  End If
  Filename = s
  TextBoxFilename.SetFocus

End Sub

Private Sub CheckBoxCyclic_Click()
  CheckBox_Dataselect CheckBoxCyclic.Value
End Sub

Private Sub CheckBoxHolidays_Click()
  CheckBox_Dataselect CheckBoxHolidays.Value
End Sub



Private Sub CheckBoxLizenzschl|fffd|ssel_Click()
  CheckBox_Dataselect CheckBoxLizenzschl|fffd|ssel.Value
End Sub

Private Sub CheckBoxOther_Click()
  CheckBox_Dataselect CheckBoxOther.Value
End Sub

Private Sub CheckBoxPublics_Click()
  CheckBox_Dataselect CheckBoxPublics.Value
End Sub


Private Sub CheckBoxSettings_Click()
  CheckBox_Dataselect CheckBoxSettings.Value
End Sub

Private Sub CheckBoxTreatAll_Click()
  If CheckBoxTreatAll.Value Then
    CheckBoxPublics = True
    CheckBoxHolidays = True
    CheckBoxYearly = True
    CheckBoxCyclic = True
    CheckBoxSettings = True
    CheckBoxLizenzschl|fffd|ssel = True
    CheckBoxOther = True
  End If
End Sub

Private Sub CheckBoxYearly_Click()
  CheckBox_Dataselect CheckBoxYearly.Value
End Sub



Private Property Get Filename() As String
  Filename = Trim(TextBoxFilename.Text)
End Property


Private Property Let Filename(NewFilename As String)
  TextBoxFilename.Text = Trim(NewFilename)
  TextBoxFilename_Change
End Property

Private Property Get Import() As Boolean
  Import = OptionButtonImport.Value
End Property



Private Sub OptionButtonExport_Click()
  CheckBoxOverwrite.Enabled = False
End Sub

Private Sub OptionButtonImport_Click()
  CheckBoxOverwrite.Enabled = True
End Sub


Private Property Get Overwrite() As Boolean
  Overwrite = CheckBoxOverwrite.Value
End Property


Private Property Let Overwrite(NewValue As Boolean)
  If NewValue = Overwrite Then Exit Property
  CheckBoxOverwrite.Value = Overwrite
End Property


Private Sub TextBoxFilename_Change()
  ButtonOKCheck
End Sub

  


Property Get TreatAll() As Boolean
  TreatAll = CheckBoxTreatAll.Value
End Property



Property Let TreatAll(b As Boolean)
  CheckBoxTreatAll.Value = b
End Property


Private Sub TreatAllCheck()
  If CheckBoxPublics Then _
    If CheckBoxHolidays Then _
      If CheckBoxYearly Then _
        If CheckBoxCyclic Then _
          If CheckBoxSettings Then _
            If CheckBoxLizenzschl|fffd|ssel Then _
              If CheckBoxOther Then _
                TreatAll = True

End Sub


Private Sub UserForm_Initialize()
  Filename = TabData.LastFilenameImportExport
End Sub
Attribute VB_Name = "FormImportSchulferien"
Attribute VB_Base = "0{571342EF-24A5-4DCF-A63D-9A346EB74FEC}{9DA83F8D-D4C9-4890-9C55-C700ECBBD200}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False





Option Explicit

Private CancelPressed As Boolean

Private Sub ButtonCancel_Click()
  CancelPressed = True
  Me.Hide
End Sub

Private Sub ButtonOk_Click()
  If FileGetAttributes(Filename) < 0 Then
    MsgBox "Datei nicht gefunden!", vbCritical, CTitleMsgBox
  Else
    CancelPressed = False
    Me.Hide
  End If
End Sub


Public Function Execute(ByRef AFilename As String) As Boolean
  Filename = AFilename
  EditFilename.SetFocus
  CancelPressed = True
  Me.Show
  If CancelPressed Then
    Execute = False
  Else
    AFilename = Filename
    Execute = True
  End If
End Function



Private Sub ButtonSearchFilename_Click()
Dim s As String
Static Filterindex As Long
  s = Filename
  If Not FileOpenDLG("csv", "CSV-Dateien (*.csv)|*.csv|Alle Dateien (*.*)|*.*", s, "Schulferiendefinitionsdatei ausw|fffd|hlen", Filterindex:=Filterindex) Then Exit Sub
  Filename = s
  EditFilename.SetFocus
End Sub

Private Sub EditFilename_Change()
  ButtonOK.Enabled = Filename <> ""
End Sub


Private Property Get Filename() As String
  Filename = Trim(EditFilename.Text)
End Property

Private Property Let Filename(NewFilename As String)
  EditFilename.Text = Trim(NewFilename)
  EditFilename_Change
End Property



Private Sub UserForm_Activate()
  Label1.Caption = _
     "F|fffd|r den Fall, dass die in Kalender-Excel hinterlegten Feriendefinitionen fehlerhaft oder " _
   & "unvollst|fffd|ndig sind, k|fffd|nnen Sie diese durch eine aktualisierte Version ersetzen lassen. " _
   & "Die jeweils aktuellste Feriendefinitionsdatei finden Sie auch auf unseren Webseiten unter " _
   & CURLUpdates & ". (Sie benutzen zur Zeit die Version vom " _
   & TabHolidaysAll.HolidayReleaseDate & ")"
End Sub

Attribute VB_Name = "FormImportYearly"
Attribute VB_Base = "0{78EDE8D9-060F-4F30-9643-88939879F116}{0A7B5B31-03DE-4FBE-BB9A-8A7AA363A734}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private fCancelPressed As Boolean
Private Const CImportschemaKalender8x  As Byte = 1
Private Const CImportschemaOutlook     As Byte = 2


Private Sub ButtonCancel_Click()
  fCancelPressed = True
  Hide
  Unload Me
End Sub


Private Sub ButtonOKCheck()
  ButtonOK.Enabled = (Filename <> "") And (Importschema <> 0)
End Sub




Private Sub ButtonHelp_Click()
  Help "#ImportYearly"
End Sub

Private Sub ButtonOk_Click()

  If ClearItems Then TabYearly.Clear
  Select Case Importschema
    Case CImportschemaKalender8x
      TabYearly.Import_Kalender8x Filename
    Case CImportschemaOutlook
      TabYearly.Import_Outlook Filename
  End Select
  
  TabData.LastFilenameYearlyImport = Filename
  
  Unload Me
End Sub

Private Sub ButtonSearch_Click()
Const CDefaultExt As String = "csv"
Const CFileFilter As String = "CSV-Dateien (*.csv)|*.csv|Alle Dateien (*.*)|*.*"
Dim s As String
Static Filterindex As Long
  
  s = Filename
  If Not FileOpenDLG(CDefaultExt, CFileFilter, s, "Importdatei ausw|fffd|hlen", Filterindex:=Filterindex) Then Exit Sub
  Filename = s
  TextBoxFilename.SetFocus

End Sub


Private Property Get ClearItems() As Boolean
  ClearItems = CheckBoxClear
End Property

Private Property Let ClearItems(ByVal NewClearItems As Boolean)
  If ClearItems = NewClearItems Then Exit Property
  CheckBoxClear = NewClearItems
End Property


Private Property Get Filename() As String
  Filename = Trim(TextBoxFilename.Text)
End Property


Private Property Let Filename(NewFilename As String)
  TextBoxFilename.Text = Trim(NewFilename)
  TextBoxFilename_Change
End Property



Private Property Get Importschema() As Byte
  If IsNull(ListBoxImportformat.Value) Then
    Importschema = 0
  Else
    Importschema = ListBoxImportformat.Value + 1
  End If
End Property



Private Property Let Importschema(ByVal NewImportschema As Byte)
  If NewImportschema = Importschema Then Exit Property
  ListBoxImportformat.Value = NewImportschema
  ImportschemaChanged
End Property

Private Sub ImportschemaChanged()
  ButtonOKCheck
End Sub


Private Sub ListBoxImportformat_Click()
  ImportschemaChanged
End Sub

Private Sub TextBoxFilename_Change()
  ButtonOKCheck
End Sub



Private Sub UserForm_Initialize()
  ListBoxImportformat.AddItem "Kalender-Excel 8.5.x"
  'ListBoxImportformat.Column(1, 0) = "Tag|Monat|Jahr|Hilfsspalte|Benennung|Schriftgr|fffd||fffd|e|Anzeigen,"
  ListBoxImportformat.AddItem "Outlook"
  'ListBoxImportformat.Column(1, 1) = """Beginnt am"",""Endet am"",""Ganzt|fffd|giges Ereignis"",""Betreff"""
  Filename = TabData.LastFilenameYearlyImport
  
End Sub
Attribute VB_Name = "FormYearSelect"
Attribute VB_Base = "0{67F0A7FC-E4AD-4F43-A378-D0DC3793263E}{1C324398-2A1B-4EED-9F02-A28CD33437E0}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

Private CancelPressed As Boolean
Private fWorkbookName As String


Private Function AutoName() As String
Dim s As String
  s = TextBoxYearFrom.Text
  AutoName = Left(s & " - " & ComboBoxFormat.Value, 31)
End Function

Private Sub ButtonCancel_Click()
  CancelPressed = True
  Hide
End Sub




Private Sub ButtonOk_Click()
On Error GoTo Err_ButtonOk_Click
Dim AWorkSheet As Worksheet

    
  If GetDauer < 1 Then
    MsgBox "Der Kalender muss mindestens einen Monat umfassen.", vbCritical, CTitleMsgBox
    Exit Sub
  End If
  
  If GetDauer > 256 \ CColsPerMonth Then
    MsgBox "Da in Excel maximal 256 Spalten m|fffd|glich sind, darf bei " & CStr(CColsPerMonth) & " Spalten/Monat die Gesamtzahl der Monate " & CStr(256 \ CColsPerMonth) & " nicht |fffd|bersteigen.", vbCritical, CTitleMsgBox
    Exit Sub
  End If
  

  If Len(TextBoxTableName.Text) > 31 Then
    MsgBox "Der Tabellenname darf h|fffd|chstens 31 Zeichen umfassen.", vbCritical, CTitleMsgBox
    TextBoxTableName.SetFocus
    Exit Sub
  End If
  If TextBoxTableName.Text = "" Then
    MsgBox "Sie m|fffd|ssen einen Tabellennamen vergeben.", vbCritical, CTitleMsgBox
    TextBoxTableName.SetFocus
    Exit Sub
  End If
  

  
  
  If OptionButtonNewmap Then
    WorkbookName = Workbooks.Add.Name
  Else
    If OptionButtonCurrentMap Then
      WorkbookName = LabelCurrentmapName.Caption
    Else
      WorkbookName = ComboBoxWorkbooks.Text
    End If
    If ExistsTableName(WorkbookName, TextBoxTableName) Then
      If MsgBox("Es existiert bereits ein Kalenderblatt namens '" & TextBoxTableName & "'!" & vbNewLine & _
        "Soll das Blatt gel|fffd|scht werden?", vbQuestion Or vbYesNo, CTitleMsgBox) = vbNo Then Exit Sub
    End If
  End If
  KalenderblattEinf|fffd|gen WorkbookName, TextBoxTableName, ComboBoxFormat.Listindex
  
  If OptionButtonNewmap Then
    For Each AWorkSheet In Workbooks(WorkbookName).Sheets
      If AWorkSheet.Name <> TextBoxTableName Then WorkSheetDelete WorkbookName, AWorkSheet.Name
    Next AWorkSheet
  End If
    
  CancelPressed = False
  GoTo Exit_ButtonOk_Click
  
Err_ButtonOk_Click:
  MsgBox Err.Description, vbCritical, CTitleMsgBox
  Resume Exit_ButtonOk_Click
  
Exit_ButtonOk_Click:

  
  Me.Hide
End Sub



Private Sub CheckBoxAutoName_Click()
  TextBoxTableNameRequery
End Sub



Private Sub CheckButtons()
  ButtonOK.Enabled = False
  If ComboBoxFormat.Listindex >= 0 Then
    If IsNumeric(TextBoxYearFrom.Value) Then
      If TextBoxYearFrom.Value >= 1900 Then
        If TextBoxYearFrom.Value <= 2100 Then
          If TextBoxTableName <> "" Then
            ButtonOK.Enabled = True
          End If
        End If
      End If
    End If
  End If
  TextBoxTableNameRequery

End Sub


Private Sub ComboBoxFormat_Change()
  TextBoxTableNameRequery
  CheckButtons
End Sub

Private Sub ComboboxMonatFill(ACombobox As ComboBox)
Dim i As Byte
  If ACombobox.ListCount <> 0 Then Exit Sub
  For i = 1 To 12
    ACombobox.AddItem i
  Next i
  ACombobox.Listindex = 0
End Sub


Private Sub ComboBoxMonthFrom_Change()
  LabelDauerRequery
  TextBoxTableNameRequery
End Sub

Private Sub ComboBoxMonthTo_Change()
  LabelDauerRequery
End Sub

Private Sub ComboBoxWorkbooks_Enter()
  OptionButtonExistingmap.Value = True
End Sub



Public Property Get DateFrom() As Long
  DateFrom = DateSerial(TextBoxYearFrom.Text, ComboBoxMonthFrom.Listindex + 1, 1)
End Property


Public Property Get DateTo() As Long
Dim ADate As Long
  ADate = DateSerial(TextBoxYearTo.Text, ComboBoxMonthTo.Listindex + 1, 28)
  While Month(ADate) = ComboBoxMonthTo.Listindex + 1
    ADate = ADate + 1
  Wend
  DateTo = ADate - 1
End Property


Private Function GetDauer() As Long
' TextBoxDauer
  If TextBoxYearTo.Value <> "" Then
    If TextBoxYearFrom.Value <> "" Then
      GetDauer = (TextBoxYearTo.Value - TextBoxYearFrom.Value) * 12 + ComboBoxMonthTo.Listindex - ComboBoxMonthFrom.Listindex + 1
    End If
  End If
End Function



Private Sub LabelDauerRequery()
  LabelDauer.Caption = "Dauer: " & CStr(GetDauer) & " Monate"
End Sub




Public Function Show_Modal(ByRef AWorkBookName As String, ByRef TableName As String, ByRef CalendarFormatIndex As Byte) As Boolean
  UserForm_Init
  Me.Show
  If CancelPressed Then
    Show_Modal = False
  Else
    TabData.LastChoosenDate(True) = DateFrom
    TabData.LastChoosenDate(False) = DateTo
    CalendarFormatIndex = ComboBoxFormat.Listindex
    TabData.LastChoosenSchema = ComboBoxFormat.Text
    AWorkBookName = WorkbookName
    TableName = TextBoxTableName.Text
    
    Show_Modal = True
  End If
  'Unload Me
End Function



Private Sub SpinButtonFrom_Change()
  TextBoxYearFrom.Value = SpinButtonFrom.Value
  LabelDauerRequery
  TextBoxTableNameRequery
End Sub

Private Sub SpinButtonTo_Change()
  TextBoxYearTo.Value = SpinButtonTo.Value
  LabelDauerRequery
End Sub




Private Sub TextBoxTableName_Change()
  CheckButtons
End Sub


Private Sub TextBoxTableName_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
  CheckBoxAutoName.Value = False
End Sub


Private Sub TextBoxTableNameRequery()
  If CheckBoxAutoName.Value Then _
    TextBoxTableName.Text = AutoName
End Sub



Private Sub TextBoxYear_Change()
  If IsNumeric(TextBoxYearFrom.Value) Then
    If TextBoxYearFrom.Value >= CYearMin Then
      If TextBoxYearFrom.Value <= CYearMax Then
        SpinButtonFrom.Value = CInt(TextBoxYearFrom.Value)
      End If
    End If
  End If
  TextBoxTableNameRequery
  CheckButtons
End Sub







Private Sub UserForm_Init()
Dim CalendarFormats()
Dim i As Byte, FormatCount As Byte
  
  CancelPressed = True
  
  ComboBoxFormat.Clear
  
  
  ComboBoxFormat.Clear
  FormatCount = TabSettings.ItemsCount
  If FormatCount > 0 Then
    For i = 0 To FormatCount - 1
      ComboBoxFormat.AddItem TabSettings.ItemsCaption(i)
    Next i
    
    For i = 0 To ComboBoxFormat.ListCount - 1
      If ComboBoxFormat.List(i) = TabData.LastChoosenSchema Then
        ComboBoxFormat.Listindex = i
        Exit For
      End If
    Next i
    If ComboBoxFormat.Listindex < 0 Then
      If ComboBoxFormat.ListCount <> 0 Then ComboBoxFormat.Listindex = 0
    End If
  Else
    MsgBox "Es wurden keine Schemadefinitionen gefunden. Eine Kalendererstellung ist nicht m|fffd|glich.", vbCritical, CTitleMsgBox
  End If
  
  ComboBoxWorkbooks.Clear
  For i = 1 To Workbooks.count
    If Workbooks(i).Name <> ActiveWorkbook.Name Then
      ComboBoxWorkbooks.AddItem Workbooks(i).Name
    Else
      LabelCurrentmapName.Caption = Workbooks(i).Name
    End If
  Next i
  If ComboBoxWorkbooks.ListCount <> 0 Then
    OptionButtonExistingmap.Enabled = True
    ComboBoxWorkbooks.Listindex = 0
    ComboBoxWorkbooks.Enabled = True
  Else
    If Not OptionButtonNewmap.Value Then _
      If Not OptionButtonCurrentMap.Value Then _
        OptionButtonNewmap.Value = True
    OptionButtonExistingmap.Enabled = False
    ComboBoxWorkbooks.Enabled = False
  End If

  ComboboxMonatFill ComboBoxMonthFrom
  ComboboxMonatFill ComboBoxMonthTo
  
  If TabData.LastChoosenDateHave(True) Then
    SpinButtonFrom.Value = Year(TabData.LastChoosenDate(True))
    ComboBoxMonthFrom.Listindex = Month(TabData.LastChoosenDate(True)) - 1
  Else
    SpinButtonFrom.Value = Year(Date + 365 / 2)
    ComboBoxMonthFrom.Listindex = 0
  End If
  
  If TabData.LastChoosenDateHave(False) Then
    SpinButtonTo.Value = Year(TabData.LastChoosenDate(False))
    ComboBoxMonthTo.Listindex = Month(TabData.LastChoosenDate(False)) - 1
  Else
    SpinButtonTo.Value = SpinButtonFrom.Value
    ComboBoxMonthTo.Listindex = 11
  End If
  

  ComboBoxFormat.SetFocus
End Sub


Private Sub UserForm_Initialize()
  UserForm_Init
  CheckButtons
End Sub


Private Property Get WorkbookName() As String
  WorkbookName = fWorkbookName
End Property


Private Property Let WorkbookName(NewWorkbookName As String)
  fWorkbookName = NewWorkbookName
End Property


Attribute VB_Name = "Inifile"
Option Explicit

Global Const CIniDelimiterCharCode As Byte = 124 ' Asc("|")

Public Const CIniPrefixUserdef          As String = "Userdef"
Public Const CIniPrefixFrmStrToc        As String = "FrmStrToc"
Public Const CIniPrefixComment          As String = "Comment"


Public Const CIniSection_Global         As String = "Global"

Public Const CIniKeyNext                As String = "Next"
Public Const CIniKeyCommentlist         As String = "Comments"

Private Const CInifileVersion           As Integer = 0
Private Const CIniKey_IniFileversion    As String = "Version"


Private Const CRaiseErr = vbObjectError + 1050



Private Const CIniKeyCol            As String = "Col"
Private Const CIniKeyHeight         As String = "Height"
Private Const CIniKeyLeft           As String = "Left"
Private Const CIniKeyLocked         As String = "Locked"
Private Const CIniKeyPlacement      As String = "Placement"
Private Const CIniKeyRow            As String = "Row"
Private Const CIniKeyShadow         As String = "Shadow"
Private Const CIniKeyShape          As String = "Shape"
Private Const CIniKeyText           As String = "Text"
Private Const CIniKeyTop            As String = "Top"
Private Const CIniKeyVisible        As String = "Visible"
Private Const CIniKeyWidth          As String = "Width"



Private fNextFreeSectionID As Integer
Private fInifilename As String
Private fInifileVersion As Integer


Public Function InifileIsOpen() As Boolean
  InifileIsOpen = fInifilename <> ""
End Function


Public Function InifileName() As String
  InifileName = fInifilename
End Function


Public Function InifileOpen(ByVal AInifilename As String, ByVal OpenForWrite As Boolean) As Boolean
  InifileOpen = True
  
  If InifileIsOpen Then
    Exit Function ' Mehrfach|fffd|ffnung ist unproblematisch
  End If
  
  AInifilename = Trim(AInifilename)
  If AInifilename = "" Then
    InifileOpen = False
    Exit Function
  End If
  
  fNextFreeSectionID = 0
  fInifilename = AInifilename
  
  If OpenForWrite Then
    SaveToOpenIniFileInteger CIniSection_Global, CIniKey_IniFileversion, CInifileVersion
    fInifileVersion = CInifileVersion
  Else
    fInifileVersion = LoadFromOpenInifileInteger(CIniSection_Global, CIniKey_IniFileversion, -1)
    If fInifileVersion < 0 Then
      MsgBox "Unbekannte Dateiversion: " & AInifilename, vbCritical, CTitleMsgBox
      InifileClose
      InifileOpen = False
      Exit Function
    End If
  End If
    
  
End Function


Public Sub InifileClose()
  fInifilename = ""
  fNextFreeSectionID = 0
End Sub


Public Function InifileVersion() As Integer
  If InifileIsOpen Then
    InifileVersion = fInifileVersion
  Else
    Err.Raise CRaiseErr, , "Inidatei nicht offen"
  End If
End Function


Public Function LoadFromOpenIniFileBoolean(ByVal Section As String, ByVal Key As String, ByVal Default As Boolean) As Boolean
  LoadFromOpenIniFileBoolean = IniReadBoolean(Section, Key, Default, InifileName)
End Function



Public Function LoadFromOpenIniFileCharacters(ByVal Section As String, ACharacters As Characters) As Boolean
Dim i As Integer
Dim NextSection As String, s As String

  
  ACharacters.Text = ""
  NextSection = Section
  
  While NextSection <> ""
    NextSection = IniReadFormattedStringToken(NextSection, s, TabData.TempRow.Cells(1, 1).Font, InifileName)
    i = Len(ACharacters.Text) + 1
    ACharacters.Parent.Characters(i, 1).Insert decodeURI(s, True)
    
    CopyFont TabData.TempRow.Cells(1, 1).Font, ACharacters.Parent.Characters(i, Len(s)).Font
  Wend
  
  
End Function


Public Sub LoadFromOpenIniFileComment(ByVal Section As String, ByRef AComment As Comment)
  AComment.Text decodeURI(LoadFromOpenIniFileString(Section, CIniKeyText), True)
  LoadFromOpenIniFileShape LoadFromOpenIniFileString(Section, CIniKeyShape), AComment.Shape
End Sub


Public Function LoadFromOpenIniFileCommentPos(ByVal Section As String, ByRef ARow As Long, ByRef ACol As Long) As Boolean
' Versucht die Koordinaten des Kommentars zu lesen und gibt sie und TRUE zur|fffd|ck, falls erfolgreich, ansonsten FALSE
Dim x As Integer, y As Integer
  LoadFromOpenIniFileCommentPos = False
  y = LoadFromOpenInifileInteger(Section, CIniKeyRow, -1)
  If y = -1 Then Exit Function
  x = LoadFromOpenInifileInteger(Section, CIniKeyCol, -1)
  If x = -1 Then Exit Function
  ARow = y
  ACol = x
  LoadFromOpenIniFileCommentPos = True
End Function


Public Sub LoadFromOpenIniFileFont(ByVal Section As String, AFont As Font)
  IniReadFont Section, AFont, InifileName
End Sub

Public Function LoadFromOpenInifileInteger(ByVal Section As String, ByVal Key As String, ByVal Default As Integer) As Integer
  LoadFromOpenInifileInteger = IniReadInteger(Section, Key, Default, InifileName)
End Function

Public Function LoadFromOpenInifileLong(ByVal Section As String, ByVal Key As String, ByVal Default As Long) As Long
  LoadFromOpenInifileLong = IniReadLong(Section, Key, Default, InifileName)
End Function


Public Sub LoadFromOpenIniFileShape(ByVal Section As String, AShape As Shape)
  IniReadShape Section, AShape, InifileName
  'AShape.Width = LoadFromOpenIniFileDouble(Section, CIniKeyWidth, 10)
  'AShape.Height = LoadFromOpenIniFileDouble(Section, CIniKeyHeight, 10)
  'AShape.Top = LoadFromOpenIniFileDouble(Section, CIniKeyTop, 10)
  'AShape.Left = LoadFromOpenIniFileDouble(Section, CIniKeyLeft, 10)
  ''AShape.Shadow = LoadFromOpenIniFileBoolean(Section, CIniKeyShadow, False)
  'AShape.Visible = LoadFromOpenInifileInteger(Section, CIniKeyVisible, msoTrue)
  'AShape.Placement = LoadFromOpenInifileInteger(Section, CIniKeyPlacement, xlFreeFloating)
  'AShape.Locked = LoadFromOpenIniFileBoolean(Section, CIniKeyLocked, True)
End Sub




Public Function LoadFromOpenIniFileDouble(ByVal Section As String, ByVal Key As String, ByVal Default As Double) As Double
  LoadFromOpenIniFileDouble = IniReadDouble(Section, Key, Default, InifileName)
End Function


Public Function LoadFromOpenIniFileString(ByVal Section As String, ByVal Key As String) As String
  LoadFromOpenIniFileString = IniReadString(Section, Key, "", InifileName)
End Function


Function NextFreeSectionID() As Integer
  NextFreeSectionID = fNextFreeSectionID
  fNextFreeSectionID = fNextFreeSectionID + 1
End Function



Public Sub SaveToOpenIniFileBoolean(ByVal Section As String, ByVal Key As String, ByVal Value As Boolean)
  IniWriteBoolean Section, Key, Value, InifileName
End Sub



Function SaveToOpenIniFileCharacters(ByVal SectionPrefix As String, ACharacters As Excel.Characters) As String
' Liefert den ersten Sectionname zur|fffd|ck
Dim i As Integer, LastI As Integer
Dim LastFmtStrSection As String, FmtStrSection  As String, FontSection As String
  
  LastFmtStrSection = ""
  LastI = 1
  i = 1
  While (i <= ACharacters.count)
    FmtStrSection = SectionPrefix & CStr(NextFreeSectionID)
    FontSection = CIniSection_PrefixFont & CStr(NextFreeSectionID)
    i = LastI + 1
    While (i <= ACharacters.count) And (FontsEqual(ACharacters.Parent.Characters(LastI, 1).Font, ACharacters.Parent.Characters(i, 1).Font))
      i = i + 1
    Wend
    IniWriteFormattedStringToken FmtStrSection, encodeURI(ACharacters.Parent.Characters(LastI, i - LastI).Text, True), FontSection, ACharacters.Parent.Characters(LastI, 1).Font, InifileName
    If LastFmtStrSection <> "" Then
      SaveToOpenIniFileString LastFmtStrSection, CIniKeyNext, FmtStrSection
    Else
      SaveToOpenIniFileCharacters = FmtStrSection
    End If
    LastFmtStrSection = FmtStrSection
    LastI = i
  Wend
  
  ' Fertig:
  If LastFmtStrSection <> "" Then IniDeleteKey LastFmtStrSection, CIniKeyNext, InifileName
  
End Function


Public Sub SaveToOpenIniFileComment(ByVal Section As String, AComment As Comment, ByVal ARow As Long, ACol As Long)
Dim SectionShape As String
  SaveToOpenIniFileLong Section, CIniKeyRow, ARow
  SaveToOpenIniFileLong Section, CIniKeyCol, ACol
  SaveToOpenIniFileString Section, CIniKeyText, encodeURI(AComment.Text, True)
  SectionShape = CIniSection_PrefixShape & NextFreeSectionID
  SaveToOpenIniFileString Section, CIniKeyShape, SectionShape
  SaveToOpenIniFileShape SectionShape, AComment.Shape
End Sub



Public Function SaveToOpenIniFileFont(AFont As Font) As String
' R|fffd|ckgabe: Name der Ini-Sektion
Dim SectionName As String

  If Not InifileIsOpen Then Err.Raise CRaiseErr
  SectionName = CIniSection_PrefixFont & CStr(NextFreeSectionID)
  If IniWriteFont(SectionName, AFont, InifileName) Then
    SaveToOpenIniFileFont = SectionName
  Else
    SaveToOpenIniFileFont = ""
  End If
End Function


Public Sub SaveToOpenIniFileInteger(ByVal Section As String, ByVal Key As String, ByVal Value As Integer)
  IniWriteInteger Section, Key, Value, InifileName
End Sub

Public Sub SaveToOpenIniFileLong(ByVal Section As String, ByVal Key As String, ByVal Value As Long)
  IniWriteLong Section, Key, Value, InifileName
End Sub


Public Sub SaveToOpenIniFileShape(ByVal Section As String, AShape As Shape)
  IniWriteShape Section, AShape, InifileName
End Sub

  

Public Sub SaveToOpenIniFileString(ByVal Section As String, ByVal Key As String, ByVal Value As String)
  IniWriteString Section, Key, Value, InifileName
End Sub


Public Sub SaveToOpenIniFileDouble(ByVal Section As String, ByVal Key As String, ByVal Value As Double)
  IniWriteDouble Section, Key, Value, InifileName
End Sub



Public Function SaveToOpenIniFileInterior(AInterior As Interior) As String
' R|fffd|ckgabe: Name der Ini-Sektion
Dim SectionName As String

  If Not InifileIsOpen Then Err.Raise CRaiseErr
  SectionName = CIniSection_PrefixInterior & CStr(NextFreeSectionID)
  If IniWriteInterior(SectionName, AInterior, InifileName) Then
    SaveToOpenIniFileInterior = SectionName
  Else
    SaveToOpenIniFileInterior = ""
  End If
End Function

Public Sub LoadFromOpenIniFileInterior(ByVal Section As String, ByRef AInterior As Interior)
  IniReadInterior Section, AInterior, InifileName
End Sub



Function TokenNext_boolean(ByVal s As String, ByVal DelimiterCharCode As Byte, ByRef Value As Boolean, ByRef Index As Long) As Boolean
Dim token As String
  
  If TokenNext(s, DelimiterCharCode, token, Index, False) Then
    If token = "0" Then
      Value = False
      GoTo OkAndExit
    Else
      If token = "1" Then
        Value = True
        GoTo OkAndExit
      End If
    End If
  End If
  GoTo FailAndExit
  
OkAndExit:
  TokenNext_boolean = True
  Index = Index + 1
  Exit Function

FailAndExit:
  TokenNext_boolean = False
  Exit Function
  
End Function


Function TokenNext_long(ByVal s As String, ByVal DelimiterCharCode As Byte, ByRef Value As Long, ByRef Index As Long) As Boolean
Dim token As String
  If TokenNext(s, DelimiterCharCode, token, Index, False) Then
    If IsNumeric(Value) Then
      Value = CLng(token)
      Index = Index + 1
      TokenNext_long = True
      Exit Function
    End If
  End If
  TokenNext_long = False
End Function

Attribute VB_Name = "KalenderGlobal"
Option Explicit
Option Private Module



Global Const CVersionMain = 8
Global Const CVersionSub = "6.1"



Global Const CPassword = "16B280C8-EE70-11D1-9066-00C04FD9189D"

Global Const CColsPerMonth As Byte = 3             'Wie viele Spalten pro Monat?


Global Const CYearMin = 1900
Global Const CYearMax = 2099

Global Const CDateStrMin = "1.1." & CYearMin
Global Const CDateStrMax = "31.12." & CYearMax



' *********************** interne "Variablen" ***********************
Global Const CVersionStr = "v" & CVersionMain & "." & CVersionSub & " vom 30.11.2009"
Global Const CProgrammname = "Kalendererstellung"
Global Const CTitleMsgBox = "Kalender-Excel " & CVersionStr


Global Const CURLUpdates = "http://www.msdatec.de/kalender-info.htm"
Global Const CURLForum = "http://www.msdatec.de/forum/viewforum.php?f=3"


Global Const CColCountHolidayDates = 12         ' Wie viele Spalten mit Standard-Ferienterminen gibt es? Gilt f|fffd|r Tabelle *TabHolidays* und *TabHolidaysAll*
Global Const CColCountHolidaySingles = 4        ' Wie viele Spalten mit einzelnen Ferienterminen gibt es? Gilt f|fffd|r Tabelle *TabHolidays* und *TabHolidaysAll*




'Global Const CFormatCellRange = "B1"            ' Wo ist die Zelle mit der Format-Vorgabe? (gilt f|fffd|r Tabelle
                                                ' *TabPublics* sowie *TabHolidays*

Global Const CPublicCount = 18                         'Wie viele Feiertage m|fffd|ssen mindestens
'ber|fffd|cksichtigt werden? (Entspricht der Anzahl der Spalten im Bereich '"Feiertagsbenennungen")

Global Const CInfoCheckboxZeileLicence = 2
Global Const CInfoCheckboxZeileBundesland = 3
Global Const CInfoCheckboxZeileFeiertage = 4
Global Const CInfoCheckboxZeileSchulferien = 5
Global Const CInfoCheckboxZeileYearly = 6
Global Const CInfoCheckboxZeileCyclic = 7
Global Const CInfoCheckboxZeileMakeCalendar = 8

' Konstanten f|fffd|r Ini-Dateien:
Global Const CIniValueNameFont As String = "FontDef"


    


    
Sub ButtonInfoClick()
Dim s As String
  
  s = vbNewLine & vbNewLine
  If Registered Then
    s = s & "Registriert f|fffd|r " & TabData.Kundenangaben
  Else
    s = s & "Dies ist eine nicht lizensierte Version"
  End If
  MsgBox CTitleMsgBox + vbNewLine + vbNewLine + _
    String(1, 169) + " 1995-2009 by" + vbNewLine + _
    "Matthias Stolte Datentechnik" + vbNewLine + _
    "33613 Bielefeld, Albert-Schweitzer-Str. 13" + vbNewLine + _
    "Web: http://www.msdatec.de/" + vbNewLine + _
    "Alle Ferien- und Feiertags- und sonstige Datumsangaben ohne Gew|fffd|hr!" + vbNewLine + _
     vbNewLine + _
    "Die private Nutzung ist kostenlos," + vbNewLine + _
    "die Weitergabe der nicht lizensierten Version erlaubt." + vbNewLine + _
    "Die nicht private Nutzung ist lizenzpflichtig." & s, 64, "Willkommen"

End Sub




Sub ButtonSelectInfos_Click()
  WorkSheetSelect TabInfos
End Sub
    
    
    
    
Sub DateCorrect(ByVal Jahr As Integer, ByRef ADate As Date)
  If Year(ADate) < Jahr Then
    ADate = DateSerial(Jahr, 1, 1)
  Else
    If Year(ADate) > Jahr Then ADate = DateSerial(Jahr, 12, 31)
  End If
  
End Sub
    
    
    
Private Function DayIsWorkday(ByVal ADate As Long, ByVal SaturdayIsWorkday) As Boolean
' Hilfsfunktion zu *WorkdayPrev* und *WorkdayNext*
Dim b As Byte
  
  DayIsWorkday = False
  b = Weekday(ADate)
  
  If b = vbSunday Then Exit Function
  If Not SaturdayIsWorkday Then
    If b = vbSaturday Then Exit Function
  End If
  DayIsWorkday = Not TabPublics.IsPublic(ADate)
End Function
    
    
Sub DefaultFont(AFont As Font)
  AFont.Size = CDefault_Font_Size
  AFont.Bold = CDefault_Font_Bold
  AFont.Color = CDefault_Font_Color
  AFont.Italic = CDefault_Font_Italic
  AFont.Name = CDefault_Font_Name
  AFont.Strikethrough = CDefault_Font_Strikethrough
  AFont.Subscript = CDefault_Font_Subscript
  AFont.Superscript = CDefault_Font_Superscript
  AFont.Underline = CDefault_Font_Underline
End Sub

    
Sub DefaultInterior(AInterior As Interior)
  AInterior.ColorIndex = xlColorIndexAutomatic
  AInterior.Color = 16777215
  AInterior.Pattern = xlPatternAutomatic
  AInterior.PatternColor = 0
  AInterior.PatternColorIndex = xlColorIndexAutomatic
End Sub

    
    
Sub EMailSend(Optional ByVal EMailSubject As String, Optional ByVal EMailBody As String)
Dim Params As String
Dim MailAdress As String

  MailAdress = "MailTo:" & TabData.EMailAddress
  
  If EMailSubject <> "" Then Params = "subject=" & EMailSubject
  If EMailBody <> "" Then
    If Params <> "" Then Params = Params & "&"
    Params = Params & "body=" & EMailBody
  End If
  If Params <> "" Then Params = "?" & Params
  TabData.Range(TabData.EMailAddressRange).Hyperlinks.Add TabData.Range(TabData.EMailAddressRange), MailAdress & Params
  TabData.Range(TabData.EMailAddressRange).Hyperlinks(1).Follow
  TabData.Range(TabData.EMailAddressRange).Hyperlinks(1).Delete
End Sub
    




Public Function FerienArrayGet(ATable As Worksheet, ByVal ARow As Integer, ByVal StartCol As Byte)
Dim i As Byte
Dim Feriendata()
  
  ReDim Feriendata(11)
  For i = 0 To 11
    Feriendata(i) = ATable.Cells(ARow, i + StartCol)
  Next i
  'i = i + 1
  While ATable.Cells(ARow, i + StartCol) <> ""
    ReDim Preserve Feriendata(i)
    Feriendata(i) = ATable.Cells(ARow, i + StartCol)
    i = i + 1
  Wend
  Let FerienArrayGet = Feriendata
End Function

    


Function Help(ByVal NamedAnchor As String) As Boolean
Dim Filename As String
Dim ErrCode As Long

  Help = False
  Filename = TabData.FilenameHelp
  If (Filename = "") Or (Not FileExists(Filename)) Then
    Filename = DirBS(ThisWorkbook.Path) & "docs\Kalender-Excel" & "-" & CStr(CVersionMain) & "." & CStr(CVersionSub) & ".htm"
  End If
  If Not FileExists(Filename) Then
    If MsgBox("Die Hilfedatei konnte nicht gefunden werden. M|fffd|chten Sie danach suchen?", vbQuestion Or vbYesNo, CTitleMsgBox) <> vbYes Then Exit Function
    If Not FileOpenDLG("htm", "HTML-Dateien (*.htm)|*.htm", Filename, "Hilfedatei ausw|fffd|hlen") Then Exit Function
  End If
  If ShellOpenHTMLFile(Filename, NamedAnchor, ErrCode) Then
    TabData.FilenameHelp = Filename
    Help = True
  End If

End Function
    

Function IsInDateWindow(ByVal ADate As Long, ByVal DateStart As Long, ByVal DateEnd As Long) As Boolean
  IsInDateWindow = ADate >= DateStart And ADate <= DateEnd
End Function

    
    

    
Function KalenderblattEinf|fffd|gen(ByVal AWorkBookName As String, ByVal ATableName As String, ByVal CalendarFormatIndex As Byte) As Boolean
Dim DestTable As Worksheet

  If WorkSheetInsert(AWorkBookName, ATableName, True) Then
    KalenderblattEinf|fffd|gen = True
    Set DestTable = Workbooks(AWorkBookName).Worksheets(ATableName)
    'DestTable.Cells.Font.Size = TabSettings.ItemsDatumFont(CalendarFormatIndex).Size
    DestTable.Rows.RowHeight = TabSettings.ItemsLineHeightMin(CalendarFormatIndex)
  Else
    KalenderblattEinf|fffd|gen = False
  End If

End Function
    
    
Sub MakeDist()
  TabHolidays.MakeDist
  TabPublics.MakeDist
  TabYearly.MakeDist
  TabCyclic.MakeDist
  TabSettings.MakeDist
  TabData.MakeDist
  TabData.LastChoosenSchema = "A4, 2 Blatt"
  TabInfos.MakeDist
  TabMacrosdisabled.Visible = xlSheetVisible
  TabMacrosdisabled.Activate
  TabInfos.Visible = xlSheetHidden
End Sub
    
    
    
    
Function Registered() As Boolean
  Registered = (TabData.Kundenangaben <> "") And TabData.RegistrierungscodeOk(TabData.Registrierungscode)
End Function
    
    

    
Function WorkdayNext(ByVal ADate As Long, ByVal SaturdayIsWorkday) As Long
  Do
    ADate = ADate + 1
  Loop Until DayIsWorkday(ADate, SaturdayIsWorkday)
  WorkdayNext = ADate
End Function
    
    

Function WorkdayPrev(ByVal ADate As Long, ByVal SaturdayIsWorkday) As Long
  Do
    ADate = ADate - 1
  Loop Until DayIsWorkday(ADate, SaturdayIsWorkday)
  WorkdayPrev = ADate
End Function


   
    
Sub SetzeFont(ByVal zeile As Integer, ByVal spalte As Integer, ByVal AWorkSheet As Worksheet, AFont As Font, Optional AVerticalAlignment, Optional FontSizeScale)
  CopyFont AFont, AWorkSheet.Cells(zeile, spalte).Font
  If Not IsMissing(FontSizeScale) Then AWorkSheet.Cells(zeile, spalte).Font.Size = AWorkSheet.Cells(zeile, spalte).Font.Size * FontSizeScale
  If Not IsMissing(AVerticalAlignment) Then AWorkSheet.Cells(zeile, spalte).VerticalAlignment = AVerticalAlignment
  'With AWorkSheet.Cells(Zeile, Spalte)
  '  .Font.Name = AFont.Name
  '  .Font.Size = AFont.Size
  '  .Font.FontStyle = AFont.FontStyle
  '  .Font.Color = AFont.Color
  '  If Not IsMissing(AVerticalAlignment) Then .VerticalAlignment = AVerticalAlignment
  'End With
End Sub
    
    
    
    
    


    
    

    
Function SucheJahresZeile(ATable As Worksheet, ByVal Kalenderjahr As Integer, ByVal zeile As Integer, ByVal spalte As Integer) As Integer
' Sucht in der Tabelle *ATable* in der *Spalte* ab ausschlie|fffd|lich *Zeile*
' nach einer Zelle, die das angegebene *KalenderJahr* enth|fffd|lt und liefert die
' entsprechende Zeilennummer zur|fffd|ck.
' Falls keine Zelle gefunden wurde, wird 0 zur|fffd|ckgegeben.
' Mit der ersten leeren Zelle endet der Suchvorgang

  SucheJahresZeile = 0
  Do
    zeile = zeile + 1
    If ATable.Cells(zeile, spalte) = "" Then Exit Function
  Loop Until ATable.Cells(zeile, spalte) = Kalenderjahr
  SucheJahresZeile = zeile
End Function
    

    
Function UnprotectCalendarWorksheet(AWorkSheet As Worksheet, ByVal APassword As String, ByRef WasProtected As Boolean) As Boolean

  If WorksheetUnprotect(AWorkSheet, APassword, WasProtected) Then
    UnprotectCalendarWorksheet = True
  Else
    UnprotectCalendarWorksheet = False
    MsgBox AWorkSheet.Name & ": Kann den Blattschutz aus unbekannten Gr|fffd|nden nicht aufheben", vbCritical, CTitleMsgBox
  End If
  
End Function
 


Public Sub URLFollow(ByVal URL As String)
Dim wshshell As Object
  Set wshshell = CreateObject("WScript.Shell")
  wshshell.Run URL
End Sub




Attribute VB_Name = "KalenderPublic"
Option Explicit
' Modul f|fffd|r |fffd|ffentlich zug|fffd|ngliche Routinen



Public Function ArbeitstageMonat(ByVal Monat As Byte, ByVal Jahr As Integer, ByVal SamstagZaehlen As Boolean) As Byte
Dim i As Byte
Dim ADate As Long
Dim b As Byte
  
  ADate = DateSerial(Jahr, Monat, 1)
  Do
    b = Weekday(ADate)
    If b <> vbSunday Then
      If (b <> vbSaturday) Or SamstagZaehlen Then
        If Not TabPublics.IsPublic(ADate) Then i = i + 1
      End If
    End If
    ADate = ADate + 1
  Loop Until Month(ADate) <> Monat
fertig:
  ArbeitstageMonat = i
End Function


Public Function Busstag(ByVal Jahr As Integer) As Long
Dim ADate As Long
Dim Tag As Byte
  
  ADate = DateSerial(Jahr, 12, 25)
  Tag = Weekday(ADate) - 1
  If Tag = 0 Then Tag = 7
  Busstag = ADate - Tag - 4 * 7 - 4
End Function


Private Function KalenderDatumBeginnEnde(ByVal GetFromDate As Boolean) As Long
  Application.Volatile
  If TabData.LastChoosenDateHave(GetFromDate) Then
    KalenderDatumBeginnEnde = TabData.LastChoosenDate(GetFromDate)
  Else
    KalenderDatumBeginnEnde = Date
  End If
End Function

Function KalenderDatumBeginn() As Long
  KalenderDatumBeginn = KalenderDatumBeginnEnde(True)
End Function
  
Function KalenderDatumEnde() As Long
  KalenderDatumEnde = KalenderDatumBeginnEnde(False)
End Function

Function KalenderDatumMitte() As Long
  KalenderDatumMitte = (KalenderDatumEnde + KalenderDatumBeginn) \ 2
End Function




Function KalenderWochenBeginn(ByVal Kalenderwoche As Byte, ByVal Kalenderjahr As Integer) As Variant
' Berechnet den Montag, der in der angegebenen Kalenderwoches des Kalenderjahres liegt.
' Falls die Kalenderwoche nicht im angegebenen Kalenderjahr liegt (alles au|fffd|er 1 bis
' 52; 53 nur in Kombination bestimmten Jahren, z.B. 1992, 1998, 2004, 2009, 2015), wird ein Fehlerwert
' zur|fffd|ckgegeben.
' Zur Berechnung der Kalenderwochen:
' Aus den Weiten des www:
'---8<---
'F|fffd|r die Wochenz|fffd|hlung nach DIN, welche seit 1972 konsequent angewendet
'wird, gilt folgende Norm: |fffd|Bei der Nummerierung der Kalenderwochen z|fffd|hlt
'als erste Kalenderwoche eines Kalenderjahres diejenige Woche, in die die
'ersten vier oder mehr Januartage fallen|fffd|. Die erste Kalenderwoche eines
'Kalenderjahres ist also diejenige, die den ersten Donnerstag des
'Kalenderjahres enth|fffd|lt.
'---8<---
' Bleibt noch die Frage, mit welchem Wochentag die Woche beginnt: Hier
' wird *Montag* unterstellt
Const CVErrValue = 1
Dim dat As Date, FirstDayOfYear As Date
Dim i As Integer

  KalenderWochenBeginn = CVErr(CVErrValue)
  
  If Kalenderwoche = 0 Then
    Exit Function
  Else
    If Kalenderwoche > 53 Then
      Exit Function
    End If
  End If
      
    
  FirstDayOfYear = DateSerial(Kalenderjahr, 1, 1)
  dat = FirstDayOfYear
  While Weekday(dat) <> vbMonday
    dat = dat + 1
  Wend

  If dat - FirstDayOfYear < 4 Then
    i = 1
  Else
    i = 2
    If Kalenderwoche < i Then
      KalenderWochenBeginn = dat - 7
      Exit Function
    End If
  End If
  
 dat = dat + (Kalenderwoche - i) * 7
 If Kalenderwoche = 53 Then
   If Year(dat) > Kalenderjahr Then Exit Function
   FirstDayOfYear = DateSerial(Kalenderjahr + 1, 1, 1)
   If FirstDayOfYear - dat < 4 Then Exit Function
   KalenderWochenBeginn = dat
 Else
   KalenderWochenBeginn = dat
 End If
  

End Function



Public Function OsterSonntag(ByVal Jahr As Integer) As Long
  OsterSonntag = EasterSunday(Jahr)
End Function


Public Function VersionMain() As Byte
  VersionMain = CVersionMain
End Function

Public Function VersionSub() As Byte
  VersionSub = CVersionSub
End Function

Attribute VB_Name = "Licence"
Option Private Module
Option Explicit

' letzte |fffd|nderung: 18.11.03-2



Public Function RegistrierungscodeOk(ByVal NewRegistrierungscode As String) As Boolean
Dim Programmname As String, dummy As String
Dim MainVersion As Byte

  RegistrierungscodeOk = RegStr2UserData(NewRegistrierungscode, dummy, Programmname, MainVersion) _
    And (Programmname = CProgrammname) _
    And (CVersionMain = MainVersion)
End Function


Function RegStrExtractKundenAngaben(ByVal RegStr As String) As String
Dim AKundenAngaben As String, AProgrammname As String, AMainVersion As Byte
  
  If RegStr2UserData(RegStr, AKundenAngaben, AProgrammname, AMainVersion) Then
    RegStrExtractKundenAngaben = AKundenAngaben
  Else
    RegStrExtractKundenAngaben = ""
  End If
End Function


Function RegStr2UserData(ByVal RegStr As String, ByRef AKundenAngaben As String, ByRef AProgrammname As String, ByRef AMainVersion As Byte) As Boolean
Dim ACheckSum As Long
Dim Index As Long
Static LastRegStr As String, LastKundenAngaben As String, LastProgrammname As String
Static LastMainVersion As Byte
Static LastRegStr2UserData As Boolean

  If RegStr = LastRegStr Then
    AKundenAngaben = LastKundenAngaben
    AProgrammname = LastProgrammname
    AMainVersion = LastMainVersion
    RegStr2UserData = LastRegStr2UserData
    GoTo Exit_RegStr2UserData
  Else
     LastRegStr = RegStr
     LastKundenAngaben = ""
     LastProgrammname = ""
  End If
  
  If Not Base64DecodeStr(RegStr, RegStr, True) Then GoTo ExitWithFalse_RegStr2UserData
  Index = 1
  If Not PascalStr8Extract(RegStr, Index, AKundenAngaben) Then GoTo ExitWithFalse_RegStr2UserData
  If Not PascalStr8Extract(RegStr, Index, AProgrammname) Then GoTo ExitWithFalse_RegStr2UserData
  If Index + 1 > Len(RegStr) Then GoTo ExitWithFalse_RegStr2UserData
  AMainVersion = Asc(Mid(RegStr, Index, 1))
  
  If Index + 4 > Len(RegStr) Then GoTo ExitWithFalse_RegStr2UserData
  ACheckSum = StrToInt32(Mid(RegStr, Index + 1, 4))
  If CheckSum(Left(RegStr, Index)) <> ACheckSum Then GoTo ExitWithFalse_RegStr2UserData
  RegStr2UserData = True
  LastRegStr2UserData = True
  LastKundenAngaben = AKundenAngaben
  LastProgrammname = AProgrammname
  LastMainVersion = AMainVersion
  GoTo Exit_RegStr2UserData

Err_RegStr2UserData:
  Resume ExitWithFalse_RegStr2UserData
  
ExitWithFalse_RegStr2UserData:
  RegStr2UserData = False
  LastRegStr2UserData = False
  GoTo Exit_RegStr2UserData

Exit_RegStr2UserData:
End Function




Private Function UserData2RegStr(ByVal AKundenAngaben As String, ByVal AProgrammname As String, ByVal AMainVersion As Byte) As String
Dim result As String
  result = _
      PascalStr8(AKundenAngaben) _
    & PascalStr8(AProgrammname) _
    & Chr(AMainVersion)
  UserData2RegStr = Base64EncodeStr(result & Int32ToStr(CheckSum(result)))
End Function


































Attribute VB_Name = "MSD_All"
Option Explicit
Option Private Module

' Library for global VBA routines
' last change: 2009/05/19
' Modul dependencies: [none]

' DON'T MAKE ANY CHANGES!
' All your changes will be lost with the next update of this library.
' Contact the author <ms@msdatec.de> for bug fixes or enhancements instead.

' BITTE KEINE |fffd|NDERUNGEN DURCHF|fffd|HREN!
' Alle |fffd|nderungen, die Sie hier vornehmen, gehen mit dem n|fffd|chsten Update dieses Modules verloren.
' Kontaktieren Sie anstattdessen den Autor unter <ms@msdatec.de> f|fffd|r Fehlerkorrekturen oder Verbesserungen.

' All rights of this code are reserved by MSDatec.
' See http://www.msdatec.de/ for further information.
' You are allowed to use and modify this code for personal use.
' You are NOT allowed to publish or distribute this code or parts of it
' without a written permission of MSDatec.

' Alle Rechte deses Codes liegen bei MSDatec.
' Unter http://www.msdatec.de/ finden Sie weitere Informationen sowie Kontaktm|fffd|glichkeiten.
' Sie d|fffd|rfen f|fffd|r Ihre eigenen Bed|fffd|rfnisse diesen Code benutzen und ver|fffd|ndern.
' Sie d|fffd|rfen NICHT diesen Code oder Teile desselben ohne eine schriftliche Genehmigung
' von MSDatec publizieren oder Dritten zug|fffd|nglich machen.

' History:
' 2009/05/19: introduced const *CTitleMsgBox*
' 2008/04/19: *VersionStrToLong* eingef|fffd|hrt
' 2007/10/12: Function *RoundCurrency* wieder eingef|fffd|hrt, da die Access-interne "round"-Funktion falsch arbeitet (siehe auch: http://www.donkarl.com/FAQ/FAQ2Allgemein.htm#2.1)
' 2007/09/06: Funktion *Buchwert* korrigiert - es wird nun der Buchwert zu Beginn des angegebenen Jahres ermittelt
' 2007/09/03:
' - Funktion *AbschreibungsBetrag* aufgeteilt in *AbschreibungsBetragAfABeginn* und *AbschreibungsBetragAfAEnde*
' - Funktion *Buchwert* eingef|fffd|hrt
' 2007/08/31: Funktion *AbschreibungsBetrag* korrigiert: im Bezugsmonat wird bereits mit 1/12 abgeschrieben
' 2007/07/27: Funktion *AbschreibungsBetrag* auf 12er-St|fffd|ckelung ge|fffd|ndert
' 2005/05/28: Added *Anteil* to *AbschreibungsBetrag* and *AbschreibungsBetragNormal*



Global Const CCentimetersPerInch = 2.54




Function AbschreibungsBetrag(ByVal Buchungsmonat As Byte, ByVal Buchungsjahr As Integer, ByVal JahreAbschreibungsDauer As Integer, GeschaeftsJahr As Integer, ByVal Betrag As Currency) As Currency
' Ermittelt gem|fffd||fffd| der angegebenen *JahreAbschreibungsDauer* den linearen Abschreibungsbetrag f|fffd|r *Betrag*
' in den genannten *GeschaeftsJahr* mit Ber|fffd|cksichtigung der Halbjahresgrenze.
' *Anteil* gibt den steuerrelevanten Anteil in ganzen Prozent von *Betrag* an.
' 27.07.07, ms: Ge|fffd|ndert in 12er-St|fffd|ckelung

    
  ' liegt die Buchung in der zweiten Jahresh|fffd|lfte und ist eine der Abschreibungsgrenzen erreicht?
  'If (JahreAbschreibungsDauer > 1) And (Buchungsmonat >= 6) And ((Buchungsjahr = GeschaeftsJahr) Or (Buchungsjahr + JahreAbschreibungsDauer = GeschaeftsJahr)) Then
  
  
  If (JahreAbschreibungsDauer = 1) Or (JahreAbschreibungsDauer = 0) Then
    If (Buchungsjahr = GeschaeftsJahr) Then
      AbschreibungsBetrag = Betrag
    Else
      AbschreibungsBetrag = 0
    End If
  Else
    If Buchungsjahr > GeschaeftsJahr Then
      AbschreibungsBetrag = 0
    Else
      If Buchungsjahr + JahreAbschreibungsDauer < GeschaeftsJahr Then
        AbschreibungsBetrag = 0
      Else
        If (Buchungsjahr = GeschaeftsJahr) Then
          AbschreibungsBetrag = AbschreibungsBetragAfABeginn(Buchungsmonat, JahreAbschreibungsDauer, Betrag)
        Else
          If Buchungsjahr + JahreAbschreibungsDauer = GeschaeftsJahr Then
            AbschreibungsBetrag = AbschreibungsBetragAfAEnde(Buchungsmonat, JahreAbschreibungsDauer, Betrag)
          Else
            AbschreibungsBetrag = Betrag / JahreAbschreibungsDauer
          End If
        End If
      End If
    End If
  End If
End Function



Function AbschreibungsBetragAfABeginn(ByVal Buchungsmonat As Byte, ByVal JahreAbschreibungsDauer As Integer, ByVal Betrag As Currency) As Currency
  If (JahreAbschreibungsDauer = 1) Or (JahreAbschreibungsDauer = 0) Then
    AbschreibungsBetragAfABeginn = Betrag
  Else
    AbschreibungsBetragAfABeginn = Betrag / 12 * (13 - Buchungsmonat) / JahreAbschreibungsDauer
  End If
End Function


Function AbschreibungsBetragAfAEnde(ByVal Buchungsmonat As Byte, ByVal JahreAbschreibungsDauer As Integer, ByVal Betrag As Currency) As Currency
  If (JahreAbschreibungsDauer = 1) Or (JahreAbschreibungsDauer = 0) Then
    AbschreibungsBetragAfAEnde = Betrag
  Else
    AbschreibungsBetragAfAEnde = Betrag / 12 * (Buchungsmonat - 1) / JahreAbschreibungsDauer
  End If
End Function



Function AbschreibungNormal(ByVal Buchungsjahr As Integer, ByVal JahreAbschreibungsDauer As Integer, ByVal GeschaeftsJahr As Integer, ByVal Betrag As Currency, ByVal Anteil As Byte) As Currency
' Ermittelt den linearen Abschreibungsbetrag ohne Ber|fffd|cksichtigung der Halbjahresgrenze
  If (GeschaeftsJahr >= Buchungsjahr) And (GeschaeftsJahr < Buchungsjahr + JahreAbschreibungsDauer) Then
    AbschreibungNormal = Anteil / 100 * Betrag / JahreAbschreibungsDauer
  Else
    AbschreibungNormal = 0
  End If
End Function



Function AdressOfFunc(ByVal l As Long) As Long
  AdressOfFunc = l
End Function


Function BankLeitZahlNumerisch(ByVal BLZ As String) As Long
Dim i As Integer

  i = 1
  Do
    If Mid(BLZ, i, 1) = " " Then
      BLZ = Left(BLZ, i - 1) & Right(BLZ, Len(BLZ) - i)
    Else
      i = i + 1
    End If
  Loop While i <= Len(BLZ)
  If BLZ = "" Then BankLeitZahlNumerisch = 0 Else BankLeitZahlNumerisch = CLng(BLZ)
End Function


Function BankLeitZahlStr(ByVal BLZ As String) As String
  BankLeitZahlStr = Format(BankLeitZahlNumerisch(BLZ), "000 000 00")
End Function



Function Buchwert(ByVal Buchungsmonat As Byte, ByVal Buchungsjahr As Integer, ByVal JahreAbschreibungsDauer As Integer, GeschaeftsJahr As Integer, ByVal Betrag As Currency) As Currency
' Ermittelt den Buchwert von *Betrag* f|fffd|r den Beginn des angegebenen *GeschaeftsJahr*es
Dim AfA As Currency
Dim i As Integer
  
  If (Buchungsjahr >= GeschaeftsJahr) Or (JahreAbschreibungsDauer <= 1) Then
    Buchwert = 0
    Exit Function
  End If
  
  
  i = JahreAbschreibungsDauer - (GeschaeftsJahr - Buchungsjahr) ' i = verbleibende Jahre
  If i < 0 Then
    Buchwert = 0
  Else
    AfA = AbschreibungsBetragAfABeginn(Buchungsmonat, JahreAbschreibungsDauer, Betrag)
    AfA = AfA + (JahreAbschreibungsDauer - i - 1) * Betrag / JahreAbschreibungsDauer
    Buchwert = Betrag - AfA
  End If
End Function



Function CheckSum(ByVal s As String) As Long
Dim i As Long
Dim result As Long

  result = Len(s)
  For i = 1 To Len(s)
    result = result + Asc(Mid(s, i, 1)) * i
  Next i
  CheckSum = result
End Function




Function DateExists(ByVal AYear As Integer, ByVal AMonth As Byte, ByVal ADay As Byte) As Boolean
Dim ADate As Date
  ADate = DateSerial(AYear, AMonth, ADay)
  DateExists = (Month(ADate) = AMonth) And (Day(ADate) = ADay)
End Function



Function Datumszahl() As Long
' GE|fffd|NDERT: Liefert eine zehnstellige Zahl JJJJMMTT00 zur|fffd|ck, wobei JJJJ f|fffd|r das aktuelle Jahr, MM f|fffd|r
' den aktuellen Monat und TT f|fffd|r den aktuellen Tag steht.
' NEU: Liefert den in Excel/DOS/Access definierten Datumswert

 'Datumszahl = Year(Now) * 1000000 + Month(Now) * 10000 + Day(Now) * 100
 Datumszahl = Date * 100
End Function





Sub FlagDel(ByRef state As Long, ByVal Flag As Long)
  state = state And (Not Flag)
End Sub


Function FlagHas(ByVal state, Flag As Long) As Boolean
' Gibt TRUE zur|fffd|ck, wenn *Flag* in *state* gesetzt ist, ansonsten FALSE.
  FlagHas = (state And Flag) = Flag
End Function



Sub FlagSet(ByRef state As Long, ByVal Flag As Long)
  state = state Or Flag
End Sub





Function IsDay(ADay As Variant) As Boolean
  IsDay = IsNumericInRange(ADay, 1, 31)
End Function




Function IsNumericInRange(ANumber As Variant, ByVal MinVal As Integer, ByVal MaxVal As Integer) As Boolean
  If Not IsNull(ANumber) Then _
    If IsNumeric(ANumber) Then _
      If ANumber >= MinVal Then _
        If ANumber <= MaxVal Then _
          IsNumericInRange = True: Exit Function
  IsNumericInRange = False
End Function

Function IsMonth(AMonth As Variant) As Boolean
  IsMonth = IsNumericInRange(AMonth, 1, 12)
End Function





Function MaxInt(ByVal int1 As Integer, ByVal int2 As Integer) As Integer
  If int1 > int2 Then MaxInt = int1 Else MaxInt = int2
End Function


Function MaxSng(ByVal s1 As Single, ByVal s2 As Single) As Integer
  If s1 > s2 Then MaxSng = s1 Else MaxSng = s2
End Function


Sub Oops(Optional msg As String = "(keine)")
  MsgBox "Dieses Dialogfenster sollte nie erscheinen. Bitte benachrichtigen Sie den Programmautor." & vbNewLine _
    & "Erweiterte Informationen: " & msg, vbCritical, CTitleMsgBox
End Sub



Function RoundCurrency(ByVal param As Variant) As Currency
Dim i As Currency
  
 If Not IsNull(param) Then
    i = Fix(param * 1000)
    If i Mod 10 >= 5 Then
      RoundCurrency = Fix(param * 100 + 1) / 100
    Else
      RoundCurrency = Fix(param * 100) / 100
    End If
  Else
    RoundCurrency = 0
  End If
End Function


Function VariantToCurrency(ByVal v As Variant) As Currency
  If IsNull(v) Then VariantToCurrency = 0 Else VariantToCurrency = CCur(v)
End Function


Function VariantToDate(ByVal param) As Date
  If IsNull(param) Then VariantToDate = 0 Else VariantToDate = CDate(param)
End Function


Function VariantToLong(ByVal param) As Long
  If IsNull(param) Then VariantToLong = 0 Else VariantToLong = CLng(param)
End Function



Function VariantToString(ByVal v As Variant) As String
  If IsNull(v) Then VariantToString = "" Else VariantToString = CStr(v)
End Function




Function VersionStrToLong(ByVal VersionStr As String) As Long
Dim i, j, NextByte As Byte
Dim result As Long
Dim s As String
  result = 0
  For j = 1 To 4
    i = InStr(VersionStr, ".")
    If i <> 0 Then
      NextByte = CByte(Mid(VersionStr, 1, i))
    Else
      If VersionStr <> "" Then
        NextByte = CByte(VersionStr)
      Else
        NextByte = 0
      End If
    End If
    VersionStr = Right(VersionStr, Len(VersionStr) - i)
    result = result * 256 + NextByte
  Next j
  VersionStrToLong = result
End Function


Function WinBool2VBBool(ByVal WinBool As Integer) As Boolean
  WinBool2VBBool = WinBool <> 0
End Function















Attribute VB_Name = "MSD_AllExcel"
Option Explicit
Option Private Module

' Library for global VBA routines for MS-Excel
' last change: 2009/11/30
' Modul dependencies: [none]

' DON'T MAKE ANY CHANGES!
' All your changes will be lost with the next update of this library.
' Contact the author <ms@msdatec.de> for bug fixes or enhancements instead.

' BITTE KEINE |fffd|NDERUNGEN DURCHF|fffd|HREN!
' Alle |fffd|nderungen, die Sie hier vornehmen, gehen mit dem n|fffd|chsten Update dieses Modules verloren.
' Kontaktieren Sie anstattdessen den Autor unter <ms@msdatec.de> f|fffd|r Fehlerkorrekturen oder Verbesserungen.

' All rights of this code are reserved by MSDatec.
' See http://www.msdatec.de/ for further information.
' You are allowed to use and modify this code for personal use.
' You are NOT allowed to publish or distribute this code or parts of it
' without a written permission of MSDatec.

' Alle Rechte dieses Codes liegen bei MSDatec.
' Unter http://www.msdatec.de/ finden Sie weitere Informationen sowie Kontaktm|fffd|glichkeiten.
' Sie d|fffd|rfen f|fffd|r Ihre eigenen Bed|fffd|rfnisse diesen Code benutzen und ver|fffd|ndern.
' Sie d|fffd|rfen NICHT diesen Code oder Teile desselben ohne eine schriftliche Genehmigung
' von MSDatec publizieren oder Dritten zug|fffd|nglich machen.

' History:
' 2009/11/30
' - added ApplicationHandle (Application.Hwnd is available only since Excel 2003)
' 2009/07/05
' - Functions *FontsEqual* and *CommentsDelete* introduced
' 2008/12/03
' - Function *NextFreeRow* introduced
' 2006/12/14
' - optional parameter f|fffd|r error message box title in sub *WorkSheetSelect* and *WorksheetUnprotect* introduced
' 2005/10/16
' - Added param *CopyDefaultAlso* to Sub *CopyInterior*
' 2005/01/07
' - renamed *SelectWorkSheet* to *WorkSheetSelect*
' - renamed *UnprotectWorksheet* to *WorksheetUnprotect*
' - introduced *WorkSheetInsert*

Global Const CRowMax = 65536
Global Const CColMax = 256

Private fUpdateCount As Integer


Public Function ApplicationHandle() As Long
  ApplicationHandle = FindWindow("XLMAIN", Application.Caption)
End Function


Public Sub CommentsDelete(AWorkSheet As Worksheet, ByVal RowMin As Long, ByVal ColMin As Long, ByVal RowMax As Long, ByVal ColMax As Long)
' Deletes all comments within the rectangle given by (RowMin/ColMin) (RowMax/ColMax) (including this points).
Dim i As Long
  
  i = 1
  While i <= AWorkSheet.Comments.count
    If AWorkSheet.Comments(i).Parent.Row < RowMin Then GoTo DontDel
    If AWorkSheet.Comments(i).Parent.Column < ColMin Then GoTo DontDel
    If AWorkSheet.Comments(i).Parent.Column > ColMax Then GoTo DontDel
    If AWorkSheet.Comments(i).Parent.Row > RowMax Then GoTo DontDel
    AWorkSheet.Comments(i).Delete
    GoTo NextLoop
DontDel:
      i = i + 1
NextLoop:
  Wend

End Sub


Sub CopyFont(ByVal Src As Font, ByRef Dest As Font)
  Dest.Bold = Src.Bold
  Dest.Color = Src.Color
  Dest.ColorIndex = Src.ColorIndex
  Dest.FontStyle = Src.FontStyle
  Dest.Italic = Src.Italic
  Dest.Name = Src.Name
  Dest.OutlineFont = Src.OutlineFont
  Dest.Shadow = Src.Shadow
  Dest.Size = Src.Size
  Dest.Strikethrough = Src.Strikethrough
  Dest.Subscript = Src.Subscript
  Dest.Superscript = Src.Superscript
  Dest.Underline = Src.Underline
End Sub



Sub CopyInterior(ByVal Src As Interior, ByRef Dest As Interior, ByVal CopyDefaultAlso As Boolean)
' |fffd|bertr|fffd|gt Farbe und Muster aus *Src* nach *Dest *.
' Falls CopyDefaultAlso=TRUE, wird Farbe bzw. Muster auch |fffd|bertragen, wenn in *src* die
' Standardeinstellungen gesetzt sind.
  If (Src.ColorIndex <> xlColorIndexNone) Or CopyDefaultAlso Then
    Dest.Color = Src.Color
    Dest.ColorIndex = Src.ColorIndex
  End If
  'dest.InvertIfNegative = Src.InvertIfNegative
  If (Src.PatternColorIndex <> xlColorIndexNone) Or CopyDefaultAlso Then
    Dest.PatternColor = Src.PatternColor
    Dest.PatternColorIndex = Src.PatternColorIndex
    Dest.Pattern = Src.Pattern
  End If
End Sub



Function ExistsTableName(ByVal AWorkBookName As String, ByVal ATableName As String) As Boolean
' Pr|fffd|ft, ob bereits ein Tabellenblatt mit dem Namen *ATableName* vorhanden ist
On Error GoTo Err_ExistsTableName
  ExistsTableName = Workbooks(AWorkBookName).Worksheets(ATableName).Name = ATableName
  GoTo Exit_ExistsTableName

Err_ExistsTableName:

  ExistsTableName = False
  Resume Exit_ExistsTableName
  
Exit_ExistsTableName:
End Function





Function FirstRangeOfRange(ByVal ARange As String) As String
' Gibt den Teil aus *ARange* zur|fffd|ck, der bis zum ersten ":" enthalten ist
' Enth|fffd|lt *ARange* keinen ":", wird *ARange* zur|fffd|ckgegeben
Dim i As Integer
  i = InStr(1, ARange, ":", vbBinaryCompare)
  If i <> 0 Then FirstRangeOfRange = Left(ARange, i - 1) Else FirstRangeOfRange = ARange
End Function


Function FontsEqual(Font1 As Font, Font2 As Font) As Boolean
  FontsEqual = False
  If Font1.Size <> Font2.Size Then Exit Function
  If Font1.Bold <> Font2.Bold Then Exit Function
  If Font1.Color <> Font2.Color Then Exit Function
  If Font1.Italic <> Font2.Italic Then Exit Function
  If Font1.Name <> Font2.Name Then Exit Function
  If Font1.OutlineFont <> Font2.OutlineFont Then Exit Function
  If Font1.Strikethrough <> Font2.Strikethrough Then Exit Function
  If Font1.Subscript <> Font2.Subscript Then Exit Function
  If Font1.Superscript <> Font2.Superscript Then Exit Function
  If Font1.Underline <> Font2.Underline Then Exit Function
  FontsEqual = True
End Function




Function LastUsedCellInColumn(ByRef ATable As Worksheet, ByVal StartRow As Integer, ByVal AColumn As Integer, Optional MaxEmptyCells) As Integer
' Sucht ab einschlie|fffd|lich *StartRow* in *AColumn* nach der ersten leeren Zelle. Falls
' *MaxEmptyCells* gesetzt ist, werden *MaxEmptyCells* als leere Zellen zwischen den Eintr|fffd|gen akzeptiert
Dim AMaxEmptyCells As Integer
Dim EmptyCells As Integer
Dim i As Integer

  If IsMissing(MaxEmptyCells) Then AMaxEmptyCells = 1 Else AMaxEmptyCells = MaxEmptyCells + 1
  
  i = StartRow
  While (EmptyCells < AMaxEmptyCells)
    If ATable.Cells(i, AColumn) <> "" Then EmptyCells = 0 Else EmptyCells = EmptyCells + 1
    i = i + 1
  Wend
  LastUsedCellInColumn = i - AMaxEmptyCells - 1
  
End Function


Function NextFreeRow(ATable As Worksheet, ByVal StartRow As Integer, CheckColumns As String) As Long
' Sucht ab einschlie|fffd|lich *StartRow* in dem Bereich von einschlie|fffd|lich *CheckColumns*  nach der ersten komplett leeren Zeile.
' *CheckColumns* ist dabei eine Kette von Zeichen, deren Zeichencode die zu pr|fffd|fenden Spalten angibt.
Dim CurrRow As Long
Dim CurrCol As Byte
  
  For CurrRow = StartRow To CRowMax
    For CurrCol = 1 To Len(CheckColumns)
      If ATable.Cells(CurrRow, Asc(Mid(CheckColumns, CurrCol, 1))) <> "" Then GoTo RowIsUsed
    Next CurrCol
    NextFreeRow = CurrRow
    Exit Function
RowIsUsed:
    
  Next CurrRow
  
End Function




Function RangeIsEmpty(AWorkSheet As Worksheet, ByVal Row1 As Integer, ByVal Col1 As Integer, ByVal Row2 As Integer, ByVal col2 As Integer) As Boolean
Dim i As Integer
Dim j As Integer
  For i = Row1 To Row2
    For j = Col1 To col2
      If AWorkSheet.Cells(i, j) <> "" Then
        RangeIsEmpty = False
        Exit Function
      End If
    Next j
  Next i
  RangeIsEmpty = True
End Function






Sub SwapRows(ATable As Worksheet, ByVal Row1 As Integer, ByVal Row2 As Integer, ByRef ATmpColRange As Range)
  ATable.Range(CStr(Row1) & ":" & CStr(Row1)).Copy ATmpColRange
  ATable.Range(CStr(Row2) & ":" & CStr(Row2)).Copy ATable.Cells(Row1, 1)
  ATmpColRange.Copy ATable.Range(CStr(Row2) & ":" & CStr(Row2))
End Sub



Sub ValidationSetNumberRange(ARange As Range, ByVal Formula1 As String, ByVal Formula2 As String, ByVal ValidateWholeNumber As Boolean)
Dim ValidationType As Integer
Dim s As String

  With ARange.Validation
    .Delete
    If ValidateWholeNumber Then
      ValidationType = xlValidateWholeNumber
      s = "ganzzahligen "
    Else
      ValidationType = xlValidateDecimal
    End If
    .Add ValidationType, xlValidAlertStop, xlBetween, Formula1, Formula2
      .IgnoreBlank = True
      .InCellDropdown = True
      .InputTitle = ""
      .ErrorTitle = ""
      .InputMessage = ""
      .ErrorMessage = "Bitte geben Sie einen " & s & "Wert zwischen " & Formula1 & " und " & Formula2 & " ein."
      .ShowInput = True
      .ShowError = True
    End With
End Sub




Sub UpdateBegin()
  fUpdateCount = fUpdateCount + 1
  If fUpdateCount = 1 Then
    Application.ScreenUpdating = False
    Application.Cursor = xlWait
  End If
End Sub


Function Updating() As Boolean
  Updating = fUpdateCount <> 0
End Function



Sub UpdateEnd()
  fUpdateCount = fUpdateCount - 1
  If fUpdateCount = 0 Then
    Application.ScreenUpdating = True
    Application.Cursor = xlDefault
  End If
End Sub


Function WorkSheetDelete(ByVal AWorkBookName As String, ByVal ATableName As String) As Boolean
On Error GoTo Err_WorkSheetDelete

Dim ApplicationDisplayAlerts  As Boolean
  
  ApplicationDisplayAlerts = Application.DisplayAlerts
  Application.DisplayAlerts = False
  Workbooks(AWorkBookName).Worksheets(ATableName).Delete
  WorkSheetDelete = True
  GoTo Exit_WorkSheetDelete
  
Err_WorkSheetDelete:
  WorkSheetDelete = False
  Resume Exit_WorkSheetDelete
  
Exit_WorkSheetDelete:
  Application.DisplayAlerts = ApplicationDisplayAlerts
End Function
    


Function WorkSheetInsert(ByVal AWorkBookName As String, ByVal AWorkSheetName As String, ByVal InsertSorted As Boolean) As Boolean
' F|fffd|gt in der Mappe mit dem Namen "AWorkBookName* ein neues Blatt mit dem Namen *ATableName* ein
' und gibt TRUE zur|fffd|ck, falls erfolgreich.
' Falls bereits ein Blatt mit diesem Namen existiert, wird es ohne Nachfrage gel|fffd|scht
' Falls kein Tabellenblatt eingef|fffd|gt werden konnte, wird FALSE zur|fffd|ckgegeben
' Falls *Sorted*=true, wird das Arbeitsblatt ain alphabetischer Reihenfolge eingef|fffd|gt, ansonsten hinter dem aktiven


Dim LastSheetIndex As Integer
Dim AWorkbook As Workbook
Dim DestTable As Worksheet
Dim TmpTableName As String


  WorkSheetInsert = False
  Set AWorkbook = Workbooks(AWorkBookName)
  If ExistsTableName(AWorkbook.Name, AWorkSheetName) Then
    If AWorkbook.Sheets.count = 1 Then
      ' Workaround: Falls nur ein Tabellenblatt vorhanden ist und das bisherige |fffd|berschrieben werden soll,
      ' wird tempor|fffd|r ein weiteres Tabellenblatt eingef|fffd|gt und sp|fffd|ter wieder gel|fffd|scht
      TmpTableName = AWorkbook.Sheets.Add.Name
    End If
    WorkSheetDelete AWorkBookName, AWorkSheetName
    If ExistsTableName(AWorkbook.Name, AWorkSheetName) Then
      MsgBox "Konnte das Tabellenblatt '" & AWorkSheetName & "' in der Arbeitsmappe " & AWorkBookName & " nicht l|fffd|schen! (Huch?)", vbCritical
      Exit Function ' L|fffd|schen hat nicht geklappt
    End If
  End If
  
  If InsertSorted Then
    ' in alphabetischer Reihenfolge einf|fffd|gen - "n|fffd|chstkleineres" Tabellenblatt bestimmen:
    For LastSheetIndex = 1 To AWorkbook.Worksheets.count
      If AWorkbook.Worksheets(LastSheetIndex).Name > AWorkSheetName Then Exit For
    Next LastSheetIndex
  End If
    
  If LastSheetIndex > AWorkbook.Worksheets.count Then
    Set DestTable = AWorkbook.Worksheets.Add(after:=Worksheets(AWorkbook.Worksheets.count))
  Else
    Set DestTable = AWorkbook.Worksheets.Add(Before:=Worksheets(LastSheetIndex))
  End If
  DestTable.Name = AWorkSheetName
  If TmpTableName <> "" Then WorkSheetDelete AWorkBookName, TmpTableName
  
  WorkSheetInsert = ExistsTableName(AWorkbook.Name, AWorkSheetName)
End Function




Sub WorkSheetSelect(ByVal AWorkSheet As Worksheet, Optional ByVal ATitleErrMSGBox As String)
On Error GoTo Err_WorkSheetSelect
Dim OldApplicationScreenUpdating As Boolean, WasSaved As Boolean
  
  WasSaved = AWorkSheet.Parent.Saved
  OldApplicationScreenUpdating = Application.ScreenUpdating
  Application.ScreenUpdating = False
  If Not AWorkSheet.Visible Then AWorkSheet.Visible = True
  AWorkSheet.Select
  GoTo Exit_WorkSheetSelect
  
  
Err_WorkSheetSelect:
  MsgBox Err.Description, vbCritical, ATitleErrMSGBox
  Resume Exit_WorkSheetSelect

Exit_WorkSheetSelect:
  Application.ScreenUpdating = OldApplicationScreenUpdating
  If WasSaved Then AWorkSheet.Parent.Saved = True
End Sub


Function WorksheetUnprotect(AWorkSheet As Worksheet, ByVal APassword As String, ByRef WasProtected As Boolean, Optional ShowError As Boolean = False, Optional ByVal ATitleErrMSGBox As String) As Boolean
On Error GoTo Err_WorksheetUnprotect
  
  If AWorkSheet.ProtectContents Then
    WasProtected = True
    AWorkSheet.Unprotect APassword
  Else
    WasProtected = False
  End If
  WorksheetUnprotect = True
  GoTo Exit_WorksheetUnprotect
  
Err_WorksheetUnprotect:
  WorksheetUnprotect = False
  If ShowError Then MsgBox Err.Description, vbCritical, ATitleErrMSGBox
  Resume Exit_WorksheetUnprotect


Exit_WorksheetUnprotect:
End Function


Attribute VB_Name = "MSD_Base64"
Option Explicit
Option Private Module

' Library for routines for Base64-Coding
' last change: 2002/12/03
' Modul dependencies: [none]

' DON'T MAKE ANY CHANGES!
' All your changes will be lost with the next update of this library.
' Contact the author <ms@msdatec.de> for bug fixes or enhancements instead.

' BITTE KEINE |fffd|NDERUNGEN DURCHF|fffd|HREN!
' Alle |fffd|nderungen, die Sie hier vornehmen, gehen mit dem n|fffd|chsten Update dieses Modules verloren.
' Kontaktieren Sie anstattdessen den Autor unter <ms@msdatec.de> f|fffd|r Fehlerkorrekturen oder Verbesserungen.

' All rights of this code are reserved by MSDatec.
' See http://www.msdatec.de/ for further information.
' You are allowed to use and modify this code for personal use.
' You are NOT allowed to publish or distribute this code or parts of it
' without a written permission of MSDatec.

' Alle Rechte dieses Codes liegen bei MSDatec.
' Unter http://www.msdatec.de/ finden Sie weitere Informationen sowie Kontaktm|fffd|glichkeiten.
' Sie d|fffd|rfen f|fffd|r Ihre eigenen Bed|fffd|rfnisse diesen Code benutzen und ver|fffd|ndern.
' Sie d|fffd|rfen NICHT diesen Code oder Teile desselben ohne eine schriftliche Genehmigung
' von MSDatec publizieren oder Dritten zug|fffd|nglich machen.

' History:


Const CBase64SubstCharCode1 As Byte = 43  ' "+"
Const CBase64SubstCharCode2 As Byte = 47  ' "/"
Const CBase64FillCharCode   As Byte = 61  ' "="


Private Function CharIsBase64Char(ByVal CharCode As Byte) As Boolean
  If (CharCode >= 65) And (CharCode <= 90) Then _
    CharIsBase64Char = True _
  Else _
    If (CharCode >= 97) And (CharCode <= 122) Then _
      CharIsBase64Char = True _
    Else _
      If (CharCode >= 48) And (CharCode <= 57) Then _
        CharIsBase64Char = True _
      Else _
        If CharCode = CBase64SubstCharCode1 Then _
          CharIsBase64Char = True _
        Else _
          If CharCode = CBase64SubstCharCode2 Then _
            CharIsBase64Char = True _
          Else _
            If CharCode = CBase64FillCharCode Then _
              CharIsBase64Char = True _
            Else CharIsBase64Char = False
End Function


Function Base64EncodeChar(ByVal b As Byte) As Byte
  Select Case b
    Case 0 To 25
      Base64EncodeChar = b + Asc("A")
    Case 26 To 51
      Base64EncodeChar = b - 26 + Asc("a")
    Case 52 To 61
      Base64EncodeChar = b - 52 + Asc("0")
    Case 62
      Base64EncodeChar = CBase64SubstCharCode1
    Case 63
      Base64EncodeChar = CBase64SubstCharCode2
    Case Else
      Base64EncodeChar = Asc("?")
  End Select
End Function


Private Function Base64DecodeChar(ByVal Base64Char As Byte, ByRef BinChar As Byte) As Boolean
  Base64DecodeChar = True
  Select Case Base64Char
    Case Asc("A") To Asc("Z")
      BinChar = Base64Char - 65
    Case Asc("a") To Asc("z")
      BinChar = Base64Char - 71
    Case Asc("0") To Asc("9")
      BinChar = Base64Char + 4
    Case CBase64SubstCharCode1
      BinChar = 62
    Case CBase64SubstCharCode2
      BinChar = 63
    Case CBase64FillCharCode
      BinChar = 0
    Case Else
      Base64DecodeChar = False
  End Select
End Function





Private Function Base64EncodeStr3(ByVal BinStr3 As String) As String
' Verwandelt das Dreierpaket *BinStr3* in eine Zeichenkette aus druckbaren
' Zeichen ('A-Za-z0-9+/').
Dim b1 As Byte
Dim b2 As Byte
Dim b3 As Byte
Dim result As String
  
  b1 = Asc(Left(BinStr3, 1))
  b2 = Asc(Mid(BinStr3, 2, 1))
  b3 = Asc(Right(BinStr3, 1))
  
  Base64EncodeStr3 = _
      Chr(Base64EncodeChar(b1 \ 4)) _
    & Chr(Base64EncodeChar(((b1 And 3) * 16) Or (b2 \ 16))) _
    & Chr(Base64EncodeChar(((b2 And 15) * 4) Or (b3 \ 64))) _
    & Chr(Base64EncodeChar(b3 And 63))
  
  'result = Chr(Base64EncodeChar(b1 \ 4))
  'result = result + Chr(Base64EncodeChar(((b1 And 3) * 16) Or (b2 \ 16)))
  'result = result + Chr(Base64EncodeChar(((b2 And 15) * 4) Or (b3 \ 64)))
  'Base64EncodeStr3 = result + Chr(Base64EncodeChar(b4 And 63))
  
End Function



Private Function Base64DecodeStr4(ByVal Base64Str4 As String, ByRef BinStr4 As String) As Boolean
'***************************************************************************
' Verwandelt das Viererpaket *Base64Str4* zurueck in die urspruengliche
' Zeichenkette aus 3 Zeichen.
'***************************************************************************)
Dim BArray(3) As Byte
'Dim CArray(2) As String
Dim i As Byte

  For i = 0 To 3
    If Not Base64DecodeChar(Asc(Mid(Base64Str4, i + 1, 1)), BArray(i)) Then
      Base64DecodeStr4 = False
      Exit Function
    End If
  Next i
  
  BinStr4 = _
      Chr((BArray(0) And 255) * 4 + BArray(1) \ 16) _
    & Chr((BArray(1) And 15) * 16 + (BArray(2) \ 4)) _
    & Chr((BArray(2) And 3) * 64 + BArray(3))
  
'  CArray(0) = Chr((BArray(0) And 255) * 4 + BArray(1) \ 16)
'  CArray(1) = Chr((BArray(1) And 15) * 16 + (BArray(2) \ 4))
'  CArray(2) = Chr((BArray(2) And 3) * 64 + BArray(3))
'  BinStr4 = CArray(0) & CArray(1) & CArray(2)
  Base64DecodeStr4 = True
End Function


Function Base64DecodeStr(ByVal Base64Str As String, ByRef BinStr As String, ByVal Strict As Boolean) As Boolean
Dim i As Integer
Dim s As String
Dim Base64Str4 As String
Dim LenWithoutPadding As Integer
Dim b As Byte
  
  Base64DecodeStr = False
  BinStr = ""
  i = 1
    
  While i <= Len(Base64Str)
    Base64Str4 = ""
    While i <= Len(Base64Str) And Len(Base64Str4) < 4
      If Strict Then
        Base64Str4 = Base64Str4 + Mid(Base64Str, i, 1)
      Else
        If CharIsBase64Char(Asc(Mid(Base64Str, i, 1))) Then Base64Str4 = Base64Str4 + Mid(Base64Str, i, 1)
      End If
      
      i = i + 1
    Wend
    If Len(Base64Str4) <> 4 Then Exit Function
    If Not Base64DecodeStr4(Base64Str4, s) Then Exit Function
    BinStr = BinStr & s
  Wend
  
  If Right(Base64Str, 1) = CBase64FillCharCode Then
    If Mid(Base64Str, Len(Base64Str) - 1, 1) = CBase64FillCharCode Then
      BinStr = Left(BinStr, Len(BinStr) - 2)
    Else
      BinStr = Left(BinStr, Len(BinStr) - 1)
    End If
  End If
      
  Base64DecodeStr = True
End Function
  
  


Function Base64EncodeStr(ByVal BinStr As String) As String
Dim i As Integer
Dim j As Integer
Dim result As String
Dim PostStr As String
  
  While Len(BinStr) Mod 3 <> 0
    BinStr = BinStr & Chr(0) ' mit *CBase64FillChar* auff|fffd|llen
    PostStr = PostStr & Chr(CBase64FillCharCode)
  Wend
  
  For i = 1 To Len(BinStr) Step 3
    result = result & Base64EncodeStr3(Mid(BinStr, i, 3))
  Next i
  
  Base64EncodeStr = Left(result, Len(result) - Len(PostStr)) & PostStr
End Function









Attribute VB_Name = "MSD_CommonDLGs"
Option Explicit
Option Private Module

' Library for windows common dialogs
' last change: 2009/05/19
' Modul dependencies: MSD_Windows, MSD_DiskStrg, MSD_All

' DON'T MAKE ANY CHANGES!
' All your changes will be lost with the next update of this library.
' Contact the author <ms@msdatec.de> for bug fixes or enhancements instead.

' BITTE KEINE |fffd|NDERUNGEN DURCHF|fffd|HREN!
' Alle |fffd|nderungen, die Sie hier vornehmen, gehen mit dem n|fffd|chsten Update dieses Modules verloren.
' Kontaktieren Sie anstattdessen den Autor unter <ms@msdatec.de> f|fffd|r Fehlerkorrekturen oder Verbesserungen.

' All rights of this code are reserved by MSDatec.
' See http://www.msdatec.de/ for further information.
' You are allowed to use and modify this code for personal use.
' You are NOT allowed to publish or distribute this code or parts of it
' without a written permission of MSDatec.

' Alle Rechte dieses Codes liegen bei MSDatec.
' Unter http://www.msdatec.de/ finden Sie weitere Informationen sowie Kontaktm|fffd|glichkeiten.
' Sie d|fffd|rfen f|fffd|r Ihre eigenen Bed|fffd|rfnisse diesen Code benutzen und ver|fffd|ndern.
' Sie d|fffd|rfen NICHT diesen Code oder Teile desselben ohne eine schriftliche Genehmigung
' von MSDatec publizieren oder Dritten zug|fffd|nglich machen.

' History:
' 2009/05/19
' - CTitleMsgBox implemented
' 2006/01/26
' - Modul dependencies updated
' 2004/11/27:
' - added some default file filters


' Public Function BrowseForFolder(ByRef DirName As String, ByVal DirMustExist As Boolean) As Boolean
' alte Version: Gibt im Erfolgsfalle TRUE zur|fffd|ck. *DirName* enth|fffd|lt dann den ausgew|fffd|hlten Verzeichnisnamen.
' Public Function BrowseForFolderSH(ByVal lngCSIDL As Long, ByVal lngBiFlags As Long, ByVal StartDir As String, ByRef strFolder As String, ByRef result As Long, Optional ByVal hWnd As Long = 0, Optional pszTitle As String = "Verzeichnis w|fffd|hlen:") As Boolean
' Windows-Version: Gibt im Erfolgsfalle TRUE zur|fffd|ck. *strFolder* enth|fffd|lt dann den ausgew|fffd|hlten Verzeichnisnamen.

' Public Function FileOpenDLG(ByVal DefaultExtension As String, ByVal Filter As String, ByRef Filename As String, Optional ByVal Title As String = "|fffd|ffnen", Optional Flags As Long = COFNFlags_Open) As Boolean
' Public Function FileSaveDLG(ByVal DefaultExtension As String, ByVal Filter As String, ByRef Filename As String, Optional ByVal Title As String = "Speichern", Optional Flags As Long = COFNFlags_Save) As Boolean
' Falls *FileName* nicht leer ist, werden *InitialDir* und *FileDLG.Filename* auf die entsprechenden Angaben gesetzt
' Gibt im Erfolgsfalle TRUE zur|fffd|ck. *Filename* enth|fffd|lt dann den ausgew|fffd|hlten Dateinamen.



' some default file filters:
Global Const CStrFilterCSV_de = "CSV-Dateien (*.csv)|*.csv"
Global Const CStrFilterTXT_de = "Textdateien (*.txt)|*.txt"
Global Const CStrFilterAll_de = "Alle Dateien (*.*)|*.*"




' GetOpen-/GetSaveName types and constants:

Private Type TOpenFileName
    lStructSize As Long
    hwndOwner As Long
    hInstance As Long
    lpstrFilter As String
    lpstrCustomFilter As String
    nMaxCustFilter As Long
    nFilterIndex As Long
    lpstrFile As String
    nMaxFile As Long
    lpstrFileTitle As String
    nMaxFileTitle As Long
    lpstrInitialDir As String
    lpstrTitle As String
    Flags As Long
    nFileOffset As Integer
    nFileExtension As Integer
    lpstrDefExt As String
    lCustData As Long
    lpfnHook As Long
    lpTemplateName As String
End Type



Public Const OFN_ALLOWMULTISELECT         As Long = &H200
Public Const OFN_CREATEPROMPT             As Long = &H2000
Public Const OFN_ENABLEHOOK               As Long = &H20
Public Const OFN_ENABLETEMPLATE           As Long = &H40
Public Const OFN_ENABLETEMPLATEHANDLE     As Long = &H80
Public Const OFN_EXPLORER                 As Long = &H80000
Public Const OFN_EXTENSIONDIFFERENT       As Long = &H400
Public Const OFN_FILEMUSTEXIST            As Long = &H1000
Public Const OFN_HIDEREADONLY             As Long = &H4
Public Const OFN_LONGNAMES                As Long = &H200000
Public Const OFN_NOCHANGEDIR              As Long = &H8
Public Const OFN_NODEREFERENCELINKS       As Long = &H100000
Public Const OFN_NOLONGNAMES              As Long = &H40000
Public Const OFN_NONETWORKBUTTON          As Long = &H20000
Public Const OFN_NOTESTFILECREATE         As Long = &H10000
Public Const OFN_OVERWRITEPROMPT          As Long = &H2
Public Const OFN_PATHMUSTEXIST            As Long = &H800
Public Const OFN_READONLY                 As Long = &H1
Public Const OFN_SHAREAWARE               As Long = &H4000
Public Const OFN_SHOWHELP                 As Long = &H10

Private Const OFN_SHAREWARN               As Byte = 0
Private Const OFN_SHAREFALLTHROUGH        As Byte = 2
Private Const OFN_SHARENOWARN             As Byte = 1


Public Const COFNFlags_Save = OFN_EXTENSIONDIFFERENT Or OFN_NOCHANGEDIR Or OFN_HIDEREADONLY Or OFN_OVERWRITEPROMPT
Public Const COFNFlags_Open = OFN_EXTENSIONDIFFERENT Or OFN_NOCHANGEDIR Or OFN_HIDEREADONLY Or OFN_PATHMUSTEXIST Or OFN_FILEMUSTEXIST



' BrowseForFolder types and constants:

Type TBrowseInfo
  hwndOwner As Long
  pidlRoot As Long
  pszDisplayName As String
  lpszTitle As String
  ulFlags As Long
  lpfn As Long
  lParam As Long
  iImage As Long
End Type

'specify root dir for browse for folder by constants
'you can also specify values by constants for searchable folders and options.
Global Const dhcCSIdlDesktop = &H0
Global Const dhcCSIdlPrograms = &H2
Global Const dhcCSIdlControlPanel = &H3
Global Const dhcCSIdlInstalledPrinters = &H4
Global Const dhcCSIdlPersonal = &H5
Global Const dhcCSIdlFavorites = &H6
Global Const dhcCSIdlStartupPmGroup = &H7
Global Const dhcCSIdlRecentDocDir = &H8
Global Const dhcCSIdlSendToItemsDir = &H9
Global Const dhcCSIdlRecycleBin = &HA
Global Const dhcCSIdlStartMenu = &HB
Global Const dhcCSIdlDesktopDirectory = &H10
Global Const dhcCSIdlMyComputer = &H11
Global Const dhcCSIdlNetworkNeighborhood = &H12
Global Const dhcCSIdlNetHoodFileSystemDir = &H13
Global Const dhcCSIdlFonts = &H14
Global Const dhcCSIdlTemplates = &H15
 
 'constants for limiting choices for BrowseForFolder Dialog
Global Const dhcBifReturnAll = &H0
Global Const dhcBifReturnOnlyFileSystemDirs = &H1
Global Const dhcBifDontGoBelowDomain = &H2
Global Const dhcBifIncludeStatusText = &H4
Global Const dhcBifSystemAncestors = &H8
Global Const dhcBifBrowseForComputer = &H1000
Global Const dhcBifBrowseForPrinter = &H2000

Global Const dhcErrorExtendedError = 1208&
Global Const dhcNoError = 0&





Private Declare Function GetSaveFileName Lib "comdlg32" Alias "GetSaveFileNameA" (lpOpenfilename As TOpenFileName) As Long
Private Declare Function GetOpenFileName Lib "comdlg32" Alias "GetOpenFileNameA" (lpOpenfilename As TOpenFileName) As Long
Private Declare Function CommDlgExtendedError Lib "comdlg32" () As Integer
Private Declare Function SHBrowseForFolder Lib "shell32.dll" (ByRef lpbi As TBrowseInfo) As Long
Private Declare Function SHGetPathFromIDList Lib "shell32" (ByVal pidList As Long, ByVal lpBuffer As String) As Long
Private Declare Function SHGetSpecialFolderLocation Lib "shell32.dll" (ByVal hwndOwner As Long, ByVal nFolder As Long, ByRef pidl As Long) As Long


Private BrowseForFolderSHCallBackInitDir As String ' hmpf: globale Variable f|fffd|r das Startverzeichnis von BrowseForFolderSH


Private Function BrowseForFolderSHCallBackSetInitDir(ByVal Wnd As Long, ByVal uMsg As Long, ByVal lParam As Long, ByVal lpData As Long) As Long
Const BFFM_INITIALIZED = 1
Const BFFM_SETSELECTIONA = WM_USER + 102

  BrowseForFolderSHCallBackSetInitDir = 0
  If uMsg = BFFM_INITIALIZED Then
'    If 0 <> lpData Then
    If BrowseForFolderSHCallBackInitDir <> "" Then
      SendMessageStr Wnd, BFFM_SETSELECTIONA, 1, BrowseForFolderSHCallBackInitDir
    End If
  End If

End Function





Public Function BrowseForFolderSH(ByVal lngCSIDL As Long, ByVal lngBiFlags As Long, ByVal StartDir As String, ByRef strFolder As String, ByRef result As Long, Optional ByVal hWnd As Long = 0, Optional pszTitle As String = "Verzeichnis w|fffd|hlen:") As Boolean
Dim BrowseInfo As TBrowseInfo
Dim lngIDL As Long

  If SHGetSpecialFolderLocation(GetActiveWindow, lngCSIDL, lngIDL) = 0 Then
    If hWnd = 0 Then hWnd = GetActiveWindow
   'set up the browse structure here
    With BrowseInfo
      .hwndOwner = hWnd
      .pidlRoot = lngIDL
      .pszDisplayName = String(CMax_Path, vbNullChar)
      .lpszTitle = pszTitle
      .ulFlags = lngBiFlags
      .lpfn = AdressOfFunc(AddressOf BrowseForFolderSHCallBackSetInitDir)
      '.lParam = StartDir
    End With
    BrowseForFolderSHCallBackInitDir = StartDir
    'open the dialog
    lngIDL = SHBrowseForFolder(BrowseInfo)
    BrowseForFolderSHCallBackInitDir = ""
    'if successful
    If lngIDL <> 0 Then
      strFolder = String(CMax_Path, vbNullChar)
      'resolve the long value form the lngIDL to a real path
      If SHGetPathFromIDList(lngIDL, strFolder) Then
        strFolder = Left(strFolder, InStr(1, strFolder, vbNullChar) - 1)
        result = dhcNoError 'to show there is no error.
      Else
        'nothing real is available.
        'return a virtual selection
        strFolder = Left(BrowseInfo.pszDisplayName, InStr(1, BrowseInfo.pszDisplayName, vbNullChar) - 1)
        result = dhcNoError 'to show there is no error.
      End If
    Else
      strFolder = ""
      result = 0
      BrowseForFolderSH = False
      Exit Function
    End If
  Else
    result = dhcErrorExtendedError 'something went wrong
  End If
  BrowseForFolderSH = (result = dhcNoError)

End Function


Public Function BrowseForFolder(ByRef DirName As String, ByVal DirMustExist As Boolean) As Boolean
' Gibt im Erfolgsfalle TRUE zur|fffd|ck. *DirName* enth|fffd|lt dann den ausgew|fffd|hlten Verzeichnisnamen.
Dim s As String
Dim ACaption As String



  If DirMustExist Then ACaption = "existierenden "
  ACaption = "Bitte geben Sie den Namen eines " & ACaption & "Verzeichnisses ein:"
  BrowseForFolder = False
  If DirName = "" Then s = CurDir Else s = DirName
showInputDir:
  s = InputBox(ACaption, "Verzeichnis ausw|fffd|hlen", s)
  If s = "" Then Exit Function ' Abbruch
  If DirMustExist Then
    If Dir(s, vbDirectory) <> "" Then
      If (GetAttr(s) And vbDirectory) <> vbDirectory Then
        MsgBox "'" & s & "' ist kein Verzeichnis!", vbExclamation, CTitleMsgBox
        GoTo showInputDir
      End If
    Else ' *s* existiert nicht
      MsgBox "Das Verzeichnis '" & s & "' existiert nicht!", vbExclamation, CTitleMsgBox
      GoTo showInputDir
    End If
  End If
  DirName = s
  BrowseForFolder = True

End Function




Private Function ChangeFilterHaveDelimiter(ByVal Delimiter As String, UserFriendlyFilter As String, ByRef Position As Integer) As Boolean
  Position = InStr(Position, UserFriendlyFilter, Delimiter, vbBinaryCompare)
  ChangeFilterHaveDelimiter = Position <> 0
End Function


Private Function ChangeFilter(ByVal UserFriendlyFilter As String) As String
Const CFilterDelimiter = "|"
Dim s As String
Dim i As Integer, j As Integer, LastFoundPos As Integer

  i = 1
  LastFoundPos = 1
  While ChangeFilterHaveDelimiter(CFilterDelimiter, UserFriendlyFilter, i)
    j = i + 1
    If Not ChangeFilterHaveDelimiter(CFilterDelimiter, UserFriendlyFilter, j) Then j = Len(UserFriendlyFilter) + 1
    s = s _
      & Mid(UserFriendlyFilter, LastFoundPos, i - LastFoundPos) & vbNullChar _
      & Mid(UserFriendlyFilter, i + Len(CFilterDelimiter), j - i - 1) & vbNullChar
    LastFoundPos = j + Len(CFilterDelimiter)
    i = LastFoundPos
  Wend
  ChangeFilter = s & vbNullChar & vbNullChar
End Function



Private Function FileDLG(ByVal OpenDLG As Boolean, ByVal DefaultExtension As String, ByVal Filter As String, ByRef Filename As String, ByVal Title As String, ByVal Flags As Long, ByRef Filterindex As Long) As Boolean
Dim OpenFileName As TOpenFileName
Const CMax_Path_local = CMax_Path * 2
Dim s As String
Dim i As Integer
Dim result As Boolean

  FileDLG = False

  OpenFileName.lStructSize = Len(OpenFileName)
  OpenFileName.hwndOwner = GetActiveWindow()
  OpenFileName.lpstrFilter = ChangeFilter(Filter)
  OpenFileName.lpstrFile = FileNameExtract(Filename) & String(CMax_Path_local, vbNullChar)
  
  OpenFileName.nMaxFile = Len(OpenFileName.lpstrFile)
  OpenFileName.lpstrFileTitle = String(CMax_Path_local, vbNullChar)
  OpenFileName.nMaxFileTitle = CMax_Path_local
  OpenFileName.lpstrInitialDir = PathNameExtract(Filename) & vbNullChar
  OpenFileName.lpstrTitle = Title
  'OpenFileName.Flags = FlagstoSet And (Not FlagsToDelete)
  OpenFileName.Flags = Flags
  OpenFileName.nFilterIndex = Filterindex
  OpenFileName.lpstrDefExt = DefaultExtension ' ohne Punkt...

  If OpenDLG Then result = GetOpenFileName(OpenFileName) Else result = GetSaveFileName(OpenFileName)
  If result Then
    s = OpenFileName.lpstrFile
    i = InStr(s, vbNullChar)
    If i > 1 Then s = Left(s, i - 1)
    Filename = s
    Filterindex = OpenFileName.nFilterIndex
    FileDLG = True
  End If


End Function

Public Function FileOpenDLG(ByVal DefaultExtension As String, ByVal Filter As String, ByRef Filename As String, Optional ByVal Title As String = "|fffd|ffnen", Optional Flags As Long = COFNFlags_Open, Optional Filterindex As Long) As Boolean
  FileOpenDLG = FileDLG(True, DefaultExtension, Filter, Filename, Title, Flags, Filterindex)
End Function


Public Function FileSaveDLG(ByVal DefaultExtension As String, ByVal Filter As String, ByRef Filename As String, Optional ByVal Title As String = "Speichern", Optional Flags As Long = COFNFlags_Save, Optional Filterindex As Long) As Boolean
  FileSaveDLG = FileDLG(False, DefaultExtension, Filter, Filename, Title, Flags, Filterindex)
End Function







Attribute VB_Name = "MSD_Crypt"
Option Explicit
Option Private Module

' Library for "crypting" routines
' last change: 2002/12/03
' Modul dependencies: [none]

' DON'T MAKE ANY CHANGES!
' All your changes will be lost with the next update of this library.
' Contact the author <ms@msdatec.de> for bug fixes or enhancements instead.

' BITTE KEINE |fffd|NDERUNGEN DURCHF|fffd|HREN!
' Alle |fffd|nderungen, die Sie hier vornehmen, gehen mit dem n|fffd|chsten Update dieses Modules verloren.
' Kontaktieren Sie anstattdessen den Autor unter <ms@msdatec.de> f|fffd|r Fehlerkorrekturen oder Verbesserungen.

' All rights of this code are reserved by MSDatec.
' See http://www.msdatec.de/ for further information.
' You are allowed to use and modify this code for personal use.
' You are NOT allowed to publish or distribute this code or parts of it
' without a written permission of MSDatec.

' Alle Rechte dieses Codes liegen bei MSDatec.
' Unter http://www.msdatec.de/ finden Sie weitere Informationen sowie Kontaktm|fffd|glichkeiten.
' Sie d|fffd|rfen f|fffd|r Ihre eigenen Bed|fffd|rfnisse diesen Code benutzen und ver|fffd|ndern.
' Sie d|fffd|rfen NICHT diesen Code oder Teile desselben ohne eine schriftliche Genehmigung
' von MSDatec publizieren oder Dritten zug|fffd|nglich machen.

' History:


Function Cryptstr(ByVal s As String) As String
Dim i As Long
Dim result As String

  If s = "" Then Exit Function
  result = Chr((Len(s) Mod 256) + Asc(Left(s, 1)) Mod 256)
  For i = 1 To Len(s) - 1
    result = result + Chr((Asc(Mid(result, i, 1)) + Asc(Mid(s, i + 1, 1))) Mod 256)
  Next i
  
  Cryptstr = result
End Function



Function DeCryptstr(ByVal s As String) As String
Dim i As Long
Dim result As String
  
  For i = Len(s) To 2 Step -1
    result = Chr((256 + Asc(Mid(s, i, 1)) - Asc(Mid(s, i - 1, 1))) Mod 256) + result
  Next i
  DeCryptstr = Chr((256 + Asc(Left(s, 1)) - Len(s)) Mod 256) + result
End Function


Attribute VB_Name = "MSD_Disk"
Option Private Module
Option Explicit


' Library for routines with access to physical storage media
' last change: 2009/05/19
' Modul dependencies: MSD_Windows

' DON'T MAKE ANY CHANGES!
' All your changes will be lost with the next update of this library.
' Contact the author <ms@msdatec.de> for bug fixes or enhancements instead.

' BITTE KEINE |fffd|NDERUNGEN DURCHF|fffd|HREN!
' Alle |fffd|nderungen, die Sie hier vornehmen, gehen mit dem n|fffd|chsten Update dieses Modules verloren.
' Kontaktieren Sie anstattdessen den Autor unter <ms@msdatec.de> f|fffd|r Fehlerkorrekturen oder Verbesserungen.

' All rights of this code are reserved by MSDatec.
' See http://www.msdatec.de/ for further information.
' You are allowed to use and modify this code for personal use.
' You are NOT allowed to publish or distribute this code or parts of it
' without a written permission of MSDatec.

' Alle Rechte dieses Codes liegen bei MSDatec.
' Unter http://www.msdatec.de/ finden Sie weitere Informationen sowie Kontaktm|fffd|glichkeiten.
' Sie d|fffd|rfen f|fffd|r Ihre eigenen Bed|fffd|rfnisse diesen Code benutzen und ver|fffd|ndern.
' Sie d|fffd|rfen NICHT diesen Code oder Teile desselben ohne eine schriftliche Genehmigung
' von MSDatec publizieren oder Dritten zug|fffd|nglich machen.

' History:
' 2009/05/19
' - CTitleMsgBox implemented
' 2004/11/27:
' - added some default file filters


' Public Function BrowseForFolder(ByRef DirName As String, ByVal DirMustExist As Boolean) As Boolean
' alte Version: Gibt im Erfolgsfalle TRUE zur|fffd|ck. *DirName* enth|fffd|lt dann den ausgew|fffd|hlten Verzeichnisnamen.
' Public Function BrowseForFolderSH(ByVal lngCSIDL As Long, ByVal lngBiFlags As Long, ByVal StartDir As String, ByRef strFolder As String, ByRef result As Long, Optional ByVal hWnd As Long = 0, Optional pszTitle As String = "Verzeichnis w|fffd|hlen:") As Boolean
' Windows-Version: Gibt im Erfolgsfalle TRUE zur|fffd|ck. *strFolder* enth|fffd|lt dann den ausgew|fffd|hlten Verzeichnisnamen.

' Public Function FileOpenDLG(ByVal DefaultExtension As String, ByVal Filter As String, ByRef Filename As String, Optional ByVal Title As String = "|fffd|ffnen", Optional Flags As Long = COFNFlags_Open) As Boolean
' Public Function FileSaveDLG(ByVal DefaultExtension As String, ByVal Filter As String, ByRef Filename As String, Optional ByVal Title As String = "Speichern", Optional Flags As Long = COFNFlags_Save) As Boolean
' Falls *FileName* nicht leer ist, werden *InitialDir* und *FileDLG.Filename* auf die entsprechenden Angaben gesetzt
' Gibt im Erfolgsfalle TRUE zur|fffd|ck. *Filename* enth|fffd|lt dann den ausgew|fffd|hlten Dateinamen.



Global Const CFileDialogFileMustExist    As Byte = 1
Global Const CFileDialogOverwritePrompt  As Byte = 2


Global Const C_FILE_ATTRIBUTE_READONLY    As Integer = 1
Global Const C_FILE_ATTRIBUTE_HIDDEN      As Integer = 2
Global Const C_FILE_ATTRIBUTE_SYSTEM      As Integer = 4
Global Const C_FILE_ATTRIBUTE_DIRECTORY   As Integer = 16
Global Const C_FILE_ATTRIBUTE_ARCHIVE     As Integer = 32
Global Const C_FILE_ATTRIBUTE_NORMAL      As Integer = 128
Global Const C_FILE_ATTRIBUTE_TEMPORARY   As Integer = 256
Global Const C_FILE_ATTRIBUTE_COMPRESSED  As Integer = 2048
Global Const C_FILE_ATTRIBUTE_OFFLINE     As Integer = 4096


Declare Function FileGetAttributes Lib "kernel32" Alias "GetFileAttributesA" (ByVal lpFileName As String) As Long


Function AskForFilename(ByRef Filename As String, ByVal CFileDialogOptions As Byte, Optional ByVal Prompt As String = "Bitte den Dateinamen eingeben:", Optional ByVal Title As String) As Boolean
Dim nochmal As Boolean

  AskForFilename = False
  Do
    Filename = InputBox(Prompt, Title, Filename)
    If Filename = "" Then Exit Function
    nochmal = False
    
    If (CFileDialogOptions And CFileDialogFileMustExist) = CFileDialogFileMustExist Then
      If Not FileExists(Filename) Then
        MsgBox "Die Datei " & Filename & " konnte nicht gefunden werden", vbCritical, CTitleMsgBox
        nochmal = True
      End If
    End If
    
    If (CFileDialogOptions And CFileDialogOverwritePrompt) = CFileDialogOverwritePrompt Then
      If FileExists(Filename) Then
        nochmal = MsgBox("Die Datei " & Filename & " existiert bereits. |fffd|berschreiben?", vbYesNo Or vbQuestion, CTitleMsgBox) = vbNo
      End If
    End If
    
  Loop While nochmal

  AskForFilename = True
End Function



Function DirExists(ByVal ADirName As String) As Boolean
' siehe auch *FileExists*
  DirExists = FileDirExists(ADirName, True)
End Function




Private Function FileDirExists(ByVal AFileDirName As String, ByVal CheckAsDir As Boolean) As Boolean
' Hilfsfunktion zu *FileExists* und *DirExists*
  
  If (AFileDirName = "") Or (FileGetAttributes(AFileDirName) < 0) Then
    FileDirExists = False
  Else
    If CheckAsDir Then
      FileDirExists = FileHasAttributes(AFileDirName, C_FILE_ATTRIBUTE_DIRECTORY)
    Else
      FileDirExists = Not FileHasAttributes(AFileDirName, C_FILE_ATTRIBUTE_DIRECTORY)
    End If
  End If
End Function



Function FileExists(ByVal AFilename As String) As Boolean
' siehe auch *DirExists*
  FileExists = FileDirExists(AFilename, False)
End Function


Function FileHasAttributes(ByVal AFilename As String, ByVal Attributes As Long) As Boolean
' Gibt TRUE zur|fffd|ck, falls *AFilename* |fffd|ber alle angegebene(n) *Attributes* verf|fffd|gt.
Dim l As Long
  
  l = FileGetAttributes(AFilename)
  If l <> -1 Then
    FileHasAttributes = (l And Attributes) = Attributes
  Else
    FileHasAttributes = False
  End If
End Function


Public Function GetTmpName(Optional Template As String = "tmp~") As String
  GetTmpName = Template & CLng(Date) & CStr(GetTickCount)
End Function




Attribute VB_Name = "MSD_DiskStrg"
Option Private Module
Option Explicit


' Library for storage name manipulation without access to physical storage media
' last change: 2006/01/26
' Modul dependencies: MSD_Windows, MSD_All, MSD_Strg

' DON'T MAKE ANY CHANGES!
' All your changes will be lost with the next update of this library.
' Contact the author <ms@msdatec.de> for bug fixes or enhancements instead.

' BITTE KEINE |fffd|NDERUNGEN DURCHF|fffd|HREN!
' Alle |fffd|nderungen, die Sie hier vornehmen, gehen mit dem n|fffd|chsten Update dieses Modules verloren.
' Kontaktieren Sie anstattdessen den Autor unter <ms@msdatec.de> f|fffd|r Fehlerkorrekturen oder Verbesserungen.

' All rights of this code are reserved by MSDatec.
' See http://www.msdatec.de/ for further information.
' You are allowed to use and modify this code for personal use.
' You are NOT allowed to publish or distribute this code or parts of it
' without a written permission of MSDatec.

' Alle Rechte dieses Codes liegen bei MSDatec.
' Unter http://www.msdatec.de/ finden Sie weitere Informationen sowie Kontaktm|fffd|glichkeiten.
' Sie d|fffd|rfen f|fffd|r Ihre eigenen Bed|fffd|rfnisse diesen Code benutzen und ver|fffd|ndern.
' Sie d|fffd|rfen NICHT diesen Code oder Teile desselben ohne eine schriftliche Genehmigung
' von MSDatec publizieren oder Dritten zug|fffd|nglich machen.

' History:
' 2006/01/26
' - Modul dependencies updated
' 2004/11/27:
' - added some default file filters


' Public Function BrowseForFolder(ByRef DirName As String, ByVal DirMustExist As Boolean) As Boolean
' alte Version: Gibt im Erfolgsfalle TRUE zur|fffd|ck. *DirName* enth|fffd|lt dann den ausgew|fffd|hlten Verzeichnisnamen.
' Public Function BrowseForFolderSH(ByVal lngCSIDL As Long, ByVal lngBiFlags As Long, ByVal StartDir As String, ByRef strFolder As String, ByRef result As Long, Optional ByVal hWnd As Long = 0, Optional pszTitle As String = "Verzeichnis w|fffd|hlen:") As Boolean
' Windows-Version: Gibt im Erfolgsfalle TRUE zur|fffd|ck. *strFolder* enth|fffd|lt dann den ausgew|fffd|hlten Verzeichnisnamen.

' Public Function FileOpenDLG(ByVal DefaultExtension As String, ByVal Filter As String, ByRef Filename As String, Optional ByVal Title As String = "|fffd|ffnen", Optional Flags As Long = COFNFlags_Open) As Boolean
' Public Function FileSaveDLG(ByVal DefaultExtension As String, ByVal Filter As String, ByRef Filename As String, Optional ByVal Title As String = "Speichern", Optional Flags As Long = COFNFlags_Save) As Boolean
' Falls *FileName* nicht leer ist, werden *InitialDir* und *FileDLG.Filename* auf die entsprechenden Angaben gesetzt
' Gibt im Erfolgsfalle TRUE zur|fffd|ck. *Filename* enth|fffd|lt dann den ausgew|fffd|hlten Dateinamen.




Function ChangeFileExt(ByVal Filename As String, ByVal Extension As String) As String
Dim i As Long
  i = LastDelimiter(".\:", Filename)
  If (i = 0) Then
    i = Len(Filename) + 1
  Else
    If Mid(Filename, i, 1) <> "." Then i = Len(Filename) + 1
  End If
   ChangeFileExt = Left(Filename, i - 1) & Extension
End Function



Function DirBS(ByVal APathName As String) As String
' h|fffd|ngt ggf. einen Backslash an das Ende von *APathName* an.
  If APathName <> "" Then
    If Mid(APathName, Len(APathName)) <> "\" Then
      DirBS = APathName & "\"
    Else
      DirBS = APathName
    End If
  Else
    DirBS = APathName
  End If
End Function





Function FileExtensionExtract(ByVal AFilename As String) As String
' Gibt die Dateinamenserweiterung aus *AFileName* zur|fffd|ck (ohne Punkt) oder eine leere ZK
Dim i As Long
  
  i = CharPosLastGetCR(Asc("."), AFilename)
  If i > 0 Then
    FileExtensionExtract = Right(AFilename, Len(AFilename) - i)
  Else
    FileExtensionExtract = ""
  End If
  
End Function



Function FileNameExtract(ByVal s As String) As String
' Gibt den in *s* enthaltenen Dateinamen (einschlie|fffd|lich Erweiterung) zur|fffd|ck oder nichts.
' siehe auch *PathNameExtract*, *FileNameSplit*

Dim AFilename As String
Dim TmpS As String


  FileNameSplit s, TmpS, AFilename
  FileNameExtract = AFilename
End Function



Sub FileNameSplit(ByVal s As String, ByRef APath As String, ByRef AFilename As String, Optional ByRef AExtension)
' siehe auch *FileNameExtract*, *PathNameExtract*
' Wenn *AExtension* vorhanden ist, wird der Dateiname nochmals in Dateiname und Erweiterung aufgeteilt.
' Falls eine Erweiterung vorhanden ist, erh|fffd|lt *AExtension* den Teil nach dem Punkt
Dim i As Long
  
  i = MaxInt(CharPosLastGetCR(Asc("\"), s), CharPosLastGetCR(Asc(":"), s))
  If i = 0 Then
    AFilename = s
    APath = ""
  Else
    AFilename = Mid(s, i + 1)
    APath = Left(s, i - 1)
  End If
  ' Extension ermitteln:
  If Not IsMissing(AExtension) Then
    If AFilename <> "" Then
      i = CharPosLastGetCR(Asc("."), AFilename)
      If i <> 0 Then
        AExtension = Right(AFilename, Len(AFilename) - i)
        AFilename = Left(AFilename, i - 1)
      End If
    End If
  End If
End Sub


Function PathNameExtract(ByVal s As String) As String
' siehe auch *FileNameExtract*, *FileNameSplit*
Dim APathName As String
Dim TmpS As String
  FileNameSplit s, APathName, TmpS
  PathNameExtract = APathName
End Function

Attribute VB_Name = "MSD_Inifile"
Option Explicit
Option Private Module

' Library for ini file handling
' last change: 2009/11/28
' Modul dependencies: [none]

' DON'T MAKE ANY CHANGES!
' All your changes will be lost with the next update of this library.
' Contact the author <ms@msdatec.de> for bug fixes or enhancements instead.

' BITTE KEINE |fffd|NDERUNGEN DURCHF|fffd|HREN!
' Alle |fffd|nderungen, die Sie hier vornehmen, gehen mit dem n|fffd|chsten Update dieses Modules verloren.
' Kontaktieren Sie anstattdessen den Autor unter <ms@msdatec.de> f|fffd|r Fehlerkorrekturen oder Verbesserungen.

' All rights of this code are reserved by MSDatec.
' See http://www.msdatec.de/ for further information.
' You are allowed to use and modify this code for personal use.
' You are NOT allowed to publish or distribute this code or parts of it
' without a written permission of MSDatec.

' Alle Rechte deses Codes liegen bei MSDatec.
' Unter http://www.msdatec.de/ finden Sie weitere Informationen sowie Kontaktm|fffd|glichkeiten.
' Sie d|fffd|rfen f|fffd|r Ihre eigenen Bed|fffd|rfnisse diesen Code benutzen und ver|fffd|ndern.
' Sie d|fffd|rfen NICHT diesen Code oder Teile desselben ohne eine schriftliche Genehmigung
' von MSDatec publizieren oder Dritten zug|fffd|nglich machen.

' History:
'(bislang nur in KALENDER.XLS verwendet)
' 2009/11/28
' - *ColorFormat.TintAndShade* ausgetauscht durch *CallByName(AColorFormat, CPropertyName_TintAndShade, *vbCallType*), da in Excel<2003 unbekannt

' Todo:
' - je nach Objekten aufteilen in MSD_Inifile_Excel, MSD_Inifile_Access, usw.

' Summary:
' IniDeleteSection, IniDeleteKey

' BooleanToIniValue/IniValueToBoolean

' IniReadLong/IniWriteLong
' IniReadInteger/IniWriteInteger
' IniReadDouble/IniWriteDouble
' IniReadString/IniWriteString
' IniReadFormattedStringToken/IniWriteFormattedStringToken
' IniReadBoolean/IniWriteBoolean

' IniReadFont/IniWriteFont
' IniWriteFillformat
' IniReadColorFormat/IniWriteColorFormat
' IniReadInterior/IniWriteInterior



Private Declare Function GetPrivateProfileStringA Lib "kernel32.dll" (ByVal lpAppName As String, ByVal lpKeyName As String, ByVal lpDefault As String, ByVal lpReturnedString As String, ByVal nSize As Long, ByVal lpFileName As String) As Long
Private Declare Function WritePrivateProfileStringA Lib "kernel32.dll" (ByVal lpSection As String, ByVal lpszKey As Any, ByVal lpszString As Any, ByVal lpszFile As String) As Boolean

Global Const CIniSection_PrefixColorFormat As String = "ColorFormat"
Global Const CIniSection_PrefixShape       As String = "Shape"
Global Const CIniSection_PrefixFont        As String = "Font"
Global Const CIniSection_PrefixInterior    As String = "Interior"


Private Const CIniKeyBackColor             As String = "BackColor"
Private Const CIniKeyColor                 As String = "Color"
Private Const CIniKeyColorindex            As String = "Colorindex"
Private Const CIniKeyFill                  As String = "Fill"
Private Const CIniKeyFontBold              As String = "Bold"
Private Const CIniKeyFontItalic            As String = "Italic"
Private Const CIniKeyFontName              As String = "Name"
Private Const CIniKeyFontOutlineFont       As String = "OutlineFont"
Private Const CIniKeyFontSize              As String = "Size"
Private Const CIniKeyFontStrikethrough     As String = "Strikethrough"
Private Const CIniKeyFontSubscript         As String = "Subscript"
Private Const CIniKeyFontSuperscript       As String = "Superscript"
Private Const CIniKeyFontUnderline         As String = "Underline"
Private Const CIniKeyForeColor             As String = "ForeColor"
Private Const CIniKeyGradientColorType     As String = "GradientColorType"
Private Const CIniKeyGradientDegree        As String = "GradientDegree"
Private Const CIniKeyGradientPattern       As String = "Pattern"
Private Const CIniKeyGradientStyle         As String = "GradientStyle"
Private Const CIniKeyGradientVariant       As String = "GradientVariant"
Private Const CIniKeyHeight                As String = "Height"
Private Const CIniKeyLeft                  As String = "Left"
Private Const CIniKeyLocked                As String = "Locked"
Private Const CIniKeyPattern               As String = "Pattern"
Private Const CIniKeyPatternColor          As String = "PatternColor"
Private Const CIniKeyPatternColorIndex     As String = "PatternColorIndex"
Private Const CIniKeyPlacement             As String = "Placement"
Private Const CIniKeyPresetGradientType    As String = "PresetGradientType"
Private Const CIniKeyPresetTexture         As String = "PresetTexture"
Private Const CIniKeyRGB                   As String = "RGB"
Private Const CIniKeySchemeColor           As String = "SchemeColor"
Private Const CIniKeyTextureName           As String = "TextureName"
Private Const CIniKeyTextureType           As String = "TextureType"
Private Const CIniKeyTintAndShade          As String = "TintAndShade"
Private Const CIniKeyTop                   As String = "Top"
Private Const CIniKeyTransparency          As String = "Transparency"
Private Const CIniKeyType                  As String = "Type"
Private Const CIniKeyVisible               As String = "Visible"
Private Const CIniKeyWidth                 As String = "Width"


Private Const CPropertyName_TintAndShade   As String = "TintAndShade"

Public Const CDefault_Font_Size                            As Byte = 10
Public Const CDefault_Font_Bold                            As Boolean = False
Public Const CDefault_Font_Color                            As Byte = 0
Public Const CDefault_Font_Italic                           As Boolean = False
Public Const CDefault_Font_Name                             As String = "Arial"
Public Const CDefault_Font_Strikethrough                    As Boolean = False
Public Const CDefault_Font_Subscript                        As Boolean = False
Public Const CDefault_Font_Superscript                      As Boolean = False
Public Const CDefault_Font_Underline                        As Integer = xlUnderlineStyleNone


Public Function BooleanToIniValue(ByVal b As Boolean) As String
' true -> "1", false -> "0"
' see also  *IniValueToBoolean*
  BooleanToIniValue = CInt(Not b) + 1
End Function


Public Function IniValueToBoolean(ByVal i As Integer) As Boolean
' 0 -> false, anything else -> true
' see also *BooleanToIniValue*
  If i = 0 Then IniValueToBoolean = False Else IniValueToBoolean = True
End Function


Public Function IniDeleteSection(ByVal Section As String, ByVal InifileName As String) As Boolean
  IniDeleteSection = WritePrivateProfileStringA(Section, vbNullString, vbNullString, InifileName) = 1
End Function


Public Function IniDeleteKey(ByVal Section As String, ByVal Key As String, InifileName As String) As Boolean
  IniDeleteKey = WritePrivateProfileStringA(Section, Key, vbNullString, InifileName) = 1
End Function



Public Function IniReadBoolean(ByVal Section As String, ByVal Key As String, ByVal Default As Boolean, ByVal InifileName As String) As Boolean
  IniReadBoolean = IniValueToBoolean(IniReadInteger(Section, Key, BooleanToIniValue(Default), InifileName))
End Function



Public Sub IniReadFont(ByVal Section As String, AFont As Font, ByVal InifileName As String)
  AFont.Size = IniReadInteger(Section, CIniKeyFontSize, CDefault_Font_Size, InifileName)
  AFont.Bold = IniReadBoolean(Section, CIniKeyFontBold, CDefault_Font_Bold, InifileName)
  AFont.Color = IniReadLong(Section, CIniKeyColor, CDefault_Font_Color, InifileName)
  AFont.Italic = IniReadBoolean(Section, CIniKeyFontItalic, CDefault_Font_Italic, InifileName)
  AFont.Name = IniReadString(Section, CIniKeyFontName, CDefault_Font_Name, InifileName)
  'AFont.OutlineFont = IniReadBoolean(Section, CIniKeyFontOutlineFont, False, InifileName)
  AFont.Strikethrough = IniReadBoolean(Section, CIniKeyFontStrikethrough, CDefault_Font_Strikethrough, InifileName)
  AFont.Subscript = IniReadBoolean(Section, CIniKeyFontSubscript, CDefault_Font_Subscript, InifileName)
  AFont.Superscript = IniReadBoolean(Section, CIniKeyFontSuperscript, CDefault_Font_Superscript, InifileName)
  AFont.Underline = IniReadInteger(Section, CIniKeyFontUnderline, CDefault_Font_Underline, InifileName)
End Sub


Public Function IniReadFormattedStringToken(ByVal Section As String, ByRef Value As String, ByRef AFont As Font, ByVal InifileName As String) As String
' R|fffd|ckgabe: Wert von "Next"
Dim s As String
  
  Value = IniReadString(Section, "Text", "", InifileName)
  s = IniReadString(Section, "Font", "", InifileName)
  If s <> "" Then IniReadFont s, AFont, InifileName
  IniReadFormattedStringToken = IniReadString(Section, "Next", "", InifileName)
End Function


Public Sub IniReadInterior(ByVal Section As String, ByRef AInterior As Interior, ByVal InifileName As String)
  AInterior.ColorIndex = IniReadInteger(Section, CIniKeyColorindex, AInterior.ColorIndex, InifileName)
  AInterior.Color = IniReadLong(Section, CIniKeyColor, AInterior.Color, InifileName)
  AInterior.Pattern = IniReadLong(Section, CIniKeyPattern, AInterior.Pattern, InifileName)
  AInterior.PatternColor = IniReadLong(Section, CIniKeyPatternColor, AInterior.PatternColor, InifileName)
  AInterior.PatternColorIndex = IniReadLong(Section, CIniKeyPatternColorIndex, AInterior.PatternColorIndex, InifileName)
End Sub



Public Function IniReadLong(ByVal Section As String, ByVal Key As String, ByVal Default As Long, ByVal InifileName As String) As Long
Dim s As String

  s = IniReadString(Section, Key, CStr(Default), InifileName)
  If IsNumeric(s) Then
    IniReadLong = CLng(s)
  Else
    IniReadLong = Default
  End If
End Function


Public Function IniReadInteger(ByVal Section As String, ByVal Key As String, ByVal Default As Integer, ByVal InifileName As String) As Integer
Dim s As String

  s = IniReadString(Section, Key, CStr(Default), InifileName)
  If IsNumeric(s) Then
    IniReadInteger = CInt(s)
  Else
    IniReadInteger = Default
  End If
End Function

Public Function IniReadDouble(ByVal Section As String, ByVal Key As String, ByVal Default As Double, ByVal InifileName As String) As Double
Dim s As String
  s = IniReadString(Section, Key, "", InifileName)
  If s = "" Then
    IniReadDouble = Default
  Else
    IniReadDouble = val(s)
  End If

End Function



Public Function IniReadString(ByVal Section As String, ByVal Key As String, ByVal Default As String, ByVal InifileName As String) As String
Const CBufSize = 1024
Dim CharCount As Long
Dim s As String * CBufSize
  CharCount = GetPrivateProfileStringA(Section, Key, Default, s, CBufSize, InifileName)
  IniReadString = Left(s, CharCount)
End Function



Public Function IniWriteBoolean(ByVal Section As String, ByVal Key As String, ByVal Value As Boolean, ByVal InifileName As String) As Boolean
  IniWriteBoolean = IniWriteInteger(Section, Key, BooleanToIniValue(Value), InifileName)
End Function


Public Sub IniReadColorFormat(ByVal Section As String, ByRef AColorFormat As ColorFormat, ByVal InifileName As String)
On Error Resume Next ' *AColorFormat.TintAndShade* ist unter Excel 2000 unbekannt
  AColorFormat.RGB = IniReadLong(Section, CIniKeyRGB, AColorFormat.RGB, InifileName)
  If AColorFormat.Type = msoColorTypeScheme Then
    AColorFormat.SchemeColor = IniReadLong(Section, CIniKeySchemeColor, AColorFormat.SchemeColor, InifileName)
  End If
  
  CallByName(AColorFormat, CPropertyName_TintAndShade, VbLet) = IniReadDouble(Section, CIniKeyTintAndShade, CallByName(AColorFormat, CPropertyName_TintAndShade, VbGet), InifileName)
  
  ' Schreibgesch|fffd|tzte Eigenschaft:
  'AColorFormat.Type = IniReadLong(Section, CIniKeyType, AColorFormat.Type, InifileName)
End Sub


Public Sub IniWriteColorFormat(ByVal Section As String, ByRef AColorFormat As ColorFormat, ByVal InifileName As String)
' On Error Resume Next ' SchemeColor laesst sich nicht auslesen bei Wordarts
  IniWriteLong Section, CIniKeyRGB, AColorFormat.RGB, InifileName
  If AColorFormat.Type = msoColorTypeScheme Then
    IniWriteLong Section, CIniKeySchemeColor, AColorFormat.SchemeColor, InifileName
  End If
  'IniWriteDouble Section, CIniKeyTintAndShade, AColorFormat.TintAndShade, InifileName
  IniWriteDouble Section, CIniKeyTintAndShade, CallByName(AColorFormat, CPropertyName_TintAndShade, VbGet), InifileName
  
  ' Schreibgesch|fffd|tzte Eigenschaft:
  IniWriteLong Section, CIniKeyType, AColorFormat.Type, InifileName
End Sub


Public Sub IniReadFillformat(ByVal Section As String, ByRef AFillFormat As FillFormat, ByVal InifileName As String)
Dim s As String
Dim GradientDegree As Double
Dim GradientStyle As Long, GradientVariant  As Long, GradientColorType As Long, PresetGradientType  As Long, Pattern As Long, _
                  TextureType As Long


  AFillFormat.Transparency = IniReadDouble(Section, CIniKeyTransparency, AFillFormat.Transparency, InifileName)
  'AFillFormat.Type = IniReadLong(Section, CIniKeyType, AFillFormat.Type, InifileName)
  AFillFormat.Visible = IniReadLong(Section, CIniKeyVisible, AFillFormat.Visible, InifileName)


  s = IniReadString(Section, CIniKeyForeColor, "", InifileName)
  If s <> "" Then IniReadColorFormat s, AFillFormat.ForeColor, InifileName
  s = IniReadString(Section, CIniKeyBackColor, "", InifileName)
  If s <> "" Then IniReadColorFormat s, AFillFormat.BackColor, InifileName
  
  If (AFillFormat.Type = msoFillGradient) And (AFillFormat.GradientColorType = msoGradientOneColor) Then
    GradientDegree = AFillFormat.GradientDegree
  Else
    GradientDegree = 0
  End If
  
  GradientDegree = IniReadDouble(Section, CIniKeyGradientDegree, GradientDegree, InifileName)
  GradientStyle = IniReadLong(Section, CIniKeyGradientStyle, AFillFormat.GradientStyle, InifileName)
  GradientVariant = IniReadLong(Section, CIniKeyGradientVariant, AFillFormat.GradientVariant, InifileName)
  PresetGradientType = IniReadLong(Section, CIniKeyPresetGradientType, AFillFormat.PresetGradientType, InifileName)
  
  GradientColorType = IniReadLong(Section, CIniKeyGradientColorType, AFillFormat.GradientColorType, InifileName)
  Select Case GradientColorType
    
    Case msoGradientColorMixed
      ' ?
    
    Case msoGradientOneColor
      AFillFormat.OneColorGradient GradientStyle, GradientVariant, GradientDegree
      
    Case msoGradientPresetColors
      AFillFormat.PresetGradient GradientStyle, GradientVariant, PresetGradientType
    
    Case msoGradientTwoColors
      AFillFormat.TwoColorGradient GradientStyle, GradientVariant
  End Select
  
  
'  AFillFormat.Patterned IniReadLong(Section, CIniKeyPattern, AFillFormat.Pattern, InifileName)
  
  
  TextureType = IniReadLong(Section, CIniKeyTextureType, AFillFormat.TextureType, InifileName)
  
  
  Select Case TextureType
    Case msoTexturePreset
      AFillFormat.PresetTextured IniReadLong(Section, CIniKeyPresetTexture, AFillFormat.PresetTexture, InifileName)
    Case msoTextureTypeMixed
      ' ?
    Case msoTextureUserDefined
      AFillFormat.UserTextured IniReadString(Section, CIniKeyTextureName, AFillFormat.TextureName, InifileName)
  End Select

  
  
  
  
End Sub


Public Sub IniWriteFillformat(ByVal Section As String, AFillFormat As FillFormat, ByVal InifileName As String)
On Error Resume Next ' wurde erforderlich, da bei Kommentaren der Zugriff auf *AFillFormat.GradientDegree* verweigert wird
Dim OtherSection As String

  OtherSection = CIniSection_PrefixColorFormat & CStr(NextFreeSectionID)
  IniWriteColorFormat OtherSection, AFillFormat.ForeColor, InifileName
  IniWriteString Section, CIniKeyForeColor, OtherSection, InifileName
  
  
  OtherSection = CIniSection_PrefixColorFormat & CStr(NextFreeSectionID)
  IniWriteColorFormat OtherSection, AFillFormat.BackColor, InifileName
  IniWriteString Section, CIniKeyBackColor, OtherSection, InifileName
  
  IniWriteLong Section, CIniKeyGradientColorType, AFillFormat.GradientColorType, InifileName
  IniWriteDouble Section, CIniKeyGradientDegree, AFillFormat.GradientDegree, InifileName
  IniWriteLong Section, CIniKeyGradientStyle, AFillFormat.GradientStyle, InifileName
  IniWriteLong Section, CIniKeyGradientVariant, AFillFormat.GradientVariant, InifileName
  IniWriteLong Section, CIniKeyPattern, AFillFormat.Pattern, InifileName
  IniWriteLong Section, CIniKeyPresetGradientType, AFillFormat.PresetGradientType, InifileName
  IniWriteLong Section, CIniKeyPresetTexture, AFillFormat.PresetTexture, InifileName
  IniWriteString Section, CIniKeyTextureName, AFillFormat.TextureName, InifileName
  IniWriteLong Section, CIniKeyTextureType, AFillFormat.TextureType, InifileName
  IniWriteDouble Section, CIniKeyTransparency, AFillFormat.Transparency, InifileName
  ' der Typ sollte sich aus den anderen Einstellungen ergeben...
  'IniWriteLong Section, CIniKeyType, AFillFormat.Type, InifileName
  IniWriteLong Section, CIniKeyVisible, AFillFormat.Visible, InifileName
  
End Sub


Public Function IniWriteFont(ByVal Section As String, AFont As Font, ByVal InifileName As String) As Boolean
  IniWriteFont = False
  If Not IniWriteInteger(Section, CIniKeyFontSize, AFont.Size, InifileName) Then Exit Function
  If Not IniWriteBoolean(Section, CIniKeyFontBold, AFont.Bold, InifileName) Then Exit Function
  If Not IniWriteLong(Section, CIniKeyColor, AFont.Color, InifileName) Then Exit Function
  If Not IniWriteBoolean(Section, CIniKeyFontItalic, AFont.Italic, InifileName) Then Exit Function
  If Not IniWriteString(Section, CIniKeyFontName, AFont.Name, InifileName) Then Exit Function
  'If Not IniWriteBoolean(Section, CIniKeyFontOutlineFont, AFont.OutlineFont, InifileName) Then Exit Function
  If Not IniWriteBoolean(Section, CIniKeyFontStrikethrough, AFont.Strikethrough, InifileName) Then Exit Function
  If Not IniWriteBoolean(Section, CIniKeyFontSubscript, AFont.Subscript, InifileName) Then Exit Function
  If Not IniWriteBoolean(Section, CIniKeyFontSuperscript, AFont.Superscript, InifileName) Then Exit Function
  If Not IniWriteInteger(Section, CIniKeyFontUnderline, AFont.Underline, InifileName) Then Exit Function
  IniWriteFont = True
End Function


Public Function IniWriteInterior(ByVal Section As String, AInterior As Interior, ByVal InifileName As String) As Boolean
  IniWriteInterior = False
  If Not IniWriteInteger(Section, CIniKeyColorindex, AInterior.ColorIndex, InifileName) Then Exit Function
  If Not IniWriteLong(Section, CIniKeyColor, AInterior.Color, InifileName) Then Exit Function
  If Not IniWriteLong(Section, CIniKeyPattern, AInterior.Pattern, InifileName) Then Exit Function
  If Not IniWriteLong(Section, CIniKeyPatternColor, AInterior.PatternColor, InifileName) Then Exit Function
  If Not IniWriteLong(Section, CIniKeyPatternColorIndex, AInterior.PatternColorIndex, InifileName) Then Exit Function
  'If Not IniWriteBoolean(Section, "InvertIfNegative", AInterior.InvertIfNegative, InifileName) Then Exit Function
  IniWriteInterior = True
End Function



Public Function IniWriteInteger(ByVal Section As String, ByVal Key As String, ByVal Value As Integer, ByVal InifileName As String) As Boolean
  IniWriteInteger = WritePrivateProfileStringA(Section, Key, CStr(Value), InifileName) = 1
End Function

Public Function IniWriteLong(ByVal Section As String, ByVal Key As String, ByVal Value As Long, ByVal InifileName As String) As Boolean
  IniWriteLong = WritePrivateProfileStringA(Section, Key, CStr(Value), InifileName) = 1
End Function

Public Function IniWriteDouble(ByVal Section As String, ByVal Key As String, ByVal Value As Double, ByVal InifileName As String) As Boolean
  Dim s As String
  
  s = Trim(Str(Value))
  IniWriteDouble = WritePrivateProfileStringA(Section, Key, s, InifileName) = 1
End Function


Public Sub IniWriteShape(ByVal Section As String, ByRef AShape As Shape, ByVal InifileName As String)
Dim s As String
  IniWriteDouble Section, CIniKeyWidth, AShape.Width, InifileName
  IniWriteDouble Section, CIniKeyHeight, AShape.Height, InifileName
  IniWriteDouble Section, CIniKeyTop, AShape.Top, InifileName
  IniWriteDouble Section, CIniKeyLeft, AShape.Left, InifileName
  'IniWriteBoolean Section, CIniKeyShadow, AShape.Shadow, InifileName
  IniWriteInteger Section, CIniKeyVisible, AShape.Visible, InifileName
  IniWriteInteger Section, CIniKeyPlacement, AShape.Placement, InifileName
  IniWriteBoolean Section, CIniKeyLocked, AShape.Locked, InifileName
  s = CIniKeyFill & CStr(NextFreeSectionID)
  IniWriteFillformat s, AShape.Fill, InifileName
  IniWriteString Section, CIniKeyFill, s, InifileName
End Sub


Public Sub IniReadShape(ByVal Section As String, ByRef AShape As Shape, ByVal InifileName As String)
Dim s As String

  AShape.Width = IniReadDouble(Section, CIniKeyWidth, AShape.Width, InifileName)
  AShape.Height = IniReadDouble(Section, CIniKeyHeight, AShape.Height, InifileName)
  AShape.Top = IniReadDouble(Section, CIniKeyTop, AShape.Top, InifileName)
  AShape.Left = IniReadDouble(Section, CIniKeyLeft, AShape.Left, InifileName)
  'InireadBoolean Section, CIniKeyShadow, AShape.Shadow, InifileName
  AShape.Visible = IniReadInteger(Section, CIniKeyVisible, AShape.Visible, InifileName)
  AShape.Placement = IniReadInteger(Section, CIniKeyPlacement, AShape.Placement, InifileName)
  AShape.Locked = IniReadBoolean(Section, CIniKeyLocked, AShape.Locked, InifileName)
  s = IniReadString(Section, CIniKeyFill, "", InifileName)
  If s <> "" Then
    IniReadFillformat s, AShape.Fill, InifileName
  End If
End Sub



Public Function IniWriteString(ByVal Section As String, ByVal Key As String, ByVal Value As String, ByVal InifileName As String) As Boolean
  IniWriteString = WritePrivateProfileStringA(Section, Key, Value, InifileName) = 1
End Function


Public Function IniWriteFormattedStringToken(ByVal Section As String, ByVal Value As String, ByVal FontSection As String, AFont As Font, ByVal InifileName As String) As Boolean
  If IniWriteString(Section, "Font", FontSection, InifileName) Then _
    If IniWriteFont(FontSection, AFont, InifileName) Then _
      IniWriteFormattedStringToken = IniWriteString(Section, "Text", Value, InifileName) _
        Else IniWriteFormattedStringToken = False
End Function






Attribute VB_Name = "MSD_Strg"
Option Explicit
Option Private Module


' Library for global string routines
' last change: 2009/11/06
' Modul dependencies: windows, all

' DON'T MAKE ANY CHANGES!
' All your changes will be lost with the next update of this library.
' Contact the author <ms@msdatec.de> for bug fixes or enhancements instead.

' BITTE KEINE |fffd|NDERUNGEN DURCHF|fffd|HREN!
' Alle |fffd|nderungen, die Sie hier vornehmen, gehen mit dem n|fffd|chsten Update dieses Modules verloren.
' Kontaktieren Sie anstattdessen den Autor unter <ms@msdatec.de> f|fffd|r Fehlerkorrekturen oder Verbesserungen.

' All rights of this code are reserved by MSDatec.
' See http://www.msdatec.de/ for further information.
' You are allowed to use and modify this code for personal use.
' You are NOT allowed to publish or distribute this code or parts of it
' without a written permission of MSDatec.

' Alle Rechte deses Codes liegen bei MSDatec.
' Unter http://www.msdatec.de/ finden Sie weitere Informationen sowie Kontaktm|fffd|glichkeiten.
' Sie d|fffd|rfen f|fffd|r Ihre eigenen Bed|fffd|rfnisse diesen Code benutzen und ver|fffd|ndern.
' Sie d|fffd|rfen NICHT diesen Code oder Teile desselben ohne eine schriftliche Genehmigung
' von MSDatec publizieren oder Dritten zug|fffd|nglich machen.

' History:
'2009/11/06
' - Function *TokenNext*: added boolean parameter *LinebreakIsDelimiter*
' - Function SkipCharsWhite: changed data type Integer to Long for parameter *Index*, changed *StrIsComment* accordingly
' - Function *CharPosFirstHaveCR*, *SkipChars* and *IsLineBreak* introduced
'2009/10/29
' - added function CountChars
'2009/07/05
' - added functions *CharIsAlpha*, *CharIsValidURIChar*, *encodeURI*, *decodeURI*, *uInt4ToHexStr*, *uInt8ToHexStr*, *uInt8ToHexStrZero*, *IsUInt8HexStr*, *StrIsComment*
' - Bugfix in function *HexStrToUInt8*
' - changed param type *index* from int to long in function *TokenNext*
'2009/05/20
' - added functions *QuoteStrDouble*, *QuoteStrSingle*
'2009/05/19
' - *TokenNext*: if *index*=0, *index* is set to 1
'2009/05/15
' - Function *SplitIntoNameAndValue* implemented
'2008/12/01
' - Functions *CharIsWhite*, *SkipCharsWhite*  implemented
' - Bugfix function *TokenNext*
'2008/01/25
' - inserted some "Asc()" in functions, that are using *CharIsDecDigit*, changed parameter type from byte to int in that function
' 2007/10/01:
' - Functions *HexDigitToUInt4*, *HexStrToUInt8*, *CharIsHexDigit* implemented
' 2007/09/06:
' - Function *ReplaceStrs* implemented



Function CharIsAlpha(ByVal CharCode As Integer) As Boolean
' ist Char(CharCode) innerhalb von "a-zA-Z"? (ohne Umlaute)
  CharIsAlpha = ((CharCode >= 97) And (CharCode <= 122)) Or ((CharCode >= 65) And (CharCode <= 90))
End Function


Function CharIsDecDigit(ByVal CharCode As Integer) As Boolean
  CharIsDecDigit = (CharCode >= 48) And (CharCode <= 57)
End Function


Function CharIsHexDigit(ByVal CharCode As Integer) As Boolean
  CharIsHexDigit = CharIsDecDigit(CharCode) Or ((CharCode >= 65) And (CharCode <= 70)) Or ((CharCode >= 97) And (CharCode <= 102))
End Function


Function CharIsValidURIChar(ByVal CharCode As Integer, ByVal Component As Boolean) As Boolean
' g|fffd|ltige Zeichen:
' 0-9A-Za-z
' - _ . ! ~ * ' ( ) , / ? : @ & = + $
' Const CValidChars As String = "-_.!~*'(),/?:@&=+$"
Const CValidCharsComponent As String = "-_.!~*'()"
Const CValidCharsOthers As String = ",/?:@&=+$"
Dim i As Byte
Dim ValidChars As String

  ValidChars = CValidCharsComponent
  If Not Component Then ValidChars = ValidChars & CValidCharsOthers
  CharIsValidURIChar = True
  If CharIsAlpha(CharCode) Then Exit Function
  If CharIsDecDigit(CharCode) Then Exit Function
  For i = 1 To Len(ValidChars)
    If Asc(Mid(ValidChars, i, 1)) = CharCode Then Exit Function
  Next i
  CharIsValidURIChar = False
End Function




Function CharIsWhite(ByVal CharCode As Byte) As Boolean
  CharIsWhite = True
  If CharCode = 32 Then Exit Function ' Space
  If CharCode = 9 Then Exit Function  ' Tab
  If CharCode = 10 Then Exit Function ' LF
  If CharCode = 11 Then Exit Function ' VerticalTab
  If CharCode = 12 Then Exit Function ' FormFeed
  If CharCode = 13 Then Exit Function ' CR
  If CharCode = 27 Then Exit Function ' ESC
  CharIsWhite = False
End Function


Function CharPosFirstHaveCR(ByVal CharCode As Byte, ByVal s As String, ByRef Index As Long) As Boolean
Dim v As Variant
  CharPosFirstHaveCR = False
  v = InStr(1, s, Chr(CharCode), vbBinaryCompare)
  If IsNull(v) Then Exit Function
  If v = 0 Then Exit Function
  Index = v
  CharPosFirstHaveCR = True
End Function




Function CharPosFirstGetCR(ByVal CharCode As Byte, ByVal s As String) As Long
' Liefert die Position des ersten Auftretens des Zeichens mit dem
' angegebenen *CharCode* in *s* oder 0, falls nicht vorhanden.
' Zwischen Gross- und Kleinschreibung wird unterschieden.
Dim i As Long
Dim c As String
  
  CharPosFirstGetCR = 0
  If s = "" Then Exit Function
  c = Chr(CharCode)
  i = 1
  While i <= Len(s)
    If Mid(s, i, 1) = c Then
      CharPosFirstGetCR = i
      Exit Function
    End If
    i = i + 1
  Wend

End Function


Function CharPosLastGet(ByVal CharCode As Byte, ByVal s As String, ByVal CaseRespect As Boolean) As Long
'Wie *CharPosLastHave*, jedoch wird hier die Position des Zeichens
'zurueckgegeben (oder 0, falls nicht vorhanden).
  If CaseRespect Then
    CharPosLastGet = CharPosLastGetCR(CharCode, s)
  Else
    CharPosLastGet = CharPosLastGetCI(CharCode, s)
  End If
End Function


Function CharPosLastGetCI(ByVal CharCode As Byte, ByVal s As String) As Long
'Liefert die Position des letzten Auftretens in *s* oder 0, falls nicht
'vorhanden. Zwischen Gross- und Kleinschreibung wird NICHT unterschieden.
Dim i As Long
Dim c As String
  
  CharPosLastGetCI = 0
  If s = "" Then Exit Function
  c = UCase(Chr(CharCode))
  i = Len(s)
  While i > 0
    If UCase(Mid(s, i, 1)) = c Then
      CharPosLastGetCI = i
      Exit Function
    End If
    i = i - 1
  Wend

End Function


Function CharPosLastGetCR(ByVal CharCode As Byte, ByVal s As String) As Long
'Liefert die Position des letzten Auftretens in *s* oder 0, falls nicht
'vorhanden. Zuweischen Gross- und Kleinschreibung wird unterschieden.
Dim i As Long
Dim c As String
  
  CharPosLastGetCR = 0
  If s = "" Then Exit Function
  c = Chr(CharCode)
  i = Len(s)
  While i > 0
    If Mid(s, i, 1) = c Then
      CharPosLastGetCR = i
      Exit Function
    End If
    i = i - 1
  Wend

End Function



Function CountChars(ByVal s As String, ByVal CharCode As Integer, ByVal VonStelle As Long, ByVal BisStelle As Long) As Long
' Zaehlt die Anzahl der in *s* enthaltenen Zeichen *CharCode* ab einschliesslich *VonStelle*  bis einschliesslich *BisStelle*.
Dim i As Long, count As Long
  For i = VonStelle To BisStelle
    If Asc(Mid(s, i, 1)) = CharCode Then count = count + 1
  Next i
  CountChars = count
End Function


Function encodeURI(ByVal URI As String, ByVal Component As Boolean) As String
' Kodiert alle au|fffd|er den Zeichen, die durch *CharIsValidURIChar* abgelehnt werden
' 0-9A-Za-z
' - _ . ! ~ * ' ( ) , / ? : @ & = + $
' see also: decodeURI
'nommal anguggen:  Private Declare Function UrlEscape Lib "Shlwapi.dll" Alias "UrlEscapeA" (ByVal pszURL As String, ByVal pszEscaped As String, ByRef pcchEscaped As Long, ByVal dwFlags As Long) As Long

Dim result As String
Dim i As Long
Dim CharCode As Byte
  
  For i = 1 To Len(URI)
    CharCode = Asc(Mid(URI, i, 1))
    If CharIsValidURIChar(CharCode, Component) Then
      result = result & Chr(CharCode)
    Else
      result = result & "%" & uInt8ToHexStrZero(CharCode)
    End If
  Next i
  encodeURI = result
End Function


Function decodeURI(ByVal EncodedStr As String, ByVal Component As Boolean) As String
' decodes the string encoded by *encodeURI(Component)*
' *Component* isnt used yet
Const CDelimiterCode As Byte = 37 ' asc("%")
Dim i As Long
Dim token As String, result As String, EncodedCharStr As String

  i = 1
  While TokenNext(EncodedStr, CDelimiterCode, token, i, False)
    result = result & token
    If i > Len(EncodedStr) Then GoTo SetResultAndExit ' fertig
    If i + 2 <= Len(EncodedStr) Then
      EncodedCharStr = Mid(EncodedStr, i + 1, 2)
      If IsUInt8HexStr(EncodedCharStr) Then
        result = result & Chr(HexStrToUInt8(EncodedCharStr))
      Else ' Fehler - falsch maskierte Zeichen unver|fffd|ndert anh|fffd|ngen:
        result = result & Chr(CDelimiterCode) & EncodedCharStr
      End If
      i = i + 3
    Else ' darf net vorkommen - den Rest unver|fffd|ndert zur|fffd|ckgeben:
      decodeURI = result & Mid(EncodedStr, i, Len(EncodedStr) - i + 1)
      Exit Function
    End If
  Wend
SetResultAndExit:
  decodeURI = result
End Function


Function Hash(ByVal s As String, ByVal CaseRespect As Boolean) As Long
Dim i As Long
Dim val As Long

  val = 0
  'If Not CaseRespect Then s = LCase$(s/)
  If Not CaseRespect Then s = CharLower(s)
  For i = 1 To Len(s)
    val = val + Asc(Mid(s, i, 1)) * i
  Next i
  Hash = val
  
End Function



Function HexDigitToUInt4(ByVal Hexdigit As Byte) As Byte
' Returns the binary value of the given hex char *Hexdigit* (0-9, A-F, a-f). No error handling.
Dim uHexdigit As Byte
  
  uHexdigit = Asc(UCase(Chr(Hexdigit))) ' make sure to have upper case
  
  If uHexdigit >= Asc("A") Then
    HexDigitToUInt4 = uHexdigit - Asc("A") + 10
  Else
    HexDigitToUInt4 = uHexdigit - Asc("0")
  End If
End Function


Function HexStrToUInt8(ByVal HexStr As String) As Byte
' Returns the binary value of the given 2-char-hex string *HexStr* (00-FF or 0-F). No error handling.
Dim UInt8 As Byte
Dim i As Integer
  
  i = Len(HexStr)
  If i = 0 Then
    UInt8 = 0
  Else
    UInt8 = HexDigitToUInt4(Asc(Mid(HexStr, 1, 1)))
    If i = 2 Then
      UInt8 = UInt8 * 16 + HexDigitToUInt4(Asc(Mid(HexStr, 2, 1)))
    End If
  End If
      
  HexStrToUInt8 = UInt8
End Function



Function Int16ToStr(ByVal Int16 As Integer) As String
' gibt *Int16* als bin|fffd|rcodierten 2-Zeichen-String zur|fffd|ck
  Int16ToStr = Chr(Int16 \ 256) & Chr(Int16 And 255)
End Function


Function Int32ToStr(ByVal Int32 As Long) As String
' gibt *Int32* als bin|fffd|rcodierten 4-Zeichen-String zur|fffd|ck
  Int32ToStr = Chr(Int32 \ &H1000000) _
    & Chr((Int32 \ &H10000) And &HFF) _
    & Chr((Int32 \ &H100) And &HFF) _
    & Chr((Int32) And &HFF)
End Function



Function IsCurrencyStr(ByVal s As String, ByVal MustBePositive As Boolean) As Boolean
Dim Cur As Currency
Dim Ok As Boolean

  Cur = CCur(s)
  Ok = CStr(s) = s
  If Ok Then
    If MustBePositive Then Ok = Ok And Cur > 0
    IsCurrencyStr = Ok
  Else
    IsCurrencyStr = False
  End If

End Function



Function IsLineBreak(ByVal s As String, ByRef Index As Long, ByVal DoIncementIndex As Boolean) As Boolean
' Pr|fffd|ft, ob s[index] ein Zeilenumbruch ist und gibt das Ergebnis zur|fffd|ck.
' Falls *DoIncementIndex*, wird *Index* um 1 bzw. 2 erh|fffd|ht.

  IsLineBreak = True
  If Index > Len(s) Then Exit Function
  If Mid(s, Index, 1) = vbCr Then
    If DoIncementIndex Then
      Index = Index + 1
      If Index + 1 <= Len(s) Then If Mid(s, Index, 1) = vbLf Then Index = Index + 1
    End If
  Else
    If Mid(s, Index, 1) <> vbLf Then
      IsLineBreak = False
    Else
      If DoIncementIndex Then Index = Index + 1
    End If
  End If
    
End Function

Function IsUInt32DecStr(ByVal s As String) As Boolean
Dim i As Long

  IsUInt32DecStr = False
  If s <> "" Then
    For i = 1 To Len(s)
      If Not CharIsDecDigit(Asc(Mid(s, i, 1))) Then Exit Function
    Next i
    IsUInt32DecStr = True
  End If
End Function


Function IsUInt8HexStr(ByVal s As String) As Boolean
Dim i As Byte

  IsUInt8HexStr = False
  If Len(s) > 2 Then Exit Function
  If Len(s) = 0 Then Exit Function

  For i = 1 To Len(s)
    If Not CharIsHexDigit(Asc(Mid(s, i, 1))) Then Exit Function
  Next i
  IsUInt8HexStr = True
  
End Function


Function LastDelimiter(ByVal Delimiters As String, s As String) As Integer
Dim i As Long

  i = Len(s)
  While i > 0
    If CharPosFirstGetCR(Asc(Mid(s, i, 1)), Delimiters) Then
      LastDelimiter = i
      Exit Function
    End If
    i = i - 1
  Wend
  
End Function



Function NewLines(ByVal count As Byte) As String
' Ich liebe VBA...
Dim s As String

  While count > 0
    s = s & vbNewLine
    count = count - 1
  Wend
  NewLines = s
End Function



Function PascalStr8(ByVal Src As String) As String
  PascalStr8 = Chr(Len(Src)) & Src
End Function



Function PascalStr8Extract(ByVal Src As String, ByRef Index As Long, ByRef Dest As String) As Boolean
' Liest ab der Stelle *Index* einen Pascal-8-Codierten String aus *Src* und schreibt ihn nach *Dest*.
' Falls das Lesen geklappt hat, zeigt *Index* auf das n|fffd|chste Zeichens in *Src* und True wird zur|fffd|ckgegeben.
' Bei Auftreten von Fehlern wird False zur|fffd|ckgegeben.
Dim StrLen As Integer
  PascalStr8Extract = False
  If Index > Len(Src) Then Exit Function
  StrLen = Asc(Mid(Src, Index, 1))
  If Index + StrLen > Len(Src) Then Exit Function
  Dest = Mid(Src, Index + 1, StrLen)
  Index = Index + 1 + StrLen
  PascalStr8Extract = True
End Function



Function QuoteStrDouble(ByVal s As String) As String
  QuoteStrDouble = Chr(34) & s & Chr(34)
End Function

Function QuoteStrSingle(ByVal s As String) As String
  QuoteStrSingle = "'" & s & "'"
End Function


Function ReplaceStrs(ByRef s As String, ByVal OutString As String, ByVal InString As String, ByVal Index As Long, ByVal MaxCount As Long, ByVal CompareOption As Integer) As Integer
' Ersetzt ab einschlie|fffd|lich *Index* *MaxCount* Vorkommen von *OutString* durch *InString*.
' Falls *MaxCount* kleinergleich null ist, werden alle Vorkommen ersetzt.
' Zur|fffd|ckgegeben wird die Anzahl der Ersetzungen.
Dim v As Variant
Dim count As Integer
 
  v = Index
  Do
    v = InStr(v, s, OutString, CompareOption)
    If IsNull(v) Then Exit Function
    If v = 0 Then Exit Function
    s = Left(s, v - 1) & InString & Right(s, Len(s) - v - Len(OutString) + 1)
    v = v + Len(InString)
  Loop While (Not IsNull(v)) And (v <= Len(s))

End Function


Function SkipChars(ByVal s As String, ByVal CharsToSkip As String, ByRef Index As Long) As Boolean
' Testet die Zeichen ab einschlie|fffd|lich *index* auf eines der Zeichen in *CharsToSkip* und stellt *index* auf das erste
' darin nicht enthaltene Zeichen.
' Die Funktion gibt TRUE zurueck, wenn noch Zeichen in *s* uebrig sind; FALSE sonst.
  
  While Index <= Len(s)
    If CharPosFirstGetCR(Asc(Mid(s, Index, 1)), CharsToSkip) = 0 Then
      SkipChars = True
      Exit Function
    End If
    Index = Index + 1
  Wend
  SkipChars = False

End Function

Function SkipCharsWhite(ByVal s As String, ByRef Index As Long) As Boolean
' Testet die Zeichen ab einschlie|fffd|lich *index* auf *CharIsWhite* und stellt *index* auf das erste nichtwei|fffd|e Zeichen.
' Die Funktion gibt TRUE zurueck, wenn noch Zeichen in *s* uebrig sind; FALSE sonst.
  
  While Index <= Len(s)
    If Not CharIsWhite(Asc(Mid(s, Index, 1))) Then
      SkipCharsWhite = True
      Exit Function
    End If
    Index = Index + 1
  Wend
  SkipCharsWhite = False
 
End Function


Function SplitIntoNameAndValue(ByVal s As String, ByRef AName As String, ByRef AValue As String) As Boolean
' Splits the string *s* "Name=Value" into trimmed *AName* and *AValue* and returns FALSE; returns FALSE if no "=" is found in *s*
Dim i As Long
  i = InStr(1, s, "=", vbBinaryCompare)
  If i = 0 Then
    SplitIntoNameAndValue = False
    Exit Function
  End If
  AName = Trim(Left(s, i - 1))
  AValue = Trim(Right(s, Len(s) - i))
  SplitIntoNameAndValue = True
End Function



Public Function StrIsComment(ByVal line As String, ByVal CommentChars As String) As Boolean
Dim i As Long
Dim j As Byte
Dim FirstChar As String

  i = 1
  If SkipCharsWhite(line, i) Then
    FirstChar = Mid(line, i, 1)
    For j = 1 To Len(CommentChars)
      If FirstChar = Mid(CommentChars, j, 1) Then
        StrIsComment = True
        Exit Function
      End If
    Next j
  End If
  StrIsComment = False
   
End Function



Function StrToInt16(ByVal s As String) As Integer
' Interpretiert die ersten zwei Bytes aus *s* als bin|fffd|r codierten Integer-Wert.
' Wenn *s* weniger als zwei Zeichen enth|fffd|lt, tritt ein Laufzeitfehler auf.

  StrToInt16 = Asc(s) * 256 + Asc(Mid(s, 2, 1))
End Function



Function StrToInt32(ByVal s As String) As Long
' Interpretiert die ersten vier Bytes aus *s* als bin|fffd|r codierten long-Wert.
' Wenn *s* weniger als vier Zeichen enth|fffd|lt, tritt ein Laufzeitfehler auf.
  StrToInt32 = CLng(Asc(s)) * &H1000000 _
    + CLng(Asc(Mid(s, 2, 1))) * &H10000 _
    + CLng(Asc(Mid(s, 3, 1))) * &H100 _
    + CLng(Asc(Mid(s, 4, 1)))
End Function


Function StrToLong(ByVal s As String) As Long
' Verwandelt das, was sich am Anfang von *s* befindet, in eine positive Ganzzahl
' *s* darf kein Dezimaltrennzeichen enthalten!
Dim i As Byte
Dim TmpS As String, c As String
  
  i = 1
  s = Trim(s)
  While i <= Len(s)
    c = Mid(s, i, 1)
    If CharIsDecDigit(Asc(c)) Then
      TmpS = TmpS & c
    Else
      GoTo AfterLoop
    End If
    i = i + 1
  Wend
AfterLoop:
  If TmpS <> "" Then StrToLong = CLng(TmpS)
  
End Function



Function TokenNext(ByVal s As String, ByVal DelimiterCharCode As Byte, token As String, ByRef Index As Long, ByVal LinebreakIsDelimiter As Boolean) As Boolean
' Duchsucht *s* ab einschlie|fffd|lich *index* nach *Delimiter*. Sofern ein Trenner gefunden wurde oder sich noch Zeichen nach
' *index* befinden, gibt die Funktion TRUE zur|fffd|ck.
' *Token* enth|fffd|lt die Zeichenkette ab *index* bis zum n|fffd|chsten Trenner (exklusive) bzw. zum Ende der ZK.
' *index* wird auf die Position des n|fffd|chsten aufgefundenen Delimiters gesetzt; muss also vom Aufrufer inkrementiert werden.
Dim i As Long
  
  If Index <= Len(s) Then
    If Index = 0 Then Index = 1
    i = Index
    
    Do
      If Asc(Mid(s, i, 1)) = DelimiterCharCode Then
        GoTo Exit_Found_TokenNext
      Else
        If LinebreakIsDelimiter Then If IsLineBreak(s, i, True) Then GoTo Exit_Found_TokenNext
      End If
      i = i + 1
    Loop Until i > Len(s)
    
    If i <> Index Then
      GoTo Exit_Found_TokenNext
    Else
      GoTo Exit_NotFound_TokenNext
    End If
  Else
    GoTo Exit_NotFound_TokenNext
  End If
  
  
Exit_NotFound_TokenNext:
  TokenNext = False
  GoTo Exit_TokenNext
  
Exit_Found_TokenNext:
  TokenNext = True
  token = Mid(s, Index, i - Index)
  Index = i
  GoTo Exit_TokenNext
  
Exit_TokenNext:
  
End Function


Function uInt4ToHexStr(b As Byte) As String
' Verwandelt die Zahl in 0<=*b*<=$F in die Hexadezimalziffer. Eine Pruefung
' findet nicht statt.
  If b < 10 Then
    uInt4ToHexStr = Chr(48 + b) ' asc("0")=48
  Else
    uInt4ToHexStr = Chr(55 + b) ' 55= asc("A")=65-10
  End If
End Function





Function uInt8ToHexStr(ByVal b As Byte) As String
' Verwandelt *b* in eine ein- oder zweistellige Hexzahl.
' Siehe auch: uInt8ToHexStrZero

  If b < 16 Then
    uInt8ToHexStr = uInt4ToHexStr(b)
  Else
    uInt8ToHexStr = uInt4ToHexStr(b \ 16) & uInt4ToHexStr(b Mod 16)
  End If
  
End Function


Function uInt8ToHexStrZero(ByVal b As Byte) As String
'Verwandelt *b* in eine zweistellige Hexzahl, wobei ggf. mit Nullen
'aufgefuellt wird.
'Siehe auch: uInt8ToHexStr
Dim result As String
  result = uInt8ToHexStr(b)
  If Len(result) = 1 Then uInt8ToHexStrZero = "0" & result Else uInt8ToHexStrZero = result
End Function

Attribute VB_Name = "MSD_TNumList"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

' Class definition for a List of integer numbers (long)
' last change: 2009/04/02
' Modul dependencies: -

' DON'T MAKE ANY CHANGES!
' All your changes will be lost with the next update of this library.
' Contact the author <ms@msdatec.de> for bug fixes or enhancements instead.

' BITTE KEINE |fffd|NDERUNGEN DURCHF|fffd|HREN!
' Alle |fffd|nderungen, die Sie hier vornehmen, gehen mit dem n|fffd|chsten Update dieses Modules verloren.
' Kontaktieren Sie anstattdessen den Autor unter <ms@msdatec.de> f|fffd|r Fehlerkorrekturen oder Verbesserungen.

' All rights of this code are reserved by MSDatec.
' See http://www.msdatec.de/ for further information.
' You are allowed to use and modify this code for personal use.
' You are NOT allowed to publish or distribute this code or parts of it
' without a written permission of MSDatec.

' Alle Rechte dieses Codes liegen bei MSDatec.
' Unter http://www.msdatec.de/ finden Sie weitere Informationen sowie Kontaktm|fffd|glichkeiten.
' Sie d|fffd|rfen f|fffd|r Ihre eigenen Bed|fffd|rfnisse diesen Code benutzen und ver|fffd|ndern.
' Sie d|fffd|rfen NICHT diesen Code oder Teile desselben ohne eine schriftliche Genehmigung
' von MSDatec publizieren oder Dritten zug|fffd|nglich machen.

' History:



Private fCount As Long
Private fSorted As Boolean
Private fDuplicates As Byte
Private fItems() As Long



Private Const CDupIgnore As Byte = 0
Private Const CDupAccept As Byte = 1
Private Const CDupError  As Byte = 2
#Const CDebug = True


Public Function Add(ByVal AVal As Long) As Long
Dim Index As Long
  
  Add = -1
  If FindWithIndex(AVal, Index) Then
    If DupError Then
      MsgBox "In der Liste sind Duplikate nicht erlaubt", vbCritical
      Exit Function
    Else
      If DupIgnore Then Exit Function
    End If
  End If
  InsertItem AVal, Index
  Add = Index
End Function



#If CDebug Then
  Private Function CheckIndex(ByVal Index As Long) As Boolean
    If Index >= count Then
      MsgBox "Der Index " & CStr(Index) & " ist au|fffd|erhalb des g|fffd|ltigen Bereichs", vbCritical, "TStringlist"
      CheckIndex = False
    Else
      CheckIndex = True
    End If
  End Function
#End If


Public Sub Clear()
  fCount = 0
  ReDim fItems(0)
End Sub


Public Function count() As Long
  count = fCount
End Function



Public Sub Delete(ByVal Index As Long)
Dim i As Long

  #If CDebug Then
    If Not CheckIndex(Index) Then Exit Sub
  #End If

  For i = Index To count - 1
    SetItem Items(i + 1), i
  Next
  fCount = fCount - 1
  ReDim Preserve fItems(count)
End Sub



Public Property Get DupAccept() As Boolean
  DupAccept = fDuplicates = CDupAccept
End Property


Public Property Let DupAccept(ByVal NewVal As Boolean)
  If NewVal Then fDuplicates = CDupAccept Else fDuplicates = CDupIgnore
End Property


Public Property Get DupIgnore() As Boolean
  DupIgnore = fDuplicates = CDupIgnore
End Property

Public Property Let DupIgnore(ByVal NewVal As Boolean)
  fDuplicates = CDupIgnore
End Property


Public Property Get DupError() As Boolean
  DupError = fDuplicates = CDupError
End Property


Public Property Let DupError(ByVal NewVal As Boolean)
  If NewVal Then fDuplicates = CDupError Else fDuplicates = CDupIgnore
End Property


Private Sub Exchange(ByVal i As Long, ByVal j As Long)
Dim AVal As Long
  
  #If CDebug Then
    If Not CheckIndex(i) Then Exit Sub
    If Not CheckIndex(j) Then Exit Sub
  #End If
  
  
  AVal = Items(i)
  SetItem Items(j), i
  SetItem AVal, j
End Sub


Public Function Find(ByVal SearchVal As Long) As Boolean
Dim dummy As Long
  
  Find = FindWithIndex(SearchVal, dummy)
End Function


Public Function FindWithIndex(ByVal SearchVal As Long, ByRef Index As Long) As Boolean
Dim i As Long
Dim H As Long


  If Sorted Then
    Index = 0
    H = count - 1
    
    Do While Index <= H
      i = (Index + H) \ 2
      If SearchVal = Items(i) Then
        FindWithIndex = True
        Index = i
        Exit Function
      Else
        If SearchVal > Items(i) Then
          Index = i + 1
        Else
          H = i - 1
        End If
      End If
    Loop
  Else
    For Index = 0 To count - 1
      If SearchVal = Items(i) Then
        FindWithIndex = True
        Exit Function
      End If
    Next Index
    Index = count
    FindWithIndex = False
  End If
End Function



Public Sub Insert(ByVal AVal As Long, Index As Long)
  If Sorted Then
    MsgBox "Bei sortierten Listen ist das Einf|fffd|gen nicht erlaubt", vbCritical
  Else
    InsertItem AVal, Index
  End If
End Sub


Private Sub InsertItem(ByVal AVal As Long, Index As Long)
Dim i As Long
  
  ' ein Element anf|fffd|gen:
  fCount = fCount + 1
  ReDim Preserve fItems(count)
  For i = count - 1 To Index + 1 Step -1
    SetItem Items(i - 1), i
  Next
  SetItem AVal, Index
  
End Sub


Public Property Get Items(ByVal Index As Long) As Long
  #If CDebug Then
    If Not CheckIndex(Index) Then Exit Property
  #End If
  
  Items = fItems(Index)
End Property



Private Sub SetItem(ByVal AVal As Long, ByVal Index As Long)
  #If CDebug Then
    If Not CheckIndex(Index) Then Exit Sub
  #End If
  fItems(Index) = AVal
End Sub



Private Sub Sort()
  If count < 2 Then Exit Sub
  MsgBox "TNumlist.Sort: noch nicht fertig...", vbCritical
End Sub



Public Property Get Sorted() As Boolean
  Sorted = fSorted
End Property


Public Property Let Sorted(NewSorted As Boolean)
  If Sorted = NewSorted Then Exit Property
  If NewSorted = True Then Sort
  fSorted = NewSorted
End Property



Private Sub Class_Terminate()
  Clear
End Sub
Attribute VB_Name = "MSD_Windows"
Option Explicit
Option Private Module

' Library for global VBA routines - Windows specific
' last change: 2009/11/30
' Modul dependencies: MSD_All

' DON'T MAKE ANY CHANGES!
' All your changes will be lost with the next update of this library.
' Contact the author <ms@msdatec.de> for bug fixes or enhancements instead.

' BITTE KEINE |fffd|NDERUNGEN DURCHF|fffd|HREN!
' Alle |fffd|nderungen, die Sie hier vornehmen, gehen mit dem n|fffd|chsten Update dieses Modules verloren.
' Kontaktieren Sie anstattdessen den Autor unter <ms@msdatec.de> f|fffd|r Fehlerkorrekturen oder Verbesserungen.

' All rights of this code are reserved by MSDatec.
' See http://www.msdatec.de/ for further information.
' You are allowed to use and modify this code for personal use.
' You are NOT allowed to publish or distribute this code or parts of it
' without a written permission of MSDatec.

' Alle Rechte dieses Codes liegen bei MSDatec.
' Unter http://www.msdatec.de/ finden Sie weitere Informationen sowie Kontaktm|fffd|glichkeiten.
' Sie d|fffd|rfen f|fffd|r Ihre eigenen Bed|fffd|rfnisse diesen Code benutzen und ver|fffd|ndern.
' Sie d|fffd|rfen NICHT diesen Code oder Teile desselben ohne eine schriftliche Genehmigung
' von MSDatec publizieren oder Dritten zug|fffd|nglich machen.

' History:
' 2009/11/30
' - added function *FindWindow*
' 2009/11/06
' - added *ShellExecute*, *FindExecutable*, *ShellOpenHTMLFile*
' 2009/06/16
' - function "GetLastError" introduced
' 2009/05/24
' - added some changes made in other project (2008/02/12, 2007/08/29)
' 2009/05/15
' - added font specific functions, types and constants
' 2008/02/12
' - Param size of *hWnd* and *ByVal* in *SendMessageStr* changed from Integer to Long
' 2008/06/03
' - Function "DeleteUrlCacheEntry" introduced
' 2007/08/29
' - Function *DiskFreeSpace* with "CDbl" corrected for bigger harddisks
' 2006/11/11
' - Function "URLDownloadToFile", "GetTempDir", "GetTempFileName" introduced
' 2005/07/01
' - Function *DiskFreeSpace* introduced
' 2005/01/12
' - Functions *HostName*, *gethostname*, *WSAStartup*, *WSACleanup* and type *WSADATA* defined
' 2004/02/28
' - CTwips_per_inch introduced




Global Const SORT_DEFAULT = &H0         ' sorting default
Global Const SUBLANG_DEFAULT = &H1      ' user default
Global Const LANG_NEUTRAL = &H0

Global Const LANG_USER_DEFAULT = (SUBLANG_DEFAULT * 1024) Or LANG_NEUTRAL
Global Const LOCALE_USER_DEFAULT = (SORT_DEFAULT * 65536) Or LANG_USER_DEFAULT

Global Const CMax_Path As Long = 260

Global Const CTwips_per_cm   As Integer = 567 ' Anzahl der Twips pro cm
Global Const CTwips_per_inch As Integer = 1440 ' Anzahl der Twips pro Zoll


' String Flags.
Global Const NORM_IGNORECASE = 1    ' ignore case
Global Const NORM_IGNORENONSPACE = 2   ' ignore nonspacing chars
Global Const NORM_IGNORESYMBOLS = 4   ' ignore symbols
Global Const NORM_IGNOREKANATYPE = &H10000
Global Const NORM_IGNOREWIDTH = &H20000

Global Const CB_GETDROPPEDSTATE = 343



Global Const WM_USER = &H400




'Declare function CharPrev Lib "user32"  alias "CharPrevA" (lpszStart: PAnsiChar; lpszCurrent: PAnsiChar)
'Declare function CharPrevA(lpszStart: PAnsiChar; lpszCurrent: PAnsiChar): PAnsiChar; stdcall;
'Declare Function CharUpper Lib "user32" Alias "CharUpperA" (lpsz As String) As String
Declare Function CharLower Lib "user32" Alias "CharLowerA" (ByVal lpsz As String) As String
Declare Function CompareString Lib "kernel32" Alias "CompareStringA" (ByVal Locale As Long, ByVal dwCmpFlags As Long, ByVal lpString1 As String, ByVal cchCount1 As Long, ByVal lpString2 As String, ByVal cchCount2 As Long) As Long
Declare Function CopyFile Lib "kernel32" Alias "CopyFileA" (ByVal lpExistingFileName As String, ByVal lpNewFileName As String, ByVal bFailIfExists As Boolean) As Integer
Declare Function DeleteUrlCacheEntry Lib "wininet.dll" Alias "DeleteUrlCacheEntryA" (ByVal lpszUrlName As String) As Long
Declare Function EnumFontFamilies Lib "gdi32" Alias "EnumFontFamiliesA" (ByVal hDC As Long, ByVal lpszFamily As String, ByVal lpEnumFontFamProc As Long, lParam As Any) As Long
Declare Function FileMove Lib "kernel32" Alias "MoveFileA" (ByVal lpExistingFileName As String, ByVal lpNewFileName As String) As Integer
Declare Function FindExecutable Lib "shell32.dll" Alias "FindExecutableA" (ByVal lpFile As String, ByVal lpDirectory As String, ByVal lpResult As String) As Long
Declare Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
Declare Function GetActiveWindow Lib "user32" () As Long
Declare Function GetDC Lib "user32" (ByVal hWnd As Long) As Long
Declare Function GetDiskFreeSpace Lib "kernel32" Alias "GetDiskFreeSpaceA" (ByVal lpRootPathName As String, ByRef lpSectorsPerCluster As Long, ByRef lpBytesPerSector As Long, ByRef lpNumberOfFreeClusters As Long, ByRef lpTotalNumberOfClusters As Long) As Integer
Declare Function GetDiskFreeSpaceEx Lib "kernel32" Alias "GetDiskFreeSpaceExA" (ByVal lpDirectoryName As String, ByRef lpFreeBytesAvailableToCaller As Integer, ByRef lpTotalNumberOfBytes As Integer, ByRef lpTotalNumberOfFreeBytes As Integer) As Integer
Declare Function GetDlgCtrlID Lib "user32.dll" (ByVal hwndCtl As Long) As Long
Declare Function GetDlgItem Lib "user32.dll" (ByVal hDlgBox As Long, ByVal nIDDlgItem As Long) As Long
Declare Function GetHostName Lib "WSOCK32.DLL" (ByVal szHostname As String, ByVal HostLen As Long) As Long
Declare Function GetLastError Lib "kernel32.dll" () As Long
Declare Function GetTempFileName Lib "kernel32" Alias "GetTempFileNameA" (ByVal lpszPath As String, ByVal lpPrefixString As String, ByVal wUnique As Long, ByVal lpTempFileName As String) As Long
Declare Function GetTempPath Lib "kernel32" Alias "GetTempPathA" (ByVal strBufferLength As Long, ByVal lpBuffer As String) As Long
Declare Function GetTickCount Lib "kernel32" () As Long
Declare Function IsCharAlphaNumeric Lib "user32" Alias "IsCharAlphaNumericA" (ByVal char As Byte) As Boolean
Declare Function OemToCharBuff Lib "user32" Alias "OemToCharBuffA" (ByVal lpszSrc As String, ByVal lpszDst As String, ByVal cchDstLength As Long) As Long
Declare Function ReleaseDC Lib "user32" (ByVal hWnd As Long, ByVal hDC As Long) As Long
Declare Function SendMessage Lib "user32" Alias "SendMessageA" (ByVal hWnd As Integer, ByVal msg As Integer, ByVal wParam As Long, ByVal lParam As Long) As Long       ' LRESULT SendMessage(HWND  hwnd, UINT  uMsg, WPARAM wParam,  LPARAM lParam);
Declare Function SendMessageStr Lib "user32" Alias "SendMessageA" (ByVal hWnd As Long, ByVal msg As Long, ByVal wParam As Long, ByVal s As String) As Long
Declare Function ShellExecute Lib "shell32.dll" Alias "ShellExecuteA" (ByVal hWnd As Long, ByVal lpOperation As String, ByVal lpFile As String, ByVal lpParameters As String, ByVal lpDirectory As String, ByVal nshowcmd As Long) As Long
Declare Function URLDownloadToFile Lib "urlmon" Alias "URLDownloadToFileA" (ByVal pCaller As Long, ByVal szURL As String, ByVal szFileName As String, ByVal dwReserved As Long, ByVal lpfnCB As Long) As Long
Declare Function WSACleanup Lib "WSOCK32.DLL" () As Long
Declare Function WSAStartup Lib "WSOCK32.DLL" (ByVal wVersionRequired As Integer, lpWSAData As WSADATA) As Long
Declare Sub Sleep Lib "kernel32" (ByVal millisec As Long)





Public Const SW_HIDE = 0                  ' Versteckt |fffd|ffnen
Public Const SW_MAXIMIZE = 3              ' Maximiert |fffd|ffnen
Public Const SW_MINIMIZE = 6              ' Minimiert |fffd|ffnen
Public Const SW_NORMAL = 1
Public Const SW_SHOWNORMAL = SW_NORMAL
Public Const SW_RESTORE = 9
Public Const SW_SHOWMAXIMIZED = 3
Public Const SW_SHOWMINIMIZED = 2
Public Const SW_SHOWMINNOACTIVE = 7
Public Const SW_SHOWNOACTIVATE = 4



Global Const LB_ADDSTRING = &H180
Global Const LB_INSERTSTRING = &H181
Global Const LB_DELETESTRING = &H182
Global Const LB_SELITEMRANGEEX = &H183
Global Const LB_RESETCONTENT = &H184
Global Const LB_SETSEL = &H185
Global Const LB_SETCURSEL = &H186
Global Const LB_GETSEL = &H187
Global Const LB_GETCURSEL = &H188
Global Const LB_GETTEXT = &H189
Global Const LB_GETTEXTLEN = &H18A
Global Const LB_GETCOUNT = &H18B
Global Const LB_SELECTSTRING = &H18C
Global Const LB_DIR = &H18D
Global Const LB_GETTOPINDEX = &H18E
Global Const LB_FINDSTRING = &H18F
Global Const LB_GETSELCOUNT = &H190
Global Const LB_GETSELITEMS = &H191
Global Const LB_SETTABSTOPS = &H192
Global Const LB_GETHORIZONTALEXTENT = &H193
Global Const LB_SETHORIZONTALEXTENT = &H194
Global Const LB_SETCOLUMNWIDTH = &H195
Global Const LB_ADDFILE = &H196
Global Const LB_SETTOPINDEX = &H197
Global Const LB_GETITEMRECT = &H198
Global Const LB_GETITEMDATA = &H199
Global Const LB_SETITEMDATA = &H19A
Global Const LB_SELITEMRANGE = &H19B
Global Const LB_SETANCHORINDEX = &H19C
Global Const LB_GETANCHORINDEX = &H19D
Global Const LB_SETCARETINDEX = &H19E
Global Const LB_GETCARETINDEX = &H19F
Global Const LB_SETITEMHEIGHT = &H1A0
Global Const LB_GETITEMHEIGHT = &H1A1
Global Const LB_FINDSTRINGEXACT = &H1A2
Global Const LB_SETLOCALE = &H1A5
Global Const LB_GETLOCALE = &H1A6
Global Const LB_SETCOUNT = &H1A7
Global Const LB_INITSTORAGE = &H1A8
Global Const LB_ITEMFROMPOINT = &H1A9
Global Const LB_MSGMAX = 432




Public Type WSADATA
  wversion As Integer
  wHighVersion As Integer
  szDescription(0 To 256) As Byte
  szSystemStatus(0 To 128) As Byte
  iMaxSockets As Integer
  iMaxUdpDg As Integer
  lpszVendorInfo As Long
End Type


' Font related constants and types:
Public Const LF_FACESIZE = 32
Public Const LF_FULLFACESIZE = 64

Type LOGFONT
        lfHeight As Long
        lfWidth As Long
        lfEscapement As Long
        lfOrientation As Long
        lfWeight As Long
        lfItalic As Byte
        lfUnderline As Byte
        lfStrikeOut As Byte
        lfCharSet As Byte
        lfOutPrecision As Byte
        lfClipPrecision As Byte
        lfQuality As Byte
        lfPitchAndFamily As Byte
        lfFaceName(LF_FACESIZE) As Byte
End Type

Type NEWTEXTMETRIC
        tmHeight As Long
        tmAscent As Long
        tmDescent As Long
        tmInternalLeading As Long
        tmExternalLeading As Long
        tmAveCharWidth As Long
        tmMaxCharWidth As Long
        tmWeight As Long
        tmOverhang As Long
        tmDigitizedAspectX As Long
        tmDigitizedAspectY As Long
        tmFirstChar As Byte
        tmLastChar As Byte
        tmDefaultChar As Byte
        tmBreakChar As Byte
        tmItalic As Byte
        tmUnderlined As Byte
        tmStruckOut As Byte
        tmPitchAndFamily As Byte
        tmCharSet As Byte
        ntmFlags As Long
        ntmSizeEM As Long
        ntmCellHeight As Long
        ntmAveWidth As Long
End Type

' ntmFlags field flags
Public Const NTM_REGULAR = &H40&
Public Const NTM_BOLD = &H20&
Public Const NTM_ITALIC = &H1&

'  tmPitchAndFamily flags
Public Const TMPF_FIXED_PITCH = &H1
Public Const TMPF_VECTOR = &H2
Public Const TMPF_DEVICE = &H8
Public Const TMPF_TRUETYPE = &H4

Public Const ELF_VERSION = 0
Public Const ELF_CULTURE_LATIN = 0

'  EnumFonts Masks
Public Const RASTER_FONTTYPE = &H1
Public Const DEVICE_FONTTYPE = &H2
Public Const TRUETYPE_FONTTYPE = &H4

' /Font related constants and types:


Private fHostName As String
Private fHostNameSet As Boolean


Public Function AnsiCompareStr(ByVal s1 As String, ByVal s2 As String) As Integer
  AnsiCompareStr = CompareString(LOCALE_USER_DEFAULT, 0, s1, Len(s1), s2, Len(s2)) - 2
End Function

Public Function AnsiCompareText(ByVal s1 As String, ByVal s2 As String) As Integer
  AnsiCompareText = CompareString(LOCALE_USER_DEFAULT, NORM_IGNORECASE, s1, Len(s1), s2, Len(s2)) - 2
End Function



Public Function DiskFreeSpace(APath As String) As Double
Dim lpSectorsPerCluster As Long
Dim lpBytesPerSector As Long
Dim lpNumberOfFreeClusters As Long
Dim lpTotalNumberOfClusters As Long
  
  If WinBool2VBBool(GetDiskFreeSpace(Left(APath, 3), lpSectorsPerCluster, lpBytesPerSector, lpNumberOfFreeClusters, lpTotalNumberOfClusters)) Then
    DiskFreeSpace = lpSectorsPerCluster * lpBytesPerSector * CDbl(lpNumberOfFreeClusters)
  Else
    DiskFreeSpace = -1
  End If
End Function



Public Function GetTempDir() As String
' returns the first given temp directory entry with a trailing backslash
Const CBufferSize = 256
Dim Buffer As String
Dim RetVal As Long

  Buffer = Space(CBufferSize)
  RetVal = GetTempPath(CBufferSize, Buffer) ' *RetVal* = Anzahl der kopierten Zeichen
  If (RetVal > CBufferSize) Or (RetVal = 0) Then
    GetTempDir = "C:\"
    Exit Function
  End If
  Buffer = Left(Buffer, RetVal)
  RetVal = InStr(Buffer, ";")
  If RetVal > 0 Then Buffer = Left(Buffer, RetVal - 1)
  GetTempDir = Buffer
End Function



Public Function HostName(ByRef StrHostName As String) As Long
' Setzt *StrHostName* auf den Hostnamen und gibt 0 zur|fffd|ck.
' Beim Auftreten eines Fehlers bleibt *StrHostName* unver|fffd|ndert
' und der Fehlercode wird zur|fffd|ckgegeben.
' *fHostName* wird als Cache benutzt.
Const WS_VERSION_REQD = &H101
Const fHostNameLen As Byte = 255
Dim lngRet As Long
Dim udtWSAD As WSADATA
Dim s As String * fHostNameLen

  If fHostNameSet Then
    HostName = 0
    StrHostName = fHostName
    Exit Function
  End If
  fHostName = ""
  lngRet = WSAStartup(WS_VERSION_REQD, udtWSAD)
  If lngRet <> 0 Then
    HostName = lngRet
    Exit Function
  End If
  
  
  lngRet = GetHostName(s, fHostNameLen)
  If lngRet = 0 Then
    HostName = 0
    lngRet = InStr(1, s, Chr(0))
    If lngRet > 0 Then fHostName = Left(s, lngRet - 1)
    fHostNameSet = True
    StrHostName = fHostName
  Else
    HostName = lngRet
  End If
  
    
  
  WSACleanup
  
End Function





Function ShellOpenHTMLFile(ByVal HTMLFileName As String, ByVal NamedAnchor As String, ByRef ErrCode As Long) As Boolean
Dim Progname As String, Docname As String
  
  Progname = Space(2 * CMax_Path)
  ErrCode = FindExecutable(HTMLFileName, "", Progname)
  If ErrCode <= 32 Then
    ShellOpenHTMLFileError HTMLFileName
  Else
    If NamedAnchor <> "" Then If Left(NamedAnchor, 1) <> "#" Then NamedAnchor = "#" + NamedAnchor
    Docname = "file://" & HTMLFileName & NamedAnchor
    ReplaceStrs Docname, "\", "/", 1, 0, vbBinaryCompare
    'ErrCode = ShellExecute(Application.hWnd, "", Progname, Docname, "", SW_SHOWNORMAL)
    ErrCode = ShellExecute(ApplicationHandle, "", Progname, Docname, "", SW_SHOWNORMAL)
    
    If ErrCode <= 32 Then ShellOpenHTMLFileError Docname
  End If
  ShellOpenHTMLFile = ErrCode > 32
End Function


Sub ShellOpenHTMLFileError(ByVal Docname As String)
  MsgBox "Fehler beim |fffd|ffnen von '" & Docname & "'.", vbCritical, CTitleMsgBox
End Sub



Attribute VB_Name = "TabCyclic"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit


Private Const CRowColumnCaptions        As Byte = 3
Private Const CRowDataFirst             As Byte = 4

Private Const CColCaption               As Byte = 1
Private Const CColChar                  As Byte = 2
Private Const CColCycleBegin            As Byte = 3
Private Const CColDuration              As Byte = 4
Private Const CColPeriod                As Byte = 5
Private Const CColCycleEnd              As Byte = 6
Private Const CColSaturdayBehaviour     As Byte = 7
Private Const CColPublicBehaviour       As Byte = 8
Private Const CColSaturdayIsWorkday     As Byte = 9
Private Const CColDoshow                As Byte = 10

Private Const CColFirst                 As Byte = CColCaption
Private Const CColLast                  As Byte = CColDoshow


Private Const CIniPrefixSectionItems    As String = "TabCyclicItem"

Private Const CIniKey_Items             As String = "Items"


Private Const CIniKey_ItemsCaption           As String = "Caption"
Private Const CIniKey_ItemsCharlist          As String = "Charlist"
Private Const CIniKey_ItemsCycleBegin        As String = "Cyclebegin"
Private Const CIniKey_ItemsDuration          As String = "Duration"
Private Const CIniKey_ItemsPeriod            As String = "Period"
Private Const CIniKey_ItemsCycleEnd          As String = "CycleEnd"
Private Const CIniKey_ItemsSaturdayBehaviour As String = "SaturdayBehaviour"
Private Const CIniKey_ItemsPublicBehaviour   As String = "PublicBehaviour"
Private Const CIniKey_ItemsSaturdayIsWorkday As String = "SaturdayIsWorkday"
Private Const CIniKey_ItemsDoshow            As String = "Doshow"


Public Sub ButtonCheckItems_Click()
Dim i As Integer
Dim ErrCol As Byte
  For i = 0 To ItemsCount - 1
    ErrCol = ItemsCheck(i, True)
    If ErrCol <> 0 Then
      If ErrCol > 100 Then ErrCol = ErrCol - 100
      Cells(i + CRowDataFirst, ErrCol).Select
      Exit Sub
    End If
  Next i
  MsgBox CStr(ItemsCount) & " Eintr|fffd|ge gepr|fffd|ft: keine Fehler gefunden", vbInformation, CTitleMsgBox
End Sub
  


Private Function CharIndexModuloLen(ByVal Index As Integer, ByVal CharIndex As Integer) As Integer
' Liefert den entsprechenden Wert zwischen 1 und ItemsCharCount(Index)
' Z.B. f|fffd|r "ABC"
' CharIndex Result
'         1     1
'         2     2
'         3     3
'         4     1
  
  CharIndexModuloLen = (((CharIndex - 1)) Mod ItemsCharCount(Index)) + 1
End Function


Public Sub Clear()
Dim i  As Long
  i = Cells(Rows.count, 1).End(xlUp).Row
  If i >= CRowDataFirst Then
    Range(Cells(CRowDataFirst, CColFirst), Cells(i, CColLast)).ClearContents
  End If
  CommentsDelete Me, CRowDataFirst, CColFirst, CRowMax, CColLast
End Sub



Private Function ColumnCaptions(ByVal AColIndex As Byte) As String
  ColumnCaptions = Cells(CRowColumnCaptions, AColIndex)
End Function



Public Property Get ItemsCaption(ByVal Index As Integer) As String
  ItemsCaption = Cells(Index + CRowDataFirst, CColCaption)
End Property


Public Property Let ItemsCaption(ByVal Index As Integer, s As String)
  Cells(Index + CRowDataFirst, CColCaption) = s
End Property


Private Function ItemsCharCharacters(ByVal Index As Integer) As Characters
  ' Funktioniert nicht :-(
  Set ItemsCharCharacters = Cells(Index + CRowDataFirst).Characters
End Function


Public Property Get ItemsCharCode(ByVal Index As Integer, ByVal CharIndex As Integer) As Byte
' Gibt den *CharIndex*ten Kennbuchstaben des zyklischen Eintrags *index* zur|fffd|ck.
' *CharIndex* beginnt bei 1 und beginnt nach *ItemsCharCount(index)* wieder von vorne.
  ItemsCharCode = Asc(Mid(ItemsChars(Index), CharIndexModuloLen(Index, CharIndex), 1))
End Property


Public Function ItemsCharCount(ByVal Index As Integer) As Integer
  ItemsCharCount = Len(Cells(Index + CRowDataFirst, CColChar))
End Function


Public Property Get ItemsCharFont(ByVal Index As Integer, ByVal CharIndex As Integer) As Font
  Set ItemsCharFont = Cells(Index + CRowDataFirst, CColChar).Characters(CharIndexModuloLen(Index, CharIndex), 1).Font
End Property


Public Property Let ItemsCharFont(ByVal Index As Integer, ByVal CharIndex As Integer, AFont As Font)
  Set Cells(Index + CRowDataFirst, CColChar).Characters(CharIndexModuloLen(Index, CharIndex), 1).Font = AFont
End Property


Public Property Get ItemsChars(ByVal Index As Integer) As String
' Liefert alle Kennbuchstaben zur|fffd|ck
  ItemsChars = Cells(Index + CRowDataFirst, CColChar)
End Property


Public Property Let ItemsChars(ByVal Index As Integer, s As String)
  Cells(Index + CRowDataFirst, CColChar) = s
End Property





Private Sub ItemsCheckErrorMsgShow(ByVal Index As Integer, AColIndex As Byte)
  MsgBox ItemsCheckErrorMsg(Index, AColIndex), vbCritical, CTitleMsgBox
End Sub


Private Function ItemsCheckErrorMsg(ByVal Index As Integer, ErrCode As Byte) As String
  Select Case ErrCode
    Case CColChar
      ItemsCheckErrorMsg = "In Zeile " & CStr(Index + CRowDataFirst) & " fehlt der Zyklus-Kennbuchstabe!"
    Case CColCaption, CColCycleBegin, CColDuration, CColPeriod, CColCycleEnd, CColSaturdayBehaviour, CColPublicBehaviour, CColSaturdayIsWorkday, CColDoshow
      ItemsCheckErrorMsg = "Der zyklische Eintrag |fffd|" & ItemsCaption(Index) & "|fffd| in Zeile " & CStr(Index + CRowDataFirst) & " enth|fffd|lt eine ung|fffd|ltige Angabe in der Spalte |fffd|" & ColumnCaptions(ErrCode) & "|fffd|!"
    Case CColCycleEnd + 100
      ItemsCheckErrorMsg = "Das Endedatum muss nach dem Anfangsdatum liegen!"
    Case CColPeriod + 100
      ItemsCheckErrorMsg = "Die Periode darf nicht kleiner sein als die Dauer!"
    Case Else
      ItemsCheckErrorMsg = "Unbekannter Fehlercode=" & CStr(ErrCode)
  End Select
End Function



Public Function ItemsCheck(ByVal Index As Integer, ByVal DoShowError As Boolean) As Byte
' liefert 0, falls alles ok, ansonsten die Spalte, in der der Fehler aufgetreten ist oder einen h|fffd|heren Fehlercode
  
  If ItemsCharCount(Index) = 0 Then
    If DoShowError Then ItemsCheckErrorMsgShow Index, CColChar
    ItemsCheck = CColChar
    Exit Function
  End If
  
  If Not ItemsCycleBeginIsValid(Index) Then
    If DoShowError Then ItemsCheckErrorMsgShow Index, CColCycleBegin
    ItemsCheck = CColCycleBegin
    Exit Function
  End If
  
  If Not ItemsDurationIsValid(Index) Then
    If DoShowError Then ItemsCheckErrorMsgShow Index, CColDuration
    ItemsCheck = CColDuration
    Exit Function
  End If
   
  If Not ItemsPeriodIsValid(Index) Then
    If DoShowError Then ItemsCheckErrorMsgShow Index, CColPeriod
    ItemsCheck = CColPeriod
    Exit Function
  End If
   
  If ItemsCycleEndIsDate(Index) Then
    If ItemsCycleEnd(Index) <= ItemsCycleBegin(Index) Then
      ItemsCheck = CColCycleEnd + 100
      If DoShowError Then ItemsCheckErrorMsgShow Index, CColCycleEnd + 100
      Exit Function
    End If
  End If
      
  If ItemsDuration(Index) > ItemsPeriod(Index) Then
    If DoShowError Then ItemsCheckErrorMsgShow Index, CColPeriod + 100
    ItemsCheck = CColPeriod + 100
    Exit Function
  End If
   
   
   
  ItemsCheck = 0
End Function



Private Function ItemLineHasData(ByVal zeile As Integer) As Boolean
  ItemLineHasData = True
  If Cells(zeile, CColChar) <> "" Then Exit Function
  If Cells(zeile, CColCycleBegin) <> "" Then Exit Function
  If Cells(zeile, CColDuration) <> "" Then Exit Function
  If Cells(zeile, CColPeriod) <> "" Then Exit Function
  ItemLineHasData = False
End Function


Public Function ItemsCount() As Integer
Dim zeile As Integer

  zeile = MaxInt( _
    Cells(Rows.count, CColChar).End(xlUp).Row, MaxInt( _
    Cells(Rows.count, CColCycleBegin).End(xlUp).Row, MaxInt( _
    Cells(Rows.count, CColDuration).End(xlUp).Row, _
    Cells(Rows.count, CColPeriod).End(xlUp).Row)))
  ItemsCount = zeile - CRowDataFirst + 1
End Function

Public Property Get ItemsCycleBegin(ByVal Index As Integer) As Long
  ItemsCycleBegin = Cells(Index + CRowDataFirst, CColCycleBegin)
End Property


Public Property Let ItemsCycleBegin(ByVal Index As Integer, ADate As Long)
  Cells(Index + CRowDataFirst, CColCycleBegin) = ADate
End Property


Public Function ItemsCycleBeginIsValid(ByVal Index As Integer) As Boolean
  ItemsCycleBeginIsValid = IsDate(Cells(Index + CRowDataFirst, CColCycleBegin))
End Function


Public Property Get ItemsCycleEnd(ByVal Index As Integer) As Long
  If IsDate(Cells(Index + CRowDataFirst, CColCycleEnd)) Then
    ItemsCycleEnd = Cells(Index + CRowDataFirst, CColCycleEnd)
  Else
    ItemsCycleEnd = DateSerial(CYearMax, 12, 31)
  End If
End Property


Public Property Let ItemsCycleEnd(ByVal Index As Integer, ACycleEnd As Long)
  If ACycleEnd <= 0 Then
    ItemsCycleEndClear (Index)
  Else
    Cells(Index + CRowDataFirst, CColCycleEnd) = ACycleEnd
  End If
End Property


Public Sub ItemsCycleEndClear(ByVal Index As Integer)
  Cells(Index + CRowDataFirst, CColCycleEnd).ClearContents
End Sub

Public Function ItemsCycleEndIsDate(ByVal Index As Integer) As Long
  ItemsCycleEndIsDate = IsDate(Cells(Index + CRowDataFirst, CColCycleEnd))
End Function



Public Property Get ItemsDoShow(ByVal Index As Integer) As Boolean
  ItemsDoShow = Not TabData.StrIsNoStr(Cells(Index + CRowDataFirst, CColDoshow))
End Property


Public Property Let ItemsDoShow(ByVal Index As Integer, b As Boolean)
  Cells(Index + CRowDataFirst, CColDoshow) = TabData.YesNoStr(b)
End Property


Public Property Get ItemsDuration(ByVal Index As Integer) As Long
  ItemsDuration = Cells(Index + CRowDataFirst, CColDuration)
End Property


Public Property Let ItemsDuration(ByVal Index As Integer, ADuration As Long)
  Cells(Index + CRowDataFirst, CColDuration) = ADuration
End Property


Private Property Get ItemsFormula(ByVal Index As Integer, AColumn As Byte) As String
  ItemsFormula = Cells(Index + CRowDataFirst, AColumn).Formula
End Property

Private Property Let ItemsFormula(ByVal Index As Integer, AColumn As Byte, NewFormula As String)
  Cells(Index + CRowDataFirst, AColumn).Formula = NewFormula
End Property



Public Function ItemsDurationIsValid(ByVal Index As Integer) As Boolean
  If IsNumeric(Cells(Index + CRowDataFirst, CColDuration)) Then
    ItemsDurationIsValid = ItemsDuration(Index) > 0
  Else
    ItemsDurationIsValid = False
  End If
End Function


Private Function ItemsLoadFromOpenIniFile(ByVal Index As Byte, ByVal ASectionName As String) As Boolean
Dim CharList As String, CharListFirst As String
  Application.StatusBar = Me.Name & ": Lade Eintrag " & CStr(Index + 1)
  ItemsFormula(Index, CColCaption) = decodeURI(LoadFromOpenIniFileString(ASectionName, CIniKey_ItemsCaption), True)
  LoadFromOpenIniFileCharacters LoadFromOpenIniFileString(ASectionName, CIniKey_ItemsCharlist), Cells(Index + CRowDataFirst, CColChar).Characters
  ItemsFormula(Index, CColCycleBegin) = decodeURI(LoadFromOpenIniFileString(ASectionName, CIniKey_ItemsCycleBegin), True)
  ItemsFormula(Index, CColDuration) = decodeURI(LoadFromOpenIniFileString(ASectionName, CIniKey_ItemsDuration), True)
  ItemsFormula(Index, CColPeriod) = decodeURI(LoadFromOpenIniFileString(ASectionName, CIniKey_ItemsPeriod), True)
  ItemsFormula(Index, CColCycleEnd) = decodeURI(LoadFromOpenIniFileString(ASectionName, CIniKey_ItemsCycleEnd), True)
  ItemsSaturdayBehaviourIndex(Index) = LoadFromOpenInifileInteger(ASectionName, CIniKey_ItemsSaturdayBehaviour, 0)
  ItemsPublicBehaviourIndex(Index) = LoadFromOpenInifileInteger(ASectionName, CIniKey_ItemsPublicBehaviour, 0)
  ItemsSaturdayIsWorkday(Index) = LoadFromOpenIniFileBoolean(ASectionName, CIniKey_ItemsSaturdayIsWorkday, False)
  ItemsDoShow(Index) = LoadFromOpenIniFileBoolean(ASectionName, CIniKey_ItemsDoshow, True)
  ItemsLoadFromOpenIniFile = True
  Application.StatusBar = False
End Function



Public Property Get ItemsPeriod(ByVal Index As Integer) As Long
  ItemsPeriod = Cells(Index + CRowDataFirst, CColPeriod)
End Property


Public Property Let ItemsPeriod(ByVal Index As Integer, APeriod As Long)
  Cells(Index + CRowDataFirst, CColPeriod) = APeriod
End Property


Public Function ItemsPeriodIsValid(ByVal Index As Integer) As Boolean
  If IsNumeric(Cells(Index + CRowDataFirst, CColPeriod)) Then
    ItemsPeriodIsValid = CLng(Cells(Index + CRowDataFirst, CColPeriod)) > 0
  Else
    ItemsPeriodIsValid = False
  End If
End Function






Public Property Get ItemsPublicBehaviourIndex(ByVal Index As Integer) As Byte
  ItemsPublicBehaviourIndex = TabData.PublicBehaviourStrToIndex(Cells(Index + CRowDataFirst, CColPublicBehaviour))
End Property


Public Property Let ItemsPublicBehaviourIndex(ByVal Index As Integer, NewPublicBehaviourIndex As Byte)
  Cells(Index + CRowDataFirst, CColPublicBehaviour) = TabData.IndexToPublicBehaviourStr(NewPublicBehaviourIndex)
End Property



Public Property Get ItemsSaturdayBehaviourIndex(ByVal Index As Integer) As Byte
  ItemsSaturdayBehaviourIndex = TabData.PublicBehaviourStrToIndex(Cells(Index + CRowDataFirst, CColSaturdayBehaviour))
End Property


Public Property Let ItemsSaturdayBehaviourIndex(ByVal Index As Integer, NewPublicBehaviourIndex As Byte)
  Cells(Index + CRowDataFirst, CColSaturdayBehaviour) = TabData.IndexToPublicBehaviourStr(NewPublicBehaviourIndex)
End Property


Public Property Get ItemsSaturdayIsWorkday(ByVal Index As Integer) As Boolean
  ItemsSaturdayIsWorkday = Not TabData.StrIsNoStr(Cells(Index + CRowDataFirst, CColSaturdayIsWorkday))
End Property


Public Property Let ItemsSaturdayIsWorkday(ByVal Index As Integer, b As Boolean)
  Cells(Index + CRowDataFirst, CColSaturdayIsWorkday) = TabData.YesNoStr(b)
End Property


Private Function ItemsSaveToOpenIniFile(ByVal Index As Byte, ByVal SectionName As String) As Boolean
  Application.StatusBar = Me.Name & ": Speichere Eintrag " & CStr(Index + 1)
  SaveToOpenIniFileString SectionName, CIniKey_ItemsCaption, encodeURI(ItemsFormula(Index, CColCaption), True)
  SaveToOpenIniFileString SectionName, CIniKey_ItemsCharlist, SaveToOpenIniFileCharacters(CIniPrefixSectionItems & CIniPrefixFrmStrToc, Cells(Index + CRowDataFirst, CColChar).Characters)
  SaveToOpenIniFileString SectionName, CIniKey_ItemsCycleBegin, encodeURI(ItemsFormula(Index, CColCycleBegin), True)
  SaveToOpenIniFileString SectionName, CIniKey_ItemsDuration, encodeURI(ItemsFormula(Index, CColDuration), True)
  SaveToOpenIniFileString SectionName, CIniKey_ItemsPeriod, encodeURI(ItemsFormula(Index, CColPeriod), True)
  SaveToOpenIniFileString SectionName, CIniKey_ItemsCycleEnd, encodeURI(ItemsFormula(Index, CColCycleEnd), True)
  SaveToOpenIniFileInteger SectionName, CIniKey_ItemsSaturdayBehaviour, ItemsSaturdayBehaviourIndex(Index)
  SaveToOpenIniFileInteger SectionName, CIniKey_ItemsPublicBehaviour, ItemsPublicBehaviourIndex(Index)
  SaveToOpenIniFileBoolean SectionName, CIniKey_ItemsSaturdayIsWorkday, BooleanToIniValue(ItemsSaturdayIsWorkday(Index))
  SaveToOpenIniFileBoolean SectionName, CIniKey_ItemsDoshow, BooleanToIniValue(ItemsDoShow(Index))
  ItemsSaveToOpenIniFile = True
  Application.StatusBar = False
  
End Function





Public Function LoadFromOpenIniFile(ByRef ItemsTreated As Long) As Boolean
Dim Keylist As String, s As String
Dim StrIndex As Long, ARow As Long, ACol As Long, CommentOffsetRow As Long
  
  CommentOffsetRow = ItemsCount
  Keylist = LoadFromOpenIniFileString(CodeName, CIniKeyCommentlist)
  While TokenNext(Keylist, Asc(","), s, StrIndex, False)
    If LoadFromOpenIniFileCommentPos(s, ARow, ACol) Then
      Cells(ARow + CommentOffsetRow, ACol).AddComment
      LoadFromOpenIniFileComment s, Cells(ARow + CommentOffsetRow, ACol).Comment
    End If
    StrIndex = StrIndex + 1
  Wend

  
  Keylist = LoadFromOpenIniFileString(CodeName, CIniKey_Items)
  StrIndex = 1
  While TokenNext(Keylist, Asc(","), s, StrIndex, False)
    ItemsLoadFromOpenIniFile ItemsCount, s
    StrIndex = StrIndex + 1
    ItemsTreated = ItemsTreated + 1
  Wend
  LoadFromOpenIniFile = True
End Function



Public Sub MakeDist()
Dim i As Integer
Dim PrevVisible As Long
  PrevVisible = Visible
  Visible = xlSheetVisible
  Activate
  For i = 0 To ItemsCount - 1
    ItemsDoShow(i) = False
  Next i
  Cells(CRowDataFirst + ItemsCount, CColCaption).Select
  Visible = PrevVisible

End Sub



Public Function SaveToOpenIniFile(ByRef ItemsTreated As Long) As Boolean
Dim i As Integer
Dim KeyCommentlist As String, KeyUserItems As String, s As String
  
  For i = 1 To Comments.count
    If Comments(i).Parent.Row >= CRowDataFirst Then
      s = CIniPrefixComment & CStr(NextFreeSectionID)
      SaveToOpenIniFileComment s, Comments(i), Comments(i).Parent.Row, Comments(i).Parent.Column
      KeyCommentlist = KeyCommentlist & s & ","
    End If
  Next i
  If KeyCommentlist <> "" Then
    KeyCommentlist = Left(KeyCommentlist, Len(KeyCommentlist) - 1)
    SaveToOpenIniFileString CodeName, CIniKeyCommentlist, KeyCommentlist
  End If
  
  For i = 0 To ItemsCount - 1
    s = CIniPrefixSectionItems & CStr(i)
    KeyUserItems = KeyUserItems & s & ","
    ItemsSaveToOpenIniFile i, s
    ItemsTreated = ItemsTreated + 1
  Next i
  KeyUserItems = Left(KeyUserItems, Len(KeyUserItems) - 1)
  SaveToOpenIniFileString CodeName, CIniKey_Items, KeyUserItems
  SaveToOpenIniFile = True
End Function








Private Sub Worksheet_Activate()
  TabInfos.InfoCheckbox(CInfoCheckboxZeileCyclic) = True
  If TabInfos.TabselectionCodeUse Then
    ActiveWindow.DisplayHeadings = True
    ActiveSheet.DisplayAutomaticPageBreaks = False
    EnableSelection = xlUnlockedCells
    If Not ActiveWindow.Split Then GoTo CorrectPanes
    If ActiveWindow.SplitRow <> 3 Then GoTo CorrectPanes
    If ActiveWindow.Panes(1).ScrollRow <> 1 Then
CorrectPanes:
      Application.ScreenUpdating = False
      ActiveSheet.ScrollArea = ""
      ActiveWindow.FreezePanes = False
      ActiveWindow.Panes(1).ScrollRow = 1
      ActiveWindow.SplitRow = 3
      ActiveWindow.SplitColumn = 0
      ActiveWindow.FreezePanes = True
      Application.ScreenUpdating = True
    End If
    ActiveSheet.ScrollArea = Range(Cells(CRowDataFirst, CColFirst), Cells(CRowMax, CColLast)).Address
    
    ' Wenn die Tabelle gesch|fffd|tzt ist, ist keine Zellformatierung mehr m|fffd|glich...
    Unprotect
  End If
End Sub



Private Sub Worksheet_Deactivate()
  If TabInfos.TabselectionCodeUse Then Visible = xlSheetHidden
End Sub

Attribute VB_Name = "TabData"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit


Const CRowBundeslandindex                 As Byte = 1: Const CColBundeslandindex               As Byte = 1
Const CRowBundeslaenderBegin              As Byte = 2: Const CColBundeslaender                  As Byte = 1
Const CRowFeiertageBegin                  As Byte = CRowBundeslaenderBegin: Const CColFeiertageBegin As Byte = 2
' Die Endezeile und -spalte ergibt sich durch *CPublicCount* und *BundeslaenderCount*
Const CRowBundeslaenderEnd                As Byte = 17
Const CRowRegistrierungscode              As Byte = 23: Const CColRegistrierungscode            As Byte = 2
Const CRowEMailAddress                    As Byte = 73: Const CColEMailAddress                  As Byte = 1
Const CRowLastChoosenDateFrom             As Byte = 74: Const CColLastChoosenDateFrom           As Byte = 2
Const CRowLastChoosenDateTo               As Byte = 75: Const CColLastChoosenDateTo             As Byte = 2
Const CRowLastChoosenSchema               As Byte = 76: Const CColLastChoosenSchema             As Byte = 2
Const CRowLastFilenameYearlyImport        As Byte = 77: Const CColLastFilenameYearlyImport      As Byte = 2
Const CRowLastFilenameImportExport        As Byte = 78: Const CColLastFilenameImportExport      As Byte = 2
Const CRowFilenameHelp                    As Byte = 79: Const CColFilenameHelp                  As Byte = 2






Const CRangeFeiertagsverhalten          As String = "Feiertagsverhalten"
Const CRangeJaNein                      As String = "JaNein"
Const CRangeOrientation                 As String = "Seitenorientierung"
Const CRangePapersizesStr               As String = "Papierformate"
Const CRangePapersizesIndices           As String = "PapierformatIndices"
Const CRangeTmpRow                      As String = "TmpRow"
Const CRangeVerticalAlignment           As String = "VertikaleAusrichtungen"




Public Property Get BundeslandIndex() As Byte
' Liefert den in *CRowBundeslandindex*/*CColBundeslandindex* gespeicherten, zuletzt ausgew|fffd|hlten Index des Bundeslandes
' Falls 0, ist kein Bundesland ausgew|fffd|hlt
  BundeslandIndex = CByte(Cells(CRowBundeslandindex, CColBundeslandindex))
End Property


Public Property Let BundeslandIndex(ByVal NewBundeslandIndex As Byte)
  If BundeslandIndex = NewBundeslandIndex Then Exit Property
  Cells(CRowBundeslandindex, CColBundeslandindex) = NewBundeslandIndex
  BundeslandIndexChanged
End Property



Private Sub BundeslandIndexChanged()
Dim i As Byte
  
  TabPublics.BundeslandStr = Bundeslaender(BundeslandIndex)
  TabPublics.DefaultSet TabData.BundeslandIndex
  For i = 1 To TabHolidaysAll.YearsCount(BundeslandIndex)
    TabHolidays.DefaultSet BundeslandIndex, TabHolidaysAll.Years(BundeslandIndex, i - 1), True
  Next i
End Sub



Public Property Get Bundeslaender(ByVal Index As Byte) As String
' 1-basierte Liste aller Bundesl|fffd|nderbenennungen
  Bundeslaender = Cells(CRowBundeslaenderBegin + Index - 1, CColBundeslaender)
End Property


Public Property Get BundeslaenderCount() As Byte
  BundeslaenderCount = CRowBundeslaenderEnd - CRowBundeslaenderBegin + 1
End Property

'Public Property Get BundeslandStr(ByVal index As Byte) As String
'  If index = 0 Then BundeslandStr = "" Else BundeslandStr = Bundeslaender(index)
'End Property



Public Property Get BundeslandStrToIndex(ByVal BundeslandStr As String) As Integer
' Sucht aus
Dim i As Byte
  For i = 1 To BundeslaenderCount
    If StrComp(Bundeslaender(i), BundeslandStr, vbTextCompare) = 0 Then
      BundeslandStrToIndex = i
      Exit Property
    End If
  Next i
  BundeslandStrToIndex = -1
End Property


Public Sub Clear()
  LastChoosenSchemaClear
  LastChoosenDateClear
  LastFilenameYearlyImport = ""
  LastFilenameImportExport = ""
  FilenameHelp = ""
  Registrierungscode = ""
  TempRow.Clear
  BundeslandIndex = 0
End Sub




Public Property Get EMailAddress() As String
  EMailAddress = Cells(CRowEMailAddress, CColEMailAddress)
End Property

Public Property Get EMailAddressRange() As String
  EMailAddressRange = Cells(CRowEMailAddress, CColEMailAddress).Address
End Property


Public Property Get FilenameHelp() As String
  FilenameHelp = Cells(CRowFilenameHelp, CColFilenameHelp)
End Property


Public Property Let FilenameHelp(ByVal NewFilenameHelp As String)
  If NewFilenameHelp = FilenameHelp Then Exit Property
  Cells(CRowFilenameHelp, CColFilenameHelp) = NewFilenameHelp
End Property


Public Function Holidays(ABundeslandIndex As Byte)
' gibt ein Array aus *CPublicCount* Feldern mit Boolean-Werten zur|fffd|ck, die anzeigen, ob der i-te Tag ein Feiertag ist
Dim Feiertage(1 To CPublicCount) As Boolean
Dim i As Byte
  If ABundeslandIndex = 0 Then Exit Function
  For i = 1 To CPublicCount
    Feiertage(i) = Cells(CRowFeiertageBegin + ABundeslandIndex - 1, CColFeiertageBegin + i - 1)
  Next i
  Let Holidays = Feiertage
End Function



Public Function Kundenangaben() As String
  Kundenangaben = RegStrExtractKundenAngaben(Registrierungscode)
End Function



Public Property Get LastChoosenSchema() As String
  LastChoosenSchema = Cells(CRowLastChoosenSchema, CColLastChoosenSchema)
End Property


Public Property Let LastChoosenSchema(NewLastChoosenSchema As String)
  Cells(CRowLastChoosenSchema, CColLastChoosenSchema) = NewLastChoosenSchema
End Property

Private Sub LastChoosenSchemaClear()
  Cells(CRowLastChoosenSchema, CColLastChoosenSchema).ClearContents
End Sub


Public Property Get LastChoosenDate(ByVal GetFromDate As Boolean) As Long
  If GetFromDate Then
    LastChoosenDate = Cells(CRowLastChoosenDateFrom, CColLastChoosenDateFrom)
  Else
    LastChoosenDate = Cells(CRowLastChoosenDateTo, CColLastChoosenDateTo)
  End If
End Property


Private Sub LastChoosenDateClear()
  Cells(CRowLastChoosenDateFrom, CColLastChoosenDateFrom).ClearContents
  Cells(CRowLastChoosenDateTo, CColLastChoosenDateTo).ClearContents
End Sub


Public Property Let LastChoosenDate(ByVal GetFromDate As Boolean, ByVal NewLastChoosenDate As Long)
  If GetFromDate Then
    Cells(CRowLastChoosenDateFrom, CColLastChoosenDateFrom) = NewLastChoosenDate
  Else
    Cells(CRowLastChoosenDateTo, CColLastChoosenDateTo) = NewLastChoosenDate
  End If
End Property



Public Function LastChoosenDateHave(ByVal GetFromDate As Boolean) As Boolean
  If GetFromDate Then
    LastChoosenDateHave = IsDate(Cells(CRowLastChoosenDateFrom, CColLastChoosenDateFrom))
  Else
    LastChoosenDateHave = IsDate(Cells(CRowLastChoosenDateTo, CColLastChoosenDateTo))
  End If
End Function




Public Property Get LastFilenameImportExport() As String
  LastFilenameImportExport = Cells(CRowLastFilenameImportExport, CColLastFilenameImportExport)
End Property


Public Property Let LastFilenameImportExport(ByVal AFilename As String)
  Cells(CRowLastFilenameImportExport, CColLastFilenameImportExport) = AFilename
End Property



Public Property Get LastFilenameYearlyImport() As String
  LastFilenameYearlyImport = Cells(CRowLastFilenameYearlyImport, CColLastFilenameYearlyImport)
End Property


Public Property Let LastFilenameYearlyImport(ByVal Filename As String)
  Cells(CRowLastFilenameYearlyImport, CColLastFilenameYearlyImport) = Filename
End Property


Public Sub MakeDist()
  Clear
End Sub


Public Function OrientationStrToIndex(ByVal OrientationStr As String) As Byte
  If StrComp(OrientationStr, Range(CRangeOrientation).Cells(1, 1), vbTextCompare) = 0 Then
    OrientationStrToIndex = xlPortrait
  Else
    OrientationStrToIndex = xlLandscape
  End If
End Function


Public Function OrientationIndexToStr(ByVal OrientationIndex As Byte) As String
  OrientationIndexToStr = Range(CRangeOrientation).Cells(OrientationIndex, 1)
End Function


Public Function PaperSizeIndexToStr(ByVal PaperSizeIndex As Integer) As String
Dim i As Byte
  
  For i = 1 To Range(CRangePapersizesIndices).Rows.count
    If PaperSizeIndex = Range(CRangePapersizesIndices).Cells(i, 1) Then
      PaperSizeIndexToStr = Range(CRangePapersizesStr).Cells(i, 1)
      Exit Function
    End If
  Next i
  PaperSizeIndexToStr = ""
End Function


Public Function PaperSizeStrToIndex(ByVal PaperSizeStr As String) As Integer
Dim i As Byte
  
  For i = 1 To Range(CRangePapersizesStr).Rows.count
    If StrComp(PaperSizeStr, Range(CRangePapersizesStr).Cells(i, 1), vbTextCompare) = 0 Then
      PaperSizeStrToIndex = Range(CRangePapersizesIndices).Cells(i, 1)
      Exit Function
    End If
  Next i
  PaperSizeStrToIndex = -1
End Function


Public Function IndexToPublicBehaviourStr(ByVal Index As Byte) As String
' Die Indexz|fffd|hlung beginnt bei 1
  IndexToPublicBehaviourStr = Range(CRangeFeiertagsverhalten).Cells(Index, 1)
End Function

Public Function PublicBehaviourStrToIndex(PublicBehaviourStr As String) As Byte
' Die Indexz|fffd|hlung beginnt bei 1
' Siehe auch *IndexToPublicBehaviourStr*
Dim i As Byte
  For i = 1 To Range(CRangeFeiertagsverhalten).Rows.count
    If StrComp(PublicBehaviourStr, Range(CRangeFeiertagsverhalten).Cells(i, 1), vbTextCompare) = 0 Then
      PublicBehaviourStrToIndex = i
      Exit Function
    End If
  Next i
  ' nicht gefunden, Index 1 zur|fffd|ckgeben
  PublicBehaviourStrToIndex = 1
End Function


Public Property Get Registrierungscode() As String
  Registrierungscode = Cells(CRowRegistrierungscode, CColRegistrierungscode)
End Property


Public Property Let Registrierungscode(ByVal NewRegistrierungscode As String)
Dim Programmname As String
Dim MainVersion As Byte

  
  If NewRegistrierungscode = "" Then
    GoTo Delete_RegCode
  Else
    If RegistrierungscodeOk(NewRegistrierungscode) Then
      If Registrierungscode <> NewRegistrierungscode Then
        Cells(CRowRegistrierungscode, CColRegistrierungscode) = NewRegistrierungscode
      End If
      TabSettings.Gesperrt = False
    Else
      GoTo Delete_RegCode
    End If
  End If
  GoTo Exit_Registrierungscode
  
Delete_RegCode:
  Cells(CRowRegistrierungscode, CColRegistrierungscode) = ""
  TabSettings.Gesperrt = True
  GoTo Exit_Registrierungscode
  
Exit_Registrierungscode:
End Property



Public Function RegistrierungscodeOk(ByVal NewRegistrierungscode As String) As Boolean
Dim Programmname As String, dummy As String
Dim MainVersion As Byte

  RegistrierungscodeOk = RegStr2UserData(NewRegistrierungscode, dummy, Programmname, MainVersion) _
    And (Programmname = CProgrammname) _
    And (CVersionMain = MainVersion)
End Function






Public Property Get StrIsYesStr(ByVal s As String) As Boolean
  StrIsYesStr = StrComp(s, YesNoStr(True), vbTextCompare) = 0
End Property


Public Property Get StrIsNoStr(ByVal s As String) As Boolean
  StrIsNoStr = StrComp(s, YesNoStr(False), vbTextCompare) = 0
End Property


Public Property Get TempRow() As Range
  Set TempRow = Range(CRangeTmpRow)
End Property


Public Function VerticalAlignmentStrToIndex(ByVal VerticalAlignmentStr As String) As Integer
Dim i As Byte
  
  For i = 1 To Range(CRangeVerticalAlignment).Rows.count
    If StrComp(VerticalAlignmentStr, Range(CRangeVerticalAlignment).Cells(i, 1), vbTextCompare) = 0 Then
      VerticalAlignmentStrToIndex = Range(CRangeVerticalAlignment).Cells(i, 2)
      Exit Function
    End If
  Next i
  VerticalAlignmentStrToIndex = xlVAlignTop
End Function


Public Function VerticalAlignmentIndexToStr(ByVal VerticalAlignmentIndex As Integer) As String
Dim i As Byte
  
  For i = 1 To Range(CRangeVerticalAlignment).Rows.count
    If VerticalAlignmentIndex = Range(CRangeVerticalAlignment).Cells(i, 2) Then
      VerticalAlignmentIndexToStr = Range(CRangeVerticalAlignment).Cells(i, 1)
      Exit Function
    End If
  Next i
  VerticalAlignmentIndexToStr = xlVAlignTop
End Function





Public Property Get YesNoStr(ByVal GetYesStr As Boolean) As String
  YesNoStr = Range(CRangeJaNein).Cells(CByte(GetYesStr + 1) + 1, 1)
End Property






Attribute VB_Name = "TabHolidays"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Control = "ButtonSchulFerienNachschlagen, 3, 0, MSForms, CommandButton"
Attribute VB_Control = "ButtonImport, 4, 1, MSForms, CommandButton"
Attribute VB_Control = "ButtonSchulferienSort, 5, 2, MSForms, CommandButton"
Attribute VB_Control = "ButtonSelectInfos, 6, 3, MSForms, CommandButton"
Option Explicit




Private Const CColYear              As Byte = 1
Private Const CColChristmasBegin    As Byte = 13
Private Const CColChristmasEnd      As Byte = 2
Private Const CColDataFirst         As Byte = 2
Private Const CColDataLast          As Byte = 17 ' letzte Spalte mit Datumsangaben

Private Const CRowDataFirst         As Byte = 4
Private Const CIniLinePrefix        As String = "Def"

Dim CurZeile As Integer
Dim CurSpalte As Integer


   
Private Sub ButtonSchulFerienNachschlagen_Click()
  FormHolidaySelect.Show
End Sub
    
    
Private Sub ButtonImport_Click()
Static Filename As String

  If Filename = "" Then Filename = "Schulferien.csv"
  
  If Not FormImportSchulferien.Execute(Filename) Then Exit Sub
  TabHolidaysAll.ImportFerien Filename
End Sub
    

Private Function ButtonSchulferienSort_ClickCompareCells(ByVal Val1 As Long, ByVal Val2 As Long) As Integer
  If Val1 = Val2 Then _
    ButtonSchulferienSort_ClickCompareCells = 0 _
  Else _
    If Val1 = 0 Then _
      ButtonSchulferienSort_ClickCompareCells = 1 _
    Else _
      If Val2 = 0 Then _
        ButtonSchulferienSort_ClickCompareCells = -1 _
      Else _
        If Val1 > Val2 Then _
          ButtonSchulferienSort_ClickCompareCells = 1 _
        Else _
          ButtonSchulferienSort_ClickCompareCells = -1
  
End Function



Private Sub ButtonSchulferienSort_Click()
' Voraussetzung: die Tabelle ist bereits aktiv
On Error GoTo Err_ButtonSchulferienSort_Click
Dim RowCount As Integer
Dim i As Integer
Dim j As Integer

  
  
  Application.ScreenUpdating = False
  

  ActiveSheet.Unprotect
  RowCount = LastUsedCellInColumn(ActiveSheet, CRowDataFirst, 1, 3) - CRowDataFirst
  
  For i = CRowDataFirst To RowCount + CRowDataFirst
    For j = i + 1 To RowCount + CRowDataFirst
      If ButtonSchulferienSort_ClickCompareCells(Cells(j, 1), Cells(i, 1)) < 0 Then _
        SwapRows ActiveSheet, i, j, TabData.Range("TmpRow")
    Next j
  Next i
  ActiveSheet.Protect
  GoTo Exit_ButtonSchulferienSort_Click


Err_ButtonSchulferienSort_Click:
  MsgBox Err.Description, vbCritical, CTitleMsgBox
  Resume Exit_ButtonSchulferienSort_Click
Exit_ButtonSchulferienSort_Click:
  Application.ScreenUpdating = True
End Sub




    
Private Sub ButtonSelectInfos_Click()
  KalenderGlobal.ButtonSelectInfos_Click
End Sub
    
    


Public Sub Clear()
Dim LastUsedRow  As Long
  LastUsedRow = Cells(Rows.count, 1).End(xlUp).Row
  If LastUsedRow >= CRowDataFirst Then
    Range(Cells(CRowDataFirst, CColYear), Cells(LastUsedRow, CColDataLast)).ClearContents
  End If
End Sub


Public Function ColDataLast() As Long
  ColDataLast = CColDataLast
End Function


Public Function DefaultHave(ByVal ABundeslandIndex As Byte) As Boolean
Dim i As Integer

  For i = 1 To TabHolidaysAll.YearsCount(TabData.BundeslandIndex)
    If Not DefaultHaveYear(ABundeslandIndex, TabHolidaysAll.Years(ABundeslandIndex, i - 1)) Then
      DefaultHave = False
      Exit Function
    End If
  Next i
  DefaultHave = True

End Function


Private Function DefaultHaveYearContentsEqual(ByVal CellContent1, ByVal CellContent2) As Byte
  If (IsDate(CellContent1)) And (IsDate(CellContent2)) Then
    DefaultHaveYearContentsEqual = CDate(CellContent1) = CDate(CellContent2)
  Else
    DefaultHaveYearContentsEqual = CellContent1 = CellContent1
  End If
End Function

Public Function DefaultHaveYear(ByVal ABundeslandIndex As Byte, ByVal AYear As Integer) As Boolean
Dim i As Integer
Dim SchulferienlisteDefault
Dim SchulferienlisteCurrent
  
  SchulferienlisteCurrent = HolidayArrayGet(AYear)
  If IsEmpty(SchulferienlisteCurrent) Then DefaultHaveYear = True: Exit Function
  SchulferienlisteDefault = TabHolidaysAll.HolidayArray(ABundeslandIndex, AYear)
  If UBound(SchulferienlisteCurrent) <> UBound(SchulferienlisteDefault) Then DefaultHaveYear = False: Exit Function
  For i = LBound(SchulferienlisteDefault) To UBound(SchulferienlisteDefault)
    If Not DefaultHaveYearContentsEqual(SchulferienlisteDefault(i), SchulferienlisteCurrent(i)) Then DefaultHaveYear = False: Exit Function
  Next i
  DefaultHaveYear = True
End Function



Public Function DefaultSet(ByVal ABundeslandIndex As Byte, ByVal AYear As Integer, ByVal DoOverwrite As Boolean) As Integer
Dim SchulferienlisteDefault
Dim zeile As Integer, i As Integer, EntriesWritten As Integer
Dim ProtectContentsOld As Boolean

  If Me.ProtectContents Then
    ProtectContentsOld = True
    Me.Unprotect
  Else
    ProtectContentsOld = False
  End If
    
  JahresZeile AYear, zeile
  
  
  SchulferienlisteDefault = TabHolidaysAll.HolidayArray(ABundeslandIndex, AYear)
  
  If DoOverwrite Then
    If Me.ProtectContents Then Me.Unprotect
    Me.Cells(zeile, 1).EntireRow.ClearContents
    Me.Cells(zeile, CColYear) = AYear
  End If

  If DoOverwrite Then
    For i = LBound(SchulferienlisteDefault) To UBound(SchulferienlisteDefault)
      FillCellWithProbablyDate zeile, CColDataFirst + i, SchulferienlisteDefault(i)
      EntriesWritten = EntriesWritten + 1
    Next i
  Else
    For i = LBound(SchulferienlisteDefault) To UBound(SchulferienlisteDefault)
      If Me.Cells(zeile, CColDataFirst + i) = "" Then
        FillCellWithProbablyDate zeile, CColDataFirst + i, SchulferienlisteDefault(i)
        EntriesWritten = EntriesWritten + 1
      End If
    Next i
  End If
  'Me.Columns("A:Z").EntireColumn.AutoFit ' "Objekte k|fffd|nnen nicht |fffd|ber das Blatt hinaus verschoben werden"
  If ProtectContentsOld Then Me.Protect
  DefaultSet = EntriesWritten
End Function



Public Function Ferien(ByVal DateFrom As Long, ByVal DateTo As Long)
Dim CurIndex As Integer
Dim Feriendata() As Long
Dim zeile As Integer
Dim i As Byte
Dim WeihnachtsEndeZelle As Range
Dim FerienBeginn As Range, FerienEnde As Range
Dim ADate As Long
  
 

  ReDim Feriendata(1, 0)
  CurIndex = -1
  
  For zeile = CRowDataFirst To Cells(Rows.count, 1).End(xlUp).Row
    
    If IsDate(Cells(zeile, CColChristmasEnd)) Then
      If Not HaveWeihnachtsAnfang(Cells(zeile, CColChristmasEnd), ADate) Then ADate = DateSerial(Year(Cells(zeile, CColChristmasEnd)), 1, 1)
      If IsInDateWindow(Cells(zeile, CColChristmasEnd), DateFrom, DateTo) Or IsInDateWindow(ADate, DateFrom, DateTo) Then
        CurIndex = CurIndex + 1
        ReDim Preserve Feriendata(1, CurIndex)
        Feriendata(0, CurIndex) = ADate
        Feriendata(1, CurIndex) = Cells(zeile, CColChristmasEnd)
      End If
    End If
    
    For i = 0 To 4 ' Winter- bis Herbstferien
      Set FerienBeginn = Cells(zeile, CColChristmasEnd + 1 + i * 2)
      If IsDate(FerienBeginn) Then
        Set FerienEnde = Cells(zeile, CColChristmasEnd + 1 + i * 2 + 1)
        If IsInDateWindow(FerienBeginn, DateFrom, DateTo) Or IsInDateWindow(FerienEnde, DateFrom, DateTo) Then
          If IsDate(FerienEnde) Then
            CurIndex = CurIndex + 1
            ReDim Preserve Feriendata(1, CurIndex)
            Feriendata(0, CurIndex) = FerienBeginn
            Feriendata(1, CurIndex) = FerienEnde
          End If
        End If
      End If
    Next i
    
    i = CColChristmasBegin + 1
    While IsDate(Cells(zeile, i))
      If IsInDateWindow(Cells(zeile, i), DateFrom, DateTo) Then
        CurIndex = CurIndex + 1
        ReDim Preserve Feriendata(1, CurIndex)
        Feriendata(0, CurIndex) = Cells(zeile, i)
        Feriendata(1, CurIndex) = Cells(zeile, i)
      End If
      i = i + 1
    Wend
  Next zeile
  
  Let Ferien = Feriendata
End Function





Private Function FillCellWithProbablyDate(ByVal ARow As Byte, ByVal ACol As Byte, ByVal AValue As String)
  If IsDate(AValue) Then
    Me.Cells(ARow, ACol) = CDate(AValue)
  Else
    Me.Cells(ARow, ACol) = AValue
    Me.Cells(ARow, ACol).HorizontalAlignment = xlCenter
  End If
End Function



Public Function HolidayArrayGet(ByVal AYear As Integer)
Dim zeile As Integer

  If Not JahresZeile(AYear, zeile) Then Exit Function
  Let HolidayArrayGet = FerienArrayGet(Me, zeile, CColDataFirst)
End Function





Private Function HaveWeihnachtsAnfang(ByVal WeihnachtsEnde As Long, ByRef WeihnachtsBeginn As Long) As Boolean
Dim i As Integer, ZielJahr As Integer

  ZielJahr = Year(WeihnachtsEnde) - 1
  For i = CRowDataFirst To Cells(Rows.count, 1).End(xlUp).Row
    If IsDate(Cells(i, CColChristmasBegin)) Then
      If Year(Cells(i, CColChristmasBegin)) = ZielJahr Then
        WeihnachtsBeginn = Cells(i, CColChristmasBegin)
        HaveWeihnachtsAnfang = True
        Exit Function
      End If
    End If
  Next i
  HaveWeihnachtsAnfang = False
End Function






Public Function JahresZeile(ByVal AYear As Integer, ByRef zeile As Integer) As Boolean
  
  zeile = SucheJahresZeile(TabHolidays, AYear, CRowDataFirst - 1, CColYear)
  If zeile = 0 Then ' n|fffd|chste leere Zeile aufsuchen:
    JahresZeile = False
    zeile = CRowDataFirst
    While TabHolidays.Cells(zeile, CColYear) <> ""
      zeile = zeile + 1
    Wend
  Else
    JahresZeile = True
  End If
End Function


Public Function LoadFromOpenIniFile(ByRef ItemsTreated As Long) As Boolean
Dim zeile As Integer
Dim spalte As Byte
Dim inistr As String, s As String
Dim StrIndex As Long

  zeile = CRowDataFirst
  Do
    inistr = LoadFromOpenIniFileString(CodeName, CIniLinePrefix & CStr(zeile - CRowDataFirst))
    If inistr = "" Then GoTo Success_LoadFromOpenIniFile
    spalte = CColYear
    StrIndex = 1
    While TokenNext(inistr, CIniDelimiterCharCode, s, StrIndex, False)
      Cells(zeile, spalte) = decodeURI(s, True)
      StrIndex = StrIndex + 1
      spalte = spalte + 1
    Wend
    ItemsTreated = ItemsTreated + 1
    zeile = zeile + 1
  Loop Until inistr = ""
  GoTo Success_LoadFromOpenIniFile
  
Fail_LoadFromOpenIniFile:
  LoadFromOpenIniFile = False
  GoTo Exit_LoadFromOpenIniFile
  
Success_LoadFromOpenIniFile:
  LoadFromOpenIniFile = True
  GoTo Exit_LoadFromOpenIniFile
  
Exit_LoadFromOpenIniFile:
  
End Function


Public Sub MakeDist()
Dim PrevVisible As Long
  PrevVisible = Visible
  Visible = xlSheetVisible
  Activate
  Clear
  Cells(CRowDataFirst, CColYear).Select
  Visible = PrevVisible
End Sub
    



Public Function SaveToOpenIniFile(ByRef ItemsTreated As Long) As Boolean
Dim zeile As Integer
Dim spalte As Byte
Dim inistr As String, s As String

  
  For zeile = CRowDataFirst To Cells(Rows.count, 1).End(xlUp).Row
    Application.StatusBar = Me.Name & ": Speichere Eintrag " & CStr(zeile - CRowDataFirst + 1)
    inistr = ""
    For spalte = CColYear To CColDataLast
      s = encodeURI(Cells(zeile, spalte).Formula, True)
      inistr = inistr & s & Chr(CIniDelimiterCharCode)
    Next spalte
    If inistr <> "" Then inistr = Left(inistr, Len(inistr) - 1)
    SaveToOpenIniFileString CodeName, CIniLinePrefix & CStr(zeile - CRowDataFirst), inistr
    ItemsTreated = ItemsTreated + 1
  Next zeile
  SaveToOpenIniFile = True
  Application.StatusBar = False
End Function






Private Sub Worksheet_Activate()
  TabInfos.InfoCheckbox(CInfoCheckboxZeileSchulferien) = True
  If TabInfos.TabselectionCodeUse Then
    ActiveWindow.DisplayHeadings = False
    ActiveSheet.DisplayAutomaticPageBreaks = False
    EnableSelection = xlUnlockedCells
    Protect
  End If
End Sub

Private Sub Worksheet_Deactivate()
  If TabInfos.TabselectionCodeUse Then Visible = xlSheetHidden
End Sub



Attribute VB_Name = "TabHolidaysAll"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit


Private Const CColBundesland        As Byte = 1       ' Spalte mit den Bundesl|fffd|ndern in *TabHolidaysAll*
Private Const CColYear              As Byte = 2
Private Const CColXMasBegin         As Byte = 14
Private Const CColXMasEnd           As Byte = 3

Private Const CColDataFirst         As Byte = CColBundesland
'Private Const CColDataLast: siehe Funktion ColDataLast


Private Const CColHolydayReleaseDate  As Byte = 1
Private Const CRowHolydayReleaseDate  As Byte = 1

'Private Const CRowDataFirst As Byte = 3

Private Const CRowDataFirst  As Byte = 3 ' erste Datenzeile


Public Property Get BundeslandNextLine(ByVal ABundeslandIndex As Byte, ByRef zeile As Integer) As Boolean
' Pr|fffd|ft, ob von ausschlie|fffd|lich *Zeile* noch ein Eintrag f|fffd|r das entspechende Bundesland mit dem angegebenen
' *ABundeslandIndex* existiert. Falls ja, wird die Zeilennummer in *Zeile* und TRUE zur|fffd|ckgegeben.

  If zeile < CRowDataFirst Then zeile = CRowDataFirst Else zeile = zeile + 1
  While Not IsEmpty(Cells(zeile, 1))
    If Cells(zeile, 1) = TabData.Bundeslaender(ABundeslandIndex) Then BundeslandNextLine = True: Exit Property
    zeile = zeile + 1
  Wend
  BundeslandNextLine = False
End Property



Public Sub ButtonCheckFerientage_Click()
On Error GoTo Err_ButtonCheckFerientage_Click
Dim zeile As Integer
Dim Jahr As Integer
Dim i As Integer
Dim j As Integer
Dim MustBeEmpty As Boolean
Dim HaveFound As Boolean
Dim s As String

  If MsgBox("Haben Sie hier fehlerhafte Eintr|fffd|ge gefunden oder weitere Schulferien hinzugef|fffd|gt?" & vbNewLine _
   & "Dann w|fffd|re es nett, wenn Sie uns die korrigierte bzw. erweiterte Version zur Verf|fffd|gung stellen w|fffd|rden. (Bitte kennzeichnen Sie die ge|fffd|nderten Eintr|fffd|ge.)" & vbNewLine _
   & vbNewLine _
   & "Vielen Dank daf|fffd|r!" _
   & vbNewLine _
   & "Jetzt pr|fffd|fen?", vbOKCancel Or vbQuestion, CTitleMsgBox) = vbCancel Then Exit Sub
    

  zeile = CRowDataFirst
  

  
  While (Cells(zeile, 2) <> "") Or (Cells(zeile, CColBundesland) <> "")
  
    ' FIXME Cells(Zeile, 1)
    
    ' Bundesland angegeben?
    If Cells(zeile, CColBundesland) = "" Then
      Cells(zeile, CColBundesland).Activate
      If MsgBox("Hier fehlt das Bundesland", vbExclamation Or vbOKCancel, CTitleMsgBox) = vbCancel Then Exit Sub
      HaveFound = True
    End If
    
    ' Ist die Jahresangabe eine Zahl?
    If Not IsNumeric(Cells(zeile, CColYear)) Then
      Cells(zeile, CColYear).Activate
      MsgBox "Dies ist keine Jahreszahl", vbExclamation, CTitleMsgBox
      Exit Sub
    End If
    
    ' Ist die Jahresangabe eine Ganzzahl?
    If Fix(Cells(zeile, CColYear)) <> Cells(zeile, CColYear) Then
      Cells(zeile, CColYear).Activate
      MsgBox "Dies ist keine ganze Zahl", vbExclamation, CTitleMsgBox
      Exit Sub
    Else
      Cells(zeile, CColYear).Value = CInt(Cells(zeile, CColYear))
    End If
    
    
    ' Ist die Jahresangabe >= 1900 und <= 2100?
    Jahr = Cells(zeile, CColYear)
    If (Jahr > CYearMax) Or (Jahr < CYearMin) Then
      Cells(zeile, CColYear).Activate
      If MsgBox("Dieses Jahr liegt nicht im Bereich von " & CStr(CYearMin) & " bis " & CStr(CYearMax) & "!", vbExclamation Or vbOKCancel, CTitleMsgBox) = vbCancel Then Exit Sub
      HaveFound = True
    End If
    
    
    
    'passen die Weihnachtsferien?
    If IsDate(Cells(zeile, CColXMasBegin)) And IsDate(Cells(zeile, CColXMasEnd)) Then
      DateStrToDateNumeric zeile, CColXMasBegin
      DateStrToDateNumeric zeile, CColXMasEnd
      If Cells(zeile, CColXMasEnd) >= Cells(zeile, CColXMasBegin) Then
        Cells(zeile, 3).Activate
        MsgBox "Weihnachtsferien in falscher Reihenfolge!", vbExclamation, CTitleMsgBox
        Exit Sub
      End If
    End If
        
    ' ist Beginn <= Ende?
    ' Winter: 4/5
    ' Ostern 6/7
    ' Pfingsten 8/9
    ' Sommer 10/11
    ' herbst: 12/13
    
    For i = 4 To 12 Step 2
      If IsDate(Cells(zeile, i)) And IsDate(Cells(zeile, i + 1)) Then
        DateStrToDateNumeric zeile, i
        DateStrToDateNumeric zeile, i + 1
        If Cells(zeile, i) > Cells(zeile, i + 1) Then
          Cells(zeile, i).Activate
          MsgBox "Beginn > Ende!", vbExclamation, CTitleMsgBox
          Exit Sub
        End If
      End If
    Next i
      
    ' das Jahr mu|fffd| in einer Zeile |fffd|berall gleich sein:
    For i = CColYear + 1 To CColCountHolidayDates
      If IsDate(Cells(zeile, i)) Then
        If Year(Cells(zeile, i)) <> Jahr Then
          ' Das Datum 31.12.(jahr-1) wird akzeptiert...
          If Cells(zeile, i) <> DateSerial(Jahr - 1, 12, 31) Then
            Cells(zeile, i).Activate
            If MsgBox("Das Jahr stimmt nicht!", vbExclamation Or vbOKCancel, CTitleMsgBox) = vbCancel Then Exit Sub
            HaveFound = True
          End If
        End If
      Else
        If Cells(zeile, i) <> "" Then
          If Cells(zeile, i) <> "-" Then
            If Cells(zeile, i) <> "?" Then
              Cells(zeile, i).Activate
              If MsgBox("Suspekter Eintrag", vbExclamation Or vbOKCancel, CTitleMsgBox) = vbCancel Then Exit Sub
            End If
          End If
        End If
      End If
    Next i
      
      
    MustBeEmpty = False
    For i = 15 To 15 + CColCountHolidaySingles
      If TabHolidaysAll.Cells(zeile, i) <> "" Then
        If MustBeEmpty Then
          TabHolidaysAll.Cells(zeile, i - 1).Activate
          MsgBox "Bitte hier keine L|fffd|cken lassen", vbExclamation, CTitleMsgBox
          Exit Sub
        End If
        
        If Not IsDate(TabHolidaysAll.Cells(zeile, i)) Then
          TabHolidaysAll.Cells(zeile, i).Activate
          MsgBox "Dies ist kein Datum", vbExclamation, CTitleMsgBox
          Exit Sub
        End If
        DateStrToDateNumeric zeile, i
        
        If Year(TabHolidaysAll.Cells(zeile, i)) <> Jahr Then
          TabHolidaysAll.Cells(zeile, i).Activate
          MsgBox "Das Jahr stimmt nicht!", vbExclamation, CTitleMsgBox
          Exit Sub
        End If
        
      Else
        MustBeEmpty = True
      End If
    Next i
  
  
    zeile = zeile + 1
  Wend
  
  For i = 1 To zeile - 1
    For j = i + 1 To zeile - 1
      If TabHolidaysAll.Cells(i, 1) = TabHolidaysAll.Cells(j, 1) Then
        If TabHolidaysAll.Cells(i, 2) = TabHolidaysAll.Cells(j, 2) Then
          TabHolidaysAll.Cells(j, 1).Select
          MsgBox "Doppelter Zeilen-Eintrag!", vbExclamation, CTitleMsgBox
          Exit Sub
        End If
      End If
    Next j
  Next i
      
  
  If HaveFound Then s = " weiteren" Else s = ""
  MsgBox "Keine" & s & " offensichtlichen Fehler gefunden", vbInformation, CTitleMsgBox
  GoTo Exit_ButtonCheckFerientage_Click

Err_ButtonCheckFerientage_Click:
  MsgBox Err.Description
  Resume Next
  

Exit_ButtonCheckFerientage_Click:

End Sub



Public Sub Clear()
  HolidayReleaseDateClear
  Range(Cells(CRowDataFirst, CColDataFirst), Cells(CRowDataFirst, CColDataFirst).SpecialCells(xlLastCell)).ClearContents
End Sub



Public Function ColDataLast() As Long
  ColDataLast = TabHolidays.ColDataLast
End Function



Private Sub Complain(Optional ByVal PostText As String)
  MsgBox "Dies ist keine g|fffd|ltige Feriendefinionsdatei!" & vbNewLine _
    & "Import wird nicht durchgef|fffd|hrt." & PostText, vbCritical, CTitleMsgBox
End Sub



Private Function DateStrToDateNumeric(ByVal ARow As Byte, ByVal ACol As Byte)
' ggf. in Textform vorliegendes Datum in in numerisches Datum umwandeln:
  Cells(ARow, ACol).Value = CDate(Cells(ARow, ACol))
 
' Zum Debuggen:
' behandelte Zellen markieren:
'  With Cells(aRow, ACol).Interior
'    .ColorIndex = 4
'    .Pattern = xlSolid
'    .PatternColorIndex = xlAutomatic
'  End With
  

End Function


Public Property Get HolidayReleaseDate() As Date
  HolidayReleaseDate = Cells(CRowHolydayReleaseDate, CColHolydayReleaseDate)
End Property


Public Property Let HolidayReleaseDate(ByVal NewHolidayReleaseDate As Date)
  Cells(CRowHolydayReleaseDate, CColHolydayReleaseDate).Value = NewHolidayReleaseDate
End Property


Private Sub HolidayReleaseDateClear()
  Cells(CRowHolydayReleaseDate, CColHolydayReleaseDate).ClearContents
End Sub


Public Function HolidayArray(ByVal ABundeslandIndex As Byte, ByVal AYear As Integer)
Dim zeile As Integer

  zeile = JahresZeile(ABundeslandIndex, AYear)
  If zeile <= 0 Then Exit Function
  Let HolidayArray = FerienArrayGet(Me, zeile, CColYear + 1)
End Function


Sub ImportFerien(ByVal Filename As String)
Const CMagic = "Content=Feriendefinionen Jahreskalender"
Const CDateDesc = "Date="
Const CDisplay = "Display="
Const CTitleMsgBox = "Feriendefinitionen importieren"
Const CVersionDesc = "Version="
Const CMaxValidFileVersion = 0

Dim line As String
Dim Version As Byte
Dim zeile As Integer
Dim spalte As Integer
Dim i As Long
Dim s As String
Dim v As Variant
Dim DateStr As String
Dim DisplayStr As String
Dim Ask4ImportPreStr As String

On Error GoTo Err_ImportFerien

  UpdateBegin
  Open Filename For Input As #1
  
  '********************* Magic ***********************
  ImportFerienNextLine line
  If line <> CMagic Then Complain: GoTo exit_ImportFerien
  
  
  '********************* Datum ***********************
  ImportFerienNextLine line
  If Left(line, Len(CDateDesc)) <> CDateDesc Then Complain: GoTo exit_ImportFerien
  DateStr = Right(line, Len(line) - Len(CDateDesc))
  If Not IsDate(DateStr) Then
    Complain vbNewLine & "(Ist m|fffd|glicherweise das Datumsformat nicht auf TT.MM.JJJJ eingestellt?)"
    GoTo exit_ImportFerien
  End If
  If CDate(DateStr) <= HolidayReleaseDate Then
    Ask4ImportPreStr = "Die Feriendefinionsdatei vom " & DateStr & " ist nicht neuer als die zur Zeit benutzte. Trotzdem"
  Else
    Ask4ImportPreStr = "Die Feriendefinionsdatei vom " & DateStr
  End If
  
  '********************* Version ***********************
  ImportFerienNextLine line
  If Left(line, Len(CVersionDesc)) <> CVersionDesc Then Complain: GoTo exit_ImportFerien
  s = Right(line, Len(line) - Len(CVersionDesc))
  If Not IsNumeric(s) Then Complain: GoTo exit_ImportFerien
  Version = CInt(s)
  If Version > CMaxValidFileVersion Then MsgBox "Die vorliegende Dateiformatversion " & s & " ist unbekannt. " _
    & "Wahrscheinlich ist diese Version (" & CVersionStr & ") des Kalender-Excels zu alt. " & vbNewLine _
    & "Import wird nicht durchgef|fffd|hrt.", vbCritical, CTitleMsgBox: GoTo exit_ImportFerien
    
  '********************* Anzeigetext ***********************
  ImportFerienNextLine line
  If Left(line, Len(CDisplay)) <> CDisplay Then Complain: GoTo exit_ImportFerien
  DisplayStr = Right(line, Len(line) - Len(CDisplay))
  If DisplayStr <> "" Then MsgBox DisplayStr, vbInformation, CTitleMsgBox
    
    
  'los gehts:
  If MsgBox(Ask4ImportPreStr & " einlesen?", vbYesNo Or vbQuestion, CTitleMsgBox) = vbNo Then GoTo exit_ImportFerien
  
  
  Me.Clear
  'GoTo exit_ImportFerien
  
  zeile = CRowDataFirst
  While ImportFerienNextLine(line)
    spalte = 1
    i = 1
    'While NextItem(line, v, i)
    While TokenNext(line, Asc(";"), s, i, False)
      If IsDate(s) Then
        TabHolidaysAll.Cells(zeile, spalte).Value = CDate(s)
      Else
        TabHolidaysAll.Cells(zeile, spalte) = s
      End If
      spalte = spalte + 1
      i = i + 1
    Wend
    zeile = zeile + 1
  Wend
  
  'TabHolidaysAll.Cells(1, 1) = CDate(DateStr)
  HolidayReleaseDate = CDate(DateStr)
  
  If zeile - CRowDataFirst = 1 Then s = " Zeile " Else s = " Zeilen "
  If MsgBox(CStr(zeile - CRowDataFirst) & s & "importiert." & vbNewLine _
    & "M|fffd|chten Sie nun mit 'Ferien nachschlagen' Ihre Feriendefinitionen korrigieren oder erweitern? (empfohlen)", vbQuestion Or vbYesNo, CTitleMsgBox) = vbYes Then
    FormHolidaySelect.Show
  End If
  
  GoTo exit_ImportFerien
  
Err_ImportFerien:
  MsgBox Err.Description, vbCritical, CTitleMsgBox
  Resume exit_ImportFerien
  
exit_ImportFerien:
  Close #1
  UpdateEnd
End Sub




Private Function ImportFerienNextLine(ByRef line As String) As Boolean
Dim s As String
  
  ImportFerienNextLine = True
  While Not EOF(1)
    Line Input #1, line
    line = Trim(line)
    If line <> "" Then
      If Left(line, 1) <> "#" Then Exit Function
    End If
  Wend
  ImportFerienNextLine = False
End Function



Public Property Get Items(ByVal ABundeslandIndex As Byte, ByVal AYear As Integer, ByVal Index As Byte) As Variant
Dim i As Integer
Dim count As Integer
Dim ABundeslandStr As String
Dim zeile As Integer

  zeile = JahresZeile(TabData.Bundeslaender(ABundeslandIndex), AYear)
  If zeile <= 0 Then Items = Null: Exit Property
  Items = Cells(zeile, CColYear + 1 + Index)
End Property


Public Property Get ItemsCount(ByVal ABundeslandIndex As Byte, ByVal AYear As Integer) As Byte
Dim i As Integer
Dim count As Integer
Dim ABundeslandStr As String
Dim zeile As Integer

  ABundeslandStr = TabData.Bundeslaender(ABundeslandIndex)
  zeile = JahresZeile(ABundeslandStr, AYear)
  If zeile <= 0 Then ItemsCount = 0: Exit Property
  i = CColYear + 1
  While Cells(zeile, i) <> ""
    count = count + 1
    i = i + 1
  Wend
  ItemsCount = count
End Property


Public Property Get Jahr(ByVal zeile As Integer) As Integer
  Jahr = Cells(zeile, CColYear)
End Property




Public Property Get JahresZeile(ByVal ABundeslandIndex As Byte, ByVal AYear As Integer) As Integer
Dim i As Integer
  
  i = CRowDataFirst
  While (Cells(i, CColBundesland) <> "")
    If Cells(i, CColBundesland) = TabData.Bundeslaender(ABundeslandIndex) Then
      If Jahr(i) = AYear Then
        JahresZeile = i
        Exit Property
      End If
    End If
    i = i + 1
  Wend
  
  JahresZeile = -1
  
End Property



' Public Sub SaveToOpenIniFile()
' Ist f|fffd|r Feriendaten nicht n|fffd|tig, da frische Kalender-Excel |fffd|ber aktuelle Feriendefinitionen verf|fffd|gen
' und weiterhin ein Online-Update jederzeit m|fffd|glich ist.



Public Property Get Years(ByVal ABundeslandIndex As Byte, ByVal Index As Byte) As Integer
Dim zeile As Integer
  
  While BundeslandNextLine(ABundeslandIndex, zeile)
    If Index = 0 Then
      Years = Jahr(zeile)
      Exit Property
    End If
    Index = Index - 1
  Wend
    
End Property


Public Property Get YearsCount(ByVal ABundeslandIndex As Byte) As Integer
Dim zeile As Integer
Dim count As Integer
  
  While BundeslandNextLine(ABundeslandIndex, zeile)
    count = count + 1
  Wend
  YearsCount = count
End Property




























Attribute VB_Name = "TabInfos"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Control = "ComboBoxBundeslaender, 3, 0, MSForms, ComboBox"
Attribute VB_Control = "ButtonPublics, 5, 1, MSForms, CommandButton"
Attribute VB_Control = "ButtonHolidays, 6, 2, MSForms, CommandButton"
Attribute VB_Control = "ButtonYearly, 7, 3, MSForms, CommandButton"
Attribute VB_Control = "ButtonCyclic, 8, 4, MSForms, CommandButton"
Attribute VB_Control = "ButtonCreateCalendar, 9, 5, MSForms, CommandButton"
Attribute VB_Control = "ButtonSettings, 10, 6, MSForms, CommandButton"
Attribute VB_Control = "ButtonShowinfo, 11, 7, MSForms, CommandButton"
Attribute VB_Control = "ButtonGotoWeb, 12, 8, MSForms, CommandButton"
Attribute VB_Control = "ButtonGotoForum, 13, 9, MSForms, CommandButton"
Attribute VB_Control = "ButtonUpdates, 14, 10, MSForms, CommandButton"
Attribute VB_Control = "ButtonLicence, 15, 11, MSForms, CommandButton"
Attribute VB_Control = "ButtonImportExport, 20, 12, MSForms, CommandButton"
Option Explicit


Const COffsetCol As Byte = 0 ' wie viele Spalten bleiben links frei?
Const COffsetRow As Byte = 2 ' wie viele Zeilen bleiben oben frei?

Const CColData   As Byte = 4

Const CRowTabSelectionCodeUse           As Byte = 10
Const CRowAutoopenShow                  As Byte = 11
Const CRowShowMessageOverwriteWarning   As Byte = 12


Const CZeileErsterDesMonats As Byte = 2     ' In welcher Zeile soll jeweils der Erste des Monats eingetragen werden? Mu|fffd| gr|fffd||fffd|er als 1 sein.
Const CZeileMonatsBenennungen As Byte = CZeileErsterDesMonats - 1   ' In welcher Zeile sollen jeweils die Monatsbenennungen eingetragen werden?
 

' Angaben der verschiedenen Eintragsfelder relativ zum Monat:
Const CDatumsspalte As Byte = 0       ' Datum (z.B. "01 Mo")
Const CTextspalte As Byte = 1         ' Feiertags-/j|fffd|hliche Eintr|fffd|ge
Const CKWSpalte = 1
Const CZyklusSpalte = 2



Private Const CIniValueName_AutoopenShow                    As String = "AutoopenShow"
Private Const CIniValueName_DoShowMessageOverwriteWarning   As String = "DoShowMessageOverwriteWarning"
Private Const CIniValueName_TabselectionCodeUse             As String = "TabselectionCodeUse"



Private Function AlleMonatsspalten(DestTable As Worksheet, ByVal AColumn As Byte, ByVal AMonthsCount As Byte) As Range
' Liefert *AMonthsCount* Spalten aus der Tabelle *Kalenderjahr*, die jeweils
' den Abstand *CColsPerMonth* haben (also alle Spalten mit Datum oder alle Spalten mit Text
' oder alle Spalten mit ...

Dim ber As Range
Dim i As Integer, ZeilenBeginn As Integer, spalte As Integer

  ZeilenBeginn = Tag2Zeile(1)
  
  spalte = COffsetCol + AColumn + 1
  Set ber = DestTable.Range(DestTable.Cells(ZeilenBeginn, spalte), DestTable.Cells(ZeilenBeginn + 30, spalte))
  For i = 1 To AMonthsCount - 1
    spalte = COffsetCol + CColsPerMonth * i + AColumn + 1
    Set ber = Union(ber, DestTable.Range(DestTable.Cells(ZeilenBeginn, spalte), DestTable.Cells(ZeilenBeginn + 30, spalte)))
  Next i
  Set AlleMonatsspalten = ber
End Function


Public Property Get AutoopenShow() As Boolean
  AutoopenShow = TabData.StrIsYesStr(Cells(CRowAutoopenShow, CColData))
End Property


Public Property Let AutoopenShow(ByVal NewAutoopenShow As Boolean)
  If NewAutoopenShow = AutoopenShow Then Exit Property
  Cells(CRowAutoopenShow, CColData) = TabData.YesNoStr(NewAutoopenShow)
End Property



Private Sub BeschriftungenEintragen(DestTable As Worksheet, ByVal DateFrom As Long, ByVal DateTo As Long, CalendarFormatIndex As Byte)
Dim ber As Range
Dim i As Integer, spalte As Integer, MonatsAnzahlLocal As Integer
Dim j As Byte

  Application.StatusBar = "Trage Beschriftungen ein..."
  
  MonatsAnzahlLocal = MonatsAnzahl(DateFrom, DateTo)
  With DestTable
    For i = 1 To MonatsAnzahlLocal
      spalte = (i - 1) * CColsPerMonth + 1
      With .Cells(CZeileMonatsBenennungen, spalte)
        .Value = DestTable.Cells(CZeileErsterDesMonats, spalte + CDatumsspalte) ' dort ist der 1. des Monats eingetragen
        .NumberFormat = TabSettings.ItemsMonatsSpalten|fffd|berschriftNumberFormat(CalendarFormatIndex)
      End With
      CopyFont TabSettings.ItemsMonatsSpalten|fffd|berschriftFont(CalendarFormatIndex), .Cells(CZeileMonatsBenennungen, spalte).Font
      For j = 0 To CColsPerMonth - 1
        CopyInterior TabSettings.ItemsMonatsSpalten|fffd|berschriftInterior(CalendarFormatIndex), .Cells(CZeileMonatsBenennungen, spalte + j).Interior, False
      Next j
      With .Range(.Cells(CZeileMonatsBenennungen, spalte), .Cells(CZeileMonatsBenennungen, spalte + CColsPerMonth - 1))
        .HorizontalAlignment = xlCenterAcrossSelection  ' "Zentrieren |fffd|ber Markierung" f|fffd|r *CColsPerMonth* Spalten einschalten
      End With
    Next i
    '.DisplayGridlines = False ' keine Anzeige der Gitternetzlinen

    ' um jeden Tag eine punktierte Linie; links und rechts eine Haarlinie
    With .Range(.Cells(CZeileErsterDesMonats, 1), .Cells(CZeileErsterDesMonats + 30, MonatsAnzahlLocal * CColsPerMonth))
      .Borders(xlTop).Weight = xlHairline
      .Borders(xlBottom).Weight = xlHairline
    End With

    ' jeden Monat mit einer d|fffd|nnen, durchgezogenen Linie umrahmen:
    For i = 1 To MonatsAnzahlLocal
      .Range( _
        .Cells(CZeileMonatsBenennungen, (i - 1) * CColsPerMonth + 1), _
        .Cells(CZeileErsterDesMonats + 31 - 1, i * CColsPerMonth)) _
        .BorderAround Weight:=xlThin
    Next i

    ' die erste Zeile mit den Beschriftungen ebenfalls mit derselben Linienart abtrennen:
    .Range(.Cells(CZeileMonatsBenennungen, 1), .Cells(CZeileMonatsBenennungen, MonatsAnzahlLocal * CColsPerMonth)).Borders(xlBottom).Weight = xlThin

  End With ' DestTable
  Application.StatusBar = ""
End Sub



Private Sub ButtonGotoForum_Click()
  URLFollow CURLForum
End Sub

Private Sub ButtonGotoWeb_Click()
  URLFollow CURLUpdates
End Sub


Private Sub ButtonCreateCalendar_Click()
On Error GoTo Err_ButtonCreateCalendar_Click
Dim TableName As String, WorkbookName As String
Dim DestTable As Worksheet
Dim CalendarFormatIndex As Byte, StartMonat As Byte
Dim Kalenderjahr As Integer

  Application.ScreenUpdating = False
  If Not FormYearSelect.Show_Modal(WorkbookName, TableName, CalendarFormatIndex) Then GoTo Exit_ButtonCreateCalendar_Click
  
  
  Set DestTable = Workbooks(WorkbookName).Worksheets(TableName)

  With AlleMonatsspalten(DestTable, CTextspalte, MonatsAnzahl(FormYearSelect.DateFrom, FormYearSelect.DateTo))
    .VerticalAlignment = TabSettings.ItemsTextVerticalAlignment(CalendarFormatIndex)
    .WrapText = True
  End With
  DatumEintragen DestTable, FormYearSelect.DateFrom, FormYearSelect.DateTo, CalendarFormatIndex
  If TabSettings.ItemsHolidaysBeforePublic(CalendarFormatIndex) Then SchulferienEintragen DestTable, FormYearSelect.DateFrom, FormYearSelect.DateTo, CalendarFormatIndex
  TageF|fffd|rben DestTable, CalendarFormatIndex, FormYearSelect.DateFrom, FormYearSelect.DateTo
  FeiertageEintragen DestTable, FormYearSelect.DateFrom, FormYearSelect.DateTo, CalendarFormatIndex
  If Not TabSettings.ItemsHolidaysBeforePublic(CalendarFormatIndex) Then SchulferienEintragen DestTable, FormYearSelect.DateFrom, FormYearSelect.DateTo, CalendarFormatIndex
  ZyklischeEintr|fffd|geBehandeln DestTable, FormYearSelect.DateFrom, FormYearSelect.DateTo, CalendarFormatIndex
  J|fffd|hrlicheEintr|fffd|geBehandeln DestTable, FormYearSelect.DateFrom, FormYearSelect.DateTo, CalendarFormatIndex
  BeschriftungenEintragen DestTable, FormYearSelect.DateFrom, FormYearSelect.DateTo, CalendarFormatIndex
  SpaltenBreitenSetzen DestTable, FormYearSelect.DateFrom, FormYearSelect.DateTo, CalendarFormatIndex
  Seiteneinrichtung DestTable, FormYearSelect.DateFrom, FormYearSelect.DateTo, CalendarFormatIndex
  KalenderwochenEintragen DestTable, FormYearSelect.DateFrom, FormYearSelect.DateTo, CalendarFormatIndex
  If TabSettings.ItemsFormatCurrentday(CalendarFormatIndex) Then FormatCurrentday DestTable, CalendarFormatIndex, MonatsAnzahl(FormYearSelect.DateFrom, FormYearSelect.DateTo)
  CheckPageBreaks DestTable

  Workbooks(WorkbookName).Activate
  DestTable.Select

  ActiveWindow.DisplayGridlines = False
  ActiveWindow.Zoom = TabSettings.ItemsZoom(CalendarFormatIndex)
  InfoCheckbox(CInfoCheckboxZeileMakeCalendar) = True
  Application.ScreenUpdating = True
  If DoShowMessageOverwriteWarning Then ShowMessageOverwriteWarning
  GoTo Exit_ButtonCreateCalendar_Click

Err_ButtonCreateCalendar_Click:
  MsgBox Err.Description, vbCritical, CTitleMsgBox
  Resume Exit_ButtonCreateCalendar_Click

Exit_ButtonCreateCalendar_Click:
  Application.ScreenUpdating = True
  
  Application.StatusBar = False

End Sub


Private Sub ButtonCyclic_Click()
  WorkSheetSelect TabCyclic, CTitleMsgBox
End Sub



Private Sub ButtonHolidays_Click()
 WorkSheetSelect TabHolidays, CTitleMsgBox
End Sub



Private Sub ButtonImportExport_Click()
  FormImportExport.Show
End Sub

Private Sub ButtonLicence_Click()
  WorkSheetSelect TabLicence, CTitleMsgBox
End Sub




Private Sub ButtonPublics_Click()
  WorkSheetSelect TabPublics, CTitleMsgBox
End Sub





Sub ButtonSettings_Click()
  WorkSheetSelect TabSettings, CTitleMsgBox
End Sub


Private Sub ButtonShowinfo_Click()
  ButtonInfoClick
End Sub



Private Sub ButtonUpdates_Click()
On Error GoTo Err_ButtonUpdates_Click
Const BINDF_GETNEWESTVERSION As Long = &H10
Const CURL = "http://www.msdatec.de/"
Const CFilenameSchulferien = "schulferien.csv"
Const CFilenameKalenderExcelVersion = "Kalender-Excel.version"
Const CFilenameSchulferienversion = CFilenameSchulferien & ".version"
Const CURL_schulferien = CURL & CFilenameSchulferien
Const CURL_schulferien_version = CURL & CFilenameSchulferienversion
Const CURL_KalenderExcel_version = CURL & CFilenameKalenderExcelVersion

Dim TempFilename As String, s  As String, VersionStr As String
Dim DateYoungest As Date
Dim ErrVal As Long


  Application.Cursor = xlWait
  Application.StatusBar = "Lade Versionsinformationen f|fffd|r Kalender-Excel herunter..."
  
  TempFilename = GetTempDir() & CFilenameKalenderExcelVersion
  If FileExists(TempFilename) Then Kill TempFilename
  
  ErrVal = DeleteUrlCacheEntry(CURL_KalenderExcel_version)
  If ErrVal <> 0 Then
    ErrVal = GetLastError
    Beep
  End If
  'ErrVal = URLDownloadToFile(0, CURL_KalenderExcel_version, TempFilename, BINDF_GETNEWESTVERSION, 0)
  ErrVal = URLDownloadToFile(0, CURL_KalenderExcel_version, TempFilename, 0, 0)
  If ErrVal <> 0 Then
    MsgBox "Beim Download der Versionsinformationen ist ein Fehler aufgetreten", vbCritical, CTitleMsgBox
    GoTo Exit_ButtonUpdates_Click
  End If
  Application.StatusBar = "Lese Versionsinformationen f|fffd|r Kalender-Excel..."
  Open TempFilename For Input As #1
  Line Input #1, s
  If val(s) >= CVersionMain Then
    VersionStr = s
    Line Input #1, s
    VersionStr = VersionStr & "." & s
    If IsNumeric(s) Then
      If val(s) <= val(CVersionSub) Then VersionStr = ""
    Else
      If CStr(s) <= CStr(CVersionSub) Then VersionStr = ""
    End If
  End If
  Close #1
  Kill TempFilename
  Application.StatusBar = ""
  If VersionStr = "" Then
    MsgBox "Keine aktuellere Version von Kalender-Excel verf|fffd|gbar", vbInformation, CTitleMsgBox
  Else
    If MsgBox("Die neuere Version " & VersionStr & " von Kalender-Excel steht zur Verf|fffd|gung. Allerdings kann diese nicht automatisch installiert werden." & vbNewLine _
      & "M|fffd|chten Sie nun die Webseite zu Kalender-Excel aufrufen?", vbQuestion Or vbYesNo, CTitleMsgBox) = vbYes Then
      URLFollow CURLUpdates
    End If
  End If
  
  
  If VersionStr <> "" Then
    If MsgBox("M|fffd|chten Sie f|fffd|r Ihren vorhandenen Kalender-Excel pr|fffd|fen, ob aktuelle Schulferiendefinitionen vorhanden sind?", vbQuestion Or vbYesNo, CTitleMsgBox) <> vbYes Then
      GoTo Exit_ButtonUpdates_Click:
    End If
  End If
  
  
  Application.StatusBar = "Lade Versionsinformationen f|fffd|r Schulferiendefinitionen herunter..."
  TempFilename = GetTempDir() & CFilenameSchulferienversion
  If FileExists(TempFilename) Then Kill TempFilename
  
  
  ErrVal = URLDownloadToFile(0, CURL_schulferien_version, TempFilename, BINDF_GETNEWESTVERSION, 0)
  If ErrVal <> 0 Then
    MsgBox "Beim Download der Versionsinformationen ist ein Fehler aufgetreten", vbCritical, CTitleMsgBox
    GoTo Exit_ButtonUpdates_Click
  End If
  Application.StatusBar = "Lese Versionsinformationen f|fffd|r Schulferiendefinitionen..."
  Open TempFilename For Input As #1
  If Not EOF(1) Then Line Input #1, s
  Close #1
  Kill TempFilename
  DateYoungest = DateSerial(Left(s, 2), Mid(s, 3, 2), Right(s, 2))
  Application.StatusBar = ""
  If TabHolidaysAll.HolidayReleaseDate < DateYoungest Then
    If MsgBox("Eine neuere Version der Schulferiendefinitionen vom " & DateYoungest & " steht zur Verf|fffd|gung. Soll diese nun heruntergeladen und importiert werden?", vbQuestion Or vbYesNo, CTitleMsgBox) = vbYes Then
      TempFilename = GetTempDir() & CFilenameSchulferien
      If FileExists(TempFilename) Then Kill TempFilename
      ErrVal = URLDownloadToFile(0, CURL_schulferien, TempFilename, BINDF_GETNEWESTVERSION, 0)
      If ErrVal <> 0 Then
        MsgBox "Beim Download der Schulferiendefinitionsdatei " & CURL_schulferien & " ist ein Fehler aufgetreten", vbCritical, CTitleMsgBox
        GoTo Exit_ButtonUpdates_Click
      End If
      TabHolidaysAll.ImportFerien TempFilename
      Kill TempFilename
    End If
  Else
    MsgBox "Keine aktuellere Version der Schulferiendefinitionen verf|fffd|gbar", vbInformation, CTitleMsgBox
  End If
  
    
  
  GoTo Exit_ButtonUpdates_Click
  
  
Err_ButtonUpdates_Click:
  s = Err.Description
  If Err.Number = 75 Then s = s & " '" & TempFilename & "'"
  MsgBox "Fehler " & CStr(Err.Number) & ": " & s, vbCritical, CTitleMsgBox
  Resume Exit_ButtonUpdates_Click


Exit_ButtonUpdates_Click:
  Application.Cursor = xlDefault
  Application.StatusBar = ""
End Sub



Sub ButtonYearly_Click()
  WorkSheetSelect TabYearly, CTitleMsgBox
End Sub


Private Sub CheckPageBreaks(DestTable As Worksheet)

End Sub


Public Sub Clear()
  AutoopenShow = True
  DoShowMessageOverwriteWarning = True
  TabselectionCodeUse = True
End Sub



Private Sub DatumEintragen(DestTable As Worksheet, ByVal DateStart As Long, ByVal DateEnd As Long, CalendarFormatIndex As Byte)
Dim dat As Long

  Application.StatusBar = "Trage Datum ein..."
  dat = DateStart
  Do
    DestTable.Cells(Tag2Zeile(Day(dat)), Monat2Spalte(dat, DateStart)).Value = dat
    dat = dat + 1
  Loop While dat <= DateEnd

  'Bereiche formatieren:
  With AlleMonatsspalten(DestTable, CDatumsspalte, (Year(DateEnd) - Year(DateStart) - 1) * 12 + 12 - Month(DateStart) + Month(DateEnd) + 1)
    .NumberFormat = TabSettings.ItemsDatumNumberFormat(CalendarFormatIndex)
    ' entf|fffd|llt durch die Font-|fffd|bertragung der Wochentage: CopyFont TabSettings.DatumFont(CalendarFormatIndex), .Font
    .HorizontalAlignment = xlLeft
    .VerticalAlignment = TabSettings.ItemsDatumVerticalAlignment(CalendarFormatIndex)
    .WrapText = False
    .Orientation = xlHorizontal
  End With
  Application.StatusBar = ""
End Sub


Private Sub ComboBoxBundeslaender_Change()
On Error GoTo Err_ComboBoxBundeslaender_Change
Dim ChoosenBundesLandIndex As Byte
Dim OldScreenUpdating As Boolean, DefaultFeiertage As Boolean, DefaultFerientage As Boolean
Dim s As String


  OldScreenUpdating = Application.ScreenUpdating
  Application.ScreenUpdating = False
  InfoCheckbox(CInfoCheckboxZeileBundesland) = True

  If ComboBoxBundeslaender.Listindex + 1 = TabData.BundeslandIndex Then Exit Sub
  ChoosenBundesLandIndex = ComboBoxBundeslaender.Listindex + 1
  If TabData.BundeslandIndex <> 0 Then  ' schon ein Eintrag vorhanden?
    ' Zun|fffd|chst die Pr|fffd|fung, ob die bisherigen Feiertags- und Ferieneinstellungen dem Standard entsprechen:
    DefaultFeiertage = TabPublics.DefaultHave(TabData.BundeslandIndex)
    DefaultFerientage = TabHolidays.DefaultHave(TabData.BundeslandIndex)
    s = ""
    If Not DefaultFeiertage Then s = "Feiertags"
    If Not DefaultFerientage Then
      If s <> "" Then s = s & "- und "
      s = s & "Ferien"
    End If
    If s <> "" Then
      If MsgBox("Damit |fffd|berschreiben Sie Ihre bisherigen " & s & "einstellungen. Fortfahren?", _
        vbYesNo Or vbQuestion, CTitleMsgBox) = vbNo Then
          ' den vorherigen Bundesland-Eintrag wiederherstellen:
          ComboBoxBundeslaender.Listindex = TabData.BundeslandIndex - 1
          GoTo Exit_ComboBoxBundeslaender_Change
      End If
    End If
  End If
  TabData.BundeslandIndex = ChoosenBundesLandIndex


Exit_ComboBoxBundeslaender_Change:
  Application.ScreenUpdating = OldScreenUpdating
  Exit Sub

Err_ComboBoxBundeslaender_Change:
  MsgBox Err.Description, vbCritical, CTitleMsgBox
  Resume Exit_ComboBoxBundeslaender_Change

End Sub



Public Property Get DoShowMessageOverwriteWarning() As Boolean
  DoShowMessageOverwriteWarning = TabData.StrIsYesStr(Cells(CRowShowMessageOverwriteWarning, CColData))
End Property


Public Property Let DoShowMessageOverwriteWarning(NewShowMessageOverwriteWarning As Boolean)
  Cells(CRowShowMessageOverwriteWarning, CColData) = TabData.YesNoStr(NewShowMessageOverwriteWarning)
End Property






Private Sub FeiertageEintragen(DestTable As Worksheet, ByVal DateFrom As Long, ByVal DateTo As Long, ByVal CalendarFormatIndex As Byte)
Dim i As Integer
Dim AInterior As Interior
Dim ADate As Long
Dim DestCol As Byte
Dim DestRow As Byte
Dim s As String
Dim Kalenderjahr As Integer


  Application.StatusBar = "Trage Feiertage ein..."

  'Set AInterior = TabPublics.Interior
  Set AInterior = TabSettings.ItemsPublicdayInterior(CalendarFormatIndex)
  
  For Kalenderjahr = Year(DateFrom) To Year(DateTo)
    For i = 0 To TabPublics.ItemsCount - 1
      If TabPublics.ItemsDoDisplayText(i) Then
        If TabPublics.ItemsDate(i, Kalenderjahr) >= DateFrom Then
          If TabPublics.ItemsDate(i, Kalenderjahr) <= DateTo Then
            ADate = TabPublics.ItemsDate(i, Kalenderjahr)
            DestCol = Monat2Spalte(ADate, DateFrom)
            DestRow = Tag2Zeile(Day(ADate))
            If TabPublics.ItemsIsPublic(i) Then SetzeTagesfarbe DestRow, DestCol, DestTable, AInterior, False
            SetzeFont DestRow, DestCol + CTextspalte, DestTable, TabPublics.Font, TabSettings.ItemsTextVerticalAlignment(CalendarFormatIndex), TabSettings.ItemsTextScale(CalendarFormatIndex)
            s = DestTable.Cells(DestRow, DestCol + CTextspalte).Formula
            If s <> "" Then s = s + ", "
            DestTable.Cells(DestRow, DestCol + CTextspalte).Formula = s + TabPublics.ItemsText(i)
          End If
        End If
      End If
    Next i
  Next Kalenderjahr
  Application.StatusBar = ""
End Sub



Private Sub FormatCurrentdayColumn(DestTable As Worksheet, ByVal AColumn As Byte, ByVal AMonthsCount As Byte, AFormula As String, AInterior As Interior)
  Application.StatusBar = "Setze Format f|fffd|r Darstellung des aktuellen Tages..."
  
  With AlleMonatsspalten(DestTable, AColumn, AMonthsCount)
    .FormatConditions.Delete
    .FormatConditions.Add Type:=xlExpression, Formula1:=AFormula
    CopyInterior AInterior, .FormatConditions(1).Interior, False
  End With
  Application.StatusBar = ""
End Sub


Private Sub FormatCurrentday(DestTable As Worksheet, ByVal CalendarFormatIndex As Byte, ByVal AMonthsCount As Byte)
  FormatCurrentdayColumn DestTable, CDatumsspalte, AMonthsCount, "=ZS=HEUTE()", TabSettings.ItemsCurrentdayInterior(CalendarFormatIndex)
  FormatCurrentdayColumn DestTable, CTextspalte, AMonthsCount, "=ZS(-1)=HEUTE()", TabSettings.ItemsCurrentdayInterior(CalendarFormatIndex)
  FormatCurrentdayColumn DestTable, CZyklusSpalte, AMonthsCount, "=ZS(-2)=HEUTE()", TabSettings.ItemsCurrentdayInterior(CalendarFormatIndex)
End Sub


Public Property Get InfoCheckbox(ByVal zeile As Byte) As Boolean
  InfoCheckbox = Cells(zeile, 2) = "|fffd|"
End Property



Public Property Let InfoCheckbox(ByVal zeile As Byte, ByVal NewVal As Boolean)
On Error GoTo Err_InfoCheckbox
Dim OldApplicationScreenUpdating As Boolean, WasProtected As Boolean
  
  If NewVal = InfoCheckbox(zeile) Then Exit Property
  If Not UnprotectCalendarWorksheet(Me, "", WasProtected) Then Exit Property
  
  OldApplicationScreenUpdating = Application.ScreenUpdating
  Application.ScreenUpdating = False
  If NewVal Then
    Cells(zeile, 2) = "|fffd|"
  Else
    Cells(zeile, 2) = "|fffd|"
  End If
  If zeile = CInfoCheckboxZeileLicence Then
    TabInfos.ComboBoxBundeslaender.Enabled = NewVal
    ButtonPublics.Enabled = NewVal
    ButtonHolidays.Enabled = NewVal
    ButtonYearly.Enabled = NewVal
    ButtonCyclic.Enabled = NewVal
    ButtonCreateCalendar.Enabled = NewVal
    ButtonSettings.Enabled = NewVal
  End If
  
  GoTo Exit_InfoCheckbox
  
Err_InfoCheckbox:
  MsgBox Err.Description, vbCritical, CTitleMsgBox
  Resume Next
  GoTo Exit_InfoCheckbox

Exit_InfoCheckbox:
  Application.ScreenUpdating = OldApplicationScreenUpdating
  If WasProtected Then Protect
End Property





Sub J|fffd|hrlicheEintr|fffd|geBehandeln(DestTable As Worksheet, ByVal DateFrom As Long, ByVal DateTo As Long, ByVal CalendarFormatIndex As Byte)
'Dim ADay As Byte
'Dim aMonth As Byte
'Dim ACaption As String
'Dim AFont As Font
'Dim aFontSize As Single
Dim DestCol As Byte
Dim DestRow As Byte
Dim i As Byte
Dim j As Integer
Dim Kalenderjahr As Integer
Dim CurrDate As Long


  For Kalenderjahr = Year(DateFrom) To Year(DateTo)
    For j = 0 To TabYearly.ItemsCount - 1
      If TabYearly.ItemsDoShow(j) Then
        If TabYearly.ItemsCheck(j, True) = 0 Then
          If TabYearly.ItemsYearMatches(j, Kalenderjahr) Then
            CurrDate = DateSerial(Kalenderjahr, TabYearly.ItemsMonth(j), TabYearly.ItemsDay(j))
            If (CurrDate >= DateFrom) And (CurrDate <= DateTo) Then
              DestCol = Monat2Spalte(CurrDate, DateFrom) + CTextspalte
              DestRow = Tag2Zeile(TabYearly.ItemsDay(j))
            ' Bei verbundenen Zellen klappt die optimale H|fffd|he nicht... Code zum Verbinden zum Zellen rausgeworfen

              i = Len(DestTable.Cells(DestRow, DestCol).Text)
              If i <> 0 Then
                With DestTable.Cells(DestRow, DestCol).Characters(i + 1, Len(TabSettings.ItemsDelimiterStr(CalendarFormatIndex)))
                  .Text = TabSettings.ItemsDelimiterStr(CalendarFormatIndex)
                  CopyFont TabSettings.ItemsDelimiterFont(CalendarFormatIndex), .Font
                End With
              End If
    
              i = Len(DestTable.Cells(DestRow, DestCol).Text)
    
              With DestTable.Cells(DestRow, DestCol).Characters(i + 1, Len(TabYearly.ItemsCaption(j)))
                .Text = TabYearly.ItemsCaption(j)
                CopyFont TabYearly.ItemsFont(j), .Font
                .Font.Size = TabSettings.ItemsTextScale(CalendarFormatIndex) * TabYearly.ItemsFontSize(j)
              End With
            End If
          End If
        End If
      End If
    Next j
  Next Kalenderjahr
End Sub


Private Sub KalenderwochenBeginnMontag(ByVal Kalenderjahr As Integer, ByRef Kalenderwoche As Byte, ByRef MondayFirstKW As Long)
' Ermittelt f|fffd|r das angegebene *Kalenderjahr* den Montag der ersten Kalenderwoche und gibt dieses Datum in *MondayFirstKW* zur|fffd|ck.
' *KW* enth|fffd|lt die entsprechende Kalenderwoche (1 oder 2)
Dim FirstDayOfYear As Long

  FirstDayOfYear = DateSerial(Kalenderjahr, 1, 1)
  MondayFirstKW = FirstDayOfYear
  While Weekday(MondayFirstKW) <> vbMonday
    MondayFirstKW = MondayFirstKW + 1
  Wend

  If MondayFirstKW - FirstDayOfYear < 4 Then Kalenderwoche = 1 Else Kalenderwoche = 2

End Sub

Private Sub KalenderwochenEintragen(DestTable As Worksheet, ByVal DateFrom As Long, ByVal DateTo As Long, ByVal CalendarFormatIndex As Byte)
' Aus den Weiten des www:
'---8<---
'F|fffd|r die Wochenz|fffd|hlung nach DIN, welche seit 1972 konsequent angewendet
'wird, gilt folgende Norm: |fffd|Bei der Nummerierung der Kalenderwochen z|fffd|hlt
'als erste Kalenderwoche eines Kalenderjahres diejenige Woche, in die die
'ersten vier oder mehr Januartage fallen|fffd|. Die erste Kalenderwoche eines
'Kalenderjahres ist also diejenige, die den ersten Donnerstag des
'Kalenderjahres enth|fffd|lt.
'---8<---
' Bleibt noch die Frage, mit welchem Wochentag die Woche beginnt: Hier
' wird *Montag* unterstellt

Dim CurrDate As Long
Dim zeile As Integer, spalte As Integer, CurrYear As Integer
Dim i As Byte, KW As Byte
Dim s As String, PreStr As String, PostStr As String
Dim UseNumber As Boolean, KWFill As Boolean
Dim KWShape As Shape
Dim DistLeft As Single, DistTop As Single
Dim KWShapeVorlage As Shape

  Application.StatusBar = "Trage Kalenderwochen ein..."
  If Not TabSettings.ItemsKWUse(CalendarFormatIndex) Then GoTo Exit_KalenderwochenEintragen
  
   
  If Not TabSettings.ItemsShapeHave(CalendarFormatIndex) Then
    MsgBox "Die Kalenderwochenvorlage zum Schema " & TabSettings.ItemsCaption(CalendarFormatIndex) & " fehlt! Die Kalenderwochen werden nicht eingetragen.", vbCritical
    Exit Sub
  End If
  Set KWShapeVorlage = TabSettings.ItemsShape(CalendarFormatIndex)
  
  DistLeft = TabSettings.ItemsKWDistLeft(CalendarFormatIndex)
  DistTop = TabSettings.ItemsKWDistTop(CalendarFormatIndex)
  
  PreStr = TabSettings.ItemsKWStr(CalendarFormatIndex)
  i = InStr(1, PreStr, "#")
  If i <> 0 Then
    PostStr = Right(PreStr, Len(PreStr) - i)
    PreStr = Left(PreStr, i - 1)
    UseNumber = True
  Else
    UseNumber = False
  End If

  ' erste Woche ermitteln:
  CurrDate = DateFrom
  CurrYear = 0 ' Initialisierung in der Schleife unten erzwingen
  
  Do
    If Year(CurrDate) <> CurrYear Then
      CurrYear = Year(CurrDate)
      KalenderwochenBeginnMontag CurrYear, KW, CurrDate
    End If
    If CurrDate >= DateFrom Then
      zeile = Tag2Zeile(Day(CurrDate))
      spalte = Monat2Spalte(CurrDate, DateFrom)
    
      If UseNumber Then s = PreStr & CStr(KW) & PostStr Else s = PreStr
      
      KWShapeVorlage.Copy
      DestTable.Paste
      Set KWShape = DestTable.Shapes(DestTable.Shapes.count)
        
      KWShape.TextEffect.Text = Trim(KWShape.TextEffect.Text)
      If Len(KWShape.TextEffect.Text) <> 0 Then
        If Len(KWShape.TextEffect.Text) <> Len(s) Then
          KWShape.Width = KWShape.Width / Len(KWShape.TextEffect.Text) * Len(s)
        End If
      End If
        
      KWShape.TextEffect.Text = s
      KWShape.Left = DestTable.Cells(zeile, spalte).Columns.Left + DistLeft
      KWShape.Top = DestTable.Cells(zeile, spalte).Rows.Top + DistTop
        
      If KWShape.BottomRightCell.Row > CZeileErsterDesMonats + 31 - 1 Then KWShape.Delete
    End If

    CurrDate = CurrDate + 7
    KW = KW + 1
    'If KW > 52 Then
    '  FirstDayOfYear = DateSerial(Kalenderjahr + 1, 1, 1)
    '  If FirstDayOfYear - dat <= 3 Then KW = 1 ' also 4 oder mehr Tage im n|fffd|chsten Jahr
    'End If
  Loop While CurrDate <= DateTo




Exit_KalenderwochenEintragen:
  DestTable.Cells(1, 1).Select
  Application.StatusBar = ""
End Sub





Public Sub MakeDist()
  Clear
  InfoCheckbox(CInfoCheckboxZeileLicence) = False
  InfoCheckbox(CInfoCheckboxZeileBundesland) = False
  InfoCheckbox(CInfoCheckboxZeileFeiertage) = False
  InfoCheckbox(CInfoCheckboxZeileSchulferien) = False
  InfoCheckbox(CInfoCheckboxZeileYearly) = False
  InfoCheckbox(CInfoCheckboxZeileCyclic) = False
  InfoCheckbox(CInfoCheckboxZeileMakeCalendar) = False
  ComboBoxBundeslaender.Listindex = -1
  Cells(CRowTabSelectionCodeUse, CColData).Select
  If Not Me.ProtectContents Then Protect
End Sub


Private Function MonatsAnzahl(ByVal DateStart As Long, ByVal DateEnd As Long) As Integer
  MonatsAnzahl = (Year(DateEnd) - Year(DateStart) - 1) * 12 + 12 - Month(DateStart) + Month(DateEnd) + 1
End Function


Private Function Monat2Spalte(ByVal ADate As Long, ByVal DateStart As Long) As Integer
' Gibt die erste der Spaltennummern zur|fffd|ck, die f|fffd|r den Monat von *ADate* vorgesehen ist.
' Die Z|fffd|hlung der Spalten beginnt bei 1.
  Monat2Spalte = (MonatsAnzahl(DateStart, ADate) - 1) * CColsPerMonth + 1
End Function


Private Function RoundToLowerQuarter(ByVal Zahl As Single) As Single
Dim Rest As Single

  Rest = Zahl - Int(Zahl)
  Zahl = Int(Zahl)
  If Rest > 0.75 Then RoundToLowerQuarter = Zahl + 0.75 _
  Else _
    If Rest > 0.5 Then RoundToLowerQuarter = Zahl + 0.5 _
    Else
      If Rest > 0.25 Then RoundToLowerQuarter = Zahl + 0.25 _
      Else: RoundToLowerQuarter = Zahl
End Function






Private Sub SchulferienEintragenRange(AWorkSheet As Worksheet, ByVal DateCalendarStart As Long, ByVal DateCalendarEnd As Long, ByVal DateSchulferienFrom As Long, ByVal DateSchulferienUntil As Long, ByVal AInterior As Interior)
Dim ADate As Long
  While (DateSchulferienFrom <= DateSchulferienUntil)
    If DateSchulferienFrom >= DateCalendarStart Then
      If DateSchulferienFrom <= DateCalendarEnd Then
        SetzeTagesfarbeVonDatum DateSchulferienFrom, DateCalendarStart, AWorkSheet, AInterior, False
      End If
    End If
    DateSchulferienFrom = DateSchulferienFrom + 1
  Wend
End Sub


Private Sub SchulferienEintragen(DestTable As Worksheet, ByVal DateFrom As Long, ByVal DateTo As Long, ByVal CalendarFormatIndex As Byte)
Dim i As Integer
Dim Feriendata
Dim AInterior As Interior

  Application.StatusBar = "Trage Schulferien ein..."
  Feriendata = TabHolidays.Ferien(DateFrom, DateTo)

  If Not IsEmpty(Feriendata) Then
    For i = LBound(Feriendata, 2) To UBound(Feriendata, 2)
      Set AInterior = TabSettings.ItemsHolidaysInterior(CalendarFormatIndex)
      SchulferienEintragenRange DestTable, DateFrom, DateTo, Feriendata(0, i), Feriendata(1, i), AInterior
    Next i
    Feriendata = Null
  End If


ExitSub:
  Application.StatusBar = ""
End Sub


Function SeiteneinrichtungGetRowHeightMin(DestTable As Worksheet) As Single
Dim sng As Single
Dim i As Byte

  sng = 3.402823E+38
  For i = CZeileErsterDesMonats To CZeileErsterDesMonats - 1 + 31
    If DestTable.Rows(i).RowHeight < sng Then sng = DestTable.Rows(i).RowHeight
  Next i
  SeiteneinrichtungGetRowHeightMin = sng
End Function



Function SeiteneinrichtungZeilenHoehe(DestTable As Worksheet, ByVal LineHeight As Single, ByVal DoAutoFit As Boolean) As Boolean
Dim i As Byte

  SeiteneinrichtungZeilenHoehe = False
  For i = CZeileErsterDesMonats To CZeileErsterDesMonats - 1 + 31
    If DoAutoFit Then DestTable.Rows(i).AutoFit
    If DestTable.Rows(i).RowHeight < LineHeight Then
      DestTable.Rows(i).RowHeight = LineHeight
      SeiteneinrichtungZeilenHoehe = True
    End If
  Next i

End Function



Sub Seiteneinrichtung(DestTable As Worksheet, ByVal DateFrom As Long, ByVal DateTo As Long, ByVal CalendarFormatIndex As Byte)
On Error GoTo Err_Seiteneinrichtung
Const CStr_RichteSeiteEin = "Richte Seite ein: "
Dim i As Integer, j As Integer, MonthCount As Integer
Dim zeile As Byte, spalte As Byte, CurrentView As Byte
Dim MinLineHeight As Single
Dim LineHeight As Single
Dim BundeslandStr As String



  BundeslandStr = TabData.Bundeslaender(TabData.BundeslandIndex)
  With DestTable
    With .PageSetup
      Application.StatusBar = CStr_RichteSeiteEin & "R|fffd|nder"
      .TopMargin = TabSettings.ItemsMargin(CalendarFormatIndex, xlTop, True)
      .BottomMargin = TabSettings.ItemsMargin(CalendarFormatIndex, xlBottom, True)
      .RightMargin = TabSettings.ItemsMargin(CalendarFormatIndex, xlRight, True)
      .LeftMargin = TabSettings.ItemsMargin(CalendarFormatIndex, xlLeft, True)

      Application.StatusBar = CStr_RichteSeiteEin & "Kopfzeile"
      
      
      .LeftHeader = SubstVars(TabSettings.ItemsHeaderStr(CalendarFormatIndex, xlLeft, False), DateFrom, DateTo, BundeslandStr)
      .CenterHeader = SubstVars(TabSettings.ItemsHeaderStr(CalendarFormatIndex, xlCenter, False), DateFrom, DateTo, BundeslandStr)
      .RightHeader = SubstVars(TabSettings.ItemsHeaderStr(CalendarFormatIndex, xlRight, False), DateFrom, DateTo, BundeslandStr)
      .HeaderMargin = TabSettings.ItemsHeaderMargin(CalendarFormatIndex, True)


      Application.StatusBar = CStr_RichteSeiteEin & "Fu|fffd|zeile"
      .LeftFooter = SubstVars(TabSettings.ItemsFooterStr(CalendarFormatIndex, xlLeft, False), DateFrom, DateTo, BundeslandStr)
      .CenterFooter = SubstVars(TabSettings.ItemsFooterStr(CalendarFormatIndex, xlCenter, False), DateFrom, DateTo, BundeslandStr)
      .RightFooter = SubstVars(TabSettings.ItemsFooterStr(CalendarFormatIndex, xlRight, False), DateFrom, DateTo, BundeslandStr)
      .FooterMargin = TabSettings.ItemsFooterMargin(CalendarFormatIndex, True)

      Application.StatusBar = CStr_RichteSeiteEin & "Ausrichtung"
      .Orientation = TabSettings.ItemsOrientationIndex(CalendarFormatIndex)
      
      Application.StatusBar = CStr_RichteSeiteEin & "Papierformat"
      i = TabSettings.ItemsPaperSizeIndex(CalendarFormatIndex)
      If i >= 0 Then _
        If i <> xlPaperUser Then .PaperSize = i
    End With ' PageSetup


    ' F|fffd|r alle Zellen, bei denen ein Texteintrag vorhanden ist und die Zyklusspalte
    ' leer ist, die Zellen zusammenfassen:
    MonthCount = MonatsAnzahl(DateFrom, DateTo)
    For i = MonthCount To 1 Step -1
      Application.StatusBar = "F|fffd|ge f|fffd|r Monat " & CStr(MonthCount - i + 1) & " leere Zykluszellen der Zelle f|fffd|r die Beschreibung hinzu"
      spalte = Monat2Spalte(DateSerial(Year(DateFrom), i + Month(DateFrom) - 1, 1), DateFrom)
      For j = 1 To 31
        zeile = Tag2Zeile(j)
        If Not IsEmpty(DestTable.Cells(zeile, spalte + CTextspalte)) Then
          If IsEmpty(DestTable.Cells(zeile, spalte + CTextspalte + 1)) Then
            LineHeight = DestTable.Rows(zeile).RowHeight
            With DestTable.Range(DestTable.Cells(zeile, spalte + CTextspalte), DestTable.Cells(zeile, spalte + CTextspalte + 1))
              .WrapText = True
              .MergeCells = True
            End With
            DestTable.Rows(zeile).RowHeight = LineHeight
          End If
        End If
      Next j
    Next i

    ' Zeilenh|fffd|hen:
    DestTable.Rows.EntireRow.AutoFit
    MinLineHeight = TabSettings.ItemsLineHeightMin(CalendarFormatIndex)

    SeiteneinrichtungZeilenHoehe DestTable, MinLineHeight, False

    If TabSettings.ItemsMaximizeLineHeight(CalendarFormatIndex) Then
      MinLineHeight = SeiteneinrichtungGetRowHeightMin(DestTable)
      While DestTable.HPageBreaks.count = 0
        MinLineHeight = MinLineHeight + 1
        Application.StatusBar = "Maximiere Zeilenh|fffd|hen: " & CStr(MinLineHeight)
        SeiteneinrichtungZeilenHoehe DestTable, MinLineHeight, False
      Wend
      
      
      
      j = 0
      For i = CZeileErsterDesMonats - 1 + 31 To DestTable.HPageBreaks(1).Location.Row
        j = j + DestTable.Rows(i).RowHeight
      Next i
      MinLineHeight = Round(4 * (MinLineHeight - j / 31)) / 4 ' kleinster Zeilenh|fffd|henwert ist 0.25
      Application.StatusBar = "Maximiere Zeilenh|fffd|hen: " & CStr(MinLineHeight)
      SeiteneinrichtungZeilenHoehe DestTable, MinLineHeight, True
      Do While DestTable.HPageBreaks.count > 0
        MinLineHeight = MinLineHeight - 0.25
        Application.StatusBar = "Maximiere Zeilenh|fffd|hen: " & CStr(MinLineHeight)
        If Not SeiteneinrichtungZeilenHoehe(DestTable, MinLineHeight, True) Then Exit Do
      Loop
    End If

'    DestTable.Rows.EntireRow.AutoFit


  End With
  GoTo Exit_Seiteneinrichtung


Err_Seiteneinrichtung:
  If Err.Number = 1004 Then
    MsgBox "Ein Problem ist bei der Seiteneinrichtung aufgetreten. M|fffd|glicherweise unterst|fffd|tzt der aktuelle Drucker das gew|fffd|nschte Papierformat nicht, oder es sind die Randeinstellungen ung|fffd|ltig.", vbInformation, CTitleMsgBox
  Else
    MsgBox Err.Description, vbCritical, CTitleMsgBox
  End If
  Resume Next


Exit_Seiteneinrichtung:
  Application.StatusBar = ""
End Sub




Private Sub SetzeTagesfarbe(ByVal zeile As Integer, ByVal spalte As Integer, AWorkSheet As Worksheet, ByVal AInterior As Interior, ByVal CopyDefaultAlso As Boolean)
  CopyInterior AInterior, AWorkSheet.Range(AWorkSheet.Cells(zeile, spalte), AWorkSheet.Cells(zeile, spalte + CColsPerMonth - 1)).Interior, CopyDefaultAlso
End Sub



Private Sub SetzeTagesfarbeVonDatum(ByVal ADate As Long, ByVal DateStart As Long, AWorkSheet As Worksheet, ByVal AInterior As Interior, ByVal CopyDefaultAlso As Boolean, Optional AFont)
Dim zeile As Integer, spalte As Integer

  zeile = Tag2Zeile(Day(ADate))
  spalte = Monat2Spalte(ADate, DateStart)
  SetzeTagesfarbe zeile, spalte, AWorkSheet, AInterior, CopyDefaultAlso
  If Not IsMissing(AFont) Then CopyFont AFont, AWorkSheet.Range(AWorkSheet.Cells(zeile, spalte), AWorkSheet.Cells(zeile, spalte + CColsPerMonth - 1)).Font
  'CopyInterior AInterior, AWorkSheet.Range(AWorkSheet.Cells(Zeile, Spalte), AWorkSheet.Cells(Zeile, Spalte + CColsPerMonth - 1)).Interior, CopyDefaultAlso
End Sub




Sub ShowMessageOverwriteWarning()
  MsgBox "Fertig." & vbNewLine _
    & "Achtung: Sie k|fffd|nnen den erstellen Kalender manuell ver|fffd|ndern. Dies hat jedoch " _
    & "keinen Einfluss auf die n|fffd|chste Kalendererstellung. Wenn |fffd|nderungen auch k|fffd|nftig ber|fffd|cksichtigt werden sollen, f|fffd|hren Sie die |fffd|nderungen besser in den Einstellungen durch.", _
    vbInformation, CTitleMsgBox
End Sub






Private Sub SpaltenBreitenSetzen(DestTable As Worksheet, ByVal DateFrom As Long, ByVal DateTo As Long, ByVal CalendarFormatIndex As Byte)
Dim ColWidth As Single
Dim AMonat As Byte
Dim Offset As Byte
Dim MonatsspaltenBreiteDefault As Single
Dim b As Byte

  Application.StatusBar = "Setze Spaltenbreiten..."

  MonatsspaltenBreiteDefault = TabSettings.ItemsMonatsSpaltenBreite(CalendarFormatIndex)
  With DestTable
    For AMonat = 0 To MonatsAnzahl(DateFrom, DateTo) - 1
      Offset = AMonat * CColsPerMonth + 1
      '.Columns(Offset + CDatumsspalte).ColumnWidth = TabSettings.DatumSpalteBreite(CalendarFormatIndex)
      .Columns(Offset + CDatumsspalte).Columns.AutoFit
      If RangeIsEmpty(DestTable, CZeileErsterDesMonats, Offset + CZyklusSpalte, CZeileErsterDesMonats - 1 + 31, Offset + CZyklusSpalte) Then
        .Columns(Offset + CZyklusSpalte).ColumnWidth = 0.08
'        .Columns(Offset + CZyklusSpalte).ColumnWidth = 0
'        Falls Breite=0, wird der Rahmen nicht mehr angezeigt
      Else
        .Columns(Offset + CZyklusSpalte).Columns.AutoFit
      End If
      ' den verbleibenden Rest gleichm|fffd||fffd|ig auf alle anderen Spalten verteilen:
      ColWidth = RoundToLowerQuarter( _
        MonatsspaltenBreiteDefault _
        - .Columns(Offset + CDatumsspalte).ColumnWidth _
        - .Columns(Offset + CZyklusSpalte).ColumnWidth)
      If ColWidth < 0 Then ColWidth = 0.08 Else ColWidth = ColWidth / (CColsPerMonth - 2) ' 2 = 1 Datumsspalte + 1 Zyklusspalte
      For b = 0 To CColsPerMonth - 1
        If b <> CDatumsspalte Then
          If b <> CZyklusSpalte Then
            .Columns(Offset + b).ColumnWidth = ColWidth
          End If
        End If
      Next b
      
    Next AMonat
  End With

  Application.StatusBar = ""
End Sub


Public Function LoadFromOpenIniFile(ByRef ItemsTreated As Long) As Boolean
  AutoopenShow = LoadFromOpenIniFileBoolean(CodeName, CIniValueName_AutoopenShow, True)
  DoShowMessageOverwriteWarning = LoadFromOpenIniFileBoolean(CodeName, CIniValueName_DoShowMessageOverwriteWarning, True)
  TabselectionCodeUse = LoadFromOpenIniFileBoolean(CodeName, CIniValueName_TabselectionCodeUse, True)
  ItemsTreated = ItemsTreated + 3
  LoadFromOpenIniFile = True
End Function


Public Function SaveToOpenIniFile(ByRef ItemsTreated As Long) As Boolean
  Application.StatusBar = Me.Name & ": Speichern..."
  SaveToOpenIniFileBoolean CodeName, CIniValueName_AutoopenShow, AutoopenShow
  SaveToOpenIniFileBoolean CodeName, CIniValueName_DoShowMessageOverwriteWarning, DoShowMessageOverwriteWarning
  SaveToOpenIniFileBoolean CodeName, CIniValueName_TabselectionCodeUse, TabselectionCodeUse
  ItemsTreated = ItemsTreated + 3
  SaveToOpenIniFile = True
  Application.StatusBar = False
End Function


Private Function SubstVar(ByVal s As String, ByVal VarName As String, ByVal VarValue As String) As String
Dim l As Long
  Do
    l = InStr(s, VarName)
    If l <> 0 Then _
      s = Left(s, l - 1) & VarValue & Right(s, Len(s) - l - Len(VarName) + 1)
  Loop While l <> 0
  SubstVar = s

End Function


Function SubstVars(ByVal s As String, ByVal DateFrom As Long, ByVal DateTo As Long, ByVal BundeslandStr As String) As String
  s = SubstVar(s, "&[Bundesland]", BundeslandStr)
  s = SubstVar(s, "&[Kalenderjahr]", CStr(Year(DateFrom)))
  s = SubstVar(s, "&#", CStr(Year(DateFrom)))
  s = SubstVar(s, "&[Kalenderjahrbeginn]", CStr(Year(DateFrom)))
  s = SubstVar(s, "&[Kalenderjahrende]", CStr(Year(DateTo)))
  s = SubstVar(s, "&[Kalenderjahrmitte]", CStr(Year((CDate(DateTo + DateFrom) / 2))))
  s = SubstVar(s, "&[Kalenderbeginn]", CStr(CDate(DateFrom)))
  s = SubstVar(s, "&[Kalenderende]", CStr(CDate(DateTo)))
  
  SubstVars = s
End Function




Public Property Get TabselectionCodeUse() As Boolean
  TabselectionCodeUse = TabData.StrIsYesStr(Cells(CRowTabSelectionCodeUse, CColData))
End Property


Public Property Let TabselectionCodeUse(ByVal NewTabselectionCodeUse As Boolean)
  If NewTabselectionCodeUse = TabselectionCodeUse Then Exit Property
  Cells(CRowTabSelectionCodeUse, CColData) = TabData.YesNoStr(NewTabselectionCodeUse)
End Property


Private Function Tag2Zeile(ByVal Tag As Integer) As Integer
' Liefert die Zeile des entsprechenden Tages im Zielkalender
  Tag2Zeile = Tag + CZeileErsterDesMonats - 1
End Function



Private Sub TageF|fffd|rben(DestTable As Worksheet, ByVal CalendarFormatIndex As Byte, ByVal DateFrom As Long, ByVal DateTo As Long)
Dim dat As Long
Dim AInterior As Interior
Dim Monat As Integer
Dim CurrentMonth As Byte, AWeekday As Byte

  Application.StatusBar = "F|fffd|rbe Tage..."
  dat = DateFrom
  While dat <= DateTo
    AWeekday = Weekday(dat)
    Set AInterior = TabSettings.ItemsWeekdayColor(CalendarFormatIndex, AWeekday)
    SetzeTagesfarbeVonDatum dat, DateFrom, DestTable, AInterior, False, TabSettings.ItemsWeekdayFont(CalendarFormatIndex, AWeekday)
    dat = dat + 1
  Wend
  Application.StatusBar = ""
End Sub




Public Sub Worksheet_Activate()
Dim WasSaved As Boolean
  If TabInfos.TabselectionCodeUse Then
    WasSaved = Parent.Saved
    ActiveSheet.DisplayAutomaticPageBreaks = False
    ActiveWindow.DisplayHeadings = False
    ActiveWindow.DisplayWorkbookTabs = True
    Cells(1, 1).Select
    EnableSelection = xlUnlockedCells
    Protect
    If WasSaved Then Parent.Saved = True
  End If
End Sub


Private Sub Worksheet_Change(ByVal Target As Range)
  Select Case Target.Row
    Case CRowAutoopenShow
      If Target.Column = CColData Then
        If Not AutoopenShow Then
          If Not Registered Then
            MsgBox "Diese Einstellung kann nur in der lizensierten Version ge|fffd|ndert werden!", vbCritical, CTitleMsgBox
            AutoopenShow = True
          End If
        End If
      End If
    End Select
End Sub





Private Sub ZyklischeEintr|fffd|geBehandeln(DestTable As Worksheet, ByVal DateFrom As Long, ByVal DateTo As Long, ByVal CalendarFormatIndex As Byte)
Const CPublicIndexIgnore      As Byte = 1
Const CPublicIndexForget      As Byte = 2
Const CPublicIndexPrevworkday As Byte = 3
Const CPublicIndexNextworkday As Byte = 4

Dim DateCurr As Long, DateCurrStart As Long, DateCurrEnd As Long
Dim zeile As Integer, spalte As Integer, i As Integer, DurationIndex As Integer, DestCharIndex As Integer
Dim DayList As MSD_TNumList
Dim SaturdayIsWorkday As Boolean


  Set DayList = New MSD_TNumList
  DayList.Sorted = True
  DayList.DupAccept = False

  For i = 0 To TabCyclic.ItemsCount - 1
    If TabCyclic.ItemsDoShow(i) Then
      Application.StatusBar = "Zyklische Eintr|fffd|ge behandeln: " & TabCyclic.ItemsCaption(i)
      If TabCyclic.ItemsCheck(i, True) <> 0 Then GoTo NextCyclic ' Zeilen mit fehlerhaften Eintr|fffd|ge auslassen
      
      If TabCyclic.ItemsCycleBegin(i) + TabCyclic.ItemsDuration(i) <= DateTo Then
        ' Sofern ein Ende angegeben ist, wird bis zum kleineren Wert von (TabCyclic.ItemsCycleEnd, DateTo) behandelt:
        If TabCyclic.ItemsCycleEndIsDate(i) Then
          If TabCyclic.ItemsCycleEnd(i) > DateTo Then DateCurrEnd = DateTo Else DateCurrEnd = TabCyclic.ItemsCycleEnd(i)
        Else
          DateCurrEnd = DateTo
        End If
        
        If DateCurrEnd >= DateFrom Then
          DateCurrStart = TabCyclic.ItemsCycleBegin(i)
          Do
            SaturdayIsWorkday = TabCyclic.ItemsSaturdayIsWorkday(i)
            DateCurr = DateCurrStart
            For DurationIndex = 0 To TabCyclic.ItemsDuration(i) - 1
              DateCurr = DateCurrStart + DurationIndex
CheckCurrDate:
              If DayList.Find(DateCurr) Then GoTo SkipEntry ' dieser Tag wurde bereits eingetragen
              If DateCurr > DateCurrEnd Then Exit For
              If DateCurr >= DateFrom Then
                If TabPublics.IsPublic(DateCurr) Then
                  Select Case TabCyclic.ItemsPublicBehaviourIndex(i)
                    Case CPublicIndexForget
                      GoTo SkipEntry
                    Case CPublicIndexNextworkday
                      DateCurr = WorkdayNext(DateCurr, SaturdayIsWorkday)
                      GoTo CheckCurrDate
                    Case CPublicIndexPrevworkday
                      DateCurr = WorkdayPrev(DateCurr, SaturdayIsWorkday)
                      GoTo CheckCurrDate
                    ' CPublicIndexIgnore braucht nicht behandelt zu werden; *DateCurr* bleibt gleich
                  End Select
                Else
                  If Weekday(DateCurr) = vbSaturday Then
                    Select Case TabCyclic.ItemsSaturdayBehaviourIndex(i)
                      Case CPublicIndexForget
                        GoTo SkipEntry
                      Case CPublicIndexNextworkday
                        DateCurr = WorkdayNext(DateCurr, SaturdayIsWorkday)
                        GoTo CheckCurrDate
                      Case CPublicIndexPrevworkday
                        DateCurr = WorkdayPrev(DateCurr, SaturdayIsWorkday)
                        GoTo CheckCurrDate
                      ' CPublicIndexIgnore braucht nicht behandelt zu werden; *DateCurr* bleibt gleich
                    End Select
                  End If
                End If
                ' Liegt der Tag in den gesteckten Grenzen?
                If (DateCurr >= DateFrom) And (DateCurr >= TabCyclic.ItemsCycleBegin(i)) And (DateCurr <= DateCurrEnd) Then
                  DayList.Add DateCurr ' diesen Tag merken
                  zeile = Tag2Zeile(Day(DateCurr))
                  spalte = Monat2Spalte(DateCurr, DateFrom) + CZyklusSpalte
                  
                  DestCharIndex = Len(DestTable.Cells(zeile, spalte)) + 1
                  DestTable.Cells(zeile, spalte).Characters(DestCharIndex, 1).Text = Chr(TabCyclic.ItemsCharCode(i, DurationIndex + 1))
                  DestTable.Cells(zeile, spalte).VerticalAlignment = xlTop
                  CopyFont TabCyclic.ItemsCharFont(i, DurationIndex + 1), DestTable.Cells(zeile, spalte).Characters(DestCharIndex, 1).Font
                  DestTable.Cells(zeile, spalte).Characters(DestCharIndex, 1).Font.Size = _
                    DestTable.Cells(zeile, spalte).Characters(DestCharIndex, 1).Font.Size * TabSettings.ItemsTextScale(CalendarFormatIndex)
                End If
              End If
              
SkipEntry:
            Next DurationIndex
            DateCurrStart = DateCurrStart + TabCyclic.ItemsPeriod(i)
    
          Loop While DateCurr <= DateCurrEnd
        End If
      End If
    End If
NextCyclic:
    DayList.Clear ' *DayList* wird f|fffd|r alle Tage einer Zyklusdefinition verwendet
  Next i
  Set DayList = Nothing

  ' Formatierung:
  AlleMonatsspalten(DestTable, CZyklusSpalte, MonatsAnzahl(DateFrom, DateTo)).HorizontalAlignment = xlRight

End Sub







Attribute VB_Name = "TabLicence"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit


Private Sub ButtonContact_Click()
  EMailSend "Anpassung Kalender-Excel", "Wir w|fffd|nschen folgende Anpassungen des Produktes " & CProgrammname & " (" & CVersionStr & "):%0D%0A"
End Sub


Private Sub ButtonLicenceTableUnprotect_Click()
On Error GoTo Err_ButtonLicenceTableUnprotect_Click
Dim RegStr As String
Dim ApplicationScreenUpdating As Boolean
  
  ApplicationScreenUpdating = Application.ScreenUpdating
  Application.ScreenUpdating = False
  RegStr = TabData.Registrierungscode
  RegStr = Trim(InputBox("Bitte geben Sie den Lizenzschl|fffd|ssel ein:", CTitleMsgBox, RegStr))
  If RegStr = "" Then
    If Registered Then
      If MsgBox("Soll der vorhandene Lizenzschl|fffd|ssel gel|fffd|scht werden?", vbQuestion Or vbYesNo, CTitleMsgBox) = vbYes Then GoTo RegCodeDisable
    End If
    GoTo Exit_ButtonLicenceTableUnprotect_Click
  End If
  If TabData.RegistrierungscodeOk(RegStr) Then
    TabData.Registrierungscode = RegStr
    MsgBox "Vielen Dank f|fffd|r die Lizenzierung", vbOKOnly, CTitleMsgBox
  Else
    MsgBox "Der Registrierungsschl|fffd|ssel ist ung|fffd|ltig. Bitte beachten Sie die Gro|fffd|- und Kleinschreibung.", vbOKOnly Or vbCritical, CTitleMsgBox
    GoTo RegCodeDisable
  End If
  GoTo Exit_ButtonLicenceTableUnprotect_Click
  
RegCodeDisable:
  TabData.Registrierungscode = ""
  TabSettings.Gesperrt = True
  GoTo Exit_ButtonLicenceTableUnprotect_Click
  

Err_ButtonLicenceTableUnprotect_Click:
  MsgBox Err.Description, vbCritical, CTitleMsgBox
  Resume Exit_ButtonLicenceTableUnprotect_Click

Exit_ButtonLicenceTableUnprotect_Click:
  Application.ScreenUpdating = ApplicationScreenUpdating
End Sub



Private Sub ButtonRequestBill_Click()
  EMailSend "Rechnung Kalender-Excel", "Bitte senden Sie uns eine Rechnung |fffd|ber eine Lizenz f|fffd|r das Produkt " & CProgrammname & " (" & CVersionStr & ") an folgende Anschrift:%0D%0A"
End Sub


Private Sub Worksheet_Activate()
  TabInfos.InfoCheckbox(CInfoCheckboxZeileLicence) = True
  
  If TabInfos.TabselectionCodeUse Then
    ActiveWindow.DisplayHeadings = False
    ActiveWindow.DisplayGridlines = False
    ActiveSheet.DisplayAutomaticPageBreaks = False
    Cells(1, 1).Select
    EnableSelection = xlNoSelection
    If Not ProtectContents Then Protect
  End If
End Sub


Private Sub Worksheet_Deactivate()
Dim WasSaved As Boolean
  If TabInfos.TabselectionCodeUse Then
    WasSaved = Me.Parent.Saved
    Visible = xlSheetHidden
    If WasSaved Then Me.Parent.Saved = True
  End If
End Sub


Attribute VB_Name = "TabMacrosdisabled"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit



Private Sub Worksheet_Deactivate()
  If TabInfos.TabselectionCodeUse Then Visible = xlSheetHidden
End Sub


Attribute VB_Name = "TabPublics"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit



Private Const CEasterDepPublicCount     As Byte = 7
Private Const CBussUndBettagIndex       As Byte = 7


Private Const CRowDataFirst             As Byte = 4  ' Beginn der fixen Eintr|fffd|ge
Private Const CRowDataLast              As Byte = 21 ' Ende der fixen Eintr|fffd|ge
Private Const CRowDataUserFirst         As Byte = CRowDataLast  ' Beginn der Benutzereintr|fffd|ge
Private Const CRowDataUserLast          As Byte = 33            ' Ende der Benutzereintr|fffd|ge


Private Const CColCaptions              As Byte = 2
Private Const CColDay                   As Byte = 3
Private Const CColMonth                 As Byte = 4
Private Const ColIsPublic               As Byte = 5
Private Const ColDoShow                 As Byte = 6

Private Const CColFirst                 As Byte = CColCaptions
Private Const CColLast                  As Byte = ColDoShow


Private Const CColBundesland As Byte = 3: Private Const CRowBundesland  As Byte = 2 ' dient der Anzeige des aktuell gew|fffd|hlten Bundeslandes
Private Const CColFont       As Byte = 2: Private Const CRowFont        As Byte = 1 ' In welcher Zelle befindet sich die Schriftartvorgabe f|fffd|r einen Feiertag?




Private fItemsCountValid As Boolean ' ist der Wert in *fItemsCount* noch g|fffd|ltig?
Private fItemsCount As Byte


Public Property Get BundeslandStr() As String
' dient der Anzeige des aktuell gew|fffd|hlten Bundeslandes
  BundeslandStr = Cells(CRowBundesland, CColBundesland)
End Property



Public Property Let BundeslandStr(ByVal NewBundeslandStr As String)
Dim WasProtected As Boolean

  If BundeslandStr = NewBundeslandStr Then Exit Property
  If Not UnprotectCalendarWorksheet(Me, "", WasProtected) Then Exit Property

  Cells(CRowBundesland, CColBundesland) = NewBundeslandStr
  If WasProtected Then Protect
End Property



Private Sub ButtonSchriftartAendern_Click()
Dim bereich As Range
Dim DoProtect As Boolean
  
  If ActiveSheet.ProtectContents Then
    ActiveSheet.Unprotect
    DoProtect = True
  Else
    DoProtect = False
  End If
  
  Set bereich = Selection
  
  Cells(CRowFont, CColFont).Select
  Application.Dialogs(xlDialogActiveCellFont).Show
  bereich.Select
  If DoProtect Then ActiveSheet.Protect
End Sub


 
Public Sub Clear()
Dim i As Integer
  
  If Me.ProtectContents Then Me.Unprotect
  
  With Cells(1, 2).Font
    .Size = 4.5
    .Name = "Arial"
    .Bold = False
    .Color = 0
    .Italic = False
    .OutlineFont = False
    .Strikethrough = False
    .Subscript = False
    .Superscript = False
    .Underline = False
  End With
  Range(Cells(CRowDataLast + 1, CColFirst), Cells(CRowDataLast - CRowDataFirst + ItemsCount - 2, CColLast)).ClearContents
  
  For i = 0 To CRowDataUserLast - CRowDataFirst
    ItemsIsPublic(i) = True
    ItemsDoDisplayText(i) = True
  Next i
        
  Me.Protect
End Sub

Function DefaultHave(ByVal ABundeslandIndex As Byte) As Boolean
Dim i As Byte
Dim Feiertagsliste

  Feiertagsliste = TabData.Holidays(ABundeslandIndex)
  For i = LBound(Feiertagsliste) To UBound(Feiertagsliste)
    If Feiertagsliste(i) <> TabData.StrIsYesStr(Cells(CRowDataFirst + i - 1, ColIsPublic)) Then _
      DefaultHave = False: Exit Function
  Next i
  DefaultHave = True
  
End Function



Public Sub DefaultSet(ByVal ABundeslandIndex As Byte)
Dim i As Byte
Dim Feiertagsliste
Dim ProtectContentsOld As Boolean

  If ProtectContents Then
    ProtectContentsOld = True
    Unprotect
  Else
    ProtectContentsOld = False
  End If
  Feiertagsliste = TabData.Holidays(ABundeslandIndex)
  For i = LBound(Feiertagsliste) To UBound(Feiertagsliste)
    Cells(CRowDataFirst + i - 1, ColIsPublic) = TabData.YesNoStr(Feiertagsliste(i))
  Next i
  If ProtectContentsOld Then Protect
  
End Sub


Public Property Get Font() As Font
  Set Font = Cells(CRowFont, CColFont).Font
End Property


Public Property Get ItemsCount() As Byte
' Ermittelt die Gesamtzahl der Zeilen mit Feiertagseintr|fffd|gen
Dim i As Byte
  If Not fItemsCountValid Then
    i = CRowDataFirst
    While Cells(i, CColCaptions) <> ""
      i = i + 1
    Wend
    fItemsCount = i - CRowDataFirst
    fItemsCountValid = True
  End If
  ItemsCount = fItemsCount
End Property



Private Property Get ItemsDayStr(ByVal Index As Byte) As String
  ItemsDayStr = Cells(CRowDataFirst + Index, CColDay).Formula
End Property

Private Property Let ItemsDayStr(ByVal Index As Byte, s As String)
  Cells(CRowDataFirst + Index, CColDay).Formula = s
End Property


Private Property Get ItemsMonthStr(ByVal Index As Byte) As String
  ItemsMonthStr = Cells(CRowDataFirst + Index, CColMonth).Formula
End Property


Private Property Let ItemsMonthStr(ByVal Index As Byte, s As String)
  Cells(CRowDataFirst + Index, CColMonth).Formula = s
End Property


Public Property Get ItemsDate(ByVal Index As Byte, ByVal Jahr As Integer) As Long
  If Index < CEasterDepPublicCount Then
    ItemsDate = EasterDepPublic(Jahr, Index)
  Else
    If Index = CBussUndBettagIndex Then
      ItemsDate = Busstag(Jahr)
    Else
      ItemsDate = DateSerial(Jahr, Cells(CRowDataFirst + Index, CColMonth), Cells(CRowDataFirst + Index, CColDay))
    End If
  End If
End Property



Private Property Let ItemsDoDisplayText(ByVal Index As Byte, ByVal NewVal As Boolean)
  Cells(CRowDataFirst + Index, ColDoShow) = TabData.YesNoStr(NewVal)
End Property

Public Property Get ItemsDoDisplayText(ByVal Index As Byte) As Boolean
  ItemsDoDisplayText = TabData.StrIsYesStr(Cells(CRowDataFirst + Index, ColDoShow))
End Property


Private Function ItemIndexToZeile(ByVal Itemindex As Integer) As Integer
  ItemIndexToZeile = CRowDataFirst + Itemindex
End Function



Public Property Get ItemsIniStr(ByVal Index As Byte) As String
' Aufbau:
' vorgegebene Eintr|fffd|ge: ColIsPublic [0|1]|ColDoShow [0|1]
' Benutzereintrag: Zeilennummer|Text der Spalte *CColCaptions*|Formula(CColDay)|Formula(CColMonth)|ColIsPublic [0|1]|ColDoShow [0|1]
Dim IniStrPublicDodisplay As String ' Werte von ColIsPublic/ColDoShow
  
  IniStrPublicDodisplay = CStr(-CInt(ItemsIsPublic(Index))) & Chr(CIniDelimiterCharCode) & CStr(-CInt(ItemsDoDisplayText(Index)))
  If Index > CRowDataLast - CRowDataFirst Then ' Benutzereintrag
    ItemsIniStr = CStr(Index + CRowDataFirst) & Chr(CIniDelimiterCharCode) & encodeURI(ItemsText(Index), True) & Chr(CIniDelimiterCharCode) & encodeURI(ItemsDayStr(Index), True) & Chr(CIniDelimiterCharCode) & encodeURI(ItemsMonthStr(Index), True) & Chr(CIniDelimiterCharCode) & IniStrPublicDodisplay
  Else
    ItemsIniStr = IniStrPublicDodisplay
  End If
End Property



Public Property Let ItemsIniStr(ByVal Index As Byte, inistr As String)
Dim StrIndex As Long
Dim b As Boolean
Dim l As Long
Dim s As String

  StrIndex = 1
  If Index > CRowDataLast - CRowDataFirst Then ' Benutzereintrag
    If TokenNext_long(inistr, CIniDelimiterCharCode, l, StrIndex) Then ' Zeilennummer
      If ItemIndexToZeile(Index) = l Then
        If TokenNext(inistr, CIniDelimiterCharCode, s, StrIndex, False) Then ' Text der Spalte *CColCaptions*
          ItemsText(Index) = decodeURI(s, True)
          StrIndex = StrIndex + 1
          If TokenNext(inistr, CIniDelimiterCharCode, s, StrIndex, False) Then ' Formula(CColDay)
            StrIndex = StrIndex + 1
            ItemsDayStr(Index) = decodeURI(s, True)
            If TokenNext(inistr, CIniDelimiterCharCode, s, StrIndex, False) Then ' Formula(CColMonth)
              ItemsMonthStr(Index) = decodeURI(s, True)
              StrIndex = StrIndex + 1
              GoTo ReadRemining
            End If
          End If
        End If
      End If
    End If
    GoTo ShowParseErrorAndExit
  End If
  
  
ReadRemining:
  ' dieser Codeteil wird f|fffd|r Benutzereintr|fffd|ge und vorgegebene Eintr|fffd|ge ausgef|fffd|hrt:
  If TokenNext_boolean(inistr, CIniDelimiterCharCode, b, StrIndex) Then
    ItemsIsPublic(Index) = b
    If TokenNext_boolean(inistr, CIniDelimiterCharCode, b, StrIndex) Then
      ItemsDoDisplayText(Index) = b
    End If
  End If
  Exit Property
  
ShowParseErrorAndExit:
  MsgBox "Importfehler beim Parsen der Zeile " & inistr, vbCritical, CTitleMsgBox
  
End Property

Public Property Get ItemsIsPublic(ByVal Index As Byte) As Boolean
  ItemsIsPublic = TabData.StrIsYesStr(Cells(CRowDataFirst + Index, ColIsPublic))
End Property

Private Property Let ItemsIsPublic(ByVal Index As Byte, ByVal NewVal As Boolean)
  Cells(CRowDataFirst + Index, ColIsPublic) = TabData.YesNoStr(NewVal)
End Property


Public Property Get ItemsText(ByVal Index As Byte) As String
  ItemsText = Cells(CRowDataFirst + Index, CColCaptions)
End Property

Private Property Let ItemsText(ByVal Index As Byte, s As String)
  Cells(CRowDataFirst + Index, CColCaptions) = s
End Property




Public Property Get Interior() As Interior
  Set Interior = Cells(CRowFont, CColFont).Interior
End Property




Function IsPublic(ByVal ADate As Long) As Boolean
' Gibt TRUE zur|fffd|ck, falls *ADate* ein Sonn- oder Feiertag ist
Dim Kalenderjahr As Integer
Dim i As Integer

  IsPublic = True
  If Weekday(ADate) = vbSunday Then Exit Function
  Kalenderjahr = Year(ADate)
  
  ' zun|fffd|chst die Osterfestabh|fffd|ngigen Feiertage:
  For i = 0 To CEasterDepPublicCount - 1
    If ItemsIsPublic(i) Then _
      If ADate = EasterDepPublic(Kalenderjahr, i + CEasterDepIndexFirst) Then Exit Function
  Next i
  
  
  ' Buss- und Bettag:
  If ItemsIsPublic(CBussUndBettagIndex) Then _
    If ADate = Busstag(Kalenderjahr) Then Exit Function
  
  ' restliche Feiertage checken:
  i = i + 1
  While Cells(i, CColCaptions) <> ""
    If ItemsIsPublic(i) Then _
      If ItemsDate(i, Kalenderjahr) = ADate Then Exit Function
    i = i + 1
  Wend
  
  IsPublic = False
End Function


Public Function LoadFromOpenIniFile(ByRef ItemsTreated As Long) As Boolean
Dim i As Integer
Dim s As String
Dim WasProtected  As Boolean
  
  
  LoadFromOpenIniFile = False
  If Not UnprotectCalendarWorksheet(Me, "", WasProtected) Then Exit Function
  
  
  s = LoadFromOpenIniFileString(Me.CodeName, CIniValueNameFont)
  If s <> "" Then LoadFromOpenIniFileFont s, Font
  
  For i = 0 To CRowDataLast - CRowDataFirst  ' erst die fixen Eintr|fffd|ge:
    s = LoadFromOpenIniFileString(Me.CodeName, ItemsText(i))
    If s <> "" Then ItemsIniStr(i) = s
    ItemsTreated = ItemsTreated + 1
  Next i
  i = 0
  Do
    s = LoadFromOpenIniFileString(Me.CodeName, CIniPrefixUserdef & CStr(i))
    If s <> "" Then
      ItemsIniStr(i + CRowDataLast - CRowDataFirst + 1) = s
      ItemsTreated = ItemsTreated + 1
    End If
    i = i + 1
  Loop Until s = ""
  
  If WasProtected Then Protect
  LoadFromOpenIniFile = True
End Function


Sub MakeDist()
Dim PrevVisible As Long
  PrevVisible = Visible
  Visible = xlSheetVisible
  Activate
  Cells(CRowDataFirst + ItemsCount, CColCaptions).Select
  Visible = PrevVisible
End Sub


Public Function SaveToOpenIniFile(ByRef ItemsTreated As Long) As Boolean
Dim i As Integer
  
  SaveToOpenIniFileString Me.CodeName, CIniValueNameFont, SaveToOpenIniFileFont(Font)
  For i = 0 To CRowDataLast - CRowDataFirst  ' erst die fixen Eintr|fffd|ge:
    SaveToOpenIniFileString Me.CodeName, ItemsText(i), ItemsIniStr(i)
    ItemsTreated = ItemsTreated + 1
    Application.StatusBar = Me.Name & ": Speichere Eintrag " & CStr(i + 1)
  Next i
  For i = CRowDataLast - CRowDataFirst + 1 To ItemsCount - 1
    SaveToOpenIniFileString Me.CodeName, CIniPrefixUserdef & CStr(i - (CRowDataLast - CRowDataFirst + 1)), ItemsIniStr(i)
    ItemsTreated = ItemsTreated + 1
    Application.StatusBar = Me.Name & ": Speichere Eintrag " & CStr(i + 1)
  Next i
  SaveToOpenIniFile = True
  Application.StatusBar = False
End Function




Private Sub Worksheet_Activate()
  TabInfos.InfoCheckbox(CInfoCheckboxZeileFeiertage) = True
  If TabInfos.TabselectionCodeUse Then
    ActiveWindow.DisplayHeadings = False
    Me.DisplayAutomaticPageBreaks = False
    EnableSelection = xlUnlockedCells
    Protect
  End If
End Sub


Private Sub Worksheet_Change(ByVal Target As Range)
  fItemsCountValid = False
End Sub



Private Sub Worksheet_Deactivate()
  If TabInfos.TabselectionCodeUse Then Visible = xlSheetHidden
End Sub




Attribute VB_Name = "TabSettings"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Control = "ButtonSchriftartAendern, 8, 0, MSForms, CommandButton"
Attribute VB_Control = "ButtonZahlenformatAendern, 10, 1, MSForms, CommandButton"
Attribute VB_Control = "SpinButtonResizeColWidth, 20, 2, MSForms, SpinButton"
Attribute VB_Control = "ButtonFarbeAendern, 21, 3, MSForms, CommandButton"
Option Explicit



Private Const C_Row_Caption                             As Byte = 2  ' = C_Row_First
Private Const C_Row_PageSettings                         As Byte = C_Row_Caption + 1
  Private Const C_Row_PageSettings_PaperSize             As Byte = C_Row_PageSettings + 1
  Private Const C_Row_PageSettings_Orientation           As Byte = C_Row_PageSettings + 2
  Private Const C_Row_PageSettings_PageWidth             As Byte = C_Row_PageSettings + 3
  Private Const C_Row_PageSettings_PageHeight            As Byte = C_Row_PageSettings + 4
  Private Const C_Row_PageSettings_Zoom                  As Byte = C_Row_PageSettings + 5

  Private Const C_Row_PageSettings_Margins               As Byte = C_Row_PageSettings + 6
    Private Const C_Row_PageSettings_Margins_Left        As Byte = C_Row_PageSettings_Margins + 1
    Private Const C_Row_PageSettings_Margins_Right       As Byte = C_Row_PageSettings_Margins + 2
    Private Const C_Row_PageSettings_Margins_Top         As Byte = C_Row_PageSettings_Margins + 3
    Private Const C_Row_PageSettings_Margins_Bottom      As Byte = C_Row_PageSettings_Margins + 4

  Private Const C_Row_PageSettings_Header                As Byte = C_Row_PageSettings_Margins + 5
    Private Const C_Row_PageSettings_Header_Left         As Byte = C_Row_PageSettings_Header + 1
    Private Const C_Row_PageSettings_Header_Center       As Byte = C_Row_PageSettings_Header + 2
    Private Const C_Row_PageSettings_Header_Right        As Byte = C_Row_PageSettings_Header + 3
    Private Const C_Row_PageSettings_Header_Margin       As Byte = C_Row_PageSettings_Header + 4

  Private Const C_Row_PageSettings_Footer                As Byte = C_Row_PageSettings_Header + 5
    Private Const C_Row_PageSettings_Footer_Left         As Byte = C_Row_PageSettings_Footer + 1
    Private Const C_Row_PageSettings_Footer_Center       As Byte = C_Row_PageSettings_Footer + 2
    Private Const C_Row_PageSettings_Footer_Right        As Byte = C_Row_PageSettings_Footer + 3
    Private Const C_Row_PageSettings_Footer_Margin       As Byte = C_Row_PageSettings_Footer + 4

Private Const C_Row_Columns                              As Byte = C_Row_PageSettings_Footer + 5
  Private Const C_Row_Columns_MonthWidth                 As Byte = C_Row_Columns + 1
  Private Const C_Row_Columns_Headerformat               As Byte = C_Row_Columns + 2
  Private Const C_Row_Columns_ColDate                    As Byte = C_Row_Columns + 3
    Private Const C_Row_Columns_ColDate_Format           As Byte = C_Row_Columns_ColDate + 1
    Private Const C_Row_Columns_ColDate_VA               As Byte = C_Row_Columns_ColDate + 2
  Private Const C_Row_Columns_ColCaption                 As Byte = C_Row_Columns_ColDate + 3
    Private Const C_Row_Columns_ColCaption_TextScale     As Byte = C_Row_Columns_ColCaption + 1
    Private Const C_Row_Columns_ColCaption_VA            As Byte = C_Row_Columns_ColCaption + 2

Private Const C_Row_Colors                               As Byte = C_Row_Columns_ColCaption_VA + 1
  Private Const C_Row_Colors_WeekdaysFirst               As Byte = C_Row_Colors + 1
  ' die dazwischenliegenden werden per Code ermittelt
  Private Const C_Row_Colors_WeekdaysLast                As Byte = C_Row_Colors_WeekdaysFirst + 6
  Private Const C_Row_Colors_Publicday                   As Byte = C_Row_Colors_WeekdaysLast + 1
  Private Const C_Row_Colors_Holiday                     As Byte = C_Row_Colors_WeekdaysLast + 2
  Private Const C_Row_Colors_HolidaysBeforePublic        As Byte = C_Row_Colors_Holiday + 1
  Private Const C_Row_Colors_Formatcurrentday            As Byte = C_Row_Colors_HolidaysBeforePublic + 1
    Private Const C_Row_Colors_Formatcurrentday_Color    As Byte = C_Row_Colors_Formatcurrentday + 1

Private Const C_Row_KW                                   As Byte = C_Row_Colors_Formatcurrentday_Color + 1
  Private Const C_Row_KW_Use                             As Byte = C_Row_KW + 1
  Private Const C_Row_KW_DistLeft                        As Byte = C_Row_KW + 2
  Private Const C_Row_KW_DistTop                         As Byte = C_Row_KW + 3
  Private Const C_Row_KW_Str                             As Byte = C_Row_KW + 4
  Private Const C_Row_KW_Schema                          As Byte = C_Row_KW + 5 ' wird seit Einf|fffd|hrung der Wordart-Grafiken nicht mehr benutzt
  Private Const C_Row_KW_Last                            As Byte = C_Row_KW_Schema
  

Private Const C_Row_Misc                                 As Byte = C_Row_KW_Schema + 1
Private Const C_Row_Misc_MaximizeLineHeight              As Byte = C_Row_Misc + 1
Private Const C_Row_Misc_DelimiterStr                    As Byte = C_Row_Misc + 2
Private Const C_Row_Misc_LineHeightMin                   As Byte = C_Row_Misc + 3 ' = C_Row_Last

Private Const C_Row_First   As Byte = C_Row_Caption
Private Const C_Row_Last    As Byte = C_Row_Misc_LineHeightMin

Private Const CColFirst     As Byte = 4
Private Const CColLast      As Byte = 14


Private Const CKWShapenamePrefix As String = "KWSchema"
Private Const CErrNum = 7042 + vbObjectError ' 7042 = Hash(CodeName, True)

Private Const CIniPrefixSectionItems        As String = "Item"
Private Const CIniKey_Items                     As String = "Items"

Private Const CIniKeyCaption                    As String = "Caption"
Private Const CIniKeyColorHolidays              As String = "ColorHolidays"
Private Const CIniKeyColorPublics               As String = "ColorPublics"
Private Const CIniKeyColumnWidth                As String = "ColumnWidth"
Private Const CIniKeyComments                   As String = "Comments"
Private Const CIniKeyDateNumberFormat           As String = "DateNumberFormat"
Private Const CIniKeyDateVerticalAlignment      As String = "DateVerticalAlignment"
Private Const CIniKeyDelimiterFont              As String = "DelimiterFont"
Private Const CIniKeyDelimiterStr               As String = "DelimiterStr"
Private Const CIniKeyFooterCenter               As String = "FooterCenter"
Private Const CIniKeyFooterLeft                 As String = "FooterLeft"
Private Const CIniKeyFooterMargin               As String = "FooterMargin"
Private Const CIniKeyFooterRight                As String = "FooterRight"
Private Const CIniKeyFormatcurrentday           As String = "Formatcurrentday"
Private Const CIniKeyFormatcurrentdayFormat     As String = "FormatcurrentdayFormat"
Private Const CIniKeyHeaderCenter               As String = "HeaderCenter"
Private Const CIniKeyHeaderLeft                 As String = "HeaderLeft"
Private Const CIniKeyHeaderMargin               As String = "HeaderMargin"
Private Const CIniKeyHeaderRight                As String = "HeaderRight"
Private Const CIniKeyHolidaysBeforePublic       As String = "HolidaysBeforePublic"
Private Const CIniKeyItemsShapePrefix           As String = "KWShape"
Private Const CIniKeyKWDistLeft                 As String = "KWDistLeft"
Private Const CIniKeyKWDistTop                  As String = "KWDistTop"
Private Const CIniKeyKWStr                      As String = "KWText"
Private Const CIniKeyKWUse                      As String = "UseKW"
Private Const CIniKeyLineHeightMin              As String = "LineHeightMin"
Private Const CIniKeyMarginBottom               As String = "MarginBottom"
Private Const CIniKeyMarginLeft                 As String = "MarginLeft"
Private Const CIniKeyMarginRight                As String = "MarginRight"
Private Const CIniKeyMarginTop                  As String = "MarginTop"
Private Const CIniKeyMaximizeLineHeight         As String = "MaximizeLineHeight"
Private Const CIniKeyMonthHeaderFont            As String = "MonthHeaderFont"
Private Const CIniKeyMonthHeaderInterior        As String = "MonthHeaderInterior"
Private Const CIniKeyMonthHeaderNumberformat    As String = "MonthHeaderNumberformat"
Private Const CIniKeyMonthWidth                 As String = "MonthWidth"
Private Const CIniKeyOrientationIndex           As String = "OrientationIndex"
Private Const CIniKeyPaperSizeIndex             As String = "PaperSizeIndex"
Private Const CIniKeyTextScale                  As String = "TextScale"
Private Const CIniKeyTextVerticalAlignment      As String = "TextVerticalAlignment"
Private Const CIniKeyWeekdayPrefixFont          As String = "WeekdayFont"
Private Const CIniKeyWeekdayPrefixInterieur     As String = "WeekdayInterieur"
Private Const CIniKeyZoom                       As String = "Zoom"

Private Const CDefault_Header_Margin            As Double = 1.5
Private Const CDefault_Margin                   As Double = 2
Private Const CDefault_Columnwidth              As Double = 19.14
Private Const CDefault_Footer_Margin            As Double = 1.3
Private Const CDefault_MonatsSpaltenBreite      As Byte = 20

Private fIgnoreSpinButtonResizeColWidthChange As Boolean


Private Sub ButtonDialog_Click(ByVal Index As XlBuiltInDialog)
Dim WasProtected As Boolean
Dim ACell As Variant

  If Not UnprotectCalendarWorksheet(Me, CPassword, WasProtected) Then Exit Sub
  
  Selection.Select

  If Application.Dialogs(Index).Show Then
    If Index = xlDialogActiveCellFont Then
      If Selection.count > 1 Then
        Application.ScreenUpdating = False
        For Each ACell In Selection
          CopyFont ActiveCell.Font, ACell.Font
        Next ACell
        Application.ScreenUpdating = True
      End If
    End If
  End If
  If WasProtected Then Sch|fffd|tzen
  
End Sub



Private Sub ButtonFarbeAendern_Click()
  ButtonDialog_Click xlDialogPatterns
End Sub

Private Sub ButtonSchriftartAendern_Click()
  ButtonDialog_Click xlDialogActiveCellFont
End Sub

Private Sub ButtonZahlenformatAendern_Click()
  ButtonDialog_Click xlDialogFormatNumber
End Sub



Private Property Get CellsFormulaValueStr(ByVal ARow As Integer, ByVal ACol As Integer, ByVal UseFormular As Boolean) As String
  If UseFormular Then CellsFormulaValueStr = Cells(ARow, ACol).Formula Else CellsFormulaValueStr = Cells(ARow, ACol)
End Property


Private Property Let CellsFormulaValueStr(ByVal ARow As Integer, ByVal ACol As Integer, ByVal UseFormular As Boolean, ByVal s As String)
  If Cells(ARow, ACol).Locked Then Exit Property
  If UseFormular Then Cells(ARow, ACol).Formula = s Else Cells(ARow, ACol) = s
End Property


Public Sub Clear()
Dim i As Integer
  
  UpdateBegin
  For i = ItemsCount - 1 To 0 Step -1
    ItemsClear i
  Next i
  UpdateEnd
End Sub


Private Function ColorDaysInterior(CRowColumnsIndex As Byte, Index As Byte) As Interior
  Set ColorDaysInterior = Cells(CRowColumnsIndex, CColFirst + Index).Interior
End Function



Private Property Get Gesch|fffd|tzt() As Boolean
' Kapselung f|fffd|r self.ProtectContents: falls Registriert, ist das Kennwort f|fffd|r den Schutz leer
  Gesch|fffd|tzt = ProtectContents
End Property


Private Function GetDoubleVal(ByVal ARow As Byte, ByVal ACol As Byte, ByVal Default As Double) As Double
' Liefert einen Double-Wert aus der Zelle (ARow, ACol). Falls die Zelle keinen g|fffd|ltigen Doublewert enth|fffd|lt, wird der Default-Wert zur|fffd|ckgegeben
  If IsEmpty(Cells(ARow, ACol)) Then
    GetDoubleVal = Default
  Else
    GetDoubleVal = CDbl(Cells(ARow, ACol))
  End If
End Function



Public Property Get ItemsCaption(ByVal Index As Byte) As String
  ItemsCaption = Trim(Cells(C_Row_Caption, Index + CColFirst))
End Property


Public Property Let ItemsCaption(ByVal Index As Byte, NewCaption As String)
  Cells(C_Row_Caption, Index + CColFirst) = NewCaption
End Property


Private Sub ItemsClear(ByVal Listindex As Integer)
On Error GoTo Err_ItemsClear
Dim i As Integer
Dim WasProtected As Boolean

  If Not UnprotectCalendarWorksheet(Me, CPassword, WasProtected) Then Exit Sub
  UpdateBegin
  ItemsCaption(Listindex) = ""
  For i = ItemsCommentsCount(Listindex) - 1 To 0 Step -1
    ItemsComments(Listindex, i).Delete
  Next i
  
  ItemsColumnWidth(Listindex) = CDefault_Columnwidth
  ItemsPaperSizeIndex(Listindex) = 9
  ItemsOrientationIndex(Listindex) = 1
  ItemsZoom(Listindex) = 100
  ItemsMargin(Listindex, xlLeft, False) = CDefault_Margin
  ItemsMargin(Listindex, xlRight, False) = CDefault_Margin
  ItemsMargin(Listindex, xlTop, False) = CDefault_Margin
  ItemsMargin(Listindex, xlBottom, False) = CDefault_Margin
  'ItemsHeaderStr(Listindex, xlLeft, True), True)=
  ItemsHeaderStr(Listindex, xlCenter, True) = "&B&12Kalender &[Kalenderjahrmitte] f|fffd|r &[Bundesland]"
  ItemsHeaderStr(Listindex, xlRight, True) = "&D"
  ItemsHeaderMargin(Listindex, False) = CDefault_Header_Margin
  ItemsFooterStr(Listindex, xlLeft, True) = ""
  ItemsFooterStr(Listindex, xlCenter, True) = ""
  ItemsFooterStr(Listindex, xlRight, True) = ""
  ItemsFooterMargin(Listindex, False) = CDefault_Footer_Margin
  ItemsMonatsSpaltenBreite(Listindex) = CDefault_MonatsSpaltenBreite
  
  DefaultFont ItemsMonatsSpalten|fffd|berschriftFont(Listindex)
  ItemsMonatsSpalten|fffd|berschriftFont(Listindex).Bold = True
  DefaultInterior ItemsMonatsSpalten|fffd|berschriftInterior(Listindex)
  ItemsMonatsSpalten|fffd|berschriftNumberFormat(Listindex) = "mmmm"
  Cells(C_Row_Columns_Headerformat, CColFirst + Listindex) = 36526 ' = 01.01.2000

  ItemsDatumNumberFormat(Listindex) = "dd ddd"
  Cells(C_Row_Columns_ColDate_Format, CColFirst + Listindex) = 36526 ' = 01.01.2000
  
  ItemsDatumVerticalAlignment(Listindex) = xlVAlignTop
  ItemsTextScale(Listindex) = 1
  ItemsTextVerticalAlignment(Listindex) = xlVAlignCenter
  For i = vbSunday To vbSaturday
    DefaultFont ItemsWeekdayFont(Listindex, i)
    DefaultInterior ItemsWeekdayInterior(Listindex, i)
  Next i
  ' Sonntag anpassen:
  With ItemsWeekdayInterior(Listindex, vbSunday)
    .ColorIndex = 15
    .Color = 12632256
    .Pattern = xlPatternSolid
    .PatternColor = 16711935
    .PatternColorIndex = xlColorIndexAutomatic
  End With
  With ItemsPublicdayInterior(Listindex)
    .ColorIndex = 48
    .Color = 9868950
    .Pattern = xlPatternSolid
    .PatternColor = 16711935
    .PatternColorIndex = xlColorIndexAutomatic
  End With
  With ItemsHolidaysInterior(Listindex)
    .ColorIndex = 20
    .Color = 16777164
    .Pattern = xlPatternSolid
    .PatternColor = 16711935
    .PatternColorIndex = xlColorIndexAutomatic
  End With
  ItemsHolidaysBeforePublic(Listindex) = True
  ItemsFormatCurrentday(Listindex) = False
  With ItemsCurrentdayInterior(Listindex)
    .ColorIndex = 3
    .Color = 255
    .Pattern = xlPatternSolid
    .PatternColor = 16711935
    .PatternColorIndex = -4105
  End With
  
  ItemsKWUse(Listindex) = True
  ItemsKWDistLeft(Listindex) = 35
  ItemsKWDistTop(Listindex) = 5
  ItemsKWStr(Listindex) = "#"
  ItemsMaximizeLineHeight(Listindex) = True
  ItemsDelimiterStr(Listindex) = ", "
  
  DefaultFont ItemsDelimiterFont(Listindex)
  ItemsLineHeightMin(Listindex) = 15
  GoTo Exit_ItemsClear
  
  
Err_ItemsClear:
  MsgBox Err.Description, vbCritical, , CTitleMsgBox
  GoTo Exit_ItemsClear
  
Exit_ItemsClear:
  If WasProtected Then Sch|fffd|tzen
  UpdateEnd
  
End Sub


Public Function ItemsClientWidthPoints(ByVal Index As Byte) As Double
  ItemsClientWidthPoints = ItemsPageWidth(Index, True) - ItemsMargin(Index, xlLeft, True) - ItemsMargin(Index, xlRight, True)
End Function



Public Function ItemsClientHeightPoints(ByVal Index As Byte) As Double
  ItemsClientHeightPoints = ItemsPageHeight(Index, True) _
    - MaxSng(ItemsMargin(Index, xlTop, True), ItemsHeaderMargin(Index, True)) _
    - MaxSng(ItemsMargin(Index, xlBottom, True), ItemsFooterMargin(Index, True))
End Function


Private Property Get ItemsColumnWidth(ByVal Index As Byte) As Double
  ItemsColumnWidth = Cells(C_Row_First, CColFirst + Index).ColumnWidth
End Property


Private Property Let ItemsColumnWidth(ByVal Index As Byte, ByVal d As Double)
On Error GoTo Err_ItemsColumnWidth
Dim WasProtected As Boolean
  
  If Not UnprotectCalendarWorksheet(Me, CPassword, WasProtected) Then Exit Property
  Cells(C_Row_First, CColFirst + Index).ColumnWidth = d
  ItemsKWSchemeaCenter Index
  GoTo Exit_ItemsColumnWidth
  
Err_ItemsColumnWidth:
  MsgBox Err.Description, vbCritical, CTitleMsgBox
  GoTo Exit_ItemsColumnWidth
  
Exit_ItemsColumnWidth:
  If WasProtected Then Sch|fffd|tzen
End Property


Private Function ItemsComments(ByVal Index As Integer, ByVal CommentIndex As Integer) As Comment
Dim i As Integer, CommentsCount As Integer
  
  For i = 1 To Comments.count
    If Comments(i).Parent.Column = Index + CColFirst Then
      If CommentIndex = CommentsCount Then
        Set ItemsComments = Comments(i)
        Exit Function
      End If
      CommentsCount = CommentsCount + 1
    End If
  Next i
  Set ItemsComments = Nothing

End Function




Private Function ItemsCommentsCount(ByVal Index As Integer) As Integer
Dim i As Integer, CommentsCount As Integer
  
  For i = 1 To Comments.count
    If Comments(i).Parent.Column = Index + CColFirst Then
      CommentsCount = CommentsCount + 1
    End If
  Next i
  ItemsCommentsCount = CommentsCount
End Function




Public Function ItemsCount() As Byte
Dim i As Byte
  i = 0
  While (ItemsCaption(i) <> "") And (i < ItemsCountMax)
    i = i + 1
  Wend
  ItemsCount = i
End Function


Public Function ItemsCountMax() As Byte
  ItemsCountMax = CColLast - CColFirst + 1
End Function


Public Property Get ItemsCurrentdayInterior(ByVal Index As Byte) As Interior
  Set ItemsCurrentdayInterior = ColorDaysInterior(C_Row_Colors_Formatcurrentday_Color, Index)
End Property


Private Property Let ItemsCurrentdayInterior(ByVal Index As Byte, AInterior As Interior)
  Set ColorDaysInterior(C_Row_Colors_Formatcurrentday_Color, Index) = AInterior
End Property



'Public Property Get ItemsDatumFont(ByVal index As Byte) As Font
'  Set ItemsDatumFont = Cells(C_Row_Columns_ColDate_Format, CColFirst + index).Font
'End Property


'Private Property Let ItemsDatumFont(ByVal index As Byte, AFont As Font)
'  Set Cells(C_Row_Columns_ColDate_Format, CColFirst + index).Font = AFont
'End Property


Public Property Get ItemsDatumNumberFormat(ByVal Index As Byte) As String
  ItemsDatumNumberFormat = Cells(C_Row_Columns_ColDate_Format, CColFirst + Index).NumberFormat
End Property


Private Property Let ItemsDatumNumberFormat(ByVal Index As Byte, NewNumberFormat As String)
  Cells(C_Row_Columns_ColDate_Format, CColFirst + Index).NumberFormat = NewNumberFormat
End Property


Public Property Get ItemsDatumVerticalAlignment(ByVal Index As Byte) As Integer
  ItemsDatumVerticalAlignment = TabData.VerticalAlignmentStrToIndex(Cells(C_Row_Columns_ColDate_VA, CColFirst + Index))
End Property


Private Property Let ItemsDatumVerticalAlignment(ByVal Index As Byte, ByVal NewDatumVerticalAlignment As Integer)
  Cells(C_Row_Columns_ColDate_VA, CColFirst + Index) = TabData.VerticalAlignmentIndexToStr(NewDatumVerticalAlignment)
End Property



Public Property Get ItemsDelimiterStr(ByVal Index As Byte) As String
  ItemsDelimiterStr = Cells(C_Row_Misc_DelimiterStr, CColFirst + Index)
End Property


Private Property Let ItemsDelimiterStr(ByVal Index As Byte, NewItemsDelimiterStr As String)
  Cells(C_Row_Misc_DelimiterStr, CColFirst + Index) = NewItemsDelimiterStr
End Property


Public Property Get ItemsDelimiterFont(ByVal Index As Byte) As Font
  Set ItemsDelimiterFont = Cells(C_Row_Misc_DelimiterStr, CColFirst + Index).Font
End Property


Private Property Let ItemsDelimiterFont(ByVal Index As Byte, AFont As Font)
  Set Cells(C_Row_Misc_DelimiterStr, CColFirst + Index).Font = AFont
End Property


Private Function ItemsFindByCaption(ByVal ACaption As String, ByVal ExcludeIndex As Integer, ByRef Index As Byte) As Boolean
Dim i As Integer

  For i = 0 To ItemsCount - 1
    If i <> ExcludeIndex Then
      If ItemsCaption(i) = ACaption Then
        Index = i
        ItemsFindByCaption = True
        Exit Function
      End If
    End If
  Next i
  ItemsFindByCaption = False
End Function


Public Property Get ItemsFooterMargin(ByVal Index As Byte, ByVal UsePoints As Boolean) As Double
  If UsePoints Then
    ItemsFooterMargin = Application.CentimetersToPoints(ItemsFooterMargin(Index, False))
  Else
    ItemsFooterMargin = GetDoubleVal(C_Row_PageSettings_Footer_Margin, CColFirst + Index, CDefault_Footer_Margin)
  End If
End Property


Private Property Let ItemsFooterMargin(ByVal Index As Byte, ByVal UsePoints As Boolean, ByVal NewVal As Double)
  If Not UsePoints Then Cells(C_Row_PageSettings_Footer_Margin, CColFirst + Index) = NewVal
End Property


Public Property Get ItemsFooterStr(ByVal Index As Byte, ByVal AOrientation As Integer, ByVal UseFormular As Boolean) As String
  Select Case AOrientation
    Case xlLeft
      ItemsFooterStr = CellsFormulaValueStr(C_Row_PageSettings_Footer_Left, CColFirst + Index, UseFormular)
    Case xlCenter
      ItemsFooterStr = CellsFormulaValueStr(C_Row_PageSettings_Footer_Center, CColFirst + Index, UseFormular)
    Case xlRight
      ItemsFooterStr = CellsFormulaValueStr(C_Row_PageSettings_Footer_Right, CColFirst + Index, UseFormular)
    Case Else
      Err.Raise CErrNum
   End Select
End Property

Private Property Let ItemsFooterStr(ByVal Index As Byte, ByVal AOrientation As Integer, ByVal UseFormular As Boolean, ByVal NewItemsFooterStr As String)
  Select Case AOrientation
    Case xlLeft
      CellsFormulaValueStr(C_Row_PageSettings_Footer_Left, CColFirst + Index, UseFormular) = NewItemsFooterStr
    Case xlCenter
      CellsFormulaValueStr(C_Row_PageSettings_Footer_Center, CColFirst + Index, UseFormular) = NewItemsFooterStr
    Case xlRight
      CellsFormulaValueStr(C_Row_PageSettings_Footer_Right, CColFirst + Index, UseFormular) = NewItemsFooterStr
    Case Else
      Err.Raise CErrNum
   End Select
End Property



Public Property Get ItemsFormatCurrentday(ByVal Index As Byte) As Boolean
  ItemsFormatCurrentday = TabData.StrIsYesStr(Cells(C_Row_Colors_Formatcurrentday, CColFirst + Index))
End Property


Private Property Let ItemsFormatCurrentday(ByVal Index As Byte, ByVal b As Boolean)
  Cells(C_Row_Colors_Formatcurrentday, CColFirst + Index) = TabData.YesNoStr(b)
End Property


Private Property Get ItemsFormatCurrentdayColorLocked(ByVal Index As Byte) As Boolean
  ItemsFormatCurrentdayColorLocked = Cells(C_Row_Colors_Formatcurrentday_Color, CColFirst + Index).Locked
End Property


Private Property Let ItemsFormatCurrentdayColorLocked(ByVal Index As Byte, ByVal NewFormatCurrentdayColorLocked As Boolean)
  If NewFormatCurrentdayColorLocked = ItemsFormatCurrentdayColorLocked(Index) Then Exit Property
  LockCells NewFormatCurrentdayColorLocked, Cells(C_Row_Colors_Formatcurrentday_Color, CColFirst + Index), False
End Property


Public Property Get ItemsHeaderMargin(ByVal Index As Byte, ByVal UsePoints As Boolean) As Double
  If UsePoints Then
    ItemsHeaderMargin = Application.CentimetersToPoints(ItemsHeaderMargin(Index, False))
  Else
    ItemsHeaderMargin = GetDoubleVal(C_Row_PageSettings_Header_Margin, CColFirst + Index, CDefault_Header_Margin)
  End If
End Property



Private Property Let ItemsHeaderMargin(ByVal Index As Byte, ByVal UsePoints As Boolean, ByVal NewVal As Double)
  If Not UsePoints Then Cells(C_Row_PageSettings_Header_Margin, CColFirst + Index) = NewVal
End Property



Public Property Get ItemsHeaderStr(ByVal Index As Byte, ByVal AOrientation As Integer, ByVal UseFormular As Boolean) As String
  Select Case AOrientation
    Case xlLeft
      ItemsHeaderStr = CellsFormulaValueStr(C_Row_PageSettings_Header_Left, CColFirst + Index, UseFormular)
    Case xlCenter
      ItemsHeaderStr = CellsFormulaValueStr(C_Row_PageSettings_Header_Center, CColFirst + Index, UseFormular)
    Case xlRight
      ItemsHeaderStr = CellsFormulaValueStr(C_Row_PageSettings_Header_Right, CColFirst + Index, UseFormular)
    Case Else
      Err.Raise CErrNum
  End Select
End Property


Private Property Let ItemsHeaderStr(ByVal Index As Byte, ByVal AOrientation As Integer, ByVal UseFormular As Boolean, ByVal s As String)
  
  Select Case AOrientation
    Case xlLeft
      CellsFormulaValueStr(C_Row_PageSettings_Header_Left, CColFirst + Index, UseFormular) = s
    Case xlCenter
      CellsFormulaValueStr(C_Row_PageSettings_Header_Center, CColFirst + Index, UseFormular) = s
    Case xlRight
      CellsFormulaValueStr(C_Row_PageSettings_Header_Right, CColFirst + Index, UseFormular) = s
    Case Else
      Err.Raise CErrNum
  End Select

End Property

Public Property Get ItemsHolidaysInterior(ByVal Index As Byte) As Interior
  Set ItemsHolidaysInterior = ColorDaysInterior(C_Row_Colors_Holiday, Index)
End Property



Public Property Get ItemsHolidaysBeforePublic(ByVal Index As Byte) As Boolean
  ItemsHolidaysBeforePublic = TabData.StrIsYesStr(Cells(C_Row_Colors_HolidaysBeforePublic, CColFirst + Index))
End Property

Public Property Let ItemsHolidaysBeforePublic(ByVal Index As Byte, ByVal b As Boolean)
  Cells(C_Row_Colors_HolidaysBeforePublic, CColFirst + Index) = TabData.YesNoStr(b)
End Property


Public Property Get ItemsKWDistLeft(ByVal Index As Byte) As Double
  ItemsKWDistLeft = Cells(C_Row_KW_DistLeft, CColFirst + Index)
End Property

Private Property Let ItemsKWDistLeft(ByVal Index As Byte, NewKWDistLeft As Double)
  Cells(C_Row_KW_DistLeft, CColFirst + Index) = NewKWDistLeft
End Property



Public Property Get ItemsKWDistTop(ByVal Index As Byte) As Double
  ItemsKWDistTop = Cells(C_Row_KW_DistTop, CColFirst + Index)
End Property

Private Property Let ItemsKWDistTop(ByVal Index As Byte, ByVal AValue As Double)
  Cells(C_Row_KW_DistTop, CColFirst + Index) = AValue
End Property


Private Property Get ItemsKWLocked(ByVal Index As Byte) As Boolean
  ItemsKWLocked = Cells(C_Row_KW_DistLeft, CColFirst + Index).Locked
End Property


Private Property Let ItemsKWLocked(ByVal Index As Byte, ByVal NewKWLocked As Boolean)
Dim ARange As Range
Dim AShape As Shape

  If NewKWLocked = ItemsKWLocked(Index) Then Exit Property
  Application.ScreenUpdating = False
  Set ARange = Range(Cells(C_Row_KW_Use + 1, CColFirst + Index), Cells(C_Row_KW_Last, CColFirst + Index))
  LockCells NewKWLocked, ARange, True
  
  'If GetShape(KWSchemaName + CStr(Index + 1), AShape) Then AShape.Visible = Not NewKWLocked
  If ItemsShapeHave(Index) Then ItemsShape(Index).Visible = Not NewKWLocked
 
  Application.ScreenUpdating = True
End Property


Private Sub ItemsKWSchemeaCenter(ByVal Index As Byte)
' Zentriert die KW-Grafik in der Spalte zu *index*
  If Not ItemsShapeHave(Index) Then Exit Sub
  With ItemsShape(Index)
    .Left = Columns(Index + CColFirst).Left + (Columns(Index + CColFirst).Width - .Width) \ 2
    .Top = Rows(C_Row_KW_Schema).Top + 10
  End With

End Sub




Public Property Get ItemsKWStr(ByVal Index As Byte) As String
  ItemsKWStr = Cells(C_Row_KW_Str, CColFirst + Index)
End Property


Private Property Let ItemsKWStr(ByVal Index As Byte, ByVal s As String)
  Cells(C_Row_KW_Str, CColFirst + Index) = s
End Property


Public Property Get ItemsKWUse(ByVal Index As Byte) As Boolean
  ItemsKWUse = TabData.StrIsYesStr(Cells(C_Row_KW_Use, CColFirst + Index))
End Property


Private Property Let ItemsKWUse(ByVal Index As Byte, ByVal b As Boolean)
  Cells(C_Row_KW_Use, CColFirst + Index) = TabData.YesNoStr(b)
End Property






Public Property Get ItemsLineHeightMin(ByVal Index As Byte) As Double
  ItemsLineHeightMin = GetDoubleVal(C_Row_Misc_LineHeightMin, Index + CColFirst, 12.75)
End Property


Private Property Let ItemsLineHeightMin(ByVal Index As Byte, ByVal NewVal As Double)
  Cells(C_Row_Misc_LineHeightMin, Index + CColFirst) = NewVal
End Property




Public Property Get ItemsMargin(ByVal Index As Byte, ByVal AOrientation As Integer, ByVal UsePoints As Boolean) As Double
  If UsePoints Then
    ItemsMargin = Application.CentimetersToPoints(ItemsMargin(Index, AOrientation, False))
  Else
    ItemsMargin = GetDoubleVal(MarginOrientationToRow(AOrientation), CColFirst + Index, CDefault_Margin)
  End If
End Property



Private Property Let ItemsMargin(ByVal Index As Byte, ByVal AOrientation As Integer, ByVal UsePoints As Boolean, ByVal NewVal As Double)
  If UsePoints Then
    Err.Raise CErrNum
  Else
    Cells(MarginOrientationToRow(AOrientation), CColFirst + Index) = NewVal
  End If
End Property


Public Property Get ItemsMaximizeLineHeight(ByVal Index As Byte) As Boolean
  ItemsMaximizeLineHeight = TabData.StrIsYesStr(Cells(C_Row_Misc_MaximizeLineHeight, CColFirst + Index))
End Property

Private Property Let ItemsMaximizeLineHeight(ByVal Index As Byte, ByVal b As Boolean)
  Cells(C_Row_Misc_MaximizeLineHeight, CColFirst + Index) = TabData.YesNoStr(b)
End Property









Public Property Get ItemsMonatsSpaltenBreite(ByVal Index As Byte) As Double
  ItemsMonatsSpaltenBreite = GetDoubleVal(C_Row_Columns_MonthWidth, CColFirst + Index, CDefault_MonatsSpaltenBreite)
End Property


Private Property Let ItemsMonatsSpaltenBreite(ByVal Index As Byte, NewVal As Double)
  Cells(C_Row_Columns_MonthWidth, CColFirst + Index) = NewVal
End Property


Public Property Get ItemsMonatsSpalten|fffd|berschriftFont(ByVal Index As Byte) As Font
  Set ItemsMonatsSpalten|fffd|berschriftFont = Cells(C_Row_Columns_Headerformat, CColFirst + Index).Font
End Property


Public Property Get ItemsMonatsSpalten|fffd|berschriftInterior(ByVal Index As Byte) As Interior
  Set ItemsMonatsSpalten|fffd|berschriftInterior = Cells(C_Row_Columns_Headerformat, CColFirst + Index).Interior
End Property


Public Property Get ItemsMonatsSpalten|fffd|berschriftNumberFormat(ByVal Index As Byte) As String
  ItemsMonatsSpalten|fffd|berschriftNumberFormat = Cells(C_Row_Columns_Headerformat, CColFirst + Index).NumberFormat
End Property

Private Property Let ItemsMonatsSpalten|fffd|berschriftNumberFormat(ByVal Index As Byte, ByVal NewVal As String)
  Cells(C_Row_Columns_Headerformat, CColFirst + Index).NumberFormat = NewVal
End Property


Public Property Get ItemsOrientationIndex(ByVal Index As Byte) As Byte
' Liefert "xlPortrait" oder "xlLandscape" zur|fffd|ck
  ItemsOrientationIndex = TabData.OrientationStrToIndex(Cells(C_Row_PageSettings_Orientation, CColFirst + Index))
End Property

Private Property Let ItemsOrientationIndex(ByVal Index As Byte, ByVal NewVal As Byte)
  Cells(C_Row_PageSettings_Orientation, CColFirst + Index) = TabData.OrientationIndexToStr(NewVal)
End Property



Private Property Get ItemsPageHeight(ByVal Index As Byte, ByVal UsePoints As Boolean) As Double
  If UsePoints Then
    ItemsPageHeight = Application.CentimetersToPoints(ItemsPageHeight(Index, False))
  Else
    ItemsPageHeight = GetDoubleVal(C_Row_PageSettings_PageHeight, CColFirst + Index, 29.7)
  End If
End Property


Private Property Let ItemsPageHeight(ByVal Index As Byte, ByVal UsePoints As Boolean, ByVal NewVal As Double)
  If Not UsePoints Then Cells(C_Row_PageSettings_PageHeight, CColFirst + Index) = NewVal
End Property


Public Property Get ItemsPageWidth(ByVal Index As Byte, ByVal UsePoints As Boolean) As Double
  If UsePoints Then
    ItemsPageWidth = Application.CentimetersToPoints(ItemsPageWidth(Index, False))
  Else
    ItemsPageWidth = GetDoubleVal(C_Row_PageSettings_PageWidth, CColFirst + Index, 21)
  End If
End Property


Private Property Let ItemsPageWidth(ByVal Index As Byte, ByVal UsePoints As Boolean, ByVal NewVal As Double)
  If Not UsePoints Then Cells(C_Row_PageSettings_PageWidth, CColFirst + Index) = NewVal
End Property



Public Property Get ItemsPaperSizeIndex(ByVal Index As Byte) As Integer
  ItemsPaperSizeIndex = TabData.PaperSizeStrToIndex(Cells(C_Row_PageSettings_PaperSize, CColFirst + Index))
End Property

Private Property Let ItemsPaperSizeIndex(ByVal Index As Byte, ByVal NewSizeIndex As Integer)
  Cells(C_Row_PageSettings_PaperSize, CColFirst + Index) = TabData.PaperSizeIndexToStr(NewSizeIndex)
End Property


Private Function ItemsLoadFromOpenIniFileValue(ByVal ASectionName As String, ByVal AKeyName As String, ByRef Value As String) As Boolean
' Hilfsfunktion zu ItemsLoadFromOpenIniFile: Falls Inifile.ASectionName.AKeyName einen nichtleeren String als Value hat,
' wird dieser nach *Value* transportiert und TRUE zur|fffd|ckgegeben, sonst FALSE
  Value = LoadFromOpenIniFileString(ASectionName, AKeyName)
  ItemsLoadFromOpenIniFileValue = Value <> ""
End Function


Private Function CaptionIsNumbered(ByVal ACaption As String, ByRef CaptionPrefix As String, ByRef ANumber As Integer) As Boolean
' Liefert TRUE, falls *ACaption* dem regul|fffd|ren Ausdruck ".*#[[:digit:]]+" entspricht. Zur|fffd|ckgegeben wird dann in *CaptionPrefix* der Teil
' bis zum "#"; in *ANumber* die entsprechende Zahl.
Dim i As Long, j As Long

  CaptionIsNumbered = False
  If ACaption = "" Then Exit Function
  i = CharPosLastGetCR(Asc("#"), ACaption)
  If i = 0 Then Exit Function
  If i = Len(ACaption) Then Exit Function
  For j = i + 1 To Len(ACaption)
    If Not CharIsDecDigit(Asc(Mid(ACaption, j, 1))) Then Exit Function
  Next j
  
  CaptionPrefix = Left(ACaption, i - 1)
  ANumber = CInt(Right(ACaption, Len(ACaption) - i))
  CaptionIsNumbered = True

End Function


Private Function ItemsLoadFromOpenIniFile(ByVal SectionName As String) As Boolean
' L|fffd|dt die Einstellungen aus dem angageben Abschnitt *SectionName*. Falls bereits eine Einstellung mit dem dort angegebenen Namen
' existiert, wird eine neuer Name ermittelt und die Einstellung angeh|fffd|ngt.
' Falls die Liste voll ist (ItemsCount>=ItemsCountMax), wird die Routine kommentarlos verlassen

On Error GoTo Err_ItemsLoadFromOpenIniFile
Dim s As String, CommentList As String, CaptionPrefix As String
Dim CaptionNumber As Integer
Dim i As Byte, Listindex As Byte
Dim WasProtected As Boolean
Dim StrIndex As Long, ADummy As Long, ARow As Long

  Application.StatusBar = Me.Name & ": Lade Eintrag " & CStr(ItemsCount + 1)
  ItemsLoadFromOpenIniFile = False
  
  If ItemsCount >= ItemsCountMax Then Exit Function

  If Not UnprotectCalendarWorksheet(Me, CPassword, WasProtected) Then Exit Function

  s = decodeURI(LoadFromOpenIniFileString(SectionName, CIniKeyCaption), True)

  While ItemsFindByCaption(s, -1, Listindex)
    If CaptionIsNumbered(s, CaptionPrefix, CaptionNumber) Then
      s = CaptionPrefix
    Else
      CaptionNumber = 0
      CaptionPrefix = s
    End If
    s = CaptionPrefix & "#" & CStr(CaptionNumber + 1)
  Wend
  Listindex = ItemsCount
  ItemsCaption(Listindex) = s
  
  StrIndex = 1
  CommentList = LoadFromOpenIniFileString(SectionName, CIniKeyComments)
  While TokenNext(CommentList, Asc(","), s, StrIndex, False)
    If LoadFromOpenIniFileCommentPos(s, ARow, ADummy) Then
      Cells(ARow, Listindex + CColFirst).AddComment
      LoadFromOpenIniFileComment s, Cells(ARow, Listindex + CColFirst).Comment
    End If
    StrIndex = StrIndex + 1
  Wend


  ItemsColumnWidth(Listindex) = LoadFromOpenIniFileDouble(SectionName, CIniKeyColumnWidth, ItemsColumnWidth(Listindex))
  
  ItemsPaperSizeIndex(Listindex) = LoadFromOpenInifileInteger(SectionName, CIniKeyPaperSizeIndex, ItemsPaperSizeIndex(Listindex))
  
  ItemsOrientationIndex(Listindex) = LoadFromOpenInifileInteger(SectionName, CIniKeyOrientationIndex, ItemsOrientationIndex(Listindex))
  ItemsZoom(Listindex) = LoadFromOpenIniFileDouble(SectionName, CIniKeyZoom, ItemsZoom(Listindex))
  ItemsMargin(Listindex, xlLeft, False) = LoadFromOpenIniFileDouble(SectionName, CIniKeyMarginLeft, ItemsMargin(Listindex, xlLeft, False))
  ItemsMargin(Listindex, xlRight, False) = LoadFromOpenIniFileDouble(SectionName, CIniKeyMarginRight, ItemsMargin(Listindex, xlRight, False))
  ItemsMargin(Listindex, xlTop, False) = LoadFromOpenIniFileDouble(SectionName, CIniKeyMarginTop, ItemsMargin(Listindex, xlTop, False))
  ItemsMargin(Listindex, xlBottom, False) = LoadFromOpenIniFileDouble(SectionName, CIniKeyMarginBottom, ItemsMargin(Listindex, xlBottom, False))
  ItemsHeaderStr(Listindex, xlLeft, True) = decodeURI(LoadFromOpenIniFileString(SectionName, CIniKeyHeaderLeft), True)
  
  ItemsHeaderStr(Listindex, xlCenter, True) = decodeURI(LoadFromOpenIniFileString(SectionName, CIniKeyHeaderCenter), True)
  ItemsHeaderStr(Listindex, xlRight, True) = decodeURI(LoadFromOpenIniFileString(SectionName, CIniKeyHeaderRight), True)
  ItemsHeaderMargin(Listindex, False) = LoadFromOpenIniFileDouble(SectionName, CIniKeyHeaderMargin, ItemsHeaderMargin(Listindex, False))
  
  ItemsFooterStr(Listindex, xlLeft, True) = decodeURI(LoadFromOpenIniFileString(SectionName, CIniKeyFooterLeft), True)
  ItemsFooterStr(Listindex, xlCenter, True) = decodeURI(LoadFromOpenIniFileString(SectionName, CIniKeyFooterCenter), True)
  ItemsFooterStr(Listindex, xlRight, True) = decodeURI(LoadFromOpenIniFileString(SectionName, CIniKeyFooterRight), True)
  ItemsFooterMargin(Listindex, False) = LoadFromOpenIniFileDouble(SectionName, CIniKeyFooterMargin, ItemsFooterMargin(Listindex, False))

  ItemsMonatsSpaltenBreite(Listindex) = LoadFromOpenIniFileDouble(SectionName, CIniKeyMonthWidth, ItemsMonatsSpaltenBreite(Listindex))
  
  If ItemsLoadFromOpenIniFileValue(SectionName, CIniKeyMonthHeaderFont, s) Then
    LoadFromOpenIniFileFont s, ItemsMonatsSpalten|fffd|berschriftFont(Listindex)
  End If
  If ItemsLoadFromOpenIniFileValue(SectionName, CIniKeyMonthHeaderInterior, s) Then
    LoadFromOpenIniFileInterior s, ItemsMonatsSpalten|fffd|berschriftInterior(Listindex)
  End If
  ItemsMonatsSpalten|fffd|berschriftNumberFormat(Listindex) = decodeURI(LoadFromOpenIniFileString(SectionName, CIniKeyMonthHeaderNumberformat), True)
  
  
  
  ItemsDatumNumberFormat(Listindex) = decodeURI(LoadFromOpenIniFileString(SectionName, CIniKeyDateNumberFormat), True)
  ItemsDatumVerticalAlignment(Listindex) = LoadFromOpenInifileInteger(SectionName, CIniKeyDateVerticalAlignment, ItemsDatumVerticalAlignment(Listindex))
  ItemsTextScale(Listindex) = LoadFromOpenIniFileDouble(SectionName, CIniKeyTextScale, ItemsTextScale(Listindex))
  ItemsTextVerticalAlignment(Listindex) = LoadFromOpenInifileInteger(SectionName, CIniKeyTextVerticalAlignment, ItemsTextVerticalAlignment(Listindex))
  
  For i = vbSunday To vbSaturday
    If ItemsLoadFromOpenIniFileValue(SectionName, CIniKeyWeekdayPrefixFont & CStr(i), s) Then
      LoadFromOpenIniFileFont s, ItemsWeekdayFont(Listindex, i)
    End If
    If ItemsLoadFromOpenIniFileValue(SectionName, CIniKeyWeekdayPrefixInterieur & CStr(i), s) Then
      LoadFromOpenIniFileInterior s, ItemsWeekdayInterior(Listindex, i)
    End If
  Next i
  
  If ItemsLoadFromOpenIniFileValue(SectionName, CIniKeyColorPublics, s) Then LoadFromOpenIniFileInterior s, ItemsPublicdayInterior(Listindex)
  If ItemsLoadFromOpenIniFileValue(SectionName, CIniKeyColorHolidays, s) Then LoadFromOpenIniFileInterior s, ItemsHolidaysInterior(Listindex)
  ItemsHolidaysBeforePublic(Listindex) = LoadFromOpenIniFileBoolean(SectionName, CIniKeyHolidaysBeforePublic, ItemsHolidaysBeforePublic(Listindex))
  
  ItemsFormatCurrentday(Listindex) = LoadFromOpenIniFileBoolean(SectionName, CIniKeyFormatcurrentday, ItemsFormatCurrentday(Listindex))
  If ItemsLoadFromOpenIniFileValue(SectionName, CIniKeyFormatcurrentdayFormat, s) Then LoadFromOpenIniFileInterior s, ItemsCurrentdayInterior(Listindex)
  
  ItemsKWUse(Listindex) = LoadFromOpenIniFileBoolean(SectionName, CIniKeyKWUse, ItemsKWUse(Listindex))
  ItemsKWDistLeft(Listindex) = LoadFromOpenIniFileDouble(SectionName, CIniKeyKWDistLeft, ItemsKWDistLeft(Listindex))
  ItemsKWDistTop(Listindex) = LoadFromOpenIniFileDouble(SectionName, CIniKeyKWDistTop, ItemsKWDistTop(Listindex))
  ItemsKWStr(Listindex) = decodeURI(LoadFromOpenIniFileString(SectionName, CIniKeyKWStr), True)

  If ItemsShapeHave(Listindex) Then
    s = LoadFromOpenIniFileString(SectionName, CIniSection_PrefixShape)
    If s <> "" Then LoadFromOpenIniFileShape s, ItemsShape(Listindex)
    ItemsKWSchemeaCenter Listindex
  End If
  ItemsMaximizeLineHeight(Listindex) = LoadFromOpenIniFileBoolean(SectionName, CIniKeyMaximizeLineHeight, ItemsMaximizeLineHeight(Listindex))
  ItemsDelimiterStr(Listindex) = decodeURI(LoadFromOpenIniFileString(SectionName, CIniKeyDelimiterStr), True)
  If ItemsLoadFromOpenIniFileValue(SectionName, CIniKeyDelimiterFont, s) Then
    LoadFromOpenIniFileFont s, ItemsDelimiterFont(Listindex)
  End If
  ItemsLineHeightMin(Listindex) = LoadFromOpenIniFileDouble(SectionName, CIniKeyLineHeightMin, ItemsLineHeightMin(Listindex))
  ItemsLoadFromOpenIniFile = True
  GoTo Exit_ItemsLoadFromOpenIniFile
  
Err_ItemsLoadFromOpenIniFile:
  MsgBox Err.Description, CTitleMsgBox
  ItemsLoadFromOpenIniFile = False
  GoTo Exit_ItemsLoadFromOpenIniFile

Exit_ItemsLoadFromOpenIniFile:
  If WasProtected Then Sch|fffd|tzen
  Application.StatusBar = False
End Function





Private Function ItemsSaveToOpenIniFile(ByVal Listindex As Byte, ByVal SectionName As String) As Boolean
Dim i As Integer
Dim s As String, CommentSectionname As String
Dim AComment As Comment
  
  
  Application.StatusBar = Me.Name & ": Speichere Eintrag " & CStr(Listindex + 1)
  For i = 0 To ItemsCommentsCount(Listindex) - 1
    Set AComment = ItemsComments(Listindex, i)
    CommentSectionname = CIniPrefixComment & CStr(NextFreeSectionID)
    s = s & CommentSectionname & ","
    SaveToOpenIniFileComment CommentSectionname, AComment, AComment.Parent.Row, AComment.Parent.Column
  Next i
  If s <> "" Then
    s = Left(s, Len(s) - 1)
    SaveToOpenIniFileString SectionName, CIniKeyComments, s
  End If
  
  SaveToOpenIniFileDouble SectionName, CIniKeyColumnWidth, ItemsColumnWidth(Listindex)
  SaveToOpenIniFileString SectionName, CIniKeyCaption, encodeURI(ItemsCaption(Listindex), True)
  SaveToOpenIniFileInteger SectionName, CIniKeyPaperSizeIndex, ItemsPaperSizeIndex(Listindex)
  SaveToOpenIniFileInteger SectionName, CIniKeyOrientationIndex, ItemsOrientationIndex(Listindex)
  SaveToOpenIniFileDouble SectionName, CIniKeyZoom, ItemsZoom(Listindex)
  SaveToOpenIniFileDouble SectionName, CIniKeyMarginLeft, ItemsMargin(Listindex, xlLeft, False)
  SaveToOpenIniFileDouble SectionName, CIniKeyMarginRight, ItemsMargin(Listindex, xlRight, False)
  SaveToOpenIniFileDouble SectionName, CIniKeyMarginTop, ItemsMargin(Listindex, xlTop, False)
  SaveToOpenIniFileDouble SectionName, CIniKeyMarginBottom, ItemsMargin(Listindex, xlBottom, False)
  SaveToOpenIniFileString SectionName, CIniKeyHeaderLeft, encodeURI(ItemsHeaderStr(Listindex, xlLeft, True), True)
  SaveToOpenIniFileString SectionName, CIniKeyHeaderCenter, encodeURI(ItemsHeaderStr(Listindex, xlCenter, True), True)
  SaveToOpenIniFileString SectionName, CIniKeyHeaderRight, encodeURI(ItemsHeaderStr(Listindex, xlRight, True), True)
  SaveToOpenIniFileDouble SectionName, CIniKeyHeaderMargin, ItemsHeaderMargin(Listindex, False)
  
  SaveToOpenIniFileString SectionName, CIniKeyFooterLeft, encodeURI(ItemsFooterStr(Listindex, xlLeft, True), True)
  SaveToOpenIniFileString SectionName, CIniKeyFooterCenter, encodeURI(ItemsFooterStr(Listindex, xlCenter, True), True)
  SaveToOpenIniFileString SectionName, CIniKeyFooterRight, encodeURI(ItemsFooterStr(Listindex, xlRight, True), True)
  SaveToOpenIniFileDouble SectionName, CIniKeyFooterMargin, ItemsFooterMargin(Listindex, False)

  SaveToOpenIniFileDouble SectionName, CIniKeyMonthWidth, ItemsMonatsSpaltenBreite(Listindex)
  
  SaveToOpenIniFileString SectionName, CIniKeyMonthHeaderFont, SaveToOpenIniFileFont(ItemsMonatsSpalten|fffd|berschriftFont(Listindex))
  SaveToOpenIniFileString SectionName, CIniKeyMonthHeaderInterior, SaveToOpenIniFileInterior(ItemsMonatsSpalten|fffd|berschriftInterior(Listindex))
  SaveToOpenIniFileString SectionName, CIniKeyMonthHeaderNumberformat, encodeURI(ItemsMonatsSpalten|fffd|berschriftNumberFormat(Listindex), True)
  
  SaveToOpenIniFileString SectionName, CIniKeyDateNumberFormat, encodeURI(ItemsDatumNumberFormat(Listindex), True)
  SaveToOpenIniFileInteger SectionName, CIniKeyDateVerticalAlignment, ItemsDatumVerticalAlignment(Listindex)
  SaveToOpenIniFileDouble SectionName, CIniKeyTextScale, ItemsTextScale(Listindex)
  SaveToOpenIniFileInteger SectionName, CIniKeyTextVerticalAlignment, ItemsTextVerticalAlignment(Listindex)
  
  For i = vbSunday To vbSaturday
    SaveToOpenIniFileString SectionName, CIniKeyWeekdayPrefixFont & CStr(i), SaveToOpenIniFileFont(ItemsWeekdayFont(Listindex, i))
    SaveToOpenIniFileString SectionName, CIniKeyWeekdayPrefixInterieur & CStr(i), SaveToOpenIniFileInterior(ItemsWeekdayInterior(Listindex, i))
  Next i
  
  
  SaveToOpenIniFileString SectionName, CIniKeyColorPublics, SaveToOpenIniFileInterior(ItemsPublicdayInterior(Listindex))
  SaveToOpenIniFileString SectionName, CIniKeyColorHolidays, SaveToOpenIniFileInterior(ItemsHolidaysInterior(Listindex))
  SaveToOpenIniFileBoolean SectionName, CIniKeyHolidaysBeforePublic, ItemsHolidaysBeforePublic(Listindex)
 
  SaveToOpenIniFileBoolean SectionName, CIniKeyFormatcurrentday, ItemsFormatCurrentday(Listindex)
  SaveToOpenIniFileString SectionName, CIniKeyFormatcurrentdayFormat, SaveToOpenIniFileInterior(ItemsCurrentdayInterior(Listindex))
  
  SaveToOpenIniFileBoolean SectionName, CIniKeyKWUse, ItemsKWUse(Listindex)
  SaveToOpenIniFileDouble SectionName, CIniKeyKWDistLeft, ItemsKWDistLeft(Listindex)
  SaveToOpenIniFileDouble SectionName, CIniKeyKWDistTop, ItemsKWDistTop(Listindex)
  SaveToOpenIniFileString SectionName, CIniKeyKWStr, encodeURI(ItemsKWStr(Listindex), True)
  If ItemsShapeHave(Listindex) Then
    s = CIniSection_PrefixShape & CStr(NextFreeSectionID)
    SaveToOpenIniFileShape s, ItemsShape(Listindex)
    SaveToOpenIniFileString SectionName, CIniSection_PrefixShape, s
  End If
  SaveToOpenIniFileBoolean SectionName, CIniKeyMaximizeLineHeight, ItemsMaximizeLineHeight(Listindex)
  SaveToOpenIniFileString SectionName, CIniKeyDelimiterStr, encodeURI(ItemsDelimiterStr(Listindex), True)
  SaveToOpenIniFileString SectionName, CIniKeyDelimiterFont, SaveToOpenIniFileFont(ItemsDelimiterFont(Listindex))
  SaveToOpenIniFileDouble SectionName, CIniKeyLineHeightMin, ItemsLineHeightMin(Listindex)

  ItemsSaveToOpenIniFile = True
End Function


Public Property Get ItemsShape(ByVal Index As Byte) As Shape
Dim ShapeIndex As Integer
  If ItemsShapeHave(Index, ShapeIndex) Then
    Set ItemsShape = Shapes(ShapeIndex)
  Else
    Err.Raise CErrNum
  End If
End Property




Public Function ItemsShapeHave(ByVal Index As Byte, Optional ShapeIndex As Integer) As Boolean
Static LastIndex As Byte
Static LastIndexHave As Boolean ' wird als FALSE initialisiert
Static LastShapeIndex As Integer
Dim i As Integer

  If LastIndexHave Then
    If LastIndex = Index Then
      ItemsShapeHave = True
      If Not IsMissing(ShapeIndex) Then ShapeIndex = LastShapeIndex
      Exit Function
    End If
  End If
  
  For i = 1 To Shapes.count
    If Shapes(i).Name = CKWShapenamePrefix & CStr(Index) Then
      If Not IsMissing(ShapeIndex) Then ShapeIndex = i
      LastIndexHave = True
      LastIndex = Index
       LastShapeIndex = i
      ItemsShapeHave = True
      Exit Function
    End If
  Next i
  ItemsShapeHave = False
End Function


Public Property Get ItemsTextVerticalAlignment(ByVal Index As Byte) As Integer
  ItemsTextVerticalAlignment = TabData.VerticalAlignmentStrToIndex(Cells(C_Row_Columns_ColCaption_VA, CColFirst + Index))
End Property


Private Property Let ItemsTextVerticalAlignment(ByVal Index As Byte, NewTextVerticalAlignment As Integer)
  Cells(C_Row_Columns_ColCaption_VA, CColFirst + Index) = TabData.VerticalAlignmentIndexToStr(NewTextVerticalAlignment)
End Property




Public Property Get ItemsPublicdayInterior(ByVal Index As Byte) As Interior
  Set ItemsPublicdayInterior = ColorDaysInterior(C_Row_Colors_Publicday, Index)
End Property

'Private Property Let ItemsPublicdayColor(ByVal Index As Byte, AInterior As Interior)
'  Set ItemsPublicdayColor = ColorDays(C_Row_Colors_Publicday, Index)
'End Property


Public Property Get ItemsTextScale(ByVal Index As Byte) As Double
  ItemsTextScale = GetDoubleVal(C_Row_Columns_ColCaption_TextScale, CColFirst + Index, 1)
End Property


Private Property Let ItemsTextScale(ByVal Index As Byte, ByVal d As Double)
  Cells(C_Row_Columns_ColCaption_TextScale, CColFirst + Index) = d
End Property


Public Property Get ItemsWeekdayColor(ByVal Index As Byte, ByVal AWeekday As Byte) As Interior
  Set ItemsWeekdayColor = ColorDaysInterior(C_Row_Colors_WeekdaysFirst + AWeekday - 1, Index)
End Property



Public Property Get ItemsWeekdayFont(ByVal Index As Byte, ByVal AWeekday As Byte) As Font
  Set ItemsWeekdayFont = Cells(C_Row_Colors_WeekdaysFirst + AWeekday - 1, CColFirst + Index).Font
End Property


'Private Property Let ItemsWeekdayFont(ByVal index As Byte, ByVal AWeekday As Byte, AFont As Font)
'  Set Cells(C_Row_Colors_WeekdaysFirst + AWeekday - 1, CColFirst + index).Font = AFont
'End Property


Public Property Get ItemsWeekdayInterior(ByVal Index As Byte, ByVal AWeekday As Byte) As Interior
  Set ItemsWeekdayInterior = Cells(C_Row_Colors_WeekdaysFirst + AWeekday - 1, CColFirst + Index).Interior
End Property



Public Property Get ItemsZoom(ByVal Index As Byte) As Double
Dim z As Double
  z = GetDoubleVal(C_Row_PageSettings_Zoom, CColFirst + Index, 1) * 100
  If z < 10 Then
    ItemsZoom = 10
  Else
    If z > 400 Then
      ItemsZoom = 400
    Else
      ItemsZoom = z
    End If
  End If
End Property


Private Property Let ItemsZoom(ByVal Index As Byte, ByVal NewVal As Double)
  Cells(C_Row_PageSettings_Zoom, CColFirst + Index) = NewVal / 100
End Property



Private Function LockCells(ByVal DoLock As Boolean, ByVal ARange As Range, ByVal UseColorIndex As Boolean) As Boolean
' Dient dazu, bei Auswahl|fffd|nderungen abh|fffd|ngige Zellen zu aktivieren/deaktivieren
On Error GoTo Err_LockCells
Dim WasProtected As Boolean
  
  
  LockCells = False
  
  If Not UnprotectCalendarWorksheet(Me, CPassword, WasProtected) Then Exit Function
  
  ARange.Locked = DoLock
  If UseColorIndex Then
    If DoLock Then
      ARange.Interior.ColorIndex = 15 ' grau
      ARange.Interior.Pattern = xlSolid
      ARange.Interior.PatternColorIndex = xlAutomatic
    Else
      ARange.Interior.ColorIndex = xlNone
    End If
  End If
  LockCells = True
  GoTo Exit_LockCells
  
Err_LockCells:
  MsgBox Err.Description, vbCritical, CTitleMsgBox
  Resume Exit_LockCells
  
Exit_LockCells:
  If WasProtected Then Sch|fffd|tzen
End Function




Private Sub Sch|fffd|tzen()
Dim APasswd As String
   
  If Registered Then APasswd = "" Else APasswd = CPassword
  Protect Password:=APasswd, DrawingObjects:=False, Contents:=True, Scenarios:=True

End Sub


'Private Property Let Gesch|fffd|tzt(ByVal Sch|fffd|tzen As Boolean)
'Dim APasswd As String
'Dim dummy As Boolean
'
'  If Sch|fffd|tzen = Gesch|fffd|tzt Then Exit Property
'  If Sch|fffd|tzen Then
'    If Registered Then APasswd = "" Else APasswd = CPassword
'    Protect Password:=APasswd, DrawingObjects:=False, Contents:=True, Scenarios:=True
'  Else
'    UnprotectCalendarWorksheet Me, CPassword, dummy
'  End If
'End Property


Public Property Get Gesperrt() As Boolean
' Falls gesperrt, k|fffd|nnen die Felder "Kopfzeile links oben" nicht bearbeitet werden
  Gesperrt = Range(Cells(C_Row_PageSettings_Header_Left, CColFirst).Address & ":" & Cells(C_Row_PageSettings_Header_Left, 256).Address).Locked
End Property



Public Property Let Gesperrt(Sperren As Boolean)
On Error GoTo Err_Gesperrt
Dim ScreenUpdatingOld As Boolean, WarGesch|fffd|tzt As Boolean
Dim AColorIndex As Integer

  If Gesperrt = Sperren Then Exit Property

  If Not UnprotectCalendarWorksheet(Me, CPassword, WarGesch|fffd|tzt) Then Exit Property
  ScreenUpdatingOld = Application.ScreenUpdating
  Application.ScreenUpdating = False
  If Sperren Then AColorIndex = 15 Else AColorIndex = xlColorIndexNone

  With Range(Cells(C_Row_PageSettings_Header_Left, CColFirst).Address & ":" & Cells(C_Row_PageSettings_Header_Left, 256).Address)
    .Locked = Sperren
    .Interior.ColorIndex = AColorIndex
  End With
  GoTo Exit_Gesperrt

Err_Gesperrt:
  MsgBox Err.Description, vbCritical, CTitleMsgBox
  Resume Exit_Gesperrt

Exit_Gesperrt:
  Application.ScreenUpdating = ScreenUpdatingOld
  If WarGesch|fffd|tzt Then Sch|fffd|tzen
End Property



Private Function MarginOrientationToRow(ByVal AOrientation As Integer) As Byte
  Select Case AOrientation
    Case xlBottom
      MarginOrientationToRow = C_Row_PageSettings_Margins_Bottom
    Case xlLeft
      MarginOrientationToRow = C_Row_PageSettings_Margins_Left
    Case xlRight
      MarginOrientationToRow = C_Row_PageSettings_Margins_Right
    Case xlTop
      MarginOrientationToRow = C_Row_PageSettings_Margins_Top
    Case Else
      Err.Raise CErrNum
  End Select
End Function







Private Function RowIsColorsWeekday(ByVal Row As Integer) As Boolean
' Hilfsfunktion zu *Worksheet_SelectionChange*
  RowIsColorsWeekday = (Row >= C_Row_Colors_WeekdaysFirst) And (Row <= C_Row_Colors_WeekdaysLast)
End Function



Public Function SaveToOpenIniFile(ByRef ItemsTreated As Long) As Boolean
' Aufbau:
'[TabSettings]
' Items=TabSettingsItem1,TabSettingsItem2,...
'[TabSettingsItem1]
' siehe *ItemsSaveToOpenIniFile*

Dim i As Integer
Dim s As String, SectionName As String
Dim result As Boolean

  For i = 0 To ItemsCount - 1
    SectionName = CodeName & CIniPrefixSectionItems & CStr(i)
    result = result Or ItemsSaveToOpenIniFile(i, SectionName)
    s = s & SectionName & ","
    ItemsTreated = ItemsTreated + 1
  Next i
  If s <> "" Then
    s = Left(s, Len(s) - 1)
    SaveToOpenIniFileString CodeName, CIniKey_Items, s
  End If
  SaveToOpenIniFile = result
End Function


Public Function LoadFromOpenIniFile(ByRef ItemsTreated As Long) As Boolean
Dim Itemlist As String, s As String
Dim l As Long, CountImported As Long
Dim WasProtected As Boolean, result As Boolean
  
  
  result = False
  If Not UnprotectCalendarWorksheet(Me, CPassword, WasProtected) Then Exit Function
  result = True
  Itemlist = LoadFromOpenIniFileString(CodeName, CIniKey_Items)
  While TokenNext(Itemlist, Asc(","), s, l, False)
    If ItemsCount >= ItemsCountMax Then ' Fehler: kann keine weiteren Items importieren
      ' Anzahl der Items ermitteln:
      MsgBox "Fehler beim Import der Schemaeinstellungen: Es steht kein Platz  f|fffd|r weitere Schemadefinitionen zur Verf|fffd|gung. " _
       & " Von " & CStr(CountChars(Itemlist, Asc(","), 1, Len(Itemlist)) + 1) & " vorhandenen Definitionen wurden nur " & CStr(CountImported) & " importiert.", vbCritical, CTitleMsgBox
      Exit Function
    End If
    If Not ItemsLoadFromOpenIniFile(s) Then result = False
    ItemsTreated = ItemsTreated + 1
    CountImported = CountImported + 1
    l = l + 1
  Wend
  
  If WasProtected Then Protect
  LoadFromOpenIniFile = result
End Function


Public Sub MakeDist()
Dim i As Integer
Dim PrevVisible As Long
  PrevVisible = Visible
  Visible = xlSheetVisible
  Activate
  For i = 0 To ItemsCount - 1
    ItemsMaximizeLineHeight(i) = True
  Next i
  Cells(C_Row_First, CColFirst).Select
  ActiveWindow.ScrollRow = C_Row_First
  
  If Not Me.ProtectContents Then Protect CPassword
  Visible = PrevVisible

End Sub


Private Sub SpinButtonResizeColWidth_Change()
On Error GoTo Err_SpinButtonResizeColWidth

Dim WasProtected As Boolean, OldIgnoreSpinButtonResizeColWidthChange As Boolean

  If fIgnoreSpinButtonResizeColWidthChange Then Exit Sub
  
  If Not UnprotectCalendarWorksheet(Me, CPassword, WasProtected) Then Exit Sub
  Columns(ActiveCell.Column).ColumnWidth = SpinButtonResizeColWidth.Value
  ItemsKWSchemeaCenter ActiveCell.Column - CColFirst
  
  GoTo Exit_SpinButtonResizeColWidth
  
Err_SpinButtonResizeColWidth:
  If Err.Number <> 1004 Then MsgBox Err.Description, vbCritical, CTitleMsgBox
  Resume Exit_SpinButtonResizeColWidth
  
Exit_SpinButtonResizeColWidth:
  If Columns(ActiveCell.Column).ColumnWidth <> SpinButtonResizeColWidth.Value Then
    OldIgnoreSpinButtonResizeColWidthChange = fIgnoreSpinButtonResizeColWidthChange
    fIgnoreSpinButtonResizeColWidthChange = True
    SpinButtonResizeColWidth.Value = Columns(ActiveCell.Column).ColumnWidth
    fIgnoreSpinButtonResizeColWidthChange = OldIgnoreSpinButtonResizeColWidthChange
  End If
  If WasProtected Then Sch|fffd|tzen

End Sub





Private Sub Worksheet_Activate()
  If TabInfos.TabselectionCodeUse Then
    ActiveWindow.DisplayHeadings = False
    ActiveSheet.DisplayAutomaticPageBreaks = False
    EnableSelection = xlUnlockedCells
    If Not Gesch|fffd|tzt Then Sch|fffd|tzen
  End If
End Sub


Private Sub Worksheet_Change(ByVal Target As Range)
' Fixme: die vorhandenen Ereignisroutinen arbeiten fehlerhaft, wenn der Bereich der |fffd|nderung mehrere Spalten umfa|fffd|t
Dim Index As Byte, zeile As Byte, spalte As Byte
Dim ContentIsOk As Boolean

  If Target.Column < CColFirst Then Exit Sub
  
  Index = Target.Column - CColFirst
  Select Case Target.Row
    
    Case C_Row_KW_Use ' abh|fffd|ngige Zellen sperren, falls keine Kalenderwochen angezeigt werden sollen:
      ItemsKWLocked(Index) = Not ItemsKWUse(Index)
    
    Case C_Row_Colors_Formatcurrentday
      ItemsFormatCurrentdayColorLocked(Index) = Not ItemsFormatCurrentday(Index)
    
    Case C_Row_Colors_WeekdaysFirst To C_Row_Colors_WeekdaysLast, C_Row_Colors_Publicday, C_Row_Colors_Holiday
      ContentIsOk = True
      For zeile = 1 To Target.Rows.count
        For spalte = 1 To Target.Columns.count
          If Target.Cells(zeile, spalte).Formula <> "=$B" & CStr(Target.Cells(zeile, spalte).Row) Then
            ContentIsOk = False
            Exit For
          End If
        Next spalte
      Next zeile
      
      If Not ContentIsOk Then
        If MsgBox("Sie sollten den Textinhalt dieser Zellen nicht |fffd|ndern. Zum Einstellen der Farbe und der Schraffierung w|fffd|hlen Sie die Schaltfl|fffd|che 'Farbe...' oben links." & vbNewLine & "Soll der vorherige Inhalt wiederhergestellt werden?", vbInformation Or vbYesNo, CTitleMsgBox) = vbYes Then
          For zeile = 1 To Target.Rows.count
            For spalte = 1 To Target.Columns.count
              If Target.Cells(zeile, spalte).Formula <> "=$B" & CStr(Target.Cells(zeile, spalte).Row) Then
                Target.Cells(zeile, spalte).Formula = "=$B" & CStr(Target.Cells(zeile, spalte).Row)
              End If
            Next spalte
          Next zeile
        End If
      End If
    Case C_Row_Caption
      If ItemsFindByCaption(ItemsCaption(Index), Index, spalte) Then
        If Index <> spalte Then
          MsgBox "Die Schemabenennung '" & ItemsCaption(Index) & "' existiert bereits in Spalte " & CStr(spalte + CColFirst) & ". Die Schemabenennungen sollten eindeutig sein, um sie unterscheiden zu k|fffd|nnen.", vbInformation, CTitleMsgBox
        End If
      End If
  End Select

End Sub

Private Sub Worksheet_Deactivate()
  If TabInfos.TabselectionCodeUse Then Visible = xlSheetHidden
End Sub


Private Sub Worksheet_SelectionChange(ByVal Target As Range)
On Error GoTo Err_Worksheet_SelectionChange

  fIgnoreSpinButtonResizeColWidthChange = True
  SpinButtonResizeColWidth.Value = Columns(Target.Column).ColumnWidth
  fIgnoreSpinButtonResizeColWidthChange = False
  
  ButtonZahlenformatAendern.Enabled = _
    (Target.Row = C_Row_Columns_ColDate_Format) Or _
    (Target.Row = C_Row_Columns_Headerformat)
  ButtonSchriftartAendern.Enabled = _
    (RowIsColorsWeekday(Target.Row)) Or _
    (Target.Row = C_Row_Misc_DelimiterStr) Or _
    (Target.Row = C_Row_Columns_Headerformat)
  ButtonFarbeAendern.Enabled = _
    (RowIsColorsWeekday(Target.Row)) Or _
    (Target.Row = C_Row_Colors_Publicday) Or _
    (Target.Row = C_Row_Colors_Formatcurrentday_Color) Or _
    (Target.Row = C_Row_Colors_Holiday) Or _
    (Target.Row = C_Row_Columns_Headerformat)


Err_Worksheet_SelectionChange:
  Resume Exit_Worksheet_SelectionChange

Exit_Worksheet_SelectionChange:
  fIgnoreSpinButtonResizeColWidthChange = False
  
End Sub




Attribute VB_Name = "TabYearly"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Control = "ButtonDLGNumberformat, 8, 0, MSForms, CommandButton"
Attribute VB_Control = "ButtonDLGFont, 67, 1, MSForms, CommandButton"
Attribute VB_Control = "ButtonSort, 103, 2, MSForms, CommandButton"
Attribute VB_Control = "ButtonYearlyZoom, 105, 3, MSForms, CommandButton"
Attribute VB_Control = "ButtonCheckItems, 106, 4, MSForms, CommandButton"
Attribute VB_Control = "ButtonSelectInfos, 107, 5, MSForms, CommandButton"
Attribute VB_Control = "ButtonImport, 150, 6, MSForms, CommandButton"
Option Explicit



Private Const CColZoomfactor        As Byte = 3
Private Const CRowZoomfactor        As Byte = 2
Private Const CRowColumnCaptions    As Byte = 5

Private Const CColDay        As Byte = 1
Private Const CColMonth      As Byte = 2
Private Const CColYear       As Byte = 3
Private Const CColHelper     As Byte = 4
Private Const CColCaption    As Byte = 5
Private Const CColFontsize   As Byte = 6
Private Const CColDoshow     As Byte = 7

Private Const CColDataFirst  As Byte = CColDay
Private Const CColDataLast   As Byte = CColDoshow

Private Const CRowDataFirst  As Byte = 6

Private Const CIniPrefixSectionItems    As String = "Item"
Private Const CIniKey_Items             As String = "Items"

Private Const CIniKey_Zoom As String = "Zoom"

Private Const CIniKey_ItemsComments             As String = "Comments"
Private Const CIniKey_ItemsDay                  As String = "Day"
Private Const CIniKey_ItemsMonth                As String = "Month"
Private Const CIniKey_ItemsYear                 As String = "Year"
Private Const CIniKey_ItemsHelpCell             As String = "HelpCell"
Private Const CIniKey_ItemsHelpCellNumberformat As String = "HelpCellNumberformat"
Private Const CIniKey_ItemsCaption              As String = "Caption"
Private Const CIniKey_ItemsFontsize             As String = "Fontsize"
Private Const CIniKey_ItemsDoshow               As String = "Doshow"

Private Const CDefaultFontSize As Double = 4.5

Private Const CErrCode_ImportOutlook_DateBegin As Byte = 1
Private Const CErrCode_ImportOutlook_DateEnd   As Byte = 2
Private Const CErrCode_ImportOutlook_Wholeday  As Byte = 3
Private Const CErrCode_ImportOutlook_Caption   As Byte = 4



Private fCurrentRow As Integer
Private fCurrentYear As Integer
Private fSortOrder As Byte



Private Sub ButtonCheckItems_Click()
Dim i As Integer
Dim LastRow As Long
Dim LastCol As Byte
Dim ErrCol As Byte
  For i = 0 To ItemsCount - 1
    ErrCol = ItemsCheck(i, True)
    If ErrCol <> 0 Then
      Cells(i + CRowDataFirst, ErrCol).Select
      Exit Sub
    End If
  Next i
  For i = CColDataFirst To CColFontsize
    If Cells(Rows.count, i).End(xlUp).Row > LastRow Then
      LastCol = i
      LastRow = Cells(Rows.count, i).End(xlUp).Row
    End If
  Next i
  If LastRow >= ItemsCount + CRowDataFirst Then
    MsgBox "Nach Zeile " & CStr(ItemsCount + CRowDataFirst - 1) & " befinden sich Eintr|fffd|ge, die bei einer Kalendererstellung ignoriert werden. Um dies zu verhindern, lassen Sie keine Zeile frei zwischen den Eintr|fffd|gen.", vbInformation, CTitleMsgBox
    Cells(LastRow, LastCol).Select
  Else
    MsgBox CStr(ItemsCount) & " Eintr|fffd|ge gepr|fffd|ft: keine Fehler gefunden", vbInformation, CTitleMsgBox
    Selection.Activate
  End If
End Sub


Private Sub ButtonDLG(ByVal xlDialogConst As Integer)
Dim ACell As Variant
Dim DoProtect As Boolean
  
  If Not UnprotectCalendarWorksheet(Me, "", DoProtect) Then Exit Sub
  
  Selection.Activate
  If Application.Dialogs(xlDialogConst).Show Then
    If Selection.count > 1 Then
      Application.ScreenUpdating = False
      For Each ACell In Selection
        CopyFont ActiveCell.Font, ACell.Font
      Next ACell
      Application.ScreenUpdating = True
    End If
  End If
     
  If DoProtect Then Protect
  
End Sub

Private Sub ButtonDLGFont_Click()
  ButtonDLG xlDialogActiveCellFont
End Sub


Private Sub ButtonDLGNumberformat_Click()
  ButtonDLG xlDialogFormatNumber
End Sub


Private Sub ButtonImport_Click()
  FormImportYearly.Show
End Sub

Private Sub ButtonSelectInfos_Click()
  Selection.Activate
  KalenderGlobal.ButtonSelectInfos_Click
End Sub

Private Sub ButtonSort_Click()
Dim DoProtect As Boolean

  
  If Not UnprotectCalendarWorksheet(Me, "", DoProtect) Then Exit Sub
 
  With Range(Cells(CRowDataFirst, CColDataFirst), Cells(ItemsCount - 1 + CRowDataFirst, CColDataLast))
    .Sort _
      Order1:=SortOrder, _
      Key1:=Range(Cells(CRowDataFirst, CColYear), Cells(CRowDataFirst, CColYear)), _
      Key2:=Range(Cells(CRowDataFirst, CColMonth), Cells(CRowDataFirst, CColMonth)), _
      Key3:=Range(Cells(CRowDataFirst, CColDay), Cells(CRowDataFirst, CColDay)), _
      Header:=False, _
      MatchCase:=False, _
      Orientation:=xlTopToBottom
      ' unter XL2k unbekannt:
      ' DataOption1:=CxlSortNormal
    .Select
  End With
  SortOrderSwitch
  If DoProtect Then Protect
End Sub



Private Sub ButtonYearlyZoom_Click()
Dim AZoomfactor As Single
  If ActiveWindow.Zoom <> 100 Then
    ActiveWindow.Zoom = 100
  Else
    AZoomfactor = ZoomfactorInCell
    If AZoomfactor = 0 Then
      ZoomfactorInCell = 150
      ActiveWindow.Zoom = 150
    Else
      ActiveWindow.Zoom = AZoomfactor
    End If
  End If
  Selection.Activate
End Sub



Public Sub Clear()
Dim DoProtect As Boolean
Dim i As Integer
Dim LastRow As Long
  
  
  If Not UnprotectCalendarWorksheet(Me, "", DoProtect) Then Exit Sub

  CommentsDelete Me, CRowDataFirst, CColDataFirst, CRowMax, CColDataLast
  For i = CColDataFirst To CColDataLast
    If Cells(CRowDataFirst, i).End(xlDown).Row > LastRow Then LastRow = Cells(CRowDataFirst, i).End(xlDown).Row
  Next i
  
  Range(Cells(CRowDataFirst, CColDataFirst), Cells(LastRow, CColDataLast)).ClearContents
  ZoomfactorInCell = 150
  If DoProtect Then Protect
End Sub


Private Function ColumnCaptions(ByVal AColIndex As Byte) As String
  ColumnCaptions = Cells(CRowColumnCaptions, AColIndex)
End Function


Private Function HaveClosingQuot(ByVal s As String, ByVal DelimiterCharCode As Byte, ByRef Index As Long) As Boolean
' Setzt voraus, dass sich s[index] innerhalb einer in Anf|fffd|hrungsstrichen gesetzten Zeichenkette befindet und gibt die
' Position des schlie|fffd|enden Anf|fffd|hrungszeichen ind *Index* und TRUE zur|fffd|ck.
' Doppelte Anf|fffd|hrungszeichen werden ignoriert.
' Wird kein einzelnes Anf|fffd|hrungszeichen gefunden, bleibt *Index* unver|fffd|ndert und die Funktion gibt FALSE zur|fffd|ck.

Const CCharCodeQuot As Byte = 34
Dim i As Long

  i = Index
  Do While i <= Len(s)
    If Asc(Mid(s, i, 1)) = CCharCodeQuot Then
      If i = Len(s) Then
        GoTo Exit_Found_HaveClosingQuot
      Else ' also muss i < len(s) gelten
        If Asc(Mid(s, i + 1, 1)) = CCharCodeQuot Then ' doppeltes Anf|fffd|hrungszeichen, weitermachen
          i = i + 1 ' zusammen mit der abschlie|fffd|enden Inkementation also effektiv i=i+2
        Else ' fertig
          GoTo Exit_Found_HaveClosingQuot
        End If
      End If
    End If
    i = i + 1
  Loop
  GoTo Exit_NotFound_HaveClosingQuot
  
  
Exit_NotFound_HaveClosingQuot:
  HaveClosingQuot = False
  GoTo Exit_HaveClosingQuot
  
Exit_Found_HaveClosingQuot:
  Index = i
  HaveClosingQuot = True
  GoTo Exit_HaveClosingQuot

Exit_HaveClosingQuot:
End Function




Private Function TokenNextQuot(ByVal s As String, ByVal DelimiterCharCode As Byte, ByRef token As String, ByRef Index As Long) As Boolean
' m|fffd|glicher Aufbau einer CSV-Zeile: "test",test, unmaskierter Text mit Leerzeichen, 22,"Text mit ""Anf|fffd|hrungszeichen""","Text mit
' Zeilenumbruch"   ,  "Trennzeichen , im Text enthalten",,  ,"leere Eintr|fffd|ge" , "maskierter Text mit wei|fffd|en Zeichen drumrum"

' Gibt den Inhalt aus *s* ab einschlie|fffd|lich der Stelle *Index* bis zum n|fffd|chsten *DelimiterCharCode* zur|fffd|ck. Liegt *Index* hinter dem
' Ende von *s* oder enth|fffd|lt *s* ab einschlie|fffd|lich der Stelle *Index* nur noch wei|fffd|e Zeichen, wird FALSE zur|fffd|ckgegeben, *Token* bleibt unver|fffd|ndert
' und *Index* liegt hinter dem Ende von *s*.
' Sofern ein Trenner gefunden wurde oder sich noch Zeichen nach *Index* befinden, werden diese nach *Token* kopiert, *Index* auf das n|fffd|chste
' zu behandelnde Zeichen gesetzt und TRUE zur|fffd|ckgegeben.
' *index* wird auf die Position des n|fffd|chsten aufgefundenen Delimiters gesetzt; muss also vom Aufrufer inkrementiert werden.

Const CCharCodeQuot As Byte = 34


Dim i As Long
  
  TokenNextQuot = False
  If Index = 0 Then Index = 1
  If Index > Len(s) Then Exit Function
  If Not SkipCharsWhite(s, Index) Then Exit Function
  If Asc(Mid(s, Index, 1)) = CCharCodeQuot Then
    i = Index + 1
    If HaveClosingQuot(s, DelimiterCharCode, i) Then
      Index = Index + 1 ' vom " runter
      token = Mid(s, Index, i - Index)
      Index = i + 1
      SkipCharsWhite s, Index ' weitere wei|fffd|e Zeichen nach den Anf|fffd|hrungszeichen ignorieren
      i = 1
      ReplaceStrs token, Chr(CCharCodeQuot) & Chr(CCharCodeQuot), Chr(CCharCodeQuot), i, -1, vbBinaryCompare ' doppelte "" durch " austauschen
      
      TokenNextQuot = True
      Exit Function
    Else
      ' nix, normales TokenNext
    End If
  End If
  TokenNextQuot = TokenNext(s, DelimiterCharCode, token, Index, True)
End Function



Private Function Import_Outlook_Err(ByVal AFilename As String, ByVal ErrCode As Byte, ByRef Index As Long) As Boolean
Dim s As String
Dim ImportLine As Long
  
  Open AFilename For Input As #1
  s = Input(FileLen(AFilename), #1)
  Close #1
  ImportLine = CountChars(s, Asc(vbCr), 1, Index) + 1
  
  Select Case ErrCode
    Case CErrCode_ImportOutlook_DateBegin
      s = "Beginndatums"
    Case CErrCode_ImportOutlook_DateEnd
      s = "Endedatums"
    Case CErrCode_ImportOutlook_Wholeday
      s = "Eintrags 'Ganzt|fffd|giges Ereignis'"
    Case CErrCode_ImportOutlook_Caption
      s = "Betreffs"
  End Select
  
  Index = Index + 1
  Import_Outlook_Err = MsgBox("Fehler beim Lesen des " & s & " in Zeile " & CStr(ImportLine) & " der Importdatei. Import fortsetzen?", vbCritical Or vbYesNo, CTitleMsgBox) = vbYes
  
End Function



Public Sub Import_Outlook(ByVal AFilename As String)
On Error GoTo Err_Import_Outlook


Dim zeile As Integer
Dim Index As Long, i As Long
Dim spalte As Byte
Dim s As String, token As String, ACaption As String
Dim DateBegin As Long, DateEnd As Long
Dim WholeDay As Boolean

  
  UpdateBegin
  
  ' die letzte ja/nein-Spalte ignorieren
  zeile = NextFreeRow(TabYearly, CRowDataFirst, Chr(CColDay) & Chr(CColMonth) & Chr(CColYear) & Chr(CColHelper) & Chr(CColFontsize))
  
  Open AFilename For Input As #1
  s = Input(FileLen(AFilename), #1)
  Close #1
  If s = "" Then GoTo Exit_Import_Outlook
  ' erste Zeile abschneiden:
  If CharPosFirstHaveCR(Asc(vbNewLine), s, Index) Then
    s = Right(s, Len(s) - Index)
    Index = 1
    If SkipCharsWhite(s, Index) Then s = Right(s, Len(s) - Index + 1)
  End If
  
  Index = 1
  Do While Index <= Len(s)
    If TokenNextQuot(s, Asc(","), token, Index) Then
      If IsDate(token) Then
        DateBegin = CDate(token)
        Index = Index + 1
        If TokenNextQuot(s, Asc(","), token, Index) Then
          If IsDate(token) Then
            DateEnd = CDate(token)
            Index = Index + 1
            If TokenNextQuot(s, Asc(","), token, Index) Then '"Ganzt|fffd|giges Ereignis"
              WholeDay = token = "Ein"
              Index = Index + 1
              If TokenNextQuot(s, Asc(","), token, Index) Then
                ACaption = token
                ' Excel hat vbLf als neue Zeile:
                ReplaceStrs ACaption, vbNewLine, vbLf, 1, 0, vbBinaryCompare
                If DateEnd > DateBegin Then If WholeDay Then DateEnd = DateEnd - 1
                For i = DateBegin To DateEnd
                  ItemsAddDate i, "", ACaption, CDefaultFontSize, True
                Next i
              Else
                If Not Import_Outlook_Err(AFilename, CErrCode_ImportOutlook_Caption, Index) Then GoTo Exit_Import_Outlook
              End If
            Else
              If Not Import_Outlook_Err(AFilename, CErrCode_ImportOutlook_Wholeday, Index) Then GoTo Exit_Import_Outlook
            End If
          Else
            If Not Import_Outlook_Err(AFilename, CErrCode_ImportOutlook_DateEnd, Index) Then GoTo Exit_Import_Outlook
          End If
        Else
          If Not Import_Outlook_Err(AFilename, CErrCode_ImportOutlook_DateEnd, Index) Then GoTo Exit_Import_Outlook
        End If
      Else
        If Not Import_Outlook_Err(AFilename, CErrCode_ImportOutlook_DateBegin, Index) Then GoTo Exit_Import_Outlook
      End If
    Else
      If Not Import_Outlook_Err(AFilename, CErrCode_ImportOutlook_DateBegin, Index) Then GoTo Exit_Import_Outlook
    End If
  Loop
  
  GoTo Exit_Import_Outlook
  
  
Err_Import_Outlook:
  MsgBox Err.Description, vbCritical, CTitleMsgBox
  Resume Exit_Import_Outlook


Exit_Import_Outlook:
  UpdateEnd
  Application.StatusBar = False

End Sub



Public Sub Import_Kalender8x(ByVal AFilename As String)
On Error GoTo Err_Import_Kalender8x

Const CCSVComment = ";"
Const CCSVDelimiterCharCode = 124

Dim ImportZeile As Integer, zeile As Integer
Dim Index As Long
Dim spalte As Byte
Dim s As String, token As String
  
  UpdateBegin
  
  ' die letzte ja/nein-Spalte ignorieren
  zeile = NextFreeRow(TabYearly, CRowDataFirst, Chr(CColDay) & Chr(CColMonth) & Chr(CColYear) & Chr(CColHelper) & Chr(CColFontsize))
  
  Open AFilename For Input As #1
  Do While Not EOF(1)
    ImportZeile = ImportZeile + 1
    Application.StatusBar = "Importiere aus Zeile " & CStr(ImportZeile)
    Line Input #1, s
    If Not StrIsComment(s, CCSVComment) Then
      spalte = CColDataFirst
      Index = 1
      While TokenNext(s, CCSVDelimiterCharCode, token, Index, False)
        Index = Index + 1
        Cells(zeile, spalte).Formula = token
        spalte = spalte + 1
      Wend
      zeile = zeile + 1
      ' Debug.Print "Zeile " & CStr(ImportZeile) & ": " & s
    End If
  Loop
  
  GoTo Exit_Import_Kalender8x
  
  
Err_Import_Kalender8x:
  MsgBox Err.Description & " (Aufgetreten in Zeile " & CStr(ImportZeile) & " der Importdatei.)", vbCritical, CTitleMsgBox
  Resume Exit_Import_Kalender8x


Exit_Import_Kalender8x:
  Close #1
  UpdateEnd
  Application.StatusBar = False
End Sub



Private Function ItemsAdd(ByVal ADay As Byte, ByVal AMonth As Byte, ByVal AYear As Integer, ByVal HelperCellFormula As String, ByVal ACaption As String, ByVal AFontSize As Double, ByVal DoShow As Boolean) As Long
Dim Index As Long
  Index = ItemsCount
  ItemsDay(Index) = ADay
  ItemsMonth(Index) = AMonth
  ItemsYear(Index) = AYear
  ItemsFormula(Index, CColHelper) = HelperCellFormula
  ItemsCaption(Index) = ACaption
  ItemsFontSize(Index) = AFontSize
  ItemsDoShow(Index) = DoShow
End Function


Private Function ItemsAddDate(ByVal ADate As Long, ByVal HelperCellFormula As String, ByVal ACaption As String, ByVal AFontSize As Double, ByVal DoShow As Boolean) As Long
Dim ADay As Byte, AMonth As Byte
Dim AYear As Integer
  ADay = Day(ADate)
  AMonth = Month(ADate)
  AYear = Year(ADate)
  ItemsAddDate = ItemsAdd(ADay, AMonth, AYear, HelperCellFormula, ACaption, AFontSize, DoShow)
End Function


Public Property Get ItemsCaption(ByVal Index As Integer) As String
  ItemsCaption = Cells(Index + CRowDataFirst, CColCaption)
End Property


Public Property Let ItemsCaption(ByVal Index As Integer, ByVal s As String)
  Cells(Index + CRowDataFirst, CColCaption) = s
End Property



Public Function ItemsCheck(ByVal Index As Integer, ByVal DoShowError As Boolean) As Byte
' liefert 0, falls alles ok, ansonsten die Spalte, in der der Fehler aufgetreten ist
  
  If ItemsDay(Index) = 0 Then
    If DoShowError Then ItemsCheckErrorMsgShow Index, CColDay
    ItemsCheck = CColDay
    Exit Function
  End If
  
  If ItemsMonth(Index) = 0 Then
    If DoShowError Then ItemsCheckErrorMsgShow Index, CColMonth
    ItemsCheck = CColMonth
    Exit Function
  End If
  
  Select Case ItemsMonth(Index)
    Case 4, 6, 9, 11
      If ItemsDay(Index) > 30 Then
        If DoShowError Then ItemsCheckErrorMsgShow Index, 255
        ItemsCheck = CColDay
        Exit Function
      End If
    Case 2
      If ItemsDay(Index) > 29 Then
        If DoShowError Then ItemsCheckErrorMsgShow Index, 255
        ItemsCheck = CColDay
        Exit Function
      End If
  End Select
    
  If ItemsCaption(Index) = "" Then
    If DoShowError Then ItemsCheckErrorMsgShow Index, CColCaption
    ItemsCheck = CColCaption
    Exit Function
  End If
   
  If ItemsYearHave(Index) Then
    If Not DateExists(ItemsYear(Index), ItemsMonth(Index), ItemsDay(Index)) Then
      If DoShowError Then ItemsCheckErrorMsgShow Index, CColYear
      ItemsCheck = CColYear
      Exit Function
    End If
  End If
   
  ItemsCheck = 0
End Function



Private Function ItemsCheckErrorMsg(ByVal Index As Integer, AColIndex As Byte) As String
Const CErrTextDayMontInvalid  As String = "Die Kombination aus Tag, Monat"
  Select Case AColIndex
    
    Case 255
     ItemsCheckErrorMsg = CErrTextDayMontInvalid & " beim Eintrag |fffd|" & ItemsCaption(Index) & "|fffd| in Zeile " & CStr(Index + CRowDataFirst) & " ist ung|fffd|ltig!"
  
    Case CColYear
      ItemsCheckErrorMsg = CErrTextDayMontInvalid & ", Jahr beim Eintrag |fffd|" & ItemsCaption(Index) & "|fffd| in Zeile " & CStr(Index + CRowDataFirst) & " ist ung|fffd|ltig!"
      
    Case Else
      ItemsCheckErrorMsg = "Der Eintrag |fffd|" & ItemsCaption(Index) & "|fffd| in Zeile " & CStr(Index + CRowDataFirst) & " enth|fffd|lt eine ung|fffd|ltige Angabe in der Spalte |fffd|" & ColumnCaptions(AColIndex) & "|fffd|!"
    
  End Select
End Function


Private Sub ItemsCheckErrorMsgShow(ByVal Index As Integer, AColIndex As Byte)
  MsgBox "Tabelle '" & Me.Name & "': " & ItemsCheckErrorMsg(Index, AColIndex), vbCritical, CTitleMsgBox
End Sub


Private Function ItemsComments(ByVal Index As Integer, ByVal CommentIndex As Integer) As Comment
Dim i As Integer, CommentsCount As Integer
  
  For i = 1 To Comments.count
    If Comments(i).Parent.Row = Index + CRowDataFirst Then
      If CommentIndex = CommentsCount Then
        Set ItemsComments = Comments(i)
        Exit Function
      End If
      CommentsCount = CommentsCount + 1
    End If
  Next i
  Set ItemsComments = Nothing

End Function


Private Function ItemsCommentsCount(ByVal Index As Integer) As Integer
Dim i As Integer, CommentsCount As Integer
  
  For i = 1 To Comments.count
    If Comments(i).Parent.Row = Index + CRowDataFirst Then
      CommentsCount = CommentsCount + 1
    End If
  Next i
  ItemsCommentsCount = CommentsCount
End Function


Public Function ItemsCount() As Integer
Dim i As Integer
  i = CRowDataFirst
  While Cells(i, CColDay) <> ""
    i = i + 1
  Wend
  ItemsCount = i - CRowDataFirst
End Function


Public Property Get ItemsDay(ByVal Index As Integer) As Byte
  ItemsDay = Cells(Index + CRowDataFirst, CColDay)
End Property


Private Property Let ItemsDay(ByVal Index As Integer, ByVal ADay As Byte)
  Cells(Index + CRowDataFirst, CColDay) = ADay
End Property


Public Property Get ItemsDoShow(ByVal Index As Integer) As Boolean
  ItemsDoShow = Not TabData.StrIsNoStr(Cells(Index + CRowDataFirst, CColDoshow))
End Property


Public Property Let ItemsDoShow(ByVal Index As Integer, ByVal ADoShow As Boolean)
  Cells(Index + CRowDataFirst, CColDoshow) = TabData.YesNoStr(ADoShow)
End Property



Public Property Get ItemsFont(ByVal Index As Integer) As Font
  Set ItemsFont = Cells(Index + CRowDataFirst, CColCaption).Font
End Property

Private Property Let ItemsFont(ByVal Index As Integer, AFont As Font)
  Set Cells(Index + CRowDataFirst, CColCaption).Font = AFont
End Property




Public Property Get ItemsFontSize(ByVal Index As Integer) As Double
' Liefert die in Spalte *CColFontsize* angegebene Zahl.
' Falls dort nichts eingetragen ist, wird die Fontgr|fffd||fffd|e aus *CColCaption* zur|fffd|ckgegeben.
  If Cells(Index + CRowDataFirst, CColFontsize) > 0 Then
    ItemsFontSize = CDbl(Cells(Index + CRowDataFirst, CColFontsize))
  Else
    ItemsFontSize = ItemsFont(Index).Size
  End If
End Property

Private Property Let ItemsFontSize(ByVal Index As Integer, ByVal NewSize As Double)
  Cells(Index + CRowDataFirst, CColFontsize) = NewSize
End Property


Private Property Get ItemsFormula(ByVal Index As Integer, ByVal ACol As Byte) As String
  ItemsFormula = Cells(Index + CRowDataFirst, ACol).Formula
End Property

Private Property Let ItemsFormula(ByVal Index As Integer, ByVal ACol As Byte, ByVal AFormula As String)
  Cells(Index + CRowDataFirst, ACol).Formula = AFormula
End Property


Private Function ItemsLoadFromOpenIniFile(ByVal Index As Byte, ByVal SectionName As String) As Boolean
Dim CommentList As String, s As String
Dim StrIndex As Long, ADummy As Long, ACol As Long
  
  Application.StatusBar = Me.Name & ": Lade Eintrag " & CStr(Index + 1)
  StrIndex = 1
  CommentList = LoadFromOpenIniFileString(SectionName, CIniKey_ItemsComments)
  While TokenNext(CommentList, Asc(","), s, StrIndex, False)
    If LoadFromOpenIniFileCommentPos(s, ADummy, ACol) Then
      Cells(Index + CRowDataFirst, ACol).AddComment
      LoadFromOpenIniFileComment s, Cells(Index + CRowDataFirst, ACol).Comment
    End If
    StrIndex = StrIndex + 1
  Wend

  ItemsFormula(Index, CColDay) = decodeURI(LoadFromOpenIniFileString(SectionName, CIniKey_ItemsDay), True)
  ItemsFormula(Index, CColMonth) = decodeURI(LoadFromOpenIniFileString(SectionName, CIniKey_ItemsMonth), True)
  ItemsFormula(Index, CColYear) = decodeURI(LoadFromOpenIniFileString(SectionName, CIniKey_ItemsYear), True)
  ItemsFormula(Index, CColHelper) = decodeURI(LoadFromOpenIniFileString(SectionName, CIniKey_ItemsHelpCell), True)
  ItemsNumberformat(Index, CColHelper) = decodeURI(LoadFromOpenIniFileString(SectionName, CIniKey_ItemsHelpCellNumberformat), True)
  ItemsFormula(Index, CColCaption) = decodeURI(LoadFromOpenIniFileString(SectionName, CIniKey_ItemsCaption), True)
  ItemsFormula(Index, CColFontsize) = decodeURI(LoadFromOpenIniFileString(SectionName, CIniKey_ItemsFontsize), True)
  ItemsDoShow(Index) = LoadFromOpenIniFileBoolean(SectionName, CIniKey_ItemsDoshow, True)
  
  ItemsLoadFromOpenIniFile = True
  Application.StatusBar = False
End Function




Public Property Get ItemsMonth(ByVal Index As Integer) As Byte
  ItemsMonth = Cells(Index + CRowDataFirst, CColMonth)
End Property


Private Property Let ItemsMonth(ByVal Index As Integer, ByVal AMonth As Byte)
  Cells(Index + CRowDataFirst, CColMonth) = AMonth
End Property


Private Property Get ItemsNumberformat(ByVal Index As Integer, ByVal ACol As Byte) As String
  ItemsNumberformat = Cells(Index + CRowDataFirst, ACol).NumberFormat
End Property


Private Property Let ItemsNumberformat(ByVal Index As Integer, ByVal ACol As Byte, ByVal ANumberFormat As String)
  Cells(Index + CRowDataFirst, ACol).NumberFormat = ANumberFormat
End Property



Private Function ItemsSaveToOpenIniFile(ByVal Index As Byte, ByVal SectionName As String) As Boolean
' Aufbau:
'[TabYearlyItem1]
'Comments=Comment1,Comment2,Comment3
'Day=29
'Month=1
'Year=2009
'HelpCell=WildeFormel
'HelpCellNumberformat=TT.MM.YYYY
'Caption=Muttertag
'Fontsize=4.5
'Doshow=1
Dim s As String, CommentSectionname As String
Dim i As Integer
Dim AComment As Comment

  Application.StatusBar = Me.Name & ": Speichere Eintrag " & CStr(Index + 1)
  For i = 0 To ItemsCommentsCount(Index) - 1
    Set AComment = ItemsComments(Index, i)
    CommentSectionname = CIniPrefixComment & CStr(NextFreeSectionID)
    s = s & CommentSectionname & ","
    SaveToOpenIniFileComment CommentSectionname, AComment, AComment.Parent.Row, AComment.Parent.Column
  Next i
  If s <> "" Then
    s = Left(s, Len(s) - 1)
    SaveToOpenIniFileString SectionName, CIniKey_ItemsComments, s
  End If
  
  SaveToOpenIniFileString SectionName, CIniKey_ItemsDay, encodeURI(ItemsFormula(Index, CColDay), True)
  SaveToOpenIniFileString SectionName, CIniKey_ItemsMonth, encodeURI(ItemsFormula(Index, CColMonth), True)
  SaveToOpenIniFileString SectionName, CIniKey_ItemsYear, encodeURI(ItemsFormula(Index, CColYear), True)
  SaveToOpenIniFileString SectionName, CIniKey_ItemsHelpCell, encodeURI(ItemsFormula(Index, CColHelper), True)
  SaveToOpenIniFileString SectionName, CIniKey_ItemsHelpCellNumberformat, encodeURI(ItemsNumberformat(Index, CColHelper), True)
  SaveToOpenIniFileString SectionName, CIniKey_ItemsCaption, encodeURI(ItemsFormula(Index, CColCaption), True)
  SaveToOpenIniFileString SectionName, CIniKey_ItemsFontsize, encodeURI(ItemsFormula(Index, CColFontsize), True)
  SaveToOpenIniFileBoolean SectionName, CIniKey_ItemsDoshow, BooleanToIniValue(ItemsDoShow(Index))
  ItemsSaveToOpenIniFile = True
  Application.StatusBar = False
End Function


Public Property Get ItemsYear(ByVal Index As Integer) As Integer
  ItemsYear = -1
  If Not IsEmpty(Cells(Index + CRowDataFirst, CColYear)) Then
    If IsNumeric(Cells(Index + CRowDataFirst, CColYear)) Then
      If CInt(Cells(Index + CRowDataFirst, CColYear)) >= CYearMin Then
        If CInt(Cells(Index + CRowDataFirst, CColYear)) <= CYearMax Then
          ItemsYear = CInt(Cells(Index + CRowDataFirst, CColYear))
        End If
      End If
    End If
  End If
End Property


Private Property Let ItemsYear(ByVal Index As Integer, ByVal AYear As Integer)
  Cells(Index + CRowDataFirst, CColYear) = AYear
End Property


Public Function ItemsYearHave(ByVal Index As Integer) As Boolean
  ItemsYearHave = ItemsYear(Index) >= 0
End Function


Public Function ItemsYearMatches(ByVal Index As Integer, ByVal AYear As Integer) As Boolean
' Falls ItemsYearHave, wird ItemsYear=AYear zur|fffd|ckgegeben, ansonsten TRUE
  If ItemsYearHave(Index) Then ItemsYearMatches = (ItemsYear(Index) = AYear) Else ItemsYearMatches = True
End Function








Public Function SaveToOpenIniFile(ByRef ItemsTreated As Long) As Boolean
' Aufbau:
' Items=Item1,Item2,...
' Zoom=150
Dim i As Integer
Dim s As String, SectionName As String
Dim result As Boolean

  result = True
  
  For i = 0 To ItemsCount - 1
    SectionName = CodeName & CIniPrefixSectionItems & CStr(i)
    result = result Or ItemsSaveToOpenIniFile(i, SectionName)
    s = s & SectionName & ","
    ItemsTreated = ItemsTreated + 1
  Next i
  If s <> "" Then
    s = Left(s, Len(s) - 1)
    SaveToOpenIniFileString CodeName, CIniKey_Items, s
  End If
  
  SaveToOpenIniFileInteger CodeName, CIniKey_Zoom, ZoomfactorInCell
  SaveToOpenIniFile = result
End Function





Public Function LoadFromOpenIniFile(ByRef ItemsTreated As Long) As Boolean
Dim Itemlist As String, s As String
Dim StrIndex As Long
Dim WasProtected As Boolean
  
  LoadFromOpenIniFile = False
  If Not UnprotectCalendarWorksheet(Me, CPassword, WasProtected) Then Exit Function
  ZoomfactorInCell = LoadFromOpenInifileInteger(CodeName, CIniKey_Zoom, 150)

  Itemlist = LoadFromOpenIniFileString(CodeName, CIniKey_Items)
  While TokenNext(Itemlist, Asc(","), s, StrIndex, False)
    ItemsLoadFromOpenIniFile ItemsCount, s
    StrIndex = StrIndex + 1
    ItemsTreated = ItemsTreated + 1
  Wend
  
  If WasProtected Then Protect
  LoadFromOpenIniFile = True
End Function



Public Sub MakeDist()
Dim PrevVisible As Long
  PrevVisible = Visible
  Visible = xlSheetVisible
  Activate
  Cells(ItemsCount + CRowDataFirst, CColDay).Select
  Visible = PrevVisible
End Sub


Private Property Get SortOrder() As Byte
  If fSortOrder = 0 Then fSortOrder = xlAscending
  SortOrder = fSortOrder
End Property


Private Property Let SortOrder(NewSortorder As Byte)
  If SortOrder = NewSortorder Then Exit Property
  fSortOrder = NewSortorder
  SortOrderChanged
End Property


Private Sub SortOrderChanged()
  'ButtonCheckItems.Caption = "test"
 ' If SortOrder = xlAscending Then Shapes("ButtonSort").Characters.Text = "Sortieren |fffd|" Else Shapes("ButtonSort").Characters.Text = "Sortieren ?"
 If SortOrder = xlAscending Then ButtonSort.Caption = "Sortieren ^" Else ButtonSort.Caption = "Sortieren v"
End Sub

Private Sub SortOrderSwitch()
  If SortOrder = xlAscending Then SortOrder = xlDescending Else SortOrder = xlAscending
End Sub




Private Sub Worksheet_Activate()
  TabInfos.InfoCheckbox(CInfoCheckboxZeileYearly) = True
  If TabInfos.TabselectionCodeUse Then
    ActiveWindow.DisplayHeadings = True
    ActiveSheet.DisplayAutomaticPageBreaks = False
    EnableSelection = xlUnlockedCells
    ScrollArea = Range(Cells(CRowDataFirst, CColDataFirst), Cells(CRowMax, CColDataLast)).Address
    Protect
  End If
End Sub




Private Sub Worksheet_Deactivate()
  If TabInfos.TabselectionCodeUse Then Visible = xlSheetHidden
End Sub


Private Sub Worksheet_SelectionChange(ByVal Target As Range)
  Select Case Target.Column
    Case CColCaption
      ButtonDLGFont.Enabled = True
      ButtonDLGNumberformat.Enabled = False
    Case CColHelper
      ButtonDLGNumberformat.Enabled = True
      ButtonDLGFont.Enabled = True
    Case Else
      ButtonDLGNumberformat.Enabled = False
      ButtonDLGFont.Enabled = False
  End Select
    
End Sub


Private Property Get ZoomfactorInCell() As Integer
On Error GoTo Err_ZoomfactorInCell

  ZoomfactorInCell = CInt(Cells(CRowZoomfactor, CColZoomfactor))
  GoTo Exit_ZoomfactorInCell

Err_ZoomfactorInCell:
  ZoomfactorInCell = 0
  Resume Exit_ZoomfactorInCell

Exit_ZoomfactorInCell:

End Property


Private Property Let ZoomfactorInCell(NewZoomfactorInCell As Integer)
  Cells(CRowZoomfactor, CColZoomfactor) = NewZoomfactorInCell
End Property




' InQuest injected base64 decoded content
' %jwCy
' zw^~)
' z{Lj
' ^u+k
' x:.nW
' (^rF
' (^rF
' (^rF
' (^rF
' (^rF
' ek %z
' z(!n
' )^K+-z`
' :&j)
' *^r&
' x?"x
' ^u+k
' +^"{^
' bz{B
' Z+O*^
' bz{Oj
' bz{Uj
' bz{O
' (^rA+
' Zzw^
' "wbq
' h)^j
' eZ+a>
' !zq"
' !zp^
' )j[^
' mzpkz+^
' )bz{V
' )bz{Gz(!
' z+y*b
' x*%Z'm

INQUEST-PP=macro
