Attribute VB_Name = "Dictionary"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'Version 2.2
'Andreas Killer
'19.01.18
'Attribute VB_Name = "Dictionary"

'Replica of the Scripting.Dictionary object (for MAC)

'If the default property of this class module did not work:
'  1. Export this class module to a file
'  2. Delete this class module
'  3. Open the file with Notepad
'  4. Duplicate any "'Attribute Item." lines and remove the comment sign
'  5. Save that file
'  6. Import the file

Option Explicit

#Const UseBinaryCompare = True
'To simulate a Dictionary this class uses a set of collections used with the key feature
'But as the compare method for keys in a collection is always vbTextCompare, we need hash codes for the binary compare method

Dim dKeys As Collection
Dim dDataK As Collection
Dim dDataI As Collection
Dim dIndex As Long
Dim dCompareMethod As VbCompareMethod

#If UseBinaryCompare Then
Function StringAsHex(ByVal s As String) As String
  'Returns all bytes in S as hexadecimal values (useful as key in collections)
  Dim B() As Byte, i As Long, j As Long
  B = s
  StringAsHex = String((UBound(B) - LBound(B) + 1) * 2, "0")
  j = -1
  For i = LBound(B) To UBound(B)
    j = j + 2
    If B(i) > &HF Then
      Mid$(StringAsHex, j, 2) = Hex$(B(i))
    Else
      Mid$(StringAsHex, j + 1, 1) = Hex$(B(i))
    End If
  Next
End Function
#End If

Sub Add(ByVal Key As String, Item)
  'Add an item
#If UseBinaryCompare Then
  Dim dKey As String
  If dCompareMethod <> vbTextCompare Then
    dKey = StringAsHex(Key)
  Else
    dKey = Key
  End If
  dKeys.Add dIndex, dKey
#Else
  dKeys.Add dIndex, Key
#End If
  dDataK.Add Key, CStr(dIndex)
  dDataI.Add Item, CStr(dIndex)
  dIndex = dIndex + 1
End Sub

Property Let CompareMode(Value As VbCompareMethod)
  'Set the compare method
  'Note:
  '  The dictionary must be empty
  If dDataI.Count > 0 Then Err.Raise 5, "Dictionary", "Dictionary must be empty"
  dCompareMethod = Value
End Property

Property Get CompareMode() As VbCompareMethod
  'Return the compare method
  CompareMode = dCompareMethod
End Property

Property Get Count() As Long
  'Return the number of items
  Count = dDataI.Count
End Property

Function Exists(ByVal Key As String) As Boolean
  'True if an element exists
  On Error Resume Next
#If UseBinaryCompare Then
  Dim dKey As String
  If dCompareMethod <> vbTextCompare Then
    dKey = StringAsHex(Key)
  Else
    dKey = Key
  End If
  Exists = dKeys(dKey) >= 0
#Else
  Exists = dKeys(Key) >= 0
#End If
End Function

Property Get Item(ByVal Key As String) As Variant '(default property)
  'Attribute Item.VB_UserMemId = 0
  'Return the element with that key
  Dim p As String
#If UseBinaryCompare Then
  Dim dKey As String
  If dCompareMethod <> vbTextCompare Then
    dKey = StringAsHex(Key)
  Else
    dKey = Key
  End If
  p = dKeys(dKey)
#Else
  p = dKeys(Key)
#End If
  If IsObject(dDataI(p)) Then
    Set Item = dDataI(p)
  Else
    Item = dDataI(p)
  End If
End Property

Property Let Item(ByVal Key As String, Value As Variant) '(default property)
  'Attribute Item.VB_UserMemId = 0
  'Returns the element from the dictionary form that key
  Dim p As String
  On Error GoTo Add
#If UseBinaryCompare Then
  Dim dKey As String
  If dCompareMethod <> vbTextCompare Then
    dKey = StringAsHex(Key)
  Else
    dKey = Key
  End If
  p = dKeys(dKey)
#Else
  p = dKeys(Key)
#End If
  dDataI.Remove p
  dDataI.Add Value, p
  Exit Property
Add:
  Me.Add Key, Value
End Property

Function Items() As Variant
  'Return all elements as array
  Dim Item, Result, p As Long
  ReDim Result(0 To dDataI.Count - 1)
  For Each Item In dDataI
    If IsObject(Item) Then
      Set Result(p) = Item
    Else
      Result(p) = Item
    End If
    p = p + 1
  Next
  Items = Result
End Function

Property Get NewEnum() As Variant 'Default Enumerator Property
  'Attribute NewEnum.VB_UserMemId = -4
  'Attribute NewEnum.VB_MemberFlags = "40"
  Set NewEnum = dDataK.[_NewEnum]
End Property

Property Let Key(ByVal OldKey As String, ByVal NewKey As String)
  'Rename a key
  Dim p As Long
#If UseBinaryCompare Then
  Dim oKey As String, nKey As String
  If dCompareMethod <> vbTextCompare Then
    oKey = StringAsHex(OldKey)
    nKey = StringAsHex(NewKey)
  Else
    oKey = OldKey
    nKey = NewKey
  End If
  p = dKeys(oKey)
  dKeys.Add p, nKey
  dKeys.Remove oKey
#Else
  p = dKeys(OldKey)
  dKeys.Add p, NewKey
  dKeys.Remove OldKey
#End If
  dDataK.Remove p
  dDataK.Add NewKey, CStr(p)
End Property

Function Keys() As Variant
  'Return all keys as array
  Dim Item, Result, p As Long
  ReDim Result(0 To dKeys.Count - 1)
  For Each Item In dDataK
    Result(p) = Item
    p = p + 1
  Next
  Keys = Result
End Function

Sub Remove(ByVal Key As String)
  'Remove this key
  Dim p As String
#If UseBinaryCompare Then
  Dim dKey As String
  If dCompareMethod <> vbTextCompare Then
    dKey = StringAsHex(Key)
  Else
    dKey = Key
  End If
  p = dKeys(dKey)
  dKeys.Remove dKey
#Else
  p = dKeys(Key)
  dKeys.Remove Key
#End If
  dDataI.Remove p
  dDataK.Remove p
End Sub

Sub RemoveAll()
  'Remove all keys
  Class_Terminate
  Class_Initialize
End Sub

Private Sub Class_Initialize()
  Set dKeys = New Collection
  Set dDataK = New Collection
  Set dDataI = New Collection
  dIndex = 0
End Sub

Private Sub Class_Terminate()
  Set dDataI = Nothing
  Set dDataK = Nothing
  Set dKeys = Nothing
End Sub
Attribute VB_Name = "DieseArbeitsmappe"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Private Sub Workbook_BeforeSave(ByVal SaveAsUI As Boolean, Cancel As Boolean)
  If ThisWorkbook.ReadOnly Then
    ThisWorkbook.Saved = True
  Else
    UnRegisterFunctions_E085BB24_9882_4471_86B5_22FC180E4AA 0
  End If
End Sub

Private Sub Workbook_Open()
  Application.OnTime Now, "'" & Me.CodeName & ".RegisterFunctions_E085BB24_9882_4471_86B5_22FC180E4AA 0'"
End Sub

Sub RegisterFunctions_E085BB24_9882_4471_86B5_22FC180E4AA(Dummy)
  Const Category As String = "xlfn"
  Dim All As Range, R As Range
  Dim Macro As String, Description As String, Help As String, Args
  Dim Activate As String
  Dim HelpID As Integer
  'Excel functions (alphabetical)
  Help = "https://support.office.com/en-ie/article/excel-functions-alphabetical-b3944572-255d-4efb-bb96-c6d90033e188"
  On Error Resume Next
  Set All = ThisWorkbook.Worksheets(1).ListObjects(1).ListColumns(1).DataBodyRange
  Activate = xlfn.Activated
  With WorksheetFunction
    For Each R In All.Cells
      Macro = R.Value
      If InStr(1, Activate, ";" & Macro & ";", vbTextCompare) > 0 Then
        'Did not work within the function wizard:
        'Help = R.Offset(, 1).Value
        Description = R.Offset(, 2).Value
        Args = .Transpose(.Transpose(Range(R.Offset(, 3), R.Offset(, Columns.Count - R.Column).End(xlToLeft))))
        If Not IsArray(Args) Then
          ReDim Args(1)
          Args(1) = R.Offset(, 3)
        End If
        Do While IsEmpty(Args(UBound(Args)))
          ReDim Preserve Args(LBound(Args) To UBound(Args) - 1)
        Loop
        If Val(Application.Version) > 12 Then
          'Application.MacroOptions Macro, Description, , , , , Category, , HelpID, Help, Args
          VBA.CallByName Application, "MacroOptions", VbMethod, Macro, Description, , , , , Category, , HelpID, Help, Args
        Else
          'Application.MacroOptions Macro, Description, , , , , Category, , HelpID, Help
          VBA.CallByName Application, "MacroOptions", VbMethod, Macro, Description, , , , , Category, , HelpID, Help
        End If
        HelpID = HelpID + 1
      End If
    Next
  End With
  ThisWorkbook.Saved = True
End Sub

Sub UnRegisterFunctions_E085BB24_9882_4471_86B5_22FC180E4AA(Dummy)
  Const Category As Long = 14
  Dim All As Range, R As Range
  Dim Macro As String, Description As String, Help As String, Args
  Dim Activate As String
  Dim HelpID As Integer
  'Excel functions (alphabetical)
  Help = "https://support.office.com/en-ie/article/excel-functions-alphabetical-b3944572-255d-4efb-bb96-c6d90033e188"
  'On Error Resume Next
  Set All = ThisWorkbook.Worksheets(1).ListObjects(1).ListColumns(1).DataBodyRange
  Activate = xlfn.Activated
  With WorksheetFunction
    For Each R In All.Cells
      Macro = R.Value
      If InStr(1, Activate, ";" & R.Value & ";", vbTextCompare) > 0 Then
        'Did not work within the function wizard:
        'Help = R.Offset(, 1).Value
        Description = R.Offset(, 2).Value
        ReDim Args(1 To 19)
        If Val(Application.Version) > 12 Then
          'Application.MacroOptions Macro, Description, , , , , Category, , HelpID, Help, Args
          VBA.CallByName Application, "MacroOptions", VbMethod, Macro, Description, , , , , Category, , HelpID, Help, Args
        Else
          'Application.MacroOptions Macro, Description, , , , , Category, , HelpID, Help
          VBA.CallByName Application, "MacroOptions", VbMethod, Macro, Description, , , , , Category, , HelpID, Help
        End If
        HelpID = HelpID + 1
      End If
    Next
  End With
  ThisWorkbook.Saved = True
End Sub
Attribute VB_Name = "Macro"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "modRibbon"
'Version 1.0
'Andreas Killer
'26.11.2019

Option Explicit
Option Compare Text
Option Private Module

Private Const GUID = "E085BB24_9882_4471_86B5_22FC180E4AA"
Public MyRibbon As IRibbonUI

Public Sub OnRibbonLoad_E085BB24_9882_4471_86B5_22FC180E4AA(ribbon As IRibbonUI)
  Set MyRibbon = ribbon
End Sub

Public Sub OnActionButton_E085BB24_9882_4471_86B5_22FC180E4AA(control As IRibbonControl)
  Application.OnTime Now, "'CallFunctionWizard """ & control.Tag & """'"
End Sub

Sub CallFunctionWizard(ByVal Macro As String)
  Dim InitFormula As String, DefFormula As String
  Dim Value
  Dim T As Single
  Dim HasArray As Boolean
  Dim Where As Range
  On Error Resume Next
  Set Where = ActiveCell
  If Where.HasArray Then
    Set Where = Where.CurrentArray
    HasArray = True
  End If
  With Where
    InitFormula = .Formula
    If .HasFormula Then
      DefFormula = "=" & Macro & "(" & Mid$(.Formula, 2) & ")"
    Else
      Value = .Value
      If Not IsEmpty(Value) Then If Not IsNumeric(Value) Then Value = """" & Value & """"
      DefFormula = "=" & Macro & "(" & Value & ")"
    End If
    If .HasArray Then
      .FormulaArray = DefFormula
    Else
      .Formula = DefFormula
    End If
    GoSub Wait
    Application.Dialogs(xlDialogFunctionWizard).Show
    If .HasArray Then
      If .FormulaArray = DefFormula Then
        .FormulaArray = InitFormula
      End If
    Else
      If .Formula = DefFormula Then
        .Formula = InitFormula
      End If
    End If
  End With
  Exit Sub
Wait:
  T = Timer
  Do
    DoEvents
  Loop Until T <> Timer
  Return
End Sub

Public Sub GetContent_E085BB24_9882_4471_86B5_22FC180E4AA(control As IRibbonControl, ByRef XMLString)
  Const Schema12 = "<menu xmlns=""http://schemas.microsoft.com/office/2006/01/customui"">"
  Const Schema14 = "<menu xmlns=""http://schemas.microsoft.com/office/2009/07/customui"">"
  Const MenuEnd = "</menu>"
  Dim Item, XML
  Item = Array("<button id=", "[ID]", "label=", "[LABEL]", "tag=", "[TAG]", "onAction=", "[ONACTION]", "/>")
  Dim i As Integer, j As Integer
  Dim All As Range, R As Range
  Dim Activate As String
  Set All = ThisWorkbook.Worksheets(1).ListObjects(1).ListColumns(1).DataBodyRange
  Activate = xlfn.Activated

  If Val(Application.Version) > 12 Then
    XML = Array(Schema14)
  Else
    XML = Array(Schema12)
  End If
  For Each R In All.Cells
    If InStr(1, Activate, ";" & R.Value & ";", vbTextCompare) > 0 Then
      Item(1) = "btn" & GUID & R.Value
      Item(3) = R.Value
      Item(5) = R.Value
      Item(7) = "OnActionButton_E085BB24_9882_4471_86B5_22FC180E4AA"
      For j = 1 To UBound(Item) Step 2
        Item(j) = """" & Item(j) & """"
      Next
      ReDim Preserve XML(0 To UBound(XML) + 1)
      XML(UBound(XML)) = Join(Item)
    End If
  Next
  ReDim Preserve XML(0 To UBound(XML) + 1)
  XML(UBound(XML)) = MenuEnd
  XMLString = Join(XML, vbCrLf)
End Sub
Attribute VB_Name = "xlfn"
'Version 1.0 beta
'Andreas Killer
'22.11.2019

Option Explicit
Option Compare Text

'-------------------- Define section, customize to adjust your version of Excel --------------------

'Set the defines to False of the version you have and earlier versions, because you already have this functions in your Excel!
'Set the defines to True of the version you do NOT have

#Const Excel2019 = True
#Const Excel365Sep2018 = True
#Const Excel365Aug2019 = True

'-------------------- Individual activation of each function, in general no need to make a change in here --------------------

'Excel 2019
#Const ActivateCONCAT = Excel2019
#Const ActivateIFS = Excel2019
#Const ActivateMAXIFS = Excel2019
#Const ActivateMINIFS = Excel2019
#Const ActivateTEXTJOIN = Excel2019
#Const ActivateSWITCH = Excel2019
'Excel 365 Sep2018
#Const ActivateFILTER = Excel365Sep2018
#Const ActivateRANDARRAY = Excel365Sep2018
#Const ActivateSEQUENCE = Excel365Sep2018
#Const ActivateSORT = Excel365Sep2018
#Const ActivateSORTBY = Excel365Sep2018
#Const ActivateUNIQUE = Excel365Sep2018
'Excel 365 Aug2019
#Const ActivateXLOOKUP = Excel365Aug2019
#Const ActivateXMATCH = Excel365Aug2019

'-------------------- Do not make any change below this line! --------------------

'https://support.office.com/en-ie/article/excel-functions-alphabetical-b3944572-255d-4efb-bb96-c6d90033e188

Public Property Get Activated() As String
  Dim Result
  Result = Array("")
'Excel 2019
#If ActivateCONCAT Then
  ReDim Preserve Result(0 To UBound(Result) + 1)
  Result(UBound(Result)) = "CONCAT"
#End If
#If ActivateIFS Then
  ReDim Preserve Result(0 To UBound(Result) + 1)
  Result(UBound(Result)) = "IFS"
#End If
#If ActivateMAXIFS Then
  ReDim Preserve Result(0 To UBound(Result) + 1)
  Result(UBound(Result)) = "MAXIFS"
#End If
#If ActivateMINIFS Then
  ReDim Preserve Result(0 To UBound(Result) + 1)
  Result(UBound(Result)) = "MINIFS"
#End If
#If ActivateTEXTJOIN Then
  ReDim Preserve Result(0 To UBound(Result) + 1)
  Result(UBound(Result)) = "TEXTJOIN"
#End If
#If ActivateSWITCH Then
  ReDim Preserve Result(0 To UBound(Result) + 1)
  Result(UBound(Result)) = "SWITCH"
#End If
'Excel 365 Sep2018
#If ActivateFILTER Then
  ReDim Preserve Result(0 To UBound(Result) + 1)
  Result(UBound(Result)) = "aFILTER"
#End If
#If ActivateRANDARRAY Then
  ReDim Preserve Result(0 To UBound(Result) + 1)
  Result(UBound(Result)) = "RANDARRAY"
#End If
#If ActivateSEQUENCE Then
  ReDim Preserve Result(0 To UBound(Result) + 1)
  Result(UBound(Result)) = "aSEQUENCE"
#End If
#If ActivateSORT Then
  ReDim Preserve Result(0 To UBound(Result) + 1)
  Result(UBound(Result)) = "SORT"
#End If
#If ActivateSORTBY Then
  ReDim Preserve Result(0 To UBound(Result) + 1)
  Result(UBound(Result)) = "SORTBY"
#End If
#If ActivateUNIQUE Then
  ReDim Preserve Result(0 To UBound(Result) + 1)
  Result(UBound(Result)) = "UNIQUE"
#End If
'Excel 365 Aug2019
#If ActivateXLOOKUP Then
  ReDim Preserve Result(0 To UBound(Result) + 1)
  Result(UBound(Result)) = "XLOOKUP"
#End If
#If ActivateXMATCH Then
  ReDim Preserve Result(0 To UBound(Result) + 1)
  Result(UBound(Result)) = "XMATCH"
#End If

  ReDim Preserve Result(0 To UBound(Result) + 1)
  Result(UBound(Result)) = ""
  Activated = Join(Result, ";")
End Property

Sub SaveMe()
  ThisWorkbook.IsAddin = True
  ThisWorkbook.Save
End Sub

'-------------------- Excel 2019 --------------------

#If ActivateCONCAT Then
Public Function CONCAT(ParamArray Text())
Attribute CONCAT.VB_Description = "The CONCAT function combines the text from multiple ranges and/or strings  but it doesn't provide delimiter or IgnoreEmpty arguments."
Attribute CONCAT.VB_ProcData.VB_Invoke_Func = " \n19"
  'https://support.office.com/en-ie/article/concat-function-9b1a9a3f-94ff-41af-9736-694cbd6b4ca2
  Dim A As Integer
  Dim Area As Range
  Dim Data, i As Long, j As Long
  Dim ByRow As Boolean
  For A = 0 To UBound(Text)
    If IsObject(Text(A)) Then
      ByRow = Text(A).Rows.Count = Text(A).Parent.Rows.Count
      Set Area = Intersect(Text(A), Text(A).Parent.UsedRange)
      Data = Area.Value
      If Not IsArray(Data) Then
        ReDim Data(1 To 1, 1 To 1)
        Data(1, 1) = Area.Value
      End If
      If ByRow Then
        For j = 1 To UBound(Data, 2)
          For i = 1 To UBound(Data)
            CONCAT = CONCAT & Data(i, j)
          Next
        Next
      Else
        For i = 1 To UBound(Data)
          For j = 1 To UBound(Data, 2)
            CONCAT = CONCAT & Data(i, j)
          Next
        Next
      End If
    Else
      CONCAT = CONCAT & Text(A)
    End If
  Next
End Function
#End If

#If ActivateIFS Then
Public Function IFS(ByVal Expression1, Value1, ParamArray Args()) As Variant
Attribute IFS.VB_Description = "The IFS function checks whether one or more conditions are met  and returns a value that corresponds to the first TRUE condition. IFS can take the place of multiple nested IF statements  and is much easier to read with multiple conditions."
Attribute IFS.VB_HelpID = 2
Attribute IFS.VB_ProcData.VB_Invoke_Func = " \n19"
  'https://support.office.com/en-us/article/ifs-function-36329a26-37b2-467c-972b-4a39bd951d45
  Dim i As Long
  IFS = CVErr(xlErrNA)
  If CBool(Expression1) Then
    IFS = Value1
  Else
    For i = LBound(Args) To UBound(Args) Step 2
      If CBool(Args(i)) Then
        IFS = Args(i + 1)
        Exit Function
      End If
    Next
  End If
End Function
#End If

#If ActivateMAXIFS Then
Public Function MAXIFS(max_range, criteria_range1, criteria1, ParamArray Args())
Attribute MAXIFS.VB_Description = "The MAXIFS function returns the maximum value among cells specified by a given set of conditions or criteria."
Attribute MAXIFS.VB_HelpID = 3
Attribute MAXIFS.VB_ProcData.VB_Invoke_Func = " \n19"
  'https://support.office.com/en-ie/article/maxifs-function-dfd611e6-da2c-488a-919b-9b6376b28883
  Dim CData, Arg
  Arg = Args
  CData = ProcessIFS(max_range, criteria_range1, criteria1, Arg)
  If IsError(CData) Then
    MAXIFS = CData
  Else
    MAXIFS = WorksheetFunction.max(CData)
  End If
End Function
#End If

#If ActivateMINIFS Then
Public Function MINIFS(min_range, criteria_range1, criteria1, ParamArray Args())
Attribute MINIFS.VB_Description = "The MINIFS function returns the minimum value among cells specified by a given set of conditions or criteria."
Attribute MINIFS.VB_HelpID = 4
Attribute MINIFS.VB_ProcData.VB_Invoke_Func = " \n19"
  'https://support.office.com/en-ie/article/minifs-function-6ca1ddaa-079b-4e74-80cc-72eef32e6599
  Dim CData, Arg
  Arg = Args
  CData = ProcessIFS(min_range, criteria_range1, criteria1, Arg)
  If IsError(CData) Then
    MINIFS = CData
  Else
    MINIFS = WorksheetFunction.min(CData)
  End If
End Function
#End If

#If ActivateSWITCH Then
Public Function SWITCH(Value, Match1, Return1, ParamArray Args())
Attribute SWITCH.VB_Description = "The SWITCH function evaluates one value (called the expression) against a list of values  and returns the result corresponding to the first matching value. If there is no match  an optional default value may be returned."
Attribute SWITCH.VB_HelpID = 9
Attribute SWITCH.VB_ProcData.VB_Invoke_Func = " \n19"
  'https://support.office.com/en-ie/article/switch-function-47ab33c0-28ce-4530-8a45-d532ec4aa25e
  Dim i As Integer
  If Value = Match1 Then
    SWITCH = Return1
  Else
    For i = 0 To UBound(Args) Step 2
      If i + 1 > UBound(Args) Then
        'No Match
        SWITCH = Args(i)
        Exit Function
      Else
        If Value = Args(i) Then
          SWITCH = Args(i + 1)
          Exit Function
        End If
      End If
    Next
    SWITCH = CVErr(xlErrNA)
  End If
End Function
#End If

#If ActivateTEXTJOIN Then
Public Function TEXTJOIN(ByVal Delimiter, ByVal Ignore_Empty As Boolean, ParamArray Text()) As String
Attribute TEXTJOIN.VB_Description = "The TEXTJOIN function combines the text from multiple ranges and/or strings  and includes a delimiter you specify between each text value that will be combined."
Attribute TEXTJOIN.VB_HelpID = 10
Attribute TEXTJOIN.VB_ProcData.VB_Invoke_Func = " \n19"
  'https://support.office.com/en-us/article/TEXTJOIN-function-357b449a-ec91-49d0-80c3-0e8fc845691c
  Dim A As Long, i As Long, j As Long
  Dim Item, Data, LastDelimiter
  Data = Array()
  If IsObject(Delimiter) Then Delimiter = Delimiter.Value
  If IsArray(Delimiter) Then
    If UBound(Delimiter) > UBound(Delimiter, 2) Then
      'Vertical
      For A = 0 To UBound(Text)
        Item = Text(A).Value
        For j = 1 To UBound(Item, 2)
          For i = 1 To UBound(Item, 1)
            If Not (IsEmpty(Item(i, j)) And Ignore_Empty) Then
              ReDim Preserve Data(0 To UBound(Data) + 2)
              Data(UBound(Data) - 1) = Item(i, j)
              Data(UBound(Data)) = Delimiter(1, j)
            End If
          Next
        Next
      Next
    Else
      'Horizontal
      For A = 0 To UBound(Text)
        Item = Text(A).Value
        For i = 1 To UBound(Item, 1)
          For j = 1 To UBound(Item, 2)
            If Not (IsEmpty(Item(i, j)) And Ignore_Empty) Then
              ReDim Preserve Data(0 To UBound(Data) + 2)
              Data(UBound(Data) - 1) = Item(i, j)
              Data(UBound(Data)) = Delimiter(1, j)
            End If
          Next
        Next
      Next
    End If
    'Remove last delimiter
    If UBound(Data) > 0 Then ReDim Preserve Data(0 To UBound(Data) - 1)
    TEXTJOIN = Join(Data, "")
  Else
    'Single delimiter
    For A = 0 To UBound(Text)
      If IsArray(Text(A)) Then
        For Each Item In Text(A)
          If Not (IsEmpty(Item) And Ignore_Empty) Then
            ReDim Preserve Data(0 To UBound(Data) + 1)
            Data(UBound(Data)) = Item
          End If
        Next
      Else
        If Not (IsEmpty(Item) And Ignore_Empty) Then
          ReDim Preserve Data(0 To UBound(Data) + 1)
          Data(UBound(Data)) = Item
        End If
      End If
    Next
    TEXTJOIN = Join(Data, Delimiter)
  End If
End Function
#End If

'-------------------- Excel 365 Excel365Sep2018 --------------------

#If ActivateFILTER Then
Public Function aFILTER(array_, include, Optional ByVal if_empty)
Attribute aFILTER.VB_Description = "The FILTER function allows you to filter a range of data based on criteria you define"
Attribute aFILTER.VB_HelpID = 1
Attribute aFILTER.VB_ProcData.VB_Invoke_Func = " \n19"
  'https://support.office.com/en-ie/article/aFILTER-function-f4f7cb66-82eb-4767-8f7c-4877ad80c759
  Dim Data, Result
  Dim i As Long, j As Long, k As Long
  If IsObject(array_) Then Set array_ = Intersect(array_, array_.Parent.UsedRange)
  Data = array_
  If Not IsArray(include) Then
    Result = include
    ReDim include(1 To 1, 1 To 1)
    include(1, 1) = Result
  End If
  For i = LBound(include) To UBound(include)
    If include(i, 1) Then j = j + 1
  Next
  With Application.Caller
    If j < .Rows.Count Then k = .Rows.Count Else k = j
    If j > .Rows.Count Then
      aFILTER = CVErr(xlErrNull)
      Exit Function
    End If
  End With
  ReDim Result(1 To k, 1 To UBound(Data, 2))
  k = 0
  For i = LBound(include) To UBound(include)
    If include(i, 1) Then
      k = k + 1
      For j = 1 To UBound(Data, 2)
        If IsEmpty(Data(i, j)) Then
          If Not IsMissing(if_empty) Then
            Data(i, j) = if_empty
          End If
        End If
        Result(k, j) = Data(i, j)
      Next
    End If
  Next
  For k = k + 1 To UBound(Result)
    For j = 1 To UBound(Data, 2)
      Result(k, j) = ""
    Next
  Next
  aFILTER = Result
End Function
#End If

#If ActivateRANDARRAY Then
Public Function RANDARRAY(Optional Rows, Optional Columns, Optional min, Optional max, Optional AsInteger)
Attribute RANDARRAY.VB_Description = "The RANDARRAY function returns an array of random numbers. You can specify the number of rows and columns to fill  minimum and maximum values  and whether to return whole numbers or decimal values."
Attribute RANDARRAY.VB_HelpID = 5
Attribute RANDARRAY.VB_ProcData.VB_Invoke_Func = " \n19"
  'https://support.office.com/en-ie/article/randarray-function-21261e55-3bec-4885-86a6-8b0a47fd4d33
  Dim Data
  Dim i As Long, j As Long, R As Long, c As Long
  Application.Volatile
  
  If IsMissing(Rows) Then Rows = 1 Else Rows = CLng(Rows)
  If IsMissing(Columns) Then Columns = 1 Else Columns = CLng(Columns)
  If IsMissing(min) Then min = 0 Else min = CDbl(min)
  If IsMissing(max) Then max = 1 Else max = CDbl(max)
  If IsMissing(AsInteger) Then AsInteger = False Else AsInteger = CBool(AsInteger)
  With Application.Caller
    If Rows > .Rows.Count Then
      RANDARRAY = CVErr(xlErrNull)
      Exit Function
    End If
    If Columns > .Columns.Count Then
      RANDARRAY = CVErr(xlErrNull)
      Exit Function
    End If
    If .Rows.Count > Rows Then R = .Rows.Count Else R = Rows
    If .Columns.Count > Columns Then c = .Columns.Count Else c = Columns
  End With
  ReDim Data(1 To R, 1 To c)
  For j = 1 To Columns
    For i = 1 To Rows
      Data(i, j) = Rnd() * (max - min) + min
    Next
    For i = i To R
      Data(i, j) = ""
    Next
  Next
  For j = j To c
    For i = 1 To R
      Data(i, j) = ""
    Next
  Next
  If AsInteger Then
    For j = 1 To Columns
      For i = 1 To Rows
        Data(i, j) = Int(Data(i, j))
      Next
    Next
  End If
  RANDARRAY = Data
End Function
#End If

#If ActivateSEQUENCE Then
Public Function aSEQUENCE(Rows, Optional Columns, Optional Start, Optional increment)
Attribute aSEQUENCE.VB_Description = "The SEQUENCE function allows you to generate a list of sequential numbers in an array  such as 1 2 3  4"
Attribute aSEQUENCE.VB_HelpID = 6
Attribute aSEQUENCE.VB_ProcData.VB_Invoke_Func = " \n19"
  'https://support.office.com/en-ie/article/aSEQUENCE-function-57467a98-57e0-4817-9f14-2eb78519ca90
  Dim Data
  Dim i As Long, j As Long, R As Long, c As Long
  Dim Value
  If IsMissing(Columns) Then Columns = 1 Else Columns = CLng(Columns)
  If IsMissing(Start) Then Start = 1 Else Start = CDbl(Start)
  If IsMissing(increment) Then increment = 1 Else increment = CDbl(increment)
  With Application.Caller
    If Rows > .Rows.Count Then
      aSEQUENCE = CVErr(xlErrNull)
      Exit Function
    End If
    If Columns > .Columns.Count Then
      aSEQUENCE = CVErr(xlErrNull)
      Exit Function
    End If
    If .Rows.Count > Rows Then R = .Rows.Count Else R = Rows
    If .Columns.Count > Columns Then c = .Columns.Count Else c = Columns
  End With
  ReDim Data(1 To R, 1 To c)
  For i = 1 To Rows
    For j = 1 To Columns
      Data(i, j) = Start
      Start = Start + increment
    Next
    For j = j To c
      Data(i, j) = ""
    Next
  Next
  For i = i To R
    For j = 1 To c
      Data(i, j) = ""
    Next
  Next
  aSEQUENCE = Data
End Function
#End If

#If ActivateSORT Then
Public Function SORT(array_, Optional sort_index, Optional sort_order, Optional by_col)
Attribute SORT.VB_Description = "The SORT function sorts the contents of a range or array."
Attribute SORT.VB_HelpID = 7
Attribute SORT.VB_ProcData.VB_Invoke_Func = " \n19"
  'https://support.office.com/en-ie/article/sort-function-22f63bd0-ccc8-492f-953d-c20e8e44b86c
  Dim Data
  Dim i As Long, j As Long
  Dim Start As Long, Ende As Long

  If IsMissing(sort_index) Then sort_index = 1
  If IsMissing(sort_order) Then sort_order = 1
  If IsMissing(by_col) Then by_col = False Else by_col = CBool(by_col)

  If IsObject(array_) Then Set array_ = Intersect(array_, array_.Parent.UsedRange)
  Data = array_
  With Application.Caller
    If .Rows.Count < UBound(Data) Then
      SORT = CVErr(xlErrNull)
      Exit Function
    End If
    If .Columns.Count < UBound(Data, 2) Then
      SORT = CVErr(xlErrNull)
      Exit Function
    End If
  End With
  
  If by_col Then
    Start = LBound(Data, 2)
    Ende = UBound(Data, 2)
  Else
    Start = LBound(Data)
    Ende = UBound(Data)
  End If
  QuickSort2D Data, sort_index, sort_order, by_col, Start, Ende

  With Application.Caller
    If .Rows.Count > UBound(Data) Or .Columns.Count > UBound(Data, 2) Then
      ReDim Temp(1 To WorksheetFunction.max(.Rows.Count, UBound(Data)), 1 To WorksheetFunction.max(.Columns.Count, UBound(Data, 2)))
      For j = 1 To UBound(Data, 2)
        For i = 1 To UBound(Data)
          Temp(i, j) = Data(i, j)
        Next
        For i = i To UBound(Temp)
          Temp(i, j) = ""
        Next
      Next
      For j = j To UBound(Temp, 2)
        For i = 1 To UBound(Temp)
          Temp(i, j) = ""
        Next
      Next
      SORT = Temp
    Else
      SORT = Data
    End If
  End With
End Function
#End If

#If ActivateSORTBY Then
Public Function SORTBY(array_, by_array1, ParamArray Args())
Attribute SORTBY.VB_Description = "The SORTBY function sorts the contents of a range or array based on the values in a corresponding range or array."
Attribute SORTBY.VB_HelpID = 8
Attribute SORTBY.VB_ProcData.VB_Invoke_Func = " \n19"
  'https://support.office.com/en-ie/article/sortby-function-cd2d7a62-1b93-435c-b561-d6a35134f28f
  Dim Data
  Dim i As Long, j As Long
  Dim Index As Long, Start As Long, Ende As Long, LastIndex As Long
  Dim by_array, sort_order, Value
  Dim A As Integer

  If IsObject(array_) Then Set array_ = Intersect(array_, array_.Parent.UsedRange)
  Data = array_
  With Application.Caller
    If .Rows.Count < UBound(Data) Then
      SORTBY = CVErr(xlErrNull)
      Exit Function
    End If
    If .Columns.Count < UBound(Data, 2) Then
      SORTBY = CVErr(xlErrNull)
      Exit Function
    End If
  End With
  
  Set by_array = by_array1
  If UBound(Args) >= 0 Then sort_order = Args(0) Else sort_order = 1
    
  Index = by_array.Column - array_.Column + 1
  Start = 1
  Ende = UBound(Data)
  QuickSort2D Data, Index, sort_order, 0, Start, Ende
  
  For A = 1 To UBound(Args) Step 2
    LastIndex = Index
    Set by_array = Args(A)
    sort_order = Args(A + 1)
    Index = by_array.Column - array_.Column + 1
    Start = 1
    Do
      Value = Data(Start, LastIndex)
      For Ende = Start To UBound(Data)
        If Value <> Data(Ende, LastIndex) Then Exit For
      Next
      QuickSort2D Data, Index, sort_order, 0, Start, Ende - 1
      Start = Ende
    Loop Until Ende > UBound(Data)
  Next

  With Application.Caller
    If .Rows.Count > UBound(Data) Or .Columns.Count > UBound(Data, 2) Then
      ReDim Temp(1 To WorksheetFunction.max(.Rows.Count, UBound(Data)), 1 To WorksheetFunction.max(.Columns.Count, UBound(Data, 2)))
      For j = 1 To UBound(Data, 2)
        For i = 1 To UBound(Data)
          Temp(i, j) = Data(i, j)
        Next
        For i = i To UBound(Temp)
          Temp(i, j) = ""
        Next
      Next
      For j = j To UBound(Temp, 2)
        For i = 1 To UBound(Temp)
          Temp(i, j) = ""
        Next
      Next
      SORTBY = Temp
    Else
      SORTBY = Data
    End If
  End With
End Function
#End If

#If ActivateUNIQUE Then
Public Function UNIQUE(array_, Optional by_col, Optional exactly_once)
Attribute UNIQUE.VB_Description = "The UNIQUE function returns a list of unique values in a list or range."
Attribute UNIQUE.VB_HelpID = 11
Attribute UNIQUE.VB_ProcData.VB_Invoke_Func = " \n19"
  'https://support.office.com/en-ie/article/unique-function-c5ab87fd-30a3-4ce9-9d1a-40204fb85e1e
  Dim Data, Temp, Key, Items, Keys
#If Mac Then
  Dim Dict As Dictionary
#Else
  Dim Dict As Object 'Scripting.Dictionary
#End If
  Dim i As Long, j As Long, R As Long, c As Long, u As Long

  If IsMissing(by_col) Then by_col = False Else by_col = CBool(by_col)
  If IsMissing(exactly_once) Then exactly_once = False Else exactly_once = CBool(exactly_once)

#If Mac Then
  Set Dict = New Dictionary
#Else
  Set Dict = CreateObject("Scripting.Dictionary")
#End If
  Dict.CompareMode = vbTextCompare
  
  If IsObject(array_) Then Set array_ = Intersect(array_, array_.Parent.UsedRange)
  Data = array_
  If by_col Then
    For j = 1 To UBound(Data, 2)
      ReDim Temp(1 To UBound(Data))
      For i = 1 To UBound(Data)
        Temp(i) = Data(i, j)
      Next
      Key = Join(Temp, vbNullChar)
      If Not Dict.Exists(Key) Then
        Dict.Add Key, Array(Temp, 1)
      Else
        Temp = Dict.Item(Key)
        Temp(1) = Temp(1) + 1
        Dict.Item(Key) = Temp
      End If
    Next
    Items = Dict.Items
    If exactly_once Then
      Keys = Dict.Keys
      For i = 0 To UBound(Items)
        If Items(i)(1) > 1 Then Dict.Remove Keys(i)
      Next
      Items = Dict.Items
    End If
    With Application.Caller
      If .Columns.Count < Dict.Count Then
        UNIQUE = CVErr(xlErrNull)
        Exit Function
      End If
      If .Rows.Count < UBound(Data) Then
        UNIQUE = CVErr(xlErrNull)
        Exit Function
      End If
      If .Rows.Count > UBound(Data) Then R = .Rows.Count Else R = UBound(Data)
      If .Columns.Count > Dict.Count Then c = .Columns.Count Else c = Dict.Count
      u = UBound(Data)
    End With
    ReDim Data(1 To R, 1 To c)
    For j = 0 To UBound(Items)
      For i = 1 To u
        Data(i, j + 1) = Items(j)(0)(i)
      Next
      For i = i To R
        Data(i, j + 1) = ""
      Next
    Next
    For j = j To c - 1
      For i = 1 To R
        Data(i, j + 1) = ""
      Next
    Next
  Else
    For i = 1 To UBound(Data)
      ReDim Temp(1 To UBound(Data, 2))
      For j = 1 To UBound(Data, 2)
        Temp(j) = Data(i, j)
      Next
      Key = Join(Temp, vbNullChar)
      If Not Dict.Exists(Key) Then
        Dict.Add Key, Array(Temp, 1)
      Else
        Temp = Dict.Item(Key)
        Temp(1) = Temp(1) + 1
        Dict.Item(Key) = Temp
      End If
    Next
    Items = Dict.Items
    If exactly_once Then
      Keys = Dict.Keys
      For i = 0 To UBound(Items)
        If Items(i)(1) > 1 Then Dict.Remove Keys(i)
      Next
      Items = Dict.Items
    End If
    With Application.Caller
      If .Rows.Count < Dict.Count Then
        UNIQUE = CVErr(xlErrNull)
        Exit Function
      End If
      If .Columns.Count < UBound(Data, 2) Then
        UNIQUE = CVErr(xlErrNull)
        Exit Function
      End If
      If .Rows.Count > Dict.Count Then R = .Rows.Count Else R = Dict.Count
      If .Columns.Count > UBound(Data, 2) Then c = .Columns.Count Else c = UBound(Data, 2)
      u = UBound(Data, 2)
    End With
    ReDim Data(1 To R, 1 To c)
    For i = 0 To UBound(Items)
      For j = 1 To u
        Data(i + 1, j) = Items(i)(0)(j)
      Next
      For j = j To c
        Data(i + 1, j) = ""
      Next
    Next
    For i = i To R - 1
      For j = 1 To c
        Data(i + 1, j) = ""
      Next
    Next
  End If
  UNIQUE = Data
End Function
#End If

'-------------------- Excel 365 Excel365Aug2019 --------------------

#If ActivateXLOOKUP Then
Public Function XLOOKUP(lookup_value, lookup_array, return_array, Optional not_found, Optional match_mode, Optional search_mode)
Attribute XLOOKUP.VB_Description = "Use the XLOOKUP function when you need to find things in a table or a range by row. With XLOOKUP  you can look in one column for a search term  and return a result from the same row in another column  regardless of which side the return column is on."
Attribute XLOOKUP.VB_HelpID = 12
Attribute XLOOKUP.VB_ProcData.VB_Invoke_Func = " \n19"
  'https://support.office.com/en-ie/article/xlookup-function-b7fd680e-6d10-43e6-84f9-88eae8bf5929
  Dim Result, i As Long
  If IsMissing(match_mode) Then match_mode = 0
  If IsMissing(search_mode) Then search_mode = 1
  If Abs(search_mode) > 1 Then
    Set XLOOKUP = xlfn_bin.XFIND(1, lookup_value, lookup_array, match_mode, search_mode, return_array)
  Else
    Set XLOOKUP = xlfn_text.XFIND(1, lookup_value, lookup_array, match_mode, search_mode, return_array)
  End If
  
  If XLOOKUP Is Nothing And Not IsMissing(not_found) Then
    ReDim Result(1 To return_array.Columns.Count)
    Result(1) = not_found
    For i = 2 To UBound(Result)
      Result(i) = ""
    Next
    XLOOKUP = Result
  End If
End Function
#End If

#If ActivateXMATCH Then
Public Function XMATCH(lookup_value, lookup_array, Optional match_mode)
Attribute XMATCH.VB_Description = "The XMATCH function searches for a specified item in an array or range of cells, and then returns the item's relative position. "
Attribute XMATCH.VB_HelpID = 13
Attribute XMATCH.VB_ProcData.VB_Invoke_Func = " \n19"
  'https://support.office.com/en-ie/article/xmatch-function-d966da31-7a6b-4a13-a1c6-5a33ed6a0312
  XMATCH = xlfn_text.XFIND(2, lookup_value, lookup_array, match_mode)
End Function
#End If
Attribute VB_Name = "xlfn_bin"
'Version 1.0 beta
'Andreas Killer
'22.11.2019

'Low level routines, binary compare

Option Explicit
Option Compare Binary
Option Private Module

#Const XFIND_bin = True

Function XFIND(return_type, lookup_value, lookup_array, Optional match_mode, Optional search_mode, Optional return_array)
  Dim Horizontal As Boolean
  Dim Data
  Dim i As Long, j As Long, f As Long, T As Long
  Dim Fit As Double, Dif As Double, p As Long
  Const MaxDouble = 1.79769313486231E+308
  If IsMissing(match_mode) Then match_mode = 0
  If IsMissing(search_mode) Then search_mode = 1
  Fit = MaxDouble

  If IsObject(lookup_array) Then Set lookup_array = Intersect(lookup_array, lookup_array.Parent.UsedRange)
  Data = lookup_array
  If Not IsArray(Data) Then
    ReDim Data(1 To 1, 1 To 1)
    Data(1, 1) = lookup_array
  End If
  Horizontal = UBound(Data, 2) > UBound(Data)

  If Horizontal Then
    Select Case Sgn(search_mode)
      Case 1
        'search from first
        f = 1
        T = UBound(Data, 2)
      Case -1
        'search from last
        f = UBound(Data, 2)
        T = 1
    End Select
    Select Case match_mode
      Case 0
        'exakt match
        For i = f To T Step Sgn(search_mode)
          If lookup_value = Data(1, i) Then
            If return_type = 1 Then Set XFIND = return_array.Columns(i) Else XFIND = i
            Exit Function
          End If
        Next
      Case -1
        For i = f To T Step Sgn(search_mode)
#If XFIND_bin Then
          'binary search descending
          If lookup_value >= Data(1, i) Then
            If return_type = 1 Then Set XFIND = return_array.Columns(i) Else XFIND = i
            Exit Function
          End If
#Else
          'exact match or next smallest
          If lookup_value = Data(1, i) Then
            If return_type = 1 Then Set XFIND = return_array.Columns(i) Else XFIND = i
            Exit Function
          Else
            If lookup_value > Data(1, i) Then
              Dif = lookup_value - Data(1, i)
              If Dif < Fit Then
                Fit = Dif
                p = i
              End If
            End If
          End If
#End If
        Next
        If p > 0 Then
          If return_type = 1 Then Set XFIND = return_array.Columns(p) Else XFIND = p
          Exit Function
        End If
      Case 1
        For i = f To T Step Sgn(search_mode)
#If XFIND_bin Then
          'binary search ascending
          If lookup_value <= Data(1, i) Then
            If return_type = 1 Then Set XFIND = return_array.Columns(i) Else XFIND = i
            Exit Function
          End If
#Else
          'exact match or next larger
          If lookup_value = Data(1, i) Then
            If return_type = 1 Then Set XFIND = return_array.Columns(i) Else XFIND = i
            Exit Function
          Else
            If lookup_value < Data(1, i) Then
              Dif = Abs(lookup_value - Data(1, i))
              If Dif < Fit Then
                Fit = Dif
                p = i
              End If
            End If
          End If
#End If
        Next
        If p > 0 Then
          If return_type = 1 Then Set XFIND = return_array.Columns(p) Else XFIND = p
          Exit Function
        End If
      Case -2, 2
        'wildcard
        For i = f To T Step Sgn(search_mode)
          If Data(1, i) Like lookup_value Then
            If return_type = 1 Then Set XFIND = return_array.Columns(i) Else XFIND = i
            Exit Function
          End If
        Next
    End Select
  Else
    Select Case Sgn(search_mode)
      Case 1
        'search from first
        f = 1
        T = UBound(Data)
      Case -1
        'search from last
        f = UBound(Data)
        T = 1
    End Select
    Select Case match_mode
      Case 0
        'exakt match
        For i = f To T Step Sgn(search_mode)
          If lookup_value = Data(i, 1) Then
            If return_type = 1 Then Set XFIND = return_array.Rows(i) Else XFIND = i
            Exit Function
          End If
        Next
      Case -1
        For i = f To T Step Sgn(search_mode)
#If XFIND_bin Then
          'binary search descending
          If lookup_value >= Data(i, 1) Then
            If return_type = 1 Then Set XFIND = return_array.Rows(i) Else XFIND = i
            Exit Function
          End If
#Else
          'exact match or next smallest
          If lookup_value = Data(i, 1) Then
            If return_type = 1 Then Set XFIND = return_array.Rows(i) Else XFIND = i
            Exit Function
          Else
            If lookup_value > Data(i, 1) Then
              Dif = lookup_value - Data(i, 1)
              If Dif < Fit Then
                Fit = Dif
                p = i
              End If
            End If
          End If
#End If
        Next
        If p > 0 Then
          If return_type = 1 Then Set XFIND = return_array.Rows(p) Else XFIND = p
          Exit Function
        End If
      Case 1
        For i = f To T Step Sgn(search_mode)
#If XFIND_bin Then
          'binary search ascending
          If lookup_value = Data(i, 1) Then
            If return_type = 1 Then Set XFIND = return_array.Rows(i) Else XFIND = i
            Exit Function
          End If
#Else
          'exact match or next larger
          If lookup_value = Data(i, 1) Then
            If return_type = 1 Then Set XFIND = return_array.Rows(i) Else XFIND = i
            Exit Function
          Else
            If lookup_value < Data(i, 1) Then
              Dif = Abs(lookup_value - Data(i, 1))
              If Dif < Fit Then
                Fit = Dif
                p = i
              End If
            End If
          End If
#End If
        Next
        If p > 0 Then
          If return_type = 1 Then Set XFIND = return_array.Rows(p) Else XFIND = p
          Exit Function
        End If
      Case -2, 2
        'wildcard
        For i = f To T Step Sgn(search_mode)
          If Data(i, 1) Like lookup_value Then
            If return_type = 1 Then Set XFIND = return_array.Rows(i) Else XFIND = i
            Exit Function
          End If
        Next
    End Select
  End If
  If return_type = 1 Then Set XFIND = Nothing Else XFIND = 0
End Function
Attribute VB_Name = "xlfn_text"
'Version 1.0 beta
'Andreas Killer
'22.11.2019

'Low level routines, text compare

Option Explicit
Option Compare Text
Option Private Module

#Const XFIND_bin = False

Function ProcessIFS(max_range, criteria_range1, criteria1, Args)
  Dim Data, CData, CComp, COp, CVal
  Dim Digit As String
  Dim A As Integer
  Dim i As Long, j As Long

  If IsObject(max_range) Then Set max_range = Intersect(max_range, max_range.Parent.UsedRange)
  Data = max_range
  If IsObject(criteria_range1) Then Set criteria_range1 = Intersect(criteria_range1, criteria_range1.Parent.UsedRange)
  CData = criteria_range1
  CComp = criteria1
  Do
    If IsEmpty(CComp) Then CComp = 0
    If UBound(Data) <> UBound(CData) Then
      ProcessIFS = CVErr(xlErrValue)
      Exit Function
    End If
    COp = ""
    For i = 1 To Len(CComp)
      Digit = Mid$(CComp, i, 1)
      Select Case Digit
        Case ">", "<", "="
          COp = COp & Digit
        Case Else
          Exit For
      End Select
    Next
    CVal = Mid(CComp, Len(COp) + 1)
    For i = 1 To UBound(Data)
      If IsEmpty(Data(i, 1)) Then GoTo Skip
      Select Case COp
        Case "", "="
          If StrComp(CData(i, 1), CVal, vbTextCompare) <> 0 Then
            Data(i, 1) = Empty
          End If
        Case ">"
          If CDbl(CData(i, 1)) > CDbl(CVal) Then Else Data(i, 1) = Empty
        Case ">="
          If CDbl(CData(i, 1)) >= CDbl(CVal) Then Else Data(i, 1) = Empty
        Case "<"
          If CDbl(CData(i, 1)) < CDbl(CVal) Then Else Data(i, 1) = Empty
        Case "<="
          If CDbl(CData(i, 1)) <= CDbl(CVal) Then Else Data(i, 1) = Empty
        Case "<>"
          If CDbl(CData(i, 1)) <= CDbl(CVal) Then Else Data(i, 1) = Empty
        Case Else
          ProcessIFS = CVErr(xlErrName)
          Exit Function
      End Select
Skip:
    Next
    If A > UBound(Args) Then Exit Do
    CData = Args(A)
    CComp = Args(A + 1)
    A = A + 2
  Loop
  j = 0
  For i = 1 To UBound(Data)
    If Not IsEmpty(Data(i, 1)) Then j = j + 1
  Next
  If j = 0 Then
    ProcessIFS = 0
    Exit Function
  End If
  ReDim CData(1 To j, 1 To 1)
  j = 0
  For i = 1 To UBound(Data)
    If Not IsEmpty(Data(i, 1)) Then
      j = j + 1
      CData(j, 1) = Data(i, 1)
    End If
  Next
  ProcessIFS = CData
End Function

Sub QuickSort2D(Data, ByVal Index As Long, ByVal Order As Integer, ByVal ByColumn As Boolean, ByVal Start As Long, ByVal Ende As Long)
  Const QTHRESH As Long = 20
  Dim i As Long, j As Long, k As Long
  Dim Pivot, Temp
  Dim Stack(1 To 64) As Long
  Dim StackPtr As Long

  If ByColumn Then
    ReDim Temp(LBound(Data, 1) To UBound(Data, 1))
    Stack(StackPtr + 1) = Start
    Stack(StackPtr + 2) = Ende
    StackPtr = StackPtr + 2
    Do
      StackPtr = StackPtr - 2
      Start = Stack(StackPtr + 1)
      Ende = Stack(StackPtr + 2)
      If Ende - Start < QTHRESH Then
        'Insertionsort
        For j = Start + 1 To Ende
          For k = LBound(Data, 1) To UBound(Data, 1)
            Temp(k) = Data(k, j)
          Next
          Pivot = Data(Index, j)
          For i = j - 1 To Start Step -1
            If Order >= 0 Then
              If Data(Index, i) <= Pivot Then Exit For
            Else
              If Data(Index, i) >= Pivot Then Exit For
            End If
            For k = LBound(Data) To UBound(Data)
              Data(k, i + 1) = Data(k, i)
            Next
          Next
          For k = LBound(Data) To UBound(Data)
            Data(k, i + 1) = Temp(k)
          Next
        Next
      Else
        'QuickSort
        i = Start: j = Ende
        Pivot = Data(Index, (Start + Ende) \ 2)
        Do
          If Order >= 0 Then
            Do While (Data(Index, i) < Pivot): i = i + 1: Loop
            Do While (Data(Index, j) > Pivot): j = j - 1: Loop
          Else
            Do While (Data(Index, i) > Pivot): i = i + 1: Loop
            Do While (Data(Index, j) < Pivot): j = j - 1: Loop
          End If
          If i <= j Then
            If i < j Then
              For k = LBound(Data) To UBound(Data)
                Temp(k) = Data(k, i)
                Data(k, i) = Data(k, j)
                Data(k, j) = Temp(k)
              Next
            End If
            i = i + 1: j = j - 1
          End If
        Loop Until i > j
        If (Start < j) Then
          Stack(StackPtr + 1) = Start
          Stack(StackPtr + 2) = j
          StackPtr = StackPtr + 2
        End If
        If (i < Ende) Then
          Stack(StackPtr + 1) = i
          Stack(StackPtr + 2) = Ende
          StackPtr = StackPtr + 2
        End If
      End If
    Loop Until StackPtr = 0
  Else
    ReDim Temp(LBound(Data, 2) To UBound(Data, 2))
    Stack(StackPtr + 1) = Start
    Stack(StackPtr + 2) = Ende
    StackPtr = StackPtr + 2
    Do
      StackPtr = StackPtr - 2
      Start = Stack(StackPtr + 1)
      Ende = Stack(StackPtr + 2)
      If Ende - Start < QTHRESH Then
        'Insertionsort
        For j = Start + 1 To Ende
          For k = LBound(Data, 2) To UBound(Data, 2)
            Temp(k) = Data(j, k)
          Next
          Pivot = Data(j, Index)
          For i = j - 1 To Start Step -1
            If Order >= 0 Then
              If Data(i, Index) <= Pivot Then Exit For
            Else
              If Data(i, Index) >= Pivot Then Exit For
            End If
            For k = LBound(Data, 2) To UBound(Data, 2)
              Data(i + 1, k) = Data(i, k)
            Next
          Next
          For k = LBound(Data, 2) To UBound(Data, 2)
            Data(i + 1, k) = Temp(k)
          Next
        Next
      Else
        'QuickSort
        i = Start: j = Ende
        Pivot = Data((Start + Ende) \ 2, Index)
        Do
          If Order >= 0 Then
            Do While (Data(i, Index) < Pivot): i = i + 1: Loop
            Do While (Data(j, Index) > Pivot): j = j - 1: Loop
          Else
            Do While (Data(i, Index) > Pivot): i = i + 1: Loop
            Do While (Data(j, Index) < Pivot): j = j - 1: Loop
          End If
          If i <= j Then
            If i < j Then
              For k = LBound(Data, 2) To UBound(Data, 2)
                Temp(k) = Data(i, k)
                Data(i, k) = Data(j, k)
                Data(j, k) = Temp(k)
              Next
            End If
            i = i + 1: j = j - 1
          End If
        Loop Until i > j
        If (Start < j) Then
          Stack(StackPtr + 1) = Start
          Stack(StackPtr + 2) = j
          StackPtr = StackPtr + 2
        End If
        If (i < Ende) Then
          Stack(StackPtr + 1) = i
          Stack(StackPtr + 2) = Ende
          StackPtr = StackPtr + 2
        End If
      End If
    Loop Until StackPtr = 0
  End If
End Sub

Function XFIND(return_type, lookup_value, lookup_array, Optional match_mode, Optional search_mode, Optional return_array)
  Dim Horizontal As Boolean
  Dim Data
  Dim i As Long, j As Long, f As Long, T As Long
  Dim Fit As Double, Dif As Double, p As Long
  Const MaxDouble = 1.79769313486231E+308
  If IsMissing(match_mode) Then match_mode = 0
  If IsMissing(search_mode) Then search_mode = 1
  Fit = MaxDouble

  If IsObject(lookup_array) Then Set lookup_array = Intersect(lookup_array, lookup_array.Parent.UsedRange)
  Data = lookup_array
  If Not IsArray(Data) Then
    ReDim Data(1 To 1, 1 To 1)
    Data(1, 1) = lookup_array
  End If
  Horizontal = UBound(Data, 2) > UBound(Data)

  If Horizontal Then
    Select Case Sgn(search_mode)
      Case 1
        'search from first
        f = 1
        T = UBound(Data, 2)
      Case -1
        'search from last
        f = UBound(Data, 2)
        T = 1
    End Select
    Select Case match_mode
      Case 0
        'exakt match
        For i = f To T Step Sgn(search_mode)
          If lookup_value = Data(1, i) Then
            If return_type = 1 Then Set XFIND = return_array.Columns(i) Else XFIND = i
            Exit Function
          End If
        Next
      Case -1
        For i = f To T Step Sgn(search_mode)
#If XFIND_bin Then
          'binary search descending
          If lookup_value >= Data(1, i) Then
            If return_type = 1 Then Set XFIND = return_array.Columns(i) Else XFIND = i
            Exit Function
          End If
#Else
          'exact match or next smallest
          If lookup_value = Data(1, i) Then
            If return_type = 1 Then Set XFIND = return_array.Columns(i) Else XFIND = i
            Exit Function
          Else
            If lookup_value > Data(1, i) Then
              Dif = lookup_value - Data(1, i)
              If Dif < Fit Then
                Fit = Dif
                p = i
              End If
            End If
          End If
#End If
        Next
        If p > 0 Then
          If return_type = 1 Then Set XFIND = return_array.Columns(p) Else XFIND = p
          Exit Function
        End If
      Case 1
        For i = f To T Step Sgn(search_mode)
#If XFIND_bin Then
          'binary search ascending
          If lookup_value <= Data(1, i) Then
            If return_type = 1 Then Set XFIND = return_array.Columns(i) Else XFIND = i
            Exit Function
          End If
#Else
          'exact match or next larger
          If lookup_value = Data(1, i) Then
            If return_type = 1 Then Set XFIND = return_array.Columns(i) Else XFIND = i
            Exit Function
          Else
            If lookup_value < Data(1, i) Then
              Dif = Abs(lookup_value - Data(1, i))
              If Dif < Fit Then
                Fit = Dif
                p = i
              End If
            End If
          End If
#End If
        Next
        If p > 0 Then
          If return_type = 1 Then Set XFIND = return_array.Columns(p) Else XFIND = p
          Exit Function
        End If
      Case -2, 2
        'wildcard
        For i = f To T Step Sgn(search_mode)
          If Data(1, i) Like lookup_value Then
            If return_type = 1 Then Set XFIND = return_array.Columns(i) Else XFIND = i
            Exit Function
          End If
        Next
    End Select
  Else
    Select Case Sgn(search_mode)
      Case 1
        'search from first
        f = 1
        T = UBound(Data)
      Case -1
        'search from last
        f = UBound(Data)
        T = 1
    End Select
    Select Case match_mode
      Case 0
        'exakt match
        For i = f To T Step Sgn(search_mode)
          If lookup_value = Data(i, 1) Then
            If return_type = 1 Then Set XFIND = return_array.Rows(i) Else XFIND = i
            Exit Function
          End If
        Next
      Case -1
        For i = f To T Step Sgn(search_mode)
#If XFIND_bin Then
          'binary search descending
          If lookup_value >= Data(i, 1) Then
            If return_type = 1 Then Set XFIND = return_array.Rows(i) Else XFIND = i
            Exit Function
          End If
#Else
          'exact match or next smallest
          If lookup_value = Data(i, 1) Then
            If return_type = 1 Then Set XFIND = return_array.Rows(i) Else XFIND = i
            Exit Function
          Else
            If lookup_value > Data(i, 1) Then
              Dif = lookup_value - Data(i, 1)
              If Dif < Fit Then
                Fit = Dif
                p = i
              End If
            End If
          End If
#End If
        Next
        If p > 0 Then
          If return_type = 1 Then Set XFIND = return_array.Rows(p) Else XFIND = p
          Exit Function
        End If
      Case 1
        For i = f To T Step Sgn(search_mode)
#If XFIND_bin Then
          'binary search ascending
          If lookup_value = Data(i, 1) Then
            If return_type = 1 Then Set XFIND = return_array.Rows(i) Else XFIND = i
            Exit Function
          End If
#Else
          'exact match or next larger
          If lookup_value = Data(i, 1) Then
            If return_type = 1 Then Set XFIND = return_array.Rows(i) Else XFIND = i
            Exit Function
          Else
            If lookup_value < Data(i, 1) Then
              Dif = Abs(lookup_value - Data(i, 1))
              If Dif < Fit Then
                Fit = Dif
                p = i
              End If
            End If
          End If
#End If
        Next
        If p > 0 Then
          If return_type = 1 Then Set XFIND = return_array.Rows(p) Else XFIND = p
          Exit Function
        End If
      Case -2, 2
        'wildcard
        For i = f To T Step Sgn(search_mode)
          If Data(i, 1) Like lookup_value Then
            If return_type = 1 Then Set XFIND = return_array.Rows(i) Else XFIND = i
            Exit Function
          End If
        Next
    End Select
  End If
  If return_type = 1 Then Set XFIND = Nothing Else XFIND = 0
End Function

' InQuest injected base64 decoded content
' *'Z,

INQUEST-PP=macro
