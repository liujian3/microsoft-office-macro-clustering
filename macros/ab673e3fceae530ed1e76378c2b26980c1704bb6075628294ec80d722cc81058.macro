Attribute VB_Name = "BSAddin"
Option Explicit
Option Private Module

Public Sub Auto_Open()
    On Error GoTo OOPS

    With CDDXApp
    End With
    
    With CEvents
    End With

    With CDDXLogin
    End With

    With CDDXHelper
    End With

    With CVarHelper
    End With

    With CDDXVar
    End With
    
'    Application.OnTime Now + TimeValue("00:00:01"), "AfterOpen"
    Call AfterOpen

OOPS:
    If Err.Number <> 0 Then
        Call CDDXHelper.LogError(Err.Description, "Auto_Open", False)
    End If

    On Error GoTo 0
    Exit Sub
End Sub

Private Sub AfterOpen()
 Dim Wb As Workbook
 
    On Error GoTo OOPS
'
'    With CEvents
'    End With
'
'    With DDXObjects.AppObject
'    End With
'
'    With DDXObjects.LoginObject
'    End With
'
'    With DDXObjects.HelperObject
'    End With
'
'    With CVarHelper
'    End With
'
'    With CDDXVar
'    End With
    
    For Each Wb In Workbooks
        Call CDDXApp.ProcessWorkbook(BSConsts.DDX_PID, Wb)
    Next
    
OOPS:
    If Err.Number <> 0 Then
        Call CDDXHelper.LogError(Err.Description, "AfterOpen", False)
    End If
    
    On Error GoTo 0
    Exit Sub
End Sub
Attribute VB_Name = "BSConsts"
Option Explicit
Option Private Module

Global Const DDX_PID As String = "29707791-56E7-4930-8118-AAF18BE861EB"

Global Const DDX_CONFIG_FILE As String = "ZEDDXBase.xml"

'doc/sheet
Global Const PROP_SHEET_ID As String = "ZE.sheet.id"
Global Const PROP_SHEET_TYPE As String = "ZE.sheet.type"
Global Const PROP_SHEET_VERSION As String = "ZE.sheet.ver"
'
Global Const ZEDOC_ID As String = "ZE.doc.id"
Global Const ZEDOC_VER As String = "ZE.doc.ver"
Global Const ZEDOC_VER_CREATOR As String = "ZE.doc.creator.ver"
Global Const ZEDOC_VER_CREATOR_NAME As String = "ZE.doc.creator.nam"
Global Const ZEDOC_REV As String = "ZE.doc.rev"
Global Const ZEDOC_NAME As String = "ZE.doc.nm"
Global Const ZEDOC_ZEWSPROXY As String = "ZE.doc.zewsproxy"
Global Const ZEDOC_TIMEZONE As String = "ZE.doc.tz"
Global Const ZEDOC_DD As String = "ZE.doc.dd"
Global Const ZEDOC_CONVERTION_COMPLETED As String = "ZE.doc.ccm"

'Global Const ZESHEET_CURVE_DATERANGE As String = "C1-STD"
'Global Const ZESHEET_CURVE_SINGLEDATE_RDOL As String = "C2-STD"
'Global Const ZESHEET_CURVE_SINGLEDATE_EDIT As String = "C2-EDIT"
'Global Const ZESHEET_CURVE_SINGLEDATE_EXCL As String = "C2-EXCL"
'Global Const ZESHEET_CURVE_SINGLEDATE_TRANS As String = "C2-TRANS"
'Global Const ZESHEET_CURVE_SINGLEDATE_FLX1 As String = "C2-FLX-1"
'Global Const ZESHEET_CURVE_TIMESERIES As String = "C2-TS"
'Global Const ZESHEET_CURVE_TIMESERIES_TRANS As String = "C2-TS-TRANS"
'Global Const ZESHEET_CURVE  As String = "C3"

Global Const UPLOAD_SHEET_PASSWORD As String = "upload0162"


Global Const G_UPLOAD_STATUS As String = "upload.status"
Global Const G_UPLOAD_LASTRUN As String = "upload.lastrun"
'
Global Const PROP_SAVED_ENTITIES As String = "ZE.savedEntities"

'
Global Const OLD_PROFSHEETNAME As String = "Saved Profiles"
Global Const OLD_REPORTSHEETNAME As String = "ZE Saved Reports"
'
'Global Const RPT_CLRINDX As Integer = 54

'upload sheet
Global Const UPLD_ERR_ADDR As String = "UPD.1"
'Global Const UPLD_ERR_ID As String = "UPD.2"

Global Const LF_ENCODE As String = "&#10;"

'stop timer
'Global Const STOP_TIMER_FINISH_LOADING As Integer = 0
'Global Const STOP_TIMER_LOGOUT As Integer = 1
'Global Const STOP_TIMER_NO_AUTO_REFRESH As Integer = 2

'upload sheet
Global Const UPLOAD_COLOR_ODD_ROW As Long = 16777215
Global Const UPLOAD_INSERT_ONLY As Long = &H1
Global Const UPLOAD_WAIT_3SEC As Long = &H2
'

'visibility of named ranges
Global Const NR_HIDDEN As String = "ZE.doc.nr.hidden"

'entity font colors
Global Const ENTITY_COLOR_HEADER_N_DATE As Long = 11
'
Global Const EXECUTION_RESULT_LDR_DEFAULT As Long = 0
Global Const EXECUTION_RESULT_LDR_CURVE_DATA As Long = 1
Attribute VB_Name = "BSConstsCP"
Option Explicit
Option Private Module

'curve
Global Const CURVE_GRP_NAME As String = "UNUSED"
Global Const CURVE_CHANGE_CLR_IDX As Integer = 50
Global Const CURVE_ERROR_CLR_IDX As Integer = 3
'Global Const CURVE_DATA_CLR_IDX As Integer = 1
'
Global Const CURVE_ROW_ALTERNATING_COLOR_1 As Long = 15790320 'RGB(240, 240, 240)
Global Const CURVE_ROW_ALTERNATING_COLOR_2 As Long = 16447216 'RGB(240, 246, 250)

Global Const CURVE_ROW_ODD_COLOR As Long = CURVE_ROW_ALTERNATING_COLOR_1 'RGB(240, 246, 250)
Global Const CURVE_ROW_EVEN_COLOR As Long = 16049626 'RGB(&HDA, &HE5, &HF4)

Global Const CURVE_ROW_HEADER_COLOR As Long = 16053492  'RGB(244, 244, 244)
Global Const CURVE_COLUMN_HEADER_COLOR As Long = 14935011  'RGB(227, 227, 227)
Global Const CURVE_COLUMN_HEADER_COLOR2 As Long = &HE6E6E6

Global Const CURVE_SHEET_INFO As String = "CUR.CI"
'Global Const CURVE_SHEET_INFO2 As String = "CUR.CI2"
'Global Const CURVE_SHEET_PERMISSION As String = "CUR.PM"
Global Const CURVE_SHEET_FLAGVALUES As String = "CUR.FVS"
Global Const CURVE_SHEET_CREATORS As String = "CUR.CRS"
Global Const CURVE_SHEET_FIND_CRITERION As String = "CUR.FIND.CRITERION"
Global Const CURVE_SHEET_PASSWORD As String = "curve0162"
Global Const CURVE_SHEET_VALIDATIONS As String = "CUR.VR"
Global Const CURVE_SHEET_SPLITS As String = "CUR.SPL"
Global Const CURVE_SHEET_DATE_TYPES As String = "CUR.TYPES"
Global Const CURVE_SHEET_CREATORS_1 As Long = 1 'max 16 gens
'
Global Const CURVE_F_SUPPRESS_FINALIZE As Long = &H1
Attribute VB_Name = "BSLstner"
Option Explicit
Option Private Module

Global Const DISPATCH_GET_HANDLE As Long = 1
Global Const DISPATCH_REFRESH_HANDLES As Long = 2
 
Private Const WM_DDX_DATA_READY As Long = (&H400 + &H400)
Private Const WM_DDX_IDLE As Long = (&H400 + &H401)
Private Const WM_DDX_EXIT_EDIT As Long = (&H400 + &H402)

Private m_reentrant As Boolean

#If VBA7 Then
Private m_hWnd As LongPtr
#Else
Private m_hWnd As Long
#End If

#If Win64 Or VBA7 Then
Public Function WndHandle() As LongPtr
#Else
Public Function WndHandle() As Long
#End If
    If m_hWnd = 0 Then
        m_hWnd = ZECreateListener(Application.hwnd, AddressOf CBListenerProc)
    End If
    WndHandle = m_hWnd
End Function

Private Function IsBusy() As Boolean
    On Error GoTo OOPS
    
    IsBusy = Not Application.Ready
    If IsBusy Then Exit Function
    
    IsBusy = IIf(Application.CalculationState = xlCalculating, True, False)
    If IsBusy Then Exit Function
    
    IsBusy = Not CCurveControl.IsReady
    
'    IsBusy = (Application.CommandBars(1).FindControl(id:=23, Recursive:=True).enabled = False)
'    If IsBusy Then Exit Function
    
OOPS:
    If Err.Number <> 0 Then
        'CDDXApp.DebugMessage = Err.Description
        IsBusy = True
    End If
    
    On Error GoTo 0
    Exit Function
End Function

Private Sub CBListenerProc(ByVal tMessage As LongPtr)
    'Stop
    
    If m_reentrant Then Exit Sub
    
    On Error GoTo OOPS
    
    If IsBusy() Then Exit Sub
    
    Application.EnableCancelKey = xlDisabled
'    Application.Interactive = False
    
    m_reentrant = True
    
    If tMessage = WM_DDX_DATA_READY Then
        Call CXLTaskSwitch.DisableTS
        Call CTimer.OnData
        Call CXLTaskSwitch.RestoreTS
        
    ElseIf tMessage = WM_DDX_IDLE Then
        Call CTimer.OnIdle
        
    ElseIf tMessage = WM_DDX_EXIT_EDIT Then
        Call CTimer.OnExitEditor
        
    End If
    
OOPS:
    m_reentrant = False
'    Application.Interactive = True
    
    Exit Sub
End Sub
Attribute VB_Name = "BSMacros"
Option Explicit
Option Private Module

Private Const SUPERCRIPT As String = "\^[CHR(39)]^\"

Private Const ITEM_IS_NEW As Long = 1
Private Const ITEM_SINGLE_DATE_COLUMN  As Long = 2
Private Const ITEM_SUPPRESS_NULLS  As Long = 3
Private Const ITEM_INTERVAL  As Long = 4
Private Const ITEM_IS_VERTICAL  As Long = 5
'

Private Sub SetFocusWhenUploadSheet()
    If CDDXApp.XLVersion <> 2003 Then Exit Sub
    Call ActiveWorkbook.ActiveSheet.range("F22").Activate
End Sub

Public Function MSaveUpload(Optional aSheet As Worksheet = Nothing, Optional isSync As Boolean = False) As String
    On Error GoTo OOPS

    Call SetFocusWhenUploadSheet
          
    With DDXObjects.UploadObject
        If CSheet.ZESheetID(IIf(aSheet Is Nothing, ActiveSheet, aSheet)) = vbNullString Then
            CSheet.ZESheetID(IIf(aSheet Is Nothing, ActiveSheet, aSheet)) = CDDXHelper.NewGUID()
        End If
        
        If CSheet.ZESheetType(IIf(aSheet Is Nothing, ActiveSheet, aSheet)) = vbNullString Then
            Dim tyid As String
            
            If CDDXApp.DialogMessage("Type info is missing." + vbCrLf + "Is this a Futures sheet ?", vbYesNo Or vbQuestion) = vbYes Then
                tyid = ZESHEET_FUTURES
            ElseIf CDDXApp.DialogMessage("Is this a Spot sheet ?", vbYesNo Or vbQuestion) = vbYes Then
                tyid = ZESHEET_SPOT
            ElseIf CDDXApp.DialogMessage("Is this a Forecast sheet ?", vbYesNo Or vbQuestion) = vbYes Then
                tyid = ZESHEET_FORECAST
            End If
            If tyid = vbNullString Then Exit Function
            
            CSheet.ZESheetType(IIf(aSheet Is Nothing, ActiveSheet, aSheet)) = tyid
        End If
        
        Set .sheet = aSheet
            
        .Quiet = isSync
        .Sync = isSync
        Call .Upload
    End With

OOPS:
    If Err.Number <> 0 Then
        Call CDDXHelper.LogError(Err.Description, Err.source, False)
    End If
    Exit Function
End Function

'Load MetaData of the report
Public Sub MLoadMetaData(Optional synchro As Boolean = False, Optional noMessages As Boolean = False)
    On Error GoTo OOPS

    With DDXObjects.UploadObject
        If CSheet.ZESheetID(ActiveSheet) = vbNullString Then
            CSheet.ZESheetID(ActiveSheet) = CDDXHelper.NewGUID()
        End If
            
        Set .sheet = ActiveSheet
        Call .UploadMetaData
    End With

OOPS:
    If Err.Number <> 0 Then
        Call CDDXHelper.LogError(Err.Description, Err.source, False)
    End If
    Exit Sub
End Sub

Public Sub MExport()
 Dim filename As String
 
    On Error GoTo OOPS
          
    With DDXObjects.UploadObject
        Set .sheet = ActiveSheet
        If (.Validate() = False) Then Exit Sub
    End With
              
    With Application.FileDialog(msoFileDialogSaveAs)
        .title = CDDXApp.DDXTitle
        .AllowMultiSelect = False
        .FilterIndex = 11
        If .Show() Then filename = .SelectedItems(1)
    End With
          
    If Len(filename) > 0 Then
        With DDXObjects.UploadObject
            Call .SaveData(filename)
        End With
    End If

OOPS:
    If Err.Number <> 0 Then
        Call CDDXHelper.LogError(Err.Description, Err.source, True)
    End If
    Exit Sub
End Sub

Public Sub MImport()
 Dim filename As String
 
    On Error GoTo OOPS

    With Application.FileDialog(msoFileDialogFilePicker)
        .title = CDDXApp.DDXTitle
        .AllowMultiSelect = False
        .filters.Clear
        .filters.Add "Text(Tab delimited)", "*.txt"
        .filters.Add "All Files", "*.*"
        .FilterIndex = 1
        If .Show() Then
            filename = .SelectedItems(1)
        End If
    End With
          
    If Len(filename) = 0 Then Exit Sub
    
    With DDXObjects.UploadObject
        Set .sheet = ActiveSheet
        Call .ImportFile(filename)
    End With

OOPS:
    If Err.Number <> 0 Then
        Call CDDXHelper.LogError(Err.Description, Err.source, True)
    End If
    Exit Sub
End Sub

Private Sub RaiseAPILoadedEvent(entity As ZEWSProxy.DataDirectEntity)
    On Error GoTo OOPS
    
    If (CDDXUtility.IsProfileDataEntity(DDX_PID, entity)) Then
        Call CProfile.RaiseOnAfterProfileLoad(DDX_PID, entity)
    ElseIf (CDDXUtility.IsReportDataEntity(DDX_PID, entity)) Then
        Call CReport.RaiseOnAfterReportLoad(DDX_PID, entity)
    ElseIf (CDDXUtility.IsDCurveDataEntity(DDX_PID, entity)) Then
        Call CDCurve.RaiseOnAfterDCurveLoad(DDX_PID, entity)
#If SMARTMAT_USE Then
    ElseIf (CDDXUtility.IsSmartMartDataEntity(DDX_PID, entity)) Then
        Call CSmartMart.RaiseOnAfterSmartMartLoad(DDX_PID, entity)
#End If
    End If
    
OOPS:
    If Err.Number <> 0 Then
        CDDXApp.StatusMessage = Err.Description
    End If
    Exit Sub
End Sub

Public Sub OnEntityData(filename As String, ByVal userData As String)
 Dim entity As ZEWSProxy.DataDirectEntity
 Dim flgs As Long
 Dim fr As range
  
    If Len(filename) <= 0 Then Exit Sub
    
    On Error GoTo OOPS
 
    Set entity = CDDXEntity.GetEntityByTaskId(BSConsts.DDX_PID, filename, fr)
    
    If entity Is Nothing Then
        Call CDDXEntity.FireUponEntityError(DDX_PID, filename, vbNullString)
        Call CDDXUtility.DeleteTempFilesByTaskId(filename)
        Exit Sub
    End If

    entity.IsLoading = False
    entity.LastRunningTime = Now

    If entity.executeResult.errorMessage = vbNullString Or Not entity.IsFromFormula Then
'        If Not CDDXEntity.IsEntityStale(DDX_PID, entity ) Then
         
            If entity.entityOption.IsPreserveFormat And Not entity.SettingChanged(ITEM_IS_NEW, Val(userData)) Then
                If entity.SettingChanged(ITEM_SINGLE_DATE_COLUMN, Val(userData)) Or _
                   entity.SettingChanged(ITEM_INTERVAL, Val(userData)) Or _
                   entity.SettingChanged(ITEM_IS_VERTICAL, Val(userData)) Then
                    entity.entityOption.IsPreserveFormat = False
                    flgs = 1
                End If
            End If
            
            Call EntityDataHandler(entity, fr)
            
            If entity.IsAPI Then
                Call RaiseAPILoadedEvent(entity)
            End If
'        End If
    Else
        If entity.IsAPI Then
            Call RaiseAPILoadedEvent(entity)
        Else
            Call CDDXEntity.FireUponEntityError(DDX_PID, filename, entity.executeResult.errorMessage)
        End If
    End If

OOPS:
    If Err.Number <> 0 Then
        Call CDDXHelper.LogError(Err.Description, "OnEntityTimer")
    End If
    
    If Not entity Is Nothing Then
        If Not entity.IsFromFormula Then
            entity.IsBase = True

            If flgs = 1 Then
                entity.entityOption.IsPreserveFormat = True
            End If
        End If
    End If
    
    On Error GoTo 0
    Exit Sub
End Sub

Private Sub EntityDataHandler(entity As ZEWSProxy.DataDirectEntity, targetR As range)
 Dim targetRange As range
 Dim formulaWorkSheet As Worksheet
 Dim startTime As Date
 Dim emsg As String
 Dim esite As String
 Dim enumb As Long
 
    On Error GoTo OOPS

    startTime = Now
    
    Call CDDXEntity.RaiseEventByID(DDX_PID, 4, entity) ' OnEntityRetrievedFromServer(entity)
    Call CEntityHelper.DeleteRefreshingComment(entity)
    Set targetRange = CDDXUtility.GetRange(BSConsts.DDX_PID, entity)
          
    If (entity.executeResult.IsCancelled Or Len(entity.executeResult.errorMessage) > 0) Then
        If entity.ExecutionRefreshType <> RefreshType_FullRefresh Then
            entity.startDate = entity.DataStartDate
            entity.enddate = entity.DataEndDate
            'CDDXApp.StatusMessage = entity.Caption + "  refresh failed. The error message is: " + entity.executeResult.errorMessage
            Call CDDXUtility.DeleteTempFilesByTaskId(entity.taskID)
        Else
            If (Len(entity.executeResult.errorMessage) > 0) And entity.IsBase Then
                If Not (targetRange Is Nothing) Then
                    Call CEntityHelper.AddErrToComment(entity)
                Else
                    CDDXApp.StatusMessage = entity.executeResult.errorMessage
                End If
            End If
            'CDDXApp.StatusMessage = entity.executeResult.errorMessage
            
            Call CDDXUtility.DeleteTempFilesByTaskId(entity.taskID)
            If targetRange Is Nothing And entity.IsBase Then
                If (CDDXUtility.IsProfileDataEntity(BSConsts.DDX_PID, entity)) Then
                    Call CDDXEntity.RaiseEventByID(DDX_PID, 1, entity) 'RaiseEvent OnPopulateProfile(entity)
                ElseIf (CDDXUtility.IsReportDataEntity(BSConsts.DDX_PID, entity)) Then
                    Call CDDXEntity.RaiseEventByID(DDX_PID, 2, entity) 'RaiseEvent OnPopulateReport(entity)
                ElseIf (CDDXUtility.IsDCurveDataEntity(BSConsts.DDX_PID, entity)) Then
                    Call CDDXEntity.RaiseEventByID(DDX_PID, 5, entity) 'RaiseEvent OnPopulateDCurve(entity)
                Else
                    Call CDDXEntity.RaiseEventByID(DDX_PID, 3, entity) 'RaiseEvent OnPopulateEntity(entity)
                End If
            End If
        End If
        
        Call CDDXHelper.LogError(entity.executeResult.errorMessage, "EntityTimerHandler")
        Call CEntityHelper.AddErrToComment(entity)
    Else
        If entity.executeResult.DataRowsCount < 0 Then
            If entity.ExecutionRefreshType = RefreshType_IncrementalRefresh Or entity.ExecutionRefreshType = RefreshType_IncrementalFillRefresh Then
            'Call CDDXEntity.IncrementalRefreshCleanup(BSConsts.DDX_PID, entity, targetRange)
            End If
        ElseIf CDDXUtility.IsResultReadyForTaskId(entity.taskID) Then
            If (entity.IsFromFormula And (targetRange Is Nothing)) Then
                Set targetRange = targetR
            End If
            If (targetRange Is Nothing) Then
                If (Len(entity.sheetId) = 0) Then
                    If (CDDXUtility.IsProfileDataEntity(BSConsts.DDX_PID, entity)) Then
                        Call CDDXEntity.RaiseEventByID(DDX_PID, 1, entity) 'RaiseEvent OnPopulateProfile(entity)
                    ElseIf (CDDXUtility.IsReportDataEntity(BSConsts.DDX_PID, entity)) Then
                        Call CDDXEntity.RaiseEventByID(DDX_PID, 2, entity) 'RaiseEvent OnPopulateReport(entity)
#If SMARTMAT_USE Then
                    ElseIf (CDDXUtility.IsSmartMartDataEntity(BSConsts.DDX_PID, entity)) Then
                        Call CDDXEntity.RaiseEventByID(DDX_PID, 3, entity) 'RaiseEvent OnPopulateEntity(entity)
#End If
                    ElseIf (CDDXUtility.IsDCurveDataEntity(BSConsts.DDX_PID, entity)) Then
                        Call CDDXEntity.RaiseEventByID(DDX_PID, 5, entity) 'RaiseEvent OnPopulateDCurve(entity)
                    Else
                        Call CDDXUtility.DeleteTempFilesByTaskId(entity.taskID)
                    End If
                Else
                    Call CDDXUtility.DeleteTempFilesByTaskId(entity.taskID)
                End If
            Else
                Select Case entity.ExecutionRefreshType
                    Case RefreshType_SelectionRefresh
                        Call CDDXEntity.MergeSelectionRefreshResult(BSConsts.DDX_PID, entity, targetRange)
                    Case RefreshType_IncrementalRefresh
                        Call CDDXEntity.MergeIncrementalRefreshResult(BSConsts.DDX_PID, entity, targetRange)
                    Case RefreshType_IncrementalFillRefresh
                        Call CDDXEntity.MergeIncrementalRefreshResult(BSConsts.DDX_PID, entity, targetRange)
                    Case Else
                        Call CDDXEntity.PopulateData(DDX_PID, entity, targetRange)
                End Select
            End If
            CDDXApp.StatusMessage = vbNullString
        End If
    End If

OOPS:
    
    If Err.Number <> 0 Then
        enumb = Err.Number
        emsg = Err.Description
        esite = Err.source
    End If
    
    entity.ExecutionRefreshType = RefreshType_FullRefresh
    entity.LastRunningTime = startTime
    
    If enumb <> 0 Then Err.Raise enumb, esite, emsg
End Sub

Public Function DecodeMacroParam(ByVal aStr As String) As String
    DecodeMacroParam = Replace(aStr, SUPERCRIPT, "'")
End Function

Public Function EncodeMacroParam(ByVal aStr As String) As String
 Dim msk As Long
    
    msk = ZEStrContainQuotes(StrPtr(aStr))
    If msk <> 0 Then
        If (msk And &H2&) <> 0 Then aStr = Replace(aStr, "'", SUPERCRIPT)
        If (msk And &H1&) <> 0 Then aStr = Replace(aStr, """", """""")
    End If
    EncodeMacroParam = aStr
End Function

Public Sub ResetStatusBar()
    On Local Error GoTo OOPS
    
    Application.StatusBar = False
    
OOPS:
    On Local Error GoTo 0
    Exit Sub
End Sub
Attribute VB_Name = "BSMacrosCP"
Option Explicit
Option Private Module

Global Const OID_ACCEPT_ALL As Integer = 20
Global Const OID_ACCEPT As Integer = 21

Global Const AT_HISTORY As String = "History"
Global Const AT_SORT As String = "Sort"
Global Const AT_DELETE As String = "Delete"
Global Const AT_NAME As String = "Name"
Global Const AT_DOWNLOAD As String = "Download"
Global Const AT_UPLOAD As String = "Upload"
Global Const AT_ACCEPT As String = "Accept"
Global Const AT_ACCEPT_ALL As String = "AcceptAll"


Dim m_caller As String

Private Function GetSheetName() As String
    If ActiveSheet Is Nothing Then Exit Function
    GetSheetName = vbCrLf + "[" + ActiveSheet.name + "]"
End Function

Private Sub UnsetFocus()
 Dim shp As Shape
 
    On Error GoTo OOPS

    If CDDXApp.XLVersion <= 2003 Then Exit Sub
    If m_caller = vbNullString Then Exit Sub
    
    If ActiveSheet.Shapes Is Nothing Then Exit Sub
    
    'need to check the shaped was deleted like Accept
    For Each shp In ActiveSheet.Shapes
        If StrComp(shp.name, m_caller) = 0 Then
            shp.Line.Visible = MsoTriState.msoFalse
            Exit For
        End If
    Next
    
OOPS:
    If Err.Number <> 0 Then
        Call CDDXHelper.LogError(Err.Description, Err.source, False)
    End If

    On Error GoTo 0
    Exit Sub
End Sub

Private Sub SetFocus()
 Dim f As Variant
          
    On Error GoTo OOPS

    If CDDXApp.XLVersion <= 2003 Then Exit Sub
          
    m_caller = vbNullString
    If iserror(Application.Caller) Then Exit Sub
    If StrComp(TypeName(Application.Caller), "String", vbTextCompare) <> 0 Then Exit Sub
          
    For Each f In ActiveSheet.Shapes
        If StrComp(f.name, Application.Caller, vbTextCompare) = 0 Then
            With ActiveSheet.Shapes(Application.Caller).Line
                .Visible = MsoTriState.msoTrue
                .Weight = 1
                .ForeColor.RGB = RGB(0, 0, 0)
            End With
            DoEvents
                  
            m_caller = Application.Caller
            Exit For
        End If
    Next

OOPS:
    If Err.Number <> 0 Then
        Call CDDXHelper.LogError(Err.Description, Err.source, False)
    End If
    
    On Error GoTo 0
    Exit Sub
End Sub

Private Function NoActionOnShareMode() As Boolean
    NoActionOnShareMode = IIf(WndHandle() = 0, True, False)
    If NoActionOnShareMode Then
        Call CDDXApp.DialogMessage("No valid monitor.", vbExclamation)
        Exit Function
    End If
    
    NoActionOnShareMode = CDDXHelper.IsSharedMode(ActiveWorkbook)
    If NoActionOnShareMode Then
        Call CDDXApp.DialogMessage("CurveProtal does not work in Share mode.", vbExclamation)
        Exit Function
    End If
    
    NoActionOnShareMode = CCurveControl.IsSheetGrouped(ActiveSheet)
    If NoActionOnShareMode Then
        Call CDDXApp.DialogMessage("CurveProtal does not work with grouped sheet.", vbExclamation)
        Exit Function
    End If
    
    NoActionOnShareMode = Not CDDXLogin.Loggedin
    If NoActionOnShareMode Then
        Call CDDXApp.DialogMessage("Login required!.", vbExclamation)
        Exit Function
    End If
    
    If CDDXHelper.IsCurveSheet(ActiveSheet) Then
    
    End If
    
    Call CCurveControl.DeleteInputFile(ActiveSheet)
End Function

Public Sub MacroEditDateSettings()
    Call Application.OnTime(Now, "CPEditDateSettings")
End Sub

Public Sub CPEditDateSettings()
    If NoActionOnShareMode() Then Exit Sub
    If Not IsRightCurveSheet() Then Exit Sub
    
    On Error GoTo OOPS
    
    Application.EnableCancelKey = xlDisabled
    
    Call SetFocus
    Call CDDXCurve.MacroEditDateSettings(BSConsts.DDX_PID)
    Call UnsetFocus

OOPS:
    If Err.Number <> 0 Then
        Call CDDXHelper.LogError(Err.Description + GetSheetName(), Err.source, True)
    End If
    
    On Error GoTo 0
    Exit Sub
End Sub

Private Function IsRightCurveSheet() As Boolean
    CDDXHelper.LastMessage = vbNullString
    
    IsRightCurveSheet = CDDXHelper.IsCurveSheet(ActiveSheet)
    
    If IsRightCurveSheet Then
        IsRightCurveSheet = CCurveControl.SaveEffectiveStartDate
    Else
        CDDXApp.StatusMessage = "This curve sheet is not supported !"
    End If
End Function

Public Sub MacroContract()
    If NoActionOnShareMode() Then Exit Sub
    If Not IsRightCurveSheet() Then Exit Sub
    
    On Error GoTo OOPS
    
    Application.EnableCancelKey = xlDisabled
    Call SetFocus
    Call CDDXCurve.MacroContract(BSConsts.DDX_PID)
    Call UnsetFocus

OOPS:
    If Err.Number <> 0 Then
        Call CDDXHelper.LogError(Err.Description + GetSheetName(), Err.source, True)
    End If

    On Error GoTo 0
    Exit Sub
End Sub

Public Sub MacroSort(ByVal aColumn As Long)
    Call Application.OnTime(Now, MacroActionStrEx(False, "CPSort", aColumn))
End Sub

Public Sub CPSort(ByVal aColumn As Long)
    If NoActionOnShareMode() Then Exit Sub
    If Not IsRightCurveSheet() Then Exit Sub
    
    On Error GoTo OOPS

    Call SetFocus
    Call CDDXCurve.MacroSort(BSConsts.DDX_PID, aColumn)
    Call UnsetFocus

OOPS:
    If Err.Number <> 0 Then
        Call CDDXHelper.LogError(Err.Description + GetSheetName(), Err.source, True)
    End If
    
    On Error GoTo 0
    Exit Sub
End Sub

Public Sub MacroSortS(ByVal aGroupName As String, ByVal aCurveName As String, Optional ByVal methodID As String)
    Call Application.OnTime(Now, MacroActionStrEx(False, "CPSortS", aGroupName, aCurveName))
End Sub

Public Sub CPSortS(ByVal aGroupName As String, ByVal aCurveName As String)
    If NoActionOnShareMode() Then Exit Sub
    If Not IsRightCurveSheet() Then Exit Sub
    
    On Error GoTo OOPS

    aGroupName = DecodeMacroParam(aGroupName)
    aCurveName = DecodeMacroParam(aCurveName)
          
    Call SetFocus
    Call CDDXCurve.MacroSortS(BSConsts.DDX_PID, aGroupName, aCurveName)
    Call UnsetFocus

OOPS:
    If Err.Number <> 0 Then
        Call CDDXHelper.LogError(Err.Description + GetSheetName(), Err.source, True)
    End If
    
    On Error GoTo 0
    Exit Sub
End Sub

Public Sub MacroPivot()

End Sub

Public Sub MacroDownload()
    If NoActionOnShareMode() Then Exit Sub
    If Not IsRightCurveSheet() Then Exit Sub
    
    On Error GoTo OOPS

    Application.EnableCancelKey = xlDisabled
    Call SetFocus
    Call CDDXCurve.MacroDownload(BSConsts.DDX_PID)
    Call UnsetFocus

OOPS:
    If Err.Number <> 0 Then
        Call CDDXHelper.LogError(Err.Description + GetSheetName(), Err.source, True)
    End If

    On Error GoTo 0
    Exit Sub
End Sub

Public Sub MacroUpload()
    Call Application.OnTime(Now, "CPUpload")
End Sub

Public Sub CPUpload()
    If NoActionOnShareMode() Then Exit Sub
    If Not IsRightCurveSheet() Then Exit Sub
    
    On Error GoTo OOPS

    Application.EnableCancelKey = xlDisabled
    Call SetFocus
    Call CDDXCurve.MacroUpload(BSConsts.DDX_PID)
    Call UnsetFocus

OOPS:
    If Err.Number <> 0 Then
        Call CDDXHelper.LogError(Err.Description + GetSheetName(), Err.source, True)
    End If

    On Error GoTo 0
    Exit Sub
End Sub

Public Sub MacroEditDateSettingsS()
    Call Application.OnTime(Now, "CPEditDateSettingsS")
End Sub

Public Sub CPEditDateSettingsS()
    If NoActionOnShareMode() Then Exit Sub
    If Not IsRightCurveSheet() Then Exit Sub
    
    On Error GoTo OOPS

    Application.EnableCancelKey = xlDisabled
    Call SetFocus
    Call CDDXCurve.MacroEditDateSettingsS(BSConsts.DDX_PID)
    Call UnsetFocus

OOPS:
    If Err.Number <> 0 Then
        Call CDDXHelper.LogError(Err.Description + GetSheetName(), Err.source, True)
    End If

    On Error GoTo 0
    Exit Sub
End Sub

Public Sub MacroContractS()
    If NoActionOnShareMode() Then Exit Sub
    If Not IsRightCurveSheet() Then Exit Sub
    
    On Error GoTo OOPS

    Application.EnableCancelKey = xlDisabled
    Call SetFocus
    Call CDDXCurve.MacroContractS(BSConsts.DDX_PID)
    Call UnsetFocus

OOPS:
    If Err.Number <> 0 Then
        Call CDDXHelper.LogError(Err.Description + GetSheetName(), Err.source, True)
    End If

    On Error GoTo 0
    Exit Sub
End Sub

Public Sub MacroDownloadAllS()
    If NoActionOnShareMode() Then Exit Sub
    If Not IsRightCurveSheet() Then Exit Sub
    
    On Error GoTo OOPS

    Application.EnableCancelKey = xlDisabled
    Call SetFocus
    Call CDDXCurve.MacroDownloadAllS(BSConsts.DDX_PID)
    Call UnsetFocus
    
OOPS:
    If Err.Number <> 0 Then
        Call CDDXHelper.LogError(Err.Description + GetSheetName(), Err.source, True)
    End If

    On Error GoTo 0
    Exit Sub
End Sub

Public Sub MacroViewHistoryS(ByVal aGroupName As String, ByVal aCurveName As String, Optional ByVal methodID As String)
    If NoActionOnShareMode() Then Exit Sub
    If Not IsRightCurveSheet() Then Exit Sub
    
    On Error GoTo OOPS

    aGroupName = DecodeMacroParam(aGroupName)
    aCurveName = DecodeMacroParam(aCurveName)
          
    Application.EnableCancelKey = xlDisabled
    Call SetFocus
    Call CDDXCurve.MacroViewHistoryS(BSConsts.DDX_PID, aGroupName, aCurveName)
    Call UnsetFocus

OOPS:
    If Err.Number <> 0 Then
        Call CDDXHelper.LogError(Err.Description + GetSheetName(), Err.source, True)
    End If

    On Error GoTo 0
    Exit Sub
End Sub

Public Sub V2ViewHistoryS()
    If NoActionOnShareMode() Then Exit Sub
    If Not IsRightCurveSheet() Then Exit Sub
    
    On Error GoTo OOPS

    Application.EnableCancelKey = xlDisabled
    Call CDDXCurve.MacroViewHistoryS(DDX_PID, vbNullString, GetV2CBCurveName(CURVE_V2CB_VIEW))

OOPS:
    If Err.Number <> 0 Then
        Call CDDXHelper.LogError(Err.Description + GetSheetName(), Err.source, True)
    End If

    On Error GoTo 0
    Exit Sub
End Sub

Public Sub MacroDeleteS(ByVal aGroupName As String, ByVal aCurveName As String, Optional ByVal methodID As String)
    Call Application.OnTime(Now, MacroActionStrEx(False, "CPDeleteS", aGroupName, aCurveName))
End Sub

Public Sub CPDeleteS(ByVal aGroupName As String, ByVal aCurveName As String)
    If NoActionOnShareMode() Then Exit Sub
    If Not IsRightCurveSheet() Then Exit Sub
    
    On Error GoTo OOPS

    aGroupName = DecodeMacroParam(aGroupName)
    aCurveName = DecodeMacroParam(aCurveName)
          
    Call SetFocus
    Call CDDXCurve.MacroDeleteS(BSConsts.DDX_PID, aGroupName, aCurveName)
    Call UnsetFocus

OOPS:
    If Err.Number <> 0 Then
        Call CDDXHelper.LogError(Err.Description + GetSheetName(), Err.source, True)
    End If
    
    Call ResetFocusedCell
    On Error GoTo 0
    Exit Sub
End Sub

Public Sub V2Delete()
    If NoActionOnShareMode() Then Exit Sub
    If Not IsRightCurveSheet() Then Exit Sub
    
    On Error GoTo OOPS

    Call CDDXCurve.MacroDeleteS(DDX_PID, vbNullString, GetV2CBCurveName(CURVE_V2CB_DELETE))

OOPS:
    If Err.Number <> 0 Then
        Call CDDXHelper.LogError(Err.Description + GetSheetName(), Err.source, True)
    End If
    
    Call ResetFocusedCell
    On Error GoTo 0
    Exit Sub
End Sub

Public Sub MacroDownloadS(ByVal aGroupName As String, ByVal aCurveName As String, Optional ByVal methodID As String)
    If NoActionOnShareMode() Then Exit Sub
    If Not IsRightCurveSheet() Then Exit Sub
    
    On Error GoTo OOPS

    aGroupName = DecodeMacroParam(aGroupName)
    aCurveName = DecodeMacroParam(aCurveName)
          
    Application.EnableCancelKey = xlDisabled
    Call SetFocus
    Call CDDXCurve.MacroDownloadS(BSConsts.DDX_PID, aGroupName, aCurveName)
    Call UnsetFocus

OOPS:
    If Err.Number <> 0 Then
        Call CDDXHelper.LogError(Err.Description + GetSheetName(), Err.source, True)
    End If

    On Error GoTo 0
    Exit Sub
End Sub

Public Sub V2DownloadS()
    If NoActionOnShareMode() Then Exit Sub
    If Not IsRightCurveSheet() Then Exit Sub
    
    On Error GoTo OOPS

    Application.EnableCancelKey = xlDisabled
    Call CDDXCurve.MacroDownloadS(DDX_PID, vbNullString, GetV2CBCurveName(CURVE_V2CB_DOWNLOAD))

OOPS:
    If Err.Number <> 0 Then
        Call CDDXHelper.LogError(Err.Description + GetSheetName(), Err.source, True)
    End If

    On Error GoTo 0
    Exit Sub
End Sub

Public Sub MacroUploadS(ByVal aGroupName As String, ByVal aCurveName As String, Optional ByVal methodID As String)
    Call Application.OnTime(Now, MacroActionStrEx(False, "CPUploadS", aGroupName, aCurveName))
End Sub

Public Sub CPUploadS(ByVal aGroupName As String, ByVal aCurveName As String)
    If NoActionOnShareMode() Then Exit Sub
    If Not IsRightCurveSheet() Then Exit Sub
    
    On Error GoTo OOPS

    aGroupName = DecodeMacroParam(aGroupName)
    aCurveName = DecodeMacroParam(aCurveName)
          
    Application.EnableCancelKey = xlDisabled
    Call SetFocus
    Call CDDXCurve.MacroUploadS(BSConsts.DDX_PID, aGroupName, aCurveName)
    Call UnsetFocus

OOPS:
    If Err.Number <> 0 Then
        Call CDDXHelper.LogError(Err.Description + GetSheetName(), Err.source, True)
    End If
 
    On Error GoTo 0
    Exit Sub
End Sub

Public Sub V2UploadS()
    If NoActionOnShareMode() Then Exit Sub
    If Not IsRightCurveSheet() Then Exit Sub
    
    On Error GoTo OOPS
    
    Application.EnableCancelKey = xlDisabled
    Call CDDXCurve.MacroUploadS(DDX_PID, vbNullString, GetV2CBCurveName(CURVE_V2CB_UPLOAD))

OOPS:
    If Err.Number <> 0 Then
        Call CDDXHelper.LogError(Err.Description + GetSheetName(), Err.source, True)
    End If

    On Error GoTo 0
    Exit Sub
End Sub

Public Sub MacroUploadAllS()
    Call Application.OnTime(Now, "CPUploadAllS")
End Sub

Public Sub CPUploadAllS()
    If NoActionOnShareMode() Then Exit Sub
    If Not IsRightCurveSheet() Then Exit Sub
    
    On Error GoTo OOPS

    Application.EnableCancelKey = xlDisabled
    Call SetFocus
    Call CDDXCurve.MacroUploadAllS(BSConsts.DDX_PID)
    Call UnsetFocus

OOPS:
    If Err.Number <> 0 Then
        Call CDDXHelper.LogError(Err.Description + GetSheetName(), Err.source, True)
    End If

    On Error GoTo 0
    Exit Sub
End Sub

'Private Sub MacroDoPaste()
'    If NoActionOnShareMode() Then Exit Sub
'
'          Dim txt As String
'          Dim ary() As String
'          Dim fld() As String
'          Dim r As Long
'          Dim c As Long
'          Dim k As Long
'          Dim m As Long
'
'10        On Error GoTo errorHandler
'
'20        If ActiveCell Is Nothing Then Exit Sub
'
'30        txt = CDDXHelper.GetClipboardText(BSConsts.DDX_PID)
'40        If txt = vbNullString Then Exit Sub
'50        ary = Split(txt, vbCrLf)
'60        c = ActiveCell.column
'70        r = ActiveCell.row
'
'80        For k = LBound(ary) To UBound(ary)
'90            fld = Split(ary(k), Chr(9))
'100           For m = LBound(fld) To UBound(fld)
'110               If Not ActiveSheet.Cells(r, c + m).locked Then
'120                   ActiveSheet.Cells(r, c + m).value = fld(m)
'130               End If
'140           Next
'150           r = r + 1
'160       Next
'
'170       On Error GoTo 0
'180       Exit Sub
'errorHandler:
'          Dim errorDescription As String, errorNumber As Long
'190       errorDescription = "BSCurveMacros.MacroDoPaste(), Line:" & Str(Erl()) + " " + vbCrLf + Err.Description
'200       errorNumber = Err.Number
'          'your clean up codes here
'210       Err.Raise errorNumber, , errorDescription
'End Sub

Public Sub MacroCurveProc(ByVal sheetId As String, ByVal taskName As String, ByVal curveName As String)
    On Error GoTo OOPS
    
    Call CCurveControl.NotifyUI
    Call CDDXCurve.NotifyStartTask(DDX_PID, sheetId, taskName, curveName)
                
OOPS:
    If Err.Number <> 0 Then
        Call CDDXHelper.LogError(Err.Description, Err.source, False)
    End If

    On Error GoTo 0
    Exit Sub
End Sub

Public Sub MacroContractPlusMinus(ByVal op As Integer, Optional ByVal methodUniqueID As String)
    If NoActionOnShareMode() Then Exit Sub
    If Not IsRightCurveSheet() Then Exit Sub
    
    On Error GoTo OOPS

    Application.EnableCancelKey = xlDisabled
    Call SetFocus
    Call CDDXCurve.MacroContractPlusMinus(BSConsts.DDX_PID, op)
    Call UnsetFocus
          
OOPS:
    If Err.Number <> 0 Then
        Call CDDXHelper.LogError(Err.Description + GetSheetName(), Err.source, False)
    End If

    On Error GoTo 0
    Exit Sub
End Sub

'Public Sub MacroChangeGranularity(ByVal nm As String)
' Dim granularity As Long
' Dim rgn As range
' Dim p As Boolean
'
''    If CCurveGranularity.Manual = False Then Exit Sub
'
'    Set rgn = CCurveGranularity.GetDropdownRange(nm, 2)
'    If rgn Is Nothing Then
'        CDDXApp.StatusMessage = nm + " not found"
'        Exit Sub
'    End If
'
'    granularity = CCurveGranularity.ReadDropdownByName(nm)
'    If granularity = 0 Then Exit Sub
''
'    p = rgn.Parent.ProtectContents
'    If p Then Call CCurveControl.Unprotect(rgn.Parent)
'
'    rgn.offset(, -1).NumberFormat = CDDXCurve.GetContractDateFormat(granularity)
'
'    If p Then Call CCurveControl.Protect(rgn.Parent)
'End Sub

Public Sub MacroAcceptAll()
    If NoActionOnShareMode() Then Exit Sub
    If Not IsRightCurveSheet() Then Exit Sub
    
    On Error GoTo OOPS
    
    Application.EnableCancelKey = xlDisabled
    Call SetFocus
    Call CDDXCurve.MacroAccept(DDX_PID, vbNullString)
    Call UnsetFocus
    Call ResetFocusedCell
    
OOPS:
    If Err.Number <> 0 Then
        Call CDDXHelper.LogError(Err.Description + GetSheetName(), Err.source, False)
    End If

    On Error GoTo 0
    Exit Sub
End Sub

Public Sub MacroAccept(ByVal aGrp As String, ByVal aCurveName As String, ByVal methodID As String)
    If NoActionOnShareMode() Then Exit Sub
    If Not IsRightCurveSheet() Then Exit Sub
    
    On Error GoTo OOPS

    aCurveName = DecodeMacroParam(aCurveName)
          
    Application.EnableCancelKey = xlDisabled
    Call SetFocus
    Call CDDXCurve.MacroAccept(DDX_PID, aCurveName)
    Call UnsetFocus
    Call ResetFocusedCell
    
OOPS:
    If Err.Number <> 0 Then
        Call CDDXHelper.LogError(Err.Description + GetSheetName(), Err.source, True)
    End If
   
    On Error GoTo 0
    Exit Sub
End Sub

Public Sub V2AcceptVR()
    If NoActionOnShareMode() Then Exit Sub
    If Not IsRightCurveSheet() Then Exit Sub
    
    On Error GoTo OOPS

    Application.EnableCancelKey = xlDisabled
    Call CDDXCurve.MacroAccept(DDX_PID, GetV2CBCurveName(CURVE_V2CB_ACCEPT_VR))
    Call ResetFocusedCell
    
OOPS:
    If Err.Number <> 0 Then
        Call CDDXHelper.LogError(Err.Description + GetSheetName(), Err.source, True)
    End If

    On Error GoTo 0
    Exit Sub
End Sub

Public Function MacroActionStr(macro As String, ParamArray args() As Variant) As String
 Dim i As Long
 Dim starta As Long
 Dim enda As Long
 
    starta = LBound(args)
    enda = UBound(args)
    
    MacroActionStr = "'" + macro
    For i = starta To enda
        MacroActionStr = MacroActionStr + IIf(i = starta, " ", ",")
        If VarType(args(i)) = vbString Then
            MacroActionStr = MacroActionStr + """" + EncodeMacroParam(args(i)) + """"
        Else
            MacroActionStr = MacroActionStr + CStr(args(i))
        End If
    Next
    MacroActionStr = MacroActionStr + "'"
End Function

Public Function MacroActionStrEx(ByVal doEncode As Boolean, macro As String, ParamArray args() As Variant) As String
 Dim i As Long
 Dim starta As Long
 Dim enda As Long
 Dim s As String
    
    starta = LBound(args)
    enda = UBound(args)
    
    MacroActionStrEx = "'" + macro
    For i = starta To enda
        MacroActionStrEx = MacroActionStrEx + IIf(i = starta, " ", ",")
        If VarType(args(i)) = vbString Then
            If doEncode Then
                s = EncodeMacroParam(args(i))
            Else
                s = args(i)
            End If
            MacroActionStrEx = MacroActionStrEx + """" + s + """"
        Else
            MacroActionStrEx = MacroActionStrEx + CStr(args(i))
        End If
    Next
    MacroActionStrEx = MacroActionStrEx + "'"
End Function

Private Function GetV2CBCurveName(ByVal op As Long) As String
 Const ED As String = "Stopped."
 Dim splitrows As Long
 Dim splitcols As Long
 Dim idx As Long
 Dim cvs() As String
 
    Set CCurveDates.TargetSheet = ActiveSheet
    If CCurveDates.ParamEntity Is Nothing Then Err.Raise vbObjectError, , ED
    
    If CDDXCurve.GetSheetVersion(CCurveDates.ParamEntity.flagValues) <> CDDXCurve.GetSheetVersion(CURVE_FLG_V2) Then
        Err.Raise vbObjectError, , "Wrong sheet version."
    End If
    
    If Not CCurveControl.GetSplits(CCurveDates.TargetSheet, CCurveDates.ParamEntity, splitrows, splitcols) Then
        Err.Raise vbObjectError, , "Unable to obtain the Frozen Panes."
    End If
    
    If ActiveCell.column > splitcols Then Err.Raise vbObjectError, , ED
    
    cvs = CCurveDates.ParamEntity.curves
    idx = ActiveCell.row - splitrows - 1
    If idx < 0 Or idx > UBound(cvs) Then Err.Raise vbObjectError, , ED
    
    If op = CURVE_V2CB_UPLOAD Then
        If CCurveDates.ParamEntity.Readonly(idx) Then Err.Raise vbObjectError, , ED
 
    ElseIf op = CURVE_V2CB_ACCEPT_VR Then
        If CCurveDates.ParamEntity.Readonly(idx) Then Exit Function
        If Not CCPVRStorage.VRExists(CCurveDates.TargetSheet, cvs(idx)) Then Exit Function
        
    ElseIf op = CURVE_V2CB_DOWNLOAD Or op = CURVE_V2CB_VIEW Or op = CURVE_V2CB_DELETE Then
    
    Else
        Err.Raise vbObjectError, , ED
    End If
    
    GetV2CBCurveName = cvs(idx)
End Function

Private Sub ResetFocusedCell()
 Dim rgn As range
 
    On Error GoTo OOPS
       
    Set rgn = ActiveCell
    
    If Not rgn Is Nothing Then
        rgn.Parent.Cells(1, 1).Select
        rgn.Select
    End If
    
OOPS:
    If Err.Number <> 0 Then
        CDDXApp.StatusMessage = Err.Description
    End If
    Exit Sub
End Sub
Attribute VB_Name = "CAPICurves"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private m_upload_result As String

Private Sub GetCurves(curves() As String, isFutures As Boolean, isMultiObservations As Boolean)
 Dim v() As String
 Dim k As Long

    For k = LBound(curves) To UBound(curves)
        With CDDXLib.DefaultZEWSProxy(BSConsts.DDX_PID)
            v = .GetCurveInfo(CDDXLogin.sid, curves(k), CURVE_INFO_FLD_1_READONLY Or CURVE_INFO_FLD_2_FUTURES Or CURVE_INFO_FLD_3_MULTIOBS)
        End With
        
        If v(0) = CURVE_INFO_FLD_BOOL_TRUE Then
            Err.Raise vbObjectError + 1, "UploadFile", curves(k) + " : ReadOnly"
        End If
        
        If k = LBound(curves) Then
            isFutures = IIf(v(2) = CURVE_INFO_FLD_BOOL_TRUE, True, False)
            isMultiObservations = IIf(v(4) = CURVE_INFO_FLD_BOOL_TRUE, True, False)
        Else
            If isFutures <> IIf(v(2) = CURVE_INFO_FLD_BOOL_TRUE, True, False) Then
                Err.Raise vbObjectError + 1, "UploadFile", curves(k) + " : Different data type"
            End If
            
            If isMultiObservations <> IIf(v(4) = CURVE_INFO_FLD_BOOL_TRUE, True, False) Then
                Err.Raise vbObjectError + 1, "UploadFile", curves(k) + " : Different curve/granularity type"
            End If
        End If
    Next
End Sub

Private Function ReformCurveFile(ByVal flg As Long, curves() As String, oprDates() As Date, ByVal granularity As String, contrDates() As Date, ByVal DataFilePath As String, errStr As String) As String
 Dim tmpfil As String
 Dim num As Integer
 Dim p As Long
' Dim gvalue As Long
 
    On Error GoTo OOPS
    
    num = -1
    tmpfil = CDDXUtility.GetTempFile()
    num = FreeFile
    
    Open (tmpfil) For Output As #num
    
'count of curves/opr dates
    Print #num, CStr(UBound(curves) - LBound(curves) + 1)

'curve names
    For p = LBound(curves) To UBound(curves)
        Print #num, curves(p)
    Next

'opr dates
'    If Not CDDXHelper.IsFlag(flg, CURVE_FLG_TIMESERIES) Then
        For p = LBound(oprDates) To UBound(oprDates)
            Print #num, CStr(Int(CDbl(oprDates(p))))
        Next
'    End If
    
'
    Print #num, CStr(UBound(contrDates) - LBound(contrDates) + 1)

'contracts
'    gvalue = CCurveGranularity.GetGranularity(granularity)
    
'    If CDDXHelper.IsFlag(flg, CURVE_FLG_TIMESERIES) Then
'        Print #num, CStr(UBound(oprdates) - LBound(oprdates) + 1)
''        Print #num, CStr(gvalue)
'
'        For p = LBound(oprdates) To UBound(oprdates)
'            Print #num, CStr(CDbl(CCurveDates.ContractDate(gvalue, oprdates(p))))
'        Next
'
'    Else
'        Print #num, CStr(UBound(contrDates) - LBound(contrDates) + 1)
'        Print #num, CStr(gvalue)
        
'        If CDDXHelper.IsFlag(flg, CURVE_FLG_MULTIOBS) Then
'            For p = LBound(contrDates) To UBound(contrDates)
'                Print #num, CStr(gvalue)
'            Next
'            For p = LBound(contrDates) To UBound(contrDates)
'                Print #num, vbNullString
'            Next
'        End If
        
        For p = LBound(contrDates) To UBound(contrDates)
            Print #num, CStr(CDbl(contrDates(p)))
        Next
'    End If
    
    Call ConcatenateCurveFiles(num, DataFilePath)
    
    Close #num
    num = -1

    ReformCurveFile = tmpfil
    
OOPS:
    If Err.Number <> 0 Then
        errStr = Err.Description
    End If
    
    If num > 0 Then Close #num
    If Len(errStr) > 0 Then
        Call CDDXHelper.DeleteFile(tmpfil)
    End If
    
    On Error GoTo 0
    Exit Function
End Function

Private Sub ConcatenateCurveFiles(ByVal num As Integer, ByVal DataFilePath As String)
 Dim fn As Integer
 Dim buf As String
 
    fn = FreeFile()
    Open DataFilePath For Input As #fn
    
    Do While Not EOF(fn)
        Line Input #fn, buf
        Print #num, buf
    Loop
    
    Close #fn
End Sub

Public Function UploadFile(curves() As String, oprDates() As Date, contrDates() As Date, ByVal granularity As String, ByVal DataFilePath As String) As String()
 Dim result As ZEWSProxy.CurveResult
 Dim k As Long
 Dim ret() As String
 Dim p As Long
 Dim upr() As CurveInsertUpdateResult
 Dim buff As String
 Dim tmpfile As String
 Dim errStr As String
 Dim flg As Long
 Dim bfutures As Boolean
 Dim bmultiobs As Boolean
 Dim cvrsaccepted() As String
 
'    If Not CCurveControl.TryAccessToCurve() Then
'        Err.Raise vbObjectError, "UploadFile", CDDXHelper.LastMessage
'    End If
    
    Call GetCurves(curves, bfutures, bmultiobs)
    
    If Not bfutures Then
        flg = CURVE_FLG_TIMESERIES
        Err.Raise vbObjectError, "UploadFile", "Time Series not supported."
    End If
    
    If bmultiobs Then
        flg = flg Or CURVE_FLG_MULTIOBS
        Err.Raise vbObjectError, "UploadFile", "Multi Observations not supported."
    End If
    
    tmpfile = ReformCurveFile(flg, curves, oprDates, granularity, contrDates, DataFilePath, errStr)
    If Len(errStr) > 0 Then
        Err.Raise vbObjectError, "UploadFile", errStr
    End If
'
    Set result = CDDXLib.DefaultZEWSProxy(BSConsts.DDX_PID).UploadCurves(CDDXHelper.NewGUID(), _
                                                                        CDDXLogin.sid, _
                                                                        tmpfile, _
                                                                        flg, _
                                                                        UploadOpOptions, _
                                                                        cvrsaccepted, _
                                                                        vbNullString)
                                                                
    Call CDDXHelper.DeleteFile(tmpfile)
    
    If result.Error <> vbNullString Then
        Err.Raise vbObjectError, "UploadFile", result.Error
    End If
    
    ReDim ret(LBound(curves) To UBound(curves))
    p = LBound(curves)
    
    upr = result.UploadResult
    For k = LBound(upr) To UBound(upr)
        With upr(k)
            buff = .curveName + vbCr
            buff = buff + "Inserted " + CStr(.numRecordsInserted) + vbCr
            buff = buff + "Updated " + CStr(.numRecordsUpdated) + vbCr
            buff = buff + "Deleted " + CStr(.numRecordsDeleted) + vbCr
            buff = buff + vbCr
            If Len(Join(.errors)) <> 0 Then
                buff = buff + Join(.errors, vbCr)
            End If
            ret(p) = buff
        End With
        p = p + 1
    Next
    
    UploadFile = ret
End Function

Private Function IsRange(dtaSource As Variant) As Boolean
    IsRange = IIf(StrComp(TypeName(dtaSource), "range", vbTextCompare) = 0, True, False)
End Function

Private Function IsString(dtaSource As Variant) As Boolean
    IsString = IIf(StrComp(TypeName(dtaSource), "string", vbTextCompare) = 0, True, False)
End Function

Private Function SaveToFileByInputFile(curveNm As String, num As Integer, curveFlg As Long, ByVal dtaSourceFile As Integer) As Long
 Dim rowCount As Long
 Dim colcount As Long
 Dim row As Long
 Dim col As Long
 Dim k As Long
 Dim ox As Long
 Dim buf As String
 Dim items() As String
 Dim datapos As Long

    colcount = 0
    If CDDXHelper.IsFlag(curveFlg, CURVE_FLG_TIMESERIES) Then
        colcount = 1
    Else
        Line Input #dtaSourceFile, buf
        items = Split(buf, vbTab)
        colcount = UBound(items) - LBound(items) + 1 - 3
        If colcount > 1 Then
            curveFlg = curveFlg Or CURVE_FLG_FUTURE_RANGE
        End If
    End If
    
    datapos = Seek(dtaSourceFile)
    rowCount = 0
    Do
        If EOF(dtaSourceFile) Then Exit Do
        Line Input #dtaSourceFile, buf
        If Trim(buf) = vbNullString Then Exit Do
        rowCount = rowCount + 1
    Loop

'count of columns
    Print #num, CStr(colcount)

'curve names
    Print #num, curveNm

'opr dates
    If Not CDDXHelper.IsFlag(curveFlg, CURVE_FLG_TIMESERIES) Then
        For col = 1 To colcount
            Print #num, items(col - 1 + 3)
        Next
    End If

'count of rows
    Print #num, CStr(rowCount)

    If CDDXHelper.IsFlag(curveFlg, CURVE_FLG_MULTIOBS) Then
        If Not CDDXHelper.IsFlag(curveFlg, CURVE_FLG_TIMESERIES) Then
            Seek dtaSourceFile, datapos
            For row = 1 To rowCount
                Line Input #dtaSourceFile, buf
                items = Split(buf, vbTab)
                Print #num, CStr(CCurveGranularity.GetGranularity(items(1)))
            Next
        End If
        
        Seek dtaSourceFile, datapos
        ox = IIf(CDDXHelper.IsFlag(curveFlg, CURVE_FLG_TIMESERIES), 1, 2)
        For row = 1 To rowCount
            Line Input #dtaSourceFile, buf
            items = Split(buf, vbTab)
            Print #num, items(ox)
        Next
    End If
    
    Seek dtaSourceFile, datapos
    For row = 1 To rowCount
        Line Input #dtaSourceFile, buf
        items = Split(buf, vbTab)
        Print #num, items(0)
    Next

'data lines
    Seek dtaSourceFile, datapos
    For row = 1 To rowCount
        Line Input #dtaSourceFile, buf
        k = 0
        For col = 1 To IIf(CDDXHelper.IsFlag(curveFlg, CURVE_FLG_TIMESERIES), 2, 3)
            k = InStr(k + 1, buf, vbTab)
        Next
        Print #num, Mid(buf, k + 1)
    Next
    
    SaveToFileByInputFile = rowCount + IIf(CDDXHelper.IsFlag(curveFlg, CURVE_FLG_TIMESERIES), 0, 1)
End Function

Private Function SaveToFileByRange(curveNm As String, num As Integer, curveFlg As Long, dtaSource As range) As Long
 Dim rowCount As Long
 Dim colcount As Long
 Dim row As Long
 Dim col As Long
 Dim ox As Long
 Dim buf As String
    
    colcount = 0
    If CDDXHelper.IsFlag(curveFlg, CURVE_FLG_TIMESERIES) Then
        colcount = 1
        row = 1
    Else
        col = 4
        row = 2
        Do
            If Trim(dtaSource.Cells(1, col).text) = vbNullString Then Exit Do
            colcount = colcount + 1
            col = col + 1
        Loop
        If colcount > 1 Then
            curveFlg = curveFlg Or CURVE_FLG_FUTURE_RANGE
        End If
    End If
    
    rowCount = 0
    Do
        If Trim(dtaSource.Cells(row, 1).text) = vbNullString Then Exit Do
        rowCount = rowCount + 1
        row = row + 1
    Loop
    
'count of columns
    Print #num, CStr(colcount)

'curve names
    Print #num, curveNm

'opr dates
    If Not CDDXHelper.IsFlag(curveFlg, CURVE_FLG_TIMESERIES) Then
        For col = 1 To colcount
            Print #num, CStr(dtaSource.Cells(1, col + 3).Value2)
        Next
    End If

'count of rows
    Print #num, CStr(rowCount)

    If CDDXHelper.IsFlag(curveFlg, CURVE_FLG_MULTIOBS) Then
        If Not CDDXHelper.IsFlag(curveFlg, CURVE_FLG_TIMESERIES) Then
            For row = 1 To rowCount
                Print #num, CStr(CCurveGranularity.GetGranularity(dtaSource.Cells(row + 1, 2).Value2))
            Next
        End If
        
        ox = IIf(CDDXHelper.IsFlag(curveFlg, CURVE_FLG_TIMESERIES), 0, 1)
        For row = 1 To rowCount
            Print #num, CStr(dtaSource.Cells(row + ox, 2 + ox).Value2)
        Next
    End If

    ox = IIf(CDDXHelper.IsFlag(curveFlg, CURVE_FLG_TIMESERIES), 0, 1)
    For row = 1 To rowCount
        Print #num, CStr(dtaSource.Cells(row + ox, 1).Value2)
    Next

'data lines
    For row = 1 To rowCount
        buf = vbNullString
        For col = 1 To colcount
            buf = buf + IIf(col > 1, vbTab, vbNullString) + CStr(dtaSource.Cells(row + IIf(CDDXHelper.IsFlag(curveFlg, CURVE_FLG_TIMESERIES), 0, 1), col + IIf(CDDXHelper.IsFlag(curveFlg, CURVE_FLG_TIMESERIES), 2, 3)).Value2)
        Next
        Print #num, buf
    Next
    
    SaveToFileByRange = rowCount + IIf(CDDXHelper.IsFlag(curveFlg, CURVE_FLG_TIMESERIES), 0, 1)
End Function

Private Function ProcessSingleCurve(ByVal curveNm As String, dtaSource As Variant) As Long
 Dim result As ZEWSProxy.CurveResult
 Dim upr() As CurveInsertUpdateResult
 Dim buff As String
 Dim tmpfile As String
 Dim num As Integer
 Dim flgs As Long
 Dim bfutures As Boolean
 Dim bmultiobs As Boolean
 Dim curves() As String
 Dim rgn As range
 Dim fi As Integer
 Dim cvrsaccepted() As String
 
    ReDim curves(0 To 0)
    curves(0) = curveNm
    Call GetCurves(curves, bfutures, bmultiobs)
    flgs = IIf(bfutures, 0, CURVE_FLG_TIMESERIES) Or IIf(bmultiobs, CURVE_FLG_MULTIOBS, 0)
    Erase curves
    
    tmpfile = CDDXUtility.GetTempFile()
    num = FreeFile
    
    Open (tmpfile) For Output As #num
    
    If IsRange(dtaSource) Then
        Set rgn = dtaSource
        ProcessSingleCurve = SaveToFileByRange(curveNm, num, flgs, rgn)
    Else
        fi = dtaSource
        ProcessSingleCurve = SaveToFileByInputFile(curveNm, num, flgs, fi)
    End If
    
    Close #num
'
    On Local Error GoTo OOPS
    
    Set result = CDDXLib.DefaultZEWSProxy(BSConsts.DDX_PID).UploadCurves(CDDXHelper.NewGUID(), _
                                                                        CDDXLogin.sid, _
                                                                        tmpfile, _
                                                                        flgs, _
                                                                        UploadOpOptions, _
                                                                        cvrsaccepted, _
                                                                        vbNullString)
    
    m_upload_result = m_upload_result + IIf(m_upload_result <> vbNullString, vbCr + String(2, vbTab) + vbCr, vbNullString) + curveNm + vbTab + vbCr
    If result.Error <> vbNullString Then
        buff = result.Error + vbTab
    Else
        upr = result.UploadResult
        With upr(0)
            buff = "Inserted " + vbTab + CStr(.numRecordsInserted) + vbCr
            buff = buff + "Updated " + vbTab + CStr(.numRecordsUpdated) + vbCr
            buff = buff + "Deleted " + vbTab + CStr(.numRecordsDeleted)
        End With
    End If
    m_upload_result = m_upload_result + buff
    
OOPS:
    If Err.Number <> 0 Then
        m_upload_result = m_upload_result + IIf(m_upload_result <> vbNullString, vbCr + String(2, vbTab) + vbCr, vbNullString) + curveNm + vbTab + vbCr + Err.Description + vbTab
    End If
    
    If tmpfile <> vbNullString Then
        Call CDDXHelper.DeleteFile(tmpfile)
    End If
    
    Exit Function
End Function

Public Sub UploadFile2(dtaSource As Variant, resultOutput As Variant) 'DDX-1511
 Dim rowsprocessed As Long
 Dim rgn As range
 Dim fn As Integer
 Dim cvn As String
 Dim rlt() As String
 Dim r As Long
 
    m_upload_result = vbNullString
    
    If IsRange(dtaSource) Then
        Set rgn = dtaSource
        
        Do
            cvn = Trim(rgn.Cells(1, 1).Value2)
            If cvn = vbNullString Then Exit Do
            
            Set rgn = rgn.offset(1)
            rowsprocessed = ProcessSingleCurve(cvn, rgn)
            If rowsprocessed <= 0 Then Exit Do
            
            Set rgn = rgn.offset(rowsprocessed + 1)
        Loop
        
    Else
        fn = FreeFile()
        Open dtaSource For Input As #fn
        
        Do
            If EOF(fn) Then Exit Do
            Line Input #fn, cvn
            
            rowsprocessed = ProcessSingleCurve(cvn, fn)
            If rowsprocessed <= 0 Then Exit Do
            
            If EOF(fn) Then Exit Do
            Line Input #fn, cvn
        Loop
        
        Close #fn
    End If
    
    rlt = Split(m_upload_result, vbCr)

    If IsRange(resultOutput) Then
        For r = LBound(rlt) To UBound(rlt)
            resultOutput.offset(r).Resize(1, 2).value = Split(rlt(r), vbTab)
        Next
        
    ElseIf IsString(resultOutput) Then
        If resultOutput <> vbNullString Then
            fn = FreeFile()
            Open resultOutput For Output As #fn
            
            For r = LBound(rlt) To UBound(rlt)
                Print #fn, rlt(r)
            Next
            
            Close #fn
        End If
    End If
End Sub

Private Property Get UploadOpOptions() As Long
    UploadOpOptions = IIf(CDDXCurve.UploadNulls, CURVE_OP_INSERT_NULLS, 0) Or IIf(CDDXCurve.UploadWithProt, CURVE_OP_INSERT_PROT, 0) Or CURVE_OP_SYNC
End Property

Attribute VB_Name = "CCPFutureMulti"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Option Base 0

Private m_sheet As Worksheet
Private WithEvents m_Imager As CCurveImageText
Attribute m_Imager.VB_VarHelpID = -1
Private m_params As New CCurveParams
Private m_dataRgn As range
Private m_HeaderRgn As range
Private m_flags As Long
'
Private Const C_FIXED_ROWS As Long = 6
Private Const C_FIXED_COLS As Long = 3
'
Private Const OID_DOWNLOAD_ALL As Integer = 1
Private Const OID_UPLOAD_ALL As Integer = 2
Private Const OID_EDIT_DATE As Integer = 3
Private Const OID_CONTRACT As Integer = 4
Private Const OID_LAST_DOWNLOAD As Integer = 5
Private Const OID_LAST_UPLOAD As Integer = 6
Private Const OID_VIEW_HISTORY As Integer = 7
Private Const OID_DELETE As Integer = 8
Private Const OID_CURVE_NAME As Integer = 9
'Private Const OID_SORT As Integer = 10
Private Const OID_CONTRACT_START_PLUS As Integer = 11
Private Const OID_CONTRACT_START_MINUS As Integer = 12
Private Const OID_CONTRACT_END_PLUS As Integer = 13
Private Const OID_CONTRACT_END_MINUS As Integer = 14
'

Private Sub GetRanges()
    If m_sheet Is Nothing Then Set m_sheet = ActiveSheet
    Set m_dataRgn = CCurveControl.GetCurveRange(m_sheet)
    
    If Not m_dataRgn Is Nothing Then
        With m_dataRgn
            Set m_HeaderRgn = m_sheet.Cells(1, 1).Resize(.row - 1, .Columns.count)
        End With
    End If
End Sub

Private Sub AddStyle()
 Dim k As Long
 Dim f As Variant
 Dim b As Boolean
 Dim rgn As range
 Dim cols As Long
 Dim row As Long
 
    Call GetRanges
    
    With m_HeaderRgn
        .offset(1).Resize(C_FIXED_ROWS - 1).Interior.color = RGB(255, 255, 255)
        .Cells(2, C_FIXED_COLS + 1).Resize(, .Columns.count - C_FIXED_COLS).Interior.color = CURVE_ROW_HEADER_COLOR
        
        If .rows.count > C_FIXED_ROWS Then
            .offset(C_FIXED_ROWS).Resize(.rows.count - C_FIXED_ROWS).Interior.color = CURVE_ROW_HEADER_COLOR
            
            If .rows.count >= 7 Then
                Set rgn = .offset(C_FIXED_ROWS).Resize(2, 1)
                rgn.MergeCells = True
                rgn.VerticalAlignment = xlCenter
            End If
            
            .offset(C_FIXED_ROWS).Resize(.rows.count - C_FIXED_ROWS, C_FIXED_COLS).Interior.color = RGB(255, 255, 255)
        End If
    End With

    cols = m_HeaderRgn.Columns.count
    
    With m_HeaderRgn.offset(1).Resize(C_FIXED_ROWS - 1)
        .Borders(xlInsideHorizontal).LineStyle = xlContinuous
        .Borders(xlInsideHorizontal).Weight = xlHairline
        .Borders(xlInsideHorizontal).color = RGB(&HD9, &HD9, &HD9)
    End With
    
    With m_HeaderRgn.offset(1, C_FIXED_COLS).Resize(C_FIXED_ROWS - 1, cols - C_FIXED_COLS)
        .Borders(xlInsideVertical).LineStyle = xlContinuous
        .Borders(xlInsideVertical).Weight = IIf(k = C_FIXED_COLS Or k = cols, xlThin, xlHairline)
        .Borders(xlInsideVertical).color = RGB(&HD9, &HD9, &HD9)
        
        .Borders(xlEdgeRight).LineStyle = xlContinuous
        .Borders(xlEdgeRight).Weight = xlThin
    End With
    
    row = m_HeaderRgn.rows.count
    With m_HeaderRgn.rows(row)
        .Borders(xlEdgeBottom).LineStyle = xlContinuous
        .Borders(xlEdgeBottom).Weight = xlThin
    End With
    
    With m_dataRgn
        '.Cells(1, 1).RowHeight = 34
    
        With .rows(1)
            .HorizontalAlignment = xlCenter
            .VerticalAlignment = xlCenter
'            .WrapText = False
            .Orientation = 0
            .AddIndent = False
            .IndentLevel = 0
            .ShrinkToFit = False
            .ReadingOrder = xlContext
            .MergeCells = False
        End With

        For Each f In .Columns
            f.ColumnWidth = IIf(f.column <= C_FIXED_COLS, 18, 32)
        Next
        
        For k = C_FIXED_COLS + 1 To .Columns.count
            With .Cells(1, k).Resize(2)
                Call .Merge
                .HorizontalAlignment = xlCenter
            End With
        Next
    End With
    
    Call AddDataStyle(-1, -1)
End Sub

Private Sub AddDataStyle(ByVal dayCount As Long, ByVal op As Integer)
 Dim k As Long
 Dim f As Variant
 Dim b As Boolean
 Dim rgn As range
 Dim cols As Long
 Dim row As Long
    
    With m_dataRgn
        If op = -2 Then
            With .offset(.rows.count - 1).Resize(1)
                .Borders(xlEdgeBottom).color = RGB(210, 210, 210)
            End With
        ElseIf op = -1 Then
            .offset(, C_FIXED_COLS).Resize(, .Columns.count - C_FIXED_COLS).Borders(xlInsideVertical).Weight = xlHairline '.offset(, 1).Resize(, .Columns.count - 1)
    
            If .rows.count > 2 Then
                With .offset(2).Resize(.rows.count - 2, 3)
                    .HorizontalAlignment = xlLeft
                    .IndentLevel = 1
                End With
            End If
    
            .Borders(xlEdgeRight).LineStyle = xlContinuous
            .Borders(xlEdgeRight).Weight = xlThin
    
            .Borders(xlInsideHorizontal).LineStyle = xlContinuous
            .Borders(xlInsideHorizontal).Weight = xlThin
            .Borders(xlInsideHorizontal).color = RGB(210, 210, 210)
                    
            .Borders(xlEdgeBottom).color = RGB(210, 210, 210)
    
        ElseIf op = CURVE_UI_CONTRACTS_START_PLUS Or op = CURVE_UI_CONTRACTS_END_PLUS Then
            With .offset(IIf(op = CURVE_UI_CONTRACTS_END_PLUS, .rows.count - dayCount, 2)).Resize(dayCount)
                .Borders(xlInsideVertical).Weight = xlHairline
            End With
            
            With .Cells(IIf(op = CURVE_UI_CONTRACTS_END_PLUS, .rows.count - dayCount + 1, 3), 1).Resize(dayCount)
                .HorizontalAlignment = xlLeft
                .IndentLevel = 1
            End With
     
            .Borders(xlEdgeRight).LineStyle = xlContinuous
            .Borders(xlEdgeRight).Weight = xlThin
            
            With .offset(IIf(op = CURVE_UI_CONTRACTS_END_PLUS, .rows.count - dayCount, 2)).Resize(dayCount)
                .Borders(xlInsideHorizontal).color = RGB(210, 210, 210)
                .Borders(xlEdgeBottom).color = RGB(210, 210, 210)
            End With
            
            If CURVE_UI_CONTRACTS_START_PLUS Then
                With .Cells(3, 1).Resize(dayCount, 3)
                    .Characters.Font.size = .Cells(3, 4).Font.size
                    .HorizontalAlignment = xlLeft
                    .IndentLevel = 1
                End With
            End If
        End If

''        If .rows.count > 2 Then
''            With .offset(2, C_FIXED_COLS).Resize(.rows.count - 2, .Columns.count - C_FIXED_COLS)
''                .FormatConditions.Delete
''
''                .FormatConditions.Add Type:=xlExpression, Formula1:="=Mod(Row(),2)=0"
''                .FormatConditions(1).Interior.color = CURVE_ROW_ALTERNATING_COLOR_2
''                .FormatConditions.Add Type:=xlExpression, Formula1:="=Mod(Row(),2)<>0"
''                .FormatConditions(2).Interior.color = CURVE_ROW_ALTERNATING_COLOR_1
''
''            End With
''
''            For k = C_FIXED_COLS + 1 To .Columns.count
''                If m_params.Readonly(k - C_FIXED_COLS - 1) Then
''                 .offset(2, k - 1).Resize(.rows.count - 2, 1).Interior.color = BSConsts.CURVE_COLUMN_HEADER_COLOR2
''                End If
''            Next
''        End If
        
        With .Cells(2, 1).Resize(.rows.count - 1, C_FIXED_COLS)
            .Borders(xlInsideVertical).LineStyle = xlContinuous
            .Borders(xlInsideVertical).Weight = xlThin
            .Borders(xlInsideVertical).color = RGB(210, 210, 210)
        End With

        With .Cells(2, 1).Resize(1, C_FIXED_COLS)
            .Characters.Font.size = 9
            .HorizontalAlignment = xlCenter
        End With
        .Cells(2, 1) = "Contract Start"
        .Cells(2, 2) = "Contract Type"
        .Cells(2, 3) = "Curve Type"
    End With
    
    If m_dataRgn.rows.count > 2 Then
        With m_dataRgn.Cells(3, C_FIXED_COLS + 1).Resize(m_dataRgn.rows.count - 2, m_dataRgn.Columns.count - C_FIXED_COLS)
'            .NumberFormat = "General"
            .HorizontalAlignment = xlRight
        End With
    End If
End Sub

Private Sub InitImager()
    With m_Imager
        Set .sheet = m_sheet
    End With
End Sub

Public Function IFDelete(sheet As Worksheet, ByVal aGroupName As String, ByVal aCurveName As String)
 Dim idx As Long

    m_flags = m_flags And (Not CURVE_F_SUPPRESS_FINALIZE)
    
    Set m_sheet = sheet
    Set m_Imager.sheet = m_sheet
    
'    Set m_params = CCurveControl.GetParams(sheet)
    Set m_params = CCurveDates.ParamEntity
    Call GetRanges
    
    idx = m_params.GetCurvePosition(aCurveName)
    If idx < 0 Then Exit Function
    IFDelete = True
    
    Call sheet.Columns(idx + C_FIXED_COLS + 1).Delete(xlShiftToLeft)
    
    Call CCurveControl.DeleteCurveIcons(aCurveName, AT_HISTORY, AT_SORT, AT_DELETE, AT_DOWNLOAD, AT_UPLOAD, AT_ACCEPT, AT_NAME)
    
    'strange in Excel ?
    With m_params
        Call .RemoveCurve(idx)
        .ColumnCount = .ColumnCount - 1
    End With
    
    Call CCurveControl.SaveCurveProperties(m_sheet, m_params)
 
    If m_params.GetCurveCount() > 0 Then
        Call GetRanges
        
        If m_params.AllCurvesRD() Then
            Call CCurveControl.DeleteCurveIconsByID(m_Imager, OID_ACCEPT_ALL, OID_UPLOAD_ALL, OID_CONTRACT, OID_DELETE, OID_CONTRACT_START_PLUS, OID_CONTRACT_START_MINUS, OID_CONTRACT_END_PLUS, OID_CONTRACT_END_MINUS)
        End If
        
        Call CCurveControl.DeleteProperties(m_HeaderRgn, C_FIXED_ROWS)
    Else
        Call OnDeletion
    End If
End Function

Private Sub OnDeletion()
 Dim p As CustomProperty
 Dim shp As Shape
 
    m_sheet.Cells.Delete
    For Each shp In m_sheet.Shapes
        shp.Delete
    Next
    
    For Each p In m_sheet.CustomProperties
        p.Delete
    Next
    
'    Call RemoveMD(-1)
End Sub

Public Function IFNew(data As ZEWSProxy.ICurveResult, ud As CCurveUserData) As Boolean
 Dim isnew As Boolean
 
    m_flags = m_flags And (Not CURVE_F_SUPPRESS_FINALIZE)
    Call m_params.FromXML(data.value)
    
    Set m_sheet = CCurveControl.GetSheet(m_params, True, isnew)
    If m_sheet Is Nothing Then Exit Function
    
    If Not isnew Then
'        Call CCurveGranularity.RemoveDropdowns(m_sheet)
        Call CCurveControl.AdjustPropNDataAreas(m_params, 6)
    End If
    Call CCurveDates.AssignTargetSheet(m_sheet)
    Set CCurveDates.ParamEntity = m_params
 
    Call CCurveControl.SaveCurveProperties(m_sheet, m_params)
    Call InitImager
    
    Call CDDXCurve.SetFindCriterion(BSConsts.DDX_PID, m_sheet, ud.Criterion)
    
    Call DrawHeader
    Call DrawProperties
    m_dataRgn.Font.ColorIndex = 1
    
    Call AddStyle
    Call ReadFromFile(-1)
    Call DrawObjects
    
    Call AddMD(-1)
    
    IFNew = True
End Function

Public Function IFRefresh(data As ZEWSProxy.ICurveResult) As Boolean
 Dim oldParams As CCurveParams
 
    m_flags = m_flags And (Not CURVE_F_SUPPRESS_FINALIZE)
    Set m_sheet = ActiveSheet
    Call m_params.FromXML(data.value)
    
    Call CCurveControl.ClearAllImages(m_sheet)
    Call CCurveControl.AdjustPropNDataAreas(m_params, 6)
    
    Set oldParams = New CCurveParams
    
    With oldParams
        Call .FromXML(CCurveControl.GetCurveProperties(m_sheet))
    End With
    
    m_params.LastUploadTime = oldParams.LastUploadTime
    Call CCurveControl.SaveCurveProperties(m_sheet, m_params)
    'Set oldparams = Nothing
    
    Call GetRanges
    Call CCurveControl.ClearUnusedArea(m_dataRgn, m_HeaderRgn)
    
    Call InitImager
    
    Call DrawHeader
    Call DrawProperties
    Call AddStyle
    
    Call ReadFromFile(-1)
    Call DrawObjects
    
    Call AddMD(-1)

    IFRefresh = True
End Function

Private Sub RefreshVROnUpload(ByVal cvrIdx As Long, ByVal doSummary As Boolean, ByVal readComments As Boolean)
 Dim rgn As range
 Dim cvrnms() As String
 
    Set rgn = m_dataRgn.offset(2, 3 + IIf(cvrIdx >= 0, cvrIdx, 0)).Resize(m_dataRgn.rows.count - 2, IIf(cvrIdx >= 0, 1, m_dataRgn.Columns.count - 3))
    
    If CDDXCurve.FourEyesActive Then
        If readComments Then Call CCurveControl.RefreshCommentsAfterUploaded(rgn, False)
        
    Else
        If doSummary Then
            Call CCurveControl.VRColorValues(vbNullString, rgn, m_params, True)
        End If
        
        Call CCurveControl.EraseAccepts(m_Imager, cvrIdx)
        cvrnms = m_params.curves
        
        If cvrIdx >= 0 Then
            Call DrawObjectAccept(cvrnms(cvrIdx), cvrIdx)
        Else
            For cvrIdx = LBound(cvrnms) To UBound(cvrnms)
                Call DrawObjectAccept(cvrnms(cvrIdx), cvrIdx)
            Next
        End If
    End If
End Sub

Public Function IFUpload(data As ZEWSProxy.ICurveResult, ByVal curvePos As Long) As Boolean
 Dim k As Long
 Dim curveIdx() As Long
 Dim count As Long

    m_flags = m_flags And (Not CURVE_F_SUPPRESS_FINALIZE)
    Set m_sheet = ActiveSheet
    Call m_params.FromXML(CCurveControl.GetCurveProperties(m_sheet))
    Call GetRanges
    
    curveIdx = CCurveControl.GetUploadedItms(m_params, m_sheet, data, True, count)
    If count > 0 Then
        Call CCurveControl.SaveCurveProperties(m_sheet, m_params)
    
        For k = LBound(curveIdx) To UBound(curveIdx)
            Call DrawTimes(curveIdx(k), False)
        Next
    End If
    
    Call RefreshVROnUpload(curvePos - 1, True, True)
    Call CDDXCurve.NotifyCurveUploadResult(DDX_PID, data, m_params)
    
    IFUpload = True
End Function

Public Function IFRefreshIndividual(data As ZEWSProxy.ICurveResult, ByVal RefreshTarget As Integer) As Boolean
 Dim p As New CCurveParams
 Dim index As Long
 Dim curves() As String
 Dim downloadtimes() As String
 Dim target As String
 Dim newtime As String
 
    m_flags = m_flags And (Not CURVE_F_SUPPRESS_FINALIZE)
    Call p.FromXML(data.value)
    
    Set m_sheet = ActiveSheet
    
    With p
        curves = .curves
        target = curves(LBound(curves))
        downloadtimes = .LastDownloadTime()
        newtime = downloadtimes(LBound(downloadtimes))
    End With
    Set p = Nothing
    
    Set m_params = CCurveDates.ParamEntity
    With m_params
'        Call .FromXML(CCurveControl.GetCurveProperties(m_sheet))
            
        Call GetRanges

        curves = .curves
        downloadtimes = .LastDownloadTime
        For index = LBound(curves) To UBound(curves)
            If curves(index) = target Then
                downloadtimes(index) = newtime
                .LastDownloadTime = downloadtimes
                Exit For
            End If
        Next
        If index > UBound(curves) Then Exit Function
    End With
    
    Call InitImager
'    Call DrawObjectDownload(target, index)
    Call DrawTimes(index, True)
    Call ReadFromFile(index)
    
    Call CCurveControl.SaveCurveProperties(m_sheet, m_params)
    
    Call AddMD(index)
    
    Call GetRanges
    Call RefreshVROnUpload(index, False, False)
    
    IFRefreshIndividual = True
End Function

Private Sub DrawHeader()
 Dim wr As range
 Dim f As Variant

    Call CCurveControl.SetSplits(m_sheet, m_params.PropertyCount + C_FIXED_ROWS + 2, C_FIXED_COLS)
    Call GetRanges
    
    Call CCurveControl.InsertTitle(m_sheet)
        
' set header info
    With m_HeaderRgn
        .Cells(1, 1).RowHeight = 40
        .Cells(2, 1).Resize(.rows.count - 1).RowHeight = 18
        
        m_sheet.rows(1).Interior.color = RGB(&H0, &H52, &H93)
        
        With .rows(1)
            .Borders(xlEdgeBottom).LineStyle = xlContinuous
            .Borders(xlEdgeBottom).Weight = xlThick
            '.Borders(xlEdgeBottom).ColorIndex = 10
            .Borders(xlEdgeBottom).color = RGB(&H5E, &HB6, &HE4)
        End With
        
        With .Cells(.rows.count + 1, 1).Resize(1, .Columns.count)
            .Borders(xlEdgeTop).LineStyle = xlContinuous
            .Borders(xlEdgeTop).Weight = xlHairline
        End With
    End With
End Sub

Private Sub DrawProperties()
 Dim k As Long
 Dim j As Long
 Dim Values() As String
 Dim cvs() As String
 Dim row As Long
 Dim col As Long
 
    With m_params
        Values = .PropertyNames
        If Len(Join(Values)) = 0 Then Exit Sub
        
        m_HeaderRgn.Cells((C_FIXED_ROWS + 1), 1).Resize(UBound(Values) - LBound(Values) + 1).value = vbNullString
        
'        With m_HeaderRgn.Cells((C_FIXED_ROWS + 1), 1)
'            .value = "  Property"
'            .Characters.Font.Bold = True
'            .Characters.Font.SIZE = 9
'        End With
                
        For k = LBound(Values) To UBound(Values)
            With m_HeaderRgn.Cells(k + (C_FIXED_ROWS + 1), C_FIXED_COLS)
                .value = CCurveControl.AddApostrophe(Values(k)) + " "
                .Characters.Font.size = 8
                .HorizontalAlignment = xlRight
                .VerticalAlignment = xlCenter
            End With
        Next
        
        cvs = .curves
        For k = LBound(cvs) To UBound(cvs)
            Values = .PropertyValues(cvs(k))
            
            For j = LBound(Values) To UBound(Values)
                row = C_FIXED_ROWS + j + 1
                col = k + 1 + C_FIXED_COLS
                With m_HeaderRgn.Cells(row, col)
                    .value = CCurveControl.AddApostrophe(Values(j))
                    .Characters.Font.size = 8
                    .Characters.Font.Bold = False
                    .HorizontalAlignment = xlLeft
                    .VerticalAlignment = xlCenter
                End With
            Next
        Next
    End With
End Sub

Private Sub DrawIcon(ByVal aObjectID As Integer, ByVal aPos As Long, ByVal aCurveName As String, ByVal aAlternativeText As String)
    With m_Imager
        .AlternativeText = CCurveControl.GetAltText(aCurveName, aAlternativeText)
        Call .Draw(aObjectID, CStr(aPos))
    End With
End Sub

Private Sub DrawObjectDownload(ByVal aCurveName As String, ByVal aPos As Long)
    Call DrawIcon(OID_LAST_DOWNLOAD, aPos, aCurveName, AT_DOWNLOAD)
End Sub

Private Sub DrawObjectUpload(ByVal aCurveName As String, ByVal aPos As Long)
    Call DrawIcon(OID_LAST_UPLOAD, aPos, aCurveName, AT_UPLOAD)
End Sub

Private Sub DrawDateRange()
    Call CCurveControl.DrawChangableDateRange(m_sheet, m_params.OprStartDate, 3, Not CCurveControl.PreserveFormulas And Not m_sheet.Cells(3, 1).HasFormula)
End Sub

Private Sub DrawInterval()
' Dim dtz As Boolean
'
'    dtz = IIf(CCurveGranularity.IsGranularity(m_params.Granularities, CURVE_GRANULARITY_HOURLY) And Len(m_params.TZName) <> 0 And (m_params.IsFlag(CURVE_FLG_DST_ADJUST_START) Or m_params.IsFlag(CURVE_FLG_DST_ADJUST_END)), True, False)
'    Call CCurveControl.DrawStyledTexts(m_sheet, 3, 1, " Interval:  ", "Multi-observation", IIf(dtz, "   (" + m_params.TZName + ")", vbNullString))
End Sub

Private Sub DrawObjects()
 Dim k As Long
 Dim curves() As String

    Call DrawDateRange
    Call DrawInterval
    
    With m_Imager
        .AlternativeText = vbNullString
        
        Call .Draw(OID_DOWNLOAD_ALL, vbNullString)
        Call .Draw(OID_EDIT_DATE, vbNullString)
        If Not m_params.AllCurvesRD() Then
            Call CCurveControl.AddAcceptAll(m_Imager)
        End If
        
        If Not m_params.AllCurvesRD() Then
            Call .Draw(OID_UPLOAD_ALL, vbNullString) '
'            If Not IsDateEditable Then Call .Draw(OID_SORT, vbNullString)
            Call .Draw(OID_CONTRACT, vbNullString)
'            Call DrawContractDatesForMP
        End If
        
        If Not m_params.AllCurvesRD() Then
            Call .Draw(OID_CONTRACT_START_PLUS, vbNullString)
            Call .Draw(OID_CONTRACT_START_MINUS, vbNullString)
            Call .Draw(OID_CONTRACT_END_PLUS, vbNullString)
            Call .Draw(OID_CONTRACT_END_MINUS, vbNullString)
        End If

    End With

    curves = m_params.curves
'    groups = m_params.CurveGroups
    For k = LBound(m_params.curves) To UBound(m_params.curves)
        Call DrawIcon(OID_VIEW_HISTORY, k, curves(k), AT_HISTORY)
        
        Call DrawObjectDownload(curves(k), k)
        If Not m_params.Readonly(k) Then
            Call DrawObjectUpload(curves(k), k)
'            If Not IsDateEditable Then Call DrawIcon(OID_SORT, k, groups(k), curves(k), AT_SORT)
        End If
        
        Call DrawIcon(OID_DELETE, k, curves(k), AT_DELETE)
        
        Call DrawCurveName(k, curves(k))
        Call DrawIcon(OID_CURVE_NAME, k, curves(k), AT_NAME)
        Call DrawObjectAccept(curves(k), k)
    Next
End Sub

Private Sub DrawCurveName(ByVal aPos As Long, ByVal aCurveName As String)
    aPos = aPos + C_FIXED_COLS + 1
    
    With m_HeaderRgn.Cells(C_FIXED_ROWS, aPos)
        .Characters.Font.Bold = True
        .Characters.Font.size = 8
        '
        .HorizontalAlignment = xlLeft 'xlFill '
'        .WrapText = True
        .VerticalAlignment = xlCenter
'        .WrapText = False
        .Orientation = 0
        .AddIndent = False
        .IndentLevel = 0
        .ShrinkToFit = False
        .ReadingOrder = xlContext
        .NumberFormat = "@"
        .value = CCurveControl.AddApostrophe(aCurveName)
    End With
End Sub

Private Sub ReadFromFile(ByVal aCurveIndex As Long)
    With m_dataRgn
        If aCurveIndex < 0 Then
            Call CCurveControl.ReadFile(aCurveIndex, .Cells(2, 1).Resize(m_params.rowCount), .Cells(1, C_FIXED_COLS + 1).Resize(m_params.rowCount + 1, m_params.ColumnCount - 1), m_params)
        Else
            Call CCurveControl.ReadFile(aCurveIndex, Nothing, .Cells(1, C_FIXED_COLS + 1 + aCurveIndex).Resize(m_params.rowCount + 1, 1), m_params)
        End If
    End With
    
    Call GetRanges
    
    With m_dataRgn.Cells(1, 4).Resize(, m_dataRgn.Columns.count - 3)
        .Formula = "=" + m_sheet.Cells(3, 1).Address
        .NumberFormat = CDDXDates.SystemDateFormat
    End With
End Sub

Private Sub Class_Initialize()
    Set m_Imager = New CCurveImageText
End Sub

Private Sub Class_Terminate()
    Call ProtectSheet
    Set m_Imager = Nothing
End Sub

Private Sub ProtectSheet()
 Dim r As Long
 Dim k As Long
 Dim startp As Long
 
    If CDDXHelper.IsFlag(m_flags, CURVE_F_SUPPRESS_FINALIZE) Then Exit Sub
    
    If m_params.GetCurveCount() <= 0 Then
        Call CCurveControl.Unprotect(m_sheet)
        Exit Sub
    End If

    If m_sheet Is Nothing Then Exit Sub
    If m_sheet.ProtectContents Then Exit Sub

    m_sheet.UsedRange.Cells.Locked = True

    Call CCurveGranularity.EnableDropdowns(m_sheet, Not m_params.AllCurvesRD())
    Call LockOprDate(m_params.AllCurvesRD())
    
    If Not m_dataRgn Is Nothing Then
        With m_dataRgn
            r = .rows.count - 2
            If r > 0 Then
                .Cells(3, 1).Resize(r, 3).Locked = m_params.AllCurvesRD()
                
'                For k = LBound(m_params.curves) To UBound(m_params.curves)
'                    If Not m_params.Readonly(k) Then
'                        .Cells(3, k + C_FIXED_COLS + 1).Resize(r).Locked = False
'                    End If
'                Next
                startp = -1
                For k = LBound(m_params.curves) To UBound(m_params.curves)
                    If m_params.Readonly(k) Then
                        If startp >= 0 Then
                            .Cells(3, C_FIXED_COLS + startp + 1).Resize(r, k - startp).Locked = False
                        End If
                        startp = -1
                    Else
                        If startp = -1 Then startp = k
                        If k = UBound(m_params.curves) Then
                            .Cells(3, C_FIXED_COLS + startp + 1).Resize(r, k - startp + 1).Locked = False
                        End If
                    End If
                Next
            End If
        End With
        
        Call CCurveControl.Add4EyesStyle(m_dataRgn)
    End If
    
    Call CCurveControl.Protect(m_sheet)
End Sub

Private Sub m_Imager_OnImage(sender As Object, ByVal aTarget As Integer, ByVal aUserData As String, aPicturePath As String, ByRef aWidth As Single, ByRef aHeight As Single)
    aPicturePath = vbNullString
    aWidth = 95
    aHeight = 18
    
    Select Case aTarget
        Case OID_EDIT_DATE:
            aWidth = 140
            aPicturePath = "CurveEditSettings.png" '"CurveEditDate.png"
        Case OID_CONTRACT:
            aWidth = 140
            aPicturePath = "CurveContract.png"
        Case OID_LAST_DOWNLOAD:
            aWidth = 110
            aPicturePath = "CurveLastDownload.png"
        Case OID_DOWNLOAD_ALL:
            aWidth = 100
            aPicturePath = "CurveDownloadAll.png"
        Case OID_ACCEPT_ALL:
            aWidth = 100
            aPicturePath = "CurveAcceptAll.png"
        Case OID_ACCEPT:
            aWidth = 100
            aPicturePath = "CurveAccept.png"
        Case OID_LAST_UPLOAD:
            aWidth = 110
            aPicturePath = "CurveLastUpload.png"
        Case OID_UPLOAD_ALL:
            aWidth = 100
            aPicturePath = "CurveUploadAll.png"
        Case OID_VIEW_HISTORY:
            aWidth = 110
            aPicturePath = "CurveViewHistory.png"
        Case OID_DELETE:
            aPicturePath = "CurveDelete.png"
'        Case OID_SORT:
'            If Not IsDateEditable Then aPicturePath = IIf(aUserData = vbNullString, "filter.png", "filter.png")
        Case OID_CURVE_NAME:
            aWidth = 0 '
            aHeight = 0 '
        Case OID_CONTRACT_START_PLUS, OID_CONTRACT_END_PLUS:
            aPicturePath = "CurvePlus.png"
        Case OID_CONTRACT_START_MINUS, OID_CONTRACT_END_MINUS:
            aPicturePath = "CurveMinus.png"
'        Case OID_MIN_CONTRACT_DATE, OID_MAX_CONTRACT_DATE:
'            aWidth = 68
'            aHeight = 16
    End Select
End Sub

Private Sub m_Imager_OnImageBackColor(sender As Object, ByVal aTarget As Integer, bkColor As Long)
'    Select Case aTarget
'        Case OID_MIN_CONTRACT_DATE, OID_MAX_CONTRACT_DATE:
'            'bkColor = m_Sheet.Cells(BSConsts.CURVE_SINGLE_START_ROW, 1).Interior.color
'            bkColor = m_dataRgn.Cells(1, 1).Interior.color
'        Case Else:
            bkColor = xlNone 'RGB(255, 255, 255) 'BSConsts.CURVE_ROW_HEADER_COLOR
'    End Select
End Sub

Private Sub m_Imager_OnImagePlacement(sender As Object, ByVal aTarget As Integer, ByVal aUserData As String, aTop As Single, aLeft As Single, aWidth As Single, aHeight As Single)
 Dim col As Long
 Dim t1 As Variant
 
    t1 = 4 + 2 '23
    col = GetColIndex(aUserData) + C_FIXED_COLS
    aWidth = -1
    aHeight = -1
    
    Select Case aTarget
        Case OID_EDIT_DATE:
            With m_sheet.Cells(C_FIXED_ROWS - 1, 1)
                aTop = .top + 3
                aLeft = .left + 5
            End With
        Case OID_CONTRACT:
            With m_dataRgn.Cells(1, 1)
                .value = " "
                aTop = .top + t1 - 4
                aLeft = .left + .Width \ 2
            End With
            
        Case OID_CONTRACT_START_PLUS:
            With m_dataRgn.Cells(1, 1)
                aTop = .top + t1
                aLeft = .left + 10
            End With
        Case OID_CONTRACT_START_MINUS:
            With m_dataRgn.Cells(1, 1)
                aTop = .top + t1
                aLeft = .left + 20
            End With
        Case OID_CONTRACT_END_PLUS:
            With m_dataRgn.Cells(1, C_FIXED_COLS - 1)
                aTop = .top + t1
                aLeft = .left + .Width - 18
            End With
        Case OID_CONTRACT_END_MINUS:
            With m_dataRgn.Cells(1, C_FIXED_COLS - 1)
                aTop = .top + t1
                aLeft = .left + .Width - 28
            End With
        Case OID_VIEW_HISTORY:
            With m_sheet.Cells(2, col)
                aTop = .top + 4
                aLeft = .left + 5
            End With
        Case OID_LAST_DOWNLOAD:
            With m_sheet.Cells(3, col)
                aTop = .top + 3
                aLeft = .left + 5
            End With
        Case OID_DOWNLOAD_ALL:
            With m_sheet.Cells(C_FIXED_ROWS, 1)
                aTop = .top + 3
                aLeft = .left + 5
            End With
        Case OID_ACCEPT_ALL:
            With m_sheet.Cells(C_FIXED_ROWS, 1)
                aTop = .top + 3
                aLeft = .left + 74 + 62
            End With
        Case OID_LAST_UPLOAD:
            With m_sheet.Cells(3, col)
                aTop = .top + 3
                aLeft = .left + .Width / 2 - 14
            End With
        Case OID_ACCEPT:
            With m_sheet.Cells(5, col)
                aTop = .top + 3
                aLeft = .left + .Width / 2 + 30
            End With
        Case OID_UPLOAD_ALL:
            With m_sheet.Cells(C_FIXED_ROWS, 1)
                aTop = .top + 3
                aLeft = .left + 74
            End With
        Case OID_DELETE:
            With m_sheet.Cells(2, col)
                aTop = .top + 3
                aLeft = .left + .Width - 10 '+ 78
            End With
            aHeight = 8
            aWidth = 8
        Case OID_CURVE_NAME:
            With m_sheet.Cells(C_FIXED_ROWS, col)
                aTop = .top + 4
                aLeft = .left + 5
                'aWidth = 2 * .Width
            End With
    End Select
End Sub

Private Function GetColIndex(ByVal aUserData As String) As Long
    If aUserData <> vbNullString Then
        GetColIndex = Val(aUserData) + 1
    Else
        GetColIndex = -1
    End If
End Function

Private Sub m_Imager_OnMacro(sender As Object, ByVal aTarget As Integer, ByVal aUserData As String, aMacro As String)
 Dim idx As Integer
 Dim curves() As String
 
    curves = m_params.curves
'    groups = m_params.CurveGroups
    idx = GetColIndex(aUserData) - 1
    aMacro = vbNullString

    Select Case aTarget
        Case OID_DOWNLOAD_ALL:
            aMacro = MacroActionStr("MacroDownloadAllS")
        Case OID_ACCEPT_ALL:
            aMacro = MacroActionStr("MacroAcceptAll")
        Case OID_UPLOAD_ALL:
            aMacro = MacroActionStr("MacroUploadAllS")
        Case OID_EDIT_DATE:
            aMacro = MacroActionStr("MacroEditDateSettingsS")
        Case OID_CONTRACT:
            aMacro = MacroActionStr("MacroContractS")
            
        Case OID_CONTRACT_START_PLUS:
            aMacro = CCurveControl.OnPlusMinusAction(CURVE_UI_CONTRACTS_START_PLUS)
        Case OID_CONTRACT_START_MINUS:
            aMacro = CCurveControl.OnPlusMinusAction(CURVE_UI_CONTRACTS_START_MINUS)
        Case OID_CONTRACT_END_PLUS:
            aMacro = CCurveControl.OnPlusMinusAction(CURVE_UI_CONTRACTS_END_PLUS)
        Case OID_CONTRACT_END_MINUS:
            aMacro = CCurveControl.OnPlusMinusAction(CURVE_UI_CONTRACTS_END_MINUS)
        Case OID_VIEW_HISTORY:
            aMacro = MacroActionStr("MacroViewHistoryS", CURVE_GRP_NAME, curves(idx), CDDXHelper.NewGUID())
        Case OID_LAST_DOWNLOAD:
            aMacro = MacroActionStr("MacroDownloadS", CURVE_GRP_NAME, curves(idx), CDDXHelper.NewGUID())
        Case OID_LAST_UPLOAD:
            aMacro = MacroActionStr("MacroUploadS", CURVE_GRP_NAME, curves(idx), CDDXHelper.NewGUID())
        Case OID_ACCEPT:
            If CCurveControl.ShowAccept(idx) Then
                aMacro = MacroActionStr("MacroAccept", CURVE_GRP_NAME, curves(idx), CDDXHelper.NewGUID())
            End If
        Case OID_DELETE:
            aMacro = MacroActionStr("MacroDeleteS", CURVE_GRP_NAME, curves(idx), CDDXHelper.NewGUID())
    End Select
End Sub

Private Sub DrawTimes(ByVal aIndex As Long, ByVal aIsDownload As Boolean)
 Dim tv As Double
 
    If Not CCurveControl.GetAccessTimeToDraw(m_params, aIndex, aIsDownload, tv) Then Exit Sub
    Call CCurveControl.DrawAccessTime(m_sheet.Cells(C_FIXED_ROWS - 2, aIndex + C_FIXED_COLS + 1), tv, aIsDownload, xlLeft)
End Sub

Private Sub m_Imager_OnText(sender As Object, ByVal aTarget As Integer, ByVal aUserData As String, aText As String, ByRef aBold As Boolean, ByRef aToolTip As String, ByRef aTop As Long, ByRef aLeft As Long)
 Dim col As Long
 Dim pos As Long
 Dim maxdte As String
 Dim mindte As String
 
    If IsNumeric(aUserData) Then
        pos = CLng(aUserData)
    End If
    col = 2 * GetColIndex(aUserData)
    
    aText = vbNullString
    aBold = False
    aToolTip = vbNullString
    
    Select Case aTarget
        Case OID_DOWNLOAD_ALL:
        Case OID_ACCEPT_ALL:
        Case OID_UPLOAD_ALL:

'        Case OID_EDIT_DATE:
'            aText = "  Edit Effective Date"
'        Case OID_CONTRACT:
 
'        Case OID_VIEW_HISTORY:
            'aText = "  View History"
        Case OID_LAST_DOWNLOAD:
            'aText = "  Download" '+ du
'
            Call DrawTimes(pos, True)
        Case OID_LAST_UPLOAD:
            'aText = "  Upload" '+ du
            Call DrawTimes(pos, False)
        Case OID_ACCEPT:
'            Call DrawVR(pos)
        Case OID_CURVE_NAME:
            aToolTip = m_params.GetTooltipByPosition(pos)
            aTop = C_FIXED_ROWS
            aLeft = pos + C_FIXED_COLS + 1
            
'        Case OID_MIN_CONTRACT_DATE:
'            Call GetContractDates(mindte, maxdte)
'            aText = mindte
'        Case OID_MAX_CONTRACT_DATE:
'            Call GetContractDates(mindte, maxdte)
'            aText = maxdte
    End Select
End Sub

Private Sub AddContracts(ByVal length As Long, ByVal op As Integer)
 Dim rgn As range
 Dim k As Long
 Dim dte1 As Double
 Dim dte2 As Double
 Dim startRow As Long
 Dim gv As Long
 Dim cv As String
 
    With m_dataRgn
        startRow = .row + 1
        
        If op = CURVE_UI_CONTRACTS_START_PLUS Or op = CURVE_UI_CONTRACTS_END_PLUS Then
            Call CCurveGranularity.CreateContents(m_params.granularities)
            Call CCurveType.CreateContents(m_params.curveTypes)
            Call CCurveControl.GetDefaultGranularityNCurveType(m_params.GetFirstWritableCurve(), gv, cv)
        End If
        
        Select Case op
            Case CURVE_UI_CONTRACTS_START_PLUS:
                Set rgn = .Cells(3, 1).Resize(length, .Columns.count)
                Call rgn.rows.Insert(shift:=xlShiftDown)
                
                For k = 1 To length
                    Call CCurveGranularity.AddDropdown(m_dataRgn.Cells(k + 2, C_FIXED_COLS - 1), gv)
                    Call CCurveType.AddDropdown(m_dataRgn.Cells(k + 2, C_FIXED_COLS), cv)
                Next
                m_params.rowCount = m_params.rowCount + length
    
            Case CURVE_UI_CONTRACTS_END_PLUS:
                Set rgn = .Cells(.rows.count + 1, 1).Resize(length, .Columns.count)
                Call rgn.rows.Insert(shift:=xlShiftDown)
                Call CCurveControl.Remove4EyesStyle(rgn.offset(-length))
                
                m_params.rowCount = m_params.rowCount + length
                For k = 1 To length
                    Call CCurveGranularity.AddDropdown(m_dataRgn.Cells(m_params.rowCount + 2 - k, C_FIXED_COLS - 1), gv)
                    Call CCurveType.AddDropdown(m_dataRgn.Cells(m_params.rowCount + 2 - k, C_FIXED_COLS), cv)
                Next

            Case CURVE_UI_CONTRACTS_START_MINUS:
                If .rows.count = 2 Then Exit Sub
                Set rgn = .offset(2).Resize(1)
                Call CCurveGranularity.RemoveDropdown(rgn.Cells(2, C_FIXED_COLS - 1))
                Call CCurveGranularity.RemoveDropdown(rgn.Cells(2, C_FIXED_COLS))
                
                Call rgn.rows.Delete(shift:=xlShiftUp)
                m_params.rowCount = m_params.rowCount - 1

                Exit Sub
                
            Case CURVE_UI_CONTRACTS_END_MINUS:
                If .rows.count = 2 Then Exit Sub
                Set rgn = .offset(.rows.count - 1).Resize(1)
                Call CCurveGranularity.RemoveDropdown(rgn.Cells(1, C_FIXED_COLS - 1))
                Call CCurveGranularity.RemoveDropdown(rgn.Cells(1, C_FIXED_COLS))
                
                Call rgn.rows.Delete(shift:=xlShiftUp)
                m_params.rowCount = m_params.rowCount - 1
                Exit Sub
        End Select
    End With
End Sub

Public Function IFNewContracts(ByVal dayCount As Long, ByVal op As Integer, dispDates() As Double) As Boolean
 Dim length As Long
 
    m_flags = m_flags And (Not CURVE_F_SUPPRESS_FINALIZE)
    Set m_sheet = ActiveSheet
    Call m_params.FromXML(CCurveControl.GetCurveProperties(m_sheet))
    
    Call GetRanges
    Call InitImager
        
    If op Mod 2 = 0 And m_dataRgn.rows.count = 1 Then
        Exit Function
    End If
    
    Call AddContracts(dayCount, op)
    Call CCurveControl.SaveCurveProperties(m_sheet, m_params)
    Call GetRanges
    
    If op = 1 Or op = 3 Then
        Call AddDataStyle(dayCount, op)
    ElseIf op = 2 Then
        Call AddDataStyle(dayCount, -1)
    ElseIf op = 4 Then
        Call AddDataStyle(dayCount, -2)
    End If
End Function

Private Sub AddMD(ByVal oprDateIndex As Long)
    Call CCurveControl.ResetRangeColor(m_params, m_dataRgn, oprDateIndex)
    Call CCurveControl.PopulateInputs
    Call CalculateDates
End Sub

Private Sub DrawObjectAccept(ByVal aCurveName As String, ByVal aPos As Long)
    Call PrivateDrawVR(aPos)
    
    If m_params.Readonly(aPos) Then Exit Sub
    If Not CCPVRStorage.VRExists(m_sheet, aCurveName) Then Exit Sub
    If Not CCurveControl.ShowAccept(aPos) Then Exit Sub
    
    Call DrawIcon(OID_ACCEPT, aPos, aCurveName, AT_ACCEPT)
End Sub

Public Sub DrawVR(ByVal aIndex As Long)
    m_flags = m_flags Or CURVE_F_SUPPRESS_FINALIZE
    Call PrivateDrawVR(aIndex)
End Sub

Private Sub PrivateDrawVR(ByVal aIndex As Long)
    Call CCurveControl.DrawCurveVR(aIndex, CDbl(CCurveDates.ParamEntity.OprStartDate), C_FIXED_ROWS - 1, aIndex + 4, xlLeft)
End Sub

Public Sub IFReLayout()
    m_flags = m_flags And (Not CURVE_F_SUPPRESS_FINALIZE)
    Call GetRanges
    Set m_Imager.sheet = m_sheet
    If m_params.granularities = 0 Then
        Call m_params.FromXML(CCurveControl.GetCurveProperties(m_sheet))
    End If
    
    Call CCurveControl.ClearImagesV1(m_dataRgn)
    
    Call AddStyle
    Call DrawObjects
End Sub

Private Sub CalculateDates()
    If Application.Calculation = xlCalculationAutomatic Then Exit Sub
    
    With m_dataRgn
        Call .offset(, 2).Resize(1, .Columns.count - 2).Calculate
    End With
End Sub

Private Sub LockRange(ByVal curveIdx As Long, rdonly As Boolean)
 Dim r As Long

    With m_dataRgn
        r = .rows.count - 2
        If r <= 0 Then Exit Sub
        
        .Cells(3, C_FIXED_COLS + curveIdx + 1).Resize(r, 1).Locked = rdonly
    End With
    
    'Call CCurveControl.Add4EyesStyle(m_dataRgn)
End Sub

Private Sub LockOprDate(rdonly As Boolean)
    m_sheet.Cells(3, 1).Locked = rdonly Or Not m_params.IsFlag(CURVE_FLG_EDIT_DATES)
End Sub

Public Sub IFUpdatePermissions(permissions() As Long)
 Dim curves() As String
 Dim rdonly As Boolean
 Dim k As Long
 Dim imgl As Scripting.Dictionary
 
    m_flags = m_flags Or CURVE_F_SUPPRESS_FINALIZE
    
    Set m_sheet = ActiveSheet
    If m_Imager Is Nothing Then Set m_Imager = New CCurveImageText
    Set m_Imager.sheet = m_sheet
    Set m_params = CCurveDates.ParamEntity

    Call GetRanges
    
    curves = m_params.curves
    rdonly = Not CCurveControl.HasWriteableCurves(m_sheet, m_params, permissions)
    
    With m_Imager
        .AlternativeText = vbNullString

        If rdonly Then
            Call CCurveControl.DeleteCurveIconsByID(m_Imager, OID_ACCEPT_ALL, OID_UPLOAD_ALL, OID_CONTRACT, OID_CONTRACT_START_PLUS, OID_CONTRACT_START_MINUS, OID_CONTRACT_END_PLUS, OID_CONTRACT_END_MINUS)
        
        Else
            If .FindImage(OID_ACCEPT_ALL) Is Nothing Then Call CCurveControl.AddAcceptAll(m_Imager)
            
            If .FindImage(OID_UPLOAD_ALL) Is Nothing Then
                Call .Draw(OID_UPLOAD_ALL, vbNullString)
                Call .Draw(OID_CONTRACT, vbNullString)

                Call .Draw(OID_CONTRACT_START_PLUS, vbNullString)
                Call .Draw(OID_CONTRACT_START_MINUS, vbNullString)
                Call .Draw(OID_CONTRACT_END_PLUS, vbNullString)
                Call .Draw(OID_CONTRACT_END_MINUS, vbNullString)
            End If
        End If
    End With
    
    Call LockOprDate(rdonly)
    m_Imager.DeleteExsitingBeforeAdd = False
    
    For k = LBound(permissions) To UBound(permissions)
        If permissions(k) >= 0 Then
            rdonly = IIf(permissions(k) = 0, True, False)
            
            If rdonly Then
                If imgl Is Nothing Then
                    Set imgl = New Scripting.Dictionary
                    Call CCurveControl.DeleteCurveIconsByAlt(imgl, vbNullString)
                End If
                Call CCurveControl.DeleteCurveIconsByAlt(imgl, curves(k), AT_UPLOAD, AT_ACCEPT)
            Else
                Call DrawObjectUpload(curves(k), k)
                Call DrawObjectAccept(curves(k), k)
            End If
            Call LockRange(k, rdonly)
        End If
    Next
    
    With m_dataRgn
        If .rows.count > 1 Then
            Call CCurveControl.AddProtection(permissions, .Cells(2, C_FIXED_COLS).Resize(.rows.count - 1, .Columns.count - (C_FIXED_COLS - 1)))
        End If
    End With
End Sub
Attribute VB_Name = "CCPFutureMultiRange"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Option Base 0

Private m_sheet As Worksheet
Private WithEvents m_Imager As CCurveImageText
Attribute m_Imager.VB_VarHelpID = -1
Private m_params As New CCurveParams
'
Private m_dataRgn As range
Private m_HeaderRgn As range
Private m_flags As Long
'
Private Const C_START_ROW As Long = 6
Private Const C_START_COL As Long = 4
'
Private Const OID_DOWNLOAD_DATE As Integer = 1
Private Const OID_UPLOAD_DATE As Integer = 2
Private Const OID_EDIT_DATE As Integer = 3
Private Const OID_CONTRACT As Integer = 4
Private Const OID_LAST_DOWNLOAD As Integer = 6
Private Const OID_LAST_UPLOAD As Integer = 7
Private Const OID_CONTRACT_START_PLUS As Integer = 10
Private Const OID_CONTRACT_START_MINUS As Integer = 11
Private Const OID_CONTRACT_END_PLUS As Integer = 12
Private Const OID_CONTRACT_END_MINUS As Integer = 13
'Private Const OID_MAX_CONTRACT_DATE As Integer = 14
'Private Const OID_MIN_CONTRACT_DATE As Integer = 15
'

Private Sub InitImager()
    With m_Imager
        Set .sheet = m_sheet
    End With
End Sub

Public Function IFNew(data As ZEWSProxy.ICurveResult, ud As CCurveUserData) As Boolean
 Dim isnew As Boolean
    
    m_flags = m_flags And (Not CURVE_F_SUPPRESS_FINALIZE)
    Call m_params.FromXML(data.value)

    Set m_sheet = CCurveControl.GetSheet(m_params, True, isnew)
    If m_sheet Is Nothing Then Exit Function ' failed to find the workbook
    
    If Not isnew Then
        Call CCurveControl.AdjustPropNDataAreas(m_params, -1)
    End If
    
    Call CCurveDates.AssignTargetSheet(m_sheet)
    Set CCurveDates.ParamEntity = m_params
    
    Call CCurveControl.SaveCurveProperties(m_sheet, m_params)    ' data.value)
    
    Call InitImager

    Call DrawHeader
    Call AddStyle

    Call ReadFromFile
    Call DrawObjects
    Call AddMD(-1)
    
    IFNew = True
End Function

Private Sub RefreshVROnUpload(ByVal readComments As Boolean)
 Dim rgn As range
 Dim k As Long
 
    Set rgn = m_dataRgn.offset(2, 3).Resize(m_dataRgn.rows.count - 2, m_dataRgn.Columns.count - 3)
    
    If CDDXCurve.FourEyesActive Then
        If readComments Then Call CCurveControl.RefreshCommentsAfterUploaded(rgn, False)
        
    Else
        Call CCurveControl.VRColorValues(vbNullString, rgn, m_params, True)
        
        Call CCurveControl.EraseAccepts(m_Imager, -1)
    
        For k = 0 To m_params.ColumnCount - 1 - 1
            Call DrawObjectAccept(k)
        Next
    End If
End Sub

Public Function IFUpload(data As ZEWSProxy.ICurveResult, ByVal oprPos As Long) As Boolean
 Dim dates() As String
 Dim k As Long
 Dim j As Long
 Dim rgn As range
 Dim ary() As Long
 Dim count As Long
 
    m_flags = m_flags And (Not CURVE_F_SUPPRESS_FINALIZE)
    Set m_sheet = ActiveSheet
    Call m_params.FromXML(CCurveControl.GetCurveProperties(m_sheet))
    
    Call GetRanges
    ary = CCurveControl.GetUploadedItms(m_params, m_sheet, data, False, count)

    If count > 0 Then
        Call CCurveControl.SaveCurveProperties(m_sheet, m_params)
        
        Call InitImager
    
        With m_Imager
            Call .Draw(OID_UPLOAD_DATE, vbNullString)
        End With
    End If
    
    Call RefreshVROnUpload(True)
    Call CDDXCurve.NotifyCurveUploadResult(DDX_PID, data, m_params)
    
    IFUpload = True
End Function

Public Function IFRefresh(data As ZEWSProxy.ICurveResult) As Boolean
 Dim oldParams As CCurveParams

    m_flags = m_flags And (Not CURVE_F_SUPPRESS_FINALIZE)
    Set m_sheet = ActiveSheet

    Set oldParams = New CCurveParams
    Call oldParams.FromXML(CCurveControl.GetCurveProperties(m_sheet))

    Call m_params.FromXML(data.value)
    With m_params
        .LastUploadTime = oldParams.LastUploadTime
    End With
    Set oldParams = Nothing
  
    Call CCurveControl.ClearAllImages(m_sheet)
    Call CCurveControl.AdjustPropNDataAreas(m_params, -1)
    
    Call CCurveControl.SaveCurveProperties(m_sheet, m_params)
    Call GetRanges
    Call CCurveControl.ClearUnusedArea(m_dataRgn, m_HeaderRgn)
    
    Call CCurveGranularity.RemoveDropdowns(m_sheet)
    If Not CCurveControl.PreserveFormulas Then m_sheet.Cells.Clear
    
    Call InitImager
    
    Call DrawHeader
    Call AddStyle

    Call ReadFromFile
    Call DrawObjects
    
    Call AddMD(-1)
    
    IFRefresh = True
End Function

Private Sub AddContracts(ByVal op As Integer, ByVal length As Long)
 Dim rgn As range
 Dim k As Long
 Dim gv As Long
 Dim cv As String
 
    Select Case op
        Case CURVE_UI_CONTRACTS_NEW, CURVE_UI_CONTRACTS_START_PLUS, CURVE_UI_CONTRACTS_END_PLUS:
            Call CCurveGranularity.CreateContents(m_params.granularities)
            Call CCurveType.CreateContents(m_params.curveTypes)
            Call CCurveControl.GetDefaultGranularityNCurveType(m_params.GetFirstWritableCurve(), gv, cv)
    End Select

    With m_dataRgn
        Select Case op
            Case CURVE_UI_CONTRACTS_START_PLUS:
                Set rgn = .offset(2).Resize(length)
                Call rgn.rows.Insert(shift:=xlShiftDown)
                
                For k = 1 To length
                    Call CCurveGranularity.AddDropdown(m_dataRgn.Cells(k + 2, 2), gv)
                    Call CCurveType.AddDropdown(m_dataRgn.Cells(k + 2, 3), cv)
                Next
                m_params.rowCount = m_params.rowCount + length
                
            Case CURVE_UI_CONTRACTS_END_PLUS:
                Set rgn = .offset(.rows.count).Resize(length)
                Call rgn.rows.Insert(shift:=xlShiftDown)
                Call CCurveControl.Remove4EyesStyle(rgn.offset(-length))
                
                For k = 1 To length
                    Call CCurveGranularity.AddDropdown(m_dataRgn.Cells(m_params.rowCount + 1 + k, 2), gv)
                    Call CCurveType.AddDropdown(m_dataRgn.Cells(m_params.rowCount + 1 + k, 3), cv)
                Next
                m_params.rowCount = m_params.rowCount + length
                
            Case CURVE_UI_CONTRACTS_NEW:
                Set rgn = .offset(.rows.count).Resize(length)
                Call rgn.rows.Insert(shift:=xlShiftDown)
                
                For k = 1 To length
                    Call CCurveGranularity.AddDropdown(m_dataRgn.Cells(m_params.rowCount + 2 - k, 2), gv)
                    Call CCurveType.AddDropdown(m_dataRgn.Cells(m_params.rowCount + 2 - k, 3), cv)
                Next
                m_params.rowCount = m_params.rowCount + length
                
            Case CURVE_UI_CONTRACTS_START_MINUS:
                If .rows.count <= 2 Then Exit Sub
                
                Call CCurveGranularity.RemoveDropdown(.Cells(3, 2))
                Call CCurveGranularity.RemoveDropdown(.Cells(3, 3))
                Call .offset(2).Resize(1).rows.Delete(shift:=xlShiftUp)
                m_params.rowCount = m_params.rowCount - 1
                
            Case CURVE_UI_CONTRACTS_END_MINUS:
                If .rows.count <= 2 Then Exit Sub
                
                Call CCurveGranularity.RemoveDropdown(.Cells(.rows.count, 2))
                Call CCurveGranularity.RemoveDropdown(.Cells(.rows.count, 3))
                Call .offset(.rows.count - 1).Resize(1).rows.Delete(shift:=xlShiftUp)
                m_params.rowCount = m_params.rowCount - 1
        End Select
    End With
    
    Call CCurveControl.SaveCurveProperties(m_sheet, m_params)
End Sub

Public Function IFNewContracts(ByVal aPrior As Long, ByVal op As Integer, dispDates() As Double) As Boolean
    m_flags = m_flags And (Not CURVE_F_SUPPRESS_FINALIZE)
    Set m_sheet = ActiveSheet
    Call m_params.FromXML(CCurveControl.GetCurveProperties(m_sheet))
    Call GetRanges
    
    Call InitImager
    
    Call AddContracts(op, aPrior)
    
    Call GetRanges
    
    Call AddStyle
End Function

Private Sub DrawHeader()
 Dim wr As range
 Dim f As Variant
 Dim cn() As String

    Call CCurveControl.SetSplits(m_sheet, m_params.PropertyCount + C_START_ROW, C_START_COL - 1)
    Call GetRanges
    
    m_sheet.Cells(1, 1).Resize(4, m_params.ColumnCount + (C_START_COL - 1)).Clear
    
    m_sheet.Cells(1, 1).RowHeight = 40
    m_sheet.Cells(2, 1).Resize(5).RowHeight = 18
    
    m_sheet.rows(1).Interior.color = RGB(&H0, &H52, &H93)
 
    Call CCurveControl.InsertTitle(m_sheet)
    
    cn = m_params.curves

    With m_sheet.Cells(1, C_START_COL)
        .NumberFormat = "@"
        .VerticalAlignment = xlCenter
        .value = CCurveControl.AddApostrophe(cn(0))
        .Font.size = 18
        .Font.ColorIndex = 2
        With .Characters(1).Font
            .size = 14
            .Bold = True
        End With
    
    End With
    
    With m_sheet.rows(1)
        .Borders(xlEdgeBottom).LineStyle = xlContinuous
        .Borders(xlEdgeBottom).Weight = xlThick
        .Borders(xlEdgeBottom).color = RGB(&H5E, &HB6, &HE4)
    End With

'    With m_sheet.Cells(C_START_ROW, 1)
'        .Borders(xlEdgeRight).LineStyle = xlContinuous
'        .Borders(xlEdgeRight).Weight = xlHairline
'    End With
    With m_sheet.Cells(C_START_ROW, 1).Resize(, m_params.ColumnCount + 1)
        .Borders(xlEdgeTop).LineStyle = xlContinuous
        .Borders(xlEdgeTop).Weight = xlHairline
    End With
End Sub

Private Sub DrawDateRange()
 Dim dtz As Boolean
 
    dtz = CCurveGranularity.IsGranularity(m_params.granularities, CURVE_GRANULARITY_HOURLY) Or CCurveGranularity.IsGranularity(m_params.granularities, CURVE_GRANULARITY_MINUTELY)
    dtz = IIf(dtz And m_params.TZName <> vbNullString And (m_params.IsFlag(CURVE_FLG_DST_ADJUST_START) Or m_params.IsFlag(CURVE_FLG_DST_ADJUST_END)), True, False)
    
    Call CCurveControl.DrawStyledTexts(m_sheet, 2, 1, " Date Range:   ", CCurveDates.DisplayTime(m_params.OprStartDate, False) + "  " + "-" + "  " + CCurveDates.DisplayTime(m_params.OprEndDate, False), IIf(dtz, "   (" + m_params.TZName + ")", vbNullString))
End Sub

Private Sub DrawInterval()
' Dim dtz As Boolean
'
'    dtz = IIf(CCurveGranularity.IsGranularity(m_params.Granularities, CURVE_GRANULARITY_HOURLY) And Len(m_params.TZName) <> 0 And (m_params.IsFlag(CURVE_FLG_DST_ADJUST_START) Or m_params.IsFlag(CURVE_FLG_DST_ADJUST_END)), True, False)
'    Call CCurveControl.DrawStyledTexts(m_sheet, 3, 1, " Interval:  ", "Multi-observation", IIf(dtz, "   (" + m_params.TZName + ")", vbNullString))
End Sub

Private Sub DrawObjects()
 Dim k As Long
 
    With m_Imager
        .AlternativeText = vbNullString
        
        Call DrawDateRange
        Call DrawInterval
        
        Call .Draw(OID_LAST_DOWNLOAD, vbNullString) '
        
        Call .Draw(OID_EDIT_DATE, vbNullString) '
        
        If Not m_params.AllCurvesRD() Then
            Call CCurveControl.AddAcceptAll(m_Imager)
            
            Call .Draw(OID_LAST_UPLOAD, vbNullString) '
            
            Call .Draw(OID_CONTRACT, vbNullString)
            '
            Call .Draw(OID_CONTRACT_START_PLUS, vbNullString)
            Call .Draw(OID_CONTRACT_START_MINUS, vbNullString)
            Call .Draw(OID_CONTRACT_END_PLUS, vbNullString)
            Call .Draw(OID_CONTRACT_END_MINUS, vbNullString)
            
        End If
        
        Call .Draw(OID_DOWNLOAD_DATE, vbNullString)
        
        If Not m_params.AllCurvesRD() Then
            Call .Draw(OID_UPLOAD_DATE, vbNullString)
        End If
        
        If Not Readonly Then
            For k = 0 To m_params.ColumnCount - 1 - 1
                Call DrawObjectAccept(k)
            Next
        End If
    End With
End Sub

Private Sub DrawObjectAccept(ByVal aPos As Long)
 Dim cvrs() As String
 Dim oprs() As Double
 Dim vr As Variant
 
    Call PrivateDrawVR(aPos)
    
    cvrs = m_params.curves
    oprs = CCurveDates.EffectiveDateList
 
    vr = CCPVRStorage.GetVR(m_sheet, CURVE_VR_L_CURVE, cvrs(0), m_params.flagValues, oprs(aPos), 0, vbNullString, vbNullString)
    If IsEmpty(vr) Then Exit Sub
    
    If Not CCurveControl.ContainsStatusToAccept(vr) Then Exit Sub
    
    With m_Imager
        .AlternativeText = CCurveControl.GetAltTextDateRange(oprs(aPos))
        Call .Draw(OID_ACCEPT, CStr(aPos))
    End With
End Sub

Private Sub AddStyle()
 Dim rgn As range
 Dim k As Long
 Dim f As Variant
 Dim row As Long
    
    Call GetRanges
    
    With m_sheet.Cells(3, 1).Resize(1, m_params.ColumnCount + 2)

        .Borders(xlEdgeTop).LineStyle = xlContinuous
        .Borders(xlEdgeTop).Weight = xlHairline
        .Borders(xlEdgeTop).color = RGB(&HD9, &HD9, &HD9)
        
        .Borders(xlEdgeBottom).LineStyle = xlContinuous
        .Borders(xlEdgeBottom).Weight = xlHairline
        .Borders(xlEdgeBottom).color = RGB(&HD9, &HD9, &HD9)
    End With
    
    With m_dataRgn
        For k = C_START_COL To .Columns.count
            With .Cells(1, k).Resize(2)
                Call .Merge
                .HorizontalAlignment = xlCenter
                .VerticalAlignment = xlCenter
            End With
        Next
    End With
    
    For k = 1 To 2
        m_sheet.Cells(2, k).HorizontalAlignment = IIf(k = 1, xlCenter, xlLeft)
    Next
    
    m_sheet.Cells(2, 1).Resize(3, m_params.ColumnCount + 2).Interior.color = RGB(255, 255, 255)
    
    m_dataRgn.Resize(, C_START_COL - 1).ColumnWidth = 17

    If m_params.ColumnCount = 2 Then
        m_dataRgn.Columns(C_START_COL).ColumnWidth = 32
    Else
        m_dataRgn.Cells(1, C_START_COL).Resize(, m_dataRgn.Columns.count - (C_START_COL - 1)).ColumnWidth = 31.6
    End If
    
    With m_dataRgn.Cells(1, C_START_COL).Resize(m_dataRgn.rows.count, m_dataRgn.Columns.count - C_START_COL + 1)
        .Borders(xlInsideVertical).LineStyle = xlContinuous
        .Borders(xlInsideVertical).Weight = xlHairline
        .Borders(xlInsideVertical).color = RGB(190, 190, 190)
        
        .Borders(xlEdgeRight).Weight = xlThin
    End With
    
    If m_dataRgn.rows.count > 2 Then
        With m_dataRgn.Cells(3, 1).Resize(m_dataRgn.rows.count - 2, C_START_COL - 1)
            .Borders(xlInsideVertical).LineStyle = xlContinuous
            .Borders(xlInsideVertical).Weight = xlThin
            .Borders(xlInsideVertical).color = RGB(190, 190, 190)
            
            .Borders(xlEdgeRight).Weight = xlThin
        End With
    End If

    With m_sheet.Cells(1, m_dataRgn.Columns.count).Resize(6)
        .Borders(xlEdgeRight).LineStyle = xlContinuous
        .Borders(xlEdgeRight).Weight = xlThin
    End With
    With m_sheet.Cells(4, 1).Resize(1, m_dataRgn.Columns.count)
        .Borders(xlEdgeBottom).LineStyle = xlContinuous
        .Borders(xlEdgeBottom).Weight = xlThin
    End With
    
    Set rgn = m_sheet.Cells(C_START_ROW - 1, 1).Resize(m_params.rowCount + 1, m_params.ColumnCount + 2)
    
    With rgn
        .Borders(xlInsideHorizontal).LineStyle = xlContinuous
        .Borders(xlInsideHorizontal).Weight = xlThin
        .Borders(xlInsideHorizontal).color = RGB(210, 210, 210)
        
        .Borders(xlEdgeBottom).LineStyle = xlContinuous
        .Borders(xlEdgeBottom).Weight = xlThin
        .Borders(xlEdgeBottom).color = RGB(210, 210, 210)
    End With

    If m_params.rowCount > 1 Then
        m_sheet.Cells(C_START_ROW + 1, C_START_COL).Resize(m_params.rowCount - 1, m_params.ColumnCount).HorizontalAlignment = xlRight
    End If

    With m_sheet.Cells(C_START_ROW - 1, 1).Resize(2, rgn.Columns.count)
        .Interior.color = CURVE_ROW_HEADER_COLOR
        .Font.color = RGB(50, 50, 50)
    End With
'
'    If m_params.rowCount > 1 Then
'        Set rgn = m_dataRgn.offset(2, (C_START_COL - 1)).Resize(m_dataRgn.rows.count - 2, m_dataRgn.Columns.count - (C_START_COL - 1))
'
'        With rgn
'            .FormatConditions.Delete
'
'            .FormatConditions.Add Type:=xlExpression, Formula1:="=Mod(Row(),2)=0"
'            .FormatConditions(1).Interior.color = CURVE_ROW_ALTERNATING_COLOR_2
'            .FormatConditions.Add Type:=xlExpression, Formula1:="=Mod(Row(),2)<>0"
'            .FormatConditions(2).Interior.color = CURVE_ROW_ALTERNATING_COLOR_1
'
'        End With
'    End If
    
    With m_dataRgn
        With .Cells(2, 1).Resize(1, C_START_COL - 1)
            .Characters.Font.size = 9
            .HorizontalAlignment = xlCenter
            
            .Borders(xlEdgeTop).LineStyle = xlContinuous
            .Borders(xlEdgeTop).Weight = xlThin
            .Borders(xlEdgeTop).color = RGB(210, 210, 210)
        End With
        For k = 1 To C_START_COL - 2
            With .Cells(2, k)
                .Borders(xlEdgeRight).LineStyle = xlContinuous
                .Borders(xlEdgeRight).Weight = xlThin
                .Borders(xlEdgeRight).color = RGB(210, 210, 210)
            End With
        Next
        
        .Cells(2, 1) = "Contract Start"
        .Cells(2, 2) = "Contract Type"
        .Cells(2, 3) = "Curve Type"
    End With
    
    If m_dataRgn.rows.count > 2 Then
        With m_dataRgn.Cells(3, 1).Resize(m_dataRgn.rows.count - 2, 3)
            .Characters.Font.size = .Cells(3, 4).Font.size
            .HorizontalAlignment = xlLeft
            .IndentLevel = 1
        End With

        With m_dataRgn.Cells(3, C_START_COL).Resize(m_dataRgn.rows.count - 2, m_dataRgn.Columns.count - (C_START_COL - 1))
'            .NumberFormat = "General"
            .HorizontalAlignment = xlRight
        End With
    End If
    
    If m_HeaderRgn.Columns.count > 3 Then
        Set rgn = m_HeaderRgn.Cells(C_START_ROW - 2, C_START_COL).Resize(1, m_HeaderRgn.Columns.count - 3)
        With rgn
            .Borders(xlInsideVertical).LineStyle = xlContinuous
            .Borders(xlInsideVertical).color = RGB(210, 210, 210)
            '.Borders(xlInsideVertical).Weight = xlHairline
        End With
    End If
    'rgn.Cells(1, rgn.Columns.count).Borders(xlLeft).color = 0
End Sub

Private Sub ReadFromFile()
    With m_dataRgn
        Call CCurveControl.ReadFileRange(-1, .Cells(2, 1).Resize(.rows.count - 1), .Cells(1, C_START_COL).Resize(.rows.count, .Columns.count - (C_START_COL - 1)), m_params)
    End With
    
    Call GetRanges
End Sub

Private Sub Class_Initialize()
    Set m_Imager = New CCurveImageText
End Sub

Private Sub Class_Terminate()
    Call ProtectSheet
    Set m_Imager = Nothing
End Sub

Private Sub ProtectSheet()
 Dim r As Long
 Dim c As Long

    If CDDXHelper.IsFlag(m_flags, CURVE_F_SUPPRESS_FINALIZE) Then Exit Sub
    
    Set m_dataRgn = CCurveControl.GetCurveRange(m_sheet)

    If m_sheet Is Nothing Then Exit Sub
    If m_sheet.ProtectContents Then Exit Sub
    
    m_sheet.UsedRange.Cells.Locked = True
    Call CCurveGranularity.EnableDropdowns(m_sheet, Not m_params.AllCurvesRD())
    
    With m_dataRgn
        r = .rows.count - 2
        c = .Columns.count - (C_START_COL - 1)
    End With
    
    If Not m_params.AllCurvesRD() Then
        If r > 0 And c > 0 Then
            m_dataRgn.Cells(3, 1).Resize(r, 3).Locked = False
            m_dataRgn.Cells(3, C_START_COL).Resize(r, c).Locked = False
        End If
    End If
    
    With m_dataRgn
        If .Columns.count > (C_START_COL - 1) Then
            .offset(, (C_START_COL - 1)).Resize(1, .Columns.count - (C_START_COL - 1)).NumberFormat = CDDXDates.SystemDateFormat
        End If
    End With
    
    Call CCurveControl.Add4EyesStyle(m_dataRgn)
    
    Call CCurveControl.Protect(m_sheet)
End Sub

Private Sub m_Imager_OnImage(sender As Object, ByVal aTarget As Integer, ByVal aUserData As String, aPicturePath As String, ByRef aWidth As Single, ByRef aHeight As Single)
    aPicturePath = vbNullString

    aWidth = 95
    aHeight = 20
    
    Select Case aTarget
        Case OID_EDIT_DATE:
            aWidth = 140
            aPicturePath = "CurveEditDate.png"
        Case OID_CONTRACT:
            aWidth = 140
            If Not m_params.AllCurvesRD() Then aPicturePath = "CurveContract.png"
        Case OID_LAST_DOWNLOAD:
            aWidth = 110
            aPicturePath = "CurveLastDownload.png"
        Case OID_LAST_UPLOAD:
            aWidth = 110
            aPicturePath = "CurveLastUpload.png"
        Case OID_UPLOAD_DATE, OID_DOWNLOAD_DATE:
            aWidth = 110
            aHeight = 16
        Case OID_CONTRACT_START_PLUS, OID_CONTRACT_END_PLUS:
            aPicturePath = "CurvePlus.png"
        Case OID_CONTRACT_START_MINUS, OID_CONTRACT_END_MINUS:
            aPicturePath = "CurveMinus.png"
        Case OID_ACCEPT_ALL:
            aWidth = 100
            aPicturePath = "CurveAcceptAll.png"
        Case OID_ACCEPT:
            aWidth = 100
            aPicturePath = "CurveAccept.png"
    End Select
End Sub

Private Sub m_Imager_OnImageBackColor(sender As Object, ByVal aTarget As Integer, bkColor As Long)
    bkColor = xlNone 'RGB(255, 255, 255) 'BSConsts.CURVE_ROW_HEADER_COLOR
End Sub

Private Sub m_Imager_OnImagePlacement(sender As Object, ByVal aTarget As Integer, ByVal aUserData As String, aTop As Single, aLeft As Single, aWidth As Single, aHeight As Single)
 Dim col As Long
 Dim t1 As Variant

    t1 = 4 + 2 '23 't1 = 23
    aWidth = -1
    aHeight = -1
    Select Case aTarget
        Case OID_EDIT_DATE:
            With m_sheet.Cells(4, 1)
                aTop = .top + 3
                aLeft = .left + 6
            End With
        Case OID_CONTRACT:
            With m_dataRgn.Cells(1, 1)
                .value = " "
                aTop = .top + t1 - 4
                aLeft = .left + .Width \ 2
            End With
            
        Case OID_CONTRACT_START_PLUS:
            With m_dataRgn.Cells(1, 1)
                aTop = .top + t1
                aLeft = .left + 10
            End With
        Case OID_CONTRACT_START_MINUS:
            With m_dataRgn.Cells(1, 1)
                aTop = .top + t1
                aLeft = .left + 20
            End With
        Case OID_CONTRACT_END_PLUS:
            With m_dataRgn.Cells(1, 2)
                aTop = .top + t1
                aLeft = .left + .Width - 18
            End With
        Case OID_CONTRACT_END_MINUS:
            With m_dataRgn.Cells(1, 2)
                aTop = .top + t1
                aLeft = .left + .Width - 28
            End With

        Case OID_LAST_DOWNLOAD:
            With m_sheet.Cells(2, C_START_COL)
                aTop = .top + 3
                aLeft = .left + 6
            End With
            
'        Case OID_DOWNLOAD_DATE:
'            With m_sheet.Cells(2, C_START_COL)
'                aTop = .top + 6
'                aLeft = .left + 65
'            End With
            
        Case OID_LAST_UPLOAD:
            With m_sheet.Cells(2, C_START_COL)
                aTop = .top + 3
                aLeft = .left + 74
            End With
            
        Case OID_ACCEPT_ALL:
            With m_sheet.Cells(C_START_ROW - 2, 1)
                aTop = .top + 3
                aLeft = .left + 90
            End With
        Case OID_ACCEPT:
            With m_sheet.Cells(C_START_ROW - 2, CLng(aUserData) + C_START_COL)
                aTop = .top + 3
                aLeft = .left + 116
            End With
    End Select
End Sub

Private Sub m_Imager_OnMacro(sender As Object, ByVal aTarget As Integer, ByVal aUserData As String, aMacro As String)
    aMacro = vbNullString
    
    Select Case aTarget
        Case OID_EDIT_DATE:
            aMacro = MacroActionStr("MacroEditDateSettings")
        Case OID_CONTRACT:
            aMacro = MacroActionStr("MacroContract")
            
        Case OID_CONTRACT_START_PLUS:
            aMacro = CCurveControl.OnPlusMinusAction(CURVE_UI_CONTRACTS_START_PLUS)
        Case OID_CONTRACT_START_MINUS:
            aMacro = CCurveControl.OnPlusMinusAction(CURVE_UI_CONTRACTS_START_MINUS)
        Case OID_CONTRACT_END_PLUS:
            aMacro = CCurveControl.OnPlusMinusAction(CURVE_UI_CONTRACTS_END_PLUS)
        Case OID_CONTRACT_END_MINUS:
            aMacro = CCurveControl.OnPlusMinusAction(CURVE_UI_CONTRACTS_END_MINUS)
        Case OID_LAST_DOWNLOAD:
            aMacro = MacroActionStr("MacroDownload")
        Case OID_LAST_UPLOAD:
            aMacro = MacroActionStr("MacroUpload")
        Case OID_ACCEPT_ALL:
            aMacro = MacroActionStr("MacroAcceptAll")
        Case OID_ACCEPT:
            If CCurveControl.ShowAccept(Int(Val(aUserData))) Then
                aMacro = MacroActionStr("MacroAccept", CURVE_GRP_NAME, aUserData, CDDXHelper.NewGUID())
            End If
    End Select
End Sub

Private Sub m_Imager_OnText(sender As Object, ByVal aTarget As Integer, ByVal aUserData As String, aText As String, ByRef aBold As Boolean, ByRef aToolTip As String, ByRef aTop As Long, ByRef aLeft As Long)
    aText = vbNullString
    aBold = False
    
    Select Case aTarget
        Case OID_EDIT_DATE:
            'aText = "  Edit Effective Date"
        Case OID_CONTRACT:
            'aText = "  Edit Contract Range"
'        Case OID_LAST_DOWNLOAD:
'            times = m_params.LastDownloadTime
            'aText = "  Download"
'
'            With m_Sheet.Cells(3, 3)
'                .value = m_params.ToLocalTimeStr(times(0))
'            End With
            
        Case OID_DOWNLOAD_DATE:
            Call DrawTimes(True)
'            times = m_params.LastDownloadTime
'            aText = m_params.ToLocalTimeStr(times(0))
'
'        Case OID_LAST_UPLOAD:
'            times = m_params.LastUploadTime
            'aText = "  Upload"
            
'            With m_Sheet.Cells(4, 3)
'                .value = m_params.ToLocalTimeStr(times(0))
'            End With

        Case OID_UPLOAD_DATE:
            Call DrawTimes(False)
'            times = m_params.LastUploadTime
'            aText = m_params.ToLocalTimeStr(times(0))
        Case OID_ACCEPT_ALL:
        Case OID_ACCEPT:
'            Call DrawVR(Int(Val(aUserData)))
    End Select
End Sub

Public Sub DrawVR(ByVal aIndex As Long)
    m_flags = m_flags Or CURVE_F_SUPPRESS_FINALIZE
    Call PrivateDrawVR(aIndex)
End Sub

Private Sub PrivateDrawVR(ByVal aIndex As Long)
    Call CCurveControl.DrawCurveVR(aIndex, 0, C_START_ROW - 2, aIndex + C_START_COL, xlLeft)
End Sub

Private Sub GetRanges()
    If m_params Is Nothing Then Exit Sub
    
    If m_sheet Is Nothing Then Set m_sheet = ActiveSheet
    Set m_dataRgn = CCurveControl.GetCurveRange(m_sheet)
    
    If Not m_dataRgn Is Nothing Then
        With m_dataRgn
            Set m_HeaderRgn = m_sheet.Cells(1, 1).Resize(.row - 1, .Columns.count)
        End With
    End If
End Sub

Private Sub AddMD(ByVal oprDateIndex As Long)
    Call CCurveControl.ResetRangeColor(m_params, m_dataRgn, oprDateIndex)
    Call CCurveControl.PopulateInputs
End Sub

Private Sub DrawTimes(ByVal aIsDownload As Boolean)
Dim tv As Double
 
    If Not CCurveControl.GetAccessTimeToDraw(m_params, 0, aIsDownload, tv) Then Exit Sub
    Call CCurveControl.DrawAccessTime(m_sheet.Cells(3, C_START_COL), tv, aIsDownload, xlLeft)
End Sub

Public Sub IFReLayout()
    m_flags = m_flags And (Not CURVE_F_SUPPRESS_FINALIZE)
    Call GetRanges
    Set m_Imager.sheet = m_sheet
    If m_params.granularities = 0 Then
        Call m_params.FromXML(CCurveControl.GetCurveProperties(m_sheet))
    End If
    
    Call CCurveControl.ClearImagesV1(m_dataRgn)
    
    Call AddStyle
    Call DrawObjects
End Sub

Private Sub LockRange(ByVal curveIdx As Long, rdonly As Boolean)
 Dim r As Long
 Dim c As Long
 
    With m_dataRgn
        r = .rows.count - 2
        c = .Columns.count - (C_START_COL - 1)
        If r <= 0 Or c <= 0 Then Exit Sub
        
        .Cells(3, 1).Resize(r, 3).Locked = rdonly
        .Cells(3, C_START_COL).Resize(r, c).Locked = rdonly
    End With
    
    'Call CCurveControl.Add4EyesStyle(m_dataRgn)
End Sub

Public Sub IFUpdatePermissions(permissions() As Long)
 Dim curves() As String
 Dim rdonly As Boolean
 Dim k As Long
 Dim iid As Long
 
    m_flags = m_flags Or CURVE_F_SUPPRESS_FINALIZE

    Set m_sheet = ActiveSheet
    If m_Imager Is Nothing Then Set m_Imager = New CCurveImageText
    Set m_Imager.sheet = m_sheet
    Set m_params = CCurveDates.ParamEntity

    Call GetRanges
    
    curves = m_params.curves
    rdonly = Not CCurveControl.HasWriteableCurves(m_sheet, m_params, permissions)
    
    With m_Imager
        .AlternativeText = vbNullString

        If rdonly Then
            Call CCurveControl.DeleteCurveIconsByID(m_Imager, OID_ACCEPT_ALL, OID_LAST_UPLOAD, OID_CONTRACT, OID_CONTRACT_START_PLUS, OID_CONTRACT_START_MINUS, OID_CONTRACT_END_PLUS, OID_CONTRACT_END_MINUS)
        
        Else
            If .FindImage(OID_ACCEPT_ALL) Is Nothing Then Call CCurveControl.AddAcceptAll(m_Imager)
            
            If .FindImage(OID_LAST_UPLOAD) Is Nothing Then
                Call .Draw(OID_LAST_UPLOAD, vbNullString)
                Call .Draw(OID_CONTRACT, vbNullString)

                Call .Draw(OID_CONTRACT_START_PLUS, vbNullString)
                Call .Draw(OID_CONTRACT_START_MINUS, vbNullString)
                Call .Draw(OID_CONTRACT_END_PLUS, vbNullString)
                Call .Draw(OID_CONTRACT_END_MINUS, vbNullString)
            End If
        End If
    End With
    
    m_Imager.DeleteExsitingBeforeAdd = False
    
    For k = 0 To m_params.ColumnCount - 1 - 1
        If rdonly Then
            iid = m_Imager.GetImageID(OID_ACCEPT, k)
            If Not m_Imager.FindImage(iid) Is Nothing Then Call m_Imager.DeleteImage(iid)
        Else
            Call DrawObjectAccept(k)
        End If
    Next
    Call LockRange(0, rdonly)
    
    With m_dataRgn
        If .rows.count > 2 Then
            Call CCurveControl.AddProtection(permissions, .Cells(3, C_START_COL).Resize(.rows.count - 2, .Columns.count - (C_START_COL - 1)))
        End If
    End With
End Sub
Attribute VB_Name = "CCPFutureRange"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Option Base 0

Private m_sheet As Worksheet
Private WithEvents m_Imager As CCurveImageText
Attribute m_Imager.VB_VarHelpID = -1
Private m_params As New CCurveParams
'
Private m_dataRgn As range
Private m_HeaderRgn As range
Private m_flags As Long
'
Private Const C_START_ROW As Long = 5
Private Const C_START_COL As Long = 3
'
Private Const OID_DOWNLOAD_DATE As Integer = 1
Private Const OID_UPLOAD_DATE As Integer = 2
Private Const OID_EDIT_DATE As Integer = 3
Private Const OID_CONTRACT As Integer = 4
Private Const OID_LAST_DOWNLOAD As Integer = 6
Private Const OID_LAST_UPLOAD As Integer = 7
Private Const OID_SORT As Integer = 9
Private Const OID_CONTRACT_START_PLUS As Integer = 10
Private Const OID_CONTRACT_START_MINUS As Integer = 11
Private Const OID_CONTRACT_END_PLUS As Integer = 12
Private Const OID_CONTRACT_END_MINUS As Integer = 13
Private Const OID_MAX_CONTRACT_DATE As Integer = 14
Private Const OID_MIN_CONTRACT_DATE As Integer = 15
'

Private Sub InitImager()
    With m_Imager
        Set .sheet = m_sheet
    End With
End Sub

Private Sub PopulateCurve()
    Call InitImager

    m_sheet.Select

    Call DrawHeader
    Call ReadFromFile
End Sub

Public Function IFNew(data As ZEWSProxy.ICurveResult, ud As CCurveUserData) As Boolean
 Dim isnew As Boolean
    
    m_flags = m_flags And (Not CURVE_F_SUPPRESS_FINALIZE)
    Call m_params.FromXML(data.value)

    Set m_sheet = CCurveControl.GetSheet(m_params, True, isnew)
    If m_sheet Is Nothing Then Exit Function ' failed to find the workbook
    
    Call CCurveDates.AssignTargetSheet(m_sheet)
    Set CCurveDates.ParamEntity = m_params
    
    If Not isnew Then
        Call CCurveControl.AdjustPropNDataAreas(m_params, -1)
    End If
    
    Call CCurveControl.SaveCurveProperties(m_sheet, m_params)    ' data.value)
    
    Call PopulateCurve

    Call AddStyle
    Call DrawObjects

    Call AddMD(-1)
    
    IFNew = True
End Function

Public Function IFSort(ByVal aColumn As Long) As Boolean
 Dim sorter As CCurveSort
 
    m_flags = m_flags And (Not CURVE_F_SUPPRESS_FINALIZE)
    Set m_sheet = ActiveSheet
    Set m_params = CCurveControl.GetParams(m_sheet)
    Call GetRanges
    
    With m_dataRgn
        If .Columns.count < 3 Or .rows.count <= 2 Then Exit Function
    End With
    
    
'    Call UponSort(True)
    
    Set sorter = New CCurveSort
    With m_dataRgn
        IFSort = sorter.Execute(.offset(1).Resize(.rows.count - 1), aColumn, m_params)
    End With
    Set sorter = Nothing
    
    If Not IFSort Then Exit Function
    
'    Call UponSort(False)
    
    Call GetRanges
    Call AddStyle
End Function

Private Sub RefreshVROnUpload(ByVal readComments As Boolean)
 Dim rgn As range
 Dim k As Long
 
    Set rgn = m_dataRgn.offset(1, 2).Resize(m_dataRgn.rows.count - 1, m_dataRgn.Columns.count - 2)
    
    If CDDXCurve.FourEyesActive Then
        If readComments Then Call CCurveControl.RefreshCommentsAfterUploaded(rgn, False)
        
    Else
        Call CCurveControl.VRColorValues(vbNullString, rgn, m_params, True)
        
        Call CCurveControl.EraseAccepts(m_Imager, -1)
    
        For k = 0 To m_params.ColumnCount - 1 - 1
            Call DrawObjectAccept(k)
        Next
    End If
End Sub

Public Function IFUpload(data As ZEWSProxy.ICurveResult, ByVal curvePos As Long) As Boolean
 Dim dates() As String
 Dim k As Long
 Dim j As Long
 Dim rgn As range
 Dim ary() As Long
 Dim count As Long
 
    m_flags = m_flags And (Not CURVE_F_SUPPRESS_FINALIZE)
    Set m_sheet = ActiveSheet
    Call m_params.FromXML(CCurveControl.GetCurveProperties(m_sheet))
    
    Call GetRanges
    ary = CCurveControl.GetUploadedItms(m_params, m_sheet, data, False, count)

    If count > 0 Then
        Call CCurveControl.SaveCurveProperties(m_sheet, m_params)
        
        Call InitImager
    
        With m_Imager
            Call .Draw(OID_UPLOAD_DATE, vbNullString)
        End With
    End If
    
    Call RefreshVROnUpload(True)
    Call CDDXCurve.NotifyCurveUploadResult(DDX_PID, data, m_params)
    
    IFUpload = True
End Function

Public Function IFRefresh(data As ZEWSProxy.ICurveResult) As Boolean
 Dim oldParams As CCurveParams

    m_flags = m_flags And (Not CURVE_F_SUPPRESS_FINALIZE)
    Set m_sheet = ActiveSheet

    Set oldParams = New CCurveParams
    Call oldParams.FromXML(CCurveControl.GetCurveProperties(m_sheet))

    Call m_params.FromXML(data.value)
    With m_params
        .LastUploadTime = oldParams.LastUploadTime
    End With
    Set oldParams = Nothing
    
    Call CCurveControl.ClearAllImages(m_sheet)
    Call CCurveControl.AdjustPropNDataAreas(m_params, -1)
    
    Call CCurveControl.SaveCurveProperties(m_sheet, m_params)
    Call GetRanges
    
    '
    If Not CCurveControl.PreserveFormulas Then m_sheet.Cells.Clear
    Call PopulateCurve

    Call AddStyle
    Call DrawObjects
    
    Call AddMD(-1)
    
    IFRefresh = True
End Function

Private Sub AddNewContracts(ByVal aPrior As Integer, dispDates() As Double, ByVal length As Long)
 Dim rgn As range
 
    With m_dataRgn
        If CCurveDates.ParamEntity.IsFlag(CURVE_FLG_EDIT_DATES) Then
            Select Case aPrior
                Case 1:
                    Set rgn = .offset(1).Resize(length)
                    Call rgn.rows.Insert(shift:=xlShiftDown)
                Case 0, 3:
                    Set rgn = .offset(.rows.count).Resize(length)
                    Call rgn.rows.Insert(shift:=xlShiftDown)
                    Call CCurveControl.Remove4EyesStyle(rgn.offset(-length))
                    
                Case 2:
                    Call .offset(1).Resize(1).rows.Delete(shift:=xlShiftUp)
                    Exit Sub
                Case 4:
                    Call .offset(.rows.count - 1).Resize(1).rows.Delete(shift:=xlShiftUp)
                    Exit Sub
            End Select
        Else
            Select Case aPrior
                Case -1:
                    Set rgn = .offset(1).Resize(length)
                    Call rgn.rows.Insert(shift:=xlShiftDown)
                Case 1:
                    Set rgn = .offset(.rows.count - length).Resize(length)
                    Call rgn.rows.Insert(shift:=xlShiftDown)
                    Call CCurveControl.Remove4EyesStyle(rgn.offset(-length))
                Case 0:
                    Set rgn = .offset(1).Resize(length)
                    Call rgn.rows.Insert(shift:=xlShiftDown)
                Case -2:
                    Call .offset(1).Resize(1).rows.Delete(shift:=xlShiftUp)
                    Exit Sub
                Case 2:
                    Call .offset(.rows.count).Resize(1).rows.Delete(shift:=xlShiftUp)
                    Exit Sub
            End Select
        End If
    End With

    Set rgn = rgn.offset(-length).Resize(length)
    
    If Not m_params.IsFlag(CURVE_FLG_EDIT_DATES) Then
        Call CCurveControl.SetDateVaules(m_params.granularities, rgn.Resize(, 1), dispDates)
    End If
    Call CCurveControl.SetSOCValueFormats(-1, rgn.offset(, 2).Resize(, rgn.Columns.count - 2), m_params)
End Sub

Public Function IFNewContracts(ByVal aPrior As Long, ByVal op As Integer, dispDates() As Double) As Boolean
 Dim length As Long
 
    m_flags = m_flags And (Not CURVE_F_SUPPRESS_FINALIZE)
    Set m_sheet = ActiveSheet
    
    If CCurveDates.ParamEntity.IsFlag(CURVE_FLG_EDIT_DATES) Then
        If aPrior <= 0 Then Exit Function
        length = aPrior
        aPrior = op
    Else
         If CCurveControl.IsEmptyDates(dispDates) Then Exit Function
         length = UBound(dispDates) - LBound(dispDates) + 1
    End If

    Set m_params = CCurveControl.GetParams(m_sheet)
    'Call m_params.FromXML(CCurveControl.GetCurveProperties(m_sheet))
    Call GetRanges
    
    If CCurveDates.ParamEntity.IsFlag(CURVE_FLG_EDIT_DATES) And aPrior Mod 2 = 0 And m_dataRgn.rows.count = 1 Then
        Exit Function
    End If
    
    Call InitImager
    
    Call AddNewContracts(aPrior, dispDates, length)
    
    If CCurveDates.ParamEntity.IsFlag(CURVE_FLG_EDIT_DATES) Then
        m_params.rowCount = m_params.rowCount + length * IIf(aPrior Mod 2 = 0, -1, 1)
        Call CCurveControl.SaveCurveProperties(m_sheet, m_params)
    End If
    'Call CCurveControl.SaveCurveProperties(m_sheet, CCurveDates.ParamEntity)
    Call GetRanges
    
    Call DrawContractDatesForMP
    
    If Is410() Then
        Call AddStyle
        Call Reposition410Buttons
    Else
        Call AddStyle
    End If
End Function

Private Sub DrawHeader()
 Dim wr As range
 Dim f As Variant
 Dim cn() As String

    Call CCurveControl.SetSplits(m_sheet, m_params.PropertyCount + C_START_ROW, 2)
    Call GetRanges
    
    m_sheet.Cells(1, 1).Resize(4, m_params.ColumnCount + 2).Clear
    
    m_sheet.Cells(1, 1).RowHeight = 40
    For f = 2 To 4
        m_sheet.Cells(f, 1).RowHeight = 18
    Next
    
    m_sheet.Columns(1).ColumnWidth = 15
    m_sheet.Columns(2).ColumnWidth = 15
    
    m_sheet.rows(1).Interior.color = RGB(&H0, &H52, &H93)
    'borders
''    Set wr = m_Sheet.Cells(2, 1).Resize(3, m_params.ColumnCount + 1)

'    Call wr.BorderAround(XlLineStyle.xlLineStyleNone, XlBorderWeight.xlThin, XlColorIndex.xlColorIndexNone)
 
    Call CCurveControl.InsertTitle(m_sheet)
    
    cn = m_params.curves

    With m_sheet.Cells(1, 3)
        .NumberFormat = "@"
        '.Merge
        .VerticalAlignment = xlCenter
        ''.value = cn(0) + IIf(m_params.isPivoted, "  (Transposed)", vbNullString)
        .value = CCurveControl.AddApostrophe(cn(0))
        .Font.size = 18
        .Font.ColorIndex = 2
        With .Characters(1).Font
            .size = 14
            .Bold = True
        End With
        
''        If m_params.isPivoted Then
''            With .Characters(Len(cn(0)) + 1).Font
''                .size = 11
''                .color = RGB(&HEF, &HEF, &HEF)
''                .Bold = True
''            End With
''        End If
    End With
    
    With m_sheet.rows(1)
        .Borders(xlEdgeBottom).LineStyle = xlContinuous
        .Borders(xlEdgeBottom).Weight = xlThick
        '.Borders(xlEdgeBottom).ColorIndex = 10
        .Borders(xlEdgeBottom).color = RGB(&H5E, &HB6, &HE4)
    End With
    
'    If insertedLength > 0 Then
'        With m_sheet.Cells(1, m_params.ColumnCount - insertedLength).Resize(4)
'            .Borders(xlEdgeRight).LineStyle = xlLineStyleNone
'        End With
'    End If
    
    With m_sheet.Cells(1, m_params.ColumnCount + 1).Resize(C_START_ROW)
        .Borders(xlEdgeRight).LineStyle = xlContinuous
        .Borders(xlEdgeRight).Weight = xlThin
    End With
    
    With m_sheet.Cells(C_START_ROW, 1).Resize(1, m_params.ColumnCount + 1)
        .Borders(xlEdgeTop).LineStyle = xlContinuous
        .Borders(xlEdgeTop).Weight = xlHairline
    End With
End Sub

Private Sub DrawSort(ByVal aColumn As Long)
    With m_Imager
        .AlternativeText = "Sort - " + CStr(aColumn)
        Call .Draw(OID_SORT, CStr(aColumn))
    End With
End Sub

Private Sub DrawDateRange()
    Call CCurveControl.DrawStyledTexts(m_sheet, 2, 1, " Date Range:   ", CCurveDates.DisplayTime(m_params.OprStartDate, False) + "  " + "-" + "  " + CCurveDates.DisplayTime(m_params.OprEndDate, False))
End Sub

Private Sub DrawInterval()
 Dim dtz As Boolean
 
    dtz = CCurveGranularity.IsGranularity(m_params.granularities, CURVE_GRANULARITY_HOURLY) Or CCurveGranularity.IsGranularity(m_params.granularities, CURVE_GRANULARITY_MINUTELY)
    dtz = IIf(dtz And m_params.TZName <> vbNullString And (m_params.IsFlag(CURVE_FLG_DST_ADJUST_START) Or m_params.IsFlag(CURVE_FLG_DST_ADJUST_END)), True, False)
    Call CCurveControl.DrawStyledTexts(m_sheet, 3, 1, " Interval:  ", CCurveGranularity.GetGranularityName(m_params.granularities), IIf(dtz, "   (" + m_params.TZName + ")", vbNullString))
End Sub

Private Sub DrawContractDatesForMP()
    With m_Imager
''        If Not m_params.isPivoted Then
            Call .Draw(OID_MAX_CONTRACT_DATE, vbNullString)
            Call .Draw(OID_MIN_CONTRACT_DATE, vbNullString) '
''        Else
''            Call .DeleteImage(OID_MAX_CONTRACT_DATE)
''            Call .DeleteImage(OID_MIN_CONTRACT_DATE)  '
''        End If
    End With
End Sub

Private Sub DrawObjects()
 Dim Readonly As Boolean
 Dim k As Long
 
    Readonly = m_params.AllCurvesRD()
    
    With m_Imager
        Call .RemoveImages("Sort - ")
        
        .AlternativeText = vbNullString
        
        Call DrawDateRange
        Call DrawInterval
        '
        
        Call .Draw(OID_LAST_DOWNLOAD, vbNullString) '
        
        Call .Draw(OID_EDIT_DATE, vbNullString) '
        
        If Not Readonly Then
            Call .Draw(OID_LAST_UPLOAD, vbNullString) '
            
            Call CCurveControl.AddAcceptAll(m_Imager)
        
''            If Not m_params.isPivoted Then
                Call .Draw(OID_CONTRACT, vbNullString)
                '
                Call .Draw(OID_CONTRACT_START_PLUS, vbNullString)
                Call .Draw(OID_CONTRACT_START_MINUS, vbNullString)
                Call .Draw(OID_CONTRACT_END_PLUS, vbNullString)
                Call .Draw(OID_CONTRACT_END_MINUS, vbNullString)
''            Else
''                Call .DeleteImage(OID_CONTRACT)
''                '
''                Call .DeleteImage(OID_CONTRACT_START_PLUS)
''                Call .DeleteImage(OID_CONTRACT_START_MINUS)
''                Call .DeleteImage(OID_CONTRACT_END_PLUS)
''                Call .DeleteImage(OID_CONTRACT_END_MINUS)
''            End If
            
            Call DrawContractDatesForMP
        End If
        
        Call .Draw(OID_DOWNLOAD_DATE, vbNullString)
        
        Call .Draw(OID_UPLOAD_DATE, vbNullString) '

''        If Not Readonly And Not m_params.isPivoted Then
        
        For k = 1 To m_params.ColumnCount
            If Not Readonly Then Call DrawSort(k)
        Next
        
        If Not Readonly Then
            For k = 0 To m_params.ColumnCount - 1 - 1
                Call DrawObjectAccept(k)
            Next
        End If
    End With
End Sub

Private Sub AddStyle()
 Dim rgn As range
 Dim k As Long
 Dim f As Variant
 Dim row As Long
    
    With m_sheet.Cells(3, 1).Resize(1, m_params.ColumnCount + 1)

        .Borders(xlEdgeTop).LineStyle = xlContinuous
        .Borders(xlEdgeTop).Weight = xlHairline
        .Borders(xlEdgeTop).color = RGB(&HD9, &HD9, &HD9)
        
        .Borders(xlEdgeBottom).LineStyle = xlContinuous
        .Borders(xlEdgeBottom).Weight = xlHairline
        .Borders(xlEdgeBottom).color = RGB(&HD9, &HD9, &HD9)
    End With
    
    With m_sheet.rows(C_START_ROW)
        .RowHeight = 36
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
'        .WrapText = False
        .Orientation = 0
        .AddIndent = False
        .IndentLevel = 0
        .ShrinkToFit = False
        .ReadingOrder = xlContext
        .MergeCells = False
    End With
    
    For k = 1 To 2
        m_sheet.Cells(2, k).HorizontalAlignment = IIf(k = 1, xlCenter, xlLeft)
    Next
    
    m_sheet.Cells(2, 1).Resize(3, m_params.ColumnCount + 1).Interior.color = RGB(255, 255, 255)
    
    Set rgn = m_sheet.Cells(C_START_ROW, 1).Resize(m_params.rowCount, m_params.ColumnCount + 1)
    
    For k = 1 To 2
        rgn.Columns(k).ColumnWidth = 18 * 2
    Next
    If m_params.ColumnCount = 2 Then
        rgn.Columns(3).ColumnWidth = 48
    Else
        rgn.offset(, 2).Resize(, rgn.Columns.count - 2).ColumnWidth = 31.6
    End If
    
    With rgn.offset(, 1).Resize(, rgn.Columns.count - 1)
        .Borders(xlInsideVertical).LineStyle = xlContinuous
        .Borders(xlInsideVertical).Weight = xlHairline
        .Borders(xlInsideVertical).color = RGB(190, 190, 190)
        
        .Borders(xlEdgeRight).Weight = xlThin
    End With
    
    If rgn.rows.count > 1 Then
        With rgn.offset(1).Resize(rgn.rows.count - 1, 2)
            'Call .Merge(True)
            .HorizontalAlignment = xlCenter
        End With
    End If
    
    m_sheet.Columns(2).EntireColumn.Hidden = True
    
    With m_sheet.Cells(1, m_params.ColumnCount + 1).Resize(5)
        .Borders(xlEdgeRight).LineStyle = xlContinuous
        .Borders(xlEdgeRight).Weight = xlThin
    End With
    
    With rgn
        .Borders(xlInsideHorizontal).LineStyle = xlContinuous
        .Borders(xlInsideHorizontal).Weight = xlThin
        .Borders(xlInsideHorizontal).color = RGB(210, 210, 210)
        
        .Borders(xlEdgeBottom).LineStyle = xlContinuous
        .Borders(xlEdgeBottom).Weight = xlThin
        .Borders(xlEdgeBottom).color = RGB(210, 210, 210)
    End With

'    For f = 2 To m_params.ColumnCount + 1
'        m_sheet.Cells(C_START_ROW, f).HorizontalAlignment = xlCenter
'    Next
    m_sheet.Cells(C_START_ROW, 3).Resize(1, m_params.ColumnCount - 1).HorizontalAlignment = xlCenter
    
    If m_params.rowCount > 1 Then
'        For Each f In m_sheet.Cells(C_START_ROW + 1, 3).Resize(m_params.rowCount - 1, m_params.ColumnCount - 1).Columns
'            f.HorizontalAlignment = xlRight
'        Next
        m_sheet.Cells(C_START_ROW + 1, 3).Resize(m_params.rowCount - 1, m_params.ColumnCount - 1).HorizontalAlignment = xlRight
    End If

    Set rgn = CCurveControl.GetCurveRange(m_sheet)
    
    With m_sheet.Cells(C_START_ROW, 1).Resize(1, rgn.Columns.count)
        .Interior.color = CURVE_ROW_HEADER_COLOR
        .Font.color = RGB(50, 50, 50)
    End With
 
    If m_params.rowCount > 1 Then
        rgn.offset(1).Resize(rgn.rows.count - 1, 1).Interior.color = CURVE_COLUMN_HEADER_COLOR
    End If
    
    Set rgn = m_HeaderRgn.Cells(C_START_ROW - 1, 3).Resize(1, m_HeaderRgn.Columns.count - 2)
    With rgn
        .Borders(xlInsideVertical).LineStyle = xlContinuous
        .Borders(xlInsideVertical).color = RGB(210, 210, 210)
        '.Borders(xlInsideVertical).Weight = xlHairline
    End With
    
''    If rgn.rows.count > 1 Then
''        With rgn.offset(1, 1).Resize(rgn.rows.count - 1, rgn.Columns.count - 1)
''            .FormatConditions.Delete
''
''            .FormatConditions.Add Type:=xlExpression, Formula1:="=Mod(Row(),2)=0"
''            .FormatConditions(1).Interior.color = CURVE_ROW_ALTERNATING_COLOR_2
''            .FormatConditions.Add Type:=xlExpression, Formula1:="=Mod(Row(),2)<>0"
''            .FormatConditions(2).Interior.color = CURVE_ROW_ALTERNATING_COLOR_1
''
''        End With
''    End If
End Sub

Private Sub ReadFromFile()
    With m_dataRgn
        Call CCurveControl.ReadFileRange(-1, .Resize(, 1), .offset(, 2).Resize(, .Columns.count - 2), m_params)
    End With
    
    Call GetRanges
End Sub

Private Sub Class_Initialize()
    Set m_Imager = New CCurveImageText
End Sub

Private Sub Class_Terminate()
    Call ProtectSheet
    Set m_Imager = Nothing
End Sub

Private Sub SetDataRgnFormat()
 Dim spltrows As Long
 Dim spltcols As Long
 Dim rgn As range
 
    On Local Error Resume Next
    
    Call CCurveControl.GetSplits(m_sheet, m_params, spltrows, spltcols)
    
    With m_dataRgn
        If .rows.count <= 1 Or spltcols >= .Columns.count Then Exit Sub
        
        Set rgn = .offset(1, spltcols).Resize(.rows.count - 1, .Columns.count - spltcols)
'        rgn.NumberFormat = "General"
        rgn.HorizontalAlignment = xlRight
    End With
End Sub

Private Sub SetDateFormat()
' Dim fmt As String
'
    On Local Error Resume Next
    
    If m_params Is Nothing Then Exit Sub
'    fmt = CDDXCurve.GetContractDateFormat(m_params.granularities)
    
    With m_dataRgn
        If .rows.count > 1 And .Columns.count > 2 Then
        
''            If Not m_params.isPivoted Then
                .offset(, 2).Resize(1, .Columns.count - 2).NumberFormat = CDDXDates.SystemDateFormat
                .offset(1).Resize(.rows.count - 1, 1).NumberFormat = CDDXCurve.GetContractDateFormat(m_params.granularities)
''            Else
''                .offset(, 2).Resize(1, .Columns.count - 2).NumberFormat = fmt
''                .offset(1).Resize(.rows.count - 1, 1).NumberFormat = CDDXDates.SystemDateFormat
''            End If
        End If
    End With
End Sub

Private Sub UnprotectContractDates(ByVal rows As Long)
    If m_dataRgn Is Nothing Then Exit Sub
    
    If m_params.IsFlag(CURVE_FLG_EDIT_DATES) Then
        m_dataRgn.offset(1).Resize(rows, 2).Locked = False
    End If
End Sub

Private Sub ProtectSheet()
 Dim rgn As range
 Dim r As Long
 Dim c As Long

    If CDDXHelper.IsFlag(m_flags, CURVE_F_SUPPRESS_FINALIZE) Then Exit Sub
    
    Set rgn = CCurveControl.GetCurveRange(m_sheet)
    If rgn Is Nothing Then Exit Sub

    If m_sheet Is Nothing Then Exit Sub
    If m_sheet.ProtectContents Then Exit Sub
    
    'Call cDDXCurve.Unprotect(BSConsts.DDX_PID, m_sheet)
    
    m_sheet.UsedRange.Cells.Locked = True
    
    With rgn
        r = .rows.count - 1
        c = .Columns.count - 2
    End With
    
    If Not m_params.AllCurvesRD() Then
        If r > 0 And c > 0 Then
            Call CUploadSheetCreator.setRangeLocked(rgn.offset(1, 2).Resize(r, c), False)
            'rgn.offSet(1, 2).Resize(r, c).locked = False
            Call UnprotectContractDates(r)
        End If
    End If
    
    Call SetDateFormat
    Call SetDataRgnFormat
    Call CCurveControl.Add4EyesStyle(m_dataRgn)
    
    Call CCurveControl.Protect(m_sheet)
End Sub

Private Sub m_Imager_OnImage(sender As Object, ByVal aTarget As Integer, ByVal aUserData As String, aPicturePath As String, ByRef aWidth As Single, ByRef aHeight As Single)
    aPicturePath = vbNullString

    aWidth = 95
    aHeight = 20
    
    Select Case aTarget
        Case OID_EDIT_DATE:
            aWidth = 140
            aPicturePath = "CurveEditDate.png"
        Case OID_CONTRACT:
            aWidth = 140
            If Not m_params.AllCurvesRD() Then aPicturePath = "CurveContract.png"
        Case OID_LAST_DOWNLOAD:
            aWidth = 110
            aPicturePath = "CurveLastDownload.png"
        Case OID_LAST_UPLOAD:
            aWidth = 110
            aPicturePath = "CurveLastUpload.png"
        Case OID_SORT:
            aPicturePath = IIf(CLng(aUserData) = 1, "Filter.png", "Filter.png") '"Sort.png"
        Case OID_UPLOAD_DATE, OID_DOWNLOAD_DATE:
            aWidth = 110
            aHeight = 16
        Case OID_CONTRACT_START_PLUS, OID_CONTRACT_END_PLUS:
            aPicturePath = "CurvePlus.png"
        Case OID_CONTRACT_START_MINUS, OID_CONTRACT_END_MINUS:
            aPicturePath = "CurveMinus.png"
        Case OID_MIN_CONTRACT_DATE, OID_MAX_CONTRACT_DATE:
            aWidth = 68
            aHeight = 16
        Case OID_ACCEPT_ALL:
            aWidth = 100
            aPicturePath = "CurveAcceptAll.png"
        Case OID_ACCEPT:
            aWidth = 100
            aPicturePath = "CurveAccept.png"
    End Select
End Sub

Private Sub m_Imager_OnImageBackColor(sender As Object, ByVal aTarget As Integer, bkColor As Long)
    Select Case aTarget
        Case OID_MIN_CONTRACT_DATE, OID_MAX_CONTRACT_DATE:
            bkColor = xlNone 'm_sheet.Cells(C_START_ROW, 1).Interior.color
        Case Else:
            bkColor = RGB(255, 255, 255) 'BSConsts.CURVE_ROW_HEADER_COLOR
    End Select
End Sub

Private Sub m_Imager_OnImagePlacement(sender As Object, ByVal aTarget As Integer, ByVal aUserData As String, aTop As Single, aLeft As Single, aWidth As Single, aHeight As Single)
 Dim col As Long
 Dim t1 As Variant
 
    t1 = 23
    aWidth = -1
    aHeight = -1
    Select Case aTarget
        Case OID_EDIT_DATE:
            With m_sheet.Cells(4, 1)
                aTop = .top + 3
                aLeft = .left + 6
            End With
        Case OID_CONTRACT:
            With m_sheet.Cells(C_START_ROW, 1)
                .value = " "
                aTop = .top + 6
                aLeft = .left + 6
            End With
            
        Case OID_CONTRACT_START_PLUS:
            With m_sheet.Cells(C_START_ROW, 1)
                aTop = .top + t1
                aLeft = .left + 6
            End With
        Case OID_CONTRACT_START_MINUS:
            With m_sheet.Cells(C_START_ROW, 1)
                aTop = .top + t1
                aLeft = .left + 16
            End With
        Case OID_CONTRACT_END_PLUS:
            With m_sheet.Cells(C_START_ROW, 1)
                aTop = .top + t1
                aLeft = .left + .Width / 2 - 10
            End With
        Case OID_CONTRACT_END_MINUS:
            With m_sheet.Cells(C_START_ROW, 1)
                aTop = .top + t1
                aLeft = .left + .Width / 2 - 20
            End With
            
        Case OID_MIN_CONTRACT_DATE:
            With m_sheet.Cells(C_START_ROW, 1)
                aTop = .top + t1 - 1
                aLeft = .left + 26
            End With
        Case OID_MAX_CONTRACT_DATE:
            With m_sheet.Cells(C_START_ROW, 2)
                aTop = .top + t1 - 1
                aLeft = .left + 20
            End With
            
        Case OID_SORT:
            aWidth = 12
            aHeight = 12
            col = CLng(aUserData) + 1
            With m_sheet.Cells(C_START_ROW, col)
                aTop = .top + 11
                aLeft = .left + .Width - IIf(col = 1, 15, 13)
            End With
        Case OID_LAST_DOWNLOAD:
            With m_sheet.Cells(2, 3)
                aTop = .top + 3
                aLeft = .left + 6
            End With
        Case OID_DOWNLOAD_DATE:
            With m_sheet.Cells(2, 3)
                aTop = .top + 6
                aLeft = .left + 65
            End With
            
        Case OID_LAST_UPLOAD:
            With m_sheet.Cells(2, 3)
                aTop = .top + 3
                aLeft = .left + 74
            End With
            
        Case OID_UPLOAD_DATE:
            With m_sheet.Cells(3, 3)
                aTop = .top + 6
                aLeft = .left + 65
            End With
        Case OID_ACCEPT_ALL:
            With m_sheet.Cells(C_START_ROW - 1, 1)
                aTop = .top + 3
                aLeft = .left + 90
            End With
        Case OID_ACCEPT:
            With m_sheet.Cells(C_START_ROW - 1, CLng(aUserData) + 3)
                aTop = .top + 3
                aLeft = .left + 116
            End With
    End Select
End Sub

Private Sub m_Imager_OnMacro(sender As Object, ByVal aTarget As Integer, ByVal aUserData As String, aMacro As String)
 Dim Readonly As Boolean
 Dim col As Long
 Dim oprs() As Double
 Dim curvs() As String
 
    aMacro = vbNullString
    Readonly = m_params.AllCurvesRD()
    
    Select Case aTarget
        Case OID_EDIT_DATE:
            aMacro = MacroActionStr("MacroEditDateSettings")
        Case OID_CONTRACT:
'            'If Not Readonly And Not m_params.isPivoted Then aMacro = "'MacroContract'"
            If Not Readonly Then aMacro = MacroActionStr("MacroContract")
        Case OID_CONTRACT_START_PLUS:
            If Not Readonly Then aMacro = CCurveControl.OnPlusMinusAction(CURVE_UI_CONTRACTS_START_PLUS)
        Case OID_CONTRACT_START_MINUS:
            If Not Readonly Then aMacro = CCurveControl.OnPlusMinusAction(CURVE_UI_CONTRACTS_START_MINUS)
        Case OID_CONTRACT_END_PLUS:
            If Not Readonly Then aMacro = CCurveControl.OnPlusMinusAction(CURVE_UI_CONTRACTS_END_PLUS)
        Case OID_CONTRACT_END_MINUS:
            If Not Readonly Then aMacro = CCurveControl.OnPlusMinusAction(CURVE_UI_CONTRACTS_END_MINUS)
        Case OID_LAST_DOWNLOAD:
            aMacro = MacroActionStr("MacroDownload")
        Case OID_LAST_UPLOAD:
            If Not Readonly Then aMacro = MacroActionStr("MacroUpload")
        Case OID_SORT:
            col = Val(aUserData)
            If col <> 1 Then col = col + 1
            If Not Readonly Then aMacro = MacroActionStr("MacroSort", col)
        Case OID_ACCEPT_ALL:
            aMacro = MacroActionStr("MacroAcceptAll")
        Case OID_ACCEPT:
            If CCurveControl.ShowAccept(Int(Val(aUserData))) Then
                aMacro = MacroActionStr("MacroAccept", CURVE_GRP_NAME, aUserData, CDDXHelper.NewGUID())
            End If
    End Select
End Sub

Private Sub GetContractDates(minDate As String, maxDate As String)
    If m_params.IsFlag(CURVE_FLG_EDIT_DATES) Then
        minDate = "--- -- ----"
        maxDate = "--- -- ----"
    Else
        minDate = vbNullString
        maxDate = vbNullString
        With m_dataRgn
            If .rows.count <= 1 Then Exit Sub
            minDate = .Cells(2, 1).text
            maxDate = .Cells(.rows.count, 1).text
        End With
    End If
End Sub

Private Sub m_Imager_OnText(sender As Object, ByVal aTarget As Integer, ByVal aUserData As String, aText As String, ByRef aBold As Boolean, ByRef aToolTip As String, ByRef aTop As Long, ByRef aLeft As Long)
 Dim times() As String
 Dim maxdte As String
 Dim mindte As String
 
    aText = vbNullString
    aBold = False
    
    Select Case aTarget
        Case OID_ACCEPT_ALL:
        Case OID_EDIT_DATE:
            'aText = "  Edit Effective Date"
        Case OID_CONTRACT:
            'aText = "  Edit Contract Range"
'        Case OID_LAST_DOWNLOAD:
'            times = m_params.LastDownloadTime
            'aText = "  Download"
'
'            With m_Sheet.Cells(3, 3)
'                .value = m_params.ToLocalTimeStr(times(0))
'            End With
            
        Case OID_DOWNLOAD_DATE:
            Call DrawTimes(True)
'            times = m_params.LastDownloadTime
'            aText = m_params.ToLocalTimeStr(times(0))
'
'        Case OID_LAST_UPLOAD:
'            times = m_params.LastUploadTime
            'aText = "  Upload"
            
'            With m_Sheet.Cells(4, 3)
'                .value = m_params.ToLocalTimeStr(times(0))
'            End With

        Case OID_UPLOAD_DATE:
            Call DrawTimes(False)
'            times = m_params.LastUploadTime
'            aText = m_params.ToLocalTimeStr(times(0))
        Case OID_ACCEPT:
'            Call DrawVR(Int(Val(aUserData)))
        Case OID_MIN_CONTRACT_DATE:
            Call GetContractDates(mindte, maxdte)
            aText = mindte
        Case OID_MAX_CONTRACT_DATE:
            Call GetContractDates(mindte, maxdte)
            aText = maxdte
    End Select
End Sub

Private Sub GetRanges()
    If m_params Is Nothing Then Exit Sub
    
    If m_sheet Is Nothing Then Set m_sheet = ActiveSheet
    Set m_dataRgn = CCurveControl.GetCurveRange(m_sheet)
    
    If Not m_dataRgn Is Nothing Then
        With m_dataRgn
            Set m_HeaderRgn = m_sheet.Cells(1, 1).Resize(.row - 1, .Columns.count)
        End With
    End If
End Sub

Private Sub AddMD(ByVal oprDateIndex As Long)
    Call CCurveControl.ResetRangeColor(m_params, m_dataRgn, oprDateIndex)
    Call CCurveControl.PopulateInputs
End Sub

Private Sub DrawTimes(ByVal aIsDownload As Boolean)
 Dim tv As Double
 
    If Not CCurveControl.GetAccessTimeToDraw(m_params, 0, aIsDownload, tv) Then Exit Sub
    Call CCurveControl.DrawAccessTime(m_sheet.Cells(3, 3), tv, aIsDownload, xlLeft)
End Sub

Private Sub DrawObjectAccept(ByVal aPos As Long)
 Dim cvrs() As String
 Dim oprs() As Double
 Dim vr As Variant
 
    Call PrivateDrawVR(aPos)
    
    cvrs = m_params.curves
    oprs = CCurveDates.EffectiveDateList
 
    vr = CCPVRStorage.GetVR(m_sheet, CURVE_VR_L_CURVE, cvrs(0), m_params.flagValues, oprs(aPos), 0, vbNullString, vbNullString)
    If IsEmpty(vr) Then Exit Sub

    If Not CCurveControl.ContainsStatusToAccept(vr) Then Exit Sub
    
    With m_Imager
        .AlternativeText = CCurveControl.GetAltTextDateRange(oprs(aPos))
        Call .Draw(OID_ACCEPT, CStr(aPos))
        .AlternativeText = vbNullString
    End With
End Sub

Private Sub DrawIcon(ByVal aObjectID As Integer, ByVal aPos As Long, ByVal aCurveName As String, ByVal aAlternativeText As String)
    With m_Imager
        .AlternativeText = CCurveControl.GetAltText(aCurveName, aAlternativeText)
        Call .Draw(aObjectID, CStr(aPos))
    End With
End Sub

Public Sub DrawVR(ByVal aIndex As Long)
    m_flags = m_flags Or CURVE_F_SUPPRESS_FINALIZE
    Call PrivateDrawVR(aIndex)
End Sub

Private Sub PrivateDrawVR(ByVal aIndex As Long)
    Call CCurveControl.DrawCurveVR(aIndex, 0, C_START_ROW - 1, aIndex + C_START_COL, xlLeft)
End Sub

Public Sub IFReLayout()
    m_flags = m_flags And (Not CURVE_F_SUPPRESS_FINALIZE)
    Call GetRanges
    Set m_Imager.sheet = m_sheet
    If m_params.granularities = 0 Then
        Call m_params.FromXML(CCurveControl.GetCurveProperties(m_sheet))
    End If
    
    Call CCurveControl.ClearImagesV1(m_dataRgn)
    
    Call AddStyle
    Call DrawObjects
End Sub

Private Function Is410() As Boolean
    If CCurveControl.IsUIUpToDate() Then Exit Function
    
    Is410 = Not m_sheet.Columns(2).EntireColumn.Hidden
End Function

Private Sub Reposition410Buttons()
 Dim t1 As Long
 Dim s As Shape

    'sort
    Set s = Find410Button("'MacroSort(" + EncodeMacroParam(CStr(1)) + ")'")
    If Not s Is Nothing Then
        With m_sheet.Cells(C_START_ROW, 1)
            s.top = .top + 11
            s.left = 168
        End With
    End If
    
    t1 = 23
    
    'plus
    Set s = Find410Button(CCurveControl.OnPlusMinusAction(CURVE_UI_CONTRACTS_END_PLUS))
    If Not s Is Nothing Then
        With m_sheet.Cells(C_START_ROW, 1)
            s.top = .top + t1
            s.left = .left + 85
        End With
    End If
    
    'minus
    Set s = Find410Button(CCurveControl.OnPlusMinusAction(CURVE_UI_CONTRACTS_END_MINUS))
    If Not s Is Nothing Then
        With m_sheet.Cells(C_START_ROW, 1)
            s.top = .top + t1
            s.left = .left + 75
        End With
    End If
End Sub

Private Function Find410Button(ByVal action As String) As Object
 Dim s As Shape
 
    With ActiveSheet
        For Each s In .Shapes
            If s.Type <> msoComment And s.Type <> msoFormControl Then
                If InStr(s.OnAction, action) > 0 Then
                    Set Find410Button = s
                    Exit Function
                End If
            End If
        Next
    End With
End Function

Private Sub LockRange(ByVal curveIdx As Long, rdonly As Boolean)
 Dim r As Long
 Dim c As Long
 Dim rgn As range
 
    Set rgn = CCurveControl.GetCurveRange(m_sheet)
    
    With rgn
        r = .rows.count - 1
        c = .Columns.count - 2
        If r <= 0 Or c <= 0 Then Exit Sub
        
        .offset(1, 2).Resize(r, c).Locked = rdonly
    End With
    
    'Call CCurveControl.Add4EyesStyle(m_dataRgn)
End Sub

Public Sub IFUpdatePermissions(permissions() As Long)
 Dim curves() As String
 Dim rdonly As Boolean
 Dim k As Long
 Dim iid As Long
 
    m_flags = m_flags Or CURVE_F_SUPPRESS_FINALIZE

    Set m_sheet = ActiveSheet
    If m_Imager Is Nothing Then Set m_Imager = New CCurveImageText
    Set m_Imager.sheet = m_sheet
    Set m_params = CCurveDates.ParamEntity

    Call GetRanges
    
    curves = m_params.curves
    rdonly = Not CCurveControl.HasWriteableCurves(m_sheet, m_params, permissions)
    
    With m_Imager
        .AlternativeText = vbNullString

        If rdonly Then
            Call CCurveControl.DeleteCurveIconsByID(m_Imager, OID_ACCEPT_ALL, OID_LAST_UPLOAD, OID_CONTRACT, OID_CONTRACT_START_PLUS, OID_CONTRACT_START_MINUS, OID_CONTRACT_END_PLUS, OID_CONTRACT_END_MINUS)
        
        Else
            If .FindImage(OID_ACCEPT_ALL) Is Nothing Then Call CCurveControl.AddAcceptAll(m_Imager)
            
            If .FindImage(OID_LAST_UPLOAD) Is Nothing Then
                Call .Draw(OID_LAST_UPLOAD, vbNullString)
                Call .Draw(OID_CONTRACT, vbNullString)

                Call .Draw(OID_CONTRACT_START_PLUS, vbNullString)
                Call .Draw(OID_CONTRACT_START_MINUS, vbNullString)
                Call .Draw(OID_CONTRACT_END_PLUS, vbNullString)
                Call .Draw(OID_CONTRACT_END_MINUS, vbNullString)
            End If
        End If
    End With
    
    m_Imager.DeleteExsitingBeforeAdd = False
    
    For k = 0 To m_params.ColumnCount - 1 - 1
        If rdonly Then
            iid = m_Imager.GetImageID(OID_ACCEPT, k)
            If Not m_Imager.FindImage(iid) Is Nothing Then Call m_Imager.DeleteImage(iid)
        Else
            Call DrawObjectAccept(k)
        End If
    Next
    Call LockRange(0, rdonly)
    
    With m_dataRgn
        If .rows.count > 1 Then
            Call CCurveControl.AddProtection(permissions, .Cells(2, C_START_COL).Resize(.rows.count - 1, .Columns.count - (C_START_COL - 1)))
        End If
    End With
End Sub
Attribute VB_Name = "CCPFutureSingle"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Option Base 0

Private m_sheet As Worksheet
Private WithEvents m_Imager As CCurveImageText
Attribute m_Imager.VB_VarHelpID = -1
Private m_params As New CCurveParams
Private m_dataRgn As range
Private m_HeaderRgn As range
Private m_flags As Long
'
Private Const C_FIXED_ROWS As Long = 5
'
Private Const OID_DOWNLOAD_ALL As Integer = 1
Private Const OID_UPLOAD_ALL As Integer = 2
Private Const OID_EDIT_DATE As Integer = 3
Private Const OID_CONTRACT As Integer = 4
Private Const OID_LAST_DOWNLOAD As Integer = 5
Private Const OID_LAST_UPLOAD As Integer = 6
Private Const OID_VIEW_HISTORY As Integer = 7
Private Const OID_DELETE As Integer = 8
Private Const OID_CURVE_NAME As Integer = 9
Private Const OID_SORT As Integer = 10
Private Const OID_CONTRACT_START_PLUS As Integer = 11
Private Const OID_CONTRACT_START_MINUS As Integer = 12
Private Const OID_CONTRACT_END_PLUS As Integer = 13
Private Const OID_CONTRACT_END_MINUS As Integer = 14
Private Const OID_MAX_CONTRACT_DATE As Integer = 15
Private Const OID_MIN_CONTRACT_DATE As Integer = 16
'

Private Sub GetRanges()
    If m_params Is Nothing Then Exit Sub
    
    If m_sheet Is Nothing Then Set m_sheet = ActiveSheet
    Set m_dataRgn = CCurveControl.GetCurveRange(m_sheet)
    
    If Not m_dataRgn Is Nothing Then
        With m_dataRgn
            Set m_HeaderRgn = m_sheet.Cells(1, 1).Resize(.row - 1, .Columns.count)
        End With
    End If
End Sub

Private Sub AddStyle()
 Dim k As Long
 Dim f As Variant
 Dim b As Boolean
 Dim rgn As range
 Dim row As Long
 Dim cols As Long
 
    With m_HeaderRgn
        .offset(1).Resize((C_FIXED_ROWS - 1)).Interior.color = RGB(255, 255, 255)
        .Cells(2, 2 + 1).Resize(, .Columns.count - 2).Interior.color = CURVE_ROW_HEADER_COLOR
        
        If .rows.count > C_FIXED_ROWS Then
            .offset(C_FIXED_ROWS).Resize(.rows.count - C_FIXED_ROWS).Interior.color = CURVE_ROW_HEADER_COLOR
            
'            If .rows.count >= 7 Then
'                Set rgn = .offset(C_FIXED_ROWS).Resize(2, 1)
'                rgn.MergeCells = True
'                'rgn.HorizontalAlignment = xlCenter
'                rgn.VerticalAlignment = xlCenter
'            End If
            
            For k = (C_FIXED_ROWS + 1) To .rows.count
                '.Cells(k, 2).HorizontalAlignment = xlFill
'                .Cells(k, 2).WrapText = True
            Next
            
            .offset(C_FIXED_ROWS).Resize(.rows.count - C_FIXED_ROWS, 2).Interior.color = RGB(255, 255, 255)
        End If
    End With

    cols = 2 * UBound(m_params.curves) + 4
    
    With m_HeaderRgn.offset(1).Resize(C_FIXED_ROWS - 1)
        .Borders(xlInsideHorizontal).LineStyle = xlContinuous
        .Borders(xlInsideHorizontal).Weight = xlHairline
        .Borders(xlInsideHorizontal).color = RGB(&HD9, &HD9, &HD9)
        
    End With
    
    For row = 2 To C_FIXED_ROWS
        For k = 4 To cols Step 2
            With m_HeaderRgn.Cells(row, k)
                If row <> 2 And row <> C_FIXED_ROWS Then
'                    .Borders(xlEdgeTop).LineStyle = xlContinuous
'                    .Borders(xlEdgeTop).Weight = xlHairline
'                    .Borders(xlEdgeTop).color = RGB(&HD9, &HD9, &HD9)
'
'                    .Borders(xlEdgeBottom).LineStyle = xlContinuous
'                    .Borders(xlEdgeBottom).Weight = xlHairline
'                    .Borders(xlEdgeBottom).color = RGB(&HD9, &HD9, &HD9)

                    If k <> 1 Then
                        .Borders(xlEdgeRight).LineStyle = xlContinuous
                        .Borders(xlEdgeRight).Weight = IIf(k = 2 Or k = cols, xlThin, xlHairline)
                    End If

                    If k > 2 And k <> cols Then
                        .Borders(xlEdgeRight).color = RGB(&HD9, &HD9, &HD9)
                    End If
                Else
                   If k = cols Then
                        .Borders(xlEdgeRight).LineStyle = xlContinuous
                        .Borders(xlEdgeRight).Weight = xlThin
                   End If
                End If
            End With
        Next
    Next
    
    For row = 2 To C_FIXED_ROWS Step 3
        For k = 4 To cols Step 2
            With m_HeaderRgn.Cells(row, k)
                .Borders(xlEdgeRight).LineStyle = xlContinuous
                .Borders(xlEdgeRight).Weight = IIf(k <> cols, xlHairline, xlThin)
                If k <> cols Then
                    .Borders(xlEdgeRight).color = RGB(&HD9, &HD9, &HD9)
                End If
            End With
        Next
    Next
    
    For row = C_FIXED_ROWS + 1 To m_HeaderRgn.rows.count
        For k = 1 To cols
            With m_HeaderRgn.Cells(row, k)
 
                If k <> 1 Then
                    .Borders(xlEdgeTop).LineStyle = xlContinuous
                    .Borders(xlEdgeTop).Weight = xlHairline
                    .Borders(xlEdgeTop).color = RGB(&HD9, &HD9, &HD9)
                    
                    .Borders(xlEdgeBottom).LineStyle = xlContinuous
                    .Borders(xlEdgeBottom).Weight = xlHairline
                    .Borders(xlEdgeBottom).color = RGB(&HD9, &HD9, &HD9)
                End If

                .Borders(xlEdgeRight).LineStyle = xlContinuous
                .Borders(xlEdgeRight).Weight = IIf(k = cols, xlThin, xlHairline)
                If k <> cols Then
                    .Borders(xlEdgeRight).color = RGB(&HD9, &HD9, &HD9)
                End If

            End With
        Next
    Next
    
    row = m_HeaderRgn.rows.count
    With m_HeaderRgn.rows(row)
        .Borders(xlEdgeBottom).LineStyle = xlContinuous
        .Borders(xlEdgeBottom).Weight = xlThin
    End With
    
    With m_dataRgn
        .Cells(1, 1).RowHeight = 36
    
        With .rows(1)
            .HorizontalAlignment = xlCenter
            .VerticalAlignment = xlCenter
'            .WrapText = False
            .Orientation = 0
            .AddIndent = False
            .IndentLevel = 0
            .ShrinkToFit = False
            .ReadingOrder = xlContext
            .MergeCells = False
        End With

        Call SetDateAreaAlignment(.Cells(1, 1).Resize(, 2))
        
        For Each f In .Columns
            f.ColumnWidth = IIf(f.column <= 2, 18 * 2, 24)
        Next
    End With
    
    m_sheet.Columns(2).EntireColumn.Hidden = True
    
    Call AddDataStyle(-1, -1)
End Sub

Private Sub SetDateAreaAlignment(rgn As range)
    With rgn
        .HorizontalAlignment = xlRight
        .IndentLevel = 3
    End With
End Sub

Private Sub AddDataStyle(ByVal dayCount As Long, ByVal op As Integer)
 Dim k As Long
 Dim f As Variant
 Dim b As Boolean
 Dim rgn As range
 Dim row As Long
 Dim cols As Long
    
    With m_dataRgn
        If op = -2 Then
            With .offset(.rows.count - 1).Resize(1)
                .Borders(xlEdgeBottom).color = RGB(210, 210, 210)
            End With
            
        ElseIf op = -1 Then
            For Each f In .Columns
                If f.column > 1 Then
                    With f
                        b = (f.column = 2 Or f.column = m_params.ColumnCount + 1 Or f.column Mod 2 = 0)
                        .Borders(xlEdgeRight).LineStyle = IIf(b, XlLineStyle.xlLineStyleNone, xlContinuous)
                        .Borders(xlEdgeRight).Weight = IIf(b, xlThin, xlHairline)
                    End With
                End If
            Next
    
            If .rows.count > 1 Then
                Call SetDateAreaAlignment(.offset(1).Resize(.rows.count - 1, 2))
            End If
     
            .Borders(xlEdgeRight).LineStyle = xlContinuous
            .Borders(xlEdgeRight).Weight = xlThin
            
'            For Each f In .rows
'                With f
                    .Borders(xlInsideHorizontal).LineStyle = xlContinuous
                    .Borders(xlInsideHorizontal).Weight = xlThin
                    .Borders(xlInsideHorizontal).color = RGB(210, 210, 210)
'                End With
'            Next
            .Borders(xlEdgeBottom).color = RGB(210, 210, 210)
            
        Else
            For k = 3 To .Columns.count
               With .offset(IIf(op = 3, .rows.count - dayCount, dayCount), k - 1).Resize(dayCount, 1)
                    b = (k = m_params.ColumnCount + 1 Or k Mod 2 = 0)
                    .Borders(xlEdgeRight).LineStyle = IIf(b, XlLineStyle.xlLineStyleNone, xlContinuous)
                    .Borders(xlEdgeRight).Weight = IIf(b, xlThin, xlHairline)
               End With
           Next
           
'           For k = IIf(op = 3, .rows.count - dayCount, 1) To IIf(op = 3, .rows.count - 1, dayCount)
'               With .offset(k).Resize(1, 2)
'                   Call .Merge
'                   .HorizontalAlignment = xlCenter
'               End With
'
'           Next
    
           .Borders(xlEdgeRight).LineStyle = xlContinuous
           .Borders(xlEdgeRight).Weight = xlThin
           
           With .offset(IIf(op = 3, .rows.count - dayCount, 1)).Resize(dayCount)
                .Borders(xlInsideHorizontal).color = RGB(210, 210, 210)
                .Borders(xlEdgeBottom).color = RGB(210, 210, 210)
            End With
        End If
    
    
''        If m_params.rowCount > 1 Then
''             .Cells(2, 1).Resize(m_params.rowCount - 1, 1).Columns(1).Interior.color = BSConsts.CURVE_ROW_HEADER_COLOR
''        End If
''
''        .Interior.color = BSConsts.CURVE_ROW_HEADER_COLOR
''        '.Font.color = rgb(50, 50, 50)
''        .VerticalAlignment = xlCenter
'''        .HorizontalAlignment = xlCenter
''
''        If .rows.count > 1 Then
''             .offset(1).Resize(m_dataRgn.rows.count - 1, 2).Interior.color = BSConsts.CURVE_COLUMN_HEADER_COLOR
''        End If
''
''        If .rows.count > 1 Then
''            With .offset(1, 1).Resize(.rows.count - 1, .Columns.count - 1)
''                .FormatConditions.Delete
''
''                .FormatConditions.Add Type:=xlExpression, Formula1:="=Mod(Row(),2)=0"
''                .FormatConditions(1).Interior.color = CURVE_ROW_ALTERNATING_COLOR_2
''                .FormatConditions.Add Type:=xlExpression, Formula1:="=Mod(Row(),2)<>0"
''                .FormatConditions(2).Interior.color = CURVE_ROW_ALTERNATING_COLOR_1
''
''            End With
''        End If
''
''        If .rows.count > 1 Then
''            For k = 3 To .Columns.count Step 2
''                 .offset(1, k - 1).Resize(.rows.count - 1, 1).Interior.color = BSConsts.CURVE_COLUMN_HEADER_COLOR
''
''                If m_params.Readonly((k - 3) / 2) Then
''                     .offset(1, k).Resize(.rows.count - 1, 1).Interior.color = BSConsts.CURVE_COLUMN_HEADER_COLOR2
''                End If
''            Next
''
''        End If
    End With
End Sub

Private Sub InitImager()
    With m_Imager
        Set .sheet = m_sheet
'        Set .ZEComp = m_ZEComp
    End With
End Sub

Public Function IFDelete(sheet As Worksheet, ByVal aGroupName As String, ByVal aCurveName As String)
 Dim idx As Long
 Dim j As Long

    m_flags = m_flags And (Not CURVE_F_SUPPRESS_FINALIZE)
    Set m_sheet = sheet
    Set m_Imager.sheet = m_sheet

    Set m_params = CCurveDates.ParamEntity
    Call GetRanges
    
    idx = m_params.GetCurvePosition(aCurveName)
    If idx < 0 Then Exit Function
    IFDelete = True
    
    For j = 1 To 2
        Call sheet.Columns(2 * idx + 3).Delete(xlShiftToLeft)
    Next
    
    Call CCurveControl.DeleteCurveIcons(aCurveName, AT_HISTORY, AT_SORT, AT_DELETE, AT_DOWNLOAD, AT_UPLOAD, AT_ACCEPT, AT_NAME)
    
    'strange in Excel ?
    With m_params
        Call .RemoveCurve(idx)
        .ColumnCount = .ColumnCount - 2
    End With
    
    Call CCurveControl.SaveCurveProperties(m_sheet, m_params)
'    Call RemoveMD(idx)
    
    If m_params.GetCurveCount() > 0 Then
        Call CCurveControl.SaveCurveProperties(m_sheet, m_params)
        Call GetRanges
        
        If m_params.AllCurvesRD() Then
            Call CCurveControl.DeleteCurveIconsByID(m_Imager, OID_ACCEPT_ALL, OID_UPLOAD_ALL, OID_CONTRACT, OID_DELETE, OID_CONTRACT_START_PLUS, OID_CONTRACT_START_MINUS, OID_CONTRACT_END_PLUS, OID_CONTRACT_END_MINUS, OID_MAX_CONTRACT_DATE, OID_MIN_CONTRACT_DATE)
        End If
        
        Call CCurveControl.DeleteProperties(m_HeaderRgn, C_FIXED_ROWS)
    Else
        Call OnDeletion
    End If
End Function

Private Sub OnDeletion()
 Dim p As CustomProperty
 Dim shp As Shape
 
    m_sheet.Cells.Delete
    For Each shp In m_sheet.Shapes
        shp.Delete
    Next
    
    For Each p In m_sheet.CustomProperties
        p.Delete
    Next
End Sub

Public Function IFNew(data As ZEWSProxy.ICurveResult, ud As CCurveUserData) As Boolean
 Dim isnew As Boolean
 
    m_flags = m_flags And (Not CURVE_F_SUPPRESS_FINALIZE)
    Call m_params.FromXML(data.value)

    Set m_sheet = CCurveControl.GetSheet(m_params, True, isnew)
    If m_sheet Is Nothing Then Exit Function ' failed to find the workbook
    
    If Not isnew Then
        Call CCurveControl.AdjustPropNDataAreas(m_params, 5)
    End If
    Call CCurveDates.AssignTargetSheet(m_sheet)
    Set CCurveDates.ParamEntity = m_params
 
    Call CCurveControl.SaveCurveProperties(m_sheet, m_params)
    Call InitImager
    
    Call CDDXCurve.SetFindCriterion(BSConsts.DDX_PID, m_sheet, ud.Criterion)

    Call DrawHeader
    Call DrawProperties
    Call DrawData(True)

    Call AddStyle
    Call DrawObjects
    
    Call AddMD(-1)
    
    IFNew = True
End Function

Public Function IFSort(ByVal aGroupName As String, ByVal aCurveName As String) As Boolean
 Dim sorter As CCurveSort
 Dim pos As Long

    m_flags = m_flags And (Not CURVE_F_SUPPRESS_FINALIZE)
    Set m_sheet = ActiveSheet
    Set m_params = CCurveControl.GetParams(m_sheet)
    Call GetRanges
    
    With m_dataRgn
        If .Columns.count <= 3 Or .rows.count <= 2 Then Exit Function
    End With

'    Call UponSort(True)
    
    pos = m_params.GetCurvePosition(aCurveName)
    Set sorter = New CCurveSort
    
    With m_dataRgn
        IFSort = sorter.Execute(.offset(1).Resize(.rows.count - 1), IIf(aCurveName = vbNullString, 1, 2 * (pos + 1) + 2), m_params)
    End With
    
    Set sorter = Nothing
    
    If Not IFSort Then Exit Function
'    Call UponSort(False)
    
    Call GetRanges
    Call AddStyle
End Function

Public Function IFRefresh(data As ZEWSProxy.ICurveResult) As Boolean
 Dim oldParams As CCurveParams
 
    m_flags = m_flags And (Not CURVE_F_SUPPRESS_FINALIZE)
    Set m_sheet = ActiveSheet
    
    Call m_params.FromXML(data.value)
    
    Call CCurveControl.ClearAllImages(m_sheet)
    Call CCurveControl.AdjustPropNDataAreas(m_params, 5)
    
    Set oldParams = New CCurveParams
    Call oldParams.FromXML(CCurveControl.GetCurveProperties(m_sheet))
    
    With m_params
        .LastUploadTime = oldParams.LastUploadTime
    End With
    
    Call CCurveControl.SaveCurveProperties(m_sheet, m_params)
    Set oldParams = Nothing
    
    Call GetRanges
    
    Call m_sheet.Cells.Clear
    
    Call InitImager
    
    Call DrawHeader
    Call DrawProperties
    Call DrawData(True)
    
    Call AddStyle
    Call DrawObjects

    Call AddMD(-1)
    
    IFRefresh = True
End Function

Private Sub RefreshVROnUpload(ByVal cvrIdx As Long, ByVal doSummary As Boolean, ByVal readComments As Boolean)
 Dim rgn As range
 Dim cvrnms() As String
 
    Set rgn = m_dataRgn.offset(1, 2 + IIf(cvrIdx >= 0, 2 * cvrIdx, 0)).Resize(m_dataRgn.rows.count - 1, IIf(cvrIdx >= 0, 2, m_dataRgn.Columns.count - 2))
    
    If CDDXCurve.FourEyesActive Then
        If readComments Then Call CCurveControl.RefreshCommentsAfterUploaded(rgn, False)
        
    Else
        If doSummary Then
            Call CCurveControl.VRColorValues(vbNullString, rgn, m_params, True)
        End If
        
        Call CCurveControl.EraseAccepts(m_Imager, cvrIdx)
        cvrnms = m_params.curves
        
        If cvrIdx >= 0 Then
            Call DrawObjectAccept(cvrnms(cvrIdx), cvrIdx)
        Else
            For cvrIdx = LBound(cvrnms) To UBound(cvrnms)
                Call DrawObjectAccept(cvrnms(cvrIdx), cvrIdx)
            Next
        End If
    End If
End Sub

Public Function IFUpload(data As ZEWSProxy.ICurveResult, ByVal curvePos As Long) As Boolean
 Dim k As Long
 Dim curveIdx() As Long
 Dim count As Long
 
    m_flags = m_flags And (Not CURVE_F_SUPPRESS_FINALIZE)
    Set m_sheet = ActiveSheet
    Call m_params.FromXML(CCurveControl.GetCurveProperties(m_sheet))
    Call GetRanges
    
    curveIdx = CCurveControl.GetUploadedItms(m_params, m_sheet, data, True, count)
    If count > 0 Then
        Call CCurveControl.SaveCurveProperties(m_sheet, m_params)

        For k = LBound(curveIdx) To UBound(curveIdx)
            Call DrawTimes(curveIdx(k), False)
        Next

    End If
    
    Call RefreshVROnUpload(curvePos - 1, True, True)
    Call CDDXCurve.NotifyCurveUploadResult(DDX_PID, data, m_params)
    
    IFUpload = True
End Function

Public Function IFRefreshIndividual(data As ZEWSProxy.ICurveResult, ByVal RefreshTarget As Integer) As Boolean
 Dim p As New CCurveParams
 Dim index As Long
 Dim curves() As String
 Dim downloadtimes() As String
 Dim target As String
 Dim newtime As String

    m_flags = m_flags And (Not CURVE_F_SUPPRESS_FINALIZE)
    Call p.FromXML(data.value)
    
    Set m_sheet = ActiveSheet

    With p
        curves = .curves
        target = curves(LBound(curves))
        downloadtimes = .LastDownloadTime()
        newtime = downloadtimes(LBound(downloadtimes))
    End With
    Set p = Nothing
    
    Set m_params = CCurveDates.ParamEntity
    With m_params
'        Call .FromXML(CCurveControl.GetCurveProperties(m_sheet))
            
        Call GetRanges

        curves = .curves
        downloadtimes = .LastDownloadTime
        For index = LBound(curves) To UBound(curves)
            If curves(index) = target Then
                downloadtimes(index) = newtime
                .LastDownloadTime = downloadtimes
                Exit For
            End If
        Next
        If index > UBound(curves) Then Exit Function
    End With
    
    Call InitImager
'    Call DrawObjectDownload(target, index)
    Call DrawTimes(index, True)
    Call ReadFromFile(index, RefreshTarget)
    
    Call CCurveControl.SaveCurveProperties(m_sheet, m_params)
    
    If RefreshTarget <> 1 Then
        Call AddMD(index)
    End If
    
    Call GetRanges
    Call RefreshVROnUpload(index, False, False)
    
    IFRefreshIndividual = True
End Function

Private Sub DrawHeader()
 Dim wr As range
 Dim f As Variant

    Call CCurveControl.SetSplits(m_sheet, m_params.PropertyCount + C_FIXED_ROWS + 1, 2)
    Call GetRanges
    
    Call CCurveControl.InsertTitle(m_sheet)
        
' set header info
    With m_HeaderRgn
        .Cells(1, 1).RowHeight = 40
        For f = 2 To .rows.count
             .Cells(f, 1).RowHeight = 18
        Next
        
        m_sheet.rows(1).Interior.color = RGB(&H0, &H52, &H93)
        
        'borders
    '    Set wr = m_HeaderRgn.Cells(2, 1).Resize(4, 2)
    '
    '    With wr.Resize(, 2)
    '        .Borders(xlEdgeRight).LineStyle = xlContinuous
    '    End With
     
        'ze logo
        
        
        With .rows(1)
            .Borders(xlEdgeBottom).LineStyle = xlContinuous
            .Borders(xlEdgeBottom).Weight = xlThick
            '.Borders(xlEdgeBottom).ColorIndex = 10
            .Borders(xlEdgeBottom).color = RGB(&H5E, &HB6, &HE4)
        End With
        
        With .Cells(.rows.count + 1, 1).Resize(1, .Columns.count)
            .Borders(xlEdgeTop).LineStyle = xlContinuous
            .Borders(xlEdgeTop).Weight = xlHairline
        End With
    End With
End Sub

Private Sub DrawProperties()
 Dim k As Long
 Dim j As Long
 Dim Values() As String
 Dim cvs() As String
 Dim row As Long
 Dim col As Long
 
    With m_params
        Values = .PropertyNames
        If Len(Join(Values)) = 0 Then Exit Sub
        
        m_HeaderRgn.Cells((C_FIXED_ROWS + 1), 1).Resize(UBound(Values) - LBound(Values) + 1).value = vbNullString
        
'        With m_HeaderRgn.Cells((C_FIXED_ROWS + 1), 1)
'            .value = "  Property"
'            .Characters.Font.Bold = True
'            .Characters.Font.SIZE = 9
'        End With
                
        For k = LBound(Values) To UBound(Values)
            With m_HeaderRgn.Cells(k + (C_FIXED_ROWS + 1), 1)
                .value = CCurveControl.AddApostrophe(Values(k)) + " "
                .Characters.Font.size = 8
                .HorizontalAlignment = xlRight
                .VerticalAlignment = xlCenter
            End With
        Next
        
        cvs = .curves
        For k = LBound(cvs) To UBound(cvs)
            Values = .PropertyValues(cvs(k))
            
            For j = LBound(Values) To UBound(Values)
                row = C_FIXED_ROWS + j + 1
                col = 2 * k + 1 + 2
                With m_HeaderRgn.Cells(row, col)
                    .Resize(, 2).MergeCells = True
                    .value = CCurveControl.AddApostrophe(Values(j))
                    .Characters.Font.size = 8
                    .Characters.Font.Bold = False
                    .HorizontalAlignment = xlLeft
                    .VerticalAlignment = xlCenter
                End With
            Next
        Next
    End With
End Sub

Private Sub DrawIcon(ByVal aObjectID As Integer, ByVal aPos As Long, ByVal aCurveName As String, ByVal aAlternativeText As String)
    With m_Imager
        .AlternativeText = CCurveControl.GetAltText(aCurveName, aAlternativeText)
        Call .Draw(aObjectID, CStr(aPos))
    End With
End Sub

Private Sub DrawObjectDownload(ByVal aCurveName As String, ByVal aPos As Long)
    Call DrawIcon(OID_LAST_DOWNLOAD, aPos, aCurveName, AT_DOWNLOAD)
End Sub

Private Sub DrawObjectUpload(ByVal aCurveName As String, ByVal aPos As Long)
    Call DrawIcon(OID_LAST_UPLOAD, aPos, aCurveName, AT_UPLOAD)
End Sub

Private Sub DrawDateRange()
    Call CCurveControl.DrawStyledTexts(m_sheet, 2, 1, " Effective Date:  ", format(m_params.OprStartDate, CDDXDates.SystemDateFormat))
End Sub

Private Sub DrawInterval()
 Dim dtz As Boolean
 
    dtz = CCurveGranularity.IsGranularity(m_params.granularities, CURVE_GRANULARITY_HOURLY) Or CCurveGranularity.IsGranularity(m_params.granularities, CURVE_GRANULARITY_MINUTELY)
    dtz = IIf(dtz And m_params.TZName <> vbNullString And (m_params.IsFlag(CURVE_FLG_DST_ADJUST_START) Or m_params.IsFlag(CURVE_FLG_DST_ADJUST_END)), True, False)
    Call CCurveControl.DrawStyledTexts(m_sheet, 3, 1, " Interval:  ", CCurveGranularity.GetGranularityName(m_params.granularities), IIf(dtz, "   (" + m_params.TZName + ")", vbNullString))
End Sub

Private Sub DrawContractDatesForMP()
    With m_Imager
        Call .Draw(OID_MAX_CONTRACT_DATE, vbNullString)
        Call .Draw(OID_MIN_CONTRACT_DATE, vbNullString) '
    End With
End Sub

Private Sub DrawObjects()
 Dim k As Long
 Dim curves() As String
' Dim groups() As String

    Call DrawDateRange
    Call DrawInterval
    
    With m_Imager
        .AlternativeText = vbNullString
        
        Call .Draw(OID_DOWNLOAD_ALL, vbNullString)
        Call .Draw(OID_EDIT_DATE, vbNullString)
        If Not m_params.AllCurvesRD() Then
            Call CCurveControl.AddAcceptAll(m_Imager)

            Call .Draw(OID_UPLOAD_ALL, vbNullString) '
            Call .Draw(OID_SORT, vbNullString)
            Call .Draw(OID_CONTRACT, vbNullString)
            Call DrawContractDatesForMP

            Call .Draw(OID_CONTRACT_START_PLUS, vbNullString)
            Call .Draw(OID_CONTRACT_START_MINUS, vbNullString)
            Call .Draw(OID_CONTRACT_END_PLUS, vbNullString)
            Call .Draw(OID_CONTRACT_END_MINUS, vbNullString)
        End If

    End With
    
'    Call AddButton("Download All", "MacroDownloadAllS", 8, 12)
'    If Not readonly Then
'        Call AddButton("Upload All", "MacroUploadAllS", 78, 0)
'    End If
    
    curves = m_params.curves
'    groups = m_params.CurveGroups
    For k = LBound(m_params.curves) To UBound(m_params.curves)
        Call DrawIcon(OID_VIEW_HISTORY, k, curves(k), AT_HISTORY)
        
        Call DrawObjectDownload(curves(k), k)
        If Not m_params.Readonly(k) Then
            Call DrawObjectUpload(curves(k), k)
            Call DrawIcon(OID_SORT, k, curves(k), AT_SORT)
        End If
        
        Call DrawIcon(OID_DELETE, k, curves(k), AT_DELETE)
        
        Call DrawCurveName(k, curves(k))
        Call DrawIcon(OID_CURVE_NAME, k, curves(k), AT_NAME)
        
        Call DrawObjectAccept(curves(k), k)
    Next
End Sub

Private Sub DrawCurveName(ByVal aPos As Long, ByVal aCurveName As String)
    If aPos = 0 Then
        With m_HeaderRgn.Cells(C_FIXED_ROWS, 3).Resize(1, m_HeaderRgn.Columns.count - 2)
            .Characters.Font.Bold = True
            .Characters.Font.size = 8
            '
            .HorizontalAlignment = xlLeft
            .VerticalAlignment = xlCenter
    '        .WrapText = False
            .Orientation = 0
            .AddIndent = False
            .IndentLevel = 0
            .ShrinkToFit = False
            .ReadingOrder = xlContext
            .NumberFormat = "@"
        End With
    End If
    
    aPos = 2 * aPos + 3
    
    With m_HeaderRgn.Cells(C_FIXED_ROWS, aPos) '.Resize(1, 2)
'        Call .Merge
'        .Characters.Font.Bold = True
'        .Characters.Font.size = 8
'        '
'        .HorizontalAlignment = xlLeft
'        .VerticalAlignment = xlCenter
''        .WrapText = False
'        .Orientation = 0
'        .AddIndent = False
'        .IndentLevel = 0
'        .ShrinkToFit = False
'        .ReadingOrder = xlContext
'        .NumberFormat = "@"
        .value = CCurveControl.AddApostrophe(aCurveName)
    End With
End Sub

Private Sub DrawData(ByVal aIsNew As Boolean)
    m_dataRgn.Font.ColorIndex = 1
    Call ReadFromFile(-1, 3)
End Sub

Private Sub ReadFromFile(ByVal aCurveIndex As Long, ByVal RefreshTarget As Long)
 Dim wid As Long
 Dim start As Long

    With m_dataRgn
        If aCurveIndex < 0 Then
            Call CCurveControl.ReadFile(aCurveIndex, .Resize(, 1), .offset(, 2).Resize(, .Columns.count - 2), m_params)
        Else
            If CDDXHelper.IsFlag(RefreshTarget, CURVE_DOWNLOAD_RECENT) And CDDXHelper.IsFlag(RefreshTarget, CURVE_DOWNLOAD_CURRENT) Then
                start = 1
                wid = 2
            Else
                start = IIf(CDDXHelper.IsFlag(RefreshTarget, CURVE_DOWNLOAD_RECENT), 1, 2)
                wid = 1
            End If
            Call CCurveControl.ReadFile(aCurveIndex, Nothing, .Cells(1, 2 * (aCurveIndex + 1) + start).Resize(.rows.count, wid), m_params)
        End If
    End With
    
    Call GetRanges
End Sub

Private Sub Class_Initialize()
    Set m_Imager = New CCurveImageText
End Sub

Private Sub Class_Terminate()
    Call ProtectSheet
    Set m_Imager = Nothing
End Sub

Private Sub ProtectSheet()
 Dim r As Long
 Dim c As Long
 Dim k As Long
 Dim editprev As Boolean
 
    If CDDXHelper.IsFlag(m_flags, CURVE_F_SUPPRESS_FINALIZE) Then Exit Sub
    
    If m_params.GetCurveCount() <= 0 Then
        Call CCurveControl.Unprotect(m_sheet)
        Exit Sub
    End If

    If m_sheet Is Nothing Then Exit Sub
    If m_sheet.ProtectContents Then Exit Sub
    
    m_sheet.UsedRange.Cells.Locked = True

    editprev = m_params.IsFlag(CURVE_FLG_EDIT_MRBD_COLUMN)
    
    If Not editprev Then 'backward compatibility
        editprev = CDDXHelper.IsFlag(CDDXCurve.GetFVS(m_sheet), CURVE_FLG_EDIT_MRBD_COLUMN)
        If editprev Then
            m_params.flagValues = m_params.flagValues Or CURVE_FLG_EDIT_MRBD_COLUMN
            Call CCurveControl.SaveCurveProperties(m_sheet, m_params)
        End If
    End If
    
    If Not m_dataRgn Is Nothing Then
        With m_dataRgn
            r = .rows.count - 1
            c = .Columns.count
        
            If r > 0 Then
                For k = LBound(m_params.curves) To UBound(m_params.curves)
                    
                    If Not m_params.Readonly(k) Then
                        .offset(1, 2 * k + 3).Resize(r, 1).Locked = False
                        If editprev Then
                             .offset(1, 2 * k + 2).Resize(r, 1).Locked = False
                        End If
                    End If
                Next
                
                .Cells(2, 1).Resize(r).NumberFormat = CDDXCurve.GetContractDateFormat(m_params.granularities)
                
                With .Cells(2, 3).Resize(r, c - 2)
'                    .NumberFormat = "General"
                    .HorizontalAlignment = xlRight
                End With
            End If
        End With
        
        Call CCurveControl.Add4EyesStyle(m_dataRgn)
    End If
    
    Call CCurveControl.Protect(m_sheet)
End Sub

Private Sub m_Imager_OnImage(sender As Object, ByVal aTarget As Integer, ByVal aUserData As String, aPicturePath As String, ByRef aWidth As Single, ByRef aHeight As Single)
    aPicturePath = vbNullString
    aWidth = 95
    aHeight = 18
    
    Select Case aTarget
        Case OID_EDIT_DATE:
            aWidth = 140
            aPicturePath = "CurveEditSettings.png" '"CurveEditDate.png"
        Case OID_CONTRACT:
            aWidth = 140
            aPicturePath = "CurveContract.png" 'If Not cDDXCurve.IsCurveReadOnly(m_Sheet) Then
        Case OID_LAST_DOWNLOAD:
            aWidth = 110
            aPicturePath = "CurveLastDownload.png"
        Case OID_DOWNLOAD_ALL:
            aWidth = 100
            aPicturePath = "CurveDownloadAll.png"
        Case OID_ACCEPT_ALL:
            aWidth = 100
            aPicturePath = "CurveAcceptAll.png"
        Case OID_ACCEPT:
            aWidth = 100
            aPicturePath = "CurveAccept.png"
        Case OID_LAST_UPLOAD:
            aWidth = 110
            aPicturePath = "CurveLastUpload.png"
        Case OID_UPLOAD_ALL:
            aWidth = 100
            aPicturePath = "CurveUploadAll.png"
        Case OID_VIEW_HISTORY:
            aWidth = 110
            aPicturePath = "CurveViewHistory.png"
        Case OID_DELETE:
            aPicturePath = "CurveDelete.png"
        Case OID_SORT:
            aPicturePath = IIf(aUserData = vbNullString, "filter.png", "filter.png")
        Case OID_CURVE_NAME:
            aWidth = 0 '215
            aHeight = 0 '
        Case OID_CONTRACT_START_PLUS, OID_CONTRACT_END_PLUS:
            aPicturePath = "CurvePlus.png"
        Case OID_CONTRACT_START_MINUS, OID_CONTRACT_END_MINUS:
            aPicturePath = "CurveMinus.png"
        Case OID_MIN_CONTRACT_DATE, OID_MAX_CONTRACT_DATE:
            aWidth = 68
            aHeight = 16
    End Select
End Sub

Private Sub m_Imager_OnImageBackColor(sender As Object, ByVal aTarget As Integer, bkColor As Long)
    Select Case aTarget
        Case OID_MIN_CONTRACT_DATE, OID_MAX_CONTRACT_DATE:
            'bkColor = m_Sheet.Cells(BSConsts.CURVE_SINGLE_START_ROW, 1).Interior.color
            bkColor = xlNone 'm_dataRgn.Cells(1, 1).Interior.color
        Case Else:
            bkColor = RGB(255, 255, 255) 'BSConsts.CURVE_ROW_HEADER_COLOR
    End Select
End Sub

Private Sub m_Imager_OnImagePlacement(sender As Object, ByVal aTarget As Integer, ByVal aUserData As String, aTop As Single, aLeft As Single, aWidth As Single, aHeight As Single)
 Dim col As Long
 Dim t1 As Variant
 
    t1 = 23
    col = 2 * GetColIndex(aUserData) + 1
    aWidth = -1
    aHeight = -1
    
    Select Case aTarget
        Case OID_EDIT_DATE:
            With m_sheet.Cells((C_FIXED_ROWS - 1), 1)
                aTop = .top + 3
                aLeft = .left + 5
            End With
        Case OID_CONTRACT:
            With m_dataRgn.Cells(1, 1)
                .value = " "
                aTop = .top + 6
                aLeft = .left + 5
            End With
            
        Case OID_CONTRACT_START_PLUS:
            With m_dataRgn.Cells(1, 1)
                aTop = .top + t1
                aLeft = .left + 6
            End With
        Case OID_CONTRACT_START_MINUS:
            With m_dataRgn.Cells(1, 1)
                aTop = .top + t1
                aLeft = .left + 16
            End With
        Case OID_CONTRACT_END_PLUS:
            With m_dataRgn.Cells(1, 1)
                aTop = .top + t1
                aLeft = .left + .Width / 2 - 20
            End With
        Case OID_CONTRACT_END_MINUS:
            With m_dataRgn.Cells(1, 1)
                aTop = .top + t1
                aLeft = .left + .Width / 2 - 10
            End With
           
        Case OID_MIN_CONTRACT_DATE:
            With m_dataRgn.Cells(1, 1)
                aTop = .top + t1 - 1
                aLeft = .left + 26
            End With
        Case OID_MAX_CONTRACT_DATE:
            With m_dataRgn.Cells(1, 2)
                aTop = .top + t1 - 1
                aLeft = .left + 20
            End With
            
        Case OID_SORT:
            With m_dataRgn.Cells(1, IIf(col < 0, 2, col + 1))
                aTop = .top + 11
                aLeft = .left + .Width - IIf(col < 0, 14, 14)
            End With
        Case OID_VIEW_HISTORY:
            With m_sheet.Cells(2, col)
                aTop = .top + 4
                aLeft = .left + 5
            End With
        Case OID_LAST_DOWNLOAD:
            With m_sheet.Cells(3, col)
                aTop = .top + 3
                aLeft = .left + 5
                'aWidth = 2 * .Width - 2
            End With
        Case OID_DOWNLOAD_ALL:
            With m_sheet.Cells(C_FIXED_ROWS, 1)
                aTop = .top + 3
                aLeft = .left + 5
            End With
        Case OID_ACCEPT_ALL:
            With m_sheet.Cells(C_FIXED_ROWS, 1)
                aTop = .top + 3
                aLeft = .left + 74 + 62
            End With
        Case OID_LAST_UPLOAD:
            With m_sheet.Cells(3, col)
                aTop = .top + 3
                aLeft = .left + 72
            End With
        Case OID_UPLOAD_ALL:
            With m_sheet.Cells(C_FIXED_ROWS, 1)
                aTop = .top + 3
                aLeft = .left + 75
            End With
        Case OID_ACCEPT:
            With m_sheet.Cells(4, col)
                aTop = .top + 3
                aLeft = .left + 120
            End With
        Case OID_DELETE:
            With m_sheet.Cells(2, col + 1)
                aTop = .top + 3
                aLeft = .left + .Width - 10 '+ 78
            End With
            aHeight = 8
            aWidth = 8
        Case OID_CURVE_NAME:
            With m_sheet.Cells(C_FIXED_ROWS, col)
                aTop = .top + 4
                aLeft = .left + 5
                'aWidth = 2 * .Width
            End With
    End Select
End Sub

Private Function GetColIndex(ByVal aUserData As String) As Long
    If aUserData <> vbNullString Then
        GetColIndex = Val(aUserData) + 1
    Else
        GetColIndex = -1
    End If
End Function

Private Sub m_Imager_OnMacro(sender As Object, ByVal aTarget As Integer, ByVal aUserData As String, aMacro As String)
 Dim idx As Long
 Dim curves() As String
 Dim cn As String
 
    curves = m_params.curves
    idx = GetColIndex(aUserData) - 1
    aMacro = vbNullString

    Select Case aTarget
        Case OID_DOWNLOAD_ALL:
            aMacro = MacroActionStr("MacroDownloadAllS")
        Case OID_ACCEPT_ALL:
            aMacro = MacroActionStr("MacroAcceptAll")
        Case OID_UPLOAD_ALL:
            aMacro = MacroActionStr("MacroUploadAllS")
        Case OID_EDIT_DATE:
            aMacro = MacroActionStr("MacroEditDateSettingsS")
        Case OID_CONTRACT:
            aMacro = MacroActionStr("MacroContractS")
        Case OID_CONTRACT_START_PLUS:
            aMacro = CCurveControl.OnPlusMinusAction(CURVE_UI_CONTRACTS_START_PLUS)
        Case OID_CONTRACT_START_MINUS:
            aMacro = CCurveControl.OnPlusMinusAction(CURVE_UI_CONTRACTS_START_MINUS)
        Case OID_CONTRACT_END_PLUS:
            aMacro = CCurveControl.OnPlusMinusAction(CURVE_UI_CONTRACTS_END_PLUS)
        Case OID_CONTRACT_END_MINUS:
            aMacro = CCurveControl.OnPlusMinusAction(CURVE_UI_CONTRACTS_END_MINUS)
        Case OID_SORT:
            If idx >= 0 Then cn = curves(idx)
            aMacro = MacroActionStr("MacroSortS", CURVE_GRP_NAME, cn, CDDXHelper.NewGUID())
        Case OID_VIEW_HISTORY:
            aMacro = MacroActionStr("MacroViewHistoryS", CURVE_GRP_NAME, curves(idx), CDDXHelper.NewGUID())
        Case OID_LAST_DOWNLOAD:
            aMacro = MacroActionStr("MacroDownloadS", CURVE_GRP_NAME, curves(idx), CDDXHelper.NewGUID())
        Case OID_LAST_UPLOAD:
            aMacro = MacroActionStr("MacroUploadS", CURVE_GRP_NAME, curves(idx), CDDXHelper.NewGUID())
        Case OID_ACCEPT:
            If CCurveControl.ShowAccept(idx) Then
                aMacro = MacroActionStr("MacroAccept", CURVE_GRP_NAME, curves(idx), CDDXHelper.NewGUID())
            End If
        Case OID_DELETE:
            aMacro = MacroActionStr("MacroDeleteS", CURVE_GRP_NAME, curves(idx), CDDXHelper.NewGUID())
    End Select
End Sub

Private Sub DrawTimes(ByVal aIndex As Long, ByVal aIsDownload As Boolean)
 Dim tv As Double
 Dim cl As Long
 
    If Not CCurveControl.GetAccessTimeToDraw(m_params, aIndex, aIsDownload, tv) Then Exit Sub
    cl = 2 * aIndex + 4
    Call CCurveControl.DrawAccessTime(m_sheet.Cells(3, cl), tv, aIsDownload, xlLeft)
    m_sheet.Cells(3, cl).IndentLevel = 1
End Sub

Private Sub GetContractDates(minDate As String, maxDate As String)
    minDate = vbNullString
    maxDate = vbNullString
    
    With m_dataRgn
        If .rows.count <= 1 Then Exit Sub
        minDate = .Cells(2, 1).text
        maxDate = .Cells(.rows.count, 1).text
    End With
End Sub

Private Sub m_Imager_OnText(sender As Object, ByVal aTarget As Integer, ByVal aUserData As String, aText As String, ByRef aBold As Boolean, ByRef aToolTip As String, ByRef aTop As Long, ByRef aLeft As Long)
 Dim col As Long
 Dim pos As Long
 Dim maxdte As String
 Dim mindte As String
 
    If IsNumeric(aUserData) Then
        pos = CLng(aUserData)
    End If
    col = 2 * GetColIndex(aUserData)
    
    aText = vbNullString
    aBold = False
    aToolTip = vbNullString
    
    Select Case aTarget
        Case OID_DOWNLOAD_ALL:
        Case OID_ACCEPT_ALL:
        Case OID_UPLOAD_ALL:
            'aText = "  Upload All"
        Case OID_EDIT_DATE:
            'aText = "  Edit Effective Date"
        Case OID_CONTRACT:
            'aText = "  Edit Contract Range"
        Case OID_VIEW_HISTORY:
            'aText = "  View History"
        Case OID_LAST_DOWNLOAD:
            'aText = "  Download" '+ du
            Call DrawTimes(pos, True)
        Case OID_LAST_UPLOAD:
            'aText = "  Upload" '+ du
            Call DrawTimes(pos, False)
        Case OID_ACCEPT:
'            Call DrawVR(pos)
        Case OID_CURVE_NAME:
'            aBold = True
'            aText = left(tmp(pos), 40)
            aToolTip = m_params.GetTooltipByPosition(pos)
            aTop = C_FIXED_ROWS
            aLeft = 2 * pos + 3
            
        Case OID_MIN_CONTRACT_DATE:
            Call GetContractDates(mindte, maxdte)
            aText = mindte
        Case OID_MAX_CONTRACT_DATE:
            Call GetContractDates(mindte, maxdte)
            aText = maxdte
    End Select
End Sub

Private Sub AddNewContracts(ByVal aPrior As Long, dispDates() As Double, ByVal length As Long)
 Dim rgn As range
 Dim mrgn As range
 
    With m_dataRgn
        Select Case aPrior
            Case -1:
                Set rgn = .offset(1).Resize(length)
                Call rgn.rows.Insert(shift:=xlShiftDown)
                
                If Is410() Then Set mrgn = rgn.offset(-length).Resize(length, 2)
            Case 1:
                Set rgn = .offset(.rows.count - length).Resize(length)
                Call rgn.rows.Insert(shift:=xlShiftDown)
                Call CCurveControl.Remove4EyesStyle(rgn.offset(-length))
                
                If Is410() Then Set mrgn = rgn.offset(-length).Resize(length, 2)
                
            Case 0:
                Set rgn = .offset(1).Resize(length)
                Call rgn.rows.Insert(shift:=xlShiftDown)
            Case -2:
                If .rows.count = 1 Then Exit Sub
                Set rgn = .offset(1).Resize(1)
                Call rgn.rows.Delete(shift:=xlShiftUp)
                Exit Sub
            Case 2:
                If .rows.count = 1 Then Exit Sub
                Set rgn = .offset(.rows.count).Resize(1)
                Call rgn.rows.Delete(shift:=xlShiftUp)
                Exit Sub
        End Select
    End With
    
    Set rgn = rgn.offset(-length).Resize(length)
    Call CCurveControl.SetDateVaules(m_params.granularities, rgn.Resize(, 1), dispDates)
    Call CCurveControl.SetSOCValueFormats(-1, rgn.offset(, 2).Resize(, rgn.Columns.count - 2), m_params)
    
    If Not mrgn Is Nothing Then
        With mrgn
            Call .Merge(True)
            .HorizontalAlignment = xlCenter
        End With
    End If
End Sub

Public Function IFNewContracts(ByVal aPrior As Long, ByVal op As Integer, dispDates() As Double) As Boolean
 Dim length As Long
 
    m_flags = m_flags And (Not CURVE_F_SUPPRESS_FINALIZE)
    If CCurveControl.IsEmptyDates(dispDates) Then Exit Function
    
    length = UBound(dispDates) - LBound(dispDates) + 1
    Set m_sheet = ActiveSheet
    Call m_params.FromXML(CCurveControl.GetCurveProperties(m_sheet))
    Call GetRanges
    Call InitImager
    
    Call AddNewContracts(aPrior, dispDates, length)

    Call GetRanges
    
    Call DrawContractDatesForMP
    
    If aPrior = -1 Then
        Call AddDataStyle(length, 1)
    ElseIf aPrior = 1 Then
        Call AddDataStyle(length, 3)
    ElseIf aPrior = 2 Then
        Call AddDataStyle(length, -2)
    Else
        Call AddDataStyle(length, -1)
    End If
End Function

Private Sub AddMD(ByVal oprDateIndex As Long)
    Call CCurveControl.ResetRangeColor(m_params, m_dataRgn, oprDateIndex)
    Call CCurveControl.PopulateInputs
End Sub

Private Sub DrawObjectAccept(ByVal aCurveName As String, ByVal aPos As Long)
    Call PrivateDrawVR(aPos)
    
    If m_params.Readonly(aPos) Then Exit Sub
    If Not CCPVRStorage.VRExists(m_sheet, aCurveName) Then Exit Sub
    
    If Not CCurveControl.ShowAccept(aPos) Then Exit Sub
    
    Call DrawIcon(OID_ACCEPT, aPos, aCurveName, AT_ACCEPT)
End Sub

Public Sub DrawVR(ByVal aIndex As Long)
    m_flags = m_flags Or CURVE_F_SUPPRESS_FINALIZE
    Call PrivateDrawVR(aIndex)
End Sub

Private Sub PrivateDrawVR(ByVal aIndex As Long)
    Call CCurveControl.DrawCurveVR(aIndex, CDbl(CCurveDates.ParamEntity.OprStartDate), C_FIXED_ROWS - 1, (aIndex + 2) * 2 - 1, xlLeft)
End Sub

Public Sub IFReLayout()
    m_flags = m_flags And (Not CURVE_F_SUPPRESS_FINALIZE)
    Call GetRanges
    Set m_Imager.sheet = m_sheet
    If m_params.granularities = 0 Then
        Call m_params.FromXML(CCurveControl.GetCurveProperties(m_sheet))
    End If
    
    Call CCurveControl.ClearImagesV1(m_dataRgn)
    
    Call AddStyle
    Call DrawObjects
End Sub

Private Function Is410() As Boolean
    If CCurveControl.IsUIUpToDate() Then Exit Function
    
    Is410 = Not m_sheet.Columns(2).EntireColumn.Hidden
End Function

Private Sub LockRange(ByVal curveIdx As Long, rdonly As Boolean)
 Dim r As Long
 Dim c As Long
   
    With m_dataRgn
        r = .rows.count - 1
        If r <= 0 Then Exit Sub
        
        c = 2 * curveIdx + 2
        .offset(1, c + 1).Resize(r, 1).Locked = rdonly
        .offset(1, c).Resize(r, 1).Locked = rdonly Or Not m_params.IsFlag(CURVE_FLG_EDIT_MRBD_COLUMN)
    End With
    
    'Call CCurveControl.Add4EyesStyle(m_dataRgn)
End Sub

Public Sub IFUpdatePermissions(permissions() As Long)
 Dim curves() As String
 Dim rdonly As Boolean
 Dim k As Long
 Dim imgl As Scripting.Dictionary
 
    m_flags = m_flags Or CURVE_F_SUPPRESS_FINALIZE
    
    Set m_sheet = ActiveSheet
    If m_Imager Is Nothing Then Set m_Imager = New CCurveImageText
    Set m_Imager.sheet = m_sheet
    Set m_params = CCurveDates.ParamEntity

    Call GetRanges
    
    curves = m_params.curves
    rdonly = Not CCurveControl.HasWriteableCurves(m_sheet, m_params, permissions)
    
    With m_Imager
        .AlternativeText = vbNullString

        If rdonly Then
            Call CCurveControl.DeleteCurveIconsByID(m_Imager, OID_ACCEPT_ALL, OID_UPLOAD_ALL, OID_CONTRACT, OID_CONTRACT_START_PLUS, OID_CONTRACT_START_MINUS, OID_CONTRACT_END_PLUS, OID_CONTRACT_END_MINUS)
        
        Else
            If .FindImage(OID_ACCEPT_ALL) Is Nothing Then Call CCurveControl.AddAcceptAll(m_Imager)
            
            If .FindImage(OID_UPLOAD_ALL) Is Nothing Then
                Call .Draw(OID_UPLOAD_ALL, vbNullString)
                Call .Draw(OID_CONTRACT, vbNullString)

                Call .Draw(OID_CONTRACT_START_PLUS, vbNullString)
                Call .Draw(OID_CONTRACT_START_MINUS, vbNullString)
                Call .Draw(OID_CONTRACT_END_PLUS, vbNullString)
                Call .Draw(OID_CONTRACT_END_MINUS, vbNullString)
            End If
        End If
    End With
    
    m_Imager.DeleteExsitingBeforeAdd = False
    
    For k = LBound(permissions) To UBound(permissions)
        If permissions(k) >= 0 Then
            rdonly = IIf(permissions(k) = 0, True, False)
            
            If rdonly Then
                If imgl Is Nothing Then
                    Set imgl = New Scripting.Dictionary
                    Call CCurveControl.DeleteCurveIconsByAlt(imgl, vbNullString)
                End If
                Call CCurveControl.DeleteCurveIconsByAlt(imgl, curves(k), AT_UPLOAD, AT_ACCEPT)
            Else
                Call DrawObjectUpload(curves(k), k)
                Call DrawObjectAccept(curves(k), k)
            End If

            Call LockRange(k, rdonly)
        End If
    Next
    
    With m_dataRgn
        If .rows.count > 1 Then
            Call CCurveControl.AddProtection(permissions, .Cells(2, 3).Resize(.rows.count - 1, .Columns.count - 2))
        End If
    End With
End Sub
Attribute VB_Name = "CCPFutureSingleEdit"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Option Base 0

Private m_sheet As Worksheet
Private WithEvents m_Imager As CCurveImageText
Attribute m_Imager.VB_VarHelpID = -1
Private m_params As New CCurveParams
Private m_dataRgn As range
Private m_HeaderRgn As range
Private m_flags As Long
'
Private Const C_FIXED_ROWS As Long = 6
'
Private Const OID_DOWNLOAD_ALL As Integer = 1
Private Const OID_UPLOAD_ALL As Integer = 2
Private Const OID_EDIT_DATE As Integer = 3
Private Const OID_CONTRACT As Integer = 4
Private Const OID_LAST_DOWNLOAD As Integer = 5
Private Const OID_LAST_UPLOAD As Integer = 6
Private Const OID_VIEW_HISTORY As Integer = 7
Private Const OID_DELETE As Integer = 8
Private Const OID_CURVE_NAME As Integer = 9
Private Const OID_SORT As Integer = 10
Private Const OID_CONTRACT_START_PLUS As Integer = 11
Private Const OID_CONTRACT_START_MINUS As Integer = 12
Private Const OID_CONTRACT_END_PLUS As Integer = 13
Private Const OID_CONTRACT_END_MINUS As Integer = 14
Private Const OID_MAX_CONTRACT_DATE As Integer = 15
Private Const OID_MIN_CONTRACT_DATE As Integer = 16
'

Private Sub GetRanges()
'    If m_params Is Nothing Then Exit Sub
    
    If m_sheet Is Nothing Then Set m_sheet = ActiveSheet
    Set m_dataRgn = CCurveControl.GetCurveRange(m_sheet)
    
    If Not m_dataRgn Is Nothing Then
        With m_dataRgn
            Set m_HeaderRgn = m_sheet.Cells(1, 1).Resize(.row - 1, .Columns.count)
        End With
    End If
End Sub

Private Sub AddStyle()
 Dim k As Long
 Dim f As Variant
 Dim b As Boolean
 Dim rgn As range
 Dim cols As Long
 Dim row As Long
 
    With m_HeaderRgn
        .offset(1).Resize(C_FIXED_ROWS - 1).Interior.color = RGB(255, 255, 255)
        .Cells(2, 2 + 1).Resize(, .Columns.count - 2).Interior.color = CURVE_ROW_HEADER_COLOR
        
        If .rows.count > C_FIXED_ROWS Then
            .offset(C_FIXED_ROWS).Resize(.rows.count - C_FIXED_ROWS).Interior.color = CURVE_ROW_HEADER_COLOR
            
'            If .rows.count >= 7 Then
'                Set rgn = .offset(C_FIXED_ROWS).Resize(2, 1)
'                rgn.MergeCells = True
'                'rgn.HorizontalAlignment = xlCenter
'                rgn.VerticalAlignment = xlCenter
'            End If
            
            .offset(C_FIXED_ROWS).Resize(.rows.count - C_FIXED_ROWS, 2).Interior.color = RGB(255, 255, 255)
        End If
    End With

    cols = m_HeaderRgn.Columns.count
    
    With m_HeaderRgn.offset(1).Resize(C_FIXED_ROWS - 1)
        .Borders(xlInsideHorizontal).LineStyle = xlContinuous
        .Borders(xlInsideHorizontal).Weight = xlHairline
        .Borders(xlInsideHorizontal).color = RGB(&HD9, &HD9, &HD9)
    End With
    
    With m_HeaderRgn.offset(1, 2).Resize(C_FIXED_ROWS - 1, cols - 2)
        .Borders(xlInsideVertical).LineStyle = xlContinuous
        .Borders(xlInsideVertical).Weight = IIf(k = 2 Or k = cols, xlThin, xlHairline)
        .Borders(xlInsideVertical).color = RGB(&HD9, &HD9, &HD9)
        
        .Borders(xlEdgeRight).LineStyle = xlContinuous
        .Borders(xlEdgeRight).Weight = xlThin
    End With
    
    For row = 6 To m_HeaderRgn.rows.count
        For k = 1 To cols
            With m_HeaderRgn.Cells(row, k)
 
                If k <> 1 Then
                    .Borders(xlEdgeTop).LineStyle = xlContinuous
                    .Borders(xlEdgeTop).Weight = xlHairline
                    .Borders(xlEdgeTop).color = RGB(&HD9, &HD9, &HD9)
                    
                    .Borders(xlEdgeBottom).LineStyle = xlContinuous
                    .Borders(xlEdgeBottom).Weight = xlHairline
                    .Borders(xlEdgeBottom).color = RGB(&HD9, &HD9, &HD9)
                End If

                .Borders(xlEdgeRight).LineStyle = xlContinuous
                .Borders(xlEdgeRight).Weight = IIf(k = cols, xlThin, xlHairline)
                If k <> cols Then
                    .Borders(xlEdgeRight).color = RGB(&HD9, &HD9, &HD9)
                End If

            End With
        Next
    Next
    
    row = m_HeaderRgn.rows.count
    With m_HeaderRgn.rows(row)
        .Borders(xlEdgeBottom).LineStyle = xlContinuous
        .Borders(xlEdgeBottom).Weight = xlThin
    End With
    
    With m_dataRgn
        .Cells(1, 1).RowHeight = 34
    
        With .rows(1)
            .HorizontalAlignment = xlCenter
            .VerticalAlignment = xlCenter
'            .WrapText = False
            .Orientation = 0
            .AddIndent = False
            .IndentLevel = 0
            .ShrinkToFit = False
            .ReadingOrder = xlContext
            .MergeCells = False
        End With
        
        Call SetDateAreaAlignment(.Cells(1, 1).Resize(, 2))
        
        For Each f In .Columns
            f.ColumnWidth = IIf(f.column <= 2, 18 * 2, 32)
        Next
        
    End With
    
    m_sheet.Columns(2).EntireColumn.Hidden = True
    
    Call AddDataStyle(-1, -1)
End Sub

Private Sub SetDateAreaAlignment(rgn As range)
    With rgn
        .HorizontalAlignment = xlRight
        .IndentLevel = 3
    End With
End Sub

Private Sub AddDataStyle(ByVal dayCount As Long, ByVal op As Integer)
 Dim k As Long
 Dim f As Variant
 Dim b As Boolean
 Dim rgn As range
 Dim cols As Long
 Dim row As Long
    
    With m_dataRgn

        If op = -2 Then
            With .offset(.rows.count - 1).Resize(1)
                .Borders(xlEdgeBottom).color = RGB(210, 210, 210)
            End With
        ElseIf op = -1 Then
'            For Each f In .Columns
'                If f.Column > 1 Then
'                    With f
'                        'b = (f.Column = 2 Or f.Column = .Columns.count)
'                        '.Borders(xlEdgeRight).LineStyle = IIf(b, XlLineStyle.xlLineStyleNone, xlContinuous)
'                        .Borders(xlEdgeRight).Weight = xlHairline
'                    End With
'                End If
'            Next
    
            .offset(, 1).Resize(, .Columns.count - 1).Borders(xlInsideVertical).Weight = xlHairline
    
            If .rows.count > 1 Then
                Call SetDateAreaAlignment(.offset(1).Resize(.rows.count - 1, 2))
            End If
    
            .Borders(xlEdgeRight).LineStyle = xlContinuous
            .Borders(xlEdgeRight).Weight = xlThin
    
'            For Each f In .rows
'                With f
                    .Borders(xlInsideHorizontal).LineStyle = xlContinuous
                    .Borders(xlInsideHorizontal).Weight = xlThin
                    .Borders(xlInsideHorizontal).color = RGB(210, 210, 210)
'                End With
'            Next
            .Borders(xlEdgeBottom).color = RGB(210, 210, 210)
    
        ElseIf op = 3 Or op = 1 Then
        
'            For k = 3 To .Columns.count
'                With .offSet(IIf(op = 3, .rows.count - dayCount, dayCount), k - 1).Resize(dayCount, 1)
'                    .Borders(xlEdgeRight).Weight = xlHairline
'                End With
'            Next
            
            With .offset(IIf(op = 3, .rows.count - dayCount, 1)).Resize(dayCount)
                .Borders(xlInsideVertical).Weight = xlHairline
            End With
            
'            For k = IIf(op = 3, .rows.count - dayCount, 1) To IIf(op = 3, .rows.count - 1, dayCount)
'                With .offset(k).Resize(1, 2)
'                    Call .Merge
'                    .HorizontalAlignment = xlCenter
'                End With
'
'            Next
     
            .Borders(xlEdgeRight).LineStyle = xlContinuous
            .Borders(xlEdgeRight).Weight = xlThin
            
'            For k = IIf(op = 3, .rows.count - dayCount - 1, 1) To IIf(op = 3, .rows.count - 1, dayCount)
'
'                With .offSet(k).Resize(1)
'                    .Borders(xlEdgeBottom).color = rgb(210, 210, 210)
'                End With
'            Next
            
            With .offset(IIf(op = 3, .rows.count - dayCount, 1)).Resize(dayCount)
                .Borders(xlInsideHorizontal).color = RGB(210, 210, 210)
                .Borders(xlEdgeBottom).color = RGB(210, 210, 210)
            End With
            
        End If
    
    
''        If m_params.rowCount > 1 Then
''             .Cells(2, 1).Resize(m_params.rowCount - 1, 1).Columns(1).Interior.color = BSConsts.CURVE_ROW_HEADER_COLOR
''        End If
''
''        .Interior.color = BSConsts.CURVE_ROW_HEADER_COLOR
''        '.Font.color = rgb(50, 50, 50)
''        .VerticalAlignment = xlCenter
''        '.HorizontalAlignment = xlCenter
''
''        If .rows.count > 1 Then
''             .offset(1).Resize(m_dataRgn.rows.count - 1, 2).Interior.color = BSConsts.CURVE_COLUMN_HEADER_COLOR
''        End If
''
''        If .rows.count > 1 Then
''            With .offset(1, 1).Resize(.rows.count - 1, .Columns.count - 1)
''                .FormatConditions.Delete
''
''                .FormatConditions.Add Type:=xlExpression, Formula1:="=Mod(Row(),2)=0"
''                .FormatConditions(1).Interior.color = CURVE_ROW_ALTERNATING_COLOR_2
''                .FormatConditions.Add Type:=xlExpression, Formula1:="=Mod(Row(),2)<>0"
''                .FormatConditions(2).Interior.color = CURVE_ROW_ALTERNATING_COLOR_1
''
''            End With
''        End If
''
''        If .rows.count > 1 Then
''            For k = 3 To .Columns.count
''                If m_params.Readonly(k - 3) Then
''                 .offset(1, k - 1).Resize(.rows.count - 1, 1).Interior.color = BSConsts.CURVE_COLUMN_HEADER_COLOR2
''                End If
''            Next
''
''        End If
    End With
End Sub

Private Sub InitImager()
    With m_Imager
        Set .sheet = m_sheet
'        Set .ZEComp = m_ZEComp
    End With
End Sub

Public Function IFDelete(sht As Worksheet, ByVal aGroupName As String, ByVal aCurveName As String)
 Dim idx As Long

    m_flags = m_flags And (Not CURVE_F_SUPPRESS_FINALIZE)
    Set m_sheet = sht
    Set m_Imager.sheet = m_sheet
    
    Set m_params = CCurveDates.ParamEntity
    Call GetRanges
    
    idx = m_params.GetCurvePosition(aCurveName)
    If idx < 0 Then Exit Function
    IFDelete = True
    
    Call m_sheet.Columns(idx + 3).Delete(xlShiftToLeft)
    
    Call CCurveControl.DeleteCurveIcons(aCurveName, AT_HISTORY, AT_SORT, AT_DELETE, AT_DOWNLOAD, AT_UPLOAD, AT_ACCEPT, AT_NAME)
    
    'strange in Excel ?
    With m_params
        Call .RemoveCurve(idx)
        .ColumnCount = .ColumnCount - 1
    End With
    
    Call CCurveControl.SaveCurveProperties(m_sheet, m_params)
    
    If m_params.GetCurveCount() > 0 Then
        Call GetRanges
        
        If m_params.AllCurvesRD() Then
            Call CCurveControl.DeleteCurveIconsByID(m_Imager, OID_ACCEPT_ALL, OID_UPLOAD_ALL, OID_CONTRACT, OID_DELETE, OID_CONTRACT_START_PLUS, OID_CONTRACT_START_MINUS, OID_CONTRACT_END_PLUS, OID_CONTRACT_END_MINUS, OID_MAX_CONTRACT_DATE, OID_MIN_CONTRACT_DATE)
        End If
        
        Call CCurveControl.DeleteProperties(m_HeaderRgn, C_FIXED_ROWS)
    Else
        Call OnDeletion
    End If
End Function

Private Sub OnDeletion()
 Dim p As CustomProperty
 Dim shp As Shape
 
    m_sheet.Cells.Delete
    For Each shp In m_sheet.Shapes
        shp.Delete
    Next
    
    For Each p In m_sheet.CustomProperties
        p.Delete
    Next
    
'    Call RemoveMD(-1)
End Sub

Public Function IFNew(data As ZEWSProxy.ICurveResult, ud As CCurveUserData) As Boolean
 Dim isnew As Boolean
 
    m_flags = m_flags And (Not CURVE_F_SUPPRESS_FINALIZE)
    Call m_params.FromXML(data.value)
    
    Set m_sheet = CCurveControl.GetSheet(m_params, True, isnew)
    If m_sheet Is Nothing Then Exit Function ' failed to find the workbook
    
    If Not isnew Then
        Call CCurveControl.AdjustPropNDataAreas(m_params, 6)
    End If
    Call CCurveDates.AssignTargetSheet(m_sheet)
    Set CCurveDates.ParamEntity = m_params
 
    Call CCurveControl.SaveCurveProperties(m_sheet, m_params)
    'Call GetRanges
    Call InitImager

    Call CDDXCurve.SetFindCriterion(BSConsts.DDX_PID, m_sheet, ud.Criterion)
    
    Call DrawHeader
    Call DrawProperties
    m_dataRgn.Font.ColorIndex = 1
    Call ReadFromFile(-1)

    Call AddStyle
    Call DrawObjects
    
    Call AddMD(-1)
    
    IFNew = True
End Function

Public Function IFRefresh(data As ZEWSProxy.ICurveResult) As Boolean
 Dim oldParams As CCurveParams
 
    m_flags = m_flags And (Not CURVE_F_SUPPRESS_FINALIZE)
    Set m_sheet = ActiveSheet
    Call m_params.FromXML(data.value)
    
    Call CCurveControl.ClearAllImages(m_sheet)
    Call CCurveControl.AdjustPropNDataAreas(m_params, 6)
    
    Set oldParams = New CCurveParams
    
    With oldParams
        Call .FromXML(CCurveControl.GetCurveProperties(m_sheet))
    End With
    
    m_params.LastUploadTime = oldParams.LastUploadTime
    Call CCurveControl.SaveCurveProperties(m_sheet, m_params)

    Call GetRanges

    Call InitImager
    
    Call DrawHeader
    Call DrawProperties
    
    m_dataRgn.Font.ColorIndex = 1
    Call ReadFromFile(-1)
    
    Call AddStyle
    Call DrawObjects
 
    Call AddMD(-1)
    
    IFRefresh = True
End Function

Private Sub RefreshVROnUpload(ByVal cvrIdx As Long, ByVal doSummary As Boolean, ByVal readComments As Boolean)
 Dim rgn As range
 Dim cvrnms() As String
    
    Set rgn = m_dataRgn.offset(1, 2 + IIf(cvrIdx >= 0, cvrIdx, 0)).Resize(m_dataRgn.rows.count - 1, IIf(cvrIdx >= 0, 1, m_dataRgn.Columns.count - 2))
    
    If CDDXCurve.FourEyesActive Then
        If readComments Then Call CCurveControl.RefreshCommentsAfterUploaded(rgn, False)
        
    Else
        If doSummary Then
            Call CCurveControl.VRColorValues(vbNullString, rgn, m_params, True)
        End If
        
        Call CCurveControl.EraseAccepts(m_Imager, cvrIdx)
        cvrnms = m_params.curves
        
        If cvrIdx >= 0 Then
            Call DrawObjectAccept(cvrnms(cvrIdx), cvrIdx)
        Else
            For cvrIdx = LBound(cvrnms) To UBound(cvrnms)
                Call DrawObjectAccept(cvrnms(cvrIdx), cvrIdx)
            Next
        End If
    End If
End Sub

Public Function IFUpload(data As ZEWSProxy.ICurveResult, ByVal curvePos As Long) As Boolean
 Dim k As Long
 Dim curveIdx() As Long
 Dim count As Long

    m_flags = m_flags And (Not CURVE_F_SUPPRESS_FINALIZE)
    Set m_sheet = ActiveSheet
    Call m_params.FromXML(CCurveControl.GetCurveProperties(m_sheet))
    Call GetRanges
    
    curveIdx = CCurveControl.GetUploadedItms(m_params, m_sheet, data, True, count)
    If count > 0 Then
        Call CCurveControl.SaveCurveProperties(m_sheet, m_params)
    
        For k = LBound(curveIdx) To UBound(curveIdx)
            Call DrawTimes(curveIdx(k), False)
        Next
    End If
    
    Call RefreshVROnUpload(curvePos - 1, True, True)
    Call CDDXCurve.NotifyCurveUploadResult(DDX_PID, data, m_params)
    
    IFUpload = True
End Function

Public Function IFRefreshIndividual(data As ZEWSProxy.ICurveResult, ByVal RefreshTarget As Integer) As Boolean
 Dim p As New CCurveParams
 Dim index As Long
 Dim curves() As String
 Dim downloadtimes() As String
 Dim target As String
 Dim newtime As String
 
    m_flags = m_flags And (Not CURVE_F_SUPPRESS_FINALIZE)
    Call p.FromXML(data.value)
    
    Set m_sheet = ActiveSheet
    
    With p
        curves = .curves
        target = curves(LBound(curves))
        downloadtimes = .LastDownloadTime()
        newtime = downloadtimes(LBound(downloadtimes))
    End With
    Set p = Nothing
    
    Set m_params = CCurveDates.ParamEntity
    
    With m_params
'        Call .FromXML(CCurveControl.GetCurveProperties(m_sheet))
            
        Call GetRanges

        curves = .curves
        downloadtimes = .LastDownloadTime
        For index = LBound(curves) To UBound(curves)
            If curves(index) = target Then
                downloadtimes(index) = newtime
                .LastDownloadTime = downloadtimes
                Exit For
            End If
        Next
        If index > UBound(curves) Then Exit Function
    End With
    
    Call InitImager
'    Call DrawObjectDownload(target, index)
    Call DrawTimes(index, True)
    Call ReadFromFile(index)
    
    Call CCurveControl.SaveCurveProperties(m_sheet, m_params)
    
    Call AddMD(index)
    
    Call GetRanges
    Call RefreshVROnUpload(index, False, False)
    
    IFRefreshIndividual = True
End Function

Private Sub DrawHeader()
 Dim wr As range
 Dim f As Variant

    Call CCurveControl.SetSplits(m_sheet, m_params.PropertyCount + C_FIXED_ROWS + 1, 2)
    Call GetRanges
    
    Call CCurveControl.InsertTitle(m_sheet)
        
' set header info
    With m_HeaderRgn
        .Cells(1, 1).RowHeight = 40
        For f = 2 To .rows.count
             .Cells(f, 1).RowHeight = 18
        Next
        
        m_sheet.rows(1).Interior.color = RGB(&H0, &H52, &H93)
        
        With .rows(1)
            .Borders(xlEdgeBottom).LineStyle = xlContinuous
            .Borders(xlEdgeBottom).Weight = xlThick
            '.Borders(xlEdgeBottom).ColorIndex = 10
            .Borders(xlEdgeBottom).color = RGB(&H5E, &HB6, &HE4)
        End With
        
        With .Cells(.rows.count + 1, 1).Resize(1, .Columns.count)
            .Borders(xlEdgeTop).LineStyle = xlContinuous
            .Borders(xlEdgeTop).Weight = xlHairline
        End With
    End With
End Sub

Private Sub DrawProperties()
 Dim k As Long
 Dim j As Long
 Dim Values() As String
 Dim cvs() As String
 Dim row As Long
 Dim col As Long
 
    With m_params
        Values = .PropertyNames
        If Len(Join(Values)) = 0 Then Exit Sub
        
        m_HeaderRgn.Cells((C_FIXED_ROWS + 1), 1).Resize(UBound(Values) - LBound(Values) + 1).value = vbNullString
        
'        With m_HeaderRgn.Cells((C_FIXED_ROWS + 1), 1)
'            .value = "  Property"
'            .Characters.Font.Bold = True
'            .Characters.Font.SIZE = 9
'        End With
                
        For k = LBound(Values) To UBound(Values)
            With m_HeaderRgn.Cells(k + (C_FIXED_ROWS + 1), 1)
                .value = CCurveControl.AddApostrophe(Values(k)) + " "
                .Characters.Font.size = 8
                .HorizontalAlignment = xlRight
                .VerticalAlignment = xlCenter
            End With
        Next
        
        cvs = .curves
        For k = LBound(cvs) To UBound(cvs)
            Values = .PropertyValues(cvs(k))
            
            For j = LBound(Values) To UBound(Values)
                row = C_FIXED_ROWS + j + 1
                col = k + 1 + 2
                With m_HeaderRgn.Cells(row, col)
                    .value = CCurveControl.AddApostrophe(Values(j))
                    .Characters.Font.size = 8
                    .Characters.Font.Bold = False
                    .HorizontalAlignment = xlLeft
                    .VerticalAlignment = xlCenter
                End With
            Next
        Next
    End With
End Sub

Private Sub DrawIcon(ByVal aObjectID As Integer, ByVal aPos As Long, ByVal aCurveName As String, ByVal aAlternativeText As String)
    With m_Imager
        .AlternativeText = CCurveControl.GetAltText(aCurveName, aAlternativeText)
        Call .Draw(aObjectID, CStr(aPos))
    End With
End Sub

Private Sub DrawObjectAccept(ByVal aCurveName As String, ByVal aPos As Long)
    Call PrivateDrawVR(aPos)
    
    If m_params.Readonly(aPos) Then Exit Sub
    
    If Not CCPVRStorage.VRExists(m_sheet, aCurveName) Then Exit Sub
    If Not CCurveControl.ShowAccept(aPos) Then Exit Sub
    
    Call DrawIcon(OID_ACCEPT, aPos, aCurveName, AT_ACCEPT)
End Sub

Private Sub DrawObjectDownload(ByVal aCurveName As String, ByVal aPos As Long)
    Call DrawIcon(OID_LAST_DOWNLOAD, aPos, aCurveName, AT_DOWNLOAD)
End Sub

Private Sub DrawObjectUpload(ByVal aCurveName As String, ByVal aPos As Long)
    Call DrawIcon(OID_LAST_UPLOAD, aPos, aCurveName, AT_UPLOAD)
End Sub

Private Sub DrawDateRange()
 Dim rgn As range
 
    If m_params.IsFlag(CURVE_FLG_EDIT_DATES) Then
        Call CCurveControl.DrawChangableDateRange(m_sheet, m_params.OprStartDate, 1, False)
        
        With m_sheet.Cells(2, 2)
            If .HasFormula And Len(.Formula) <> 0 Then
                m_sheet.Cells(3, 1).Formula = .Formula
                .Formula = vbNullString
                .Value2 = vbNullString
            ElseIf IsNumeric(.Value2) And .Value2 <> vbNullString Then
                m_sheet.Cells(3, 1) = .Value2
                m_sheet.Cells(3, 1).NumberFormat = CDDXDates.SystemDateFormat
                .Value2 = vbNullString
            End If
        End With
        
        Set rgn = m_sheet.Cells(3, 1)
        If Not rgn.HasFormula Then
            If Not CCurveControl.PreserveFormulas Then
                With rgn
                    .NumberFormat = CDDXDates.SystemDateFormat
                    .value = m_params.OprStartDate
                End With
            End If
        End If
    Else
        Call CCurveControl.DrawStyledTexts(m_sheet, 2, 1, "Effective Date:  ", format(m_params.OprStartDate, CDDXDates.SystemDateFormat))
    End If
End Sub

Private Sub DrawInterval()
 Dim dtz As Boolean
 
    dtz = CCurveGranularity.IsGranularity(m_params.granularities, CURVE_GRANULARITY_HOURLY) Or CCurveGranularity.IsGranularity(m_params.granularities, CURVE_GRANULARITY_MINUTELY)
    dtz = IIf(dtz And Len(m_params.TZName) <> 0 And (m_params.IsFlag(CURVE_FLG_DST_ADJUST_START) Or m_params.IsFlag(CURVE_FLG_DST_ADJUST_END)), True, False)
    Call CCurveControl.DrawStyledTexts(m_sheet, IIf(m_params.IsFlag(CURVE_FLG_EDIT_DATES), 4, 3), 1, " Interval:  ", CCurveGranularity.GetGranularityName(m_params.granularities), IIf(dtz, "   (" + m_params.TZName + ")", vbNullString))
End Sub

Private Sub DrawContractDatesForMP()
    With m_Imager
        Call .Draw(OID_MAX_CONTRACT_DATE, vbNullString)
        Call .Draw(OID_MIN_CONTRACT_DATE, vbNullString) '
    End With
End Sub

Private Sub DrawObjects()
 Dim k As Long
 Dim curves() As String

    Call DrawDateRange
    Call DrawInterval
    
    With m_Imager
        .AlternativeText = vbNullString
        
        Call .Draw(OID_DOWNLOAD_ALL, vbNullString)
        Call .Draw(OID_EDIT_DATE, vbNullString)
        If Not m_params.AllCurvesRD() Then
            Call CCurveControl.AddAcceptAll(m_Imager)

            Call .Draw(OID_UPLOAD_ALL, vbNullString) '
            If Not m_params.IsFlag(CURVE_FLG_EDIT_DATES) Then Call .Draw(OID_SORT, vbNullString)
            Call .Draw(OID_CONTRACT, vbNullString)
            Call DrawContractDatesForMP

            Call .Draw(OID_CONTRACT_START_PLUS, vbNullString)
            Call .Draw(OID_CONTRACT_START_MINUS, vbNullString)
            Call .Draw(OID_CONTRACT_END_PLUS, vbNullString)
            Call .Draw(OID_CONTRACT_END_MINUS, vbNullString)
        End If

    End With

    curves = m_params.curves
    For k = LBound(m_params.curves) To UBound(m_params.curves)
        Call DrawIcon(OID_VIEW_HISTORY, k, curves(k), AT_HISTORY)
        
        Call DrawObjectDownload(curves(k), k)
        If Not m_params.Readonly(k) Then
            Call DrawObjectUpload(curves(k), k)
            If Not m_params.IsFlag(CURVE_FLG_EDIT_DATES) Then Call DrawIcon(OID_SORT, k, curves(k), AT_SORT)
        End If
        
        Call DrawIcon(OID_DELETE, k, curves(k), AT_DELETE)
        
        Call DrawCurveName(k, curves(k))
        Call DrawIcon(OID_CURVE_NAME, k, curves(k), AT_NAME)
        Call DrawObjectAccept(curves(k), k)
    Next
End Sub

Private Sub DrawCurveName(ByVal aPos As Long, ByVal aCurveName As String)
    If aPos = 0 Then
        With m_HeaderRgn.Cells(C_FIXED_ROWS, 3).Resize(1, m_HeaderRgn.Columns.count - 2)
            .Characters.Font.Bold = True
            .Characters.Font.size = 8
            '
            .HorizontalAlignment = xlLeft 'xlFill '
    '        .WrapText = True
            .VerticalAlignment = xlCenter
    '        .WrapText = False
            .Orientation = 0
            .AddIndent = False
            .IndentLevel = 0
            .ShrinkToFit = False
            .ReadingOrder = xlContext
            .NumberFormat = "@"
        End With
    End If
    
    aPos = aPos + 3
    
    With m_HeaderRgn.Cells(C_FIXED_ROWS, aPos)
'        .Characters.Font.Bold = True
'        .Characters.Font.size = 8
'        '
'        .HorizontalAlignment = xlLeft 'xlFill '
''        .WrapText = True
'        .VerticalAlignment = xlCenter
''        .WrapText = False
'        .Orientation = 0
'        .AddIndent = False
'        .IndentLevel = 0
'        .ShrinkToFit = False
'        .ReadingOrder = xlContext
'        .NumberFormat = "@"
        .value = CCurveControl.AddApostrophe(aCurveName)
    End With
End Sub

Private Sub ReadFromFile(ByVal aCurveIndex As Long)
    With m_dataRgn
        If aCurveIndex < 0 Then
            Call CCurveControl.ReadFile(aCurveIndex, .Resize(, 1), .offset(, 2).Resize(, .Columns.count - 2), m_params)
        Else
            Call CCurveControl.ReadFile(aCurveIndex, Nothing, .offset(, 2 + aCurveIndex).Resize(, 1), m_params)
        End If
    End With
    
    Call GetRanges
    Call ReferenceOprDate
End Sub

Private Sub Class_Initialize()
    Set m_Imager = New CCurveImageText
End Sub

Private Sub Class_Terminate()
    Call ProtectSheet
    Set m_Imager = Nothing
End Sub

Private Sub SetDataRgnFormat()
 Dim spltrows As Long
 Dim spltcols As Long
 Dim rgn As range
 
    On Local Error Resume Next
    
    Call CCurveControl.GetSplits(m_sheet, m_params, spltrows, spltcols)
    
    With m_dataRgn
        If .rows.count <= 1 Or spltcols >= .Columns.count Then Exit Sub
        
        Set rgn = .offset(1, spltcols).Resize(.rows.count - 1, .Columns.count - spltcols)
'        rgn.NumberFormat = "General"
        rgn.HorizontalAlignment = xlRight
    End With
End Sub

Private Sub ProtectSheet()
 Dim r As Long
 Dim k As Long
 Dim splitrow As Long
 Dim splitcol As Long
 Dim startp As Long
 
    If CDDXHelper.IsFlag(m_flags, CURVE_F_SUPPRESS_FINALIZE) Then Exit Sub
    
    If m_params.GetCurveCount() <= 0 Then
        Call CCurveControl.Unprotect(m_sheet)
        Exit Sub
    End If

    If m_sheet Is Nothing Then Exit Sub
    If m_sheet.ProtectContents Then Exit Sub
    
    m_sheet.UsedRange.Cells.Locked = True
    
    Call CCurveControl.GetSplits(m_sheet, m_params, splitrow, splitcol)
    
    Call LockOprDate(m_params.AllCurvesRD())
    
    If Not m_dataRgn Is Nothing Then
        With m_dataRgn
            r = .rows.count - 1
    
            If r > 0 Then
'                For k = LBound(m_params.curves) To UBound(m_params.curves)
'                    If Not m_params.Readonly(k) Then
'                        .offset(1, k + splitcol).Resize(r, 1).Locked = False
'                    End If
'                Next
                
                startp = -1
                For k = LBound(m_params.curves) To UBound(m_params.curves)
                    If m_params.Readonly(k) Then
                        If startp >= 0 Then
                            .Cells(2, splitcol + startp + 1).Resize(r, k - startp).Locked = False
                        End If
                        startp = -1
                    Else
                        If startp = -1 Then startp = k
                        If k = UBound(m_params.curves) Then
                            .Cells(2, splitcol + startp + 1).Resize(r, k - startp + 1).Locked = False
                        End If
                    End If
                Next
                
                With .offset(1).Resize(r, splitcol)
                    .Locked = m_params.AllCurvesRD() Or Not m_params.IsFlag(CURVE_FLG_EDIT_DATES)
                    .NumberFormat = CDDXCurve.GetContractDateFormat(m_params.granularities)
                End With
            End If
        End With
        
        Call SetDataRgnFormat
        Call CCurveControl.Add4EyesStyle(m_dataRgn)
    End If
    
    Call CCurveControl.Protect(m_sheet)
End Sub

Private Sub m_Imager_OnImage(sender As Object, ByVal aTarget As Integer, ByVal aUserData As String, aPicturePath As String, ByRef aWidth As Single, ByRef aHeight As Single)
    aPicturePath = vbNullString
    aWidth = 95
    aHeight = 18
    
    Select Case aTarget
        Case OID_EDIT_DATE:
            aWidth = 140
            aPicturePath = "CurveEditSettings.png" '"CurveEditDate.png"
        Case OID_CONTRACT:
            aWidth = 140
            aPicturePath = "CurveContract.png"
        Case OID_LAST_DOWNLOAD:
            aWidth = 110
            aPicturePath = "CurveLastDownload.png"
        Case OID_DOWNLOAD_ALL:
            aWidth = 100
            aPicturePath = "CurveDownloadAll.png"
        Case OID_ACCEPT_ALL:
            aWidth = 100
            aPicturePath = "CurveAcceptAll.png"
        Case OID_LAST_UPLOAD:
            aWidth = 110
            aPicturePath = "CurveLastUpload.png"
        Case OID_ACCEPT:
            aWidth = 100
            aPicturePath = "CurveAccept.png"
        Case OID_UPLOAD_ALL:
            aWidth = 100
            aPicturePath = "CurveUploadAll.png"
        Case OID_VIEW_HISTORY:
            aWidth = 110
            aPicturePath = "CurveViewHistory.png"
        Case OID_DELETE:
            aPicturePath = "CurveDelete.png"
        Case OID_SORT:
            If Not m_params.IsFlag(CURVE_FLG_EDIT_DATES) Then aPicturePath = IIf(aUserData = vbNullString, "filter.png", "filter.png")
        Case OID_CURVE_NAME:
            aWidth = 0 '
            aHeight = 0 '
        Case OID_CONTRACT_START_PLUS, OID_CONTRACT_END_PLUS:
            aPicturePath = "CurvePlus.png"
        Case OID_CONTRACT_START_MINUS, OID_CONTRACT_END_MINUS:
            aPicturePath = "CurveMinus.png"
        Case OID_MIN_CONTRACT_DATE, OID_MAX_CONTRACT_DATE:
            aWidth = 68
            aHeight = 16
    End Select
End Sub

Private Sub m_Imager_OnImageBackColor(sender As Object, ByVal aTarget As Integer, bkColor As Long)
    Select Case aTarget
        Case OID_MIN_CONTRACT_DATE, OID_MAX_CONTRACT_DATE:
            'bkColor = m_Sheet.Cells(BSConsts.CURVE_SINGLE_START_ROW, 1).Interior.color
            bkColor = xlNone 'm_dataRgn.Cells(1, 1).Interior.color
        Case Else:
            bkColor = RGB(255, 255, 255) 'BSConsts.CURVE_ROW_HEADER_COLOR
    End Select
End Sub

Private Sub m_Imager_OnImagePlacement(sender As Object, ByVal aTarget As Integer, ByVal aUserData As String, aTop As Single, aLeft As Single, aWidth As Single, aHeight As Single)
 Dim col As Long
 Dim t1 As Variant
 
    t1 = 23
    col = GetColIndex(aUserData) + 2
    aWidth = -1
    aHeight = -1
    
    Select Case aTarget
        Case OID_EDIT_DATE:
            With m_sheet.Cells(C_FIXED_ROWS - 1, 1)
                aTop = .top + 3
                aLeft = .left + 5
            End With
        Case OID_CONTRACT:
            With m_dataRgn.Cells(1, 1)
                .value = " "
                aTop = .top + 6
                aLeft = .left + 5
            End With
            
        Case OID_CONTRACT_START_PLUS:
            With m_dataRgn.Cells(1, 1)
                aTop = .top + t1
                aLeft = .left + 6
            End With
        Case OID_CONTRACT_START_MINUS:
            With m_dataRgn.Cells(1, 1)
                aTop = .top + t1
                aLeft = .left + 16
            End With
        Case OID_CONTRACT_END_PLUS:
            With m_dataRgn.Cells(1, 1)
                aTop = .top + t1
                aLeft = .left + .Width / 2 - 10
            End With
        Case OID_CONTRACT_END_MINUS:
            With m_dataRgn.Cells(1, 1)
                aTop = .top + t1
                aLeft = .left + .Width / 2 - 20
            End With
           
        Case OID_MIN_CONTRACT_DATE:
            With m_dataRgn.Cells(1, 1)
                aTop = .top + t1 - 1
                aLeft = .left + 26
            End With
        Case OID_MAX_CONTRACT_DATE:
            With m_dataRgn.Cells(1, 2)
                aTop = .top + t1 - 1
                aLeft = .left + 20
            End With
            
        Case OID_SORT:
            If Not m_params.IsFlag(CURVE_FLG_EDIT_DATES) Then
                With m_dataRgn.Cells(1, IIf(aUserData = vbNullString, 2, col))
                    aTop = .top + 11
                    aLeft = .left + .Width - IIf(aUserData = vbNullString, 14, 14)
                End With
            End If
        Case OID_VIEW_HISTORY:
            With m_sheet.Cells(2, col)
                aTop = .top + 4
                aLeft = .left + 5
            End With
        Case OID_LAST_DOWNLOAD:
            With m_sheet.Cells(3, col)
                aTop = .top + 3
                aLeft = .left + 5
            End With
        Case OID_DOWNLOAD_ALL:
            With m_sheet.Cells(C_FIXED_ROWS, 1)
                aTop = .top + 3
                aLeft = .left + 5
            End With
        Case OID_ACCEPT_ALL:
            With m_sheet.Cells(C_FIXED_ROWS, 1)
                aTop = .top + 3
                aLeft = .left + 74 + 62
            End With
        Case OID_LAST_UPLOAD:
            With m_sheet.Cells(3, col)
                aTop = .top + 3
                aLeft = .left + 73
            End With
        Case OID_ACCEPT:
            With m_sheet.Cells(5, col)
                aTop = .top + 3
                aLeft = .left + .Width / 2 + 30
            End With
        Case OID_UPLOAD_ALL:
            With m_sheet.Cells(C_FIXED_ROWS, 1)
                aTop = .top + 3
                aLeft = .left + 74
            End With
        Case OID_DELETE:
            With m_sheet.Cells(2, col)
                aTop = .top + 3
                aLeft = .left + .Width - 10 '+ 78
            End With
            aHeight = 8
            aWidth = 8
        Case OID_CURVE_NAME:
            With m_sheet.Cells(C_FIXED_ROWS, col)
                aTop = .top + 4
                aLeft = .left + 5
                'aWidth = 2 * .Width
            End With
    End Select
End Sub

Private Function GetColIndex(ByVal aUserData As String) As Long
    If aUserData <> vbNullString Then
        GetColIndex = Val(aUserData) + 1
    Else
        GetColIndex = -1
    End If
End Function

Private Sub m_Imager_OnMacro(sender As Object, ByVal aTarget As Integer, ByVal aUserData As String, aMacro As String)
 Dim idx As Integer
 Dim curves() As String
 Dim cn As String
 
    curves = m_params.curves
    idx = GetColIndex(aUserData) - 1
    aMacro = vbNullString

    Select Case aTarget
        Case OID_DOWNLOAD_ALL:
            aMacro = MacroActionStr("MacroDownloadAllS")
        Case OID_ACCEPT_ALL:
            aMacro = MacroActionStr("MacroAcceptAll")
        Case OID_UPLOAD_ALL:
            aMacro = MacroActionStr("MacroUploadAllS")
        Case OID_EDIT_DATE:
            aMacro = MacroActionStr("MacroEditDateSettingsS")
        Case OID_CONTRACT:
            aMacro = MacroActionStr("MacroContractS")
        Case OID_CONTRACT_START_PLUS:
            aMacro = CCurveControl.OnPlusMinusAction(CURVE_UI_CONTRACTS_START_PLUS)
        Case OID_CONTRACT_START_MINUS:
            aMacro = CCurveControl.OnPlusMinusAction(CURVE_UI_CONTRACTS_START_MINUS)
        Case OID_CONTRACT_END_PLUS:
            aMacro = CCurveControl.OnPlusMinusAction(CURVE_UI_CONTRACTS_END_PLUS)
        Case OID_CONTRACT_END_MINUS:
            aMacro = CCurveControl.OnPlusMinusAction(CURVE_UI_CONTRACTS_END_MINUS)
        Case OID_SORT:
            If Not m_params.IsFlag(CURVE_FLG_EDIT_DATES) Then
                If idx >= 0 Then cn = curves(idx)
                aMacro = MacroActionStr("MacroSortS", CURVE_GRP_NAME, cn, CDDXHelper.NewGUID())
            End If
        Case OID_VIEW_HISTORY:
            aMacro = MacroActionStr("MacroViewHistoryS", CURVE_GRP_NAME, curves(idx), CDDXHelper.NewGUID())
        Case OID_LAST_DOWNLOAD:
            aMacro = MacroActionStr("MacroDownloadS", CURVE_GRP_NAME, curves(idx), CDDXHelper.NewGUID())
        Case OID_LAST_UPLOAD:
            aMacro = MacroActionStr("MacroUploadS", CURVE_GRP_NAME, curves(idx), CDDXHelper.NewGUID())
        Case OID_ACCEPT:
            If CCurveControl.ShowAccept(idx) Then
                aMacro = MacroActionStr("MacroAccept", CURVE_GRP_NAME, curves(idx), CDDXHelper.NewGUID())
            End If
        Case OID_DELETE:
            aMacro = MacroActionStr("MacroDeleteS", CURVE_GRP_NAME, curves(idx), CDDXHelper.NewGUID())
    End Select
End Sub

Private Sub DrawTimes(ByVal aIndex As Long, ByVal aIsDownload As Boolean)
 Dim tv As Double
 
    If Not CCurveControl.GetAccessTimeToDraw(m_params, aIndex, aIsDownload, tv) Then Exit Sub
    Call CCurveControl.DrawAccessTime(m_sheet.Cells(C_FIXED_ROWS - 2, aIndex + 3), tv, aIsDownload, xlLeft)
End Sub

Public Sub DrawVR(ByVal aIndex As Long)
    m_flags = m_flags Or CURVE_F_SUPPRESS_FINALIZE
    Call PrivateDrawVR(aIndex)
End Sub

Private Sub PrivateDrawVR(ByVal aIndex As Long)
    Call CCurveControl.DrawCurveVR(aIndex, CDbl(CCurveDates.ParamEntity.OprStartDate), C_FIXED_ROWS - 1, aIndex + 3, xlLeft)
End Sub

Private Sub GetContractDates(minDate As String, maxDate As String)
    minDate = "--- -- ----"
    maxDate = minDate
End Sub

Private Sub m_Imager_OnText(sender As Object, ByVal aTarget As Integer, ByVal aUserData As String, aText As String, ByRef aBold As Boolean, ByRef aToolTip As String, ByRef aTop As Long, ByRef aLeft As Long)
 Dim col As Long
 Dim pos As Long
 Dim maxdte As String
 Dim mindte As String
 
    If IsNumeric(aUserData) Then
        pos = CLng(aUserData)
    End If
    col = 2 * GetColIndex(aUserData)
    
    aText = vbNullString
    aBold = False
    aToolTip = vbNullString
    
    Select Case aTarget
        Case OID_DOWNLOAD_ALL:
        Case OID_ACCEPT_ALL:
        Case OID_UPLOAD_ALL:

'        Case OID_EDIT_DATE:
'            aText = "  Edit Effective Date"
'        Case OID_CONTRACT:
 
'        Case OID_VIEW_HISTORY:
            'aText = "  View History"
        Case OID_LAST_DOWNLOAD:
            'aText = "  Download" '+ du
'
            Call DrawTimes(pos, True)
        Case OID_LAST_UPLOAD:
            'aText = "  Upload" '+ du
            Call DrawTimes(pos, False)
        Case OID_ACCEPT:
'            Call DrawVR(pos)
        Case OID_CURVE_NAME:
'            aBold = True
            aToolTip = m_params.GetTooltipByPosition(pos)
            aTop = C_FIXED_ROWS
            aLeft = pos + 3
            
        Case OID_MIN_CONTRACT_DATE:
            Call GetContractDates(mindte, maxdte)
            aText = mindte
        Case OID_MAX_CONTRACT_DATE:
            Call GetContractDates(mindte, maxdte)
            aText = maxdte
    End Select
End Sub

Private Sub AddNewContracts(ByVal length As Long, ByVal op As Integer)
 Dim rgn As range
 Dim k As Long
 Dim dte1 As Double
 Dim dte2 As Double
 Dim startRow As Long
 Dim mrgn As range
 
    With m_dataRgn
        startRow = .row + 1
        
        Select Case op
            Case 1:
                Set rgn = .Cells(2, 1).Resize(length, .Columns.count)
                Call rgn.rows.Insert(shift:=xlShiftDown)
                
                m_params.rowCount = m_params.rowCount + length
                
                If Is410() Then Set mrgn = rgn.offset(-length).Resize(length, 2)
            Case 3:
                Set rgn = .Cells(.rows.count + 1, 1).Resize(length, .Columns.count)
                Call rgn.rows.Insert(shift:=xlShiftDown)
                Call CCurveControl.Remove4EyesStyle(rgn.offset(-length))
                
                m_params.rowCount = m_params.rowCount + length
                
                If Is410() Then Set mrgn = rgn.offset(-length).Resize(length, 2)
            Case 2:
                If .rows.count = 1 Then Exit Sub
                Set rgn = .offset(1).Resize(1)
                Call rgn.rows.Delete(shift:=xlShiftUp)
                m_params.rowCount = m_params.rowCount - 1
                Exit Sub
                
            Case 4:
                If .rows.count = 1 Then Exit Sub
                Set rgn = .offset(.rows.count - 1).Resize(1)
                Call rgn.rows.Delete(shift:=xlShiftUp)
                m_params.rowCount = m_params.rowCount - 1
                Exit Sub
        End Select
    End With
    
    Set rgn = rgn.offset(-length).Resize(length)
    Call CCurveControl.SetSOCValueFormats(-1, rgn.offset(, 2).Resize(, rgn.Columns.count - 2), m_params)
    
    If Not mrgn Is Nothing Then
        With mrgn
            Call .Merge(True)
            .HorizontalAlignment = xlCenter
        End With
    End If
End Sub

Private Sub AddNewContracts2(ByVal aPrior As Long, dispDates() As Double, ByVal length As Long)
 Dim rgn As range
 Dim mrgn As range
 
    With m_dataRgn
        Select Case aPrior
            Case -1:
                Set rgn = .offset(1).Resize(length)
                Call rgn.rows.Insert(shift:=xlShiftDown)
                
                If Is410() Then Set mrgn = rgn.offset(-length).Resize(length, 2)
            Case 1:
                Set rgn = .offset(.rows.count - length).Resize(length)
                Call rgn.rows.Insert(shift:=xlShiftDown) ', CopyOrigin:=xlFormatFromRightOrBelow)
                Call CCurveControl.Remove4EyesStyle(rgn.offset(-length))
                
                If Is410() Then Set mrgn = rgn.offset(-length).Resize(length, 2)
            Case 0:
                Set rgn = .offset(1).Resize(length)
                Call rgn.rows.Insert(shift:=xlShiftDown)
                
            Case -2:
                If .rows.count = 1 Then Exit Sub
                
                Set rgn = .offset(1).Resize(1)
                Call rgn.rows.Delete(shift:=xlShiftUp)
                Exit Sub
            Case 2:
                If .rows.count = 1 Then Exit Sub
                
                Set rgn = .offset(.rows.count).Resize(1)
                Call rgn.rows.Delete(shift:=xlShiftUp)
                Exit Sub
        End Select
    End With
    
    Set rgn = rgn.offset(-length).Resize(length)
    Call CCurveControl.SetDateVaules(m_params.granularities, rgn.Resize(, 1), dispDates)
    Call CCurveControl.SetSOCValueFormats(-1, rgn.offset(, 2).Resize(, rgn.Columns.count - 2), m_params)
    
    If Not mrgn Is Nothing Then
        With mrgn
            Call .Merge(True)
            .HorizontalAlignment = xlCenter
        End With
    End If
End Sub

Public Function IFNewContracts(ByVal dayCount As Long, ByVal op As Integer, dispDates() As Double) As Boolean
 Dim length As Long
 
    m_flags = m_flags And (Not CURVE_F_SUPPRESS_FINALIZE)
    Set m_sheet = ActiveSheet
    Call m_params.FromXML(CCurveControl.GetCurveProperties(m_sheet))
    
    Call GetRanges
    Call InitImager
        
    If m_params.IsFlag(CURVE_FLG_EDIT_DATES) Then
        
        If op Mod 2 = 0 And m_dataRgn.rows.count = 1 Then
            Exit Function
        End If
        
        Call AddNewContracts(dayCount, op)
        Call CCurveControl.SaveCurveProperties(m_sheet, m_params)
        Call GetRanges
        
        With m_dataRgn
            If .rows.count > 1 Then
                .offset(1).Resize(.rows.count - 1, 1).NumberFormat = CDDXDates.SystemDateFormat
            End If
        End With
        
        Call DrawContractDatesForMP
        
        If op = 1 Or op = 3 Then
            Call AddDataStyle(dayCount, op)
        ElseIf op = 2 Then
            Call AddDataStyle(dayCount, -1)
        ElseIf op = 4 Then
            Call AddDataStyle(dayCount, -2)
        End If
        
    '    With m_params
    '        Call cDDXCurve.AllotCurveMDs(BSConsts.DDX_PID, m_sheet, m_DataRgn.Columns.count - 2)
    '    End With
    
    Else
        If CCurveControl.IsEmptyDates(dispDates) Then Exit Function
        length = UBound(dispDates) - LBound(dispDates) + 1
        
        Call AddNewContracts2(dayCount, dispDates, length)
        
        Call GetRanges
        
        Call DrawContractDatesForMP
        
        If dayCount = -1 Then
            Call AddDataStyle(length, 1)
        ElseIf dayCount = 1 Then
            Call AddDataStyle(length, 3)
        ElseIf dayCount = 2 Then
            Call AddDataStyle(length, -2)
        Else
            Call AddDataStyle(length, -1)
        End If
        
    End If
End Function

Private Sub AddMD(ByVal oprDateIndex As Long)
    Call CCurveControl.ResetRangeColor(m_params, m_dataRgn, oprDateIndex)
    Call CCurveControl.PopulateInputs
    Call CalculateDates
End Sub

Public Function IFSort(ByVal aGroupName As String, ByVal aCurveName As String) As Boolean
 Dim sorter As CCurveSort
 Dim pos As Long
 
    m_flags = m_flags And (Not CURVE_F_SUPPRESS_FINALIZE)
    Set m_sheet = ActiveSheet
    Set m_params = CCurveControl.GetParams(m_sheet)
    Call GetRanges
    
    With m_dataRgn
        If .Columns.count < 3 Or .rows.count <= 2 Then Exit Function
    End With

'    Call UponSort(True)
    
    pos = m_params.GetCurvePosition(aCurveName)
    Set sorter = New CCurveSort
    
    With m_dataRgn
        IFSort = sorter.Execute(.offset(1).Resize(.rows.count - 1), IIf(aCurveName = vbNullString, 1, pos + 3), m_params)
    End With
    
    Set sorter = Nothing
    If Not IFSort Then Exit Function
     
'    Call UponSort(False)
    
    Call GetRanges
    Call AddStyle
End Function

Private Sub CalculateDates()
    If Application.Calculation = xlCalculationAutomatic Then Exit Sub
    
    With m_dataRgn
        Call .offset(, 2).Resize(1, .Columns.count - 2).Calculate
    End With
End Sub

Private Sub ReferenceOprDate()
    If Not m_params.IsFlag(CURVE_FLG_EDIT_DATES) Then Exit Sub
    
    With m_dataRgn.Cells(1, 3).Resize(, m_dataRgn.Columns.count - 2)
        .Formula = "=" + m_sheet.Cells(3, 1).Address
        .NumberFormat = CDDXDates.SystemDateFormat
    End With
End Sub

Public Sub IFReLayout()
    m_flags = m_flags And (Not CURVE_F_SUPPRESS_FINALIZE)
    Call GetRanges
    Set m_Imager.sheet = m_sheet
    If m_params.granularities = 0 Then
        Call m_params.FromXML(CCurveControl.GetCurveProperties(m_sheet))
    End If
    
    Call CCurveControl.ClearImagesV1(m_dataRgn)
    
    Call AddStyle
    Call DrawObjects
    Call ReferenceOprDate
End Sub

Private Function Is410() As Boolean
    If CCurveControl.IsUIUpToDate() Then Exit Function
    
    Is410 = Not m_sheet.Columns(2).EntireColumn.Hidden
End Function

Private Sub LockOprDate(rdonly As Boolean)
    m_sheet.Cells(3, 1).Locked = rdonly Or Not m_params.IsFlag(CURVE_FLG_EDIT_DATES)
End Sub

Public Sub IFUpdatePermissions(permissions() As Long)
 Dim curves() As String
 Dim rdonly As Boolean
 Dim k As Long
 Dim r As Long
 Dim splitrow As Long
 Dim splitcol As Long
 Dim imgl As Scripting.Dictionary
 
    m_flags = m_flags Or CURVE_F_SUPPRESS_FINALIZE
    
    Set m_sheet = ActiveSheet
    If m_Imager Is Nothing Then Set m_Imager = New CCurveImageText
    Set m_Imager.sheet = m_sheet
    Set m_params = CCurveDates.ParamEntity

    Call GetRanges
    
    curves = m_params.curves
    rdonly = Not CCurveControl.HasWriteableCurves(m_sheet, m_params, permissions)
    
    With m_Imager
        .AlternativeText = vbNullString

        If rdonly Then
            Call CCurveControl.DeleteCurveIconsByID(m_Imager, OID_ACCEPT_ALL, OID_UPLOAD_ALL, OID_CONTRACT, OID_CONTRACT_START_PLUS, OID_CONTRACT_START_MINUS, OID_CONTRACT_END_PLUS, OID_CONTRACT_END_MINUS)
        
        Else
            If .FindImage(OID_ACCEPT_ALL) Is Nothing Then Call CCurveControl.AddAcceptAll(m_Imager)
            
            If .FindImage(OID_UPLOAD_ALL) Is Nothing Then
                Call .Draw(OID_UPLOAD_ALL, vbNullString)
                Call .Draw(OID_CONTRACT, vbNullString)

                Call .Draw(OID_CONTRACT_START_PLUS, vbNullString)
                Call .Draw(OID_CONTRACT_START_MINUS, vbNullString)
                Call .Draw(OID_CONTRACT_END_PLUS, vbNullString)
                Call .Draw(OID_CONTRACT_END_MINUS, vbNullString)
            End If
        End If
    End With
    
    Call LockOprDate(rdonly)
    Call CCurveControl.GetSplits(m_sheet, m_params, splitrow, splitcol)
    m_Imager.DeleteExsitingBeforeAdd = False
    
    For k = LBound(permissions) To UBound(permissions)
        If permissions(k) >= 0 Then
            rdonly = IIf(permissions(k) = 0, True, False)
            
            If rdonly Then
                If imgl Is Nothing Then
                    Set imgl = New Scripting.Dictionary
                    Call CCurveControl.DeleteCurveIconsByAlt(imgl, vbNullString)
                End If
                Call CCurveControl.DeleteCurveIconsByAlt(imgl, curves(k), AT_UPLOAD, AT_ACCEPT)
            Else
                Call DrawObjectUpload(curves(k), k)
                Call DrawObjectAccept(curves(k), k)
            End If
            
            With m_dataRgn
                r = .rows.count - 1
                If r > 0 Then .offset(1, splitcol + k).Resize(r, 1).Locked = rdonly
                'Call CCurveControl.Add4EyesStyle(m_dataRgn)
            End With
        End If
    Next
    
     With m_dataRgn
        If .rows.count > 1 Then
            Call CCurveControl.AddProtection(permissions, .Cells(2, 3).Resize(.rows.count - 1, .Columns.count - 2))
        End If
    End With
End Sub
Attribute VB_Name = "CCPFutureTRANS2"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Option Base 0

Private m_sheet As Worksheet
Private WithEvents m_Imager As CCurveImageText
Attribute m_Imager.VB_VarHelpID = -1
Private m_params As New CCurveParams
Private m_dataRgn As range
Private m_HeaderRgn As range
Private m_flags As Long
'
Private Const C_FIXED_COLS As Long = 6
Private Const C_FIXED_ROWS As Long = 6
'
Private Const OID_DOWNLOAD_ALL As Integer = 1
Private Const OID_UPLOAD_ALL As Integer = 2
Private Const OID_EDIT_SETTINGS As Integer = 3
Private Const OID_CONTRACT_RANGE As Integer = 4
'Private Const OID_CURVE_NAME As Integer = 9
Private Const OID_CONTRACT_START_PLUS As Integer = 11
Private Const OID_CONTRACT_START_MINUS As Integer = 12
Private Const OID_CONTRACT_END_PLUS As Integer = 13
Private Const OID_CONTRACT_END_MINUS As Integer = 14
'Private Const OID_MAX_CONTRACT_DATE As Integer = 15
'Private Const OID_MIN_CONTRACT_DATE As Integer = 16
'
Private Const ALT_CONTRA_HEAD_PLUS As String = "New contract"
Private Const ALT_CONTRA_HEAD_MINUS As String = "Delete first contract"
Private Const ALT_CONTRA_TAIL_PLUS As String = "New contract to the end"
Private Const ALT_CONTRA_TAIL_MINUS As String = "Delete last contract"

Private m_hasvr As Boolean

Private Sub GetRanges()
    If m_params Is Nothing Then Exit Sub
    
    If m_sheet Is Nothing Then Set m_sheet = ActiveSheet
    Set m_dataRgn = CCurveControl.GetCurveRange(m_sheet)
    
    If Not m_dataRgn Is Nothing Then
        With m_dataRgn
            Set m_HeaderRgn = m_sheet.Cells(1, 1).Resize(.row - 1, .Columns.count)
        End With
    End If
End Sub

Private Sub ResizeVRCol(ByVal isvr As Boolean, ByVal colNum As Long)
    If colNum = C_FIXED_COLS - 1 Then
        m_sheet.Columns(colNum).ColumnWidth = IIf(isvr, 32, 2) '0.01)
    Else
        m_sheet.Columns(colNum).ColumnWidth = IIf(isvr, 10, 4)
    End If
End Sub

Private Sub RestoreEditableDateText()
 Dim sht As Worksheet
 
    If Not m_params.IsFlag(CURVE_FLG_EDIT_DATES) Then Exit Sub
    
    Set sht = IIf(m_sheet Is Nothing, ActiveSheet, m_sheet)
    With sht.Cells(2, 2)
        .Characters.Font.ColorIndex = xlColorIndexAutomatic
    End With
End Sub

Private Sub ColorEditableDate()
 Dim sht As Worksheet
 
    If Not m_params.IsFlag(CURVE_FLG_EDIT_DATES) Then Exit Sub
    
    Set sht = IIf(m_sheet Is Nothing, ActiveSheet, m_sheet)
    With sht.Cells(2, 2).Resize(, C_FIXED_COLS - 1)
        .Interior.ColorIndex = 40
    End With
End Sub

Private Sub AddStyle(ByVal isNewFlg As Long)
 Dim k As Long
 Dim f As Variant
 Dim row As Long
 Dim dtacols As Long

    With m_HeaderRgn
        dtacols = .Columns.count - C_FIXED_COLS
        If dtacols > 0 Then Call .offset(, C_FIXED_COLS).Resize(, dtacols).Clear
        
        .Cells(1, 1).RowHeight = 40
        For f = 2 To .rows.count
             .Cells(f, 1).RowHeight = 18
        Next
        
        m_sheet.rows(1).Interior.color = RGB(&H0, &H52, &H93)
        
        With .rows(1)
            .Borders(xlEdgeBottom).LineStyle = xlContinuous
            .Borders(xlEdgeBottom).Weight = xlThick
            '.Borders(xlEdgeBottom).ColorIndex = 10
            .Borders(xlEdgeBottom).color = RGB(&H5E, &HB6, &HE4)
        End With
        
        With .Cells(.rows.count + 1, 1).Resize(1, .Columns.count)
            .Borders(xlEdgeTop).LineStyle = xlContinuous
            .Borders(xlEdgeTop).Weight = xlHairline
        End With
 
        If dtacols > 0 Then
            With .offset(, C_FIXED_COLS).Resize(, dtacols)
                .Borders(xlEdgeRight).LineStyle = XlLineStyle.xlLineStyleNone
            End With
        End If
        
        .offset(1).Interior.color = RGB(255, 255, 255)

        .Columns(.Columns.count).Borders(xlEdgeRight).LineStyle = xlContinuous
        .Columns(.Columns.count).Borders(xlEdgeRight).Weight = xlThin
    End With

    With m_HeaderRgn.offset(1).Resize(m_HeaderRgn.rows.count - 1, C_FIXED_COLS)

        .Borders(xlInsideHorizontal).LineStyle = xlContinuous
        .Borders(xlInsideHorizontal).Weight = xlHairline
        .Borders(xlInsideHorizontal).color = RGB(&HD9, &HD9, &HD9)
        
        .Borders(xlEdgeBottom).LineStyle = xlContinuous
        .Borders(xlEdgeBottom).Weight = xlHairline
        .Borders(xlEdgeBottom).color = RGB(&HD9, &HD9, &HD9)

    End With
    
    row = m_HeaderRgn.rows.count
    With m_HeaderRgn.rows(row)
        .Borders(xlEdgeBottom).LineStyle = xlContinuous
        .Borders(xlEdgeBottom).Weight = xlThin
    End With
    
    m_hasvr = HasVR()
    
    With m_dataRgn
        .Cells(1, 1).RowHeight = 34
    
        .rows(1).Interior.color = CURVE_COLUMN_HEADER_COLOR2
        
        With .rows(1)
            .HorizontalAlignment = xlCenter
            .VerticalAlignment = xlCenter
            .WrapText = False
            .Orientation = 0
            .AddIndent = False
            .IndentLevel = 0
            .ShrinkToFit = False
            .ReadingOrder = xlContext
            '.MergeCells = False
        End With

        For Each f In .Columns
            Select Case f.column
                Case 1, 2:
                    If isNewFlg = 1 Then f.ColumnWidth = 13
                Case 3:
                    If isNewFlg = 1 Then Call ResizeVRCol(m_hasvr, f.column)
                Case 4:
                    If isNewFlg = 1 Then f.ColumnWidth = 16
                Case C_FIXED_COLS - 1:
                    If isNewFlg = 1 Then Call ResizeVRCol(m_hasvr, f.column) 'IIf(CCurveControl.ShowAcceptAll() And Not m_params.AllCurvesRD(), 32, 8)
                Case C_FIXED_COLS:
                    If isNewFlg = 1 Then f.ColumnWidth = IIf(m_hasvr, 4, 3)
                Case Else:
                    If isNewFlg = 1 Or (f.column > C_FIXED_COLS + 1 + m_params.PropertyCount) Then
                        f.ColumnWidth = 20
                    End If
            End Select
     
            Select Case f.column
                Case 1, 2, 4:
'                    f.Borders(xlEdgeRight).LineStyle = xlContinuous
'                    f.Borders(xlEdgeRight).Weight = xlHairline
                Case C_FIXED_COLS + 1:
                    f.Borders(xlEdgeRight).LineStyle = xlContinuous
                    f.Borders(xlEdgeRight).Weight = xlThin
                Case Is > C_FIXED_COLS + 1:
                    f.Borders(xlEdgeRight).LineStyle = xlContinuous
                    f.Borders(xlEdgeRight).Weight = IIf(f.column = .Columns.count, xlThin, xlHairline)
            End Select
        Next
        
        With .offset(1, 1).Resize(.rows.count - 1, 3)
            .Borders(xlEdgeRight).LineStyle = xlContinuous
            .Borders(xlEdgeRight).Weight = xlHairline
        End With
'
        With .offset(1).Resize(.rows.count - 1)
            .Borders(xlInsideHorizontal).LineStyle = xlContinuous
            .Borders(xlInsideHorizontal).Weight = xlThin
            .Borders(xlInsideHorizontal).color = RGB(210, 210, 210)
            
            .Borders(xlEdgeBottom).LineStyle = xlContinuous
            .Borders(xlEdgeBottom).Weight = xlThin
            .Borders(xlEdgeBottom).color = RGB(210, 210, 210)
        End With
'
''        For k = 2 To .rows.count
''             .offset(k - 1, C_FIXED_COLS).Resize(1, .Columns.count - C_FIXED_COLS).Interior.color = _
''                            IIf(m_params.Readonly(k - 2), BSConsts.CURVE_COLUMN_HEADER_COLOR2, IIf((k Mod 2 = 1), BSConsts.CURVE_ROW_ALTERNATING_COLOR_1, CURVE_ROW_ALTERNATING_COLOR_2))
''        Next
''
''        For k = 2 To .rows.count
''             .offset(k - 1, C_FIXED_COLS).Resize(1, m_params.PropertyCount + 2).Interior.color = IIf(m_params.Readonly(k - 2), BSConsts.CURVE_COLUMN_HEADER_COLOR2, BSConsts.CURVE_COLUMN_HEADER_COLOR)
''        Next
        
        .offset(1).Resize(.rows.count - 1, C_FIXED_COLS).Interior.color = RGB(&HFF, &HFF, &HFF)
    End With

    Call ColorEditableDate
End Sub

Private Sub AddDataGroup(ByVal isGroup As Boolean)
    Call CCurveHelper.GroupColumns(m_sheet, C_FIXED_COLS + 1, m_params.PropertyCount + C_FIXED_COLS + 1, isGroup)
End Sub

Private Sub AddGroups()
    Call CCurveHelper.RemoveAllGroups(m_sheet)
    
    Call CCurveHelper.GroupColumns(m_sheet, 4, 5, True)
    Call AddDataGroup(True)
    
    Call CCurveHelper.CollapseGroups(m_sheet)
End Sub

Private Sub InitImager()
    With m_Imager
        Set .sheet = m_sheet
'        Set .ZEComp = m_ZEComp
    End With
End Sub

Public Function IFDelete(sheet As Worksheet, ByVal aGroupName As String, ByVal aCurveName As String)
 Dim idx As Long

    m_flags = m_flags And (Not CURVE_F_SUPPRESS_FINALIZE)
    Set m_sheet = sheet
    Set m_Imager.sheet = m_sheet

    Set m_params = CCurveDates.ParamEntity
    Call GetRanges
    
    idx = m_params.GetCurvePosition(aCurveName)
    If idx < 0 Then Exit Function
 
    IFDelete = True

    Call m_sheet.rows(m_dataRgn.row + idx + 1).Delete(xlShiftUp)
    
    Call CCPVRStorage.DeleteCurve(m_sheet, aCurveName)
    If Not CCPVRStorage.VRExists(m_sheet, vbNullString) Then Call CCurveControl.EraseAcceptAll2
    
    With m_params
        Call .RemoveCurve(idx)
        .ColumnCount = .ColumnCount - 1
    End With
    
    Call CCurveControl.SaveCurveProperties(m_sheet, m_params)
    
    If m_params.GetCurveCount() > 0 Then
        Call GetRanges
        
        If m_params.AllCurvesRD() Then
            Call CCurveControl.DeleteCurveIconsByID(m_Imager, OID_ACCEPT_ALL, OID_UPLOAD_ALL, OID_CONTRACT_RANGE, OID_CONTRACT_END_MINUS, OID_CONTRACT_END_PLUS, OID_CONTRACT_START_MINUS, OID_CONTRACT_START_PLUS)
        End If
        
        If CCurveControl.DeletePropertiesTRANS(m_dataRgn) > 0 Then
            Call AddGroups
        End If
    Else
        Call OnDeletion
    End If
End Function

Private Sub OnDeletion()
 Dim p As CustomProperty
 Dim shp As Shape
 
    m_sheet.Cells.Delete
    For Each shp In m_sheet.Shapes
        shp.Delete
    Next
    
    For Each p In m_sheet.CustomProperties
        p.Delete
    Next
End Sub

'Private Function GetOldParamsObject() As CCurveParams
' Dim oldParams As CCurveParams
' Dim ps As String
'
'    ps = CCurveControl.GetCurveProperties(m_sheet)
'    If Len(ps) = 0 Then Exit Function
'
'    Set oldParams = New CCurveParams
'    Call oldParams.FromXML(ps)
'    Set GetOldParamsObject = oldParams
'End Function

Public Function IFNew(data As ZEWSProxy.ICurveResult, ud As CCurveUserData) As Boolean
 Dim isnew As Boolean
' Dim oldParams As CCurveParams
 
    m_flags = m_flags And (Not CURVE_F_SUPPRESS_FINALIZE)
    With m_params
        Call .FromXML(data.value)
        .flagValues = .flagValues Or CURVE_FLG_V2
    End With
    
    Set m_sheet = CCurveControl.GetSheet(m_params, True, isnew)
    If m_sheet Is Nothing Then Exit Function ' failed to find the workbook
    
    If Not isnew Then
'        Set oldParams = GetOldParamsObject()
        Call CCurveControl.AdjustPropNDataAreasTRANS(CCurveDates.ParamEntity, m_params)
    End If
    Call CCurveDates.AssignTargetSheet(m_sheet)
    Set CCurveDates.ParamEntity = m_params
 
    Call CCurveControl.SaveCurveProperties(m_sheet, m_params)
    Call InitImager
    
    Call CDDXCurve.SetFindCriterion(BSConsts.DDX_PID, m_sheet, ud.Criterion)
    
    If isnew Then
        Call DrawHeader
    Else
        Call GetRanges
    End If
    
    Call DrawProperties
    Call DrawData(True)

    Call AddStyle(1)
    Call AddGroups
    
    Call DrawControls
    Call AddMD(-1)
    
    IFNew = True
End Function

Public Function IFRefresh(data As ZEWSProxy.ICurveResult) As Boolean
 Dim oldParams As CCurveParams
 Dim diff As Long
 
    m_flags = m_flags And (Not CURVE_F_SUPPRESS_FINALIZE)
    Call m_params.FromXML(data.value)
    
    Set m_sheet = ActiveSheet
    
    Set oldParams = New CCurveParams
    Call oldParams.FromXML(CCurveControl.GetCurveProperties(m_sheet))
    
    Call CCurveControl.ClearAllImages(m_sheet)
    If m_params.IsFlag(CURVE_FLG_EDIT_DATES) Then
        Call CCurveControl.ResetSheetButFormulas(m_sheet)
        
        diff = (oldParams.rowCount + oldParams.PropertyCount) - (m_params.rowCount + m_params.PropertyCount)
        If diff > 0 Then
            m_sheet.Cells(1, C_FIXED_COLS + oldParams.rowCount + oldParams.PropertyCount - diff + 1).Resize(rows.count, diff).Clear
        End If
    Else
        Call m_sheet.Cells.Clear
    End If

    m_params.LastUploadTime = oldParams.LastUploadTime
    Call CCurveControl.SaveCurveProperties(m_sheet, m_params)
    Set oldParams = Nothing
    
    Call GetRanges

    Call InitImager
    
'    Call DrawHeader
    Call DrawProperties
    Call DrawData(True)
    
    Call AddStyle(1)
    Call AddGroups
    
    'If Not HasVR() Then Call CCurveControl.EraseAcceptAll2
    Call DrawControls

    Call AddMD(-1)
    
    Call RestoreEditableDateText
    
    IFRefresh = True
End Function

Private Sub RefreshVROnUpload(ByVal cvrIdx As Long, ByVal doSummary As Boolean, ByVal readComments As Boolean)
 Dim rgn As range
 Dim cvrnms() As String
 Dim cols As Long
 Dim isvr As Boolean
 
    cols = C_FIXED_COLS + CCurveControl.HoriWidthTRANS(m_params)
    If cvrIdx >= 0 Then
        Set rgn = m_dataRgn.offset(cvrIdx + 1, cols).Resize(1, m_dataRgn.Columns.count - cols)
    Else
        Set rgn = m_dataRgn.offset(1, cols).Resize(m_dataRgn.rows.count - 1, m_dataRgn.Columns.count - cols)
    End If
        
    If CDDXCurve.FourEyesActive Then
        If readComments Then Call CCurveControl.RefreshCommentsAfterUploaded(rgn, True)
        
    Else
        If doSummary Then
            Call CCurveControl.VRColorValues(vbNullString, rgn, m_params, True)
        End If
        
        Call CCurveControl.EraseAccepts(m_Imager, cvrIdx)
        
        isvr = HasVR()
        Call CCurveHelper.ExpandGroups(m_sheet)
        Call ResizeVRCol(isvr, 3)
        Call ResizeVRCol(isvr, C_FIXED_COLS - 1)
        Call CCurveHelper.CollapseGroups(m_sheet)
        
        cvrnms = m_params.curves
        
        If cvrIdx >= 0 Then
            'Call DrawObjectAccept(cvrnms(cvrIdx), cvrIdx)
            Call PrivateDrawVR(cvrnms(cvrIdx), cvrIdx)
        Else
            For cvrIdx = LBound(cvrnms) To UBound(cvrnms)
'                Call DrawObjectAccept(cvrnms(cvrIdx), cvrIdx)
                Call PrivateDrawVR(cvrnms(cvrIdx), cvrIdx)
            Next
        End If
    End If
    'm_sheet.Columns(5).ColumnWidth = IIf(CCurveControl.ShowAcceptAll(), 32, 8)
End Sub

Public Function IFUpload(data As ZEWSProxy.ICurveResult, ByVal curvePos As Long) As Boolean
 Dim k As Long
 Dim curveIdx() As Long
 Dim count As Long
 
    m_flags = m_flags And (Not CURVE_F_SUPPRESS_FINALIZE)
    Set m_sheet = ActiveSheet
    Call m_params.FromXML(CCurveControl.GetCurveProperties(m_sheet))
    Call GetRanges
    
    curveIdx = CCurveControl.GetUploadedItms(m_params, m_sheet, data, True, count)
    If count > 0 Then
        Call CCurveControl.SaveCurveProperties(m_sheet, m_params)
    
        For k = LBound(curveIdx) To UBound(curveIdx)
            Call DrawTimes(curveIdx(k), False)
        Next
    End If
    
    Call RefreshVROnUpload(curvePos - 1, True, True)
    Call CDDXCurve.NotifyCurveUploadResult(DDX_PID, data, m_params)
     
    If curvePos <= 0 Then Call RestoreEditableDateText
    
    IFUpload = True
End Function

Public Function IFRefreshIndividual(data As ZEWSProxy.ICurveResult, ByVal RefreshTarget As Long) As Boolean
 Dim p As New CCurveParams
 Dim isnew As Boolean
 Dim index As Long
 Dim curves() As String
' Dim groups() As String
 Dim downloadtimes() As String
 Dim target As String
 Dim grp As String
 Dim newtime As String
 Dim rgn As range
 
    m_flags = m_flags And (Not CURVE_F_SUPPRESS_FINALIZE)
    Call p.FromXML(data.value)
    
    Set m_sheet = CCurveControl.GetSheet(p, False, isnew)
    If m_sheet Is Nothing Then Exit Function
    
    With p
        curves = .curves
'        groups = .CurveGroups
        target = curves(LBound(curves))
'        grp = groups(LBound(curves))
        downloadtimes = .LastDownloadTime()
        newtime = downloadtimes(LBound(downloadtimes))
    End With
    Set p = Nothing
    
    Set m_params = CCurveDates.ParamEntity
    
    With m_params
'        Call .FromXML(CCurveControl.GetCurveProperties(m_sheet))
            
        Call GetRanges

        curves = .curves
        downloadtimes = .LastDownloadTime
        For index = LBound(curves) To UBound(curves)
            If curves(index) = target Then
                downloadtimes(index) = newtime
                .LastDownloadTime = downloadtimes
                Exit For
            End If
        Next
        If index > UBound(curves) Then Exit Function
    End With
    
    Call InitImager
'    Call DrawObjectDownload(target, index)
    Call DrawTimes(index, True)
    Set rgn = m_dataRgn.offset(index + 1).Resize(1)
    Call ReadFromFile(index)
    
    Call CCurveControl.SaveCurveProperties(m_sheet, m_params)
    Call AddMD(index)
    
    Call GetRanges
    Call RefreshVROnUpload(index, False, False)
    
    IFRefreshIndividual = True
End Function

Private Sub DrawHeader()
    Call CCurveControl.SetSplits(m_sheet, C_FIXED_ROWS, C_FIXED_COLS)
    Call GetRanges
    
    Call CCurveControl.InsertTitle(m_sheet)
End Sub

Private Sub DrawProperties()
 Dim k As Long
 Dim j As Long
 Dim Values() As String
 Dim cvs() As String
 Dim row As Long
 Dim col As Long
 Dim splitrow As Long
 Dim splitcol As Long
 
    Call CCurveControl.GetSplits(m_sheet, m_params, splitrow, splitcol)
    splitrow = splitrow + 1
    
    With m_params
        Values = .PropertyNames
        If Len(Join(Values)) = 0 Then Exit Sub
                
        For k = LBound(Values) To UBound(Values)
            With m_dataRgn.Cells(1, splitcol + (k + 1))
                .value = CCurveControl.AddApostrophe(Values(k))
                '.Characters.Font.Size = 8
                .HorizontalAlignment = xlLeft
                .VerticalAlignment = xlCenter
            End With
        Next
        
        cvs = .curves
        For k = LBound(cvs) To UBound(cvs)
            Values = .PropertyValues(cvs(k))
            row = splitrow + k
            
            For j = LBound(Values) To UBound(Values)
                col = splitcol + (j + 1)
                m_HeaderRgn.Cells(row, col).value = CCurveControl.AddApostrophe(Values(j))
                m_HeaderRgn.Cells(row, col).HorizontalAlignment = xlLeft
                m_HeaderRgn.Cells(row, col).VerticalAlignment = xlCenter
            Next
        Next
    End With
End Sub

Private Sub DrawIcon(ByVal aObjectID As Long, ByVal aPos As Long, ByVal aCurveName As String, ByVal aAlternativeText As String)
    With m_Imager
        .AlternativeText = CCurveControl.GetAltText(aCurveName, aAlternativeText)
        Call .Draw(aObjectID, CStr(aPos))
    End With
End Sub

Private Sub DrawDateRange()
 Dim rgn As range
 
    With m_sheet.Cells(2, 1)
        .IndentLevel = 1
        .value = " Effective Date:"
        With .Characters(1).Font
            .size = 9
        End With
    End With
    
'    With m_Sheet.Cells(2, 2)
'        .HorizontalAlignment = xlLeft
'        '.value = m_params.ToLocalTimeStr(m_params.startDate, False)
'        With .Characters(1).Font
'            .Bold = True
'            .Size = 8
'        End With
'    End With
    
    Set rgn = m_sheet.Cells(2, 2)
    If Not rgn.HasFormula Then
        If Not CCurveControl.PreserveFormulas() Then
            'Call CCurveControl.SetDateCell(m_sheet.Cells(2, 2), m_params.ToLocalTimeStr(m_params.startDate, False))
            With rgn
                .NumberFormat = CDDXDates.SystemDateFormat
                .value = m_params.OprStartDate
                .HorizontalAlignment = xlLeft
            End With
        End If
    End If
End Sub

Private Sub DrawInterval()
 Dim dtz As Boolean
 
    dtz = CCurveGranularity.IsGranularity(m_params.granularities, CURVE_GRANULARITY_HOURLY) Or CCurveGranularity.IsGranularity(m_params.granularities, CURVE_GRANULARITY_MINUTELY)
    dtz = IIf(dtz And m_params.TZName <> vbNullString And (m_params.IsFlag(CURVE_FLG_DST_ADJUST_START) Or m_params.IsFlag(CURVE_FLG_DST_ADJUST_END)), True, False)
    
    m_sheet.Cells(3, 1).Resize(, 2).Merge
    Call CCurveControl.DrawStyledTexts(m_sheet, 3, 1, " Interval:  ", CCurveGranularity.GetGranularityName(m_params.granularities), IIf(dtz, "   (" + m_params.TZName + ")", vbNullString))
End Sub

'Private Sub DrawContractDatesForMP()
'    With m_Imager
'        Call .Draw(OID_MAX_CONTRACT_DATE, vbNullString)
'        Call .Draw(OID_MIN_CONTRACT_DATE, vbNullString) '
'    End With
'End Sub

Private Sub DrawControls()
 Dim k As Long
 Dim vr As Long
 Dim curves() As String

    vr = IIf(m_params.rowCount - 1 > 0, &H1, 0) Or IIf(m_hasvr, &H2, 0)
    
    Call DrawDateRange
    Call DrawInterval

    curves = m_params.curves

    For k = LBound(curves) To UBound(curves)
        Call DrawTimes(k, True)
'        If Not m_params.Readonly(k) Then
'            Call DrawTimes(k, False)
'        End If

        Call DrawCurveName(k, curves(k))
'        Call DrawIcon(OID_CURVE_NAME, k, curves(k), AT_NAME)
        
        Call PrivateDrawVR(IIf(vr = (&H1 Or &H2), curves(k), vbNullString), k)
    Next
    
    With m_Imager
        .AlternativeText = vbNullString
        
        Call .Draw(OID_DOWNLOAD_ALL, vbNullString)
        Call .Draw(OID_EDIT_SETTINGS, vbNullString)
        Call CCurveControl.EraseAcceptAll2
        
        If Not m_params.AllCurvesRD() Then
            If vr = (&H1 Or &H2) Then Call CCurveControl.AddAcceptAll2(m_Imager)
            
            Call .Draw(OID_UPLOAD_ALL, vbNullString) '
'            Call .Draw(OID_SORT, vbNullString)
            Call .Draw(OID_CONTRACT_RANGE, vbNullString)
'            Call DrawContractDatesForMP
            
            Call AddContraControls
        End If

    End With
End Sub

Private Sub AddContraControls()
    Call CCurveControl.DeleteCurveIconsByID(m_Imager, OID_CONTRACT_START_PLUS, OID_CONTRACT_START_MINUS, OID_CONTRACT_END_PLUS, OID_CONTRACT_END_MINUS)
    With m_Imager
        
'        Call .RemoveImage(ALT_CONTRA_HEAD_PLUS)
'        Call .RemoveImage(ALT_CONTRA_HEAD_MINUS)
'        Call .RemoveImage(ALT_CONTRA_TAIL_PLUS)
'        Call .RemoveImage(ALT_CONTRA_TAIL_MINUS)
        '
        If m_params.rowCount >= 2 Then
            Call .Draw(OID_CONTRACT_START_PLUS, ALT_CONTRA_HEAD_PLUS, xlMove)
            Call .Draw(OID_CONTRACT_START_MINUS, ALT_CONTRA_HEAD_MINUS, xlMove)
            Call .Draw(OID_CONTRACT_END_PLUS, ALT_CONTRA_TAIL_PLUS, xlMove)
            Call .Draw(OID_CONTRACT_END_MINUS, ALT_CONTRA_TAIL_MINUS, xlMove)
        End If
    End With
End Sub

Private Sub DrawCurveName(ByVal aPos As Long, ByVal aCurveName As String)
 Dim w As Long
 Dim w0 As Long
 
    If aPos = 0 Then
        With m_dataRgn.Cells(1, 1).Resize(1, 2)
            .Merge
            .HorizontalAlignment = xlCenter
            .VerticalAlignment = xlCenter
            .value = "Curve Name"
        End With
        
        w = CCurveControl.GetNameWidth(m_params)
        w0 = Len("Effective Date: ")
        m_sheet.Columns(1).ColumnWidth = w0
        m_sheet.Columns(2).ColumnWidth = IIf(w < 28, 28, w) - w0
        
        With m_dataRgn.Cells(2, 1).Resize(m_dataRgn.rows.count - 1, 2)
            .HorizontalAlignment = xlLeft
            .VerticalAlignment = xlCenter
            .IndentLevel = 1
            .ShrinkToFit = False
            .WrapText = False
            .NumberFormat = "@"
            Call .Merge(Across:=True)
        End With
    End If
    
    m_dataRgn.Cells(aPos + 2, 1).value = CCurveControl.AddApostrophe(aCurveName)
End Sub

Private Sub DrawData(ByVal aIsNew As Boolean)
'    m_dataRgn.Font.ColorIndex = 1
    Call ReadFromFile(-1)
End Sub

Private Property Get EffectDatesRgn() As range
 Dim srows As Long
 Dim scols As Long
 
    Call CCurveControl.GetSplits(m_sheet, m_params, srows, scols)
    
    scols = scols + m_params.PropertyCount + 1
    Set EffectDatesRgn = m_dataRgn.Cells(2, scols).Resize(m_dataRgn.rows.count - 1)
End Property

Private Sub SetDateLinks()
    If Not m_params.IsFlag(CURVE_FLG_EDIT_DATES) Then Exit Sub
    EffectDatesRgn.Formula = "=" + m_sheet.Cells(2, 2).Address
End Sub

Public Sub CalculateDates(params As CCurveParams)
    m_flags = m_flags And (Not CURVE_F_SUPPRESS_FINALIZE)
    If Application.Calculation = xlCalculationAutomatic Then Exit Sub
    
    If Not params Is Nothing Then
        Set m_sheet = ActiveSheet
        Set m_params = params
        Call GetRanges
    End If
    
    If Not m_params.IsFlag(CURVE_FLG_EDIT_DATES) Then Exit Sub
    
    Call EffectDatesRgn.Calculate
End Sub

Private Sub ReadFromFile(ByVal aCurveIndex As Long)
 Dim r As Long
 
'    With m_dataRgn
'        If .Columns.count >= 2 And .rows.count >= 2 Then
'            .Font.ColorIndex = xlColorIndexAutomatic 'CURVE_DATA_CLR_IDX
'        End If
'    End With
    
    With m_dataRgn
        If aCurveIndex < 0 Then
            Call CCurveControl.ReadFileTRANS(aCurveIndex, .Resize(1), .offset(1).Resize(.rows.count - 1), m_params)
        Else
            Call CCurveControl.ReadFileTRANS(aCurveIndex, Nothing, .offset(aCurveIndex + 1).Resize(1), m_params)
        End If
    End With
    
    Call GetRanges
    Call SetDateLinks
    
    With m_dataRgn
        .Cells(2, C_FIXED_COLS + 1).Resize(.rows.count - 1).NumberFormat = CDDXDates.SystemDateFormat
'        For r = 2 To .rows.count
'            .Cells(r, C_FIXED_COLS + 1).NumberFormat = CDDXDates.SystemDateFormat
'        Next
    End With
End Sub

Private Sub Class_Initialize()
    Set m_Imager = New CCurveImageText
End Sub

Private Sub Class_Terminate()
    Call ProtectSheet
    Set m_Imager = Nothing
End Sub

Private Sub SetDataRgnFormat()
 Dim spltrows As Long
 Dim spltcols As Long
 Dim pc As Long
 
    On Local Error Resume Next
    
    Call CCurveControl.GetSplits(m_sheet, m_params, spltrows, spltcols)
    
    With m_dataRgn
        If .rows.count <= 1 Or spltcols >= .Columns.count Then Exit Sub
        
        pc = m_params.PropertyCount
        
        'curve nme
        With .offset(1, spltcols - 1).Resize(.rows.count - 1, pc + 1)
            .NumberFormat = "@"
            .HorizontalAlignment = xlLeft
            .offset(, pc).Resize(, 1).VerticalAlignment = xlCenter
        End With
        
        pc = pc + 1
        
        If .Columns.count > spltcols + pc Then
            With .offset(1, spltcols + pc).Resize(.rows.count - 1, .Columns.count - (spltcols + pc))
'                .NumberFormat = "General"
                .HorizontalAlignment = xlRight
            End With
        End If
    End With
End Sub

Private Sub ProtectSheet()
 Dim c As Long
 Dim k As Long
 Dim sizex As Long
 Dim tmp As Long
 Dim startl As Long
 Dim endl As Long
 
    If CDDXHelper.IsFlag(m_flags, CURVE_F_SUPPRESS_FINALIZE) Then Exit Sub
    
    If m_params.GetCurveCount() <= 0 Then
        Call CCurveControl.Unprotect(m_sheet)
        Exit Sub
    End If
 
    If m_sheet Is Nothing Then Exit Sub
    If m_sheet.ProtectContents Then Exit Sub
    'Call cDDXCurve.Unprotect(BSConsts.DDX_PID, m_sheet)
    
    If Not m_dataRgn Is Nothing Then
        If Not m_dataRgn Is Nothing Then m_dataRgn.Locked = True
        If Not m_HeaderRgn Is Nothing Then m_HeaderRgn.Locked = True
    Else
        m_sheet.UsedRange.Cells.Locked = True
    End If
    
    Call LockOprDate(m_params.AllCurvesRD())
    
    If Not m_dataRgn Is Nothing Then
        sizex = m_params.PropertyCount + 1    'curvename + effective date
        With m_dataRgn
            c = .Columns.count
            tmp = c - sizex - C_FIXED_COLS
            If tmp > 0 Then
                startl = 0
                endl = 0
                For k = LBound(m_params.curves) To UBound(m_params.curves)
                    If Not m_params.Readonly(k) Then
                        If startl = 0 Then startl = k + 1
                        endl = endl + 1
                    Else
                        If startl > 0 Then
                            'Call CUploadSheetCreator.setRangeLocked(m_dataRgn.offset(k + 1, C_FIXED_COLS + sizex).Resize(1, tmp), False)
                            .Cells(startl + 1, C_FIXED_COLS + sizex + 1).Resize(endl, tmp).Locked = False
                            startl = 0
                            endl = 0
                        End If
                    End If
                Next
                If startl > 0 Then
                    .Cells(startl + 1, C_FIXED_COLS + sizex + 1).Resize(endl, tmp).Locked = False
                End If
            End If
            
'            If .Columns.count > C_FIXED_COLS + sizex Then
                '.offset(, C_FIXED_COLS + sizex).Resize(1, .Columns.count - C_FIXED_COLS - sizex).Locked = m_params.AllCurvesRD()
'            End If
            
        End With
        
        Call SetDataRgnFormat
        Call CCurveControl.Add4EyesStyle(m_dataRgn)
    End If
    
    Call CCurveControl.Protect(m_sheet)
End Sub

Private Sub m_Imager_OnImage(sender As Object, ByVal aTarget As Integer, ByVal aUserData As String, aPicturePath As String, ByRef aWidth As Single, ByRef aHeight As Single)
    aPicturePath = vbNullString
    aWidth = 95
    aHeight = 18
    
    Select Case aTarget
        Case OID_EDIT_SETTINGS:
            aWidth = 140
            aPicturePath = "CurveEditDateSettings2.png"
        Case OID_CONTRACT_RANGE:
            aWidth = 140
            aPicturePath = "CurveContract2.png"
        Case OID_DOWNLOAD_ALL:
            aWidth = 100
            aPicturePath = "CurveDownloadAll2.png"
        Case OID_UPLOAD_ALL:
            aWidth = 100
            aPicturePath = "CurveUploadAll2.png"
        Case OID_ACCEPT_ALL:
            aWidth = 100
            aPicturePath = "CurveAcceptAll2.png"
'        Case OID_ACCEPT:
'            aWidth = 100
'            aPicturePath = "CurveAccept.png"
'        Case OID_CURVE_NAME:
'            aWidth = 0 '
'            aHeight = 0 '
        Case OID_CONTRACT_START_PLUS, OID_CONTRACT_END_PLUS:
            aPicturePath = "CurvePlus.png"
        Case OID_CONTRACT_START_MINUS, OID_CONTRACT_END_MINUS:
            aPicturePath = "CurveMinus.png"
'        Case OID_MIN_CONTRACT_DATE, OID_MAX_CONTRACT_DATE:
'            aWidth = 68
'            aHeight = 16
    End Select
End Sub

Private Sub m_Imager_OnImageBackColor(sender As Object, ByVal aTarget As Integer, bkColor As Long)
'    Select Case aTarget
'        Case OID_MIN_CONTRACT_DATE, OID_MAX_CONTRACT_DATE:
'            'bkColor = m_Sheet.Cells(BSConsts.CURVE_SINGLE_START_ROW, 1).Interior.color
'            bkColor = xlNone 'm_dataRgn.Cells(1, 1).Interior.color
'        Case Else:
            bkColor = RGB(255, 255, 255) 'BSConsts.CURVE_ROW_HEADER_COLOR
'    End Select
End Sub

Private Sub m_Imager_OnImagePlacement(sender As Object, ByVal aTarget As Integer, ByVal aUserData As String, aTop As Single, aLeft As Single, aWidth As Single, aHeight As Single)
 Dim row As Long
 Dim t1 As Variant
 
    t1 = 23
    row = GetColIndex(aUserData)
    aWidth = -1
    aHeight = -1
    
    Select Case aTarget
        Case OID_EDIT_SETTINGS:
            With m_sheet.Cells(4, 1)
                .value = " "
                aTop = .top + 3
                aLeft = .left + 5
            End With
            
        Case OID_CONTRACT_RANGE:
            With m_sheet.Cells(4, 1)
                aTop = .top + 3
                aLeft = .left + IIf(m_params.AllCurvesRD(), 5, 78)
            End With
            
        Case OID_DOWNLOAD_ALL:
            With m_sheet.Cells(5, 1)
                aTop = .top + 3
                aLeft = .left + 5
            End With
            
        Case OID_UPLOAD_ALL:
            With m_sheet.Cells(5, 1)
                aTop = .top + 3
                aLeft = .left + 78
            End With
            
        Case OID_ACCEPT_ALL:
            With m_sheet.Cells(5, 1)
                aTop = .top + 3
                aLeft = .left + IIf(m_params.AllCurvesRD(), 78, 150)
            End With
            
        Case OID_CONTRACT_START_PLUS:
            Call GetContractControlPos(True, True, aTop, aLeft)
        Case OID_CONTRACT_START_MINUS:
            Call GetContractControlPos(True, False, aTop, aLeft)
        Case OID_CONTRACT_END_PLUS:
            Call GetContractControlPos(False, True, aTop, aLeft)
        Case OID_CONTRACT_END_MINUS:
            Call GetContractControlPos(False, False, aTop, aLeft)
    End Select
End Sub

Private Sub GetContractControlPos(ByVal isHead As Boolean, ByVal isPlus As Boolean, aTop As Single, aLeft As Single)
    With m_sheet.Cells(C_FIXED_ROWS - 1, IIf(isHead, C_FIXED_COLS + 1 + m_params.PropertyCount + 1, m_dataRgn.Columns.count))
        aTop = .top + 5
        aLeft = .left + IIf(isHead, 0, .Width) + IIf(isPlus, 10, 20) * IIf(isHead, 1, -1)
    End With
End Sub

'Private Sub GetTailContractControlPos(ByVal isPlus As Boolean, aTop As Single, aLeft As Single)
'    With m_sheet.Cells(C_FIXED_ROWS - 1, m_dataRgn.Columns.count)
'        aTop = .top + 5
'        aLeft = .left + .Width - IIf(isPlus, 10, 20)
'    End With
'End Sub

Private Function GetColIndex(ByVal aUserData As String) As Long
    If aUserData <> vbNullString Then
        GetColIndex = Val(aUserData) + 1
    Else
        GetColIndex = -1
    End If
End Function

Private Sub m_Imager_OnMacro(sender As Object, ByVal aTarget As Integer, ByVal aUserData As String, aMacro As String)
 Dim idx As Long
 Dim curves() As String

    curves = m_params.curves
    idx = GetColIndex(aUserData) - 1
    aMacro = vbNullString

    Select Case aTarget
        Case OID_DOWNLOAD_ALL:
            aMacro = MacroActionStr("MacroDownloadAllS")
        Case OID_ACCEPT_ALL:
            aMacro = MacroActionStr("MacroAcceptAll")
        Case OID_UPLOAD_ALL:
            aMacro = MacroActionStr("MacroUploadAllS")
        Case OID_EDIT_SETTINGS:
            aMacro = MacroActionStr("MacroEditDateSettingsS")
        Case OID_CONTRACT_RANGE:
            aMacro = MacroActionStr("MacroContractS")
        Case OID_CONTRACT_START_PLUS:
            aMacro = CCurveControl.OnPlusMinusAction(CURVE_UI_CONTRACTS_START_PLUS)
        Case OID_CONTRACT_START_MINUS:
            aMacro = CCurveControl.OnPlusMinusAction(CURVE_UI_CONTRACTS_START_MINUS)
        Case OID_CONTRACT_END_PLUS:
            aMacro = CCurveControl.OnPlusMinusAction(CURVE_UI_CONTRACTS_END_PLUS)
        Case OID_CONTRACT_END_MINUS:
            aMacro = CCurveControl.OnPlusMinusAction(CURVE_UI_CONTRACTS_END_MINUS)
'        Case OID_LAST_DOWNLOAD:
'            aMacro = MacroActionStr("MacroDownloadS", CURVE_GRP_NAME, curves(idx), CDDXHelper.NewGUID())
'        Case OID_LAST_UPLOAD:
'            aMacro = MacroActionStr("MacroUploadS", CURVE_GRP_NAME, curves(idx), CDDXHelper.NewGUID())
'        Case OID_ACCEPT:
'            If CCurveControl.ShowAccept(idx) Then
'                aMacro = MacroActionStr("MacroAccept", CURVE_GRP_NAME, curves(idx), CDDXHelper.NewGUID())
'            End If
    End Select
End Sub

Private Sub DrawTimes(ByVal aIndex As Long, ByVal aIsDownload As Boolean)
 Dim tv As Double
 
    If Not CCurveControl.GetAccessTimeToDraw(m_params, aIndex, aIsDownload, tv) Then Exit Sub
    Call CCurveControl.DrawAccessTime(m_dataRgn.Cells(aIndex + 2, 4), tv, aIsDownload, xlLeft)
End Sub

'Private Sub GetContractDates(minDate As String, maxDate As String)
'    minDate = "--- -- ----"
'    maxDate = minDate
'End Sub

Private Sub m_Imager_OnText(sender As Object, ByVal aTarget As Integer, ByVal aUserData As String, aText As String, ByRef aBold As Boolean, ByRef aToolTip As String, ByRef aTop As Long, ByRef aLeft As Long)
 Dim pos As Long
 Dim maxdte As String
 Dim mindte As String
 
    If IsNumeric(aUserData) Then
        pos = CLng(aUserData)
    End If
'    col = 2 * GetColIndex(aUserData)
    
    aText = vbNullString
    aBold = False
    aToolTip = vbNullString
    
'    Select Case aTarget
'        Case OID_DOWNLOAD_ALL:
'        Case OID_ACCEPT_ALL:
'        Case OID_UPLOAD_ALL:
'            'aText = "  Upload All"
'        Case OID_EDIT_DATE:
'            'aText = "  Edit Effective Date"
''        Case OID_CONTRACT:
'        Case OID_ACCEPT:
''            Call DrawVR(pos)
'        Case OID_CURVE_NAME:
'            aToolTip = m_params.GetTooltipByPosition(pos)
'            aTop = m_dataRgn.row + pos + 1
'            aLeft = C_FIXED_COLS
'
''        Case OID_MIN_CONTRACT_DATE:
''            Call GetContractDates(mindte, maxdte)
''            aText = mindte
''        Case OID_MAX_CONTRACT_DATE:
''            Call GetContractDates(mindte, maxdte)
''            aText = maxdte
'    End Select
End Sub

Private Sub AddNewContracts(ByVal aPrior As Integer, dispDates() As Double, ByVal length As Long)
 Dim rgn As range
 Dim splitrows As Long
 Dim splitcols As Long
 
    Call CCurveControl.GetSplits(m_sheet, m_params, splitrows, splitcols)
    splitcols = splitcols + m_params.PropertyCount + 1
    
    If aPrior <= 0 Or aPrior = -2 Then Call AddDataGroup(False)
    
    With m_dataRgn
        Select Case aPrior
            Case -1:
                Set rgn = .offset(, splitcols).Resize(, length)
                Call rgn.EntireColumn.Insert
                rgn.offset(, -length).Interior.ColorIndex = xlNone
                
            Case 1:
                Set rgn = .offset(, .Columns.count - length).Resize(, length)
                Call rgn.EntireColumn.Insert
                Call CCurveControl.Remove4EyesStyle(rgn.offset(, -length))
                
            Case 0:
                Set rgn = .offset(, splitcols).Resize(, length)
                Call rgn.EntireColumn.Insert
                rgn.offset(, -length).Interior.ColorIndex = xlNone
                
            Case -2:
                If .Columns.count = splitcols Then Exit Sub
                Set rgn = .offset(, splitcols).Resize(, 1)
                Call rgn.EntireColumn.Delete
                
                Call AddDataGroup(True)
                Exit Sub
            Case 2:
                If .Columns.count = splitcols Then Exit Sub
                Set rgn = .offset(, .Columns.count).Resize(, 1)
                Call rgn.EntireColumn.Delete

                Exit Sub
        End Select
    End With
    
'    Set rgn = rgn.offset(, -length).Resize(1)
'    Call CCurveControl.SetDateVaules(m_params.granularities, rgn.Resize(, length), dispDates)
'    Call CCurveControl.SetSOCValueFormats(-1, rgn.offset(1).Resize(1), m_params)
    Set rgn = rgn.offset(, -length) '.Resize(1)
    Call CCurveControl.SetDateVaules(m_params.granularities, rgn.Resize(1), dispDates)
    Call CCurveControl.SetSOCValueFormats(-1, rgn.offset(1).Resize(rgn.rows.count - 1), m_params)
    
    Call AddDataGroup(True)
End Sub

Public Function IFNewContracts(ByVal aPrior As Long, ByVal op As Integer, dispDates() As Double) As Boolean
 Dim length As Long
 
    m_flags = m_flags And (Not CURVE_F_SUPPRESS_FINALIZE)
    If CCurveControl.IsEmptyDates(dispDates) Then Exit Function
    
    length = UBound(dispDates) - LBound(dispDates) + 1
    Set m_sheet = ActiveSheet
    Call m_params.FromXML(CCurveControl.GetCurveProperties(m_sheet))
    Call GetRanges
    Call InitImager
    
    Call AddNewContracts(aPrior, dispDates, length)
    Call GetRanges
    
'    Call DrawContractDatesForMP
    Call AddStyle(0)
    Call AddContraControls
End Function

Private Sub AddMD(ByVal oprDateIndex As Long)
    'Call CCurveControl.ResetRangeColor(m_params, m_dataRgn, oprDateIndex)
    Call CCurveControl.PopulateInputs
    Call CalculateDates(m_params)
End Sub

'Private Sub DrawObjectAccept(ByVal aCurveName As String, ByVal aPos As Long)
'    Call DrawVR(aPos)
    
'    If m_params.Readonly(aPos) Then Exit Sub
'    If Not CCPVRStorage.VRExists(m_sheet, aCurveName) Then Exit Sub

'    If Not CCurveControl.ShowAccept(aPos) Then
'        Call CCurveControl.EraseAccepts(m_Imager, aPos)
'        Exit Sub
'    End If
    
'    Call DrawIcon(OID_ACCEPT, aPos, aCurveName, AT_ACCEPT)
'End Sub

Public Sub DrawVR(ByVal cvrNm As String, ByVal cvrIndex As Long)
    m_flags = m_flags Or CURVE_F_SUPPRESS_FINALIZE
    Call PrivateDrawVR(cvrNm, cvrIndex)
End Sub

Private Sub PrivateDrawVR(ByVal cvrNm As String, ByVal cvrIndex As Long)
 Dim rw As Long

    rw = cvrIndex + C_FIXED_ROWS + 1
    
    If cvrNm = vbNullString Then
        ActiveSheet.Cells(rw, C_FIXED_COLS - 1).value = vbNullString
    Else
        Call CCurveControl.DrawCurveVR(GetCurveVR(cvrNm), CDbl(CCurveDates.ParamEntity.OprStartDate), rw, C_FIXED_COLS - 1, xlLeft)
        ActiveSheet.Cells(rw, C_FIXED_COLS - 1).IndentLevel = 1
    End If
End Sub

Public Sub IFReLayout()
    m_flags = m_flags And (Not CURVE_F_SUPPRESS_FINALIZE)
    
    Call GetRanges
    Set m_Imager.sheet = m_sheet
    If m_params.granularities = 0 Then
        Call m_params.FromXML(CCurveControl.GetCurveProperties(m_sheet))
    End If
    
    Call CCurveControl.ClearImagesV1(m_dataRgn)
    
    With m_dataRgn
        If .rows.count >= 1 Then
            .Cells(1, 3).Resize(.rows.count) = vbNullString
            .Cells(1, 5).Resize(.rows.count) = vbNullString
        End If
    End With
    
    Call AddStyle(1)
    Call DrawControls
End Sub

Private Function GetCurveVR(cvrNm As String) As String
 Dim vr As Variant

    vr = CCPVRStorage.GetVR(ActiveSheet, CURVE_VR_L_CURVE, cvrNm, CCurveDates.ParamEntity.flagValues, Int(CDbl(CCurveDates.ParamEntity.OprStartDate)), 0, vbNullString, vbNullString)
    If IsEmpty(vr) Then Exit Function

    GetCurveVR = CCurveControl.ContainsStatusToAccept2(vr)
End Function

Private Function HasVR() As Boolean
 Dim cvrs() As String
 Dim k As Long
        
    cvrs = CCurveDates.ParamEntity.curves
    
    For k = LBound(cvrs) To UBound(cvrs)
        HasVR = IIf(Len(GetCurveVR(cvrs(k))) > 0, True, False)
        If HasVR Then Exit Function
    Next
End Function

Private Sub LockRange(ByVal curveIdx As Long, rdonly As Boolean)
 Dim c As Long

    With m_dataRgn
        c = .Columns.count - (m_params.PropertyCount + 1) - C_FIXED_COLS
        If c <= 0 Then Exit Sub
        
        .Cells(curveIdx + 1, C_FIXED_COLS + 1).Resize(1, c).Locked = rdonly
    End With

    'Call CCurveControl.Add4EyesStyle(m_dataRgn)
End Sub

Private Sub LockOprDate(rdonly As Boolean)
    m_sheet.Cells(2, 2).Locked = rdonly Or Not m_params.IsFlag(CURVE_FLG_EDIT_DATES)
End Sub

Public Sub IFUpdatePermissions(permissions() As Long)
 Dim curves() As String
 Dim rdonly As Boolean
 Dim k As Long
 Dim c As Long
 
    m_flags = m_flags Or CURVE_F_SUPPRESS_FINALIZE
    
    Set m_sheet = ActiveSheet
    If m_Imager Is Nothing Then Set m_Imager = New CCurveImageText
    Set m_Imager.sheet = m_sheet
    Set m_params = CCurveDates.ParamEntity

    Call GetRanges
    
    curves = m_params.curves
    rdonly = Not CCurveControl.HasWriteableCurves(m_sheet, m_params, permissions)
    
    With m_Imager
        .AlternativeText = vbNullString

        If rdonly Then
            Call CCurveControl.DeleteCurveIconsByID(m_Imager, OID_ACCEPT_ALL, OID_UPLOAD_ALL, OID_CONTRACT_RANGE, OID_CONTRACT_START_PLUS, OID_CONTRACT_START_MINUS, OID_CONTRACT_END_PLUS, OID_CONTRACT_END_MINUS)
        
        Else
            If .FindImage(OID_ACCEPT_ALL) Is Nothing Then Call CCurveControl.AddAcceptAll(m_Imager)
            
            If .FindImage(OID_UPLOAD_ALL) Is Nothing Then
                Call .Draw(OID_UPLOAD_ALL, vbNullString)

                Call .Draw(OID_CONTRACT_START_PLUS, vbNullString)
                Call .Draw(OID_CONTRACT_START_MINUS, vbNullString)
                Call .Draw(OID_CONTRACT_END_PLUS, vbNullString)
                Call .Draw(OID_CONTRACT_END_MINUS, vbNullString)
            End If
        End If
    End With
    
    Call LockOprDate(rdonly)
    m_Imager.DeleteExsitingBeforeAdd = False
    
    For k = LBound(permissions) To UBound(permissions)
        If permissions(k) >= 0 Then
            rdonly = IIf(permissions(k) = 0, True, False)
            Call LockRange(k, rdonly)
        End If
    Next
    
    With m_dataRgn
        If .rows.count > 1 Then
            c = C_FIXED_COLS + 1 + m_params.PropertyCount + 1
            k = .Columns.count - (c - 1)
            If k > 0 Then Call CCurveControl.AddProtection(permissions, .Cells(2, c).Resize(.rows.count - 1, k))
        End If
    End With
End Sub
Attribute VB_Name = "CCPTimeSeries"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Option Base 0

Private m_sheet As Worksheet
Private WithEvents m_Imager As CCurveImageText
Attribute m_Imager.VB_VarHelpID = -1
Private m_params As New CCurveParams
Private m_dataRgn As range
Private m_HeaderRgn As range
Private m_flags As Long
'
Private Const C_FIXED_ROWS As Long = 6
'
Private Const OID_DOWNLOAD_ALL As Integer = 1
Private Const OID_UPLOAD_ALL As Integer = 2
Private Const OID_EDIT_DATE As Integer = 3
Private Const OID_OPR_RANGE As Integer = 4
Private Const OID_LAST_DOWNLOAD As Integer = 5
Private Const OID_LAST_UPLOAD As Integer = 6
Private Const OID_DELETE As Integer = 8
Private Const OID_CURVE_NAME As Integer = 9
Private Const OID_SORT As Integer = 10
Private Const OID_OPR_START_PLUS As Integer = 11
Private Const OID_OPR_START_MINUS As Integer = 12
Private Const OID_OPR_END_PLUS As Integer = 13
Private Const OID_OPR_END_MINUS As Integer = 14
Private Const OID_OPR_MAX_DATE As Integer = 15
Private Const OID_OPR_MIN_DATE As Integer = 16

Private Sub GetRanges()
    If m_sheet Is Nothing Then Set m_sheet = ActiveSheet
    Set m_dataRgn = CCurveControl.GetCurveRange(m_sheet)
    
    If Not m_dataRgn Is Nothing Then
        With m_dataRgn
            Set m_HeaderRgn = m_sheet.Cells(1, 1).Resize(.row - 1, .Columns.count)
        End With
    End If
End Sub

Private Sub AddStyle()
 Dim k As Long
 Dim f As Variant
 Dim b As Boolean
 Dim rgn As range
 Dim cols As Long
 Dim row As Long
 
    With m_HeaderRgn
        .offset(1).Resize(C_FIXED_ROWS - 1).Interior.color = RGB(255, 255, 255)
        .rows(2).Interior.color = CURVE_ROW_HEADER_COLOR
        
        For k = 1 To 2
            .Cells(2, k).Interior.color = RGB(255, 255, 255)
        Next
        
        If .rows.count > C_FIXED_ROWS Then
            .offset(C_FIXED_ROWS).Resize(.rows.count - C_FIXED_ROWS).Interior.color = CURVE_ROW_HEADER_COLOR
            
            If IsMultiObs Then
                If .rows.count >= 7 Then
                    Set rgn = .offset(C_FIXED_ROWS).Resize(2, 1)
                    rgn.MergeCells = True
                    rgn.VerticalAlignment = xlCenter
                End If
            End If
            
            .offset(C_FIXED_ROWS).Resize(.rows.count - C_FIXED_ROWS, 2).Interior.color = RGB(255, 255, 255)
        End If
    End With

    cols = m_HeaderRgn.Columns.count
    
    With m_HeaderRgn.offset(1).Resize(C_FIXED_ROWS - 1)
        .Borders(xlInsideHorizontal).LineStyle = xlContinuous
        .Borders(xlInsideHorizontal).Weight = xlHairline
        .Borders(xlInsideHorizontal).color = RGB(&HD9, &HD9, &HD9)
    End With
    
    With m_HeaderRgn.offset(1, 2).Resize(C_FIXED_ROWS - 1, cols - 2)
        .Borders(xlInsideVertical).LineStyle = xlContinuous
        .Borders(xlInsideVertical).Weight = IIf(k = 2 Or k = cols, xlThin, xlHairline)
        .Borders(xlInsideVertical).color = RGB(&HD9, &HD9, &HD9)
        
        .Borders(xlEdgeRight).LineStyle = xlContinuous
        .Borders(xlEdgeRight).Weight = xlThin
    End With
    
    For row = 6 To m_HeaderRgn.rows.count
        For k = 1 To cols
            With m_HeaderRgn.Cells(row, k)
 
                If k <> 1 Then
                    .Borders(xlEdgeTop).LineStyle = xlContinuous
                    .Borders(xlEdgeTop).Weight = xlHairline
                    .Borders(xlEdgeTop).color = RGB(&HD9, &HD9, &HD9)
                    
                    .Borders(xlEdgeBottom).LineStyle = xlContinuous
                    .Borders(xlEdgeBottom).Weight = xlHairline
                    .Borders(xlEdgeBottom).color = RGB(&HD9, &HD9, &HD9)
                End If

                .Borders(xlEdgeRight).LineStyle = xlContinuous
                .Borders(xlEdgeRight).Weight = IIf(k = cols, xlThin, xlHairline)
                If k <> cols Then
                    .Borders(xlEdgeRight).color = RGB(&HD9, &HD9, &HD9)
                End If

            End With
        Next
    Next
    
    row = m_HeaderRgn.rows.count
    With m_HeaderRgn.rows(row)
        .Borders(xlEdgeBottom).LineStyle = xlContinuous
        .Borders(xlEdgeBottom).Weight = xlThin
    End With
    
    With m_dataRgn
        If IsMultiObs Then
            For k = 1 To 2
                .rows(1).RowHeight = 18
            Next
            
            For k = 2 + 1 To .Columns.count
                With .Cells(1, k).Resize(2)
                    Call .Merge
                    .HorizontalAlignment = xlCenter
                End With
            Next
        Else
            .rows(1).RowHeight = 34
            With .rows(1)
                .HorizontalAlignment = xlCenter
                .VerticalAlignment = xlCenter
    '            .WrapText = False
                .Orientation = 0
                .AddIndent = False
                .IndentLevel = 0
                .ShrinkToFit = False
                .ReadingOrder = xlContext
                .MergeCells = False
            End With
        End If
        
        For Each f In .Columns
            f.ColumnWidth = IIf(f.column <= 2, 18 * IIf(IsMultiObs, 1, 2), 34)
        Next
        
    End With
    
    If Not IsMultiObs Then
        m_sheet.Columns(2).EntireColumn.Hidden = True
    End If
    
    Call AddDataStyle(-1, -1)
End Sub

Private Sub AddDataStyle(ByVal dayCount As Long, ByVal op As Integer)
 Dim k As Long
 Dim tmp As Long
 
    With m_dataRgn

        If op = -2 Then
            With .offset(.rows.count - 1).Resize(1)
                .Borders(xlEdgeBottom).color = RGB(210, 210, 210)
            End With
            
        ElseIf op = -1 Then
            .offset(, 1).Resize(, .Columns.count - 1).Borders(xlInsideVertical).Weight = xlHairline
    
            If IsMultiObs And .rows.count > 2 Then
                With .Cells(3, 1).Resize(.rows.count - 2, 2)
                    .Borders(xlInsideVertical).Weight = xlHairline
                End With
            End If
            
            If m_dataRgn.rows.count > IIf(IsMultiObs, 2, 1) Then
                With m_dataRgn.offset(IIf(IsMultiObs, 2, 1)).Resize(m_dataRgn.rows.count - IIf(IsMultiObs, 2, 1), 2)
                    If IsMultiObs Then
                        .HorizontalAlignment = xlLeft
                        .IndentLevel = 1
                    Else
                        .HorizontalAlignment = xlCenter
                    End If
                End With
            End If
    
            .Borders(xlEdgeRight).LineStyle = xlContinuous
            .Borders(xlEdgeRight).Weight = xlThin
    
            .Borders(xlInsideHorizontal).LineStyle = xlContinuous
            .Borders(xlInsideHorizontal).Weight = xlThin
            .Borders(xlInsideHorizontal).color = RGB(210, 210, 210)

            .Borders(xlEdgeBottom).color = RGB(210, 210, 210)
    
        ElseIf op = CURVE_UI_CONTRACTS_START_PLUS Or op = CURVE_UI_CONTRACTS_END_PLUS Then
            With .offset(IIf(op = CURVE_UI_CONTRACTS_END_PLUS, .rows.count - dayCount, IIf(IsMultiObs, 2, 1))).Resize(dayCount)
                .Borders(xlInsideVertical).Weight = xlHairline
            End With
     
            .Borders(xlEdgeRight).LineStyle = xlContinuous
            .Borders(xlEdgeRight).Weight = xlThin
            
            With .offset(IIf(op = CURVE_UI_CONTRACTS_END_PLUS, .rows.count - dayCount, 1)).Resize(dayCount)
                .Borders(xlInsideHorizontal).color = RGB(210, 210, 210)
                .Borders(xlEdgeBottom).color = RGB(210, 210, 210)
            End With
            
            If IsMultiObs Then
                If op = CURVE_UI_CONTRACTS_START_PLUS Then
                    With .Cells(3, 1).Resize(dayCount, 2)
                        .Characters.Font.size = .Cells(3, 3).Font.size
                        .IndentLevel = 1
                        .HorizontalAlignment = xlLeft
                    End With
                End If
            End If
        End If
    
    
''        If m_params.rowCount > 1 Then
''             .Cells(IIf(IsMultiObs, 3, 2), 1).Resize(m_params.rowCount - 1).Columns(1).Interior.color = BSConsts.CURVE_ROW_HEADER_COLOR
''        End If
''
''        .Interior.color = BSConsts.CURVE_ROW_HEADER_COLOR
''
''        k = IIf(IsMultiObs, 2, 1)
''
''        If .rows.count > k Then
''            With .offset(k, IIf(m_params.IsFlag(CURVE_FLG_EDIT_DATES), 0, 2)).Resize(.rows.count - k, .Columns.count - IIf(m_params.IsFlag(CURVE_FLG_EDIT_DATES), 0, 2))
''                .FormatConditions.Delete
''
''                .FormatConditions.Add Type:=xlExpression, Formula1:="=Mod(Row(),2)=0"
''                .FormatConditions(1).Interior.color = CURVE_ROW_ODD_COLOR
''                .FormatConditions.Add Type:=xlExpression, Formula1:="=Mod(Row(),2)<>0"
''                .FormatConditions(2).Interior.color = CURVE_ROW_EVEN_COLOR
''
''            End With
''        End If
        
        tmp = IIf(IsMultiObs, 2, 1)
        If .rows.count > tmp Then
            For k = 3 To .Columns.count
                If m_params.Readonly(k - 3) Then
                 .offset(tmp, k - 1).Resize(.rows.count - tmp, 1).Interior.color = CURVE_COLUMN_HEADER_COLOR2
                End If
            Next
        
        End If

        If IsMultiObs Then
            With .Cells(2, 1).Resize(1, 2)
                .Borders(xlInsideVertical).LineStyle = xlContinuous
                .Borders(xlInsideVertical).Weight = xlThin
                .Borders(xlInsideVertical).color = RGB(210, 210, 210)
            
                .Borders(xlInsideHorizontal).LineStyle = xlContinuous
                .Borders(xlInsideHorizontal).Weight = xlThin
                .Borders(xlInsideHorizontal).color = RGB(210, 210, 210)
                
                .Characters.Font.size = 9
                .HorizontalAlignment = xlCenter
            End With
            .Cells(2, 1) = "Opr Date"
            .Cells(2, 2) = "Curve Type"
        End If
    End With
End Sub

Private Sub InitImager()
    With m_Imager
        Set .sheet = m_sheet
'        Set .ZEComp = m_ZEComp
    End With
End Sub

Public Function IFDelete(sheet As Worksheet, ByVal aGroupName As String, ByVal aCurveName As String)
 Dim idx As Long

    m_flags = m_flags And (Not CURVE_F_SUPPRESS_FINALIZE)
    Set m_sheet = sheet
    Set m_Imager.sheet = m_sheet

    Set m_params = CCurveDates.ParamEntity
    Call GetRanges
    
    idx = m_params.GetCurvePosition(aCurveName)
    If idx < 0 Then Exit Function
    IFDelete = True
    
    Call sheet.Columns(idx + 3).Delete(xlShiftToLeft)
    
    Call CCurveControl.DeleteCurveIcons(aCurveName, AT_SORT, AT_DELETE, AT_DOWNLOAD, AT_UPLOAD, AT_ACCEPT, AT_NAME)
    
    'strange in Excel ?
    With m_params
        Call .RemoveCurve(idx)
        .ColumnCount = .ColumnCount - 1
    End With
    
    Call CCurveControl.SaveCurveProperties(m_sheet, m_params)
 
    If m_params.GetCurveCount() > 0 Then
        Call GetRanges
        
        If m_params.AllCurvesRD() Then
            Call CCurveControl.DeleteCurveIconsByID(m_Imager, OID_ACCEPT_ALL, OID_OPR_MAX_DATE, OID_OPR_MIN_DATE, OID_OPR_END_MINUS, OID_OPR_END_PLUS, OID_OPR_START_MINUS, OID_OPR_START_PLUS, OID_DELETE, OID_OPR_RANGE, OID_UPLOAD_ALL)
        End If
        
        Call CCurveControl.DeleteProperties(m_HeaderRgn, C_FIXED_ROWS)
    Else
        Call OnDeletion
    End If
End Function

Private Sub OnDeletion()
 Dim p As CustomProperty
 Dim shp As Shape
 
    m_sheet.Cells.Delete
    For Each shp In m_sheet.Shapes
        shp.Delete
    Next
    
    For Each p In m_sheet.CustomProperties
        p.Delete
    Next
    
'    Call RemoveMD(-1)
End Sub

Private Sub AdjustDataRanges()
    Call GetRanges
    If m_dataRgn.rows.count <= 1 Then Exit Sub
    
    With m_dataRgn
        Call CCurveControl.RearrangeDatesTS(IIf(IsMultiObs, .offset(1).Resize(.rows.count - 1), m_dataRgn), m_params)
    End With
End Sub

Public Function IFNew(data As ZEWSProxy.ICurveResult, ud As CCurveUserData) As Boolean
 Dim isnew As Boolean
' Dim oldParams As CCurveParams
 Dim dr As Long
 Dim oldrows As Long
 
    m_flags = m_flags And (Not CURVE_F_SUPPRESS_FINALIZE)
    Call m_params.FromXML(data.value)
    
    Set m_sheet = CCurveControl.GetSheet(m_params, True, isnew)
    If m_sheet Is Nothing Then Exit Function ' failed to find the workbook
    
    If Not isnew Then
        oldrows = CCurveDates.ParamEntity.rowCount
'        Set oldParams = GetOldParamsObject()
        Call AdjustDataRanges
        
        Call CCurveControl.AdjustPropNDataAreas(m_params, 6)
'        Call CCurveGranularity.RemoveDropdowns(m_sheet)
    End If
    Call CCurveDates.AssignTargetSheet(m_sheet)
    Set CCurveDates.ParamEntity = m_params
 
    Call CCurveControl.SaveCurveProperties(m_sheet, m_params)
    Call InitImager
    
    Call CDDXCurve.SetFindCriterion(BSConsts.DDX_PID, m_sheet, ud.Criterion)

    Call DrawHeader
    Call DrawProperties
    m_dataRgn.Font.ColorIndex = 1
    
    Call AddStyle
    Call ReadFromFile(-1)
    Call DrawObjects
    
    Call AddMD(-1)
    
    Call CalculateDates
    
    If Not isnew Then 'And Not oldParams Is Nothing Then
        dr = oldrows - m_params.rowCount
        If dr > 0 Then
            With m_dataRgn.offset(m_params.rowCount).Resize(dr)
                .Clear
                .Locked = True
            End With
        End If
    End If
    
    IFNew = True
End Function

Private Sub CalculateDates()
    If Not m_params.IsFlag(CURVE_FLG_EDIT_DATES) Then Exit Sub
    
    If Application.Calculation = xlCalculationAutomatic Then Exit Sub
    With m_dataRgn
        Call .offset(, 2).Resize(1, .Columns.count - 2).Calculate
    End With
End Sub

'Private Function GetOldParamsObject() As CCurveParams
' Dim oldParams As CCurveParams
' Dim ps As String
'
'    ps = CCurveControl.GetCurveProperties(m_sheet)
'    If Len(ps) = 0 Then Exit Function
'
'    Set oldParams = New CCurveParams
'    Call oldParams.FromXML(ps)
'    Set GetOldParamsObject = oldParams
'End Function

Public Function IFRefresh(data As ZEWSProxy.ICurveResult) As Boolean
 Dim oldParams As CCurveParams
 
    m_flags = m_flags And (Not CURVE_F_SUPPRESS_FINALIZE)
    Set m_sheet = ActiveSheet
    Call m_params.FromXML(data.value)
    
    Call CCurveControl.ClearAllImages(m_sheet)
    Call CCurveControl.AdjustPropNDataAreas(m_params, 6)
    
    Set oldParams = New CCurveParams
    
    With oldParams
        Call .FromXML(CCurveControl.GetCurveProperties(m_sheet))
    End With
    
    m_params.LastUploadTime = oldParams.LastUploadTime
    Call CCurveControl.SaveCurveProperties(m_sheet, m_params)

    Call GetRanges
    Call CCurveControl.ClearUnusedArea(m_dataRgn, m_HeaderRgn)
    
    Call InitImager
    
    Call DrawHeader
    Call DrawProperties
    m_dataRgn.Font.ColorIndex = 1
    Call ReadFromFile(-1)
    
    Call AddStyle
    Call DrawObjects
 
    Call AddMD(-1)
    
    IFRefresh = True
End Function

Private Sub RefreshVROnUpload(ByVal cvrIdx As Long, ByVal readComments As Boolean)
 Dim rgn As range
 Dim rws As Long

    rws = IIf(CDDXHelper.IsFlag(m_params.flagValues, CURVE_FLG_MULTIOBS), 2, 1)
    Set rgn = m_dataRgn.offset(rws, 2 + IIf(cvrIdx >= 0, cvrIdx, 0)).Resize(m_dataRgn.rows.count - rws, IIf(cvrIdx >= 0, 1, m_dataRgn.Columns.count - 2))
    
    If CDDXCurve.FourEyesActive Then
        If readComments Then Call CCurveControl.RefreshCommentsAfterUploaded(rgn, False)
    Else
       Call CCurveControl.VRColorValues(vbNullString, rgn, m_params, True)
       Call CCurveControl.EraseAccepts(m_Imager, cvrIdx)
    End If
End Sub

Public Function IFUpload(data As ZEWSProxy.ICurveResult, ByVal curvePos As Long) As Boolean
 Dim k As Long
 Dim curveIdx() As Long
 Dim count As Long

    m_flags = m_flags And (Not CURVE_F_SUPPRESS_FINALIZE)
    Set m_sheet = ActiveSheet
    Call m_params.FromXML(CCurveControl.GetCurveProperties(m_sheet))
    Call GetRanges
    
    curveIdx = CCurveControl.GetUploadedItms(m_params, m_sheet, data, True, count)
    If count > 0 Then
        Call CCurveControl.SaveCurveProperties(m_sheet, m_params)

        For k = LBound(curveIdx) To UBound(curveIdx)
            Call DrawTimes(curveIdx(k), False)
        Next
    End If
    
    Call RefreshVROnUpload(curvePos - 1, True)
    Call CDDXCurve.NotifyCurveUploadResult(DDX_PID, data, m_params)
    
    IFUpload = True
End Function

Public Function IFRefreshIndividual(data As ZEWSProxy.ICurveResult, ByVal RefreshTarget As Integer) As Boolean
 Dim p As New CCurveParams
 Dim index As Long
 Dim curves() As String
 Dim downloadtimes() As String
 Dim target As String
 Dim newtime As String
 
    m_flags = m_flags And (Not CURVE_F_SUPPRESS_FINALIZE)
    Call p.FromXML(data.value)
    
    Set m_sheet = ActiveSheet
    
    With p
        curves = .curves
        target = curves(LBound(curves))
        downloadtimes = .LastDownloadTime()
        newtime = downloadtimes(LBound(downloadtimes))
    End With
    Set p = Nothing
    
    Set m_params = CCurveDates.ParamEntity
    With m_params
'        Call .FromXML(CCurveControl.GetCurveProperties(m_sheet))
            
        Call GetRanges

        curves = .curves
        downloadtimes = .LastDownloadTime
        For index = LBound(curves) To UBound(curves)
            If curves(index) = target Then
                downloadtimes(index) = newtime
                .LastDownloadTime = downloadtimes
                Exit For
            End If
        Next
        If index > UBound(curves) Then Exit Function
    End With
    
    Call InitImager
'    Call DrawObjectDownload(target, index)
    Call DrawTimes(index, True)
    Call ReadFromFile(index)
    
    Call CCurveControl.SaveCurveProperties(m_sheet, m_params)
    
    Call AddMD(index)
    
    Call GetRanges
    Call CCurveControl.EraseAccepts(m_Imager, index)
    
    IFRefreshIndividual = True
End Function

Private Sub DrawHeader()
 Dim r As Long
 
    Call CCurveControl.SetSplits(m_sheet, m_params.PropertyCount + C_FIXED_ROWS + IIf(IsMultiObs, 2, 1), 2)
    Call GetRanges
    
    Call CCurveControl.InsertTitle(m_sheet)
        
' set header info
    With m_HeaderRgn
        .Cells(1, 1).RowHeight = 40
        For r = 2 To .rows.count
             .Cells(r, 1).RowHeight = 18
        Next
        
        m_sheet.rows(1).Interior.color = RGB(&H0, &H52, &H93)
        
        With .rows(1)
            .Borders(xlEdgeBottom).LineStyle = xlContinuous
            .Borders(xlEdgeBottom).Weight = xlThick
            .Borders(xlEdgeBottom).color = RGB(&H5E, &HB6, &HE4)
        End With
        
        With .Cells(.rows.count + 1, 1).Resize(1, .Columns.count)
            .Borders(xlEdgeTop).LineStyle = xlContinuous
            .Borders(xlEdgeTop).Weight = xlHairline
        End With
    End With
End Sub

Private Sub DrawProperties()
 Dim k As Long
 Dim j As Long
 Dim Values() As String
 Dim cvs() As String
 Dim row As Long
 Dim col As Long
 
    With m_params
        Values = .PropertyNames
        If Len(Join(Values)) = 0 Then Exit Sub
        
        m_HeaderRgn.Cells((C_FIXED_ROWS + 1), 1).Resize(UBound(Values) - LBound(Values) + 1).value = vbNullString
        
'        If .IsFlag(CURVE_FLG_MULTIOBS) Then
'            With m_HeaderRgn.Cells((C_FIXED_ROWS + 1), 1)
'                .value = "  Property"
'                .Characters.Font.Bold = True
'                .Characters.Font.SIZE = 9
'            End With
'        End If
        For k = LBound(Values) To UBound(Values)
            With m_HeaderRgn.Cells(k + (C_FIXED_ROWS + 1), IIf(.IsFlag(CURVE_FLG_MULTIOBS), 2, 1))
                .value = CCurveControl.AddApostrophe(Values(k)) + " "
                .Characters.Font.size = 8
                .HorizontalAlignment = xlRight
                .VerticalAlignment = xlCenter
            End With
        Next

        cvs = .curves
        For k = LBound(cvs) To UBound(cvs)
            Values = .PropertyValues(cvs(k))
            
            For j = LBound(Values) To UBound(Values)
                row = C_FIXED_ROWS + j + 1
                col = k + 1 + 2
                With m_HeaderRgn.Cells(row, col)
                    .value = CCurveControl.AddApostrophe(Values(j))
                    .Characters.Font.size = 8
                    .Characters.Font.Bold = False
                    .HorizontalAlignment = xlLeft
                    .VerticalAlignment = xlCenter
                End With
            Next
        Next
    End With
End Sub

Private Sub DrawIcon(ByVal aObjectID As Integer, ByVal aPos As Long, ByVal aCurveName As String, ByVal aAlternativeText As String)
    With m_Imager
        .AlternativeText = CCurveControl.GetAltText(aCurveName, aAlternativeText)
        Call .Draw(aObjectID, CStr(aPos))
    End With
End Sub

Private Sub DrawObjectDownload(ByVal aCurveName As String, ByVal aPos As Long)
    Call DrawIcon(OID_LAST_DOWNLOAD, aPos, aCurveName, AT_DOWNLOAD)
End Sub

Private Sub DrawObjectUpload(ByVal aCurveName As String, ByVal aPos As Long)
    Call DrawIcon(OID_LAST_UPLOAD, aPos, aCurveName, AT_UPLOAD)
End Sub

'Private Sub DrawDateRange()
'    Call CCurveControl.DrawStyledTexts(m_sheet, 2, 1, " Opr Dates:  ", CCurveDates.DisplayTime(m_params.OprStartDate, False) + "  " + "-" + "  " + CCurveDates.DisplayTime(m_params.OprEndDate, False))
'End Sub

Private Sub DrawInterval()
 Dim dtz As Boolean
 
    dtz = CCurveGranularity.IsGranularity(m_params.granularities, CURVE_GRANULARITY_HOURLY) Or CCurveGranularity.IsGranularity(m_params.granularities, CURVE_GRANULARITY_MINUTELY)
    dtz = IIf(dtz And m_params.TZName <> vbNullString And (m_params.IsFlag(CURVE_FLG_DST_ADJUST_START) Or m_params.IsFlag(CURVE_FLG_DST_ADJUST_END)), True, False)
    Call CCurveControl.DrawStyledTexts(m_sheet, 2, 1, " Interval:  ", CCurveGranularity.GetGranularityName(m_params.granularities), IIf(dtz, "   (" + m_params.TZName + ")", vbNullString))
End Sub

Private Sub DrawContractDatesForMP()
    With m_Imager
        Call .Draw(OID_OPR_MAX_DATE, vbNullString)
        Call .Draw(OID_OPR_MIN_DATE, vbNullString) '
    End With
End Sub

Private Sub DrawObjects()
 Dim k As Long
 Dim curves() As String
' Dim groups() As String

'    Call DrawDateRange
    Call DrawInterval
    
    With m_Imager
        .AlternativeText = vbNullString
        
        Call .Draw(OID_DOWNLOAD_ALL, vbNullString)
        Call .Draw(OID_EDIT_DATE, vbNullString)
        If Not m_params.AllCurvesRD() Then
            Call CCurveControl.AddAcceptAll(m_Imager)
        
            Call .Draw(OID_UPLOAD_ALL, vbNullString) '
            If Not IsMultiObs And Not IsMultiObs Then
                Call .Draw(OID_SORT, vbNullString)
            End If
            Call .Draw(OID_OPR_RANGE, vbNullString)
            Call DrawContractDatesForMP
        
            Call .Draw(OID_OPR_START_PLUS, vbNullString)
            Call .Draw(OID_OPR_START_MINUS, vbNullString)
            Call .Draw(OID_OPR_END_PLUS, vbNullString)
            Call .Draw(OID_OPR_END_MINUS, vbNullString)
        End If

    End With

    curves = m_params.curves
    For k = LBound(m_params.curves) To UBound(m_params.curves)
        
        Call DrawObjectDownload(curves(k), k)
        If Not m_params.Readonly(k) Then
            Call DrawObjectUpload(curves(k), k)
            If Not m_params.IsFlag(CURVE_FLG_EDIT_DATES) And Not IsMultiObs Then
                Call DrawIcon(OID_SORT, k, curves(k), AT_SORT)
            End If
        End If
        
        Call DrawIcon(OID_DELETE, k, curves(k), AT_DELETE)

        Call DrawCurveName(k, curves(k))
        Call DrawIcon(OID_CURVE_NAME, k, curves(k), AT_NAME)

        Call DrawObjectAccept(curves(k), k)
    Next
End Sub

Private Sub DrawCurveName(ByVal aPos As Long, ByVal aCurveName As String)
    aPos = aPos + 3
    
    With m_HeaderRgn.Cells(C_FIXED_ROWS, aPos)
        .Characters.Font.Bold = True
        .Characters.Font.size = 8
        '
'        .WrapText = True
        .VerticalAlignment = xlCenter
        .HorizontalAlignment = xlLeft
'        .WrapText = False
        .Orientation = 0
        .AddIndent = False
        .IndentLevel = 0
        .ShrinkToFit = False
        .ReadingOrder = xlContext
        .NumberFormat = "@"
        .value = CCurveControl.AddApostrophe(aCurveName)
    End With
End Sub

Private Sub ReadFromFile(ByVal aCurveIndex As Long)
 Dim ro As Long
 
    ro = IIf(IsMultiObs, 1, 0)
    With m_dataRgn
        If aCurveIndex < 0 Then
            Call CCurveControl.ReadFile(aCurveIndex, .offset(ro).Resize(.rows.count - ro, 1), .offset(, 2).Resize(.rows.count, .Columns.count - 2), m_params)
        Else
            Call CCurveControl.ReadFile(aCurveIndex, Nothing, .offset(, 2 + aCurveIndex).Resize(.rows.count, 1), m_params)
        End If
    End With
    
    Call GetRanges
End Sub

Private Sub Class_Initialize()
    Set m_Imager = New CCurveImageText
End Sub

Private Sub Class_Terminate()
    Call ProtectSheet
    Set m_Imager = Nothing
End Sub

Private Sub ProtectSheet()
 Dim r As Long
 Dim k As Long
 Dim startp As Long
 
    If CDDXHelper.IsFlag(m_flags, CURVE_F_SUPPRESS_FINALIZE) Then Exit Sub
    
    If m_params.GetCurveCount() <= 0 Then
        Call CCurveControl.Unprotect(m_sheet)
        Exit Sub
    End If

    If m_sheet Is Nothing Then Exit Sub
    If m_sheet.ProtectContents Then Exit Sub
    
    m_sheet.UsedRange.Cells.Locked = True
    If IsMultiObs Then
        Call CCurveGranularity.EnableDropdowns(m_sheet, Not m_params.AllCurvesRD())
    End If
    
    Call LockOprDate(m_params.AllCurvesRD())
    
    If Not m_dataRgn Is Nothing Then
        With m_dataRgn
            r = .rows.count - IIf(IsMultiObs, 2, 1)
            If r > 0 Then
'                For k = LBound(m_params.curves) To UBound(m_params.curves)
'                    If Not m_params.Readonly(k) Then
'                        .offset(IIf(IsMultiObs, 2, 1), k + 2).Resize(r, 1).Locked = False
'                    End If
'                Next
                
                startp = -1
                For k = LBound(m_params.curves) To UBound(m_params.curves)
                    If m_params.Readonly(k) Then
                        If startp >= 0 Then
                            .Cells(IIf(IsMultiObs, 2, 1) + 1, startp + 3).Resize(r, k - startp).Locked = False
                        End If
                        startp = -1
                    Else
                        If startp = -1 Then startp = k
                        If k = UBound(m_params.curves) Then
                            .Cells(IIf(IsMultiObs, 2, 1) + 1, startp + 3).Resize(r, k - startp + 1).Locked = False
                        End If
                    End If
                Next
                
                With .offset(IIf(IsMultiObs, 2, 1)).Resize(r, IIf(IsMultiObs, 2, 1))
                    .Locked = m_params.AllCurvesRD() Or Not m_params.IsFlag(CURVE_FLG_EDIT_DATES)
                    .NumberFormat = CDDXCurve.GetContractDateFormat(m_params.granularities)
                End With

                With .offset(IIf(IsMultiObs, 2, 1), 2).Resize(r, .Columns.count - 2)
'                    .NumberFormat = "General"
                    .HorizontalAlignment = xlRight
                End With
            End If
        End With
        
        Call CCurveControl.Add4EyesStyle(m_dataRgn)
    End If
    
    Call CCurveControl.Protect(m_sheet)
End Sub

Private Sub m_Imager_OnImage(sender As Object, ByVal aTarget As Integer, ByVal aUserData As String, aPicturePath As String, ByRef aWidth As Single, ByRef aHeight As Single)
    aPicturePath = vbNullString
    aWidth = 95
    aHeight = 18
    
    Select Case aTarget
        Case OID_EDIT_DATE:
            aWidth = 140
            aPicturePath = "CurveEditSettings.png" '"CurveEditDate.png"
        Case OID_OPR_RANGE:
            aWidth = 140
            aPicturePath = "CurveOprRange.png"
        Case OID_LAST_DOWNLOAD:
            aWidth = 110
            aPicturePath = "CurveLastDownload.png"
        Case OID_DOWNLOAD_ALL:
            aWidth = 100
            aPicturePath = "CurveDownloadAll.png"
        Case OID_ACCEPT_ALL:
            aWidth = 100
            aPicturePath = "CurveAcceptAll.png"
        Case OID_ACCEPT:
            aWidth = 100
            aPicturePath = "CurveAccept.png"
        Case OID_LAST_UPLOAD:
            aWidth = 110
            aPicturePath = "CurveLastUpload.png"
        Case OID_UPLOAD_ALL:
            aWidth = 100
            aPicturePath = "CurveUploadAll.png"
        Case OID_DELETE:
            aPicturePath = "CurveDelete.png"
        Case OID_SORT:
            aPicturePath = IIf(aUserData = vbNullString, "filter.png", "filter.png")
        Case OID_CURVE_NAME:
            aWidth = 0 '
            aHeight = 0 '
        Case OID_OPR_START_PLUS, OID_OPR_END_PLUS:
            aPicturePath = "CurvePlus.png"
        Case OID_OPR_START_MINUS, OID_OPR_END_MINUS:
            aPicturePath = "CurveMinus.png"
        Case OID_OPR_MIN_DATE, OID_OPR_MAX_DATE:
            aWidth = 68
            aHeight = 16
    End Select
End Sub

Private Sub m_Imager_OnImageBackColor(sender As Object, ByVal aTarget As Integer, bkColor As Long)
    Select Case aTarget
        Case OID_OPR_MIN_DATE, OID_OPR_MAX_DATE:
            bkColor = xlNone 'm_dataRgn.Cells(1, 1).Interior.color
        Case Else:
            bkColor = RGB(255, 255, 255) 'BSConsts.CURVE_ROW_HEADER_COLOR
    End Select
End Sub

Private Sub m_Imager_OnImagePlacement(sender As Object, ByVal aTarget As Integer, ByVal aUserData As String, aTop As Single, aLeft As Single, aWidth As Single, aHeight As Single)
 Dim col As Long
 Dim t1 As Variant
 
    t1 = IIf(IsMultiObs, 6, 23)
    col = GetColIndex(aUserData) + 2
    aWidth = -1
    aHeight = -1
    
    Select Case aTarget
        Case OID_EDIT_DATE:
            With m_sheet.Cells(C_FIXED_ROWS - 1, 1)
                aTop = .top + 3
                aLeft = .left + 5
            End With
        Case OID_OPR_RANGE:
            With m_dataRgn.Cells(1, 1)
                .value = " "
                If IsMultiObs Then
                    aTop = .top + t1 - 4
                    aLeft = .left + .Width \ 2
                Else
                    aTop = .top + 6
                    aLeft = .left + 5
                End If
            End With
        Case OID_OPR_START_PLUS:
            With m_dataRgn.Cells(1, 1)
                If IsMultiObs Then
                    aTop = .top + t1
                    aLeft = .left + 10
                Else
                    aTop = .top + t1
                    aLeft = .left + 6
                End If
            End With
        Case OID_OPR_START_MINUS:
            With m_dataRgn.Cells(1, 1)
                If IsMultiObs Then
                    aTop = .top + t1
                    aLeft = .left + 20
                Else
                    aTop = .top + t1
                    aLeft = .left + 16
                End If
            End With
        Case OID_OPR_END_PLUS:
            With m_dataRgn.Cells(1, IIf(IsMultiObs, 2, 1))
                If IsMultiObs Then
                    aTop = .top + t1
                    aLeft = .left + .Width - 18
                Else
                    aTop = .top + t1
                    aLeft = .left + .Width / 2 - 10
                End If
            End With
        Case OID_OPR_END_MINUS:
            With m_dataRgn.Cells(1, IIf(IsMultiObs, 2, 1))
                If IsMultiObs Then
                    aTop = .top + t1
                    aLeft = .left + .Width - 28
                Else
                    aTop = .top + t1
                    aLeft = .left + .Width / 2 - 20
                End If
            End With
           
        Case OID_OPR_MIN_DATE:
            With m_dataRgn.Cells(1, 1)
                aTop = .top + t1 - 1
                aLeft = .left + 26
            End With
        Case OID_OPR_MAX_DATE:
            With m_dataRgn.Cells(1, 2)
                aTop = .top + t1 - 1
                aLeft = .left + 20
            End With
        Case OID_SORT:
            With m_dataRgn.Cells(1, IIf(aUserData = vbNullString, 2, col))
                aTop = .top + 11
                aLeft = .left + .Width - IIf(aUserData = vbNullString, 14, 14)
            End With
        Case OID_LAST_DOWNLOAD:
            With m_sheet.Cells(3, col)
                aTop = .top + 3
                aLeft = .left + 5
            End With
        Case OID_DOWNLOAD_ALL:
            With m_sheet.Cells(C_FIXED_ROWS, 1)
                aTop = .top + 3
                aLeft = .left + 5
            End With
        Case OID_ACCEPT_ALL:
            With m_sheet.Cells(C_FIXED_ROWS, 1)
                aTop = .top + 3
                aLeft = .left + 74 + 62
            End With
        Case OID_UPLOAD_ALL:
            With m_sheet.Cells(C_FIXED_ROWS, 1)
                aTop = .top + 3
                aLeft = .left + 74
            End With
        Case OID_LAST_UPLOAD:
            With m_sheet.Cells(3, col)
                aTop = .top + 3
                aLeft = .left + 74
            End With
        Case OID_ACCEPT:
            With m_sheet.Cells(5, col)
                aTop = .top + 3
                aLeft = .left + .Width / 2 + 15
            End With
        Case OID_DELETE:
            With m_sheet.Cells(2, col)
                aTop = .top + 3
                aLeft = .left + .Width - 10 '+ 78
            End With
            aHeight = 8
            aWidth = 8
        Case OID_CURVE_NAME:
            With m_sheet.Cells(C_FIXED_ROWS, col)
                aTop = .top + 4
                aLeft = .left + 5
                'aWidth = 2 * .Width
            End With
    End Select
End Sub

Private Function GetColIndex(ByVal aUserData As String) As Long
    If aUserData <> vbNullString Then
        GetColIndex = Val(aUserData) + 1
    Else
        GetColIndex = -1
    End If
End Function

Private Sub m_Imager_OnMacro(sender As Object, ByVal aTarget As Integer, ByVal aUserData As String, aMacro As String)
 Dim idx As Integer
 Dim curves() As String
 Dim cn As String
 
    curves = m_params.curves
    idx = GetColIndex(aUserData) - 1
    aMacro = vbNullString

    Select Case aTarget
        Case OID_DOWNLOAD_ALL:
            aMacro = MacroActionStr("MacroDownloadAllS")
        Case OID_ACCEPT_ALL:
            aMacro = MacroActionStr("MacroAcceptAll")
        Case OID_UPLOAD_ALL:
            aMacro = MacroActionStr("MacroUploadAllS")
        Case OID_EDIT_DATE:
            aMacro = MacroActionStr("MacroEditDateSettingsS")
        Case OID_OPR_RANGE:
            aMacro = MacroActionStr("MacroContractS")
        Case OID_OPR_START_PLUS:
            aMacro = CCurveControl.OnPlusMinusAction(CURVE_UI_CONTRACTS_START_PLUS)
        Case OID_OPR_START_MINUS:
            aMacro = CCurveControl.OnPlusMinusAction(CURVE_UI_CONTRACTS_START_MINUS)
        Case OID_OPR_END_PLUS:
            aMacro = CCurveControl.OnPlusMinusAction(CURVE_UI_CONTRACTS_END_PLUS)
        Case OID_OPR_END_MINUS:
            aMacro = CCurveControl.OnPlusMinusAction(CURVE_UI_CONTRACTS_END_MINUS)
        Case OID_SORT:
            If idx >= 0 Then cn = curves(idx)
            aMacro = MacroActionStr("MacroSortS", CURVE_GRP_NAME, cn, CDDXHelper.NewGUID())
        Case OID_LAST_DOWNLOAD:
            aMacro = MacroActionStr("MacroDownloadS", CURVE_GRP_NAME, curves(idx), CDDXHelper.NewGUID())
'        Case OID_ACCEPT:
'            If CCurveControl.ShowAccept(idx) Then
'                aMacro = MacroActionStr("MacroAccept", CURVE_GRP_NAME, curves(idx), CDDXHelper.NewGUID())
'            End If
        Case OID_LAST_UPLOAD:
            aMacro = MacroActionStr("MacroUploadS", CURVE_GRP_NAME, curves(idx), CDDXHelper.NewGUID())
        Case OID_DELETE:
            aMacro = MacroActionStr("MacroDeleteS", CURVE_GRP_NAME, curves(idx), CDDXHelper.NewGUID())
    End Select
End Sub

Private Sub DrawTimes(ByVal aIndex As Long, ByVal aIsDownload As Boolean)
 Dim tv As Double
 
    If Not CCurveControl.GetAccessTimeToDraw(m_params, aIndex, aIsDownload, tv) Then Exit Sub
    Call CCurveControl.DrawAccessTime(m_sheet.Cells(C_FIXED_ROWS - 2, aIndex + 3), tv, aIsDownload, xlLeft)
End Sub

Private Sub GetContractDates(minDate As String, maxDate As String)
    minDate = "--- -- ----"
    maxDate = minDate
End Sub

Private Sub m_Imager_OnText(sender As Object, ByVal aTarget As Integer, ByVal aUserData As String, aText As String, ByRef aBold As Boolean, ByRef aToolTip As String, ByRef aTop As Long, ByRef aLeft As Long)
 Dim col As Long
 Dim pos As Long
 Dim maxdte As String
 Dim mindte As String
 
    If IsNumeric(aUserData) Then
        pos = CLng(aUserData)
    End If
    col = 2 * GetColIndex(aUserData)
    
    aText = vbNullString
    aBold = False
    aToolTip = vbNullString
    
    Select Case aTarget
        Case OID_DOWNLOAD_ALL:
        Case OID_ACCEPT_ALL:
        Case OID_UPLOAD_ALL:

        Case OID_LAST_DOWNLOAD:
            Call DrawTimes(pos, True)
        Case OID_LAST_UPLOAD:
            Call DrawTimes(pos, False)
        Case OID_ACCEPT:
            Call PrivateDrawVR(pos)
        Case OID_CURVE_NAME:
            aToolTip = m_params.GetTooltipByPosition(pos)
            aTop = C_FIXED_ROWS
            aLeft = pos + 3
            
        Case OID_OPR_MIN_DATE:
            Call GetContractDates(mindte, maxdte)
            aText = mindte
        Case OID_OPR_MAX_DATE:
            Call GetContractDates(mindte, maxdte)
            aText = maxdte
    End Select
End Sub

Private Sub AddContracts(ByVal length As Long, ByVal op As Integer)
 Dim rgn As range
 Dim k As Long
 Dim gv As Long
 Dim cv As String
 
    If IsMultiObs And (op = CURVE_UI_CONTRACTS_START_PLUS Or op = CURVE_UI_CONTRACTS_END_PLUS) Then
        Call CCurveType.CreateContents(m_params.curveTypes)
        Call CCurveControl.GetDefaultGranularityNCurveType(m_params.GetFirstWritableCurve(), gv, cv)
    End If
        
    With m_dataRgn
        Select Case op
            Case CURVE_UI_CONTRACTS_START_PLUS:
                Set rgn = .Cells(IIf(IsMultiObs, 3, 2), 1).Resize(length, .Columns.count)
                Call rgn.rows.Insert(shift:=xlShiftDown)
                
                If IsMultiObs Then
                    For k = 1 To length
                        Call CCurveType.AddDropdown(.Cells(k + 2, 2), cv)
                    Next
                End If
                
                m_params.rowCount = m_params.rowCount + length
                
            Case CURVE_UI_CONTRACTS_END_PLUS:
                Set rgn = .Cells(.rows.count + 1, 1).Resize(length, .Columns.count)
                Call rgn.rows.Insert(shift:=xlShiftDown)
                Call CCurveControl.Remove4EyesStyle(rgn.offset(-length))
                
                m_params.rowCount = m_params.rowCount + length
                
                If IsMultiObs Then
                    For k = 1 To length
                        Call CCurveType.AddDropdown(m_dataRgn.Cells(m_params.rowCount + 2 - k, 2), cv)
                    Next
                End If
                
            Case CURVE_UI_CONTRACTS_START_MINUS:
                If .rows.count <= IIf(IsMultiObs, 2, 1) Then Exit Sub
                Set rgn = .offset(IIf(IsMultiObs, 2, 1)).Resize(1)
                
                If IsMultiObs Then
                    Call CCurveGranularity.RemoveDropdown(rgn.Cells(1, 2))
                End If
                
                Call rgn.rows.Delete(shift:=xlShiftUp)
                m_params.rowCount = m_params.rowCount - 1
                Exit Sub
                
            Case CURVE_UI_CONTRACTS_END_MINUS:
                If .rows.count <= IIf(IsMultiObs, 2, 1) Then Exit Sub
                Set rgn = .offset(.rows.count - 1).Resize(1)
                
                If IsMultiObs Then
                    Call CCurveGranularity.RemoveDropdown(rgn.Cells(1, 2))
                End If
                
                Call rgn.rows.Delete(shift:=xlShiftUp)
                m_params.rowCount = m_params.rowCount - 1
                
                Exit Sub
        End Select
    End With
    
    Set rgn = rgn.offset(-length).Resize(length)
    Call CCurveControl.SetSOCValueFormats(-1, rgn.offset(, 2).Resize(, rgn.Columns.count - 2), m_params)
End Sub

Private Sub AddContracts2(ByVal aPrior As Long, dispDates() As Double, ByVal length As Long)
 Dim rgn As range
 
    With m_dataRgn
        Select Case aPrior
            Case -1:
                Set rgn = .offset(1).Resize(length)
                Call rgn.rows.Insert(shift:=xlShiftDown)

            Case 1:
                Set rgn = .offset(.rows.count - length).Resize(length)
                Call rgn.rows.Insert(shift:=xlShiftDown)
                Call CCurveControl.Remove4EyesStyle(rgn.offset(-length))
                
            Case 0:
                Set rgn = .offset(1).Resize(length)
                Call rgn.rows.Insert(shift:=xlShiftDown)
                
            Case -2:
                If .rows.count = 1 Then Exit Sub
                
                Set rgn = .offset(1).Resize(1)
                Call rgn.rows.Delete(shift:=xlShiftUp)
                Exit Sub
            Case 2:
                If .rows.count = 1 Then Exit Sub
                
                Set rgn = .offset(.rows.count).Resize(1)
                Call rgn.rows.Delete(shift:=xlShiftUp)
                Exit Sub
        End Select
    End With
    
    'Call CCurveControl.SetDateVaules(m_params.granularities, rgn.offset(-length).Resize(length, 1), dispDates)
    Set rgn = rgn.offset(-length).Resize(length)
    Call CCurveControl.SetDateVaules(m_params.granularities, rgn.Resize(, 1), dispDates)
    Call CCurveControl.SetSOCValueFormats(-1, rgn.offset(, 2).Resize(, rgn.Columns.count - 2), m_params)
End Sub

Public Function IFNewContracts(ByVal dayCount As Long, ByVal op As Integer, dispDtes() As Double) As Boolean
 Dim length As Long
 
    m_flags = m_flags And (Not CURVE_F_SUPPRESS_FINALIZE)
    Set m_sheet = ActiveSheet
    Call m_params.FromXML(CCurveControl.GetCurveProperties(m_sheet))
    
    Call GetRanges
    Call InitImager
        
    If m_params.IsFlag(CURVE_FLG_EDIT_DATES) Then
        
        If op Mod 2 = 0 And m_dataRgn.rows.count = 1 Then
            Exit Function
        End If
        
        Call AddContracts(dayCount, op)
        
        Call CCurveControl.SaveCurveProperties(m_sheet, m_params)
        
        Call GetRanges
        
        With m_dataRgn
            If .rows.count > 1 Then
                .offset(1).Resize(.rows.count - 1, 1).NumberFormat = CDDXDates.SystemDateFormat
            End If
        End With
        
        Call DrawContractDatesForMP
        
        If op = 1 Or op = 3 Then
            Call AddDataStyle(dayCount, op)
        ElseIf op = 2 Then
            Call AddDataStyle(dayCount, -1)
        ElseIf op = 4 Then
            Call AddDataStyle(dayCount, -2)
        End If
    
    Else
        If CCurveControl.IsEmptyDates(dispDtes) Then Exit Function
        length = UBound(dispDtes) - LBound(dispDtes) + 1
        
        Call AddContracts2(dayCount, dispDtes, length)
        
        Call GetRanges
        
        Call DrawContractDatesForMP
        
        If dayCount = -1 Then
            Call AddDataStyle(length, 1)
        ElseIf dayCount = 1 Then
            Call AddDataStyle(length, 3)
        ElseIf dayCount = 2 Then
            Call AddDataStyle(length, -2)
        Else
            Call AddDataStyle(length, -1)
        End If
        
    End If
    
    If Not m_params.IsFlag(CURVE_FLG_EDIT_DATES) Then
        If CCurveControl.RefreshOprRange(m_params, m_sheet) Then
'            Call DrawDateRange
        End If
    End If
End Function

Private Sub AddMD(ByVal oprDateIndex As Long)
    Call CCurveControl.ResetRangeColor(m_params, m_dataRgn, oprDateIndex)
    Call CCurveControl.PopulateInputs
End Sub

Public Function IFSort(ByVal aGroupName As String, ByVal aCurveName As String) As Boolean
 Dim sorter As CCurveSort
 Dim pos As Long
 
    m_flags = m_flags And (Not CURVE_F_SUPPRESS_FINALIZE)
    Set m_sheet = ActiveSheet
    Set m_params = CCurveControl.GetParams(m_sheet)
    Call GetRanges
    
    With m_dataRgn
        If .Columns.count < 3 Or .rows.count <= 2 Then Exit Function
    End With

    pos = m_params.GetCurvePosition(aCurveName)
    Set sorter = New CCurveSort
    
    With m_dataRgn
        IFSort = sorter.Execute(.offset(1).Resize(.rows.count - 1), IIf(aCurveName = vbNullString, 1, pos + 3), m_params)
    End With
    
    Set sorter = Nothing
    If Not IFSort Then Exit Function
     

    Call GetRanges
    Call AddStyle
End Function

Private Property Get IsMultiObs() As Boolean
    IsMultiObs = m_params.IsFlag(CURVE_FLG_MULTIOBS)
End Property

Private Sub DrawObjectAccept(ByVal aCurveName As String, ByVal aPos As Long)
'    If m_params.Readonly(aPos) Then Exit Sub
'    If Not CCPVRStorage.VRExists(m_sheet, aCurveName) Then Exit Sub
'
'    Call DrawIcon(OID_ACCEPT, aPos, aCurveName, AT_ACCEPT)
End Sub

Public Sub DrawVR(ByVal aIndex As Long)
    m_flags = m_flags Or CURVE_F_SUPPRESS_FINALIZE
    Call PrivateDrawVR(aIndex)
End Sub

Private Sub PrivateDrawVR(ByVal aIndex As Long)
 
End Sub

Public Sub IFReLayout()
    m_flags = m_flags And (Not CURVE_F_SUPPRESS_FINALIZE)
    Call GetRanges
    Set m_Imager.sheet = m_sheet
    If m_params.granularities = 0 Then
        Call m_params.FromXML(CCurveControl.GetCurveProperties(m_sheet))
    End If
    
    Call CCurveControl.ClearImagesV1(m_dataRgn)
    
    With m_HeaderRgn
        .Cells(3, 3).Resize(, .Columns.count - 2) = vbNullString
    End With
    
    Call AddStyle
    Call DrawObjects
End Sub

Private Sub LockRange(ByVal curveIdx As Long, rdonly As Boolean)
 Dim r As Long

    With m_dataRgn
        r = .rows.count - IIf(IsMultiObs, 2, 1)
        If r <= 0 Then Exit Sub
        
        .Cells(IIf(IsMultiObs, 2, 1) + 1, curveIdx + 3 + 1).Resize(r, 1).Locked = rdonly
    End With
    
    'Call CCurveControl.Add4EyesStyle(m_dataRgn)
End Sub

Private Sub LockOprDate(rdonly As Boolean)
    m_sheet.Cells(2, 2).Locked = rdonly Or Not m_params.IsFlag(CURVE_FLG_EDIT_DATES)
End Sub

Public Sub IFUpdatePermissions(permissions() As Long)
 Dim curves() As String
 Dim rdonly As Boolean
 Dim k As Long
 Dim imgl As Scripting.Dictionary
 Dim r As Long
 Dim c As Long
 
    m_flags = m_flags Or CURVE_F_SUPPRESS_FINALIZE
    
    Set m_sheet = ActiveSheet
    If m_Imager Is Nothing Then Set m_Imager = New CCurveImageText
    Set m_Imager.sheet = m_sheet
    Set m_params = CCurveDates.ParamEntity

    Call GetRanges
    
    curves = m_params.curves
    rdonly = Not CCurveControl.HasWriteableCurves(m_sheet, m_params, permissions)
    
    With m_Imager
        .AlternativeText = vbNullString

        If rdonly Then
            Call CCurveControl.DeleteCurveIconsByID(m_Imager, OID_ACCEPT_ALL, OID_UPLOAD_ALL)
        
        Else
            If .FindImage(OID_ACCEPT_ALL) Is Nothing Then Call CCurveControl.AddAcceptAll(m_Imager)
            
            If .FindImage(OID_UPLOAD_ALL) Is Nothing Then
                Call .Draw(OID_UPLOAD_ALL, vbNullString)
            End If
        End If
    End With
    
    Call LockOprDate(rdonly)
    m_Imager.DeleteExsitingBeforeAdd = False
    
    For k = LBound(permissions) To UBound(permissions)
        If permissions(k) >= 0 Then
            rdonly = IIf(permissions(k) = 0, True, False)
            
            If rdonly Then
                If imgl Is Nothing Then
                    Set imgl = New Scripting.Dictionary
                    Call CCurveControl.DeleteCurveIconsByAlt(imgl, vbNullString)
                End If
                Call CCurveControl.DeleteCurveIconsByAlt(imgl, curves(k), AT_UPLOAD)
            Else
                Call DrawObjectUpload(curves(k), k)
            End If

            Call LockRange(k, rdonly)
        End If
    Next
    
    With m_dataRgn
        If .rows.count > IIf(m_params.IsFlag(CURVE_FLG_MULTIOBS), 2, 1) Then
            r = IIf(m_params.IsFlag(CURVE_FLG_MULTIOBS), 3, 2)
            c = 3
            k = .Columns.count - (c - 1)
            If k > 0 Then Call CCurveControl.AddProtection(permissions, .Cells(r, c).Resize(.rows.count - (r - 1), k))
        End If
    End With
End Sub
Attribute VB_Name = "CCPTimeSeriesTRANS2"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Option Base 0

Private m_sheet As Worksheet
Private WithEvents m_Imager As CCurveImageText
Attribute m_Imager.VB_VarHelpID = -1
Private m_params As New CCurveParams
Private m_dataRgn As range
Private m_HeaderRgn As range
Private m_flags As Long
'
Private Const C_FIXED_COLS As Long = 6
Private Const C_FIXED_ROWS As Long = 6
'
Private Const OID_DOWNLOAD_ALL As Integer = 1
Private Const OID_UPLOAD_ALL As Integer = 2
Private Const OID_EDIT_SETTINGS As Integer = 3
Private Const OID_OPR_RANGE As Integer = 4
''Private Const OID_LAST_DOWNLOAD As Integer = 5
''Private Const OID_LAST_UPLOAD As Integer = 6
'Private Const OID_VIEW_HISTORY As Integer = 7
''Private Const OID_DELETE As Integer = 8
'Private Const OID_CURVE_NAME As Integer = 9
Private Const OID_OPR_START_PLUS As Integer = 11
Private Const OID_OPR_START_MINUS As Integer = 12
Private Const OID_OPR_END_PLUS As Integer = 13
Private Const OID_OPR_END_MINUS As Integer = 14
'Private Const OID_OPR_MAX_DATE As Integer = 15
'Private Const OID_OPR_MIN_DATE As Integer = 16

Private Const ALT_OPR_HEAD_PLUS As String = "New opr"
Private Const ALT_OPR_HEAD_MINUS As String = "Delete first opr"
Private Const ALT_OPR_TAIL_PLUS As String = "New opr to the end"
Private Const ALT_OPR_TAIL_MINUS As String = "Delete last opr"

Private m_hasvr As Boolean

Private Sub GetRanges()
    If m_params Is Nothing Then Exit Sub
    
    If m_sheet Is Nothing Then Set m_sheet = ActiveSheet
    Set m_dataRgn = CCurveControl.GetCurveRange(m_sheet)
    
    If Not m_dataRgn Is Nothing Then
        With m_dataRgn
            Set m_HeaderRgn = m_sheet.Cells(1, 1).Resize(.row - 1, .Columns.count)
        End With
    End If
End Sub

Private Sub ResizeVRCol(ByVal isvr As Boolean, ByVal colNum As Long)
    If colNum = C_FIXED_COLS - 1 Then
        m_sheet.Columns(colNum).ColumnWidth = IIf(isvr, 32, 2) '0.01)
    Else
        m_sheet.Columns(colNum).ColumnWidth = IIf(isvr, 10, 4)
    End If
End Sub

Private Sub AddStyle(ByVal isNewFlg As Long)
 Dim k As Long
 Dim f As Variant
 Dim row As Long
 Dim dtacols As Long
 
    With m_HeaderRgn
        dtacols = .Columns.count - C_FIXED_COLS
        If dtacols > 0 Then Call .offset(, C_FIXED_COLS).Resize(, dtacols).Clear
        
        .Cells(1, 1).RowHeight = 40
        For f = 2 To .rows.count
             .Cells(f, 1).RowHeight = 18
        Next
        
        m_sheet.rows(1).Interior.color = RGB(&H0, &H52, &H93)
        
        With .rows(1)
            .Borders(xlEdgeBottom).LineStyle = xlContinuous
            .Borders(xlEdgeBottom).Weight = xlThick
            '.Borders(xlEdgeBottom).ColorIndex = 10
            .Borders(xlEdgeBottom).color = RGB(&H5E, &HB6, &HE4)
        End With
        
        If dtacols > 0 Then
            With .offset(, C_FIXED_COLS).Resize(, dtacols)
                .Borders(xlEdgeRight).LineStyle = XlLineStyle.xlLineStyleNone
            End With
        End If
 
        If .Columns.count > C_FIXED_COLS Then
            With .offset(, C_FIXED_COLS).Resize(, .Columns.count - C_FIXED_COLS)
                .Borders(xlEdgeRight).LineStyle = XlLineStyle.xlLineStyleNone
            End With
        End If
        
        .offset(1).Interior.color = RGB(255, 255, 255)

        .Columns(.Columns.count).Borders(xlEdgeRight).LineStyle = xlContinuous
        .Columns(.Columns.count).Borders(xlEdgeRight).Weight = xlThin
    End With

    With m_HeaderRgn.offset(1).Resize(m_HeaderRgn.rows.count - 1, C_FIXED_COLS)

        .Borders(xlInsideHorizontal).LineStyle = xlContinuous
        .Borders(xlInsideHorizontal).Weight = xlHairline
        .Borders(xlInsideHorizontal).color = RGB(&HD9, &HD9, &HD9)
        
        .Borders(xlEdgeBottom).LineStyle = xlContinuous
        .Borders(xlEdgeBottom).Weight = xlHairline
        .Borders(xlEdgeBottom).color = RGB(&HD9, &HD9, &HD9)

    End With
    
    row = m_HeaderRgn.rows.count
    With m_HeaderRgn.rows(row)
        .Borders(xlEdgeBottom).LineStyle = xlContinuous
        .Borders(xlEdgeBottom).Weight = xlThin
    End With
    
    m_hasvr = HasVR()
    
    With m_dataRgn
        .Cells(1, 1).RowHeight = 34
    
        .rows(1).Interior.color = CURVE_COLUMN_HEADER_COLOR2
        
        With .rows(1)
            .HorizontalAlignment = xlCenter
            .VerticalAlignment = xlCenter
            .WrapText = False
            .Orientation = 0
            .AddIndent = False
            .IndentLevel = 0
            .ShrinkToFit = False
            .ReadingOrder = xlContext
            '.MergeCells = False
        End With

        For Each f In .Columns
            Select Case f.column
                Case 1, 2:
                    If isNewFlg = 1 Then f.ColumnWidth = 13
                Case 3:
                    If isNewFlg = 1 Then Call ResizeVRCol(m_hasvr, f.column)
                Case 4:
                    If isNewFlg = 1 Then f.ColumnWidth = 16
                Case C_FIXED_COLS - 1:
                    If isNewFlg = 1 Then Call ResizeVRCol(m_hasvr, f.column) 'IIf(CCurveControl.ShowAcceptAll() And Not m_params.AllCurvesRD(), 32, 8)
                Case C_FIXED_COLS:
                    If isNewFlg = 1 Then f.ColumnWidth = IIf(m_hasvr, 4, 3) 'CCurveControl.GetNameWidth(m_params)
                Case Else:
                    If isNewFlg = 1 Or (f.column > C_FIXED_COLS + m_params.PropertyCount) Then
                        f.ColumnWidth = 20
                    End If
            End Select
     
            Select Case f.column
                Case 1, 2, 4:
'                    f.Borders(xlEdgeRight).LineStyle = xlContinuous
'                    f.Borders(xlEdgeRight).Weight = xlHairline
                Case Is >= C_FIXED_COLS:
                    f.Borders(xlEdgeRight).LineStyle = xlContinuous
                    f.Borders(xlEdgeRight).Weight = IIf(f.column = .Columns.count, xlThin, xlHairline)
            End Select
        Next
        
        With .offset(1, 1).Resize(.rows.count - 1, 3)
            .Borders(xlEdgeRight).LineStyle = xlContinuous
            .Borders(xlEdgeRight).Weight = xlHairline
        End With
'
        With .offset(1).Resize(.rows.count - 1)
            .Borders(xlInsideHorizontal).LineStyle = xlContinuous
            .Borders(xlInsideHorizontal).Weight = xlThin
            .Borders(xlInsideHorizontal).color = RGB(210, 210, 210)
            
            .Borders(xlEdgeBottom).LineStyle = xlContinuous
            .Borders(xlEdgeBottom).Weight = xlThin
            .Borders(xlEdgeBottom).color = RGB(210, 210, 210)
        End With
'
''        For k = 2 To .rows.count
''             .offset(k - 1, C_FIXED_COLS).Resize(1, .Columns.count - C_FIXED_COLS).Interior.color = _
''                            IIf(m_params.Readonly(k - 2), BSConsts.CURVE_COLUMN_HEADER_COLOR2, IIf((k Mod 2 = 1), BSConsts.CURVE_ROW_ODD_COLOR, CURVE_ROW_EVEN_COLOR))
''        Next
''
''        For k = 2 To .rows.count
''             .offset(k - 1, C_FIXED_COLS).Resize(1, m_params.PropertyCount + 1).Interior.color = IIf(m_params.Readonly(k - 2), BSConsts.CURVE_COLUMN_HEADER_COLOR2, BSConsts.CURVE_COLUMN_HEADER_COLOR)
''        Next
        
        .offset(1).Resize(.rows.count - 1, C_FIXED_COLS).Interior.color = RGB(&HFF, &HFF, &HFF)
    End With
End Sub

Private Sub AddDataGroup(ByVal isGroup As Boolean)
    If isGroup Then
        If m_params.PropertyCount = 0 Then isGroup = False
    End If
    If m_params.PropertyCount > 0 Then
        Call CCurveHelper.GroupColumns(m_sheet, C_FIXED_COLS + 1, m_params.PropertyCount + C_FIXED_COLS, isGroup)
    End If
End Sub

Private Sub AddGroups()
    Call CCurveHelper.RemoveAllGroups(m_sheet)
    
    Call CCurveHelper.GroupColumns(m_sheet, 4, 5, True)
    Call AddDataGroup(True)
    
    Call CCurveHelper.CollapseGroups(m_sheet)
End Sub

Private Sub InitImager()
    With m_Imager
        Set .sheet = m_sheet
'        Set .ZEComp = m_ZEComp
    End With
End Sub

Public Function IFDelete(sheet As Worksheet, ByVal aGroupName As String, ByVal aCurveName As String)
 Dim idx As Long
 
    m_flags = m_flags And (Not CURVE_F_SUPPRESS_FINALIZE)
    Set m_sheet = sheet
    Set m_Imager.sheet = m_sheet

    Set m_params = CCurveDates.ParamEntity
    Call GetRanges
    
    idx = m_params.GetCurvePosition(aCurveName)
    If idx < 0 Then Exit Function
   
    IFDelete = True

    Call m_sheet.rows(m_dataRgn.row + idx + 1).Delete(xlShiftUp)
    
    Call CCPVRStorage.DeleteCurve(m_sheet, aCurveName)
    If Not CCPVRStorage.VRExists(m_sheet, vbNullString) Then Call CCurveControl.EraseAcceptAll2
    
    With m_params
        Call .RemoveCurve(idx)
        .ColumnCount = .ColumnCount - 1

    End With
    
    Call CCurveControl.SaveCurveProperties(m_sheet, m_params)
    
    If m_params.GetCurveCount() > 0 Then
        Call GetRanges
        
        If m_params.AllCurvesRD() Then
            Call CCurveControl.DeleteCurveIconsByID(m_Imager, OID_ACCEPT_ALL, OID_OPR_END_MINUS, OID_OPR_RANGE, OID_OPR_END_PLUS, OID_OPR_START_MINUS, OID_OPR_START_PLUS, OID_UPLOAD_ALL)
        End If
        
        If CCurveControl.DeletePropertiesTRANS(m_dataRgn) > 0 Then
            Call AddGroups
        End If
    Else
        Call OnDeletion
    End If
End Function

Private Sub OnDeletion()
 Dim p As CustomProperty
 Dim shp As Shape
 
    m_sheet.Cells.Delete
    For Each shp In m_sheet.Shapes
        shp.Delete
    Next
    
    For Each p In m_sheet.CustomProperties
        p.Delete
    Next
End Sub

'Private Function GetOldParamsObject() As CCurveParams
' Dim oldParams As CCurveParams
' Dim ps As String
'
'    ps = CCurveControl.GetCurveProperties(m_sheet)
'    If Len(ps) = 0 Then Exit Function
'
'    Set oldParams = New CCurveParams
'    Call oldParams.FromXML(ps)
'    Set GetOldParamsObject = oldParams
'End Function

Private Sub AdjustDataRanges(oldParams As CCurveParams)
    Call GetRanges
    If m_dataRgn.rows.count <= 1 Then Exit Sub
    If m_dataRgn.Columns.count <= C_FIXED_COLS Then Exit Sub
    
    Call CCurveControl.RearrangeDatesTS(m_dataRgn.offset(, C_FIXED_COLS).Resize(, m_dataRgn.Columns.count - C_FIXED_COLS), oldParams)
End Sub

Public Function IFNew(data As ZEWSProxy.ICurveResult, ud As CCurveUserData) As Boolean
 Dim isnew As Boolean
' Dim oldParams As CCurveParams
 Dim dr As Long
 Dim oldrows As Long
 
    m_flags = m_flags And (Not CURVE_F_SUPPRESS_FINALIZE)
    With m_params
        Call .FromXML(data.value)
    End With
    
    Set m_sheet = CCurveControl.GetSheet(m_params, True, isnew)
    If m_sheet Is Nothing Then Exit Function ' failed to find the workbook
    
    If Not isnew Then
'        Set oldParams = GetOldParamsObject()
        oldrows = CCurveDates.ParamEntity.rowCount
        Call AdjustDataRanges(CCurveDates.ParamEntity)
        
        Call CCurveControl.AdjustPropNDataAreasTRANS(CCurveDates.ParamEntity, m_params)
    End If
    Call CCurveDates.AssignTargetSheet(m_sheet)
    Set CCurveDates.ParamEntity = m_params
 
    Call CCurveControl.SaveCurveProperties(m_sheet, m_params)
    Call InitImager
        
    Call CDDXCurve.SetFindCriterion(BSConsts.DDX_PID, m_sheet, ud.Criterion)
    
    If isnew Then
        Call DrawHeader
    Else
        Call GetRanges
    End If
    
    Call DrawProperties
    Call DrawData(True)

    Call AddStyle(1)
    Call AddGroups
    
    Call DrawControls
    Call AddMD(-1)
    
    If Not isnew Then 'And Not oldParams Is Nothing Then
        dr = oldrows - m_params.rowCount
        If dr > 0 Then
            With m_dataRgn.offset(, m_dataRgn.Columns.count).Resize(, dr)
                .Clear
                .Locked = True
            End With
            With m_HeaderRgn.offset(1, m_HeaderRgn.Columns.count).Resize(m_HeaderRgn.rows.count - 1, dr)
                .Clear
                .Locked = True
            End With
        End If
    End If
    
    IFNew = True
End Function

Public Function IFRefresh(data As ZEWSProxy.ICurveResult) As Boolean
 Dim oldParams As CCurveParams
 
    m_flags = m_flags And (Not CURVE_F_SUPPRESS_FINALIZE)
    Set m_sheet = ActiveSheet
    Call CCurveControl.ClearAllImages(m_sheet)
    Call m_sheet.Cells.Clear
    
    Call m_params.FromXML(data.value)
    
    Set oldParams = New CCurveParams
    Call oldParams.FromXML(CCurveControl.GetCurveProperties(m_sheet))
    m_params.LastUploadTime = oldParams.LastUploadTime
    Call CCurveControl.SaveCurveProperties(m_sheet, m_params)
    Set oldParams = Nothing
    
    Call GetRanges

    Call InitImager
    
'    Call DrawHeader
    Call DrawProperties
    Call DrawData(True)
    
    Call AddStyle(1)
    Call AddGroups
    
    Call DrawControls

    Call AddMD(-1)
    
    IFRefresh = True
End Function

Private Sub RefreshVROnUpload(ByVal cvrIdx As Long, ByVal readComments As Boolean)
 Dim rgn As range
 Dim cols As Long
 Dim isvr As Boolean
 
    cols = C_FIXED_COLS + CCurveControl.HoriWidthTRANS(m_params)
    If cvrIdx >= 0 Then
        Set rgn = m_dataRgn.offset(cvrIdx + 1, cols).Resize(1, m_dataRgn.Columns.count - cols)
    Else
        Set rgn = m_dataRgn.offset(1, cols).Resize(m_dataRgn.rows.count - 1, m_dataRgn.Columns.count - cols)
    End If
    
    If CDDXCurve.FourEyesActive Then
        If readComments Then Call CCurveControl.RefreshCommentsAfterUploaded(rgn, True)
    Else
        Call CCurveControl.VRColorValues(vbNullString, rgn, m_params, True)
        Call CCurveControl.EraseAccepts(m_Imager, cvrIdx)
        
        isvr = HasVR()
        Call CCurveHelper.ExpandGroups(m_sheet)
        Call ResizeVRCol(isvr, 3)
        Call ResizeVRCol(isvr, C_FIXED_COLS - 1)
        Call CCurveHelper.CollapseGroups(m_sheet)
    End If
End Sub

Public Function IFUpload(data As ZEWSProxy.ICurveResult, ByVal curvePos As Long) As Boolean
 Dim k As Long
 Dim curveIdx() As Long
 Dim count As Long
 
    m_flags = m_flags And (Not CURVE_F_SUPPRESS_FINALIZE)
    Set m_sheet = ActiveSheet
    Call m_params.FromXML(CCurveControl.GetCurveProperties(m_sheet))
    Call GetRanges
    
    curveIdx = CCurveControl.GetUploadedItms(m_params, m_sheet, data, True, count)
    If count > 0 Then
        Call CCurveControl.SaveCurveProperties(m_sheet, m_params)
    
        For k = LBound(curveIdx) To UBound(curveIdx)
            Call DrawTimes(curveIdx(k), False)
        Next
    End If
    
    Call RefreshVROnUpload(curvePos - 1, True)
    Call CDDXCurve.NotifyCurveUploadResult(DDX_PID, data, m_params)
     
    IFUpload = True
End Function

Public Function IFRefreshIndividual(data As ZEWSProxy.ICurveResult, ByVal RefreshTarget As Long) As Boolean
 Dim p As New CCurveParams
 Dim isnew As Boolean
 Dim index As Long
 Dim curves() As String
' Dim groups() As String
 Dim downloadtimes() As String
 Dim target As String
' Dim grp As String
 Dim newtime As String
 Dim rgn As range
 
    m_flags = m_flags And (Not CURVE_F_SUPPRESS_FINALIZE)
    Call p.FromXML(data.value)
    
    Set m_sheet = CCurveControl.GetSheet(p, False, isnew)
    If m_sheet Is Nothing Then Exit Function
    
    With p
        curves = .curves
        target = curves(LBound(curves))
        downloadtimes = .LastDownloadTime()
        newtime = downloadtimes(LBound(downloadtimes))
    End With
    Set p = Nothing
    
    Set m_params = CCurveDates.ParamEntity
    With m_params
'        Call .FromXML(CCurveControl.GetCurveProperties(m_sheet))
            
        Call GetRanges

        curves = .curves
        downloadtimes = .LastDownloadTime
        For index = LBound(curves) To UBound(curves)
            If curves(index) = target Then
                downloadtimes(index) = newtime
                .LastDownloadTime = downloadtimes
                Exit For
            End If
        Next
        If index > UBound(curves) Then Exit Function
    End With
    
    Call InitImager
    Call DrawTimes(index, True)
    Set rgn = m_dataRgn.offset(index + 1).Resize(1)
    Call ReadFromFile(index)
    
    Call CCurveControl.SaveCurveProperties(m_sheet, m_params)

    Call AddMD(index)

    Call GetRanges
    Call CCurveControl.EraseAccepts(m_Imager, index)
    
    IFRefreshIndividual = True
End Function

Private Sub DrawHeader()
    Call CCurveControl.SetSplits(m_sheet, C_FIXED_ROWS, C_FIXED_COLS)
    Call GetRanges
    
    Call CCurveControl.InsertTitle(m_sheet)
End Sub

Private Sub DrawProperties()
 Dim k As Long
 Dim j As Long
 Dim Values() As String
 Dim cvs() As String
 Dim row As Long
 Dim col As Long
 Dim splitrow As Long
 Dim splitcol As Long
 
    Call CCurveControl.GetSplits(m_sheet, m_params, splitrow, splitcol)
    splitrow = splitrow + 1
    
    With m_params
        Values = .PropertyNames
        If Len(Join(Values)) = 0 Then Exit Sub
                
        For k = LBound(Values) To UBound(Values)
            With m_dataRgn.Cells(1, splitcol + (k + 1))
                .value = CCurveControl.AddApostrophe(Values(k))
                '.Characters.Font.Size = 8
                .HorizontalAlignment = xlLeft
                .VerticalAlignment = xlCenter
            End With
        Next
        
        cvs = .curves
        For k = LBound(cvs) To UBound(cvs)
            Values = .PropertyValues(cvs(k))
            row = splitrow + k
            
            For j = LBound(Values) To UBound(Values)
                col = splitcol + (j + 1)
                m_HeaderRgn.Cells(row, col).value = CCurveControl.AddApostrophe(Values(j))
                m_HeaderRgn.Cells(row, col).HorizontalAlignment = xlLeft
                m_HeaderRgn.Cells(row, col).VerticalAlignment = xlCenter
            Next
        Next
    End With
End Sub

Private Sub DrawIcon(ByVal aObjectID As Long, ByVal aPos As Long, ByVal aCurveName As String, ByVal aAlternativeText As String)
    With m_Imager
        .AlternativeText = CCurveControl.GetAltText(aCurveName, aAlternativeText)
        Call .Draw(aObjectID, CStr(aPos))
    End With
End Sub

''Private Sub DrawObjectDownload(ByVal aCurveName As String, ByVal aPos As Long)
''    Call DrawIcon(OID_LAST_DOWNLOAD, aPos, aCurveName, AT_DOWNLOAD)
''End Sub
''
''Private Sub DrawObjectUpload(ByVal aCurveName As String, ByVal aPos As Long)
''    Call DrawIcon(OID_LAST_UPLOAD, aPos, aCurveName, AT_UPLOAD)
''End Sub

'Private Sub DrawDateRange()
'    Call CCurveControl.DrawStyledTexts(m_sheet, 2, 1, " Opr Dates:  ", CCurveDates.DisplayTime(m_params.OprStartDate, False) + "  " + "-" + "  " + CCurveDates.DisplayTime(m_params.OprEndDate, False))
'End Sub

Private Sub DrawInterval()
Dim dtz As Boolean
 
    dtz = CCurveGranularity.IsGranularity(m_params.granularities, CURVE_GRANULARITY_HOURLY) Or CCurveGranularity.IsGranularity(m_params.granularities, CURVE_GRANULARITY_MINUTELY)
    dtz = IIf(dtz And m_params.TZName <> vbNullString And (m_params.IsFlag(CURVE_FLG_DST_ADJUST_START) Or m_params.IsFlag(CURVE_FLG_DST_ADJUST_END)), True, False)
    Call CCurveControl.DrawStyledTexts(m_sheet, 2, 1, " Interval:  ", CCurveGranularity.GetGranularityName(m_params.granularities), IIf(dtz, "   (" + m_params.TZName + ")", vbNullString))
End Sub

'Private Sub DrawContractDatesForMP()
'    With m_Imager
'        Call .Draw(OID_OPR_MAX_DATE, vbNullString)
'        Call .Draw(OID_OPR_MIN_DATE, vbNullString) '
'    End With
'End Sub

Private Sub DrawControls()
 Dim k As Long
 Dim vr As Long
 Dim curves() As String

    vr = IIf(m_params.rowCount - 1 > 0, &H1, 0) Or IIf(m_hasvr, &H2, 0)
    
    Call DrawInterval

    curves = m_params.curves
'    groups = m_params.CurveGroups
    For k = LBound(m_params.curves) To UBound(m_params.curves)
        'Call DrawIcon(OID_VIEW_HISTORY, k, groups(k), curves(k), AT_HISTORY)
        
''        Call DrawObjectDownload(curves(k), k)
'        If Not m_params.Readonly(k) Then
''            Call DrawObjectUpload(curves(k), k)
'            Call DrawIcon(OID_SORT, k, groups(k), curves(k), AT_SORT)
'        End If

        Call DrawTimes(k, True)
        Call DrawCurveName(k, curves(k))
        
        Call PrivateDrawVR(IIf(vr = (&H1 Or &H2), curves(k), vbNullString), k)
    Next
    
    With m_Imager
        .AlternativeText = vbNullString
        
        Call .Draw(OID_DOWNLOAD_ALL, vbNullString)
        Call .Draw(OID_EDIT_SETTINGS, vbNullString)
        Call CCurveControl.EraseAcceptAll2
        
        If Not m_params.AllCurvesRD() Then
            If vr = (&H1 Or &H2) Then Call CCurveControl.AddAcceptAll2(m_Imager)

            Call .Draw(OID_UPLOAD_ALL, vbNullString) '
'            Call .Draw(OID_SORT, vbNullString)
            Call .Draw(OID_OPR_RANGE, vbNullString)
'            Call DrawContractDatesForMP

            Call AddOprControls
        End If
    End With
End Sub

Private Sub AddOprControls()
    Call CCurveControl.DeleteCurveIconsByID(m_Imager, OID_OPR_START_PLUS, OID_OPR_START_MINUS, OID_OPR_END_PLUS, OID_OPR_END_MINUS)
    
    With m_Imager
        If m_params.rowCount >= 2 Then
            Call .Draw(OID_OPR_START_PLUS, ALT_OPR_HEAD_PLUS, xlMove)
            Call .Draw(OID_OPR_START_MINUS, ALT_OPR_HEAD_MINUS, xlMove)
            Call .Draw(OID_OPR_END_PLUS, ALT_OPR_TAIL_PLUS, xlMove)
            Call .Draw(OID_OPR_END_MINUS, ALT_OPR_TAIL_MINUS, xlMove)
        End If
    End With
End Sub

Private Sub DrawCurveName(ByVal aPos As Long, ByVal aCurveName As String)
 Dim w As Long
 Dim w0 As Long
 
    If aPos = 0 Then
        With m_dataRgn.Cells(1, 1).Resize(1, 2)
            .Merge
            .HorizontalAlignment = xlCenter
            .VerticalAlignment = xlCenter
            .value = "Curve Name"
        End With
        
        w = CCurveControl.GetNameWidth(m_params)
        w0 = Len("Effective Date: ")
        m_sheet.Columns(1).ColumnWidth = w0
        m_sheet.Columns(2).ColumnWidth = IIf(w < 28, 28, w) - w0
        
        With m_dataRgn.Cells(2, 1).Resize(m_dataRgn.rows.count - 1, 2)
            .HorizontalAlignment = xlLeft
            .VerticalAlignment = xlCenter
            .IndentLevel = 1
            .ShrinkToFit = False
            .WrapText = False
            .NumberFormat = "@"
            Call .Merge(Across:=True)
        End With
    End If
    
    m_dataRgn.Cells(aPos + 2, 1).value = CCurveControl.AddApostrophe(aCurveName)
End Sub

Private Sub DrawData(ByVal aIsNew As Boolean)
'    m_dataRgn.Font.ColorIndex = 1
    Call ReadFromFile(-1)
End Sub

Private Sub ReadFromFile(ByVal aCurveIndex As Long)
' Dim r As Long
 
'    With m_dataRgn
'        If .Columns.count >= 2 And .rows.count >= 2 Then
'            .Font.ColorIndex = xlColorIndexAutomatic 'CURVE_DATA_CLR_IDX
'        End If
'    End With
    
    With m_dataRgn
        If aCurveIndex < 0 Then
            Call CCurveControl.ReadFileTRANS(aCurveIndex, .Resize(1), .offset(1).Resize(.rows.count - 1), m_params)
        Else
            Call CCurveControl.ReadFileTRANS(aCurveIndex, Nothing, .offset(aCurveIndex + 1).Resize(1), m_params)
        End If
    End With
    
    Call GetRanges
End Sub

Private Sub Class_Initialize()
    Set m_Imager = New CCurveImageText
End Sub

Private Sub Class_Terminate()
    Call ProtectSheet
    Set m_Imager = Nothing
End Sub

Private Sub SetDataRgnFormat()
 Dim spltrows As Long
 Dim spltcols As Long
 Dim pc As Long
 
    On Local Error Resume Next
    
    Call CCurveControl.GetSplits(m_sheet, m_params, spltrows, spltcols)
    
    With m_dataRgn
        If .rows.count <= 1 Or spltcols >= .Columns.count Then Exit Sub
        
        pc = m_params.PropertyCount
        
        pc = m_params.PropertyCount

        With .offset(1, spltcols - 1).Resize(.rows.count - 1, pc + 1)
            .NumberFormat = "@"
            .HorizontalAlignment = xlLeft
            .offset(, pc).Resize(, 1).VerticalAlignment = xlCenter
        End With
        
        If .Columns.count > spltcols + pc Then
            With .offset(1, spltcols + pc).Resize(.rows.count - 1, .Columns.count - (spltcols + pc))
'                .NumberFormat = "General"
                .HorizontalAlignment = xlRight
            End With
        End If
    End With
End Sub

Private Sub ProtectSheet()
 Dim c As Long
 Dim k As Long
 Dim sizex As Long
 Dim tmp As Long
 Dim startl As Long
 Dim endl As Long
 
    If CDDXHelper.IsFlag(m_flags, CURVE_F_SUPPRESS_FINALIZE) Then Exit Sub
    
    If m_params.GetCurveCount() <= 0 Then
        Call CCurveControl.Unprotect(m_sheet)
        Exit Sub
    End If
 
    If m_sheet Is Nothing Then Exit Sub
    If m_sheet.ProtectContents Then Exit Sub

    If Not m_dataRgn Is Nothing Then
        If Not m_dataRgn Is Nothing Then m_dataRgn.Locked = True
        If Not m_HeaderRgn Is Nothing Then m_HeaderRgn.Locked = True
    Else
        m_sheet.UsedRange.Cells.Locked = True
    End If
    
    m_sheet.Cells(2, 2).Locked = m_params.AllCurvesRD()
    
    If Not m_dataRgn Is Nothing Then
        sizex = m_params.PropertyCount
        With m_dataRgn
            c = .Columns.count
            tmp = c - sizex - C_FIXED_COLS
            If tmp > 0 Then
                startl = 0
                endl = 0
                For k = LBound(m_params.curves) To UBound(m_params.curves)
                    If Not m_params.Readonly(k) Then
                        If startl = 0 Then startl = k + 1
                        endl = endl + 1
                    Else
                        '.offset(k + 1, C_FIXED_COLS + sizex).Resize(1, tmp).Locked = False
                        If startl > 0 Then
                            .Cells(startl + 1, C_FIXED_COLS + sizex + 1).Resize(endl, tmp).Locked = False
                            startl = 0
                            endl = 0
                        End If
                    End If
                Next
                If startl > 0 Then
                    .Cells(startl + 1, C_FIXED_COLS + sizex + 1).Resize(endl, tmp).Locked = False
                End If
            End If
'            If .Columns.count > C_FIXED_COLS + sizex Then
'                '.offset(, C_FIXED_COLS + sizex).Resize(1, .Columns.count - C_FIXED_COLS - sizex).Locked = m_params.AllCurvesRD()
'            End If
            
        End With
        
        Call SetDataRgnFormat
        Call CCurveControl.Add4EyesStyle(m_dataRgn)
    End If
    
    Call CCurveControl.Protect(m_sheet)
End Sub

Private Sub m_Imager_OnImage(sender As Object, ByVal aTarget As Integer, ByVal aUserData As String, aPicturePath As String, ByRef aWidth As Single, ByRef aHeight As Single)
    aPicturePath = vbNullString
    aWidth = 95
    aHeight = 18
    
    Select Case aTarget
        Case OID_EDIT_SETTINGS:
            aWidth = 140
            aPicturePath = "CurveEditDateSettings2.png"
        Case OID_OPR_RANGE:
            aWidth = 140
            aPicturePath = "OprDateRange2.png"
        Case OID_DOWNLOAD_ALL:
            aWidth = 100
            aPicturePath = "CurveDownloadAll2.png"
'        Case OID_LAST_UPLOAD:
'            aWidth = 110
'            aPicturePath = "CurveLastUpload.png"
        Case OID_UPLOAD_ALL:
            aWidth = 100
            aPicturePath = "CurveUploadAll2.png"
'        Case OID_VIEW_HISTORY:
'            aWidth = 110
'            aPicturePath = "CurveViewHistory.png"
'        Case OID_DELETE:
'            aPicturePath = "CurveDelete.png"
'        Case OID_SORT:
'            aPicturePath = IIf(aUserData = vbNullString, "filter.png", "filter.png")
'        Case OID_CURVE_NAME:
'            aWidth = 0 '
'            aHeight = 0 '
'        Case OID_OPR_START_PLUS, OID_OPR_END_PLUS:
'            aPicturePath = "CurvePlus.png"
'        Case OID_OPR_START_MINUS, OID_OPR_END_MINUS:
'            aPicturePath = "CurveMinus.png"
'        Case OID_OPR_MIN_DATE, OID_OPR_MAX_DATE:
'            aWidth = 68
'            aHeight = 16
        Case OID_ACCEPT_ALL:
            aWidth = 100
            aPicturePath = "CurveAcceptAll2.png"
'        Case OID_ACCEPT:
'            aWidth = 100
'            aPicturePath = "CurveAccept.png"
        Case OID_OPR_START_PLUS, OID_OPR_END_PLUS:
            aPicturePath = "CurvePlus.png"
        Case OID_OPR_START_MINUS, OID_OPR_END_MINUS:
            aPicturePath = "CurveMinus.png"
    End Select
End Sub

Private Sub m_Imager_OnImageBackColor(sender As Object, ByVal aTarget As Integer, bkColor As Long)
'    Select Case aTarget
'        Case OID_OPR_MIN_DATE, OID_OPR_MAX_DATE:
'            'bkColor = m_Sheet.Cells(BSConsts.CURVE_SINGLE_START_ROW, 1).Interior.color
'            bkColor = xlNone 'm_dataRgn.Cells(1, 1).Interior.color
'        Case Else:
            bkColor = RGB(255, 255, 255) 'BSConsts.CURVE_ROW_HEADER_COLOR
'    End Select
End Sub

Private Sub m_Imager_OnImagePlacement(sender As Object, ByVal aTarget As Integer, ByVal aUserData As String, aTop As Single, aLeft As Single, aWidth As Single, aHeight As Single)
 Dim row As Long
 Dim t1 As Variant
 
    t1 = 23
    row = GetColIndex(aUserData)
    aWidth = -1
    aHeight = -1
    
    Select Case aTarget
        Case OID_OPR_RANGE:
            With m_sheet.Cells(4, 1)
                aTop = .top + 3
                aLeft = .left + 78
            End With
        Case OID_EDIT_SETTINGS:
            With m_sheet.Cells(4, 1)
                aTop = .top + 3
                aLeft = .left + 5
            End With
        Case OID_DOWNLOAD_ALL:
            With m_sheet.Cells(5, 1)
                aTop = .top + 3
                aLeft = .left + 5
            End With
            
        Case OID_UPLOAD_ALL:
            With m_sheet.Cells(5, 1)
                aTop = .top + 3
                aLeft = .left + 78
            End With
            
        Case OID_ACCEPT_ALL:
            With m_sheet.Cells(5, 1)
                aTop = .top + 3
                aLeft = .left + IIf(m_params.AllCurvesRD(), 78, 150)
            End With
        
        Case OID_OPR_START_PLUS:
            Call GetOprControlPos(True, True, aTop, aLeft)
        Case OID_OPR_START_MINUS:
            Call GetOprControlPos(True, False, aTop, aLeft)
        Case OID_OPR_END_PLUS:
            Call GetOprControlPos(False, True, aTop, aLeft)
        Case OID_OPR_END_MINUS:
            Call GetOprControlPos(False, False, aTop, aLeft)
    End Select
End Sub

Private Sub GetOprControlPos(ByVal isHead As Boolean, ByVal isPlus As Boolean, aTop As Single, aLeft As Single)
    With m_sheet.Cells(C_FIXED_ROWS - 1, IIf(isHead, C_FIXED_COLS + m_params.PropertyCount + 1, m_dataRgn.Columns.count))
        aTop = .top + 5
        aLeft = .left + IIf(isHead, 0, .Width) + IIf(isPlus, 10, 20) * IIf(isHead, 1, -1)
    End With
End Sub

Private Function GetColIndex(ByVal aUserData As String) As Long
    If aUserData <> vbNullString Then
        GetColIndex = Val(aUserData) + 1
    Else
        GetColIndex = -1
    End If
End Function

Private Sub m_Imager_OnMacro(sender As Object, ByVal aTarget As Integer, ByVal aUserData As String, aMacro As String)
 Dim idx As Long
 Dim curves() As String
 
    curves = m_params.curves
    idx = GetColIndex(aUserData) - 1
    aMacro = vbNullString

    Select Case aTarget
        Case OID_DOWNLOAD_ALL:
            aMacro = MacroActionStr("MacroDownloadAllS")
        Case OID_ACCEPT_ALL:
            aMacro = MacroActionStr("MacroAcceptAll")
        Case OID_UPLOAD_ALL:
            aMacro = MacroActionStr("MacroUploadAllS")
        Case OID_EDIT_SETTINGS:
            aMacro = MacroActionStr("MacroEditDateSettingsS")
        Case OID_OPR_RANGE:
            aMacro = MacroActionStr("MacroContractS")
            
        Case OID_OPR_START_PLUS:
            aMacro = CCurveControl.OnPlusMinusAction(CURVE_UI_CONTRACTS_START_PLUS)
        Case OID_OPR_START_MINUS:
            aMacro = CCurveControl.OnPlusMinusAction(CURVE_UI_CONTRACTS_START_MINUS)
        Case OID_OPR_END_PLUS:
            aMacro = CCurveControl.OnPlusMinusAction(CURVE_UI_CONTRACTS_END_PLUS)
        Case OID_OPR_END_MINUS:
            aMacro = CCurveControl.OnPlusMinusAction(CURVE_UI_CONTRACTS_END_MINUS)
'        Case OID_LAST_DOWNLOAD:
'            aMacro = MacroActionStr("MacroDownloadS", CURVE_GRP_NAME, curves(idx), CDDXHelper.NewGUID())
'        Case OID_LAST_UPLOAD:
'            aMacro = MacroActionStr("MacroUploadS", CURVE_GRP_NAME, curves(idx), CDDXHelper.NewGUID())
'        Case OID_DELETE:
'            aMacro = MacroActionStr("MacroDeleteS", CURVE_GRP_NAME, curves(idx), CDDXHelper.NewGUID())
'        Case OID_ACCEPT:
'            If CCurveControl.ShowAccept(idx) Then
'                aMacro = MacroActionStr("MacroAccept", CURVE_GRP_NAME, curves(idx), CDDXHelper.NewGUID())
'            End If
    End Select
End Sub

Private Sub DrawTimes(ByVal aIndex As Long, ByVal aIsDownload As Boolean)
 Dim tv As Double
 
    If Not CCurveControl.GetAccessTimeToDraw(m_params, aIndex, aIsDownload, tv) Then Exit Sub
    Call CCurveControl.DrawAccessTime(m_dataRgn.Cells(aIndex + 2, 4), tv, aIsDownload, xlLeft)
End Sub

Private Sub GetContractDates(minDate As String, maxDate As String)
    minDate = "--- -- ----"
    maxDate = minDate
End Sub

Private Sub m_Imager_OnText(sender As Object, ByVal aTarget As Integer, ByVal aUserData As String, aText As String, ByRef aBold As Boolean, ByRef aToolTip As String, ByRef aTop As Long, ByRef aLeft As Long)
 Dim pos As Long
 Dim maxdte As String
 Dim mindte As String
 
    If IsNumeric(aUserData) Then
        pos = CLng(aUserData)
    End If

    aText = vbNullString
    aBold = False
    aToolTip = vbNullString
    
'    Select Case aTarget
'        Case OID_DOWNLOAD_ALL:
'        Case OID_ACCEPT_ALL:
'        Case OID_UPLOAD_ALL:
            'aText = "  Upload All"
'        Case OID_EDIT_DATE:
            'aText = "  Edit Effective Date"
'        Case OID_CONTRACT:
         
'        Case OID_VIEW_HISTORY:
            'aText = "  View History"
'        Case OID_LAST_DOWNLOAD:
'            'aText = "  Download" '+ du
'
'            Call DrawTimes(pos, True)
'        Case OID_LAST_UPLOAD:
'            'aText = "  Upload" '+ du
'
'            Call DrawTimes(pos, False)
'        Case OID_CURVE_NAME:
'            'aToolTip = m_params.GetTooltipByPosition(pos)
'            aTop = m_dataRgn.row + pos + 1
'            aLeft = C_FIXED_COLS + 1
            
'        Case OID_OPR_MIN_DATE:
'            Call GetContractDates(mindte, maxdte)
'            aText = mindte
'        Case OID_OPR_MAX_DATE:
'            Call GetContractDates(mindte, maxdte)
'            aText = maxdte
'        Case OID_ACCEPT:
'            Call DrawVR(pos)
'    End Select
End Sub

Private Sub AddNewOprs(ByVal aPrior As Integer, dispDates() As Double, ByVal length As Long)
 Dim rgn As range
 Dim splitrows As Long
 Dim splitcols As Long
 
    Call CCurveControl.GetSplits(m_sheet, m_params, splitrows, splitcols)
    splitcols = splitcols + m_params.PropertyCount '+ 1
    
    If aPrior <= 0 Or aPrior = -2 Then Call AddDataGroup(False)
    
    With m_dataRgn
        Select Case aPrior
            Case -1:
                Set rgn = .offset(, splitcols).Resize(, length)
                Call rgn.EntireColumn.Insert
                rgn.offset(, -length).Interior.ColorIndex = xlNone
        
            Case 1:
                Set rgn = .offset(, .Columns.count - length).Resize(, length)
                Call rgn.EntireColumn.Insert
                Call CCurveControl.Remove4EyesStyle(rgn.offset(, -length))
                
            Case 0:
                Set rgn = .offset(, splitcols).Resize(, length)
                Call rgn.EntireColumn.Insert
                rgn.offset(, -length).Interior.ColorIndex = xlNone
                
            Case -2:
                If .Columns.count = splitcols Then Exit Sub
                Set rgn = .offset(, splitcols).Resize(, 1)
                Call rgn.EntireColumn.Delete
                
                Call AddDataGroup(True)
                Exit Sub
            Case 2:
                If .Columns.count = splitcols Then Exit Sub
                Set rgn = .offset(, .Columns.count).Resize(, 1)
                Call rgn.EntireColumn.Delete
                Exit Sub
        End Select
    End With
    
    'Call CCurveControl.SetDateVaules(m_params.granularities, rgn.offset(, -length).Resize(1, length), dispDates)
    
    Set rgn = rgn.offset(, -length) '.Resize(1)
    Call CCurveControl.SetDateVaules(m_params.granularities, rgn.Resize(1), dispDates)
    Call CCurveControl.SetSOCValueFormats(-1, rgn.offset(1).Resize(rgn.rows.count - 1), m_params)
    
    Call AddDataGroup(True)
End Sub

Public Function IFNewContracts(ByVal aPrior As Long, ByVal op As Integer, dispDates() As Double) As Boolean
 Dim length As Long
 
    m_flags = m_flags And (Not CURVE_F_SUPPRESS_FINALIZE)
    If CCurveControl.IsEmptyDates(dispDates) Then Exit Function
    
    length = UBound(dispDates) - LBound(dispDates) + 1
    Set m_sheet = ActiveSheet
    Call m_params.FromXML(CCurveControl.GetCurveProperties(m_sheet))
    Call GetRanges
    Call InitImager
    
    Call AddNewOprs(aPrior, dispDates, length)
    
    Call GetRanges
    
'    Call DrawContractDatesForMP
    Call AddStyle(0)
    Call AddOprControls
    
    If CCurveControl.RefreshOprRange(m_params, m_sheet) Then
'        Call DrawDateRange
    End If
End Function

Private Sub AddMD(ByVal oprDateIndex As Long)
'    Call CCurveControl.ResetRangeColor(m_params, m_dataRgn, oprDateIndex)
    Call CCurveControl.PopulateInputs
End Sub

Public Sub DrawVR(cvrNm As String, ByVal cvrIndex As Long)
    m_flags = m_flags Or CURVE_F_SUPPRESS_FINALIZE
    Call PrivateDrawVR(cvrNm, cvrIndex)
End Sub

Private Sub PrivateDrawVR(cvrNm As String, ByVal cvrIndex As Long)
 Dim rw As Long

    rw = cvrIndex + C_FIXED_ROWS + 1
    
    If cvrNm = vbNullString Then
        ActiveSheet.Cells(rw, C_FIXED_COLS - 1).value = vbNullString
    Else
        Call CCurveControl.DrawCurveVR(GetCurveVR(cvrNm), CDbl(CCurveDates.ParamEntity.OprStartDate), rw, C_FIXED_COLS - 1, xlLeft)
        ActiveSheet.Cells(rw, C_FIXED_COLS - 1).IndentLevel = 1
    End If
End Sub

Public Sub IFReLayout()
    Call GetRanges
    Set m_Imager.sheet = m_sheet
    If m_params.granularities = 0 Then
        Call m_params.FromXML(CCurveControl.GetCurveProperties(m_sheet))
    End If
    
    Call CCurveControl.ClearImagesV1(m_dataRgn)
    
    With m_dataRgn
        If .rows.count >= 1 Then
            .Cells(1, 3).Resize(.rows.count) = vbNullString
            .Cells(1, 5).Resize(.rows.count) = vbNullString
        End If
    End With
    
    Call AddStyle(1)
    Call DrawControls
End Sub

Private Function GetCurveVR(cvrNm As String) As String
 Dim vr As Variant

    vr = CCPVRStorage.GetVR(ActiveSheet, CURVE_VR_L_CURVE, cvrNm, 0, 0, 0, vbNullString, vbNullString)
    If IsEmpty(vr) Then Exit Function

    GetCurveVR = CCurveControl.ContainsStatusToAccept2(vr)
End Function

Private Function HasVR() As Boolean
 Dim cvrs() As String
 Dim k As Long
        
    cvrs = CCurveDates.ParamEntity.curves
    
    For k = LBound(cvrs) To UBound(cvrs)
        HasVR = IIf(Len(GetCurveVR(cvrs(k))) > 0, True, False)
        If HasVR Then Exit Function
    Next
End Function

Private Sub LockRange(ByVal curveIdx As Long, rdonly As Boolean)
 Dim c As Long

    With m_dataRgn
        c = .Columns.count - m_params.PropertyCount - C_FIXED_COLS
        If c <= 0 Then Exit Sub
        
        .Cells(curveIdx + 1, C_FIXED_COLS + 1).Resize(1, c).Locked = rdonly
    End With

    'Call CCurveControl.Add4EyesStyle(m_dataRgn)
End Sub

Public Sub IFUpdatePermissions(permissions() As Long)
 Dim curves() As String
 Dim rdonly As Boolean
 Dim k As Long
 Dim c As Long
 
    m_flags = m_flags Or CURVE_F_SUPPRESS_FINALIZE
    
    Set m_sheet = ActiveSheet
    If m_Imager Is Nothing Then Set m_Imager = New CCurveImageText
    Set m_Imager.sheet = m_sheet
    Set m_params = CCurveDates.ParamEntity

    Call GetRanges
    
    curves = m_params.curves
    rdonly = Not CCurveControl.HasWriteableCurves(m_sheet, m_params, permissions)
    
    With m_Imager
        .AlternativeText = vbNullString

        If rdonly Then
            Call CCurveControl.DeleteCurveIconsByID(m_Imager, OID_ACCEPT_ALL, OID_UPLOAD_ALL, OID_OPR_RANGE, OID_OPR_START_PLUS, OID_OPR_START_MINUS, OID_OPR_END_PLUS, OID_OPR_END_MINUS)
        
        Else
            If .FindImage(OID_ACCEPT_ALL) Is Nothing Then Call CCurveControl.AddAcceptAll(m_Imager)
            
            If .FindImage(OID_UPLOAD_ALL) Is Nothing Then
                Call .Draw(OID_UPLOAD_ALL, vbNullString)

                Call .Draw(OID_OPR_START_PLUS, vbNullString)
                Call .Draw(OID_OPR_START_MINUS, vbNullString)
                Call .Draw(OID_OPR_END_PLUS, vbNullString)
                Call .Draw(OID_OPR_END_MINUS, vbNullString)
            End If
        End If
    End With
    
    m_Imager.DeleteExsitingBeforeAdd = False
    
    For k = LBound(permissions) To UBound(permissions)
        If permissions(k) >= 0 Then
            rdonly = IIf(permissions(k) = 0, True, False)
            Call LockRange(k, rdonly)
        End If
    Next
    
    With m_dataRgn
        If .rows.count > 1 Then
            c = C_FIXED_COLS + m_params.PropertyCount + 1
            k = .Columns.count - (c - 1)
            If k > 0 Then Call CCurveControl.AddProtection(permissions, .Cells(2, c).Resize(.rows.count - 1, k))
        End If
    End With
End Sub
Attribute VB_Name = "CCPVRStorage"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Const S_ACCEPTED As String = "1" '"Accepted"
        
Public Function GetCXP(sht As Worksheet, ByVal curve As String) As CustomXMLPart
 Dim k As Long
 Dim ids
    
    ids = CSheet.WSGetProp(sht, CURVE_SHEET_VALIDATIONS)
    If ids = vbNullString Then Exit Function
    ids = Split(ids, vbTab)
    
    For k = LBound(ids) + 1 To UBound(ids) Step 2
        If StrComp(curve, ids(k), vbBinaryCompare) = 0 Then
            Set GetCXP = sht.Parent.CustomXMLParts.SelectByID(ids(k - 1))
            Exit Function
        End If
    Next
End Function

Private Function GetText(cxp As CustomXMLPart, ByVal textNo As String) As String
 Dim node As CustomXMLNode
    
    If textNo = "0" Or textNo = vbNullString Then Exit Function
    
    GetText = textNo
    
    If IsNumeric(textNo) Then
        Set node = cxp.SelectSingleNode("ddx/texts/i[@t='" + textNo + "']")
        If node Is Nothing Then Exit Function
        
        GetText = node.text
    End If
End Function

Public Function RestoreNeeded(cxp As CustomXMLPart, ByVal efDate As Double) As Boolean
Dim vrid As String
Dim node As CustomXMLNode

    vrid = CDDXLib.DefaultZEWSProxy(DDX_PID).VRGetID(CURVE_VR_L_CURVE, vbNullString, 0, efDate, 0, vbNullString, 0)
    Set node = cxp.SelectSingleNode("ddx/curve/i[@t='" + vrid + "']/st")
    If node Is Nothing Then Exit Function
    
    RestoreNeeded = IIf(StrComp(node.text, S_ACCEPTED, vbTextCompare) = 0, False, True)
End Function

Private Function ConvertToVRColor(ByVal vrStatus As String) As Long
    If StrComp(vrStatus, "error", vbTextCompare) = 0 Then
        ConvertToVRColor = CURVE_VR_COLOR_ERR
    ElseIf StrComp(vrStatus, "warning", vbTextCompare) = 0 Then
        ConvertToVRColor = CURVE_VR_COLOR_WARNING
    ElseIf StrComp(vrStatus, "Not Validated", vbTextCompare) = 0 Then
        ConvertToVRColor = CURVE_VR_COLOR_UNVALIDATED
    End If
End Function

Public Function GetDataPointVR(cxp As CustomXMLPart, ByVal curveName As String, ByVal flgValues As Long, ByVal efDte As Double, ByVal contractDte As Double, ctypeName As String, granName As Variant) As Long
 Dim k As Long
 Dim p As Long
 Dim vrid As String
 Dim gv As Long
 Dim nodes As CustomXMLNodes
 Dim txt As String
 Dim clr As Long
 
    If VarType(granName) = vbLong Or VarType(granName) = vbInteger Then
        gv = granName
    ElseIf VarType(granName) = vbString Then
        If granName = vbNullString Then
            gv = 0
        Else
            gv = CCurveGranularity.GetGranularity(granName)
        End If
    End If
    
    vrid = CDDXLib.DefaultZEWSProxy(DDX_PID).VRGetID(CURVE_VR_L_DATAPOINT, curveName, flgValues, efDte, contractDte, ctypeName, gv)

    Set nodes = cxp.SelectNodes("ddx/datapoints/i[@t='" + vrid + "']/st")
    
    If nodes Is Nothing Then Exit Function
    If nodes.count = 0 Then Exit Function
 
    For k = nodes.count To 1 Step -1
        txt = nodes(k).text
        
        If StrComp(txt, S_ACCEPTED) <> 0 Then
            clr = ConvertToVRColor(GetText(cxp, txt))
            
            If clr <> 0 Then
                If clr = CURVE_VR_COLOR_ERR Then
                    GetDataPointVR = clr
                    Exit Function
                End If
                
                If clr = CURVE_VR_COLOR_WARNING Then
                    GetDataPointVR = clr
                ElseIf clr = CURVE_VR_COLOR_UNVALIDATED Then
                    If GetDataPointVR <> CURVE_VR_COLOR_WARNING Then GetDataPointVR = clr
                End If
            End If
        End If
    Next
End Function

Private Function GetCXPIndex(ids As Variant, ByVal curve As String) As Long
 Dim k As Long

    For k = LBound(ids) + 1 To UBound(ids) Step 2
        If StrComp(curve, ids(k), vbBinaryCompare) = 0 Then
            GetCXPIndex = k - 1
            Exit Function
        End If
    Next
    
    GetCXPIndex = -1
End Function

'Public Sub OnAcceptCurve(sht As Worksheet, ByVal acceptTarget As Long, ByVal curve As String, ByVal oprDate As Variant)
' Dim k As Long
' Dim ids
' Dim cxp As CustomXMLPart
' Dim startidx As Long
' Dim vrid As String
' Dim nodes As CustomXMLNodes
' Dim xml As String
'
'    On Error GoTo OOPS
'
'    ids = CSheet.WSGetProp(sht, CURVE_SHEET_VALIDATIONS)
'    If ids = vbNullString Then Exit Sub
'    ids = Split(ids, vbTab)
'
'    startidx = GetCXPIndex(ids, curve)
'    If startidx < 0 Then Exit Sub
'
'    Set cxp = sht.Parent.CustomXMLParts.SelectByID(ids(startidx))
'    If cxp Is Nothing Then Exit Sub
'
'    If oprDate > 0 Then
'        vrid = CDDXLib.DefaultZEWSProxy(DDX_PID).VRGetID(CURVE_VR_L_CURVE, curve, 0, oprDate, 0, vbNullString, 0)
'    End If
'
'    Set nodes = cxp.SelectNodes("ddx/curve/i" + IIf(Len(vrid) = 0, vbNullString, "[@t='" + vrid + "']")) ' + "/st")
'    If Not nodes Is Nothing Then
'        For k = 1 To nodes.count
'            If nodes(k).Attributes.count = 1 Then
'                Call cxp.AddNode(nodes(k), "a", , , msoCustomXMLNodeAttribute, "1")
'            End If
'            nodes(k).SelectSingleNode("st").text = S_ACCEPTED
'        Next
'    End If
'
'    If oprDate > 0 Then
'        vrid = CDDXLib.DefaultZEWSProxy(DDX_PID).VRGetID(CURVE_VR_L_OBSERVATION, curve, 0, oprDate, 0, vbNullString, 0)
'    End If
'
'    Set nodes = cxp.SelectNodes("ddx/observations/i" + IIf(Len(vrid) = 0, vbNullString, "[@t='" + vrid + "']"))
'    If Not nodes Is Nothing Then
'        For k = nodes.count To 1 Step -1
'            Call nodes(k).Delete
'        Next
'    End If
'
'    Set nodes = cxp.SelectNodes("ddx/oprs/i")
'    If Not nodes Is Nothing Then
'        For k = nodes.count To 1 Step -1
'            If oprDate = 0 Then
'                nodes(k).Delete
'            Else
'                If Int(Val(nodes(k).text)) = Int(oprDate) Then
'                    Call nodes(k).Delete
'                    Exit For
'                End If
'            End If
'        Next
'    End If
'
'    xml = cxp.xml
'    Call cxp.Delete
'
'    Set cxp = sht.Parent.CustomXMLParts.Add(xml)
'
'    ids(startidx) = cxp.id
'    Call CSheet.WSSetProp(sht, CURVE_SHEET_VALIDATIONS, Join(ids, vbTab))
'
'OOPS:
'    If Err.Number <> 0 Then
'        CDDXApp.StatusMessage = Err.Description
'    End If
'    Exit Sub
'End Sub

Public Sub DeleteCurve(sht As Worksheet, ByVal curve As String)
 Dim k As Long
 Dim ids
 Dim cxp As CustomXMLPart
 Dim buff As String
 Dim startidx As Long
 Dim endidx As Long
 
    On Error GoTo OOPS

    ids = CSheet.WSGetProp(sht, CURVE_SHEET_VALIDATIONS)
    If ids = vbNullString Then Exit Sub
    ids = Split(ids, vbTab)
    
    If Len(curve) = 0 Then
        startidx = LBound(ids)
        endidx = UBound(ids)
    Else
        startidx = -1
        For k = LBound(ids) + 1 To UBound(ids) Step 2
            If StrComp(curve, ids(k), vbBinaryCompare) = 0 Then
                startidx = k - 1
                endidx = k
                Exit For
            End If
        Next
    End If
    If startidx < 0 Then Exit Sub
    
    For k = startidx To endidx Step 2
        Set cxp = sht.Parent.CustomXMLParts.SelectByID(ids(k))
        If Not cxp Is Nothing Then
            Call cxp.Delete
        End If
        ids(k) = vbNullString
    Next

    buff = vbNullString
    For k = LBound(ids) To UBound(ids) Step 2
        If Len(ids(k)) > 0 Then
            If Len(buff) > 0 Then buff = buff + vbTab
            buff = buff + ids(k) + vbTab + ids(k + 1)
        End If
    Next

    Call CSheet.WSSetProp(sht, CURVE_SHEET_VALIDATIONS, buff)
    
OOPS:
    If Err.Number <> 0 Then
        CDDXApp.StatusMessage = Err.Description
    End If
    Exit Sub
End Sub

Public Sub AddCurve(sht As Worksheet, ByVal curve As String, ByVal fpname As String)
 Dim k As Long
 Dim ids
 Dim cxp As CustomXMLPart
 Dim cxpid As String
 Dim buff As String
 Dim curvePos As Long
 
    On Error GoTo OOPS
    
    curvePos = -1
    
    buff = CSheet.WSGetProp(sht, CURVE_SHEET_VALIDATIONS)
    If Len(buff) > 0 Then
        ids = Split(buff, vbTab)
        
        For k = LBound(ids) To UBound(ids) Step 2
            If StrComp(curve, ids(k + 1)) = 0 Then
                curvePos = k
                
                Set cxp = sht.Parent.CustomXMLParts.SelectByID(ids(k))
                If Not cxp Is Nothing Then
                    Call cxp.Delete
                End If
                Exit For
            End If
        Next
    End If
    
    cxpid = AddCXP(sht.Parent, fpname)
    
    If curvePos >= 0 Then
        ids(curvePos) = cxpid
        buff = Join(ids, vbTab)
    Else
        If Len(buff) > 0 Then buff = buff + vbTab
        buff = buff + cxpid + vbTab + curve
    End If
    
    Call CSheet.WSSetProp(sht, CURVE_SHEET_VALIDATIONS, buff)
    
OOPS:
    If Err.Number <> 0 Then
        CDDXApp.StatusMessage = Err.Description
    End If
    Exit Sub
End Sub

Public Function GetVR(sht As Worksheet, ByVal levelNum As Long, ByVal curveName As String, ByVal flgValues As Long, ByVal efDte As Double, ByVal contractDte As Double, ctypeName As String, granName As Variant) As Variant
 Dim k As Long
 Dim p As Long
 Dim rlt() As String
 Dim ids
 Dim cxp As CustomXMLPart
 Dim buff As String
 Dim vrid As String
 Dim gv As Long
 Dim nodes As CustomXMLNodes
 Dim ctnode As CustomXMLNode
 
    On Error GoTo OOPS
       
    ids = CSheet.WSGetProp(sht, CURVE_SHEET_VALIDATIONS)
    If ids = vbNullString Then Exit Function
    ids = Split(ids, vbTab)
    
    If VarType(granName) = vbString Then
        If granName = vbNullString Then
            gv = 0
        Else
            gv = CCurveGranularity.GetGranularity(granName)
        End If
    ElseIf VarType(granName) = vbLong Or VarType(granName) = vbInteger Then
        gv = granName
    End If
    
    For k = LBound(ids) To UBound(ids) Step 2
        If StrComp(curveName, ids(k + 1)) = 0 Then
            Set cxp = sht.Parent.CustomXMLParts.SelectByID(ids(k))
            Exit For
        End If
    Next
    If cxp Is Nothing Then Exit Function
    
    If efDte > 0 Then
        vrid = CDDXLib.DefaultZEWSProxy(DDX_PID).VRGetID(levelNum, curveName, flgValues, efDte, contractDte, ctypeName, gv)
    End If
    
    If levelNum = CURVE_VR_L_CURVE Then
        Set nodes = cxp.SelectNodes("ddx/curve/i" + IIf(vrid = vbNullString, vbNullString, "[@t='" + vrid + "']"))

        If Not nodes Is Nothing Then
            If nodes.count > 0 Then
                ReDim rlt(0 To CURVE_VR_SIZE_CURVE * nodes.count - 1)
                
                p = 0
                For k = 1 To nodes.count
                    rlt(p) = GetText(cxp, nodes(k).SelectSingleNode("st").text) '.SelectSingleNode("rt")
                    rlt(p + 1) = GetText(cxp, nodes(k).SelectSingleNode("ms").text)
                    p = p + CURVE_VR_SIZE_CURVE
                Next
                GetVR = rlt
            End If
        End If
        
    ElseIf levelNum = CURVE_VR_L_OBSERVATION Then
        Set nodes = cxp.SelectNodes("ddx/observations/i[@t='" + vrid + "']")
        
        If Not nodes Is Nothing Then
            If nodes.count > 0 Then
                ReDim rlt(0 To CURVE_VR_SIZE_OBSERVATION * nodes.count - 1)
                
                For k = 1 To nodes.count
                    rlt(p) = GetText(cxp, nodes(k).SelectSingleNode("sn").text) 'set name
                    rlt(p + 1) = GetText(cxp, nodes(k).SelectSingleNode("rn").text) 'rule name
                    rlt(p + 2) = GetText(cxp, nodes(k).SelectSingleNode("ct").text) 'curve type
                    rlt(p + 3) = GetText(cxp, nodes(k).SelectSingleNode("st").text) 'status
                    rlt(p + 4) = GetText(cxp, nodes(k).SelectSingleNode("vl").text) 'validation level
                    rlt(p + 5) = GetText(cxp, nodes(k).SelectSingleNode("ms").text) 'message
                    p = p + CURVE_VR_SIZE_OBSERVATION
                Next
                GetVR = rlt
            End If
        End If
        
    ElseIf levelNum = CURVE_VR_L_DATAPOINT Then
        Dim vridp As String
        Dim nodep As CustomXMLNode
        
        vridp = CDDXLib.DefaultZEWSProxy(DDX_PID).VRGetID(CURVE_VR_L_CURVE, curveName, flgValues, efDte, contractDte, ctypeName, gv)
        Set nodep = cxp.SelectSingleNode("ddx/curve/i[@t='" + vridp + "']/st")
        If nodep Is Nothing Then Exit Function
        If StrComp(nodep.text, S_ACCEPTED, vbTextCompare) = 0 Then Exit Function
        
        Set nodes = cxp.SelectNodes("ddx/datapoints/i[@t='" + vrid + "']")
        
        If Not nodes Is Nothing Then
            If nodes.count > 0 Then
                ReDim rlt(0 To CURVE_VR_SIZE_DATAPOINT * nodes.count - 1)
                
                For k = 1 To nodes.count
                    rlt(p) = GetText(cxp, nodes(k).SelectSingleNode("sn").text) 'set name
                    rlt(p + 1) = GetText(cxp, nodes(k).SelectSingleNode("rn").text) 'rule name
                    
                    Set ctnode = nodes(k).SelectSingleNode("ct")
                    If Not ctnode Is Nothing Then rlt(p + 2) = GetText(cxp, ctnode.text) 'curve type
                    
                    rlt(p + 3) = GetText(cxp, nodes(k).SelectSingleNode("st").text) 'status
                    rlt(p + 4) = GetText(cxp, nodes(k).SelectSingleNode("cs").text) 'curve type status
                    rlt(p + 5) = GetText(cxp, nodes(k).SelectSingleNode("vl").text) 'validation level
                    rlt(p + 6) = GetText(cxp, nodes(k).SelectSingleNode("ms").text) 'message
                    p = p + CURVE_VR_SIZE_DATAPOINT
                Next
                GetVR = rlt
            End If
        End If
    
    ElseIf levelNum = CURVE_VR_L_DATAPOINT_OPRS Then
        Set nodes = cxp.SelectNodes("ddx/oprs/i")
        
        If Not nodes Is Nothing Then
            If nodes.count > 0 Then
                ReDim rlt(0 To nodes.count - 1)
                
                For k = 1 To nodes.count
                    rlt(k - 1) = nodes(k).text
                Next
                
                GetVR = rlt
            End If
        End If
        
    End If

OOPS:
    If Err.Number <> 0 Then
        CDDXApp.StatusMessage = Err.Description
    End If
    Exit Function
End Function

Public Function VRExists(sht As Worksheet, cvrName As String) As Boolean
 Dim ids As Variant
 Dim k As Long
 
    ids = CSheet.WSGetProp(sht, CURVE_SHEET_VALIDATIONS)
    If ids = vbNullString Then Exit Function
    
    If cvrName = vbNullString Then
        VRExists = True
    
    Else
        ids = Split(ids, vbTab)
        
        For k = LBound(ids) + 1 To UBound(ids) Step 2
            If StrComp(ids(k), cvrName) = 0 Then
                VRExists = True
                Exit For
            End If
        Next
    End If
End Function

Private Function AddCXP(Wb As Workbook, ByVal filePath As String) As String
 Dim txt As String
 Dim cxp As CustomXMLPart
 Dim stm As Object
 
    On Error GoTo OOPS
    
    Set stm = CreateObject("ADODB.Stream")
    With stm
        .Charset = "utf-8"
        Call .Open
        Call .LoadFromFile(filePath)
    
        txt = .ReadText()
    
        Call .Close
    End With
    Set stm = Nothing
    
    Set cxp = Wb.CustomXMLParts.Add(txt)
    AddCXP = cxp.id

OOPS:
    If Err.Number <> 0 Then
        CDDXApp.StatusMessage = Err.Description
    End If
    Exit Function
End Function

Public Function AcceptedInside(sht As Worksheet, ByVal curveName As String, ByVal flgValues As Long, ByVal efDte As Double) As Boolean
 Dim cxp As CustomXMLPart
 Dim vrid As String
 Dim nodes As CustomXMLNodes
 
    On Error GoTo OOPS
       
    Set cxp = GetCXP(sht, curveName)
    If cxp Is Nothing Then Exit Function
    
    If efDte > 0 Then
        vrid = CDDXLib.DefaultZEWSProxy(DDX_PID).VRGetID(CURVE_VR_L_CURVE, curveName, flgValues, efDte, 0, vbNullString, 0)
    End If

    Set nodes = cxp.SelectNodes("ddx/curve/i" + IIf(Len(vrid) = 0, "[@a]", "[@a and @t='" + vrid + "']")) ' + "/st[text() != '" + S_ACCEPTED + "']")
    If nodes Is Nothing Then Exit Function
    
    AcceptedInside = IIf(nodes.count > 0, True, False)
    
OOPS:
    If Err.Number <> 0 Then
        CDDXApp.StatusMessage = Err.Description
    End If
    Exit Function
End Function

Public Sub Clean(Wb As Workbook)
 Dim k As Long
 Dim j As Long
 Dim all As Scripting.Dictionary
 Dim ids
 Dim cxp As CustomXMLPart

    On Error GoTo OOPS
       
    For k = Wb.Worksheets.count To 1 Step -1
        If CDDXHelper.IsCurveSheet(Wb.Worksheets(k)) Then
            ids = CSheet.WSGetProp(Wb.Worksheets(k), CURVE_SHEET_VALIDATIONS)
            If ids <> vbNullString Then
                ids = Split(ids, vbTab)
                If all Is Nothing Then Set all = New Scripting.Dictionary
                
                For j = 0 To UBound(ids) Step 2
                    Call all.Add(ids(j), ids(j + 1))
                Next
            End If
        End If
    Next
    
    With Wb.CustomXMLParts
        For k = .count To 1 Step -1
            Set cxp = .item(k)
            If Not cxp.BuiltIn Then
                If StrComp(cxp.DocumentElement.BaseName, "ddx") = 0 Then
                    If all Is Nothing Then
                        Call cxp.Delete
                    ElseIf Not all.Exists(cxp.id) Then
                        Call cxp.Delete
                    End If
                End If
            End If
        Next
    End With
    
OOPS:
    If Err.Number <> 0 Then
        CDDXApp.StatusMessage = Err.Description
    End If
    Exit Sub
End Sub

Private Function GetErrByNodes(cxp As CustomXMLPart, nodes As CustomXMLNodes, ByVal errL As Long, ByVal errA As Long) As Long
 Dim k As Long
 Dim cnt As Long
 Dim txt As String
 
    If nodes Is Nothing Then Exit Function
    cnt = nodes.count
    If cnt = 0 Then Exit Function

    For k = cnt To 1 Step -1
        txt = nodes(k).text
        
        If StrComp(txt, S_ACCEPTED) = 0 Then
            'accepted = accepted + 1
            GetErrByNodes = errA
        Else
            Select Case ConvertToVRColor(GetText(cxp, txt))
                Case CURVE_VR_COLOR_ERR, CURVE_VR_COLOR_WARNING, CURVE_VR_COLOR_UNVALIDATED:
                    GetErrByNodes = errL
                    Exit Function
            End Select
        End If
    Next
    'If accepted = cnt Then GetErrByNodes = errA
End Function

Private Function VRVersion(cxp As CustomXMLPart) As Long
 Dim k As Long
 
    With cxp.DocumentElement.Attributes
        For k = .count To 1 Step -1
            If StrComp(.item(k).BaseName, "sv") = 0 Then
                VRVersion = Int(Val(.item(k).text))
                Exit Function
            End If
        Next
    End With
End Function

Public Function GetErrLevels(sht As Worksheet, ByVal curve As String, ByVal oprDate As Variant) As Long
 Dim ids
 Dim cxp As CustomXMLPart
 Dim startidx As Long
 Dim endidx As Long
 Dim vrid As String
 Dim nodes As CustomXMLNodes
 Dim ver As Long
 
    On Error GoTo OOPS
    
    GetErrLevels = 0
    
    ids = CSheet.WSGetProp(sht, CURVE_SHEET_VALIDATIONS)
    If ids = vbNullString Then Exit Function
    ids = Split(ids, vbTab)
    
    If Len(curve) > 0 Then
        startidx = GetCXPIndex(ids, curve)
        If startidx < 0 Then Exit Function
        endidx = startidx
    Else
        startidx = 0
        endidx = UBound(ids)
    End If
    
    Do
        If startidx > endidx Then Exit Do
        
        Set cxp = sht.Parent.CustomXMLParts.SelectByID(ids(startidx))
        
        If Not cxp Is Nothing Then
            ver = VRVersion(cxp)
        
            'to check curve
            If Len(curve) > 0 And Int(oprDate) > 0 Then vrid = CDDXLib.DefaultZEWSProxy(DDX_PID).VRGetID(CURVE_VR_L_CURVE, curve, 0, oprDate, 0, vbNullString, 0)
            Set nodes = cxp.SelectNodes("ddx/curve/i" + IIf(Len(vrid) = 0, vbNullString, "[@t='" + vrid + "']") + "/st")
            GetErrLevels = GetErrLevels Or GetErrByNodes(cxp, nodes, CURVE_EL_CURVE, CURVE_EL_CURVE_ACCEPTED)
                
            'If ver <= 1 Then Exit Function
            
            'to check curve types
            If Len(curve) > 0 And Int(oprDate) > 0 Then vrid = CDDXLib.DefaultZEWSProxy(DDX_PID).VRGetID(CURVE_VR_L_OBSERVATION, curve, 0, oprDate, 0, vbNullString, 0)
            Set nodes = cxp.SelectNodes("ddx/observations/i" + IIf(Len(vrid) = 0, vbNullString, "[@t='" + vrid + "']") + "/st")
            GetErrLevels = GetErrLevels Or GetErrByNodes(cxp, nodes, CURVE_EL_CURVETYPE, CURVE_EL_CURVETYPE_ACCEPTED)
            
            'to check values
            If Len(curve) > 0 And Int(oprDate) > 0 Then vrid = CDDXLib.DefaultZEWSProxy(DDX_PID).VRGetID(CURVE_VR_L_CURVE, curve, 0, oprDate, 0, vbNullString, 0)
            Set nodes = cxp.SelectNodes("ddx/datapoints/i" + IIf(Len(vrid) = 0, vbNullString, "[@t1='" + vrid + "']") + "/st")
            GetErrLevels = GetErrLevels Or GetErrByNodes(cxp, nodes, CURVE_EL_RECORD, CURVE_EL_RECORD_ACCEPTED)
            
            Set cxp = Nothing
        End If
        
        startidx = startidx + 1
    Loop

OOPS:
    If Err.Number <> 0 Then
        Call CDDXHelper.LogError(Err.Description, "GetErrLevels")
    End If
    Exit Function
End Function

Private Sub ChangeToAccepted(cxp As CustomXMLPart, ByVal cxpPath As String, ByVal vrid As String, Optional targetNumber As Long)
 Dim nodes As CustomXMLNodes
 Dim k As Long
 Dim target As String
    
    If IsMissing(targetNumber) Then
        target = "[@t='"
    Else
        target = "[@t1='"
    End If
    
    Set nodes = cxp.SelectNodes(cxpPath + IIf(Len(vrid) = 0, vbNullString, target + vrid + "']") + "/st")
    If nodes Is Nothing Then Exit Sub
    
    For k = nodes.count To 1 Step -1
        nodes(k).text = S_ACCEPTED
    Next
End Sub

Public Sub OnAcceptCurveEx(sht As Worksheet, ByVal acceptTarget As Long, ByVal curve As String, ByVal oprDate As Variant)
 Dim k As Long
 Dim ids
 Dim cxp As CustomXMLPart
 Dim startidx As Long
 Dim vrid As String
 Dim nodes As CustomXMLNodes
 Dim xml As String
 Dim ns As Long
 
    On Error GoTo OOPS

    ids = CSheet.WSGetProp(sht, CURVE_SHEET_VALIDATIONS)
    If ids = vbNullString Then Exit Sub
    ids = Split(ids, vbTab)
    
    startidx = GetCXPIndex(ids, curve)
    If startidx < 0 Then Exit Sub

    Set cxp = sht.Parent.CustomXMLParts.SelectByID(ids(startidx))
    If cxp Is Nothing Then Exit Sub
    
'    If acceptTarget = CURVE_EL_CURVE Then
'        If Int(oprDate) > 0 Then vrid = CDDXLib.DefaultZEWSProxy(DDX_PID).VRGetID(CURVE_VR_L_CURVE, curve, 0, oprDate, 0, vbNullString, 0)
'        Call ChangeToAccepted(cxp, "ddx/curve/i", vrid)
'    End If
    
    If acceptTarget = CURVE_EL_CURVE Or acceptTarget = CURVE_EL_CURVETYPE Then
        If Int(oprDate) > 0 Then vrid = CDDXLib.DefaultZEWSProxy(DDX_PID).VRGetID(CURVE_VR_L_OBSERVATION, curve, 0, oprDate, 0, vbNullString, 0)
        Call ChangeToAccepted(cxp, "ddx/observations/i", vrid)
    End If
    
    If acceptTarget = CURVE_EL_CURVE Or acceptTarget = CURVE_EL_RECORD Then
        If Int(oprDate) > 0 Then vrid = CDDXLib.DefaultZEWSProxy(DDX_PID).VRGetID(CURVE_VR_L_CURVE, curve, 0, oprDate, 0, vbNullString, 0)
        Call ChangeToAccepted(cxp, "ddx/datapoints/i", vrid, 1)
    End If
    
    If acceptTarget <> CURVE_EL_CURVE Then
        vrid = vbNullString
        If Int(oprDate) > 0 Then vrid = CDDXLib.DefaultZEWSProxy(DDX_PID).VRGetID(CURVE_VR_L_OBSERVATION, curve, 0, oprDate, 0, vbNullString, 0)
        Set nodes = cxp.SelectNodes("ddx/observations/i" + IIf(Len(vrid) = 0, vbNullString, "[@t='" + vrid + "']") + "/st")
        ns = GetErrByNodes(cxp, nodes, CURVE_EL_CURVETYPE, CURVE_EL_CURVETYPE_ACCEPTED)
        
        vrid = vbNullString
        If Int(oprDate) > 0 Then vrid = CDDXLib.DefaultZEWSProxy(DDX_PID).VRGetID(CURVE_VR_L_CURVE, curve, 0, oprDate, 0, vbNullString, 0)
        Set nodes = cxp.SelectNodes("ddx/datapoints/i" + IIf(Len(vrid) = 0, vbNullString, "[@t1='" + vrid + "']") + "/st")
        ns = ns Or GetErrByNodes(cxp, nodes, CURVE_EL_RECORD, CURVE_EL_RECORD_ACCEPTED)
        
        If (ns And CURVE_EL_RECORD) = 0 And (ns And CURVE_EL_CURVETYPE) = 0 Then
            ns = CURVE_EL_CURVE
        Else
            ns = acceptTarget
        End If
    Else
        ns = CURVE_EL_CURVE
    End If
    
    'both curve type and record are accepted
    If ns = CURVE_EL_CURVE Or acceptTarget = CURVE_EL_CURVE Then
        If Int(oprDate) > 0 Then vrid = CDDXLib.DefaultZEWSProxy(DDX_PID).VRGetID(CURVE_VR_L_CURVE, curve, 0, oprDate, 0, vbNullString, 0)
        Call ChangeToAccepted(cxp, "ddx/curve/i", vrid)
        
        acceptTarget = CURVE_EL_CURVE
    End If
    
    If acceptTarget = CURVE_EL_CURVE Then
        Set nodes = cxp.SelectNodes("ddx/oprs/i")
        If Not nodes Is Nothing Then
            If Int(oprDate) = 0 Then
                For k = nodes.count To 1 Step -1
                    nodes(k).Delete
                Next
            Else
                For k = nodes.count To 1 Step -1
                    If Int(Val(nodes(k).text)) = Int(oprDate) Then
                        Call nodes(k).Delete
                        Exit For
                    End If
                Next
            End If
        End If
    End If
    
    xml = cxp.xml
    Call cxp.Delete
    
    Set cxp = sht.Parent.CustomXMLParts.Add(xml)
    
    ids(startidx) = cxp.id
    Call CSheet.WSSetProp(sht, CURVE_SHEET_VALIDATIONS, Join(ids, vbTab))

OOPS:
    If Err.Number <> 0 Then
        Call CDDXHelper.LogError(Err.Description, "OnAcceptCurveEx")
    End If
    Exit Sub
End Sub

Public Sub EraseVR(sht As Worksheet)
 Dim k As Long
 Dim j As Long
 Dim ids
 Dim cxp As CustomXMLPart

    On Error GoTo OOPS

    ids = CSheet.WSGetProp(sht, CURVE_SHEET_VALIDATIONS)
    If ids = vbNullString Then Exit Sub
    Call CSheet.WSRemoveProp(sht, CURVE_SHEET_VALIDATIONS)
    
    ids = Split(ids, vbTab)
    
    With sht.Parent.CustomXMLParts
        For k = .count To 1 Step -1
            Set cxp = .item(k)
            If Not cxp.BuiltIn Then
                For j = 0 To UBound(ids) Step 2
                    If StrComp(cxp.DocumentElement.BaseName, "ddx") = 0 And StrComp(cxp.id, ids(j)) = 0 Then 'ids(j + 1)
                        Call cxp.Delete
                        Exit For
                    End If
                Next
            End If
        Next
    End With
    
OOPS:
    If Err.Number <> 0 Then
        CDDXApp.StatusMessage = Err.Description
    End If
    Exit Sub
End Sub
Attribute VB_Name = "CChangeLnkHelp"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Function ChangeThis(Wb As Workbook, btn As Shape) As Long
 Dim p As Integer
 Dim mact As String
 Const SYM_BANG As String = "!"
 
    On Error GoTo OOPS
    
    With btn
        mact = .OnAction
        If mact = vbNullString Then Exit Function
        
        p = InStr(mact, SYM_BANG)
        If p > 0 Then mact = Mid(mact, p + 1)
        
        CDDXApp.DebugMessage = .OnAction
        
        .OnAction = ThisWorkbook.name + SYM_BANG + mact
        CDDXApp.DebugMessage = .OnAction
        
        ChangeThis = 1
    End With
    
OOPS:
    If Err.Number <> 0 Then
        CDDXApp.DebugMessage = Err.Description
    End If

    Exit Function
End Function

Private Function SetCreatorName(Wb As Workbook) As Boolean
 Dim cn As String
 Dim nnm As String
 
    nnm = ThisWorkbook.FullName
    cn = CSheet.DOCGetProp(Wb, ZEDOC_VER_CREATOR_NAME)
    
    If StrComp(cn, nnm, vbTextCompare) = 0 Then Exit Function
    
    Call CSheet.DOCSetProp(Wb, ZEDOC_VER_CREATOR_NAME, nnm)
    SetCreatorName = True
End Function

Public Function Execute(Wb As Workbook, ByVal execOpts As Long) As Long
 Dim sht As Worksheet
 Dim btn As Shape
 
    On Local Error GoTo OOPS
    
    If Wb Is Nothing Then Exit Function
'    If wb.Readonly Then Exit Function
    
    If execOpts = 0 Then
        Call SetCreatorName(Wb)
    ElseIf execOpts = 1 Then
        If Wb.MultiUserEditing Then Exit Function
        If CSheet.DOCVersion(Wb) = vbNullString Then Exit Function
        If Not SetCreatorName(Wb) Then Exit Function
    Else
        Exit Function
    End If
 
    CDDXApp.StatusMessage = "Changing DDX links..."
    
    For Each sht In Wb.Worksheets
        If CDDXHelper.IsCurveSheet(sht) Or CDDXHelper.IsUploadSheet(sht) Then
            For Each btn In sht.Shapes
                Execute = Execute + ChangeThis(Wb, btn)
            Next
        End If
    Next
    
OOPS:
    If Err.Number <> 0 Then
        CDDXApp.StatusMessage = Err.Description
    Else
        CDDXApp.StatusMessage = vbNullString
    End If
    
    On Local Error GoTo 0
    Exit Function
End Function
Attribute VB_Name = "CCnvtHelp"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

'Private Const COMPLETED_PERFORMED As Long = &H20000
Private Const COMPLETED_PERFORMED As Long = &H40000
Private Const COMPLETED_1X As Long = &H10000
Private Const COMPLETED_CP_41706 As Long = &H1
Private Const COMPLETED_CP_419 As Long = &H2
Private Const COMPLETED_FM_412 As Long = &H4

Private Property Get ConversionTool() As String
  Dim nm As String
  Dim k As Long
  
    nm = ThisWorkbook.FullName
    For k = Len(nm) To 1 Step -1
        If Mid(nm, k, 1) = "\" Then
            ConversionTool = left(nm, k) + "ZEDDXCnvt.xlam"
            Exit For
        End If
    Next
End Property

Private Function ContainsReports(Wb As Workbook) As Boolean
 Dim sht As Worksheet
 
    For Each sht In Wb.Worksheets
        If StrComp(sht.name, OLD_REPORTSHEETNAME, vbTextCompare) = 0 Or _
           StrComp(sht.name, OLD_PROFSHEETNAME, vbTextCompare) = 0 Then
            ContainsReports = True
            Exit For
        End If
    Next
End Function

Private Function ContainsDDXLink(Wb As Workbook) As Boolean
 Dim k As Long
 Dim ln As String
 Dim lnks
 
    On Local Error GoTo OOPS
    
    lnks = Wb.LinkSources(XlLink.xlExcelLinks)
    If IsEmpty(lnks) Then Exit Function
    
    For k = LBound(lnks) To UBound(lnks)
        ln = UCase(lnks(k))
        ContainsDDXLink = (InStr(ln, "ZE") > 0 And InStr(ln, "DATA") > 0 And InStr(ln, "DIRECT") > 0)
        If ContainsDDXLink Then Exit For
    Next
    
OOPS:
    On Local Error GoTo 0
    Exit Function
End Function

Private Function IsQConn(qt As Variant) As Boolean
 Const V1_DD_LOADPROFILE_1 As String = "/ZEData?"
 Const V1_DD_LOADPROFILE_2 As String = "/LoadProfile?request="
 Const V1_DD_LOADPROFILE_3 As String = "/invalidZEData?"
 Dim url As String

    On Error GoTo OOPS
    
    url = qt.Connection
    IsQConn = IIf(InStr(1, url, V1_DD_LOADPROFILE_1, vbTextCompare) > 1 Or InStr(1, url, V1_DD_LOADPROFILE_2, vbTextCompare) > 1 Or InStr(1, url, V1_DD_LOADPROFILE_3, vbTextCompare) > 1, True, False)
    
OOPS:
    If Err.Number <> 0 Then
        CDDXApp.StatusMessage = Err.Description
    End If
    Exit Function
End Function

Private Function ContainsWebQuery(Wb As Workbook) As Boolean
 Dim sht As Worksheet
 Dim qt As Variant
 
    On Error GoTo OOPS
    
    For Each sht In Wb.Worksheets
        For Each qt In sht.QueryTables
            ContainsWebQuery = IsQConn(qt)
            If ContainsWebQuery Then Exit Function
        Next
    Next
    
OOPS:
    On Error GoTo 0
    Exit Function
End Function

Private Function NeedConversion1X(Wb As Workbook, ver As String) As Boolean
 Dim ele() As String
 Dim sht As Worksheet
 Dim v As Long
 
    ver = CSheet.DOCVersion(Wb)
    
    If ver = vbNullString Then
        If ContainsReports(Wb) Then
            ver = "2.x"
        ElseIf ContainsDDXLink(Wb) Then
            ver = CVarHelper.GetValue(VAR_CONVERSION_STR, CVarHelper.CONVERSION_VERSION)
        ElseIf ContainsWebQuery(Wb) Then
            ver = "1.x"
        End If
    End If
    If ver = vbNullString Then Exit Function
    
    ele = Split(ver, ".")
    v = 100 * Int(Val(ele(0)))
    If UBound(ele) >= 1 Then v = v + Int(Val(ele(1)))
    
    NeedConversion1X = IIf(v < 403, True, False)
End Function
'
Private Sub CloseUptool(tool As Workbook)
    On Local Error GoTo OOPS

    If tool Is Nothing Then Exit Sub
    Call tool.Close

OOPS:
    On Local Error GoTo 0
    Exit Sub
End Sub

Private Function GetMacroCmd(ByVal wkName As String, ByVal macroName As String) As String
 Dim k As Long
 
    For k = Len(wkName) To 1 Step -1
        If Mid(wkName, k, 1) = "\" Then
            GetMacroCmd = Mid(wkName, k + 1) + "!" + macroName
            Exit For
        End If
    Next
End Function

Private Function IsWkUTD(Wb As Workbook) As Boolean
 Dim wkv As Variant
 Dim ddxv As Variant
 Dim k As Long
 Dim v0 As Long
 Dim v1 As Long
 
    wkv = CSheet.DOCVersion(Wb)
    If wkv = vbNullString Then Exit Function
    
    ddxv = Split(CDDXApp.DDXVersion(Nothing), ".")
    wkv = Split(wkv, ".")
    
    k = 0
    Do
        If k > UBound(wkv) Or k > UBound(ddxv) Then
            IsWkUTD = IIf(UBound(wkv) >= UBound(ddxv), True, False)
            Exit Function
        End If
        
        v0 = Int(Val(ddxv(k)))
        v1 = Int(Val(wkv(k)))
        
        If v1 <> v0 Then
            IsWkUTD = IIf(v1 > v0, True, False)
            Exit Function
        End If
        
        k = k + 1
    Loop
End Function

Public Function Execute(Wb As Workbook, resultMsg As String) As Boolean
 Dim tool As Workbook
 Dim toolnm As String
 Dim ver As String
 Dim ret As String
 Dim masks As Long
 Dim cf As Long
 Dim ze As Boolean
 
    On Error GoTo OOPS
    
    If Wb.Readonly Then Exit Function
    If IsHigherVersion(Wb, True) Then Exit Function
    
    Application.EnableCancelKey = xlDisabled
    
    If Not Wb Is Nothing Then
        If Wb.Readonly Then
            resultMsg = "Unable to write Readonly workbook."
            Exit Function
        End If
    End If
    
    ze = CDDXHelper.IsZEDoc(Wb)
    If Not ze Then
        If CVarHelper.GetValue(VAR_CONVERSION_STR, CVarHelper.CONVERSION_SKIP_UNVERSIONED) = "1" Then
            resultMsg = "The workbook is unversioned, and thus skipped."
            Exit Function
        End If
    End If
    
    masks = Int(Val(CSheet.DOCGetProp(Wb, ZEDOC_CONVERTION_COMPLETED)))
    cf = CompletionMasks
    
    If (masks And cf) = cf Then
        resultMsg = "The workbook is up to date."
        Exit Function
    End If
    
    If IsWkUTD(Wb) Then
        Call SetMasks(Wb, masks Or cf) 'make up for missing
        resultMsg = "The workbook is up to date."
        Exit Function
    End If
    
    cf = 0
    If Not CDDXHelper.IsFlag(masks, COMPLETED_1X) Then
        If NeedConversion1X(Wb, ver) Then
            cf = cf Or COMPLETED_1X
        Else
            masks = masks Or COMPLETED_1X
        End If
    End If
    
    If cf = 0 And Not ze Then
        Exit Function
    End If
    
    If Not CDDXHelper.IsFlag(masks, COMPLETED_FM_412) Then
        cf = cf Or COMPLETED_FM_412
    End If
    
    If Not CDDXHelper.IsFlag(masks, COMPLETED_CP_41706) Then
        If CDDXHelper.IsSharedMode(Wb) Then
            resultMsg = "Unable to write workbook in Shared mode."
            Exit Function
        End If
        cf = cf Or COMPLETED_CP_41706
    End If
    
    If Not CDDXHelper.IsFlag(masks, COMPLETED_CP_419) Then
        If CDDXHelper.IsSharedMode(Wb) Then
            resultMsg = "Unable to write workbook in Shared mode."
            Exit Function
        End If
        cf = cf Or COMPLETED_CP_419
    End If
    
    If cf = 0 Then
        resultMsg = "The workbook is up to date."
        Exit Function
    End If
    
    toolnm = ConversionTool
    If toolnm = vbNullString Then
        resultMsg = "Unable to find the tool."
        Exit Function
    End If
    
    Call CXLEvents.DisableEvents

    Call CDDXHelper.LogMessage(ver + "   " + Wb.FullName, "RunConversionUtil")
    CDDXApp.StatusMessage = "Upgrading " + Wb.name + " ..."
  
    Set tool = Workbooks.Open(toolnm, Readonly:=True)

    resultMsg = vbNullString
    
    If CDDXHelper.IsFlag(cf, COMPLETED_1X) Then
        resultMsg = Application.Run(GetMacroCmd(toolnm, "RunCnvt1X"), Wb.name, ver, Val(CVarHelper.GetValue(VAR_CONVERSION_STR, CVarHelper.CONVERSION_BACKUP)), vbNullString, vbNullString)
        If resultMsg <> vbNullString Then
            CDDXApp.StatusMessage = resultMsg
        Else
            masks = masks Or COMPLETED_1X
        End If
    End If
    
    If CDDXHelper.IsFlag(cf, COMPLETED_FM_412) Then
        If ze Then
            ret = Application.Run(GetMacroCmd(toolnm, "RunCnvtFM412"), Wb.name, CDDXDates.SystemDateFormat, vbNullString)
            If ret <> vbNullString Then
                resultMsg = resultMsg + IIf(resultMsg = vbNullString, vbNullString, vbCrLf) + ret
                CDDXApp.StatusMessage = ret
            Else
                masks = masks Or COMPLETED_FM_412
            End If
        Else
            masks = masks Or COMPLETED_FM_412
        End If
    End If
    
    If CDDXHelper.IsFlag(cf, COMPLETED_CP_419) Or CDDXHelper.IsFlag(cf, COMPLETED_CP_41706) Then
        Call PresetFVS(Wb)
    End If
    
    If CDDXHelper.IsFlag(cf, COMPLETED_CP_41706) Then
        If ze Then
            ret = Application.Run(GetMacroCmd(toolnm, "RunCnvt41706"), Wb.name, CDDXDates.SystemDateFormat, vbNullString)
            If ret <> vbNullString Then
                resultMsg = resultMsg + IIf(resultMsg = vbNullString, vbNullString, vbCrLf) + ret
                CDDXApp.StatusMessage = ret
            Else
                masks = masks Or COMPLETED_CP_41706
            End If
        Else
            masks = masks Or COMPLETED_CP_41706
        End If
    End If
    
    If CDDXHelper.IsFlag(cf, COMPLETED_CP_419) Then
        If ze Then
            ret = Application.Run(GetMacroCmd(toolnm, "RunCnvt419"), Wb.name, CDDXDates.SystemDateFormat, vbNullString)
            If ret <> vbNullString Then
                resultMsg = resultMsg + IIf(resultMsg = vbNullString, vbNullString, vbCrLf) + ret
                CDDXApp.StatusMessage = ret
            Else
                masks = masks Or COMPLETED_CP_419
            End If
        Else
            masks = masks Or COMPLETED_CP_419
        End If
    End If

    Call CloseUptool(tool)
    Set tool = Nothing
    
    Call SetMasks(Wb, masks Or COMPLETED_PERFORMED)
    
    Execute = True
    
OOPS:
    If Err.Number <> 0 Then
        resultMsg = Err.Description
        CDDXApp.StatusMessage = resultMsg
    End If
    
    Call CloseUptool(tool)
    Set tool = Nothing
    
    If resultMsg <> vbNullString Then
        Call CDDXHelper.LogMessage(resultMsg, "RunConversionUtil")
    Else
        CDDXApp.StatusMessage = vbNullString
    End If
    
    Call CXLEvents.RestoreEvents
    Exit Function
End Function

Private Sub PresetFVS(Wb As Workbook)
 Dim sht As Worksheet
 
    For Each sht In Wb.Worksheets
        Call CDDXCurve.GetFVS(sht)
    Next
End Sub

Private Function IsHigherVersion(Wb As Workbook, ByVal showWarning As Boolean) As Boolean
 Dim v0 As Variant
 Dim v As Variant
 Dim rlt As Long
 Dim msg As String
 
    v = CSheet.DOCVersion(Wb)
    If v = vbNullString Then Exit Function
    v = Split(v, ".")
    If UBound(v) < 1 Then Exit Function
    
    v0 = Split(CDDXApp.DDXVersion(Nothing), ".")
    
    rlt = Int(Val(v0(0))) - Int(Val(v(0)))
    If rlt = 0 Then rlt = Int(Val(v0(1))) - Int(Val(v(1)))
    
    If rlt < 0 Then
        msg = "The workbook was created or saved in a higher version so as not to work correctly. (" + CSheet.DOCVersion(Wb) + ")"
        
        If showWarning Then Call CDDXApp.DialogMessage(msg, vbCritical)
        CDDXApp.StatusMessage = msg
        
        IsHigherVersion = True
    End If
End Function

Public Property Get CompletionMasks() As Long
    CompletionMasks = COMPLETED_FM_412 Or COMPLETED_CP_41706 Or COMPLETED_CP_419 Or COMPLETED_1X
End Property

Public Sub SetMasks(Wb As Workbook, ByVal masks As Long)
 Dim v As Long
 
    v = Int(Val(CSheet.DOCGetProp(Wb, ZEDOC_CONVERTION_COMPLETED)))
    If (masks And v) = masks Then Exit Sub
    
    Call CSheet.DOCSetProp(Wb, ZEDOC_CONVERTION_COMPLETED, CDDXHelper.ToHexStr(v Or masks))
End Sub
Attribute VB_Name = "CCurveControl"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Const STARTF_SHOW As Long = &H100
Private Const STARTF_AFTER_CALL_WS As Long = &H1
Private Const STARTF_NOTIFY_UI As Long = &H2

Private Const ATTRIB_CELL_PROTECTION As Long = &H1
Private Const ATTRIB_CELL_4EYES As Long = &H2
Private Const ATTRIB_CELL_COMMENT As Long = &H4
Private Const PROT_TEXT As String = "Protected"
 '
Private Const CLEARANCE_BACKGROUND As Long = &H1
Private Const CLEARANCE_COMMENT_FONT As Long = &H2

Private Const UD_DATERANGE_NEW As Integer = &H1
Private Const UD_DATERANGE_REFRESH As Integer = &H2
Private Const UD_DATERANGE_UPLOAD As Integer = &H3
'
Private Const UD_SINGLEDATE_NEW As Integer = &H10
'
Private Const UD_SINGLEDATE_REFRESH As Integer = &H20
Private Const UD_SINGLEDATE_UPLOAD As Integer = &H30
Private Const UD_SINGLEDATE_REFRESH_INDIVIDUAL As Integer = &H40
'
Private Const FXIED_COLUMNS_TRANSPOSED As Long = 6
'
Private Const MSG_DATA_RETRIEVAL As String = "Downloading Curves ..."

'
Private m_enableEvents As Boolean
Private m_screenUpdating As Boolean
Private m_displayAlerts As Boolean
Private m_calculation
'
Public m_isExtend As Boolean
'
Private m_flag_start As Long
Public m_sheetid As String

Private m_curveRgn As range
Private m_oprRgn As range
Private m_contractRgn As range
Private m_dataRgn As range

Private Type TOprTS
    oprDate As Double
    curveType As String
End Type

Private m_ts_oprs() As TOprTS
Private m_ts_sorted() As TOprTS
Private m_ts_inputs() As TOprTS

Private m_dpi(0 To 1) As Long

Private Sub BeginUpdate()
    With Application
        If Not .Ready Then Exit Sub
    
        m_enableEvents = .EnableEvents
        m_screenUpdating = .ScreenUpdating
        m_displayAlerts = .DisplayAlerts
        m_calculation = .Calculation
        
        If m_enableEvents Then .EnableEvents = False
        If m_screenUpdating Then .ScreenUpdating = False
        If m_displayAlerts Then .DisplayAlerts = False

        .DisplayStatusBar = False
        .Calculation = xlCalculationManual
    End With
End Sub

Private Sub ResetCalculation()
    On Error GoTo OOPS
    
    With Application
        If .Calculation <> m_calculation Then
            .Calculation = m_calculation
        End If
    End With
    
OOPS:
    If Err.Number <> 0 Then
        CDDXApp.DebugMessage = Err.Description
    End If
    On Error GoTo 0
    Exit Sub
End Sub

Private Sub EndUpdate()
    With Application
        If Not .Ready Then Exit Sub

        Call ResetCalculation
        .EnableEvents = True

        .DisplayAlerts = True
        .DisplayStatusBar = True
        .ScreenUpdating = True
    End With
End Sub

Public Sub NotifyUI()
    m_flag_start = m_flag_start And (Not STARTF_AFTER_CALL_WS)
    m_flag_start = m_flag_start Or STARTF_NOTIFY_UI
End Sub

Private Sub ShowProgressBox()
    m_flag_start = STARTF_SHOW
End Sub

Private Sub HideProgressBox()
    If (m_flag_start And STARTF_SHOW) = 0 Then Exit Sub
    m_flag_start = m_flag_start And (Not STARTF_SHOW)
    
    Call CDDXCurve.NotifyEndTask(DDX_PID)
End Sub

Private Function RefineErrMessage(ByVal value As String) As String
 Dim p1 As Long
 Dim p2 As Long
 Dim sr As Long
 Dim sc As Long
 Dim n As Long
 
    Do
        p1 = InStr(value, "%%%")
        If p1 <= 1 Then Exit Do
        p1 = p1 + 3
        
        If sr = 0 Then
            Call GetSplits(ActiveSheet, CCurveDates.ParamEntity, sr, sc)
            If sr <= 1 Or sc <= 1 Then Exit Do
        End If
        
        p2 = p1
        Do
            If p2 > Len(value) Then Exit Do
            n = Asc(Mid(value, p2, 1))
            If n < Asc("0") Or n > Asc("9") Then Exit Do
            p2 = p2 + 1
        Loop
        If p2 = p1 Then Exit Do

        n = Val(Mid(value, p1, p2 - p1)) + IIf(CCurveDates.ParamEntity.IsFlag(CURVE_FLG_PIVOT), sc, sr)
        value = left(value, p1 - 3 - 1) + CStr(n) + Mid(value, p2)
    Loop
    
    RefineErrMessage = value
End Function

Private Function GetCreator() As Long
    GetCreator = Int(Val(CSheet.WSGetProp(ActiveSheet, CURVE_SHEET_CREATORS)))
End Function

'Public Function GetCreaterVersion() As Long
'    GetCreaterVersion = GetCreator() And &HF
'End Function

Public Function IsUIUpToDate() As Boolean
    IsUIUpToDate = IIf((GetCreator() And &H10000) <> 0, True, False)
End Function

Private Function NeedsRelayout() As Boolean
 Dim creators As Long

    creators = GetCreator()
    If (creators And &HF) <> 0 Or (creators And &H10000) <> 0 Then Exit Function
    
    creators = creators Or &H10000
    Call CSheet.WSSetProp(ActiveSheet, CURVE_SHEET_CREATORS, CStr(creators))
    
    NeedsRelayout = True
End Function

Private Sub SetCreators(userData As CCurveUserData)
' first 4 bits : creator
 ' next 4 bits : updater
 ' the 9th bit : relayouted
 Dim creators As Long
 Dim updater As Long
    
    creators = Int(Val(CSheet.WSGetProp(ActiveSheet, CURVE_SHEET_CREATORS)))
    
    If (userData.opCode = UD_DATERANGE_NEW Or userData.opCode = UD_SINGLEDATE_NEW) And userData.IsEditing = False Then
        creators = creators Or CURVE_SHEET_CREATORS_1
    Else
        updater = CURVE_SHEET_CREATORS_1
        updater = 16 * updater
        creators = creators Or updater
    End If
    
    Call CSheet.WSSetProp(ActiveSheet, CURVE_SHEET_CREATORS, CStr(creators))
End Sub

Public Sub OnCompleted(data As ZEWSProxy.CurveResult)
 Dim msg As String
 Dim userData As CCurveUserData
 Dim iserr As Boolean
 
    On Error GoTo OOPS:
    
    Application.EnableCancelKey = xlDisabled
    
    'Call UnloadProgressBox
    
    CDDXApp.StatusMessage = vbNullString
    
    Set userData = New CCurveUserData
    Call userData.FromXML(data.userData)
    
    iserr = (data.Cancelled Or data.Error <> vbNullString)
    
    If iserr Then
        Call HideProgressBox
        
        msg = IIf(data.Cancelled, "Aborted", RefineErrMessage(data.Error))
        CDDXHelper.LastMessage = msg
        
        If Not CDDXApp.Quiet Then
            Call CDDXApp.DialogMessage(msg, vbExclamation)
        Else
            Call CDDXHelper.LogError(msg, "OnCompleted")
        End If
        
    Else
        Call BeginUpdate
    
        Select Case Abs(userData.opCode)
        'date range
            Case UD_DATERANGE_NEW, _
                 UD_DATERANGE_REFRESH, _
                 UD_DATERANGE_UPLOAD:
                    Call OnDateRange(data, userData)

        'single date
            Case Else:
                Call OnSingleDate(data, userData)
        End Select
        
        Call CDDXHelper.MarkZEDoc(DDX_PID, Application.ActiveWorkbook)
        Call SetCreators(userData)

        If NeedsRelayout() Then Call CCurveDates.Handler.IFReLayout
    End If
    
OOPS:
    If Err.Number <> 0 Then
        msg = RefineErrMessage(Err.Description)
        Call CDDXHelper.LogError(msg, "OnCompleted")
    End If
    
    If Not iserr Then Call EndUpdate
    
    Set CCurveDates.Handler = Nothing

    Call HideProgressBox
    
    Select Case Abs(userData.opCode)
        Case UD_DATERANGE_UPLOAD, UD_SINGLEDATE_UPLOAD:
            'Call CDDXCurve.RaiseUploadCompletedEvent(BSConsts.DDX_PID, ActiveWorkbook.ActiveSheet, msg)
            Call CDDXCurve.RaiseCurveEvent(DDX_PID, CURVE_EVENT_UPLOAD_COMPLETED, vbNullString, ActiveWorkbook.ActiveSheet, msg)
            
        Case UD_DATERANGE_REFRESH, UD_SINGLEDATE_REFRESH, UD_SINGLEDATE_REFRESH_INDIVIDUAL:
            'Call CDDXCurve.RaiseDownloadCompletedEvent(BSConsts.DDX_PID, ActiveWorkbook.ActiveSheet, msg)
            Call CDDXCurve.RaiseCurveEvent(DDX_PID, CURVE_EVENT_DOWNLOAD_COMPLETED, vbNullString, ActiveWorkbook.ActiveSheet, msg)
    End Select

    On Error GoTo 0
    Exit Sub
End Sub

Private Sub OnDateRange(data As ZEWSProxy.ICurveResult, ud As CCurveUserData)
    Select Case Abs(ud.opCode)
        Case UD_DATERANGE_NEW:
            Set CCurveDates.Handler = CCurveDates.GetHandler(ud.flagValues)
        Case Else:
            Call Unprotect(CCurveDates.TargetSheet)
    End Select
    
    With CCurveDates.Handler
        Select Case Abs(ud.opCode)
            Case UD_DATERANGE_NEW:
                Call .IFNew(data, ud)
            
            Case UD_DATERANGE_REFRESH:
                Call .IFRefresh(data)
                
            Case UD_DATERANGE_UPLOAD:
                Call .IFUpload(data, 0)
        End Select
    End With
    
End Sub

Private Sub OnSingleDate(data As ZEWSProxy.ICurveResult, ud As CCurveUserData)
    Select Case Abs(ud.opCode)
        Case UD_SINGLEDATE_NEW:
            Set CCurveDates.Handler = CCurveDates.GetHandler(ud.flagValues)
            
        Case Else:
            Call Unprotect(CCurveDates.TargetSheet)
    End Select
    
    With CCurveDates.Handler
        Select Case Abs(ud.opCode)
            Case UD_SINGLEDATE_NEW:
                Call .IFNew(data, ud) ' locked unlocked
                
            Case UD_SINGLEDATE_REFRESH:
                Call .IFRefresh(data)
                
            Case UD_SINGLEDATE_UPLOAD:
                Call .IFUpload(data, ud.opSubCode) ' userdata.Quiet)
                
            Case UD_SINGLEDATE_REFRESH_INDIVIDUAL:
                Call .IFRefreshIndividual(data, ud.RefreshTarget) '1:prev '2:current '3 both
        End Select
        
    End With
End Sub

Public Function NewDateRangeCurve(ByVal aSheetID As String, aCurve As Variant, ByVal aStartDate As String, ByVal aEndDate As String, ByVal aExclWeekends As String, ByVal aExclHolidays As String, ByVal aGranularity As Long, ByVal flagValues As Long, ByVal aIsEditing As Boolean) As Boolean
 Dim udte() As Double
 Dim userData As CCurveUserData
 Dim curv() As String
 Dim granularities() As Long
 Dim curveTypes() As String
 
    If CDDXLogin.SessionExpired() Then Exit Function
    If WndHandle() = 0 Then Exit Function
    
    Set userData = New CCurveUserData
    With userData
        .opCode = UD_DATERANGE_NEW
        .flagValues = flagValues
        .SelectedGranularities = aGranularity
    End With
    
    If (VarType(aCurve) And vbString) <> 0 Then
        If (VarType(aCurve) And vbArray) <> 0 Then
            If Join(aCurve) > 0 Then
                curv = aCurve
            End If
        Else
            ReDim curv(0 To 0)
            curv(0) = aCurve
        End If
    End If
    
    Call ShowProgressBox
    
    With CDDXLib.DefaultZEWSProxy(DDX_PID)
        Call .DownloadCurves(aSheetID, CDDXLogin.CredentialToken(DDX_PID), curv, _
                            CDbl(CDDXDates.CDateSafe(aStartDate)), CDbl(CDDXDates.CDateSafe(aEndDate)), _
                            aExclWeekends, aExclHolidays, _
                            udte, _
                            granularities, _
                            curveTypes, _
                            flagValues, _
                            DownloadOpOptions, _
                            userData.ToXML())
    End With
    Set userData = Nothing
    
    Call SetTask(aSheetID, MSG_DATA_RETRIEVAL, vbNullString)
    
    NewDateRangeCurve = True
End Function

Public Function InputFileName(ByVal aSheetID) As String
    InputFileName = CDDXLib.DefaultZEWSProxy(DDX_PID).HelperResultsetFileName(aSheetID, 0) + ".inputs"
End Function

Private Sub SaveProps2File(ByVal shtid As String, propNames As Variant)
 Dim fn As String
 Dim file As Object
 Dim k As Long
 Dim cntprops As Long
' Dim cntctypes As Long
 Dim errmsg As String
 
    If (VarType(propNames) And vbString) <> 0 Then
        If (VarType(propNames) And vbArray) <> 0 Then
            If Len(Join(propNames)) > 0 Then cntprops = UBound(propNames) + 1
        End If
    End If
    
'    If (VarType(curveTypeHeaders) And vbString) <> 0 Then
'        If (VarType(curveTypeHeaders) And vbArray) <> 0 Then
'            If Len(Join(curveTypeHeaders)) > 0 Then cntctypes = UBound(curveTypeHeaders) + 1
'        End If
'    End If

    fn = CDDXLib.DefaultZEWSProxy(DDX_PID).HelperResultsetFileName(shtid, 0) + ".props"
    
    If cntprops <= 0 Then
        Call CDDXHelper.DeleteFile(fn)
        Exit Sub
    End If
    
    Set file = CDDXFile.OpenWriteStream()
    
    Call file.WriteText(CStr(cntprops), 1)
    For k = 0 To cntprops - 1
        Call file.WriteText(propNames(k), 1)
    Next

    Call file.WriteText("0", 1)
'    Call file.WriteText(CStr(cntctypes), 1)
'    cntctypes = cntctypes - 1
'    For k = 0 To cntctypes
'        Call file.WriteText(curveTypeHeaders(k), IIf(k = cntctypes, 0, 1))
'    Next
    
    Call CDDXFile.SaveWriteStream(file, fn, errmsg)
    If errmsg <> vbNullString Then CDDXApp.StatusMessage = errmsg
End Sub

Public Function NewSingleDateCurves(ByVal aSheetID As String, _
                                    aCurves As Variant, _
                                    ByVal aStartDate As String, ByVal aEndDate As String, _
                                    aExclWeekends, aExclHolidays, _
                                    ByVal aGranularity As Long, _
                                    ByVal flagValues As Long, _
                                    aProps As Variant, _
                                    ByVal aCriterion As String, _
                                    ByVal aIsEditing As Boolean) As Boolean
 Dim userData As CCurveUserData
 Dim contra() As Double
 Dim granularities() As Long
 Dim curveTypes() As String
 Dim curvs() As String
 
    If CDDXLogin.SessionExpired() Then Exit Function
    If WndHandle() = 0 Then Exit Function
    
    If (VarType(aCurves) And vbString) <> 0 Then
        If (VarType(aCurves) And vbArray) <> 0 Then
            curvs = aCurves
        Else
            ReDim curvs(0)
            curvs(0) = aCurves
        End If
    End If
    
    Call SaveProps2File(aSheetID, aProps)
    
    Call ShowProgressBox
    
    If aIsEditing Then
        If CDDXHelper.IsFlag(flagValues, CURVE_FLG_TIMESERIES) Or CDDXDates.CDateSafe(aStartDate) = CCurveDates.ParamEntity.OprStartDate Then
            Call PersistInputs
            contra = CCurveDates.ContractDateList
        End If
            
        If CDDXHelper.IsFlag(flagValues, CURVE_FLG_MULTIOBS) Then
            curveTypes = CCurveDates.CurveTypeList
            If Not CDDXHelper.IsFlag(flagValues, CURVE_FLG_TIMESERIES) Then
                granularities = CCurveDates.GranularityList
            End If
        End If
    End If
    
    Set userData = New CCurveUserData
    With userData
        .opCode = UD_SINGLEDATE_NEW
        .Criterion = aCriterion
        .IsEditing = aIsEditing
        .flagValues = flagValues
        .SelectedGranularities = aGranularity
    End With
    
    With CDDXLib.DefaultZEWSProxy(DDX_PID)
        Call .DownloadCurves(aSheetID, CDDXLogin.CredentialToken(DDX_PID), curvs, _
                                  CDbl(CDDXDates.CDateSafe(aStartDate)), CDbl(CDDXDates.CDateSafe(aEndDate)), _
                                  aExclWeekends, aExclHolidays, _
                                  contra, _
                                  granularities, _
                                  curveTypes, _
                                  flagValues, _
                                  DownloadOpOptions Or IIf(CDDXHelper.IsFlag(flagValues, CURVE_FLG_TIMESERIES) Or Not aIsEditing, 0, CURVE_OP_STRICT_INPUTS), _
                                  userData.ToXML)
    End With
    
    Set userData = Nothing
    
    Call SetTask(aSheetID, MSG_DATA_RETRIEVAL, vbNullString)
    
    NewSingleDateCurves = True
End Function

Public Function RefreshDateRangeCurve(sht As Worksheet, params As CCurveParams, ByVal PreserveInputs As Boolean, ByVal preserveContracts As Boolean) As Boolean
 Dim curves() As String
 Dim taskID As String
 Dim udtes() As Double
 Dim userData As CCurveUserData
 Dim granularities() As Long
 Dim curveTypes() As String

    If params Is Nothing Then
        Set params = New CCurveParams
        Call params.FromXML(CCurveControl.GetCurveProperties(sht))
    End If
    
    If PreserveInputs Then
        Call PersistInputs
    End If
    
    Set userData = New CCurveUserData
    With userData
        .opCode = UD_DATERANGE_REFRESH
        .PreserveInputs = PreserveInputs
    End With

    With params
        curves = .curves
        taskID = .sheetId

        Call ShowProgressBox
        
        If preserveContracts Then
            udtes = CCurveDates.ContractDateList
            If .IsFlag(CURVE_FLG_MULTIOBS) Then
                If Not .IsFlag(CURVE_FLG_TIMESERIES) Then
                    granularities = CCurveDates.GranularityList
                End If
                curveTypes = CCurveDates.CurveTypeList
            End If
        End If
        
        Call CDDXLib.DefaultZEWSProxy(DDX_PID).DownloadCurves(.sheetId, CDDXLogin.CredentialToken(DDX_PID), _
                            curves, _
                            CDbl(.OprStartDate), _
                            CDbl(.OprEndDate), _
                            .exclWeekEnds, .exclHolidays, _
                            udtes, _
                            granularities, _
                            curveTypes, _
                            .flagValues, _
                            DownloadOpOptions Or IIf(preserveContracts, CURVE_OP_STRICT_INPUTS, 0), _
                            userData.ToXML())
                            
        Call SetTask(.sheetId, MSG_DATA_RETRIEVAL, vbNullString)
    End With
    
    Set userData = Nothing
    
    RefreshDateRangeCurve = True
End Function

Private Function GetCurvesWithAccepted(sht As Worksheet, params As CCurveParams, ByVal cvrName As String) As String()
 Dim cvrs() As String
 Dim opr  As Variant
 Dim accepted() As String
 Dim k As Long
 Dim p As Long
 
    If params.IsFlag(CURVE_FLG_TIMESERIES) Or params.IsFlag(CURVE_FLG_FUTURE_RANGE) Then
        opr = 0
    Else
        opr = CCurveDates.EffectiveDateList
        opr = opr(IIf(params.IsFlag(CURVE_FLG_MRBD), 1, 0))
    End If
    
    If Len(cvrName) = 0 Then
        cvrs = params.curves
        ReDim accepted(LBound(cvrs) To UBound(cvrs))
        
        p = 0
        For k = LBound(cvrs) To UBound(cvrs)
            If CCPVRStorage.AcceptedInside(sht, cvrs(k), params.flagValues, opr) Then
                accepted(p) = cvrs(k)
                p = p + 1
            End If
        Next
        If p = 0 Then Exit Function
        
        ReDim Preserve accepted(0 To p - 1)
    Else
        If Not CCPVRStorage.AcceptedInside(sht, cvrName, params.flagValues, opr) Then Exit Function
        
        ReDim accepted(0 To 0)
        accepted(0) = cvrName
    End If
    
    GetCurvesWithAccepted = accepted
End Function

Public Function RefreshSingleDateCurves(sht As Worksheet, params As CCurveParams) As Boolean
 Dim taskID As String
 Dim granularities() As Long
 Dim curveTypes() As String
 Dim userData As CCurveUserData
 Dim contra() As Double
 Dim oprstart As Double
 Dim oprend As Double
 
    If params Is Nothing Then
        Set params = New CCurveParams
        Call params.FromXML(CCurveControl.GetCurveProperties(sht))
    End If
    
    Set userData = New CCurveUserData
    With userData
        .opCode = UD_SINGLEDATE_REFRESH
    End With

    With params
        Call SaveProps2File(.sheetId, .PropertyNames)
        
        If .IsFlag(CURVE_FLG_TIMESERIES) Then
            Call GetRefreshDateRangeIndividual(vbNullString, 0, oprstart, oprend)
        Else
            oprstart = CDbl(.OprStartDate)
            oprend = CDbl(.OprEndDate)
        End If
        
        taskID = .sheetId
        Call ShowProgressBox
               
        Call CDDXLib.DefaultZEWSProxy(DDX_PID).DownloadCurves(.sheetId, CDDXLogin.CredentialToken(DDX_PID), _
                        .curves, _
                        oprstart, oprend, _
                        .exclWeekEnds, .exclHolidays, _
                        contra, _
                        granularities, _
                        curveTypes, _
                        .flagValues, _
                        DownloadOpOptions, _
                        userData.ToXML())
        
        Call SetTask(.sheetId, MSG_DATA_RETRIEVAL, vbNullString)
        
        RefreshSingleDateCurves = True
    End With
    
    Set userData = Nothing
End Function

Private Function GetCellValue(rgn As Variant, ByVal isCell As Boolean) As String
 Dim buf As String
 
    If isCell Then
        GetCellValue = Trim(rgn.text)
        If Not IsNumeric(GetCellValue) Then
            GetCellValue = Trim(rgn.Value2)
        End If
    Else
        GetCellValue = Trim(rgn)
    End If
End Function

Private Function WriteDataLine(num As Integer, v As Variant, rdonly() As Boolean, ByVal incr As Long, hasvalues As Boolean) As Boolean
 Dim buf As String
 Dim row As Long
 Dim col As Long
 Dim count As Long
 Dim tabcount As Long
 Dim ok As Boolean
 
    If StrComp(TypeName(v), "range", vbTextCompare) = 0 Then
        count = v.Columns.count
        If count > 1 Then
            For col = IIf(incr = 2, 2, 1) To count Step IIf(incr = 2, 2, 1)
                ok = IIf(incr = 0, True, False)
                If Not ok Then ok = Not rdonly(col \ incr - 1)
                
                If ok Then
                    buf = buf + IIf(tabcount = 0, vbNullString, vbTab) + GetCellValue(v.Cells(1, col), True)
                    tabcount = tabcount + 1
                End If
            Next
        Else
            count = v.rows.count
            For row = IIf(incr = 2, 2, 1) To count Step IIf(incr = 2, 2, 1)
                ok = IIf(incr = 0, True, False)
                If Not ok Then ok = Not rdonly(row \ incr - 1)
                If ok Then
                    buf = buf + IIf(tabcount = 0, vbNullString, vbTab) + GetCellValue(v.Cells(row, 1), True)
                    tabcount = tabcount + 1
                End If
            Next
        End If
            
    Else
        If (VarType(v) And vbArray) = 0 Then
            tabcount = 1
            buf = GetCellValue(v, False)
        Else
            count = UBound(v, 2)
            If count > 1 Then
                For col = IIf(incr = 2, 2, 1) To count Step IIf(incr = 2, 2, 1)
                    ok = IIf(incr = 0, True, False)
                    If Not ok Then ok = Not rdonly(col \ incr - 1)
                    
                    If ok Then
                        buf = buf + IIf(tabcount = 0, vbNullString, vbTab) + GetCellValue(v(1, col), False)
                        tabcount = tabcount + 1
                    End If
                Next
            Else
                count = UBound(v, 1)
                For row = IIf(incr = 2, 2, 1) To count Step IIf(incr = 2, 2, 1)
                    ok = IIf(incr = 0, True, False)
                    If Not ok Then ok = Not rdonly(row \ incr - 1)
                    If ok Then
                        buf = buf + IIf(tabcount = 0, vbNullString, vbTab) + GetCellValue(v(row, 1), False)
                        tabcount = tabcount + 1
                    End If
                Next
            End If
        End If
    End If
    
    Print #num, buf
    If Not hasvalues Then
        count = Len(buf)
        If count > 0 And count > tabcount - 1 Then hasvalues = True
    End If
End Function

Private Function WriteMultiDataLines(num As Integer, v, hasvalues As Boolean) As Boolean
 Dim buf As String
 Dim row As Long
 Dim col As Long
 Dim count As Long
 
    If StrComp(TypeName(v), "range", vbTextCompare) = 0 Then
        For col = 1 To v.Columns.count
            For row = 1 To v.rows.count
                buf = GetCellValue(v.Cells(row, col), True)
                Print #num, buf
                If Not hasvalues Then
                    hasvalues = IIf(Len(buf) = 0, False, True)
                End If
            Next
        Next
    Else
        If (VarType(v) And vbArray) = 0 Then
            count = 1
            buf = GetCellValue(v, False)
            Print #num, buf
            
            If Not hasvalues Then
                hasvalues = IIf(Len(buf) = 0, False, True)
            End If
        Else
            
            For col = 1 To UBound(v, 2)
                For row = 1 To UBound(v, 1)
                    buf = GetCellValue(v(row, col), False)
                    
                    Print #num, buf
            
                    If Not hasvalues Then
                        hasvalues = IIf(Len(buf) = 0, False, True)
                    End If
                Next
            Next
        End If
    End If
End Function

Private Function SaveToFile(params As CCurveParams, ByVal curveIndex As Long) As Boolean
 Dim fn As String
 Dim rowCount As Long
 Dim row As Long
 Dim col As Long
 Dim num As Integer
 Dim curveNames() As String
 Dim rdonly() As Boolean
 Dim k As Long
 Dim v As Variant
 Dim oprcount As Long
 Dim hasvalues As Boolean
 Dim granularities() As Long
 Dim curveTypes() As String
 
    hasvalues = False
    
    If Not GetAreas(curveIndex) Then Exit Function
    
    fn = CDDXLib.DefaultZEWSProxy(DDX_PID).HelperResultsetFileName(CSheet.ZESheetID(m_dataRgn.Parent), 0)
    Call CDDXHelper.DeleteFile(fn)
    
    On Local Error GoTo OOPS
    
    oprcount = 0
    If params.IsFlag(CURVE_FLG_FUTURE_RANGE) Then
        oprcount = m_dataRgn.Columns.count
    Else
        If curveIndex < 0 Then
            ReDim rdonly(LBound(params.curves) To UBound(params.curves))
            
            For k = LBound(params.curves) To UBound(params.curves)
                rdonly(k) = params.Readonly(k)
                If Not rdonly(k) Then oprcount = oprcount + 1
            Next
        Else
            oprcount = 1
        End If
    End If
    
    num = FreeFile
    
    Open (fn) For Output As #num
    
'count of columns
    Print #num, CStr(oprcount)
    
    'curve names
    curveNames = params.curves
    
    If params.IsFlag(CURVE_FLG_FUTURE_RANGE) Then
        Print #num, curveNames(0)
    Else
        If curveIndex < 0 Then
            For k = LBound(curveNames) To UBound(curveNames)
                If Not rdonly(k) Then Print #num, curveNames(k)
            Next
        Else
            Print #num, curveNames(curveIndex)
        End If
    End If
    
    'opr dates
    If Not params.IsFlag(CURVE_FLG_TIMESERIES) Then
        v = m_oprRgn.Value2
        
        If (VarType(v) And vbArray) = 0 Then
            Print #num, CStr(v)
        Else
            If params.IsFlag(CURVE_FLG_FUTURE_RANGE) Then
                For col = LBound(v, 2) To UBound(v, 2)
                    Print #num, CStr(v(1, col))
                Next
            Else
                If curveIndex < 0 Then
                    For k = LBound(curveNames) To UBound(curveNames)
                        If Not rdonly(k) Then
                            If params.IsFlag(CURVE_FLG_PIVOT) Then
                                Print #num, CStr(v(k + 1, 1))
                            Else
                                Print #num, CStr(v(1, IIf(params.IsFlag(CURVE_FLG_MRBD), 2, 1) * (k + 1)))
                            End If
                        End If
                    Next
                Else
                    If params.IsFlag(CURVE_FLG_PIVOT) Then
                        Print #num, CStr(v(curveIndex + 1, 1))
                    Else
                        Print #num, CStr(v(1, IIf(params.IsFlag(CURVE_FLG_MRBD), 2, 1)))
                    End If
                End If
            End If
        End If
    End If
    
'count of rows
    Print #num, CStr(IIf(params.IsFlag(CURVE_FLG_PIVOT), m_contractRgn.Columns.count, m_contractRgn.rows.count))
    
    If params.IsFlag(CURVE_FLG_MULTIOBS) Then
        If Not params.IsFlag(CURVE_FLG_TIMESERIES) Then
            granularities = CCurveDates.GranularityList
            For k = LBound(granularities) To UBound(granularities)
                Print #num, CStr(granularities(k))
            Next
        End If
        
        curveTypes = CCurveDates.CurveTypeList
        For k = LBound(curveTypes) To UBound(curveTypes)
            Print #num, curveTypes(k)
        Next
    End If
    
    If params.IsFlag(CURVE_FLG_PIVOT) Then
        v = m_contractRgn.rows(1).Value2
    Else
        v = m_contractRgn.Columns(1).Value2
    End If
    hasvalues = True
    Call WriteMultiDataLines(num, v, hasvalues)
    
'data lines
    hasvalues = False
    
    If params.IsFlag(CURVE_FLG_FUTURE_RANGE) Then
        With m_dataRgn
            rowCount = .rows.count
            For row = 1 To rowCount
                Set v = .rows(row) '.Value2
                Call WriteDataLine(num, v, rdonly, 0, hasvalues)
            Next
        End With
        
    Else
        If curveIndex < 0 Then
            If params.IsFlag(CURVE_FLG_PIVOT) Then
                For k = 1 To m_dataRgn.Columns.count
                    Set v = m_dataRgn.Columns(k) '.Value2
                    Call WriteDataLine(num, v, rdonly, 1, hasvalues)
                Next
            Else
                For k = 1 To m_dataRgn.rows.count
                    Set v = m_dataRgn.rows(k) '.Value2
                    Call WriteDataLine(num, v, rdonly, IIf(params.IsFlag(CURVE_FLG_MRBD), 2, 1), hasvalues)
                Next
            End If
        Else
        
            If params.IsFlag(CURVE_FLG_PIVOT) Then
                Set v = m_dataRgn.rows(1) '.Value2
            Else
                Set v = m_dataRgn.Columns(IIf(params.IsFlag(CURVE_FLG_MRBD), 2, 1)) '.Value2
            End If
            Call WriteMultiDataLines(num, v, hasvalues)
        End If
    End If
    
    Close #num
    num = -1
    
'    If Not CDDXCurve.UploadNulls And Not hasvalues And Not params.IsFlag(CURVE_FLG_TIMESERIES) Then
'        If CDDXApp.Quiet Then
'            CDDXApp.StatusMessage = "No values found"
'        Else
'            Call CDDXApp.DialogMessage("No values found", vbInformation)
'        End If
'    Else
        SaveToFile = True
'    End If
    
OOPS:
    If Err.Number <> 0 Then
        If Err.Number <> 0 Then Call CDDXHelper.LogError(Err.Description, "SaveToFile")
    End If
    
    If num > 0 Then Close #num
    On Local Error GoTo 0
    
    If Not SaveToFile Then
        Call CDDXHelper.DeleteFile(fn)
    End If
    
    Exit Function
End Function

Public Function UploadDateRangeCurve() As Boolean
 Dim userData As CCurveUserData
 Dim cvrs() As String
 
    If CDDXLogin.SessionExpired() Then Exit Function

    If Not SaveToFile(CCurveDates.ParamEntity, -1) Then Exit Function
 
    Set userData = New CCurveUserData
    With userData
        .opCode = UD_DATERANGE_UPLOAD
    End With
    
    cvrs = GetCurvesWithAccepted(ActiveSheet, CCurveDates.ParamEntity, vbNullString)
    
    With CCurveDates.ParamEntity
        Call ShowProgressBox

        Call CDDXLib.DefaultZEWSProxy(DDX_PID).UploadCurves(.sheetId, _
                            CDDXLogin.sid, _
                            CurveFilePath, _
                            .flagValues, _
                            UploadOpOptions, _
                            cvrs, _
                            userData.ToXML())

        Call SetTask(.sheetId, "Uploading Curves...", vbNullString)
    End With
    
    Set userData = Nothing

    UploadDateRangeCurve = True
End Function

Public Function UploadSingleDateCurves() As Boolean
 Dim userData As CCurveUserData
 Dim cvrs() As String
 
    If CDDXLogin.SessionExpired() Then Exit Function
    
    If Not SaveToFile(CCurveDates.ParamEntity, -1) Then Exit Function
    
    Set userData = New CCurveUserData
    With userData
        .opCode = UD_SINGLEDATE_UPLOAD
        .opSubCode = 0
    End With
    
    cvrs = GetCurvesWithAccepted(ActiveSheet, CCurveDates.ParamEntity, vbNullString)
    
    With CCurveDates.ParamEntity
        Call ShowProgressBox
    
        Call CDDXLib.DefaultZEWSProxy(DDX_PID).UploadCurves(.sheetId, _
                                CDDXLogin.sid, _
                                CurveFilePath, _
                                .flagValues, _
                                UploadOpOptions, _
                                cvrs, _
                                userData.ToXML())

        Call SetTask(.sheetId, "Uploading Curves...", vbNullString)
    End With
    
    Set userData = Nothing
    UploadSingleDateCurves = True
End Function

Public Function UploadSingleDateCurvesIndividual(ByVal aGroupName As String, ByVal aCurveName As String) As Boolean
 Dim idx As Long
 Dim userData As CCurveUserData
 Dim cvrs() As String
 
    If CDDXLogin.SessionExpired() Then Exit Function

    idx = CCurveDates.ParamEntity.GetCurvePosition(aCurveName)
    If idx < 0 Then Exit Function
        
    Set userData = New CCurveUserData
    With userData
        .opCode = UD_SINGLEDATE_UPLOAD
        .opSubCode = idx + 1
    End With
    
    cvrs = GetCurvesWithAccepted(ActiveSheet, CCurveDates.ParamEntity, aCurveName)
    
    With CCurveDates.ParamEntity
        If Not SaveToFile(CCurveDates.ParamEntity, idx) Then Exit Function
        
        Call ShowProgressBox
        
        Call CDDXLib.DefaultZEWSProxy(DDX_PID).UploadCurves(.sheetId, CDDXLogin.sid, _
                            CurveFilePath, _
                            .flagValues, _
                            UploadOpOptions, _
                            cvrs, _
                            userData.ToXML())
                            
        Call SetTask(.sheetId, "Uploading Curve...", aCurveName)
    End With
    
    Set userData = Nothing
    UploadSingleDateCurvesIndividual = True
End Function

Public Function DeleteSingleDateCurve(sheet As Worksheet, ByVal aGroupName As String, ByVal aCurveName As String) As Boolean
    Call BeginUpdate
    Call CCurveDates.Handler.IFDelete(sheet, aGroupName, aCurveName)
    Call EndUpdate
End Function

Private Sub GetRefreshDateRangeIndividual(ByVal aCurveName As String, ByVal RefreshTarget As Integer, startdte As Double, enddte As Double)
 Dim cvs() As String
 Dim v As Variant
 Dim k As Long
             
    With CCurveDates
        If .ParamEntity.IsFlag(CURVE_FLG_TIMESERIES) Then
            If Not .ParamEntity.IsFlag(CURVE_FLG_EDIT_DATES) Then
                startdte = CDbl(.ParamEntity.OprStartDate)
                enddte = CDbl(.ParamEntity.OprEndDate)
            Else
                v = CCurveDates.ContractDateList
                
                If CDDXUtility.IsArrayEmpty(v) Then
                    startdte = CDbl(.ParamEntity.OprStartDate)
                    enddte = CDbl(.ParamEntity.OprEndDate)
                Else
                    For k = LBound(v) To UBound(v)
                        If k = LBound(v) Then
                            startdte = v(k)
                            enddte = v(k)
                        Else
                            If startdte > v(k) Then startdte = v(k)
                            If enddte < v(k) Then enddte = v(k)
                        End If
                    Next
                End If
            End If
        Else
            If (RefreshTarget And CURVE_DOWNLOAD_RECENT) = 0 Or Not .ParamEntity.IsFlag(CURVE_FLG_MRBD) Then
                startdte = CDbl(.ParamEntity.OprStartDate)
                enddte = startdte
            Else
                enddte = CDbl(.ParamEntity.OprStartDate)
                cvs = .ParamEntity.curves
                For k = LBound(cvs) To UBound(cvs)
                    If StrComp(cvs(k), aCurveName) = 0 Then Exit For
                Next
                If k > UBound(cvs) Then
                    Err.Raise vbObjectError + 1, "GetRefreshDateRangeIndividual", aCurveName + " not found"
                End If
                
                Call GetAreas(k)
                If m_oprRgn Is Nothing Then
                    Call GetAreas(k, False)
                End If
                
                v = m_oprRgn.Value2
                startdte = v(1, 1)
            End If
        End If
    End With
End Sub

Public Sub RefreshSingleDateCurvesIndividual(sht As Worksheet, ByVal aGroupName As String, ByVal aCurveName As String, ByVal RefreshTarget As Integer)
 Dim curves(0) As String
 Dim taskID As String
 Dim oprstart As Double
 Dim oprend As Double
 Dim userData As CCurveUserData
 Dim flags As Long
 Dim gvals() As Long
 Dim ctvals() As String

    If CDDXLogin.SessionExpired() Then Exit Sub
    
    Set userData = New CCurveUserData
    With userData
        .opCode = UD_SINGLEDATE_REFRESH_INDIVIDUAL
        .RefreshTarget = RefreshTarget
    End With

    With CCurveDates.ParamEntity
        Call SaveProps2File(.sheetId, .PropertyNames)
        
        curves(0) = aCurveName
        taskID = .sheetId
        Call ShowProgressBox
        
        flags = .flagValues
        
        If RefreshTarget = CURVE_DOWNLOAD_RECENT Or RefreshTarget = CURVE_DOWNLOAD_CURRENT Then '2 current 1 previous
            flags = flags And (Not CURVE_FLG_MRBD_COMPLETE)
        End If
        
        If .IsFlag(CURVE_FLG_MULTIOBS) Then
            ctvals = CCurveDates.CurveTypeList
            If Not .IsFlag(CURVE_FLG_TIMESERIES) Then
                gvals = CCurveDates.GranularityList
            End If
        End If
        
        Call GetRefreshDateRangeIndividual(aCurveName, RefreshTarget, oprstart, oprend)
        Call CDDXLib.DefaultZEWSProxy(DDX_PID).DownloadCurves(.sheetId, CDDXLogin.CredentialToken(DDX_PID), _
                                    curves, _
                                    oprstart, oprend, _
                                    .exclWeekEnds, .exclHolidays, _
                                    CCurveDates.ContractDateList, _
                                    gvals, _
                                    ctvals, _
                                    flags, _
                                    DownloadOpOptions Or CURVE_OP_STRICT_INPUTS, _
                                    userData.ToXML())
        
        Call SetTask(.sheetId, "Downloading Curve...", aCurveName)
    End With
    
    Set userData = Nothing
End Sub

Private Function LimitExceeded(ByVal op As Integer, ByVal aCountToAdd As Long) As Boolean
 Dim mr As Long
 Dim mc As Long
 Dim m As Long
 
    If op = CURVE_UI_CONTRACTS_START_MINUS Or op = CURVE_UI_CONTRACTS_END_MINUS Then Exit Function
    
    Call CDDXLib.DefaultZEWSProxy(DDX_PID).GetLimits(mr, mc)
    
    With CCurveDates.ParamEntity
        m = IIf(.IsFlag(CURVE_FLG_PIVOT), mc, mr)
        
        LimitExceeded = IIf(aCountToAdd + .rowCount > m, True, False)
        If LimitExceeded Then
            CDDXApp.StatusMessage = "Exceeded the limit. (" + CStr(m) + ")"
        End If
    End With
End Function

Private Sub AddContractsFLX(ByVal op As Integer, ByVal dateCount As Long)
 Dim dtes() As Double

    If LimitExceeded(op, dateCount) Then Exit Sub
    
    Call BeginUpdate
    Call Unprotect(ActiveSheet)
    Call CCurveDates.Handler.IFNewContracts(dateCount, op, dtes)
    Call EndUpdate
End Sub

Public Sub AddContracts(sheet As Worksheet, ByVal op As Integer, ByVal aFrom As Date, ByVal aTo As Date)
 Dim direction As Long
 Dim Pivoted As Boolean
 Dim dates() As Double
 Dim cvs() As String
 Dim length As Long
 Dim tmp As Date
 Dim k As Long
 Dim d1 As Double
 Dim d2 As Double
 
    On Local Error GoTo OOPS
    
    If op <> CURVE_UI_CONTRACTS_START_MINUS And op <> CURVE_UI_CONTRACTS_END_MINUS Then
        If Not CacheCurves(-1, False, True) Then Exit Sub
    End If
    
    If CDDXCurve.ContractsEditable(DDX_PID) Then
        Call AddContractsFLX(op, aFrom)
        Exit Sub
    End If
    
    If aFrom > aTo Then
        tmp = aFrom
        aFrom = aTo
        aTo = tmp
    End If

    Call CCurveDates.GetContractBounds(d1, d2)
    
    With CCurveDates.ParamEntity

        If op <> CURVE_UI_CONTRACTS_START_MINUS And op <> CURVE_UI_CONTRACTS_END_MINUS Then
            cvs = CCurveDates.ParamEntity.curves
            dates = CDDXLib.DefaultZEWSProxy(DDX_PID).GenerateCurveDates(CDDXLogin.sid, cvs(0), op, CDbl(aFrom), CDbl(aTo), _
                                            .exclWeekEnds, _
                                            .exclHolidays, _
                                            m_isExtend, _
                                            .flagValues)
    
'            dates = Split(rlt, vbTab)
            length = UBound(dates) - LBound(dates) + 1
            
            If LimitExceeded(op, length) Then Exit Sub
            
            If d2 = 0 Then
                direction = 0
            ElseIf CCurveDates.CompareDates(CDate(d2), aFrom) < 0 Then
                direction = 1
            Else
                direction = -1
            End If

            If Pivoted Then
                .ColumnCount = .ColumnCount + length
            Else
                .rowCount = .rowCount + length
            End If
'
'            dates = Split(dtes, vbTab)

        Else
            If .rowCount <= 2 Then Exit Sub
            
            dates = CCurveDates.ContractDateList

            If UBound(dates) = LBound(dates) Then
                If Pivoted Then
                    Exit Sub
                End If

                'dates(UBound(dates)) = 0
                Erase dates
                direction = 2
            ElseIf op = CURVE_UI_CONTRACTS_END_MINUS Then  'CCurveDates.CompareDates(CDate(d2), aFrom) = 0 Then
                'dates(UBound(dates)) = 0
                ReDim Preserve dates(LBound(dates) To UBound(dates) - 1)
                direction = 2
            Else
                'dates(LBound(dates)) = 0
                For k = LBound(dates) To UBound(dates) - 1
                    dates(k) = dates(k + 1)
                Next
                ReDim Preserve dates(LBound(dates) To UBound(dates) - 1)
                direction = -2
            End If

'            rlt = vbNullString
'            For k = LBound(dates) To UBound(dates)
'                If dates(k) <> vbNullString Then
'                    If Len(rlt) > 0 Then rlt = rlt + vbTab
'                    rlt = rlt + dates(k)
'                End If
'            Next k

'            dates = Split(rlt, vbTab)

            If Pivoted Then
                .ColumnCount = .ColumnCount - 1
            Else
                .rowCount = .rowCount - 1
            End If

        End If

        Call SaveCurveProperties(sheet, CCurveDates.ParamEntity)

    End With

    Call BeginUpdate
    Call Unprotect(sheet)
    Call CCurveDates.Handler.IFNewContracts(direction, 0, dates) 'Pivoted -> 0
    'Call CDDXCurve.Protect(BSConsts.DDX_PID, sheet)
    Call EndUpdate
    
OOPS:
    If Err.Number <> 0 Then
        Call CDDXApp.DialogMessage(Err.Description, vbExclamation)
    End If
    
    On Local Error GoTo 0
    Exit Sub
End Sub

Public Sub sort(ByVal aColumn As Long)
 Dim curve As New CCPFutureRange

    Call BeginUpdate
    Call Unprotect(ActiveSheet)

    Call curve.IFSort(aColumn)

    'Call CDDXCurve.Protect(BSConsts.DDX_PID, ActiveSheet)
    Call EndUpdate
End Sub

Public Sub sorts(ByVal aGroupName As String, ByVal aCurveName As String)
    Call BeginUpdate
    Call Unprotect(ActiveSheet)

    Call CCurveDates.Handler.IFSort(aGroupName, aCurveName)

    'Call CDDXCurve.Protect(BSConsts.DDX_PID, ActiveSheet)
    Call EndUpdate
End Sub

Public Function Affected(data As ZEWSProxy.ICurveResult, ByVal curveName As String) As Boolean
 Dim result() As ZEWSProxy.IInsertUpdateCurveDataResult
 Dim k As Integer

    result = data.UploadResult
    
    For k = LBound(result) To UBound(result)
        If curveName = vbNullString Or StrComp(result(k).curveName, curveName) = 0 Then
           If result(k).numRecordsInserted + result(k).numRecordsUpdated + result(k).numRecordsDeleted > 0 Then
                Affected = True
                Exit Function
            End If
        End If
    Next
End Function

Public Sub SetDateVaules(ByVal granuVal As Long, rgn As range, dtVals() As Double)
  Dim k As Long
 
    With rgn
        .NumberFormat = CDDXCurve.GetContractDateFormat(granuVal)
        If .rows.count > 1 Then
            For k = 1 To .rows.count
                .Cells(k, 1).Value2 = dtVals(k - 1)
            Next
        Else
            For k = 1 To .Columns.count
                .Cells(1, k).Value2 = dtVals(k - 1)
            Next
        End If
    End With
End Sub

Public Sub SetDateValue(ByVal fmtVal As String, rgn As range, dtVal As Variant)
    With rgn
        .NumberFormat = fmtVal
        If VarType(dtVal) = vbDate Then
            .value = dtVal
        Else
            .Value2 = CDbl(dtVal)
        End If
    End With
End Sub

Private Sub SetAfterUploaded(ByVal curveIndex As Long)
 Dim rgn As range
 Dim rn As Long
 Dim cn As Long
 
    Call GetAreas(curveIndex)
    
    If m_dataRgn Is Nothing Then Exit Sub
'    For Each rgn In m_dataRgn
'        With rgn
'            If .Font.ColorIndex = CURVE_CHANGE_CLR_IDX Then
'                .Font.ColorIndex = xlColorIndexAutomatic
'            End If
''            If .Comment Is Nothing Then
''                .Font.ColorIndex = xlColorIndexAutomatic 'CURVE_DATA_CLR_IDX
''            End If
'        End With
'    Next
'    'm_dataRgn.Font.ColorIndex = xlColorIndexAutomatic'CURVE_DATA_CLR_IDX
    
    With Application.FindFormat
        .Clear
        .Font.ColorIndex = CURVE_CHANGE_CLR_IDX
    End With

    Do
        Set rgn = m_dataRgn.Find(what:=vbNullString, After:=IIf(rn = 0, m_dataRgn.Cells(1, 1), rgn), _
                LookIn:=xlFormulas, LookAt:=xlPart, _
                SearchOrder:=xlByRows, SearchDirection:=xlNext, _
                MatchCase:=False, SearchFormat:=True)
        
        If rgn Is Nothing Then Exit Do
        
        If rn = 0 Then
            rn = rgn.row
            cn = rgn.column
        Else
            If rn = rgn.row And cn = rgn.column Then Exit Do
        End If
        
        rgn.Font.ColorIndex = xlColorIndexAutomatic
    Loop
End Sub

Private Function GetPosInUpResult(cvrName As String, upRlt() As ZEWSProxy.CurveInsertUpdateResult) As Long
 Dim startpos As Long
 Dim endpos As Long
 Dim tmp As Long
 Dim ret As Long
 
    startpos = LBound(upRlt)
    endpos = UBound(upRlt)
    
    tmp = (startpos + endpos) \ 2
    Do
        ret = StrComp(cvrName, upRlt(tmp).curveName, vbBinaryCompare)
        If ret = 0 Then
            GetPosInUpResult = tmp
            Exit Function
        End If
        
        If startpos = endpos Then Exit Do
            
        If ret < 0 Then
            endpos = IIf(endpos = tmp, tmp - 1, tmp)
        Else
            startpos = IIf(startpos = tmp, tmp + 1, tmp)
        End If
        
        If startpos > endpos Then Exit Do
    
        tmp = (startpos + endpos) \ 2
    Loop
    
    GetPosInUpResult = -1
End Function

Private Function GetUploadedItmsByCurveName(params As CCurveParams, sheet As Worksheet, data As ZEWSProxy.ICurveResult, count As Long) As Long()
 Dim result As New CCurveParams
 Dim cvnm() As String
 Dim uptime() As String
 Dim lut As Variant
 Dim k As Long
 Dim j As Long
 Dim upr() As ZEWSProxy.CurveInsertUpdateResult
 Dim idx() As Long

    cvnm = params.curves
    uptime = params.LastUploadTime
    
    Call result.FromXML(data.value)

    upr = data.UploadResult
    lut = result.LastUploadTime
    lut = lut(0)
    
    count = 0
    
    For j = LBound(cvnm) To UBound(cvnm)
        k = GetPosInUpResult(cvnm(j), upr)
        
        If k >= 0 Then
            If upr(k).numRecordsInserted + upr(k).numRecordsUpdated + upr(k).numRecordsDeleted > 0 Then
                If count = 0 Then
                    ReDim idx(LBound(cvnm) To UBound(cvnm))
                End If
                
                uptime(j) = lut
                
                idx(count) = j
                count = count + 1
                
            End If
        End If
    Next
    If count <= 0 Then Exit Function
    
    params.LastUploadTime = uptime
    ReDim Preserve idx(0 To count - 1)
    
    For k = 0 To count - 1
        Call SetAfterUploaded(idx(k))
    Next
    
    GetUploadedItmsByCurveName = idx
End Function

Public Function GetUploadedItms(params As CCurveParams, sheet As Worksheet, data As ZEWSProxy.ICurveResult, ByVal byCurveName As Boolean, count As Long) As Long()
 Dim result As New CCurveParams
 Dim cvnm() As String
 Dim uptime() As String
 Dim tmpuptime() As String
 Dim k As Long
 Dim j As Long
 Dim m As Long
 Dim resultant() As ZEWSProxy.CurveInsertUpdateResult
 Dim oprDates As Variant
 Dim items() As Long
 
    If byCurveName Then
        GetUploadedItms = GetUploadedItmsByCurveName(params, sheet, data, count)
        Exit Function
    End If
    
    count = 0
    cvnm = params.curves
    uptime = params.LastUploadTime
    
    Call result.FromXML(data.value)
    
    With result
        resultant = data.UploadResult
        tmpuptime = .LastUploadTime
        
        For k = LBound(resultant) To UBound(resultant)
            For j = LBound(cvnm) To UBound(cvnm)
                If resultant(k).curveName = cvnm(j) Then
                    If resultant(k).numRecordsInserted + resultant(k).numRecordsUpdated + resultant(k).numRecordsDeleted > 0 Then
                        uptime(j) = tmpuptime(0)
                        
                        If IsEmpty(oprDates) Then oprDates = CCurveDates.EffectiveDateList
                        For m = LBound(oprDates) To UBound(oprDates)
                            If CCurveDates.CompareDoubles(CDbl(oprDates(m)), CDbl(resultant(k).oprDate)) = 0 Then
                                If count = 0 Then ReDim items(LBound(oprDates) To UBound(oprDates))
                                items(count) = m
                                count = count + 1
                                Exit For
                            End If
                        Next
                    End If
                    
                    Exit For
                End If
            Next
        Next
    End With
    
    If count > 0 Then
        params.LastUploadTime = uptime
        ReDim Preserve items(0 To count - 1)
        
        For k = 0 To count - 1
            Call SetAfterUploaded(items(k))
        Next
        
        GetUploadedItms = items
    End If
End Function

Public Function GetColumnLetter(adr As String) As String
 Dim p As Long
 
    p = InStr(2, adr, "$")
    If p > 1 Then
        GetColumnLetter = Mid(adr, 2, p - 2)
    End If
End Function

Private Function ToInvalidDateStr(v As Variant, ByVal r As Long) As String
    On Error GoTo OOPS
    
    ToInvalidDateStr = "Invalid Date. "
    ToInvalidDateStr = ToInvalidDateStr + str(CDate(v))
    Call Application.GoTo(m_contractRgn.Cells(r, 1), True)
    
OOPS:
    Exit Function
End Function

Private Function ValidateContractDates() As Boolean
 Dim r As Long
 Dim v
    
    If CCurveDates.ParamEntity.IsFlag(CURVE_FLG_EDIT_DATES) Then
        v = m_contractRgn.Value2
        If (VarType(v) And vbArray) = 0 Then
            If Not IsDateType(v) Then
                CDDXHelper.LastMessage = ToInvalidDateStr(v, 1)
                Exit Function
            End If
        Else
            For r = LBound(v, 1) To UBound(v, 1)
                If Not IsDateType(v(r, 1)) Then
                    CDDXHelper.LastMessage = ToInvalidDateStr(v(r, 1), r)
                    Exit Function
                End If
            Next
        End If
    End If
    
    ValidateContractDates = True
End Function

Private Function IsDateType(v As Variant) As Boolean
Dim t As Variant

    If iserror(v) Then Exit Function
    t = VarType(v)
    IsDateType = IIf(t = vbDouble Or t = vbDecimal Or t = vbLong Or t = vbInteger, True, False)
    If IsDateType Then IsDateType = IIf(v > 0.1, True, False)
End Function

Private Function ValidateOprDates() As Boolean
 Dim c As Long
 Dim v
    
    If CCurveDates.ParamEntity.IsFlag(CURVE_FLG_EDIT_DATES) And _
        Not CCurveDates.ParamEntity.IsFlag(CURVE_FLG_TIMESERIES) And _
        Not CCurveDates.ParamEntity.IsFlag(CURVE_FLG_MULTIOBS) Then
        v = m_oprRgn.Value2
        If (VarType(v) And vbArray) = 0 Then
            If Not IsDateType(v) Then
                CDDXHelper.LastMessage = "Invalidate Opr Date"
                Exit Function
            End If
        Else
            For c = LBound(v, 2) To UBound(v, 2)
                If Not IsDateType(v(1, c)) Then
                    CDDXHelper.LastMessage = "Invalidate Opr Date"
                    Exit Function
                End If
            Next
        End If
    End If
    
    ValidateOprDates = True
End Function

Public Function ValidateSheet(ByVal curveIndex As Long, hasnulls As Boolean) As Boolean
 Dim fc As range
 Dim cc As range
        
    If Not GetAreas(curveIndex) Then Exit Function
    
    If Not ValidateOprDates() Then Exit Function
    If Not ValidateContractDates() Then Exit Function
    
    With Application.FindFormat
        .Clear
        .Font.ColorIndex = CURVE_ERROR_CLR_IDX
    End With

    Set fc = m_dataRgn.Find(what:=vbNullString, After:=m_dataRgn.Cells(1, 1), _
        LookIn:=xlFormulas, LookAt:=xlPart, _
        SearchOrder:=xlByRows, SearchDirection:=xlNext, _
        MatchCase:=False, SearchFormat:=True)
        
    Set cc = fc
    Do
        If cc Is Nothing Then Exit Do
        
        If cc.text <> vbNullString Then
            CDDXHelper.LastMessage = "Error found ( Row " + CStr(cc.row) + ", Col " + GetColumnLetter(cc.Address) + " )"
            Exit Function
        End If

        Set cc = m_dataRgn.Find(what:=vbNullString, After:=cc, _
            LookIn:=xlFormulas, LookAt:=xlPart, _
            SearchOrder:=xlByRows, SearchDirection:=xlNext, _
            MatchCase:=False, SearchFormat:=True)
            
        If cc Is Nothing Then Exit Do
        If cc.Address = fc.Address Then Exit Do
    Loop
    
    'If Not CDDXCurve.UploadNulls Then
        hasnulls = IIf(EmptyCell() > 0, True, False)
    'End If
    ValidateSheet = True
End Function

'Private Function CellExists(dateRgn As range, cellType, Optional cellValue) As Long
' Dim rgn As range
'
'    On Local Error GoTo OOPS
'    Set rgn = dateRgn.SpecialCells(cellType, cellValue)
'    If rgn Is Nothing Then Exit Function
'
'    CellExists = rgn.row
'
'OOPS:
'    If Err.Number <> 0 Then
'
'    End If
'    On Local Error GoTo 0
'    Exit Function
'End Function

'Private Function ErrorCell(dtaRgn As range) As Long
' Dim fc As range
'
''    ErrorCell = CellExists(dtaRgn, xlCellTypeConstants, xlErrors)
''    If ErrorCell > 0 Then Exit Function
''
''    ErrorCell = CellExists(dtaRgn, xlCellTypeFormulas, xlErrors)
''    If ErrorCell > 0 Then Exit Function
'''
'''    ErrorCell = CellExists(dtaRgn, xlCellTypeConstants, xlTextValues)
'''    If ErrorCell > 0 Then Exit Function
''
'''    ErrorCell = CellExists(dtaRgn, xlCellTypeFormulas, xlTextValues)
'''    If ErrorCell > 0 Then Exit Function
'
'
'    With Application.FindFormat
'        .Clear
'        .Font.ColorIndex = CURVE_ERROR_CLR_IDX
'    End With
'
'    Set fc = dtaRgn.Find(What:=vbNullString, After:=dtaRgn.Cells(1, 1), _
'        LookIn:=xlFormulas, LookAt:=xlPart, _
'        SearchOrder:=xlByRows, SearchDirection:=xlNext, _
'        MatchCase:=False, SearchFormat:=True)
'
'    If Not fc Is Nothing Then
'        ErrorCell = fc.row
'        Exit Function
'    End If
'End Function

Private Function EmptyCell() As Long
 Dim fc As range
 
    Set fc = m_dataRgn.Find(what:=vbNullString, After:=m_dataRgn.Cells(1, 1), _
        LookIn:=xlValues, LookAt:=xlWhole, _
        SearchOrder:=xlByRows, SearchDirection:=xlNext, _
        MatchCase:=False, SearchFormat:=False)
        
    If Not fc Is Nothing Then
        EmptyCell = fc.row
    End If
End Function

Private Sub SetCellColor(target As range, ByVal clr As Long, ByVal dteFmt As String, ByVal typName As String, ByRef PROTECTED As Long)
 Dim f As Long
 
    On Error GoTo OOPS
    f = IIf(target.Characters.Font.ColorIndex <> clr, &H1, 0)
    f = f Or IIf(Len(dteFmt) <> 0, &H2, 0)
    f = f Or IIf(Len(typName) <> 0, &H4, 0)
    
    If f <> 0 Then
        If PROTECTED = 0 Then
            PROTECTED = PROTECTED Or &H1
            If Not target.Parent.Protection.AllowFormattingCells Then
                PROTECTED = PROTECTED Or &H2
                Call Unprotect(target.Parent)
            End If
        End If
        
        If CDDXHelper.IsFlag(f, &H1) Then target.Characters.Font.ColorIndex = clr
        If CDDXHelper.IsFlag(f, &H2) Then Call CCurveGranularity.SetContractDateFormat(target, dteFmt)
        If CDDXHelper.IsFlag(f, &H4) Then Call CCurveType.SetValueDateFormat(target, typName)
    End If
    
OOPS:
    If Err.Number <> 0 Then
        CDDXApp.StatusMessage = Err.Description
    End If
    
    On Error GoTo 0
    Exit Sub
End Sub

Private Property Get ScreenDPI(verti As Boolean) As Long
 Dim dc As LongPtr
 
    If m_dpi(0) = 0 Then
        dc = GetDC(0)
        m_dpi(0) = GetDeviceCaps(dc, 88)
        m_dpi(1) = GetDeviceCaps(dc, 90)
        Call ReleaseDC(0, dc)
    End If
    
    ScreenDPI = m_dpi(IIf(verti, 1, 0)) '96
End Property

Private Function Point2Pixel(pt As Single, verti As Boolean) As Long
  Point2Pixel = pt * ScreenDPI(verti) / 72
End Function

Private Sub GetCellRect(ByVal level As Long, ByVal rgn As range, ByRef rc As RECT)
 Dim wnd As Window
 Dim pn As Long
 
    If level = CURVE_VR_L_OBSERVATION Then
        pn = 2
    Else
        pn = 3
    End If
    
    Set wnd = Application.ActiveWindow
    With rgn
        rc.left = wnd.Panes(2).PointsToScreenPixelsX(0) + Point2Pixel(rgn.left * wnd.Zoom / 100, False)
        rc.top = wnd.Panes(pn).PointsToScreenPixelsY(0) + Point2Pixel(rgn.top * wnd.Zoom / 100, True)
        rc.right = Point2Pixel(.Width * wnd.Zoom / 100, False) + rc.left
        rc.bottom = Point2Pixel(.Height * wnd.Zoom / 100, True) + rc.top
    End With
End Sub

Public Function OnDoubleClick(ByVal sh As Object, ByVal target As range, ByRef cvrName As String, ByRef rcLeft As Long, ByRef rcBottom As Long) As Boolean
 Dim rc As RECT
 Dim pt As POINTAPI
 Dim col As Long
 Dim levelNum As Long
 Dim odte As Double
 Dim cdte As Double
 Dim ctname As String
 Dim gname As Variant
 Dim vr As Variant
 Dim splitcol As Long
 Dim splitrow As Long
 
    If target.rows.count > 1 Then Exit Function
    If target.Columns.count > 2 Then Exit Function
    
    Set CCurveDates.TargetSheet = ActiveSheet
    
    If Not GetCPSplits(CCurveDates.ParamEntity, ActiveSheet, splitrow, splitcol) Then Exit Function
    
    With target
        If CCurveDates.ParamEntity.IsFlag(CURVE_FLG_PIVOT) Then
   
        Else
            If .column <= splitcol Then Exit Function
        End If
    End With

    Call GetAreas(-1)
    
    If Not m_curveRgn Is Nothing Then
        With m_curveRgn
            If target.row >= .row And target.row <= .row + .rows.count - 1 And target.column >= .column And target.column <= .column + .Columns.count - 1 Then levelNum = CURVE_VR_L_OBSERVATION
        End With
    End If
    
    If Not m_dataRgn Is Nothing Then
        With m_dataRgn
            If target.row >= .row And target.row <= .row + .rows.count And _
               target.column >= .column And target.column <= .column + .Columns.count Then levelNum = CURVE_VR_L_DATAPOINT
        End With
    End If
    
    If levelNum = 0 Then Exit Function
    
    Call GetCursorPos(pt)
    Call GetCellRect(levelNum, target, rc)
    
    If CCurveDates.ParamEntity.IsFlag(CURVE_FLG_PIVOT) Then
        cvrName = target.value
    Else
        col = target.column - m_curveRgn.column + 1
        cvrName = m_curveRgn.Cells(1, col).value
    End If

    rcLeft = rc.left
    rcBottom = rc.bottom
    
    'Call CDDXCurve.RaiseCurveEvent(DDX_PID, CURVE_EVENT_CURVE_SELECTED, crvname, rc.left, rc.bottom)
    OnDoubleClick = IIf(levelNum = CURVE_VR_L_OBSERVATION, True, False)
End Function

Private Function Need2CalculateChangableDate(ByVal fvs As Long, ByVal forSave As Boolean) As Boolean
    If Not forSave Then
        If Application.Calculation <> xlCalculationManual Then Exit Function
    End If
    
    If Not CDDXHelper.IsFlag(fvs, CURVE_FLG_EDIT_DATES) Then Exit Function
    If CDDXHelper.IsFlag(fvs, CURVE_FLG_MRBD) Then Exit Function
    If CDDXHelper.IsFlag(fvs, CURVE_FLG_TIMESERIES) Then Exit Function
    If CDDXHelper.IsFlag(fvs, CURVE_FLG_FUTURE_RANGE) Then Exit Function
    'Not CDDXHelper.IsFlag(fvs, CURVE_FLG_MULTIOBS) Then
    
    Need2CalculateChangableDate = True
End Function

Public Function OnSheetChange(target As range) As Boolean
 Dim s As String
 Dim tc As range
 Dim fv As Long
 Dim r As Long
 Dim c As Long
 Dim PROTECTED As Long
 
    If target Is Nothing Then Exit Function
    If target.Parent.Parent.IsAddin Then Exit Function
    
    fv = CDDXCurve.GetFVS(target.Parent)
    If fv <= 0 Then Exit Function
    
    OnSheetChange = True
    PROTECTED = &H0
    
    For Each tc In target.Cells
        If iserror(tc) Then
            Call SetCellColor(tc, CURVE_CHANGE_CLR_IDX, vbNullString, vbNullString, PROTECTED)
        Else
            If CDDXHelper.IsFlag(fv, CURVE_FLG_MULTIOBS) And (tc.column >= 2 And tc.column <= IIf(CDDXHelper.IsFlag(fv, CURVE_FLG_TIMESERIES), 2, 3)) Then
                Call SetCellColor(tc, _
                                  CURVE_CHANGE_CLR_IDX, _
                                  IIf(Not CDDXHelper.IsFlag(fv, CURVE_FLG_TIMESERIES) And tc.column = 2, CStr(tc.Value2), vbNullString), _
                                  IIf((CDDXHelper.IsFlag(fv, CURVE_FLG_TIMESERIES) And tc.column = 2) Or (Not CDDXHelper.IsFlag(fv, CURVE_FLG_TIMESERIES) And tc.column = 3), CStr(tc.Value2), vbNullString), _
                                  PROTECTED)
            Else
                s = Trim(tc.Value2)
                If s <> vbNullString Then
                    Call SetCellColor(tc, IIf(IsNumeric(s), CURVE_CHANGE_CLR_IDX, CURVE_ERROR_CLR_IDX), vbNullString, vbNullString, PROTECTED)
                End If
            End If
        End If
    Next
    
    If Need2CalculateChangableDate(fv, False) Then
        If (target.column = 1 And target.row = 3) Or (target.column = 2 And target.row = 2) Then
            If GetSplits(target.Parent, Nothing, r, c) Then
                If Application.EnableEvents Then
                    PROTECTED = PROTECTED Or &H4
                    Application.EnableEvents = False
                End If
                    
                If (target.column = 2 And target.row = 2) Then
                    Call CCurveDates.Handler.CalculateDates(CCurveDates.ParamEntity)
                Else
                    With target.Parent.rows(r - IIf(CDDXHelper.IsFlag(fv, CURVE_FLG_MULTIOBS), 1, 0))
                        .Calculate
                    End With
                End If
                
                If CDDXHelper.IsFlag(PROTECTED, &H4) Then
                    Application.EnableEvents = True
                End If
            End If
        End If
    End If
    
    If CDDXHelper.IsFlag(PROTECTED, &H2) Then
        Call Protect(target.Parent)
    End If
End Function

Public Property Get PreserveFormulas() As Boolean
    PreserveFormulas = IIf(Dir(InputFileName(CSheet.ZESheetID(ActiveSheet))) = vbNullString, False, True)
    If Not PreserveFormulas Then
        PreserveFormulas = IIf(Dir(InputFileNameContracts(CSheet.ZESheetID(ActiveSheet))) = vbNullString, False, True)
    End If
End Property

Private Function FormRgn(ByVal row As Long, ByVal col As Long, ByVal rowcnt As Long, ByVal colcnt As Long) As range
    Set FormRgn = ActiveSheet.Cells(row, col).Resize(rowcnt, colcnt)
End Function

Private Sub Rearrange(dtaRgn As range, oldCurveParams As CCurveParams, newCurveParams As CCurveParams)
 Dim k As Long
 Dim j As Long
 Dim newcvs() As String
 Dim oldcvs() As String
 Dim cvs() As String
 Dim nameIndex As Collection
 Dim wid As Long
 Dim nm As String
 Dim row As Long
 Dim col As Long
 Dim rowcnt As Long
 Dim colcnt As Long
 
    newcvs = newCurveParams.curves
    oldcvs = oldCurveParams.curves
    
    If UBound(oldcvs) = UBound(newcvs) Then
        For k = LBound(oldcvs) To UBound(oldcvs)
            If StrComp(oldcvs(k), newcvs(k), vbBinaryCompare) <> 0 Then Exit For
        Next
        If k > UBound(oldcvs) Then Exit Sub
    End If
    
    Set nameIndex = New Collection
    
    For k = LBound(oldcvs) To UBound(oldcvs)
        Call nameIndex.Add(oldcvs(k))
    Next
    
    wid = IIf(oldCurveParams.IsFlag(CURVE_FLG_MRBD), 2, 1)
    
    With dtaRgn
        row = .row
        col = .column
        rowcnt = .rows.count
        colcnt = wid * (UBound(newcvs) - LBound(newcvs) + 1)
    End With
    
'delete curves
    For j = nameIndex.count To 1 Step -1
        For k = LBound(newcvs) To UBound(newcvs)
            If StrComp(CStr(nameIndex.item(j)), newcvs(k), vbBinaryCompare) = 0 Then Exit For
        Next

        If k > UBound(newcvs) Then
            Call nameIndex.Remove(j)
            Call FormRgn(row, col, rowcnt, colcnt).offset(, (j - 1) * wid).Resize(, wid).Columns.Delete(shift:=xlToLeft)
        End If
    Next
        
'insert curves
    For k = LBound(newcvs) To UBound(newcvs)
        For j = nameIndex.count To 1 Step -1
            If StrComp(CStr(nameIndex.item(j)), newcvs(k), vbBinaryCompare) = 0 Then Exit For
        Next

        If j < 1 Then
'            Call nameindex.Add(newcvs(k))
'            Set src = FormRgn(row, col, rowcnt, colcnt).offset(, colcnt).Resize(, wid)
'            Call src.Columns.Insert(shift:=xlToRight)
            Call FormRgn(row, col, rowcnt, colcnt).offset(, nameIndex.count * wid).Resize(, wid).Columns.Insert(shift:=xlToRight, CopyOrigin:=xlFormatFromRightOrBelow)
            Call nameIndex.Add(newcvs(k))
        End If
    Next

'swap curves
    ReDim cvs(LBound(newcvs) To UBound(newcvs))
    
    For k = LBound(cvs) To UBound(cvs)
        cvs(k) = CStr(nameIndex.item(k + 1))
    Next
    
    For k = LBound(newcvs) To UBound(newcvs)
        For j = k To UBound(cvs)
            If StrComp(newcvs(k), cvs(j), vbBinaryCompare) = 0 Then Exit For
        Next
        
        If k <> j Then
            FormRgn(row, col, rowcnt, colcnt).offset(, k * wid).Resize(, wid).Select
            FormRgn(row, col, rowcnt, colcnt).offset(, k * wid).Resize(, wid).Cut
            FormRgn(row, col, rowcnt, colcnt).offset(, colcnt).Resize(, wid).Select
            FormRgn(row, col, rowcnt, colcnt).offset(, colcnt).Resize(, wid).Parent.Paste
            
            FormRgn(row, col, rowcnt, colcnt).offset(, j * wid).Resize(, wid).Select
            FormRgn(row, col, rowcnt, colcnt).offset(, j * wid).Resize(, wid).Cut
            FormRgn(row, col, rowcnt, colcnt).offset(, k * wid).Resize(, wid).Select
            FormRgn(row, col, rowcnt, colcnt).offset(, k * wid).Resize(, wid).Parent.Paste
            
            FormRgn(row, col, rowcnt, colcnt).offset(, colcnt).Resize(, wid).Select
            FormRgn(row, col, rowcnt, colcnt).offset(, colcnt).Resize(, wid).Cut
            FormRgn(row, col, rowcnt, colcnt).offset(, j * wid).Resize(, wid).Select
            FormRgn(row, col, rowcnt, colcnt).offset(, j * wid).Resize(, wid).Parent.Paste
            
            FormRgn(row, col, rowcnt, colcnt).offset(, colcnt).Resize(, wid).Clear
            
            nm = cvs(k)
            cvs(k) = cvs(j)
            cvs(j) = nm
        End If
    Next
End Sub

Private Sub RearrangeRange(dtaRgn As range, oldCurveParams As CCurveParams, newCurveParams As CCurveParams)
 Dim k As Long
 Dim j As Long
 Dim newdtes() As String
 Dim olddtes() As String
 Dim cvs() As String
 Dim dtedictionary As Collection
 Dim filnum As Long
 Dim buff As String
 Dim row As Long
 Dim col As Long
 Dim rowcnt As Long
 Dim colcnt As Long
 
    filnum = FreeFile
    Open CurveFilePath For Input As filnum
    Line Input #filnum, buff
    Close #filnum
    
    col = 1
    For k = 1 To 3
        col = InStr(col, buff, vbTab)
        col = col + 1
    Next
    buff = Mid(buff, col)
    newdtes = Split(buff, vbTab)
    
    ReDim olddtes(0 To dtaRgn.Columns.count - 1)
    For k = LBound(olddtes) To UBound(olddtes)
        olddtes(k) = CStr(dtaRgn.Cells(1, k + 1).Value2)
    Next
    
    If UBound(olddtes) = UBound(newdtes) Then
        For k = LBound(olddtes) To UBound(olddtes)
            If StrComp(olddtes(k), newdtes(k), vbBinaryCompare) <> 0 Then Exit For
        Next
        If k > UBound(olddtes) Then Exit Sub
    End If

'
    Set dtedictionary = New Collection
    For k = LBound(olddtes) To UBound(olddtes)
        Call dtedictionary.Add(olddtes(k))
    Next

    With dtaRgn
        row = .row
        col = .column
        rowcnt = .rows.count
        colcnt = (UBound(newdtes) - LBound(newdtes) + 1)
    End With
    
'delete dates
    For j = dtedictionary.count To 1 Step -1
        For k = LBound(newdtes) To UBound(newdtes)
            If StrComp(CStr(dtedictionary.item(j)), newdtes(k), vbBinaryCompare) = 0 Then Exit For
        Next

        If k > UBound(newdtes) Then
            Call dtedictionary.Remove(j)
            Call FormRgn(row, col, rowcnt, colcnt).offset(, (j - 1)).Resize(, 1).Columns.Delete(shift:=xlToLeft)
        End If
    Next
        
'insert dates
    For k = LBound(newdtes) To UBound(newdtes)
        For j = dtedictionary.count To 1 Step -1
            If StrComp(CStr(dtedictionary.item(j)), newdtes(k), vbBinaryCompare) = 0 Then Exit For
        Next

        If j < 1 Then
            Call FormRgn(row, col, rowcnt, colcnt).offset(, dtedictionary.count).Resize(, 1).Columns.Insert(shift:=xlToRight)
            Call dtedictionary.Add(newdtes(k))
        End If
    Next

'swap dates
    ReDim dtes(LBound(newdtes) To UBound(newdtes))
    
    For k = LBound(dtes) To UBound(dtes)
        dtes(k) = CStr(dtedictionary.item(k + 1))
    Next
    
    For k = LBound(newdtes) To UBound(newdtes)
        For j = k To UBound(dtes)
            If StrComp(newdtes(k), dtes(j), vbBinaryCompare) = 0 Then Exit For
        Next
        
        If k <> j Then
            FormRgn(row, col, rowcnt, colcnt).offset(, k).Resize(, 1).Select
            FormRgn(row, col, rowcnt, colcnt).offset(, k).Resize(, 1).Cut
            FormRgn(row, col, rowcnt, colcnt).offset(, colcnt).Resize(, 1).Select
            FormRgn(row, col, rowcnt, colcnt).offset(, colcnt).Resize(, 1).Parent.Paste
            
            FormRgn(row, col, rowcnt, colcnt).offset(, j).Resize(, 1).Select
            FormRgn(row, col, rowcnt, colcnt).offset(, j).Resize(, 1).Cut
            FormRgn(row, col, rowcnt, colcnt).offset(, k).Resize(, 1).Select
            FormRgn(row, col, rowcnt, colcnt).offset(, k).Resize(, 1).Parent.Paste
            
            FormRgn(row, col, rowcnt, colcnt).offset(, colcnt).Resize(, 1).Select
            FormRgn(row, col, rowcnt, colcnt).offset(, colcnt).Resize(, 1).Cut
            FormRgn(row, col, rowcnt, colcnt).offset(, j).Resize(, 1).Select
            FormRgn(row, col, rowcnt, colcnt).offset(, j).Resize(, 1).Parent.Paste
            
            FormRgn(row, col, rowcnt, colcnt).offset(, colcnt).Resize(, 1).Clear
            
            buff = dtes(k)
            dtes(k) = dtes(j)
            dtes(j) = buff
        End If
    Next
End Sub

Private Sub RearrangeTRANS(dtaRgn As range, oldCurveParams As CCurveParams, newCurveParams As CCurveParams)
 Dim k As Long
 Dim j As Long
 Dim newcvs() As String
 Dim oldcvs() As String
 Dim row As Long
 Dim colcnt As Long
 Dim start As Long
 
    oldcvs = oldCurveParams.curves
    newcvs = newCurveParams.curves
     
    If UBound(oldcvs) = UBound(newcvs) Then
        For k = LBound(oldcvs) To UBound(oldcvs)
            If StrComp(oldcvs(k), newcvs(k), vbBinaryCompare) <> 0 Then Exit For
        Next
        If k > UBound(oldcvs) Then Exit Sub
    End If

    With dtaRgn
        row = .row
        colcnt = .Columns.count
    End With

    start = dtaRgn.row + dtaRgn.rows.count
    
    For k = LBound(newcvs) To UBound(newcvs)
        For j = LBound(oldcvs) To UBound(oldcvs)
            If StrComp(newcvs(k), oldcvs(j), vbBinaryCompare) = 0 Then Exit For
        Next
        
        If j <= UBound(oldcvs) Then
            FormRgn(row + j, 1, 1, colcnt).Select
            FormRgn(row + j, 1, 1, colcnt).Cut
            FormRgn(start + k, 1, 1, colcnt).Select
            FormRgn(start + k, 1, 1, colcnt).Parent.Paste
        End If
    Next

    FormRgn(start, 1, UBound(newcvs) - LBound(newcvs) + 1, colcnt).Select
    FormRgn(start, 1, UBound(newcvs) - LBound(newcvs) + 1, colcnt).Cut
    FormRgn(row, 1, UBound(newcvs) - LBound(newcvs) + 1, colcnt).Select
    FormRgn(row, 1, UBound(newcvs) - LBound(newcvs) + 1, colcnt).Parent.Paste
    
    FormRgn(row, 1, 1, 1).Select
End Sub

Public Sub ResetSheetButFormulas(sht As Worksheet)
    On Error GoTo OOPS
    Call sht.Cells.SpecialCells(xlCellTypeConstants, 23).Clear
    
OOPS:
    Exit Sub
End Sub

Private Sub ResetSheet(newParams As CCurveParams)
 Dim s As Variant

    On Error GoTo OOPS
    
    With ActiveSheet
        .Cells.ClearComments
        
        For Each s In .Shapes
            If s.Type <> msoFormControl Then
                s.Delete
            End If
        Next
        
        If Not PreserveFormulas Then
            If Not newParams.IsFlag(CURVE_FLG_EDIT_DATES) Or newParams.IsFlag(CURVE_FLG_TIMESERIES) Then
                Call .Cells.Clear
            Else
                Call ResetSheetButFormulas(ActiveSheet)
            End If
        End If
    End With
    
OOPS:
    If Err.Number <> 0 Then
        CDDXApp.StatusMessage = Err.Description
    End If
    Exit Sub
End Sub

Public Sub AdjustPropNDataAreas(newParams As CCurveParams, ByVal fixedRowCount As Long)
 Dim params As New CCurveParams
 Dim props As Long
 Dim oldprops As Long
 Dim k As Long
 Dim start As Long
 Dim sRow As Long
 Dim sCol As Long
 Dim rgn As range
 
    Call ResetSheet(newParams)
    
    With params
        Call .FromXML(GetCurveProperties(ActiveSheet))
        
        Call GetSplits(ActiveSheet, params, sRow, sCol)
        oldprops = .PropertyCount
    End With
    
    If Not newParams.IsFlag(CURVE_FLG_FUTURE_RANGE) Then
        With ActiveSheet
            props = newParams.PropertyCount
            start = fixedRowCount + 1 'm_HeaderRgn.rows.count - 1
            
            If props > oldprops Then
                For k = 1 To props - oldprops
                    .rows(start).Insert
                Next
            ElseIf props < oldprops Then
                For k = 1 To oldprops - props
                    .rows(start).Delete
                Next
            End If
            
            If props <> oldprops Then
                sRow = sRow + (props - oldprops)
                Call SetSplits(ActiveSheet, sRow, sCol)
            End If
        End With
    End If

    If newParams.rowCount >= 2 Then
        If Not newParams.IsFlag(CURVE_FLG_FUTURE_RANGE) Then
            Call Rearrange(ActiveSheet.Cells(sRow - IIf(params.IsFlag(CURVE_FLG_MULTIOBS), 1, 0), sCol + 1).Resize(IIf(params.IsFlag(CURVE_FLG_MULTIOBS), 1, 0) + params.rowCount, params.ColumnCount - 1), params, newParams)
        Else
            Call RearrangeRange(ActiveSheet.Cells(sRow - IIf(params.IsFlag(CURVE_FLG_MULTIOBS), 1, 0), sCol + 1).Resize(IIf(params.IsFlag(CURVE_FLG_MULTIOBS), 1, 0) + params.rowCount, params.ColumnCount - 1), params, newParams)
        End If
    End If
    
    If newParams.ColumnCount < params.ColumnCount Then
        Set rgn = ActiveSheet.Cells(1, sCol + newParams.ColumnCount).Resize(sRow + 2, params.ColumnCount - newParams.ColumnCount)
        rgn.Clear
        
        For k = 1 To params.ColumnCount - newParams.ColumnCount
            ActiveSheet.Columns(sCol + newParams.ColumnCount - 1 + k).Clear
        Next
    End If
    
    If params.IsFlag(CURVE_FLG_MULTIOBS) Then
        Set rgn = ActiveSheet.Cells(1, 1).Resize(sRow, sCol)
        Call RemoveValidations(rgn)
    End If
    
    Set params = Nothing
End Sub

Private Sub RemoveValidations(rgn As range)
 Dim tmp As range
 
    On Error GoTo OOPS
    
    Set tmp = rgn.SpecialCells(xlCellTypeAllValidation)
    If Not tmp Is Nothing Then
        tmp.Validation.Delete
    End If
        
OOPS:
    On Error GoTo 0
    Exit Sub
End Sub

Public Sub AdjustPropNDataAreasTRANS(oldParams As CCurveParams, newParams As CCurveParams)
 Dim props As Long
 Dim oldprops As Long
 Dim k As Long
 Dim start As Long
 Dim sRow As Long
 Dim sCol As Long
 Dim rgn As range
 
    Call ResetSheet(newParams)
    
    Call GetSplits(ActiveSheet, oldParams, sRow, sCol)
    
    props = newParams.PropertyCount
    oldprops = oldParams.PropertyCount
    
    With ActiveSheet
        start = 5 + 1 + 1
        If props > oldprops Then
            For k = 1 To props - oldprops
                .Columns(start).Insert
            Next
        ElseIf props < oldprops Then
            For k = 1 To oldprops - props
                .Columns(start).Delete
            Next
        End If
        
        If props <> oldprops Then
            sCol = sCol + (props - oldprops)
'            If CDDXCurve.GetSheetVersion(CCurveDates.ParamEntity.flagValues) <= CDDXCurve.GetSheetVersion(CURVE_FLG_V1) Then
'                Call SetSplits(ActiveSheet, sRow, sCol)
'            End If
        End If
    End With
    
    If newParams.rowCount >= 2 Then
        'Call RearrangeTRANS(ActiveSheet.Cells(sRow + 1, sCol + 1).Resize(oldParams.ColumnCount - 1, 1 + newParams.PropertyCount + IIf(newParams.IsFlag(CURVE_FLG_TIMESERIES), 0, 1) + oldParams.rowCount - 1), oldParams, newParams)
        Call RearrangeTRANS(ActiveSheet.Cells(sRow + 1, 1).Resize(oldParams.ColumnCount - 1, 6 + newParams.PropertyCount + IIf(newParams.IsFlag(CURVE_FLG_TIMESERIES), 0, 1) + oldParams.rowCount), oldParams, newParams)
    End If
    
    If newParams.ColumnCount < oldParams.ColumnCount Then
        Set rgn = ActiveSheet.Cells(sRow + newParams.rowCount, 1).Resize(oldParams.ColumnCount - newParams.ColumnCount, 5)
        rgn.Clear
        
        For k = 1 To oldParams.ColumnCount - newParams.ColumnCount
            ActiveSheet.rows(sRow + newParams.ColumnCount - 1 + k).Clear
        Next
    End If
End Sub

'Public Function GetSplits(sht As Worksheet, params As CCurveParams, ByRef splitrows As Long, ByRef splitcols As Long) As Boolean
'    GetSplits = True
'
'    If GetCPSplits(params, sht, splitrows, splitcols) Then Exit Function
'
'    If splitcols <> 0 Or splitrows <> 0 Then
'        Exit Function
'    End If
'
'    If params Is Nothing Then
'        GetSplits = False
'        Exit Function
'    End If
'
'    With params
'        If params.IsFlag(CURVE_FLG_PIVOT) Then
'            splitcols = 5
'            splitrows = 6
'
'        Else
'            If params.IsFlag(CURVE_FLG_MULTIOBS) Then
'                splitcols = IIf(params.IsFlag(CURVE_FLG_TIMESERIES), 2, 3)
'            Else
'                splitcols = 2
'            End If
'
'            splitrows = .PropertyCount
'
'            If params.IsFlag(CURVE_FLG_MULTIOBS) Then
'                If params.IsFlag(CURVE_FLG_TIMESERIES) Then
'                    splitrows = splitrows + 8
'                Else
'                    splitrows = splitrows + IIf(params.IsFlag(CURVE_FLG_FUTURE_RANGE), 6, 8)
'                End If
'            Else
'                If params.IsFlag(CURVE_FLG_TIMESERIES) Then
'                    splitrows = splitrows + 7
'                Else
'                    If params.IsFlag(CURVE_FLG_FUTURE_RANGE) Then
'                        splitrows = splitrows + 5
'                    Else
'                        splitrows = splitrows + IIf(params.IsFlag(CURVE_FLG_MRBD), 6, 7)
'                    End If
'                End If
'            End If
'        End If
'    End With
'End Function

Public Function GetSplits(sht As Worksheet, params As CCurveParams, ByRef splitrows As Long, ByRef splitcols As Long) As Boolean
    GetSplits = True
    
    With GetWnd(sht)
        splitcols = .SplitColumn
        splitrows = .splitrow
        
        'for compatibility
        If splitcols = 1 Then
            If Not params Is Nothing Then
                If Not params.IsFlag(CURVE_FLG_PIVOT) Then
                    If sht.Columns(2).EntireColumn.Hidden = True Then
                        splitcols = 2
                    End If
                End If
            End If
        End If
        
        If .Split Then Exit Function
        
        If splitcols <> 0 Or splitrows <> 0 Then
            If params.IsFlag(CURVE_FLG_PIVOT) Then
                splitcols = FXIED_COLUMNS_TRANSPOSED
            End If
            Exit Function
        End If
    End With
    
    If params Is Nothing Then
        GetSplits = False
        Exit Function
    End If
    
    With params
        If params.IsFlag(CURVE_FLG_PIVOT) Then
            splitcols = FXIED_COLUMNS_TRANSPOSED
            splitrows = 6
            
        Else
            If params.IsFlag(CURVE_FLG_MULTIOBS) Then
                splitcols = IIf(params.IsFlag(CURVE_FLG_TIMESERIES), 2, 3)
            Else
                splitcols = 2
            End If
            
            splitrows = .PropertyCount
            
            If params.IsFlag(CURVE_FLG_MULTIOBS) Then
                If params.IsFlag(CURVE_FLG_TIMESERIES) Then
                    splitrows = splitrows + 8
                Else
                    splitrows = splitrows + IIf(params.IsFlag(CURVE_FLG_FUTURE_RANGE), 6, 8)
                End If
            Else
                If params.IsFlag(CURVE_FLG_TIMESERIES) Then
                    splitrows = splitrows + 7
                Else
                    If params.IsFlag(CURVE_FLG_FUTURE_RANGE) Then
                        splitrows = splitrows + 5
                    Else
                        splitrows = splitrows + IIf(params.IsFlag(CURVE_FLG_MRBD), 6, 7)
                    End If
                End If
            End If
        End If
    End With
End Function

Public Sub SetSplits(sht As Worksheet, ByVal splitrows As Long, ByVal splitcols As Long)
    Call StoreCPSplits(sht, splitrows, splitcols)
    
    With GetWnd(sht)
        .SplitColumn = splitcols
        .splitrow = splitrows
        .FreezePanes = True
        .DisplayGridlines = False
    End With
End Sub

Private Function GetWnd(sheet As Worksheet) As Window
 Dim win As Window
 Dim sht As Variant
 Dim k As Integer
    
    For Each win In sheet.Parent.Windows
        For k = 1 To win.SheetViews.count
            If LCase(TypeName(win.SheetViews.item(k).sheet)) = "worksheet" Then
                If win.SheetViews.item(k).sheet.name = sheet.name Then
                    Set GetWnd = win
                    Exit Function
                End If
            End If
        Next
    Next
End Function

Public Function GetCurveRange(ByVal sht As Worksheet) As range
 Dim srows As Long
 Dim scols As Long
 
    Call GetSplits(sht, CCurveDates.ParamEntity, srows, scols)
    
    With CCurveDates.ParamEntity
        Call .FromXML(GetCurveProperties(sht))

        If .IsFlag(CURVE_FLG_PIVOT) Then
            scols = scols + CCurveDates.ParamEntity.PropertyCount + IIf(.IsFlag(CURVE_FLG_TIMESERIES), 0, 1)
            Set GetCurveRange = sht.Cells(srows, 1).Resize(.ColumnCount, scols + .rowCount - 1)
        Else
            Set GetCurveRange = sht.Cells(srows - IIf(.IsFlag(CURVE_FLG_MULTIOBS), 1, 0), 1).Resize(.rowCount + IIf(.IsFlag(CURVE_FLG_MULTIOBS), 1, 0), _
                                                                                                    .ColumnCount + IIf(.IsFlag(CURVE_FLG_MULTIOBS) And Not .IsFlag(CURVE_FLG_TIMESERIES), 2, 1))
        End If
    End With
End Function

Public Sub ResetRangeColor(params As CCurveParams, datargn As range, ByVal cuvreIndex As Long)
 Dim cols As Long
 Dim rgn As range
 Dim splitrows As Long
 Dim splitcols As Long
 
    If datargn Is Nothing Then Exit Sub
 
    On Local Error GoTo OOPS
    
    If cuvreIndex < 0 Then
        Set rgn = datargn
    Else
        If params.IsFlag(CURVE_FLG_FUTURE_RANGE) Then
            Set rgn = datargn
        Else
            Call GetSplits(datargn.Parent, params, splitrows, splitcols)
            If params.IsFlag(CURVE_FLG_PIVOT) Then
                Set rgn = datargn.offset(cuvreIndex + 1, splitcols).Resize(1, datargn.Columns.count - splitcols)
            Else
                cols = IIf(params.IsFlag(CURVE_FLG_MRBD), 2, 1)
                Set rgn = datargn.offset(, splitcols + cols * cuvreIndex).Resize(, cols)
            End If
        End If
    End If
 
    rgn.Characters.Font.ColorIndex = xlColorIndexAutomatic 'CURVE_DATA_CLR_IDX
    
OOPS:
    If Err.Number <> 0 Then
        If Err.Number <> 0 Then Call CDDXHelper.LogError(Err.Description, "ResetRangeColor")
    End If
    
    On Local Error GoTo 0
    
    Exit Sub
End Sub

Public Function RefreshOprRange(params As CCurveParams, sht As Worksheet) As Boolean
 Dim dtes() As Double
 Dim min As Double
 Dim max As Double
 Dim k As Long
 Dim v As Double
 
    On Local Error GoTo OOPS
    
    With params
        min = CDbl(.OprStartDate)
        max = CDbl(.OprEndDate)
    End With
    
    dtes = CCurveDates.ContractDateList
    For k = LBound(dtes) To UBound(dtes)
        v = Int(dtes(k))
        If v < min Then
            min = v
        ElseIf v > max Then
            max = v
        End If
    Next
    
    With params
        If min <> CDbl(.OprStartDate) Or max <> CDbl(.OprEndDate) Then
            .OprStartDate = CDate(min)
            .OprEndDate = CDate(max)
            Call SaveCurveProperties(sht, params)
            RefreshOprRange = True
        End If
    End With
    
OOPS:
    If Err.Number <> 0 Then
    
    End If
    Exit Function
End Function

Public Function OnPlusMinusAction(actionID As Integer) As String
    OnPlusMinusAction = MacroActionStr("MacroContractPlusMinus", actionID, CDDXHelper.NewGUID())
End Function

Public Sub DrawStyledTexts(sht As Worksheet, rn As Long, cn As Long, text1 As String, text2 As String, ParamArray italicTexts() As Variant)
 Dim k As Integer
 Dim txt As String
 
    For k = LBound(italicTexts) To UBound(italicTexts)
        txt = txt + italicTexts(k)
    Next
    text1 = LTrim(text1)
    txt = RTrim(txt)
    
    With sht.Cells(rn, cn)
        .IndentLevel = 1
        .HorizontalAlignment = xlLeft
        .value = text1 + text2 + txt
        With .Characters(1).Font
            .size = 9
        End With
        With .Characters(Len(text1) + 1).Font
            .Bold = True
            .size = 8
        End With
        
        If Len(txt) > 0 Then
            With .Characters(Len(text1) + Len(text2) + 1).Font
                .Italic = True
            End With
        End If
    End With
End Sub

Public Function ClearFlags()
    m_flag_start = &H0
    m_sheetid = vbNullString
End Function

Public Property Get IsReady() As Boolean
    IsReady = IIf(m_flag_start = &H0 Or (m_flag_start And STARTF_NOTIFY_UI) > 0, True, False)
End Property

Private Function SetTask(ByVal sheetId As String, tskName As String, curveName As String)
    m_flag_start = m_flag_start Or STARTF_AFTER_CALL_WS
    
    m_sheetid = sheetId
    Call CTimer.StartMonitor(sheetId, vbNullString)
    
    Application.OnTime Now, "'MacroCurveProc """ + EncodeMacroParam(m_sheetid) + """,""" + EncodeMacroParam(tskName) + """,""" + EncodeMacroParam(curveName) + """'"
End Function

Public Sub OnCurveData(ByVal tid As String, ByVal flags As Long, ByVal tag As String)
 Dim result As ZEWSProxy.CurveResult
 
    On Error GoTo OOPS

    Application.EnableCancelKey = xlDisabled
    
    If (m_flag_start And STARTF_NOTIFY_UI) = &H0 Then Exit Sub
    If StrComp(tid, m_sheetid) <> 0 Then Exit Sub
    m_flag_start = m_flag_start And (Not STARTF_NOTIFY_UI)
    
    With CDDXLib.DefaultZEWSProxy(DDX_PID)
        Set result = .RetrieveCurveResponse(m_sheetid)
        If Not result Is Nothing Then
            Call CCurveControl.OnCompleted(result)
        Else
            Call HideProgressBox
        End If
    End With
    
OOPS:
    If Err.Number <> 0 Then
        Call CDDXHelper.LogError(Err.Description, "OnCurveData", False)
    End If
    
    On Error GoTo 0
    Exit Sub
End Sub

Public Function IsEmptyDates(dtes() As Double) As Boolean
    On Error GoTo OOPS
    
    If UBound(dtes) < 0 Then IsEmptyDates = True
    
OOPS:
    If Err.Number <> 0 Then
        IsEmptyDates = True
    End If
    Exit Function
End Function

Public Sub DeleteInputFile(sht As Worksheet)
 Dim fn As String
 
    fn = InputFileName(CSheet.ZESheetID(sht))
    Call CDDXHelper.DeleteFile(fn)
    Call CDDXHelper.DeleteFile(InputFileNameContracts(CSheet.ZESheetID(sht)))
End Sub

Public Function HoriWidthTRANS(params As CCurveParams) As Long
    HoriWidthTRANS = params.PropertyCount + IIf(params.IsFlag(CURVE_FLG_TIMESERIES), 0, 1)
End Function

Private Function GetAreas(ByVal curveIndex As Long, Optional ByVal allAreas As Boolean = True) As Boolean
 Dim srows As Long
 Dim scols As Long
 Dim sht As Worksheet
 Dim r As Long
 Dim c As Long
 Dim rs As Long
 Dim cs As Long
 
    Set m_curveRgn = Nothing
    Set m_oprRgn = Nothing
    Set m_contractRgn = Nothing
    Set m_dataRgn = Nothing
    
    If allAreas Then
        With CCurveDates.ParamEntity
            If .rowCount <= 1 Or .ColumnCount <= 1 Then Exit Function
        End With
    End If
    
    Set sht = CCurveDates.TargetSheet
    Call GetSplits(sht, CCurveDates.ParamEntity, srows, scols)
    
    With CCurveDates.ParamEntity
        If .IsFlag(CURVE_FLG_PIVOT) Then
            r = srows + 1 + IIf(curveIndex < 0, 0, curveIndex)
            c = scols + HoriWidthTRANS(CCurveDates.ParamEntity)
            rs = IIf(curveIndex < 0, .ColumnCount - 1, 1)
            cs = .rowCount - 1
            
            Set m_curveRgn = sht.Cells(r, scols + 1).Resize(rs, 1)
            If Not .IsFlag(CURVE_FLG_TIMESERIES) Then
                Set m_oprRgn = sht.Cells(r, c).Resize(rs, 1)
            End If
                
            If allAreas Then
                Set m_contractRgn = sht.Cells(srows, c + 1).Resize(1, cs)
                Set m_dataRgn = sht.Cells(r, c + 1).Resize(rs, cs)
            End If
        Else
            If .IsFlag(CURVE_FLG_FUTURE_RANGE) Then
                If .IsFlag(CURVE_FLG_MULTIOBS) Then
                    Set m_curveRgn = sht.Cells(1, 2)
                    Set m_oprRgn = sht.Cells(srows - 1, scols + 1).Resize(1, .ColumnCount - 1)
                    
                    If allAreas Then
                        Set m_contractRgn = sht.Cells(srows + 1, 1).Resize(.rowCount - 1)
                        Set m_dataRgn = sht.Cells(srows + 1, scols + 1).Resize(.rowCount - 1, .ColumnCount - 1)
                    End If
                Else
                    Set m_curveRgn = sht.Cells(1, 2)
                    Set m_oprRgn = sht.Cells(srows, scols + 1).Resize(1, .ColumnCount - 1)
                    
                    If allAreas Then
                        Set m_contractRgn = sht.Cells(srows + 1, 1).Resize(.rowCount - 1)
                        Set m_dataRgn = sht.Cells(srows + 1, scols + 1).Resize(.rowCount - 1, .ColumnCount - 1)
                    End If
                End If
                
            ElseIf .IsFlag(CURVE_FLG_MULTIOBS) Then
                If .IsFlag(CURVE_FLG_TIMESERIES) Then
                    c = scols + 1 + IIf(curveIndex < 0, 0, curveIndex)
                    cs = IIf(curveIndex < 0, .ColumnCount - 1, 1)
                
                    Set m_curveRgn = sht.Cells(srows - 2 - CCurveDates.ParamEntity.PropertyCount, c).Resize(1, cs)
                    
                    If allAreas Then
                        Set m_contractRgn = sht.Cells(srows + 1, 1).Resize(.rowCount - 1, 1)
                        Set m_dataRgn = sht.Cells(srows + 1, c).Resize(.rowCount - 1, cs)
                    End If
                Else
                    c = scols + 1 + IIf(curveIndex < 0, 0, curveIndex)
                    cs = IIf(curveIndex < 0, .ColumnCount - 1, 1)
                
                    Set m_curveRgn = sht.Cells(srows - 2 - CCurveDates.ParamEntity.PropertyCount, c).Resize(1, cs)
                    Set m_oprRgn = sht.Cells(srows - 1, c).Resize(1, cs)
                    
                    If allAreas Then
                        Set m_contractRgn = sht.Cells(srows + 1, 1).Resize(.rowCount - 1, 1)
                        Set m_dataRgn = sht.Cells(srows + 1, c).Resize(.rowCount - 1, cs)
                    End If
                End If
            Else
                c = scols + 1 + IIf(curveIndex < 0, 0, curveIndex) * IIf(.IsFlag(CURVE_FLG_MRBD), 2, 1)
                cs = IIf(curveIndex < 0, .ColumnCount - 1, IIf(.IsFlag(CURVE_FLG_MRBD), 2, 1))
            
                Set m_curveRgn = sht.Cells(srows - 1 - CCurveDates.ParamEntity.PropertyCount, c).Resize(1, cs)
                If Not .IsFlag(CURVE_FLG_TIMESERIES) Then
                    Set m_oprRgn = sht.Cells(srows, c).Resize(1, cs)
                End If
                    
                If allAreas Then
                    Set m_contractRgn = sht.Cells(srows + 1, 1).Resize(.rowCount - 1, 1)
                    Set m_dataRgn = sht.Cells(srows + 1, c).Resize(.rowCount - 1, cs)
                End If
            End If
        End If
    End With
    
    GetAreas = True
End Function

Private Sub PersistInputs()
    If Not GetAreas(-1) Then Exit Sub
    
    Call SaveInputFileContracts(CCurveDates.ParamEntity, m_contractRgn)
    Call SaveInputFile(CCurveDates.ParamEntity, m_curveRgn, m_contractRgn, m_dataRgn)
End Sub

Public Sub PopulateInputs()
    If Not GetAreas(-1) Then Exit Sub
    
    Call PopulateInputFileContracts(CCurveDates.ParamEntity, m_contractRgn)
    Call PopulateInputFile(CCurveDates.ParamEntity)
End Sub

Private Function SaveInputFile(params As CCurveParams, curveRgn As range, contractRgn As range, datargn As range) As Long
 Dim fn As String
 Dim num As Integer
 Dim count As Long
 
    On Local Error GoTo OOPS

    fn = InputFileName(CSheet.ZESheetID(ActiveSheet))
    
    num = FreeFile()
    Open (fn) For Output As #num
    
    count = SaveInputFileByColor(params, CURVE_ERROR_CLR_IDX, num)
    count = count + SaveInputFileByColor(params, CURVE_CHANGE_CLR_IDX, num)
    Close #num
    num = 0
    
'    If count = 0 Then
'        Do
'            count = 1
'
'            If CellExists(curveRgn, xlCellTypeFormulas) > 0 Then Exit Do
'            If CellExists(contractRgn, xlCellTypeFormulas) > 0 Then Exit Do
'            If CellExists(dataRgn, xlCellTypeFormulas) > 0 Then Exit Do
'
'            count = 0
'            Exit Do
'        Loop
'
'        If count = 0 Then Call CDDXHelper.DeleteFile(fn)
'    End If
    
    SaveInputFile = count
    
OOPS:
    If Err.Number <> 0 Then
        Call CDDXHelper.LogError(Err.Description, "SaveInputFile")

        SaveInputFile = -1
    End If
    
    If num > 0 Then
        Close #num
    End If
    
    On Local Error GoTo 0
    Exit Function
End Function

Private Function SaveInputFileByColor(params As CCurveParams, ByVal clrIndex As Long, ByVal FileNum As Long) As Long
 Dim fc As range
 Dim cc As range
 Dim c As Long
 Dim r As Long
 
    With Application.FindFormat
        .Clear
        .Font.ColorIndex = clrIndex
    End With

    Set fc = m_dataRgn.Find(what:=vbNullString, After:=m_dataRgn.Cells(1, 1), LookIn:=xlFormulas, LookAt:=xlPart, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=False, SearchFormat:=True)
        
    Set cc = fc
    Do
        If cc Is Nothing Then Exit Do
        
        If cc.text <> vbNullString Then
            SaveInputFileByColor = SaveInputFileByColor + 1
            
            If Not params.IsFlag(CURVE_FLG_PIVOT) Then
                c = cc.column - m_dataRgn.column + 1
                
                'curve name
                If params.IsFlag(CURVE_FLG_FUTURE_RANGE) Then
                    Print #FileNum, m_curveRgn.value
                Else
                    Print #FileNum, m_curveRgn.Cells(1, IIf(params.IsFlag(CURVE_FLG_MRBD), IIf(c Mod 2 = 0, c - 1, c), c)).value
                End If
                'opr date
                If Not params.IsFlag(CURVE_FLG_TIMESERIES) Then
                    Print #FileNum, CStr(m_oprRgn.Cells(1, c).Value2)
                End If
                
                'contract date
                Print #FileNum, CStr(m_contractRgn.Cells(cc.row - m_contractRgn.row + 1, 1).Value2)
            Else
                r = cc.row - m_curveRgn.row + 1
                Print #FileNum, m_curveRgn.Cells(r, 1).value
                If Not params.IsFlag(CURVE_FLG_TIMESERIES) Then
                    Print #FileNum, CStr(m_curveRgn.Cells(r, m_curveRgn.Columns.count).Value2)
                End If
                
                c = cc.column - m_dataRgn.column + 1
                Print #FileNum, CStr(m_contractRgn.Cells(1, cc.column - m_contractRgn.column + 1).Value2)
            End If
            
            Print #FileNum, IIf(cc.HasFormula, vbNullString, cc.value)
            Print #FileNum, CStr(clrIndex)
        End If

        Set cc = m_dataRgn.Find(what:=vbNullString, After:=cc, LookIn:=xlFormulas, LookAt:=xlPart, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=False, SearchFormat:=True)
            
        If cc Is Nothing Then Exit Do
        If cc.Address = fc.Address Then Exit Do
    Loop
End Function

Public Function InputFileNameContracts(ByVal aSheetID) As String
    InputFileNameContracts = InputFileName(aSheetID) + ".contracts"
End Function

Private Function SaveInputFileContracts(params As CCurveParams, contractRgn As range) As Long
 Dim fc As range
 Dim cc As range
 Dim fn As String
 Dim num As Integer
 
    If Not params.IsFlag(CURVE_FLG_EDIT_DATES) Then Exit Function
    
    On Local Error GoTo OOPS
    
    fn = InputFileNameContracts(CSheet.ZESheetID(ActiveSheet))
    
    num = FreeFile()
    Open (fn) For Output As #num
 
    With Application.FindFormat
        .Clear
        .Font.ColorIndex = CURVE_CHANGE_CLR_IDX
    End With

    Set fc = contractRgn.Find(what:=vbNullString, After:=contractRgn.Cells(1, 1), LookIn:=xlFormulas, LookAt:=xlPart, SearchOrder:=IIf(params.IsFlag(CURVE_FLG_PIVOT), xlByColumns, xlByRows), SearchDirection:=xlNext, MatchCase:=False, SearchFormat:=True)
    Set cc = fc
    Do
        If cc Is Nothing Then Exit Do
        
        SaveInputFileContracts = SaveInputFileContracts + 1
        
        Print #num, CStr(cc.Value2)
        Print #num, CStr(CURVE_CHANGE_CLR_IDX)

        Set cc = contractRgn.Find(what:=vbNullString, After:=cc, LookIn:=xlFormulas, LookAt:=xlPart, SearchOrder:=IIf(params.IsFlag(CURVE_FLG_PIVOT), xlByColumns, xlByRows), SearchDirection:=xlNext, MatchCase:=False, SearchFormat:=True)
            
        If cc Is Nothing Then Exit Do
        If cc.Address = fc.Address Then Exit Do
    Loop
    
    Close #num
    num = 0
    
    If SaveInputFileContracts = 0 Then
        Call CDDXHelper.DeleteFile(fn)
    End If
    
OOPS:
    If Err.Number <> 0 Then
        Call CDDXHelper.LogError(Err.Description, "SaveInputFileContracts")
    End If
    If num > 0 Then
        Close #num
    End If
    
    On Local Error GoTo 0
    Exit Function
End Function

Private Sub PopulateInputFile(params As CCurveParams)
 Dim fn As String
 Dim num As Integer
 Dim curveName As String
 Dim opr As String
 Dim contra As String
 Dim contraval As Double
 Dim item As String
 Dim clr As String
 Dim curvecell As range
 Dim v As Variant
 Dim v2 As Variant
 Dim row As Long
 Dim col As Long
 Dim truecol As Long
 Dim oprfound As Boolean
 Dim rgn As range
 
    On Local Error GoTo OOPS
        
    fn = InputFileName(CSheet.ZESheetID(ActiveSheet))
    If Dir(fn) = vbNullString Then Exit Sub
    
    num = FreeFile()
    Open fn For Input As #num
    
    Do While Not EOF(num)
        Line Input #num, curveName
        If curveName = vbNullString Then Exit Do
        
        If Not params.IsFlag(CURVE_FLG_TIMESERIES) Then
            Line Input #num, opr
        End If
        Line Input #num, contra
        Line Input #num, item
        Line Input #num, clr

        oprfound = False
        
        truecol = 0
        If IsEmpty(v) Then v = m_contractRgn.Value2
        
        If Not params.IsFlag(CURVE_FLG_FUTURE_RANGE) Then
            
            If Not params.IsFlag(CURVE_FLG_PIVOT) Then
                Set rgn = m_curveRgn.Resize(1)
            Else
                Set rgn = m_curveRgn.Resize(, 1)
            End If
            Set curvecell = rgn.Find(what:=curveName, After:=rgn.Cells(1, 1), LookIn:=xlValues, LookAt:=xlWhole, SearchOrder:=IIf(Not params.IsFlag(CURVE_FLG_PIVOT), xlByColumns, xlByRows), SearchDirection:=xlNext, MatchCase:=True, SearchFormat:=False)
            
            If Not curvecell Is Nothing Then
    
                If Not params.IsFlag(CURVE_FLG_TIMESERIES) Then
                    If Not params.IsFlag(CURVE_FLG_PIVOT) Then
                        Do
                            oprfound = True
                            
                            col = curvecell.column - m_oprRgn.column + 1
                            If CCurveDates.CompareDoubles(Val(opr), m_oprRgn.Cells(m_oprRgn.rows.count, col).Value2) = 0 Then Exit Do
                            
                            If params.IsFlag(CURVE_FLG_MRBD) And (col Mod 2) <> 0 Then
                                col = col + 1
                                If CCurveDates.CompareDoubles(Val(opr), m_oprRgn.Cells(m_oprRgn.rows.count, col).Value2) = 0 Then
                                    truecol = col
                                    Exit Do
                                End If
                            End If
                            oprfound = False
                            Exit Do
                        Loop
                    Else
                        oprfound = IIf(CCurveDates.CompareDoubles(Val(opr), m_oprRgn.Cells(curvecell.row - m_oprRgn.row + 1, m_oprRgn.Columns.count).Value2) = 0, True, False)
                    End If
                Else
                    oprfound = True
                End If
            End If
            
        Else
        
            If IsEmpty(v2) Then v2 = m_oprRgn.Value2
            
            If (VarType(v2) And vbArray) = 0 Then
                If CCurveDates.CompareDoubles(Val(opr), CDbl(v2)) = 0 Then
                    oprfound = True
                    Set curvecell = m_oprRgn.Cells(1, 1)
                End If
            Else
                For col = LBound(v2, 2) To UBound(v2, 2)
                    If CCurveDates.CompareDoubles(Val(opr), CDbl(v2(1, col))) = 0 Then
                        oprfound = True
                        Set curvecell = m_oprRgn.Cells(1, col)
                        Exit For
                    End If
                Next
            End If
        End If
                
        If oprfound Then
            contraval = Val(contra)
            
            row = 0
            col = 0
            
            If Not params.IsFlag(CURVE_FLG_PIVOT) Then
                
                If (VarType(v) And vbArray) = 0 Then
                    If CCurveDates.CompareDoubles(contraval, CDbl(v)) = 0 Then row = 1
                Else
                    For row = LBound(v, 1) To UBound(v, 1)
                        If CCurveDates.CompareDoubles(contraval, CDbl(v(row, 1))) = 0 Then Exit For
                    Next
                    If row > UBound(v, 1) Then row = 0
                End If
                
                If row > 0 Then
                    col = IIf(truecol = 0, curvecell.column - m_dataRgn.column + 1, truecol)
                End If
            
            Else
                
                If (VarType(v) And vbArray) = 0 Then
                    If CCurveDates.CompareDoubles(contraval, CDbl(v)) = 0 Then col = 1
                Else
                    For col = LBound(v, 2) To UBound(v, 2)
                        If CCurveDates.CompareDoubles(contraval, CDbl(v(1, col))) = 0 Then Exit For
                    Next
                    If col > UBound(v, 2) Then col = 0
                End If
                
                If col > 0 Then
                    row = curvecell.row - m_dataRgn.row + 1
                End If
            End If
            
            If col > 0 And row > 0 Then
                With m_dataRgn.Cells(row, col)
                    If Len(item) > 0 Then .value = item
                    .Characters.Font.ColorIndex = Val(clr)
                End With
            End If
        End If
    Loop
    
    Close #num
    num = -1
    
OOPS:
    If Err.Number <> 0 Then
        Call CDDXHelper.LogError(Err.Description, "PoupulateInputFile")
        If num > 0 Then Close #num
    End If
    Call CDDXHelper.DeleteFile(fn)
    
    On Local Error GoTo 0
    Exit Sub
End Sub

Private Sub PopulateInputFileContracts(params As CCurveParams, contractRgn As range)
 Dim fn As String
 Dim num As Integer
 Dim contra As String
 Dim contraval As Double
 Dim clr As String
 Dim curvecell As range
 Dim v As Variant
 Dim k As Long
 
    If Not params.IsFlag(CURVE_FLG_EDIT_DATES) Then Exit Sub
    
    On Local Error GoTo OOPS
        
    fn = InputFileNameContracts(CSheet.ZESheetID(ActiveSheet))
    If Dir(fn) = vbNullString Then Exit Sub
    
    v = contractRgn.Value2
    
    num = FreeFile()
    Open fn For Input As #num
    
    Do While Not EOF(num)
        Line Input #num, contra
        Line Input #num, clr

        contraval = Val(contra)
        
        If (VarType(v) And vbArray) = vbArray Then
            If params.IsFlag(CURVE_FLG_PIVOT) Then
                For k = LBound(v, 2) To UBound(v, 2)
                    If CCurveDates.CompareDoubles(contraval, CDbl(v(1, k))) = 0 Then
                        contractRgn.Cells(1, k).Characters.Font.ColorIndex = Val(clr)
                        Exit For
                    End If
                Next
            Else
                For k = LBound(v, 1) To UBound(v, 1)
                    If CCurveDates.CompareDoubles(contraval, CDbl(v(k, 1))) = 0 Then
                        contractRgn.Cells(k, 1).Characters.Font.ColorIndex = Val(clr)
                        Exit For
                    End If
                Next
            End If
        Else
            If CCurveDates.CompareDoubles(contraval, CDbl(v)) = 0 Then
                contractRgn.Cells(1, 1).Characters.Font.ColorIndex = Val(clr)
            End If
        End If
    Loop
    
    Close #num
    num = -1
    
OOPS:
    If Err.Number <> 0 Then
        Call CDDXHelper.LogError(Err.Description, "PoupulateInputFile")
        If num > 0 Then Close #num
    End If
    Call CDDXHelper.DeleteFile(fn)
    
    On Local Error GoTo 0
    Exit Sub
End Sub

Private Function IsOprCell(rgn As range) As range
    On Error GoTo OOPS
    
    Do
        If Not rgn.Locked Then Exit Do
        If Val(rgn.Value2) > 0 Then Exit Do
        Exit Function
    Loop
    Set IsOprCell = rgn
    
OOPS:
    Exit Function
End Function

Public Function SaveEffectiveStartDate() As Boolean
 Dim target As range
 Dim fvs As Long
 Dim tdv As Long
 
    On Error GoTo OOPS
    
    Set CCurveDates.TargetSheet = ActiveSheet
    fvs = CDDXCurve.GetFVS(CCurveDates.TargetSheet)
    
    If Not Need2CalculateChangableDate(fvs, True) Then
        SaveEffectiveStartDate = True
        Exit Function
    End If
    
    With CCurveDates.ParamEntity
        Set target = IsOprCell(CCurveDates.TargetSheet.Cells(3, 1))
        If target Is Nothing Then Set target = IsOprCell(CCurveDates.TargetSheet.Cells(2, 2))
        If target Is Nothing Then
            If CDDXHelper.IsFlag(fvs, CURVE_FLG_MULTIOBS) Then Exit Function 'for old future sheets
            CDDXApp.StatusMessage = "Effective date not found."
            Exit Function
        End If
        
        If iserror(target.value) Or Not IsDate(target.value) Then
            CDDXApp.StatusMessage = "Invalid Effective date."
            Exit Function
        End If
        
        SaveEffectiveStartDate = True
        
        tdv = Int(CDbl(target.value))
        If Int(CDbl(.OprStartDate)) = tdv Then Exit Function
            
        .OprStartDate = CDate(tdv)
        .OprEndDate = .OprStartDate
        Call SaveCurveProperties(CCurveDates.TargetSheet, CCurveDates.ParamEntity)
    End With
    
    If Application.Calculation <> xlCalculationAutomatic Then
        If GetAreas(-1) Then
            With m_oprRgn
                Call .Calculate
            End With
        End If
    End If
    
OOPS:
    If Err.Number <> 0 Then
        CDDXApp.StatusMessage = "Invalid Effective date. " + Err.Description
        SaveEffectiveStartDate = False
    End If
    
    Exit Function
End Function

Public Sub SaveCurveProperties(sht As Worksheet, params As CCurveParams)
    If (params.flagValues \ 2 ^ 28) = 0 Then
        params.flagValues = (params.flagValues Or CURVE_FLG_V1)
    End If
    
    Call CSheet.WSSetProp(sht, CURVE_SHEET_INFO, params.ToXML())

    Call CSheet.WSSetProp(sht, CURVE_SHEET_FLAGVALUES, CDDXHelper.ToHexStr(params.flagValues))
End Sub
'
Public Function GetCurveProperties(sht As Worksheet) As String
    GetCurveProperties = CSheet.WSGetProp(sht, CURVE_SHEET_INFO)
End Function

Public Function GetSheet(params As CCurveParams, ByVal createWhenNew As Boolean, ByRef isCreated As Boolean) As Worksheet
 Dim sht As Worksheet

    If ActiveWorkbook Is Nothing Then Exit Function
    
    isCreated = True

    For Each sht In ActiveWorkbook.Worksheets
        If StrComp(CDDXHelper.ZESheetID(BSConsts.DDX_PID, sht), params.sheetId, vbBinaryCompare) = 0 Then
            Call Unprotect(sht)
            Set GetSheet = sht
            sht.Select
            isCreated = False
            Exit Function
        End If
    Next

    If Not createWhenNew Then Exit Function
    
    With ActiveWorkbook.Worksheets
        If .count > 0 Then
            Set GetSheet = .Add(After:=ActiveWorkbook.Worksheets(.count))
        Else
            Set GetSheet = .Add
        End If
    End With
    
    Call SetSheetName(GetSheet, params.flagValues)
    CSheet.ZESheetID(GetSheet) = params.sheetId
    
    If CDDXCurve.GetSheetVersion(params.flagValues) >= CDDXCurve.GetSheetVersion(CURVE_FLG_V2) Then
        GetSheet.EnableOutlining = True
    End If
    
    If params.IsFlag(CURVE_FLG_TIMESERIES) Then
        GetSheet.Tab.ColorIndex = 24
    ElseIf params.IsFlag(CURVE_FLG_MULTIOBS) Then
        GetSheet.Tab.ColorIndex = 21
    Else
        GetSheet.Tab.ColorIndex = 35
    End If
    'SheetCurrentOwner(GetSheet) = CDDXLogin.CurrentUser
End Function

Public Function GetParams(sht As Worksheet) As CCurveParams
    Set GetParams = New CCurveParams
    With GetParams
        Call .FromXML(GetCurveProperties(sht))
    End With
End Function

Public Sub Unprotect(sht As Worksheet)
    On Error GoTo OOPS
    
    If sht Is Nothing Then Set sht = ActiveSheet

    Call sht.Unprotect(CURVE_SHEET_PASSWORD)

OOPS:
    If Err.Number <> 0 Then
        CDDXApp.StatusMessage = Err.Description
    End If
    On Error GoTo 0
    Exit Sub
End Sub

Public Sub Protect(sht As Worksheet)
 Dim fvs As Long
 
    On Error GoTo OOPS
    
    If sht Is Nothing Then Set sht = ActiveSheet
    If Not CDDXHelper.IsCurveSheet(sht) Then Exit Sub
    
    fvs = CDDXCurve.GetFVS(sht)
    
    If CDDXCurve.GetSheetVersion(fvs) <= CDDXCurve.GetSheetVersion(CURVE_FLG_V1) Then
        sht.Protect DrawingObjects:=True, UserInterfaceOnly:=True, AllowFormattingCells:=CDDXHelper.IsFlag(fvs, CURVE_FLG_EDIT_DATES), Password:=CURVE_SHEET_PASSWORD
    Else
        sht.Protect UserInterfaceOnly:=True, Password:=CURVE_SHEET_PASSWORD
        sht.EnableOutlining = True
    End If
    
OOPS:
    If Err.Number <> 0 Then
        CDDXApp.StatusMessage = Err.Description
    End If
    On Error GoTo 0
    Exit Sub
End Sub

Public Function GetImagesDir() As String
    GetImagesDir = CDDXHelper.GetImagesDirectory()
End Function

Private Sub SetSheetName(curveSht As Worksheet, ByVal flagValues As Long)
 Dim sht As Worksheet
 Dim numstr As String
 Dim n As Integer
 Dim num As Integer
 Dim root As String
 
    root = "ZEMA "
    If CDDXHelper.IsFlag(flagValues, CURVE_FLG_TIMESERIES) Then
        root = root + IIf(CDDXHelper.IsFlag(flagValues, CURVE_FLG_MULTIOBS), "(MO TimeSeries)", "(TimeSeries)")
    Else
        root = root + IIf(CDDXHelper.IsFlag(flagValues, CURVE_FLG_MULTIOBS), "(MO Futures)", "(Futures)")
    End If
    
    For Each sht In curveSht.Parent.Worksheets
        If LCase(sht.name) Like LCase(root) + "*" Then
            n = InStr(sht.name, ") ")
            If n > 0 Then
                numstr = Trim(Mid(sht.name, n + 1))
                If IsNumeric(numstr) Then
                    n = Int(CDec(numstr))
                    If n > num Then num = n
                End If
            End If
        End If
    Next
    
    root = root + "  " + CStr(num + 1)
    If Len(root) <= 32 Then
        curveSht.name = root
    End If
End Sub

Public Sub InsertTitle(sht As Worksheet)
    With sht
        Call .Shapes.AddPicture(GetImagesDir() + "CurveHeader.png", msoFalse, msoTrue, .Cells(1, 1).left, .Cells(1, 1).top + 3, -1, -1)
    End With
'    With sht.Pictures.Insert(GetImagesDir() + "CurveHeader.png")
'        .left = sht.Cells(1, 1).left
'        .top = sht.Cells(1, 1).top + 3
'    End With
End Sub

Public Sub SplitDataLine(buff As String, granuPart As Long, curveTypePart As String)
 Dim p1 As Long
 Dim p2 As Long
 
    granuPart = CURVE_GRANULARITY_NONE
    curveTypePart = vbNullString
    
    p1 = InStr(buff, vbTab)
    If p1 <= 0 Then Exit Sub
    
    If p1 > 1 Then
        granuPart = Val(left(buff, p1 - 1))
    End If
    
    p2 = InStr(p1 + 1, buff, vbTab)
    If p2 <= 0 Then Exit Sub
    
    If p2 - p1 > 1 Then
        curveTypePart = Mid(buff, p1 + 1, p2 - p1 - 1)
    End If
    
    buff = Mid(buff, p2 + 1)
End Sub

Private Function DecodeComment(ByVal cmtStr As String) As String
 Const COMMENT_NEWLINE As String = "&#13;"
 
    If cmtStr = vbNullString Then Exit Function
    If InStr(cmtStr, COMMENT_NEWLINE) > 0 Then
        DecodeComment = Replace(cmtStr, COMMENT_NEWLINE, vbNewLine)
    Else
        DecodeComment = cmtStr
    End If
End Function

Public Sub Remove4EyesStyle(dtaRgn As range)
    If dtaRgn Is Nothing Then Exit Sub
    
    With dtaRgn
        .Interior.ColorIndex = xlNone
        .Font.Bold = False
'        .Font.Italic = False
    End With
End Sub

Public Sub Add4EyesStyle(dtaRgn As range)
    If dtaRgn Is Nothing Then Exit Sub
    
    On Error GoTo OOPS
    
    With Application.FindFormat
        .Clear
        .Font.Bold = True
'        .Font.Italic = True
        '.Interior.color = CURVE_4EYES_COLOR
    End With
    
    With Application.ReplaceFormat
        .Clear
        .Locked = True
    End With

    Call dtaRgn.Replace(what:=vbNullString, replacement:=vbNullString, SearchFormat:=True, ReplaceFormat:=True)
    
OOPS:
    If Err.Number <> 0 Then
        CDDXApp.StatusMessage = Err.source + Err.Description
    End If
    Exit Sub
End Sub

Public Sub RefreshCommentsAfterUploaded(cmtRgn As range, ByVal transposed As Boolean)
    If Not CDDXCurve.FourEyesActive Then Exit Sub

    Call AddComments(False, cmtRgn, transposed)
End Sub

Private Sub AddComments(ByVal doClear As Boolean, cmtRgn As range, ByVal transposed As Boolean)
 Dim file As Object
 Dim fpath As String
 Dim msg As String
 Dim k As Long
 Dim r As Long
 Dim c As Long
 Dim attribs As Long
 Dim buff As Variant
 Dim cmt As Comment
 Dim valprot As Boolean
 Dim clearance As Long
 
    On Error GoTo OOPS
    
    clearance = IIf(doClear, CLEARANCE_BACKGROUND Or CLEARANCE_COMMENT_FONT, 0)
    
    fpath = CurveCommentFilePath
    
    If Not CDDXHelper.FileThere(fpath) Then
        clearance = clearance Or CLEARANCE_COMMENT_FONT
        fpath = vbNullString
    ElseIf FileLen(fpath) <= 3 Then
        clearance = clearance Or CLEARANCE_COMMENT_FONT
        fpath = vbNullString
    End If

    With cmtRgn
        If (clearance And CLEARANCE_COMMENT_FONT) <> 0 Then
            Call .ClearComments
            .Cells.Font.Bold = False
        End If
        
        If (clearance And CLEARANCE_BACKGROUND) <> 0 Then
            .Interior.color = xlNone
        End If
    End With

    If fpath = vbNullString Then
        fpath = CurveCommentFilePath
        If CDDXHelper.FileThere(fpath) Then Kill fpath
        Exit Sub
    End If
    
    Set file = CDDXFile.OpenFile(fpath)
    
    Do
        If file.EOS() Then Exit Do
        
        buff = file.ReadText(-2)
        If Len(buff) = 0 Then Exit Do
        
        buff = Split(CStr(buff), vbTab)

        r = Int(Val(buff(0)))
        k = 1
        Do
            If k > UBound(buff) Then Exit Do
            
            c = Int(Val(buff(k)))
            If c = 0 Then Exit Do
            
            attribs = c And &HF
            c = c \ &H10

            valprot = IIf((attribs And ATTRIB_CELL_PROTECTION) = 0, False, True)

            With cmtRgn.Cells(IIf(transposed, c, r), IIf(transposed, r, c))
                If IIf(valprot And (attribs And ATTRIB_CELL_4EYES) <> 0, True, False) Then
                    .Font.Bold = True
                    '.Font.Italic = prot
                    .Interior.color = IIf(True, CURVE_4EYES_COLOR, xlNone)
'                Else
'                    If .Font.Bold Then
'                        .Interior.color = xlNone
'                        .Locked = False
'                    End If
'                    .Font.Bold = False
                End If
            End With
                
            Set cmt = cmtRgn.Cells(IIf(transposed, c, r), IIf(transposed, r, c)).Comment
    
            If (attribs And ATTRIB_CELL_COMMENT) = 0 Then
                If Not cmt Is Nothing Then cmt.Delete
                
            Else
                If cmt Is Nothing Then Set cmt = cmtRgn.Cells(IIf(transposed, c, r), IIf(transposed, r, c)).AddComment
                
                valprot = valprot And IIf((attribs And ATTRIB_CELL_4EYES) = 0, True, False)
                With cmt
                    .text IIf(valprot, PROT_TEXT + vbLf, vbNullString) + DecodeComment(buff(k + 1))
                    
                    With .Shape.TextFrame.Characters(1)
                        .Font.Italic = False
                        .Font.ColorIndex = 1
                    End With
                    
                    If valprot Then
                        With .Shape.TextFrame.Characters(1, Len(PROT_TEXT))
                            .Font.Italic = True
                            .Font.ColorIndex = 3
                        End With
                    End If
                    .Shape.TextFrame.AutoSize = True
                End With
            End If
            
            k = k + 2
            
'            With cmt
'                .text IIf(protd, "Protected" + vbLf + vbLf, vbNullString) + DecodeComment(buff(k + 1))
'                If protd Then
'                    With .Shape.TextFrame.Characters(1, Len("Protected"))
'                        .Font.Italic = True
'                        .Font.ColorIndex = 3
'                    End With
'                End If
'                .Shape.TextFrame.AutoSize = True
'            End With
                
'            With cmt.Shape
'                .Fill.UserPicture GetImagesDir() + "secure.png"
'                .Line.Visible = msoFalse
'                .Shadow.Visible = msoFalse
'                .Width = 12
'                .Height = 12
'            End With
        Loop
    Loop
    
OOPS:
    If Err.Number <> 0 Then
        Call CDDXHelper.LogError(Err.Description, "AddComments")
    End If
    
    If Not file Is Nothing Then
        Call CDDXFile.CloseFile(file, fpath, msg)
        Set file = Nothing
    End If
    
    Exit Sub
End Sub

Public Sub ReadFile(aCurveIndex As Long, contractRgn As range, datargn As range, curveParams As CCurveParams)
 Dim fn As String
 Dim buff As String
 Dim file As Object
 Dim f() As String
 Dim numval
 Dim contr As String
 Dim p As Long
 Dim k As Long
 Dim c As Long
 Dim gidx As Long
 Dim ctname As String
 Dim colcnt As Long
 Dim respectf As Boolean
 Dim hasvalidation As Boolean
 Dim errmsg As String
 Dim ev As Variant
 Dim doclr As Boolean
 
    On Local Error GoTo OOPS
    
    Call CXLTaskSwitch.DisableTS
    
    Call CCurveType.RefreshObservationTypes(datargn.Parent, curveParams)

    k = IIf(curveParams.IsFlag(CURVE_FLG_MULTIOBS), 2, 1)
    k = IIf(k >= datargn.rows.count, 0, k)
    doclr = Not VRColorValues(VRFilePath, datargn.offset(k).Resize(datargn.rows.count - k), curveParams, False)
 
    colcnt = datargn.Columns.count
    respectf = CCurveControl.PreserveFormulas
    
    If curveParams.IsFlag(CURVE_FLG_MULTIOBS) And Not contractRgn Is Nothing Then
        hasvalidation = (contractRgn.rows.count > 1)
    End If
    
    If hasvalidation Then
        If Not curveParams.IsFlag(CURVE_FLG_TIMESERIES) Then
            Call CCurveGranularity.CreateContents(curveParams.granularities)
            Call CCurveGranularity.AddDropdowns(contractRgn.offset(1, 1).Resize(contractRgn.rows.count - 1, 1))
        End If
        
        Call CCurveType.CreateContents(curveParams.curveTypes)
        Call CCurveType.AddDropdowns(contractRgn.offset(1, IIf(curveParams.IsFlag(CURVE_FLG_TIMESERIES), 2, 3) - 1).Resize(contractRgn.rows.count - 1, 1))
    End If
            
    fn = CurveFilePath

    Set file = CDDXFile.OpenFile(fn)
    
    For k = 1 To datargn.rows.count
        If file.EOS() Then Exit For
        
        buff = file.ReadText(-2)

        Call CCurveControl.SplitDataLine(buff, gidx, ctname)
      
        If hasvalidation And k > 1 Then
            If Not curveParams.IsFlag(CURVE_FLG_TIMESERIES) Then
                Call CCurveGranularity.SetDropdownSelection(contractRgn.Parent.Cells(k + contractRgn.row - 1, 2), gidx)
            End If
            Call CCurveType.SetDropdownSelection(contractRgn.Parent.Cells(k + contractRgn.row - 1, IIf(curveParams.IsFlag(CURVE_FLG_TIMESERIES), 2, 3)), ctname)
        End If

        If k = 1 Then
            f = Split(buff, vbTab)

            For p = LBound(f) + 1 To UBound(f)
                If Not curveParams.IsFlag(CURVE_FLG_TIMESERIES) Then
                    Call CCurveControl.SetDateValue(CDDXDates.SystemDateFormat, datargn.Cells(1, p), f(p))
                Else
                    With datargn.Cells(1, p)
                        .NumberFormat = "@"
                        .HorizontalAlignment = xlCenter
                        .VerticalAlignment = xlCenter
                        .value = f(p)
                    End With
                End If
            Next
    
            If curveParams.IsFlag(CURVE_FLG_MULTIOBS) Then
                Set datargn = datargn.offset(1).Resize(datargn.rows.count - 1)
            End If
        Else
            p = InStr(buff, vbTab)
            contr = left(buff, p - 1)
        
            f = Split(Mid(buff, p + 1), vbTab)
            
            If Not respectf Then
                If Not contractRgn Is Nothing Then
                    contractRgn.Cells(k, 1).Value2 = Val(contr)
                    If curveParams.IsFlag(CURVE_FLG_EDIT_DATES) Then
                        contractRgn.Cells(k, 1).Characters.Font.ColorIndex = xlColorIndexAutomatic 'CURVE_DATA_CLR_IDX
                        If curveParams.IsFlag(CURVE_FLG_MULTIOBS) Then
                            contractRgn.Cells(k, 2).Resize(, IIf(curveParams.IsFlag(CURVE_FLG_TIMESERIES), 1, 2)).Characters.Font.ColorIndex = xlColorIndexAutomatic 'CURVE_DATA_CLR_IDX
                        End If
                    End If
                End If

                If IsEmpty(numval) Then
                    ReDim numval(0 To datargn.Columns.count - 1)
                End If
                
                For p = 0 To UBound(numval)
                    If Len(f(p)) > 0 Then
                        numval(p) = Val(f(p))
                    Else
                        numval(p) = ev
                    End If
                Next
    
                Call datargn.offset(k).Resize(1).ClearContents
                datargn.rows(k) = numval
                datargn.rows(k).Characters.Font.ColorIndex = xlColorIndexAutomatic 'CURVE_DATA_CLR_IDX
                
            Else
                If Not contractRgn Is Nothing Then
                    If Not contractRgn.Cells(k, 1).HasFormula Then
                        contractRgn.Cells(k, 1).Value2 = Val(contr)
                        If curveParams.IsFlag(CURVE_FLG_EDIT_DATES) Then
                            contractRgn.Cells(k, 1).Characters.Font.ColorIndex = xlColorIndexAutomatic 'CURVE_DATA_CLR_IDX
                            If curveParams.IsFlag(CURVE_FLG_MULTIOBS) Then
                                contractRgn.Cells(k, 2).Resize(, IIf(curveParams.IsFlag(CURVE_FLG_TIMESERIES), 1, 2)).Characters.Font.ColorIndex = xlColorIndexAutomatic 'CURVE_DATA_CLR_IDX
                            End If
                        End If
                    End If
                End If
                
                For c = 1 To colcnt
                    If Not datargn.Cells(k, c).HasFormula Then
                        Call datargn.Cells(k, c).ClearContents
                        
                        If c - 1 <= UBound(f) Then
                            If Len(f(c - 1)) > 0 Then
                                datargn.Cells(k, c) = Val(f(c - 1))
                            End If
                            datargn.Cells(k, c).Characters.Font.ColorIndex = xlColorIndexAutomatic 'CURVE_DATA_CLR_IDX
                        End If
                    End If
                Next
            End If
        End If
    Next

    If datargn.rows.count > 1 Then
        Call AddComments(doclr, datargn.offset(1).Resize(datargn.rows.count - 1), False)
        Call SetSOCValueFormats(aCurveIndex, datargn.offset(1).Resize(datargn.rows.count - 1), curveParams)
    Else
        Call CDDXHelper.DeleteFile(CurveCommentFilePath)
    End If
    
OOPS:
    If Err.Number <> 0 Then
        Call CDDXHelper.LogError(Err.Description, "ReadFile")
    End If
    
    Call CDDXFile.CloseFile(file, fn, errmsg)
    Set file = Nothing
    
    If errmsg <> vbNullString Then CDDXApp.StatusMessage = errmsg
    
    Call CXLTaskSwitch.RestoreTS
    
    On Local Error GoTo -1
    Exit Sub
End Sub

Public Sub ReadFileRange(aCurveIndex As Long, contractRgn As range, datargn As range, curveParams As CCurveParams)
 Dim fn As String
 Dim file As Object
 Dim buff As String
 Dim f() As String
 Dim numval
 Dim k As Long
 Dim c As Long
 Dim col As Long
 Dim contr As String
 Dim p As Long
 Dim gidx As Long
 Dim ctname As String
 Dim respectf As Boolean
 Dim colcnt As Long
 Dim hasvalidation As Boolean
 Dim errmsg As String
 Dim ev As Variant
 Dim doclr As Boolean
 
    respectf = CCurveControl.PreserveFormulas
    colcnt = datargn.Columns.count
 
    If curveParams.IsFlag(CURVE_FLG_MULTIOBS) And Not contractRgn Is Nothing Then
        hasvalidation = (contractRgn.rows.count > 1)
    End If
    
    If hasvalidation Then
        Call CCurveGranularity.CreateContents(curveParams.granularities)
        Call CCurveGranularity.AddDropdowns(contractRgn.offset(1, 1).Resize(contractRgn.rows.count - 1, 1))
        
        Call CCurveType.CreateContents(curveParams.curveTypes)
        Call CCurveType.AddDropdowns(contractRgn.offset(1, 2).Resize(contractRgn.rows.count - 1, 1))
    End If
    
    On Local Error GoTo OOPS
    
    Call CXLTaskSwitch.DisableTS
    
    Call CCurveType.RefreshObservationTypes(datargn.Parent, curveParams)
    
    k = IIf(curveParams.IsFlag(CURVE_FLG_MULTIOBS), 2, 1)
    k = IIf(k >= datargn.rows.count, 0, k)
    doclr = Not VRColorValues(VRFilePath, datargn.offset(k).Resize(datargn.rows.count - k), curveParams, False)
    
    fn = CurveFilePath

    Set file = CDDXFile.OpenFile(fn)
    
    For k = 1 To datargn.rows.count
        If file.EOS() Then Exit For
        
        buff = file.ReadText(-2)
        
        Call CCurveControl.SplitDataLine(buff, gidx, ctname)
        If curveParams.IsFlag(CURVE_FLG_MULTIOBS) Then
            If k > 1 Then
                Call CCurveGranularity.SetDropdownSelection(contractRgn.Parent.Cells(k + contractRgn.row - 1, 2), gidx)
                Call CCurveType.SetDropdownSelection(contractRgn.Parent.Cells(k + contractRgn.row - 1, 3), ctname)
            End If
        End If

        If k = 1 Then
            f = Split(buff, vbTab)

            For c = LBound(f) + 1 To UBound(f)
                Call CCurveControl.SetDateValue(CDDXDates.SystemDateFormat, datargn.Cells(1, c), f(c))
            Next
            
            If curveParams.IsFlag(CURVE_FLG_MULTIOBS) Then
                Set datargn = datargn.offset(1).Resize(datargn.rows.count - 1)
            End If

        Else
            p = InStr(buff, vbTab)
            contr = left(buff, p - 1)
        
            f = Split(Mid(buff, p + 1), vbTab)
            
            If Not respectf Then
                contractRgn.Cells(k, 1).Value2 = Val(contr)
                If curveParams.IsFlag(CURVE_FLG_EDIT_DATES) Then
                    contractRgn.Cells(k, 1).Characters.Font.ColorIndex = xlColorIndexAutomatic 'CURVE_DATA_CLR_IDX
                    If curveParams.IsFlag(CURVE_FLG_MULTIOBS) And Not curveParams.IsFlag(CURVE_FLG_TIMESERIES) Then
                        contractRgn.Cells(k, 2).Resize(, 2).Characters.Font.ColorIndex = xlColorIndexAutomatic 'CURVE_DATA_CLR_IDX
                    End If
                End If

                If IsEmpty(numval) Then
                    ReDim numval(0 To datargn.Columns.count - 1)
                End If
                For p = 0 To UBound(numval)
                    If Len(f(p)) > 0 Then
                        numval(p) = Val(f(p))
                    Else
                        numval(p) = ev
                    End If
                Next
                
                Call datargn.offset(k).Resize(1).ClearContents
                datargn.rows(k) = numval
                datargn.rows(k).Characters.Font.ColorIndex = xlColorIndexAutomatic 'CURVE_DATA_CLR_IDX
            Else
                If Not contractRgn.Cells(k, 1).HasFormula Then
                    contractRgn.Cells(k, 1).Value2 = Val(contr)
                    If curveParams.IsFlag(CURVE_FLG_EDIT_DATES) Then
                        contractRgn.Cells(k, 1).Characters.Font.ColorIndex = xlColorIndexAutomatic 'CURVE_DATA_CLR_IDX
                        If curveParams.IsFlag(CURVE_FLG_MULTIOBS) And Not curveParams.IsFlag(CURVE_FLG_TIMESERIES) Then
                            contractRgn.Cells(k, 2).Resize(, 2).Characters.Font.ColorIndex = xlColorIndexAutomatic 'CURVE_DATA_CLR_IDX
                        End If
                    End If
                End If
                
                For c = 1 To colcnt
                    If Not datargn.Cells(k, c).HasFormula Then
                        Call datargn.Cells(k, c).ClearContents
                        
                        If c - 1 <= UBound(f) Then
                            If Len(f(c - 1)) > 0 Then
                                datargn.Cells(k, c) = Val(f(c - 1))
                            End If
                            datargn.Cells(k, c).Characters.Font.ColorIndex = xlColorIndexAutomatic 'CURVE_DATA_CLR_IDX
                        End If
                    End If
                Next
            End If
        End If
    Next

    If datargn.rows.count > 1 Then
        Call AddComments(doclr, datargn.offset(1).Resize(datargn.rows.count - 1), False)
        Call SetSOCValueFormats(aCurveIndex, datargn.offset(1).Resize(datargn.rows.count - 1), curveParams)
    Else
        Call CDDXHelper.DeleteFile(CurveCommentFilePath)
    End If
    
OOPS:
    If Err.Number <> 0 Then
        Call CDDXHelper.LogError(Err.Description, "ReadFileRange")
    End If
    
    Call CDDXFile.CloseFile(file, fn, errmsg)
    Set file = Nothing
    
    If errmsg <> vbNullString Then CDDXApp.StatusMessage = errmsg
    
    Call CXLTaskSwitch.RestoreTS
    
    On Error GoTo 0
    Exit Sub
End Sub

Public Sub ReadFileTRANS(aCurveIndex As Long, contractRgn As range, datargn As range, curveParams As CCurveParams)
 Dim fn As String
 Dim buff As String
 Dim file As Object
 Dim f() As String
 Dim k As Long
 Dim c As Long
 Dim col As Long
 Dim gidx As Long
 Dim ctname As String
 Dim respectf As Boolean
 Dim hdrcols As Long
 Dim colcnt As Long
 Dim rwcnt As Long
 Dim contrfmt As String
 Dim errmsg As String
 Dim doclr As Boolean
 Dim clridx As Long
 
    On Local Error GoTo OOPS
    
    Call CXLTaskSwitch.DisableTS
    
    Call CCurveType.RefreshObservationTypes(datargn.Parent, curveParams)
    
    k = IIf(curveParams.IsFlag(CURVE_FLG_TIMESERIES), FXIED_COLUMNS_TRANSPOSED, FXIED_COLUMNS_TRANSPOSED) + HoriWidthTRANS(curveParams)
    k = IIf(k >= datargn.Columns.count, 0, k)
    doclr = Not VRColorValues(VRFilePath, datargn.offset(, k).Resize(, datargn.Columns.count - k), curveParams, False)
    
    respectf = CCurveControl.PreserveFormulas
    hdrcols = curveParams.PropertyCount + FXIED_COLUMNS_TRANSPOSED + IIf(curveParams.IsFlag(CURVE_FLG_TIMESERIES), 0, 1)
    colcnt = datargn.Columns.count
    
    contrfmt = CDDXCurve.GetContractDateFormat(curveParams.granularities)
    
    fn = CurveFilePath

    Set file = CDDXFile.OpenFile(fn)
    
    If Not contractRgn Is Nothing Then
        If Not curveParams.IsFlag(CURVE_FLG_TIMESERIES) Then
            contractRgn.Cells(1, hdrcols).value = "Effective Date"
        End If
    End If
    
    rwcnt = datargn.rows.count
    
    For k = 1 To colcnt - hdrcols + 1
        If file.EOS() Then Exit For
        
        buff = file.ReadText(-2)
        
        Call CCurveControl.SplitDataLine(buff, gidx, ctname)

        f = Split(buff, vbTab)
        
        If k = 1 Then
''            For c = LBound(f) + 1 To UBound(f)
''                If Not curveParams.IsFlag(CURVE_FLG_TIMESERIES) Then
''                    Call CCurveControl.SetDateValue(CDDXDates.SystemDateFormat, datargn.Cells(c, hdrcols), f(c))
''                End If
''            Next
            If Not curveParams.IsFlag(CURVE_FLG_TIMESERIES) Then
                With datargn.Cells(1, hdrcols).Resize(UBound(f) - LBound(f))
                    .value = f(1)
                    .NumberFormat = CDDXDates.SystemDateFormat
                End With
            End If
        Else
            col = hdrcols + k - 1
            For c = LBound(f) To rwcnt ' UBound(f)
                If c = LBound(f) Then
                    If Not contractRgn Is Nothing Then
                        If Not respectf Or Not contractRgn.Cells(1, col).HasFormula Then
                            Call CCurveControl.SetDateValue(contrfmt, contractRgn.Cells(1, col), f(c))
'                            contractRgn.Cells(1, col).Characters.Font.ColorIndex = xlColorIndexAutomatic'CURVE_DATA_CLR_IDX
                        End If
                    End If
                Else
                    If Not respectf Then
                        'datargn.Cells(c, col).NumberFormat = "General"
                        datargn.Cells(c, col) = f(c)
                        datargn.Cells(c, col).Characters.Font.ColorIndex = xlColorIndexAutomatic 'CURVE_DATA_CLR_IDX
                    Else
                        clridx = datargn.Cells(c, col).Characters.Font.ColorIndex
                        If Not (datargn.Cells(c, col).HasFormula Or (clridx <> xlColorIndexAutomatic And clridx <> 1)) Then
                            'datargn.Cells(c, col).NumberFormat = "General"
                            datargn.Cells(c, col) = f(c)
                            datargn.Cells(c, col).Characters.Font.ColorIndex = xlColorIndexAutomatic
                        End If
                    End If
                End If
            Next
        End If
    Next

    If datargn.Columns.count > hdrcols Then
        Call AddComments(doclr, datargn.offset(, hdrcols).Resize(, datargn.Columns.count - hdrcols), True)
        Call SetSOCValueFormats(aCurveIndex, datargn.offset(, hdrcols).Resize(, datargn.Columns.count - hdrcols), curveParams)
    Else
        Call CDDXHelper.DeleteFile(CurveCommentFilePath)
    End If
    
OOPS:
    If Err.Number <> 0 Then
        Call CDDXHelper.LogError(Err.Description, "ReadFileTRANS")
    End If
    
    Call CDDXFile.CloseFile(file, fn, errmsg)
    Set file = Nothing
    
    If errmsg <> vbNullString Then CDDXApp.StatusMessage = errmsg
    
    Call CXLTaskSwitch.RestoreTS
    
    On Local Error GoTo 0
    Exit Sub
End Sub

Public Sub RearrangeDatesTS(dtaRgn As range, curveParams As CCurveParams)
 Dim fn As String
 Dim filnum As Long
 Dim p As Long
 Dim size As Long
 Dim nextp As Long
 Dim buff As String
 Dim gidx As Long
 Dim ctnam As String
 
    If dtaRgn.rows.count <= 1 Then Exit Sub
    
    On Local Error GoTo OOPS:
    
    size = 0
    
    fn = CurveFilePath

    filnum = FreeFile

    Open fn For Input As filnum

    nextp = 0
    Do
        If EOF(filnum) Then Exit Do
        
        Line Input #filnum, buff
        If Len(buff) = 0 Then Exit Do
        
        If nextp >= 1 Then
            If nextp >= size Then
                size = size + 1024
                ReDim Preserve m_ts_oprs(0 To size - 1)
            End If
            
            Call CCurveControl.SplitDataLine(buff, gidx, ctnam)
            p = InStr(buff, vbTab)
            m_ts_oprs(nextp).oprDate = Val(left(buff, p - 1))
            m_ts_oprs(nextp).curveType = ctnam
            
            nextp = nextp + 1
        End If
    Loop
    
    Close filnum
    filnum = -1
    
    If nextp > 0 Then
        ReDim Preserve m_ts_oprs(0 To nextp - 1)
        
        If curveParams.IsFlag(CURVE_FLG_MULTIOBS) Then
            Call CCurveType.CreateContents(curveParams.curveTypes)
        End If
    
        If Not CDDXHelper.IsFlag(curveParams.flagValues, CURVE_FLG_PIVOT) Then
            Call TSChangeRange(dtaRgn, curveParams)
        Else
            Call TSChangeRangeTRANS(dtaRgn, curveParams)
        End If
    End If
    
OOPS:
    If filnum > 0 Then
        Close filnum
    End If
End Sub

Private Sub TSSortOprDates()
 Dim tmp As TOprTS
 Dim i As Long
 Dim j As Long
 Dim n As Long
 Dim r As Long
 
    ReDim m_ts_sored(LBound(m_ts_oprs) To UBound(m_ts_oprs))
    
    For i = LBound(m_ts_oprs) To UBound(m_ts_oprs)
        m_ts_sorted(i) = m_ts_oprs(i)
    Next
    
    For i = LBound(m_ts_sorted) To UBound(m_ts_sorted) - 1
        n = i
        For j = i + 1 To UBound(m_ts_sored)
            r = CCurveDates.CompareDoubles(m_ts_sorted(n).oprDate, m_ts_sorted(j).oprDate)
            If r > 0 Then
                n = j
            ElseIf r = 0 Then
                If StrComp(m_ts_sorted(n).curveType, m_ts_sorted(j).curveType, vbBinaryCompare) > 0 Then
                    n = j
                End If
            End If
        Next
        If n <> i Then
            tmp = m_ts_sorted(i)
            m_ts_sorted(i) = m_ts_sorted(n)
            m_ts_sorted(n) = tmp
        End If
    Next
End Sub

Private Function TSFindOprDate(ByVal startidx As Long, ByVal endidx As Long, item As TOprTS) As Long
 Dim m As Long
 Dim r As Long
 
    If startidx > endidx Then
        TSFindOprDate = -1
        Exit Function
    End If
    
    m = startidx + (endidx - startidx) \ 2
    r = CCurveDates.CompareDoubles(item.oprDate, m_ts_sorted(m).oprDate)
    
    If r = 0 Then
        r = StrComp(item.curveType, m_ts_sorted(m).curveType, vbBinaryCompare)
    End If
    
    If r = 0 Then
        TSFindOprDate = m
    ElseIf r > 0 Then
        TSFindOprDate = TSFindOprDate(m + 1, endidx, item)
    Else
        TSFindOprDate = TSFindOprDate(startidx, m + 1, item)
    End If
End Function

Private Sub TSChangeRange(dtaRgn As range, curveParams As CCurveParams)
 Dim p As Long
 Dim k As Long
 Dim v As Variant
 Dim ct() As String
 Dim delcnt As Long
 
    v = dtaRgn.offset(1).Resize(dtaRgn.rows.count - 1, 1).Value2
    If (VarType(v) And vbArray) = 0 Then
        ReDim m_ary(0)
        m_ary(0).oprDate = CCurveDates.contractDate(curveParams.granularities, CDate(v))
    Else
        ReDim m_ary(0 To UBound(v, 1) - 1)
        For k = LBound(v, 1) To UBound(v, 1)
            m_ary(k - 1).oprDate = CCurveDates.contractDate(curveParams.granularities, CDate(v(k, 1)))
        Next
    End If

    If curveParams.IsFlag(CURVE_FLG_MULTIOBS) Then
        ct = CCurveDates.CurveTypeList
        For k = LBound(m_ary) To UBound(m_ary)
            m_ary(k).curveType = ct(k)
        Next
    End If
    
    Call TSSortOprDates

'delete rows
    delcnt = 0
    
    For k = UBound(m_ary) To LBound(m_ary)
        If TSFindOprDate(LBound(m_ts_sorted), UBound(m_ts_sorted), m_ts_inputs(k)) < 0 Then
            With dtaRgn.offset(k + IIf(curveParams.IsFlag(CURVE_FLG_MULTIOBS), 2, 1)).Resize(1)
                Call .Delete(shift:=xlShiftUp)
            End With
            delcnt = delcnt + 1
        End If
    Next
End Sub

Private Sub TSChangeRangeTRANS(dtaRgn As range, curveParams As CCurveParams)
 Dim p As Long
 Dim k As Long
 Dim v As Variant
 Dim rgn As range
 
    p = curveParams.PropertyCount
    If p > 0 Then
        Set dtaRgn = dtaRgn.offset(, p).Resize(1, dtaRgn.Columns.count - p)
    End If
    
    v = dtaRgn.offset(, 1).Resize(1, dtaRgn.Columns.count - 1).Value2
    If (VarType(v) And vbArray) = 0 Then
        ReDim m_ary(0)
        m_ary(0).oprDate = CCurveDates.contractDate(curveParams.granularities, CDate(v))
    Else
        ReDim m_ary(0 To UBound(v, 2) - 1)
        For k = LBound(v, 2) To UBound(v, 2)
            m_ary(k - 1).oprDate = CCurveDates.contractDate(curveParams.granularities, CDate(v(1, k)))
        Next
    End If
    
    'delete columns
    For p = UBound(m_ary) To LBound(m_ary) Step -1
        For k = LBound(m_ts_oprs) To UBound(m_ts_oprs)
            If CCurveDates.CompareDoubles(m_ts_inputs(p).oprDate, m_ts_oprs(k).oprDate) = 0 Then Exit For
        Next
        
        If k > UBound(m_ts_oprs) Then
            Set rgn = dtaRgn.offset(, p + 1).Resize(, 1)
            Call rgn.EntireColumn.Delete
            m_ts_inputs(p).oprDate = 0
        End If
    Next
End Sub

Public Function GetDefaultGranularityNCurveType(ByVal curveNm As String, granuVal As Long, curveTypeNM As String) As Boolean
 Dim v() As String
 
    On Error GoTo OOPS
    
    v = CDDXLib.DefaultZEWSProxy(DDX_PID).GetCurveInfo(CDDXLogin.sid, curveNm, CURVE_INFO_FLD_6_GRANULARITY_N_CURVETYPE)
    granuVal = Val(v(0))
    curveTypeNM = v(1)
    
    GetDefaultGranularityNCurveType = True

OOPS:
    If Err.Number <> 0 Then
        CDDXApp.StatusMessage = Err.Description
    End If
    
    On Error GoTo 0
    Exit Function
End Function

Public Sub ResetAfterUploaded(params As CCurveParams, data As ZEWSProxy.ICurveResult)
 Dim k As Long
 Dim j As Long
 Dim ra() As ZEWSProxy.CurveInsertUpdateResult
 Dim curves() As String
 Dim uploaded() As Long
 Dim fc As range
 
    On Error GoTo OOPS
    
    If Len(data.Error) <> 0 Or data.Cancelled Then Exit Sub
    
    curves = params.curves
    ReDim uploaded(LBound(curves) To UBound(curves))
    
    ra = data.UploadResult
    For k = LBound(ra) To UBound(ra)
        With ra(k)
            For j = LBound(curves) To UBound(curves)
                If StrComp(curves(j), .curveName, vbBinaryCompare) = 0 Then
                    uploaded(j) = IIf(.numRecordsDeleted = 0 And .numRecordsInserted = 0 And .numRecordsUpdated = 0, 1, 10)
                    Exit For
                End If
            Next
        End With
    Next

'    For k = LBound(uploaded) To UBound(uploaded)
'        If uploaded(k) = 10 Then
'            Call GetAreas(k)
'            m_dataRgn.Font.ColorIndex = xlColorIndexAutomatic'CURVE_DATA_CLR_IDX
'        End If
'    Next
    
    Erase uploaded
    Call GetAreas(-1)

    For k = 1 To 2
        With Application.FindFormat
            .Clear
            .Font.ColorIndex = IIf(k = 1, CURVE_CHANGE_CLR_IDX, CURVE_ERROR_CLR_IDX)
        End With
    
        Set fc = m_dataRgn.Find(what:=vbNullString, After:=m_dataRgn.Cells(1, 1), _
            LookIn:=xlFormulas, LookAt:=xlPart, _
            SearchOrder:=xlByRows, SearchDirection:=xlNext, _
            MatchCase:=False, SearchFormat:=True)
        If Not fc Is Nothing Then Exit For
    Next
    
    If k > 2 Then
        m_contractRgn.Font.ColorIndex = xlColorIndexAutomatic 'CURVE_DATA_CLR_IDX
        If params.IsFlag(CURVE_FLG_MULTIOBS) Then
            m_contractRgn.offset(, 1).Resize(, IIf(params.IsFlag(CURVE_FLG_TIMESERIES), 1, 2)).Font.ColorIndex = xlColorIndexAutomatic 'CURVE_DATA_CLR_IDX
        End If
    End If
    
OOPS:
    If Err.Number <> 0 Then
        Call CDDXHelper.LogError(Err.Description, "ResetAfterUploaded")
    End If
    
    Call HideProgressBox
    Exit Sub
End Sub

Public Function IsSheetGrouped(sht As Worksheet) As Boolean
 Dim k As Long
 
     With GetWnd(sht)
        If .SelectedSheets Is Nothing Then Exit Function
        If .SelectedSheets.count <= 1 Then Exit Function
        
        For k = 1 To .SelectedSheets.count
            If StrComp(.SelectedSheets(k).name, sht.name) = 0 Then
                CDDXApp.StatusMessage = "Grouped sheet :  " + sht.name
                IsSheetGrouped = True
                Exit For
            End If
        Next
    End With
End Function

Public Function AddApostrophe(str As String) As String
 Dim c As String
 
    If Len(str) = 0 Then
        AddApostrophe = str
    Else
        If left(str, 1) = "'" Then
            AddApostrophe = "'" + str
        Else
            c = left(str, 1)
            If c = "=" Or c = "+" Or c = "-" Or c = "." Or c = "@" Or (c >= "0" And c <= "9") Then
                AddApostrophe = "'" + str
            Else
                AddApostrophe = str
            End If
        End If
    End If
End Function

Private Property Get CurveFilePath() As String
    CurveFilePath = CDDXLib.DefaultZEWSProxy(DDX_PID).HelperResultsetFileName(CSheet.ZESheetID(ActiveSheet), 0)
End Property

Private Property Get CurveCommentFilePath() As String
    CurveCommentFilePath = CurveFilePath + ".comment"
End Property

Public Function GetAccessTimeToDraw(params As CCurveParams, ByVal aIndex As Long, ByRef aIsDownload As Boolean, ByRef timeVal As Double) As Boolean
 Dim dlt As Double
 Dim ult As Double
 Dim dltstr As String
 Dim ultstr As String
 
    On Error GoTo OOPS
    
    Call params.GetCurveAccessTimes(aIndex, dltstr, ultstr)
 
    dlt = CDbl(CCurveDates.ToLocalDate(dltstr))

    If ultstr <> vbNullString Then
        ult = CDbl(CCurveDates.ToLocalDate(ultstr))
    Else
        If Not aIsDownload Then Exit Function
    End If
    
    aIsDownload = (dlt > ult)
    timeVal = IIf(aIsDownload, dlt, ult)
    
    GetAccessTimeToDraw = (timeVal > 1)
    
OOPS:
    Exit Function
End Function

Public Sub DrawAccessTime(rgn As range, tv As Double, aIsDownload As Boolean, halign As Variant)
    With rgn
        .NumberFormat = "@"
        .Font.size = 8
        .HorizontalAlignment = halign
        .VerticalAlignment = xlCenter
        .value = CCurveDates.DisplayTime(CDate(tv), True)
        .Font.ColorIndex = IIf(aIsDownload, 10, 21) '56 '16
    End With
End Sub

Private Property Get VRFilePath() As String
    VRFilePath = CurveFilePath + ".vrs"
End Property

Public Function VRColorValues(ByVal fname As String, datargn As range, curveParams As CCurveParams, ByVal forUpload As Boolean) As Boolean
 Dim buff As String
 Dim file As Object
 Dim f() As String
 Dim k As Long
 Dim cl As Long
 Dim rw As Long
 Dim clrnum As Long
 Dim errNum As String
 Dim errmsg As String
 Dim tmp As Long
 
    VRColorValues = True
    
    On Error GoTo OOPS
    
    If forUpload Then
        Call VRRestoreToNoneColor(datargn, CURVE_VR_COLOR_ERR)
        Call VRRestoreToNoneColor(datargn, CURVE_VR_COLOR_WARNING)
        Call VRRestoreToNoneColor(datargn, CURVE_VR_COLOR_UNVALIDATED)
    Else
        datargn.Interior.color = xlNone
    End If
    
    If Len(fname) = 0 Then fname = VRFilePath
    If Not CDDXHelper.FileThere(fname) Then
        'Call CCPVRStorage.DeleteCurve(ActiveSheet, vbNullString) 'fool-proof
        Exit Function
    End If
    
    Set file = CDDXFile.OpenFile(fname)
    
    errNum = file.ReadText(-2)
    errmsg = file.ReadText(-2)
    
    If errNum = vbNullString Then
        'curves that have no vr info
        Do
            If file.EOS() Then Exit Do
            buff = file.ReadText(-2)
            If Len(buff) = 0 Then Exit Do
            
            Call CCPVRStorage.DeleteCurve(ActiveSheet, buff)
        Loop
            
        'curves that have vr info
        Do
            If file.EOS() Then Exit Do
            buff = file.ReadText(-2)
            If Len(buff) = 0 Then Exit Do
            f = Split(buff, vbTab)

            Call CCPVRStorage.AddCurve(ActiveSheet, f(0), f(1))
        Loop
        
        'to color cells
        Do
            If file.EOS() Then Exit Do
            buff = file.ReadText(-2)
            If Len(buff) = 0 Then Exit Do
            f = Split(buff, vbTab)
            
            rw = Int(Val(f(0)))

            For k = 1 To UBound(f)
                cl = Int(Val(f(k)))
                clrnum = cl And &HF
                cl = cl \ &H10
                
                If curveParams.IsFlag(CURVE_FLG_PIVOT) Then
                    tmp = rw
                    rw = cl
                    cl = tmp
                Else
                    If curveParams.IsFlag(CURVE_FLG_MRBD) Then cl = 2 * cl
                End If
                
                With datargn.Cells(rw, cl)
                    .Interior.color = Switch(clrnum = CURVE_SON_ERROR, CURVE_VR_COLOR_ERR, _
                                                                   clrnum = CURVE_SON_WARNING, CURVE_VR_COLOR_WARNING, _
                                                                   clrnum = CURVE_SON_UNVALIDATED, CURVE_VR_COLOR_UNVALIDATED, _
                                                                   True, CURVE_VR_COLOR_UNSUPPORTED)
                    .Font.Bold = False
                End With
                
                If curveParams.IsFlag(CURVE_FLG_PIVOT) Then rw = cl
            Next
        Loop
    End If
    
OOPS:
    If Err.Number <> 0 Then
        If Len(errmsg) = 0 Then errmsg = Err.Description
        Call CDDXHelper.LogError(Err.Description, "ReadVRFile")
    End If
    
    Call CDDXFile.CloseFile(file, fname, buff)
    Set file = Nothing
    
    If errmsg <> vbNullString Then
        CDDXApp.StatusMessage = errmsg
        VRColorValues = False
    End If
    
    Exit Function
End Function

Private Function AcceptFuturesRange(ByVal flgs As Long, file As Object, ByVal acceptTarget As Long, ByVal cvrName As String, ByVal oprDate As Long) As Long()
 Dim cvrs() As String
 Dim oprs() As Double
 Dim k As Long
 Dim n As Long
 Dim vr As Variant
 Dim Indice() As Long
 Dim size As Long
 '
 Dim crvname As String
 Dim odte As Double
 Dim cdte As Double
 Dim ctname As String
 Dim gname As Variant
 '
 Dim r As Long
 Dim c As Long
 Dim s As Long
 
    oprs = CCurveDates.EffectiveDateList
    
'curve names
    cvrs = CCurveDates.ParamEntity.curves
    Call CDDXFile.WriteLine(file, cvrs(0), True)
    
'opr dates
    size = 0
    If oprDate = 0 Then
        vr = CCPVRStorage.GetVR(ActiveSheet, CURVE_VR_L_DATAPOINT_OPRS, cvrs(0), 0, 0, 0, vbNullString, vbNullString)
        If IsEmpty(vr) Then Exit Function
            
        ReDim Indice(LBound(vr) To UBound(vr))
        
        For n = LBound(vr) To UBound(vr)
            For k = LBound(oprs) To UBound(oprs)
                If Int(Val(vr(n))) = Int(oprs(k)) Then
                    Indice(size) = k
                    size = size + 1
                    Exit For
                End If
            Next
        Next
        
    Else
        ReDim Indice(0 To 0)

        For k = LBound(oprs) To UBound(oprs)
            If oprDate = Int(oprs(k)) Then
                Indice(0) = k
                size = 1
                Exit For
            End If
        Next
    End If
    
    If size = 0 Then Exit Function
    
    size = size - 1
    ReDim Preserve Indice(0 To size)
    
    If acceptTarget = CURVE_EL_CURVETYPE Then
        For k = 0 To size
            Call CDDXFile.WriteLine(file, CStr(Int(oprs(Indice(k)))), True)
        Next
    Else
        Call GetAreas(Indice(k))

        With m_dataRgn
            For r = 1 To .rows.count
                For c = 1 To .Columns.count
                    Call GetValuesByCell(.Cells(r, c), crvname, odte, cdte, ctname, gname)
                    
                    If r = 1 And c = 1 Then
                        Call CDDXFile.WriteLine(file, CStr(odte), True)
                    End If
                    
                    vr = CCPVRStorage.GetVR(ActiveSheet, IIf(acceptTarget = CURVE_EL_CURVETYPE, CURVE_VR_L_OBSERVATION, CURVE_VR_L_DATAPOINT), crvname, 0, oprDate, cdte, ctname, gname)
                    
                    If Not IsEmpty(vr) Then
                        For s = 0 To UBound(vr) Step IIf(acceptTarget = CURVE_EL_CURVETYPE, CURVE_VR_SIZE_OBSERVATION, CURVE_VR_SIZE_DATAPOINT)
                            Select Case CDDXCurve.GetVRSON(vr(s + CURVE_VR_POS_STATUS))
                                Case CURVE_SON_ERROR, CURVE_SON_WARNING, CURVE_SON_UNVALIDATED:
                                    Call CDDXFile.WriteLine(file, CStr(vr(s + CURVE_VR_POS_CURVETYPE)) + vbTab + CStr(cdte) + vbTab + CStr(CCurveGranularity.GetGranularity(CStr(gname))) + vbTab, True)
                                    Exit For
                            End Select
                        Next
                    End If
                Next
            Next
        End With
    End If
    
    AcceptFuturesRange = Indice
End Function

Private Function AcceptFutures(ByVal flgs As Long, file As Object, ByVal acceptTarget As Long, ByVal cvrName As String, ByVal oprDate As Long) As Long()
 Dim cvrs() As String
 Dim oprs() As Double
 Dim k As Long
 Dim vr As Variant
 Dim Indice() As Long
 Dim size As Long
 '
 Dim crvname As String
 Dim odte As Double
 Dim cdte As Double
 Dim ctname As String
 Dim gname As Variant
 '
 Dim r As Long
 Dim c As Long
 Dim s As Long
 
    oprs = CCurveDates.EffectiveDateList

'curve names
    cvrs = CCurveDates.ParamEntity.curves
    oprDate = Int(CDbl(CCurveDates.ParamEntity.OprStartDate))
    size = 0
    
    If Len(cvrName) > 0 Then
        ReDim Indice(0 To 0)
        
        For k = LBound(cvrs) To UBound(cvrs)
            If StrComp(cvrs(k), cvrName) = 0 Then
                Indice(0) = k
                size = 1
                Exit For
            End If
        Next

    Else
        ReDim Indice(LBound(cvrs) To UBound(cvrs))

        For k = LBound(cvrs) To UBound(cvrs)
            vr = CCPVRStorage.GetVR(ActiveSheet, CURVE_VR_L_CURVE, cvrs(k), 0, oprDate, 0, vbNullString, vbNullString)
            If ContainsStatusToAccept(vr) Then
                Indice(size) = k
                size = size + 1
            End If
        Next
    End If
    
    If size = 0 Then Exit Function
    
    size = size - 1
    ReDim Preserve Indice(0 To size)

    ' curve name -> [opr date -> [curve type -> contract date -> granularity]]
    
    For k = 0 To size
        If k > 0 Then
            Call CDDXFile.WriteLine(file, vbNullString, True)
        End If
        
        Call CDDXFile.WriteLine(file, cvrs(Indice(k)), True)
        
        If acceptTarget = CURVE_EL_CURVE Then
            Call CDDXFile.WriteLine(file, CStr(oprDate), True)
        
        Else
            Call GetAreas(Indice(k))

            With m_dataRgn
                For r = 1 To .rows.count
                    For c = 1 To .Columns.count
                        Call GetValuesByCell(.Cells(r, c), crvname, odte, cdte, ctname, gname)
                        
                        If r = 1 And c = 1 Then
                            Call CDDXFile.WriteLine(file, CStr(odte), True)
                        End If
                        
                        vr = CCPVRStorage.GetVR(ActiveSheet, IIf(acceptTarget = CURVE_EL_CURVETYPE, CURVE_VR_L_OBSERVATION, CURVE_VR_L_DATAPOINT), crvname, flgs, oprDate, cdte, ctname, gname)
                        
                        If Not IsEmpty(vr) Then
                            For s = 0 To UBound(vr) Step IIf(acceptTarget = CURVE_EL_CURVETYPE, CURVE_VR_SIZE_OBSERVATION, CURVE_VR_SIZE_DATAPOINT)
                                Select Case CDDXCurve.GetVRSON(vr(s + CURVE_VR_POS_STATUS))
                                    Case CURVE_SON_ERROR, CURVE_SON_WARNING, CURVE_SON_UNVALIDATED:
                                        Call CDDXFile.WriteLine(file, CStr(vr(s + CURVE_VR_POS_CURVETYPE)) + vbTab + CStr(cdte) + vbTab + CStr(CCurveGranularity.GetGranularity(CStr(gname))) + vbTab, True)
                                        Exit For
                                End Select
                            Next
                        End If
                    Next
                Next
            End With
        End If
    Next
    
    AcceptFutures = Indice
End Function

Private Function AcceptTimeSeries(ByVal flgs As Long, file As Object, ByVal acceptTarget As Long, ByVal cvrName As String, ByVal oprDate As Long) As Long()
 Dim cvrs() As String
 Dim oprs() As Double
 Dim k As Long
 Dim j As Long
 Dim n As Long
 Dim vr As Variant
 Dim Indice() As Long
 Dim size As Long
 '
 Dim crvname As String
 Dim odte As Double
 Dim cdte As Double
 Dim ctname As String
 Dim gname As Variant
 '
 Dim r As Long
 Dim c As Long
 Dim s As Long
 
    oprs = CCurveDates.ContractDateList
    If CDDXUtility.IsArrayEmpty(oprs) Then Exit Function

'curve names
    cvrs = CCurveDates.ParamEntity.curves
    
    size = 0
    
    If Len(cvrName) > 0 Then
        ReDim Indice(0 To 0)
        
        For k = LBound(cvrs) To UBound(cvrs)
            If StrComp(cvrs(k), cvrName) = 0 Then
                Indice(0) = k
                size = 1
                Exit For
            End If
        Next

    Else
        ReDim Indice(LBound(cvrs) To UBound(cvrs))

        For k = LBound(cvrs) To UBound(cvrs)
            vr = CCPVRStorage.GetVR(ActiveSheet, CURVE_VR_L_CURVE, cvrs(k), 0, oprDate, 0, vbNullString, vbNullString)
            If ContainsStatusToAccept(vr) Then
                Indice(size) = k
                size = size + 1
            End If
        Next
    End If
    
    If size = 0 Then Exit Function
    
    size = size - 1
    ReDim Preserve Indice(0 To size)
    
'opr dates
    ' [curve name -> [opr date -> curve type]]
    
    For k = 0 To size
        If k > 0 Then
            Call CDDXFile.WriteLine(file, vbNullString, True)
        End If
        
        Call CDDXFile.WriteLine(file, cvrs(Indice(k)), True)
        
        If acceptTarget = CURVE_EL_CURVE Then
            If oprDate <> 0 Then
                Call CDDXFile.WriteLine(file, CStr(oprDate), True)
            Else
                vr = CCPVRStorage.GetVR(ActiveSheet, CURVE_VR_L_DATAPOINT_OPRS, cvrs(Indice(k)), flgs, 0, 0, vbNullString, vbNullString)
                If Not IsEmpty(vr) Then
                    For j = LBound(vr) To UBound(vr)
                        
                        For n = LBound(oprs) To UBound(oprs)
                            If CLng(vr(j)) = Int(oprs(n)) Then Exit For
                        Next
                        If n <= UBound(oprs) Then
                            Call CDDXFile.WriteLine(file, CStr(vr(j)), True)
                        End If
                    Next
                End If
            End If
        Else
            Call GetAreas(Indice(k))

            With m_dataRgn
                For r = 1 To .rows.count
                    For c = 1 To .Columns.count
                        Call GetValuesByCell(.Cells(r, c), crvname, odte, cdte, ctname, gname)

                        vr = CCPVRStorage.GetVR(ActiveSheet, IIf(acceptTarget = CURVE_EL_CURVETYPE, CURVE_VR_L_OBSERVATION, CURVE_VR_L_DATAPOINT), cvrs(Indice(k)), flgs, odte, cdte, ctname, gname)
                        If Not IsEmpty(vr) Then
                            For s = 0 To UBound(vr) Step IIf(acceptTarget = CURVE_EL_CURVETYPE, CURVE_VR_SIZE_OBSERVATION, CURVE_VR_SIZE_DATAPOINT)
                                Select Case CDDXCurve.GetVRSON(vr(s + CURVE_VR_POS_STATUS))
                                    Case CURVE_SON_ERROR, CURVE_SON_WARNING, CURVE_SON_UNVALIDATED:
                                        Call CDDXFile.WriteLine(file, CStr(odte) + vbTab + CStr(vr(s + CURVE_VR_POS_CURVETYPE)) + vbTab, True)
                                        Exit For
                                End Select
                            Next
                        End If
                    Next
                Next
            End With
        End If
    Next

    AcceptTimeSeries = Indice
End Function

Private Sub ResetAcceptedCommentByClr(rgn As range, clrVal As Long, commentText As String)
 Dim fc As range
 Dim cc As range
 Dim cmt As Comment
 
    With Application.FindFormat
        .Clear
        '.Interior.ColorIndex = clrIdx
        .Interior.color = clrVal
    End With

    Set fc = rgn.Find(what:=vbNullString, SearchFormat:=True)
        
    Set cc = fc
    Do
        If cc Is Nothing Then Exit Do
        
        cc.Interior.ColorIndex = xlNone
        
        Set cmt = cc.Comment
        If cmt Is Nothing Then
             Set cmt = cc.AddComment(commentText)
             cmt.Shape.TextFrame.AutoSize = True
'        Else
'            cmt.Text commentText
        End If
    
        Set cc = rgn.Find(what:=vbNullString, After:=cc, SearchFormat:=True)
            
        If cc Is Nothing Then Exit Do
        If cc.Address = fc.Address Then Exit Do
    Loop
End Sub

Private Sub ResetAcceptedComment(rgn As range, commentText As String)
    Call ResetAcceptedCommentByClr(rgn, CURVE_VR_COLOR_ERR, commentText)
    Call ResetAcceptedCommentByClr(rgn, CURVE_VR_COLOR_WARNING, commentText)
    Call ResetAcceptedCommentByClr(rgn, CURVE_VR_COLOR_UNVALIDATED, commentText)
End Sub

Private Sub DeleteAcceptButton(altText As String)
 Dim shp As Shape

    For Each shp In ActiveSheet.Shapes
        With shp
            If StrComp(.AlternativeText, altText) = 0 Then
                .Delete
                Exit For
            End If
        End With
    Next
End Sub

Private Function AcceptedTimeSeries(ByVal curveFlgs As Long, Indice() As Long, ByVal oprDate As Long, commentText As String, ByVal acceptTarget As Long) As String
 Dim cvrs() As String
 Dim k As Long
 Dim ind As Long
 Dim oprs() As Double
 Dim r As Long
 Dim cc As range
 Dim cmt As Comment
 Dim ns As Long
 
    cvrs = CCurveDates.ParamEntity.curves
    oprs = CCurveDates.ContractDateList

    For k = LBound(Indice) To UBound(Indice)
        ind = Indice(k)
        
        Call CCPVRStorage.OnAcceptCurveEx(ActiveSheet, acceptTarget, cvrs(ind), oprDate)

        Call GetAreas(ind)
        
        If acceptTarget <> CURVE_EL_CURVE Then
            ns = CCPVRStorage.GetErrLevels(ActiveSheet, cvrs(ind), 0)
            If (ns And CURVE_EL_CURVETYPE) = 0 And (ns And CURVE_EL_RECORD) = 0 Then ns = CURVE_EL_CURVE
        Else
            ns = CURVE_EL_CURVE
        End If
        
        If ns = CURVE_EL_CURVE Then
            If oprDate = 0 Then
                Call ResetAcceptedComment(m_dataRgn, commentText)
            Else
                For r = LBound(oprs) To UBound(oprs)
                    If Int(oprs(r)) = oprDate Then
                        If CDDXHelper.IsFlag(curveFlgs, CURVE_FLG_PIVOT) Then
                            Set cc = m_dataRgn.Cells(1, r + 1)
                        Else
                            Set cc = m_dataRgn.Cells(r + 1, 1)
                        End If
                        
                        cc.Interior.ColorIndex = xlNone
                        
                        Set cmt = cc.Comment
                        If cmt Is Nothing Then
                             Set cmt = cc.AddComment(commentText)
                             cmt.Shape.TextFrame.AutoSize = True
    '                    Else
    '                        cmt.Text commentText
                        End If
                    End If
                Next
            End If
        End If
    Next
    
    If acceptTarget <> CURVE_EL_CURVE Then
        Call VRRestoreColors
    End If
End Function


Private Function AcceptedFutures(ByVal curveFlgs As Long, Indice() As Long, commentText As String, ByVal acceptTarget As Long) As String
 Dim cvrs() As String
 Dim k As Long
 Dim ind As Long
 Dim ns As Long
 
    cvrs = CCurveDates.ParamEntity.curves

    For k = LBound(Indice) To UBound(Indice)
        ind = Indice(k)
        
        Call CCPVRStorage.OnAcceptCurveEx(ActiveSheet, acceptTarget, cvrs(ind), 0)
        
        If acceptTarget <> CURVE_EL_CURVE Then
            ns = CCPVRStorage.GetErrLevels(ActiveSheet, cvrs(ind), 0)
            If (ns And CURVE_EL_CURVETYPE) = 0 And (ns And CURVE_EL_RECORD) = 0 Then ns = CURVE_EL_CURVE
        Else
            ns = CURVE_EL_CURVE
        End If
        
        If ns = CURVE_EL_CURVE Then
            Call DeleteAcceptButton(GetAltText(cvrs(ind), AT_ACCEPT))
            With CCurveDates.Handler
                If CDDXCurve.GetSheetVersion(curveFlgs) >= CDDXCurve.GetSheetVersion(CURVE_FLG_V2) Then
                    Call .DrawVR(cvrs(ind), ind)
                Else
                    Call .DrawVR(ind)
                End If
            End With
            Call GetAreas(ind)
            
            Call ResetAcceptedComment(m_dataRgn, commentText)
        End If
    Next
    
    If acceptTarget <> CURVE_EL_CURVE Then
        Call VRRestoreColors
    End If
End Function

Private Function AcceptedFuturesRange(ByVal curveFlgs As Long, Indice() As Long, ByVal oprDate As Long, commentText As String, ByVal acceptTarget As Long) As String
 Dim cvrs() As String
 Dim oprs() As Double
 Dim k As Long
 Dim ind As Long
 Dim rgn As range
 Dim ns As Long
 
    cvrs = CCurveDates.ParamEntity.curves
    oprs = CCurveDates.EffectiveDateList
'
    Call CCPVRStorage.OnAcceptCurveEx(ActiveSheet, acceptTarget, cvrs(0), oprDate)
    Call GetAreas(-1)
    
    For k = LBound(Indice) To UBound(Indice)
        ind = Indice(k)
        
        If acceptTarget <> CURVE_EL_CURVE Then
            ns = CCPVRStorage.GetErrLevels(ActiveSheet, cvrs(0), oprs(ind))
            If (ns And CURVE_EL_CURVETYPE) = 0 And (ns And CURVE_EL_RECORD) = 0 Then ns = CURVE_EL_CURVE
        Else
            ns = CURVE_EL_CURVE
        End If
        
        If ns = CURVE_EL_CURVE Then
            Call DeleteAcceptButton(GetAltTextDateRange(oprs(ind)))
            Call CCurveDates.Handler.DrawVR(ind)
            
            Set rgn = m_dataRgn.offset(, ind).Resize(, 1)
            Call ResetAcceptedComment(rgn, commentText)
        End If
    Next
    
    If acceptTarget <> CURVE_EL_CURVE Then
        Call VRRestoreColors
    End If
End Function

Public Function VRAccept(ByVal acceptTarget As Long, ByVal cvrName As String, ByVal oprDate As Long, ByVal commentText As String) As String
 Dim fname As String
 Dim Indice() As Long
 Dim file As Object
 Dim msg As String
 Dim flgs As Long
 
    On Error GoTo OOPS
    
    fname = CDDXLib.DefaultZEWSProxy(DDX_PID).HelperResultsetFileName(CDDXLib.DefaultZEWSProxy(DDX_PID).NewGUID(), 0)
    Set file = CDDXFile.OpenWriteStream()

    flgs = CDDXCurve.GetFVS(ActiveSheet)
    Call CDDXFile.WriteLine(file, CStr(flgs), True)

    If CDDXHelper.IsFlag(flgs, CURVE_FLG_TIMESERIES) Then
        Indice = AcceptTimeSeries(flgs, file, acceptTarget, cvrName, oprDate)
    ElseIf CDDXHelper.IsFlag(flgs, CURVE_FLG_FUTURE_RANGE) Then
        Indice = AcceptFuturesRange(flgs, file, acceptTarget, cvrName, oprDate)
    Else
        Indice = AcceptFutures(flgs, file, acceptTarget, cvrName, oprDate)
    End If
    
    Call CDDXFile.SaveWriteStream(file, fname, msg)
    
    If CDDXUtility.IsArrayEmpty(Indice) Then Exit Function
    
    VRAccept = CDDXLib.DefaultZEWSProxy(DDX_PID).VRAccept(fname, acceptTarget, commentText, IIf(CDDXCurve.UploadWithProt And Not CDDXCurve.FourEyesActive, CURVE_OP_INSERT_PROT, 0))
    Call CDDXHelper.DeleteFile(fname)
    
    If Len(VRAccept) > 0 Then
        'Call CDDXApp.DialogMessage(VRAccept, vbExclamation Or vbOKOnly)
    Else
        'ActiveSheet.ProtectContents = True
        Call CXLEvents.DisableEvents
        Call Unprotect(ActiveSheet)

        If CDDXHelper.IsFlag(flgs, CURVE_FLG_TIMESERIES) Then
            Call AcceptedTimeSeries(flgs, Indice, oprDate, commentText, acceptTarget)
        ElseIf CDDXHelper.IsFlag(flgs, CURVE_FLG_FUTURE_RANGE) Then
            Call AcceptedFuturesRange(flgs, Indice, oprDate, commentText, acceptTarget)
        Else
            Call AcceptedFutures(flgs, Indice, commentText, acceptTarget)
        End If
        Call Protect(ActiveSheet)

        Set file = Nothing
        
        Call EraseAcceptAll
    End If
    
OOPS:
    If Err.Number <> 0 Then
        'Call CDDXApp.DialogMessage(Err.Description, vbExclamation Or vbOKOnly)
        VRAccept = Err.Description
    End If
    
    Call CDDXHelper.DeleteFile(fname)
    Call CXLEvents.RestoreEvents
    
    Exit Function
End Function

Public Function GetAltText(ByVal cvrName As String, ByVal promptText As String) As String
    GetAltText = IIf(cvrName = vbNullString, vbNullString, cvrName + " - ") + promptText
End Function

Public Function GetAltTextDateRange(ByVal oprDate As Double) As String
    GetAltTextDateRange = GetAltText(AT_ACCEPT, CStr(Int(oprDate)))
End Function

Public Function ContainsStatusToAccept(vr As Variant) As Boolean
 Dim k As Long
    
    If IsEmpty(vr) Then Exit Function
    
    If (VarType(vr) And vbArray) <> 0 Then
        For k = LBound(vr) To UBound(vr) Step CURVE_VR_SIZE_CURVE
            ContainsStatusToAccept = ContainsStatusToAccept(vr(k))
            If ContainsStatusToAccept Then Exit For
        Next
        
    Else
        Select Case VRGetColorIndex(vr)
            Case CURVE_VR_CLRIDX_ERR, CURVE_VR_CLRIDX_WARNING, CURVE_VR_CLRIDX_UNVALIDATED:
                ContainsStatusToAccept = True
                Exit Function
        End Select
    End If
End Function

Public Function ContainsStatusToAccept2(vr As Variant) As String
 Dim k As Long
 Dim tmp As Long
 Dim clr As Long
 
    For k = LBound(vr) To UBound(vr) Step CURVE_VR_SIZE_CURVE
        tmp = VRGetColorIndex(vr(k))
        
        If tmp = CURVE_VR_CLRIDX_ERR Then
            ContainsStatusToAccept2 = vr(k)
            Exit Function
        End If
        
        If tmp = CURVE_VR_CLRIDX_WARNING Or tmp = CURVE_VR_CLRIDX_UNVALIDATED Then
            If clr = 0 Or tmp = CURVE_VR_CLRIDX_WARNING Then
                clr = tmp
                ContainsStatusToAccept2 = vr(k)
            End If
        End If
    Next
End Function

Public Function ShowAcceptAll() As Boolean
 Dim cvrnms() As String
 Dim vr As Variant
 Dim k As Long
 
    If CCurveDates.ParamEntity.AllCurvesRD() Then Exit Function
    
    cvrnms = CCurveDates.ParamEntity.curves
    
    If CCurveDates.ParamEntity.IsFlag(CURVE_FLG_FUTURE_RANGE) Then
        vr = CCPVRStorage.GetVR(ActiveSheet, CURVE_VR_L_DATAPOINT_OPRS, cvrnms(0), 0, 0, 0, vbNullString, vbNullString)
        ShowAcceptAll = Not IsEmpty(vr)
    Else
        For k = LBound(cvrnms) To UBound(cvrnms)
            If CCurveDates.ParamEntity.IsFlag(CURVE_FLG_TIMESERIES) Then
                vr = CCPVRStorage.GetVR(ActiveSheet, CURVE_VR_L_DATAPOINT_OPRS, cvrnms(k), 0, 0, 0, vbNullString, vbNullString)
                ShowAcceptAll = Not IsEmpty(vr)
            Else
                ShowAcceptAll = ShowAccept(k)
            End If
            
            If ShowAcceptAll Then Exit For
        Next
    End If
End Function

Public Function ShowAccept(ByVal cvrIndex As Long) As Boolean
    ShowAccept = ContainsStatusToAccept(GetCurveVRValue(cvrIndex, CDbl(CCurveDates.ParamEntity.OprStartDate)))
End Function

Private Function GetCurveVRValue(ByVal cvrIndex As Long, ByVal oprDate As Double) As String
 Dim vr As Variant
 Dim cvrnms As Variant
 Dim oprs() As Double
 
    cvrnms = CCurveDates.ParamEntity.curves
    
    If CCurveDates.ParamEntity.IsFlag(CURVE_FLG_TIMESERIES) Then
        cvrnms = cvrnms(cvrIndex)
    Else
        If CCurveDates.ParamEntity.IsFlag(CURVE_FLG_FUTURE_RANGE) Then
            oprs = CCurveDates.EffectiveDateList
            
            oprDate = oprs(cvrIndex)
            cvrnms = cvrnms(0)
            'GetCurveVRValue = CCPVRStorage.GetStaticVR(ActiveSheet, CStr(cvrnms), oprDate)
        Else
            cvrnms = cvrnms(cvrIndex)
            'GetCurveVRValue = CCPVRStorage.GetStaticVR(ActiveSheet, CStr(cvrnms), oprDate)
        End If
    End If
'    GetCurveVRValue = CCPVRStorage.GetStaticVR(ActiveSheet, CStr(cvrnms), oprDate)
'    If Len(GetCurveVRValue) > 0 Then Exit Function

    vr = CCPVRStorage.GetVR(ActiveSheet, CURVE_VR_L_CURVE, cvrnms, CCurveDates.ParamEntity.flagValues, oprDate, 0, vbNullString, vbNullString)
    If Not IsEmpty(vr) Then
        GetCurveVRValue = CStr(vr(0))
    End If
End Function

Public Function VRGetColorIndex(ByVal vr As String) As Long
    If StrComp(vr, "Error", vbTextCompare) = 0 Then
        VRGetColorIndex = CURVE_VR_CLRIDX_ERR
    ElseIf StrComp(vr, "warning", vbTextCompare) = 0 Then
        VRGetColorIndex = CURVE_VR_CLRIDX_WARNING
    ElseIf StrComp(vr, "Not Validated", vbTextCompare) = 0 Then
        VRGetColorIndex = CURVE_VR_CLRIDX_UNVALIDATED
    ElseIf StrComp(vr, "accepted", vbTextCompare) = 0 Then
        VRGetColorIndex = CURVE_VR_CLRIDX_ACCEPTED
    ElseIf StrComp(vr, "correct", vbTextCompare) = 0 Then
        VRGetColorIndex = CURVE_VR_CLRIDX_CORRECT
    Else
        VRGetColorIndex = CURVE_VR_CLRIDX_UNSUPPORTED
    End If
End Function

Public Sub DrawCurveVR(ByVal cvrIndex As Variant, ByVal oprDate As Double, ByVal dispRow As Long, ByVal dispCol As Long, halign As Variant)
 Const VR_TXT As String = "Curve Validation:  "
 Dim vr As String
 Dim clr As Long
 
    If (VarType(cvrIndex) And vbString) <> 0 Then
        vr = CStr(cvrIndex)
    Else
        vr = GetCurveVRValue(cvrIndex, oprDate)
    End If
    
    With ActiveSheet.Cells(dispRow, dispCol)
        .NumberFormat = "@"
        .HorizontalAlignment = halign
        .VerticalAlignment = xlCenter
        
        If Len(vr) = 0 Then
            .value = vbNullString
        Else
            .value = VR_TXT + vr
            .Font.size = 8
            .Font.ColorIndex = 1
            With .Characters(Len(VR_TXT) + 1).Font
                clr = VRGetColorIndex(vr)
                .ColorIndex = Switch(clr = CURVE_VR_CLRIDX_ERR, 3, _
                                clr = CURVE_VR_CLRIDX_WARNING, 9, _
                                clr = CURVE_VR_CLRIDX_UNVALIDATED, 23, _
                                clr = CURVE_VR_CLRIDX_ACCEPTED, 10, _
                                True, 0)
                .Bold = True
            End With
        End If
    End With
End Sub

Public Function VRReadStorage(ByVal levelNum As Long) As Variant
 Dim crvname As String
 Dim odte As Double
 Dim cdte As Double
 Dim ctname As String
 Dim gname As Variant
 
    If Not GetValuesByCell(Application.ActiveCell, crvname, odte, cdte, ctname, gname) Then Exit Function

    VRReadStorage = CCPVRStorage.GetVR(CCurveDates.TargetSheet, levelNum, crvname, CCurveDates.ParamEntity.flagValues, odte, cdte, ctname, gname)
End Function

Public Function GetValuesByCell(target As range, ByRef curvName As String, ByRef oprDate As Double, ByRef contrDate As Double, ByRef cvrType As String, ByRef granName As Variant) As Boolean
 Dim col As Long
 Dim rw As Long
 Dim cnt As Long
 Dim tmp As Variant
 
'    Set target = Application.ActiveCell
    If target Is Nothing Then Exit Function
 
    Set CCurveDates.TargetSheet = ActiveSheet
    Call GetAreas(-1)
    
    col = target.column - m_curveRgn.column + 1
    curvName = m_curveRgn.Cells(1, col).value
    
    If CCurveDates.ParamEntity.IsFlag(CURVE_FLG_PIVOT) Then
        With target
            Call GetSplits(.Parent, CCurveDates.ParamEntity, rw, col)
            curvName = .Parent.Cells(.row, IIf(CDDXCurve.GetSheetVersion(CCurveDates.ParamEntity.flagValues) <= CDDXCurve.GetSheetVersion(CURVE_FLG_V1), col, 1)).value
            If CCurveDates.ParamEntity.IsFlag(CURVE_FLG_TIMESERIES) Then
                oprDate = .Parent.Cells(rw, .column).Value2
                'granName = CCurveDates.ParamEntity.granularities
            Else
                col = col + HoriWidthTRANS(CCurveDates.ParamEntity)
                oprDate = .Parent.Cells(.row, col).Value2
                If IsNumeric(.Parent.Cells(rw, .column).Value2) Then
                    contrDate = .Parent.Cells(rw, .column).Value2
                End If
            End If
        End With
    Else
        If CCurveDates.ParamEntity.IsFlag(CURVE_FLG_FUTURE_RANGE) Then
            tmp = CCurveDates.ParamEntity.curves
            curvName = tmp(0)
            
            col = target.column
            rw = target.row

            tmp = CCurveDates.EffectiveDateList
            If CCurveDates.ParamEntity.IsFlag(CURVE_FLG_MULTIOBS) Then
                oprDate = tmp(col - 4)
                contrDate = target.Parent.Cells(rw, 1).Value2
                granName = target.Parent.Cells(rw, 2).value
                cvrType = target.Parent.Cells(rw, 3).value
            Else
                oprDate = tmp(col - 3)
                contrDate = target.Parent.Cells(rw, 1).Value2
            End If
        Else
            If CCurveDates.ParamEntity.IsFlag(CURVE_FLG_MULTIOBS) Then
                cnt = IIf(CCurveDates.ParamEntity.IsFlag(CURVE_FLG_TIMESERIES), 2, 3)
            Else
                cnt = 1
            End If
            
            rw = target.row - m_contractRgn.row + 1
            
            If cnt = 1 Then
                If CCurveDates.ParamEntity.IsFlag(CURVE_FLG_TIMESERIES) Then
                    oprDate = m_contractRgn.Cells(rw, 1).Value2
                Else
                    oprDate = m_oprRgn.Cells(1, col).Value2
                    contrDate = m_contractRgn.Cells(rw, 1).Value2
                End If
            ElseIf cnt = 2 Then
                oprDate = m_contractRgn.Cells(rw, 1).Value2
                cvrType = m_contractRgn.Cells(rw, 2).value
                granName = CCurveDates.ParamEntity.granularities
            Else '3
                oprDate = m_oprRgn.Cells(1, col).Value2
                contrDate = m_contractRgn.Cells(rw, 1).Value2
                granName = m_contractRgn.Cells(rw, 2).value
                cvrType = m_contractRgn.Cells(rw, 3).value
            End If
        End If

    End If
    
    If CCurveDates.ParamEntity.IsFlag(CURVE_FLG_TIMESERIES) Then
        granName = CCurveDates.ParamEntity.granularities
    End If
    
    GetValuesByCell = True
End Function

Public Sub AddAcceptAll(imager As CCurveImageText)
    If Not ShowAcceptAll() Then Exit Sub
    Call AddAcceptAll2(imager)
End Sub

Public Sub AddAcceptAll2(imager As CCurveImageText)
    imager.AlternativeText = GetAltText(vbNullString, AT_ACCEPT_ALL)
    Call imager.Draw(OID_ACCEPT_ALL, vbNullString)
    imager.AlternativeText = vbNullString
End Sub

Public Sub EraseAcceptAll()
    If ShowAcceptAll() Then Exit Sub
    Call EraseAcceptAll2
End Sub

Public Sub EraseAcceptAll2()
 Dim alt As String
 Dim shp As Shape

    alt = GetAltText(vbNullString, AT_ACCEPT_ALL)
    
    For Each shp In ActiveSheet.Shapes
        With shp
            If StrComp(.AlternativeText, alt) = 0 Then
                Call .Delete
                Exit For
            End If
        End With
    Next
End Sub

Public Sub ClearAllImages(sht As Worksheet)
 Dim shp As Shape
 Dim tdel As Boolean
 
    On Error Resume Next
    
    For Each shp In sht.Shapes
        tdel = True
        If shp.FormControlType = xlDropDown Then tdel = False

        If tdel Then shp.Delete
        If Err.Number <> 0 Then Err.Clear
    Next
    
    On Error GoTo 0
End Sub

Private Sub SortAlts(alt() As String)
 Dim k As Long
 Dim endp As Long
 Dim p As Long
 Dim j As Long
 Dim tmp As String
 
    endp = UBound(alt)
    If endp = 0 Then Exit Sub
    
    For k = 0 To endp - 1
        p = k
        For j = k + 1 To endp
            If StrComp(alt(p), alt(j)) > 0 Then
                p = j
            End If
        Next
        
        If p <> k Then
            tmp = alt(k)
            alt(k) = alt(p)
            alt(p) = tmp
        End If
    Next
End Sub

Public Sub EraseAccepts(imager As CCurveImageText, ByVal cvrIdx As Long)
 Dim shp As Shape
 Dim cvrnms() As String
 Dim alt() As String
 Dim k As Long
 Dim oprs() As Double
 Dim startp As Long
 Dim endp As Long
 Dim rlt As Long
 Dim nm As String
 
    Set imager.sheet = ActiveSheet
    cvrnms = CCurveDates.ParamEntity.curves
    
    If cvrIdx >= 0 Then
        ReDim alt(0 To 1)
        
        alt(1) = GetAltText(cvrnms(cvrIdx), AT_ACCEPT)
    Else
        If CCurveDates.ParamEntity.IsFlag(CURVE_FLG_FUTURE_RANGE) Then
            oprs = CCurveDates.EffectiveDateList
            
            ReDim alt(0 To UBound(oprs) + 1)
            For k = LBound(oprs) To UBound(oprs)
                alt(k + 1) = GetAltTextDateRange(oprs(k))
            Next
        Else
            ReDim alt(0 To UBound(cvrnms) + 1)
            
            For k = LBound(cvrnms) To UBound(cvrnms)
                alt(k + 1) = GetAltText(cvrnms(k), AT_ACCEPT)
            Next
        End If
    End If
    alt(0) = GetAltText(vbNullString, AT_ACCEPT_ALL)
    
    Call SortAlts(alt)
    
    For Each shp In ActiveSheet.Shapes
        nm = shp.AlternativeText
        startp = LBound(alt)
        endp = UBound(alt)
        
        Do
            k = (startp + endp) \ 2
            
            rlt = StrComp(nm, alt(k))
            
            If rlt = 0 Then
                shp.Delete
                Exit Do
            End If
            
            If rlt < 0 Then
                endp = k - 1
            Else
                startp = k + 1
            End If
            
            If startp > endp Then Exit Do
        Loop
    Next
    
    Erase alt
    
    Call AddAcceptAll(imager)
End Sub

Public Sub DeleteCurveIcons(aCurveName As String, ParamArray alts() As Variant)
 Dim shp As Shape
 Dim texts() As String
 Dim k As Long
 
    ReDim texts(LBound(alts) To UBound(alts))
    
    For k = LBound(alts) To UBound(alts)
        texts(k) = GetAltText(aCurveName, alts(k))
    Next
    
    For k = LBound(alts) To UBound(alts)
        For Each shp In ActiveSheet.Shapes
            With shp
                If StrComp(.AlternativeText, texts(k)) = 0 Then
                    .Delete
                    Exit For
                End If
            End With
        Next
    Next
    
    Erase texts
    
    Call CCPVRStorage.DeleteCurve(ActiveSheet, aCurveName)
    Call EraseAcceptAll
End Sub

Public Sub DeleteCurveIconsByAlt(imageLib As Scripting.Dictionary, aCurveName As String, ParamArray alts() As Variant)
 Dim shp As Shape
 Dim txt As String
 Dim k As Long
 
    If aCurveName = vbNullString Then
        For Each shp In ActiveSheet.Shapes
            txt = shp.AlternativeText
            If txt <> vbNullString Then Call imageLib.Add(txt, shp)
        Next
        Exit Sub
    End If
    
    ReDim texts(LBound(alts) To UBound(alts))
    
    For k = LBound(alts) To UBound(alts)
        txt = GetAltText(aCurveName, alts(k))
        If imageLib.Exists(txt) Then
            imageLib(txt).Delete
        End If
    Next
End Sub

Public Sub DeleteCurveIconsByID(imager As CCurveImageText, ParamArray oid() As Variant)
 Dim k As Long
 
    For k = LBound(oid) To UBound(oid)
        Call imager.DeleteImage(oid(k))
    Next
End Sub

Public Function ValidateDates() As Boolean
    If Not ValidateOprDates() Then
        Call CDDXApp.DialogMessage(CDDXHelper.LastMessage, vbInformation Or vbOKOnly)
        Exit Function
    End If
    
    If Not ValidateContractDates() Then
        Call CDDXApp.DialogMessage(CDDXHelper.LastMessage, vbInformation Or vbOKOnly)
        Exit Function
    End If
   
    ValidateDates = True
End Function

Private Sub VRRestoreToNoneColor(rgn As range, ByVal clr As Long)
    If rgn Is Nothing Then Exit Sub
    
    On Error GoTo OOPS
    
    With Application.FindFormat
        .Clear
        .Interior.color = clr
    End With
    
    With Application.ReplaceFormat
        .Clear
        .Interior.ColorIndex = xlNone
    End With

    Call rgn.Replace(what:=vbNullString, replacement:=vbNullString, SearchFormat:=True, ReplaceFormat:=True)
    
OOPS:
    If Err.Number <> 0 Then
        CDDXApp.StatusMessage = "VRRestoreColorsWithNone: " + Err.Description
    End If
    Exit Sub
End Sub

Public Sub VRRestoreColors()
 Dim cvrs() As String
 Dim k As Long
 Dim flgs As Long
 Dim cxp As Object
 Dim opr As Double
 Dim vridx As Long
 Dim rwcnt As Long
 Dim rw As Long
 Dim col As Long
 Dim vr As Variant
 Dim oprdtes() As Double
 Dim tsoprs As Variant
 Dim o1 As Double
 Dim m As Long
                        
    With CCurveDates.ParamEntity
        flgs = .flagValues
        If CDDXCurve.VRReliableColros(flgs) Then Exit Sub
        cvrs = .curves
        oprdtes = CCurveDates.EffectiveDateList
    End With
    
    Call GetAreas(-1)
    If m_dataRgn Is Nothing Then Exit Sub
    
    Call VRRestoreToNoneColor(m_dataRgn, CURVE_VR_COLOR_ERR)
    Call VRRestoreToNoneColor(m_dataRgn, CURVE_VR_COLOR_WARNING)
    Call VRRestoreToNoneColor(m_dataRgn, CURVE_VR_COLOR_UNVALIDATED)
    
    rwcnt = m_dataRgn.rows.count
    
    If CDDXHelper.IsFlag(flgs, CURVE_FLG_TIMESERIES) Then
        For k = LBound(cvrs) To UBound(cvrs)
            tsoprs = CCPVRStorage.GetVR(ActiveSheet, CURVE_VR_L_DATAPOINT_OPRS, cvrs(k), flgs, 0, 0, vbNullString, 0)
            
            If Not IsEmpty(tsoprs) Then
                For m = LBound(tsoprs) To UBound(tsoprs)
                    tsoprs(m) = Int(Val(tsoprs(m)))
                Next
                
                Set cxp = CCPVRStorage.GetCXP(ActiveSheet, cvrs(k))
                If Not cxp Is Nothing Then
                    col = k + 1
                    For rw = 1 To rwcnt
                        o1 = m_contractRgn.Cells(rw, 1).Value2
                        For m = UBound(tsoprs) To 0 Step -1
                            If tsoprs(m) = Int(o1) Then Exit For
                        Next
                        
                        If m >= 0 Then
                            vridx = CCPVRStorage.GetDataPointVR(cxp, cvrs(k), flgs, o1, 0, m_contractRgn.Cells(rw, 2).Value2, CCurveDates.ParamEntity.granularities)
                            If vridx <> 0 Then
                                m_dataRgn.Cells(rw, col).Interior.color = vridx
                            End If
                        End If
                    Next
                End If
            End If
        Next
        
    Else
        If CDDXHelper.IsFlag(flgs, CURVE_FLG_FUTURE_RANGE) Then
            vr = CCPVRStorage.GetVR(ActiveSheet, CURVE_VR_L_DATAPOINT_OPRS, cvrs(0), 0, 0, 0, vbNullString, vbNullString)
            If IsEmpty(vr) Then Exit Sub
            
            Set cxp = CCPVRStorage.GetCXP(ActiveSheet, cvrs(0))
            If cxp Is Nothing Then Exit Sub
            
            For k = LBound(vr) To UBound(vr)
                For col = LBound(oprdtes) To UBound(oprdtes)
                    If Int(oprdtes(col)) = CLng(vr(k)) Then
                        opr = Int(oprdtes(col))
                        
                        If CCPVRStorage.RestoreNeeded(cxp, opr) Then
                            For rw = 1 To rwcnt
                                vridx = CCPVRStorage.GetDataPointVR(cxp, cvrs(0), flgs, opr, m_contractRgn.Cells(rw, 1).Value2, m_contractRgn.Cells(rw, 3).Value2, m_contractRgn.Cells(rw, 2).Value2)
                                If vridx <> 0 Then
                                    m_dataRgn.Cells(rw, col + 1).Interior.color = vridx
                                End If
                            Next
                        End If
                    End If
                Next
            Next
            
        Else
            For k = LBound(cvrs) To UBound(cvrs)
                Set cxp = CCPVRStorage.GetCXP(ActiveSheet, cvrs(k))
                If Not cxp Is Nothing Then
                    col = k + 1
                    opr = m_oprRgn.Cells(1, col).Value2
                    
                    If CCPVRStorage.RestoreNeeded(cxp, opr) Then
                        For rw = 1 To rwcnt
                            vridx = CCPVRStorage.GetDataPointVR(cxp, cvrs(k), flgs, opr, m_contractRgn.Cells(rw, 1).Value2, m_contractRgn.Cells(rw, 3).Value2, m_contractRgn.Cells(rw, 2).Value2)
                            If vridx <> 0 Then
                                m_dataRgn.Cells(rw, col).Interior.color = vridx 'Index = IIf(vridx = CURVE_VR_CLRIDX_UN_SUPPORTED, xlNone, vridx)
                            End If
                        Next
                    End If
                End If
            Next
        End If
    End If
End Sub

Public Sub ClearImagesV1(datargn As range)
 Dim s As Variant
 
    With ActiveSheet
        For Each s In .Shapes
            If s.Type <> msoComment And s.Type <> msoFormControl Then
                s.Delete
            End If
        Next
    End With
    
    Call CCurveControl.InsertTitle(ActiveSheet)

    With datargn
        '.Interior.ColorIndex = xlNone
        If Not .FormatConditions Is Nothing Then
            If .FormatConditions.count > 0 Then
                Call .FormatConditions.Delete
            End If
        End If
    End With
End Sub

Private Sub GetCompoundSplits(sht As Worksheet, ByRef si As Long, ByRef rowdiff As Long, ByRef colDiff As Long)
 Dim tmp As Variant
 
    si = 0
    rowdiff = 0
    colDiff = 0
    
    tmp = CSheet.WSGetProp(sht, CURVE_SHEET_SPLITS)
    If Len(tmp) = 0 Then Exit Sub
    tmp = Split(tmp, ",")
    If UBound(tmp) <> 2 Then Exit Sub
    
    si = Int(Val(tmp(0)))
    rowdiff = Int(Val(tmp(1)))
    colDiff = Int(Val(tmp(2)))
End Sub

Private Sub StoreCompoundSplits(sht As Worksheet, ByVal si As Long, ByVal rowdiff As Long, ByVal colDiff As Long)
    Call CSheet.WSSetProp(sht, CURVE_SHEET_SPLITS, CStr(si) + "," + CStr(rowdiff) + "," + CStr(colDiff))
End Sub

Private Sub StoreCPSplits(sht As Worksheet, ByRef sRow As Long, ByRef sCol As Long)
 Dim si As Long
 Dim dc As Long
 Dim dr As Long
 
    Call GetCompoundSplits(sht, si, dr, dc)
    Call StoreCompoundSplits(sht, sCol Or (sRow * &H100), 0, 0)
    
    If sCol + dc > 1 Then sCol = sCol + dc
    If sRow + dr > 0 Then sRow = sRow + dr
End Sub

Private Sub GetOldSplits(ByVal si As Long, ByRef sRow As Long, ByRef sCol As Long)
    sRow = 0
    sCol = 0
    
    If si > 0 Then
        sCol = (si And &HFF)
        sRow = (si \ &H100) And &HFF
    End If
End Sub

Private Function GetCPSplits(params As CCurveParams, sht As Worksheet, ByRef sRow As Long, ByRef sCol As Long) As Boolean
 Dim si As Long
 Dim dc As Long
 Dim dr As Long
 Dim tempcol As Long
 Dim temprow As Long
 
    sRow = 0
    sCol = 0
    
    With GetWnd(sht)
        If Not .Split Then
            Call GetCompoundSplits(sht, si, dr, dc)
            Call GetOldSplits(si, sRow, sCol)
            GetCPSplits = IIf(sCol > 0 And sRow > 0, True, False)
            
            Exit Function
        End If
        
        tempcol = .SplitColumn
        temprow = .splitrow
    End With

    'for compatibility
    If tempcol = 1 Then
        If Not params Is Nothing Then
            If Not params.IsFlag(CURVE_FLG_PIVOT) Then
                If sht.Columns(2).EntireColumn.Hidden = True Then
                    tempcol = 2
                End If
            End If
        End If
    End If
    
    Call GetCompoundSplits(sht, si, dr, dc)
    
    If si > 0 Then
        Call GetOldSplits(si, sRow, sCol)
    Else
        sCol = tempcol
        sRow = temprow
    End If
    
    dc = tempcol - sCol
    dr = temprow - sRow
    
    Call StoreCompoundSplits(sht, sCol Or (sRow * &H100), dr, dc)
    
    GetCPSplits = True
End Function

Public Function GetDateObservationTypes(ByVal curveNam As String, ByVal obsTypes As Long, ByVal withDataTypeprefixed As Boolean) As String()
 Dim cvnm(0) As String

    cvnm(0) = curveNam
    GetDateObservationTypes = CDDXLib.DefaultZEWSProxy(DDX_PID).GetCurveObservationTypes(vbNullString, cvnm, obsTypes, IIf(withDataTypeprefixed, 1, 0))
End Function

Private Function GetSOCFormat(ByVal curveNam As String) As String  'used for single observation curves only
 Dim typs() As String
 Dim tv As Long
 
    typs = GetDateObservationTypes(curveNam, CURVE_OBSERVATION_DATE, True)
    
    If Len(Join(typs)) = 0 Then
        tv = CURVE_OBSERVATION_NUMBER
    
    Else
        typs = Split(typs(0), ",")
        tv = Int(Val(typs(0)))
    End If
    
    GetSOCFormat = CCurveType.GetValueFormat(tv)
End Function

Public Sub SetSOCValueFormats(aCurveIndex As Long, datargn As range, curveParams As CCurveParams)
 Dim cns() As String
 Dim k As Long
 Dim inc As Long
 Dim fmt As String
 Dim tmp As String
 Dim startl As Long
 Dim cols As Long
 
    If curveParams.IsFlag(CURVE_FLG_MULTIOBS) Then Exit Sub
    
    cns = curveParams.curves
    
    If curveParams.IsFlag(CURVE_FLG_FUTURE_RANGE) Or aCurveIndex >= 0 Then
        If curveParams.IsFlag(CURVE_FLG_FUTURE_RANGE) Then aCurveIndex = 0
        datargn.NumberFormat = GetSOCFormat(cns(aCurveIndex))
        Exit Sub
    End If
    
    If curveParams.IsFlag(CURVE_FLG_PIVOT) Then
        cols = datargn.Columns.count
        
        fmt = vbNullString
        startl = -1
        
        For k = LBound(cns) To UBound(cns)
            tmp = GetSOCFormat(cns(k))
            
            If StrComp(tmp, fmt) <> 0 Then
                If fmt = vbNullString Then
                    fmt = tmp
                    startl = k
                Else
                    'datargn.Cells(k + 1, 1).Resize(, cols).NumberFormat = GetSOCFormat(cns(k))
                    datargn.Cells(startl + 1, 1).Resize(k - startl, cols).NumberFormat = fmt
                    fmt = tmp
                    startl = k
                End If
            End If
        Next
        If fmt <> vbNullString And startl >= 0 Then
            datargn.Cells(startl + 1, 1).Resize(k - startl, cols).NumberFormat = fmt
        End If
        Exit Sub
    End If
    
    inc = IIf(curveParams.IsFlag(CURVE_FLG_MRBD), 2, 1)
    
    For k = LBound(cns) To UBound(cns)
        datargn.offset(, k * inc).Resize(, inc).NumberFormat = GetSOCFormat(cns(k))
    Next
End Sub

Private Function IsDateCurveType(dtyps() As String, ctyp As String) As Boolean
 Dim k As Long
 
    For k = LBound(dtyps) To UBound(dtyps)
        If StrComp(dtyps(k), ctyp) = 0 Then
            IsDateCurveType = True
            Exit Function
        End If
    Next
End Function

Private Function IsWrongFormatCell(rgn As range, ByRef errRow As Long, ByRef errCol As Long) As Long
 Dim e As Long
 
    On Error GoTo OOPS
    
    If IsDate(rgn) Then e = &H1
    If iserror(rgn) Then e = e Or &H2
    
OOPS:
    If Err.Number <> 0 Then e = e Or &H2
    
    If e <> 0 Then
        errRow = rgn.row 'm_dataRgn.row - 1
        errCol = rgn.column 'm_dataRgn.column - 1
        
        IsWrongFormatCell = IIf((e And &H2) <> 0, -1, 1)
    End If
End Function

Public Function CheckDataFormats(params As CCurveParams, ByVal curveIndex As Long, ByRef errRow As Long, ByRef errCol As Long) As Long
 Dim dtyps() As String
 Dim rowcnt As Long
 Dim colcnt As Long
 Dim row As Long
 Dim col As Long
 Dim cvrtypes() As String
 Dim rgn As range
 Dim cnames() As String
 Dim multi As Long
 
    On Error GoTo OOPS
    
    If Not GetAreas(curveIndex) Then Exit Function
    
    cnames = params.curves
    If curveIndex < 0 Then
        dtyps = CDDXLib.DefaultZEWSProxy(DDX_PID).GetCurveObservationTypes(vbNullString, params.curves, CURVE_OBSERVATION_DATE, 0)
    Else
        dtyps = GetDateObservationTypes(cnames(curveIndex), CURVE_OBSERVATION_DATE, False)
    End If
    
    rowcnt = m_dataRgn.rows.count
    colcnt = m_dataRgn.Columns.count
        
    If Len(Join(dtyps)) = 0 Then
        For row = 1 To rowcnt
            For col = 1 To colcnt
                CheckDataFormats = IsWrongFormatCell(m_dataRgn.Cells(row, col), errRow, errCol)
                If CheckDataFormats <> 0 Then Exit Function
            Next
        Next
        Exit Function
    End If
    
    If params.IsFlag(CURVE_FLG_PIVOT) Then
        For row = 1 To rowcnt
            dtyps = GetDateObservationTypes(cnames(IIf(curveIndex < 0, row - 1, curveIndex)), CURVE_OBSERVATION_DATE, False)
            If Len(Join(dtyps)) = 0 Then
                For col = 1 To colcnt
                    CheckDataFormats = IsWrongFormatCell(m_dataRgn.Cells(row, col), errRow, errCol)
                    If CheckDataFormats <> 0 Then Exit Function
                Next
            End If
        Next
        
    ElseIf Not params.IsFlag(CURVE_FLG_MULTIOBS) Then
        multi = IIf(params.IsFlag(CURVE_FLG_MRBD), 2, 1)
        For col = 1 To colcnt \ multi
            dtyps = GetDateObservationTypes(cnames(IIf(curveIndex < 0, col - 1, curveIndex)), CURVE_OBSERVATION_DATE, False)
            If Len(Join(dtyps)) = 0 Then
                For row = 1 To rowcnt
                    CheckDataFormats = IsWrongFormatCell(m_dataRgn.Cells(row, multi * col), errRow, errCol)
                    If CheckDataFormats <> 0 Then Exit Function
                Next
            End If
        Next
        
    Else
        cvrtypes = CCurveDates.CurveTypeList
        For row = 1 To rowcnt
            If Not IsDateCurveType(dtyps, cvrtypes(row - 1)) Then
                For col = 1 To colcnt
                    CheckDataFormats = IsWrongFormatCell(m_dataRgn.Cells(row, col), errRow, errCol)
                    If CheckDataFormats <> 0 Then Exit Function
                Next
            End If
        Next
    End If

    'Set rgn = m_dataRgn.SpecialCells(xlCellTypeFormulas, xlErrors) 'would be slow
    For row = 1 To rowcnt
        For col = 1 To colcnt
            If iserror(m_dataRgn.Cells(row, col)) Then
                errRow = rgn.row
                errCol = rgn.column
                CheckDataFormats = -1
                Exit Function
            End If
        Next
    Next
    
OOPS:
    If Err.Number <> 0 Then
        CDDXApp.StatusMessage = Err.Description
    End If
    Exit Function
End Function

Public Sub ResetAllDataFormats(params As CCurveParams, ByVal curveIndex As Long)
 Const DF As String = "General"
 Dim dtyps() As String
 Dim rowcnt As Long
 Dim colcnt As Long
 Dim row As Long
 Dim col As Long
 Dim cvrtypes() As String
 Dim cnames() As String
 Dim multi As Long
 
    On Error GoTo OOPS
    
    If Not GetAreas(curveIndex) Then Exit Sub

    cnames = params.curves
    If curveIndex < 0 Then
        dtyps = CDDXLib.DefaultZEWSProxy(DDX_PID).GetCurveObservationTypes(vbNullString, cnames, CURVE_OBSERVATION_DATE, 0)
    Else
        dtyps = GetDateObservationTypes(cnames(curveIndex), CURVE_OBSERVATION_DATE, False)
    End If
    
    If Len(Join(dtyps)) = 0 Then
        Call SetCellFormat(m_dataRgn, DF)
        Exit Sub
    End If
    
    rowcnt = m_dataRgn.rows.count
    colcnt = m_dataRgn.Columns.count
    
    If params.IsFlag(CURVE_FLG_PIVOT) Then
        For row = 1 To rowcnt
            dtyps = GetDateObservationTypes(cnames(IIf(curveIndex < 0, row - 1, curveIndex)), CURVE_OBSERVATION_DATE, False)
            If Len(Join(dtyps)) = 0 Then
                Call SetCellFormat(m_dataRgn.offset(row - 1).Resize(1), DF)
            End If
        Next
        
    ElseIf Not params.IsFlag(CURVE_FLG_MULTIOBS) Then
        multi = IIf(params.IsFlag(CURVE_FLG_MRBD), 2, 1)
        For col = 1 To colcnt \ multi
            dtyps = GetDateObservationTypes(cnames(IIf(curveIndex < 0, col - 1, curveIndex)), CURVE_OBSERVATION_DATE, False)
            If Len(Join(dtyps)) = 0 Then
                Call SetCellFormat(m_dataRgn.offset(, col * multi - 1).Resize(, 1), DF)
            End If
        Next
    
    Else
        cvrtypes = CCurveDates.CurveTypeList
        rowcnt = UBound(cvrtypes) - LBound(cvrtypes) + 1

        For row = 1 To rowcnt
            If Not IsDateCurveType(dtyps, cvrtypes(row - 1)) Then
                Call SetCellFormat(m_dataRgn.offset(row - 1).Resize(1), DF)
            End If
        Next
    End If
    
OOPS:
    If Err.Number <> 0 Then
        CDDXApp.StatusMessage = Err.Description
    End If
    Exit Sub
End Sub

Private Sub SetCellFormat(target As range, cfmt As String)
 Dim prot As Long
 
    If target.Parent.ProtectContents Then
        prot = &H1
        Call Unprotect(target.Parent)
    End If
    
    target.NumberFormat = cfmt
    
    If prot = &H1 Then
        Call Protect(target.Parent)
    End If
End Sub

Public Function ResetDataFormat(params As CCurveParams) As Long
 Const DF As String = "General"
 Dim dtyps() As String
 Dim row As Long
 Dim col As Long
 Dim cvrtypes() As String
 Dim target As range
 Dim cnames() As String
 Dim multi As Long
 
    Set target = ActiveCell
    If StrComp(target.NumberFormat, DF, vbTextCompare) = 0 Then Exit Function
    
    On Error GoTo OOPS
    
    If Not GetAreas(-1) Then Exit Function
    
    With m_dataRgn
        If target.row < .row Then Exit Function
        If target.row > .row + .rows.count - 1 Then Exit Function
        If target.column < .column Then Exit Function
        If target.column > .column + .Columns.count - 1 Then Exit Function
    End With
    
    cnames = params.curves
    dtyps = CDDXLib.DefaultZEWSProxy(DDX_PID).GetCurveObservationTypes(vbNullString, cnames, CURVE_OBSERVATION_DATE, 0)

    If Len(Join(dtyps)) = 0 Then
        Call SetCellFormat(target, DF)
        ResetDataFormat = 1
        Exit Function
    End If
    
    If params.IsFlag(CURVE_FLG_PIVOT) Then
        row = target.row - m_dataRgn.row
        dtyps = GetDateObservationTypes(cnames(row), CURVE_OBSERVATION_DATE, False)
        If Len(Join(dtyps)) = 0 Then
            Call SetCellFormat(target, DF)
        End If
        
    ElseIf Not params.IsFlag(CURVE_FLG_MULTIOBS) Then
        col = target.column - m_dataRgn.column + 1
        multi = IIf(params.IsFlag(CURVE_FLG_MRBD), 2, 1)
        If multi = 2 Then
            If col Mod 2 <> 0 Then Exit Function
        End If
 
        dtyps = GetDateObservationTypes(cnames(col \ multi - 1), CURVE_OBSERVATION_DATE, False)
        If Len(Join(dtyps)) = 0 Then
            Call SetCellFormat(target, DF)
        End If
        
    Else
        cvrtypes = CCurveDates.CurveTypeList
        row = target.row - m_dataRgn.row
        
        If Not IsDateCurveType(dtyps, cvrtypes(row)) Then
            Call SetCellFormat(target, DF)
            ResetDataFormat = 1
        End If
    End If

OOPS:
    If Err.Number <> 0 Then
        CDDXApp.StatusMessage = Err.Description
    End If
    Exit Function
End Function

Private Property Get UploadOpOptions() As Long
    UploadOpOptions = IIf(CDDXCurve.UploadNulls And Not CDDXCurve.FourEyesActive, CURVE_OP_INSERT_NULLS, 0) Or _
                     IIf(CDDXCurve.UploadWithProt, CURVE_OP_INSERT_PROT, 0) Or _
                     CURVE_OP_VR_RETRIEVE Or CURVE_OP_FOUR_EYES
End Property

Private Property Get DownloadOpOptions() As Long
    DownloadOpOptions = CURVE_OP_VR_RETRIEVE Or CURVE_OP_FOUR_EYES
End Property

Public Function GetNameWidth(params As CCurveParams) As Long
 Dim cns() As String
 Dim i As Long
 Dim w As Long
 
    cns = params.curves
    For i = LBound(cns) To UBound(cns)
        w = Len(cns(i))
        If w > GetNameWidth Then GetNameWidth = w
    Next
    
    If GetNameWidth <= 12 Then
        GetNameWidth = 14
    Else
        GetNameWidth = GetNameWidth + 2
    End If
End Function

Public Sub DrawChangableDateRange(sht As Worksheet, ByVal oprDate As Date, ByVal dateCols As Long, ByVal drawFormula As Boolean)
 Dim edte As String
 
    With sht.Cells(2, 1)
        .IndentLevel = 1
        .HorizontalAlignment = xlLeft
        .VerticalAlignment = xlCenter
        
        edte = "Effective Date "
        .value = edte + "  ( Changeable below )"
        With .Characters(1).Font
            .size = 9
        End With
        With .Characters(Len(edte) + 1).Font
            .size = 8
            '.Italic = True
        End With
    End With
    
    With sht.Cells(3, 1).Resize(, dateCols)
        .Interior.ColorIndex = 40
        .IndentLevel = 1
        .HorizontalAlignment = xlLeft
        .VerticalAlignment = xlCenter
        .Characters(1).Font.size = 9
    End With
    
    If drawFormula Then
        With sht.Cells(3, 1)
            .NumberFormat = CDDXDates.SystemDateFormat
            .value = oprDate
        End With
    End If
End Sub

Public Sub EraseVR()
 Dim shp As Shape
 Dim btnall As String
 Dim btnlenall As Long
 Dim btn As String
 Dim btnlen As Long
 Dim fc As range
 Dim addr As String
 Dim k As Long
 Dim cvs() As String
 Dim isv2 As Boolean
 Dim uihandler As Object
 
'erase vr
    Call CCPVRStorage.EraseVR(ActiveSheet)
    
    With CCurveDates.ParamEntity
        isv2 = IIf(CDDXCurve.GetSheetVersion(.flagValues) >= CDDXCurve.GetSheetVersion(CURVE_FLG_V2), True, False)
        cvs = .curves
    End With
    
    Set uihandler = CCurveDates.Handler
    
    For k = LBound(cvs) To UBound(cvs)
        If isv2 Then
            Call uihandler.DrawVR(vbNullString, k)
        Else
            Call uihandler.DrawVR(k)
        End If
    Next
    
'delete all Accept buttons
    btnall = GetAltText(vbNullString, AT_ACCEPT_ALL)
    btnlenall = Len(btnall)
    
    btn = GetAltText(vbNullString, AT_ACCEPT)
    btnlen = Len(btn)
    
    For Each shp In ActiveSheet.Shapes
        With shp
            If isv2 Then
                If StrComp(right(.AlternativeText, btnlenall), btnall) = 0 Then
                    .Delete
                    Exit For
                End If
            Else
                If StrComp(right(.AlternativeText, btnlen), btn) = 0 Or StrComp(right(.AlternativeText, btnlenall), btnall) = 0 Then
                    .Delete
                End If
            End If
        End With
    Next
    
'clear styles
    Call GetAreas(-1)
    
    If Not m_dataRgn Is Nothing Then
        With m_dataRgn
            .ClearComments
            
            .Locked = False
            .Interior.ColorIndex = xlNone

            .Characters.Font.Bold = False
        End With
        
        'set colors to CHANGED
        With Application.FindFormat
            .Clear
            .Font.ColorIndex = xlColorIndexAutomatic
        End With
        
        Set fc = m_dataRgn.Cells(1, 1)
        Do
            Set fc = m_dataRgn.Find(what:=vbNullString, After:=fc, _
                    LookIn:=xlFormulas, LookAt:=xlPart, _
                    SearchOrder:=xlByRows, SearchDirection:=xlNext, _
                    MatchCase:=False, SearchFormat:=True)
                
            If fc Is Nothing Then Exit Do
            fc.Font.ColorIndex = CURVE_CHANGE_CLR_IDX
            
            If Len(addr) = 0 Then
                addr = fc.Address
            Else
                If StrComp(addr, fc.Address) = 0 Then Exit Do
            End If
        Loop
    End If
End Sub

Private Function GetTargetCurveToCache(idxCurve As Variant, ByVal isUp As Boolean) As String()
 Dim cvs() As String
 Dim wcvs() As String
 Dim k As Long
 Dim p As Long
 
    cvs = CCurveDates.ParamEntity.curves
    
    If VarType(idxCurve) = vbString Then
        ReDim cvs(0 To 0)
        cvs(0) = idxCurve
    Else
        If idxCurve >= 0 Then
            ReDim cvs(0 To 0)
            cvs(0) = cvs(idxCurve)
            ReDim Preserve cvs(0 To 0)
            
        ElseIf isUp Then
            p = -1
            For k = LBound(cvs) To UBound(cvs)
                If Not CCurveDates.ParamEntity.Readonly(k) Then
                    If p = -1 Then
                        ReDim wcvs(LBound(cvs) To UBound(cvs))
                    End If
                    p = p + 1
                    wcvs(p) = cvs(k)
                End If
            Next
            
            If p <> -1 Then
                ReDim Preserve wcvs(0 To p)
                cvs = wcvs
            End If
        End If
    End If
    
    GetTargetCurveToCache = cvs
End Function

Public Function CacheCurves(idxCurve As Variant, ByVal isUp As Boolean, Optional useCachedInfo As Boolean = False) As Boolean
 Dim cvs() As String
 Dim typs() As String
 Dim tmp As Long

    CDDXApp.StatusMessage = "Caching curves..."
    cvs = GetTargetCurveToCache(idxCurve, isUp)
    Call CDDXLib.DefaultZEWSProxy(DDX_PID).FindCurves(CDDXLogin.sid, 0, cvs, typs, vbNullString, vbNullString, tmp, CURVE_FIND_BY_NAME Or CURVE_FIND_VOID_RETURN Or IIf(useCachedInfo, CURVE_FIND_DIFFERENTIAL, 0))
    CDDXApp.StatusMessage = vbNullString
    
    If tmp <= 0 Then
        Call CDDXApp.DialogMessage(IIf(VarType(idxCurve) = vbString Or idxCurve >= 0, cvs(0) + " not found.", "None of curves is found."), vbExclamation)
        Exit Function
    End If

    tmp = (UBound(cvs) - LBound(cvs) + 1) - tmp
    If tmp > 0 Then
        Call CDDXApp.DialogMessage("There exist missing curves. (" + CStr(tmp) + ")" + vbCrLf + "Missing curves can be removed on the Settings window.", vbExclamation)
        Exit Function
    End If

    CacheCurves = True
End Function

Public Function DeleteProperties(hdrRgn As range, ByVal fixedRow As Long) As Long
 Dim k As Long
 Dim j As Long
 Dim Values() As String
 Dim v
 Dim row As Long
 Dim col As Long
 Dim rgn As range
 
    With CCurveDates.ParamEntity
        Values = .PropertyNames
        If Len(Join(Values)) = 0 Then Exit Function
                
        Call GetSplits(CCurveDates.TargetSheet, CCurveDates.ParamEntity, row, col)
        
        row = fixedRow
        Set rgn = hdrRgn.offset(row, col).Resize(hdrRgn.rows.count - row, hdrRgn.Columns.count - col)
        
        col = rgn.Columns.count
        For k = UBound(Values) To LBound(Values) Step -1
            v = rgn.rows(k + 1).Value2
            
            If (VarType(v) And vbArray) = vbArray Then
                For j = 1 To col
                    If Not IsEmpty(v(1, j)) Then
                        If Len(Trim(v(1, j))) > 0 Then Exit For
                    End If
                Next
            Else
                If IsEmpty(v) Or Len(Trim(v)) = 0 Then j = col + 1
            End If
            If j > col Then
                CCurveDates.TargetSheet.rows(row + k + 1).EntireRow.Delete
                Call CCurveDates.ParamEntity.RemoveProperty(Values(k))
                
                DeleteProperties = DeleteProperties + 1
            End If
        Next
    End With
    
    If DeleteProperties > 0 Then Call SaveCurveProperties(hdrRgn.Parent, CCurveDates.ParamEntity)
End Function

Public Function DeletePropertiesTRANS(dtaRgn As range) As Long
 Dim k As Long
 Dim j As Long
 Dim Values() As String
 Dim v
 Dim rcnt As Long
 Dim row As Long
 Dim col As Long

    With CCurveDates.ParamEntity
        Values = .PropertyNames
        If Len(Join(Values)) = 0 Then Exit Function
                
        Call GetSplits(CCurveDates.TargetSheet, CCurveDates.ParamEntity, row, col)
        col = col + 1
        
        rcnt = dtaRgn.rows.count - 1
        For k = UBound(Values) To LBound(Values) Step -1
            v = dtaRgn.Cells(2, col + k).Resize(rcnt, 1).Value2
            
            If (VarType(v) And vbArray) = vbArray Then
                For j = 1 To rcnt
                    If Not IsEmpty(v(j, 1)) Then
                        If Len(Trim(v(j, 1))) > 0 Then Exit For
                    End If
                Next
            Else
                If IsEmpty(v) Or Len(Trim(v)) = 0 Then j = rcnt + 1
            End If
            If j > rcnt Then
                CCurveDates.TargetSheet.Columns(col + k).EntireColumn.Delete
                Call CCurveDates.ParamEntity.RemoveProperty(Values(k))
                
                DeletePropertiesTRANS = DeletePropertiesTRANS + 1
            End If
        Next
    End With
    
    If DeletePropertiesTRANS > 0 Then Call SaveCurveProperties(dtaRgn.Parent, CCurveDates.ParamEntity)
End Function

Public Sub ClearUnusedArea(dtaRgn As range, hdrRgn As range)
 Dim lr As Long
 Dim sht As Worksheet
 
    On Error GoTo OOPS
    
    If Not dtaRgn Is Nothing Then
        lr = dtaRgn.row + dtaRgn.rows.count
        Set sht = dtaRgn.Worksheet
    Else
        lr = hdrRgn.rows.count + 1
        Set sht = hdrRgn.Worksheet
    End If
    
    With sht
        Call .Cells(lr, 1).Resize(.rows.count - lr - 1, .Columns.count).Clear
    End With
    
OOPS:
    Exit Sub
End Sub

Public Function HasWriteableCurves(sht As Worksheet, params As CCurveParams, permissions() As Long) As Boolean
 Dim k As Long
 
    For k = LBound(permissions) To UBound(permissions)
        If permissions(k) = 1 Then HasWriteableCurves = True

        If permissions(k) >= 0 Then
            Call params.SetReadonly(k, IIf(permissions(k) = 0, True, False))
        End If
    Next
    
    Call CCurveControl.SaveCurveProperties(sht, params)
End Function

Public Function AddProtection(permissions() As Long, dtaRgn As range) As Boolean
 Dim curves() As String
 Dim taskID As String
 Dim oprstart As Double
 Dim oprend As Double
 Dim flags As Long
 Dim gvals() As Long
 Dim ctvals() As String
 Dim pidx As String
 
    pidx = GetTargetCurves(permissions)
    If pidx = vbNullString Then Exit Function
    
    With CCurveDates.ParamEntity
        curves = .curves
        taskID = .sheetId

        flags = .flagValues
        
        If .IsFlag(CURVE_FLG_MULTIOBS) Then
            ctvals = CCurveDates.CurveTypeList
            If Not .IsFlag(CURVE_FLG_TIMESERIES) Then
                gvals = CCurveDates.GranularityList
            End If
        End If
        
        Call GetRefreshDateRangeIndividual(curves(0), 0, oprstart, oprend)
        Call CDDXLib.DefaultZEWSProxy(DDX_PID).DownloadCurves(.sheetId, vbNullString, _
                                    curves, _
                                    oprstart, oprend, _
                                    .exclWeekEnds, .exclHolidays, _
                                    CCurveDates.ContractDateList, _
                                    gvals, _
                                    ctvals, _
                                    flags, _
                                    DownloadOpOptions Or CURVE_OP_STRICT_INPUTS Or CURVE_OP_SYNC Or CURVE_OP_PROTECTED_INFO_ONLY, _
                                    pidx)
    End With
    
    AddProtection = ReadProtection(dtaRgn, IIf((flags And CURVE_FLG_PIVOT) = 0, False, True))
End Function

Private Function GetTargetCurves(permissions() As Long) As String
 Dim k As Long

    For k = LBound(permissions) To UBound(permissions)
        If permissions(k) = 1 Then
            If Len(GetTargetCurves) > 0 Then GetTargetCurves = GetTargetCurves + ","
            GetTargetCurves = GetTargetCurves + CStr(k)
        End If
    Next
End Function

Private Function ReadProtection(dtaRgn As range, ByVal transposed As Boolean) As Boolean 'from addcomments
 Dim file As Object
 Dim fpath As String
 Dim msg As String
 Dim k As Long
 Dim r As Long
 Dim c As Long
 Dim attribs As Long
 Dim buff As Variant

    On Error GoTo OOPS

    fpath = CurveCommentFilePath
    
    If Not CDDXHelper.FileThere(fpath) Then Exit Function
    If FileLen(fpath) <= 3 Then
        Kill fpath
        Exit Function
    End If
    
    Set file = CDDXFile.OpenFile(fpath)
    
    Do
        If file.EOS() Then Exit Do
        
        buff = file.ReadText(-2)
        If Len(buff) = 0 Then Exit Do
        
        buff = Split(CStr(buff), vbTab)

        r = Int(Val(buff(0)))
        k = 1
        Do
            If k > UBound(buff) Then Exit Do
            
            c = Int(Val(buff(k)))
            If c = 0 Then Exit Do
            
            attribs = c And &HF
            c = c \ &H10

            dtaRgn.Cells(IIf(transposed, c, r), IIf(transposed, r, c)).Locked = IIf((attribs And ATTRIB_CELL_PROTECTION) = 0, False, True)
            
            k = k + 2
        Loop
    Loop
    
    ReadProtection = True
    
OOPS:
    If Err.Number <> 0 Then
        Call CDDXHelper.LogError(Err.Description, "RetrieveProtection")
    End If
    
    If Not file Is Nothing Then
        Call CDDXFile.CloseFile(file, fpath, msg)
        Set file = Nothing
    End If
    
    Exit Function
End Function

Private Sub Class_Terminate()
    Erase m_ts_oprs
    Erase m_ts_inputs
    Erase m_ts_sorted
End Sub
Attribute VB_Name = "CCurveDates"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private m_handler As Object
Private m_sheet As Worksheet
Private m_params As CCurveParams

Public Function NewDate(yearValue As Integer, monthValue As Integer, dayValue As Integer, hourValue As Integer, minuteValue As Integer, secondValue As Integer) As Date
 Dim dt As Date
 
    dt = DateSerial(yearValue, monthValue, dayValue)
    If hourValue > 0 Then dt = DateAdd("h", hourValue, dt)
    If minuteValue > 0 Then dt = DateAdd("n", minuteValue, dt)
    If secondValue > 0 Then dt = DateAdd("s", secondValue, dt)
End Function

Public Function IsDateNull(dt As Date) As Boolean
 Dim tmp As Date
 
    If year(tmp) <> year(dt) Then Exit Function
    If month(tmp) <> month(dt) Then Exit Function
    If day(tmp) <> day(dt) Then Exit Function
    
    IsDateNull = True
End Function

Public Function CompareDoubles(d1 As Double, d2 As Double) As Integer
 Dim d As Double
 
    d = d1 - d2
    If Abs(d) < 0.0000000001 Then '1.0e-10
        CompareDoubles = 0
    Else
        CompareDoubles = IIf(d < 0, -1, 1)
    End If
End Function

Public Function CompareDates(dt1 As Date, dt2 As Date) As Integer
    CompareDates = year(dt1) - year(dt2)
    If CompareDates <> 0 Then Exit Function

    CompareDates = month(dt1) - month(dt2)
    If CompareDates <> 0 Then Exit Function

    CompareDates = day(dt1) - day(dt2)
    If CompareDates <> 0 Then Exit Function

    CompareDates = Hour(dt1) - Hour(dt2)
    If CompareDates <> 0 Then Exit Function

    CompareDates = Minute(dt1) - Minute(dt2)
    If CompareDates <> 0 Then Exit Function

    CompareDates = Second(dt1) - Second(dt2)
    If CompareDates <> 0 Then Exit Function
End Function

Private Sub Cleanup()
    Set m_handler = Nothing
    Set m_params = Nothing
    Set m_sheet = Nothing
End Sub

Public Sub AssignTargetSheet(value As Worksheet)
    Set m_sheet = value
End Sub

Public Property Get TargetSheet() As Worksheet
    Set TargetSheet = m_sheet
End Property

Private Function IsValidSheet(sht) As Boolean
    On Error GoTo OOPS
    
    If sht.name <> vbNullString Then
    End If
    IsValidSheet = True
    
OOPS:
    Exit Function
End Function

Public Property Set TargetSheet(value As Worksheet)
    If Not IsValidSheet(m_sheet) Then
        Call Cleanup
    ElseIf m_sheet Is Nothing Or value Is Nothing Then
        Call Cleanup
    ElseIf StrComp(m_sheet.name, value.name) <> 0 Or StrComp(m_sheet.Parent.FullName, value.Parent.FullName) <> 0 Then
        Call Cleanup
    End If
    
    Set m_sheet = value
End Property

Public Property Get Handler() As Object
    If m_handler Is Nothing Then
        If m_sheet Is Nothing Then Set m_sheet = ActiveSheet
        Set m_handler = GetHandler(CDDXCurve.GetFVS(m_sheet))
    End If
    Set Handler = m_handler
End Property

Public Property Set Handler(value As Object)
    Set m_handler = value
End Property

Public Property Get ParamEntity() As CCurveParams
    On Error GoTo OOPS
    
    If m_params Is Nothing Then
        If m_sheet Is Nothing Then Set m_sheet = ActiveSheet
        Set m_params = New CCurveParams
        Call m_params.FromXML(CCurveControl.GetCurveProperties(m_sheet))
    End If
    
    Set ParamEntity = m_params
    
OOPS:
    If Err.Number <> 0 Then
        CDDXApp.StatusMessage = Err.Description
        Set m_params = Nothing
    End If
    Exit Property
End Property

Public Property Set ParamEntity(value As CCurveParams)
    Set m_params = value
End Property

Public Property Get GranularityList() As Long()
    If Not ParamEntity.IsFlag(CURVE_FLG_MULTIOBS) Then Exit Property
    GranularityList = CCurveGranularity.GetGranularitiesBySheet(ActiveSheet)
End Property

Public Property Get CurveTypeList() As String()
    If Not ParamEntity.IsFlag(CURVE_FLG_MULTIOBS) Then Exit Property
    CurveTypeList = CCurveType.GetTypesBySheet(ActiveSheet)
End Property

Private Function GetContracts() As Variant
 Dim srows As Long
 Dim scols As Long
 Dim v
 Dim props As Long
 
    If ParamEntity.rowCount <= 1 Then Exit Function
    
    Call CCurveControl.GetSplits(TargetSheet, ParamEntity, srows, scols)
       
    If ParamEntity.IsFlag(CURVE_FLG_PIVOT) Then
        scols = scols + CCurveControl.HoriWidthTRANS(ParamEntity) + 1
        v = TargetSheet.Cells(srows, scols).Resize(1, ParamEntity.rowCount - 1).Value2
    Else
        v = TargetSheet.Cells(srows + 1, 1).Resize(ParamEntity.rowCount - 1, 1).Value2
    End If
    
    GetContracts = v
End Function

Public Sub GetContractBounds(ByRef minDate As Double, ByRef maxDate As Double)
 Dim v
 Dim k As Long
 
    minDate = 0
    maxDate = 0
    
    v = GetContracts()
    If IsEmpty(v) Then Exit Sub
    
    If (VarType(v) And vbArray) = 0 Then
        minDate = v
        maxDate = minDate
    Else
        minDate = v(1, 1)
        maxDate = minDate
        
        If ParamEntity.IsFlag(CURVE_FLG_PIVOT) Then
'                For k = LBound(v, 2) To UBound(v, 2)
'                    If v(1, k) > maxDate Then maxDate = v(1, k)
'                    If v(1, k) < minDate Then minDate = v(1, k)
'                Next
            maxDate = v(1, UBound(v, 2))
        Else
            For k = LBound(v, 1) To UBound(v, 1)
                If v(k, 1) > maxDate Then maxDate = v(k, 1)
                If v(k, 1) < minDate Then minDate = v(k, 1)
            Next
        End If
    End If
End Sub

Public Property Get ContractDateList() As Double()
 Dim v
 Dim k As Long
 Dim ary() As Double
 
    v = GetContracts()
    If IsEmpty(v) Then Exit Function
       
    If (VarType(v) And vbArray) = 0 Then
        If ParamEntity.IsFlag(CURVE_FLG_EDIT_DATES) Then
            If iserror(v) Or VarType(v) <> vbDouble Then
                Err.Raise vbObjectError, , "Invalid contract date"
            End If
        End If
        ReDim ary(0)
        ary(0) = v
    Else
        k = IIf(ParamEntity.IsFlag(CURVE_FLG_PIVOT), 2, 1)
        ReDim ary(0 To UBound(v, k) - LBound(v, k))
        
        If ParamEntity.IsFlag(CURVE_FLG_PIVOT) Then
            For k = LBound(v, 2) To UBound(v, 2)
                ary(k - 1) = v(1, k)
            Next
        Else
            For k = LBound(v, 1) To UBound(v, 1)
                If ParamEntity.IsFlag(CURVE_FLG_EDIT_DATES) Then
                    If iserror(v(k, 1)) Or VarType(v(k, 1)) <> vbDouble Then
                        Err.Raise vbObjectError, , "Invalid contract date (" + CStr(k + 1) + ")"
                    End If
                End If
                ary(k - 1) = v(k, 1)
            Next
        End If
    End If
    
    ContractDateList = ary
End Property

Public Property Get EffectiveDateList() As Double()
 Dim srows As Long
 Dim scols As Long
 Dim v
 Dim k As Long
 Dim props As Long
 Dim ary() As Double
 
    If ParamEntity.IsFlag(CURVE_FLG_TIMESERIES) Then Exit Property
    If ParamEntity.ColumnCount <= 1 Then Exit Property
    
    Call CCurveControl.GetSplits(TargetSheet, ParamEntity, srows, scols)
       
    If ParamEntity.IsFlag(CURVE_FLG_PIVOT) Then
        v = TargetSheet.Cells(srows + 1, scols + CCurveControl.HoriWidthTRANS(ParamEntity)).Resize(ParamEntity.ColumnCount - 1, 1).Value2
    Else
        v = TargetSheet.Cells(srows - IIf(ParamEntity.IsFlag(CURVE_FLG_FUTURE_RANGE) And ParamEntity.IsFlag(CURVE_FLG_MULTIOBS), 1, 0), scols + 1).Resize(1, ParamEntity.ColumnCount - 1).Value2
    End If
       
    If (VarType(v) And vbArray) = 0 Then
        ReDim ary(0)
        ary(0) = v
    Else
        k = IIf(ParamEntity.IsFlag(CURVE_FLG_PIVOT), 1, 2)
        ReDim ary(0 To UBound(v, k) - LBound(v, k))
        
        If ParamEntity.IsFlag(CURVE_FLG_PIVOT) Then
            For k = LBound(v, 1) To UBound(v, 1)
                ary(k - 1) = v(k, 1)
            Next
        Else
            For k = LBound(v, 2) To UBound(v, 2)
                ary(k - 1) = v(1, k)
            Next
        End If
    End If
    
    EffectiveDateList = ary
End Property
 
Public Function ToLocalDate(ByVal aTimeStr As String) As Date
 Dim tokens() As String
 Dim y As Long
 Dim m As Long
 Dim d As Long
 
    If aTimeStr = vbNullString Then
        Exit Function
    End If
    
    If InStr(aTimeStr, " ") <= 0 Then
        ToLocalDate = CDate(CDbl(aTimeStr))
    
    Else
        tokens = Split(aTimeStr, " ")
        
        y = CLng(tokens(0))
        m = y Mod 10000
        d = m Mod 100
        m = m \ 100
        y = y \ 10000
        
        ToLocalDate = DateSerial(y, m, d)
    End If
End Function

Public Function DisplayTime(dtValue As Variant, isTime As Boolean) As String
 Dim dt As Date

    If VarType(dtValue) = vbDate Then
        dt = dtValue
    ElseIf VarType(dtValue) = vbString Then
        dt = ToLocalDate(dtValue)
    End If
    If IsDateNull(dt) Then Exit Function
    
    DisplayTime = format(dt, IIf(isTime, "General Date", "Short Date"))
End Function

Public Function contractDate(granularities As Long, dateValue As Date) As Double
 Dim dte As Date
 Dim m As Long
 Dim y As Long
 Dim d As Long
 Dim h As Long
 Dim wd As Long
 
    y = year(dateValue)
    m = month(dateValue)
    d = day(dateValue)
    h = Hour(dateValue)
    
    If CCurveGranularity.IsGranularity(granularities, CURVE_GRANULARITY_MONTHLY) Then
        dte = DateSerial(y, m, 1)
        
    ElseIf CCurveGranularity.IsGranularity(granularities, CURVE_GRANULARITY_DAILY) Then
        dte = DateSerial(y, m, d)
        
    ElseIf CCurveGranularity.IsGranularity(granularities, CURVE_GRANULARITY_HOURLY) Then
        dte = DateSerial(y, m, d)
        dte = DateAdd("h", h, dte)
        
    ElseIf CCurveGranularity.IsGranularity(granularities, CURVE_GRANULARITY_WEEKLY) Then
        wd = WeekDay(dateValue)
        dte = DateSerial(y, m, d)
        If CCurveGranularity.IsGranularity(granularities, CURVE_GRANULARITY_WEEKDAY) Then
            If wd = 0 Or wd = 6 Then Err.Raise vbObjectError + 1, "ContractDate", "Wrong date for WEEKDAY " + format(dateValue, CDDXDates.SystemDateFormat)
            If wd <> 1 Then dte = DateAdd("d", 1 - wd, dte)
        ElseIf CCurveGranularity.IsGranularity(granularities, CURVE_GRANULARITY_WEEKEND) Then
            If wd <> 0 And wd <> 6 Then Err.Raise vbObjectError + 1, "ContractDate", "Wrong date for WEEKEND " + format(dateValue, CDDXDates.SystemDateFormat)
            If wd <> 6 Then dte = DateAdd("d", -1, dte)
        ElseIf CCurveGranularity.IsGranularity(granularities, CURVE_GRANULARITY_WEEKLY_SUN2SAT) Then
            If wd <> 0 Then dte = DateAdd("d", -wd, dte)
        ElseIf CCurveGranularity.IsGranularity(granularities, CURVE_GRANULARITY_WEEKLY_MON2SUN) Then
            If wd <> 1 Then dte = DateAdd("d", IIf(wd = 0, 7, wd) - 1, dte)
        End If
    ElseIf CCurveGranularity.IsGranularity(granularities, CURVE_GRANULARITY_QUARTERLY) Then
        dte = DateSerial(y, m \ 3 + IIf(m Mod 3 = 0, 0, 1), 1)
        
    ElseIf CCurveGranularity.IsGranularity(granularities, CURVE_GRANULARITY_HALFYEAR) Then
        dte = DateSerial(y, IIf(m >= 7, 7, 1), 1)
        
    ElseIf CCurveGranularity.IsGranularity(granularities, CURVE_GRANULARITY_YEARLY) Then
        dte = DateSerial(y, 1, 1)
        
    End If
    contractDate = CDbl(dte)
End Function

'Public Function effectiveDate(dateValue As Date) As Double
'    effectiveDate = Int(CDbl(dateValue))
'End Function

Public Function GetHandler(ByVal flgs As Long) As Object
    On Error GoTo OOPS

    If CDDXHelper.IsFlag(flgs, CURVE_FLG_MULTIOBS) Then
        If CDDXHelper.IsFlag(flgs, CURVE_FLG_FUTURE_RANGE) Then
            Set GetHandler = New CCPFutureMultiRange
        ElseIf CDDXHelper.IsFlag(flgs, CURVE_FLG_TIMESERIES) Then
            Set GetHandler = New CCPTimeSeries
        Else
            Set GetHandler = New CCPFutureMulti
        End If
        
    ElseIf CDDXHelper.IsFlag(flgs, CURVE_FLG_TIMESERIES) Then
        If CDDXHelper.IsFlag(flgs, CURVE_FLG_PIVOT) Then
            Set GetHandler = New CCPTimeSeriesTRANS2
        Else
            Set GetHandler = New CCPTimeSeries
        End If
    Else
        If CDDXHelper.IsFlag(flgs, CURVE_FLG_FUTURE_RANGE) Then
            Set GetHandler = New CCPFutureRange
 
        ElseIf CDDXHelper.IsFlag(flgs, CURVE_FLG_MRBD) Then
            Set GetHandler = New CCPFutureSingle
                
        ElseIf CDDXHelper.IsFlag(flgs, CURVE_FLG_PIVOT) Then
            Set GetHandler = New CCPFutureTRANS2
            
        Else
            Set GetHandler = New CCPFutureSingleEdit
            
        End If
    End If
    
OOPS:
    On Error GoTo 0
    Exit Function
End Function

Private Sub Class_Terminate()
    Call Cleanup
End Sub

Attribute VB_Name = "CCurveGranularity"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Const N_MIN1 As String = "Minute"
Private Const N_MIN5 As String = "5Min"
Private Const N_MIN10 As String = "10Min"
Private Const N_MIN15 As String = "15Min"
Private Const N_MIN30 As String = "30Min"
'
Private Const N_HOURLY As String = "Hourly"
Private Const N_DAILY As String = "Daily"
Private Const N_MONTHLY As String = "Monthly"
Private Const N_WEEKDAY As String = "Weekday"
Private Const N_WEEKEND As String = "Weekend"
Private Const N_WEEK_MON2SUN As String = "Weekly(Mon-Sun)"
Private Const N_WEEK_SUN2SAT As String = "Weekly(Sun-Sat)"
Private Const N_WEEKLY As String = "Weekly"
Private Const N_QUARTERLY As String = "Quarterly"
Private Const N_HALFYEAR As String = "Half Year"
Private Const N_YEARLY As String = "Annual"

Private Const size As Long = 32

Private m_granularity_names() As String
Private m_granularity_values(0 To size - 1) As Long
Private m_granularity_count As Long

Public Function GetGranularitiesBySheet(sht As Worksheet) As Long()
 Dim sr As Long
 Dim sc As Long
 Dim v As Variant
 Dim gvals() As Long
 Dim k As Long
 
    If CCurveDates.ParamEntity.rowCount <= 1 Then Exit Function
    
    Call CCurveControl.GetSplits(sht, CCurveDates.ParamEntity, sr, sc)
    v = sht.Cells(sr + 1, 2).Resize(CCurveDates.ParamEntity.rowCount - 1).Value2
    
    If Not IsArray(v) Then
        ReDim gvals(0)
        gvals(0) = GetGranularity(v)
    Else
        ReDim gvals(LBound(v, 1) - 1 To UBound(v, 1) - 1)
        For k = LBound(v, 1) To UBound(v, 1)
            gvals(k - 1) = GetGranularity(v(k, 1))
        Next
    End If
    
    GetGranularitiesBySheet = gvals
End Function

Public Sub RemoveDropdowns(sht As Worksheet)
' Dim f As Object
'
'    For Each f In sht.DropDowns
'        Call f.Delete
'    Next
    sht.Cells.Validation.Delete
End Sub

Public Sub EnableDropdowns(sht As Worksheet, ByVal enabled As Boolean)
' Dim f As Object
'
'    For Each f In sht.DropDowns
'        f.enabled = enabled
'    Next
End Sub

Private Sub SetContent(ByVal allGanularities As Long, ByVal gVal As Long, ByVal gname As String)
    If Not IsGranularity(allGanularities, gVal) Then Exit Sub
    
    m_granularity_names(m_granularity_count) = gname
    m_granularity_values(m_granularity_count) = gVal
    m_granularity_count = m_granularity_count + 1
End Sub

Public Sub CreateContents(ByVal allGanularities As Long)
    ReDim m_granularity_names(0 To (size - 1))

    m_granularity_count = 0
    
    Call SetContent(allGanularities, CURVE_GRANULARITY_MIN1, N_MIN1)
    Call SetContent(allGanularities, CURVE_GRANULARITY_MIN5, N_MIN5)
    Call SetContent(allGanularities, CURVE_GRANULARITY_MIN10, N_MIN10)
    Call SetContent(allGanularities, CURVE_GRANULARITY_MIN15, N_MIN15)
    Call SetContent(allGanularities, CURVE_GRANULARITY_MIN30, N_MIN30)

    Call SetContent(allGanularities, CURVE_GRANULARITY_HOURLY, N_HOURLY)
    Call SetContent(allGanularities, CURVE_GRANULARITY_DAILY, N_DAILY)

    If IsGranularity(allGanularities, CURVE_GRANULARITY_WEEKLY) Then
        If Not IsGranularity(allGanularities, CURVE_GRANULARITY_WEEKDAY) And _
           Not IsGranularity(allGanularities, CURVE_GRANULARITY_WEEKEND) And _
           Not IsGranularity(allGanularities, CURVE_GRANULARITY_WEEKLY_SUN2SAT) And _
           Not IsGranularity(allGanularities, CURVE_GRANULARITY_WEEKLY_MON2SUN) Then
            Call SetContent(allGanularities, CURVE_GRANULARITY_WEEKLY, N_WEEKLY)
        End If
        
        Call SetContent(allGanularities, CURVE_GRANULARITY_WEEKDAY, N_WEEKDAY)
        Call SetContent(allGanularities, CURVE_GRANULARITY_WEEKEND, N_WEEKEND)
        Call SetContent(allGanularities, CURVE_GRANULARITY_WEEKLY_SUN2SAT, N_WEEK_SUN2SAT)
        Call SetContent(allGanularities, CURVE_GRANULARITY_WEEKLY_MON2SUN, N_WEEK_MON2SUN)
    End If
    
    Call SetContent(allGanularities, CURVE_GRANULARITY_MONTHLY, N_MONTHLY)
    Call SetContent(allGanularities, CURVE_GRANULARITY_QUARTERLY, N_QUARTERLY)
    Call SetContent(allGanularities, CURVE_GRANULARITY_HALFYEAR, N_HALFYEAR)
    Call SetContent(allGanularities, CURVE_GRANULARITY_YEARLY, N_YEARLY)
    
    If m_granularity_count > 0 Then
        ReDim Preserve m_granularity_names(0 To m_granularity_count - 1)
    Else
        Erase m_granularity_names
    End If
End Sub

Public Sub SetContractDateFormat(rgn As range, gname As String)
 Dim gVal As Long
 Dim p As Boolean

    gVal = CCurveGranularity.GetGranularity(gname)
    If gVal = 0 Then Exit Sub
'
    p = rgn.Parent.ProtectContents
    If p Then Call CCurveControl.Unprotect(rgn.Parent)

    rgn.offset(, -1).NumberFormat = CDDXCurve.GetContractDateFormat(gVal)

    If p Then Call CCurveControl.Protect(rgn.Parent)
End Sub

Public Sub AddDropdowns(rgn As range)
    With rgn.Validation
        .Delete
        .Add Type:=xlValidateList, AlertStyle:=xlValidAlertStop, Operator:=xlBetween, Formula1:=Join(m_granularity_names, ",")
        .IgnoreBlank = True
        .InCellDropdown = True
'        .InputTitle = ""
'        .ErrorTitle = ""
'        .InputMessage = ""
'        .ErrorMessage = ""
        .ShowInput = True
        .ShowError = True
    End With
End Sub

Public Sub SetDropdownSelection(rgn As range, ByVal granularity As Long)
 Dim k As Long
 Dim idx As Long
 
    With rgn
        If granularity = CURVE_GRANULARITY_NONE Then
            idx = 0
        Else
            For k = m_granularity_count - 1 To 0 Step -1
                If m_granularity_values(k) = granularity Then
                    idx = k
                    Exit For
                End If
            Next
        End If
        
        If idx >= 0 Then
            .value = m_granularity_names(idx)
            Call SetContractDateFormat(rgn, m_granularity_names(idx))
        End If
    End With
End Sub

Public Sub AddDropdown(rgn As range, ByVal granularity As Long)
 Dim k As Long
 Dim idx As Long
 
    With rgn
        .value = vbNullString
        .Validation.Delete
 
        With .Validation
            .Add Type:=xlValidateList, AlertStyle:=xlValidAlertStop, Operator:=xlBetween, Formula1:=Join(m_granularity_names, ",")
        End With
        
        If granularity = CURVE_GRANULARITY_NONE Then
            idx = 0
        Else
            For k = m_granularity_count - 1 To 0 Step -1
                If m_granularity_values(k) = granularity Then
                    idx = k
                    Exit For
                End If
            Next
        End If
        
        If idx >= 0 Then
            .value = m_granularity_names(idx)
            Call SetContractDateFormat(rgn, m_granularity_names(idx))
        End If
    End With
End Sub

Public Sub RemoveDropdown(rgn As range)
    rgn.Validation.Delete
End Sub

Public Function IsGranularity(ByVal granularities As Long, ByVal value As Long) As Boolean
    IsGranularity = CDDXHelper.IsFlag(granularities, value)
End Function

Public Function GetGranularity(ByVal value As String) As Long
    If StrComp(value, N_HOURLY, vbTextCompare) = 0 Then
        GetGranularity = CURVE_GRANULARITY_HOURLY
    ElseIf StrComp(value, N_DAILY, vbTextCompare) = 0 Then
        GetGranularity = CURVE_GRANULARITY_DAILY
    ElseIf StrComp(value, N_MONTHLY, vbTextCompare) = 0 Then
        GetGranularity = CURVE_GRANULARITY_MONTHLY
    ElseIf StrComp(value, N_WEEKDAY, vbTextCompare) = 0 Then
        GetGranularity = CURVE_GRANULARITY_WEEKDAY
    ElseIf StrComp(value, N_WEEKEND, vbTextCompare) = 0 Then
        GetGranularity = CURVE_GRANULARITY_WEEKEND
    ElseIf StrComp(value, N_WEEK_MON2SUN, vbTextCompare) = 0 Then
        GetGranularity = CURVE_GRANULARITY_WEEKLY_MON2SUN
    ElseIf StrComp(value, N_WEEK_SUN2SAT, vbTextCompare) = 0 Then
        GetGranularity = CURVE_GRANULARITY_WEEKLY_SUN2SAT
    ElseIf StrComp(value, N_QUARTERLY, vbTextCompare) = 0 Then
        GetGranularity = CURVE_GRANULARITY_QUARTERLY
    ElseIf StrComp(value, N_HALFYEAR, vbTextCompare) = 0 Then
        GetGranularity = CURVE_GRANULARITY_HALFYEAR
    ElseIf StrComp(value, N_YEARLY, vbTextCompare) = 0 Then
        GetGranularity = CURVE_GRANULARITY_YEARLY
    ElseIf StrComp(value, N_WEEKLY, vbTextCompare) = 0 Then
        GetGranularity = CURVE_GRANULARITY_WEEKLY
    ElseIf StrComp(value, N_MIN1, vbTextCompare) = 0 Then
        GetGranularity = CURVE_GRANULARITY_MIN1
    ElseIf StrComp(value, N_MIN5, vbTextCompare) = 0 Then
        GetGranularity = CURVE_GRANULARITY_MIN5
    ElseIf StrComp(value, N_MIN10, vbTextCompare) = 0 Then
        GetGranularity = CURVE_GRANULARITY_MIN10
    ElseIf StrComp(value, N_MIN15, vbTextCompare) = 0 Then
        GetGranularity = CURVE_GRANULARITY_MIN15
    ElseIf StrComp(value, N_MIN30, vbTextCompare) = 0 Then
        GetGranularity = CURVE_GRANULARITY_MIN30
    End If
End Function

Public Function GetGranularityName(ByVal value As Long) As String
    If IsGranularity(value, CURVE_GRANULARITY_HOURLY) Then
        GetGranularityName = N_HOURLY
    ElseIf IsGranularity(value, CURVE_GRANULARITY_DAILY) Then
        GetGranularityName = N_DAILY
    ElseIf IsGranularity(value, CURVE_GRANULARITY_MONTHLY) Then
        GetGranularityName = N_MONTHLY
    ElseIf IsGranularity(value, CURVE_GRANULARITY_WEEKDAY) Then
        GetGranularityName = N_WEEKDAY
    ElseIf IsGranularity(value, CURVE_GRANULARITY_WEEKEND) Then
        GetGranularityName = N_WEEKEND
    ElseIf IsGranularity(value, CURVE_GRANULARITY_WEEKLY_MON2SUN) Then
        GetGranularityName = N_WEEK_MON2SUN
    ElseIf IsGranularity(value, CURVE_GRANULARITY_WEEKLY_SUN2SAT) Then
        GetGranularityName = N_WEEK_SUN2SAT
    ElseIf IsGranularity(value, CURVE_GRANULARITY_QUARTERLY) Then
        GetGranularityName = N_QUARTERLY
    ElseIf IsGranularity(value, CURVE_GRANULARITY_HALFYEAR) Then
        GetGranularityName = N_HALFYEAR
    ElseIf IsGranularity(value, CURVE_GRANULARITY_YEARLY) Then
        GetGranularityName = N_YEARLY
    ElseIf IsGranularity(value, CURVE_GRANULARITY_WEEKLY) Then
        GetGranularityName = N_WEEKLY
    ElseIf IsGranularity(value, CURVE_GRANULARITY_MIN1) Then
        GetGranularityName = N_MIN1
    ElseIf IsGranularity(value, CURVE_GRANULARITY_MIN5) Then
        GetGranularityName = N_MIN5
    ElseIf IsGranularity(value, CURVE_GRANULARITY_MIN10) Then
        GetGranularityName = N_MIN10
    ElseIf IsGranularity(value, CURVE_GRANULARITY_MIN15) Then
        GetGranularityName = N_MIN15
    ElseIf IsGranularity(value, CURVE_GRANULARITY_MIN30) Then
        GetGranularityName = N_MIN30
    End If
End Function
Attribute VB_Name = "CCurveHelper"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public Sub CollapseGroups(sht As Worksheet)
    Call SetGroupsState(sht, 1) '8 to expand
End Sub

Public Sub ExpandGroups(sht As Worksheet)
    Call SetGroupsState(sht, 8) 'to expand
End Sub

Private Sub SetGroupsState(sht As Worksheet, ByVal stateVal As Long)
    sht.Outline.ShowLevels RowLevels:=stateVal, ColumnLevels:=stateVal '8 to expand
End Sub

Public Sub GroupColumns(sht As Worksheet, ByVal startcol As Long, ByVal endCol As Long, ByVal isGroup As Boolean)
 Dim tmp As Long
 
    If Not (sht.Columns(startcol).OutlineLevel > 1 Xor isGroup) Then Exit Sub
    
    If startcol > endCol Then
        tmp = startcol
        startcol = endCol
        endCol = tmp
    End If

    With sht.Columns(CDDXUtility.IntegerToColmnLetter(startcol) + ":" + CDDXUtility.IntegerToColmnLetter(endCol)).Columns
        If isGroup Then
            Call .group
        Else
            Call .Ungroup
            'm_sheet.PrintOut
        End If
    End With
End Sub

Private Sub EnableGroupingSheet(sht As Worksheet)
 Dim fvs As Long
 
    On Error GoTo OOPS
    
    fvs = CDDXCurve.GetFVS(sht)
    If CDDXCurve.GetSheetVersion(fvs) < CDDXCurve.GetSheetVersion(CURVE_FLG_V2) Then Exit Sub
    
    Call CCurveControl.Unprotect(sht)
    Call CCurveControl.Protect(sht)
 
OOPS:
    If Err.Number <> 0 Then
        CDDXApp.StatusMessage = "EnableGroupingSheet : " + Err.Description
    End If
    Exit Sub
End Sub

Public Sub EnableGrouping(Wb As Workbook)
 Dim sht As Worksheet
 
    On Error GoTo OOPS
    
    If Wb.Readonly Then Exit Sub
    
    Call CXLEvents.DisableEvents
    
    For Each sht In Wb.Worksheets
        Call EnableGroupingSheet(sht)
    Next
  
OOPS:
    If Err.Number <> 0 Then
        CDDXApp.StatusMessage = "EnableGrouping: " + Err.Description
    End If
    
    Call CXLEvents.RestoreEvents
    Exit Sub
End Sub

Public Sub RemoveAllGroups(sht As Worksheet)
    On Error Resume Next
    
    With sht
        .Columns.Ungroup
        .rows.Ungroup
    End With
    
    On Error GoTo 0
End Sub
Attribute VB_Name = "CCurveImageText"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public Event OnImage(sender As Object, ByVal aTarget As Integer, ByVal aUserData As String, ByRef aPicturePath As String, ByRef aWidth As Single, ByRef aHeight As Single)
Public Event OnText(sender As Object, ByVal aTarget As Integer, ByVal aUserData As String, ByRef aText As String, ByRef aBold As Boolean, ByRef aToolTip As String, ByRef aTop As Long, ByRef aLeft As Long)
Public Event OnMacro(sender As Object, ByVal aTarget As Integer, ByVal aUserData As String, ByRef aMacro As String)
Public Event OnImagePlacement(sender As Object, ByVal aTarget As Integer, ByVal aUserData As String, ByRef aTop As Single, ByRef aLeft As Single, ByRef aWidth As Single, ByRef aHeight As Single)
Public Event OnImageBackColor(sender As Object, ByVal aTarget As Integer, ByRef bkColor As Long)

Private Const OBS_INDICATOR_PATH As String = "CurveCMStatus.bmp" ' "CurveObsIndicator.PNG"
Private Const OPR_DELETE_BEFORE_ADD As Long = &H1

Public AlternativeText As String

Private m_sheet As Worksheet

Private m_Target As Integer
'Private m_Placement As Integer

Private m_PicturePath As String   'source picture path
Private m_Text As String '
Private m_Bold As Boolean
Private m_FontSize As Single 'text size
Private m_tooltip As String
Private m_tooltip_Top As Long
Private m_tooltip_Left As Long

Private m_Action As String 'n/a
Private m_Top As Single 'n/a
Private m_Left As Single 'n/a
Private m_Width As Single 'n/a
Private m_Height As Single 'n/a
Private m_Button_Width As Single 'n/a
Private m_Button_Height As Single 'n/a
'
Private m_ResultImagePath As String 'result file path
Private m_Kill As Boolean

Private m_ShpCount As Long
Private m_ImgPath As String

Dim m_Images As Scripting.Dictionary

Public Property Set sheet(value As Worksheet)
    Set m_sheet = value

    If m_sheet Is Nothing Then Exit Property
    If m_sheet.Shapes Is Nothing Then Exit Property
    
    If (m_ShpCount And &H10) = 0 Then
        m_ShpCount = &H10 Or IIf(m_sheet.Shapes.count > 0, OPR_DELETE_BEFORE_ADD, 0)
    End If
End Property

Public Property Let DeleteExsitingBeforeAdd(value As Boolean)
    If value Then
        m_ShpCount = m_ShpCount Or OPR_DELETE_BEFORE_ADD
    Else
        m_ShpCount = m_ShpCount And (Not OPR_DELETE_BEFORE_ADD)
    End If
End Property

Private Sub DeleteShape(shp As Shape)
 Dim nm As String
 Dim row As Long
 Dim col As Long
 
    nm = left(shp.name, InStr(shp.name, "_") - 1)
    If Len(nm) = 9 Then
        nm = right(nm, 8)
        row = CLng(left(nm, 4))
        col = CLng(right(nm, 4))
    End If
    
    If row > 0 And col > 0 Then
        If Not m_sheet.Cells(row, col).Comment Is Nothing Then
            m_sheet.Cells(row, col).Comment.Delete
        End If
        m_sheet.Cells(row, col).Validation.Delete
    End If
    
    shp.Delete
End Sub

Public Sub RemoveImages(ByVal aAlternativeTextPattern As String)
 Dim s As Shape
 
    For Each s In m_sheet.Shapes
        If s.AlternativeText Like aAlternativeTextPattern + "*" Then
            Call DeleteShape(s)
        End If
    Next
End Sub

Public Function DeleteImage(ByVal targetImage As Long) As Boolean
 Dim s As Shape
 
    For Each s In m_sheet.Shapes
        If s.name Like "N*_" + CStr(targetImage) Then
            Call DeleteShape(s)
            DeleteImage = True
            Exit For
        End If
    Next
End Function

Public Function GetImageID(ByVal targetMajor As Long, ByVal targetMinor As Long) As Long
    GetImageID = 1000 * targetMajor + IIf(targetMinor > 0, targetMinor, 0)
End Function

Public Function FindImage(ByVal targetImage As Long) As Shape
 Dim s As Shape
 
    For Each s In m_sheet.Shapes
        If s.name Like "N*_" + CStr(targetImage) Then
            Set FindImage = s
            Exit Function
        End If
    Next
End Function

Private Function DupImage(indexName As String) As Shape
 Dim s As Shape
 
    On Error GoTo OOPS
    
    If m_Images Is Nothing Then Exit Function
    If Not m_Images.Exists(indexName) Then Exit Function
    
    Set s = m_Images(indexName)
    Set DupImage = s.Duplicate
        
OOPS:
    If Err.Number <> 0 Then
        CDDXApp.DebugMessage = indexName + ":  " + Err.Description
    End If
    Exit Function
End Function

Private Sub AddImage(indexName As String, s As Shape)
    On Error GoTo OOPS
    
    If m_Images.Exists(indexName) Then Call m_Images.Remove(indexName)
    Call m_Images.Add(indexName, s)
    
OOPS:
    If Err.Number <> 0 Then
        CDDXApp.DebugMessage = indexName + ":  " + Err.Description
    End If
    Exit Sub
End Sub

Private Sub DrawObservationIndicator(ByVal aAlternativeText As String)
 Dim s As Shape
 Dim rgn As range
 Const siz As Long = 12
 
    If m_tooltip = vbNullString Then Exit Sub
    
    On Error GoTo OOPS
    
    Set rgn = m_sheet.Cells(m_tooltip_Top, m_tooltip_Left + IIf(CCurveDates.ParamEntity.IsFlag(CURVE_FLG_MRBD), 1, 0))
    
    Set s = DupImage(OBS_INDICATOR_PATH)
    If Not s Is Nothing Then
        With s
            .left = rgn.left + rgn.Width - siz
            .top = rgn.top
        End With
    Else
        Set s = m_sheet.Shapes.AddPicture(m_ImgPath + OBS_INDICATOR_PATH, msoFalse, msoTrue, rgn.left + rgn.Width - siz, rgn.top, siz, siz)
        Call AddImage(OBS_INDICATOR_PATH, s)
    End If

    With s
        .name = "N" + IIf(m_tooltip <> vbNullString, format(m_tooltip_Top, "0000") + format(m_tooltip_Left, "0000"), vbNullString) + "_" + CStr(m_Target) + "_I"
'        .Visible = True
        .AlternativeText = AlternativeText
'        .Placement = m_Placement
    End With
    
OOPS:
    If Err.Number <> 0 Then
        CDDXApp.StatusMessage = Err.Description
    End If
    Exit Sub
End Sub

Private Sub DrawCurveName()
 Dim s As Shape
 
    If m_sheet.Parent.MultiUserEditing Then Exit Sub
    
    If (m_ShpCount And OPR_DELETE_BEFORE_ADD) <> 0 Then Call DeleteImage(m_Target)
    
    If m_ResultImagePath <> vbNullString Then
        Set s = DupImage(m_PicturePath)
        If Not s Is Nothing Then
            With s
                .left = m_Left
                .top = m_Top
            End With
        Else
            Set s = m_sheet.Shapes.AddPicture(m_ResultImagePath, msoFalse, msoTrue, m_Left, m_Top, m_Width, m_Height)
            Call AddImage(m_PicturePath, s)
        End If
        
        With s
            .name = "N" + IIf(m_tooltip <> vbNullString, format(m_tooltip_Top, "0000") + format(m_tooltip_Left, "0000"), vbNullString) + "_" + CStr(m_Target)
            If m_Action <> vbNullString Then
                .OnAction = m_Action
            End If
'            .Visible = True
            .AlternativeText = AlternativeText
'            .Placement = m_Placement
        End With
        
        If m_Kill Then
            Kill m_ResultImagePath
        End If
    End If
    
    Call DrawObservationIndicator(AlternativeText)
End Sub

Public Sub Draw(ByVal aTarget As Integer, ByVal aUserData As String, Optional isMove As Variant = xlMove) 'xlFreeFloating)
    m_Target = aTarget
'    m_Placement = isMove
    
    If IsNumeric(aUserData) Then
        m_Target = GetImageID(m_Target, Int(Val(aUserData)))
    End If
    
    RaiseEvent OnImage(Me, aTarget, aUserData, m_PicturePath, m_Button_Width, m_Button_Height)
    RaiseEvent OnText(Me, aTarget, aUserData, m_Text, m_Bold, m_tooltip, m_tooltip_Top, m_tooltip_Left)
    RaiseEvent OnMacro(Me, aTarget, aUserData, m_Action)
    RaiseEvent OnImagePlacement(Me, aTarget, aUserData, m_Top, m_Left, m_Width, m_Height)

    If m_Text = vbNullString And m_PicturePath = vbNullString Then
        m_Kill = True
        m_ResultImagePath = vbNullString
    Else
        m_Kill = False
        If m_PicturePath = vbNullString Then
            m_ResultImagePath = vbNullString
        Else
            m_ResultImagePath = m_ImgPath + m_PicturePath
        End If
    End If
    
    Call DrawCurveName
End Sub

Private Sub Class_Initialize()
    m_ImgPath = CCurveControl.GetImagesDir()
    m_ShpCount = 0
    
    Set m_Images = New Scripting.Dictionary
    
    With CDDXLib.DefaultZEWSProxy(DDX_PID)
        m_ResultImagePath = .HelperResultsetFileName(.NewGUID(), 0) + ".png"
    End With
End Sub

Private Sub Class_Terminate()
    Set m_Images = Nothing
End Sub
Attribute VB_Name = "CCurveParams"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Type TCuvreInfo
    curve As String
    dlt As String
    ult As String
    permissions As String
    obs As String
    numerators As String
    denominators As String
    tz As String
    propVals() As String
End Type

Private Const C_ROOT As String = "/CurvePortal/"
Private Const C_VER As String = "4.13"

Private Const C_NAME As Integer = 1
Private Const C_OBS As Integer = 2
Private Const C_DLT As Integer = 3
Private Const C_ULT As Integer = 4
Private Const C_PERM As Integer = 5
Private Const C_PROPVALS As Integer = 6
Private Const C_TZ As Integer = 7

Public sheetId As String
Public granularities As Long
Public exclHolidays As String
Public exclWeekEnds As String
'
Public rowCount As Long
Public ColumnCount As Long
'
Public flagValues As Long
Public TZName As String
'
Private m_Xml As New ZEWSXml
Private m_CurveInfo() As TCuvreInfo
Private m_PropertyNames()  As String
Private m_CurveTypes() As String
'Private m_CurveTypesHeader() As String
'
Public OprStartDate As Date
Public OprEndDate As Date

Public Property Get curveTypes() As String()
    curveTypes = m_CurveTypes
End Property

'Public Property Get CurveTypesHeader() As String()
'    CurveTypesHeader = m_CurveTypesHeader
'End Property

Public Property Get PropertyNames() As String()
    PropertyNames = m_PropertyNames
End Property

Private Function SetArray(ByVal aItem As Integer, value() As String)
 Dim k As Integer
 
    For k = LBound(m_CurveInfo) To UBound(m_CurveInfo)
        Select Case aItem
            Case C_NAME: m_CurveInfo(k).curve = value(k)
            Case C_OBS: m_CurveInfo(k).obs = value(k)
            Case C_DLT: m_CurveInfo(k).dlt = value(k)
            Case C_ULT: m_CurveInfo(k).ult = value(k)
            Case C_PERM: m_CurveInfo(k).permissions = value(k)
            Case C_TZ: m_CurveInfo(k).tz = value(k)
        End Select
    Next
End Function

Private Function GetArray(ByVal aItem As Integer, Optional value As String) As String()
 Dim tmp() As String
 Dim k As Integer
 
    If GetCurveCount() <= 0 Then
        GetArray = tmp
        Exit Function
    End If
    
    If aItem = C_PROPVALS Then
        For k = LBound(m_CurveInfo) To UBound(m_CurveInfo)
            If StrComp(value, m_CurveInfo(k).curve) = 0 Then
                GetArray = m_CurveInfo(k).propVals
                Exit For
            End If
        Next
        Exit Function
    End If
    
    ReDim tmp(UBound(m_CurveInfo))
    For k = LBound(m_CurveInfo) To UBound(m_CurveInfo)
        If m_CurveInfo(k).curve = vbNullString Then Exit For
        
        Select Case aItem
            Case C_NAME: tmp(k) = m_CurveInfo(k).curve
            Case C_OBS: tmp(k) = m_CurveInfo(k).obs
            Case C_DLT: tmp(k) = m_CurveInfo(k).dlt
            Case C_ULT: tmp(k) = m_CurveInfo(k).ult
            Case C_PERM: tmp(k) = m_CurveInfo(k).permissions
            Case C_TZ: tmp(k) = m_CurveInfo(k).tz
        End Select
    Next
    
    GetArray = tmp
End Function

Public Property Get curves() As String()
    curves = GetArray(C_NAME)
End Property

Public Property Get PropertyValues(ByVal curveNm As String) As String()
 Dim k As Long
 Dim ary() As String
 
    ary = GetArray(C_PROPVALS, curveNm)
    
    On Local Error GoTo OOPS
    
    For k = LBound(ary) To UBound(ary)
        If ary(k) = vbNullString Then
            ary(k) = " "
        End If
    Next
OOPS:
    PropertyValues = ary
End Property

Private Function FindCurveIndex(curveNm As String) As Long
 Dim idx As Long
 
    For idx = LBound(m_CurveInfo) To UBound(m_CurveInfo)
        If StrComp(m_CurveInfo(idx).curve, curveNm, vbBinaryCompare) = 0 Then
            FindCurveIndex = idx
            Exit Function
        End If
    Next
    FindCurveIndex = -1
End Function

Public Property Get obsTypes(ByVal curveNm As String) As String()
 Dim idx As Long
 Dim ary() As String
 Dim tmp() As String
 
    On Error GoTo OOPS
    
    idx = FindCurveIndex(curveNm)
    If idx < 0 Then Exit Property
    If m_CurveInfo(idx).obs = vbNullString Then Exit Property
    
    tmp = Split(m_CurveInfo(idx).obs, vbTab)
    ReDim ary(0 To UBound(tmp) \ 2)
    For idx = 1 To UBound(tmp) Step 2
        ary(idx \ 2) = tmp(idx)
    Next
    obsTypes = ary
    
OOPS:
    If Err.Number <> 0 Then
        CDDXApp.StatusMessage = Err.Description + " (ObsTypes)"
    End If
    On Error GoTo 0
    Exit Property
End Property

Public Property Get ObsNumerators(ByVal curveNm As String) As String()
 Dim idx As Long
 Dim ary() As String
 
    On Error GoTo OOPS
    
    idx = FindCurveIndex(curveNm)
    If idx < 0 Then Exit Property
    If m_CurveInfo(idx).numerators = vbNullString Then Exit Property
    ObsNumerators = Split(m_CurveInfo(idx).numerators + vbTab, vbTab)
    
OOPS:
    If Err.Number <> 0 Then
        CDDXApp.StatusMessage = Err.Description + " (ObsNumerators)"
    End If
    On Error GoTo 0
    Exit Property
End Property

Public Property Get ObsDenominators(ByVal curveNm As String) As String()
 Dim idx As Long
 Dim ary() As String
 
    On Error GoTo OOPS
    
    idx = FindCurveIndex(curveNm)
    If idx < 0 Then Exit Property
    If m_CurveInfo(idx).denominators = vbNullString Then Exit Property
    ObsDenominators = Split(m_CurveInfo(idx).denominators + vbTab, vbTab)
    
OOPS:
    If Err.Number <> 0 Then
        CDDXApp.StatusMessage = Err.Description + " (ObsDenominators)"
    End If
    On Error GoTo 0
    Exit Property
End Property

Public Property Get LastDownloadTime() As String()
    LastDownloadTime = GetArray(C_DLT)
End Property

Public Property Get LastUploadTime() As String()
    LastUploadTime = GetArray(C_ULT)
End Property

Public Property Get Readonly(ByVal aPos As Integer) As Boolean
    Readonly = IIf(InStr(m_CurveInfo(aPos).permissions, "R") > 0, True, False)
End Property

Public Sub SetReadonly(ByVal aPos As Integer, ByVal isSet As Boolean)
 Dim p As Long
 
    p = InStr(m_CurveInfo(aPos).permissions, "R")
    
    If isSet Then
        If p > 0 Then Exit Sub
        m_CurveInfo(aPos).permissions = m_CurveInfo(aPos).permissions + "R"
    Else
        If p <= 0 Then Exit Sub
        m_CurveInfo(aPos).permissions = Replace(m_CurveInfo(aPos).permissions, "R", vbNullString)
    End If
End Sub

Public Property Let LastUploadTime(value() As String)
    Call SetArray(C_ULT, value)
End Property

Public Property Let LastDownloadTime(value() As String)
    Call SetArray(C_DLT, value)
End Property

Private Function GetFromXml(ByVal aTag As String) As String
 Dim v() As String
    
    v = m_Xml.SelectTexts(C_ROOT + aTag)
    GetFromXml = v(LBound(v))
End Function

Private Function GetArrayFromXML(ByVal aTag As String) As String()
    GetArrayFromXML = m_Xml.SelectTexts(C_ROOT + aTag + "/i")
End Function

Private Sub GetCurves()
 Dim k As Long
 Dim cnt As Long
 Dim hasprops As Boolean
 Dim nodes As MSXML2.IXMLDOMNodeList
 Dim nd As MSXML2.IXMLDOMNode
 Dim attrbs As Variant
 Dim attr As MSXML2.IXMLDOMAttribute
 
    Erase m_CurveInfo
    Set nodes = m_Xml.SelectNodes(C_ROOT + "Curves/i")
    If nodes Is Nothing Then Exit Sub 'fool-proof
    cnt = nodes.length - 1
    If cnt < 0 Then Exit Sub
    
    ReDim m_CurveInfo(cnt)
    
    m_PropertyNames = m_Xml.SelectTexts(C_ROOT + "Properties/n")
    hasprops = IIf(Len(Join(m_PropertyNames)) > 0, True, False)
    
    For k = 0 To cnt
        Set nd = nodes(k)
        Set attrbs = nd.Attributes
        
        m_CurveInfo(k).curve = nd.text
        
        Set attr = attrbs.getNamedItem("dlt")
        If Not attr Is Nothing Then m_CurveInfo(k).dlt = attr.text
        
        Set attr = attrbs.getNamedItem("ult")
        If Not attr Is Nothing Then m_CurveInfo(k).ult = attr.text
        
        Set attr = attrbs.getNamedItem("perm")
        If Not attr Is Nothing Then m_CurveInfo(k).permissions = attr.text
       
        Set attr = attrbs.getNamedItem("tz")
        If Not attr Is Nothing Then m_CurveInfo(k).tz = attr.text
         
        Set attr = attrbs.getNamedItem("obs")
        If Not attr Is Nothing Then m_CurveInfo(k).obs = attr.text
       
        Set attr = attrbs.getNamedItem("ns")
        If Not attr Is Nothing Then m_CurveInfo(k).numerators = attr.text
       
        Set attr = attrbs.getNamedItem("ds")
        If Not attr Is Nothing Then m_CurveInfo(k).denominators = attr.text
       
        If hasprops Then
            m_CurveInfo(k).propVals = m_Xml.SelectTexts(C_ROOT + "Properties/i[@curve=" + CDDXHelper.EscXPATHExpr(m_CurveInfo(k).curve) + "]/p")
        End If
    Next
End Sub

'Private Sub GetCurveAttributes(ByVal aCurve As String, ByRef aDLT As String, ByRef aULT As String, ByRef aObs As String, ByRef aPerm As String, ByRef aTZ As String)
'    aDLT = m_Xml.SelectAttribute(C_ROOT + "Curves/i[text()=" + CDDXHelper.EscXPATHExpr(aCurve) + "]", "dlt")
'    aULT = m_Xml.SelectAttribute(C_ROOT + "Curves/i[text()=" + CDDXHelper.EscXPATHExpr(aCurve) + "]", "ult")
'    aObs = m_Xml.SelectAttribute(C_ROOT + "Curves/i[text()=" + CDDXHelper.EscXPATHExpr(aCurve) + "]", "obs")
'    aPerm = m_Xml.SelectAttribute(C_ROOT + "Curves/i[text()=" + CDDXHelper.EscXPATHExpr(aCurve) + "]", "perm")
'    aTZ = m_Xml.SelectAttribute(C_ROOT + "Curves/i[text()=" + CDDXHelper.EscXPATHExpr(aCurve) + "]", "tz")
'End Sub

Private Function GetGranularities(granu As String) As Long
    GetGranularities = Val(granu)
    
    If GetGranularities <= 0 Then
        If StrComp(granu, "monthly", vbTextCompare) = 0 Then
            GetGranularities = CURVE_GRANULARITY_MONTHLY
        ElseIf StrComp(granu, "daily", vbTextCompare) = 0 Then
            GetGranularities = CURVE_GRANULARITY_DAILY
        ElseIf StrComp(granu, "hourly", vbTextCompare) = 0 Then
            GetGranularities = CURVE_GRANULARITY_HOURLY
        End If
    End If
End Function

Public Sub FromXML(ByVal aCurveInfo As String)
    If Not m_Xml.LoadXML(aCurveInfo) Then
        Exit Sub
    End If

    sheetId = GetFromXml("SheetID")
    Call GetCurves
    
    OprStartDate = CCurveDates.ToLocalDate(GetFromXml("StartDate"))
    OprEndDate = CCurveDates.ToLocalDate(GetFromXml("EndDate"))
    exclWeekEnds = GetFromXml("ExclWeekends")
    exclHolidays = GetFromXml("ExclHolidays")
    '
    'SelectedGranularities = GetGranularities(GetFromXml("Granularity"))
    granularities = Val(GetFromXml("Granularities"))
    If granularities = CURVE_GRANULARITY_NONE Then
        granularities = GetGranularities(GetFromXml("Granularity"))
    End If
    '
    rowCount = Val(GetFromXml("Rows"))
    ColumnCount = Val(GetFromXml("Columns"))
    '
    flagValues = Val(GetFromXml("FlagValues"))
    TZName = GetFromXml("TZName")
    m_CurveTypes = Split(GetFromXml("CurveTypes"), vbTab)
'    m_CurveTypesHeader = Split(GetFromXml("CurveTypesHeader"), vbTab)
End Sub

Public Function ToXML() As String
 Dim k As Long
 Dim j As Long
 Dim xml As New ZEWSXml
 Dim node As MSXML2.IXMLDOMElement
 Dim node2 As MSXML2.IXMLDOMElement
 
    If GetCurveCount() <= 0 Then
        Exit Function
    End If
    
    With xml
        Call .CreateRootElement("CurvePortal", C_VER)
        
        Call .CreateTextNode2(Nothing, "SheetID", sheetId)
        Call .CreateTextNode2(Nothing, "Granularities", CStr(granularities))
        Call .CreateTextNode2(Nothing, "Rows", CStr(rowCount))
        Call .CreateTextNode2(Nothing, "Columns", CStr(ColumnCount))

        Call .CreateTextNode2(Nothing, "StartDate", CStr(CDbl(OprStartDate)))
        Call .CreateTextNode2(Nothing, "EndDate", CStr(CDbl(OprEndDate)))
        Call .CreateTextNode2(Nothing, "ExclWeekends", exclWeekEnds)
        Call .CreateTextNode2(Nothing, "ExclHolidays", exclHolidays)
        '
        Call .CreateTextNode2(Nothing, "FlagValues", CDDXHelper.ToHexStr(flagValues))
        Call .CreateTextNode2(Nothing, "TZName", TZName)
        
        Call .CreateTextNode2(Nothing, "CurveTypes", Join(m_CurveTypes, vbTab))
'        Call .CreateTextNode2(nothing, "CurveTypesHeader", Join(m_CurveTypesHeader, vbTab))
        
        Set node = .Createlement2(Nothing, "Curves")
        For k = LBound(m_CurveInfo) To UBound(m_CurveInfo)
            If m_CurveInfo(k).curve = vbNullString Then Exit For
            
            Set node2 = .CreateTextNode2(node, "i", m_CurveInfo(k).curve)
            If m_CurveInfo(k).dlt <> vbNullString Then
                Call .AddAttribute2(node2, "dlt", m_CurveInfo(k).dlt)
            End If
            If m_CurveInfo(k).ult <> vbNullString Then
                Call .AddAttribute2(node2, "ult", m_CurveInfo(k).ult)
            End If
            
            Call .AddAttribute2(node2, "obs", m_CurveInfo(k).obs)
            Call .AddAttribute2(node2, "perm", m_CurveInfo(k).permissions)
            Call .AddAttribute2(node2, "tz", m_CurveInfo(k).tz)
            Call .AddAttribute2(node2, "ns", m_CurveInfo(k).numerators)
            Call .AddAttribute2(node2, "ds", m_CurveInfo(k).denominators)
        Next
        
        If Len(Join(m_PropertyNames)) <> 0 Then
            Set node = .Createlement2(Nothing, "Properties")
            
            For k = LBound(m_PropertyNames) To UBound(m_PropertyNames)
                Call .CreateTextNode2(node, "n", m_PropertyNames(k))
            Next
            
            For k = LBound(m_CurveInfo) To UBound(m_CurveInfo)
                If m_CurveInfo(k).curve = vbNullString Then Exit For
                
                Set node2 = .Createlement2(node, "i")
                Call .AddAttribute2(node2, "curve", m_CurveInfo(k).curve)
                
                For j = LBound(m_CurveInfo(k).propVals) To UBound(m_CurveInfo(k).propVals)
                    Call .CreateTextNode2(node2, "p", m_CurveInfo(k).propVals(j))
                Next
            Next
        End If
        
        ToXML = .ToString()
    End With
    
    Set xml = Nothing
End Function

Public Sub RemoveCurve(ByVal aPos As Integer)
 Dim ED() As String
 Dim k As Integer
 
    For k = aPos To UBound(m_CurveInfo) - 1
        m_CurveInfo(k) = m_CurveInfo(k + 1)
    Next
    
    If UBound(m_CurveInfo) - 1 >= LBound(m_CurveInfo) Then
        ReDim Preserve m_CurveInfo(UBound(m_CurveInfo) - 1)
    Else
        Erase m_CurveInfo
    End If
End Sub

Public Function GetCurveCount() As Integer
Dim k As Integer

    On Local Error GoTo OOPS
    
    For k = LBound(m_CurveInfo) To UBound(m_CurveInfo)
        If m_CurveInfo(k).curve = vbNullString Then Exit For
        GetCurveCount = GetCurveCount + 1
    Next
    
OOPS:
    On Local Error GoTo 0
    Exit Function
End Function

Public Function IsFlag(ByVal value As Long) As Boolean
    IsFlag = CDDXHelper.IsFlag(flagValues, value)
End Function

Public Function AllCurvesRD() As Boolean
 Dim k As Long
 
    For k = 0 To GetCurveCount() - 1
        If Not Readonly(k) Then
            Exit Function
        End If
    Next
    
    AllCurvesRD = True
End Function

Public Property Get PropertyCount() As Long
    If Len(Join(PropertyNames)) > 0 Then
        PropertyCount = UBound(PropertyNames) - LBound(PropertyNames) + 1
    End If
End Property

Public Function GetCurvePosition(ByVal aCurveName As String)
 Dim k As Long
 Dim cn() As String

    cn = curves

    If Len(Join(cn)) > 0 Then
        For k = LBound(cn) To UBound(cn)
            If StrComp(aCurveName, cn(k), vbBinaryCompare) = 0 Then
                GetCurvePosition = k
                Exit Function
            End If
        Next
    End If
    GetCurvePosition = -1
End Function

Public Function GetTooltipByPosition(ByVal nPos As Long) As String
    If Not IsFlag(CURVE_FLG_PIVOT) Then
        GetTooltipByPosition = m_CurveInfo(nPos).curve
    End If
End Function

Public Function GetObservationInfoByName(ByVal value As String) As String
 Dim obs() As String
 Dim numerators() As String
 Dim denominators() As String
 Dim k As Long
 Dim p As Long
 
    On Error GoTo OOPS
    
    p = FindCurveIndex(value)
    'If Not IsFlag(CURVE_FLG_MULTIOBS) Then Exit Function
 
    With m_CurveInfo(p)
        obs = Split(.obs, vbTab)
        If Len(Join(obs)) = 0 Then Exit Function

        numerators = ObsNumerators(.curve)
        denominators = ObsDenominators(.curve)
        If Len(Join(numerators)) = 0 And Len(Join(denominators)) = 0 Then Exit Function

        For k = 0 To (UBound(obs) - LBound(obs) + 1) \ 2 - 1
            If k > LBound(obs) Then GetObservationInfoByName = GetObservationInfoByName + vbLf
            GetObservationInfoByName = GetObservationInfoByName + IIf(k = 0, vbNullString, vbLf) + "Curve Type" + vbTab + obs(2 * k + 1)
            GetObservationInfoByName = GetObservationInfoByName + vbLf + "Contract Type" + vbTab + CCurveGranularity.GetGranularityName(Val(obs(2 * k)))
            
            GetObservationInfoByName = GetObservationInfoByName + vbLf + "Numerator" + vbTab
            If Len(Join(numerators)) > 0 Then
                GetObservationInfoByName = GetObservationInfoByName + numerators(2 * k + 1) + vbTab + numerators(2 * k)
            Else
                GetObservationInfoByName = GetObservationInfoByName + vbTab
            End If
            
            GetObservationInfoByName = GetObservationInfoByName + vbLf + "Denominator" + vbTab
            If Len(Join(denominators)) > 0 Then
                GetObservationInfoByName = GetObservationInfoByName + denominators(2 * k + 1) + vbTab + denominators(2 * k)
            Else
                GetObservationInfoByName = GetObservationInfoByName + vbTab
            End If
        Next
        GetObservationInfoByName = GetObservationInfoByName + vbTab
    End With
    
OOPS:
    If Err.Number <> 0 Then
        CDDXApp.StatusMessage = Err.Description
    End If
    Exit Function
End Function

Public Function GetFirstWritableCurve() As String
 Dim k As Long
 
    For k = LBound(m_CurveInfo) To UBound(m_CurveInfo)
        If Len(m_CurveInfo(k).permissions) = 0 Then
            GetFirstWritableCurve = m_CurveInfo(k).curve
            Exit For
        End If
    Next
End Function

Public Sub GetCurveAccessTimes(ByVal curveIdx As Long, dlt As String, ult As String)
    If curveIdx < LBound(m_CurveInfo) Or curveIdx > UBound(m_CurveInfo) Then
        dlt = vbNullString
        ult = vbNullString
    Else
        With m_CurveInfo(curveIdx)
            dlt = .dlt
            ult = .ult
        End With
    End If
End Sub

Private Function DeleteAt(pAry() As String, ByVal pidx As Long) As String()
 Dim k As Long
 Dim p As Long
 Dim ret() As String
    
    If UBound(pAry) = 0 Then Exit Function
    ReDim ret(0 To UBound(pAry) - 1)
    
    For k = LBound(pAry) To UBound(pAry)
        If k <> pidx Then
            ret(p) = pAry(k)
            p = p + 1
        End If
    Next
    
    DeleteAt = ret
End Function

Public Sub RemoveProperty(ByVal propName As String)
 Dim p As Long
 Dim k As Long

    For p = LBound(m_PropertyNames) To UBound(m_PropertyNames)
        If StrComp(m_PropertyNames(p), propName) = 0 Then Exit For
    Next
    If p > UBound(m_PropertyNames) Then Exit Sub
    
    m_PropertyNames = DeleteAt(m_PropertyNames, p)

    For k = LBound(m_CurveInfo) To UBound(m_CurveInfo)
        m_CurveInfo(k).propVals = DeleteAt(m_CurveInfo(k).propVals, p)
    Next
End Sub

Private Sub Class_Terminate()
    Set m_Xml = Nothing
End Sub
Attribute VB_Name = "CCurveSort"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
 
Private m_params As CCurveParams
Private m_range As range
'

Public Function Execute(aDataRgn As range, ByVal aColumn As Long, params As CCurveParams) As Boolean
 Dim fr As Long
 Dim fc As Long
 
    If aDataRgn Is Nothing Then Exit Function
    If aDataRgn.rows.count <= 1 Then Exit Function
    
    fr = ActiveCell.row
    fc = ActiveCell.column
    
    Set m_params = params
    Set m_range = aDataRgn 'ccurvecontrol.GetCurveRange( ActiveSheet)
 
    If aColumn <= 1 Then
        If Not ByDates() Then Exit Function 'sort by contract dates
    Else
        If Not ByColors(aColumn) Then Exit Function 'sort by colors
    End If

    If fr > 0 And fc > 0 Then
        Call aDataRgn.Parent.Cells(fr, fc).Select
    End If
    
    Execute = True
End Function

Private Function ByDates() As Boolean
 Dim dates
 Dim k As Long
 Dim m As Long
 Dim p As Long
 Dim tmp As String
 
    dates = m_range.Columns(1).Value2
       
    For k = LBound(dates, 1) To UBound(dates, 1)
        p = k
        For m = k + 1 To UBound(dates, 1)
            If dates(p, 1) > dates(m, 1) Then
                p = m
            End If
        Next
        If p <> k Then
            Call SwapRows(k, p)
            dates = m_range.Columns(1).Value2
            ByDates = True
        End If
    Next
End Function

Private Function GetRowsByColorIndex(ByVal aColumn As Long, ByVal clrIndex As Long, ByRef count As Long) As Long()
 Dim FirstCell As range
 Dim rgn As range
 Dim ptr As Long
 Dim rn() As Long
 Dim k As Long
 Dim j As Long
 Dim fr As Long
 Const incr As Long = 128
 
    count = 0
    
    With Application.FindFormat
        .Clear
        .Font.ColorIndex = clrIndex
    End With

    Set rgn = m_range.offset(-1, aColumn - 1).Resize(m_range.rows.count + 1, 1)
    
    Set FirstCell = rgn.Find(what:=vbNullString, After:=rgn.Cells(1, 1), LookIn:=xlFormulas, LookAt:=xlPart, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=False, SearchFormat:=True)

    If FirstCell Is Nothing Then Exit Function
    fr = FirstCell.row
    
    ptr = -1
    ReDim rn(0 To incr - 1)
    
    Do
        If ptr >= UBound(rn) Then
            ReDim Preserve rn(0 To UBound(rn) + incr)
        End If
        ptr = ptr + 1
        rn(ptr) = FirstCell.row - m_range.row + 1
        
        Set FirstCell = rgn.Find(what:=vbNullString, After:=FirstCell, LookIn:=xlFormulas, LookAt:=xlPart, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=False, SearchFormat:=True)
            
        If FirstCell Is Nothing Then Exit Do
        If FirstCell.row <= fr Then Exit Do
    Loop
    
    count = ptr + 1
    For k = 1 To count
        If rn(k - 1) <> k Then Exit For
    Next
    If k > count Then
        count = 0
        Erase rn
    Else
'        For j = k To count
'            rn(j - k) = rn(j - 1)
'        Next
'        count = count - k + 1
        ReDim Preserve rn(0 To count - 1)
        GetRowsByColorIndex = rn
    End If
End Function

Private Function ByColors(ByVal aColumn As Long) As Boolean
 Dim k As Long
 Dim clr  As Integer
 Dim rn() As Long
 Dim count As Long
 
    Select Case CDDXCurve.GetCurveSortCommand(BSConsts.DDX_PID)
        Case 1:
            clr = CURVE_CHANGE_CLR_IDX
        Case 2:
            clr = xlColorIndexAutomatic 'CURVE_DATA_CLR_IDX
        Case 3:
            clr = CURVE_ERROR_CLR_IDX
    End Select
    
    rn = GetRowsByColorIndex(aColumn, clr, count)
    If count <= 0 Then Exit Function
    
    ByColors = True
    
    Call m_range.Resize(count).rows.Insert(shift:=xlShiftDown)
    Set m_range = m_range.offset(-count)
    Set m_range = m_range.Resize(count + m_range.rows.count)
    
    For k = 1 To count
        Call SwapRows(k, count + rn(k - 1))
    Next
    For k = count To 1 Step -1
        Call m_range.offset(count + rn(k - 1) - 1).Resize(1).Delete(shift:=xlShiftUp)
    Next
    Set m_range = m_range.Resize(m_range.rows.count - count)
End Function

Private Sub SwapRows(ByVal row1 As Long, ByVal row2 As Long)
 Dim dest As range
 Dim src As range
 Dim tmp As range
 Dim p As Long
 Dim rowcnt As Long
 
    With m_range
        rowcnt = .rows.count
        
        p = rowcnt + 1
        
        Set dest = .offset(row1 - 1).Resize(1)
        Set tmp = .offset(p).Resize(1)
        
        dest.Select
        Selection.Cut
        tmp.Select
        dest.Parent.Paste
        
        Set src = .offset(row2 - 1).Resize(1)
        Set dest = .offset(row1 - 1).Resize(1)
        
        src.Select
        Selection.Cut
        dest.Select
        src.Parent.Paste
        
        Set src = .offset(row2 - 1).Resize(1)
        Set tmp = .offset(p).Resize(1)
        
        tmp.Select
        Selection.Cut
        src.Select
        tmp.Parent.Paste
    End With
    
    If rowcnt <> m_range.rows.count Then
        Set m_range = m_range.Resize(rowcnt)
    End If
End Sub


Attribute VB_Name = "CCurveType"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private m_types() As String
Private m_types2() As String
'
Private m_date_types_size As Long
Private m_date_types() As String
Private m_date_types_2() As Long

Private Sub SetTypes()
 Dim k As Long
 Dim v() As String
 
    If m_date_types_size <= 0 Then
        Erase m_date_types_2
        Exit Sub
    End If
    
    ReDim m_date_types_2(0 To m_date_types_size - 1)
    
    For k = LBound(m_date_types) To UBound(m_date_types)
        v = Split(m_date_types(k), ",")
        
        m_date_types_2(k) = Int(Val(v(0)))
        m_date_types(k) = v(1)
    Next
End Sub

Private Sub PrepareDateTypes(sht As Worksheet)
 Dim typs As String
 
    typs = CSheet.WSGetProp(sht, CURVE_SHEET_DATE_TYPES)
    
    If Len(typs) = 0 Then
        m_date_types_size = 0
        Erase m_date_types
    Else
        m_date_types = Split(typs, vbTab)
        m_date_types_size = UBound(m_date_types) - LBound(m_date_types) + 1
    End If
    
    Call SetTypes
End Sub

Public Sub RefreshObservationTypes(sht As Worksheet, params As CCurveParams)
 Dim obs() As String
 
    m_date_types = CDDXLib.DefaultZEWSProxy(DDX_PID).GetCurveObservationTypes(vbNullString, params.curves, CURVE_OBSERVATION_DATE, 1)
    
    If Len(Join(m_date_types)) = 0 Then
        Call CSheet.WSSetProp(sht, CURVE_SHEET_DATE_TYPES, vbNullString)
        m_date_types_size = 0
    Else
        Call CSheet.WSSetProp(sht, CURVE_SHEET_DATE_TYPES, Join(m_date_types, vbTab))
        m_date_types_size = UBound(m_date_types) - LBound(m_date_types) + 1
    End If
    
    Call SetTypes
End Sub

Public Function GetTypesBySheet(sht As Worksheet) As String()
 Dim sr As Long
 Dim sc As Long
 Dim v As Variant
 Dim ctvals() As String
 Dim k As Long
 
    Call PrepareDateTypes(sht)
    
    If CCurveDates.ParamEntity.rowCount <= 1 Then Exit Function
    
    Call CCurveControl.GetSplits(sht, CCurveDates.ParamEntity, sr, sc)
    v = sht.Cells(sr + 1, IIf(CCurveDates.ParamEntity.IsFlag(CURVE_FLG_TIMESERIES), 2, 3)).Resize(CCurveDates.ParamEntity.rowCount - 1).Value2
    
    If Not IsArray(v) Then
        ReDim ctvals(0)
        ctvals(0) = v
    Else
        ReDim ctvals(LBound(v, 1) - 1 To UBound(v, 1) - 1)
        For k = LBound(v, 1) To UBound(v, 1)
            ctvals(k - 1) = v(k, 1)
        Next
    End If
    
    GetTypesBySheet = ctvals
    
' Dim count As Long
' Dim k As Long
' Dim j As Long
' Dim p As Long
' Dim tmp As String
' Dim f As Object
' Dim types() As String
' Dim tps() As Long
'
'    count = sht.DropDowns.count \ IIf(CCurveDates.ParamEntity.IsFlag(CURVE_FLG_TIMESERIES), 1, 2)
'    If count = 0 Then Exit Function
'
'    ReDim types(0 To count - 1)
'    ReDim tps(0 To count - 1)
'
'    k = 0
'    For Each f In sht.DropDowns
'        With sht.Shapes(f.name).ControlFormat
'            If f.left = sht.Cells(1, IIf(CCurveDates.ParamEntity.IsFlag(CURVE_FLG_TIMESERIES), 2, 3)).left Then
'                types(k) = .List(IIf(.ListIndex <= 0, 1, .ListIndex))
'                tps(k) = f.top
'
'                k = k + 1
'            End If
'        End With
'    Next
'
'    count = count - 1
'    For k = 0 To count - 1
'        p = k
'        For j = k + 1 To count
'            If tps(p) > tps(j) Then
'                p = j
'            End If
'        Next
'
'        If p <> k Then
'            tmp = types(k)
'            types(k) = types(p)
'            types(p) = tmp
'
'            tmp = tps(k)
'            tps(k) = tps(p)
'            tps(p) = tmp
'        End If
'    Next
'
'    Erase tps
'
'    GetTypesBySheet = types
End Function

Public Sub CreateContents(types() As String)
 Dim k As Long
 
    m_types = types
    
    Erase m_types2
    If Len(Join(m_types)) = 0 Then Exit Sub
    
    ReDim m_types2(LBound(m_types) To UBound(m_types))
    
    For k = LBound(m_types) To UBound(m_types)
        m_types2(k) = CCurveControl.AddApostrophe(m_types(k))
    Next
End Sub

Public Sub AddDropdowns(rgn As range)
    With rgn.Validation
        .Delete
        .Add Type:=xlValidateList, AlertStyle:=xlValidAlertStop, Operator:=xlBetween, Formula1:=Join(m_types2, ",")
        .IgnoreBlank = True
        .InCellDropdown = True
'        .InputTitle = ""
'        .ErrorTitle = ""
'        .InputMessage = ""
'        .ErrorMessage = ""
        .ShowInput = True
        .ShowError = True
    End With
End Sub

Public Sub SetDropdownSelection(rgn As range, ByVal typeNm As String)
 Dim k As Long
 Dim idx As Long
    
    With rgn
        If Len(typeNm) = 0 Then
            idx = 0
        Else
            For k = LBound(m_types) To UBound(m_types)
                If StrComp(typeNm, m_types(k), vbBinaryCompare) = 0 Then
                    idx = k
                    Exit For
                End If
            Next
        End If
        
        If idx >= 0 Then
            .value = m_types2(idx)
        End If
    End With

    Call SetValueDateFormat(rgn, typeNm)
End Sub

Public Sub SetValueDateFormat(rgn As range, typeNm As String)
 Dim p As Boolean
 Dim k As Long
 Dim t As Long
 
    p = True
    Do
        If CCurveDates.TargetSheet Is Nothing Then Exit Do
        If StrComp(CCurveDates.TargetSheet.name, rgn.Parent.name) <> 0 Then Exit Do
        If StrComp(CCurveDates.TargetSheet.Parent.name, rgn.Parent.Parent.name) <> 0 Then Exit Do
        
        p = False
        Exit Do
    Loop
    If p Then Set CCurveDates.TargetSheet = rgn.Parent
    
    For k = m_date_types_size - 1 To 0 Step -1
        If StrComp(typeNm, m_date_types(k)) = 0 Then Exit For
    Next
    
    p = rgn.Parent.ProtectContents
    If p Then Call CCurveControl.Unprotect(rgn.Parent)

    Set rgn = rgn.offset(, 1).Resize(, CCurveDates.ParamEntity.ColumnCount - 1)
    
    If k < 0 Then
        t = CURVE_OBSERVATION_NUMBER
    Else
        t = m_date_types_2(k)
    End If
    
    rgn.NumberFormat = GetValueFormat(t)

    If p Then Call CCurveControl.Protect(rgn.Parent)
End Sub

Public Function GetValueFormat(formatID As Long) As String
    If formatID = CURVE_OBSERVATION_NUMBER Then
        GetValueFormat = "General"
        
    ElseIf formatID = CURVE_OBSERVATION_DATE Then
        GetValueFormat = CDDXCurve.GetContractDateFormat(CURVE_GRANULARITY_DAILY)
        
    ElseIf formatID = CURVE_OBSERVATION_TIMESTAMP Then
        GetValueFormat = CDDXCurve.GetContractDateFormat(CURVE_GRANULARITY_MINUTELY) + ":ss"
    End If
End Function

Public Sub AddDropdown(rgn As range, ByVal typeNm As String)
 Dim k As Long
 Dim idx As Long
    
    With rgn
        .value = vbNullString
        .Validation.Delete
 
        With .Validation
            .Add Type:=xlValidateList, AlertStyle:=xlValidAlertStop, Operator:=xlBetween, Formula1:=Join(m_types2, ",")
        End With
        
        If Len(typeNm) = 0 Then
            idx = 0
        Else
            For k = LBound(m_types) To UBound(m_types)
                If StrComp(typeNm, m_types(k), vbBinaryCompare) = 0 Then
                    idx = k
                    Exit For
                End If
            Next
        End If
        
        If idx >= 0 Then .value = m_types2(idx)
    End With
    
    Call SetValueDateFormat(rgn, typeNm)
    
'    nm = Format(Now, "TyymmddHhNnSs") + CStr(rgn.row)
'
'    With rgn.Parent
'        .DropDowns.Add(rgn.left, rgn.top, rgn.Width - 1, rgn.Height - 1).name = nm
'    End With
'
'    With rgn.Parent.Shapes(nm)
'        With .ControlFormat
'            .List = m_types
'            .DropDownLines = UBound(m_types) - LBound(m_types) + 1
'
'            If Len(typeNm) = 0 Then
'                idx = 1
'            Else
'                For k = LBound(m_types) To UBound(m_types)
'                    If StrComp(typeNm, m_types(k), vbBinaryCompare) = 0 Then
'                        idx = k + 1
'                        Exit For
'                    End If
'                Next
'            End If
'            If idx > 0 Then .ListIndex = idx
'        End With
'        .Locked = False
'    End With
End Sub

Attribute VB_Name = "CCurveUserData"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private m_Xml As New ZEWSXml
Private Const C_ROOT As String = "/CurvePortal/"

Public opCode As Long
Public opSubCode As Long
Public flagValues As Long

Public PreserveInputs As Boolean

Public Criterion As String
Public IsEditing As Boolean

Public RefreshTarget As Long
Public SelectedGranularities As Long


Private Function GetFromXml(ByVal aTag As String) As String
 Dim v() As String
    
    v = m_Xml.SelectTexts(C_ROOT + aTag)
    GetFromXml = v(LBound(v))
End Function

Public Sub FromXML(ByVal aUserData As String)
    If Not m_Xml.LoadXML(aUserData) Then
        Exit Sub
    End If

    opCode = Val(GetFromXml("OpCode"))
    opSubCode = Val(GetFromXml("opSubCode"))
    
    flagValues = Val(GetFromXml("FlagValues"))
 
    PreserveInputs = IIf(GetFromXml("PreserveInputs") = "1", True, False)
    Criterion = GetFromXml("Criterion")
    IsEditing = IIf(GetFromXml("IsEditing") = "1", True, False)
    
    RefreshTarget = Val(GetFromXml("RefreshTarget"))
    SelectedGranularities = Val(GetFromXml("SelectedGranularities"))
End Sub

Public Function ToXML() As String
    With m_Xml
        Call .CreateRootElement("CurvePortal", "1.0")
        
        Call .CreateTextNode(-1, "OpCode", CStr(opCode))
        Call .CreateTextNode(-1, "opSubCode", CStr(opSubCode))
        
        Call .CreateTextNode(-1, "FlagValues", CStr(flagValues))
        
        Call .CreateTextNode(-1, "PreserveInputs", IIf(PreserveInputs, "1", "0"))
        Call .CreateTextNode(-1, "Criterion", Criterion)
        Call .CreateTextNode(-1, "IsEditing", IIf(IsEditing, "1", "0"))
        
        Call .CreateTextNode(-1, "RefreshTarget", CStr(RefreshTarget))
        Call .CreateTextNode(-1, "SelectedGranularities", CStr(SelectedGranularities))
        
        ToXML = .ToString()
    End With
End Function

Private Sub Class_Terminate()
    Set m_Xml = Nothing
End Sub
Attribute VB_Name = "CDCurve"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public Event OnAfterDCurveLoad(sender As Object, entity As CProfileInfo)

Private Function GetDCurvesByWorkBook(Wb As Workbook) As ZEWSProxy.DataDirectEntities
10        On Error GoTo errorHandler

20        If Wb Is Nothing Then Set Wb = Application.ActiveWorkbook
30        If Wb Is Nothing Then Exit Function
          
          Dim result As ZEWSProxy.DataDirectEntities
40        Set result = CDDXEntity.GetEntitiesByWorkBook(BSConsts.DDX_PID, Wb)
50        If Not result Is Nothing Then
60            Set result = result.GetByEntityTypeName(TYPE_DCURVE)
70        End If
80        Set GetDCurvesByWorkBook = result

90        On Error GoTo 0
100       Exit Function
errorHandler:
          Dim errorDescription As String, errorNumber As Long
110       errorDescription = "CDCurve.GetDCurvesByWorkBook(), Line:" & str(Erl()) + " " + vbCrLf + Err.Description
120       errorNumber = Err.Number
          'your clean up codes here
130       Err.Raise errorNumber, , errorDescription
End Function

Public Function GetDCurveCollection(Wb As Workbook) As Collection
 Dim result As Collection
 Dim entities As ZEWSProxy.DataDirectEntities
 Dim entity As ZEWSProxy.DataDirectEntity
 Dim item As Variant
 Dim Profile As CProfileInfo
    
    Set entities = GetDCurvesByWorkBook(Wb)
    If entities Is Nothing Then Exit Function
    
    For Each item In entities.GetEntities
        Set entity = item
        
        If Not entity.entityOption.IsOneTimeRequest Then
            If result Is Nothing Then
                Set result = New Collection
            End If
                
            Set Profile = NewDCurveData(BSConsts.DDX_PID, entity)
            Call result.Add(Profile)
        End If
    Next
    
    Set GetDCurveCollection = result
End Function

Public Sub RaiseOnAfterDCurveLoad(pid As String, entity As ZEWSProxy.DCurveDataEntity)
    On Error GoTo OOPS
    
    If Not CDDXApp.IsPX(pid) Then Exit Sub
          
 Dim dcurve As CProfileInfo
 
    Set dcurve = NewDCurveData(BSConsts.DDX_PID, entity)
    RaiseEvent OnAfterDCurveLoad(Me, dcurve)

OOPS:
    If Err.Number <> 0 Then
        CDDXApp.StatusMessage = Err.Description
    End If
    On Error GoTo 0
    Exit Sub
End Sub

Public Function NewDCurveData(ByVal pid As String, entity As ZEWSProxy.DCurveDataEntity) As CProfileInfo
    If Not CDDXApp.IsPX(pid) Then Exit Function
          
    Call CDDXEntity.SetParams(BSConsts.DDX_PID, entity)
    Set NewDCurveData = New CProfileInfo
End Function

Public Function RefreshDCurve(Profile As CProfileInfo) As Boolean
 Dim entity As ZEWSProxy.DCurveDataEntity
 
    If Not CDDXLogin.Loggedin Then Exit Function

    Set entity = CDDXEntity.AllEntities(BSConsts.DDX_PID).GetByTaskId(Profile.entityID)

    If entity Is Nothing Then Exit Function

    If Profile.UseDynamicDates Then
        entity.EntityObject.entityOption.DateInputOption = DateInputOption_QuickDate
        entity.EntityObject.entityOption.SelectedQuickDate = Profile.DynamicDate

    ElseIf Profile.UseCustomDates Then
        With entity.EntityObject.entityOption
            .DateInputOption = DateInputOption_DirectInput
            .InputStartDate = Profile.startDate
            .InputEndDate = Profile.enddate
            Call .SetRollingOption(.RollingOption)
        End With
    End If
    
    entity.EntityObject.IsAPI = True
    
    'If Profile.UseIncrementalRefresh Then
    '    If entity.EntityObject.entityOption.IsNeedIncrementalRefreshCache Then
    '        RefreshProfile = CDDXEntity.IncrementalRefreshEntity(BSConsts.DDX_PID, entity)
    '    Else
    '        RefreshProfile = CDDXEntity.IncrementalFillRefreshEntity(BSConsts.DDX_PID, entity)
    '    End If
    'Else
        RefreshDCurve = CDDXEntity.RefreshEntity(BSConsts.DDX_PID, entity)
    'End If

End Function

Attribute VB_Name = "CDCurveHelpTRANS"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Sub ClearTargetFormats(entity As ZEWSProxy.DataDirectEntity, targetRange As range)
    With entity
        If .IsFromFormula Then Exit Sub
        If entity.entityOption.IsPreserveFormat And .executeResult.ChangedMasks = 0 Then Exit Sub
    End With
 
    With targetRange
        .ClearFormats
        .Font.ColorIndex = xlColorIndexAutomatic
    End With
End Sub

Public Function LoadExecutionResult(entity As ZEWSProxy.DataDirectEntity, entityRange As range, origRows As Long, origCols As Long) As Excel.range
 Dim file As Object
 Dim dataary() As Variant
 Dim fpath As String
 Dim buff As String
 Dim headers() As String
 Dim valfmt As String
 Dim token As Variant
 Dim tokens
 Dim errmsg As String
 Dim titlestr As String
 Dim row As Long
 Dim col As Long
 Dim rowCount As Long
 Dim rc As Long
 Dim cc As Long
 Dim fetch_rows As Long
 Dim colcount As Long
 Dim fmtrowcount As Long
 Dim hdrrowcount As Long
 Dim ttlrowcount As Long
 Dim targetRange As Excel.range
 Dim rgn As Excel.range
 Dim fromfm As Boolean
 Dim ocursor As XlMousePointer

    On Error GoTo OOPS

    Set targetRange = entityRange
    Call ClearTargetFormats(entity, targetRange)
    
    ocursor = Application.Cursor
    Application.Cursor = xlWait

    fpath = CDDXUtility.GetDataFileName(entity.taskID)
    Set file = CDDXFile.OpenFile(fpath)
    
    If Not file.EOS() Then
        ttlrowcount = IIf(entity.entityOption.HasDCurveEntityTitle, 1, 0)
        If ttlrowcount = 0 Then entityRange.Resize(1).Font.Bold = False

        buff = file.ReadText(-2)

        buff = file.ReadText(-2)
        tokens = Split(buff, vbTab)
        
        colcount = CLng(tokens(0))
        fmtrowcount = CLng(tokens(1))
        hdrrowcount = CLng(tokens(2))
        rowCount = CLng(tokens(3))
        
        titlestr = file.ReadText(-2)
        
        valfmt = file.ReadText(-2)
        buff = file.ReadText(-2)
        Call SetFormats(entity, entityRange, ttlrowcount, rowCount, colcount, valfmt, buff)
        
        If ttlrowcount > 0 Then
            targetRange.Cells(1, 1) = titlestr
            origRows = origRows - ttlrowcount
            If origRows < 1 Then
                targetRange.rows(1).Font.ColorIndex = ENTITY_COLOR_HEADER_N_DATE
                targetRange.rows(1).HorizontalAlignment = xlLeft
                targetRange.rows(1).NumberFormat = "@"
            End If
        End If
        
        ReDim dataary(1 To hdrrowcount, 1 To colcount)
        For row = 1 To hdrrowcount
            buff = file.ReadText(-2)
            headers = Split(buff, vbTab)
            For col = 1 To colcount
                If Len(headers(col - 1)) > 0 And left(headers(col - 1), 1) = "'" Then
                    dataary(row, col) = "'" + headers(col - 1)
                Else
                    dataary(row, col) = headers(col - 1)
                End If
            Next
        Next row
        
        If (targetRange.Columns.count <> colcount) Or (targetRange.rows.count <> rowCount + hdrrowcount) Then
            Set targetRange = targetRange.offset(ttlrowcount, 0).Resize(rowCount + hdrrowcount, colcount)
        End If
        
        If hdrrowcount > 0 Then
            targetRange.Resize(hdrrowcount, colcount).value = dataary
            origRows = origRows - hdrrowcount
            If rowCount > 0 Then
                Set targetRange = targetRange.offset(hdrrowcount, 0).Resize(rowCount, colcount)
            End If
        End If
        If origRows < 0 Then origRows = 0
    
        If rowCount > 0 Then
            Set rgn = targetRange
            
            fetch_rows = (2048 \ colcount) + 1
            If fetch_rows > rowCount Then fetch_rows = rowCount
            
            ReDim dataary(1 To fetch_rows, 1 To colcount)
            rc = 0
            
            While rowCount > 0
                If rowCount < fetch_rows Then
                    fetch_rows = rowCount
                End If
                
                For row = 1 To fetch_rows
                    buff = file.ReadText(-2)
                    col = 1
                    tokens = Split(buff, vbTab)
    
                    For Each token In tokens
                        If col > colcount Then Exit For
                        If IsNumeric(token) Then
                            dataary(row, col) = CDbl(token)
                        Else
                            dataary(row, col) = token
                        End If
                        col = col + 1
                    Next
                Next

                rgn.Cells(rc + 1, 1).Resize(fetch_rows, colcount).value = dataary
                
                rowCount = rowCount - fetch_rows
                rc = rc + fetch_rows
            Wend
            
            Set rgn = rgn.Resize(1)
        End If
    End If

    Call SetStyles(entity, entityRange)
    
    Call CEntityHelper.ClearErr
    
OOPS:
    If Err.Number <> 0 Then
        errmsg = Err.Description
    End If

    Application.Cursor = ocursor

    
    Call CDDXFile.CloseFile(file, fpath, buff)
    Set file = Nothing
    
    Erase dataary
        
    On Error GoTo 0
    If errmsg <> vbNullString Then Call Err.Raise(vbObjectError + 1, "LoadEntity", errmsg)

    Set LoadExecutionResult = entityRange.Resize(entity.executeResult.TotalRowsCount, entity.executeResult.columnsCount)
End Function

Private Function IsFutureSingleTransposed(entity As ZEWSProxy.DataDirectEntity) As Boolean
 Dim obj As ZEWSProxy.CurveDataEntity
 
    Set obj = entity
    
    IsFutureSingleTransposed = Not CDDXHelper.IsFlag(obj.flagValues, CURVE_FLG_TIMESERIES) And Not CDDXHelper.IsFlag(obj.flagValues, CURVE_FLG_MULTIOBS)
End Function

Private Sub SetFormats(entity As ZEWSProxy.DataDirectEntity, entityRange As range, titleRowCount As Long, dataRowCount As Long, dataColCount As Long, valFormat As String, formatIndice As String)
 Dim rgn As range
 Dim dfmts() As String
 Dim fmt As String
 Dim c As Long
 Dim idx As Long
 Dim startcol As Long
 Dim fst As Boolean
 
    dfmts = ReadDateFormats(entity)
    fst = IsFutureSingleTransposed(entity)
    
    If titleRowCount > 0 Then
        entityRange.Cells(1, 1).NumberFormat = "@"
    End If
    
    Set rgn = entityRange.Resize(1 + dataRowCount, dataColCount)
    
    rgn.Cells(2, 1).Resize(dataRowCount).NumberFormat = dfmts(CLng(left(formatIndice, 1)))
    
    For c = 1 To dataColCount
        idx = CLng(Mid(formatIndice, c, 1))
        fmt = dfmts(idx)
        
        If fst Then
            If c = 1 Then
                rgn.Cells(1, c).Resize(dataRowCount + 1).NumberFormat = fmt
            ElseIf c = 2 Then
                rgn.Cells(1, c).NumberFormat = "@"
                rgn.Cells(2, c).Resize(dataRowCount).NumberFormat = fmt
            Else
                If startcol = 0 Then startcol = c
                rgn.Cells(1, c).NumberFormat = fmt
            End If
            
        Else
            If c = 1 Then
                If fmt = "@" Then
                    rgn.Cells(1, c).Resize(dataRowCount + 1).NumberFormat = fmt
                Else
                    rgn.Cells(1, c).NumberFormat = "@"
                    rgn.Cells(2, c).Resize(dataRowCount).NumberFormat = fmt
                End If
            ElseIf fmt = "@" Then
                rgn.Cells(1, c).Resize(dataRowCount + 1).NumberFormat = fmt
            Else
                If startcol = 0 Then startcol = c
                rgn.Cells(1, c).NumberFormat = fmt
            End If
        End If
    Next
    
    If startcol <= 0 Then Exit Sub
    
    Set rgn = rgn.Cells(2, startcol).Resize(dataRowCount, dataColCount - startcol + 1)
    
    rgn.NumberFormat = valFormat
    Call SetFormats2(entity, rgn, dfmts)
End Sub

Private Sub SetFormats2(entity As ZEWSProxy.DataDirectEntity, rgn As range, dfmts() As String)
 Dim fname As String
 Dim file As Object
 Dim txt As String
 Dim dtrow() As String
 
    On Error GoTo OOPS
    
    fname = entity.GetResultFile(1)
    If Len(Dir(fname)) = 0 Then Exit Sub
    
    Set file = CDDXFile.OpenFile(fname)
    
    Do
        If file.EOS() Then Exit Do
        
        txt = file.ReadText(-2)
        If txt = vbNullString Then Exit Do
        
        dtrow = Split(txt, vbTab)
        rgn.rows(CLng(dtrow(0))).NumberFormat = dfmts(CLng(dtrow(1)))
    Loop
    
OOPS:
    If Err.Number <> 0 Then
        CDDXApp.StatusMessage = "SetFormats2: " + Err.Description
    End If
    
    Call CDDXFile.CloseFile(file, fname, txt)
    Set file = Nothing
    Exit Sub
End Sub


Private Sub SetStyles(entity As ZEWSProxy.DataDirectEntity, entityRange As range)
 Dim dcurveobj As ZEWSProxy.CurveDataEntity
 Dim rgn As range
 Dim c As Long
 Dim cols As Long
 Dim rws As Long
 
    Set dcurveobj = entity
    
    With entity.executeResult
        cols = .columnsCount
        rws = .DataRowsCount
        Set rgn = entityRange.Resize(rws + 1, cols)
    End With
    
    With rgn
        With .rows(1)
            .Font.Bold = False
            .Font.Italic = False
            .Font.ColorIndex = ENTITY_COLOR_HEADER_N_DATE
            .VerticalAlignment = xlVAlignCenter
        End With
        
        For c = 1 To cols
            If StrComp(.Cells(1, c).NumberFormat, "@") <> 0 Then
                .Cells(1, 1).Resize(, c - 1).HorizontalAlignment = xlLeft
                .Cells(1, c).Resize(, cols - c + 1).HorizontalAlignment = xlRight
                Exit For
            End If
        Next
    End With
    
    If (dcurveobj.flagValues And CURVE_FLG_TIMESERIES) = 0 And rws > 0 Then
        With rgn.Cells(2, 1).Resize(rws, 1)
            .Font.Bold = False
            .Font.Italic = False
            .Font.ColorIndex = ENTITY_COLOR_HEADER_N_DATE
            .HorizontalAlignment = xlRight
            .VerticalAlignment = xlVAlignCenter
        End With
    End If
End Sub

Private Function ReadDateFormats(entity As ZEWSProxy.DataDirectEntity) As String()
 Dim fname As String
 Dim msg As String
 Dim file As Object
 Dim buff As String
    
    fname = Replace(CDDXUtility.GetDataFileName(entity.taskID), ".csv", ".tmp")
    If Len(Dir(fname)) = 0 Then Exit Function
    
    Set file = CDDXFile.OpenFile(fname)
    Call file.ReadText(-2)
    
    buff = file.ReadText(-2)
    ReadDateFormats = Split(buff, vbTab)
    
OOPS:
    If Err.Number <> 0 Then
        CDDXApp.StatusMessage = "ReadDateFormats: " + Err.Description
    End If
    
    Call CDDXFile.CloseFile(file, fname, msg)
    Set file = Nothing
End Function
Attribute VB_Name = "CDDXApp"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Option Base 1

Public Event OnWorkbookOpened(sender As Object, Wb As Workbook)
'
Public Event OnDuplicateWorkbook(wk As Workbook)
Public Event OnDuplicateSheet(sh As Worksheet, newSh As Worksheet)

Private WithEvents m_xlApp As Application
Attribute m_xlApp.VB_VarHelpID = -1
Private m_quiet As Boolean
Private m_initial_open As Boolean
'
Private m_sheet_deactivated As Worksheet

Private m_message_method As CMessageMethod

Private Sub Class_Initialize()
    Call LoadDLL
    Set m_message_method = New CMessageMethod
        
    m_quiet = True
    Set m_xlApp = Application
End Sub

Public Function GetUserRange(sheet As Worksheet) As range
    On Error GoTo OOPS
          
    If Not sheet Is Nothing Then
        Set GetUserRange = sheet.UsedRange
    End If

OOPS:
    Exit Function
End Function

Private Function GetCopiedSheet(sh As Worksheet) As Worksheet
Dim tmp As String
Dim k As Integer
Dim nmPart As String
Dim seqPart As Integer
Dim sname As String
Dim f As Worksheet
Dim r1 As range
Dim r2 As range

    Set r1 = GetUserRange(sh)
    Set r2 = GetUserRange(m_sheet_deactivated)
          
    If r1 Is Nothing Then Exit Function
    If r2 Is Nothing Then Exit Function
          
    If r1.top <> r2.top Or r1.left <> r2.left Or r1.rows.count <> r2.rows.count Or r1.Columns.count <> r2.Columns.count Then Exit Function
          
    sname = sh.name
    If right(sname, 1) <> ")" Then
        If sh.name <> m_sheet_deactivated.name Then Exit Function
        Set GetCopiedSheet = m_sheet_deactivated
        Exit Function
    End If

    For k = Len(sname) - 1 To 1 Step -1
        If Mid(sname, k, 1) = "(" Then Exit For
    Next
    If k <= 0 Then Exit Function
    tmp = Mid(sname, k + 1, Len(sname) - k - 1)
    Err.Clear
    seqPart = CInt(tmp) - 1
    If Err.Number <> 0 Then Exit Function
    sname = left(sname, k - 1 - 1)
    If InStr(m_sheet_deactivated.name, sname) <> 1 Then Exit Function
    Set GetCopiedSheet = m_sheet_deactivated
End Function

Private Sub ResetDeactivated(sh As Worksheet)
    On Error GoTo OOPS

    If m_sheet_deactivated Is Nothing Then Exit Sub
    If m_sheet_deactivated.Parent.name <> sh.Parent.name Then
        If IsWorksheet(m_sheet_deactivated.Parent.ActiveSheet) Then
            Set m_sheet_deactivated = m_sheet_deactivated.Parent.ActiveSheet
        End If
    End If

OOPS:
    Exit Sub
End Sub

Private Sub CheckDuplicateSheet(sh As Worksheet)
 Dim f As Worksheet

    Call ResetDeactivated(sh)
    If m_sheet_deactivated Is Nothing Then Exit Sub
    If sh Is Nothing Then Exit Sub
    If CSheet.ZESheetID(sh) <> vbNullString Then Exit Sub
          
    Set f = GetCopiedSheet(sh)
    If Not f Is Nothing Then
        RaiseEvent OnDuplicateSheet(f, sh)
    End If
End Sub

Private Sub Class_Terminate()
    Set m_message_method = Nothing
End Sub

Private Sub m_xlApp_NewWorkbook(ByVal Wb As Workbook)
    Call DispatchRefresh(Wb)
End Sub

Private Sub m_xlApp_SheetActivate(ByVal sh As Object)
    On Error GoTo OOPS
          
    If IsWorksheet(sh) Then
        Set CCurveDates.TargetSheet = sh
        Call CheckDuplicateSheet(sh)
              
        With sh.Parent
            If .IsAddin Then Exit Sub
            If .name = ThisWorkbook.name Then Exit Sub
        End With
    End If
    
    Set m_sheet_deactivated = Nothing

OOPS:
    If Err.Number <> 0 Then
        StatusMessage = Err.Description
    End If
    Exit Sub
End Sub

Private Function IsWorksheet(sh As Object) As Boolean
    If sh Is Nothing Then Exit Function
    IsWorksheet = IIf(StrComp(TypeName(sh), "worksheet", vbTextCompare) = 0, True, False)
End Function

Private Sub m_xlApp_SheetChange(ByVal sh As Object, ByVal target As range)
    On Error GoTo OOPS

    With Application
        If .CalculationState = xlCalculating Then Exit Sub
        If Not .Ready Then Exit Sub
    End With
        
    If sh Is Nothing Then Exit Sub
    If target Is Nothing Then Exit Sub
    If Not IsWorksheet(sh) Then Exit Sub
          
    If CDDXHelper.IsCurveSheet(sh) Then
        If CCurveControl.OnSheetChange(target) Then Exit Sub
    ElseIf CDDXHelper.IsUploadSheet(sh) Then
        Call CUploadSheetCreator.OnUploadsheetChange(target)
    End If

OOPS:
    If Err.Number <> 0 Then
        Call CDDXHelper.LogError(Err.Description, "CDDXApp.m_xlApp_SheetChange")
    End If
    On Error GoTo 0
    Exit Sub
End Sub

Private Sub m_xlApp_SheetDeactivate(ByVal sh As Object)
 Dim tid As String
'
    On Error GoTo OOPS
    
    If IsWorksheet(sh) Then
        tid = CSheet.ZESheetType(sh)
        If tid <> vbNullString Then
            Set m_sheet_deactivated = sh
        Else
            Set m_sheet_deactivated = Nothing
        End If
    Else
        Set m_sheet_deactivated = Nothing
    End If

OOPS:
    If Err.Number <> 0 Then
        StatusMessage = Err.Description
    End If
    Exit Sub
End Sub

Private Sub m_xlApp_WorkbookActivate(ByVal Wb As Workbook)
    On Error GoTo OOPS

    If Wb.IsAddin Then Exit Sub
          
    Call AfterWorkbookOpen(Wb)

OOPS:
    If Err.Number <> 0 Then
        Call CDDXHelper.LogError(Err.Description, "m_xlApp_WorkbookActivate")
    End If
    Exit Sub
End Sub

Private Sub m_xlApp_WorkbookDeactivate(ByVal Wb As Workbook)
    On Error GoTo OOPS

    If IsWorksheet(Wb.ActiveSheet) Then
        Set m_sheet_deactivated = Wb.ActiveSheet
    Else
        Set m_sheet_deactivated = Nothing
    End If

OOPS:
    Exit Sub
End Sub

Public Sub PersistCreatorVersion(pid As String, Wb As Workbook)
 Dim ver As String
 
    If Not IsPX(pid) Then Exit Sub
    
    On Error GoTo OOPS
    
    ver = CSheet.DOCGetProp(Wb, ZEDOC_VER_CREATOR)
    If ver <> vbNullString Then Exit Sub
    
    ver = CSheet.DOCGetProp(Wb, ZEDOC_VER)
    If ver = vbNullString Then Exit Sub
    
    DebugMessage = ver
    Call CSheet.DOCSetProp(Wb, ZEDOC_VER_CREATOR, ver)
    
OOPS:
    If Err.Number <> 0 Then
        StatusMessage = Err.Description
    End If
    On Error GoTo 0
    Exit Sub
End Sub

Private Sub CheckDuplicateWBId(ByVal Wb As Workbook)
 Dim k As Long
 Dim id As String
 Dim tmp As String
 
    id = CSheet.DOCGetProp(Wb, ZEDOC_ID)
    If id = vbNullString Then Exit Sub
    
    If Application.Workbooks Is Nothing Then Exit Sub
    
    For k = 1 To Application.Workbooks.count
        If Not Application.Workbooks(k) Is Nothing Then
            If StrComp(Wb.FullName, Application.Workbooks(k).FullName, vbTextCompare) <> 0 Then
                tmp = CSheet.DOCGetProp(Application.Workbooks(k), ZEDOC_ID)
                If StrComp(id, tmp, vbTextCompare) = 0 Then
                    id = CDDXLib.DefaultZEWSProxy(DDX_PID).NewGUID()
                    Call CSheet.DOCSetProp(Application.Workbooks(k), ZEDOC_ID, id)
                    Exit For
                End If
            End If
        End If
    Next
End Sub

Private Sub m_XlApp_WorkbookOpen(ByVal Wb As Workbook)
    On Error GoTo OOPS
    
    Call DispatchRefresh(Wb)
    
    If Wb.IsAddin Then Exit Sub
    
    m_initial_open = True
    
    Call PersistCreatorVersion(DDX_PID, Wb)
    Call CheckDuplicateWBId(Wb)
    
OOPS:
    If Err.Number <> 0 Then
        Call CDDXHelper.LogError(Err.Description, "m_XlApp_WorkbookOpen")
    End If
    
    On Error GoTo 0
    Exit Sub
End Sub

Private Function ParseVersion(ByVal ver As String) As Integer
 Dim ary() As String
       
    If ver = vbNullString Then
        ParseVersion = -9
        Exit Function
    End If
          
    ary = Split(ver, ".")
    If UBound(ary) <= 1 Then
        ParseVersion = -8
        Exit Function
    End If
          
    ParseVersion = Val(ary(0) + ary(1))
End Function

Private Function CheckDocVersion(Wb As Workbook) As Boolean
Dim ddxv As Integer
Dim docv As Integer
Dim k As Integer

    ddxv = ParseVersion(DDXVersion(Nothing))
    docv = ParseVersion(CSheet.DOCVersion(Wb))
          
    If docv > 0 And docv <= 42 Then
        With Application
            For k = 1 To 3 Step 1
                Beep
                StatusMessage = "Incompatible Workbook !" + Wb.name + " (Version " + CSheet.DOCVersion(Wb) + ")"
                .Wait Now() + TimeValue("00:00:01")
                .StatusBar = False
                If k <> 3 Then
                    .Wait Now() + TimeValue("00:00:01")
                End If
            Next
        End With
    Else
        CheckDocVersion = True
    End If
End Function

Private Function CheckDuplicateWorkbook(Wb As Workbook) As Boolean
 Dim f As Workbook
 Dim wid As String

    If Wb Is Nothing Then Exit Function
    wid = CSheet.ZEDocID(Wb)
    If wid = vbNullString Then Exit Function
          
    For Each f In Workbooks
        If StrComp(Wb.name, f.name, vbTextCompare) <> 0 Then
            If StrComp(wid, CSheet.ZEDocID(f), vbTextCompare) = 0 Then
                CheckDuplicateWorkbook = True
                RaiseEvent OnDuplicateWorkbook(Wb)
                Exit Function
            End If
        End If
    Next
End Function

Private Function IsAddinFile(Wb As Workbook) As Boolean
 Dim k As Long
 Dim ext As String
 
    For k = Len(Wb.name) To 1 Step -1
        If Mid(Wb.name, k, 1) = "." Then
            ext = Mid(Wb.name, k)
            IsAddinFile = IIf(StrComp(ext, ".xlam", vbTextCompare) = 0 Or StrComp(ext, ".xla", vbTextCompare) = 0, True, False)
            Exit Function
        End If
    Next
End Function

Public Sub ProcessWorkbook(ByVal pid As String, Wb As Workbook)
 Dim msg As String
 
    If Not IsPX(pid) Then Exit Sub
    
'    If CSheet.IsZEAddin(wb) Then Exit Sub
    If IsAddinFile(Wb) Then Exit Sub
    
    Call CDDXHelper.RunConversion(Wb, msg)
    Call CDDXHelper.ChangeLinks(Wb, &H1)
    Call CDDXUpload.EnableGrouping(DDX_PID, Wb)
    Call CCurveHelper.EnableGrouping(Wb)
    
    If Not CheckDocVersion(Wb) Then Exit Sub
    If CheckDuplicateWorkbook(Wb) Then Exit Sub
          
'    Call CCurveControl.OnWorkbookOpen(wb)
    Call CDDXEntity.InstantiateEntities(DDX_PID, Wb)
          
'    With DDXObjects.LoginObject
'        Call .SessionExpired
'    End With
              
'    If Not ActiveWorkbook Is Nothing And CDDXLogin.Loggedin Then
'        Call CDDXEntity.RefreshAllEntities(BSConsts.DDX_PID, True)
'    End If
    
'    wb.saved = True
End Sub

Private Sub AfterWorkbookOpen(ByVal Wb As Workbook)
    If Not m_initial_open Then Exit Sub
    m_initial_open = False
          
    Call ProcessWorkbook(DDX_PID, Wb)
    
    If CDDXLogin.Loggedin And Not CDDXLogin.InAutoLogin Then
        Call CDDXEntity.RefreshAllEntities(DDX_PID, Wb, True)
    End If

    RaiseEvent OnWorkbookOpened(Me, Wb)
End Sub

Public Property Get Quiet() As Boolean
    Quiet = m_quiet
End Property

Public Property Let Quiet(ByVal value As Boolean)
    m_quiet = value
End Property

Public Function SetMessageMethod(Method As Integer, durationInSeconds As Integer) As Boolean
    Call m_message_method.SetMethod(Method, durationInSeconds)
End Function

Public Sub GetMessageMethod(Method As Integer, durationInSeconds As Integer)
    With m_message_method
        Method = .Method
        durationInSeconds = .Duration
    End With
End Sub

Public Property Let StatusMessage(ByVal msg As String)
    On Error GoTo errorHandler

'    If InStr(msg, "Application-defined") > 0 Then
'        Stop 'todo
'    End If
    
    If msg <> vbNullString Then
        DebugMessage = msg
    End If
    
    If m_message_method.Disabled Then
 
    ElseIf m_message_method.enabled Then
        With Application
            If .Ready Then
'                If InStr(msg, "Invalid") > 0 Then
'                    Stop
'                End If
                .StatusBar = IIf(Len(msg) <> 0, left(DDXTitle + ":  " + msg, 220), vbNullString)
                
                If m_message_method.Duration > 0 Then
                    .OnTime Now + TimeSerial(0, 0, m_message_method.Duration), "ResetStatusBar"
                End If
            End If
        End With
    ElseIf m_message_method.InPopup Then
    
    End If

errorHandler:
    On Error GoTo 0
    Exit Property
End Property

Public Property Let DebugMessage(ByVal value As String)
    'Debug.Print msg
    'If Not CVarHelper.m_debug_message Then Exit Property
    Call DebugPrint(ThisWorkbook.name + "   " + value)
End Property

Public Function DialogMessage(ByVal prompt As String, Optional ByVal buttons As VbMsgBoxStyle = vbInformation) As VbMsgBoxResult
    On Error GoTo OOPS

    If Not Quiet Then
        If XLVersion <= 2003 Or OSVersion Mod 100 < 6 Then
            prompt = Replace(prompt, vbCrLf, vbLf)
        End If
        DialogMessage = MsgBox(prompt, buttons, DDXTitle)
    Else
        If (buttons And VbMsgBoxStyle.vbOKCancel) <> 0 Then
            DialogMessage = vbOK
        ElseIf (buttons And VbMsgBoxStyle.vbOKOnly) <> 0 Then
            DialogMessage = vbOK
        ElseIf (buttons And VbMsgBoxStyle.vbYesNo) <> 0 Then
            DialogMessage = vbYes
        ElseIf (buttons And VbMsgBoxStyle.vbYesNoCancel) <> 0 Then
            DialogMessage = vbYes
        ElseIf (buttons And VbMsgBoxStyle.vbRetryCancel) <> 0 Then
            DialogMessage = vbCancel
        Else
            DialogMessage = vbOK
        End If
              
        StatusMessage = prompt
    End If

OOPS:
    If Err.Number <> 0 Then
        DebugMessage = Err.Description
    End If
    
    On Error GoTo 0
    Exit Function
End Function

Public Property Get MinimiumDDVersion() As String
 Dim v() As String
 
    v = Split(CSheet.DOCGetProp(ThisWorkbook, BSConsts.ZEDOC_DD), ",")
    MinimiumDDVersion = v(LBound(v))
End Property

Public Property Get DDVersion() As String
 Dim v() As String
 
    v = Split(CSheet.DOCGetProp(ThisWorkbook, BSConsts.ZEDOC_DD), ",")
    If LBound(v) <> LBound(v) Then
        DDVersion = v(LBound(v) + 1)
    End If
End Property

Private Sub GetVersionTitle(title As String, Version As String)
 Dim t As String
 Dim k As Integer

    t = Trim(ThisWorkbook.BuiltinDocumentProperties("Title"))
    
    For k = Len(t) To 1 Step -1
        If Mid(t, k, 1) = " " Then Exit For
    Next
    
    title = left(t, k - 1)
    Version = Mid(t, k + 1)
    
'    If ThisWorkbook.IsAddin Then
'        For k = Len(version) To 1 Step -1
'            If Mid(version, k, 1) = "." Then
'                If k > 2 Then
'                    version = left(version, k - 1)
'                End If
'                Exit For
'            End If
'        Next
'    End If
End Sub

Public Property Get DDXCodeRevision(Wb As Workbook) As String
    On Local Error GoTo OOPS
    
    If Wb Is Nothing Then
        Set Wb = ThisWorkbook
    End If
    DDXCodeRevision = Trim(Wb.CustomDocumentProperties(ZEDOC_REV))
    
OOPS:
    On Local Error GoTo 0
    Exit Property
End Property

Public Property Get ZEWSProxyRevision() As String
    On Local Error GoTo OOPS
    
    ZEWSProxyRevision = Trim(ThisWorkbook.CustomDocumentProperties(ZEDOC_ZEWSPROXY))
    
OOPS:
    On Local Error GoTo 0
    Exit Property
End Property

Public Property Get DDXTitle() As String
 Dim v As String
 Dim t As String
 
    Call GetVersionTitle(t, v)
    DDXTitle = t + " " + v
End Property

Public Property Get DDXVersion(Wb As Workbook) As String
    If Wb Is Nothing Then
        DDXVersion = CSheet.DOCVersion(ThisWorkbook)
    Else
        DDXVersion = CSheet.DOCVersion(Wb)
    End If
End Property

#If Win64 Then
Private Property Get OSVersion() As LongLong
#Else
Private Property Get OSVersion() As Long
#End If
 Dim info As OSVERSIONINFO
          
    info.dwOSVersionInfoSize = Len(info)
    Call GetVersionEx(info)
    OSVersion = 100 * info.dwMajorVersion + info.dwMinorVersion
End Property

Public Property Get XLVersion() As Integer
 Dim ver As String
       
    ver = CStr(Application.Version)
    XLVersion = 9999
          
    If InStr(ver, "16") > 0 Then
        XLVersion = 2016
    ElseIf InStr(ver, "15") > 0 Then
        XLVersion = 2013
    ElseIf InStr(ver, "14") > 0 Then
        XLVersion = 2010
    ElseIf InStr(ver, "12") > 0 Then
        XLVersion = 2007
    ElseIf InStr(ver, "11") > 0 Then
        XLVersion = 2003
    ElseIf InStr(ver, "10") > 0 Then
        XLVersion = 2002
    ElseIf InStr(ver, "9") > 0 Then
        XLVersion = 2000
    ElseIf InStr(ver, "8") > 0 Then
        XLVersion = 97
    Else

    End If
End Property

Public Function IsPX(ByVal pid As String) As Boolean
    IsPX = (StrComp(pid, BSConsts.DDX_PID) = 0)
End Function

Public Sub StartMonitor(ByVal pid As String, ByVal taskID As String, ByVal userData As String)
    If Not IsPX(pid) Then Exit Sub
    
    Call CTimer.StartMonitor(taskID, userData)
End Sub

Public Property Get Signature() As String
    Signature = "ZE Data Direct Excel Add-In " + DDXVersion(ThisWorkbook)
End Property

Private Sub DispatchRefresh(Wb As Workbook)
    If Wb.IsAddin Then Exit Sub
    
    Call CDDXLib.DefaultZEWSProxy(DDX_PID).DispatchHelper(DISPATCH_REFRESH_HANDLES, Int(Val(Application.Version)), vbNullString, vbNullString)
End Sub

Public Function GetDLLPath(ByVal fileNameOnly As Boolean, ByVal ignore64Bit As Boolean, ByVal ext As String) As String
  Dim k As Long
  Dim path As String
    
    path = ThisWorkbook.FullName
    For k = Len(path) To 1 Step -1
        If Mid(path, k, 1) = "\" Then
            path = left(path, k) + "ZEDDXCalc"
#If Win64 Then
            If Not ignore64Bit Then
                path = path + "64"
            End If
#End If
            path = path + ext
            Exit For
        End If
    Next
        
    If fileNameOnly Then
        For k = Len(path) To 1 Step -1
            If Mid(path, k, 1) = "\" Then
                path = Mid(path, k + 1)
                Exit For
            End If
        Next
    End If
    
    GetDLLPath = path
End Function

Private Sub LoadMainLib()
  Dim k As Long
  Dim path As String
    
    path = ThisWorkbook.FullName
    For k = Len(path) To 1 Step -1
        If Mid(path, k, 1) = "." Then
            path = left(path, k - 1)
#If Win64 Then
            path = path + "64"
#End If
            Call LoadLibrary(StrPtr(path + ".dll"))
            Exit For
        End If
    Next
End Sub

Private Sub LoadDLL()
 Dim xll As String
    
    xll = GetDLLPath(False, False, ".xll")
    Call LoadLibrary(StrPtr(xll))
    Call LoadMainLib
End Sub
Attribute VB_Name = "CDDXCurve"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Const ZESHEET_CURVE_DATERANGE As String = "C1-STD"
Private Const ZESHEET_CURVE_SINGLEDATE_RDOL As String = "C2-STD"
Private Const ZESHEET_CURVE_SINGLEDATE_EDIT As String = "C2-EDIT"
Private Const ZESHEET_CURVE_SINGLEDATE_EXCL As String = "C2-EXCL"
Private Const ZESHEET_CURVE_SINGLEDATE_TRANS As String = "C2-TRANS"
Private Const ZESHEET_CURVE_SINGLEDATE_FLX1 As String = "C2-FLX-1"
Private Const ZESHEET_CURVE_TIMESERIES As String = "C2-TS"
Private Const ZESHEET_CURVE_TIMESERIES_TRANS As String = "C2-TS-TRANS"

Private Const CP_SETTING_4EYES As Long = 1
Private Const CV_PROT_IN_MA As String = "CurveProtInMA"

Public Event OnEvent(sender As Object, ByVal eventID As Long, params As CCurveParams, ByVal curveName As String, ByRef wParam As Variant, ByRef lParam As Variant)

Private FSort As Integer
Private FMasks As Long

Public Sub OnLogin(ByVal pid As String)
    If Not CDDXApp.IsPX(pid) Then Exit Sub
    
    On Error GoTo OOPS

    Call SetMask(IIf(CDDXLib.DefaultZEWSProxy(DDX_PID).GetCPSetting(CP_SETTING_4EYES) = 1, True, False), CURVE_INQUIRY_4EYES)

OOPS:
    If Err.Number <> 0 Then
        CDDXApp.StatusMessage = Err.Description
    End If
    Exit Sub
End Sub

Private Sub SetMask(isSet As Boolean, value As Long)
    If isSet Then
        FMasks = FMasks Or value
    Else
        FMasks = FMasks And (Not value)
    End If
End Sub

Public Property Get UploadNulls() As Boolean
    UploadNulls = CDDXHelper.IsFlag(FMasks, CURVE_INQUIRY_HAS_NULLS)
End Property

Public Property Let UploadNulls(value As Boolean)
    Call SetMask(value, CURVE_INQUIRY_HAS_NULLS)
End Property

Public Property Get UploadWithProt() As Boolean
    UploadWithProt = CDDXHelper.IsFlag(FMasks, CURVE_INQUIRY_VALUES_PROT)
End Property

Public Property Let UploadWithProt(value As Boolean)
    On Error GoTo OOPS
    
    Call SetMask(value, CURVE_INQUIRY_VALUES_PROT)
    Call CDDXHelper.PutToRegistry(CV_PROT_IN_MA, IIf(value, "1", "0"))
    
OOPS:
    If Err.Number <> 0 Then
        CDDXApp.StatusMessage = Err.Description
    End If
    Exit Property
End Property

Public Property Get FourEyesActive() As Boolean
    FourEyesActive = CDDXHelper.IsFlag(FMasks, CURVE_INQUIRY_4EYES)
End Property

'Public Function FindCurves(ByVal pid As String, ByVal granularities As Long, curveNames() As String, curveTypes As Variant, ByVal properties As String, ByVal filters As String, ByVal findDirectives As Long) As ZEWSProxy.curveBean()
' Dim cvTypes() As String
'
'    If Not CDDXApp.IsPX(pid) Then Exit Function
'
'    If (VarType(curveTypes) And vbString) <> 0 Then
'        If (VarType(curveTypes) And vbArray) <> 0 Then
'            cvTypes = curveTypes
'        ElseIf curveTypes <> vbNullString Then
'            ReDim cvTypes(0 To 0)
'            cvTypes(0) = curveTypes
'        End If
'    End If
'
'    With CDDXLib.DefaultZEWSProxy(DDX_PID)
'        FindCurves = .FindCurves(CDDXLogin.sid, granularities, curveNames, cvTypes, properties, filters, findDirectives)
'    End With
'End Function

Public Function GetCurvePropertyNames(ByVal pid As String) As String()
    If Not CDDXApp.IsPX(pid) Then Exit Function

    GetCurvePropertyNames = CDDXLib.DefaultZEWSProxy(BSConsts.DDX_PID).RetrieveCurvePropertyNameList(CDDXLogin.sid)
End Function

Public Function IsBusinessRange(ByVal pid As String, ByVal startDate As String, ByVal enddate As String, ByVal exclWeekEnds As String, ByVal exclHolidays As String) As Boolean
    If Not CDDXApp.IsPX(pid) Then Exit Function
    
    On Local Error GoTo OOPS
    IsBusinessRange = CDDXLib.DefaultZEWSProxy(BSConsts.DDX_PID).IsCurveBusinessDateRange(CDDXLogin.sid, _
                                CDbl(CDDXDates.CDateSafe(startDate)), _
                                CDbl(CDDXDates.CDateSafe(enddate)), _
                                exclWeekEnds, exclHolidays)
                                
OOPS:
    If Err.Number <> 0 Then
        CDDXApp.StatusMessage = Err.Description
    End If
    On Local Error GoTo 0
    Exit Function
End Function

Public Function GetHolidays(ByVal pid As String) As ZEWSProxy.LabelValue()
    If Not CDDXApp.IsPX(pid) Then Exit Function
    
    GetHolidays = CDDXLib.DefaultZEWSProxy(BSConsts.DDX_PID).RetrieveHolidays(CDDXLogin.sid)
End Function

Private Sub DeselectTheCurrent()
' Dim txt As String
' Dim splitrow As Long
' Dim splitcol As Long
'
'    If Selection Is Nothing Then Exit Sub
'    If StrComp(TypeName(Selection), "Range", vbTextCompare) <> 0 Then Exit Sub
'
'    Call GetSplits(BSConsts.DDX_PID, ActiveSheet, splitrow, splitcol)
'
'    With Selection.Cells(1, 1)
'        If .row <= splitrow Or .Column <= splitcol Then Exit Sub
'
'        txt = CStr(.value)
'        If txt <> vbNullString Then
'            .Font.ColorIndex = IIf(IsNumeric(txt), CURVE_CHANGE_CLR_IDX, CURVE_ERROR_CLR_IDX)
'        End If
'    End With
End Sub

Public Sub SetFindCriterion(ByVal pid As String, sheet As Worksheet, ByVal aCriterion As String)
    If Not CDDXApp.IsPX(pid) Then Exit Sub
    Call CSheet.WSSetProp(sheet, CURVE_SHEET_FIND_CRITERION, IIf(aCriterion = vbNullString, " ", aCriterion))
End Sub

Public Function GetFindCriterion(ByVal pid As String, sheet As Worksheet) As String
    If Not CDDXApp.IsPX(pid) Then Exit Function
    GetFindCriterion = CSheet.WSGetProp(sheet, CURVE_SHEET_FIND_CRITERION)
End Function

Public Sub NotifyCurveUploadResult(ByVal pid As String, data As ZEWSProxy.ICurveResult, params As CCurveParams)
    If Not CDDXApp.IsPX(pid) Then Exit Sub
    
    Call CCurveControl.ResetAfterUploaded(params, data)
    RaiseEvent OnEvent(Me, CURVE_EVENT_SHOW_UPLOAD_RESULTS, params, vbNullString, data, 0)
End Sub

'Public Sub MergeCurveStyle(WB As Workbook)
' Dim stl As style
'    Exit Sub
'    For Each stl In WB.TableStyles
'        If Not stl.BuiltIn Then
'            If stl.Name = CURVE_TABLE_STYLE_NAME Then Exit Sub
'        End If
'    Next
'    WB.TableStyles.Merge Workbook:=ThisWorkbook
'End Sub

'Public Sub DisableCurveCopyPaste(ByVal pid As String, ByVal aEnabled As Boolean)
' Dim str As String
'
'    If Not cddxapp.IsPX(pid) Then Exit Sub
'    str = cDDXHelper.GetClipboardText(BSConsts.DDX_PID)
'    With Application
'        .CutCopyMode = aEnabled
'        .CellDragAndDrop = aEnabled
'    End With
'    Call cDDXHelper.SetClipboardText(BSConsts.DDX_PID, str)
'
'    Call SetCopyPasteHandler
'End Sub

'Private Function ConvertTwipsToPixels(lngTwips As Long, lngDirection As Long) As Long
'   'Handle to device
'   Dim lngDC As Long
'   Dim lngPixelsPerInch As Long
'   Const nTwipsPerInch = 1440
'
'   lngDC = GetDC(0)
'
'   If (lngDirection = 0) Then       'Horizontal
'      lngPixelsPerInch = GetDeviceCaps(lngDC, WU_LOGPIXELSX)
'   Else                            'Vertical
'      lngPixelsPerInch = GetDeviceCaps(lngDC, WU_LOGPIXELSY)
'   End If
'   lngDC = ReleaseDC(0, lngDC)
'   ConvertTwipsToPixels = (lngTwips / nTwipsPerInch) * lngPixelsPerInch
'
'End Function

Public Function RetrieveCurvePropertyNames(ByVal pid As String) As String()
    If Not CDDXApp.IsPX(pid) Then Exit Function
    
    If CDDXLogin.SessionExpired() Then Exit Function
    
    On Local Error GoTo OOPS
    RetrieveCurvePropertyNames = GetCurvePropertyNames(pid)
    
OOPS:
    If Err.Number <> 0 Then
        Call CDDXHelper.LogError(Err.Description, "GetCurvePropertyNames")
    End If
    
    On Local Error GoTo 0
    Exit Function
End Function

Public Function RetrieveCurvePropertyValues(ByVal pid As String, ByVal aName As String) As String()
    If Not CDDXApp.IsPX(pid) Then Exit Function
    
    If CDDXLogin.SessionExpired() Then Exit Function
    
    On Local Error GoTo OOPS
    RetrieveCurvePropertyValues = CDDXLib.DefaultZEWSProxy(BSConsts.DDX_PID).RetrieveCurvePropertyValueList(CDDXLogin.sid, aName)
OOPS:
    If Err.Number <> 0 Then
        Call CDDXHelper.LogError(Err.Description, "RetrieveCurvePropertyValueList")
    End If
    
    On Local Error GoTo 0
    Exit Function
End Function

Public Function RetrieveCurveFilterValues(ByVal pid As String, ByVal aName As String) As ZEWSProxy.LabelValue()
    If Not CDDXApp.IsPX(pid) Then Exit Function
    If CDDXLogin.SessionExpired() Then Exit Function
    
    On Local Error GoTo OOPS
    RetrieveCurveFilterValues = CDDXLib.DefaultZEWSProxy(BSConsts.DDX_PID).RetrieveCurveFilterValues(CDDXLogin.sid, aName)
OOPS:
    If Err.Number <> 0 Then
        Call CDDXHelper.LogError(Err.Description, "RetrieveCurveFilterValues")
    End If
    
    On Local Error GoTo 0
    Exit Function
End Function

Public Sub MacroEditDateSettings(ByVal pid As String)
 Dim errmsg As String
 Dim errNum As Long
     
    If Not CDDXApp.IsPX(pid) Then Exit Sub
    If CDDXLogin.SessionExpired() Then Exit Sub
    Call DeselectTheCurrent

    On Local Error GoTo OOPS
    
    Set CCurveDates.TargetSheet = ActiveSheet
    RaiseEvent OnEvent(Me, CURVE_EVENT_CHANGE_DATE_RANGE, CCurveDates.ParamEntity, vbNullString, vbNullString, vbNullString)
    
OOPS:
    errNum = Err.Number
    If errNum <> 0 Then
        errmsg = Err.Description
    End If
    
    If errNum <> 0 Then
        Err.Raise errNum, , errmsg
    End If
    
    On Local Error GoTo 0
    Exit Sub
End Sub

Public Sub MacroContract(ByVal pid As String, Optional ByVal doExtend As Boolean = False)
 Dim errmsg As String
 Dim errNum As Long
 Dim d1 As Double
 Dim d2 As Double
 
    If Not CDDXApp.IsPX(pid) Then Exit Sub
    Call DeselectTheCurrent
    
    On Local Error GoTo OOPS
    
    Set CCurveDates.TargetSheet = ActiveSheet

    CCurveControl.m_isExtend = False
    
    If ContractsEditable(DDX_PID) Then
        RaiseEvent OnEvent(Me, CURVE_EVENT_EXTEND, CCurveDates.ParamEntity, vbNullString, CURVE_UI_CONTRACTS_NEW, 0)
    Else
        Call CCurveDates.GetContractBounds(d1, d2)
        If d2 = 0 Or d1 = 0 And Not doExtend Then
            RaiseEvent OnEvent(Me, CURVE_EVENT_EXTEND, CCurveDates.ParamEntity, vbNullString, IIf(doExtend, CURVE_UI_CONTRACTS_NEW, CURVE_UI_CONTRACTS_DEFINE), 0)
        Else
            CCurveControl.m_isExtend = True
            RaiseEvent OnEvent(Me, CURVE_EVENT_EXTEND, CCurveDates.ParamEntity, vbNullString, IIf(doExtend, CURVE_UI_CONTRACTS_NEW, CURVE_UI_CONTRACTS_NEW_WITH_DIRECTION), 0)
        End If
    End If
    
OOPS:
    errNum = Err.Number
    If errNum <> 0 Then
        errmsg = Err.Description
    End If
    
    Set CCurveDates.TargetSheet = Nothing
    
    If errNum <> 0 Then
        Err.Raise errNum, , errmsg
    End If
    
    On Local Error GoTo 0
    Exit Sub
End Sub

Public Sub MacroContractPlusMinus(ByVal pid As String, ByVal op As Integer)
 Dim errmsg As String
 Dim errNum As Long
 
    If Not CDDXApp.IsPX(pid) Then Exit Sub
    Call DeselectTheCurrent
 
    On Local Error GoTo OOPS
    
    Do
        Set CCurveDates.TargetSheet = ActiveSheet

        With CCurveDates.ParamEntity
            If op = CURVE_UI_CONTRACTS_START_MINUS Or op = CURVE_UI_CONTRACTS_END_MINUS Then
                If .rowCount <= 2 Then Exit Do
            Else
                If .rowCount <= 1 Then Exit Do
            End If
        End With
        
        CCurveControl.m_isExtend = True
        RaiseEvent OnEvent(Me, CURVE_EVENT_EXTEND, CCurveDates.ParamEntity, vbNullString, op, 0)
        Exit Do
    Loop
    
OOPS:
    errNum = Err.Number
    If errNum <> 0 Then
        errmsg = Err.Description
    End If
    
    Set CCurveDates.TargetSheet = Nothing
    
    If errNum <> 0 Then
        Err.Raise errNum, , errmsg
    End If
    
    On Local Error GoTo 0
    Exit Sub
End Sub

Public Sub MacroSort(ByVal pid As String, ByVal aColumn As Long)
 Dim errmsg As String
 Dim errNum As Long
 
    If Not CDDXApp.IsPX(pid) Then Exit Sub
    Call DeselectTheCurrent

     If aColumn > 1 Then
        FSort = -1
        Call ShowSortMenu
        If FSort = -1 Then Exit Sub
    Else
        FSort = 0
        Call ShowSortMenu
    End If

    On Local Error GoTo OOPS
    
    Set CCurveDates.TargetSheet = ActiveSheet
    
    Call CCurveControl.Unprotect(ActiveSheet)
    Call CCurveControl.sort(aColumn)
    Call CCurveControl.Protect(ActiveSheet)

OOPS:
    errNum = Err.Number
    If errNum <> 0 Then
        errmsg = Err.Description
    End If
    
    Set CCurveDates.TargetSheet = Nothing
    
    If errNum <> 0 Then
        Err.Raise errNum, , errmsg
    End If
    
    On Local Error GoTo 0
    Exit Sub
    
End Sub

Public Sub MacroSortS(ByVal pid As String, ByVal aGroupName As String, ByVal aCurveName As String)
 Dim errmsg As String
 Dim errNum As Long
 
    If Not CDDXApp.IsPX(pid) Then Exit Sub
    Call DeselectTheCurrent

    If aCurveName <> vbNullString Then
        FSort = -1
        Call ShowSortMenu
        If FSort = -1 Then Exit Sub
    Else
        FSort = 0
        Call ShowSortMenu
    End If

    On Local Error GoTo OOPS
    
    Set CCurveDates.TargetSheet = ActiveSheet
    
    Call CCurveControl.Unprotect(ActiveSheet)
    Call CCurveControl.sorts(aGroupName, aCurveName)
    Call CCurveControl.Protect(ActiveSheet)
    
OOPS:
    errNum = Err.Number
    If errNum <> 0 Then
        errmsg = Err.Description
    End If
    
    Set CCurveDates.TargetSheet = Nothing
    
    If errNum <> 0 Then
        Err.Raise errNum, , errmsg
    End If
    
    On Local Error GoTo 0
    Exit Sub
End Sub

Private Function WarningOnFormulaLost() As Boolean
    WarningOnFormulaLost = (CDDXApp.DialogMessage("Formulas, if any, will be lost." + vbCrLf + "Are you sure to continue ?", vbQuestion Or vbYesNo) = vbYes)
End Function

Private Sub UpdateSheetID()
 Dim tsk As String
 Dim sht As Worksheet
 Dim params As CCurveParams
 
    Set sht = ActiveSheet
    tsk = CSheet.ZESheetID(sht)
    If Not CTimer.CancelMonitor(tsk) Then Exit Sub
    
    tsk = CDDXLib.DefaultZEWSProxy(DDX_PID).NewGUID()
    CSheet.ZESheetID(sht) = tsk
    
    Set CCurveDates.TargetSheet = sht
    Set params = CCurveDates.ParamEntity
    
    params.sheetId = tsk
    Call CCurveControl.SaveCurveProperties(sht, params)
End Sub

Public Function MacroDownload(ByVal pid As String) As Boolean
 Dim errmsg As String
 Dim errNum As Long
 
    If Not CDDXApp.IsPX(pid) Then Exit Function
    If CDDXLogin.SessionExpired() Then Exit Function
    Call DeselectTheCurrent
    If CDDXLogin.SessionExpired() Then Exit Function
    
    On Local Error GoTo OOPS
    
    Set CCurveDates.TargetSheet = ActiveSheet
    Do
        If Not CCurveControl.CacheCurves(-1, False) Then Exit Do
        
        If Not RefreshInquiry(vbNullString) Then Exit Do
        
        Call UpdateSheetID
        MacroDownload = CCurveControl.RefreshDateRangeCurve(ActiveSheet, Nothing, False, False)
        Exit Do
    Loop
    
OOPS:
    errNum = Err.Number
    If errNum <> 0 Or Not MacroDownload Then
        If errNum <> 0 Then errmsg = Err.Description
        Set CCurveDates.TargetSheet = Nothing
    End If
    
    'If Not IsAnyFormVisible() Then Set CCurveDates.TargetSheet = Nothing
    
    If errNum <> 0 Then
        Err.Raise errNum, , errmsg
    End If
    
    On Local Error GoTo 0
    Exit Function
End Function
        
Private Function RefreshInquiry(ByVal aCurveName As String) As Boolean
 Dim idx As Integer
 Dim hasnulls As Boolean
 Dim ret
 
    If Not CDDXDates.DateSystem1900(ActiveWorkbook, True) Then Exit Function
    
    If aCurveName <> vbNullString Then
        idx = CCurveDates.ParamEntity.GetCurvePosition(aCurveName)
    Else
        idx = -1
    End If
    
    If idx >= 0 Then
        If Not CCurveControl.ValidateSheet(idx, hasnulls) Then
            CDDXApp.StatusMessage = "Error Found!"
            Exit Function
        End If
    End If
    
    Call RaiseCurveEvent(DDX_PID, CURVE_EVENT_REFRSH_ALL_CURVES, vbNullString, ret, 0)
    RefreshInquiry = ret '
End Function

Private Function RefreshInquiryEx(ByVal aGroupName As String, ByVal aCurveName As String) As Integer
 Dim idx As Long
 Dim target As Long

    If Not CDDXDates.DateSystem1900(ActiveWorkbook, True) Then Exit Function
    
    If aCurveName <> vbNullString Then
        idx = CCurveDates.ParamEntity.GetCurvePosition(aCurveName)
    Else
        idx = -1
    End If
    
    If CCurveDates.ParamEntity.IsFlag(CURVE_FLG_MRBD) Then
        RaiseEvent OnEvent(Me, CURVE_EVENT_INQUIREY_DOWNLOAD_COLUMNS, CCurveDates.ParamEntity, aCurveName, True, target)
        RefreshInquiryEx = target
    Else
        If CDDXApp.DialogMessage(aCurveName + vbCrLf + vbCrLf + "Any changes or formulas entered in this curve will be lost." + vbCrLf + "Would you like to continue ?", vbQuestion Or vbYesNo) = vbYes Then
            RefreshInquiryEx = (CURVE_DOWNLOAD_RECENT Or CURVE_DOWNLOAD_CURRENT)
        End If
    End If
End Function

Private Function CanUpload(hasnulls As Boolean, Optional ByVal aGroupName As String = vbNullString, Optional ByVal aCurveName As String = vbNullString) As Boolean
 Dim idx As Long
 Dim row As Long
 Dim col As Long
 Dim ret As Long
 
    If Not CDDXDates.DateSystem1900(ActiveWorkbook, True) Then Exit Function
    
    With CCurveDates.ParamEntity
        If .rowCount <= 1 Or .ColumnCount <= 1 Then
            CDDXHelper.LastMessage = "Empty table!"
            Call CDDXApp.DialogMessage(CDDXHelper.LastMessage, vbExclamation)
            Exit Function
        End If

        If aCurveName = vbNullString Then
            idx = -1
        Else
            idx = CCurveDates.ParamEntity.GetCurvePosition(aCurveName)
        End If
    End With
    
    ret = CCurveControl.CheckDataFormats(CCurveDates.ParamEntity, idx, row, col)
    If ret < 0 Then
        Call CDDXApp.DialogMessage("Error found (Row " + CStr(row) + ", Col " + CCurveControl.GetColumnLetter(ActiveSheet.Cells(row, col).Address) + ")", vbExclamation)
        Exit Function
    End If
    
    If ret > 0 Then
        If CDDXApp.DialogMessage("Wrong cell format found (Row " + CStr(row) + ", Col " + CCurveControl.GetColumnLetter(ActiveSheet.Cells(row, col).Address) + ")" + vbCrLf + _
                                                            "Would you want them to be corrected automatically ?", vbYesNo Or vbQuestion) = vbYes Then
            Call CCurveControl.ResetAllDataFormats(CCurveDates.ParamEntity, idx)
        End If
    End If
    
    If Not CCurveControl.ValidateSheet(idx, hasnulls) Then
        Call CDDXApp.DialogMessage(CDDXHelper.LastMessage, vbExclamation)
        Exit Function
    End If
    
    CanUpload = True
End Function

Public Function MacroUpload(ByVal pid As String) As Boolean
 Dim errmsg As String
 Dim errNum As Long
 Dim ok As Boolean
 Dim hasnulls As Boolean

    If Not CDDXApp.IsPX(pid) Then Exit Function
        
    If CDDXLogin.SessionExpired() Then Exit Function

    Call DeselectTheCurrent
    'If Not CCurveControl.TryAccessToCurve() Then Exit Function
        
    On Local Error GoTo OOPS
    
    Do
        Set CCurveDates.TargetSheet = ActiveSheet
        
        If Not CCurveControl.CacheCurves(-1, True) Then Exit Do
        
        If Not CanUpload(hasnulls) Then Exit Do
        If Not InquiryUpload(vbNullString, hasnulls) Then Exit Do
        
        Call UpdateSheetID
        MacroUpload = CCurveControl.UploadDateRangeCurve()
        
        ok = True
        Exit Do
    Loop
    
OOPS:
    errNum = Err.Number
    If errNum <> 0 Or Not ok Then
        If errNum <> 0 Then errmsg = Err.Description
        Set CCurveDates.TargetSheet = Nothing
    End If
    
    'If Not IsAnyFormVisible() Then Set CCurveDates.TargetSheet = Nothing
    
    If errNum <> 0 Then
        Err.Raise errNum, , errmsg
    End If
    
    On Local Error GoTo 0
    Exit Function
End Function

Public Sub MacroEditDateSettingsS(ByVal pid As String)
 Dim errmsg As String
 Dim errNum As Long
 
    If Not CDDXApp.IsPX(pid) Then Exit Sub
    If CDDXLogin.SessionExpired() Then Exit Sub
    
    On Local Error GoTo OOPS
    
    Call DeselectTheCurrent
    Set CCurveDates.TargetSheet = ActiveSheet

    If CCurveControl.SaveEffectiveStartDate() Then
        RaiseEvent OnEvent(Me, CURVE_EVENT_CHANGE_DATE, CCurveDates.ParamEntity, vbNullString, vbNullString, vbNullString)
    End If

OOPS:
    errNum = Err.Number
    If errNum <> 0 Then
        errmsg = Err.Description
    End If
    
    'If Not IsAnyFormVisible() Then Set CCurveDates.TargetSheet = Nothing
    
    If errNum <> 0 Then
        Err.Raise errNum, , errmsg
    End If
    
    On Local Error GoTo 0
    Exit Sub
End Sub
        
Public Sub MacroContractS(ByVal pid As String)
 Dim errmsg As String
 Dim errNum As Long

    If Not CDDXApp.IsPX(pid) Then Exit Sub
    
    On Local Error GoTo OOPS
    
    Set CCurveDates.TargetSheet = ActiveSheet
    Call MacroContract(DDX_PID)
    
OOPS:
    errNum = Err.Number
    If errNum <> 0 Then
        errmsg = Err.Description
    End If
    
    Set CCurveDates.TargetSheet = Nothing
    
    If errNum <> 0 Then
        Err.Raise errNum, , errmsg
    End If
    
    On Local Error GoTo 0
    Exit Sub
End Sub
        
Public Function MacroDownloadAllS(ByVal pid As String) As Boolean
 Dim errmsg As String
 Dim errNum As Long
 
    If Not CDDXApp.IsPX(pid) Then Exit Function
    Call DeselectTheCurrent
    If CDDXLogin.SessionExpired() Then Exit Function
    
    On Local Error GoTo OOPS
    
    Do
        Set CCurveDates.TargetSheet = ActiveSheet
        
        If Not CCurveControl.CacheCurves(-1, False) Then Exit Do
        
        If CCurveDates.ParamEntity.rowCount >= 2 Then
            If Not RefreshInquiry(vbNullString) Then Exit Do
        End If
        
        If Not CCurveControl.SaveEffectiveStartDate() Then Exit Do
        
        Call UpdateSheetID
        MacroDownloadAllS = CCurveControl.RefreshSingleDateCurves(ActiveSheet, Nothing)
        
        Exit Do
    Loop
    
OOPS:
    errNum = Err.Number
    If errNum <> 0 Or Not MacroDownloadAllS Then
        If errNum <> 0 Then errmsg = Err.Description
        Set CCurveDates.TargetSheet = Nothing
    End If
    
    If errNum <> 0 Then
        Err.Raise errNum, , errmsg
    End If
    
    On Local Error GoTo 0
    Exit Function
End Function

'Public Sub ScrollToView(ByVal pid As String, rgn As range)
'    If Not CDDXApp.IsPX(pid) Then Exit Sub
'    Call Application.Goto(rgn, True)
'End Sub

Public Function MacroUploadAllS(ByVal pid As String) As Boolean
 Dim errmsg As String
 Dim errNum As Long
 Dim ok As Boolean
 Dim hasnulls As Boolean
 Dim failed As Variant
 
    If Not CDDXApp.IsPX(pid) Then Exit Function
        
    If CDDXLogin.SessionExpired() Then Exit Function
    Call DeselectTheCurrent
'    If Not CCurveControl.TryAccessToCurve() Then Exit Function
        
    On Local Error GoTo OOPS
    
    Do
        Set CCurveDates.TargetSheet = ActiveSheet
        
        If Not CCurveControl.CacheCurves(-1, True) Then Exit Do
        
        If Not CanUpload(hasnulls) Then Exit Do
        If Not InquiryUpload(vbNullString, hasnulls) Then Exit Do
        
        If CCurveControl.SaveEffectiveStartDate() Then
            
            Call UpdateSheetID
            MacroUploadAllS = CCurveControl.UploadSingleDateCurves()
            ok = True
        End If

        Exit Do
    Loop

OOPS:
    errNum = Err.Number
    If errNum <> 0 Or Not ok Then
        If errNum <> 0 Then errmsg = Err.Description
        Set CCurveDates.TargetSheet = Nothing
    End If
        
    If errNum <> 0 Then
        Err.Raise errNum, , errmsg
    End If
    
    On Local Error GoTo 0
    Exit Function
End Function

Public Sub MacroViewHistoryS(ByVal pid As String, ByVal aGroupName As String, ByVal aCurveName As String)
 Dim errmsg As String
 Dim errNum As Long
 
    If Not CDDXApp.IsPX(pid) Then Exit Sub
    If CDDXLogin.SessionExpired() Then Exit Sub
    If Not CDDXDates.DateSystem1900(ActiveWorkbook, True) Then Exit Sub
    
    Call DeselectTheCurrent
    On Local Error GoTo OOPS
    
    Set CCurveDates.TargetSheet = ActiveSheet
    
    If CCurveControl.SaveEffectiveStartDate() Then
        RaiseEvent OnEvent(Me, CURVE_EVENT_VIEW_HISTORY, CCurveDates.ParamEntity, aCurveName, vbNullString, vbNullString)
    End If

OOPS:
    errNum = Err.Number
    If errNum <> 0 Then
        errmsg = Err.Description
    End If

    'If Not IsAnyFormVisible() Then Set CCurveDates.TargetSheet = Nothing

    If errNum <> 0 Then
        Err.Raise errNum, , errmsg
    End If
    
    On Local Error GoTo 0
    Exit Sub
End Sub

Public Sub MacroDeleteS(ByVal pid As String, ByVal aGroupName As String, ByVal aCurveName As String)
 Dim errmsg As String
 Dim errNum As Long
 
    If Not CDDXApp.IsPX(pid) Then Exit Sub
    Call DeselectTheCurrent
    If CDDXApp.DialogMessage(aCurveName + vbCrLf + vbCrLf + "Would you like to delete?", vbQuestion Or vbYesNo) <> vbYes Then Exit Sub
    
    On Local Error GoTo OOPS
    
    Call CXLEvents.DisableEvents
    Set CCurveDates.TargetSheet = ActiveSheet
    
    Call CCurveControl.Unprotect(ActiveSheet)
    Call CCurveControl.DeleteSingleDateCurve(ActiveSheet, aGroupName, aCurveName)
    Call CCurveControl.Protect(ActiveSheet)
    
OOPS:
    errNum = Err.Number
    If errNum <> 0 Then
        errmsg = Err.Description
    End If
    
    Set CCurveDates.TargetSheet = Nothing
    Call CXLEvents.RestoreEvents
    
    If errNum <> 0 Then
        Err.Raise errNum, , errmsg
    End If
    
    On Local Error GoTo 0
    Exit Sub
End Sub

Public Sub MacroDownloadS(ByVal pid As String, ByVal aGroupName As String, ByVal aCurveName As String)
 Dim ret As Integer
 Dim errmsg As String
 Dim errNum As Long
 Dim ok As Boolean
 
    If Not CDDXApp.IsPX(pid) Then Exit Sub
    If CDDXLogin.SessionExpired() Then Exit Sub
    Call DeselectTheCurrent

    On Local Error GoTo OOPS
    
    Set CCurveDates.TargetSheet = ActiveSheet
    
    If CCurveDates.ParamEntity.rowCount <= 1 Then
        If Not CCurveControl.CacheCurves(-1, False) Then Exit Sub
        Call MacroDownloadAllS(pid)
        Exit Sub
    End If
    
    Do
        If Not CCurveControl.CacheCurves(aCurveName, False) Then Exit Do
        
        ret = RefreshInquiryEx(aGroupName, aCurveName)
        If ret = 0 Then Exit Do
        
        If Not CCurveControl.SaveEffectiveStartDate() Then Exit Do
        
        Call UpdateSheetID
        Call CCurveControl.RefreshSingleDateCurvesIndividual(ActiveSheet, aGroupName, aCurveName, ret)
        
        ok = True
        Exit Do
    Loop
    
OOPS:
    errNum = Err.Number
    If errNum <> 0 Or Not ok Then
        If errNum <> 0 Then errmsg = Err.Description
        Set CCurveDates.TargetSheet = Nothing
    End If
    
    'If Not IsAnyFormVisible() Then Set CCurveDates.TargetSheet = Nothing
    
    If errNum <> 0 Then
        Err.Raise errNum, , errmsg
    End If
    
    On Local Error GoTo 0
    Exit Sub
End Sub

Private Function InquiryUpload(curveNm As String, hasnulls As Boolean) As Boolean
 Const FEMSG As String = "Uploading empty values is not supported when Four Eyes is on."
 Dim ret As Variant
    
'    If FourEyesActive And hasnulls Then
'        If Not CDDXApp.Quiet Then
'            Call CDDXApp.DialogMessage(FEMSG, vbExclamation)
'        Else
'            CDDXApp.StatusMessage = FEMSG
'        End If
'        Exit Function
'    End If
    
    Call RaiseCurveEvent(DDX_PID, _
                        CURVE_EVENT_INQUIRY_UPLOAD, _
                        curveNm, _
                        IIf(hasnulls, CURVE_INQUIRY_HAS_NULLS, 0), ret)
    If ret < 0 Then Exit Function
    
    If FourEyesActive And hasnulls And UploadNulls Then
        If Not CDDXApp.Quiet Then
            Call CDDXApp.DialogMessage(FEMSG, vbInformation)
        Else
            CDDXApp.StatusMessage = FEMSG
        End If
    End If
    
    InquiryUpload = True
End Function

Public Sub MacroUploadS(ByVal pid As String, ByVal aGroupName As String, ByVal aCurveName As String)
 Dim errmsg As String
 Dim errNum As Long
 Dim ok As Boolean
 Dim hasnulls As Boolean
 
    If Not CDDXApp.IsPX(pid) Then Exit Sub
    If CDDXLogin.SessionExpired() Then Exit Sub
    Call DeselectTheCurrent
'    If Not CCurveControl.TryAccessToCurve() Then Exit Sub
        
    On Local Error GoTo OOPS
    
    Do
        Set CCurveDates.TargetSheet = ActiveSheet
        
        If Not CCurveControl.CacheCurves(aCurveName, True) Then Exit Do
        
        If Not CanUpload(hasnulls, aGroupName, aCurveName) Then Exit Do
        If Not InquiryUpload(aCurveName, hasnulls) Then Exit Do
        
        If CCurveControl.SaveEffectiveStartDate() Then
            Call UpdateSheetID
            Call CCurveControl.UploadSingleDateCurvesIndividual(aGroupName, aCurveName)
            ok = True
        End If
        
        Exit Do
    Loop

OOPS:
    errNum = Err.Number
    If errNum <> 0 Or Not ok Then
        If errNum <> 0 Then errmsg = Err.Description
        Set CCurveDates.TargetSheet = Nothing
    End If
    
    If errNum <> 0 Then
        Err.Raise errNum, , errmsg
    End If
    
    On Local Error GoTo 0
    Exit Sub
End Sub

Public Function GetCurveSortCommand(ByVal pid As String) As Integer
    If Not CDDXApp.IsPX(pid) Then Exit Function
    GetCurveSortCommand = FSort
End Function

Private Sub ShowSortMenu()
    'FSort = -1
    RaiseEvent OnEvent(Me, CURVE_EVENT_SORT, Nothing, vbNullString, FSort, 0)
End Sub

Public Function IsCurveUploadSuccessful(ByVal pid As String, data As ZEWSProxy.ICurveResult) As Boolean
 Dim rlt() As ZEWSProxy.insertUpdateCurveDataResult
 Dim errors() As String
 Dim k As Long
 Dim count As Long
 Dim errcount As Long
    
    If Not CDDXApp.IsPX(pid) Then Exit Function
    rlt = data.UploadResult
    For k = LBound(rlt) To UBound(rlt)
        count = rlt(k).numRecordsInserted + rlt(k).numRecordsUpdated + rlt(k).numRecordsDeleted
        errors = rlt(k).errors
        If Len(Join(errors)) > 0 Then errcount = errcount + 1
    Next
    
    IsCurveUploadSuccessful = IIf(count > 0 And errcount = 0, True, False)
End Function

'Private Sub SetCopyPasteHandler()
' Dim key As String
'
'    key = "^v"
'    With Application
'        If .CellDragAndDrop Then
'            .OnKey key
'        Else
'            .OnKey key, "MacroDoPaste"
'        End If
'    End With
'End Sub

Public Sub NotifyEndTask(ByVal pid As String)
    If Not CDDXApp.IsPX(pid) Then Exit Sub
    RaiseEvent OnEvent(Me, CURVE_EVENT_END_TASK, Nothing, vbNullString, 0, 0)
End Sub

Public Sub NotifyStartTask(ByVal pid As String, ByVal taskID As String, ByVal taskName As String, ByVal curveName As String)
    If Not CDDXApp.IsPX(pid) Then Exit Sub
    RaiseEvent OnEvent(Me, CURVE_EVENT_START_TASK, Nothing, curveName, taskID, taskName)
End Sub

Public Function newCurves(ByVal pid As String, _
                        ByVal aSheetID As String, _
                        aCurves As Variant, _
                        ByVal aStartDate As String, ByVal aEndDate As String, _
                        ByVal aGranularities As Long, _
                        ByVal aExclWeekends As String, _
                        ByVal aExclHolidays As String, _
                        ByVal flagValues As Long, _
                        aProps As Variant, _
                        ByVal aCriterion As String, _
                        ByVal aIsEditing As Boolean) As Boolean
                             
    If Not CDDXApp.IsPX(pid) Then Exit Function
    
    
    If CDDXHelper.IsFlag(flagValues, CURVE_FLG_FUTURE_RANGE) Then
        newCurves = CCurveControl.NewDateRangeCurve(aSheetID, aCurves, aStartDate, aEndDate, aExclWeekends, aExclHolidays, aGranularities, flagValues, aIsEditing)
        
    Else
        newCurves = CCurveControl.NewSingleDateCurves(aSheetID, _
                                        aCurves, _
                                        aStartDate, aEndDate, aExclWeekends, aExclHolidays, aGranularities, _
                                        flagValues, _
                                        aProps, _
                                        aCriterion, _
                                        aIsEditing)
    End If
    
    If Not newCurves Then
        Set CCurveDates.TargetSheet = Nothing
    End If
End Function

Public Sub AddContracts(ByVal pid As String, sht As Worksheet, ByVal op As Integer, ByVal aFrom As Variant, ByVal aTo As Variant)
    If Not CDDXApp.IsPX(pid) Then Exit Sub
    
    If iserror(Application.Caller) Then
        Set CCurveDates.TargetSheet = ActiveSheet
    End If
    
    Call CCurveControl.AddContracts(sht, op, aFrom, aTo)
    
    Set CCurveDates.TargetSheet = Nothing
End Sub

Public Sub RefreshDateRangeCurve(ByVal pid As String, sheet As Worksheet, params As CCurveParams, ByVal PreserveInputs As Boolean, ByVal preserveContracts As Boolean)
    If Not CDDXApp.IsPX(pid) Then Exit Sub
    Call CCurveControl.RefreshDateRangeCurve(sheet, params, PreserveInputs, preserveContracts)
End Sub

Public Sub RefreshSingleDateCurves(ByVal pid As String, sheet As Worksheet, params As CCurveParams)
    If Not CDDXApp.IsPX(pid) Then Exit Sub
    If Not CCurveControl.RefreshSingleDateCurves(sheet, params) Then
        Set CCurveDates.TargetSheet = Nothing
    End If
    
End Sub

Public Function UploadActiveSheet() As Boolean
    If Not CDDXHelper.IsCurveSheet(ActiveSheet) Then Exit Function

    If CCurveControl.IsSheetGrouped(ActiveSheet) Then
        Exit Function
    End If
    
    If CDDXHelper.IsFlag(GetFVS(ActiveSheet), CURVE_FLG_FUTURE_RANGE) Then
        UploadActiveSheet = MacroUpload(BSConsts.DDX_PID)
    Else
        UploadActiveSheet = MacroUploadAllS(BSConsts.DDX_PID)
    End If
End Function

Public Function DownloadActiveSheet() As Boolean
    If Not CDDXHelper.IsCurveSheet(ActiveSheet) Then Exit Function
    
    If CCurveControl.IsSheetGrouped(ActiveSheet) Then
        Exit Function
    End If
    
    If CDDXHelper.IsFlag(GetFVS(ActiveSheet), CURVE_FLG_FUTURE_RANGE) Then
        DownloadActiveSheet = MacroDownload(BSConsts.DDX_PID)
    Else
        DownloadActiveSheet = MacroDownloadAllS(BSConsts.DDX_PID)
    End If
End Function

Public Function GetBuildTime(curveNames() As String, oprDate As Date) As String()
    GetBuildTime = CDDXLib.DefaultZEWSProxy(BSConsts.DDX_PID).GetCurveBuildDateTime(CDDXLogin.CredentialToken(DDX_PID), curveNames, CDbl(oprDate))
End Function

Public Function GetStatus(curveNames() As String, oprDate As Date, arrivalStatus As Boolean, validationStatus As Boolean) As String()
    GetStatus = CDDXLib.DefaultZEWSProxy(DDX_PID).GetCurveStatus(CDDXLogin.CredentialToken(DDX_PID), curveNames, CDbl(oprDate), IIf(arrivalStatus, &H1, 0) Or IIf(validationStatus, &H2, 0))
End Function

Public Function GetParams(ByVal pid As String, sht As Worksheet) As CCurveParams
    If Not CDDXApp.IsPX(pid) Then Exit Function
    If sht Is Nothing Then
        Set GetParams = CCurveDates.ParamEntity
    Else
        Set GetParams = CCurveControl.GetParams(sht)
    End If
End Function

Public Function UploadFile(curves() As String, oprDates() As Date, contrDates() As Date, ByVal granularity As String, ByVal DataFilePath As String) As String()
 Dim api As New CAPICurves
 
    UploadFile = api.UploadFile(curves, oprDates, contrDates, granularity, DataFilePath)
    Set api = Nothing
End Function

Public Function GetGranularityName(ByVal granularityCode As Long) As String
    GetGranularityName = CCurveGranularity.GetGranularityName(granularityCode)
End Function

Public Sub UploadFile2(dtaSource As Variant, resultOutput As Variant)
 Dim api As New CAPICurves
 
    Call api.UploadFile2(dtaSource, resultOutput)
    Set api = Nothing
End Sub

'Public Sub RaiseUploadCompletedEvent(ByVal pid As String, sheet As Worksheet, ByVal msg As String)
'    If Not CDDXApp.IsPX(pid) Then Exit Sub
'
'    RaiseEvent OnUploadCompleted(Me, sheet, msg)
'End Sub
'
'Public Sub RaiseDownloadCompletedEvent(ByVal pid As String, sheet As Worksheet, ByVal msg As String)
'    If Not CDDXApp.IsPX(pid) Then Exit Sub
'
'    RaiseEvent OnDownloadCompleted(Me, sheet, msg)
'End Sub

Public Function GetContractBounds(ByVal pid As String, sheet As Worksheet, contractMin As Date, contractMax As Date) As Boolean
 Dim d1 As Double
 Dim d2 As Double
 
    If Not CDDXApp.IsPX(pid) Then Exit Function

    Call CCurveDates.GetContractBounds(d1, d2)
    contractMin = CDate(d1)
    contractMax = CDate(d2)
    GetContractBounds = IIf(d1 = 0, False, True)
End Function

'Public Function NewFiltersInstance() As CCurveFilters
'    Set NewFiltersInstance = New CCurveFilters
'End Function

Public Function GetContractDateFormat(ByVal granularity As Long) As String
    If CCurveGranularity.IsGranularity(granularity, CURVE_GRANULARITY_MONTHLY) Then
        GetContractDateFormat = CDDXDates.SystemMonthFormat
        
    ElseIf CCurveGranularity.IsGranularity(granularity, CURVE_GRANULARITY_DAILY) Then
        GetContractDateFormat = CDDXDates.SystemDateFormat
        
    ElseIf CCurveGranularity.IsGranularity(granularity, CURVE_GRANULARITY_HOURLY) Then
        GetContractDateFormat = CDDXDates.SystemDateFormat + " hh"
        
    ElseIf CCurveGranularity.IsGranularity(granularity, CURVE_GRANULARITY_MINUTELY) Then
        GetContractDateFormat = CDDXDates.SystemDateFormat + " hh:mm"
        
    ElseIf CCurveGranularity.IsGranularity(granularity, CURVE_GRANULARITY_WEEKLY) Then
        GetContractDateFormat = CDDXDates.SystemDateFormat
        
    ElseIf CCurveGranularity.IsGranularity(granularity, CURVE_GRANULARITY_QUARTERLY) Then
        GetContractDateFormat = CDDXDates.SystemMonthFormat
        
    ElseIf CCurveGranularity.IsGranularity(granularity, CURVE_GRANULARITY_HALFYEAR) Then
        GetContractDateFormat = CDDXDates.SystemMonthFormat
    
    ElseIf CCurveGranularity.IsGranularity(granularity, CURVE_GRANULARITY_YEARLY) Then
        GetContractDateFormat = CDDXDates.SystemYearFormat
    End If
End Function

Public Function GetFVS(sht As Worksheet) As Long
 Dim params As CCurveParams
 
    On Error GoTo OOPS
    
    GetFVS = Val(CSheet.WSGetProp(sht, CURVE_SHEET_FLAGVALUES))
    If GetFVS > 0 Then Exit Function
    
    Select Case CSheet.ZESheetType(sht)
        Case ZESHEET_CURVE_DATERANGE:
            GetFVS = CURVE_FLG_FUTURE_RANGE Or CURVE_FLG_V1
       
        Case ZESHEET_CURVE_SINGLEDATE_RDOL:
            GetFVS = CURVE_FLG_MRBD Or CURVE_FLG_V1

        Case ZESHEET_CURVE_SINGLEDATE_EDIT:
            GetFVS = CURVE_FLG_EDIT_MRBD_COLUMN Or CURVE_FLG_V1
            
        Case ZESHEET_CURVE_SINGLEDATE_FLX1:
            GetFVS = CURVE_FLG_EDIT_DATES Or CURVE_FLG_V1
            
        Case ZESHEET_CURVE_SINGLEDATE_EXCL:
            GetFVS = CURVE_FLG_V1

        Case ZESHEET_CURVE_SINGLEDATE_TRANS:
            GetFVS = CURVE_FLG_PIVOT Or CURVE_FLG_V1

        Case ZESHEET_CURVE_TIMESERIES:
             GetFVS = CURVE_FLG_TIMESERIES Or CURVE_FLG_V1

        Case ZESHEET_CURVE_TIMESERIES_TRANS:
             GetFVS = CURVE_FLG_TIMESERIES Or CURVE_FLG_PIVOT Or CURVE_FLG_V1
    End Select

    If GetFVS > 0 Then
        Set params = New CCurveParams
        
        Call params.FromXML(CCurveControl.GetCurveProperties(sht))
        GetFVS = GetFVS Or params.flagValues
        params.flagValues = GetFVS
        Call CCurveControl.SaveCurveProperties(sht, params)
        
        Call CSheet.WSSetProp(sht, CURVE_SHEET_FLAGVALUES, CDDXHelper.ToHexStr(GetFVS))
    End If
    
OOPS:
    On Error GoTo 0
    Exit Function
End Function

Public Sub RaiseCurveEvent(ByVal pid As String, ByVal eventID As Long, ByVal curveName As String, wParam As Variant, lParam As Variant)
 Dim obj As Object
 
    If Not CDDXApp.IsPX(pid) Then Exit Sub
    
    Select Case eventID
        Case CURVE_EVENT_INQUIRY_UPLOAD:
            Set obj = CCurveDates.ParamEntity
    End Select
    
    RaiseEvent OnEvent(Me, eventID, obj, curveName, wParam, lParam)
End Sub

Public Function GetGranularity(ByVal value As String) As Long
    GetGranularity = CCurveGranularity.GetGranularity(value)
End Function

Public Function UpdateCurveArrivalAndComment(ByVal curveName As String, ByVal updateArrivalStatus As Boolean, ByVal newArrivalStatus As String, ByVal updateComment As Boolean, ByVal newComment As String, Optional oprDates As Variant) As Variant
 Dim dtes() As Long
 Dim tmp() As String
 Dim results() As Variant
 Dim k As Long
 Dim isary As Boolean
 
    If Not updateArrivalStatus And Not updateComment Then Exit Function
    
    If IsMissing(oprDates) Then
        ReDim dtes(0 To 0)
        dtes(0) = 0
        
    Else
        If (VarType(oprDates) And vbDate) = 0 Then
            Err.Raise vbObjectError, ThisWorkbook.name, "Invalid parameter : oprDates"
        End If
        
        If (VarType(oprDates) And vbArray) = 0 Then
            ReDim dtes(0 To 0)
            dtes(0) = Int(CDbl(oprDates))
        
        Else
            isary = True
            ReDim dtes(0 To UBound(oprDates) - LBound(oprDates))
            
            For k = LBound(oprDates) To UBound(oprDates)
                dtes(k) = Int(CDbl(oprDates(k)))
            Next
    
        End If
    End If
    
    tmp = CDDXLib.DefaultZEWSProxy(DDX_PID).UpdateCurveArrivalAndComment(CDDXLogin.sid, curveName, _
                                                IIf(updateArrivalStatus, &H1, &H0) Or IIf(updateComment, &H2, &H0), _
                                                dtes, _
                                                newArrivalStatus, newComment)
    Erase dtes
    
    ReDim results(LBound(tmp) To UBound(tmp))
    
    For k = LBound(tmp) To UBound(tmp)
        If tmp(k) = "1" Then
            results(k) = True
        ElseIf tmp(k) = "0" Then
            results(k) = False
        Else
            results(k) = tmp(k)
        End If
    Next
    
    If isary Then
        UpdateCurveArrivalAndComment = results
    Else
        UpdateCurveArrivalAndComment = results(0)
    End If
End Function

Public Sub MacroAccept(ByVal pid As String, ByVal aCurveName As String)
 Dim wpar As Long
 Dim lpar As String
 Dim opr As Double
 Dim tmp
 
    If Not CDDXApp.IsPX(pid) Then Exit Sub
    If CDDXLogin.SessionExpired() Then Exit Sub
    Call DeselectTheCurrent

    On Error GoTo OOPS
    
    Set CCurveDates.TargetSheet = ActiveSheet
    
    If Not CCurveControl.ValidateDates() Then Exit Sub
    
    If CCurveDates.ParamEntity.IsFlag(CURVE_FLG_TIMESERIES) Then
    
    Else
        If CCurveDates.ParamEntity.IsFlag(CURVE_FLG_FUTURE_RANGE) And Len(aCurveName) > 0 Then
            tmp = CCurveDates.EffectiveDateList
            opr = tmp(Int(Val(aCurveName)))
            
            tmp = CCurveDates.ParamEntity.curves
            aCurveName = tmp(0)
            
            lpar = CStr(opr)
        
        Else 'If CCurveDates.ParamEntity.IsFlag(CURVE_FLG_TIMESERIES) Then
            tmp = CCurveDates.EffectiveDateList
            lpar = CStr(tmp(0))
        End If
    End If
    
    Call RaiseCurveEvent(DDX_PID, CURVE_EVENT_ACCEPT, aCurveName, wpar, lpar)
    If wpar = 0 Then Exit Sub
    
    With CCurveControl
        Call .VRRestoreColors
        
        tmp = GetFVS(ActiveSheet)

        If Len(aCurveName) > 0 Or (tmp And CURVE_FLG_FUTURE_RANGE) > 0 Then
            tmp = .VRAccept(wpar, aCurveName, Int(opr), lpar)
        Else
            tmp = AcceptVRAll(wpar, lpar)
        End If
        
        Call RaiseCurveEvent(DDX_PID, CURVE_EVENT_ACCEPT_RESULTS, vbNullString, wpar, tmp)
    End With
    
OOPS:
    If Err.Number <> 0 Then
        CDDXApp.StatusMessage = Err.Description
        Set CCurveDates.TargetSheet = Nothing
    End If
    
    On Error GoTo 0
    Exit Sub
End Sub

Private Function AcceptVRAll(ByVal acceptTarget As Long, ByVal commentText As String) As Variant
 Dim cvrs() As String
 Dim level As Long
 Dim k As Long
 Dim accepted As Boolean
 Dim results() As Variant
 
    cvrs = CCurveDates.ParamEntity.curves
    
    ReDim results(0 To 2 * (UBound(cvrs) - LBound(cvrs)) + 1)
    
    For k = LBound(cvrs) To UBound(cvrs)
        results(2 * k) = cvrs(k)
        level = GetVRErrLevels(DDX_PID, cvrs(k), 0)
 
        If (level And acceptTarget) <> 0 Then
            If acceptTarget = CURVE_EL_CURVE Then
                accepted = False
            ElseIf acceptTarget = CURVE_EL_CURVETYPE And (level And CURVE_EL_CURVETYPE_ACCEPTED) = 0 Then
                accepted = False
            ElseIf acceptTarget = CURVE_EL_RECORD And (level = CURVE_EL_RECORD_ACCEPTED) = 0 Then
                accepted = False
            Else
                accepted = True
            End If
            
            If Not accepted Then
                results(2 * k + 1) = CCurveControl.VRAccept(acceptTarget, cvrs(k), 0, commentText)
            End If
        End If
    Next
    
    AcceptVRAll = results
End Function

Public Function AcceptVR(ByVal pid As String, ByVal acceptTarget As Long, ByVal aCurveName As String, ByVal oprDate As Double, ByVal commentText As String) As String
    If Not CDDXApp.IsPX(pid) Then Exit Function
    If Not CDDXLogin.Loggedin Then Exit Function
    
    With CCurveControl
        Call .VRRestoreColors
        AcceptVR = .VRAccept(acceptTarget, aCurveName, Int(oprDate), commentText)
    End With
End Function

Public Function GetVRInfo(ByVal pid As String, ByVal levelNum As Long) As Variant
    If Not CDDXApp.IsPX(pid) Then Exit Function
    
    On Error GoTo OOPS
    GetVRInfo = CCurveControl.VRReadStorage(levelNum)

OOPS:
    If Err.Number <> 0 Then
        CDDXApp.StatusMessage = Err.Description
    End If
    Exit Function
End Function

Public Function IsDoubleClick(ByVal pid As String, ByVal sh As Object, ByVal target As range, ByRef cvrName As String, ByRef rcLeft As Long, ByRef rcBottom As Long) As Boolean
    If Not CDDXApp.IsPX(pid) Then Exit Function
    
    cvrName = vbNullString
    IsDoubleClick = CCurveControl.OnDoubleClick(sh, target, cvrName, rcLeft, rcBottom)
End Function

Public Function GetCCurveParams(ByVal pid As String) As CCurveParams
    If Not CDDXApp.IsPX(pid) Then Exit Function
    Set GetCCurveParams = CCurveDates.ParamEntity
End Function

Public Sub CleanVRInfo(ByVal pid As String, Wb As Workbook)
    If Not CDDXApp.IsPX(pid) Then Exit Sub
    Call CCPVRStorage.Clean(Wb)
End Sub

Public Function GetVRColorIndex(ByVal pid As String, ByVal vr As String) As Long
    If Not CDDXApp.IsPX(pid) Then Exit Function
    GetVRColorIndex = CCurveControl.VRGetColorIndex(vr)
    
    If GetVRColorIndex = CURVE_VR_CLRIDX_ERR Then
        GetVRColorIndex = 3
    ElseIf GetVRColorIndex = CURVE_VR_CLRIDX_WARNING Then
        GetVRColorIndex = 9
    ElseIf GetVRColorIndex = CURVE_VR_CLRIDX_UNVALIDATED Then
        GetVRColorIndex = 23
    End If
End Function

Public Sub GetFreezeCoord(ByVal pid As String, sht As Worksheet, ByRef xCoord As Long, ByRef yCoord As Long)
    If Not CDDXApp.IsPX(pid) Then Exit Sub
    
    If CCurveDates.TargetSheet Is Nothing Then
        Set CCurveDates.TargetSheet = sht
    End If
    Call CCurveControl.GetSplits(sht, CCurveDates.ParamEntity, yCoord, xCoord)
End Sub

Public Function GetCurrentValueInfo(ByVal pid As String, ByRef curvName As String, ByRef oprDate As Double, ByRef contrDate As Double, ByRef cvrType As String, ByRef granName As Variant) As Boolean
    If Not CDDXApp.IsPX(pid) Then Exit Function
    
    GetCurrentValueInfo = CCurveControl.GetValuesByCell(Application.ActiveCell, curvName, oprDate, contrDate, cvrType, granName)
End Function

Public Function VRReliableColros(ByVal curveFlgs As Long) As Boolean
    VRReliableColros = True
    
    With CDDXHelper
        If .IsFlag(curveFlgs, CURVE_FLG_PIVOT) Then Exit Function
        If Not .IsFlag(curveFlgs, CURVE_FLG_EDIT_DATES) And Not .IsFlag(curveFlgs, CURVE_FLG_MULTIOBS) Then Exit Function
    End With
    
    VRReliableColros = False
End Function

Public Function GetVRSON(ByVal vrStatus As String) As Long
    If StrComp(vrStatus, "error", vbTextCompare) = 0 Then
        GetVRSON = CURVE_SON_ERROR
    ElseIf StrComp(vrStatus, "warning", vbTextCompare) = 0 Then
        GetVRSON = CURVE_SON_WARNING
    ElseIf StrComp(vrStatus, "not validated", vbTextCompare) = 0 Then
        GetVRSON = CURVE_SON_UNVALIDATED
    ElseIf StrComp(vrStatus, "accepted", vbTextCompare) = 0 Then
        GetVRSON = CURVE_SON_ACCEPTED
    Else
        GetVRSON = CURVE_SON_NOT_SUPPORTED
    End If
End Function

Public Function VRExists(sht As Worksheet) As Boolean
    VRExists = CCPVRStorage.VRExists(sht, vbNullString)
End Function

Public Function GetDateCurveTypes(ByVal curveNm As String, ByVal obsDataType As Long) As String()
 Dim typs() As String
 Dim results As String
 Dim k As Long
 Dim v() As String
 
    If (obsDataType <> CURVE_OBSERVATION_DATE And obsDataType <> CURVE_OBSERVATION_TIMESTAMP) Then
        Err.Raise vbObjectError + 1, "CDDXCurve.GetDateCurveTypes", "Wrong parameter"
    End If
    
    typs = CCurveControl.GetDateObservationTypes(curveNm, CURVE_OBSERVATION_DATE, True)
    If Len(Join(typs)) = 0 Then Exit Function
       
    For k = LBound(typs) To UBound(typs)
        v = Split(typs(k), ",")
        If Int(Val(v(0))) = obsDataType Then
            If Len(results) <> 0 Then results = results + vbTab
            results = results + v(1)
        End If
    Next
    
    If Len(results) > 0 Then GetDateCurveTypes = Split(results, vbTab)
End Function

Public Function ResetCellFormat(pid As String) As Long
    If Not CDDXApp.IsPX(pid) Then Exit Function
    
    Set CCurveDates.TargetSheet = ActiveSheet
    ResetCellFormat = CCurveControl.ResetDataFormat(CCurveDates.ParamEntity)
End Function

Public Function GetVRErrLevels(pid As String, ByVal curve As String, ByVal oprDate As Variant) As Long
    GetVRErrLevels = CCPVRStorage.GetErrLevels(ActiveSheet, curve, oprDate)
End Function

Public Function ContractsEditable(ByVal pid As String) As Boolean
    If Not CDDXApp.IsPX(pid) Then Exit Function
    
    With CCurveDates.ParamEntity
        If Not .IsFlag(CURVE_FLG_EDIT_DATES) Then Exit Function
        ContractsEditable = .IsFlag(CURVE_FLG_TIMESERIES) Or Not .IsFlag(CURVE_FLG_PIVOT)
    End With
End Function

Public Function GetSheetVersion(ByVal fvs As Long) As Long
    GetSheetVersion = fvs \ 2 ^ 28
End Function

Public Sub V2CB(ByVal pid As String, ByVal op As Long)
    If Not CDDXApp.IsPX(pid) Then Exit Sub
    
    Select Case op
        Case CURVE_V2CB_UPLOAD:
            Call V2UploadS
        Case CURVE_V2CB_DOWNLOAD:
            Call V2DownloadS
        Case CURVE_V2CB_VIEW:
            Call V2ViewHistoryS
        Case CURVE_V2CB_ACCEPT_VR:
            Call V2AcceptVR
        Case CURVE_V2CB_DELETE:
            Call V2Delete
    End Select
End Sub

Public Sub GetCurveUIControlInfo(ByVal pid As String, ByVal cvrName As String, ByRef canAcceptVR As Boolean, ByRef isReadOnly As Boolean)
 Dim cvs() As String
 Dim k As Long
 
    If Not CDDXApp.IsPX(pid) Then Exit Sub
    
    isReadOnly = True
    canAcceptVR = False
    
    If Len(cvrName) = 0 Then Exit Sub

    Set CCurveDates.TargetSheet = ActiveSheet
    cvs = CCurveDates.ParamEntity.curves

    For k = LBound(cvs) To UBound(cvs)
        If StrComp(cvrName, cvs(k), vbBinaryCompare) = 0 Then
            isReadOnly = CCurveDates.ParamEntity.Readonly(k)
            If isReadOnly Then
                canAcceptVR = False
            Else
                canAcceptVR = CCurveControl.ShowAccept(k)
            End If
            
            Exit For
        End If
    Next
End Sub

'this is also a new curve API that is callable from custom VBA code
Public Function UpdateCurvePermissions(sht As Worksheet) As Long
 Dim curves() As String
 Dim permstr As String
 Dim permissions() As Long
 Dim params As CCurveParams
 Dim prot As Long
 Dim k As Long
 Dim n As Long
 Dim c As String
 
    On Error GoTo OOPS
    
    If sht Is Nothing Then Exit Function
    If ActiveSheet Is Nothing Then Exit Function
    If StrComp(sht.name, ActiveSheet.name) <> 0 Or StrComp(sht.Parent.name, ActiveSheet.Parent.name) <> 0 Then Exit Function
    
    If GetFVS(sht) = 0 Then Exit Function
    
    Call CXLEvents.DisableEvents
    
    With CCurveDates
        Set .TargetSheet = sht
        Call UpdateSheetID
        
        Set params = .ParamEntity
        
        curves = params.curves
        permstr = CDDXLib.DefaultZEWSProxy(DDX_PID).CPGetCurvePermissions(vbNullString, 0, curves)
        If permstr = vbNullString Then Exit Function
        
        Call UpdateSheetID
        
        ReDim permissions(LBound(curves) To UBound(curves))
        
        For k = LBound(curves) To UBound(curves)
            permissions(k) = -1
            c = Mid(permstr, k + 1, 1)
            If c <> "?" Then
                n = Int(Val(c))
                If n <> IIf(params.Readonly(k), 0, 1) Then permissions(k) = n
            End If
        Next
        
        If sht.ProtectContents Then
            prot = &H1
            Call CCurveControl.Unprotect(sht)
        End If
        
        Call .Handler.IFUpdatePermissions(permissions)
        
        If prot = &H1 Then
            Call CCurveControl.Protect(sht)
        End If
    End With
    
OOPS:
    If Err.Number <> 0 Then
        UpdateCurvePermissions = Err.Number
        CDDXApp.StatusMessage = Err.Description
    End If
    
    Call CXLEvents.RestoreEvents
    Exit Function
End Function

Private Sub Class_Initialize()
 Dim v As String
    
    On Error GoTo OOPS
    
    v = CDDXHelper.GetFromRegistry(CV_PROT_IN_MA, "0")
    FMasks = IIf(v = "1", CURVE_INQUIRY_VALUES_PROT, 0)
    
OOPS:
    Exit Sub
End Sub
Attribute VB_Name = "CDDXDates"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private m_month_format As String
Private m_date_format As String
Private m_year_format As String

Public Property Get DefaultDateStr() As String
    DefaultDateStr = "Default"
End Property

Private Sub GetCurrentWeekDates(ByVal today As Date, ByRef startDate As String, ByRef enddate As String)
 Dim c As Integer
 Dim startdte As Date
 Dim enddte As Date

    startdte = today
    c = WeekDay(startdte, vbMonday)
    If c <> 1 Then
        startdte = DateAdd("d", -c + 1, startdte)
    End If
    enddte = DateAdd("d", 6, startdte)
          
    startDate = CStr(DateSerial(year(startdte), month(startdte), day(startdte)))
    enddate = CStr(DateSerial(year(enddte), month(enddte), day(enddte)))
End Sub

Public Sub GetDynaDates(ByVal aDateIndex As String, ByRef startDate As String, ByRef enddate As String, ByVal referenceDate As String)
 Dim d1 As Date
 Dim d2 As Date
 Dim today As Date
  
    If referenceDate = vbNullString Then
        today = Date
    Else
        today = CDate(ToClientDate(referenceDate))
    End If
    
    If aDateIndex = DYNA_DATE_LAST_WHOLE_WEEK Then
        startDate = LastWholeWeek(today, "start")
        enddate = LastWholeWeek(today, "end")

    ElseIf aDateIndex = DYNA_DATE_LAST_WHOLE_MONTH Then
        startDate = LastWholeXMonths(today, 1, "start")
        enddate = LastWholeXMonths(today, 1, "end")

    ElseIf aDateIndex = DYNA_DATE_LAST_WHOLE_6_MONTHS Then
        startDate = LastWholeXMonths(today, 6, "start")
        enddate = LastWholeXMonths(today, 6, "end")

    ElseIf aDateIndex = DYNA_DATE_LAST_WHOLE_YEAR Then
        startDate = CStr(DateSerial(year(today) - 1, 1, 1))
        enddate = CStr(DateSerial(year(today) - 1, 12, 31))

    ElseIf aDateIndex = DYNA_DATE_ROLLING_YESTERDAY Then
        startDate = DaysBack(today, 1)
        enddate = startDate

    ElseIf aDateIndex = DYNA_DATE_ROLLING_LAST_7_DAYS Then
        startDate = DaysBack(today, 7 - 1)
        enddate = CStr(today)

    ElseIf aDateIndex = DYNA_DATE_ROLLING_LAST_30_DAYS Then
        startDate = DaysBack(today, 30 - 1)
        enddate = CStr(today)

    ElseIf aDateIndex = DYNA_DATE_ROLLING_LAST_6_MONTHS Then
        startDate = MonthsBack(today, 6)
        enddate = CStr(today)

    ElseIf aDateIndex = DYNA_DATE_ROLLING_LAST_9_MONTHS Then
        startDate = MonthsBack(today, 9)
        enddate = CStr(today)

    ElseIf aDateIndex = DYNA_DATE_ROLLING_LAST_365_DAYS Then
        startDate = OneYearBack(today)
        enddate = CStr(today)

    ElseIf aDateIndex = DYNA_DATE_CURRENT_DAY Then
        startDate = CStr(today)
        enddate = CStr(today)

    ElseIf aDateIndex = DYNA_DATE_CURRENT_WEEK Then
        Call GetCurrentWeekDates(today, startDate, enddate)
        enddate = CStr(today)

    ElseIf aDateIndex = DYNA_DATE_CURRENT_MONTH Then
        startDate = CurrentMonthDate(today, "start")
        enddate = CStr(today)

    ElseIf aDateIndex = DYNA_DATE_CURRENT_QUARTER Then
        startDate = CurrentQuarterDate(today, "start")
        enddate = CStr(today)

    ElseIf aDateIndex = DYNA_DATE_CURRENT_YEAR Then
        startDate = CStr(DateSerial(year(today), 1, 1))
        enddate = CStr(today)
              
    ElseIf aDateIndex = DYNA_DATE_CURRENT_WHOLE_WEEK Then
        Call GetCurrentWeekDates(today, startDate, enddate)
              
    ElseIf aDateIndex = DYNA_DATE_CURRENT_WHOLE_MONTH Then
        startDate = CurrentMonthDate(today, "start")
        enddate = CurrentMonthDate(today, "end")

    ElseIf aDateIndex = DYNA_DATE_CURRENT_WHOLE_QUARTER Then
        startDate = CurrentQuarterDate(today, "start")
        enddate = CurrentQuarterDate(today, "end")

    ElseIf aDateIndex = DYNA_DATE_CURRENT_WHOLE_YEAR Then
        startDate = CStr(DateSerial(year(today), 1, 1))
        enddate = CStr(DateSerial(year(today), 12, 31))

    ElseIf aDateIndex = DYNA_DATE_ROLLING_NEXT_7_DAYS Then
        startDate = DaysBack(today, -1)
        enddate = DaysBack(today, -7)
        
    ElseIf aDateIndex = DYNA_DATE_ROLLING_NEXT_30_DAYS Then
        startDate = DaysBack(today, -1)
        enddate = DaysBack(today, -30)
        
    ElseIf aDateIndex = DYNA_DATE_ROLLING_NEXT_6_MONTHS Then
        startDate = DaysBack(today, -1)
        enddate = MonthsBack(today, -6)
        
    ElseIf aDateIndex = DYNA_DATE_ROLLING_NEXT_9_MONTHS Then
        startDate = DaysBack(today, -1)
        enddate = MonthsBack(today, -9)
        
    ElseIf aDateIndex = DYNA_DATE_ROLLING_NEXT_365_DAYS Then
        startDate = DaysBack(today, -1)
        enddate = DaysBack(today, -365)
        
    ElseIf aDateIndex = DYNA_DATE_1ST_QUARTER Then
        startDate = CStr(DateSerial(year(today), 1, 1))
        enddate = CStr(DateSerial(year(today), 3, 31))

    ElseIf aDateIndex = DYNA_DATE_2ND_QUARTER Then
        startDate = CStr(DateSerial(year(today), 4, 1))
        enddate = CStr(DateSerial(year(today), 6, 30))

    ElseIf aDateIndex = DYNA_DATE_3RD_QUARTER Then
        startDate = CStr(DateSerial(year(today), 7, 1))
        enddate = CStr(DateSerial(year(today), 9, 30))

    ElseIf aDateIndex = DYNA_DATE_4TH_QUARTER Then
        startDate = CStr(DateSerial(year(today), 10, 1))
        enddate = CStr(DateSerial(year(today), 12, 31))

    ElseIf aDateIndex = DYNA_DATE_NEXT_WHOLE_WEEK Then
       Call NextWeek(today, d1, d2)
       startDate = DateStr(d1)
       enddate = DateStr(d2)

    ElseIf aDateIndex = DYNA_DATE_NEXT_WHOLE_MONTH Then
       Call NextMonth(today, d1, d2)
       startDate = DateStr(d1)
       enddate = DateStr(d2)
       
    ElseIf aDateIndex = DYNA_DATE_NEXT_WHOLE_6_MONTHS Then
       Call Next6Months(today, d1, d2)
       startDate = DateStr(d1)
       enddate = DateStr(d2)
       
    ElseIf aDateIndex = DYNA_DATE_NEXT_YEAR Then
       Call NextYear(today, d1, d2)
       startDate = DateStr(d1)
       enddate = DateStr(d2)
       
    ElseIf aDateIndex = DefaultDateStr Then
        startDate = VoidDate()
        enddate = VoidDate()
    Else
        startDate = VoidDate()
        enddate = VoidDate()
    End If
End Sub

Private Function DateStr(ByVal dte As Date) As String
    DateStr = CStr(DateSerial(year(dte), month(dte), day(dte)))
End Function

Private Sub NextWeek(ByVal currDte As Date, ByRef startdte As Date, ByRef enddte As Date)
 Dim wd As Integer
 
    wd = WeekDay(currDte, vbMonday)
    startdte = DateAdd("d", 8 - wd, currDte)
    enddte = DateAdd("d", 6, startdte)
End Sub

Private Sub NextMonth(ByVal currDte As Date, ByRef startdte As Date, ByRef enddte As Date)
    currDte = DateAdd("m", 1, currDte)
    startdte = DateSerial(year(currDte), month(currDte), 1)
    enddte = DateSerial(year(currDte), month(currDte), LastDayOfMonth(month(currDte), year(currDte)))
End Sub

Private Sub Next6Months(ByVal currDte As Date, ByRef startdte As Date, ByRef enddte As Date)
    currDte = DateAdd("m", 1, currDte)
    startdte = DateSerial(year(currDte), month(currDte), 1)
    currDte = DateAdd("m", 5, currDte)
    enddte = DateSerial(year(currDte), month(currDte), LastDayOfMonth(month(currDte), year(currDte)))
End Sub

Private Sub NextYear(ByVal currDte As Date, ByRef startdte As Date, ByRef enddte As Date)
 Dim yr As Integer
 
    yr = year(currDte) + 1
    startdte = DateSerial(yr, 1, 1)
    enddte = DateSerial(yr, 12, LastDayOfMonth(12, yr))
End Sub

Public Function GetDynaDateNames() As String()
 Dim ary As String
 
    ary = DYNA_DATE_LAST_WHOLE_WEEK
    ary = ary + vbTab + DYNA_DATE_LAST_WHOLE_MONTH
    ary = ary + vbTab + DYNA_DATE_LAST_WHOLE_6_MONTHS
    ary = ary + vbTab + DYNA_DATE_LAST_WHOLE_YEAR
    ary = ary + vbTab + DYNA_DATE_ROLLING_YESTERDAY
    ary = ary + vbTab + DYNA_DATE_ROLLING_LAST_7_DAYS
    ary = ary + vbTab + DYNA_DATE_ROLLING_LAST_30_DAYS
    ary = ary + vbTab + DYNA_DATE_ROLLING_LAST_6_MONTHS
    ary = ary + vbTab + DYNA_DATE_ROLLING_LAST_9_MONTHS
    ary = ary + vbTab + DYNA_DATE_ROLLING_LAST_365_DAYS
    ary = ary + vbTab + DYNA_DATE_CURRENT_DAY
    ary = ary + vbTab + DYNA_DATE_CURRENT_WEEK
    ary = ary + vbTab + DYNA_DATE_CURRENT_MONTH
    ary = ary + vbTab + DYNA_DATE_CURRENT_QUARTER
    ary = ary + vbTab + DYNA_DATE_CURRENT_YEAR
    ary = ary + vbTab + DYNA_DATE_CURRENT_WHOLE_WEEK
    ary = ary + vbTab + DYNA_DATE_CURRENT_WHOLE_MONTH
    ary = ary + vbTab + DYNA_DATE_CURRENT_WHOLE_QUARTER
    ary = ary + vbTab + DYNA_DATE_CURRENT_WHOLE_YEAR
    
    ary = ary + vbTab + DYNA_DATE_ROLLING_NEXT_7_DAYS
    ary = ary + vbTab + DYNA_DATE_ROLLING_NEXT_30_DAYS
    ary = ary + vbTab + DYNA_DATE_ROLLING_NEXT_6_MONTHS
    ary = ary + vbTab + DYNA_DATE_ROLLING_NEXT_9_MONTHS
    ary = ary + vbTab + DYNA_DATE_ROLLING_NEXT_365_DAYS
    
    ary = ary + vbTab + DYNA_DATE_1ST_QUARTER
    ary = ary + vbTab + DYNA_DATE_2ND_QUARTER
    ary = ary + vbTab + DYNA_DATE_3RD_QUARTER
    ary = ary + vbTab + DYNA_DATE_4TH_QUARTER
    
    ary = ary + vbTab + DYNA_DATE_NEXT_WHOLE_WEEK
    ary = ary + vbTab + DYNA_DATE_NEXT_WHOLE_MONTH
    ary = ary + vbTab + DYNA_DATE_NEXT_WHOLE_6_MONTHS
    ary = ary + vbTab + DYNA_DATE_NEXT_YEAR
    
    GetDynaDateNames = Split(ary, vbTab)
End Function

Private Function LastWholeWeek(ByVal today As Date, StartOrEnd As String) As String
 Dim mondayDate As Date
 Dim sundayDate As Date

    mondayDate = WeekStart(ISOWeekNum(today) - 1, year(today))
    
    If LCase(StartOrEnd) = "start" Then
        LastWholeWeek = CStr(DateSerial(year(mondayDate), month(mondayDate), day(mondayDate)))
    Else
        sundayDate = DateSerial(year(mondayDate), month(mondayDate), day(mondayDate) + 6)
        LastWholeWeek = CStr(DateSerial(year(sundayDate), month(sundayDate), day(sundayDate)))
    End If
End Function

Private Function LastWholeXMonths(ByVal today As Date, numMonths As Integer, StartOrEnd As String) As String
 Dim mosBack, mosBackEnd As Date

    If LCase(StartOrEnd) = "start" Then
        LastWholeXMonths = CStr(DateSerial(year(today), month(today) - numMonths, 1))
    Else
        LastWholeXMonths = CStr(DateSerial(year(today), month(today) - 1, LastDayOfMonth(month(today) - 1, year(today))))
    End If
End Function

Private Function RollingNext(ByVal today As Date, ByVal numDays As Integer) As String
    RollingNext = CStr(DateSerial(year(today), month(today), day(today) + numDays))
End Function

Private Function DaysBack(ByVal today As Date, numDays As Integer) As String
    DaysBack = CStr(DateSerial(year(today), month(today), day(today) - numDays))
End Function

Private Function MonthsBack(ByVal today As Date, numMonths As Integer) As String
    MonthsBack = CStr(DateSerial(year(today), month(today) - numMonths, day(today) + 1))
End Function

Private Function OneYearBack(ByVal today As Date) As String
    OneYearBack = CStr(DateSerial(year(today) - 1, month(today), day(today) + 1))
End Function

Private Function CurrentQuarterDate(ByVal today As Date, StartOrEnd As String) As String
 Dim currentYear, mo1, mo2, day2 As Integer
 Dim endMo, startMo As String

    currentYear = year(today)
    mo1 = 1
    Do While mo1 <= 10
        mo2 = mo1 + 2
        day2 = 31
        If mo2 = 6 Or mo2 = 9 Then
            day2 = 30
        End If
        If today >= DateSerial(currentYear, mo1, 1) And today <= DateSerial(currentYear, mo2, day2) Then
            startMo = Trim(str(mo1))
            If Len(startMo) = 1 Then startMo = "0" + startMo
            endMo = Trim(str(mo2))
            If Len(endMo) = 1 Then endMo = "0" + endMo
            CurrentQuarterDate = CStr(DateSerial(currentYear, endMo, day2))
            If StartOrEnd = "start" Then
                CurrentQuarterDate = CStr(DateSerial(currentYear, startMo, 1))
            End If
            Exit Function
        End If
        mo1 = mo1 + 3
    Loop
End Function

Public Function QuarterDate(StartOrEnd As String, inputDate As Date) As Date
 Dim currentYear, mo1, mo2, day2 As Integer
 Dim endMo, startMo As String

20        currentYear = year(inputDate)
30        mo1 = 1
40        Do While mo1 <= 10
50            mo2 = mo1 + 2
60            day2 = 31
70            If mo2 = 6 Or mo2 = 9 Then
80                day2 = 30
90            End If
100           If inputDate >= DateSerial(currentYear, mo1, 1) And inputDate <= DateSerial(currentYear, mo2, day2) Then
110               startMo = Trim(str(mo1))
120               If Len(startMo) = 1 Then startMo = "0" + startMo
130               endMo = Trim(str(mo2))
140               If Len(endMo) = 1 Then endMo = "0" + endMo
150               QuarterDate = CStr(DateSerial(currentYear, endMo, day2))
160               If StartOrEnd = "start" Then
170                   QuarterDate = CStr(DateSerial(currentYear, startMo, 1))
180               End If
190               Exit Function
200           End If
210           mo1 = mo1 + 3
220       Loop

End Function

Private Function CurrentMonthDate(ByVal today As Date, StartOrEnd As String) As String
 Dim currMo, currYear, lastDay As Integer
 Dim displayMo, displayYear As String

    currMo = month(today)
    displayMo = Trim(str(currMo))
    If Len(displayMo) = 1 Then displayMo = "0" + displayMo
    CurrentMonthDate = CStr(DateSerial(year(today), displayMo, 1))
    If LCase(StartOrEnd) = "end" Then
        lastDay = LastDayOfMonth(currMo, year(today))
        CurrentMonthDate = CStr(DateSerial(year(today), displayMo, lastDay))
    End If
End Function

Public Function MonthDate(StartOrEnd As String, inputDate As Date) As Date
          Dim currMo, currYear, lastDay As Integer
          Dim displayMo, displayYear As String
10        On Error GoTo errorHandler

20        currMo = month(inputDate)
30        displayMo = Trim(str(currMo))
40        If Len(displayMo) = 1 Then displayMo = "0" + displayMo
50        MonthDate = CStr(DateSerial(year(inputDate), displayMo, 1))
60        If LCase(StartOrEnd) = "end" Then
70            lastDay = LastDayOfMonth(currMo, year(inputDate))
80            MonthDate = CStr(DateSerial(year(inputDate), displayMo, lastDay))
90        End If

100       On Error GoTo 0
110       Exit Function
errorHandler:
          Dim errorDescription As String, errorNumber As Long
120       errorDescription = "CDDXDates.MonthDate(), Line:" & str(Erl()) + " " + vbCrLf + Err.Description
130       errorNumber = Err.Number
          'your clean up codes here
140       Err.Raise errorNumber, , errorDescription
End Function

Public Function WeekDate(StartOrEnd As String, inputDate As Date) As Date
          Dim mondayDate, sundayDate As Date
          Dim startMo, startDay, endMo, endDay As String
10        On Error GoTo errorHandler

20        mondayDate = WeekStart(ISOWeekNum(inputDate), year(inputDate))
30        If LCase(StartOrEnd) = "start" Then
40            startDay = Trim(day(mondayDate))
50            startMo = Trim(month(mondayDate))
60            If Len(startDay) = 1 Then startDay = "0" + startDay
70            If Len(startMo) = 1 Then startMo = "0" + startMo
80            WeekDate = CStr(DateSerial(year(mondayDate), CInt(startMo), CInt(startDay)))
90        Else
100           sundayDate = DateSerial(year(mondayDate), month(mondayDate), day(mondayDate) + 6)
110           endDay = Trim(day(sundayDate))
120           endMo = Trim(month(sundayDate))
130           If Len(endDay) = 1 Then endDay = "0" + endDay
140           If Len(endMo) = 1 Then endMo = "0" + endMo
150           WeekDate = CStr(DateSerial(year(sundayDate), CInt(endMo), CInt(endDay)))
160       End If

170       On Error GoTo 0
180       Exit Function
errorHandler:
          Dim errorDescription As String, errorNumber As Long
190       errorDescription = "CDDXDates.WeekDate(), Line:" & str(Erl()) + " " + vbCrLf + Err.Description
200       errorNumber = Err.Number
          'your clean up codes here
210       Err.Raise errorNumber, , errorDescription
End Function

Private Function LastDayOfMonth(ByVal m As Integer, currYear As Integer)
10        On Error GoTo errorHandler

20        LastDayOfMonth = 31
30        If m = 4 Or m = 6 Or m = 9 Or m = 11 Then LastDayOfMonth = 30
40        If m = 2 Then
50            LastDayOfMonth = 28
60            If IsLeapYear(currYear) Then LastDayOfMonth = 29
70        End If

80        On Error GoTo 0
90        Exit Function
errorHandler:
          Dim errorDescription As String, errorNumber As Long
100       errorDescription = "CDDXDates.LastDayOfMonth(), Line:" & str(Erl()) + " " + vbCrLf + Err.Description
110       errorNumber = Err.Number
          'your clean up codes here
120       Err.Raise errorNumber, , errorDescription
End Function

Private Function WeekStart(WhichWeek As Integer, WhichYear As Integer) As Date
10        On Error GoTo errorHandler

20        WeekStart = YearStart(WhichYear) + ((WhichWeek - 1) * 7)

30        On Error GoTo 0
40        Exit Function
errorHandler:
          Dim errorDescription As String, errorNumber As Long
50        errorDescription = "CDDXDates.WeekStart(), Line:" & str(Erl()) + " " + vbCrLf + Err.Description
60        errorNumber = Err.Number
          'your clean up codes here
70        Err.Raise errorNumber, , errorDescription
End Function

Private Function YearStart(WhichYear As Integer) As Date
          Dim WeekDay As Integer
          Dim NewYear As Date
10        On Error GoTo errorHandler

20        NewYear = DateSerial(WhichYear, 1, 1)
30        WeekDay = (NewYear - 2) Mod 7 'Generate weekday index where Monday = 0
40        If WeekDay < 4 Then
50            YearStart = NewYear - WeekDay
60        Else
70            YearStart = NewYear - WeekDay + 7
80        End If

90        On Error GoTo 0
100       Exit Function
errorHandler:
          Dim errorDescription As String, errorNumber As Long
110       errorDescription = "CDDXDates.YearStart(), Line:" & str(Erl()) + " " + vbCrLf + Err.Description
120       errorNumber = Err.Number
          'your clean up codes here
130       Err.Raise errorNumber, , errorDescription
End Function

Private Function IsLeapYear(y As Integer)
10        On Error GoTo errorHandler

20        IsLeapYear = month(DateSerial(y, 2, 29)) = 2

30        On Error GoTo 0
40        Exit Function
errorHandler:
          Dim errorDescription As String, errorNumber As Long
50        errorDescription = "CDDXDates.IsLeapYear(), Line:" & str(Erl()) + " " + vbCrLf + Err.Description
60        errorNumber = Err.Number
          'your clean up codes here
70        Err.Raise errorNumber, , errorDescription
End Function

Private Function ISOWeekNum(AnyDate As Date, Optional WhichFormat As Variant) As Integer
          Dim ThisYear As Integer
          Dim PreviousYearStart As Date
          Dim ThisYearStart As Date
          Dim NextYearStart As Date
          Dim YearNum As Integer
10        On Error GoTo errorHandler

20        ThisYear = year(AnyDate)
30        ThisYearStart = YearStart(ThisYear)
40        PreviousYearStart = YearStart(ThisYear - 1)
50        NextYearStart = YearStart(ThisYear + 1)
60        Select Case AnyDate
              Case Is >= NextYearStart
70                ISOWeekNum = (AnyDate - NextYearStart) \ 7 + 1
80                YearNum = year(AnyDate) + 1
90            Case Is < ThisYearStart
100               ISOWeekNum = (AnyDate - PreviousYearStart) \ 7 + 1
110               YearNum = year(AnyDate) - 1
120           Case Else
130               ISOWeekNum = (AnyDate - ThisYearStart) \ 7 + 1
140               YearNum = year(AnyDate)
150       End Select
160       If IsMissing(WhichFormat) Then Exit Function
170       If WhichFormat = 2 Then
180           ISOWeekNum = CInt(format(right(YearNum, 2), "00") & _
              format(ISOWeekNum, "00"))
190       End If

200       On Error GoTo 0
210       Exit Function
errorHandler:
          Dim errorDescription As String, errorNumber As Long
220       errorDescription = "CDDXDates.ISOWeekNum(), Line:" & str(Erl()) + " " + vbCrLf + Err.Description
230       errorNumber = Err.Number
          'your clean up codes here
240       Err.Raise errorNumber, , errorDescription
End Function

Public Sub GetDateInfo(ByRef dspName As String, ByRef dteFormat As String)
    Call CDDXLib.DefaultZEWSProxy(BSConsts.DDX_PID).GetDateInfo(dspName, dteFormat)
End Sub

Public Function VoidDate() As String
    VoidDate = DateSerial(1899, 12, 31) '"12/31/1899"
End Function

Public Function ToClientDate(ByVal aDte As String) As String
          Dim dte() As String
       
10        On Error GoTo errorHandler

20        If aDte = vbNullString Then
30            ToClientDate = CStr(DateSerial(1899, 12, 31))
40        Else
50            dte = Split(aDte, "/")
60            ToClientDate = CStr(DateSerial(CInt(dte(2)), CInt(dte(0)), CInt(dte(1))))
70        End If

80        On Error GoTo 0
90        Exit Function
errorHandler:
          Dim errorDescription As String, errorNumber As Long
100       errorDescription = "CDDXDates.ToClientDate(), Line:" & str(Erl()) + " " + vbCrLf + Err.Description
110       errorNumber = Err.Number
          'your clean up codes here
120       Err.Raise errorNumber, , errorDescription
End Function

Public Function ToServerDate(ByVal aDte As String) As String
          Dim dte As Date
       
10        On Error GoTo errorHandler

20        If Not IsDateGood(aDte) Then
30            ToServerDate = VoidDate()
40        Else
50            ToServerDate = aDte
60        End If

70        On Error GoTo 0
80        Exit Function
errorHandler:
          Dim errorDescription As String, errorNumber As Long
90        errorDescription = "CDDXDates.ToServerDate(), Line:" & str(Erl()) + " " + vbCrLf + Err.Description
100       errorNumber = Err.Number
          'your clean up codes here
110       Err.Raise errorNumber, , errorDescription
End Function

Public Function CDateSafe(ByVal aDte As String, Optional dateFormat As String = vbNullString, Optional DefaultDate As Date) As Date
          Dim year As Long, month As Long, day As Long
       
10        On Error GoTo errorHandler
          If aDte = vbNullString Then
            CDateSafe = DefaultDate
          End If

20        If CDDXLib.DefaultZEWSProxy(BSConsts.DDX_PID).CDate(aDte, dateFormat, vbNullString, year, month, day) = vbNullString Then Exit Function
30        CDateSafe = DateSerial(year, month, day)

40        On Error GoTo 0
50        Exit Function
errorHandler:
          Dim errorDescription As String, errorNumber As Long
60        errorDescription = "CDDXDates.CDateSafe(), Line:" & str(Erl()) + " " + vbCrLf + Err.Description
70        errorNumber = Err.Number
          'your clean up codes here
80        Err.Raise errorNumber, , errorDescription
End Function

Public Function IsDateGood(ByVal aDte As String, Optional dateFormat As String = vbNullString) As Boolean
          Dim year As Long, month As Long, day As Long
10        On Error GoTo errorHandler

20        IsDateGood = (CDDXLib.DefaultZEWSProxy(BSConsts.DDX_PID).CDate(aDte, dateFormat, vbNullString, year, month, day) <> vbNullString)

30        On Error GoTo 0
40        Exit Function
errorHandler:
          Dim errorDescription As String, errorNumber As Long
50        errorDescription = "CDDXDates.IsDateGood(), Line:" & str(Erl()) + " " + vbCrLf + Err.Description
60        errorNumber = Err.Number
          'your clean up codes here
70        Err.Raise errorNumber, , errorDescription
End Function

Public Function DatePicker(ByVal aTitle As String, ByVal aLeft As Long, ByVal aTop As Long, ByVal aDispDate As String) As String
10        On Error GoTo errorHandler

20        DatePicker = CDDXLib.DefaultZEWSProxy(BSConsts.DDX_PID).CalendarPick(aTitle, aLeft, aTop, aDispDate)

30        On Error GoTo 0
40        Exit Function
errorHandler:
          Dim errorDescription As String, errorNumber As Long
50        errorDescription = "CDDXDates.DatePicker(), Line:" & str(Erl()) + " " + vbCrLf + Err.Description
60        errorNumber = Err.Number
          'your clean up codes here
70        Err.Raise errorNumber, , errorDescription
End Function

Public Property Get SystemDateFormat() As String
    SystemDateFormat = m_date_format
End Property

Public Property Get SystemMonthFormat() As String
    SystemMonthFormat = m_month_format
End Property

Public Property Get SystemYearFormat() As String
    SystemYearFormat = m_year_format
End Property

Public Function CompareDates(dte1 As Date, dte2 As Date) As Integer
    CompareDates = Switch(year(dte1) > year(dte2), 1, year(dte1) < year(dte2), -1, year(dte1) = year(dte2), 0)
    If CompareDates <> 0 Then Exit Function
    
    CompareDates = Switch(month(dte1) > month(dte2), 1, month(dte1) < month(dte2), -1, month(dte1) = month(dte2), 0)
    If CompareDates <> 0 Then Exit Function
    
    CompareDates = Switch(day(dte1) > day(dte2), 1, day(dte1) < day(dte2), -1, day(dte1) = day(dte2), 0)
End Function

Private Sub GetYearFormat()
 Dim current As String
 Dim k As Long
 Dim fmt As String
 
    fmt = SystemDateFormat
    m_year_format = vbNullString
    
    For k = 1 To Len(fmt)
        current = Mid(fmt, k, 1)
        If Asc(LCase(current)) = Asc("y") Then
            m_year_format = m_year_format + current
        End If
    Next
End Sub

Private Sub GetMonthFormat()
 Dim current As String
 Dim tmp As Long
 Dim k As Long
 Dim fmt As String
 Dim c As String
 Dim pre As String
 
    fmt = SystemDateFormat
    m_month_format = vbNullString
    
    For k = 1 To Len(fmt)
        current = Mid(fmt, k, 1)
        tmp = Asc(LCase(current))
        
        If tmp >= Asc("a") And tmp <= Asc("z") Then
            If tmp = Asc("y") Or tmp = Asc("m") Then
                m_month_format = m_month_format + current
            End If
        Else
            m_month_format = m_month_format + current
        End If
    Next
    
    For k = 1 To Len(m_month_format)
        current = LCase(Mid(m_month_format, k, 1))
        If current = "y" Or current = "m" Then
            If k > 1 Then
                m_month_format = Mid(m_month_format, k)
            End If
            Exit For
        End If
    Next
    
    For k = Len(m_month_format) To 1 Step -1
        current = LCase(Mid(m_month_format, k, 1))
        If current = "y" Or current = "m" Then
            If k < Len(m_month_format) Then
                m_month_format = left(m_month_format, k)
            End If
            Exit For
        End If
    Next
    
    fmt = m_month_format
    m_month_format = vbNullString
    pre = vbNullString
    For k = 1 To Len(fmt)
        c = LCase(Mid(fmt, k, 1))
        If c = "m" Or c = "y" Or pre = vbNullString Then
            m_month_format = m_month_format + Mid(fmt, k, 1)
            pre = IIf(c = "m" Or c = "y", vbNullString, c)
        Else
            pre = c
        End If
    Next
    
    m_month_format = Replace(m_month_format, "\", "\/")
End Sub

Public Function ToDDXDate(ByVal dateVal As Date) As String
    ToDDXDate = CStr(Int(CDbl(dateVal)))
End Function

Public Function ToDDXDateTime(ByVal dateVal As Date) As String
    ToDDXDateTime = CStr(CDbl(dateVal))
End Function

Public Function FromDDXDate(ByVal dateVal As String) As Date
    FromDDXDate = CDate(Int(Val(dateVal)))
End Function

Public Function FromDDXDateTime(ByVal dateVal As String) As Date
    FromDDXDateTime = CDate(Val(dateVal))
End Function

Public Function DateSystem1900(wk As Workbook, ByVal showUponErr As Boolean) As Boolean
    If wk.Date1904 Then
        If showUponErr Then
            Call CDDXApp.DialogMessage("Please use 1900 date system.", vbInformation)
        End If
    Else
        DateSystem1900 = True
    End If
End Function

Private Sub Class_Initialize()
 Dim culture As String
 
    m_date_format = vbNullString
    m_month_format = vbNullString
    m_year_format = vbNullString
    
    With CDDXLib.DefaultZEWSProxy(BSConsts.DDX_PID)
        Call .GetDateInfo(culture, m_date_format)
    End With
    
    Call GetMonthFormat
    Call GetYearFormat
End Sub
Attribute VB_Name = "CDDXEntity"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public Event OnBeforeAddOrUpdateEntity(entityTaskId As String)
Public Event OnAfterAddOrUpdateEntity(entityTaskId As String)
Public Event OnEntityError(taskID As String, errMessage As String)
Public Event OnBeforeDeleteEntity(entityTaskId As String)

Public Event OnPopulateProfile(sender As Object, entity As Object) 'ZEWSProxy.ProfileDataEntity)
Public Event OnPopulateReport(sender As Object, entity As Object) ' ZEWSProxy.ReportDataEntity)
Public Event OnPopulateEntity(sender As Object, entity As Object) ' ZEWSProxy.ReportDataEntity)
Public Event OnPopulateDCurveEntity(sender As Object, entity As Object) ' ZEWSProxy.ReportDataEntity)
Public Event OnEntityRetrievedFromServer(sender As Object, entity As Object) ' ZEWSProxy.DataDirectEntity)
Public Event OnGetEntityByTaskId(sender As Object, taskID As String, entity As Object, targetR As Object) ' ZEWSProxy.DataDirectEntity)
Public Event OnValueReady(sender As Object, ByVal taskID As String, value As Variant) ' ZEWSProxy.DataDirectEntity)
'

Private m_Tag As ZEWSProxy.DataDirectEntity
'
Private m_AllEntities As ZEWSProxy.DataDirectEntities
Private m_calculation_set As Boolean

Public Sub RaiseEventByID(pid As String, eventID As Long, entity As ZEWSProxy.DataDirectEntity)
    If Not CDDXApp.IsPX(pid) Then Exit Sub
    
    On Local Error GoTo OOPS
    
    Select Case eventID
        Case 1:     RaiseEvent OnPopulateProfile(Me, entity)   '1
        Case 2:     RaiseEvent OnPopulateReport(Me, entity)      '2
        Case 3:     RaiseEvent OnPopulateEntity(Me, entity)      '3
        Case 4:     RaiseEvent OnEntityRetrievedFromServer(Me, entity) '4
        Case 5:     RaiseEvent OnPopulateDCurveEntity(Me, entity)      '5
    End Select
    
OOPS:
    If Err.Number <> 0 Then
        Call CDDXHelper.LogError(Err.Description, "RaiseEventValueReady")
    End If
    
    On Local Error GoTo -1
    Exit Sub
End Sub

Public Sub RaiseEventValueReady(pid As String, taskID As String, value As Variant)
    If Not CDDXApp.IsPX(pid) Then Exit Sub
    
    On Local Error GoTo OOPS
    RaiseEvent OnValueReady(Me, taskID, value)
    
OOPS:
    If Err.Number <> 0 Then
        Call CDDXHelper.LogError(Err.Description, "RaiseEventValueReady")
    End If
    
    On Local Error GoTo -1
    Exit Sub
End Sub

Private Sub TurnOffCalculation()
    m_calculation_set = False
    If Application.Calculation = xlCalculationAutomatic Then
        m_calculation_set = True
        Application.Calculation = xlCalculationManual
    End If
End Sub

Private Sub RestoreCalculation()
    If m_calculation_set Then
        Application.Calculation = xlCalculationAutomatic
        m_calculation_set = False
    End If
End Sub

Public Sub FireUponEntityError(pid As String, taskID As String, errMessage As String)
    If Not CDDXApp.IsPX(pid) Then Exit Sub
    
    'If entity.executeResult.errorMessage <> vbNullString Then
       RaiseEvent OnEntityError(taskID, errMessage)
    'End If
End Sub

Private Sub RefreshEntitySettings()
 Dim obj As Variant
 
    For Each obj In m_AllEntities.GetEntities()
        Call obj.entityOption.RefreshSettings
    Next
End Sub

Public Property Get AllEntities(pid As String) As ZEWSProxy.DataDirectEntities
    If Not CDDXApp.IsPX(pid) Then Exit Property
              
    If m_AllEntities Is Nothing Then
        Set m_AllEntities = New ZEWSProxy.DataDirectEntities
        Call InstantiateEntities(DDX_PID, Application.ActiveWorkbook)
        
    Else
        Call RefreshEntitySettings
    End If

    Set AllEntities = m_AllEntities
End Property

Public Property Get LiveEntities(pid As String) As ZEWSProxy.DataDirectEntities
    If Not CDDXApp.IsPX(pid) Then Exit Property
              
    If m_AllEntities Is Nothing Then Exit Property
    Call RefreshEntitySettings

    Set LiveEntities = m_AllEntities
End Property

Public Sub RefreshAllEntities(ByVal pid As String, Wb As Workbook, ByVal isRefreshOnlyOnOpen As Boolean)
 Dim entity As ZEWSProxy.DataDirectEntity
 Dim item As Variant
 Dim all As ZEWSProxy.DataDirectEntities

    If Not CDDXApp.IsPX(pid) Then Exit Sub

    Set all = GetEntitiesByWorkBook(BSConsts.DDX_PID, Wb)
    If all Is Nothing Then Exit Sub
          
    For Each item In all.GetEntities() 'AllEntities(BSConsts.DDX_PID).GetEntities
        Set entity = item
        If ((isRefreshOnlyOnOpen = False) Or (isRefreshOnlyOnOpen = True And entity.entityOption.IsRefreshOnOpen = True)) Then
            Call RefreshEntity(pid, entity)
        End If
    Next
End Sub

Public Sub OnIdle(pid As String)
 Dim entity As ZEWSProxy.DataDirectEntity
 Dim item As Variant
    
    On Error GoTo OOPS
    
    If Not CDDXApp.IsPX(pid) Then Exit Sub
    If Not CDDXLogin.PermProfile Then Exit Sub
    
    For Each item In AllEntities(BSConsts.DDX_PID).GetEntities
        Set entity = item

        With entity
            If Not .IsLoading And Not .entityOption.IsOneTimeRequest And Len(.sheetId) > 0 And Not .EntityObject.IsFromFormula Then
                Call EntityOnTimer(entity)
            End If
        End With
    Next

OOPS:
    If Err.Number <> 0 Then
        Call CDDXHelper.LogError(Err.Description, "DataDirectEntitiesOnTimer")
    End If
    
    On Local Error GoTo 0
    Exit Sub
End Sub

Public Function GetAutoRefreshCount(ByVal pid As String) As Long
 Dim entity As ZEWSProxy.DataDirectEntity
 Dim item As Variant
 
    On Error GoTo OOPS
    
    GetAutoRefreshCount = 0
    If Not CDDXApp.IsPX(pid) Then Exit Function
          
    For Each item In AllEntities(BSConsts.DDX_PID).GetEntities
        Set entity = item
        With entity.entityOption
            If Not .IsOneTimeRequest And .IsRefreshPeriodically Then
                GetAutoRefreshCount = GetAutoRefreshCount + 1
            End If
        End With
    Next
    
OOPS:
    If Err.Number <> 0 Then
    
    End If
    On Error GoTo 0
    Exit Function
End Function

Private Function DoPeriodicRefresh(entity As ZEWSProxy.DataDirectEntity) As Long
    With entity.entityOption
        If Not .IsRefreshPeriodically Then Exit Function
        If .RefreshMinutes <= 0 And .RefreshHours <= 0 Then Exit Function
        
        If DateDiff("n", entity.LastRunningTime, Now) >= 60 * .RefreshHours + .RefreshMinutes Then
            DoPeriodicRefresh = IIf(entity.entityOption.RefreshType = RefreshType_FullRefresh, 2, 1)
        End If
    End With
End Function

Private Function DoScheduleRefresh(entity As ZEWSProxy.DataDirectEntity) As Long
 Dim i As Long
 Dim nowTime As Date
 Dim srt As Date

    With entity.entityOption
        If Not .IsRefreshOnSchedule Then Exit Function
        
        nowTime = Now
        nowTime = DateAdd("s", -Second(nowTime), nowTime)
        
        For i = 1 To Len(.RefreshSchedules) Step SCHEDULE_LENGTH
            CDDXScheduleParser.TargetSchedule = Mid(.RefreshSchedules, i, SCHEDULE_LENGTH)
            If Len(CDDXScheduleParser.TargetSchedule) < SCHEDULE_LENGTH Then Exit For

            srt = GetScheduledRefreshTime(nowTime)
            
            CDDXApp.DebugMessage = entity.Moniker + " -> " + CStr(entity.EntityObject.LastRunningTime) + ", " + CStr(srt)
            
            If entity.EntityObject.LastRunningTime < srt Then
                DoScheduleRefresh = IIf(CDDXScheduleParser.IsFull, 2, 1)
                If DoScheduleRefresh = 2 Then Exit Function
            Else
                CDDXApp.DebugMessage = entity.Moniker + " -> SKIPPED"
            End If
        Next
    End With
End Function

Private Function DelayRefresh(entity As ZEWSProxy.DataDirectEntity, refresh As Long) As Boolean
    If refresh = 1 Or refresh = 2 Then
        DelayRefresh = entity.DelayAutoRefresh()
    End If
End Function

Private Sub EntityOnTimer(entity As ZEWSProxy.DataDirectEntity)
 Dim refresh As Long
 Dim refresh2 As Long
 
    If DateDiff("n", entity.EntityObject.LastRunningTime, Now) < 1 Then Exit Sub
    If Not CDDXUtility.RangeExists(DDX_PID, entity) Then Exit Sub

    refresh = DoPeriodicRefresh(entity)
    
    If refresh <> 2 Then
        refresh2 = DoScheduleRefresh(entity)
        If refresh2 > refresh Then refresh = refresh2
    End If

    If DelayRefresh(entity, refresh) Then Exit Sub
    
    If refresh = 2 Then 'full
        CDDXApp.DebugMessage = entity.Moniker + " -> Full"
        Call RefreshEntity(DDX_PID, entity)
        
    ElseIf refresh = 1 Then 'incrmental
        CDDXApp.DebugMessage = entity.Moniker + " -> Incremental"
        Call IncrementalRefreshEntity(DDX_PID, entity)
    Else
    
    End If
End Sub

Public Function InstantiateEntities(ByVal pid As String, Wb As Workbook) As Boolean
    If Not CDDXApp.IsPX(pid) Then Exit Function

    If (Wb Is Nothing) Then Set Wb = Application.ActiveWorkbook
    If (Wb Is Nothing) Then Exit Function
    
 Dim sheet As Worksheet
 Dim xml As String
 Dim newSheetId As String
 Dim entities As ZEWSProxy.DataDirectEntities
 
    For Each sheet In Wb.Worksheets
        If (Len(CDDXHelper.ZESheetID(BSConsts.DDX_PID, sheet)) > 0) Then
            xml = CEntityHelper.ZESheetSavedEntities(sheet)
            If (Len(xml) > 0) Then
                Set entities = New ZEWSProxy.DataDirectEntities
                Set entities = entities.FromXML(xml, CSheet.DOCGetProp(Wb, ZEDOC_VER_CREATOR))
                If (entities.GetCount > 0) Then
                      
'                          Dim k As Integer
'                          Dim entityary() As ZEWSProxy.DataDirectEntity
'110                       entityary = entities.GetEntities()
                          
                    newSheetId = CDDXHelper.NewGUID()
                    Call entities.SetSheetId(newSheetId)
                    CSheet.ZESheetID(sheet) = newSheetId
                    Set entities = CDDXUtility.RemoveEmptyRangeEntities(BSConsts.DDX_PID, entities)
                    If (m_AllEntities Is Nothing) Then
                        Set m_AllEntities = New ZEWSProxy.DataDirectEntities
                    End If
                    Call m_AllEntities.AddEntities(entities)
                End If
            End If
        End If
    Next
End Function

Public Function PersistEntities(pid As String, ByVal isRemoveEmptyRangeEntity As Boolean, Wb As Workbook, entity As ZEWSProxy.DataDirectEntity) As Boolean
    If Not CDDXApp.IsPX(pid) Then Exit Function
    If (Wb Is Nothing) Then Exit Function

    On Error GoTo OOPS

    Dim entities As ZEWSProxy.DataDirectEntities
    Dim sht As Worksheet
    Dim xml As String
    Dim shtid As String
    Dim tmpid As String
    
    If Not entity Is Nothing Then
        shtid = entity.sheetId
    Else
        shtid = vbNullString
    End If
    
    For Each sht In Wb.Worksheets
        tmpid = CDDXHelper.ZESheetID(DDX_PID, sht)
        
        If Len(tmpid) > 0 And (shtid = vbNullString Or shtid = tmpid) Then
            If (m_AllEntities Is Nothing) Then
                Set m_AllEntities = New ZEWSProxy.DataDirectEntities
                Exit Function
            End If
            
            Set entities = m_AllEntities.GetBySheetId(tmpid)
            If (isRemoveEmptyRangeEntity) Then
                Set entities = CDDXUtility.RemoveEmptyRangeEntities(DDX_PID, entities)
            End If
                  
            If entities.GetCount > 0 Then
                xml = entities.ToXML()
                CSheet.ZESheetType(sht) = ZESHEET_ENTITY
            Else
                xml = vbNullString
            End If
            CEntityHelper.ZESheetSavedEntities(sht) = xml
            
            If shtid <> vbNullString Then Exit For
        End If
    Next
    PersistEntities = True

OOPS:
    If Err.Number <> 0 Then
        Call CDDXHelper.LogError(Err.Description, "PersistEntities")
    End If
    Exit Function
End Function

Private Sub PreserveDataRangeFormats(entity As ZEWSProxy.DataDirectEntity, targetRange As range, ByVal origCols As Long, ByVal origRows As Long)
 Dim ohdrs As Long
 Dim nhdrs As Long
 Dim rgn As range
 
    On Error GoTo OOPS
    
    If entity.executeResult.ChangedMasks > 0 Then Exit Sub
    'If entity.entityOption.ResultType = ResultType_ListObject Then Exit Sub
    If origCols <> entity.executeResult.columnsCount Then Exit Sub 'should be redundant
    If Not entity.IsVertical Then Exit Sub
    If Not entity.entityOption.IsPreserveFormat Then Exit Sub
    
    For ohdrs = 1 To origRows
        If CEntityHelper.IsDateCell(targetRange.Cells(ohdrs, 1)) Then 'StrComp(fmt, "@") <> 0 And StrComp(fmt, "General", vbTextCompare) <> 0
            ohdrs = ohdrs - 1
            Exit For
        End If
    Next
    If ohdrs > origRows Then Exit Sub
    nhdrs = entity.executeResult.TotalRowsCount - entity.executeResult.DataRowsCount
    If ohdrs <= nhdrs Then Exit Sub
    
    Set rgn = Application.Selection
    targetRange.Cells(ohdrs + 1, 1).Resize(origRows - ohdrs, origCols).Copy
    targetRange.Cells(nhdrs + 1, 1).PasteSpecial Paste:=xlPasteFormats
    If Not rgn Is Nothing Then rgn.Select
    
OOPS:
    If Err.Number <> 0 Then
        CDDXApp.StatusMessage = Err.Description
    End If
    Exit Sub
End Sub

Public Function PopulateData(pid As String, entity As ZEWSProxy.DataDirectEntity, targetRange As range, _
        Optional IsDeleteTempFile As Boolean = True, Optional IsSetDateFormat As Boolean = True, _
            Optional IsResizeRange As Boolean = True, Optional copiedFromRange As range = Nothing) As range
 Dim origRows As Long
 Dim origCols As Long
 Dim filters() As Variant
 Dim sorts() As Variant
 Dim filterRange As range
 Dim entityRange As range
 Dim targetFilter As AutoFilter
 Dim isEnableEvents As Boolean
 Dim isWorkSheetFilter As Boolean
 Dim isexisting As Boolean
 Dim hiddenColumns() As Boolean
 Dim errmsg As String
 Dim errNum As Long
 Dim targetsite As String
 
    On Error GoTo OOPS
    
    If entity Is Nothing Then Exit Function
    If targetRange Is Nothing Then Exit Function
    If Not CDDXApp.IsPX(pid) Then Exit Function
    
    Call CXLTaskSwitch.DisableTS
    
    If Not entity.EntityObject.IsFromFormula Then Call TurnOffCalculation
    
    isEnableEvents = Application.EnableEvents
    Application.EnableEvents = False
    Call CDDXUtility.SetScreenUpdating(False)

    If (entity.entityOption.IsPreserveFormat = True) Then
        hiddenColumns = CEntityHelper.SaveHiddenColumns(targetRange)
        Set targetFilter = CEntityFilter.GetAutoFilter(targetRange, isWorkSheetFilter)
        If Not targetFilter Is Nothing Then
            Set filterRange = targetFilter.range
            Call CEntityFilter.SaveAutoFilter(targetFilter, filters)
            Call CEntityFilter.saveSort(targetFilter, sorts)
            If isWorkSheetFilter Then targetRange.Worksheet.AutoFilterMode = False
        End If
    End If

    isexisting = (CDDXUtility.RangeExists(BSConsts.DDX_PID, entity))

    If isexisting Then
        If (targetRange.Parent.ProtectContents) Then
            targetRange.Parent.Unprotect
        End If
        Call CEntityHelper.DeleteRefreshingComment(entity)
        
        Call CEntityAdjacentFormulas.RemoveAdjacentFormulas(entity, targetRange)
        
        If (IsResizeRange) And Not entity.IsFromFormula Then
            origRows = targetRange.rows.count
            origCols = targetRange.Columns.count
            
            Call PreserveDataRangeFormats(entity, targetRange, origCols, origRows)
            Set targetRange = CEntityHelper.ResizeRange(entity, targetRange)
        End If
        
        Call CEntityHelper.DeleteExcelResultByRangeName(entity.sheetId, entity.ExcelRangeName, entity.entityOption.IsPreserveFormat, targetRange)
    End If

    RaiseEvent OnBeforeAddOrUpdateEntity(entity.taskID)

    If copiedFromRange Is Nothing Then
        Set entityRange = CEntityHelper.PopulateEntity(entity, targetRange, origCols, origRows)
    Else
        Call copiedFromRange.Copy
        If (entity.IsVertical) Then
            Call targetRange.Cells(1, 1).PasteSpecial(xlPasteAllExceptBorders, xlPasteSpecialOperationNone, False, False)
        Else
            Call targetRange.Cells(1, 1).PasteSpecial(xlPasteAllExceptBorders, xlPasteSpecialOperationNone, False, True)
        End If
        
        Set entityRange = targetRange.Resize(copiedFromRange.rows.count, copiedFromRange.Columns.count)
        'Call CDDXUtility.SetDateFormat(DDX_PID, entity, entityRange)
        Call CEntityHelper.NewNamedRange(entityRange.Worksheet.Parent, entity.ExcelRangeName, entityRange)
        If (entity.entityOption.ResultType = ResultType_ListObject) Then
            Dim tableObject As ListObject
            Set tableObject = targetRange.Worksheet.ListObjects.Add(xlSrcRange, targetRange, , xlYes)
            tableObject.name = entity.ExcelRangeName
            tableObject.TableStyle = "TableStyleMedium18"
            Call CEntityHelper.PopulateTableFormulas(targetRange, entity.entityOption.IsPreserveFormat)
        End If
    End If
        
    Call BoldSeriesName(entity)
'510    Call RemoveAdjacentFormulas(entity, targetRange)
    Call CEntityHelper.AddStyle(entity, entityRange)
    Call CEntityAdjacentFormulas.FillAdjacentFormula(entity, entityRange, True)
    
    If entity.entityOption.IsAdjustWidth Then
        Call CEntityHelper.AdjustColumnWidths((entity.executeResult.HeaderRowsCount > 0 And entity.entityOption.HeaderOption = HeaderOption_SingleRow), entityRange)
    End If
    Call CEntityHelper.AdjustRowHeights(entity, entityRange)
        
    If (entity.entityOption.IsPreserveFormat = True) Then
        Call CEntityHelper.RestoreHiddenColumns(entityRange, hiddenColumns)
        If Not targetFilter Is Nothing And Not filterRange Is Nothing And entity.entityOption.ResultType <> ResultType_ListObject Then
            Call CEntityFilter.RestoreAutoFilters(filterRange, filters)
            Set targetFilter = CEntityFilter.GetAutoFilter(targetRange, isWorkSheetFilter)
            Call CEntityFilter.restoreSort(targetFilter, sorts)
        End If
    End If

    Call CEntityHelper.AddProfileComment(entity, entityRange)
    Call CDDXUtility.SetScreenUpdating(True)
    Call RaiseLoadedEvent(DDX_PID, entity)

    Set PopulateData = entityRange

    Call CEntityHelper.AddOrUpdateEntityRangeCache(entity, entityRange)

    If Not entity.EntityObject.IsFromFormula Then
        If Len(entity.sheetId) = 0 And Not entityRange Is Nothing And copiedFromRange Is Nothing Then
            entity.sheetId = CSheet.ZESheetID(entityRange.Parent)
        End If
    End If
    
OOPS:
    errNum = Err.Number
    If errNum <> 0 Then
        targetsite = Err.source
        errmsg = Err.Description
    End If
    
    Call CXLTaskSwitch.RestoreTS
    
    If Not entity.EntityObject.IsFromFormula Then Call RestoreCalculation
    Application.EnableEvents = isEnableEvents
    
    If (IsDeleteTempFile) Then Call CDDXUtility.DeleteTempFilesByTaskId(entity.taskID)

    If errNum <> 0 Then Call Err.Raise(errNum, targetsite, errmsg)
End Function

Private Sub BoldSeriesName(entity As ZEWSProxy.DataDirectEntity)
    Dim boldTarget                             As Excel.range
    Dim targetRange                            As Excel.range
    Dim rows                                   As Long
    Dim cols                                   As Long
    Dim offset                                 As Long
    Dim i                                      As Long
    Dim FileNum                                As Integer
    Dim filename                               As String
    Dim infoLine                               As String
    Dim file                                   As Object
    Dim strData                                As String
    Dim seriesNameCount
    Dim errmsg As String
        
    On Error GoTo OOPS

    If Not (CDDXUtility.IsReportDataEntity(BSConsts.DDX_PID, entity) Or CDDXUtility.IsProfileDataEntity(BSConsts.DDX_PID, entity)) Then Exit Sub
    
    If entity.entityOption.ResultType = ResultType_ListObject Then Exit Sub
    If Not entity.IsVertical Then Exit Sub
    
    Set boldTarget = Nothing
    offset = entity.executeResult.CaptionRowsCount
    Set targetRange = CDDXUtility.GetRangeByRangeName(entity.sheetId, entity.ExcelRangeName) 'range(entity.ExcelRangeName)
    rows = targetRange.rows.count
    cols = targetRange.Columns.count

    If rows = 1 Or cols = 1 Then Exit Sub
    If cols <= entity.executeResult.DateColumnCount Then Exit Sub
    
    Set boldTarget = targetRange.offset(offset, entity.executeResult.DateColumnCount).Resize(, cols - entity.executeResult.DateColumnCount).rows(1)
    If boldTarget Is Nothing Then Exit Sub
    
    boldTarget.Font.Bold = False

    filename = Replace(CDDXUtility.GetDataFileName(entity.taskID), ".csv", ".info")
    If Len(Dir(filename)) = 0 Then Exit Sub
    
    Set file = CDDXFile.OpenFile(filename)

    strData = CDDXFile.ReadLine(file)
    strData = CDDXFile.ReadLine(file) '"Series Line = 1"
    seriesNameCount = Split(strData, vbTab)

    For i = 1 To boldTarget.Cells.count
        If seriesNameCount(i + entity.executeResult.DateColumnCount - 1) > 0 Then
            boldTarget.Cells(i).Characters(start:=1, length:=seriesNameCount(i + entity.executeResult.DateColumnCount - 1)).Font.Bold = True
        End If
    Next
        
OOPS:
    If Err.Number <> 0 Then
        CDDXApp.StatusMessage = Err.Description
    End If
    Call CDDXFile.CloseFile(file, filename, errmsg)
    If errmsg <> vbNullString Then CDDXApp.StatusMessage = errmsg
    
    Exit Sub
End Sub

Public Sub RaiseLoadedEvent(ByVal pid As String, entity As ZEWSProxy.DataDirectEntity)
    If Not CDDXApp.IsPX(pid) Then Exit Sub
    RaiseEvent OnAfterAddOrUpdateEntity(entity.taskID)
End Sub

Public Function DeleteEntityByPosition(ByVal pid As String, targetRange As range, Optional isShowConfirm As Boolean = True) As Boolean
 Dim entity As ZEWSProxy.DataDirectEntity
 Dim displayName As String

    If Not CDDXApp.IsPX(pid) Then Exit Function
          
    Set entity = CDDXUtility.GetEntityByPosition(BSConsts.DDX_PID, targetRange)
    If Trim(entity.Caption & vbNullString) <> vbNullString Then
        displayName = "[ " & entity.Caption & " ]"
    ElseIf Trim(entity.Moniker & vbNullString) <> vbNullString Then
        displayName = "[ " & entity.Moniker & " ]"
    Else
        displayName = "selected data"
    End If
          
    If Not entity Is Nothing Then
        If isShowConfirm Then
            If (CDDXApp.DialogMessage("Are you sure you want to remove " & displayName & " ?", vbQuestion & vbOKCancel) <> vbOK) Then
                DeleteEntityByPosition = False
                Exit Function
            End If
        End If
        DeleteEntityByPosition = DeleteEntity(pid, entity)
    Else
        Call CDDXApp.DialogMessage("No valid data range is selected.", vbInformation)
        DeleteEntityByPosition = False
    End If
End Function

Public Function DeleteEntity(ByVal pid As String, entity As ZEWSProxy.DataDirectEntity) As Boolean
    If Not CDDXApp.IsPX(pid) Then Exit Function
          
    If Not entity Is Nothing Then
        Dim entityRange As range
        
        Set entityRange = CDDXUtility.GetRangeByRangeName(entity.sheetId, entity.ExcelRangeName)
        If (entity.IsFromFormula = True) Then
            entityRange.offset(-1, 0).Clear
        End If
        
        Dim formulaRange As range
        
        Set formulaRange = CEntityAdjacentFormulas.FillAdjacentFormula(entity, entityRange, False)
        If Not formulaRange Is Nothing Then formulaRange.Clear
              
        RaiseEvent OnBeforeDeleteEntity(entity.taskID)
        Call CEntityHelper.DeleteExcelResultByRangeName(entity.sheetId, entity.ExcelRangeName, False, Nothing)
        Call AllEntities(BSConsts.DDX_PID).DeleteByTaskId(entity.taskID)
        Call CEntityHelper.RemoveEntityRangeFromCache(entity)
        Call PersistEntities(DDX_PID, True, Application.ActiveWorkbook, Nothing)
    End If
    DeleteEntity = True
End Function

Private Sub PickupObjectName(entity As ZEWSProxy.DataDirectEntity)
 Dim rnm As String
       
    With entity
        rnm = CDDXUtility.GetObjectNameByPoint(.sheetId, .RangeTop, .RangeLeft)
        If rnm = vbNullString Then Exit Sub
        entity.ExcelRangeName = rnm
    End With
End Sub

Public Sub LoadEntityAsync(pid As String, entity As ZEWSProxy.DataDirectEntity, ByVal wbName As String)
 Dim rgn As range
 
    If Not CDDXApp.IsPX(pid) Then Exit Sub
          
    On Error GoTo OOPS
    
    Call CTimer.ValidateMonitor
    Call CTimer.StartMonitor(entity.taskID, CStr(entity.EntityVersion))
    
    If Len(wbName) = 0 Then
        Set rgn = CDDXUtility.GetRange(pid, entity)
        If rgn Is Nothing Then wbName = ActiveWorkbook.name
    End If
    
    Call CEntityHelper.ResetTableEntityOutputOptions(entity)
    Call entity.LoadDataAsync(wbName)
    
OOPS:
    If Err.Number = 0 Then
        entity.IsLoading = True
    Else
        Err.Raise Err.Number, Err.source, Err.Description
    End If
End Sub

Public Function RefreshEntity(ByVal pid As String, entity As ZEWSProxy.DataDirectEntity) As Boolean
    If Not CDDXApp.IsPX(pid) Then Exit Function
        
    If entity Is Nothing Then Exit Function
    If entity.entityOption.IsOneTimeRequest = True Then Exit Function
    If entity.IsLoading Then Exit Function
          
    If Not CDDXUtility.SetupEntity(pid, entity) Then Exit Function
    If Not CDDXUtility.RangeExists(BSConsts.DDX_PID, entity) Then Exit Function

    Call CDDXUtility.ShowRefreshingComment(BSConsts.DDX_PID, entity)
          
    Call PickupObjectName(entity)
    Call LoadEntityAsync(BSConsts.DDX_PID, entity, vbNullString)
          
    RefreshEntity = True
End Function

Public Function GetWorkSheetByEntityTaskId(taskID As String) As Worksheet
 Dim entity As ZEWSProxy.DataDirectEntity

    Set entity = AllEntities(BSConsts.DDX_PID).GetByTaskId(taskID)
    If Not (entity Is Nothing) Then
        Dim entityRange As range
        Set entityRange = CDDXUtility.GetRange(BSConsts.DDX_PID, entity)
        If Not entityRange Is Nothing Then
            Set GetWorkSheetByEntityTaskId = entityRange.Worksheet
        End If
    End If
End Function

Public Function GetEntitiesBySheet(pid As String, sheet As Worksheet) As ZEWSProxy.DataDirectEntities
 Dim result As ZEWSProxy.DataDirectEntities

    If Not CDDXApp.IsPX(pid) Then Exit Function
    Set result = New ZEWSProxy.DataDirectEntities
    If (Len(CDDXHelper.ZESheetID(BSConsts.DDX_PID, sheet)) > 0) Then
        Set result = AllEntities(BSConsts.DDX_PID).GetBySheetId(CDDXHelper.ZESheetID(BSConsts.DDX_PID, sheet))
    End If
    Set GetEntitiesBySheet = result
End Function

Public Function GetEntitiesByWorkBook(pid As String, Optional Wb As Workbook) As ZEWSProxy.DataDirectEntities
    If Not CDDXApp.IsPX(pid) Then Exit Function
    If Wb Is Nothing Then Set Wb = Application.ActiveWorkbook
    If Wb Is Nothing Then Exit Function
          
 Dim sheet As Worksheet
 Dim result As ZEWSProxy.DataDirectEntities
 
    Set result = New ZEWSProxy.DataDirectEntities
    For Each sheet In Wb.Worksheets
        Call result.AddEntities(GetEntitiesBySheet(BSConsts.DDX_PID, sheet))
    Next
    Set GetEntitiesByWorkBook = result
End Function

Public Function TransposeEntity(pid As String, entity As ZEWSProxy.DataDirectEntity) As range
    If Not CDDXApp.IsPX(pid) Then Exit Function
    If entity Is Nothing Then Exit Function

    If (entity.entityOption.IsFillFormulas) Then
        CDDXApp.DialogMessage "Cannot transpose because the range contains formulas." + vbLf + " Please uncheck the option of ""fill down formulas adjacent to the right of data"" in the output options.", vbInformation
        Exit Function
    End If
              
 Dim entityRange As range
 Dim targetRange As range
 
    Set entityRange = CDDXUtility.GetRangeByRangeName(entity.sheetId, entity.ExcelRangeName)
    If (CDDXHelper.IsRangeOverFlowed(entityRange, entityRange.Columns.count, entityRange.rows.count)) Then
        CDDXApp.DialogMessage "Cannot transpose because it will overflow.", vbInformation
        Exit Function
    End If
    Set targetRange = entityRange.Cells(1 + entity.executeResult.CaptionRowsCount, 1).Resize(entity.executeResult.columnsCount, entity.executeResult.TotalRowsCount - entity.executeResult.CaptionRowsCount)
    If (Len(CDDXHelper.IsRangeIntersectWithOtherRanges(targetRange, entity.ExcelRangeName)) > 0) Then
        CDDXApp.DialogMessage "Not sufficient space to transpose.", vbInformation
        Exit Function
    End If
              
    If Not CDDXUtility.SaveToFilePivoted(pid, entity, entityRange) Then Exit Function
    Call entityRange.Clear
              
    entity.IsVertical = Not entity.IsVertical
    entity.executeResult.columnsCount = entityRange.rows.count - entity.executeResult.CaptionRowsCount
    If (entity.IsVertical) Then
        entity.executeResult.HeaderRowsCount = entity.executeResult.PreviousHeaderRowsCount
    Else
        entity.executeResult.HeaderRowsCount = 1
    End If
    
    entity.executeResult.DataRowsCount = entityRange.Columns.count - entity.executeResult.HeaderRowsCount
    Set TransposeEntity = PopulateData(BSConsts.DDX_PID, entity, entityRange, True, True, False)
End Function

Private Sub MoveFormulasTo(entity As ZEWSProxy.DataDirectEntity, entityRange As range, targetRange As range)
 Dim formulaRange As range

    Set formulaRange = CEntityAdjacentFormulas.FillAdjacentFormula(entity, entityRange, False)
    If formulaRange Is Nothing Then Exit Sub
          
 Dim areaRange As range
 Dim targetAreaRange As range
 Dim ColumnCount As Long
 
    For Each areaRange In formulaRange.Areas
        Set targetAreaRange = targetRange.offset(entityRange.rows.count - areaRange.rows.count, entityRange.Columns.count + ColumnCount)
        Call CDDXUtility.CopyRange(DDX_PID, areaRange, targetAreaRange, xlPasteAll, False)
        ColumnCount = ColumnCount + areaRange.Columns.count
    Next
    formulaRange.Clear
End Sub

Public Function MoveEntity(ByVal pid As String, entity As ZEWSProxy.DataDirectEntity, targetRange As range) As Boolean
    If Not CDDXApp.IsPX(pid) Then Exit Function
    If (entity Is Nothing) Then Exit Function
    If (targetRange Is Nothing) Then Exit Function
    
 Dim entityRange As range, RangeToBeCleared As range
 
    Set entityRange = CDDXUtility.GetRange(BSConsts.DDX_PID, entity)
    If entityRange Is Nothing Then Exit Function
    
    Set targetRange = targetRange.Resize(entityRange.rows.count, entityRange.Columns.count)
    Set RangeToBeCleared = CDDXUtility.subtractRange(BSConsts.DDX_PID, targetRange, entityRange)
    If Not RangeToBeCleared Is Nothing Then
        If (WorksheetFunction.CountA(RangeToBeCleared) > 0) Then
            Call CDDXApp.DialogMessage("The destination is not empty.", vbInformation)
            Exit Function
        End If
    End If
 
 Dim conflictRangeName As String
 
    conflictRangeName = CDDXHelper.IsRangeIntersectWithOtherRanges(targetRange, entity.ExcelRangeName)
    If (Len(conflictRangeName) > 0) Then
        Call CDDXApp.DialogMessage("The destination is not empty." + vbCrLf + "(" + conflictRangeName + ")", vbInformation)
        Exit Function
    End If
              
    Call PickupObjectName(entity)
    Call CDDXUtility.SetScreenUpdating(False)
              
    If (entityRange.column <= targetRange.column) Then
        Call MoveFormulasTo(entity, entityRange, targetRange)
        Set RangeToBeCleared = CDDXUtility.CopyRange(DDX_PID, entityRange, targetRange, xlPasteAll)
    Else
        Set RangeToBeCleared = CDDXUtility.CopyRange(DDX_PID, entityRange, targetRange, xlPasteAll)
        Call MoveFormulasTo(entity, entityRange, targetRange)
    End If
    
    Set RangeToBeCleared = CDDXUtility.subtractRange(BSConsts.DDX_PID, entityRange, RangeToBeCleared)
    If Not RangeToBeCleared Is Nothing Then
        RangeToBeCleared.Clear
    End If
    If (entity.entityOption.ResultType = ResultType_QueryTable) Then
        Dim excelName As name
        Set excelName = CDDXUtility.GetExcelNameByPosition(entityRange)
        If Not excelName Is Nothing Then
            entityRange.Worksheet.Activate
            excelName.Delete
        End If
        targetRange.Worksheet.Activate
        Call CEntityHelper.NewNamedRange(targetRange.Worksheet.Parent, entity.ExcelRangeName, targetRange)
    Else
        Dim tableObject As ListObject
        Set tableObject = CDDXUtility.GetListObjectByPosition(targetRange)
        tableObject.name = entity.ExcelRangeName
    End If
    
    Call CEntityHelper.AddOrUpdateEntityRangeCache(entity, targetRange)
    Call CDDXUtility.SetScreenUpdating(True)
              
    With entity
        .RangeTop = targetRange.row
        .RangeLeft = targetRange.column
    End With
    If (StrComp(entityRange.Worksheet.Parent.name, targetRange.Worksheet.Parent.name, vbTextCompare) <> 0) Then
        Call PersistEntities(DDX_PID, True, entityRange.Worksheet.Parent, Nothing)
        entity.sheetId = vbNullString
        Call CEntityHelper.SetSheetId(targetRange.Worksheet, entity)
    Else
        If (StrComp(entityRange.Worksheet.name, targetRange.Worksheet.name, vbTextCompare) <> 0) Then
            entity.sheetId = vbNullString
            Call CEntityHelper.SetSheetId(targetRange.Worksheet, entity)
        End If
    End If
    Call PersistEntities(DDX_PID, True, targetRange.Worksheet.Parent, Nothing)
    MoveEntity = True
End Function

Public Function SelectionRefreshEntity(ByVal pid As String, entity As ZEWSProxy.DataDirectEntity) As Boolean
 Dim entityRange As Excel.range
 Dim SelectRange As Excel.range
 Dim targetRange As Excel.range
 Dim startOffset As Long
 Dim endOffset As Long
 Dim minOffset As Long
 Dim maxOffset As Long

    On Error GoTo OOPS
    
    If Not CDDXApp.IsPX(pid) Then Exit Function
    If entity Is Nothing Then Exit Function
    If Not (CDDXUtility.SetupEntity(pid, entity)) Then Exit Function
    
    Call CDDXUtility.ShowRefreshingComment(BSConsts.DDX_PID, entity, "Selection Refreshing ...")
    Set entityRange = CDDXUtility.GetRange(entity.sheetId, entity)
    Set SelectRange = Selection
    startOffset = SelectRange.row - entityRange.row + 1
    endOffset = startOffset + SelectRange.rows.count - 1
    minOffset = entity.executeResult.CaptionAndHeaderRowsCount + 1
    maxOffset = entityRange.rows.count
          
    If startOffset < minOffset Then
        startOffset = minOffset
    End If
    If endOffset > maxOffset Then
        endOffset = maxOffset
    End If
          
    If startOffset > endOffset Then
        Err.Raise vbObjectError + 1, "SelectionRefreshEntity", "Selected region does not contain any data."
    End If
          
    If CDDXUtility.IsDCurveDataEntity(BSConsts.DDX_PID, entity) Then
        Set targetRange = CRefreshSelectionDCurve.SelectRefreshRange(entity, entityRange, SelectRange)
    Else
        Set targetRange = CRefreshSelection.SelectRefreshRange(entity)
    End If
    
    If targetRange Is Nothing Then
        Err.Raise vbObjectError + 1, "SelectionRefreshEntity", "Range is nothing."
    End If
        
    Call targetRange.Select
    entity.ExecutionRefreshType = RefreshType_SelectionRefresh
    
    Call LoadEntityAsync(BSConsts.DDX_PID, entity, vbNullString)
    SelectionRefreshEntity = True

OOPS:
    If Err.Number <> 0 Then
        CDDXApp.StatusMessage = Err.Description
        Call CEntityHelper.DeleteRefreshingComment(entity)
    End If
    
    Exit Function
End Function

Public Function MergeSelectionRefreshResult(ByVal pid As String, entity As ZEWSProxy.DataDirectEntity, entityRange As range) As Boolean
    On Error GoTo OOPS
    
    If Not CDDXApp.IsPX(pid) Then Exit Function
    If (CDDXHelper.IsSelectionRange() = False) Then Exit Function

    Call CEntityHelper.DeleteRefreshingComment(entity)
        
    If CDDXUtility.IsDCurveDataEntity(DDX_PID, entity) Then
        Call CRefreshSelectionDCurve.Merge(entity, entityRange)
    Else
        Call CRefreshSelection.Merge(entity, entityRange)
    End If
    
OOPS:
    If Err.Number <> 0 Then
        Call CDDXApp.DialogMessage(Err.Description, vbInformation)
    End If
    
    Exit Function
End Function

Public Function IncrementalRefreshEntity(ByVal pid As String, entity As ZEWSProxy.DataDirectEntity) As Boolean
    If Not CDDXApp.IsPX(pid) Then Exit Function
    If entity Is Nothing Then Exit Function

    'If CDDXUtility.IsProfileDataEntity(BSConsts.DDX_PID, entity) = False Then Exit Function
    If entity.entityOption.IsOneTimeRequest = True Then Exit Function
    If Not entity.IsVertical Then
        CDDXApp.StatusMessage = "Incremental Refresh is not supported for pivoted profiles."
        Exit Function
    End If
    'If entity.entityOption.DateInputOption <> DateInputOption_Default Then Exit Function
    
'    entity.sid = CDDXLogin.sid
    If CDDXUtility.IsProfileDataEntity(DDX_PID, entity) = True And (Len(entity.ExcelRangeName) = 0) Then
        entity.ExcelRangeName = entity.GenerateExcelRangeName
    Else
        Call CDDXUtility.SetupEntity(DDX_PID, entity)
        'Call GetIncrementalRefreshRange(pid, entity)
    End If
    
    entity.ExecutionRefreshType = RefreshType_IncrementalRefresh
    If Not CRefreshIncremental.CollectSheetDates(entity) Then Exit Function
    
    Call CDDXUtility.ShowRefreshingComment(DDX_PID, entity, "Incremental refreshing ...")
    
    Call LoadEntityAsync(BSConsts.DDX_PID, entity, vbNullString)
    IncrementalRefreshEntity = True
End Function

Public Function MergeIncrementalRefreshResult(ByVal pid As String, entity As ZEWSProxy.DataDirectEntity, entityRange As range) As Boolean
 Dim transferSheet As Worksheet
 Dim refreshedRange As range
 Dim isEnableEvents As Boolean
 Dim startOffset As Long
 Dim endOffset As Long
 Dim rowdiff As Long
 Dim insertCount As Long
 Dim fillRefreshRange As Long
 Dim borderStyle As Variant
 Dim rowInsert As VerticalInsert
 Dim rowDelete As VerticalDelete
 Dim oldDataCount As Long
 Dim errNum As Long
 Dim errmsg As String
 Dim errsite As String
 
    On Error GoTo OOPS
    
    If Not CDDXApp.IsPX(pid) Then Exit Function
        
    Call CDDXUtility.SetScreenUpdating(False)
    Call TurnOffCalculation
    isEnableEvents = Application.EnableEvents
    Application.EnableEvents = False

    Call CEntityHelper.DeleteRefreshingComment(entity)
    Set transferSheet = CTempSheet.GetTransferSheet()
    transferSheet.rows.Clear
    Set refreshedRange = CEntityHelper.LoadEntityByNamedRange(entity, transferSheet.Cells(entityRange.row, entityRange.column), True, False)
    
    If Not refreshedRange Is Nothing Then
        If CDDXUtility.IsDCurveDataEntity(BSConsts.DDX_PID, entity) = True Then
'            Call CRefreshIncremental.Merge(entity, entityRange, refreshedRange)
            
        Else
            Call CRefreshIncremental.Merge(entity, refreshedRange)
        End If
    End If
   
OOPS:
    errNum = Err.Number
    If errNum <> 0 Then
        errmsg = Err.Description
        errsite = Err.source
    End If
    
    Call CDDXUtility.DeleteTempFilesByTaskId(entity.taskID)
    Call CDDXUtility.SetScreenUpdating(True)
    Call RestoreCalculation
    Application.EnableEvents = isEnableEvents
    Application.CutCopyMode = False
    
    If errNum <> 0 Then Err.Raise errNum, errsite, errmsg
End Function

Public Function ChangeExcelRangeName(pid As String, entityTaskId As String, newExcelRangeName As String) As Boolean
 Dim entity As ZEWSProxy.DataDirectEntity
 
    If Not CDDXApp.IsPX(pid) Then Exit Function
    
    If StrComp(newExcelRangeName, "r", vbTextCompare) = 0 Or StrComp(newExcelRangeName, "c", vbTextCompare) = 0 Then Exit Function
    
    Set entity = EntityObject.AllEntities(BSConsts.DDX_PID).GetByTaskId(entityTaskId)
    If entity Is Nothing Then Exit Function

    ChangeExcelRangeName = True
    
    If StrComp(entity.ExcelRangeName, newExcelRangeName, vbTextCompare) = 0 Then Exit Function

    If (entity.entityOption.ResultType = ResultType_QueryTable) Then
        Dim definedName As name
        Set definedName = CDDXUtility.GetExcelNameByRangeName(entity.sheetId, entity.ExcelRangeName)
        If Not definedName Is Nothing Then
            definedName.name = newExcelRangeName
            If definedName.name <> newExcelRangeName Then
                ChangeExcelRangeName = False
                Exit Function
            End If
        End If
    ElseIf (entity.entityOption.ResultType = ResultType_ListObject) Then
        Dim tableObject As ListObject
        Set tableObject = CDDXUtility.GetListObjectBysheetId(entity.sheetId, entity.ExcelRangeName)
        If Not tableObject Is Nothing Then
            tableObject.name = newExcelRangeName
            If tableObject.name <> newExcelRangeName Then
                ChangeExcelRangeName = False
                Exit Function
            End If
        End If
    End If

    Call CEntityHelper.RemoveEntityRangeFromCache(entity)
    entity.ExcelRangeName = newExcelRangeName
End Function

Public Function GetEntityByTaskId(ByVal pid As String, taskID As String, targetR As Object) As ZEWSProxy.DataDirectEntity
    If Not CDDXApp.IsPX(pid) Then Exit Function
          
    Dim result As ZEWSProxy.DataDirectEntity
    
    Set result = DDXObjects.EntityObject.AllEntities(BSConsts.DDX_PID).GetByTaskId(taskID)
    If result Is Nothing Then
        RaiseEvent OnGetEntityByTaskId(Me, taskID, result, targetR)
    End If
        
    If result Is Nothing Then
        Call CDDXUtility.DeleteTempFilesByTaskId(taskID)
    End If
        
    Set GetEntityByTaskId = result
End Function

'Public Function IsEntityStale(ByVal pid As String, result As ZEWSProxy.DataDirectEntity) As Boolean
'    If Not CDDXApp.IsPX(pid) Then Exit Function
'
'    If result.IsAPI Then Exit Function
'    If Not result.IsFromFormula Then Exit Function
'
'    RaiseEvent OnGetEntityByTaskId(Me, result.taskID, result)
'
'    IsEntityStale = IIf(result Is Nothing, True, False)
'End Function

Public Sub SetParams(pid As String, entity As ZEWSProxy.DataDirectEntity) ' ParamArray Values() As Variant)
    If Not CDDXApp.IsPX(pid) Then Exit Sub
    
    Set m_Tag = entity
End Sub

Public Function GetParams(pid As String) As ZEWSProxy.DataDirectEntity
    If Not CDDXApp.IsPX(pid) Then Exit Function
    
    Set GetParams = m_Tag
End Function

Public Function CopyEntity(pid As String) As ZEWSProxy.DataDirectEntity
    If Not CDDXApp.IsPX(pid) Then Exit Function
    If CDDXLogin.SessionExpired() Then Exit Function
    If (CDDXHelper.IsSelectionRange = False) Then Exit Function

 Dim entity As ZEWSProxy.DataDirectEntity
    Set entity = CDDXUtility.GetEntityByPosition(BSConsts.DDX_PID, Application.Selection.Cells(1, 1))
    If Not entity Is Nothing Then
        Set CopyEntity = entity
    End If
End Function
 
Public Function PasteEntity(ByVal pid As String, entity As ZEWSProxy.DataDirectEntity, targetRange As range, Optional IsLinkPaste As Boolean = True) As Boolean
10        If Not CDDXApp.IsPX(pid) Then Exit Function
20        If (entity Is Nothing) Then Exit Function
30        If (targetRange Is Nothing) Then Exit Function
40        On Error GoTo errorHandler
          Dim hasTitle As Boolean
          Dim entityRange As range, copiedEntityObject As ZEWSProxy.DataDirectEntity
50        Set entityRange = CDDXUtility.GetRange(BSConsts.DDX_PID, entity)
60        If Not entityRange Is Nothing Then
70            Set targetRange = targetRange.Resize(entityRange.rows.count, entityRange.Columns.count)
80            If (WorksheetFunction.CountA(targetRange) > 0) Then
90                Call CDDXApp.DialogMessage("The destination is not empty.", vbInformation)
100               Exit Function
110           End If
              Dim conflictRangeName As String
120           conflictRangeName = CDDXHelper.IsRangeIntersectWithOtherRanges(targetRange, entity.ExcelRangeName)
130           If (Len(conflictRangeName) > 0) Then
140               Call CDDXApp.DialogMessage("The destination is not empty." + vbCrLf + "(" + conflictRangeName + ")", vbInformation)
150               Exit Function
160           End If
                
            Call CDDXUtility.SetScreenUpdating(False)
            
            Set copiedEntityObject = cloneEntityObject(entity)
            
            'to assign a new name
            If CDDXUtility.IsProfileDataEntity(DDX_PID, copiedEntityObject) Then
                copiedEntityObject.Moniker = GetNextProfileID(DDX_PID, targetRange.Parent.Parent)
                hasTitle = entity.entityOption.HasProfileEntityTitle
            ElseIf CDDXUtility.IsReportDataEntity(DDX_PID, copiedEntityObject) Then
                copiedEntityObject.Moniker = GetNextReportID(DDX_PID, targetRange.Parent.Parent)
                hasTitle = entity.entityOption.HasReportEntityTitle
            ElseIf CDDXUtility.IsDCurveDataEntity(DDX_PID, copiedEntityObject) Then
                copiedEntityObject.Moniker = GetNextCurveID(DDX_PID, targetRange.Parent.Parent)
                hasTitle = entity.entityOption.HasDCurveEntityTitle
            End If
            
190           If (entityRange.column <= targetRange.column) Then
200               Call MoveFormulasTo(entity, entityRange, targetRange)
210               Call CDDXUtility.CopyRange(DDX_PID, entityRange, targetRange, xlPasteAll)
220           Else
230               Call CDDXUtility.CopyRange(DDX_PID, entityRange, targetRange, xlPasteAll)
240               Call MoveFormulasTo(entity, entityRange, targetRange)
250           End If

260          If IsLinkPaste Then
270               copiedEntityObject.ExcelRangeName = copiedEntityObject.GenerateExcelRangeName
280               Call DDXObjects.EntityObject.AllEntities(BSConsts.DDX_PID).AddOrUpdateEntity(copiedEntityObject)
290               If (copiedEntityObject.entityOption.ResultType = ResultType_QueryTable) Then
300                   targetRange.Worksheet.Activate
310                   Call CEntityHelper.NewNamedRange(targetRange.Worksheet.Parent, copiedEntityObject.ExcelRangeName, targetRange)
320               Else
                          Dim tableObject As ListObject
330                       Set tableObject = CDDXUtility.GetListObjectByPosition(targetRange)
340                       tableObject.name = copiedEntityObject.ExcelRangeName
350               End If
360               Call CEntityHelper.AddOrUpdateEntityRangeCache(copiedEntityObject, targetRange)
370               Call CDDXUtility.SetScreenUpdating(True)
                  
380               If (StrComp(entityRange.Worksheet.Parent.name, targetRange.Worksheet.Parent.name, vbTextCompare) <> 0) Then
390                   copiedEntityObject.sheetId = vbNullString
400                   Call CEntityHelper.SetSheetId(targetRange.Worksheet, copiedEntityObject)
410                   Call PersistEntities(DDX_PID, True, entityRange.Worksheet.Parent, Nothing)
420               Else
430                   If (StrComp(entityRange.Worksheet.name, targetRange.Worksheet.name, vbTextCompare) <> 0) Then
440                       copiedEntityObject.sheetId = vbNullString
450                       Call CEntityHelper.SetSheetId(targetRange.Worksheet, copiedEntityObject)
460                   End If
470               End If
480               Call PersistEntities(DDX_PID, True, targetRange.Worksheet.Parent, Nothing)

                  If entity.Caption = entity.Moniker And entity.Caption = entityRange.Cells(1, 1).value Then
                      copiedEntityObject.Caption = copiedEntityObject.Moniker
                      If hasTitle = True And entity.Caption = targetRange.Cells(1, 1).value Then
                          targetRange.Cells(1, 1).value = copiedEntityObject.Caption
                      End If
                  End If
490          End If
500          PasteEntity = True
510       End If

520       On Error GoTo 0
530       Exit Function
errorHandler:
          Dim errorDescription As String, errorNumber As Long
540       errorDescription = "ddxobjects.CDDXEntity.PasteEntity(), Line:" & str(Erl()) + " " + vbCrLf + Err.Description
550       errorNumber = Err.Number
560       Err.Clear
570       Err.Raise errorNumber, , errorDescription
End Function

Private Function cloneEntityObject(entity As ZEWSProxy.DataDirectEntity) As ZEWSProxy.DataDirectEntity
10        On Error GoTo errorHandler

20        If Not entity Is Nothing Then
              Dim entities As ZEWSProxy.DataDirectEntities, xml As String, newEntities As ZEWSProxy.DataDirectEntities
30            Set entities = New ZEWSProxy.DataDirectEntities
40            Call entities.AddOrUpdateEntity(entity)
50            xml = entities.ToXML()
60            If Len(xml) > 0 Then
70                Set newEntities = New ZEWSProxy.DataDirectEntities
80                Set newEntities = newEntities.FromXML(xml, vbNullString)
90                If newEntities.GetCount > 0 Then
100                   Set cloneEntityObject = newEntities.GetByIndex(0)
110               End If
120           End If
130       End If

140       On Error GoTo 0
150       Exit Function
errorHandler:
          Dim errorDescription As String, errorNumber As Long
160       errorDescription = "CDDXEntity.cloneEntityObject(), Line:" & str(Erl()) + " " + vbCrLf + Err.Description
170       errorNumber = Err.Number
          'your clean up codes here
180       Err.Raise errorNumber, , errorDescription
End Function

Private Function GetNextID(Wb As Workbook, ByVal entityType As Long, ByVal prefixUnnamed As String) As String
 Dim sht As Worksheet
 Dim se As String
 Dim k As Long
 Dim nnum As Long
 Dim tmp As Long

    If Wb Is Nothing Then Exit Function
    
    For Each sht In Wb.Worksheets
        If CDDXHelper.IsEntitySheet(sht) Then
            se = Trim(CSheet.WSGetProp(sht, PROP_SAVED_ENTITIES))
            If Len(se) > 0 Then
                tmp = CDDXLib.DefaultZEWSProxy(DDX_PID).GetNextEntityNumber(se, entityType, prefixUnnamed, Asc("<"), Asc(">"))
                If tmp > nnum Then nnum = tmp
            End If
        End If
    Next
    
    GetNextID = "< " + prefixUnnamed + " " + CStr(IIf(nnum = 0, 1, nnum)) + " >"
End Function

Public Function GetNextProfileID(pid As String, Wb As Workbook) As String
    GetNextProfileID = GetNextID(Wb, 1, "Profile Unnamed")
End Function

Public Function GetNextReportID(pid As String, Wb As Workbook) As String
    GetNextReportID = GetNextID(Wb, 2, "Report Unnamed")
End Function

Public Function GetNextCurveID(pid As String, Wb As Workbook) As String
    GetNextCurveID = GetNextID(Wb, 3, "Curve Unnamed")
End Function

Private Function GetScheduledRefreshTime(ByVal baseTime As Date) As Date
    If CDDXScheduleParser.IsWeekly Then
        GetScheduledRefreshTime = GetWeeklyScheduledTime(baseTime)
    Else
        GetScheduledRefreshTime = GetMonthlyScheduledTime(baseTime)
    End If
End Function

Private Function GetWeeklyScheduledTime(ByVal baseTime As Date) As Date
 Dim dte As Date
 Dim hr As Long
 Dim mins As Long
 Dim diff As Long
 Dim p As Long
 Dim wdays As Long

    With CDDXScheduleParser
        wdays = 0
        If .HasSunday Then wdays = wdays Or &H40
        If .HasSaturday Then wdays = wdays Or &H20
        If .HasFriday Then wdays = wdays Or &H10
        If .HasThursday Then wdays = wdays Or &H8
        If .HasWednesday Then wdays = wdays Or &H4
        If .HasTuesday Then wdays = wdays Or &H2
        If .HasMonday Then wdays = wdays Or &H1
        
        If wdays = 0 Then Exit Function 'foolproof
        
        Select Case WeekDay(baseTime)
            Case vbSunday: p = 6
            Case vbSaturday: p = 5
            Case vbFriday: p = 4
            Case vbThursday: p = 3
            Case vbWednesday: p = 2
            Case vbTuesday: p = 1
            Case vbMonday: p = 0
        End Select
'
        hr = .HourNumber + IIf(.IsMorning, 0, 12)
        mins = .MinuteNumber
 
        If (wdays And (2 ^ p)) <> 0 Then
            dte = CDate(Int(CDbl(baseTime)))
            dte = DateAdd("h", hr, dte)
            dte = DateAdd("n", mins, dte)
        Else
            dte = DateAdd("n", 1, baseTime)
        End If
        
        If baseTime < dte Then
            diff = 0
            Do
                diff = diff - 1
                
                p = p - 1
                If p < 0 Then p = 6
                
                If (wdays And (2 ^ p)) <> 0 Then Exit Do
            Loop
       
            dte = CDate(Int(CDbl(baseTime)))
            dte = DateAdd("d", diff, dte)
            dte = DateAdd("h", hr, dte)
            dte = DateAdd("n", mins, dte)
        End If
    End With
    
    GetWeeklyScheduledTime = dte
End Function

Private Function GetMEndDay(ByVal y As Long, ByVal m As Long) As Date
    GetMEndDay = DateSerial(y + IIf(m = 12, 1, 0), IIf(m = 12, 1, m + 1), 1)
    GetMEndDay = DateAdd("d", -1, GetMEndDay)
End Function

Private Function GetMonthlyScheduledTime(ByVal baseTime As Date) As Date
 Dim y As Long
 Dim m As Long
 Dim d As Long
 Dim dte As Date
 Dim hr As Long
 Dim mins As Long

    hr = CDDXScheduleParser.HourNumber + IIf(CDDXScheduleParser.IsMorning, 0, 12)
    mins = CDDXScheduleParser.MinuteNumber
        
    y = year(baseTime)
    
    If CDDXScheduleParser.MonthNumber = 0 Then 'every month
        m = month(baseTime)
    Else
        m = CDDXScheduleParser.MonthNumber 'no check on >12 & <0
    End If
    
    dte = GetMEndDay(y, m)
    If CDDXScheduleParser.MonthDate = 0 Then
        d = day(dte)
    Else
        d = CDDXScheduleParser.MonthDate
        If d > day(dte) Then d = day(dte)
    End If
  
    dte = DateSerial(y, m, d)
    dte = DateAdd("h", hr, dte)
    dte = DateAdd("n", mins, dte)
    
    If baseTime < dte Then
        If CDDXScheduleParser.MonthNumber = 0 Then
            m = m - 1
            If m <= 0 Then
                m = 12
                y = y - 1
            End If
        Else
            y = y - 1
        End If
        
        If CDDXScheduleParser.MonthDate = 0 Then
            d = 100 'definitely an invalid date so as to be re-valued
        End If
        
        dte = GetMEndDay(y, m)
        If d > day(dte) Then d = day(dte)

        dte = DateSerial(y, m, d)
        dte = DateAdd("h", hr, dte)
        dte = DateAdd("n", mins, dte)
    End If
    
    GetMonthlyScheduledTime = dte
End Function

Public Function DelayAutoRefresh(ByVal entityID As String, wkSheet As Worksheet, ByVal delayType As Long, ByVal delayPasses As Variant) As Long
 Dim entity As Variant
 Dim passes As Double
 Dim shtid As String
 
    If m_AllEntities Is Nothing Then
        DelayAutoRefresh = -&H100
        Exit Function
    End If
    
    If Trim(entityID) = vbNullString And wkSheet Is Nothing Then
        DelayAutoRefresh = -1
        Exit Function
    End If
    
    If delayType < REFRESH_DELAY_NO Or delayType > REFRESH_DELAY_ENDTIME Then
        DelayAutoRefresh = -3
        Exit Function
    End If
    
    Select Case VarType(delayPasses)
        Case vbDate:
            passes = CDbl(delayPasses)
        Case vbLong, vbInteger:
            passes = delayPasses
        Case Else:
            DelayAutoRefresh = -&H200
            Exit Function
    End Select
    
    If passes < 0 Then
        DelayAutoRefresh = -4
        Exit Function
    End If
    
    If Not wkSheet Is Nothing Then shtid = CSheet.ZESheetID(wkSheet)
    
    For Each entity In m_AllEntities.GetEntities()
        If (entityID = vbNullString Or StrComp(entityID, entity.Moniker, vbTextCompare) = 0) And (shtid = vbNullString Or StrComp(shtid, entity.sheetId) = 0) Then
            If entity.SetDelayAutoRefresh(delayType, passes) = 0 Then
                DelayAutoRefresh = DelayAutoRefresh + 1
            End If
        End If
    Next
End Function
Attribute VB_Name = "CDDXFile"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public Function OpenWriteStream() As Object
    Set OpenWriteStream = CreateObject("ADODB.Stream")

    With OpenWriteStream
        Call .Open
        .Type = 2
        .Charset = "UTF-8"
        .LineSeparator = -1
    End With
End Function

Public Sub SetPosition(file As Object, ByVal offset As Long)
    file.position = offset
End Sub

Public Function GetPosition(file As Object) As Long
    GetPosition = file.position
End Function

Public Sub WriteLine(file As Object, txtContent As String, withCarriageReturn As Boolean)
    Call file.WriteText(IIf(Len(txtContent) = 0, "", txtContent), IIf(withCarriageReturn, 1, 0))
End Sub

Public Sub SaveWriteStream(file As Object, ByVal filePath As String, ByRef errmsg As String)
    If file Is Nothing Then Exit Sub
    
    On Error GoTo OOPS
    
    If file.State = 1 Then
        If Len(filePath) > 0 Then Call file.SaveToFile(filePath, 2)
        Call file.Close
    End If
    
OOPS:
    errmsg = IIf(Err.Number <> 0, Err.Description, vbNullString)

    On Error GoTo 0
    Exit Sub
End Sub

Public Function OpenFile(ByVal filePath As String) As Object
    Set OpenFile = CreateObject("ADODB.Stream")

    With OpenFile
        Call .Open
        .Type = 2
        .Charset = "UTF-8"
        Call .LoadFromFile(filePath)
    End With
End Function

Public Sub CloseFile(file As Object, ByVal filePath As String, ByRef errmsg As String)
    On Error GoTo OOPS
    
    If Not file Is Nothing Then
        If file.State = 1 Then
            Call file.Close
        End If
        Set file = Nothing
    End If
    
    If filePath <> vbNullString Then
        Call CDDXHelper.DeleteFile(filePath)
    End If
    
OOPS:
    errmsg = IIf(Err.Number <> 0, Err.Description, vbNullString)
    
    On Error GoTo 0
    Exit Sub
End Sub

Public Function IsEOF(file As Object) As Boolean
    IsEOF = file.EOS()
End Function

Public Function ReadLine(file As Object) As String
    ReadLine = file.ReadText(-2)
End Function
Attribute VB_Name = "CDDXHelper"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

'Public Event OnFingerprint(sender As Object)
Public Event OnEvent(sender As Object, ByVal eventID As Long, ByRef wParam As Variant, ByRef lParam As Variant)

Private F_PASTED As String

Private m_LogPath As String
Private m_userListOrder As Integer
Private m_LogLevel As Integer
Private m_lastMessage As String
Private m_fingerprint As Collection

Public Property Let LastMessage(value As String)
    m_lastMessage = value
End Property

Public Property Get LastMessage() As String
    LastMessage = m_lastMessage
End Property

Public Property Let LogLevel(ByVal value As Integer)
    m_LogLevel = value
    Call SetLog
End Property

Public Property Get LogLevel() As Integer
    LogLevel = m_LogLevel
End Property

Public Property Get LogPath() As String
    LogPath = m_LogPath
End Property

Public Property Let LogPath(ByVal value As String)
    m_LogPath = value
    Call SetLog
End Property

Public Function GetFromRegistry(ByVal aKey As String, Optional ByVal aDef As String = vbNullString) As String
    GetFromRegistry = GetSetting("ZE", "DataDirectAddin", aKey, aDef)
End Function

Public Sub PutToRegistry(ByVal aKey As String, ByVal aValue As String)
    Call SaveSetting("ZE", "DataDirectAddin", aKey, aValue)
End Sub

Public Function GetFromSharedRegistry(ByVal aKey As String, Optional ByVal aDef As String = vbNullString) As String
    GetFromSharedRegistry = GetSetting("ZE", "Shared", aKey, aDef)
End Function

Public Sub PutToSharedRegistry(ByVal aKey As String, ByVal aValue As String)
    Call SaveSetting("ZE", "Shared", aKey, aValue)
End Sub

Public Sub DeleteFromRegistry(ByVal aKey As String)
    Call DeleteSetting("ZE", "DataDirectAddin", aKey)
End Sub

Public Sub PutBooleanToRegistry(ByVal aKey As String, ByVal aValue As Boolean)
    Call PutToRegistry(aKey, IIf(aValue, "1", "0"))
End Sub

Public Function GetBooleanFromRegistry(ByVal aKey As String, Optional ByVal aDef As Boolean = False) As Boolean
    GetBooleanFromRegistry = (GetFromRegistry(aKey, IIf(aDef, "1", "0")) = "1")
End Function

Public Function HiWord(dw As Long) As Integer
    If dw And &H80000000 Then
        HiWord = (dw \ 65535) - 1
    Else
        HiWord = dw \ 65535
    End If
End Function

Public Function LoWord(dw As Long) As Integer
    If dw And &H8000& Then
        LoWord = &H8000 Or (dw And &H7FFF&)
    Else
        LoWord = dw And &HFFFF&
    End If
End Function

Public Function MakeLong(ByVal LoWord As Integer, ByVal HiWord As Integer) As Long
    MakeLong = ((HiWord * &H10000) + LoWord)
End Function

Public Property Get ApplicationDirectory() As String
 Dim tf As String
 Dim k As Long
 Dim cnt As Long
 
    'dest = Environ("ProgramFiles(X86)")
    tf = ThisWorkbook.FullName
    cnt = 0
    For k = Len(tf) To 1 Step -1
        If Mid(tf, k, 1) = "\" Then cnt = cnt + 1
        If cnt = 3 Then Exit For
    Next
    If k > 1 Then
        ApplicationDirectory = left(tf, k)
    End If
End Property

Public Function GetImagesDirectory() As String
    GetImagesDirectory = ApplicationDirectory + "images\"
End Function

Public Function GetHelpDirectory() As String
    GetHelpDirectory = ApplicationDirectory + "help\"
End Function

Public Function ValidateURL(ByVal url As String) As Boolean
    With CDDXLib.DefaultZEWSProxy(BSConsts.DDX_PID)
        ValidateURL = .ValidateURL(url)
    End With
End Function

Public Function NewGUID() As String
    NewGUID = CDDXLib.DefaultZEWSProxy(BSConsts.DDX_PID).NewGUID()
End Function

Private Sub SplitRGB(ByVal colorValue As Long, r As Long, g As Long, b As Long)
 Dim hexclr As String

    hexclr = right("000000" & Hex(colorValue), 6)
    r = CLng("&H" & right(hexclr, 2))
    g = CLng("&H" & Mid(hexclr, 3, 2))
    b = CLng("&H" & left(hexclr, 2))
End Sub

Public Function SelectColor(ByVal prsetColor As Long, resultColor As Long) As Boolean
 Dim old As Long
 Dim r As Long
 Dim g As Long
 Dim b As Long
 Const clrnum As Integer = 1

    Call SplitRGB(prsetColor, r, g, b)
    old = ActiveWorkbook.Colors(clrnum)
    SelectColor = Application.Dialogs(xlDialogEditColor).Show(clrnum, r, g, b)
    If SelectColor Then
        resultColor = ActiveWorkbook.Colors(clrnum)
        ActiveWorkbook.Colors(clrnum) = old
    End If
End Function

Public Sub MarkZEDoc(ByVal pid As String, Wb As Workbook)
    If Not CDDXApp.IsPX(pid) Then Exit Sub
    If Wb Is Nothing Then Exit Sub
    
    On Error GoTo OOPS
            
    With CSheet
        .DOCVersion(Wb) = CDDXApp.DDXVersion(Nothing)
        .DOCTimeZone(Wb) = CFingerprint.TimeZone
        Call .DOCSetProp(Wb, ZEDOC_VER_CREATOR_NAME, ThisWorkbook.FullName)
    End With
    
    With CCnvtHelp
        Call .SetMasks(Wb, .CompletionMasks)
    End With
    
    If Not CDDXHelper.NRVisibilityExists(Wb) Or CSheet.ZEDocID(Wb) = vbNullString Then
        CSheet.ZEDocID(Wb) = CDDXLib.DefaultZEWSProxy(DDX_PID).NewGUID()
        Call CDDXHelper.SetNRVisibility(DDX_PID, Wb, IIf(CEntityHelper.GetDocCreatorVer(Wb) <= 417, True, False))
        RaiseEvent OnEvent(Me, HELPER_EVENT_NR_VISIBILITY, 0, 0)
    End If
    
OOPS:
    If Err.Number <> 0 Then
        CDDXApp.StatusMessage = Err.Description
    End If
    On Error GoTo 0
    Exit Sub
End Sub

Public Sub MarkZESheet(ByVal pid As String, sheet As Worksheet, ByVal aType As String)
    If Not CDDXApp.IsPX(pid) Then Exit Sub
          
    CSheet.ZESheetType(sheet) = aType
    CSheet.ZESheetVersion(sheet) = CDDXApp.DDXVersion(Nothing)
    If Not sheet.Parent Is Nothing Then
        CSheet.DOCVersion(sheet.Parent) = CDDXApp.DDXVersion(Nothing)
    End If
End Sub

Private Sub SetLog()
    On Local Error GoTo OOPS
    
    With CDDXLib.DefaultZEWSProxy(BSConsts.DDX_PID)
        Call .SetLog(m_LogPath, m_LogLevel)
    End With
    
OOPS:
    On Local Error GoTo 0
    Exit Sub
End Sub

Private Sub Log(ByVal nLevel As Integer, ByVal Description As String, ByVal source As String)
' Dim LogLevel As Integer
    On Error GoTo OOPS

    If m_LogPath = vbNullString Then Exit Sub
'    LogLevel = cddxhelper.LogLevel
'    If Err.Number <> 0 Then LogLevel = 7
          
    Call SetLog
          
    With CDDXLib.DefaultZEWSProxy(BSConsts.DDX_PID)
        Call .Log(nLevel, Description, source)
    End With

OOPS:
    On Error GoTo 0
    Exit Sub
End Sub

Public Sub LogError(ByVal aDesciption As String, ByVal aSource As String, Optional ByVal aShow As Boolean = False)
    On Error GoTo OOPS
    
    With CDDXApp
        .DebugMessage = aDesciption
        .StatusMessage = removeMessageStack(BSConsts.DDX_PID, aDesciption)
        
        If aShow Then
            Call .DialogMessage(aDesciption, vbCritical)
        End If
    End With
    
    Call Log(&H1, aDesciption, aSource)
    
OOPS:

    On Error GoTo 0
    Exit Sub
End Sub

Public Sub LogMessage(ByVal aDesciption As String, ByVal aSource As String)
    Call Log(&H4, aDesciption, aSource)
End Sub

Public Function DeleteFile(ByVal filename As String) As Boolean
    On Error GoTo OOPS

    Kill filename
    DeleteFile = (Err.Number = 0)

OOPS:
          'ignore the error explicitly
    Err.Clear
End Function

Public Function FileThere(ByVal filename As String) As Boolean
    filename = Trim(filename)
    FileThere = (filename <> "" And Dir(filename) > "")
End Function

Public Function CompareRangeNames(ByVal aName As String, ByVal rn As String) As Boolean
          Dim p As Integer
       
10        On Error GoTo errorHandler

20        rn = UCase(rn)
30        aName = UCase(aName)
40        If aName = rn Then
50            CompareRangeNames = True
60        Else
70            p = InStr(aName, "!")
80            If p <= 0 Then Exit Function
90            If Mid(aName, p + 1) = rn Then
100               CompareRangeNames = True
110           End If
120       End If

130       On Error GoTo 0
140       Exit Function
errorHandler:
          Dim errorDescription As String, errorNumber As Long
150       errorDescription = "CDDXHelper.CompareRangeNames(), Line:" & str(Erl()) + " " + vbCrLf + Err.Description
160       errorNumber = Err.Number
          'your clean up codes here
170       Err.Raise errorNumber, , errorDescription
End Function

Public Function IsReferedToRange(nm As name) As Boolean
10        On Error GoTo errorHandler

20        If nm.RefersToRange Is Nothing Then
30        End If
40        IsReferedToRange = True

50        On Error GoTo 0
60        Exit Function
errorHandler:
          'ignore the error explicitly
70        Err.Clear
End Function

Public Function IsCurveSheet(sht As Worksheet) As Boolean
    IsCurveSheet = IIf(CDDXCurve.GetFVS(sht) > 0, True, False)
End Function

Public Function IsEntitySheet(sheet As Worksheet) As Boolean
10        On Error GoTo errorHandler

20        Select Case CSheet.ZESheetType(sheet)
              Case ZESHEET_ENTITY:
30                IsEntitySheet = True
40        End Select

50        On Error GoTo 0
60        Exit Function
errorHandler:
          Dim errorDescription As String, errorNumber As Long
70        errorDescription = "CDDXHelper.IsEntitySheet(), Line:" & str(Erl()) + " " + vbCrLf + Err.Description
80        errorNumber = Err.Number
          'your clean up codes here
90        Err.Raise errorNumber, , errorDescription
End Function

Public Function IsUploadSheet(sheet As Worksheet) As Boolean
10        On Error GoTo errorHandler

20        Select Case CSheet.ZESheetType(sheet)
              Case ZESHEET_FORECAST, ZESHEET_FUTURES, ZESHEET_SPOT:
30                IsUploadSheet = True
40        End Select

50        On Error GoTo 0
60        Exit Function
errorHandler:
          Dim errorDescription As String, errorNumber As Long
70        errorDescription = "CDDXHelper.IsUploadSheet(), Line:" & str(Erl()) + " " + vbCrLf + Err.Description
80        errorNumber = Err.Number
          'your clean up codes here
90        Err.Raise errorNumber, , errorDescription
End Function

Public Function IsForecastUploadSheet(sheet As Worksheet) As Boolean
10        On Error GoTo errorHandler

20        Select Case CSheet.ZESheetType(sheet)
              Case ZESHEET_FORECAST:
30                IsForecastUploadSheet = True
40        End Select

50        On Error GoTo 0
60        Exit Function
errorHandler:
          Dim errorDescription As String, errorNumber As Long
70        errorDescription = "CDDXHelper.IsForecastUploadSheet(), Line:" & str(Erl()) + " " + vbCrLf + Err.Description
80        errorNumber = Err.Number
          'your clean up codes here
90        Err.Raise errorNumber, , errorDescription
End Function

Public Function IsFuturesUploadSheet(sheet As Worksheet) As Boolean
10        On Error GoTo errorHandler

20        Select Case CSheet.ZESheetType(sheet)
              Case ZESHEET_FUTURES:
30                IsFuturesUploadSheet = True
40        End Select

50        On Error GoTo 0
60        Exit Function
errorHandler:
          Dim errorDescription As String, errorNumber As Long
70        errorDescription = "CDDXHelper.IsFuturesUploadSheet(), Line:" & str(Erl()) + " " + vbCrLf + Err.Description
80        errorNumber = Err.Number
          'your clean up codes here
90        Err.Raise errorNumber, , errorDescription
End Function

Public Function IsSpotUploadSheet(sheet As Worksheet) As Boolean
10        On Error GoTo errorHandler

20        Select Case CSheet.ZESheetType(sheet)
              Case ZESHEET_SPOT:
30                IsSpotUploadSheet = True
40        End Select

50        On Error GoTo 0
60        Exit Function
errorHandler:
          Dim errorDescription As String, errorNumber As Long
70        errorDescription = "CDDXHelper.IsSpotUploadSheet(), Line:" & str(Erl()) + " " + vbCrLf + Err.Description
80        errorNumber = Err.Number
          'your clean up codes here
90        Err.Raise errorNumber, , errorDescription
End Function

Public Function IsZESheet(sht As Worksheet) As Boolean
10        On Error GoTo errorHandler

20        IsZESheet = (CSheet.ZESheetType(sht) <> ZESHEET_NIL)

30        On Error GoTo 0
40        Exit Function
errorHandler:
          Dim errorDescription As String, errorNumber As Long
50        errorDescription = "CDDXHelper.IsZESheet(), Line:" & str(Erl()) + " " + vbCrLf + Err.Description
60        errorNumber = Err.Number
          'your clean up codes here
70        Err.Raise errorNumber, , errorDescription
End Function

Public Property Get ZEDocID(ByVal pid As String, Wb As Workbook) As String
10        On Error GoTo errorHandler

20        If Not CDDXApp.IsPX(pid) Then Exit Sub
30        ZEDocID = CSheet.DOCGetProp(Wb, ZEDOC_ID)

40        On Error GoTo 0
50        Exit Property
errorHandler:
          Dim errorDescription As String, errorNumber As Long
60        errorDescription = "CDDXHelper.ZEDocID(), Line:" & str(Erl()) + " " + vbCrLf + Err.Description
70        errorNumber = Err.Number
          'your clean up codes here
80        Err.Raise errorNumber, , errorDescription
End Property

Public Sub SetZEDocID(ByVal pid As String, Wb As Workbook, ByVal value As String)
10        On Error GoTo errorHandler

20        If Not CDDXApp.IsPX(pid) Then Exit Sub
30        CSheet.ZEDocID(Wb) = value

40        On Error GoTo 0
50        Exit Sub
errorHandler:
          Dim errorDescription As String, errorNumber As Long
60        errorDescription = "CDDXHelper.SetZEDocID(), Line:" & str(Erl()) + " " + vbCrLf + Err.Description
70        errorNumber = Err.Number
          'your clean up codes here
80        Err.Raise errorNumber, , errorDescription
End Sub

Public Property Get ZESheetID(ByVal pid As String, sheet As Worksheet) As String
10        On Error GoTo errorHandler

20        If Not CDDXApp.IsPX(pid) Then Exit Sub
30        ZESheetID = CSheet.WSGetProp(sheet, PROP_SHEET_ID)

40        On Error GoTo 0
50        Exit Property
errorHandler:
          Dim errorDescription As String, errorNumber As Long
60        errorDescription = "CDDXHelper.ZESheetID(), Line:" & str(Erl()) + " " + vbCrLf + Err.Description
70        errorNumber = Err.Number
          'your clean up codes here
80        Err.Raise errorNumber, , errorDescription
End Property

Public Property Get GetCurveParamFromXML(ByVal pid As String, ByVal aCurveInfo As String) As CCurveParams
10        On Error GoTo errorHandler
          Dim param As CCurveParams
          

20        If Not CDDXApp.IsPX(pid) Then Exit Property
30        Set param = New CCurveParams
40        param.FromXML (aCurveInfo)
50        Set GetCurveParamFromXML = param


60        On Error GoTo 0
70        Exit Property
errorHandler:
          Dim errorDescription As String, errorNumber As Long
80        errorDescription = "CDDXHelper.ZESheetID(), Line:" & str(Erl()) + " " + vbCrLf + Err.Description
90        errorNumber = Err.Number
          'your clean up codes here
100       Err.Raise errorNumber, , errorDescription
End Property



Public Sub SetZESheetID(ByVal pid As String, sht As Worksheet, ByVal value As String)
10        On Error GoTo errorHandler

20        If Not CDDXApp.IsPX(pid) Then Exit Sub
30        CSheet.ZESheetID(sht) = value

40        On Error GoTo 0
50        Exit Sub
errorHandler:
          Dim errorDescription As String, errorNumber As Long
60        errorDescription = "CDDXHelper.SetZESheetID(), Line:" & str(Erl()) + " " + vbCrLf + Err.Description
70        errorNumber = Err.Number
          'your clean up codes here
80        Err.Raise errorNumber, , errorDescription
End Sub

Public Function IsRangeOverFlowed(targetRange As range, rowsCount As Long, columnsCount As Long) As Boolean
          Dim isOverFlowed As Boolean
          Dim lastRow As Long
          Dim lastColumn As Long
10        On Error GoTo errorHandler

20        lastRow = targetRange.row + rowsCount
30        lastColumn = targetRange.column + columnsCount
40        If (CDDXApp.XLVersion >= 2007) Then
50            If lastColumn >= 16383 Then isOverFlowed = True
60            If lastRow >= 1048575 Then isOverFlowed = True
70        Else
80            If lastColumn >= 255 Then isOverFlowed = True
90            If lastRow >= 65535 Then isOverFlowed = True
100       End If
110       IsRangeOverFlowed = isOverFlowed

120       On Error GoTo 0
130       Exit Function
errorHandler:
          Dim errorDescription As String, errorNumber As Long
140       errorDescription = "CDDXHelper.IsRangeOverFlowed(), Line:" & str(Erl()) + " " + vbCrLf + Err.Description
150       errorNumber = Err.Number
160       Err.Clear
170       Err.Raise errorNumber, , errorDescription
End Function

Public Function GetExcelRange(targetRange As range, rowsCount As Long, columnsCount As Long) As range
          Dim lastRow As Long
          Dim lastColumn As Long
10        On Error GoTo errorHandler

20        lastRow = targetRange.row + rowsCount
30        lastColumn = targetRange.column + columnsCount
40        If (CDDXApp.XLVersion >= 2007) Then
50            If lastColumn >= 16383 Then columnsCount = 16383 - targetRange.column
60            If lastRow >= 1048575 Then rowsCount = 1048575 - targetRange.row
70        Else
80            If lastColumn >= 255 Then columnsCount = 255 - targetRange.column
90            If lastRow >= 65535 Then rowsCount = 65535 - targetRange.row
100       End If
110       Set GetExcelRange = targetRange.Resize(rowsCount, columnsCount)

120       On Error GoTo 0
130       Exit Function
errorHandler:
          Dim errorDescription As String, errorNumber As Long
140       errorDescription = "CDDXHelper.GetExcelRange(), Line:" & str(Erl()) + " " + vbCrLf + Err.Description
150       errorNumber = Err.Number
160       Err.Clear
170       Err.Raise errorNumber, , errorDescription
End Function

Public Function IsRangeIntersectWithOtherRanges(targetRange As range, Optional exceptionalRangeName As String = vbNullString) As String
10        On Error GoTo errorHandler

20        If targetRange Is Nothing Then Exit Function
          Dim result As String
          Dim excelName As name
30        For Each excelName In targetRange.Worksheet.Parent.Names
40            If (CDDXHelper.IsReferedToRange(excelName)) Then
50                If (StrComp(excelName.RefersToRange.Worksheet.name, targetRange.Worksheet.name, vbTextCompare) = 0) Then
60                    If (excelName.value <> "#REF!") Then
70                        If Not Application.Intersect(excelName.RefersToRange, targetRange) Is Nothing Then
80                            If (Len(exceptionalRangeName) > 0) Then
90                                If Not CDDXHelper.CompareRangeNames(excelName.name, exceptionalRangeName) Then
100                                   result = excelName.name
110                                   Exit For
120                               End If
130                           Else
140                               result = excelName.name
150                               Exit For
160                           End If
170                       End If
180                   End If
190               End If
200           End If
210       Next
          
          Dim tableObject As ListObject
220       For Each tableObject In targetRange.Worksheet.ListObjects
230           If Not Application.Intersect(targetRange, tableObject.range) Is Nothing Then
240               If (Len(exceptionalRangeName) > 0) Then
250                   If Not CDDXHelper.CompareRangeNames(tableObject.name, exceptionalRangeName) Then
260                       result = tableObject.name
270                       Exit For
280                   End If
290               Else
300                   result = tableObject.name
310                   Exit For
320               End If
330           End If
340       Next
350       IsRangeIntersectWithOtherRanges = result

360       On Error GoTo 0
370       Exit Function
errorHandler:
          Dim errorDescription As String, errorNumber As Long
380       errorDescription = "CDDXHelper.IsRangeIntersectWithOtherRanges(), Line:" & str(Erl()) + " " + vbCrLf + Err.Description
390       errorNumber = Err.Number
400       Err.Clear
410       Err.Raise errorNumber, , errorDescription
End Function

Public Sub AddFingerprint(ByVal pid As String, ByVal value As String)
    If m_fingerprint Is Nothing Then Exit Sub
    If Not CDDXApp.IsPX(pid) Then Exit Sub
    
    m_fingerprint.Add value
End Sub

Public Function GetAddinInfoCollection() As Collection
    On Error GoTo OOPS
          
    Set m_fingerprint = New Collection
    
    RaiseEvent OnEvent(Me, HELPER_EVENT_FINGERPINT, 0, 0)
    Set GetAddinInfoCollection = CFingerprint.GetAddinInfoCollection(m_fingerprint)
    
OOPS:
    On Error GoTo 0
    Exit Function
End Function

Public Function IsSelectionRange() As Boolean
10        On Error GoTo errorHandler

20        IsSelectionRange = False
30        If (Application.Selection Is Nothing) Then
40            CDDXApp.StatusMessage = "No destination specified."
50            Exit Function
60        End If
70        If (UCase(TypeName(Application.Selection)) <> "RANGE") Then
80            CDDXApp.StatusMessage = "The destination is not a range"
90            Exit Function
100       Else
110           IsSelectionRange = True
120       End If

130       On Error GoTo 0
140       Exit Function
errorHandler:
          Dim errorDescription As String, errorNumber As Long
150       errorDescription = "CDDXHelper.IsSelectionRange(), Line:" & str(Erl()) + " " + vbCrLf + Err.Description
160       errorNumber = Err.Number
170       Err.Clear
180       Err.Raise errorNumber, , errorDescription
End Function

'Public Sub SetClipboardText(ByVal pid As String, ByVal inputString As String)
'          Dim data As DataObject
'
'10        On Error GoTo errorHandler
'
'20        If Not CDDXApp.IsPX(pid) Then Exit Sub
'30        If (inputString = "") Then Exit Sub
'
'40        Set data = New DataObject
'50        With data
'60            .SetText inputString
'70            .PutInClipboard
'80        End With
'
'90        On Error GoTo 0
'100       Exit Sub
'errorHandler:
'          Dim errorDescription As String, errorNumber As Long
'110       errorDescription = "CDDXHelper.SetClipboardText(), Line:" & str(Erl()) + " " + vbCrLf + Err.Description
'120       errorNumber = Err.Number
'          'your clean up codes here
'130       Err.Raise errorNumber, , errorDescription
'End Sub
'
'Public Function GetClipboardText(ByVal pid As String) As String
'          Dim data As DataObject
'
'10        On Error GoTo errorHandler
'
'20        If Not CDDXApp.IsPX(pid) Then Exit Function
'
'30        Set data = New DataObject
'40        data.GetFromClipboard
'50        GetClipboardText = data.GetText
'60        F_PASTED = GetClipboardText
'
'70        On Error GoTo 0
'80        Exit Function
'errorHandler:
'          'ignore the error explicitly
'90        GetClipboardText = F_PASTED
'End Function

Public Function IsSharedMode(Wb As Workbook) As Boolean
    IsSharedMode = True
    If Not Wb Is Nothing Then
        IsSharedMode = Wb.MultiUserEditing
    End If
End Function

Public Function EscXPATHExpr(ByVal value As String) As String
 Dim token As String
 Dim tmp As String
 Dim ary() As String
 Dim k As Integer
 Dim c As String

20        If InStr(value, """") <= 0 Then
30            EscXPATHExpr = """" + value + """"
40            Exit Function
50        End If
60        If InStr(value, "'") <= 0 Then
70            EscXPATHExpr = "'" + value + "'"
80            Exit Function
90        End If
          
100       token = vbNullString
110       tmp = vbNullString
120       For k = 1 To Len(value)
130           c = Mid(value, k, 1)
140           If c = """" Then
150               If Len(tmp) > 0 Then tmp = tmp + vbCr
160               If token <> vbNullString Then tmp = tmp + token + vbCr
170               tmp = tmp + c
180               token = vbNullString
190           Else
200               token = token + c
210           End If
220       Next
230       If token <> vbNullString Then
240           If Len(tmp) > 0 Then tmp = tmp + vbCr
250           tmp = tmp + token
260       End If
          
270       ary = Split(tmp, vbCr)
              
280       token = "concat("
290       For k = LBound(ary) To UBound(ary)
300           If ary(k) = """" Then
310               token = token + "'" + ary(k) + "'"
320           Else
330               token = token + """" + ary(k) + """"
340           End If
350           token = token + IIf(k = UBound(ary), ")", ",")
360       Next
          
370       EscXPATHExpr = token
End Function

Private Function removeMessageStack(pid As String, Message As String) As String
 Dim messageLines() As String
 Dim i As Long
 Dim result As String
 
    If Not CDDXApp.IsPX(pid) Then Exit Function
    If (Len(Message) = 0) Then Exit Function
          
    messageLines = Split(Message, vbCrLf, , vbTextCompare)
          
    For i = UBound(messageLines) To 0 Step -1
        If (InStr(messageLines(i), ", Line:") > 0) Then
            Exit For
        End If
    Next
          
    For i = i + 1 To UBound(messageLines)
        result = messageLines(i) + vbCrLf
    Next
    removeMessageStack = IIf(Len(result) > 0, RTrim(result), Message)
End Function

Public Function ChangeLinks(Wb As Workbook, ByVal execOpts As Long) As Long
    ChangeLinks = CChangeLnkHelp.Execute(Wb, execOpts)
End Function

Public Function RunConversion(Wb As Workbook, resultMsg As String) As Boolean
    RunConversion = CCnvtHelp.Execute(Wb, resultMsg)
End Function

Private Sub Class_Initialize()
    LogLevel = 7
End Sub

Public Function GetZEMAPrecisionPref(ByVal pid As String) As Long
 Dim i As Long
 Dim up() As ZEWSProxy.LabelValue
       
    If Not CDDXApp.IsPX(pid) Then Exit Function
    
    GetZEMAPrecisionPref = 2
    up = CDDXLogin.UserPref(DDX_PID)

    For i = LBound(up) To UBound(up)
        If StrComp(up(i).label, "number_of_decimals", vbTextCompare) = 0 Then
            If IsNumeric(up(i).value) Then
                GetZEMAPrecisionPref = Val(up(i).value)
            End If
            Exit For
        End If
    Next i
End Function

Public Function GetMDString(ByVal aStr As String) As String
    GetMDString = CDDXLib.DefaultZEWSProxy(BSConsts.DDX_PID).GetMD5String(aStr)
End Function

Public Function IsSingleDateColumn(ByVal pid As String) As Boolean
 Dim i As Long
 Dim up() As ZEWSProxy.LabelValue
 
    If Not CDDXApp.IsPX(pid) Then Exit Function

    up = CDDXLogin.UserPref(DDX_PID)
'
    For i = LBound(up) To UBound(up)
        If LCase(up(i).label) Like "single_date_column" Then
            IsSingleDateColumn = (StrComp(up(i).value, "no") <> 0)
            Exit For
        End If
    Next
End Function

Public Sub CancelTask(ByVal pid As String, ByVal tsk As String)
    If Not CDDXApp.IsPX(pid) Then Exit Sub
    
    Call CTimer.CancelMonitor(tsk)
    Call CEntityHelper.RemoveRefreshIndicator(ActiveWorkbook, tsk)
End Sub

Public Function IsFlag(ByVal flags As Long, ByVal value As Long) As Boolean
    IsFlag = IIf((flags And value) = value, True, False)
End Function

Public Function NRVisibilityExists(Wb As Workbook) As Boolean
    NRVisibilityExists = IIf(CSheet.DOCGetProp(Wb, NR_HIDDEN) = vbNullString, False, True)
End Function

Public Function GetNRVisibility(Wb As Workbook) As Boolean
    GetNRVisibility = IIf(Int(Val(CSheet.DOCGetProp(Wb, NR_HIDDEN))) = 0, True, False)
End Function

Private Sub SetNamedRange(Wb As Workbook, ByVal rangeName As String, visibility As Boolean)
 Dim nm As name
 
    On Error GoTo OOPS
    
    Set nm = Wb.Names(rangeName)
    If Not nm Is Nothing Then
        nm.Visible = visibility
    End If
    
OOPS:
    Exit Sub
End Sub

Public Sub SetNRVisibility(pid As String, Wb As Workbook, visibility As Boolean)
 Dim sht As Worksheet
 Dim nrs As Variant
 Dim k As Long
 
    If Not CDDXApp.IsPX(pid) Then Exit Sub
    If Wb Is Nothing Then Exit Sub
    
    For Each sht In Wb.Worksheets
        If CDDXHelper.IsEntitySheet(sht) Then
            nrs = Trim(CSheet.WSGetProp(sht, PROP_SAVED_ENTITIES))
            If Len(nrs) > 0 Then
                nrs = CDDXLib.DefaultZEWSProxy(DDX_PID).GetNRNames(CStr(nrs), vbNullString)
                If Not CDDXUtility.IsArrayEmpty(nrs) Then
                    For k = LBound(nrs) To UBound(nrs)
                        Call SetNamedRange(Wb, nrs(k), visibility)
                    Next
                End If
            End If
        End If
    Next
    
    Call CSheet.DOCSetProp(Wb, NR_HIDDEN, IIf(visibility, "0", "1"))
End Sub

Public Function IsZEDoc(Wb As Workbook) As Boolean
    If Wb Is Nothing Then Exit Function
    
    IsZEDoc = IIf(CSheet.DOCGetProp(Wb, ZEDOC_VER_CREATOR) = vbNullString And CSheet.DOCGetProp(Wb, ZEDOC_VER) = vbNullString And CSheet.DOCGetProp(Wb, ZEDOC_ID) = vbNullString, False, True)
    If IsZEDoc Then
        IsZEDoc = IIf(Wb.Worksheets.count > 0, True, False)
    End If
End Function

Public Function ToHexStr(aNumber) As String
    ToHexStr = "&H" + Hex(aNumber) + "&"
End Function
Attribute VB_Name = "CDDXLib"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private m_default_instance As ZEWSProxy.ZEWSProxy

Public Property Get DefaultZEWSProxy(ByVal pid As String) As ZEWSProxy.ZEWSProxy
    If Not CDDXApp.IsPX(pid) Then Exit Function
          
    If m_default_instance Is Nothing Then
        Set m_default_instance = New ZEWSProxy.ZEWSProxy
        
        With m_default_instance
            'Stop
            Call .SetSignature(CDDXApp.Signature, CDDXApp.XLVersion, CStr(WndHandle()))
        End With
    End If
    Set DefaultZEWSProxy = m_default_instance
End Property

Public Function RetrieveUsers(ByVal pid As String, ByVal withProfiles As Boolean, ByVal orderByUserName As Boolean) As ZEWSProxy.userProfile()
  Dim user As ZEWSProxy.UserEntity
  
    If Not CDDXApp.IsPX(pid) Then Exit Function
    If CDDXLogin.SessionExpired() Then Exit Function

    Set user = New ZEWSProxy.UserEntity
    If CDDXUtility.SetupEntity(pid, user) Then
        With user
'            .currentUserName = CDDXLogin.CurrentUser
'            .userListOrder = IIf(orderByUserName, userListOrder.UserListOrder_ByUserLoginName, userListOrder.UserListOrder_ByLastFirstName)
            .userListOrder = IIf(orderByUserName, 1, 0)
            .withProfiles = withProfiles
            RetrieveUsers = .GetUsers()
        End With
    End If
End Function

Public Function RetrieveUserProfile(ByVal pid As String, ByVal username As String, ByVal isAnalytic As Boolean) As ZEWSProxy.userProfile
    On Error GoTo OOPS
    
    If Not CDDXApp.IsPX(pid) Then Exit Function
    If CDDXLogin.SessionExpired() Then Exit Function
    If (Len(Trim(username)) = 0) Then Exit Function
          
 Dim analyticTemplate As ZEWSProxy.AnalyticTemplateEntity
 
    Set analyticTemplate = New ZEWSProxy.AnalyticTemplateEntity
    If CDDXUtility.SetupEntity(pid, analyticTemplate) Then
        With analyticTemplate
            .LoginUserName = CDDXLogin.CurrentUser
            .OwnerUserName = username
            .isAnalytic = isAnalytic
            Call .SetUserProfileObject(Nothing)
            Set RetrieveUserProfile = .GetUserProfilesFromServer()
        End With
    End If
    
OOPS:
    If Err.Number <> 0 Then
        Call CDDXHelper.LogError(Err.Description, "RetrieveUserProfile")
    End If
    
    Exit Function
End Function

Public Function GetProfileGroups(ByVal pid As String, userProfile As ZEWSProxy.userProfile, ByVal isOptionAnalytics As Boolean) As ZEWSProxy.ProfileGroup()
    If Not CDDXApp.IsPX(pid) Then Exit Function
    If CDDXLogin.SessionExpired() Then Exit Function
    If userProfile Is Nothing Then Exit Function
          
 Dim groupEntity As ZEWSProxy.groupEntity
 
    Set groupEntity = New ZEWSProxy.groupEntity
    If (CDDXUtility.SetupEntity(pid, groupEntity)) Then
        With groupEntity
            Call .SetUserProfileObject(userProfile)
            .isAnalytic = isOptionAnalytics
            GetProfileGroups = .GetGroups()
        End With
    End If
End Function

Public Function GetAnalyticOptions(ByVal pid As String, ByVal username As String, ByVal userID As Long, ByVal group As String, ByVal Profile As String, _
                                ByRef newUserName As String, _
                                ByRef profileType As String, _
                                ByRef isDynamicDate As Boolean, _
                                ByRef dynaName As String, _
                                ByRef isConstDate As Boolean, _
                                ByRef shiftEffectiveDate As String, _
                                ByRef nullSuppression As Long, _
                                Optional templateName As String = vbNullString) As ZEWSProxy.IAnalyticOptions
 Dim msg As String

    If Not CDDXApp.IsPX(pid) Then Exit Function
    If CDDXLogin.SessionExpired() Then Exit Function

    Set GetAnalyticOptions = DefaultZEWSProxy(BSConsts.DDX_PID).RetrieveAnalyticOptions(CDDXLogin.sid, username, userID, group, Profile, templateName, shiftEffectiveDate, newUserName, profileType, isDynamicDate, dynaName, isConstDate, nullSuppression, msg)
    If msg <> vbNullString Then
        Err.Raise 432, , msg
        CDDXApp.StatusMessage = msg
    End If
End Function

Public Function GetProfileNames(ByVal pid As String, myProfiles As ZEWSProxy.userProfile, ByVal isOptionAnalytics As Boolean, ByVal groupName As String) As ZEWSProxy.profilenames()
    If Not CDDXApp.IsPX(pid) Then Exit Function
    If myProfiles Is Nothing Then Exit Function
    If CDDXLogin.SessionExpired() Then Exit Function
          
 Dim analyticTemplate As ZEWSProxy.AnalyticTemplateEntity
 
    Set analyticTemplate = New ZEWSProxy.AnalyticTemplateEntity
    If CDDXUtility.SetupEntity(pid, analyticTemplate) Then
        With analyticTemplate
            Call .SetUserProfileObject(myProfiles)
            .groupName = groupName
            .isAnalytic = isOptionAnalytics
            GetProfileNames = .GetProfileNames()
        End With
    End If
End Function

Public Function GetProfileDisplayNames(ByVal pid As String, myProfiles As ZEWSProxy.userProfile, ByVal isOptionAnalytics As Boolean, ByVal groupName As String) As String()
 Dim profilenames() As ZEWSProxy.profilenames
 Dim f As Integer
 Dim ary() As String

    If Not CDDXApp.IsPX(pid) Then Exit Function
          
    profilenames = GetProfileNames(pid, myProfiles, isOptionAnalytics, groupName)
    If IsNull(profilenames) Then Exit Function
        
    ReDim ary(UBound(profilenames))
        
    For f = LBound(profilenames) To UBound(profilenames)
        ary(f) = profilenames(f).profileDispName + Chr(&H2) + profilenames(f).profileDispPath
    Next
    GetProfileDisplayNames = ary
End Function

Public Function RetrieveDatasources(ByVal pid As String) As ZEWSProxy.LabelValue()
    If Not CDDXApp.IsPX(pid) Then Exit Function
    If CDDXLogin.SessionExpired Then Exit Function
          
 Dim DataSource As ZEWSProxy.DataSourceEntity
 
    Set DataSource = New ZEWSProxy.DataSourceEntity
    If CDDXUtility.SetupEntity(pid, DataSource) Then
        RetrieveDatasources = DataSource.LoadDataSources()
    End If
End Function

Public Function RetrieveReports(ByVal pid As String, ByVal DataSource As String) As ZEWSProxy.LabelValue()
    If Not CDDXApp.IsPX(pid) Then Exit Function
          
    If CDDXLogin.SessionExpired Then Exit Function
    RetrieveReports = DefaultZEWSProxy(BSConsts.DDX_PID).RetrieveReports(CDDXLogin.sid, DataSource)
End Function

Public Function RetrieveObservations(ByVal pid As String, ByVal DataSource As String, ByVal report As String) As ZEWSProxy.LabelValue()
    If Not CDDXApp.IsPX(pid) Then Exit Function
          
    If CDDXLogin.SessionExpired Then Exit Function
    RetrieveObservations = DefaultZEWSProxy(BSConsts.DDX_PID).RetrieveObservations(CDDXLogin.sid, DataSource, report)
End Function

Public Function RetrieveAttributes(ByVal pid As String, ByVal DataSource As String, ByVal report As String) As ZEWSProxy.ILabelValueResponseHolder
    If Not CDDXApp.IsPX(pid) Then Exit Function
          
    If CDDXLogin.SessionExpired Then Exit Function
    Set RetrieveAttributes = DefaultZEWSProxy(BSConsts.DDX_PID).RetrieveAttributes(CDDXLogin.sid, DataSource, report)
End Function

Public Function RetrieveAttributeValues(ByVal pid As String, ByVal DataSource As String, ByVal report As String, observations() As String, selAttributes() As ZEWSProxy.AttributeValuesHolder, ByVal aCurIndex As Integer) As ZEWSProxy.IReportInfoResponseHolder
    If Not CDDXApp.IsPX(pid) Then Exit Function
    If CDDXLogin.SessionExpired Then Exit Function
          
    Set RetrieveAttributeValues = DefaultZEWSProxy(BSConsts.DDX_PID).RetrieveAttributeValues(CDDXLogin.sid, DataSource, report, observations, selAttributes, aCurIndex)
End Function

Public Sub AbortZEWS(ByVal pid As String, ByVal aTaskID As String)
    If Not CDDXApp.IsPX(pid) Then Exit Sub
    If m_default_instance Is Nothing Then Exit Sub
    
    Call m_default_instance.abort(aTaskID)
End Sub

Public Function GetDDInfo(ByVal pid As String) As ZEWSProxy.LabelValue()
    If Not CDDXApp.IsPX(pid) Then Exit Function
          
    With DDXObjects.LoginObject
'       If Not .Loggedin Then Exit Function
'       If .sid = vbNullString Then Exit Function
        GetDDInfo = DefaultZEWSProxy(DDX_PID).GetDDInfo(.sid)
    End With
End Function

Public Function UpdatePassword(pid As String, request As String) As String
    If Not CDDXApp.IsPX(pid) Then Exit Function
    UpdatePassword = DefaultZEWSProxy(BSConsts.DDX_PID).UpdatePassword(request)
End Function
Attribute VB_Name = "CDDXLogin"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Const RECONNECT_INTERVAL_IN_MIN As Integer = 2
'
Private Const LF_FULLINFO As Long = &H1
Private Const LF_DOASYNC As Long = &H10
        
Public Event OnAfterLogin(sender As Object)
Public Event OnAfterLogout(sender As Object)
Public Event OnPasswordExpired(sender As Object)
Public Event OnQueryRecconection(sender As Object, ByRef needReconnection As Boolean)

Dim m_ws As ZEWSProxy.ZEWSProxy

Private Const PERMISSION_PROFILE As Long = &H1
Private Const PERMISSION_TABLE_ADMIN As Long = &H2
Private Const PERMISSION_TABLE_WRITE As Long = &H4
Private Const PERMISSION_CURVEPORTAL As Long = &H8
'Private Const PERMISSION_SMARTMART As Long = &H10

Private m_sid As String
Private m_user As String
Private m_pwd As String
Private m_client As String
Private m_url As String
Private m_samlIssuerUrl As String
Private m_samlVer As String
Private m_SPN As String
Private m_kaSettings As Long
'
Private m_permissions As Long
'
Private m_Expired As Boolean
Private m_message As String
Private m_connLimit As Integer
Private m_conn_timeout As Long 'in mins
Private m_read_timeout As Long 'in mins
Private m_last_token_check_time As Date

Private m_LargeData As Boolean
Private m_IgnoreInvalidCert As Boolean
'
Private m_in_autologin As Boolean

Public Property Get InAutoLogin() As Boolean
    InAutoLogin = m_in_autologin
End Property

Public Property Get CredentialToken(pid As String) As String
    If Not CDDXApp.IsPX(pid) Then Exit Function
    
    'CredentialToken = CDDXLib.DefaultZEWSProxy(pid).GenerateCredentialTokens(m_sid, m_user, m_pwd, m_client)
    CredentialToken = m_sid
End Property

Public Property Get HTTPConcurrentConnections() As Integer
    HTTPConcurrentConnections = m_connLimit
End Property

Public Property Get UserPref(ByVal pid As String) As ZEWSProxy.LabelValue()
    If Not CDDXApp.IsPX(pid) Then Exit Property
    UserPref = CDDXLib.DefaultZEWSProxy(DDX_PID).GetUserPreferences(m_sid)
End Property

Public Property Get Message() As String
    Message = m_message
End Property

Public Property Get PwdExpired() As Boolean
    PwdExpired = m_Expired
End Property

Private Function GetPermission(ByVal flag As Integer) As Boolean
    GetPermission = IIf((m_permissions And flag) <> 0, True, False)
End Function

Public Property Get PermTableAdmin() As Boolean
    PermTableAdmin = GetPermission(PERMISSION_TABLE_ADMIN)
End Property

Public Property Get PermTableWrite() As Boolean
    PermTableWrite = GetPermission(PERMISSION_TABLE_WRITE)
End Property

Public Property Get PermTableRead() As Boolean
    PermTableRead = GetPermission(PERMISSION_TABLE_WRITE)
End Property

Public Property Get PermCurvePortal() As Boolean
    PermCurvePortal = GetPermission(PERMISSION_CURVEPORTAL)
End Property

Public Property Get PermProfile() As Boolean
    PermProfile = GetPermission(PERMISSION_PROFILE)
End Property

Public Property Get PermSmartMart() As Boolean
'    PermSmartMart = GetPermission(PERMISSION_SMARTMART)
End Property

Public Property Get sid() As String
    If m_ws Is Nothing Then Exit Property
    
    m_sid = m_ws.GetSid()
    sid = m_sid
End Property

Public Property Get Loggedin() As Boolean
    Loggedin = (m_sid <> vbNullString)
End Property

Public Property Get CurrentUser() As String
    CurrentUser = m_user
End Property

Public Property Get EffectiveUser() As String
    EffectiveUser = IIf(Loggedin, IIf(m_user = vbNullString, Environ("username"), m_user), vbNullString)
End Property

Public Property Get CurrentPwd(ByVal pid As String) As String
    If Not CDDXApp.IsPX(pid) Then Exit Function
    CurrentPwd = m_pwd
End Property

Public Property Get CurrentUrl() As String
    CurrentUrl = m_url
End Property

Public Property Get samlIssuerUrl() As String
    samlIssuerUrl = m_samlIssuerUrl
End Property

Public Property Get CurrentClient() As String
    CurrentClient = m_client
End Property

Private Function Connect(ByVal aUrl As String, ByVal prevSID As String, ByVal aUser As String, ByVal aPwd As String, ByVal aClient As String, samlIssuerUrl As String, samlVer As String, SPN As String) As Boolean
 Dim cr As XlMousePointer

    cr = Application.Cursor
    Application.Cursor = xlWait
    m_sid = vbNullString
    m_Expired = False
          
    With m_ws
        If aUrl <> vbNullString Then
            Call .SetDD(aUrl, m_LargeData, m_IgnoreInvalidCert, m_connLimit, GetTimeouts(), m_kaSettings)
            Call .SetSTS(samlIssuerUrl, samlVer, SPN)
            Call OnGetAccessToken(.GetAccessTokenForAccount(prevSID, aUser, aPwd, aClient, LF_FULLINFO), True)
        Else
            m_message = "URL not specified"
            If m_sid <> vbNullString Then
                Call SingOut
            End If
            m_sid = vbNullString
        End If
    End With
    
    Connect = (m_sid <> vbNullString)
    Application.Cursor = cr
          
    If Connect Then
        m_last_token_check_time = Now
        RaiseEvent OnAfterLogin(Me)
    Else
        If PwdExpired Then
            RaiseEvent OnPasswordExpired(Me)
        Else
            RaiseEvent OnAfterLogout(Me)
        End If
    End If
End Function

Public Function Logout() As Boolean
    On Error GoTo OOPS

    If m_sid = vbNullString Then Exit Function
              
    Call SingOut
    CDDXApp.StatusMessage = "Logout succeeded."
          
    Logout = True

    m_sid = vbNullString
    m_user = vbNullString
    m_pwd = vbNullString
    m_client = vbNullString
    RaiseEvent OnAfterLogout(Me)

OOPS:
    On Error GoTo 0
    Exit Function
End Function

Public Property Get LargeData() As Boolean
    LargeData = m_LargeData
End Property

Public Property Let LargeData(value As Boolean)
    m_LargeData = value
End Property

Public Property Get IgnoreInvalidCert() As Boolean
    IgnoreInvalidCert = m_IgnoreInvalidCert
End Property

Public Property Let IgnoreInvalidCert(value As Boolean)
    m_IgnoreInvalidCert = value
End Property

Private Sub SingOut()
    Call m_ws.Logout(m_sid)
End Sub

Public Function Login(ByVal aUrl As String, ByVal prevSID As String, ByVal aHTTPConnLimit As Integer, ByVal aUser As String, ByVal aPwd As String, ByVal aClient As String, _
                      Optional connTimeout As Integer = 1, Optional readTimeout As Integer = 6, _
                      Optional samlIssuerUrl As String, Optional samlVer As String, Optional SPN As String, Optional kaSettings As Long) As Boolean
    If m_in_autologin Then Exit Function
    Login = SignIn(aUrl, prevSID, aHTTPConnLimit, aUser, aPwd, aClient, connTimeout, readTimeout, samlIssuerUrl, samlVer, SPN, kaSettings, True)
End Function

Public Sub AutoLogin(ByVal pid As String, ByVal aUrl As String, ByVal prevSID As String, ByVal aHTTPConnLimit As Integer, ByVal aUser As String, ByVal aPwd As String, ByVal aClient As String, Optional connTimeout As Integer = 1, Optional readTimeout As Integer = 6, Optional samlIssuerUrl As String, Optional samlVer As String, Optional SPN As String, Optional kaSettings As Long)
    If Not CDDXApp.IsPX(pid) Then Exit Sub
    If Loggedin Then Exit Sub
    If m_in_autologin Then Exit Sub
    
    m_in_autologin = True
    Call SignIn(aUrl, prevSID, aHTTPConnLimit, aUser, aPwd, aClient, connTimeout, readTimeout, samlIssuerUrl, samlVer, SPN, kaSettings, False)
End Sub

Private Function SignIn(ByVal aUrl As String, ByVal prevSID As String, ByVal aHTTPConnLimit As Integer, ByVal aUser As String, ByVal aPwd As String, ByVal aClient As String, _
                      ByVal connTimeout As Integer, ByVal readTimeout As Integer, ByVal samlIssuerUrl As String, ByVal samlVer As String, ByVal SPN As String, ByVal kaSettings As Long, _
                      ByVal isSync As Boolean) As Boolean
 Dim usr As String
 Dim pwd As String
 Dim client As String
 Dim url As String
 Dim originalSamlIssuerUrl As String
          
    If Loggedin And StrComp(aUrl, CurrentUrl, vbTextCompare) <> 0 Then
         Err.Raise vbObjectError + 100, , "A different URL is being logged in."
     End If
     
     On Error GoTo OOPS

     If Loggedin Then
         Call SingOut
     End If
     
     url = m_url
     usr = m_user
     pwd = m_pwd
     client = m_client
     originalSamlIssuerUrl = m_samlIssuerUrl
           
     m_url = aUrl
     m_user = aUser
     m_pwd = aPwd
     m_client = aClient
     m_connLimit = IIf(aHTTPConnLimit <= 0, 2, aHTTPConnLimit)
     m_conn_timeout = IIf(connTimeout <= 0, 1, connTimeout)
     m_read_timeout = IIf(readTimeout <= 0, 90, readTimeout)
     m_samlIssuerUrl = samlIssuerUrl
     m_samlVer = samlVer
     m_SPN = SPN
     m_kaSettings = kaSettings
     
     If isSync Then
         SignIn = Connect(aUrl, prevSID, aUser, aPwd, aClient, m_samlIssuerUrl, m_samlVer, m_SPN)
           
         If Not SignIn Then
             m_url = url
             m_user = usr
             m_pwd = pwd
             m_client = client
             m_samlIssuerUrl = originalSamlIssuerUrl
         End If
     Else
         With m_ws
             Call .SetDD(m_url, m_LargeData, m_IgnoreInvalidCert, m_connLimit, GetTimeouts(), m_kaSettings)
             Call .SetSTS(m_samlIssuerUrl, m_samlVer, m_SPN)
             Call .GetAccessTokenForAccount(vbNullString, m_user, m_pwd, m_client, LF_FULLINFO Or LF_DOASYNC)
             
         End With
     End If
        
OOPS:
    If Err.Number <> 0 Then
        m_in_autologin = False
        m_sid = vbNullString
        
        Err.Raise Err.Number, , Err.Description
    End If
    Exit Function
End Function

Private Function GetTimeouts() As Long
    GetTimeouts = &H100& * (m_conn_timeout And &HFF&) + (m_read_timeout And &HFF&)
End Function

Public Sub OnAutoLogin(pid As String, taskID As String)
    If Not CDDXApp.IsPX(pid) Then Exit Sub
 Dim file As Object
 Dim errmsg As String
 Dim tmp As String
    
    On Error GoTo OOPS
    
    m_in_autologin = False
    Set file = CDDXFile.OpenFile(taskID)
    
    errmsg = file.ReadText(-2)
    If Len(errmsg) = 0 Then
        m_sid = file.ReadText(-2)
        m_permissions = Val(file.ReadText(-2))
    End If
    
    Call CDDXFile.CloseFile(file, taskID, tmp)
    Set file = Nothing
    
    CDDXApp.StatusMessage = errmsg
    If Len(m_sid) > 0 And Len(errmsg) = 0 Then
        m_last_token_check_time = Now
        RaiseEvent OnAfterLogin(Me)
    Else
        RaiseEvent OnAfterLogout(Me)
    End If
    
OOPS:
    If Err.Number <> 0 Then
        CDDXApp.StatusMessage = Err.Description
    End If
    
    Exit Sub
End Sub

Private Sub AfterLogin(ByVal aIsAutoLogin As Boolean)
    CDDXApp.StatusMessage = vbNullString
          
    If Not aIsAutoLogin Then
        If Loggedin Then
            CDDXApp.StatusMessage = "Login Succeeded. Welcome to ZEMA Data Direct."
        End If
    End If
          
    If Not Loggedin Then
        CDDXApp.StatusMessage = "Failed to login to the DD server."
    End If
End Sub

Private Sub Class_Initialize()
    Set m_ws = CDDXLib.DefaultZEWSProxy(DDX_PID)
    m_LargeData = True
    m_IgnoreInvalidCert = False
End Sub

Private Sub OnGetAccessToken(lvs() As ZEWSProxy.LabelValue, ByVal FULLINFO As Boolean)
 Dim Permission() As String

    m_Expired = False
    
    If lvs(0).value <> vbNullString Then
        m_sid = vbNullString
        m_message = lvs(0).value
        
        m_Expired = (InStr(1, m_message, "expired", vbTextCompare) > 0 And InStr(1, m_message, "account", vbTextCompare) > 0)
        If m_Expired Then m_message = "Password Expired."
    Else
        m_sid = lvs(1).value
        m_pwd = m_sid
        
        If FULLINFO Then
            m_permissions = Val(lvs(2).value)
        End If
        
        m_message = "Login Succeeded."
    End If
    
    CDDXApp.StatusMessage = m_message
End Sub

Public Function SessionExpired() As Boolean
    SessionExpired = Not Loggedin
    
    If SessionExpired Then
        CDDXHelper.LastMessage = "Session Expired."
        CDDXApp.StatusMessage = CDDXHelper.LastMessage
    End If
End Function

Public Function GetLoginType(ByVal url As String, ByVal samlIssuerUrl As String, isSSO As Boolean, isSAML As Boolean) As String
    On Local Error GoTo OOPS
    
    If samlIssuerUrl = vbNullString Then
        GetLoginType = m_ws.GetEffectiveLoginType(url, samlIssuerUrl)
    Else
        GetLoginType = "saml"
    End If
    
    isSAML = IIf(StrComp(GetLoginType, "saml", vbTextCompare) = 0, True, False)
    isSSO = IIf(StrComp(GetLoginType, "ntlm", vbTextCompare) = 0 Or StrComp(GetLoginType, "negotiate", vbTextCompare) = 0, True, False)
    
OOPS:
    If Err.Number <> 0 Then
        Call CDDXHelper.LogError(Err.Description, "TestSSO")
    End If
    Exit Function
End Function

Public Sub SetSessionTimeout(tmVal As Long)
  'tmVal : 0 no timeout, -1: follow the setting in DD
    Call m_ws.SetSessionTimeout(tmVal)
End Sub
Attribute VB_Name = "CDDXProxy"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public Event OnEvent(sender As Object, ByVal taskID As String, wParam As Variant, lParam As Variant)

Public Sub RaiseProxyEvent(ByVal pid As String, ByVal taskID As String, ByVal flags As Long, ByVal tag As String)
 Dim obj As Object
 
    If Not CDDXApp.IsPX(pid) Then Exit Sub
    
    On Error GoTo OOPS
    RaiseEvent OnEvent(Me, taskID, flags, tag)
    
OOPS:
    On Error GoTo 0
    Exit Sub
End Sub
Attribute VB_Name = "CDDXScheduleParser"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private m_schedule As String
'
Private m_indMinute As Long
Private m_indHour As Long
Private m_indDay As Long
Private m_flags As Long
Private m_indMonth As Long
Private m_IsMorning As Boolean

Public Property Let TargetSchedule(schedule As String)
    m_schedule = schedule
    
    m_indMinute = ToInt(Mid(schedule, 7, 2))
    m_indHour = ToInt(Mid(schedule, 5, 2))
    m_indDay = ToInt(Mid(schedule, 3, 2))
    m_flags = ToInt(left(schedule, 1))
    
    If Not IsWeekly Then
        m_indMonth = ToInt(Mid(schedule, 2, 1))
    Else
        m_indMonth = -1
    End If

    m_IsMorning = IIf(m_indHour < 12, True, False)
    If Not m_IsMorning Then m_indHour = m_indHour - 12
    If m_indHour = 0 Then m_indHour = 12
End Property

Public Property Get TargetSchedule() As String
    TargetSchedule = m_schedule
End Property

Private Function ToInt(hexValue As String) As Long
    ToInt = Int(Val("&H" & hexValue))
End Function

Public Property Get IsFull() As Boolean
    IsFull = IIf((m_flags And 1) = 0, True, False)
End Property

Public Property Get IsMorning() As Boolean
    IsMorning = m_IsMorning
End Property

Public Property Get HourNumber() As Long
    HourNumber = m_indHour
End Property

Public Property Get MinuteNumber() As Long
    MinuteNumber = m_indMinute
End Property

Public Property Get MonthNumber() As Long
    MonthNumber = m_indMonth
End Property

Public Property Get MonthDate() As Long
    MonthDate = IIf(m_indMonth >= 0, m_indDay, -1)
End Property

Public Property Get IsWeekly() As Boolean
    IsWeekly = IIf((m_flags And 2 ^ 2) = 0, True, False)
End Property

Public Property Get HasMonday() As Boolean
    HasMonday = IsWeekly And (IIf((m_indDay And &H2) <> 0, True, False))
End Property

Public Property Get HasTuesday() As Boolean
    HasTuesday = IsWeekly And (IIf((m_indDay And &H4) <> 0, True, False))
End Property

Public Property Get HasWednesday() As Boolean
    HasWednesday = IsWeekly And (IIf((m_indDay And &H8) <> 0, True, False))
End Property

Public Property Get HasThursday() As Boolean
    HasThursday = IsWeekly And (IIf((m_indDay And &H10) <> 0, True, False))
End Property

Public Property Get HasFriday() As Boolean
    HasFriday = IsWeekly And (IIf((m_indDay And &H20) <> 0, True, False))
End Property

Public Property Get HasSaturday() As Boolean
    HasSaturday = IsWeekly And (IIf((m_indDay And &H40) <> 0, True, False))
End Property

Public Property Get HasSunday() As Boolean
    HasSunday = IsWeekly And (IIf((m_indDay And &H80) <> 0, True, False))
End Property


Attribute VB_Name = "CDDXUpload"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public Event OnBeforeUploadData(sender As Object, sht As Worksheet, ByVal isSuccess As Boolean, ByVal msg As String)
Public Event OnAfterUploadData(sender As Object, sht As Worksheet, ByVal isSuccess As Boolean, ByVal msg As String)
Public Event OnAfterUploadMetadata(sender As Object, sht As Worksheet, ByVal success As Boolean, ByVal msg As String)

Private Const STATUS_TAG_NAME           As String = "DDXUPStatus"

Private m_tasks                         As New Collection

Private m_ws                            As ZEWSProxy.ZEWSProxy
Attribute m_ws.VB_VarHelpID = -1
Private m_sheet                         As Worksheet

Private m_sheet_type                    As String
Private m_writedata_result              As String

Private m_silient                       As Boolean
Private m_sync                          As Boolean

'Private m_upload_tables() As String


Public Property Set sheet(value As Excel.Worksheet)

10      On Error GoTo OOPS

20      Set m_sheet = value

30      If m_sheet Is Nothing Then Set m_sheet = ActiveSheet

40      Call CDDXUpload.UnProtectSheet(m_sheet)

50      m_sheet_type = CSheet.ZESheetType(m_sheet)

60      On Error GoTo 0
70      Exit Property
OOPS:
        Dim errDesc         As String, errNum       As Long
80      errDesc = "CDDXUpload.sheet(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
90      errNum = Err.Number
        'your clean up codes here
100     Call Err.Raise(errNum, Err.source, errDesc)

End Property

Public Property Let Quiet(ByVal value As Boolean)

10      On Error GoTo OOPS

20      m_silient = value

30      On Error GoTo 0
40      Exit Property
OOPS:
        Dim errDesc         As String, errNum       As Long
50      errDesc = "CDDXUpload.Quiet(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
60      errNum = Err.Number
        'your clean up codes here
70      Call Err.Raise(errNum, Err.source, errDesc)

End Property

Public Property Get Quiet() As Boolean

10      On Error GoTo OOPS

20      Quiet = m_silient

30      On Error GoTo 0
40      Exit Property
OOPS:
        Dim errDesc         As String, errNum       As Long
50      errDesc = "CDDXUpload.Quiet(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
60      errNum = Err.Number
        'your clean up codes here
70      Call Err.Raise(errNum, Err.source, errDesc)

End Property

Public Property Let Sync(ByVal value As Boolean)

10      On Error GoTo OOPS

20      m_sync = value

30      On Error GoTo 0
40      Exit Property
OOPS:
        Dim errDesc         As String, errNum       As Long
50      errDesc = "CDDXUpload.Sync(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
60      errNum = Err.Number
        'your clean up codes here
70      Call Err.Raise(errNum, Err.source, errDesc)

End Property

Public Property Get Sync() As Boolean

10      On Error GoTo OOPS

20      Sync = m_sync

30      On Error GoTo 0
40      Exit Property
OOPS:
        Dim errDesc         As String, errNum       As Long
50      errDesc = "CDDXUpload.Sync(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
60      errNum = Err.Number
        'your clean up codes here
70      Call Err.Raise(errNum, Err.source, errDesc)

End Property

Public Sub Upload()

10      On Error GoTo OOPS

        If Not CDDXLogin.Loggedin Then Exit Sub

        Dim id                          As String

20      If Not Validate() Then

30          RaiseEvent OnBeforeUploadData(Me, m_sheet, False, "Data error")

40          Exit Sub
50      End If

60      If Not m_silient Then

70          id = GetSheetID(m_sheet)

80          If (IsInProgress(id)) Then

90              RaiseEvent OnBeforeUploadData(Me, m_sheet, False, "Uploading in progress...")

100             Exit Sub
110         End If

120         If (CDDXApp.DialogMessage("Are you sure to write data for " & m_sheet.name & "?" & vbCrLf & "[" & V2Table(m_sheet) & " ]", vbOKCancel Or vbQuestion) = vbCancel) Then Exit Sub
130     End If

140     If CDDXLogin.SessionExpired() Then
150         RaiseEvent OnBeforeUploadData(Me, m_sheet, False, "Session Expired")

160         Exit Sub
170     End If

180     CDDXApp.StatusMessage = vbNullString

        Call V2Status(m_sheet, "Uploading ...")

190     Call SaveData

200     UploadData m_sheet, V2Table(m_sheet), IIf(m_sheet_type = ZESHEET_FUTURES, "Future", "N/A"), V2Date(m_sheet), _
                IIf(insertOnly(), UPLOAD_INSERT_ONLY, 0) Or IIf(IsLoadMetaData(m_sheet), UPLOAD_WAIT_3SEC, 0), _
                LastDataRow - FirstDataRow + 1, V2LastColumn(m_sheet) - getColumnFirstIndex() + 1

        If Not Sync Then
            RaiseEvent OnBeforeUploadData(Me, m_sheet, True, vbNullString)
        End If

230     On Error GoTo 0
240     Exit Sub
OOPS:
        Dim errDesc         As String, errNum      As Long
250     errDesc = "CDDXUpload.Upload(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
260     errNum = Err.Number
        'your clean up codes here
270     Call Err.Raise(errNum, Err.source, errDesc)

End Sub

Public Function NewSpotSheet() As Excel.Worksheet

10      On Error GoTo OOPS

20      Set NewSpotSheet = NewSheet(ZESHEET_SPOT)

30      On Error GoTo 0
40      Exit Function
OOPS:
        Dim errDesc         As String, errNum       As Long
50      errDesc = "CDDXUpload.NewSpotSheet(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
60      errNum = Err.Number
        'your clean up codes here
70      Call Err.Raise(errNum, Err.source, errDesc)

End Function

Public Function NewForecastSheet() As Excel.Worksheet

10      On Error GoTo OOPS

20      Set NewForecastSheet = NewSheet(ZESHEET_FORECAST)

30      On Error GoTo 0
40      Exit Function
OOPS:
        Dim errDesc         As String, errNum       As Long
50      errDesc = "CDDXUpload.NewForecastSheet(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
60      errNum = Err.Number
        'your clean up codes here
70      Call Err.Raise(errNum, Err.source, errDesc)

End Function

Public Function NewFuturesSheet() As Excel.Worksheet

10      On Error GoTo OOPS

20      Set NewFuturesSheet = NewSheet(ZESHEET_FUTURES)

30      On Error GoTo 0
40      Exit Function
OOPS:
        Dim errDesc         As String, errNum       As Long
50      errDesc = "CDDXUpload.NewFuturesSheet(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
60      errNum = Err.Number
        'your clean up codes here
70      Call Err.Raise(errNum, Err.source, errDesc)

End Function

Private Function NewSheet(ByVal aTypeID As String) As Excel.Worksheet
10
        On Error GoTo OOPS

        Dim obj                         As New CUploadSheetCreator

20      Set NewSheet = obj.NewUploadSheet(aTypeID)

30      On Error GoTo 0
40      Exit Function
OOPS:
        Dim errDesc         As String, errNum       As Long
50      errDesc = "CDDXUpload.NewSheet(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
60      errNum = Err.Number
        'your clean up codes here
70      Call Err.Raise(errNum, Err.source, errDesc)

End Function

Private Function CheckTable() As Boolean

        On Error GoTo OOPS

        Dim r                           As Excel.range
        Dim m                           As String  '= "Target table not found."
        Dim actfrow                     As Long
        Dim lrow                        As Long
        Dim minFirstRow                 As Long

        minFirstRow = IIf(m_sheet_type = ZESHEET_FUTURES, 19, 21)
10
20      Call ResetColorsOnUploadSheet

30      m = vbNullString
40      lrow = V2LastRow(m_sheet)

50      actfrow = V2FirstRow(m_sheet)

60      If actfrow < minFirstRow Or (actfrow > lrow And lrow >= minFirstRow) Then

70          m = "Invalid first row"
80          Set r = V2ValueCell(m_sheet, "*First Row of Data:*")

90      ElseIf lastRow() < lrow Or lrow < actfrow Then
100         m = "Invalid last row"
110         Set r = V2ValueCell(m_sheet, "*Last Row of Data:*")

120     Else
130         If Not IsTableNameOkay(V2Table(m_sheet), m) Then
140             Set r = V2ValueCell(m_sheet, "*Target Table:*")
150         End If
160     End If

170     CheckTable = (m = vbNullString)

180     If Not CheckTable Then

190         If Not r Is Nothing Then

200             Call SetCellError(m_sheet, r.row, r.column)
210             Call SetErrCell(r.row, r.column)
220         End If

230         Call ShowErr(m)

240         Exit Function
250     End If

260     CheckTable = CheckAttributes()

261     If Not CheckTable Then Exit Function

262     CheckTable = CheckDuplicateAttributes()

270     If Not CheckTable Then Exit Function

280     On Error GoTo 0
290     Exit Function
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.CheckTable(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        'your clean up codes here
        Call Err.Raise(errNum, Err.source, errDesc)

End Function

Private Function ValidateMetaData(Optional ignoreCheckLoadMetaData As Boolean = False) As Boolean

10      On Error GoTo OOPS

20      If ignoreCheckLoadMetaData = False Then

30          If Trim$(V2LoadMetadata(m_sheet)) <> "Yes" Then

40              ValidateMetaData = True

50              Exit Function
60          End If
70      End If

80      If Trim$(V2Namespace(m_sheet)) = vbNullString Then

90          Call ShowErr("Invalid Namespace")

100         Exit Function
110     End If

120     If Trim$(V2Report(m_sheet)) = vbNullString Then

130         Call ShowErr("Invalid Database Object")

140         Exit Function
150     End If

160     ValidateMetaData = True

170     On Error GoTo 0
180     Exit Function
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.ValidateMetaData(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        'your clean up codes here
        Call Err.Raise(errNum, Err.source, errDesc)

End Function

Public Function Validate() As Boolean

10      On Error GoTo OOPS

        Dim b                           As Boolean

20      If GetUploadSheetVersion(m_sheet) <> 2 Then

30          Call ShowErr("Upload worksheet V1 is not supported any more.")

40          Exit Function
50      End If

60      If Not validateV2CellTitle() Then Exit Function
70      If Not CheckUploadDates() Then Exit Function
80      If Not CheckTable() Then Exit Function
          
90      If Not effectiveDateValid() Then Exit Function
100     If Not ValidateV2() Then Exit Function

110     If Not ValidateMetaData(b) Then Exit Function
120     If Not ValidateFuturesStartDate() Then Exit Function

130     Validate = True

140     On Error GoTo 0
150     Exit Function
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.Validate(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        'your clean up codes here
        Call Err.Raise(errNum, Err.source, errDesc)

End Function

Private Function ValidateFuturesStartDate() As Boolean

10      On Error GoTo OOPS

20      If m_sheet Is Nothing Then Exit Function

        Dim contractDate                As Date
        Dim i                           As Long
        Dim contractType                As String
        Dim errCells                    As String
        Dim isThereError                As Boolean

30      If CDDXHelper.IsFuturesUploadSheet(m_sheet) Then

40          errCells = CSheet.WSGetProp(m_sheet, BSConsts.UPLD_ERR_ADDR)

50          For i = FirstDataRow To LastDataRow

60              contractType = m_sheet.Cells(i, 3).value
70              contractDate = m_sheet.Cells(i, 4).value

80              If Len(contractType) > 0 And year(contractDate) > 1900 Then

90                  Select Case contractType
                    Case "Week (Mon-Sun)"
100                     If WeekDay(contractDate) <> VbDayOfWeek.vbMonday Then

110                         errCells = errCells & IIf(errCells = vbNullString, vbNullString, ",") & ErrCellAddress(i, 4)
120                         m_sheet.Cells(i, 4).Interior.ColorIndex = 22
130                         isThereError = True
140                     End If

150                 Case "Week (Sun-Sat)"
160                     If WeekDay(contractDate) <> VbDayOfWeek.vbSunday Then

170                         errCells = errCells & IIf(errCells = vbNullString, vbNullString, ",") & ErrCellAddress(i, 4)
180                         m_sheet.Cells(i, 4).Interior.ColorIndex = 22
190                         isThereError = True
200                     End If

210                 Case "Weekday"
220                     If WeekDay(contractDate) = VbDayOfWeek.vbSaturday Or WeekDay(contractDate) = VbDayOfWeek.vbSunday Then

230                         errCells = errCells & IIf(errCells = vbNullString, vbNullString, ",") & ErrCellAddress(i, 4)
240                         m_sheet.Cells(i, 4).Interior.ColorIndex = 22
250                         isThereError = True
260                     End If

270                 Case "Weekend"
280                     If WeekDay(contractDate) <> VbDayOfWeek.vbSaturday Then

290                         errCells = errCells & IIf(errCells = vbNullString, vbNullString, ",") & ErrCellAddress(i, 4)
300                         m_sheet.Cells(i, 4).Interior.ColorIndex = 22
310                         isThereError = True
320                     End If
330                 End Select
340             End If
350         Next i

360         Call SetErrCell2(m_sheet, errCells)
370     End If

380     If isThereError Then
390           Call ShowErr("The start date is invalid for the contract type")
400     End If

410     ValidateFuturesStartDate = Not isThereError

420     On Error GoTo 0
430     Exit Function
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.ValidateFuturesStartDate(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        'your clean up codes here
        Call Err.Raise(errNum, Err.source, errDesc)

End Function

Private Function ValidateV2() As Boolean

10      On Error GoTo OOPS

        Dim d                           As Date
        Dim data                        As Long
        Dim tmp                         As String

20      ValidateV2 = False

30      tmp = Trim$(V2Date(m_sheet))

40      If tmp <> "" Then

50          d = CDDXDates.CDateSafe(tmp)

60          If Err.Number <> 0 Then
70              Call ShowErr("Invalid Effective Date")

80              Exit Function
90          End If
100     End If

110     data = CLng(Trim$(V2FirstRow(m_sheet))) 'CLng(sheet.Cells(5, 10).value) 'DDX-192

120     If 0 = data Then Call Err.Raise(12345, "FirstDataRow", "Invalid First Data Row Value")

130     If Not IsNumeric(data) Then
140         Call ShowErr("Invalid First DataRow")

150         Exit Function
160     End If

170     data = CLng(Trim$(V2LastRow(m_sheet))) 'CLng(sheet.Cells(6, 10).value) 'DDX-192

180     If Not IsNumeric(data) Then
190         Call ShowErr("Invalid Last Data row value")

200         Exit Function
210     End If

220     If "" = Trim$(V2Table(m_sheet)) Then ' Trim(sheet.Cells(7, 8).value) Then 'DDX-192
230         Call ShowErr("Invalid Table Name Field")

240         Exit Function
250     End If

260     ValidateV2 = True

270     On Error GoTo 0
280     Exit Function
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.ValidateV2(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        'your clean up codes here
        Call Err.Raise(errNum, Err.source, errDesc)

End Function

Private Function IsTableNameOkay(ByVal aTableName As String, ByRef errorMessage As String) As Boolean

10      On Error GoTo OOPS

        Dim i                           As Long
        Dim inputChar                   As String

20      If Len(aTableName) = 0 Then
30          errorMessage = "The input is empty."

40          Exit Function
50      End If

60      inputChar = Mid$(aTableName, 1, 1)

70      If inputChar Like "[a-zA-Z_]" Then
            ' inputchar ok
80      Else
90          errorMessage = "The input should start with character or underscore."

100         Exit Function
110     End If
120
130     ' alphanumeric characters, underscores and dots only please
140     IsTableNameOkay = Not aTableName Like "*[!a-zA-Z0-9._]*"
150
160     ' set error message output variable and exit
170     If Not IsTableNameOkay Then
180
190         errorMessage = "The new name should contains only characters, numerical digits, dot and underscore"
200     End If
210
        On Error GoTo 0
220     Exit Function
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.IsTableNameOkay(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        'your clean up codes here
        Call Err.Raise(errNum, Err.source, errDesc)

End Function

Private Sub SetCellError(sheet As Excel.Worksheet, ByVal rowNo, ByVal cellNo)
10
        On Error GoTo OOPS

        Dim dr                          As Excel.range
        Dim cm                          As Excel.Comment
20
        Set dr = sheet.Cells(rowNo, cellNo)

30      dr.Interior.ColorIndex = 22

40      Set cm = dr.AddComment
50      cm.text "This attribute must be filled for upload!"

60      On Error GoTo 0
70      Exit Sub
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.SetCellError(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        'your clean up codes here
        Call Err.Raise(errNum, Err.source, errDesc)

End Sub

Private Function IsRowEmpty(nRow As Long, nCol As Long) As Boolean

        On Error GoTo OOPS

        Dim i                           As Long
10
20      IsRowEmpty = False

30      For i = getColumnFirstIndex() To nCol
40          If "" <> Trim$(m_sheet.Cells(nRow, i).value) Then Exit Function
50      Next i

60      IsRowEmpty = True

70      On Error GoTo 0
80      Exit Function
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.IsRowEmpty(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        'your clean up codes here
        Call Err.Raise(errNum, Err.source, errDesc)

End Function

'Private Function IsAttributeRowEmpty(row As Integer, col As Integer) As Boolean
'          Dim i As Integer, startInd As Integer
'10        On Error GoTo errorHandler
'
'20        IsAttributeRowEmpty = False
'
'30        startInd = 4
'
'40        For i = startInd To col + startInd
'50            If "" <> Trim(m_sheet.Cells(row, i).value) Then
'60                IsAttributeRowEmpty = False
'70                Exit Function
'80            End If
'90        Next i
'100       IsAttributeRowEmpty = True
'
'110       On Error GoTo 0
'120       Exit Function
'errorHandler:
'          Dim errorDescription As String, errorNumber As Long
'130       errorDescription = "CDDXUpload.IsAttributeRowEmpty(), Line:" & Str(Erl()) + " " + vbCrLf + Err.Description
'140       errorNumber = Err.Number
'          'your clean up codes here
'150       Err.Raise errorNumber, , errorDescription
'End Function

Private Property Get insertOnly() As Boolean
10
        On Error GoTo OOPS

        Dim insertOnlyRange             As Excel.range

20      Set insertOnlyRange = V2ValueCell(m_sheet, "*Insert Records Only:*")

30      If Not insertOnlyRange Is Nothing Then

40          If (insertOnlyRange.value = "No") Then
50              insertOnly = False

60              Exit Property
70          End If
80      End If
90
        insertOnly = True

100     On Error GoTo 0
110     Exit Property
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.insertOnly(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        'your clean up codes here
        Call Err.Raise(errNum, Err.source, errDesc)

End Property

Private Property Get FirstDataRow() As Long

10      On Error GoTo OOPS

20      FirstDataRow = V2FirstRow(m_sheet) 'CLng(sheet.Cells(5, 10).value)'DDX-192

30      On Error GoTo 0
40      Exit Property
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.FirstDataRow(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        'your clean up codes here
        Call Err.Raise(errNum, Err.source, errDesc)

End Property

Private Property Get LastDataRow() As Long

10      On Error GoTo OOPS

20      LastDataRow = V2LastRow(m_sheet) 'CLng(sheet.Cells(6, 10).value)'DDX-192

30      On Error GoTo 0
40      Exit Property
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.LastDataRow(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        'your clean up codes here
        Call Err.Raise(errNum, Err.source, errDesc)

End Property

Private Function StartingDateRowFS(ByVal defRow As Long) As Long

        Dim c                           As Variant
 
        For Each c In [A18:E21]

            If c.value Like "Start Date" Then

                StartingDateRowFS = c.row + 1

                Exit Function
            End If
        Next c

        StartingDateRowFS = defRow

End Function

Private Function CheckUploadDates() As Boolean
10
        On Error GoTo OOPS

        Dim i                           As Long
        Dim cols                        As Long
        Dim c                           As Long
        Dim startRow                    As Long '= 21
        Dim errCells                    As String

20      c = IIf(IsFuturesSheet(m_sheet), 4, 3)

        If IsFuturesSheet(m_sheet) Then

            startRow = StartingDateRowFS(19)
        Else
            startRow = 21
        End If

30      For i = 65300 To startRow Step -1

40          If m_sheet.Cells(i, c).value <> vbNullString Then

50              Exit For
60          End If
70      Next i

80      If i < startRow Then
90          CheckUploadDates = True

100         Exit Function
110     End If

120     Do
130         If i < startRow Then Exit Do

140         If m_sheet.Cells(i, c).value = vbNullString Then

150             errCells = IIf(Len(errCells) = 0, vbNullString, ",") & ErrCellAddress(i, c)

160             m_sheet.Cells(i, c).Interior.ColorIndex = 22
170         End If
180         i = i - 1
190     Loop

200     If errCells <> vbNullString Then

210         Call SetErrCell2(m_sheet, errCells)
220         Call ShowErr("Date values can not be empty.")
230     Else
240         CheckUploadDates = True
250     End If

260     On Error GoTo 0
270     Exit Function
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.CheckUploadDates(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        'your clean up codes here
        Call Err.Raise(errNum, Err.source, errDesc)

End Function

Private Property Get lastRow() As Long

        On Error GoTo OOPS

        Dim i                           As Long
        Dim cols                        As Long
        Dim c                           As Long


20      c = IIf(m_sheet_type = ZESHEET_FUTURES, 4, 3)
30      cols = V2LastColumn(m_sheet) + 1

40      lastRow = -1

50      For i = FirstDataRow() To 65300

60          If IsRowEmpty(i, cols) Then

70              If m_sheet.Cells(i, c).value = vbNullString Then

80                  lastRow = i - 1

90                  Exit Property
100             End If
110         Else
120             lastRow = -1
130         End If
140     Next i

150     lastRow = -1

160     On Error GoTo 0
170     Exit Property
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.lastRow(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        'your clean up codes here
        Call Err.Raise(errNum, Err.source, errDesc)

End Property

Private Function CheckForecast() As String
10
        On Error GoTo OOPS

        Dim r                           As Excel.range
        Dim cm                          As Excel.Comment
        Dim isv2                        As Boolean
        Dim isValidDate                 As Boolean
        Dim tmpDt                       As String
        Dim dFR                         As Date

20      CheckForecast = vbNullString
30      isValidDate = False

40      If Not IsNull(V2ValueCell(m_sheet, "* Date:*", False)) Then

50          Set r = V2ValueCell(m_sheet, "* Date:*", False)  'sheet.Cells(5, 6) 'DDX-192
60          tmpDt = Trim(r(1, IIf(m_sheet_type = ZESHEET_FUTURES, 2, 1)).value) 'Trim(sheet.Cells(5, 6).value) 'DDX-192
70      Else
80          Exit Function
90      End If

100     isv2 = True

110     Set cm = r.Comment

120     If "" = tmpDt Then

130         If cm Is Nothing Then Set cm = r.AddComment

140         Call cm.text("Effective Date is not a valid date.")

150         CheckForecast = "Effective Date is not a valid date." & vbCrLf

160         r.Interior.color = RGB(250, 150, 150)

170     ElseIf CDDXDates.IsDateGood(tmpDt) Then

180         dFR = CDDXDates.CDateSafe(tmpDt)
190         isValidDate = True
200     Else
210         If cm Is Nothing Then Set cm = r.AddComment

220         Call cm.text("Effective Date is not a valid date.")
            ' DoEvents
230         If Not cm.Visible Then cm.Visible = True

240         CheckForecast = "Effective Date is not a valid date." & vbCrLf

250         r.Interior.color = RGB(250, 150, 150)
260     End If

270     If (isValidDate) Then

280         If (m_sheet_type <> ZESHEET_FORECAST) And (month(dFR) <> month(Now) Or day(dFR) <> day(Now) Or year(dFR) <> year(Now)) Then

290             If cm Is Nothing Then Set cm = r.AddComment

300             Call cm.text("Effective Date is not current date")
                ' DoEvents
310             If Not cm.Visible Then cm.Visible = True

320             CheckForecast = "Effective Date is not current date" & vbCrLf
330             r.Interior.color = RGB(250, 150, 150)

340             Call SetErrCell(r.row, r.column)
350         End If
360     End If
        ' DoEvents

370     On Error GoTo 0
380     Exit Function
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.CheckForecast(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        'your clean up codes here
        Call Err.Raise(errNum, Err.source, errDesc)

End Function

Private Function ErrCellAddress(ByVal aRow As Long, ByVal aCol As Long) As String

10      On Error GoTo OOPS

        ErrCellAddress = _
            Application.ConvertFormula("R" & aRow & "C" & aCol, xlR1C1, xlA1, True)

        ' original solution below: packing 2 16 bit integers into a 32 bit long.
        ' a little convoluted and show-off-y if you ask me. I mean Y not just
        ' store the cell address???
20      ' ErrCellAddress = CStr(CDDXHelper.MakeLong(aCol, aRow))

30      On Error GoTo 0
40      Exit Function
OOPS:
        Dim errDesc         As String, errNum       As Long
50      errDesc = "CDDXUpload.ErrCellAddress(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
60      errNum = Err.Number
        'your clean up codes here
70      Call Err.Raise(errNum, Err.source, errDesc)

End Function

Private Sub TrimAttributes(Values As Variant)

        On Error GoTo OOPS

        Dim n                           As Long
10

20      For n = LBound(Values) To UBound(Values)
30          Values(n, 1) = Trim$(Values(n, 1))
40      Next n

50      On Error GoTo 0
60      Exit Sub
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.TrimAttributes(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        'your clean up codes here
        Call Err.Raise(errNum, Err.source, errDesc)

End Sub

Private Sub TrimAttributesRows(Values As Variant)

        On Error GoTo OOPS

        Dim n                           As Long

        If Not IsArray(Values) Then Exit Sub

20      For n = LBound(Values, 2) To UBound(Values, 2)
30          Values(1, n) = Trim(Values(1, n))
40      Next n

50      On Error GoTo 0
60      Exit Sub
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.TrimAttributesRows(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        'your clean up codes here
        Call Err.Raise(errNum, Err.source, errDesc)

End Sub

Private Function getColumnFirstIndex() As Long
10
        On Error GoTo OOPS

        Dim item                        As Variant
        Dim result                      As Long

20      For Each item In [A9:M9]

30          result = result + 1

40          If item.value Like "Column 1" Then

50              getColumnFirstIndex = result

60              Exit Function
70          End If
80      Next item

90      getColumnFirstIndex = 5

100     On Error GoTo 0
110     Exit Function
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.getColumnFirstIndex(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        'your clean up codes here
        Call Err.Raise(errNum, Err.source, errDesc)

End Function

Private Function GetAttributeCount() As Long

        Dim c1                          As Long
        Dim c2                          As Long
        Dim r1                          As Long
        Dim r2                          As Long
        Dim k                           As Long
        Dim n                           As Long
        Dim Values                      As Variant

        r1 = 10
        If IsFuturesSheet(m_sheet) = True Then
            r2 = 17
            c1 = getColumnFirstIndex()
        Else
            r2 = 19
            c1 = 5
        End If

        c2 = V2LastColumn(m_sheet)

        For k = c1 To c2

            Values = m_sheet.Cells(r1, k).Resize(r2 - r1 + 1, 1).value
            Call TrimAttributes(Values)

            For n = UBound(Values) To LBound(Values) Step -1

                If Values(n, 1) <> vbNullString Then
                    If GetAttributeCount < n Then GetAttributeCount = n
                End If
            Next n
        Next k

End Function

Private Function CheckWeeklyAttributes() As Boolean

        Dim attribcount                 As Long
        Dim k                           As Long

        CheckWeeklyAttributes = True

        If Not IsFuturesSheet(m_sheet) Then Exit Function

        attribcount = V2AttributeRows(m_sheet)
        If attribcount <= 0 Then attribcount = GetAttributeCount()
        If attribcount <= 6 Then Exit Function

        For k = FirstDataRow To LastDataRow

            If InStr(LCase$(m_sheet.Cells(k, 3).value), "week") > 0 Then

                Call ShowErr("The max rows of attributes is 6 when the Contract Type contains Week.")
                CheckWeeklyAttributes = False

                Exit Function
            End If
        Next k

End Function

Private Function CheckAttributes() As Boolean
10
        On Error GoTo OOPS

        Dim r1                          As Long
        Dim r2                          As Long
        Dim c1                          As Long
        Dim c2                          As Long
        Dim k                           As Long
        Dim n                           As Long
        Dim attribcount                 As Long
        Dim start                       As Boolean
        Dim rgn                         As Excel.range
        Dim Values                      As Variant
        Dim errCells                    As String

20      errCells = CSheet.WSGetProp(m_sheet, BSConsts.UPLD_ERR_ADDR)
30      attribcount = V2AttributeRows(m_sheet)

40      r1 = 10
50      If IsFuturesSheet(m_sheet) = True Then
60          r2 = 17
70          c1 = getColumnFirstIndex
80      Else
90          r2 = 19
100         c1 = 5
110     End If

120     c2 = V2LastColumn(m_sheet)

130     CheckAttributes = True

140     If attribcount > 0 Then

150         For k = c1 To c2

160             Values = m_sheet.Cells(r1, k).Resize(r2 - r1 + 1, 1).value
170             Call TrimAttributes(Values)

180             For n = LBound(Values) To UBound(Values)

190                 If (Values(n, 1) = vbNullString And n <= attribcount) Or (Values(n, 1) <> vbNullString And n > attribcount) Then
200                     errCells = errCells & IIf(errCells = vbNullString, vbNullString, ",") & ErrCellAddress(r1 + n - 1, k)
210                     m_sheet.Cells(r1 + n - 1, k).Interior.ColorIndex = 22

220                     CheckAttributes = False
230                 End If
240             Next n
250         Next k
260     Else
270         For k = c1 To c2

280             Values = m_sheet.Cells(r1, k).Resize(r2 - r1 + 1, 1).value
290             Call TrimAttributes(Values)

300             start = False

310             For n = UBound(Values) To LBound(Values) Step -1

320                 If Values(n, 1) <> vbNullString Then
330                     If start = False Then start = True

340                 ElseIf start Then
350                     errCells = errCells & IIf(errCells = vbNullString, vbNullString, ",") & ErrCellAddress(r1 + n - 1, k)
360                     m_sheet.Cells(r1 + n - 1, k).Interior.ColorIndex = 22

370                     CheckAttributes = False
380                 End If
390             Next n
400             If start = False Then

410                 errCells = errCells & IIf(errCells = vbNullString, vbNullString, ",") & ErrCellAddress(r1, k)
420                 m_sheet.Cells(r1, k).Interior.ColorIndex = 22
430                 CheckAttributes = False

440                 Exit For
450             End If
460         Next k
470     End If

480     If CheckAttributes Then
            CheckAttributes = CheckWeeklyAttributes()

            Exit Function
        End If

490     Call SetErrCell2(m_sheet, errCells)
500     Values = "No empty value is allowed in between attribute values. Or Have not met specified Attribute Row count"
510     Call ShowErr(Values)

520     On Error GoTo 0
530     Exit Function
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.CheckAttributes(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        'your clean up codes here
        Call Err.Raise(errNum, Err.source, errDesc)

End Function

Private Function CheckDuplicateAttributes() As Boolean
10
        On Error GoTo OOPS

        Dim col1                        As Excel.range
        Dim col2                        As Excel.range
        Dim rgn                         As Excel.range
        Dim r1                          As Long
        Dim r2                          As Long
        Dim c1                          As Long
        Dim c2                          As Long
        Dim k                           As Long
        Dim n                           As Long
        Dim j                           As Long
        Dim attribcount                 As Long
        Dim start                       As Boolean
        Dim Values                      As Variant
        Dim errCells                    As String
        Dim col1String                  As String
        Dim col2String                  As String

20      errCells = CSheet.WSGetProp(m_sheet, BSConsts.UPLD_ERR_ADDR)

40      r1 = 10
50      If IsFuturesSheet(m_sheet) = True Then
60          r2 = 17
70          c1 = getColumnFirstIndex
80      Else
90          r2 = 19
100         c1 = 5
110     End If

120     c2 = V2LastColumn(m_sheet)
          
130     CheckDuplicateAttributes = True

150     For k = c1 To c2

            Set col1 = m_sheet.Cells(r1, k).Resize(r2 - r1 + 1, 1)
            col1String = ConvertToString(col1)

160         For j = k + 1 To c2

                Set col2 = m_sheet.Cells(r1, j).Resize(r2 - r1 + 1, 1)
                col2String = ConvertToString(col2)

                If (StrComp(col1String, col2String, vbBinaryCompare) = 0) Then

                    errCells = AppendErrCells(errCells, col1)
                    errCells = AppendErrCells(errCells, col2)

210                 col1.Interior.ColorIndex = 22
                    col2.Interior.ColorIndex = 22

                    CheckDuplicateAttributes = False
                End If
            Next j
250     Next k

        If CheckDuplicateAttributes Then

            Exit Function
        End If

490     Call SetErrCell2(m_sheet, errCells)
500     Values = "Please check duplicate attributes"
510     Call ShowErr(Values)

520     On Error GoTo 0
530     Exit Function
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.CheckDuplicateAttributes(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        Call Err.Raise(errNum, Err.source, errDesc)

End Function

Private Function ConvertToString(param As Excel.range) As String

    Dim c                               As Excel.range
    Dim result                          As String

    For Each c In param.Cells
        result = result & c & Chr$(&H6)
    Next c

    ConvertToString = result

End Function

Private Function AppendErrCells(initialString As String, param As Excel.range) As String

        Dim c                           As Excel.range

        For Each c In param.Cells
            initialString = initialString & IIf(initialString = vbNullString, vbNullString, ",") & ErrCellAddress(c.row, c.column)
        Next c

        AppendErrCells = initialString

End Function

Private Sub SetErrCell2(sht As Excel.Worksheet, ByVal aErrCells As String)
10
        On Error GoTo OOPS

        Dim errCells                    As String

20      errCells = CSheet.WSGetProp(sht, BSConsts.UPLD_ERR_ADDR)

30      If errCells <> vbNullString Then errCells = errCells & ","

40      errCells = errCells & aErrCells

50      Call CSheet.WSSetProp(sht, BSConsts.UPLD_ERR_ADDR, errCells)

60      On Error GoTo 0
70      Exit Sub
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.SetErrCell2(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        'your clean up codes here
        Call Err.Raise(errNum, Err.source, errDesc)

End Sub

Private Function Tolong(value As String) As Long

10      On Error GoTo OOPS

20      Tolong = CLng(value)
30      If Err.Number <> 0 Then Tolong = 0

40      On Error GoTo 0
50      Exit Function
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.Tolong(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        'your clean up codes here
        Call Err.Raise(errNum, Err.source, errDesc)

End Function

Private Sub ResetColorsOnUploadSheet()

        On Error GoTo OOPS
10
        ' spot bg color: even, row < 20 and >=10
        Const BG_COLOR_EVEN_ROW_SPOT    As Long = 16773109
        ' forecast bg color: even, row < 20 and >= 10
        Const BG_COLOR_EVEN_ROW_FCAST   As Long = 16447216
        ' futures bg color: even, row < 20 and >= 10
        Const BG_COLOR_EVEN_ROW_FUTR    As Long = 14611454

        ' even row bg color > 21 13695215
        Const BG_COLOR_EVEN_ROW         As Long = 13695215

        Dim errCells                    As String
        Dim sWShtType                   As String
        Dim sCellAddr                   As String
        Dim bIsEven                     As Boolean
        Dim Values                      As Variant
        Dim row                         As Long
        Dim dataEntryRow                As Long
        Dim k                           As Long

20
        errCells = CSheet.WSGetProp(m_sheet, BSConsts.UPLD_ERR_ADDR)
30
        If errCells = vbNullString Then Exit Sub
40
        ' fetch upload sheet type (cust props - ZE.sheet.type)
        sWShtType = CSheet.ZESheetType(m_sheet)
        ' upload sheet must be F (Forecast), S (Spot) or U (Futures)
        If Not sWShtType Like "[fFsSuU]" Then Exit Sub

        ' futures upload sheets data entry row starts at 19
        dataEntryRow = IIf(sWShtType Like "[uU]", 19, 21)

        Values = Split(errCells, ",")
50
        For k = LBound(Values) To UBound(Values)
60
            sCellAddr = Values(k)
            ' Debug.Print "cell_addr: "; sCellAddr
70
            With m_sheet.range(sCellAddr)
                ' DDX-1494: The background colors should be restored
                ' after errors are corrected on upload sheets
80
                ' save row num for eval...
                row = .row
                ' see if is even row
                bIsEven = ((row Mod 2) = 0)
90
                ' on all upload sheets, rows < 9 or
                ' else odd num'd have no bg color
                If row < 9 Or (Not bIsEven) Then
                    .Interior.color = UPLOAD_COLOR_ODD_ROW 'xlNone
100
                    ' all upload sheets, even rows >= data entry row (19 for futures, 21 otherwise)
                    ' have same bg color...
                ElseIf bIsEven And (row >= dataEntryRow) Then
                    .Interior.color = BG_COLOR_EVEN_ROW
110
                ' even row, < [data entry row] and >= 10
                ElseIf bIsEven And (row < dataEntryRow And row >= 10) Then
                    ' depends on upload sheet...
                    Select Case sWShtType
                    Case "S"
                    ' spot...
                    .Interior.color = BG_COLOR_EVEN_ROW_SPOT
120
                    ' forecast...
                    Case "F"
                    .Interior.color = BG_COLOR_EVEN_ROW_FCAST
130
                    ' otherwise, futures
                    Case Else
                    .Interior.color = BG_COLOR_EVEN_ROW_FUTR

                    End Select
                End If
140
                If Not .Comment Is Nothing Then Call .Comment.Delete
            End With
150
        Next k
160
        Call CSheet.WSSetProp(m_sheet, BSConsts.UPLD_ERR_ADDR, " ")

170     On Error GoTo 0
        Exit Sub

OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.ResetColorsOnUploadSheet(), Line: " & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        Call CDDXHelper.LogError("R/T Error #" & errNum & " " & errDesc, Err.source)

End Sub

Private Function effectiveDateValid() As Boolean

        On Error GoTo OOPS

10      Dim effectiveDate               As String

20      effectiveDateValid = True
30      effectiveDate = V2Date(m_sheet)

40      If m_sheet_type <> ZESHEET_SPOT Then

50          If effectiveDate = vbNullString Then

60              effectiveDateValid = False
70              Call Err.Raise(21325, "Upload Error", "Effective Date may not be empty when Granularity is set to Monthly.")
80          End If
90      End If

100     On Error GoTo 0
110     Exit Function
OOPS:
        Dim errDesc         As String, errNum       As Long
120     errDesc = "CDDXUpload.effectiveDateValid(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
130     errNum = Err.Number
        'your clean up codes here
140     Call Err.Raise(errNum, Err.source, errDesc)

End Function

Private Sub SetErrCell(ByVal aRow As Long, ByVal aCol As Long)

        On Error GoTo OOPS
       
10      Dim errCells                    As String

20      errCells = CSheet.WSGetProp(m_sheet, BSConsts.UPLD_ERR_ADDR)

30      If errCells <> vbNullString Then errCells = errCells & ","

40      errCells = errCells & ErrCellAddress(aRow, aCol)

50      Call CSheet.WSSetProp(m_sheet, BSConsts.UPLD_ERR_ADDR, errCells)

60      On Error GoTo 0
70      Exit Sub
OOPS:
        Dim errDesc         As String, errNum       As Long
80      errDesc = "CDDXUpload.SetErrCell(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
90      errNum = Err.Number
        'your clean up codes here
100     Call Err.Raise(errNum, Err.source, errDesc)

End Sub

Private Sub ShowErr(ByVal value As String)

10      On Error GoTo OOPS

20      If m_silient Then
30          CDDXApp.StatusMessage = value
40      Else
50          Call CDDXApp.DialogMessage(value, vbExclamation)
60      End If

70      On Error GoTo 0
80      Exit Sub
OOPS:
        Dim errDesc         As String, errNum       As Long
90      errDesc = "CDDXUpload.ShowErr(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
100     errNum = Err.Number
        'your clean up codes here
110     Call Err.Raise(errNum, Err.source, errDesc)

End Sub

Private Sub Class_Initialize()

10      On Error GoTo OOPS

20      m_silient = False
30      Set m_ws = CDDXLib.DefaultZEWSProxy(BSConsts.DDX_PID)
'40     Set m_timer = CTimer

50      On Error GoTo 0
60      Exit Sub
OOPS:
        Dim errDesc         As String, errNum       As Long
70      errDesc = "CDDXUpload.Class_Initialize(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
80      errNum = Err.Number
        'your clean up codes here
90      Call Err.Raise(errNum, Err.source, errDesc)

End Sub

Private Function isNeedAppendHourColumn() As Boolean

10      On Error GoTo OOPS

20      If m_sheet Is Nothing Then Exit Function

30      If m_sheet_type = ZESHEET_FUTURES Then

40          If (StrComp(m_sheet.Cells(20, 5).value, "Hour", vbTextCompare) <> 0) And (StrComp(m_sheet.Cells(20, 5).value, "Start Time", vbTextCompare) <> 0) Then
50              isNeedAppendHourColumn = True
60          End If
70      End If

80      On Error GoTo 0
90      Exit Function
OOPS:
        Dim errDesc         As String, errNum       As Long
100     errDesc = "CDDXUpload.isNeedAppendHourColumn(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
110     errNum = Err.Number
        'your clean up codes here
120     Call Err.Raise(errNum, Err.source, errDesc)

End Function

Public Sub SaveData(Optional fileNameString As String)

        On Error GoTo OOPS
1
        Dim targetRange                 As Excel.range

        Dim row                         As Variant
        Dim cellItem                    As Variant

        Dim fileNumber                  As Long
        Dim noAttr                      As Long

        Dim rowIndex                    As Long
        Dim columnIndex                 As Long

        Dim filename                    As String
        Dim buff                        As String
        Dim cellValue                   As String

        Dim isAppendHourColumn          As Boolean


9       noAttr = IIf(m_sheet_type = ZESHEET_FUTURES, 8, 10)
10
30      If Len(fileNameString) > 0 Then
40            filename = fileNameString
50      Else
60          filename = CDDXLib.DefaultZEWSProxy(BSConsts.DDX_PID).HelperResultsetFileName(GetSheetID(m_sheet), 0) & ".data"
70      End If

80      Call CDDXHelper.DeleteFile(filename)

90      Call Err.Clear

100     fileNumber = FreeFile

110     Open (filename) For Output As fileNumber

120     If Err.Number <> 0 Then Exit Sub

130     Print #fileNumber, "forecastDate=" & V2Date(m_sheet)
          
140     Print #fileNumber, "nameSpace=" & Namespace(m_sheet)
150     Print #fileNumber, "databaseObject=" & reportName(m_sheet)
160     Print #fileNumber, "targetTable=" & V2Table(m_sheet)

170     Print #fileNumber, "firstRowOfData=" & CStr(FirstDataRow)
180     Print #fileNumber, "lastRowOfData=" & CStr(LastDataRow)
190     Print #fileNumber, "lastColumnOfData=" & CStr(V2LastColumn(m_sheet))
200     Print #fileNumber, "attributeRows=" & IIf((V2AttributeRows(m_sheet) > 0), CStr(V2AttributeRows(m_sheet)), "N/A")

210     Print #fileNumber, "insertRecordsOnly=" & CStr(insertOnly())
220     Print #fileNumber, "LoadMetadata=" & CStr(IsLoadMetaData(m_sheet))
230     Print #fileNumber, " "

240     Set targetRange = m_sheet.Cells(10, getColumnFirstIndex - 1).Resize(noAttr, V2LastColumn(m_sheet) - getColumnFirstIndex + 2)

250     For Each row In targetRange.rows

260         rowIndex = rowIndex + 1
270         columnIndex = 0
280         buff = vbNullString

290           For Each cellItem In row.Cells

300               If (columnIndex > 0) Then
310                   buff = buff + vbTab
320               End If

330               columnIndex = columnIndex + 1
340               cellValue = cellItem.value
350               buff = buff + Replace(cellValue, vbTab, " ")

360           Next cellItem

370           Print #fileNumber, buff
380     Next row

390     Print #fileNumber, " "

391     If m_sheet_type = ZESHEET_FUTURES Then
392         Print #fileNumber, " "
393         Print #fileNumber, " "
394     End If

400     Set targetRange = m_sheet.Cells(FirstDataRow, 3).Resize(LastDataRow - FirstDataRow + 1, V2LastColumn(m_sheet) - 2)
410     rowIndex = 0

420     isAppendHourColumn = isNeedAppendHourColumn()

430     For Each row In targetRange.rows

440         rowIndex = rowIndex + 1
450         columnIndex = 0
460         buff = vbNullString

470         For Each cellItem In row.Cells

480             If (columnIndex > 0) Then
490                 buff = buff + vbTab
500             End If

510             columnIndex = columnIndex + 1

520             If (columnIndex = 3 And isAppendHourColumn) Then
530                 buff = buff & " " & vbTab
540             End If

550             cellValue = cellItem.value
560             buff = buff + Replace(cellValue, vbTab, " ")
570         Next cellItem

580         Print #fileNumber, buff
590     Next row

600     Close #fileNumber

610     On Error GoTo 0
620     Exit Sub
OOPS:
        Dim errDesc         As String, errNum       As Long
630     errDesc = "CDDXUpload.SaveData(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
640     errNum = Err.Number
        'your clean up codes here
650     Call Err.Raise(errNum, Err.source, errDesc)

End Sub

Public Sub ImportFile(filename As String)

10      On Error GoTo OOPS

20      If Len(filename) = 0 Then Exit Sub

        Dim lineArray()                 As String
        Dim lineString                  As String

        Dim fileNumber                  As Long
        Dim lineIndex                   As Long

        Dim attributeMatrixStartRow     As Long
        Dim DataMatrixStartRow          As Long
        Dim i                           As Long

30      fileNumber = FreeFile
40      attributeMatrixStartRow = 12
50      DataMatrixStartRow = 23

60      Open filename For Input As fileNumber

70      Do
80          If EOF(fileNumber) Then Exit Do

90          Line Input #fileNumber, lineString
100         lineIndex = lineIndex + 1

110         If Len(Trim$(lineString)) > 0 Then

120             If (lineIndex < attributeMatrixStartRow - 1) Then

130                 Call importTitle(lineString, "forecastDate", "* Date:*")
140                 Call importTitle(lineString, "nameSpace", "*Name Space:*")
150                 Call importTitle(lineString, "databaseObject", "*Database Object:*")
160                 Call importTitle(lineString, "targetTable", "*Target Table:*")
170                 Call importTitle(lineString, "firstRowOfData", "*First Row of Data:*")
180                 Call importTitle(lineString, "lastRowOfData", "*Last Row of Data:*")
190                 Call importTitle(lineString, "lastColumnOfData", "*Last Column of Data:*")
200                 Call importTitle(lineString, "attributeRows", "*Attribute Rows:*")
210                 Call importTitle(lineString, "insertRecordsOnly", "*Insert Records Only:*")
220                 Call importTitle(lineString, "LoadMetadata", "*Load Metadata:*")
230             End If

240             If (lineIndex >= attributeMatrixStartRow And lineIndex < attributeMatrixStartRow + 10) Then

250                 lineArray = Split(lineString, vbTab)
260                 m_sheet.Cells(lineIndex - 2, 4).Resize(, UBound(lineArray) + 1).value = lineArray
270             End If

280             If (lineIndex >= DataMatrixStartRow) Then

290                 lineArray = Split(lineString, vbTab)

300                 If (CDDXUtility.IsArrayEmpty(lineArray) = False) Then

310                     If UBound(lineArray) > 1 Then

320                         m_sheet.Cells(lineIndex - 2, 3).value = lineArray(0)
330                         m_sheet.Cells(lineIndex - 2, 4).value = lineArray(1)

340                         For i = IIf(m_sheet_type = ZESHEET_FUTURES, 3, 2) To UBound(lineArray)

350                             m_sheet.Cells(lineIndex - 2, IIf(m_sheet_type = ZESHEET_FUTURES, 2, 3) + i) = lineArray(i)
360                         Next i
370                     End If
380                 End If
390             End If
400         End If
410     Loop

420     Close #fileNumber

430     On Error GoTo 0
440     Exit Sub
OOPS:
        Dim errDesc         As String, errNum       As Long
450     errDesc = "CDDXUpload.ImportFile(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
460     errNum = Err.Number
        'your clean up codes here
470     Call Err.Raise(errNum, Err.source, errDesc)

End Sub

Public Sub importTitle(lineString As String, importedStringPattern As String, excelStringPattern As String)

10      On Error GoTo OOPS

        Dim targetRange                 As Excel.range
        Dim lineArray()                 As String

20      If (InStr(lineString, importedStringPattern) > 0) Then

30          If (InStr(lineString, "=") > 0) Then

40               lineArray = Split(lineString, "=")
50               Set targetRange = V2ValueCell(m_sheet, excelStringPattern)

60               If Not targetRange Is Nothing Then
70                  targetRange.value = Trim$(lineArray(1))
80               End If

90               If (importedStringPattern = "insertRecordsOnly") Then
100                 targetRange.value = IIf((StrComp(Trim$(lineArray(1)), "True") = 0), "Yes", "No")
110              End If

120              If (importedStringPattern = "LoadMetadata") Then
130                 targetRange.value = IIf((StrComp(Trim$(lineArray(1)), "True") = 0), "Yes", "No")
140              End If

150              If (importedStringPattern = "lastColumnOfData") Then
160                 targetRange.value = CDDXUtility.IntegerToColmnLetter(CInt(Trim$(lineArray(1))))
170             End If
180         End If
190     End If

200     On Error GoTo 0
210     Exit Sub
OOPS:
        Dim errDesc         As String, errNum       As Long
220     errDesc = "CDDXUpload.importTitle(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
230     errNum = Err.Number
        'your clean up codes here
240     Call Err.Raise(errNum, Err.source, errDesc)

End Sub

Private Sub Class_Terminate()

10      On Error GoTo OOPS

        Dim r                           As Excel.range

20      If Not m_sheet Is Nothing Then

30          Set r = V2ValueCell(m_sheet, "*Attribute Rows:*")

40          If Not r Is Nothing Then r.offset.Locked = False

50          Call CDDXUpload.ProtectSheet(m_sheet)
60      End If

70      On Error GoTo 0
80      Exit Sub
OOPS:
        Dim errDesc         As String, errNum       As Long
90      errDesc = "CDDXUpload.Class_Terminate(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
100     errNum = Err.Number
        'your clean up codes here
110     Call Err.Raise(errNum, Err.source, errDesc)

End Sub

Private Property Get dataRange(aSheet As Excel.Worksheet) As Excel.range

10      On Error GoTo OOPS

20      Set dataRange = aSheet.Cells(IIf(m_sheet_type = ZESHEET_FUTURES, 19, 21), 3)

30      On Error GoTo 0
40      Exit Property
OOPS:
        Dim errDesc         As String, errNum       As Long
50      errDesc = "CDDXUpload.datarange(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
60      errNum = Err.Number
        'your clean up codes here
70      Call Err.Raise(errNum, Err.source, errDesc)

End Property

Private Property Get Namespace(sheet As Excel.Worksheet) As String

10      On Error GoTo OOPS

20      Namespace = V2Namespace(sheet) 'sheet.Cells(5, 8).value 'DDX-192

30      On Error GoTo 0
40      Exit Property
OOPS:
        Dim errDesc         As String, errNum       As Long
50      errDesc = "CDDXUpload.Namespace(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
60      errNum = Err.Number
        'your clean up codes here
70      Call Err.Raise(errNum, Err.source, errDesc)

End Property

Public Property Get reportName(sheet As Excel.Worksheet) As String

10      On Error GoTo OOPS

20      reportName = V2Report(sheet) 'sheet.Cells(6, 8).value

30      On Error GoTo 0
40      Exit Property
OOPS:
        Dim errDesc         As String, errNum       As Long
50      errDesc = "CDDXUpload.reportName(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
60      errNum = Err.Number
        'your clean up codes here
70      Call Err.Raise(errNum, Err.source, errDesc)

End Property

Private Function GetSheetID(aSheet As Excel.Worksheet) As String
10
        On Error GoTo OOPS

        Dim id                          As String

20      id = CDDXHelper.ZESheetID(BSConsts.DDX_PID, aSheet)

30      If id = ZESHEET_NIL Then

40          If CDDXHelper.IsUploadSheet(aSheet) Then

50              id = CDDXHelper.NewGUID()
60              CSheet.ZESheetID(aSheet) = id
70          End If
80      End If

90      GetSheetID = id

100     On Error GoTo 0
110     Exit Function
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.GetSheetID(), Line: " & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        Call CDDXHelper.LogError("R/T Error #" & errNum & " " & errDesc, Err.source)

End Function

Private Function GetSheetByID(ByVal aID As String) As Excel.Worksheet

        On Error GoTo OOPS

        Dim wk                          As Excel.Workbook
        Dim sht                         As Excel.Worksheet

20      For Each wk In Workbooks

30          If Not wk.IsAddin Then

40              For Each sht In wk.Worksheets

50                  If CDDXHelper.ZESheetID(BSConsts.DDX_PID, sht) = aID Then
60                      Set GetSheetByID = sht

70                      Exit Function
80                  End If
90              Next sht
100         End If
110     Next wk

120     On Error GoTo 0
130     Exit Function
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.GetSheetByID(), Line: " & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        Call CDDXHelper.LogError("R/T Error #" & errNum & " " & errDesc, Err.source)

End Function

Private Function UploadData(aSheet As Excel.Worksheet, tName As String, dataType As String, fDate As String, flags As Long, ByVal dataRows As Long, ByVal aDataCols As Long) As Boolean

        On Error GoTo OOPS

        Dim data                        As ZEWSProxy.IWriteDataResponseHolder
        Dim id                          As String
        Dim ret                         As Boolean

        id = GetSheetID(aSheet)
        If IsInProgress(id) Then Exit Function

        Call V2Status(aSheet, vbNullString)

        If Not Sync Then

            Call CTimer.ValidateMonitor
            Call CTimer.StartMonitor(id, vbNullString)

            Call m_ws.WriteData(id, CDDXLogin.CredentialToken(DDX_PID), id, tName, dataType, fDate, flags, dataRows, aDataCols)
            Call AddTask(id)

            UploadData = True

        Else
            Set data = m_ws.WriteDataSync(id, CDDXLogin.CredentialToken(DDX_PID), id, tName, dataType, fDate, CDDXHelper.IsFlag(flags, UPLOAD_INSERT_ONLY), dataRows, aDataCols)
            Call OnWriteData(id, data)
            ret = IIf(Len(data.Error) = 0 And data.Cancelled = False, True, False)

            RaiseEvent OnAfterUploadData(Me, aSheet, ret, data.Error)

            UploadData = ret

        End If
OOPS:
    If Err.Number <> 0 Then
        RaiseEvent OnAfterUploadData(Me, aSheet, False, Err.Description)
    End If

    On Error GoTo 0
    Exit Function

End Function

Public Function UploadSheetFile(ByVal pid As String, filename As String, targetTableName As String, dataType As String, ForecastDate As String, isInsertOnly As Boolean, dataRows As Long, dataColumns As Long) As ZEWSProxy.IWriteDataResponseHolder
10
        On Error GoTo OOPS

        If Not CDDXLogin.Loggedin Then Exit Function

        Dim guid                        As String

20      If Not CDDXApp.IsPX(pid) Then Exit Function

30      guid = CDDXHelper.NewGUID()

40      With DDXObjects.LoginObject
50          Call CTimer.ValidateMonitor
            Call CTimer.StartMonitor(guid, vbNullString)
60          Set UploadSheetFile = m_ws.UploadSheetFile(guid, .CredentialToken(DDX_PID), filename, targetTableName, dataType, ForecastDate, isInsertOnly, dataRows, dataColumns)
70      End With

80      On Error GoTo 0
90      Exit Function
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.UploadSheetFile(), Line: " & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        Call CDDXHelper.LogError("R/T Error #" & errNum & " " & errDesc, Err.source)

End Function

Private Sub AddTask(ByVal aID As String)

10      On Error GoTo OOPS

20      Call m_tasks.Add(aID)

30      On Error GoTo 0
40      Exit Sub
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.AddTask(), Line: " & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        Call CDDXHelper.LogError("R/T Error #" & errNum & " " & errDesc, Err.source)

End Sub

Private Sub RemoveTask(ByVal aID As String)
10
        On Error GoTo OOPS

        Dim k                           As Long

20      For k = 1 To m_tasks.count

30          If m_tasks.item(k) = aID Then

40              Call m_tasks.Remove(k)

50              Exit Sub
60          End If
70      Next k

80      On Error GoTo 0
90      Exit Sub
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.RemoveTask(), Line: " & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        Call CDDXHelper.LogError("R/T Error #" & errNum & " " & errDesc, Err.source)

End Sub
'
Private Function IsInProgress(ByVal aID As String) As Boolean
10
        On Error GoTo OOPS

        Dim k                           As Long

20      For k = 1 To m_tasks.count

30          If m_tasks.item(k) = aID Then

40              IsInProgress = True

50              Exit Function
60          End If
70      Next k

80      On Error GoTo 0
90      Exit Function
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.IsInProgress(), Line: " & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        Call CDDXHelper.LogError("R/T Error #" & errNum & " " & errDesc, Err.source)

End Function

Private Property Get IsLoadMetaData(sheet As Worksheet) As Boolean

10      On Error GoTo OOPS

20      IsLoadMetaData = (Trim$(V2LoadMetadata(sheet)) = "Yes")

30      On Error GoTo 0
40      Exit Property
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.IsInProgress(), Line: " & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        Call CDDXHelper.LogError("R/T Error #" & errNum & " " & errDesc, Err.source)

End Property

Private Property Get CarriageReturn() As String

    CarriageReturn = IIf(CDDXApp.XLVersion <= 2003, vbLf, vbLf)

End Property

Private Sub ShowDataResult(CSheet As Excel.Worksheet, errmsg As String, inserted As String, ignored As String, updated As String, badRecords As String)

        Call V2Status(CSheet, _
            IIf(errmsg = vbNullString, CStr(Now()), errmsg) & CarriageReturn & _
                " INS/UPD:   " & inserted + "/" & updated & CarriageReturn & _
                    " IGG/INV:   " & ignored & "/" & badRecords)

End Sub

Public Sub UploadMetadataByNames(ByVal ns As String, ByVal rpt As String, ByVal Incremental As Boolean)

10      On Error GoTo OOPS

20      Call m_ws.LoadMetaData(CDDXHelper.NewGUID(), CDDXLogin.sid, ns, rpt, Incremental, vbNullString, vbNullString)

30      On Error GoTo 0
40      Exit Sub
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.UploadMetadataByNames(), Line: " & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        Call CDDXHelper.LogError("R/T Error #" & errNum & " " & errDesc, Err.source)

End Sub

Private Function SaveMetaData(aSheet As Excel.Worksheet, ByVal Incremental As Boolean, ByVal force As Boolean) As Boolean
10
        On Error GoTo OOPS

        Dim id                          As String

20      If Not force Then

30          If Not ValidateMetaData(True) Then

40              Call CDDXUpload.UnProtectSheet(aSheet)

50              Exit Function
60          End If
70      End If

80      id = GetSheetID(aSheet)
      '    taskID = id + ".m"

90      CDDXApp.StatusMessage = vbNullString
100     Call CTimer.ValidateMonitor
        Call CTimer.StartMonitor(id, vbNullString)
110     Call m_ws.LoadMetaData(id, CDDXLogin.sid, Namespace(aSheet), reportName(aSheet), Incremental, vbNullString, id)
120     SaveMetaData = True
130     Call ShowMetadataResult(aSheet, Err.Description)

140       On Error GoTo 0
150       Exit Function
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.SaveMetaData(), Line: " & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        Call CDDXHelper.LogError("R/T Error #" & errNum & " " & errDesc, Err.source)

End Function

Private Sub ShowErrors(data As ZEWSProxy.IWriteDataResponseHolder, aSheet As Excel.Worksheet)
10
        On Error GoTo OOPS

        Dim cmt                         As Excel.Comment
        Dim dr                          As Excel.range
        Dim i                           As Variant
        Dim rows                        As Variant
        Dim offset                      As Long
        Dim r                           As Long
        Dim mm()                        As String
        Dim errCells                    As String

20      For Each cmt In aSheet.Comments
30          Call cmt.Delete
40      Next cmt

50      If UBound(data.Columns) < 0 Then Exit Sub

60      offset = getColumnFirstIndex - 2

70      Call CDDXUpload.UnProtectSheet(aSheet)

80      For Each i In data.Columns

90          rows = data.rows(i)
100         mm = data.Descriptions(i)

110         For r = LBound(rows) To UBound(rows)

120             Set dr = dataRange(aSheet).Cells(rows(r) + 1, i + offset)
130             dr.Interior.ColorIndex = 22

140             If errCells <> vbNullString Then errCells = errCells & ","
150             errCells = errCells & ErrCellAddress(dr.row, dr.column)

160             If dr.Cells(1, 1).Comment Is Nothing Then
170                 Set cmt = dr.Cells(1, 1).AddComment
180             Else
190                 Set cmt = dr.Cells(1, 1).Comment
200             End If

210             If mm(r) <> vbNullString Then
220                 cmt.Visible = False
230                 cmt.text mm(r)
240             Else
250                 Call cmt.Delete
260             End If
270         Next r
280     Next i

290     If errCells <> vbNullString Then
300         Call SetErrCell2(dr.Parent, errCells)
310     End If

320     Call CDDXUpload.UnProtectSheet(aSheet)
330     Exit Sub

340     On Error GoTo 0
350     Exit Sub
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.ShowErrors(), Line: " & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        Call CDDXHelper.LogError("R/T Error #" & errNum & " " & errDesc, Err.source)

End Sub

Public Sub UnProtectSheet(sheet As Excel.Worksheet)

10      On Error GoTo OOPS

20      sheet.Unprotect Password:=BSConsts.UPLOAD_SHEET_PASSWORD

30      On Error GoTo 0
40      Exit Sub
OOPS:
50      Call sheet.Unprotect
60      Call Err.Clear

End Sub

Public Sub ProtectSheet(sheet As Excel.Worksheet)

10      On Error GoTo OOPS

20      sheet.EnableOutlining = True
30      sheet.Protect UserInterfaceOnly:=True

40      On Error GoTo 0
50      Exit Sub
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.ProtectSheet(), Line: " & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        Call CDDXHelper.LogError("R/T Error #" & errNum & " " & errDesc, Err.source)

End Sub

Public Sub UploadMetaData()

10      On Error GoTo OOPS

20      Call CDDXUpload.UnProtectSheet(m_sheet)
30      Call SaveMetaData(m_sheet, True, False)

40      On Error GoTo 0
50      Exit Sub
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.UploadMetaData(), Line: " & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        Call CDDXHelper.LogError("R/T Error #" & errNum & " " & errDesc, Err.source)

End Sub

Public Sub GetUploadTables(ByVal pid As String, rgn As Excel.range)

10      On Error GoTo OOPS

20      If Not CDDXApp.IsPX(pid) Then Exit Sub

30      If rgn Is Nothing Then Exit Sub

40      Call SetUploadTables(rgn.Parent, rgn)

50      On Error GoTo 0
60      Exit Sub
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.GetUploadTables(), Line: " & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        Call CDDXHelper.LogError("R/T Error #" & errNum & " " & errDesc, Err.source)

End Sub

Private Sub CreateValidataionList(data() As String, rgn As Excel.range)
10
        On Error GoTo OOPS

        Dim listValues                  As String

20      listValues = ConcatUserTables(data)

30      With rgn
40          .value = ""
50          Call .Validation.Delete

60          If InStr(listValues, "*") <= 0 Then

70              With .Validation
80                  Call .Add(Type:=xlValidateList, AlertStyle:=xlValidAlertStop, Operator:=xlBetween, Formula1:=listValues)
90              End With
100             .value = data(0)
110         End If
120     End With

130     On Error GoTo 0
140     Exit Sub
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.CreateValidataionList(), Line: " & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        Call CDDXHelper.LogError("R/T Error #" & errNum & " " & errDesc, Err.source)

End Sub

Private Sub SetUploadTables(aSheet As Excel.Worksheet, rgn As Excel.range)
10
        On Error GoTo OOPS

20      Call CDDXUpload.UnProtectSheet(aSheet)
30      Call CreateValidataionList(UserUploadTables, rgn)
40      Call CDDXUpload.UnProtectSheet(aSheet)

50      On Error GoTo 0
60      Exit Sub
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.SetUploadTables(), Line: " & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        Call CDDXHelper.LogError("R/T Error #" & errNum & " " & errDesc, Err.source)

End Sub

Private Function readRFI(aFileName As String, typeID As String, Cancelled As String, Error As String, userData As String) As Boolean
10
        On Error GoTo OOPS

        Dim FileNum                     As Long

20      FileNum = FreeFile
30      Open aFileName For Input As FileNum

40      Line Input #FileNum, typeID
50      Line Input #FileNum, Cancelled
60      Line Input #FileNum, Error
70      Line Input #FileNum, userData

80      Close (FileNum)
90      Call Kill(aFileName)

100     Error = Trim(Error)
110     readRFI = True

120     On Error GoTo 0
130     Exit Function
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.readRFI(), Line: " & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        Call CDDXHelper.LogError("R/T Error #" & errNum & " " & errDesc, Err.source)

End Function

Private Function IsInfoFile(ByVal inFile As String) As Boolean

        Dim k                           As Long
        Dim ln                          As Long
        Dim ext                         As String

        ln = Len(inFile)
        If ln = 0 Then Exit Function

        For k = ln To 1 Step -1

            If Mid$(inFile, k, 1) = "." Then

                ext = Mid(inFile, k)

                If StrComp(ext, ".u", vbTextCompare) = 0 Or StrComp(ext, ".m", vbTextCompare) = 0 Then
                    IsInfoFile = True

                    Exit For
                End If
            End If
        Next k

End Function

Public Sub OnUploadData(pid As String, id As String, fl() As String, ByVal userData As String)
 Dim data As ZEWSProxy.IWriteDataResponseHolder
 Dim typeID As String
 Dim Cancelled As String
 Dim ud As String
 Dim Error As String
 Dim k As Long
        
    If Not CDDXApp.IsPX(pid) Then Exit Sub
    
    On Error GoTo OOPS

    Application.EnableCancelKey = xlDisabled
    Application.Interactive = False
    
    If Len(Join(fl)) = 0 Then
        Call OnWriteDataError(id, "Could not find result file")
        
    Else
        For k = LBound(fl) To UBound(fl)
            If IsInfoFile(fl(k)) Then
                If readRFI(fl(k), typeID, Cancelled, Error, ud) Then
                    If typeID = "U" Then
                        If Trim$(Error) <> vbNullString Then
                            Call OnWriteDataError(id, Error)
                        Else
                            With m_ws
                                Set data = .GetUploadResults(.HelperResultsetFileName(id, Asc("o")))
                            End With

                            If Not data Is Nothing Then
                                Call OnWriteData(id, data)
                            Else
                                Call OnWriteDataError(id, "Could not find result file")
                            End If
                        End If
                        
                    ElseIf typeID = "M" Then
                        Call OnLoadMetaData(id, Error)
                    End If
                End If
            End If
        Next
    End If

OOPS:
    If Err.Number <> 0 Then
        Call CDDXHelper.LogError(Err.Description, Err.source)
    End If
    Application.Interactive = True
    Exit Sub
End Sub

Private Sub OnWriteDataError(ByVal sheetId As String, ByVal aError As String)
10
        On Error GoTo OOPS

        Dim sht                         As Excel.Worksheet
        Dim ok                          As Boolean

20      Call RemoveTask(sheetId)
30      Set sht = GetSheetByID(sheetId)

40      If sht Is Nothing Then Exit Sub

50      Call V2Status(sht, aError)

60      RaiseEvent OnAfterUploadData(Me, sht, False, aError)

70      On Error GoTo 0
80      Exit Sub
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.OnWriteDataError(), Line: " & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        Call CDDXHelper.LogError("R/T Error #" & errNum & " " & errDesc, Err.source)

End Sub

Private Sub OnWriteData(id As String, data As ZEWSProxy.IWriteDataResponseHolder)
10
        On Error GoTo OOPS

        Dim sht                         As Excel.Worksheet
        Dim ok                          As Boolean

20      Call RemoveTask(data.sheetName)

30      Set sht = GetSheetByID(id) 'data.sheetName)

40      If sht Is Nothing Then Exit Sub

50      ok = (data.Error = vbNullString And Not data.Cancelled)

60      RaiseEvent OnAfterUploadData(Me, sht, ok, data.Error)

70      Call ShowErrors(data, sht)
80      Call ShowDataResult(sht, IIf(data.Cancelled, "Cancelled", data.Error), data.recordsInserted, data.recordsIgnored, data.recordsUpdated, data.recordsBad)

90      If ok Then
100         If data.recordsInserted > 0 Or data.recordsUpdated > 0 Then

110             Call CDDXUpload.UnProtectSheet(sht)

120             If IsLoadMetaData(sht) Then
130                 Call SaveMetaData(sht, True, False)
140             End If
150         End If
160     End If

170     Call CDDXUpload.ProtectSheet(sht)

180     On Error GoTo 0
190     Exit Sub
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.OnWriteData(), Line: " & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        Call CDDXHelper.LogError("R/T Error #" & errNum & " " & errDesc, Err.source)

End Sub

Private Sub OnLoadMetaData(taskID As String, errorMsg As String)
10
        On Error GoTo OOPS

        Dim sht                         As Excel.Worksheet
        Dim msg                         As String


20      Set sht = GetSheetByID(taskID)

30      If sht Is Nothing Then Exit Sub

40      RaiseEvent OnAfterUploadMetadata(Me, sht, (errorMsg = vbNullString), errorMsg)

50      If errorMsg <> vbNullString Then
60          If Len(errorMsg) > 12 Then
                ' don't know what supposed 2b here
                ' or what this does???
70          End If
80          Call V2Status(sht, errorMsg)
90          msg = errorMsg
100     Else
110         msg = "Loaded"
120     End If

130     Call ShowMetadataResult(sht, msg)
140     Call CDDXUpload.ProtectSheet(sht)

150     On Error GoTo 0
160     Exit Sub
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.OnLoadMetaData(), Line: " & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        Call CDDXHelper.LogError("R/T Error #" & errNum & " " & errDesc, Err.source)

End Sub

Private Function V2DateOnCell(r As Excel.range) As String
10
        On Error GoTo OOPS

        Dim yyyy                        As Long
        Dim mm                          As Long
        Dim dd                          As Long
        Dim d                           As String
        Dim f                           As String

20      f = vbNullString 'Replace(r.NumberFormat, "mmm", "MMM")
30      d = r.value

40      V2DateOnCell = IIf(CDDXLib.DefaultZEWSProxy(BSConsts.DDX_PID).CDate(d, f, vbNullString, yyyy, mm, dd) <> vbNullString, d, DateSerial(yyyy, mm, dd))

50      On Error GoTo 0
60      Exit Function
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.V2DateOnCell(), Line: " & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        Call CDDXHelper.LogError("R/T Error #" & errNum & " " & errDesc, Err.source)

End Function

Private Function V2Date(sheet As Excel.Worksheet) As Variant

10      On Error GoTo OOPS

        Dim r                           As Excel.range

20      If CSheet.ZESheetType(sheet) = ZESHEET_FUTURES Then
30          V2Date = V2DateFutures(sheet)

40          Exit Function
50      End If

60      Set r = V2ValueCell(sheet, "* Date:*", False)

70      If r Is Nothing Then Exit Function

80      If r.value = vbNullString Then Exit Function

90      V2Date = V2DateOnCell(r)

100     On Error GoTo 0
110     Exit Function
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.V2Data(), Line: " & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        Call CDDXHelper.LogError("R/T Error #" & errNum & " " & errDesc, Err.source)

End Function

Private Function V2DateFutures(sheet As Excel.Worksheet) As Variant
10
        On Error GoTo OOPS

        Dim r                           As Excel.range

20      Set r = V2ValueCell(sheet, "* Date:*", False)

30      If r Is Nothing Then Exit Function

40      If r.value = vbNullString Then
50          Set r = r.offset(, 1).Resize(1, 1)
60      End If

70      If r.value = vbNullString Then Exit Function
80      V2DateFutures = V2DateOnCell(r)

90      On Error GoTo 0
100     Exit Function
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.V2DateFutures(), Line: " & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        Call CDDXHelper.LogError("R/T Error #" & errNum & " " & errDesc, Err.source)

End Function

Private Function V2Table(sheet As Excel.Worksheet) As String
      'DDX-192
10      On Error GoTo OOPS

20      V2Table = CStr(GetUploadSheetItemValue(sheet, "*Target Table:*"))

30      On Error GoTo 0
40      Exit Function
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.V2Table(), Line: " & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        Call CDDXHelper.LogError("R/T Error #" & errNum & " " & errDesc, Err.source)

End Function

Private Function V2LoadMetadata(sheet As Excel.Worksheet) As Variant
      'DDX-192
10      On Error GoTo OOPS

20      V2LoadMetadata = GetUploadSheetItemValue(sheet, "*Load Metadata:*")

30      On Error GoTo 0
40      Exit Function
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.V2LoadMetadata(), Line: " & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        Call CDDXHelper.LogError("R/T Error #" & errNum & " " & errDesc, Err.source)

End Function

Private Function V2Namespace(sheet As Excel.Worksheet) As Variant
      'DDX-192
10      On Error GoTo OOPS

20      V2Namespace = GetUploadSheetItemValue(sheet, "*Name Space:*")

30      On Error GoTo 0
40      Exit Function
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.V2Namespace(), Line: " & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        Call CDDXHelper.LogError("R/T Error #" & errNum & " " & errDesc, Err.source)

End Function

Private Function V2Report(sheet As Excel.Worksheet) As Variant
      'DDX-192
10      On Error GoTo OOPS

20      V2Report = GetUploadSheetItemValue(sheet, "*Database Object:*")

30      If Len(V2Report) = 0 Then
40          V2Report = GetUploadSheetItemValue(sheet, "*ReportName:*", False)
50      End If

60      On Error GoTo 0
70      Exit Function
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.V2Report(), Line: " & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        Call CDDXHelper.LogError("R/T Error #" & errNum & " " & errDesc, Err.source)

End Function

Private Function V2FirstRow(sheet As Excel.Worksheet) As Long
      'DDX-192
10      On Error GoTo OOPS

20      V2FirstRow = GetUploadSheetItemValue(sheet, "*First Row of Data:*")

30      On Error GoTo 0
40      Exit Function
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.V2FirstRow(), Line: " & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        Call CDDXHelper.LogError("R/T Error #" & errNum & " " & errDesc, Err.source)

End Function

Public Function V2LastRow(sheet As Excel.Worksheet) As Long
      'DDX-192
10      On Error GoTo OOPS

20      V2LastRow = GetUploadSheetItemValue(sheet, "*Last Row of Data:*")

30      On Error GoTo 0
40      Exit Function
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.V2LastRow(), Line: " & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        Call CDDXHelper.LogError("R/T Error #" & errNum & " " & errDesc, Err.source)

End Function

Private Function V2AttributeRows(sheet As Excel.Worksheet) As Long
10
        On Error GoTo OOPS

        Dim r                           As Excel.range
        Dim txt                         As String

20      If CSheet.ZESheetType(sheet) <> ZESHEET_FUTURES Then

30          txt = GetUploadSheetItemValue(sheet, "*Attribute Rows:*")
40      Else
50          Set r = V2ValueCell(sheet, "*Attribute Rows:*")

60          If Not r Is Nothing Then
70              txt = r.value
            End If
90      End If

100     If IsNumeric(txt) Then
110         V2AttributeRows = CInt(txt)
120     Else
130         V2AttributeRows = -1
140     End If

150     On Error GoTo 0
160     Exit Function
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.V2AttributeRows(), Line: " & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        Call CDDXHelper.LogError("R/T Error #" & errNum & " " & errDesc, Err.source)

End Function

Public Function V2LastColumn(sheet As Excel.Worksheet) As Long
10
        On Error GoTo OOPS

        Dim r                           As Excel.range
        Dim numstr                      As String

20      Set r = V2ValueCell(sheet, "*Last Column of Data:*")

30      If r Is Nothing Then Exit Function

40      numstr = r.Cells(1, 1).value

50      If numstr = vbNullString Then Exit Function

60      If IsNumeric(numstr) Then
70          V2LastColumn = GetUploadSheetItemValue(sheet, "*Last Column of Data:*")

80          Exit Function
90      End If

100     V2LastColumn = Asc(left$(numstr, 1)) - Asc("A") + 1

110     If Len(numstr) > 1 Then
120         V2LastColumn = 26 * V2LastColumn
130         V2LastColumn = V2LastColumn + (Asc(right(numstr, 1)) - Asc("A") + 1)
140     End If

150     On Error GoTo 0
160     Exit Function
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.V2LastColumn(), Line: " & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        Call CDDXHelper.LogError("R/T Error #" & errNum & " " & errDesc, Err.source)

End Function

Private Function GetUploadSheetItemValue(sheet As Excel.Worksheet, pattern As String, Optional isShowErrorMessage As Boolean) As Variant

10      On Error GoTo OOPS

20      If Not V2ValueCell(sheet, pattern, isShowErrorMessage) Is Nothing Then
30          GetUploadSheetItemValue = V2ValueCell(sheet, pattern, isShowErrorMessage).value
40      End If

50      On Error GoTo 0
60      Exit Function
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.GetUploadSheetItemValue(), Line: " & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        Call CDDXHelper.LogError("R/T Error #" & errNum & " " & errDesc, Err.source)

End Function

Private Function V2ValueCell(sheet As Excel.Worksheet, pattern As String, Optional isShowErrorMessage As Boolean = True) As Variant
10
        On Error GoTo OOPS

        Dim c                           As Variant

20      Set V2ValueCell = Nothing

30      For Each c In [A1:M8]

40          If c.value Like pattern Then
50              Set V2ValueCell = c.offset(0, 1)

60              Exit Function
70          End If
80      Next c

90      If (isShowErrorMessage = True) Then
100         CDDXApp.StatusMessage = pattern & " not found."
110     End If

120     On Error GoTo 0
130     Exit Function
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.V2ValueCell(), Line: " & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        Call CDDXHelper.LogError("R/T Error #" & errNum & " " & errDesc, Err.source)

End Function

Private Function isCellPatternExist(pattern As String, errorMessage As String) As Boolean
10
        On Error GoTo OOPS

        Dim c                           As Variant

20      isCellPatternExist = False

30      For Each c In [A1:M8]

40          If c.value Like pattern Then

50              isCellPatternExist = True

60              Exit Function
70          End If
80      Next c

90      Call CDDXApp.DialogMessage(errorMessage, vbCritical)
100     CDDXApp.StatusMessage = pattern + " not found."

110     On Error GoTo 0
120     Exit Function
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.isCellPatternExist(), Line: " & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        Call CDDXHelper.LogError("R/T Error #" & errNum & " " & errDesc, Err.source)

End Function

Private Function validateV2CellTitle() As Boolean
10
        On Error GoTo OOPS

        Dim result                      As Boolean

20      result = isCellPatternExist("*Name Space:*", "Name space is not found")
'30     result = result And isCellPatternExist("*Database Object:*", "Database object is not found")
40      result = result And isCellPatternExist("*Target Table:*", "Target table is not found")
50      result = result And isCellPatternExist("*First Row of Data:*", "First Row of data is not found")
60      result = result And isCellPatternExist("*Last Row of Data:*", "Last row of data is not found")
70      result = result And isCellPatternExist("*Last Column of Data:*", "Last column of data is not found")
'80     result = result And isCellPatternExist("*Attribute Rows:*", "Attribute rows is not found")
90      result = result And isCellPatternExist("*Insert Records Only:*", "Insert Records only is not found")
100     result = result And isCellPatternExist("*Load Metadata:*", "Load metadata is not found")

110     If (IsSpotSheet(m_sheet) = False) Then
120         result = result And isCellPatternExist("* Date:*", "Forecast Date is not found")
130     End If

140     validateV2CellTitle = result

150     On Error GoTo 0
160     Exit Function
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.validateV2CellTitle(), Line: " & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        Call CDDXHelper.LogError("R/T Error #" & errNum & " " & errDesc, Err.source)

End Function

Private Function GetUploadSheetVersion(sheet As Excel.Worksheet) As Long
10
        On Error GoTo OOPS

        Dim ver                         As String

20      ver = Trim$(sheet.Cells(10, 2).value)

30      If ver = "Header Information" Then
40          GetUploadSheetVersion = 2
50      Else
60          GetUploadSheetVersion = 1
70      End If

80      On Error GoTo 0
90      Exit Function
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.GetUploadSheetVersion(), Line: " & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        Call CDDXHelper.LogError("R/T Error #" & errNum & " " & errDesc, Err.source)

End Function

Private Sub V2Status(sheet As Excel.Worksheet, status As String)
10
        On Error GoTo OOPS

        Dim s                           As Excel.Shape
        Dim b                           As Boolean

20      b = sheet.ProtectContents

30      If b Then Call CDDXUpload.UnProtectSheet(sheet)
          
40      Set s = GetResultTag(sheet)

50      If Not s Is Nothing Then
60          s.TextFrame.Characters.text = status
70      End If

80      If b Then Call CDDXUpload.ProtectSheet(sheet)

90      On Error GoTo 0
100     Exit Sub
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.V2Status(), Line: " & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        Call CDDXHelper.LogError("R/T Error #" & errNum & " " & errDesc, Err.source)

End Sub

Private Function GetResultTag(sheet As Excel.Worksheet) As Excel.Shape
10
        On Error GoTo OOPS

        Dim s                           As Excel.Shape
        Dim x
        Dim y
        Dim w
        Dim h

20      For Each s In sheet.Shapes

30          If s.AutoShapeType = msoShapeRectangle Then  'msoShapeFoldedCorner Then

40              If s.name = STATUS_TAG_NAME Then
50                  Set GetResultTag = s

60                  Exit Function
70              End If
80          End If
90      Next s

        With sheet.Cells(5, 1)
            x = .left + 3
            y = .top + 3
            w = 152.25
            h = 72
        End With

120     Set GetResultTag = sheet.Shapes.AddShape(msoShapeRectangle, x, y, w, h) ' 155, 81)

130     With GetResultTag
140         .name = STATUS_TAG_NAME
150         '.Fill.Transparency = 0.25
160         .Fill.Visible = msoTrue
170         .Fill.ForeColor.SchemeColor = 31 '34
180         .Fill.BackColor.SchemeColor = 39 '40
190         '.Fill.TwoColorGradient msoGradientHorizontal, 1
200         .TextFrame.Characters.Font.ColorIndex = 1
210         .TextFrame.Characters.Font.size = 10
220         '.TextFrame.VerticalOverflow = xlOartVerticalOverflowOverflow
230         '.TextFrame.HorizontalOverflow = xlOartHorizontalOverflowOverflow
'240        .Height = 81
250     End With

260     On Error GoTo 0
270     Exit Function
OOPS:
        Dim errDesc         As String, errNum       As Long
280     errDesc = "CDDXUpload.GetResultTag(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
290     errNum = Err.Number
        'your clean up codes here
300     Call Err.Raise(errNum, Err.source, errDesc)

End Function

Private Sub ShowMetadataResult(sheet As Excel.Worksheet, ByVal msg As String)
10
        On Error GoTo OOPS

        Dim s                           As Excel.Shape
        Dim b                           As Boolean
        Dim txt                         As String
        Dim ary()                       As String
        Dim p                           As Long

20      b = sheet.ProtectContents

30      If b Then Call CDDXUpload.UnProtectSheet(sheet)

40      Set s = GetResultTag(sheet)

50      If Not s Is Nothing Then
60          With s
70              txt = .TextFrame.Characters.text

                If txt <> vbNullString Then

                    ary = Split(txt, CarriageReturn)
                    txt = vbNullString

                    If UBound(ary) >= 2 Then

                        For p = 0 To 2
                            txt = txt & IIf(p = 0, vbNullString, CarriageReturn) & ary(p)
                        Next p
                    End If
                End If

                If msg <> vbNullString Then
                    txt = txt & IIf(txt = vbNullString, vbNullString, CarriageReturn) & "(MD " & IIf(StrComp(msg, "loaded", vbTextCompare) = 0, CStr(Now), msg) & ")"
                End If

110             .TextFrame.Characters.text = txt
120         End With
130     End If

140     If b Then Call CDDXUpload.ProtectSheet(sheet)

150     On Error GoTo 0
160     Exit Sub
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.ShowMetadatResult(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        'your clean up codes here
        Call Err.Raise(errNum, Err.source, errDesc)

End Sub

Public Sub V2SetAttributeRows(ByVal pid As String, sheet As Excel.Worksheet, ByVal aType As String)
10
        On Error GoTo OOPS

        Dim c                           As Variant
        Dim collist                     As String
        Dim k                           As Long
        Dim j                           As Long

20      If Not CDDXApp.IsPX(pid) Then Exit Sub

30      If IsNull(V2ValueCell(sheet, "*Attribute Rows:*")) Then Exit Sub

40      Set c = V2ValueCell(sheet, "*Attribute Rows:*")

50      If c Is Nothing Then Exit Sub

60      If (aType = ZESHEET_FUTURES) Then
70          j = 8
80      Else
90          j = 10
100     End If

110     collist = "N/A"

120     For k = 1 To j
130         collist = collist & "," & CStr(k)
140     Next k

150     With c.Validation
160         Call .Delete
170         Call .Add(xlValidateList, xlValidAlertStop, xlBetween, collist)
180     End With

190     c.value = "N/A"

200     On Error GoTo 0
210     Exit Sub
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.V2SetAttributeRows(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        'your clean up codes here
        Call Err.Raise(errNum, Err.source, errDesc)

End Sub

Public Sub V2SetLastDataColumn(ByVal pid As String, sheet As Excel.Worksheet, ByVal aType As String)
10
        On Error GoTo OOPS

        Dim nm                          As String
        Dim c                           As Variant

20      If Not CDDXApp.IsPX(pid) Then Exit Sub

30      nm = "*Last Column of Data:*"
40      Set c = V2ValueCell(sheet, nm)

50      If c Is Nothing Then Exit Sub

60      c.value = IIf(aType = ZESHEET_SPOT, "I", "K")

70      On Error GoTo 0
80      Exit Sub
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.V2SetLastDataColumn(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        'your clean up codes here
        Call Err.Raise(errNum, Err.source, errDesc)

End Sub

Public Sub V2SetDateFormat(ByVal pid As String, sheet As Excel.Worksheet, ByVal aType As String)
10
        On Error GoTo OOPS

        Dim c                           As Variant
        Dim fmt                         As String
        Dim adr                         As String
        Dim dsp                         As String

20      If Not CDDXApp.IsPX(pid) Then Exit Sub

30      Call CDDXDates.GetDateInfo(dsp, fmt)

40      Select Case aType
        Case ZESHEET_FORECAST, ZESHEET_SPOT:

50          adr = "C21:C70"
60      Case ZESHEET_FUTURES:

70          adr = "D21:D70"
80      Case Else:

90          Exit Sub
100     End Select

110     Call sheet.range(adr).Select
120     Selection.NumberFormat = fmt

130     If Not IsNull(V2ValueCell(sheet, "* Date:*", False)) Then

140         Set c = V2ValueCell(sheet, "* Date:*", False)

150         If Not (c Is Nothing) Then

160             c.value = CStr(DateSerial(year(Now), month(Now), day(Now)))
170             Call c.Select
180             c.NumberFormat = fmt
190         End If
200     End If

210     On Error GoTo 0
220     Exit Sub
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.V2SetDateFormat(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        'your clean up codes here
        Call Err.Raise(errNum, Err.source, errDesc)

End Sub

Public Property Get UserUploadTables() As String()

    UserUploadTables = CDDXLib.DefaultZEWSProxy(BSConsts.DDX_PID).RetrieveUploadTablesByUser(CDDXLogin.sid)
End Property

Private Function ConcatUserTables(aTables() As String) As String
10
        On Error GoTo OOPS

        Dim f                           As Variant
        Dim length                      As Long

20      ConcatUserTables = Join(aTables, ",")

30      If Len(ConcatUserTables) <= 255 Then Exit Function

40      ConcatUserTables = vbNullString

50      For Each f In aTables

60          length = Len(ConcatUserTables)

70          If length + Len(f) >= 255 Then Exit Function

80          If length > 0 Then ConcatUserTables = ConcatUserTables & ","

90          ConcatUserTables = ConcatUserTables & f
100     Next f

110     On Error GoTo 0
120     Exit Function
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.ConcatUserTables(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        'your clean up codes here
        Call Err.Raise(errNum, Err.source, errDesc)

End Function

Public Function GetAllUploadTables() As String()

10      On Error GoTo OOPS

20      GetAllUploadTables = CDDXLib.DefaultZEWSProxy(BSConsts.DDX_PID).retrieveUploadTableNameList(CDDXLogin.sid)

30      On Error GoTo 0
40      Exit Function
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.GetAllUploadTables(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        'your clean up codes here
        Call Err.Raise(errNum, Err.source, errDesc)

End Function

Public Function GetGrantedUsers(ByVal pid As String, ByVal aTable As String, ByVal orderByUserName As Boolean) As ZEWSProxy.userProfile()

10      On Error GoTo OOPS

20      If Not CDDXApp.IsPX(pid) Then Exit Function

30      GetGrantedUsers = CDDXLib.DefaultZEWSProxy(BSConsts.DDX_PID).retrieveGrantedUserListByUploadTable(CDDXLogin.sid, aTable, IIf(orderByUserName, 1, 0))

40      On Error GoTo 0
50      Exit Function
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.GetGrantedUsers(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        'your clean up codes here
        Call Err.Raise(errNum, Err.source, errDesc)

End Function

Public Sub CreateTableResource(ByVal tableName As String, ByRef returnedMsg As String)

10      On Error GoTo OOPS

20      returnedMsg = CDDXLib.DefaultZEWSProxy(BSConsts.DDX_PID).createUploadTableResource(CDDXLogin.sid, tableName)

30      On Error GoTo 0
40      Exit Sub
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.CreateTableResource(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        'your clean up codes here
        Call Err.Raise(errNum, Err.source, errDesc)

End Sub

Public Sub AssignTableResource(ByVal tableName As String, userNames() As String, ByRef returnedMsg As String)

10      On Error GoTo OOPS

20      returnedMsg = CDDXLib.DefaultZEWSProxy(BSConsts.DDX_PID).assignUploadTableResource(CDDXLogin.sid, tableName, userNames)

30      On Error GoTo 0
40      Exit Sub
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.AssignTableResource(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        'your clean up codes here
        Call Err.Raise(errNum, Err.source, errDesc)

End Sub

Public Sub RevokeTableResource(ByVal tableName As String, userNames() As String)

10      On Error GoTo OOPS

20      Call CDDXLib.DefaultZEWSProxy(BSConsts.DDX_PID).revokeUploadTableResource(CDDXLogin.sid, tableName, userNames)

30      On Error GoTo 0
40      Exit Sub
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.RevokeTableResource(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        'your clean up codes here
        Call Err.Raise(errNum, Err.source, errDesc)

End Sub

Public Sub SetUploadStatus(sheet As Excel.Worksheet, ByVal aStatus As String)

10      On Error GoTo OOPS

20      Call CSheet.WSSetProp(sheet, G_UPLOAD_STATUS, IIf(aStatus = vbNullString, " ", aStatus))

30      On Error GoTo 0
40      Exit Sub
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.SetUploadStatus(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        'your clean up codes here
        Call Err.Raise(errNum, Err.source, errDesc)

End Sub

Public Function GetUploadStatus(sheet As Excel.Worksheet) As String

10      On Error GoTo OOPS

20      GetUploadStatus = CSheet.WSGetProp(sheet, G_UPLOAD_STATUS)

30      On Error GoTo 0
40      Exit Function
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.GetUploadStatus(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        'your clean up codes here
        Call Err.Raise(errNum, Err.source, errDesc)

End Function

Public Sub SetUploadLastRun(sheet As Excel.Worksheet)

10      On Error GoTo OOPS

20      Call CSheet.WSSetProp(sheet, G_UPLOAD_LASTRUN, CStr(Now))

30      On Error GoTo 0
40      Exit Sub
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.SetUploadLastRun(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        'your clean up codes here
        Call Err.Raise(errNum, Err.source, errDesc)

End Sub

Public Function GetUploadLastRun(sheet As Excel.Worksheet) As Date

10      On Error GoTo OOPS

20      GetUploadLastRun = CDate(CSheet.WSGetProp(sheet, G_UPLOAD_LASTRUN))

30      On Error GoTo 0
40      Exit Function
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.GetUploadLastRun(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        'your clean up codes here
        Call Err.Raise(errNum, Err.source, errDesc)

End Function

Public Sub SetWriteDataResult(ByVal value As String)

10      On Error GoTo OOPS

20      m_writedata_result = value

30      On Error GoTo 0
40      Exit Sub
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.SetWriteDataResult(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        'your clean up codes here
        Call Err.Raise(errNum, Err.source, errDesc)

End Sub

Public Function GetWriteDataResult() As String()

10      On Error GoTo OOPS

20      GetWriteDataResult = Split(m_writedata_result, Chr$(&H2))

30      On Error GoTo 0
40      Exit Function
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.GetWriteDataResult(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        'your clean up codes here
        Call Err.Raise(errNum, Err.source, errDesc)

End Function

Public Function IsSpotSheet(sheet As Excel.Worksheet) As Boolean

10      On Error GoTo OOPS

20      IsSpotSheet = (CSheet.ZESheetType(sheet) = ZESHEET_SPOT)

30      On Error GoTo 0
40      Exit Function
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.IsSpotSheet(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        'your clean up codes here
        Call Err.Raise(errNum, Err.source, errDesc)

End Function

Public Function IsForecastSheet(sheet As Excel.Worksheet) As Boolean

10      On Error GoTo OOPS

20      IsForecastSheet = (CSheet.ZESheetType(sheet) = ZESHEET_FORECAST)

30      On Error GoTo 0
40      Exit Function
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.IsForecastSheet(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        'your clean up codes here
        Call Err.Raise(errNum, Err.source, errDesc)

End Function

Public Function IsFuturesSheet(sheet As Excel.Worksheet) As Boolean

10      On Error GoTo OOPS

20      IsFuturesSheet = (CSheet.ZESheetType(sheet) = ZESHEET_FUTURES)

30      On Error GoTo 0
40      Exit Function
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.IsFuturesSheet(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        'your clean up codes here
        Call Err.Raise(errNum, Err.source, errDesc)

End Function

Public Function V2GetStatus(sheet As Excel.Worksheet) As String
10
        On Error GoTo OOPS

        Dim s                           As Excel.Shape

20      For Each s In sheet.Shapes

30          If s.AutoShapeType = msoShapeFoldedCorner Then
40              V2GetStatus = s.TextFrame.Characters.text

50              Exit Function
60          End If
70      Next s

80      On Error GoTo 0
90      Exit Function
OOPS:
        Dim errDesc         As String, errNum       As Long
        errDesc = "CDDXUpload.V2GetStatus(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
        errNum = Err.Number
        'your clean up codes here
        Call Err.Raise(errNum, Err.source, errDesc)

End Function

Public Sub EnableGrouping(pid As String, Wb As Workbook)
 Dim sht As Worksheet
 
    On Error GoTo OOPS
    
    If Not CDDXApp.IsPX(pid) Then Exit Sub
    
    If Wb.Readonly Then Exit Sub
    
    Call CXLEvents.DisableEvents
    
    For Each sht In Wb.Worksheets
        If CDDXHelper.IsUploadSheet(sht) Then
            Call CDDXUpload.UnProtectSheet(sht)
            Call CDDXUpload.ProtectSheet(sht)
        End If
    Next
    
OOPS:
    If Err.Number <> 0 Then
        CDDXApp.StatusMessage = Err.Description
    End If
    
    Call CXLEvents.RestoreEvents
    Exit Sub
End Sub
Attribute VB_Name = "CDDXUtility"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public Function IsArrayEmpty(arrayObject As Variant) As Boolean
          Dim result As Boolean
10        On Error GoTo errorHandler

20        result = True
30        If (IsArray(arrayObject)) Then
40            If (Not IsEmpty(arrayObject)) Then
50                If (TypeName(arrayObject) = "String()") Then
60                    If (Len(Join(arrayObject, "")) > 0) Then
70                        result = False
80                    End If
90                Else
100                   On Error GoTo eh
110                   If (UBound(arrayObject) >= LBound(arrayObject)) Then
120                       result = False
130                   End If
140                   On Error GoTo 0
150               End If
160           End If
170       End If
180       IsArrayEmpty = result
190       Exit Function
eh:
200       On Error GoTo 0
210       IsArrayEmpty = True
220       Exit Function
errorHandler:
          Dim errorDescription As String, errorNumber As Long
230       errorDescription = "cddxutility.IsArrayEmpty(), Line:" & str(Erl()) + " " + vbCrLf + Err.Description
240       errorNumber = Err.Number
250       Err.Clear
260       Err.Raise errorNumber, , errorDescription
End Function

Public Function IsExcelReady() As Boolean
10        On Error GoTo errorHandler

20        If (CDDXApp.XLVersion < 2002 Or (CDDXApp.XLVersion >= 2002 And Application.Ready)) Then
30            IsExcelReady = True
40        Else
50            IsExcelReady = False
60        End If

70        On Error GoTo 0
80        Exit Function
errorHandler:
          Dim errorDescription As String, errorNumber As Long
90        errorDescription = "cddxutility.IsExcelReady(), Line:" & str(Erl()) + " " + vbCrLf + Err.Description
100       errorNumber = Err.Number
110       Err.Clear
120       Err.Raise errorNumber, , errorDescription
End Function

Public Function SetScreenUpdating(updating As Boolean) As Boolean
10        On Error GoTo errorHandler

20        If (CDDXUtility.IsExcelReady) Then
30            Application.ScreenUpdating = updating
40        End If

50        On Error GoTo 0
60        Exit Function
errorHandler:
          Dim errorDescription As String, errorNumber As Long
70        errorDescription = "cddxutility.SetScreenUpdating(), Line:" & str(Erl()) + " " + vbCrLf + Err.Description
80        errorNumber = Err.Number
90        Err.Clear
100       Err.Raise errorNumber, , errorDescription
End Function

Public Sub DeleteTempFilesByTaskId(taskID As String)
 Dim f As String
 Dim p As String
 
    On Error GoTo OOPS

    If (Len(taskID) = 0) Then Exit Sub
    
    p = CDDXLib.DefaultZEWSProxy(DDX_PID).GetDDXTempFolder()
    f = Dir(p + "*" + taskID + "*", vbNormal)
    
    Do While Len(f) > 0
        Kill p + f
        f = Dir()
    Loop
    
OOPS:
    If Err.Number <> 0 Then
        Call CDDXHelper.LogError(Err.Description, Err.source)
    End If
    Exit Sub
End Sub

Public Function IsResultReadyForTaskId(taskID As String) As Boolean
    IsResultReadyForTaskId = True
'          Dim result As Boolean
'10        On Error GoTo errorHandler
'
'20        If (Len(taskID) > 0) Then
'50            result = DDFiles.IsResultReadyForTaskId(taskID)
'60        End If
'70        IsResultReadyForTaskId = result
'
'80        On Error GoTo 0
'90        Exit Function
'errorHandler:
'          Dim errorDescription As String, errorNumber As Long
'100       errorDescription = "cddxutility.IsResultReadyForTaskId(), Line:" & str(Erl()) + " " + vbCrLf + Err.Description
'110       errorNumber = Err.Number
'120       Err.Clear
'130       Err.Raise errorNumber, , errorDescription
End Function

Public Function SetupEntity(ByVal pid As String, entity As ZEWSProxy.DataDirectEntity) As Boolean
    If Not CDDXApp.IsPX(pid) Then Exit Function

    If (IsProfileDataEntity(DDX_PID, entity)) Then
        If (setupProfileDataEntity(entity)) = False Then Exit Function
        
    ElseIf (IsReportDataEntity(DDX_PID, entity)) Then
        If (setupReportDataEntity(entity)) = False Then Exit Function
        
    ElseIf (IsDCurveDataEntity(DDX_PID, entity)) Then
        If (setupDCurveDataEntity(entity)) = False Then Exit Function
           
#If SMARTMAT_USE Then
    ElseIf (IsSmartMartDataEntity(DDX_PID, entity)) Then
        If (SetupSmartMartDataEntity(entity)) = False Then Exit Function
#End If
    End If
    
    If (Len(entity.ExcelRangeName) = 0) Then entity.ExcelRangeName = entity.GenerateExcelRangeName
    SetupEntity = True
End Function

Private Function setupProfileDataEntity(entity As ZEWSProxy.ProfileDataEntity) As Boolean
    entity.EntityObject.root = entity.ProfileName
          
    With entity.EntityObject
        Select Case .entityOption.DateInputOption

            Case ZEWSProxy.DateInputOption.DateInputOption_QuickDate:
                Dim sDate As String
                Dim eDate As String
                    Call CDDXDates.GetDynaDates(.entityOption.SelectedQuickDate, sDate, eDate, entity.shiftEffectiveDate)
                    .startDate = CDDXDates.CDateSafe(sDate)
                    .enddate = CDDXDates.CDateSafe(eDate)
        End Select
    End With

    setupProfileDataEntity = True
End Function

Private Function setupReportDataEntity(entity As ZEWSProxy.ReportDataEntity) As Boolean
    entity.EntityObject.root = entity.DataReportLabel + " " + Join(entity.ObservationLabels, "_")
    
'    If ReportData.EntityObject.Caption = vbNullString Then
'        If ReportData.EntityObject.Moniker <> vbNullString Then
'                ReportData.EntityObject.Caption = ReportData.EntityObject.Moniker
'        End If
'    End If
'    If ReportData.EntityObject.Caption = vbNullString Then
'        ReportData.EntityObject.Caption = ReportData.DataReportLabel + Space(2) + "[ " + ReportData.DataSourceLabel + " ]"
'    End If
           
    entity.EntityObject.dateOrder = entity.EntityObject.entityOption.InputDateOrder
    With entity.EntityObject
        Select Case .entityOption.DateInputOption
            Case ZEWSProxy.DateInputOption.DateInputOption_DirectInput
                .startDate = .entityOption.InputStartDate
                .enddate = .entityOption.InputEndDate
            Case ZEWSProxy.DateInputOption.DateInputOption_QuickDate
                Dim sDate As String
                Dim eDate As String
                Call CDDXDates.GetDynaDates(.entityOption.SelectedQuickDate, sDate, eDate, vbNullString)
                .startDate = CDDXDates.CDateSafe(sDate)
                .enddate = CDDXDates.CDateSafe(eDate)
        End Select
    End With
    
    entity.EntityObject.entityOption.DataPrecision = CDDXHelper.GetZEMAPrecisionPref(DDX_PID)
    setupReportDataEntity = True
End Function

Private Function setupDCurveDataEntity(DCurveData As ZEWSProxy.DCurveDataEntity) As Boolean
    DCurveData.EntityObject.root = "CurveData"
          
    With DCurveData.EntityObject
        Select Case .entityOption.DateInputOption
            Case ZEWSProxy.DateInputOption.DateInputOption_QuickDate:
                Dim sDate As String
                Dim eDate As String
                    Call CDDXDates.GetDynaDates(.entityOption.SelectedQuickDate, sDate, eDate, vbNullString)
                    .startDate = CDDXDates.CDateSafe(sDate)
                    .enddate = CDDXDates.CDateSafe(eDate)
            End Select
    End With

    setupDCurveDataEntity = True
End Function

#If SMARTMAT_USE Then
Private Function SetupSmartMartDataEntity(entity As ZEWSProxy.SmartMartDataEntity) As Boolean
 Dim sDate As String
 Dim eDate As String

    entity.EntityObject.dateOrder = entity.EntityObject.entityOption.InputDateOrder
    With entity.EntityObject
        Select Case .entityOption.DateInputOption
            Case ZEWSProxy.DateInputOption.DateInputOption_DirectInput
                .startDate = .entityOption.InputStartDate
                .enddate = .entityOption.InputEndDate
                
            Case ZEWSProxy.DateInputOption.DateInputOption_QuickDate
                Call CDDXDates.GetDynaDates(.entityOption.SelectedQuickDate, sDate, eDate, vbNullString)
                .startDate = CDDXDates.CDateSafe(sDate)
                .enddate = CDDXDates.CDateSafe(eDate)
        End Select
    End With
    entity.EntityObject.entityOption.DataPrecision = CDDXHelper.GetZEMAPrecisionPref(DDX_PID)
'    entity.EntityObject.Caption = entity.SmartMartLabel + " : " + entity.SmartMartModelLabel
    
    SetupSmartMartDataEntity = True
End Function
#End If

Public Function IsProfileDataEntity(pid As String, entity As ZEWSProxy.DataDirectEntity) As Boolean
    If Not CDDXApp.IsPX(pid) Then Exit Function
    If (entity Is Nothing) Then Exit Function
    
    If (StrComp(TypeName(entity), "ProfileDataEntity", vbTextCompare) = 0) Then IsProfileDataEntity = True
End Function

Public Function IsReportDataEntity(pid As String, entity As ZEWSProxy.DataDirectEntity) As Boolean
    If Not CDDXApp.IsPX(pid) Then Exit Function
    If (entity Is Nothing) Then Exit Function
    
    If (StrComp(TypeName(entity), "ReportDataEntity", vbTextCompare) = 0) Then IsReportDataEntity = True
End Function

Public Function IsDCurveDataEntity(pid As String, entity As ZEWSProxy.DataDirectEntity) As Boolean
    If Not CDDXApp.IsPX(pid) Then Exit Function
    If (entity Is Nothing) Then Exit Function
    
    If (StrComp(TypeName(entity), "DCurveDataEntity", vbTextCompare) = 0) Then IsDCurveDataEntity = True
End Function

#If SMARTMAT_USE Then
Public Function IsSmartMartDataEntity(pid As String, entity As ZEWSProxy.DataDirectEntity) As Boolean
    On Error GoTo OOPS
          
    If Not CDDXApp.IsPX(pid) Then Exit Function
    If Not (entity Is Nothing) Then
        IsSmartMartDataEntity = (StrComp(TypeName(entity), "SmartMartDataEntity", vbTextCompare) = 0)
    End If
    
OOPS:
    On Error GoTo 0
    Exit Function
End Function
#End If

Public Function GetObjectNameByPoint(sheetId As String, ByVal cellTop As Long, ByVal cellLeft As Long) As String
          Dim sht As Worksheet
          Dim qt As QueryTable
       
10        On Error GoTo errorHandler

20        Set sht = GetWorkSheetBySheetId(sheetId)
30        If sht Is Nothing Then Exit Function

40        Set qt = GetQueryTableByPoint(sht, cellTop, cellLeft)
50        If Not qt Is Nothing Then
60            GetObjectNameByPoint = qt.name
70            Exit Function
80        End If
          
          Dim lstobj As ListObject
       
90        Set lstobj = GetTableObjectByPoint(sht, cellTop, cellLeft)
100       If Not lstobj Is Nothing Then
110           GetObjectNameByPoint = lstobj.name
120           Exit Function
130       End If

140       On Error GoTo 0
150       Exit Function
errorHandler:
          Dim errorDescription As String, errorNumber As Long
160       errorDescription = "CDDXUtility.GetObjectNameByPoint(), Line:" & str(Erl()) + " " + vbCrLf + Err.Description
170       errorNumber = Err.Number
          'your clean up codes here
180       Err.Raise errorNumber, , errorDescription
End Function

Private Function GetQTRange(qt As QueryTable) As range
10        On Error GoTo errorHandler

20        Set GetQTRange = qt.resultRange

30        On Error GoTo 0
40        Exit Function
errorHandler:
          Dim errorDescription As String, errorNumber As Long
50        errorDescription = "CDDXUtility.GetQTRange(), Line:" & str(Erl()) + " " + vbCrLf + Err.Description
60        errorNumber = Err.Number
          'your clean up codes here
70        Err.Raise errorNumber, , errorDescription
End Function

Private Function GetQueryTableByPoint(sht As Worksheet, ByVal cellTop As Long, ByVal cellLeft As Long) As QueryTable
          Dim qt As QueryTable
          Dim rgn As range
       
10        On Error GoTo errorHandler

20        For Each qt In sht.QueryTables
30            Set rgn = GetQTRange(qt)
40            If Not rgn Is Nothing Then
50                With rgn
60                    If cellTop >= .row And cellTop < .row + .rows.count And cellLeft >= .column And cellLeft < .column + .Columns.count Then
70                       Set GetQueryTableByPoint = qt
80                       Exit Function
90                    End If
100               End With
110           End If
120       Next

130       On Error GoTo 0
140       Exit Function
errorHandler:
          Dim errorDescription As String, errorNumber As Long
150       errorDescription = "CDDXUtility.GetQueryTableByPoint(), Line:" & str(Erl()) + " " + vbCrLf + Err.Description
160       errorNumber = Err.Number
          'your clean up codes here
170       Err.Raise errorNumber, , errorDescription
End Function

Private Function GetTableObjectByPoint(sht As Worksheet, ByVal cellTop As Long, ByVal cellLeft As Long) As ListObject
          Dim tableObject As ListObject
       
10        On Error GoTo errorHandler

20        For Each tableObject In sht.ListObjects
30            With tableObject.range
40                If cellTop >= .row And cellTop < .row + .rows.count And cellLeft >= .column And cellLeft < .column + .Columns.count Then
50                   Set GetTableObjectByPoint = tableObject
60                   Exit Function
70                End If
80            End With
90        Next

100       On Error GoTo 0
110       Exit Function
errorHandler:
          Dim errorDescription As String, errorNumber As Long
120       errorDescription = "CDDXUtility.GetTableObjectByPoint(), Line:" & str(Erl()) + " " + vbCrLf + Err.Description
130       errorNumber = Err.Number
          'your clean up codes here
140       Err.Raise errorNumber, , errorDescription
End Function

Public Function GetRange(ByVal pid As String, entity As ZEWSProxy.DataDirectEntity) As range
 Dim nm As String

    With entity
        Set GetRange = CEntityHelper.GetEntityRangeFromCache(entity)
        If Not GetRange Is Nothing Then Exit Function

        Set GetRange = GetRangeByRangeName(.sheetId, .ExcelRangeName)
        If Not GetRange Is Nothing Then
            Call CEntityHelper.AddOrUpdateEntityRangeCache(entity, GetRange)
            Exit Function
        End If
              
        If .RangeTop > 0 And .RangeLeft > 0 Then
            nm = GetObjectNameByPoint(.sheetId, .RangeTop, .RangeLeft)
            Set GetRange = GetRangeByRangeName(.sheetId, nm)
            If Not GetRange Is Nothing Then
                Call CEntityHelper.AddOrUpdateEntityRangeCache(entity, GetRange)
            End If
        End If
    End With
End Function

Public Function GetRangeByRangeName(sheetId As String, rangeName As String) As range
 Dim excelName As name
 Dim tableObject As ListObject

    Set excelName = GetExcelNameByRangeName(sheetId, rangeName)
    If Not excelName Is Nothing Then
        Set GetRangeByRangeName = GetExcelNameResultRange(excelName)
        Exit Function
    End If

    Set tableObject = GetListObjectBysheetId(sheetId, rangeName)
    If Not tableObject Is Nothing Then
        Set GetRangeByRangeName = tableObject.range
        Exit Function
    End If
End Function

Public Function GetExcelNameFromSheet(sheet As Worksheet, rangeName As String) As name
 Dim excelName As name
 
    If sheet Is Nothing Then Exit Function
              
    For Each excelName In sheet.Names
        If CDDXHelper.CompareRangeNames(excelName.name, rangeName) Then
            Set GetExcelNameFromSheet = excelName
            Exit Function
        End If
    Next
End Function

Public Function GetExcelNameByRangeName(sheetId As String, rangeName As String) As name
 Dim sht As Worksheet
 
    On Error Resume Next
    
    Set sht = GetWorkSheetBySheetId(sheetId)
    If Not sht Is Nothing Then
        Set GetExcelNameByRangeName = sht.Parent.Names(rangeName)
        
        If GetExcelNameByRangeName Is Nothing Then
            Set GetExcelNameByRangeName = sht.Parent.Names("'" + sht.name + "'!" + rangeName)
        End If
    End If
    
    Err.Clear
    
    On Error GoTo 0
    Exit Function
End Function

Public Function GetListObjectBysheetId(sheetId As String, rangeName As String) As ListObject
 Dim sheet As Worksheet
 Dim tableObject As ListObject
              
    Set sheet = GetWorkSheetBySheetId(sheetId)
    If sheet Is Nothing Then Exit Function
    
    For Each tableObject In sheet.ListObjects
        If CDDXHelper.CompareRangeNames(tableObject.name, rangeName) Then
            Set GetListObjectBysheetId = tableObject
            Exit For
        End If
    Next
End Function

Public Function GetWorkSheetBySheetId(sheetId As String) As Worksheet
Dim Wb As Workbook
Dim sheet As Worksheet
Dim isFound As Boolean
          
    If (Len(sheetId) = 0) Then Exit Function
    
    For Each Wb In Application.Workbooks
        isFound = False
        For Each sheet In Wb.Worksheets
            If (StrComp(CDDXHelper.ZESheetID(BSConsts.DDX_PID, sheet), sheetId, vbTextCompare) = 0) Then
                isFound = True
                Set GetWorkSheetBySheetId = sheet
                Exit For
            End If
        Next
        If (isFound) Then Exit For
    Next
End Function

Public Function GetEntityByPosition(pid As String, targetRange As range) As ZEWSProxy.DataDirectEntity
 Dim all As ZEWSProxy.DataDirectEntities
 Dim entities() As ZEWSProxy.DataDirectEntity
 Dim entity As ZEWSProxy.DataDirectEntity
 Dim rgn As range
 Dim tmp As Variant
     
    If Not CDDXApp.IsPX(pid) Then Exit Function
    
    Set all = CDDXEntity.LiveEntities(DDX_PID)
    If all Is Nothing Then Exit Function
    
    If all.GetCount() <= 0 Then Exit Function
    entities = all.GetEntities()
    
    For Each tmp In entities
        Set entity = tmp
        Set rgn = GetRange(DDX_PID, entity)
        If IsRangeIntersect(rgn, targetRange) Then
            Set GetEntityByPosition = entity
        End If
    Next
End Function

Public Function GetRangeNameByPosition(targetRange As range) As String
          Dim excelName As name
10        On Error GoTo errorHandler

20        If targetRange Is Nothing Then Exit Function
          
30        Set excelName = GetExcelNameByPosition(targetRange)
40        If Not excelName Is Nothing Then
50            GetRangeNameByPosition = excelName.name
60            Exit Function
70        End If
          
              Dim tableObject As ListObject
80            Set tableObject = GetListObjectByPosition(targetRange)
90            If Not tableObject Is Nothing Then
100               GetRangeNameByPosition = tableObject.name
110               Exit Function
120           End If
130       GetRangeNameByPosition = vbNullString

140       On Error GoTo 0
150       Exit Function
errorHandler:
          Dim errorDescription As String, errorNumber As Long
160       errorDescription = "cddxutility.GetRangeNameByPosition(), Line:" & str(Erl()) + " " + vbCrLf + Err.Description
170       errorNumber = Err.Number
180       Err.Clear
190       Err.Raise errorNumber, , errorDescription
End Function

Public Function GetExcelNameByPosition(targetRange As range) As name
 Dim excelName As name

    For Each excelName In targetRange.Worksheet.Parent.Names
        If IsRangeIntersect(targetRange.Cells(1, 1), GetExcelNameResultRange(excelName)) Then
            Set GetExcelNameByPosition = excelName
            Exit Function
        End If
    Next
End Function

Public Function GetListObjectByPosition(targetRange As range) As ListObject
 Dim result As ListObject
 Dim tableObject As ListObject

    For Each tableObject In targetRange.Worksheet.ListObjects
        If (IsRangeIntersect(targetRange.Cells(1, 1), tableObject.range)) Then
            Set result = tableObject
            Exit For
        End If
    Next
              
    Set GetListObjectByPosition = result
End Function

Public Function IsRangeIntersect(sourceRange As range, targetRange As range) As Boolean
    If sourceRange Is Nothing Then Exit Function
    If targetRange Is Nothing Then Exit Function

    If (StrComp(sourceRange.Worksheet.Parent.name, targetRange.Worksheet.Parent.name, vbTextCompare) = 0) Then
        If (StrComp(sourceRange.Worksheet.name, targetRange.Worksheet.name, vbTextCompare) = 0) Then
            IsRangeIntersect = Not (Application.Intersect(sourceRange, targetRange) Is Nothing)
        End If
    End If
End Function

Public Function GetDataFileName(taskID) As String
    GetDataFileName = CDDXLib.DefaultZEWSProxy(DDX_PID).GetDDXTempFolder() + taskID + ".csv"
End Function

Public Function RemoveEmptyRangeEntities(pid As String, entities As ZEWSProxy.DataDirectEntities) As ZEWSProxy.DataDirectEntities
          Dim item As Variant
          Dim targetRange As range
          Dim tmp As ZEWSProxy.DataDirectEntity
10        On Error GoTo errorHandler
          
20        If Not CDDXApp.IsPX(pid) Then Exit Function
30        For Each item In entities.GetEntities
40            Set tmp = item
50            Set targetRange = GetRange(BSConsts.DDX_PID, tmp)
60            If (targetRange Is Nothing) Then
70                Call entities.DeleteByTaskId(item.taskID)
80            End If
90        Next
100       Set RemoveEmptyRangeEntities = entities

110       On Error GoTo 0
120       Exit Function
errorHandler:
          Dim errorDescription As String, errorNumber As Long
130       errorDescription = "cddxutility.RemoveEmptyRangeEntities(), Line:" & str(Erl()) + " " + vbCrLf + Err.Description
140       errorNumber = Err.Number
150       Err.Clear
160       Err.Raise errorNumber, , errorDescription
End Function

Public Function GetExcelNameResultRange(excelName As name) As range
10        On Error GoTo errorHandler
          
20        Set GetExcelNameResultRange = Nothing
30        If Not excelName Is Nothing Then
40            Set GetExcelNameResultRange = excelName.RefersToRange
50        End If

60        On Error GoTo 0
70        Exit Function
errorHandler:
          'ignore the error explicitly
80        Set GetExcelNameResultRange = Nothing
End Function

Public Sub ShowRefreshingComment(pid As String, entity As ZEWSProxy.DataDirectEntity, Optional refreshingCommentString As String = "Refreshing ...", Optional isAtLastRow As Boolean = False)
          Dim range As range
10        On Error GoTo errorHandler
          
20        If Not CDDXApp.IsPX(pid) Then Exit Sub
30        Set range = GetRange(BSConsts.DDX_PID, entity)
40        If Not range Is Nothing Then
              Dim targetRange As range, rowIndex As Long
50            rowIndex = 1
60            If isAtLastRow Then rowIndex = range.rows.count
'70            If (range.Columns.count = 1) Then
80                Set targetRange = range.Cells(rowIndex, 1)
'90            Else
'100               Set targetRange = range.Cells(rowIndex, 2)
'110           End If
              Dim refreshingComment As Comment
              
120           Set refreshingComment = targetRange.Comment
130           If refreshingComment Is Nothing Then
140               Set refreshingComment = targetRange.AddComment
150               refreshingComment.Shape.TextFrame.AutoSize = True
160           End If
            refreshingComment.Shape.TextFrame.Characters.Font.ColorIndex = 5
            
170           With refreshingComment.Shape.Fill
180               .Visible = msoTrue
190               .ForeColor.RGB = RGB(220, 220, 220)
200               .OneColorGradient msoGradientDiagonalUp, 1, 0.4
210           End With
220           refreshingComment.Visible = True
230           If (CDDXUtility.IsExcelReady) Then
240               Call refreshingComment.text(refreshingCommentString)
250           End If
260       End If

270       On Error GoTo 0
280       Exit Sub
errorHandler:
          'ignore the error explicitly
290       Call CDDXHelper.LogError(Err.Description, "CDDXUtility.ShowRefreshingComment", False)
End Sub

Public Function RangeExists(ByVal pid As String, entity As ZEWSProxy.DataDirectEntity) As Boolean
10        On Error GoTo errorHandler

20        If Not CDDXApp.IsPX(pid) Then Exit Function
30         RangeExists = (Not GetRange(pid, entity) Is Nothing)

40        On Error GoTo 0
50        Exit Function
errorHandler:
          Dim errorDescription As String, errorNumber As Long
60        errorDescription = "CDDXUtility.RangeExists(), Line:" & str(Erl()) + " " + vbCrLf + Err.Description
70        errorNumber = Err.Number
          'your clean up codes here
80        Err.Raise errorNumber, , errorDescription
End Function

Public Function SaveToFilePivoted(pid As String, entity As ZEWSProxy.DataDirectEntity, entityRange As range, Optional targetFileName As String) As Boolean
    If Not CDDXApp.IsPX(pid) Then Exit Function
    
10        On Error GoTo errorHandler

20        If (entity Is Nothing) Then Exit Function
30        If (entityRange Is Nothing) Then Exit Function
          Dim buff As String, cellValue As String, targetRange As range, columnItem As Variant, cellItem As Variant
          Dim filename As String, fileNumber As Integer, i As Long, j As Long

40        If (Len(targetFileName) > 0) Then
50            filename = targetFileName
60        Else
70            filename = GetDataFileName(entity.taskID)
80        End If
90        Call CDDXHelper.DeleteFile(filename)
100       Err.Clear
110       fileNumber = FreeFile()
120       Open (filename) For Binary Access Write As #fileNumber
130       If (Err.Number <> 0) Then Exit Function

140       If (entity.executeResult.CaptionRowsCount > 0) Then
150           buff = ReplaceStringForSaveToFile(entityRange.Cells(1, 1).value)
160           Set targetRange = entityRange.offset(entity.executeResult.CaptionRowsCount).Resize(entityRange.rows.count - entity.executeResult.CaptionRowsCount, entityRange.Columns.count)
170           For i = 2 To targetRange.rows.count
180               buff = buff + ","
190           Next
200           Put #fileNumber, , buff
210           Put #fileNumber, , vbCrLf
220       Else
230           Set targetRange = entityRange
240       End If

250       i = 0
260       For Each columnItem In targetRange.Columns
270           If (i > 0) Then
280               Put #fileNumber, , vbCrLf
290           End If
300           i = i + 1
310           buff = vbNullString
320           j = 0
330           For Each cellItem In columnItem.Value2
340               If j > 0 Then buff = buff + ","
350               j = j + 1
'360               cellValue = cellItem.value
'370               If isInEntityResultDateFormats(entity, cellItem.NumberFormat) = True Then
'380                   cellValue = CStr(cellItem.Value2)
'390                   If (IsNumeric(cellValue) = False) Then
'400                       If (IsDateValue(cellValue)) Then
'410                           cellValue = CStr(CDbl(cddxdates.CDateSafe(cellValue, cellItem.NumberFormat)))
'420                       End If
'430                   End If
'440               End If
'450               buff = buff + ReplaceStringForSaveToFile(cellValue)
                buff = buff + ReplaceStringForSaveToFile(CStr(cellItem))
460           Next

470           Put #fileNumber, , buff
480       Next

490       Close #fileNumber
500       SaveToFilePivoted = True

510       On Error GoTo 0
520       Exit Function
errorHandler:
          Dim errorDescription As String, errorNumber As Long
530       errorDescription = "cddxutility.SaveToFilePivoted(), Line:" & str(Erl()) + " " + vbCrLf + Err.Description
540       errorNumber = Err.Number
550       Err.Clear
560       Err.Raise errorNumber, , errorDescription
End Function

Private Function ReplaceStringForSaveToFile(value As String) As String
10        On Error GoTo errorHandler

20        value = Replace(value, vbCrLf, LF_ENCODE)
30        value = Replace(value, vbLf, LF_ENCODE)
40        value = Replace(value, """", """""")
50        ReplaceStringForSaveToFile = """" + value + """"

60        On Error GoTo 0
70        Exit Function
errorHandler:
          Dim errorDescription As String, errorNumber As Long
80        errorDescription = "cddxutility.ReplaceStringForSaveToFile(), Line:" & str(Erl()) + " " + vbCrLf + Err.Description
90        errorNumber = Err.Number
100       Err.Clear
110       Err.Raise errorNumber, , errorDescription
End Function

Public Function CopyRange(pid As String, sourceRange As range, targetRange As range, pasteType As XlPasteType, Optional isAutoFit As Boolean = True) As range
    If Not CDDXApp.IsPX(pid) Then Exit Function
        
    If sourceRange Is Nothing Then Exit Function
    If targetRange Is Nothing Then Exit Function
          
    Call sourceRange.Copy(targetRange.Areas(1).Cells(1, 1))
    'targetRange.Areas(1).Cells(1, 1).PasteSpecial Paste:=pasteType, operation:=xlPasteSpecialOperationNone, skipblanks:=False

    Set CopyRange = targetRange.Resize(sourceRange.rows.count, sourceRange.Columns.count)
    If Not isAutoFit Then Exit Function
    
    Call CEntityHelper.AdjustColumnWidths(True, CopyRange)
    Call CEntityHelper.AdjustRowHeights(Nothing, targetRange)
End Function

Public Function ColumnLetterToLong(columnLetter As String) As Long
 Dim i As Long
 Dim result As Long
 Dim letters As String
 Dim c As Long
 
    letters = UCase(Trim(Trim(columnLetter)))
    If Len(letters) > 3 Then Err.Raise vbObjectError, "ColumnLetterToLong", "Invalid length of column letters"
    
    For i = Len(letters) To 1 Step -1
        c = Asc(Mid(letters, i, 1))
        If c < Asc("A") Or c > Asc("Z") Then Err.Raise vbObjectError, "ColumnLetterToLong", "Invalid column letter"
        
        result = result + ((c - 64) * (26 ^ (Len(letters) - i)))
    Next
    ColumnLetterToLong = result
End Function

Public Function IntegerToColmnLetter(ByVal columnIndex As Long) As String
    If columnIndex < 27 Then
        IntegerToColmnLetter = Chr(64 + columnIndex)
    Else
        IntegerToColmnLetter = IntegerToColmnLetter((columnIndex - 1) / 26) & IntegerToColmnLetter((columnIndex - 1) Mod 26 + 1)
    End If
End Function

Public Function subtractRange(ByVal pid As String, originalRange As range, subtractedRange As range) As range
10        On Error GoTo errorHandler
          
20        If Not CDDXApp.IsPX(pid) Then Exit Function
30        If originalRange Is Nothing Then Exit Function
40        If subtractedRange Is Nothing Then Exit Function
          Dim result As range, cellItem As range
          If originalRange.Worksheet.name <> subtractedRange.Worksheet.name Then
                Set result = originalRange
                Set subtractRange = result
                Exit Function
          End If
          
50        For Each cellItem In originalRange
60            If Application.Intersect(cellItem, subtractedRange) Is Nothing Then
70                If result Is Nothing Then
80                    Set result = cellItem
90                Else
100                   Set result = Application.Union(result, cellItem)
110               End If
120           End If
130       Next
140       Set subtractRange = result

150       On Error GoTo 0
160       Exit Function
errorHandler:
          Dim errorDescription As String, errorNumber As Long
170       errorDescription = "CDDXUtility.SubtractRange(), Line:" & str(Erl()) + " " + vbCrLf + Err.Description
180       errorNumber = Err.Number
          'your clean up codes here
190       Err.Raise errorNumber, , errorDescription
End Function

Public Function GetTempFile(Optional ext As String = ".txt") As String
    GetTempFile = Environ("TMP") + "\" + format(Now, "MMMddhhmmss") + "." + CStr(CLng(Int((1000 * Rnd()) + 1))) + ext
End Function

Public Function EncodeControlTip(tipText As String) As String
    EncodeControlTip = Replace(tipText, "&", "&&")
End Function

Private Sub Class_Terminate()
'    If Not m_files Is Nothing Then
'        Set m_files = Nothing
'    End If
End Sub
Attribute VB_Name = "CDDXVar"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public Function SetVar(name As String, value As String) As Boolean
 Dim macro As String
 
    On Local Error GoTo OOPS
    
    If value <> vbNullString Then
        macro = "SET.NAME(""" + name + """, """ + value + """)"
    Else
        macro = "SET.NAME(""" + name + """)"
    End If
    
    Call Application.ExecuteExcel4Macro(macro)
    
OOPS:
    SetVar = IIf(Err.Number = 0, True, False)
    
    On Local Error GoTo 0
    Exit Function
End Function

Public Function GetVar(name As String) As String
    On Local Error GoTo OOPS
    
    GetVar = Application.ExecuteExcel4Macro(name)
    
OOPS:
    If Err.Number <> 0 Then
    
    End If
    
    On Local Error GoTo 0
    Exit Function
End Function
Attribute VB_Name = "CEntityAdjacentFormulas"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public Function FillAdjacentFormula(entity As ZEWSProxy.DataDirectEntity, targetRange As range, isDoFill As Boolean) As range
 Dim candidateRange As range
 Dim filledRange As range
 Dim rowIndex As Long
 Dim columnIndex As Long
 Dim isFilledFormulaInColumn As Boolean

    With entity
        If .IsFromFormula Then Exit Function
        If .entityOption.IsFillFormulas = False Then Exit Function
        If .entityOption.ResultType = ResultType_ListObject Then Exit Function
    End With
    
    columnIndex = 0
    Do
        isFilledFormulaInColumn = False

        For rowIndex = entity.executeResult.HeaderRowsCount + entity.executeResult.CaptionRowsCount To entity.executeResult.TotalRowsCount
            If entity.IsVertical Then
                Set candidateRange = targetRange.Cells(rowIndex + 1, entity.executeResult.columnsCount + columnIndex + 1) '.Resize(1, 1)
            Else
                Set candidateRange = targetRange.Resize(, 1).offset(rowIndex, entity.executeResult.columnsCount + columnIndex).Resize(1, 1)
            End If

            If (candidateRange.HasFormula) Then
                If (rowIndex <> entity.executeResult.TotalRowsCount) Then
                    Set filledRange = candidateRange.Resize(entity.executeResult.TotalRowsCount - rowIndex, 1)

                    If (FillAdjacentFormula Is Nothing) Then
                        Set FillAdjacentFormula = filledRange
                    Else
                        Set FillAdjacentFormula = Union(FillAdjacentFormula, filledRange)
                    End If

                    If (isDoFill) Then Call candidateRange.AutoFill(filledRange, xlFillValues)
                End If

                isFilledFormulaInColumn = True
                Exit For
            End If
        Next

        If isFilledFormulaInColumn = False Then Exit Do
        columnIndex = columnIndex + 1
    Loop
End Function

Public Sub RemoveAdjacentFormulas(entity As ZEWSProxy.DataDirectEntity, oldRange As range)
 Dim row As Long
 Dim count As Long
 
    On Error GoTo OOPS
        
    If entity.IsFromFormula Then Exit Sub
    If entity.entityOption.IsFillFormulas = False Then Exit Sub
  
    With oldRange
        count = 0
        For row = .rows.count To entity.executeResult.DataRowsCount + entity.executeResult.HeaderRowsCount + 1 Step -1
            If Not .cell(row, .Columns.count + 1).HasFormula Then Exit For
            count = count + 1
        Next
        
        If count > 0 Then
            Call .Cells(.rows.count - count + 1, .Columns.count + 1).Resize(count).Clear
        End If
    End With
    
OOPS:
    If Err.Number <> 0 Then
    
    End If
    
    On Error GoTo 0
    Exit Sub
End Sub
Attribute VB_Name = "CEntityFilter"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

' See http://stackoverflow.com/questions/9489126/in-excel-vba-how-do-i-save-restore-a-user-defined-filter
Public Function SaveAutoFilter(filterObject As AutoFilter, filters() As Variant) As Boolean

    If filterObject Is Nothing Then Exit Function
    
    Dim i                       As Long
    Dim c1ok As Boolean
    Dim c2ok As Boolean

    With filterObject.filters

        ReDim filters(1 To .count, 1 To 3)

        For i = 1 To .count
            filters(i, 2) = -1
            If .item(i).On Then
                c1ok = CanParseCriteria(.item(i), 1)
                c2ok = CanParseCriteria(.item(i), 2)
                If c1ok Or c2ok Then
                    If c1ok And c2ok Then
                        filters(i, 1) = .item(i).Criteria1
                        filters(i, 2) = .item(i).Operator
                        filters(i, 3) = .item(i).Criteria2
                    ElseIf c1ok Then
                        filters(i, 1) = .item(i).Criteria1
                        filters(i, 2) = .item(i).Operator
                    Else
                        filters(i, 1) = .item(i).Criteria2
                        filters(i, 2) = 0
                    End If
                End If
            End If
        Next
    End With

    SaveAutoFilter = True

End Function

Private Function CanParseCriteria(filter As Object, index As Long) As Boolean
    On Error GoTo OOPS
    
    Dim temp As Variant
    
    Select Case index
        Case 1
            temp = filter.Criteria1
            CanParseCriteria = True
        Case 2
            temp = filter.Criteria2
            CanParseCriteria = True
    End Select
    
    On Error GoTo 0
    Exit Function
OOPS:
    Call Err.Clear
    CanParseCriteria = False
End Function

Public Function RestoreAutoFilters(targetRange As range, filters() As Variant) As Boolean

    If targetRange Is Nothing Then Exit Function

    If targetRange.Columns.count <> UBound(filters(), 1) Then Exit Function

    Dim i                       As Long

    Call targetRange.AutoFilter

    For i = 1 To UBound(filters(), 1)

        If Not IsEmpty(filters(i, 2)) Then

            Select Case filters(i, 2)
                Case 0 ' no operator
                    targetRange.AutoFilter field:=i, Criteria1:=filters(i, 1)
                Case 1, 2 'xlAnd, xlOr
                    targetRange.AutoFilter field:=i, Criteria1:=filters(i, 1), Operator:=filters(i, 2), Criteria2:=filters(i, 3)
                Case 3 To 6 ' xlTop10Items, xlBottom10Items, xlTop10Percent, xlBottom10Percent
                    targetRange.AutoFilter field:=i, Criteria1:=filters(i, 1)
                Case 7  'xlFilterValues
                    targetRange.AutoFilter field:=i, Criteria1:=filters(i, 1), Operator:=filters(i, 2)
            End Select
        End If
    Next i

End Function

Public Function saveSort(filterObject As AutoFilter, sorts() As Variant) As Boolean

    If filterObject Is Nothing Then Exit Function

    If filterObject.sort.SortFields.count = 0 Then Exit Function

    Dim i                       As Long

    With filterObject.sort.SortFields

        ReDim sorts(1 To .count, 1 To 5)

        For i = 1 To .count

            With .item(i)
                sorts(i, 1) = .key.Address
                sorts(i, 2) = .SortOn
                sorts(i, 3) = .order
                sorts(i, 4) = .CustomOrder
                sorts(i, 5) = .DataOption
            End With
        Next i
    End With

    saveSort = True

End Function

Public Function restoreSort(filterObject As AutoFilter, sorts() As Variant) As Boolean

    On Error GoTo OOPS

    If filterObject Is Nothing Then Exit Function

    If CDDXUtility.IsArrayEmpty(sorts) Then Exit Function

    Dim i                       As Long

    With filterObject.sort.SortFields

        Call .Clear

        For i = 1 To UBound(sorts(), 1)
            .Add key:=filterObject.range.Worksheet.range(sorts(i, 1)), SortOn:=sorts(i, 2), order:=sorts(i, 3), CustomOrder:=sorts(i, 4), DataOption:=sorts(i, 5)
        Next i
    End With

    Call filterObject.sort.Apply

    On Error GoTo 0
    Exit Function
OOPS:
    Call Err.Clear

End Function

Public Function GetAutoFilter(targetRange As range, isWorkSheetAutoFilter As Boolean) As AutoFilter

    Dim tableObject                         As ListObject

    Set tableObject = CDDXUtility.GetListObjectByPosition(targetRange)

    If Not tableObject Is Nothing Then

        Set GetAutoFilter = tableObject.AutoFilter
    Else
        If (targetRange.Worksheet.AutoFilterMode = True) Then

            If CDDXUtility.IsRangeIntersect(targetRange, targetRange.Worksheet.AutoFilter.range) = True Then

                Set GetAutoFilter = targetRange.Worksheet.AutoFilter
                isWorkSheetAutoFilter = True
            End If
        End If
    End If

End Function
Attribute VB_Name = "CEntityHelper"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Const RESULT_CHANGED_DATE_COLUMN_COUNT As Long = &H1
Private Const RESULT_CHANGED_TOTAL_COLUMN_COUNT As Long = &H2

Private Const FINFO_SIZE As Long = 3
Private m_table_formulas As String
Private m_entityRangeCache As Collection
 
Public m_CurrentDataFormats As Variant

Private Function GetEntityRangeCache() As VBA.Collection
    If m_entityRangeCache Is Nothing Then
        Set m_entityRangeCache = New VBA.Collection
    End If
    Set GetEntityRangeCache = m_entityRangeCache
End Function

Public Function GetEntityRangeFromCache(entity As ZEWSProxy.DataDirectEntity) As range
 Dim cache As Collection
 Dim rangeAddress As String

    On Error GoTo OOPS

    If entity Is Nothing Then Exit Function

    Set cache = GetEntityRangeCache(BSConsts.DDX_PID)
    Set GetEntityRangeFromCache = cache(entity.ExcelRangeName & "_" & entity.taskID)

    rangeAddress = GetEntityRangeFromCache.Address  'to make sure the range is still validated

OOPS:
    If Err.Number <> 0 Then
        Set GetEntityRangeFromCache = Nothing
        Call RemoveEntityRangeFromCache(entity)
    End If
    
    On Error GoTo 0
    Exit Function
End Function

Public Function AddOrUpdateEntityRangeCache(entity As ZEWSProxy.DataDirectEntity, targetRange As range) As Boolean
 Dim cache As Collection
 
    On Error GoTo OOPS
    
    If entity Is Nothing Then Exit Function
    If targetRange Is Nothing Then Exit Function

    Call RemoveEntityRangeFromCache(entity)
    Set cache = GetEntityRangeCache()
    Call cache.Add(targetRange, entity.ExcelRangeName & "_" & entity.taskID)
    AddOrUpdateEntityRangeCache = True

OOPS:
     On Error GoTo 0
    Exit Function
End Function

Public Function RemoveEntityRangeFromCache(entity As ZEWSProxy.DataDirectEntity) As Boolean
 Dim cache As Collection
    
    If entity Is Nothing Then Exit Function
    
    On Error GoTo OOPS
    
    Set cache = GetEntityRangeCache(BSConsts.DDX_PID)
    Call cache.Remove(entity.ExcelRangeName & "_" & entity.taskID)

OOPS:
    On Error GoTo 0
    Exit Function
End Function

Public Sub PopulateTableFormulas(tableRange As range, restoreFormat As Boolean)
 Dim formulas() As String
 Dim cols As Long
 Dim rows As Long
 Dim k As Long
 Dim c As Long
 Dim rgn As range
 
    On Error GoTo OOPS
    
    If m_table_formulas = vbNullString Then Exit Sub

    formulas = Split(m_table_formulas, vbTab)

    With tableRange
        cols = .Columns.count
        rows = .rows.count
    End With
    
    c = cols
    For k = UBound(formulas) To LBound(formulas) Step -FINFO_SIZE
        c = c + 1
        With tableRange.Cells(1, c)
            .Value2 = formulas(k - (FINFO_SIZE - 1))
        End With
    Next
    
    Set rgn = tableRange.Cells(2, cols + 1).Resize(rows - 1, (UBound(formulas) - LBound(formulas) + 1) \ FINFO_SIZE)
    rgn.NumberFormat = "General"
    
    c = cols
    For k = UBound(formulas) To LBound(formulas) Step -FINFO_SIZE
        c = c + 1
        With tableRange.Cells(1, c)
            .offset(1).Resize(rows - 1, 1).FormulaLocal = formulas(k - 1)
            If restoreFormat Then .offset(1).Resize(rows - 1, 1).NumberFormat = formulas(k)
        End With
    Next
    
    If Application.Calculation <> xlCalculationAutomatic Then
        With rgn
            .Calculate
            Call AdjustColumnWidths(True, .offset(-1).Resize(.rows.count + 1))
        End With
    End If
    
OOPS:
    If Err.Number <> 0 Then
        CDDXApp.StatusMessage = Err.Description
    End If
    m_table_formulas = vbNullString
    
    Exit Sub
End Sub

Public Function ContainsFormula(rgn As range) As Boolean
    With rgn
        ContainsFormula = IIf(.HasFormula = True And Not iserror(.FormulaR1C1), True, False)
    End With
End Function

Private Function PreserveTableFormulas(tableRange As range) As Long ', sheetId As String, rangeName As String) As Long
 Dim c As Long
 Dim rgn As range
 
    m_table_formulas = vbNullString
    If tableRange.rows.count <= 1 Then Exit Function
    
    For c = tableRange.Columns.count To 2 Step -1
        Set rgn = tableRange.Cells(2, c)
        With rgn
            If Not ContainsFormula(rgn) Then Exit For
            
            If Not IsNull(.FormulaR1C1) Then
                If Len(m_table_formulas) <> 0 Then m_table_formulas = m_table_formulas + vbTab
                
                m_table_formulas = m_table_formulas + tableRange.Cells(1, c).text + vbTab + .FormulaLocal + vbTab + .NumberFormat
                
                PreserveTableFormulas = PreserveTableFormulas + 1
            End If
        End With
    Next
End Function

Public Sub ResetTableEntityOutputOptions(entity As ZEWSProxy.DataDirectEntity)
    If entity.entityOption.ResultType <> ResultType_ListObject Then Exit Sub
    
    With entity.entityOption
        .HasProfileEntityTitle = False
        .HasReportEntityTitle = False
        .HasDCurveEntityTitle = False
        .HeaderOption = HeaderOption_SingleRow

        If .VerticalInsert = VerticalInsert_EntireRow Then .VerticalInsert = VerticalInsert_None
        If .VerticalDelete = VerticalDelete_EntireRow Then .VerticalDelete = VerticalDelete_None
        If .HorizontalInsert = HorizontalInsert_EntireColumn Then .HorizontalInsert = HorizontalInsert_None
        If .HorizontalDelete = HorizontalDelete_EntireColumn Then .HorizontalDelete = HorizontalDelete_None
    End With
End Sub

Public Function PopulateEntity(entity As ZEWSProxy.DataDirectEntity, targetRange As range, origCols As Long, origRows As Long) As range
    If CDDXHelper.IsSharedMode(targetRange.Worksheet.Parent) Then
        entity.entityOption.ResultType = ResultType_QueryTable
    End If

    Call ResetTableEntityOutputOptions(entity)

    If (entity.entityOption.ResultType = ResultType_QueryTable) Then
        Set PopulateEntity = LoadEntityByNamedRange(entity, targetRange, origCols, origRows)
    Else
        Set PopulateEntity = LoadEntityByListObject(entity, targetRange, origCols, origRows)
        Call PopulateTableFormulas(targetRange, entity.entityOption.IsPreserveFormat)
    End If

    Call SetSheetId(PopulateEntity.Worksheet, entity)
    Call CDDXHelper.MarkZEDoc(DDX_PID, PopulateEntity.Worksheet.Parent)

    If Not entity.IsFromFormula Then
        Call CDDXEntity.PersistEntities(DDX_PID, True, targetRange.Worksheet.Parent, entity)
    End If
End Function

Public Function DeleteExcelResultByRangeName(sheetId As String, rangeName As String, ByVal IsPreserveFormat As Boolean, newRange As range) As Boolean '= False
 Dim tableObject As ListObject
 Dim excelName As name
 Dim targetRange As range
 Dim rfc As Long

    Set excelName = CDDXUtility.GetExcelNameByRangeName(sheetId, rangeName)

    If Not excelName Is Nothing Then

        Set targetRange = CDDXUtility.GetExcelNameResultRange(excelName)

        If Not (targetRange Is Nothing) Then
            If (IsPreserveFormat) Then
                Call targetRange.ClearContents
            Else
                Call targetRange.Clear
            End If
        End If

        Call excelName.Delete
    End If

    Set tableObject = CDDXUtility.GetListObjectBysheetId(sheetId, rangeName)

    If Not tableObject Is Nothing Then
        Set targetRange = tableObject.range

'        rfc = StoreTableFormulas(targetRange, sheetId, rangeName)
        Call UnlistTable(tableObject)

        If (IsPreserveFormat) Then
            Call targetRange.ClearContents
            targetRange.Interior.ColorIndex = xlNone
        Else
            Call targetRange.Clear
        End If
            
        If Not newRange Is Nothing Then
            rfc = targetRange.Columns.count - (newRange.Columns.count + rfc)
            If rfc > 0 Then
                targetRange.offset(, targetRange.Columns.count - rfc).Resize(, rfc).Clear
            End If
        End If
    End If

    DeleteExcelResultByRangeName = True
End Function

Public Sub UnlistTable(tableObject As ListObject)
 Dim r As range
        
    Set r = tableObject.range
    Call tableObject.Unlist
        
    If Not r Is Nothing Then
        r.Borders(xlEdgeBottom).LineStyle = xlNone
    End If
End Sub

Private Function ColumnPersistence(entity As ZEWSProxy.DataDirectEntity, targetRange As range) As Boolean
    If entity.IsFromFormula Then Exit Function
    If entity.entityOption.HeaderOption = HeaderOption_NoHeader Then Exit Function

    With entity.entityOption
        If Not .IsFillFormulas Then Exit Function
        If .ResultType = ResultType_ListObject Then Call PreserveTableFormulas(targetRange)
    End With
End Function

Public Function GetHeaderRowCount(entityRange As range)
    Dim titleRowCount As Long
    Dim headerRowCount As Long

    If entityRange.Cells.count > 0 Then
        If LCase(entityRange.Cells(1, 1).value) = "date" Then
            titleRowCount = 0
            headerRowCount = 1

        ElseIf entityRange.rows.count > 1 Then
            If LCase(entityRange.Cells(2, 1).value) = "date" Then
                titleRowCount = 1
                headerRowCount = 1

            Else
                titleRowCount = 0
                headerRowCount = 1

            End If
        Else
            titleRowCount = 0
            headerRowCount = 0

        End If

        GetHeaderRowCount = titleRowCount + headerRowCount
        Do While GetHeaderRowCount < entityRange.rows.count
            If IsDate(entityRange.Cells(GetHeaderRowCount + 1, 1).value) Or IsNumeric(entityRange.Cells(GetHeaderRowCount + 1, 1).value) Then
                Exit Do
            Else
                GetHeaderRowCount = GetHeaderRowCount + 1
            End If
        Loop
    Else
        GetHeaderRowCount = 0
    End If
End Function

Public Function ResizeRange(entity As ZEWSProxy.DataDirectEntity, targetRange As range) As range
    Dim entityOption                                          As ZEWSProxy.entityOption
    Dim executeResult                                         As ZEWSProxy.EntityExecuteResult
    Dim sheet                                                 As Worksheet
    Dim rowIndex                                              As Long
    Dim columnIndex                                           As Long
    Dim originalRowCount                                      As Long
    Dim originalColumnCount                                   As Long
    Dim newRowCount                                           As Long
    Dim newColumnCount                                        As Long
    Dim columnCountDifference                                 As Long
    Dim rowCountDifference                                    As Long
    Dim originalLastRowIndex                                  As Long
    Dim originalLastColumnIndex                               As Long
    Dim k                                                     As Long

30      With targetRange
40          Set sheet = .Worksheet
50          rowIndex = .row
60          columnIndex = .column
70          originalRowCount = .rows.count
80          originalColumnCount = .Columns.count
90      End With

100     With entity
110         Set entityOption = entity.entityOption
120         Set executeResult = entity.executeResult
130     End With

        If entity.IsVertical = True Then
            newColumnCount = executeResult.columnsCount
            newRowCount = executeResult.TotalRowsCount
        Else
            newColumnCount = executeResult.DataRowsCount + executeResult.HeaderRowsCount
            newRowCount = executeResult.CaptionRowsCount + executeResult.columnsCount
        End If
        columnCountDifference = newColumnCount - originalColumnCount
        rowCountDifference = newRowCount - originalRowCount
        
160     originalLastRowIndex = rowIndex + originalRowCount - 1
170     originalLastColumnIndex = columnIndex + originalColumnCount - 1

171     If (originalLastRowIndex = rowIndex) Then
172         originalLastRowIndex = originalLastRowIndex + 1
173     End If

174     If (originalLastColumnIndex = columnIndex) Then
175         originalLastColumnIndex = originalLastColumnIndex + 1
        End If

        If (CDDXUtility.IsExcelReady = False) Then Exit Function

        If entity.entityOption.ResultType = ResultType_ListObject Then
            targetRange.Cells(originalRowCount, 1).Resize(1, originalColumnCount).Borders(xlEdgeBottom).LineStyle = xlNone
        End If

210     If targetRange.Worksheet.Parent.MultiUserEditing Then
220         If entityOption.VerticalInsert = VerticalInsert_ShiftCellsDown Then entityOption.VerticalInsert = VerticalInsert_EntireRow
230         If entityOption.VerticalDelete = VerticalDelete_ShiftCellsUp Then entityOption.VerticalDelete = VerticalInsert_EntireRow
240         If entityOption.HorizontalInsert = HorizontalInsert_ShiftCellsRight Then entityOption.HorizontalInsert = HorizontalInsert_EntireColumn
250         If entityOption.HorizontalDelete = HorizontalDelete_ShiftCellsLeft Then entityOption.HorizontalDelete = HorizontalDelete_EntireColumn
260     End If

        If Not ColumnPersistence(entity, targetRange) Then

270         If (newColumnCount > originalColumnCount) Then

280             Select Case entityOption.HorizontalInsert

                Case ZEWSProxy.HorizontalInsert.HorizontalInsert_ShiftCellsRight:
290                 Call sheet.Cells(rowIndex, originalLastColumnIndex).Resize(newRowCount, columnCountDifference).Insert(xlShiftToRight)

300             Case ZEWSProxy.HorizontalInsert.HorizontalInsert_EntireColumn:
310                 Call sheet.Columns(originalLastColumnIndex).Resize(, columnCountDifference).Insert(xlShiftToRight)

320             End Select

330             Call sheet.Cells(rowIndex, originalLastColumnIndex).Resize(newRowCount, columnCountDifference).ClearFormats

340         ElseIf (newColumnCount < originalColumnCount) Then

350             Select Case entityOption.HorizontalDelete

                    Case ZEWSProxy.HorizontalDelete.HorizontalDelete_ShiftCellsLeft:
360                     Call sheet.Cells(rowIndex + 1, originalLastColumnIndex).Resize(originalRowCount, 0 - columnCountDifference).Delete(xlShiftToLeft)

370                 Case ZEWSProxy.HorizontalDelete.HorizontalDelete_EntireColumn:
                        For k = 1 To Abs(columnCountDifference)
                            Call sheet.Columns(originalLastColumnIndex - k + 1).Delete
                        Next k
                        
                    Case Else:
                        With targetRange.Cells(1, newColumnCount + 1).Resize(originalRowCount, Abs(columnCountDifference))
                            .Clear
                            .Font.ColorIndex = xlColorIndexAutomatic
                        End With
390             End Select
400         End If
        End If

410     If (newRowCount > originalRowCount) Then

420         Select Case entityOption.VerticalInsert
                Case ZEWSProxy.VerticalInsert.VerticalInsert_ShiftCellsDown:
430                 Call sheet.Cells(originalLastRowIndex + 1, columnIndex).Resize(rowCountDifference, newColumnCount).Insert(xlShiftDown)

440             Case ZEWSProxy.VerticalInsert.VerticalInsert_EntireRow:
450                 Call sheet.rows(originalLastRowIndex + 1).Resize(rowCountDifference).Insert(xlShiftDown)

460         End Select

470         Call sheet.Cells(originalLastRowIndex + 1, columnIndex).Resize(rowCountDifference, newColumnCount).ClearFormats

    ElseIf (newRowCount < originalRowCount) Then
            Select Case entityOption.VerticalDelete
                Case ZEWSProxy.VerticalDelete.VerticalDelete_ShiftCellsUp:
                    Call sheet.Cells(rowIndex + newRowCount, columnIndex).Resize(0 - rowCountDifference, newColumnCount).Delete(xlShiftUp)

                Case ZEWSProxy.VerticalDelete.VerticalDelete_EntireRow:
                    Call sheet.rows(rowIndex + newRowCount).Resize(0 - rowCountDifference).Delete(xlShiftUp)

                Case Else:
                    With targetRange.Cells(newRowCount + 1, 1).Resize(originalRowCount - newRowCount, originalColumnCount)
                        .Clear
                        .Font.ColorIndex = xlColorIndexAutomatic
                    End With
            End Select
    End If

    Set ResizeRange = sheet.Cells(rowIndex, columnIndex).Resize(newRowCount, newColumnCount)
End Function

Public Function AddStyle(entity As ZEWSProxy.DataDirectEntity, targetRange As range)

30        If targetRange Is Nothing Then Exit Function
40        If entity Is Nothing Then Exit Function

          Dim k                             As Long

50        If (targetRange.rows.count > 1) Then

60            With targetRange.Resize(1, 1)

70                If Len(entity.Caption) > 0 Then

80                    If (entity.executeResult.CaptionRowsCount > 0) Then

90                        .HorizontalAlignment = xlLeft
'100                       .Borders(xlEdgeLeft).LineStyle = xlContinuous
'110                       .Borders(xlEdgeTop).LineStyle = xlContinuous
'120                       .Borders(xlEdgeRight).LineStyle = xlContinuous
'130                       .Borders(xlEdgeBottom).LineStyle = xlContinuous
140                       .Font.Bold = True
150                   End If
160               End If

170               If (entity.entityOption.IsFillCaption) Then

180                   If (entity.entityOption.ResultType <> 1) Then

190                       If (entity.executeResult.CaptionRowsCount > 0) Then
200                           .Interior.color = entity.entityOption.CaptionColor
210                       End If
220                   End If
230               End If
240           End With

250           If (entity.entityOption.ResultType <> 1) Then

260             If (entity.entityOption.IsFillHeader) Then

270                 For k = 1 To entity.executeResult.HeaderRowsCount
280                     targetRange.rows(entity.executeResult.CaptionRowsCount + k).Interior.color = entity.entityOption.HeaderColor
290                 Next k
300             End If

310             If (entity.entityOption.IsFillDataRow) Then

320                 If (entity.entityOption.IsFillByRow) Then

330                     For k = 1 To entity.executeResult.DataRowsCount
340                         targetRange.rows(entity.executeResult.CaptionAndHeaderRowsCount + k).Interior.color = IIf((k Mod 2 = 0), entity.entityOption.EvenColor, entity.entityOption.OddColor)
350                     Next k

360                 Else
370                     For k = 0 To entity.executeResult.columnsCount - 1
380                         targetRange.offset(entity.executeResult.CaptionAndHeaderRowsCount, k).Resize(entity.executeResult.DataRowsCount, 1).Interior.color = IIf((k Mod 2 = 0), entity.entityOption.OddColor, entity.entityOption.EvenColor)
390                     Next k
400                 End If
410             End If
420         End If
430       End If
End Function

'Private Function getProfile(username As String, groupName As String, ProfileName As String, configName As String) As ZEWSProxy.ProfileInfo
'
'        On Error GoTo OOPS
'
'        Dim userProfiles                        As ZEWSProxy.userProfile
'        Dim result                              As ZEWSProxy.ProfileInfo
'        Dim k                                   As Long
'10
'20      Set userProfiles = CDDXLib.RetrieveUserProfile(BSConsts.DDX_PID, username, 0)
'
'30      If Not (userProfiles Is Nothing) Then
'
'            Dim profiles() As ZEWSProxy.ProfileInfo
'
'40          profiles = userProfiles.profiles
'
'50          For k = LBound(profiles) To UBound(profiles)
'
'60              If StrComp(profiles(k).groupName, groupName, vbTextCompare) = 0 Then
'
'70                  If StrComp(profiles(k).ProfileName, ProfileName, vbTextCompare) = 0 Then
'
'80                      If (Len(Trim$(configName)) > 0) Then
'
'90                          If StrComp(profiles(k).configName, configName, vbTextCompare) = 0 Then
'100                             Set result = profiles(k)
'
'110                             Exit For
'120                         End If
'130                     Else
'140                         Set result = profiles(k)
'
'150                         Exit For
'160                     End If
'170                 End If
'180             End If
'190         Next k
'200     End If
'
'210     Set getProfile = result
'
'220     On Error GoTo 0
'230     Exit Function
'OOPS:
'        Dim errDesc         As String, errNum       As Long
'240     errDesc = "CEntityHelper.getProfile(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
'250     errNum = Err.Number
'        'your clean up codes here
'260     Call Err.Raise(errNum, Err.source, errDesc)
'
'End Function

Public Sub AddProfileComment(entity As ZEWSProxy.DataDirectEntity, entityRange As range)
 Dim ProfileData As ZEWSProxy.ProfileDataEntity
 Dim profileComment As Comment
 Dim Message As String

    On Error GoTo OOPS

    If (entityRange Is Nothing) Then Exit Sub
    If (entityRange.Columns.count = 1) Then Exit Sub
    If (entity Is Nothing) Then Exit Sub

    If Not CDDXUtility.IsProfileDataEntity(DDX_PID, entity) Then Exit Sub
    If entity.executeResult.CaptionRowsCount <= 0 Then Exit Sub
            
    Set ProfileData = entity

80          If (entityRange.Cells(1, 1).Comment) Is Nothing Then
90              Set profileComment = entityRange.Cells(1, 1).AddComment
100         Else
110             Set profileComment = entityRange.Cells(1, 1).Comment
120         End If

130         With profileComment

140             .Shape.TextFrame.AutoSize = True
150             .Shape.TextFrame.Characters.Font.ColorIndex = 5

160             Message = "Owner: " & ProfileData.OwnerUserName & vbLf
170             Message = Message & "Profile Group: " & ProfileData.groupName

180             If (Len(ProfileData.templateName) > 0) Then

190                 Message = Message & vbLf & "Template: " & ProfileData.ProfileName
200                 Message = Message & vbLf & "Profile: " & ProfileData.templateName
210             Else
220                 Message = Message & vbLf & "Profile: " & ProfileData.ProfileName
230             End If

280             If (CDDXUtility.IsExcelReady) Then
290                 Call .text(Message)
300             End If
310                 .Visible = False
320         End With

OOPS:
    If Err.Number <> 0 Then
        Call CDDXHelper.LogError(Err.Description, "CEntityHelper.AddProfileComment")
    End If
    Exit Sub
End Sub

Private Sub MarkEntitySheet(sheet As Worksheet)
    CSheet.ZESheetType(sheet) = ZESHEET_ENTITY
End Sub

Public Function BuildTable(entity As ZEWSProxy.DataDirectEntity, targetRange As range) As ListObject
 Dim tableObject As ListObject
 
    targetRange.Interior.ColorIndex = xlNone
    
    Set tableObject = targetRange.Worksheet.ListObjects.Add(xlSrcRange, targetRange, , xlYes)
    tableObject.name = entity.ExcelRangeName
    tableObject.TableStyle = "TableStyleMedium18"
    
    Set BuildTable = tableObject
End Function

Private Function LoadEntityByListObject(entity As ZEWSProxy.DataDirectEntity, targetRange As range, origCols As Long, origRows As Long) As range
 Dim tableObject As ListObject
        
    Set targetRange = LoadEntityByNamedRange(entity, targetRange, origCols, origRows, False)

    If Not targetRange Is Nothing Then
        Set tableObject = BuildTable(entity, targetRange)
    End If

    Set LoadEntityByListObject = tableObject.range
    Call MarkEntitySheet(targetRange.Parent)
End Function

Public Function LoadEntityByNamedRange(entity As ZEWSProxy.DataDirectEntity, targetRange As range, origCols As Long, origRows As Long, Optional IsAddExcelName As Boolean = True) As Excel.range
 Dim fcols() As String
 
    If entity.IsVertical Then
        If Not entity.entityOption.IsPreserveFormat Then
            origRows = 0
            
        ElseIf origCols <> entity.executeResult.columnsCount Then
            If entity.entityOption.ResultType = ResultType_ListObject And Len(m_table_formulas) > 0 Then
                fcols = Split(m_table_formulas, vbTab)
                If origCols - (UBound(fcols) - LBound(fcols) + 1) \ FINFO_SIZE <> entity.executeResult.columnsCount Then origRows = 0
            Else
                origRows = 0
            End If
        End If
    Else
        If Not entity.entityOption.IsPreserveFormat Or origRows <> entity.executeResult.columnsCount Then
            origCols = 0
        End If
    End If
    
    Select Case entity.executeResult.Ldr
        Case EXECUTION_RESULT_LDR_CURVE_DATA:
            Set LoadEntityByNamedRange = CDCurveHelpTRANS.LoadExecutionResult(entity, targetRange, origRows, origCols)
            
        Case EXECUTION_RESULT_LDR_DEFAULT:
            If entity.IsVertical Then
                Set LoadEntityByNamedRange = LoadExecutionResultVERT(entity, targetRange, origRows)
            Else
                Set LoadEntityByNamedRange = LoadExecutionResultHORI(entity, targetRange, origCols)
            End If
            
        Case Default:
    End Select
        
    Call replaceLoadedRange(entity, LoadEntityByNamedRange)
    
    If IsAddExcelName Then
        Call CEntityHelper.NewNamedRange(LoadEntityByNamedRange.Worksheet.Parent, entity.ExcelRangeName, LoadEntityByNamedRange)
    End If

    Call MarkEntitySheet(targetRange.Parent)
End Function

Private Sub ClearTargetFormats(entity As ZEWSProxy.DataDirectEntity, targetRange As range)
    With entity
        If .IsFromFormula Then Exit Sub
        If entity.entityOption.IsPreserveFormat And .executeResult.ChangedMasks = 0 Then Exit Sub
    End With
 
    With targetRange
        .ClearFormats
        .Font.ColorIndex = xlColorIndexAutomatic
    End With
End Sub

Private Function LoadExecutionResultVERT(entity As ZEWSProxy.DataDirectEntity, entityRange As range, origRows As Long) As Excel.range
 Dim file                                        As Object
 Dim dataary()                                   As Variant

 Dim filename                                    As String
 Dim buff                                        As String
 Dim headers()                                   As String
 Dim formats()                                   As String
 Dim datatypes()                                 As String
 Dim delimiter                                   As String
 Dim token                                       As Variant
 Dim tokens
 Dim errmsg                                      As String
' entity title
 Dim hdrTitle                                    As String
 Dim row                                         As Long
 Dim column                                      As Long
 Dim position                                    As Long
 Dim previousPosition                            As Long
 Dim rowCount                                    As Long
 Dim rc                                          As Long
 Dim cc                                          As Long
 Dim fetch_rows                                  As Long
 Dim colcount                                    As Long
 Dim fmtrowcount                                 As Long
 Dim hdrrowcount                                 As Long
 Dim ttlrowcount                                 As Long
 Dim targetRange                                 As Excel.range
 Dim rgn                                         As Excel.range
 Dim fromfm                                      As Boolean
 Dim originalCursor                              As Excel.XlMousePointer

    On Error GoTo OOPS

    If entity Is Nothing Then Exit Function
    If entityRange Is Nothing Then Exit Function
    If (CDDXUtility.IsResultReadyForTaskId(entity.taskID) = False) Then Exit Function

    Set targetRange = entityRange
    Call ClearTargetFormats(entity, targetRange)
    
    originalCursor = Application.Cursor
    Application.Cursor = xlWait

'    Call ClearOldData4Formula(entity, targetRange, 0, 0)

    filename = CDDXUtility.GetDataFileName(entity.taskID)
    Set file = CDDXFile.OpenFile(filename)
    If Not file.EOS() Then
        buff = file.ReadText(-2)
        ttlrowcount = 0
        If CDDXUtility.IsProfileDataEntity(DDX_PID, entity) And entity.entityOption.HasProfileEntityTitle Then ttlrowcount = 1
        If CDDXUtility.IsReportDataEntity(DDX_PID, entity) And entity.entityOption.HasReportEntityTitle Then ttlrowcount = 1
#If SMARTMAT_USE Then
        If CDDXUtility.IsSmartMartDataEntity(DDX_PID, entity) And entity.entityOption.HasSmartMartTitle Then ttlrowcount = 1
#End If
        If CDDXUtility.IsDCurveDataEntity(DDX_PID, entity) Then
            If entity.entityOption.HasDCurveEntityTitle Then
                ttlrowcount = 1
            Else
                entityRange.Resize(1).Font.Bold = False
            End If
        End If
        
        delimiter = Chr(9)
        If Len(buff) >= 4 And StrComp(left(buff, 4), "sep=") = 0 Then
            If Len(buff) > 4 Then
                delimiter = right(buff, Len(buff) - 4)
            End If
            buff = file.ReadText(-2)
        End If
        
        tokens = Split(buff, delimiter)
        
        colcount = CLng(tokens(0))
        fmtrowcount = CLng(tokens(1))
        hdrrowcount = CLng(tokens(2))
        rowCount = CLng(tokens(3))
        
        'Call ClearOldData4Formula(entity, targetRange, hdrrowcount + rowCount, colcount)
        
        hdrTitle = file.ReadText(-2)
        
        buff = file.ReadText(-2)
        If buff <> vbNullString Then
            datatypes = Split(buff, delimiter)
        End If
        
        buff = file.ReadText(-2)
        If Len(buff) > 0 Then
            formats = Split(buff, delimiter)
            m_CurrentDataFormats = formats
        End If
        
        If ttlrowcount > 0 Then
            If Len(hdrTitle) > 0 And left(hdrTitle, 1) = "'" Then
                targetRange.Cells(1, 1) = "'" + hdrTitle
            Else
                targetRange.Cells(1, 1) = hdrTitle
            End If
            origRows = origRows - ttlrowcount
            If origRows < 1 Then
                targetRange.rows(1).Font.ColorIndex = ENTITY_COLOR_HEADER_N_DATE
                targetRange.rows(1).HorizontalAlignment = xlLeft
                targetRange.rows(1).NumberFormat = "@"
            End If
        End If
        
        If entity.entityOption.HeaderOption = HeaderOption_MultipleRows And entity.executeResult.HeaderRowsCount > 0 Then
            ReDim dataary(1 To hdrrowcount, 1 To colcount)
            For row = 1 To hdrrowcount
                buff = file.ReadText(-2)
                headers = Split(buff, delimiter)
                For column = 1 To colcount
                    If Len(headers(column - 1)) > 0 And left(headers(column - 1), 1) = "'" Then
                        dataary(row, column) = "'" + headers(column - 1)
                    Else
                        dataary(row, column) = headers(column - 1)
                    End If
                Next column
            Next row
        ElseIf entity.entityOption.HeaderOption = HeaderOption_SingleRow And entity.executeResult.HeaderRowsCount > 0 Then
            If entity.entityOption.InsertBlankLines = 0 Then '.IsTrimEmptyHeaderRows
                ReDim dataary(1 To 1, 1 To colcount)
                If hdrrowcount > 0 Then
                    buff = file.ReadText(-2)
                    headers = Split(buff, delimiter)
                    For row = 2 To hdrrowcount
                        buff = file.ReadText(-2)
                        tokens = Split(buff, delimiter)
                        For column = 1 To colcount
                            headers(column - 1) = headers(column - 1) & vbCrLf & tokens(column - 1)
                        Next column
                    Next row
                    
                    For column = 1 To colcount
                        If Len(headers(column - 1)) > 0 And left(headers(column - 1), 1) = "'" Then
                            dataary(1, column) = "'" + headers(column - 1)
                        Else
                            dataary(1, column) = headers(column - 1)
                        End If
                    Next column
                    hdrrowcount = 1
                End If
            Else
                ReDim dataary(1 To entity.entityOption.InsertBlankLines + IIf(entity.executeResult.HeaderRowsCount > 0, 1, 0), 1 To colcount)
                
                If hdrrowcount > 0 Then
                    buff = file.ReadText(-2)
                    headers = Split(buff, delimiter)
                    For row = 2 To hdrrowcount - 1 '- entity.entityOption.InsertBlankLines
                        buff = file.ReadText(-2)
                        If row <= hdrrowcount - entity.entityOption.InsertBlankLines Then
                            tokens = Split(buff, delimiter)
                            For column = 1 To colcount
                                headers(column - 1) = headers(column - 1) & vbCrLf & tokens(column - 1)
                            Next
                        End If
                    Next row
                    
                    For column = 1 To colcount
                        If Len(headers(column - 1)) > 0 And left(headers(column - 1), 1) = "'" Then
                            dataary(1, column) = "'" + headers(column - 1)
                        Else
                            dataary(1, column) = headers(column - 1)
                        End If
                    Next column
                    file.ReadText (-2)
                    hdrrowcount = entity.entityOption.InsertBlankLines + IIf(entity.executeResult.HeaderRowsCount > 0, 1, 0)
                End If
            End If
        Else
            For row = 1 To hdrrowcount
                file.ReadText (-2)
            Next row
            hdrrowcount = 0
        End If
        
        If (targetRange.Columns.count <> colcount) Or (targetRange.rows.count <> rowCount + hdrrowcount) Then
            Set targetRange = targetRange.offset(ttlrowcount, 0).Resize(rowCount + hdrrowcount, colcount)
        End If
        
        If hdrrowcount > 0 Then
            Call SetHeaderFormat(entity, targetRange, origRows, True)
            targetRange.Resize(hdrrowcount, colcount).value = dataary
            origRows = origRows - hdrrowcount
            If rowCount > 0 Then
                Set targetRange = targetRange.offset(hdrrowcount, 0).Resize(rowCount, colcount)
            End If
        End If
        If origRows < 0 Then origRows = 0
    
        If rowCount > 0 Then
            If (rowCount > origRows Or ResultAttributesChanged(entity)) And Len(Join(formats)) > 0 Then
                Set rgn = targetRange.Cells(IIf(ResultAttributesChanged(entity), 0, origRows) + 1, 1).Resize(rowCount - IIf(ResultAttributesChanged(entity), 0, origRows), colcount)
                
                For column = 0 To colcount - 1
                    rgn.Columns(column + 1).NumberFormat = IIf(Len(formats(column)) > 0, formats(column), "@")
                Next
            End If
            
            Set rgn = targetRange
            fetch_rows = (2048 \ colcount) + 1
            If fetch_rows > rowCount Then fetch_rows = rowCount
            ReDim dataary(1 To fetch_rows, 1 To colcount)
            rc = 0
            
            While rowCount > 0
                If rowCount < fetch_rows Then
                    fetch_rows = rowCount
                End If
                
                For row = 1 To fetch_rows
                    buff = file.ReadText(-2)
                    column = 1
                    tokens = Split(buff, delimiter)
    
                    For Each token In tokens
                        If column > colcount Then Exit For
                        If IsNumeric(token) Then
                            dataary(row, column) = CDbl(token)
                        Else
                            dataary(row, column) = token
                        End If
                        column = column + 1
                    Next token
                Next row

                rgn.Cells(rc + 1, 1).Resize(fetch_rows, colcount).value = dataary
                
                rowCount = rowCount - fetch_rows
                rc = rc + fetch_rows
            Wend
            
            If Len(Join(datatypes)) > 0 Then
                If datatypes(0) = "DATE" Or datatypes(0) = "TIMESTAMP" Then
                    Call SetDateFormat(entity, rgn, origRows, True)
                End If
            End If
            
            Set rgn = rgn.Resize(1)
        End If
    End If

    Call ClearErr
    
OOPS:
    If Err.Number <> 0 Then
        errmsg = Err.Description
    End If

    Application.Cursor = originalCursor

    
    Call CDDXFile.CloseFile(file, filename, buff)
    Set file = Nothing
    
    Erase dataary

    If CDDXUtility.IsDCurveDataEntity(BSConsts.DDX_PID, entity) And entity.executeResult.DataRowsCount > 0 Then
        Call SetCurveValueFormat(entity, targetRange, origRows)
        Call SetCurveDateFormat(entity, targetRange, origRows)
    End If
    
    If errmsg <> vbNullString Then
        Call Err.Raise(vbObjectError + 1, "LoadEntityByNamedRange", errmsg)
    End If

    'no idea why this resize is necessary, but if do not apply the resize, the entity recorded on workbook will become size of 1x1
    Set LoadExecutionResultVERT = entityRange.Resize(entity.executeResult.TotalRowsCount, entity.executeResult.columnsCount)
End Function

Public Function ResultAttributesChanged(entity As ZEWSProxy.DataDirectEntity) As Boolean
    With entity.executeResult
        ResultAttributesChanged = (.ChangedMasks And RESULT_CHANGED_DATE_COLUMN_COUNT) <> 0 Or (.ChangedMasks And RESULT_CHANGED_TOTAL_COLUMN_COUNT) <> 0
    End With
End Function

Private Function TrimDateHeader(keyName As String, captionValues As String) As String
 Dim v As Variant
 Dim k As Long
 
    If captionValues = vbNullString Then Exit Function
    v = Split(captionValues, vbCrLf)
   
    If StrComp(v(0), keyName, vbTextCompare) <> 0 Then
        TrimDateHeader = captionValues
        Exit Function
    End If
    
    For k = 1 To UBound(v)
        If v(k) <> vbNullString Then
            TrimDateHeader = captionValues
            Exit Function
        End If
    Next
    
    TrimDateHeader = v(0)
End Function

Private Sub TrimDateCaptions(entity As ZEWSProxy.DataDirectEntity, headers() As String)
 Dim ival As String
 Dim k As Long
 
    headers(0) = TrimDateHeader("Date", headers(0))

    ival = entity.interval
    If StrComp(ival, "Daily", vbTextCompare) = 0 Then Exit Sub
    If StrComp(ival, "Weekly", vbTextCompare) = 0 Then Exit Sub
    If StrComp(ival, "Monthly", vbTextCompare) = 0 Then Exit Sub
    If StrComp(ival, "Quarterly", vbTextCompare) = 0 Then Exit Sub
    If StrComp(ival, "HalfYear", vbTextCompare) = 0 Then Exit Sub
    If StrComp(ival, "Annual", vbTextCompare) = 0 Then Exit Sub
    
    For k = 1 To 2
        If k > UBound(headers) Then Exit For
        headers(k) = TrimDateHeader(IIf(k = 1, "Hour", "Minute"), headers(k))
    Next
End Sub

Private Function LoadExecutionResultHORI(entity As ZEWSProxy.DataDirectEntity, entityRange As range, origCols As Long) As Excel.range
    On Error GoTo OOPS

    If entity Is Nothing Then Exit Function
    If entityRange Is Nothing Then Exit Function

    If (CDDXUtility.IsResultReadyForTaskId(entity.taskID) = False) Then Exit Function

    Dim file                                        As Object
    Dim dataary()                                   As Variant

    Dim filename                                    As String
    Dim buff                                        As String
    Dim headers()                                   As String
    Dim formats()                                   As String
    Dim datatypes()                                 As String
    Dim delimiter                                   As String
    Dim token                                       As Variant
    Dim tokens
    Dim errmsg                                      As String
    ' entity title
    Dim hdrTitle                                    As String

    Dim row                                         As Long
    Dim column                                      As Long
    Dim position                                    As Long
    Dim previousPosition                            As Long

    Dim rowCount                                    As Long
    Dim rc                                          As Long
    Dim cc                                          As Long
    Dim fetch_rows                                  As Long
    Dim colcount                                    As Long
    Dim fmtrowcount                                 As Long
    Dim hdrrowcount                                 As Long
    Dim ttlrowcount                                 As Long
    Dim targetRange                                 As Excel.range
    Dim rgn                                         As Excel.range

    Dim fromfm                                      As Boolean

    Dim originalCursor                              As Excel.XlMousePointer

    Set targetRange = entityRange
    Call ClearTargetFormats(entity, targetRange)
    
    originalCursor = Application.Cursor
    Application.Cursor = xlWait

'    Call ClearOldData4Formula(entity, targetRange, 0, 0)

    filename = CDDXUtility.GetDataFileName(entity.taskID)
    Set file = CDDXFile.OpenFile(filename)
    If Not file.EOS() Then
        buff = file.ReadText(-2)
        ttlrowcount = 0
        If CDDXUtility.IsProfileDataEntity(DDX_PID, entity) And entity.entityOption.HasProfileEntityTitle Then ttlrowcount = 1
        If CDDXUtility.IsReportDataEntity(DDX_PID, entity) And entity.entityOption.HasReportEntityTitle Then ttlrowcount = 1
#If SMARTMAT_USE Then
        If CDDXUtility.IsSmartMartDataEntity(DDX_PID, entity) And entity.entityOption.HasSmartMartTitle Then ttlrowcount = 1
#End If
        If CDDXUtility.IsDCurveDataEntity(DDX_PID, entity) And entity.entityOption.HasDCurveEntityTitle Then ttlrowcount = 1
        
        delimiter = Chr(9)
        If Len(buff) >= 4 And StrComp(left(buff, 4), "sep=") = 0 Then
            If Len(buff) > 4 Then
                delimiter = right(buff, Len(buff) - 4)
            End If
            buff = file.ReadText(-2)
        End If
        
        tokens = Split(buff, delimiter)
        
        colcount = CLng(tokens(0))
        fmtrowcount = CLng(tokens(1))
        hdrrowcount = CLng(tokens(2))
        rowCount = CLng(tokens(3))
    
        hdrTitle = file.ReadText(-2)
        
        buff = file.ReadText(-2)
        If buff <> vbNullString Then
            datatypes = Split(buff, delimiter)
        End If
        
        buff = file.ReadText(-2)
        If Len(buff) > 0 Then
            formats = Split(buff, delimiter)
        End If
        
        If ttlrowcount > 0 Then
            If Len(hdrTitle) > 0 And left(hdrTitle, 1) = "'" Then
                targetRange.Cells(1, 1) = "'" + hdrTitle
            Else
                targetRange.Cells(1, 1) = hdrTitle
            End If
            If origCols < 1 Then
                targetRange.Columns(1).Font.ColorIndex = ENTITY_COLOR_HEADER_N_DATE
                targetRange.Columns(1).HorizontalAlignment = xlLeft
                targetRange.Columns(1).NumberFormat = "@"
            End If
        End If
        
        If entity.entityOption.HeaderOption = HeaderOption_MultipleRows Then
            ReDim dataary(1 To colcount, 1 To hdrrowcount)
            For row = 1 To hdrrowcount
                buff = file.ReadText(-2)
                headers = Split(buff, delimiter)
                For column = 1 To colcount
                    If Len(headers(column - 1)) > 0 And left(headers(column - 1), 1) = "'" Then
                        dataary(column, row) = "'" + headers(column - 1)
                    Else
                        dataary(column, row) = headers(column - 1)
                    End If
                Next column
            Next row
        ElseIf entity.entityOption.HeaderOption = HeaderOption_SingleRow Then
            If entity.entityOption.InsertBlankLines = 0 Then '.IsTrimEmptyHeaderRows
                ReDim dataary(1 To colcount, 1 To 1)
                If hdrrowcount > 0 Then
                    buff = file.ReadText(-2)
                    headers = Split(buff, delimiter)
                    For row = 2 To hdrrowcount
                        buff = file.ReadText(-2)
                        tokens = Split(buff, delimiter)
                        For column = 1 To colcount
                            headers(column - 1) = headers(column - 1) & vbCrLf & tokens(column - 1)
                        Next column
                    Next row
                    Call TrimDateCaptions(entity, headers)
                    
                    For column = 1 To colcount
                        If Len(headers(column - 1)) > 0 And left(headers(column - 1), 1) = "'" Then
                            dataary(column, 1) = "'" + headers(column - 1)
                        Else
                            dataary(column, 1) = headers(column - 1)
                        End If
                    Next column
                    hdrrowcount = 1
                End If
            Else
                ReDim dataary(1 To colcount, 1 To entity.entityOption.InsertBlankLines + IIf(entity.executeResult.HeaderRowsCount > 0, 1, 0))
                
                If hdrrowcount > 0 Then
                    buff = file.ReadText(-2)
                    headers = Split(buff, delimiter)
                    For row = 2 To hdrrowcount - 1 '- entity.entityOption.InsertBlankLines
                        buff = file.ReadText(-2)
                        If row <= hdrrowcount - entity.entityOption.InsertBlankLines Then
                            tokens = Split(buff, delimiter)
                            For column = 1 To colcount
                                headers(column - 1) = headers(column - 1) & vbCrLf & tokens(column - 1)
                            Next
                        End If
                    Next row
                    Call TrimDateCaptions(entity, headers)
                    
                    For column = 1 To colcount
                        dataary(column, 1) = headers(column - 1)
                    Next column
                    file.ReadText (-2)
                    hdrrowcount = entity.entityOption.InsertBlankLines + IIf(entity.executeResult.HeaderRowsCount > 0, 1, 0)
                End If
            End If
        Else
            For row = 1 To hdrrowcount
                file.ReadText (-2)
            Next row
            hdrrowcount = 0
        End If
        
        If (targetRange.Columns.count <> colcount) Or (targetRange.rows.count <> rowCount + hdrrowcount) Then
            Set targetRange = targetRange.offset(ttlrowcount, 0).Resize(colcount, rowCount + hdrrowcount)
        End If
        Call SetHeaderFormat(entity, targetRange, origCols, False)
        
        If hdrrowcount > 0 Then
            targetRange.Resize(colcount, hdrrowcount).value = dataary
            If rowCount > 0 Then
                Set targetRange = targetRange.offset(0, hdrrowcount).Resize(colcount, rowCount)
            End If
        End If
        origCols = origCols - hdrrowcount
        If origCols < 0 Then origCols = 0
    
        If rowCount > 0 Then
            If Len(Join(formats)) > 0 Then
                If rowCount > origCols Then
                    'Set rgn = targetRange.offset(0, origCols).Resize(colcount, rowCount - origCols)
                    Set rgn = targetRange.Resize(colcount, rowCount)
                    For row = 0 To colcount - 1
                        If Len(formats(row)) > 0 Then
                            rgn.rows(row + 1).NumberFormat = formats(row)
                        End If
                    Next
                ElseIf entity.executeResult.DateColumnCount > 0 And entity.executeResult.DataRowsCount > 0 Then
                    Set rgn = targetRange.Resize(entity.executeResult.DateColumnCount, entity.executeResult.DataRowsCount)
                    For row = 0 To entity.executeResult.DateColumnCount - 1
                        If Len(formats(row)) > 0 Then
                            rgn.rows(row + 1).NumberFormat = formats(row)
                        End If
                    Next
                End If
            End If
            Set rgn = targetRange
            
            fetch_rows = (2048 \ colcount) + 1
            If fetch_rows > rowCount Then fetch_rows = rowCount
            ReDim dataary(1 To colcount, 1 To fetch_rows)
            rc = 0
            
            While rowCount > 0
                If rowCount < fetch_rows Then
                    fetch_rows = rowCount
                End If
                
                For row = 1 To fetch_rows
                    buff = file.ReadText(-2)
                    column = 1
                    tokens = Split(buff, delimiter)
    
                    For Each token In tokens
                        If column > colcount Then Exit For
                        If IsNumeric(token) Then
                            dataary(column, row) = CDbl(token)
                        Else
                            dataary(column, row) = token
                        End If
                        column = column + 1
                    Next token
                Next row
                
                
                rgn.offset(0, rc).Resize(colcount, fetch_rows).value = dataary
                rowCount = rowCount - fetch_rows
                rc = rc + fetch_rows
            Wend
            If Len(Join(datatypes)) > 0 Then
                If datatypes(0) = "DATE" Or datatypes(0) = "TIMESTAMP" Then
                    Call SetDateFormat(entity, rgn, origCols, False)
                End If
            End If
            
            Set rgn = rgn.Resize(1)
        End If
    End If

    Call ClearErr

OOPS:
    If Err.Number <> 0 Then
        errmsg = Err.Description
    End If

    Application.Cursor = originalCursor

    Call CDDXFile.CloseFile(file, filename, buff)
    Set file = Nothing
    
    Erase dataary
    
    If CDDXUtility.IsDCurveDataEntity(BSConsts.DDX_PID, entity) Then
        'Call SetCurveDataFormatH(entity, targetRange, origcols)
        'Call SetCurveDateFormatH(entity, targetRange, origcols)
    End If

    If errmsg <> vbNullString Then
        Call Err.Raise(vbObjectError + 1, "LoadEntityByNamedRange", errmsg)
    End If

    Set LoadExecutionResultHORI = entityRange.Resize(entity.executeResult.CaptionRowsCount + entity.executeResult.columnsCount, entity.executeResult.HeaderRowsCount + entity.executeResult.DataRowsCount)
End Function

Private Sub ResetFont(targetRange As range)
    With targetRange.Font
        .FontStyle = "Regular"
        .Strikethrough = False
        .Superscript = False
        .Subscript = False
        .Underline = xlUnderlineStyleNone
        .ColorIndex = xlAutomatic
    End With
End Sub

Private Sub SetHeaderFormat(entity As ZEWSProxy.DataDirectEntity, entityRange As range, origRows As Long, vertical As Boolean)
 Dim targetRange As range
 Dim hc As Long
 
    If entity.executeResult.HeaderRowsCount <= 0 Then Exit Sub
    If entity.IsFromFormula And entity.entityOption.HeaderOption = HeaderOption_NoHeader Then Exit Sub
    
    If Not vertical Then
        hc = entity.executeResult.HeaderRowsCount
        If hc <= 0 Then Exit Sub
    End If
    
    Set targetRange = entityRange.Resize(IIf(vertical, entity.executeResult.HeaderRowsCount, entity.executeResult.columnsCount), IIf(vertical, entity.executeResult.columnsCount, hc))
    
    Call ResetFont(targetRange)
    With targetRange
        .Font.ColorIndex = ENTITY_COLOR_HEADER_N_DATE
        .HorizontalAlignment = xlLeft
        .VerticalAlignment = IIf(entity.entityOption.HeaderOption = HeaderOption_SingleRow, xlVAlignTop, xlVAlignCenter)
        .NumberFormat = "@"
    End With
    
    If entity.executeResult.PreviousHeaderRowsCount <= entity.executeResult.HeaderRowsCount Then Exit Sub
    
    If vertical Then
        'Set targetRange = targetRange.offset(entity.executeResult.HeaderRowsCount).Resize(entity.executeResult.PreviousHeaderRowsCount - entity.executeResult.HeaderRowsCount)
        Exit Sub
    Else
        Set targetRange = targetRange.offset(, entity.executeResult.HeaderRowsCount).Resize(, entity.executeResult.PreviousHeaderRowsCount - entity.executeResult.HeaderRowsCount)
    End If
    
    With targetRange
        Call .Clear
    End With
End Sub

Public Sub SetDateFormat(entity As ZEWSProxy.DataDirectEntity, entityRange As range, origRows As Long, vertical As Boolean)
 Dim targetRange As range
 Dim formatHeader As Boolean
    
    If vertical Then
        If entity.executeResult.DataRowsCount > origRows Then
            Set targetRange = entityRange.offset(origRows, 0).Resize(entity.executeResult.DataRowsCount - origRows, 1)
            targetRange.Columns(1).Font.ColorIndex = ENTITY_COLOR_HEADER_N_DATE
            targetRange.Columns(1).HorizontalAlignment = xlRight
        End If
    Else
        Set targetRange = entityRange.Resize(entity.executeResult.DateColumnCount, entity.executeResult.DataRowsCount)
        targetRange.Font.ColorIndex = ENTITY_COLOR_HEADER_N_DATE
        targetRange.HorizontalAlignment = xlRight
    End If
End Sub

Public Sub SetCurveValueFormat(entity As ZEWSProxy.DataDirectEntity, entityRange As range, ByVal origRows As Long)
    Dim targetRange                                 As Excel.range
    Dim dRange                                      As Excel.range
    Dim hRange                                      As Excel.range
    Dim mRange                                      As Excel.range
    Dim dataary()                                   As Variant
    Dim tempDateFormats()                           As String
    Dim resultDateFormats(3)                         As String
    Dim cellFormates()                              As String
    Dim format                                      As Long
    Dim filename                                    As String
    Dim buffer                                      As String
    Dim row                                         As Long
    Dim ttlrowcount                                 As Long
    Dim col                                         As Long
    Dim colcount                                    As Long
    Dim i                                           As Long
    Dim file                                        As Object
    Dim dc As ZEWSProxy.DCurveDataEntity

    On Error GoTo OOPS

    ttlrowcount = entity.executeResult.DataRowsCount - origRows
    If ttlrowcount < 1 Then Exit Sub
    
    filename = Replace(CDDXUtility.GetDataFileName(entity.taskID), ".csv", ".map")
    If Len(Dir(filename)) = 0 Then Exit Sub
    Set file = CDDXFile.OpenFile(filename)
    
    Set dc = entity

    tempDateFormats = dc.resultDateFormats
    resultDateFormats(0) = vbNullString
    resultDateFormats(1) = tempDateFormats(0)
    resultDateFormats(2) = tempDateFormats(2)

    col = entityRange.Columns.count - 1
    If dc.IsShowStatus = False Then col = col + 1
    
    If dc.IsTypeAsHeader = False Then
        row = 0
        format = 0
        Do While row < origRows And Not file.EOS()
            buffer = file.ReadText(-2)
            format = CLng(left(buffer, 1))
            row = row + CLng(Mid(buffer, 2))
        Loop

        If row > origRows Then
            Set targetRange = entityRange.offset(origRows, 0).Resize(row - origRows, entity.executeResult.columnsCount)
            If format > 0 Then
                targetRange.Columns(col).NumberFormat = resultDateFormats(format)
            End If
            origRows = row
            ttlrowcount = entity.executeResult.DataRowsCount - origRows
        End If

        Do While Not file.EOS()
            buffer = file.ReadText(-2)
            format = CLng(left(buffer, 1))
            row = CLng(Mid(buffer, 2))
            Set targetRange = entityRange.offset(origRows, 0).Resize(row, entity.executeResult.columnsCount)
            If format > 0 Then
                targetRange.Columns(col).NumberFormat = resultDateFormats(format)
            End If
            origRows = origRows + row
        Loop
    Else
        Set targetRange = entityRange.offset(origRows, 0).Resize(ttlrowcount, entity.executeResult.columnsCount)
        If Not file.EOS() Then
            buffer = file.ReadText(-2)
            tempDateFormats = Split(buffer, vbTab)
            colcount = UBound(tempDateFormats) - LBound(tempDateFormats) '1 extra tab
            For i = 1 To colcount
                format = CLng(tempDateFormats(i - 1))
                If format > 0 Then
                    targetRange.Columns(col - colcount + i).NumberFormat = resultDateFormats(format)
                End If
            Next i
        End If
    End If

OOPS:
    If Err.Number <> 0 Then
        CDDXApp.StatusMessage = "SetCurveValueFormat:  " + Err.Description
    End If

    Call CDDXFile.CloseFile(file, filename, Err.Description)
    Set file = Nothing

    Erase dataary
    On Error GoTo 0
End Sub

Public Sub SetCurveDateFormat(entity As ZEWSProxy.DataDirectEntity, entityRange As range, origRows As Long)
    Dim targetRange                                 As Excel.range
    Dim dRange                                      As Excel.range
    Dim hRange                                      As Excel.range
    Dim mRange                                      As Excel.range
    Dim dataary()                                   As Variant
    Dim resultDateFormats()                         As String
    Dim cellFormates()                              As String
    Dim format                                      As Long
    Dim filename                                    As String
    Dim buffer                                      As String
    Dim row                                         As Long
    Dim ttlrowcount                                 As Long
    Dim file                                        As Object
    Dim dc As ZEWSProxy.DCurveDataEntity
     
    On Error GoTo OOPS
    
    Set dc = entity

    resultDateFormats = dc.resultDateFormats
    
    ttlrowcount = entity.executeResult.DataRowsCount - origRows
    If ttlrowcount < 1 Then Exit Sub
        
    filename = Replace(CDDXUtility.GetDataFileName(entity.taskID), ".csv", ".fmt")
    If Len(Dir(filename)) = 0 Then Exit Sub
    
    Set file = CDDXFile.OpenFile(filename)
    
    row = 0
    format = 0
    Do While row < origRows And Not file.EOS()
        buffer = file.ReadText(-2)
        format = CLng(left(buffer, 1))
        row = row + CLng(Mid(buffer, 2))
    Loop
    
    If row > origRows Then
        Set targetRange = entityRange.offset(origRows, 0).Resize(row - origRows, entity.executeResult.columnsCount)
        If dc.isFutures Then
            targetRange.Columns(1).NumberFormat = resultDateFormats(0) 'effective date -> daily
            targetRange.Columns(3).NumberFormat = resultDateFormats(format)
            targetRange.Columns(4).NumberFormat = resultDateFormats(format)
        Else
            targetRange.Columns(1).NumberFormat = resultDateFormats(format)
        End If
        origRows = row
        ttlrowcount = entity.executeResult.DataRowsCount - origRows
    End If
    
    If dc.isFutures Then
        entityRange.offset(origRows, 0).Resize(ttlrowcount, 1).Columns(1).NumberFormat = resultDateFormats(0) 'effective date -> daily
    End If
    
    Do While Not file.EOS()
        buffer = file.ReadText(-2)
        format = CLng(left(buffer, 1))
        row = CLng(Mid(buffer, 2))
        Set targetRange = entityRange.offset(origRows, 0).Resize(row, entity.executeResult.columnsCount)
        If dc.isFutures Then
            targetRange.Columns(3).NumberFormat = resultDateFormats(format)
            targetRange.Columns(4).NumberFormat = resultDateFormats(format)
        Else
            targetRange.Columns(1).NumberFormat = resultDateFormats(format)
        End If
'            If format = 0 Then
'                If dRange Is Nothing Then
'                    Set dRange = targetRange
'                Else
'                    Set dRange = Application.Union(dRange, targetRange)
'                End If
'
'            ElseIf format = 1 Then
'                If hRange Is Nothing Then
'                    Set hRange = targetRange
'                Else
'                    Set hRange = Application.Union(hRange, targetRange)
'                End If
'
'            ElseIf format = 2 Then
'                If mRange Is Nothing Then
'                    Set mRange = targetRange
'                Else
'                    Set mRange = Application.Union(mRange, targetRange)
'                End If
'
'            Else
'
'            End If
        origRows = origRows + row
    Loop
        
        
'        If dc.isFutures Then
'            If Not dRange Is Nothing Then
'                dRange.Columns(3).NumberFormat = resultDateFormats(0)
'                dRange.Columns(4).NumberFormat = resultDateFormats(0)
'            End If
'            If Not hRange Is Nothing Then
'                hRange.Columns(3).NumberFormat = resultDateFormats(1)
'                hRange.Columns(4).NumberFormat = resultDateFormats(1)
'            End If
'            If Not mRange Is Nothing Then
'                mRange.Columns(3).NumberFormat = resultDateFormats(2)
'                mRange.Columns(4).NumberFormat = resultDateFormats(2)
'            End If
'        Else
'            If Not dRange Is Nothing Then
'                dRange.Columns(1).NumberFormat = resultDateFormats(0)
'            End If
'            If Not hRange Is Nothing Then
'                hRange.Columns(1).NumberFormat = resultDateFormats(1)
'            End If
'            If Not mRange Is Nothing Then
'                mRange.Columns(1).NumberFormat = resultDateFormats(2)
'            End If
'        End If
    
OOPS:
    If Err.Number <> 0 Then
        CDDXApp.StatusMessage = "SetCurveDateFormat: " + Err.Description
    End If
    
    Call CDDXFile.CloseFile(file, filename, Err.Description)
    Set file = Nothing
    
    Erase dataary
    On Error GoTo 0
End Sub

Private Sub replaceLoadedRange(entity As ZEWSProxy.DataDirectEntity, targetRange As range)
 Dim dispalert As Boolean
 Dim errDesc As String
 Dim errNum As Long
 
    If targetRange Is Nothing Then Exit Sub
    
    On Error GoTo OOPS
    
    dispalert = Application.DisplayAlerts
    Application.DisplayAlerts = False

    With targetRange
        Call .Replace(what:=LF_ENCODE, replacement:=vbLf, LookAt:=xlPart, SearchOrder:=xlByRows, MatchCase:=False)
        Call .Resize(1, 1).Replace(what:="&#13;", replacement:=vbLf, LookAt:=xlPart, SearchOrder:=xlByRows, MatchCase:=False)
        
        Call CEntityHelper.AdjustRowHeights(entity, targetRange)
    End With

OOPS:
    If Err.Number <> 0 Then
        errDesc = Err.Description
        errNum = Err.Number
    End If
    
    Application.DisplayAlerts = dispalert

    If errNum <> 0 Then Call Err.Raise(errNum, , errDesc)
End Sub

Public Function SetSheetId(sheet As Worksheet, entity As ZEWSProxy.DataDirectEntity) As Boolean
    If (Len(CDDXHelper.ZESheetID(BSConsts.DDX_PID, sheet)) > 0) Then
        entity.sheetId = CDDXHelper.ZESheetID(BSConsts.DDX_PID, sheet)
    Else
        entity.sheetId = CDDXHelper.NewGUID()
        CSheet.ZESheetID(sheet) = entity.sheetId
    End If
End Function

Public Property Get ZESheetSavedEntities(sheet As Worksheet) As String
    ZESheetSavedEntities = CSheet.WSGetProp(sheet, PROP_SAVED_ENTITIES)
End Property

Public Property Let ZESheetSavedEntities(sheet As Worksheet, entitiesXml As String)
    Call CSheet.WSSetProp(sheet, PROP_SAVED_ENTITIES, entitiesXml)
End Property

Public Function SaveHiddenColumns(targetRange As range) As Boolean()
 Dim i As Long
 Dim result() As Boolean

    If targetRange Is Nothing Then Exit Function

    ReDim result(1 To targetRange.Columns.count)

    For i = 1 To targetRange.Columns.count
        result(i) = targetRange.Columns(i).EntireColumn.Hidden
    Next i

    SaveHiddenColumns = result
End Function

Public Function RestoreHiddenColumns(targetRange As range, hiddenColumns() As Boolean) As Boolean
 Dim i As Long
 
    If targetRange Is Nothing Then Exit Function
    If targetRange.Columns.count <> UBound(hiddenColumns) Then Exit Function

    For i = 1 To UBound(hiddenColumns)
        targetRange.Columns(i).EntireColumn.Hidden = hiddenColumns(i)
    Next i
End Function

Public Function AddErrToComment(entity As ZEWSProxy.DataDirectEntity) As Long
 Dim rgn As range
 Dim cmt As Comment
 
    Set rgn = CDDXUtility.GetRange(DDX_PID, entity)
    If rgn Is Nothing Then
        AddErrToComment = -1
        Exit Function
    End If
    
    Set cmt = rgn.Cells(1, 1).Comment
    
    If Len(entity.executeResult.errorMessage) = 0 Then
        If Not cmt Is Nothing Then cmt.Delete
        Exit Function
    End If
    
'    If entity.executeResult.CaptionRowsCount <= 0 Then Exit Function
    
    If cmt Is Nothing Then Set cmt = rgn.Cells(1, 1).AddComment
    
    With cmt
        .Shape.TextFrame.AutoSize = True
        .Shape.TextFrame.Characters.Font.ColorIndex = 3

        Call .text(entity.executeResult.errorMessage)
        .Visible = True
    End With
    
    AddErrToComment = 1
End Function

Public Sub DeleteRefreshingComment(entity As ZEWSProxy.DataDirectEntity)
 Dim rgn As range
 Dim targetRange As range
 Dim targetRangeAtLastRow As range
 Dim refreshingComment As Comment

    Set rgn = CDDXUtility.GetRange(DDX_PID, entity)
    If rgn Is Nothing Then Exit Sub

    Set targetRange = rgn.Cells(1, 1)
    Set targetRangeAtLastRow = rgn.Cells(rgn.rows.count, 1)

    Set refreshingComment = targetRange.Comment
    If Not refreshingComment Is Nothing Then Call refreshingComment.Delete

    Set refreshingComment = targetRangeAtLastRow.Comment
    If Not refreshingComment Is Nothing Then refreshingComment.Delete
End Sub

Public Function GetDocCreatorVer(Wb As Workbook) As Long
 Dim a() As String
 Dim v As String
 
    v = CSheet.DOCGetProp(Wb, ZEDOC_VER_CREATOR)
    If v = vbNullString Then v = CSheet.DOCGetProp(Wb, ZEDOC_VER)
    If Len(v) = 0 Then
        GetDocCreatorVer = 418
    Else
        a = Split(v, ".")
        If UBound(a) < 1 Then
            GetDocCreatorVer = 417
        Else
            GetDocCreatorVer = 100 * Int(Val(a(0))) + Int(Val(a(1)))
        End If
    End If
End Function

Public Function NewNamedRange(Wb As Workbook, nrName As String, referedRgn As range) As name
 Dim visibility As Boolean
 
    Set NewNamedRange = Wb.Names.Add(name:=nrName, RefersTo:=referedRgn)
    
    If CDDXHelper.NRVisibilityExists(Wb) Then
        visibility = CDDXHelper.GetNRVisibility(Wb)
    Else
        visibility = IIf(GetDocCreatorVer(Wb) <= 417, True, False)
    End If
    
    NewNamedRange.Visible = visibility
End Function

Public Sub RemoveRefreshIndicator(Wb As Workbook, ByVal tsk As String)
 Dim nm As name
 Dim cmt As Comment
 Dim fr As range
 Dim entity As DataDirectEntity
 
    On Error GoTo OOPS
    
    Set entity = CDDXEntity.GetEntityByTaskId(DDX_PID, tsk, fr)
    If entity Is Nothing Then Exit Sub
    
    Set nm = Wb.Names(entity.ExcelRangeName)
    If Not nm Is Nothing Then
        Set cmt = nm.RefersToRange.Cells(1, 1).Comment
        If Not cmt Is Nothing Then
            cmt.Delete
        End If
    End If
    
OOPS:
    If Err.Number <> 0 Then
    
    End If
    Exit Sub
End Sub

Private Function GetMaxCellLength(rng As range) As Long
 Dim eval As String
 Const MCIC = 255
 
    eval = "Max(len(" + rng.Address + "))"
    GetMaxCellLength = Evaluate(eval)
    
    If GetMaxCellLength > MCIC Then GetMaxCellLength = MCIC
End Function

Public Sub AdjustColumnWidths(ByVal isSingleHeader As Boolean, targetRange As range)
 Dim c As Long
 Dim rgn As range
 Dim cwid
  
    If isSingleHeader Then
        With targetRange
            For c = .Columns.count To 1 Step -1
                Set rgn = .Cells(1, c).Resize(.rows.count)
                cwid = GetMaxCellLength(rgn)
                rgn.ColumnWidth = IIf(cwid > 0, cwid, 8.43)
            Next
        End With
    Else
        targetRange.WrapText = False
    End If
    
    targetRange.Columns.AutoFit
End Sub

Public Sub AdjustRowHeights(entity As ZEWSProxy.DataDirectEntity, targetRange As range)
 Dim hrows As Long
 
    If entity Is Nothing Then
        Call targetRange.rows.AutoFit
        
    Else
        With entity
            If .IsVertical Then
                If .entityOption.HeaderOption <> HeaderOption_SingleRow Then Exit Sub
                
                hrows = .executeResult.HeaderRowsCount + .executeResult.CaptionRowsCount
                If hrows <= 0 Then Exit Sub
                
                Call targetRange.Resize(hrows).rows.AutoFit
            Else
                If .entityOption.HeaderOption <> HeaderOption_SingleRow Then Exit Sub
                Call targetRange.rows.AutoFit
            End If
        End With
    End If
End Sub

Public Function IsDateCell(ByVal r As range) As Boolean
 Dim fmt As String
 
    fmt = r.NumberFormat
    IsDateCell = IIf(StrComp(fmt, "@") <> 0 And StrComp(fmt, "General", vbTextCompare) <> 0, True, False)
End Function

Public Sub ClearErr()
    If Err.Number = 0 Then Exit Sub
    
    CDDXApp.DebugMessage = "External Error: " + CStr(Err.Number) + ", " + Err.Description
    Err.Clear
End Sub
Attribute VB_Name = "CEvents"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Dim WithEvents m_login As CDDXLogin
Attribute m_login.VB_VarHelpID = -1
Dim WithEvents m_App As CDDXApp
Attribute m_App.VB_VarHelpID = -1

Private Sub Class_Initialize()
    Set m_login = CDDXLogin
    Set m_App = CDDXApp
End Sub

Private Sub SetDocSignatures(Wb As Workbook)
    On Error Resume Next

    If CSheet.ZEDocID(Wb) <> vbNullString Then Exit Sub
          
    CSheet.ZEDocID(Wb) = CDDXLib.DefaultZEWSProxy(BSConsts.DDX_PID).NewGUID()
    Call CDDXHelper.MarkZEDoc(DDX_PID, Wb)

    On Error GoTo 0
End Sub

Private Sub m_App_OnDuplicateSheet(sh As Worksheet, newSh As Worksheet)
 Dim f As CustomProperty
 
    On Error GoTo OOPS
          
    If CDDXHelper.IsCurveSheet(sh) Or CDDXHelper.IsUploadSheet(sh) Or CDDXHelper.IsEntitySheet(sh) Then
        If newSh.Parent.name <> sh.Parent.name Then
            Call SetDocSignatures(newSh.Parent)
        End If
              
        For Each f In sh.CustomProperties
            Call CSheet.WSSetProp(newSh, f.name, f.value)
        Next
        CSheet.ZESheetID(newSh) = CDDXHelper.NewGUID()
    End If
          
    If CDDXHelper.IsEntitySheet(sh) Then
        Dim entities As ZEWSProxy.DataDirectEntities
        Dim xml As String
        Dim item As Variant
        Dim entity As ZEWSProxy.DataDirectEntity
        
        If (Len(CDDXHelper.ZESheetID(BSConsts.DDX_PID, newSh)) > 0) Then
            xml = CEntityHelper.ZESheetSavedEntities(newSh)
            If (Len(xml) > 0) Then
                Set entities = New ZEWSProxy.DataDirectEntities
                Set entities = entities.FromXML(xml, CSheet.DOCGetProp(sh.Parent, ZEDOC_VER_CREATOR))
                Call entities.SetSheetId(CSheet.ZESheetID(newSh))
                
                Dim excelName As name
                Dim resultRange As range
                Dim i As Long
                
                For Each item In entities.GetEntities
                    Set entity = item
                    i = i + 1
                    If entity.entityOption.ResultType = ResultType_QueryTable Then
                        Set excelName = CDDXUtility.GetExcelNameFromSheet(newSh, entity.ExcelRangeName)
                        If Not excelName Is Nothing Then
                            Set resultRange = CDDXUtility.GetExcelNameResultRange(excelName)
                            If Not resultRange Is Nothing Then
                                entity.ExcelRangeName = entity.GenerateExcelRangeName + "_" + CStr(i)
                                resultRange.Worksheet.Activate
                                excelName.Delete
                                Call CEntityHelper.NewNamedRange(resultRange.Worksheet.Parent, entity.ExcelRangeName, resultRange)
                                Call CEntityHelper.AddOrUpdateEntityRangeCache(entity, resultRange)
                            End If
                        End If
                    Else
                        Dim tableObject As ListObject
                        
                        For Each tableObject In newSh.ListObjects
                            If InStr(tableObject.name, entity.ExcelRangeName) > 0 Then
                                entity.ExcelRangeName = entity.GenerateExcelRangeName + "_" + CStr(i)
                                tableObject.name = entity.ExcelRangeName
                                Call CEntityHelper.AddOrUpdateEntityRangeCache(entity, tableObject.range)
                                Exit For
                            End If
                        Next
                    End If
                Next
                      
                Call DDXObjects.EntityObject.AllEntities(BSConsts.DDX_PID).AddEntities(entities)
                Call CDDXEntity.PersistEntities(DDX_PID, True, Application.ActiveWorkbook, Nothing)
            End If
        End If
    End If

OOPS:
    If Err.Number <> 0 Then
        Call CDDXHelper.LogError(Err.Description, "m_App_OnDuplicateSheet")
    End If

    Exit Sub
End Sub

Private Sub m_App_OnDuplicateWorkbook(wk As Workbook)
    Call CDDXApp.DialogMessage("Duplicate document found.")
End Sub

Private Sub m_login_OnAfterLogin(sender As Object)
    Call CCurveControl.ClearFlags
    
    Call CVarHelper.GetVars
    Call CDDXCurve.OnLogin(DDX_PID)
End Sub

Private Sub m_login_OnAfterLogout(sender As Object)
    Call CCurveControl.ClearFlags
End Sub

Private Sub m_login_OnPasswordExpired(sender As Object)
    Call CCurveControl.ClearFlags
End Sub
Attribute VB_Name = "CFingerprint"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Type SYSTEMTIME
   wYear As Integer
   wMonth As Integer
   wDayOfWeek As Integer
   wDay As Integer
   wHour As Integer
   wMinute As Integer
   wSecond As Integer
   wMilliseconds As Integer
End Type

#If Win64 Then
Private Type SYSTEM_INFO
    wProcessorArchitecture As Long
    wReserved As Long
    dwPageSize As LongLong
    lpMinimumApplicationAddress As LongPtr
    lpMaximumApplicationAddress As LongPtr
    dwActiveProcessorMask As LongPtr
    dwNumberOrfProcessors As LongLong
    dwProcessorType As LongLong
    dwAllocationGranularity As LongLong
    dwReserved As LongLong
End Type

Private Type TIME_ZONE_INFORMATION
    Bias As Long
    StandardName(0 To 63) As Byte
    StandardDate As SYSTEMTIME
    StandardBias As Long
    DaylightName(0 To 63) As Byte
    DaylightDate As SYSTEMTIME
    DaylightBias As Long
End Type

#ElseIf VBA7 Then
Private Type SYSTEM_INFO
    wProcessorArchitecture As Integer
    wReserved As Integer
    dwPageSize As Long
    lpMinimumApplicationAddress As Long
    lpMaximumApplicationAddress As Long
    dwActiveProcessorMask As Long
    dwNumberOrfProcessors As Long
    dwProcessorType As Long
    dwAllocationGranularity As Long
    dwReserved As Long
End Type

Private Type TIME_ZONE_INFORMATION
    Bias As Long
    StandardName(0 To 63) As Byte
    StandardDate As SYSTEMTIME
    StandardBias As Long
    DaylightName(0 To 63) As Byte
    DaylightDate As SYSTEMTIME
    DaylightBias As Long
End Type

#End If

#If Win64 Then
Private Declare PtrSafe Sub GetNativeSystemInfo Lib "kernel32" (lpSystemInfo As SYSTEM_INFO)
Private Declare PtrSafe Function GetSystemMetrics Lib "user32.dll" (ByVal nIndex As LongLong) As LongLong
Private Declare PtrSafe Function GetTimeZoneInformationForYear Lib "kernel32" (wYear As Long, ByVal pTZI As LongPtr, pTimeZoneInformation As TIME_ZONE_INFORMATION) As LongLong
Private Declare PtrSafe Function IsOS Lib "Shlwapi.dll" (ByVal nIndex As LongLong) As LongLong
Private Declare PtrSafe Function GetLocaleInfo Lib "kernel32" Alias "GetLocaleInfoA" (ByVal Locale As Long, ByVal LCType As Long, ByVal lpLCData As String, ByVal cchData As Long) As Long

#ElseIf VBA7 Then
Private Declare PtrSafe Sub GetNativeSystemInfo Lib "kernel32" (lpSystemInfo As SYSTEM_INFO)
Private Declare PtrSafe Function GetSystemMetrics Lib "user32.dll" (ByVal nIndex As Long) As Long
Private Declare PtrSafe Function GetTimeZoneInformationForYear Lib "kernel32" (wYear As Integer, ByVal pTZI As Long, pTimeZoneInformation As TIME_ZONE_INFORMATION) As Long
Private Declare PtrSafe Function IsOS Lib "Shlwapi.dll" (ByVal nIndex As Long) As Long
Private Declare PtrSafe Function GetLocaleInfo Lib "kernel32" Alias "GetLocaleInfoA" (ByVal Locale As Long, ByVal LCType As Long, ByVal lpLCData As String, ByVal cchData As Long) As Long

#End If

Private Const OBJECT_WINMGMTS As String = "Winmgmts:root\default:StdRegProv"

'Private Const PROCESSOR_INTEL_386 = 386
'Private Const PROCESSOR_INTEL_486 = 486
'Private Const PROCESSOR_INTEL_PENTIUM = 586
'Private Const PROCESSOR_MIPS_R4000 = 4000
'Private Const PROCESSOR_ALPHA_21064 = 21064
Private Const HKEY_CURRENT_USER = &H80000001
Private Const HKEY_LOCAL_MACHINE = &H80000002

Private m_handle As Integer

Public Function GetAddinInfoCollection(extraInfo As Collection) As Collection
 Dim bit64 As Boolean
 Dim cultureName As String
 Dim shortDateFormat As String
 Dim isAddLabel As Boolean
 Dim result As Collection
 Dim k As Long

    Set result = New Collection
    Call GetDDInfo(result)
    
    Call Add(result, "DDX", ThisWorkbook.BuiltinDocumentProperties("Title") + _
                              IIf(InStr(1, ThisWorkbook.FullName, Environ("ProgramFiles(X86)"), vbTextCompare) <= 0, "    (Just me)", vbNullString)) 'UCase(Environ("username"))
    Call Add(result, "Revisions", CDDXApp.DDXCodeRevision(Nothing) + " (" + ThisWorkbook.name + ")")
    Call Add(result, vbNullString, CDDXApp.ZEWSProxyRevision() + " (ZEWSProxy.dll)")
    
    For k = 1 To extraInfo.count
        Call Add(result, vbNullString, extraInfo.item(k))
    Next
    
    'Call GetDDInfo(result)
    
    If Application.OrganizationName <> vbNullString Then
        Call Add(result, "Organization", Application.OrganizationName)
    End If
    Call Add(result, "OS", OSServicePack)
    If IsOS(33) <> 0 Then Call Add(result, "Tablet PC", "Yes")
    If GetSystemMetrics(&H1000) <> 0 Then Call Add(result, "Remote Session", "Yes")
    Call GetSecuritySettings(result)
    Call PopulateHardwareInfo(result)
#If Win64 Then
    bit64 = True
#Else
    bit64 = False
#End If

    Call Add(result, Application.name, Application.Version + "." + CStr(Application.Build) + "  (" + IIf(bit64, "64", "32") + "-bit)")
    'Call Add(result, "Locale", Application.LanguageSettings.LanguageID(MsoAppLanguageID.msoLanguageIDHelp))
    Call AddLocale(result)
    Call CDDXDates.GetDateInfo(cultureName, shortDateFormat)
    Call Add(result, "Culture Name", cultureName)
    Call Add(result, "TimeZone", TimeZone)
    Call Add(result, "Date Format", Replace(shortDateFormat, "\/", "/"))

    isAddLabel = AddAddins(result)
    Call AddCOMAddins(HKEY_LOCAL_MACHINE, result, isAddLabel)
    Call AddCOMAddins(HKEY_CURRENT_USER, result, isAddLabel)
    
    Set GetAddinInfoCollection = result
End Function

Private Function IsOPENKey(nm, typ) As Boolean
 Dim ll As Long
 
    On Error GoTo OOPS
    
    If typ <> 1 And typ <> 2 And typ = 7 Then Exit Function
    If InStr(1, nm, "OPEN", vbTextCompare) <> 1 Then Exit Function
    If Len(nm) > 4 Then ll = CInt(Mid(nm, 5))
    
    IsOPENKey = True
    
OOPS:
    Exit Function
End Function

Private Function GetOPENValue(ByVal fv As String) As String
 Dim ll As Long
 Dim k As Long
 
    On Error GoTo OOPS
    
    ll = Len(fv)
    If ll = 0 Then Exit Function
 
    For k = ll To 1 Step -1
        If Mid(fv, k, 1) = "\" Then
            GetOPENValue = right(fv, ll - k)
            ll = Len(GetOPENValue)
            If right(GetOPENValue, 1) = """" Then GetOPENValue = left(GetOPENValue, ll - 1)
            Exit For
        End If
    Next
OOPS:
    Exit Function
End Function

Private Function AddAddins(result As Collection) As Boolean
 Dim isAddLabel As Boolean
 Dim reg As Object
 Dim valueNames
 Dim types
 Dim keyPath As String
 Dim i As Long
 Dim fv As String
 
    On Error GoTo OOPS

    keyPath = "SOFTWARE\Microsoft\Office\" + Application.Version + "\Excel\Options"
    Set reg = GetObject(OBJECT_WINMGMTS)
    
    isAddLabel = True
    
    If reg.enumValues(HKEY_CURRENT_USER, keyPath, valueNames, types) = 0 Then
        For i = LBound(valueNames) To UBound(valueNames)
            If IsOPENKey(valueNames(i), types(i)) Then
                Call reg.GetStringValue(HKEY_CURRENT_USER, keyPath, valueNames(i), fv)
                fv = GetOPENValue(fv)
                If fv <> vbNullString Then Call Add(result, IIf(isAddLabel, "Add-ins", vbNullString), fv)
                isAddLabel = False
            End If
        Next
    End If

OOPS:
    If Err.Number <> 0 Then
        CDDXApp.StatusMessage = Err.Description
    End If
    
    Set reg = Nothing
    AddAddins = isAddLabel
    
    Exit Function
End Function

Private Sub GetSecuritySettings(result As Collection)
 Dim fws() As String
 Dim k As Long
 
    On Error GoTo OOPS
    
    fws = CDDXLib.DefaultZEWSProxy(DDX_PID).GetSecuritySettings()
    If Len(Join(fws)) = 0 Then Exit Sub
    
    For k = LBound(fws) To UBound(fws) - 1 Step 2
        Call Add(result, fws(k), fws(k + 1))
    Next
    
OOPS:
    If Err.Number <> 0 Then
        Call CDDXHelper.LogError(Err.Description, "GetSecuritySettings")
    End If
    
    On Error GoTo 0
    Exit Sub
End Sub

Private Function BytesToString(uniAry() As Byte) As String
 Dim ans As String
 Dim p As Long
    
    ans = StrConv(uniAry, vbUnicode)
    ans = StrConv(ans, vbFromUnicode)
    
    p = InStr(ans, Chr(0))
    If p > 0 Then ans = left(ans, p - 1)
    
    BytesToString = ans
 End Function
 
Public Property Get TimeZone() As String
 Dim s As TIME_ZONE_INFORMATION
 
    Call GetTimeZoneInformationForYear(year(Now), 0, s)
    TimeZone = BytesToString(s.StandardName)
    If s.Bias <> 0 Then
        TimeZone = TimeZone + "  (UTC" + IIf(s.Bias > 0, "-", "+") + format(Abs(s.Bias) \ 60, "00") + ":" + format(Abs(s.Bias) Mod 60, "00") + ")"
    End If
End Property

Private Function GetOSName(info As OSVERSIONINFO) As String
 Const WKSTATION As Integer = &H1
 
    If info.dwMajorVersion = 10 Then
        GetOSName = IIf(info.wProductType = WKSTATION, "Windows 10", "Windows Server 2016")
        
    ElseIf info.dwMajorVersion = 6 Then
        If info.dwMinorVersion = 3 Then
            GetOSName = IIf(info.wProductType = WKSTATION, "Windows 8.1", "Windows Server 2012 R2")
        ElseIf info.dwMinorVersion = 2 Then
            GetOSName = IIf(info.wProductType = WKSTATION, "Windows 8", "Windows Server 2012")
        ElseIf info.dwMinorVersion = 1 Then
            GetOSName = IIf(info.wProductType = WKSTATION, "Windows 7", "Windows Server 2008 R2")
        ElseIf info.dwMinorVersion = 0 Then
            GetOSName = IIf(info.wProductType = WKSTATION, "Windows Vista", "Windows Server 2008")
        End If
    End If
    
    If GetOSName = vbNullString Then GetOSName = "Windows " + CStr(info.dwMajorVersion) + "." + CStr(info.dwMinorVersion)
End Function

'Private Function DetectOS(ParamArray dwOS()) As Boolean
' Dim k As Long
'
'    For k = LBound(dwOS) To UBound(dwOS)
'        If IsOS(dwOS(k)) <> 0 Then
'            DetectOS = True
'            Exit Function
'        End If
'    Next
'End Function

Private Property Get OSServicePack() As String
 Dim info As OSVERSIONINFO
 Dim bits As Long
 
    info.dwOSVersionInfoSize = Len(info)
    Call GetVersionEx(info)
    
#If Win64 Then
    bits = 64
#Else
    bits = IIf(IsOS(30) <> 0, 64, 32)
#End If
'    If DetectOS(20) Then
'        OSServicePack = "Windows NT"
'    ElseIf DetectOS(21, 22, 23, 24, 29) Then
'        OSServicePack = "Windows Server"
'    Else
'        OSServicePack = "Windows XP"
'    End If
    
    OSServicePack = GetOSName(info) & " (" & bits & "-bit) " ' & info.dwMajorVersion & "." & info.dwMinorVersion
    If info.wServicePackMajor > 0 Then
        OSServicePack = OSServicePack & ",  Service Pack " & info.wServicePackMajor & "." & info.wServicePackMinor
    End If
End Property

Private Sub GetDDInfo(result As Collection)
 Dim lv() As ZEWSProxy.LabelValue
 Dim k As Integer
 Dim offset As Long
 Dim utc As String
 Const DL As String = "       :  "
                
    On Error GoTo OOPS
    If Not CDDXLogin.Loggedin Then Exit Sub
    
    lv = CDDXLib.GetDDInfo(BSConsts.DDX_PID)
    k = LBound(lv)
    Do
        If StrComp(lv(k).label, "Timezone id", vbTextCompare) = 0 Then
            utc = StrConv(lv(k).value, 3)

            If k + 1 <= UBound(lv) Then
                If StrComp(lv(k + 1).label, "Timezone offset", vbTextCompare) = 0 Then
                    k = k + 1
                    offset = Val(lv(k).value) \ 1000
                    If offset <> 0 Then
                        utc = utc + "  (UTC" + IIf(offset > 0, "+", "-") + format(Abs(offset) \ (60 * 60), "00") + ":" + format(Abs(offset) Mod (60), "00") + ")"
                    End If
                End If
                
            End If
            Call Add(result, IIf(k = LBound(lv), "DataDirect", vbNullString), utc)
            
        Else
            Call Add(result, IIf(k = LBound(lv), "DataDirect", vbNullString), StrConv(lv(k).label + ",  " + lv(k).value, 3))
            
        End If
        
        k = k + 1
        If k > UBound(lv) Then Exit Do
    Loop
    
    With DDXObjects.LoginObject
        If .CurrentUrl <> vbNullString Then
            Call Add(result, vbNullString, .CurrentUrl)
            Call GetUserTZ(result)
            
            If .CurrentUser <> vbNullString Then
            
            Else
                Call Add(result, vbNullString, "SSO")
            End If
        End If
    End With

OOPS:
    If Err.Number <> 0 Then
        Call CDDXHelper.LogError(Err.Description, "GetDDInfo")
    End If
    
    On Error GoTo 0
    Exit Sub
End Sub

Private Sub AddLocale(result As Collection)
 Dim langid As Long
 Dim cch As Long
 Dim buff As String * 32
 
    On Error GoTo OOPS
    langid = Application.LanguageSettings.LanguageID(MsoAppLanguageID.msoLanguageIDUI)

    cch = GetLocaleInfo(langid, &H59, buff, 32 - 1)
    If cch > 1 Then
        Call Add(result, "Language-UI", left(buff, cch))
    End If
    
    langid = Application.LanguageSettings.LanguageID(MsoAppLanguageID.msoLanguageIDExeMode)

    cch = GetLocaleInfo(langid, &H59, buff, 32 - 1)
    If cch > 1 Then
        Call Add(result, "Language-Execution", left(buff, cch))
    End If
    
OOPS:
    If Err.Number <> 0 Then
        CDDXApp.StatusMessage = Err.Description
    End If
    On Error GoTo 0
    Exit Sub
End Sub

Private Sub GetUserTZ(result As Collection)
 Dim ary() As ZEWSProxy.LabelValue
 Dim k As Long
 
    On Local Error GoTo OOPS
    
    With CDDXLogin
        
        ary = .UserPref(DDX_PID)
        For k = LBound(ary) To UBound(ary)
            If StrComp(ary(k).label, "USER_TIME_ZONE", vbTextCompare) = 0 Then
                Call Add(result, vbNullString, "User TZ,  " + ary(k).value)
                Exit Sub
            End If
        Next
    End With
    
OOPS:
    On Local Error GoTo -1
    Exit Sub
End Sub

Private Sub Add(result As Collection, ByVal name As String, ByVal value As String)
    Call result.Add(name + vbTab + value)
End Sub

Private Sub PopulateHardwareInfo(result As Collection)
 Dim cpu As String
 Dim sysinfo As SYSTEM_INFO
 Dim ms() As String
 Dim k As Long

    Call GetNativeSystemInfo(sysinfo)
    Select Case sysinfo.wProcessorArchitecture
        Case 9:
            cpu = "x64 (AMD or Intel)"
        Case 5:
            cpu = "ARM"
        Case 6:
            cpu = "Intel Itanium-based"
        Case 0:
            cpu = "x86"
        Case &HFFFF:
            cpu = "(unknown)"
    End Select

    Call Add(result, "CPU", cpu)
    
    ms = CDDXLib.DefaultZEWSProxy(DDX_PID).GetMemory()
    
    If Len(Join(ms)) > 0 Then
        For k = LBound(ms) To UBound(ms) Step 2
            Call Add(result, ms(k), ms(k + 1))
        Next
    End If
End Sub

Private Sub GetCOMAddinFriendlyName(hkey As Long, result As Collection, titleExists As Boolean, reg As Object, ByVal keyPath As String, ByVal addinKey As String)
 Dim lb
 Dim fn As String
 
    On Error GoTo OOPS

    lb = -1
    fn = vbNullString
    
    If reg.getDWORDValue(hkey, keyPath + "\" + addinKey, "LoadBehavior", lb) = 0 Then
        Call reg.GetStringValue(hkey, keyPath + "\" + addinKey, "FriendlyName", fn)
    End If
    
OOPS:
    If lb <> -1 Then
        If fn = vbNullString Then
            fn = addinKey
        End If
    End If
    
    If fn <> vbNullString Then
        Call Add(result, IIf(titleExists, "Loaded Add-ins", vbNullString), "[COM " + format(lb, IIf(lb >= 10, "00", " 0")) + "] " + CStr(fn))
        titleExists = False
    End If
    
    On Error GoTo 0
    Exit Sub
End Sub

Private Sub AddCOMAddins(hkey As Long, result As Collection, titleExists As Boolean)
 Dim reg As Object
 Dim valueNames
 Dim types
 Dim i As Long
 Dim keyPath As String
       
    On Error GoTo OOPS

    keyPath = "SOFTWARE\Microsoft\Office\Excel\AddIns"
    Set reg = GetObject(OBJECT_WINMGMTS)

    If reg.enumKey(hkey, keyPath, valueNames, types) = 0 Then
        If VarType(valueNames) Or vbString Then
            'If IsArray(valueNames) Then
            If VarType(valueNames) Or vbArray Then
                For i = LBound(valueNames) To UBound(valueNames)
                    Call GetCOMAddinFriendlyName(hkey, result, titleExists, reg, keyPath, valueNames(i))
                Next
            Else
                Call GetCOMAddinFriendlyName(hkey, result, titleExists, reg, keyPath, valueNames)
            End If
        End If
    End If
    
OOPS:
    If Err.Number <> 0 Then
        Call CDDXHelper.LogError(Err.Description, "AddCOMAddins")
    End If
    
    If Not reg Is Nothing Then Set reg = Nothing
    
    On Error GoTo -1
    Exit Sub
End Sub


Attribute VB_Name = "CMessageMethod"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Const METHOD_KEY As String = "MessageMethod"
Private Const DURATION_KEY As String = "MessageDuration"

Private Const MESSAGE_METHOD_DISABLED As Integer = 0
Private Const MESSAGE_METHOD_ENABLED As Integer = 1
Private Const MESSAGE_METHOD_DURATION As Integer = 2
Private Const MESSAGE_METHOD_POPUP As Integer = 3

Private m_method As Integer
Private m_duration As Integer

Public Function SetMethod(Method As Integer, durationInSeconds As Integer) As Boolean
    On Local Error GoTo OOPS
    
    Select Case Method
        Case MESSAGE_METHOD_DISABLED, MESSAGE_METHOD_ENABLED, MESSAGE_METHOD_DURATION, MESSAGE_METHOD_POPUP:
            Call CDDXHelper.PutToRegistry(METHOD_KEY, CStr(Method))
            Call CDDXHelper.PutToRegistry(DURATION_KEY, CStr(IIf(durationInSeconds < 0, 0, durationInSeconds)))
            
            m_method = Method
            m_duration = durationInSeconds
            
            SetMethod = True
    End Select
    
OOPS:
    On Local Error GoTo 0
    Exit Function
End Function

Public Property Get Duration() As Integer
    Duration = IIf(m_method = MESSAGE_METHOD_DURATION, m_duration, 0)
End Property

Public Property Get Method() As Integer
    Method = m_method
End Property

Public Property Get enabled() As Boolean
    enabled = IIf(m_method = MESSAGE_METHOD_DURATION Or m_method = MESSAGE_METHOD_ENABLED, True, False)
End Property

Public Property Get InPopup() As Boolean
    InPopup = IIf(m_method = MESSAGE_METHOD_POPUP, True, False)
End Property

Public Property Get Disabled() As Boolean
    Disabled = IIf(m_method = MESSAGE_METHOD_DISABLED, True, False)
End Property

Private Sub Class_Initialize()
    Call GetSettings
End Sub

Private Sub GetSettings()
    m_method = Val(CDDXHelper.GetFromRegistry(METHOD_KEY, "1"))
    m_duration = Val(CDDXHelper.GetFromRegistry(DURATION_KEY, "3"))
End Sub
Attribute VB_Name = "CProfile"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

'this is a PredeclaredId class, try NOT use class level variable(public or private) unless necessary

Public Event OnAfterProfileLoad(sender As Object, entity As CProfileInfo)

Private Function GetProfilesByWorkBook(Wb As Workbook) As ZEWSProxy.DataDirectEntities
10        On Error GoTo errorHandler

20        If Wb Is Nothing Then Set Wb = Application.ActiveWorkbook
30        If Wb Is Nothing Then Exit Function
          
          Dim result As ZEWSProxy.DataDirectEntities
40        Set result = CDDXEntity.GetEntitiesByWorkBook(BSConsts.DDX_PID, Wb)
50        If Not result Is Nothing Then
60            Set result = result.GetByEntityTypeName(TYPE_PROFILE)
70        End If
80        Set GetProfilesByWorkBook = result

90        On Error GoTo 0
100       Exit Function
errorHandler:
          Dim errorDescription As String, errorNumber As Long
110       errorDescription = "CDDXProfile.GetProfilesByWorkBook(), Line:" & str(Erl()) + " " + vbCrLf + Err.Description
120       errorNumber = Err.Number
          'your clean up codes here
130       Err.Raise errorNumber, , errorDescription
End Function

Public Function GetProfileCollection(Wb As Workbook) As Collection
 Dim result As Collection
 Dim entities As ZEWSProxy.DataDirectEntities
 Dim entity As ZEWSProxy.DataDirectEntity
 Dim item As Variant
 Dim Profile As CProfileInfo
 
    Set entities = GetProfilesByWorkBook(Wb)
    If entities Is Nothing Then Exit Function
    
    For Each item In entities.GetEntities
        Set entity = item
        
        If Not entity.entityOption.IsOneTimeRequest Then
            If result Is Nothing Then
                Set result = New Collection
            End If
                
            Set Profile = NewCProfileData(BSConsts.DDX_PID, entity)
            Call result.Add(Profile)
        End If
    Next
    
    Set GetProfileCollection = result
End Function

Public Function NewCProfileData(ByVal pid As String, entity As ZEWSProxy.ProfileDataEntity) As CProfileInfo
    If Not CDDXApp.IsPX(pid) Then Exit Function
          
    Call CDDXEntity.SetParams(BSConsts.DDX_PID, entity)
    Set NewCProfileData = New CProfileInfo
End Function

Public Function RefreshProfile(Profile As CProfileInfo) As Boolean
 Dim entity As ZEWSProxy.ProfileDataEntity
 
    If Not CDDXLogin.Loggedin Then Exit Function

    Set entity = CDDXEntity.AllEntities(BSConsts.DDX_PID).GetByTaskId(Profile.entityID)

    If entity Is Nothing Then Exit Function

    If Profile.UseDynamicDates Then
        entity.EntityObject.entityOption.DateInputOption = DateInputOption_QuickDate
        entity.EntityObject.entityOption.SelectedQuickDate = Profile.DynamicDate

    ElseIf Profile.UseCustomDates Then
        With entity.EntityObject.entityOption
            .DateInputOption = DateInputOption_DirectInput
            .InputStartDate = Profile.startDate
            .InputEndDate = Profile.enddate
            Call .SetRollingOption(.RollingOption)
        End With

    ElseIf Profile.UseProfileDates Then
        entity.EntityObject.entityOption.DateInputOption = DateInputOption_Default
    End If

    If Profile.UseForecastDate Then
        entity.ForecastDate = Profile.ForecastDate
    End If

    If Profile.UseShiftEffectiveDate Then
        entity.shiftEffectiveDate = IIf(Profile.IsEmptyDate(Profile.shiftEffectiveDate), vbNullString, format(Profile.shiftEffectiveDate, "mm\/dd\/yyyy"))
    End If

    If Profile.UseProfileName Then
        entity.ProfileName = Profile.ProfileName
    End If

    If Profile.UseProfileTemplateName Then
        entity.ProfileTemplateName = Profile.ProfileTemplateName
    End If

    If Profile.UseProfileGroup Then
        entity.groupName = Profile.groupName
    End If

    If Profile.UseProfileGroupTemplate Then
        entity.TemplateGroupName = Profile.groupTemplateName
    End If

    If Profile.UseProfileOwnerName Then
        If entity.OwnerUserName <> Profile.OwnerName Then
            entity.OwnerUserName = Profile.OwnerName
            entity.OwnerUserId = 0
        End If
    End If

    If Profile.UseProfileOwnerID Then
        If entity.OwnerUserId <> Profile.OwnerID Then
            entity.OwnerUserName = vbNullString
            entity.OwnerUserId = Profile.OwnerID
        End If
    End If

    entity.EntityObject.tag = Profile.tag
    entity.EntityObject.IsAPI = True
    
    If Profile.UseIncrementalRefresh Then
        RefreshProfile = CDDXEntity.IncrementalRefreshEntity(BSConsts.DDX_PID, entity)
    Else
        RefreshProfile = CDDXEntity.RefreshEntity(BSConsts.DDX_PID, entity)
    End If

End Function

Public Sub RaiseOnAfterProfileLoad(pid As String, entity As ZEWSProxy.ProfileDataEntity)
10        On Error GoTo errorHandler

20        If Not CDDXApp.IsPX(pid) Then Exit Sub
          
          Dim Profile As CProfileInfo
30        Set Profile = NewCProfileData(BSConsts.DDX_PID, entity)
40        RaiseEvent OnAfterProfileLoad(Me, Profile)

50        On Error GoTo 0
60        Exit Sub
errorHandler:
          Dim errorDescription As String, errorNumber As Long
70        errorDescription = "CDDXProfile.RaiseOnAfterProfileLoad(), Line:" & str(Erl()) + " " + vbCrLf + Err.Description
80        errorNumber = Err.Number
          'your clean up codes here
90        Err.Raise errorNumber, , errorDescription
End Sub

Public Function GetProfileDataWithEffectiveDate(profileOwner As String, ProfileName As String, configName As String, effectiveDate As Date, startDate As Date, enddate As Date, ForecastDate As Date, tradeDateStart As Date, tradeDateEnd As Date, maxResults As Integer, order As String, Optional isReturnArray = False) As Variant
10        On Error GoTo errorHandler

50        GetProfileDataWithEffectiveDate = GetDataWithEffectiveDate(profileOwner, "", ProfileName, configName, effectiveDate, startDate, enddate, ForecastDate, tradeDateStart, tradeDateEnd, maxResults, order, isReturnArray)

60        On Error GoTo 0
70        Exit Function
errorHandler:
          Dim errorDescription As String, errorNumber As Long
80        errorDescription = "CDDXProfile.GetProfileDataWithEffectiveDate(), Line:" & str(Erl()) + " " + vbCrLf + Err.Description
90        errorNumber = Err.Number
          'your clean up codes here
100       Err.Raise errorNumber, , errorDescription
End Function

Public Function GetDataWithEffectiveDate(profileOwner As String, ProfileGroup As String, ProfileName As String, configName As String, effectiveDate As Date, startDate As Date, enddate As Date, ForecastDate As Date, tradeDateStart As Date, tradeDateEnd As Date, maxResults As Integer, order As String, Optional isReturnArray = False) As Variant
    If StrComp(order, "DESC", vbTextCompare) <> 0 Then
        order = "ASC"
    End If
          
    GetDataWithEffectiveDate = CDDXLib.DefaultZEWSProxy(BSConsts.DDX_PID).GetProfileDataWithEffectiveDate(CDDXLogin.sid, profileOwner, ProfileGroup, ProfileName, configName, effectiveDate, order, maxResults, startDate, enddate, ForecastDate, tradeDateStart, tradeDateEnd)
    If isReturnArray = False Then
        Dim i As Long, j As Long, result As String, stringArray() As String
        stringArray = GetDataWithEffectiveDate
        For i = LBound(stringArray, 1) To UBound(stringArray, 1)
            For j = LBound(stringArray, 2) To UBound(stringArray, 2)
                result = result + """" + Replace(stringArray(i, j), """", """""") + """"
                If (j < UBound(stringArray, 2)) Then
                    result = result + ","
                End If
            Next
            result = result + vbCrLf
        Next
        GetDataWithEffectiveDate = result
    End If
End Function
Attribute VB_Name = "CProfileInfo"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public tag As String

'---- in common block ---'
Private m_Moniker As String

Private m_startDate As Date
Private m_endDate As Date
Private m_ForecastDate As Date

'
Private Const TYPE_PROFILE As Long = &H1
Private Const TYPE_PROFILE_INCREMENTAL As Long = &H2
Private Const TYPE_REPORT As Long = &H10
Private Const TYPE_SMARTMART As Long = &H100

'
Private Const USE_PROFILE_DATES As Long = &H1
Private Const USE_DYNAMIC_DATE As Long = &H2
Private Const USE_CUSTOM_DATES As Long = &H4
Private Const USE_FORECAST_DATE As Long = &H8
Private Const USE_SHIFT_EFFECTIVE_DATE As Long = &H10
'
Private Const USE_PROFILE_TEMPLATE_NAME As Long = &H20
Private Const USE_PROFILE_NAME As Long = &H40
Private Const USE_PROFILE_GROUP_TEMPLATE As Long = &H80
Private Const USE_PROFILE_GROUP As Long = &H100
Private Const USE_PROFILE_OWNER_NAME As Long = &H200
Private Const USE_PROFILE_OWNER_ID As Long = &H400
Private Const USE_PROFILE_INCREMENTAL_REFRESH As Long = &H800

Private m_flag_use_field As Long
Private m_flag_entity_attribs As Long

'
Private m_DynamicDate As String
Private m_ExcelRangeName As String
Private m_EntityId As String
'
Private m_ErrorMessage As String
Private m_IsLoading As Boolean
Private m_LastRun As Date

'specific to profile
Private m_OwnerName As String
Private m_OwnerID As Long
Private m_GroupName As String
Private m_GroupTemplateName As String
Private m_ProfileName As String
Private m_ProfileTemplateName As String
Private m_ShiftEffectiveDate As String

'specific to report
Private m_DataSourceValue As String
Private m_DataReportValue As String
Private m_DataObservationValues() As String
Private m_DataSource As String
Private m_DataReport As String
Private m_DataObservations() As String

#If SMARTMAT_USE Then
'specific to smart mart
Private m_SmartMartLabel As String
Private m_SmartMartModelLabel As String
#End If

Private m_container As Worksheet

'*** entity type
Private Function TestEntity(ByVal entityFlag As Long) As Boolean
    TestEntity = IIf((m_flag_entity_attribs And entityFlag) <> 0, True, False)
End Function

Public Property Get IsProfile() As Boolean
    IsProfile = TestEntity(TYPE_PROFILE)
End Property

Public Property Get IsReport() As Boolean
    IsReport = TestEntity(TYPE_REPORT)
End Property

Public Property Get IsSmartMart() As Boolean
    IsSmartMart = TestEntity(TYPE_SMARTMART)
End Property

'***
Private Sub SetUseField(ByVal fieldFlag As Long)
    m_flag_use_field = m_flag_use_field Or fieldFlag
End Sub

Private Sub ClearUseField(ByVal fieldFlag As Long)
    m_flag_use_field = m_flag_use_field And (Not fieldFlag)
End Sub

Private Function TestUseField(ByVal fieldFlag As Long) As Boolean
    TestUseField = IIf((m_flag_use_field And fieldFlag) <> 0, True, False)
End Function

Public Property Get Identifier() As String
    Identifier = m_Moniker
End Property

'------------------ specific to profile ------------------
Public Property Let UseProfileDates(ByVal value As Boolean)
    If Not IsProfile Then Exit Property
    
    If value Then
        Call SetUseField(USE_PROFILE_DATES)
        
        Call ClearUseField(USE_CUSTOM_DATES)
        Call ClearUseField(USE_DYNAMIC_DATE)
    Else
        Call ClearUseField(USE_PROFILE_DATES)
    End If
End Property

Public Property Get UseProfileDates() As Boolean
    If Not IsProfile Then Exit Property
    UseProfileDates = TestUseField(USE_PROFILE_DATES)
End Property
'----------------------------------------------------------

Public Property Let UseDynamicDates(ByVal value As Boolean)
    If value Then
        Call SetUseField(USE_DYNAMIC_DATE)
        
        Call ClearUseField(USE_CUSTOM_DATES)
        Call ClearUseField(USE_PROFILE_DATES)
    Else
        Call ClearUseField(USE_DYNAMIC_DATE)
    End If
End Property

Public Property Get UseDynamicDates() As Boolean
    UseDynamicDates = TestUseField(USE_DYNAMIC_DATE)
End Property

Public Property Let UseCustomDates(ByVal value As Boolean)
    If value Then
        Call SetUseField(USE_CUSTOM_DATES)
        
        Call ClearUseField(USE_DYNAMIC_DATE)
        Call ClearUseField(USE_PROFILE_DATES)
    Else
        Call ClearUseField(USE_CUSTOM_DATES)
    End If
End Property

Public Property Get UseCustomDates() As Boolean
    UseCustomDates = TestUseField(USE_CUSTOM_DATES)
End Property

Public Property Get DynamicDate() As String
    DynamicDate = m_DynamicDate
End Property

Public Property Let DynamicDate(value As String)
 Dim ary() As String
 Dim k As Long
    
    If Len(value) > 0 Then
        ary = CDDXDates.GetDynaDateNames()
        For k = LBound(ary) To UBound(ary)
            If StrComp(value, ary(k), vbTextCompare) = 0 Then
                m_DynamicDate = value
                Exit Property
            End If
        Next
        
        Err.Raise vbObjectError + 5000, , "Invalid dynamic date name"
    End If
End Property

Public Property Let UseForecastDate(value As Boolean)
    If value Then
        Call SetUseField(USE_FORECAST_DATE)
    Else
        Call ClearUseField(USE_FORECAST_DATE)
    End If
End Property

Public Property Get UseForecastDate() As Boolean
    UseForecastDate = TestUseField(USE_FORECAST_DATE)
End Property

Public Property Get ExcelRangeName() As String
    ExcelRangeName = m_ExcelRangeName
End Property

Public Property Get entityID() As String
    entityID = m_EntityId
End Property

Public Property Get errorMessage() As String
    errorMessage = m_ErrorMessage
End Property

Public Property Get IsLoading() As Boolean
    IsLoading = m_IsLoading
End Property

Public Property Get LastRun() As Date
    LastRun = m_LastRun
End Property

Private Sub Class_Initialize()
 Dim entity As ZEWSProxy.DataDirectEntity
 
    Set entity = CDDXEntity.GetParams(BSConsts.DDX_PID)
    If entity Is Nothing Then Exit Sub
    
    Call SetCommonFileds(entity)
    
    If CDDXUtility.IsProfileDataEntity(BSConsts.DDX_PID, entity) Then
        m_flag_entity_attribs = TYPE_PROFILE
        Call GetProfileSettings(entity)
        
    ElseIf CDDXUtility.IsReportDataEntity(BSConsts.DDX_PID, entity) Then
        m_flag_entity_attribs = TYPE_REPORT
        Call GetReportSettings(entity)
        
#If SMARTMAT_USE Then
    ElseIf CDDXUtility.IsSmartMartDataEntity(BSConsts.DDX_PID, entity) Then
        m_flag_entity_attribs = TYPE_SMARTMART
        Call GetSmartMartSettings(entity)
#End If
    End If
    
    Call CDDXEntity.SetParams(BSConsts.DDX_PID, Nothing)
End Sub

Private Sub SetCommonFileds(entity As ZEWSProxy.DataDirectEntity)
    m_Moniker = entity.Moniker
    
    m_EntityId = entity.EntityObject.taskID
    m_ExcelRangeName = entity.EntityObject.ExcelRangeName
    '
    m_ErrorMessage = entity.EntityObject.executeResult.errorMessage
    m_IsLoading = entity.EntityObject.IsLoading
    m_LastRun = entity.EntityObject.LastRunningTime
       
    m_DynamicDate = entity.EntityObject.entityOption.SelectedQuickDate
    startDate = entity.EntityObject.startDate
    enddate = entity.EntityObject.enddate
    
    Select Case entity.EntityObject.entityOption.DateInputOption
        Case DateInputOption_Default:
            UseProfileDates = True
        Case DateInputOption_QuickDate:
            UseDynamicDates = True
        Case DateInputOption_DirectInput:
            UseCustomDates = True
            startDate = entity.entityOption.InputStartDate
            enddate = entity.entityOption.InputEndDate
    End Select
    
    tag = entity.EntityObject.tag

    Set m_container = GetContainer(entity)
End Sub

Private Function GetContainer(entity As ZEWSProxy.DataDirectEntity) As Worksheet
 Dim rgn As range
 
    If entity Is Nothing Then Exit Function
    If entity.ExcelRangeName = vbNullString Then Exit Function
    
    On Local Error GoTo OOPS
    Set rgn = CDDXUtility.GetRange(BSConsts.DDX_PID, entity)
    If Not rgn Is Nothing Then
        Set GetContainer = rgn.Parent
    End If
    
OOPS:
    If Err.Number <> 0 Then
    
    End If
    On Local Error GoTo 0
    Exit Function
End Function

'profile
Private Sub GetProfileSettings(entity As ZEWSProxy.ProfileDataEntity)
    m_flag_entity_attribs = TYPE_PROFILE

    With entity
        m_OwnerName = .OwnerUserName
        m_OwnerID = .OwnerUserId
        m_GroupName = .groupName
        m_GroupTemplateName = .TemplateGroupName
        m_ProfileName = .ProfileName
        m_ProfileTemplateName = .templateName
        m_ShiftEffectiveDate = .shiftEffectiveDate
        ForecastDate = .ForecastDate

        With .EntityObject.entityOption
            ' NO incremental refresh for profiles w/local dynamic dates
            If .DateInputOption <> DateInputOption_QuickDate Then
                m_flag_entity_attribs = m_flag_entity_attribs Or TYPE_PROFILE_INCREMENTAL
            End If
        End With
    End With
End Sub

Public Property Get OwnerName() As String
    OwnerName = m_OwnerName
End Property

Public Property Get OwnerID() As Long
    OwnerID = m_OwnerID
End Property

Public Property Get groupName() As String
    groupName = m_GroupName
End Property

Public Property Get groupTemplateName() As String
    groupTemplateName = m_GroupTemplateName
End Property

Public Property Get ProfileName() As String
    ProfileName = m_ProfileName
End Property

Public Property Get ProfileTemplateName() As String
    ProfileTemplateName = m_ProfileTemplateName
End Property

Public Property Let OwnerName(value As String)
    m_OwnerName = value
End Property

Public Property Let OwnerID(value As Long)
    m_OwnerID = value
End Property

Public Property Let groupName(value As String)
    m_GroupName = IIf(value = vbNullString, "NOGROUP", value)
End Property

Public Property Let groupTemplateName(value As String)
    m_GroupTemplateName = IIf(value = vbNullString, value, value)
End Property

Public Property Let ProfileName(value As String)
    m_ProfileName = value
End Property

Public Property Let ProfileTemplateName(value As String)
    m_ProfileTemplateName = value
End Property

Public Property Get shiftEffectiveDate() As Date
 Dim y As Long
 Dim m As Long
 Dim d As Long
 
    If m_ShiftEffectiveDate = vbNullString Then Exit Property
    m = Val(left(m_ShiftEffectiveDate, 2))
    d = Val(Mid(m_ShiftEffectiveDate, 4, 2))
    y = Val(right(m_ShiftEffectiveDate, 4))
    
    shiftEffectiveDate = DateSerial(y, m, d)
End Property

Public Function IsEmptyDate(value As Date) As Boolean
    IsEmptyDate = IIf(year(value) < 1900, True, False)
End Function

Public Property Let shiftEffectiveDate(value As Date)
    If IsEmptyDate(value) Then
        m_ShiftEffectiveDate = vbNullString
    Else
        m_ShiftEffectiveDate = format(value, "mm\/dd\/yyyy")
    End If
End Property

Public Property Let UseShiftEffectiveDate(value As Boolean)
    If value Then
        Call SetUseField(USE_SHIFT_EFFECTIVE_DATE)
    Else
        Call ClearUseField(USE_SHIFT_EFFECTIVE_DATE)
    End If
End Property

Public Property Get UseShiftEffectiveDate() As Boolean
    UseShiftEffectiveDate = TestUseField(USE_SHIFT_EFFECTIVE_DATE)
End Property

Public Property Let UseProfileName(value As Boolean)
    If value Then
        Call SetUseField(USE_PROFILE_NAME)
    Else
        Call ClearUseField(USE_PROFILE_NAME)
    End If
End Property

Public Property Let UseProfileTemplateName(value As Boolean)
    If value Then
        Call SetUseField(USE_PROFILE_TEMPLATE_NAME)
    Else
        Call ClearUseField(USE_PROFILE_TEMPLATE_NAME)
    End If
End Property

Public Property Get UseProfileName() As Boolean
    UseProfileName = TestUseField(USE_PROFILE_NAME)
End Property

Public Property Get UseProfileTemplateName() As Boolean
    UseProfileTemplateName = TestUseField(USE_PROFILE_TEMPLATE_NAME)
End Property

Public Property Let UseProfileGroup(value As Boolean)
    If value Then
        Call SetUseField(USE_PROFILE_GROUP)
    Else
        Call ClearUseField(USE_PROFILE_GROUP)
    End If
End Property

Public Property Let UseProfileGroupTemplate(value As Boolean)
    If value Then
        Call SetUseField(USE_PROFILE_GROUP_TEMPLATE)
    Else
        Call ClearUseField(USE_PROFILE_GROUP_TEMPLATE)
    End If
End Property

Public Property Get UseProfileOwnerID() As Boolean
    UseProfileOwnerID = TestUseField(USE_PROFILE_OWNER_ID)
End Property

Public Property Let UseProfileOwnerID(value As Boolean)
    If value Then
        Call SetUseField(USE_PROFILE_OWNER_ID)
    Else
        Call ClearUseField(USE_PROFILE_OWNER_ID)
    End If
End Property

Public Property Get UseProfileGroup() As Boolean
    UseProfileGroup = TestUseField(USE_PROFILE_GROUP)
End Property

Public Property Get UseProfileGroupTemplate() As Boolean
    UseProfileGroupTemplate = TestUseField(USE_PROFILE_GROUP_TEMPLATE)
End Property

Public Property Let UseProfileOwnerName(value As Boolean)
    If value Then
        Call SetUseField(USE_PROFILE_OWNER_NAME)
    Else
        Call ClearUseField(USE_PROFILE_OWNER_NAME)
    End If
End Property

Public Property Get UseProfileOwnerName() As Boolean
    UseProfileOwnerName = TestUseField(USE_PROFILE_OWNER_NAME)
End Property

'report
Private Sub GetReportSettings(entity As ZEWSProxy.ReportDataEntity)
    m_DataSourceValue = entity.DataSourceValue
    m_DataReportValue = entity.DataReportValue
    m_DataObservationValues = entity.ObservationValues
    '
    m_DataSource = entity.DataSourceLabel
    m_DataReport = entity.DataReportLabel
    m_DataObservations = entity.ObservationLabels
End Sub

Public Property Get DataSourceValue() As String
    DataSourceValue = m_DataSourceValue
End Property

Public Property Get DataReportValue() As String
    DataReportValue = m_DataReportValue
End Property

Public Property Get DataObservationValues() As String()
    DataObservationValues = m_DataObservationValues
End Property

Public Property Get DataSource() As String
    DataSource = m_DataSource
End Property

Public Property Get DataReport() As String
    DataReport = m_DataReport
End Property

Public Property Get DataObservations() As String()
    DataObservations = m_DataObservations
End Property

#If SMARTMAT_USE Then
'smart mart
Private Sub GetSmartMartSettings(entity As ZEWSProxy.SmartMartDataEntity)
    m_SmartMartLabel = entity.SmartMartLabel
    m_SmartMartModelLabel = entity.SmartMartModelLabel
End Sub

'specific to smart mart
Public Property Get SmartMartLabel() As String
    SmartMartLabel = m_SmartMartLabel
End Property

Public Property Get SmartMartModelLabel() As String
    SmartMartModelLabel = m_SmartMartModelLabel
End Property
#End If

Private Function getDate(dte As Date) As Date
 Dim y As Long
 Dim m As Long
 Dim d As Long

    d = day(dte)
    m = month(dte)
    y = year(dte)

    getDate = DateSerial(y, m, d)
End Function

Public Property Let startDate(value As Date)
    m_startDate = value
End Property

Public Property Get startDate() As Date
    startDate = getDate(m_startDate)
End Property

Public Property Let enddate(value As Date)
    m_endDate = value
End Property
  
Public Property Get enddate() As Date
    enddate = getDate(m_endDate)
End Property

Public Property Let ForecastDate(value As Date)
    m_ForecastDate = value
End Property

Public Property Get ForecastDate() As Date
    ForecastDate = getDate(m_ForecastDate)
End Property

Public Function RefreshData() As Boolean
    If IsProfile Then
        RefreshData = CProfile.RefreshProfile(Me)

    ElseIf IsReport Then
        RefreshData = CReport.RefreshReport(Me)
        
#If SMARTMAT_USE Then
    ElseIf IsSmartMart Then
        RefreshData = CSmartMart.RefreshSmartMart(Me)
#End If
    End If
End Function

Public Property Get Container() As Worksheet
    Set Container = m_container
End Property

Public Property Get entityRange() As range
    If m_ExcelRangeName = vbNullString Then Exit Property
    If m_container Is Nothing Then Exit Property

    On Local Error GoTo OOPS

    Set entityRange = m_container.Parent.Names(m_ExcelRangeName)

OOPS:
    If Err.Number <> 0 Then
        CDDXApp.StatusMessage = Err.Description
    End If

    On Local Error GoTo -1
    Exit Property
End Property

Public Property Get IncrementalRefresh() As Boolean
    IncrementalRefresh = TestEntity(TYPE_PROFILE_INCREMENTAL)
End Property

Public Property Get UseIncrementalRefresh() As Boolean
    UseIncrementalRefresh = TestUseField(USE_PROFILE_INCREMENTAL_REFRESH)
End Property

Public Property Let UseIncrementalRefresh(value As Boolean)
    If Not IncrementalRefresh() Then
        Call Err.Raise(vbObjectError + 100, "Set UseIncrementalRefresh", "Incremental refresh not supported on specified profile.")
    End If

    If value Then
        Call SetUseField(USE_PROFILE_INCREMENTAL_REFRESH)
    Else
        Call ClearUseField(USE_PROFILE_INCREMENTAL_REFRESH)
    End If
End Property
Attribute VB_Name = "CRefreshIncremental"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Const ORDER_UNKNOWN As Long = 0
Private Const ORDER_ASC As Long = 1
Private Const ORDER_DESC As Long = 2

Private m_order As Long
Private m_header_rows As Long
Private m_targetRgn As range

Public Sub PerformAutofillFormulas(entity As ZEWSProxy.DataDirectEntity, ByVal formulaColumns As Long, entityRange As range)
 Dim dest As range
 Dim r As Long
 Dim c As Long
 Dim rowcnt As Long
 Dim cnt As Long
 Dim start As Long
 Dim lb As Long
 Dim ub As Long
 
    If formulaColumns <= 0 Then Exit Sub
    If Not GetBounds(entityRange, start, lb, ub) Then Exit Sub
    
    start = start + 1
    rowcnt = entityRange.rows.count
    
    If entity.entityOption.ResultType = ResultType_ListObject Then
        Set entityRange = entityRange.Resize(, entityRange.Columns.count - formulaColumns)
    End If
    
    For c = entityRange.Columns.count + 1 To entityRange.Columns.count + formulaColumns
        If Not CEntityHelper.ContainsFormula(entityRange.Cells(start, c)) Then
            For r = start + 1 To rowcnt
                If CEntityHelper.ContainsFormula(entityRange.Cells(r, c)) Then
                    Call entityRange.Cells(r, c).Copy(entityRange.Cells(start, c))
                    Exit For
                End If
            Next
        End If
        
        cnt = rowcnt - start + 1
        If cnt > 1 And CEntityHelper.ContainsFormula(entityRange.Cells(start, c)) Then
            Set dest = entityRange.Cells(start, c).Resize(cnt) 'destination range must include source range
            Call entityRange.Cells(start, c).AutoFill(dest, xlFillValues)
            
            If Application.Calculation <> xlCalculationAutomatic Then
                Call dest.Calculate
            End If
        End If
    Next
End Sub

Public Function GetAutofillFormulaColumns(entity As ZEWSProxy.DataDirectEntity, entityRange As range, ByVal redoSelection As Boolean) As Long
 Dim c As Long
 Dim r As Long
 Dim cnt As Long
 Dim hdrs As Long
 Dim lb As Long
 Dim ub As Long
 Dim found As Boolean
 Dim rowcnt As Long
 
    If Not entity.entityOption.IsFillFormulas Then Exit Function
    If Not entity.IsVertical Then Exit Function 'non-vertical is not supported
    
    If entity.entityOption.ResultType = ResultType_ListObject Then
        With entityRange
            For c = .Columns.count To 2 Step -1
                If Not CEntityHelper.ContainsFormula(.Cells(1, c)) Then Exit For
                cnt = cnt + 1
            Next
        End With
            
        If cnt = 0 Then
            With entityRange
                For c = .Columns.count To 2 Step -1
                    If Not CEntityHelper.ContainsFormula(.Cells(2, c)) Then Exit For
                    cnt = cnt + 1
                Next
            End With
        End If
 
    Else
        If Not GetBounds(entityRange, hdrs, lb, ub) Then Exit Function
        
        rowcnt = entityRange.rows.count
        hdrs = hdrs + 1
        
        With entityRange
            For c = .Columns.count + 1 To XL_MAX_COLUMNS
                found = CEntityHelper.ContainsFormula(.Cells(hdrs, c))
                If Not found Then
                    For r = hdrs + 1 To rowcnt
                        found = CEntityHelper.ContainsFormula(.Cells(r, c))
                        If found Then Exit For
                    Next
                End If
                
                If Not found Then Exit For
                cnt = cnt + 1
            Next
        End With
    End If
    
    If redoSelection And cnt > 0 Then
        Call Selection.Resize(, Selection.Columns.count - cnt).Select
    End If
        
    GetAutofillFormulaColumns = cnt
End Function

Public Function GetBounds(entityRgn As range, ByRef hdrRows As Long, ByRef startDateRow As Long, ByRef endDateRow As Long) As Boolean
 Dim cnt As Long
 
    cnt = entityRgn.rows.count
    
    For startDateRow = 1 To cnt
        If IsDateValue(entityRgn.Cells(startDateRow, 1)) Then Exit For
    Next
    If startDateRow > cnt Then Exit Function
    
    hdrRows = startDateRow - 1
    
    For endDateRow = cnt To 1 Step -1
        If IsDateValue(entityRgn.Cells(endDateRow, 1)) Then Exit For
    Next
    
    GetBounds = True
End Function

Public Function IsDateValue(r As Variant) As Boolean
    On Error GoTo OOPS
    
    If iserror(r) Then Exit Function
    
    If StrComp(TypeName(r), "range", vbTextCompare) = 0 Then
        If CEntityHelper.IsDateCell(r) And IsNumeric(r.Value2) Then
            IsDateValue = True
        End If
    Else
        IsDateValue = IsNumeric(r) And Not IsEmpty(r) And Not iserror(r)
    End If
    
OOPS:
    If Err.Number <> 0 Then
    
    End If
    Exit Function
End Function

Private Function GetAuthenticDate(dv As Variant, dtaRgn As range, ByVal r As Long, ByVal baseDate As Double, ByVal compareMethod As Long) As Long
 Dim cnt As Long
 
    If Not IsDateValue(dv) Then Exit Function
    
    If baseDate >= 1# Then
        If compareMethod = 1 Then
            If Int(dv) < Int(baseDate) Then Exit Function
        Else
            If Int(dv) > Int(baseDate) Then Exit Function
        End If
    End If
    
    cnt = WorksheetFunction.CountBlank(dtaRgn.rows(r))
    If cnt = dtaRgn.Columns.count Then Exit Function
                    
    GetAuthenticDate = Int(dv)
End Function

Private Sub FindFillDates(entity As ZEWSProxy.DataDirectEntity)
 Dim r As Long
 Dim cnt As Long
 Dim rgn As range
 Dim dtaRgn As range
 Dim lb As Long
 Dim ub As Long
 Dim dva As Variant
 Dim fd As Long
 Dim tmp As Long
 
    Set rgn = CDDXUtility.GetRange(DDX_PID, entity)
    If rgn Is Nothing Then Exit Sub
    
    If Not GetBounds(rgn, m_header_rows, lb, ub) Then Exit Sub
    
    dva = rgn.Resize(, 1).Value2
    
    'to detect order
    For r = lb To ub
        If IsDateValue(dva(r, 1)) Then
            tmp = Int(dva(r, 1))
            If fd = 0 Then
                fd = tmp
            ElseIf fd <> tmp Then
                m_order = IIf(fd < tmp, ORDER_ASC, ORDER_DESC)
                Exit For
            End If
        End If
    Next
        
    If m_order = ORDER_UNKNOWN Then
        If entity.dateOrder = DateOrder_ASC Then
            m_order = ORDER_ASC 'assume
        ElseIf entity.dateOrder = DateOrder_DESC Then
            m_order = ORDER_DESC
        Else
            m_order = Switch(entity.entityOption.InputDateOrder = DateOrder_DESC, ORDER_DESC, True, ORDER_ASC)
        End If
    End If
    
    cnt = entity.executeResult.DateColumnCount
    Set dtaRgn = rgn.Cells(1, cnt + 1).Resize(rgn.rows.count, rgn.Columns.count - cnt)
    
    If m_order = ORDER_ASC Then
        For r = lb To ub
            entity.SheetStartDate = GetAuthenticDate(dva(r, 1), dtaRgn, r, entity.DataStartDate, 1)
            If entity.SheetStartDate >= 1 Then Exit For
        Next
        
        For r = ub To lb Step -1
            entity.SheetEndDate = GetAuthenticDate(dva(r, 1), dtaRgn, r, entity.DataEndDate, -1)
            If entity.SheetEndDate >= 1 Then Exit For
        Next
        
    Else
        For r = lb To ub
            entity.SheetEndDate = GetAuthenticDate(dva(r, 1), dtaRgn, r, entity.DataEndDate, -1)
            If entity.SheetEndDate >= 1 Then Exit For
        Next
        
        For r = ub To lb Step -1
            entity.SheetStartDate = GetAuthenticDate(dva(r, 1), dtaRgn, r, entity.DataStartDate, 1)
            If entity.SheetStartDate >= 1 Then Exit For
        Next
    End If
End Sub

Public Function CollectSheetDates(entity As ZEWSProxy.DataDirectEntity) As Boolean
'*** the sheet dates are calculated based on data dates
    On Error GoTo OOPS
    
    CollectSheetDates = True
    
    m_order = ORDER_UNKNOWN
    
    With entity
        .SheetStartDate = 0
        .SheetEndDate = 0
        
        If .IsFromFormula Then Exit Function
        If .IsAPI Then Exit Function
        If .ExecutionRefreshType <> RefreshType_IncrementalFillRefresh And .ExecutionRefreshType <> RefreshType_IncrementalRefresh Then Exit Function
        
        Call FindFillDates(entity)
        
        If .SheetStartDate < 1# Or .SheetEndDate < 1# Then
            .ExecutionRefreshType = RefreshType_FullRefresh
        End If
        
        .SheetUserData = (.SheetUserData And (Not (ORDER_ASC Or ORDER_DESC))) Or m_order
    End With

OOPS:
    If Err.Number <> 0 Then
        CDDXApp.StatusMessage = Err.Description
        CollectSheetDates = False
    End If
    
    Exit Function
End Function

Private Function GetRolledOutRow(entity As ZEWSProxy.DataDirectEntity, oldEntityRange As range, ByVal isBegin As Boolean) As Long
 Dim r As Long
 Dim lb As Long
 Dim ub As Long
 Dim dva As Variant
 Dim stdate As Long
 
    On Error GoTo OOPS

    If Not GetBounds(oldEntityRange, m_header_rows, lb, ub) Then Exit Function
    
    dva = oldEntityRange.Resize(, 1).Value2
    m_order = (entity.SheetUserData And (ORDER_ASC Or ORDER_DESC))

    If m_order = ORDER_ASC Then
        stdate = Int(CDbl(IIf(isBegin, entity.startDate, entity.enddate)))
        
        If isBegin Then
            For r = lb To ub
                If IsDateValue(dva(r, 1)) Then
                    If stdate <= Int(dva(r, 1)) Then Exit For
                End If
            Next
            r = r - 1

            GetRolledOutRow = IIf(r <= m_header_rows, 0, r)
        Else
            For r = ub To lb Step -1
                If IsDateValue(dva(r, 1)) Then
                    If Int(dva(r, 1)) <= stdate Then Exit For
                End If
            Next
            r = r + 1
    
            GetRolledOutRow = IIf(r > ub, 0, r)
        End If
        
    Else
        stdate = Int(CDbl(IIf(isBegin, entity.enddate, entity.startDate)))
        
        If isBegin Then
            For r = lb To ub
                If IsDateValue(dva(r, 1)) Then
                    If stdate >= Int(dva(r, 1)) Then Exit For
                End If
            Next
            r = r - 1

            GetRolledOutRow = IIf(r = m_header_rows, 0, r)
        Else
            For r = ub To lb Step -1
                If IsDateValue(dva(r, 1)) Then
                    If Int(dva(r, 1)) >= stdate Then Exit For
                End If
            Next
            r = r + 1
    
            GetRolledOutRow = IIf(r > ub, 0, r)
        End If
    End If
    
OOPS:
    If Err.Number <> 0 Then
        CDDXApp.StatusMessage = Err.Description
    End If
    
    Exit Function
End Function

Public Function GetReplacedStartRow(entity As ZEWSProxy.DataDirectEntity, entityRange As range) As Long
 Dim r As Long
 Dim lb As Long
 Dim ub As Long
 Dim dva As Variant
 Dim found As Boolean
 Dim dt As Long
 
    On Error GoTo OOPS

    If Not GetBounds(entityRange, m_header_rows, lb, ub) Then Exit Function
    
    dva = entityRange.Resize(, 1).Value2
    m_order = (entity.SheetUserData And (ORDER_ASC Or ORDER_DESC))

    dt = Int(CDbl(entity.SheetEndDate))
    
    If m_order = ORDER_ASC Then
        For r = ub To lb Step -1
            If IsDateValue(dva(r, 1)) Then
                If dt > Int(dva(r, 1)) Then Exit For
            End If
        Next
 
        GetReplacedStartRow = r + 1
        
    Else
        For r = lb To ub
            If IsDateValue(dva(r, 1)) Then
                If dt > Int(dva(r, 1)) Then Exit For
            End If
        Next

        GetReplacedStartRow = r - 1
    End If
    
OOPS:
    If Err.Number <> 0 Then
        CDDXApp.StatusMessage = Err.Description
    End If
    
    Exit Function
End Function

Public Property Get HeaderRows() As Long
    HeaderRows = m_header_rows
End Property

Public Property Get IsOrderASC() As Boolean
    IsOrderASC = IIf(m_order = ORDER_ASC, True, False)
End Property

Private Sub RollTarget(entity As ZEWSProxy.DataDirectEntity)
 Dim r As Long
 Dim delta As Long
 Dim colcnt As Long
 
    With CRefreshIncremental
        colcnt = m_targetRgn.Columns.count
        
        r = GetRolledOutRow(entity, m_targetRgn, False)
        If r > 0 Then
            delta = m_targetRgn.rows.count - r + 1
            If m_targetRgn.rows.count > delta Then
                Set m_targetRgn = m_targetRgn.Resize(m_targetRgn.rows.count - delta)
            End If
        End If
        
        r = GetRolledOutRow(entity, m_targetRgn, True)
        If r > 0 And m_targetRgn.rows.count > r Then
            Call m_targetRgn.Cells(r + 1, 1).Resize(m_targetRgn.rows.count - r, colcnt).Copy(m_targetRgn.Cells(m_header_rows + 1, 1))
            delta = r - m_header_rows
            Set m_targetRgn = m_targetRgn.Resize(m_targetRgn.rows.count - delta)
        End If
    End With
End Sub

Private Function ReplaceRowCount(replrow As Long) As Long
    If CRefreshIncremental.IsOrderASC Then
        ReplaceRowCount = m_targetRgn.rows.count - replrow + 1

    Else
        ReplaceRowCount = replrow - CRefreshIncremental.HeaderRows
    End If
End Function

Public Sub Merge(entity As ZEWSProxy.DataDirectEntity, dataRange As range)
 Dim fmcols As Long
 
    Set dataRange = dataRange.Cells(entity.executeResult.CaptionAndHeaderRowsCount + 1, 1).Resize(entity.executeResult.DataRowsCount, dataRange.Columns.count)
    Set m_targetRgn = CDDXUtility.GetRangeByRangeName(entity.sheetId, entity.ExcelRangeName)
    fmcols = GetAutofillFormulaColumns(entity, m_targetRgn, False)
    
    If entity.dateOrder = DateOrder_DESC Then
        Call MergeDESC(entity, dataRange, fmcols)
    Else
        Call MergeASC(entity, dataRange, fmcols)
    End If
    
    Call PerformAutofillFormulas(entity, fmcols, m_targetRgn)
End Sub

Private Sub MergeASC(entity As ZEWSProxy.DataDirectEntity, dataRange As range, fmcols As Long)
 Dim ownedrows As Long
 Dim newrows As Long
 Dim replrow As Long
 Dim delta As Long
 Dim rgn As range
 Dim c As Long
 
    ownedrows = m_targetRgn.rows.count

    If entity.entityOption.ResultType = ResultType_ListObject Then
        Call CEntityHelper.UnlistTable(CDDXUtility.GetListObjectBysheetId(entity.sheetId, entity.ExcelRangeName))
    End If
    
    Call RollTarget(entity)
    
    replrow = CRefreshIncremental.GetReplacedStartRow(entity, m_targetRgn)
    delta = entity.executeResult.DataRowsCount - ReplaceRowCount(replrow)

    newrows = (m_targetRgn.rows.count + delta) - ownedrows
    
    If newrows > 0 Then 'need to insert more rows
        c = ownedrows + 1
        Select Case IIf(m_targetRgn.Worksheet.Parent.MultiUserEditing And entity.entityOption.VerticalInsert = VerticalInsert_ShiftCellsDown, VerticalInsert_EntireRow, entity.entityOption.VerticalInsert)
            Case VerticalInsert_None:

            Case VerticalInsert_EntireRow:
                Call m_targetRgn.Worksheet.rows(c).Resize(newrows).Insert(xlShiftDown)
                
            Case VerticalInsert_ShiftCellsDown:
                Call m_targetRgn.Cells(c, 1).Resize(newrows, m_targetRgn.Columns.count).Insert(xlShiftDown)
                
        End Select
        
        Set rgn = m_targetRgn.Cells(c, 1).Resize(newrows, m_targetRgn.Columns.count)
        For c = LBound(CEntityHelper.m_CurrentDataFormats) To UBound(CEntityHelper.m_CurrentDataFormats)
            rgn.Cells(1, c + 1).Resize(newrows).NumberFormat = CEntityHelper.m_CurrentDataFormats(c)
        Next
        
    ElseIf newrows < 0 Then
        c = ownedrows + newrows + 1
        Select Case IIf(m_targetRgn.Worksheet.Parent.MultiUserEditing And entity.entityOption.VerticalDelete = VerticalDelete_ShiftCellsUp, VerticalDelete_EntireRow, entity.entityOption.VerticalDelete)
            Case VerticalDelete_None:
                Call m_targetRgn.Cells(c, 1).Resize(-newrows, m_targetRgn.Columns.count).Clear

            Case VerticalDelete_EntireRow:
                Call m_targetRgn.Worksheet.rows(c).Resize(-newrows).Delete(xlShiftUp)
                
            Case VerticalDelete_ShiftCellsUp:
                Call m_targetRgn.Cells(c, 1).Resize(-newrows, m_targetRgn.Columns.count).Insert(xlShiftUp)
                
        End Select
        
    End If
    
    Set m_targetRgn = m_targetRgn.Resize(ownedrows + newrows)
    
    If entity.entityOption.ResultType = ResultType_ListObject Then
        Call CEntityHelper.BuildTable(entity, m_targetRgn)
    Else
        m_targetRgn.Worksheet.Parent.Names.item(entity.ExcelRangeName).RefersTo = m_targetRgn
    End If

    Call dataRange.Copy(m_targetRgn.Cells(replrow, 1))
End Sub

Private Sub MergeDESC(entity As ZEWSProxy.DataDirectEntity, dataRange As range, fmcols As Long)
 Dim ownedrows As Long
 Dim newrows As Long
 Dim replrow As Long
 Dim delta As Long
 Dim rgn As range
 Dim c As Long
 
    ownedrows = m_targetRgn.rows.count

    If entity.entityOption.ResultType = ResultType_ListObject Then
        Call CEntityHelper.UnlistTable(CDDXUtility.GetListObjectBysheetId(entity.sheetId, entity.ExcelRangeName))
    End If
    
    Call RollTarget(entity)
    
    replrow = CRefreshIncremental.GetReplacedStartRow(entity, m_targetRgn)
    delta = entity.executeResult.DataRowsCount - ReplaceRowCount(replrow)

    newrows = (m_targetRgn.rows.count + delta) - ownedrows
    
    If newrows > 0 Then 'need to insert more rows
        c = ownedrows + 1
        Select Case IIf(m_targetRgn.Worksheet.Parent.MultiUserEditing And entity.entityOption.VerticalInsert = VerticalInsert_ShiftCellsDown, VerticalInsert_EntireRow, entity.entityOption.VerticalInsert)
            Case VerticalInsert_None:

            Case VerticalInsert_EntireRow:
                Call m_targetRgn.Worksheet.rows(c).Resize(newrows).Insert(xlShiftDown)
                
            Case VerticalInsert_ShiftCellsDown:
                Call m_targetRgn.Cells(c, 1).Resize(newrows, m_targetRgn.Columns.count).Insert(xlShiftDown)
                
        End Select

        Set rgn = m_targetRgn.Cells(m_header_rows + 1, 1).Resize(newrows, m_targetRgn.Columns.count)
        For c = LBound(CEntityHelper.m_CurrentDataFormats) To UBound(CEntityHelper.m_CurrentDataFormats)
            rgn.Cells(1, c + 1).Resize(newrows).NumberFormat = CEntityHelper.m_CurrentDataFormats(c)
        Next
        
    ElseIf newrows < 0 Then
        c = m_header_rows - newrows
        'm_targetRgn.Cells(c + 1, 1).Resize(ownedrows - c, m_targetRgn.Columns.count).Copy (m_targetRgn.Cells(m_header_rows + 1, 1))
        
        c = ownedrows + newrows + 1
        Select Case IIf(m_targetRgn.Worksheet.Parent.MultiUserEditing And entity.entityOption.VerticalDelete = VerticalDelete_ShiftCellsUp, VerticalDelete_EntireRow, entity.entityOption.VerticalDelete)
            Case VerticalDelete_None:
                Call m_targetRgn.Cells(c, 1).Resize(-newrows, m_targetRgn.Columns.count).Clear

            Case VerticalDelete_EntireRow:
                Call m_targetRgn.Worksheet.rows(c).Resize(-newrows).Delete(xlShiftUp)
                
            Case VerticalDelete_ShiftCellsUp:
                Call m_targetRgn.Cells(c, 1).Resize(-newrows, m_targetRgn.Columns.count).Insert(xlShiftUp)
                
        End Select
        
    End If

    If delta <> 0 Then
        Set m_targetRgn = m_targetRgn.Resize(m_targetRgn.rows.count + delta)
        If delta > 0 Then m_targetRgn.Cells(m_header_rows + 1, 1).Resize(m_targetRgn.rows.count - m_header_rows - delta, m_targetRgn.Columns.count).Copy (m_targetRgn.Cells(m_header_rows + delta + 1, 1))
    End If
    
    If entity.entityOption.ResultType = ResultType_ListObject Then
        Call CEntityHelper.BuildTable(entity, m_targetRgn)
    Else
        m_targetRgn.Worksheet.Parent.Names.item(entity.ExcelRangeName).RefersTo = m_targetRgn
    End If

    Call dataRange.Copy(m_targetRgn.Cells(CRefreshIncremental.HeaderRows + 1, 1))
End Sub
Attribute VB_Name = "CRefreshIncrementalDCurve"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Attribute VB_Name = "CRefreshSelection"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private m_targetRgn As range

Private Function GetAuthenticDate(dv As Variant) As Long
    If Not CRefreshIncremental.IsDateValue(dv) Then Exit Function
    GetAuthenticDate = Int(dv)
End Function

Private Sub GetStart(dva As Variant, ByVal lb As Long, ByRef selStart As Long)
 Dim r As Long
 Dim tmp  As Long
 Dim target  As Long
 Dim flg As Long
 
    If selStart = lb Then Exit Sub
    
    target = GetAuthenticDate(dva(selStart, 1))
    
    For r = selStart - 1 To lb Step -1
        tmp = GetAuthenticDate(dva(r, 1))
        
        If tmp > 0 Then
            If target > 0 And target <> tmp Then
                If (flg And &H1) = 0 Or (flg And &H2) <> 0 Then Exit Sub
                flg = flg And Not (&H1)
                flg = flg Or (&H2) '
            End If
            
            target = tmp
            selStart = r
            
            If r = lb Then Exit Sub
        Else
            flg = flg Or &H1 'empty line
        End If
    Next
    
    If r < lb Then selStart = lb
End Sub

Private Sub GetEnd(dva As Variant, ByVal ub As Long, ByRef selEnd As Long)
 Dim r As Long
 Dim tmp  As Long
 Dim target  As Long
 Dim flg As Long
 
    If selEnd = ub Then Exit Sub
    
    target = GetAuthenticDate(dva(selEnd, 1))
    
    For r = selEnd + 1 To ub
        tmp = GetAuthenticDate(dva(r, 1))
        
        If tmp > 0 Then
            If target > 0 And target <> tmp Then
                If (flg And &H1) = 0 Or (flg And &H2) <> 0 Then Exit Sub
                flg = flg And Not (&H1)
                flg = flg Or (&H2)
            End If
            
            target = tmp
            selEnd = r
            
            If r = ub Then Exit Sub
        Else
            flg = flg Or &H1 'empty line
        End If
    Next
    
    If r > ub Then selEnd = ub
End Sub

Private Function GetSED(entity As ZEWSProxy.DataDirectEntity) As String
 Dim pe As ZEWSProxy.ProfileDataEntity
 
    If Not CDDXUtility.IsProfileDataEntity(DDX_PID, entity) Then Exit Function
    
    Set pe = entity
    GetSED = pe.shiftEffectiveDate
End Function

Public Function SelectRefreshRange(entity As ZEWSProxy.DataDirectEntity) As range
 Dim rgn As range
 Dim hdrs As Long
 Dim lb As Long
 Dim ub As Long
 Dim dva As Variant
 Dim selStart As Long
 Dim selEnd As Long
 Dim vstart As Long
 Dim vend As Long
 Dim sdte As String
 Dim edte As String
                
    Set rgn = CDDXUtility.GetRange(DDX_PID, entity)
    If rgn Is Nothing Then Exit Function

    If Not CRefreshIncremental.GetBounds(rgn, hdrs, lb, ub) Then Exit Function
    
    'adjust selection range
    With Selection
        selStart = .row - rgn.row + 1
        selEnd = (.row + .rows.count - 1) - rgn.row + 1
    End With
    
    If selStart > ub Then Exit Function
    If selStart < lb Then selStart = lb
    
    If selStart < lb Then Exit Function
    If selEnd > ub Then selEnd = ub
    
    If selStart > selEnd Then Exit Function
    
    'to extend selection
    dva = rgn.Resize(, 1).Value2

    Call GetStart(dva, lb, selStart)
    Call GetEnd(dva, ub, selEnd)
    
    vstart = GetAuthenticDate(dva(selStart, 1))
    vend = GetAuthenticDate(dva(selEnd, 1))

    If vstart <= 0 Or vend <= 0 Then
        If entity.entityOption.DateInputOption = DateInputOption_QuickDate Then
            Call CDDXDates.GetDynaDates(entity.entityOption.SelectedQuickDate, sdte, edte, GetSED(entity))
            If vstart <= 0 Then vstart = Int(CDbl(CDDXDates.CDateSafe(IIf(entity.entityOption.InputDateOrder = DateOrder_DESC, edte, sdte))))
            If vend <= 0 Then vend = Int(CDbl(CDDXDates.CDateSafe(IIf(entity.entityOption.InputDateOrder = DateOrder_DESC, sdte, edte))))
            
        ElseIf entity.entityOption.DateInputOption = DateInputOption_DirectInput Then
            If vstart <= 0 Then vstart = Int(CDbl(IIf(entity.entityOption.InputDateOrder = DateOrder_DESC, entity.entityOption.InputEndDate, entity.entityOption.InputStartDate)))
            If vend <= 0 Then vend = Int(CDbl(IIf(entity.entityOption.InputDateOrder = DateOrder_DESC, entity.entityOption.InputStartDate, entity.entityOption.InputEndDate)))
        End If
    End If
    
    entity.startDate = CDate(vstart)
    entity.enddate = CDate(vend)
    
    Set SelectRefreshRange = rgn.Cells(selStart, 1).Resize(selEnd - selStart + 1, rgn.Columns.count)
End Function

Public Function Merge(entity As ZEWSProxy.DataDirectEntity, entityRange As range) As Boolean
 Dim transferSheet As Worksheet
 Dim dataRange As range
 Dim fmcols As Long
 Dim newrows As Long
 Dim ownedrows As Long
 Dim rstart As Long
 Dim rgn As range
 Dim c As Long
 
    Set m_targetRgn = CDDXUtility.GetRangeByRangeName(entity.sheetId, entity.ExcelRangeName)
    
    ownedrows = m_targetRgn.rows.count
    fmcols = CRefreshIncremental.GetAutofillFormulaColumns(entity, entityRange, True)
    
    If entity.entityOption.ResultType = ResultType_ListObject Then
        Call CEntityHelper.UnlistTable(CDDXUtility.GetListObjectBysheetId(entity.sheetId, entity.ExcelRangeName))
    End If

    If entity.executeResult.DataRowsCount = 0 Then
        ownedrows = m_targetRgn.rows.count
    
        newrows = -Selection.rows.count
        Set m_targetRgn = m_targetRgn.Resize(m_targetRgn.rows.count + newrows)
    
        rstart = Selection.row - m_targetRgn.row + Selection.rows.count + 1
           
        Call m_targetRgn.Cells(rstart, 1).Resize(ownedrows - rstart + 1, Selection.Columns.count).Copy(Selection.Cells(Selection.rows.count + newrows + 1, 1))
        Call m_targetRgn.Cells(ownedrows + newrows + 1, 1).Resize(-newrows, Selection.Columns.count).Clear
        
        Select Case IIf(m_targetRgn.Worksheet.Parent.MultiUserEditing And entity.entityOption.VerticalDelete = VerticalDelete_ShiftCellsUp, VerticalDelete_EntireRow, entity.entityOption.VerticalDelete)
            Case VerticalDelete_None:
                Call m_targetRgn.Cells(m_targetRgn.rows.count - newrows, 1).Resize(-newrows, Selection.Columns.count).Clear
    
            Case VerticalDelete_EntireRow:
                Call m_targetRgn.Worksheet.rows(m_targetRgn.rows.count - newrows).Resize(-newrows).Delete(xlShiftUp)
                
            Case VerticalDelete_ShiftCellsUp:
                Call m_targetRgn.Cells(m_targetRgn.rows.count + 1, 1).Resize(-newrows, Selection.Columns.count).Delete(xlShiftUp)
                
        End Select
        
    Else
    
        Set transferSheet = CTempSheet.GetTransferSheet()
        transferSheet.rows.Clear
    
        Set dataRange = CEntityHelper.LoadEntityByNamedRange(entity, transferSheet.Cells(entityRange.row, entityRange.column), Selection.Columns.count - fmcols, Selection.rows.count, False)
        Set dataRange = dataRange.Cells(entity.executeResult.CaptionAndHeaderRowsCount + 1, 1).Resize(entity.executeResult.DataRowsCount, dataRange.Columns.count)
        
        newrows = entity.executeResult.DataRowsCount - Selection.rows.count
        If newrows <> 0 Then Set m_targetRgn = m_targetRgn.Resize(m_targetRgn.rows.count + newrows)
    
        rstart = Selection.row - m_targetRgn.row + Selection.rows.count + 1
        
        If newrows > 0 Then 'need to insert more rows
            Select Case IIf(m_targetRgn.Worksheet.Parent.MultiUserEditing And entity.entityOption.VerticalInsert = VerticalInsert_ShiftCellsDown, VerticalInsert_EntireRow, entity.entityOption.VerticalInsert)
                Case VerticalInsert_None:
    
                Case VerticalInsert_EntireRow:
                    Call m_targetRgn.Worksheet.rows(m_targetRgn.rows.count + newrows).Resize(newrows).Insert(xlShiftDown)
                    
                Case VerticalInsert_ShiftCellsDown:
                    Call m_targetRgn.Cells(m_targetRgn.rows.count + 1, 1).Resize(newrows, Selection.Columns.count).Insert(xlShiftDown)
                    
            End Select
            If ownedrows - rstart + 1 > 0 Then
                Call m_targetRgn.Cells(rstart, 1).Resize(ownedrows - rstart + 1, Selection.Columns.count).Copy(m_targetRgn.Cells(rstart + newrows, 1))
            End If
            
            Set rgn = m_targetRgn.Cells(m_targetRgn.rows.count - newrows + 1, 1).Resize(newrows, m_targetRgn.Columns.count)
            For c = LBound(CEntityHelper.m_CurrentDataFormats) To UBound(CEntityHelper.m_CurrentDataFormats)
                With rgn.Cells(1, c + 1).Resize(newrows)
                    .NumberFormat = CEntityHelper.m_CurrentDataFormats(c)
                    If c = LBound(CEntityHelper.m_CurrentDataFormats) Then
                        .Font.ColorIndex = ENTITY_COLOR_HEADER_N_DATE
                    End If
                End With
            Next
            
        ElseIf newrows < 0 Then
            If ownedrows - rstart + 1 > 0 Then
                Call m_targetRgn.Cells(rstart, 1).Resize(ownedrows - rstart + 1, Selection.Columns.count).Copy(Selection.Cells(Selection.rows.count + newrows + 1, 1))
            End If
            Call m_targetRgn.Cells(ownedrows + newrows + 1, 1).Resize(-newrows, Selection.Columns.count).Clear
            
            Select Case IIf(m_targetRgn.Worksheet.Parent.MultiUserEditing And entity.entityOption.VerticalDelete = VerticalDelete_ShiftCellsUp, VerticalDelete_EntireRow, entity.entityOption.VerticalDelete)
                Case VerticalDelete_None:
                    Call m_targetRgn.Cells(m_targetRgn.rows.count - newrows, 1).Resize(-newrows, Selection.Columns.count).Clear
    
                Case VerticalDelete_EntireRow:
                    Call m_targetRgn.Worksheet.rows(m_targetRgn.rows.count - newrows).Resize(-newrows).Delete(xlShiftUp)
                    
                Case VerticalDelete_ShiftCellsUp:
                    Call m_targetRgn.Cells(m_targetRgn.rows.count + 1, 1).Resize(-newrows, Selection.Columns.count).Delete(xlShiftUp)
                    
            End Select
            
        End If
        
        Call dataRange.Copy
        Call Selection.Cells(1, 1).PasteSpecial(xlPasteValues)
        Call Selection.Cells(1, 1).Resize(dataRange.rows.count, dataRange.Columns.count + fmcols).Select
    End If
    
    If entity.entityOption.ResultType = ResultType_ListObject Then
        Call CEntityHelper.BuildTable(entity, m_targetRgn)
    Else
        m_targetRgn.Worksheet.Parent.Names.item(entity.ExcelRangeName).RefersTo = m_targetRgn
    End If

    'Call CDDXEntity.RaiseLoadedEvent(DDX_PID, entity)
    Call CDDXUtility.DeleteTempFilesByTaskId(entity.taskID)
    transferSheet.rows.Clear
          
    Call CRefreshIncremental.PerformAutofillFormulas(entity, fmcols, entityRange)
End Function
Attribute VB_Name = "CRefreshSelectionDCurve"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

'Private Function SRDCurvePropertyCount(entity As ZEWSProxy.DCurveDataEntity) As Long
''' Dim avaiableProperties() As String
'' Dim isSelected() As Boolean
'' Dim k As Long
''
''    On Error GoTo OOPS
''
'''    avaiableProperties = entity.FilteredProperties
'''    If Len(Join(avaiableProperties)) = 0 Then Exit Function
'''
''    isSelected = entity.IsFilteredPropertyChecked
''
''    For k = LBound(isSelected) To UBound(isSelected)
''        If isSelected(k) Then
''            SRDCurvePropertyCount = SRDCurvePropertyCount + 1
''        End If
''    Next
''
''OOPS:
''    Exit Function
'End Function

Private Function SRDCurveRowID(isFuturesEntity As Boolean, rgn As range) As String
    With rgn
        SRDCurveRowID = CStr(.Cells(1, 1).Value2) + vbTab + Trim(.Cells(1, 2).Value2) + vbTab
        If isFuturesEntity Then
            SRDCurveRowID = SRDCurveRowID + CStr(.Cells(1, 3).Value2) + vbTab + CStr(.Cells(1, 4).Value2) + vbTab + Trim(.Cells(1, 5).Value2)
        Else
            SRDCurveRowID = SRDCurveRowID + Trim(.Cells(1, 3).Value2)
        End If
    End With
End Function

Public Function SelectRefreshRange(entity As ZEWSProxy.DataDirectEntity, entityRange As Excel.range, SelectRange As Excel.range) As range
 Dim re As Long
 Dim rs As Long
 Dim k As Long
 Dim c As Long
 Dim buff As String
 Dim v As Variant
 Dim file As Object
 Dim de As ZEWSProxy.DCurveDataEntity
 Dim boundary As String
' Dim pc As Long
 Dim rgn As range
 
 'to adjust start row
    re = entityRange.row
    rs = SelectRange.row
    If rs < re Then
        re = re - rs
        If SelectRange.rows.count - re <= 0 Then Exit Function
        Set SelectRange = SelectRange.offset(re).Resize(SelectRange.rows.count - re)
    End If
    
'to adjust end row
    re = entityRange.row + entityRange.rows.count
    rs = SelectRange.row + SelectRange.rows.count
    If rs > re Then
        rs = rs - re
        If SelectRange.rows.count - rs <= 0 Then Exit Function
        Set SelectRange = SelectRange.Resize(SelectRange.rows.count - rs)
    End If
        
    Set SelectRange = SelectRange.Parent.Cells(SelectRange.row, entityRange.column).Resize(SelectRange.rows.count, entityRange.Columns.count)
    
'to search for the real selection range
    v = SelectRange.Resize(, 1).Value2
    
    If (VarType(v) And vbArray) = 0 Then
        If Not IsNumeric(v) Then Exit Function
        Set SelectRefreshRange = SelectRange
        
    Else
        rs = -1
        re = -1
        For k = LBound(v, 1) To UBound(v, 1)
            If IsNumeric(v(k, 1)) Then
                If rs = -1 Then rs = k
                re = k
            End If
        Next
        If rs = -1 Then Exit Function
        
        Set SelectRefreshRange = SelectRange.offset(rs - 1).Resize(re - rs + 1)
    End If
    
'to increase range using opr + curve name + contract start + granularity (futures)
    Set de = entity

    If de.IsTypeAsHeader And Not de.isSuppressNull Then
        boundary = SRDCurveRowID(de.isFutures, SelectRefreshRange)
        rs = 0
        Set rgn = SelectRefreshRange.Resize(1)

        For k = SelectRefreshRange.row - 1 To entityRange.row Step -1
            Set rgn = rgn.offset(-1).Resize(1)
            If StrComp(boundary, SRDCurveRowID(de.isFutures, rgn)) <> 0 Then Exit For
            rs = rs + 1
        Next
        If rs > 0 Then Set SelectRefreshRange = SelectRefreshRange.offset(-rs).Resize(SelectRefreshRange.rows.count + rs)

        boundary = SRDCurveRowID(de.isFutures, SelectRefreshRange.offset(SelectRefreshRange.rows.count - 1).Resize(1))
        rs = 0
        Set rgn = SelectRefreshRange.offset(SelectRefreshRange.rows.count - 1).Resize(1)

        For k = SelectRefreshRange.row + SelectRefreshRange.rows.count To entityRange.row + entityRange.rows.count - 1
            Set rgn = rgn.offset(1).Resize(1)
            If StrComp(boundary, SRDCurveRowID(de.isFutures, rgn)) <> 0 Then Exit For
            rs = rs + 1
        Next
        If rs > 0 Then Set SelectRefreshRange = SelectRefreshRange.Resize(SelectRefreshRange.rows.count + rs)
    End If
    
'output to file
    Set file = CDDXFile.OpenWriteStream
    
    With SelectRefreshRange
'        Call CDDXFile.WriteLine(file, CStr(.row) + vbTab + CStr(.column) + vbTab + CStr(.rows.count) + vbTab + CStr(.Columns.count), True)
        
        For k = 1 To .rows.count
            buff = vbNullString
            For c = 1 To .Columns.count
                If c > 1 Then buff = buff + vbTab
                buff = buff + Trim(CStr(.Cells(k, c).Value2))
            Next
            Call CDDXFile.WriteLine(file, buff + vbTab, True)
        Next
    End With

    Call CDDXFile.SaveWriteStream(file, entity.SRFilePath, buff)
End Function

Public Function Merge(entity As ZEWSProxy.DataDirectEntity, entityRange As range) As Boolean
    Merge = CRefreshSelection.Merge(entity, entityRange)
End Function
Attribute VB_Name = "CReport"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public Enum eInterval
    eOneMin = 1
    eFiveMin
    eTenMin
    eFifteenMin
    eThirtyMin
    eHourly
    eDaily
    eWeekly
    eMonthly
    eQuarterly
    eAnnual
End Enum

Public Enum eAggregation
    eAverage = 1
    eCount
    eDistCount
    eMin
    eMax
    eStdDeviation
    eSum
    eVariance
End Enum

Public Event OnAfterReportLoad(sender As Object, entity As CProfileInfo)

Public Sub GetReportData(ByVal outReportTAB As String, ByVal dataSrcLabel As String, ByVal dataRptLabel As String, ByVal stdate As Date, ByVal edDate As Date, _
                        ByRef rptObserv() As String, ByRef rptAttr() As String, ByVal aggregation As eAggregation, ByVal interval As eInterval, ByVal isDataSheet As Boolean, _
                        ByVal trdStartDate As Date, ByVal trdEndDate As Date, Optional ByVal suppNullOpts As Long)
 Dim rptEntity As ZEWSProxy.ReportDataEntity
 Dim errmsg As String

    Set rptEntity = New ZEWSProxy.ReportDataEntity

    rptEntity.DataSourceLabel = dataSrcLabel
    rptEntity.DataReportLabel = dataRptLabel

    Call rptEntity.SetObservationLabels(rptObserv)
    Call rptEntity.AddReportAttributesAndFilter(rptAttr)

    rptEntity.IsSimple = isDataSheet

    With rptEntity.EntityObject
'        .sid = CDDXLogin.sid
        .IsFromFormula = True
        .aggregation = Choose(aggregation, "Average", "Count", "Distinct Count", "Max", "Min", "Std Deviation", "Sum", "Variance")
        .interval = Choose(interval, "Minute", "5-Minutes", "10-Minutes", "15-Minutes", "30-Minutes", "Hourly", "Daily", "Weekly", "Monthly", "Quarterly", "Annual")
        .startDate = CDDXDates.CDateSafe(stdate)
        .enddate = CDDXDates.CDateSafe(edDate)
        .SupressNulls = False

        With .entityOption
            .SupressNullsOptions = suppNullOpts
            .DataPrecision = CDDXHelper.GetZEMAPrecisionPref(DDX_PID)
            .HasReportSeriesName = True
            .HasReportDataSource = Not isDataSheet
            .HasReportDataReport = Not isDataSheet
            .HasReportObservation = True
            .HasReportAttributes = True
            .HasReportNumeratorDenominator = True
        End With
    End With

    Call rptEntity.ApiGetReportData(outReportTAB)

    errmsg = Trim$(rptEntity.EntityObject.executeResult.errorMessage)
    Set rptEntity = Nothing
    
    If Len(errmsg) > 0 Then
        Call Err.Raise(vbObjectError + 1, "ZEDDXBase.CReport.GetReportData()", errmsg)
    End If
End Sub

Private Function GetReportsByWorkBook(Wb As Workbook) As ZEWSProxy.DataDirectEntities
    If Wb Is Nothing Then Set Wb = Application.ActiveWorkbook
    If Wb Is Nothing Then Exit Function
          
 Dim result As ZEWSProxy.DataDirectEntities
 
    Set result = CDDXEntity.GetEntitiesByWorkBook(BSConsts.DDX_PID, Wb)
    If Not result Is Nothing Then
        Set result = result.GetByEntityTypeName(TYPE_REPORT)
    End If

    Set GetReportsByWorkBook = result
End Function

Public Function GetReportCollection(Wb As Workbook) As Collection
 Dim result As Collection
 Dim item As Variant
 Dim entity As ZEWSProxy.DataDirectEntity
 Dim report As CProfileInfo
 Dim entities As ZEWSProxy.DataDirectEntities
  
    Set entities = GetReportsByWorkBook(Wb)
    If entities Is Nothing Then Exit Function
              
    For Each item In entities.GetEntities
        Set entity = item
        
        If Not entity.entityOption.IsOneTimeRequest Then
            If result Is Nothing Then
                Set result = New Collection
            End If
            Set report = NewCReportData(BSConsts.DDX_PID, entity)
            Call result.Add(report)
        End If
    Next

    Set GetReportCollection = result
End Function

Public Function NewCReportData(ByVal pid As String, entity As ZEWSProxy.ReportDataEntity) As CProfileInfo
    If Not CDDXApp.IsPX(pid) Then Exit Function

    Call CDDXEntity.SetParams(BSConsts.DDX_PID, entity)
    Set NewCReportData = New CProfileInfo
End Function

Public Function RefreshReport(report As CProfileInfo) As Boolean
 Dim entity As ZEWSProxy.DataDirectEntity

    If Not CDDXLogin.Loggedin Then Exit Function
    
    Set entity = CDDXEntity.AllEntities(BSConsts.DDX_PID).GetByTaskId(report.entityID)
      
    If entity Is Nothing Then Exit Function

     entity.entityOption.DateInputOption = IIf(report.UseDynamicDates, DateInputOption_QuickDate, DateInputOption_DirectInput)
     If report.UseDynamicDates Then
         entity.entityOption.SelectedQuickDate = report.DynamicDate
         
     ElseIf report.UseCustomDates Then
         With entity.entityOption
            .InputStartDate = report.startDate
            .InputEndDate = report.enddate
            Call .SetRollingOption(.RollingOption)
        End With
     End If
     
    entity.entityOption.DataPrecision = CDDXHelper.GetZEMAPrecisionPref(DDX_PID)
     'If report.TagSpecified Then entity.EntityObject.Tag = report.Tag
    entity.EntityObject.tag = report.tag
    entity.EntityObject.IsAPI = True
     
    RefreshReport = CDDXEntity.RefreshEntity(BSConsts.DDX_PID, entity)
End Function

Public Sub RaiseOnAfterReportLoad(pid As String, entity As ZEWSProxy.ReportDataEntity)
    On Error GoTo OOPS
    
    If Not CDDXApp.IsPX(pid) Then Exit Sub
          
 Dim report As CProfileInfo
 
    Set report = NewCReportData(BSConsts.DDX_PID, entity)
    RaiseEvent OnAfterReportLoad(Me, report)

OOPS:
    If Err.Number <> 0 Then
        CDDXApp.StatusMessage = Err.Description
    End If
    On Error GoTo 0
    Exit Sub
End Sub


Attribute VB_Name = "CSheet"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Function GetPropertyWK(wrk As Workbook, ByVal aPropName As String) As DocumentProperty
          Dim f As Variant
10        On Error GoTo errorHandler

20        For Each f In wrk.CustomDocumentProperties
30            If StrComp(f.name, aPropName, vbTextCompare) = 0 Then
40                Set GetPropertyWK = f
50                Exit Function
60            End If
70        Next

80        On Error GoTo 0
90        Exit Function
errorHandler:
          Dim errorDescription As String, errorNumber As Long
100       errorDescription = "CSheet.GetPropertyWK(), Line:" & str(Erl()) + " " + vbCrLf + Err.Description
110       errorNumber = Err.Number
          'your clean up codes here
120       Err.Raise errorNumber, , errorDescription
End Function

Public Function DOCGetProp(wrk As Workbook, ByVal aPropName As String) As String
 Dim prop As DocumentProperty
       
    On Error GoTo OOPS

    Set prop = GetPropertyWK(wrk, aPropName)
    If prop Is Nothing Then
        DOCGetProp = vbNullString
    Else
        DOCGetProp = prop.value
    End If

OOPS:
    On Error GoTo 0
    Exit Function
End Function

Public Sub DOCSetProp(wrk As Workbook, ByVal aPropName As String, ByVal aValue As String)
          Dim prop As DocumentProperty
       
10        On Error GoTo errorHandler

20        Set prop = GetPropertyWK(wrk, aPropName)
30        If prop Is Nothing Then
40            Call wrk.CustomDocumentProperties.Add(name:=aPropName, LinkToContent:=False, Type:=msoPropertyTypeString, value:=aValue)
50        Else
60            prop.value = aValue
70        End If

80        On Error GoTo 0
90        Exit Sub
errorHandler:
          Dim errorDescription As String, errorNumber As Long
100       errorDescription = "CSheet.DOCSetProp(), Line:" & str(Erl()) + " " + vbCrLf + Err.Description
110       errorNumber = Err.Number
          'your clean up codes here
120       Err.Raise errorNumber, , errorDescription
End Sub

Public Property Get DOCVersion(wrk As Workbook) As String
    DOCVersion = DOCGetProp(wrk, ZEDOC_VER)
End Property

Public Property Let DOCVersion(wrk As Workbook, value As String)
    Call DOCSetProp(wrk, ZEDOC_VER, value)
End Property

Public Property Get DOCTimeZone(wrk As Workbook) As String
    DOCTimeZone = DOCGetProp(wrk, ZEDOC_TIMEZONE)
End Property

Public Property Let DOCTimeZone(wrk As Workbook, value As String)
    Call DOCSetProp(wrk, ZEDOC_TIMEZONE, value)
End Property

Public Property Let ZEDocID(Wb As Workbook, ByVal value As String)
    Call DOCSetProp(Wb, ZEDOC_ID, value)
End Property

Public Property Get ZEDocID(Wb As Workbook) As String
    ZEDocID = DOCGetProp(Wb, ZEDOC_ID)
End Property

Private Function GetProperty(sheet As Worksheet, ByVal aProp As String) As CustomProperty
          Dim f As Variant
       
10        On Error GoTo errorHandler

20        For Each f In sheet.CustomProperties
30            If StrComp(f.name, aProp, vbTextCompare) = 0 Then
40                Set GetProperty = f
50                Exit Function
60            End If
70        Next

80        On Error GoTo 0
90        Exit Function
errorHandler:
          Dim errorDescription As String, errorNumber As Long
100       errorDescription = "CSheet.GetProperty(), Line:" & str(Erl()) + " " + vbCrLf + Err.Description
110       errorNumber = Err.Number
          'your clean up codes here
120       Err.Raise errorNumber, , errorDescription
End Function

Public Function WSGetProp(sheet As Worksheet, ByVal aProp As String) As String
          Dim prop As CustomProperty
       
10        On Error GoTo errorHandler

20        Set prop = GetProperty(sheet, aProp)
30        If prop Is Nothing Then
40            WSGetProp = ZESHEET_NIL
50        Else
60            WSGetProp = Trim(prop.value)
70        End If

80        On Error GoTo 0
90        Exit Function
errorHandler:
          Dim errorDescription As String, errorNumber As Long
100       errorDescription = "CSheet.WSGetProp(), Line:" & str(Erl()) + " " + vbCrLf + Err.Description
110       errorNumber = Err.Number
          'your clean up codes here
120       Err.Raise errorNumber, , errorDescription
End Function

Public Sub WSRemoveProp(sheet As Worksheet, ByVal aProp As String)
          Dim prop As CustomProperty
       
10        On Error GoTo errorHandler

20        For Each prop In sheet.CustomProperties
30            If prop.name = aProp Then
40                prop.Delete
50                Exit For
60            End If
70        Next

80        On Error GoTo 0
90        Exit Sub
errorHandler:
          Dim errorDescription As String, errorNumber As Long
100       errorDescription = "CSheet.WSRemoveProp(), Line:" & str(Erl()) + " " + vbCrLf + Err.Description
110       errorNumber = Err.Number
          'your clean up codes here
120       Err.Raise errorNumber, , errorDescription
End Sub

Public Sub WSSetProp(sheet As Worksheet, ByVal aProp As String, ByVal aValue As String)
          Dim prop As CustomProperty
       
10        On Error GoTo errorHandler

20        Set prop = GetProperty(sheet, aProp)
30        aValue = IIf(aValue = vbNullString, " ", aValue)
40        If prop Is Nothing Then
50            Call sheet.CustomProperties.Add(aProp, aValue)
60        Else
70            prop.value = aValue
80        End If

90        On Error GoTo 0
100       Exit Sub
errorHandler:
          Dim errorDescription As String, errorNumber As Long
110       errorDescription = "CSheet.WSSetProp(), Line:" & str(Erl()) + " " + vbCrLf + Err.Description
120       errorNumber = Err.Number
          'your clean up codes here
130       Err.Raise errorNumber, , errorDescription
End Sub

Public Property Let ZESheetType(sheet As Worksheet, aType As String)
10        On Error GoTo errorHandler

20        Call WSSetProp(sheet, PROP_SHEET_TYPE, aType)

30        On Error GoTo 0
40        Exit Property
errorHandler:
          Dim errorDescription As String, errorNumber As Long
50        errorDescription = "CSheet.ZESheetType(), Line:" & str(Erl()) + " " + vbCrLf + Err.Description
60        errorNumber = Err.Number
          'your clean up codes here
70        Err.Raise errorNumber, , errorDescription
End Property

Public Property Get ZESheetType(sheet As Worksheet) As String
10        On Error GoTo errorHandler

20        ZESheetType = WSGetProp(sheet, PROP_SHEET_TYPE)

30        On Error GoTo 0
40        Exit Property
errorHandler:
          Dim errorDescription As String, errorNumber As Long
50        errorDescription = "CSheet.ZESheetType(), Line:" & str(Erl()) + " " + vbCrLf + Err.Description
60        errorNumber = Err.Number
          'your clean up codes here
70        Err.Raise errorNumber, , errorDescription
End Property

Public Property Let ZESheetVersion(sheet As Worksheet, aType As String)
10        On Error GoTo errorHandler

20        Call WSSetProp(sheet, PROP_SHEET_VERSION, aType)

30        On Error GoTo 0
40        Exit Property
errorHandler:
          Dim errorDescription As String, errorNumber As Long
50        errorDescription = "CSheet.ZESheetVersion(), Line:" & str(Erl()) + " " + vbCrLf + Err.Description
60        errorNumber = Err.Number
          'your clean up codes here
70        Err.Raise errorNumber, , errorDescription
End Property

Public Property Get ZESheetVersion(sheet As Worksheet) As String
10        On Error GoTo errorHandler

20        ZESheetVersion = WSGetProp(sheet, PROP_SHEET_VERSION)

30        On Error GoTo 0
40        Exit Property
errorHandler:
          Dim errorDescription As String, errorNumber As Long
50        errorDescription = "CSheet.ZESheetVersion(), Line:" & str(Erl()) + " " + vbCrLf + Err.Description
60        errorNumber = Err.Number
          'your clean up codes here
70        Err.Raise errorNumber, , errorDescription
End Property

Public Property Let ZESheetID(sh As Worksheet, aID As String)
10        On Error GoTo errorHandler

20        Call WSSetProp(sh, PROP_SHEET_ID, aID)

30        On Error GoTo 0
40        Exit Property
errorHandler:
          Dim errorDescription As String, errorNumber As Long
50        errorDescription = "CSheet.ZESheetID(), Line:" & str(Erl()) + " " + vbCrLf + Err.Description
60        errorNumber = Err.Number
          'your clean up codes here
70        Err.Raise errorNumber, , errorDescription
End Property

Public Property Get ZESheetID(sh As Worksheet) As String
10        On Error GoTo errorHandler

20        ZESheetID = WSGetProp(sh, PROP_SHEET_ID)

30        On Error GoTo 0
40        Exit Property
errorHandler:
          Dim errorDescription As String, errorNumber As Long
50        errorDescription = "CSheet.ZESheetID(), Line:" & str(Erl()) + " " + vbCrLf + Err.Description
60        errorNumber = Err.Number
          'your clean up codes here
70        Err.Raise errorNumber, , errorDescription
End Property

Private Sub SetSheetMenuItem(ByVal id As String, ByVal itemID As Long, ByVal value As Boolean)
          Dim item
       
10        On Error GoTo errorHandler

20        Set item = CommandBars(id).FindControl(id:=itemID)
30        If Not item Is Nothing Then
40            item.enabled = value
50        End If

60        On Error GoTo 0
70        Exit Sub
errorHandler:
          Dim errorDescription As String, errorNumber As Long
80        errorDescription = "CSheet.SetSheetMenuItem(), Line:" & str(Erl()) + " " + vbCrLf + Err.Description
90        errorNumber = Err.Number
          'your clean up codes here
100       Err.Raise errorNumber, , errorDescription
End Sub
Attribute VB_Name = "CSmartMart"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

'this is a PredeclaredId class, try NOT use class level variable(public or private) unless necessary
#If SMARTMAT_USE Then
Public Event OnAfterSmartMartLoad(sender As Object, entity As CProfileInfo)

Private Function GetSmartMartsByWorkBook(Wb As Workbook) As ZEWSProxy.DataDirectEntities
 Dim result As ZEWSProxy.DataDirectEntities
 
    If Wb Is Nothing Then Set Wb = Application.ActiveWorkbook
    If Wb Is Nothing Then Exit Function

    Set result = CDDXEntity.GetEntitiesByWorkBook(BSConsts.DDX_PID, Wb)
    If Not result Is Nothing Then
        Set GetSmartMartsByWorkBook = result.GetByEntityTypeName(TYPE_SMARTMART)
    End If
End Function

Public Function GetSmartMartCollection(Wb As Workbook) As Collection
 Dim result As Collection
 Dim entities As ZEWSProxy.DataDirectEntities
 Dim item As Variant
 Dim entity As ZEWSProxy.DataDirectEntity
 Dim sm As CProfileInfo
 
    Set entities = GetSmartMartsByWorkBook(Wb)
    If entities Is Nothing Then Exit Function

    For Each item In entities.GetEntities
        Set entity = item
        
        If Not entity.entityOption.IsOneTimeRequest Then
            If result Is Nothing Then
                Set result = New Collection
            End If
            
            Set sm = NewCSmartMartData(BSConsts.DDX_PID, entity)
            Call result.Add(sm)
        End If
    Next

    Set GetSmartMartCollection = result
End Function

Public Function NewCSmartMartData(ByVal pid As String, entity As ZEWSProxy.SmartMartDataEntity) As CProfileInfo
    If Not CDDXApp.IsPX(pid) Then Exit Function
    
    Call CDDXEntity.SetParams(BSConsts.DDX_PID, entity)
    Set NewCSmartMartData = New CProfileInfo
End Function

Public Function RefreshSmartMart(sm As CProfileInfo) As Boolean
 Dim entity As ZEWSProxy.DataDirectEntity
 
    If Not CDDXLogin.Loggedin Then Exit Function
    
    Set entity = CDDXEntity.AllEntities(BSConsts.DDX_PID).GetByTaskId(sm.entityID)
          
    If entity Is Nothing Then Exit Function

    With entity.entityOption
        .DateInputOption = IIf(sm.UseDynamicDates, DateInputOption_QuickDate, DateInputOption_DirectInput)
        If sm.UseDynamicDates Then
            .SelectedQuickDate = sm.DynamicDate
        Else
            .InputStartDate = sm.startDate
            .InputEndDate = sm.enddate
            Call .SetRollingOption(.RollingOption)
        End If
        
        .DataPrecision = CDDXHelper.GetZEMAPrecisionPref(DDX_PID)
        entity.EntityObject.tag = sm.tag
    End With
            
    entity.EntityObject.IsAPI = True
    RefreshSmartMart = CDDXEntity.RefreshEntity(BSConsts.DDX_PID, entity)
End Function

Public Sub RaiseOnAfterSmartMartLoad(pid As String, entity As ZEWSProxy.SmartMartDataEntity)
 Dim sm As CProfileInfo
 
    If Not CDDXApp.IsPX(pid) Then Exit Sub
    
    On Error GoTo OOPS

    Set sm = NewCSmartMartData(BSConsts.DDX_PID, entity)
    If Not sm Is Nothing Then
        RaiseEvent OnAfterSmartMartLoad(Me, sm)
    End If
    
OOPS:
    If Err.Number <> 0 Then
        Call CDDXHelper.LogError(Err.Description, "RaiseOnAfterSmartMartLoad")
    End If

    On Error GoTo 0
    Exit Sub
End Sub
#End If
Attribute VB_Name = "CTempSheet"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

'this is a PredeclaredId class, try not use class level variable(public or private), except const variable

Private Const ZE_TRANSFER_SHEET_NAME As String = "ZE Transfer sheet"
Private Const ZE_TRANSFER_SHEET_PWD As String = "zepower_transfer_sheet"
Private Const ZE_TRANSFER_SHEET_TYPE As String = "T"

Public Function GetTransferSheet() As Worksheet
           Dim sht As Worksheet
10        On Error GoTo errorHandler

20         For Each sht In ThisWorkbook.Worksheets
30            If (sht.name = ZE_TRANSFER_SHEET_NAME) Then
40                Exit For
50            End If
60         Next
70         If sht Is Nothing Then
80            Set sht = CreateTrnasferSheet(ThisWorkbook)
90         End If
           
100        Set GetTransferSheet = sht

110       On Error GoTo 0
120       Exit Function
errorHandler:
          Dim errorDescription As String, errorNumber As Long
130       errorDescription = "ZeSheetHelper.GetTransferSheet(), Line:" & str(Erl()) + " " + vbCrLf + Err.Description
140       errorNumber = Err.Number
          'your clean up codes here
150       Err.Raise errorNumber, , errorDescription
End Function

Private Function SetSheetName(sheet As Worksheet, ByVal name As String) As Boolean
10        On Error GoTo errorHandler

20        sheet.name = name
30        SetSheetName = True

40        On Error GoTo 0
50        Exit Function
errorHandler:
          Dim errorDescription As String, errorNumber As Long
60        errorDescription = "ZeSheetHelper.SetSheetName(), Line:" & str(Erl()) + " " + vbCrLf + Err.Description
70        errorNumber = Err.Number
          'your clean up codes here
80        Call CDDXHelper.LogError(errorDescription, "SetSheetName")
End Function

Private Function CreateTrnasferSheet(wrk As Workbook) As Worksheet
10        On Error GoTo errorHandler
          
          Dim sht As Worksheet
20        Set sht = wrk.Worksheets.Add
30        Call SetSheetName(sht, ZE_TRANSFER_SHEET_NAME)
40        sht.Visible = xlSheetVeryHidden
50        Call CDDXHelper.MarkZESheet(BSConsts.DDX_PID, sht, ZE_TRANSFER_SHEET_TYPE)
60        Set CreateTrnasferSheet = sht

70        On Error GoTo 0
80        Exit Function
errorHandler:
          Dim errorDescription As String, errorNumber As Long
90        errorDescription = "ZeSheetHelper.CreateTrnasferSheet(), Line:" & str(Erl()) + " " + vbCrLf + Err.Description
100       errorNumber = Err.Number
          'your clean up codes here
110       Err.Raise errorNumber, , errorDescription
End Function
Attribute VB_Name = "CTimer"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
 
'Private Const FT_OOQ As Long = &H10000000

Private Const FT_FILE As Long = &H1000
Private Const FT_MEMORY As Long = &H2000

Private Const DT_PROXY As Long = &H100

Private Const DT_PROFILE As Long = &H1
Private Const DT_UPLOAD As Long = &H2
Private Const DT_CURVE As Long = &H4
Private Const DT_LOGIN As Long = &H8

Private WithEvents m_login As CDDXLogin
Attribute m_login.VB_VarHelpID = -1
Private m_tasks As New Scripting.Dictionary

Public Sub OnIdle()
    Call CDDXEntity.OnIdle(DDX_PID)
End Sub

Public Sub OnData()
 Dim tmp As String
 Dim tasks() As String
 Dim files() As String
 Dim start As Long
 Dim k As Long
 Dim tid As String
 Dim flags As Long
 Dim tag As String
 Dim ud As String
    
    On Local Error GoTo OOPS
          
    tmp = CDDXLib.DefaultZEWSProxy(DDX_PID).GetTasksInQueue(0)
    If tmp = vbNullString Then Exit Sub
    'Stop
    tasks = Split(tmp, vbTab)
    If LBound(tasks) = UBound(tasks) Then Exit Sub
    
    start = LBound(tasks) + 1
    For k = 1 To (UBound(tasks) - LBound(tasks)) \ 3 Step 1
        start = 3 * (k - 1) + 1
        
        tid = tasks(start)
        flags = Val(tasks(start + 1))
        tag = tasks(start + 2)
        
        If CDDXHelper.IsFlag(flags, DT_PROXY) Then
            Call CDDXProxy.RaiseProxyEvent(DDX_PID, tid, flags, tag)
        Else
            If CDDXHelper.IsFlag(flags, FT_FILE) Then
                If (flags And DT_LOGIN) <> 0 Then
                    CDDXApp.DebugMessage = "Login"
                    Call CDDXLogin.OnAutoLogin(DDX_PID, tasks(LBound(tasks)) + "\" + tid)
                            
                Else
                    If m_tasks.Exists(tid) Then
                        files = GetFiles(tasks(LBound(tasks)), tid, ud)
                        
                        'If Len(Join(files)) <> 0 Then
                            If (flags And DT_PROFILE) <> 0 Then
                                CDDXApp.DebugMessage = "Entity Type"
                                Call OnEntityData(tid, ud)
                                
                            ElseIf (flags And DT_UPLOAD) <> 0 Then
                                CDDXApp.DebugMessage = "Upload Sheet Type"
                                Call CDDXUpload.OnUploadData(DDX_PID, tid, files, ud)
                                
                            ElseIf (flags And DT_CURVE) <> 0 Then
                                CDDXApp.DebugMessage = "CurvePortal"
                                Call CCurveControl.OnCurveData(tid, flags, tag)
                            
                            End If
                        'End If
                    End If
                End If
            ElseIf CDDXHelper.IsFlag(flags, FT_MEMORY) Then
                If m_tasks.Exists(tid) Then
                    Call m_tasks.Remove(tid)
                    
                    Call CDDXEntity.RaiseEventValueReady(DDX_PID, tid, tag)
                End If
            End If
        End If
    Next
    
OOPS:
    If Err.Number <> 0 Then
        Call CDDXHelper.LogError(Err.Description, "OnData")
    End If
    
    On Local Error GoTo -1
    Exit Sub
End Sub

Private Function GetFiles(ByVal folderName As String, ByVal taskID As String, ByRef userData As String) As String()
 Dim fil As String
 Dim tmp As String
 
    If Not m_tasks.Exists(taskID) Then
        userData = vbNullString
        Exit Function
    End If
    
    userData = CStr(m_tasks.item(taskID))
    Call m_tasks.Remove(taskID)
        
    tmp = Dir(folderName + "\" + taskID + ".*", vbNormal)
    Do While Len(tmp) > 0
        If Len(fil) > 0 Then fil = fil + vbCr
        fil = fil + folderName + "\" + tmp
        tmp = Dir()
    Loop
    
    If Len(fil) > 0 Then
        GetFiles = Split(fil, vbCr)
    End If
End Function

'Public Sub BeginProc()
'    On Error GoTo OOPS
'
'    Application.Interactive = False
'
'OOPS:
'    If Err.Number <> 0 Then
'        Call CDDXHelper.LogError(Err.Description, "BeginProc")
'    End If
'    On Error GoTo 0
'    Exit Sub
'End Sub

'Public Sub EndProc()
'    On Error GoTo OOPS
'
'    Application.Interactive = True
'
'OOPS:
'    If Err.Number <> 0 Then
'        Call CDDXHelper.LogError(Err.Description, "EndProc")
'    End If
'    On Error GoTo 0
'    Exit Sub
'End Sub

Public Sub ValidateMonitor()
   If WndHandle() = 0 Then Err.Raise vbObjectError + 1, "ValidateMonitor", "No valid Monitor"
End Sub

Public Sub StartMonitor(ByVal taskID As String, ByVal userData As String)
    If m_tasks.Exists(taskID) Then Call m_tasks.Remove(taskID)
    Call m_tasks.Add(taskID, userData)
End Sub

Private Sub Class_Initialize()
    Set m_login = CDDXLogin
End Sub

Public Function CancelMonitor(ByVal tsk As String) As Boolean
    If tsk = vbNullString Then Exit Function
    
    If m_tasks Is Nothing Then Exit Function
    If m_tasks.count = 0 Then Exit Function
    
    If m_tasks.Exists(tsk) Then
        Call m_tasks.Remove(tsk)
        CancelMonitor = True
    End If
End Function

Private Sub Class_Terminate()
    Set m_tasks = Nothing
End Sub

Private Sub m_login_OnAfterLogout(sender As Object)
    Call m_tasks.RemoveAll
End Sub

Public Sub OnExitEditor()
 Dim fvs As Long
 Dim rgn As range
 Dim pf As Long

    On Error GoTo OOPS
    
    If ActiveWorkbook.Readonly Then Exit Sub
    If ActiveSheet Is Nothing Or Selection Is Nothing Then Exit Sub
    
    fvs = Val(CSheet.WSGetProp(ActiveSheet, CURVE_SHEET_FLAGVALUES))
    If fvs <= 0 Then Exit Sub
    If (fvs And CURVE_FLG_EDIT_DATES) = 0 Or (fvs And CURVE_FLG_TIMESERIES) <> 0 Then Exit Sub
    
    With Selection
        If (fvs And CURVE_FLG_PIVOT) = 0 Then
            If .column <> 1 And .column <> 2 Then Exit Sub
            If .row > 4 Then Exit Sub
            
            Set rgn = Selection.offset(-1).Resize(1, 1)
        Else
            If .column > 2 Then Exit Sub
            If .row >= 4 Then Exit Sub
            
            Set rgn = Selection.Parent.Cells(2, 2)
        End If
        'skip checking ProtectContents
    End With
    
    If iserror(rgn) Then Exit Sub
    If Not IsDate(rgn) Then Exit Sub
    
    Call CXLEvents.DisableEvents
    pf = pf Or &H2
    
    With CCurveDates
        Set .TargetSheet = ActiveSheet
        If Int(rgn.Value2) <> Int(CDbl(.ParamEntity.OprStartDate)) Then
            pf = pf Or &H4
            CDDXApp.StatusMessage = "Changing Opr date..."
            
            If .TargetSheet.ProtectContents Then
                Call CCurveControl.Unprotect(.TargetSheet)
                pf = pf Or &H1
            End If
            
            Call CCurveControl.EraseVR
        End If
    End With
    
OOPS:
    If Err.Number <> 0 Then
        CDDXApp.StatusMessage = Err.Description
        pf = pf Or &H10
    End If
    
    If (pf And &H4) <> 0 And (pf And &H10) = 0 Then
        With CCurveDates
            .ParamEntity.OprStartDate = CDate(Int(rgn.Value2))
            .ParamEntity.OprEndDate = .ParamEntity.OprStartDate
            
            Call CCurveControl.SaveCurveProperties(.TargetSheet, .ParamEntity)
            CDDXApp.StatusMessage = "Opr date changed"
        End With
    End If
    
    If (pf And &H1) <> 0 Then Call CCurveControl.Protect(CCurveDates.TargetSheet)
    If (pf And &H2) <> 0 Then Call CXLEvents.RestoreEvents
    Exit Sub
End Sub
Attribute VB_Name = "CUploadSheetCreator"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Const UPLOAD_SHEET_ROW_COUNT                        As String = "uploadSheetRowCount"
Private Const UPLOAD_SHEET_COLUMN_COUNT                     As String = "uploadSheetColumnCount"

Public Function NewUploadSheet(ByVal aType As String, Optional wk As Excel.Workbook) As Worksheet
10
        On Error GoTo OOPS

        Dim ws                          As Excel.Worksheet
        Dim r                           As Excel.range
        Dim tbladr                      As String

    If wk Is Nothing Then Set wk = ActiveWorkbook
    If wk.ProtectStructure Then
        CDDXApp.StatusMessage = "Unable to add any new sheet because structure of the current workbook is being protected."
        Exit Function
    End If
    
20      With CDDXUpload

30          If Len(Join(.UserUploadTables)) = 0 Then
40              CDDXApp.StatusMessage = "No upload table available and/or no access permissions."

50              Exit Function
60          End If
70      End With

110     Call CDDXUtility.SetScreenUpdating(False)

120     Set ws = wk.Worksheets.Add()
130     ws.name = GetNewUploadSheetName(wk, aType)

140     Call DrawUploadSheetTitle(ws, aType)
150     Call DrawUploadSheetHeader(ws, aType, IIf(aType = ZESHEET_SPOT, 5, 7))
160     Call DrawUploadSheetDataEntryWorkSpace(ws, aType, IIf(aType = ZESHEET_SPOT, 5, 7), 8)

170     Select Case aType
        Case ZESHEET_FORECAST, ZESHEET_FUTURES
190         ' forecast. futures
200         tbladr = "G7"
210
220     Case Else
230         ' spot
            tbladr = "E7"

        End Select

240     Call CDDXUpload.V2SetDateFormat(DDX_PID, ws, aType)
250     Call CDDXUpload.V2SetLastDataColumn(DDX_PID, ws, aType)
260     Call CDDXHelper.MarkZESheet(DDX_PID, ws, aType)
        Call CDDXHelper.MarkZEDoc(DDX_PID, ws.Parent)
270     Call CDDXUpload.V2SetAttributeRows(DDX_PID, ws, aType)

280     Set r = ws.range("A1")
290     ' r.Cells(21, 3).Select
300     Call GetUploadTable(ws.range(tbladr))

350     ws.EnableSelection = xlUnlockedCells

        CSheet.ZESheetID(ws) = CDDXHelper.NewGUID()

360     Call CDDXUpload.ProtectSheet(ws)
370     Set NewUploadSheet = ws
380     Call CDDXUtility.SetScreenUpdating(True)

390     On Error GoTo 0
400     Exit Function
OOPS:
        Dim errDesc       As String, errNum       As Long
410     errDesc = "CUploadSheetCreator.NewUploadSheet(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
420     errNum = Err.Number
        'your clean up codes here
430     Call Err.Raise(errNum, Err.source, errDesc)

End Function

Public Sub RePaintUploadSheet(sheet As Excel.Worksheet, targetRange As Excel.range)
10
        On Error GoTo OOPS

        Dim originalRowsCount           As Long
        Dim originalColumnsCount        As Long
        Dim lastRow                     As Long
        Dim lastColumn                  As Long
        Dim index                       As Long

20      originalRowsCount = GetRowCount(sheet)
30      originalColumnsCount = GetColumnCount(sheet)

40      lastRow = CDDXUpload.V2LastRow(sheet)
50      lastColumn = CDDXUpload.V2LastColumn(sheet)

60      Call CDDXUtility.SetScreenUpdating(False)
70      Call CDDXUpload.UnProtectSheet(sheet)

80      Call setupRange(sheet.Cells(10, 4).Resize(10, originalColumnsCount + 1), False, True)
90      Call setRowsBackColor(sheet, 9, IIf(originalRowsCount > lastRow - 20, 22 + originalRowsCount, lastRow + 9))

100     Call DrawUploadSheetHeader(sheet, CSheet.ZESheetType(sheet), lastColumn - 4)

110     Call setupRange(sheet.Cells(21, 3).Resize(originalRowsCount, originalColumnsCount + 2), False, True)

120     Call DrawUploadSheetDataEntryWorkSpace(sheet, CSheet.ZESheetType(sheet), lastColumn - 4, lastRow - IIf(CSheet.ZESheetType(sheet) = ZESHEET_FUTURES, 18, 20))
130     Call CDDXUpload.ProtectSheet(sheet)
140     Call CDDXUtility.SetScreenUpdating(True)

150     On Error GoTo 0
160     Exit Sub
OOPS:
        Dim errDesc        As String, errNum      As Long
170     errDesc = "CUploadSheetCreator.RePaintUploadSheet(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
180     errNum = Err.Number
        'your clean up codes here
190     Call Err.Raise(errNum, Err.source, errDesc)

End Sub

Private Sub setRowsBackColor(sheet As Excel.Worksheet, startRowIndex As Long, endRowIndex As Long)

        On Error GoTo OOPS

10      Dim i                           As Long

20      For i = startRowIndex To endRowIndex

30          sheet.rows(i).Interior.color = 16053492

40          If i > 8 Then
50              Call setupRange(sheet.rows(i), True, True, False, "", 15)
60          End If
70      Next i

80      On Error GoTo 0
90      Exit Sub
OOPS:
        Dim errDesc        As String, errNum      As Long
100     errDesc = "CUploadSheetCreator.setRowsBackColor(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
110     errNum = Err.Number
        'your clean up codes here
120     Call Err.Raise(errNum, Err.source, errDesc)

End Sub

Private Sub DrawUploadSheetTitle(sheet As Excel.Worksheet, uploadType As String)

        On Error GoTo OOPS
10
        Dim targetRange                 As Excel.range
        Dim index                       As Long
        Dim columnOffset                As Long

20      sheet.Cells(1, 1).RowHeight = 0
30      sheet.Cells(2, 1).RowHeight = 40
40      sheet.Cells(3, 1).RowHeight = 0
50      sheet.Cells(4, 1).RowHeight = 27

60      For index = 5 To 8
70          sheet.Cells(index, 1).RowHeight = 20
80      Next index

90      Call setRowsBackColor(sheet, 4, 37)

100     sheet.rows(2).Interior.color = RGB(&H0, &H52, &H93)
110     sheet.Columns.ColumnWidth = 20
120     sheet.Columns(1).ColumnWidth = 4
130     sheet.Columns(2).ColumnWidth = 4

140     With sheet.Cells(2, 4).Resize(1, 6)
150         Call .Merge
160         .VerticalAlignment = xlCenter
170         .value = "Upload " + GetUploadSheetRootName(uploadType) + " Sheet"
180         .Font.size = 18
190         .Font.ColorIndex = 2
200     End With

        With sheet
            Call .Shapes.AddPicture(CDDXHelper.GetImagesDirectory() + "data-direct-logo.gif", msoFalse, msoTrue, .Cells(2, 1).left + 3, .Cells(2, 1).top + 3, -1, -1)
        End With

250     With sheet.rows(2)
260         .Borders(xlEdgeBottom).LineStyle = xlContinuous
270         .Borders(xlEdgeBottom).Weight = xlThick
280         .Borders(xlEdgeBottom).color = RGB(&H5E, &HB6, &HE4)
290     End With

300     Set targetRange = sheet.Cells(4, 1).Resize(1, 3)

310     Call targetRange.Merge
320     Call setupRange(targetRange, True, True, False, "")
330     Call AddUploadButtons(targetRange)

340     If (uploadType = ZESHEET_FORECAST Or uploadType = ZESHEET_FUTURES) Then

350         columnOffset = 2

360         Set targetRange = sheet.Cells(4, 4).Resize(1, 2)

370         Call targetRange.Merge
380         Call setupRange(targetRange, True, True, True, "Date Options")
390         Call setupRange(sheet.Cells(5, 4), True, True, False, "Forecast Date:")
400         Call setupRange(sheet.Cells(5, 5), True, False, False, "")
410         Call AddDateValidation(sheet.Cells(5, 5))

420         Set targetRange = sheet.Cells(6, 4).Resize(3, 2)

430         Call targetRange.Merge
440         Call setupRange(targetRange, True, True, False, "")
450     End If

460     Set targetRange = sheet.Cells(4, 10 + columnOffset).Resize(1, 2)
470     Call targetRange.Merge
        '470       Call AddImportExportButton(targetRange)

480     Set targetRange = sheet.Cells(4, 4 + columnOffset).Resize(1, 2)
490     Call targetRange.Merge
500     Call setupRange(targetRange, True, True, True, "Upload Destination")

510     Set targetRange = sheet.Cells(4, 6 + columnOffset).Resize(1, 2)
520     Call targetRange.Merge
530     Call setupRange(targetRange, True, True, True, "Upload Range")

540     Set targetRange = sheet.Cells(4, 8 + columnOffset).Resize(1, 2)
550     Call targetRange.Merge
560     Call setupRange(targetRange, True, True, True, "Actions On Upload")

570     Call setupRange(sheet.Cells(5, 4 + columnOffset), True, True, False, "Name Space:")
580     Call setupRange(sheet.Cells(5, 5 + columnOffset), True, False, False, "")
590     Call setupRange(sheet.Cells(5, 6 + columnOffset), True, True, False, "First Row of Data:")
600     Call setupRange(sheet.Cells(5, 7 + columnOffset), True, False, False, IIf(uploadType = ZESHEET_FUTURES, "19", "21"))

610     Call AddRowIndexValidation(sheet.Cells(5, 7 + columnOffset), IIf(uploadType = ZESHEET_FUTURES, 19, 21))

620     Call setupRange(sheet.Cells(5, 8 + columnOffset), True, True, False, "Insert Records Only:")
630     Call setupRange(sheet.Cells(5, 9 + columnOffset), True, False, False, "")

640     Call AddYesNoValidation(sheet.Cells(5, 9 + columnOffset))

650     Call setupRange(sheet.Cells(6, 4 + columnOffset), True, True, False, "Database Object:")
660     Call setupRange(sheet.Cells(6, 5 + columnOffset), True, False, False, "")
670     Call setupRange(sheet.Cells(6, 6 + columnOffset), True, True, False, "Last Row of Data:")
680     Call setupRange(sheet.Cells(6, 7 + columnOffset), True, False, False, IIf(uploadType = ZESHEET_FUTURES, "26", "28"))

690     Call AddRowIndexValidation(sheet.Cells(6, 7 + columnOffset), IIf(uploadType = ZESHEET_FUTURES, 19, 21))

700     Call setupRange(sheet.Cells(6, 8 + columnOffset), True, True, False, "Load Metadata:")
710     Call setupRange(sheet.Cells(6, 9 + columnOffset), True, False, False, "")

720     Call AddYesNoValidation(sheet.Cells(6, 9 + columnOffset))

730     Call setupRange(sheet.Cells(7, 4 + columnOffset), True, True, False, "Target Table:")
740     Call setupRange(sheet.Cells(7, 5 + columnOffset), True, False, False, "")
750     Call setupRange(sheet.Cells(7, 6 + columnOffset), True, True, False, "Last Column of Data:")
760     Call setupRange(sheet.Cells(7, 7 + columnOffset), True, False, False, "")
770     Call setupRange(sheet.Cells(8, 6 + columnOffset), True, True, False, "Attribute Rows:")
780     Call setupRange(sheet.Cells(8, 7 + columnOffset), True, False, False, "")

790     Set targetRange = sheet.Cells(8, 4 + columnOffset).Resize(1, 2)

800     Call targetRange.Merge

810     Call setupRange(targetRange, True, True, False, "")

820     Set targetRange = sheet.Cells(7, 8 + columnOffset).Resize(2, 2)

830     Call targetRange.Merge

840     Call setupRange(targetRange, True, True, False, "")

850     On Error GoTo 0
860     Exit Sub
OOPS:
        Dim errDesc        As String, errNum      As Long
870     errDesc = "CUploadSheetCreator.DrawUploadSheetTitle(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
880     errNum = Err.Number
        'your clean up codes here
890     Call Err.Raise(errNum, Err.source, errDesc)

End Sub

Private Sub AddRowIndexValidation(targetRange As Excel.range, Optional firstRow As Long = 21)

10      On Error GoTo OOPS

20      If targetRange Is Nothing Then Exit Sub

30      Call targetRange.Validation.Delete
40      Call targetRange.Validation.Add(xlValidateWholeNumber, xlValidAlertStop, xlBetween, firstRow, 30000)

50      On Error GoTo 0
60      Exit Sub
OOPS:
        Dim errDesc        As String, errNum      As Long
70      errDesc = "CUploadSheetCreator.AddRowIndexValidation(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
80      errNum = Err.Number
        'your clean up codes here
90      Call Err.Raise(errNum, Err.source, errDesc)

End Sub

Private Sub AddYesNoValidation(targetRange As Excel.range)

10      On Error GoTo OOPS

20      If targetRange Is Nothing Then Exit Sub

30      Call targetRange.Validation.Delete
40      Call targetRange.Validation.Add(xlValidateList, xlValidAlertStop, xlBetween, "No,Yes")

50      targetRange.value = "No"

60      On Error GoTo 0
70      Exit Sub
OOPS:
        Dim errDesc        As String, errNum      As Long
80      errDesc = "CUploadSheetCreator.AddYesNoValidation(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
90      errNum = Err.Number
        'your clean up codes here
100     Call Err.Raise(errNum, Err.source, errDesc)

End Sub

Private Sub DrawUploadSheetHeader(sheet As Excel.Worksheet, uploadType As String, columnsCount As Long)

10      On Error GoTo OOPS

        Dim index                       As Long
        Dim color                       As Long
        Dim rowCount                    As Long

        rowCount = 10

20      Select Case uploadType
        Case ZESHEET_FORECAST
            color = 16447216

30      Case ZESHEET_SPOT
            color = 16773109

40      Case ZESHEET_FUTURES
41          color = 14611454
42          rowCount = 8
50      End Select

60      For index = 1 To rowCount

70          If (index Mod 2 = 0) Then
80              sheet.Cells(9 + index, 3).Resize(1, columnsCount + 2).Interior.color = UPLOAD_COLOR_ODD_ROW
90          Else
100             sheet.Cells(9 + index, 3).Resize(1, columnsCount + 2).Interior.color = color
110         End If

120         Call setupRange(sheet.Cells(9 + index, 3).Resize(1, columnsCount + 2), True, True, False, "", 56)

            ' DDX-1498: Cells of attribute values in upload sheet should be formatted as Text,
            ' otherwise numeric text values are unexpectedly turned into numbers
            sheet.Cells(9 + index, 3).Resize(1, columnsCount + 2).NumberFormat = "@"

130     Next index

140     Select Case uploadType
        Case ZESHEET_FORECAST
            color = 13470981

150     Case ZESHEET_SPOT
            color = 13317468

160     Case ZESHEET_FUTURES
            color = 627181

170     End Select

180     With sheet.Cells(10, 2).Resize(rowCount)
190         Call .Merge
200         .value = "Header Information"
210         .Interior.color = color
220         .Borders.color = RGB(&HD9, &HD9, &HD9)
230         .Orientation = 90
240         .Font.Bold = True
250         .Font.ColorIndex = 2
260     End With

270     Call setupRange(sheet.Cells(9, 3), True, True, True, "Tag", 56)
280     Call setupRange(sheet.Cells(9, 4), True, True, True, "Caption", 56)

290     For index = 1 To rowCount
300         Call setupRange(sheet.Cells(9 + index, 3), True, True, True, "Attribute " + CStr(index), 56)
310     Next index

320     For index = 1 To columnsCount
330         Call setupRange(sheet.Cells(9, 4 + index), True, True, True, "Attr Column " + CStr(index), 56)
340     Next index

350     Call setupRange(sheet.Cells(10, 4).Resize(10, columnsCount + 1), False, False)
360     Call SetColumnCount(sheet, columnsCount)
370     Call AddGroupToAttribute(sheet, rowCount)

380     On Error GoTo 0
390     Exit Sub
OOPS:
        Dim errDesc         As String, errNum       As Long
400     errDesc = "CUploadSheetCreator.DrawUploadSheetHeader(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
410     errNum = Err.Number
        'your clean up codes here
420     Call Err.Raise(errNum, Err.source, errDesc)

End Sub

Private Sub AddGroupToAttribute(sheet As Excel.Worksheet, Optional groupSize As Long = 10)

10      On Error GoTo OOPS

20      If sheet Is Nothing Then Exit Sub

        Dim targetRange                 As Excel.range

30      Set targetRange = sheet.rows(10)
40      Set targetRange = targetRange.Resize(groupSize)

50      If targetRange.OutlineLevel = 1 Then
60          Call targetRange.group
70      End If

80      With sheet.Outline
90          .SummaryRow = xlSummaryAbove
100         .AutomaticStyles = True
110     End With

120     On Error GoTo 0
130     Exit Sub
OOPS:
        Dim errDesc         As String, errNum       As Long
140     errDesc = "CUploadSheetCreator.AddGroupToAttribute(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
150     errNum = Err.Number
        'your clean up codes here
160     Call Err.Raise(errNum, Err.source, errDesc)

End Sub

Private Sub DrawUploadSheetDataEntryWorkSpace(sheet As Excel.Worksheet, uploadType As String, columnsCount As Long, rowsCount As Long)

10      On Error GoTo OOPS

        Dim index                       As Long
        Dim headerRow                   As Long
        Dim firstRow                    As Long

11      headerRow = IIf(uploadType = ZESHEET_FUTURES, 18, 20)
12      firstRow = headerRow + 1

20      For index = 1 To rowsCount

30          If index Mod 2 = 0 Then
40              sheet.Cells(headerRow + index, 3).Resize(1, columnsCount + 2).Interior.color = 13695215
50          Else
60              sheet.Cells(headerRow + index, 3).Resize(1, columnsCount + 2).Interior.color = UPLOAD_COLOR_ODD_ROW
70          End If

80          Call setupRange(sheet.Cells(headerRow + index, 3).Resize(1, columnsCount + 2), True, True, False, "", 56)
90      Next index

100     With sheet.Cells(firstRow, 2).Resize(rowsCount)
110         Call .Merge
120         .value = "Data Entry Workspace"
130         .Interior.color = 3969910
140         .Borders.color = RGB(&HD9, &HD9, &HD9)
150         .Orientation = 90
160         .Font.Bold = True
170         .VerticalAlignment = xlTop
180         .Font.ColorIndex = 2
190     End With

200     If uploadType = ZESHEET_FUTURES Then

210         Call setupRange(sheet.Cells(headerRow, 3), True, True, True, "Contract Type", 56)
220         Call AddContractTypeValidation(sheet.Cells(firstRow, 3).Resize(rowsCount))
230         Call setupRange(sheet.Cells(headerRow, 4), True, True, True, "Start Date", 56)
240         Call AddDateValidation(sheet.Cells(firstRow, 4).Resize(rowsCount))
250     Else
260         Call setupRange(sheet.Cells(headerRow, 3), True, True, True, "Start Date", 56)
270         Call AddDateValidation(sheet.Cells(firstRow, 3).Resize(rowsCount))
280         Call setupRange(sheet.Cells(headerRow, 4), True, True, True, "Hour", 56)
290         Call AddHourValidation(sheet.Cells(firstRow, 4).Resize(rowsCount))
300     End If

310     Call setupRange(sheet.Cells(headerRow, 3).Resize(, 2), True, True, True, "")

320     For index = 1 To columnsCount
330         Call setupRange(sheet.Cells(headerRow, 4 + index), True, True, True, "Data Column " & CStr(index), 56)
340     Next index

350     Call setupRange(sheet.Cells(firstRow, 3).Resize(rowsCount, columnsCount + 2), False, False)
360     Call SetRowCount(sheet, rowsCount)
370     Call SetColumnCount(sheet, columnsCount)
380     Call freezeDataPane(sheet, firstRow)

390     On Error GoTo 0
400     Exit Sub
OOPS:
        Dim errDesc         As String, errNum       As Long
410     errDesc = "CUploadSheetCreator.DrawUploadSheetDataEntryWorkSpace(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
420     errNum = Err.Number
        'your clean up codes here
430     Call Err.Raise(errNum, Err.source, errDesc)

End Sub

Private Sub freezeDataPane(sheet As Excel.Worksheet, firstRow As Long)

10      On Error GoTo OOPS

20      If sheet Is Nothing Then Exit Sub

        Dim targetRange                 As Excel.range

30      Set targetRange = sheet.rows(firstRow)
40      Call targetRange.Select
50      Application.ActiveWindow.FreezePanes = True

60      On Error GoTo 0
70      Exit Sub
OOPS:
        Dim errDesc         As String, errNum       As Long
80      errDesc = "CUploadSheetCreator.freezeDataPane(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
90      errNum = Err.Number
        'your clean up codes here
100     Call Err.Raise(errNum, Err.source, errDesc)

End Sub

Private Sub AddContractTypeValidation(targetRange As Excel.range)

10      On Error GoTo OOPS

20      If targetRange Is Nothing Then Exit Sub

30      Call targetRange.Validation.Delete
40      Call targetRange.Validation.Add(xlValidateList, xlValidAlertStop, xlBetween, "Annual, Daily, HalfYear, Monthly, Quarterly, Week (Mon-Sun), Week (Sun-Sat), Weekday, Weekend")

50      On Error GoTo 0
60      Exit Sub
OOPS:
        Dim errDesc         As String, errNum       As Long
70      errDesc = "CUploadSheetCreator.AddContractTypeValidation(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
80      errNum = Err.Number
        'your clean up codes here
90      Call Err.Raise(errNum, Err.source, errDesc)

End Sub

Private Sub AddDateValidation(targetRange As Excel.range)

10      On Error GoTo OOPS

20      If targetRange Is Nothing Then Exit Sub

30      Call targetRange.Validation.Delete
40      Call targetRange.Validation.Add(xlValidateDate, xlValidAlertStop, xlBetween, "1900-01-01", "3900-01-01")

50      On Error GoTo 0
60      Exit Sub
OOPS:
        Dim errDesc         As String, errNum       As Long
70      errDesc = "CUploadSheetCreator.AddDateValidation(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
80      errNum = Err.Number
        'your clean up codes here
90      Call Err.Raise(errNum, Err.source, errDesc)

End Sub

Private Sub AddHourValidation(targetRange As Excel.range)

10      On Error GoTo OOPS

20      If targetRange Is Nothing Then Exit Sub

30      Call targetRange.Validation.Delete
40      Call targetRange.Validation.Add(xlValidateList, xlValidAlertStop, xlBetween, "1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25")

50      On Error GoTo 0
60      Exit Sub
OOPS:
        Dim errDesc         As String, errNum       As Long
70      errDesc = "CUploadSheetCreator.AddHourValidation(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
80      errNum = Err.Number
        'your clean up codes here
90      Call Err.Raise(errNum, Err.source, errDesc)

End Sub

Private Sub AddUploadButtons(targetRange As Excel.range)

10      On Error GoTo OOPS

20      If targetRange Is Nothing Then Exit Sub

        Dim uploadButton                As Excel.Button

30      Set uploadButton = targetRange.Worksheet.buttons.Add(targetRange.left + 4, targetRange.top + 4, 45, 17)

40      uploadButton.OnAction = "MSaveUpload"
50      uploadButton.Caption = "Upload"
          
60      Set uploadButton = targetRange.Worksheet.buttons.Add(targetRange.left + 55, targetRange.top + 4, 90, 17)

70      uploadButton.OnAction = "MLoadMetaData"
80      uploadButton.Caption = "Reload Metadata"

90      On Error GoTo 0
100     Exit Sub
OOPS:
        Dim errDesc         As String, errNum       As Long
110     errDesc = "CUploadSheetCreator.AddUploadButtons(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
120     errNum = Err.Number
        'your clean up codes here
130     Call Err.Raise(errNum, Err.source, errDesc)

End Sub

Private Sub AddImportExportButton(targetRange As Excel.range)

10      On Error GoTo OOPS

20      If targetRange Is Nothing Then Exit Sub

        Dim uploadButton                As Excel.Button

30      Set uploadButton = targetRange.Worksheet.buttons.Add(targetRange.left + 4, targetRange.top + 4, 45, 17)
40      uploadButton.OnAction = "MImport"
50      uploadButton.Caption = "Import"

60      Set uploadButton = targetRange.Worksheet.buttons.Add(targetRange.left + 55, targetRange.top + 4, 45, 17)
70      uploadButton.OnAction = "MExport"
80      uploadButton.Caption = "Export"

90      On Error GoTo 0
100     Exit Sub
OOPS:
        Dim errDesc         As String, errNum       As Long
110     errDesc = "CUploadSheetCreator.AddImportExportButton(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
120     errNum = Err.Number
        'your clean up codes here
130     Call Err.Raise(errNum, Err.source, errDesc)

End Sub

Private Sub setupRange(targetRange As Excel.range, Optional isSetBorders As Boolean = False, Optional islocked As Boolean = True, _
    Optional isBold As Boolean = False, Optional rangeValue As String = vbNullString, Optional fontColorIndex As Long = -1)

10      On Error GoTo OOPS

20      If targetRange Is Nothing Then Exit Sub

30      If (isSetBorders) Then

40          With targetRange
50              .Borders.LineStyle = xlContinuous
60              .Borders.Weight = xlThin
70              .Borders.color = RGB(&HD9, &HD9, &HD9)
80          End With
90      End If

100     Call setRangeLocked(targetRange, islocked)

110     If (islocked = False) Then

120         If targetRange.rows.count = 1 And targetRange.Columns.count = 1 Then
130             targetRange.Interior.color = UPLOAD_COLOR_ODD_ROW
140         End If
150     End If

160     If isBold Then

170         With targetRange
180             .Font.Bold = True
190             .HorizontalAlignment = xlCenter
200             .VerticalAlignment = xlCenter
210         End With
220     End If

230     If (fontColorIndex > 0) Then
240         targetRange.Font.ColorIndex = fontColorIndex
250     End If

260     If (Len(rangeValue) > 0) Then
270         targetRange.value = rangeValue
280     End If

290     On Error GoTo 0
300     Exit Sub
OOPS:
        Dim errDesc         As String, errNum       As Long
310     errDesc = "CUploadSheetCreator.setupRange(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
320     errNum = Err.Number
        'your clean up codes here
330     Call Err.Raise(errNum, Err.source, errDesc)

End Sub

Public Sub setRangeLocked(targetRange As Excel.range, islocked As Boolean)

10      On Error GoTo OOPS

20      If targetRange Is Nothing Then Exit Sub

30      targetRange.Locked = islocked
        ' targetRange.Interior.color = RGB(100, 10, 10)

40      On Error GoTo 0
50      Exit Sub
OOPS:
        'ignore the error explicitly
60      Call Err.Clear

End Sub

Private Function GetUploadTable(rg As Excel.range)

10      On Error GoTo OOPS

20      If left$(Trim$(UCase$(right$(rg.offset(0, -1).value, 6))), 5) = "TABLE" Then

30          Call CDDXUpload.GetUploadTables(DDX_PID, rg)
40      End If

50      On Error GoTo 0
60      Exit Function
OOPS:
        Dim errDesc         As String, errNum       As Long
70      errDesc = "CUploadSheetCreator.GetUploadTable(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
80      errNum = Err.Number
        'your clean up codes here
90      Call Err.Raise(errNum, Err.source, errDesc)

End Function

Private Function GetUploadSheetRootName(uploadType As String) As String

        On Error GoTo OOPS

        Dim root                        As String
10
20      Select Case uploadType
            Case ZESHEET_FORECAST:   root = "Forecast"

30          Case ZESHEET_SPOT:   root = "Spot"

40          Case ZESHEET_FUTURES:   root = "Futures"
50      End Select

60      GetUploadSheetRootName = root

70      On Error GoTo 0
80      Exit Function
OOPS:
        Dim errDesc         As String, errNum       As Long
90      errDesc = "CUploadSheetCreator.GetUploadSheetRootName(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
100     errNum = Err.Number
        'your clean up codes here
110     Call Err.Raise(errNum, Err.source, errDesc)

End Function

Private Function GetNewUploadSheetName(Wb As Excel.Workbook, ByVal aType As String) As String

        On Error GoTo OOPS

        Dim f                           As Excel.Worksheet
        Dim part                        As String
        Dim root                        As String
        Dim n                           As Long
        Dim m                           As Long
10
20      root = GetUploadSheetRootName(aType)
30      n = 0

40      For Each f In Wb.Worksheets

50          If UCase$(f.name) Like UCase$(root) & "-*" Then

60              m = Len(root & "-")
70              part = Mid$(f.name, m + 1)

80              If IsNumeric(part) Then
90                  If CLng(part) > n Then n = CLng(part)
100             End If
110         End If
120     Next f

130     GetNewUploadSheetName = root & "-" & CStr(n + 1)

140     On Error GoTo 0
150     Exit Function
OOPS:
        Dim errDesc         As String, errNum       As Long
160     errDesc = "CUploadSheetCreator.GetNewUploadSheetName(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
170     errNum = Err.Number
        'your clean up codes here
180     Call Err.Raise(errNum, Err.source, errDesc)

End Function

Private Function GetRowCount(sheet As Excel.Worksheet) As Long

10      On Error GoTo OOPS

20      If sheet Is Nothing Then Exit Function

30      GetRowCount = CLng(CSheet.WSGetProp(sheet, UPLOAD_SHEET_ROW_COUNT))

40      On Error GoTo 0
50      Exit Function
OOPS:
        Dim errDesc         As String, errNum       As Long
60      errDesc = "CUploadSheetCreator.GetRowCount(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
70      errNum = Err.Number
        'your clean up codes here
80      Call Err.Raise(errNum, Err.source, errDesc)

End Function

Private Sub SetRowCount(sheet As Excel.Worksheet, rowCount As Long)

10      On Error GoTo OOPS

20      If sheet Is Nothing Then Exit Sub

30      Call CSheet.WSSetProp(sheet, UPLOAD_SHEET_ROW_COUNT, CStr(rowCount))

40      On Error GoTo 0
50      Exit Sub
OOPS:
        Dim errDesc         As String, errNum       As Long
60      errDesc = "CUploadSheetCreator.SetRowCount(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
70      errNum = Err.Number
        'your clean up codes here
80      Call Err.Raise(errNum, Err.source, errDesc)

End Sub

Private Function GetColumnCount(sheet As Excel.Worksheet) As Long

10      On Error GoTo OOPS

20      If sheet Is Nothing Then Exit Function

30      GetColumnCount = CLng(CSheet.WSGetProp(sheet, UPLOAD_SHEET_COLUMN_COUNT))

40      On Error GoTo 0
50      Exit Function
OOPS:
        Dim errDesc         As String, errNum       As Long
60      errDesc = "CUploadSheetCreator.GetColumnCount(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
70      errNum = Err.Number
        'your clean up codes here
80      Call Err.Raise(errNum, Err.source, errDesc)

End Function

Private Sub SetColumnCount(sheet As Excel.Worksheet, ColumnCount As Long)

10        On Error GoTo OOPS

20        If sheet Is Nothing Then Exit Sub

30        Call CSheet.WSSetProp(sheet, UPLOAD_SHEET_COLUMN_COUNT, CStr(ColumnCount))

40        On Error GoTo 0
50        Exit Sub
OOPS:
          Dim errDesc         As String, errNum       As Long
60        errDesc = "CUploadSheetCreator.SetColumnCount(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
70        errNum = Err.Number
          ' your clean up codes here
80        Call Err.Raise(errNum, Err.source, errDesc)

End Sub

Private Function isRangeValidated(target As Excel.range) As Boolean

10      On Error GoTo OOPS

20      If Not (target Is Nothing) Then

30          If Not (target.Validation Is Nothing) Then

40              isRangeValidated = target.Validation.value
50          End If
60      End If

70      On Error GoTo 0
80      Exit Function
OOPS:
        ' ignore the error explicitly
90      Call Err.Clear

End Function

Public Sub OnUploadsheetChange(target As Excel.range)

10      On Error GoTo OOPS

        Dim labelRange                  As Excel.range
        Dim isUploadSheetChange         As Boolean

20      Call validateUploadSheetChange(target)

30      Set labelRange = target.offset(, -1)

40      If labelRange.text = "Last Column of Data:" Then

50          isUploadSheetChange = validateLastColumn(target)

60      ElseIf labelRange.text = "Last Row of Data:" Then

70          isUploadSheetChange = True
80      End If

90      If isUploadSheetChange Then
100         Call CUploadSheetCreator.RePaintUploadSheet(target.Parent, target)
110     End If

120     On Error GoTo 0
130     Exit Sub
OOPS:
        Dim errDesc         As String, errNum       As Long
140     errDesc = "CUploadSheetCreator.OnUploadsheetChange(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
150     errNum = Err.Number
        'your clean up codes here
160     Call Err.Raise(errNum, Err.source, errDesc)

End Sub

Public Function validateLastColumn(target As Excel.range) As Boolean

10      On Error GoTo OOPS

20      If target Is Nothing Then Exit Function

        Dim isEnableEvents              As Boolean
        Dim result                      As Boolean
        Dim columnIndex                 As Long

30      isEnableEvents = Application.EnableEvents
40      Application.EnableEvents = False

50      If IsNumeric(target.value) Then

60          If (target.value >= 5) And (target.value < 1000) Then

70              target.value = Int(target.value)
80              result = True
90          End If
100     Else
110         target.value = UCase$(target.value)

120         If Len(target.value) = 1 Then

130             If Asc(target.value) >= Asc("E") And Asc(target.value) <= Asc("z") Then
140                 result = True
150             End If

160         ElseIf Len(target.value) = 2 Then

170             If Asc(left$(target.value, 1)) >= Asc("A") And Asc(left$(target.value, 1)) <= Asc("Z") Then

180                 If Asc(right$(target.value, 1)) >= Asc("A") And Asc(right$(target.value, 1)) <= Asc("Z") Then

190                     columnIndex = CDDXUtility.ColumnLetterToLong(target.value)

200                     If columnIndex >= 5 And columnIndex < 1000 Then
210                         result = True
220                     End If
230                 End If
240             End If
250         End If
260     End If

270     If result = False Then
280         target.value = vbNullString
290         Call CDDXApp.DialogMessage("your last operation was cancelled since it is not validated.", vbCritical)
300     End If

310     validateLastColumn = result
320     Application.EnableEvents = isEnableEvents

330     On Error GoTo 0
340     Exit Function
OOPS:
        Dim errDesc         As String, errNum       As Long
350     errDesc = "CUploadSheetCreator.validateLastColumn(), Line:" & str(Erl()) & " " & vbCrLf & Err.Description
360     errNum = Err.Number
        'your clean up codes here
370     Application.EnableEvents = isEnableEvents
380     Call Err.Raise(errNum, Err.source, errDesc)

End Function

Private Sub validateUploadSheetChange(target As Excel.range)

10      On Error GoTo OOPS

        Dim isEnableEvents              As Boolean

20      isEnableEvents = Application.EnableEvents

30      If (isRangeValidated(target) = False) Then

40          Application.EnableEvents = False
50          Call Application.Undo
60          Application.EnableEvents = isEnableEvents

70          Call CDDXApp.DialogMessage("your last operation was cancelled since it is not validated.", vbCritical)
80      End If

90      Application.EnableEvents = isEnableEvents

100     On Error GoTo 0
110     Exit Sub
OOPS:
120     Call Err.Clear
130     Application.EnableEvents = isEnableEvents

End Sub
Attribute VB_Name = "CVarHelper"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public CONVERSION_VERSION As String
Public CONVERSION_BACKUP As String
Public CONVERSION_SKIP_UNVERSIONED As String
'
Public MESSAGE_DIALOG As String
Public MESSAGE_DEBUG As String
Public MESSAGE_STATUS_BAR As String
'

Public m_debug_message As Boolean

Public Sub GetVars()
    m_debug_message = IIf(StrComp(GetValue(VAR_MESSAGE_STR, MESSAGE_DEBUG), "1") = 0, True, False)
End Sub

'Private Sub SetConversionDefaults()
'    Call SetValue(VAR_CONVERSION, CONVERSION_BACKUP, "1")
'End Sub

Public Function GetValue(varName As String, keyName As String) As String
 Dim s As String
 Dim ary() As String
 Dim k As Long
 Dim idx As Long
 
    s = CDDXVar.GetVar(varName)
    If s = vbNullString Then Exit Function
    ary = Split(s, ";")
    
    For k = LBound(ary) To UBound(ary)
        idx = InStr(ary(k), "=")
        If idx > 0 Then
            If StrComp(left(ary(k), idx - 1), keyName, vbTextCompare) = 0 Then
                GetValue = Trim(Mid(ary(k), idx + 1))
                Exit Function
            End If
        End If
    Next
End Function

Private Sub SetValue(varName As String, keyName As String, keyValue As String)
 Dim s As String
 Dim t As String
 Dim ary() As String
 Dim mask As Integer
 Dim k As Long
 Dim idx As Long

    mask = 0
    s = CDDXVar.GetVar(varName)
    
    If s <> vbNullString Then
        ary = Split(s, ";")
        For k = LBound(ary) To UBound(ary)
            idx = InStr(ary(k), "=")
            If idx > 0 Then
                t = left(ary(k), idx - 1)
            Else
                t = ary(k)
            End If
            
            If StrComp(t, keyName, vbTextCompare) = 0 Then
                mask = mask Or &H1
                Exit For
            End If
        Next
    End If
    
    If (mask And &H1) <> 0 Then Exit Sub
    Call CDDXVar.SetVar(varName, s + IIf(s = vbNullString, vbNullString, ";") + keyName + "=" + keyValue)
End Sub

Private Sub Class_Initialize()
'conversion
    CONVERSION_VERSION = "version"
    CONVERSION_BACKUP = "backup"
    CONVERSION_SKIP_UNVERSIONED = "skipunver"
'messages
    MESSAGE_DIALOG = "dialog"
    MESSAGE_DEBUG = "debug"
    MESSAGE_STATUS_BAR = "status"
End Sub
Attribute VB_Name = "CXLEvents"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private m_enableEvents As Long
Private m_screenUpdating As Long
Private m_displayAlerts As Long
'
Private m_fee As Variant
Private m_fsu As Variant
Private m_fda As Variant

Public Sub DisableEvents()
    With Application
        If m_enableEvents = 0 Then
            m_fee = .EnableEvents
            .EnableEvents = False
        End If
        m_enableEvents = m_enableEvents + 1
        
        If m_screenUpdating = 0 Then
            m_fsu = .ScreenUpdating
            .ScreenUpdating = False
        End If
        m_screenUpdating = m_screenUpdating + 1
        
        If m_displayAlerts = 0 Then
            m_fda = .DisplayAlerts
            .DisplayAlerts = False
        End If
        m_displayAlerts = m_displayAlerts + 1
    End With
End Sub

Public Sub RestoreEvents()
    With Application
        If m_enableEvents > 0 Then
            m_enableEvents = m_enableEvents - 1
            If m_enableEvents = 0 Then .EnableEvents = m_fee
        End If
        
        If m_screenUpdating > 0 Then
            m_screenUpdating = m_screenUpdating - 1
            If m_screenUpdating = 0 Then .ScreenUpdating = m_fsu
        End If

        If m_displayAlerts > 0 Then
            m_displayAlerts = m_displayAlerts - 1
            If m_displayAlerts = 0 Then .DisplayAlerts = m_fda
        End If
    End With
End Sub

Private Sub Class_Initialize()
    m_enableEvents = 0
    m_screenUpdating = 0
    m_displayAlerts = 0
End Sub
Attribute VB_Name = "CXLTaskSwitch"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Declare PtrSafe Function CoRegisterMessageFilter Lib "OLE32.DLL" (ByVal lFilterIn As LongPtr, ByRef lPreviousFilter As LongPtr) As Long
Private Const S_OK As Long = 0

Private m_oldMessageFilter As LongPtr 'we stop supporting vba4
Private m_refCount As Long

Private Sub Class_Initialize()
    m_oldMessageFilter = 0
    m_refCount = 0
End Sub

Private Sub DispRlt(ByVal rlt As Long, ByVal incrBy As Long)
    If rlt = S_OK Then
        m_refCount = m_refCount + incrBy
    Else
        CDDXApp.DebugMessage = "CXlTaskSwitch Err " + CStr(rlt)
    End If
End Sub

Public Function DisableTS() As Long
 Dim rlt As Long
 
    If m_refCount = 0 Then
        rlt = CoRegisterMessageFilter(0, m_oldMessageFilter)
        CDDXApp.DebugMessage = "DisableTS " + CStr(rlt)
    Else
        rlt = S_OK
    End If
    
    Call DispRlt(rlt, 1)
End Function

Public Sub RestoreTS()
 Dim rlt As Long
 Dim filter As LongPtr
 
    If m_refCount <= 0 Then Exit Sub
    
    If m_refCount >= 2 Then
        m_refCount = m_refCount - 1
    Else
        rlt = CoRegisterMessageFilter(m_oldMessageFilter, filter)
        CDDXApp.DebugMessage = "RestoreTS " + CStr(rlt)
        Call DispRlt(rlt, -1)
    End If
End Sub
Attribute VB_Name = "DDXConsts"
Option Explicit

Public Const ZESHEET_NIL As String = vbNullString

Public Const ZESHEET_SPOT As String = "S"
Public Const ZESHEET_FUTURES As String = "U"
Public Const ZESHEET_FORECAST As String = "F"
Public Const ZESHEET_ENTITY As String = "E"

'dynamic dates
Public Const DYNA_DATE_LAST_WHOLE_WEEK As String = "Last Whole Week (Mo. - Su.)"
Public Const DYNA_DATE_LAST_WHOLE_MONTH As String = "Last Whole Month (1 - 31)"
Public Const DYNA_DATE_LAST_WHOLE_6_MONTHS As String = "Last Whole 6 Months" '"Last Whole 6 Month"
Public Const DYNA_DATE_LAST_WHOLE_YEAR As String = "Last Whole Year"
Public Const DYNA_DATE_ROLLING_YESTERDAY As String = "Rolling Yesterday"
Public Const DYNA_DATE_ROLLING_LAST_7_DAYS As String = "Rolling Last 7 Days"
Public Const DYNA_DATE_ROLLING_LAST_30_DAYS As String = "Rolling Last 30 Days"
Public Const DYNA_DATE_ROLLING_LAST_6_MONTHS As String = "Rolling Last 6 Months"
Public Const DYNA_DATE_ROLLING_LAST_9_MONTHS As String = "Rolling Last 9 Months"
Public Const DYNA_DATE_ROLLING_LAST_365_DAYS As String = "Rolling Last 365 Days"
Public Const DYNA_DATE_CURRENT_DAY As String = "Current Day"
Public Const DYNA_DATE_CURRENT_WEEK As String = "Current Week"
Public Const DYNA_DATE_CURRENT_MONTH As String = "Current Month"
Public Const DYNA_DATE_CURRENT_QUARTER As String = "Current Quarter"
Public Const DYNA_DATE_CURRENT_YEAR As String = "Current Year"
Public Const DYNA_DATE_CURRENT_WHOLE_WEEK As String = "Current Whole Week"
Public Const DYNA_DATE_CURRENT_WHOLE_MONTH As String = "Current Whole Month"
Public Const DYNA_DATE_CURRENT_WHOLE_QUARTER As String = "Current Whole Quarter"
Public Const DYNA_DATE_CURRENT_WHOLE_YEAR As String = "Current Whole Year"

Public Const DYNA_DATE_ROLLING_NEXT_7_DAYS As String = "Rolling Next 7 Days"
Public Const DYNA_DATE_ROLLING_NEXT_30_DAYS As String = "Rolling Next 30 Days"
Public Const DYNA_DATE_ROLLING_NEXT_6_MONTHS As String = "Rolling Next 6 Months"
Public Const DYNA_DATE_ROLLING_NEXT_9_MONTHS As String = "Rolling Next 9 Months"
Public Const DYNA_DATE_ROLLING_NEXT_365_DAYS As String = "Rolling Next 365 Days"

Public Const DYNA_DATE_1ST_QUARTER As String = "First Quarter"
Public Const DYNA_DATE_2ND_QUARTER As String = "Second Quarter"
Public Const DYNA_DATE_3RD_QUARTER As String = "Third Quarter"
Public Const DYNA_DATE_4TH_QUARTER As String = "Fourth Quarter"
'
Public Const DYNA_DATE_NEXT_WHOLE_WEEK As String = "Next Whole Week(Mon - Sun)"
Public Const DYNA_DATE_NEXT_WHOLE_MONTH As String = "Next Whole Month(1 - 31)"
Public Const DYNA_DATE_NEXT_WHOLE_6_MONTHS As String = "Next Whole 6 Months"
Public Const DYNA_DATE_NEXT_YEAR As String = "Next Whole Year"

'Variable names
Public Const VAR_CONVERSION_STR As String = "DDXConversion"
Public Const VAR_MESSAGE_STR As String = "DDXMessages"

'Rolling dynamic dates
Public Const RANGE_ROLLING_NONE As Long = &H0
Public Const RANGE_ROLLING_START As Long = &H1
Public Const RANGE_ROLLING_END As Long = &H2
Public Const RANGE_ROLLING_BOTH As Long = (RANGE_ROLLING_START Or RANGE_ROLLING_END)

'suppress nulls
Public Const SUPPRESS_NULLS_LEADING As Long = &H1
Public Const SUPPRESS_NULLS_INBETWEEN As Long = &H2
Public Const SUPPRESS_NULLS_TRAILING As Long = &H4

'Series Options
Public Const HSI_SET As Long = &H1
Public Const HSI_REMOVE_UPON_EMPTY As Long = &H2
Public Const HSI_FORMULA As Long = &H10
Public Const HSI_ROW_AGGREGATION As Long = &H20
Public Const HSI_FILTER As Long = &H40
Public Const HSI_AGGREGATION As Long = &H80
Public Const HSI_CUMULATIVE_AGGREGATION As Long = &H100
Public Const HSI_CONTRACT As Long = &H200
Public Const HSI_FORWARD_ANALYSIS As Long = &H400
Public Const HSI_EXTRPOLATION As Long = &H800
Public Const HSI_INTROPLATION As Long = &H1000
Public Const HSI_SHIFT As Long = &H2000

'time format
Public Const TIME_FORMAT_SET As Long = &H1
Public Const TIME_FORMAT_DEFAULT As Long = &H10
Public Const TIME_FORMAT_023 As Long = &H20

'single column
Public Const SINGLE_COL_SET As Long = &H1
Public Const SINGLE_COL_DEFAULT As Long = &H10
Public Const SINGLE_COL_TRUE As Long = &H20

Public Const HELPER_EVENT_FINGERPINT As Long = 1
Public Const HELPER_EVENT_NR_VISIBILITY As Long = 2

Public Const TYPE_PROFILE As Long = &H1
Public Const TYPE_REPORT As Long = &H2
Public Const TYPE_DCURVE As Long = &H4
Public Const TYPE_SMARTMART As Long = &H8

'
Public Const SCHEDULE_LENGTH As Long = 8
'
Public Const REFRESH_DELAY_NO As Long = 1
Public Const REFRESH_DELAY_YES As Long = 2
Public Const REFRESH_DELAY_PASSES As Long = 3
Public Const REFRESH_DELAY_ENDTIME As Long = 4
Attribute VB_Name = "DDXConstsCP"
Option Explicit

'curve validation relevant constants
Public Const CURVE_SON_ERROR As Long = &H1
Public Const CURVE_SON_WARNING As Long = &H2
Public Const CURVE_SON_UNVALIDATED As Long = &H3
Public Const CURVE_SON_ACCEPTED As Long = &H4
Public Const CURVE_SON_NOT_SUPPORTED As Long = &HF
'
Public Const CURVE_VR_SIZE_CURVE As Long = 2
Public Const CURVE_VR_SIZE_OBSERVATION As Long = 6
Public Const CURVE_VR_SIZE_DATAPOINT As Long = 7
'
Public Const CURVE_VR_CLRIDX_ERR As Long = 38 '22
Public Const CURVE_VR_CLRIDX_WARNING As Long = 40
Public Const CURVE_VR_CLRIDX_UNVALIDATED As Long = 34 ' 39 '21
Public Const CURVE_VR_CLRIDX_CORRECT As Long = 10
Public Const CURVE_VR_CLRIDX_ACCEPTED As Long = 10
Public Const CURVE_VR_CLRIDX_UNSUPPORTED As Long = 55

Public Const CURVE_VR_COLOR_ERR As Long = 13551615
Public Const CURVE_VR_COLOR_WARNING As Long = 8696052
Public Const CURVE_VR_COLOR_UNVALIDATED As Long = 16764108
Public Const CURVE_VR_COLOR_ACCEPTED As Long = &HFF00
Public Const CURVE_VR_COLOR_UNSUPPORTED As Long = 0
'
Public Const CURVE_4EYES_COLOR As Long = &HDBDBDB ' RGB(219, 219, 219)
'
Public Const CURVE_UI_CONTRACTS_DEFINE As Integer = -99
Public Const CURVE_UI_CONTRACTS_NEW As Integer = -9
Public Const CURVE_UI_CONTRACTS_NEW_WITH_DIRECTION As Integer = 0

Public Const CURVE_UI_CONTRACTS_START_PLUS As Integer = 1
Public Const CURVE_UI_CONTRACTS_START_MINUS As Integer = 2
Public Const CURVE_UI_CONTRACTS_END_PLUS As Integer = 3
Public Const CURVE_UI_CONTRACTS_END_MINUS As Integer = 4

Public Const CURVE_DOWNLOAD_RECENT As Long = &H1
Public Const CURVE_DOWNLOAD_CURRENT As Long = &H2

Public Const CURVE_FIND_BY_NAME As Long = &H1
Public Const CURVE_FIND_INCLUDE_RDONLY As Long = &H2
Public Const CURVE_FIND_EXTERNAL_ONLY As Long = &H4
Public Const CURVE_FIND_CURRENT_USER As Long = &H8
Public Const CURVE_FIND_TIMESERIES As Long = &H1000
Public Const CURVE_FIND_MULTIOBS As Long = &H2000
Public Const CURVE_FIND_VOID_RETURN As Long = &H4000 'this works with CURVE_FIND_BY_NAME
Public Const CURVE_FIND_DIFFERENTIAL As Long = &H8000&
Public Const CURVE_FIND_INCLUDE_MULTIOBS As Long = &H10000

Public Const CURVE_OP_STRICT_INPUTS As Long = &H10
Public Const CURVE_OP_INSERT_NULLS As Long = &H20
Public Const CURVE_OP_SYNC As Long = &H40
Public Const CURVE_OP_VR_RETRIEVE As Long = &H80
Public Const CURVE_OP_FOUR_EYES As Long = &H100
Public Const CURVE_OP_INSERT_PROT As Long = &H200
Public Const CURVE_OP_PROTECTED_INFO_ONLY = &H400

'curve flag bits
Public Const CURVE_FLG_MRBD As Long = &H1
Public Const CURVE_FLG_MRBD_COMPLETE As Long = (CURVE_FLG_MRBD Or &H2)
Public Const CURVE_FLG_EDIT_MRBD_COLUMN As Long = &H4
Public Const CURVE_FLG_EDIT_DATES As Long = &H8
Public Const CURVE_FLG_PIVOT As Long = &H10
Public Const CURVE_FLG_DST_ADJUST_START As Long = &H100
Public Const CURVE_FLG_DST_ADJUST_END As Long = &H200

Public Const CURVE_FLG_TIMESERIES As Long = &H1000
Public Const CURVE_FLG_FUTURE_RANGE As Long = &H8000& '32768  '&H8000
Public Const CURVE_FLG_MULTIOBS As Long = &H10000
Public Const CURVE_FLG_V1 As Long = &H10000000 'the 4 most significant bits contain version
Public Const CURVE_FLG_V2 As Long = &H20000000

'granularities
Public Const CURVE_GRANULARITY_NONE As Long = &H0
Public Const CURVE_GRANULARITY_HOURLY As Long = &H1
Public Const CURVE_GRANULARITY_DAILY As Long = &H2
Public Const CURVE_GRANULARITY_MONTHLY As Long = &H4
Public Const CURVE_GRANULARITY_WEEKLY As Long = &H8
Public Const CURVE_GRANULARITY_WEEKDAY As Long = (CURVE_GRANULARITY_WEEKLY Or &H10)
Public Const CURVE_GRANULARITY_WEEKEND As Long = (CURVE_GRANULARITY_WEEKLY Or &H20)
Public Const CURVE_GRANULARITY_WEEKLY_MON2SUN As Long = (CURVE_GRANULARITY_WEEKLY Or &H40)
Public Const CURVE_GRANULARITY_WEEKLY_SUN2SAT As Long = (CURVE_GRANULARITY_WEEKLY Or &H80)
Public Const CURVE_GRANULARITY_QUARTERLY As Long = &H100
Public Const CURVE_GRANULARITY_HALFYEAR As Long = &H200
Public Const CURVE_GRANULARITY_YEARLY As Long = &H400
Public Const CURVE_GRANULARITY_MINUTELY As Long = &H800
Public Const CURVE_GRANULARITY_MIN1 As Long = (CURVE_GRANULARITY_MINUTELY Or &H1000)
Public Const CURVE_GRANULARITY_MIN5 As Long = (CURVE_GRANULARITY_MINUTELY Or &H2000)
Public Const CURVE_GRANULARITY_MIN10 As Long = (CURVE_GRANULARITY_MINUTELY Or &H4000)
Public Const CURVE_GRANULARITY_MIN15 As Long = (CURVE_GRANULARITY_MINUTELY Or &H8000&) ' 32768)
Public Const CURVE_GRANULARITY_MIN30 As Long = (CURVE_GRANULARITY_MINUTELY Or &H10000)
        
'info fields
Public Const CURVE_INFO_FLD_BOOL_TRUE As String = "1"

Public Const CURVE_INFO_FLD_1_READONLY As Long = &H1
Public Const CURVE_INFO_FLD_2_FUTURES  As Long = &H2
Public Const CURVE_INFO_FLD_3_MULTIOBS  As Long = &H4
Public Const CURVE_INFO_FLD_4_GRANULARITIES  As Long = &H100
Public Const CURVE_INFO_FLD_5_CURVETYPES  As Long = &H200
Public Const CURVE_INFO_FLD_6_GRANULARITY_N_CURVETYPE   As Long = &H400

'curve validation levels
Public Const CURVE_VR_L_CURVE As Long = 1
Public Const CURVE_VR_L_OBSERVATION As Long = 2
Public Const CURVE_VR_L_DATAPOINT As Long = 3
Public Const CURVE_VR_L_DATAPOINT_OPRS As Long = 30
'
Public Const CURVE_OBSERVATION_NUMBER As Long = 1
Public Const CURVE_OBSERVATION_DATE As Long = 2
Public Const CURVE_OBSERVATION_TIMESTAMP As Long = 3

'curve events
'Public Const CURVE_EVENT_CURVE_SELECTED As Long = 1
Public Const CURVE_EVENT_INQUIRY_UPLOAD As Long = 2
Public Const CURVE_EVENT_ACCEPT As Long = 3
Public Const CURVE_EVENT_DOWNLOAD_COMPLETED As Long = 4
Public Const CURVE_EVENT_UPLOAD_COMPLETED As Long = 5
Public Const CURVE_EVENT_VIEW_HISTORY As Long = 6
Public Const CURVE_EVENT_EXTEND As Long = 7
Public Const CURVE_EVENT_CHANGE_DATE As Long = 8
Public Const CURVE_EVENT_CHANGE_DATE_RANGE As Long = 9
Public Const CURVE_EVENT_SHOW_UPLOAD_RESULTS As Long = 10
Public Const CURVE_EVENT_START_TASK As Long = 11
Public Const CURVE_EVENT_END_TASK As Long = 12
Public Const CURVE_EVENT_SORT As Long = 13
Public Const CURVE_EVENT_INQUIREY_DOWNLOAD_COLUMNS As Long = 14
Public Const CURVE_EVENT_ACCEPT_RESULTS As Long = 15
Public Const CURVE_EVENT_REFRSH_ALL_CURVES As Long = 16

'curve events (CURVE_EVENT_INQUIRY_UPLOAD)
Public Const CURVE_INQUIRY_HAS_NULLS As Long = &H1
Public Const CURVE_INQUIRY_VALUES_PROT As Long = &H2
Public Const CURVE_INQUIRY_4EYES As Long = &H4 'DONT USE IT

'curve validation error levels
Public Const CURVE_EL_CURVE As Long = &H1
Public Const CURVE_EL_CURVETYPE As Long = &H2
Public Const CURVE_EL_RECORD As Long = &H4
'
Public Const CURVE_EL_CURVE_ACCEPTED As Long = &H100
Public Const CURVE_EL_CURVETYPE_ACCEPTED As Long = &H200
Public Const CURVE_EL_RECORD_ACCEPTED As Long = &H400

'vb positions
Public Const CURVE_VR_POS_CURVETYPE As Long = 2
Public Const CURVE_VR_POS_STATUS As Long = 3

'v2 cb opcodes
Public Const CURVE_V2CB_UPLOAD As Long = 1
Public Const CURVE_V2CB_DOWNLOAD As Long = 2
Public Const CURVE_V2CB_VIEW As Long = 3
Public Const CURVE_V2CB_ACCEPT_VR As Long = 4
Public Const CURVE_V2CB_DELETE As Long = 5

'change permissions
Public Const CURVE_PERMISSION_ADD_WRITE As Long = &H1
Attribute VB_Name = "DDXLimits"
Option Explicit

Public Const XL_MAX_COLUMNS As Long = 16384&
Attribute VB_Name = "DDXObjects"
Option Explicit

Public Property Get AppObject() As CDDXApp
    Set AppObject = CDDXApp
End Property

Public Property Get LoginObject() As CDDXLogin
    Set LoginObject = CDDXLogin
End Property

Public Property Get EntityObject() As CDDXEntity
    Set EntityObject = CDDXEntity
End Property

Public Property Get UploadObject() As CDDXUpload
    Set UploadObject = CDDXUpload
End Property

Public Property Get LibObject() As CDDXLib
    Set LibObject = CDDXLib
End Property

Public Property Get CurveObject() As CDDXCurve
    Set CurveObject = CDDXCurve
End Property

Public Property Get HelperObject() As CDDXHelper
    Set HelperObject = CDDXHelper
End Property

Public Property Get DatesObject() As CDDXDates
    Set DatesObject = CDDXDates
End Property

Public Property Get UtilityObject() As CDDXUtility
    Set UtilityObject = CDDXUtility
End Property

Public Property Get ProfileObject() As CProfile
    Set ProfileObject = CProfile
End Property

Public Property Get ReportObject() As CReport
    Set ReportObject = CReport
End Property

Public Property Get DCurveObject() As CDCurve
    Set DCurveObject = CDCurve
End Property

Public Property Get SmartMartObject() As CSmartMart
    Set SmartMartObject = CSmartMart
End Property

Public Property Get VarObject() As CDDXVar
    Set VarObject = CDDXVar
End Property
Attribute VB_Name = "WinAPI"
Option Explicit
Option Private Module

Public Type POINTAPI
    x As Long
    y As Long
End Type

Public Type RECT
    left As Long
    top As Long
    right As Long
    bottom As Long
End Type

Public Type OSVERSIONINFO
    dwOSVersionInfoSize As Long
    dwMajorVersion As Long
    dwMinorVersion As Long
    dwBuildNumber As Long
    dwPlatformId As Long
    szCSDVersion As String * 128
    wServicePackMajor As Integer
    wServicePackMinor As Integer
    wSuiteMask As Integer
    wProductType As Byte
    wReserved As Byte
End Type

#If Win64 Then
Public Declare PtrSafe Function GetSystemMetrics Lib "user32" (ByVal nIndex As Long) As Long
Public Declare PtrSafe Function SetForegroundWindow Lib "user32" (ByVal hwnd As LongPtr) As LongLong
Public Declare PtrSafe Function GetCursorPos Lib "user32" (lpPoint As POINTAPI) As LongPtr
Public Declare PtrSafe Function WindowFromPoint Lib "user32" (ByVal xPoint As LongLong, ByVal yPoint As LongLong) As LongPtr
Public Declare PtrSafe Function SetCapture Lib "user32" (ByVal hwnd As LongPtr) As LongPtr
Public Declare PtrSafe Function ReleaseCapture Lib "user32" () As LongPtr
Public Declare PtrSafe Function GetCapture Lib "user32" () As LongPtr
Public Declare PtrSafe Function FindWindow Lib "user32.dll" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As LongPtr
Public Declare PtrSafe Function ClipCursor Lib "user32.dll" (lpRect As RECT) As LongLong
Public Declare PtrSafe Function GetWindowRect Lib "user32.dll" (ByVal hwnd As LongPtr, lpRect As RECT) As Long
Public Declare PtrSafe Function GetDesktopWindow Lib "user32.dll" () As LongPtr
Public Declare PtrSafe Function GetClipCursor Lib "user32.dll" (lprc As RECT) As LongLong
Public Declare PtrSafe Function ShellExecute Lib "shell32.dll" Alias "ShellExecuteA" ( _
    ByVal hwnd As LongPtr, _
    ByVal lpOperation As String, _
    ByVal lpFile As String, _
    ByVal lpParameters As String, _
    ByVal lpDirectory As String, _
    ByVal nShowCmd As Integer) As Long
Public Declare PtrSafe Function GetForegroundWindow Lib "user32" () As LongPtr
Public Declare PtrSafe Function GetWinDir Lib "kernel32" Alias "GetWindowsDirectoryA" (ByVal buffer As String, ByVal size As Integer) As Integer
Public Declare PtrSafe Function InternetSetOption Lib "wininet.dll" Alias "InternetSetOptionA" (ByVal hInternet As LongLong, ByVal dwOption As LongLong, ByRef lpBuffer As Any, ByVal dwBufferLength As LongLong) As LongLong
Public Declare PtrSafe Function ShowWindow Lib "user32" (ByVal hwnd As LongLong, ByVal nCmdShow As Long) As Long
Public Declare PtrSafe Function BringWindowToTop Lib "user32" (ByVal hwnd As LongLong) As Long
'Public Declare PtrSafe Function SetTimer Lib "user32" (ByVal hWnd As LongLong, ByVal nIDEvent As Long, ByVal uElapse As Long, ByVal lpTimerFunc As LongLong) As Long
'Public Declare PtrSafe Function KillTimer Lib "user32" (ByVal hWnd As LongLong, ByVal nIDEvent As Long) As Long
Public Declare PtrSafe Function GetTickCount Lib "kernel32" () As Long
Public Declare PtrSafe Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)
'Public Declare PtrSafe Function IntersectRect Lib "user32.dll" (lpDestRect As RECT, lpSrc1Rect As RECT, lpSrc2Rect As RECT) As Long
Public Declare PtrSafe Function lstrcpyn_long_string Lib "kernel32" Alias "lstrcpynA" (ByVal DestString As String, ByVal SourcePointer As LongLong, ByVal MaxLen As Long) As Long
Public Declare PtrSafe Function lstrlen_long Lib "kernel32" Alias "lstrlenA" (ByVal SourcePointer As LongLong) As Long
Public Declare PtrSafe Function GetCommandLine_long Lib "kernel32" Alias "GetCommandLineA" () As LongLong
Public Declare PtrSafe Function GetVersionEx Lib "kernel32" Alias "GetVersionExA" (LpVersionInformation As OSVERSIONINFO) As Long
Public Declare PtrSafe Function SHGetSpecialFolderPath Lib "shell32.dll" Alias "SHGetSpecialFolderPathA" (ByVal hwnd As LongLong, ByVal lpszPath As String, ByVal nFolder As Integer, ByVal fCreate As Boolean) As Boolean
Public Declare PtrSafe Function WritePrivateProfileString Lib "kernel32" Alias "WritePrivateProfileStringA" (ByVal sSectionName As String, ByVal sKeyName As String, ByVal sString As String, ByVal sFileName As String) As LongLong
Public Declare PtrSafe Sub DebugPrint Lib "kernel32" Alias "OutputDebugStringA" (ByVal msg As String)
Public Declare PtrSafe Function LoadLibrary Lib "kernel32" Alias "LoadLibraryW" (ByVal lpLibFileName As LongPtr) As LongPtr
Public Declare PtrSafe Function GetDC Lib "user32" (ByVal hwnd As LongPtr) As LongPtr
Public Declare PtrSafe Function ReleaseDC Lib "user32" (ByVal hwnd As LongPtr, ByVal hDC As LongPtr) As LongPtr
Public Declare PtrSafe Function GetDeviceCaps Lib "gdi32" (ByVal hDC As LongPtr, ByVal nIndex As Long) As Long
Public Declare PtrSafe Function ZECreateListener Lib "ZEDDXCalc64.xll" Alias "#3" (ByVal hwnd As LongPtr, ByVal lpCBFunc As LongPtr) As LongPtr
Public Declare PtrSafe Function ZEStrContainQuotes Lib "ZEDDXCalc64.xll" Alias "#4" (ByVal macroName As LongPtr) As Long

#ElseIf VBA7 Then
Public Declare PtrSafe Function GetSystemMetrics Lib "user32" (ByVal nIndex As Integer) As Integer
Public Declare PtrSafe Function SetForegroundWindow Lib "user32" (ByVal hwnd As LongPtr) As Long
Public Declare PtrSafe Function GetCursorPos Lib "user32" (lpPoint As POINTAPI) As LongPtr
Public Declare PtrSafe Function WindowFromPoint Lib "user32" (ByVal xPoint As Long, ByVal yPoint As Long) As LongPtr
Public Declare PtrSafe Function SetCapture Lib "user32" (ByVal hwnd As LongPtr) As LongPtr
Public Declare PtrSafe Function ReleaseCapture Lib "user32" () As LongPtr
Public Declare PtrSafe Function GetCapture Lib "user32" () As LongPtr
Public Declare PtrSafe Function FindWindow Lib "user32.dll" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As LongPtr
Public Declare PtrSafe Function ClipCursor Lib "user32.dll" (lpRect As RECT) As Long
Public Declare PtrSafe Function GetWindowRect Lib "user32.dll" (ByVal hwnd As LongPtr, lpRect As RECT) As Long
Public Declare PtrSafe Function GetDesktopWindow Lib "user32.dll" () As LongPtr
Public Declare PtrSafe Function GetClipCursor Lib "user32.dll" (lprc As RECT) As Long
Public Declare PtrSafe Function ShellExecute Lib "shell32.dll" Alias "ShellExecuteA" ( _
    ByVal hwnd As LongPtr, _
    ByVal lpOperation As String, _
    ByVal lpFile As String, _
    ByVal lpParameters As String, _
    ByVal lpDirectory As String, _
    ByVal nShowCmd As Integer) As Long
Public Declare PtrSafe Function GetForegroundWindow Lib "user32" () As LongPtr
Public Declare PtrSafe Function GetWinDir Lib "kernel32" Alias "GetWindowsDirectoryA" (ByVal buffer As String, ByVal size As Integer) As Integer
Public Declare PtrSafe Function InternetSetOption Lib "wininet.dll" Alias "InternetSetOptionA" (ByVal hInternet As Long, ByVal dwOption As Long, ByRef lpBuffer As Any, ByVal dwBufferLength As Long) As Long
Public Declare PtrSafe Function ShowWindow Lib "user32" (ByVal hwnd As Long, ByVal nCmdShow As Long) As Long
Public Declare PtrSafe Function BringWindowToTop Lib "user32" (ByVal hwnd As Long) As Long
'Public Declare PtrSafe Function SetTimer Lib "user32" (ByVal hWnd As Long, ByVal nIDEvent As Long, ByVal uElapse As Long, ByVal lpTimerFunc As Long) As Long
'Public Declare PtrSafe Function KillTimer Lib "user32" (ByVal hWnd As Long, ByVal nIDEvent As Long) As Long
Public Declare PtrSafe Function GetTickCount Lib "kernel32" () As Long
Public Declare PtrSafe Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)
'Public Declare PtrSafe Function IntersectRect Lib "user32.dll" (lpDestRect As RECT, lpSrc1Rect As RECT, lpSrc2Rect As RECT) As Long
Public Declare PtrSafe Function lstrcpyn_long_string Lib "kernel32" Alias "lstrcpynA" (ByVal DestString As String, ByVal SourcePointer As Long, ByVal MaxLen As Long) As Long
Public Declare PtrSafe Function lstrlen_long Lib "kernel32" Alias "lstrlenA" (ByVal SourcePointer As Long) As Long
Public Declare PtrSafe Function GetCommandLine_long Lib "kernel32" Alias "GetCommandLineA" () As Long
Public Declare PtrSafe Function GetVersionEx Lib "kernel32" Alias "GetVersionExA" (LpVersionInformation As OSVERSIONINFO) As Long
Public Declare PtrSafe Function SHGetSpecialFolderPath Lib "shell32.dll" Alias "SHGetSpecialFolderPathA" (ByVal hwnd As Long, ByVal lpszPath As String, ByVal nFolder As Integer, ByVal fCreate As Boolean) As Boolean
Public Declare PtrSafe Function WritePrivateProfileString Lib "kernel32" Alias "WritePrivateProfileStringA" (ByVal sSectionName As String, ByVal sKeyName As String, ByVal sString As String, ByVal sFileName As String) As Long
Public Declare PtrSafe Sub DebugPrint Lib "kernel32" Alias "OutputDebugStringA" (ByVal msg As String)
Public Declare PtrSafe Function LoadLibrary Lib "kernel32" Alias "LoadLibraryW" (ByVal lpLibFileName As LongPtr) As LongPtr
Public Declare PtrSafe Function GetDC Lib "user32" (ByVal hwnd As LongPtr) As LongPtr
Public Declare PtrSafe Function ReleaseDC Lib "user32" (ByVal hwnd As LongPtr, ByVal hDC As LongPtr) As LongPtr
Public Declare PtrSafe Function GetDeviceCaps Lib "gdi32" (ByVal hDC As LongPtr, ByVal nIndex As Long) As Long
Public Declare PtrSafe Function ZECreateListener Lib "ZEDDXCalc.xll" Alias "#3" (ByVal hwnd As LongPtr, ByVal lpCBFunc As LongPtr) As LongPtr
Public Declare PtrSafe Function ZEStrContainQuotes Lib "ZEDDXCalc.xll" Alias "#4" (ByVal macroName As LongPtr) As Long

#End If

Attribute VB_Name = "ZEDataDirectPage"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Attribute VB_Name = "ZEWSXml"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public Event OnRead(ByVal seq As Long, ByVal IsAttribute As Boolean, ByVal name As String, ByVal value As String, ByVal userData As Long)
Public Event OnWrite(ByVal seq As Long, ByRef IsAttribute As Boolean, ByRef name As String, ByRef value As String, ByVal userData As Long)

Private m_xmlDoc As MSXML2.DOMDocument60
Private m_nodeHash As Scripting.Dictionary

Private Sub NewDoc()
' Dim ver As MSXML2.IXMLDOMProcessingInstruction
    Call m_nodeHash.RemoveAll
    Set m_xmlDoc = New MSXML2.DOMDocument60
    m_xmlDoc.preserveWhiteSpace = True
'    Set ver = m_xmlDoc.createProcessingInstruction("xml", "version=" & """1.0""")
'    Call m_xmlDoc.appendChild(ver)
End Sub

Public Sub CreateRootElement(ByVal rootName As String, ByVal VersionNumber As String)
 Dim rootNode As MSXML2.IXMLDOMElement
    
    Call NewDoc
    
'    xmlDecl = m_xmlDoc.CreateXmlDeclaration("1.0", "utf-8", Null)
    Set rootNode = m_xmlDoc.createElement(rootName)
    
    Call rootNode.SetAttribute("Version", VersionNumber)
'    Call m_xmlDoc.InsertBefore(xmlDecl, m_xmlDoc.DocumentElement)
    Call m_xmlDoc.appendChild(rootNode)
End Sub

Public Function Createlement(ByVal parentNode As LongPtr, ByVal elementName As String) As LongPtr '???
 Dim node As MSXML2.IXMLDOMElement

    If InStr(elementName, "/") > 0 And parentNode = -1 Then
        Createlement = CreatelementEx(elementName)
        Exit Function
    End If

    Set node = m_xmlDoc.createElement(elementName)

    Call GetParentElement(parentNode).appendChild(node)

    Createlement = LUID(node)
    Call m_nodeHash.Add(CStr(Createlement), node)
End Function

Public Function Createlement2(ByVal parentNode As MSXML2.IXMLDOMElement, ByVal elementName As String) As MSXML2.IXMLDOMElement
 Dim node As MSXML2.IXMLDOMElement

    If InStr(elementName, "/") > 0 And (parentNode Is Nothing) Then
        Set Createlement2 = CreatelementEx2(elementName)
        Exit Function
    End If
    
    Set node = m_xmlDoc.createElement(elementName)
    
    Call IIf(parentNode Is Nothing, m_xmlDoc.DocumentElement, parentNode).appendChild(node)
            
    Set Createlement2 = node
End Function

Private Function CreatelementEx(ByVal elementName As String) As LongPtr
' Dim path() As String
 Dim node As MSXML2.IXMLDOMElement
' Dim tmp As MSXML2.IXMLDOMElement
' Dim k As Long
' Dim m As Long
'
'    If left(elementName, 1) = "/" Then
'        elementName = Mid(elementName, 2)
'    ElseIf right(elementName, 1) = "/" Then
'        elementName = left(elementName, Len(elementName) - 1)
'    End If
'    If Len(elementName) = 0 Then
'        CreatelementEx = -10
'        Exit Function
'    End If
'
'    path = Split(elementName, "/")
'
'    Set node = m_xmlDoc.DocumentElement
'
'    If node.nodeName <> path(0) Then
'        CreatelementEx = -11
'        Exit Function
'    End If
'
'    For k = 1 To UBound(path) - 1
'        Set tmp = Nothing
'
'        For m = 0 To node.ChildNodes.length - 1
'            If node.ChildNodes(m).nodeName = path(k) Then
'                Set tmp = node.ChildNodes(m)
'                Exit For
'            End If
'        Next
'
'        If tmp Is Nothing Then
'            Set node = tmp
'        End If
'    Next
'
'    Set tmp = m_xmlDoc.createElement(path(UBound(path)))
'    Call node.appendChild(tmp)
'    Set node = tmp

    Set node = CreatelementEx2(elementName)
    CreatelementEx = LUID(node)
    Call m_nodeHash.Add(CStr(CreatelementEx), node)
End Function

Private Function CreatelementEx2(ByVal elementName As String) As MSXML2.IXMLDOMElement
 Dim path() As String
 Dim node As MSXML2.IXMLDOMElement
 Dim tmp As MSXML2.IXMLDOMElement
 Dim k As Long
 Dim m As Long
 
    If left(elementName, 1) = "/" Then
        elementName = Mid(elementName, 2)
    ElseIf right(elementName, 1) = "/" Then
        elementName = left(elementName, Len(elementName) - 1)
    End If
    If Len(elementName) = 0 Then
        'CreatelementEx = -10
        Exit Function
    End If
    
    path = Split(elementName, "/")
 
    Set node = m_xmlDoc.DocumentElement
            
    If node.nodeName <> path(0) Then
        'CreatelementEx = -11
        Exit Function
    End If
    
    For k = 1 To UBound(path) - 1
        Set tmp = Nothing
        
        For m = 0 To node.ChildNodes.length - 1
            If node.ChildNodes(m).nodeName = path(k) Then
                Set tmp = node.ChildNodes(m)
                Exit For
            End If
        Next
        
        If tmp Is Nothing Then
            Set node = tmp
        End If
    Next

    Set tmp = m_xmlDoc.createElement(path(UBound(path)))
    Call node.appendChild(tmp)
    Set node = tmp

    Set CreatelementEx2 = node
End Function

Private Function GetParentElement(ByVal parentNode As LongPtr) As MSXML2.IXMLDOMElement
    If m_nodeHash.Exists(CStr(parentNode)) Then
        Set GetParentElement = m_nodeHash(CStr(parentNode))
    Else
        Set GetParentElement = m_xmlDoc.DocumentElement
    End If
End Function

Private Function AddToHash(node As MSXML2.IXMLDOMElement) As LongPtr
    AddToHash = LUID(node)
    Call m_nodeHash.Add(CStr(AddToHash), node)
End Function
 
Public Function CreateTextNode(ByVal parentNode As LongPtr, ByVal nodeName As String, ByVal nodeText As String) As LongPtr '???
 Dim text As MSXML2.IXMLDOMText
 Dim node As MSXML2.IXMLDOMElement

    Set text = m_xmlDoc.CreateTextNode(nodeText)
    Set node = m_xmlDoc.createElement(nodeName)
    Call node.appendChild(text)

    Call GetParentElement(parentNode).appendChild(node)
    CreateTextNode = AddToHash(node)
End Function

Public Function CreateTextNode2(parentNode As MSXML2.IXMLDOMElement, ByVal nodeName As String, ByVal nodeText As String) As MSXML2.IXMLDOMElement
 Dim text As MSXML2.IXMLDOMText
 Dim node As MSXML2.IXMLDOMElement

    Set text = m_xmlDoc.CreateTextNode(nodeText)
    Set node = m_xmlDoc.createElement(nodeName)
    Call node.appendChild(text)
    
    If parentNode Is Nothing Then
        Call m_xmlDoc.DocumentElement.appendChild(node)
    Else
        Call parentNode.appendChild(node)
    End If
    
    Set CreateTextNode2 = node
End Function

Public Function ToString() As String
    ToString = CDDXLib.DefaultZEWSProxy(DDX_PID).BeautifyXML(m_xmlDoc.xml)
End Function

Public Function LoadXML(ByVal xml As String) As Boolean
    Call NewDoc
    If Len(xml) = 0 Then Exit Function

    On Error GoTo OOPS
    
    LoadXML = m_xmlDoc.LoadXML(xml)
    
OOPS:
    If Err.Number <> 0 Then
        Call DispErr(Err.Description)
    End If
    Exit Function
End Function

Public Function SelectTexts(ByVal selectPath As String) As String()
 Dim nodes As MSXML2.IXMLDOMNodeList
 Dim ret() As String
 Dim k As Long
 Dim cnt As Long
 
    Set nodes = m_xmlDoc.SelectNodes(selectPath)

    If nodes Is Nothing Then
        ReDim ret(0 To 0)
        SelectTexts = ret
        Exit Function 'return new string[1]{string.Empty};
    End If
    
    cnt = nodes.length
    If cnt = 0 Then
        ReDim ret(0 To 0)
        SelectTexts = ret
        Exit Function 'return new string[1]{string.Empty};
    End If
    
    ReDim ret(0 To cnt - 1)
     
    For k = 0 To cnt - 1
        ret(k) = nodes(k).text
    Next
    
    SelectTexts = ret
End Function

Private Sub DispErr(ByVal errDesc As String)
    CDDXApp.StatusMessage = errDesc
    'Debug.Print errDesc
End Sub

Public Function Load(ByVal filePath As String) As Boolean
    On Error GoTo OOPS
    
    Call NewDoc
    Load = m_xmlDoc.Load(filePath)

OOPS:
    If Err.Number <> 0 Then
        Call DispErr(Err.Description)
    End If
    Exit Function
End Function

'Public Function Save(ByVal filePath As String) As Boolean
'    On Error GoTo OOPS
'
'                XmlWriterSettings settings = new XmlWriterSettings();
'                settings.Indent = true;
'                settings.NewLineChars = Environment.NewLine;
'                using (XmlWriter writer = XmlTextWriter.Create(filePath, settings))
'                {
'                    m_xmlDoc.Save(writer);
'                }
'                return true;
'
'OOPS:
'    If Err.Number <> 0 Then
'        Call DispErr(Err.Description)
'    End If
'    Exit Function
'End Function

Public Property Get Version() As String
    Version = m_xmlDoc.DocumentElement.getAttribute("Version")
End Property

'Public Function Encode64(ByVal strToEncode As String) As String
'            byte[] b = System.Text.ASCIIEncoding.ASCII.GetBytes(strToEncode);
'            string ret = System.Convert.ToBase64String(b);
'
'            return ret;
'End Function
'
'Public Function Decode64(ByVal strToDecode As String) As String
'            byte[] b  = System.Convert.FromBase64String(strToDecode);
'            string ret = System.Text.ASCIIEncoding.ASCII.GetString(b);
'
'            return ret;
'End Function

'Public Function RemoveNode(ByVal selectPath As String) As Boolean
'            XmlNode node = _xmlDoc.SelectSingleNode(selectPath);
'
'            if (node == null) return false;
'            if (node.ParentNode == null) return false;
'            node.ParentNode.RemoveChild(node);
'            return true;
'End Function
'
Public Function SelectAttribute(ByVal selectPath As String, ByVal attribName As String) As String
 Dim node As MSXML2.IXMLDOMNode
 Dim attr As MSXML2.IXMLDOMAttribute
 
    Set node = m_xmlDoc.SelectSingleNode(selectPath)
    If node Is Nothing Then Exit Function

    Set attr = node.Attributes.getNamedItem(attribName)
    If attr Is Nothing Then Exit Function
    
    SelectAttribute = attr.text
End Function

'Public Function AddAttribute(ByVal nodeID As LongPtr, ByVal attribName As String, ByVal attribValue As String) As Boolean '???
' Dim node As MSXML2.IXMLDOMNode
' Dim attr As MSXML2.IXMLDOMAttribute
'
'    Set node = GetParentElement(nodeID)
'    If node Is Nothing Then Exit Function
'
'    Set attr = m_xmlDoc.createAttribute(attribName)
'    node.Attributes.setNamedItem(attr).text = attribValue
'
'    AddAttribute = True
'End Function

Public Function AddAttribute2(ByVal node As MSXML2.IXMLDOMElement, ByVal attribName As String, ByVal attribValue As String) As Boolean '???
 Dim attr As MSXML2.IXMLDOMAttribute
 
    Set attr = m_xmlDoc.createAttribute(attribName)
    node.Attributes.setNamedItem(attr).text = attribValue

    AddAttribute2 = True
End Function

'Public Function SelectAttributes(ByVal selectPath As String, ByVal attribName As String) As String()
'            XmlNodeList nodes = _xmlDoc.SelectNodes(selectPath);
'
'            if (nodes == null || nodes.Count == 0)
'            {
'                return new string[1] { string.Empty };
'            }
'
'            List<string> values = new List<string>();
'            foreach (XmlElement node in nodes)
'            {
'                values.Add(node.HasAttribute(attribName) ? node.GetAttribute(attribName) : string.Empty);
'            }
'            return values.ToArray();
'End Function

Private Function LUID(obj As Object) As LongPtr
    LUID = ObjPtr(obj)
End Function

Public Sub ReadXML(ByVal path As String, ByVal userData As Long)
 Dim nodes As MSXML2.IXMLDOMNodeList
 Dim seq As Long
 Dim k As Long
 Dim n As Long
 
    seq = 1
    Set nodes = m_xmlDoc.SelectNodes(path)
    
    If nodes Is Nothing Then Exit Sub
    If nodes.length = 0 Then Exit Sub
    
    For k = 0 To nodes.length - 1
        For n = 0 To nodes(k).Attributes.length - 1
            With nodes(k).Attributes(n)
                RaiseEvent OnRead(seq, True, .nodeName, .text, userData)
            End With
        Next

        For n = 0 To nodes(k).ChildNodes.length - 1
            With nodes(k).ChildNodes(n)
                RaiseEvent OnRead(seq, False, .nodeName, .text, userData)
            End With
        Next
        
        seq = seq + 1
    Next
End Sub

Public Sub WriteXML(ByVal path As String, ByVal userData As Long)
 Dim name As String
 Dim value As String
 Dim isattrib As Boolean
 Dim node As MSXML2.IXMLDOMNode
 Dim tmp As MSXML2.IXMLDOMNode
 Dim attr As MSXML2.IXMLDOMAttribute
 Dim itemno As Long
 
    Set node = CreateNode(path)
    itemno = 0
        
    Do
        name = vbNullString
        value = vbNullString
        isattrib = False
        
        itemno = itemno + 1
        RaiseEvent OnWrite(itemno, isattrib, name, value, userData)
        
        If name = vbNullString Then Exit Do

        If isattrib Then
            Set attr = m_xmlDoc.createAttribute(name)
            node.Attributes.setNamedItem(attr).text = value
        Else
            Set tmp = m_xmlDoc.createElement(name)
            tmp.text = value
            Call node.appendChild(tmp)
        End If
    Loop
End Sub

Private Function CreateNode(ByVal pathName As String) As MSXML2.IXMLDOMNode
 Dim path() As String
 Dim node As MSXML2.IXMLDOMNode
 Dim tmp As MSXML2.IXMLDOMNode
 Dim k As Long
 Dim n As Long

    If left(pathName, 1) = "/" Then
        pathName = Mid(pathName, 2)
    ElseIf right(pathName, 1) = "/" Then
        pathName = left(pathName, Len(pathName) - 1)
    End If
    If Len(pathName) = 0 Then Exit Function
    
    path = Split(pathName, "/")

    Set node = m_xmlDoc.DocumentElement
    If node.nodeName <> path(0) Then Exit Function

    For k = LBound(path) + 1 To UBound(path)
        Set tmp = Nothing

        If k <> UBound(path) Then
            For n = 0 To node.ChildNodes.length - 1
                If node.ChildNodes(n).nodeName = path(k) Then
                    Set tmp = node.ChildNodes(n)
                    Exit For
                End If
            Next
        End If

        If tmp Is Nothing Then
            Set tmp = m_xmlDoc.createElement(path(k))
            Call node.appendChild(tmp)
            Set node = tmp
        End If
    Next

    Set CreateNode = node
End Function

Public Function SelectNodes(ByVal selectPath As String) As MSXML2.IXMLDOMNodeList
 Dim nodes As MSXML2.IXMLDOMNodeList
 
    Set nodes = m_xmlDoc.SelectNodes(selectPath)

    If nodes Is Nothing Then Exit Function
    If nodes.length = 0 Then Exit Function
    Set SelectNodes = nodes
End Function

Private Sub Class_Initialize()
    Set m_nodeHash = New Scripting.Dictionary
    m_nodeHash.CompareMode = vbBinaryCompare
End Sub

Private Sub Class_Terminate()
    Set m_nodeHash = Nothing
    Set m_xmlDoc = Nothing
End Sub
Attribute VB_Name = "ZEWorkBook"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

' InQuest injected base64 decoded content
' "w+zg
' &F(!
' v+ZnW
' x%x6
' ^"zn
' +x*%
' h	mz
' "w+zg
' "w+zg
' jP't*&
' -Z+a:
' jT^~
' ^jqk
' z{bjT
' :$zqh
' u(^z
' -zeZ
' ~Z0:
'  r.+-9
' Szjej
' u(^z
' *^r&
' *^r&

INQUEST-PP=macro
