Attribute VB_Name = "DieseArbeitsmappe"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "ILIASXMLExport"
Dim row As Integer
Dim coleTitle As String




'http://www.freevbcode.com/ShowCode.Asp?ID=1694
Public Function ExportToILIASXML(FullPath As String, encoding As String) As Boolean

'PURPOSE: EXPORTS AN EXCEL SPREADSHEET TO XML FOR IMPORT INTO ILIAS
'
'PARAMETERS: FullPath: Full Path of File to Export Sheet to
'            Encoding: Encoding of the XML file. This must be "UTF-16LE" or "ISO-8859-1"
'
'RETURNS: True if Successful, false otherwise
'
'EXAMPLE: ExportToXML "C:\mysheet.xml", "Employee"
'
'COPYRIGHT: Fachhochschule Zentralschweiz, Lucerne, Switzerland
'           All rights reserved.
'
'Version:   2.6.5 2018 Stanislav Wischniak (wischniak@qualitus.de)
'                      - Small changes
'                      - Abandoned support for MD5 passwords
'                      - Change to password(1,2,3) in TextFormeln
'[..]
'Version:   6.8   2014-2016  Stanislav Wischniak (wischniak@qualitus.de)
'Version:   6.7   2012-10-16 Evelyn Hamm - Qualitus GmbH, Added support for OrgUnits
'
'
'AUTHOR:    Werner Randelshofer, Fachstelle Neue Lernmedien
'VERSION:   6.6   2008-07-18 Added support for action "AssignWithParents"
'           6.5.5 2008-07-11 Put role names into CDATA sections.
'           6.5.4 2008-05-16 An invalid choice of the export file extension will be
'                          corrected to '.xml'
'           6.5.3 2008-04-24 Actions and role types were set to upper case instead of
'                          first letter upper case and the rest lower case.
'           6.5.1 2008-01-16 Renamed trim function to trimWhitespace function.
'           6.5 2008-01-16 Strip non-breaking space (ASCII 160) out of strings.
'           6.4 2007-12-06 Added support for special column Password[MD5]. Columns with
'                          this title contain MD5 encoded passwords.
'           6.2 2007-04-17 Added Encoding parameter for UTF-16LE or ISO-8859-1 encoding.
'           6.1 2007-04-03 Encode XML using UTF-16LE instead of ISO-8859-1. ILIAS
'                          can work with this encoding now.
'           6.0 2007-03-30 Id attribute of XML elements must comply to XML standard.
'           5.0 2007-03-30 Added support for XML elements that have additional attibutes.
'           4.2 2006-10-06 Added functions shortFirstname() and shortLastname().
'           3.8 2006-08-29 Function getWord() enhanced to handel individual cases of
'                          composite user names, eg. lastname 'von Arx' -> 'vonarx'
'           3.7 2006-02-23 Allow hyphen in login. Randomize random number generator
'                          before using it.
'           3.6 2006-02-10 Function getWord() fixed.
'           3.5 2006-01-26 Function password(length) added.
'           3.4 2006-01-26 Automatically correct case of actions and role type.
'           3.2 2005-10-14 Minor fixes.
'           3.0 2005-06-27 Encode XML using ISO-8895-1 instead of UTF-16LE,
'                          because PHP5 does not support UTF-16LE. Unfortunately
'                          there is no way to create UTF-8 encoded files using
'                          VBA. Therefore we lose on internationalization
'                          compatibility.
'                          Write CDATA begin and end tags into same line as content,
'                          because PHP5 does treat all characters between CDATA
'                          tags as part of the content.
'           2.3 2005-06-07 Don't write null bytes and 0x0b bytes into XML file
'           2.2 2005-04-04 Added support for columns 'Global Role' and 'Local Role'
'           2.1 2005-02-22 Support for ignoring rows and columns added.
'           2.0 2005-02-18 Enhancements for ILIAS 3.4 added.
'           1.0 2004       Created.
'******************************************************

'On Error GoTo ErrorHandler


Dim colIndex As Integer
Dim rwIndex As Integer
Dim asCols() As String
Dim oWorkSheet As Worksheet
Dim lCols As Long, lRows As Long
Dim iFileNum As Integer
Dim currentOrgUnit As String
Dim isCurrentOrgUnit As Boolean
Dim currentRoleId As String
Dim currentAction As String
Dim ErrorMessage As String
Dim required As String
Dim orgImportId As Boolean

Dim nodeTitles As Variant
Dim requiredFields As Variant

Set oWorkSheet = ThisWorkbook.Worksheets(1)
lCols = oWorkSheet.Columns.count
lRows = oWorkSheet.Rows.count


ReDim asCols(lCols) As String

For i = 0 To lCols - 1
    'Assumes no blank column names
    If Trim(Cells(1, i + 1).Value) = "" Then Exit For
    asCols(i) = Cells(1, i + 1).Value
Next i

' Zuweisungsarray ExcelSpalten Titel zu XMLNode Titeln
globalFunctions.FillNodeTitles nodeTitles, "User-Declaration"

If i = 0 Then GoTo ErrorHandler
lCols = i

'*********************************************************************************************
'*Trocken|fffd|bung
'*********************************************************************************************
For i = 2 To lRows
    If Trim(Cells(i, 1).Value) = "" Then Exit For
    
    Dim action As String
    Dim XMLNodeTitle As String
    Dim cellValue As String
    row = i
    
    action = "Insert"
    For j = 1 To lCols
        coleTitle = Trim(asCols(j - 1))
        globalFunctions.getRealName nodeTitles, requiredFields, coleTitle
        XMLNodeTitle = requiredFields(0, 0)
        required = requiredFields(0, 1)
        If WorksheetFunction.IsNA(Cells(i, j).Value) Or WorksheetFunction.IsErr(Cells(i, j).Value) Then
            'ErrorMessage = "Der Wert wird nicht unterst|fffd|tzt."
            ErrorMessage = "The value is not supported"
            ActiveWorksheet.Cells(i, j).Select
            GoTo Fehler
        End If

        cellValue = Trim(Cells(i, j).Value)

        If LCase(XMLNodeTitle) = "action" And cellValue <> "" Then
            action = UCase(Left(cellValue, 1)) & LCase(Right(cellValue, Len(cellValue) - 1))
        End If
    Next j
    'MsgBox action
    If action = "Insert" And Left(action, 1) <> "(" Then
        For j = 1 To lCols
              coleTitle = trimWhitespace(asCols(j - 1))
              globalFunctions.getRealName nodeTitles, requiredFields, coleTitle
              XMLNodeTitle = requiredFields(0, 0)
              required = requiredFields(0, 1)
              
                If WorksheetFunction.IsNA(Cells(i, j).Value) Or WorksheetFunction.IsErr(Cells(i, j).Value) Then
                    ErrorMessage = "The value is not supported"
                    ActiveWorksheet.Cells(i, j).Select
                    GoTo Fehler
            End If
                cellValue = trimWhitespace(Cells(i, j).Value)
            If required = "yes" And cellValue = "" Then
                'MsgBox "Action: " & action
                MsgBox "Column '" & coleTitle & "' is set to 'mandatory' but does not contain a value in the row " & row & ". " & "Export cancelled.", vbCritical, "Mandatory value missing"
                ActiveSheet.Cells(row, j).Select
                Exit Function
            End If
        Next j
    End If
Next i
'*********************************************************************************************
'*ENDE Trocken|fffd|bung
'*********************************************************************************************

'Dictionary for role ids, key=role name, value=XML Id
Dim roleIdDictionary
Set roleIdDictionary = CreateObject("Scripting.Dictionary")
Dim roleId


'forces .xml file extension in FullPath
FullPath = ensureXmlExtension(FullPath)

Set fs = CreateObject("Scripting.FileSystemObject")
If encoding = "UTF-16LE" Then
    Set a = fs.CreateTextFile(FullPath, True, True)
Else
    Set a = fs.CreateTextFile(FullPath, True, False)
End If


a.WriteLine ("<?xml version=""1.0"" encoding=""" + encoding + """?>")
a.WriteLine ("<Users>")
For i = 2 To lRows
    If Trim(Cells(i, 1).Value) = "" Then Exit For
    
    'Begin <User> element
    '--------------------
    Dim userid As String
    Dim nextCellValue As String
    Dim language As String
    row = i
    action = "Insert"
    language = "de"
    For j = 1 To lCols
        coleTitle = Trim(asCols(j - 1))
        globalFunctions.getRealName nodeTitles, requiredFields, coleTitle
        XMLNodeTitle = requiredFields(0, 0)
        required = requiredFields(0, 1)
        cellValue = Trim(Cells(i, j).Value)
        
        If LCase(XMLNodeTitle) = "login" Then
           userid = cellValue
        ElseIf LCase(XMLNodeTitle) = "action" Then
           If (cellValue <> "") Then
                action = UCase(Left(cellValue, 1)) & LCase(Right(cellValue, Len(cellValue) - 1))
           End If
        ElseIf LCase(XMLNodeTitle) = "language" Then
            If (cellValue <> "") Then
                    language = LCase(cellValue)
            End If
        End If
    Next j
    
    Dim foundTimeLimitFrom As Boolean
    Dim foundTimeLimitUntil As Boolean
    Dim foundTimeLimitUnlimited As Boolean
    
    foundTimeLimitFrom = False
    foundTimeLimitUntil = False
    foundTimeLimitUnlimited = False
    
    If action <> "Ignore" And Left(action, 1) <> "(" Then
       a.WriteLine ("<User Id=""" & userid & """ Language=""" & language & """ Action=""" & action & """>")
     
       'Create sub-elements of the <User> element
       '-----------------------------------------
       
       For j = 1 To lCols
            coleTitle = trimWhitespace(asCols(j - 1))
            globalFunctions.getRealName nodeTitles, requiredFields, coleTitle
            XMLNodeTitle = requiredFields(0, 0)
            required = requiredFields(0, 1)
            cellValue = trimWhitespace(Cells(i, j).Value)
            cellValue = Replace(cellValue, Chr(0), "")
            cellValue = Replace(cellValue, Chr(11), "")
            
            ' Note if some important cells have been found, for later. Once it was found, remember it.
            foundTimeLimitUnlimited = foundTimeLimitUnlimited Or (LCase(XMLNodeTitle) = "timelimitunlimited" And cellValue <> "")
            foundTimeLimitFrom = foundTimeLimitFrom Or (LCase(XMLNodeTitle) = "timelimitfrom" And cellValue <> "")
            foundTimeLimitUntil = foundTimeLimitUntil Or (LCase(XMLNodeTitle) = "timelimituntil" And cellValue <> "")
                      
            If required = "yes" And cellValue = "" And action <> "Update" Then
                'MsgBox "Action: " & action
                MsgBox "Column '" & coleTitle & "' is set to 'mandatory' but does not contain a value in the row " & row & ". ", vbCritical, "Mandatory value missing"
                ActiveSheet.Cells(row, j).Select
                Exit Function
            End If
        
           
            If XMLNodeTitle <> "" _
            And XMLNodeTitle <> "Ignore" _
            And Left(XMLNodeTitle, 1) <> "(" _
            And cellValue <> "" Then
         
                If XMLNodeTitle = "Role" _
                Or XMLNodeTitle = "Global Role" _
                Or XMLNodeTitle = "Local Role" Then
                    Dim roleType As String
                    Dim roleAction As String
                    Dim roleName As String
                    If (GetWord(cellValue, 1, ":") = "") Then
                        If LCase(XMLNodeTitle) = "local role" Then
                          roleType = "Local"
                        Else
                          roleType = "Global"
                        End If
                        roleAction = "Assign"
                        roleName = cellValue
                    Else
                        roleType = GetWord(cellValue, 0, ":")
                        roleName = GetWord(cellValue, 1, ":")
                        If (GetWord(roleType, 1, ",") = "") Then
                            roleType = UCase(Left(roleType, 1)) & LCase(Right(roleType, Len(roleType) - 1))
    
                            ' Swap action and role type if they are specified
                            ' in the wrong sequence
                            If (roleType = "Assign" Or roleType = "Detach" Or roleType = "Assignwithparents") Then
                                  roleAction = roleType
                                  If LCase(XMLNodeTitle) = "local role" Then
                                    roleType = "Local"
                                  Else
                                    roleType = "Global"
                                  End If
                            Else
                                roleAction = "Assign"
                            End If
                        Else
                            roleAction = GetWord(roleType, 0, ",")
                            roleAction = UCase(Left(roleAction, 1)) & LCase(Right(roleAction, Len(roleAction) - 1))
                            
                            roleType = GetWord(roleType, 1, ",")
                            roleType = UCase(Left(roleType, 1)) & LCase(Right(roleType, Len(roleType) - 1))
                            
                            ' Swap action and role type if they are specified
                            ' in the wrong sequence
                            If (roleAction <> "Assign" And roleAction <> "Detach" And roleAction <> "Assignwithparents") Then
                                Dim help As String
                                help = roleAction
                                roleAction = roleType
                                roleType = help
                            End If
                        End If
                        If (roleAction = "Assignwithparents") Then
                          roleAction = "AssignWithParents"
                        End If
                    End If
                   
                    If (Not roleIdDictionary.exists(roleName)) Then
                      roleIdDictionary.Add roleName, "_" & (roleIdDictionary.count + 1)
                    End If
                    roleId = roleIdDictionary.Item(roleName)
                    
                    a.Write ("  <Role Id=""" & roleId & """ Type=""" & roleType & """ Action=""" & roleAction & """><![CDATA[")
                    a.Write (roleName)
                    a.WriteLine ("]]></Role>")
                ElseIf LCase(XMLNodeTitle) = "password" Then
                    a.Write ("  <Password Type=""PLAIN"">")
                    a.Write (cellValue)
                    a.WriteLine ("</Password>")
                ElseIf LCase(XMLNodeTitle) = "action" Then
                    ' Do nothing
                    ' (We already wrote the value of this cell into the
                    ' 'Action' Attribute of the <User> element.
                ElseIf LCase(XMLNodeTitle) = "language" Then
                    ' Do nothing
                    ' (We already wrote the value of this cell into the
                    ' 'Action' Attribute of the <User> element.
                ElseIf LCase(XMLNodeTitle) = "skinid" Then
                    If LCase(cellValue) = "delos" Then
                        a.WriteLine ("  <Look Skin=""default"" Style=""delos""></Look>")
                    Else
                        a.WriteLine ("  <Look Skin=""" & cellValue & """ Style=""" & cellValue & """></Look>")
                    End If
                ElseIf XMLNodeTitle = "AuthMode" Then
                        a.WriteLine ("  <" & XMLNodeTitle & " type=""" & LCase(cellValue) & """><![CDATA[" & LCase(cellValue) & "]]></AuthMode>")
                        'Debug.Print "  <" & XMLNodeTitle & " type=""" & LCase(cellValue) & """><![CDATA[" & LCase(cellValue) & "]]></AuthMode>"
                ElseIf XMLNodeTitle = "OrgUnitId" Or XMLNodeTitle = "OrgUnitImportId" Then
                    If (InStr(cellValue, "Detach") Or InStr(cellValue, "DETACH")) > 0 Then
                        currentOrgUnit = Mid(cellValue, 8)
                        currentAction = "Detach"
                        isCurrentOrgUnit = False
                        If XMLNodeTitle = "OrgUnitId" Then
                            a.WriteLine ("  <OrgUnit Id=""" & currentOrgUnit & """ OrgRoleId="""" Action=""" & currentAction & """></OrgUnit>")
                        Else
                            a.Write ("  <OrgUnit ImportId=""")
                            a.Write (currentOrgUnit)
                            a.WriteLine (""" OrgRoleId="""" Action=""" & currentAction & """></OrgUnit>")
                        End If
                ElseIf cellValue <> "" Then
                    currentAction = "Assign"
                    If InStr(cellValue, "Assign") > 0 Then
                        currentOrgUnit = Mid(cellValue, 8)
                    Else
                        currentOrgUnit = cellValue
                    End If
                    
                    isCurrentOrgUnit = True
                    nextCellValue = trimWhitespace(Cells(i, j + 1).Value)
                    nextCellValue = Replace(nextCellValue, Chr(0), "")
                    nextCellValue = Replace(nextCellValue, Chr(11), "")
                        
                    If nextCellValue = "" Then
                        ErrorMessage = "By inserting an OrgUnit you have to" & Chr(9) & Chr(9) & Chr(9) & "declare a Role-ID, too!"
                        ActiveSheet.Cells(i, j).Select
                        GoTo Fehler
                    End If
                End If
                If XMLNodeTitle = "OrgUnitId" Then
                    orgImportId = False
                Else
                    orgImportId = True
                End If
            ElseIf XMLNodeTitle = "OrgRoleId" And isCurrentOrgUnit Then
                currentRoleId = cellValue
                'MsgBox currentOrgUnit & ", " & currentRoleId
                If orgImportId Then
                    a.WriteLine ("  <OrgUnit ImportId=""" & currentOrgUnit & """ OrgRoleId=""" & currentRoleId & """ Action=""" & currentAction & """></OrgUnit>")
                Else
                    a.WriteLine ("  <OrgUnit Id=""" & currentOrgUnit & """ OrgRoleId=""" & currentRoleId & """ Action=""" & currentAction & """></OrgUnit>")
                End If
                isCurrentOrgUnit = False
            ElseIf XMLNodeTitle = "TimeLimitUnlimited" Then
                'Debug.Print "cell: " & cellValue
                If cellValue = "yes" Then
                    a.WriteLine ("  <TimeLimitUnlimited><![CDATA[" & "1" & "]]></TimeLimitUnlimited>")
                Else
                    a.WriteLine ("  <TimeLimitUnlimited><![CDATA[" & "0" & "]]></TimeLimitUnlimited>")
                End If
            ElseIf XMLNodeTitle = "TimeLimitFrom" Then
                a.WriteLine ("  <TimeLimitFrom><![CDATA[" & cellValue + " 23:59:59" & "]]></TimeLimitFrom>")
            ElseIf XMLNodeTitle = "TimeLimitUntil" Then
                a.WriteLine ("  <TimeLimitUntil><![CDATA[" & cellValue + " 23:59:59" & "]]></TimeLimitUntil>")
            ElseIf XMLNodeTitle <> "OrgRoleId" Then
                 
                a.Write ("  <" & XMLNodeTitle & "><![CDATA[")
                If LCase(XMLNodeTitle) = "active" Then
                    If LCase(cellValue) = "yes" Then
                        cellValue = "true"
                    Else
                        cellValue = "false"
                    End If
                End If
                If (cellValue <> "_") Then
                    a.Write (cellValue)
                End If
                a.WriteLine ("]]></" & GetWord(XMLNodeTitle, 0, " ") & ">")
                End If
            End If
        Next j
         ' If the tags TimeLimitUnlimited, TimeLimitFrom, TimeLimitUnitil were not found, add them.
        'If Not foundTimeLimitUnlimited Then
        '    a.WriteLine ("  <TimeLimitUnlimited><![CDATA[0]]></TimeLimitUnlimited>")
        'End If
        'If Not foundTimeLimitUntil Then
        '    Dim dateUntil As Date
        '    dateUntil = Now()
        '    dateUntil = DateAdd("yyyy", 1, dateUntil)
        '    a.WriteLine ("  <TimeLimitUntil><![CDATA[" & Format(dateUntil, "dd.mm.yyyy 23:59:59") & "]]></TimeLimitUntil>")
        'End If
        'If Not foundTimeLimitFrom Then
        '    a.WriteLine ("  <TimeLimitFrom><![CDATA[" & Format(Now(), "dd.mm.yyyy 00:00:00") & "]]></TimeLimitFrom>")
        'End If
        
        
        'Finish </User> element
        '----------------------
        a.WriteLine (" </User>")
    End If
Next i

a.WriteLine ("</Users>")
ExportToILIASXML = True
ErrorHandler:
a.Close
Exit Function
Fehler: MsgBox "Error in Row: " & Chr(9) & i & Chr(13) & _
            "Description: " & Chr(9) & ErrorMessage, vbCritical
End Function

Attribute VB_Name = "ILIAS_ORG_XMLExport"
'@author: Evelyn Hamm
'@date: September 2012

Dim row As Integer
Dim columnTitle As String


Public Function ORG_ExportToILIASXML(path As String, encoding As String) As Boolean

Dim asCols() As String
Dim oWorkSheet As Worksheet
Dim lCols As Long, lRows As Long
Dim pruefdurchlauf  As Boolean

Dim nodeTitles As Variant
Dim requiredFields As Variant

Set oWorkSheet = ThisWorkbook.Worksheets(2)
lCols = oWorkSheet.Columns.count
lRows = oWorkSheet.Rows.count

ReDim asCols(lCols) As String

'forces .xml file extension in path
path = ensureXmlExtension(path)
pruefdurchlauf = True

Set fs = CreateObject("Scripting.FileSystemObject")
If encoding = "UTF-16LE" Then
    Set a = fs.CreateTextFile(path, True, True)
Else
    Set a = fs.CreateTextFile(path, True, False)
End If

'*************************************
' Saving the Columnnames in asCols()
' If there is an empty cell the loop will exit
For i = 0 To lCols - 1
    'Assumes no blank column names
    If Trim(Cells(1, i + 1).Value) = "" Then Exit For
    asCols(i) = Cells(1, i + 1).Value
Next i

If i = 0 Then GoTo ErrorHandler
lCols = i

globalFunctions.FillNodeTitles nodeTitles, "OrgUnit-Declaration"

'**********************
'XML Header Informations
a.WriteLine ("<?xml version=""1.0"" encoding=""" + encoding + """?>")
a.WriteLine ("<OrgUnits>")

For i = 2 To lRows
    If Trim(Cells(i, 1).Value) = "" Then Exit For
    
    '***************************
    'Begin <OrgUnit> element -> Node Informations
    Dim orgUnit_Id As String
    Dim orgUnit_ParendId As String
    Dim XMLNodeTitle As String
    Dim cellValue As String
    'Dim udf_counter As Integer
    Dim current_udf As String
    Dim x As Byte
    row = i
    For j = 1 To lCols
        columnTitle = Trim(asCols(j - 1))
        globalFunctions.getRealName nodeTitles, requiredFields, columnTitle
        XMLNodeTitle = requiredFields(0, 0)
        required = requiredFields(0, 1)
        cellValue = Trim(Cells(i, j).Value)
        If LCase(XMLNodeTitle) = "ou_id" Then
           orgUnit_Id = cellValue
        ElseIf LCase(XMLNodeTitle) = "ou_parent_id" Then
           If (cellValue <> "") Then
                orgUnit_ParendId = cellValue
           End If
        End If
        If orgUnit_Id = "" Then
            GoTo ErrorHandler
        End If
    Next j
   
    If Left(action, 1) <> "(" Then
    a.WriteLine (" <OrgUnit ou_id=""" & orgUnit_Id & """ ou_parent_id=""" & orgUnit_ParendId & """>")
    'udf_counter = 1
      '*********************************************
      'Create child-elements of the <OrgUnit> element
      For j = 1 To lCols
          columnTitle = trimWhitespace(asCols(j - 1))
          globalFunctions.getRealName nodeTitles, requiredFields, columnTitle
          XMLNodeTitle = requiredFields(0, 0)
          required = requiredFields(0, 1)
          cellValue = trimWhitespace(Cells(i, j).Value)
          cellValue = Replace(cellValue, Chr(0), "")
          cellValue = Replace(cellValue, Chr(11), "")
          If required = "yes" And cellValue = "" Then
            MsgBox "Column '" & coleTitle & "' is set to 'mandatory'but does not contain a value in the row " & row & ". ", vbCritical, "Mandatory value missing"
            ActiveSheet.Cells(row, j).Select
            
            Exit Function
        End If
          
          
          If XMLNodeTitle <> "" _
          And Left(XMLNodeTitle, 1) <> "(" _
          And cellValue <> "" Then
              If LCase(XMLNodeTitle) = "ou_title" Then
                a.Write ("  <ou_title><![CDATA[")
                a.Write (cellValue)
                a.WriteLine ("]]></ou_title>")
              ElseIf LCase(XMLNodeTitle) = "ou_description" Then
                a.Write ("  <ou_description><![CDATA[")
                a.Write (cellValue)
                a.WriteLine ("]]></ou_description>")
              ElseIf LCase(XMLNodeTitle) = "ou_type" Then
                a.Write ("  <ou_type><![CDATA[")
                For x = 1 To 10
                   If InStr(1, cellValue, " ") Then
                      'cellValue = Replace(Trim(cellValue), " ", "")
                        cellValue = Trim(cellValue)

                    End If
                Next
                a.Write (cellValue)
                a.WriteLine ("]]></ou_type>")
                'udf_counter = udf_counter + 1
              
              End If
          End If
        Next j
        '***************************
        'Finish </OrgUnit> element
        a.WriteLine (" </OrgUnit>")
    End If
Next i
'**************************
'Finish </OrgUnits> element
a.WriteLine ("</OrgUnits>")
ORG_ExportToILIASXML = True
ErrorHandler:
a.Close
Exit Function
Fehler: MsgBox "Fehler in Zeile: " & Chr(9) & i & Chr(13) & _
            "Description: " & Chr(9) & ErrorMessage, vbCritical, "Error"
End Function






Attribute VB_Name = "MD5Formel"
Function MD5(Text As String) As String
    Dim op As MD5_Klasse
    Set op = New MD5_Klasse
    MD5 = StrConv(op.DigestStrToHexStr(Text), vbLowerCase)
    
End Function
Attribute VB_Name = "MD5_Klasse"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'http://spotlight.de/zforen/amsa/m/amsa-1073555039-5871.html
Option Explicit

'/******************************************************************************
' *  Copyright (C) 2000 by Robert Hubley.                                      *
' *  All rights reserved.                                                      *
' *                                                                            *
' *  This software is provided ``AS IS'' and any express or implied            *
' *  warranties, including, but not limited to, the implied warranties of      *
' *  merchantability and fitness for a particular purpose, are disclaimed.     *
' *  In no event shall the authors be liable for any direct, indirect,         *
' *  incidental, special, exemplary, or consequential damages (including, but  *
' *  not limited to, procurement of substitute goods or services; loss of use, *
' *  data, or profits; or business interruption) however caused and on any     *
' *  theory of liability, whether in contract, strict liability, or tort       *
' *  (including negligence or otherwise) arising in any way out of the use of  *
' *  this software, even if advised of the possibility of such damage.         *
' *                                                                            *
' ******************************************************************************
'
'  CLASS: MD5
'
'  DESCRIPTION:
'     This is a class which encapsulates a set of MD5 Message Digest functions.
'     MD5 algorithm produces a 128 bit digital fingerprint (signature) from an
'     dataset of arbitrary length.  For details see RFC 1321 (summarized below).
'     This implementation is derived from the RSA Data Security, Inc. MD5 Message-Digest
'     algorithm reference implementation (originally written in C)
'
'  AUTHOR:
'     Robert M. Hubley 12/1999
'
'
'  NOTES:
'      Network Working Group                                    R. Rivest
'      Request for Comments: 1321     MIT Laboratory for Computer Science
'                                             and RSA Data Security, Inc.
'                                                              April 1992
'
'
'                           The MD5 Message-Digest Algorithm
'
'      Summary
'
'         This document describes the MD5 message-digest algorithm. The
'         algorithm takes as input a message of arbitrary length and produces
'         as output a 128-bit "fingerprint" or "message digest" of the input.
'         It is conjectured that it is computationally infeasible to produce
'         two messages having the same message digest, or to produce any
'         message having a given prespecified target message digest. The MD5
'         algorithm is intended for digital signature applications, where a
'         large file must be "compressed" in a secure manner before being
'         encrypted with a private (secret) key under a public-key cryptosystem
'         such as RSA.
'
'         The MD5 algorithm is designed to be quite fast on 32-bit machines. In
'         addition, the MD5 algorithm does not require any large substitution
'         tables; the algorithm can be coded quite compactly.
'
'         The MD5 algorithm is an extension of the MD4 message-digest algorithm
'         1,2]. MD5 is slightly slower than MD4, but is more "conservative" in
'         design. MD5 was designed because it was felt that MD4 was perhaps
'         being adopted for use more quickly than justified by the existing
'         critical review; because MD4 was designed to be exceptionally fast,
'         it is "at the edge" in terms of risking successful cryptanalytic
'         attack. MD5 backs off a bit, giving up a little in speed for a much
'         greater likelihood of ultimate security. It incorporates some
'         suggestions made by various reviewers, and contains additional
'         optimizations. The MD5 algorithm is being placed in the public domain
'         for review and possible adoption as a standard.
'
'         RFC Author:
'         Ronald L.Rivest
'         Massachusetts Institute of Technology
'         Laboratory for Computer Science
'         NE43 -324545    Technology Square
'         Cambridge, MA  02139-1986
'         Phone: (617) 253-5880
'         EMail:    Rivest@ theory.lcs.mit.edu
'
'
'
'  CHANGE HISTORY:
'
'     0.1.0  RMH    1999/12/29      Original version
'
'

'=
'= Class Constants
'=
Private Const OFFSET_4 = 4294967296#
Private Const MAXINT_4 = 2147483647

Private Const S11 = 7
Private Const S12 = 12
Private Const S13 = 17
Private Const S14 = 22
Private Const S21 = 5
Private Const S22 = 9
Private Const S23 = 14
Private Const S24 = 20
Private Const S31 = 4
Private Const S32 = 11
Private Const S33 = 16
Private Const S34 = 23
Private Const S41 = 6
Private Const S42 = 10
Private Const S43 = 15
Private Const S44 = 21

'=
'= Class Variables
'=
Private State(4) As Long
Private ByteCounter As Long
Private ByteBuffer(63) As Byte

'=
'= Class Properties
'=
Property Get RegisterA() As String
    RegisterA = State(1)
End Property

Property Get RegisterB() As String
    RegisterB = State(2)
End Property

Property Get RegisterC() As String
    RegisterC = State(3)
End Property

Property Get RegisterD() As String
    RegisterD = State(4)
End Property

'=
'= Class Functions
'=

'
' Function to quickly digest a file into a hex string
'
Public Function DigestFileToHexStr(filename As String) As String
    Open filename For Binary Access Read As #1
    MD5Init
    Do While Not EOF(1)
        Get #1, , ByteBuffer
        If Loc(1) < LOF(1) Then
            ByteCounter = ByteCounter + 64
            MD5Transform ByteBuffer
        End If
    Loop
    ByteCounter = ByteCounter + (LOF(1) Mod 64)
    Close #1
    MD5Final
    DigestFileToHexStr = GetValues
End Function

'
' Function to digest a text string and output the result as a string
' of hexadecimal characters.
'
Public Function DigestStrToHexStr(SourceString As String) As String
    MD5Init
    MD5Update Len(SourceString), StringToArray(SourceString)
    MD5Final
    DigestStrToHexStr = GetValues
End Function

'
' A utility function which converts a string into an array of
' bytes.
'
Private Function StringToArray(InString As String) As Byte()
    Dim i As Integer
    Dim bytBuffer() As Byte
    ReDim bytBuffer(Len(InString))
    For i = 0 To Len(InString) - 1
        bytBuffer(i) = Asc(Mid(InString, i + 1, 1))
    Next i
    StringToArray = bytBuffer
End Function

'
' Concatenate the four state vaules into one string
'
Public Function GetValues() As String
    GetValues = LongToString(State(1)) & LongToString(State(2)) & LongToString(State(3)) & LongToString(State(4))
End Function

'
' Convert a Long to a Hex string
'
Private Function LongToString(Num As Long) As String
        Dim a As Byte
        Dim b As Byte
        Dim c As Byte
        Dim d As Byte
        
        a = Num And &HFF&
        If a < 16 Then
            LongToString = "0" & Hex(a)
        Else
            LongToString = Hex(a)
        End If
               
        b = (Num And &HFF00&) \ 256
        If b < 16 Then
            LongToString = LongToString & "0" & Hex(b)
        Else
            LongToString = LongToString & Hex(b)
        End If
        
        c = (Num And &HFF0000) \ 65536
        If c < 16 Then
            LongToString = LongToString & "0" & Hex(c)
        Else
            LongToString = LongToString & Hex(c)
        End If
       
        If Num < 0 Then
            d = ((Num And &H7F000000) \ 16777216) Or &H80&
        Else
            d = (Num And &HFF000000) \ 16777216
        End If
        
        If d < 16 Then
            LongToString = LongToString & "0" & Hex(d)
        Else
            LongToString = LongToString & Hex(d)
        End If
    
End Function

'
' Initialize the class
'   This must be called before a digest calculation is started
'
Public Sub MD5Init()
    ByteCounter = 0
    State(1) = UnsignedToLong(1732584193#)
    State(2) = UnsignedToLong(4023233417#)
    State(3) = UnsignedToLong(2562383102#)
    State(4) = UnsignedToLong(271733878#)
End Sub

'
' MD5 Final
'
Public Sub MD5Final()
    Dim dblBits As Double
    
    Dim padding(72) As Byte
    Dim lngBytesBuffered As Long
    
    padding(0) = &H80
    
    dblBits = ByteCounter * 8
    
    ' Pad out
    lngBytesBuffered = ByteCounter Mod 64
    If lngBytesBuffered <= 56 Then
        MD5Update 56 - lngBytesBuffered, padding
    Else
        MD5Update 120 - ByteCounter, padding
    End If
    
    
    padding(0) = UnsignedToLong(dblBits) And &HFF&
    padding(1) = UnsignedToLong(dblBits) \ 256 And &HFF&
    padding(2) = UnsignedToLong(dblBits) \ 65536 And &HFF&
    padding(3) = UnsignedToLong(dblBits) \ 16777216 And &HFF&
    padding(4) = 0
    padding(5) = 0
    padding(6) = 0
    padding(7) = 0
    
    MD5Update 8, padding
End Sub

'
' Break up input stream into 64 byte chunks
'
Public Sub MD5Update(InputLen As Long, InputBuffer() As Byte)
    Dim II As Integer
    Dim i As Integer
    Dim j As Integer
    Dim K As Integer
    Dim lngBufferedBytes As Long
    Dim lngBufferRemaining As Long
    Dim lngRem As Long
    
    lngBufferedBytes = ByteCounter Mod 64
    lngBufferRemaining = 64 - lngBufferedBytes
    ByteCounter = ByteCounter + InputLen
    ' Use up old buffer results first
    If InputLen >= lngBufferRemaining Then
        For II = 0 To lngBufferRemaining - 1
            ByteBuffer(lngBufferedBytes + II) = InputBuffer(II)
        Next II
        MD5Transform ByteBuffer
        
        lngRem = (InputLen) Mod 64
        ' The transfer is a multiple of 64 lets do some transformations
        For i = lngBufferRemaining To InputLen - II - lngRem Step 64
            For j = 0 To 63
                ByteBuffer(j) = InputBuffer(i + j)
            Next j
            MD5Transform ByteBuffer
        Next i
        lngBufferedBytes = 0
    Else
      i = 0
    End If
    
    ' Buffer any remaining input
    For K = 0 To InputLen - i - 1
        ByteBuffer(lngBufferedBytes + K) = InputBuffer(i + K)
    Next K
    
End Sub

'
' MD5 Transform
'
Private Sub MD5Transform(Buffer() As Byte)
    Dim x(16) As Long
    Dim a As Long
    Dim b As Long
    Dim c As Long
    Dim d As Long
    
    a = State(1)
    b = State(2)
    c = State(3)
    d = State(4)
    
    Decode 64, x, Buffer

    ' Round 1
    FF a, b, c, d, x(0), S11, -680876936
    FF d, a, b, c, x(1), S12, -389564586
    FF c, d, a, b, x(2), S13, 606105819
    FF b, c, d, a, x(3), S14, -1044525330
    FF a, b, c, d, x(4), S11, -176418897
    FF d, a, b, c, x(5), S12, 1200080426
    FF c, d, a, b, x(6), S13, -1473231341
    FF b, c, d, a, x(7), S14, -45705983
    FF a, b, c, d, x(8), S11, 1770035416
    FF d, a, b, c, x(9), S12, -1958414417
    FF c, d, a, b, x(10), S13, -42063
    FF b, c, d, a, x(11), S14, -1990404162
    FF a, b, c, d, x(12), S11, 1804603682
    FF d, a, b, c, x(13), S12, -40341101
    FF c, d, a, b, x(14), S13, -1502002290
    FF b, c, d, a, x(15), S14, 1236535329
    
    ' Round 2
    GG a, b, c, d, x(1), S21, -165796510
    GG d, a, b, c, x(6), S22, -1069501632
    GG c, d, a, b, x(11), S23, 643717713
    GG b, c, d, a, x(0), S24, -373897302
    GG a, b, c, d, x(5), S21, -701558691
    GG d, a, b, c, x(10), S22, 38016083
    GG c, d, a, b, x(15), S23, -660478335
    GG b, c, d, a, x(4), S24, -405537848
    GG a, b, c, d, x(9), S21, 568446438
    GG d, a, b, c, x(14), S22, -1019803690
    GG c, d, a, b, x(3), S23, -187363961
    GG b, c, d, a, x(8), S24, 1163531501
    GG a, b, c, d, x(13), S21, -1444681467
    GG d, a, b, c, x(2), S22, -51403784
    GG c, d, a, b, x(7), S23, 1735328473
    GG b, c, d, a, x(12), S24, -1926607734
    
    ' Round 3
    HH a, b, c, d, x(5), S31, -378558
    HH d, a, b, c, x(8), S32, -2022574463
    HH c, d, a, b, x(11), S33, 1839030562
    HH b, c, d, a, x(14), S34, -35309556
    HH a, b, c, d, x(1), S31, -1530992060
    HH d, a, b, c, x(4), S32, 1272893353
    HH c, d, a, b, x(7), S33, -155497632
    HH b, c, d, a, x(10), S34, -1094730640
    HH a, b, c, d, x(13), S31, 681279174
    HH d, a, b, c, x(0), S32, -358537222
    HH c, d, a, b, x(3), S33, -722521979
    HH b, c, d, a, x(6), S34, 76029189
    HH a, b, c, d, x(9), S31, -640364487
    HH d, a, b, c, x(12), S32, -421815835
    HH c, d, a, b, x(15), S33, 530742520
    HH b, c, d, a, x(2), S34, -995338651
    
    ' Round 4
    II a, b, c, d, x(0), S41, -198630844
    II d, a, b, c, x(7), S42, 1126891415
    II c, d, a, b, x(14), S43, -1416354905
    II b, c, d, a, x(5), S44, -57434055
    II a, b, c, d, x(12), S41, 1700485571
    II d, a, b, c, x(3), S42, -1894986606
    II c, d, a, b, x(10), S43, -1051523
    II b, c, d, a, x(1), S44, -2054922799
    II a, b, c, d, x(8), S41, 1873313359
    II d, a, b, c, x(15), S42, -30611744
    II c, d, a, b, x(6), S43, -1560198380
    II b, c, d, a, x(13), S44, 1309151649
    II a, b, c, d, x(4), S41, -145523070
    II d, a, b, c, x(11), S42, -1120210379
    II c, d, a, b, x(2), S43, 718787259
    II b, c, d, a, x(9), S44, -343485551
    
    
    State(1) = LongOverflowAdd(State(1), a)
    State(2) = LongOverflowAdd(State(2), b)
    State(3) = LongOverflowAdd(State(3), c)
    State(4) = LongOverflowAdd(State(4), d)

'  /* Zeroize sensitive information.
'*/
'  MD5_memset ((POINTER)x, 0, sizeof (x));
    
End Sub

Private Sub Decode(Length As Integer, OutputBuffer() As Long, InputBuffer() As Byte)
    Dim intDblIndex As Integer
    Dim intByteIndex As Integer
    Dim dblSum As Double
    
    intDblIndex = 0
    For intByteIndex = 0 To Length - 1 Step 4
        dblSum = InputBuffer(intByteIndex) + _
                                    InputBuffer(intByteIndex + 1) * 256# + _
                                    InputBuffer(intByteIndex + 2) * 65536# + _
                                    InputBuffer(intByteIndex + 3) * 16777216#
        OutputBuffer(intDblIndex) = UnsignedToLong(dblSum)
        intDblIndex = intDblIndex + 1
    Next intByteIndex
End Sub

'
' FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4.
' Rotation is separate from addition to prevent recomputation.
'
Private Function FF(a As Long, _
                    b As Long, _
                    c As Long, _
                    d As Long, _
                    x As Long, _
                    s As Long, _
                    ac As Long) As Long
    a = LongOverflowAdd4(a, (b And c) Or (Not (b) And d), x, ac)
    a = LongLeftRotate(a, s)
    a = LongOverflowAdd(a, b)
End Function

Private Function GG(a As Long, _
                    b As Long, _
                    c As Long, _
                    d As Long, _
                    x As Long, _
                    s As Long, _
                    ac As Long) As Long
    a = LongOverflowAdd4(a, (b And d) Or (c And Not (d)), x, ac)
    a = LongLeftRotate(a, s)
    a = LongOverflowAdd(a, b)
End Function

Private Function HH(a As Long, _
                    b As Long, _
                    c As Long, _
                    d As Long, _
                    x As Long, _
                    s As Long, _
                    ac As Long) As Long
    a = LongOverflowAdd4(a, b Xor c Xor d, x, ac)
    a = LongLeftRotate(a, s)
    a = LongOverflowAdd(a, b)
End Function

Private Function II(a As Long, _
                    b As Long, _
                    c As Long, _
                    d As Long, _
                    x As Long, _
                    s As Long, _
                    ac As Long) As Long
    a = LongOverflowAdd4(a, c Xor (b Or Not (d)), x, ac)
    a = LongLeftRotate(a, s)
    a = LongOverflowAdd(a, b)
End Function

'
' Rotate a long to the right
'
Function LongLeftRotate(Value As Long, bits As Long) As Long
    Dim lngSign As Long
    Dim lngI As Long
    bits = bits Mod 32
    If bits = 0 Then LongLeftRotate = Value: Exit Function
    For lngI = 1 To bits
        lngSign = Value And &HC0000000
        Value = (Value And &H3FFFFFFF) * 2
        Value = Value Or ((lngSign < 0) And 1) Or (CBool(lngSign And _
                &H40000000) And &H80000000)
    Next
    LongLeftRotate = Value
End Function

'
' Function to add two unsigned numbers together as in C.
' Overflows are ignored!
'
Private Function LongOverflowAdd(Val1 As Long, Val2 As Long) As Long
    Dim lngHighWord As Long
    Dim lngLowWord As Long
    Dim lngOverflow As Long

    lngLowWord = (Val1 And &HFFFF&) + (Val2 And &HFFFF&)
    lngOverflow = lngLowWord \ 65536
    lngHighWord = (((Val1 And &HFFFF0000) \ 65536) + ((Val2 And &HFFFF0000) \ 65536) + lngOverflow) And &HFFFF&
    LongOverflowAdd = UnsignedToLong((lngHighWord * 65536#) + (lngLowWord And &HFFFF&))
End Function

'
' Function to add two unsigned numbers together as in C.
' Overflows are ignored!
'
Private Function LongOverflowAdd4(Val1 As Long, Val2 As Long, val3 As Long, val4 As Long) As Long
    Dim lngHighWord As Long
    Dim lngLowWord As Long
    Dim lngOverflow As Long

    lngLowWord = (Val1 And &HFFFF&) + (Val2 And &HFFFF&) + (val3 And &HFFFF&) + (val4 And &HFFFF&)
    lngOverflow = lngLowWord \ 65536
    lngHighWord = (((Val1 And &HFFFF0000) \ 65536) + _
                   ((Val2 And &HFFFF0000) \ 65536) + _
                   ((val3 And &HFFFF0000) \ 65536) + _
                   ((val4 And &HFFFF0000) \ 65536) + _
                   lngOverflow) And &HFFFF&
    LongOverflowAdd4 = UnsignedToLong((lngHighWord * 65536#) + (lngLowWord And &HFFFF&))
End Function

'
' Convert an unsigned double into a long
'
Private Function UnsignedToLong(Value As Double) As Long
        If Value < 0 Or Value >= OFFSET_4 Then Error 6 ' Overflow
        If Value <= MAXINT_4 Then
          UnsignedToLong = Value
        Else
          UnsignedToLong = Value - OFFSET_4
        End If
      End Function

'
' Convert a long to an unsigned Double
'
Private Function LongToUnsigned(Value As Long) As Double
        If Value < 0 Then
          LongToUnsigned = Value + OFFSET_4
        Else
          LongToUnsigned = Value
        End If
End Function


Attribute VB_Name = "Name_Match_for_XML"
Public Function FillNodeTitles(currentWorksheet As String)

Dim declarationWorkSheet As Worksheet
Set declarationWorkSheet = ThisWorkbook.Worksheets(currentWorksheet)
titleRows = declarationWorkSheet.Rows.count

For rowCounter = 0 To titleRows - 1
    'Assumes no blank column names
    If Trim(declarationWorkSheet.Cells(rowCounter + 1, 1).Value) = "" Then Exit For
Next rowCounter

ReDim nodeTitles(rowCounter, 1, 1) As String
For i = 2 To rowCounter
    nodeTitles(i, 0, 0) = declarationWorkSheet.Cells(i, 1).Value
    nodeTitles(i, 1, 0) = declarationWorkSheet.Cells(i, 2).Value
    If declarationWorkSheet.Cells(i, 3).Value = "" Then
        nodeTitles(i, 1, 1) = "-"
    Else
        nodeTitles(i, 1, 1) = declarationWorkSheet.Cells(i, 3).Value
    End If
Next i
End Function



Attribute VB_Name = "Namen_Trennen"

'Stanislav Wischniak
'Oktober 2006

'Die Ausgew|fffd|hlten Namen werden auf 2 Spalten verteilt.
'Beispiel: "Wischniak, Stanislav" wird zu "Wischniak | Stanislav"

Option Explicit

Private Sub Namen_trennen()
Dim a%, b%, i%
Dim Zelle As Object

ActiveSheet.Columns(Selection.Range("B1").Column).Insert
'Bereich mu|fffd| markiert sein,
'f|fffd|r jede Zelle in der Markierung:
For Each Zelle In Selection
    With Zelle
        'Suche nach der ersten Komma
        a = InStr(.Value, ",")
        'Schleife, falls mehrere durch leer getrennte Vornamen
        'vorhanden sind, z. B. Ute Elke Meier
        For i = 0 To Len(.Value)
            b = InStr(Right(.Value, Len(.Value) - a), ",")
            a = InStr(Right(.Value, Len(.Value) - a), ",") + a
        Next
        On Error Resume Next 'falls leere Zellen markiert sind
        'Aufteilen auf die 1. Zelle rechts und die 2. Zelle rechts
        'Name
        Cells(.row, .Column + 1).Value = Trim(Right(.Value, Len(.Value) - a))
        'Vorname
        Cells(.row, .Column).Value = Trim(Left(.Value, a - 1))

    End With
Next
End Sub
Attribute VB_Name = "OU_invisible"
'Stanislav Wischniak
'wischniak@qualitus.de
'Created: 13.11.2014

Sub hideOU()
    'Set ws = ActiveWorkbook.ActiveSheet
    ThisWorkbook.Worksheets("OrgUnits").Visible = xlVeryHidden
    ThisWorkbook.Worksheets("OrgUnit-Declaration").Visible = xlVeryHidden
End Sub

Sub showOU()
    ThisWorkbook.Worksheets("OrgUnits").Visible = True
    ThisWorkbook.Worksheets("OrgUnit-Declaration").Visible = True
End Sub
Attribute VB_Name = "OrgUnitExport"
'February 2012
'Stanislav Wischniak
'wischniak@qualitus.de
'Creates an XML with a given org structure from table "OrgUnits".
'The XML is used to manage (insert/move) an org structure in ILIAS (custom OrgUnits-Feature).
'Prior to export the given structure is verified and shown to the user.


Public Sub OrgUnitExport()
    'Declare a variable as a FileDialog object.
    Dim fd As FileDialog

    'Create a FileDialog object as a File Picker dialog box.
    Set fd = Application.FileDialog(msoFileDialogSaveAs)

    'Declare a variable to contain the path
    'of each selected item. Even though the path is a String,
    'the variable must be a Variant because For Each...Next
    'routines only work with Variants and Objects.
    Dim vrtSelectedItem As Variant

    'Use a With...End With block to reference the FileDialog object.
    With fd

        'Change the contents of the Files of Type list.
        'Empty the list by clearing the FileDialogFilters collection.
        '.filters.Clear


        'Add a filter that includes all files.
        '.filters.Add "All files", "*.*"

        'Add a filter that includes XML files and make it the first item in the list.
        '.filters.Add "XML", "*.xml", 1

        'Use the Show method to display the File Picker dialog box and return the user's action.
        'The user pressed the action button.
        If .Show = -1 Then

            'Step through each String in the FileDialogSelectedItems collection.
            For Each vrtSelectedItem In .SelectedItems

                'vrtSelectedItem is a String that contains the path of each selected item.
                'You can use any file I/O functions that you want to work with this path.
                'This example simply displays the path in a message box.
                'MsgBox "Path name: " & vrtSelectedItem

                'ORG_ExportToILIASXML "" & vrtSelectedItem, "UTF-16LE"
                ORG_ExportToILIASXML "" & vrtSelectedItem, "UTF-16LE"
            Next vrtSelectedItem
        'The user pressed Cancel.
        Else
        End If
    End With

    'Set the object variable to Nothing.
    Set fd = Nothing
End Sub
Attribute VB_Name = "Tabelle1"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Tabelle2"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Tabelle3"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Tabelle4"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "TextFormeln"
Function toLogin(Text)
' Removes all characters which are not allowed for an ILIAS
' login from the specified text

Text = LCase(Text)
Text = Replace(Text, "|fffd|", "ae")
Text = Replace(Text, "|fffd|", "a")
Text = Replace(Text, "|fffd|", "a")
Text = Replace(Text, "|fffd|", "a")
Text = Replace(Text, "|fffd|", "c")
Text = Replace(Text, ChrW(263), "c") 'unicode: LATIN SMALL LETTER C WITH ACUTE
Text = Replace(Text, ChrW(269), "c") 'unicode: LATIN SMALL LETTER C WITH CARON
Text = Replace(Text, "|fffd|", "e")
Text = Replace(Text, "|fffd|", "e")
Text = Replace(Text, "|fffd|", "e")
Text = Replace(Text, "|fffd|", "e")
Text = Replace(Text, "|fffd|", "i")
Text = Replace(Text, "|fffd|", "n")
Text = Replace(Text, "|fffd|", "oe")
Text = Replace(Text, "|fffd|", "o")
Text = Replace(Text, "|fffd|", "o")
Text = Replace(Text, "|fffd|", "o")
Text = Replace(Text, "|fffd|", "ue")
Text = Replace(Text, "|fffd|", "u")
Text = Replace(Text, "|fffd|", "u")
Text = Replace(Text, "|fffd|", "u")
Text = Replace(Text, "|fffd|", "ss")
Text = Replace(Text, "|fffd|", "y")
'text = Replace(text, "-", "")
Text = Replace(Text, "'", "")
Text = Replace(Text, " ", "")
Text = Replace(Text, ChrW(160), "")

toLogin = Text
End Function

Function GetWord(Text, Index, delimiter)
Dim words() As String
  
  ' Split adds empty strings to the array if
  ' the text contains multiple consecutive delimiters
words = Split(Text, delimiter)

' This for loop is used to skip the the empty strings
' in the word array.
Dim i As Integer
Dim count As Integer
count = -1
For i = LBound(words) To UBound(words)
  If words(i) <> "" Then
    count = count + 1
  End If
  If count = Index Then
    Exit For
  End If
Next

If count = Index Then
  GetWord = words(i)
Else
  GetWord = ""
End If
End Function

Function shortFirstname(firstname)
'Shortens the firstname of a person for use as a login
'If a firstname consists of multiple words, only the first word is taken
'
' e.g. Heinrich Josef   is returned as   Heinrich
'      Franz-Xaver      is returned as   Franz-Xaver

    
    shortFirstname = GetWord(firstname, 0, " ")
End Function

Function shortLastname(lastname)
'Shortens the lasttname of a person for use as a login
'If a lastname consists of multiple words, only the first word is taken,
'    except, if the first word is a preposition, then the second word is
'    taken as well
'
' e.g. Meier Huber   is returned as   Meier
'      Meier-Huber   is returned as   Meier-Huber
'      von Allmen    is returned as   vonAllmen

    shortLastname = GetWord(lastname, 0, " ")
    
    ' Handle individual cases
    Select Case shortLastname
        Case "da", "di", "de", "del", "della", "la", "le", "van", "von"
            shortLastname = shortLastname & GetWord(lastname, 1, " ")
    End Select
End Function
Function password(pwLength, nmbrDigits, nmbrCharacters)
'Generates a password of the specified length incl. capitals and a specified number of random placed digits and special characters
    
    Dim nmbrLetters As Integer
    Dim intArr(1 To 77) As Integer 'Array um 15 erweitert, vorher 62
    'Dim intZahlenArr(1 To 48) As Integer
    
    Dim intZ As Integer
    Dim intP As Integer
    Dim strPW As String
    
    
    'Array von 1 bis 15 mit Zahlen 33-47 bef|fffd|llen
    For intZ = 33 To 47  'Sonderzeichen
        intArr(intZ - 32) = intZ
        'Debug.Print Chr(intArr(intZ - 32))
        'Special characters used: !"#$%&'()*+,-./
    Next intZ
    'Array von 16 bis 25 mit Zahlen 48-57 bef|fffd|llen
    For intZ = 48 To 57 '0 bis 9
        intArr(intZ - 32) = intZ
        'Debug.Print Chr(intArr(intZ - 32))
    Next intZ
    'Array von 26 bis 51 mit Zahlen 65-90 bef|fffd|llen
    For intZ = 65 To 90 'A bis Z
        intArr(intZ - 39) = intZ
        'Debug.Print Chr(intArr(intZ - 39))
    Next intZ
    'Array von 52 bis 77 mit Zahlen 97-122 bef|fffd|llen
    For intZ = 97 To 122  'a bis z
        intArr(intZ - 45) = intZ
        'Debug.Print Chr(intArr(intZ - 45))
    Next intZ
    Randomize
    
    nmbrLetters = pwLength - (nmbrDigits + nmbrCharacters)
          
    For intP = 1 To pwLength 'Anzahl Stellen des Passwortes
      
    Do While (nmbrDigits + nmbrCharacters + nmbrLetters > 0) 'Solange nicht alle verwendet ...
        'Verwendung der Rnd - Funktion: Int((Obergrenze - Untergrenze + 1) * Rnd + Untergrenze)
        'Es wird eine Zahl aus der vorgegebenen Menge per Zufall rausgesucht (currInt)
        currInt = intArr(Int(77 * Rnd + 1))
        
      If (currInt > 32 And currInt < 48) And (nmbrCharacters > 0) Then 'Wenn ein Sonderzeichen ...
        nmbrCharacters = nmbrCharacters - 1
        strPW = strPW & Chr(currInt)
        Exit Do
      End If
      If (currInt > 47 And currInt < 58) And (nmbrDigits > 0) Then 'Wenn eine Zahl ...
        nmbrDigits = nmbrDigits - 1
        strPW = strPW & Chr(currInt)
      End If
      If (currInt > 64 And currInt < 91) And (nmbrLetters > 0) Then 'Wenn ein Buchstabe (gro|fffd|) ...
        nmbrLetters = nmbrLetters - 1
        strPW = strPW & Chr(currInt)
      End If
      If (currInt > 96 And currInt < 123) And (nmbrLetters > 0) Then 'Wenn ein Buchstabe (klein) ...
        nmbrLetters = nmbrLetters - 1
        strPW = strPW & Chr(currInt)
      End If
      
      Loop
    Next intP
    password = strPW
End Function

'Function password(Length)
'' Generates a password of the specified length
'' consisting of digits and lower case characters, except character 'l'
'' because it can easily be confused with number 1.
'    password = ""
'    passwordChars = "01234567890abcdefghijkmnopqrstuvwxyz"
'
'    Randomize '(Time())
'
'    For i = 1 To Length
'        password = password & Mid(passwordChars, Int(Len(passwordChars) * Rnd) + 1, 1)
'    Next
'End Function



Function trimWhitespace(Text)
' Removes all whitespace characters from the start and end of a string
Dim startpos As Integer
Dim endpos As Integer
Dim ch As String

For startpos = 1 To Len(Text)
    ch = Mid(Text, startpos, 1)
    If (ch > " " And AscW(ch) <> 160) Then
        Exit For
    End If
Next
If (startpos > Len(Text)) Then
    trimWhitespace = ""
Else
    For endpos = Len(Text) To 1 Step -1
        ch = Mid(Text, endpos, 1)
        If (ch > " " And AscW(ch) <> 160) Then
            Exit For
        End If
    Next
    trimWhitespace = Mid(Text, startpos, endpos - startpos + 1)
End If
End Function

Function ensureXmlExtension(path)
'ensure export file extension is set to '.xml'
Dim i As Integer
Dim extensionpos As Integer

If InStr(1, path, ".xml", vbTextCompare) < 1 Then
    extensionpos = Len(path) + 1 'just in case there is no extension at all
    For i = 1 To Len(path)
        If Mid(path, i, 1) = "." Then extensionpos = i
    Next i
    path = Left(path, extensionpos - 1) & ".xml"
    MsgBox "Please take note, that the export file extension has been changed to '.xml':" & Chr(10) & path
End If
ensureXmlExtension = path
End Function

Attribute VB_Name = "TreeViewTester"

'February 2012
'Stanislav Wischniak
'wischniak@qualitus.de
'
'
'ToDo:
'"M|fffd|gliche Fehlerszenarien f|fffd|r Pr|fffd|fung:
'- OU-x ou_parent_id = OU-Y ou_id UND OU-Y ou_parent_id = OU-X ou_id (X ist child von Y und Y ist child von X)
'M|fffd|gl. ToDo: Button: Expand all/Collapse all

Public Sub TreeViewTester()

UserForm2.createTree_Click

End Sub





Attribute VB_Name = "UserForm2"
Attribute VB_Base = "0{7E56E984-E332-495D-A97F-5D449CBA2F29}{540FD8CA-5A98-4B58-B814-1780FB7142BD}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
                                                                                                                                                                              
'February 2012
'Stanislav Wischniak
'wischniak@qualitus.de

'Creates an XML with a given org structure from table "OrgUnits".
'The XML is used to manage (insert/move) an org structure in ILIAS (custom OrgUnits-Feature).
'Prior to export the given structure is verified and shown to the user.

Private WithEvents mcTree As clsTreeView
Attribute mcTree.VB_VarHelpID = -1
Dim cRoot As clsNode
Dim cNode As clsNode
Dim cExtraNode As clsNode
Public AppName As String



Private Sub Exportieren_Click()
'Declare a variable as a FileDialog object.
    Dim fd As FileDialog

    'Create a FileDialog object as a File Picker dialog box.
    Set fd = Application.FileDialog(msoFileDialogSaveAs)

    'Declare a variable to contain the path
    'of each selected item. Even though the path is a String,
    'the variable must be a Variant because For Each...Next
    'routines only work with Variants and Objects.
    Dim vrtSelectedItem As Variant

    'Use a With...End With block to reference the FileDialog object.
    With fd
    
        .title = "Save as XML-File"
        .InitialFileName = Format(Date, "yyyy-mm-dd") & "_OU-Import"
        .AllowMultiSelect = False
        
        'Change the contents of the Files of Type list.
        'Empty the list by clearing the FileDialogFilters collection.
        '.filters.Clear

        'Add a filter that includes all files.
        '.filters.Add "All files", "*.*"

        'Add a filter that includes XML files and make it the first item in the list.
        '.filters.Add "XML", "*.xml", 1

        'Use the Show method to display the File Picker dialog box and return the user's action.
        'The user pressed the action button.
        If .Show = -1 Then

            'Step through each String in the FileDialogSelectedItems collection.
            For Each vrtSelectedItem In .SelectedItems

                'vrtSelectedItem is a String that contains the path of each selected item.
                'You can use any file I/O functions that you want to work with this path.
                'This example simply displays the path in a message box.
                'MsgBox "Path name: " & vrtSelectedItem

                ORG_ExportToILIASXML "" & vrtSelectedItem, "UTF-16LE"
            Next vrtSelectedItem
        'The user pressed Cancel.
        Else
        End If
    End With

    'Set the object variable to Nothing.
    Set fd = Nothing
End Sub

Private Sub frmDemo_Click()

End Sub

Private Sub frmTreeView_Click()

End Sub

Private Sub Label1_Click()

End Sub

Private Sub Label2_Click()

End Sub

Private Sub Label3_Click()

End Sub

Private Sub Label5_Click()

End Sub

Private Sub Label6_Click()

End Sub

Private Sub Label7_Click()

End Sub

Private Sub Label8_Click()

End Sub

Private Sub TextBox1_Change()

End Sub

Private Sub TextBox2_Change()

End Sub

Private Sub TextBox4_Change()

End Sub

Private Sub TextBox5_Change()

End Sub

Private Sub TreeView2_NodeClick(ByVal Node As MSComctlLib.Node)
    TextBox1.Text = Node.FullPath 'Kette
    
    If Node.Key = "ilias" Then
        TextBox2.Text = "[1]"
        'TextBox4.text = "[Keine |fffd|bergeordnete Einheit vorhanden]"
        TextBox4.Text = "[Parent unit is missing]"
        'TextBox6.text = "[Oberste Systemeinheit]" 'description
        TextBox6.Text = "[Top unit]" 'description
        TextBox7.Text = "" 'typ
        TextBox8.Text = "" 'responsible
    Else
        TextBox2.Text = Node.Tag(1) 'Position (Zeile)
        TextBox4.Text = Node.Parent.Key 'ID der |fffd|bergeordneten OE
        TextBox6.Text = Node.Tag(2) 'description
        TextBox7.Text = Node.Tag(3) 'UDF 1
        TextBox8.Text = Node.Tag(4) 'UDF 2
    End If
    
    
    TextBox3.Text = Node.Key 'ID der OE
              
    TextBox5.Text = Node.Text   'title

        
End Sub



'Example for scalable form (not implemented yet)

'
'Option Explicit
'
'Private m_objUserForm As clsUserForm
'Private m_blnFormInit As Boolean
'
'Private Sub UserForm_Activate()
'  Set m_objUserForm = New clsUserForm
'  Set m_objUserForm.Form = Me
'End Sub
'
'Private Sub UserForm_Resize()
'  If m_objUserForm.gIsIconic = True Then Exit Sub
'
'  Const cMinHght As Single = 100
'  Const cMinWdth As Single = 200
'  Const cGap     As Single = 6
'
'  Dim sngTxtBoxHght As Single
'  Dim sngTxtBoxWdth As Single
'
'  If Me.Height < cMinHght Then Me.Height = cMinHght
'  If Me.Width < cMinWdth Then Me.Width = cMinWdth
'
'  sngTxtBoxHght = (Me.InsideHeight - Me.fraButtons.Height - _
'        (cGap * 4)) / 2
'  sngTxtBoxWdth = Me.InsideWidth - (cGap * 2)
'
'  txtTop.Move cGap, cGap, sngTxtBoxWdth, sngTxtBoxHght
'  txtBot.Move cGap, txtTop.Height + (cGap * 2), _
'        sngTxtBoxWdth, sngTxtBoxHght
'
'  Me.fraButtons.Move Me.InsideWidth - Me.fraButtons.Width - cGap, _
'        Me.InsideHeight - Me.fraButtons.Height
'
'  If m_objUserForm.gIsZoomed = True Then
'    Me.imgGrip.Visible = False
'  Else
'    Me.imgGrip.Visible = True
'    Me.imgGrip.Move Me.InsideWidth - 10, Me.InsideHeight - 10
'  End If
'End Sub
'
'Private Sub UserForm_Terminate()
'  Set m_objUserForm = Nothing
'End Sub
'


Public Sub NodesClear()
' PT,  similar to Treeview.Nodes.Clear
    Dim i As Long
    On Error GoTo errH

    If Not TreeControl Is Nothing Then
        For i = TreeControl.Controls.count - 1 To 0 Step -1
            TreeControl.Controls.Remove i
        Next
    End If

    TerminateTree

    Changed = False

    Exit Sub
errH:
    #If DebugMode = 1 Then
        Stop
        Resume
    #End If
End Sub


Public Sub createTree_Click()

    Dim ou_parent_id As String
    Dim ou_id As String
    Dim ou_title As String
    Dim i As Integer
    Dim lastRow As Integer
    Dim ErrorMessage As String
    ReDim available_Parents(0) As String
    Dim parent_counter As Integer
    Dim parents As String
    Dim parent_undefined As Boolean
    
    Dim iD_required As String
    Dim parnetID_required As String
    Dim title_required As String
    Dim descrpition_required As String
    Dim orgType_required As String
    
    Dim nodeTitles As Variant
    Dim requiredFields As Variant

    Dim cNode As clsNode

    Set mcTree = New clsTreeView
    
    
    With mcTree
        Set .TreeControl = Me.frmTreeView
        .AppName = Me.AppName
        .NodeHeight = 16 * 0.75
        .LabelEdit = 1
    

        
        'Set first node
        Set cRoot = .AddRoot("ilias", "ILIAS")
        cRoot.Bold = True
        
        'Lost: nodx.Expanded = True
    
        lastRow = ActiveSheet.Cells(Rows.count, "b").End(xlUp).row

        ' **********************************
        ' Set ERROR-Messages
        ' First Parent should be ilias
        available_Parents(0) = "ilias"

        globalFunctions.FillNodeTitles nodeTitles, "OrgUnit-Declaration"

        For i = 2 To lastRow

            'Required Fields
            globalFunctions.getRealName nodeTitles, requiredFields, ActiveSheet.Range("a" & 1).Value
            'MsgBox requiredFields(0, 1)
            iD_required = requiredFields(0, 1)
            globalFunctions.getRealName nodeTitles, requiredFields, ActiveSheet.Range("b" & 1).Value
            parnetID_required = requiredFields(0, 1)
            globalFunctions.getRealName nodeTitles, requiredFields, ActiveSheet.Range("c" & 1).Value
            title_required = requiredFields(0, 1)
            globalFunctions.getRealName nodeTitles, requiredFields, ActiveSheet.Range("d" & 1).Value
            descrpition_required = requiredFields(0, 1)
            globalFunctions.getRealName nodeTitles, requiredFields, ActiveSheet.Range("e" & 1).Value
            orgType_required = requiredFields(0, 1)
            
            ou_parent_id = ActiveSheet.Range("b" & i).Value
            ou_id = ActiveSheet.Range("a" & i).Value
            ou_title = ActiveSheet.Range("c" & i).Value
            
            If ou_id = "" And iD_required = "yes" Then
                'Error Message 5:
                ErrorMessage = "Sie haben keine " & ActiveSheet.Range("a" & 1).Value & " hinterlegt! "
                GoTo Fehler
            ElseIf ou_parent_id = "" And parnetID_required = "yes" Then
                'Error Message 5:
                ErrorMessage = "Sie haben keine " & ActiveSheet.Range("b" & 1).Value & " hinterlegt!"
                GoTo Fehler
            ElseIf ou_title = "" And title_required = "yes" Then
                'Error Message 5:
                ErrorMessage = "Sie haben keinen " & ActiveSheet.Range("c" & 1).Value & " hinterlegt!"
                GoTo Fehler
            End If
            For M = 0 To UBound(available_Parents)
                If available_Parents(M) = ou_id Then
                    'Error Message 4:
                    ErrorMessage = "Die ID wurde bereits in Zeile " & M + 1 & " definiert."
                End If
            Next M
            ' Error Message 1:  If first declared parent in field isn't ilias
            If ou_parent_id <> "ilias" And i = 2 Then
                ErrorMessage = "Der erste Parent muss 'ilias' sein."
            ' Error Message 2: If ID is equal to Parent-ID
            ElseIf ou_parent_id = ou_id Then
                ErrorMessage = "Die Parent-ID muss sich von der eigenen ID " & Chr(9) & Chr(9) & Chr(9) & "unterscheiden."
            ' Error Message 3: If Parent ID is declared before ID
            Else
                parent_undefined = True
                For counter = 0 To UBound(available_Parents)
                    If available_Parents(counter) = ou_parent_id Then
                        parent_undefined = False
                    End If
                Next counter
                
                If parent_undefined Then
                    ErrorMessage = "Die Parent-ID darf nur deklariert " & Chr(9) & Chr(9) & Chr(9) & Chr(9) & "werden, wenn ID bereits vorhanden."
                End If
            End If
            
            ReDim Preserve available_Parents(UBound(available_Parents) + 1)
            'MsgBox UBound(available_Parents) & "," & ou_id
            available_Parents(UBound(available_Parents)) = ou_id
            
            
           
            'Set Error handling
            'On Error GoTo Fehler
            'object.Add(relative, relationship, key, text, image, selectedimage)
            
            If i = 2 Then
                Set cNode = cRoot.AddChild(ou_id, ou_title)
            ElseIf ou_parent_id <> "ilias" Then
                If FindNode(cRoot, ou_parent_id).Key <> "" Then
                   Set cNode = FindNode(cRoot, ou_parent_id)
                   Set cNode = cNode.AddChild(ou_id, ou_title)
                   
                End If
                
            Else
                Set cNode = cRoot.AddChild(ou_id, ou_title)
                
            End If
            'Set nodx = TV.Nodes.Add(ou_parent_id, tvwChild, ou_id, ou_title)
            'MsgBox UserForm2.cRoot
           
            Dim data(1 To 4) As String
            data(1) = CStr(i)           'row as string
            data(2) = ActiveSheet.Range("d" & i).Value 'description
            data(3) = ActiveSheet.Range("e" & i).Value 'org-type
    
    
            If data(2) = "" And descrpition_required = "yes" Then
                'Error Message 5:
                ErrorMessage = "Sie haben keine " & ActiveSheet.Range("d" & 1).Value & " hinterlegt!"
                GoTo Fehler
            ElseIf data(3) = "" And orgType_required = "yes" Then
                'Error Message 5:
                ErrorMessage = "Sie haben keinen " & ActiveSheet.Range("e" & 1).Value & " hinterlegt!"
                GoTo Fehler
            End If
            'data(4) = ActiveSheet.Range("f" & I).value 'UDF 2
            
            'Assign array with data to tag
            cNode.Tag = data()
            'Expand node
            'Lost: nodx.Expanded = True
        Next i

        UserForm2.Show
        .PopulateTree
        
        'LOST: Set TV = Nothing
        'LOST: Set nodx = Nothing

        'Exit sub without msgbox, when OK. Else msgbox with wrong row & error description.
        Exit Sub
        
Fehler:
        If Err.Description <> "" Then
        MsgBox "Fehler in Zeile: " & Chr(9) & i & Chr(13) & _
                    "Fehlertext: " & Chr(9) & Err.Description & Chr(13) & _
                    "Beschreibung: " & Chr(9) & ErrorMessage, vbCritical, "Fehler"
        Else
        MsgBox "Fehler in Zeile: " & Chr(9) & Chr(9) & i & Chr(13) & _
                    "Beschreibung: " & Chr(9) & Chr(9) & ErrorMessage, vbCritical, "Fehler"
        End If
    
    End With

End Sub

Public Sub addMyNodes(title)

    With mcTree
        Set cNode = cRoot.AddChild(1, title)
        cNode.Bold = True
    
    End With

EndSub

End Sub


Public Function FindNode(cNode As clsNode, vKey As Variant) As clsNode
    Dim cFoundNode As clsNode
    Dim cNextNode As clsNode
    
    If Not cNode.ChildNodes Is Nothing Then
        If cNode.GetChild(vKey) Is Nothing Then
             If Not cNode.ChildNodes Is Nothing Then
                 For Each cNextNode In cNode.ChildNodes
                     Set FindNode = FindNode(cNextNode, vKey)
                     If Not FindNode Is Nothing Then Exit Function
                 Next
             End If
         Else
             Set cFoundNode = cNode.GetChild(vKey)
             Set FindNode = cFoundNode
         End If
    End If
End Function




Attribute VB_Name = "XMLExport"
Public Sub XMLExport()
 'Declare a variable as a FileDialog object.
    Dim fd As FileDialog

    'Create a FileDialog object as a File Picker dialog box.
    Set fd = Application.FileDialog(msoFileDialogSaveAs)

    'Declare a variable to contain the path
    'of each selected item. Even though the path is a String,
    'the variable must be a Variant because For Each...Next
    'routines only work with Variants and Objects.
    Dim vrtSelectedItem As Variant

    'Use a With...End With block to reference the FileDialog object.
    With fd

        .title = "Save XML file"
        .InitialFileName = Format(Date, "yyyy-mm-dd") & "_UserImport"
        .AllowMultiSelect = False
        
        'Choose "XML-Daten" filter per default.
        'Debug.Print .Filters(5).Description
        .FilterIndex = 5

        'Use the Show method to display the File Picker dialog box and return the user's action.
        'The user pressed the action button.
        If .Show = -1 Then

            'Step through each String in the FileDialogSelectedItems collection.
            For Each vrtSelectedItem In .SelectedItems

                'vrtSelectedItem is a String that contains the path of each selected item.
                'You can use any file I/O functions that you want to work with this path.
                'This example simply displays the path in a message box.
                'MsgBox "Path name: " & vrtSelectedItem
                
                ExportToILIASXML "" & vrtSelectedItem, "UTF-16LE"
                
                
            Next vrtSelectedItem
        'The user pressed Cancel.
        Else
        End If
    End With

    'Set the object variable to Nothing.
    Set fd = Nothing
End Sub
Attribute VB_Name = "clsNode"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'Build 021
'***************************************************************************
'
' Authors:  JKP Application Development Services, info@jkp-ads.com, http://www.jkp-ads.com
'           Peter Thornton, pmbthornton@gmail.com
'
' (c)2013, all rights reserved to the authors
'
' You are free to use and adapt the code in these modules for
' your own purposes and to distribute as part of your overall project.
' However all headers and copyright notices should remain intact
'
' You may not publish the code in these modules, for example on a web site,
' without the explicit consent of the authors
'***************************************************************************

'-------------------------------------------------------------------------
' Module    : clsNode
' Company   : JKP Application Development Services (c)
' Author    : Jan Karel Pieterse (www.jkp-ads.com)
' Created   : 15-01-2013
' Purpose   : Holds all information of a node of the tree
'-------------------------------------------------------------------------
Option Explicit

Private mbExpanded As Boolean

Private mcolChildNodes As Collection

Private moParentNode As clsNode
Private moTree As clsTreeView

Private msKey As String
Private msCaption As String

Private mlChecked As Long        ' PT checkbox tristate boolean 0/-1 or 1 for null
'Private mbVisible As Boolean        ' PT determines if the node can be displayed
Private mnIndex As Long             ' PT order added to Treeview's mcolNodes, won't change
Private mlVisIndex As Long          ' PT the visible order in the current view, changes with expand/collapse
Private mvIconMainKey               ' PT string name or numeric index as icon Key for the Image collection
Private mvIconExpandedKey           ' PT ditto for expanded icon
Private mlIconCnt As Long           ' PT number of icons availabel for this node 0, 1 or 2
Private msngTextWidth As Single     ' PT autosized text width before the node is widened beyond the frame
Private mlBackColor As Long         ' PT
Private mbBold As Boolean           ' PT
Private mlForeColor As Long         ' PT
Private mvTag

Private WithEvents mctlControl As MSForms.Label
Attribute mctlControl.VB_VarHelpID = -1
Private WithEvents mctlExpander As MSForms.Label
Attribute mctlExpander.VB_VarHelpID = -1
Private WithEvents moEditBox As MSForms.TextBox     ' PT editbox
Attribute moEditBox.VB_VarHelpID = -1
Private WithEvents mctlCheckBox As MSForms.Label    ' PT checkbox
Attribute mctlCheckBox.VB_VarHelpID = -1

Private mctlExpanderBox As MSForms.Label
Private mctlVLine As MSForms.Label  ' PT vertical line, only the first child node with children will have a vertical line
Private mctlHLine As MSForms.Label  ' PT horizontal line
Private mctlIcon As MSForms.Image   ' PT separate icon image control

Public Enum ndSortOrder
    ndAscending = 1
    ndDescending = 2
End Enum
Public Enum ndCompareMethod
    ndBinaryCompare = 0
    ndTextCompare = 1
End Enum
Public Enum ndMouse
    ndDown = 1
    ndUp = 2
    ndMove = 3
    ndBeforeDragOver = 4
    ndBeforeDropOrPaste = 5
End Enum

#If Mac Then
    Const mcFullWidth As Long = 800
#Else
    Const mcFullWidth As Long = 600
#End If

'*********************
'* Public Properties *
'*********************

Public Property Get BackColor() As Long

    BackColor = mlBackColor ' if zero the treecaller will apply the frame container's backcolor

End Property

Public Property Let BackColor(lColor As Long)
'PT if lColor is written as 0/black, change it to 1 as 0 means default
    mlBackColor = lColor
    If mlBackColor = 0 Then mlBackColor = 1
    If Not mctlControl Is Nothing Then
        mctlControl.BackColor = lColor
    End If
End Property

Public Property Get Bold() As Boolean
    Bold = mbBold
End Property

Public Property Let Bold(bBold As Boolean)
    mbBold = bBold
    If Not mctlControl Is Nothing Then
        mctlControl.Font.Bold = mbBold
    End If
End Property

Public Property Get Caption() As String
    Caption = msCaption
End Property

Public Property Let Caption(ByVal sCaption As String)
    msCaption = sCaption
    If Not mctlControl Is Nothing Then
        mctlControl.Caption = sCaption
    End If
End Property

Public Property Get cHild() As clsNode
' PT Returns a reference to the first Child node, if any
    On Error Resume Next
    Set cHild = mcolChildNodes(1)
End Property

Public Property Get Checked()    ' PT
     ' Checked values are -1 true, 0 false, +1 mixed
     ' If TriState is enabled be careful not to return a potential +1 to a boolean or it'll coerce to True
    Checked = mlChecked
End Property

Public Property Let Checked(vChecked)  ' PT
    Dim bFlag As Boolean, bTriState As Boolean
    Dim alChecked(-1 To 1) As Long
    Dim lChecked As Long
    Dim cNode As clsNode
    Dim cChild As clsNode
    Dim pic As StdPicture

    ' Checked values are -1 true, 0 false, +1 mixed
    ' if vChecked is a boolean Checked will coerce to -1 or 0
    ' if vChecked is Null Checked is set as +1

    If VarType(vChecked) = vbBoolean Then
        lChecked = vChecked
    ElseIf IsNull(vChecked) Then
        lChecked = 1
    ElseIf vChecked >= -1 And vChecked <= 1 Then
        lChecked = vChecked
    End If

    bFlag = lChecked <> mlChecked
    mlChecked = lChecked

    If Not mctlCheckBox Is Nothing And bFlag Then
        moTree.Changed = True
        UpdateCheckbox
    End If
    
    If Not moTree Is Nothing Then    ' eg during clone
        bFlag = moTree.CheckBoxes(bTriState)
        If bTriState Then
            If ParentNode.Caption <> "RootHolder" Then
                ParentNode.CheckTriStateParent
            End If
            
            If Not ChildNodes Is Nothing Then
                For Each cChild In ChildNodes
                    cChild.CheckTriStateChildren mlChecked
                Next
            End If
        End If
    End If
    
End Property

Public Property Get ChildNodes() As Collection
    Set ChildNodes = mcolChildNodes
End Property

Public Property Set ChildNodes(colChildNodes As Collection)
    Set mcolChildNodes = colChildNodes
End Property

Public Property Get Expanded() As Boolean
    Expanded = mbExpanded
End Property

Public Property Let Expanded(ByVal bExpanded As Boolean)
    mbExpanded = bExpanded
    If Not Me.Expander Is Nothing Then
        UpdateExpanded bControlOnly:=False
    ElseIf Not Me.Control Is Nothing Then
        UpdateExpanded bControlOnly:=True
    End If
End Property

Public Property Get ForeColor() As Long
    ForeColor = mlForeColor
End Property

Public Property Let ForeColor(lColor As Long)
'PT if lColor is written as 0/black, change it to 1 as 0 means default
    mlForeColor = lColor
    If mlForeColor = 0 Then mlForeColor = 1
    If Not mctlControl Is Nothing Then
        mctlControl.ForeColor = lColor
    End If
End Property

Public Property Get FirstSibling() As clsNode
    If Not moParentNode Is Nothing Then    ' PT Root has no parent
        Set FirstSibling = moParentNode.GetChild(1)
    End If
End Property

Public Property Get LastSibling() As clsNode
    If Not moParentNode Is Nothing Then    ' PT Root has no parent
        Set LastSibling = moParentNode.GetChild(-1)    ' -1 flags GetChild to return the last Child
    End If
End Property

Public Property Get ImageExpanded()
' PT string name or numeric index for the main icon key
    ImageExpanded = mvIconExpandedKey
End Property

Public Property Let ImageExpanded(vImageExpanded)
' PT string name or numeric index for an expanded icon key
    On Error GoTo errExit
    If Not IsMissing(vImageExpanded) Then
        If Not IsEmpty(vImageExpanded) Then
            If Len(mvIconMainKey) = 0 Then
                mvIconMainKey = vImageExpanded
            End If
            mvIconExpandedKey = vImageExpanded
            mlIconCnt = 2
        End If
    End If
errExit:
End Property

Public Property Get ImageMain()
' PT string name or numeric index for the main icon key
    ImageMain = mvIconMainKey
End Property

Public Property Let ImageMain(vImageMain)
' PT string name or numeric index for the main icon key
    On Error GoTo errExit
    If Not IsMissing(vImageMain) Then
        If Not IsEmpty(vImageMain) Then
            mvIconMainKey = vImageMain
            If mlIconCnt = 0 Then mlIconCnt = 1
        End If
    End If
errExit:
End Property

Public Property Get Key() As String
    Key = msKey
End Property

Public Property Let Key(ByVal sKey As String)
    Dim bIsInMainCol As Boolean
    Dim i As Long
    Dim cTmp As clsNode

    On Error GoTo errH

    If Tree Is Nothing Then
        msKey = sKey
        Exit Property
    ElseIf msKey = sKey Or Len(sKey) = 0 Then
        Exit Property
    End If

    On Error Resume Next
    Set cTmp = Tree.Nodes.Item(sKey)
    On Error GoTo errH

    If Not cTmp Is Nothing Then
        Err.Raise 457    ' standard duplicate key error
    End If

    ' to change the Key, remove Me and add Me back where it was with the new key
    For Each cTmp In Tree.Nodes
        i = i + 1
        If cTmp Is Me Then
            bIsInMainCol = True
            Exit For
        End If
    Next

    If bIsInMainCol Then
        With Tree.Nodes
            .Remove i
            If .count Then
                .Add Me, sKey, i
            Else
                .Add Me
            End If
        End With
    Else
        ' Let Key  called by via move/copy
    End If

    msKey = sKey

    Exit Property
errH:
    Err.Raise Err.Number, "Let Key", Err.Description
End Property

Public Property Get Level() As Long
    Dim lLevel As Long
    Dim cNode As clsNode

    On Error GoTo errH
    lLevel = -1
    Set cNode = Me.ParentNode
    While Not cNode Is Nothing
        lLevel = lLevel + 1
        Set cNode = cNode.ParentNode
    Wend
    Level = lLevel
    Exit Property
errH:
    #If DebugMode = 1 Then
        Stop
        Resume
    #End If
End Property

Public Property Get NextNode() As clsNode    ' can't name this proc 'Next' in VBA
' PT return the next sibling if there is one
    Dim i As Long
    Dim cNode As clsNode

    With Me.ParentNode
        For Each cNode In .ChildNodes
            i = i + 1
            If cNode Is Me Then
                Exit For
            End If
        Next
        If .ChildNodes.count > i Then
            Set NextNode = .ChildNodes(i + 1)
        End If
    End With
End Property

Public Property Get ParentNode() As clsNode
    Set ParentNode = moParentNode
End Property

Public Property Set ParentNode(oParentNode As clsNode)
    Set moParentNode = oParentNode
End Property

Public Property Get Previous() As clsNode
' PT return the previous sibling if there is one
    Dim i As Long
    Dim cNode As clsNode

    With Me.ParentNode
        For Each cNode In Me.ParentNode.ChildNodes
            i = i + 1
            If cNode Is Me Then
                Exit For
            End If
        Next
        If i > 1 Then
            Set NextNode = .ChildNodes(i - 1)
        End If
    End With
End Property

Public Property Get Root() As clsNode
    Dim cTmp As clsNode
    Set cTmp = Me
    Do While Not cTmp.ParentNode.ParentNode Is Nothing
        Set cTmp = cTmp.ParentNode
    Loop
    Set Root = cTmp
End Property

Public Property Get Tag()
    Tag = mvTag
End Property

Public Property Let Tag(vTag)
    mvTag = vTag
End Property


'*****************************
'* Public subs and functions *
'*****************************

Public Function Sort(Optional ByVal ndOrder As ndSortOrder = ndAscending, _
                     Optional ByVal ndCompare As ndCompareMethod = ndTextCompare) As Boolean
' PT Sorts the child nodes,
'    returns True if the order has changed to flag Refresh should be called
    Dim sCaptions() As String
    Dim lStart As Long, lLast As Long, i As Long
    Dim colNodes As New Collection
    Dim bIsUnSorted As Boolean

    On Error GoTo errExit
    lStart = 1
    lLast = ChildNodes.count    ' error if no childnodes to sort

    If lLast = 1 Then
        ' nothing to sort
        Exit Function
    End If

    ReDim idx(lStart To lLast) As Long
    ReDim sCaptions(lStart To lLast) As String
    For i = lStart To lLast
        idx(i) = i
        sCaptions(i) = ChildNodes.Item(i).Caption
    Next

    If ndOrder <> ndAscending Then ndOrder = -1    ' descending
    If ndCompare <> ndTextCompare Then ndCompare = ndBinaryCompare

    Call BinarySortIndexText(sCaptions(), lStart, lLast, idx, ndOrder, ndCompare)

    For i = lStart To lLast - 1
        If idx(i) <> idx(i + 1) - 1 Then
            bIsUnSorted = True
            Exit For
        End If
    Next

    If bIsUnSorted Then
        For i = lStart To lLast
            colNodes.Add ChildNodes(idx(i))
        Next
        Set ChildNodes = colNodes
        Sort = True
    End If

errExit:
'   Probably(?) any error was because there were no childnodes, no need to raise an error
End Function

Public Function AddChild(Optional sKey As String, _
                         Optional sCaption As String, _
                         Optional vImageMain, _
                         Optional vImageExpanded) As clsNode

    Dim cChild As clsNode

    On Error GoTo errH
    Set cChild = New clsNode

    With moTree.Nodes

        If Len(sKey) Then
100         Tree.Nodes.Add cChild, sKey
101
            cChild.Key = sKey
        Else
            Tree.Nodes.Add cChild
        End If

        cChild.Index = .count
    End With

    If mcolChildNodes Is Nothing Then
        Set mcolChildNodes = New Collection
    End If

    mcolChildNodes.Add cChild

    With cChild
        If Not IsMissing(vImageMain) Then
            If Len(vImageMain) Then
                .ImageMain = vImageMain
            End If
        End If

        If Not IsMissing(vImageExpanded) Then
            If Len(vImageExpanded) Then
                .ImageExpanded = vImageExpanded
            End If
        End If

        .Caption = sCaption

        Set .Tree = Tree
        Set .ParentNode = Me
    End With

    Set AddChild = cChild

    Exit Function
errH:
    #If DebugMode = 1 Then
        Stop
        Resume
    #End If

    If Erl = 100 And Err.Number = 457 Then
        Err.Raise vbObjectError + 1, "clsNode.AddChild", "Duplicate key: '" & sKey & "'"
    Else
        Err.Raise Err.Number, "clsNode.AddChild", Err.Description
    End If
End Function

Public Function ChildIndex(sKey As String) As Long
'-------------------------------------------------------------------------
' Procedure : ChildIndex
' Company   : JKP Application Development Services (c)
' Author    : Jan Karel Pieterse (www.jkp-ads.com)
' Created   : 15-01-2013
' Purpose   : Returns the index of a childnode using its key
'-------------------------------------------------------------------------
    Dim cNode As clsNode
    Dim lCt As Long
    For Each cNode In mcolChildNodes
        lCt = lCt + 1
        If sKey = cNode.Key Then
            ChildIndex = lCt
            Set cNode = Nothing
            Exit Function
        End If
    Next
    Set cNode = Nothing
End Function

Public Function FullPath() As String
' PT, get all the grand/parent keys
' assumes use of key

    Dim s As String
    Dim cNode As clsNode

    On Error GoTo errDone
    s = Me.Key
    Set cNode = Me

    While Err.Number = 0
        Set cNode = cNode.ParentNode
        s = cNode.Key & "\" & s
    Wend

errDone:
    FullPath = s
End Function

Public Function GetChild(vKey As Variant) As clsNode
'-------------------------------------------------------------------------
' Procedure : GetChild
' Company   : JKP Application Development Services (c)
' Author    : Jan Karel Pieterse (www.jkp-ads.com)
' Created   : 15-01-2013
' Purpose   : Returns a childnode using its key
'-------------------------------------------------------------------------
    Dim cNode As clsNode
    Dim lIdx As Long

    If VarType(vKey) = vbString Then

        For Each cNode In mcolChildNodes
            If vKey = cNode.Key Then
                Set GetChild = cNode
                Set cNode = Nothing
                Exit Function
            End If
        Next

    ElseIf Not mcolChildNodes Is Nothing Then
        lIdx = vKey
        If lIdx = -1 Then
            lIdx = mcolChildNodes.count
        End If
        If lIdx > 0 Then
            Set GetChild = mcolChildNodes(lIdx)
        Else: Set mcolChildNodes = Nothing
        End If
    End If

    Set cNode = Nothing
End Function


'*************************************************************************
'*    Friend Properties, Subs & Funtions                                 *
'*    ** these procedures are visible throughout the project but should  *
'*    ** only be used to communicate with the TreeView, ie clsTreeView   *
'*************************************************************************



'' PT new properties in 006PT2:
'' Created, CreatedButton, Checked, CheckBoxName, Index, VisIndex
''

Friend Property Get Control() As MSForms.Label
    Set Control = mctlControl
End Property

Friend Property Set Control(ctlControl As MSForms.Label)
    Set mctlControl = ctlControl
End Property

Friend Property Get Index() As Long    ' PT
    Index = mnIndex
End Property

Friend Property Let Index(idx As Long)
' PT Index: the order this node was added to Treeview's collection mcolNodes
'    Index will never increase but may decrement if previously added nodes are removed
    mnIndex = idx
End Property

Friend Property Let VisIndex(lVisIndex As Long)
    mlVisIndex = lVisIndex
End Property

Friend Property Get VisIndex() As Long    ' PT
    VisIndex = mlVisIndex
End Property

Friend Property Get Tree() As clsTreeView
    Set Tree = moTree
End Property

Friend Property Set Tree(oTree As clsTreeView)
    Set moTree = oTree
End Property

Friend Property Get Checkbox() As MSForms.Control
    Set Checkbox = mctlCheckBox
End Property

Friend Property Set Checkbox(oCtl As MSForms.Control)
    Set mctlCheckBox = oCtl
End Property

Friend Property Get Expander() As MSForms.Label
    Set Expander = mctlExpander
End Property

Friend Property Set Expander(ctlExpander As MSForms.Label)
    Set mctlExpander = ctlExpander
End Property

Friend Property Get ExpanderBox() As MSForms.Label
    Set ExpanderBox = mctlExpanderBox
End Property

Friend Property Set ExpanderBox(ctlExpanderBox As MSForms.Label)
    Set mctlExpanderBox = ctlExpanderBox
End Property

Friend Property Set HLine(ctlHLine As MSForms.Label)
    Set mctlHLine = ctlHLine
End Property

Friend Property Get HLine() As MSForms.Label
    Set HLine = mctlHLine
End Property

Friend Property Set Icon(ctlIcon As MSForms.Image)
    Set mctlIcon = ctlIcon
End Property

Friend Property Get Icon() As MSForms.Image
    Set Icon = mctlIcon
End Property

Friend Property Get TextWidth() As Single
    TextWidth = msngTextWidth
End Property

Friend Property Let TextWidth(sngTextWidth As Single)
    msngTextWidth = sngTextWidth
End Property

Friend Property Get VLine() As MSForms.Label
    Set VLine = mctlVLine
End Property

Friend Property Set VLine(ctlVLine As MSForms.Label)
    Set mctlVLine = ctlVLine
End Property

Friend Sub CheckTriStateParent()
' PT set triState value of parent according to its childnodes' values
Dim alChecked(-1 To 1) As Long
Dim cChild As clsNode

    For Each cChild In ChildNodes
        alChecked(cChild.Checked) = alChecked(cChild.Checked) + 1
    Next
    If alChecked(1) Then
        alChecked(1) = 1
    ElseIf alChecked(-1) = ChildNodes.count Then
        alChecked(1) = -1
    ElseIf alChecked(0) = ChildNodes.count Then
        alChecked(1) = 0
    Else
        alChecked(1) = 1
    End If
    If Checked <> alChecked(1) Then
        mlChecked = alChecked(1)
        UpdateCheckbox
    End If

    If Not ParentNode.ParentNode Is Nothing Then
        ParentNode.CheckTriStateParent
    End If

End Sub

Friend Sub CheckTriStateChildren(lChecked As Long)
' PT, make checked values of children same as parent's
'     only called if triState is enabled
Dim cChild As clsNode

    mlChecked = lChecked
    UpdateCheckbox

    If Not ChildNodes Is Nothing Then
        For Each cChild In ChildNodes
            cChild.CheckTriStateChildren lChecked
        Next
    End If
End Sub

Friend Function hasIcon(vKey) As Boolean
' PT get the appropriate icon key/index, if any
    If mlIconCnt = 2 And mbExpanded Then
        vKey = mvIconExpandedKey
        hasIcon = True    'Not IsEmpty(vKey) '(True
    ElseIf mlIconCnt Then
        vKey = mvIconMainKey
        hasIcon = True    'Not IsEmpty(vKey)
    End If
End Function

Friend Sub EditBox(bEnterEdit As Boolean)    '  PT new in 006PT2 ,,move to clsTreView
'-------------------------------------------------------------------------
' Procedure : moCtl_Click
' Author    : Peter Thornton
' Created   : 20-01-2013
' Purpose   : Enter/exit Editmode, show/hide the edit textbox
'-------------------------------------------------------------------------
    On Error Resume Next
    Set moEditBox = moTree.TreeControl.Controls("EditBox")
    On Error GoTo 0

    If bEnterEdit Then
    
        If moEditBox Is Nothing Then
            Set moEditBox = moTree.TreeControl.Controls.Add("forms.textbox.1", False)
            moEditBox.name = "EditBox"
        End If

        With moEditBox
            .Left = Control.Left - 3
            .Top = Control.Top - 1.5
            .AutoSize = True
            .BorderStyle = fmBorderStyleSingle
            .Text = Caption
            Control.Visible = False    ' hide the node label while editing
            .ZOrder 0
            .Visible = True
            .SelStart = 0
            .SelLength = Len(.Text)
            .SetFocus
        End With

    ElseIf Not moEditBox Is Nothing Then
        ' exit editmode
        If Not moEditBox Is Nothing Then
            ' error if moEditBox has already been removed
            On Error Resume Next
            moEditBox.Visible = False
            moEditBox.Text = ""
            Set moEditBox = Nothing
        End If
        Control.Visible = True

    End If
End Sub

Friend Function RemoveChild(cNode As clsNode) As Boolean
'PT remove a node from the collection,
'   note, this is only one part of the process of removing a node

    Dim lCt As Long
    Dim cTmp As clsNode
    On Error GoTo errH

    For Each cTmp In mcolChildNodes
        lCt = lCt + 1
        If cTmp Is cNode Then
            mcolChildNodes.Remove lCt
            RemoveChild = True
            Exit For
        End If
    Next

    If mcolChildNodes.count = 0 Then
        Set mcolChildNodes = Nothing
        Me.Expanded = False
    End If

    Exit Function
errH:
    Err.Raise vbObjectError, "RemoveChild", Err.Description
End Function

Friend Sub RemoveNodeControls()
    Dim cChild As clsNode
    If Not ChildNodes Is Nothing Then
        For Each cChild In ChildNodes
            cChild.RemoveNodeControls
        Next
    End If
    DeleteNodeControls False
End Sub

Friend Sub TerminateNode(Optional bDeleteNodeControls As Boolean)
'-------------------------------------------------------------------------
' Procedure : TerminateNode
' Company   : JKP Application Development Services (c)
' Author    : Jan Karel Pieterse (www.jkp-ads.com)
' Created   : 15-01-2013
' Purpose   : Terminates the class instance
'-------------------------------------------------------------------------
    Dim cChild As clsNode
    'Instead of the Terminate event of the class we use this public
    'method so it can be explicitly called by parent classes.
    'This is done because to break the two way or circular references
    'between the parent child classes.
    
    'The most important call in this routine is to destroy the reference
    'between this node class and the parent treeview class -
    '    < Set moTree = Nothing >
    'Once all the moTree references to have been destroyed everything else will
    ' 'tear down' normally

    If Not ChildNodes Is Nothing Then
        For Each cChild In ChildNodes
            ' recursively drill down to all child nodes in this branch
            cChild.TerminateNode bDeleteNodeControls
        Next
    End If

    ' If deleting individual nodes while the treeview is running we also want to
    ' remove all associated controls as well as removing references
    
    If bDeleteNodeControls Then
        DeleteNodeControls True
        If bDeleteNodeControls Then
            Index = -1
        End If
    End If

    Set mcolChildNodes = Nothing
    Set moTree = Nothing
End Sub

'End Function

'******************************
'* Private subs and functions *
'******************************

Private Sub BinarySortIndexText(sCaptions() As String, ByVal lStart As Long, ByVal lEnd As Long, ByRef idx() As Long, ndOrder As Long, ndCompare As ndCompareMethod)
' PT sorts the index array based on the string array
    Dim lSmall As Long, lLarge As Long, sMid As String, lTmp As Long

    lSmall = lStart
    lLarge = lEnd
    sMid = sCaptions(idx((lSmall + lLarge) / 2))

    Do While lSmall <= lLarge
        Do While (StrComp(sCaptions(idx(lSmall)), sMid, ndCompare) = -ndOrder And lSmall < lEnd)
            lSmall = lSmall + 1
        Loop
        Do While (StrComp(sCaptions(idx(lLarge)), sMid, ndCompare) = ndOrder And lLarge > lStart)
            lLarge = lLarge - 1
        Loop
        If lSmall <= lLarge Then
            lTmp = idx(lSmall)
            idx(lSmall) = idx(lLarge)
            idx(lLarge) = lTmp
            lSmall = lSmall + 1
            lLarge = lLarge - 1
        End If
    Loop

    If lStart <= lLarge Then
        Call BinarySortIndexText(sCaptions(), lStart, lLarge, idx, ndOrder, ndCompare)
    End If
    If lSmall <= lEnd Then
        Call BinarySortIndexText(sCaptions(), lSmall, lEnd, idx, ndOrder, ndCompare)
    End If
End Sub

Private Sub DeleteNodeControls(bClearIndex As Boolean)
'PT Delete all controls linked to this node

    On Error GoTo errH
    
    With moTree.TreeControl.Controls
        If Not mctlControl Is Nothing Then
            .Remove mctlControl.TabIndex
            Set mctlControl = Nothing
            If Not mctlHLine Is Nothing Then
                .Remove mctlHLine.TabIndex
            End If
            Set mctlHLine = Nothing
            If Not mctlIcon Is Nothing Then
                .Remove mctlIcon.TabIndex
                Set mctlIcon = Nothing
            End If
        End If

        If Not mctlExpander Is Nothing Then
            .Remove mctlExpander.TabIndex
            Set mctlExpander = Nothing
            If Not mctlExpanderBox Is Nothing Then
                .Remove mctlExpanderBox.TabIndex
                Set mctlExpanderBox = Nothing
            End If
            If Not mctlVLine Is Nothing Then
                .Remove mctlVLine.TabIndex
                Set mctlVLine = Nothing
            End If
        End If

        If Not moEditBox Is Nothing Then
            .Remove moEditBox.TabIndex
            Set moEditBox = Nothing
        End If
        If Not mctlCheckBox Is Nothing Then
            .Remove mctlCheckBox.TabIndex
            Set mctlCheckBox = Nothing
        End If

        If Not Me.ParentNode Is Nothing Then
            ' if Me is the last child delete parent's expander and VLine (if it has one)
            If FirstSibling Is LastSibling Then

                If Not Me.ParentNode.VLine Is Nothing Then
                    .Remove Me.ParentNode.VLine.TabIndex
                    Set Me.ParentNode.VLine = Nothing
                End If
                If Not Me.ParentNode.ExpanderBox Is Nothing Then
                    .Remove Me.ParentNode.ExpanderBox.TabIndex
                    Set Me.ParentNode.ExpanderBox = Nothing
                End If

                .Remove Me.ParentNode.Expander.TabIndex
                Set Me.ParentNode.Expander = Nothing

                Me.ParentNode.Expanded = False

            End If

        End If

    End With

    If bClearIndex Then
        Me.Index = -1  ' flag this node to be removed from mcolNodes in NodeRemove
    End If

    Exit Sub
errH:
    ' Stop
    Resume Next
End Sub

Private Function UpdateCheckbox()
Dim pic As StdPicture
    If Not mctlCheckBox Is Nothing Then
        With mctlCheckBox
            If moTree.GetCheckboxIcon(mlChecked, pic) Then
                .Picture = pic
            Else
                .Caption = IIf(mlChecked, "a", "")
                If (mlChecked = 1) <> (.ForeColor = RGB(180, 180, 180)) Then
                    .ForeColor = IIf(mlChecked = 1, RGB(180, 180, 180), vbWindowText)
                End If
            End If
        End With
    End If
End Function

Private Sub UpdateExpanded(bControlOnly As Boolean)
'-------------------------------------------------------------------------
' Procedure : UpdateExpanded
' Author    : Peter Thornton
' Created   : 27-01-2013
' Purpose   : Called via an Expander click or arrow keys
'             Updates the Expanded property and changes +/- caption
'-------------------------------------------------------------------------
    Dim bFullWidth As Boolean
    Dim vKey
    Dim pic As StdPicture

    If Not bControlOnly Then
        With Me.Expander
            If moTree.GetExpanderIcon(mbExpanded, pic) Then
                .Picture = pic
            Else
                If mbExpanded Then
                    .Caption = "-"
                Else
                    .Caption = "+"
                End If
            End If
        End With
    End If

    On Error GoTo errExit
    If Me.hasIcon(vKey) Then
        If moTree.GetNodeIcon(vKey, pic, bFullWidth) Then
            If bFullWidth Then
                Me.Icon.Picture = pic   ' potential error if Icon is nothing, let error abort
            Else
                Me.Control.Picture = pic
            End If
        End If
    End If
errExit:
End Sub


'***********************
'*   Node Events       *
'***********************

Private Sub mctlCheckBox_Click()    ' PT new in 006PT2
'-------------------------------------------------------------------------
' Procedure : moCtl_Click
' Author    : Peter Thornton
' Created   : 20-01-2013
' Purpose   : Event fires when a Checkbox label is clicked
'-------------------------------------------------------------------------
    If moTree.EditMode(Me) Then
        ' exit editmode if in editmode
        moTree.EditMode(Me) = False
    End If
    If mlChecked = 0 Then
    
        Checked = -1
    Else
        Checked = 0
    End If
    moTree.NodeClick mctlCheckBox, Me    ' share the checkbox click event
End Sub

Private Sub mctlControl_Click()
'-------------------------------------------------------------------------
' Procedure : mctlControl_Click
' Company   : JKP Application Development Services (c)
' Author    : Jan Karel Pieterse (www.jkp-ads.com)
' Created   : 15-01-2013
' Purpose   : Event fires when a treebranch is clicked
'-------------------------------------------------------------------------

' PT handle enter & exit EditMode

    If moTree.ActiveNode Is Nothing Then
        Set moTree.ActiveNode = Me
    End If

    If moTree.EditMode(Me) Then
        ' if some other node is in edit mode, or this node's expander clicked, exit edit mode
        moTree.EditMode(Me) = False
    End If

    If moTree.ActiveNode Is Me Then
        ' don't raise the click event if the node was already selected
    Else
        moTree.NodeClick Control, Me    ' PT NodeClick can be called in moTree.ActiveNode ?
    End If
End Sub

Private Sub mctlControl_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
' PT  a node label has been double-clicked, so enter edit mode
    Dim bAutoSort As Boolean
    
        If moTree.LabelEdit(bAutoSort) <> 0 Then
            ' exit if editing is disabled
        Else
            moTree.EditMode(Me) = True
            EditBox bEnterEdit:=True
        End If

End Sub

Private Sub mctlExpander_Click()
    Expanded = Not Expanded

    Tree.NodeClick Expander, Me
End Sub

Private Sub moEditBox_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)    'PT
' PT Textbox key events to Enter or Esc the Editbox,   006PT2

    Dim bCancel As Boolean
    Dim bSort As Boolean
    Dim sNewText As String

    If KeyCode = vbKeyReturn Then
        sNewText = moEditBox.Value
        If sNewText = Caption Then
            KeyCode = vbKeyEscape
        Else
            bCancel = moTree.RaiseAfterLabelEdit(Me, sNewText)
            If Not bCancel Then
                Me.Caption = moEditBox.Value
                Control.Caption = sNewText

                Control.AutoSize = True
                TextWidth = Control.Width
                Control.AutoSize = False
                If TextWidth < mcFullWidth And moTree.FullWidth Then
                    Control.Width = mcFullWidth
                End If
                moTree.Changed = True
                moTree.NodeClick Control, Me
                bCancel = moTree.LabelEdit(bSort)
                If bSort Then
                    If Me.ParentNode.Sort Then
                        moTree.Refresh
                    End If
                End If
            End If
            EditBox False
        End If
    End If
    If KeyCode = vbKeyEscape Then
        moTree.EditMode(Me) = False
        EditBox False
    End If
End Sub

Private Sub Class_Initialize()
' default properties
    mbExpanded = True  ' default
    
    #If DebugMode = 1 Then
        gClsNodeInit = gClsNodeInit + 1    ' PT, for testing only, remove, see ClassCounts() in the normal module
    #End If
End Sub

Private Sub Class_Terminate()
    #If DebugMode = 1 Then
        gClsNodeTerm = gClsNodeTerm + 1    ' PT, for testing,
    #End If
    Set moTree = Nothing
End Sub

Attribute VB_Name = "clsTreeView"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'Build 021
'***************************************************************************
'
' Authors:  JKP Application Development Services, info@jkp-ads.com, http://www.jkp-ads.com
'           Peter Thornton, pmbthornton@gmail.com
'
' (c)2013, all rights reserved to the authors
'
' You are free to use and adapt the code in these modules for
' your own purposes and to distribute as part of your overall project.
' However all headers and copyright notices should remain intact
'
' You may not publish the code in these modules, for example on a web site,
' without the explicit consent of the authors
'***************************************************************************

'-------------------------------------------------------------------------
' Module    : clsTreeView
' Company   : JKP Application Development Services (c)
' Author    : Jan Karel Pieterse (www.jkp-ads.com)
' Created   : 15-01-2013
' Purpose   : Creates a VBA Treeview control in a frame on your UserForm
'-------------------------------------------------------------------------
Option Explicit

Public WithEvents TreeControl As MSForms.Frame    'JKP: The parent/container control in which the VBA treeview is created
Attribute TreeControl.VB_VarHelpID = -1

Private mbAlwaysRedesign As Boolean    'PT temporary flag to force mbRedesign=true, see Move()
Private mbAutoSort As Boolean       'PT sort siblings after manual edit
Private mbChanged As Boolean        'PT "dirty", user has edited node(s)
Private mbCheckboxes As Boolean     'PT show checkboxes
Private mbTriState As Boolean       'PT enable tripple state checkboxes
Private mbCheckboxImage As Boolean  'PT determins if icons are used for checkboxes
Private mbEditMode As Boolean       'PT flag if in editmode
Private mbFullWidth As Boolean      'PT use separate image controls for icons, can highlight nodes to full width
Private mbGotIcons As Boolean       'PT got a collection of images
Private mbExpanderImage As Boolean  'PT determines if icons will be used for collapse/expand controls
Private mbKeyDown As Boolean        'PT Enter-keyup in a Textbox occurs when next control gets focus
Private mbMove As Boolean           'PT flag intention of the MoveCopyNode
Private mbRedesign As Boolean       'PT flag to reset all dim's after changing NodeHeight or Indentation at runtime
Private mbRootButton As Boolean     'PT Root has an expander button
Private mbShowExpanders As Boolean  'PT Show +/- buttons
Private mbShowLines As Boolean      'PT determines if lines will be created and shown
Private mlBackColor As Long         'PT frameholder's backcolor
Private mlForeColor As Long         'PT frameholder's ForeColor
Private mlLabelEdit As Long         'PT 0-Automatic, 1-Manual can't be edited
Private mlNodesCreated As Long      'PT in/de-cremented as nodes are added/deleted from mcolNodes
Private mlVisCount As Long          'PT incremented from zero as each node is displayed
Private mlVisOrder() As Long        'PT an index array to identify displayed nodes in the order as displayed
Private msAppName As String         'JKP: Title of messageboxes
Private msngChkBoxPad As Single     'PT offset if using checkboxes
Private msngChkBoxSize As Single    'PT checkbox size
Private msngIndent As Single        'PT default 15
Private msngLineLeft As Single      'PT Left pos of Root H & V lines, 3 + alpha
Private msngNodeHeight As Single    'JKP: vertical distance between nodes
Private msngRootLine As Single      'PT if mbRootButton, same as msngIndent, else 0
Private msngTopChk As Single        'PT top checkbox  (these "tops" are offsets down from the top a given node)
Private msngTopExpB As Single       'PT top expander button (a label)
Private msngTopExpT As Single       'PT top expander text (a label)
Private msngTopHV As Single         'PT top for Horiz' & Vert' lines (mid height of a node + top padding))
Private msngTopIcon As Single       'PT top icon
Private msngTopLabel As Single      'PT top node label, if font height less than NodeHeight
Private msngVisTop As Single        'PT activenode top relative to scroll-top
Private msngMaxWidths() As Single   'PT array, max width of text in each level, helps determine scroll-width
Private moActiveNode As clsNode     'JKP: refers to the selected node
Private moEditNode As clsNode       'PT the node in EditMode
Private moMoveNode As clsNode       'PT node waiting to be moved
Private moMoveNodes As Collection
Private moRootHolder As clsNode     'PT parent for the root node(s), although a clsNode it's not a real node
Private mcolIcons As Collection     'PT collection of stdPicture objects, their names as keys
Private mcolNodes As Collection     'JKP: global collection of all the nodes
Private moCheckboxImage(-1 To 1) As StdPicture   'PT checkbox true/false/triState icons
Private moExpanderImage(-1 To 0) As StdPicture   'PT collapse/expand icons

''-----------------------------------------------------------

'Public Enum tvMouse
'    tvDown = 1
'    tvUp = 2
'    tvMove = 3
'    tvBeforeDragOver = 4
'    tvBeforeDropOrPaste = 5
'End Enum

Public Enum tvTreeRelationship
    tvFirst = 0
    tvLast = 1
    tvNext = 2
    tvPrevious = 3
    tvChild = 4
End Enum

Event Click(cNode As clsNode)       'Node clcick event
Event NodeCheck(cNode As clsNode)   'Checkbox change event
Event AfterLabelEdit(ByRef Cancel As Boolean, NewString As String, cNode As clsNode)
Event KeyDown(cNode As clsNode, ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)

Private Type POINTAPI
    x As Long
    Y As Long
End Type

#If VBA7 And Not Mac Then
    Private Declare PtrSafe Function GetCursorPos Lib "user32.dll" ( _
            ByRef lpPoint As POINTAPI) As Long
    Private Declare PtrSafe Function SetCursorPos Lib "user32.dll" ( _
            ByVal x As Long, _
            ByVal Y As Long) As Long
    Private Declare PtrSafe Function getTickCount Lib "kernel32.dll" Alias "GetTickCount" () As Long
#Else
    Private Declare Function GetCursorPos Lib "user32.dll" ( _
                                          ByRef lpPoint As POINTAPI) As Long
    Private Declare Function SetCursorPos Lib "user32.dll" ( _
                                          ByVal x As Long, _
                                          ByVal Y As Long) As Long
    Private Declare Function getTickCount Lib "kernel32.dll" Alias "GetTickCount" () As Long
#End If

' Mac displays at 72 pixels per 72 points vs (typically) 96/72 in Windows
' The respective constants help size and position node controls appropriatelly in the different OS
' Search the project for instances of the Mac constant

#If Mac Then
    Const mcCheckboxFont As Long = 13
    Const mcCheckboxPad As Single = 19
    Const mcCheckboxPadImg As Single = 15
    Const mcChkBoxSize As Single = 13
    Const mcExpanderFont As Long = 13
    Const mcExpButSize As Single = 15
    Const mcExpBoxSize As Long = 12
    Const mcFullWidth As Long = 800
    Const mcIconPad As Single = 17
    Const mcIconSize As Long = 16
    Const mcTLpad As Long = 4
    Const mcLineLeft As Single = mcTLpad + 10
    Const mcPtPxl As Single = 1
#Else
    Const mcCheckboxFont As Long = 10
    Const mcCheckboxPad As Single = 15
    Const mcCheckboxPadImg As Single = 11.25
    Const mcChkBoxSize As Single = 10.5
    Const mcExpanderFont As Long = 10
    Const mcExpButSize As Single = 11.25
    Const mcExpBoxSize As Long = 9
    Const mcFullWidth As Long = 600
    Const mcIconPad As Single = 13.5
    Const mcIconSize As Long = 12
    Const mcTLpad As Long = 3
    Const mcLineLeft As Single = mcTLpad + 7.5
    Const mcPtPxl As Single = 0.75
#End If

Private Const mcSource As String = "clsTreeView"

'***************************
'*    Public Properties    *
'***************************

Public Property Get ActiveNode() As clsNode
    Set ActiveNode = moActiveNode
End Property

Public Property Set ActiveNode(oActiveNode As clsNode)
'-------------------------------------------------------------------------
' Procedure : ActiveNode
' Company   : JKP Application Development Services (c)
' Author    : Jan Karel Pieterse (www.jkp-ads.com)
' Created   : 17-01-2013
' Purpose   : Setting the activenode also updates the node colors
'             and ensures the node is scrolled into view
'-------------------------------------------------------------------------
'PT nothing left of the original!

    Dim cTmp As clsNode
    If oActiveNode Is MoveCopyNode(False) Then
        Set MoveCopyNode(False) = Nothing
    End If

    ResetActiveNodeColor ActiveNode

    If oActiveNode.Control Is Nothing Then
        Set cTmp = oActiveNode.ParentNode
        While Not cTmp.Caption = "RootHolder"
            cTmp.Expanded = True
            Set cTmp = cTmp.ParentNode
        Wend
        BuildRoot False
    End If

    Set moActiveNode = oActiveNode
    SetActiveNodeColor

End Property

Public Sub ExpandNode(cNode As clsNode)
    Dim cTmp As clsNode

    Set cTmp = cNode.ParentNode
    While Not cTmp.Caption = "RootHolder"
        cTmp.Expanded = True
    Wend
    
End Sub

Public Property Get AppName() As String
    AppName = msAppName
End Property

Public Property Let AppName(ByVal sAppName As String)
    msAppName = sAppName
End Property

Public Property Get Changed() As Boolean    ' PT
'PT user has edited node(s)
    Changed = mbChanged
End Property

Public Property Let Changed(ByVal bChanged As Boolean)    ' PT
    Dim msgChangedRight As Single
    mbChanged = bChanged
    If Not ActiveNode Is Nothing Then
        msgChangedRight = ActiveNode.Control.Left + ActiveNode.TextWidth + 15
        With Me.TreeControl

            If msgChangedRight > .Width Then

                If .ScrollBars > fmScrollBarsHorizontal Then
                    .ScrollBars = fmScrollBarsBoth
                Else
                    .ScrollBars = fmScrollBarsHorizontal
                End If

                .ScrollWidth = msgChangedRight + 15
                .Scroll fmScrollActionEnd
            End If
        End With
    End If

End Property

Public Property Get CheckBoxes(Optional bTriState As Boolean) As Boolean    ' PT
    CheckBoxes = mbCheckboxes
    bTriState = mbTriState
End Property

Public Property Let CheckBoxes(Optional bTriState As Boolean, ByVal bCheckboxes As Boolean)   ' PT
    Dim bOrig As Boolean
    Dim bOrigTriState As Boolean

    bOrig = mbCheckboxes
    mbCheckboxes = bCheckboxes

    bOrigTriState = mbTriState
    mbTriState = bTriState
    If bCheckboxes Then
        msngChkBoxPad = mcCheckboxPad
        If msngNodeHeight < mcExpButSize Then msngNodeHeight = mcExpButSize
    Else
        msngChkBoxPad = 0
    End If

    If Not TreeControl Is Nothing Then

        If TreeControl.Controls.count And (bOrig <> mbCheckboxes Or bOrigTriState <> mbTriState) Then
            ' Checkboxes added changed after start-up so update the treeview
            mbRedesign = True
            Refresh
        End If
    End If

End Property

Public Property Get FullWidth() As Boolean
    FullWidth = mbFullWidth
End Property

Public Property Let FullWidth(bFullWidth As Boolean)
    mbFullWidth = bFullWidth
End Property

Public Property Set Images(objImages As Object)
    Dim pic As stdole.StdPicture    ' As Object
    Dim obj As Object
    ' PT  objImages can be a collection of image handles
    '     a Frame containing only Image controls (or controls with an image handle)
    '     stdole.IPictureDisp or stdole.StdPicture  objects
    On Error GoTo errH
    If TypeName(objImages) = "Collection" Then
        Set mcolIcons = objImages
        For Each pic In mcolIcons
            ' if not a valid picture let the error abort

        Next
    Else
        Set mcolIcons = New Collection
        For Each obj In objImages.Controls
            mcolIcons.Add obj.Picture, obj.name
        Next
    End If

    ' Flag we have a valid collection of images
    mbGotIcons = mcolIcons.count >= 1
    Exit Property
errH:
    Set mcolIcons = Nothing
    ' Err.Raise vbObjectError, "Invalid picture object in Images"
    ' Debug.Print Err.Description
End Property

Public Property Get Indentation() As Single
    Indentation = msngIndent
End Property

Public Property Let Indentation(sngIndent As Single)
    Dim cNode As clsNode
    Dim sngOld As Single

    sngOld = msngIndent

    #If Mac Then
        If sngIndent < 16 Then
            msngIndent = 16    ' min indent ?
        ElseIf sngIndent > 80 Then
            msngIndent = 80    ' max indent
        Else
            msngIndent = Int(sngIndent)
        End If
    #Else
        If sngIndent < 12 Then
            msngIndent = 12    ' min indent ?
        ElseIf sngIndent > 60 Then
            msngIndent = 60    ' max indent
        Else
            msngIndent = Int((sngIndent * 2 + mcPtPxl) / 3 * 2) * mcPtPxl
        End If
    #End If

    If mbRootButton Then msngRootLine = msngIndent

    If Not TreeControl Is Nothing And Not (sngOld = msngIndent) Then
        ' changed after start-up so update the treview
        If TreeControl.Controls.count Then
            Set cNode = Me.ActiveNode
            Refresh
            If Not cNode Is Nothing Then
                Set ActiveNode = cNode
            End If
        End If
    End If
End Property

Public Property Get LabelEdit(Optional bAutoSort As Boolean) As Long    ' PT
' PT,  equivalent to Treeview.LabelEdit
' 0/tvwAutomatic nodes can be manually edited
' optional bAutoSort: automatically resort siblings after a manual edit
    LabelEdit = mlLabelEdit
    bAutoSort = mbAutoSort
End Property

Public Property Let LabelEdit(Optional bAutoSort As Boolean, ByVal nLabelEdit As Long)    ' PT
    mlLabelEdit = nLabelEdit
    mbAutoSort = bAutoSort
End Property

Public Property Get MoveCopyNode(Optional bMove As Boolean, Optional lColor As Long) As clsNode
    bMove = mbMove
    Set MoveCopyNode = moMoveNode
End Property
Public Property Set MoveCopyNode(Optional bMove As Boolean, Optional lColor As Long, cNode As clsNode)
    Static lOrigBackcolor As Long

    mbMove = bMove
    If lColor = 0 Then
        If bMove Then
            lColor = RGB(255, 231, 162)
        Else: lColor = RGB(159, 249, 174)
        End If
    End If

    If Not moMoveNode Is Nothing Then
        moMoveNode.BackColor = lOrigBackcolor
        moMoveNode.Control.BackColor = lOrigBackcolor
        Set moMoveNode = Nothing
    Else

    End If

    If Not cNode Is Nothing Then
        lOrigBackcolor = cNode.BackColor
        If lOrigBackcolor = 0 Then lOrigBackcolor = mlBackColor
        cNode.BackColor = lColor

        cNode.Control.BackColor = cNode.BackColor
        cNode.Control.ForeColor = cNode.ForeColor
        Set moMoveNode = cNode
    Else

    End If
End Property

'Public Property Get MultiSelect() As Boolean
'    MultiSelect = mbMultiSelect
'End Property
'Public Property Let MultiSelect(mbMultiSelect As Boolean)
'    mbMultiSelect = MultiSelect
'End Property

Public Property Get NodeHeight() As Single
    If msngNodeHeight = 0 Then msngNodeHeight = 12
    NodeHeight = msngNodeHeight
End Property

Public Property Let NodeHeight(ByVal sngNodeHeight As Single)
    Dim cNode As clsNode
    Dim sngOld As Single

    sngOld = msngNodeHeight

    #If Mac Then
        If sngNodeHeight < 12 Then  ' height of expander-box is 9
            msngNodeHeight = 12
        ElseIf sngNodeHeight > 60 Then
            msngNodeHeight = 60
        Else
            msngNodeHeight = Int(sngNodeHeight)
        End If
    #Else
        If sngNodeHeight < 9 Then  ' height of expander-box is 9
            msngNodeHeight = 9
        ElseIf sngNodeHeight > 45 Then
            msngNodeHeight = 45
        Else
            msngNodeHeight = Int((sngNodeHeight * 2 + mcPtPxl) / 3 * 2) * mcPtPxl
        End If

    #End If
    If mbRootButton Then msngRootLine = msngIndent
    If Not TreeControl Is Nothing And Not (sngOld = msngNodeHeight) Then
        If TreeControl.Controls.count Then
            Set cNode = Me.ActiveNode
            Refresh
            If Not cNode Is Nothing Then
                Set ActiveNode = cNode
            End If
        End If
    End If
End Property

Public Property Get Nodes() As Collection
' Global collection of the nodes
' *DO NOT USE* its Nodes.Add and Nodes.Remove methods
' To add & remove nodes use clsNode.AddChild() or clsTreeView.NodeAdd and clsTeevView.NodeRemove()
    If mcolNodes Is Nothing Then Set mcolNodes = New Collection
    Set Nodes = mcolNodes
End Property

Public Property Get RootButton() As Boolean
    If mbRootButton Then RootButton = 1
End Property

Public Property Let RootButton(lRootLeader As Boolean)
' PT The Root nodes have expanders and lines (if mbShowlines)

    mbRootButton = lRootLeader
    If mbRootButton Then
        msngRootLine = msngIndent
    Else
        msngRootLine = 0
    End If

    If Not Me.TreeControl Is Nothing Then
        If Not moRootHolder Is Nothing Then
            If Not moRootHolder.ChildNodes Is Nothing Then
                Refresh
            End If
        End If
    End If
End Property

Public Property Get RootNodes() As Collection
'PT returns the collection of Root-nodes
' **should be treated as read only. Use AddRoot and NodeRemove to add/remove a root node**
    Set RootNodes = moRootHolder.ChildNodes
End Property

Public Property Get ShowExpanders() As Boolean
    ShowExpanders = mbShowExpanders
End Property

Public Property Let ShowExpanders(bShowExpanders As Boolean)

    mbShowExpanders = bShowExpanders
    
    If Not TreeControl Is Nothing Then
        If TreeControl.Controls.count Then
            Refresh
        End If
    End If
End Property

Public Property Get ShowLines() As Boolean
    ShowLines = mbShowLines
End Property

Public Property Let ShowLines(bShowLines As Boolean)
' PT Show horizontal & vertical lines
Dim bOrig As Boolean
Dim cNode As clsNode

    bOrig = mbShowLines
    mbShowLines = bShowLines

    If Not TreeControl Is Nothing Then
        If TreeControl.Controls.count Then
            If mbShowLines Then
                ' normally ShowLines = True is only done at startup
                ' but to handle if done while running ...
                For Each cNode In Nodes
                    If Not cNode.Control Is Nothing Then
                        If cNode.HLine Is Nothing Then
                            Set cNode.HLine = TreeControl.Controls.Add("Forms.label.1", "HLine", False)
                            With cNode.HLine
                                .Width = msngIndent
                                .Height = mcPtPxl
                                .Caption = ""
                                .BorderStyle = fmBorderStyleSingle
                                .BorderColor = vbScrollBars
                                .ZOrder 1
                                .Visible = True
                            End With
                        End If
                    End If
                Next
            End If
            If bOrig <> mbShowLines Then
                ' ShowLines added after start-up so update the treeview
                Refresh
            End If
        End If
    End If

End Property

'***********************************
'*    Public functions and subs    *
'***********************************

Public Function AddRoot(Optional sKey As String, Optional sCaption As String, Optional vImageMain, Optional vImageExpanded) As clsNode

    On Error GoTo errH

    If moRootHolder Is Nothing Then
        Set moRootHolder = New clsNode
        Set moRootHolder.ChildNodes = New Collection
        Set moRootHolder.Tree = Me
        moRootHolder.Caption = "RootHolder"
        If mcolNodes Is Nothing Then
            Set mcolNodes = New Collection
        End If
    End If

    Set AddRoot = moRootHolder.AddChild(sKey, sCaption, vImageMain, vImageExpanded)

    Exit Function
errH:
    #If DebugMode = 1 Then
        Stop
        Resume
    #End If
End Function

Public Sub CheckboxImage(picFalse As StdPicture, picTrue As StdPicture, Optional picTriState As StdPicture)
    On Error GoTo errExit:
    Set moCheckboxImage(0) = picFalse
    Set moCheckboxImage(-1) = picTrue
    If Not IsMissing(picTriState) Then
        Set moCheckboxImage(1) = picTriState
    End If

    mbCheckboxImage = True
errExit:
End Sub

Public Sub ExpanderImage(picMinus As StdPicture, picPlus As StdPicture)
    On Error GoTo errExit:
    Set moExpanderImage(0) = picPlus
    Set moExpanderImage(-1) = picMinus
    mbExpanderImage = True
errExit:
End Sub

Public Sub ExpandToLevel(lExpansionLevel As Long, Optional bReActivate As Boolean = True)
' PT call SetTreeExpansionLevel and reactivates the closest expanded parent if necessary
'    eg, if activeNode.level = 4 and lExpansionLevel = 2, the activenode's grandparent will be activated
    Dim cTmp As clsNode

    Call SetTreeExpansionLevel(lExpansionLevel - 1)

    If bReActivate Then
        If ActiveNode.Level > lExpansionLevel Then
            Set cTmp = ActiveNode.ParentNode
            While cTmp.Level > lExpansionLevel
                Set cTmp = cTmp.ParentNode
            Wend
            Set ActiveNode = cTmp
        End If
    End If
    
End Sub

Public Sub Copy(cSource As clsNode, cDest As clsNode, _
                Optional vBefore, Optional ByVal vAfter, _
                Optional ByVal bShowError As Boolean)
                
    Set MoveCopyNode(False) = Nothing
    Clone cDest, cSource, vBefore, vAfter
    SetActiveNodeColor
End Sub

Public Sub Move(cSource As clsNode, cDest As clsNode, _
                Optional vBefore, Optional ByVal vAfter, _
                Optional ByVal bShowError As Boolean)
' PT Move source node + children to destination node
'    cannot move the Root and cannot move to a descendent
'   vBefore/vAfter work as for normal collection; error if invalid, eg a new collection, after the last item, etc
'
    Dim sErrDesc As String
    Dim bIsParent As Boolean
    Dim cNode As clsNode

    Set MoveCopyNode(False) = Nothing
    On Error GoTo errH

    'If cSource Is Nothing Or cDest Is Nothing Or cSource Is cDest Or cSource Is Root Then
    If cSource Is Nothing Or cDest Is Nothing Or cSource Is cDest Then
        Exit Sub
    End If

    Set cNode = cDest
    bIsParent = False
    Do
        Set cNode = cNode.ParentNode
        bIsParent = cNode Is cSource
    Loop Until cNode Is Nothing Or bIsParent

    If bIsParent Then
        Err.Raise vbObjectError + 110
    End If

    If cDest.ChildNodes Is Nothing Then
        ' the child becomes a parent for the first time
        Set cDest.ChildNodes = New Collection
        ' expander & VLine will get created automatically if necessary
    End If

    AddNodeToCol cDest.ChildNodes, cSource, False, vBefore, vAfter

    With cSource.ParentNode

        .RemoveChild cSource '
        ' if the old parent has no more children remove its expander & VLine

        If .ChildNodes Is Nothing Then

            If Not .Expander Is Nothing Then
                Me.TreeControl.Controls.Remove .Expander.TabIndex
                Set .Expander = Nothing
            End If

            If Not .ExpanderBox Is Nothing Then
                Me.TreeControl.Controls.Remove .ExpanderBox.TabIndex
                Set .ExpanderBox = Nothing
            End If

            If Not .VLine Is Nothing Then
                Me.TreeControl.Controls.Remove .VLine.TabIndex
                Set .VLine = Nothing
            End If

            .Expanded = False

        End If
    End With

    Set cSource.ParentNode = cDest
    cDest.Expanded = True
    
    If mbTriState Then
        cDest.CheckTriStateParent
    End If
    
    '    mbAlwaysRedesign = True    ' temporary kludge to always reposition .Left's during future refresh

    Exit Sub
errH:

    Select Case Err.Number
    Case vbObjectError + 110
        sErrDesc = "Cannot move Node to a descendent"
    Case Else
        sErrDesc = "Move: " & Err.Description
    End Select

    If bShowError Then
        MsgBox sErrDesc, , AppName
    Else
        Err.Raise Err.Number, mcSource, "Move: " & sErrDesc
    End If

End Sub

Public Function NodeAdd(Optional vRelative, _
                        Optional vRelationship, _
                        Optional sKey As String, _
                        Optional sCaption As String, _
                        Optional vImageMain, _
                        Optional vImageExpanded) As clsNode    '  As tvTreevRelationship

'PT, similar to the old tv's nodes.add method
'    main difference is vRelative can be a Node object as well as a key or index
'    see also clsNode.AddChild

    Dim i As Long
    Dim cNode As clsNode
    Dim cRelative As clsNode
    Dim cParent As clsNode
    Dim cTmp As clsNode
    '    tvFirst = 0  tvlast = 1 tvNext = 2 tvprevious = 3  tvChild = 4

    If IsMissing(vRelative) Then

        Set NodeAdd = Me.AddRoot(sKey, sCaption, vImageMain, vImageExpanded)
        Exit Function
    Else

        On Error Resume Next
        Set cRelative = vRelative
        If cRelative Is Nothing Then
            Set cRelative = mcolNodes(vRelative)
        End If

        On Error GoTo errH
        If cRelative Is Nothing Then
            Err.Raise vbObjectError + 100, "NodeAdd", "vRelative is not a valid node or a node.key"
        End If
    End If

    If IsMissing(vRelationship) Then
        vRelationship = tvTreeRelationship.tvNext    ' default
    End If

    If vRelationship = tvChild Or cRelative Is cRelative.Root Then
        Set cParent = cRelative
    Else
        Set cParent = cRelative.ParentNode
    End If

    Set cNode = New clsNode

    If Len(sKey) Then
100     mcolNodes.Add cNode, sKey
101
    Else
        mcolNodes.Add cNode
    End If

    If cParent.ChildNodes Is Nothing Then
        Set cParent.ChildNodes = New Collection
    End If

    With cParent.ChildNodes
        If .count = 0 Then
            .Add cNode
        Else
            i = 0
            If vRelationship = tvNext Or vRelationship = tvPrevious Then
                For Each cTmp In cParent.ChildNodes
                    i = i + 1
                    If cTmp Is cRelative Then
                        Exit For
                    End If
                Next
            End If
            Select Case vRelationship
            Case tvFirst: .Add cNode, , 1
            Case tvLast: .Add cNode, after:=.count
            Case tvNext: .Add cNode, after:=i
            Case tvPrevious: .Add cNode, before:=i
            Case tvChild: .Add cNode
            End Select
        End If
    End With

    With cNode
        .Key = sKey
        .Caption = sCaption
        .ImageMain = vImageMain
        .ImageExpanded = vImageExpanded
        .Index = mcolNodes.count
        Set .ParentNode = cParent
        Set .Tree = Me
    End With

    Set cNode.Tree = Me    ' do this after let key = skey
    Set NodeAdd = cNode

    Exit Function
errH:
    If mcolNodes Is Nothing Then
        Set mcolNodes = New Collection
        Resume
    End If
    If Erl = 100 And Err.Number = 457 Then
        Err.Raise vbObjectError + 1, "clsNode.AddChild", "Duplicate key: '" & sKey & "'"
    Else
        #If DebugMode = 1 Then
            Stop
            Resume
        #End If
        Err.Raise Err.Number, "clsNode.AddChild", Err.Description
    End If
End Function

Public Sub NodeRemove(cNode As clsNode)
' PT Remove a Node, its children and grandchildrem
'    remove all associated controls and tear down class objects
'    Call Refresh() when done removing nodes

    Dim lIdx As Long
    Dim cParent As clsNode
    Dim cNodeAbove As clsNode, cNd As clsNode
    
    On Error GoTo errH

    Set cNodeAbove = NextVisibleNodeInTree(cNode, bUp:=True)
    Set cParent = cNode.ParentNode

    cNode.TerminateNode True

    cParent.RemoveChild cNode
    
    cNode.Index = -1    ' flag to get removed from mcolNodes
    If ActiveNode Is cNode Then
        Set moActiveNode = Nothing
    End If
    Set moEditNode = Nothing

    lIdx = 0
    mlNodesCreated = 0
    For Each cNd In mcolNodes
        lIdx = lIdx + 1
        If cNd.Index = -1 Then
            mcolNodes.Remove lIdx
            lIdx = lIdx - 1
        Else
            mlNodesCreated = mlNodesCreated - CLng(Not cNd.Control Is Nothing)
            cNd.Index = lIdx
        End If
    Next

    Set cNode = Nothing    ' should terminate the class

    If Not cNodeAbove Is Nothing Then
        Set Me.ActiveNode = cNodeAbove
    ElseIf mcolNodes.count Then
        Set Me.ActiveNode = mcolNodes(1)
    End If

    Exit Sub
errH:
    Debug.Print Err.Description, Err.Number
    #If DebugMode = 1 Then

        Stop
        Resume
    #End If
End Sub

Public Sub NodesClear()
' PT,  similar to Treeview.Nodes.Clear
    Dim i As Long
    On Error GoTo errH

    If Not TreeControl Is Nothing Then
        For i = TreeControl.Controls.count - 1 To 0 Step -1
            TreeControl.Controls.Remove i
        Next
    End If

    TerminateTree

    Changed = False

    Exit Sub
errH:
    #If DebugMode = 1 Then
        Stop
        Resume
    #End If
End Sub

Public Sub PopulateTree()
' PT adds and displays all the controls for the Treeview for the first time
    Dim cRoot As clsNode
    
    If Me.TreeControl Is Nothing Then
        TerminateTree
        Err.Raise vbObjectError + 10, mcSource, "PopulateTree: 'TreeControl' frame is not referenced"
    ElseIf moRootHolder Is Nothing Then
        Err.Raise vbObjectError + 11, mcSource, "PopulateTree: No Roots have not been created"
    Else
        If TreeControl.Controls.count Then
            For Each cRoot In moRootHolder.ChildNodes
                cRoot.RemoveNodeControls
            Next
            Err.Raise vbObjectError + 12, mcSource, "PopulateTree: The tree is already populated"
        Else

        End If
    End If

    On Error GoTo errExit

    BuildRoot True

    Exit Sub
errExit:
    Err.Raise Err.Number, mcSource, "Error in BuildRoot: " & Err.Description
End Sub

Public Sub Refresh()
' PT, displays and repositions node controls as required
'     call this after changing any properties or when done adding/removing/moving any nodes

    On Error GoTo errExit

    If Me.TreeControl Is Nothing Then
        TerminateTree
        Err.Raise vbObjectError + 10, mcSource, "Refresh: 'TreeControl' frame is not referenced"
    ElseIf moRootHolder.ChildNodes Is Nothing Then
        mlVisCount = 0
        Exit Sub    ' nothing to do
    End If

    On Error GoTo errExit
    mbRedesign = True

    BuildRoot False

    Exit Sub

errExit:
    Err.Raise Err.Number, mcSource, "Refresh: Error in BuildRoot: " & Err.Description
End Sub

Public Sub ScrollToView(Optional cNode As clsNode, Optional Top1Bottom2 As Long)
' PT scrolls the treeview to position the node in view
' Top1Bottom2=0 roughly 1/3 from the top
' Top1Bottom2=1 at the top
' Top1Bottom2=2 at the bottom

    Dim bIsVisible As Boolean
    Dim bWasCollapsed As Boolean
    Dim lVisIndex As Long
    Dim sngTop As Single
    Dim sngBot As Single
    Dim sngVisHt As Single
    Dim sngScrollTop As Single
    Dim cTmp As clsNode

    If cNode Is Nothing Then
        Set cNode = ActiveNode
    End If

    Set cTmp = cNode.ParentNode
    While Not cTmp.Caption = "RootHolder"
        If Not cTmp.Expanded Then
            bWasCollapsed = True
            cTmp.Expanded = True
        End If
        Set cTmp = cTmp.ParentNode
    Wend
    
    If bWasCollapsed Then
        BuildRoot False
    End If

    lVisIndex = cNode.VisIndex
    sngBot = mcTLpad + lVisIndex * NodeHeight
    sngTop = sngBot - NodeHeight

    With TreeControl
        sngVisHt = .Height
        If .ScrollBars = fmScrollBarsBoth Or .ScrollBars = fmScrollBarsHorizontal Then
            sngVisHt = sngVisHt - 15    ' roughly(?) width of horizontal scrollbar
        End If

        bIsVisible = sngTop > .ScrollTop And _
                     sngBot < .ScrollTop + sngVisHt
        If Not bIsVisible Then

            If Top1Bottom2 = 0 Then  ' place about 1/3 from top
                sngScrollTop = lVisIndex * NodeHeight - .Height / 3

            ElseIf Top1Bottom2 = 1 Then  ' scroll to top
                sngScrollTop = sngTop - mcTLpad
            Else
                sngScrollTop = sngBot - sngVisHt + mcTLpad    ' scroll to bottom
            End If

            If sngScrollTop < 0 Then
                sngScrollTop = 0
            End If

            .ScrollTop = sngScrollTop
        End If
    End With
End Sub

Public Sub TerminateTree()
'-------------------------------------------------------------------------
' Procedure : TerminateTree
' Company   : JKP Application Development Services (c)
' Author    : Jan Karel Pieterse (www.jkp-ads.com)
' Created   : 15-01-2013
' Purpose   : Terminates this class' instance
'-------------------------------------------------------------------------
Dim cNode As clsNode
    'Instead of the terminate event of the class
    'we use this public method so it can be
    'explicitly called by parent classes
    'this is done because we'll end up having multiple circular references
    'between parent and child classes, which may cause the terminate events to be ignored.

    If Not moRootHolder Is Nothing Then
        If Not moRootHolder.ChildNodes Is Nothing Then
            For Each cNode In moRootHolder.ChildNodes

                cNode.TerminateNode
            Next
        End If
        moRootHolder.TerminateNode
    End If
    
    Set moMoveNode = Nothing
    Set moEditNode = Nothing
    Set moActiveNode = Nothing
    Set moRootHolder = Nothing
    Set mcolNodes = Nothing
    
    '** by design TerminateTree does NOT reset treeview properties or remove
    '** the reference TreeControl reference to the treeview's Frame control
    '
    '   If the form is being unloaded it's enough to call TerminateTree in it's close event, node controls will automatically unload with the form.
    '   However the treeview is to be cleared or moved but the main form is not being unloaded
    '   call the NodesRemove method which will remove all node controls then call TerminateTree
End Sub

'***********************************************************************************************
'*    Friend properties, functions and subs                                                    *
'*    although visible throughout the project these are only intended to be called by clsNodes *
'***********************************************************************************************

Friend Property Get EditMode(cNode As clsNode) As Boolean  ' PT
    EditMode = mbEditMode
End Property

Friend Property Let EditMode(cNode As clsNode, ByVal bEditMode As Boolean)  ' PT

    Set MoveCopyNode(False) = Nothing
    mbEditMode = bEditMode

    If Not moEditNode Is Nothing Then
        moEditNode.EditBox False
    End If


    If bEditMode Then
        Set moEditNode = cNode
    Else
        Set moEditNode = Nothing
    End If
End Property

Friend Function GetExpanderIcon(bExpanded As Boolean, pic As StdPicture) As Boolean
    If mbExpanderImage Then
        Set pic = moExpanderImage(bExpanded)
        GetExpanderIcon = True
    End If
End Function
Friend Function GetCheckboxIcon(lChecked As Long, pic As StdPicture) As Boolean
    If mbCheckboxImage Then
        Set pic = moCheckboxImage(lChecked)
        GetCheckboxIcon = True
    End If
End Function

Friend Function GetNodeIcon(vKey, pic As StdPicture, bFullWidth As Boolean) As Boolean
    On Error GoTo errExit
    Set pic = mcolIcons(vKey)
    bFullWidth = mbFullWidth
    GetNodeIcon = True
errExit:
End Function

Friend Function RaiseAfterLabelEdit(cNode As clsNode, sNewText As String) As Boolean
' PT called from moEditBox_KeyDown after vbKeyEnter
'
    Dim Cancel As Boolean
    RaiseEvent AfterLabelEdit(Cancel, sNewText, cNode)
    RaiseAfterLabelEdit = Cancel
End Function

Friend Sub NodeClick(ByRef oCtl As MSForms.Control, ByRef cNode As clsNode)
'-------------------------------------------------------------------------
' Procedure : NodeClick
' Company   : JKP Application Development Services (c)
' Author    : Jan Karel Pieterse (www.jkp-ads.com)
' Created   : 15-01-2013
' Purpose   : Handles clicks on the treeview. Called from clsNode
'-------------------------------------------------------------------------

' PT also called from checkbox (label) click event in clsNode
    
    UserForm2.TextBox1.Text = cNode.FullPath 'Kette
    
    If cNode.Key = "ilias" Then
        UserForm2.TextBox2.Text = "[1]"
        UserForm2.TextBox4.Text = "[Keine |fffd|bergeordnete Einheit vorhanden]"
        UserForm2.TextBox6.Text = "[Oberste Systemeinheit]" 'description
        UserForm2.TextBox7.Text = "" 'typ
        UserForm2.TextBox8.Text = "" 'responsible
    Else
       UserForm2.TextBox2.Text = cNode.Tag(1) 'Position (Zeile)
        UserForm2.TextBox4.Text = cNode.ParentNode.Key 'ID der |fffd|bergeordneten OE
        UserForm2.TextBox6.Text = cNode.Tag(2) 'description
        UserForm2.TextBox7.Text = cNode.Tag(3) 'UDF 1
        UserForm2.TextBox8.Text = cNode.Tag(4) 'UDF 2
    End If
    
    
    UserForm2.TextBox3.Text = cNode.Key 'ID der OE
              
    UserForm2.TextBox5.Text = cNode.Caption 'title
    
    If oCtl.name Like "Exp*" Then

        Set ActiveNode = cNode

        BuildRoot False

    ElseIf oCtl.name = "CheckBox" Then  ' PT
        ' RaiseEvent for the checkbox moved to clsNode
        RaiseEvent NodeCheck(cNode)

    ElseIf oCtl.name = "NodeLabel" Then
        If Not ActiveNode Is cNode Then
            Set ActiveNode = cNode
        Else
            SetActiveNodeColor
        End If
        RaiseEvent Click(cNode)
    End If
    

End Sub

Friend Function UniqueKey(sKey As String) As String
    Dim cNode As clsNode
    For Each cNode In Nodes
        If cNode.Key = sKey Then
            Err.Raise vbObjectError + 1, "clsTreeView", "Duplicate key: '" & sKey & "'"
        End If
    Next
    UniqueKey = sKey
End Function

'************************************
'*    Private functions and subs    *
'************************************

Private Sub Class_Initialize()
' Set Root = New clsNode
' Set moRoot = New clsNode ' maybe(?) but keep Root() as read only

' set some defaults
    mbRootButton = True
    mbShowExpanders = True
    mbShowLines = True
    #If Mac Then
        msngIndent = 20
    #Else
        msngIndent = 15
    #End If
    msAppName = "TreeView"
    
    #If DebugMode = 1 Then
        gClsTreeViewInit = gClsTreeViewInit + 1    'for testing only
    #End If
End Sub

Private Sub Class_Terminate()
    #If DebugMode = 1 Then
        gClsTreeViewTerm = gClsTreeViewTerm + 1
    #End If
End Sub

Private Function AddNodeToCol(colNodes As Collection, cAddNode As clsNode, bTreeCol As Boolean, Optional vBefore, Optional vAfter)
    Dim i As Long
    Dim sKey As String
    Dim cTmp As clsNode
    Dim pos As Long

    If bTreeCol Then sKey = cAddNode.Key

    If Len(sKey) Then
        On Error Resume Next
        i = 0
        Set cTmp = colNodes(sKey)
        If Not cTmp Is Nothing Then
            pos = InStr(1, sKey, "_copy:")
            If pos Then
                sKey = Left$(sKey, pos - 1)
            End If
            sKey = sKey & "_copy:"
            While Not cTmp Is Nothing
                Set cTmp = Nothing
                i = i + 1
                Set cTmp = colNodes(sKey & i)
            Wend
            sKey = sKey & i

            If bTreeCol Then
                cAddNode.Key = sKey
            End If

        End If

        On Error GoTo 0    ' error returns to caller

        If IsMissing(vBefore) And IsMissing(vAfter) Then
            colNodes.Add cAddNode, sKey
        ElseIf IsMissing(vAfter) Then
            colNodes.Add cAddNode, sKey, vBefore
        Else
            colNodes.Add cAddNode, sKey, , vAfter
        End If

    Else    ' no key
        If IsMissing(vBefore) And IsMissing(vAfter) Then
            colNodes.Add cAddNode
        ElseIf IsMissing(vAfter) Then
            colNodes.Add cAddNode, , vBefore
        Else
            colNodes.Add cAddNode, , , vAfter
        End If
    End If
End Function

Private Sub BuildRoot(bInit As Boolean)
    Dim bCursorWait As Boolean
    Dim bTriStateOrig As Boolean
    Dim lLastRootVisIndex As Long
    Dim sngActiveNodeScrollTop As Single    ' PT distance activenode was from scrolltop top before refresh, if visible
    Dim sngChkBoxPad As Single
    Dim sngHeightAllNodes As Single
    Dim sngIconPad As Single
    Dim sngMaxWidth As Single
    Dim cNode As clsNode
    Dim cRoot As clsNode
    Dim objCtrl As MSForms.Control
    Dim pt As POINTAPI
    Dim vIconKey
    
    Dim sngTickCnt As Single

    On Error GoTo locErr

    #If DebugMode Then
        #If Win32 Or Win64 Then
            sngTickCnt = getTickCount
            sngTickCnt = Timer
        #Else  ' Mac
            sngTickCnt = Timer
        #End If
    #End If

    '  Application.EnableCancelKey = xlErrorHandler

    If mbAlwaysRedesign Then mbRedesign = True

    '    mcChkBoxSize = 10.5    ' 11.25
    '    mcLineLeft = 3 + 7.5    'msngIndent / 2

    ' PT if these arrays aren't large enough Redim Preserve is done in error handler
    ReDim mlVisOrder(1 To mlNodesCreated + 100)
    If bInit Or mbRedesign Then
        ReDim msngMaxWidths(0 To 7)
    End If

    If bInit Then
        If mcolNodes.count > 300 Then
            ' creating many controls might take a while
            Application.Cursor = xlWait
            bCursorWait = True
        End If
    Else
        If NodeIsVisible Then
            sngActiveNodeScrollTop = ActiveNode.VisIndex * NodeHeight - Me.TreeControl.ScrollTop
        End If
    End If

    mlVisCount = 0
    bTriStateOrig = mbTriState
    mbTriState = False
    

    If CheckBoxes Then
        If mbCheckboxImage Then
            sngChkBoxPad = mcCheckboxPadImg
        Else
            sngChkBoxPad = mcCheckboxPad
        End If
        If mcChkBoxSize > msngNodeHeight Then
            msngNodeHeight = mcChkBoxSize
        End If
    End If

    ' work out respective offsets to various node controls from node tops
    msngTopExpB = mcTLpad + (msngNodeHeight - mcExpButSize) / 2 + 1.5
    If mbExpanderImage Then
        msngTopExpT = mcTLpad + (msngNodeHeight - (mcExpButSize - 4)) / 2
    Else
        msngTopExpT = mcTLpad + (msngNodeHeight - mcExpButSize) / 2
    End If

    msngTopChk = mcTLpad + (msngNodeHeight - mcChkBoxSize) / 2
    msngTopIcon = mcTLpad + (msngNodeHeight - mcIconSize) / 2
    msngTopHV = mcTLpad + msngNodeHeight / 2
    Call Round75


    With TreeControl
        mlBackColor = .BackColor    ' default colours for node labels
        mlForeColor = .ForeColor

        If bInit Then
            .SpecialEffect = 2    ' fmSpecialEffectSunken

        Else
            ' PT, refresh, start by hiding all the controls
            For Each objCtrl In .Controls
                objCtrl.Visible = False
            Next
        End If

        For Each cRoot In moRootHolder.ChildNodes
            sngIconPad = 0
            If mbFullWidth Then
                If mbGotIcons And cRoot.hasIcon(vIconKey) Then
                    sngIconPad = mcCheckboxPad
                End If
            End If

If cRoot.Control Is Nothing Then

    'Add the rootnode to the tree
    Set cRoot.Control = TreeControl.Controls.Add("Forms.label.1", "NodeLabel", False)
                With cRoot.Control

                    If Not mbFullWidth And mbGotIcons Then
                        If cRoot.hasIcon(vIconKey) Then
                            .PicturePosition = fmPicturePositionLeftCenter
                            .Picture = mcolIcons(vIconKey)

                        End If
                    End If

                    .Top = mcTLpad + mlVisCount * msngNodeHeight
                    .Left = mcTLpad + msngRootLine + sngIconPad + msngChkBoxPad

                    If cRoot.BackColor Then
                        .BackColor = cRoot.BackColor
                    End If
                    If .ForeColor Then
                        .ForeColor = cRoot.ForeColor
                    End If

                    If cRoot.Bold Then .Font.Bold = True
                    .Caption = cRoot.Caption
                    .AutoSize = True
                    .WordWrap = False

                    cRoot.TextWidth = .Width

                    If .Width + sngIconPad > msngMaxWidths(0) Then
                        msngMaxWidths(0) = .Width + sngIconPad
                    End If

                    ' calc msngTopLabel to align node label to mid NodeHeight
                    ' first calc min NodeHeight if not set higher by user
                    If .Height > msngNodeHeight Then
                        ' optimal HodeHeight for the current font
                        msngNodeHeight = .Height    ' 'don't use the Property method or Refresh will be called
                    ElseIf .Height < msngNodeHeight Then
                        #If Mac Then
                            msngTopLabel = Int(msngNodeHeight - .Height) / 2
                        #Else
                            msngTopLabel = Int((msngNodeHeight - .Height + mcPtPxl) / 3 * 2) * mcPtPxl
                        #End If
                        .Top = mcTLpad + msngTopLabel + mlVisCount * msngNodeHeight
                    End If

                    If mbFullWidth Then
                        If msngTopLabel < mcFullWidth Then
                            .Width = mcFullWidth
                            .AutoSize = False
                        End If
                    End If

                    .WordWrap = False
                    .ZOrder 0
                    .Visible = True
                    mlNodesCreated = mlNodesCreated + 1

                End With
            Else

                With cRoot.Control

                    If mbRedesign Then
                        .Left = mcTLpad + msngRootLine + sngIconPad + msngChkBoxPad
                        
                        If cRoot.TextWidth + sngIconPad > msngMaxWidths(0) Then
                            msngMaxWidths(0) = cRoot.TextWidth + sngIconPad
                        End If
                    End If

                    If .Height > msngNodeHeight Then
                        msngNodeHeight = .Height
                    ElseIf .Height < msngNodeHeight Then
                        #If Mac Then
                            msngTopLabel = Int(msngNodeHeight - .Height) / 2
                        #Else
                            msngTopLabel = Int((msngNodeHeight - .Height + mcPtPxl) / 3 * 2) * mcPtPxl
                        #End If
                    End If

                    .Top = mcTLpad + msngTopLabel + mlVisCount * msngNodeHeight

                    .Visible = True

                End With
            End If

            ' horizontal line
            If mbRootButton And mbShowLines Then
                If cRoot.HLine Is Nothing Then
                    Set cRoot.HLine = TreeControl.Controls.Add("Forms.label.1", "HLine", False)
                    With cRoot.HLine
                        .Top = msngTopHV + mlVisCount * msngNodeHeight
                        .Left = mcLineLeft
                        .Caption = ""
                        .BorderStyle = fmBorderStyleSingle
                        .BorderColor = vbScrollBars
                        .Width = msngIndent
                        .Height = mcPtPxl
                        .TextAlign = fmTextAlignCenter
                        .BackStyle = fmBackStyleTransparent
                        .ZOrder 1
                        .Visible = True
                    End With
                Else
                    With cRoot.HLine
                        .Width = msngIndent
                        .Top = msngTopHV + mlVisCount * msngNodeHeight  ' 3 + NodeHeight/2 (to nearest 0.75)
                        .Visible = True
                    End With
                End If
            End If

            ' Checkbox
            If CheckBoxes Then
                If cRoot.Checkbox Is Nothing Then
                    Set cRoot.Checkbox = TreeControl.Controls.Add("Forms.label.1", "CheckBox", False)
                    With cRoot.Checkbox
                        .Left = mcTLpad + msngRootLine
                        .Top = msngTopChk + mlVisCount * msngNodeHeight
                        
                        If mbCheckboxImage Then
                            'Use an image
                            .BorderStyle = fmBorderStyleNone
                            .Picture = moCheckboxImage(cRoot.Checked)
                            .PicturePosition = fmPicturePositionLeftTop
                            .AutoSize = True
                            '                    .Width = 7.5
                            '                    .Height = 7.5
                        Else
                            .Width = mcChkBoxSize
                            .Height = mcChkBoxSize
                            .Font.name = "Marlett"  ' "a" is a tick
                            .FontSize = mcCheckboxFont     '9
                            .BorderStyle = fmBorderStyleSingle
                            .BackColor = vbWindowBackground
                            .ForeColor = vbWindowText
                        End If
                        If cRoot.Checked Then cRoot.Checked = True
                        .Visible = True
                    End With
                Else
                    With cRoot.Checkbox
                        .Left = mcTLpad + msngRootLine
                        .Top = msngTopChk + mlVisCount * msngNodeHeight
                        .Visible = True
                    End With
                End If
            End If

            ' Icon
            If mbFullWidth And mbGotIcons Then
                If cRoot.hasIcon(vIconKey) Then
                    If cRoot.Icon Is Nothing Then
                        Set cRoot.Icon = TreeControl.Controls.Add("Forms.Image.1", "Icon", False)
                        With cRoot.Icon
                            .BackStyle = fmBackStyleTransparent
                            .BorderStyle = fmBorderStyleNone
                            '.AutoSize
                            .Width = mcIconSize
                            .Height = mcIconSize
                            .Left = mcTLpad + msngRootLine + msngChkBoxPad
                            .Top = msngTopIcon + mlVisCount * msngNodeHeight
                            .Picture = mcolIcons(vIconKey)
                            .BackStyle = fmBackStyleTransparent
                            .Visible = True
                        End With
                    Else
                        With cRoot.Icon
                            .Left = mcTLpad + msngRootLine + msngChkBoxPad
                            .Top = msngTopIcon + mlVisCount * msngNodeHeight
                            .Visible = True
                        End With
                    End If
                Else
                    sngIconPad = 0
                End If
            End If

            mlVisCount = mlVisCount + 1
            mlVisOrder(mlVisCount) = cRoot.Index
            cRoot.VisIndex = mlVisCount

            lLastRootVisIndex = mlVisCount

            'Now add this root's children
            If Not cRoot.ChildNodes Is Nothing Then
                BuildTree cRoot, 1, True
            End If

        Next

        'Vertical line for multiple roots
        If mbRootButton And mbShowLines Then
            If moRootHolder.ChildNodes.count > 1 Then

                If moRootHolder.VLine Is Nothing Then
                    Set moRootHolder.VLine = TreeControl.Controls.Add("forms.label.1", "VLine")
                    With moRootHolder.VLine
                        .ZOrder 1
                        .Width = mcPtPxl
                        .Caption = ""
                        .BorderColor = vbScrollBars
                        .BorderStyle = fmBorderStyleSingle
                        .Top = msngTopHV
                        .Left = mcLineLeft
                        .Height = (lLastRootVisIndex - 1) * msngNodeHeight
                    End With

                Else

                    With moRootHolder.VLine
                        .Top = msngTopHV
                        .Height = (lLastRootVisIndex - 1) * msngNodeHeight
                        .Visible = True
                    End With
                End If

            End If
        End If

        sngHeightAllNodes = mlVisCount * NodeHeight + (mcTLpad * 2)    ' mcTLpad for top/bottom padding
        .ScrollHeight = 0

        sngMaxWidth = MaxNodeWidth + 15
        .ScrollWidth = sngMaxWidth

        If sngHeightAllNodes > .Height And sngMaxWidth > .Width Then
            .ScrollBars = fmScrollBarsBoth
            .ScrollWidth = sngMaxWidth
            .ScrollHeight = sngHeightAllNodes
        ElseIf .Width < sngMaxWidth Then
            .ScrollBars = fmScrollBarsHorizontal
            .ScrollWidth = sngMaxWidth
        ElseIf sngHeightAllNodes + NodeHeight > .Height Then
            .ScrollBars = fmScrollBarsVertical
            .ScrollHeight = sngHeightAllNodes
        Else
            .ScrollBars = fmScrollBarsNone
        End If

        If bInit Then
            Set ActiveNode = moRootHolder.ChildNodes(1)
        ElseIf Not ActiveNode Is Nothing Then
            If Not NodeIsVisible Then
                .ScrollTop = (ActiveNode.VisIndex) * NodeHeight - sngActiveNodeScrollTop
            End If
        End If

    End With

    #If DebugMode Then
        Dim sCap As String
        #If Win32 Or Win64 Then
            'sCap = "Seconds: " & (getTickCount - sngTickCnt) / 1000
            sCap = "Seconds: " & Left$((Timer - sngTickCnt), 4)
        #Else  ' if Mac
            sCap = "Seconds: " & Left$((Timer - sngTickCnt), 4)
        #End If
        sCap = sCap & _
               "    Nodes: " & mcolNodes.count & _
               "  created: " & mlNodesCreated & _
               "  visible: " & mlVisCount & _
               "    Total controls: " & TreeControl.Controls.count
        Me.TreeControl.Parent.Caption = sCap
    #End If


    mbRedesign = False
    mbTriState = bTriStateOrig
done:

    If bCursorWait Then
        Application.Cursor = xlDefault

        #If Win32 Or Win64 Then
            ' in some systems the cursor fails to reset to default, this forces it
            GetCursorPos pt
            SetCursorPos pt.x, pt.Y
        #End If
    End If


    Application.EnableCancelKey = xlInterrupt
    Exit Sub

locErr:
    mbRedesign = False
    mbTriState = bTriStateOrig
    
    If Err.Number = 9 And (mlVisCount = UBound(mlVisOrder) + 1) Then
        ' most likely an array needs enlarging
        If mlVisCount = UBound(mlVisOrder) + 1 Then
            ReDim Preserve mlVisOrder(LBound(mlVisOrder) To mlVisCount + 100)
            Resume
        End If
    ElseIf Err.Number = 18 Then
        ' user pressed ctrl-break
        MsgBox "Loading Treeview aborted", , AppName
        NodesClear
        Resume done
    End If

    #If DebugMode = 1 Then
        Debug.Print Err.Number, Err.Description
        Stop
        Resume
    #End If
End Sub

Private Sub BuildTree(cNode As clsNode, ByVal lLevel As Long, Optional lMaxLevel As Long = -1)
    Dim cChild As clsNode
    Dim lVLineTopIdx As Long

   ' On Error GoTo locErr

    If (lLevel > 1 Or mbRootButton) And mbShowExpanders Then

        'Expand/collapse button box (not needed when we use an icon on expanders)
        If Not mbExpanderImage Then
            If cNode.ExpanderBox Is Nothing Then
                Set cNode.ExpanderBox = TreeControl.Controls.Add("Forms.label.1", "ExpBox", False)
                With cNode.ExpanderBox
                    .Top = (mlVisCount - 1) * NodeHeight + msngTopExpB
                    .Left = mcTLpad * 2 + (lLevel - 2) * msngIndent + msngRootLine
                    .Width = mcExpBoxSize
                    .Height = mcExpBoxSize
                    .BorderStyle = fmBorderStyleSingle
                    .BorderColor = vbScrollBars
                    .BackStyle = fmBackStyleOpaque
                    .Visible = True
                End With
            Else
                With cNode.ExpanderBox
                    If mbRedesign Then .Left = mcTLpad * 2 + (lLevel - 2) * msngIndent + msngRootLine
                    .Top = (mlVisCount - 1) * NodeHeight + msngTopExpB
                    .Visible = True
                End With
            End If
        End If

        'Expand/collapse button text (or icon)
        If cNode.Expander Is Nothing Then
            Set cNode.Expander = TreeControl.Controls.Add("Forms.label.1", "ExpText", False)
            With cNode.Expander
                .Left = mcTLpad * 2 + (lLevel - 2) * msngIndent + msngRootLine
                .Top = (mlVisCount - 1) * NodeHeight + msngTopExpT

                If mbExpanderImage Then
                    'Use an image
                    .AutoSize = True
                    .Width = 7.5
                    .Height = 7.5
                    .BorderStyle = fmBorderStyleNone
                    .Picture = moExpanderImage(cNode.Expanded)
                    .PicturePosition = fmPicturePositionLeftTop
                    #If Mac Then
                        .BackStyle = fmBackStyleTransparent
                    #End If
                Else
                    'use +/- text
                    .Width = mcExpButSize
                    .Height = mcExpButSize

                    If cNode.Expanded = True Then
                        .Caption = "-"
                        .Font.Bold = True
                    Else
                        .Caption = "+"
                        .Font.Bold = False
                    End If

                    .Font.Size = mcExpanderFont
                    .TextAlign = fmTextAlignCenter
                    .BackStyle = fmBackStyleTransparent
                End If
                .Visible = True
            End With
        Else
            With cNode.Expander
                If mbRedesign Then .Left = mcTLpad * 2 + (lLevel - 2) * msngIndent + msngRootLine
                .Top = (mlVisCount - 1) * NodeHeight + msngTopExpT
                .Visible = True
            End With
        End If

    End If  ' lLevel > 1 Or mbRootButton) And mbShowExpanders

    If cNode.Expanded And (lMaxLevel < lLevel Or lMaxLevel = -1) Then

        'Vertical line
        If mbShowLines Then
            If cNode.VLine Is Nothing Then
                Set cNode.VLine = TreeControl.Controls.Add("Forms.label.1", "VLine", False)
                lVLineTopIdx = mlVisCount
                With cNode.VLine
                    .ZOrder 1
                    .Top = msngTopHV + (lVLineTopIdx - 1) * NodeHeight
                    .Left = mcLineLeft + msngRootLine + msngIndent * (lLevel - 1)
                    .Width = mcPtPxl
                    .Height = NodeHeight
                    .Caption = ""
                    .BorderColor = vbScrollBars
                    .BorderStyle = fmBorderStyleSingle
                    .Visible = True
                End With

            Else
                lVLineTopIdx = mlVisCount
                cNode.VLine.Top = msngTopHV + (lVLineTopIdx - 1) * NodeHeight
                If mbRedesign Then
                    cNode.VLine.Left = mcLineLeft + msngRootLine + msngIndent * (lLevel - 1)
                End If
            End If
        End If

        For Each cChild In cNode.ChildNodes

            ' extend the vertical line
            If mbShowLines Then
                With cNode.VLine
                    .Height = (mlVisCount - lVLineTopIdx + 1) * msngNodeHeight
                    .Visible = True
                End With
            End If

            BuildNodeControls cChild, lLevel

            If Not cChild.ChildNodes Is Nothing Then
                BuildTree cChild, lLevel + 1
            End If

        Next

    End If    ' cNode.Expanded And (lMaxLevel < lLevel Or lMaxLevel = -1)

    Exit Sub

'locErr:
'    #If DebugMode = 1 Then
'        Stop
'        Resume
'    #End If
End Sub

Private Sub BuildNodeControls(cNode As clsNode, ByVal lLevel As Long)
' PT, create or unhide the controls, size & position to suit
' all created nodes have a caption, and optionally a horizontal line, checkbox and seperate icon

    Dim sngIconPad As Single
    Dim vKey

    On Error GoTo locErr
    Application.EnableCancelKey = xlErrorHandler

    'Horizontal line
    If mbShowLines Then
        If cNode.HLine Is Nothing Then
            Set cNode.HLine = TreeControl.Controls.Add("Forms.label.1", "HLine", False)
            With cNode.HLine
                .Left = mcLineLeft + msngRootLine + msngIndent * (lLevel - 1)
                .Top = msngTopHV + mlVisCount * NodeHeight
                .Width = msngIndent
                .Height = mcPtPxl
                .Caption = ""
                .BorderStyle = fmBorderStyleSingle
                .BorderColor = vbScrollBars
                .Visible = True
            End With
        Else
            With cNode.HLine
                If mbRedesign Then
                    .Left = mcLineLeft + msngRootLine + msngIndent * (lLevel - 1)
                    .Width = msngIndent
                End If
                .Top = msngTopHV + mlVisCount * NodeHeight
                .Visible = True
            End With

        End If
    End If

    ' Checkbox
    If CheckBoxes Then
        If cNode.Checkbox Is Nothing Then
            Set cNode.Checkbox = TreeControl.Controls.Add("Forms.label.1", "CheckBox", False)
            With cNode.Checkbox
                .Left = mcTLpad + msngRootLine + msngIndent * lLevel
                .Top = mlVisCount * NodeHeight + msngTopChk

                If mbCheckboxImage Then
                    'Use an image
                    .BorderStyle = fmBorderStyleNone
                    .Picture = moCheckboxImage(cNode.Checked)
                    .PicturePosition = fmPicturePositionLeftBottom
                    .AutoSize = True
                Else

                .Width = mcChkBoxSize
                .Height = mcChkBoxSize
                    .Font.name = "Marlett"
                    .Font.Size = 10
                    .TextAlign = fmTextAlignCenter
                    .BorderStyle = fmBorderStyleSingle
                    If cNode.Checked Then
                        .Caption = "a"
                        If cNode.Checked = 1 Then
                            .ForeColor = RGB(180, 180, 180)
                        End If
                    End If
                End If

                .Visible = True
            End With
        Else
            With cNode.Checkbox
                If mbRedesign Then .Left = mcTLpad + msngRootLine + msngIndent * lLevel
                .Top = mlVisCount * NodeHeight + msngTopChk
                .Visible = True
            End With
        End If
    End If

    ' Icon, in its own image control if using FullWidth, otherwise it goes in the label
    If mbFullWidth And mbGotIcons Then
        If cNode.hasIcon(vKey) Then
            sngIconPad = mcCheckboxPad
            If cNode.Icon Is Nothing Then
                Set cNode.Icon = TreeControl.Controls.Add("Forms.Image.1", "I", False)
                With cNode.Icon
                    .BorderStyle = fmBorderStyleNone
                    .Left = mcTLpad + msngRootLine + msngIndent * lLevel + msngChkBoxPad
                    .Top = mlVisCount * NodeHeight + msngTopIcon
                    '.AutoSize
                    .Width = mcIconSize
                    .Height = mcIconSize
                    .BackStyle = fmBackStyleTransparent
                    .Picture = mcolIcons(vKey)
                    .BackStyle = fmBackStyleTransparent
                    .Visible = True
                End With
            Else
                With cNode.Icon
                    If mbRedesign Then
                        .Left = mcTLpad + msngRootLine + msngIndent * lLevel + msngChkBoxPad
                    End If
                    .Top = mlVisCount * NodeHeight + msngTopIcon
                    .Visible = True
                End With
            End If
        Else
            sngIconPad = 0
        End If
    End If

    'The node itself
    If cNode.Control Is Nothing Then

        Set cNode.Control = TreeControl.Controls.Add("Forms.label.1", "NodeLabel", False)
        With cNode.Control
            .WordWrap = False
            .AutoSize = True
            .Left = mcTLpad + msngRootLine + msngIndent * lLevel + msngChkBoxPad + sngIconPad
            .Top = mcTLpad + msngTopLabel + mlVisCount * NodeHeight

            If Not mbFullWidth And mbGotIcons Then
                If cNode.hasIcon(vKey) Then
                    .PicturePosition = fmPicturePositionLeftCenter
                    .Picture = mcolIcons(vKey)
                End If
            End If

            If cNode.Bold Then .Font.Bold = True
            .WordWrap = False
            .AutoSize = True
            .Caption = cNode.Caption
            cNode.TextWidth = .Width

            If cNode.TextWidth + sngIconPad > msngMaxWidths(lLevel) Then
                msngMaxWidths(lLevel) = cNode.TextWidth + sngIconPad
            End If

            If mbFullWidth Then
                .AutoSize = False
                If .Width <= mcFullWidth Then .Width = mcFullWidth
            End If
            If cNode.BackColor Then
                .BackColor = cNode.BackColor
            End If
            If cNode.ForeColor Then
                .ForeColor = cNode.ForeColor
            End If
            .Visible = True
        End With

        mlNodesCreated = mlNodesCreated + 1

    Else
        With cNode.Control
            If mbRedesign Then
                .Left = mcTLpad + msngRootLine + msngIndent * lLevel + sngIconPad + msngChkBoxPad
                
                If cNode.TextWidth + sngIconPad > msngMaxWidths(lLevel) Then
                    msngMaxWidths(lLevel) = cNode.TextWidth + sngIconPad
                End If
            End If

            .Top = mlVisCount * NodeHeight + mcTLpad + msngTopLabel
            .Visible = True
        End With

    End If

    mlVisCount = mlVisCount + 1
    mlVisOrder(mlVisCount) = cNode.Index
    cNode.VisIndex = mlVisCount

    Exit Sub

locErr:
    If Err.Number = 9 Then
        ' most likely an array needs enlarging
        If mlVisCount = UBound(mlVisOrder) + 1 Then
            ReDim Preserve mlVisOrder(LBound(mlVisOrder) To mlVisCount + 100)
            Resume
        ElseIf lLevel > UBound(msngMaxWidths) Then
            ReDim Preserve msngMaxWidths(LBound(msngMaxWidths) To lLevel + 5)
            Resume
        End If
    ElseIf Err.Number = 18 Then
        Err.Raise 18 ' user pressed ctrl-break, pass to BuildRoot
    End If

    #If DebugMode = 1 Then
        Stop
        Resume
    #End If
End Sub

Private Sub Clone(cParent As clsNode, cNode As clsNode, Optional vBefore, Optional ByVal vAfter)
' PT clone a node and add the 4-way references
    Dim bTriStateOrig As Boolean
    Dim cClone As clsNode
    Dim cChild As clsNode
    
    bTriStateOrig = mbTriState
    mbTriState = False
    
    On Error GoTo errH

    If cParent Is Nothing Or cNode Is Nothing Then
        Exit Sub
    End If

    Set cClone = New clsNode

    With cNode
        If .BackColor = 0 Then .BackColor = mlBackColor
        cClone.BackColor = .BackColor
        cClone.Caption = .Caption
        cClone.Checked = .Checked
        cClone.Expanded = .Expanded
        If .ForeColor = 0 Then .ForeColor = mlForeColor
        cClone.ImageExpanded = .ImageExpanded
        cClone.ImageMain = .ImageMain
        cClone.ForeColor = .ForeColor
        cClone.Key = .Key
    End With

    If cParent.ChildNodes Is Nothing Then
        Set cParent.ChildNodes = New Collection
    End If

    Set cClone.ParentNode = cParent

    If Not cNode.ChildNodes Is Nothing Then
        For Each cChild In cNode.ChildNodes
            Clone cClone, cChild    ' don't pass vBefore/vAfter
        Next
    End If

    AddNodeToCol cParent.ChildNodes, cClone, False, vBefore, vAfter

    Set cClone.Tree = Me
    
    AddNodeToCol mcolNodes, cClone, bTreeCol:=True

    cClone.Index = Nodes.count
    mbTriState = bTriStateOrig
    If mbTriState Then
        cClone.ParentNode.CheckTriStateParent
    End If
    
    Exit Sub

errH:
    #If DebugMode = 1 Then
        Debug.Print Err.Description
        Stop
        Resume
    #End If
    mbTriState = bTriStateOrig
End Sub

Private Function MaxNodeWidth() As Single
'-------------------------------------------------------------------------
' Procedure : MaxNodeWidth
' Author    : Peter Thornton
' Created   : 27-01-2013
' Purpose   : Get the max right for horizontal scroll
'-------------------------------------------------------------------------
    Dim lLevel As Long
    Dim sngMax As Single

    ''' msngMaxWidths(), contains maximum text-width + additional icon width (if any) in each level
    '  tot-width = 3 + msngRootLine + msngIndent * lLevel + msngChkBoxPad + [ msngIconPad + text-width]

    For lLevel = 0 To UBound(msngMaxWidths)
        If msngMaxWidths(lLevel) Then
            If mcTLpad + msngRootLine + msngIndent * lLevel + msngChkBoxPad + msngMaxWidths(lLevel) > sngMax Then
                sngMax = mcTLpad + msngRootLine + msngIndent * lLevel + msngChkBoxPad + msngMaxWidths(lLevel)
            End If
        End If
    Next
    MaxNodeWidth = sngMax
End Function

Private Function NextVisibleNodeInTree(ByRef cStartNode As clsNode, Optional bUp As Boolean = True) As clsNode
'-------------------------------------------------------------------------
' Procedure : NextVisibleNodeInTree
' Company   : JKP Application Development Services (c)
' Author    : Jan Karel Pieterse (www.jkp-ads.com)
' Created   : 16-01-2013
' Purpose   : Function that returns either the next or the previous node adjacent to the active node
'-------------------------------------------------------------------------

    Dim lStep As Long
    Dim lNextVis As Long    'PT

    On Error GoTo errH
    If bUp Then lStep = -1 Else lStep = 1

    If cStartNode Is Nothing Then
        Set NextVisibleNodeInTree = mcolNodes(1)
    Else

        lNextVis = cStartNode.VisIndex
        lNextVis = lNextVis + lStep
        If lNextVis >= 1 And lNextVis <= mlVisCount Then
            lNextVis = mlVisOrder(lNextVis)
            Set NextVisibleNodeInTree = mcolNodes(lNextVis)
        End If
    End If
    Exit Function
errH:
    #If DebugMode = 1 Then
        Stop
        Debug.Print Err.Description
        Resume
    #End If
End Function

Private Function NodeIsVisible(Optional cNode As clsNode)
Dim idxFirstVis As Long
Dim idxLastVis As Long

    If TreeControl Is Nothing Then
        Exit Function
    End If
    With TreeControl
        idxFirstVis = .ScrollTop / NodeHeight
        idxLastVis = idxFirstVis + (.Height / NodeHeight)
    End With

    If cNode Is Nothing Then
        If Not ActiveNode Is Nothing Then

            Set cNode = ActiveNode
        Else
            Exit Function
        End If
    End If

    If idxFirstVis < 1 Then idxFirstVis = 1
    If idxLastVis > mlVisCount Then idxLastVis = mlVisCount

    If Not cNode Is Nothing Then
        NodeIsVisible = cNode.VisIndex >= idxFirstVis And cNode.VisIndex <= idxLastVis
    End If

End Function

Private Sub ResetActiveNodeColor(cNode As clsNode)
    Dim lBColor As Long
    Dim lFColor As Long
    If Not cNode Is Nothing Then
        lBColor = cNode.BackColor
        lFColor = cNode.ForeColor
        With cNode.Control
            .BackColor = IIf(lBColor, lBColor, mlBackColor)
            .ForeColor = IIf(lFColor, lFColor, mlForeColor)
        End With
    End If
End Sub

Private Sub Round75()
'-------------------------------------------------------------------------
' Procedure : Round75
' Author    : Peter Thornton
' Created   : 29-01-2013
' Purpose   : Make size & position dims a factor of 0.75 points (units of 1 pixel)
'-------------------------------------------------------------------------
#If Mac Then
    msngTopExpB = Int(msngTopExpB)
    msngTopExpT = Int(msngTopExpT)
    msngTopHV = Int(msngTopHV)
    msngTopIcon = Int(msngTopIcon)
    msngTopChk = Int(msngTopChk)
    msngTopLabel = Int(msngTopLabel)
#Else
    msngTopExpB = Int((msngTopExpB * 2 + mcPtPxl) / 3 * 2) * mcPtPxl
    msngTopExpT = Int((msngTopExpT * 2 + mcPtPxl) / 3 * 2) * mcPtPxl
    msngTopHV = Int((msngTopHV * 2 + mcPtPxl) / 3 * 2) * mcPtPxl
    msngTopIcon = Int((msngTopIcon * 2 + mcPtPxl) / 3 * 2) * mcPtPxl
    msngTopChk = Int((msngTopChk * 2 + mcPtPxl) / 3 * 2) * mcPtPxl
    msngTopLabel = Int((msngTopLabel * 2 + mcPtPxl) / 3 * 2) * mcPtPxl
#End If
End Sub


Private Sub SetActiveNodeColor()
    If Not ActiveNode Is Nothing Then
        ActiveNode.Control.BackStyle = fmBackStyleOpaque
        ActiveNode.Control.BackColor = vbHighlight    ' system highlight colours
        ActiveNode.Control.ForeColor = vbHighlightText
    End If
End Sub

Private Sub SetTreeExpansionLevel(lLevel As Long, Optional lCurLevel As Long, _
                                          Optional cNode As clsNode, Optional bExit As Boolean = False)
'-------------------------------------------------------------------------
' Procedure : SetTreeExpansionLevel
' Company   : JKP Application Development Services (c)
' Author    : Jan Karel Pieterse (www.jkp-ads.com)
' Created   : 17-01-2013
' Purpose   : Updates the expanded properties according to lLevel
'             Called recursively.
'-------------------------------------------------------------------------
    Dim cChild As clsNode
    If bExit Then Exit Sub
    If cNode Is Nothing Then

        For Each cNode In moRootHolder.ChildNodes
            If lLevel > -1 Then
                cNode.Expanded = True
            Else
                cNode.Expanded = False
            End If
            If Not cNode.ChildNodes Is Nothing Then
                For Each cChild In cNode.ChildNodes
                    cChild.Expanded = (lLevel > lCurLevel)
                    SetTreeExpansionLevel lLevel, lCurLevel + 1, cChild, False
                Next
            End If
        Next

    ElseIf Not cNode.ChildNodes Is Nothing Then
        For Each cChild In cNode.ChildNodes
            cChild.Expanded = (lLevel > lCurLevel)
            SetTreeExpansionLevel lLevel, lCurLevel + 1, cChild, False
        Next
    End If
End Sub


'*********************************************************************************************
'*    Private events    *
'**********************************************************************************************

Private Sub TreeControl_Click()
' PT exit editmode if an empty part of the treeview is clicked
    EditMode(ActiveNode) = False
End Sub

Private Sub TreeControl_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
    Dim sngVisTop As Single
    Dim cNode As clsNode

        ' PT toggle expand/collapse with key Enter
        If KeyCode = vbKeyReturn Then
            If ActiveNode.Expanded Then
                KeyCode = vbKeyLeft
            Else
                KeyCode = vbKeyRight
            End If
        End If

   Select Case KeyCode

        Case vbKeyLeft
            If ActiveNode.Level = 0 And Not mbRootButton Then
                ' don't attempt to collapse the Root if it doesn't have a buttone

            ElseIf Not ActiveNode.ChildNodes Is Nothing Then
                If ActiveNode.Expanded Then
                    ActiveNode.Expanded = False
                    BuildRoot False
                Else
                    If Not ActiveNode.ParentNode Is Nothing Then
                        If ActiveNode.ParentNode.Expanded Then
                            'If Not ActiveNode.ParentNode.Level = 0 And mbRootButton Then
                            If Not ActiveNode.ParentNode.Level = 0 Then
                                Set ActiveNode = ActiveNode.ParentNode
                                ScrollToView , 1
                            End If
                        End If
                    End If
                End If
            Else
                If Not ActiveNode.ParentNode Is Nothing Then
                    If ActiveNode.ParentNode.Level = 0 And Not mbRootButton Then
                        ' don't attempt to collapse the Root if it doesn't have a button
                    ElseIf ActiveNode.ParentNode.Expanded Then
                        If ActiveNode.ParentNode.Caption <> "RootHolder" Then
                            Set ActiveNode = ActiveNode.ParentNode
                            ScrollToView
                        End If
                    End If
                End If
            End If

        Case vbKeyRight
            If Not ActiveNode.ChildNodes Is Nothing Then
                If ActiveNode.Expanded = False Then
                    ActiveNode.Expanded = True
                    BuildRoot False
                Else
                    Set ActiveNode = ActiveNode.ChildNodes(1)

                End If
            End If

    Case vbKeyUp, vbKeyDown
        If ActiveNode.VisIndex = mlVisCount And KeyCode = vbKeyDown Then
            ' if the activenode is the last node and collapes, expand it and activate the 1st childnode
            If Not ActiveNode.ChildNodes Is Nothing Then
                If ActiveNode.Expanded = False Then
                    ActiveNode.Expanded = True
                    BuildRoot False
                End If
            End If
        End If
        
        Set cNode = NextVisibleNodeInTree(ActiveNode, (KeyCode = vbKeyUp))

        If Not cNode Is Nothing Then
            Set ActiveNode = cNode
            ScrollToView ActiveNode, IIf(KeyCode = vbKeyUp, 1, 2)
            NodeClick ActiveNode.Control, ActiveNode
        End If

    Case vbKeyPageUp, vbKeyPageDown
        'store the activenode's vertical position to reset a similar in the keyup
        If Not mbKeyDown Then
            sngVisTop = (ActiveNode.VisIndex - 1) * NodeHeight - TreeControl.ScrollTop
            If sngVisTop > 0 And sngVisTop < TreeControl.Height Then
                msngVisTop = sngVisTop
            Else
                msngVisTop = 0
            End If
        End If

    Case vbKeyEscape
        Set MoveCopyNode(False) = Nothing

    Case vbKeySpace  ' PT toggle checkbox with space
        If CheckBoxes Then
            ActiveNode.Checked = Not ActiveNode.Checked

            RaiseEvent NodeCheck(ActiveNode)
        End If
    End Select

    mbKeyDown = True    ' PT

    RaiseEvent KeyDown(ActiveNode, KeyCode, Shift)
End Sub

Private Sub TreeControl_KeyUp(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
'-------------------------------------------------------------------------
' Procedure : TreeControl_KeyUp
' Company   : JKP Application Development Services (c)
' Author    : Jan Karel Pieterse (www.jkp-ads.com)
' Created   : 17-01-2013
' Purpose   : Handles collapsing and expanding of the tree using left and right arrow keys
'             and moving up/down the tree using up/down arrow keys
'             Also handles folding of the tree when you use the numeric keys.
'-------------------------------------------------------------------------
    Dim lIdx As Long
    Dim sngNewScrollTop As Single

    If Not mbKeyDown Then    'PT
        ' PT KeyDown was initiated in some other control,
        '   eg Key Enter in the Editbox or tabbing to the treecontrol (enter event)
        Exit Sub
    Else

        mbKeyDown = False
    End If

    If Not ActiveNode Is Nothing Then

        Select Case KeyCode

        ' PT look into moving more key events into KeyDown

        Case 48 To 57, 96 To 105
            If KeyCode >= 96 Then KeyCode = KeyCode - 48
            If KeyCode > vbKey0 Or mbRootButton Then
                'SetTreeExpansionLevel (KeyCode - 49)
                ExpandToLevel (KeyCode - 48)
                BuildRoot False
            End If

        Case vbKeyF2, 93   ' F2 & key right/context menu (?) PT
            If mlLabelEdit = 0 Then
                If Not ActiveNode Is Nothing Then
                    EditMode(ActiveNode) = True
                    ActiveNode.EditBox True
                End If
            End If
        Case vbKeyPageUp, vbKeyPageDown
            ' PT activate node in the same position as previous activenode when scrolling
            With Me.TreeControl
                sngNewScrollTop = .ScrollTop
                lIdx = (sngNewScrollTop + msngVisTop) / NodeHeight + 1

                If (lIdx - 1) * NodeHeight < .ScrollTop Then
                    lIdx = lIdx + 1

                ElseIf lIdx * NodeHeight > .Height + .ScrollTop Then
                    lIdx = lIdx - 1
                End If
            End With

            If lIdx > 1 And lIdx <= mlVisCount Then
                lIdx = mlVisOrder(lIdx)
                Set ActiveNode = mcolNodes(lIdx)
            End If
            
        Case vbKeyHome, vbKeyEnd
            If KeyCode = vbKeyHome Then lIdx = 1 Else lIdx = mlVisCount
            lIdx = mlVisOrder(lIdx)
            If ActiveNode.Index <> lIdx Then
                Set ActiveNode = mcolNodes(lIdx)
            End If
        Case Else

        End Select
    Else
        If Not mcolNodes Is Nothing Then
            If mcolNodes.count Then
                Set ActiveNode = mcolNodes(1)
            End If
        End If
    End If
End Sub

Attribute VB_Name = "clsUserForm"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'==================================================================
'Dieser Source stammt von http://www.vb-fun.de und kann frei
'in EIGENEN (auch in EIGENEN kommerziellen) Projekten verwendet
'werden. Er darf NICHT auf anderen Webseiten oder Foren ohne
'Quellenangabe ver|fffd|ffentlicht werden (siehe hierzu auch die
'Hinweise unter "Urheber- und Kennzeichenrecht" im Impressum).
'F|fffd|r eventuelle Sch|fffd|den wird nicht gehaftet.

'Um Fehler oder Fragen zu kl|fffd|ren, nutzen Sie bitte unser Forum.
'Ansonsten viel Spa|fffd| und Erfolg mit diesem Source-Code !

'==================================================================
'UserForm minimieren/maximieren
'==================================================================

Option Explicit

'Windows API-Aufrufe:

'FindWindow
'  versucht ein Top-Level-Fenster zu finden, das dem |fffd|ber-
'  gebenen Klassennamen und/oder dem Fenstertitel entspricht.
Private Declare Function FindWindow Lib "user32" Alias _
      "FindWindowA" (ByVal lpClassName As String, ByVal _
      lpWindowName As String) As Long

'GetWindowLong
'  gibt den aktuellen Wert eines Window-Attributes zur|fffd|ck.
Private Declare Function GetWindowLong Lib "user32" Alias _
      "GetWindowLongA" (ByVal hwnd As Long, ByVal nIndex _
      As Long) As Long

'SetWindowLong
'  |fffd|ndert ein Attribut des angegebenen Fensters.
Private Declare Function SetWindowLong Lib "user32" Alias _
      "SetWindowLongA" (ByVal hwnd As Long, ByVal nIndex _
      As Long, ByVal dwNewLong As Long) As Long

'ShowWindow
'  bestimmt die Anzeige eines Fensters.
Private Declare Function ShowWindow Lib "user32" (ByVal _
      hwnd As Long, ByVal nCmdShow As Long) As Long

'DrawMenuBar
'  erzwingt das Neuzeichnen der Titelleiste eines Fensters.
Private Declare Function DrawMenuBar Lib "user32" (ByVal _
      hwnd As Long) As Long

'SetFocus
'  aktiviert ein bestimmtes Fenster. Das Fenster erh|fffd|lt dann den "Fokus".
Private Declare Function SetFocus Lib "user32" (ByVal _
      hwnd As Long) As Long

'IsIconic
'  ermittelt, ob ein Fenster minimiert ist.
Private Declare Function IsIconic Lib "user32" (ByVal _
      hwnd As Long) As Long

'IsZoomed
'  ermittelt, ob ein Fenster maximiert ist.
Private Declare Function IsZoomed Lib "user32" (ByVal _
      hwnd As Long) As Long

'Konstanten:
Private Const GWL_STYLE As Long = (-16)        'Fensterstil
Private Const WS_THICKFRAME As Long = &H40000  'gr|fffd|ssenver|fffd|nderbarer Frame

Private Const WS_SYSMENU As Long = &H80000     'Systemmen|fffd| (Titelleiste)
Private Const WS_MINIMIZEBOX As Long = &H20000 'Minimize-Box (Titelleiste)
Private Const WS_MAXIMIZEBOX As Long = &H10000 'Maximize-Box (Titelleiste)

Private Const SW_SHOW As Long = 5   'Show window

Private m_objUserForm   As Object   'Verweis auf UserForm
Private m_hWndForm      As Long     'Fenster-Handle der UserForm


Private Sub Class_Terminate()
'Das Terminate-Ereignis tritt auf, nachdem das Objekt entladen wurde.
    
  'Verweis (Speicher) freigeben
    Set m_objUserForm = Nothing
End Sub

Public Property Set Form(ByVal objForm As Object)
'UserForm Fensterstil |fffd|ndern
  
  Dim nStyle As Long
  
  'Verweis auf die UserForm setzen (Private Variable)
    Set m_objUserForm = objForm
  
  'Fenster-Handle der UserForm ermitteln
    m_hWndForm = FindWindow(vbNullString, m_objUserForm.Caption)
  
    If m_hWndForm <> 0 Then
      'UserForm Fensterstil (Window Style) ermitteln:
        nStyle = GetWindowLong(m_hWndForm, GWL_STYLE)
      
        nStyle = nStyle Or WS_THICKFRAME Or WS_SYSMENU Or _
            WS_MINIMIZEBOX Or WS_MAXIMIZEBOX
  
      'UserForm Fensterstil (Window Style) |fffd|ndern:
      '(Minimieren, Maximieren, Resize)
        SetWindowLong m_hWndForm, GWL_STYLE, nStyle
      
      'Show UserForm:
        ShowWindow m_hWndForm, SW_SHOW
        DrawMenuBar m_hWndForm
        SetFocus m_hWndForm
    End If
  
End Property

Public Property Get gIsIconic() As Boolean
  If m_hWndForm <> 0 Then
      gIsIconic = CBool(IsIconic(m_hWndForm))
  End If
End Property

Public Property Get gIsZoomed() As Boolean
  If m_hWndForm <> 0 Then
      gIsZoomed = CBool(IsZoomed(m_hWndForm))
  End If
End Property
Attribute VB_Name = "finde_Namen"
'Stanislav Wischniak
'Oktober 2006

'Das Makro soll helfen die Personal|fffd|nderungen mit der ILIAS-Verwaltungsliste zu vergleichen.

'Es findet ausgew|fffd|hlte Namen und kennzeichnet sie in der "Users"-Tabelle durch die |fffd|nderung des
'Status in der ersten Spalte auf 'Update'. Die ausgew|fffd|hlten Namen werden dabei markiert.

'Die ausgew|fffd|hlten Namen k|fffd|nnen dabei in einer parallel ge|fffd|ffneten Excel-Datei verbleiben, solange
'die Zieldatei mit dem Code (diese Datei) ge|fffd|ffnet ist.

'Vorgabe f|fffd|r die Quelldatei: die Reihenfolge der Spalten ist (anders als in der Zieldatei) "Lastname|Firstname".

'Orange         - Name nicht in der Liste
'Hellorange     - Name gefunden, Vorname trifft nicht zu
'Gr|fffd|n           - Nachname und Vorname treffen zu, Wert aus Spalte 1 wurde auf "Update" gesetzt.

'Update: 10.07.2007 Spaltennummern angepasst an die neue Version der Tabelle.

Private Sub Finde_Namen()
        
    Set ws = ActiveWorkbook.ActiveSheet
    Set wsUsers = ThisWorkbook.Worksheets("Users")
    Dim firstrow As Integer, countrows As Integer, firstcolumn As Integer
    Dim fname As String, sname As String '(first name = Vorname, surname = Nachname)

    'Berechnet die ausgew|fffd|hlten Zellen
    firstrow = Selection.Range("A1").row
    firstcolumn = Selection.Range("A1").Column
    countrows = Selection.Rows.count
    
    For i = firstrow To firstrow + countrows - 1 Step 1
        'Fenster scrollt nach unten
        If i >= 15 Then
            ActiveWindow.ScrollRow = i - 6
        End If
        'F|fffd|rbt Namen Orange ein. Die erledigten werden sp|fffd|ter zur|fffd|ckgesetzt.
        ws.Range(Cells(i, firstcolumn), Cells(i, firstcolumn + 1)).Interior.ColorIndex = 46
        
        sname = ws.Cells(i, firstcolumn).Value
        fname = ws.Cells(i, firstcolumn + 1).Value
        'MsgBox "Davor!" & Chr(13) & "Nachname: " & sname & Chr(13) & "Vorname: " & fname
        sname = UmlauteEntfernen(Trim(sname))
        fname = UmlauteEntfernen(Trim(fname))
        'MsgBox "Danach!" & Chr(13) & "Nachname: " & sname & Chr(13) & "Vorname: " & fname
        
        'Die 'Users'-Tabelle wird nach dem richtigen Namen durchsucht
        For j = 2 To 3000 Step 1
            'Abbruch, falls kein Name (Spalte 10) mehr da (Ende der Liste)
            If wsUsers.Cells(j, 10).Value = "" Then
                Exit For
            End If
            'Wenn der Nachname und der Vorname aus der Auswahl mit
            'den Namen aus der 'Users'-Tabelle |fffd|bereistimmen, wird
            'in der 'Users'-Tabelle in der ersten Spalte und der
            'entsprechenden Zeile der Wert auf "Update" gesetzt.
            If sname = UmlauteEntfernen(wsUsers.Cells(j, 10).Value) Then
                'Zutreffende Nachnamen werden in Hellorange eingef|fffd|rbt
                ws.Cells(i, firstcolumn).Interior.ColorIndex = 44
                
                If fname = UmlauteEntfernen(wsUsers.Cells(j, 9).Value) Then
                    wsUsers.Cells(j, 1).Value = "Update"
                    'Die gefundenen werden wieder in Gr|fffd|n eingef|fffd|rbt
                    ws.Range(Cells(i, firstcolumn), Cells(i, firstcolumn + 1)).Interior.ColorIndex = 4
                    Exit For
                End If
            End If
        Next j
        
    Next i
End Sub

'Bereinigt die Namen von Umlauten
Public Function UmlauteEntfernen(txt As String) As String
    Dim s As String, char As String
    Dim i As Long, Length As Long
    
    Length = Len(txt)
    s = ""
    'Alles klein
    txt = LCase(txt)
    
    For i = 1 To Length
        char = Mid(txt, i, 1)
        
        Select Case Asc(char)
            Case Asc("|fffd|")
                s = s & "ae"
                Length = Length + 1
            Case Asc("|fffd|")
                s = s & "oe"
                Length = Length + 1
            Case Asc("|fffd|")
                s = s & "ue"
                Length = Length + 1
            Case Asc("|fffd|")
                s = s & "ss"
                Length = Length + 1
            Case Else
                s = s & char
                Length = Length + 1
        End Select
    Next i
    UmlauteEntfernen = s
End Function

Function login()
    
    'fname = Selection.Range("A1").Row
    'lname = Selection.Range("A1").Row

End Function
Attribute VB_Name = "globalFunctions"
Public Function FillNodeTitles(nodeTitles As Variant, sheetname As String)

Dim declarationWorkSheet As Worksheet
Set declarationWorkSheet = ThisWorkbook.Worksheets(sheetname)
titleRows = declarationWorkSheet.Rows.count

For rowCounter = 0 To titleRows - 1
    'Assumes no blank column names
    If Trim(declarationWorkSheet.Cells(rowCounter + 1, 1).Value) = "" Then Exit For
Next rowCounter

ReDim nodeTitles(rowCounter, 1, 1) As String
For i = 2 To rowCounter
    nodeTitles(i, 0, 0) = declarationWorkSheet.Cells(i, 1).Value
    nodeTitles(i, 1, 0) = declarationWorkSheet.Cells(i, 2).Value
    If declarationWorkSheet.Cells(i, 3).Value = "" Then
        nodeTitles(i, 1, 1) = "-"
    Else
        nodeTitles(i, 1, 1) = declarationWorkSheet.Cells(i, 3).Value
    End If
Next i
End Function


Public Function getRealName(nodeTitles As Variant, required As Variant, columnName As String)

ReDim required(1, 1) As String

For i = 0 To UBound(nodeTitles)
Debug.Print (coloumName & nodeTitles(1, 1, 0))
If nodeTitles(i, 0, 0) = columnName Then
        required(0, 0) = nodeTitles(i, 1, 0)
        required(0, 1) = nodeTitles(i, 1, 1)
    Exit For
End If

Next i

End Function




' InQuest injected base64 decoded content
' ~`ZrD

INQUEST-PP=macro
