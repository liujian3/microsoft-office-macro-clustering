Attribute VB_Name = "AutoOpen"










'Diane--Translation worksheet is hidden and protected with the password "Translation" (case-sensitive!!!)
'This is so users don't accidentally delete things if they end up unhiding the worksheet
'Also note, workbook names are derived from named ranges which are set during the creation of the ML from the asapdb.exe

'2/9--Diane--redid code strings for translation lookup

    Public vaArr_QAdb As Variant
    Public vaArr_Menu As Variant
    
'These hold the worksheet names...they're referenced all over
Public gsMasterListName As String
Public gsBaselineName As String
Public gsCycleName As String
Public gsIntegrationName As String
Public gsEUPName As String
Public gsJob1Name As String
Public gsJob2Name As String
Public gsSAPToolbarName As String
Public gsExcelCountryCode As Integer

'Public variable for International settings
Public gIntlOffset As Integer
'Shah added this Win32API calls for getting the DBVersion
Declare Function RegCloseKey Lib "advapi32.dll" (ByVal hKey As Long) As Long
Attribute RegCloseKey.VB_ProcData.VB_Invoke_Func = " \n14"
Declare Function RegOpenKeyEx Lib "advapi32.dll" Alias "RegOpenKeyExA" (ByVal hKey As Long, ByVal lpSubKey As String, ByVal ulOptions As Long, ByVal samDesired As Long, phkResult As Long) As Long
Attribute RegOpenKeyEx.VB_ProcData.VB_Invoke_Func = " \n14"
Declare Function RegQueryValueEx Lib "advapi32.dll" Alias "RegQueryValueExA" (ByVal hKey As Long, ByVal lpValueName As String, ByVal lpReserved As Long, lpType As Long, lpData As Any, lpcbData As Long) As Long         ' Note that if you declare the lpData parameter as String, you must pass it By Value.
Attribute RegQueryValueEx.VB_ProcData.VB_Invoke_Func = " \n14"

' Registry constants
Global Const dhcRegSz = 1
Global Const dhcKeyRead = &H20019
Global Const dhcHKeyCurrentUser = &H80000001
Sub Auto_Open()
Attribute Auto_Open.VB_ProcData.VB_Invoke_Func = " \n14"
    
    '**********************************************************************************************
    'Functionality added by Jens. Do not remove !
    vaArr_QAdb = Worksheets(1).[G1:G65530]
    vaArr_Menu = Worksheets(2).[K1:K65530]
    '**********************************************************************************************

    Dim strLanguage As String 'Value returned from registry
    Dim strError As String 'Error returned from reading registry
    'First set up the offset when referencing strings
    GetKeyValue HKEY_CURRENT_USER, gsRegKeyQADB, gsRegValLanguage, strLanguage, strError
    If strError = "" Then     'We successfully read the registry, so use the value
      Select Case UCase(strLanguage)
        Case "ENGLISH"
          gIntlOffset = 1
        Case "GERMAN"
          gIntlOffset = 2
        Case "SPANISH"
          gIntlOffset = 3
        Case "FRENCH"
          gIntlOffset = 4
        Case Else 'Default to English if all else fails
          gIntlOffset = 1
      End Select
        'But also store the Excel application language for when we add formulas to the spreadsheets so we use the local Excel langauge
      strLanguage = Application.International(xlCountryCode)
      Select Case strLanguage
        Case "1" 'English
          gsExcelCountryCode = 1
        Case "49" 'German
          gsExcelCountryCode = 2
        Case "34" 'Spanish
          gsExcelCountryCode = 3
        Case "33" 'French
          gsExcelCountryCode = 4
        Case Else 'Default to English if all else fails
          gsExcelCountryCode = 1
      End Select
    Else
    'If we couldn't read the registry key, show errors in the correct language version of Excel
      strLanguage = Application.International(xlCountryCode)
      Select Case strLanguage 'Set both the Excel language and the qadb language variables
        Case "1" 'English
          gIntlOffset = 1
          gsExcelCountryCode = 1
        Case "49" 'German
          gIntlOffset = 2
          gsExcelCountryCode = 2
        Case "34" 'Spanish
          gIntlOffset = 3
          gsExcelCountryCode = 3
        Case "33" 'French
          gIntlOffset = 4
          gsExcelCountryCode = 4
        Case Else 'Default to English if all else fails
          gIntlOffset = 1
          gsExcelCountryCode = 1
      End Select
    End If
    gsMasterListName = Evaluate("MasterListName")
    gsBaselineName = Evaluate("BaselineName")
    gsCycleName = Evaluate("CName")
    gsIntegrationName = Evaluate("IName")
    gsEUPName = Evaluate("EUPName")
    gsJob1Name = Evaluate("Job1Name")
    gsJob2Name = Evaluate("Job2Name")
    gsSAPToolbarName = Evaluate("SAPToolbarName")
    MakeToolbar 'Make the toolbar and add the buttons
    Worksheets("Translation").Visible = False
    Worksheets("Logon_Info").Visible = False
    '10/21--Diane Schaffer--added this line so Outline toolbarbutton gets updated correctly for different sheets
    ActiveWorkbook.OnSheetActivate = ActiveWorkbook.Name & "!AutoOpen.TestForOutline"
    Worksheets(2).Range("A65000").Value = "y"
    Worksheets(1).Activate
 
 End Sub

Sub Auto_Close()
Attribute Auto_Close.VB_ProcData.VB_Invoke_Func = " \n14"
  Dim tb As Toolbar
  
  On Error GoTo Exit_Auto_Close:
  
  
  For Each tb In Application.Toolbars
    If tb.Name = gsSAPToolbarName Then tb.delete
  Next tb
Exit_Auto_Close:
  Set tb = Nothing
End Sub

'Written by Diane Schaffer, 2/16/98
Sub MakeToolbar()
Attribute MakeToolbar.VB_ProcData.VB_Invoke_Func = " \n14"
  Dim tb As Toolbar
  'Dim sStatusBarText As String
  'Dim sToolTipText As String
  'Dim sToolbarName As String
  'Dim lToolbuttonNumber As Long
  'Dim lFaceId As Long
  Dim MyControl As Object
  On Error GoTo Exit_MakeToolbar:
  'Clear the old SAP Masterlist toolbar
  For Each tb In Application.Toolbars
    If tb.Name = gsSAPToolbarName Then tb.delete
  Next tb
  'Recreate the SAP Masterlist toolbar
  Toolbars.Add Name:=gsSAPToolbarName
  Toolbars(gsSAPToolbarName).Visible = True
  With Application
    .ShowToolTips = True
    .LargeButtons = False
    .ColorButtons = True
  End With
    ' One of xlTop, xlLeft, xlRight, xlBottom, or xlFloating.
  Toolbars(gsSAPToolbarName).Position = xlRight
'Start adding buttons
  'verstr = GetVersionDB
  If Not fOpenBitmapLibrary() Then
    Dim sMsgTxt As String
    sMsgTxt = "Library Bpml.dll could not be found!" & Chr$(13) & _
              "Failed to initialize toolbar and no access to IMG links."
    MsgBox sMsgTxt, vbExclamation + vbOKOnly
  End If
 'verstr = GetVersionDB
  verstr = "4"
  If verstr = "4" Then
    Create_Button 213, 218, 282, 283, 284, 1, "LaunchDoc"
    Create_Button 214, 219, 285, 286, 287, 2, "MakeOutline"
    Create_Button 215, 220, 288, 289, 290, 3, "FillAllChildren"
    
    'Shah added a new button for Logon to R/3 6/10/99...
    'Create_Button 320, 320, 291, 318, 319, 4, "LOGON"
    Create_Button 216, 221, 291, 292, 293, 4, "Button_Trans"
    'Create_Button 302, 302, 291, 303, 304, 5, "Button_ProView"
    'Create_Button 308, 308, 291, 309, 310, 6, "Button_NoProView"
    'Create_Button 311, 311, 291, 312, 313, 5, "Button_WholeView"
    Create_Button 317, 317, 291, 318, 319, 5, "pSAPLogOff"
    'Create_Button 217, 222, 294, 295, 296, 6, "LaunchHelp"
    giButtonIndex = 6
  ElseIf verstr = "3" Then
    Create_Button 213, 218, 282, 283, 284, 1, "LaunchDoc"
    Create_Button 214, 219, 285, 286, 287, 2, "MakeOutline"
    Create_Button 215, 220, 288, 289, 290, 3, "FillAllChildren"
    Create_Button 216, 221, 291, 292, 293, 4, "Button_Trans"
    'Create_Button 217, 222, 294, 295, 296, 5, "LaunchHelp"
    Create_Button 317, 317, 291, 318, 319, 5, "pSAPLogOff"
    giButtonIndex = 6
  End If
  'disable will make the bitmap disappear under NT
  'Application.Toolbars(gsSAPToolbarName).ToolbarButtons(giButtonIndex).Enabled = False
'Clean up
Exit_MakeToolbar:
  fCloseBitmapLibrary
  Set tb = Nothing
End Sub

Sub Create_Button(StaBarTx, TooTipTx, TooBarNa, TooButNum, FaceID, posi, Routine)
Attribute Create_Button.VB_ProcData.VB_Invoke_Func = " \n14"
  sStatusBarText = Worksheets("Translation").Cells(StaBarTx, gIntlOffset).Value
  sToolTipText = Worksheets("Translation").Cells(TooTipTx, gIntlOffset).Value
  'Toolbar to copy picture from must use local name
  sToolbarName = Worksheets("Translation").Cells(TooBarNa, gsExcelCountryCode).Value
  lToolbuttonNumber = Worksheets("Translation").Cells(TooButNum, gIntlOffset).Value
  lFaceId = Worksheets("Translation").Cells(FaceID, gIntlOffset).Value
  Toolbars(gsSAPToolbarName).ToolbarButtons.Add _
                Button:=231, Before:=posi, OnAction:=Routine, _
                StatusBar:=sStatusBarText
  Toolbars(gsSAPToolbarName).ToolbarButtons(posi).Name = sToolTipText
  
  If fCopyBitmapToClipboard(VBA.Trim(Routine)) Then
    Toolbars(gsSAPToolbarName).ToolbarButtons(posi).PasteFace
  End If
  
'  If InStr(Application.Version, "7") > 0 Then
'    Toolbars(sToolbarName).ToolbarButtons(lToolbuttonNumber).CopyFace
'    Toolbars(gsSAPToolbarName).ToolbarButtons(posi).PasteFace
'  ElseIf InStr(Application.Version, "8") > 0 Then
'    Application.CommandBars(gsSAPToolbarName).Controls(posi).FaceID = lFaceId
'  End If
End Sub

'Written by Diane Schaffer, 10/20/97
'This is called on worksheet.activate to test for the proper button label
Public Sub TestForOutline()
Attribute TestForOutline.VB_ProcData.VB_Invoke_Func = " \n14"
  On Error Resume Next
  Select Case ActiveSheet.Name
    Case gsJob1Name
      Application.Toolbars(gsSAPToolbarName).ToolbarButtons(2).Enabled = False
    Case gsJob2Name
      Application.Toolbars(gsSAPToolbarName).ToolbarButtons(2).Enabled = False
    Case gsEUPName
      Application.Toolbars(gsSAPToolbarName).ToolbarButtons(2).Enabled = False
    Case Else
      Application.Toolbars(gsSAPToolbarName).ToolbarButtons(2).Enabled = True
    If ActiveSheet.Rows(5).OutlineLevel = 1 Then
      Application.Toolbars(gsSAPToolbarName).ToolbarButtons(2).Name = Worksheets("Translation").Cells(219, gIntlOffset).Value
    Else
      Application.Toolbars(gsSAPToolbarName).ToolbarButtons(2).Name = Worksheets("Translation").Cells(212, gIntlOffset).Value
    End If
  End Select
End Sub

Public Function GetVersionDB() As String
Attribute GetVersionDB.VB_ProcData.VB_Invoke_Func = " \n14"
Dim gdbDatabase As Database 'main database object
Dim gstrLocationMDB As String 'This stores the location of the database file
Dim gnDBMajor As Integer
Dim gnDBMinor As Integer
Dim gnDBMinVerMajor As Integer
Dim gnDBMinVerMinor As Integer
Dim Temp As String
Dim WorkspaceError As Integer
Dim dummy As Integer
Dim hKey As Long
Dim lngResult As Long
Dim strBuffer As String
Dim cb As Long
On Error GoTo ErrorExit
    Temp = "AcceleratedSAP Q&Adb 4.0"

    Set gwsMainWS = DBEngine.CreateWorkspace("MainWS", "Admin", vbNullString)
    'get the database location from the registry
    'gstrLocationMDB = GetSetting(Temp, "External Files", "Database Name", CurDir() & "\Qadb.mdb")
    'Shah added this Reg funcs...
    lngResult = RegOpenKeyEx(dhcHKeyCurrentUser, "Software\VB and VBA Program Settings\" & Temp & "\External Files", 0&, dhcKeyRead, hKey)
    strBuffer = Space(255)
    cb = Len(strBuffer)
    lngResult = RegQueryValueEx(hKey, "Database Name", 0&, dhcRegSz, ByVal strBuffer, cb)
    lngResult = RegCloseKey(hKey)
    gstrLocationMDB = Left(strBuffer, cb - 1)
    If gstrLocationMDB = "" Or Dir(gstrLocationMDB) = "" Then
        WorkspaceError = 1
        GoTo ErrorExit
    End If
    DBEngine.IniPath = "HKEY_CURRENT_USER\Software\VB and VBA Program Settings\" & Temp & "\External Files"
    Set gdbDatabase = gwsMainWS.OpenDatabase(gstrLocationMDB, gbDatabaseExclusive)
    WorkspaceError = 3
    On Error Resume Next
    'The first time around, the property doesn't exist
    Dim sDBInternalVersion As String
    Dim sDBMinimumVersion As String
    Dim strDBMinimumVersion As String
    sDBInternalVersion = gdbDatabase.Containers(0).Documents("UserDefined").Properties("InternalVersion")
    strDBMinimumVersion = gdbDatabase.Containers(0).Documents("UserDefined").Properties("MinimumVersion")
    ParseVersionString sDBInternalVersion, gnDBMajor, gnDBMinor
    'Call Check_Definition
    If (gnDBMajor = 3) Then
        GetVersionDB = "3" 'DBVersion = 3
    ElseIf (gnDBMajor = 4) Then
        GetVersionDB = "4" 'DBVersion = 4
    Else
        WorkspaceError = 2
        GoTo ErrorExit
    End If
    'End application
    gdbDatabase.Close
    Set gdbDatabase = Nothing
    Exit Function
ErrorExit:
    Select Case WorkspaceError
      Case 1
        dummy = MsgBox(314, 2)
        If dummy = vbOKOnly Then
          Exit Function
        End If
      Case 2
        dummy = MsgBox(315, 2)
        If dummy = vbOKOnly Then
          Exit Function
        End If
      Case Else
        dummy = MsgBox(316, 2)
        If dummy = vbOKOnly Then
          Exit Function
        End If
    End Select
End Function

Private Sub ParseVersionString(sVersion As String, ByRef nDBMajor_out As Integer, _
                ByRef nDBMinor_out As Integer)
    Dim nDotPos As Integer
    nDotPos = InStr(1, sVersion, ".")
    If nDotPos > 0 Then
        nDBMajor_out = val(Left(sVersion, nDotPos - 1))
        nDBMinor_out = val(Mid(sVersion, nDotPos + 1))
    Else
        nDBMajor_out = val(sVersion)
        nDBMinor_out = 0
    End If
End Sub

'******************************************************************************************************************************
'Automatization Macros : Show_Dialog invokes a dialog for the selection of T-Codes                                             *
'                        Set_Dot sets "x" in the highlighted cell                                                           *
'******************************************************************************************************************************

Sub Show_Dialog()
'Error Handling
On Error Resume Next

'Show Dialog!
    UserForm1.Show

End Sub

Sub Set_Dot()
'Error Handling
On Error Resume Next

'If cell already contains a dot, remove it
    If ActiveCell = "x" Then
        ActiveCell = ""
    Else
'If cell does not contain a dot, set dot
        With ActiveCell
        .Value = "x"
        End With
    End If
    
End Sub

Sub Show_Help()
    UserForm2.Show
End Sub

Attribute VB_Name = "Baseline Module"
Sub delete_Menu()


'Accelerates the search; sheet is not updated and recalculated until the building-process is accomplished
berechn_modus = Application.Calculation
aktual_modus = Application.ScreenUpdating
Application.Calculation = xlCalculationManual
Application.ScreenUpdating = False

Workbooks("d_al.xlt").Worksheets(2).Range("A5:K65500").Value = ""

Application.EnableEvents = True
    
'Calculate and Update Sheet
Application.Calculation = berechn_modus
Application.ScreenUpdating = aktual_modus
Application.StatusBar = False
End Sub

Sub adsfgrdfg()
Application.EnableEvents = True
End Sub











































































































'2/9--Diane--redid code strings for translation lookup

'11/13--Diane Schaffer--Changed this procedure to support new global functions
'
' Create_Baseline--Populates the baseline worksheet with data from the Master List worksheet
' Now we use an autofilter to determine what to copy to avoid the deletion of cells later on.
Sub Create_Baseline()
Attribute Create_Baseline.VB_Description = "Macro recorded 9/4/97 by SAP America"
Attribute Create_Baseline.VB_ProcData.VB_Invoke_Func = " \n0"
    
    Dim wkWorksheet1 As Worksheet 'Always "Master List" worksheet.
    Dim wkWorksheet2 As Worksheet '"Baseline" worksheet.
    Dim nNumColVerify As Long 'Used to store the column we're going to verify for record inclusion.
    Dim strFilterAddress As String  'Address returned by filtering
    Dim rgFilterRange As Range 'Result of filter--records to be included
    Dim nLastRow As Long 'Last record to be included.
    Dim sStatusBarText As String
    
    On Error GoTo Exit_Create_Baseline:
    
    'Turn off screenupdating for speed and appearance and give feedback to user.
    Application.ScreenUpdating = False
    Application.EnableEvents = False
    
    'Store the worksheets we're using
    Set wkWorksheet1 = ActiveSheet
    Set wkWorksheet2 = Worksheets(gsBaselineName)

    'Clear the Baseline worksheet
''' BTO 11/21/97 -- Changed gfnClearActiveSheet to gfnClearSheet
    If Not (gfnClearSheet(wkWorksheet2.Name)) Then
        GoTo Exit_Create_Baseline:
    End If
    
    wkWorksheet1.Activate
        
    'Give some user feedback
    sStatusBarText = Worksheets("Translation").Cells(224, gIntlOffset).Value
    Application.StatusBar = sStatusBarText & "..."
    
    'We need to make sure all outline levels are showing
    'Doesn't fail, even if no outline is present
    wkWorksheet1.Outline.ShowLevels 5
    
    'Check the Create Baseline column for non-blanks
    nNumColVerify = 14
    strFilterAddress = gfnFilterOutNonBlankRows(nNumColVerify, wkWorksheet1.Name)
    
    'gfnFilterOutNonBlankRows returns the address of the filtered area
    'Only continue if there were records returned
    If strFilterAddress = "" Then
        GoTo Exit_Create_Baseline:
    Else
        Set rgFilterRange = Range(strFilterAddress)
    End If
    
    'Get the last visible row in the filter
    nLastRow = rgFilterRange.Rows(rgFilterRange.Rows.Count).row
    
    'Give some user feedback
    sStatusBarText = Worksheets("Translation").Cells(225, gIntlOffset).Value & " "
    Application.StatusBar = sStatusBarText & wkWorksheet2.Name & "..."
 
    ' Copy cols 1 - 5 (A-E) to same
    gfnCopyColumns wkWorksheet2.Name, 1, 6, 1, nLastRow
    ' Copy 30-32 to 6-9 (AD-AF to G-K)
    gfnCopyColumns wkWorksheet2.Name, 32, 34, 7, nLastRow
    ' Copy 8-9 to 9-10 (H-I to I-J)
    gfnCopyColumns wkWorksheet2.Name, 10, 11, 11, nLastRow
    ' Copy cols 10-11 (J-K) to 12-13 (L-M)
    gfnCopyColumns wkWorksheet2.Name, 12, 13, 13, nLastRow
    ' Copy col 12 (L) to 33 (AG)
    gfnCopyColumns wkWorksheet2.Name, 14, 14, 35, nLastRow
    'Copy col 28-32(AB-AF) to 28-32 (AB-AF)
    gfnCopyColumns wkWorksheet2.Name, 30, 34, 30, nLastRow
    'Shah
    'We must also copy the process ID from the masterlist-Sheet to the Baseline Sheet.
    'Copy col 28-34(AB-AH) to 28-34 (AB-AH)
    gfnCopyColumns wkWorksheet2.Name, 30, 36, 30, nLastRow

    
    'Autofilter with no arguments will clear the filter created by gfnFilterOutNonBlankRows
    rgFilterRange.AutoFilter
        
Exit_Create_Baseline:
    'Clean up the windows for easier navigation
    GoHome ActiveWorkbook.Name, wkWorksheet1.Name
    GoHome ActiveWorkbook.Name, wkWorksheet2.Name

    Set wkWorksheet1 = Nothing
    Set wkWorksheet2 = Nothing
    Set rgFilterRange = Nothing

    Application.StatusBar = False
    Application.ScreenUpdating = True
    Application.EnableEvents = True
    
End Sub
Attribute VB_Name = "Bitmaps"










Option Explicit

Declare Function GetActiveWindow Lib "user32" () As Long
Attribute GetActiveWindow.VB_ProcData.VB_Invoke_Func = " \n14"
Declare Function OpenClipBoard Lib "user32" Alias "OpenClipboard" (ByVal hwnd As Long) As Long
Attribute OpenClipBoard.VB_ProcData.VB_Invoke_Func = " \n14"
Declare Function EmptyClipBoard Lib "user32" Alias "EmptyClipboard" () As Long
Attribute EmptyClipBoard.VB_ProcData.VB_Invoke_Func = " \n14"
Declare Function SetClipBoardData Lib "user32" Alias "SetClipboardData" (ByVal wFormat As Long, ByVal hMem As Long) As Long
Attribute SetClipBoardData.VB_ProcData.VB_Invoke_Func = " \n14"
Declare Function CloseClipBoard Lib "user32" Alias "CloseClipboard" () As Long
Attribute CloseClipBoard.VB_ProcData.VB_Invoke_Func = " \n14"
Declare Function LoadBitmap Lib "user32" Alias "LoadBitmapA" (ByVal hInstance As Long, ByVal lpBitmapName As String) As Long
Attribute LoadBitmap.VB_ProcData.VB_Invoke_Func = " \n14"
Declare Function LoadLibrary Lib "kernel32" Alias "LoadLibraryA" (ByVal lpLibFileName As String) As Long
Attribute LoadLibrary.VB_ProcData.VB_Invoke_Func = " \n14"
Declare Function FreeLibrary Lib "kernel32" (ByVal hLibModule As Long) As Long
Attribute FreeLibrary.VB_ProcData.VB_Invoke_Func = " \n14"
  
Declare Function CreateCompatibleBitmap Lib "gdi32" (ByVal hdc As Long, ByVal nWidth As Long, ByVal nHeight As Long) As Long
Attribute CreateCompatibleBitmap.VB_ProcData.VB_Invoke_Func = " \n14"
Declare Function CreateBitmap Lib "gdi32" (ByVal nWidth As Long, ByVal nHeight As Long, ByVal nPlanes As Long, ByVal nBitCount As Long, lpBits As Any) As Long
Attribute CreateBitmap.VB_ProcData.VB_Invoke_Func = " \n14"
Declare Function CreateCompatibleDC Lib "gdi32" (ByVal hdc As Long) As Long
Attribute CreateCompatibleDC.VB_ProcData.VB_Invoke_Func = " \n14"
Declare Function CreateDC Lib "gdi32" Alias "CreateDCA" (ByVal lpDriverName As String, ByVal lpDeviceName As String, ByVal lpOutput As String, lpInitData As Long) As Long
Attribute CreateDC.VB_ProcData.VB_Invoke_Func = " \n14"
Declare Function DeleteDC Lib "gdi32" (ByVal hdc As Long) As Long
Attribute DeleteDC.VB_ProcData.VB_Invoke_Func = " \n14"
Declare Function ReleaseDC Lib "user32" (ByVal hwnd As Long, ByVal hdc As Long) As Long
Attribute ReleaseDC.VB_ProcData.VB_Invoke_Func = " \n14"
Declare Function BitBlt Lib "gdi32" (ByVal hDestDC As Long, ByVal x As Long, ByVal y As Long, ByVal nWidth As Long, ByVal nHeight As Long, ByVal hSrcDC As Long, ByVal xSrc As Long, ByVal ySrc As Long, ByVal dwRop As Long) As Long
Attribute BitBlt.VB_ProcData.VB_Invoke_Func = " \n14"
Declare Function StretchBlt Lib "gdi32" (ByVal hdc As Long, ByVal x As Long, ByVal y As Long, ByVal nWidth As Long, ByVal nHeight As Long, ByVal hSrcDC As Long, ByVal xSrc As Long, ByVal ySrc As Long, ByVal nSrcWidth As Long, ByVal nSrcHeight As Long, ByVal dwRop As Long) As Long
Attribute StretchBlt.VB_ProcData.VB_Invoke_Func = " \n14"
Declare Function SelectObject Lib "gdi32" (ByVal hdc As Long, ByVal hObject As Long) As Long
Attribute SelectObject.VB_ProcData.VB_Invoke_Func = " \n14"
Declare Function GetPixel Lib "gdi32" (ByVal hdc As Long, ByVal x As Long, ByVal y As Long) As Long
Attribute GetPixel.VB_ProcData.VB_Invoke_Func = " \n14"
Declare Function SetBkColor Lib "gdi32" (ByVal hdc As Long, ByVal crColor As Long) As Long
Attribute SetBkColor.VB_ProcData.VB_Invoke_Func = " \n14"
Declare Function SetTextColor Lib "gdi32" (ByVal hdc As Long, ByVal crColor As Long) As Long
Attribute SetTextColor.VB_ProcData.VB_Invoke_Func = " \n14"
Declare Function SetBkMode Lib "gdi32" (ByVal hdc As Long, ByVal nBkMode As Long) As Long
Attribute SetBkMode.VB_ProcData.VB_Invoke_Func = " \n14"
Declare Function ExtFloodFill Lib "gdi32" (ByVal hdc As Long, ByVal x As Long, ByVal y As Long, ByVal crColor As Long, ByVal wFillType As Long) As Long
Attribute ExtFloodFill.VB_ProcData.VB_Invoke_Func = " \n14"
Declare Function Rectangle Lib "gdi32" (ByVal hdc As Long, ByVal X1 As Long, ByVal Y1 As Long, ByVal X2 As Long, ByVal Y2 As Long) As Long
Attribute Rectangle.VB_ProcData.VB_Invoke_Func = " \n14"
Declare Function CreateSolidBrush Lib "gdi32" (ByVal crColor As Long) As Long
Attribute CreateSolidBrush.VB_ProcData.VB_Invoke_Func = " \n14"
Declare Function DeleteObject Lib "gdi32" (ByVal hObject As Long) As Long
Attribute DeleteObject.VB_ProcData.VB_Invoke_Func = " \n14"
Declare Function GetSysColor Lib "user32" (ByVal nIndex As Long) As Long
Attribute GetSysColor.VB_ProcData.VB_Invoke_Func = " \n14"

Const COLOR_BTNFACE = 15

Const SRCCOPY = &HCC0020

Const CF_BITMAP As Long = 2


Dim ghBitmapInstance As Long

Public Function fOpenBitmapLibrary() As Boolean
Attribute fOpenBitmapLibrary.VB_ProcData.VB_Invoke_Func = " \n14"
    ghBitmapInstance = LoadLibrary("Bpml.dll")
    fOpenBitmapLibrary = ghBitmapInstance <> 0
End Function


Public Sub fCloseBitmapLibrary()
Attribute fCloseBitmapLibrary.VB_ProcData.VB_Invoke_Func = " \n14"
    If ghBitmapInstance <> 0 Then
        FreeLibrary ghBitmapInstance
        ghBitmapInstance = 0
    End If
End Sub


Public Function fCopyBitmapToClipboard(ABitmap As String) As Boolean
Attribute fCopyBitmapToClipboard.VB_ProcData.VB_Invoke_Func = " \n14"
    Dim lRC As Long
    Dim bRC As Boolean
    Dim hwnd As Long
    Dim hBitMap As Long
    Dim hData As Long
    
    On Error Resume Next

    fCopyBitmapToClipboard = False
    
    If ghBitmapInstance <> 0 Then
        hwnd = GetActiveWindow()
        hBitMap = LoadBitmap(ghBitmapInstance, ABitmap)
        bRC = OpenClipBoard(hwnd)
        If bRC And (hBitMap <> 0) Then
            lRC = EmptyClipBoard()
            hData = fBitmapToClipboardFormat(hBitMap)
            If hData <> 0 Then
                lRC = SetClipBoardData(CF_BITMAP, hData)
            End If
            bRC = CloseClipBoard
            fCopyBitmapToClipboard = lRC <> 0
        End If
    End If
End Function

Private Function fBitmapToClipboardFormat(ABitmap As Long) As Long
    Dim hScreenDC As Long
    Dim hBitmapDC As Long
    Dim hMonoDC As Long
    Dim hMonoBitmap As Long
    Dim hNewDC As Long
    Dim hNewBitmap As Long
    Dim hBrush As Long
    Dim iWidth As Integer, iHeight As Integer
    Dim clTransparent As Long, clBack As Long, clText As Long, clFace As Long
    Dim lRC As Long
    
    On Error GoTo Exit_fBitmapToClipboardFormat
    
    fBitmapToClipboardFormat = 0
    iWidth = 16
    iHeight = 16
    
    hScreenDC = CreateDC("DISPLAY", "", "", 0)
    
    'prepare source bitmap
    hBitmapDC = CreateCompatibleDC(hScreenDC)
    lRC = SelectObject(hBitmapDC, ABitmap)
    clTransparent = GetPixel(hBitmapDC, 15, 15)
    clFace = GetSysColor(COLOR_BTNFACE)
    
    'prepare mono bitmap
    hMonoDC = CreateCompatibleDC(hScreenDC)
    hMonoBitmap = CreateBitmap(iWidth, iHeight, 1, 1, 0)
    lRC = SelectObject(hMonoDC, hMonoBitmap)
    
    clBack = SetBkColor(hBitmapDC, clTransparent)
    lRC = BitBlt(hMonoDC, 0, 0, iWidth, iHeight, hBitmapDC, 0, 0, SRCCOPY)
    SetBkColor hBitmapDC, clBack
    
    'prepare Destination
    hNewDC = CreateCompatibleDC(hScreenDC)
    hNewBitmap = CreateCompatibleBitmap(hScreenDC, iWidth, iHeight)
    lRC = SelectObject(hNewDC, hNewBitmap)
    
    hBrush = CreateSolidBrush(clFace)
    SelectObject hNewDC, hBrush
    
    lRC = StretchBlt(hNewDC, 0, 0, iWidth, iHeight, hBitmapDC, 0, 0, iWidth, iHeight, SRCCOPY)
    clText = SetTextColor(hNewDC, 0)
    clBack = SetBkColor(hNewDC, &HFFFFFF)
    lRC = StretchBlt(hNewDC, 0, 0, iWidth, iHeight, hMonoDC, 0, 0, iWidth, iHeight, &HE20746)
        
    clText = SetTextColor(hNewDC, clText)
    clBack = SetBkColor(hNewDC, clBack)
                
    fBitmapToClipboardFormat = hNewBitmap
    
Exit_fBitmapToClipboardFormat:
    DeleteObject hMonoBitmap
    DeleteObject hBrush
    DeleteDC hMonoDC
    DeleteDC hBitmapDC
    DeleteDC hNewDC
    ReleaseDC 0, hScreenDC
End Function

Attribute VB_Name = "Chield_Cells"
Sub FillAllChildren()
Dim lCurrentRow As Long, lastrow As Long, lActualRow As Long
Dim iMaxColumnCount As Integer

On Error GoTo Scope_Error

'Accelerates the search; sheet is not updated and recalculated until the building-process is accomplished
berechn_modus = Application.Calculation
aktual_modus = Application.ScreenUpdating
Application.Calculation = xlCalculationManual
Application.ScreenUpdating = False


If ActiveSheet.Name = Worksheets(1).Name Then
    iMaxColumnCount = 6
ElseIf ActiveSheet.Name = Worksheets(2).Name Then
    iMaxColumnCount = 10
End If

lCurrentRow = ActiveCell.row

For iSearch = 1 To iMaxColumnCount
    If Cells(lCurrentRow, iSearch) <> "" Then
            iCurrentColumn = iSearch
            Exit For
    End If
Next

iRoleColumn = ActiveCell.Column

'Wenn FillAllChildren innerhalb des Men|fffd|s (inklusive T-Code (+1)) aufgerufen wird, mu|fffd| Sub beendet werden.
If iRoleColumn > iMaxColumnCount + 1 Then
    
    If iMaxColumnCount = 10 Then
    'Range-Objekt f|fffd|r die Suche der letzten Zeile des Submen|fffd|s
        Set arr = ThisWorkbook.Worksheets(2).Range(Cells(1, iCurrentColumn), Cells(61719, iCurrentColumn))
    Else
        Set arr = ThisWorkbook.Worksheets(1).Range(Cells(1, iCurrentColumn), Cells(61719, iCurrentColumn))
    End If
    
    'j ist einfache Schleifenvariable, die die Anzahl der durchsuchten Reihen ab lCurrentRow angibt
    Order = False
    j = 0
            Do
            j = j + 1
            
            'Wenn das Submen|fffd| ab iCurrentColumn 2 beginnt, m|fffd|ssen alle Zellen, die sich links unterhalb des Zellcursors befinden
            'auf Ihren Inhalt hin |fffd|berpr|fffd|ft werden. Enthalten sie Eintr|fffd|ge, endet das Submen|fffd| hier
            If iCurrentColumn > 1 Then
                For m = 1 To iCurrentColumn - 1
                bruch = False
                    If Cells(lCurrentRow + j + 1, iCurrentColumn - m) <> "" Then
                        bruch = True
                        Exit For
                    End If
                Next m
            End If
            Loop Until (arr(lCurrentRow + j, 1) = "" And arr(lCurrentRow + j + 1, 1) <> "" And Order = False) Or j + lCurrentRow > 61719 Or (bruch = True And Order = False)
    
    'Letzte lCurrentRow des Submen|fffd|s
    lastrow = lCurrentRow + j
        
    If lastrow - lCurrentRow > 600 Then
        MsgBox "The highlighted submenu contains too many entries", vbExclamation + vbOKOnly
        
        ActiveCell = ""
        Application.EnableEvents = True
        
        'Calculate and Update Sheet
        Application.Calculation = berechn_modus
        Application.ScreenUpdating = aktual_modus
        
        Exit Sub
    End If
      
    'Falls kein Submen|fffd| existiert, setze nur die Transaktion in scope, in deren lCurrentRow sich der Zellcursor befindet
    If iCurrentColumn > 1 Then
            If Cells(lCurrentRow, iCurrentColumn) <> "" And Cells(lCurrentRow + 1, iCurrentColumn) <> "" Or Cells(lCurrentRow + 1, iCurrentColumn - 1) <> "" Then
                
                'Event-Handling f|fffd|r das updaten der Zellen wieder aktivieren
                Application.EnableEvents = True
                
                'Calculate and Update Sheet
                Application.Calculation = berechn_modus
                Application.ScreenUpdating = aktual_modus
                
                Exit Sub
            End If
    End If
    
    'User-Dialog. Meldungsfenster, in dem der User |fffd|ber beabsichtigte Aktion informiert wird
    If ActiveCell = "" Then
        mbResult = MsgBox("Wollen Sie wirklich alle untergeordneten Transaktionen von " & Cells(lCurrentRow, iCurrentColumn) & " deaktivieren?", vbExclamation + vbYesNo)
            If mbResult = vbNo Then
                Exit Sub
            End If
    Else
        mbResult = MsgBox("Wollen Sie wirklich '" & ActiveCell & "' f|fffd|r alle untergeordneten Transaktionen von " & Cells(lCurrentRow, iCurrentColumn) & " setzen?", vbExclamation + vbYesNo)
            If mbResult = vbNo Then
                Exit Sub
            End If
    End If
    
    'Event-Handling mu|fffd| ausgeschaltet sein, damit Update_Values_XXXX sich nicht rekursiv aufruft
    Application.EnableEvents = False
    
        'Wenn Submen|fffd| im Men|fffd|-Worksheet liegt
        If iMaxColumnCount = 10 Then
            
            'Ab hier werden alle T-Codes im Teilbereichsmen|fffd| durchlaufen und |fffd|berpr|fffd|ft, ob sie bereits in-scope gesetzt wurden oder nicht
            For lActualRow = lCurrentRow + 1 To lastrow
            
            Application.StatusBar = "Bitte gedulden Sie sich. Aktualisierung... " & CInt((lActualRow - lCurrentRow) / (lastrow - lCurrentRow) * 100) & "%"
                'Wenn T-Code (iCurrentColumn 11) vorhanden ist (keine Leerzeile)
                If Cells(lActualRow, 11) <> "" Then
                    
                    If ActiveCell <> "" Then
                        
                        'Wenn noch nicht in-scope gesetzt wurde, setze in-scope. Ansonsten setze scope zur|fffd|ck.

                            Cells(lActualRow, iRoleColumn) = Cells(lCurrentRow, iRoleColumn)
                        
                        'Setze alle gleichen T-Codes im Men|fffd| in scope
                        Update_Values_Menue iRoleColumn, lActualRow
                    Else
                              
                            Cells(lActualRow, iRoleColumn) = Cells(lCurrentRow, iRoleColumn)
                        
                        'Setze alle gleichen T-Codes im Men|fffd| zur|fffd|ck
                        Update_Values_Menue iRoleColumn, lActualRow
                    End If
                    
                End If
            Next
                    
        'Wenn Submen|fffd| im QAdb Worksheet liegt
        Else
            'Ab hier werden alle T-Codes im Teilbereichsmen|fffd| durchlaufen und |fffd|berpr|fffd|ft, ob sie bereits in-scope gesetzt wurden oder nicht
            For lActualRow = lCurrentRow + 1 To lastrow
            
            Application.StatusBar = "Bitte gedulden Sie sich. Aktualisierung... " & CInt((lActualRow - lCurrentRow) / (lastrow - lCurrentRow) * 100) & "%"
                'Wenn T-Code (iCurrentColumn 11) vorhanden ist (keine Leerzeile)
                If Cells(lActualRow, 7) <> "" Then
                    
                    If ActiveCell <> "" Then
                        'Wenn noch nicht in-scope gesetzt wurde, setze in-scope. Ansonsten setze scope zur|fffd|ck.
                        
                            Cells(lActualRow, iRoleColumn) = Cells(lCurrentRow, iRoleColumn)
                        
                        'Setze alle gleichen T-Codes im Men|fffd| in scope
                        Update_Values_QAdb iRoleColumn, lActualRow
                    Else
                              
                            Cells(lActualRow, iRoleColumn) = Cells(lCurrentRow, iRoleColumn)
                        
                        'Setze alle gleichen T-Codes im Men|fffd| zur|fffd|ck
                        Update_Values_QAdb iRoleColumn, lActualRow
                    End If
                    
                End If
            Next
        End If
     
End If

'L|fffd|sche den in der Hierachie gemachten Eintrag, da sonst un|fffd|bersichtlich
Cells(lCurrentRow, iRoleColumn) = ""

Application.EnableEvents = True
    
'Calculate and Update Sheet
Application.Calculation = berechn_modus
Application.ScreenUpdating = aktual_modus
Application.StatusBar = False

Set arr = Nothing
Exit Sub

Scope_Error:
Set arr = Nothing
Application.EnableEvents = True
Application.StatusBar = False

'Calculate and Update Sheet
Application.Calculation = berechn_modus
Application.ScreenUpdating = aktual_modus

MsgBox "Es ist ein Laufzeitfehler aufgetreten." & Chr(13) & "Bitte schlie|fffd|en Sie die Berechtigungsliste und wiederholen Sie den Vorgang.", vbOKOnly + vbExclamation

End Sub

Sub Update_Values_Menue(ByVal Column As Long, ByVal row As Long)

Dim T_Code As String
Dim zelle, rgTargetCell As Range
Dim lLastRow As Long
Dim i As Long

'row = 6
'Column = 12
'Get the affected T_Code and calculate the Column-Difference between the T_Code-Column and the Active Column
T_Code = Range("K" & row).Value

On Error Resume Next

Column_QAdb = Column - 3

'to avoid multiple calls from Worksheet_Change
Application.EnableEvents = False

'rgTargetCell is the Cell which is hit in the Sheet
Set rgTargetCell = Cells(row, Column)

For i = 1 To 61719
    If vaArr_Menu(i, 1) = T_Code Then
        Cells(i, Column) = rgTargetCell
    End If
Next
    
'Activate QAdb-Worksheet, because Cells always refer to active sheet
Worksheets(1).Activate

With Worksheets(1)
    For i = 1 To 35000
        If vaArr_QAdb(i, 1) = T_Code Then
            .Cells(i, Column_QAdb) = rgTargetCell
        End If
    Next
End With

Worksheets(2).Activate

Set rgTargetCell = Nothing

'Enable Event-Handling again
Application.EnableEvents = True

End Sub

Sub Update_Values_QAdb(ByVal Column As Long, ByVal row As Long)

Dim T_Code As String
Dim zelle, rgTargetCell As Range
Dim lLastRow As Long
Dim i As Long

Column_Menu = Column + 3

'Get the affected T_Code and calculate the Column-Difference between the T_Code-Column and the Active Column
T_Code = Range("G" & row).Value


On Error Resume Next

'to avoid multiple calls from Worksheet_Change
Application.EnableEvents = False

'rgTargetCell is the Cell which is hit in the Sheet
Set rgTargetCell = Cells(row, Column)

For i = 1 To 35000
    If vaArr_QAdb(i, 1) = T_Code Then
        Cells(i, Column) = rgTargetCell
    End If
Next
    
Worksheets(2).Activate

With Worksheets(2)
    For i = 1 To 61719
        If vaArr_Menu(i, 1) = T_Code Then
            .Cells(i, Column_Menu) = rgTargetCell
        End If
    Next
End With
    
Worksheets(1).Activate

Set rgTargetCell = Nothing

'Enable Event-Handling again
Application.EnableEvents = True

End Sub
Attribute VB_Name = "Cn Module"














































































































'2/9--Diane--redid code strings for translation lookup

Option Explicit

Sub Create_C1()
Attribute Create_C1.VB_ProcData.VB_Invoke_Func = " \n14"
    Create_Cn 1, 15
End Sub

Sub Create_C2()
Attribute Create_C2.VB_ProcData.VB_Invoke_Func = " \n14"
    Create_Cn 2, 16
End Sub

Sub Create_C3()
Attribute Create_C3.VB_ProcData.VB_Invoke_Func = " \n14"
    Create_Cn 3, 17
End Sub

Sub Create_C4()
Attribute Create_C4.VB_ProcData.VB_Invoke_Func = " \n14"
    Create_Cn 4, 18
End Sub

' Create_Cn--Populates the Cycle worksheets with data from the Master List worksheet
' 10/17/97, Brian O'Neill
'
Sub Create_Cn(nIndex As Long, nColumToVerify As Long)
Attribute Create_Cn.VB_ProcData.VB_Invoke_Func = " \n14"

    Dim wkWorksheet1 As Worksheet 'Always "Master List" worksheet.
    Dim wkWorksheet2 As Worksheet 'Cn worksheet.
    Dim strFilterAddress As String  'Address returned by filtering
    Dim rgFilterRange As Range 'Result of filter--records to be included
    Dim nLastRow As Long 'Last record to be included.
    Dim sSheetCx As String 'Name of the cycle worksheet being created
    Dim sStatusBarText As String
    
    On Error GoTo Exit_Create_Cn:
    
    'Turn off screenupdating for speed and appearance and give feedback to user.
    Application.ScreenUpdating = False
    Application.EnableEvents = False
    
    sSheetCx = gsCycleName & " " & nIndex
    
    'Store the worksheets we're using
    Set wkWorksheet1 = ActiveSheet
    Set wkWorksheet2 = Worksheets(sSheetCx)

    'Clear the Cn worksheet
''' BTO 11/21/97 -- Changed gfnClearActiveSheet to gfnClearSheet
    If Not (gfnClearSheet(wkWorksheet2.Name)) Then
        GoTo Exit_Create_Cn:
    End If
    
    wkWorksheet1.Activate
        
    'Give some user feedback
    sStatusBarText = Worksheets("Translation").Cells(224, gIntlOffset).Value
    Application.StatusBar = sStatusBarText
    
    'We need to make sure all outline levels are showing
    'Doesn't fail, even if no outline is present
    wkWorksheet1.Outline.ShowLevels 5
    
    'Check the Create Cn column for non-blanks
    strFilterAddress = gfnFilterOutNonBlankRows(nColumToVerify, wkWorksheet1.Name)
    
    'gfnFilterOutNonBlankRows returns the address of the filtered area
    'Only continue if there were records returned
    If strFilterAddress = "" Then
        GoTo Exit_Create_Cn:
    Else
        Set rgFilterRange = Range(strFilterAddress)
    End If
    
    'Get the last visible row in the filter
    nLastRow = rgFilterRange.Rows(rgFilterRange.Rows.Count).row
    
    'Give some user feedback
    sStatusBarText = Worksheets("Translation").Cells(225, gIntlOffset).Value
    Application.StatusBar = sStatusBarText & " " & wkWorksheet2.Name & "..."
 
'    ' Copy cols 1 - 5 (A-E) to same
'    gfnCopyColumns wkWorksheet2.Name, 1, 5, 1, nLastRow
'    ' Copy 30-32 to 6-9 (AD-AF to G-K)
'    gfnCopyColumns wkWorksheet2.Name, 30, 32, 6, nLastRow
'    ' Copy 8-9 to 9-10 (H-I to I-J)
'    gfnCopyColumns wkWorksheet2.Name, 8, 9, 9, nLastRow
'    ' Copy cols 10-11 (J-K) to 12-13 (L-M)
'    gfnCopyColumns wkWorksheet2.Name, 10, 11, 12, nLastRow
'    ' Copy col 13, etc. (M,N,O,P) to 19 (S)
'    gfnCopyColumns wkWorksheet2.Name, 12 + nIndex, 12 + nIndex, 19, nLastRow
'    ' Copy col 13, etc. (M,N,O,P) to 33 (AG)
'    gfnCopyColumns wkWorksheet2.Name, 12 + nIndex, 12 + nIndex, 33, nLastRow
'    'Copy col 28-32(AB-AF) to 28-32 (AB-AF)
'    gfnCopyColumns wkWorksheet2.Name, 28, 32, 28, nLastRow
'    'Shah 8/27/98
'    'We must also copy the process ID from the masterlist-Sheet to the Cycle Sheet.
'    'Copy col 28-34(AB-AH) to 28-34 (AB-AH)
'    gfnCopyColumns wkWorksheet2.Name, 28, 34, 28, nLastRow
    
' Copy cols 1 - 5 (A-E) to same
    gfnCopyColumns wkWorksheet2.Name, 1, 6, 1, nLastRow
    ' Copy 30-32 to 6-9 (AD-AF to G-K)
    gfnCopyColumns wkWorksheet2.Name, 32, 32, 9, 9
    gfnCopyColumns wkWorksheet2.Name, 33, 33, 10, 10
    gfnCopyColumns wkWorksheet2.Name, 34, 34, 8, 8
    ' Copy 8-9 to 9-10 (H-I to I-J)
    gfnCopyColumns wkWorksheet2.Name, 10, 11, 11, nLastRow
    ' Copy cols 10-11 (J-K) to 12-13 (L-M)
    gfnCopyColumns wkWorksheet2.Name, 12, 13, 14, nLastRow
    ' Copy col 13, etc. (M,N,O,P) to 19 (S)
    gfnCopyColumns wkWorksheet2.Name, 14 + nIndex, 14 + nIndex, 21, nLastRow
    ' Copy col 13, etc. (M,N,O,P) to 33 (AG)
    gfnCopyColumns wkWorksheet2.Name, 14 + nIndex, 14 + nIndex, 35, nLastRow
    'Copy col 28-32(AB-AF) to 28-32 (AB-AF)
    gfnCopyColumns wkWorksheet2.Name, 30, 34, 29, nLastRow
    'Shah 8/27/98
    'We must also copy the process ID from the masterlist-Sheet to the Cycle Sheet.
    'Copy col 28-34(AB-AH) to 28-34 (AB-AH)
    gfnCopyColumns wkWorksheet2.Name, 30, 36, 29, nLastRow
    
    'Autofilter with no arguments will clear the filter created by gfnFilterOutNonBlankRows
    rgFilterRange.AutoFilter
        
Exit_Create_Cn:
    'Clean up the windows for easier navigation
    GoHome ActiveWorkbook.Name, wkWorksheet1.Name
    GoHome ActiveWorkbook.Name, wkWorksheet2.Name

    Set wkWorksheet1 = Nothing
    Set wkWorksheet2 = Nothing
    Set rgFilterRange = Nothing

    Application.StatusBar = False
    Application.ScreenUpdating = True
    Application.EnableEvents = True

End Sub
Attribute VB_Name = "Create_CnX Module"





















































































'2/9--Diane--redid code strings for translation lookup

Sub Create_C1C()
Attribute Create_C1C.VB_ProcData.VB_Invoke_Func = " \n14"
    Create_CnX 1, Worksheets("Translation").Cells(227, gIntlOffset).Value, "C"
End Sub

Sub Create_C1T()
Attribute Create_C1T.VB_ProcData.VB_Invoke_Func = " \n14"
    Create_CnX 1, Worksheets("Translation").Cells(228, gIntlOffset).Value, "T"
End Sub

Sub Create_C1W()
Attribute Create_C1W.VB_ProcData.VB_Invoke_Func = " \n14"
    Create_CnX 1, Worksheets("Translation").Cells(229, gIntlOffset).Value, "W"
End Sub

'--------------------------------------------------------------------------
Sub Create_C2C()
Attribute Create_C2C.VB_ProcData.VB_Invoke_Func = " \n14"
    Create_CnX 2, Worksheets("Translation").Cells(227, gIntlOffset).Value, "C"
End Sub

Sub Create_C2T()
Attribute Create_C2T.VB_ProcData.VB_Invoke_Func = " \n14"
    Create_CnX 2, Worksheets("Translation").Cells(228, gIntlOffset).Value, "T"
End Sub

Sub Create_C2W()
Attribute Create_C2W.VB_ProcData.VB_Invoke_Func = " \n14"
    Create_CnX 2, Worksheets("Translation").Cells(229, gIntlOffset).Value, "W"
End Sub

'--------------------------------------------------------------------------
Sub Create_C3C()
Attribute Create_C3C.VB_ProcData.VB_Invoke_Func = " \n14"
    Create_CnX 3, Worksheets("Translation").Cells(227, gIntlOffset).Value, "C"
End Sub

Sub Create_C3T()
Attribute Create_C3T.VB_ProcData.VB_Invoke_Func = " \n14"
    Create_CnX 3, Worksheets("Translation").Cells(228, gIntlOffset).Value, "T"
End Sub

Sub Create_C3W()
Attribute Create_C3W.VB_ProcData.VB_Invoke_Func = " \n14"
    Create_CnX 3, Worksheets("Translation").Cells(229, gIntlOffset).Value, "W"
End Sub

'--------------------------------------------------------------------------
Sub Create_C4C()
Attribute Create_C4C.VB_ProcData.VB_Invoke_Func = " \n14"
    Create_CnX 4, Worksheets("Translation").Cells(227, gIntlOffset).Value, "C"
End Sub

Sub Create_C4T()
Attribute Create_C4T.VB_ProcData.VB_Invoke_Func = " \n14"
    Create_CnX 4, Worksheets("Translation").Cells(228, gIntlOffset).Value, "T"
End Sub

Sub Create_C4W()
Attribute Create_C4W.VB_ProcData.VB_Invoke_Func = " \n14"
    Create_CnX 4, Worksheets("Translation").Cells(229, gIntlOffset).Value, "W"
End Sub

'
' Create_CnX
' Factored/parameterized version of Create_C1C, Create_C1T, ..., Create_C2W, etc.
' Called by all of those guys.
'
' 10/8/97, BTO @ CPI
'
' nIndex: 1, 2, 3, 4
' strCTW: "C", "T", "W"
'
Sub Create_CnX(nIndex As Long, strCTW As String, Optional strMacroCTW As String)
Attribute Create_CnX.VB_ProcData.VB_Invoke_Func = " \n14"
    
    Dim wk As Worksheet 'Used to loop through worksheets to see if we already have one by this name
    Dim sSheetCx As String 'Base Cycle worksheet we're creating the worklist from
    Dim strCaptionTail As String 'Caption for B1 of new worksheet
    Dim strColToDelete1 As String 'First column of Config/Test/Writer to delete
    Dim strColToDelete2 As String 'Second column of Config/Test/Writer to delete
    Dim doObject As Object 'Used to loop through the buttons on the new worksheet and clean them up
    Dim rgUsed As Range 'Used range on the new worksheet
    Dim rgKeepRange As Range 'Range of cells to keep on the new worksheet
    Dim rgArea As Range 'Used to loop through areas of rgUsed and rgKeepRange
    Dim nConstVisible As Long 'Constant used for xlcelltypevisible in different versions of Excel
    Dim MsgText As String
    Dim MsgTitle As String
    
    On Error GoTo Exit_Create_Cnx:
    
    'Turn off the screenupdating
    Application.ScreenUpdating = False
    Application.EnableEvents = False
   
    sSheetCx = gsCycleName & " " & nIndex
    
    'Must loop through worksheets to ensure it exists before we try to delete it
    For Each wk In ActiveWorkbook.Worksheets
        If wk.Name = sSheetCx & strCTW Then
            'Verify the user really wants to do this
            MsgText = Worksheets("Translation").Cells(230, gIntlOffset).Value & " "
            MsgText = MsgText & Worksheets(sSheetCx & strCTW).Name & " "
            MsgText = MsgText & Worksheets("Translation").Cells(231, gIntlOffset).Value
            MsgTitle = Worksheets("Translation").Cells(232, gIntlOffset).Value & " "
            MsgTitle = MsgTitle & Worksheets(sSheetCx & strCTW).Name
            Select Case MsgBox(MsgText, vbYesNo + vbDefaultButton2 + vbExclamation, MsgTitle)
                Case vbNo
                    GoTo Exit_Create_Cnx:
                Case vbYes
                    'Give the user some feedback
                    sStatusBarText = Worksheets("Translation").Cells(233, gIntlOffset).Value & "..."
                    Application.StatusBar = sStatusBarText
            End Select
    
            'Delete the C 1X sheet if it already exists, turn off alerts so the user doesn't get the Excel prompt
            Application.DisplayAlerts = False
                Worksheets(sSheetCx & strCTW).delete
            Application.DisplayAlerts = True
            
            Exit For
        End If
    Next

    'Give the user some feedback
    sStatusBarText = Worksheets("Translation").Cells(234, gIntlOffset).Value & "..."
    Application.StatusBar = sStatusBarText
    
    'Copy the Cycle sheet to a new worksheet
    Sheets(sSheetCx).Copy After:=Sheets(sSheetCx)
    
    'Properly rename the new worksheet and set the on activate procedure
    Sheets(sSheetCx & " (2)").Name = sSheetCx & strCTW
    Sheets(sSheetCx & strCTW).OnSheetActivate = ActiveWorkbook.Name & "!AutoOpen.TestForOutline"

    ' Do new title, in cell B1
    Sheets(sSheetCx & strCTW).Cells(1, 2).Select
    With Selection.Font
        .FontStyle = "Bold"
        .Size = 11
    End With
                
    'Create the title string and set up columns to delete from the new worksheet
    Select Case strCTW
        Case Worksheets("Translation").Cells(227, gIntlOffset).Value
                strCaptionTail = " " & Worksheets("Translation").Cells(235, gIntlOffset).Value
                strColToDelete1 = "13" '"M"
                strColToDelete2 = "14" '"N"
        Case Worksheets("Translation").Cells(228, gIntlOffset).Value
                strCaptionTail = " " & Worksheets("Translation").Cells(236, gIntlOffset).Value
                strColToDelete1 = "12" '"L"
                strColToDelete2 = "14" '"N"
        Case Worksheets("Translation").Cells(229, gIntlOffset).Value
                strCaptionTail = " " & Worksheets("Translation").Cells(237, gIntlOffset).Value
                strColToDelete1 = "12" '"L"
                strColToDelete2 = "13" '"M"
        Case Else   ' ("can't happen")
            MsgBox Worksheets("Translation").Cells(238, gIntlOffset).Value, vbOKOnly, Worksheets("Translation").Cells(2, gIntlOffset).Value
    End Select

    Selection.FormulaR1C1 = Worksheets("Translation").Cells(239, gIntlOffset).Value & nIndex & strCaptionTail

    ' Set up & format Delete button
    'Note, Delete button name won't get translated
    ActiveSheet.DrawingObjects("Delete").Select
    Selection.Characters.Text = Worksheets("Translation").Cells(232, gIntlOffset).Value & " " & gsCycleName & " " & nIndex & strCTW
    Selection.OnAction = "Delete_C" & nIndex & strMacroCTW
    
    ' Select and delete two columns out of L, M, N,
    ' depending upon whether this is Config, Tester, or Writer.
    ' The one column that remains will then be col L.
    ' Delete strColToDelete2 (further right) first,
    ' so that strColToDelete1 doesn't change letter.
    
    ActiveSheet.Columns(CInt(strColToDelete2)).Select
    Selection.delete shift:=xlToLeft
    
    ActiveSheet.Columns(CInt(strColToDelete1)).Select
    Selection.delete shift:=xlToLeft
    
    ' The remaining col (out of LMN) is now col L.
    ActiveSheet.Columns(12).ColumnWidth = 8.83
    ActiveSheet.Columns(12).HorizontalAlignment = xlCenter
    ActiveSheet.Cells(1, 12).Value = Worksheets("Translation").Cells(242, gIntlOffset).Value
    ActiveSheet.Cells(1, 12).Characters.Font.Underline = True
    ActiveSheet.Cells(1, 12).Characters.Font.Bold = True
            
    'Remove the "Create" buttons...they don't automatically get deleted when the columns do...
    For Each doObject In ActiveSheet.DrawingObjects
        'Clean up the buttons which aren't needed (i.e., keep only the two blank buttons and the Delete button)
        '(button names don't get translated)
        If doObject.Characters.Text <> "" And InStr(doObject.Name, "Delete") = 0 Then
            doObject.delete
        Else  'Make the last blank button wider to make the format consistant across columns
            If doObject.TopLeftCell.Column = 13 Then
                doObject.Left = Columns(12).Left + 1
                doObject.Width = doObject.Width + (doObject.TopLeftCell.ColumnWidth * 4.85)
            End If
        End If
    Next
    
    'Clear the current outline...if there is none, no error occurs
    ActiveSheet.UsedRange.ClearOutline
    ActiveSheet.UsedRange.Rows.EntireRow.Hidden = False
        
    On Error Resume Next
    'We'll get an error if there's no cells with text in them...
    Set rgKeepRange = ActiveSheet.Range(Cells(4, 12), Cells(ActiveSheet.UsedRange.Rows.Count, 12)).SpecialCells(xlTextValues)
    On Error GoTo Exit_Create_Cnx:
    
    If Not (rgKeepRange Is Nothing) Then
        For Each rgArea In rgKeepRange.Areas
            rgArea.EntireRow.Hidden = True
        Next
    End If
    
    'Hide the row with the buttons...
    Rows("3:3").EntireRow.Hidden = True
    
    'Watch out for different constants indifferent XL versions...
    If InStr(Application.Version, "8") > 0 Then
        nConstVisible = xlCellTypeVisible
    Else
        nConstVisible = xlVisible
    End If
    
    'Delete the ones we don't want anymore
    Set rgUsed = Range(Cells(4, 1), Cells(ActiveSheet.UsedRange.Rows.Count, 1)).SpecialCells(nConstVisible)
    For Each rgArea In rgUsed.Areas
        rgArea.EntireRow.delete
    Next
    
    'Reshow the ones we kept
    If Not (rgKeepRange Is Nothing) Then
        rgKeepRange.EntireRow.Hidden = False
    End If
    
    'Reshow the row with the buttons
    Rows("3:3").EntireRow.Hidden = False
    
'Clean up
Exit_Create_Cnx:
    'Clean up the windows for easier navigation
    GoHome ActiveWorkbook.Name, sSheetCx
    GoHome ActiveWorkbook.Name, sSheetCx & strCTW

    Set wk = Nothing
    Set doObject = Nothing
    Set rgUsed = Nothing
    Set rgKeepRange = Nothing
    Set rgArea = Nothing
    
    Application.StatusBar = False
    Application.ScreenUpdating = True
    Application.EnableEvents = True

End Sub
Attribute VB_Name = "Delete_CnX Module"














































































































'2/9--Diane--redid code strings for translation lookup

Sub Delete_C1C()
Attribute Delete_C1C.VB_ProcData.VB_Invoke_Func = " \n14"
    Delete_CnX 1, Worksheets("Translation").Cells(227, gIntlOffset).Value
End Sub

Sub Delete_C1T()
Attribute Delete_C1T.VB_ProcData.VB_Invoke_Func = " \n14"
    Delete_CnX 1, Worksheets("Translation").Cells(228, gIntlOffset).Value
End Sub

Sub Delete_C1W()
Attribute Delete_C1W.VB_ProcData.VB_Invoke_Func = " \n14"
    Delete_CnX 1, Worksheets("Translation").Cells(229, gIntlOffset).Value
End Sub

Sub Delete_C2C()
Attribute Delete_C2C.VB_ProcData.VB_Invoke_Func = " \n14"
    Delete_CnX 2, Worksheets("Translation").Cells(227, gIntlOffset).Value
End Sub

Sub Delete_C2T()
Attribute Delete_C2T.VB_ProcData.VB_Invoke_Func = " \n14"
    Delete_CnX 2, Worksheets("Translation").Cells(228, gIntlOffset).Value
End Sub

Sub Delete_C2W()
Attribute Delete_C2W.VB_ProcData.VB_Invoke_Func = " \n14"
    Delete_CnX 2, Worksheets("Translation").Cells(229, gIntlOffset).Value
End Sub

Sub Delete_C3C()
Attribute Delete_C3C.VB_ProcData.VB_Invoke_Func = " \n14"
    Delete_CnX 3, Worksheets("Translation").Cells(227, gIntlOffset).Value
End Sub

Sub Delete_C3T()
Attribute Delete_C3T.VB_ProcData.VB_Invoke_Func = " \n14"
    Delete_CnX 3, Worksheets("Translation").Cells(228, gIntlOffset).Value
End Sub

Sub Delete_C3W()
Attribute Delete_C3W.VB_ProcData.VB_Invoke_Func = " \n14"
    Delete_CnX 3, Worksheets("Translation").Cells(229, gIntlOffset).Value
End Sub

Sub Delete_C4C()
Attribute Delete_C4C.VB_ProcData.VB_Invoke_Func = " \n14"
    Delete_CnX 4, Worksheets("Translation").Cells(227, gIntlOffset).Value
End Sub

Sub Delete_C4T()
Attribute Delete_C4T.VB_ProcData.VB_Invoke_Func = " \n14"
    Delete_CnX 4, Worksheets("Translation").Cells(228, gIntlOffset).Value
End Sub

Sub Delete_C4W()
Attribute Delete_C4W.VB_ProcData.VB_Invoke_Func = " \n14"
    Delete_CnX 4, Worksheets("Translation").Cells(229, gIntlOffset).Value
End Sub

' Delete_CnX
' Factored/parameterized version of Delete_C1C, Delete_C1T, ..., Delete_C2W, etc.
' Called by all of those guys.
'
' 10/8/97, BTO @ CPI
'
' nIndex: 1, 2, 3, 4
' strCTW: "C", "T", "W"
'
Sub Delete_CnX(nIndex As Long, strCTW As String)
Attribute Delete_CnX.VB_ProcData.VB_Invoke_Func = " \n14"
    
    Dim sStatusBarText As String
    Dim MsgText As String
    Dim MsgTitle As String
    
    On Error GoTo Exit_Delete_Cnx:
    
    'Turn off screen updating
    Application.ScreenUpdating = False
    Application.EnableEvents = False
    
    'Give user some feedback
    sStatusBarText = Worksheets("Translation").Cells(243, gIntlOffset).Value & " "
    Application.StatusBar = sStatusBarText & ActiveSheet.Name & "..."
    
    'Verify the user really wants to do this
    MsgText = Worksheets("Translation").Cells(230, gIntlOffset).Value & " "
    MsgText = MsgText & ActiveSheet.Name & " "
    MsgText = MsgText & Worksheets("Translation").Cells(231, gIntlOffset).Value
    MsgTitle = Worksheets("Translation").Cells(232, gIntlOffset).Value & " "
    MsgTitle = MsgTitle & ActiveSheet.Name
    Select Case MsgBox(MsgText, vbYesNo + vbDefaultButton2 + vbExclamation, MsgTitle)
        Case vbYes
            'Turn off alerts so Excel doesn't prompt the user
            Application.DisplayAlerts = False
            'Delete the activeworksheet
            ActiveSheet.delete
            
            'Clean up the windows for easier navigation
            GoHome ActiveWorkbook.Name, gsCycleName & " " & nIndex
    
            'Turn alerts back on
            Application.DisplayAlerts = True
    End Select
    
'Clean up
Exit_Delete_Cnx:
    Application.StatusBar = False
    Application.ScreenUpdating = True
    Application.EnableEvents = True
    
End Sub
Attribute VB_Name = "DevTools Module"














































































































'2/9--Diane--redid code strings for translation lookup--nothing changed here since these are "DEVELOPMENT-ONLY" procedures

Option Explicit

'------------------------------------------------------------------------------------------
' README
' I got sick of manually hiding/unhiding macro modules and their associated worksheets
' & dialog sheets; hence these two simple, fast, easy-to-use macros. No fuss, no mess.
'
' Manually run Workbook_Release to hide all the stuff, and Workbook_Development to unhide it.
'
' Workbook_Release also OPTIONALLY clears test/junk data from visible (end user) worksheets,
' and sets the active cell to A4 on each such sheet.
'
' One complication with automating these tedious tasks: we DON'T want to let end users
' delete all their data with a mere click on a default button. So we make it difficult
' though not impossible to run these macros  -- a user has to go through a few steps
' to do so, and thus can't run them by accident or without knowing the consequences.
'
' Unfortunately, developers must also go through the same extra steps to unhide
' the macros on a release version of bpml.xls:
'
'    (1)  If the worksheet "AssocDocs_scrap" is hidden,
'         choose Format | Sheet | Unhide... to unhide it.
'    (2)  Set the value of cell H1 to 1.
'         This cell is a flag, which the macros set appropriately.
'         The adjacent cell, I1, reads:
'          "<-- THIS IS A RELEASE VERSION (1 if true, 0 if false)"
'          NOTE: The flag is set to true only when you run Workbook_Release
'          and say Yes to clearing all data.
'
' NOW you can run Workbook_Development and Workbook_Release meaningfully.
'
' Brian O'Neill 10/28/97
'------------------------------------------------------------------------------------------
' These work fine under Excel95; under Excel 97, however, Workbook_Release doesn't do
' what it oughta when you save the workbook in Excel 95 format (macro sheets are not hidden).
' Brian O'Neill 10/28/97
'------------------------------------------------------------------------------------------

' Macro-data worksheet that holds "Release?" flag cell
Const kstrFlagCellSheet = "AssocDocs_scrap"
' Cell on sheet AssocDocs_scrap that holds "Release?" flag
Const kstrFlagCell = "H1"

' What user is told if s/he runs Workbook_XXXXXX and "Release?" flag is set
Const kstrUserMessage = "This macro is not for use in release versions of bpml.xls."

'------------------------------------------------------------------------------------------
Public Sub Workbook_Release()
Attribute Workbook_Release.VB_ProcData.VB_Invoke_Func = " \n14"

    ' Try, really try, not to let end users run this function!!!!
    ' Toward that end, we delegate a particular cell on a macro scrap worksheet
    ' to hold a flag (nonzero --> release, 0 --> development).
    If Worksheets(kstrFlagCellSheet).Range(kstrFlagCell).Value <> 0 Then
        ' Assume an end user is using the workbook, and therefore...
        MsgBox kstrUserMessage
        Exit Sub
    End If
    
    ' Hide the stuff
    Workbook_DisplayTheStuff False   ' arg: make sheets invisible

    ' Let the user be looking at masterlist while contemplating
    ' whether to delete all data:
    Worksheets("Master list").Activate

    ' Pop the question:
    Dim sCrLf As String
    sCrLf = Chr(13) & Chr(10)
    Dim sPrompt As String
    sPrompt = _
        "Delete all data from visible worksheets?" & sCrLf & _
        sCrLf & _
        "WARNING: YOU CANNOT UNDO THIS ACTION! Do you wish to proceed?" & sCrLf

    Dim bClearAllData As Boolean
    bClearAllData = _
        (MsgBox(sPrompt, vbYesNo, "Clear All Data?") = vbYes)
    
    
    ' Do it if told to do so
    
    If bClearAllData Then

        ' Clear each visible worksheet and select its cell A4
        Dim oWks As Worksheet
        For Each oWks In Worksheets
            If oWks.Visible Then
                gfnClearSheet oWks.Name, False  '-- False: no verify
                Range(Cells(4, 1)).Select
            End If
        Next oWks

        ' Finally, reactivate masterlist
        Worksheets("Master list").Activate
    
        ' All data cleared. So, either you're a developer who's preparing
        ' the workbook for some kinda release, or you're an end user running
        ' this macro. Set the "Release?" flag to true:
        ' NOTE: if you DIDN'T clear all data, then the "Release?" flag
        ' remains false (0), so you can still run Workbook_xxxxxxx sans fuss.
        Worksheets(kstrFlagCellSheet).Range(kstrFlagCell).Value = 1
    
    End If
        
End Sub

'------------------------------------------------------------------------------------------
Public Sub Workbook_Development()
Attribute Workbook_Development.VB_ProcData.VB_Invoke_Func = " \n14"
    
    ' Don't let end users run this function!
    ' Toward that end, we delegate a particular cell on a macro scrap worksheet
    ' to hold a flag (nonzero --> release, 0 --> development).
    If Worksheets(kstrFlagCellSheet).Range(kstrFlagCell).Value <> 0 Then
        ' Assume a user is using the workbook, and therefore...
        MsgBox kstrUserMessage
        Exit Sub
    End If
    
    ' Unhide the stuff
    Workbook_DisplayTheStuff True    ' arg: make sheets visible

    ' This is redundant, because the value must already be 0
    ' for you to have gotten this far in the macro.
    '' Worksheets(kstrFlagCellSheet).Range(kstrFlagCell).Value = 0

End Sub


'------------------------------------------------------------------------------------------
Private Sub Workbook_DisplayTheStuff( _
                                      bVisible As Boolean)

    ' Hide/unhide all macro modules
    Dim oMod As Module
    For Each oMod In Modules
        oMod.Visible = bVisible
    Next oMod
    
    ' Hide/unhide all dialog sheets
    Dim oDlg As DialogSheet
    For Each oDlg In DialogSheets
        oDlg.Visible = bVisible
    Next oDlg
    
    ' Hide/unhide any support worksheets
    Sheets(kstrFlagCellSheet).Visible = bVisible

End Sub
Attribute VB_Name = "GlobalFns Module"














































































































'2/9--Diane--redid code strings for translation lookup

Option Explicit

'11/13--DLS rewrote with less "Select" calls which are slow...also parameterized the last row
Public Sub gfnCopyColumns(sToSheet As String, nColSourceStart As Long, nColSourceEnd As Long, nColTarget As Long, nLastRow As Long)
Attribute gfnCopyColumns.VB_ProcData.VB_Invoke_Func = " \n14"
    
    Dim rgUsed As Range 'Used range on the worksheet
    
    Sheets(gsMasterListName).Select

    Set rgUsed = Range(Cells(4, nColSourceStart).Address, Cells(nLastRow, nColSourceEnd))
    rgUsed.Copy
   
    'Select the "To" range and paste the data
    Sheets(sToSheet).Select
    Range(Cells(4, nColTarget).Address).Select
    ActiveSheet.Paste
    
    Application.CutCopyMode = False
    
    Set rgUsed = Nothing
End Sub

'--------------------------------------------------------------------------
'11/13--Diane--Added this to support the new gfnClearActiveSheet
'11/21/97 BTO -- Make that, "to support gfnClearSheet"

Sub ClearSheetVerify()
Attribute ClearSheetVerify.VB_ProcData.VB_Invoke_Func = " \n14"
    Application.ScreenUpdating = False
    gfnClearSheet ActiveSheet.Name
    Application.ScreenUpdating = True
End Sub

'--------------------------------------------------------------------------
' gfnClearActiveSheet Macro
'11/21/97 BTO -- Wrapper for gfnClearSheet (see below).

Public Function gfnClearActiveSheet(Optional bVerify As Variant) As Boolean
Attribute gfnClearActiveSheet.VB_ProcData.VB_Invoke_Func = " \n14"
    
    gfnClearActiveSheet = gfnClearSheet(ActiveSheet.Name, bVerify)
    
End Function
'--------------------------------------------------------------------------
' gfnClearSheet Macro
'11/13--DLS rewrote with less "Select" calls which are slow...also parameterized the worksheet name so I can call internally
'11/21/97 BTO -- renamed this modified function to "gfnClearSheet",
'  added a new function gfnClearActiveSheet which wraps this one
'  [precedes it with a simple Worksheets(WorksheetName).Activate]
'  Also added optional 2nd argument, so the function can be used "silently".
'  The function will delete data without first asking the user
'  ONLY if the 2nd argument has been supplied and its value is False.
'  [XL95 doesn't support default values for optional parameters.]

Public Function gfnClearSheet( _
                                WorksheetName As String, _
                                Optional bVerify As Variant _
                                ) As Boolean
Attribute gfnClearSheet.VB_ProcData.VB_Invoke_Func = " \n14"
    
    Dim nLastRow As Long 'Last row in the active worksheet
    Dim vDoIt As Variant
    Dim MsgText As String
    Dim MsgTitle As String
    
    Application.EnableEvents = False
    
    gfnClearSheet = False
    nLastRow = Worksheets(WorksheetName).UsedRange.Rows.Count
    
    ' No 2nd arg? Give it a default value (need to in XL95):
    If IsMissing(bVerify) Then
        bVerify = True
    End If

    If bVerify <> False Then
        'Verify that the user wants to do this
        MsgText = Worksheets("Translation").Cells(230, gIntlOffset).Value & " "
        MsgText = MsgText & WorksheetName & " "
        MsgText = MsgText & Worksheets("Translation").Cells(231, gIntlOffset).Value
        MsgTitle = Worksheets("Translation").Cells(232, gIntlOffset).Value & " "
        MsgTitle = MsgTitle & WorksheetName
        vDoIt = MsgBox(MsgText, vbYesNo + vbDefaultButton2 + vbExclamation, MsgTitle)
        If vDoIt = vbNo Then
            Exit Function
        End If
    End If
    
    ' Delete the data.
    ' Make sure we don't delete up if there's no data in the worksheet
    If nLastRow < 4 Then
        nLastRow = 4
    End If
    Worksheets(WorksheetName).Rows("4:" & nLastRow).Rows.delete shift:=xlUp
    
    gfnClearSheet = True
    
    'Clean up the display
    GoHome ActiveWorkbook.Name, WorksheetName
    
    Application.EnableEvents = True
    
End Function

'------------------------------------------------------------------------------------------
Public Sub HomeButton()
Attribute HomeButton.VB_ProcData.VB_Invoke_Func = " \n14"
    GoHome ActiveWorkbook.Name, ActiveSheet.Name
End Sub

'------------------------------------------------------------------------------------------
' GoHome--unscrolls the windows and goes to F4
'
Public Sub GoHome(WorkbookName, WorksheetName As String)
Attribute GoHome.VB_ProcData.VB_Invoke_Func = " \n14"
    Workbooks(WorkbookName).Worksheets(WorksheetName).Activate
    ActiveSheet.Cells(4, 6).Select
    Selection.Activate
    ActiveWindow.ScrollRow = 4
    ActiveWindow.ScrollColumn = 6
End Sub

'NumColVerify is the column number to verify for non-blank cells
'WorksheetName is the name of the sheet we will be copying from (performing the filter on
Public Function gfnFilterOutNonBlankRows(NumColVerify As Variant, WorksheetName As String) As String
Attribute gfnFilterOutNonBlankRows.VB_ProcData.VB_Invoke_Func = " \n14"

    Dim rgUsed As Range 'Used range on the worksheet
    Dim nFirstCol As Long 'First column in the filter range
    Dim nLastCol As Long 'Last column in the filter range
    Dim rgFirstCell As Range 'First cell in the filter range
    Dim nFirstRow As Long 'First row in the filter range
    Dim nLastRow As Long 'Last row in the filter range
    Dim rgFilterRange As Range 'Range which will be filtered

    On Error GoTo Exit_gfnFilterOutNonBlankRows:
    
    gfnFilterOutNonBlankRows = ""
    
    Set rgUsed = Worksheets(WorksheetName).UsedRange
    nFirstCol = 1
    nLastCol = 35
    nFirstRow = 3 'This is the row to put the arrows on...otherwise, we'll miss the first row
    nLastRow = rgUsed.Rows.Count
    
    'Select the range to filter
    Set rgFilterRange = Range(Cells(nFirstRow, nFirstCol), Cells(nLastRow, nLastCol))
    
    'Make sure there'll be at least one row in the filter, else Excel may freeze
    Range(Cells(nFirstRow, NumColVerify).Address).Select
    Selection.End(xlDown).Select  'Goes to the first visible row
    
    If Selection.Value = "" Then
        GoTo Exit_gfnFilterOutNonBlankRows:                                                                                                                                                        'Nothing to copy
    End If
    
    'Clean up if there's an existing filter
    rgFilterRange.AutoFilter
    
    'Filter on the first column in the array (showing non-blanks)
    rgFilterRange.AutoFilter field:=NumColVerify, Criteria1:="<>"

    'The last row will really have data in it, so...testing if it's null should give us the right answer
    Range(Cells(3, NumColVerify).Address).Select 'Row 3
    
    'Need to figure out the first row in the filter
    Set rgFirstCell = Selection
    nFirstRow = rgFirstCell.row
    Set rgFirstCell = rgFirstCell.Offset(1, 0)
    
    Do Until rgFirstCell.Value <> "" And rgFirstCell.EntireRow.Hidden = False
        Set rgFirstCell = rgFirstCell.Offset(1, 0)
    Loop
    rgFirstCell.Select
    nFirstRow = rgFirstCell.row
    
    Selection.End(xlDown).Select  'Goes to the last visible row
    'If it's null, we only have one row of visible data, set nlastrow to nfirstrow
    If Selection.Value = "" Then
        nLastRow = nFirstRow
    Else
        nLastRow = Selection.row
    End If
    
    Set rgFilterRange = Range(Cells(nFirstRow, nFirstCol), Cells(nLastRow, nLastCol))
    'Return the visible rows in the filter
    gfnFilterOutNonBlankRows = rgFilterRange.Address
    
Exit_gfnFilterOutNonBlankRows:
'Clean up
    Set rgUsed = Nothing
    Set rgFilterRange = Nothing
    Set rgFirstCell = Nothing

End Function

'------------------------------------------------------------------------------------------
Public Sub FillAllChildren_sdfgdfgfdgfg()
Attribute FillAllChildren_sdfgdfgfdgfg.VB_ProcData.VB_Invoke_Func = " \n14"

    Dim strValue As String 'Value to paste in the child cells
    Dim rgCurrentCell As Range 'The currently selected cell we're copying from
    Dim rgLabelCell As Range 'The label which corresponds to the row we're on
    Dim rgPasteRange As Range 'The range we'll paste the value into
    Dim rgColumn1ToLabel As Range 'Range of cells from column1 to the current label column
    Dim nLastRow As Long 'The last used row of the worksheet
    Dim nWarning As Long 'Result of warning the user about pasting the strValue
    Dim MsgText As String
    Dim MsgTitle As String
    
    On Error GoTo Exit_FillAllChildren:
    
    If VerifyBPMLWorkbook = False Then
        Exit Sub
    End If
    
    Application.ScreenUpdating = False
    Application.EnableEvents = False
    
    Set rgCurrentCell = ActiveCell
    
    'Test for a valid selection
    If rgCurrentCell.Column <= 6 Then
        MsgText = Worksheets("Translation").Cells(261, gIntlOffset).Value
        MsgTitle = Worksheets("Translation").Cells(262, gIntlOffset).Value
        MsgBox MsgText, vbOKOnly + vbExclamation, MsgTitle
        GoTo Exit_FillAllChildren:
    ElseIf Selection.Cells.Count > 1 Then
        MsgText = Worksheets("Translation").Cells(263, gIntlOffset).Value
        MsgTitle = Worksheets("Translation").Cells(262, gIntlOffset).Value
        MsgBox MsgText, vbOKOnly + vbExclamation, MsgTitle
        GoTo Exit_FillAllChildren:
    End If
    
    strValue = rgCurrentCell.Value
    
    'Figure out which parent label we're starting from
    If Cells(rgCurrentCell.row, 5).Value <> "" Then
        Set rgLabelCell = Cells(rgCurrentCell.row, 5)
    ElseIf Cells(rgCurrentCell.row, 4).Value <> "" Then
        Set rgLabelCell = Cells(rgCurrentCell.row, 4)
    ElseIf Cells(rgCurrentCell.row, 3).Value <> "" Then
        Set rgLabelCell = Cells(rgCurrentCell.row, 3)
    ElseIf Cells(rgCurrentCell.row, 2).Value <> "" Then
        Set rgLabelCell = Cells(rgCurrentCell.row, 2)
    ElseIf Cells(rgCurrentCell.row, 1).Value <> "" Then
        Set rgLabelCell = Cells(rgCurrentCell.row, 1)
    Else
        'We don't have any parent information
        MsgText = Worksheets("Translation").Cells(264, gIntlOffset).Value
        MsgTitle = Worksheets("Translation").Cells(262, gIntlOffset).Value
        MsgBox MsgText, vbOKOnly + vbExclamation, MsgTitle
        GoTo Exit_FillAllChildren
    End If
    
    If rgCurrentCell.Value = "" Then
        MsgText = Worksheets("Translation").Cells(265, gIntlOffset).Value & " "
        MsgText = MsgText & rgLabelCell.Value & "?"
        MsgTitle = Worksheets("Translation").Cells(266, gIntlOffset).Value & " "
        nWarning = MsgBox(MsgText, vbExclamation + vbYesNo, MsgTitle)
    Else
        MsgText = Worksheets("Translation").Cells(267, gIntlOffset).Value & " '"
        MsgText = MsgText & strValue & "' "
        MsgText = MsgText & Worksheets("Translation").Cells(268, gIntlOffset).Value & " "
        MsgText = MsgText & rgLabelCell.Value & "?"
        MsgTitle = Worksheets("Translation").Cells(266, gIntlOffset).Value & " "
        nWarning = MsgBox(MsgText, vbExclamation + vbYesNo, MsgTitle)
    End If
    
    Select Case nWarning
        Case vbNo
        GoTo Exit_FillAllChildren
    End Select
    
    'Initialize the pasterange...and other variables for the loop
    Set rgPasteRange = rgCurrentCell
    Set rgLabelCell = rgLabelCell.Offset(1, 0)
    nLastRow = ActiveSheet.UsedRange.Rows.Count
    
    Set rgColumn1ToLabel = Range(Cells(rgLabelCell.row, 1), Cells(rgLabelCell.row, rgLabelCell.Column))
    
    'Loop to find the last row in this parent section (i.e., the first row of the next section)
    'Checking that the label column and it's parents are empty
    If rgLabelCell.Column = 1 Then
    
        Do While rgLabelCell.row <= nLastRow And Cells(rgLabelCell.row, 1) = ""
            'Only do this to rows with a value in columns A-E
            If Cells(rgLabelCell.row, 1) <> "" Or Cells(rgLabelCell.row, 2) <> "" Or Cells(rgLabelCell.row, 3) <> "" Or Cells(rgLabelCell.row, 4) <> "" Or Cells(rgLabelCell.row, 5) <> "" Or Cells(rgLabelCell.row, 6) <> "" Then
                'Add this row to the paste range
                Set rgPasteRange = Union(rgPasteRange, Cells(rgLabelCell.row, rgCurrentCell.Column))
            End If
            Set rgLabelCell = rgLabelCell.Offset(1, 0)
        Loop
    
    Else
        Do While rgLabelCell.row <= nLastRow
            If Not (rgColumn1ToLabel.SpecialCells(xlBlanks) Is Nothing) Then
                If rgColumn1ToLabel.SpecialCells(xlBlanks).Count = rgColumn1ToLabel.Cells.Count Then
                    'Only do this to rows with a value in columns A-F
                    If Cells(rgLabelCell.row, 1) <> "" Or Cells(rgLabelCell.row, 2) <> "" Or Cells(rgLabelCell.row, 3) <> "" Or Cells(rgLabelCell.row, 4) <> "" Or Cells(rgLabelCell.row, 5) <> "" Or Cells(rgLabelCell.row, 6) <> "" Then
                        'Add this row to the paste range
                        Set rgPasteRange = Union(rgPasteRange, Cells(rgLabelCell.row, rgCurrentCell.Column))
                    End If
                    Set rgLabelCell = rgLabelCell.Offset(1, 0)
                    'Reset the row number in this
                    Set rgColumn1ToLabel = Range(Cells(rgLabelCell.row, 1), Cells(rgLabelCell.row, rgLabelCell.Column))
                Else
                    Exit Do
                End If
            End If
        Loop
    End If
    
    If rgLabelCell.row <> nLastRow Then
        'Step back up to the last row
        Set rgLabelCell = rgLabelCell.Offset(-1, 0)
    End If

    'Copy and fill the value in every row in the range
    rgCurrentCell.Copy
        
    rgPasteRange.PasteSpecial xlValues
    
    'Clean up the display
    Application.CutCopyMode = False
    rgCurrentCell.Select
    
    
Exit_FillAllChildren:
    'Clean up
    Application.ScreenUpdating = True
    Application.EnableEvents = True
    
    Set rgCurrentCell = Nothing
    Set rgLabelCell = Nothing
    Set rgPasteRange = Nothing
    
End Sub


Public Function VerifyBPMLWorkbook()
Attribute VerifyBPMLWorkbook.VB_ProcData.VB_Invoke_Func = " \n14"

    Dim wk As Worksheet
    
    For Each wk In ActiveWorkbook.Worksheets
        If wk.Name = "Translation" Then
            VerifyBPMLWorkbook = True
            Exit For
        Else
            VerifyBPMLWorkbook = False
        End If
    Next
    
    Set wk = Nothing
    
End Function
Attribute VB_Name = "Ix Module"














































































































'2/9--Diane--redid code strings for translation lookup

'Option Explicit
'Can't have option explicit since there's XL 97 constants around...XL 95 won't like them

Sub Create_I1()
Attribute Create_I1.VB_ProcData.VB_Invoke_Func = " \n14"
    Create_Ix 1, 19
End Sub

Sub Create_I2()
Attribute Create_I2.VB_ProcData.VB_Invoke_Func = " \n14"
    Create_Ix 2, 20
End Sub

' Create_Ix--Populates Integration worksheet with data from Master List worksheet
' 10/16/97, BTO @ CPI

Sub Create_Ix(nIndex As Long, nColumToVerify As Long)
Attribute Create_Ix.VB_ProcData.VB_Invoke_Func = " \n14"

    Dim wkWorksheet1 As Worksheet 'Always "Master List" worksheet.
    Dim wkWorksheet2 As Worksheet 'Cn worksheet.
    Dim nNumColVerify As Long 'Used to store the column we're going to verify for record inclusion.
    Dim strFilterAddress As String  'Address returned by filtering
    Dim rgFilterRange As Range 'Result of filter--records to be included
    Dim nLastRow As Long 'Last record to be included.
    Dim sSheetIx As String 'Name of the integration worksheet being created
    Dim sStatusBarText As String
    
    On Error GoTo Exit_Create_Ix:
    'Turn off screen updating
    Application.ScreenUpdating = False
    Application.EnableEvents = False
    
    sSheetIx = gsIntegrationName & " " & nIndex
    
    'Store the worksheets we're using
    Set wkWorksheet1 = ActiveSheet
    Set wkWorksheet2 = Worksheets(sSheetIx)

    'Clear the Ix worksheet
''' BTO 11/21/97 -- Changed gfnClearActiveSheet to gfnClearSheet
    If Not (gfnClearSheet(wkWorksheet2.Name)) Then
        GoTo Exit_Create_Ix:
    End If
    
    wkWorksheet1.Activate
        
    'Give some user feedback
    sStatusBarText = Worksheets("Translation").Cells(257, gIntlOffset).Value & "..."
    Application.StatusBar = sStatusBarText
    
    'We need to make sure all outline levels are showing
    'Doesn't fail, even if no outline is present
    wkWorksheet1.Outline.ShowLevels 5
    
    'Check the Create Cn column for non-blanks
    nNumColVerify = nColumToVerify
    strFilterAddress = gfnFilterOutNonBlankRows(nNumColVerify, wkWorksheet1.Name)
    
    'gfnFilterOutNonBlankRows returns the address of the filtered area
    'Only continue if there were records returned
    If strFilterAddress = "" Then
        GoTo Exit_Create_Ix:
    Else
        Set rgFilterRange = Range(strFilterAddress)
    End If
    
    'Get the last visible row in the filter
    nLastRow = rgFilterRange.Rows(rgFilterRange.Rows.Count).row
    
    'Give some user feedback
    sStatusBarText = Worksheets("Translation").Cells(258, gIntlOffset).Value & " " & wkWorksheet2.Name & "..."
    Application.StatusBar = sStatusBarText
 
'    ' Copy cols 1 - 5 (A-E) to same
'    gfnCopyColumns wkWorksheet2.Name, 1, 5, 1, nLastRow
'    ' Copy 30-32 to 6-9 (AD-AF to G-K)
'    gfnCopyColumns wkWorksheet2.Name, 30, 32, 6, nLastRow
'    ' Copy 16 + nIndex (I1: Q, I2: R) to 33 (AG)
'    gfnCopyColumns wkWorksheet2.Name, 16 + nIndex, 16 + nIndex, 33, nLastRow
'    'Copy col 28-32(AB-AF) to 28-32 (AB-AF)
'    gfnCopyColumns wkWorksheet2.Name, 28, 32, 28, nLastRow
    
    ' Copy cols 1 - 5 (A-E) to same
    gfnCopyColumns wkWorksheet2.Name, 1, 6, 1, nLastRow
    ' Copy 30-32 to 6-9 (AD-AF to G-K)
    gfnCopyColumns wkWorksheet2.Name, 30, 32, 8, nLastRow
    ' Copy 16 + nIndex (I1: Q, I2: R) to 33 (AG)
    gfnCopyColumns wkWorksheet2.Name, 18 + nIndex, 18 + nIndex, 35, nLastRow
    'Copy col 28-32(AB-AF) to 28-32 (AB-AF)
    gfnCopyColumns wkWorksheet2.Name, 30, 34, 29, nLastRow
    
    
    
    'Autofilter with no arguments will clear the filter created by gfnFilterOutNonBlankRows
    rgFilterRange.AutoFilter
        
    'Give feedback to user
    sStatusBarText = Worksheets("Translation").Cells(259, gIntlOffset).Value & "..."
    Application.StatusBar = sStatusBarText

    ' Insert formulas in col K & L, default difficulty factor of 5 in col K
    SetupPriorityColumns wkWorksheet2.UsedRange.Rows.Count, wkWorksheet2.Name
    
Exit_Create_Ix:
    'Clean up the windows for easier navigation
    GoHome ActiveWorkbook.Name, wkWorksheet1.Name
    GoHome ActiveWorkbook.Name, wkWorksheet2.Name

    Set wkWorksheet1 = Nothing
    Set wkWorksheet2 = Nothing
    Set rgFilterRange = Nothing

    Application.StatusBar = False
    Application.ScreenUpdating = True
    Application.EnableEvents = True

End Sub

'------------------------------------------------------------------------------------------
' gfnSetupPriorityColumns
' 10/17/97, Brian O'Neill
'
Sub SetupPriorityColumns(nEndRow As Long, WorksheetName As String)
Attribute SetupPriorityColumns.VB_ProcData.VB_Invoke_Func = " \n14"
    
    Dim rgRange As Range 'Range to populate with default priority of "5"
    Dim rgCell As Range
    Dim nConstValues As Long 'Constant to differentiate between constants used in different version of XL
    Dim sBuildFormula As String
    
    'Insert default difficulty factor of 5 in col K
    'Note, request made to not show a priority, nor forumla unless the row is a Scenario or Case row.
    
    '4/16--Diane--added this for multi-language support
    'Takes a long time, but using RC references doesn't work in other langauges
    '.Address(False, False) makes it a relative reference instead of absolute
    
    Set rgCell = Worksheets(WorksheetName).Cells(5, 12)
    Set rgRange = Worksheets(WorksheetName).Range(Cells(6, 12), Cells(nEndRow, 12))
    sBuildFormula = ""
    sBuildFormula = "=" & Worksheets("Translation").Cells(299, gsExcelCountryCode).Value & "(" 'If
    sBuildFormula = sBuildFormula & Worksheets("Translation").Cells(300, gsExcelCountryCode).Value & "(" 'Or
    sBuildFormula = sBuildFormula & rgCell.Offset(0, -9).Address(False, False) & "<>"""""  'First test for blank scenario
    sBuildFormula = sBuildFormula & "," & rgCell.Offset(0, -8).Address(False, False) & "<>"""""  'Then test for blank process group
    sBuildFormula = sBuildFormula & ")," & """5""" & ","""")" 'Add the rest of formula
    If gsExcelCountryCode = 1 Then 'English
        rgCell.Formula = sBuildFormula
    Else  'Any other language
        rgCell.FormulaLocal = sBuildFormula
    End If
    'Equivalent of "=IF(OR(RC[-9]<>"", RC[-8]<>""),"5","")"
    
    rgCell.Copy
    If InStr(Application.Version, "8") > 0 Then
        nConstValues = xlPasteFormulas
    Else
        nConstValues = xlFormulas
    End If
    rgRange.PasteSpecial nConstValues
    
    'Copy and paste this formula so it's just "5" everywhere.  This will speed up the recalcs on large spreadsheets during regular use.
    rgRange.Copy
    If InStr(Application.Version, "8") > 0 Then
        nConstValues = xlPasteValues
    Else
        nConstValues = xlValues
    End If
    rgRange.PasteSpecial nConstValues
    rgCell.Copy
    rgCell.PasteSpecial nConstValues
    
    Application.CutCopyMode = False
    
    ' Insert formula in col L
    'Note, request made to not show a priority, nor forumla unless the row is a Scenario or Case row.
    Set rgCell = Cells(5, 13)
    Set rgRange = Range(Cells(6, 13), Cells(nEndRow, 13))
    sBuildFormula = ""
    sBuildFormula = "=" & Worksheets("Translation").Cells(299, gsExcelCountryCode).Value & "(" 'If
    sBuildFormula = sBuildFormula & Worksheets("Translation").Cells(300, gsExcelCountryCode).Value & "(" 'Or
    sBuildFormula = sBuildFormula & rgCell.Offset(0, -10).Address(False, False) & "<>"""","  'First test for blank scenario
    sBuildFormula = sBuildFormula & rgCell.Offset(0, -9).Address(False, False) & "<>""""),("  'Then test for blank process group
    sBuildFormula = sBuildFormula & rgCell.Offset(0, -3).Address(False, False) & "+" & rgCell.Offset(0, -2).Address(False, False)
    sBuildFormula = sBuildFormula & ")/(1-(0.1*" & rgCell.Offset(0, -1).Address(False, False) & ")),"""")" 'Add the rest of the formula
    
    If gsExcelCountryCode = 1 Then 'English
        rgCell.Formula = sBuildFormula
    Else  'Any other language
        rgCell.FormulaLocal = sBuildFormula
    End If
    
    'Equivalent of "=IF(OR(RC[-10]<>"", RC[-9]<>""),(RC[-3]+RC[-2])/(1-(0.1*RC[-1])),"")"
    
    rgCell.Copy
    If InStr(Application.Version, "8") > 0 Then
        nConstValues = xlPasteFormulas
    Else
        nConstValues = xlFormulas
    End If
    rgRange.PasteSpecial nConstValues
    
    Application.CutCopyMode = False
    
'Clean up
    Set rgRange = Nothing
    Set rgCell = Nothing
    
End Sub
Attribute VB_Name = "LaunchDoc Module"






































'2/9--Diane--redid code strings for translation lookup

Dim oWord As Object

'=========================================================================
' LaunchDoc & helper procs
' 10/6/97 Brian O'Neill for Cambridge Publications
'=========================================================================


' Listbox in dialogbox AssocDocsDialog gets data
' from worksheet AssocDocs_scrap:
'     items from col 1,
'     index of initial selection from cell F1.
' Current selection index is stored in F1 as well
' (cell value updated as selection changes).
Const kstrListLinkedCell = "F1"
Const knListLinkedCellRow = 1
Const knListLinkedCellCol = 6   ' leave some slack

' Think of the following constants as an enum
Const knDoctypeBPP = 1
Const knDoctypeCIID = 2
'     Got more? Continue as above... .

' ALSO defined in VB5 QAdbLkup.
' Passed to QAdbLkup on cmdline (currently).
' Just a silly precaution.
Const kstrSignature = "BPML"

Dim gbUserChooses As Boolean    ' True if user clicks OK in dlgbox, False if Cancel

' Row on each worksheet containing the column titles
Const knTitleRow = 2

'Declare Function FindExecutable Lib "shell32.dll" Alias "FindExecutableA" (ByVal lpFile As String, ByVal lpDirectory As String, ByVal lpResult As String) As Long

'=========================================================================

Sub LaunchDoc()
Attribute LaunchDoc.VB_ProcData.VB_Invoke_Func = " \n14"
    
    Dim FilePath As String
    Dim strError As String
    Dim nColStart As Long
    Dim nColEnd As Long
    Dim strSheetName As String
    Dim bNoLaunchNow As Boolean
    Dim bNoLaunchEver As Boolean
    Dim strPartialDocName As String
    Dim nDoctype As Long
    Dim MsgText As String
    Dim MsgTitle As String
    
    
    If VerifyBPMLWorkbook = False Then
        Exit Sub
    End If
        
    '---------------------------------------------------------------------
    ' Init vbles
    '---------------------------------------------------------------------
    GetKeyValue HKEY_CURRENT_USER, gsRegKeyExternalFiles, gsRegValBPPPath, FilePath, strError
    
    strSheetName = ActiveSheet.Name
    
    '---------------------------------------------------------------------
    ' Set nColStart, nColEnd -- columns in which partial filenames can
    ' occur -- depending on which worksheet is active.
    ' Also set bNoLaunchNow, bNoLaunchEver -- "launchability" of wks.
    '---------------------------------------------------------------------
    GetWorksheetLaunchInfo strSheetName, nColStart, nColEnd, bNoLaunchNow, bNoLaunchEver
        
        
    '---------------------------------------------------------------------
    ' Deal with don't-care cases
    '---------------------------------------------------------------------
    If bNoLaunchNow Then
        MsgText = Worksheets("Translation").Cells(245, gIntlOffset).Value
        MsgTitle = Worksheets("Translation").Cells(2, gIntlOffset).Value
        MsgBox MsgText, vbOKOnly, MsgTitle
        GoTo ByeBye
    ElseIf bNoLaunchEver Then
        MsgText = Worksheets("Translation").Cells(245, gIntlOffset).Value
        MsgTitle = Worksheets("Translation").Cells(2, gIntlOffset).Value
        MsgBox MsgText, vbOKOnly, MsgTitle
        GoTo ByeBye
    End If
    
    '---------------------------------------------------------------------
    ' We're on a valid worksheet.
    ' Set strPartialDocName, nDoctype
    '---------------------------------------------------------------------
    ' Here's what we do:
    ' * Make list of triples
    '       title from row 2, text of cell in <curr row, col i>, type (BPP, CI, ...)
    '   provided the text of cell is nonempty
    '   where i ranges from nRowStart to nRowEnd.
    ' * If "list" length is 0, then do: MsgBox "This row has no associated file."
    ' * If list is length > 2,
    '       present user with a "menu" -- the titles (1st field of items in list);
    '       if user cancels, abort;
    '       if user picks i-th elt, use text (2nd field) of that element as
    '          a (partial) doc name (filename if BPP-ID, key if CI-ID, etc.),
    '          and use type (3rd field of triple) to determine what to do
    '          (open doc in Word, lookup & display records from qadb, etc.)
    ' * If list length is 1, then act as though the user chose the only item
    '   i.e. skip the dialog box.
    '---------------------------------------------------------------------
    
    If nColStart = nColEnd Then     ' just get the text (partial filename)
        strPartialDocName = Cells(ActiveCell.row, nColStart).Text
        ' Trim strPartialDocName
        strPartialDocName = Trim(strPartialDocName)
        nDoctype = knDoctypeBPP
    Else                            ' (nColStart < nColEnd)
        ' Get strPartialDocName, nDoctype
        If Not UserChoosesDoc(nColStart, nColEnd, strPartialDocName, nDoctype) Then  ' user cancelled
            GoTo ByeBye
        End If
        ' Assert: strPartialDocName is Trim-med
    End If

   
    '- - - - - - - - - - -
    ' Error handling:
    '- - - - - - - - - - -
    If strPartialDocName = "" Or ActiveCell.row <= (knTitleRow + 1) Then
        MsgText = Worksheets("Translation").Cells(247, gIntlOffset).Value
        MsgTitle = Worksheets("Translation").Cells(2, gIntlOffset).Value
        If nColStart < nColEnd Then     ' possibly multiple filenames in this row
            MsgText = Worksheets("Translation").Cells(248, gIntlOffset).Value
        End If
        MsgBox MsgText, vbOKOnly, MsgTitle

        GoTo ByeBye
    End If
    
    '---------------------------------------------------------------------
    ' Now do the right thing, depending on doctype
    '---------------------------------------------------------------------
    Select Case nDoctype
        
        Case knDoctypeBPP
            
            Dim sFileNm As String
            sFileNm = MakeFilename(FilePath, strPartialDocName)
            
            ' Handle nonexistence
            If Dir(sFileNm) = "" Then           ' file doesn't exist
                MsgText = Worksheets("Translation").Cells(249, gIntlOffset).Value & "  "
                MsgText = MsgText & sFileNm & " "
                MsgText = MsgText & Worksheets("Translation").Cells(250, gIntlOffset).Value
                MsgTitle = Worksheets("Translation").Cells(2, gIntlOffset).Value
                MsgBox MsgText, vbOKOnly, MsgTitle
                GoTo ByeBye
            End If
            
            '1/29--Diane--added other file types functionality
            Select Case Right(sFileNm, 3)
            Case "doc"
                LaunchWord sFileNm
            Case "xls"
                LaunchExcel sFileNm
            Case "ppt"
                LaunchPowerPoint sFileNm
            Case "txt"
                LaunchNotepad sFileNm
            End Select
                    
        Case knDoctypeCIID
            
            Dim sRowDescr As String
            GetRowDescription sRowDescr
            LookupInQADB strPartialDocName, sRowDescr

        Case Else               ' can't happen!
            MsgText = Worksheets("Translation").Cells(251, gIntlOffset).Value
            MsgTitle = Worksheets("Translation").Cells(2, gIntlOffset).Value
            MsgBox MsgText, vbOKOnly, MsgTitle
            GoTo ByeBye
    End Select
    
    Exit Sub            ' normal exit
    
ByeBye:
    ' (nada)
    
End Sub

'=========================================================================
Function MakeFilename(sFilePath As String, sPartialDocName As String) As String
Attribute MakeFilename.VB_ProcData.VB_Invoke_Func = " \n14"

    '1/28--Diane--added tests for other types of files besides *.doc
    Dim sFilename As String
    
    '---------------------------------------------------------------------
    ' Set sFilename
    '---------------------------------------------------------------------

'Note, this tests for a doc, then xls, then ppt, then txt
'This is a quick fix, but should be changed so the full file name is stored in the database.
'Else, we can't have diff file types with the same name (i.e., X000345.doc and X000345.ppt)

    ' Make sure sFilePath ends in a path delimiter
    If Right(sFilePath, 1) <> "\" Then
        sFilePath = sFilePath + "\"
    End If
    
    ' Set sFilename = path + partial filename + ".doc"
    sFilename = sFilePath + sPartialDocName + ".doc"
    
    'Check to see if the doc exists
    If Dir(sFilename) = "" Then
        'If not, let's try Excel
        sFilename = sFilePath + sPartialDocName + ".xls"
    Else
        'If the doc exists, use it
        MakeFilename = sFilename
        Exit Function
    End If
    
    'Check to see if the xls exists
    If Dir(sFilename) = "" Then
        'If not, try power point
        sFilename = sFilePath + sPartialDocName + ".ppt"
    Else
        'If the xls exists, use it
        MakeFilename = sFilename
        Exit Function
    End If
    
    'Check to see if the ppt exists
    If Dir(sFilename) = "" Then
        'If not, try notepad
        sFilename = sFilePath + sPartialDocName + ".txt"
    Else
        'If the ppt exists, use it
        MakeFilename = sFilename
        Exit Function
    End If
    
    'Check to see if the txt exists
    If Dir(sFilename) = "" Then
        'If not, just return the filename with no extension
        MakeFilename = sFilePath + sPartialDocName
    Else
        'If the txt exists, use it
        MakeFilename = sFilename
        Exit Function
    End If

End Function
    
'=========================================================================
Sub LaunchWord(FileNm As String)
Attribute LaunchWord.VB_ProcData.VB_Invoke_Func = " \n14"
    '---------------------------------------------------------------------
    ' Launch Word.
    ' Assume that if this is Excel95, then Word95 can be launched,
    ' and if this is Excel97, then Word97 can be launched.
    ' Two different cases, 'cause I dunno how to unify 'em.
    ' BTO 10/6/97
    '---------------------------------------------------------------------
    Dim strExcelVersion As String
    strExcelVersion = Application.Version           ' string of form "x.y"
    If (Asc(strExcelVersion) - Asc("0") < 8) Then   ' pre-office97
        LaunchWord95 FileNm
    Else
        LaunchWord97 FileNm
    End If
End Sub

'=========================================================================
Sub LaunchWord95(FileNm As String)
Attribute LaunchWord95.VB_ProcData.VB_Invoke_Func = " \n14"

    Dim MsgText As String
    Dim MsgTitle As String

    '---------------------------------------------------------------------
    ' So, uh, do it.
    ' If Word is running, activate it; otherwise, launch it.
    ' Open document FileNm in Word.
    '---------------------------------------------------------------------
Application.ScreenUpdating = False
    
    Const kstrAutomationClass = "Word.Basic"
    '-- NOTE: Word.Basic is the only top-level Automation
    '--       object exposed by Word95.  There is no
    '--       Word.Application object :((  MSKB Q114347

    On Error Resume Next    ' GetObject can throw an exception
    Set oWord = GetObject("", kstrAutomationClass)
    '-- NOTE: GetObject(, kstrAutomationClass) always fails. MSKB Q114347
        
    If Err <> 0 Then    ' error -- GetObject failed (Err.Number in Excel97)
'''     Set oWord = CreateObject(kstrAutomationClass)
        ' Ain't no Word
        MsgText = Worksheets("Translation").Cells(252, gIntlOffset).Value
        MsgTitle = Worksheets("Translation").Cells(2, gIntlOffset).Value
        MsgBox MsgText, vbOKOnly, MsgTitle
        Exit Sub
    End If

    oWord.Visible = True    '-- Make menus & toolbars appear(!). BTO 7/7/98
    
    oWord.FileOpen FileNm
    
    ' Activate Word, using ActivateMicrosoftApp, which...
    ' "Activates a Microsoft application. If the application
    '  is already running, this method activates the running
    '  application. If the application is not running, this
    '  method starts a new instance of the application."
    '
    ' The purpose of the ActivateMicrosoftApp method is
    ' presumably to simplify the mess they had already made...
    ' Without it, you'd have to write special-purpose code
    ' for each MicrosoftApp.
    Application.ActivateMicrosoftApp xlMicrosoftWord

'11/25--Diane--moved the above statement so Word isn't visible until doc is done opening
    'Note...still launches multiple copies of Word
    
    Application.ScreenUpdating = True
    
End Sub


'=========================================================================

Sub LaunchWord97(FileNm As String)
Attribute LaunchWord97.VB_ProcData.VB_Invoke_Func = " \n14"

    Dim MsgText As String
    Dim MsgTitle As String

    '---------------------------------------------------------------------
    ' So, uh, do it.
    ' If Word is running, activate it; otherwise, launch it.
    ' Open document in Word.
    '---------------------------------------------------------------------
    
    Application.ScreenUpdating = False

    Const kstrAutomationClass = "Word.Application"
      
    ' WaitForInputIdle on Word window (TODO, instead of AppActivate)
    
    On Error Resume Next    ' GetObject can throw an exception
    Set oWord = GetObject("", kstrAutomationClass)
    '-- NOTE: GetObject(, kstrAutomationClass) always fails. MSKB Q114347
    If Err <> 0 Then    ' error -- GetObject failed
'''     Set oWord = CreateObject(kstrAutomationClass)
        ' Ain't no Word
        MsgText = Worksheets("Translation").Cells(252, gIntlOffset).Value
        MsgTitle = Worksheets("Translation").Cells(2, gIntlOffset).Value
        MsgBox MsgText, vbOKOnly, MsgTitle
        Exit Sub
    End If

    oWord.Visible = True    '-- Make menus & toolbars appear(!). BTO 7/7/98
    
    ' Use Word automation to open the document
    oWord.Documents.Open FileNm

    ' Activate Word, using ActivateMicrosoftApp, which...
    ' "Activates a Microsoft application. If the application
    '  is already running, this method activates the running
    '  application. If the application is not running, this
    '  method starts a new instance of the application."
    '
    ' The purpose of the ActivateMicrosoftApp method is
    ' presumably to simplify the mess they had already made...
    ' Without it, you'd have to write special-purpose code
    ' for each MicrosoftApp.
    Application.ActivateMicrosoftApp xlMicrosoftWord
  
'11/25--Diane--moved the above statement so Word isn't visible until doc is done opening
    'Note...still launches multiple copies of Word
    
    Application.ScreenUpdating = True

End Sub

'=========================================================================
'1/29--Diane--added this one
Sub LaunchExcel(FileNm As String)
Attribute LaunchExcel.VB_ProcData.VB_Invoke_Func = " \n14"

    Application.ScreenUpdating = False
    'It's already open...
    Workbooks.Add FileNm
    Application.ScreenUpdating = True

End Sub

'=========================================================================
'1/29--Diane--added this one
Sub LaunchNotepad(FileNm As String)
Attribute LaunchNotepad.VB_ProcData.VB_Invoke_Func = " \n14"
    Dim rc As Long 'Return code for Shell

    Application.ScreenUpdating = False
    rc = Shell("notepad.exe " & FileNm, 1)
    Application.ScreenUpdating = True

End Sub

'1/29--Diane--added this too
'=========================================================================

Sub LaunchPowerPoint(FileNm As String)
Attribute LaunchPowerPoint.VB_ProcData.VB_Invoke_Func = " \n14"

    ' Open document in PPoint.
    Dim oPPT As Object
    Dim oPPTFile As Object
    Dim MsgText As String
    Dim MsgTitle As String
    
    Application.ScreenUpdating = False

    Const kstrAutomationClass = "PowerPoint.Application"
        
    On Error Resume Next    ' GetObject can throw an exception
    Set oPPT = GetObject("", kstrAutomationClass)
    'Set oPPT = GetObject(FileNm)
    If Err <> 0 Then    ' error -- GetObject failed
        MsgText = Worksheets("Translation").Cells(253, gIntlOffset).Value
        MsgTitle = Worksheets("Translation").Cells(2, gIntlOffset).Value
        MsgBox MsgText, vbOKOnly, MsgTitle
        Exit Sub
    End If
    On Error GoTo 0
    
    'Fake adding a new one to close the dialog
    oPPT.presentations.Add
    
    'Must be visible for the rest to work in PP95
    'No Version is exposed...this must be visible for 95, so try it and ignore the failure for 97
    On Error Resume Next
    oPPT.AppWindow.Visible = True
    Err = 0
    On Error GoTo 0
    
    ' Use automation to open the document
    Set oPPTFile = oPPT.presentations.Open(FileName:=FileNm, ReadOnly:=False, withwindow:=True)
    'We can test for Version...it's not exposed in PP!!!
    'Try the '95 way, if it fails, try the '97 way
        
    On Error Resume Next
    'In PP95, both the app window and the slideshow will be visible, no choice
    oPPTFile.SlideShow.Run SlideShowType:=2
    'If we got an error, we may be using PP97 with XL 95
    If Err <> 0 Then
        Err = 0
        'In PP97, only the slideshow will be active
        oPPTFile.SlideShowSettings.Run
    End If
    On Error GoTo 0
    
Cleanup:
    Application.ScreenUpdating = True
    Set oPPT = Nothing
    Set oPPTFile = Nothing
    
End Sub


'=========================================================================
' Set sRowDescr = text of first nonempty cell in row

Sub GetRowDescription(sRowDescr As String)
Attribute GetRowDescription.VB_ProcData.VB_Invoke_Func = " \n14"

    ' Save current cell "coords"
    Dim r As Long
    Dim c As Long
    r = ActiveCell.row
    c = ActiveCell.Column

    ' Set sRowDescr
    Application.GoTo Reference:="R" & r & "C" & 1
    If ActiveCell.Text = "" Then
        Selection.End(xlToRight).Select
    End If
    sRowDescr = ActiveCell.Text

    ' Restore formerly active cell
    Application.GoTo Reference:="R" & r & "C" & c

End Sub

'=========================================================================

Sub LookupInQADB(sCIID As String, sRowDescr As String)
Attribute LookupInQADB.VB_ProcData.VB_Invoke_Func = " \n14"

' TODO: This should be ShellEx (block) (?)
' TODO: This should use ActiveX interfaces (TODO: redo QAdbLkup)
    Dim sAppPath As String 'QADBLkup.exe
    Dim MsgText As String
    Dim MsgTitle As String
    
    '4/8--Diane--Get the QADBLkup.exe location from the registry
    GetKeyValue HKEY_CURRENT_USER, gsRegKeyExternalFiles, gsRegValQADBLKup, sAppPath, strError
        
    '12/9--Diane--Added check to make sure QAdbLkup.exe exists where we expect it
    If Dir(sAppPath) = "" Then GoTo Exit_LookupInDADB:
    
    Shell sAppPath & "QADBlkup.exe" & " " & kstrSignature & " " & sCIID & " " & """" & sRowDescr & """", 1
    
    Exit Sub
Exit_LookupInDADB:
    MsgText = Worksheets("Translation").Cells(254, gIntlOffset).Value
    MsgTitle = Worksheets("Translation").Cells(255, gIntlOffset).Value
    MsgBox MsgText, vbOKOnly, MsgTitle
End Sub
'=========================================================================

Sub GetWorksheetLaunchInfo( _
                        ByVal strSheetName As String, _
                        nColStart As Long, nColEnd As Long, _
                        bNoLaunchNow As Boolean, bNoLaunchEver As Boolean)
Attribute GetWorksheetLaunchInfo.VB_ProcData.VB_Invoke_Func = " \n14"

    bNoLaunchNow = False
    bNoLaunchEver = False
    
    If strSheetName = gsMasterListName Then        ' Master list
            nColStart = 32 '30          ' AD
            nColEnd = 34 '32            ' AF
            'Shah 8/27/98
            If strSheetName = gsMasterListName Then        ' Master list
                    nColStart = 29 '27          ' AA
                    nColEnd = 34 '32            ' AF
            End If
    ElseIf strSheetName = gsBaselineName Then       ' Baseline
            nColStart = 6           ' F
            nColEnd = 8             ' H
    ElseIf Len(strSheetName) = 3 Then
        Select Case Left(strSheetName, 1)
            Case gsCycleName                         ' C 1, C 2, C 3, C 4
                nColStart = 6       ' F
                nColEnd = 8         ' H
            Case gsIntegrationName                            ' I 1, I 2
                nColStart = 6       ' F
                nColEnd = 8         ' H
            Case Else                           ' do nothing
                bNoLaunchEver = True
        End Select
    ElseIf strSheetName = gsEUPName Then            ' EUP
        ' do nothing
        ' (ignore, for now)
        bNoLaunchNow = True
    ElseIf strSheetName = gsJob1Name Then   ' Job1
        ' do nothing
        ' (ignore, for now)
        bNoLaunchNow = True
    ElseIf strSheetName = gsJob2Name Then   ' Job2
        ' do nothing
        ' (ignore, for now)
        bNoLaunchNow = True
    Else                                        ' do nothing
        bNoLaunchEver = True
    End If
        
End Sub

'=========================================================================
' Present user with dialog box AssocDocsDialog listing the titles
' of all nonempty cells in this row and in cols nColStart...nColEnd
' Returns False if user cancels dialog box AssocDocsDialog.
' O/w, return True (no files to launch, or user clicked OK).
' If all cells in range are empty text ("")(i.e. no files),
' then set strUserChoice to ""; otherwise, set strUserChoice to the
' contents of the cell in this row whose heading/title the user selected.
' If only one cell is nonempty, just return its contents in strUserChoice.
'
' Set type (BPP, CI, ...)
'
Function UserChoosesDoc( _
                ByVal nColStart As Long, ByVal nColEnd As Long, _
                strUserChoice As String, nUserChoiceType As Long _
                ) As Boolean
Attribute UserChoosesDoc.VB_ProcData.VB_Invoke_Func = " \n14"

    UserChoosesDoc = True  ' default return value
    
    '---------------------------------------------------------------------
    ' Initialize listbox data (worksheet AssocDocs_scrap) for current row.
    '---------------------------------------------------------------------
    Dim nCount As Long
    nCount = InitListboxData(nColStart, nColEnd)    ' # items
    
    '---------------------------------------------------------------------
    ' Special case:
    ' Return True, but set strUserChoice to empty if no files to launch.
    '---------------------------------------------------------------------
    If nCount = 0 Then
        strUserChoice = ""
        Exit Function           ' returning True
    End If
    
    '---------------------------------------------------------------------
    ' Special case:
    ' If only one element in list, return that (skip dialog box).
    ' We don't have to do anything (except skip the dlg):
    ' the cell on sheet "AssocDocs_scrap" which contains the initial item
    ' to select (F1, actually) has been initialized to 1 by InitListboxData
    '---------------------------------------------------------------------
    If nCount = 1 Then
        GoTo UserChoosesDoc_UserOKed__
    End If
    
    '---------------------------------------------------------------------
    ' Display dialog.
    ' If users clicks OK, macro AssocDocs_OK fires,
    ' which sets gbUserChooses = True;
    ' if user clicks Cancel, macro AssocDocs_Cancel fires,
    ' which sets gbUserChooses = False.
    ' Check value of global flag:
    ' if gbUserChooses = False, just return False (quit quietly).
    '---------------------------------------------------------------------
    
    'Diane--dialog name won't be translated
    DialogSheets("AssocDocsDialog").DialogFrame.Caption = Worksheets("Translation").Cells(278, gIntlOffset).Value
    DialogSheets("AssocDocsDialog").Buttons("OK").Caption = Worksheets("Translation").Cells(279, gIntlOffset).Value
    DialogSheets("AssocDocsDialog").Buttons("Cancel").Caption = Worksheets("Translation").Cells(280, gIntlOffset).Value
    DialogSheets("AssocDocsDialog").Show
        
    If Not gbUserChooses Then       ' user Cancelled
        UserChoosesDoc = False
        Exit Function
    End If
    
UserChoosesDoc_UserOKed__:
    '---------------------------------------------------------------------
    ' Otherwise, set strUserChoice to string associated with
    ' selection, set nUserChoiceType, and return True.
    '---------------------------------------------------------------------
    ' Get selected item index (1-based) -- use it as row number
    Dim nSelectedRow As Long
    'Diane--dialog worksheet name won't be translated
    nSelectedRow = Worksheets("AssocDocs_scrap").Cells(knListLinkedCellRow, knListLinkedCellCol).Value

    ' Get associated string (filename or CI-ID or ...) in row nSelectedRow.
    ' It's adjacent (col 2) to selected title/heading (col 1)
    strUserChoice = Worksheets("AssocDocs_scrap").Cells(nSelectedRow, 2).Text
    
    ' Get nUserChoiceType
    ' It's adjacent (col 3) to selected title/heading (col 1) and assoc string (col 2)
    nUserChoiceType = Worksheets("AssocDocs_scrap").Cells(nSelectedRow, 3).Value
    
    ' Return True (it's gonna happen)
        
End Function


'=========================================================================
' Sets gbUserChooses = True; fired when user clicks OK in AssocDocsDialog

Sub AssocDocs_OK()
Attribute AssocDocs_OK.VB_ProcData.VB_Invoke_Func = " \n14"
    gbUserChooses = True
End Sub

'=========================================================================
' Sets gbUserChooses = False; fired when user clicks Cancel in AssocDocsDialog

Sub AssocDocs_Cancel()
Attribute AssocDocs_Cancel.VB_ProcData.VB_Invoke_Func = " \n14"
    gbUserChooses = False
End Sub

'=========================================================================
' Initialize listbox data (worksheet AssocDocs_scrap) for current row.
' Return count of number of items (possibly 0).
'---------------------------------------------------------------------
' Put headings (from row knTitleRow, cols nColStart..nColEnd) of nonempty
' filenames (from this row) in col 1 of AssocDocs_scrap,
' and put the corresponding associated strings (filenames or keys)
' (from this row) in col 2 of AssocDocs_scrap,
' and put the type of the item (BPP, CI, etc.) in col 3.
' Set listbox initial selection  to 1 by setting value of cell at
' knListLinkedCellRow, knListLinkedCellCol on AssocDocs_scrap to 1.
'=========================================================================

Function InitListboxData( _
                ByVal nColStart As Long, ByVal nColEnd As Long _
                ) As Long
Attribute InitListboxData.VB_ProcData.VB_Invoke_Func = " \n14"

    ' (nRow + 1) = the row on AssocDocs_scrap where next listbox item goes
    ' This function returns nRow.
    Dim nRow As Long             ' retval
    nRow = 0
    
    '---------------------------------------------------------------------
    ' Collect list items
    '---------------------------------------------------------------------
    Dim i As Long
    
    For i = nColStart To nColEnd
        ' add title only if cell in this row, that col (i)
        ' is nonempty (**when trimmed**)
        strCellText = Cells(ActiveCell.row, i).Text
        strCellText = Trim(strCellText)
        If strCellText <> "" Then
            nRow = nRow + 1
            
            ' Put heading above cell in col 1,
            ' so it'll appear in listbox
            Worksheets("AssocDocs_scrap").Cells(nRow, 1).Value = Cells(knTitleRow, i).Text

            ' Put associated string (partial filename, CI-ID, etc.) (cell text) in col 2,
            ' next to text that'll appear in listbox
            Worksheets("AssocDocs_scrap").Cells(nRow, 2).Value = strCellText
        
            ' Put type of cell (knDoctypeXXXXX) in col 3.
            ' NOTE WELL (BTO 10-11-97): The logic & assumptions here are
            ' the simplest possible. Namely, the type is BPP (partial filename)
            ' unless it's the last col of a sheet with multiple cols to launch from,
            ' and then it's a CI-ID
            If (nColStart = nColEnd) Or (i < nColEnd) Then  ' it's a BPP ID
                Worksheets("AssocDocs_scrap").Cells(nRow, 3).Value = knDoctypeBPP
            Else                                            ' it's a CI-ID
                Worksheets("AssocDocs_scrap").Cells(nRow, 3).Value = knDoctypeCIID
            End If
            
        End If
    Next i
    
    '---------------------------------------------------------------------
    ' Link region to the listbox
    '---------------------------------------------------------------------
    
    ' set item range
    DialogSheets("AssocDocsDialog").ListBoxes("lbxTitles").ListFillRange = _
        "AssocDocs_scrap!A1:A" & nRow
    
    '---------------------------------------------------------------------
    ' Set linked cell
    '---------------------------------------------------------------------
    DialogSheets("AssocDocsDialog").ListBoxes("lbxTitles").LinkedCell = _
        "AssocDocs_scrap!" & kstrListLinkedCell
    
    '---------------------------------------------------------------------
    ' Set initial list selection data
    '---------------------------------------------------------------------
    Worksheets("AssocDocs_scrap").Cells(knListLinkedCellRow, knListLinkedCellCol).Value = 1
    
    '---------------------------------------------------------------------
    ' Return item count
    '---------------------------------------------------------------------
    InitListboxData = nRow

End Function
Attribute VB_Name = "LaunchHelp Module"














































































































'2/9--Diane--redid code strings for translation lookup--none here

Option Explicit

Public Const HELP_CONTEXT = &H1          '  Display topic in ulTopic
Public Const HELP_QUIT = &H2             '  Terminate help
Public Const HELP_INDEX = &H3            '  Display index
Public Const HELP_CONTENTS = &H3&
Public Const HELP_HELPONHELP = &H4       '  Display help on using help
Public Const HELP_SETINDEX = &H5         '  Set current Index for multi index help
Public Const HELP_SETCONTENTS = &H5&
Public Const HELP_CONTEXTPOPUP = &H8&
Public Const HELP_FORCEFILE = &H9&
Public Const HELP_KEY = &H101            '  Display topic for keyword in offabData
Public Const HELP_COMMAND = &H102&
Public Const HELP_PARTIALKEY = &H105&
Public Const HELP_MULTIKEY = &H201&
Public Const HELP_SETWINPOS = &H203&

Declare Function WinHelp Lib "user32" Alias "WinHelpA" (ByVal hwnd As Long, ByVal lpHelpFile As String, ByVal wCommand As Long, ByVal dwData As Long) As Long
Attribute WinHelp.VB_ProcData.VB_Invoke_Func = " \n14"

Sub LaunchHelp()
Attribute LaunchHelp.VB_ProcData.VB_Invoke_Func = " \n14"
    
    Dim sHelpFile As String
    Dim strError As String
    If VerifyBPMLWorkbook = False Then
        Exit Sub
    End If

    'Now storing entire path and filename in the registry
    GetKeyValue HKEY_CURRENT_USER, gsRegKeyExternalFiles, gsRegValBPMLHelpFile, sHelpFile, strError
    
    WinHelp 0&, sHelpFile, HELP_CONTENTS, 0&
        
End Sub
Attribute VB_Name = "Module2"
Sub disable_events()
Application.EnableEvents = False
End Sub

Sub enable_events()
Application.EnableEvents = True
End Sub
Attribute VB_Name = "Outline"

'2/9--Diane--redid code strings for translation lookup

'Rewritten by Diane Schaffer, 11/14/97
'Creates an outline of columns "A"-"F" on the active worksheet
Sub MakeOutline()
Attribute MakeOutline.VB_ProcData.VB_Invoke_Func = " \n14"

    Dim iOrigUsedRows As Integer 'Original number of rows on the worksheet
    Dim iDeletedRows As Integer 'Number of blank rows deleted before evaluation
    Dim iCountRows As Integer 'Used to loop through rows used on the activesheet for deletion
    Dim iCountAreas As Integer 'Count of areas being evaluated in a given column
    Dim nTotalAreaCount As Long 'Total number of areas to evaluate in a given column
    Dim rgArea1 As Range 'Current Area being evaluated
    Dim rgArea2 As Range 'Next area to be evaluated
    Dim rgGroupArea As Range 'Area to group together
    Dim iFirstRow As Integer 'First row of the area to group
    Dim iLastRow As Integer 'Last row of the area to group
    Dim iCountParents As Integer 'Count of columns to evaluate
    Dim strColLetter As String 'Letter of column currently being evaluated
    Dim nConstVisible As Long 'Constant used for xlcelltypevisible in different versions of Excel
    Dim sStatusBarText As String
    
    If VerifyBPMLWorkbook = False Then
        Exit Sub
    End If
    
    On Error GoTo Exit_Testing:

    'Turn off screen updating...
    Application.ScreenUpdating = False
    Application.EnableEvents = False
    
    'Give some user feedback
    sStatusBarText = Worksheets("Translation").Cells(204, gIntlOffset).Value & "..."
    Application.StatusBar = sStatusBarText

    iOrigUsedRows = ActiveSheet.UsedRange.Rows.Count
    'Clean up blank rows (no "A"-"F" Data)
    For iCountRows = 5 To iOrigUsedRows
        If (iCountRows < iOrigUsedRows - iDeletedRows) And Cells(iCountRows, 1) = "" And Cells(iCountRows, 2) = "" And Cells(iCountRows, 3) = "" And Cells(iCountRows, 4) = "" And Cells(iCountRows, 5) = "" And Cells(iCountRows, 6) = "" Then
            ActiveSheet.Rows(iCountRows).EntireRow.delete
            iDeletedRows = iDeletedRows + 1
            iCountRows = iCountRows - 1
        End If
        If iCountRows / 1000 = CInt(iCountRows / 1000) Then
            sStatusBarText = Worksheets("Translation").Cells(204, gIntlOffset).Value & "..."
            sStatusBarText = sStatusBarText & Worksheets("Translation").Cells(205, gIntlOffset).Value & ": "
            sStatusBarText = sStatusBarText & iCountRows
            Application.StatusBar = sStatusBarText
        End If
    Next

    'Clear the current outline...if there is none, no error occurs
    ActiveSheet.Rows.ClearOutline
    ActiveSheet.Rows.EntireRow.Hidden = False
    
    'Give some user feedback
    sStatusBarText = Worksheets("Translation").Cells(206, gIntlOffset).Value & "..."
    Application.StatusBar = sStatusBarText
   
    'Column F
    For Each rgArea1 In ActiveSheet.Columns(6).SpecialCells(xlTextValues).Areas
        If rgArea1.row >= 5 Then
           ' ActiveSheet.Range(Cells(rgArea1.Row + rgArea1.Rows.Count, 5)).EntireRow.Insert
            rgArea1.Rows.group
        End If
    Next
    
    'Collapse the existing levels
    ActiveSheet.Outline.ShowLevels 1
    
    'Columns E-A
    For iCountParents = 5 To 2 Step -1
        Select Case iCountParents
            Case 5
                strColLetter = "5" '"E"
                sStatusBarText = Worksheets("Translation").Cells(207, gIntlOffset).Value & "..."
                Application.StatusBar = sStatusBarText
            Case 4
                strColLetter = "4" '"D"
                sStatusBarText = Worksheets("Translation").Cells(207, gIntlOffset).Value & "..."
                Application.StatusBar = sStatusBarText
            Case 3
                strColLetter = "3" '"C"
                sStatusBarText = Worksheets("Translation").Cells(208, gIntlOffset).Value & "..."
                Application.StatusBar = sStatusBarText
            Case 2
                strColLetter = "2" '"B"
                sStatusBarText = Worksheets("Translation").Cells(209, gIntlOffset).Value & "..."
                Application.StatusBar = sStatusBarText
        End Select
    
        'Watch out for different constants indifferent XL versions...
        If InStr(Application.Version, "8") > 0 Then
            nConstVisible = xlCellTypeVisible
        Else
            nConstVisible = xlVisible
        End If
        
        'Reset counters from the last column
        iCountAreas = 0
        nTotalAreaCount = ActiveSheet.Columns(CInt(strColLetter)).SpecialCells(nConstVisible).SpecialCells(xlTextValues).Areas.Count
    
        'Loop through the non-blank areas in the column to evaluate for grouping
        For Each rgArea1 In ActiveSheet.Columns(CInt(strColLetter)).SpecialCells(nConstVisible).SpecialCells(xlTextValues).Areas
            iCountAreas = iCountAreas + 1
            If rgArea1.row >= 5 Then
                'Don't do this until we're in the "real" used area of the worksheet
                If ActiveSheet.Cells(rgArea1.row - 1, iCountParents - 1).Value <> "" Then
                'We're at a beginning group row
ProcessLastArea:
                    'Make sure we've done this once before so we don't error on the first area
                    If Not (rgArea2 Is Nothing) Then
                        
                        'Look for the end of this area's children
                        Do Until ActiveSheet.Rows(iLastRow + 1).Hidden = False
                            iLastRow = iLastRow + 1
                        Loop
                    
                        'Only insert a blank row if the last parent has children...
                        If iLastRow <> rgArea2.row + rgArea2.Rows.Count - 1 Then
                            ActiveSheet.Rows(iLastRow + 1).EntireRow.Insert
                        End If
                    
                        'We're at another beginning row, so outline the rows above us
                        Set rgGroupArea = Range(Cells(iFirstRow, iCountParents), Cells(iLastRow, iCountParents))
                        rgGroupArea.Rows.group
                        Set rgArea2 = Nothing
                        'If this is the last area, we're done...go to the next column
                        If iCountAreas = nTotalAreaCount + 1 Then
                            GoTo LastAreaDone:
                        End If
                    End If
                End If
            
                If rgArea2 Is Nothing Then
                    iFirstRow = rgArea1.row
                End If
            
                'Store this area so we can go back if we need to
                Set rgArea2 = rgArea1
                iLastRow = rgArea2.row + rgArea2.Rows.Count - 1
                
                'Loop one last time to group the last area
                If iCountAreas = nTotalAreaCount Then
                    iCountAreas = iCountAreas + 1
                    GoTo ProcessLastArea:
                End If
            End If
LastAreaDone:
        Next
        
        'Collapse existing levels of the outline so rows which are already grouped are hidden
        ActiveSheet.Outline.ShowLevels 1
    
    Next 'iCountParents

    'Fix up the tooltip text on the toolbar
    Application.Toolbars(gsSAPToolbarName).ToolbarButtons(2).Name = Worksheets("Translation").Cells(212, gIntlOffset).Value

'Ensure that the Column "H" is grouped!
Group_Column_H

Exit_Testing:
'Clean up
    GoHome ActiveWorkbook.Name, ActiveSheet.Name
    Range("A5").Select
    Set rgArea1 = Nothing
    Set rgArea2 = Nothing
    Set rgGroupArea = Nothing

    Application.StatusBar = False
    Application.ScreenUpdating = True
    Application.EnableEvents = True
    
End Sub

Sub Group_Column_H()
'Macro hides Column "H" in the QAdb Sheet
Range("G1:H2").Select
    With Selection
        .WrapText = False
        .Orientation = 0
        .ShrinkToFit = False
        .MergeCells = False
    End With
    Columns("H:H").Select
    Selection.Columns.group
    Selection.Columns.ShowDetail = False
    Range("G1:H1").Select
    With Selection
        .VerticalAlignment = xlCenter
        .WrapText = False
        .Orientation = 0
        .ShrinkToFit = False
        .MergeCells = True
    End With
    Range("G2:H2").Select
    With Selection
        .WrapText = False
        .Orientation = 0
        .ShrinkToFit = False
        .MergeCells = True
    End With

End Sub
Attribute VB_Name = "Registry_Code"












































































































Option Explicit

'Global Registry Key constants
Public Const gsRegKeyQADB = "SOFTWARE\VB and VBA Program Settings\AcceleratedSAP Q&Adb 4.0\Settings"
Public Const gsRegValLanguage = "Installed Languages"
Public Const gsRegKeyExternalFiles = "SOFTWARE\VB and VBA Program Settings\AcceleratedSAP Q&Adb 4.0\External Files"
Public Const gsRegValBPMLHelpFile = "Bpml Help"
Public Const gsRegValBPPPath = "Location BPP Folder"
Public Const gsRegValQADBLKup = "Location Application Path"

' Reg Key Security Options...
Public Const READ_CONTROL = &H20000
Public Const KEY_QUERY_VALUE = &H1
Public Const KEY_SET_VALUE = &H2
Public Const KEY_CREATE_SUB_KEY = &H4
Public Const KEY_ENUMERATE_SUB_KEYS = &H8
Public Const KEY_NOTIFY = &H10
Public Const KEY_CREATE_LINK = &H20
Public Const KEY_ALL_ACCESS = KEY_QUERY_VALUE + KEY_SET_VALUE + KEY_CREATE_SUB_KEY + KEY_ENUMERATE_SUB_KEYS + KEY_NOTIFY + KEY_CREATE_LINK + READ_CONTROL
Public Const REG_OPTION_NON_VOLATILE = 0

' Reg Key ROOT Types...
Public Const HKEY_CLASSES_ROOT As Long = &H80000000
Public Const HKEY_CURRENT_USER As Long = &H80000001
Public Const HKEY_LOCAL_MACHINE As Long = &H80000002
Public Const HKEY_USERS As Long = &H80000003
Public Const HKEY_CURRENT_CONFIG As Long = &H80000005

Public Const ERROR_SUCCESS = 0
Public Const REG_SZ = 1                         ' Unicode nul terminated string
Public Const REG_DWORD = 4                      ' 32-bit number
Public Const REG_MULTI_SZ = 7

Public Declare Function RegConnectRegistry Lib "advapi32.dll" Alias "RegConnectRegistryA" (ByVal lpMachineName As String, ByVal hKey As Long, phkResult As Long) As Long
Attribute RegConnectRegistry.VB_ProcData.VB_Invoke_Func = " \n14"
Public Declare Function RegOpenKeyEx Lib "advapi32" Alias "RegOpenKeyExA" (ByVal hKey As Long, ByVal lpSubKey As String, ByVal ulOptions As Long, ByVal samDesired As Long, ByRef phkResult As Long) As Long
Attribute RegOpenKeyEx.VB_ProcData.VB_Invoke_Func = " \n14"
Public Declare Function RegQueryValueEx Lib "advapi32" Alias "RegQueryValueExA" (ByVal hKey As Long, ByVal lpValueName As String, ByVal lpReserved As Long, ByRef lpType As Long, ByVal lpData As String, ByRef lpcbData As Long) As Long
Attribute RegQueryValueEx.VB_ProcData.VB_Invoke_Func = " \n14"
Public Declare Function RegCreateKeyEx Lib "advapi32.dll" Alias "RegCreateKeyExA" (ByVal hKey As Long, ByVal lpSubKey As String, ByVal Reserved As Long, ByVal lpClass As String, ByVal dwOptions As Long, ByVal samDesired As Long, ByVal lpSecurityAttributes As Long, phkResult As Long, lpdwDisposition As Long) As Long
Attribute RegCreateKeyEx.VB_ProcData.VB_Invoke_Func = " \n14"
Public Declare Function RegSetValueExString Lib "advapi32.dll" Alias "RegSetValueExA" (ByVal hKey As Long, ByVal lpValueName As String, ByVal Reserved As Long, ByVal dwType As Long, ByVal lpValue As String, ByVal cbData As Long) As Long
Attribute RegSetValueExString.VB_ProcData.VB_Invoke_Func = " \n14"
Public Declare Function RegCloseKey Lib "advapi32" (ByVal hKey As Long) As Long
Attribute RegCloseKey.VB_ProcData.VB_Invoke_Func = " \n14"

'Connects to a remote registry, opens a key and returns the value.  Processes  error too.
Public Function GetKeyValue(KeyRoot As Long, KeyName As String, SubKeyRef As String, ByRef KeyVal As Variant, ByRef ErrorText As Variant) As Boolean
Attribute GetKeyValue.VB_ProcData.VB_Invoke_Func = " \n14"
    Dim i As Long                                           ' Loop Counter
    Dim rc As Long                                          ' Return Code
    Dim hKey As Long                                        ' Handle To An Open Registry Key
    Dim KeyValType As Long                                  ' Data Type Of A Registry Key
    Dim tmpVal As String                                    ' Tempory Storage For A Registry Key Value
    Dim KeyValSize As Long                                  ' Size Of Registry Key Variable
    Dim hResult As Long 'Handle to registry
    '------------------------------------------------------------
    ' Open RegKey Under KeyRoot {HKEY_CURRENT_USER...}
    '------------------------------------------------------------
    
    rc = RegConnectRegistry("", KeyRoot, hResult)
    
    If (rc <> ERROR_SUCCESS) Then GoTo GetKeyError          ' Handle Error...
    
    rc = RegOpenKeyEx(hResult, KeyName, 0, KEY_ALL_ACCESS, hKey) ' Open Registry Key
    
    If (rc <> ERROR_SUCCESS) Then GoTo GetKeyError          ' Handle Error...
    
    tmpVal = String$(1024, 0)                             ' Allocate Variable Space
    KeyValSize = 1024                                   ' Mark Variable Size
    
    '------------------------------------------------------------
    ' Retrieve Registry Key Value...
    '------------------------------------------------------------
    rc = RegQueryValueEx(hKey, SubKeyRef, 0, KeyValType, tmpVal, KeyValSize)                              ' Get/Create Key Value
                        
    If (rc <> ERROR_SUCCESS) Then GoTo GetKeyError          ' Handle Errors
    
    If (Asc(Mid(tmpVal, KeyValSize, 1)) = 0) Then           ' Win95 Adds Null Terminated String...
        tmpVal = Left(tmpVal, KeyValSize - 1)               ' Null Found, Extract From String
    Else                                                    ' WinNT Does NOT Null Terminate String...
        tmpVal = Left(tmpVal, KeyValSize)                   ' Null Not Found, Extract String Only
    End If
    '------------------------------------------------------------
    ' Determine Key Value Type For Conversion...
    '------------------------------------------------------------
    Select Case KeyValType                                  ' Search Data Types...
    Case REG_SZ                                             ' String Registry Key Data Type
        KeyVal = tmpVal                                     ' Copy String Value
    Case REG_DWORD                                          ' Double Word Registry Key Data Type
        For i = Len(tmpVal) To 1 Step -1                    ' Convert Each Bit
            KeyVal = KeyVal + Hex(Asc(Mid(tmpVal, i, 1)))   ' Build Value Char. By Char.
        Next
        KeyVal = Str("&h" + KeyVal)
        ' Convert Double Word To String
    Case REG_MULTI_SZ
        If tmpVal <> "" Then
            KeyVal = Left(tmpVal, Len(tmpVal) - 1)
        End If
    End Select
    
    GetKeyValue = True                                      ' Return Success
    rc = RegCloseKey(hKey)                                  ' Close Registry Key
    Exit Function                                           ' Exit
    
GetKeyError:      ' Cleanup After An Error Has Occured...
    If Not (GetKeyValue) Then
        'Even though this returns an English error, it's only to pass an error back to the calling function.
        ErrorText = "Error reading " & SubKeyRef & "."
    End If
    KeyVal = ""                                             ' Set Return Val To Empty String
    GetKeyValue = False                                     ' Return Failure
    rc = RegCloseKey(hKey)                                  ' Close Registry Key
End Function

Public Function CreateNewKey(NewKeyName As String, PredefinedKey As Long) As Boolean
Attribute CreateNewKey.VB_ProcData.VB_Invoke_Func = " \n14"
    
    Dim mhNewKey As Long 'Handle to the new key
    Dim mlRetVal As Long 'Result of the RegCreateKeyEx function
 
    'Create the new key
    mlRetVal = RegCreateKeyEx(PredefinedKey, NewKeyName, 0&, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, 0&, mhNewKey, mlRetVal)
        
    'Close the new key
    RegCloseKey (mhNewKey)
       
End Function

Public Function SetKeyValue(KeyName As String, ValueName As String, ValueSetting As String, ValueType As Long, PredefinedKey As Long) As Boolean
Attribute SetKeyValue.VB_ProcData.VB_Invoke_Func = " \n14"
       
    Dim mlRetVal As Long 'Result of the SetValueEx function
    Dim mhKey As Long 'Handle of open key
 
    'Null terminate the string
    ValueSetting = ValueSetting & Chr$(0)
    
    'Open the specified key
    mlRetVal = RegOpenKeyEx(PredefinedKey, KeyName, 0, KEY_ALL_ACCESS, mhKey)
    'Set the value
    mlRetVal = RegSetValueExString(mhKey, ValueName, 0&, ValueType, ValueSetting, Len(ValueSetting))
    'Close the key
    RegCloseKey (mhKey)
       
    If mlRetVal = ERROR_SUCCESS Then
        SetKeyValue = True
    Else
        SetKeyValue = False
    End If
    
End Function

Attribute VB_Name = "Sap_Code"

Option Explicit

' logon and connection declarations Dariusz 06/17/99
Dim LogonControl As Object
Dim oConnection As Object

' function declarations Dariusz 06/17/99
Dim functions As Object
Dim fTcodeTrans As Object
Dim fIMGDisp As Object
Dim fReturn As Object

' logon connection flags Dariusz 06/17/99
Dim logonFlag As String
Dim logedInFlag As String

' correct cell identifiers
Dim Process As String
Dim Project As String

' change oConnection parameters
Dim chang_logPar As Boolean
Dim oConn_language As String
Dim oConn_user As String
Dim oConn_client As Integer
Dim oConn_systNum As Integer
Dim oConn_appServer As String
Dim sProjID_temp As String
Dim proj_disp_counter As Integer


' SAPhexGuid conversion
Dim data_array
Dim mbox_return As Integer

Global giButtonIndex As Integer
Dim gsLastException As String

Dim ghGUIWindow As Long
Dim ghXLSWindow As Long

' Windows API Declarations
Declare Function SetActiveWindow Lib "user32" (ByVal hwnd As Long) As Long
Declare Function GetActiveWindow Lib "user32" () As Long
Declare Function SetForegroundWindow Lib "user32" (ByVal hwnd As Long) As Long
Declare Function GetForegroundWindow Lib "user32" () As Long
Declare Function ShowWindow Lib "user32" (ByVal hwnd As Long, ByVal nCmdShow As Long) As Long

Public Const SW_SHOW = 5
Public Const SW_SHOWMAXIMIZED = 3



Public Type udtSAP_ST_BDI_LINE
  Line As String * 1000
End Type



Function LOGON()
'Shah and Dariusz 6/10/99

If logedInFlag <> "X" Then

    ' ask user if she/he has a valid network connection to  R/3
        Dim user_decision2
        user_decision2 = MsgBox(Worksheets("Translation").Cells(321, gIntlOffset).Value, vbYesNo, Worksheets("Translation").Cells(322, gIntlOffset).Value)

        If user_decision2 <> 6 Then
            Exit Function
        End If
    
Application.Cursor = xlWait

'initiate logonFlag
    logonFlag = ""
'create SAP LogonControl object
    Set LogonControl = CreateObject("SAP.LogonControl.1")
    
' create connection object
    Set oConnection = LogonControl.NewConnection

' provide QADB defoult R/3 Logon information
    If chang_logPar = False Then
        oConnection.Client = Sheets("Logon_Info").Cells(6, 2)
        oConnection.User = Sheets("Logon_Info").Cells(5, 2)
        oConnection.language = Sheets("Logon_Info").Cells(3, 2)
        'oConnection.Password = Sheets("Logon_Info").Cells(4, 2)
        oConnection.SystemNumber = Sheets("Logon_Info").Cells(2, 2)
        oConnection.ApplicationServer = Sheets("Logon_Info").Cells(1, 2)
    Else
        oConnection.language = oConn_language
        oConnection.User = oConn_user
        oConnection.Client = oConn_client
        'Sheets("Logon_Info").Cells(4, 2) = oConnection.Password
        oConnection.SystemNumber = oConn_systNum
        oConnection.ApplicationServer = oConn_appServer
    End If
    
' RFC With R/3 GUI
    oConnection.RfcWithDialog = 4

' Status bar
    Application.StatusBar = Worksheets("Translation").Cells(342, gIntlOffset).Value


' logon to R/3
    If Not oConnection.LOGON(0, False) Then
    
        Application.StatusBar = Worksheets("Translation").Cells(340, gIntlOffset).Value
    
    Application.Cursor = xlDefault
        If oConnection.IsConnected <> 2 Then
            MsgBox Worksheets("Translation").Cells(323, gIntlOffset).Value
        End If
    Exit Function
    End If
    

    If oConnection.language <> Sheets("Logon_Info").Cells(3, 2) Or oConnection.User <> Sheets("Logon_Info").Cells(5, 2) Or oConnection.Client <> Mid(Sheets("Logon_Info").Cells(6, 2), 2, 3) Or oConnection.SystemNumber <> Sheets("Logon_Info").Cells(2, 2) Or oConnection.ApplicationServer <> Sheets("Logon_Info").Cells(1, 2) Then
        chang_logPar = True
    
    'If oConnection.language <> oConn_language Or oConnection.User <> oConn_user Or oConnection.Client <> oConn_client Or oConnection.SystemNumber <> oConn_systNum Or oConnection.ApplicationServer <> oConn_appServer Then
            proj_disp_counter = 0
            sProjID_temp = ""
    '  End If
    
        
    ' save logon information
        oConn_language = oConnection.language
        oConn_user = oConnection.User
        oConn_client = oConnection.Client
        'Sheets("Logon_Info").Cells(4, 2) = oConnection.Password
        oConn_systNum = oConnection.SystemNumber
        oConn_appServer = oConnection.ApplicationServer
    End If

    ghGUIWindow = GetForegroundWindow()
    Application.StatusBar = Worksheets("Translation").Cells(341, gIntlOffset).Value & "  " & oConnection.ApplicationServer

 
' set logon flag to "X" = logon
    logonFlag = "X"
    logedInFlag = "X"
    
 
 ' create function collection
    Set functions = CreateObject("SAP.Functions")
        functions.LogFileName = "c:\asap_bpml46alog.txt"
        functions.LogLevel = 8

' set the connection
    Set functions.Connection = oConnection
    
' create ASAP_IMG_DISPLAY_FOR_PROCESS function
    Set fIMGDisp = functions.Add("ASAP_IMG_DISPLAY_FOR_PROCESS")
    
' create TRANSACTION_CALL_VIA_RFC function
    Set fTcodeTrans = functions.Add("TRANSACTION_CALL_VIA_RFC")
    
Application.Cursor = xlDefault
End If

End Function

Sub pSAPLogOff()
'Shah and Dariusz 6/10/99
If logonFlag = "X" Then

' ask user if she/he wants to Logoff from R/3
Dim user_decision
user_decision = MsgBox(Worksheets("Translation").Cells(324, gIntlOffset).Value, vbYesNo, "Logoff")

    If user_decision = 6 Then
        oConnection.Logoff
        Set oConnection = Nothing
        
' Change the statusbar
    Application.StatusBar = Worksheets("Translation").Cells(340, gIntlOffset).Value
    
        logonFlag = ""
        logedInFlag = ""
    End If
Else
 Exit Sub
End If
       
End Sub


Sub Button_Trans()
'Shah and Dariusz 6/10/99

    ghXLSWindow = GetActiveWindow()

' Check if user is Loged in to R/3 system
 If logonFlag = "X" Then
 
 Application.Cursor = xlWait

    If oConnection.IsConnected <> 1 Then
    
        oConnection.Logoff
        Set oConnection = Nothing
        Application.StatusBar = Worksheets("Translation").Cells(340, gIntlOffset).Value
    
        logonFlag = ""
        logedInFlag = ""
    
    Application.Cursor = xlDefault
        mbox_return = 2
        mbox_return = MsgBox(Worksheets("Translation").Cells(325, gIntlOffset).Value, vbOKCancel)
    
        If mbox_return = 1 Then
            Call LOGON
            SetForegroundWindow (ghXLSWindow)
            If logedInFlag = "X" Then
                Call Button_Trans
            End If
        End If
    Else

' declere function parameters
    fTcodeTrans.Exports("TCODE") = UCase(Trim(Get_TCode()))
    
' exit if Get_Tcode = ""
        If fTcodeTrans.Exports("TCODE") = "" Then
            Application.Cursor = xlDefault
        Exit Sub
        End If
  
  SetForegroundWindow (ghGUIWindow)
  ShowWindow ghGUIWindow, 3
  
' Call SAP transaction

        If fTcodeTrans.Call <> True Then
        Application.Cursor = xlDefault
        MsgBox Worksheets("Translation").Cells(326, gIntlOffset).Value & Translate_Exceptions(fTcodeTrans.exception), vbInformation
        End If

  SetForegroundWindow (ghXLSWindow)
    End If
    ghXLSWindow = 0
   ' ghGUIWindow = 0
 Else
    Application.Cursor = xlDefault
    
    Call LOGON
        SetForegroundWindow (ghXLSWindow)
    If logedInFlag = "X" Then
        Call Button_Trans
    End If
 End If
 Application.Cursor = xlDefault
End Sub


Sub Button_ProView()
  'Shah and Dariusz 6/10/99
  
  
  ghXLSWindow = GetActiveWindow()
  
' Check if user is Logon to R/3 system
 If logonFlag = "X" Then
 
 Application.Cursor = xlWait
 
    If oConnection.IsConnected <> 1 Then
    
        oConnection.Logoff
        Set oConnection = Nothing
        Application.StatusBar = Worksheets("Translation").Cells(340, gIntlOffset).Value
    
        logonFlag = ""
        logedInFlag = ""
        
    Application.Cursor = xlDefault
        mbox_return = 2
        mbox_return = MsgBox(Worksheets("Translation").Cells(325, gIntlOffset).Value, vbOKCancel)
    
        If mbox_return = 1 Then
            Call LOGON
            SetForegroundWindow (ghXLSWindow)
            If logedInFlag = "X" Then
                Call Button_ProView
            End If
        End If
    Else
    
    Project = Get_Project()
    If Project <> "" Then
        Process = Get_Node_Guid_IMG()
    End If
    
' declere function parameters
    fIMGDisp.Exports("PROCESS") = Process
    fIMGDisp.Exports("PROJECT") = Project
  
' exit if Get_Node_Guid or Get_Project = ""
    If Process = "" Or Project = "" Then
    Application.Cursor = xlDefault
        Exit Sub
    End If
    
  SetForegroundWindow (ghGUIWindow)
  ShowWindow ghGUIWindow, 3
  
' Call SAP transaction
    If fIMGDisp.Call <> True Then
    Application.Cursor = xlDefault
        MsgBox Worksheets("Translation").Cells(326, gIntlOffset).Value & Translate_Exceptions(fIMGDisp.exception), vbInformation
    proj_disp_counter = 0
    sProjID_temp = ""
    End If
    
   
   SetForegroundWindow (ghXLSWindow)
    End If
    ghXLSWindow = 0
 
  Else
  Application.Cursor = xlDefault
  
    Call LOGON
        SetForegroundWindow (ghXLSWindow)
    If logedInFlag = "X" Then
        Call Button_ProView
    End If
End If
Application.Cursor = xlDefault
End Sub


Sub Button_NoProView()
  'Shah and Dariusz 6/10/99
  
  ghXLSWindow = GetActiveWindow()
  
' Check if user is Logon to R/3 system
 If logonFlag = "X" Then
 
 Application.Cursor = xlWait
 
    If oConnection.IsConnected <> 1 Then
        
        oConnection.Logoff
        Set oConnection = Nothing
        Application.StatusBar = Worksheets("Translation").Cells(340, gIntlOffset).Value
    
        logonFlag = ""
        logedInFlag = ""
        
    Application.Cursor = xlDefault
        mbox_return = 2
        mbox_return = MsgBox(Worksheets("Translation").Cells(325, gIntlOffset).Value, vbOKCancel)
    
        If mbox_return = 1 Then
            Call LOGON
            SetForegroundWindow (ghXLSWindow)
            
            If logedInFlag = "X" Then
                Call Button_NoProView
            End If
        End If
    Else
     
    Project = Get_Project()
' declere function parameters
    fIMGDisp.Exports("PROCESS") = "10000000000000000000000000000000"
    fIMGDisp.Exports("PROJECT") = Project
    
    
' exit if Get_Node_Guid or Get_Project = ""
    If Project = "" Then
    Application.Cursor = xlDefault
        Exit Sub
    End If
    
    
  SetForegroundWindow (ghGUIWindow)
  ShowWindow ghGUIWindow, 3
  
' Call SAP transaction
    If fIMGDisp.Call <> True Then
    Application.Cursor = xlDefault
        MsgBox Worksheets("Translation").Cells(326, gIntlOffset).Value & Translate_Exceptions(fIMGDisp.exception), vbInformation
    proj_disp_counter = 0
    sProjID_temp = ""
    End If
    
  
   SetForegroundWindow (ghXLSWindow)
    
    End If
    ghXLSWindow = 0
   
  Else
  Application.Cursor = xlDefault
    
    Call LOGON
        SetForegroundWindow (ghXLSWindow)
        
    If logedInFlag = "X" Then
        Call Button_NoProView
    End If
    
  End If
  
Application.Cursor = xlDefault
  
  
End Sub


Sub Button_WholeView()
  'Shah and Dariusz 6/10/99
  
ghXLSWindow = GetActiveWindow()
  
' Check if user is Logon to R/3 system
 If logonFlag = "X" Then
 
 Application.Cursor = xlWait
 
    If oConnection.IsConnected <> 1 Then
        
        oConnection.Logoff
        Set oConnection = Nothing
        Application.StatusBar = Worksheets("Translation").Cells(340, gIntlOffset).Value
    
        logonFlag = ""
        logedInFlag = ""
        
    Application.Cursor = xlDefault
        mbox_return = 2
        mbox_return = MsgBox(Worksheets("Translation").Cells(325, gIntlOffset).Value, vbOKCancel)
    
        If mbox_return = 1 Then
            Call LOGON
            SetForegroundWindow (ghXLSWindow)
            If logedInFlag = "X" Then
                Call Button_WholeView
            End If
        End If
    Else

    
' declere function parameters

    Project = Get_Project()
    fIMGDisp.Exports("PROCESS") = " "
    fIMGDisp.Exports("PROJECT") = Project
    fIMGDisp.Exports("SHOW_PROJECT_IMG") = "X"
     
' exit if Get_Node_Guid or Get_Project = ""
    If Project = "" Then
    Application.Cursor = xlDefault
        Exit Sub
    End If
    
  SetForegroundWindow (ghGUIWindow)
  ShowWindow ghGUIWindow, 3
    
' Call SAP transaction
    If fIMGDisp.Call <> True Then
    Application.Cursor = xlDefault
        MsgBox Worksheets("Translation").Cells(326, gIntlOffset).Value & Translate_Exceptions(fIMGDisp.exception), vbInformation
    proj_disp_counter = 0
    sProjID_temp = ""
    End If
 
    SetForegroundWindow (ghXLSWindow)
    End If
   
   ghXLSWindow = 0
  
  Else
  Application.Cursor = xlDefault
    
    Call LOGON
        SetForegroundWindow (ghXLSWindow)
    If logedInFlag = "X" Then
        Call Button_WholeView
    End If
    
  End If
  
Application.Cursor = xlDefault
End Sub








Function fErrorMsgBox(AText As Integer, ATitle As Integer) As Integer
    Dim sMsgText As String
    Dim sMsgTitle As String

    sMsgText = Worksheets("Translation").Cells(AText, gIntlOffset).Value
    sMsgTitle = Worksheets("Translation").Cells(ATitle, gIntlOffset).Value
    fErrorMsgBox = MsgBox(sMsgText, vbOKOnly, sMsgTitle)
End Function


Function Get_TCode() As String
    Dim iTCodeColumn As Integer
    Dim rgTCodeRange As Range
    
    Get_TCode = ""
    
    Set rgTCodeRange = Cells(ActiveCell.row, ActiveCell.Column)
    
    'Changed test to look at the proper transcode column and make sure there's a proper value there
    If Len(CStr(rgTCodeRange)) > 20 Then
        Dim userAnswer
        Application.Cursor = xlDefault
        userAnswer = MsgBox(Worksheets("Translation").Cells(328, gIntlOffset).Value, vbOKOnly, Worksheets("Translation").Cells(329, gIntlOffset).Value)
        Exit Function
    ElseIf rgTCodeRange = "" Then
        Application.Cursor = xlDefault
        userAnswer = MsgBox(Worksheets("Translation").Cells(330, gIntlOffset).Value, vbOKOnly, Worksheets("Translation").Cells(329, gIntlOffset).Value)
        Exit Function
    End If

    
    Get_TCode = rgTCodeRange
End Function


Function Get_Project() As String
    Dim sProjID As String
    Dim sMsgText As String
    Dim sMsgTitle As String
    Dim iProjID As Integer
    Dim fProjID As Double
    Dim Response As String
    
    
    Get_Project = ""
    
    sMsgText = Worksheets("Translation").Cells(301, gIntlOffset).Value
    sMsgTitle = Worksheets("Translation").Cells(302, gIntlOffset).Value
    
If sProjID_temp <> "" Then
    Get_Project = sProjID_temp
Else
    
    sProjID = UCase(Trim(Sheets("Logon_Info").Cells(7, 2)))
    sProjID = Mid(sProjID, 2, 10)
    
    If proj_disp_counter <> 1 Then
        sProjID = UCase(Trim(InputBox(sMsgText, sMsgTitle, sProjID)))
    
       If sProjID = "" Then
            Response = MsgBox(Worksheets("Translation").Cells(331, gIntlOffset).Value, vbOKOnly, sMsgTitle)
            Exit Function
            
       End If
    
    
        If Len(CStr(sProjID)) > 10 Then

            Response = MsgBox(Worksheets("Translation").Cells(331, gIntlOffset).Value, vbOKOnly, sMsgTitle)
        Exit Function
        End If
        If sProjID <> Mid(Sheets("Logon_Info").Cells(7, 2), 2, 10) Then
            sProjID_temp = sProjID
        End If
    proj_disp_counter = 1
    
        Get_Project = sProjID
    Else
        Get_Project = sProjID
    End If
End If
End Function


Function Get_Node_Guid_IMG() As String
    Dim iNode_Guid_IMG_Column As Integer
    Dim iIMG_X_Flag_Column As Integer
    Dim rgNode_Guid_IMG As String
    Dim IMG_X_Flag As Range
    Dim userAnswer
    
Get_Node_Guid_IMG = ""

' Flag and Node_Guid Column position
    iIMG_X_Flag_Column = 12
    iNode_Guid_IMG_Column = 37
    
' Change flag and Node_Guid position Column
    If ActiveSheet.Name = "Org Structure List " Then
        iIMG_X_Flag_Column = 6
        iNode_Guid_IMG_Column = 28
        
    ElseIf ActiveSheet.Name = "Baseline" Then
        iIMG_X_Flag_Column = 14
        iNode_Guid_IMG_Column = 32
    
    ElseIf ActiveSheet.Name = "C 1" Or ActiveSheet.Name = "C 2" Or ActiveSheet.Name = "C 3" Or ActiveSheet.Name = "C 4" Then
        iIMG_X_Flag_Column = 14
        iNode_Guid_IMG_Column = 31
    End If
    
    
' check for a correct IMG flag = "X"
  
    Set IMG_X_Flag = Cells(ActiveCell.row, iIMG_X_Flag_Column)
    
If UCase(Trim(IMG_X_Flag)) = "X" Then
    Application.Cursor = xlDefault
    rgNode_Guid_IMG = SAPHexGuid(UCase(Trim(Cells(ActiveCell.row, iNode_Guid_IMG_Column))))
    
'Changed test to look at the proper transcode column and make sure it contains a proper value
    If Len(CStr(rgNode_Guid_IMG)) <> 32 Then
        Application.Cursor = xlDefault
        userAnswer = MsgBox(Worksheets("Translation").Cells(332, gIntlOffset).Value, vbOKOnly, Worksheets("Translation").Cells(333, gIntlOffset).Value)
        Exit Function
    ElseIf rgNode_Guid_IMG = "" Then
        Application.Cursor = xlDefault
        userAnswer = MsgBox(Worksheets("Translation").Cells(332, gIntlOffset).Value, vbOKOnly, Worksheets("Translation").Cells(333, gIntlOffset).Value)
        Exit Function
    End If

    
    Get_Node_Guid_IMG = rgNode_Guid_IMG
Else
    Application.Cursor = xlDefault
    userAnswer = MsgBox(Worksheets("Translation").Cells(332, gIntlOffset).Value, vbOKOnly, Worksheets("Translation").Cells(333, gIntlOffset).Value)
    Exit Function
End If

End Function

Function SAPHexGuid(SQLHexGuid As String) As String
Dim input_guid01 As String
Dim input_guid02 As String
Dim input_guid03 As String
Dim input_guid04 As String
Dim input_guid05 As String

' seperate {} and -
input_guid01 = Mid(SQLHexGuid, 2, 8)
input_guid02 = Mid(SQLHexGuid, 11, 4)
input_guid03 = Mid(SQLHexGuid, 16, 4)
input_guid04 = Mid(SQLHexGuid, 21, 4)
input_guid05 = Mid(SQLHexGuid, 26, 12)


' create sap hex guid
SAPHexGuid = input_guid01 & input_guid02 & input_guid03 & input_guid04 & input_guid05

End Function

Function Translate_Exceptions(exception As String) As String

'Possible exceptions:
    'NO_ASAP_IMG_VIEWS
    'NO_CUSTOMIZING_AUTHORITY
    'PROJECT_UNKNOWN
    'GENERATION_RUNNING
    'NO_ASAP_PROJECT
    'TCODE_NOT_EXIST
    'SYSTEM_FAILURE
Translate_Exceptions = ""
    
If exception = "NO_ASAP_IMG_VIEWS" Then
    Translate_Exceptions = Worksheets("Translation").Cells(334, gIntlOffset).Value
    
ElseIf exception = "NO_CUSTOMIZING_AUTHORITY" Then
    Translate_Exceptions = Worksheets("Translation").Cells(335, gIntlOffset).Value
    
ElseIf exception = "PROJECT_UNKNOWN" Then
    Translate_Exceptions = Worksheets("Translation").Cells(336, gIntlOffset).Value
    
ElseIf exception = "GENERATION_RUNNING" Then
    Translate_Exceptions = Worksheets("Translation").Cells(337, gIntlOffset).Value
    
ElseIf exception = "NO_ASAP_PROJECT" Then
    Translate_Exceptions = Worksheets("Translation").Cells(338, gIntlOffset).Value
    
ElseIf exception = "TCODE_NOT_EXIST" Then
    Translate_Exceptions = Worksheets("Translation").Cells(339, gIntlOffset).Value

ElseIf exception = "SYSTEM_FAILURE" Then
    Translate_Exceptions = Worksheets("Translation").Cells(343, gIntlOffset).Value
    
    oConnection.Logoff
    Set oConnection = Nothing
    Application.StatusBar = Worksheets("Translation").Cells(340, gIntlOffset).Value
    
    logonFlag = ""
    logedInFlag = ""
    
End If


End Function

Attribute VB_Name = "Sheet10"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True

Attribute VB_Name = "Sheet11"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True

Attribute VB_Name = "Sheet12"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True

Attribute VB_Name = "Sheet132"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True

Sub formatcells()

'Accelerate the evaluation by deactivation of the update/calculation-property
berechn_modus = Application.Calculation
aktual_modus = Application.ScreenUpdating
Application.Calculation = xlCalculationManual
Application.ScreenUpdating = False

With Range("B6:IV1000")
    .HorizontalAlignment = xlLeft
End With

'Re-set the update/calculation parameter
Application.Calculation = berechn_modus
Application.ScreenUpdating = aktual_modus

End Sub
Attribute VB_Name = "T_Overview"
Sub T_Ov()

On Error GoTo Overview_Error:

Dim T_Anfang, T_Ende As Long
Dim iCurrentColumnOverview As Long, iCurrentColumnMenu As Long, iCurrentColumnFormat As Long
Dim rgSuchBereich, hit1, hit2 As Range

'Geschwindigkeitsoptimierung
berechn_modus = Application.Calculation
aktual_modus = Application.ScreenUpdating
Application.Calculation = xlCalculationManual
Application.ScreenUpdating = False

'EnableEvents mu|fffd| ausgeschaltet werden, damit nicht das Makro Update_Values aufgerufen wird
Application.EnableEvents = False

'Overview ausw|fffd|hlen, damit die Eintr|fffd|ge in der T-Code |fffd|bersicht eingetragen werden
Worksheets(3).Activate

'Benutzer das erste mal in der Statuszeile benachrichtigen
Application.StatusBar = "Bitte gedulden Sie sich. Arbeitsblattinitialisierung...... "

    'L|fffd|sche vor der Generierung alle T-Codes aus der |fffd|bersicht. Annahme, da|fffd| keine Rolle  mehr als 600 T-Codes enth|fffd|lt
        With Range("B6:IV600")
            .Value = ""
        End With
        
    'L|fffd|sche alle Rollennamen und Business Areas
        With Range("B2:IV3")
            .Value = ""
        End With
        
    'Initialisiere alle Summenfelder der Rollen mit 0
        With Range("B5:IV5")
            .Value = "0"
        End With
        
'Die T-Codes der Worksheets QAdb und Menu werden in zwei Variant-Feldern gespeichert,um Zugriff zu beschleunigen
strQAdbT_Code = Worksheets(1).[G1:G62000]
strMenuT_Code = Worksheets(2).[K1:K62000]

'In T_Anfang wird die Startzeile der |fffd|bersicht f|fffd|r die Rollen gespeichert. T_Ende gibt die letzte Zeile des Bereichs an
T_Anfang = 6
T_Ende = T_Anfang

'In der zweiten Spalte des Overview-Sheets beginnt die Erstellung der |fffd|bersicht
iCurrentColumnOverview = 2

'Ab hier beginnt die Generierung der |fffd|bersicht. Es wird jede Spalte im Menu-Sheet auf ihren Rollennamen hin |fffd|berpr|fffd|ft.
'Ist kein Rollenname eingetragen, so wird in die n|fffd|chste Spalte gesprungen. Ist ein Rollenname vorhanden, so werden die
'beiden Worksheets QAdb und Menu nach in-scope gesetzten Eintr|fffd|gen durchsucht. Wird ein Eintrag gefunden, so wird zuerst
'gepr|fffd|ft, ob er schon bereits in der |fffd|bersicht vorhanden ist(Redundanzvermeidung). Ist dies nicht der Fall wird der T-Code
'in die Liste |fffd|bernommen und die Variable T_Ende wird um 1 erh|fffd|ht. iCurrentColumnMenu speichert die aktuell fokussiete Spalte
'im Menu-Sheet. Diese Variable l|fffd|uft nur bis 253, da die Spalten in beiden Sheets um 3 zueinander versetzt sind
For iCurrentColumnMenu = 12 To 253

'iCurrentColumnFormat wird ben|fffd|tigt, um die exakte Formatierung (Breite) der Spalten zu gew|fffd|hrleisten
iCurrentColumnFormat = iCurrentColumnMenu - 10

'User wird in der Statuszeile |fffd|ber den Verlauf der Bearbeitung informiert
Application.StatusBar = "Bitte gedulden Sie sich....... Bearbeite Spalte " & iCurrentColumnMenu

rollenname = Range(Worksheets(2).Cells(1, iCurrentColumnMenu), Worksheets(2).Cells(2, iCurrentColumnMenu))

    'Pr|fffd|fen, ob Rollenname leer ist. Wenn ja, braucht der Rest nicht mehr ausgef|fffd|hrt werden
    If rollenname(2, 1) <> "" Then
            
            'iCurrentColumnQAdb speichert die fokussierte Spalte im QAdb-Sheet
            iCurrentColumnQAdb = iCurrentColumnMenu - 3

            'rgSuchBereich speichert den zu durchsuchenden Bereich innerhalb der |fffd|bersicht (T_Anfang bis T_Ende der jeweiligen Spalte)
            Set rgSuchBereich = Range(Cells(T_Anfang, iCurrentColumnOverview), Cells(500, iCurrentColumnOverview))

            rgQAdb = Range(Worksheets(1).Cells(1, iCurrentColumnQAdb), Worksheets(1).Cells(62000, iCurrentColumnQAdb))
            rgMenu = Range(Worksheets(2).Cells(1, iCurrentColumnMenu), Worksheets(2).Cells(62000, iCurrentColumnMenu))
    
            'Rollenname und Business Area aus Menu-Sheet |fffd|bernehmen
            Cells(2, iCurrentColumnOverview) = rollenname(1, 1)
            Cells(3, iCurrentColumnOverview) = rollenname(2, 1)
    
            'In dieser Schleife werden sukzessive alle Zeilen beider Sheets nach Eintr|fffd|gen durchsucht
            For iZeile = 5 To 62000
                    
                    
                    'Wenn Eintrag in scope gesetzt ist und der T-Code noch nicht in der |fffd|bersicht ist
                    If rgQAdb(iZeile, 1) <> "" Then
                        Set hit1 = rgSuchBereich.Find(strQAdbT_Code(iZeile, 1), LookIn:=xlValues, lookat:=xlWhole)
                            If hit1 Is Nothing Then
                                    Cells(T_Ende, iCurrentColumnOverview) = strQAdbT_Code(iZeile, 1)
                                    T_Ende = T_Ende + 1
                            End If
                    End If
                    
                    
                    'Wenn Eintrag in scope gesetzt ist und der T-Code noch nicht in der |fffd|bersicht ist
                    If rgMenu(iZeile, 1) <> "" Then
                        Set hit2 = rgSuchBereich.Find(strMenuT_Code(iZeile, 1), LookIn:=xlValues, lookat:=xlWhole)
                            If hit2 Is Nothing Then
                                    Cells(T_Ende, iCurrentColumnOverview) = strMenuT_Code(iZeile, 1)
                                    T_Ende = T_Ende + 1
                            End If
                    End If
                    
            Next iZeile
            
        'Summe der T-Codes der Benutzerrolle in Zeile 5 eintragen
        Cells(5, iCurrentColumnOverview) = T_Ende - 6
        
        'T_Ende mu|fffd| neu initialisiert werden, um die |fffd|bersicht f|fffd|r jede Benutzerrolle in Zeile 6 beginnen zu lassen
        T_Ende = 6
        
        'rgSuchBereich sortieren
        rgSuchBereich.SortSpecial
        
        'Spaltengr|fffd||fffd|e optimieren
        Columns(iCurrentColumnOverview).EntireColumn.AutoFit
        
        'iCurrentColumnOverview um 1 erh|fffd|hen, damit die n|fffd|chste Spalte fokussiert wird
        iCurrentColumnOverview = iCurrentColumnOverview + 1
    Else
                
        'Spaltengr|fffd||fffd|e auf 13,57 zoll zur|fffd|cksetzen
        Columns(iCurrentColumnFormat).ColumnWidth = 13.57
        
        'iCurrentColumnOverview inkrementieren, da sonst nur die erste Spalte formatiert wird
        iCurrentColumnFormat = iCurrentColumnFormat + 1
    End If
    

Next iCurrentColumnMenu

'Statusbar wieder freigeben
Application.StatusBar = False

'Neuberechnungseigenschaft der Anwendung wieder aktivieren
Application.Calculation = berechn_modus
Application.ScreenUpdating = aktual_modus

'Eingabe|fffd|berpr|fffd|fung wieder aktivieren, um Update_Value Aufruf zu erm|fffd|glichen
Application.EnableEvents = True

Set rgSuchBereich = Nothing
Set rollenname = Nothing
Set rgQAdb = Nothing
Set rgMenu = Nothing
Set strQAdbT_Code = Nothing
Set strMenuT_Code = Nothing
Set hit1 = Nothing
Set hit2 = Nothing

Exit Sub

Overview_Error:
MsgBox "Es ist ein Laufzeitfehler aufgetreten." & Chr(13) & "Bitte schlie|fffd|en Sie die Berechtigungsliste und wiederholen Sie den Vorgang.", vbOKOnly + vbExclamation
    Application.EnableEvents = True
    Application.StatusBar = False
    
End Sub
Attribute VB_Name = "Tabelle1"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True

Private Sub Worksheet_Change(ByVal Target As Excel.Range)

On Error GoTo Change_Error

Dim bResult As String

'**********************************************************************************************
'Functionality added by Jens. Do not remove !
vaArr_QAdb = Worksheets(1).[G1:G65530]
vaArr_Menu = Worksheets(2).[K1:K65530]
'**********************************************************************************************


'Accelerate the evaluation by deactivation of the update/calculation-property
berechn_modus = Application.Calculation
aktual_modus = Application.ScreenUpdating
Application.Calculation = xlCalculationManual
Application.ScreenUpdating = False

'Input parameters for the function call of the update-function
Column = Target.Column
row = Target.row

'Wenn Eingabe in Role Name oder Business Area erfolgt
If Target.row < 3 Then

'Vermeidung von rekursiven Aufrufen von Worksheet_Change
Application.EnableEvents = False

    If Target = "" Then
        
    'Wenn Rollenname gel|fffd|scht wird, wird automatisch auch die Business Area gel|fffd|scht (in beiden Sheets)
    If Target.row = 2 Then
    
            'Sicherheitsabfrage, antwortet der User mit Yes, werden alle in scope gesetzten Daten gel|fffd|scht!
            bResult = MsgBox("Wollen Sie alle Daten dieser Benutzerrolle l|fffd|schen?" & Chr(13) & "  W|fffd|hlen Sie 'Ja', um alle Daten zu l|fffd|schen oder " & Chr(13) & "'Nein', um nur den Namen der Benutzerrolle zu l|fffd|schen.", vbYesNo + vbQuestion)
                
                'Wert 6 entspricht True???!!!
                If bResult = "6" Then
                    
                    With Worksheets(2).Range(Worksheets(2).Cells(5, Column + 3), Worksheets(2).Cells(62000, Column + 3))
                        .Value = ""
                    End With
                    
                    With Range(Cells(5, Column), Cells(62000, Column))
                        .Value = ""
                    End With
                    
                End If
                
            'L|fffd|sche Business Area
            Target.Offset(-1, 0) = ""
            'L|fffd|sche Business Area in QAdb
            Worksheets(2).Cells(Target.row - 1, Target.Column + 3) = ""
            
        End If
                             
                'Zelle ist leer, Breite auf Standard setzen
                Columns(Target.Column).ColumnWidth = 7.67
                
                'Worksheets(2).Cells(Target.row, Target.Column + 3) mu|fffd| formatiert werden, da bei Eingabe von x Punkt-Format |fffd|bernommen wird
                With Worksheets(2).Cells(Target.row, Target.Column + 3)
                    .Value = Target
                End With
                
                'Zelle in QAdb mu|fffd| geleert werden
                Worksheets(2).Columns(Target.Column + 3).ColumnWidth = 7.67
                
        'Wenn Business Area gel|fffd|scht wird, der Rollenname jedoch nicht, mu|fffd| AutoFit ausgef|fffd|hrt werden
        If Target.row = 1 Then
            If Target.Offset(1, 0) <> "" Then
                Columns(Target.Column).EntireColumn.AutoFit
                Worksheets(2).Columns(Target.Column + 3).AutoFit
            End If
        End If
        
    Else
            'Breite der Spalte automatisch anpassen
            Columns(Target.Column).EntireColumn.AutoFit
            
            '|fffd|bernahme der Daten in das erste Worksheet
            With Worksheets(2).Cells(Target.row, Target.Column + 3)
                .Value = Target
            End With
            
            Worksheets(2).Columns(Target.Column + 3).AutoFit
    End If
        
    'Event-Handling wieder zur|fffd|cksetzen f|fffd|r Update_Cells
    Application.EnableEvents = True
    
    'Sub kann verlassen werden, da nichts aktualisiert werden mu|fffd|
    Exit Sub
    
End If

'allow input in the T-Code-Range
If Target.Column < 8 Then
    Exit Sub
End If

'Define key-events
Application.OnKey "x", "Set_Dot"
Application.OnKey "y", "Show_Dialog"

'Input-Validation
If Target.Value = "x" Or Target.Value = "" Then
ElseIf Target.Value = "Di   " Or Target.Value = "Di Cr  " Or Target.Value = "Di  Ch " Or Target.Value = "Di   De" Or Target.Value = "Di Cr Ch " Or Target.Value = "Di Cr Ch De" Then
ElseIf Target.Value = " Cr  " Or Target.Value = " Cr Ch " Or Target.Value = " Cr Ch De" Then
ElseIf Target.Value = "  Ch " Or Target.Value = "  Ch De" Then
ElseIf Target.Value = "   De" Then
Else: Target.Value = ""
End If

If Cells(Target.row, 7) = "" Then
    Exit Sub
End If

'Update-Function call
Update_Values_QAdb Column, row

'Focus is set to the initial cell
Target.Activate

'Clean up
Set Target = Nothing
    
'Re-set the update/calculation parameter
Application.Calculation = berechn_modus
Application.ScreenUpdating = aktual_modus

Exit Sub
Change_Error:
    MsgBox "Es ist ein Laufzeitfehler aufgetreten." & Chr(13) & "Bitte schlie|fffd|en Sie die Berechtigungsliste und wiederholen Sie den Vorgang.", vbOKOnly + vbExclamation
    Application.EnableEvents = True
    Exit Sub
    
End Sub

Private Sub Worksheet_Deactivate()
End Sub

Sub Update_Values_QAdb(ByVal Column As Long, ByVal row As Long)

Dim T_Code As String
Dim zelle, rgTargetCell As Range
Dim lLastRow As Long
Dim i As Long

Column_Menu = Column + 3

'Get the affected T_Code and calculate the Column-Difference between the T_Code-Column and the Active Column
T_Code = Range("G" & row).Value


On Error Resume Next

'to avoid multiple calls from Worksheet_Change
Application.EnableEvents = False

'rgTargetCell is the Cell which is hit in the Sheet
Set rgTargetCell = Cells(row, Column)

For i = 1 To 35000
    If vaArr_QAdb(i, 1) = T_Code Then
        Cells(i, Column) = rgTargetCell
    End If
Next
    
Worksheets(2).Activate

With Worksheets(2)
    For i = 1 To 61719
        If vaArr_Menu(i, 1) = T_Code Then
            .Cells(i, Column_Menu) = rgTargetCell
        End If
    Next
End With
    
Worksheets(1).Activate

Set rgTargetCell = Nothing

'Enable Event-Handling again
Application.EnableEvents = True

End Sub
Attribute VB_Name = "Tabelle2"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Private Sub Worksheet_Change(ByVal Target As Excel.Range)

On Error Resume Next

Dim bResult As String

'Accelerate the evaluation by deactivation of the update/calculation-property
berechn_modus = Application.Calculation
aktual_modus = Application.ScreenUpdating
Application.Calculation = xlCalculationManual
Application.ScreenUpdating = False

'Input parameters for the function call of the update-function
Column = Target.Column
row = Target.row

'Wenn Eingabe in Role Name oder Business Area erfolgt
If Target.row < 3 Then

'Vermeidung von rekursiven Aufrufen von Worksheet_Change
Application.EnableEvents = False

    If Target = "" Then
        
    'Wenn Rollenname gel|fffd|scht wird, wird automatisch auch die Business Area gel|fffd|scht (in beiden Sheets)
    If Target.row = 2 Then
    
            'Sicherheitsabfrage, antwortet der User mit Yes, werden alle in scope gesetzten Daten gel|fffd|scht!
            bResult = MsgBox("Wollen Sie alle Daten dieser Benutzerrolle l|fffd|schen?" & Chr(13) & "  W|fffd|hlen Sie 'Ja', um alle Daten zu l|fffd|schen oder " & Chr(13) & "'Nein', um nur den Namen der Benutzerrolle zu l|fffd|schen.", vbYesNo + vbQuestion)
                
                'Wert 6 entspricht True???!!!
                If bResult = "6" Then
                    
                    With Worksheets(1).Range(Worksheets(1).Cells(5, Column - 3), Worksheets(1).Cells(62000, Column - 3))
                        .Value = ""
                    End With
                    
                    With Range(Cells(5, Column), Cells(62000, Column))
                        .Value = ""
                    End With
                    
                End If
                
            'L|fffd|sche Business Area
            Target.Offset(-1, 0) = ""
            'L|fffd|sche Business Area in QAdb
            Worksheets(1).Cells(Target.row - 1, Target.Column - 3) = ""
            
        End If
                             
                'Zelle ist leer, Breite auf Standard setzen
                Columns(Target.Column).ColumnWidth = 7.67
                
                'Worksheets(1).Cells(Target.row, Target.Column - 3) mu|fffd| formatiert werden, da bei Eingabe von x Punkt-Format |fffd|bernommen wird
                With Worksheets(1).Cells(Target.row, Target.Column - 3)
                    .Value = Target
                End With
                
                'Zelle in QAdb mu|fffd| geleert werden
                Worksheets(1).Columns(Target.Column - 3).ColumnWidth = 7.67
                
        'Wenn Business Area gel|fffd|scht wird, der Rollenname jedoch nicht, mu|fffd| AutoFit ausgef|fffd|hrt werden
        If Target.row = 1 Then
            If Target.Offset(1, 0) <> "" Then
                Columns(Target.Column).EntireColumn.AutoFit
                Worksheets(1).Columns(Target.Column - 3).AutoFit
            End If
        End If
        
    Else
            'Breite der Spalte automatisch anpassen
            Columns(Target.Column).EntireColumn.AutoFit
            
            '|fffd|bernahme der Daten in das erste Worksheet
            With Worksheets(1).Cells(Target.row, Target.Column - 3)
                .Value = Target
            End With
            
            Worksheets(1).Columns(Target.Column - 3).AutoFit
    End If
        
    'Event-Handling wieder zur|fffd|cksetzen f|fffd|r Update_Cells
    Application.EnableEvents = True
    
    'Sub kann verlassen werden, da nichts aktualisiert werden mu|fffd|
    Exit Sub
    
End If

'allow input in the T-Code-Range
If Target.Column = 11 Then
    Exit Sub
End If

'Define key-events
Application.OnKey "x", "Set_Dot"
Application.OnKey "y", "Show_Dialog"

'Input-Validation
If Target.Value = "x" Or Target.Value = "" Then
ElseIf Target.Value = "Di   " Or Target.Value = "Di Cr  " Or Target.Value = "Di  Ch " Or Target.Value = "Di   De" Or Target.Value = "Di Cr Ch " Or Target.Value = "Di Cr Ch De" Then
ElseIf Target.Value = " Cr  " Or Target.Value = " Cr Ch " Or Target.Value = " Cr Ch De" Then
ElseIf Target.Value = "  Ch " Or Target.Value = "  Ch De" Then
ElseIf Target.Value = "   De" Then
Else: Target.Value = ""
End If

If Cells(Target.row, 11) = "" Then
    Exit Sub
End If

'Update-Function call
Update_Values_Menue Column, row

'Focus is set to the initial cell
Target.Activate

Application.EnableEvents = True
'Re-set the update/calculation parameter
Application.Calculation = berechn_modus
Application.ScreenUpdating = aktual_modus

Exit Sub

Change_Error:
    MsgBox "Es ist ein Laufzeitfehler aufgetreten." & Chr(13) & "Bitte schlie|fffd|en Sie die Berechtigungsliste und wiederholen Sie den Vorgang.", vbOKOnly + vbExclamation
    Application.EnableEvents = True
    Exit Sub
    
End Sub

Private Sub Worksheet_Deactivate()
End Sub

Sub Update_Values_Menue(ByVal Column As Long, ByVal row As Long)

Dim T_Code As String
Dim zelle, rgTargetCell As Range
Dim lLastRow As Long

'row = 6
'Column = 12
'Get the affected T_Code and calculate the Column-Difference between the T_Code-Column and the Active Column
T_Code = Range("K" & row).Value

Column_QAdb = Column - 3

'to avoid multiple calls from Worksheet_Change
Application.EnableEvents = False

'rgTargetCell is the Cell which is hit in the Sheet
Set rgTargetCell = Cells(row, Column)

For i = 1 To 61719
    If vaArr_Menu(i, 1) = T_Code Then
        Cells(i, Column) = rgTargetCell
    End If
Next
    
'Activate QAdb-Worksheet, because Cells always refer to active sheet
Worksheets(1).Activate

With Worksheets(1)
    For i = 1 To 50000
        If vaArr_QAdb(i, 1) = T_Code Then
            .Cells(i, Column_QAdb) = rgTargetCell
        End If
    Next
End With

Worksheets(2).Activate

Set rgTargetCell = Nothing

'Enable Event-Handling again
Application.EnableEvents = True

End Sub

Sub aaa()
Application.EnableEvents = True

End Sub
Attribute VB_Name = "ThisWorkbook"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True

Attribute VB_Name = "UserForm1"
Attribute VB_Base = "0{B00B3E6A-4B14-4C5F-9537-4C4983B80920}{470794A4-A4C1-44E3-8DA0-B03E3CA739E8}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False



Public display As String
Public create As String
Public change As String
Public delete As String


Private Sub Cancel_Click()
On Error GoTo Errorhandling
    UserForm1.Hide
Errorhandling:
If Err.Number = 1004 Then
Exit Sub
Else: Resume Next
End If
End Sub


Private Sub OK_Click()

On Error GoTo Errorhandling

If CheckBox3.Value = True Then
    display = "Di"
Else: display = ""
End If

If CheckBox1.Value = True Then
    create = "Cr"
Else: create = ""
End If

If CheckBox2.Value = True Then
    change = "Ch"
Else: change = ""
End If

If CheckBox4.Value = True Then
    delete = "De"
Else: delete = ""
End If
    UserForm1.Hide
    ActiveCell.Font.Name = "Arial"
    ActiveCell.HorizontalAlignment = xlCenter
    ActiveCell = display & " " & create & " " & change & " " & delete
Exit Sub
        
Errorhandling:
MsgBox "Can|fffd|t insert values." & Chr(13) & "Please reload Authorization List and try it again.", vbCritical + vbOKOnly
End Sub
Attribute VB_Name = "UserForm2"
Attribute VB_Base = "0{AE1BB2F3-2374-4C33-AC5D-F1794FC69060}{231302AD-66DE-48D7-8275-E5FD6C7C2E71}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False


Public result As Boolean

Private Sub CommandButton1_Click()
    UserForm2.Hide
    result = True
End Sub
Attribute VB_Name = "View_BL Module"





























































































'2/9--Diane--redid code strings for translation lookup

' View_BL_Config Macro
Sub View_BL_Config()
Attribute View_BL_Config.VB_Description = "Macro recorded 9/12/97 by SAP America"
Attribute View_BL_Config.VB_ProcData.VB_Invoke_Func = " \n0"
    Dim parm1 As String
    Dim parm2 As String
    
    parm1 = Worksheets("Translation").Cells(185, gIntlOffset).Value
    parm2 = Worksheets("Translation").Cells(186, gIntlOffset).Value
    
    View_BL parm1, parm2, 18, 19, "Config"
    
End Sub

' View_BL_Test Macro
Sub View_BL_Test()
Attribute View_BL_Test.VB_Description = "Macro recorded 9/12/97 by SAP America"
Attribute View_BL_Test.VB_ProcData.VB_Invoke_Func = " \n0"
    Dim parm1 As String
    Dim parm2 As String
    
    parm1 = Worksheets("Translation").Cells(187, gIntlOffset).Value
    parm2 = Worksheets("Translation").Cells(188, gIntlOffset).Value

    View_BL parm1, parm2, 20, 21, "Test"
    
End Sub

'View_BL_Confirm Macro--calls View_BL
Sub View_BL_Confirm()
Attribute View_BL_Confirm.VB_Description = "Macro recorded 9/12/97 by SAP America"
Attribute View_BL_Confirm.VB_ProcData.VB_Invoke_Func = " \n0"
    Dim parm1 As String
    Dim parm2 As String
    
    parm1 = Worksheets("Translation").Cells(189, gIntlOffset).Value
    parm2 = Worksheets("Translation").Cells(190, gIntlOffset).Value
    
    View_BL parm1, parm2, 22, 23, "Confirm"
    
End Sub

' View_BL--creates a new workbook with the baseline data consolidated and sorted as either Config, Test or Confirm data
Sub View_BL(strBLType As String, strBLFullType As String, StartCol As Long, EndCol As Long, ViewType As String)
Attribute View_BL.VB_ProcData.VB_Invoke_Func = " \n14"

    Dim wb1 As Workbook 'Original workbook
    Dim wb2 As Workbook 'Newly created workbook
    Dim strFilterAddress As String 'Address returned by filtering
    Dim rgUsed As Range 'Used range on the new worksheet
    Dim rgKeepRange As Range 'Range of cells to keep on the new worksheet
    Dim rgArea As Range 'Used to loop through areas of rgUsed and rgKeepRange
    Dim nConstVisible As Long 'Constant used for xlcelltypevisible in different versions of Excel
    Dim sStatusBarText As String
    
    On Error GoTo Exit_View_BL:
    
    'Turn off screen updating and give some user feedback
    Application.ScreenUpdating = False
    Application.EnableEvents = False
    
    sStatusBarText = Worksheets("Translation").Cells(191, gIntlOffset).Value & " "
    sStatusBarText = sStatusBarText & strBLFullType
    sStatusBarText = sStatusBarText & " " & Worksheets("Translation").Cells(192, gIntlOffset).Value & "..."
    Application.StatusBar = sStatusBarText
    Set wb1 = ActiveWorkbook
    
    'Copy the baseline worksheet to a new workbook
    Sheets(gsBaselineName).Copy
    'Rename the new worksheet properly
    ActiveSheet.Name = gsBaselineName & " " & strBLType
    Set wb2 = ActiveWorkbook
    
    ' Put new title in B1
    Cells(1, 2).Value = UCase(gsBaselineName & " " & strBLFullType & " " & wb1.Worksheets("Translation").Cells(193, gIntlOffset).Value)

    'Clear the current outline...if there is none, no error occurs--if there's an outline, sorts won't occur properly
    ActiveSheet.UsedRange.ClearOutline
    ActiveSheet.UsedRange.EntireRow.Hidden = False

    'Give some user feedback
    Select Case ViewType
        Case "Config"
            sStatusBarText = wb1.Worksheets("Translation").Cells(194, gIntlOffset).Value & "..."
        Case "Confirm"
            sStatusBarText = wb1.Worksheets("Translation").Cells(195, gIntlOffset).Value & "..."
        Case "Test"
            sStatusBarText = wb1.Worksheets("Translation").Cells(298, gIntlOffset).Value & "..."
    End Select
    
    Application.StatusBar = sStatusBarText
    
    'Hide the rows we want to keep
    On Error Resume Next
    'We'll get an error if there's no cells with text in them...
    Set rgKeepRange = ActiveSheet.Range(Cells(4, StartCol), Cells(ActiveSheet.UsedRange.Rows.Count, EndCol)).SpecialCells(xlTextValues)
    On Error GoTo Exit_View_BL:
    
    If Not (rgKeepRange Is Nothing) Then
        For Each rgArea In rgKeepRange.Areas
            rgArea.EntireRow.Hidden = True
        Next
    End If
    
    'Watch out for different constants indifferent XL versions...
    If InStr(Application.Version, "8") > 0 Then
        nConstVisible = xlCellTypeVisible
    Else
        nConstVisible = xlVisible
    End If
    
    'Delete the ones we don't want anymore
    Set rgUsed = Range(Cells(4, 1), Cells(ActiveSheet.UsedRange.Rows.Count, 1)).SpecialCells(nConstVisible)
    For Each rgArea In rgUsed.Areas
        If rgArea.row > 2 Then
            rgArea.EntireRow.delete
        End If
    Next
    
    'Reshow the ones we kept
    If Not (rgKeepRange Is Nothing) Then
        rgKeepRange.EntireRow.Hidden = False
    End If
    
    'Perform the sort
    Range(Cells(4, 1), Cells(ActiveSheet.UsedRange.Rows.Count, 23)).Select
    Selection.sort key1:=Cells(4, StartCol), Order1:=xlAscending, Key2:=Cells(4, EndCol), Order2:=xlAscending, Header:=xlGuess, OrderCustom:=2, _
        MatchCase:=False, Orientation:=xlTopToBottom
    
    'Get rid of the old row 3...and hide the new one so all the macros based on row 4 will work while not displaying a blank row
    Rows("3:3").Select
    Selection.delete shift:=xlUp
    Selection.Insert shift:=xlDown
    Rows("3:3").RowHeight = 0

Exit_View_BL:
'Clean up
    'Clean up display for easier navigation
    GoHome wb1.Name, gsBaselineName
    GoHome wb2.Name, gsBaselineName & " " & strBLType

    Set wb1 = Nothing
    Set wb2 = Nothing
    Set rgKeepRange = Nothing
    Set rgUsed = Nothing
    Set rgArea = Nothing
    
    Application.StatusBar = False
    Application.ScreenUpdating = True
    Application.EnableEvents = True
        
End Sub
Attribute VB_Name = "build_tree"
Sub build_tree()

'Kein Exception-Handling
On Error Resume Next

'******************************************************************************************************************************************************************************************************************
'Definitionen
'******************************************************************************************************************************************************************************************************************

Dim rgHit As Range                                                          'Zelle, f|fffd|r die die vaArr_Object_ID aus beiden Tabellen |fffd|bereinstimmt
Dim lSortOrderCounter As Long                                               'Schleifenz|fffd|hler, der die gerade bearbeitete Zeile in den Quelldateien angibt
Dim strStart As String, strEnd As String                                    'Anfangs- und Endadresse des zu durchsuchenden Bereiches
Dim lHitRow As Long                                                         'Zeilennummer der Zelle, f|fffd|r die die vaArr_Object_ID aus beiden Tabellen |fffd|bereinstimmt
Dim wsWorksheet_Texts_1 As Worksheet, wsWorksheet_Texts_2 As Worksheet      'Worksheets aus den texts-Dateinen, in denen mit Hilfe des Range-Objektes und der Find-Funktion nach der der Objekt-ID gesucht wird
Dim lMenuItemsWithLevelGreater11 As Long                                    'Variable, die die Men|fffd|eintr|fffd|ge mit Men|fffd|level > 11 erfa|fffd|t

'Timer start
starttime = Timer

'Accelerates the search; sheet is not updated and recalculated until the building-process is accomplished
berechn_modus = Application.Calculation
aktual_modus = Application.ScreenUpdating
Application.Calculation = xlCalculationManual
Application.ScreenUpdating = False

'to avoid multiple calls from Worksheet_Change
Application.EnableEvents = False

'Variant-Datenfelder f|fffd|r effizienten Men|fffd|aufbau (schnelle Berechnung) generieren
vaArr_Menu_Level = Workbooks("full_menu1.xls").Worksheets("full_menu1").[C1:C65510]                 'Spalte mit Hierachietiefe
vaArr_Report_Type = Workbooks("full_menu1.xls").Worksheets("full_menu1").[D1:D65510]                'Spalte mit Reporttype, "TR" = Transaktionscode, entspricht einem Blatt
vaArr_Report_Name = Workbooks("full_menu1.xls").Worksheets("full_menu1").[E1:E65510]                'Spalte mit Transaktionscodes
vaArr_Object_ID = Workbooks("full_menu1.xls").Worksheets("full_menu1").[B1:B65510]                  'Spalte mit Objekt-ID aus "full_menu_1"
vaArr_Texts = Workbooks("full_menu_texts1.xls").Worksheets("full_menu_texts1").[B1:B65510]          'Spalte mit den Men|fffd|Textsn
Set wsWorksheet_Texts_1 = Workbooks("full_menu_texts1.xls").Worksheets("full_menu_texts1")

'Variant-Datenfelder f|fffd|r effizienten Men|fffd|aufbau (schnelle Berechnung) generieren f|fffd|r full_menu_2 und full_menu_texts2
vaArr_Menu_Level_2 = Workbooks("full_menu2.xls").Worksheets("full_menu2").[C1:C65510]                 'Spalte mit Hierachietiefe
vaArr_Report_Type_2 = Workbooks("full_menu2.xls").Worksheets("full_menu2").[D1:D65510]                'Spalte mit Reporttype, "TR" = Transaktionscode, entspricht einem Blatt
vaArr_Report_Name_2 = Workbooks("full_menu2.xls").Worksheets("full_menu2").[E1:E65510]                'Spalte mit Transaktionscodes
vaArr_Object_ID_2 = Workbooks("full_menu2.xls").Worksheets("full_menu2").[B1:B65510]                  'Spalte mit Objekt-ID aus "full_menu_2"
vaArr_Texts_2 = Workbooks("full_menu_texts2.xls").Worksheets("full_menu_texts2").[B1:B65510]          'Spalte mit den Men|fffd|Texts_2n
Set wsWorksheet_Texts_2 = Workbooks("full_menu_texts2.xls").Worksheets("full_menu_texts2")

'**********************************************************************************************************************************************************************************************
'Ab hier Generierung des Men|fffd|s
'**********************************************************************************************************************************************************************************************

Workbooks("d_al.xlt").Worksheets(2).Activate
lMenuItemsWithLevelGreater11 = 0

For lSortOrderCounter = 1 To 80000
'lMenuItemsWithLevelGreater11 = 62999
    
    If lSortOrderCounter < 64827 Then
    
            'Bis zur Kirchg|fffd|ssner(Sort-Order) 64900 (Objekt-ID 66000) gelten diese Start/End-Werte. Ab Objekt-ID 66000 m|fffd|ssen diese neu indiziert werden (siehge unten)
            'Da Sort_Order und aktuell bearbeitete Zeile in den Quelldateien nicht |fffd|bereinstimmt, mu|fffd| bis Objekt-ID 66000 ein Bereich von 500 Zeilen vor und
            '100 Zeilen nach der aktuellen Zeile nach der gesuchten Objekt-ID durchsucht werden. Ist die erste Zeile des Suchbereichs kleiner 1 lSortOrderCounter - 500 < 0,
            'beginnt die Suche ab lSortOrderCounter
            If lSortOrderCounter - 1800 < 0 Then
                  strStart = "A" & lSortOrderCounter
                  strEnd = "A" & (lSortOrderCounter + 100)
            Else
                  strStart = "A" & (lSortOrderCounter - 1800)
                  strEnd = "A" & (lSortOrderCounter + 100)
            End If
              
                'Ermittle per Find-Funktion den zu der aus der Tabelle "full_menu_1" geh|fffd|renden Objekt-ID den entsprechenden Text aus "full_menu_texts_1"
                Set rgHit = wsWorksheet_Texts_1.Range(strStart, strEnd).Find(vaArr_Object_ID(lSortOrderCounter, 1), , , lookat:=xlWhole)
               
            'Wenn der gefundene Eintrag tiefer als Ebene 11 liegt, wird das in lMenuItemsWithLevelGreater11 erfa|fffd|t
            'und sp|fffd|ter bei der Men|fffd|plazierung nicht ber|fffd|cksichtigt
            If vaArr_Menu_Level(lSortOrderCounter, 1) > 11 Or rgHit = 0 Then
                 lMenuItemsWithLevelGreater11 = lMenuItemsWithLevelGreater11 + 1
                 GoTo weiter
            End If
              
                'Zieladresse entspricht der Reihe der gefundenen Zelle
                lHitRow = rgHit.row
               
            'Plaziere Text entsprechend der Sortierreihenfolge und Hierachieebene (abz|fffd|glich einer Ebene, da 1.Ebene "SAP R/3" entf|fffd|llt) in "Sort"
            'Da das Worksheet in der Authorization List 4 |fffd|berschriftszeilen enth|fffd|lt, mu|fffd| die Plazierungsvariable lSortOrderCounter um 4 erh|fffd|ht werden
                Cells(lSortOrderCounter + 4 - lMenuItemsWithLevelGreater11, vaArr_Menu_Level(lSortOrderCounter, 1) - 1) = vaArr_Texts(lHitRow, 1) 'i+4, da in "Roles Design - SAP Menue" 4 |fffd|berschriftszeilen
        
            'Schreibe Transaktionscode in Spalte 12
                If vaArr_Report_Type(lSortOrderCounter, 1) = "TR" Then
                    Cells(lSortOrderCounter + 4 - lMenuItemsWithLevelGreater11, 11) = vaArr_Report_Name(lSortOrderCounter, 1)
                End If
                     
weiter:
    Else
    
            Const constRowDifference = 64827
             
            'lSortOrderCounter mu|fffd| um die Zeilendifferenz "constRowDifference" bereinigt werden, da die Dateien full_menu2 und full_menu_texts2 wieder ab Zeile 1 beginnen.
            lSortOrderCounter_Adjusted = lSortOrderCounter + 1 - constRowDifference
            
            'Bis zur Object-ID 66000 gelten diese Start/End-Werte. Ab Objekt-ID 66000 m|fffd|ssen diese neu indiziert werden
            'Da die Zeilennummer in den Quellworksheets nicht mit der Sort_Order |fffd|bereinstimmt, mu|fffd| in den Textdateien
            'ein Bereich von 600 Zeilen vor und 20 Zeilen hinter der aktuellen Sort_Order durchsucht werden. Ist die Anfangs-
            'adresse kleiner A1 (lSortOrderCounter_Adjusted-600) < 0, beginnt die Suche ab Zelle A1
            If lSortOrderCounter_Adjusted - 1000 < 0 Then
                strStart = "A" & 1
                strEnd = "A" & (lSortOrderCounter_Adjusted + 100)
            Else
                strStart = "A" & (lSortOrderCounter_Adjusted - 1000)
                strEnd = "A" & (lSortOrderCounter_Adjusted + 100)
            End If
                
                'Hier wird gesucht
                'Ermittle per Find-Funktion den zu der aus der Tabelle "full_menu_2" geh|fffd|renden Objekt-ID den entsprechenden Text aus "full_menu_texts_2"
                Set rgHit = wsWorksheet_Texts_2.Range(strStart, strEnd).Find(vaArr_Object_ID_2(lSortOrderCounter_Adjusted, 1), , , lookat:=xlWhole)
              
            'Wenn der gefundene Eintrag tiefer als Ebene 11 liegt, wird das in lMenuItemsWithLevelGreater11 erfa|fffd|t
            'und sp|fffd|ter bei der Men|fffd|plazierung nicht ber|fffd|cksichtigt
            If vaArr_Menu_Level_2(lSortOrderCounter_Adjusted, 1) > 11 Or rgHit = 0 Then
                lMenuItemsWithLevelGreater11 = lMenuItemsWithLevelGreater11 + 1
                GoTo weiter_2
            End If
             
                'Zieladresse entspricht der Reihe der gefundenen Zelle
                lHitRow = rgHit.row
              
            'Plaziere Text entsprechend der Sortierreihenfolge und Hierachieebene (abz|fffd|glich einer Ebene, da 1.Ebene "SAP R/3" entf|fffd|llt) in "Sort"
            'Da das Worksheet in der Authorization List 4 |fffd|berschriftszeilen enth|fffd|lt, mu|fffd| die Plazierungsvariable lSortOrderCounter um 4 erh|fffd|ht werden
                'Cells(lSortOrderCounter + 4 - lMenuItemsWithLevelGreater11, vaArr_Menu_Level_2(lSortOrderCounter_Adjusted, 1) - 1) = vaArr_Texts_2(lHitRow, 1) 'i+4, da in "Roles Design - SAP Menue" 4 |fffd|berschriftszeilen
                Cells(lSortOrderCounter + 4 - lMenuItemsWithLevelGreater11, vaArr_Menu_Level_2(lSortOrderCounter_Adjusted, 1) - 1) = vaArr_Texts_2(lHitRow, 1) 'i+4, da in "Roles Design - SAP Menue" 4 |fffd|berschriftszeilen
            'Schreibe Transaktionscode in Spalte 12
                If vaArr_Report_Type_2(lSortOrderCounter_Adjusted, 1) = "TR" Then
                    'Cells(lSortOrderCounter + 4 - lMenuItemsWithLevelGreater11, 11) = vaArr_Report_Name_2(b - constRowDifference, 1)
                    Cells(lSortOrderCounter + 4 - lMenuItemsWithLevelGreater11, 11) = vaArr_Report_Name_2(lSortOrderCounter_Adjusted, 1)
                End If
weiter_2:
    End If
   
Next lSortOrderCounter

'Aufr|fffd|umarbeiten
Set vaArr_Texts = Nothing
Set vaArr_Object_ID_text = Nothing
Set wsWorksheet_Texts_1 = Nothing
Set vaArr_Object_ID_2_text = Nothing
Set wsWorksheet_Texts_2 = Nothing
Set vaArr_Menu_Level = Nothing
Set vaArr_Report_Type = Nothing
Set vaArr_Report_Name = Nothing
Set vaArr_Object_ID = Nothing
Set vaArr_Menu_Level_2 = Nothing
Set vaArr_Report_Type_2 = Nothing
Set vaArr_Report_Name_2 = Nothing
Set vaArr_Object_ID_2 = Nothing
Set vaArr_Texts_2 = Nothing

'Enable Event-Handling again
Application.EnableEvents = True

'Calculate and Update Sheet
Application.Calculation = berechn_modus
Application.ScreenUpdating = aktual_modus

'Timer end
MsgBox (Timer - starttime) & "Sekunden"

End Sub

Sub delete_Menu()

'Accelerates the search; sheet is not updated and recalculated until the building-process is accomplished
berechn_modus = Application.Calculation
aktual_modus = Application.ScreenUpdating
Application.Calculation = xlCalculationManual
Application.ScreenUpdating = False

Application.EnableEvents = False
Set menue = Worksheets(2).[A5:M65536]
With menue
    .Value = ""
End With
Application.EnableEvents = True

'Calculate and Update Sheet
Application.Calculation = berechn_modus
Application.ScreenUpdating = aktual_modus

End Sub
Attribute VB_Name = "make_outline"

Sub make_outline()

'Keine Fehlerbehandlung
On Error Resume Next

Dim iOutlineLevel As Integer            'iOutlineLevel enh|fffd|lt die aktuelle Hierachietiefe des Outline-Prozesses
Dim lBeginOutlineRow As Long            'Reihe, ab der Outline erstellt werden soll (Startzeile)
Dim lEndOutlineRow As Long              'Reihe, bis zu der Outline erstellt werden soll (Endzeile)
Dim lActualRow As Long                  'Aktuelle Position des Suchzeigers innerhalb der Spalte/Ebene
Dim rgActualOutlineColumn As Range      'Spalte, f|fffd|r die gerade Outline erstellt wird
Dim lStartEndDifference As Long         'Z|fffd|hler, der ausgehend von lActualRow ben|fffd|tigt wird, um Start- und Endzeile zu erhalten
Dim iBreakDetectionLevel As Integer     'Z|fffd|hler, der ben|fffd|tigt wird, um einen bBreak in der Hierachieebene festzustellen
Dim bBreak As Boolean                   'Wahrheitswert, der w|fffd|hrend der Suche nach Start- und Endzeile einen Bruch in der Hierachie signalisiert

'Timer start
starttime = Timer

'Accelerates the search; sheet is not updated and recalculated until the building-process is accomplished
berechn_modus = Application.Calculation
aktual_modus = Application.ScreenUpdating
Application.Calculation = xlCalculationManual
Application.ScreenUpdating = False

'Anzahl der zu gruppierenden Spalten/Ebenen
iOutlineLevel = 1
'Es k|fffd|nnen h|fffd|chstens 8 Outline Ebenen generiert werden
Do While iOutlineLevel < 9

'Spalte innerhalb vom Men|fffd|-Sheet festlegen, f|fffd|r die Outline erstellt wird
    Set rgActualOutlineColumn = ThisWorkbook.Worksheets(2).Range(Cells(1, iOutlineLevel), Cells(65530, iOutlineLevel))
    
    'Aktuelle Zeilenposition innerhalb der Spalte festlegen
    lActualRow = 4
    
    'lActualRow enth|fffd|lt die aktuelle Zeilenposition. 59253 ist letzte zu gruppierende Spalte
    Do While lActualRow < 59253
        
        'Suche Anfangszeile f|fffd|r Outlineerstellung
        lStartEndDifference = 0
        
            Do
                'Erh|fffd|he Zellz|fffd|hler
                lStartEndDifference = lStartEndDifference + 1
                
                '|fffd|berpr|fffd|fe, ob Bruch in der Hierachie vorliegt (nur m|fffd|glich, ab iOutlineLevel > 1!)
                If iOutlineLevel > 1 Then
                
                    'F|fffd|r alle Zellen links unterhalb der aktuellen Zelle wird der Inhalt |fffd|berpr|fffd|ft.
                    'Ist die Zelle nicht leer liegt ein Bruch in der Hierachie vor. Die Startzeile
                    'entspricht dann der aktuellen Zeile und die Schleife mu|fffd| abgebrochen werden.
                    For iBreakDetectionLevel = 1 To iOutlineLevel - 1
                    bBreak = False
                        If Cells(lActualRow + lStartEndDifference + 1, iOutlineLevel - iBreakDetectionLevel) <> "" Then
                            bBreak = True
                            Exit For
                        End If
                    Next iBreakDetectionLevel
                    
                End If
                
            'Abbruchbedingung : Wenn Aktuelle Zelle nicht leer ist und n|fffd|chste Zelle nicht leer ist und kein Bruch vorliegt
            '           oder  : Wenn Aktuelle Zelle gr|fffd||fffd|er als Anzahl der Zellen pro Spalte
            Loop Until (rgActualOutlineColumn(lActualRow + lStartEndDifference, 1) <> "" And rgActualOutlineColumn(lActualRow + lStartEndDifference + 1, 1) = "" And bBreak = False) Or lStartEndDifference + lActualRow > 59252
        
            lBeginOutlineRow = rgActualOutlineColumn(lActualRow + lStartEndDifference + 1, 1).row 'Anfang des zu gruppierenden Bereiches ermitteln
        
        
        'Erh|fffd|hung der aktuellen Reihe, um Doppelgruppierung zu vermeiden
        lActualRow = lActualRow + lStartEndDifference
    
        'Suche Endzeile f|fffd|r Outlineerstellung
        'lStartEndDifference zur|fffd|cksetzen, damit ab lActualRow gesucht wird
        lStartEndDifference = 0
            
            Do
                
                'Erh|fffd|he Zellz|fffd|hler
                lStartEndDifference = lStartEndDifference + 1
                
                '|fffd|berpr|fffd|fe, ob Bruch in der Hierachie vorliegt (nur m|fffd|glich, ab iOutlineLevel > 1!)
                If iOutlineLevel > 1 Then
                
                    'F|fffd|r alle Zellen links unterhalb der aktuellen Zelle wird der Inhalt |fffd|berpr|fffd|ft.
                    'Ist die Zelle nicht leer liegt ein Bruch in der Hierachie vor. Die Startzeile
                    'entspricht dann der aktuellen Zeile und die Schleife mu|fffd| abgebrochen werden.
                    For iBreakDetectionLevel = 1 To iOutlineLevel - 1
                    bBreak = False
                        If Cells(lActualRow + lStartEndDifference + 1, iOutlineLevel - iBreakDetectionLevel) <> "" Then
                            bBreak = True
                            Exit For
                        End If
                    Next iBreakDetectionLevel
                End If
                
            'Abbruchbedingung : Wenn Aktuelle Zelle nicht leer ist und n|fffd|chste Zelle nicht leer ist und kein Bruch vorliegt
            '           oder  : Wenn Aktuelle Zelle gr|fffd||fffd|er als Anzahl der Zellen pro Spalte
            Loop Until (rgActualOutlineColumn(lActualRow + lStartEndDifference, 1) = "" And rgActualOutlineColumn(lActualRow + lStartEndDifference + 1, 1) <> "") Or lStartEndDifference + lActualRow > 59252 Or bBreak = True
        
        'Ende des zu gruppierenden Bereiches ermitteln
        lEndOutlineRow = rgActualOutlineColumn(lActualRow + lStartEndDifference, 1).row
        
        'Z|fffd|hler erh|fffd|hen, um doppeltes Gruppieren zu vermeiden
        lActualRow = lEndOutlineRow
            
        'Markiere lActualRow und Gruppiere
        Range(rgActualOutlineColumn(lBeginOutlineRow, 1), rgActualOutlineColumn(lEndOutlineRow, 1)).Rows.group
        'Details ausblenden
        Range(rgActualOutlineColumn(lBeginOutlineRow, 1), rgActualOutlineColumn(lEndOutlineRow, 1)).Rows.ShowDetail = False
             
    'iActualRow Loop
    Loop
        
    'Outline-Level inkrementieren, um Endlosschleife zu vermeiden
    iOutlineLevel = iOutlineLevel + 1

'iOutlineLevel Loop
Loop

Set rgActualOutlineColumn = Nothing


'Calculate and Update Sheet
Application.Calculation = berechn_modus
Application.ScreenUpdating = aktual_modus

'end time
MsgBox (Timer - starttime) & "Sekunden"

End Sub

' InQuest injected base64 decoded content
' v($z+l

INQUEST-PP=macro
