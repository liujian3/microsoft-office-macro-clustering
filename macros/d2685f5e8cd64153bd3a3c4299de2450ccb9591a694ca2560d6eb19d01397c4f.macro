Attribute VB_Name = "DieseArbeitsmappe"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

'--------------------------------------------------
Private Sub Workbook_BeforeClose(Cancel As Boolean)
'--------------------------------------------------
  Application.CommandBars("row").FindControl(ID:=883).OnAction = ""
  Application.CommandBars("row").FindControl(ID:=884).OnAction = ""
End Sub

'--------------------------
Private Sub Workbook_Open()
'--------------------------
  Application.ScreenUpdating = False
  EnableAllButtons
  Application.EnableEvents = False ' 28.10.19.
  
  Clear_COM_Port_Check_ans_Set_Cursor_in_all_Sheets False
  Set_Config_Default_Values_at_Program_Start
  Application.ScreenUpdating = True
  
  ' Generate events for special actions
  On Error GoTo ErrorDetectEvents
  Application.CommandBars("row").FindControl(ID:=883).OnAction = "myHideRows_Event"
  Application.CommandBars("row").FindControl(ID:=884).OnAction = "myUnhideRows_Event"
  On Error GoTo 0
  
  Copy_Prog_If_in_LibDir
  
  Application.EnableEvents = True ' 28.10.19.
  Exit Sub
  
ErrorDetectEvents:
  MsgBox "Interner Fehler: Die Event Routinen wurden nicht gefunden", vbCritical, "Interner Fehler"
End Sub




'****************************** Mouse Events **************************

#If 0 Then ' Disabled because it's enabled and disabled in M24_Mouse_Inset_Pos

    '************ Left Mouse button ************
    '------------------------------
    Private Sub Workbook_Activate()
    '------------------------------
      'hTimer = SetTimer(0, 0, 50, AddressOf M24_Mouse_Inset_Pos.MausUeberwachen)
    End Sub
    
    '--------------------------------
    Private Sub Workbook_Deactivate()
    '--------------------------------
      'KillTimer 0, hTimer
    End Sub
#End If


' Es gibt zwei Methoden wie man die RECHTE Maustaste abf|fffd|ngt:
' Die eine muss in "Dieser Arbeitsmappe" stehen:

#If 0 Then
    '-------------------------------------------------------------------------------------------------------
    Private Sub Workbook_SheetBeforeRightClick(ByVal sh As Object, ByVal Target As Range, Cancel As Boolean)
    '-------------------------------------------------------------------------------------------------------
      Cancel = True
      Debug.Print "DieserArbeitsmappe: Workbook_SheetBeforeRightClick" & Target.Row
    End Sub
#End If


' Die andere muss in der Code Seite es entsprechenden Sheets stehen:

'  Private Sub Worksheet_BeforeRightClick(ByVal Target As Range, Cancel As Boolean)
'  ' https://docs.microsoft.com/de-de/office/vba/api/excel.worksheet.beforerightclick
'  ' !! RECHTE Taste nicht die linke [X]<- [ ]
'    Debug.Print Activesheet.Name ":Worksheet_BeforeRightClick " & Target.Row
'  End Sub


'--------------------------------------------------------------------------------------------------------
Private Sub Workbook_SheetBeforeDoubleClick(ByVal sh As Object, ByVal Target As Range, Cancel As Boolean)
'--------------------------------------------------------------------------------------------------------
  If DEBUG_CHANGEEVENT Then Debug.Print "DieserArbeitsmappe: Workbook_SheetBeforeDoubleClick:" & Target.Row
  Proc_DoubleCkick sh, Target, Cancel
End Sub

#If 0 Then ' Not used at the moment
'------------------------------------------------------------
Private Sub Workbook_WindowActivate(ByVal Wn As Excel.Window)
'------------------------------------------------------------
' Is called if switched from an other excel Workbook to this workbook
  If DEBUG_CHANGEEVENT Then Debug.Print ThisWorkbook.Name & " Workbook_WindowActivate event"
End Sub
#End If

Attribute VB_Name = "M00_RevisionHistory_ToDo"
'  MobaLedLib: LED library for model railways
'  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
'
'  Copyright (C) 2018, 2019  Hardi Stengelin: MobaLedLib@gmx.de
'
'  This library is free software; you can redistribute it and/or
'  modify it under the terms of the GNU Lesser General Public
'  License as published by the Free Software Foundation; either
'  version 2.1 of the License, or (at your option) any later version.
'
'  This library is distributed in the hope that it will be useful,
'  but WITHOUT ANY WARRANTY; without even the implied warranty of
'  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
'  Lesser General Public License for more details.
'
'  You should have received a copy of the GNU Lesser General Public
'  License along with this library; if not, write to the Free Software
'  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA
'  -------------------------------------------------------------------------------------------------------------


' Revision History:
' ~~~~~~~~~~~~~~~~~
' 06.08.19: - Started
' 10.09.19: - Send to Franz-Georg
'           - Software upload to the right Arduino only if it's necessary
'           - Corrected the displayed USB pictures (Changed by mistake yesterday)
' 11.09.19: - Added MCP_CAN lib to the directory because it cant't be loaded with the ArdionoIDE
'           - Check_Requierd_Libs_and_Install_missing() is working
' 12.09.19: - Missing libraries are installed
'           - Boards could be selected in the Options menu
' 24.09.19: - Corrected the Autofilter. It has been disabled/set to the column 1 if rows have been moved
'           - Calling "Update_Start_LedNr" if the Autofilter is changed
'           => Ver. 0.53
' 26.09.19: - Speed up deleeting whole columns
'           - No hidden columns because this generates problems when copying rows when the Autofilter is activ.
'             - Internal Columns at the and are always visble (Hint from Alf)
'             - No Empty column E at DCC and CAN to be able to copy data between DCC,CAN and Selecrix
'               In this case the Column has to be added temporary
'           - House Times and DCC Offset could bedefined in the Config sheet
' 27.09.19: - Copy the program to own directory if it's started the first time form the library
'             and create a link on the desktop.
' 28.09.19: => Ver. 0.54
'           - Debug Meldungen zur Fehlersuche bei Rolf eingef|fffd|gt
'           => Ver. 0.55
'           - WaitForSingleObject mit LongLong f|fffd|r Win64 bei den beiden Armins
'           => Ver. 0.56
'           - Changed the result variable type also to LongLong
' 02.10.19: => Ver. 0.57
'           - Uploaded to GitHub and posted in the Stummi Forum
' 05.10.19: => Ver. 0.58 (In the previos release Version Const Prog_Version was set to 0.56 by mistake)
'           - Corrected generating of LOC_INCHx defines if the Flash() function was used without Ext_AddrTxt (DCC, ...)
'             In addition a warinig in the library has been disabled.
' 06.10.19: => Uploaded to GitHub and released library version 0.9.1
'           - Added: vbDirectory to Dir() command in Function Check_Requierd_Libs() to detect also
'             directories without files.
'           => Ver. 0.59
' 29.10.19: - Solved problems when first started after download "Gesch|fffd|tzte Ansicht" at Office 2013
'             - ActiveSheet is Nothing for some reasons
'             - Sheet.Select dosn't work
'           => Ver. 0.60

' ToDo:
' ~~~~~
' - C++ Lib:
'   - Wunsch von WolfHo "permanent flackernde R|fffd|hre" : #616 https://www.stummiforum.de/viewtopic.php?f=7&t=165060&p=2024020#p2024020
'     und Klaus-Dieter #621 https://www.stummiforum.de/viewtopic.php?f=7&t=165060&p=2024020#p2024142
'   - Wunsch von Harold Umschalten zwischen verschiedenen House() Konfigurationen f|fffd|r Abend/Nacht
'      #596: https://www.stummiforum.de/viewtopic.php?f=7&t=165060&p=2024020#p2023469


' - Library Path erkennen oder in dem Config sheet speichern wenn man nicht den Standard Pfad verwendet
'   => preferences.txt: sketchbook.path=C:\Users\Hardi\Documents\Arduino

' - Kommetare von Alf: "C:\Dat\M|fffd|rklin\Arduino\LEDs_Eisenbahn\Doc\von anderen\Alf\Prog Generator - Kommentare Alf 2019-10-04.docx"

' - Testen der Beispiele
' - Hilfe einbauen dass die SINGLE_LEDs in aufsteigender Reihenfolge sein m|fffd|ssen

' - Das Servo Tool verwendet den roten Kanal. Das passt aber nicht bei dem S3PO Modul

' - Manchmal wird nach der Auswahl der Funktion gleich nochmal nachgefagt.
'   Ich hab aber noch nicht herausgefunden wann das passiert.

' - Beim Verschieben von Zeilen mit aktivem Filter solte die Zielposition
'   direkt unter der dar|fffd|ber liegenden sichtbaren Zeile sein.
'   Momentan wird es vor die erste Zeile geschoben welche sichtbar ist.

' - Die SingleLEDs im Haus gehen nicht sofort aus => Untersuchen

' - Par_Description erg|fffd|nzen:
'     Blink3...: Pause, Act, In welchen Bereich k|fffd|nnen die Zeiten liegen
'     Val0, Val1 werden beim Blinker3 anderst verwendet als z.B. Beim Button
'     => |fffd|berpr|fffd|fen

' - Installation:
'   - Updates der MobaLedLib sollen erkannt werden
'     => Wie soll das gehen? Zun|fffd|chst doch manuel ansto|fffd|en
'   - Version aus der library.properties Datei auslesen. Momentan wird nur dann was gemacht wenn die Bibliothek fehlt
'   - Die alten Daten der User m|fffd|ssen bei einem Update erhalten bleiben
'     => Funktion zum Speichern der Daten einbauen
'   - Arduino IDE Installieren per Dialog?
'     Dann br|fffd|uchte man nur die Excel Datei herunterladen.

' - Doku:
' - Old Bootloader
'  - Menu / Meldung
'  - Installieren des Bootloaders


' - Rechtschreibpr|fffd|fung f|fffd|r alle Ausgaben/Dialoge
'   Done:
'   - M07_COM_Port

' - Probleme mit Office 2003 und kleiner bei Wilfied:
'   Hier gibt es auch Probleme mit der Anzahl der Zeilen/Spalten
'   Decode: If Exp_Rows > 64000 And val(Application.Version) < 12 Then  '(BKR): message box only for Office 2003 and older versions



' -----------------------------------
' - Vor dem beenden eine Meldung anzeigen wenn die Datei noch nicht gespeichert wurde
'   - COM Port einstellungen gehen verloren
' - Sound Befehle zusammenfassen wie beim Baustellenlicht
' - Ilumination Makro in die Bibliothek einbauen (Beispiel 16) => Nein: Braucht zu viel Speicher
' - Im Macro Auswahldialog soll man mit den Anfangsbuchstaben zur entsprechenden Zeile springen k|fffd|nnen
' - Erkennen wenn man in die Makro Spalte etwas kopiert ohne dass auch die folgenden Spalten
'   mit genommen werden. Das gibt ein Problem mit den Versteckten Spalten InChCnt , ...

' - Es ist nicht Gut wenn das Programm mit EndProg beendet wird. Dann werden alle Variablen
'   gel|fffd|scht. Das betrifft auch die Dialoge und deren Position.

' - Das Warnlevel f|fffd|r den RAM kann man evtl. mit dieser "Preverenzes" Eintrag ver|fffd|ndern: build.warn_data_percentage=75

' - Kommentare im Programm
'   - Kurze Beschreibung zu jedem Modul

' - Im DCC und Selectrix Programm sollen noch zus|fffd|tzliche Statusmeldungen zur
'   Diagnose eingebaut werden
'   - DCC vorhanden/nicht mehr vorhanden
'   - Pegelwechsel erkennung auch bei Selectrix Taktleitung

' - Der Uno kann mit diesem Board Parameter verwendet werden: '--board arduino:avr:uno
' - |fffd|berpr|fffd|fen ob das richtige Programm f|fffd|r DCC/Selectrix Arduino
'   installiert ist (Rs232 Meldungen lesen)

' - Die Excel Meldung: "Zahl ist als Text Formatiert" und das Gr|fffd|ne Dreieck ist nicht sch|fffd|n
' - Die InputBox() ersetzen da diese nicht mit ESC Abgebrochen werden k|fffd|nnen und
'   nicht zur Aplication zentriert sind

' - Arduino Bibliotheken |fffd|berpr|fffd|fen und geg. installieren

' - Einstellungsbutton
' - Prog_Version in die Sheets |fffd|bernemen beim Generate Release
' - Manchmal kommt ein Interner Kompiler Fehler.
'   Beim zweiten Compile Versuch ist er weg. => Untersuchen
'   Hier wird das beschrieben: https://arduino.stackexchange.com/questions/58495/strange-compiler-error-segmentation-fault
'      C:\Users\Hardi\Documents\Arduino\libraries\FastLED/controller.h: In member function 'clearLeds':
'      C:\Users\Hardi\Documents\Arduino\libraries\FastLED/controller.h:76:82: internal compiler error: Segmentation fault
'        virtual void clearLeds(int nLeds) { showColor(CRGB::Black, nLeds, CRGB::Black); }

' - Nicht aktive Zeilen sollten Grau dargestellt werden. Evtl. per Bedingter Formatierung. Dann kann der User
'   Trotzdem eigene Farben verwenden.
' - Die beiden Arduinos sollen unterschiedlich Blinken damit man erkennen kann wenn das falsche Programm
'   auf den Rechten Arduino geladen wurde.Die LED des DCC Arduinos macht gar nichts

' - Evtl. muss man noch den Programmer angeben. Aber das klappt nicht. Ich habe verschiedenen
'   Varianten dieses Strings probiert: --useprogrammer "arduino:arduinoisp"
'   Wenn ich nur --useprogrammer verwende, dann will er den ATTiny programmieren
'   Vielleicht braucht man den Parameter gar nicht.
'

' - Warnung bei doppelter Adresse (Gelber Text (Hint))
'   Dazu kann die Notiz Funktion verwendet werden. Zu beginn wird die Notiz in
'   beiden betroffenen Zellen Dauerhaft angezeigt. Nach 10 Sekunden wird sie wieder
'   ausgeblendet. Dann erscheint sie nur noch wenn man mit der Maus dr|fffd|ber f|fffd|hrt.

' - Die Dialoge sollen auch mit ALT+Taste zu bedinen sein. Aufgefallen beim
'   UserForm_Other. Man m|fffd|sste f|fffd|r jede Variable einen Buchstaben ablegen
'   => Das Programm das einfach selber anhand der Anfangsbuchstaben generieren
' - Die Standard MsgBox ist zum BS zentriert. Das Gef|fffd|llt mir nicht.
'   Alle Anderen sin zum Fenster zentriert. In der UserForm_Initialize()
'   wird |fffd|berall Center_Form Me aufgerufen. Dadurch, dass das nur beim
'   initialisieren gemacht wird bleiben die Buttons ach an der Stelle wenn
'   sie verschoben wurden bis das Programm neu gestartet wurde.


' - Wenn die Hilfe Datei nicht lokal vorhanden ist, dann kann man die
'   - Aus dem Bibliotheksverzeichniss
'   - oder von GitHub laden


' - Wenn eine neue Konfiguration geschickt wird welche weniger LEDs ansteuert als die
'   vorangegangene, dann bleiben u.U. alte LEDs an. Das ist sehr verwirrend. Darum
'   soll das Arduino Programm erst alle 256 LEDs 0 setzen.
'   Dazu wird aber viel Flash ben|fffd|tigt. Evtl. kann man das in der Bibliothek machen.
'   Ich habe bisher nur das gefunden: https://forum.arduino.cc/index.php?topic=556914.0
'   Ganz unten steht, dass er zwei Bereiche definiert hat. Einen mit 22 LEDs und einen mit 242
'   Beide menutzen eigene Pins. Diese hat er aber miteinende verbunden und aktiviert
'   immer nur einen als Ausgang.

' - UndoFunktion f|fffd|r Zeilen L|fffd|schen
'   Zeilen beim l|fffd|schen in ein eigenes Sheet verschieben. Auch bei "L|fffd|sche Tabelle"
' - Die Signale sollen zusammengefasst werden so dass der User nicht von dem InCh_to_TmpVar() sieht
' - Entry_Signal3_RGB ist nicht in der Bibliothek enthalten
'   - Das braucht man nur f|fffd|r Tests
'   - In die Bibliothek sollte rein Makro welches beides enth|fffd|lt:
'       InCh_to_TmpVar(#InCh, 3) // Eingang in in 8 Bit Var umwandeln
'       Entry_Signal3_RGB(#LED)
'     Am besten auch noch als Bin|fffd|r
'     - Entry_Signal3_But_RGB
'     - Entry_Signal3_Bin_RGB
'     - Entry_Signal3_But
'     - Entry_Signal3_Bin
'   - Das Macro darf nicht im Testprogramm sein sondern muss in dem Excel Makro stehen
' - Mehrbegriffige Signale k|fffd|nnen mit Selectrix auf verschiedene Arten angesteuert werden
'   - Jeder Zustand wird von einem eigenen Bit gesteuert. Immer wenn sich das Bit
'     |fffd|ndert wird der Zustand aktiviert. Damit ist die Zuordnung zu den Signalbegriffen
'     einfach aber es werden mehr Kan|fffd|le ben|fffd|tigt. Ein 4 begriffiges Signal belegt 4 Kan|fffd|le
'   - Die Zust|fffd|nde werden bin|fffd|r kodiert. Hier ben|fffd|tigt man nur zwei Bits f|fffd|r ein 4 begriffiges Signal

' - Beim "Alle Einblenden" Button Fragen was eingeblendet werden soll (AutoFilter / Versteckte Zeilen)

' - Eine Tabelle mit Umschalter (DCC/SX/CAN) oder mehrere Tabellen?
' - Testprogramm 23_B.DCC_Rail_Decoder_Receiver.ino aufr|fffd|umen und neuen Namen vergeben
'   - Die Progamme f|fffd|r den DCC Arduino beginnen mit 23_A.
'     (z.B.: 23_A.DCC_Interface, 23_A.CAN_Interface, 23_A.Selectrix_Interface, 23_A.LocoNet_Interface)
'   - Das LED Programm hei|fffd|t 23_B.LEDs_AutoProg

' - |fffd|berpr|fffd|fung ob alle InCh bedient werden.
'   - Spalte mit Anzahl der erwarteten InCh einbauen.
'   - Wie definiert man InCh von anderen Quellen?
'     - SI_1
'     - Schalter welcher per DigitalIn gelesen wird
'     - Ausgang einervanderen Funktion (z.B. Random)
'     - Andere DCC Zeile


' - Anzahl der ausgeblendeten Zeilen Anzeigen. Wenn man Draufklickt wird gefragt ob alle eingeblendet werden sollen

' - Hinzuf|fffd|gen zu einer bestehenden Configurationszeile ?
' - |fffd|berpr|fffd|fungen
'   - Selbe Routinen bei den Speziellen Dialogen verwenden

' - Achtung: Die Anzahl der Spalten ist auf 16384 gesetzt => Es kann nicht mit einem Alten Excel benutzt werden



' Doku:
' ~~~~~
' - Anleitung Arduino Prozessor ausw|fffd|hlen , ... in die Doku
' - Der SKIP_ROOM kann bei dem aktuellen Konzept nicht so einfach genutzt werden.
'   Man muss vor der entsprechenden House Zeile eine Funktion definieren bei der LEDs 0 ist.
'   Hier kann man dann z.B. mit Const(#LED+3, C_ALL, #InCh, 0, 255) auf die SKIP_ROOM LED zugreifen.
'   => Das ist nur was f|fffd|r Experten
' - Inbetriebname des DCC beschreiben
'   - Baudrate des Seriellen Monitors


' ToDo f|fffd|r n|fffd|chste Version:
' ~~~~~~~~~~~~~~~~~~~~~~~~~
' - Expert Mode
'   - Eigene Variablen
' - Editieren bestehender Config Eintr|fffd|ge
'   Urspr|fffd|nglichen Wert im Dialog anzeigen beim editierende Eintr|fffd|ge
'   - Select_Typ_by_Dialog
'   - SelectMacros_Form
'   - UserForm_Other, ..House, ...
' - Tab in dem man eigene Macros eingeben kann.
' - Integration des Pattern Generators
'   Evtl. auch ein Live Test
' - Live Ansteuerung der LEDs
'   - Set_ColTab mit einem Bild von 64 LEDs konfigurieren
'     - Colorpicker
'       https://www.instructables.com/id/How-to-use-RGB-Strip-Color-Picker/
'       https://programino.com/programino-ide-arduino-rgb-led-color-picker.html
'       Excel: https://www.reddit.com/r/arduino/comments/6ho5kh/visualizing_a_potentiometer_shifting_the_color_of/
'       Farben: http://www.cpearson.com/excel/colors.aspx
'   - Test Mode per serieller Schnittstelle. Geht das mit angeschlossenem DCC Arduino?
'     Evtl. Muss man einen Reset generieren und gleich am Anfang eine bestimmte Sequenz schicken.
'     Befehle:
'       |fffd|3 255 255 255  => LED 3 auf Wei|fffd|
'       |fffd|e              => Ende
'       |fffd|i 34 1         => Input channel setzen zum Test ohne DCC
' - Konfigurationsseite
'   - Serial Port
'   - Arduino Typ
'   - "--verbose-upload", "--verbose-build"
'   - ...
' - Zus|fffd|tzliche Bibliotheken automatisch installiern wenn sie nicht vorhanden sind
' - Hardware Eing|fffd|nge unterst|fffd|tzen:
'   - Schalter an DIn
'   - Taste an AIn
'   - Mux Taster
'   - Helligkeitssteuerung
' - Ribbon interface?
'   + Verschiebt sich nicht wenn das Blatt nach rechts gescrollt wird
'   + Bessere Hilfe
'   + Sch|fffd|nere Icons m|fffd|glich (PNG, viele Farben)
'   + Kein Problem mehr mit den Button Sizes: Correct_Buttonsizes() ben|fffd|tigt 600ms
'   - Zus|fffd|tzlicher Aufwand
'   - Evtl. Probleme in Open Office
'   - Kann man die Ribbons auch mit Tasten steuern? In meinem Filter Addon habe ich CTRL+Shift+Taste verwendet
'     Evtl. kann an unsichtbare Buttons verwenden damit ALT+Taste geht. Das geht dann auch wenn das Ribbon unsichtbar ist
'   - ?
' - Warum dauert es so lange bis die Meldung kommt wenn man auf den "Optionen" Button klickt ?
'   => Correct_Buttonsizes() ben|fffd|tigt 600ms ;-(

' - Der letzte Zustand der InCh Variablen k|fffd|nnte periodisch im EEPROM gespeichert werden und beim neustart
'   wieder geladen werden. Dazu k|fffd|nnte man das gesammte EEPROM Nutzen. Ein neuer Wert wird an die n|fffd|chste freie Stelle
'   im EEPROM Gespeichert. Wenn der Speicher voll ist wird wieder von vorne begonnen. Der EEPROM wird komplett
'   als frei markiert. Die Daten werden in einer Struck gespeichert welche eine CRC enth|fffd|lt welche
'   G|fffd|ltige Daten kennzeichnet.
'

' Verworfene Ideen:
' ~~~~~~~~~~~~~~~~~
' - Servo Best|fffd|ckung an Armin und in Bibliothek
' - Filter Spalte ganz ans Ende ? => Nein
' - Anstelle von einem Haken zum aktivieren einer Zeile k|fffd|nnte man auch ein Verbotsschild
'   zum deaktivieren verwenden: "Wingdings2" Zeichen X
' - Kommentare in der "Beleuchtung, Sound, oder andere Effekte" Spalte Farblich markieren
' - Simulation einer kleinen Configuration. Dazu werden die Daten in das EEPROM geschrieben
'   + Die |fffd|bertragung w|fffd|rde viel schneller gehen
'   - Dazu m|fffd|sten aber die #defines ersetzt werden. Das betrifft auch die Makros
'     => Man m|fffd|sste dem Pr|fffd|prozessor benutzen
'        ==> Das wird zu aufw|fffd|ndig, Dann wartet man halt 20 Sekunden bis der Kompiler fertig ist


' Mit Armin Festgestellt am 20.8.19 und behoben und wiele weitere |fffd|nderungen
' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' - |fffd|berlappung in der Arduino Send Dialogbox                                               => Ge|fffd|ndert: Bei Armin testen
' - Fehler beim Erzeugen Kompelieren wenn im Pfad Namen sonderzeichen vorkommen "M|fffd|rklin"   => O.K.
' - Genereller Hilfe Text in Haus Dialog
'   - Room_Dark und einige andere haben kein Hint
' - Cursor wird nicht auf die n|fffd|chste fehlende Typ Zeile gesetzt beim Arduino Button        => O.K.
'   Wenn mehrere Typ Zellen leer sind
' - Wenn kein Eintrag in "Beleuchtung, Sound, oder andere Effekte" ist, dann l|fffd||fffd|t sich      => O.K.
'   das Programm nicht compelieren weil das Config Array fehlt
' - Maximale Zeit bis zu n|fffd|chsten |fffd|nderung im House Dialog bis 254
'   Hier ist auch kein Hint
' - Beschreibungen zu den Spalten|fffd|berschriften
' - Dialog mit dem reservierte LEDs eingetragen werden k|fffd|nnen
' - Arduino Program St|fffd|rtzt ab, wenn die RGB_AmpelXFade als letzte Zeile verwendet wird
'   Wenn im Anschluss noch ein Blink3 kommt dann geht es
'   => Anzahl der LEDs in Letzter Zeile wurde nicht ber|fffd|cksichtigt
' - Mit Ctrl+Button den Arduino Dialog zeigen wenn dieser |fffd|ber das "Don't show again ausgeblendet wurde"
' - Zeilen zur Doku sollen m|fffd|glich sein. Wenn InCnt = 0, dann kein Eintrag in Ext_Addr
' - Das L|fffd|sche Tabelle und Help Bild wird unsch|fffd|n beim Zeilen verschieben.
' - Beim L|fffd|schen der Seite
'   - sollte nach oben gescrollt werden
'   - sollten nur ein paar leere Zeilen bleiben. Wie viele ? Ein Bildschirm ?
' - Die Berechnung von "#define NUM_LEDS" geht nicht wenn nur C1, C2, C3 LEDs benutzt werden
' - Spalten welche nicht von Hand editiert werden sollen grau hinterlegen
' - Schriftart "Consolas" In Config Array Spalte
' - Autofilter muss sich auf alles beziehen auch wenn neue Zeilen angef|fffd|gt werden
' - Bei Effekten wie dem Andreaskreuz machen nicht alle Cx M|fffd|glichkeiten Sinn.
'   Es Funktioniert nur C1, C2 und C3. => Es solte ien anderer Default Wert existieren
'   und die unsinnigen Optionen (C12, C23 und C_ALL) ausgegraut sein.
'   => So unsinnig sind die anderen Optionen nicht C12 und C23 macht genau das was man erwartet.
'      Nur C_ALL steuert nur die erste und zweite LED an
' - Start Seite
' - Doppelte Adressen sind m|fffd|glich solange der gleich Typ benutzt wird. Sie werden |fffd|ber ein INCH_... Define adressiert.
' - Sollen mehrere Eintr|fffd|ge in einer Zeile unterst|fffd|tzt werden?
'   - Wenn man eine Adresse mehrfach benutzen kann dann braucht man das nicht mehr
'   - F|fffd|r Signale welche per DCC angesteuert werden wird ein Makro generiert welches
'     das InCh_to_TmpVar enth|fffd|lt. Das ist sowieso schwer verst|fffd|ndlich
'   => Nein
' - Die InCh der DCC Eing|fffd|nge werden als #define INCH_ADDR_123_RED generiert.
'   Dann kann man diese an anderer Stelle benutzen
' - Beim Verschieben in einen Bereich au|fffd|erhalb der Tabelle
'   werden die Formatierungen nicht richtig aktualisiert
' - Beim L|fffd|schen von Zeilen muss daf|fffd|r gesorgt werden, das wieder 3 Leerzeilen am Ende
'   vorhanden sind sonst funktioniert der Filter nicht mehr
' - Bei Signalen erste und letzte Adresse in Adress Spalte untereinader
'   Soll hier auch die Direction ber|fffd|cksichtigt werden (Rot/Gr|fffd|n) ? => Nein erstmal nicht
' - Die Fehlermeldung "Internal error: Unknown Page_ID: '" kommt manchmal wenn man
'   auf ein anderes Blatt schaltet w|fffd|hrend man eine Zelle editiert
' - Verschieben mit Maus:
'   - Umschalten auf anderes Sheet muss erkannt werden => Abbruch
' - Buttons Zucken beim verschieben bei Armin => liegt am TeamViewer
' - Keine Spalten|fffd|berschriften auf Startseite
' - Startseite: Dialog Button zeigen
' - Beim Programmstart EnableDisableAllButtons True auf allen Seiten aufrufen falls die Buttons
'   durch einen Crash deaktiviert wurden
' - Das bewegen des Cursors ist sehr langsam => Auch wenn Global_Worksheet_SelectionChange deaktiviert ist ist es langsam
' - Sch|fffd|neren Start Knopf auf Start Seite
' - Verwende immer den Arduino Nano beim Download
' - Eingabe des COM Ports
' - Zus|fffd|tzlice Ausgaben in cmd File
' - Installation des DDC/Selectrix Arduinos
' - Die Konstanten COMPort_COL, ... sollten auch Dynamisch gef|fffd|llt werden
' - Defaultwert f|fffd|r die INCh Variablen. Das wird z.B. bei den Signalen gebraucht
' - CAN:
'   - Adresses from 0 - 0x7FF are possible (2048 adresses)
'   - Spalte "D" muss CAN Adresse heissen oder nur "Adresse"
' - Anpassungen an VBA7
' - Datum und Zeit (Pfad) in Arduino Prog schreiben und beim Booten anzeigen
' - Beim Programmstart sollen ActiveCell auf die erste Leere Zeile gesetzt werden
'   damit der Dummy Dialog richtig funktioniert
' - Anzeige meherere SX Kan|fffd|le mit "1 - 2" wie bei DCC. Hier muss eigentlich auch die Bitposition rein
' - Spalte von Adresse und SX Channel so formatieren, das eine Neue Zeile begonnen wird wenn es nicht passt
' - Beim compilieren des DCC Programms kommt eine Warnung, dass der EEPROM nicht benutzt wird. Das ist unsch|fffd|n
' - Untersuchen warum das Arduino Prog. so viel Speicher braucht
'   => Die serielle Schnittstelle braucht 1078 Byte Flash (4%) und 201 Byte RAM (10%)
'   - HeartBeat:  Der Sketch verwendet 14130 Bytes (45%) des Programmspeicherplatzes. Das Maximum sind 30720 Bytes.
'                 Globale Variablen verwenden 366 Bytes (17%) des dynamischen Speichers, 1682 Bytes f|fc|r lokale Variablen verbleiben. Das Maximum sind 2048 Bytes.

'   - Ohne Addr   Der Sketch verwendet 15176 Bytes (49%) des Programmspeicherplatzes. Das Maximum sind 30720 Bytes.
'                 Globale Variablen verwenden 457 Bytes (22%) des dynamischen Speichers, 1591 Bytes f|fc|r lokale Variablen verbleiben. Das Maximum sind 2048 Bytes.
'   - Ohne Serial Der Sketch verwendet 14098 Bytes (45%) des Programmspeicherplatzes. Das Maximum sind 30720 Bytes.
'                 Globale Variablen verwenden 256 Bytes (12%) des dynamischen Speichers, 1792 Bytes f|fc|r lokale Variablen verbleiben. Das Maximum sind 2048 Bytes.
' - Pattern_Configurator CR/LF Problem auf GitHub !!!
' - Wenn beim Hochladen zum Selextrix Arduino was schief geht dann muss
'   es solange wiederholt werden bis es geht
' - Corrected the House LED count
' - House:
'   - Besser Defaultwerte (1/2 und 2/3 oder so)
'   - Min Und Max LEDs nach den Rooms, und automatisch berechnen
' - Beim Programmstart und -ende ? "BuildDir" l|fffd|schen. Evtl. auch eine Taste Einbauen.
'   => Ist nicht n|fffd|tig. |fffd|nderungen im original LIB Verzeichniss werden erkannt
' - Eigenes Bild f|fffd|r CAN
' - DCC/Selectrix SW soll nur dann herunter geladen werden wenn Adressen benutzt werden
' - Im DCC Adresse Feld werden keine neuen Zeilen hinzugef|fffd|gt wenn man am ende ist
' - UNO wird nicht bei der COM Port suche entdeckt obwohl der Mode Befehl einen Port 12 erkennt. => Jetzt geht es wieder
' - Wenn man beim Programmieren von Sound Modules die "Soll der Kanal Gleich Adressiert
'   werden Frage" mit best|fffd|tigt, dann kommt bei Geraden Nummern (Gr|fffd|n?)
'   gleich wieder der Auswahl Dialog ?
'   => Kann ich nicht mehr reproduzieren ;-(
' - Signale f|fffd|r Selectix
' - Der Autofilter war gestern beim Release verschwunden welches ich Karl gegeben habe.
'   Wenn ich in die Datei auf meinem Rechner schaue ist er aber da ?!?
'   Machmal rutscht er auch in die Erste Zeile
' - Beim |fffd|ndern des Filters m|fffd|ssen die LED Nummern neu berechnet werden !
' - Probleme mit dem Autofilter:
'   - Es ist recht aufw|fffd|ndig diesen |fffd|ber einen Bereich mit l|fffd|cken zu erweitern
'   - Das Automatische erh|fffd|hen einer Zahl mit dem K|fffd|stchen Rechts unten geht nicht
'   - Es gibt Probleme beim Kopieren einer Zeile in verbindung mit versteckten Zeilen
'   - Die Autofilter sind nicht intuitiv. Die Leerzeilen werden gerne vergessen
'   => Darum verwende ich jetzt keine versteckten Spalten
' - Proc_Copy_Row spinnt wenn Spalten E und N, O Versteckt sind
' - Globale Zeiten der House() einstellbar machen
' - Bei der Z21 wird die Adresse 1 als -3 auf dem DCC Arduino erkannt
'   => Schalter einbauen ?

Attribute VB_Name = "M01_Gen_Release_Version"
Option Explicit

' Call the following function to generate a release version
'--------------------------------
Private Sub Gen_Release_Version()
'--------------------------------
  Release_or_Debug_Version True
  MsgBox "Beispiel Zeilen O.K. ?", vbQuestion
End Sub


'------------------------------
Private Sub Gen_Debug_Version()
'------------------------------
  Release_or_Debug_Version False
End Sub



'-------------------------------------------------------
Private Sub Release_or_Debug_Version(Release As Boolean)
'-------------------------------------------------------
  Dim sh As Variant, LastSheet As String
  LastSheet = ActiveSheet.Name
  For Each sh In ThisWorkbook.Sheets
      If Is_Data_Sheet(sh) Then
         sh.Select
         Make_sure_that_Col_Variables_match
         
         ' Show / Hide the internal variables
         With Range(Cells(SH_VARS_ROW, 1), Cells(SH_VARS_ROW, LastUsedColumn)).Font
            If Release Then
                  .ThemeColor = xlThemeColorDark1
            Else: .ColorIndex = xlAutomatic
            End If
         End With
         
         ' Show / Hide the internal columns
         Cells(1, InCnt___Col).EntireColumn.Hidden = False ' 26.09.19: Don't hide the internal columns because this generates problems when
         Cells(1, LocInCh_Col).EntireColumn.Hidden = False '           lines are copied while the AutoFilter is activ. Prior the columns
                                                           '           have been hidden in release mode
         
         ' Build otions
         Cells(SH_VARS_ROW, BUILDOP_COL) = "'--board arduino:avr:nano:cpu=atmega328old --pref programmer=arduino:arduinoisp"
         If Page_ID <> "CAN" Then
           Cells(SH_VARS_ROW, BUILDOpRCOL) = "'--board arduino:avr:nano:cpu=atmega328old --pref programmer=arduino:arduinoisp"
         End If
      End If
  Next sh
  
  ' Show / Hide the internal sheets
  Sheets("Lib_Macros").Visible = Not Release
  Sheets("Par_Description").Visible = Not Release
  'Sheets("Farbentest").Visible = Not Release
  
  ' Protect / Unprotect sheets
  If Release Then
        Sheets("Start").Select
        Range("A1").Activate ' Scroll to the top
        Range("M11").Select  ' Below the picture
        Sheets("Start").Protect DrawingObjects:=True, Contents:=True, Scenarios:=True
        ActiveWindow.DisplayHeadings = False
  Else: Sheets("Start").Unprotect
  End If

  If Release Then Set_Config_Default_Values_for_Release

  Clear_COM_Port_Check_ans_Set_Cursor_in_all_Sheets Release
  If Release Then
        Sheets("Start").Select
  Else: Sheets(LastSheet).Select
  End If
End Sub


'------------------------------------------------------
Public Sub Set_Config_Default_Values_at_Program_Start()
'------------------------------------------------------
  Set_Bool_Config_Var "Lib_Installed_other", False
End Sub


'--------------------------------------------------
Private Sub Set_Config_Default_Values_for_Release()
'--------------------------------------------------
  Set_String_Config_Var "MinTime_House", ""
  Set_String_Config_Var "MaxTime_House", ""
  Set_String_Config_Var "DCC_Offset", ""
End Sub
Attribute VB_Name = "M02_Public"
Option Explicit
Public Const Lib_Version_Nr = "0.9.2"
Public Const Prog_Version = "Ver. 0.60"

Public Const DEBUG_CHANGEEVENT = True ' Debug Events

Public Const InoName_DCC = "23_A.DCC_Interface.ino"
Public Const InoName__SX = "23_A.Selectrix_Interface.ino"

Public Const InoName_LED = "23_B.LEDs_AutoProg.ino"

Public Const Include_FileName = "LEDs_AutoProg.h"

' Sheet Lib_Macros: (The Sheet can not be changed by the USER => We keep the constants)
Public Const SM_DIALOGDATA_ROW1 = 4

Public Const SM_Typ___COL = 1
Public Const SM_Mode__COL = 2
Public Const SM_LEDS__COL = 3
Public Const SM_InCnt_COL = 4
Public Const SM_OutCntCOL = 5
Public Const SM_LocInCCOL = 6
Public Const SM_Tmp8BtCOL = 7
Public Const SM_SngLEDCOL = 8  ' Single LED Cnt
Public Const SM_Macro_COL = 9
Public Const SM_Name__COL = 10
Public Const SM_ShrtD_COL = 11
Public Const SM_DetailCOL = 12


' Valid for all sheets
Public Const Enable_Col = 2
Public Const Adress_Col = 3

Public Const Headder_Row = 2
Public Const FirstDat_Row = Headder_Row + 1
         
Public Const SH_VARS_ROW = 1  ' This row contains some sheet specific varaibles. The text uses white color => It' not visible
Public Const PAGE_ID_COL = 2  ' This cell contains a page ID to idetify the sheet

Public Const AllData_PgIDs = " DCC Selectrix CAN "
Public Const Prog_for_Right_Ardu = " DCC Selectrix Loconet "


Public Const MAX_ROWS = 1048576
Public Const MAX_COLUMNS = 16384


Public Const Hook_CHAR = 61692 ' Font Wingdings

Public Const SPARE_ROWS = 3 ' Number of spare rows which are generated if data are entered in a new line


Public Const ConfigSheet = "Config"

' Variables
Public SelectMacro_Res As String
Public Userform_Res As String


Public DialogGuideRes As Long ' uses constants like vbOK, vbAbort, vbNo


' Links for 32 and 64 Bit Windows:
' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' - General description: https://codekabinett.com/rdumps.php?Lang=2&targetDoc=windows-api-declaration-vba-64-bit
'   "Also new with VBA7 are the two new compiler constants Win64 and VBA7.
'    VBA7 is true if your code runs in the VBA7-Environment (Access/Office 2010 and above).
'    Win64 is true if your code actually runs in the 64-bit VBA environment.
'    Win64 is not true if you run a 32-Bit VBA Application on a 64-bit system."
' - Overview 32 / 64 Bit functions: https://jkp-ads.com/Articles/apideclarations.asp

' Following parts use declared external functions
' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' - M06_Write_Headder:
'    - Detect if CTRL is pressed when the "Arduino" button is pressed
'      Public Sub Write_Headder_File()
' - M40_Mouse_Scroll
'    - Uses a lot of functions to be able to use the scroll wheel
' - M31_Sound
'    - Play a windows sound if the hook is enabled/disabled
'      BeepThis2()
' - M24_Mouse_Insert_Pos
'    - Mouse cursor if lines are moved (Mouse or Keyboard)
' - M40_ShellAndWait
'    - Start the Arduino Compiler
' - M30_Tools
'    - Sleep         => Some locatons
'    - ShellExecute  => EditFile_Click
'    - GetKeyState   => Not used
Attribute VB_Name = "M03_Dialog"
Option Explicit

' Dialog guided input

' - Kurze Erkl|fffd|rung am Anfang
'   mit Auswahl der Zeile.
'   Wenn bereits Daten in der Zeile sind, dann wird mit der ausgew|fffd|hlten Spalte weitergemacht
' - Abfrage ob der Effekt von DCC gesteuert werden soll.
'   - Adresse
' -
Private Ask_Input_NextRow As Boolean
Private Input_NextRow As Boolean

'-------------------------------
Public Sub Dialog_Guided_Input()
'-------------------------------
  Make_sure_that_Col_Variables_match
  
  If First_Change_in_Line(ActiveCell) Then
     UserForm_DialogGuide1.Show
    
     While UserForm_DialogGuide1.IsActive
       DoEvents
     Wend
     If DialogGuideRes = vbAbort Then Exit Sub
     
     Dim i As Long
     For i = 1 To 5
       DoEvents ' Redraw the screen
       Sleep 50 ' Time to update the display
     Next
         
     Do
         Input_NextRow = False
         Ask_Input_NextRow = True
         Ask_External_Control
         
         If Input_NextRow Then
            Debug.Print "ToDo: Pr|fffd|fen of die n|fffd|chste Zeile leer ist und geg. eine Zeile einf|fffd|gen"
         End If
     Loop While Input_NextRow
  Else
     Ask_Input_NextRow = False
     Dim r As Long
     r = ActiveCell.Row
     Select Case ActiveCell.Column
       Case DCC_or_CAN_Add_Col, _
            SX_Channel_Col: ' DCC adress oder SX Channel
                            Dim SX_DataAvailable As Boolean
                            If SX_Bitposi_Col > 0 Then SX_DataAvailable = Cells(r, SX_Bitposi_Col) <> ""
                            If Cells(r, DCC_or_CAN_Add_Col + SX_Channel_Col) = "" And Not SX_DataAvailable Then
                                  Ask_External_Control
                            Else: Input_Address
                            End If
       Case Inp_Typ_Col:    Input_Typ
       Case SX_Bitposi_Col: Input_BitPos
       Case Start_V_Col:    Input_Start_Val
       Case Descrip_Col:    Input_Description
       Case Dist_Nr_Col, _
            Conn_Nr_Col:    ' Distributor or connector number
                            Input_Connector
       Case Config__Col:    SelectMacros
       Case Else            ' Unsupported column
                            If ActiveCell.Column > Config__Col Then
                                  MsgBox "Die ausgew|fffd|hlte Spalte sollte nur von erfahrenen Benutzern ver|fffd|ndert werden." & vbCr & _
                                         "Es existiert keine Dialog gest|fffd|tzte Eingabe.", vbInformation, "Spalte sollte nur von Experten ver|fffd|ndert werden"
                            Else: MsgBox "F|fffd|r die Ausgew|fffd|hlte Spalte existiert noch kein Dialog", vbInformation, "Kein Dialog vorhanden"
                            End If
     End Select
  End If
End Sub

'--------------------------------
Public Sub Ask_External_Control()
'--------------------------------
Make_sure_that_Col_Variables_match
  Select Case MsgBox("Soll die LED Gruppe |fffd|ber " & Page_ID & " gesteuert werden?" & vbCr & _
                     vbCr & _
                     "  Ja:     Der Effekt kann |fffd|ber eine Zentrale geschaltet werden." & vbCr & _
                     "           Im Folgenden wird die Adresse zur Steuerung der" & vbCr & _
                     "           Funktion abgefragt. Das ist z.B. bei einem Haus oder" & vbCr & _
                     "           einem Signal sinvoll." & vbCr & _
                     "  Nein: Der Effekt ist dauerhaft aktiv. Das kann man z.B. bei" & vbCr & _
                     "           einer Ampel ausw|fffd|hlen. Die Steuerung |fffd|ber " & Page_ID & vbCr & _
                     "           kann auch nachtr|fffd|glich aktiviert werden.", _
                     vbQuestion + vbYesNoCancel, "Steuerung |fffd|ber " & Page_ID & "?") ' 03.09.19: Corected with problem detected by Alf
     Case vbYes: Input_Address
     Case vbNo:  Input_Description
     Case vbCancel: Exit Sub
  End Select
End Sub


'-------------------------
Public Sub Input_Address()
'-------------------------
  Dim Txt As String, This_Addr_Channel As String, Addr_Channel As String, MinVal As Long, MaxVal As Long, Adresses_Channels As String
  If Page_ID = "Selectrix" Then
        Txt = " Kanal eingeben":   This_Addr_Channel = "Der Kanal":   Addr_Channel = "Kanal":   MinVal = 0: MaxVal = 99:    Adresses_Channels = "Kan|fffd|le"
  Else: Txt = " Adresse eingeben": This_Addr_Channel = "Die Adresse": Addr_Channel = "Adresse": MinVal = 1: MaxVal = 10240: Adresses_Channels = "Adressen"
  End If
  If Page_ID = "CAN" Then MaxVal = 65535 ' ??
  
  Dim Inp As String, Valid As Boolean
  Inp = Get_First_Number_of_Range(ActiveCell.Row, DCC_or_CAN_Add_Col + SX_Channel_Col)
  Do
    Inp = InputBox("Bitte " & Page_ID & Txt & " [" & MinVal & ".." & MaxVal & "]" & vbCr & _
                   vbCr & _
                   This_Addr_Channel & " muss bei der Zentrale zur Steuerung der Funktion angegeben werden." & vbCr & _
                   vbCr & _
                   "Achtung: Bei manchen Funktionen werden mehrere " & Adresses_Channels & " belegt. " & _
                   "Das Programm erg|fffd|nzt den Bereich automatisch (Beispiel: 23 - 24)" & vbCr & _
                   "Es muss nur der Startwert ohne '- 24' eingegeben." & vbCr & _
                   vbCr & _
                   Page_ID & " " & Addr_Channel & ": ", Page_ID & Txt, Default:=Inp)
    
    'Debug.Print "Res='" & Inp & "'" ' Debug
    If InStr(Inp, "-") > 1 Then Inp = Left(Inp, InStr(Inp, "-"))
    If IsNumeric(Inp) Then Valid = Val(Inp) >= MinVal And Val(Inp) <= MaxVal And Int(Inp) = Inp
    If Inp <> "" And Not Valid Then
       BeepThis2 "Windows Balloon.wav"
       Show_Status_for_a_while "Falsche Eingabe. " & This_Addr_Channel & " muss zwischen " & MinVal & " und " & MaxVal & " liegen. "
    End If
  Loop Until Inp = "" Or Valid
  Show_Status_for_a_while ""
  
  If Valid Then
     With Cells(ActiveCell.Row, DCC_or_CAN_Add_Col + SX_Channel_Col)
       .Value = Val(Inp)
       Application.EnableEvents = False ' Prevent opening the Typ Dialog per Event
       .Offset(0, 1).Select
       Application.EnableEvents = True
     End With
     If Page_ID = "Selectrix" Then
           Input_BitPos
     Else: Input_Typ
     End If
  End If
End Sub

'------------------------
Public Sub Input_BitPos()
'------------------------
  Dim Inp As String, Valid As Boolean
  Inp = Cells(ActiveCell.Row, SX_Bitposi_Col)
  Do
    Inp = InputBox("Bitte die Bitposition eingeben [1..8]" & vbCr & _
                   vbCr & _
                   "Die Bitposition muss bei der Zentrale zur Steuerung der Funktion angegeben werden." & vbCr & _
                   "Achtung: Bei manchen Funktionen werden mehrere Bits belegt. Die Eingabe definiert das erste benutzte Bit." & vbCr & _
                   vbCr & _
                   "Bitpositioen: ", Page_ID & "Bitposition eingeben", Inp)
    
    'Debug.Print "Res='" & Inp & "'" ' Debug
    If IsNumeric(Inp) Then Valid = Val(Inp) >= 1 And Val(Inp) <= 8 And Int(Inp) = Inp
    If Inp <> "" And Not Valid Then
       BeepThis2 "Windows Balloon.wav"
       Show_Status_for_a_while "Falsche Eingabe. Die Bitposition muss zwischen 1 und 8 liegen. "
    End If
  Loop Until Inp = "" Or Valid
  
  If Valid Then
     With Cells(ActiveCell.Row, SX_Bitposi_Col)
       .Value = Val(Inp)
       Application.EnableEvents = False ' Prevent opening the Typ Dialog per Event
       .Offset(0, 1).Select
       Application.EnableEvents = True
     End With
     Input_Typ
  End If
End Sub

'---------------------
Public Sub Input_Typ()
'---------------------
  Select_Typ_by_Dialog ActiveCell
  If Userform_Res <> "" Then
     Cells(ActiveCell.Row, Inp_Typ_Col).Offset(0, 1).Select
     Input_Start_Val
  End If
End Sub

'---------------------------
Public Sub Input_Start_Val()
'---------------------------
  Const MinVal = 1
  Const MaxVal = 255
  'Debug.Print "Inp_Typ_Col=" & Inp_Typ_Col
  Dim Valid As Boolean, Inp As Variant
  Inp = ActiveCell
  Do
    Inp = InputBox("Startwert des Eingangs eingeben" & vbCr & _
                   vbCr & _
                   "Der Startwert bestimmt das Verhalten nach dem Einschalten in Verbindung mit DCC, " & _
                   "CAN oder Selectrix. " & vbCr & _
                   "Normalerweise sind die Funktionen beim Start deaktiv. " & _
                   "Erst wenn der erste " & Page_ID & " Einschaltbefehl von der Zentrale kommt wird " & _
                   "die Zeile aktiviert. " & vbCr & _
                   "Wenn eine bestimmte Funktion bereits beim Einschalten der " & _
                   "Anlage einen definierten Wert haben soll kann das |fffd|ber den " & _
                   "Startwert vorgegeben werden. Die meisten Funktionen haben einen Eingang mit dem sie " & _
                   "Ein- oder Ausgeschaltet werden. Hier wird eine 1 zum Einschalten angegeben." & vbCr & _
                   "Bei Funktionen mit mehreren Eing|fffd|ngen (z.B. Signale) ist der Wert ist Bitkodiert. " & _
                   "Hier wird der erste Eingang mit einer 1, zweite Eingang mit einer 2 und der dritte Eingang " & _
                   "mit einer 4 aktiviert." & vbCr & _
                   vbCr & _
                   "Startwert:  (Keine Eingabe wenn nicht ben|fffd|tigt)", "Definition des Startwerts", Inp)
    
    If IsNumeric(Inp) Then Valid = Val(Inp) >= MinVal And Val(Inp) <= MaxVal And Int(Inp) = Val(Inp)
    
    If Inp <> "" And Not Valid Then
       BeepThis2 "Windows Balloon.wav"
       Show_Status_for_a_while "Falsche Eingabe. " & Inp & " muss zwischen " & MinVal & " und " & MaxVal & " liegen. "
    End If
    
  Loop Until Inp = "" Or Valid
  ActiveCell = Inp
  Show_Status_for_a_while ""
  ActiveCell.Offset(0, 1).Select
  Input_Description
End Sub

'-----------------------------
Public Sub Input_Description()
'-----------------------------
  Dim Res As String
  Res = UserForm_Description.ShowForm(ActiveCell.Value)
  If Res <> "<Abort>" Then
     With Cells(ActiveCell.Row, Descrip_Col)
       .Value = Res
       .Offset(0, 1).Select
     End With
     Input_Connector
  End If
End Sub


'---------------------------
Public Sub Input_Connector()
'---------------------------
  Dim r As Long, Res As Boolean
  r = ActiveCell.Row
  If UserForm_Connector.Start(Cells(r, Dist_Nr_Col), Cells(r, Conn_Nr_Col)) Then
     Application.EnableEvents = False
     Cells(r, Conn_Nr_Col + 1).Select
     Application.EnableEvents = True
    
     If MsgBox("Im folgenden Dialog wird die Funktion ausgew|fffd|hlt welche mit dieser Zeile verkn|fffd|pft ist. " & _
               "Je nach Funktion m|fffd|ssen weitere Parameter angegeben werden.", vbOKCancel, "Fast geschafft") = vbOK Then
        
        If SelectMacros() Then
           If Ask_Input_NextRow Then
              Ask_Input_NextRow = False
              Cells(r + 1, DCC_or_CAN_Add_Col + SX_Channel_Col).Select
              If MsgBox("Eingabe einer weiteren Zeile?", vbYesNo + vbQuestion, "N|fffd|chste Zeile Eingeben") = vbYes Then
                 Input_NextRow = True
              End If
           End If
        End If
     End If
  End If
End Sub
Attribute VB_Name = "M06_Write_Headder"
Option Explicit

Private AddrList() As Long
Private LocInChNr As Long
Private Ext_AddrTxt As String
Private InChTxt As String
Private ConfigTxt As String
Private Err As String
Private Channel As Long
Private LedNr As Long
Private AddrComment As String
Private Start_Values As String

'---------------------------------------
Public Sub Init_HeadderFile_Generation()
'---------------------------------------
  Erase AddrList
  Make_sure_that_Col_Variables_match
  LocInChNr = 0
  Ext_AddrTxt = ""
  InChTxt = ""
  ConfigTxt = ""
  Err = ""
  Channel = 0
  LedNr = 0
  AddrComment = ""
  Start_Values = ""
End Sub

'------------------------------------------------------
Private Function AddressExists(Addr As Long) As Boolean
'------------------------------------------------------
  Dim a As Variant
  ' ToDo: |fffd|berlappungen pr|fffd|fen wenn InCnt > 1
  If Not IsArrayEmpty(AddrList) Then
        For Each a In AddrList
            If a = Addr Then
               AddressExists = True
               Exit Function
            End If
        Next a
        ReDim Preserve AddrList(UBound(AddrList) + 1)
  Else: ReDim Preserve AddrList(0)
  End If
  
  AddrList(UBound(AddrList)) = Addr
End Function

'-------------------------------------------------------------------------------------
Private Function AddressRangeExists(Addr As Long, cnt As Long, ByVal InpTyp As String)
'-------------------------------------------------------------------------------------
' If the InpTyp is a button (Red / Green) two virtual adresses are used.
' One for each button.
' For OnOff switches one address is used twice
' To destinguish the two cases the address is multiplied by 2 and 0/1 is added
'
  Dim Ad As Long, InpTypMod As Long, i As Long
  Select Case InpTyp
    Case "Rot":   InpTypMod = 1
    Case "Gr|fffd|n":  InpTypMod = 2
    Case "AnAus": InpTypMod = 3
    Case "Tast":  InpTypMod = 3
    Case Else: MsgBox "Internal Error: Unknown InpTyp in AddressRangeExists", vbCritical
               EndProg
  End Select
  Ad = Addr
  For i = 1 To cnt
      If InpTypMod And 1 Then
         If AddressExists(Ad * 2) Then
            AddressRangeExists = True
            Exit Function
         End If
      End If
      If InpTypMod And 2 Then
         If AddressExists(Ad * 2 + 1) Then
            AddressRangeExists = True
            Exit Function
         End If
      End If
      
      Select Case InpTypMod
         Case 1: InpTypMod = 2
         Case 2: InpTypMod = 1: Ad = Ad + 1
         Case 3: Ad = Ad + 1
      End Select
  Next i
End Function

'---------------------------------------------------------------
Public Function Get_Next_Typ(ByVal Inp_Typ As String) As String
'---------------------------------------------------------------
  Select Case Inp_Typ
     Case "AnAus": Get_Next_Typ = "AnAus"
     Case "Rot":   Get_Next_Typ = "Gr|fffd|n"
     Case "Gr|fffd|n":  Get_Next_Typ = "Rot"
     Case "Tast":  Get_Next_Typ = "Tast"
     Case Else:    MsgBox "Internal error: Undefined Inp_Typ: '" & Inp_Typ & "' in Get_Next_Typ()", vbCritical, "Internal error in Get_Next_Typ()"
                   EndProg
  End Select
End Function

'----------------------------------------------------------------------------------
Private Function Gen_Address_Define_Name(ByVal Addr As Long, ByVal InTyp As String)
'----------------------------------------------------------------------------------
  If Page_ID = "Selectrix" Then
        Gen_Address_Define_Name = "INCH_SX_" & Int(Addr / 8) & "_" & (Addr Mod 8) + 1 & Replace(Mid(Get_Typ_Const(InTyp), 2, 255), ",", "")
  Else: Gen_Address_Define_Name = "INCH_" & Page_ID & "_" & Addr & Replace(Mid(Get_Typ_Const(InTyp), 2, 255), ",", "")
  End If
End Function


'-------------------------------------------------------------------------------------------------------------------------------
Private Function Generate_Define_Line(ByVal Addr As Long, Row As Long, ByVal Channel As Long, ByVal Comment As String) As String
'-------------------------------------------------------------------------------------------------------------------------------
' Generate defines for the input channels for expert users
Const COMMENT_DEFINE = "   // "
 Dim Name As String, i As Long, InTyp As String
 InTyp = Cells(Row, Inp_Typ_Col)
 For i = 1 To Cells(Row, InCnt___Col)
    'Name = "INCH_" & Page_ID & "_" & Addr & Replace(Mid(Get_Typ_Const(InTyp), 2, 255), ",", "")
    Name = Gen_Address_Define_Name(Addr, InTyp)
    Generate_Define_Line = Generate_Define_Line & "#define " & AddSpaceToLen(Name, 22) & "  " & AddSpaceToLen(Channel, 4) & COMMENT_DEFINE & Comment & vbCr
    If InTyp <> "Rot" Then Addr = Addr + 1
    InTyp = Get_Next_Typ(InTyp)
    Channel = Channel + 1
    Comment = "    """
 Next i
End Function

'----------------------------------------------------
Private Function Get_Description(r As Long) As String
'----------------------------------------------------
  Get_Description = Trim(Cells(r, Descrip_Col))
  If Get_Description = "" Then Get_Description = Cells(r, Config__Col)
  Get_Description = Replace(Get_Description, vbLf, "| ")
End Function

'-----------------------------------------------------------------------------------------------------------------------------------
Private Function Generate_Config_Line(LedNr As Long, ByVal Channel As String, r As Long, Config_Col As Long, Addr As Long) As String
'-----------------------------------------------------------------------------------------------------------------------------------
' ToDo: Add checks like
' - open/closing braket test
' - characters after #LED, #InCh
  Dim Txt As String, lines As Variant, Line As Variant, Res As String, AddDescription As Boolean, Description As String
  Txt = Cells(r, Config_Col)
  If Trim(Txt) = "" Then Exit Function
  lines = Split(Txt, vbLf)
  Description = Get_Description(r)
#If 0 Then
  Description = Trim(Cells(r, Descrip_Col))
  If Description = "" Then Description = Cells(r, Config__Col)
  Description = Replace(Description, vbLf, "| ")
#End If
  AddDescription = Description <> ""
  For Each Line In lines ' Multible lines in one cell are possible
      Dim CommentStart As Long, cmd As String, Comment As String
      Comment = ""
      cmd = ""
      CommentStart = InStr(Line, "//")
      If CommentStart = 0 Then
         cmd = Line
      ElseIf CommentStart = 1 Then
         Comment = Line
      Else
         cmd = Left(Line, CommentStart)
         Comment = Mid(Line, CommentStart + 1, 1000)
      End If
      cmd = Replace(cmd, "#LED", LedNr)
      
      If Addr >= 0 Or Addr = -2 Then ' Valid address or INCH_ define
            cmd = Replace(cmd, "#InCh", Channel)
      Else: cmd = Replace(cmd, "#InCh", "SI_1")
      End If
      
      If InStr(cmd, "#LocInCh") > 0 Then
         If Cells(r, LocInCh_Col) = 0 Then
            MsgBox "Interner Fehler: 'Loc InCh' ist 0 oder leer in Zeile " & r, vbCritical, "Interner Fehler"
            EndProg
         End If
         cmd = Replace(cmd, "#LocInCh", "LOC_INCH" & LocInChNr)
         LocInChNr = LocInChNr + Cells(r, LocInCh_Col)
      End If
      
      cmd = "  " & cmd & Comment
      If AddDescription Then
                                    cmd = AddSpaceToLen(cmd, 109) & " // " & Description
      ElseIf Description <> "" Then
                                    cmd = AddSpaceToLen(cmd, 109) & " //     """
      End If
      AddDescription = False
      Res = Res & cmd & vbCr
  Next Line
  
  Generate_Config_Line = Res
End Function

'----------------------------------------------------------------
Private Function Get_Typ_Const(ByVal Inp_Typ As String) As String
'----------------------------------------------------------------
  Select Case Inp_Typ
     Case "AnAus": Get_Typ_Const = "S_ONOFF,"
     Case "Rot":   Get_Typ_Const = "B_RED,  "
     Case "Gr|fffd|n":  Get_Typ_Const = "B_GREEN,"
     Case "Tast":  Get_Typ_Const = "B_TAST, "
     Case Else:    MsgBox "Internal error: Undefined Inp_Typ: '" & Inp_Typ & "' in Get_Typ_Const()", vbCritical, "Internal error in Get_Typ_Const()"
                   EndProg
  End Select
End Function

'------------------------------------------------
Private Sub Add_to_Err(r As Range, Txt As String)
'------------------------------------------------
  If Err = "" Then r.Select ' Marc the first error location
  Err = Err & Txt & vbCr
End Sub

'--------------------------------------------------------------------------------------------
Private Sub Add_Start_Value_Line(r As Long, Mask As Long, Pos As Long, Description As String)
'--------------------------------------------------------------------------------------------
  Start_Values = Start_Values & AddSpaceToLen("  MobaLedLib.Set_Input(" & Channel + Pos & ", 1);", 109) _
                 & " // " & Description & vbCr
End Sub


'----------------------------------------------
Private Sub Create_Start_Value_Entry(r As Long)
'----------------------------------------------
  Dim sv As Long, i As Long, Mask As Long
  sv = Val(Cells(r, Start_V_Col))
  If sv = 0 Then Exit Sub
  If sv < 0 Then Add_to_Err Cells(r, Start_V_Col), "Negativer Startwert in Zeile " & r
  Dim Description As String
  Description = Get_Description(r)
  Mask = 1
  For i = 0 To Val(Cells(r, InCnt___Col)) - 1
    If (sv And Mask) > 0 Then
       Add_Start_Value_Line r, Mask, i, Description
       Description = "   """
    End If
    Mask = Mask * 2
  Next
  If sv > Mask - 1 Then Add_to_Err Cells(r, Start_V_Col), "Startwert in Zeile " & r & " ist zu gro|fffd|. Maximal m|fffd|glicher Wert: " & Mask - 1
End Sub

'----------------------------------------------------------------------------------------------
Public Function Create_Headder_Entry(r As Long, Addr As Long) As Boolean
'----------------------------------------------------------------------------------------------
Const ADDR_BORDER = "           { "
Const COMMENT_START = "      // "
  
  Dim Comment As String
  Comment = Get_Description(r)
#If 0 Then
  Comment = Cells(r, Descrip_Col)
  If Comment = "" Then Comment = Cells(r, Config__Col)
  Comment = Replace(Comment, vbLf, "| ")
#End If
  Dim AddrTxt_Line As String, Inp_Typ As String, InCnt As Long, Channel_or_define As String
  InCnt = Cells(r, InCnt___Col)
  If Addr >= 0 Then
     Dim Inp_TypR As Range: Set Inp_TypR = Cells(r, Inp_Typ_Col)
     Complete_Typ Inp_TypR, True ' Check Inp_Typ. If not valid call the dialog
     If Inp_TypR = "" Then
        Exit Function
     End If
     
     If AddressRangeExists(Addr, InCnt, Inp_TypR) Then
           Channel_or_define = Gen_Address_Define_Name(Addr, Inp_TypR)
           If InStr(InChTxt, Channel_or_define) = 0 Then
              Add_to_Err Cells(r, Inp_Typ_Col), "Die Adresse '" & Addr & "' in Zeile " & r & " wird bereits mit einem anderen Typ benutzt."
           End If
           Addr = -2
     Else: Channel_or_define = Channel
     End If
     
  End If
  If Cells(r, LED_Nr__Col) <> "" Then
     LedNr = Cells(r, LED_Nr__Col)
  End If
  ' Entry for the configuration array which contains the macros
  ConfigTxt = ConfigTxt & Generate_Config_Line(LedNr, Channel_or_define, r, Config__Col, Addr)
  
  If Addr >= 0 Then
     ' Defines for expert users and duplicate adresses
     InChTxt = InChTxt & Generate_Define_Line(Addr, r, Channel, Comment)
    
     ' Definition of the array with the external adresses
     AddrTxt_Line = ADDR_BORDER & AddSpaceToLen(Addr, 5)
     AddrTxt_Line = AddrTxt_Line & "+ " & Get_Typ_Const(Inp_TypR) & " " & AddSpaceToLen(InCnt, 2) & "},"
     Ext_AddrTxt = Ext_AddrTxt & AddrTxt_Line & COMMENT_START
     If AddrComment <> "" Then Ext_AddrTxt = Ext_AddrTxt & AddSpaceToLen(AddrComment, 10)
     Ext_AddrTxt = Ext_AddrTxt & Comment & vbCr
     
     Create_Start_Value_Entry r
    
     ' Calculate the next input channel number
     With Cells(r, InCnt___Col)
        If .Value <> "" Then
           If Not IsNumeric(.Value) Or .Value < 0 Or .Value > 100 Then
                 .Select
                 MsgBox "Fehler: Eintrag '" & .Value & "' in InCnt Spalte ist ung|fffd|ltig", vbCritical, "Falscher InCnt Eintrag"
                 EndProg
           Else: Channel = Channel + .Value  ' ToDo: Unterst|fffd|tzung f|fffd|r mehrere Zeilen in einer Zelle ?
           End If
        End If
     End With
  End If
  Create_Headder_Entry = True
End Function

'------------------------------
Public Sub Create_HeadderFile()
'------------------------------
  Make_sure_that_Col_Variables_match
  
  Init_HeadderFile_Generation
  
  Dim r As Long, sx As Boolean, SX_Ch As Long
  sx = Page_ID = "Selectrix"
  For r = FirstDat_Row To LastUsedRow
     If Not Rows(r).EntireRow.Hidden And Cells(r, Enable_Col) <> "" Then
        Dim Addr As Variant
        
        If sx Then ' *** Selectrix ***
            Dim Bit_P As Variant
            Bit_P = Cells(r, SX_Bitposi_Col)
            Addr = -1
            If Bit_P <> "" And Val(Cells(r, InCnt___Col)) > 0 Then
               If Cells(r, SX_Channel_Col) <> "" Then SX_Ch = Get_First_Number_of_Range(r, SX_Channel_Col) ' ToDo: SX_Ch wird nur dann aktualisiert wenn Bit pos vorhanden ist und InCnt > 0. Ist das gut ?
               If SX_Ch >= 0 And SX_Ch <= 99 Then
                  If Bit_P >= 1 And Bit_P <= 8 Then
                     Addr = SX_Ch * 8 + Bit_P - 1
                     AddrComment = "SX " & AddSpaceToLenLeft(SX_Ch, 2) & "," & Bit_P & ": "
                  Else:   Add_to_Err Cells(r, SX_Bitposi_Col), "Wrong bitpos "" & bp & "" in row " & r
                  End If
               Else:      Add_to_Err Cells(r, SX_Channel_Col), "Wrong SX channel in row " & r
               End If
            End If
        Else ' *** DCC or CAN ***
            Dim MaxAddr As Long
            If Page_ID = "DCC" Then
                  MaxAddr = 10240 ' Attention some stations only support adresses up to 9999 => Don't generate a warning. The central station will generate an error
            Else: MaxAddr = 65535 ' 2048? MS2 only 320 ?
            End If
            Addr = Get_First_Number_of_Range(r, DCC_or_CAN_Add_Col)
            If Addr = "" Or Val(Cells(r, InCnt___Col)) <= 0 Then
                 Addr = -1 ' No address given of InCnt <= 0 or empty
            ElseIf Addr >= 1 And Addr <= MaxAddr Then
                 ' Valid adress range
            Else: Add_to_Err Cells(r, DCC_or_CAN_Add_Col), "Die Adresse '" & Replace(Cells(r, DCC_or_CAN_Add_Col), vbLf, " ") & "' in Zeile row " & r & " ist ung|fffd|ltig."
            End If
        End If
  
        If Not Create_Headder_Entry(r, Val(Addr)) Then Exit Sub
    End If
  Next r
  
  Write_Headder_File
End Sub

'-------------------------------------------------------------------------------
Private Sub Create_Loc_InCh_Defines(ByRef Dest As String, ByRef Channel As Long)
'-------------------------------------------------------------------------------
  If LocInChNr > 0 Then
     Dest = Dest & vbCr & "// Local InCh variables" & vbCr
     Dim i As Long
     For i = 0 To LocInChNr - 1
         Dest = Dest & AddSpaceToLen("#define LOC_INCH" & i, 32) & Channel & vbCr
         Channel = Channel + 1
     Next i
  End If
End Sub

'----------------------------------------------------
Private Sub DelTailingEmptyLines(ByRef Txt As String)
'----------------------------------------------------
  While Right(Txt, 2) = vbCr & vbCr
    Txt = Left(Txt, Len(Txt) - 1)
  Wend
End Sub

'--------------------------------------------
Public Function Ext_AddrTxt_Used() As Boolean
'--------------------------------------------
  Ext_AddrTxt_Used = (Ext_AddrTxt <> "")
End Function


'------------------------------
Public Sub Write_Headder_File()
'------------------------------
  Const VK_CONTROL = &H11
  Dim Ctrl_Pressed As Boolean
  Ctrl_Pressed = GetAsyncKeyState(VK_CONTROL) <> 0  ' Following function must be declared: Public Declare Function GetAsyncKeyState Lib "user32" (ByVal vKey As Long) As Integer
  
  Dim NumLeds As Long
  NumLeds = Cells(SH_VARS_ROW, LED_Nr__Col)
  If NumLeds > 256 Then Err = Err & "Maximale LED Anzahl |fffd|berschritten: " & NumLeds & vbCr & _
                                    "Es sind maximal 256 RGB LEDs m|fffd|glich" & vbCr ' Don't check before to be able to temprory add more than 256 LES
  
  If Err <> "" Then
     MsgBox Err & vbCr & vbCr & _
            "New header file is not generated!", vbCritical, "Errors detected"
     Exit Sub
  End If
  
  Dim Name As String
  Name = ThisWorkbook.Path & "/" & Include_FileName
  Dim fp As Integer
  fp = FreeFile
  
  DelTailingEmptyLines Ext_AddrTxt
  DelTailingEmptyLines InChTxt
  
  Create_Loc_InCh_Defines InChTxt, Channel
  
  If Channel > 250 Then
     MsgBox "Fehler: Die Anzahl der verwendeten Eingangskan|fffd|le ist zu gro|fffd|!" & vbCr & _
            "Es sind maximal 250 verf|fffd|gbar. Die Konfiguration enth|fffd|lt aber " & Channel - 1 & "." & vbCr & _
            vbCr & _
            "Die Eingangskan|fffd|le werden zum einlesen von DCC, Selectrix und CAN Daten benutzt. " & vbCr & _
            "Au|fffd|erdem werden sie als interne Zwischenspeicher ben|fffd|tigt.", vbCritical, "Anzahl der InCh Variablen |fffd|berschritten"
     EndProg
  End If
  
  Dim ShortPath As String, p As Long
  p = InStrRev(ThisWorkbook.Path, "\")
  If p = 0 Then p = InStrRev(ThisWorkbook.Path, "/")
  If p > 0 Then ShortPath = Mid(ThisWorkbook.Path, p + 1, 255) & " "
  
  On Error GoTo WriteError
  Open Name For Output As #fp
  Print #fp, "// This file contains the " & Page_ID & " and LED definitions."
  Print #fp, "//"
  Print #fp, "// It was automatically generated by the program " & ThisWorkbook.Name & " " & Prog_Version & "      by Hardi"
  Print #fp, "// File creation: " & Date & " " & time
  Print #fp, "// (Attention: The display in the Arduino IDE is not updated if Options/External Editor is disabled)"
  Print #fp, ""
  Print #fp, "#ifndef __EXT_ADDR_DESC_H__"
  Print #fp, "#define __EXT_ADDR_DESC_H__"
  Print #fp, ""
  Print #fp, "#define START_MSG ""LEDs_AutoProg Ver 1: " & ShortPath & Format(Date, "dd.mm.yy") & " " & Format(time, "hh:mm") & """" ' The version could be read out in a future version of this tool
  Print #fp, ""
  If Page_ID = "Selectrix" Then
         Print #fp, "#define TWO_BUTTONS_PER_ADDRESS 0      // One button is used (Selectrix)"
  Else:  Print #fp, "#define TWO_BUTTONS_PER_ADDRESS 1      // Two buttons (Red/Green) are used (DCC/CAN)"
  End If
  Print #fp, "#ifdef NUM_LEDS"
  Print #fp, "  #warning ""'NUM_LEDS' definition in the main program is replaced by the included '" & FileNameExt(Name) & "' with " & NumLeds & """"
  Print #fp, "  #undef NUM_LEDS"
  Print #fp, "#endif"
  Print #fp, ""
  Print #fp, "#define NUM_LEDS " & AddSpaceToLen(NumLeds, 22) & "// Number of LEDs (Maximal 256 RGB LEDs could be used)"
  Print #fp, ""
  
  ' Set HOUSE_MIN_T and HOUSE_MAX_T
  Dim House_Min_T As String                                                 ' 26.09.19:
  House_Min_T = Get_String_Config_Var("MinTime_House")
  If House_Min_T <> "" Then
        Print #fp, "#undef  HOUSE_MIN_T"
        Print #fp, "#define HOUSE_MIN_T  " & Val(House_Min_T)
  Else: House_Min_T = 50 ' Default value used in the library
  End If
  Dim House_Max_T As String
  House_Max_T = Get_String_Config_Var("MaxTime_House")
  If House_Max_T <> "" Then
     Print #fp, "#undef  HOUSE_MAX_T"
     Print #fp, "#define HOUSE_MAX_T " & Val(House_Max_T)
  Else: House_Max_T = 150 ' Default value used in the library
  End If
  If Val(House_Min_T) > Val(House_Max_T) Or Val(House_Max_T) = 0 Then
     Sheets(ConfigSheet).Select
     Range("MinTime_House").Select
     Sleep 100
     MsgBox "Fehler auf der 'Config' Seite:" & vbCr & _
            "Die 'Minimale Zeit bis zur n|fffd|chsten |fffd|nderung' muss kleiner " & _
            "oder gleich gro|fffd| wie die Maximale Zeit sein." & vbCr & _
            "Achtung: Wenn nichts eingegeben ist werden die Standard Werte vom 50/150 verwendet. " & _
            "Dadurch kann es ebenfalls zu einem Konflikt kommen.", vbCritical, "Falsche Zeiten f|fffd|r die House() Funktion"
     EndProg
  End If
  
  Print #fp, ""
  
  
  If Ext_AddrTxt_Used() Then
    Print #fp, "#define USE_EXT_ADDR"
    
    If InStr(Prog_for_Right_Ardu, " " & Page_ID & " ") > 0 Then
       Print #fp, "#define USE_RS232_AS_INPUT"
    End If
    
    ' Set DCC Offset                                                        ' 26.09.19:
    If Page_ID = "DCC" Then
          Print #fp, "#define ADDR_OFFSET " & Val(Get_String_Config_Var("DCC_Offset"))
    Else: Print #fp, "#define ADDR_OFFSET 0"
    End If
    
    If Page_ID = "CAN" Then
       Print #fp, "#define USE_CAN_AS_INPUT"
    End If
    
    Print #fp, ""
    Print #fp, "#define ADDR_MSK  0x3FFF  // 14 Bits are used for the Address"
    Print #fp, ""
    Print #fp, "#define S_ONOFF   (uint16_t)0"
    Print #fp, "#define B_RED     (uint16_t)(1<<14)"
    Print #fp, "#define B_GREEN   (uint16_t)(2<<14)"
    Print #fp, "#define B_RESERVE (uint16_t)(3<<14)    // Not used at the moment"
    Print #fp, "#define B_TAST    B_RED"
    Print #fp, ""
    Print #fp, ""
    Print #fp, "typedef struct"
    Print #fp, "    {"
    Print #fp, "    uint16_t AddrAndTyp; // Addr range: 0..16383. The upper two bytes are used for the type"
    Print #fp, "    uint8_t  InCnt;"
    Print #fp, "    } Ext_Addr_T;"
    Print #fp, ""
    Print #fp, "// Definition of external adresses" & vbCr & _
               "const PROGMEM Ext_Addr_T Ext_Addr[] =" & vbCr & _
               "         { // Addr & Typ    InCnt"
    Print #fp, Ext_AddrTxt;
    Print #fp, "         };"
    Print #fp, ""
    Print #fp, ""
  End If ' Ext_AddrTxt <> ""
  Print #fp, "// Input channel defines for local inputs and expert users" ' 05.10.19: Moved out of the if because the local inputs are also stored here
  Print #fp, InChTxt
  Print #fp, ""
  Print #fp, ""
  Print #fp, "//*******************************************************************"
  Print #fp, "// *** Configuration array which defines the behavior of the LEDs ***"
  Print #fp, "MobaLedLib_Configuration()"
  Print #fp, "  {"
  Print #fp, ConfigTxt
  Print #fp, "  EndCfg // End of the configuration"
  Print #fp, "  };"
  Print #fp, "//*******************************************************************"
  Print #fp, ""
  Print #fp, "//---------------------------------------------"
  Print #fp, "void Set_Start_Values(MobaLedLib_C &MobaLedLib)"
  Print #fp, "//---------------------------------------------"
  Print #fp, "{"
  Print #fp, Start_Values;
  Print #fp, "}"
  Print #fp, ""
  Print #fp, ""
  Print #fp, ""
  Print #fp, ""
  Print #fp, ""
  Print #fp, ""
  Print #fp, "#endif // __EXT_ADDR_DESC_H__"
  
  Close #fp
  On Error GoTo 0
  
  If ConfigTxt = "" Then
     MsgBox "Achtung: Es ist keine einzige Zeile in der Spalte ""Beleuchtung, Sound, oder andere Effekte"" aktiv!" & vbCr & _
            "=> Das Programm wird keine LEDs ansteuern", vbCritical, "Achtung: Die Konfiguration ist leer"
     UserForm_Header_Created.DontShowAgain = False
  End If
  
  Show_Status_for_a_while time & ": Header file '" & Name & "' created"
  
  If Ctrl_Pressed Then UserForm_Header_Created.DontShowAgain = False
  
  If UserForm_Header_Created.DontShowAgain = False Then
        UserForm_Header_Created.FileName = Name
        UserForm_Header_Created.Show
  Else: Compile_and_Upload_LED_Prog_to_Arduino
  End If
  Exit Sub
  
WriteError:
  MsgBox "Fehler beim schreiben der Datei '" & Name & "'", vbCritical, "Fehler beim erzeugen der Arduino Headder Datei"
  
End Sub


Attribute VB_Name = "M07_COM_Port"
Option Explicit


'-------------------------
Private Sub Test_Get_COM()
'-------------------------
  MsgBox F_shellExec("cmd /c mode") ' | find ""COM""")
End Sub


'------------------------------------------
Private Function Get_USB_Ports() As Variant
'------------------------------------------
' The function returns an long array with COM numbers
' COM-1 is allways added because otherwise the array may be empty if no other com port is detected
  Dim Res As String, lines As Variant
  Res = F_shellExec("cmd /c mode | find ""COM""") ' Achtung: Der Mode Befehl schickt einen Reset zu allen Ports

  'res = "Status von Ger|fffd|t COM3:" ' Debug with one line
  If Res = "" Then ' No COM port available ?
     Res = F_shellExec("cmd /c mode")
     If InStr(Res, "CON") = 0 Then
        MsgBox "Fehler: Das Abfragen der COM Ports ist fehlgeschlagen ;-(", vbCritical, "Fehler beim abfragen der COM Ports"
        EndProg
     End If
     Res = ""
  End If
  Res = Replace(Res, ":", "")
  Res = Res & " COM-10" & vbCr ' Add one line to because otherwise split fails if only one line exists
  lines = Split(Res, vbCr)
  
  Dim i As Long, p As Long, ResStr As String, cnt As Long
  For i = 0 To UBound(lines)
     p = InStr(lines(i), "COM")
     If p > 0 Then
        ResStr = ResStr & Trim(Mid(lines(i), p + Len("COM"), 255)) & " "
        cnt = cnt + 1
     End If
  Next
  ResStr = DelLast(ResStr)
  Dim ResSplit As Variant
  ResSplit = Split(ResStr, " ")
  Dim ResArray() As Long
  ReDim ResArray(cnt - 1)
  For i = 0 To cnt - 1
     ResArray(i) = Val(ResSplit(i))
  Next
  Get_USB_Ports = ResArray
End Function


'---------------------------------------------------------------------
Public Function Detect_Com_Port(Optional RightSide As Boolean) As Long
'---------------------------------------------------------------------
  Dim Retry As Boolean
  Dim Side As String
  If RightSide Then
        Side = "rechte"
  Else: Side = "linke"
  End If
  Dim LED_not_Light_txt As String
  If Page_ID <> "CAN" Then LED_not_Light_txt = "(Dann sollten, anders als auf dem Bild gezeigt, auch keine LEDs auf der Platine leuchten.)"
  
  Do
    If "MiddleButton" = UserForm_USB_Connection.ShowForm("Erkennung des USB Anschlusses", _
                                 "Schritt 1:" & vbCr & _
                                 vbCr & _
                                 "Zur Erkennung des USB Anschlusses darf der Arduino zun|fffd|chst " & _
                                 "NICHT am PC angeschlossen sein." & vbCr & _
                                 vbCr & _
                                 "Wenn keine Verbindung vom Arduino zum PC besteht OK bet|fffd|tigen." & vbCr & _
                                 vbCr & _
                                 vbCr & _
                                 LED_not_Light_txt, _
                                 False, False, False, _
                                 "P Pr|fffd|fen", "A Abbrechen", "O OK", _
                                 "Keine Verbindung zum PC", "USB Verbindung erkennen") Then Exit Function
                                            
    Dim WithoutArduino As Variant
    WithoutArduino = Get_USB_Ports()
    
    
    If "MiddleButton" = UserForm_USB_Connection.ShowForm("Erkennung des USB Anschlusses", _
                                 "Schritt 2:" & vbCr & _
                                 vbCr & _
                                 "Jetzt muss der " & Side & " Arduino an den PC angeschlossen werden." & vbCr & _
                                 vbCr & _
                                 "Wenn der Arduino mit dem PC verbunden ist OK bet|fffd|tigen." & vbCr & _
                                 vbCr & _
                                 "Meistens ert|fffd|nt ein Klang wenn der PC den neu angeschlossenen " & _
                                 "Rechner erkannt hat.", _
                                 False, Not RightSide, RightSide, _
                                 "P Pr|fffd|fen", "A Abbrechen", "O OK", _
                                 "Jetzt mit PC verbinden", "USB Verbindung erkennen") Then Exit Function
    
    Dim WithArduino As Variant
    WithArduino = Get_USB_Ports()
    
    If UBound(WithArduino) <= UBound(WithoutArduino) Then
        Dim Msg As String
        If UBound(WithArduino) < UBound(WithoutArduino) Then
               Msg = "Im Schritt 2 wurden weniger Anschl|fffd|sse als in Stritt 1 entdeckt ;-(" & vbCr & _
                     vbCr & _
                     "Kann es sein, dass der Arduino versehentlich bei Schritt 1 angeschlossen und " & _
                     "bei Schritt 2 nicht mehr angeschlossen war ?" & vbCr & _
                     vbCr & _
                     "Wollen Sie es nochmal versuchen?"
        Else:  Msg = "Es wurde kein Arduino entdeckt ;-(" & vbCr & _
                      vbCr & _
                      "Evtl. ist der Arduino, das Kabel oder der USB Anschluss defekt." & vbCr & _
                      vbCr & _
                      "Wollen Sie es nochmal mit anderen Komponenten und anderem USB Anschluss versuchen?"
        End If
        Retry = (MsgBox(Msg, vbQuestion + vbYesNo, "Kein Arduino erkannt") = vbYes)
    Else
        Dim i As Long, j As Long, Found As Boolean
        For i = 0 To UBound(WithArduino)
            Found = False
            For j = 0 To UBound(WithoutArduino)
                If WithArduino(i) = WithoutArduino(j) Then
                   Found = True
                   Exit For
                End If
            Next j
            If Not Found Then
               Detect_Com_Port = WithArduino(i)
               MsgBox "Der Arduino ist an COM" & Detect_Com_Port & " angeschlossen." & vbCr & _
                      vbCr & _
                      "W|fffd|hrend dieser Sitzung wird der " & Side & " Arduino |fffd|ber diesen Anschluss angesprochen.", _
                      vbInformation, "Arduino erkannt an COM" & Detect_Com_Port
               Exit Function
            End If
        Next i
        MsgBox "Interner Fehler: Kein neuer USB Port gefunden", vbCritical, "Interner Fehler"
        EndProg
    End If
  Loop While Retry
End Function

'-----------------------------------------------------------
Public Sub Detect_Com_Port_and_Save_Result(Right As Boolean)
'-----------------------------------------------------------
  Dim ComPortColumn As Long
  If Right Then
        ComPortColumn = COMPrtR_COL
  Else: ComPortColumn = COMPort_COL
  End If
  
  Dim Port As Long
  Port = Detect_Com_Port(Right)
  If Port > 0 Then
     Cells(SH_VARS_ROW, ComPortColumn) = Port
  End If
End Sub



'UT------------------------------
Private Sub TestDetect_Com_Port()
'UT------------------------------
  Detect_Com_Port True
End Sub

'----------------------------------------------------------------
Public Function USB_Port_Dialog(ComPortColumn As Long) As Boolean
'----------------------------------------------------------------
' Return true if the Port is valid
  Dim Port As Long, Detect As Boolean
  Port = Val(Cells(SH_VARS_ROW, ComPortColumn))
  Dim ArduName As String, RightSide  As Boolean
  If ComPortColumn = COMPort_COL Then
        ArduName = "LED":   RightSide = False
  Else: ArduName = Page_ID: RightSide = True
  End If
  
  If Port = 0 Then
        Select Case MsgBox("Der USB Port an den der " & ArduName & " Arduino angeschlossen ist wurde noch nicht festgelegt." & vbCr & _
                           vbCr & _
                           "Soll der Port jetzt gesucht werden?", vbQuestion + vbYesNo, "USB Port f|fffd|r " & ArduName & " Arduino festlegen")
               Case vbYes: Detect = True ' Detect the Port
               Case vbNo:  ' Return false at the end
        End Select
  Else  ' Com Port already defined. Check it ?
        Select Case UserForm_USB_Connection.ShowForm("Letzten USB Port wieder benutzen ?", _
                           "Der Arduino war beim letzten Mal an Port COM" & Abs(Port) & " angeschlossen." & vbCr & _
                           vbCr & _
                           "Soll |fffd|berpr|fffd|ft werden ob dieser Anschluss immer noch g|fffd|ltig ist ?" & vbCr & _
                           vbCr & _
                           "Pr|fffd|fen: Der USB Anschluss wird |fffd|berpr|fffd|ft. Dazu muss der Arduino im Folgenden " & _
                           "Dialog Ab- und Angesteckt werden." & vbCr & _
                           vbCr & _
                           "|fffd|bernehmen: Der Anschluss wird ohne Pr|fffd|fung |fffd|bernommen und w|fffd|hrend " & _
                           "dieser Sitzung immer verwendet.", _
                           True, Not RightSide, RightSide, _
                           "P Pr|fffd|fen", "A Abbrechen", "B |fffd|bernehmen", _
                           "Letzte Verbindung zum PC: COM" & Abs(Port), "|fffd|berpr|fffd|fung des zuletzt benutzten USB Anschlusses")
                           
              Case "LeftButton":      Detect = True
              Case "MiddleButton":    ' Return false at the end
              Case "RightButton":     ' Use the last port
                                      Cells(SH_VARS_ROW, ComPortColumn) = Abs(Port)
                                      USB_Port_Dialog = True
        End Select
  End If
  
  If Detect Then
     Port = Detect_Com_Port(RightSide)
     If Port > 0 Then
           Cells(SH_VARS_ROW, ComPortColumn) = Port
           USB_Port_Dialog = True
     Else: Cells(SH_VARS_ROW, ComPortColumn) = -Abs(Val(Cells(SH_VARS_ROW, ComPortColumn)))   ' Old value, but mark it as invalid
     End If
  End If
End Function


'-----------------------------------------------------------
Public Sub Check_USB_Port_with_Dialog(ComPortColumn As Long)
'-----------------------------------------------------------
  If Val(Cells(SH_VARS_ROW, ComPortColumn)) <= 0 Then
     If USB_Port_Dialog(ComPortColumn) = False Then EndProg
  End If
End Sub


Attribute VB_Name = "M08_Aruino"
Option Explicit

' Die MobaLedLib wird nur dann Installiert wenn sie nicht vorhanden ist
' - Das Excel sheet w|fffd|rde sich selber |fffd|berschreiben

' Comma separeted list of libraries (Case sensitive => check the library.property file
' The MCP_CAN lib can't be installed from the IDE because
'  - it's not available in the library manager
'  - the debug mode is enabled in the version on GitHub
' => It's included to the program directory



'UT-----------------------------------------
Private Function Find_ArduinoExe() As String
'UT-----------------------------------------
  Const ARDUINO_EXE = "arduino_debug.exe"
  Const Dirs = "  C:\Program Files (x86)\Arduino\" & ARDUINO_EXE & vbCr & _
               "  C:\Program Files\Arduino\" & ARDUINO_EXE
  Dim FileName As Variant
  For Each FileName In Split(Dirs, vbCr)
      FileName = Trim(FileName)
      If Dir(FileName) <> "" Then
         Find_ArduinoExe = FileName
         Exit Function
      End If
  Next
  If MsgBox("Fehler: Die Arduino Entwicklungsumgebung ist nicht oder nicht im Standard Verzeichnis installiert." & vbCr & _
         "Das Prorgamm mu|fffd| abh|fffd|ngig vom Betriebssystem hier installiert sein:" & vbCr & _
         Dirs & vbCr & _
         vbCr & _
         "Achtung: Die 'App' Version der Arduino IDE wird nicht unterst|fffd|tzt. " & vbCr & _
         "Es muss die 'Windows Installer, for Windows XP and up' Version installiert werden." & vbCr & _
         vbCr & _
         "Soll die Arduino Webseite ge|fffd|ffnet werden damit die richtige Version herunter geladen werden kann ?", vbCritical + vbYesNo, "Fehler: '" & ARDUINO_EXE & "' nicht gefunden") = vbYes Then
     Shell "Explorer ""https://www.arduino.cc/en/main/software"""
  End If

  EndProg
End Function


'---------------------------------------------------------------------------------------------------------------------------------------------
Private Function Create_Cmd_file(ResultName As String, COMPort As String, BuildOptions As String, InoName As String, Mode As String) As String
'---------------------------------------------------------------------------------------------------------------------------------------------
' Arduino start Parameters see:
'   https://github.com/arduino/Arduino/blob/master/build/shared/manpage.adoc
'   https://forum.arduino.cc/index.php?topic=550577.0
'   http://inotool.org/
  
' 26.09.19:
' Manchmal Spinnt der Compiler. Er erzeugt seltsame Fehlermeldungen:
'    " internal compiler error: Segmentation fault "
' Wenn der Fehler ein mal komm, dann muss irgend was am Programm ver|fffd|dert werden,
' dann geht es mei|fffd|tens wieder. Dann kann man die |fffd|nderung auch wieder r|fffd|ckg|fffd|ngig
' machen ohne das der Fehler wieder auftritt ;-(
'
' Wenn man das Verzeichnis "C:\Users\Hardi\AppData\Arduino_Build_23_B.LEDs_AutoProg"
' l|fffd|scht, dann geht es auch ohne |fffd|nderung am Programm.
'
' Das Weglassen des Kommandozeilenschalters "--preserve-temp-files" bringt nichts.

' Das Problem ist hier beschrieben:
'  https://github.com/arduino/Arduino/issues/8821
'  https://github.com/arduino/Arduino/issues/7949
' Im zweiten Post wird behauptet, dass der Fehler mit der Version 1.8.10 nicht mehr auftritt.
' Dummerweise produziert diese sehr viele Debug Meldungen.
'
' Ich habe jetzt mal das Neueste Board Paket f|fffd|r den Nano (1.8.1) Installiert. Mal schauen ob es
' jetzt besser ist. Dummerweise habe ich mir nicht gemerkt welches Board Paket ich vorher hatte.
' Es war irgend was mit 1.6?

  If Dir(ResultName) <> "" Then Kill ResultName
  
  Dim CommandStr As String, BuildDir As String
  
  #If 1 Then ' Use a separate Build directory. => Speed up 12 sec instead of 18
    BuildDir = Replace(Environ("APPDATA"), "Roaming", "") & "Arduino_Build_" & Replace(InoName, ".ino", "")
    If Dir(BuildDir & "\.") = "" Then
       On Error Resume Next ' In case the directory is created but empty
       MkDir BuildDir
       On Error GoTo 0
       'Debug.Print "BuildDir='" & BuildDir & "'"
    End If
  #End If
  
  ' Other options:  --verbose-build --verbose-upload"
  '   Boards  see: C:\Program Files (x86)\Arduino\hardware\arduino\avr\boards.txt
  '   New Bootloader: nano.menu.cpu.atmega328=ATmega328P
  
  CommandStr = """" & Find_ArduinoExe() & """ """ & InoName & """ --upload " & COMPort & " " & BuildOptions
  If BuildDir <> "" Then CommandStr = CommandStr & " --pref build.path=""" & BuildDir & """" & _
                                                   " --preserve-temp-files"
  Dim fp As Integer, Name As String
  
  fp = FreeFile
  Name = ThisWorkbook.Path & "\Start_Arduino.cmd"
  On Error GoTo WriteError
  Open Name For Output As #fp
  Print #fp, "@ECHO OFF"
  Print #fp, "REM This file was generated by '" & ThisWorkbook.Name & "'  " & time
  Print #fp, ""
  Print #fp, "ECHO    "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" """

Select Case Mode
  Case "Left":
          Print #fp, "ECHO    ""    Zum                                                                  """
          Print #fp, "ECHO    ""     PC                       MoBaLedLib  " & AddSpaceToLen(Prog_Version, 20) & " by Hardi  """
          Print #fp, "ECHO    ""      \\                                                                 """
          Print #fp, "ECHO    ""       \\                                                                """
          Print #fp, "ECHO    ""    ____\\___________________                                            """
          Print #fp, "ECHO    ""   |  | [_] | | [_] |[oo]    |  Achtung: Es muss der linke               """
          Print #fp, "ECHO    ""   |  |     | |     |        |  Arduino mit dem PC verbunden             """
          Print #fp, "ECHO    ""   |  |     | |     |        |  sein.                                    """
          Print #fp, "ECHO    ""   |  | LED | |     |        |                                           """
          Print #fp, "ECHO    ""   |  | Nano| |     |        |  Wenn alles gut geht, dann wird das       """
          Print #fp, "ECHO    ""   |  |     | |     |        |  Fenster ohne eine weitere Meldung        """
          Print #fp, "ECHO    ""   |  |     | |     |        |  geschlossen (Liest ja eh keiner).        """
          Print #fp, "ECHO    ""   |  |_____| |_____| [O]    |                                           """
          Print #fp, "ECHO    ""   |    [@] [@] [@]          |  Falls Probleme auftreten, dann wird      """
          Print #fp, "ECHO    ""   |__________________[:::]__|  das angezeigt.                           """
        
  Case "Right"
          Dim RightName As String
          Select Case Page_ID
             Case "DCC":       RightName = " DCC "
             Case "Selectrix": RightName = " S X "
             Case "Loconet":   RightName = "LocoN"
             Case Else:        MsgBox "Interner Fehler: Unbekante Page_ID: '" & Page_ID & "'", vbCritical, "Interner Fehler"
                               EndProg
          End Select
        
          Print #fp, "ECHO    ""            Zum                                                          """
          Print #fp, "ECHO    ""             PC               MoBaLedLib  " & AddSpaceToLen(Prog_Version, 20) & " by Hardi  """
          Print #fp, "ECHO    ""              \\                                                         """
          Print #fp, "ECHO    ""               \\                                                        """
          Print #fp, "ECHO    ""    ____________\\___________                                            """
          Print #fp, "ECHO    ""   |  | [_] | | [_] |[oo]    |  Achtung: Es muss der rechte              """
          Print #fp, "ECHO    ""   |  |     | |     |        |  Arduino mit dem PC verbunden             """
          Print #fp, "ECHO    ""   |  |     | |     |        |  sein.                                    """
          Print #fp, "ECHO    ""   |  |     | |" & RightName & _
                                                   "|        |                                           """
          Print #fp, "ECHO    ""   |  |     | | Nano|        |  Wenn alles gut geht, dann wird das       """
          Print #fp, "ECHO    ""   |  |     | |     |        |  Fenster ohne eine weitere Meldung        """
          Print #fp, "ECHO    ""   |  |     | |     |        |  geschlossen (Liest ja eh keiner).        """
          Print #fp, "ECHO    ""   |  |_____| |_____| [O]    |                                           """
          Print #fp, "ECHO    ""   |    [@] [@] [@]          |  Falls Probleme auftreten, dann wird      """
          Print #fp, "ECHO    ""   |__________________[:::]__|  das angezeigt.                           """
  
  
  Case "CAN"
          Print #fp, "ECHO    ""    Zum                                                                  """
          Print #fp, "ECHO    ""     PC                       MoBaLedLib  " & AddSpaceToLen(Prog_Version, 20) & " by Hardi  """
          Print #fp, "ECHO    ""      \\                                                                 """
          Print #fp, "ECHO    ""       \\                                                                """
          Print #fp, "ECHO    ""    ____\\___________________                                            """
          Print #fp, "ECHO    ""   |  | [_] |O _________    _|  Achtung: Es muss wird nur der linke      """
          Print #fp, "ECHO    ""   |  |     | |         |  |C|  Arduino und ein MCP2515 CAN Modul        """
          Print #fp, "ECHO    ""   |  |     | | MCP2515 |  |A|  verwendet.                               """
          Print #fp, "ECHO    ""   |  | LED | |   CAN   |  |N|                                           """
          Print #fp, "ECHO    ""   |  | Nano| |  Modul  |   ~|  Wenn alles gut geht, dann wird das       """
          Print #fp, "ECHO    ""   |  |     | |_________|    |  Fenster ohne eine weitere Meldung        """
          Print #fp, "ECHO    ""   |  |     |                |  geschlossen (Liest ja eh keiner).        """
          Print #fp, "ECHO    ""   |  |_____|         [O]    |                                           """
          Print #fp, "ECHO    ""   |    [@] [@] [@]          |  Falls Probleme auftreten, dann wird      """
          Print #fp, "ECHO    ""   |__________________[:::]__|  das angezeigt.                           """
End Select
    
  Print #fp, "ECHO    ""                                                                         """
  Print #fp, "ECHO    "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" """
  Print #fp, ""
  Print #fp, "ECHO|SET /p=""Verzeichnis: """ ' Echo without linefeed
  Print #fp, "CD" ' show the current directory for debugging
  Print #fp, ""
  Print #fp, CommandStr
  Print #fp, "ECHO."
  Print #fp, ""
  Print #fp, "IF ERRORLEVEL 1 (" ' Check if ERRORLEVEL >= 1
  Print #fp, "   ECHO Start_Arduino_Result: %ERRORLEVEL% > """ & ResultName & """"
  Print #fp, "   ECHO   **********************************"
  Print #fp, "   ECHO   * Da ist was schief gegangen ;-( *            ERRORLEVEL %ERRORLEVEL%"
  Print #fp, "   ECHO   **********************************"
  Print #fp, "   Pause"
  Print #fp, "   )"
  Close #fp
  On Error GoTo 0
  
  Create_Cmd_file = Name
  Exit Function

WriteError:
  MsgBox "Fehler beim schreiben der Datei '" & Name & "'", vbCritical, "Fehler beim erzeugen der Arduino Start Datei"

End Function


'--------------------------------------------------------------------------------------------------------------------------------
Public Sub Compile_and_Upload_Prog_to_Arduino(InoName As String, ComPortColumn As Long, BuildOptColumn As Long, SrcDir As String)
'--------------------------------------------------------------------------------------------------------------------------------
  Check_Requierd_Libs_and_Install_missing                                   ' 12.09.19:

  Check_USB_Port_with_Dialog ComPortColumn
  
  Dim COMPort As String, BuildOptions As String, CommandStr As String, ResFile As String, Mode As String
  COMPort = "--port \\.\COM" & Cells(SH_VARS_ROW, ComPortColumn)
  BuildOptions = Cells(SH_VARS_ROW, BuildOptColumn)
  ResFile = "Start_Arduino_Result.txt"

  If ComPortColumn = COMPort_COL Then
     If Page_ID = "CAN" Then
           Mode = "CAN"
     Else: Mode = "Left"
     End If
  Else
     Mode = "Right"
  End If
  
  CommandStr = Create_Cmd_file(ResFile, COMPort, BuildOptions, InoName, Mode)
  Dim Res As ShellAndWaitResult
  Dim Start As Variant: Start = time
  
  If Dir(SrcDir & InoName) = "" Then
     MsgBox "Fehler das Program " & InoName & " ist nicht vorhanden in: " & vbCr & _
            "  '" & SrcDir & "'", vbCritical, "Fehler Ino-Programm nicht vorhanden"
     EndProg
  End If
  ChDrive SrcDir
  ChDir SrcDir    ' Change to the directory because the Arduino compiler doesn't like special characters like "|fffd|" in the path

  
  Res = ShellAndWait(CommandStr, 0, vbNormalFocus, PromptUser) ' No timeout to be able to study the results in case of an error
  Select Case Res
    Case Success, timeout: ' No additional error message. They have been shown in the DOS box
    Case Else:             MsgBox "Fehler " & Res & " beim starten des Arduino Programms '" & CommandStr & "'", vbCritical, _
                                  "Fehler beim starten des Arduino programms"
  End Select
  
  If Dir(ResFile) <> "" Then
    MsgBox "Es ist ein Fehler aufgetreten ;-(" & vbCr & _
           vbCr & _
           "Zur Fehlersuche kann man die letzten |fffd|nderungen wieder r|fffd|ckg|fffd|ngig machen und es noch mal versuchen. " & vbCr & _
           vbCr & _
           "Kommunikationsprobleme erkennt man an dieser Meldung: " & vbCr & _
           "   avrdude: ser_open(): can't open device ""\\.\COM" & Cells(SH_VARS_ROW, ComPortColumn) & """:" & vbCr & _
           "   Das System kann die angegebene Datei nicht finden." & vbCr & _
           "In diesem Fall m|fffd|ssen die Verbindungen |fffd|berpr|fffd|ft und der Arduino durch einen neuen ersetzt werden." & vbCr & _
           vbCr & _
           "Wenn der Fehler nicht zu finden ist und immer wieder auftritt, dann kann ein Screenshot des " & _
           "vorangegangenen Bildschirms (Nach oben scrollen so dass die erste Meldung nach dem Arduino Bild zu sehen ist) " & _
           "zusammen mit dem Excel Programm und einer ausf|fffd|hrlichen Beschreibung an " & vbCr & _
           "  MobaLedLib@gmx.de" & vbCr & _
           "geschickt werden.", vbInformation, "Fehler beim Hochladen des Programms"
    EndProg
  Else
    Debug.Print "Compile and upload duaration: " & Format(time - Start, "hh:mm:ss")
    Show_Status_for_a_while "Programm erfolgreich hochgeladen. Kompilieren und Hochladen dauerte " & Format(time - Start, "hh:mm:ss"), "00:00:30"
  End If
End Sub

'--------------------------------------------------
Public Sub Compile_and_Upload_LED_Prog_to_Arduino()
'--------------------------------------------------
  Upload_the_Right_Arduino_Prog_if_needed
  
  Compile_and_Upload_Prog_to_Arduino InoName_LED, COMPort_COL, BUILDOP_COL, ThisWorkbook.Path & "\"
End Sub

'----------------------------------------------------
Public Sub Compile_and_Upload_Prog_to_Right_Arduino()
'----------------------------------------------------
  Make_sure_that_Col_Variables_match
  Dim InoName As String
  Select Case Page_ID
    Case "DCC":       InoName = InoName_DCC
    Case "Selectrix": InoName = InoName__SX
    Case "CAN":       MsgBox "F|fffd|r die Steuerung per CAN Bus wird kein zweiter Arduino ben|fffd|tigt." & vbCr & _
                             vbCr & _
                             "Anstelle des rechen Arduinos muss ein CAN Modul (MCP2515) eingesteckt werden", _
                             vbInformation, "Kein Programm f|fffd|r Rechen Arduino ben|fffd|tigt"
                      Exit Sub
    Case Else:        MsgBox "Interner Fehler: Undefined Page_ID '" & Page_ID & "' in Compile_and_Upload_Prog_to_Right_Arduino", vbCritical, "Interner Fehler"
                      EndProg
  End Select
  
  Dim SrcDir As String
  SrcDir = ThisWorkbook.Path & "\..\" & FileName(InoName) & "\"
  If Dir(SrcDir & InoName) <> "" Then
      Debug.Print "Programm aus lokalem Verteichnis wird zum Upload verwendet: " & SrcDir
      Application.StatusBar = "Programm aus lokalem Verteichnis wird zum Upload verwendet: " & SrcDir
  Else
      SrcDir = Environ("USERPROFILE") & "\Documents\Arduino\libraries\MobaLedLib\examples\" & FileName(InoName) & "\"
  End If
  Compile_and_Upload_Prog_to_Arduino InoName, COMPrtR_COL, BUILDOpRCOL, SrcDir
  
  ' If the upload is NOT o.k. the program is aborted => We don't reach this line
  Cells(SH_VARS_ROW, R_UPLOD_COL) = "R OK"
End Sub

'---------------------------------------------------------------------------------------
Public Function Ask_To_Upload_the_Right_Arduino_Prog(Focus_Button As String) As Boolean
'--------------------------------------------------------------------------------------
' If the cell COMPrtR_COL is "COM?" the user is asked if the program for the
' right arduino is already uploaded.
  Dim Other_Prog As String
  Other_Prog = Replace(Trim(Replace(Prog_for_Right_Ardu, Page_ID, "")), " ", ", ") ' Generate a string with other protocolls which use the right arduino
  
  Select Case UserForm_USB_Connection.ShowForm("Programm f|fffd|r " & Page_ID & " Arduino", _
                        "Wurde das Programm des rechten " & Page_ID & " Arduinos bereits " & _
                        "installiert?" & vbCr & _
                        vbCr & _
                        "Das Programm muss nur beim ersten mal auf den Arduino hochgeladen werden. " & _
                        "Danach muss es nicht mehr ver|fffd|ndert werden solange es keine neue Version der " & _
                        "MobaLedLib gibt (oder auf " & Other_Prog & " umgestellt wird)." & vbCr & _
                        vbCr & _
                        "Ja: Diese Frage wird nicht mehr gestellt." & vbCr & _
                        "Installieren: Das Programm wird installiert.", _
                        True, False, True, _
                        "I Installieren", "A Abbrechen", "J Ja", Page_ID & " Programm installiert?", _
                        "Ist das Programm f|fffd|r den rechten Arduino installiert?", Focus_Button)
      Case "LeftButton":   Ask_To_Upload_the_Right_Arduino_Prog = True
      Case "RightButton":  Ask_To_Upload_the_Right_Arduino_Prog = False
      Case "MiddleButton": EndProg
  End Select
End Function

'--------------------------------------------
Private Sub Display_Connect_to_Left_Arduino()
'--------------------------------------------
  Make_sure_that_Col_Variables_match
  If "MiddleButton" = UserForm_USB_Connection.ShowForm("Linken (LED) Arduino anstecken", _
                                   "Das Programm wurde erfolgreich auf den rechten Arduino geladen." & vbCr & _
                                   vbCr & _
                                   "Dieser Vorgang muss nur ein mal durchgef|fffd|hrt werden. In Zukunft " & _
                                   "wird nur noch das Programm des linken (LED) Arduinos ver|fffd|ndert." & vbCr & _
                                   vbCr & _
                                   "Das USB Kabel muss jetzt an den linken Arduino angeschlossen werden." & vbCr & _
                                   vbCr & _
                                   "Wenn das geschehen ist die ""OK"" Taste bet|fffd|tigen", _
                                   True, True, False, _
                                   "P Pr|fffd|fen", "A Abbrechen", "O OK", "Umstecken zum Linken Arduino", "Linken Arduino anschlie|fffd|en") _
                             Then EndProg
End Sub


'----------------------------------------------------
Private Sub Upload_the_Right_Arduino_Prog_if_needed()
'----------------------------------------------------
' Uploade the program to the right arduino if
' it's not the CAN page
' and not uploadeded before (R_OK)
' and the the sheet uses the right arduino (DCC Adresses/ SX Channels entered)
  Make_sure_that_Col_Variables_match
  If Page_ID <> "CAN" And Cells(SH_VARS_ROW, R_UPLOD_COL) <> "R OK" And Ext_AddrTxt_Used() Then
     If Ask_To_Upload_the_Right_Arduino_Prog("Default_Button") Then
           Compile_and_Upload_Prog_to_Right_Arduino
           If Val(Cells(SH_VARS_ROW, COMPort_COL)) > 0 Then Display_Connect_to_Left_Arduino
     Else: Cells(SH_VARS_ROW, R_UPLOD_COL) = "R OK"
     End If
  End If
End Sub


'----------------------------------------------------------------------
Public Sub Ask_to_Upload_and_Compile_and_Upload_Prog_to_Right_Arduino()
'----------------------------------------------------------------------
  Make_sure_that_Col_Variables_match
  If Ask_To_Upload_the_Right_Arduino_Prog("Check_Button") Then
     Compile_and_Upload_Prog_to_Right_Arduino
  End If
End Sub


'--------------------------------------------------------------------------------
Private Function Create_InstalLib_Cmd_file(Optional LibNames As String) As String
'--------------------------------------------------------------------------------
' Arduino start Parameters see:
'   https://github.com/arduino/Arduino/blob/master/build/shared/manpage.adoc
' Extract:
'  --install-library library name[:version]
'       Fetches available libraries list and install the specified one. If version is omitted, the latest is installed.
'       If a library with the same version is already installed, nothing is installed and program exits with exit code 1.
'       If a library with a different version is already installed, it|fffd|s replaced. Multiple libraries can be specified, separated by a comma.

' Ein mal habe ich beobachtet, dass die MobaLedLin in ein anderes Verzeichnis installiert wurde
' Evtl. lag das daran, das der Library manager offen war
' Das problem tritt nicht auf wenn nur die Arduino IDE offen


  Dim ResultName As String
  ResultName = "Start_Arduino_Result.txt"
  
  
  If Dir(ResultName) <> "" Then Kill ResultName
  
  
  If LibNames = "" Then LibNames = Get_String_Config_Var("AddLibNames")
  
  Dim CommandStr As String
  CommandStr = """" & Find_ArduinoExe() & """ --install-library """ & LibNames & """"
  Dim fp As Integer, Name As String
  
  fp = FreeFile
  Name = ThisWorkbook.Path & "\Start_Arduino.cmd"
  On Error GoTo WriteError
  Open Name For Output As #fp
  Print #fp, "@ECHO OFF"
  Print #fp, "REM This file was generated by '" & ThisWorkbook.Name & "'  " & time
  Print #fp, "ECHO --------------------------------------------------------------------------"
  Print #fp, "ECHO Aktualisiere die Bibliotheken " & LibNames & " ..."
  Print #fp, "ECHO --------------------------------------------------------------------------"
  Print #fp, "ECHO."
  Print #fp, ""
  Print #fp, CommandStr
  Print #fp, "ECHO."
  Print #fp, ""
 'Print #fp, "Pause"
  Print #fp, "IF ERRORLEVEL 1 (" ' Check if ERRORLEVEL >= 1
  Print #fp, "   ECHO Start_Arduino_Result: %ERRORLEVEL% > """ & ResultName & """"
  Print #fp, "   ECHO   **********************************"
  Print #fp, "   ECHO   * Da ist was schief gegangen ;-( *            ERRORLEVEL %ERRORLEVEL%"
  Print #fp, "   ECHO   **********************************"
  Print #fp, "   Pause"
  Print #fp, "   )"
  Close #fp
  On Error GoTo 0
  
  Create_InstalLib_Cmd_file = Name
  
  Exit Function

WriteError:
  MsgBox "Fehler beim schreiben der Datei '" & Name & "'", vbCritical, "Fehler beim erzeugen der Arduino Start Datei"

End Function

'---------------------------------------------------------
Private Sub Install_Libraries(Optional LibNames As String)
'---------------------------------------------------------
  Dim CommandStr As String
  CommandStr = Create_InstalLib_Cmd_file(LibNames)
  Dim Res As ShellAndWaitResult
  Dim Start As Variant: Start = time
  
  Res = ShellAndWait(CommandStr, 0, vbNormalFocus, PromptUser) ' No timeout to be able to study the results in case of an error
  Select Case Res
    Case Success, timeout: ' No additional error message. They have been shown in the DOS box
    Case Else:             MsgBox "Fehler " & Res & " beim starten des Arduino Programms '" & CommandStr & "'", _
                                  vbCritical, "Fehler beim starten des Arduino programms"
  End Select
  
  Dim SrcDir As String
  SrcDir = ThisWorkbook.Path & "\"
  ChDrive SrcDir
  ChDir SrcDir    ' Change to the directory because the Arduino compiler doesn't like special characters like "|fffd|" in the path
  
  Const ResFile = "Start_Arduino_Result.txt"
  If Dir(ResFile) <> "" Then
    MsgBox "Es ist ein Fehler aufgetreten ;-(" & vbCr & _
           vbCr & _
           "Wenn der Fehler immer wieder auftritt, dann kann ein Screenshot des " & _
           "vorangegangenen Bildschirms und einer ausf|fffd|hrlichen Beschreibung an " & vbCr & _
           "  MobaLedLib@gmx.de" & vbCr & _
           "geschickt werden.", vbInformation, "Fehler beim Installieren der Bibliotheken"
    EndProg
  Else
    Debug.Print "Compile and upload duaration: " & Format(time - Start, "hh:mm:ss")
    Show_Status_for_a_while "Bibliotheken erfolgreich installiert. (Dauer: " & Format(time - Start, "hh:mm:ss") & ")", "00:00:30"
  End If
  
End Sub

'-----------------------------------------------
Private Function Check_Requierd_Libs() As String
'-----------------------------------------------
' Return a list of missing libraries
'
' ToDo: Check the required version of existing libraries

  Const LibPath = "\Arduino\libraries\MobaLedLib\examples\00.Overview"
  
  Dim LibDir As String
  LibDir = Replace(Environ("APPDATA"), "AppData\Roaming", "") & "Documents\Arduino\libraries\"

  On Error GoTo LibDirMissing
  If Dir(LibDir, vbDirectory) = "" Then GoTo LibDirMissing ' 06.10.19: Added: vbDirectory to detect also directories without files
  On Error GoTo 0
  
  Dim Name As Variant, LibNames As String
  LibNames = Get_String_Config_Var("AddLibNames")
  For Each Name In Split(LibNames, ",")
      If Dir(LibDir & Name & "\", vbDirectory) = "" Then ' 06.10.19: Added: vbDirectory to detect also directories without files
         Check_Requierd_Libs = Check_Requierd_Libs & Name & ","
      End If
  Next
  
  Check_Requierd_Libs = DelLast(Check_Requierd_Libs)
  Exit Function
  
LibDirMissing:
  MsgBox "Fehler: Das Arduino Bibliotheksverzeichnis wurde nicht gefunden:" & vbCr & _
         "  '" & LibDir & "'", vbCritical, "Fehler Bibliotheksverzeichnis nicht vorhanden"
  EndProg
End Function

'UT-----------------------------------
Private Sub Test_Check_Requierd_Libs()
'UT-----------------------------------
  Debug.Print "Check_Requierd_Libs: " & Check_Requierd_Libs
End Sub


'---------------------------------------------------
Public Sub Check_Requierd_Libs_and_Install_missing()
'---------------------------------------------------
  If True = Get_Bool_Config_Var("Lib_Installed_other") Then Exit Sub
  
  Dim MissingLibs As String
  MissingLibs = Check_Requierd_Libs()
  If MissingLibs = "" Then Exit Sub
  
  Select Case MsgBox("Achtung: Die folgenden Biblioteken wurden nicht im " & _
                     "Standardverzeichnis von Arduino gefunden:" & vbCr & _
                     "  " & MissingLibs & vbCr & _
                     vbCr & _
                     "Sollen die Biblioteken jetzt installiert werden?" & vbCr & _
                     vbCr & _
                     "Ja: Die Bibliotheken werden aus dem Internet installiert" & vbCr & _
                     vbCr & _
                     "Nein: Es wird davon ausgegangen, dass die Bibliotheken in " & vbCr & _
                     "einem anderen Verzeichnis verf|fffd|gbar sind (F|fffd|r Experten):" & vbCr & _
                     "Wenn beim compilieren eine fehlende Datei gemeldet wird, dann liegt " & _
                     "das vermutlich an einer fehlenden oder veralteten Bibliothek. " & _
                     "In dem Fall muss das Programm neu gestartet werden und die Bibliotheken " & _
                     "installiert werden.", vbYesNoCancel + vbQuestion, "Fehlende Bibliotheken erkannt")
     Case vbYes:     ' Only the missing libraries are installed because the Installer returns 1 if
                     ' one library exists in the same version. => Looks like an error.
                     ' This very is importand tor the MobaLedLib because otherwise the running Excel
                     ' sheed may be overwritten
                     Install_Libraries MissingLibs
     Case vbNo:      Set_Bool_Config_Var "Lib_Installed_other", True
     Case vbCancel:  EndProg
  End Select
End Sub
Attribute VB_Name = "M09_SelectMacro"
Option Explicit

' - Bei Effekten welche einzelne LEDs ansteuern muss die Adressierung der
'   LEDs anders gemacht werden.
' - Die LED Nummer darf nicht immer nach einer Zeile erh|fffd|ht werden.
' - Wenn danach eine RGB Zeile kommt, dann wird die die Nummer erh|fffd|ht
' - Es muss auch m|fffd|glich sein, dass mehrere Zeilen den selben LED Kanal ansprechen
'   z.B. bei der Sound Funktion. => Es gibt keine |fffd|berpr|fffd|fung auf doppelte Belegung
' - Mit der "Kommetar" Funktion "End_Single_LEDs"  kann man die Nummer erh|fffd|hen kann wenn danach wieder eine
'   Funktion kommt welche einzelne LEDs anspricht.
'   - Das ist alles zu Kompliziert
'   - Es w|fffd|hre besser wenn automatisch die n|fffd|chste RGB LED Nummer gew|fffd|hlt w|fffd|rde.
'   - Nur bei Funktionen wie der Sound Funktion ben|fffd|tigt man einen Befehl zum weiter schalten
' - Pattern Configurator: Startkanal, Anzahl der Kan|fffd|le
' - Eintrag in der LEDs Spalte: Andreaskreuz: C1 => 1-2, C2 => 2-3, C3 => 3-4
'   hier sollen auch gr|fffd||fffd|ere Nummern m|fffd|glich sein 5-6
'   Eine gr|fffd||fffd|ere Startnummer ben|fffd|tigt man dann wenn eine Patternfunktion z.B. 4 LEDs benutzt.
'   Dann kann man mit 5-6 die letzten beiden LEDs des zweiten WS2811 ansprechen.
'   Das ginge aber auch mit NextLED und 2-3

' Neuer Ansatz:
' - Die LED Kan|fffd|le m|fffd|ssen wie beim Haus immer in aufsteigender Reihenfolge angegeben werden
'   Wenn eine kleinere Nummer als die Vorangegangene verwendet wird, dann wird damit das n|fffd|chste
'   WS2811 Modul angesprochen.
' - Funktionen wie die Sound Befehle bekommen ein Flag mit dem verhindert wird, das
'   das n|fffd|chste Modul verwendet wird. In der Tabelle kann man das so markieren: "^ C1-2"
'   Wenn ein Befehl ausgew|fffd|hlt wurde bei dem die Kan|fffd|le mit den vorangegangenen |fffd|berlappen,
'   Dann wird der User gefragt ob er die gleiche StartLedNr verwenden will wie die vorangegange Zeile.
'   Das funktioniert aber nur wenn einzel Adressierte LEDs Verwendet werden (C1-2)
' - Befehle welche die RGB LEDs am St|fffd|ck und nicht als drei einzelne Kan|fffd|le ansprechen sorgen immer
'   daf|fffd|r dass die n|fffd|chste StartLedNr verwendet wird.


'--------------------------------------------------------------------------------------------
Private Function Special_ConstrWarnLight(ByVal Res As String, ByRef Leds As String) As String
'--------------------------------------------------------------------------------------------
' ConstrWarnLight(LED,InCh, LEDcnt, MinBrightness, MaxBrightness, OnT, WaitT, WaitE)
'          Param: 0   1     2       3              4              5    6      7
  Dim Parts As Variant, Param As Variant, Ret As String, FlashFunct As Boolean
  Parts = Split(Replace(Res, ")", ""), "(")
  Param = Split(Parts(1), ",")
  If Val(Param(6)) > 0 Then
        FlashFunct = True
        Ret = "ConstrWarnLightFlash"
  Else: Ret = "ConstrWarnLight"
  End If
  Ret = Ret & Trim(Param(2)) & "(" & Trim(Param(0)) & ", " & _
                               Trim(Param(1)) & ", " & _
                               Trim(Param(3)) & ", " & _
                               Trim(Param(4)) & ", " & _
                               Trim(Param(5)) & ", "
  If FlashFunct Then Ret = Ret & Trim(Param(6)) & ", "

  Ret = Ret & Trim(Param(7)) & ")"
  Special_ConstrWarnLight = Ret
  Leds = "C1-" & Trim(Param(2))
End Function

'UT---------------------------------------
Private Sub Test_Special_ConstrWarnLight()
'UT---------------------------------------
  Dim Res As String, Leds As String
       ' ConstrWarnLight(LED,InCh, LEDcnt, MinBrightness, MaxBrightness, OnT, WaitT, WaitE)
  Res = "ConstrWarnLight(#LED,#InCh, 6, 20, 255, 100 ms, 0 ms, 300 ms)"
  Res = Special_ConstrWarnLight(Res, Leds)
  Debug.Print Res & "LEDs:" & Leds
End Sub

'------------------------------------------------------------------------------------------------------------------------
Private Function Proc_General_With_Other_Par(ByVal Macro As String, Description As String, LedChannels As Long) As String
'------------------------------------------------------------------------------------------------------------------------
  If Macro = "" Then Exit Function
  
  Dim Parts As Variant, Res As String, Param As Variant
  Parts = Split(Replace(Macro, ")", ""), "(")
  Param = Split(Parts(1), ",")
  UserForm_Other.Show_UserForm_Other Parts(1), Parts(0), Description, LedChannels
  
   
  Proc_General_With_Other_Par = Userform_Res
End Function

'-------------------------------------------------------------------------------------------------------------
Private Function Get_NamedPar(SearchName As String, MacroWithNames As String, FilledMacro As String) As String
'-------------------------------------------------------------------------------------------------------------
  Dim Names As Variant, Values As Variant, i As Long
  Names = Split(Replace(Split(MacroWithNames, "(")(1), ")", ""), ",")
  Values = Split(Replace(Split(FilledMacro, "(")(1), ")", ""), ",")
  For i = 0 To UBound(Names)
      If Trim(Names(i)) = SearchName Then
         Get_NamedPar = Trim(Values(i))
         Exit Function
      End If
  Next i
End Function

'------------------------------------------------------------------------------
Private Function Cx_to_LED_Channel(Cx As String, LedChannels As Long) As String
'------------------------------------------------------------------------------
  Select Case Cx
    Case "C_ALL": Cx_to_LED_Channel = "1"
    Case "C1":    Cx_to_LED_Channel = "C1-" & 1 + LedChannels - 1
    Case "C2":    Cx_to_LED_Channel = "C2-" & 2 + LedChannels - 1
    Case "C3":    Cx_to_LED_Channel = "C3-" & 3 + LedChannels - 1
    Case "C12":   Cx_to_LED_Channel = "C1-2"
    Case "C23":   Cx_to_LED_Channel = "C2-3"
  End Select
End Function


'-------------------------------------------------------------------------------------------------------------------------
Private Function Proc_General(Leds As String, ByVal Macro As String, Description As String, LedChannels As Long) As String
'-------------------------------------------------------------------------------------------------------------------------
  If Macro = "" Then Exit Function
  
  Dim Parts As Variant, Res As String, Param As Variant
  Parts = Split(Replace(Macro, ")", ""), "(")
  Param = Split(Parts(1), ",")
  Res = Parts(0) & "("
  Dim p As Variant, Other As Long
  For Each p In Param
     p = Trim(p)
     Select Case p
       Case "LED", "B_LED":   p = "#LED"
       Case "InCh":           p = "#InCh"
       Case "":               ' Nothing
       Case Else:             Other = Other + 1
     End Select
     Res = Res & p & ", "
  Next p
  Res = DelLast(DelLast(Res)) & ")"
  If Other > 0 Then ' Other parameters then "LED" and "InCh"
        Res = Proc_General_With_Other_Par(Res, Description, LedChannels)
        
        If Res = "" Then Exit Function
        
        If Parts(0) = "ConstrWarnLight" Then Res = Special_ConstrWarnLight(Res, Leds) ' 18.09.19
  End If
  
  If Left(Leds, Len("LedCnt")) = "LedCnt" Then Leds = Get_NamedPar(Leds, Macro, Res)
  
  Select Case Leds
     Case "Cx":  Leds = Cx_to_LED_Channel(Get_NamedPar(Leds, Macro, Res), LedChannels)
  End Select
  
  Proc_General = Leds & "|" & Res
End Function

'-----------------------------------------------------
Private Function Get_PriorLine_LEDs(ByRef Row As Long)
'-----------------------------------------------------
' Return the LEDs cell of the first enabled row starting with Row
' Row is set to the detected line
  While Row >= FirstDat_Row
    If Row_is_Achtive(Row) Then
       Get_PriorLine_LEDs = Cells(Row, LEDs____Col)
       Exit Function
    End If
    Row = Row - 1
  Wend
End Function


'-------------------------------------------------------------------------------
Private Function Get_InCnt(Macro As String, ByVal FilledMacro As String) As Long
'-------------------------------------------------------------------------------
  Dim Par As String
  Par = Get_NamedPar("InCh_Cnt", Macro, FilledMacro)
  If Par = "" Then
     MsgBox "Interner Fehler in Get_InCnt()", vbCritical, "Interner Fehler"
     EndProg
  End If
  Get_InCnt = Par
End Function



'----------------------------------------
Public Function SelectMacros() As Boolean
'----------------------------------------
  Make_sure_that_Col_Variables_match
  
  With ActiveCell
    If .Row < FirstDat_Row Then
       MsgBox "Zur Auswahl des (Beleuchtungs-)Effekts muss eine Zeile in der" & vbCr & _
              "Tabelle ausgew|fffd|hlt sein bevor der Dialog Knopf bet|fffd|tigt wird.", vbInformation, "Falsche Zielposition ausgew|fffd|hlt"
       Exit Function
    End If
  End With
  Cells(ActiveCell.Row, Config__Col).Select

  SelectMacros_Form.Show_SelectMacros_Form "Lib_Macros"
  
  If SelectMacro_Res <> "" Then
    Dim MacroName As String, SelRow As Long, DlgTyp As String, Macro As String, Leds As String, Res As String
    Dim Description As String, LedChannels As Long
    MacroName = Split(SelectMacro_Res, ",")(0)
    SelRow = Split(SelectMacro_Res, ",")(1)
    With ThisWorkbook.Sheets("Lib_Macros")
      DlgTyp = .Cells(SelRow, SM_Typ___COL)
      Leds = .Cells(SelRow, SM_LEDS__COL)
      Macro = .Cells(SelRow, SM_Macro_COL)
      LedChannels = Val(.Cells(SelRow, SM_SngLEDCOL))
      Description = Replace(.Cells(SelRow, SM_DetailCOL), "|", vbLf)
      If Description = "" Then Description = .Cells(SelRow, SM_ShrtD_COL)
      Select Case DlgTyp
        Case "House":  UserForm_House.SetMode MacroName
                       UserForm_House.Show
                       Res = Userform_Res
        Case "ColTab": UserForm_Set_ColTab.Show
                       Res = "0|" & Userform_Res
        Case "":       Res = Proc_General(Leds, Macro, Description, LedChannels) ' Empty typ
        Case Else:     MsgBox "Unknown Dialog Typ '" & DlgTyp & "'", vbCritical, "Program Error: SelectMacros"
      End Select
      
      If Res <> "" Then
         Dim Parts As Variant
         Parts = Split(Res, "|")
         Dim DstRow As Long
         DstRow = ActiveCell.Row
         Leds = Parts(0)
         
         If Check_IsSingleChannelCmd(Leds) Then ' If it's a command which adresses single channels we check if it uses the same channel as above
            Dim PriorLeds As String, PriorLine As Long
            PriorLine = DstRow - 1
            PriorLeds = Trim(Replace(Get_PriorLine_LEDs(PriorLine), "^", "")) ' Get the first enabled line above
            If Check_IsSingleChannelCmd(PriorLeds) Then
               If PriorLeds = Leds Then ' Same LEDs used again
                  Dim Answ As Variant
                  Answ = MsgBox("Achtung: Die LED Kan|fffd|le sind gleich wie der vorangegangenen Zeile!" & vbCr & _
                             "Das kann zu ungewollten Effekten f|fffd|hren." & vbCr & _
                             "Bei Funktionen welche einen Kanal nur kurzzeitig ansteuern kann das sinnvoll sein." & vbCr & _
                             "Ein Beispiel daf|fffd|r ist die Ansteuerung von Sound Modulen. Hier steuern mehrere Tasten " & _
                             "den gleichen Kanal mit unterschiedlichen Werten an. Je nach abzuspielendem Sound wird " & _
                             "eine andere 'Helligkeit' gesendet. Da die Tasten werden aber nicht gleichzeitig bet|fffd|tigt " & _
                             "werden ist das unproblematisch." & vbCr & _
                             vbCr & _
                             "Soll der neue Befehl die gleiche LED Adressieren wie der Vorangegangene Befehl?", _
                             vbQuestion + vbYesNoCancel, "|fffd|berlappende Kan|fffd|le entdeckt")
                  Select Case Answ
                     Case vbYes: Leds = "^ " & Leds
                     Case vbCancel: Exit Function
                  End Select
               End If
            End If
         End If
         
         Cells(DstRow, LEDs____Col) = Leds
         Cells(DstRow, Config__Col) = Parts(1)
         
         Dim InCnt As Long
         If .Cells(SelRow, SM_InCnt_COL) = "n" Then
               InCnt = Get_InCnt(Macro, Parts(1))
         Else: InCnt = Val(.Cells(SelRow, SM_InCnt_COL)) ' use the Val function to get 0 if the cell is empty in sheet Lib_Macros
         End If
         Cells(DstRow, InCnt___Col) = InCnt
         
         Cells(DstRow, LocInCh_Col) = Val(.Cells(SelRow, SM_LocInCCOL)) ' use the Val function to get 0 if the cell is empty in sheet Lib_Macros
         Cells(DstRow, Enable_Col) = ChrW(Hook_CHAR) ' Enable the Line
         Update_Start_LedNr
         SelectMacros = True
      End If
    End With
  End If
  ActiveCell.Offset(1, 0).Select  ' Move the cursor out of the cell because otherwise the user may change things by mistake
End Function


Attribute VB_Name = "M10_Par_Description"
Option Explicit


Private Const ParName_COL = 1
Private Const Par_Cnt_COL = 2
Private Const ParType_COL = 3
Private Const Par_Min_COL = 4
Private Const Par_Max_COL = 5
Private Const Par_Def_COL = 6
Private Const ParInTx_COL = 7
Private Const ParHint_COL = 8

Private Const FirstDatRow = 2

'------------------------------------------------------------------------
Private Function Get_ParDesc_Row(sh As Worksheet, Name As String) As Long
'------------------------------------------------------------------------
  Dim r As Range, F As Variant
  With sh
    Set r = .Range(.Cells(1, ParName_COL), .Cells(LastUsedRowIn(sh), ParName_COL))
  End With
    
  Set F = r.Find(What:=Name, After:=r.Cells(FirstDatRow, 1), LookIn:=xlFormulas, LookAt:=xlWhole, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=True, SearchFormat:=False)

  If F Is Nothing Then
       MsgBox "Fehler: Der Parameter Name '" & Name & "' wurde nicht im Sheet '" & sh.Name & "' gefunden!", _
              vbCritical, "Internal Error"
       EndProg
  Else
       Get_ParDesc_Row = F.Row
  End If
End Function

'---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Public Sub Get_Par_Data(ByVal ParName As String, ByRef Typ As String, ByRef Min As String, ByRef Max As String, ByRef Def As String, ByRef InpTxt As String, ByRef Hint As String)
'---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  Dim Row As Long, sh As Worksheet
  Set sh = Sheets("Par_Description")
  Row = Get_ParDesc_Row(sh, ParName)
  With sh
    Typ = .Cells(Row, ParType_COL)
    Min = .Cells(Row, Par_Min_COL)
    Max = .Cells(Row, Par_Max_COL)
    Def = .Cells(Row, Par_Def_COL)
    InpTxt = .Cells(Row, ParInTx_COL): If InpTxt = "" Then InpTxt = ParName
    Hint = .Cells(Row, ParHint_COL)   ' Inserting a LF seames to be not possible ;-(   Test with: Replace(.Cells(Row, ParHint_COL), "|", vbCrLf)
  End With
End Sub


'UT----------------------------
Private Sub Test_Get_Par_Data()
'UT----------------------------
  Dim Typ As String, Min As String, Max As String, Def As String, InpTxt As String, Hint As String
  Get_Par_Data "Duration", Typ, Min, Max, Def, InpTxt, Hint
  Debug.Print "Typ:" & Typ, "Min:" & Min & " Max:" & Max & " Def:" & Def & vbCr & "InpTxt:" & InpTxt & vbCr & "Hint:" & Hint
End Sub
Attribute VB_Name = "M12_Copy_Prog"
Option Explicit

' Copy the program to %USERPROFILE%\Documents\Arduino\MobaLedLib_Autoprog


'-----------------------------------------------------------------
Private Sub FileCopy_with_Check(DestDir As String, Name As String)
'-----------------------------------------------------------------
  If Dir(ThisWorkbook.Path & "\" & Name) = "" Then
     MsgBox "Fehler: Die Datei '" & Name & "' ist nicht im Verzeichnis" & vbCr & _
     "  '" & ThisWorkbook.Path & "\'" & vbCr & _
     "vorhanden.", vbCritical, "Fehler beim kopieren"
     Exit Sub
  End If
  
  On Error GoTo CopyError
  FileCopy ThisWorkbook.Path & "\" & Name, DestDir & Name
  On Error GoTo 0
  Exit Sub
  
CopyError:
  MsgBox "Es ist ein Fehler beim kopieren der Datei '" & Name & "' vom Verzeichnis" & vbCr & _
  "  '" & ThisWorkbook.Path & "\'" & vbCr & _
  "nach '" & DestDir & "'", vbCritical, "Fehler beim kopieren"
  Exit Sub
  
End Sub

'----------------------------------
Public Sub Copy_Prog_If_in_LibDir()
'----------------------------------
  Const DestDir = "\Documents\Arduino\MobaLedLib_" & Lib_Version_Nr & "_Autoprog\23_B.LEDs_AutoProg\"
  
  If InStr(ThisWorkbook.Path, "\libraries\MobaLedLib\examples\23_B.LEDs_AutoProg") = 0 Then
     Exit Sub
  End If
  
  Dim Userprofile As String
  Userprofile = Environ("USERPROFILE")
  If Userprofile = "" Then
     MsgBox "Fehler: Die Variable 'USERPROFILE' ist nicht definiert ;-(" & vbCr & _
            vbCr & _
            "Das Programm wird nach 'C:" & DestDir & "' kopiert.", vbInformation, "Fehler beim kopieren des LED Programmiertool"
     Userprofile = "C:"
  End If
   
  Dim FullDestDir As String
  FullDestDir = Userprofile & DestDir
  On Error Resume Next ' In case the directory exists
  Dim Parts As Variant, p As Variant, ActDir As String
  Parts = Split(FullDestDir, "\")
  For Each p In Parts
    ActDir = ActDir & p & "\"
    If Len(ActDir) > 3 Then MkDir ActDir
  Next
  On Error GoTo 0
  
  FileCopy_with_Check FullDestDir, "23_B.LEDs_AutoProg.ino"
  FileCopy_with_Check FullDestDir, "Prog_Generator_MobaLedLib.pdf"
  
  Dim ProgName As String
  ProgName = FullDestDir & ThisWorkbook.Name
  If Dir(ProgName) <> "" Then
     MsgBox "Achtung: Die Datei '" & ThisWorkbook.Name & "' existiert bereits im Verzeichnis" & vbCr & _
            "  '" & FullDestDir & "'" & vbCr & _
            vbCr & _
            "Das Programm wird unter einem neuen Namen gespeichert.", vbInformation, "Programm Existiert bereits"
     Dim Nr As Long
     Do
       Nr = Nr + 1
       ProgName = FullDestDir & FileName(ThisWorkbook.Name) & "_" & Nr & ".xlsm"
     Loop While Dir(ProgName) <> ""
  End If
  
  On Error GoTo ErrSaveAs
  ThisWorkbook.SaveAs ProgName
  On Error GoTo 0
  If Create_Desktoplink_w_Powershell("MobaLedLib Prog_Generator", ProgName) Then
       MsgBox "Das Programm wurde in das Verzeichnis" & vbCr & _
              "  '" & DestDir & "' kopiert." & vbCr & _
              vbCr & _
              "In Zukunft kann der Prog_Generator |fffd|ber den Link 'MobaLedLib Prog_Generator' auf dem Desktop gestartet werden", vbInformation, _
              "Programm kopiert und Link auf Desktop erzeugt"
  Else: MsgBox "Das Programm wurde in das Verzeichnis" & vbCr & _
               "  '" & DestDir & "' kopiert." & vbCr & _
               vbCr & _
               "Beim Anlegen des Links gab es Probleme ;-(" & vbCr & _
               "Das Programm kan trotzdem von der oben angegebenen Position aus gestartet werden.", vbInformation, _
               "Programm kopiert"
  End If
  Exit Sub

ErrSaveAs:
  MsgBox "Fehler beim Speichern des Programms im Verzeichnis:" & vbCr & _
         "  '" & DestDir & "'", vbCritical, "Fehler beim Speichen des Excel Programms"
End Sub


'---------------------------------------------------------------------
Private Sub Create_DesktopLink(LinkName As String, DestName As String)
'---------------------------------------------------------------------
  Dim FSOShell As Object
  Dim Desktop As String
  Dim ShortCut As Object
    
  Set FSOShell = CreateObject("WScript.Shell")
  Desktop = FSOShell.SpecialFolders("Desktop")
  'Debug.Print Desktop
    
  Set ShortCut = FSOShell.CreateShortcut(Desktop + "\" & LinkName & ".lnk")
  'Debug.Print ShortCut
    
  With ShortCut
      .WindowStyle = 4 ' 4=Normal 3=Maximized 7=Minimized
      '.IconLocation = "\Path\Name.ico"
      .TargetPath = DestName
      '.Hotkey = "ALT+CTRL+E" 'Keyboard Shortcut zuweisen
      .Save
  End With
End Sub

'UT----------------------------------
Private Sub Test_Create_DesktopLink()
'UT----------------------------------
  Create_DesktopLink "MobaLedLib Prog_Generator", Environ("userprofile") & "\Documents\Arduino\MobaLedLib_0.9.0_Autoprog\23_B.LEDs_AutoProg\Prog_Generator_MobaLedLib.xlsm"
End Sub
    
'--------------------------------------------------------------------------------------------------
Private Function Create_Desktoplink_w_Powershell(LinkName As String, DestName As String) As Boolean
'--------------------------------------------------------------------------------------------------
  MsgBox "In folgenden wir ein Link auf dem Desktop angelegt |fffd|ber den das Excel Programm in Zukunft einfach " & _
         "gestartet werden kann." & vbCr & _
         "Dummerweise gef|fffd|llt das manchen Viren Scannern (z.B. dem Microsoft Scanner) nicht." & vbCr & _
         "Wenn sich gleich der Viren scanner meldet, dann muss man den Link von Hand anlegen." & vbCr & _
         "Dazu kopiert man den inhalt der Zwischenablage mit STRG+V in die Adresszeile eines Windows Explorers.", vbInformation, "Anlegen einer Desktop Verkn|fffd|pfung"
         
  Dim fp As Integer, Name As String
  
  fp = FreeFile
  Name = ThisWorkbook.Path & "\CreateLink.cmd"
  
  ClipBoard_SetData Name
  
  On Error GoTo WriteError
  Open Name For Output As #fp
  Print #fp, "powershell ""$s=(New-Object -COM WScript.Shell).CreateShortcut('%userprofile%\Desktop\" & LinkName & ".lnk');$s.TargetPath='" & DestName & "';$s.Save()"""
  Close #fp

  Dim Res As String
  Res = F_shellExec(Name)
  
  If Dir(Name) <> "" Then
        Create_Desktoplink_w_Powershell = True
  Else: MsgBox "Das anlegen des Links hat NICHT funktioniert ;-(" & vbCr & _
               vbCr & _
               "Der Link muss von Hand erzeugt werden. Dazu kopiert man den inhalt der Zwischenablage " & _
               "in die Adresszeile eines Windows Explorers mit STRG+V", vbCritical, "Fehler beim anlegen des Links"
  End If
  
  Exit Function

WriteError:
  MsgBox "Fehler beim schreiben der Datei '" & Name & "'", vbCritical, "Fehler beim erzeugen der Kommandodatei"
End Function

'UT-----------------------------------------------
Private Sub Test_Create_Desktoplink_w_Powershell()
'UT-----------------------------------------------
  Create_Desktoplink_w_Powershell "MobaLedLib Prog_Generator", "%userprofile%\Documents\Arduino\MobaLedLib_0.9.0_Autoprog\23_B.LEDs_AutoProg\Prog_Generator_MobaLedLib.xlsm"
End Sub

Attribute VB_Name = "M15_Filter"
' Module Description:
' ~~~~~~~~~~~~~~~~~~~
' This module contains functions to load and save the filters
' The filters are internaly stored in the structure FilterButton_T
'
'
' Die Filter werden in der Struktur "FilterButton_T" gespeichert
'
' Zur Umwandlung werden folgende
' Funktionen ben|fffd|tigt:
' - Excel    => Struct          Function  Get_Excel_Filter(s As Worksheet, DestFilter As FilterButton_T) as boolean
' - Struct   => Excel           Sub       Activate_Filter (FB As FilterButton_T, s As Worksheet)

' Die Daten werden in folgender Struktur gespeichert werden:
'   FilterButton1
'     + Name                    ' Name defined by the user in the dialog
'     + Description
'     + Sheet
'     + Workbook
'     + AutoEnable
'     + EnableFilters
'     + OverwriteExisting
'     + FirstRow
'     + FirstColumn
'     + Filter1                 ' Save_One_Column_Filter_to_Registry()
'        + Enabled
'        + Column
'        + Name
'        + Count
'        + Operator
'        + Criteria1
'        + Criteria2
'     + Filter2
'     ...
'     + HideColumn1
'         + Column
'         + Name
'     + HideColumn2
'
Option Explicit

Public Const APP_NAME = "FilterTest"

Private Const Separator = "|fffd|" ' Chr(254)

Private Enum Debug_Flags_E
  D_EVENT = 1
  D_RIBBON = 2
  D_DEL_UPDATE = 4
  D_LOAD = 8
  D_ERROR = 16
End Enum

Public Type Filter_T
  Enabled As Boolean
  Column As Long
  Name As String
  Count As Long
  Criteria1 As Variant
  Criteria2 As Variant
  Operator As XlAutoFilterOperator
End Type

Public Type HiddenCol_T
  Enabled As Boolean
  Column As Long
  Name As String
End Type

Public Type FilterButton_T
  FilterName As String                  ' Name in the registry
  Name As String                        ' User defined name
  Description As String                 ' User entered description
  Sheet As String                       ' Excel sheet name (could include wild cards '?', '*')
  Workbook As String                    ' Excel wokksheet name without path (could include wild cards '?', '*')
  AutoEnable As Boolean
  EnableFilters As Boolean
  OverwriteExisting As Boolean
  FirstRow As Long
  FirstColumn As Long
  Filters() As Filter_T
  EnableColumnHiding As Boolean
  ShowAllOtherColumns As Boolean
  HiddenCols() As HiddenCol_T
  Save_ColWidth As Boolean
  ColWidthList As String
End Type

Private Debug_Mode As Integer
Private Print_Part_Act As Boolean

Private Const DEBUG_MASK = D_EVENT + D_RIBBON + D_DEL_UPDATE + D_LOAD + D_ERROR

'---------------------------
Private Function isProgDev()
'---------------------------
    isProgDev = UCase(Environ("USERNAME")) = "Hardi"
End Function


'-----------------------------------------------------------------
Private Function Check_DebugMode(Flag As Debug_Flags_E) As Boolean
'-----------------------------------------------------------------
#If True Then  ' Disable this line to use the debug mode for all users
  If Debug_Mode = 0 Then
     If isProgDev() Then
           Debug_Mode = 1
     Else: Debug_Mode = -1
     End If
  End If
#Else
  Debug_Mode = 1
#End If
  
  If Debug_Mode = 1 Then
     If Flag And DEBUG_MASK > 0 Then Check_DebugMode = True
  End If
End Function

'--------------------------------------------------------
Private Sub D_Print(Flag As Debug_Flags_E, Txt As String)
'--------------------------------------------------------
  If Check_DebugMode(Flag) Then
     If Print_Part_Act Then
           Print_Part_Act = False
           Debug.Print Txt
     Else: Debug.Print "AF: " & Format(Now, "hh:mm:ss ") & Txt
     End If
  End If
End Sub


'---------------------------------------------------------------------------------------------------------------------------------
Private Sub Get_General_Excel_Column_Filters(s As Worksheet, af As AutoFilter, ByRef FB As FilterButton_T, SetDefaults As Boolean)
'---------------------------------------------------------------------------------------------------------------------------------
  With FB
    If SetDefaults Then
        .Name = ""        ' Has to be entered later by the user
        .Description = "" ' Has to be entered later by the user
        .Sheet = s.Name
        .Workbook = s.Parent.Name
        .AutoEnable = False
        .OverwriteExisting = True
        .ShowAllOtherColumns = True
        If Not af Is Nothing Then
           .FirstRow = af.Range.Row
           .FirstColumn = af.Range.Column
           .EnableFilters = True                                            ' 24.09.19
        End If
        
        .Save_ColWidth = False
    End If
    
    ' Store the column width
    Dim Col As Long, List As String
    For Col = 1 To LastUsedColumnIn(s)
       List = List & s.Columns(Col).ColumnWidth & Separator
    Next Col
    List = Left(List, Len(List) - Len(Separator))
    .ColWidthList = List
  End With
End Sub

'------------------------------------------------------------
Private Function Get_Filtered_Count_Str(r As Range) As String
'------------------------------------------------------------
  Get_Filtered_Count_Str = r.SpecialCells(xlCellTypeVisible).Count - 1
End Function

'------------------------------------------------------------------
Private Function Enter_Percent(F As Filter, DestFilter As Filter_T)
'------------------------------------------------------------------
' ToDo: Evtl. kann man das auch automatisch berechen.
'       Die genaue Prozentzahl zu treffen wird aber nicht m|fffd|glich sein.
  Dim TypeStr As String
  With F
    If .Operator = xlTop10Percent Then
          TypeStr = "top"
    Else: TypeStr = "bottom"
    End If
    Enter_Percent = InputBox("Enter the percentage for the '" & TypeStr & " n percent'" & vbCr & _
                             "filter in column " & ColumnLettersFromNr(DestFilter.Column) & ": '" & DestFilter.Name & "'", _
                             "Enter percentage for filter", 10)
  End With
End Function


'--------------------------------------------------------------------------------------------------------------
Private Sub Store_one_Column_Filter(F As Filter, Head As Range, ByRef DestFilter As Filter_T, af As AutoFilter)
'--------------------------------------------------------------------------------------------------------------
' Store the excel autofilter of one column to the struct Filter_T
'
' The following filters need special treatement
' - Cell Color
' - Top10 / Bottom10     The Top10 filter show the 10 greatest numbers. In total 10 rows are shown even if the same number exists several times.
'
  With F
    DestFilter.Enabled = True
    DestFilter.Column = Head.Column
    DestFilter.Name = Head.Value
    DestFilter.Count = .Count
    DestFilter.Operator = .Operator '  XlAutoFilterOperator: (xlAnd = 1), (xlOr = 2), ..., (xlFilterValues = 7), ..
    
    If .Count <> 0 Then
        'If TypeName(.Criteria1) = "Variant()" Then ' Operator = (xlFilterValues = 7) oder ... ToDo
        If isVariantArray(.Criteria1) Then
           DestFilter.Criteria1 = .Criteria1
        Else ' Criteria1 is no variant
           Select Case .Operator
              Case xlTop10Items, _
                   xlBottom10Items: DestFilter.Criteria1 = Get_Filtered_Count_Str(af.Range.Columns(Head.Column))
              Case xlTop10Percent, _
                   xlBottom10Percent: DestFilter.Criteria1 = Enter_Percent(F, DestFilter)
              Case xlFilterNoFill, _
                   xlFilterCellColor: DestFilter.Criteria1 = .Criteria1.Color
              Case Else:              DestFilter.Criteria1 = .Criteria1
           End Select
           Select Case .Count
              Case 1:    ' Nothing
              Case 2:    DestFilter.Criteria2 = .Criteria2
              Case Else: MsgBox "Unexpected number of filter criterias (" & .Count & ") in column " & ColumnLetters(Head) & ": '" & Head.Value & "'", vbCritical, "Error writing filter to registry"
           End Select
        End If
    Else
        MsgBox "Unsupported filter criteria in column " & ColumnLetters(Head) & ": '" & Head.Value & "'", vbCritical, "Error writing filter to registry"  ' Must be store some were else => ToDo:
    End If
  End With
End Sub

'-----------------------------------------------------------------------------------------------------------------------------------------------
Private Function Get_All_Excel_Column_Filters(s As Worksheet, af As AutoFilter, ByRef Dest As FilterButton_T, SetDefaults As Boolean) As Boolean
'-----------------------------------------------------------------------------------------------------------------------------------------------
  Get_General_Excel_Column_Filters s, af, Dest, SetDefaults
  
  Dim i As Long, Head As Range, FilterNr As Long ' , F As Filter
  With af
    For i = 1 To .Filters.Count
        If .Filters(i).On Then
            Set Head = s.Cells(.Range.Row, .Range.Column + i - 1)
            ReDim Preserve Dest.Filters(FilterNr)
            Store_one_Column_Filter .Filters(i), Head, Dest.Filters(FilterNr), af
            FilterNr = FilterNr + 1
        End If
    Next i
  End With
  Dest.EnableFilters = (FilterNr > 0)
  Get_All_Excel_Column_Filters = Dest.EnableFilters
End Function


'-------------------------------------------------------------------------------------
Private Function Get_HiddenCols(s As Worksheet, ByRef FB As FilterButton_T) As Boolean
'-------------------------------------------------------------------------------------
  Dim Col As Long, cnt As Long
  With FB
    Erase .HiddenCols
    Dim Row As Long
    Row = .FirstRow
    If Row = 0 Then Row = 1
    For Col = 1 To LastUsedColumnIn(s)
        If s.Columns(Col).Hidden Then
           ReDim Preserve .HiddenCols(cnt)
           With .HiddenCols(cnt)
             .Enabled = True
             .Column = Col
             .Name = s.Cells(Row, Col)
             If .Name = "" Then .Name = "Column " & Col
           End With
           cnt = cnt + 1
        End If
    Next Col
  End With
  
  FB.EnableColumnHiding = cnt > 0
  Get_HiddenCols = FB.EnableColumnHiding
End Function

'UT-------------------------------------------------
Private Sub Test_Get_HiddenCols()
'UT-------------------------------------------------
  Dim FB As FilterButton_T
  Debug.Print Get_HiddenCols(ActiveSheet, FB)
End Sub


'---------------------------------------------------------------------------------------------------------------
Public Function Get_Excel_Filter(s As Worksheet, ByRef DestFilter As FilterButton_T, SetDefaults As Boolean) As Boolean
'----------------------------------------------------------------------------------------------------------------------
' Store the excel autofilter of all columns to an Filter_T array
  If Not s.AutoFilter Is Nothing Then
        If s.AutoFilter.FilterMode Then
              Get_Excel_Filter = Get_All_Excel_Column_Filters(s, s.AutoFilter, DestFilter, SetDefaults)
        Else: Get_General_Excel_Column_Filters s, s.AutoFilter, DestFilter, SetDefaults
        End If
  Else
        ' (see Save_Active_Filters_Direct_to_Registry)
        Dim obj As Variant
        'FilterNr = 0
        For Each obj In s.ListObjects
            If Not obj.AutoFilter Is Nothing Then
               Get_Excel_Filter = Get_All_Excel_Column_Filters(s, obj.AutoFilter, DestFilter, SetDefaults)
            End If
        Next obj
  End If
  If DestFilter.Sheet = "" Then Get_General_Excel_Column_Filters s, Nothing, DestFilter, SetDefaults
  
  If Get_HiddenCols(s, DestFilter) Then Get_Excel_Filter = True

End Function


'---------------------------------------------------------------
Public Sub Activate_Filter(FB As FilterButton_T, s As Worksheet)
'---------------------------------------------------------------
' Activates the filter which is defined in the structure FilterButton_T
  Dim OldUpdate As Boolean
  OldUpdate = Application.ScreenUpdating
  Application.ScreenUpdating = False
  
  Dim NormalFilter As Boolean
  If s.AutoFilterMode Then
      If s.FilterMode Then
         NormalFilter = True
      End If
  End If
      
  Dim OldActCell As Range, RestoreActiveCell As Boolean
  If Not NormalFilter Then ' If a table is used the active cell must be inside the table
     Dim obj As Variant
     For Each obj In s.ListObjects
         If Not obj.AutoFilter Is Nothing Then
            Set OldActCell = ActiveCell
            s.Cells(obj.Range.Row, obj.Range.Column).Select
            RestoreActiveCell = True
            Exit For
         End If
     Next obj
  End If
      
  '*** Filters ***
  With FB
      If .EnableFilters Then
          Dim r As Range, i As Long
          If s.AutoFilter Is Nothing Then
               On Error GoTo ErrCreateFilter
               Set r = Range(Cells(FB.FirstRow, FB.FirstColumn), Cells(LastUsedRow(), LastUsedColumn()))
               'r.Select ' Debug
               r.AutoFilter
               On Error GoTo 0
          End If
          Set r = s.Range(s.AutoFilter.Range.Address)
          If FB.OverwriteExisting Then DisableFiltersInSheet s  ' Disable the active filter
          On Error GoTo Err_UBound_EndFilterLoop
          For i = 0 To UBound(.Filters)
              On Error GoTo 0
              With .Filters(i)
                 If .Enabled Then
                    If .Operator = 0 Then .Operator = xlOr        ' Achtung Operator = 0 darf nicht vorkommen. Das passiert aber z.B. beim Datumsfilter
                    On Error GoTo ErrSetFilter
                    If IsEmpty(.Criteria2) Then
                          r.AutoFilter Field:=.Column - FB.FirstColumn + 1, Criteria1:=.Criteria1, Operator:=.Operator
                    Else: r.AutoFilter Field:=.Column - FB.FirstColumn + 1, Criteria1:=.Criteria1, Operator:=.Operator, Criteria2:=.Criteria2  ' Geht das auch mit arrays
                    End If
                    On Error GoTo 0
                 End If
              End With
          Next i
      End If
  End With
EndFilterLoop:
  
  '*** Hidden Columns ***
  With FB
     If .EnableColumnHiding Then
        On Error GoTo ErrHiding
        If FB.ShowAllOtherColumns Then s.Cells.EntireColumn.Hidden = False
        On Error GoTo Err_EndHiddenColsLoop
        For i = 0 To UBound(.HiddenCols)
            On Error GoTo 0
            With .HiddenCols(i)
               If .Enabled Then
                  s.Columns(.Column).EntireColumn.Hidden = True
                  ' ToDo: Evtl. pr|fffd|fung der Spalten|fffd|berschrift
               End If
            End With
        Next i
     End If
  End With
EndHiddenColsLoop:

  If FB.Save_ColWidth Then
     Dim Col As Long, ColWidth As Variant
     Col = 1
     For Each ColWidth In Split(FB.ColWidthList, Separator)
       s.Columns(Col).ColumnWidth = Replace(ColWidth, ",", ".") ' 28.02.18: Added: Replace(...) to prevent problems with a german komma
       Col = Col + 1
    Next ColWidth
  End If
  
  If RestoreActiveCell Then
     OldActCell.Select
  End If
  
  Application.ScreenUpdating = OldUpdate
  Exit Sub
  
'eeeeeeeeeeeeeeeeeeeeeeeeeee Error routines eeeeeeeeeeeeeeee

ErrCreateFilter:
  MsgBox "Error: The current sheet doesn't contain an autofilter" & vbCr & _
         "and the program wasn't able to define a filter for row:" & FB.FirstRow & ", col:" & FB.FirstColumn & vbCr & _
         "Check if the range is empty." & vbCr & _
         vbCr & _
         "The filter section is skipped. ", vbCritical, "No auto filter available and not able to create it"
  On Error GoTo 0
  Resume EndFilterLoop ' DON'T use goto at this point because then the next "On Error goto" doesn't work


Err_UBound_EndFilterLoop:
  D_Print D_ERROR, "Error in UBound(.Filters) detected ;-( Aborting loop"
  On Error GoTo 0
  Resume EndFilterLoop


ErrSetFilter:
  With FB.Filters(i)
    MsgBox "Error: setting filter for column " & ColumnLettersFromNr(.Column - FB.FirstColumn + 1) & ": '" & .Name & "'" & vbCr & _
           vbCr & _
           "Check if the filter conditions match with the stored filter." & vbCr & _
           "Check if the sheet is protected." & vbCr & _
           vbCr & _
           "The filter section is skipped. ", vbCritical, "Error setting filter"
  End With
  On Error GoTo 0
  Resume EndFilterLoop  ' DON'T use goto at this point because then the next "On Error goto" doesn't work
    
Err_EndHiddenColsLoop:
  D_Print D_ERROR, "Error in UBound(.HiddenCols) detected ;-( Aborting loop"
  On Error GoTo 0
  Resume EndHiddenColsLoop
    
ErrHiding:
  MsgBox "Error: hiding / unhiding columns !" & vbCr & _
         vbCr & _
         "Check if the filter conditions match with the stored filter." & vbCr & _
         "Check if the sheet is protected." & vbCr & _
         vbCr & _
         "The column hidung section is skipped. ", vbCritical, "Error hiding columns"
  On Error GoTo 0
  Resume EndHiddenColsLoop ' DON'T use goto at this point because then the next "On Error goto" doesn't work
  
End Sub


'UT------------------------------------
Private Sub Test_Get_Get_Excel_Filter()
'UT------------------------------------
  Dim ActFilter As FilterButton_T
  If Get_Excel_Filter(ActiveSheet, ActFilter, True) Then                    ' Read the active filter from the excel sheet
        DisableFiltersInSheet ActiveSheet
        
        ActiveSheet.Cells.AutoFilter
        MsgBox "Filters are disabled"
        
        Activate_Filter ActFilter, ActiveSheet   ' Activate the filter again
        
        MsgBox "And enabled again"
  Else: MsgBox "No filters active"
  End If
End Sub

'------------------------------------------
Public Sub Expand_Filter_to_all_used_Rows()
'------------------------------------------
  Dim ActFilter As FilterButton_T
  If Get_Excel_Filter(ActiveSheet, ActFilter, True) Then  ' Read the active filter from the excel sheet
       DisableFiltersInSheet ActiveSheet        ' Show all lines
       ActiveSheet.Cells.AutoFilter             ' Disable the auto filter filter
       Activate_Filter ActFilter, ActiveSheet   ' Activate the filter again using all rows
  Else ' No filter active
       If ActiveSheet.AutoFilterMode Then
          ActiveSheet.Cells.AutoFilter             ' Disable the auto filter filter
          Range(Cells(ActFilter.FirstRow, ActFilter.FirstColumn), Cells(LastUsedRow, LastUsedColumn)).AutoFilter
       End If
  End If
End Sub

Attribute VB_Name = "M20_PageEvents_a_Functions"
' Update several cells in the DCC and Selectrix sheet by events
' - Set/delete the Enable hook
' - Toggle the Input Typ
' - Calculate the Start LedNr
' - Format new lines
' -

Option Explicit
    
Private PriorCell As Range


'---------------------------------------------------------------------------------
Private Function Get_Parameter_from_Leds_Line(ByVal Line As String, ParNr As Long)
'---------------------------------------------------------------------------------
  If Left(Line, 1) = "^" Then
     Line = Trim(Mid(Line, 2, 200))
  End If
  
  If Left(Line, 1) <> "C" Then
     MsgBox "Fehler: LEDs Eintrag muss mit 'C' beginnen", vbCritical, "Fehler in LEDs Eintrag"
     EndProg
  End If
  
  Dim Parts As Variant, Error As Boolean
  Parts = Split(Mid(Line, 2, 200), "-")
  If UBound(Parts) <> 1 Then
     Error = 1
  ElseIf Not IsNumeric(Parts(0)) Or Not IsNumeric(Parts(1)) Then
     Error = 1
  End If
  If Error Then
     MsgBox "Fehler: LEDs Eintrag muss zwei mit '-' getrennte Kan|fffd|le enthalten", vbCritical, "Fehler in LEDs Eintrag"
     EndProg
  End If
  
  Get_Parameter_from_Leds_Line = Val(Parts(ParNr))
End Function

'---------------------------------------------------------------------------------------------
Private Sub Update_LastUsedChannel_in_Row(ByVal Line As String, ByRef LastusedChannel As Long)
'---------------------------------------------------------------------------------------------
  Line = Trim(Line)
  Dim Val As Long
  Val = Get_Parameter_from_Leds_Line(Line, 1)
  If Val > LastusedChannel Then LastusedChannel = Val
End Sub

'--------------------------------------------------------------------------------
Public Sub Update_LastUsedChannel(Leds As String, ByRef LastusedChannel As Long)
'--------------------------------------------------------------------------------
  If InStr(Leds, vbLf) Then
        Dim Line As Variant
        For Each Line In Split(Leds, vbLf)
           Update_LastUsedChannel_in_Row Line, LastusedChannel
        Next Line
  Else: Update_LastUsedChannel_in_Row Leds, LastusedChannel
  End If
End Sub

'---------------------------------------------------
Public Function Get_FirstUsedChannel(Leds As String)
'---------------------------------------------------
  If InStr(Leds, vbLf) Then
        Dim Line As Variant
        Get_FirstUsedChannel = 99
        For Each Line In Split(Leds, vbLf)
           Dim Val As Long
           Val = Get_Parameter_from_Leds_Line(Line, 0)
           If Val < Get_FirstUsedChannel Then Get_FirstUsedChannel = Val
        Next Line
  Else: Get_FirstUsedChannel = Get_Parameter_from_Leds_Line(Leds, 0)
  End If
End Function

'-------------------------------------------------
Private Function UsedModules(Leds As Long) As Long
'-------------------------------------------------
  Dim D As Double
  D = Leds / 3
  If D = Round(D) Then
        UsedModules = D
  Else: UsedModules = Round(D + 0.5, 0)
  End If
End Function

'-------------------------------------------------------
Public Function Check_IsSingleChannelCmd(Leds As String)
'-------------------------------------------------------
  Check_IsSingleChannelCmd = InStr(Leds, "C") > 0
End Function


'---------------------------------------------------
Public Function Row_is_Achtive(r As Long) As Boolean
'---------------------------------------------------
  Row_is_Achtive = Rows(r).EntireRow.Hidden = False And Cells(r, Enable_Col) <> "" And Trim(Cells(r, LEDs____Col)) <> ""
End Function


' Update_Start_LedNr() Berechnet die StartLedNr anhand der vorangegangenen
' Start Nummer und der LEDs der vorangegangenen Zeile.
' Die StartLedNr wird zu bei der Bearbeitung der Zeilen zu beginn
' in das Excel Sheet geschrieben und anschlie|fffd|end die interne Variable f|fffd|r die n|fffd|chste Zeile erh|fffd|ht.

' Zeilen welche einzelne LEDs ansprechen (C1, C2, ...) m|fffd|ssen anders behandelt werden.
' Hier wird StartLedNr dann erh|fffd|ht wenn die neue Zeile:
' - einen LED Kanal anspricht der kleiner ist als der letzte LED Kanal
' - alle Kan|fffd|le anspricht (C_ALL, House(), ...)
' Die |fffd|berpr|fffd|fung muss also vor dem schreiben der StartLedNr gemacht werden.

'------------------------------
Public Sub Update_Start_LedNr()
'------------------------------
' Update the Start LedNr in all used rows

  Make_sure_that_Col_Variables_match

  Dim Row As Variant, LedNr As Long, LastusedChannel As Long
  For Each Row In ActiveSheet.UsedRange.Rows
     Dim r As Long
     r = Row.Row
'     If r = 16 Then                ' Debug
'        Debug.Print "Row=" & r     ' Debug  (Set Breakpoint to this line)
'     End If                        ' Debug
     With Cells(r, LED_Nr__Col)
        If r >= FirstDat_Row Then
            'If Row.EntireRow.Hidden = False And Cells(Row.Row, Enable_Col) <> "" And Trim(Cells(r, LEDs____Col)) <> "" Then
            If Row_is_Achtive(r) Then
               Dim Leds As String, IsSingleChannelCmd As Boolean
               Leds = Trim(Cells(r, LEDs____Col))
               IsSingleChannelCmd = Check_IsSingleChannelCmd(Leds)
               
               ' Check if the privios lines adress single channels
               If LastusedChannel > 0 Then
                  If IsSingleChannelCmd Then
                     If Left(Leds, 1) = "^" Then LastusedChannel = 0
                     If Get_FirstUsedChannel(Leds) <= LastusedChannel Then
                        LedNr = LedNr + UsedModules(LastusedChannel)
                        LastusedChannel = 0
                     End If
                  Else ' Last lines have been single channel lines, but the actual line adresses full RGB LEDs
                     LedNr = LedNr + UsedModules(LastusedChannel)
                     LastusedChannel = 0
                  End If
               End If
               
               If .Value = "" Or .Value <> LedNr Then .Value = LedNr
               If IsSingleChannelCmd Then
                    Update_LastUsedChannel Leds, LastusedChannel
               Else
                    LedNr = LedNr + CellLinesSum(Leds) ' If the cell consists of several lines the sum is calculated
               End If
            Else
               If .Value <> "" Then .Value = ""
            End If
        End If
     End With
  Next Row
  Cells(1, LED_Nr__Col) = LedNr + UsedModules(LastusedChannel) ' Needed for the NUM_LEDS definition (Not visible because it's printed in white)
End Sub


'-------------------------------------------------------------
Private Function FirstNotFormatedRow(StartRow As Long) As Long
'-------------------------------------------------------------
' Find the first row where the Enable_Col doesn't use the font "Wingdings"
' The search starts with the giveb row and searches upwards.
' Return 0 if the StartRow is already formated
  Dim Row As Long
  If Cells(StartRow, Enable_Col).Font.Name = "Wingdings" Then
     Exit Function
  End If
  
  Row = StartRow
  While Cells(Row, Enable_Col).Font.Name <> "Wingdings" And Row > FirstDat_Row
    Row = Row - 1
  Wend

  FirstNotFormatedRow = Row
End Function


'--------------------------------------------------------------------------------------------------------------------
Public Sub Format_Cells_to_Row(Row As Long, Optional UpdateAutofilter As Boolean = True, Optional AllRows As Boolean)
'--------------------------------------------------------------------------------------------------------------------
' Formating the unformated rows
' - Wingdings in the Enable column and centeres in both directions
' - For all other columns the horizontal alignement is copied fron the Head line
'   and the vertical alignement is XlTop
' - Border lines

  Dim FirstNFormRow As Long
  If AllRows Then
        FirstNFormRow = FirstDat_Row
  Else: FirstNFormRow = FirstNotFormatedRow(Row)
  End If
  
  If FirstNFormRow > 0 Then
    'Debug.Print "Formating rows " & FirstNFormRow & " to " & Row ' Debug
    With Range(Cells(FirstNFormRow, Enable_Col), Cells(Row, Enable_Col))
      .Font.Name = "Wingdings" ' Enable column
      .VerticalAlignment = xlCenter
      .HorizontalAlignment = xlCenter
    End With
    Dim C As Long
    For C = Enable_Col + 1 To LastUsedColumn
        With Range(Cells(FirstNFormRow, C), Cells(Row, C))
          '.Select ' Debug
          .HorizontalAlignment = Cells(Headder_Row, C).HorizontalAlignment
          .VerticalAlignment = xlTop
          
          'If C = LEDs____Col Then .NumberFormat = "@" ' Text format to be able to enter "1-2"
          
          If C = DCC_or_CAN_Add_Col Or _
             C = SX_Channel_Col Then .NumberFormat = "@" ' Text format to be able to enter "1-2"
          If C = Config__Col Then .Font.Name = "Consolas"
          
          If C = DCC_or_CAN_Add_Col Then .WrapText = True
           
          ' Gray background
          Select Case C
             Case Config__Col, _
                  LED_Nr__Col, _
                  LEDs____Col, _
                  InCnt___Col, _
                  LocInCh_Col: With .Interior
                                 .ThemeColor = xlThemeColorDark1
                                 .TintAndShade = -4.99893185216834E-02
                               End With
          End Select

        End With
    Next
    All_Borderlines Range(Cells(FirstNFormRow, Enable_Col), Cells(Row, LastUsedColumn))
    
    If UpdateAutofilter Then Expand_Filter_to_all_used_Rows
    'If UpdateAutofilter Then AutofilterAllColumns Row ' Deletes the filter settings ;-(
  End If
End Sub


'---------------------------
Public Sub Format_All_Rows()
'---------------------------
  Make_sure_that_Col_Variables_match
  Format_Cells_to_Row LastUsedRow(), True, True
End Sub

'---------------------------
Public Sub Update_Sum_Func()
'---------------------------
' The Sum function in the filter column is used to detect changes in the autofilter
'  to update the "Start LedNr"
  Cells(SH_VARS_ROW, Filter__Col).FormulaR1C1 = "=SUM(R[1]C:R[" & LastUsedRow() & "]C)"
End Sub

'------------------------------------------------------
Private Function Col_is_in_Range(C As Long, r As Range)
'------------------------------------------------------
  Col_is_in_Range = C >= r.Column And C <= r.Column + r.Columns.Count
End Function

'-----------------------------------------------------
Private Function Range_is_Empty(r As Range) As Boolean
'-----------------------------------------------------
  Dim C As Variant
  For Each C In r
     If C <> "" Then Exit Function
  Next C
  Range_is_Empty = True
End Function

'------------------------------------------------------
Public Sub Select_Typ_by_Dialog(Target As Excel.Range)
'------------------------------------------------------
  Dim OldEvents As Boolean
  OldEvents = Application.EnableEvents
  Application.EnableEvents = False
  Target.Select
  If Page_ID = "Selectrix" Then
       UserForm_Select_Typ_SX.SetFocus Target
       UserForm_Select_Typ_SX.Show
  Else ' "DCC", "CAN"
       UserForm_Select_Typ_DCC.SetFocus Target
       UserForm_Select_Typ_DCC.Show
  End If
  Application.EnableEvents = True ' Enable to update the Address column
  If Userform_Res <> "" Then Target = Userform_Res
  Application.EnableEvents = OldEvents
End Sub

'----------------------------------------------------------------------------------------
Public Sub Complete_Typ(Target As Excel.Range, Optional DialogIfEmpty As Boolean = False)
'----------------------------------------------------------------------------------------
  If Len(Target) = 0 Then
     If DialogIfEmpty Then Select_Typ_by_Dialog Target
     Exit Sub
  End If
  Dim Txt As String
  If Page_ID = "Selectrix" Then
     If UCase(Left(Target, 1)) = "T" Then Txt = "Tast"
  Else ' "DCC", "CAN"
     If UCase(Left(Target, 1)) = "R" Then Txt = "Rot"
     If UCase(Left(Target, 1)) = "G" Then Txt = "Gr|fffd|n"
  End If
  If UCase(Left(Target, 1)) = "A" Then Txt = "AnAus"
  
  If Txt <> "" Then
        Target = Txt
  Else: Select_Typ_by_Dialog Target
  End If
End Sub


'----------------------------------------------------
Private Function AutofilterAllColumns(EndRow As Long)
'----------------------------------------------------
' Activate the autofilter for all columns
  With Range(Cells(Headder_Row, Enable_Col), Cells(EndRow, LastUsedColumn))
    If ActiveSheet.AutoFilterMode Then ' already there
        With .Cells
            .AutoFilter ' remove it
            .AutoFilter ' put it back
        End With
    Else
        .Cells.AutoFilter ' first time
    End If
  End With
End Function

'-------------------------------
Private Sub Correct_Autofilter()
'-------------------------------
' Call this manualy in case the filter is corrupted
  AutofilterAllColumns LastUsedRow
End Sub


'-----------------------------
Private Sub Move_Active_Cell()
'-----------------------------
  If Not PriorCell Is Nothing Then
     If PriorCell.Row = ActiveCell.Row Then
        Dim Delta As Long
        Delta = ActiveCell.Column - PriorCell.Column
        If Abs(Delta) = 1 Then
           Range(ActiveCell.Address).Offset(0, Delta).Activate
           Exit Sub
        End If
     End If
  End If
  Range(ActiveCell.Address).Offset(0, 1).Activate
End Sub

'----------------------------------------------
Private Sub Proc_Typ_Col(Target As Excel.Range)
'----------------------------------------------
' Open the Typ Dialog if the "DCC Adresse" or "Bitposition" Cell is filled
' but the "Typ" cell is empty
  Dim RefCol As Long
  Select Case Page_ID
    Case "DCC", "CAN": RefCol = DCC_or_CAN_Add_Col
    Case "Selectrix":  RefCol = SX_Bitposi_Col
    Case Else:         MsgBox "Internal error: Unknown Page_ID in 'Proc_Typ_Col'", vbCritical
                       EndProg
  End Select

  If Cells(Target.Row, RefCol) <> "" And Target = "" Then
     Select_Typ_by_Dialog Target
     Move_Active_Cell
  End If
End Sub

'-----------------------------------------------------
Private Sub Hide_Unhide_Selected_Rows(Hide As Boolean)
'-----------------------------------------------------
' Is called if rows are hidden or unhiden by event|fffd|
   Dim OldUppdating As Boolean, OldEvents As Boolean
   OldUppdating = Application.ScreenUpdating
   Application.ScreenUpdating = False
   OldEvents = Application.EnableEvents
   Application.EnableEvents = False
    
   Selection.EntireRow.Hidden = Hide
    
   Update_Start_LedNr ' Update the LedNr
    
   Application.EnableEvents = OldEvents
   Application.ScreenUpdating = OldUppdating
End Sub

'----------------------------
Public Sub myHideRows_Event()
'----------------------------
' Is called on event if rows are hidden
' Must be enabled in Workbook_Open() which is located in "DieseArbeismappe"
  Hide_Unhide_Selected_Rows True
End Sub

'------------------------------
Public Sub myUnhideRows_Event()
'------------------------------
' Is called on event if rows are shown
' Must be enabled in Workbook_Open() which is located in "DieseArbeismappe"
  Hide_Unhide_Selected_Rows False
End Sub

'-------------------------
Public Sub Option_Dialog()
'-------------------------
  'MsgBox "Der Optionsdialog ist noch nicht fertig ;-(", vbInformation, "ToDo"
  UserForm_Options.Show
End Sub


'----------------------
Public Sub ClearSheet()
'----------------------
  If MsgBoxMov("Wollen Sie alle Eintr|fffd|ge dieser Seite l|fffd|schen?", vbQuestion + vbYesNo, "Seite L|fffd|schen?") = vbYes Then
     Dim OldUppdating As Boolean, OldEvents As Boolean
     OldUppdating = Application.ScreenUpdating
     Application.ScreenUpdating = False
     OldEvents = Application.EnableEvents
     Application.EnableEvents = False
     
     Make_sure_that_Col_Variables_match
     Rows(FirstDat_Row & ":" & LastUsedRow).ClearContents ' Hidden Rows are also cleared
     Rows(FirstDat_Row & ":" & LastUsedRow).Hidden = False
     Rows("33:" & LastUsedRow()).Delete Shift:=xlUp
     
     Cells(FirstDat_Row, Descrip_Col).Select
     
     Application.EnableEvents = OldEvents
     Application.ScreenUpdating = OldUppdating
  End If
End Sub

'---------------------
Public Sub Show_Help()
'---------------------
  Application.EnableEvents = True ' In case of a previous crash this button enables the events again
  'MsgBox "Not finished", vbInformation, "Help"
  Dim Name As String
  Name = ThisWorkbook.Path & "\Prog_Generator_MobaLedLib.pdf"
  If Dir(Name) = "" Then
        MsgBox "Fehler: Die Hilfe Datei fehlt:" & vbCr & _
               "  '" & Name & "'", vbCritical, "Hilfe Datei wurde nicht gefunden"
  Else: Shell "Explorer " & Name
  End If
End Sub


'----------------------------------------------------------------------------------------
Public Sub Proc_DoubleCkick(ByVal sh As Object, ByVal Target As Range, Cancel As Boolean)
'----------------------------------------------------------------------------------------
  Make_sure_that_Col_Variables_match
  If Is_Data_Sheet(ActiveSheet) Then
     If Target.Row >= FirstDat_Row Then
        Select Case Target.Column
          Case Config__Col: SelectMacros
          Case Inp_Typ_Col: Select_Typ_by_Dialog Target
        End Select
     End If
  End If
End Sub

'------------------------------------
Public Sub Arduino_Button_StartPage()
'------------------------------------
   UserForm_Protokoll_Auswahl.Show
End Sub


' Typ  InCnt Start - End
' ~~~~ ~~~~~ ~~~~~~~~~
' Rot   1    1 - 1
' Gr|fffd|n  1    1 - 1
' Rot   2    1 - 1
' Gr|fffd|n  2    1 - 2
' Rot   3    1 - 2
' Gr|fffd|n  3    1 - 2
' Rot   4    1 - 2
' Gr|fffd|n  4    1 - 3

' Selextrix
' BitPos InCnt  End  Int(End/8) EndMod8 IncAddr
' 5       3     7    0          7       0
' 6       3     8    1          0       0
' 7       3     9    1          1       1
' 7       4    10    1          2       1
' 7       8    15

'-----------------------------------------------------
Private Sub Complete_Addr_Column_with_InCnt(r As Long)
'-----------------------------------------------------
' Is called by event if the DCC address or the Selectric chanel is changed
  Dim Target As Range
  Set Target = Cells(r, DCC_or_CAN_Add_Col + SX_Channel_Col) ' Add both columns because the not used is 0
  'Debug.Print "Complete_Addr_Column_with_InCnt"
  Dim InCnt As Long
  InCnt = Val(Cells(r, InCnt___Col))
  If InCnt > 0 Then
     Dim Addr As String
     Addr = Get_First_Number_of_Range(r, Target.Column)
     If Addr <> "" And Val(Addr) >= 0 Then
        Dim Inp_Typ As String, SBit_Str As String, EBit_Str As String
        SBit_Str = ""
        EBit_Str = ""
        Inp_Typ = Cells(r, Inp_Typ_Col)
        If Inp_Typ <> "" Then
           Dim i As Long, EndAddr As Long, EBit_Pos As Long
           If Page_ID = "Selectrix" Then
                Dim BitPos As Long
                BitPos = Val(Cells(r, SX_Bitposi_Col))
                If BitPos > 0 And BitPos <= 8 Then
                   EBit_Pos = BitPos + InCnt - 1
                   EndAddr = Addr + Int(EBit_Pos / 8)
                   
                   If EBit_Pos Mod 8 = 0 Then
                         EBit_Str = ".8": EndAddr = EndAddr - 1
                   Else: EBit_Str = "." & EBit_Pos Mod 8
                   End If
                   SBit_Str = "." & BitPos
                End If
           Else ' DCC
                If Inp_Typ = "Rot" Or Inp_Typ = "Gr|fffd|n" Then
                    EndAddr = Addr
                    For i = 1 To InCnt                         ' Unelegant
                        Inp_Typ = Get_Next_Typ(Inp_Typ)
                        If Inp_Typ = "Rot" And i < InCnt Then EndAddr = EndAddr + 1
                    Next i
                Else: EndAddr = Addr + InCnt - 1
                End If
           End If
        End If
        If Addr <> EndAddr And EndAddr <> 0 Or (InCnt > 1 And EBit_Str <> "") Then
              Target = Addr & SBit_Str & " - " & EndAddr & EBit_Str
        Else: Target = Addr
        End If
     End If
  End If
End Sub




'-----------------------------------------------------------------------
Public Sub Global_Worksheet_SelectionChange(ByVal Target As Excel.Range)
'-----------------------------------------------------------------------
' Is called by event if the worksheet selection has changed
  If Target.Row >= FirstDat_Row And Target.Row <= LastUsedRow() Then
     If Target.Count = 1 Then
        Make_sure_that_Col_Variables_match
        Application.EnableEvents = False ' Prevent calling the event multible times
        If DEBUG_CHANGEEVENT Then Debug.Print Format(time, "hh.mm.ss") & " SelectionChange" ' Debug
        
        Select Case Target.Column
           Case Enable_Col:  ' Enable / Disable the line
                             If Target.Value = "" Then
                                   Target.Value = ChrW(Hook_CHAR)
                             Else: Target.Value = ""
                             End If
                             BeepThis2 "Windows Balloon.wav"
                            
                             Update_Start_LedNr
                             Range(ActiveCell.Address).Offset(0, 1).Activate
           Case Inp_Typ_Col: Proc_Typ_Col Target
           Case Config__Col: ' Configuration column
                             If Target = "" And Not First_Change_in_Line(Target) Then SelectMacros
           Case LEDs____Col, _
                InCnt___Col, _
                LocInCh_Col: ' The LEDs, InCnt and Loc InCh columns should not be changed easyly It's only possible if it is selected from the right side
                             If PriorCell.Column <= Target.Column Then
                                Range(ActiveCell.Address).Offset(0, LEDs____Col - Target.Column - 1).Activate
                             End If
           
        End Select
        Set PriorCell = ActiveCell
        Application.EnableEvents = True
     End If
  End If
End Sub

' Problem:
' - Wenn eine Zelle Editiert wird und dann zu einem anderen Blatt gewechselt wird,
'   Dann wird der Global_Worksheet_Change Event ausgel|fffd|st.
'   Zu dem Zeitpunkt wurde aber bereits auf das neue Sheet umgeschaltet.
'   => Make_sure_that_Col_Variables_match erkennt ein anderes Sheet
'      Und die |fffd|nderungen am Urspr|fffd|nglichen Sheet k|fffd|nnen nicht mehr |fffd|berpr|fffd|ft werden
'
' - Wenn man Erkennt, das das Sheet gewechselt wurde, dann k|fffd|nnte man einfach zum alten Sheet
'   Zur|fffd|ck springen.


'--------------------------------------------------------------
Public Sub Global_Worksheet_Change(ByVal Target As Excel.Range)
'--------------------------------------------------------------
' This function is called if the worksheet is changed.
' It performs several checks after a user input depending form the column of the changed cell:

  Dim OldUppdating As Boolean, OldEvents As Boolean
  OldUppdating = Application.ScreenUpdating
  OldEvents = Application.EnableEvents
  Application.ScreenUpdating = False
  Application.EnableEvents = False
  
  Make_sure_that_Col_Variables_match Target
  
  Dim Row As Long
  Row = Target.Row
  If Target.CountLarge = 1 Then
       If Row >= FirstDat_Row Then
           If Target.Value <> "" And First_Change_in_Line(Target) Then
              Format_Cells_to_Row Row + SPARE_ROWS  ' Add some reserve lines
              Cells(Row, Enable_Col) = ChrW(Hook_CHAR) ' Must be set before the Start LEDNr is calculated
           End If
    
           Select Case Target.Column
              Case LED_Nr__Col, _
                   LEDs____Col:
                                   Update_Start_LedNr
              Case SX_Bitposi_Col: Complete_Addr_Column_with_InCnt Row
              Case Inp_Typ_Col:
                                   Complete_Typ Target
                                   Complete_Addr_Column_with_InCnt Row
              Case DCC_or_CAN_Add_Col, _
                   SX_Channel_Col: Complete_Addr_Column_with_InCnt Row
              Case InCnt___Col:    Complete_Addr_Column_with_InCnt Row
           End Select
       End If
  Else ' More than one cell was changed
       'If Target.Rows(1).Cells.Count <> MAX_COLUMNS _
          And Target.Columns(1).Cells.Count <> MAX_ROWS Then  ' Not a whole row/column because it would take long and we dont wan't to get the hook if lines are deleted
            ' Adapt the first row to fit in the data range
            Dim StartRow As Long
            StartRow = Row
            If StartRow < FirstDat_Row Then StartRow = FirstDat_Row
            
            ' Don't fill in hooks if cells in the enable column should be changed/deleted
            If Target.Columns(1).Cells.Count <> MAX_ROWS Then                  ' 26.09.19: Speed up deleeting whole columns
                If Not Col_is_in_Range(Enable_Col, Target) And Not Range_is_Empty(Target) Then
                   Range(Cells(StartRow, Enable_Col), Cells(Row + Target.Rows.Count - 1, Enable_Col)) = ChrW(Hook_CHAR) ' Must be set before the Start LEDNr is calculated
                End If
            End If
            
            ' Format new cells at the end
            Dim EndRow As Long: EndRow = Row + Target.Rows.Count - 1 + SPARE_ROWS
            If EndRow > LastUsedRow + SPARE_ROWS Then EndRow = LastUsedRow  ' Protection if whole columns are deleted
            If EndRow >= FirstDat_Row Then Format_Cells_to_Row EndRow
            Update_Start_LedNr
       'End If
  End If
  If DEBUG_CHANGEEVENT Then Debug.Print Format(time, "hh.mm.ss") & " Worksheet_Change " & Target.CountLarge ' Debug
  
  Application.EnableEvents = OldEvents
  Application.ScreenUpdating = OldUppdating
End Sub


'-------------------------------------
Public Sub Global_Worksheet_Activate()
'-------------------------------------
  If DEBUG_CHANGEEVENT Then Debug.Print ActiveSheet.Name & " Global_Worksheet_Activate event"
End Sub


'--------------------------------------
Public Sub Global_Worksheet_Calculate()
'--------------------------------------
  If DEBUG_CHANGEEVENT Then Debug.Print "Global_Worksheet_Calculate()" ' Debug
  Update_Start_LedNr
End Sub
Attribute VB_Name = "M22_Hide_UnHide"
Option Explicit


'----------------------------
Public Sub Proc_Hide_Unhide()
'----------------------------
' If th selected range is not in the Data range an error message is generated
' If there are hidden rows in the selected range the are unhidden
' Otherwise the selected range is hidden
  Dim OldScreenupdating As Boolean
  OldScreenupdating = Application.ScreenUpdating
  Application.ScreenUpdating = False


  Dim Row As Variant, DetectedHidden As Boolean
  For Each Row In Selection.Rows
     If Row.Row >= FirstDat_Row Then
        If Row.EntireRow.Hidden Then
           DetectedHidden = True
           Exit For
        End If
     End If
  Next Row
  
  Dim FirstHiddenRow As Long, LastHiddenRow As Long
  For Each Row In Selection.Rows
     If Row.Row >= FirstDat_Row Then
        If DetectedHidden And Row.EntireRow.Hidden Then
           If FirstHiddenRow = 0 Then FirstHiddenRow = Row.Row
           LastHiddenRow = Row.Row
        End If
        Row.EntireRow.Hidden = Not DetectedHidden
      End If
  Next Row
  
  If DetectedHidden Then
    Rows(FirstHiddenRow & ":" & LastHiddenRow).Select
  End If
  Update_Start_LedNr
  Application.ScreenUpdating = OldScreenupdating
End Sub

'---------------------------
Public Sub Proc_UnHide_All()
'---------------------------
  Dim OldScreenupdating As Boolean
  OldScreenupdating = Application.ScreenUpdating
  Application.ScreenUpdating = False

  Dim FirstHiddenRow As Long, LastHiddenRow As Long
  Dim Row As Variant
  For Each Row In ActiveSheet.UsedRange.Rows
     If Row.Row >= FirstDat_Row Then
        If Row.EntireRow.Hidden Then
           If FirstHiddenRow = 0 Then FirstHiddenRow = Row.Row
           LastHiddenRow = Row.Row
        End If
        Row.EntireRow.Hidden = False
     End If
  Next Row
      
  If FirstHiddenRow > 0 Then
    Rows(FirstHiddenRow & ":" & LastHiddenRow).Select
  End If
  
  Update_Start_LedNr
  Application.ScreenUpdating = OldScreenupdating
End Sub

Attribute VB_Name = "M23_Add_Move_Del_Row"
Option Explicit

Private Move_Info_Shown As Boolean


'-------------------------------------
Public Sub Used_Rows_All_Borderlines()
'-------------------------------------
  All_Borderlines Range(Cells(FirstDat_Row, Enable_Col), Cells(LastUsedRow, LastUsedColumn))
End Sub



'--------------------------------------------
Public Sub Proc_Insert_Line_Above(C As Range)
'--------------------------------------------
  Dim OldUpdating As Boolean
  OldUpdating = Application.ScreenUpdating
  Application.ScreenUpdating = False

  If C.Row = FirstDat_Row Then
      C.EntireRow.Insert Shift:=xlDown, CopyOrigin:=xlFormatFromRightOrBelow
  ElseIf C.Row > FirstDat_Row Then
     C.EntireRow.Insert Shift:=xlDown, CopyOrigin:=xlFormatFromLeftOrAbove
  End If
  Application.ScreenUpdating = OldUpdating
End Sub

'----------------------------
Public Sub Proc_Insert_Line()
'----------------------------
  Proc_Insert_Line_Above ActiveCell
End Sub

'------------------------
Public Sub Proc_Del_Row()
'------------------------
  If MsgBox("Mit dem 'L|fffd|sche Zeilen' Knopf k|fffd|nnen eine oder mehrere Zeilen gel|fffd|scht werden." & vbCr & _
            vbCr & _
            "Die zu l|fffd|schenden Zeilen markiert man mit der Maus oder Tastatur und der Gro|fffd|schreibetaste und bet|fffd|tigt den 'L|fffd|schen' Knopf. " & vbCr & _
            vbCr & _
            "Tipp:" & vbCr & _
            "Mit einem Klick auf den Haken an Anfang der Zeile k|fffd|nnen diese deaktiviert werden ohne sie gleich zu l|fffd|schen." & vbCr & _
            "Alternativ k|fffd|nnen Zeilen |fffd|ber den 'Aus- und Einblenden' Knopf versteckt werden. Unsichtbare Zeilen werden nicht in die Arduino Konfiguration |fffd|bernommen." & vbCr & _
            vbCr & _
            "Soll die Zeile tats|fffd|chlich gel|fffd|scht werden?", _
            vbYesNo + vbQuestion, "Zeile l|fffd|schen?") = vbNo Then Exit Sub
  
  Dim OldUpdating As Boolean
  OldUpdating = Application.ScreenUpdating
  Application.ScreenUpdating = False
  
  If ActiveCell.Row >= FirstDat_Row Then
     Selection.EntireRow.Delete Shift:=xlUp
     Update_Start_LedNr
     All_Borderlines Range(Cells(FirstDat_Row, Enable_Col), Cells(LastUsedRow + SPARE_ROWS, LastUsedColumn))
     Format_Cells_to_Row LastUsedRow
  End If
  
  Application.ScreenUpdating = OldUpdating
End Sub

'-------------------------
Public Sub Proc_Move_Row()
'-------------------------
  Dim ActSh As String
  ActSh = ActiveSheet.Name
  
  If Not Move_Info_Shown Then
     If MsgBox("Mit dem 'Verschiebe Zeilen' Knopf k|fffd|nnen eine oder mehrere Zeilen verschoben werden." & vbCr & _
            "Damit kann die Reihenfolge der Beleuchtungen oder der anderen Effekte an die physikalisch vorgegebene " & _
            "Anschlussreihenfolge angepasst werden." & vbCr & _
            vbCr & _
            "Die zu verschiebenden Zeilen markiert man mit der Maus oder Tastatur und der Gro|fffd|schreibetaste und bet|fffd|tigt den 'Verschieben' Knopf. " & _
            "Dann w|fffd|hlt man mit der Maus die neue Position der Zeilen. Eine Gr|fffd|ne Linie markiert dabei die Zielposition." & vbCr & _
            "Mit der 'ESC' Taste kann die Aktion abgebrochen werden." & vbCr & _
            vbCr & _
            "Achtung: Diese Meldung wird nur einmal pro Programmstart angezeigt.", _
            vbOKCancel, "Funktionsweise des 'Verschiebe Zeilen' Knopfes") = vbCancel Then Exit Sub
     Move_Info_Shown = True
  End If
  If ActiveCell.Row < FirstDat_Row Then
      MsgBox "Achtung: Zum verschieben von Zeilen m|fffd|ssen eine oder mehrere Zellen im Datenbereich der Tabelle markiert " & _
             "sein. Die entsprechenden Zeilen k|fffd|nnen dann per Maus verschoben werden." & vbCr & _
             vbCr & _
             "Der gew|fffd|hlte Bereich liegt (teilweise) au|fffd|erhalb des Datenbereichs", vbInformation, "Zu verschiebende Zeile muss im Datenbereich der Tabelle liegen"
      Exit Sub
  End If
  If Selection.Row >= FirstDat_Row Then
     On Error GoTo EnabButtons
     
     ActiveSheet.EnableDisableAllButtons False
     Dim Src As Range
     Set Src = Selection.EntireRow
     Src.Select
     Application.StatusBar = "Zeilen verschieben: Bitte Zielposition mit der Maus oder der Tastatur w|fffd|hlen"
     Dim DestRow As Long
     DestRow = Select_Move_Dest_by_Mouse(Enable_Col, LastUsedColumn) ' Show move Cursor and wait until button is pressed
     If DestRow > 0 Then
        Dim OldUpdating As Boolean, OldEvents As Boolean
        OldUpdating = Application.ScreenUpdating
        Application.ScreenUpdating = False
        OldEvents = Application.EnableEvents
        Application.EnableEvents = False                                    ' 26.09.19:
        
        If DestRow <> Src.Row Then
            Src.EntireRow.Cut
            Rows(DestRow & ":" & DestRow + Src.Rows.Count).Insert Shift:=xlDown
            Rows(DestRow & ":" & DestRow + Src.Rows.Count - 1).Select
            Update_Start_LedNr
        End If
        Used_Rows_All_Borderlines  ' Sometimes the borders get corrupted ;-(
        'Format_Cells_to_Row LastUsedRow
        Format_All_Rows
        Update_Sum_Func
        Application.ScreenUpdating = OldUpdating
        Application.EnableEvents = OldEvents                                ' 26.09.19:
     End If
     Application.StatusBar = ""
  End If
  
EnabButtons:
  Sheets(ActSh).EnableDisableAllButtons True
End Sub

'-------------------------
Public Sub Proc_Copy_Row()
'-------------------------
  Make_sure_that_Col_Variables_match
  Dim OldUpdating As Boolean, OldEvents As Boolean
  OldUpdating = Application.ScreenUpdating
  Application.ScreenUpdating = False
  OldEvents = Application.EnableEvents
  Application.EnableEvents = False
  
  If Selection.Row >= FirstDat_Row Then
     Dim DestRow As Long, i As Long, EndDestRow As Long
     DestRow = Selection.Row + Selection.Rows.Count
     
     For i = 1 To Selection.Rows.Count ' Insert lines
         Rows(DestRow).EntireRow.Insert Shift:=xlDown, CopyOrigin:=xlFormatFromLeftOrAbove
     Next i
     
     EndDestRow = DestRow + Selection.Rows.Count - 1
     Rows(DestRow & ":" & EndDestRow) = Selection.EntireRow.Value
     Range(Cells(DestRow, Selection.Column), Cells(EndDestRow, Selection.Column + Selection.Columns.Count - 1)).Select
     Used_Rows_All_Borderlines
     Format_Cells_to_Row DestRow + Selection.Rows.Count
     Update_Sum_Func
  End If
  Update_Start_LedNr
  Application.ScreenUpdating = OldUpdating
  Application.EnableEvents = OldEvents
End Sub
Attribute VB_Name = "M24_Mouse_Insert_Pos"
Option Explicit

' Example from
'  - http://www.herber.de/forum/archiv/1124to1128/1126102_GetKeyState_Taste_abfragen.html
'    http://www.herber.de/bbs/user/66853.xls
'  - https://stackoverflow.com/questions/47271141/vba-get-cursor-position-as-cell-address

' https://stackoverflow.com/questions/20269844/api-timers-in-vba-how-to-make-safe
#If VBA7 And Win64 Then    ' 64 bit Excel under 64-bit windows
                           ' Use LongLong and LongPtr
    Private Declare PtrSafe Function SetTimer Lib "User32" (ByVal hwnd As LongPtr, ByVal nIDEvent As LongPtr, ByVal uElapse As LongLong, ByVal lpTimerFunc As LongPtr) As LongLong
    Private Declare PtrSafe Function KillTimer Lib "User32" (ByVal hwnd As LongPtr, ByVal nIDEvent As LongPtr) As LongLong
    
    Private hTimer As LongPtr ' M|fffd|sste es hier nicht LongLong hei|fffd|en ?

#ElseIf VBA7 Then           ' 64 bit Excel in all environments
                            ' Use LongPtr only, LongLong is not available
    Private Declare PtrSafe Function SetTimer Lib "User32" (ByVal hwnd As LongPtr, ByVal nIDEvent As Long, ByVal uElapse As Long, ByVal lpTimerFunc As LongPtr) As LongPtr
    Private Declare PtrSafe Function KillTimer Lib "User32" (ByVal hwnd As LongPtr, ByVal nIDEvent As Long) As Long

    Private hTimer As LongPtr
    
#Else    ' 32 bit Excel
    Private Declare Function SetTimer Lib "User32" (ByVal hwnd As Long, ByVal nIDEvent As Long, ByVal uElapse As Long, ByVal lpTimerFunc As Long) As Long
    Private Declare Function KillTimer Lib "User32" (ByVal hwnd As Long, ByVal nIDEvent As Long) As Long

    Private hTimer As Long
#End If


#If VBA7 Then
  Public Declare PtrSafe Function GetAsyncKeyState Lib "User32" (ByVal vKey As Long) As Integer
  
  Private Declare PtrSafe Function GetCursorPos Lib "User32" (lpPoint As POINTAPI) As Long

  Private Declare PtrSafe Function SetCursorPos Lib "User32" (ByVal X As Long, ByVal y As Long) As Long
#Else
  Public Declare Function GetAsyncKeyState Lib "User32" (ByVal vKey As Long) As Integer
  
  Private Declare Function GetCursorPos Lib "User32" (lpPoint As POINTAPI) As Long

  Private Declare Function SetCursorPos Lib "User32" (ByVal X As Long, ByVal y As Long) As Long
#End If

' Create custom variable that holds two integers
Type POINTAPI
    Xcoord As Long
    Ycoord As Long
End Type

' https://docs.microsoft.com/en-us/windows/win32/inputdev/virtual-key-codes
Private Const VK_LBUTTON = &H1
Private Const VK_RBUTTON = &H2
Private Const VK_MBUTTON = &H4

Private Const VK_UP = &H26
Private Const VK_DOWN = &H28
Private Const VK_RETURN = &HD
Private Const VK_ESCAPE = &H1B

Private LeftMousePressed As Boolean
Private ESCButtonPressed As Boolean
Private EnterKey_Pressed As Boolean
Private LastRow As Long
Private Col1 As Long
Private ColN As Long

'------------------------
Sub MouseCheckTimerProc()
'------------------------
Dim Result%
KillTimer 0, hTimer

Result = GetAsyncKeyState(VK_LBUTTON)
If Result <> 0 Then LeftMousePressed = True

hTimer = SetTimer(0, 0, 50, AddressOf MouseCheckTimerProc)
End Sub


'---------------------------------------
Private Sub Show_Insert_Pos(Row As Long)
'---------------------------------------
  If Row > 0 Then
    With Range(Cells(Row, Col1), Cells(Row, ColN)).Borders(xlEdgeTop)
        .ThemeColor = 10
        .TintAndShade = -0.249977111117893
        .Weight = xlThick
    End With
  End If
End Sub

'----------------------------------------------------
Private Sub Normal_Line(sh As Worksheet, Row As Long)
'----------------------------------------------------
  With sh
    With .Range(.Cells(Row, Col1), .Cells(Row, ColN)).Borders(xlEdgeTop)
        .ColorIndex = 0
        .TintAndShade = 0
        .Weight = xlThin
    End With
  End With
End Sub

'-------------------------------------------------------
Private Function GetRange(X As Long, y As Long) As Range
'-------------------------------------------------------
  On Error Resume Next
    Set GetRange = ActiveWindow.RangeFromPoint(X, y)
  On Error GoTo 0
End Function

'--------------------------------------------------------------------------------------------------
Private Function Show_InsertLine_until_Mousepressed(MinRow As Long, SheetName As String) As Boolean
'--------------------------------------------------------------------------------------------------
    Dim llCoord As POINTAPI, rng As Range
    
    GetCursorPos llCoord ' Get the cursor positions
    'Debug.print "X Position: " & llCoord.Xcoord & vbNewLine & "Y Position: " & llCoord.Ycoord ' Display the cursor position coordinates
    
    DoEvents
    
    If GetAsyncKeyState(VK_ESCAPE) <> 0 Then ESCButtonPressed = True
    
    Dim MoveByKey As Boolean
    If GetAsyncKeyState(VK_UP) <> 0 Then MoveByKey = True
    If GetAsyncKeyState(VK_DOWN) <> 0 Then MoveByKey = True
    If GetAsyncKeyState(VK_RETURN) <> 0 Then EnterKey_Pressed = True
    
    If MoveByKey Then
          SetCursorPos ActiveWindow.ActivePane.PointsToScreenPixelsX(ActiveCell.Left + (ActiveCell.Width / 2)), _
              ActiveWindow.ActivePane.PointsToScreenPixelsY(ActiveCell.Top + (ActiveCell.Height / 2))
          Set rng = ActiveCell
    Else: Set rng = GetRange(llCoord.Xcoord, llCoord.Ycoord)
    End If
    
    Dim Row As Long
    If Not rng Is Nothing Then
       Row = rng.Row
       If Row < MinRow Then Row = MinRow
    End If
    

    If (Row <> 0 And Row <> LastRow) Or LeftMousePressed Or EnterKey_Pressed Or ESCButtonPressed Then
       Dim OldUpdating As Boolean
       OldUpdating = Application.ScreenUpdating
       Application.ScreenUpdating = False
       If LastRow > 0 Then Normal_Line Sheets(SheetName), LastRow
       If Row <> 0 Then LastRow = Row
       
       If LeftMousePressed Or EnterKey_Pressed Or ESCButtonPressed Or SheetName <> ActiveSheet.Name Then
             Show_InsertLine_until_Mousepressed = True ' Abort
       Else: Show_Insert_Pos Row
       End If
       Application.ScreenUpdating = OldUpdating
    End If
End Function

'-----------------------------------------------------------------------------------
Public Function Select_Move_Dest_by_Mouse(FirstCol As Long, LastCol As Long) As Long
'-----------------------------------------------------------------------------------
' End when Left Mouse, Enter or ESC is pressed
' Return the destination Row
' Return 0 if aborted with ESC
'
   Col1 = FirstCol
   ColN = LastCol
   
   hTimer = SetTimer(0, 0, 50, AddressOf MouseCheckTimerProc)
   LeftMousePressed = False
   EnterKey_Pressed = False
   ESCButtonPressed = False
   
   Dim ShName As String
   ShName = ActiveSheet.Name
   
   While Show_InsertLine_until_Mousepressed(FirstDat_Row, ShName) = False
   Wend
   
   KillTimer 0, hTimer
   
   If ActiveSheet.Name = ShName And (LeftMousePressed Or EnterKey_Pressed) Then
      Select_Move_Dest_by_Mouse = LastRow
   End If
End Function
Attribute VB_Name = "M25_Columns"
' Contains Variables which contain the column numbers for
' the date sheets (DCC/Selectrix)

Option Explicit
Option Compare Binary ' Use case sensitive compare.




Public Col_from_Sheet As String ' THe following ...Col variables have been read from this sheet

Public Filter__Col As Long
Public Inp_Typ_Col As Long
Public Start_V_Col As Long
Public Descrip_Col As Long
Public Dist_Nr_Col As Long
Public Conn_Nr_Col As Long
Public Config__Col As Long
Public LED_Nr__Col As Long
Public LEDs____Col As Long
Public InCnt___Col As Long
Public LocInCh_Col As Long

Public COMPort_COL As Long  ' This cell contains the COM Port of the LED Arduino
Public BUILDOP_COL As Long  ' This cell contains additional build options like "--board arduino:avr:nano:cpu=atmega328old"
Public R_UPLOD_COL As Long  ' Contains "OK" if the program of the right arduino was uploaded
Public COMPrtR_COL As Long  ' This cell contains the COM Port of the Right Arduino (DCC/Selectrix)
Public BUILDOpRCOL As Long  ' Additional build options for the right Arduino like "--board arduino:avr:nano:cpu=atmega328old"


'Only valid if the DCC or CAN Page is active
Public DCC_or_CAN_Add_Col As Long

'Only valid if the Selectrix Page is active
Public SX_Channel_Col As Long
Public SX_Bitposi_Col As Long

Public Page_ID As String

'------------------------------------------------------------------------------------------------------------------------
Public Sub Make_sure_that_Col_Variables_match(Optional Switch_back_Target As Excel.Range, Optional ByVal sh As Worksheet)
'------------------------------------------------------------------------------------------------------------------------
' Fills the global variables which contain the column numbers
  If sh Is Nothing Then Set sh = ActiveSheet

  If sh.Name = Col_from_Sheet Then Exit Sub ' Already read in => exit
  
  'Debug.Print "Updating the Col_Variables"
  
  If Not Switch_back_Target Is Nothing Then ' Check if the page has been changed while a cell was changed
     If Switch_back_Target.Parent.Name <> sh.Name Then
        Debug.Print "Switching back to " & Switch_back_Target.Parent.Name & " in Make_sure_that_Col_Variables_match()"
        On Error GoTo ErrSwitchBack
        Switch_back_Target.Parent.Select
        On Error GoTo 0
     End If
     Exit Sub
  End If
  
  Page_ID = sh.Cells(SH_VARS_ROW, PAGE_ID_COL)
          
  ' Sheet specific columns
  SX_Channel_Col = 0
  SX_Bitposi_Col = 0
  DCC_or_CAN_Add_Col = 0
  
  Select Case Page_ID
     Case "Selectrix":  SX_Channel_Col = FindHeadCol(sh, Headder_Row, "SX Channel [0..99]")
                        SX_Bitposi_Col = FindHeadCol(sh, Headder_Row, "Bitposition [1..8]")
     Case "DCC":        DCC_or_CAN_Add_Col = FindHeadCol(sh, Headder_Row, "DCC Adresse")
     Case "CAN":        DCC_or_CAN_Add_Col = FindHeadCol(sh, Headder_Row, "CAN Adresse")
     Case Else:         MsgBox "Fehler: Die Excel Seite wurde gewechselt w|fffd|hrend einer |fffd|nderung in einer Zelle. " & vbCr & _
                               "Die |fffd|nderungen k|fffd|nnen nicht |fffd|berpr|fffd|ft werden ;-(" & vbCr & _
                               vbCr & _
                               "Die Eingaben in einer Zelle m|fffd|ssen mit Enter abgeschlossen werden bevor die Seite gewechselt wird.", _
                               vbCritical, "Fehler: Seite gewechselt w|fffd|hrend der Eingabe in einer Zelle"
                        ' Normalerweise sollte diese Fehlermeldung nicht mehr kommen wenn Switch_back_to_Last_Sheet aktiv ist.
                        ' Wenn Col_from_Sheet = "" ist, dann kann es immer noch passiern
                        EndProg
  End Select
  Filter__Col = FindHeadCol(sh, Headder_Row, "Filter")
  Inp_Typ_Col = FindHeadCol(sh, Headder_Row, "Typ")
  Start_V_Col = FindHeadCol(sh, Headder_Row, "Start- wert")
  Descrip_Col = FindHeadCol(sh, Headder_Row, "Beschreibung")
  Dist_Nr_Col = FindHeadCol(sh, Headder_Row, "Verteiler- Nummer")
  Conn_Nr_Col = FindHeadCol(sh, Headder_Row, "Stecker- Nummer")
  Config__Col = FindHeadCol(sh, Headder_Row, "Beleuchtung, Sound, oder andere Effekte")
  LED_Nr__Col = FindHeadCol(sh, Headder_Row, "Start LedNr")
  LEDs____Col = FindHeadCol(sh, Headder_Row, "LEDs")
  InCnt___Col = FindHeadCol(sh, Headder_Row, "InCnt")
  LocInCh_Col = FindHeadCol(sh, Headder_Row, "Loc InCh")
  
  COMPort_COL = Inp_Typ_Col
  BUILDOP_COL = Descrip_Col
  R_UPLOD_COL = Dist_Nr_Col
  COMPrtR_COL = Conn_Nr_Col
  BUILDOpRCOL = Config__Col

  
  Col_from_Sheet = sh.Name
  Exit Sub
  
ErrSwitchBack:
  MsgBox "Interner Fehler: Die letzte Seite '" & Col_from_Sheet & "' konnte nicht aktiviert werden", vbCritical, "Interner Fehler"
  EndProg
End Sub


'-----------------------------------------------------------------------------
Public Function Get_First_Number_of_Range(Row As Long, Col As Long) As Variant
'-----------------------------------------------------------------------------
' Accepts also a address which contains two adressed separated by '-'
' Example: '1 - 3'
  Dim Addr As Variant
    
  Addr = Replace(Replace(Cells(Row, Col), vbLf, ""), " ", "")
  If Addr = "" Then
     Get_First_Number_of_Range = ""
     Exit Function
  End If
    
  If InStr(Addr, "-") > 0 Then
       Dim Parts As Variant
       Parts = Split(Addr, "-")
       If UBound(Parts) > 1 Then
             Get_First_Number_of_Range = -9            ' Generate an error message in the following routines
       Else: Get_First_Number_of_Range = Int(Val(Parts(0)))
       End If
  Else
       Get_First_Number_of_Range = Int(Val(Addr))
  End If
End Function
Attribute VB_Name = "M28_Diverse"
Option Explicit
  
'--------------------------------------------------------------
Public Function Is_Data_Sheet(ByVal sh As Worksheet) As Boolean
'--------------------------------------------------------------
  Is_Data_Sheet = (InStr(AllData_PgIDs, " " & sh.Cells(SH_VARS_ROW, PAGE_ID_COL) & " ") > 0)
End Function

'----------------------------
Public Sub EnableAllButtons()
'----------------------------
' Enable all buttons in case they have been disabled by a crash
  Dim sh As Variant
  For Each sh In ThisWorkbook.Sheets
      If Is_Data_Sheet(sh) Then
        sh.EnableDisableAllButtons True
      End If
  Next
End Sub


'-------------------------------------------------------------------
Private Sub Clear_COM_Port_Check(r As Range, ReleaseMode As Boolean)
'-------------------------------------------------------------------
' Set to a negativ number.
  With r
    If Not ReleaseMode And IsNumeric(.Value) Then
          .Value = -Abs(.Value)
    Else: .Value = "COM?"
    End If
  End With
End Sub

'-----------------------------------------------------------------------------------
Public Sub Clear_COM_Port_Check_ans_Set_Cursor_in_all_Sheets(ReleaseMode As Boolean)
'-----------------------------------------------------------------------------------
  Dim sh As Variant, OldSh As Worksheet, Skip_Scroll_Down As Boolean
  Set OldSh = ActiveSheet
  If ActiveSheet Is Nothing Then                                            ' 29.10.19:
     Debug.Print "ActiveSheet Is Nothing in Clear_COM_Port_Check_ans_Set_Cursor_in_all_Sheets"
     Debug.Print "Tritt beim ersten Start nach dem Download vom Internet auf ('Gesch|fffd|tzte Ansicht')"
     Skip_Scroll_Down = True
  End If
  For Each sh In ThisWorkbook.Sheets
      If Is_Data_Sheet(sh) Then
        With sh
          Make_sure_that_Col_Variables_match sh:=sh
          Clear_COM_Port_Check .Cells(SH_VARS_ROW, COMPort_COL), ReleaseMode
          
          If sh.Cells(SH_VARS_ROW, PAGE_ID_COL) <> "CAN" Then
            Clear_COM_Port_Check .Cells(SH_VARS_ROW, COMPrtR_COL), ReleaseMode
            If ReleaseMode Then .Cells(SH_VARS_ROW, R_UPLOD_COL) = "R not Chk" ' Right arduino software ist not checked
          End If
          If Not Skip_Scroll_Down Then                                      ' 29.10.19:
             Dim LRow As Long
             sh.Select                                                      ' 29.10.19:
             sh.Cells(FirstDat_Row, Descrip_Col).Select ' Scroll to the top
             LRow = LastFilledRowIn_ChkAll(sh) + 1
             .Cells(LRow + 1, Descrip_Col).Select     ' Select the first empty row
             'While .Rows(LRow).EntireRow.Hidden                            ' 29.10.19: Disabled
             '   LRow = LRow + 1
             'Wend
          End If
        End With
      End If
  Next
  If Not OldSh Is Nothing Then OldSh.Select
End Sub

'-------------------------------------------------------------
Public Function Get_Bool_Config_Var(Name As String) As Boolean
'-------------------------------------------------------------
  On Error GoTo NotFound
  With ThisWorkbook.Sheets(ConfigSheet).Range(Name)
    Select Case UCase(Left(Trim(.Value), 1))
       Case "", "N":  Get_Bool_Config_Var = False
       Case Else:     Get_Bool_Config_Var = True
    End Select
  End With
  Exit Function
  
NotFound:
  MsgBox "Interner Fehler: Die Konfigurationsvariable '" & Name & "' wurde nicht im Sheet '" & ConfigSheet & "' gefunden", _
         vbCritical, "Interner Fehler in Get_Bool_Config_Var"
  EndProg
End Function

'UT----------------------------------
Private Sub TestGet_Bool_Config_Var()
'UT----------------------------------
  Debug.Print "Get_Bool_Config_Var=" & Get_Bool_Config_Var("Lib_Installed_other")
End Sub

'-------------------------------------------------------------
Public Sub Set_Bool_Config_Var(Name As String, Val As Boolean)
'-------------------------------------------------------------
  On Error GoTo NotFound
  With ThisWorkbook.Sheets(ConfigSheet).Range(Name)
    If Val Then
          .Value = "Ja"
    Else: .Value = "Nein"
    End If
  End With
  Exit Sub
  
NotFound:
  MsgBox "Interner Fehler: Die Konfigurationsvariable '" & Name & "' wurde nicht im Sheet '" & ConfigSheet & "' gefunden", _
         vbCritical, "Interner Fehler in Set_Bool_Config_Var"
  EndProg
End Sub

'--------------------------------------------------------------
Public Function Get_String_Config_Var(Name As String) As String
'--------------------------------------------------------------
  On Error GoTo NotFound
  Get_String_Config_Var = ThisWorkbook.Sheets(ConfigSheet).Range(Name)
  Exit Function
  
NotFound:
  MsgBox "Interner Fehler: Die Konfigurationsvariable '" & Name & "' wurde nicht im Sheet '" & ConfigSheet & "' gefunden", _
         vbCritical, "Interner Fehler in Get_String_Config_Var"
  EndProg
End Function

'--------------------------------------------------------------
Public Sub Set_String_Config_Var(Name As String, Val As String)
'--------------------------------------------------------------
  On Error GoTo NotFound
  ThisWorkbook.Sheets(ConfigSheet).Range(Name) = Val
  Exit Sub
  
NotFound:
  MsgBox "Interner Fehler: Die Konfigurationsvariable '" & Name & "' wurde nicht im Sheet '" & ConfigSheet & "' gefunden", _
         vbCritical, "Interner Fehler in Set_String_Config_Var"
  EndProg
End Sub


Attribute VB_Name = "M30_Tools"
Option Explicit

' Module Description:
' ~~~~~~~~~~~~~~~~~~~
' This module contains general tools.

' Overview 32 / 64 Bit functions: https://jkp-ads.com/Articles/apideclarations.asp

#If VBA7 Then 'For 64 Bit Systems
    Public Declare PtrSafe Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As LongPtr)
    Public Declare PtrSafe Function ShellExecute Lib "shell32.dll" Alias "ShellExecuteA" (ByVal hwnd As Long, ByVal lpOperation As String, ByVal lpFile As String, ByVal lpParameters As String, ByVal lpDirectory As String, ByVal nShowCmd As Long) As Long
'    Public Declare PtrSafe Function GetKeyState Lib "user32" (ByVal vKey As Long) As Integer
#Else 'For 32 Bit Systems
    Public Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)
    Public Declare Function ShellExecute Lib "shell32.dll" Alias "ShellExecuteA" (ByVal hwnd As Long, ByVal lpOperation As String, ByVal lpFile As String, ByVal lpParameters As String, ByVal lpDirectory As String, ByVal nShowCmd As Long) As Long
'    Public Declare Function GetKeyState Lib "user32" (ByVal vKey As Integer) As Integer
#End If

' Test whether you are using the 64-bit version of Office 2010.
#If Win64 Then
   Public Declare PtrSafe Function GetTickCount64 Lib "kernel32" () As LongLong
   Private StartTime_for_ms_Timer As LongLong
#Else
   #If VBA7 Then
      Public Declare PtrSafe Function GetTickCount Lib "kernel32" () As Long
   #Else
      Public Declare Function GetTickCount Lib "kernel32" () As Long
   #End If
   Private StartTime_for_ms_Timer As Long
#End If

Public Const SW_NORMAL = 1

Public Const KS_SHIFT_KEY = 16
Public Const KS_CTRL_KEY = 17
Public Const KS_ALT_KEY = 18


'--------------------------
Public Sub Start_ms_Timer()
'--------------------------
' Timer for debugging
    StartTime_for_ms_Timer = GetTickCount()
End Sub

'----------------------------------------
Public Function Get_ms_Duration() As Long
'----------------------------------------
' Timer for debugging
  Get_ms_Duration = GetTickCount() - StartTime_for_ms_Timer
End Function



'----------------------------------------------------------------------------
Public Function AddSpaceToLen(ByVal s As String, MinLength As Long) As String
'----------------------------------------------------------------------------
  While Len(s) < MinLength
     s = s & " "
  Wend
  AddSpaceToLen = s
End Function

'--------------------------------------------------------------------------------
Public Function AddSpaceToLenLeft(ByVal s As String, MinLength As Long) As String
'--------------------------------------------------------------------------------
  While Len(s) < MinLength
     s = " " & s
  Wend
  AddSpaceToLenLeft = s
End Function


'---------------------------------------------------
Function IsArrayEmpty(anArray As Variant) As Boolean
'---------------------------------------------------
On Error GoTo IS_EMPTY
If (UBound(anArray) >= 0) Then Exit Function
IS_EMPTY:
    IsArrayEmpty = True
End Function

'-----------------------------
Function LastUsedRow() As Long
'-----------------------------
' Return the last used row in the active sheet.
' Attention: Rows containing only format informations are also 'used' rows.
  LastUsedRow = ActiveSheet.UsedRange.Rows(ActiveSheet.UsedRange.Rows.Count).Row
End Function

'--------------------------------
Function LastUsedColumn() As Long
'--------------------------------
  LastUsedColumn = ActiveSheet.UsedRange.Columns(ActiveSheet.UsedRange.Columns.Count).Column
End Function

'-----------------------------------------------
Function LastUsedRowIn(Sheet As Variant) As Long
'-----------------------------------------------
' return the last used row in the given sheet.
' The sheet could be given as sheet name or as worksheets variable.
Dim sh As Variant
  If VarType(Sheet) = vbString Then
        Set sh = Sheets(Sheet)
  Else: Set sh = Sheet
  End If
  LastUsedRowIn = sh.UsedRange.Rows(sh.UsedRange.Rows.Count).Row
  Set sh = Nothing
End Function



'--------------------------------------------------
Function LastUsedColumnIn(Sheet As Variant) As Long
'--------------------------------------------------
Dim sh As Variant
  If VarType(Sheet) = vbString Then
        Set sh = Sheets(Sheet)
  Else: Set sh = Sheet
  End If

  LastUsedColumnIn = sh.UsedRange.Columns(sh.UsedRange.Columns.Count).Column
  Set sh = Nothing
End Function

'------------------------------------------------------------------
Function LastFilledRowIn(sh As Worksheet, CheckCol As Long) As Long
'------------------------------------------------------------------
  Dim Row As Long
  Row = LastUsedRowIn(sh)
  With sh
    While .Cells(Row, CheckCol) = "" And Row > 0
      Row = Row - 1
    Wend
    LastFilledRowIn = Row
  End With
End Function

'-----------------------------------------------
Function LastFilledRow(CheckCol As Long) As Long
'-----------------------------------------------
  LastFilledRow = LastFilledRowIn(ActiveSheet, CheckCol)
End Function

'---------------------------------------------------------------------
Function LastFilledColumnIn(sh As Worksheet, CheckRow As Long) As Long
'---------------------------------------------------------------------
  Dim Column As Long
  Column = LastUsedColumnIn(sh)
  With sh
    While .Cells(CheckRow, Column) = ""
      Column = Column - 1
      If Column = 0 Then Exit Function
    Wend
    LastFilledColumnIn = Column
  End With
End Function

'--------------------------------------------------
Function LastFilledColumn(CheckRow As Long) As Long
'--------------------------------------------------
  LastFilledColumn = LastFilledColumnIn(ActiveSheet, CheckRow)
End Function

'--------------------------------------------------------------
Function First_Change_in_Line(Target As Excel.Range) As Boolean
'--------------------------------------------------------------
' Check if the target cell is the only cell which contains data
  First_Change_in_Line = Target.End(xlToLeft).Column = 1 And Target.End(xlToRight).Column = Target.Parent.Columns.Count ' 10.09.19: Removed: (Target = "") And  ' 28.10.19: Replaced ActiveSheet with Target.Parent
End Function

'-------------------------------------------------------------
Function LastFilledRowIn_ChkAll(ByVal sh As Worksheet) As Long
'-------------------------------------------------------------
  Dim Row As Long
  Row = LastUsedRowIn(sh)
  With sh
    While First_Change_in_Line(.Cells(Row, 1))
      Row = Row - 1
      If Row = 0 Then Exit Function
    Wend
    LastFilledRowIn_ChkAll = Row
  End With
End Function

'UT--------------------------------------
Private Sub Test_LastFilledRowIn_ChkAll()
'UT--------------------------------------
  Debug.Print LastFilledRowIn_ChkAll(ActiveSheet)
End Sub


'----------------------------------------------------------------------
Function DelLast(ByVal s As String, Optional cnt As Long = 1) As String
'----------------------------------------------------------------------
  If Len(s) > 0 Then
     DelLast = Left(s, Len(s) - cnt)
  End If
End Function



'----------------------------------------------------------------
Function DelAllLast(ByVal s As String, Chars As String) As String
'----------------------------------------------------------------
  While InStr(Chars, Right(s, 1)) > 0
    s = Left(s, Len(s) - 1)
  Wend
  DelAllLast = s
End Function

'---------------------------
Sub Center_Form(F As Object)
'---------------------------
  With F
        .StartupPosition = 0
        .Left = Application.Left + (Application.Width - .Width) / 2
        .Top = Application.Top + (Application.Height - .Height) / 2
  End With
End Sub

'UT---------------------------
Private Sub Test_Center_Form()
'UT---------------------------
  Center_Form UserForm_Set_ColTab
  UserForm_Set_ColTab.Show
End Sub

'-----------------------------------------------------------
Function Replace_Double_Space(ByVal Txt As String) As String
'-----------------------------------------------------------
  Dim Res As String
  Res = Txt
  While InStr(Res, "  ") > 0
    Res = Replace(Res, "  ", " ")
  Wend
  Replace_Double_Space = Res
End Function

'--------------------------------------------------
Function CellLinesSum(ByVal C As String) As Variant
'--------------------------------------------------
  If InStr(C, vbLf) Then
        Dim Line As Variant
        For Each Line In Split(C, vbLf)
           CellLinesSum = CellLinesSum + Val(Line)
        Next Line
  Else: CellLinesSum = Val(C)
  End If
End Function


'------------------------------------------------------------------------------------
Public Function Is_Contained_in_Array(ByVal Txt As String, arr As Variant) As Boolean
'------------------------------------------------------------------------------------
  Dim e As Variant
  Txt = Trim(Txt)
  For Each e In arr
     If Trim(e) = Txt Then
        Is_Contained_in_Array = True
        Exit Function
     End If
  Next e
End Function

'--------------------------------------------------------------------------
Function IsInArray(ByVal stringToBeFound As String, arr As Variant) As Long
'--------------------------------------------------------------------------
  Dim i As Long
  ' default return value if value not found in array
  IsInArray = -1

  For i = LBound(arr) To UBound(arr)
    If StrComp(stringToBeFound, arr(i), vbTextCompare) = 0 Then
      IsInArray = i
      Exit For
    End If
  Next i
End Function

'--------------------------------------------------------------------------------------------------
Sub Hide_and_Move_up(dlg As Object, ByVal StartHide_Name As String, ByVal StartMove_Name As String)
'--------------------------------------------------------------------------------------------------
' Hide the controls where StartHide_y <= controls.Top < StartMove_y
' Move the controls up where controls.Top >= StartMove_y

  Dim MoveDelta As Long, StartHide_y As Long, StartMove_y As Long
  StartHide_y = dlg.Controls(StartHide_Name).Top
  StartMove_y = dlg.Controls(StartMove_Name).Top
  MoveDelta = StartMove_y - StartHide_y
  
  'Debug.Print "Hide_and_Move_up from '" & StartHide_Name & "' to '" & StartMove_Name & "' " & MoveDelta ' Debug
  
  Dim C As Variant
  For Each C In dlg.Controls
      If C.Top >= StartMove_y Then
         C.Top = C.Top - MoveDelta
      ElseIf C.Top >= StartHide_y Then
         C.Visible = False
      End If
  Next C
  dlg.Height = dlg.Height - MoveDelta
End Sub



'-------------------------------------------------------------------------
Function FindHeadCol(sh As Worksheet, Row As Long, Name As Variant) As Long
'-------------------------------------------------------------------------
  Dim r As Range
  With sh
    Set r = .Range(.Cells(Row, 1), .Cells(Row, LastUsedColumnIn(sh)))
  End With
  
  #If 1 Then ' Use Match instead of find because the find command dosn't look in hidden cells (InCh)    ' 26.09.19
        Dim p As Variant
        p = Application.Match(Name, r, 0)
        If IsError(p) Then
           MsgBox "Fehler: Die Spalte '" & Name & "' wurde nicht im Sheet '" & sh.Name & "' gefunden!" & vbCr & _
                  vbCr & _
                  "Die Spaltennamen d|fffd|rfen nicht ver|fffd|ndert werden", vbCritical, "Fehler Spaltenname nicht gefunden"
           EndProg
        Else
           FindHeadCol = p
        End If
  #Else
        Dim F As Variant
        Set F = r.Find(What:=Name, After:=r.Cells(1, 1), LookIn:=xlFormulas, LookAt:=xlWhole, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=True, SearchFormat:=False)
        
        If F Is Nothing Then
             MsgBox "Fehler: Die Spalte '" & Name & "' wurde nicht im Sheet '" & sh.Name & "' gefunden!" & vbCr & _
                    vbCr & _
                    "Die Spaltennamen d|fffd|rfen nicht ver|fffd|ndert werden", vbCritical, "Fehler Spaltenname nicht gefunden"
             EndProg
        Else
             FindHeadCol = F.Column
        End If
   #End If
End Function

'UT---------------------------
Private Sub Test_FindHeadCol()
'UT---------------------------
  Debug.Print FindHeadCol(ActiveSheet, 2, "Beschreibung")
End Sub

'--------------------------------------------------------------------------------------------------------
Function InputBoxMov(prompt As String, Optional Title As Variant, Optional Default As Variant, _
                     Optional Left As Variant, Optional Top As Variant, Optional helpfile As Variant, _
                     Optional HelpContextID As Variant) As Variant
'--------------------------------------------------------------------------------------------------------
' InputBox which could be moved with correct screen update even if screenupdating is disabled
  Dim OldUpdate As Boolean
  OldUpdate = Application.ScreenUpdating
  Application.ScreenUpdating = True
  InputBoxMov = InputBox(prompt, Title, Default, Left, Top, helpfile, HelpContextID)
  Sleep 50 ' Time to update the display
  Application.ScreenUpdating = OldUpdate
End Function

'-----------------------------
Private Sub Test_InputBoxMov()
'-----------------------------
  Application.ScreenUpdating = False

  Debug.Print InputBoxMov("Hallo", "Title", "Dafault")

  Application.ScreenUpdating = True
End Sub

'----------------------------------------------------------------------------------------
Function MsgBoxMov(prompt As String, Optional buttons As Long, Optional Title As Variant, _
         Optional helpfile As Variant, Optional context As Variant) As Variant
'----------------------------------------------------------------------------------------
' MsgBox which could be moved with correct screen update even if screenupdating is disabled
  Dim OldUpdate As Boolean
  OldUpdate = Application.ScreenUpdating
  Application.ScreenUpdating = True
  MsgBoxMov = MsgBox(prompt, buttons, Title, helpfile, context)
  Sleep 50 ' Time to update the display
  Application.ScreenUpdating = OldUpdate
End Function

'UT-------------------------
Private Sub Test_MsgBoxMov()
'UT-------------------------
  Application.ScreenUpdating = False

  Debug.Print MsgBoxMov("Hallo", vbYesNoCancel, "Titel")

  Application.ScreenUpdating = True
End Sub


'-------------------
Public Sub EndProg()
'-------------------
' Is called in case of an fatal error
  Application.EnableEvents = True
  Application.ScreenUpdating = True
  End
End Sub

'--------------------------
Public Sub ClearStatusbar()
'--------------------------
' Is called by onTime to clear the status bar after a while
  Application.StatusBar = ""
End Sub

'-------------------------------------------------------------------------------------------
Public Sub Show_Status_for_a_while(Txt As String, Optional Duration As String = "00:00:15")
'-------------------------------------------------------------------------------------------
  Application.StatusBar = Txt
  If Txt <> "" Then
        Application.OnTime Now + TimeValue(Duration), "ClearStatusbar"
  Else: Application.OnTime Now + TimeValue("00:00:00"), "ClearStatusbar"
  End If
End Sub


'-------------------------------------
Public Sub All_Borderlines(r As Range)
'-------------------------------------
    'r.Select ' Debug
    r.Borders(xlDiagonalDown).LineStyle = xlNone
    r.Borders(xlDiagonalUp).LineStyle = xlNone
    With r.Borders(xlEdgeLeft)
        .LineStyle = xlContinuous
        .ColorIndex = 0
        .TintAndShade = 0
        .Weight = xlThin
    End With
    With r.Borders(xlEdgeTop)
        .LineStyle = xlContinuous
        .ColorIndex = 0
        .TintAndShade = 0
        .Weight = xlThin
    End With
    With r.Borders(xlEdgeBottom)
        .LineStyle = xlContinuous
        .ColorIndex = 0
        .TintAndShade = 0
        .Weight = xlThin
    End With
    With r.Borders(xlEdgeRight)
        .LineStyle = xlContinuous
        .ColorIndex = 0
        .TintAndShade = 0
        .Weight = xlThin
    End With
    With r.Borders(xlInsideVertical)
        .LineStyle = xlContinuous
        .ColorIndex = 0
        .TintAndShade = 0
        .Weight = xlThin
    End With
    With r.Borders(xlInsideHorizontal)
        .LineStyle = xlContinuous
        .ColorIndex = 0
        .TintAndShade = 0
        .Weight = xlThin
    End With
End Sub

'---------------------------------------------------
Function FileNameExt(ByVal Name As String) As String
'---------------------------------------------------
' Return name and extention without path
Dim Pos As Long, Pos2 As Long, Temp As String
  Pos = InStrRev(Name, "\")
  Pos2 = InStrRev(Name, "/")
  If Pos2 > Pos Then Pos = Pos2
  If Pos > 0 Then
     Temp = Mid(Name, Pos + 1)
  Else
     Pos = InStrRev(Name, ":")
     If Pos > 0 Then
          Temp = Mid(Name, Pos + 1)
     Else
          Temp = Name
     End If
  End If
  FileNameExt = Temp
End Function

'------------------------------------------------
Function FilePath(ByVal Name As String) As String
'------------------------------------------------
  FilePath = Left(Name, Len(Name) - Len(FileNameExt(Name)))
End Function

'---------------------------------------------
Function NoExt(ByVal Name As String) As String
'---------------------------------------------
' Cut of the extention of a filename
Dim Pos As Long
  Pos = InStrRev(Name, ".")
  If Pos > 0 Then
        NoExt = Left(Name, Pos - 1)
  Else: NoExt = Name
  End If
End Function

'------------------------------------------------
Function FileName(ByVal Name As String) As String
'------------------------------------------------
' Return name without extention and path
  FileName = NoExt(FileNameExt(Name))
End Function



'-------------------------------------------
Function ColumnLetters(r As Range) As String
'-------------------------------------------
  ColumnLetters = Replace(Replace(r.Address, "$", ""), r.Row, "")
End Function

'-------------------------------------------------
Function ColumnLettersFromNr(ByVal Colunm As Long)
'-------------------------------------------------
  ColumnLettersFromNr = ColumnLetters(Cells(1, Colunm))
End Function

'----------------------------------------
Sub DisableFiltersInSheet(s As Worksheet)
'----------------------------------------
    If s.AutoFilterMode Then
        If s.FilterMode Then
            On Error Resume Next ' Generates an error if all rows have been deleted
            s.ShowAllData
            On Error GoTo 0
            Exit Sub
        End If
    End If
        
    ' Check if a table is used. In this case the filter can't be disabled if the active cell is not located in the table
    Dim obj As Variant
    For Each obj In s.ListObjects
        If Not obj.AutoFilter Is Nothing Then
           Dim OldActCell As Range
           Set OldActCell = ActiveCell
           s.Cells(obj.Range.Row, obj.Range.Column).Select
           On Error Resume Next ' Generates an error if all rows have been deleted
           s.ShowAllData
           On Error GoTo 0
           OldActCell.Select
           Exit Sub
        End If
    Next obj
End Sub

'-----------------------------------------------
Function isVariantArray(V As Variant) As Boolean
'-----------------------------------------------
  On Error GoTo ErrorDet
  Dim i As Long
  i = UBound(V)
  isVariantArray = True

ErrorDet:
  On Error GoTo 0
End Function



'----------------------------------------------------
Public Function F_shellExec(sCmd As String) As String
'----------------------------------------------------
' Excecute command and get the output as string
' Example call:
'   MsgBox F_shellExec("cmd /c dir c:\")
'
' Requires ref to Windows Script Host Object Model
' To do this go to Extras -> References in the VBA IDE's menu bar.
' See:
'   https://stackoverflow.com/questions/2784367/capture-output-value-from-a-shell-command-in-vba

    Dim oShell As New WshShell 'requires ref to Windows Script Host Object Model
    F_shellExec = oShell.Exec(sCmd).StdOut.ReadAll
End Function
Attribute VB_Name = "M31_Sound"
Option Explicit
' https://wellsr.com/vba/2019/excel/vba-playsound-to-play-system-sounds-and-wav-files/

#If VBA7 Then
    Public Declare PtrSafe Function PlaySound Lib "winmm.dll" Alias "PlaySoundA" (ByVal lpszName As String, ByVal hModule As LongPtr, ByVal dwFlags As Long) As Long
#Else
    Public Declare Function PlaySound Lib "winmm.dll" Alias "PlaySoundA" (ByVal lpszName As String, ByVal hModule As Long, ByVal dwFlags As Long) As Long
#End If

Const SND_SYNC = &H0                ' wait for sound to play
Const SND_ASYNC = &H1               ' no wait
Const SND_NODEFAULT = &H2           ' no default sound on error
Const SND_NOSTOP = &H10             ' skip sound if another is playing
Const SND_ALIAS = &H10000           ' play system sound
Const SND_FILENAME = &H20000        ' play WAV file

Public Function BeepThis2(Optional ByVal ThisSound As String = "Beep" _
                        , Optional ByVal ThisValue As Variant _
                        , Optional ByVal ThisCount As Integer = 1 _
                        , Optional ByVal Wait As Boolean = False) As Variant
    Dim sPath As String, flags As Long
    Const sMedia As String = "\Media\"
    If IsMissing(ThisValue) Then ThisValue = ThisSound
    BeepThis2 = ThisValue           ' return value
    If ThisCount > 1 Then Wait = True
    flags = SND_ALIAS
    sPath = StrConv(ThisSound, vbProperCase)
    Select Case sPath
    Case "Beep"
        Beep                        ' ignore ThisCount and Wait
        Exit Function
    Case "Asterisk", "Exclamation", "Hand", "Notification", "Question"
        sPath = "System" + sPath
    Case "Connect", "Disconnect", "Fail"
        sPath = "Device" + sPath
    Case "Mail", "Reminder"
        sPath = "Notification." + sPath
    Case "Text"
        sPath = "Notification.SMS"
    Case "Message"
        sPath = "Notification.IM"
    Case "Fax"
        sPath = "FaxBeep"
    Case "Select"
        sPath = "CCSelect"
    Case "Error"
        sPath = "AppGPFault"
    Case "Close", "Maximize", "Minimize", "Open"
        ' ok
    Case "Default"
        sPath = "." & sPath
    Case "Chimes", "Chord", "Ding", "Notify", "Recycle", "Ringout", "Tada"
        sPath = Environ("SystemRoot") & sMedia & sPath & ".wav"
        flags = SND_FILENAME
    Case Else
        If LCase(Right(ThisSound, 4)) <> ".wav" Then ThisSound = ThisSound & ".wav"
        sPath = ThisSound
        If Dir(sPath) = "" Then     ' file is not in working directory
            sPath = ActiveWorkbook.Path & "\" & ThisSound
            If Dir(sPath) = "" Then sPath = Environ("SystemRoot") & sMedia & ThisSound
        End If
        flags = SND_FILENAME
    End Select
    flags = flags + IIf(Wait, SND_SYNC, SND_ASYNC)
    Do While ThisCount > 0          ' skip if ThisCount < 1
        PlaySound sPath, 0, flags   ' if error, .Default sound will play
        ThisCount = ThisCount - 1
    Loop
End Function

'-------------------------------------------------------------------------
Public Function BeepThis1(Optional ByVal ThisSound As String = "Beep" _
                        , Optional ByVal ThisValue As Variant) As Variant
'-------------------------------------------------------------------------
    If IsMissing(ThisValue) Then ThisValue = ThisSound
    BeepThis1 = ThisValue
    Beep
End Function

Private Sub Test_BeepThis1()
  'BeepThis2 "Default"
  'BeepThis2 "Asterisk"
  'BeepThis2 "Fax"
  BeepThis2 "Windows Information Bar.wav", , , True
  
End Sub


Attribute VB_Name = "M35_Mouse_Scroll"
Option Explicit
' Mouse wheel support for list boxes
' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
'
'
' Program combined from
'  https://stackoverflow.com/questions/34911413/mouse-scroll-on-a-listbox
'  https://www.ozgrid.com/forum/forum/help-forums/excel-general/128354-mouse-wheel-scroll-userform
'
' Hier eine weitere L|fffd|sung:
'  http://www.office-loesung.de/ftopic174250_0_0_asc.php

' Hier wird von Problemen mit 32/64 Bit berichtet
' https://stackoverflow.com/questions/36621795/use-mouse-wheel-in-excel-dynamic-combobox-not-working-on-excel-2010


' Usage:
' ~~~~~~
' Add the following calls to the UserForm code:
' - To the initialisation of the user form:
'     HookFormScroll Me, "ListBox"   ' Initialize the mouse wheel scroll function
'
' - When the form is closed:
'     UnhookFormScroll ' Deactivate the mouse weel scrol function
'
' - The following sub is called if the mouse wheel is changed
'   It must be copied to the user form and adapted (Remove the #if ...)
#If False Then
'-----------------------------------------------
Public Sub MouseWheel(ByVal lngRotation As Long)
'-----------------------------------------------
' Process the mouse wheel changes
  With ListBox  ' Adapt to the listbox which should be controlled
    If lngRotation > 0 Then
        If .TopIndex > 0 Then
            If .TopIndex > 3 Then
                .TopIndex = .TopIndex - 3
            Else
                .TopIndex = 0
            End If
        End If
    Else
        .TopIndex = .TopIndex + 3
    End If
  End With
End Sub
#End If

' ToDo:
' Das geht noch nicht. Bei einem 32 Bit Office Funktioniert es aber nicht mit den neuen Deklarationen
' Ich lasse es erst mal so. Unter einem 64 Bit Office ist das Scrollen mit der Maus deaktiviert

#If Win64 Then ' If this is enabled the mouse scrolling is not active
  Sub HookFormScroll(oForm As Object, ControllName As String): End Sub
  Sub UnhookFormScroll(): End Sub
#Else


' Mit der neuen Deklaration wird die Scroll Richtung der Maus nicht mehr erkannt
' => Man kann nur noch nach unten Scrollen ;-(
' Das Problem scheint die folgende Zeile zu sein:
'   iDirection = GetHookStruct(lParam).mouseData


#If 0 Then ' New Type of Functions      Scrollt nur nach unten

    ' Overview 32 / 64 Bit functions: https://jkp-ads.com/Articles/apideclarations.asp
    ' https://stackoverflow.com/questions/45324586/using-setwindowshookex-in-excel-2010
    #If VBA7 Then 'For 64 Bit Systems
       Private Declare PtrSafe Function FindWindow Lib "User32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As LongPtr
       Private Declare PtrSafe Function GetForegroundWindow Lib "user32.dll" () As LongPtr
       Private Declare PtrSafe Function UnhookWindowsHookEx Lib "User32" (ByVal hHook As LongPtr) As Long
       Private Declare PtrSafe Function SetWindowsHookEx Lib "User32" Alias "SetWindowsHookExA" (ByVal idHook As Long, ByVal lpFn As LongPtr, ByVal hmod As LongPtr, ByVal dwThreadId As Long) As LongPtr
       Private Declare PtrSafe Function CallNextHookEx Lib "User32" (ByVal hHook As LongPtr, ByVal nCode As Long, ByVal wParam As LongPtr, lParam As Any) As LongPtr
       Private Declare PtrSafe Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (hpvDest As Any, hpvSource As Any, ByVal cbCopy As Long)
    #Else 'This will compile in 32 bit Excel only
       Private Declare Function FindWindow Lib "User32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
       Private Declare Function GetForegroundWindow Lib "user32.dll" () As Long
       Private Declare Function UnhookWindowsHookEx Lib "User32" (ByVal hHook As Long) As Long
       Private Declare Function SetWindowsHookEx Lib "User32" Alias "SetWindowsHookExA" (ByVal idHook As Long, ByVal lpFn As Long, ByVal hmod As Long, ByVal dwThreadId As Long) As Long
       Private Declare Function CallNextHookEx Lib "User32" (ByVal hHook As Long, ByVal nCode As Long, ByVal wParam As Long, lParam As Any) As Long
       Private Declare Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (ByVal Destination As Long, ByVal Source As Long, ByVal Length As Long)
    #End If

#Else
   Private Declare Function FindWindow Lib "User32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
   Private Declare Function GetForegroundWindow Lib "user32.dll" () As Long
   Private Declare Function UnhookWindowsHookEx Lib "User32" (ByVal hHook As Long) As Long
   Private Declare Function SetWindowsHookEx Lib "User32" Alias "SetWindowsHookExA" (ByVal idHook As Long, ByVal lpFn As Long, ByVal hmod As Long, ByVal dwThreadId As Long) As Long
   Private Declare Function CallNextHookEx Lib "User32" (ByVal hHook As Long, ByVal nCode As Long, ByVal wParam As Long, lParam As Any) As Long
   Private Declare Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (ByVal Destination As Long, ByVal Source As Long, ByVal Length As Long)
#End If


#If False Then ' Das braucht man nicht
    ' This is one of the few API functions that requires the Win64 compile constant:
    #If VBA7 Then
        #If Win64 Then
            Private Declare PtrSafe Function GetWindowLongPtr Lib "User32" Alias "GetWindowLongPtrA" (ByVal hwnd As LongPtr, ByVal nIndex As Long) As LongPtr
        #Else
            Private Declare PtrSafe Function GetWindowLongPtr Lib "User32" Alias "GetWindowLongA" (ByVal hwnd As LongPtr, ByVal nIndex As Long) As LongPtr
        #End If
    #Else
        Private Declare Function GetWindowLong Lib "User32" Alias "GetWindowLongA" (ByVal hwnd As Long, ByVal nIndex As Long) As Long
    #End If
#End If

    
Private Type POINTAPI
  X As Long
  y As Long
End Type

Private Type MSLLHOOKSTRUCT  'Will Hold the lParam struct Data
  pt As POINTAPI
  mouseData As Long  ' Holds Forward\Backward flag
  flags As Long
  time As Long
  dwExtraInfo As Long
End Type

Private Const HC_ACTION = 0
Private Const WH_MOUSE_LL = 14
Private Const WM_MOUSEWHEEL = &H20A
Private Const GWL_HINSTANCE = (-6)

Public Const nMyControlTypeNONE = 0
Public Const nMyControlTypeUSERFORM = 1
Public Const nMyControlTypeFRAME = 2
Public Const nMyControlTypeCOMBOBOX = 3
Public Const nMyControlTypeLISTBOX = 4


Private udtlParamStuct As MSLLHOOKSTRUCT

#If VBA7 Then
  Private mLngMouseHook              As LongPtr
  Private mFormHwnd                  As LongPtr
#Else
  Private mLngMouseHook              As Long
  Private mFormHwnd                  As Long
#End If

Private mbHook                     As Boolean
Dim mForm                          As Object

Private mControllName              As String

#If VBA7 Then
    Function GetHookStruct(ByVal lParam As LongPtr) As MSLLHOOKSTRUCT
    ' VarPtr returns address; LenB returns size in bytes.
      CopyMemory VarPtr(udtlParamStuct), lParam, LenB(udtlParamStuct)
      GetHookStruct = udtlParamStuct
    End Function
#Else
    Function GetHookStruct(ByVal lParam As Long) As MSLLHOOKSTRUCT
    ' VarPtr returns address; LenB returns size in bytes.
      CopyMemory VarPtr(udtlParamStuct), lParam, LenB(udtlParamStuct)
      GetHookStruct = udtlParamStuct
    End Function
#End If

#If VBA7 Then
  Function LowLevelMouseProc(ByVal nCode As Long, ByVal wParam As LongPtr, ByVal lParam As LongPtr) As LongPtr
#Else
  Function LowLevelMouseProc(ByVal nCode As Long, ByVal wParam As Long, ByVal lParam As Long) As Long
#End If
  'Avoid XL crashing if RunTime error occurs due to Mouse fast movement

  Dim iDirection As Long

  On Error Resume Next
  '    \\ Unhook & get out in case the application is deactivated          Hardi: Das geht irgend wie nicht
  'Dim Winp As Integer
  'Winp = FindWindow(ThisWorkbook.Name, myGblUserForm.Caption)
  'If GetForegroundWindow <> Winp Then
  '  UnhookFormScroll
  '  Exit Function
  'End If
  If GetForegroundWindow = mFormHwnd Then ' Hardi
      If (nCode = HC_ACTION) Then
        If wParam = WM_MOUSEWHEEL Then
          iDirection = GetHookStruct(lParam).mouseData                             ' Problem: Hier kommt immer 0
          'Debug.Print "Call ProcessMouseWheelMovement(" & iDirection & ")"  ' Debug
          mForm.MouseWheel iDirection
    
          '\\ Don't process Default WM_MOUSEWHEEL Window message
          LowLevelMouseProc = True
        End If
    
        Exit Function
      End If
  End If
  LowLevelMouseProc = CallNextHookEx(0, nCode, wParam, ByVal lParam)
End Function


Sub UnhookFormScroll()
   If mbHook Then
      UnhookWindowsHookEx mLngMouseHook
      mLngMouseHook = 0
      mFormHwnd = 0
      mbHook = False
   End If
End Sub


'----------------------------------------------------------
Sub HookFormScroll(oForm As Object, ControllName As String)
'----------------------------------------------------------
#If VBA7 Then
   Dim lngAppInst                  As LongPtr
   Dim hwndUnderCursor             As LongPtr
#Else
   Dim lngAppInst                  As Long
   Dim hwndUnderCursor             As Long
#End If


   Set mForm = oForm
   hwndUnderCursor = FindWindow("ThunderDFrame", oForm.Caption)
   'Debug.Print "HookFormScroll() Form window: " & hwndUnderCursor ' Debug
   If mFormHwnd <> hwndUnderCursor Then
      mControllName = ControllName
      UnhookFormScroll
      'Debug.Print "Unhook old proc" ' Debug
      mFormHwnd = hwndUnderCursor

#If 0 Then  ' Das braucht man nicht
      #If VBA7 Then
         lngAppInst = GetWindowLongPtr(mFormHwnd, GWL_HINSTANCE)  ' Geht das so ???
         'lngAppInst = GetWindowLongPtr(FindWindow("XLMAIN", Application.Caption), GWL_HINSTANCE) ' Geht auch nicht
      #Else
         lngAppInst = GetWindowLong(mFormHwnd, GWL_HINSTANCE)
      #End If
#End If

      If Not mbHook Then
         mLngMouseHook = SetWindowsHookEx(WH_MOUSE_LL, AddressOf LowLevelMouseProc, lngAppInst, 0)
         mbHook = mLngMouseHook <> 0
         'If mbHook Then Debug.Print "Form hooked"
      End If
   End If
End Sub

#End If
Attribute VB_Name = "M40_ShellAndWait"
' M40_ShellAndWait:
' ~~~~~~~~~~~~~~~~~

' Module Description:
' ~~~~~~~~~~~~~~~~~~~
' This module provides a function to call external programs and wait for a certain time.
' In addition the windows style (Hidden, Maximized, Minimized, ...) and the
' "Ctrl Break" behavior could be defined.

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Chip Pearson
' http://www.cpearson.com/excel/ShellAndWait.aspx
' This module contains code for the ShellAndWait function that will Shell to a process
' and wait for that process to End before returning to the caller.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


Option Explicit
Option Compare Text


#If Win64 Then ' 28.09.19: New 64 Bit definition (Test f|fffd|r Armins MoBa Rechner)
  ' https://foren.activevb.de/forum/vba/thread-25588/beitrag-25588/VBA7-Win64-CreateProcess-WaitFo/
    Private Declare PtrSafe Function WaitForSingleObject Lib "kernel32" (ByVal hHandle As LongPtr, ByVal dwMilliseconds As LongLong) As LongLong
#Else
  #If VBA7 Then
    Private Declare PtrSafe Function WaitForSingleObject Lib "kernel32" (ByVal hHandle As LongPtr, ByVal dwMilliseconds As Long) As LongPtr ' LongPtr oder LongLong?
  #Else
    Private Declare Function WaitForSingleObject Lib "kernel32" (ByVal hHandle As Long, ByVal dwMilliseconds As Long) As Long
  #End If
#End If


#If VBA7 Then
  Private Declare PtrSafe Function OpenProcess Lib "kernel32" (ByVal dwDesiredAccess As Long, ByVal bInheritHandle As Long, ByVal dwProcessId As Long) As Long
  Private Declare PtrSafe Function CloseHandle Lib "kernel32" (ByVal hObject As Long) As Long
#Else
  Private Declare Function OpenProcess Lib "kernel32" (ByVal dwDesiredAccess As Long, ByVal bInheritHandle As Long, ByVal dwProcessId As Long) As Long
  Private Declare Function CloseHandle Lib "kernel32" (ByVal hObject As Long) As Long
#End If

Private Const SYNCHRONIZE = &H100000

Public Enum ShellAndWaitResult
    Success = 0
    Failure = 1
    timeout = 2
    InvalidParameter = 3
    SysWaitAbandoned = 4
    UserWaitAbandoned = 5
    UserBreak = 6
End Enum

Public Enum ActionOnBreak
    IgnoreBreak = 0
    AbandonWait = 1
    PromptUser = 2
End Enum

Public TaskId As Long

#If Win64 Then ' 28.09.19:
    Private Const STATUS_ABANDONED_WAIT_0 As LongLong = &H80
    Private Const STATUS_WAIT_0 As LongLong = &H0
    Private Const WAIT_ABANDONED As LongLong = (STATUS_ABANDONED_WAIT_0 + 0)
    Private Const WAIT_OBJECT_0 As LongLong = (STATUS_WAIT_0 + 0)
    Private Const WAIT_TIMEOUT As LongLong = 258&
    Private Const WAIT_FAILED As LongLong = &HFFFFFFFF
    Private Const WAIT_INFINITE = -1&
#Else
    Private Const STATUS_ABANDONED_WAIT_0 As Long = &H80
    Private Const STATUS_WAIT_0 As Long = &H0
    Private Const WAIT_ABANDONED As Long = (STATUS_ABANDONED_WAIT_0 + 0)
    Private Const WAIT_OBJECT_0 As Long = (STATUS_WAIT_0 + 0)
    Private Const WAIT_TIMEOUT As Long = 258&
    Private Const WAIT_FAILED As Long = &HFFFFFFFF
    Private Const WAIT_INFINITE = -1&
#End If

Public Function ShellAndWait(ShellCommand As String, _
                    TimeOutSeconds As Double, _
                    ShellWindowState As VbAppWinStyle, _
                    BreakKey As ActionOnBreak) As ShellAndWaitResult
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' ShellAndWait
'
' This function calls Shell and passes to it the command text in ShellCommand. The function
' then waits for TimeOutSeconds (in Seconds) to expire.
'
'   Parameters:
'       ShellCommand
'           is the command text to pass to the Shell function.
'
'       TimeOutSeconds Hardi: Changed type to double (Old: Long)
'
'       TimeOutMs
'           is the number of milliseconds to wait for the shell'd program to wait. If the
'           shell'd program terminates before TimeOutMs has expired, the function returns
'           ShellAndWaitResult.Success = 0. If TimeOutMs expires before the shell'd program
'           terminates, the return value is ShellAndWaitResult.TimeOut = 2.
'
'       ShellWindowState
'           is an item in VbAppWinStyle specifying the window state for the shell'd program.
'
'       BreakKey
'           is an item in ActionOnBreak indicating how to handle the application's cancel key
'           (Ctrl Break). If BreakKey is ActionOnBreak.AbandonWait and the user cancels, the
'           wait is abandoned and the result is ShellAndWaitResult.UserWaitAbandoned = 5.
'           If BreakKey is ActionOnBreak.IgnoreBreak, the cancel key is ignored. If
'           BreakKey is ActionOnBreak.PromptUser, the user is given a ?Continue? message. If the
'           user selects "do not continue", the function returns ShellAndWaitResult.UserBreak = 6.
'           If the user selects "continue", the wait is continued.
'
'   Return values:
'            ShellAndWaitResult.Success = 0
'               indicates the the process completed successfully.
'            ShellAndWaitResult.Failure = 1
'               indicates that the Wait operation failed due to a Windows error.
'            ShellAndWaitResult.TimeOut = 2
'               indicates that the TimeOutMs interval timed out the Wait.
'            ShellAndWaitResult.InvalidParameter = 3
'               indicates that an invalid value was passed to the procedure.
'            ShellAndWaitResult.SysWaitAbandoned = 4
'               indicates that the system abandoned the wait.
'            ShellAndWaitResult.UserWaitAbandoned = 5
'               indicates that the user abandoned the wait via the cancel key (Ctrl+Break).
'               This happens only if BreakKey is set to ActionOnBreak.AbandonWait.
'            ShellAndWaitResult.UserBreak = 6
'               indicates that the user broke out of the wait after being prompted with
'               a ?Continue message. This happens only if BreakKey is set to
'               ActionOnBreak.PromptUser.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Dim TimeOutMs As Long

#If Win64 Then                                                              ' 28.09.19:
  Dim WaitRes As LongLong
#Else
  Dim WaitRes As Long
#End If

Dim MS As Long
Dim MsgRes As VbMsgBoxResult
Dim SaveCancelKey As XlEnableCancelKey
Dim ElapsedTime As Long
Dim Quit As Boolean
Dim ProcHandle As Long
Const ERR_BREAK_KEY = 18
Const DEFAULT_POLL_INTERVAL = 500

If Trim(ShellCommand) = vbNullString Then
    ShellAndWait = ShellAndWaitResult.InvalidParameter
    Exit Function
End If

TimeOutMs = 1000 * TimeOutSeconds
If TimeOutMs < 0 Then
    ShellAndWait = ShellAndWaitResult.InvalidParameter
    Exit Function
ElseIf TimeOutMs = 0 Then
    MS = WAIT_INFINITE
Else
    MS = TimeOutMs
End If

Select Case BreakKey
    Case AbandonWait, IgnoreBreak, PromptUser
        ' valid
    Case Else
        ShellAndWait = ShellAndWaitResult.InvalidParameter
        Exit Function
End Select

Select Case ShellWindowState
    Case vbHide, vbMaximizedFocus, vbMinimizedFocus, vbMinimizedNoFocus, vbNormalFocus, vbNormalNoFocus
        ' valid
    Case Else
        ShellAndWait = ShellAndWaitResult.InvalidParameter
        Exit Function
End Select

On Error Resume Next
Err.Clear
TaskId = Shell(ShellCommand, ShellWindowState)
If (Err.Number <> 0) Or (TaskId = 0) Then
    ShellAndWait = ShellAndWaitResult.Failure
    Exit Function
End If

ProcHandle = OpenProcess(SYNCHRONIZE, False, TaskId)
If ProcHandle = 0 Then
    ShellAndWait = ShellAndWaitResult.Failure
    Exit Function
End If

On Error GoTo ErrH:
SaveCancelKey = Application.EnableCancelKey
Application.EnableCancelKey = xlErrorHandler
WaitRes = WaitForSingleObject(ProcHandle, DEFAULT_POLL_INTERVAL)
Do Until WaitRes = WAIT_OBJECT_0
    DoEvents
    Select Case WaitRes
        Case WAIT_ABANDONED
            ' Windows abandoned the wait
            ShellAndWait = ShellAndWaitResult.SysWaitAbandoned
            Exit Do
        Case WAIT_OBJECT_0
            ' Successful completion
            ShellAndWait = ShellAndWaitResult.Success
            Exit Do
        Case WAIT_FAILED
            ' attach failed
            ShellAndWait = ShellAndWaitResult.Failure
            Exit Do
        Case WAIT_TIMEOUT
            ' Wait timed out. Here, this time out is on DEFAULT_POLL_INTERVAL.
            ' See if ElapsedTime is greater than the user specified wait
            ' time out. If we have exceed that, get out with a TimeOut status.
            ' Otherwise, reissue as wait and continue.
            ElapsedTime = ElapsedTime + DEFAULT_POLL_INTERVAL
            If MS > 0 Then
                ' user specified timeout
                If ElapsedTime > MS Then
                    ShellAndWait = ShellAndWaitResult.timeout
                    Exit Do
                Else
                    ' user defined timeout has not expired.
                End If
            Else
                ' infinite wait -- do nothing
            End If
            ' reissue the Wait on ProcHandle
            WaitRes = WaitForSingleObject(ProcHandle, DEFAULT_POLL_INTERVAL)
            
        Case Else
            ' unknown result, assume failure
            ShellAndWait = ShellAndWaitResult.Failure
            Exit Do
            Quit = True
    End Select
Loop

CloseHandle ProcHandle
Application.EnableCancelKey = SaveCancelKey
Exit Function

ErrH:
Debug.Print "ErrH: Cancel: " & Application.EnableCancelKey
If Err.Number = ERR_BREAK_KEY Then
    If BreakKey = ActionOnBreak.AbandonWait Then
        CloseHandle ProcHandle
        ShellAndWait = ShellAndWaitResult.UserWaitAbandoned
        Application.EnableCancelKey = SaveCancelKey
        Exit Function
    ElseIf BreakKey = ActionOnBreak.IgnoreBreak Then
        Err.Clear
        Resume
    ElseIf BreakKey = ActionOnBreak.PromptUser Then
        MsgRes = MsgBoxMov("User Process Break." & vbCrLf & _
                           "Continue to wait?", vbYesNo)
        If MsgRes = vbNo Then
            CloseHandle ProcHandle
            ShellAndWait = ShellAndWaitResult.UserBreak
            Application.EnableCancelKey = SaveCancelKey
        Else
            Err.Clear
            Resume Next
        End If
    Else
        CloseHandle ProcHandle
        Application.EnableCancelKey = SaveCancelKey
        ShellAndWait = ShellAndWaitResult.Failure
    End If
Else
    ' some other error. assume failure
    CloseHandle ProcHandle
    ShellAndWait = ShellAndWaitResult.Failure
End If
Application.EnableCancelKey = SaveCancelKey

End Function




Attribute VB_Name = "M45_Clipboard"
Option Explicit

' https://www.spreadsheet1.com/how-to-copy-strings-to-clipboard-using-excel-vba.html

#If VBA7 Then
  Declare PtrSafe Function GlobalUnlock Lib "kernel32" (ByVal hMem As LongPtr) As Long
  Declare PtrSafe Function GlobalLock Lib "kernel32" (ByVal hMem As LongPtr) As Long
  Declare PtrSafe Function GlobalAlloc Lib "kernel32" (ByVal wFlags As LongPtr, ByVal dwBytes As LongPtr) As Long
  Declare PtrSafe Function CloseClipboard Lib "User32" () As Long
  Declare PtrSafe Function OpenClipboard Lib "User32" (ByVal hwnd As LongPtr) As Long
  Declare PtrSafe Function EmptyClipboard Lib "User32" () As Long
  Declare PtrSafe Function lstrcpy Lib "kernel32" (ByVal lpString1 As Any, ByVal lpString2 As Any) As Long
  Declare PtrSafe Function SetClipboardData Lib "User32" (ByVal wFormat As LongPtr, ByVal hMem As LongPtr) As Long
#Else
  Declare Function GlobalUnlock Lib "kernel32" (ByVal hMem As Long) As Long
  Declare Function GlobalLock Lib "kernel32" (ByVal hMem As Long) As Long
  Declare Function GlobalAlloc Lib "kernel32" (ByVal wFlags As Long, ByVal dwBytes As Long) As Long
  Declare Function CloseClipboard Lib "User32" () As Long
  Declare Function OpenClipboard Lib "User32" (ByVal hwnd As Long) As Long
  Declare Function EmptyClipboard Lib "User32" () As Long
  Declare Function lstrcpy Lib "kernel32" (ByVal lpString1 As Any, ByVal lpString2 As Any) As Long
  Declare Function SetClipboardData Lib "User32" (ByVal wFormat As Long, ByVal hMem As Long) As Long
#End If

Public Const GHND = &H42
Public Const CF_TEXT = 1
Public Const MAXSIZE = 4096


'-----------------------------------------------------------------
Public Function ClipBoard_SetData(sPutToClip As String) As Boolean
'-----------------------------------------------------------------

    ' www.msdn.microsoft.com/en-us/library/office/ff192913.aspx

    Dim hGlobalMemory As Long
    Dim lpGlobalMemory As Long
    Dim hClipMemory As Long
    Dim X As Long
    
    On Error GoTo ExitWithError_

    ' Allocate moveable global memory
    hGlobalMemory = GlobalAlloc(GHND, Len(sPutToClip) + 1)

    ' Lock the block to get a far pointer to this memory
    lpGlobalMemory = GlobalLock(hGlobalMemory)

    ' Copy the string to this global memory
    lpGlobalMemory = lstrcpy(lpGlobalMemory, sPutToClip)

    ' Unlock the memory
    If GlobalUnlock(hGlobalMemory) <> 0 Then
        MsgBox "Memory location could not be unlocked. Clipboard copy aborted", vbCritical, "API Clipboard Copy"
        GoTo ExitWithError_
    End If

    ' Open the Clipboard to copy data to
    If OpenClipboard(0&) = 0 Then
        MsgBox "Clipboard could not be opened. Copy aborted!", vbCritical, "API Clipboard Copy"
        GoTo ExitWithError_
    End If

    ' Clear the Clipboard
    X = EmptyClipboard()

    ' Copy the data to the Clipboard
    hClipMemory = SetClipboardData(CF_TEXT, hGlobalMemory)
    ClipBoard_SetData = True
    
    If CloseClipboard() = 0 Then
        MsgBox "Clipboard could not be closed!", vbCritical, "API Clipboard Copy"
    End If
    Exit Function
ExitWithError_:
    On Error Resume Next
    If Err.Number > 0 Then MsgBox "Clipboard error: " & Err.Description, vbCritical, "API Clipboard Copy"
    ClipBoard_SetData = False

End Function

'UT---------------------------------
Private Sub Test_ClipBoard_SetData()
'UT---------------------------------
  ClipBoard_SetData "Aber Hallo"
End Sub

Attribute VB_Name = "M99_Test"
Option Explicit

'-------------------------------------
Private Sub Test_Normal_Color_Dialog()
'-------------------------------------
  Dim Res As Variant
  Res = Application.Dialogs(xlDialogEditColor).Show(1, 26, 82, 48)
End Sub

'------------------------
Private Sub ColorDialog()
'------------------------
'Create variables for the color codes
Dim FullColorCode As Long
Dim RGBRed As Integer
Dim RGBGreen As Integer
Dim RGBBlue As Integer

'Get the color code from the cell named "RGBColor"
FullColorCode = Range("A3").Interior.Color

'Get the RGB value for each color (possible values 0 - 255)
RGBRed = FullColorCode Mod 256
RGBGreen = (FullColorCode \ 256) Mod 256
RGBBlue = FullColorCode \ 65536

'Open the ColorPicker dialog box, applying the RGB color as the default
If Application.Dialogs(xlDialogEditColor).Show _
    (1, RGBRed, RGBGreen, RGBBlue) = True Then

    'Set the variable RGBColorCode equal to the value
    'selected the DialogBox
    FullColorCode = ActiveWorkbook.Colors(1)
    
    'Set the color of the cell named "RGBColor"
    Range("A2").Interior.Color = FullColorCode

Else
   
    'Do nothing if the user selected cancel

End If

End Sub

'-----------------------
Private Sub Get_AllPar()
'-----------------------
' Generates a list of all MobaledLib Macro parameters and how often the parameter is used
  Dim C As Variant, Res As String, F As Variant, sh As Worksheet
  Res = " "
  Set sh = Sheets("Tabelle3")
  For Each C In ActiveSheet.UsedRange.Cells
      If C <> "" Then
      Set F = sh.Cells.Find(What:=C, After:=ActiveCell, LookIn:=xlFormulas, LookAt:=xlPart, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=False, SearchFormat:=False)
      Dim r As Long
      With sh
        If F Is Nothing Then
           r = LastUsedRowIn(sh) + 1
           .Cells(r, 1) = C
        Else: r = F.Row
        End If
        .Cells(r, 2) = Val(.Cells(r, 2)) + 1
      End With
      'If InStr(Res, " " & c & " ") = 0 Then Res = Res & c & " "
      End If
  Next C
  'Debug.Print Res
  
End Sub

'-----------------------------------
Private Sub Buttons_with_vblf_Text()
'-----------------------------------
  ActiveSheet.Shapes("Insert_Button").DrawingObject.Object.Caption = "Zeile" & vbLf & "einf|fffd|gen"
  ActiveSheet.Shapes("Del_Button").DrawingObject.Object.Caption = "L|fffd|sche" & vbLf & "Zeilen"
  ActiveSheet.Shapes("Move_Button").DrawingObject.Object.Caption = "Verschiebe" & vbLf & "Zeilen"
  ActiveSheet.Shapes("ClearSheet_Button").DrawingObject.Object.Caption = "L|fffd|sche" & vbLf & "Tabelle"
End Sub
Attribute VB_Name = "SelectMacros_Form"
Attribute VB_Base = "0{2330D8D7-91A0-457B-8668-8B31C0654410}{B6190668-ABF0-4160-A18D-F42EA6C72DF6}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
' SelectMacros_Form
' ~~~~~~~~~~~~~~~~~

' Module Description:
' ~~~~~~~~~~~~~~~~~~~
' This module contains functions for the SelectMacros dialog.
' The user could select a Macromouse.
' The result is stored in the public variable SelectMacro_Res
' as a list of models separated by space characters.

' Revision History:
' ~~~~~~~~~~~~~~~~~
' 19.08.19: - Started

Option Explicit

Private Enable_Listbox_Changed As Boolean
Private SrcSh As Worksheet

Private ListDataSh As String

'-------------------------------
Private Sub Abort_Button_Click()
'-------------------------------
  UnhookFormScroll ' Deactivate the mouse wheel scroll function
  Me.Hide  ' no "Unload Me" to Don't keep the entered data.
  SelectMacro_Res = ""
  Enable_Listbox_Changed = False
End Sub

'---------------------------------
Private Sub Calc_SelectMacro_Res()
'---------------------------------
' Return the name and the row number in the ListDataSheet
' If MultiSelect is enabled a space separated list is returned
  Dim Nr As Long, Res As String
  For Nr = 0 To ListBox.ListCount - 1
      If ListBox.Selected(Nr) Then
         Res = Res & ListBox.List(Nr, 0) & "," & Get_Row_with_Mode_Filter(Nr) & " " ' Return "Name,Nr"  Nr: row nr in the data sheet
      End If
  Next Nr
  SelectMacro_Res = DelLast(Res) ' Delete the tailing space
End Sub


'--------------------------------
Private Sub Select_Button_Click()
'--------------------------------
  UnhookFormScroll ' Deactivate the mouse weel scrol function
  Me.Hide ' no "Unload Me" to keep the entered data.
  Enable_Listbox_Changed = False
  Calc_SelectMacro_Res
End Sub

'--------------------------------------------------------
Private Function Get_Row_with_Mode_Filter(ListNr As Long)
'--------------------------------------------------------
  Dim Nr As Long, r As Long
  r = SM_DIALOGDATA_ROW1
  Nr = -1
  With Sheets(ListDataSh)
    While True
      If .Cells(r, SM_Mode__COL) = "" Or Expert_CheckBox Then Nr = Nr + 1
      If Nr < ListNr Then
            r = r + 1
      Else
           Get_Row_with_Mode_Filter = r
           Exit Function
      End If
    Wend
  End With
End Function


'---------------------------
Private Sub ListBox_Change()
'---------------------------
  Description = ""
  Detail = ""
  If Enable_Listbox_Changed Then
     Dim Nr As Long, cnt As Long
     For Nr = 0 To ListBox.ListCount - 1
         If ListBox.Selected(Nr) Then
            cnt = cnt + 1
            Dim Row As Long
            Row = Get_Row_with_Mode_Filter(Nr)
            Dim Txt As String
            Txt = Replace(SrcSh.Cells(Row, SM_DetailCOL), "|", vbLf)
            If Txt <> "" Then
                  Description = Description & Txt & vbCr
            Else: Description = Description & SrcSh.Cells(Row, SM_ShrtD_COL) & vbCr
            End If
            Detail = Detail & Replace_Double_Space(SrcSh.Cells(Row, SM_Macro_COL)) & vbCr ' Show one or more selected details
         End If
     Next
     SelectedCnt_Label = "Selected: " & cnt
  End If
  
End Sub

'------------------------------------------------------------------
Private Sub ListBox_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
'------------------------------------------------------------------
  Select_Button_Click
End Sub

'-------------------------
Private Sub Add_Filtered()
'-------------------------
  Dim r As Range, C As Range
  With Sheets(ListDataSh)
     Set r = .Range(.Cells(SM_DIALOGDATA_ROW1, SM_Name__COL), .Cells(LastUsedRowIn(ThisWorkbook.Sheets(ListDataSh)), SM_Name__COL))
     For Each C In r
       If .Cells(C.Row, SM_Mode__COL) = "" Or Expert_CheckBox Then
          ListBox.AddItem C.Value
          ListBox.List(ListBox.ListCount - 1, 1) = C.Offset(0, 1).Value
       End If
     Next C
  End With
End Sub

'----------------------------------
Private Sub Expert_CheckBox_Click()
'----------------------------------
  Load_Models_to_Listbox ListDataSh
End Sub


'-----------------------------------------------------------
Private Sub Load_Models_to_Listbox(ListDataSh_par As String)
'-----------------------------------------------------------
' Defines the sheet which contains the models and loads the data into the form.
  ListDataSh = ListDataSh_par
  On Error Resume Next ' For some reasons this function is called two times and the second call generates a crash
  Set SrcSh = ThisWorkbook.Sheets(ListDataSh)
  Me.ListBox.Clear
  On Error GoTo 0
  With Me.ListBox
      .ColumnCount = 2
      .ColumnWidths = "100 Pt"
      Add_Filtered
  End With
End Sub

'--------------------------------
Private Sub UserForm_Initialize()
'--------------------------------
  'Debug.Print vbCr & me.Name & ": UserForm_Initialize"
  Center_Form Me
End Sub

'-----------------------------------------------
Public Sub MouseWheel(ByVal lngRotation As Long)
'-----------------------------------------------
' Process the mouse wheel changes
  With ListBox     ' Adapt to the listbox which should be controlled
    If lngRotation > 0 Then
        If .TopIndex > 0 Then
            If .TopIndex > 3 Then
                .TopIndex = .TopIndex - 3
            Else
                .TopIndex = 0
            End If
        End If
    Else
        .TopIndex = .TopIndex + 3
    End If
  End With
End Sub


'----------------------------------------------
Sub Show_SelectMacros_Form(ListDataSh As String)
'----------------------------------------------
' Use this function to show the dialog.
  Load_Models_to_Listbox ListDataSh
  Enable_Listbox_Changed = True
  SelectedCnt_Label = "Selected: 0"
  Me.Controls("ListBox").SetFocus
  
  HookFormScroll Me, "ListBox"   ' Initialize the mouse wheel scroll function

  Me.Show
End Sub



Attribute VB_Name = "Serial_Test"
Option Explicit

' https://www.ozgrid.com/forum/forum/help-forums/excel-vba-macros/147023-vba-button-to-send-command-to-serial-port-to-get-data-and-send-to-excel


' Das Empfangen von seriellen Zeichen funktioniert prinzipiel, aber
' Die Input und Get Funktion warten so lange bis ein Zeichen kommt.
' Das f|fffd|hrt dazu, dass nichts mehr geht bis das n|fffd|chste Zeichen kommt ;-(
' Der Abbruch Button geht nur wenn ein Zeichen kommt

' Threads:
' https://codereview.stackexchange.com/questions/185212/a-new-approach-to-multithreading-in-excel
' https://analystcave.com/excel-vba-multithreading-tool/
' => C:\Users\Hardi\Downloads\VBA-Multithreading-Tool_20141221\VBA Multithreading Tool_20141221
' Noch nicht ausprobiert
'
' http://mikejuniperhill.blogspot.com/2017/06/excelvba-multi-threading-example.html

Public End_Serial_Test As Boolean

Private Test_Cnt As Long

Sub Debug_Text()
  Debug.Print "**" & Test_Cnt
  If Test_Cnt < 15 Then Application.OnTime Now + TimeValue("00:00:01"), "Debug_Text"
  Test_Cnt = Test_Cnt + 1
End Sub

'---------------------
Private Sub Test_Com()
'---------------------
  Dim C As String
  Dim fp As Integer
  fp = FreeFile

  End_Serial_Test = False
  Test_Cnt = 0
  UserForm_SerialTest.Show
  
    Open "COM7:115200,N,8,1" For Binary Access Read Write As #fp 'Open the com port
    'Put #fp, , sendVar$ 'write string to interface
    Application.OnTime Now + TimeValue("00:00:01"), "Debug_Text"
    C = ""
    While Not End_Serial_Test And Test_Cnt < 10
        'If Not EOF(fp) Then ' Geht nicht
            'c = Input(1, #fp)        ' Wartet bis ein Zeichen kommt ;-(
            C = "###"
            On Error Resume Next
            Get #fp, , C
            On Error GoTo 0
            If C <> "" And C <> "###" Then
                'Answer = Answer + c   'add, if printable char
                Debug.Print C;
            End If
        'End If
        DoEvents
        Sleep 100
    Wend
    Close #fp
    Debug.Print "End Serial Test"
End Sub

Attribute VB_Name = "Tabelle1"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Control = "UnHideAll_Button, 16, 1, MSForms, CommandButton"
Attribute VB_Control = "Hide_Button, 15, 2, MSForms, CommandButton"
Attribute VB_Control = "Arduino_Button, 14, 3, MSForms, CommandButton"
Attribute VB_Control = "Del_Button, 13, 4, MSForms, CommandButton"
Attribute VB_Control = "Move_Button, 11, 5, MSForms, CommandButton"
Attribute VB_Control = "Insert_Button, 9, 6, MSForms, CommandButton"
Attribute VB_Control = "Help_Button, 6, 7, MSForms, CommandButton"
Attribute VB_Control = "Dialog_Button, 5, 8, MSForms, CommandButton"
Attribute VB_Control = "ClearSheet_Button, 7, 9, MSForms, CommandButton"
Attribute VB_Control = "Copy_Button, 17, 10, MSForms, CommandButton"
Attribute VB_Control = "Options_Button, 31, 11, MSForms, CommandButton"
Option Explicit

'---------------------------------
Private Sub Arduino_Button_Click()
'---------------------------------
  Button_Pressed_Proc
  Create_HeadderFile
End Sub

'------------------------------------
Private Sub ClearSheet_Button_Click()
'------------------------------------
  Button_Pressed_Proc
  ClearSheet
End Sub

'-------------------------------
Private Sub Dialog_Button_Click()
'-------------------------------
  Button_Pressed_Proc
  Dialog_Guided_Input
End Sub

'------------------------------
Private Sub Help_Button_Click()
'------------------------------
  Button_Pressed_Proc
  Show_Help
End Sub


'--------------------------------
Private Sub Button_Pressed_Proc()
'--------------------------------
  Selection.Select ' Remove the focus from the button
  Application.EnableEvents = True ' In case the program crashed before
  Correct_Buttonsizes
End Sub


Private Sub Name_with_LF()
  Hide_Button.Caption = "Aus- oder" & vbLf & "Einblenden"
End Sub

'-----------------------------------------
Private Sub Correct_Create_Buttonsize(obj)
'-----------------------------------------
  obj.Height = 160
  obj.Width = 100
  obj.Height = 76
  obj.Width = 60
End Sub

'------------------------
Sub Correct_Buttonsizes()
'------------------------
' There is a bug in excel which changes the size of the buttons
' if the resolution of the display is changed. This happens
' fore instance if the computer is connected to a beamer.
' To prevent this the buttons are resized with this function.
  Dim OldScreenupdating As Boolean
  OldScreenupdating = Application.ScreenUpdating
  Application.ScreenUpdating = False

  Correct_Create_Buttonsize Arduino_Button
  Correct_Create_Buttonsize Dialog_Button
  Correct_Create_Buttonsize Insert_Button
  Correct_Create_Buttonsize Del_Button
  Correct_Create_Buttonsize Move_Button
  Correct_Create_Buttonsize Copy_Button
  Correct_Create_Buttonsize Hide_Button
  Correct_Create_Buttonsize UnHideAll_Button
  
  Correct_Create_Buttonsize ClearSheet_Button
  Correct_Create_Buttonsize Options_Button
  Correct_Create_Buttonsize Help_Button
  
  Application.ScreenUpdating = OldScreenupdating
End Sub

'------------------------------------------------------
Public Sub EnableDisableAllButtons(Enab As Boolean)
'------------------------------------------------------
  Arduino_Button.Enabled = Enab
  Dialog_Button.Enabled = Enab
  Insert_Button.Enabled = Enab
  Del_Button.Enabled = Enab
  Move_Button.Enabled = Enab
  Copy_Button.Enabled = Enab
  Hide_Button.Enabled = Enab
  UnHideAll_Button.Enabled = Enab
  
  ClearSheet_Button.Enabled = Enab
  Options_Button.Enabled = Enab
End Sub

'-----------------------------
Private Sub EnableAllButtons()
'-----------------------------
' Could be called manually after a crash
  EnableDisableAllButtons True
End Sub


'------------------------------
Private Sub Hide_Button_Click()
'------------------------------
  Button_Pressed_Proc
  Proc_Hide_Unhide
End Sub

Private Sub Insert_Button_Click()
  Button_Pressed_Proc
  Proc_Insert_Line
End Sub

'-----------------------------
Private Sub Del_Button_Click()
'-----------------------------
  Button_Pressed_Proc
  Proc_Del_Row
End Sub

'------------------------------
Private Sub Move_Button_Click()
'------------------------------
  Button_Pressed_Proc
  Proc_Move_Row
End Sub

'------------------------------
Private Sub Copy_Button_Click()
'------------------------------
  Button_Pressed_Proc
  Proc_Copy_Row
End Sub

'----------------------------------
Private Sub Options_Button_Click()
'----------------------------------
  Button_Pressed_Proc
  Option_Dialog
End Sub

'-----------------------------------
Private Sub UnHideAll_Button_Click()
'-----------------------------------
  Button_Pressed_Proc
  Proc_UnHide_All
End Sub

'--------------------------------------------------------
Private Sub Worksheet_Change(ByVal Target As Excel.Range)
'--------------------------------------------------------
' This function is called if the worksheet is changed.
' It performs several checks after a user input depending form the column of the changed cell:
  Global_Worksheet_Change Target
End Sub

'-----------------------------------------------------------------
Private Sub Worksheet_SelectionChange(ByVal Target As Excel.Range)
'-----------------------------------------------------------------
' Is called by event if the worksheet selection has changed
  Global_Worksheet_SelectionChange Target
End Sub

'-------------------------------
Private Sub Worksheet_Activate()
'-------------------------------
  Global_Worksheet_Activate
End Sub

'--------------------------------
Private Sub Worksheet_Calculate()
'--------------------------------
  If Cells.Parent.Name = ActiveSheet.Name Then ' At program start the Worksheet_Calculate proc is called without activating the sheet.
     Global_Worksheet_Calculate                ' This causes a crash in Make_sure_that_Col_Variables_match
  End If
End Sub

Attribute VB_Name = "Tabelle11"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Control = "Dialog_Button, 1, 0, MSForms, CommandButton"
Attribute VB_Control = "Help_Button, 2, 1, MSForms, CommandButton"
Attribute VB_Control = "ClearSheet_Button, 3, 2, MSForms, CommandButton"
Attribute VB_Control = "Insert_Button, 4, 3, MSForms, CommandButton"
Attribute VB_Control = "Move_Button, 5, 4, MSForms, CommandButton"
Attribute VB_Control = "Del_Button, 6, 5, MSForms, CommandButton"
Attribute VB_Control = "Arduino_Button, 7, 6, MSForms, CommandButton"
Attribute VB_Control = "Hide_Button, 8, 7, MSForms, CommandButton"
Attribute VB_Control = "UnHideAll_Button, 9, 8, MSForms, CommandButton"
Attribute VB_Control = "Copy_Button, 10, 9, MSForms, CommandButton"
Attribute VB_Control = "Options_Button, 24, 10, MSForms, CommandButton"
Option Explicit

'---------------------------------
Private Sub Arduino_Button_Click()
'---------------------------------
  Button_Pressed_Proc
  Create_HeadderFile
End Sub

'------------------------------------
Private Sub ClearSheet_Button_Click()
'------------------------------------
  Button_Pressed_Proc
  ClearSheet
End Sub

'-------------------------------
Private Sub Dialog_Button_Click()
'-------------------------------
  Button_Pressed_Proc
  Dialog_Guided_Input
End Sub

'------------------------------
Private Sub Help_Button_Click()
'------------------------------
  Button_Pressed_Proc
  Show_Help
End Sub


'--------------------------------
Private Sub Button_Pressed_Proc()
'--------------------------------
  Selection.Select ' Remove the focus from the button
  Application.EnableEvents = True ' In case the program crashed before
  Correct_Buttonsizes
End Sub


Private Sub Name_with_LF()
  Hide_Button.Caption = "Aus- oder" & vbLf & "Einblenden"
End Sub

'-----------------------------------------
Private Sub Correct_Create_Buttonsize(obj)
'-----------------------------------------
  obj.Height = 160
  obj.Width = 100
  obj.Height = 76
  obj.Width = 60
End Sub

'------------------------
Sub Correct_Buttonsizes()
'------------------------
' There is a bug in excel which changes the size of the buttons
' if the resolution of the display is changed. This happens
' fore instance if the computer is connected to a beamer.
' To prevent this the buttons are resized with this function.
  Dim OldScreenupdating As Boolean
  OldScreenupdating = Application.ScreenUpdating
  Application.ScreenUpdating = False

  Correct_Create_Buttonsize Arduino_Button
  Correct_Create_Buttonsize Dialog_Button
  Correct_Create_Buttonsize Insert_Button
  Correct_Create_Buttonsize Del_Button
  Correct_Create_Buttonsize Move_Button
  Correct_Create_Buttonsize Copy_Button
  Correct_Create_Buttonsize Hide_Button
  Correct_Create_Buttonsize UnHideAll_Button
  
  Correct_Create_Buttonsize ClearSheet_Button
  Correct_Create_Buttonsize Options_Button
  Correct_Create_Buttonsize Help_Button
  
  Application.ScreenUpdating = OldScreenupdating
End Sub

'------------------------------------------------------
Public Sub EnableDisableAllButtons(Enab As Boolean)
'------------------------------------------------------
  Arduino_Button.Enabled = Enab
  Dialog_Button.Enabled = Enab
  Insert_Button.Enabled = Enab
  Del_Button.Enabled = Enab
  Move_Button.Enabled = Enab
  Copy_Button.Enabled = Enab
  Hide_Button.Enabled = Enab
  UnHideAll_Button.Enabled = Enab
  
  ClearSheet_Button.Enabled = Enab
  Help_Button.Enabled = Enab
End Sub

'-----------------------------
Private Sub EnableAllButtons()
'-----------------------------
' Could be called manually after a crash
  EnableDisableAllButtons True
End Sub


'------------------------------
Private Sub Hide_Button_Click()
'------------------------------
  Button_Pressed_Proc
  Proc_Hide_Unhide
End Sub

Private Sub Insert_Button_Click()
  Button_Pressed_Proc
  Proc_Insert_Line
End Sub

'-----------------------------
Private Sub Del_Button_Click()
'-----------------------------
  Button_Pressed_Proc
  Proc_Del_Row
End Sub

'------------------------------
Private Sub Move_Button_Click()
'------------------------------
  Button_Pressed_Proc
  Proc_Move_Row
End Sub

'------------------------------
Private Sub Copy_Button_Click()
'------------------------------
  Button_Pressed_Proc
  Proc_Copy_Row
End Sub

'-----------------------------------
Private Sub UnHideAll_Button_Click()
'-----------------------------------
  Button_Pressed_Proc
  Proc_UnHide_All
End Sub

'----------------------------------
Private Sub Options_Button_Click()
'----------------------------------
  Button_Pressed_Proc
  Option_Dialog
End Sub



'--------------------------------------------------------
Private Sub Worksheet_Change(ByVal Target As Excel.Range)
'--------------------------------------------------------
' This function is called if the worksheet is changed.
' It performs several checks after a user input depending form the column of the changed cell:
  Global_Worksheet_Change Target
End Sub

'-----------------------------------------------------------------
Private Sub Worksheet_SelectionChange(ByVal Target As Excel.Range)
'-----------------------------------------------------------------
' Is called by event if the worksheet selection has changed
  Global_Worksheet_SelectionChange Target
End Sub

'-------------------------------
Private Sub Worksheet_Activate()
'-------------------------------
  Global_Worksheet_Activate
End Sub


'--------------------------------
Private Sub Worksheet_Calculate()
'--------------------------------
  If Cells.Parent.Name = ActiveSheet.Name Then ' At program start the Worksheet_Calculate proc is called without activating the sheet.
     Global_Worksheet_Calculate                ' This causes a crash in Make_sure_that_Col_Variables_match
  End If
End Sub

Attribute VB_Name = "Tabelle2"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Control = "Dialog_Button, 1, 0, MSForms, CommandButton"
Attribute VB_Control = "Help_Button, 2, 1, MSForms, CommandButton"
Attribute VB_Control = "ClearSheet_Button, 3, 2, MSForms, CommandButton"
Attribute VB_Control = "Insert_Button, 4, 3, MSForms, CommandButton"
Attribute VB_Control = "Move_Button, 5, 4, MSForms, CommandButton"
Attribute VB_Control = "Del_Button, 6, 5, MSForms, CommandButton"
Attribute VB_Control = "Arduino_Button, 7, 6, MSForms, CommandButton"
Attribute VB_Control = "Hide_Button, 8, 7, MSForms, CommandButton"
Attribute VB_Control = "UnHideAll_Button, 9, 8, MSForms, CommandButton"
Attribute VB_Control = "Copy_Button, 10, 9, MSForms, CommandButton"
Attribute VB_Control = "Options_Button, 11, 10, MSForms, CommandButton"
Option Explicit

'---------------------------------
Private Sub Arduino_Button_Click()
'---------------------------------
  Button_Pressed_Proc
  Create_HeadderFile
End Sub

'------------------------------------
Private Sub ClearSheet_Button_Click()
'------------------------------------
  Button_Pressed_Proc
  ClearSheet
End Sub

'-------------------------------
Private Sub Dialog_Button_Click()
'-------------------------------
  Button_Pressed_Proc
  Dialog_Guided_Input
End Sub

'------------------------------
Private Sub Help_Button_Click()
'------------------------------
  Button_Pressed_Proc
  Show_Help
End Sub


'--------------------------------
Private Sub Button_Pressed_Proc()
'--------------------------------
  Selection.Select ' Remove the focus from the button
  Application.EnableEvents = True ' In case the program crashed before
  Correct_Buttonsizes
End Sub


Private Sub Name_with_LF()
  Hide_Button.Caption = "Aus- oder" & vbLf & "Einblenden"
End Sub

'-----------------------------------------
Private Sub Correct_Create_Buttonsize(obj)
'-----------------------------------------
  obj.Height = 160
  obj.Width = 100
  obj.Height = 76
  obj.Width = 60
End Sub

'------------------------
Sub Correct_Buttonsizes()
'------------------------
' There is a bug in excel which changes the size of the buttons
' if the resolution of the display is changed. This happens
' for instance if the computer is connected to a beamer.
' To prevent this the buttons are resized with this function.
' Unfortunately this take some time (600ms)
'  Start_ms_Timer
  Dim OldScreenupdating As Boolean
  OldScreenupdating = Application.ScreenUpdating
  Application.ScreenUpdating = False

  Correct_Create_Buttonsize Arduino_Button
  Correct_Create_Buttonsize Dialog_Button
  Correct_Create_Buttonsize Insert_Button
  Correct_Create_Buttonsize Del_Button
  Correct_Create_Buttonsize Move_Button
  Correct_Create_Buttonsize Copy_Button
  Correct_Create_Buttonsize Hide_Button
  Correct_Create_Buttonsize UnHideAll_Button
  
  Correct_Create_Buttonsize ClearSheet_Button
  Correct_Create_Buttonsize Options_Button
  Correct_Create_Buttonsize Help_Button
  
  Application.ScreenUpdating = OldScreenupdating
'  Debug.Print "Correct_Buttonsizes duration " & Get_ms_Duration() & " ms"
End Sub

'------------------------------------------------------
Public Sub EnableDisableAllButtons(Enab As Boolean)
'------------------------------------------------------
  Arduino_Button.Enabled = Enab
  Dialog_Button.Enabled = Enab
  Insert_Button.Enabled = Enab
  Del_Button.Enabled = Enab
  Move_Button.Enabled = Enab
  Copy_Button.Enabled = Enab
  Hide_Button.Enabled = Enab
  UnHideAll_Button.Enabled = Enab
  
  ClearSheet_Button.Enabled = Enab
  Options_Button.Enabled = Enab
End Sub

'-----------------------------
Private Sub EnableAllButtons()
'-----------------------------
' Could be called manually after a crash
  EnableDisableAllButtons True
End Sub


'------------------------------
Private Sub Hide_Button_Click()
'------------------------------
  Button_Pressed_Proc
  Proc_Hide_Unhide
End Sub

Private Sub Insert_Button_Click()
  Button_Pressed_Proc
  Proc_Insert_Line
End Sub

'-----------------------------
Private Sub Del_Button_Click()
'-----------------------------
  Button_Pressed_Proc
  Proc_Del_Row
End Sub

'------------------------------
Private Sub Move_Button_Click()
'------------------------------
  Button_Pressed_Proc
  Proc_Move_Row
End Sub

'------------------------------
Private Sub Copy_Button_Click()
'------------------------------
  Button_Pressed_Proc
  Proc_Copy_Row
End Sub

'----------------------------------
Private Sub Options_Button_Click()
'----------------------------------
  Button_Pressed_Proc
  Option_Dialog
End Sub

'-----------------------------------
Private Sub UnHideAll_Button_Click()
'-----------------------------------
  Button_Pressed_Proc
  Proc_UnHide_All
End Sub

'--------------------------------------------------------
Private Sub Worksheet_Change(ByVal Target As Excel.Range)
'--------------------------------------------------------
' This function is called if the worksheet is changed.
' It performs several checks after a user input depending form the column of the changed cell:
  Global_Worksheet_Change Target
End Sub

'-----------------------------------------------------------------
Private Sub Worksheet_SelectionChange(ByVal Target As Excel.Range)
'-----------------------------------------------------------------
' Is called by event if the worksheet selection has changed
  Global_Worksheet_SelectionChange Target
End Sub

'-------------------------------
Private Sub Worksheet_Activate()
'-------------------------------
  Global_Worksheet_Activate
End Sub

'--------------------------------
Private Sub Worksheet_Calculate()
'--------------------------------
  If Cells.Parent.Name = ActiveSheet.Name Then ' At program start the Worksheet_Calculate proc is called without activating the sheet.
     Global_Worksheet_Calculate                ' This causes a crash in Make_sure_that_Col_Variables_match
  End If
End Sub


Attribute VB_Name = "Tabelle3"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

'-------------------------------
Private Sub Worksheet_Activate()
'-------------------------------
  Global_Worksheet_Activate
End Sub

Attribute VB_Name = "Tabelle5"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Control = "Start_Button, 2, 0, MSForms, CommandButton"
Option Explicit

'-------------------------------
Private Sub Start_Button_Click()
'-------------------------------
  Arduino_Button_StartPage
End Sub

'-------------------------------
Private Sub Worksheet_Activate()
'-------------------------------
  Global_Worksheet_Activate
End Sub

Attribute VB_Name = "Tabelle6"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Tabelle8"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

'-------------------------------
Private Sub Worksheet_Activate()
'-------------------------------
  Global_Worksheet_Activate
End Sub

Attribute VB_Name = "UserForm_Connector"
Attribute VB_Base = "0{E6D0CF08-5A08-4FC2-B66A-8708C69DD017}{0BCB04D2-CD3A-415F-A9CB-4821FD5AF6E0}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private OK_Pressed As Boolean

'-------------------------------
Private Sub Abort_Button_Click()
'-------------------------------
  Me.Hide
End Sub


'----------------------------
Private Sub OK_Button_Click()
'----------------------------
  OK_Pressed = True
  Me.Hide
End Sub

'--------------------------------
Private Sub UserForm_Initialize()
'--------------------------------
  'Debug.Print vbCr & me.Name & ": UserForm_Initialize"
  Center_Form Me
End Sub



'-----------------------------------------------------------------------------------
Public Function Start(Dist_Nr_R As Excel.Range, Conn_Nr_R As Excel.Range) As Boolean
'-----------------------------------------------------------------------------------
  Dist_Nr = Dist_Nr_R
  Conn_Nr = Conn_Nr_R
  OK_Pressed = False
  
  Dist_Nr.SetFocus
  
  Me.Show
  
  If OK_Pressed Then
    Dist_Nr_R = Dist_Nr
    Conn_Nr_R = Conn_Nr
  End If
  Start = OK_Pressed
End Function

Attribute VB_Name = "UserForm_Description"
Attribute VB_Base = "0{AC381070-DB4A-4100-94AA-C8702F5C55D0}{88EB9144-AC75-43C7-97BD-FB41DC72B688}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit


'-------------------------------
Private Sub Abort_Button_Click()
'-------------------------------
  TextBox = "<Abort>"
  Me.Hide
End Sub


'----------------------------
Private Sub OK_Button_Click()
'----------------------------
  'Userform_Res = TextBox.Value
  Me.Hide
End Sub

'--------------------------------
Private Sub UserForm_Initialize()
'--------------------------------
  'Debug.Print vbCr & Me.Name & ": UserForm_Initialize"
  Center_Form Me
End Sub

'------------------------------------------------------
Public Function ShowForm(ByVal Txt As String) As String
'------------------------------------------------------
  TextBox.SetFocus
  TextBox.Value = Txt
  Me.Show
  ShowForm = TextBox
End Function
Attribute VB_Name = "UserForm_DialogGuide1"
Attribute VB_Base = "0{B0F31315-1090-4C32-9901-7AE1629D8927}{E8763BBD-69ED-47CC-8612-3FB74D13DFA0}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

'----------------------------
Private Sub OK_Button_Click()
'----------------------------
  DialogGuideRes = vbOK
  Me.Hide
End Sub

'------------------------------
Private Sub UserForm_Activate()
'------------------------------
  DialogGuideRes = -1
End Sub

'-------------------------------
Private Sub Abort_Button_Click()
'-------------------------------
  DialogGuideRes = vbAbort
  Me.Hide
End Sub

'------------------------------------
Public Function IsActive() As Boolean
'------------------------------------
  IsActive = Me.Visible
End Function


'--------------------------------
Private Sub UserForm_Initialize()
'--------------------------------
  'Debug.Print vbCr & Me.Name & ": UserForm_Initialize"
  Center_Form Me
End Sub

Attribute VB_Name = "UserForm_Header_Created"
Attribute VB_Base = "0{EA23B3D5-5DC7-4982-879E-E75F91B51223}{CDCF56F4-2B1C-49BE-A597-F7EA06D402FC}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

'-------------------------------
Private Sub Abort_Button_Click()
'-------------------------------
  Me.Hide
End Sub

'---------------------------
Private Sub EditFile_Click()
'---------------------------
  Me.Hide
  Call ShellExecute(0, "open", "Notepad", """" & FileName & """", "", SW_NORMAL)
End Sub

'-------------------------
Private Sub Image1_Click()
'-------------------------
  OK_Click
End Sub

'---------------------
Private Sub OK_Click()
'---------------------
  Me.Hide
  Compile_and_Upload_LED_Prog_to_Arduino
End Sub

'---------------------------
Private Sub OpenPath_Click()
'---------------------------
  Me.Hide
  'Call ShellExecute(0, "open", "Explorer", "/e,""" & ThisWorkbook.Path & """", "", SW_NORMAL)
  
  Dim Name As String
  Name = ThisWorkbook.Path & "\" & Include_FileName
  If Dir(Name) <> FileNameExt(Name) Then
        Shell "Explorer /root,""" & FilePath(Name) & """", vbNormalFocus
  Else: Shell "Explorer /Select,""" & Name & """", vbNormalFocus
  End If
End Sub

'---------------------------------------
Private Sub Right_Arduino_Button_Click()
'---------------------------------------
  Ask_to_Upload_and_Compile_and_Upload_Prog_to_Right_Arduino
End Sub

'-----------------------------
Private Sub USB_Button_Click()
'-----------------------------
  USB_Port_Dialog COMPort_COL
End Sub

'--------------------------------
Private Sub UserForm_Initialize()
'--------------------------------
  'Debug.Print vbCr & Me.Name & ": UserForm_Initialize"
  Center_Form Me
End Sub

Attribute VB_Name = "UserForm_House"
Attribute VB_Base = "0{18FEAA14-E0B9-4B53-B6B2-2CE93B32C77B}{BCA35E2F-142A-41C6-BBE9-EFF869516704}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Mode As String
Private LED_CntList As String
Private MinCntChanged As Boolean
Private MaxCntChanged As Boolean

Private Sub Set_Color_in_y_Range(StartY As Long, EndY As Long, ForeColor As Long)
  Dim C As Variant
  For Each C In Controls
     If C.Top >= StartY And C.Top < EndY Then
        C.ForeColor = ForeColor  ' &H80000012&
     End If
  Next C
End Sub

'--------------------------------------
Public Sub SetMode(MacroName As String)
'--------------------------------------
  Mode = MacroName
  Select Case MacroName
    Case "House":     Set_Color_in_y_Range CommandButton27.Top, CommandButton54.Top, &H80000011
    Case "GasLights": Set_Color_in_y_Range CommandButton35.Top, CommandButton27.Top, &H80000011
                      Hide_and_Move_up Me, "CommandButton1", "CommandButton35"
                      Hide_and_Move_up Me, "MinCnt_TextBox", "Abort_Button"
                      Me.Caption = "Gaslights: Die Gaslaternen werden zuf|fffd|llig, nacheinander aktiviert. Sie erreichen erst nach einiger Zeit die volle Helligkeit und flackern manchmal."
                      Me.Description_Label = "Stra|fffd|enlaternen sind ein wichtiger Bestandteil einer virtuellen Stadt. Sie beleuchten die n|fffd|chtlichen Stra|fffd|en und erzeugen eine warme Atmosph|fffd|re insbesondere, wenn es sich um Gaslaternen handelt. " & _
                                             "Die Lampen gehen zuf|fffd|llig an und werden dann langsam heller bis sie die volle Helligkeit erreichen. Au|fffd|erdem ist noch ein zuf|fffd|lliges Flackern implementiert welches durch Schwankungen im Gasdruck oder durch Windb|fffd|en entstehen kann."
  End Select
End Sub

'-------------------------------------------
Private Sub IndividualTimes_CheckBox_Click()
'-------------------------------------------
  MinTime_TextBox.Enabled = Me.ActiveControl
  MaxTime_TextBox.Enabled = Me.ActiveControl
End Sub

'-----------------------------------------------------------------
Private Sub LimmitActivInput(ct As Control, MinVal As Integer, MaxVal As Integer)
'-----------------------------------------------------------------
  With ct
    If Not IsNumeric(.Value) Then
       While Len(.Value) > 0 And Not IsNumeric(.Value)
         .Value = DelLast(.Value)
       Wend
    Else
         If Val(.Value) < MinVal Then .Value = MinVal
         If Val(.Value) > MaxVal Then .Value = MaxVal
         If Round(.Value, 0) <> .Value Then .Value = Round(.Value, 0)
    End If
  End With
End Sub

'----------------------------------
Private Sub MinCnt_TextBox_Change()
'----------------------------------
  MinCntChanged = True
  LimmitActivInput MinCnt_TextBox, 0, 255
End Sub

'----------------------------------
Private Sub MaxCnt_TextBox_Change()
'----------------------------------
  MaxCntChanged = True
  LimmitActivInput MaxCnt_TextBox, 1, 255
End Sub

'----------------------------------------
Private Sub Set_MinMaxCnt(LEDCnt As Long)
'----------------------------------------
' Set MinCnt to 1/3 LEDCnt
' And MaxCnt to 2/3 LEDCnt
#If 1 Then
  Application.EnableEvents = False
  If Not MinCntChanged Then
     Dim Val As Long
     Val = Round(LEDCnt / 3, 0)
     If Val < 1 Then Val = 1
     MinCnt_TextBox = Val
     MinCntChanged = False
  End If
  If Not MaxCntChanged Then
     MaxCnt_TextBox = Round(2 * LEDCnt / 3, 0)
     MaxCntChanged = False
  End If
  Application.EnableEvents = True
#End If
End Sub

'-----------------------------------
Private Sub MinTime_TextBox_Change()
'-----------------------------------
  LimmitActivInput MinTime_TextBox, 0, 254
End Sub

'-----------------------------------
Private Sub MaxTime_TextBox_Change()
'-----------------------------------
  LimmitActivInput MaxTime_TextBox, 0, 254
End Sub

'----------------------------
Private Sub OK_Button_Click()
'----------------------------
  Dim cnt As Long
  cnt = Count_Used_RGB_Channels()
  If cnt = 0 Then
     MsgBox "Das Haus enth|fffd|lt noch keine R|fffd|ume" & vbCr & _
            "Bitte w|fffd|hlen die mindestens einen Raumtyp aus", vbInformation, "Kein Raum ausgew|fffd|hlt"
     Exit Sub
  End If
  
  Userform_Res = cnt & "|"
  If Mode = "House" Then
    If IndividualTimes_CheckBox Then
          Userform_Res = Userform_Res & "HouseT"
    Else: Userform_Res = Userform_Res & "House"
    End If
  Else:   Userform_Res = Userform_Res & "GasLights"
  End If
  Userform_Res = Userform_Res & "(#LED, #InCh, "
  If Mode = "House" Then
     Userform_Res = Userform_Res & MinCnt_TextBox & ", " & MaxCnt_TextBox & ", "
     If IndividualTimes_CheckBox Then Userform_Res = Userform_Res & MinTime_TextBox & ", " & MaxTime_TextBox & ", "
  End If
  Userform_Res = Userform_Res & SelectedRooms_TextBox & ")"
  
  'Me.Hide
  Unload Me ' Don't keep the entered data.
End Sub

'-------------------------------
Private Sub Abort_Button_Click()
'-------------------------------
  Userform_Res = ""
  Me.Hide
  Unload Me ' Don't keep the entered data.
End Sub

'-----------------------------------------
Private Function Count_Used_RGB_Channels()
'-----------------------------------------
' Single LEDs (Connected to a WS2811) are counted as one LED as long as they are in
' assending order.
' 1 2 3 = one RGB LED
' 1 1 1 = three RGB LEDs
  Dim cnt As Long, X As Variant, SingleLED As Integer
  For Each X In Split(LED_CntList, " ")
      If X = "RGB" Then
              If SingleLED = 0 Then
                    cnt = cnt + 1
              Else: cnt = cnt + 2
                    SingleLED = 0
              End If
      ElseIf X <> "" Then
              If Val(X) <= SingleLED Then cnt = cnt + 1
              SingleLED = Val(X)
      End If
  Next X
  If SingleLED > 0 Then cnt = cnt + 1
  Count_Used_RGB_Channels = cnt
End Function

'-----------------------------
Private Function Count_Rooms()
'-----------------------------
  Dim cnt As Long
  If SelectedRooms_TextBox <> "" Then
     cnt = UBound(Split(SelectedRooms_TextBox, ",")) + 1
  End If
  Count_Rooms = cnt
End Function

'-------------------------------------
Private Sub Set_RoomCount(cnt As Long)
'-------------------------------------
  RoomCnt_Label = "Anzahl: " & cnt
  Used_RGB_LEDs_Label = "RGB LED Kan|fffd|le: " & Count_Used_RGB_Channels()
  Set_MinMaxCnt cnt
End Sub

'--------------------------------------
Private Sub Add_Room(Caption As String)
'--------------------------------------
  Dim cnt As Long
  cnt = Count_Rooms()
  If cnt >= 250 Then
     MsgBox "Es k|fffd|nnen keine weiteren R|fffd|ume hinzugef|fffd|gt werden", vbInformation, "Maximale Raumanzahl erreicht"
     Exit Sub
  End If
  
  If Me.ActiveControl.Tag <> "" Then ' THe Tag contains the flag for single LEDs (1,2 or 3).
        LED_CntList = LED_CntList & Me.ActiveControl.Tag & " "
  Else: LED_CntList = LED_CntList & "RGB "
  End If
  
  If SelectedRooms_TextBox = "" Then
        SelectedRooms_TextBox = Caption
  Else: SelectedRooms_TextBox = SelectedRooms_TextBox & ", " & Caption
  End If
  Set_RoomCount Count_Rooms()
End Sub

'---------------------------------
Private Sub DelRoom_Button_Click()
'---------------------------------
  If SelectedRooms_TextBox = "" Then Exit Sub
  Dim p As Long, Txt As String
  Txt = SelectedRooms_TextBox
  While Right(Txt, 1) <> "," And Len(Txt) > 0
    Txt = Left(Txt, Len(Txt) - 1)
  Wend
  If Right(Txt, 1) = "," Then Txt = Left(Txt, Len(Txt) - 1)
  SelectedRooms_TextBox = Txt
    
  Txt = LED_CntList
  If Right(Txt, 1) = " " Then Txt = Left(Txt, Len(Txt) - 1)
  While Right(Txt, 1) <> " " And Len(Txt) > 0
    Txt = Left(Txt, Len(Txt) - 1)
  Wend
  LED_CntList = Txt
  
  Set_RoomCount Count_Rooms()
End Sub

Private Sub CommandButton1_Click()
  Add_Room Me.ActiveControl.Caption
End Sub

Private Sub CommandButton10_Click()
  Add_Room Me.ActiveControl.Caption
End Sub

Private Sub CommandButton11_Click()
  Add_Room Me.ActiveControl.Caption
End Sub

Private Sub CommandButton12_Click()
  Add_Room Me.ActiveControl.Caption
End Sub

Private Sub CommandButton13_Click()
  Add_Room Me.ActiveControl.Caption
End Sub

Private Sub CommandButton14_Click()
  Add_Room Me.ActiveControl.Caption
End Sub

Private Sub CommandButton15_Click()
  Add_Room Me.ActiveControl.Caption
End Sub

Private Sub CommandButton16_Click()
  Add_Room Me.ActiveControl.Caption
End Sub

Private Sub CommandButton17_Click()
  Add_Room Me.ActiveControl.Caption
End Sub

Private Sub CommandButton18_Click()
  Add_Room Me.ActiveControl.Caption
End Sub

Private Sub CommandButton19_Click()
  Add_Room Me.ActiveControl.Caption
End Sub

Private Sub CommandButton2_Click()
  Add_Room Me.ActiveControl.Caption
End Sub

Private Sub CommandButton20_Click()
  Add_Room Me.ActiveControl.Caption
End Sub

Private Sub CommandButton21_Click()
  Add_Room Me.ActiveControl.Caption
End Sub

Private Sub CommandButton22_Click()
  Add_Room Me.ActiveControl.Caption
End Sub

Private Sub CommandButton23_Click()
  Add_Room Me.ActiveControl.Caption
End Sub

Private Sub CommandButton24_Click()
  Add_Room Me.ActiveControl.Caption
End Sub

Private Sub CommandButton25_Click()
  Add_Room Me.ActiveControl.Caption
End Sub

Private Sub CommandButton26_Click()
  Add_Room Me.ActiveControl.Caption
End Sub

Private Sub CommandButton27_Click()
  Add_Room Me.ActiveControl.Caption
End Sub

Private Sub CommandButton28_Click()
  Add_Room Me.ActiveControl.Caption
End Sub

Private Sub CommandButton29_Click()
  Add_Room Me.ActiveControl.Caption
End Sub

Private Sub CommandButton3_Click()
  Add_Room Me.ActiveControl.Caption
End Sub

Private Sub CommandButton30_Click()
  Add_Room Me.ActiveControl.Caption
End Sub

Private Sub CommandButton31_Click()
  Add_Room Me.ActiveControl.Caption
End Sub

Private Sub CommandButton32_Click()
  Add_Room Me.ActiveControl.Caption
End Sub

Private Sub CommandButton33_Click()
  Add_Room Me.ActiveControl.Caption
End Sub

Private Sub CommandButton34_Click()
  Add_Room Me.ActiveControl.Caption
End Sub

Private Sub CommandButton35_Click()
  Add_Room Me.ActiveControl.Caption
End Sub

Private Sub CommandButton36_Click()
  Add_Room Me.ActiveControl.Caption
End Sub

Private Sub CommandButton37_Click()
  Add_Room Me.ActiveControl.Caption
End Sub

Private Sub CommandButton38_Click()
  Add_Room Me.ActiveControl.Caption
End Sub

Private Sub CommandButton39_Click()
  Add_Room Me.ActiveControl.Caption
End Sub

Private Sub CommandButton4_Click()
  Add_Room Me.ActiveControl.Caption
End Sub

Private Sub CommandButton40_Click()
  Add_Room Me.ActiveControl.Caption
End Sub

Private Sub CommandButton41_Click()
  Add_Room Me.ActiveControl.Caption
End Sub

Private Sub CommandButton42_Click()
  Add_Room Me.ActiveControl.Caption
End Sub

Private Sub CommandButton43_Click()
  Add_Room Me.ActiveControl.Caption
End Sub

Private Sub CommandButton44_Click()
  Add_Room Me.ActiveControl.Caption
End Sub

Private Sub CommandButton45_Click()
  Add_Room Me.ActiveControl.Caption
End Sub

Private Sub CommandButton46_Click()
  Add_Room Me.ActiveControl.Caption
End Sub

Private Sub CommandButton47_Click()
  Add_Room Me.ActiveControl.Caption
End Sub

Private Sub CommandButton48_Click()
  Add_Room Me.ActiveControl.Caption
End Sub

Private Sub CommandButton49_Click()
  Add_Room Me.ActiveControl.Caption
End Sub

Private Sub CommandButton5_Click()
  Add_Room Me.ActiveControl.Caption
End Sub

Private Sub CommandButton50_Click()
  Add_Room Me.ActiveControl.Caption
End Sub

Private Sub CommandButton51_Click()
  Add_Room Me.ActiveControl.Caption
End Sub

Private Sub CommandButton52_Click()
  Add_Room Me.ActiveControl.Caption
End Sub

Private Sub CommandButton53_Click()
  Add_Room Me.ActiveControl.Caption
End Sub

Private Sub CommandButton54_Click()
  Add_Room Me.ActiveControl.Caption
End Sub

Private Sub CommandButton6_Click()
  Add_Room Me.ActiveControl.Caption
End Sub

Private Sub CommandButton7_Click()
  Add_Room Me.ActiveControl.Caption
End Sub

Private Sub CommandButton8_Click()
  Add_Room Me.ActiveControl.Caption
End Sub

Private Sub CommandButton9_Click()
  Add_Room Me.ActiveControl.Caption
End Sub

Private Sub CommandButton55_Click()
  Add_Room Me.ActiveControl.Caption
End Sub

Private Sub CommandButton56_Click()
  Add_Room Me.ActiveControl.Caption
End Sub

Private Sub CommandButton57_Click()
    Add_Room Me.ActiveControl.Caption
End Sub

'--------------------------------
Private Sub UserForm_Initialize()
'--------------------------------
  'Debug.Print vbCr & Me.Name & ": UserForm_Initialize"
  Center_Form Me
End Sub

Attribute VB_Name = "UserForm_Options"
Attribute VB_Base = "0{5DF19C4E-5EDE-4038-BDA1-E58B28819AA1}{85337B53-4551-4F8C-8F3B-C306D0F00033}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Const BOARD_NANO_OLD = "--board arduino:avr:nano:cpu=atmega328old"
Private Const BOARD_NANO_NEW = "--board arduino:avr:nano:cpu=atmega328"
Private Const BOARD_UNO_NORM = "--board arduino:avr:uno"

Private Old_Board(2) As String
Private Disable_Set_Arduino_Typ As Boolean

'-------------------------------
Private Sub Close_Button_Click()
'-------------------------------
  Me.Hide
End Sub


'-----------------------------------------
Private Sub Detect_LED_Port_Button_Click()
'-----------------------------------------
  Me.Hide
  Detect_Com_Port_and_Save_Result False
  Me.Show
End Sub

'-------------------------------------------
Private Sub Detect_Right_Port_Button_Click()
'-------------------------------------------
  Me.Hide
  Detect_Com_Port_and_Save_Result True
  Me.Show
End Sub

'------------------------------------
Private Sub HardiForum_Button_Click()
'------------------------------------
  Me.Hide
  If MsgBox("|fffd|ffnet das Profil von Hardi im Stummi Forum." & vbCr & _
            vbCr & _
            "Dort findet man, wenn man im Forum angemeldet ist, einen Link zur " & _
            "Email Adresse des Autors oder kann ihm eine PN schicken." & vbCr & _
            vbCr & _
            "Alternativ kann auch eine Mail an 'MobaLedlib@gmx.de' geschickt werden wenn " & _
            "es Fragen oder Anregungen zu dem Programm oder zur MobaLedLib gibt.", vbOKCancel, "Profil des Autors |fffd|ffnen") = vbOK Then
     Shell "Explorer ""https://www.stummiforum.de/memberlist.php?mode=viewprofile&u=26419"""
  End If
End Sub

'------------------------------------
Private Sub ProInstall_Button_Click()
'------------------------------------
  Ask_to_Upload_and_Compile_and_Upload_Prog_to_Right_Arduino
End Sub


Private Sub Nano_Normal_L_Click(): Change_Board True, BOARD_NANO_OLD: End Sub
Private Sub Nano_New_L_Click():    Change_Board True, BOARD_NANO_NEW: End Sub
Private Sub Uno_L_Click():         Change_Board True, BOARD_UNO_NORM: End Sub
Private Sub Board_IDE_L_Click():   Change_Board True, "":             End Sub

Private Sub Nano_Normal_R_Click(): Change_Board False, BOARD_NANO_OLD: End Sub
Private Sub Nano_New_R_Click():    Change_Board False, BOARD_NANO_NEW: End Sub
Private Sub Uno_R_Click():         Change_Board False, BOARD_UNO_NORM: End Sub
Private Sub Board_IDE_R_Click():   Change_Board False, "":             End Sub


'-----------------------------------------------------------------
Private Sub Change_Board(LeftArduino As Boolean, NewBrd As String)
'-----------------------------------------------------------------
  If Disable_Set_Arduino_Typ Then Exit Sub
  
  Dim Col As Long, Side As String, Brd As Integer
  If LeftArduino Then
        Col = BUILDOP_COL: Side = "L": Brd = 0
  Else: Col = BUILDOpRCOL: Side = "R": Brd = 1
  End If
  Dim BuildOpt As String
  BuildOpt = Cells(SH_VARS_ROW, Col)
  If Old_Board(Brd) = "" Then
        BuildOpt = NewBrd & " " & BuildOpt
  Else: BuildOpt = Replace(BuildOpt, Old_Board(Brd), NewBrd)
  End If
  Cells(SH_VARS_ROW, Col) = Trim(BuildOpt)
  Old_Board(Brd) = NewBrd
End Sub


'---------------------------------------------------
Private Sub Get_Arduino_Typ(LeftArduino As Boolean)
'---------------------------------------------------
  Dim Col As Long, Side As String, Brd As Integer
  If LeftArduino Then
        Col = BUILDOP_COL: Side = "L": Brd = 0
  Else: Col = BUILDOpRCOL: Side = "R": Brd = 1
  End If
  Dim BuildOpt As String
  BuildOpt = Cells(SH_VARS_ROW, Col)
  If InStr(BuildOpt, BOARD_NANO_OLD) > 0 Then Controls("Nano_Normal_" & Side).Value = True: Old_Board(Brd) = BOARD_NANO_OLD: Exit Sub
  If InStr(BuildOpt, BOARD_NANO_NEW) > 0 Then Controls("Nano_New_" & Side).Value = True:    Old_Board(Brd) = BOARD_NANO_NEW: Exit Sub
  If InStr(BuildOpt, BOARD_UNO_NORM) > 0 Then Controls("Uno_" & Side).Value = True:         Old_Board(Brd) = BOARD_UNO_NORM: Exit Sub
  If InStr(BuildOpt, "--board ") > 0 Then
        Controls("Nano_Normal_" & Side).Value = False
        Controls("Nano_New_" & Side).Value = False
        Controls("Uno_" & Side).Value = False
        Controls("Board_IDE_" & Side).Value = False
        MsgBox "Unbekante Board Option: " & vbCr & _
                BuildOpt, vbInformation, "Unbekantes Board"
  Else: Controls("Board_IDE_" & Side).Value = True ' Default value
  End If
  Old_Board(Brd) = ""
End Sub

'UT-------------------------------
Private Sub Test_Get_Arduino_Typ()
'UT-------------------------------
  Get_Arduino_Typ True
End Sub

'--------------------------------
Private Sub UserForm_Initialize()
'--------------------------------
' Is called once to initialice the form
  'Debug.Print vbCr & Me.Name & ": UserForm_Initialize"
  Center_Form Me
End Sub


'------------------------------
Private Sub UserForm_Activate()
'------------------------------
' Is called every time when the form is shown
  Make_sure_that_Col_Variables_match

  'Debug.Print vbCr & Me.Name & ": UserForm_Activate"
  Make_sure_that_Col_Variables_match
  Me.MultiPage1.Page2.Visible = Page_ID <> "CAN" ' Not visible if the CAN Sheet is active
  Me.MultiPage1.Page2.Caption = Page_ID & " Arduino"
  
  Disable_Set_Arduino_Typ = True
  Get_Arduino_Typ True
  Get_Arduino_Typ False
  Disable_Set_Arduino_Typ = False
End Sub


Attribute VB_Name = "UserForm_Other"
Attribute VB_Base = "0{72338E83-44D4-4927-B64A-A0DA85521BB2}{932B2137-8B37-4EB4-9999-1F368A1AC1ED}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Option Compare Binary ' Use case sensitive compare. Important for the "Sec" compare below

' Following parameters exist:
' LED Cx  InCh    Val0    Val1    On_Min  On_Limit    LedCnt  Brightness  DstVar  Mode    Enable  TimeOut DstVar1 DstVarN MinTime MaxTime MinOn   MaxOn   Var SrcLED  EnableCh    Start   End GlobVarNr   FirstInCh   InCh_Cnt    Duration    Period  Pause   Act Off S_InCh  R_InCh  Timeout T_InCh  DstVar0 MinBrightness   MaxBrightness   B_LED_Cx    B_LED   InNr    TmpNr   Rotate  Steps   MaxSoundNr  InReset
'
'
' Maximal 6 named parameter in one macro
'
' ToDo:
' - Alte eingaben speichern und beim n|fffd|chsten mal wieder verwenden
'   - Geht nicht in dem man das Unload Me wegl|fffd|sst
'   - Man k|fffd|nnte ein Array anlegen in dem die Parameter Namen und der Letzte Wert enthalten ist
'     das sollte aber f|fffd|r jedes Makro spezifisch sein

Private ParList As Variant
Private FuncName As String
Private NamesA As Variant

Const MAX_PAR_CNT = 6
Private TypA(MAX_PAR_CNT) As String
Private MinA(MAX_PAR_CNT) As Variant
Private MaxA(MAX_PAR_CNT) As Variant
Private ParName(MAX_PAR_CNT) As String


'-------------------------------------------------------------------------------
Private Function Check_Limit_to_MinMax(ParNr As Long, Value As Variant) As Boolean
'-------------------------------------------------------------------------------
' Return true if its within the alowed range
  Dim Msg As String
  'With Controls("Par" & ParNr)
    Dim ValidRangeTxt As String
    ValidRangeTxt = vbCr & "Bitte einen Wert zwischen " & MinA(ParNr - 1) & " und " & MaxA(ParNr - 1) & " eingeben."
    If Value = "" Then
                                                                       Msg = "leer." & ValidRangeTxt
    ElseIf Not IsNumeric(Value) Then
                                                                       Msg = "keine g|fffd|ltige Zahl." & ValidRangeTxt
    ElseIf CStr(Round(Value, 0)) <> CStr(Value) Then
                                                                       Msg = "nicht Ganzzahlig." & ValidRangeTxt

    ElseIf MinA(ParNr - 1) <> "" And Value < Val(MinA(ParNr - 1)) Then
                                                                       Msg = "zu klein!" & vbCr & "Der Minimal zul|fffd|ssiger Wert ist: " & MinA(ParNr - 1)
    ElseIf MaxA(ParNr - 1) <> "" And Value > Val(MaxA(ParNr - 1)) Then
                                                                       Msg = "zu gro|fffd|!" & vbCr & "Der Maximal zul|fffd|ssige Wert ist: " & MaxA(ParNr - 1)
    End If

    If Msg <> "" Then
          Controls("Par" & ParNr).SetFocus
          MsgBox "Der Parameter '" & Controls("LabelPar" & ParNr).Caption & "' ist " & Msg, vbInformation, "Bereichs|fffd|berschreitung"
    Else: Check_Limit_to_MinMax = True
    End If
  'End With
End Function

'-----------------------------------------------------------
Private Function Check_Time_String(ParNr As Long) As Boolean
'-----------------------------------------------------------
  Dim ValidRangeTxt As String
  ValidRangeTxt = vbCr & "Bitte einen Zeit zwischen " & MinA(ParNr - 1) & " ms und " & MaxA(ParNr - 1) & " ms eingeben." & vbCr & _
                  "Die Zeitangabe kann auch eine der folgenden Einheit enthalten:" & vbCr & _
                  " Min, Sec, ms " & vbCr & _
                  "Achtung: Zwischen zahl und Einheit muss ein Leerzeichen stehen." & vbCr & _
                  "Beispiel: 3 Sec" ' ToDo: Erlaubte Zeiten zus|fffd|tzlich in Minuten Angeben
  Dim Parts As Variant
  With Controls("Par" & ParNr)
    Parts = Split(.Value, " ")
    Const ValidUnits = " Min Sek sek Sec sec Ms ms "
    If UBound(Parts) <> 1 Or Not IsNumeric(Parts(0)) Or InStr(ValidUnits, " " & Parts(1) & " ") = 0 Then
         MsgBox "Der Parameter '" & ParName(ParNr - 1) & "' ist ung|fffd|ltig", vbInformation, "Ung|fffd|ltiger Parameter" & ValidRangeTxt
         Exit Function
    Else ' Two parameter detected. First is numeric, the second is a valid Unit
         Dim Val As Double
         Select Case LCase(Parts(1))
           Case "min":             Val = Parts(0) * 60 * 1000
           Case "sec", "sek": Val = Parts(0) * 1000
           Case "ms":              Val = Parts(0)
           Case Else:              MsgBox "Internal error: Unknown unit '" & Parts(1) & "' in Check_Time_String()", vbCritical, "Internal error"
                                   EndProg
         End Select
         If Check_Limit_to_MinMax(ParNr, Val) = False Then Exit Function
    End If
  End With
  Check_Time_String = True
End Function


'--------------------------------------------------------------------------
Private Function Check_Par_with_ErrMsg(ParNr As Long, ByRef Val As Variant)
'--------------------------------------------------------------------------
  If ParNr > MAX_PAR_CNT Then
     MsgBox "Internal error in Chek_Range()"
     EndProg
  End If
  With Controls("Par" & ParNr)
    .Value = Trim(.Value)
    'Debug.Print "Check_Range " & ParName(ParNr - 1) & ": " & .Value
    Select Case TypA(ParNr - 1)
      Case "":     ' Normal Numeric parameter
                   If Check_Limit_to_MinMax(ParNr, .Value) = False Then Exit Function
      Case "Time": ' time could have a tailing "Min", "Sek", "sek", "Sec", "sec", "Ms", "ms"
                   If IsNumeric(.Value) Then
                        .Value = Int(.Value)
                        If Check_Limit_to_MinMax(ParNr, .Value) = False Then Exit Function
                   Else ' The parameter is NOT numeric
                        If Check_Time_String(ParNr) = False Then Exit Function
                   End If
                   .Value = Replace(.Value, ",", ".") ' Replace the german comma
      Case Else: MsgBox "Internal error: Unknown parameter Typ: '" & TypA(ParNr - 1) & "'", vbCritical, "Internal Error"
                 EndProg
    End Select
    Val = .Value
  End With
  Check_Par_with_ErrMsg = True
End Function



'------------------------------
Private Sub ScrollBar1_Change()
'------------------------------
' ToDo: Die Steuerung ist noch nicht gut
' - Slider Size anpassen
' - Die Description_TextBox sollte nicht editierbar sein
'
  'Debug.Print ScrollBar1.Value
  With Description_TextBox
    .SetFocus
    'Debug.Print .LineCount & " " & .MaxLength & " " & .TextLength
    .SelStart = ScrollBar1.Value
  End With
  ScrollBar1.SetFocus
End Sub

'-----------------------------------------------
Public Sub MouseWheel(ByVal lngRotation As Long)
'-----------------------------------------------
' Process the mouse wheel changes
  'Debug.Print "MouseWheel" & lngRotation ' Debug
  If lngRotation < 0 Then
        ScrollBar1 = Application.Min(ScrollBar1 + 100, ScrollBar1.Max)
  Else: ScrollBar1 = Application.Max(ScrollBar1 - 100, ScrollBar1.Min)
  End If
End Sub

'--------------------------------
Private Sub UserForm_Initialize()
'--------------------------------
  'Debug.Print vbCr & me.Name & ": UserForm_Initialize"
  Center_Form Me
End Sub

'--------------------------------------------------------------------------------------------------------------------
Public Sub Show_UserForm_Other(ByVal Par As String, ByVal Name As String, Description As String, LedChannels As Long)
'--------------------------------------------------------------------------------------------------------------------
  FuncName = Name
  Const CNames = "Val0 Val1 Period Duration Timeout DstVar MinTime MaxTime Par1"
  If Description = "" Then
        Description_TextBox = "Noch keine Beschreibung zur Funktion '" & Name & "' vorhanden ;-("
  Else: Description_TextBox = Description
  End If
  ScrollBar1.Max = Len(Description_TextBox)
  HookFormScroll Me, "Description_TextBox"   ' Initialize the mouse wheel scroll function

  Me.Caption = "Parametereingabe der '" & Name & "' Funktion"

  'Debug.Print                         ' Debug
  'Debug.Print Name & " (" & Par & ")" ' Debug

  '*** Hide all entrys in the dialog which are not needed ***
  ParList = Split(Par, ",")

  ' Hide CX selection if it's not used
  If Not Is_Contained_in_Array("Cx", ParList) And Not Is_Contained_in_Array("B_LED_Cx", ParList) Then
     Hide_and_Move_up Me, "LED_Kanal_Frame", "Par1"
  Else ' Prepare the Cx selection
       If LedChannels = 2 Then             ' Functions with two single LEDs like the Andreaskreuz
          OptionButton_All.Enabled = False ' can't access all LEDs
          OptionButton_23 = True
       End If
  End If


  ' Add parameters
  Dim p As Variant, UsedParNr As Long
  For Each p In ParList
      p = Trim(p)
      If Left(p, 1) <> "#" And InStr(" Cx B_LED_Cx ", " " & p & " ") = 0 Then
         If UsedParNr >= MAX_PAR_CNT Then
            MsgBox "Internal error: The number of parameters is to large in Show_UserForm_Other()"
            EndProg
         End If
         Dim Typ As String, Min As String, Max As String, Def As String, InpTxt As String, Hint As String
         Get_Par_Data p, Typ, Min, Max, Def, InpTxt, Hint
         TypA(UsedParNr) = Typ
         MinA(UsedParNr) = Min
         MaxA(UsedParNr) = Max
         ParName(UsedParNr) = p

         UsedParNr = UsedParNr + 1
         Me.Controls("Par" & UsedParNr) = Def
         Me.Controls("LabelPar" & UsedParNr) = InpTxt
         Me.Controls("LabelPar" & UsedParNr).ControlTipText = Hint
      End If
  Next p
  'Debug.Print "UsedParNr=" & UsedParNr ' Debug

  Hide_and_Move_up Me, "Par" & UsedParNr + 1, "Abort_Button" ' Hide the not needed controlls
  Me.Show
End Sub

'------------------------------------------------
Private Function Get_OptionButton_Res() As String
'------------------------------------------------
  Dim Val As String
  If OptionButton_All Then
                               Val = "C_ALL"
  ElseIf OptionButton_C1 Then: Val = "C1"
  ElseIf OptionButton_C2 Then: Val = "C2"
  ElseIf OptionButton_C3 Then: Val = "C3"
  ElseIf OptionButton_12 Then: Val = "C12"
  ElseIf OptionButton_23 Then: Val = "C23"
  Else: MsgBox "LED Auswahl Fehler"
  End If
  Get_OptionButton_Res = Val
End Function

'-------------------------------------------------------------
Private Function Create_Result(ByRef Res As String) As Boolean
'-------------------------------------------------------------
' Return True if sucessfully checked alt inputs
  Res = ""
  Dim p As Variant
  For Each p In ParList
      Dim Val As Variant
      Val = "Not Found"
      p = Trim(p)
      If Left(p, 1) = "#" Then
           Val = p
      Else
           If p = "Cx" Or p = "B_LED_Cx" Then
                Val = Get_OptionButton_Res()
           Else ' Not a standard parameter
                Dim Nr As Long
                For Nr = 1 To MAX_PAR_CNT
                    If ParName(Nr - 1) = p Then
                       If Check_Par_with_ErrMsg(Nr, Val) = False Then Exit Function
                       Exit For
                    End If
                Next
           End If
      End If
      If Val = "Not Found" Then MsgBox "Fehler der Parameter '" & p & "' wurde nicht gefunden", vbCritical, "Programm Fehler"
      Res = Res & Val & ", "
  Next p
  Res = FuncName & "(" & DelLast(Res, 2) & ")"
  Create_Result = True
End Function

'-------------------------------
Private Sub Abort_Button_Click()
'-------------------------------
  UnhookFormScroll ' Deactivate the mouse wheel scroll function
  'Me.Hide
  Userform_Res = ""
  Unload Me ' Don't keep the entered data. Importand because the positions of the controlls and the visibility have been changed
End Sub

'----------------------------
Private Sub OK_Button_Click()
'----------------------------
  If Create_Result(Userform_Res) Then
     UnhookFormScroll ' Deactivate the mouse wheel scroll function
     'Me.Hide
     Unload Me ' Don't keep the entered data. Importand because the positions of the controlls and the visibility have been changed
  End If
End Sub




Attribute VB_Name = "UserForm_Protokoll_Auswahl"
Attribute VB_Base = "0{9D6CA4B9-777E-414D-A816-1D519B79509B}{FA5B776F-EE5E-4697-A5E8-52476BCC0DA7}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

'-------------------------------
Private Sub Abort_Button_Click()
'-------------------------------
 Me.Hide
End Sub


'----------------------------
Private Sub OK_Button_Click()
'----------------------------
  Me.Hide
  If DCC_Button Then Sheets("DCC").Select
  If Selectrix_Button Then Sheets("Selectrix").Select
  If CAN_Button Then Sheets("CAN").Select
End Sub

'--------------------------------
Private Sub UserForm_Initialize()
'--------------------------------
  'Debug.Print vbCr & me.Name & ": UserForm_Initialize"
  Center_Form Me
End Sub

Attribute VB_Name = "UserForm_Select_Typ_DCC"
Attribute VB_Base = "0{AED5F562-D719-4F87-B08A-0C40310CEAAD}{FA0ECFBB-83BF-44DB-A771-E04699C7D6EA}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit


'-------------------------------
Private Sub Abort_Button_Click()
'-------------------------------
  Userform_Res = ""
  Me.Hide
End Sub


'----------------------------
Private Sub OK_Button_Click()
'----------------------------
  If Button_OnOff Then
                       Userform_Res = "AnAus"
  ElseIf Button_Red Then
                       Userform_Res = "Rot"
  Else:                Userform_Res = "Gr|fffd|n"
  End If
  Me.Hide
End Sub


'-----------------------------------------
Public Sub SetFocus(Target As Excel.Range)
'-----------------------------------------
  Select Case Left(Target, 1)
    Case "A": Button_OnOff = True ' "AnAus"
    Case "G": Button_Green = True ' "Gr|fffd|n"
    Case "R": Button_Red = True   ' "Rot"
    ' In any other cases the last state is used
  End Select
  
  If Button_OnOff Then
                       Button_OnOff.SetFocus
  ElseIf Button_Red Then
                       Button_Red.SetFocus
  Else:                Button_Green.SetFocus
  End If
End Sub


'--------------------------------
Private Sub UserForm_Initialize()
'--------------------------------
  'Debug.Print vbCr & me.Name & ": UserForm_Initialize"
  Center_Form Me
End Sub

Attribute VB_Name = "UserForm_Select_Typ_SX"
Attribute VB_Base = "0{C31105C0-3250-4F02-90B7-547090A9AD2B}{B4A36278-0EB3-4B17-A4ED-D856ADCB0D90}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit


'-------------------------------
Private Sub Abort_Button_Click()
'-------------------------------
  Userform_Res = ""
  Me.Hide
End Sub



'----------------------------
Private Sub OK_Button_Click()
'----------------------------
  If Button_OnOff Then
                       Userform_Res = "AnAus"
  Else
                       Userform_Res = "Tast"
  End If
  Me.Hide
End Sub


'-----------------------------------------
Public Sub SetFocus(Target As Excel.Range)
'-----------------------------------------
  Select Case Left(Target, 1)
    Case "A": Button_OnOff = True ' "AnAus"
    Case "T": Button_Tast = True  ' "Tast"
    ' In any other cases the last state is used
  End Select
  
  If Button_OnOff Then
        Button_OnOff.SetFocus
  Else: Button_Tast.SetFocus
  End If
End Sub


'--------------------------------
Private Sub UserForm_Initialize()
'--------------------------------
  'Debug.Print vbCr & me.Name & ": UserForm_Initialize"
  Center_Form Me
End Sub

Attribute VB_Name = "UserForm_SerialTest"
Attribute VB_Base = "0{8765978F-EF68-441E-9C5D-1C08B9559027}{B14FFF37-F8A3-4B64-B87E-AF9AE6E67688}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Private Sub CommandButton1_Click()
  End_Serial_Test = True
  Me.Hide
End Sub
Attribute VB_Name = "UserForm_Set_ColTab"
Attribute VB_Base = "0{018B17A2-AB37-468E-B9ED-F5A8FEE3D880}{38C0ED4C-6A92-49ED-8117-948F94C67262}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit


'   Nr  R   G   B   Color
'   0   15  13  3   &H00030D0F&
'   1   22  44  27  &H001B2C16&
'   2   155 73  5   &H0005499B&
'   3   39  18  1   &H00011227&
'   4   30  0   0   &H0000001E&
'   5   79  39  7   &H0007274F&
'   6   50  50  50  &H00323232&
'   7   255 255 255 &H00FFFFFF&
'   8   20  20  27  &H001B1414&
'   9   70  70  80  &H00504646&
'   10  245 245 255 &H00FFF5F5&
'   11  50  50  20  &H00143232&
'   12  70  70  30  &H001E4646&
'   13  50  50  8   &H00083232&
'   14  50  50  8   &H00083232&

'-----------------------------------
Private Sub OK_CommandButton_Click()
'-----------------------------------
  Userform_Res = "//         Red  Green Blue" & vbLf & _
                 "Set_ColTab(   15,  13,   3," & vbLf & _
                 "              22,  44,  27," & vbLf & _
                 "             155,  73,   5," & vbLf & _
                 "              39,  18,   1," & vbLf & _
                 "              30,   0,   0," & vbLf & _
                 "              79,  39,   7," & vbLf & _
                 "              50,  50,  50," & vbLf & _
                 "             255, 255, 255," & vbLf & _
                 "              20,  20,  27," & vbLf & _
                 "              70,  70,  80," & vbLf & _
                 "             245, 245, 255," & vbLf & _
                 "              50,  50,  20," & vbLf & _
                 "              70,  70,  30," & vbLf & _
                 "              50,  50,   8," & vbLf & _
                 "              50,  50,   8," & vbLf & _
                 "             255, 255, 255," & vbLf & _
                 "              50,  50,  50)"
                 
  'Me.Hide
  Unload Me ' Don't keep the entered data.
End Sub

'--------------------------------------
Private Sub Abort_CommandButton_Click()
'--------------------------------------
  'Me.Hide
  Unload Me ' Don't keep the entered data.
End Sub

'--------------------------------
Private Sub UserForm_Initialize()
'--------------------------------
  'Debug.Print vbCr & me.Name & ": UserForm_Initialize"
  Center_Form Me
End Sub

Attribute VB_Name = "UserForm_USB_Connection"
Attribute VB_Base = "0{49221775-95A9-481B-A60F-52A0F82EDBBE}{4772B153-B46D-4984-8D50-2E9253E7149D}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit


Private PressedButton As String

Private Sub Check_Button_Click() ' "|fffd|berpr|fffd|fen"
  PressedButton = "LeftButton"
  Me.Hide
End Sub

Private Sub Abort_Button_Click()
  PressedButton = "MiddleButton"
  Me.Hide
End Sub

Private Sub Default_Button_Click() ' "OK", "|fffd|bernehmen" or "Ja"
  PressedButton = "RightButton"
  Me.Hide
End Sub


'--------------------------------------------------------------------------------------------------------------------------------------------------------------
Public Function ShowForm(ByVal Titel As String, Text As String, _
                         Show_Left_Button As Boolean, Show_Left_Pic As Boolean, Show_Right_Pic As Boolean, _
                         LeftButton_Text As String, AbortButton_Txt As String, DefaultButton_Txt As String, _
                         PC_Verbindung As String, Caption As String, Optional Focus_Button As String = "Default_Button") As String
'--------------------------------------------------------------------------------------------------------------------------------------------------------------
  Titel_Label = Titel
  Text_Label = Text
  If Page_ID = "CAN" Then
    MainBoard.Visible = False
    Kabel_Links.Visible = False
    Kabel_Rechts.Visible = False
    CAN_with_Kabel.Visible = Show_Left_Pic
    CAN_wo_Kabel.Visible = Not Show_Left_Pic
  Else
    MainBoard.Visible = (Show_Left_Pic = False) And (Show_Right_Pic = False)
    Kabel_Links.Visible = Show_Left_Pic
    Kabel_Rechts.Visible = Show_Right_Pic
    CAN_with_Kabel.Visible = False
    CAN_wo_Kabel.Visible = False
  End If
  ZumPC_L.Visible = Show_Left_Pic
  ZumPC_R.Visible = Show_Right_Pic
  If Show_Left_Pic Then
                    PC_Verbindung_Label.Left = 320 'Left   ' Achtung die gr|fffd||fffd|e und Position der Bilder ist unterschiedlich bei verschiedenen Rechnern ;-(
  ElseIf Show_Right_Pic Then                                   ' Evtl. H|fffd|ngt das von den Windows Vergr|fffd||fffd|erungseinstellungen ab
                    PC_Verbindung_Label.Left = 340 ' Right
  Else:             PC_Verbindung_Label.Left = 288 ' Center
  End If
  PC_Verbindung_Label = PC_Verbindung
  PressedButton = False
  
  Check_Button.Caption = Mid(LeftButton_Text, 3, 255)
  Check_Button.Accelerator = Left(LeftButton_Text, 1)
  Check_Button.Visible = Show_Left_Button
  
  Default_Button.Caption = Mid(DefaultButton_Txt, 3, 255)
  Default_Button.Accelerator = Left(DefaultButton_Txt, 1)
  
  Abort_Button.Caption = Mid(AbortButton_Txt, 3, 255)
  Abort_Button.Accelerator = Left(AbortButton_Txt, 1)
  
  Select Case Focus_Button
    Case "Default_Button":  Default_Button.SetFocus
    Case "Abort_Button":    Abort_Button.SetFocus
    Case "Check_Button":    Check_Button.SetFocus
  End Select
  
  
  Me.Caption = Caption
  Me.Show
  ShowForm = PressedButton
End Function


' InQuest injected base64 decoded content
' x)br
' azK/z
' z?nZ
' azK/z
' &F(!

INQUEST-PP=macro
