Attribute VB_Name = "STEPCellMarker"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Private mStyleHelper As STEPStyleHelper
Private mIsSmartSheet As Boolean
Private C_MISSING_REQUIRED_TEXT As String
Private mLocale As New STEPLocalization

'dummy commit for hotfix

Private Sub Class_Initialize()
    Set mStyleHelper = New STEPStyleHelper
    C_MISSING_REQUIRED_TEXT = mLocale.GetLocalizationString("STEPCellMarkerMissingValue")
    Dim utils As STEPSheetUtils
    Set utils = New STEPSheetUtils
    mIsSmartSheet = utils.HasSettingsSheet And utils.HasExtendedSettingsSheet
    Set utils = Nothing
End Sub

Public Function HasComments(cells As Range)
    If (cells.Comment Is Nothing) Then
        HasComments = False
    Else
        HasComments = True
    End If
End Function

Public Sub ClearComments(cells As Range)
    Do While Not cells.Comment Is Nothing
        cells.Comment.Delete
    Loop
End Sub

Public Sub MarkValid(cells As Range)
    mStyleHelper.ClearStyles cells
    Me.ClearComments cells
End Sub

Public Sub MarkValidMandatory(cells As Range)
    If (mStyleHelper.HasMandatoryStyle(cells) And Not Me.HasComments(cells)) Then
        Exit Sub
    End If
    MarkValid cells
    mStyleHelper.SetMandatoryStyle cells
End Sub

Public Function HasMissingMandatoryMark(cells As Range) As Boolean
    HasMissingMandatoryMark = False
    If (mStyleHelper.HasErrorStyle(cells)) Then
        If (Not cells(1, 1).Comment Is Nothing) Then
            Dim s As String
            s = cells(1, 1).Comment.Text
            If (VBA.StrComp(C_MISSING_REQUIRED_TEXT, s) = 0) Then
                'already marked
                HasMissingMandatoryMark = True
            End If
        End If
    End If
End Function

Public Sub MarkMissingMandatory(cells As Range)
    Dim s As String
    If (Not cells(1, 1).Comment Is Nothing) Then
        s = cells(1, 1).Comment.Text
        If (VBA.StrComp(C_MISSING_REQUIRED_TEXT, s) = 0) Then
            'already marked
            Exit Sub
        End If
    End If
    MarkInvalid cells, C_MISSING_REQUIRED_TEXT
End Sub

Public Sub MarkValidReadonly(cells As Range)
    If (mStyleHelper.HasReadOnlyStyle(cells) And Not Me.HasComments(cells)) Then
        Exit Sub
    End If
    MarkValid cells
    mStyleHelper.SetReadOnlyStyle cells
End Sub

Public Sub MarkInvalid(cells As Range, ByVal errmsg)
    Me.ClearComments cells
    If (mIsSmartSheet) Then
        errmsg = VBA.Replace(CStr(errmsg), "&#10;", vbCrLf)
        setCommentStyle cells.AddComment(errmsg)
    Else
        cells.AddComment errmsg
    End If
    If (Not mStyleHelper.HasErrorStyle(cells)) Then
        mStyleHelper.SetErrorStyle cells
    End If
End Sub

Public Sub MarkCellStatus(cells As Range, ByVal pCellStatus As CellStatusType)
    Select Case pCellStatus
        Case STEPCellInvisible
            cells.Value = ""
            MarkValidReadonly cells 'actually invisible so clear any values
            If (Not cells.Locked) Then cells.Locked = True
        Case STEPCellReadOnly
            MarkValidReadonly cells 'simple read-only style
            If (Not cells.Locked) Then cells.Locked = True
        Case STEPCellInoperative
            MarkValidReadonly cells 'inoperative has gray text
            If (Not mStyleHelper.HasInoperativeStyle(cells)) Then
                mStyleHelper.SetInoperativeStyle cells
            End If
            If (Not cells.Locked) Then cells.Locked = True
        Case STEPCellMandatory
            MarkValidMandatory cells
            If (cells.Locked) Then cells.Locked = False
        Case STEPCellTemplateProduct
            MarkValidTemplateProduct cells
            If (Not cells.Locked) Then cells.Locked = True
        Case Else
            MarkValid cells 'clear previous comments colors etc.
    End Select
End Sub

Private Sub setCommentStyle(ByRef myComment As Comment)
 On Error GoTo COMMENTS_ERR
    With myComment
        .Shape.AutoShapeType = msoShapeRectangle
'        .Shape.TextFrame.Characters.Font.Name = "Tahoma"
'        .Shape.TextFrame.Characters.Font.size = 11
'        .Shape.TextFrame.Characters.Font.ColorIndex = 1
        .Shape.TextFrame.AutoSize = True
        .Shape.Line.ForeColor.RGB = RGB(0, 0, 0)
        .Shape.Line.BackColor.RGB = RGB(0, 0, 0)
        .Shape.Fill.Visible = msoTrue
        .Shape.Fill.ForeColor.RGB = RGB(255, 250, 205)
    End With
COMMENTS_ERR:
    err.Clear

End Sub

Public Sub MarkValidTemplateProduct(cells As Range)
    If (mStyleHelper.HasTemplateProductStyle(cells)) Then
        Exit Sub
    End If
    MarkValid cells
    mStyleHelper.SetTemplateProductStyle cells
End Sub
Attribute VB_Name = "STEPCellStatus"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public Enum CellStatusType
    STEPCellInvisible = 1
    STEPCellReadOnly = 2
    STEPCellInoperative = 3
    STEPCellMandatory = 4
    STEPCellTemplateProduct = 5
End Enum

'matched by constants in SmartsheetConstants
Private Const C_STATUS_INVISIBLE As String = "hi"
Private Const C_STATUS_READONLY As String = "ro"
Private Const C_STATUS_INOPERATIVE As String = "io"
Private Const C_STATUS_MANDATORY As String = "ma"
Private Const C_STATUS_TEMPLATEPRODUCT As String = "tp"

Private mCellStatus As CellStatusType
Private mCellAddress As String

Public Property Let CellAddress(ByVal pCellAddress As String)
    mCellAddress = pCellAddress
End Property

Public Property Get CellAddress() As String
    CellAddress = mCellAddress
End Property

Public Property Let CellStatus(ByVal pCellStatus As CellStatusType)
    mCellStatus = pCellStatus
End Property

Public Property Get CellStatus() As CellStatusType
    CellStatus = mCellStatus
End Property

Public Property Let CellStatusString(ByVal pStatus As String)
    Select Case pStatus
        Case C_STATUS_MANDATORY
            CellStatus = STEPCellMandatory
        Case C_STATUS_INVISIBLE
            CellStatus = STEPCellInvisible
        Case C_STATUS_READONLY
            CellStatus = STEPCellReadOnly
        Case C_STATUS_TEMPLATEPRODUCT
            CellStatus = STEPCellTemplateProduct
        Case Else
            CellStatus = STEPCellInoperative
    End Select
End Property

Public Property Get CellStatusString() As String
    Select Case CellStatus
        Case STEPCellMandatory
            CellStatusString = C_STATUS_MANDATORY
        Case STEPCellInvisible
            CellStatusString = C_STATUS_INVISIBLE
        Case STEPCellReadOnly
            CellStatusString = C_STATUS_READONLY
        Case STEPCellTemplateProduct
            CellStatusString = C_STATUS_TEMPLATEPRODUCT
        Case Else
            CellStatusString = C_STATUS_INOPERATIVE
    End Select
End Property

Attribute VB_Name = "STEPCellStatusTracker"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Private mProductSheetName As String
Private mStatuses As VBA.Collection
Private mSheetColIndex As Long
Private mUtils As STEPSheetUtils
Private mChanged As Boolean
Private Const C_SHEET_NAME As String = "STEPCellStatus"

Public Sub Init(ByVal pProductSheetName As String, Optional ByRef AllAddresses As VBA.Collection = Nothing)
    Set mUtils = New STEPSheetUtils
    Set mStatuses = New VBA.Collection
    mProductSheetName = pProductSheetName
    Dim ws As Worksheet
    mSheetColIndex = 1 'default
    Set ws = GetStatusSheet(False)
    If Not (ws Is Nothing) Then
        Dim found As Range
        Set found = ws.Rows(1).cells.Find(what:=mProductSheetName, _
            LookAt:=xlWhole, _
            SearchDirection:=xlNext, _
            SearchOrder:=xlByColumns)
        If (found Is Nothing) Then
            mSheetColIndex = mUtils.GetLastCol(ws, 1) + 1
        Else
            mSheetColIndex = found.Column
            Dim lastRow As Long, Index As Long
            lastRow = mUtils.GetLastRow(ws, mSheetColIndex)
            
            For Index = 2 To lastRow
                Dim ca As String
                Dim cs As String
                ca = ws.cells(Index, mSheetColIndex).Value
                cs = ws.cells(Index, mSheetColIndex + 1).Value
                If (ca <> "") Then
                    Dim lStatus As STEPCellStatus
                    Set lStatus = New STEPCellStatus
                    lStatus.CellStatusString = cs
                    lStatus.CellAddress = ca
                    AddCellStatus lStatus
                    If (Not AllAddresses Is Nothing) Then
                        AllAddresses.Add ca
                    End If
                    Set lStatus = Nothing
                End If
            Next Index
        End If
        mUtils.UnmarkMatchEntireCellContents
    End If
    Changed = False
End Sub

Private Property Get Changed() As Boolean
    Changed = mChanged
End Property

Private Property Let Changed(b As Boolean)
    mChanged = b
End Property


Public Function GetCellStatus(ByVal pCellAddress As String) As STEPCellStatus
    Set GetCellStatus = Nothing
    On Error GoTo GET_ERR:
    Set GetCellStatus = mStatuses(pCellAddress)
    Exit Function
GET_ERR:
    err.Clear
End Function

Public Sub RemoveCellStatus(ByVal pCellAddress As String)
    On Error GoTo REMOVE_ERR
    mStatuses.Remove pCellAddress
    Changed = True
    Exit Sub
REMOVE_ERR:
    err.Clear
End Sub

Public Sub AddCellStatus(ByVal pCellStatus As STEPCellStatus)
    Dim lStatus As STEPCellStatus
    On Error GoTo ADD_ERR
    Set lStatus = mStatuses(pCellStatus.CellAddress)
    lStatus.CellStatus = pCellStatus.CellStatus
    Changed = True
ADD_EXIT:
    Exit Sub

ADD_ERR:
    err.Clear
    On Error GoTo ADD_ERR2 'does it get any worse ?
    mStatuses.Add pCellStatus, pCellStatus.CellAddress
    Changed = True
ADD_ERR2:
    err.Clear
    Resume ADD_EXIT
End Sub

Private Function GetStatusSheet(ByVal create As Boolean) As Worksheet
    Dim ws As Worksheet
    On Error Resume Next
    Set ws = ThisWorkbook.Worksheets(C_SHEET_NAME)
    If create And (ws Is Nothing) Then
        Dim asu As Boolean
        asu = ThisWorkbook.Application.ScreenUpdating
        On Error GoTo CREATE_ERROR
        ThisWorkbook.Application.ScreenUpdating = False
        Set ws = ThisWorkbook.Worksheets.Add
        ws.Name = C_SHEET_NAME
        ws.Visible = xlSheetVeryHidden
CREATE_ERROR:
        ThisWorkbook.Application.ScreenUpdating = asu
    End If
    Set GetStatusSheet = ws
End Function

Public Sub Persist()
    If (Not Changed) Then
        Exit Sub
    End If
    Dim ws As Worksheet
    Set ws = GetStatusSheet(True)
    ws.cells(1, mSheetColIndex).Value = mProductSheetName
    Dim rowIndex As Long, lastRow As Long
    lastRow = mUtils.GetLastRow(ws, mSheetColIndex)
    rowIndex = 2
    Dim lCellStatus As STEPCellStatus
    For Each lCellStatus In mStatuses
        ws.cells(rowIndex, mSheetColIndex).Value = lCellStatus.CellAddress
        ws.cells(rowIndex, mSheetColIndex + 1).Value = lCellStatus.CellStatusString
        rowIndex = rowIndex + 1
    Next
    'remove the rest
    If (rowIndex <= lastRow) Then
        ws.Range(ws.cells(rowIndex, mSheetColIndex), ws.cells(lastRow, mSheetColIndex + 1)).Clear
    End If
    Changed = False
End Sub

Public Sub RowDeleted(ByVal ws As Worksheet, ByVal rowNumber As Long)
    Dim statusSheet As Worksheet
    Set statusSheet = GetStatusSheet(False)
    If (statusSheet Is Nothing) Then
        Exit Sub
    End If
    Dim found As Range
    Set found = statusSheet.Rows(1).cells.Find(what:=ws.Name, _
                    LookAt:=xlWhole, _
                    SearchDirection:=xlNext, _
                    SearchOrder:=xlByColumns)
    If (found Is Nothing) Then
        Exit Sub
    End If
    Dim rowIndex As Long, columnIndex As Long, lastRow As Long, rowToDelete As Long
    columnIndex = found.Column
    lastRow = mUtils.GetLastRow(statusSheet, columnIndex)
    If (lastRow < rowNumber) Then
        Exit Sub
    End If

    For rowIndex = 2 To lastRow
        Dim cellValue As String, columnPart As String
        Dim rowPart As Integer
        cellValue = statusSheet.cells(rowIndex, columnIndex).Value
        Dim place As Integer
        place = InStr(2, cellValue, "$")
        rowPart = CInt(Right(cellValue, place - 1))
        columnPart = Left(cellValue, place)
        If (rowNumber < rowPart) Then
            rowPart = rowPart - 1
            statusSheet.cells(rowIndex, columnIndex).Value = columnPart + CStr(rowPart)
        Else
            If (rowNumber = rowPart) Then
                rowToDelete = rowIndex
            End If
        End If
    Next
    If (rowToDelete > 1) Then
        statusSheet.Range(statusSheet.cells(rowToDelete, columnIndex), statusSheet.cells(rowToDelete, columnIndex + 1)).Delete Shift:=xlUp
    End If
    Persist
End Sub

Public Sub ApplyAll(ByRef ws As Worksheet)
    On Error GoTo APPLY_ALL_ERR
    Dim addresses As New VBA.Collection
    Dim marker As STEPCellMarker
    Dim adr
    Dim cellStat As STEPCellStatus
    Dim lRange As Range
    Me.Init ws.Name, addresses
    If (addresses.Count > 0) Then
        Set marker = New STEPCellMarker
        For Each adr In addresses
            Set cellStat = GetCellStatus(adr)
            Set lRange = ws.Range(adr)
            If (Not lRange Is Nothing And Not cellStat Is Nothing) Then
                    marker.MarkCellStatus lRange, cellStat.CellStatus
            End If
        Next
        Set marker = Nothing
    End If
    Exit Sub
APPLY_ALL_ERR:
    Dim logger As New STEPLogger
    logger.Warning "Failed STEPCellStatusTracker.ApplyAll for " + ws.Name, err.Description
    err.Clear
End Sub

Private Sub Class_Terminate()
    Set mUtils = Nothing
    Set mStatuses = Nothing
End Sub
Attribute VB_Name = "STEPChangeTracker"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Private mUtils As STEPSheetUtils
Private mUseRowAsID As Boolean
Private Const C_SHEET_NAME = "STEPChanges"
Private lUtils As New STEPLovUtils
Private mLocale As New STEPLocalization
Private mSheet As Worksheet

Private Sub Class_Initialize()
    Set mUtils = New STEPSheetUtils
    Set lUtils = New STEPLovUtils
    Set mSheet = Nothing
    mUseRowAsID = (mUtils.IsInitiateWorkbook And mUtils.initateUseAutoID)
End Sub

Public Sub change(sheet As Worksheet, cell As Range)
    If (cell.Count < 1) Then
        Exit Sub
    End If
    If (Not mUtils.IsProductsSheet(sheet)) Then
        Exit Sub
    End If

    ' TODO: Code for checking LOVs when copy/paste
    'If (mUtils.HasColumnLov(sheet, cell.Column)) Then
    '    Call checkLov(sheet, cell)
    'End If
    Application.CutCopyMode = True
    If (mUtils.HasColumnLov(sheet, cell.Column) And lUtils.IsHardLOV(mUtils.ColumnLOVIdentifier(sheet, cell.Column))) Then
        If (checkHardLov(sheet, cell) And (Application.CommandBars("Standard").FindControl(id:=128).Enabled = True)) Then
                    Dim zUndo
                    zUndo = Application.CommandBars("Standard").FindControl(id:=128).List(1)

                        With Application                    'use shortcut
                        .ScreenUpdating = False             'freeze display till ready
                        .EnableEvents = False               'turn events OFF while making changes to sheet
                        .Undo                               'Undo last operation
                        .EnableEvents = True                'turn event trapping back ON
                        .CutCopyMode = False
                        MsgBox (mLocale.GetLocalizationString("STEPChangeTrackerPasteError"))
                        End With

            Exit Sub
        End If
    End If


    Dim idcol As Long
    idcol = mUtils.GetIDColumnIndex
    If (idcol < 0) Then
        Exit Sub
    End If

    On Error GoTo MARK_ERR
    Application.EnableEvents = False
    Dim startrow As Long, endrow As Long, row As Long
    startrow = cell.row
    endrow = cell(cell.Rows.Count).row

    mUtils.RestoreSheetName sheet
    Dim changesheet As Worksheet
    Set changesheet = GetChangesSheet()

    Dim found As Range, sheetColIndex As Long
    Set found = changesheet.Rows(1).cells.Find(what:=sheet.Name, _
        LookAt:=xlWhole, _
        SearchDirection:=xlNext, _
        SearchOrder:=xlByColumns)
    If (found Is Nothing) Then
        sheetColIndex = mUtils.GetLastCol(changesheet, 1) + 1
        changesheet.cells(1, sheetColIndex).Value = sheet.Name
    Else
        sheetColIndex = found.Column

    End If


    Dim parentColumnId As Integer
    Dim t As Integer
    Dim lastAttributeCol As Integer
    lastAttributeCol = mUtils.GetLastCol(sheet, mUtils.AttributeLabelRow)
    For t = 1 To lastAttributeCol
        If sheet.cells(mUtils.AttributeLabelRow, t).Value = "Parent" Then
            parentColumnId = t
            t = lastAttributeCol
        End If
    Next


    For row = startrow To endrow
        Dim id As String
        If mUseRowAsID Then
            id = row
        Else
            id = sheet.cells(row, idcol).Value
            If (id = "") Then
                id = FakeProductID(row)
            End If

        End If
        Set found = changesheet.Columns(sheetColIndex).Find(what:=id, _
            LookAt:=xlPart, _
            after:=changesheet.cells(1, sheetColIndex), _
            SearchDirection:=xlNext, _
            SearchOrder:=xlByRows)

        If (found Is Nothing) Then
            Dim newrow As Long
            newrow = mUtils.GetLastRow(changesheet, sheetColIndex) + 1
            'Changing number format seems redundant and should be removed (ONEKING-611 issue)
            'changesheet.cells(newrow, sheetColIndex).NumberFormat = "@"
            changesheet.cells(newrow, sheetColIndex).Value = id
        End If

        'Debug.Print sheet.Name + " ID: " + sheet.cells(row, idcol).value
    Next

MARK_ERR:
    Application.EnableEvents = True
    On Error GoTo 0
End Sub

Public Sub ClearSheetChanges(ByVal sheetname As String)
    Dim changes As Worksheet
    Set changes = GetChangesSheet()
    Dim sheetColIndex As Long
    sheetColIndex = GetSheetColumnIndex(changes, sheetname)
    If (sheetColIndex < 0) Then
        Exit Sub
    End If
    Dim lastRow As Long
    lastRow = mUtils.GetLastRow(changes, sheetColIndex)
    If (lastRow > 1) Then
        On Error Resume Next
        Application.EnableEvents = False
        changes.Range(changes.cells(2, sheetColIndex), changes.cells(lastRow, sheetColIndex)).Clear
        Application.EnableEvents = True
        On Error GoTo 0
    End If

End Sub

Public Function IsProductChanged(ByVal sheetname As String, ByVal productid As String, ByVal productrowindex As Long) As Boolean
    IsProductChanged = False
    Dim changes As Worksheet
    Set changes = GetChangesSheet()
    Dim sheetColIndex As Long
    sheetColIndex = GetSheetColumnIndex(changes, sheetname)
    If (sheetColIndex < 0) Then
        Exit Function
    End If
    Dim found As Range
    If (productid = "") Then

        If mUseRowAsID Then
            productid = productrowindex
        Else
            productid = FakeProductID(productrowindex)
        End If
    End If
    Set found = changes.Columns(sheetColIndex).Find(what:=productid, _
        after:=changes.cells(1, sheetColIndex), _
        LookAt:=xlWhole, _
        SearchDirection:=xlNext, _
        SearchOrder:=xlByRows)
    IsProductChanged = Not found Is Nothing
End Function

Private Function FakeProductID(ByVal productrowindex As Long)
    FakeProductID = "[ROWASID[" & productrowindex & "]]"

End Function

Public Function GetChangeCount(ByVal sheetname As String)
    GetChangeCount = 0
    Dim changes As Worksheet
    Set changes = GetChangesSheet()
    Dim sheetColIndex As Long
    sheetColIndex = GetSheetColumnIndex(changes, sheetname)
    If (sheetColIndex < 0) Then
        Exit Function
    End If
    Dim found As Range
    Set found = changes.Columns(sheetColIndex).cells.Find(what:="*", _
                LookAt:=xlPart, _
                after:=changes.cells(1, sheetColIndex), _
                SearchDirection:=xlPrevious, _
                SearchOrder:=xlByRows)

    If Not found Is Nothing Then
      GetChangeCount = found.row - 1
    End If

End Function
Public Function GetChangedRowIDs(ByVal sheetname As String) As STEPSet
    Dim res As STEPSet
    Set res = New STEPSet
    Dim changes As Worksheet
    Set changes = GetChangesSheet()
        If changes Is Nothing Then
        Set GetChangedRowIDs = res
        Exit Function
    End If
        Dim sheetColIndex As Long
    sheetColIndex = GetSheetColumnIndex(changes, sheetname)
    If (sheetColIndex < 0) Then
        Exit Function
    End If
    Dim lMax As Long
    lMax = mUtils.GetLastRow(changes, sheetColIndex)

    If lMax > 0 Then
      Dim lIndex As Long
      For lIndex = 2 To lMax
        res.Add changes.cells(lIndex, sheetColIndex).Value
      Next lIndex
    End If
    Set GetChangedRowIDs = res
End Function

Public Sub SetChangedRowIDs(ByVal sheetname As String, ByRef pRowIDSet As STEPSet)
    ClearSheetChanges sheetname
    If (pRowIDSet.Count = 0) Then
        Exit Sub
    End If
    Dim changes As Worksheet
    Set changes = GetChangesSheet()
    Dim sheetColIndex As Long
    sheetColIndex = GetSheetColumnIndex(changes, sheetname)
    If (sheetColIndex <= 0) Then
        sheetColIndex = mUtils.GetLastCol(changes, 1) + 1
        changes.cells(1, sheetColIndex).Value = sheetname
    End If
    Dim lIndex As Long
    On Error GoTo MARK_ERR
    Dim aee As Boolean
    aee = Application.EnableEvents
    Application.EnableEvents = False
    For lIndex = 1 To pRowIDSet.Count
        mUtils.SetNumberFormat changes.cells((1 + lIndex), sheetColIndex)
        changes.cells((1 + lIndex), sheetColIndex).Value = pRowIDSet.Item(lIndex)
    Next
    Application.EnableEvents = aee
    Exit Sub
MARK_ERR:
    Application.EnableEvents = aee
    err.Clear
End Sub

Private Function GetSheetColumnIndex(changesSheet As Worksheet, ByVal sheetname As String) As Long
    GetSheetColumnIndex = -1
    If (Not changesSheet Is Nothing) Then
        Dim found As Range
        Set found = changesSheet.Rows(1).cells.Find(what:=sheetname, _
                    LookAt:=xlWhole, _
                    SearchDirection:=xlNext, _
                    SearchOrder:=xlByColumns)
        If (found Is Nothing) Then
            Exit Function
        End If
        GetSheetColumnIndex = found.Column
    End If
    mUtils.UnmarkMatchEntireCellContents
End Function

Private Function GetChangesSheet() As Worksheet
    If (mSheet Is Nothing) Then
        AssureChangesSheetIsCreated
    End If
    Set GetChangesSheet = mSheet
    On Error GoTo 0
End Function

Public Sub AssureChangesSheetIsCreated()
            On Error Resume Next
            Set mSheet = ThisWorkbook.Worksheets(C_SHEET_NAME)
            If (mSheet Is Nothing) Then
                Dim asu As Boolean
                asu = ThisWorkbook.Application.ScreenUpdating
                ThisWorkbook.Application.ScreenUpdating = False
                Dim cs As Worksheet
                Set cs = ThisWorkbook.Worksheets.Add
                cs.Visible = xlSheetVisible
                cs.Name = C_SHEET_NAME
                Set mSheet = cs
                ThisWorkbook.Application.ScreenUpdating = asu
            End If
End Sub



Private Sub checkLov(ws As Worksheet, cell As Range)
    On Error GoTo LOV_ERR
    'cell.Text = cell.Text
    Dim vtp As String
    If (Not cell.Validation Is Nothing) Then
        If (Not "=STEP_LOV_" = VBA.mID(cell.Validation.Formula1, 1, 10)) Then
            Call setLov(ws, cell)
        End If
    End If
    Exit Sub

LOV_ERR:
    Call setLov(ws, cell)

End Sub


Private Sub setLov(ws As Worksheet, cell As Range)
    Dim mUtils As New STEPSheetUtils
    Dim lUtils As New STEPLovUtils

    Dim lovName As String
    lovName = lUtils.AttributeToLovName(ws.cells(mUtils.ColumnIDRowIndex, cell.Column).Value)

    With cell.Validation
        .Delete
        .Add Type:=xlValidateList, AlertStyle:=xlValidAlertStop, Operator:= _
                    xlBetween, Formula1:="=" & lovName
    End With
End Sub

Private Function ErrorColumnKey(ByVal sheetname As String) As String
    ErrorColumnKey = "[ERRORS[" & sheetname & "]]"
End Function

'************************************************************************************************************************
'
'let's keep track of all rows with errors so we can report them to the user
'and still only revalidate what has actually been changed
'Instead of adding yet another sheet for this we'll put row-identifiers in a
'separete column in the changes sheet
'
'************************************************************************************************************************

Public Function GetRowIDSWithErrors(ByVal sheet As Worksheet) As STEPSet
    Dim res As STEPSet
    Set res = New STEPSet
    Dim changes As Worksheet
    Set changes = GetChangesSheet()
    If changes Is Nothing Then
        Set GetRowIDSWithErrors = res
        Exit Function
    End If
    Dim sheetColIndex As Long
    sheetColIndex = GetSheetColumnIndex(changes, ErrorColumnKey(sheet.Name))
    If (sheetColIndex < 0) Then
        Set GetRowIDSWithErrors = res
        Exit Function
    End If

    Dim lMax As Long
    lMax = mUtils.GetLastRow(changes, sheetColIndex)

    If lMax > 0 Then
      Dim lIndex As Long
      Dim Value
      For lIndex = 2 To lMax
        Value = changes.cells(lIndex, sheetColIndex).Value
        If (Value >= mUtils.FirstProductRow(sheet, False)) Then
            res.Add Value
        End If
      Next lIndex
    End If
    Set GetRowIDSWithErrors = res
End Function

Public Function GetRowIDIndexesSWithErrors(ByVal sheetname As String) As STEPSet
    Dim res As STEPSet
    Set res = New STEPSet
    Dim changes As Worksheet
    Set changes = GetChangesSheet()
    If changes Is Nothing Then
        Set GetRowIDIndexesSWithErrors = res
        Exit Function
    End If
    Dim sheetColIndex As Long
    sheetColIndex = GetSheetColumnIndex(changes, ErrorColumnKey(sheetname))
    If (sheetColIndex < 0) Then
        Set GetRowIDIndexesSWithErrors = res
        Exit Function
    End If

    Dim lMax As Long
    lMax = mUtils.GetLastRow(changes, sheetColIndex)

    If lMax > 0 Then
      Dim lIndex As Long
      For lIndex = 2 To lMax
        res.Add changes.cells(lIndex, sheetColIndex).Value
      Next lIndex
    End If
    Set GetRowIDIndexesSWithErrors = res
End Function

Public Sub RowDeleted(ByVal ws As Worksheet, ByVal rowNumber)
    Dim rowsSet As STEPSet
    Dim changedRowsSet As STEPSet
    Dim errorIndex As Integer
    Set changedRowsSet = New STEPSet
    Set rowsSet = GetRowIDIndexesSWithErrors(ws.Name)
    If (rowsSet.Count > 0) Then
        For errorIndex = 1 To rowsSet.Count
            Dim rowN As Integer
            'do not add deleted row number to set
            rowN = CInt(rowsSet.Item(errorIndex))
            If (rowN > rowNumber) Then
                rowN = rowN - 1
                changedRowsSet.Add CStr(rowN)
            Else
                If (rowN < rowNumber) Then
                    changedRowsSet.Add CStr(rowN)
                End If
            End If
        Next
    End If
    SetRowIDSWithError ws, changedRowsSet

    Set changedRowsSet = New STEPSet
    Set rowsSet = GetChangedRowIDs(ws.Name)
        If (rowsSet.Count > 0) Then
        For errorIndex = 1 To rowsSet.Count
            rowN = CInt(rowsSet.Item(errorIndex))
            If (rowN > rowNumber) Then
                rowN = rowN - 1
                changedRowsSet.Add CStr(rowN)
            Else
                If (rowN < rowNumber) Then
                    changedRowsSet.Add CStr(rowN)
                End If
            End If
        Next
    End If
    SetChangedRowIDs ws.Name, changedRowsSet
End Sub

Private Sub ClearSheetErrors(ByVal sheetname As String)
    Dim changes As Worksheet
    Set changes = GetChangesSheet()
    Dim sheetColIndex As Long
    sheetColIndex = GetSheetColumnIndex(changes, ErrorColumnKey(sheetname))
    If (sheetColIndex < 0) Then
        Exit Sub
    End If
    Dim lastRow As Long
    lastRow = mUtils.GetLastRow(changes, sheetColIndex)
    If (lastRow > 1) Then
        Dim aee As Boolean
        aee = Application.EnableEvents
        On Error Resume Next
        Application.EnableEvents = False
        changes.Range(changes.cells(2, sheetColIndex), changes.cells(lastRow, sheetColIndex)).Clear
        Application.EnableEvents = aee
        On Error GoTo 0
    End If

End Sub

Function IsInArray(stringToBeFound As String, arr As Variant) As Boolean
  IsInArray = False
  Dim v
  For Each v In arr
    If StrComp(CStr(v), stringToBeFound, vbTextCompare) = 0 Then
        IsInArray = True
    End If
  Next
End Function

Private Function checkHardLov(sheet As Worksheet, rng As Range) As Boolean
    checkHardLov = False
    Dim cell As Range
    Dim subRng As Range
    For Each subRng In rng.Columns
        If (mUtils.HasColumnLov(sheet, subRng.Column) And lUtils.IsHardLOV(mUtils.ColumnLOVIdentifier(sheet, subRng.Column))) Then
            Dim lovName As String
            Dim v
            lovName = lUtils.AttributeToLovName(mUtils.ColumnLOVIdentifier(sheet, subRng.Column))
            v = lUtils.GetLovValues(lovName)
            For Each cell In subRng.cells
                Dim multiValueSplit() As String
                Dim Index As Integer
                If (mUtils.IsColumnMultivalued(sheet, subRng.Column)) Then
                    multiValueSplit = Split(cell.Value, ";")
                    For Index = LBound(multiValueSplit) To UBound(multiValueSplit)
                        If (Not IsEmpty(multiValueSplit(Index)) And Not (IsInArray(multiValueSplit(Index), v))) Then
                            checkHardLov = True
                            Exit Function
                        End If
                    Next
                Else
                    If (Not IsEmpty(cell.Value) And Not (IsInArray(cell.Value, v))) Then
                        checkHardLov = True
                        Exit Function
                    End If
                End If

            Next
        End If
    Next
End Function

Public Sub SetRowIDSWithError(ByVal ws As Worksheet, ByRef pRowIDSet As STEPSet)
    ClearSheetErrors ws.Name
    If (pRowIDSet.Count = 0) Then
        Exit Sub
    End If
    Dim changes As Worksheet
    Dim firstRow As Long
    firstRow = mUtils.FirstProductRow(ws, False)
    Set changes = GetChangesSheet()
    Dim sheetColIndex As Long
    sheetColIndex = GetSheetColumnIndex(changes, ErrorColumnKey(ws.Name))
    If (sheetColIndex <= 0) Then
        sheetColIndex = mUtils.GetLastCol(changes, 1) + 1
        changes.cells(1, sheetColIndex).Value = ErrorColumnKey(ws.Name)
    End If
    Dim lIndex As Long
    On Error GoTo MARK_ERR
    Dim aee As Boolean
    aee = Application.EnableEvents
    Application.EnableEvents = False
    For lIndex = 1 To pRowIDSet.Count
        If (pRowIDSet.Item(lIndex) >= firstRow) Then
            changes.cells((1 + lIndex), sheetColIndex).numberFormat = "@"
            changes.cells((1 + lIndex), sheetColIndex).Value = pRowIDSet.Item(lIndex)
        End If
    Next
    Application.EnableEvents = aee
    Exit Sub
MARK_ERR:
    Application.EnableEvents = aee
    err.Clear
End Sub



Attribute VB_Name = "STEPCommentsHandler"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Private mStyleHelper As STEPStyleHelper
Private mUtils As New STEPSheetUtils
Private rowIndex As Long
Private columnIndex As Long
Private lastCommentRow As Long
Private lastCommentColumn As Long
Private firstCommentRow As Long
Private firstCommentColumn As Long
Private mCurrentSheetName As String
Private mLocale As New STEPLocalization

Private Sub Class_Initialize()
    mCurrentSheetName = ""
End Sub

Private Sub Init(ByVal ws As Worksheet, Optional pForceInit As Boolean = False)
    If (Not pForceInit And VBA.StrComp(ws.Name, mCurrentSheetName) = 0) Then
        'already counted
        Exit Sub
    End If
    mCurrentSheetName = ws.Name
    Set mStyleHelper = New STEPStyleHelper
    rowIndex = mUtils.FirstProductRow(ws, False)
    If mUtils.HasExtendedSettingsSheet Then
        columnIndex = 2
    Else
        columnIndex = 1
    End If
    Dim i As Integer
    Dim j As Integer

    firstCommentRow = rowIndex
    firstCommentColumn = columnIndex
    Dim maxRow As Long
    Dim maxCol As Long
    maxRow = mUtils.GetLastRow(ws, 2)
    maxCol = mUtils.GetLastCol(ws, mUtils.HeaderRow)
    For i = firstCommentRow To maxRow
        For j = firstCommentColumn To maxCol
            If Not cells(i, j).Comment Is Nothing Then
                lastCommentRow = i
                If (j > lastCommentColumn) Then lastCommentColumn = j
             End If
        Next j
    Next i

End Sub

Public Sub NextError(ByVal ws As Worksheet)

    If (Not mUtils.IsProductsSheet(ws)) Then
        Exit Sub
    End If

    Init ws, False

    If (mUtils.UseFilter And ws.FilterMode = True And mUtils.ValidationPerformed = True) Then
        MsgBox (mLocale.GetLocalizationString("STEPCommentsHandlerHiddenRows"))
        mUtils.ValidationPerformed = False
    End If

    Dim i As Integer
    Dim j As Integer

    rowIndex = ActiveCell.row
    columnIndex = ActiveCell.Column + 1


    If rowIndex < firstCommentRow Or columnIndex < firstCommentColumn Then
        rowIndex = mUtils.FirstProductRow(ws, False)
        columnIndex = 2
    End If

    If rowIndex = 0 Then
        rowIndex = mUtils.FirstProductRow(ws, False)
    End If

    If columnIndex = 0 Then
        columnIndex = 2
    End If

    If rowIndex > lastCommentRow Then
        rowIndex = mUtils.FirstProductRow(ws, False)
        columnIndex = 2
    End If


    If rowIndex >= lastCommentRow And columnIndex > lastCommentColumn Then
        rowIndex = mUtils.FirstProductRow(ws, False)
        columnIndex = 2
        MsgBox (mLocale.GetLocalizationString("STEPCommentsHandlerReachedEnd")), vbOKOnly, mLocale.GetLocalizationString("STEPCommentsHandlerNext")
    End If

    If rowIndex = lastCommentRow And columnIndex - 1 = lastCommentColumn Then
        rowIndex = mUtils.FirstProductRow(ws, False)
        columnIndex = 2
        MsgBox (mLocale.GetLocalizationString("STEPCommentsHandlerReachedEnd")), vbOKOnly, mLocale.GetLocalizationString("STEPCommentsHandlerNext")
    End If


    i = rowIndex
    j = columnIndex

    Do While i <= lastCommentRow
       Do While j <= lastCommentColumn
            If (Not cells(i, j).Comment Is Nothing) And (Not cells(i, j).EntireRow.Hidden) Then
                cells(i, j).Select
                cells(i, j).Comment.Visible = True
                If j <> 2 Then
                    cells(i, j).Comment.Shape.top = cells(i, j).top + cells(i, j).Height + 2
                    cells(i, j).Comment.Shape.Left = cells(i, j).Left + cells(i, j).Width + 5
                End If
                Increment i, j
                Exit Sub
            End If
            j = j + 1
        Loop
        i = i + 1
        rowIndex = rowIndex + 1
        columnIndex = 2
        j = 2
    Loop

End Sub

Private Sub Increment(ByVal i, ByVal j)
    If columnIndex < mUtils.GetLastCol(ThisWorkbook.ActiveSheet, mUtils.HeaderRow) Then
        columnIndex = j + 1
        Exit Sub
    End If

    If columnIndex = mUtils.GetLastCol(ThisWorkbook.ActiveSheet, mUtils.HeaderRow) Then
        rowIndex = i + 1
        columnIndex = 2
        Exit Sub
    End If

    If rowIndex = mUtils.GetLastRow(ThisWorkbook.ActiveSheet, 2) And columnIndex = mUtils.GetLastCol(ThisWorkbook.ActiveSheet, mUtils.HeaderRow) Then
        rowIndex = mUtils.FirstProductRow(ThisWorkbook.ActiveSheet, False)
        columnIndex = 2
        Exit Sub
    End If

End Sub

Private Function StartsWith(ByVal testString As String, ByVal prefix As String) As Boolean
    StartsWith = False
    If (Len(testString) >= Len(prefix)) Then
        StartsWith = Left$(testString, Len(prefix)) = prefix
    End If
End Function

Private Function EndsWith(ByVal testString As String, ByVal suffix As String) As Boolean
    EndsWith = False
    If (Len(testString) >= Len(suffix)) Then
        EndsWith = mID$(testString, (1 + Len(testString) - Len(suffix))) = suffix
    End If
End Function

Public Sub formatComments(ws As Worksheet)
    Dim AUTOCOMMENT_PREFIX As String
    AUTOCOMMENT_PREFIX = mLocale.GetLocalizationString("STEPCommentsHandlerMoreErrors")
    Dim AUTOCOMMENT_SUFFIX As String
    AUTOCOMMENT_SUFFIX = mLocale.GetLocalizationString("STEPCommentsHandlerMoreErrors2")

    If (Not mUtils.IsProductsSheet(ws)) Then
        Exit Sub
    End If
    Init ws, True
    Dim commentsCount As Long
    Dim i As Integer
    Dim j As Integer
    Dim protected As Boolean
    If (ws.ProtectContents) Then
        protected = True
        mUtils.UnProtectSheet ws
    Else
        protected = False
    End If
    Set mStyleHelper = New STEPStyleHelper
    Dim mTimer As New STEPTimer
    Dim mScreenUpdating As Boolean
    Dim mEnableEvents As Boolean
    On Error GoTo FORMAT_ERROR
    mTimer.StartTimer "Formatting comments"
    mScreenUpdating = ThisWorkbook.Application.ScreenUpdating
    ThisWorkbook.Application.ScreenUpdating = False
    mEnableEvents = ThisWorkbook.Application.EnableEvents
    ThisWorkbook.Application.EnableEvents = False
    For i = firstCommentRow To lastCommentRow
        commentsCount = 0
        For j = (firstCommentColumn + 1) To lastCommentColumn
            If Not ws.cells(i, j).Comment Is Nothing Then
                commentsCount = commentsCount + 1
            End If
        Next j
        If (0 = commentsCount) Then
            'if count is zero it was either zero when we last updated
            'or the row has been validated so the left-most comment is gone anyhow
            GoTo NEXT_ROW
        End If
        If Not ws.cells(i, firstCommentColumn).Comment Is Nothing Then
            Dim commentArray() As String
            Dim commentIndex As Integer
            Dim newComment As String
            commentArray = Split(ws.cells(i, firstCommentColumn).Comment.Text, vbCrLf)
            newComment = ""
            For commentIndex = LBound(commentArray) To UBound(commentArray)
                If (StartsWith(commentArray(commentIndex), AUTOCOMMENT_PREFIX) And EndsWith(commentArray(commentIndex), AUTOCOMMENT_SUFFIX)) Then
                    'skip this
                ElseIf (0 = Len(Trim(commentArray(commentIndex)))) Then
                    'and this
                Else
                    If (Len(newComment) > 0) Then newComment = newComment & vbCrLf
                    newComment = newComment & commentArray(commentIndex)
                End If
            Next commentIndex
            If (Len(newComment) > 0) Then newComment = newComment & vbCrLf
            newComment = newComment & AUTOCOMMENT_PREFIX & commentsCount & AUTOCOMMENT_SUFFIX
            ws.cells(i, firstCommentColumn).Comment.Delete
            ws.cells(i, firstCommentColumn).AddComment (newComment)
        Else
            ws.cells(i, firstCommentColumn).AddComment (AUTOCOMMENT_PREFIX & commentsCount & AUTOCOMMENT_SUFFIX)
        End If
NEXT_ROW:
    Next i
    'for reasons unknown time spent doing format of commets will increase about five times if
    'actual formatting is included in first loop above - very strange
    For i = firstCommentRow To lastCommentRow
        For j = firstCommentColumn To lastCommentColumn
        If Not ws.cells(i, j).Comment Is Nothing Then
            With ws.cells(i, j).Comment
                .Shape.AutoShapeType = msoShapeRectangle
                .Shape.TextFrame.AutoSize = True
                .Shape.Line.ForeColor.RGB = RGB(0, 0, 0)
                .Shape.Line.BackColor.RGB = RGB(0, 0, 0)
                .Shape.Fill.Visible = msoTrue
                .Shape.Fill.ForeColor.RGB = RGB(255, 250, 205)
                .Shape.top = ws.cells(i, j).top
                .Shape.Left = ws.cells(i, j).Left
          End With
          mStyleHelper.SetErrorStyle ws.cells(i, j)
       End If
       Next j
   Next i
   mTimer.StopTimer
FORMAT_ERROR:
    ThisWorkbook.Application.ScreenUpdating = mScreenUpdating
    ThisWorkbook.Application.EnableEvents = mEnableEvents
    If (protected) Then
        mUtils.ProtectSheet ws
    End If
End Sub


Attribute VB_Name = "STEPDuplicateDeleteRowHandler"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Private mUtils As New STEPSheetUtils
Private mLocale As New STEPLocalization
Private Sub Init(ByVal ws As Worksheet)

End Sub

Public Sub DuplicateRow(ByVal ws As Worksheet)
    If (Not mUtils.IsProductsSheet(ws)) Then
        Exit Sub
    End If
    If (ActiveCell.row < mUtils.FirstProductRow(ws, False)) Then
        MsgBox (mLocale.GetLocalizationString("STEPDDRCopyError"))
        Exit Sub
    End If
    Dim lastRow As Integer
    lastRow = mUtils.GetLastRowForAllSheet(ws, ActiveCell.row)
    ws.Rows(ActiveCell.row).EntireRow.Copy Destination:=ws.Rows(lastRow + 1)
    ActiveWindow.ScrollRow = lastRow + 1
    Dim mChangeTracker As STEPChangeTracker
    Set mChangeTracker = New STEPChangeTracker
    mChangeTracker.change ws, ws.Rows(lastRow + 1).EntireRow
End Sub

Public Sub DeleteRow(ByVal ws As Worksheet)
    If (Not mUtils.IsProductsSheet(ws)) Then
        Exit Sub
    End If
    If (ActiveCell.row < mUtils.FirstProductRow(ws, False)) Then
        MsgBox (mLocale.GetLocalizationString("STEPDDRDeleteError"))
        Exit Sub
    End If


    Dim msgRes As Integer
    Dim i As Integer
    Dim boo As Boolean
    boo = False
    For i = 1 To mUtils.GetLastCol(ws, ActiveCell.row)
        If (Not (ws.cells(ActiveCell.row, i).Value = "") And (Not ws.cells(ActiveCell.row, i).Value = "...")) Then
            boo = True
        End If
    Next
    If boo = False Then
        msgRes = MsgBox(mLocale.GetLocalizationString("STEPDDREmptyRow"))
    Else
        msgRes = MsgBox(mLocale.GetLocalizationString("STEPDDRConfirmDeletion") & ActiveCell.row & ".", vbOKCancel)
    End If

    If (msgRes = vbOK) Then
        Dim rowNumber As Integer
        rowNumber = ActiveCell.row
        Dim mChangeTracker As STEPChangeTracker
        Set mChangeTracker = New STEPChangeTracker
        mChangeTracker.RowDeleted ws, ActiveCell.row


        Dim mCellStatusTracker As STEPCellStatusTracker
        Set mCellStatusTracker = New STEPCellStatusTracker
        mCellStatusTracker.Init ws.Name
        mCellStatusTracker.RowDeleted ws, ActiveCell.row

        ws.Rows(ActiveCell.row).EntireRow.Delete
    End If
End Sub
Attribute VB_Name = "STEPErrorSheetUtils"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
'During import of smartsheets a special sheet with information about failing
'products/values can be created
'This class reads this sheet and marks up product sheets with the information from this sheet
Private Const C_ERRORSHEET As String = "STEPSmartSheetImporterErrors"
Private mErrorSheet As Worksheet
Private mUtils As STEPSheetUtils
Private mCellMarker As STEPCellMarker
Private mStyleHelper As STEPStyleHelper

Private Sub Class_Initialize()
    Set mUtils = New STEPSheetUtils
    Set mCellMarker = New STEPCellMarker
    Set mStyleHelper = New STEPStyleHelper
End Sub



Public Sub ApplyImporterErrors()
    If (mUtils.HasSettingsSheet And mUtils.HasExtendedSettingsSheet) Then
        Dim asu As Boolean
        Dim aee As Boolean
        asu = ThisWorkbook.Application.ScreenUpdating
        aee = ThisWorkbook.Application.EnableEvents
        If (mUtils.ImporterErrorsApplied) Then
            Exit Sub
        End If
        On Error Resume Next
        Set mErrorSheet = ThisWorkbook.Sheets(C_ERRORSHEET)
        If (mErrorSheet Is Nothing) Then
            On Error GoTo 0
            Exit Sub
        End If
        Dim errorRow As Long, lastErrorRow As Long
        errorRow = 1
        On Error GoTo APPLY_ERROR
        ThisWorkbook.Application.ScreenUpdating = False
        ThisWorkbook.Application.EnableEvents = False
        lastErrorRow = mUtils.GetLastRow(mErrorSheet, 1)
        While (errorRow <= lastErrorRow)
            Dim s As String
            s = mErrorSheet.cells(errorRow, 1).Value
            If (InStr(1, s, "PRODUCT-SHEET-", vbTextCompare) = 1) Then
                ApplyForSheet s, errorRow + 1, lastErrorRow, errorRow
            End If
        Wend
        mUtils.ImporterErrorsApplied = True
APPLY_ERROR:
        ThisWorkbook.Application.ScreenUpdating = asu
        ThisWorkbook.Application.EnableEvents = aee
    End If
End Sub

Private Sub ApplyForSheet(ByVal productSheetID, ByVal firstRow As Long, ByVal lastRow As Long, ByRef row As Long)
    Dim i As Integer
    Dim prodSheet As Worksheet
    Dim protected As Boolean
    row = firstRow
    On Error GoTo APPLY_SHEET_ERR
    Set prodSheet = FindProductSheet(productSheetID)
    If (Not prodSheet Is Nothing) Then
        protected = prodSheet.ProtectContents
        If (protected) Then
            mUtils.UnProtectSheet prodSheet
        End If
    Else
        protected = False
    End If
    While (row <= lastRow)
        Dim s As String
        s = mErrorSheet.cells(row, 1)
        If (InStr(1, s, "PRODUCT-SHEET-", vbTextCompare) = 1) Then
            Exit Sub
        Else
            If (Not prodSheet Is Nothing) Then
                Dim productRow As Long
                productRow = LongFromLeft(s)
                If (0 < productRow) Then
                    Dim p As Long
                    p = InStr(1, s, "#")
                    If (p > 0 And p < Len(s)) Then
                        mCellMarker.MarkInvalid prodSheet.cells(productRow, 1), VBA.mID(s, p + 1)
                    End If
                    Dim mCol As Integer
                    mCol = 2
                    While (True)
                        s = mErrorSheet.cells(row, mCol)
                        If (0 = Len(s)) Then
                            GoTo DONE_LOOP
                        End If
                        Dim mRange As Range
                        Set mRange = prodSheet.cells(productRow, mCol)
                        If (InStr(1, s, "true", vbBinaryCompare) = 1) Then
                            prodSheet.Range(mRange, mRange).Locked = True
                            mStyleHelper.SetReadOnlyStyle mRange
                        End If
                        p = InStr(1, s, "#")
                        If (0 < p) Then
                            mCellMarker.MarkInvalid mRange, VBA.mID(s, p + 1)
                        End If
                        mCol = mCol + 1
                    Wend
DONE_LOOP:
                End If
            End If
            row = row + 1
        End If
    Wend
APPLY_SHEET_ERR:
    If (Not prodSheet Is Nothing And protected) Then
        mUtils.ProtectSheet prodSheet
    End If
End Sub

Private Function LongFromLeft(ByVal s As String)
    LongFromLeft = -1
    s = VBA.Trim(s)
    Dim res As Long
    res = 0
    Dim i As Long
    i = 1
    For i = 1 To Len(s)
        Dim ascii As Integer
        ascii = Asc(VBA.mID(s, i, 1))
        If (48 <= ascii And 57 >= ascii) Then
            res = (res * 10) + (ascii - 48)
        Else
            If (res > 0) Then LongFromLeft = res
            Exit Function
        End If
        Next i
    If (res > 0) Then LongFromLeft = res
End Function

Private Function FindProductSheet(ByVal sheetID As String) As Worksheet
    Set FindProductSheet = Nothing
    Dim ws As Worksheet
    For Each ws In ThisWorkbook.Sheets
        If (TypeOf ws Is Worksheet) Then
            If (mUtils.IsProductsSheet(ws)) Then
                If (StrComp(sheetID, mUtils.GetSheetKey(ws), vbTextCompare) = 0) Then
                    Set FindProductSheet = ws
                    Exit Function
                End If
            End If
        End If
    Next
    
    
End Function

Private Sub Class_Terminate()
    Set mUtils = Nothing
    Set mCellMarker = Nothing
    Set mStyleHelper = Nothing
End Sub
Attribute VB_Name = "STEPEscapeUtils"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Dim mUseNCR As Boolean
Dim mMaxChar As String

Private Sub Class_Initialize()
    Dim lUtils As STEPSheetUtils
    Set lUtils = New STEPSheetUtils
    mUseNCR = lUtils.UseNCR
    Set lUtils = Nothing
    mMaxChar = VBA.Chr$(126)
End Sub


'Escape characters in value that are illegal in XML and optionally in UTF-8
Public Function escapeXmlValue(ByVal strXMLValue As String) As String
    'Replace special characters &'"<> that would otherwise be interpreted as part of markup language
    Dim lUtils As New STEPSheetUtils
    Dim sValue As String
    If IsNull(strXMLValue) Then
        escapeXmlValue = ""
    ElseIf (mUseNCR) Then
        If (needsEscape(strXMLValue)) Then
            'think it faste to check first and only consttruct strings if needed
            escapeXmlValue = escapeXmlValueNCR(strXMLValue)
        Else
            escapeXmlValue = strXMLValue
        End If
    Else
        sValue = Replace$(strXMLValue, "&", "&amp;") 'do ampersand first !
        sValue = Replace$(sValue, "'", "&apos;")
        sValue = Replace$(sValue, """", "&quot;")
        sValue = Replace$(sValue, "<", "&lt;")
        sValue = Replace$(sValue, ">", "&gt;")
        escapeXmlValue = sValue
   End If
End Function

Private Function needsEscape(ByVal strXMLValue) As Boolean
    needsEscape = False
    Dim lIndex As Long
    Dim lMax As Long
    lMax = VBA.Len(strXMLValue)
    For lIndex = 1 To lMax
        Select Case VBA.mID$(strXMLValue, lIndex, 1)
            Case "&", "'", """", "<", ">"
                needsEscape = True
                Exit Function
            Case Is > mMaxChar
                needsEscape = True
                Exit Function
        End Select
    Next
End Function

Private Function escapeXmlValueNCR(ByVal strXMLValue As String) As String
    'Replace special characters &'"<> that would otherwise be interpreted as part of markup language
    'and turn all extended characters (codepoint > 127) into Unicode point in Numeric Character Representation
    'to let the server turn them into UTF-8
    Dim sValue As String
    Dim lIndex As Long
    Dim lMaxlen As Long
    Dim lChar As String
    lMaxlen = VBA.Len(strXMLValue)
    For lIndex = 1 To lMaxlen
        lChar = VBA.mID$(strXMLValue, lIndex, 1)
        Select Case lChar
            Case Is = "&"
                sValue = sValue + "&amp;"
            Case Is = "'"
                sValue = sValue + "&apos;"
            Case Is = """"
                sValue = sValue + "&quot;"
            Case Is = "<"
                sValue = sValue + "&lt;"
            Case Is = ">"
                sValue = sValue + "&gt;"
            Case Is > mMaxChar
                sValue = sValue + charToNCR(lChar)
            Case Else
                sValue = sValue + lChar
        End Select
    Next lIndex
    escapeXmlValueNCR = sValue
End Function

Private Function charToNCR(ByVal pChar As String) As String
    Dim lUCP As Long
    lUCP = upcFromChar(pChar)
    'https://support.microsoft.com/en-gb/kb/272138
    If (lUCP < 0) Then lUCP = 65536 + lUCP
    If (lUCP >= 0 And lUCP < 65536) Then
        charToNCR = "&#" + CStr(lUCP) + ";"
    Else
        charToNCR = "?"
    End If
End Function

Public Function unescapeXmlValue(ByVal strXMLValue As String) As String
    'Replace Predefined General Entities with special characters &'"<> for user facing messages
    Dim sValue As String
    If IsNull(strXMLValue) Then
        unescapeXmlValue = ""
    Else
        sValue = Replace$(strXMLValue, "&amp;", "&", , , VbCompareMethod.vbTextCompare) 'ignore case
        sValue = Replace$(sValue, "&apos;", "'", , , VbCompareMethod.vbTextCompare)
        sValue = Replace$(sValue, "&quot;", """", , , VbCompareMethod.vbTextCompare)
        sValue = Replace$(sValue, "&lt;", "<", , , VbCompareMethod.vbTextCompare)
        sValue = Replace$(sValue, "&gt;", ">", , , VbCompareMethod.vbTextCompare)
        If (mUseNCR) Then
            sValue = unescapeNCR(sValue)
        End If
        unescapeXmlValue = sValue
   End If
End Function

Private Function unescapeNCR(ByVal strXMLValue As String) As String
    Dim sValue  As String
    Dim lStrLen As Long
    Dim lPos As Long
    Dim lPrevEnd As Long
    Dim lEscapeLen As Long
    Dim lUnescaped As String
    sValue = ""
    lStrLen = VBA.Len(strXMLValue)
    lPos = VBA.InStr(1, strXMLValue, "&#")
    lPrevEnd = 1
    While (lPos > 0)
        If (parseNCR(strXMLValue, lStrLen, lPos, lEscapeLen, lUnescaped)) Then
            If (lPrevEnd < lPos) Then
                sValue = sValue + VBA.mID$(strXMLValue, lPrevEnd, lPos - lPrevEnd)
            End If
            sValue = sValue + lUnescaped
            lPrevEnd = lPos + lEscapeLen
            lPos = lPrevEnd
        Else
            lPos = lPos + 2
        End If
        lPos = VBA.InStr(lPos, strXMLValue, "&#")
    Wend
    If (lPrevEnd < lStrLen) Then
        sValue = sValue + VBA.mID$(strXMLValue, lPrevEnd)
    End If
    unescapeNCR = sValue
End Function

Private Function parseNCR(ByRef strXMLValue As String, ByVal pMaxLen As Long, ByVal pPos As Long, ByRef pLen As Long, ByRef pUnescaped As String) As Boolean
    parseNCR = -1
    pLen = 0
    pUnescaped = ""
    parseNCR = False
    If ((pMaxLen - pPos) > 3) Then
        pPos = pPos + 2 'skip first two characters wich must be &#
        pLen = 2
        Dim lRes As Long
        Dim c As String
        lRes = 0
        While (pPos <= pMaxLen)
            c = VBA.mID$(strXMLValue, pPos, 1)
            pLen = pLen + 1
            If (c >= "0" And c <= "9") Then
                lRes = lRes * 10 + (VBA.Asc(c) - 48)
            ElseIf (";" = c) Then
                If (lRes > 127 And lRes <= 65535) Then
                    pUnescaped = VBA.ChrW$(lRes)
                    parseNCR = True
                    Exit Function
                Else
                    Exit Function
                End If
            Else
                Exit Function
            End If
            pPos = pPos + 1
        Wend
    End If
    
End Function
'----------------------------------------------------------------------
'Excel for Mac has a funky way of (not) dealing with unicode; it is claimed that the AscW and ChrW makes a guess
'so perhaps we should have another one with actual lookup for that
'-without furher ado this works with macroman (e.g Apple Macintosh Roman ) which is what Excel for Mac uses
'for charater layout for intalations for most westen systems
'For now nothing else has been tested
'might need rework for codepage 10001 to 100082
Private Function upcFromChar(ByVal pChar As String) As Long
    upcFromChar = VBA.AscW(pChar)
End Function

Private Function charFromUCP(ByVal upc As Long) As String
    charFromUCP = VBA.ChrW$(upc)
End Function
'-----------------------------------------------------------------------
Attribute VB_Name = "STEPGetNodes"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Private oDom As Object
Private mStepUser As STEPUser

Public Function GetChildNodes(ByVal referenceType As STEPColumnType, _
                              ByVal referenceTypeId As String, _
                              Optional parent As String = "", _
                              Optional ByVal initiateObjectType As String = "", _
                              Optional ByVal includeParent As Boolean = False, _
                              Optional ByVal pRowSupplierID As String = "") As Object
    Set GetChildNodes = Nothing
    STEPLoginForm.GetUser mStepUser
    If (Not mStepUser Is Nothing) Then
        Dim sUtils As New STEPSheetUtils
        Dim requestUtils As New STEPRequestUtils
        
        Dim nodeRequestBuilder As New STEPNodeRequestBuilder
        nodeRequestBuilder.Init sUtils.STEPContext, sUtils.STEPWorkspace, referenceType, referenceTypeId
        
        If (STEPColumnType.STEPParentID = referenceType) Then
            If (sUtils.IsInitiateWorkbook) Then
                If (initiateObjectType = "") Then
                    initiateObjectType = sUtils.GetInitiateObjectTypeId()
                End If
                nodeRequestBuilder.SetAttribute "AllowCreationOf", initiateObjectType
                If (parent = "") Then
                    parent = sUtils.GetInitiateRootProductId()
                End If
            End If
        End If
        
        If (parent <> "") Then
            nodeRequestBuilder.AddNode parent, includeParent
        End If
            
        If Len(pRowSupplierID) > 0 Then
            nodeRequestBuilder.SetAttribute "SupplierGroup", pRowSupplierID
        ElseIf Len(sUtils.STEPSupplierGroup) > 0 Then
            nodeRequestBuilder.SetAttribute "SupplierGroup", sUtils.STEPSupplierGroup
        End If
            
        If sUtils.HasExtendedSettingsSheet Then
            nodeRequestBuilder.SetAttribute "SmartSheet", "true"
        End If
            
        Dim stepHttp As New STEPXmlHttp
        stepHttp.Init requestUtils.STEPGetChildrenURL, username:=mStepUser.username, password:=mStepUser.password, timeout:=-1, token:=mStepUser.token
        If (Not stepHttp.PostXML(nodeRequestBuilder.GetXML)) Then
            Exit Function
        End If
        Set GetChildNodes = stepHttp.ResponseXML
        'Debug.Print stepHttp.ResponseXML.xml
    End If
End Function
Public Function SearchNodes(ByVal referenceType As STEPColumnType, _
                            ByVal referenceTypeId As String, _
                            ByVal expression As String, _
                            Optional ByVal initiateObjectType As String = "", _
                            Optional ByVal pTopProductID As String = "", _
                            Optional ByVal pRowSupplierID As String = "") As Object
    Set SearchNodes = Nothing
    STEPLoginForm.GetUser mStepUser
    If (VBA.Trim(expression) = "") Then
        Exit Function
    End If
    If (Not mStepUser Is Nothing) Then
        Dim sUtils As New STEPSheetUtils
        Dim requestUtils As New STEPRequestUtils
        Dim parent As String
        parent = pTopProductID
        Dim nodeRequestBuilder As New STEPNodeRequestBuilder
        nodeRequestBuilder.Init sUtils.STEPContext, sUtils.STEPWorkspace, referenceType, referenceTypeId
        nodeRequestBuilder.AddQueryExpression expression
        If (STEPColumnType.STEPParentID = referenceType) Then
            If (sUtils.IsInitiateWorkbook) Then
                If (initiateObjectType = "") Then
                    initiateObjectType = sUtils.GetInitiateObjectTypeId()
                End If
                
                nodeRequestBuilder.SetAttribute "AllowCreationOf", initiateObjectType
                If (pTopProductID <> "") Then
                    parent = pTopProductID
                Else
                    parent = sUtils.GetInitiateRootProductId()
                End If
            End If
        End If
        
        If (parent <> "") Then
            nodeRequestBuilder.AddNode parent, True 'combisearch on server always includes node anyhow
        End If
        
        If Len(pRowSupplierID) > 0 Then
            nodeRequestBuilder.SetAttribute "SupplierGroup", pRowSupplierID
        ElseIf Len(sUtils.STEPSupplierGroup) > 0 Then
            nodeRequestBuilder.SetAttribute "SupplierGroup", sUtils.STEPSupplierGroup
        End If
            
        If sUtils.HasExtendedSettingsSheet Then
            nodeRequestBuilder.SetAttribute "SmartSheet", "true"
        End If
            
        Dim stepHttp As New STEPXmlHttp
        stepHttp.Init requestUtils.STEPQueryNodesURL, username:=mStepUser.username, password:=mStepUser.password, timeout:=-1, token:=mStepUser.token
        If (Not stepHttp.PostXML(nodeRequestBuilder.GetXML)) Then
            Exit Function
        End If
        Set SearchNodes = stepHttp.ResponseXML
        'Debug.Print stepHttp.ResponseXML.xml
    End If
End Function


Attribute VB_Name = "STEPHttpServerCommunication"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
'Class created by ASEME v/Anders Villy Ehrenreich Erikse
' avee42@gmail.com
'www.aseme.dk
'This class handles the server communication
'The class wraps the xmlhttp classes used by Microsoft or a curl command call on the mac

Private mResultXml As String
Private mDom As STEPXmlDom

#If Mac Then
' Mac part, will be handled by a curl call where most of the below class members are parameters for the call
Private mTimeOut As Long
Private mHttpRequestMethod As String
Private mStepURL As String
Private mAsync As Boolean 'Ignored on the mac always sync communication
Private mUserName As String
Private mPassword As String
Private mToken As String
Private mLastExitCode As Long
Private mRequestHeader As String 'Not used on the mac
Private mRequestArgs As String
Private mMacStatus As String
Private mMacStatusText As String
'do not change UCPSeparator - it matches a constant in MacEscapeHelper serverside
Private Const UCPSeparator = "UCP#:"
Private mLocale As New STEPLocalization

'Bind ability to use file management functions
#If VBA7 Then
        Private Declare PtrSafe Function popen Lib "/usr/lib/libc.dylib" (ByVal command As String, ByVal mode As String) As LongPtr
        Private Declare PtrSafe Function pclose Lib "/usr/lib/libc.dylib" (ByVal file As LongPtr) As Long
        Private Declare PtrSafe Function fread Lib "/usr/lib/libc.dylib" (ByVal outStr As String, ByVal size As LongPtr, ByVal items As LongPtr, ByVal stream As LongPtr) As Long
        Private Declare PtrSafe Function feof Lib "/usr/lib/libc.dylib" (ByVal file As LongPtr) As LongPtr

        'This function opens the shell on the Mac and streams the command to it, while reading the result text
    Function execShell(command As String, Optional ByRef exitCode As Long) As String
        Dim file As LongPtr
        file = popen(command, "r")

        If file = 0 Then
            Exit Function
        End If

        While feof(file) = 0
            Dim chunk As String
            Dim read As Long
            chunk = VBA.Space(50)
            read = fread(chunk, 1, Len(chunk) - 1, file)
            If read > 0 Then
                chunk = VBA.Left$(chunk, read)
                execShell = execShell & chunk
            End If
        Wend

        exitCode = pclose(file)
    End Function

#Else
        Private Declare Function popen Lib "libc.dylib" (ByVal command As String, ByVal mode As String) As Long
        Private Declare Function pclose Lib "libc.dylib" (ByVal file As Long) As Long
        Private Declare Function fread Lib "libc.dylib" (ByVal outStr As String, ByVal size As Long, ByVal items As Long, ByVal stream As Long) As Long
        Private Declare Function feof Lib "libc.dylib" (ByVal file As Long) As Long

        'This function opens the shell on the Mac and streams the command to it, while reading the result text
    Function execShell(command As String, Optional ByRef exitCode As Long) As String
        Dim file As Long
        file = popen(command, "r")

        If file = 0 Then
            Exit Function
        End If

        While feof(file) = 0
            Dim chunk As String
            Dim read As Long
            chunk = VBA.Space(50)
            read = fread(chunk, 1, Len(chunk) - 1, file)
            If read > 0 Then
                chunk = VBA.Left$(chunk, read)
                execShell = execShell & chunk
            End If
        Wend

        exitCode = pclose(file)
    End Function

#End If


'curl considers dollar-sign as a processing instruction to be replaced with a variable
'so we need to escape it
Private Function escapeDollar(ByVal Source As String) As String
    Dim pos As Long
    If ("" = Source) Then
        escapeDollar = ""
        Exit Function
    End If
    pos = InStr(1, Source, "$")
    If (1 = pos) Then
        Source = "\" & Source
        pos = InStr(3, Source, "\")
    End If
    While (pos > 0)
        If ("\" = VBA.mID$(Source, pos - 1, 1)) Then
            pos = pos + 1
        Else
            Source = VBA.mID$(Source, 1, pos - 1) & "\" & VBA.mID$(Source, pos)
            pos = pos + 2
        End If
        pos = InStr(pos, Source, "$")
    Wend
    escapeDollar = Source
End Function

'if we manage to detect a HTTP status code from headers set it here
Private Sub setMacStatus(ByVal s As String)
    Dim p As Integer
    p = InStr(1, s, " ")
    If (p > 0) Then
        mMacStatus = VBA.Trim(VBA.Left(s, p - 1))
        If ("100" = mMacStatus Or "101" = mMacStatus Or "102" = mMacStatus) Then
            'do not care for continue which we get from some chatty servers
            mMacStatus = ""
            Exit Sub
        End If
        If (p < Len(s)) Then
            mMacStatusText = VBA.Trim(VBA.mID(s, p))
        End If
    End If
End Sub

'attempt to read status code header from the response retrieved with cURL and
'strip all header information from the result for dom loading
Private Function stripHeaders(ByVal result As String) As String
    Dim pos As Integer
    mMacStatus = ""
    mMacStatusText = ""
    stripHeaders = result
    'we're requesting xml so if we get anything any response it will start with <
    pos = InStr(1, result, "<", vbBinaryCompare)
    If (pos > 1) Then
        Dim work  As String
        Dim workArray() As String
        work = VBA.Left$(result, pos - 1)
        workArray = Split(work, vbLf)
        stripHeaders = VBA.mID$(result, pos)
        Dim i As Integer
        For i = LBound(workArray) To UBound(workArray)
            Dim s As String
            s = VBA.Trim(workArray(i))
            pos = InStr(1, s, "HTTP/", vbTextCompare)
            If (pos = 1) Then
                'this ought to be first line with http status
                'but we might experience double http status with code 100 - Continue
                pos = InStr(1, s, " ")
                If (pos > 1) Then
                    setMacStatus VBA.mID(s, pos + 1)
                    If (mMacStatus <> "") Then
                        Exit Function
                    End If
                End If
            End If
        Next i
        For i = LBound(workArray) To UBound(workArray)
            'possibly actual status code (unlikely)?
            pos = InStr(1, s, "Status", vbTextCompare)
            If (pos = 1) Then
                pos = InStr(1, s, ":")
                If (pos > 1) Then
                    setMacStatus VBA.mID(s, pos + 1)
                    Exit Function
                End If
            End If


        Next i
    End If
End Function

'Used to escape inappropriate character for UTF-8 encoding on MAC
'simply write them in normal NCR (Numeric Character Representation) then
'the server will take care of the rest
Private Function EscapeUCP(ByVal s As String) As String
    Dim i As Long
    Dim w As Integer
    Dim c As String
    EscapeUCP = ""
    For i = 1 To Len(s)
        c = VBA.mID(s, i, 1)
        w = AscW(c)
        If w >= 128 Then
            'Debug.Print c & " " & CStr(w)
            EscapeUCP = EscapeUCP & "&#" & CStr(w) & ";"
        Else
            EscapeUCP = EscapeUCP & c
        End If
    Next
End Function
'converts a string of digit characters to long in radix 10
'returns -1 if empty string or any non-digit character is encountered
Private Function toLong(s As String) As Long
    toLong = -1
    If (Len(s) = 0) Then Exit Function
    Dim res As Long
    res = 0
    Dim i As Long
    Dim ascii As Integer
    For i = 1 To Len(s)
        ascii = AscW(VBA.mID(s, i, 1))
        '48 is AscW("0") and 57 is AscW("9")
        If (ascii >= 48 And ascii <= 57) Then
            res = (res * 10) + (ascii - 48)
        Else
            Exit Function
        End If
    Next i
    toLong = res
End Function

'converts special escape-sequences containing Unicode points to characters in the culture and code page settings for the current thread
'necessary because we cannot otherwise convert the UTF-8 we get from the server to the local code page
'this necessitate that the STEP services that responds to HTTPMacRequest escapes all characters bigger that 128 to this sequence
Private Function unEscapeUcp(ByVal s As String, ByVal separator As String)
    Dim i As Long
    Dim str() As String
    Dim j As Long
    Dim b As String
    Dim endPos As Long
    Dim ascii As Integer
    If InStr(1, s, separator, vbBinaryCompare) > 0 Then
        str() = Split(s, separator)
        unEscapeUcp = ""
        If str(0) <> "" Then unEscapeUcp = unEscapeUcp + str(0)
        For i = 1 To UBound(str)
            If str(i) <> "" Then
                endPos = InStr(1, str(i), ";")
                ascii = -1
                If endPos > 0 Then
                    ascii = toLong(VBA.Left(str(i), endPos - 1))
                End If
                If (endPos > 0 And ascii > 0) Then
                    unEscapeUcp = unEscapeUcp + VBA.ChrW(ascii) + VBA.mID(str(i), endPos + 1)
                Else
                    unEscapeUcp = unEscapeUcp + separator + str(i)
                End If
            Else
                unEscapeUcp = unEscapeUcp + separator + str(i)
            End If
        Next i
   Else
       unEscapeUcp = s
   End If
End Function

'Called when posting and xml request on the mac
'Builds a curl request and sends it to the shell function
Private Sub HTTPMacRequest(sQuery As String)
    Dim lUtils As New STEPSheetUtils
    Dim sCmd As String
    Dim sResult As String
    Dim lExitCode As Long
    Dim mstepAddr As String
    Const HTTP_PROTOCOL = "http://"
    Const HTTPS_PROTOCOL = "https://"
    Dim mProtocol As String

    If (InStr(1, mStepURL, HTTP_PROTOCOL, vbTextCompare) = 1) Then
        mProtocol = HTTP_PROTOCOL
    ElseIf (InStr(1, mStepURL, HTTPS_PROTOCOL, vbTextCompare) = 1) Then
        mProtocol = HTTPS_PROTOCOL
    Else
        err.Raise 10401, , mLocale.GetLocalizationString("STEPCellMarkerMissingValue") & mStepURL
    End If



    mstepAddr = VBA.Right(mStepURL, Len(mStepURL) - Len(mProtocol))
'escape
    If (Not lUtils.UseNCR) Then
        'now that all values to and from server uses NCR there's no reason to do this any more
        sQuery = EscapeUCP(sQuery)
    End If
    sQuery = escapeDollar(sQuery)

    If (Len(mUserName) > 0 And Len(mPassword) > 0) Then
        '-i tells curl to include all headers
        sCmd = "curl -i -X " & mHttpRequestMethod & " -d """ & sQuery & """ " & mProtocol & mUserName & ":" & mPassword & "@" & mstepAddr
'        sCmd = "curl -X " & mHttpRequestMethod & " -d """ & sQuery & """ " & mProtocol & mUserName & ":" & mPassword & "@" & mstepAddr
    ElseIf (Len(mUserName) > 0 And Len(mToken) > 0) Then
         '-i tells curl to include all headers
        sCmd = "curl -i -X " & mHttpRequestMethod & " -d """ & sQuery & """ " & "-H ""smartsheettoken:" & mUserName & ":" & mToken & """ " & mProtocol & mstepAddr
'        sCmd = "curl -X " & mHttpRequestMethod & " -d """ & sQuery & """ " & "-H ""smartsheettoken:" & mUserName & ":" & mToken & """ " & mProtocol & mstepAddr
    Else
        sCmd = "curl -i -X " & mHttpRequestMethod & " -d """ & sQuery & """ " & mProtocol & mstepAddr
'        sCmd = "curl -X " & mHttpRequestMethod & " -d """ & sQuery & """ " & mProtocol & mstepAddr
    End If
'    MsgBox sCmd
    sResult = execShell(sCmd, lExitCode)
   'unescape
    If (Not lUtils.UseNCR) Then
        sResult = unEscapeUcp(sResult, UCPSeparator)
    End If
    'Dim ll As STEPLogger
    'Set ll = New STEPLogger
    'll.Info "HTTPMacResponse", sResult
    'Set ll = Nothing

    mLastExitCode = lExitCode
    'ToDo check lExitCode
    If (lExitCode = 0) Then
        mResultXml = stripHeaders(sResult)
        Call resultDom.Parse(mResultXml)
    Else
        err.Raise mLastExitCode, , mLocale.GetLocalizationString("STEPHttpServerCommunitationError")
    End If
    
End Sub
#Else
'Windows part using the MSXML packages to do xml requests
Private mXmlhttp As Object
Private mlasterror As String

Private Function GetXmlHttp() As Object
    Dim obj As Object
    On Error Resume Next
    Set obj = CreateObject("MSXML2.XMLHTTP")
    If err.Number <> 0 Then
        err.Clear
        Set obj = CreateObject("MSXML.XMLHTTPRequest")
    End If
    If err.Number <> 0 Then
        mlasterror = err.Description
        Set obj = Nothing
    End If
    Set GetXmlHttp = obj
    On Error GoTo 0
End Function
'Property to make sure that the xmlhttp object is always present
Private Property Get xmlhttp() As Object
    If mXmlhttp Is Nothing Then
        Set mXmlhttp = GetXmlHttp()
     End If
     Set xmlhttp = mXmlhttp
End Property
#End If

'Result dom to make sure that the xml dom is always present
Private Property Get resultDom() As STEPXmlDom
If mDom Is Nothing Then
    Set mDom = New STEPXmlDom
End If
Set resultDom = mDom
End Property

'Not used on the Mac
Public Sub setRequestHeader(rqstHeader As String, args As String)
#If Mac Then
mRequestHeader = rqstHeader
mRequestArgs = args
#Else
Call xmlhttp.setRequestHeader(rqstHeader, args)
#End If
End Sub

'Open function renamed to Open1 because of compiler issues
'On the mac just set member variables
'On windows redirect call to msxml package
Public Sub Open1(httpRequestMethod As String, stepurl As String, async As Boolean, Optional username As String, Optional password As String, Optional token As String)
    #If Mac Then
    mHttpRequestMethod = httpRequestMethod
    If (IsNull(stepurl)) Then
        mStepURL = ""
    Else
        mStepURL = VBA.Trim(stepurl)
    End If
    mAsync = async
    mUserName = username
    mPassword = password
    mToken = token
    #Else
    If (Len(token) > 0) Then
        Call xmlhttp.Open(httpRequestMethod, stepurl, async)
        xmlhttp.setRequestHeader "smartsheettoken", username & ":" & token
    Else
        Call xmlhttp.Open(httpRequestMethod, stepurl, async, username, password)
    End If
    #End If
End Sub

'Send function for xml string
Public Function send(xmlstr As String) As Boolean
#If Mac Then
    Call HTTPMacRequest(xmlstr)
#Else
    xmlhttp.send (xmlstr)
#End If
End Function

'Sed dom to send an xml dom
Public Function senddom(dom As STEPXmlDom) As Boolean
    senddom = send(dom.Xml)
End Function

'Return the xml response in a dom
'On the mac, the dom is already set in HTTPMacRequest function
'On windows the msxml dom is mapped to a stepxmldom
Public Function ResponseXML() As STEPXmlDom
#If Mac Then
    Set ResponseXML = resultDom
#Else
    Call resultDom.Parse(xmlhttp.ResponseText)
    Set ResponseXML = resultDom
#End If
End Function
'Return the resulting xml in a string
Public Function ResponseText() As String
#If Mac Then
    ResponseText = mResultXml
#Else
    ResponseText = xmlhttp.ResponseText()
#End If
End Function
'Time out for the call function
'Not settable on the mac
Public Property Let timeout(tmout As Long)
#If Mac Then
    mTimeOut = tmout
#Else
    xmlhttp.timeout = tmout
#End If
End Property
' Do nothing
Public Function testCommunication() As Boolean
    testCommunication = True
End Function
'Status of the xml call
Public Property Get Status() As String
#If Mac Then
    If (mLastExitCode = 0) Then
        If (mMacStatus <> "") Then
            Status = mMacStatus
        Else
            Status = 200
        End If
    Else
    Status = mLastExitCode
    End If
#Else
    Status = xmlhttp.Status
#End If
End Property
'Status text of the xml call - Not applicable on the mac
Public Property Get statusText() As String
#If Mac Then
    If (mMacStatus <> "") Then
        statusText = mMacStatusText
    Else
        statusText = mResultXml
    End If
#Else
    statusText = xmlhttp.statusText
#End If
End Property
Attribute VB_Name = "STEPHttpStatusCodes"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private statusCodes As Collection


Public Function GetFullStatusText(code As String)
    GetFullStatusText = "Unknown"
    
    If (statusCodes Is Nothing) Then
        Init
    End If
    
    On Error GoTo NOTFOUND
        GetFullStatusText = statusCodes.Item(code)
        Exit Function
NOTFOUND:
    
End Function


Public Function GetStatusText(code As Integer)
    GetStatusText = "Unknown"
    
    If (code > 12000 And code < 13000) Then
        GetStatusText = "Could not connect to the server"
    End If
End Function


Public Sub Init()
    Set statusCodes = New Collection
    statusCodes.Add "No more handles could be generated at this time.", "12001"
    statusCodes.Add "The request has timed out.", "12002"
    statusCodes.Add "An extended error was returned from the server. This is", "12003"
    statusCodes.Add "An internal error has occurred.", "12004"
    statusCodes.Add "The URL is invalid.", "12005"
    statusCodes.Add "The URL scheme could not be recognized or is not supported.", "12006"
    statusCodes.Add "The server name could not be resolved.", "12007"
    statusCodes.Add "The requested protocol could not be located.", "12008"
    statusCodes.Add "A request to InternetQueryOption or InternetSetOption", "12009"
    statusCodes.Add "The length of an option supplied to InternetQueryOption or", "12010"
    statusCodes.Add "The request option cannot be set, only queried.", "12011"
    statusCodes.Add "The Win32 Internet function support is being shut down or", "12012"
    statusCodes.Add "The request to connect and log on to an FTP server could", "12013"
    statusCodes.Add "The request to connect and log on to an FTP server could", "12014"
    statusCodes.Add "The request to connect to and log on to an FTP server", "12015"
    statusCodes.Add "The requested operation is invalid.", "12016"
    statusCodes.Add "The operation was canceled, usually because the handle on", "12017"
    statusCodes.Add "The type of handle supplied is incorrect for this", "12018"
    statusCodes.Add "The requested operation cannot be carried out because the", "12019"
    statusCodes.Add "The request cannot be made via a proxy.", "12020"
    statusCodes.Add "A required registry value could not be located.", "12021"
    statusCodes.Add "A required registry value was located but is an incorrect", "12022"
    statusCodes.Add "Direct network access cannot be made at this time.", "12023"
    statusCodes.Add "An asynchronous request could not be made because a zero", "12024"
    statusCodes.Add "An asynchronous request could not be made because a", "12025"
    statusCodes.Add "The required operation could not be completed because one", "12026"
    statusCodes.Add "The format of the request is invalid.", "12027"
    statusCodes.Add "The requested item could not be located.", "12028"
    statusCodes.Add "The attempt to connect to the server failed.", "12029"
    statusCodes.Add "The connection with the server has been terminated.", "12030"
    statusCodes.Add "The connection with the server has been reset.", "12031"
    statusCodes.Add "Calls for the Win32 Internet function to redo the request.", "12032"
    statusCodes.Add "The request to the proxy was invalid.", "12033"
    statusCodes.Add "The request failed because the handle already exists.", "12036"
    statusCodes.Add "SSL certificate date that was received from the server is", "12037"
    statusCodes.Add "SSL certificate common name (host name field) is incorrect.", "12038"
    statusCodes.Add "The application is moving from a non-SSL to an SSL", "12039"
    statusCodes.Add "The application is moving from an SSL to an non-SSL", "12040"
    statusCodes.Add "Indicates that the content is not entirely secure. Some of", "12041"
    statusCodes.Add "The application is posting and attempting to change", "12042"
    statusCodes.Add "The application is posting data to a server that is not", "12043"
    statusCodes.Add "The requested operation cannot be made on the FTP session", "12110"
    statusCodes.Add "The FTP operation was not completed because the session was", "12111"
    statusCodes.Add "An error was detected while parsing data returned from the", "12130"
    statusCodes.Add "The request must be made for a file locator.", "12131"
    statusCodes.Add "An error was detected while receiving data from the gopher", "12132"
    statusCodes.Add "The end of the data has been reached.", "12133"
    statusCodes.Add "The supplied locator is not valid.", "12134"
    statusCodes.Add "The type of the locator is not correct for this operation.", "12135"
    statusCodes.Add "The requested operation can only be made against a Gopher+", "12136"
    statusCodes.Add "The requested attribute could not be located.", "12137"
    statusCodes.Add "The locator type is unknown.", "12138"
    statusCodes.Add "The requested header could not be located.", "12150"
    statusCodes.Add "The server did not return any headers.", "12151"
    statusCodes.Add "The server response could not be parsed.", "12152"
    statusCodes.Add "The supplied header is invalid.", "12153"
    statusCodes.Add "The request made to HttpQueryInfo is invalid.", "12154"
    statusCodes.Add "The header could not be added because it already exists.", "12155"
    statusCodes.Add "The redirection failed because either the scheme changed", "12156"
End Sub
Attribute VB_Name = "STEPInheritanceUtils"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Private mStyleHelper As STEPStyleHelper



Public Sub ApplyInheritance()
    Dim mStyleHelper As New STEPStyleHelper
    Dim mUtils As New STEPSheetUtils
    Dim FirstProductRow As Integer

    If (mUtils.InheritanceApplied) Then
       Exit Sub
    End If

    On Error GoTo APPLY_ERR
    ThisWorkbook.Application.EnableEvents = False

    Dim IsInitiateWorkbook As Boolean
    IsInitiateWorkbook = mUtils.IsInitiateWorkbook()
    Dim protected As Boolean
    Dim ws As Worksheet
    Dim Index As Integer, col As Long

    'Loop through all worksheets and process product sheets only
    For Index = 1 To ThisWorkbook.Worksheets.Count
        Set ws = ThisWorkbook.Worksheets(Index)
        If (mUtils.IsProductsSheet(ws)) Then
            protected = ws.ProtectContents
            mUtils.UnProtectSheet ws
            'Loop through all columns and check for inheritance markup
            For col = 2 To mUtils.GetLastCol(ws, mUtils.ColumnInheritanceRowIndex)
               Dim inheritanceSource As String
               inheritanceSource = ws.cells(mUtils.ColumnInheritanceRowIndex, col).Value
               Dim r As Range
               Dim lastRow As Integer

               If (Not inheritanceSource = "") Then
    If (mUtils.HasExtendedSettingsSheet) Then
        lastRow = mUtils.GetLastRow(ws, 1)
    Else
        If (mUtils.IsInitiateWorkbook) Then
            lastRow = mUtils.LastInitiateRow(ws)
        Else
            lastRow = mUtils.GetLastRow(ws, 2)
        End If
    End If
                    Dim rowNum As Integer
                    Dim val As String
                    Dim theCell As Range
                    
                    FirstProductRow = mUtils.FirstProductRow(ws, False)
                    'Loop through all cells in this column and if the columns text value
                    'is a formula (means starts with "="), copy the value and set it as a
                    'cell formula in order to make Excel aware that it is intended as a
                    'formula rather than text
                    For rowNum = FirstProductRow To lastRow
                        Set theCell = ws.cells(rowNum, col)
                        val = theCell.Value
                        If val Like "=*" Then
                            theCell.Value = ""
                            theCell.numberFormat = "General"
                            theCell.Formula = val
                            mStyleHelper.SetInheritedStyle theCell
                        End If
                    Next
                End If
            Next
            If (protected) Then
                mUtils.ProtectSheet ws
                protected = False
            End If
        End If
    Next
    mUtils.InheritanceApplied = True
    ThisWorkbook.Application.EnableEvents = True
    Exit Sub

APPLY_ERR:
    If (Not ws Is Nothing And protected) Then
        mUtils.ProtectSheet ws
    End If
    ThisWorkbook.Application.EnableEvents = True
End Sub
Attribute VB_Name = "STEPLOVForm"
Attribute VB_Base = "0{49F7C0D1-71F8-4055-876C-1F73F730CEAA}{AE517705-AB7A-4B43-B5F9-9AB22437A213}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False







Option Explicit

Private mLovUtils As STEPLovUtils
Private mCanceled As Boolean
Private mLovValues() As String
Private mNewValues As Integer
Private mLovName As String
Private mResult() As String
Private mLocale As New STEPLocalization
#If Mac Then
  Private Const mcFontSize As Long = 10
#Else
  Private Const mcFontSize As Long = 8
#End If

Public Function Init(ByVal pAttributeID As String, ByVal pCaption As String, ByRef pCurrenValues() As String) As Boolean
    Dim cnt As Integer
    Me.Caption = pCaption
    Me.BackColor = cmdOK.BackColor
    Label1.Font.size = mcFontSize
    Label2.Font.size = mcFontSize
    Label1.Caption = mLocale.GetLocalizationString("LOVAvailableValues")
    Label2.Caption = mLocale.GetLocalizationString("LOVCurrentValues")
    lst.Font.size = mcFontSize
    lstSelected.Font.size = mcFontSize
    cmdAdd.Font.size = mcFontSize
    cmdCancel.Font.size = mcFontSize
    cmdNew.Font.size = mcFontSize
    cmdOK.Font.size = mcFontSize
    cmdRemove.Font.size = mcFontSize
    cmdOK.Left = Me.Width / 2 + 4
    cmdCancel.Left = cmdOK.Left - 8 - cmdCancel.Width

    cmdOK.Caption = mLocale.GetLocalizationString("LOVOk")
    cmdCancel.Caption = mLocale.GetLocalizationString("LOVCancel")
    cmdNew.Caption = mLocale.GetLocalizationString("LOVNew")

    ReDim mResult(0) As String

    Set mLovUtils = New STEPLovUtils

    mLovName = mLovUtils.AttributeToLovName(pAttributeID)
    Dim v
    v = mLovUtils.GetLovValues(mLovName)
    If (IsEmpty(v) Or Not IsArray(v)) Then
        MsgBox mLocale.GetLocalizationString("LOVUndefined"), vbOKOnly, Me.Caption
        Init = False
        Exit Function
    End If
    mLovValues = v


    For cnt = LBound(pCurrenValues) To UBound(pCurrenValues)
        If (VBA.Trim(pCurrenValues(cnt)) <> "") Then
            lstSelected.AddItem pCurrenValues(cnt)
        End If
    Next cnt
    Dim expand As Boolean
    expand = False
    For cnt = LBound(mLovValues) To UBound(mLovValues)
        If (VBA.Trim(mLovValues(cnt)) <> "") Then
            lst.AddItem mLovValues(cnt)
            If (VBA.Len(mLovValues(cnt)) > 30) Then
                expand = True
            End If
        End If
    Next

    If (expand = True) Then
         lst.ColumnWidths = "500pt"
         lstSelected.ColumnWidths = "500pt"
    End If

    cmdNew.Visible = Not mLovUtils.IsHardLOV(pAttributeID)
    If (cmdNew.Visible) Then
        mNewValues = 0
    Else
        mNewValues = -1
    End If
    Init = True

End Function

Public Function Run() As Boolean
    mCanceled = True
     Me.Show vbModal
    Run = Not mCanceled
End Function

Public Function GetResult() As String()
    GetResult = mResult()
End Function

Private Function IsSelected(ByVal lovval As String) As Boolean
    IsSelected = False
    Dim i As Long
    For i = 0 To lstSelected.ListCount - 1
        If (StrComp(lovval, lstSelected.List(i)) = 0) Then
            IsSelected = True
        End If
    Next

End Function

Private Sub cmdAdd_Click()
    Dim i As Integer
    For i = 0 To lst.ListCount - 1
        If (lst.Selected(i)) Then
            If (IsSelected(lst.List(i))) Then
                If (vbYes <> MsgBox(lst.List(i) & mLocale.GetLocalizationString("LOVAlreadySelected"), vbDefaultButton2 + vbYesNo, Me.Caption)) Then
                    GoTo SKIP_VAL
                End If
            End If
            lstSelected.AddItem lst.List(i)
SKIP_VAL:
            lst.Selected(i) = False
        End If
    Next
End Sub

Private Sub cmdCancel_Click()
    ReDim mResult(0) As String
    Me.Hide
End Sub

Private Sub cmdNew_Click()
    Dim nv As String
    nv = InputBox(mLocale.GetLocalizationString("LOVInputTitle"), mLocale.GetLocalizationString("LOVInputAddNew"))
    If (nv <> "") Then
        Dim i As Integer
        For i = 0 To lst.ListCount - 1
            If (nv = lst.List(i)) Then
                MsgBox mLocale.GetLocalizationString("LOVAlreadyInList"), vbOKOnly, Me.Caption
                Exit Sub
            End If
        Next
        lstSelected.AddItem nv
        lst.AddItem nv
        Dim lb As Integer
        Dim ub As Integer
        lb = LBound(mLovValues)
        ub = UBound(mLovValues)
        For i = lb To ub
            If (StrComp(mLovValues(i), nv, vbBinaryCompare) = 0) Then
                Exit Sub
            End If
        Next
        ub = ub + 1
        ReDim Preserve mLovValues(lb To ub)
        mLovValues(ub) = nv
        mNewValues = mNewValues + 1
    End If
End Sub

Private Sub cmdOK_Click()
    Dim Index As Integer, cnt As Integer
    mCanceled = False
    cnt = 0
    For Index = 0 To lstSelected.ListCount - 1
        If (lstSelected.List(Index) <> "") Then
            cnt = cnt + 1
        End If
    Next
    If (cnt > 0) Then
        ReDim mResult(0 To cnt - 1) As String
        cnt = 0
        For Index = 0 To lstSelected.ListCount - 1
            If (lstSelected.List(Index) <> "") Then
                mResult(cnt) = lstSelected.List(Index)
                cnt = cnt + 1
            End If
        Next
    Else
        ReDim mResult(0) As String
    End If
    If (mNewValues > 0) Then
        Dim nvs() As String
        ReDim nvs(0 To mNewValues - 1) As String
        Index = UBound(mLovValues) - mNewValues + 1
        For cnt = LBound(nvs) To UBound(nvs)
            nvs(cnt) = mLovValues(Index + cnt)
        Next
        mLovUtils.AddLovValues mLovName, nvs
    End If
    Me.Hide
End Sub

Private Sub ReOrderValues()
    
    Dim s As String, i As Integer, sa() As String, v As String
    If (lst.ListCount > 0) Then
        ReDim sa(0 To lst.ListCount - 1) As String
        For i = 0 To lst.ListCount - 1
            sa(i) = lst.List(i)
        Next
        s = vbTab & Join(sa, vbTab) & vbTab
        lst.Clear
        For i = LBound(mLovValues) To UBound(mLovValues)
            If InStr(s, vbTab & mLovValues(i) & vbTab) > 0 Then
                lst.AddItem (mLovValues(i))
            End If
        Next
        
    End If
    
    
End Sub

Private Sub cmdRemove_Click()
    Dim i As Integer, boo As Boolean
    For i = lstSelected.ListCount - 1 To 0 Step -1
        If (lstSelected.Selected(i)) Then
            lstSelected.RemoveItem i
            boo = True
        End If
    Next
End Sub

Private Sub lst_DblClick(ByVal cancel As MSForms.ReturnBoolean)
    cmdAdd_Click
End Sub

Private Sub lstSelected_DblClick(ByVal cancel As MSForms.ReturnBoolean)
    cmdRemove_Click
End Sub

Attribute VB_Name = "STEPLocalization"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Private Const C_SHEET_NAME = "STEPLocalization"
Private mSheet As Worksheet

Public Property Get LocalizationSheet() As Worksheet
    If (mSheet Is Nothing) Then
        On Error Resume Next
        Set mSheet = ThisWorkbook.Worksheets(C_SHEET_NAME)

    End If
    Set LocalizationSheet = mSheet
End Property

Private Sub Class_Initialize()
    Set mSheet = Nothing
End Sub


Public Function GetLocalizationString(ByVal Key As String) As String
    Dim ws As Worksheet
    Set ws = LocalizationSheet
    If Not ws Is Nothing Then
        Dim found As Range
        Dim row As Long
        row = -1
        Set found = ws.Columns(1).Find(what:=Key, _
                     LookAt:=xlWhole, _
                    SearchDirection:=xlPrevious, _
                    SearchOrder:=xlByRows)
        If (Not found Is Nothing) Then
            row = found.row
        End If
        If (row > 0) Then
            GetLocalizationString = ws.cells(row, 2).Value
        Else
            GetLocalizationString = "Localization string not found for key: " & Key
        End If
    End If
End Function
Attribute VB_Name = "STEPLogger"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Private Const C_LEVEL = 1
Private Const C_TIME = 2
Private Const C_SOURCE = 3
Private Const C_MSG = 4

Private Const C_SHEET_NAME = "STEPLogging"
Private Function GetSTEPLogSheet() As Worksheet
    Dim ws As Worksheet
    On Error Resume Next
    Set ws = ThisWorkbook.Worksheets(C_SHEET_NAME)
    If ws Is Nothing Then
        Dim asu As Boolean
        asu = ThisWorkbook.Application.ScreenUpdating
        On Error GoTo CREATE_ERROR
        ThisWorkbook.Application.ScreenUpdating = False
        Set ws = ThisWorkbook.Worksheets.Add
        ws.Name = C_SHEET_NAME
        ws.Visible = xlSheetVeryHidden
        ws.cells(1, C_LEVEL).Value = "LEVEL"
        ws.cells(1, C_TIME).Value = "TIME"
        ws.cells(1, C_SOURCE).Value = "SOURCE"
        ws.cells(1, C_MSG).Value = "MESSAGE"
CREATE_ERROR:
        ThisWorkbook.Application.ScreenUpdating = asu
    End If
    Set GetSTEPLogSheet = ws
End Function

Private Function GetTime()
    Dim dt As Date
    dt = Now
    GetTime = Year(dt) & "-" & Month(dt) & "-" & Day(dt) & " " & Hour(dt) & ":" & Minute(dt) & ":" & Second(dt)
End Function

Private Sub log(ByVal level As String, ByVal Source As String, ByVal msg As String)
    Dim actsheet As Worksheet
    Set actsheet = ThisWorkbook.Application.ActiveSheet
    Dim su As New STEPSheetUtils
    Dim ls As Worksheet
    Dim ea As Boolean
    On Error GoTo LOG_ERR
    ea = ThisWorkbook.Application.EnableEvents
    ThisWorkbook.Application.EnableEvents = False
    Set ls = GetSTEPLogSheet
    Dim row As Long
    row = 1 + su.GetLastRow(ls, C_LEVEL)
    ls.cells(row, C_LEVEL).Value = level
    ls.cells(row, C_TIME).numberFormat = "@"
    ls.cells(row, C_TIME).Value = GetTime
    ls.cells(row, C_SOURCE).Value = Source
    ls.cells(row, C_MSG).Value = msg
    
    actsheet.Activate
LOG_ERR:
    ThisWorkbook.Application.EnableEvents = ea
    err.Clear
End Sub



Public Sub info(ByVal Source As String, ByVal msg As String)
    log "INFO", Source, msg
End Sub

Public Sub Warning(ByVal Source As String, ByVal msg As String)
    log "WARNING", Source, msg
End Sub


Public Sub Severe(ByVal Source As String, ByVal msg As String)
    log "SEVERE", Source, msg
End Sub
Attribute VB_Name = "STEPLoginForm"
Attribute VB_Base = "0{DA7D7457-7E11-4375-8DC0-8D2616067DA7}{6CAA01A8-FFA6-43E2-B417-CE9981730EE6}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False








Option Explicit
Private mStepUser
Private tokenKey
Private token
Private currentStepUrl
Private Const SERVER_FAIL_CODES = "12003,12007,12028,12029,12030,12031"
Private Const LAST_SERVER_FAIL_CODE = 12031
Private serverFailCodes As New Collection
Private mLocale As New STEPLocalization
#If Mac Then
  Private Const mcFontSize As Long = 10
#Else
  Private Const mcFontSize As Long = 8
#End If

Private Sub CancelButton_Click()
    Me.Hide
End Sub

Private Sub UserForm_Initialize()
    Dim utils As New STEPSheetUtils
    Set mStepUser = Nothing
    currentStepUrl = ""
    Me.Caption = mLocale.GetLocalizationString("LoginFormTitle")
    lblUserName.Caption = mLocale.GetLocalizationString("LoginFormLogin")
    Label1.Caption = mLocale.GetLocalizationString("LoginFormPassword")
    txPassword.Font.size = mcFontSize
    txUsername.Font.size = mcFontSize
    lblUserName.Font.size = mcFontSize
    Label1.Font.size = mcFontSize
    CancelButton.Font.size = mcFontSize
    CancelButton.Caption = mLocale.GetLocalizationString("LoginFormCancel")
    LoginButton.Font.size = mcFontSize
    LoginButton.Caption = mLocale.GetLocalizationString("LoginFormOk")
    Me.BackColor = CancelButton.BackColor
    #If Mac Then
        Me.Width = 285
        txPassword.Height = 21
        txPassword.Left = 57
        txUsername.Height = 21
        txUsername.Left = 57
        Label1.Width = 51
        lblUserName.Width = 51
    #End If
End Sub


Public Function GetUser(ByRef pStepUser As STEPUser) As Boolean
    GetUser = False
    Set pStepUser = Nothing

    Dim lUtils As STEPSheetUtils

    If (mStepUser Is Nothing) Then
        txPassword.Text = ""
        txUsername.Text = ""
        Set lUtils = New STEPSheetUtils
        If Not lUtils.HasSTEPServerUrl Then
            MsgBox mLocale.GetLocalizationString("LoginFormSTEPServerMissing"), vbOKOnly, Me.Caption
            Set lUtils = Nothing
            Exit Function
        End If
        If (lUtils.GetAuthenticationMethod() = "SSO") Then
            Dim urlIndex As Integer
            urlIndex = 0
            ' if the currentStepUrl is set, we want to try that one first,
            ' and we set back the index to -1, so that we always start from
            ' the first possible server in case of connection errors
            If (currentStepUrl = "") Then
                currentStepUrl = GetUrl(urlIndex)
                urlIndex = -1
            End If

            txPassword.Enabled = False
            txPassword.BackColor = CancelButton.BackColor
            txUsername.Text = "Single SignOn User"
            txUsername.BackColor = CancelButton.BackColor
            txUsername.Enabled = False
            Do
                Dim xmlhttp As STEPXmlHttp
                Set xmlhttp = New STEPXmlHttp
                xmlhttp.Init currentStepUrl & "/sheet/sso/generatekey"
                If (Not xmlhttp.PostText("")) Then
                    If (IsServerFailCode(xmlhttp.statusCode)) Then
                        urlIndex = urlIndex + 1
                        currentStepUrl = GetUrl(urlIndex)
                    Else
                        MsgBox "Failed to connect to STEP server" & vbNewLine & "for authentication key request" & vbNewLine & "Cannot Login", vbOKOnly, Me.Caption
                        Set lUtils = Nothing
                        Exit Function
                    End If
                End If
            Loop While (IsServerFailCode(xmlhttp.statusCode) And Not currentStepUrl = "")
            Dim WebLink As String
            If (currentStepUrl = "") Then
                MsgBox mLocale.GetLocalizationString("LoginFormNoneAccessible"), vbOKOnly
                Exit Function
            End If
            tokenKey = xmlhttp.ResponseXML.getElementsByTagName("Key").Item(1).children().Item(1).NodeText()
            WebLink = currentStepUrl & "/sheet/sso/userauthentication?key=" & tokenKey
            ActiveWorkbook.FollowHyperlink WebLink, , True, False
        End If
        Set lUtils = Nothing
        #If Mac Then
            Me.Show vbModeless
        #Else
            Me.Show vbModal
        #End If
    End If

    If (Not mStepUser Is Nothing) Then
        If (Len(mStepUser.username) > 0 And (Len(mStepUser.password) Or Len(mStepUser.token) > 0)) Then
            GetUser = True
            Set pStepUser = mStepUser
        End If
    End If
End Function



Private Sub LoginButton_Click()
     If (Len(txUsername.Text) = 0) Then
        MsgBox mLocale.GetLocalizationString("LoginFormUsernameRequired"), vbOKOnly, Me.Caption
        txUsername.SetFocus
        Exit Sub
    End If

    Dim mUtils As New STEPSheetUtils

    If (Len(txPassword.Text) = 0 And Not mUtils.GetAuthenticationMethod = "SSO") Then
        MsgBox mLocale.GetLocalizationString("LoginFormPasswordRequired"), vbOKOnly, Me.Caption
        txPassword.SetFocus
        Exit Sub
    End If


    Dim requestUtils As New STEPRequestUtils
    Dim requestBuilder As New STEPRequestBuilder


    requestBuilder.InitRequest mUtils.STEPContext, mUtils.STEPWorkspace

    Dim requestdom As Object
    Dim stepHttp As STEPXmlHttp
    Dim loginUrl As String
    Dim urlIndex As Integer
    urlIndex = 0

    ' if the currentStepUrl is set, we want to try that one first,
    ' and we set back the index to -1, so that we always start from
    ' the first possible server in case of connection errors
    If (currentStepUrl = "") Then
        currentStepUrl = GetUrl(urlIndex)
        urlIndex = -1
    End If

    Set mStepUser = New STEPUser
    mStepUser.username = txUsername.Text
    If (mUtils.GetAuthenticationMethod = "SSO") Then
        Do
            Dim authHttp As STEPXmlHttp
            Set authHttp = New STEPXmlHttp
            authHttp.Init currentStepUrl & "/sheet/sso/tokenrequest?key=" & tokenKey
            If (authHttp.PostText("")) Then
                token = authHttp.ResponseXML.Xml
                mStepUser.username = Split(token, ":")(0)
                mStepUser.token = Split(token, ":")(1)
            Else
                If ("403" = authHttp.statusCode Or "401" = authHttp.statusCode) Then
                    MsgBox mLocale.GetLocalizationString("LoginFormFailedToken"), vbOKOnly, Me.Caption
                    Set mStepUser = Nothing
                    Exit Sub
                ElseIf (IsServerFailCode(authHttp.statusCode)) Then
                    urlIndex = urlIndex + 1
                    currentStepUrl = GetUrl(urlIndex)
                Else
                    MsgBox (authHttp.ErrorDescription), vbOKOnly, Me.Caption
                    Exit Sub
                End If
            End If
        Loop While (IsServerFailCode(authHttp.statusCode) And Not currentStepUrl = "")
        If (IsServerFailCode(authHttp.statusCode) And currentStepUrl = "") Then
            MsgBox mLocale.GetLocalizationString("LoginFormNoneAccessible") & vbNewLine & stepHttp.ErrorDescription, vbOKOnly
            Exit Sub
        End If
    End If

    loginUrl = requestUtils.STEPLoginURL(currentStepUrl)
    Do
        Set stepHttp = New STEPXmlHttp
        stepHttp.Init loginUrl, username:=mStepUser.username, password:=txPassword.Text, timeout:=-1, token:=mStepUser.token
        Set requestdom = requestBuilder.GetXML
        If (stepHttp.PostXML(requestdom)) Then
            mStepUser.password = txPassword.Text
            Me.Hide
        Else
            If ("403" = stepHttp.statusCode Or "401" = stepHttp.statusCode) Then
                Set mStepUser = Nothing
                If (mUtils.GetAuthenticationMethod = "SSO") Then
                    MsgBox (mLocale.GetLocalizationString("LoginFormFailedToken")), vbOKOnly, Me.Caption
                Else
                    MsgBox (mLocale.GetLocalizationString("LoginFormInvalid")), vbOKOnly, Me.Caption
                End If
            ElseIf (IsServerFailCode(stepHttp.statusCode)) Then
                urlIndex = urlIndex + 1
                currentStepUrl = GetUrl(urlIndex)
            Else
                MsgBox (stepHttp.ErrorDescription), vbOKOnly, Me.Caption
            End If
        End If
    Loop While (IsServerFailCode(stepHttp.statusCode) And Not currentStepUrl = "")
    
    If (IsServerFailCode(stepHttp.statusCode) And currentStepUrl = "") Then
        Set mStepUser = Nothing
        MsgBox (stepHttp.ErrorDescription), vbOKOnly, Me.Caption
    End If
End Sub


Private Function IsServerFailCode(statusCode As String) As Boolean
    IsServerFailCode = False
    
    If (statusCode = "") Then
        Exit Function
    Else
        Dim code As Variant
        For Each code In Split(SERVER_FAIL_CODES, ",")
            If (code = statusCode) Then
                IsServerFailCode = True
                Exit Function
            End If
        Next
    End If
End Function


Public Property Get CurrentSTEPServerURL()
    CurrentSTEPServerURL = currentStepUrl
End Property


Private Function GetUrl(Index As Integer)
    Dim mUtils As New STEPSheetUtils
    If (UBound(mUtils.GetSTEPServerURLCollection()) < Index) Then
        GetUrl = ""
    Else
        GetUrl = mUtils.GetSTEPServerURLCollection()(Index)
    End If
End Function

Attribute VB_Name = "STEPLovUtils"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Private Const C_SHEET_NAME = "STEPLov"
Private Const C_NAME_PREFIX = "STEP_LOV_"
Private mSheet As Worksheet
Private mUtils As STEPSheetUtils
Private mLocale As New STEPLocalization

Public Property Get LovSheet() As Worksheet
    If (mSheet Is Nothing) Then
        On Error Resume Next
        Set mSheet = ThisWorkbook.Worksheets(C_SHEET_NAME)

    End If
    Set LovSheet = mSheet
End Property

Private Sub Class_Initialize()
    Set mSheet = Nothing
    Set mUtils = New STEPSheetUtils
End Sub

Public Sub ApplyLovs()
    If (mUtils.LovsApplied) Then
       Exit Sub
    End If
    On Error GoTo APPLY_ERR
    ThisWorkbook.Application.EnableEvents = False
    DefineNames

    Dim IsInitiateWorkbook As Boolean
    IsInitiateWorkbook = mUtils.IsInitiateWorkbook()
    Dim protected As Boolean
    Dim ws As Worksheet
    Dim Index As Integer, col As Long
    Dim isLovApplied As Boolean
    Dim sl As New STEPLogger
    isLovApplied = True

    For Index = 1 To ThisWorkbook.Worksheets.Count
        Set ws = ThisWorkbook.Worksheets(Index)
        If (mUtils.IsProductsSheet(ws)) Then
            protected = ws.ProtectContents
            mUtils.UnProtectSheet ws
            ws.cells.Validation.Delete
            For col = 2 To mUtils.GetLastCol(ws, mUtils.ColumnTypeRowIndex)
                If (mUtils.IsColumnReadOnly(ws, col)) Then
                    'just skip r-o
                ElseIf (mUtils.HasColumnLov(ws, col)) Then
                    Dim lovName As String
                    Dim attributeName As String
                    Dim LOVIdentifier As String
                    attributeName = ws.cells(mUtils.ColumnIDRowIndex, col).Value
                    LOVIdentifier = mUtils.ColumnLOVIdentifier(ws, col)
                    lovName = AttributeToLovName(LOVIdentifier)
                    If Not lovName = "" Then
                        Dim n As Name
                        Set n = GetExcelName(lovName)

                        If (Not n Is Nothing) Then
                            'we need to find a way to handle multivalued hard lov
                            If (mUtils.IsColumnMultivalued(ws, col)) Then
                            Else
                                Dim FirstProductRow As Integer
                                FirstProductRow = mUtils.FirstProductRow(ws, False)
                                Dim r As Range
                                If (mUtils.HasExtendedSettingsSheet) Then
                                    Set r = ws.Range(ws.cells(FirstProductRow, col), ws.cells(mUtils.GetLastRow(ws, 1), col))
                                Else
                                    If (mUtils.IsInitiateWorkbook) Then
                                        Set r = ws.Range(ws.cells(FirstProductRow, col), ws.cells(mUtils.LastInitiateRow(ws), col))
                                    Else
                                        Set r = ws.Range(ws.cells(FirstProductRow, col), ws.cells(mUtils.GetLastRow(ws, 2), col))
                                    End If
                                End If

                                   With r.Validation
                                        .Delete
                                        .Add Type:=xlValidateList, AlertStyle:=xlValidAlertStop, Operator:= _
                                                xlBetween, Formula1:="=" & lovName
                                        'on medium lov just accept new values
                                        .ShowError = IsHardLOV(LOVIdentifier)
                                    End With

                            End If
                        Else
                            sl.Severe "STEPLovUtils.ApplyLovs", "Error loading LOV sheet (lov name " & lovName & ")"
                            isLovApplied = False
                        End If
                    End If
                End If

            Next
            If (protected) Then
                mUtils.ProtectSheet ws
                protected = False
            End If
        End If

    Next
    If (isLovApplied) Then
        mUtils.LovsApplied = True
    Else
        MsgBox (mLocale.GetLocalizationString("STEPLovUtilsLookupNotApplied"))
        mUtils.LovsApplied = False
    End If
RESUME_AFTER_ERR:
If (Not ws Is Nothing And protected) Then
    mUtils.ProtectSheet ws
End If
ThisWorkbook.Application.EnableEvents = True
Exit Sub
APPLY_ERR:
    sl.Severe "STEPLovUtils.ApplyLovs", err.Number & " " & err.Description
    MsgBox (mLocale.GetLocalizationString("STEPLovUtilsErrorApplying"))
    Resume RESUME_AFTER_ERR
End Sub

Public Sub DefineNames()
    Dim ws As Worksheet
    Set ws = LovSheet
    If Not ws Is Nothing Then
        Dim mUtils As New STEPSheetUtils
        Dim row As Long
        Dim lastRow As Long
        lastRow = mUtils.GetLastRow(ws, 1)
        For row = 1 To lastRow
            Dim lovName As String
            lovName = AttributeToLovName(ws.cells(row, 1).Value)
            Dim excelName As Name
            Set excelName = GetExcelName(lovName)
            If (Not excelName Is Nothing) Then
                excelName.Delete
            End If
                Dim col As Long
                col = mUtils.GetLastCol(ws, row)
                ThisWorkbook.Names.Add lovName, ws.Range(ws.cells(row, 3), ws.cells(row, col))

        Next
    End If
End Sub

Public Function IsHardLOV(ByVal attributeID As String) As Boolean
    IsHardLOV = False
    Dim ws As Worksheet
    Set ws = LovSheet
    If Not ws Is Nothing Then
        Dim found As Range
        Dim row As Long
        row = -1
        Set found = ws.Columns(1).Find(what:=attributeID, _
                                        LookAt:=xlPart, _
                    SearchDirection:=xlPrevious, _
                    SearchOrder:=xlByRows)
        If (Not found Is Nothing) Then
            row = found.row
        End If
        If (row > 0) Then
            IsHardLOV = CBool(ws.cells(row, 2).Value)
        End If
    End If
End Function

Public Function GetExcelName(ByVal lovName As String) As Name
    Dim res As Name
    Set res = Nothing
    On Error Resume Next
    If (lovName = "") Then
        Set GetExcelName = Nothing
        Exit Function
    End If
    Set res = ThisWorkbook.Names(lovName)
    err.Clear
    Set GetExcelName = res
End Function

Public Function GetLovValues(ByVal lovName As String)
    Dim nam As Name
    Dim res() As String
    Set nam = Me.GetExcelName(lovName)
    If (nam Is Nothing) Then
        GetLovValues = vbEmpty
    Else
        ReDim res(nam.RefersToRange.Count - 1) As String
        Dim i As Integer
        For i = LBound(res) To UBound(res)
            res(i) = nam.RefersToRange(1, 1 + i)
        Next i
        GetLovValues = res
    End If
End Function

Public Sub AddLovValues(ByVal lovName As String, ByRef newValues() As String)
    Dim att As String
    Dim found As Range
    Dim lovRow As Long, col As Long, i As Integer
    Dim ws As Worksheet
    Set ws = LovSheet
    Dim cmp As String, cmpArray
    Dim nv As String
    Dim extended As Boolean
    extended = False

    Dim mUtil As New STEPSheetUtils
    If (Not IsArray(newValues) Or IsEmpty(newValues)) Then
        Exit Sub
    End If
    att = Me.LovNameToAttribute(lovName)
    If (att = "") Then
        Exit Sub
    End If
    Set found = ws.Columns(1).Find(what:=att, _
        after:=mSheet.cells(1, 1), _
        LookAt:=xlWhole, _
        SearchDirection:=xlNext, _
        SearchOrder:=xlByRows)
    If (Not found Is Nothing) Then
        cmpArray = Me.GetLovValues(lovName)
        If (IsArray(cmpArray) And Not IsEmpty(cmpArray)) Then
            cmp = vbTab & Join(cmpArray, vbTab) & vbTab
        Else
            cmp = ""
        End If
        lovRow = found.row
        col = mUtil.GetLastCol(ws, lovRow)
        For i = LBound(newValues) To UBound(newValues)
            nv = VBA.Trim(newValues(i))
            If (nv <> "" And InStr(cmp, vbTab & nv & vbTab) < 1) Then
                col = col + 1
                ws.cells(lovRow, col).Value = nv
                extended = True
            End If
        Next

    End If
     mUtils.UnmarkMatchEntireCellContents

    If (extended) Then
        Dim nam As Name
        Set nam = GetExcelName(lovName)
        If (Not nam Is Nothing) Then
            'nam.RefersToRange.Resize(1, col - 3).name = lovName
        'Else
            nam.Delete
            ThisWorkbook.Names.Add lovName, ws.Range(ws.cells(lovRow, 3), ws.cells(lovRow, col))
        End If

    End If
End Sub

Public Function LovNameToAttribute(ByVal lovName As String) As String
    LovNameToAttribute = ""
    Dim ws As Worksheet
    Set ws = Me.LovSheet
    If ((Not ws Is Nothing) And InStr(1, lovName, C_NAME_PREFIX, vbBinaryCompare) = 1) Then
        Dim r As Long
        r = CLng(VBA.mID(lovName, 1 + Len(C_NAME_PREFIX)))
        LovNameToAttribute = Me.LovSheet.cells(r, 1).Value
    End If
End Function

Public Function AttributeToLovName(ByVal attname As String)
    Dim found As Range
    Dim row As Long
    AttributeToLovName = ""
    Dim ws As Worksheet
    Set ws = LovSheet
    If Not ws Is Nothing Then
        Set found = ws.Columns(1).Find(what:=attname, _
            after:=mSheet.cells(1, 1), _
            LookAt:=xlWhole, _
            SearchDirection:=xlNext, _
            MatchCase:=True, _
            SearchOrder:=xlByRows)
        If (Not found Is Nothing) Then
            AttributeToLovName = C_NAME_PREFIX & VBA.Format(found.row, "000")
        End If
    End If
End Function

Attribute VB_Name = "STEPModifiedObject"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public Enum ModifiedObjectType
    STEPModifiedValue = 1
    STEPModifiedMultiValue = 2
End Enum
    
    
Private mID As String
Private mObjectType As ModifiedObjectType
Private mValue As Variant
Private mCellAddress As String

Public Property Let id(ByVal Value As String)
    mID = Value
End Property

Public Property Get id() As String
    id = mID
End Property

Public Property Let ObjectType(ByVal pObjectType As ModifiedObjectType)
    mObjectType = pObjectType
End Property

Public Property Get ObjectType() As ModifiedObjectType
    ObjectType = mObjectType
End Property

Public Property Let ModifiedValue(pModifiedValue As Variant)
    mValue = pModifiedValue
End Property

Public Property Get ModifiedValue() As Variant
    ModifiedValue = mValue
End Property

Public Property Get ModifiedValueDisplay() As String
    ModifiedValueDisplay = ""
    If (ObjectType = STEPModifiedValue) Then
        If Not IsEmpty(mValue) Then
            ModifiedValueDisplay = mValue
        End If
    ElseIf (ObjectType = STEPModifiedMultiValue) Then
        If (IsArray(mValue)) Then
            Dim sUtils As STEPSheetUtils
            Set sUtils = New STEPSheetUtils
            Dim sa() As String
            sa = mValue
            ModifiedValueDisplay = sUtils.JoinMultivalue(sa)
        End If
    End If
End Property

Public Property Let CellAddress(ByVal pCellAddress As String)
    mCellAddress = pCellAddress
End Property

Public Property Get CellAddress() As String
    CellAddress = mCellAddress
End Property
Attribute VB_Name = "STEPNodePicker"
Attribute VB_Base = "0{CA18881E-2C6C-4534-9FCF-0CE86FED0EDF}{236A4CFD-2C72-4610-A3DA-166D4B97FCD5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False












Option Explicit
Option Base 0
Private LOADING_MESSAGE As String
Private Const SELECTABLE_PREFIX = "S_"
Private Const UNSELECTABLE_PREFIX = "N_"
Private NOTHING_FOUND As String
Private Const CHILD_PREFIX = "C_"
Private Const TAB_SEARCH = 0
Private Const TAB_BROWSE = 1

Private WithEvents mTree As clsTreeView
Attribute mTree.VB_VarHelpID = -1

Private mHasBrowsed As Boolean
Private mResult()  As String
Private closeAction As FormAction
Private mReferenceType As STEPColumnType
Private mReferenceTypeId As String
Private mInitated As Boolean
Private mMultivalued As Boolean
Private Const C_ROOT_KEY = "[ROOT_KEY]"
Private mInitiateObjectType As String
Private mTopProductID As String
Private mIsSmartSheet As Boolean
Private mRowSupplierID As String
Private mLocale As New STEPLocalization
#If Mac Then
  Private Const mcFontSize As Long = 10
#Else
  Private Const mcFontSize As Long = 8
#End If

Public Enum FormAction
    OK = 1
    cancel = 2
    Undefined = 9
End Enum

Private Property Get Tree() As clsTreeView
If mTree Is Nothing Then
    Set mTree = New clsTreeView
    Set mTree.mynodepicker = Me
End If
Set Tree = mTree
End Property

Public Function Init(ByVal pCaption As String, _
                     ByVal rt As STEPColumnType, _
                     ByVal rtId As String, _
                     ByVal multiValued As Boolean, _
                     ByVal pRowSupplierID As String, _
                     ByRef currentValues() As String)
    InitateObjectTypeID = ""
    mIsSmartSheet = False
    LOADING_MESSAGE = mLocale.GetLocalizationString("NodePickerLoading")
    NOTHING_FOUND = mLocale.GetLocalizationString("NodePickerNoMatches")
    Label1.Caption = mLocale.GetLocalizationString("NodePickerSelected")
    cmdOK.Caption = mLocale.GetLocalizationString("NodePickerOk")
    cmdCancel.Caption = mLocale.GetLocalizationString("NodePickerCancel")
    Dim lUtils As STEPSheetUtils
    Set lUtils = New STEPSheetUtils
    mIsSmartSheet = lUtils.HasExtendedSettingsSheet
    Set lUtils = Nothing
    mReferenceType = rt
    mReferenceTypeId = rtId
    Dim mStepUser As STEPUser
    Set mStepUser = Nothing
    STEPLoginForm.GetUser mStepUser
    ReDim mResult(0) As String
    closeAction = FormAction.Undefined
    Me.Caption = pCaption
    mHasBrowsed = False
    txSearch.Font.size = mcFontSize
    frTreeControl.Font.size = mcFontSize
    lstSearchRes.Font.size = mcFontSize
    lstSearchRes.ColumnWidths = "500 pt"
    lstSelected.Font.size = mcFontSize
    lstSelected.ColumnWidths = "500 pt"
    ts.Font.size = mcFontSize
    Label1.Font.size = mcFontSize
    cmdSearch.Font.size = mcFontSize
    cmdCancel.Font.size = mcFontSize
    cmdOK.Font.size = mcFontSize
    cmdAdd.Font.size = mcFontSize
    cmdRemove.Font.size = mcFontSize
    Me.BackColor = cmdOK.BackColor
    #If Mac Then
        txSearch.Height = 21
    #End If
    If (Not mStepUser Is Nothing) Then
        ts.Value = TAB_SEARCH
        ts_Change
        ts.Tabs(TAB_SEARCH).Caption = mLocale.GetLocalizationString("NodePickerSearch")
        ts.Tabs(TAB_BROWSE).Caption = mLocale.GetLocalizationString("NodePickerBrowse")
        lstSearchRes.Clear
        cmdAdd.Visible = multiValued
        cmdRemove.Visible = multiValued
        lstSelected.Visible = multiValued
        mMultivalued = multiValued
        If (multiValued) Then
            lstSearchRes.MultiSelect = MSForms.fmMultiSelectExtended
            lstSelected.Clear
            lstSelected.Height = ts.top + ts.Height - lstSelected.top
            Me.Width = 442.5
            Dim i As Integer
            For i = LBound(currentValues) To UBound(currentValues)
                If (VBA.Trim(currentValues(i)) <> "") Then
                    lstSelected.AddItem currentValues(i)
                End If
            Next
            cmdOK.Left = cmdAdd.Left + cmdAdd.Width / 2 + 8
            cmdCancel.Left = cmdOK.Left - 16 - cmdCancel.Width
        Else
            Me.Width = 244
            ts.Width = 230
            frTreeControl.Width = 216
            lstSearchRes.MultiSelect = MSForms.fmMultiSelectSingle
            lstSearchRes.Width = frTreeControl.Width
            cmdSearch.Left = lstSearchRes.Left + lstSearchRes.Width - cmdSearch.Width
            cmdOK.Left = Me.Width / 2 + 8
            cmdCancel.Left = cmdOK.Left - 16 - cmdCancel.Width
            txSearch.Width = cmdSearch.Left - 8 - txSearch.Left
        End If

        With Tree
            '.LineStyle = tvwTreeLines
            '.Nodes.Add Key:=C_ROOT_KEY, Text:=LOADING_MESSAGE
            Dim cRoot As clsNode
            Set .TreeControl = Me.frTreeControl

            Call .NodesClear

            .AppName = Me.Name

        'Set some characteristics of the root of the tree,
        'which for this demo we pick up from checkbox and spinner controls on the form


        ' add a Root node and make it bold
            Set cRoot = .AddRoot(sKey:=C_ROOT_KEY, vCaption:=LOADING_MESSAGE)
            cRoot.Bold = True

           .Refresh ' note .PopulateTree is deprecated and replaced with Refresh
        End With
        mInitated = True
    End If
    mRowSupplierID = pRowSupplierID
    Init = mInitated
End Function

Public Property Let InitateObjectTypeID(ByVal objectTypeID As String)
    mInitiateObjectType = objectTypeID
End Property

Public Property Get InitateObjectTypeID() As String
    InitateObjectTypeID = mInitiateObjectType
End Property

Public Property Let TopProductID(ByVal pTopProductID As String)
    mTopProductID = pTopProductID
End Property

Public Property Get TopProductID() As String
    TopProductID = mTopProductID
End Property

Public Function Run() As FormAction
    closeAction = Undefined
    If (mInitated) Then
         Me.Show vbModal
    End If
    Run = closeAction
End Function

Public Function GetResult() As String
    GetResult = mResult(0)
End Function

Public Function getResultList() As String()
    getResultList = mResult
End Function

Public Function getCloseAction()
    getCloseAction = closeAction
End Function

Private Property Get IsBrowsing() As Boolean
    If (ts.Value = TAB_BROWSE) Then
        IsBrowsing = True
    Else
        IsBrowsing = False
    End If

End Property

Private Sub cmdCancel_Click()
    ReDim mResult(0)
    closeAction = FormAction.cancel
    Me.Hide
End Sub

Private Sub cmdAdd_Click()
    If (IsBrowsing) Then
        If (Not Tree.ActiveNode Is Nothing) Then
            If (Tree.ActiveNode.Key <> C_ROOT_KEY) Then
                If (Len(Tree.ActiveNode.Key) < Len(SELECTABLE_PREFIX)) Then
                    Exit Sub
                End If
                If (VBA.mID(Tree.ActiveNode.Key, 1, Len(SELECTABLE_PREFIX)) <> SELECTABLE_PREFIX) Then
                    Exit Sub
                End If

                AddToSelected Tree.ActiveNode.Caption
            End If
        End If
    Else
        Dim i As Integer
        For i = 0 To lstSearchRes.ListCount - 1
            Dim txt As String
            If (lstSearchRes.Selected(i)) Then
                txt = lstSearchRes.List(i)
                If (txt <> NOTHING_FOUND) Then
                    AddToSelected txt
                End If
                lstSearchRes.Selected(i) = False
            End If
        Next
    End If
End Sub

Private Sub AddToSelected(ByVal pItem As String)
    Dim i As Integer
    For i = 0 To lstSelected.ListCount - 1
        If (pItem = lstSelected.List(i)) Then
            Exit Sub
        End If
    Next
    lstSelected.AddItem pItem

End Sub

Private Sub cmdRemove_Click()
    Dim i As Integer
    For i = lstSelected.ListCount - 1 To 0 Step -1
        If (lstSelected.Selected(i)) Then
            lstSelected.RemoveItem i
        End If
    Next
End Sub


Private Sub cmdSearch_Click()
    queryNodes txSearch.Text
End Sub

Private Sub CommandButton1_Click()
    If (frTreeControl.Left < 0) Then
        frTreeControl.Left = 4
    Else
        frTreeControl.Left = -1000
    End If
End Sub

'ONEKING-218 FIX
Private Sub cmdOK_Click()
    Dim i As Integer
    If (mMultivalued) Then
        If (lstSelected.ListCount > 0) Then
            ReDim mResult(lstSelected.ListCount - 1)
        Else
            mResult(0) = ""
        End If
        For i = 0 To lstSelected.ListCount - 1
            mResult(i) = lstSelected.List(i)
        Next
    Else
        ReDim mResult(0) As String
        If (IsBrowsing) Then
            If (Tree.ActiveNode Is Nothing) Then
                Exit Sub
            End If
            If (C_ROOT_KEY = Tree.ActiveNode.Key) Then
                Exit Sub
            End If
            If (VBA.mID(Tree.ActiveNode.Key, 1, Len(SELECTABLE_PREFIX)) <> SELECTABLE_PREFIX) Then
                Exit Sub
            End If
            mResult(0) = Tree.ActiveNode.Caption
        Else
            For i = 0 To lstSearchRes.ListCount - 1
                If (lstSearchRes.Selected(i)) Then
                    mResult(0) = lstSearchRes.List(i)
                End If
            Next
            If (mResult(0) = "") Then
                Exit Sub
            End If
        End If
    End If
    closeAction = FormAction.OK
    Me.Hide
End Sub

Private Sub mp_Change()
    If (IsBrowsing) Then
        frTreeControl.Enabled = True
    Else
        cmdOK.DEFAULT = False
        cmdSearch.DEFAULT = True
        frTreeControl.Enabled = False
    End If
End Sub



Private Sub lstSearchRes_DblClick(ByVal cancel As MSForms.ReturnBoolean)
    If (mMultivalued) Then
        cmdAdd_Click
    Else
        cmdOK_Click
    End If
End Sub

Private Sub lstSelected_DblClick(ByVal cancel As MSForms.ReturnBoolean)
    cmdRemove_Click
End Sub

Public Sub mTree_DblClick()
    If (Not Tree.ActiveNode Is Nothing) Then
        If (mMultivalued) Then
            cmdAdd_Click
        Else
            cmdOK_Click
        End If
    End If
End Sub

Public Sub mTree_Expand(ByVal node As clsNode)
    If (node Is Nothing) Then Exit Sub
    If (node.ChildNodes.Count = 1) Then
        If (node.Child.Caption <> LOADING_MESSAGE) Then
            Exit Sub
        End If
        Dim nodeId As String
        nodeId = node.Key
        addNodes node, VBA.mID(nodeId, 3), False 'Node keys are prefixed with two chars because a key in a tree cannot be a number
    End If
End Sub

Private Sub queryNodes(ByVal expression As String)
    Dim getNodes As New STEPGetNodes
    Dim oDom As STEPXmlDom
    If (VBA.Trim(expression) = "") Then
        Exit Sub
    End If
    If (IsBrowsing) Then
        Exit Sub
    End If
    lstSearchRes.Clear
    On Error GoTo QUERY_ERROR
    Me.MousePointer = MSForms.fmMousePointerHourGlass
    Me.Repaint
    Set oDom = getNodes.SearchNodes(mReferenceType, _
                                    mReferenceTypeId, _
                                    expression, _
                                    initiateObjectType:=InitateObjectTypeID, _
                                    pTopProductID:=TopProductID)
    If (Not oDom Is Nothing) Then

        Dim Root As Object
        Set Root = oDom.DocumentElement

        If (Not Root Is Nothing) Then
            If (Root.ChildNodes.Count = 0) Then
                lstSearchRes.AddItem NOTHING_FOUND
            Else
                Dim i As Integer


                Dim rootNode As Object
                Dim childNode As Object

                For i = 1 To (Root.ChildNodes.Count)
                    Set childNode = Root.ChildNodes.Item(i)
                    Dim itemID As String, itemTEXT As String
                    itemID = childNode.getAttributeNode("ID").Value
                    itemTEXT = UnDoEscapeXmlValue(childNode.getAttributeNode("Title").Value)
                    lstSearchRes.AddItem itemTEXT
                Next i
            End If
        End If

    Else
        lstSearchRes.Clear
        MsgBox (mLocale.GetLocalizationString("NodePickerErrorLoading")), vbOKOnly, Me.Caption
    End If

    Me.MousePointer = MSForms.fmMousePointerDefault
    Me.Repaint
    Exit Sub
QUERY_ERROR:
    Me.MousePointer = MSForms.fmMousePointerDefault
    MsgBox err.Description
    err.Clear
End Sub

Public Sub addNodes(node As clsNode, parentId As String, rootcall As Boolean)
    Dim getCN As New STEPGetNodes
    Dim oDom As Object
    If (Not IsBrowsing) Then
        Exit Sub
    End If
    Me.MousePointer = MSForms.fmMousePointerHourGlass

    If (Not node.Expanded) Then
        node.Expanded = True
    End If

    Dim lIncludeParent As Boolean
    lIncludeParent = False
    If (rootcall And mReferenceType = STEPParentID) Then
        lIncludeParent = mIsSmartSheet
    End If

    Set oDom = getCN.GetChildNodes(mReferenceType, _
                                   mReferenceTypeId, _
                                   parent:=parentId, _
                                   initiateObjectType:=InitateObjectTypeID, _
                                   includeParent:=lIncludeParent)
    If (Not oDom Is Nothing) Then
        On Error GoTo LOOP_ERR

        Dim Root As Object
        Set Root = oDom.DocumentElement

        If (Not Root Is Nothing) Then
            If (Root.ChildNodes.Count = 0) Then
                If (node.Index = 1) Then
                    node.Caption = "No nodes found"
                Else
                    If (node.ChildNodes.Count > 0) Then
                        Call Tree.NodeRemove(node.Child)
                        node.Expanded = False
                        Tree.Refresh
                    Else
                        node.Expanded = False
                        Tree.Refresh
                    End If
                End If
            Else
                Dim i As Integer

                'Remove the first child if it is a temporary "loading" node
                If (node.ChildNodes.Count > 0) Then
                    If (LOADING_MESSAGE = node.Child.Caption) Then
                        'Tree.Nodes.Remove (node.Index + 1)
                        Call Tree.NodeRemove(node.Child)
                        Tree.Refresh
                    End If
                End If


                Dim rootNode As Object
                Dim childNode As Object
                Dim newnode As clsNode
                Dim selectable As Boolean
                With Tree
                    If (Not Root.getAttributeNode("Title") Is Nothing And node.Index = 1) Then 'For the first node we change the "Loading" text to the title of the root node
                        node.Caption = UnDoEscapeXmlValue(Root.getAttributeNode("Title").Value)
                    End If

                    Dim folderAttribute As Object
                    Dim selectableAttribute As Object
                    For i = 1 To (Root.ChildNodes.Count)
                        Set childNode = Root.ChildNodes.Item(i)
                        Dim itemID As String, itemTEXT As String, newKey As String
                        itemID = childNode.getAttributeNode("ID").Value
                        itemTEXT = UnDoEscapeXmlValue(childNode.getAttributeNode("Title").Value)
                        Set selectableAttribute = childNode.getAttributeNode("IsSelectable")
                        selectable = False 'default
                        If (Not selectableAttribute Is Nothing) Then
                            If ("true" = selectableAttribute.Value) Then
                                selectable = True
                            End If
                        End If
                        If (selectable) Then
                            newKey = SELECTABLE_PREFIX & itemID
                        Else
                            newKey = UNSELECTABLE_PREFIX & itemID
                        End If
                        Set newnode = .NodeAdd(vRelative:=node.Key, vRelationship:=4, sKey:=newKey, vCaption:=itemTEXT)
                        node.Expanded = True
                        If (selectable) Then newnode.ForeColor = vbBlue
                        newnode.Bold = selectable
                        'ONEKING-218 fix
                        '-----------
                        newnode.Expanded = False
                        '-----------
                        Set folderAttribute = childNode.getAttributeNode("IsFolder")
                        If (Not folderAttribute Is Nothing) Then
                            If (folderAttribute.Value = "true") Then
                                Call .NodeAdd(vRelative:=newKey, vRelationship:=4, sKey:=CHILD_PREFIX & childNode.getAttributeNode("ID").Value, vCaption:=LOADING_MESSAGE)
                                If rootcall Then
                                    newnode.Expanded = False
                                End If
                            End If
                        End If
RESUME_NOT_UNIQUE:
                    Next
                End With
            End If
        End If

    Else
        Tree.Nodes.Clear
        MsgBox (mLocale.GetLocalizationString("NodePickerErrorLoadingTree")), vbOKOnly, Me.Caption
    End If

    Me.MousePointer = MSForms.fmMousePointerDefault
    Me.Repaint
    'ONEKING-218 fix
    '-------
    Set Tree.ActiveNode = node
    '-------
    Tree.Refresh
    Exit Sub

LOOP_ERR:
    If (err.Number = 35602) Then
        Resume RESUME_NOT_UNIQUE
    End If
    Me.MousePointer = MSForms.fmMousePointerDefault
    MsgBox (VBA.Error$)
End Sub

Private Sub ts_Change()
    If (IsBrowsing) Then
        frTreeControl.Enabled = True
        frTreeControl.Left = lstSearchRes.Left
        cmdSearch.Visible = False
        lstSearchRes.Visible = False
        txSearch.Visible = False
        cmdOK.DEFAULT = True
        cmdSearch.DEFAULT = False
        AutoBrowse
    Else
        frTreeControl.Enabled = False
        frTreeControl.Left = -1000
        cmdSearch.Visible = True
        lstSearchRes.Visible = True
        txSearch.Visible = True
        cmdOK.DEFAULT = False
        cmdSearch.DEFAULT = True
        txSearch.SetFocus
        txSearch.SelStart = 0
        txSearch.SelLength = Len(txSearch.Text)
    End If
End Sub


Private Sub AutoBrowse()
    If (mHasBrowsed) Then
        Exit Sub
    End If
    mHasBrowsed = True
    If (Tree.Nodes.Count = 1) Then
        If (Tree.Nodes.Item(1).Caption = LOADING_MESSAGE) Then
            Me.Repaint
            addNodes Tree.Nodes.Item(1), TopProductID, True
        End If
    End If
End Sub

Public Sub TerminateTree()
    On Error GoTo TT_ERROR
    If (Not mTree Is Nothing) Then
        mTree.TerminateTree
    End If
    Exit Sub
TT_ERROR:
    err.Clear
End Sub

Private Function UnDoEscapeXmlValue(ByVal strXMLValue As String) As String
    UnDoEscapeXmlValue = ThisWorkbook.unescapeXmlValue(strXMLValue)
End Function
Attribute VB_Name = "STEPNodeRequestBuilder"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Private oDom As STEPXmlDom
Private Root As STEPXmlNode
Private node As STEPXmlNode

'Request to server:
'attributes in [] are optional
'<Nodes Workspace="..." Context="..." ReferenceTypeId="..." ReferenceType="..." [Mac=true/false]>
'   <Node ID="..." [IncludeInResponse="true|false"]/>
'   [<Expression>...</Expression>] 'on query-action
'</Nodes>



Private Sub Clear()
    Set oDom = Nothing
    Set Root = Nothing
    Set node = Nothing
End Sub

Public Sub Init(ByVal Context As String, ByVal Workspace As String, ByVal referenceType As STEPColumnType, ByVal referenceTypeId As String)
    Clear
    Set oDom = New STEPXmlDom
    Dim pi As Object
    Set pi = oDom.createProcessingInstruction("xml", "version='1.0' encoding='UTF-8' ")
    oDom.async = False
    oDom.LoadXML "<Nodes></Nodes>"
    oDom.InsertBefore pi, oDom.DocumentElement
    Set Root = oDom.DocumentElement
    
    Dim rUtils As New STEPRequestUtils
    Dim refType As String
    refType = rUtils.ConvertToDomainReferenceType(referenceType)
    
    Root.SetAttribute "Context", Context
    Root.SetAttribute "Workspace", Workspace
    Root.SetAttribute "ReferenceType", refType
    Root.SetAttribute "ReferenceTypeId", referenceTypeId
#If Mac Then
    Root.SetAttribute "Mac", "true"
#End If
End Sub


Public Sub SetAttribute(Name As String, Value As String)
    If (Not Root Is Nothing) Then
        Root.SetAttribute Name, Value
    End If
End Sub

Public Sub AddQueryExpression(ByVal queryExpression As String)
    Dim exp As Object
    Set exp = oDom.createElement("Expression")
    Root.appendChild exp
    exp.appendChild oDom.createTextNode(queryExpression)

End Sub

Public Sub AddNode(ByVal nodeId As String, ByVal pInclude As Boolean)
    Set node = oDom.createElement("Node")
    node.SetAttribute "ID", nodeId
    If (pInclude) Then
        node.SetAttribute "IncludeInResponse", "true"
    End If
    Root.appendChild node
End Sub

'returns the constructed xml as text
Public Function GetText() As String
    GetText = oDom.Xml
End Function

Public Function GetXML() As STEPXmlDom
    Set GetXML = oDom
End Function

Private Sub Class_Terminate()
    Clear
End Sub
Attribute VB_Name = "STEPRequestBuilder"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Private oDom As STEPXmlDom
Private Root As Object
Private product As Object
Private classification As Object
Private values As Object
Private productidscollection As Collection

'Request to server:
'attributes in [] are optional
'<Products Workspace="..." Context="..." [SupplierGroup="..."] [Stateflow="..." State="..."] [Category="..."] [CreateTargetPrefix="..."] [CreateTargetType="..."] [CreateTargetParent="..."] [SmartSheet=true/false] [DecimalSeparator="..."] [Mac=true/false] [ImportConfiguration="..."] [BC1="..." - BCN="..."] [SmartSheetType="..."] [Annotation="..."] [CustomPlugin="..."] [CustomNodeTypes="true"] [CreateTargetSeparator="..."] [UseNCR="true/false"]>
'   <Product ID="..." [Initiate="true/false"] [ProductType="..."] [ParentID="..."] [Annotation="..."] [SupplierGroup="..."] [CellAddress="..."]>
'      <!-- all tags can have a [CellAddress="..."] attribute for better highligting on validation errors -->
'       <Name SourceLevel="..."  [SourceObjectType="..."] [CellAddress="..."] [Context="..."] [Annotation="..."]>...</Name>
'       <Reference ReferenceID="..." SourceLevel="..."  [SourceObjectType="..."] [CreateTarget="true"] [CellAddress="..."] [Context="..."] [Annotation="..."]> <!-- if CreateTarget exists and true id's in values is NOT checked for existense -->
'           <value>...</value>
'       </Reference>
'       <Link LinkID="..." SourceLevel="..."  [SourceObjectType="..."] [CreateTarget="true"] [CellAddress="..."] [Context="..."] [Annotation="..."]><!-- in cross-context smartsheets individual columns can contain values from different contexts -->
'           <value>...</value>
'       </Link>
'       <Batch [CellAddress="..."] [Annotation="..."]>
'           <value>...</value>
'       </Batch>
'       <Values>
'           <Value AttributeID="..." SourceLevel="..."  [SourceObjectType="..."] [CellAddress="..."] [Context="..."] [Annotation="..."] [BaseValidationType="..."] [CellStatus="hi|ro|io|ma"]>...</Value>
'           <MultiValue AttributeID="..." SourceLevel="..."  [SourceObjectType="..."] [CellAddress="..."] [Context="..."] [Annotation="..."] [BaseValidationType="..."] [CellStatus="hi|ro|io|ma"]>
'               <Value>...</Value>
'           </MultiValue>
'       </Values>
'   </Product>
'</Products>


Private Sub Clear()
    Set oDom = Nothing
    Set Root = Nothing
    Set product = Nothing
    Set values = Nothing
    Set productidscollection = Nothing
End Sub


Public Sub InitRequest(ByVal Context As String, ByVal Workspace As String, _
                Optional ByVal Stateflow As String = "", _
                Optional State As String = "", _
                Optional ByVal CategoryID As String = "", _
                Optional ByVal SupplierGroup As String = "", _
                Optional ByVal isSmartsheet As Boolean = False, _
                Optional ByVal SheetAnnotation As String = "")
    Dim lSheetUtils  As STEPSheetUtils
    Set lSheetUtils = New STEPSheetUtils
    Clear
    Set oDom = New STEPXmlDom
    Dim pi As STEPXmlNode
    Set pi = oDom.createProcessingInstruction("xml", "version='1.0' encoding='UTF-8' ")
    oDom.async = False
    oDom.LoadXML "<Products></Products>"
    oDom.InsertBefore pi, oDom.DocumentElement
    Set Root = oDom.DocumentElement
    Root.SetAttribute "Context", Context
    Root.SetAttribute "Workspace", Workspace
    If Len(CategoryID) > 0 Then
        Root.SetAttribute "Category", CategoryID
    End If
    If Len(Stateflow) > 0 And Len(State) > 0 Then
        Root.SetAttribute "Stateflow", Stateflow
        Root.SetAttribute "State", State
    End If
    If isSmartsheet Then
        Dim lMultiSupplier As Boolean
        lMultiSupplier = lSheetUtils.IsMultiSupplierSheet
        If (lMultiSupplier) Then
            Root.SetAttribute "MultiSupplier", "true"
            Dim lSeparator As String
            lSeparator = lSheetUtils.MultiSupplierCreateTargetSeparator
            If ("" <> lSeparator) Then
                Root.SetAttribute "CreateTargetSeparator", lSeparator
            End If
        Else
            'for multi-supplier these are individual on each row
            If Len(SupplierGroup) > 0 Then
                Root.SetAttribute "SupplierGroup", SupplierGroup
            End If
            Dim lTargetPrefix As String
            lTargetPrefix = lSheetUtils.GetCreateTargetPrefix
            If Len(lTargetPrefix) > 0 Then
                Root.SetAttribute "CreateTargetPrefix", lTargetPrefix
            End If
            Dim lTargetParent As String
            lTargetParent = lSheetUtils.GetCreateTargetParent
            If Len(lTargetParent) > 0 Then
                Root.SetAttribute "CreateTargetParent", lTargetParent
            End If
        End If
        Dim lTargetType As String
        lTargetType = lSheetUtils.GetCreateTargetType
        If Len(lTargetType) > 0 Then
            Root.SetAttribute "CreateTargetType", lTargetType
        End If
        If Len(SheetAnnotation) > 0 Then
            Root.SetAttribute "Annotation", SheetAnnotation
        End If
        Dim lcustomPlugin As String
        lcustomPlugin = lSheetUtils.SmartSheetCustomPlugin
        If Len(lcustomPlugin) > 0 Then
            Root.SetAttribute "CustomPlugin", lcustomPlugin
        End If
        If (lSheetUtils.SmartSheetCustomNodeTypes) Then
            Root.SetAttribute "CustomNodeTypes", "true"
        End If
        Root.SetAttribute "SmartSheet", "true"
        Dim lClientDecimalSeparator As String
        lClientDecimalSeparator = lSheetUtils.LastAppliedDecimalSeparator
        If ("" <> lClientDecimalSeparator) Then
            Root.SetAttribute "DecimalSeparator", lClientDecimalSeparator
        End If
        Dim lImportConfiguration As String
        lImportConfiguration = lSheetUtils.ImportConfiguration
        If ("" <> lImportConfiguration) Then
            Root.SetAttribute "ImportConfiguration", lImportConfiguration
        End If
        Dim lSheetTypeName As String
        lSheetTypeName = lSheetUtils.SmartSheetTypeName
        If ("" <> lSheetTypeName) Then
            Root.SetAttribute "SmartSheetType", lSheetTypeName
        End If
    Else
        If Len(SupplierGroup) > 0 Then
            Root.SetAttribute "SupplierGroup", SupplierGroup
        End If
        Root.SetAttribute "SmartSheet", "false"
    End If
    If (lSheetUtils.UseNCR) Then
        Root.SetAttribute "UseNCR", "true"
    End If
#If Mac Then
        Root.SetAttribute "Mac", "true"
#End If
    Set lSheetUtils = Nothing
    Set productidscollection = New Collection
End Sub

Public Sub AddProduct(ByVal productid As String, _
                      Optional ByVal inititate As Boolean = False, _
                      Optional ByVal producttype As String = "", _
                      Optional ByVal rowAnnotation As String = "", _
                      Optional ByVal rowSupplierInfo As STEPSupplierInfo = Nothing, _
                      Optional ByVal pCellAddr As String = "")
    Set product = oDom.createElement("Product")
    Set values = Nothing
    product.SetAttribute "ID", productid
    If (inititate) Then
        product.SetAttribute "Initiate", "true"
        If (Not rowSupplierInfo Is Nothing) Then
            'don't need to send CreateTargetParent and CreateTargetPrefix as we can freestyle them on validation (never mind the separator)
            product.SetAttribute "SupplierGroup", rowSupplierInfo.SupplierID
        End If
    End If
    If (Len(pCellAddr) > 0) Then
         product.SetAttribute "CellAddress", pCellAddr
    End If
    If (Len(producttype) > 0) Then
        product.SetAttribute "ProductType", producttype
    End If
    If (Len(rowAnnotation) > 0) Then
        product.SetAttribute "Annotation", rowAnnotation
    End If
    
    Root.appendChild product
    productidscollection.Add productid
End Sub

Public Property Get ProductCount() As Integer
    If (Not productidscollection Is Nothing) Then
        ProductCount = productidscollection.Count
    End If
End Property

Public Property Get productids() As String()
    Dim arr() As String
    If (Not productidscollection Is Nothing) Then
        If productidscollection.Count > 0 Then
            ReDim arr(1 To productidscollection.Count) As String
            Dim v, i As Integer
            i = 0
            For Each v In productidscollection
                i = i + 1
                arr(i) = v
            Next
            
        End If
    End If
    productids = arr
End Property


Public Sub SetProductParentID(ByVal parentId As String)
    product.SetAttribute "ParentID", parentId
End Sub

Public Sub SetProductName(ByVal pname As String, ByVal sourceObjectType As String, ByVal sourceLevel As Integer, ByVal pCellAddr As String, ByVal pContextID As String, ByVal pAnnotation As String)
    Dim node As STEPXmlNode
    Set node = oDom.createElement("Name")
    If (sourceObjectType <> "") Then
        node.SetAttribute "SourceObjectType", sourceObjectType
    End If
    If (pCellAddr <> "") Then
        node.SetAttribute "CellAddress", pCellAddr
    End If
    If (pContextID <> "") Then
        node.SetAttribute "Context", pContextID
    End If
    If (pAnnotation <> "") Then
        node.SetAttribute "Annotation", pAnnotation
    End If
    node.SetAttribute "SourceLevel", CStr(sourceLevel)
    product.appendChild node
    node.appendChild oDom.createTextNode(pname)
End Sub

Private Sub EnsureValues()
    If (values Is Nothing) Then
        Set values = oDom.createElement("Values")
        product.appendChild values
    End If

End Sub


Public Sub AddValue(ByVal attibuteID As String, ByVal attributeValue As String, _
                    ByVal sourceObjectType As String, ByVal useLOVID As String, ByVal sourceLevel As Integer, _
                    ByVal pCellAddr As String, ByVal pContextID As String, _
                    ByVal pLocale As String, ByVal pAnnotation As String, _
                    ByVal pBaseType As String, ByVal pCellStatusString As String)
    EnsureValues
    Dim Value As STEPXmlNode
    Set Value = oDom.createElement("Value")
    values.appendChild Value
    Value.SetAttribute "AttributeID", attibuteID
    If (sourceObjectType <> "") Then
        Value.SetAttribute "SourceObjectType", sourceObjectType
    End If
    If (useLOVID <> "") Then
        Value.SetAttribute "UseLOVID", useLOVID
    End If
    If (pCellAddr <> "") Then
        Value.SetAttribute "CellAddress", pCellAddr
    End If
    If (pContextID <> "") Then
        Value.SetAttribute "Context", pContextID
    End If
    If (pLocale <> "") Then
        Value.SetAttribute "Locale", pLocale
    End If
    If (pAnnotation <> "") Then
        Value.SetAttribute "Annotation", pAnnotation
    End If
    If (pBaseType <> "") Then
        Value.SetAttribute "BaseValidationType", pBaseType
    End If
    If (pCellStatusString <> "") Then
        Value.SetAttribute "CellStatus", pCellStatusString
    End If
    Value.SetAttribute "SourceLevel", CStr(sourceLevel)
    Value.appendChild oDom.createTextNode(attributeValue)
End Sub

Public Sub AddMultiValue(ByVal attributeID As String, ByRef attributeValues() As String, _
                         ByVal sourceObjectType As String, ByVal useLOVID As String, ByVal sourceLevel As Integer, _
                         ByVal pCellAddr As String, ByVal pContextID As String, _
                         ByVal pLocale As String, ByVal pAnnotation As String, _
                         ByVal pBaseType As String, ByVal pCellStatusString As String)
    EnsureValues
    Dim multivalue As STEPXmlNode, Value As STEPXmlNode
    
    Set multivalue = oDom.createElement("MultiValue")
    multivalue.SetAttribute "AttributeID", attributeID
    If (sourceObjectType <> "") Then
        multivalue.SetAttribute "SourceObjectType", sourceObjectType
    End If
    If (useLOVID <> "") Then
       multivalue.SetAttribute "UseLOVID", useLOVID
    End If
    If (pCellAddr <> "") Then
        multivalue.SetAttribute "CellAddress", pCellAddr
    End If
    If (pContextID <> "") Then
        multivalue.SetAttribute "Context", pContextID
    End If
    If (pLocale <> "") Then
        multivalue.SetAttribute "Locale", pLocale
    End If
    If (pAnnotation <> "") Then
        multivalue.SetAttribute "Annotation", pAnnotation
    End If
    If (pBaseType <> "") Then
        multivalue.SetAttribute "BaseValidationType", pBaseType
    End If
    If (pCellStatusString <> "") Then
        multivalue.SetAttribute "CellStatus", pCellStatusString
    End If
    multivalue.SetAttribute "SourceLevel", CStr(sourceLevel)
    values.appendChild multivalue
    Dim sv As String
    Dim i As Integer
    For i = LBound(attributeValues) To UBound(attributeValues)
        sv = attributeValues(i)
        If (Len(sv) > 0) Then
            Set Value = oDom.createElement("Value")
            Value.appendChild oDom.createTextNode(sv)
            multivalue.appendChild Value
        End If
        
    Next
End Sub


Public Sub AddReference(ByVal referenceID As String, ByRef refIDS() As String, ByVal createTarget, _
                        ByVal sourceObjectType As String, ByVal sourceLevel As Integer, _
                        ByVal pCellAddr As String, ByVal pContextID As String, ByVal pAnnotation As String)
    Dim reference As STEPXmlNode, Value As STEPXmlNode
    Set reference = oDom.createElement("Reference")
    reference.SetAttribute "ReferenceID", referenceID
    If (sourceObjectType <> "") Then
        reference.SetAttribute "SourceObjectType", sourceObjectType
    End If
    reference.SetAttribute "SourceLevel", CStr(sourceLevel)
    If (createTarget) Then
        reference.SetAttribute "CreateTarget", "true"
    End If
    If (pCellAddr <> "") Then
        reference.SetAttribute "CellAddress", pCellAddr
    End If
    If (pContextID <> "") Then
        reference.SetAttribute "Context", pContextID
    End If
    If (pAnnotation <> "") Then
        reference.SetAttribute "Annotation", pAnnotation
    End If
    Dim sv As String
    Dim i As Integer
    For i = LBound(refIDS) To UBound(refIDS)
        sv = refIDS(i)
        If (Len(sv) > 0) Then
            Set Value = oDom.createElement("Value")
            Value.appendChild oDom.createTextNode(sv)
            reference.appendChild Value
        End If
        
    Next
    product.appendChild reference
End Sub
Public Sub AddLink(ByVal linkID As String, ByRef refIDS() As String, ByVal createTarget As Boolean, ByVal sourceObjectType As String, ByVal sourceLevel As Integer, ByVal pCellAddr As String, ByVal pContextID As String, ByVal pAnnotation As String)
    Dim reference As STEPXmlNode, Value As STEPXmlNode
    Set reference = oDom.createElement("Link")
    reference.SetAttribute "LinkID", linkID
    If (sourceObjectType <> "") Then
        reference.SetAttribute "SourceObjectType", sourceObjectType
    End If
    reference.SetAttribute "SourceLevel", CStr(sourceLevel)
    If (createTarget) Then
        reference.SetAttribute "CreateTarget", "true"
    End If
    If (pCellAddr <> "") Then
        reference.SetAttribute "CellAddress", pCellAddr
    End If
    If (pContextID <> "") Then
        reference.SetAttribute "Context", pContextID
    End If
    If (pAnnotation <> "") Then
        reference.SetAttribute "Annotation", pAnnotation
    End If
    Dim sv As String
    Dim i As Integer
    For i = LBound(refIDS) To UBound(refIDS)
        sv = refIDS(i)
        If (Len(sv) > 0) Then
            Set Value = oDom.createElement("Value")
            Value.appendChild oDom.createTextNode(sv)
            reference.appendChild Value
        End If
        
    Next
    product.appendChild reference
End Sub

Public Sub AddBatches(ByRef batchIDS() As String, ByVal pCellAddr As String, ByVal pAnnotation As String)
    Dim batch As STEPXmlNode, Value As STEPXmlNode
    Set batch = oDom.createElement("Batch")
    If (pCellAddr <> "") Then
        batch.SetAttribute "CellAddress", pCellAddr
    End If
    If (pAnnotation <> "") Then
        batch.SetAttribute "Annotation", pAnnotation
    End If
    Dim sv As String
    Dim i As Integer
    For i = LBound(batchIDS) To UBound(batchIDS)
        sv = batchIDS(i)
        If (Len(sv) > 0) Then
            Set Value = oDom.createElement("Value")
            Value.appendChild oDom.createTextNode(sv)
            batch.appendChild Value
        End If
        
    Next
    product.appendChild batch
End Sub

'returns the constructed xml as text
Public Function GetText() As String
    GetText = oDom.Xml
End Function

Public Function GetXML() As Object
    Set GetXML = oDom
End Function

Private Sub Class_Terminate()
    Clear
End Sub

Attribute VB_Name = "STEPRequestUtils"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit


Private Const STEP_SERVICE_PATH = "sheet/services/excelservice"

' Actions must match actions in the ExcelServiceServlet
Private Const STEP_ACTION_PARAM = "action="
Private Const STEP_ACTION_LOGIN = "login"
Private Const STEP_ACTION_VALIDATE = "validate"
Private Const STEP_ACTION_GET_CHILDREN = "getchildnodes"
Private Const STEP_ACTION_QUERY_NODES = "querynodes"


Public Property Get STEPLoginURL(ByVal stepurl As String)
        STEPLoginURL = GetSTEPActionURL(stepurl, STEP_ACTION_LOGIN)
End Property

Public Property Get STEPValidationURL()
    Dim sheetUtils As New STEPSheetUtils
    STEPValidationURL = GetSTEPActionURL(sheetUtils.STEPServerURL, STEP_ACTION_VALIDATE)
End Property

Public Property Get STEPGetChildrenURL()
    Dim sheetUtils As New STEPSheetUtils
    STEPGetChildrenURL = GetSTEPActionURL(sheetUtils.STEPServerURL, STEP_ACTION_GET_CHILDREN)
End Property

Public Property Get STEPQueryNodesURL()
    Dim sheetUtils As New STEPSheetUtils
    STEPQueryNodesURL = GetSTEPActionURL(sheetUtils.STEPServerURL, STEP_ACTION_QUERY_NODES)
End Property

Private Function STEPmID(s As String, length As Integer) As String
    
End Function


Private Function GetSTEPActionURL(s As String, actionParam As String)
    Dim sheetUtils As New STEPSheetUtils
    If (s <> "") Then
        If VBA.mID(s, Len(s)) <> "/" Then
            s = s & "/"
        End If
        s = s & STEP_SERVICE_PATH & "?" & STEP_ACTION_PARAM & actionParam
        GetSTEPActionURL = s
    End If
End Function



Public Property Get STEPRequestTypeProducts()
        STEPRequestTypeProducts = "Products"
End Property

Public Property Get STEPRequestTypeProduct()
        STEPRequestTypeProduct = "Product"
End Property


Public Property Get STEPRequestTypeAssets()
        STEPRequestTypeAssets = "Assets"
End Property

Public Property Get STEPRequestTypeAsset()
        STEPRequestTypeAssets = "Asset"
End Property

Public Function ConvertToDomainReferenceType(ByVal referenceType As STEPColumnType)
    Select Case referenceType
        Case STEPColumnType.STEPAttribute
            ConvertToDomainReferenceType = "Attribute"
        Case STEPColumnType.STEPBatch
            ConvertToDomainReferenceType = "Batch"
        Case STEPColumnType.STEPParentID
            ConvertToDomainReferenceType = "Parent"
        Case STEPColumnType.STEPReference
            ConvertToDomainReferenceType = "Reference"
        Case STEPColumnType.STEPLink
            ConvertToDomainReferenceType = "Link"
        Case Else ' xxx deleted default
            ConvertToDomainReferenceType = ""
    End Select
End Function
Attribute VB_Name = "STEPResponseParser"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Private oDom As Object
Private mParseError As String
Private mProducts As Collection
Private mModifiedProducts As Collection
Private mStatusProducts As Collection
Private mLocale As New STEPLocalization

'Response from server:
'<Products ValidationError="..."><!-- server stopped, cant log in ect. - NO FURTHER PARSING -->
'   <Product ID="..." ValidationError="..."><!-- whole product: cant find, cant initiate ect -->
'       <Name ValidationError="..." CellAddress="...">...</Name><!-- invalid name -->
'       <ClassificationReference ClassificationID="..." ValidationError="..."/> <!-- cant find classification, illegal reference ect -->
'       <Reference ReferenceID="..." CellAddress="..." [ValidationError="..."]>
'           <Value ValidationError="..."/> <!-- 1 to n -->
'       </Reference>
'       <Link LinkID="..." CellAddress="..." [ValidationError="..."]>
'           <Value ValidationError="..."/> <!-- 1 to n -->
'       </Link>
'       <AssetCrossReference AssetID="..." Type="..." ValidationError="..."/> <!-- can't find asset, cannot create reference -->
'       <Values>
'           <Value AttributeID="..." CellAddress="..." [CellStatus="hi|ro|io" | ValidationError="..." | ModifiedValue="true"]>...</Value> <!-- attribute not found, not legal on product, illegal value ect OR value modified on server; reformatted, default value ect --->
'           <MultiValue AttributeID="..." CellAddress="..." [CellStatus="hi|ro|io" | ValidationError="..." | ModifiedValue="true"]> <!-- attribute not found, not legal on product ect OR value modified--->
'               <Value ValidationError="...">...</Value><!-- value failed validation-->
'           </MultiValue>
'       </Values>
'   </Product>
'</Products>


Private Sub Clear()
    Set mProducts = New Collection
    Set mModifiedProducts = New Collection
    Set mStatusProducts = New Collection
    Set oDom = Nothing
    ParseError = ""
End Sub

Public Property Get ParseError() As String
    ParseError = mParseError
End Property
Private Property Let ParseError(ByVal str As String)
    mParseError = str
End Property


Public Function Load(Xml) As Boolean
    Clear
    On Error GoTo LOAD_ERR:
    Set oDom = Xml
    Dim domErr
    Set domErr = oDom.ParseError
    If (Not domErr Is Nothing And domErr.errorCode <> 0) Then
        Dim sl As New STEPLogger
        sl.Severe "STEPResponseParser.Load", "Error in DOM: " & domErr.reason & "(line:" & domErr.srcText & ")"
        err.Raise vbObjectError + 1001, Description:=mLocale.GetLocalizationString("STEPResponseParserError")
    End If
    Load = Process
    On Error GoTo 0
    Exit Function
LOAD_ERR:
    ParseError = VBA.Error$
    Load = False
    On Error GoTo 0
End Function

Public Function Parse(ByVal Xml As String) As Boolean
    Clear
    On Error GoTo PARSE_ERR
    Set oDom = CreateObject("Microsoft.XMLDOM")
    oDom.async = False
    oDom.LoadXML Xml
    Dim domErr
    Set domErr = oDom.ParseError
    If (Not domErr Is Nothing And domErr.errorCode <> 0) Then
        Dim sl As New STEPLogger
        sl.Severe "STEPResponseParser.Parse", "Error in DOM: " & domErr.reason & "(line:" & domErr.srcText & ")"
        err.Raise vbObjectError + 1001, Description:=mLocale.GetLocalizationString("STEPResponseParserError")
    End If
    Parse = Process
    On Error GoTo 0
    Exit Function
PARSE_ERR:
    ParseError = VBA.Error$
    Parse = False
    On Error GoTo 0
End Function

Private Function Process() As Boolean
    On Error GoTo PROCESS_ERR
    Dim Root As Object
    Set Root = oDom.DocumentElement
    'check for velformed xml
    If (Root Is Nothing) Then
        err.Raise vbObjectError + 1000, Source:="STEPResponseParser.Process", Description:=mLocale.GetLocalizationString("STEPResponseParserXMLInvalid")
    End If
    'check for errormessage on root (Products) and stop parse if any
    If (GetValidationError(Root, ParseError)) Then
        Set oDom = Nothing
        Process = False
        Exit Function
    End If

    Dim prods
    Dim prod As Object
    Set prods = oDom.getElementsByTagName("Product")
    Dim Index As Integer
    Dim productid As String
    For Index = 1 To prods.length
        Set prod = prods.Item(Index)
        ParseProduct prod
    Next Index
    Process = True
    Exit Function
PROCESS_ERR:
    ParseError = VBA.Error$
    Process = False
End Function

Public Function GetFailedProducts() As Collection
    Set GetFailedProducts = mProducts
End Function

Public Function GetFailedProductsArray() As STEPValidatedProduct()
    Dim arr() As STEPValidatedProduct
    If (mProducts.Count > 0) Then
        ReDim arr(1 To mProducts.Count) As STEPValidatedProduct
        Dim i As Integer
        For i = 1 To mProducts.Count
            Set arr(i) = mProducts(i)
        Next i
    End If
    GetFailedProductsArray = arr
End Function

Public Function GetFailedProductsCount() As Integer
    GetFailedProductsCount = mProducts.Count
End Function
Public Function GetModifiedProductsArray() As STEPValidatedProduct()
    Dim arr() As STEPValidatedProduct
    If (mModifiedProducts.Count > 0) Then
        ReDim arr(1 To mModifiedProducts.Count) As STEPValidatedProduct
        Dim i As Integer
        For i = 1 To mModifiedProducts.Count
            Set arr(i) = mModifiedProducts(i)
        Next i
    End If
    GetModifiedProductsArray = arr
End Function

Public Function GetModifiedProductsCount() As Integer
    GetModifiedProductsCount = mModifiedProducts.Count
End Function

Public Function GetStatusProductsArray() As STEPValidatedProduct()
    Dim arr() As STEPValidatedProduct
    If (mStatusProducts.Count > 0) Then
        ReDim arr(1 To mStatusProducts.Count) As STEPValidatedProduct
        Dim i As Integer
        For i = 1 To mStatusProducts.Count
            Set arr(i) = mStatusProducts(i)
        Next i
    End If
    GetStatusProductsArray = arr
End Function

Public Function GetStatusProductsCount() As Integer
    GetStatusProductsCount = mStatusProducts.Count
End Function


Private Function GetProductID(prod As Object) As String
    GetProductID = prod.getAttributeNode("ID").Value
End Function

Private Function getNodeCellAddress(node As Object) As String
    Dim adr As Object
    Set adr = node.getAttributeNode("CellAddress")
    If (Not adr Is Nothing) Then
        getNodeCellAddress = adr.Value
    Else
        getNodeCellAddress = ""
    End If
End Function


Private Function GetCellStatus(node As Object, ByRef pCellStatus As STEPCellStatus) As Boolean
    Dim att As Object, str As String
    Set att = node.getAttributeNode("CellStatus")
    If (Not att Is Nothing) Then
        GetCellStatus = True
        str = att.Value
        Set pCellStatus = New STEPCellStatus
        pCellStatus.CellStatusString = str
        pCellStatus.CellAddress = getNodeCellAddress(node)
    Else
        GetCellStatus = False
    End If
End Function

Private Function GetValidationError(node As Object, ByRef errmsg As String) As Boolean
    Dim att As Object
    Set att = node.getAttributeNode("ValidationError")
    If (Not att Is Nothing) Then
        GetValidationError = True
        errmsg = ThisWorkbook.unescapeXmlValue(att.Value)
    Else
        GetValidationError = False
        errmsg = ""
    End If
End Function

Private Function HasModifications(node As Object) As Boolean
    HasModifications = False
    Dim att As Object
    Set att = node.getAttributeNode("ModifiedValue")
    If (Not att Is Nothing) Then
        If ("true" = att.Value) Then
            HasModifications = True
        End If
    End If
End Function

Private Sub ParseProduct(prod As Object)
    Dim errmsg As String

    Dim vp As New STEPValidatedProduct
    vp.productid = ThisWorkbook.unescapeXmlValue(prod.getAttributeNode("ID").Value)
    If (GetValidationError(prod, errmsg)) Then
        vp.AddProductError errmsg
    End If

    Dim Index As Integer, Child As Object
    For Index = 1 To prod.ChildNodes.Count
        Set Child = prod.ChildNodes(Index)
        Select Case Child.NodeName()
            Case "Name"
                If (GetValidationError(Child, errmsg)) Then
                    vp.AddNameError errmsg, getNodeCellAddress(Child)
                End If
            Case "Reference"
                ParseReference Child, vp
            Case "Link"
                ParseLink Child, vp
            Case "Batch"
                ParseBatch Child, vp
            Case "Values"
                ParseValues Child, vp
            Case Else
        End Select
    Next
    If (vp.ValidationErrorCount > 0) Then
        mProducts.Add vp, vp.productid
    End If
    If (vp.CellStatusesCount > 0) Then
        mStatusProducts.Add vp, vp.productid
    End If
    If (vp.ModificationsCount > 0) Then
        mModifiedProducts.Add vp, vp.productid
    End If
End Sub

Private Sub ParseBatch(batch As Object, ByRef vp As STEPValidatedProduct)
    Dim Index As Integer, Child As Object, errmsg As String
    Dim lCellAddr As String
    lCellAddr = getNodeCellAddress(batch)
    If (GetValidationError(batch, errmsg)) Then
        vp.AddBatchError errmsg, lCellAddr
    End If
    For Index = 1 To batch.ChildNodes.Count
        Set Child = batch.ChildNodes(Index)
        If (Child.NodeName() = "Value") Then
            If (GetValidationError(Child, errmsg)) Then
                vp.AddBatchError errmsg, lCellAddr
            End If
        End If
    Next Index
End Sub
Private Sub ParseReference(reference As Object, ByRef vp As STEPValidatedProduct)
    Dim Index As Integer, Child As Object, errmsg As String, referenceID As String
    Dim lCellAddr As String
    referenceID = ThisWorkbook.unescapeXmlValue(reference.getAttributeNode("ReferenceID").Value)
    lCellAddr = getNodeCellAddress(reference)
    If (GetValidationError(reference, errmsg)) Then
        vp.AddReferenceError referenceID, errmsg, lCellAddr
    End If
    For Index = 1 To reference.ChildNodes.Count
        Set Child = reference.ChildNodes(Index)
        If (Child.NodeName() = "Value") Then
            If (GetValidationError(Child, errmsg)) Then
                vp.AddReferenceError referenceID, errmsg, lCellAddr
            End If
        End If
    Next Index
End Sub

Private Sub ParseLink(link As Object, ByRef vp As STEPValidatedProduct)
    Dim Index As Integer, Child As Object, errmsg As String, linkID As String
    Dim lCellAddr As String
    linkID = ThisWorkbook.unescapeXmlValue(link.getAttributeNode("LinkID").Value)
    lCellAddr = getNodeCellAddress(link)
    If (GetValidationError(link, errmsg)) Then
        vp.AddLinkError linkID, errmsg, lCellAddr
    End If
    For Index = 1 To link.ChildNodes.Count
        Set Child = link.ChildNodes(Index)
        If (Child.NodeName() = "Value") Then
            If (GetValidationError(Child, errmsg)) Then
                vp.AddLinkError linkID, errmsg, lCellAddr
            End If
        End If
    Next Index
End Sub

Private Sub ParseValues(values As Object, ByRef vp As STEPValidatedProduct)
    Dim Index As Integer, Child As Object, errmsg As String, lCellStatus As STEPCellStatus
    For Index = 1 To values.ChildNodes.Count
        Set Child = values.ChildNodes(Index)
        If (Child.NodeName() = "Value") Then
            If (GetCellStatus(Child, lCellStatus)) Then
                vp.AddCellStatus lCellStatus
            ElseIf (GetValidationError(Child, errmsg)) Then
                vp.AddAttributeError ThisWorkbook.unescapeXmlValue(Child.getAttributeNode("AttributeID").Value), errmsg, getNodeCellAddress(Child)
            ElseIf (HasModifications(Child)) Then
                If (Child.ChildNodes.Count > 0) Then
                    vp.AddModifiedValue ThisWorkbook.unescapeXmlValue(Child.getAttributeNode("AttributeID").Value), ThisWorkbook.unescapeXmlValue(Child.Value), getNodeCellAddress(Child)
                End If
            End If
        ElseIf (Child.NodeName() = "MultiValue") Then
            Dim modified As Boolean
            modified = False
            Dim modifiedvalues As Collection
            Dim mverr As String
            mverr = ""
            If (GetCellStatus(Child, lCellStatus)) Then
                vp.AddCellStatus lCellStatus
            ElseIf (GetValidationError(Child, errmsg)) Then 'error for entire multivalue attribute
                mverr = errmsg & vbCrLf
            ElseIf (HasModifications(Child)) Then
                modified = True
                Set modifiedvalues = New Collection
            End If

            Dim childvalue As Object, valueindex As Integer
            For valueindex = 1 To Child.ChildNodes.Count
                Set childvalue = Child.ChildNodes(valueindex)
                If (GetValidationError(childvalue, errmsg)) Then
                    mverr = mverr & errmsg & vbCrLf
                End If
                If (modified) Then
                    If (childvalue.ChildNodes.length > 0) Then
                        modifiedvalues.Add childvalue.ChildNodes(0).NodeValue
                    End If
                End If
            Next valueindex
            If (Len(mverr) > 0) Then
                mverr = VBA.mID$(mverr, 1, Len(mverr) - 2)
                vp.AddAttributeError ThisWorkbook.unescapeXmlValue(Child.getAttributeNode("AttributeID").Value), mverr, getNodeCellAddress(Child)
            ElseIf (modified) Then
                If (modifiedvalues.Count > 0) Then
                    Dim modifiedvaluesarray() As String, modindex As Integer
                    ReDim modifiedvaluesarray(1 To modifiedvalues.Count)
                    For modindex = 1 To modifiedvalues.Count
                        modifiedvaluesarray(modindex) = ThisWorkbook.unescapeXmlValue(modifiedvalues.Item(modindex))
                    Next
                    vp.AddModifiedMultiValue ThisWorkbook.unescapeXmlValue(Child.getAttributeNode("AttributeID").Value), modifiedvaluesarray
                End If
            End If
        End If
    Next Index
End Sub

Private Sub Class_Terminate()
    Clear
End Sub
Attribute VB_Name = "STEPSelectionHandler"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Private sUtils As New STEPSheetUtils
Private mLocale As New STEPLocalization

Public Function handle(ByVal sheet As Object, ByVal Target As Range)
    err.Clear
    handleComment Target
    On Error Resume Next
    If (Target.cells.Count = 1) Then
        If err.Number <> 0 Then
            err.Clear
            Exit Function
        End If
        On Error GoTo SELHANDLE_ERR
        Dim col As String
        col = Target.cells.Column
        If Target.cells.row < sUtils.FirstProductRow(sheet, False) Then
            Exit Function
        End If
        If Target.cells.row > sUtils.LastInitiateRow(sheet) Then
            Exit Function
        End If
        Dim ColumnType As STEPColumnType
        ColumnType = sUtils.GetColumnType(sheet, col)
        Dim mulval As Boolean

        Dim cll As Range


        Select Case ColumnType
            Case STEPColumnType.EXCELButton
                Dim valueColumnType As STEPColumnType
                Dim valueColumnTypeId As String
                Dim colHdr As String
                Dim rowSupplier As STEPSupplierInfo
                Dim supplierColumn As Long
                If (col > 1) Then
                    Set cll = sheet.cells(Target.row, col - 1)
                    colHdr = sheet.cells(sUtils.HeaderRow, col - 1).Value
                    valueColumnType = sUtils.GetColumnType(sheet, col - 1)
                    valueColumnTypeId = sUtils.GetColumnID(sheet, col - 1)
                    mulval = sUtils.IsColumnMultivalued(sheet, col - 1)
                    Dim prompt As String
                    Set rowSupplier = sUtils.GetRowSupplier(sheet, Target.cells.row, supplierColumn)
                    If (sUtils.IsMultiSupplierSheet And rowSupplier Is Nothing) Then
                        If (STEPBatch = valueColumnType Or STEPReference = valueColumnType Or STEPLink = valueColumnType Or STEPParentID = valueColumnType) Then
                            If (supplierColumn > 0) Then
                                prompt = mLocale.GetLocalizationString("STEPSelectionHandlerSelectRequired") & sUtils.GetColumnHeader(sheet, supplierColumn)
                                MsgBox prompt, Title:=mLocale.GetLocalizationString("STEPSelectionHandlerSelectRequiredTitle")
                                If (supplierColumn > 0) Then
                                    sheet.cells(Target.cells.row, supplierColumn).Select
                                    Exit Function
                                End If
                            Else
                                prompt = mLocale.GetLocalizationString("STEPSelectionHandlerSupplierMissing")
                                MsgBox prompt, Title:=mLocale.GetLocalizationString("STEPSelectionHandlerSelectRequiredTitle")
                                If (supplierColumn > 0) Then
                                    Exit Function
                                End If
                            End If
                        End If
                    End If
                    If (STEPParentID = valueColumnType And sUtils.HasExtendedSettingsSheet) Then
                        If Not sUtils.IsInitiateWorkbook Then
                            Exit Function
                        End If
                        Dim initiateObjectType As String
                        Dim objectTypeColumn As Long
                        Dim lTopProductID As String
                        If (sUtils.IsMultipleCategorySmartSheet) Then
                            lTopProductID = sUtils.GetSheetInitiateRootProductId(sheet)
                        Else
                            lTopProductID = sUtils.GetInitiateRootProductId()
                        End If
                        initiateObjectType = sUtils.GetRowInitiateObjectType(sheet, Target.cells.row, objectTypeColumn)
                        If (Len(initiateObjectType) > 0) Then
                            handleSingleValue sheet, cll, valueColumnType, valueColumnTypeId, colHdr, initiateObjectType, lTopProductID, pSupplierInfo:=rowSupplier
                        Else
                            If (objectTypeColumn > 0) Then
                                prompt = mLocale.GetLocalizationString("STEPSelectionHandlerSelectRequired") & sUtils.GetColumnHeader(sheet, objectTypeColumn)
                            Else
                                prompt = mLocale.GetLocalizationString("STEPSelectionHandlerSelectProductType")
                            End If
                            MsgBox prompt, Title:=mLocale.GetLocalizationString("STEPSelectionHandlerSelectRequiredTitle")
                            If (objectTypeColumn > 0) Then
                                sheet.cells(Target.cells.row, objectTypeColumn).Select
                                Exit Function
                            End If
                        End If

                    ElseIf (STEPBatch = valueColumnType Or STEPReference = valueColumnType Or STEPLink = valueColumnType Or STEPParentID = valueColumnType) Then
                        If (mulval) Then
                            handleMultiValue sheet, cll, valueColumnType, valueColumnTypeId, colHdr, rowSupplier
                        Else
                            handleSingleValue sheet, cll, valueColumnType, valueColumnTypeId, colHdr, pSupplierInfo:=rowSupplier
                        End If
                    ElseIf (STEPAttribute = valueColumnType) Then
                        If (mulval And sUtils.HasColumnLov(sheet, col - 1)) Then
                            handleMultivaluedLOV sheet, cll, sUtils.ColumnLOVIdentifier(sheet, col - 1), colHdr
                        Else
                            MsgBox "Not implemented."
                        End If
                    Else
                        MsgBox "Not implemented."
                    End If

                    ' Change selection to the Value cell, or if current cell is in column 1, shift right
                    ' This is done to ensure that we can click the same cell again
                    On Error Resume Next
                    Dim ea As Boolean
                    ea = ThisWorkbook.Application.EnableEvents
                    ThisWorkbook.Application.EnableEvents = False
                    cll.Select
                    ThisWorkbook.Application.EnableEvents = ea

                Else
                    valueColumnType = STEPColumnType.STEPUndefined
                    valueColumnTypeId = -1
                    MsgBox mLocale.GetLocalizationString("STEPSelectionHandlerInvalidColumnIndex")
                End If

        End Select

    End If
    Exit Function
SELHANDLE_ERR:
    MsgBox mLocale.GetLocalizationString("STEPSelectionHandlerGeneralError")
    Dim msg As String
    msg = err.Number & " " & err.Description
    On Error Resume Next
    Dim logutil As New STEPLogger
    logutil.Severe "STEPSelectionHandler.handle", msg
    err.Clear
    On Error GoTo 0
End Function

Private Function handleMultivaluedLOV(ByVal ws As Worksheet, ByVal cell As Range, ByVal attributeID As String, ByVal pCaption As String)
    Dim editor As New STEPLOVForm
    Dim strval As String
    strval = cell.Value
    
    Dim strvalarray() As String
    If (strval <> "") Then
        strvalarray = sUtils.SplitMultivalue(strval)
    Else
        ReDim strvalarray(0 To 0) As String
    End If

    If (editor.Init(attributeID, pCaption, strvalarray)) Then
        If (editor.Run()) Then
            strvalarray = editor.GetResult()
            strval = sUtils.JoinMultivalue(strvalarray)
            cell.Value = strval
        End If
    End If
End Function


Private Function handleSingleValue(ByVal ws As Worksheet, ByVal cell As Range, ByVal valueColumnType As STEPColumnType, ByVal valueColumnTypeId As String, ByVal pCaption As String, Optional ByVal initiateObjecttypeID As String = "", Optional ByVal pTopProductID As String = "", Optional ByRef pSupplierInfo As STEPSupplierInfo = Nothing)
    Dim rUtils As New STEPRequestUtils
    Dim np As New STEPNodePicker
    Dim result As String
    Dim void() As String
    Dim lSupplierID As String
    If (Not pSupplierInfo Is Nothing) Then
        lSupplierID = pSupplierInfo.SupplierID
    Else
        lSupplierID = ""
    End If
    If np.Init(pCaption, valueColumnType, valueColumnTypeId, False, lSupplierID, void) Then
        np.InitateObjectTypeID = initiateObjecttypeID
        np.TopProductID = pTopProductID
        If (np.Run = FormAction.OK) Then
            result = np.GetResult
            
            ' Set result from dialog on the cell to the left of the button cell
            cell.Value = result
        End If
        On Error Resume Next 'np might have gone because of close-box so ignore errors on terminate-tree
        np.TerminateTree
        err.Clear
    End If
    
                
End Function
Private Function handleMultiValue(ByVal ws As Worksheet, ByVal cell As Range, ByVal valueColumnType As STEPColumnType, ByVal valueColumnTypeId As String, pCaption As String, Optional ByRef pSupplierInfo As STEPSupplierInfo = Nothing)
    Dim rUtils As New STEPRequestUtils
    Dim np As New STEPNodePicker
    Dim result As String
    Dim lSupplierID As String
    Dim strval As String
    strval = cell.Value
    If (Not pSupplierInfo Is Nothing) Then
        lSupplierID = pSupplierInfo.SupplierID
    Else
        lSupplierID = ""
    End If
    Dim strvalarray() As String
    If (strval <> "") Then
        strvalarray = sUtils.SplitMultivalue(strval)
    Else
        ReDim strvalarray(0 To 0) As String
    End If
    If np.Init(pCaption, valueColumnType, valueColumnTypeId, True, lSupplierID, strvalarray) Then
        If (np.Run = FormAction.OK) Then
            result = sUtils.JoinMultivalue(np.getResultList)
            
            ' Set result from dialog on the cell to the left of the button cell
            cell.Value = result
        End If
        On Error Resume Next 'np might have gone because of close-box so ignore errors on terminate-tree
        np.TerminateTree
        err.Clear
    End If
    
        
End Function

Private Sub handleComment(ByVal pCells As Range)
    'www.contextures.com/xlcomments03.html
    Dim visRange As Range
    Dim cmt As Comment
    Dim shp As Shape
    Dim maxRow As Long
    Dim maxCol As Long
    Dim cellCount As Long
    On Error GoTo COMMENT_ERROR
    'hide any comments previously forced visible
    Application.DisplayCommentIndicator = xlCommentIndicatorOnly
    
    cellCount = pCells.cells.Count
    If (cellCount = 2) Then
        'yet another quirck in excel - clicking a cell that spans two columns does not include comments
        'I suppose it is always ActiveCell comment we are getting anyway
        Set cmt = ActiveCell.Comment
    Else
        Set cmt = pCells.Comment
    End If
        
    If (cmt Is Nothing) Then
        Exit Sub
    End If
    maxRow = sUtils.HeaderRow
    If (cellCount > 2) Then
        Exit Sub
    ElseIf (cellCount = 2) Then
        'columns with buttons has a selection of two for header row
        If (pCells.row > maxRow) Then
            Exit Sub
        End If
    End If
    maxCol = sUtils.GetIDColumnIndex
    If (sUtils.HasExtendedSettingsSheet) Then
        maxCol = maxCol + 1
        End If
    If (pCells.row > maxRow And pCells.Column > maxCol) Then
        'dont do this for cells not frozen
        Exit Sub
    End If
    Set visRange = ActiveWindow.VisibleRange
    Set shp = cmt.Shape
    If (pCells.row = maxRow And pCells.Column = maxCol) Then
        'double frozen cell
        'show top-left of visible area
        shp.top = visRange.top + 2
        shp.Left = visRange.Left + 5
    ElseIf (pCells.row > maxRow) Then
        'left frozen column
        'show in visible area sligthly below current cell
        shp.top = pCells.top + pCells.Height + 2
        shp.Left = visRange.Left + 5
    Else
        'top frozen row
        'show in top of visible area
        shp.top = visRange.top + 2
        shp.Left = pCells.Left + pCells.Width + 5
    End If
    cmt.Visible = True
     
    Exit Sub
COMMENT_ERROR:
    Dim msg As String
    msg = err.Number & " " & err.Description
    On Error Resume Next
    Dim logutil As New STEPLogger
    logutil.Severe "STEPSelectionHandler.handleComment", msg
    err.Clear
    On Error GoTo 0
    
End Sub

Attribute VB_Name = "STEPSeparatorUtils"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Private mUtils As STEPSheetUtils
Private mAppliedSeparator As String
Private mCurrentSeparator
Private mApplicable As Boolean
Private Const RANGE_SEPARATOR As String = "-"
Private mLocale As New STEPLocalization

'This class functionally matches com.stibo.smartsheet.extractor.DecimalSeparatorHelper
'Keep any changes in sync

Private Sub Class_Initialize()
    mApplicable = False
    Set mUtils = New STEPSheetUtils
    If (mUtils.UseLocalDecimalSeparator) Then
        mAppliedSeparator = mUtils.LastAppliedDecimalSeparator
#If Mac Then
        'Application.DecimalSeparator apparently not available on Mac - undocumented
        Dim d As Double
        d = 10 / 4
        mCurrentSeparator = VBA.mID(CStr(d), 2, 1)
#Else
        mCurrentSeparator = Application.DecimalSeparator
#End If
        mApplicable = Len(mAppliedSeparator) = 1 And Len(mCurrentSeparator) = 1 And (StrComp(mAppliedSeparator, mCurrentSeparator) <> 0)
    End If
End Sub

Public Property Get RequiresReplace() As Boolean
    RequiresReplace = mApplicable
End Property

Public Sub ApplyReplace()
    If (Not RequiresReplace) Then
        Exit Sub
    End If
    Dim ws As Worksheet
    Dim Index As Integer, col As Long
    On Error GoTo DECIMAL_APPLY_ERROR
    For Index = 1 To ThisWorkbook.Worksheets.Count
        Set ws = ThisWorkbook.Worksheets(Index)
        If (mUtils.IsProductsSheet(ws)) Then
            For col = 2 To mUtils.GetLastCol(ws, mUtils.ColumnTypeRowIndex)
                Dim bvt As STEPColumnBaseValidationType
                bvt = mUtils.GetBaseValidationType(ws, col)
                If (bvt <> STEPColumnBaseValidationType.STEPNotClientRelevant) Then
                    ReplaceColumn ws, bvt, col
                End If

            Next
        End If
    Next
    mUtils.LastAppliedDecimalSeparator = mCurrentSeparator
    On Error GoTo 0
    Exit Sub
DECIMAL_APPLY_ERROR:
    Dim msg As String
    msg = mLocale.GetLocalizationString("STEPSeparatorUtilsReplacing") & mAppliedSeparator & "' with '" & mCurrentSeparator & "'" & vbNewLine
    msg = msg & "Sheet:" & ws.Name & " Column:" & col & vbNewLine
    msg = msg & err.Number & " " & err.Description
    Dim logger As New STEPLogger
    logger.Severe "STEPSeparatorUtils.ApplyReplace", msg
    err.Clear
    MsgBox mLocale.GetLocalizationString("STEPSeparatorUtilsError") + mCurrentSeparator & "'."
    On Error GoTo 0
End Sub

Private Sub ReplaceColumn(ByVal ws As Worksheet, ByVal validationType As STEPColumnBaseValidationType, ByVal colIndex As Long)
    Dim iRow As Long
    
    For iRow = mUtils.FirstProductRow(ws, True) To mUtils.GetLastRow(ws, colIndex) Step 1
        Dim original As String
        Dim converted As String
        original = VBA.Trim$(ws.cells(iRow, colIndex).Value)
        If (ReplaceValue(validationType, original, converted)) Then
            ws.cells(iRow, colIndex) = converted
        End If
    Next iRow
End Sub

Private Function ReplaceValue(ByVal baseType As STEPColumnBaseValidationType, ByVal Value As String, ByRef result As String) As Boolean
    ReplaceValue = False
    If (Len(Value) = 0) Then
        Exit Function
    End If
    Dim firstDigit As Long
    result = ""
    firstDigit = GetFirstDigit(Value)
    If (firstDigit < 1) Then
        Exit Function
    End If
    If (STEPColumnBaseValidationType.STEPNumberRange = baseType) Then
        Dim splitPos As Long
        splitPos = InStr(firstDigit + 1, Value, RANGE_SEPARATOR)
        If ((0 < splitPos) And (splitPos < (Len(Value) - 1))) Then
            Dim leftValue  As String
            Dim rightValue As String
            Dim leftRes As String
            Dim rightRes As String
            leftValue = VBA.Left$(Value, splitPos - 1)
            rightValue = VBA.mID$(Value, splitPos + 1)
            If (ReplaceValue(STEPNumber, leftValue, leftRes) And ReplaceValue(STEPNumber, rightValue, rightRes)) Then
                result = leftRes & RANGE_SEPARATOR & rightRes
                ReplaceValue = True
            End If
            Exit Function
        End If
    End If
    If (firstDigit > 1) Then
        result = VBA.Left$(Value, firstDigit - 1)
    End If
    Dim lIndex As Long
    Dim c As String
    lIndex = firstDigit
    Do While (lIndex <= Len(Value))
        c = VBA.mID$(Value, lIndex, 1)
        If (mAppliedSeparator = c) Then
            result = result & mCurrentSeparator
        ElseIf (IsNumeric(c) Or "-" = c Or "+" = c) Then
            result = result & c
        ElseIf ((baseType = STEPNumber) And StrComp(c, "e", vbTextCompare)) Then
            result = result & c
        Else
            GoTo DONE_LOOP
        End If
        lIndex = lIndex + 1
    Loop
DONE_LOOP:
    If (lIndex < Len(Value)) Then
        result = result & VBA.mID$(Value, lIndex)
    End If
    ReplaceValue = True
End Function


Private Function GetFirstDigit(ByVal Value As String) As Long
    Dim i As Long
    Dim c As String
    Dim boo As Boolean
    i = 1
    Do While i <= Len(Value)
        c = VBA.mID$(Value, i, 1)
        If (IsNumeric(c) Or "+" = c Or "-" = c) Then
            GetFirstDigit = i
            Exit Function
        ElseIf (c = mAppliedSeparator) Then
            If (i < Len(Value)) Then
                If IsNumeric(VBA.mID$(Value, i + 1, 1)) Then
                    GetFirstDigit = i
                    Exit Function
                End If
            End If
        End If
        i = i + 1
    Loop
    GetFirstDigit = 0
    
End Function


Private Sub Class_Terminate()
   Set mUtils = Nothing
End Sub
Attribute VB_Name = "STEPSet"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Dim mCollection As VBA.Collection

'behaves a little bit like a java-set
'can only contain one instance of a string
'in reality just a wrapper around VBA.Collection, handling
'the errors thrown on insert, remove ect.

Private Sub Class_Initialize()
    Set mCollection = New VBA.Collection
End Sub

Public Sub Add(ByVal sItem As String)
    On Error GoTo ADD_ERR
    mCollection.Add sItem, sItem
    Exit Sub
ADD_ERR:
    err.Clear
End Sub

Public Sub AddWithKey(ByVal sItem As String, ByVal sKey As String)
    On Error GoTo ADD_ERR
    mCollection.Add sItem, sKey
    Exit Sub
ADD_ERR:
    err.Clear
End Sub


Public Function Contains(ByVal sItem As String) As Boolean
    Contains = False
    On Error GoTo CONTAINS_ERR
    Dim v
    v = mCollection.Item(sItem)
    Contains = True
    Exit Function
    
CONTAINS_ERR:
    err.Clear
End Function

Public Sub Remove(ByVal sItem As String)
    On Error GoTo REMOVE_ERR
    mCollection.Remove sItem
    Exit Sub
REMOVE_ERR:
    err.Clear
End Sub

Public Function Count() As Long
    Count = mCollection.Count
End Function

Public Function Item(ByVal lIndex As Long)
    Item = mCollection.Item(lIndex)
End Function
Public Function RemoveByIndex(ByVal lIndex As Long)
    mCollection.Remove lIndex
End Function

Private Sub Class_Terminate()
    Set mCollection = Nothing
End Sub
Attribute VB_Name = "STEPSheetSetup"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Private mUtils As New STEPSheetUtils
Private mStyleHelper As New STEPStyleHelper
Private mLocale As New STEPLocalization
Private mTemplateProductHelper As New STEPTemplateProductHelper

Public Sub SetUp(ws As Worksheet)
    If (Not mUtils.IsProductsSheet(ws)) Then
        Exit Sub
    End If
    Dim lTimer As New STEPTimer
    Dim lAllTimer As New STEPTimer
    lAllTimer.StartTimer "Setting up product sheet " & ws.Name
    Dim screenUpd As Boolean, enableEvt As Boolean
    screenUpd = ThisWorkbook.Application.ScreenUpdating
    enableEvt = ThisWorkbook.Application.EnableEvents
    On Error GoTo SETUP_ERR
    ThisWorkbook.Application.ScreenUpdating = False
    ThisWorkbook.Application.EnableEvents = False
    Dim prev As Worksheet
    lTimer.StartTimer "Activate and un-protect"
    Set prev = ThisWorkbook.Application.ActiveSheet
    Dim i As Integer
    Dim r As Integer
    mUtils.UnProtectSheet ws
    ws.Activate
    lTimer.StopTimer
    lTimer.StartTimer "Un-freeze"
    'start with unfreece so we can add buttons
    With ThisWorkbook.Application.ActiveWindow
        .ScrollColumn = 1
        .ScrollRow = 1
        .SplitColumn = 0
        .SplitRow = 0
        .FreezePanes = False
    End With
    lTimer.StopTimer
    lTimer.StartTimer "Store name"
    mUtils.StoreSheetName ws
    lTimer.StopTimer
    'always hide column 1 for smartsheets
    lTimer.StartTimer "Hide first column"
    ws.Columns(1).Hidden = mUtils.HasExtendedSettingsSheet
    lTimer.StopTimer
    lTimer.StartTimer "Add sheet button(s)"
    AddSheetButton ws
    lTimer.StopTimer
    lTimer.StartTimer "Format cell buttons"
    FormatButtonColumns ws
    lTimer.StopTimer
    LockCells ws
    'POI'en makes a mess of fonts and color sor set it here
    lTimer.StartTimer "Style header"
    Dim lc As Long
    lc = mUtils.GetLastCol(ws, mUtils.HeaderRow)
    If (lc >= 1) Then
        mStyleHelper.SetHeaderStyle ws.Range(ws.cells(mUtils.HeaderRow, 1), ws.cells(mUtils.HeaderRow, lc))
    End If
    lTimer.StopTimer
    'splitrow works with VISIBLE rows so we need to decrease splitrow with number of hidden rows
    lTimer.StartTimer "Split and freeze"
    r = mUtils.FirstProductRow(ws, False) - 1
    For i = 1 To mUtils.FirstProductRow(ws, False)
        If (ws.Rows(i).Hidden) Then
            r = r - 1
        End If
    Next i
    With ThisWorkbook.Application.ActiveWindow
        .SplitColumn = mUtils.GetSheetSplitColumn(ws)
        .SplitRow = r
        .FreezePanes = True
    End With
    lTimer.StopTimer
    lTimer.StartTimer "Hide rows"
    With ws
        i = mUtils.ColumnHasLovRowIndex

        Do While i > 0
            .Rows(i).Hidden = True
            i = i - 1
        Loop
    End With
    lTimer.StopTimer
    lTimer.StartTimer "Auto-fit"
    AutoFitColumns2 ws
    lTimer.StopTimer
    lTimer.StartTimer "Handle comments"
    Comments_Handle ws
    lTimer.StopTimer
    If (mUtils.HasExtendedSettingsSheet) Then
        Dim annotationsCol As Integer
        annotationsCol = 1 + mUtils.GetLastCol(ws, mUtils.ColumnTypeRowIndex)
        ws.Columns(annotationsCol).Hidden = True
    End If
    mUtils.AutoFilterColumns ws
    SelectFirstCell ws
    prev.Activate


SETUP_ERR:
    lAllTimer.StopTimer
    ThisWorkbook.Application.ScreenUpdating = screenUpd
    ThisWorkbook.Application.EnableEvents = enableEvt
    mUtils.ProtectSheet ws
End Sub

Private Sub Comments_Handle(ws As Worksheet)
 On Error GoTo COMMENTS_ERR
 Dim sglWidth As Single
 Dim lRow As Long
 'only format header comments, the rest is handled by STEPCommentsHandle
 lRow = mUtils.HeaderRow
 Dim startCol As Long
 Dim endCol As Long
 endCol = mUtils.GetLastCol(ws, lRow)
 If mUtils.HasExtendedSettingsSheet Then
    startCol = 2
 Else
    startCol = 1
 End If
 Dim i As Long
 For i = startCol To endCol
    If (Not ws.cells(lRow, i).Comment Is Nothing) Then
        With ws.cells(lRow, i).Comment

            .Shape.AutoShapeType = msoShapeRectangle
            .Shape.TextFrame.AutoSize = True
            .Shape.LockAspectRatio = msoFalse
            If .Shape.Width > 300 Then
                Dim lArea As Long
                lArea = .Shape.Width * .Shape.Height
                .Shape.Width = 250
                ' An adjustment factor of 1.1 seems to work ok.
                .Shape.Height = (lArea / 225) * 1.1
            End If
            .Shape.Line.ForeColor.RGB = RGB(0, 0, 0)
            .Shape.Line.BackColor.RGB = RGB(0, 0, 0)
            .Shape.Fill.Visible = msoTrue
            .Shape.Fill.ForeColor.RGB = RGB(255, 250, 205)
        End With
    End If
 Next i
COMMENTS_ERR:
     err.Clear
End Sub

'gets a range of disjoint areas by leaving out any EXCLEButton columns
Private Function GetAutoFitRange(ByRef ws As Worksheet, ByVal pFirstRow, ByVal pLastRow, ByVal pFirstCol, ByVal pLastCol) As Range
    Set GetAutoFitRange = Nothing
    Dim allRange As Range, tmpRange As Range
    Dim col As Long, start As Long
    Set allRange = Nothing
    start = pFirstCol
    For col = pFirstCol + 1 To pLastCol
        If (mUtils.GetColumnType(ws, col) = EXCELButton) Then
            Set tmpRange = ws.Range(ws.cells(pFirstRow, start), ws.cells(pLastRow, col - 1))
            If (allRange Is Nothing) Then
                Set allRange = tmpRange
            Else
                Set allRange = ThisWorkbook.Application.Union(allRange, tmpRange)
            End If
            start = col + 1
        End If
    Next
    'endpoint - if last column is not a button column
    If (start <= pLastCol) Then 'could do recursive but would run out of memory if no button columns
        Set tmpRange = ws.Range(ws.cells(pFirstRow, start), ws.cells(pLastRow, pLastCol))
        If (allRange Is Nothing) Then
            Set allRange = tmpRange
        Else
            Set allRange = ThisWorkbook.Application.Union(allRange, tmpRange)
        End If
    End If
    Set GetAutoFitRange = allRange
End Function

Private Sub AutoFitColumns2(ws As Worksheet)
    Dim param As String
    param = mUtils.AutofitImportConfiguration
 On Error GoTo AUTOFIT2_ERR
    If param = "STEPRESIZENONE" Then
        Exit Sub
    Else
        Dim lFirstRow As Long
        Dim lLastRow As Long
        Dim lLastCol As Long
        Dim allRange As Range
        lFirstRow = mUtils.HeaderRow 'include headers in autosize
        If (mUtils.HasExtendedSettingsSheet) Then
            lLastRow = mUtils.GetLastRow(ws, 1)
        Else
            If (mUtils.IsInitiateWorkbook) Then
                lLastRow = mUtils.LastInitiateRow(ws)
            Else
                lLastRow = mUtils.GetLastRow(ws, 2)
            End If
        End If
        lLastCol = mUtils.GetLastCol(ws, 2) 'get last column by hidden row
        If (param = "STEPRESIZEAUTOFIT") Then
            Set allRange = GetAutoFitRange(ws, lFirstRow, lLastRow, 2, lLastCol)
            If Not allRange Is Nothing Then
                allRange.VerticalAlignment = xlTop
                allRange.Columns.WrapText = True
                allRange.Rows.AutoFit
            End If
        Else
            'only resize column width by headers and exclude first visible column with the Validate ect. buttons
            Set allRange = GetAutoFitRange(ws, lFirstRow, lFirstRow, 3, lLastCol)
            If Not allRange Is Nothing Then
                allRange.Columns.WrapText = False
                allRange.Columns.AutoFit
                'we might now have ridiculously narrow columns - fix that
                Dim columnIndex As Long
                Dim tmpRange As Range
                For columnIndex = 3 To lLastCol
                    If mUtils.GetColumnType(ws, columnIndex) <> EXCELButton Then
                        Set tmpRange = ws.Range(ws.cells(lFirstRow, columnIndex), ws.cells(lFirstRow, columnIndex))
                        If (tmpRange.ColumnWidth < 20) Then
                            tmpRange.ColumnWidth = 20
                        End If
                    End If
                Next columnIndex
                'ensure vertical allign to on all
                Set allRange = GetAutoFitRange(ws, lFirstRow, lLastRow, 2, lLastCol)
                allRange.Columns.VerticalAlignment = xlTop
                allRange.Columns.WrapText = False
            End If
        End If
    End If
    Exit Sub
AUTOFIT2_ERR:
    Dim logger As New STEPLogger
    logger.Warning "STEPSheetSetup.AutoFitColumns2", "Error applying auto-fit: " & ws.Name & " " & err.Description
    err.Clear
End Sub

Private Sub SelectFirstCell(ws As Worksheet)
    'make a nice selection for the sheet after we messed around with ranges
    On Error GoTo SELECT_FIRST_ERROR
    Dim rng As Range
    Dim col As Long
    If (mUtils.HasExtendedSettingsSheet) Then
        col = 2
    Else
        col = 1
    End If
    Set rng = ws.Range(ws.cells(mUtils.FirstProductRow(ws, False), col), ws.cells(mUtils.FirstProductRow(ws, False), col))
    rng.Select
    Exit Sub
SELECT_FIRST_ERROR:
    err.Clear
End Sub

Private Sub FormatButtonColumns(ws As Worksheet)
    Dim firstRow As Integer, lastRow As Integer
    Dim col As Integer, lastcol As Integer
    firstRow = mUtils.FirstProductRow(ws, False)
    If (mUtils.HasExtendedSettingsSheet) Then
        lastRow = mUtils.GetLastRow(ws, 1)
    Else
        If (mUtils.IsInitiateWorkbook) Then
            lastRow = mUtils.LastInitiateRow(ws)
        Else
            lastRow = mUtils.GetLastRow(ws, 2)
        End If
    End If
    lastcol = mUtils.GetLastCol(ws, mUtils.ColumnTypeRowIndex)

    For col = 1 To lastcol
        If (mUtils.IsColumnButton(ws, col)) Then
            ws.cells(firstRow, col).ColumnWidth = 2.29
            ws.Range(ws.cells(firstRow, col), ws.cells(lastRow, col)).Value = "..."
            mStyleHelper.SetButtonStyle ws.Range(ws.cells(firstRow, col), ws.cells(lastRow, col))
        End If
    Next
End Sub


Private Sub LockCells(ws As Worksheet)
    Dim firstRow As Integer, lastRow As Integer
    Dim col As Integer, lastcol As Integer
    firstRow = mUtils.FirstProductRow(ws, False)
    If (mUtils.HasExtendedSettingsSheet) Then
        lastRow = mUtils.GetLastRow(ws, 1)
    Else
        If (mUtils.IsInitiateWorkbook) Then
            lastRow = mUtils.LastInitiateRow(ws)
        Else
            lastRow = mUtils.GetLastRow(ws, 2)
        End If
    End If
    lastcol = mUtils.GetLastCol(ws, mUtils.ColumnReadOnlyRowIndex)

    For col = 1 To lastcol
        If mUtils.IsColumnReadOnly(ws, col) Then
            ws.Range(ws.cells(firstRow, col), ws.cells(lastRow, col)).Locked = True
        Else
            Dim rng As Range
            Set rng = ws.Range(ws.cells(firstRow, col), ws.cells(lastRow, col))
            If (Not IsNull(rng.Locked)) Then
                rng.Locked = False
            End If
            mUtils.SetNumberFormat rng
        End If
    Next
    'lock headers
    firstRow = mUtils.HeaderRow
    ws.Range(ws.cells(firstRow, 1), ws.cells(firstRow, lastcol)).Locked = True
    'lock template product row
    firstRow = firstRow + 1
    Dim isFirstRowTemplateProductRow As Boolean
    isFirstRowTemplateProductRow = mTemplateProductHelper.isTemplateProductRow(ws.Range(ws.cells(firstRow, 1), ws.cells(firstRow, 1)))
    If (isFirstRowTemplateProductRow = True) Then
        ws.Range(ws.cells(firstRow, 1), ws.cells(firstRow, lastcol)).Locked = True
    End If
End Sub

Public Sub RemoveSheetButton(ws As Worksheet)
    If (Not mUtils.IsProductsSheet(ws)) Then
        Exit Sub
    End If
    On Error GoTo CODE_REMOVE
    ThisWorkbook.Application.EnableEvents = False
    Do While True
        ws.Buttons(1).Delete
        If mUtils.HasExtendedSettingsSheet Then
            ws.Buttons(2).Delete
        End If
    Loop
CODE_REMOVE:
    On Error GoTo ALL_DONE
    With ActiveWorkbook.VBProject.VBComponents(ws.CodeName).CodeModule
        If .CountOfLines > 0 Then
            .DeleteLines 1, .CountOfLines
        End If

    End With
ALL_DONE:
    ThisWorkbook.Application.EnableEvents = True
    On Error GoTo 0
End Sub


Public Sub AddSheetButton(ws As Worksheet)

    If (Not mUtils.IsProductsSheet(ws)) Then
        Exit Sub
    End If

    On Error GoTo ADD_ERR
    Dim top As Long
    Dim cell As Range
    Dim code As String
    Dim lft As Long, tp As Long, hgt As Long, wdt As Long
    Dim buttonRow As Integer
    Dim Index As Integer
    Dim readOnly As Boolean
    ws.Buttons.Delete

    Dim logger As STEPLogger

    If Not mUtils.HasSTEPServerUrl Then
        Set logger = New STEPLogger
        logger.info "STEPSheetSetup.AddSheetButton", "No server URL configured - skipping buttons"
        Set logger = Nothing
        Exit Sub
    End If

    readOnly = True
    For Index = 1 To mUtils.GetLastCol(ws, mUtils.HeaderRow)
        If Not mUtils.IsColumnReadOnly(ws, Index) Then
            readOnly = False
            Exit For
        End If
    Next
    If readOnly Then
        Set logger = New STEPLogger
        logger.info "STEPSheetSetup.AddSheetButton", "All columns read-only; nothing to validate so skipping buttons"
        Set logger = Nothing
        Exit Sub
    End If

    If (ws.Buttons.Count >= 2) And (mUtils.HasExtendedSettingsSheet) Then
    'got it already for SmartSheets
        Exit Sub
    End If

    If (ws.Buttons.Count > 0) And (Not mUtils.HasExtendedSettingsSheet) Then
    'got it already for QuickSheets
        Exit Sub
    End If

    If ws.Buttons.Count > 0 Then
    'got only one button
        If (ws.Buttons.Count = 1) And (ws.Buttons.Item(1).Text = "Validate sheet") And (mUtils.HasExtendedSettingsSheet) Then
            SetUpNextButton ws
            setUpDuplicateRowButton ws
            setUpDeleteRowButton ws
            Exit Sub
        End If
    End If

    buttonRow = mUtils.buttonRow
    If (Not mUtils.HasExtendedSettingsSheet) Then
        Set cell = ws.cells(buttonRow, 1)
    Else
        If (VBA.StrComp("[Additional Header]", ws.cells(buttonRow, 1)) = 0) Then
            buttonRow = buttonRow - 1 'move one up to make room for additional header
        End If
        Set cell = ws.cells(buttonRow, 2)
    End If

    If (Not mUtils.EnableDDR) Then
           lft = cell.Left + 1
        tp = cell.top + 1
        wdt = cell.Width

        If (cell.ColumnWidth < 20) Then
            cell.EntireColumn.ColumnWidth = 20
            wdt = cell.Width
        End If
        hgt = 36
        ws.Rows(buttonRow).RowHeight = (hgt + 4)

    Else
        lft = cell.Left + 1
        tp = cell.top + 1
        wdt = 80
        If (cell.ColumnWidth < 30) Then
            cell.EntireColumn.ColumnWidth = 30
        End If
        hgt = 36
        ws.Rows(buttonRow).RowHeight = (hgt + 4)
    End If

    Dim btn
    Set btn = ws.Buttons.Add(lft, tp, wdt, hgt)

    btn.Characters.Text = mLocale.GetLocalizationString("STEPSheetSetupValidateButton")
    btn.OnAction = "ThisWorkbook.ValidateActiveSheet"
    If mUtils.HasExtendedSettingsSheet Then
        SetUpNextButton ws
        setUpDuplicateRowButton ws
        setUpDeleteRowButton ws
        If (Not mUtils.EnableDDR) Then
            ws.Rows(buttonRow).RowHeight = (hgt + 1) * 2
        End If
    End If
ADD_ERR:
End Sub
Public Sub SetUpNextButton(ws As Worksheet)

If (Not mUtils.IsProductsSheet(ws)) Then
    Exit Sub
End If

Dim lft As Long, tp As Long, hgt As Long, wdt As Long
Dim cell As Range
Dim buttonRow As Integer
Dim btn
buttonRow = mUtils.buttonRow
If (Not mUtils.HasExtendedSettingsSheet) Then
        Set cell = ws.cells(buttonRow, 1)
Else
        Set cell = ws.cells(buttonRow, 2)
End If
If (Not mUtils.EnableDDR) Then
    lft = cell.Left + 1
    tp = 37
    wdt = cell.Width

    If (cell.ColumnWidth < 20) Then
        cell.EntireColumn.ColumnWidth = 20
        wdt = cell.Width
    End If
    hgt = 3
Else
    lft = 81
    tp = cell.top + 1
    wdt = 80

    If (cell.ColumnWidth < 30) Then
        cell.EntireColumn.ColumnWidth = 30
        wdt = cell.Width
    End If

    hgt = 36
    ws.Rows(buttonRow).RowHeight = hgt * 2 + 2
End If


Set btn = ws.Buttons.Add(lft, tp, wdt, hgt)
btn.Characters.Text = mLocale.GetLocalizationString("STEPSheetSetupNextErrorButton")
btn.OnAction = "ThisWorkbook.NextError"
End Sub


Public Sub setUpDuplicateRowButton(ws As Worksheet)
If (Not mUtils.IsProductsSheet(ws) Or Not mUtils.EnableDDR) Then
    Exit Sub
End If

Dim lft As Long, tp As Long, hgt As Long, wdt As Long
Dim cell As Range
Dim buttonRow As Integer
Dim btn
buttonRow = mUtils.buttonRow
If (Not mUtils.HasExtendedSettingsSheet) Then
        Set cell = ws.cells(buttonRow, 1)
Else
        Set cell = ws.cells(buttonRow, 2)
End If
lft = cell.Left + 1
tp = 37
wdt = 80

    If (cell.ColumnWidth < 30) Then
        cell.EntireColumn.ColumnWidth = 30
    End If
hgt = 36
ws.Rows(buttonRow).RowHeight = hgt * 2 + 2
Set btn = ws.Buttons.Add(lft, tp, wdt, hgt)
btn.Characters.Text = mLocale.GetLocalizationString("STEPSheetSetupDuplicateRowButton")
btn.OnAction = "ThisWorkbook.DuplicateRow"
End Sub

Public Sub setUpDeleteRowButton(ws As Worksheet)
If (Not mUtils.IsProductsSheet(ws) Or Not mUtils.EnableDDR) Then
    Exit Sub
End If

Dim lft As Long, tp As Long, hgt As Long, wdt As Long
Dim cell As Range
Dim buttonRow As Integer
Dim btn
buttonRow = mUtils.buttonRow
If (Not mUtils.HasExtendedSettingsSheet) Then
        Set cell = ws.cells(buttonRow, 1)
Else
        Set cell = ws.cells(buttonRow, 2)
End If
lft = 81
tp = 37
wdt = 80
    If (cell.ColumnWidth < 30) Then
        cell.EntireColumn.ColumnWidth = 30
    End If

hgt = 36
ws.Rows(buttonRow).RowHeight = hgt * 2 + 2
Set btn = ws.Buttons.Add(lft, tp, wdt, hgt)
btn.Characters.Text = mLocale.GetLocalizationString("STEPSheetSetupDeleteRowButton")
btn.OnAction = "ThisWorkbook.DeleteRow"
End Sub
Attribute VB_Name = "STEPSheetUtils"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public Enum STEPColumnType
    STEPUndefined = 0
    STEPID = 1
    STEPName = 2
    STEPAttribute = 3
    STEPReference = 4
    STEPParentID = 5
    STEPBatch = 6
    STEPLink = 7
    STEPReadOnly = 8 'do not know content but don't care - must ALWAYS be read only
    STEPObjectType = 9
    EXCELButton = 10
    STEPSupplier = 11
    STEPWorkingColumn = 12
End Enum

Public Enum STEPColumnBaseValidationType
    STEPNotClientRelevant = 0   'does not matter client side
    STEPNumber = 1              'base validation type number
    STEPNumberRange = 2         'number-range
    STEPEmbeddedNumber = 3      'embedded number - not sure we can handle anyway
End Enum

Public Enum STEPSmartSheetType
    STEPNotApplicaple = 0
    STEPMultiLevelType = 1
    STEPMultiObjectTypeType = 2
    STEPCustomType = 3
End Enum

Private Const SETTING_VALUE_COL = 2
Private Const SETTING_STATEFLOW_ROW = 1
Private Const SETTING_STATE_ROW = 2
Private Const SETTING_CONTEXT_ROW = 3
Private Const SETTING_WORKSPACE_ROW = 4
Private Const SETTING_STEPURL_ROW = 5
Private Const SETTING_ISINITIATE_ROW = 6
Private Const SETTING_MULTISEP_ROW = 7
Private Const SETTING_INITIATE_OBJECTTYPEID_ROW = 8
Private Const SETTING_INITIATE_ROOTPRODUCTID_ROW = 9
Private Const SETTING_INITIATE_ROOT_OBJECTTYPEID_ROW = 10
Private Const SETTING_INITIATE_USEAUTOID_ROW = 11
Private Const SETTING_FIRSTPRODUCT_ROW = 11
Private Const SETTING_SUPPLIERGROUP_ROW = 12
Private Const SETTING_CREATE_TARGET_TYPE = 26
Private Const SETTING_CREATE_TARGET_PREFIX = 27
Private Const SETTING_CREATE_TARGET_PARENT = 28
Private Const SETTING_AUTHENTICATION_METHOD = 76

'keeps track of lovs applied from code - NOT BORN IN THE STEP EXPORT
Private Const SETTING_LOVS_APPLIED_ROW = 16
'same as above
Private Const SETTING_INHERITANCE_APPLIED_ROW = 17
'object types in smartsheets
Private Const SETTING_PRODUCT_OBJECT_TYPES = 31
'instruction about using or ignoring local decimal separator
Private Const SETTING_USE_LOCAL_DECIMAL_SEPARATOR_ROW = 40
'keeps track of last used separators - applies only to smartsheets
Private Const SETTING_LAST_APPLIED_DECIMAL_SEPARATOR_ROW = 41
'tracking if smartsheet importer errors has been applied to product sheets
Private Const SETTING_IMPORTER_ERRORS_APPLIED = 42

'smartsheet import configuration for businees rules and import; selected on export configuration
Private Const SETTING_IMPORT_CONFIGURATION = 50
'smartsheet autosize mode
Private Const SETTING_AUTOSIZE_MODE = 51
'smartsheet type now we have multilevel, multiobjecttype and custom
Private Const SETTING_SMARTSHEET_TYPE = 53
'custom smartsheet format-plugin (NOTHING TO DO WITH IMPORTER PLUGINS)
Private Const SETTING_CUSTOM_PLUGIN = 54
'custom smartsheet can allow other node types than products but must handle it themselves
Private Const SETTING_CUSTOM_NODE_TYPES = 55
'locale configuration setting
Private Const SETTING_LOCALE_CONFIGURATION = 56
'multiple supplier smartsheet - relates to the SETTING_SUPPLIER_* constants below
Private Const SETTING_MULTISUPPLIER_SMARTSHEET = 57
'multiple supplier smartsheet - optional separator
Private Const SETTING_CREATE_TARGET_SEPARATOR = 58
'a number of preformatted rows in a template
Private Const SETTING_PREFORMATTED_TEMPLATE_ROWS = 62
'products sheets identifier row
Private Const PRODUCSHEET_INDENTIFIERS_ROW = 1
Private Const PRODUCSHEET_PRODUCTSSHEET_IDENTIFIER_COL = 1
Private Const PRODUCSHEET_PRODUCTSSHEET_CATEGORY_COL = 2
Private Const PRODUCSHEET_PRODUCTSSHEET_INITIATE_PARENT_COL = 4
Private Const PRODUCSHEET_SHEETKEY_COL = 6
Private Const PRODUCSHEET_SHEETNAME_MIRROR_COL = 8 'Store original sheet-name so error/change tracking does not break

'indexes into setting-sheet for info on selectable suppliers
Private Const SETTING_SUPPLIER_INFO_FIRST_ROW = 4
Private Const SETTING_SUPPLIER_INFO_KEY_COL = 21
Private Const SETTING_SUPPLIER_INFO_ID_COL = 22
Private Const SETTING_SUPPLIER_INFO_PC_COL = 23
Private Const SETTING_SUPPLIER_INFO_AC_COL = 24

Private Const ERR_MISSING_SUPPLIER_SELECTOR = vbObjectError + 17341
'enable filtering for columns
Private Const SETTING_USE_FILTER = 70

'enable text formatting in cells on protected sheets
Private Const SETTING_ENABLE_TEXT_FORMAT = 72

'enables delete/duplicate row functionality
Private Const SETTING_ENABLE_DDR = 75

Private Const SETTING_ADD_WORKING_COLUMN = 77

Private mSettingsSheet As Worksheet
Private mSettingSheetState As Integer

Private mExtendedSettingsSheet As Worksheet
Private mExtendedSettingSheetState As Integer

Private mLocale As New STEPLocalization

Private mTemplateProductHelper As New STEPTemplateProductHelper

Private Const C_SECRET = "Secret"
Private Const C_SHEET_NAME = "STEPSettings"
Private Const C_EXTENDED_SETTINGS_SHEET = "STEPSmartSheetSettings"
Private Const C_DEFAULT_MULTISEP = "<multisep/>"
Private Const C_PRODUCTSSHEET_IDENTIFIER = "ProductsSheet"
'this constant matches on with same name in SmartsheetConstans serverside - indicates that parent id from
'setting sheet should NOT be used - instead use category id from sheet row one column two
Private Const MULTIPLE_CATEGORIES_TEMPLATE = "[multiple categories template]"

Private Const C_TYPE_MULTILEVEL = "SheetTypeMultiLevel"
Private Const C_TYPE_MULTIOBJECTTYPE = "SheetTypeMultiObjectType"
Private Const C_TYPE_CUSTOM = "SheetTypeCustom"


'only initialize on request
Private mSupplierInfoCollection As Collection

Private Sub Class_Initialize()
    mSettingSheetState = 0
    mExtendedSettingSheetState = 0
End Sub


Public Property Get ColumnTypeRowIndex() As Long
    'products sheet row for column types - ID, Name, Attribute, Asset, Classification, Parent
    ColumnTypeRowIndex = 2
End Property


Public Function GetColumnType(ws As Worksheet, ByVal columnIndex As Long) As STEPColumnType
    Dim s As String
    s = ws.cells(Me.ColumnTypeRowIndex, columnIndex).Value
    Select Case s
        Case "ID"
            GetColumnType = STEPID
        Case "Name"
            GetColumnType = STEPName
        Case "Attribute"
            GetColumnType = STEPAttribute
        Case "Reference"
            GetColumnType = STEPReference
        Case "Parent"
            GetColumnType = STEPParentID
        Case "Batch"
            GetColumnType = STEPBatch
        Case "ExcelButton"
            GetColumnType = EXCELButton
        Case "Link"
            GetColumnType = STEPLink
        Case "ReadOnlyColumn"
            GetColumnType = STEPReadOnly
        Case "ObjectType"
            GetColumnType = STEPObjectType
        Case "Supplier"
            GetColumnType = STEPSupplier
        Case "WorkingColumn"
            GetColumnType = STEPWorkingColumn
        Case Else
            GetColumnType = STEPUndefined
    End Select
End Function

Public Property Get AutofitImportConfiguration() As String
    AutofitImportConfiguration = "STEPRESIZENONE" 'Default value
    If (HasSettingsSheet And HasExtendedSettingsSheet) Then 'if smartsheet then
        Dim s As String
        s = VBA.Trim(SettingsSheet.cells(SETTING_AUTOSIZE_MODE, 2).Value)
        If (StrComp("STEPRESIZECOLUMN", s, vbTextCompare) = 0) Then
            AutofitImportConfiguration = "STEPRESIZECOLUMN"
        Else
            If (StrComp("STEPRESIZEAUTOFIT", s, vbTextCompare) = 0) Then
                AutofitImportConfiguration = "STEPRESIZEAUTOFIT"
            End If
        End If
    End If
End Property
Public Property Get LocaleConfiguration() As String
    Dim s As String
    'Default Configuration
    LocaleConfiguration = ""
    s = VBA.Trim(SettingsSheet.cells(SETTING_LOCALE_CONFIGURATION, 2).Value)
    If Not IsEmpty(s) And s <> "" Then
        LocaleConfiguration = s
    End If
End Property

Public Function GetInitiateObjectTypeId() As String
    GetInitiateObjectTypeId = SettingsSheet.cells(SETTING_INITIATE_OBJECTTYPEID_ROW, 2)
End Function

Public Function GetInitiateRootProductId() As String
    GetInitiateRootProductId = SettingsSheet.cells(SETTING_INITIATE_ROOTPRODUCTID_ROW, 2)
End Function

Public Function GetInitiateRootObjectTypeId() As String
    GetInitiateRootObjectTypeId = SettingsSheet.cells(SETTING_INITIATE_ROOT_OBJECTTYPEID_ROW, 2)
End Function

'new MultiObjectTypeSmartsheet allows the user to select object type for new products to create for each row
Public Function GetRowInitiateObjectType(ByVal ws As Worksheet, ByVal row As Long, ByRef objectTypeColumnIndex As Long) As String
    objectTypeColumnIndex = -1
    GetRowInitiateObjectType = ""
    If Not IsProductsSheet(ws) Then
        Exit Function
    End If
    If (IsInitiateWorkbook) Then
        GetRowInitiateObjectType = GetInitiateObjectTypeId
        If (SmartSheetType = STEPMultiObjectTypeType) Then
            Dim Index As Integer
            Dim mColcount As Integer
            mColcount = GetLastCol(ws, ColumnTypeRowIndex)
            Dim firstLevel As Integer
            firstLevel = GetColumnSourceLevel(ws, 1)
            For Index = 1 To mColcount
                If (GetColumnSourceLevel(ws, Index) > firstLevel) Then
                    Exit Function
                End If
                If (GetColumnType(ws, Index) = STEPObjectType) Then
                    If Not IsColumnReadOnly(ws, Index) Then
                        objectTypeColumnIndex = Index
                        GetRowInitiateObjectType = ws.cells(row, Index).Value
                        Exit Function
                    End If
                End If

            Next
        End If

    End If
End Function

Public Property Get ColumnIDRowIndex() As Long
    'products sheet row for column id (attribute-id, classification -type ect
    ColumnIDRowIndex = 3
End Property

Public Function GetColumnID(ws As Worksheet, ByVal lCol As Long) As String
    'products sheet column id (attribute-id, classification -type asset-type ect
    GetColumnID = ws.cells(Me.ColumnIDRowIndex, lCol).Value
End Function

Public Function GetColumnHeader(ws As Worksheet, ByVal lCol As Long) As String
    'products sheet headers
    GetColumnHeader = ws.cells(Me.HeaderRow, lCol).Value
End Function

Public Property Get ColumnReadOnlyRowIndex() As Long
    'products sheet row for marking column readonly
    ColumnReadOnlyRowIndex = 4
End Property

Public Function IsColumnReadOnly(ws As Worksheet, ByVal lCol As Long)
    'test if column is readonly
    IsColumnReadOnly = CBool(ws.cells(ColumnReadOnlyRowIndex, lCol).Value)
End Function

Public Function IsColumnMandatory(ws As Worksheet, ByVal lCol As Long)
    'test if column is mandatory
    IsColumnMandatory = CBool(ws.cells(ColumnMandatoryRowIndex, lCol).Value)
End Function

Public Function IsColumnButton(ws As Worksheet, ByVal lCol As Long)
    'test if column is "ExcelButton"
    IsColumnButton = (Me.GetColumnType(ws, lCol) = EXCELButton)
End Function

Public Function IsWorkingColumn(ws As Worksheet, ByVal lCol As Long)
    'test if column is "WorkingColumn"
    IsWorkingColumn = (Me.GetColumnType(ws, lCol) = STEPWorkingColumn)
End Function

Public Function IsColumnMultivalued(ws As Worksheet, ByVal lCol As Long)
    'test if column is multivalued
    IsColumnMultivalued = CBool(ws.cells(ColumnMultivaluedRowIndex, lCol).Value)
End Function

Public Function HasColumnLov(ws As Worksheet, ByVal lCol As Long)
    'test if column is has lov
    Dim s As String
    s = ws.cells(ColumnHasLovRowIndex, lCol).Value
    s = VBA.Trim(s)
    If (Len(s) > 0) Then
        If (VBA.LCase(s) = "false") Then
            HasColumnLov = False
        Else
            HasColumnLov = True
        End If
    Else
        HasColumnLov = False
    End If
End Function

Public Property Get ColumnLOVIdentifier(ws As Worksheet, ByVal lCol As Long) As String
    Dim s As String
    s = ws.cells(ColumnHasLovRowIndex, lCol).Value
    s = VBA.Trim(s)
    If (Len(s) > 0) Then
        If (s = "false") Then
            ColumnLOVIdentifier = ""
        ElseIf (s = "true") Then
            ColumnLOVIdentifier = GetColumnID(ws, lCol)
        Else
            ColumnLOVIdentifier = s
        End If
    Else
        ColumnLOVIdentifier = False
    End If
End Property

Public Property Get ColumnMandatoryRowIndex() As Long
    'products sheet row for marking column as mandatory
    ColumnMandatoryRowIndex = 5
End Property

Public Property Get ColumnMultivaluedRowIndex() As Long
    'products sheet row for marking column as multivalued
    ColumnMultivaluedRowIndex = 6
End Property

Public Property Get ColumnHasLovRowIndex() As Long
    'products sheet row for marking column as having a list of values
    ColumnHasLovRowIndex = 7
End Property

Public Property Get ColumnInheritanceRowIndex() As Long
    'products sheet row for marking column as having a list of values
    ColumnInheritanceRowIndex = 8
End Property

Public Property Get SettingsSheet() As Worksheet
    'settings sheet with this name must be created by STEP excel export
    If (0 = mSettingSheetState) Then
        On Error Resume Next
        Set mSettingsSheet = ThisWorkbook.Worksheets(C_SHEET_NAME)

        If (Not mSettingsSheet Is Nothing) Then
            mSettingSheetState = 1
            Set SettingsSheet = mSettingsSheet
        Else
            mSettingSheetState = -1
        End If
    ElseIf (1 = mSettingSheetState) Then
        Set SettingsSheet = mSettingsSheet
    Else
        Set SettingsSheet = Nothing
    End If
End Property

Public Property Get ExtendedSettingsSheet() As Worksheet
    'settings sheet with this name must be created by STEP excel export
    If (0 = mExtendedSettingSheetState) Then
        On Error Resume Next
        Set mExtendedSettingsSheet = ThisWorkbook.Worksheets(C_EXTENDED_SETTINGS_SHEET)

        If (Not mExtendedSettingsSheet Is Nothing) Then
            mExtendedSettingSheetState = 1
            Set ExtendedSettingsSheet = mExtendedSettingsSheet
        Else
            mExtendedSettingSheetState = -1
        End If
    ElseIf (1 = mExtendedSettingSheetState) Then
        Set ExtendedSettingsSheet = mExtendedSettingsSheet
    Else
        Set ExtendedSettingsSheet = Nothing
    End If
End Property

Public Property Get HasSettingsSheet()
    If (1 = mSettingSheetState) Then
        HasSettingsSheet = True
    ElseIf (0 = mSettingSheetState) Then
        Dim void As Worksheet
        Set void = SettingsSheet
        HasSettingsSheet = (1 = mSettingSheetState)
    Else
        HasSettingsSheet = False
    End If
End Property

Public Property Get HasExtendedSettingsSheet()
    If (1 = mExtendedSettingSheetState) Then
        HasExtendedSettingsSheet = True
    ElseIf (0 = mExtendedSettingSheetState) Then
        Dim void As Worksheet
        Set void = ExtendedSettingsSheet
        HasExtendedSettingsSheet = (1 = mExtendedSettingSheetState)
    Else
        HasExtendedSettingsSheet = False
    End If
End Property

Public Property Get SmartSheetType() As STEPSmartSheetType
    SmartSheetType = STEPNotApplicaple
    If HasExtendedSettingsSheet And HasSettingsSheet Then
        Dim s As String
        s = mSettingsSheet.cells(SETTING_SMARTSHEET_TYPE, SETTING_VALUE_COL)
        Select Case s
            Case C_TYPE_MULTIOBJECTTYPE
                SmartSheetType = STEPMultiObjectTypeType
            Case C_TYPE_CUSTOM
                SmartSheetType = STEPCustomType
            Case Else
                SmartSheetType = STEPMultiLevelType 'for now default - but shouldn't really happen
        End Select
    End If
End Property

Public Property Get SmartSheetTypeName() As String
    Select Case SmartSheetType
        Case STEPMultiLevelType
            SmartSheetTypeName = C_TYPE_MULTILEVEL
        Case STEPCustomType
            SmartSheetTypeName = C_TYPE_CUSTOM
        Case STEPMultiObjectTypeType
            SmartSheetTypeName = C_TYPE_MULTIOBJECTTYPE
        Case Else
            SmartSheetTypeName = ""
    End Select
End Property

Public Property Get SmartSheetCustomPlugin() As String
    SmartSheetCustomPlugin = ""
    If HasExtendedSettingsSheet And HasSettingsSheet Then
        SmartSheetCustomPlugin = mSettingsSheet.cells(SETTING_CUSTOM_PLUGIN, SETTING_VALUE_COL)
    End If
End Property

Public Property Get SmartSheetCustomNodeTypes() As Boolean
    SmartSheetCustomNodeTypes = False
    If HasExtendedSettingsSheet And HasSettingsSheet Then
        Dim s As String
        s = mSettingsSheet.cells(SETTING_CUSTOM_NODE_TYPES, SETTING_VALUE_COL)
        If (s <> "") Then
            SmartSheetCustomNodeTypes = CBool(s)
        End If
    End If
End Property

Public Function GetSheetKey(ws As Worksheet)
    GetSheetKey = ""
    If (IsProductsSheet(ws)) Then
        GetSheetKey = ws.cells(PRODUCSHEET_INDENTIFIERS_ROW, PRODUCSHEET_SHEETKEY_COL)
    End If
End Function

Public Function IsCreateTargetColumn(ws As Worksheet, ByVal columnIndex As Long)
    If (Not IsProductsSheet(ws)) Then
        IsCreateTargetColumn = False
    ElseIf (Not HasExtendedSettingsSheet) Then
        IsCreateTargetColumn = False
    Else
        IsCreateTargetColumn = False
        Dim coltype As STEPColumnType
        coltype = GetColumnType(ws, columnIndex)
        If (STEPLink = coltype Or STEPReference = coltype) Then
            Dim sheetKey As String
            sheetKey = GetSheetKey(ws)
            If Not sheetKey = "" Then
                Dim found As Range
                Set found = mExtendedSettingsSheet.Columns(1).Find(what:=sheetKey, _
                            LookAt:=xlWhole, _
                            SearchDirection:=xlNext, _
                            SearchOrder:=xlByRows)
                If (Not found Is Nothing) Then
                    Dim rowIndex As Long
                    rowIndex = found.row
                    Dim val As String
                    val = mExtendedSettingsSheet.cells(rowIndex + 8, columnIndex)
                    If ("true" = val) Then
                        IsCreateTargetColumn = True
                    End If
                End If
                UnmarkMatchEntireCellContents

            End If
        End If
    End If
End Function
Public Function GetColumnSourceLevel(ws As Worksheet, ByVal columnIndex As Long)
    GetColumnSourceLevel = 0
    If (columnIndex > 1 And IsProductsSheet(ws) And HasExtendedSettingsSheet) Then
        Dim sheetKey As String
        sheetKey = GetSheetKey(ws)
        If Not sheetKey = "" Then
            Dim found As Range
            Set found = mExtendedSettingsSheet.Columns(1).Find(what:=sheetKey, _
                        LookAt:=xlWhole, _
                        SearchDirection:=xlNext, _
                        SearchOrder:=xlByRows)
            If (Not found Is Nothing) Then
                Dim coltype As STEPColumnType
                coltype = GetColumnType(ws, columnIndex)
                If (EXCELButton = coltype) Then
                    GetColumnSourceLevel = -1
                Else
                    Dim rowIndex As Long
                    rowIndex = found.row
                    Dim val As String
                    val = mExtendedSettingsSheet.cells(rowIndex + 5, columnIndex)
                    GetColumnSourceLevel = CInt(val)
                End If
            End If
            UnmarkMatchEntireCellContents
        End If
    End If
End Function

Public Function GetUseLOVID(ws As Worksheet, ByVal columnIndex As Long)
    GetUseLOVID = ""
    If (IsProductsSheet(ws) And HasExtendedSettingsSheet) Then
        Dim sheetKey As String
        sheetKey = GetSheetKey(ws)
        If Not sheetKey = "" Then
            Dim found As Range
            Set found = mExtendedSettingsSheet.Columns(1).Find(what:=sheetKey, _
                        LookAt:=xlWhole, _
                        SearchDirection:=xlNext, _
                        SearchOrder:=xlByRows)
            If (Not found Is Nothing) Then
                If (1 < columnIndex) Then
                    Dim coltype As STEPColumnType
                    coltype = GetColumnType(ws, columnIndex)
                    If (EXCELButton <> coltype) Then
                        Dim rowIndex As Long
                        rowIndex = found.row
                        Dim val As String
                        val = mExtendedSettingsSheet.cells(rowIndex + 10, columnIndex)
                        GetUseLOVID = val
                    End If
                End If
            End If
            UnmarkMatchEntireCellContents
        End If
    End If
End Function

Public Function GetColumnSourceObjectTypeID(ws As Worksheet, ByVal columnIndex As Long)
    GetColumnSourceObjectTypeID = ""
    If (IsProductsSheet(ws) And HasExtendedSettingsSheet) Then
        Dim sheetKey As String
        sheetKey = GetSheetKey(ws)
        If Not sheetKey = "" Then
            Dim found As Range
            Set found = mExtendedSettingsSheet.Columns(1).Find(what:=sheetKey, _
                        LookAt:=xlWhole, _
                        SearchDirection:=xlNext, _
                        SearchOrder:=xlByRows)
            If (Not found Is Nothing) Then
                If (1 < columnIndex) Then
                    Dim coltype As STEPColumnType
                    coltype = GetColumnType(ws, columnIndex)
                    If (EXCELButton <> coltype) Then
                        Dim rowIndex As Long
                        rowIndex = found.row
                        Dim val As String
                        val = mExtendedSettingsSheet.cells(rowIndex + 6, columnIndex)
                        GetColumnSourceObjectTypeID = val
                    End If
                End If
            End If
            UnmarkMatchEntireCellContents
        End If
    End If
End Function
Public Function GetColumnContextID(ws As Worksheet, ByVal columnIndex As Long)
    GetColumnContextID = ""
    If (IsProductsSheet(ws) And HasExtendedSettingsSheet) Then
        Dim sheetKey As String
        sheetKey = GetSheetKey(ws)
        If Not sheetKey = "" Then
            Dim found As Range
            Set found = mExtendedSettingsSheet.Columns(1).Find(what:=sheetKey, _
                        LookAt:=xlWhole, _
                        SearchDirection:=xlNext, _
                        SearchOrder:=xlByRows)
            If (Not found Is Nothing) Then
                If (1 < columnIndex) Then
                    Dim coltype As STEPColumnType
                    coltype = GetColumnType(ws, columnIndex)
                    If (EXCELButton <> coltype) Then
                        Dim rowIndex As Long
                        rowIndex = found.row
                        Dim val As String
                        val = mExtendedSettingsSheet.cells(rowIndex + 7, columnIndex)
                        GetColumnContextID = val
                    End If
                End If
            End If
            UnmarkMatchEntireCellContents
        End If
    End If
End Function
Public Function GetBaseValidationType(ws As Worksheet, ByVal columnIndex As Long) As STEPColumnBaseValidationType
    GetBaseValidationType = STEPNotClientRelevant
    If (IsProductsSheet(ws) And HasExtendedSettingsSheet) Then
        Dim sheetKey As String
        sheetKey = GetSheetKey(ws)
        If Not sheetKey = "" Then
            Dim found As Range
            Set found = mExtendedSettingsSheet.Columns(1).Find(what:=sheetKey, _
                        LookAt:=xlWhole, _
                        SearchDirection:=xlNext, _
                        SearchOrder:=xlByRows)
            If (Not found Is Nothing) Then
                If (1 < columnIndex) Then
                    Dim coltype As STEPColumnType
                    coltype = GetColumnType(ws, columnIndex)
                    If (EXCELButton <> coltype) Then
                        Dim rowIndex As Long
                        rowIndex = found.row
                        Dim val As String
                        val = mExtendedSettingsSheet.cells(rowIndex + 11, 1)
                        'this rows existence should be in sync whith the code but just checking
                        If (StrComp("Validation Base-type", val) = 0) Then
                            val = mExtendedSettingsSheet.cells(rowIndex + 11, columnIndex)
                            Select Case val
                                Case "number"
                                    GetBaseValidationType = STEPNumber
                                Case "numberrange"
                                    GetBaseValidationType = STEPNumberRange
                                Case "embedded_number"
                                    GetBaseValidationType = STEPEmbeddedNumber
                                Case Else
                                    GetBaseValidationType = STEPNotClientRelevant
                            End Select


                        End If
                    End If
                End If
            End If
            UnmarkMatchEntireCellContents
        End If
    End If
End Function

Public Function GetSheetAnnotation(ws As Worksheet) As String
    GetSheetAnnotation = ""
    If (IsProductsSheet(ws) And HasExtendedSettingsSheet) Then
        Dim sheetKey As String
        sheetKey = GetSheetKey(ws)
        If sheetKey = "" Then _
            Exit Function
        Dim found As Range
        Set found = mExtendedSettingsSheet.Columns(1).Find(what:=sheetKey, _
                    LookAt:=xlWhole, _
                    SearchDirection:=xlNext, _
                    SearchOrder:=xlByRows)
        If (Not found Is Nothing) Then
            Dim rowIndex As Long
            rowIndex = found.row
            GetSheetAnnotation = mExtendedSettingsSheet.cells(rowIndex, 8).Value
        End If
        UnmarkMatchEntireCellContents
    End If
End Function

Public Function GetSheetSplitColumn(ws As Worksheet) As Integer
    Dim wanted As Integer
    wanted = 1
    Dim realCnt As Integer
    Dim idx As Integer
    Dim maxCol As Integer
    Dim issmart As Boolean
    issmart = False
    If (IsProductsSheet(ws) And HasExtendedSettingsSheet) Then
        issmart = True
        Dim sheetKey As String
        sheetKey = GetSheetKey(ws)
        If sheetKey = "" Then _
            Exit Function
        Dim found As Range
        Set found = mExtendedSettingsSheet.Columns(1).Find(what:=sheetKey, _
                    LookAt:=xlWhole, _
                    SearchDirection:=xlNext, _
                    SearchOrder:=xlByRows)
        If (Not found Is Nothing) Then
            Dim rowIndex As Long
            rowIndex = found.row
            Dim tmp As String
            tmp = mExtendedSettingsSheet.cells(rowIndex, 3).Value
            If (VBA.IsNumeric(tmp)) Then
                wanted = VBA.CInt(tmp)
            End If
            If (wanted < 1) Then
                wanted = 1
            End If
        End If
        UnmarkMatchEntireCellContents
    End If
    realCnt = VBA.IIf(issmart, 1, 0) 'setting split disregards hidden columns
    maxCol = Me.GetLastCol(ws, Me.ColumnTypeRowIndex)
    For idx = 1 To maxCol
        realCnt = realCnt + 1
        If (Me.GetColumnType(ws, idx) <> EXCELButton) Then
            wanted = wanted - 1
            If (wanted < 1) Then GoTo DONE_LOOP
        End If
    Next idx
DONE_LOOP:
    If (realCnt < maxCol) Then
        If (Me.GetColumnType(ws, (realCnt + 1)) = EXCELButton) Then
            realCnt = realCnt + 1
        End If
    End If
    If (realCnt < maxCol) Then
        If (AddWorkingColumn And IsWorkingColumn(ws, (realCnt + 1))) Then
            realCnt = realCnt + 1
        End If
    End If
    GetSheetSplitColumn = VBA.IIf(issmart, realCnt - 1, realCnt)
End Function

Public Function GetColumnAnnotation(ws As Worksheet, ByVal columnIndex As Long) As String
    GetColumnAnnotation = ""
    If (IsProductsSheet(ws) And HasExtendedSettingsSheet) Then
        Dim sheetKey As String
        sheetKey = GetSheetKey(ws)
        If Not sheetKey = "" Then
            Dim found As Range
            Set found = mExtendedSettingsSheet.Columns(1).Find(what:=sheetKey, _
                        LookAt:=xlWhole, _
                        SearchDirection:=xlNext, _
                        SearchOrder:=xlByRows)
            If (Not found Is Nothing) Then
                If (1 < columnIndex) Then
                    Dim coltype As STEPColumnType
                    coltype = GetColumnType(ws, columnIndex)
                    If (EXCELButton <> coltype) Then
                        Dim rowIndex As Long
                        rowIndex = found.row
                        Dim val As String
                        val = mExtendedSettingsSheet.cells(rowIndex + 14, 1)
                        'this rows existence should be in sync whith the code but just checking
                        If (StrComp("Column Annotation", val) = 0) Then
                            GetColumnAnnotation = mExtendedSettingsSheet.cells(rowIndex + 14, columnIndex)
                        End If
                    End If
                End If
            End If
            UnmarkMatchEntireCellContents
        End If
    End If
End Function

Public Property Get GetCreateTargetPrefix() As String
    If ((Not HasSettingsSheet) Or (Not HasExtendedSettingsSheet)) Then
        GetCreateTargetPrefix = ""
    Else
        GetCreateTargetPrefix = SettingsSheet.cells(SETTING_CREATE_TARGET_PREFIX, SETTING_VALUE_COL).Value
    End If

End Property

Public Property Get GetCreateTargetType() As String
    If ((Not HasSettingsSheet) Or (Not HasExtendedSettingsSheet)) Then
        GetCreateTargetType = ""
    Else
        GetCreateTargetType = SettingsSheet.cells(SETTING_CREATE_TARGET_TYPE, SETTING_VALUE_COL).Value
    End If
End Property

Public Property Get GetCreateTargetParent() As String
    If ((Not HasSettingsSheet) Or (Not HasExtendedSettingsSheet)) Then
        GetCreateTargetParent = ""
    Else
        GetCreateTargetParent = SettingsSheet.cells(SETTING_CREATE_TARGET_PARENT, SETTING_VALUE_COL).Value
    End If
End Property


Public Property Get GetIDColumnIndex() As Long
          GetIDColumnIndex = 1
End Property

Public Function IsProductsSheet(ws As Worksheet) As Boolean
    'test if a sheet is a producs sheet - topleft cell filled with "ProductsSheet" by STEP excel exporter
    IsProductsSheet = ws.cells(PRODUCSHEET_INDENTIFIERS_ROW, PRODUCSHEET_PRODUCTSSHEET_IDENTIFIER_COL).Value = C_PRODUCTSSHEET_IDENTIFIER
End Function

Public Function GetSheetProductsCategory(ws As Worksheet) As String
    GetSheetProductsCategory = ""
    'get the category (parent id in primary product hiercy) for a sheet - created by exporter (on sheet per category) in cell row1 column 2
    If (IsProductsSheet(ws)) Then
        GetSheetProductsCategory = ws.cells(PRODUCSHEET_INDENTIFIERS_ROW, PRODUCSHEET_PRODUCTSSHEET_CATEGORY_COL)
    End If
End Function

Public Function GetSheetInitiateRootProductId(ws As Worksheet) As String
    GetSheetInitiateRootProductId = ""
    'get the category (parent id in primary product hiercy) for a sheet - created by exporter (on sheet per category) in cell row1 column 2
    If (IsProductsSheet(ws)) Then
        GetSheetInitiateRootProductId = ws.cells(PRODUCSHEET_INDENTIFIERS_ROW, PRODUCSHEET_PRODUCTSSHEET_INITIATE_PARENT_COL)
    End If
End Function

Public Property Get STEPContext() As String
    'return contex from setting sheet - must be created by exporter in cell row 3, column 2
    If (HasSettingsSheet) Then
        STEPContext = SettingsSheet.cells(SETTING_CONTEXT_ROW, SETTING_VALUE_COL).Value
    Else
        STEPContext = ""
    End If
End Property

Public Property Get STEPWorkspace() As String
    'return Workspace from setting sheet - must be created by exporter in cell row 4, column 2
    If (HasSettingsSheet) Then
        STEPWorkspace = SettingsSheet.cells(SETTING_WORKSPACE_ROW, SETTING_VALUE_COL).Value
    Else
        STEPWorkspace = ""
    End If
End Property

Public Property Get STEPStateFlow() As String
    'return optional stateflow from from setting sheet - must be created by exporter in cell row 1, column 2
    If (HasSettingsSheet) Then
        STEPStateFlow = SettingsSheet.cells(SETTING_STATEFLOW_ROW, SETTING_VALUE_COL).Value
    Else
        STEPStateFlow = ""
    End If
End Property

Public Property Get STEPState() As String
    'return optional stateflow-state from from setting sheet - must be created by exporter in cell row 2, column 2
    If (HasSettingsSheet) Then
        STEPState = SettingsSheet.cells(SETTING_STATE_ROW, SETTING_VALUE_COL).Value
    Else
        STEPState = ""
    End If
End Property

Public Property Get STEPServerURL() As String
    STEPServerURL = ""
    If (Not STEPLoginForm Is Nothing) Then
        STEPServerURL = STEPLoginForm.CurrentSTEPServerURL
    End If
End Property

Public Property Get STEPSupplierGroup() As String
    If (HasSettingsSheet) Then
        STEPSupplierGroup = SettingsSheet.cells(SETTING_SUPPLIERGROUP_ROW, SETTING_VALUE_COL).Value
    Else
        STEPSupplierGroup = ""
    End If
End Property

Public Function GetSTEPServerURLCollection() As String()
    'return url to stepserver where workbook was born - required for online validation - created by excel exporter in cell row 5, column 2
    If (HasSettingsSheet) Then
        Dim url As String
        url = SettingsSheet.cells(SETTING_STEPURL_ROW, SETTING_VALUE_COL).Value
        GetSTEPServerURLCollection = Split(url, ";")
    End If
End Function

Public Property Get HasSTEPServerUrl() As Boolean
    HasSTEPServerUrl = False
    If Not HasSettingsSheet Then
        Exit Property
    End If
    Dim Index As Integer
    Dim ar() As String
    ar = GetSTEPServerURLCollection
    For Index = LBound(ar) To UBound(ar)
        If (Len(ar(Index)) > 0) Then
            HasSTEPServerUrl = True
            Exit Property
        End If
    Next Index
End Property

Public Property Get STEPMultisep() As String
    'return multivalue seperator as defined by excel exporter in setting row 7 column 2
    Dim s As String
    s = ""
    If (HasSettingsSheet) Then
        s = SettingsSheet.cells(SETTING_MULTISEP_ROW, SETTING_VALUE_COL).Value
        If (Len(s) = 0) Then
            s = C_DEFAULT_MULTISEP
        End If
    End If
    STEPMultisep = s
End Property

Public Property Get IsInitiateWorkbook() As Boolean
    'quicksheet ? - defined by excel exporter in sttering row 6, col2
    If (HasSettingsSheet) Then
        IsInitiateWorkbook = CBool(SettingsSheet.cells(SETTING_ISINITIATE_ROW, SETTING_VALUE_COL).Value)
    Else
        IsInitiateWorkbook = False
    End If

End Property

Public Property Get initateUseAutoID() As Boolean
    If (IsInitiateWorkbook) Then
        initateUseAutoID = CBool(SettingsSheet.cells(SETTING_INITIATE_USEAUTOID_ROW, SETTING_VALUE_COL).Value)
    Else
        initateUseAutoID = False
    End If

End Property

Public Property Get AttributeLabelRow() As Long
    'pr definition as created by the excel exporter
    AttributeLabelRow = 10
End Property

Public Property Get FirstProductRow(ws As Worksheet, includeTemplateProduct As Boolean) As Long
    'pr definition as created by the excel exporter
    FirstProductRow = SETTING_FIRSTPRODUCT_ROW
    If (Not includeTemplateProduct) Then
        If (mTemplateProductHelper.isTemplateProductRow(ws.cells(SETTING_FIRSTPRODUCT_ROW, 1))) Then
            FirstProductRow = FirstProductRow + 1
        End If
    End If
End Property

Public Property Get HeaderRow() As Long
    'pr definition as created by the excel exporter
    HeaderRow = SETTING_FIRSTPRODUCT_ROW - 1
End Property

Public Property Get buttonRow() As Long
    buttonRow = SETTING_FIRSTPRODUCT_ROW - 2
End Property

Public Function GetLastRow(ws As Worksheet, ByVal iCol As Long) As Long
    'Returns the row number for the last used cell for a given column on a given sheet
    Dim rFound As Range, lastCell As Range

    GetLastRow = 0
    With ws.Columns(iCol)
        Set lastCell = .cells(.cells.Count)
        Set rFound = .cells.Find(what:="*", _
                    LookAt:=xlPart, _
                    SearchDirection:=xlPrevious, _
                    SearchOrder:=xlByRows, _
                    after:=lastCell)
    End With

    If Not rFound Is Nothing Then
        'could be it would wrap around like GetLastCol
        If (rFound.Column = iCol) Then
            If (Not ws.AutoFilter Is Nothing) Then
                If (UseFilter = True And ws.AutoFilter.Filters.Count > 0) Then
                    Dim rowNumber As Long
                    rowNumber = rFound.row
                    While (ws.cells(rowNumber, iCol).EntireRow.Hidden)
                        rowNumber = rowNumber - 1
                    Wend
                    GetLastRow = rowNumber
                Else
                    GetLastRow = rFound.row
                End If
            Else
                GetLastRow = rFound.row
            End If
        End If
    End If
    If (IsProductsSheet(ws)) Then
        If (IsInitiateWorkbook And GetLastRow <> LastInitiateRow(ws)) Then
            GetLastRow = LastInitiateRow(ws)
        End If
    End If


End Function

Public Function GetAuthenticationMethod() As String
    'return Authentication Method Basic or SSO - created by excel exporter in cell row 76, column 2
    If (HasSettingsSheet) Then
        GetAuthenticationMethod = SettingsSheet.cells(SETTING_AUTHENTICATION_METHOD, SETTING_VALUE_COL).Value
    End If
End Function

Public Function GetLastRowForAllSheet(ByVal ws As Worksheet, ByVal row As Long) As Long
    Dim rFound As Range, lastCell As Range

    GetLastRowForAllSheet = 0
    Dim i As Integer
    Dim maxCol As Integer
    maxCol = GetLastCol(ws, Me.HeaderRow)
    For i = 1 To maxCol
        With ws.Columns(i)
            Set lastCell = .cells(.cells.Count)
            Set rFound = .cells.Find(what:="*", _
                    LookAt:=xlPart, _
                    SearchDirection:=xlPrevious, _
                    SearchOrder:=xlByRows, _
                    after:=lastCell)
        End With
        'get rid of node pickers
        If Not rFound Is Nothing Then
            Dim rowNumber As Long
            rowNumber = rFound.row
            If rowNumber < row Then GoTo NextIteration

            If (Not ws.AutoFilter Is Nothing) Then
                If (UseFilter = True And ws.AutoFilter.Filters.Count > 0) Then
                    While (ws.cells(rowNumber, i).EntireRow.Hidden And rowNumber > row)
                        rowNumber = rowNumber - 1
                    Wend
                    If Not rFound.Value = "..." And rowNumber > GetLastRowForAllSheet Then
                        GetLastRowForAllSheet = rowNumber
                    End If
                End If
            Else
                If Not rFound.Value = "..." And rowNumber > GetLastRowForAllSheet Then
                    GetLastRowForAllSheet = rFound.row
                End If
            End If
        End If

NextIteration:
    Next
If GetLastRowForAllSheet <= row Then
    GetLastRowForAllSheet = row
End If

End Function

Public Function GetLastCol(ws As Worksheet, ByVal iRow As Long) As Integer
    'Returns the column number for the last used cell for a given row on a given sheet
    Dim rFound As Range, lastCell As Range
    GetLastCol = 0
    With ws.Rows(iRow)
        Set lastCell = .cells(.cells.Count)
        Set rFound = .cells.Find(what:="*", _
                            LookAt:=xlPart, _
                            SearchDirection:=xlPrevious, _
                            SearchOrder:=xlByColumns, _
                            after:=lastCell)
    End With
    If Not rFound Is Nothing Then
        'seems that find can do some strange row wrap-around
        If (rFound.row = iRow) Then
            GetLastCol = rFound.Column
        End If
    End If


End Function


Public Property Get LovsApplied() As Boolean
    Dim s As String
    LovsApplied = False
    If (HasSettingsSheet) Then
        s = SettingsSheet.cells(SETTING_LOVS_APPLIED_ROW, 2).Value
        If "" = s Then
            SettingsSheet.cells(SETTING_LOVS_APPLIED_ROW, 2).Value = 0
            SettingsSheet.cells(SETTING_LOVS_APPLIED_ROW, 1).Value = "LOVS Applied"
            LovsApplied = False
        Else
            LovsApplied = CBool(s)
        End If
    End If
End Property

Public Property Let LovsApplied(ByVal applied As Boolean)
    If (HasSettingsSheet) Then
        If (applied) Then
            SettingsSheet.cells(SETTING_LOVS_APPLIED_ROW, 2).Value = 1
        Else
            SettingsSheet.cells(SETTING_LOVS_APPLIED_ROW, 2).Value = 0
        End If
    End If
End Property

Public Property Get InheritanceApplied() As Boolean
    Dim s As String
    InheritanceApplied = False
    If (HasSettingsSheet) Then
        s = SettingsSheet.cells(SETTING_INHERITANCE_APPLIED_ROW, 2).Value
        If "" = s Then
            SettingsSheet.cells(SETTING_INHERITANCE_APPLIED_ROW, 2).Value = 0
            SettingsSheet.cells(SETTING_INHERITANCE_APPLIED_ROW, 1).Value = "Inheritancs Applied"
            InheritanceApplied = False
        Else
            InheritanceApplied = CBool(s)
        End If
    End If
End Property

Public Property Let InheritanceApplied(ByVal applied As Boolean)
    If (HasSettingsSheet) Then
        If (applied) Then
            SettingsSheet.cells(SETTING_INHERITANCE_APPLIED_ROW, 2).Value = 1
        Else
            SettingsSheet.cells(SETTING_INHERITANCE_APPLIED_ROW, 2).Value = 0
        End If
    End If
End Property

Public Sub UnProtectSheet(ws As Worksheet)
    On Error Resume Next
    ws.Unprotect C_SECRET
    If (err.Number <> 0) Then err.Clear
End Sub

Public Sub ProtectSheet(ws As Worksheet)
    On Error Resume Next
    ws.Protect password:=C_SECRET, _
        UserInterfaceOnly:=True, _
        AllowFormattingColumns:=True, _
        AllowFormattingRows:=True, _
        AllowFiltering:=UseFilter, _
        AllowFormattingCells:=EnableTextFormatting
    If (err.Number <> 0) Then err.Clear
End Sub

 Public Sub RemoveFilters(ws As Worksheet)
    Dim param As Boolean
    param = UseFilter
    If (param = True And ws.AutoFilterMode) Then
        On Error GoTo SHOWALLDATA_FAILED
        'ShowAllData fails big time if no filters applied
        ws.ShowAllData
    End If
    Exit Sub
SHOWALLDATA_FAILED:
    err.Clear
 End Sub


Public Property Get UseFilter() As Boolean
    If (VBA.Trim(SettingsSheet.cells(SETTING_USE_FILTER, 2).Value) = True And HasExtendedSettingsSheet) Then
        UseFilter = True
    Else
        UseFilter = False
    End If
End Property
Public Property Get EnableDDR() As Boolean
    If (VBA.Trim(SettingsSheet.cells(SETTING_ENABLE_DDR, 2).Value) = True And HasExtendedSettingsSheet) Then
        EnableDDR = True
    Else
        EnableDDR = False
    End If
End Property

Public Property Get AddWorkingColumn() As Boolean
    If (VBA.Trim(SettingsSheet.cells(SETTING_ADD_WORKING_COLUMN, 2).Value) = True And HasExtendedSettingsSheet) Then
        AddWorkingColumn = True
    Else
        AddWorkingColumn = False
    End If
End Property

Public Property Get EnableTextFormatting() As Boolean
    If (VBA.Trim(SettingsSheet.cells(SETTING_ENABLE_TEXT_FORMAT, 2).Value) = True And HasExtendedSettingsSheet) Then
        EnableTextFormatting = True
    Else
        EnableTextFormatting = False
    End If
End Property

Public Property Get ValidationPerformed() As Boolean
    If (UseFilter) Then
        If (VBA.Trim(SettingsSheet.cells(SETTING_USE_FILTER, 3).Value = True)) Then
            ValidationPerformed = True
        Else
            ValidationPerformed = False
        End If
    End If
End Property
Public Property Let ValidationPerformed(performed As Boolean)
    If (UseFilter) Then
        SettingsSheet.cells(SETTING_USE_FILTER, 3).Value = performed
    End If
End Property

Public Sub AutoFilterColumns(ws As Worksheet)
 Dim param As Boolean
 param = UseFilter
 If (param = True) Then
    Dim rng As Range
    Dim rLastCell As Long
    Dim boo As Boolean
    boo = False
    If (ws.AutoFilter Is Nothing) Then
        boo = True
    ElseIf (ws.AutoFilter.Filters.Count <= 0) Then
        boo = True
    End If
    If (boo) Then
        rLastCell = ws.cells(10, ws.Columns.Count).End(xlToLeft).Column
        Set rng = ws.Range(ws.cells(10, 1), ws.cells(10, rLastCell))
        rng.Select
        rng.AutoFilter
    End If

 End If

 End Sub


Public Property Get LastInitiateRow(ws As Worksheet)
    If (HasExtendedSettingsSheet) Then
        Dim lastRow As Integer
        lastRow = VBA.Trim(SettingsSheet.cells(SETTING_PREFORMATTED_TEMPLATE_ROWS, 2).Value)
        If (lastRow > 0) Then
            'we are counting first product row also
            lastRow = lastRow - 1
        End If
        LastInitiateRow = Me.FirstProductRow(ws, False) + lastRow
    Else
        LastInitiateRow = Me.FirstProductRow(ws, False) + 999
    End If
End Property


Public Function SplitMultivalue(ByVal strval As String) As String()
    Dim res() As String
    If InStr(strval, C_DEFAULT_MULTISEP) > 0 Then
        res = Split(strval, C_DEFAULT_MULTISEP)
    Else
        res = Split(strval, STEPMultisep)
    End If
    SplitMultivalue = res
End Function

Public Function JoinMultivalue(ByRef strvals() As String) As String
    Dim res() As String
    Dim i As Integer, ms As String
    Dim usedef As Boolean
    usedef = False
    ms = STEPMultisep
    For i = LBound(strvals) To UBound(strvals)
        If (InStr(strvals(i), ms) > 0) Then
            usedef = True
        End If
    Next
    If (usedef) Then
        JoinMultivalue = Join(strvals, C_DEFAULT_MULTISEP)
    Else
        JoinMultivalue = Join(strvals, ms)
    End If
End Function


Public Function GetSheetByName(ByVal Name As Variant) As Worksheet
    Dim wSheet As Worksheet
    For Each wSheet In ThisWorkbook.Sheets
        If wSheet.Name = Name Then
            Set GetSheetByName = wSheet
            Exit Function
        End If
    Next
End Function

Property Get LastAppliedDecimalSeparator() As String
    Dim res As String
    LastAppliedDecimalSeparator = "." 'default from STEP
    If (UseLocalDecimalSeparator) Then
        Dim s As String
        s = VBA.Trim(SettingsSheet.cells(SETTING_LAST_APPLIED_DECIMAL_SEPARATOR_ROW, 2).Value)
        If "" = s Then
            SettingsSheet.cells(SETTING_LAST_APPLIED_DECIMAL_SEPARATOR_ROW, 2).Value = "."
            SettingsSheet.cells(SETTING_LAST_APPLIED_DECIMAL_SEPARATOR_ROW, 1).Value = "Decimal separator"
        Else
            LastAppliedDecimalSeparator = VBA.Left(s, 1)
        End If
    End If
End Property

Property Let LastAppliedDecimalSeparator(sep As String)
    If (UseLocalDecimalSeparator) Then
        SettingsSheet.cells(SETTING_LAST_APPLIED_DECIMAL_SEPARATOR_ROW, 2).Value = sep
        SettingsSheet.cells(SETTING_LAST_APPLIED_DECIMAL_SEPARATOR_ROW, 1).Value = "Decimal separator"
    End If
End Property

Public Property Get UseLocalDecimalSeparator() As Boolean
    UseLocalDecimalSeparator = False
    If (HasSettingsSheet And HasExtendedSettingsSheet) Then
        Dim s As String
        s = VBA.Trim(SettingsSheet.cells(SETTING_USE_LOCAL_DECIMAL_SEPARATOR_ROW, 2).Value)
        If (StrComp("true", s, vbTextCompare) = 0) Then
            UseLocalDecimalSeparator = True
        End If
    End If
End Property

Property Let ImporterErrorsApplied(applied As Boolean)
    If (HasSettingsSheet And HasExtendedSettingsSheet) Then
        Dim s As String
        'boolean gets localized in vba - dont bother
        If (applied) Then
            s = "applied"
        Else
            s = "not applied"
        End If
        SettingsSheet.cells(SETTING_IMPORTER_ERRORS_APPLIED, 2).Value = s
        SettingsSheet.cells(SETTING_IMPORTER_ERRORS_APPLIED, 1).Value = "Importer errors"
    End If
End Property

Property Get ImporterErrorsApplied() As Boolean
    ImporterErrorsApplied = False
    If (HasSettingsSheet And HasExtendedSettingsSheet) Then
        Dim s As String
        s = VBA.Trim(SettingsSheet.cells(SETTING_IMPORTER_ERRORS_APPLIED, 2).Value)
        If (StrComp("applied", s, vbTextCompare) = 0) Then
            ImporterErrorsApplied = True
        End If
    End If
End Property

Property Get ImportConfiguration() As String
    If (HasSettingsSheet And HasExtendedSettingsSheet) Then
        ImportConfiguration = SettingsSheet.cells(SETTING_IMPORT_CONFIGURATION, 2).Value
    End If
End Property


Public Function IsMultipleCategorySmartSheet() As Boolean
    IsMultipleCategorySmartSheet = False
    If (HasSettingsSheet And HasExtendedSettingsSheet And IsInitiateWorkbook) Then
        If (0 = VBA.StrComp(MULTIPLE_CATEGORIES_TEMPLATE, GetInitiateRootProductId)) Then
            IsMultipleCategorySmartSheet = True
        End If
    End If
End Function

Public Function GetProductObjectTypeCount() As Integer
    GetProductObjectTypeCount = 0
    If Not HasSettingsSheet Then Exit Function
    Dim cnt As Integer
    Dim Index As Integer
    Index = 2
    Do While True
        Dim s As String
        s = SettingsSheet.cells(SETTING_PRODUCT_OBJECT_TYPES, Index).Value
        If (VBA.Len(s) > 0) Then
            Index = Index + 1
            cnt = cnt + 1
        Else
            Exit Do
        End If
    Loop
    GetProductObjectTypeCount = cnt
End Function

Public Sub StoreSheetName(ws As Worksheet)
    If (IsProductsSheet(ws)) Then
        Dim s As String
        s = ws.cells(PRODUCSHEET_INDENTIFIERS_ROW, PRODUCSHEET_SHEETNAME_MIRROR_COL)
        If ("" = s) Then
            ws.cells(PRODUCSHEET_INDENTIFIERS_ROW, PRODUCSHEET_SHEETNAME_MIRROR_COL).Value = ws.Name
        End If
    End If
End Sub

Public Sub RestoreSheetName(ws As Worksheet)
    Dim lProtect As Boolean
    lProtect = False
    If (IsProductsSheet(ws)) Then
        Dim s As String
        s = ws.cells(PRODUCSHEET_INDENTIFIERS_ROW, PRODUCSHEET_SHEETNAME_MIRROR_COL)
        If ("" <> s And s <> ws.Name) Then
            lProtect = ws.ProtectContents
            If lProtect Then
                UnProtectSheet ws
            End If
            On Error GoTo RESTORE_ERR
            ws.Name = s
        End If
    End If
RESTORE_ERR:
    If (lProtect) Then
        ProtectSheet ws
    End If
    err.Clear
End Sub

Public Property Get SupplierInfoCollection() As Collection
    If (mSupplierInfoCollection Is Nothing) Then
        Set mSupplierInfoCollection = New Collection
        If (HasSettingsSheet And HasExtendedSettingsSheet) Then
            Dim lSeparator As String
            lSeparator = mSettingsSheet.cells(SETTING_CREATE_TARGET_SEPARATOR, SETTING_VALUE_COL).Value
            Dim suplKey As String
            Dim rowIndex As Integer
            rowIndex = SETTING_SUPPLIER_INFO_FIRST_ROW
            Do While True
                suplKey = mSettingsSheet.cells(rowIndex, SETTING_SUPPLIER_INFO_KEY_COL).Value
                If (suplKey = "") Then
                    Exit Do
                End If
                Dim supplierInfo As STEPSupplierInfo
                Set supplierInfo = New STEPSupplierInfo
                supplierInfo.Init suplKey, _
                                  mSettingsSheet.cells(rowIndex, SETTING_SUPPLIER_INFO_ID_COL).Value, _
                                  mSettingsSheet.cells(rowIndex, SETTING_SUPPLIER_INFO_PC_COL).Value, _
                                  mSettingsSheet.cells(rowIndex, SETTING_SUPPLIER_INFO_AC_COL).Value, _
                                  lSeparator
                mSupplierInfoCollection.Add supplierInfo, supplierInfo.supplierKey
                rowIndex = rowIndex + 1
            Loop
        End If
    End If
    Set SupplierInfoCollection = mSupplierInfoCollection
End Property

Public Property Get IsMultiSupplierSheet() As Boolean
    IsMultiSupplierSheet = False
    If (HasSettingsSheet And HasExtendedSettingsSheet And IsInitiateWorkbook) Then
        If (StrComp("true", mSettingsSheet.cells(SETTING_MULTISUPPLIER_SMARTSHEET, 2).Value, vbTextCompare) = 0) Then
            If (mSettingsSheet.cells(SETTING_SUPPLIER_INFO_FIRST_ROW, SETTING_SUPPLIER_INFO_KEY_COL).Value <> "") Then
                IsMultiSupplierSheet = True
            Else
                Call err.Raise(vbObjectError + 1099, Source:="STEPSheetUtils.IsMultiSupplierSheet", Description:=mLocale.GetLocalizationString("STEPSheetUtilsMultiSupplierError"))
            End If
        End If
    End If
End Property

Public Function GetRowSupplier(ByVal ws As Worksheet, ByVal row As Long, ByRef supplierColumnIndex As Long) As STEPSupplierInfo
    supplierColumnIndex = -1
    Set GetRowSupplier = Nothing
    If Not IsProductsSheet(ws) Or Not IsMultiSupplierSheet Then
        Exit Function
    End If
    Dim Index As Integer
    Dim mColcount As Integer
    mColcount = GetLastCol(ws, ColumnTypeRowIndex)
    Dim firstLevel As Integer
    firstLevel = GetColumnSourceLevel(ws, 1)
    For Index = 1 To mColcount
        If (GetColumnSourceLevel(ws, Index) > firstLevel) Then
            Exit For
        End If
        If (GetColumnType(ws, Index) = STEPSupplier) Then
            supplierColumnIndex = Index
            Dim val As String
            val = ws.cells(row, Index).Value
            If (val <> "") Then
                On Error GoTo NOT_FOUND
                Set GetRowSupplier = SupplierInfoCollection.Item(val)
                On Error GoTo 0
            End If
        End If

    Next
    'ensure error message for missing supplier-selctor
    If (supplierColumnIndex < 0) Then
        err.Raise ERR_MISSING_SUPPLIER_SELECTOR, Description:=mLocale.GetLocalizationString("STEPSheetUtilsMultiSupplierError")
    End If
    Exit Function
NOT_FOUND:
    err.Clear
End Function

Public Function GetSupplierInfo(ByVal supplierKey As String) As STEPSupplierInfo
    Set GetSupplierInfo = Nothing
    On Error Resume Next
    Set GetSupplierInfo = SupplierInfoCollection.Item(supplierKey)
    If (err.Number <> 0) Then
        err.Clear
    End If
    On Error GoTo 0
End Function

Public Property Get MultiSupplierCreateTargetSeparator() As String
    MultiSupplierCreateTargetSeparator = ""
    If (IsMultiSupplierSheet) Then
        Dim s As String
        s = mSettingsSheet.cells(SETTING_CREATE_TARGET_SEPARATOR, SETTING_VALUE_COL).Value
        If (Len(s) > 0) Then
            MultiSupplierCreateTargetSeparator = s
        End If
    End If
End Property

Public Property Get UseNCR() As Boolean
    'indicates if we should should convert all extended characters to Unicode point using NCR notation
    'cannot really see a reason not to so for now is is not configurable
    UseNCR = True
End Property

Public Sub UnmarkMatchEntireCellContents()
    If (Not IsProductsSheet(ThisWorkbook.ActiveSheet)) Then
        Exit Sub
    End If
    If Not Application.Version Like "14*" Then
        ThisWorkbook.ActiveSheet.cells.Find(what:="", after:=ActiveCell, LookAt:=xlPart).Show
    End If
End Sub

Public Sub SetNumberFormat(cells As Range)
Dim numberFormat As String
If (IsWorkingColumn(cells.Worksheet, cells.Column)) Then
    numberFormat = "General"
Else
    numberFormat = "@"
End If
If (cells.numberFormat <> numberFormat) Then
    cells.numberFormat = numberFormat
End If
End Sub
Attribute VB_Name = "STEPSheetValidator"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
'for custom sheets product-errors for different groups (levels) is put into one string, separated by this
Private Const GROUPED_ERROR_SEPARATOR = "   "

Private Const BUNCH_SIZE = 10
Private Const SMARTSHEET_BUNCH_SIZE = 25
Private mSheet As Worksheet
Private mUtils As STEPSheetUtils
Private mStyleHelper As STEPStyleHelper
Private mCellMarker As STEPCellMarker
Private requestUtils As STEPRequestUtils
Private mCurrentRow As Long
Private mColcount As Long
Private mIDCol As Long
Private mDone As Boolean
Private mError As String
Private mCounts As New STEPValidationCounts
Private mValidateAll As Boolean
Private mStepUser As STEPUser
Private mReadonlyCoumns() As Boolean
Private mMandatoryColumns() As Boolean
Private mColumnTypes() As STEPColumnType
Private mColumnIDS() As String
Private mIsinitiate As Boolean
Private mIniateAutoID As Boolean
Private mInitiateObjectType As String
Private mEmptyRowCounter As Integer
Private mCreateTargetColumns() As Boolean
Private mColumnSorceLevels() As Integer
Private mColumnSorceObjectTypes() As String
Private mColumnUseLOVID() As String
Private mColumnContextIDs() As String
Private mColumnAnnotations() As String
Private mColumnBaseTypes() As String
Private mFailedProductRows As Collection
Private mErrorTracker As STEPSet
Private mLocale As String
Private mStatusTracker As STEPCellStatusTracker
Private mSmartSheetType As STEPSmartSheetType
Private mObjectTypeColumnIndex As Long
Private mSupplierColumnIndx As Long
Private mSheetAnnotation As String
Private mIsSmartSheet As Boolean
Private mIsCustomSmartSheet As Boolean
Private mDuplicates As STEPSet
Private mSkipHidden As Boolean
Private mLocalization As New STEPLocalization

Private Sub Class_Initialize()
    Set mUtils = New STEPSheetUtils
    Set mCellMarker = New STEPCellMarker
    Set requestUtils = New STEPRequestUtils
    Set mStyleHelper = New STEPStyleHelper
End Sub

Public Sub Init(ws As Worksheet, pStepUser, ByVal pSkipHidden As Boolean)
    mSkipHidden = False
    Set mSheet = Nothing
    mDone = False
    mCounts.Clear
    Set mStepUser = pStepUser
    If (mUtils.IsProductsSheet(ws)) Then
        mIsSmartSheet = mUtils.HasExtendedSettingsSheet
        mSmartSheetType = mUtils.SmartSheetType
        mIsCustomSmartSheet = mIsSmartSheet And (STEPCustomType = mSmartSheetType)
        mSkipHidden = mIsSmartSheet And pSkipHidden
        mObjectTypeColumnIndex = -1
        mSupplierColumnIndx = -1
        Set mStatusTracker = New STEPCellStatusTracker
        mStatusTracker.Init ws.Name
        Set mFailedProductRows = New Collection
        Set mSheet = ws
        mUtils.RestoreSheetName ws
        Dim changeTracker As STEPChangeTracker
        Set mDuplicates = New STEPSet
        Set changeTracker = New STEPChangeTracker
        Set mErrorTracker = changeTracker.GetRowIDSWithErrors(mSheet)
        mLocale = mUtils.LocaleConfiguration
        mIsinitiate = mUtils.IsInitiateWorkbook
        If (mIsinitiate) Then
            mInitiateObjectType = mUtils.GetInitiateObjectTypeId
            mIniateAutoID = mUtils.initateUseAutoID
        Else
            mIniateAutoID = False
            mInitiateObjectType = ""
        End If
        mEmptyRowCounter = 0
        mCurrentRow = mUtils.FirstProductRow(ws, False)
        mColcount = mUtils.GetLastCol(mSheet, mUtils.ColumnTypeRowIndex)
        Dim i As Long
        i = 1
        ReDim mColumnTypes(1 To mColcount) As STEPColumnType
        ReDim mReadonlyCoumns(1 To mColcount) As Boolean
        ReDim mMandatoryColumns(1 To mColcount) As Boolean
        ReDim mCreateTargetColumns(1 To mColcount) As Boolean
        ReDim mColumnIDS(1 To mColcount) As String
        ReDim mColumnSorceLevels(1 To mColcount) As Integer
        ReDim mColumnSorceObjectTypes(1 To mColcount) As String
        ReDim mColumnUseLOVID(1 To mColcount) As String
        ReDim mColumnContextIDs(1 To mColcount) As String
        ReDim mColumnAnnotations(1 To mColcount) As String
        ReDim mColumnBaseTypes(1 To mColcount) As String
        For i = 1 To mColcount
            mReadonlyCoumns(i) = mUtils.IsColumnReadOnly(mSheet, i)
            mMandatoryColumns(i) = mUtils.IsColumnMandatory(mSheet, i)
            mColumnTypes(i) = mUtils.GetColumnType(mSheet, i)
            mColumnIDS(i) = mUtils.GetColumnID(mSheet, i)
            If (mColumnTypes(i) = STEPObjectType And mSmartSheetType = STEPMultiObjectTypeType) Then
                mObjectTypeColumnIndex = i
            End If
            If (mColumnTypes(i) = STEPSupplier And mIsinitiate And mIsSmartSheet And mSmartSheetType <> STEPCustomType) Then
                mSupplierColumnIndx = i
            End If
            mCreateTargetColumns(i) = mUtils.IsCreateTargetColumn(mSheet, i)
            mColumnSorceLevels(i) = mUtils.GetColumnSourceLevel(mSheet, i)
            mColumnSorceObjectTypes(i) = mUtils.GetColumnSourceObjectTypeID(mSheet, i)
            mColumnUseLOVID(i) = mUtils.GetUseLOVID(mSheet, i)
            mColumnContextIDs(i) = mUtils.GetColumnContextID(mSheet, i)
            mColumnAnnotations(i) = mUtils.GetColumnAnnotation(mSheet, i)
            If (mColumnTypes(i) = STEPAttribute) Then
                Select Case mUtils.GetBaseValidationType(mSheet, i)
                    Case STEPColumnBaseValidationType.STEPEmbeddedNumber
                        mColumnBaseTypes(i) = "embedded_number"
                    Case STEPColumnBaseValidationType.STEPNumber
                        mColumnBaseTypes(i) = "number"
                    Case STEPColumnBaseValidationType.STEPNumberRange
                        mColumnBaseTypes(i) = "numberrange"
                    Case Else
                        mColumnBaseTypes(i) = ""
                End Select
            Else
                mColumnBaseTypes(i) = ""
            End If
        Next

        mIDCol = mUtils.GetIDColumnIndex

        If (mIDCol < 0) Then
            SetError mLocalization.GetLocalizationString("STEPSheetValidatorIDNotFound")
        End If
        If (mSupplierColumnIndx < 0 And mUtils.IsMultiSupplierSheet And mIsinitiate) Then
            SetError mLocalization.GetLocalizationString("STEPSheetValidatorSupplierNotFound")
        End If
        If (mUtils.IsInitiateWorkbook And mSmartSheetType = STEPMultiObjectTypeType And mObjectTypeColumnIndex < 1) Then
            'multi-objecttypes with just one type is allowed not to have selector
            If (VBA.Len(mInitiateObjectType) = 0 Or mUtils.GetProductObjectTypeCount <> 1) Then
                SetError mLocalization.GetLocalizationString("STEPSheetValidatorObjectTypeNotFound")
            End If
        End If
        mSheetAnnotation = mUtils.GetSheetAnnotation(ws)
    Else
        mDone = True
    End If
End Sub

Public Property Let ForceFullValidation(ByVal boo As Boolean)
    mValidateAll = boo
End Property

Public Property Get ForceFullValidation() As Boolean
    ForceFullValidation = mValidateAll
End Property

Private Sub SetError(ByVal str As String)
    mError = str
    mDone = True
End Sub

Public Property Get done() As Boolean
    done = mDone
End Property

Public Property Get HasError() As Boolean
    HasError = mError <> ""
End Property

Public Property Get ErrorDescription() As String
    ErrorDescription = mError
End Property

Public Property Get CurrentRow() As Long
    CurrentRow = mCurrentRow
End Property

Private Function IsEmptyRow(ByVal lRow As Long) As Boolean
    Dim lCol As Long
    IsEmptyRow = False
    Dim lastRow As Long
    lastRow = mUtils.GetLastRow(mSheet, 1)
    If (lRow > lastRow) Then
        IsEmptyRow = True
        Exit Function
    End If
    If (mSmartSheetType <> STEPNotApplicaple) Then
        Dim lColumnType As STEPColumnType
        If (Not mIsinitiate) Then
            'no ID means empty
            IsEmptyRow = mSheet.cells(lRow, 1).Value = "" Or IsRowHidden(lRow)
            Exit Function
        End If
        For lCol = 2 To mColcount
            lColumnType = mColumnTypes(lCol)
            'ignore object type and parent - these alone is not enough for create so do not validate
            If (lColumnType <> STEPColumnType.EXCELButton And _
                lColumnType <> STEPColumnType.STEPObjectType And _
                lColumnType <> STEPColumnType.STEPParentID) Then
                If mSheet.cells(lRow, lCol).Value <> "" Then
                    Exit Function
                End If
            End If
        Next
    Else
        For lCol = 1 To mColcount
            If (mColumnTypes(lCol) <> STEPColumnType.EXCELButton) Then
                If mSheet.cells(lRow, lCol).Value <> "" Then
                    Exit Function
                End If
            End If
        Next
    End If
    IsEmptyRow = True
End Function

Private Function IsRowHidden(ByVal lRow As Long) As Boolean
IsRowHidden = False
    If (mUtils.UseFilter = True) Then
        If (mSheet.cells(lRow, 1).Rows.Hidden = True) Then
            IsRowHidden = True
        End If
    End If
End Function

Public Sub ValidateNextBunch()
    '
    Const AS_TEXT = False
    Dim stepRequest As STEPRequestBuilder, respXML As Object, respText As String
    Dim failedProducts() As STEPValidatedProduct, modifiedProducts() As STEPValidatedProduct, statusProducts() As STEPValidatedProduct
    Dim failCount As Integer, modificationCount As Integer, statusCount As Integer
    Dim requestedIDS() As String
    Dim mTimer As New STEPTimer
    Dim mBunchTimer As New STEPTimer
    Dim eventsEnabled As Boolean
    Dim mScreenUpdating As Boolean
    mBunchTimer.AddInfoToOutput "--- ROW: " & Me.CurrentRow & " ---"
    mBunchTimer.StartTimer "Validated bunch"
    eventsEnabled = ThisWorkbook.Application.EnableEvents
    mScreenUpdating = ThisWorkbook.Application.ScreenUpdating
    On Error GoTo VAL_FAILED
    ThisWorkbook.Application.EnableEvents = False
    ThisWorkbook.Application.ScreenUpdating = False
    Set stepRequest = BuildNextBunchXML()
    'Dim st As New STEPLogger
    'st.Warning "test", reqXML.xml

    'only call server if we have something to ask about
    If (Not HasError And stepRequest.ProductCount > 0) Then
        requestedIDS = stepRequest.productids()
        mCounts.AddValidateProducts stepRequest.ProductCount
        mTimer.StartTimer "Requesting server"
        If (AS_TEXT) Then
            respText = RequestBunchValidationText(stepRequest.GetText)
        Else
            Set respXML = RequestBunchValidation(stepRequest.GetXML)
        End If
        mTimer.StopTimer
        Set stepRequest = Nothing
        mTimer.StartTimer "Parsing response"
        If (Not HasError) Then
            If (AS_TEXT) Then
                'Products = ParseResponenseText(respText, failCount)
            Else
                ParseResponenseXML respXML, failCount, failedProducts, modificationCount, modifiedProducts, statusCount, statusProducts
            End If
            '

        End If
        mTimer.StopTimer
        mTimer.StartTimer "Marking up"
        Dim lTimer As New STEPTimer
        Set respXML = Nothing
        'in seperate if statemens as each can call SetError
        If (Not HasError) Then
            'this is BEFORE MarkRequestedWithDefault as that relies on cell-status
            If (statusCount > 0) Then
                lTimer.StartTimer "  Mark status"
                MarkCellStatuses statusProducts
                lTimer.StopTimer
            End If
        End If
        If (Not HasError) Then
            'just set default marks for entire product (row) since we on get errors back
            lTimer.StartTimer "  Mark requested with default"
            MarkRequestedWithDefault requestedIDS
            lTimer.StopTimer
        End If
        If (Not HasError) Then
            If (failCount > 0) Then
                lTimer.StartTimer "  Mark failed"
                mCounts.AddValidationFailedProducts failCount
                MarkFailed failedProducts
                lTimer.StopTimer
            End If
            If (modificationCount > 0) Then
                UpdateModifiedProducts modifiedProducts
            End If
        End If
        mTimer.StopTimer 'marking up
    End If
    If (Not HasError And done) Then
        Dim cc As New STEPChangeTracker
        cc.ClearSheetChanges mSheet.Name

        If (mUtils.IsInitiateWorkbook And mIsSmartSheet) Then
            'If row is empty it cannot be invalid, remove from error tracker'
            'this is checking for rows that has been cleared completely so it only
            'applies to initiate sheets - but NOT IN QUICKSHEETS
            Dim mEmptyRows As STEPSet 'actually set of product-ids which is the same as row-numbers for template smartsheets
            Dim errorIndex As Long
            Dim lErrorRow As Long
            Set mEmptyRows = New STEPSet
            For errorIndex = 1 To mErrorTracker.Count
                lErrorRow = FindProductRow(mErrorTracker.Item(errorIndex))
                If (lErrorRow >= mUtils.FirstProductRow(mSheet, False)) Then
                    If (IsEmptyRow(lErrorRow)) Then
                        mEmptyRows.Add mErrorTracker.Item(errorIndex)
                    End If
                End If
            Next
            'If any empty rows where found, update styling for cells to not be marked as invalid'
            If (mEmptyRows.Count > 0) Then
                For errorIndex = 1 To mEmptyRows.Count
                    mErrorTracker.Remove mEmptyRows.Item(errorIndex)
                    'this only works because smartsheet templates always uses row number as product id
                    ResetRowForProductID mEmptyRows.Item(errorIndex)
                Next
            End If
        End If

'       this forces send to server even without any change - bad idea
'        MarkTab MarkFailedAsChanged(cc)
'       instead track it
        mCounts.AddRowWithErrorCount mErrorTracker.Count
        cc.SetRowIDSWithError mSheet, mErrorTracker
        mStatusTracker.Persist
    End If
    ThisWorkbook.Application.EnableEvents = eventsEnabled
    ThisWorkbook.Application.ScreenUpdating = mScreenUpdating
    'mTimer.StopTimer
    mBunchTimer.StopTimer
    Exit Sub
VAL_FAILED:
    SetError mLocalization.GetLocalizationString("STEPSheetValidatorUnexpected")
    Dim sl As New STEPLogger
    sl.Severe "STEPSheetValidator.ValidateNextBunch", "Unexpected error: " & err.Number & " " & err.Description
    err.Clear
    ThisWorkbook.Application.EnableEvents = eventsEnabled
    ThisWorkbook.Application.ScreenUpdating = mScreenUpdating
End Sub

'find a smartsheet row and remove error marks and cell-status
Private Sub ResetRowForProductID(ByVal pProductID As String)
    On Error GoTo RESET_ERR
    Dim lCol As Integer
    Dim lRow As Long
    lRow = FindProductRow(pProductID)
    If (lRow < mUtils.FirstProductRow(mSheet, False)) Then Return
    For lCol = mIDCol + 1 To mColcount
        If (mReadonlyCoumns(lCol)) Then
            'nothing
        ElseIf (mUtils.IsWorkingColumn(mSheet, lCol)) Then
            'nothing
        ElseIf (mMandatoryColumns(lCol)) Then
            mCellMarker.MarkValidMandatory mSheet.cells(lRow, lCol)
        Else
            mCellMarker.MarkValid mSheet.cells(lRow, lCol)
        End If
        If (STEPColumnType.STEPAttribute = mColumnTypes(lCol)) Then
            mStatusTracker.RemoveCellStatus mSheet.cells(lRow, lCol).Address
        End If

    Next
    Exit Sub
RESET_ERR:
    Dim lLogger As New STEPLogger
    lLogger.Warning "STEPSheetValidator.ResetRowForProductid", mSheet.Name & " Product id:" & pProductID & " Row:" & CStr(lRow) & " Col:" & CStr(lCol) & " " & CStr(err.Number) & ":" & err.Description
    err.Clear
    Exit Sub

End Sub


'just after we cleared the changes for current products sheet
'put failed products back into the change sheet
'this means that it will get re-validated next time even if the user does not
'attempt to fix errors
'Returns number of rows marked as changed
Private Function MarkFailedAsChanged(ByRef cc As STEPChangeTracker) As Integer
    Dim lRow 'we know that collection contains long but we cannot iterate it with simple type
    Dim Count As Integer
    Count = 0
    For Each lRow In mFailedProductRows
        Count = Count + 1
        cc.change mSheet, mSheet.cells(lRow, 1)
    Next
    Set mFailedProductRows = New Collection
    MarkFailedAsChanged = Count
End Function

Private Sub MarkTab(ByVal addedRowChanges As Long)
    On Error GoTo TAB_ERR
    Dim Count As Long
    If (addedRowChanges > 0) Then
        'we positively know that rows has been marked as changed because of failure,
            'there is no reason to go through all this comment-counting
        Count = addedRowChanges
    Else
        Count = mSheet.Comments.Count
        Dim colIndex As Integer
        Dim rowIndex As Long
        colIndex = 1
        For rowIndex = 1 To mUtils.HeaderRow
            If (Not mSheet.cells(rowIndex, colIndex).Comment Is Nothing) Then
                Count = Count - 1
            End If
        Next

        rowIndex = mUtils.HeaderRow
        For colIndex = 1 To mColcount
            If (Not mSheet.cells(rowIndex, colIndex).Comment Is Nothing) Then
                Count = Count - 1
            End If
        Next
    End If
    If (Count > 0) Then
        mSheet.Tab.color = RGB(255, 0, 0)
    Else
        mSheet.Tab.color = RGB(255, 255, 255)
    End If
TAB_ERR:
    err.Clear
End Sub

'if a product was marked invalid before Request and passes validation we need to mark it valid becourse the
'product is NOT returned from the server
Private Sub MarkRequestedWithDefault(productids() As String)
    Dim prodindex As Integer, prodid As String, row As Long
    Dim isinitiate As Boolean
    Dim s As String
    Dim sendToServer As Boolean
    Dim sid As String
    Dim changes As New STEPChangeTracker

    isinitiate = mUtils.IsInitiateWorkbook
    For prodindex = LBound(productids) To UBound(productids)
        Dim missingmandatory As Boolean
        missingmandatory = False
        prodid = productids(prodindex)
        If (prodid = "") Then
            GoTo SKIP_PRODID
        End If
        row = FindProductRow(prodid)
        If (isinitiate) Then
            sid = row
            sendToServer = changes.IsProductChanged(mSheet.Name, "", row)
        Else
            sid = mSheet.cells(row, mIDCol).Value
            sendToServer = changes.IsProductChanged(mSheet.Name, sid, row)
        End If
        If row < 0 Then
            GoTo SKIP_PRODID
        End If
        Dim col As Long, cell As Range
        For col = 1 To mColcount
            Set cell = mSheet.cells(row, col)
            If (col = mIDCol) Then
                If (mReadonlyCoumns(col)) Then
                    'there can be product-comments on id column even if its readonly
                    'cellmarker.ClearComments cell
                    mCellMarker.MarkValidReadonly cell
                ElseIf (mMandatoryColumns(col)) Then
                    s = cell.Value
                    If (s = "") Then
                        mCellMarker.MarkMissingMandatory cell
                    Else
                        mCellMarker.MarkValidMandatory cell
                    End If
                End If
            Else
                If (STEPColumnType.EXCELButton = mColumnTypes(col)) Then GoTo CELL_DONE

                If (STEPColumnType.STEPAttribute = mColumnTypes(col)) Then
                    Dim lCellStatus As STEPCellStatus
                    Set lCellStatus = mStatusTracker.GetCellStatus(cell.Address)
                    If Not (lCellStatus Is Nothing) Then
                        s = cell.Value
                        If ((lCellStatus.CellStatus = STEPCellMandatory) And (s = "")) Then
                            mCellMarker.MarkMissingMandatory cell
                            If Not missingmandatory Then
                                mCounts.AddMissingMandatoryProducts
                                missingmandatory = True
                            End If
                            mCounts.AddMissingMandatoryValues
                        End If
                        'otherwise handled by MarkCellStatues
                        GoTo CELL_DONE
                    End If
                End If
                If (mReadonlyCoumns(col)) Then
                    mCellMarker.MarkValidReadonly cell
                ElseIf (mUtils.IsWorkingColumn(mSheet, col)) Then
                    'nothing
                ElseIf (mUtils.IsColumnMandatory(mSheet, col)) Then
                    s = cell.Value
                    If (s = "") Then
                        mCellMarker.MarkMissingMandatory cell
                        If Not missingmandatory Then
                            mCounts.AddMissingMandatoryProducts
                            missingmandatory = True
                        End If
                        mCounts.AddMissingMandatoryValues
                    Else
                        mCellMarker.MarkValidMandatory cell
                    End If
                    If (cell.Locked And sendToServer) Then cell.Locked = False
                    mUtils.SetNumberFormat cell
                Else
                    If (sendToServer) Then
                        mCellMarker.MarkValid cell
                        If (cell.Locked) Then cell.Locked = False
                        mUtils.SetNumberFormat cell
                    End If
                End If
CELL_DONE:
            End If
        Next


SKIP_PRODID:
    Next prodindex
End Sub

Private Function FindProductRow(ByVal productid As String) As Long
    Dim found As Range
    FindProductRow = -1
    If (mIniateAutoID) Then
        'if initate workbook and objet type uses autoid
        'we have sendt row index to server and so we must
        FindProductRow = CLng(productid)
    Else
        Set found = mSheet.Columns(mIDCol).Find(what:=productid, _
            after:=mSheet.cells(mUtils.HeaderRow, mIDCol), _
            LookAt:=xlWhole, _
            SearchDirection:=xlNext, _
            SearchOrder:=xlByRows)
        If (Not found Is Nothing) Then
            FindProductRow = found.row
        End If
        mUtils.UnmarkMatchEntireCellContents
    End If
End Function

Private Sub UpdateModifiedProducts(Products() As STEPValidatedProduct)
    Dim Index As Integer
    Dim colIndex As Integer
    Dim mp As STEPValidatedProduct
    Dim mo As STEPModifiedObject, oo
    Dim idRow As Long
    idRow = mUtils.ColumnIDRowIndex
    For Index = LBound(Products) To UBound(Products)
        Set mp = Products(Index)
        If (mp.ModificationsCount = 0) Then GoTo SKIP_PRODUCT
        Dim row As Long
        row = FindProductRow(mp.productid)
        If (row < 1) Then GoTo SKIP_PRODUCT
        For Each oo In mp.Modifications
            Set mo = oo
            Dim lCells As Range
            Set lCells = GetAddressedCell(mo.CellAddress)
            If (Not lCells Is Nothing) Then
                If (lCells.row = row) Then
                    lCells.Value = mo.ModifiedValueDisplay
                    GoTo DONE_MOD
                End If
            End If
            For colIndex = 1 To mColcount
                If (Not mReadonlyCoumns(colIndex)) Then
                    If (mColumnTypes(colIndex) = STEPAttribute) Then
                        If (mo.id = mColumnIDS(colIndex)) Then
                            mSheet.cells(row, colIndex).Value = mo.ModifiedValueDisplay
                            GoTo DONE_MOD
                        End If
                    End If
                End If
            Next
DONE_MOD:
        Next

SKIP_PRODUCT:
    Next
End Sub
Private Sub MarkCellStatuses(ByRef pProducts() As STEPValidatedProduct)
    Dim Index As Integer
    For Index = LBound(pProducts) To UBound(pProducts)
        Dim vp As STEPValidatedProduct
        Set vp = pProducts(Index)
        If (vp.CellStatusesCount = 0) Then
            GoTo SKIP_PRODUCT
        End If

        Dim row As Long
        row = FindProductRow(vp.productid)

        If (row < 1) Then
            Dim l As New STEPLogger
            l.Severe "STEPSheetValidator.MarkAttribute", "Product with id " & vp.productid & " not found in sheet " & mSheet.Name
            Set l = Nothing
            SetError mLocalization.GetLocalizationString("STEPSheetValidatorProductNotFound") & vp.productid
            Exit Sub
        End If

        'product has statuses.
        Dim lCellStatus As STEPCellStatus
        For Each lCellStatus In vp.CellStatuses
            MarkStatusAddressedCell row, lCellStatus.CellAddress, lCellStatus.CellStatus, mCellMarker
            mStatusTracker.AddCellStatus lCellStatus
        Next
SKIP_PRODUCT:
    Next Index
End Sub

Private Sub MarkFailed(Products() As STEPValidatedProduct)
    Dim Index As Integer
    For Index = LBound(Products) To UBound(Products)
        Dim vp As STEPValidatedProduct
        Set vp = Products(Index)
        If (vp.ValidationErrorCount = 0) Then
            GoTo SKIP_PRODUCT
        End If

        Dim row As Long
        row = FindProductRow(vp.productid)

        If (row > 0) Then
            'product has at least one error; put it into tracker if its not already there
            mErrorTracker.Add vp.productid
            mFailedProductRows.Add row
            Dim varierror, valerror As STEPValidationError
            For Each varierror In vp.ValidationErrors
                Set valerror = varierror
                Select Case valerror.ObjectType
                    Case ErrorObjectType.STEPReferenceError
                        If Not MarkAddressedCell(row, valerror.CellAddress, valerror.ValidationError, mCellMarker) Then
                        MarkCell row, STEPReference, valerror.id, valerror.ValidationError, mCellMarker
                        End If
                        mCounts.AddReferenceErrors
                    Case ErrorObjectType.STEPLinkError
                        If Not MarkAddressedCell(row, valerror.CellAddress, valerror.ValidationError, mCellMarker) Then
                        MarkCell row, STEPLink, valerror.id, valerror.ValidationError, mCellMarker
                        End If
                        mCounts.AddLinkErrors
                    Case ErrorObjectType.STEPAttributeError
                        mCounts.AddValueErrors
                        If Not MarkAddressedCell(row, valerror.CellAddress, valerror.ValidationError, mCellMarker) Then
                        MarkCell row, STEPAttribute, valerror.id, valerror.ValidationError, mCellMarker
                        End If
                    Case ErrorObjectType.STEPNameError
                        If Not MarkAddressedCell(row, valerror.CellAddress, valerror.ValidationError, mCellMarker) Then
                        MarkName row, valerror.ValidationError, mCellMarker
                        End If
                        mCounts.AddNameErrors
                    Case ErrorObjectType.STEPProductError
                        'invalid id or parent
                        MarkProduct row, valerror.ValidationError, mCellMarker
                        mCounts.AddProductError
                    Case ErrorObjectType.STEPBatchError
                        If Not MarkAddressedCell(row, valerror.CellAddress, valerror.ValidationError, mCellMarker) Then
                        MarkBatch row, valerror.ValidationError, mCellMarker
                        End If
                        mCounts.AddReferenceErrors
                    Case Else
                End Select
            Next

        Else
            Dim l As New STEPLogger
            l.Severe "STEPSheetValidator.MarkAttribute", "Product with id " & vp.productid & " not found in sheet " & mSheet.Name
            Set l = Nothing
            SetError mLocalization.GetLocalizationString("STEPSheetValidatorProductNotFound") & vp.productid
            Exit Sub
        End If
SKIP_PRODUCT:
    Next Index
End Sub

Private Sub MarkProduct(ByVal row As Long, ByVal errstr As String, cellmarker As STEPCellMarker)
    If Not (mIsSmartSheet) Then
        cellmarker.MarkInvalid mSheet.cells(row, mIDCol), errstr
    Else
        If (mIsCustomSmartSheet) Then
            Dim lGroupMessages
            Dim lLeftMost As String
            lGroupMessages = Split(errstr, GROUPED_ERROR_SEPARATOR)
            Dim lLevel As Integer
            For lLevel = LBound(lGroupMessages) To UBound(lGroupMessages)
                Dim lMessage As String
                lMessage = lGroupMessages(lLevel)
                If (0 = Len(lMessage)) Then
                    'no message; nothing to do
                ElseIf (0 = lLevel) Then
                    lLeftMost = lMessage
                Else
                    Dim lBoo As Boolean
                    lBoo = False
                    Dim lColIndex As Integer
                    For lColIndex = 2 To mColcount
                        If (lLevel = mColumnSorceLevels(lColIndex)) Then
                            'first col at level
                            cellmarker.MarkInvalid mSheet.cells(row, lColIndex), lMessage
                            lBoo = True
                        End If
                    Next
                    If Not lBoo Then
                        'found no place for it; put it on entire row
                        If (0 < Len(lLeftMost)) Then
                            lLeftMost = lLeftMost & vbCrLf
                        End If
                        lLeftMost = lLeftMost & lMessage
                    End If
                End If
            Next
            If (0 < Len(lLeftMost)) Then
                cellmarker.MarkInvalid mSheet.cells(row, mIDCol + 1), errstr
            End If
        Else
            cellmarker.MarkInvalid mSheet.cells(row, mIDCol + 1), errstr
        End If
    End If
End Sub

Private Sub MarkBatch(ByVal row As Long, ByVal errstr As String, cellmarker As STEPCellMarker)
    Dim col As Integer, idRow As Long
    If (errstr <> "") Then
        idRow = mUtils.ColumnIDRowIndex
        For col = 1 To mColcount
            If (mColumnTypes(col) = STEPBatch) Then
                    cellmarker.MarkInvalid mSheet.cells(row, col), errstr
                Exit Sub
            End If
        Next
        Dim l As New STEPLogger
        l.Warning "STEPSheetValidator.MarkBatch", "Batch column not found in sheet " & mSheet.Name
        Set l = Nothing
    End If
End Sub


Private Sub MarkName(ByVal row As Long, ByVal errstr As String, cellmarker As STEPCellMarker)
    Dim col As Integer, idRow As Long
    idRow = mUtils.ColumnIDRowIndex
    For col = 1 To mColcount
        If (mColumnTypes(col) = STEPName) Then
            If (errstr <> "") Then
                cellmarker.MarkInvalid mSheet.cells(row, col), errstr
            End If
            Exit Sub
        End If
    Next
    Dim l As New STEPLogger
    l.Warning "STEPSheetValidator.MarkAttribute", "Name column not found in sheet " & mSheet.Name
    Set l = Nothing
End Sub

Private Function GetAddressedCell(ByVal pCellAdr As String) As Range
    Set GetAddressedCell = Nothing
    If (pCellAdr <> "") Then
        On Error GoTo GET_CELL_ERR
        Set GetAddressedCell = mSheet.Range(pCellAdr)
        On Error GoTo 0
        Exit Function
    End If
    Exit Function

GET_CELL_ERR:
    Dim l As New STEPLogger
    l.Warning "STEPSheetValidator.GetAddressedCell", "Trying to use invalid address " & pCellAdr & " in sheet " & mSheet.Name
    Set l = Nothing
    On Error GoTo 0
End Function

Private Function MarkStatusAddressedCell(ByVal pRow As Long, ByVal pCellAddr, ByVal pCellStatus As CellStatusType, cellmarker As STEPCellMarker) As Boolean
    MarkStatusAddressedCell = False
    Dim l As STEPLogger
    Dim lRange As Range
    Set lRange = GetAddressedCell(pCellAddr)
    If (Not lRange Is Nothing) Then
        If (lRange.row <> pRow) Then
            Set l = New STEPLogger
            l.Warning "STEPSheetValidator.MarkAttribute", "Trying to set Cell with adress " & pCellAddr & " on row " & pRow & " in sheet " & mSheet.Name
            Set l = Nothing
        Else
            cellmarker.MarkCellStatus lRange, pCellStatus
            MarkStatusAddressedCell = True
        End If
    End If
End Function


Private Function MarkAddressedCell(ByVal pRow As Long, ByVal pCellAddr, ByVal errstr As String, cellmarker As STEPCellMarker) As Boolean
    MarkAddressedCell = False
    Dim l As STEPLogger
    Dim lRange As Range
    Set lRange = GetAddressedCell(pCellAddr)
    If (Not lRange Is Nothing) Then
        If (lRange.row <> pRow) Then
            Set l = New STEPLogger
            l.Warning "STEPSheetValidator.MarkAttribute", "Trying to set Cell with adress " & pCellAddr & " on row " & pRow & " in sheet " & mSheet.Name
            Set l = Nothing
        Else
            cellmarker.MarkInvalid lRange, errstr
            MarkAddressedCell = True
        End If
    End If
End Function


Private Sub MarkCell(ByVal row As Long, ByVal coltype As STEPColumnType, ByVal id As String, ByVal errstr As String, cellmarker As STEPCellMarker)
    Dim col As Integer, idRow As Long
    idRow = mUtils.ColumnIDRowIndex
    For col = 1 To mColcount
        If mColumnIDS(col) = id Then
            If (mColumnTypes(col) = coltype) Then
                If (errstr <> "") Then
                    cellmarker.MarkInvalid mSheet.cells(row, col), errstr
                End If
            End If
            Exit Sub
        End If
    Next
    Dim l As New STEPLogger
    l.Warning "STEPSheetValidator.MarkAttribute", "Column with ID " & id & " not found in sheet " & mSheet.Name
    Set l = Nothing
End Sub

Private Sub ParseResponenseXML(responsedom, ByRef failedCount As Integer, ByRef failedProducts() As STEPValidatedProduct, _
                                                 ByRef modifiedCount As Integer, ByRef modifiedProducts() As STEPValidatedProduct, _
                                                 ByRef statusCount As Integer, ByRef statusProducts() As STEPValidatedProduct)

    Dim parser As New STEPResponseParser
    If (parser.Load(responsedom)) Then
        failedCount = parser.GetFailedProductsCount
        modifiedCount = parser.GetModifiedProductsCount
        statusCount = parser.GetStatusProductsCount
        If (failedCount > 0) Then
            failedProducts = parser.GetFailedProductsArray
        End If
        If (statusCount > 0) Then
            statusProducts = parser.GetStatusProductsArray
        End If
        If (modifiedCount > 0) Then
            modifiedProducts = parser.GetModifiedProductsArray
        End If
    Else
        failedCount = 0
        modifiedCount = 0
        statusCount = 0
        SetError parser.ParseError
    End If

End Sub

'Private Function ParseResponenseText(xmlText As String, ByRef failedCount As Integer) As STEPValidatedProduct()
'
'    Dim parser As New STEPResponseParser
'    If (parser.Parse(xmlText)) Then
'        failedCount = parser.GetFailedProductsCount
'        If (failedCount > 0) Then
'            ParseResponenseText = parser.GetFailedProductsArray
'        End If
'    Else
'        SetError parser.ParseError
'    End If
'
'End Function

Private Function RequestBunchValidation(requestdom As STEPXmlDom) As Object
    Dim stepHttp As New STEPXmlHttp
    'Dim lTimer As New STEPTimer
    'lTimer.StartTimer "Initialize request"
    If (Not mStepUser Is Nothing) Then
        stepHttp.Init requestUtils.STEPValidationURL, username:=mStepUser.username, password:=mStepUser.password, timeout:=-1, token:=mStepUser.token
    Else
        stepHttp.Init requestUtils.STEPValidationURL
    End If
    'lTimer.StopTimer
    'lTimer.StartTimer "Posting XML request"
    If (Not stepHttp.PostXML(requestdom)) Then
        SetError stepHttp.ErrorDescription
        Set RequestBunchValidation = Nothing
        Exit Function
    End If
    'lTimer.StopTimer
    'lTimer.StartTimer "Retrieving response"
    Set RequestBunchValidation = stepHttp.ResponseXML
    'lTimer.StopTimer
    'Debug.Print RequestBunchValidation.xml
End Function

Private Function RequestBunchValidationText(requesttext) As String
    Dim stepHttp As New STEPXmlHttp
    If (Not mStepUser Is Nothing) Then
        stepHttp.Init requestUtils.STEPValidationURL, username:=mStepUser.username, password:=mStepUser.password, timeout:=-1, token:=mStepUser.token
    Else
        stepHttp.Init requestUtils.STEPValidationURL
    End If
    If (Not stepHttp.PostText(requesttext)) Then
        SetError stepHttp.ErrorDescription
        RequestBunchValidationText = ""
        Exit Function
    End If
    RequestBunchValidationText = stepHttp.ResponseText
End Function

Private Function BuildNextBunchXML() As STEPRequestBuilder
    On Error GoTo BUILD_ERR
    Dim mTimer As New STEPTimer
    Dim Count As Long
    Dim rowIndex As Long, colIndex As Long
    Dim sendToServer As Boolean
    Dim rb As New STEPRequestBuilder
    Dim strval As String
    Dim cell As Range
    Dim missingmandatory As Boolean
    Dim changes As New STEPChangeTracker
    Dim addParentFromSettings As Boolean
    Dim lBunchSize
    Dim sInitiateRootProductId As String
    Dim sCategoryID As String
    Dim multiCategoryTemplateWorkbook As Boolean
    Dim lSupplierInfo As STEPSupplierInfo
    Dim lIsMissingMandatoryProduct As Boolean
    Count = 0
    mTimer.StartTimer "Build xml bunch"
    If (mIsSmartSheet) Then
        'increase number of rows send to server - speeds up large validations
        lBunchSize = SMARTSHEET_BUNCH_SIZE
    Else
        lBunchSize = BUNCH_SIZE
    End If
    sInitiateRootProductId = mUtils.GetInitiateRootProductId
    'only smartsheets can have multiple product sheets when initiatiating
    multiCategoryTemplateWorkbook = mUtils.IsMultipleCategorySmartSheet
    If (mIsSmartSheet) Then
        If (multiCategoryTemplateWorkbook) Then
            'on smartsheet-multicategory-initiate validation should use this
            sCategoryID = mUtils.GetSheetInitiateRootProductId(mSheet)
        Else
            'otherwise smartsheet validation dont care (must use sInitiateRootProductId for tempates)
            sCategoryID = ""
        End If
    Else
        'this is for variants-quicksheets
        sCategoryID = mUtils.GetSheetProductsCategory(mSheet)
    End If
    'notice that CategoryID has different meanings/values on smartsheets and quicksheets
    rb.InitRequest mUtils.STEPContext, _
            mUtils.STEPWorkspace, _
            Stateflow:=mUtils.STEPStateFlow, _
            State:=mUtils.STEPState, _
            CategoryID:=sCategoryID, _
            SupplierGroup:=mUtils.STEPSupplierGroup, _
            isSmartsheet:=mIsSmartSheet, _
            SheetAnnotation:=mSheetAnnotation
    Do While True
                If mSkipHidden Then
                        If IsRowHidden(mCurrentRow) Then
                                GoTo SKIP_PRODUCT
                        End If
                End If
        lIsMissingMandatoryProduct = False
        addParentFromSettings = mIsinitiate
        missingmandatory = False
        rowIndex = mCurrentRow
        If (Count >= lBunchSize) Then
            GoTo LOOP_DONE
        End If

        If IsEmptyRow(rowIndex) Then
            If (mEmptyRowCounter > 10) Then
                'stop validation of sheet af 10 CONSECUTIVE empty rows
                mDone = True
                GoTo LOOP_DONE
            Else
                mEmptyRowCounter = mEmptyRowCounter + 1
                GoTo SKIP_PRODUCT
            End If
        Else
            'reset count of empty rows
            mEmptyRowCounter = 0
        End If
'putting this here is quite confusing in the result, lets try only counting thow actually send to server
'        mCounts.AddProducts
        Dim sid As String
        Dim lRowAnnotation
        sid = mSheet.cells(rowIndex, mIDCol).Value
        If (sid = "") Then
            If (mIniateAutoID) Then
                sid = rowIndex
            Else
                If Not (mIsSmartSheet) Then
                    mCellMarker.MarkInvalid mSheet.cells(rowIndex, mIDCol), mLocalization.GetLocalizationString("STEPSheetValidatorMissingID")
                    mCounts.AddMissingMandatoryProducts
                    mCounts.AddMissingMandatoryValues
                End If
                GoTo SKIP_PRODUCT
            End If
        End If
        If ForceFullValidation Then
            sendToServer = True
        Else
            sendToServer = changes.IsProductChanged(mSheet.Name, sid, mCurrentRow)
        End If
        If sendToServer Then 'only changed products should be sendt to server (if not forced to all)
            Set lSupplierInfo = Nothing
            If (mIsinitiate) Then
                If (mSupplierColumnIndx > 1) Then
                    Set lSupplierInfo = mUtils.GetSupplierInfo(VBA.Trim(mSheet.cells(rowIndex, mSupplierColumnIndx).Value))
                    If (lSupplierInfo Is Nothing) Then
                        mCellMarker.MarkInvalid mSheet.cells(rowIndex, mSupplierColumnIndx), mLocalization.GetLocalizationString("STEPSheetValidatorMissing") & mUtils.GetColumnHeader(mSheet, mSupplierColumnIndx)
                        mErrorTracker.Add sid
                        If Not lIsMissingMandatoryProduct Then
                            mCounts.AddMissingMandatoryProducts
                            lIsMissingMandatoryProduct = True
                        End If
                        mCounts.AddMissingMandatoryValues
                        GoTo SKIP_PRODUCT
                    End If
                End If
                If (mSmartSheetType = STEPMultiObjectTypeType) Then
                    Dim lRowObjectType As String

                    If (mObjectTypeColumnIndex > 1) Then
                        lRowObjectType = VBA.Trim(mSheet.cells(rowIndex, mObjectTypeColumnIndex).Value)
                    Else
                        lRowObjectType = mInitiateObjectType
                    End If

                    If (lRowObjectType <> "") Then
                        rb.AddProduct sid, inititate:=True, producttype:=lRowObjectType, rowSupplierInfo:=lSupplierInfo, pCellAddr:=mSheet.cells(rowIndex, mIDCol).Address
                    Else
                        mCellMarker.MarkInvalid mSheet.cells(rowIndex, mObjectTypeColumnIndex), mLocalization.GetLocalizationString("STEPSheetValidatorMissing") & mUtils.GetColumnHeader(mSheet, mObjectTypeColumnIndex)
                        mErrorTracker.Add sid
                        If Not lIsMissingMandatoryProduct Then
                            mCounts.AddMissingMandatoryProducts
                            lIsMissingMandatoryProduct = True
                        End If
                        mCounts.AddMissingMandatoryValues
                        GoTo SKIP_PRODUCT
                    End If

                Else
                    rb.AddProduct sid, inititate:=True, producttype:=mInitiateObjectType, rowSupplierInfo:=lSupplierInfo, pCellAddr:=mSheet.cells(rowIndex, mIDCol).Address
                End If
            Else
                rb.AddProduct sid, rowAnnotation:=mSheet.cells(rowIndex, mColcount + 1), pCellAddr:=mSheet.cells(rowIndex, mIDCol).Address
            End If
            'try putting this here so we only display # of products actually sendt to server
            mCounts.AddProducts
            'remove row-identifier from previous errors so we can put it back on any error
            mErrorTracker.Remove sid
        End If

        'checking second column for duplicates'
        If (mIsSmartSheet And mIsinitiate And mSmartSheetType = STEPMultiLevelType And (mColumnSorceLevels(mColcount) = 0)) Then
            mDuplicates.AddWithKey mSheet.cells(rowIndex, mIDCol + 1).Value, rowIndex
        End If


        For colIndex = 1 To mColcount
            Set cell = mSheet.cells(rowIndex, colIndex)
            Dim cellAddr As String
            cellAddr = cell.Address
            strval = cell.Value
            If (colIndex = mIDCol) Then
                If (Not mIsSmartSheet) Then
                    'on smartsheets this column is always hidden
                    If (mReadonlyCoumns(colIndex)) Then
                        'can previously have been marked invalid
                        mCellMarker.MarkValidReadonly cell
                    ElseIf (mMandatoryColumns(colIndex)) Then
                        'can previously have been marked missing mandatory
                        mCellMarker.MarkValidMandatory cell
                    End If
                End If
            Else
                If mReadonlyCoumns(colIndex) Then
                    'cm.MarkValidReadonly cell
                Else
                    Dim lCellStatus As STEPCellStatus
                    Set lCellStatus = Nothing
                    If STEPColumnType.STEPAttribute = mColumnTypes(colIndex) Then
                        Set lCellStatus = mStatusTracker.GetCellStatus(cellAddr)
                    End If
                    If (Not lCellStatus Is Nothing) Then
                        If (Not sendToServer) Then
                            If ((lCellStatus.CellStatus = STEPCellMandatory) And (Len(strval) = 0)) Then
                                mCellMarker.MarkMissingMandatory cell
                                'missing mandatory is enough to get it into error-list
                                mErrorTracker.Add sid
                                If Not lIsMissingMandatoryProduct Then
                                    mCounts.AddMissingMandatoryProducts
                                    lIsMissingMandatoryProduct = True
                                End If
                                mCounts.AddMissingMandatoryValues
                            Else
                                mCellMarker.MarkCellStatus cell, lCellStatus.CellStatus
                            End If
                        End If
                    ElseIf (mMandatoryColumns(colIndex)) Then
                        If (Not sendToServer) Then
                            If (Len(strval) = 0) Then
                               'if product is send to server we defer handling of mandatory til MarkRequestedWithDefault
                                mCellMarker.MarkMissingMandatory cell
                                'missing mandatory is enough to get it into error-list
                                mErrorTracker.Add sid
                                If Not lIsMissingMandatoryProduct Then
                                    mCounts.AddMissingMandatoryProducts
                                    lIsMissingMandatoryProduct = True
                                End If
                                mCounts.AddMissingMandatoryValues
                            Else
                                'only set it valid if marked as invalid because of missing value
                                If (mCellMarker.HasMissingMandatoryMark(cell)) Then
                                    mCellMarker.MarkValidMandatory cell
                                End If
                            End If
                        End If
                    End If
                    If sendToServer Then 'only changed products should be sendt to server
                        'leave any formattint and unlocking to MarkRequestedWithDefault
                        Dim sourceLevel As Integer
                        sourceLevel = mColumnSorceLevels(colIndex)
                        Dim sourceObjectType As String
                        sourceObjectType = mColumnSorceObjectTypes(colIndex)
                        Dim useLOVID As String
                        useLOVID = mColumnUseLOVID(colIndex)
                        Dim columnAnnotation As String
                        columnAnnotation = mColumnAnnotations(colIndex)
                        Dim colContextID As String
                        colContextID = mColumnContextIDs(colIndex)
                        Select Case mColumnTypes(colIndex)
                            Case STEPColumnType.STEPObjectType
                                'do nothing - only MultiObjectType smartsheets can do this and then we already have examined it
                            Case STEPColumnType.STEPReference
                                If (Len(strval) > 0) Then
                                    rb.AddReference mColumnIDS(colIndex), mUtils.SplitMultivalue(strval), mCreateTargetColumns(colIndex), sourceObjectType, sourceLevel, cellAddr, colContextID, columnAnnotation
                                End If
                            Case STEPColumnType.STEPLink
                                If (Len(strval) > 0) Then
                                    rb.AddLink mColumnIDS(colIndex), mUtils.SplitMultivalue(strval), mCreateTargetColumns(colIndex), sourceObjectType, sourceLevel, cellAddr, colContextID, columnAnnotation
                                End If
                            Case STEPColumnType.STEPAttribute
                                Dim lCellStatusString As String
                                If Not (lCellStatus Is Nothing) Then
                                    'remove it - might come back after validation
                                    mStatusTracker.RemoveCellStatus cellAddr
                                    lCellStatusString = lCellStatus.CellStatusString
                                Else
                                    lCellStatusString = ""
                                End If
                                If (mUtils.IsColumnMultivalued(mSheet, colIndex)) Then
                                    rb.AddMultiValue mColumnIDS(colIndex), mUtils.SplitMultivalue(strval), sourceObjectType, useLOVID, sourceLevel, cellAddr, colContextID, mLocale, columnAnnotation, mColumnBaseTypes(colIndex), lCellStatusString
                                Else
                                    rb.AddValue mColumnIDS(colIndex), strval, sourceObjectType, useLOVID, sourceLevel, cellAddr, colContextID, mLocale, columnAnnotation, mColumnBaseTypes(colIndex), lCellStatusString
                                End If
                            Case STEPColumnType.STEPID
                                'do nothing
                            Case STEPColumnType.STEPReadOnly
                                'do nothing
                            Case STEPColumnType.STEPName
                                rb.SetProductName strval, sourceObjectType, sourceLevel, cellAddr, colContextID, columnAnnotation
                            Case STEPColumnType.STEPParentID
                                If (Len(strval) > 0) Then
                                    addParentFromSettings = False
                                    rb.SetProductParentID strval
                                End If
                            Case STEPColumnType.STEPBatch
                                If (Len(strval) > 0) Then
                                    rb.AddBatches mUtils.SplitMultivalue(strval), cellAddr, columnAnnotation
                                End If
                        End Select
                    End If 'sendToServer
                End If 'not read only

            End If 'col <> idcol
NEXT_COL:
        Next 'col
        'this way we actually shaves a tiny bit of the request size
        'and currently all products have the same parent anyway - we might have to change this at some point
        'NOTE that it is the servers responsibility to check fo initiate mode on product and use parent id from product/settings sheet
        'and use category id from sheert (supplied on on products tag in the requst) if parent id is not present
        If Not multiCategoryTemplateWorkbook And sendToServer And addParentFromSettings Then
            rb.SetProductParentID mUtils.GetInitiateRootProductId
        End If

SKIP_PRODUCT:
        mCurrentRow = mCurrentRow + 1
        Count = Count + 1

    Loop
LOOP_DONE:
    Set BuildNextBunchXML = rb
    mTimer.StopTimer
    Exit Function

BUILD_ERR:
    Set rb = Nothing
    SetError err.Description
    Set BuildNextBunchXML = Nothing


End Function


Public Property Get Counts() As STEPValidationCounts
    Set Counts = mCounts
End Property

Public Property Get HasDuplicates() As Boolean
    If mDuplicates.Count > 1 Then
    Dim i As Integer
    Dim s As String
    Dim j As Integer
    s = "deduplicateString"
    For j = 1 To mDuplicates.Count
        For i = j To mDuplicates.Count
            If (s = mDuplicates.Item(i)) Then
                HasDuplicates = True
                Exit Property
            End If
        Next i
        s = mDuplicates.Item(j)
    Next j
    End If
    HasDuplicates = False
End Property


Attribute VB_Name = "STEPStyleHelper"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit


Private Const HEADER_COLOR_ROW = 3
Private Const MANDATORY_COLOR_ROW = 4
Private Const READONLY_COLOR_ROW = 5
Private Const ERROR_COLOR_ROW = 6
Private Const GRADIENT_START_COLOR_ROW = 7
Private Const GRADIENT_END_COLOR_ROW = 8
Private Const BORDER_COLOR_ROW = 9
Private Const HEADERTEXT_COLOR_ROW = 10
Private Const INHERITED_VALUES_COLOR_ROW = 11
Private Const BACKGROUND_COLOR_ROW = 12
Private Const HIGHLIGHT_HEADER_COLOR_ROW = 13
Private Const INOPERATIVETTEXT_COLOR_ROW = 14
Private Const ADDITIONAL_HEADER_COLOR_ROW = 15
Private Const TEMPLATEPRODUCT_COLOR_ROW = 16
Private Const TEMPLATEPRODUCTTEXT_COLOR_ROW = 17
Private Const TEMPLATEPRODUCTBORDER_COLOR_ROW = 18
Private Const WORKINGCOLUMN_HEADER_COLOR_ROW = 19
Private Const R_COL = 12
Private Const FIRST_COLOR = HEADER_COLOR_ROW
Private Const LAST_COLOR = WORKINGCOLUMN_HEADER_COLOR_ROW

Private m2007Compatible As Boolean

Private mUtils As STEPSheetUtils

Dim mRGB() As Long
Dim mColorIndexs() As Integer

Private Sub Class_Initialize()
    ReDim mColorIndexs(FIRST_COLOR To LAST_COLOR) As Integer
    ReDim mRGB(FIRST_COLOR To LAST_COLOR) As Long
    m2007Compatible = ThisWorkbook.Application.Version >= "12.0"
    Set mUtils = New STEPSheetUtils
    If (mUtils.HasSettingsSheet) Then
        Dim Sh As Worksheet
        Set Sh = mUtils.SettingsSheet
        On Error GoTo DEFAULT
        Dim row As Integer
        For row = FIRST_COLOR To LAST_COLOR
            mRGB(row) = RGB(CInt(Sh.cells(row, R_COL).Value), CInt(Sh.cells(row, R_COL + 1).Value), CInt(Sh.cells(row, R_COL + 2).Value))
            mColorIndexs(row) = CInt(Sh.cells(row, R_COL + 3))
        Next
    Else
        GoTo DEFAULT
    End If
    
    Exit Sub
DEFAULT:
    mRGB(HEADER_COLOR_ROW) = RGB(62, 108, 164)
    mRGB(MANDATORY_COLOR_ROW) = RGB(197, 217, 241)
    mRGB(READONLY_COLOR_ROW) = RGB(525, 250, 241)
    mRGB(ERROR_COLOR_ROW) = RGB(253, 53, 53)
    mRGB(GRADIENT_START_COLOR_ROW) = RGB(255, 255, 255)
    mRGB(GRADIENT_END_COLOR_ROW) = RGB(190, 190, 190)
    mRGB(BORDER_COLOR_ROW) = RGB(165, 165, 165)
    mRGB(HEADERTEXT_COLOR_ROW) = RGB(255, 255, 255)
    mRGB(INHERITED_VALUES_COLOR_ROW) = RGB(0, 180, 0)
    mRGB(HIGHLIGHT_HEADER_COLOR_ROW) = RGB(0, 128, 0)
    mRGB(INOPERATIVETTEXT_COLOR_ROW) = RGB(120, 120, 120)
    mRGB(ADDITIONAL_HEADER_COLOR_ROW) = RGB(120, 120, 120)
    mRGB(TEMPLATEPRODUCT_COLOR_ROW) = RGB(230, 230, 230)
    mRGB(TEMPLATEPRODUCTTEXT_COLOR_ROW) = RGB(51, 51, 51)
    mRGB(TEMPLATEPRODUCTBORDER_COLOR_ROW) = RGB(0, 0, 0)
    mRGB(WORKINGCOLUMN_HEADER_COLOR_ROW) = RGB(112, 48, 160)
    
    mColorIndexs(HEADER_COLOR_ROW) = 23
    mColorIndexs(MANDATORY_COLOR_ROW) = 37
    mColorIndexs(READONLY_COLOR_ROW) = 36
    mColorIndexs(ERROR_COLOR_ROW) = 3
    mColorIndexs(GRADIENT_START_COLOR_ROW) = 15
    mColorIndexs(GRADIENT_END_COLOR_ROW) = 15
    mColorIndexs(BORDER_COLOR_ROW) = 16
    mColorIndexs(HEADERTEXT_COLOR_ROW) = 2
    mColorIndexs(INHERITED_VALUES_COLOR_ROW) = 4
    mColorIndexs(BACKGROUND_COLOR_ROW) = 5
    mColorIndexs(HIGHLIGHT_HEADER_COLOR_ROW) = 17
    mColorIndexs(INOPERATIVETTEXT_COLOR_ROW) = 16
    mColorIndexs(ADDITIONAL_HEADER_COLOR_ROW) = 16
    mColorIndexs(TEMPLATEPRODUCT_COLOR_ROW) = 15
    mColorIndexs(TEMPLATEPRODUCTTEXT_COLOR_ROW) = 56
    mColorIndexs(TEMPLATEPRODUCTBORDER_COLOR_ROW) = 1
    mColorIndexs(WORKINGCOLUMN_HEADER_COLOR_ROW) = 13
End Sub

Private Function HasStyle(cells As Range, Index As Integer)
    HasStyle = False
    With cells
        If (m2007Compatible) Then
            HasStyle = .Interior.color = mRGB(Index)
        Else
            HasStyle = .Interior.ColorIndex = mColorIndexs(Index)
        End If
    End With
End Function


Private Sub SetStyle(cells As Range, Index As Integer)
    Dim ma As Range
    With cells
        If (m2007Compatible) Then
            .Interior.color = mRGB(Index)
            '.BorderAround Color:=mRGB(BORDER_COLOR_ROW)
            If (.MergeCells) Then
                For Each ma In .MergeArea
                    ma.BorderAround ColorIndex:=xlColorIndexNone, color:=mRGB(BORDER_COLOR_ROW)  'RGB(165, 165, 165)
                    ma.Borders.color = mRGB(BORDER_COLOR_ROW)
                Next ma
            Else
                .BorderAround ColorIndex:=xlColorIndexNone, color:=mRGB(BORDER_COLOR_ROW)  'RGB(165, 165, 165)
                .Borders.color = mRGB(BORDER_COLOR_ROW)
            End If
'            .Borders.Color = mRGB(BORDER_COLOR_ROW)
        Else
            .Interior.ColorIndex = mColorIndexs(Index)
            If (.MergeCells) Then
                For Each ma In .Areas
                    ma.BorderAround ColorIndex:=mColorIndexs(BORDER_COLOR_ROW)
                Next ma
            Else
                .BorderAround ColorIndex:=mColorIndexs(BORDER_COLOR_ROW)
            End If
        End If
    End With
End Sub
Public Function isReadOnlyColor(ByVal color As Variant) As Boolean
    If (m2007Compatible) Then
        isReadOnlyColor = (color = mRGB(READONLY_COLOR_ROW))
    Else
        isReadOnlyColor = (color = mColorIndexs(READONLY_COLOR_ROW))
    End If
End Function

Private Sub SetBorder(cells As Range, border As Integer)
    With cells
        If (m2007Compatible) Then
            .BorderAround color:=mRGB(border)
        Else
            .BorderAround ColorIndex:=mColorIndexs(border)
        End If
    End With
End Sub


Private Sub HighLightHeaders(cells As Range)
    'do not kill the sheet for color
    On Error GoTo HIGHLIGHT_FALIED
    If (mUtils.HasExtendedSettingsSheet) Then
        Dim sheet As Worksheet
        Set sheet = cells.Worksheet
        Dim level As Integer
        Dim lCol As Long
        Dim tmp As Integer
        Dim cell As Range
        level = -1
        For Each cell In cells
          If (cell.Column > 1) Then
            tmp = mUtils.GetColumnSourceLevel(sheet, cell.Column)
            If (tmp > level) Then
                SetStyle cell, HIGHLIGHT_HEADER_COLOR_ROW
                level = tmp
            End If
          End If
        Next
    End If
HIGHLIGHT_FALIED:
    err.Clear
End Sub

Private Sub SetWorkingColumnHeaderStyle(cells As Range)
    If (Not mUtils.AddWorkingColumn) Then
        Exit Sub
    End If
    Dim cell As Range
    For Each cell In cells
        If (mUtils.IsWorkingColumn(cell.Worksheet, cell.Column)) Then
            SetStyle cell, WORKINGCOLUMN_HEADER_COLOR_ROW
        End If
    Next
End Sub

Public Function HasInoperativeStyle(cells As Range) As Boolean
    If (m2007Compatible) Then
        HasInoperativeStyle = (cells.Font.color = mRGB(INOPERATIVETTEXT_COLOR_ROW))
    Else
        HasInoperativeStyle = (cells.Font.ColorIndex = mColorIndexs(INOPERATIVETTEXT_COLOR_ROW))
    End If
End Function

Public Sub SetInoperativeStyle(cells As Range)
    If (m2007Compatible) Then
        cells.Font.ColorIndex = xlColorIndexNone
        cells.Font.color = mRGB(INOPERATIVETTEXT_COLOR_ROW)
    Else
        cells.Font.ColorIndex = mColorIndexs(INOPERATIVETTEXT_COLOR_ROW)
    End If

End Sub

Public Sub SetHeaderStyle(cells As Range)
    SetStyle cells, HEADER_COLOR_ROW
    If (m2007Compatible) Then
        cells.Font.color = mRGB(HEADERTEXT_COLOR_ROW)
        cells.Font.Bold = True
    Else
        cells.Font.ColorIndex = mColorIndexs(HEADERTEXT_COLOR_ROW)
        cells.Font.Bold = True
    End If
    HighLightHeaders cells
    SetWorkingColumnHeaderStyle cells
End Sub

Public Function HasMandatoryStyle(cells As Range)
    HasMandatoryStyle = HasStyle(cells, MANDATORY_COLOR_ROW)
End Function

Public Function HasErrorStyle(cells As Range)
    HasErrorStyle = HasStyle(cells, ERROR_COLOR_ROW)
End Function

Public Function HasReadOnlyStyle(cells As Range)
    HasReadOnlyStyle = HasStyle(cells, READONLY_COLOR_ROW) And (cells.Font.ColorIndex = xlColorIndexAutomatic)
End Function

Public Sub SetMandatoryStyle(cells As Range)
    SetStyle cells, MANDATORY_COLOR_ROW
End Sub

Public Sub SetReadOnlyStyle(cells As Range)
    SetStyle cells, READONLY_COLOR_ROW
End Sub

Public Sub SetErrorStyle(cells As Range)
    SetStyle cells, ERROR_COLOR_ROW
End Sub

Public Sub SetInheritedStyle(cells As Range)
    SetBorder cells, INHERITED_VALUES_COLOR_ROW
End Sub

Public Sub SetButtonStyle(cells As Range)
    If (m2007Compatible) Then
        With cells.Interior
            .Pattern = 4000
            .Gradient.Degree = 90
            .Gradient.ColorStops.Clear
            With .Gradient.ColorStops.Add(0)
                .color = mRGB(GRADIENT_START_COLOR_ROW)
                .TintAndShade = 0
            End With
            With .Gradient.ColorStops.Add(1)
                .color = mRGB(GRADIENT_END_COLOR_ROW)
                .TintAndShade = 0
            End With
        End With
    Else
        SetStyle cells, GRADIENT_END_COLOR_ROW
    End If
End Sub

Public Sub ClearStyles(cells As Range)
    If (cells.Interior.ColorIndex <> xlColorIndexNone) Then cells.Interior.ColorIndex = 0 ' clear colors
    If (cells.Font.ColorIndex <> xlColorIndexAutomatic) Then cells.Font.ColorIndex = xlColorIndexAutomatic
End Sub

Public Sub SetTemplateProductStyle(cells As Range)
    SetStyle cells, TEMPLATEPRODUCT_COLOR_ROW
    SetTemplateProductTextStyle cells
    SetTemplateProductBorderStyle cells
End Sub

Public Function HasTemplateProductStyle(cells As Range)
    HasTemplateProductStyle = HasStyle(cells, TEMPLATEPRODUCT_COLOR_ROW) And HasTemplateProductTextStyle(cells) And HasTemplateProductBorderStyle(cells)
End Function

Private Sub SetTemplateProductTextStyle(cells As Range)
    cells.Font.Italic = True
    cells.Font.size = 10
    If (m2007Compatible) Then
        cells.Font.ColorIndex = xlColorIndexNone
        cells.Font.color = mRGB(TEMPLATEPRODUCTTEXT_COLOR_ROW)
    Else
        cells.Font.ColorIndex = mColorIndexs(TEMPLATEPRODUCTTEXT_COLOR_ROW)
    End If

End Sub

Private Function HasTemplateProductTextStyle(cells As Range) As Boolean
    HasTemplateProductTextStyle = (cells.Font.Italic = True) And (cells.Font.size = 10)
    If (HasTemplateProductTextStyle = False) Then
        Exit Function
    End If
    If (m2007Compatible) Then
        HasTemplateProductTextStyle = (cells.Font.color = mRGB(TEMPLATEPRODUCTTEXT_COLOR_ROW))
    Else
        HasTemplateProductTextStyle = (cells.Font.ColorIndex = mColorIndexs(TEMPLATEPRODUCTTEXT_COLOR_ROW))
    End If
End Function

Private Sub SetTemplateProductBorderStyle(cells As Range)
    Dim ma As Range
    With cells
        If (.MergeCells) Then
            For Each ma In .MergeArea
                ma.Borders(xlEdgeBottom).Weight = xlThick
                If (m2007Compatible) Then
                    ma.Borders(xlEdgeBottom).color = mRGB(TEMPLATEPRODUCTBORDER_COLOR_ROW)
                Else
                    ma.Borders(xlEdgeBottom).ColorIndex = mColorIndexs(TEMPLATEPRODUCTBORDER_COLOR_ROW)
                End If
            Next ma
        Else
            cells.Borders(xlEdgeBottom).Weight = xlThick
            If (m2007Compatible) Then
                .Borders(xlEdgeBottom).color = mRGB(TEMPLATEPRODUCTBORDER_COLOR_ROW)
            Else
                .Borders(xlEdgeBottom).ColorIndex = mColorIndexs(TEMPLATEPRODUCTBORDER_COLOR_ROW)
            End If
        End If
    End With
End Sub

Private Function HasTemplateProductBorderStyle(cells As Range)
    Dim ma As Range
    With cells
        If (.MergeCells) Then
            For Each ma In .MergeArea
                HasTemplateProductBorderStyle = (ma.Borders(xlEdgeBottom).Weight = xlThick)
                If (HasTemplateProductBorderStyle = False) Then
                    Exit Function
                End If
                If (m2007Compatible) Then
                    HasTemplateProductBorderStyle = (ma.Borders(xlEdgeBottom).color = mRGB(TEMPLATEPRODUCTBORDER_COLOR_ROW))
                Else
                    HasTemplateProductBorderStyle = (ma.Borders(xlEdgeBottom).ColorIndex = mColorIndexs(TEMPLATEPRODUCTBORDER_COLOR_ROW))
                End If
                If (HasTemplateProductBorderStyle = False) Then
                    Exit Function
                End If
            Next ma
        Else
            HasTemplateProductBorderStyle = (.Borders(xlEdgeBottom).Weight = xlThick)
            If (HasTemplateProductBorderStyle = False) Then
                Exit Function
            End If
            If (m2007Compatible) Then
                HasTemplateProductBorderStyle = (.Borders(xlEdgeBottom).color = mRGB(TEMPLATEPRODUCTBORDER_COLOR_ROW))
            Else
                HasTemplateProductBorderStyle = (.Borders(xlEdgeBottom).ColorIndex = mColorIndexs(TEMPLATEPRODUCTBORDER_COLOR_ROW))
            End If
        End If
    End With
End Function
Attribute VB_Name = "STEPSupplierInfo"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Dim mSupplierKey As String
Dim mSupplierID As String
Dim mSupplierProductClassification As String
Dim mSupplierAssetClassification As String
Dim mCreatetargetSeparator

Public Sub Init(ByVal pSupplierKey As String, _
                ByVal pSupplierID As String, _
                ByVal pSupplierProductClassification As String, _
                ByVal pSupplierAssetClassification As String, _
                ByVal pCreatetargetSeparator As String)
    mSupplierKey = pSupplierKey
    mSupplierID = pSupplierID
    mSupplierProductClassification = pSupplierProductClassification
    mSupplierAssetClassification = pSupplierAssetClassification
    mCreatetargetSeparator = pCreatetargetSeparator
End Sub

Public Property Get supplierKey() As String
    supplierKey = mSupplierKey
End Property

Public Property Get SupplierID() As String
    SupplierID = mSupplierID
End Property

Public Property Get SupplierProductClassification() As String
    SupplierProductClassification = mSupplierProductClassification
End Property

Public Property Get SupplierAssetClassification() As String
    SupplierAssetClassification = mSupplierAssetClassification
End Property

Public Property Get CreateTargetPrefix() As String
    CreateTargetPrefix = ""
    If (mSupplierAssetClassification <> "") Then
        CreateTargetPrefix = SupplierID & mCreatetargetSeparator
    End If
End Property
Attribute VB_Name = "STEPTemplateProductHelper"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Private mUtils As New STEPSheetUtils

Public Function isTemplateProductRow(cells As Range) As Boolean
    isTemplateProductRow = (cells(1, 1).Value = "STIBO_SMARTSHEET_TEMPLATE_PRODUCT")
End Function

Public Function anyTemplateProductRowInWorkbook(wb As Workbook) As Boolean
anyTemplateProductRowInWorkbook = False
Dim ws As Worksheet
For Each ws In wb.Sheets
    If (TypeOf ws Is Worksheet) Then
        If (mUtils.IsProductsSheet(ws)) Then
            Dim row As Long
            row = mUtils.FirstProductRow(ws, True)
            If (isTemplateProductRow(ws.cells(row, 1))) Then
                anyTemplateProductRowInWorkbook = True
                Exit Function
            End If
        End If
     End If
Next
End Function

Attribute VB_Name = "STEPTimer"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
'setting this constant to anything but one will silence the chatty timer
#Const TimerMode = 0
'rather crude timer. 1/100 of seconds on windows, whole seconds on mac
'returns wrong result if running across midnight

Private mTicks As Single
Private mLabel As String
Private mRunning As Boolean

Public Sub StartTimer(ByVal label As String)
#If TimerMode = 1 Then
    mTicks = VBA.Timer
    mLabel = label
    mRunning = True
#End If
End Sub

Public Sub AddInfoToOutput(ByVal info As String)
#If TimerMode = 1 Then
    Debug.Print info
#End If
End Sub

Public Property Get Elapsed() As Single
#If TimerMode = 1 Then
    If (mRunning) Then
        'lap time
        Elapsed = VBA.Timer() - mTicks
    Else
        Elapsed = mTicks
    End If
#Else
    Elapsed = 0
#End If
End Property

Public Function StopTimer(Optional ByVal suffix As String = "") As Long
'do not fill up Immediate unless we have to
#If TimerMode = 1 Then
    mTicks = VBA.Timer - mTicks
    StopTimer = mTicks
    mRunning = False
    Debug.Print mLabel & ": " & VBA.FormatNumber(mTicks, 2) + " s " + suffix
#Else
    StopTimer = 0
#End If
End Function



Attribute VB_Name = "STEPUser"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private mUserName As String
Private mPassword As String
Private mToken As String

Public Property Get username() As String
    username = mUserName
End Property

Public Property Let username(ByVal str As String)
    mUserName = str
End Property

Public Property Get password() As String
    password = mPassword
End Property

Public Property Let password(ByVal str As String)
    mPassword = str
End Property

Public Property Get token() As String
        token = mToken
End Property

Public Property Let token(ByVal str As String)
        mToken = str
End Property
Attribute VB_Name = "STEPValidateForm"
Attribute VB_Base = "0{76A1BDD5-0D7A-49FB-BC09-2BFD6CD8CBC0}{9FEE06DE-0A06-4630-838C-00BCD6EC40CA}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False










Option Explicit
Private mRunning As Boolean
Private mSheets() As Worksheet
Private mUtils As New STEPSheetUtils
Private mChangeTracher As New STEPChangeTracker
Private mHasRun As Boolean
Private mStepUser As STEPUser
Private mLocale As New STEPLocalization

Private Const CONFIRM_THRESHOLD = 50
#If Mac Then
  Private Const mcFontSize As Long = 10
#Else
  Private Const mcFontSize As Long = 8
#End If



Public Sub ValidateSheet(ws As Worksheet)
    If Not mUtils.IsProductsSheet(ws) Then
        MsgBox ws.Name & mLocale.GetLocalizationString("ValidationNothingToValidate"), Buttons:=vbOKOnly, Title:=mLocale.GetLocalizationString("ValidationTitle")
        Exit Sub
    End If
    ReDim mSheets(1 To 1) As Worksheet
    Set mSheets(1) = ws
    mRunning = False
    mHasRun = False
    chkValidateHiddenRows.Visible = False
    If (mUtils.UseFilter = True) Then
        chkValidateHiddenRows.Visible = True
        chkValidateHiddenRows.Value = True
    End If
    chkOnlyChangedValidation.Value = True
    chkEntireWorkbook.Value = False
    chkEntireWorkbook.Enabled = GetAllSheetsCollection.Count > 1
    #If Mac Then
       Me.Show vbModeless
    #Else
       Me.Show vbModal
    #End If
End Sub

Public Sub ValidateBook(wb As Workbook)
    mRunning = False
    mHasRun = False
    Dim col As New Collection
    Dim ws
    For Each ws In wb.Worksheets
        Dim wss As Worksheet
        If TypeOf ws Is Worksheet Then 'hm - is this nessecery ?
            Set wss = ws
            If mUtils.IsProductsSheet(wss) Then
                col.Add ws
            End If
        End If
    Next
    If col.Count = 0 Then
        MsgBox mLocale.GetLocalizationString("ValidationNoProductSheets"), Buttons:=vbOKOnly, Title:=mLocale.GetLocalizationString("ValidationTitle")
        Exit Sub
    End If
    ReDim mSheets(1 To col.Count) As Worksheet
    Dim i As Integer
    i = 0
    For Each ws In col
        i = i + 1
        Set mSheets(i) = ws
    Next
    #If Mac Then
       Me.Show vbModeless
    #Else
       Me.Show vbModal
    #End If
End Sub


Private Function ConfirmStop() As Boolean
    If (IsRunning) Then
        Dim lUpdateing  As Boolean
        lUpdateing = ThisWorkbook.Application.ScreenUpdating
        ThisWorkbook.Application.ScreenUpdating = True
        If (MsgBox(mLocale.GetLocalizationString("ValidationCancelProcess"), Buttons:=vbYesNo + vbQuestion + vbDefaultButton2, Title:=mLocale.GetLocalizationString("ValidationCancelProcessTitle")) = vbYes) Then

            ConfirmStop = True
        End If
        ThisWorkbook.Application.ScreenUpdating = lUpdateing
    End If
End Function

Private Sub cmdCancel_Click()
    If (Not IsRunning) Then
        Me.Hide
        Exit Sub
    End If
    If (ConfirmStop()) Then
        AddResult mLocale.GetLocalizationString("ValidationCanceledByUser")
        StopValidation
    End If
End Sub

Private Sub cmdOK_Click()
    If (mHasRun) Then
        Me.Hide
    Else
        StartValidation
    End If
End Sub

Private Function GetAllSheetsCollection() As Collection
    Set GetAllSheetsCollection = New Collection

    Dim sht, cnt As Integer
    For Each sht In ThisWorkbook.Worksheets
        If TypeOf sht Is Worksheet Then
            Dim wsht As Worksheet
            Set wsht = sht
            If (mUtils.IsProductsSheet(wsht)) Then
                GetAllSheetsCollection.Add wsht
            End If
        End If
    Next
End Function

Private Sub StartValidation()
    Dim i As Integer
    Dim mTimer As New STEPTimer
    Dim changes As Long
    mTimer.StartTimer "Counting"
    changes = 0
    If (chkEntireWorkbook.Value) Then
        Dim coll As Collection
        Set coll = GetAllSheetsCollection()
        ReDim mSheets(1 To coll.Count)
        For i = LBound(mSheets) To UBound(mSheets)
            Set mSheets(i) = coll.Item(i)
        Next
    End If

    If (chkOnlyChangedValidation) Then
        For i = LBound(mSheets) To UBound(mSheets)
           changes = changes + mChangeTracher.GetChangeCount(mSheets(i).Name)
        Next
        If (changes = 0) Then
            MsgBox mLocale.GetLocalizationString("ValidationNoProductsChanged"), Buttons:=vbOKOnly, Title:=mLocale.GetLocalizationString("ValidationTitle")
            Exit Sub
        ElseIf (changes > CONFIRM_THRESHOLD) Then
            If (MsgBox(mLocale.GetLocalizationString("ValidationAllConfirm") & changes, Buttons:=vbYesNo + vbQuestion + vbDefaultButton2, Title:=mLocale.GetLocalizationString("ValidationCancelProcessTitle")) = vbNo) Then
                Exit Sub
            End If
        End If
    Else
        If (GuestimateSize > CONFIRM_THRESHOLD) Then
            If (MsgBox(mLocale.GetLocalizationString("ValidationAllConfirmThreshold"), Buttons:=vbYesNo + vbQuestion + vbDefaultButton2, Title:=mLocale.GetLocalizationString("ValidationCancelProcessTitle")) = vbNo) Then
                Exit Sub
            End If
        End If
    End If
    mTimer.StopTimer
    STEPLoginForm.GetUser mStepUser
    If (Not mStepUser Is Nothing) Then
     mRunning = True
     mHasRun = True
     cmdOK.Enabled = False
     cmdCancel.Caption = mLocale.GetLocalizationString("ValidationStop")
     Dim sheetindex As Integer
     For sheetindex = LBound(mSheets) To UBound(mSheets)
         DoEvents
         If (IsRunning) Then
             mTimer.StartTimer "Validating sheet #" & sheetindex
             DoValidate mSheets(sheetindex)
             mTimer.StopTimer
         End If
     Next
     StopValidation
    End If
End Sub

Private Function GuestimateSize() As Long
    On Error GoTo GUESS_ERROR
    Dim lCount As Long
    Dim lCountCol As Long
    Dim i As Integer
    Dim l As Long
    GuestimateSize = -1
    If (mUtils.IsInitiateWorkbook) Then
        If (Not mUtils.HasExtendedSettingsSheet) Then
            'quicksheets in initiate mode cannot be guessed
            Exit Function
        Else
            lCountCol = 2
        End If
    Else
        lCountCol = 1
    End If
    For i = LBound(mSheets) To UBound(mSheets)
        l = mUtils.GetLastRow(mSheets(i), lCountCol) - mUtils.FirstProductRow(mSheets(i), False) + 1
        If (l > 0) Then
            lCount = lCount + l
        End If
    Next
    If (lCount > 0) Then
        GuestimateSize = lCount
    End If
    Exit Function
GUESS_ERROR:
    GuestimateSize = -1
    err.Clear
End Function

Private Sub StopValidation()
    If (IsRunning) Then
        mHasRun = True
        mRunning = False
        cmdOK.Caption = mLocale.GetLocalizationString("ValidationDone")
        cmdOK.Enabled = True
        SetInfo ""
        cmdCancel.Visible = False
        lbInfo.Visible = False
        chkEntireWorkbook.Enabled = False
        chkOnlyChangedValidation.Enabled = False
    End If
End Sub

Private Sub SetInfo(ByVal msg As String)
    lbInfo.Visible = True
    lbInfo.Caption = msg

End Sub

Private Property Get IsRunning() As Boolean
    IsRunning = mRunning
End Property

Private Sub UserForm_Initialize()
    Dim un As String, pw As String
    Me.Caption = mLocale.GetLocalizationString("ValidationTitle")
    chkOnlyChangedValidation.Caption = mLocale.GetLocalizationString("ValidationOnlyChange")
    chkEntireWorkbook.Caption = mLocale.GetLocalizationString("ValidationAllSheets")
    chkValidateHiddenRows.Caption = mLocale.GetLocalizationString("ValidationRemoveFilters")
    frameREsult.Caption = mLocale.GetLocalizationString("ValidationResult")
    cmdOK.Caption = mLocale.GetLocalizationString("ValidationOk")
    cmdCancel.Caption = mLocale.GetLocalizationString("ValidationCancel")
    'for some obscure reason this frame looses is fon-size from time to time
    chkEntireWorkbook.Font.size = mcFontSize
    chkOnlyChangedValidation.Font.size = mcFontSize
    chkValidateHiddenRows.Font.size = mcFontSize
    chkValidateHiddenRows.top = chkOnlyChangedValidation.top
    chkValidateHiddenRows.Height = chkOnlyChangedValidation.Height
    cmdCancel.Font.size = mcFontSize
    cmdOK.Font.size = mcFontSize
    frameREsult.Font.size = mcFontSize
    lbInfo.Font.size = mcFontSize
    Set txResult.Font = lbInfo.Font
    txResult.Font.size = mcFontSize
    Me.BackColor = cmdOK.BackColor
    frameREsult.BackColor = cmdOK.BackColor
End Sub

Private Sub UserForm_QueryClose(cancel As Integer, CloseMode As Integer)
    If (IsRunning) Then
        If Not ConfirmStop() Then
            cancel = 1
        Else
            StopValidation
        End If
    End If
End Sub


Private Sub DoValidate(ws As Worksheet)
    If (chkOnlyChangedValidation.Value) Then
        If (mChangeTracher.GetChangeCount(ws.Name) = 0) Then
            Exit Sub
        End If
    End If


    Dim sv As New STEPSheetValidator
    Dim s As String

    Dim lProtected As Boolean, lScreenUpdating As Boolean

    lProtected = ws.ProtectContents
    lScreenUpdating = ThisWorkbook.Application.ScreenUpdating
    On Error GoTo DO_VALIDATE_ERROR
    If (lProtected) Then
        'bugger microsoft - if sheet is protected it is NOT possible to add comments
        mUtils.UnProtectSheet ws
    End If

    Dim lastRowForAllSheet As Integer
    Dim lastRow As Integer
    lastRow = mUtils.GetLastRow(ws, 1)
    lastRowForAllSheet = mUtils.GetLastRowForAllSheet(ws, 1)
    If ((mUtils.IsInitiateWorkbook And lastRowForAllSheet > lastRow)) Then
        MsgBox ws.Name & mLocale.GetLocalizationString("STEPValidationExceedsLimit"), Buttons:=vbOKOnly, Title:=mLocale.GetLocalizationString("STEPValidationExceedsLimitTitle")
    End If


    Dim lSkipHidden As Boolean
    lSkipHidden = False
    If (mUtils.UseFilter = True) Then
        If (chkValidateHiddenRows.Value = True) Then
            mUtils.RemoveFilters ws
        Else
            mUtils.ValidationPerformed = True
            lSkipHidden = True
        End If
    End If

    ws.Activate
    sv.Init ws, mStepUser, lSkipHidden
    If (chkOnlyChangedValidation.Value) Then
        sv.ForceFullValidation = False
    Else
        sv.ForceFullValidation = True
    End If
    If (sv.HasError) Then
        StopValidation
        AddResult sv.ErrorDescription
        Exit Sub
    End If
    'sv.ForceFullValidation = True

    ThisWorkbook.Application.ScreenUpdating = False 'stop blinking and speed up
    Do While Not sv.done
        SetInfo ws.Name & ": " & sv.CurrentRow & " +"
        DoEvents
        If (Not IsRunning) Then
            Exit Sub
        End If
        sv.ValidateNextBunch
        If (sv.HasError) Then
            StopValidation
            AddResult sv.ErrorDescription
            Exit Sub
        End If
    Loop
    ThisWorkbook.Application.ScreenUpdating = True
    If (sv.HasDuplicates) Then
        MsgBox (mLocale.GetLocalizationString("ValidationHasDuplicates")), vbOKOnly, Me.Caption
    End If
    Dim sms As Boolean
    sms = mUtils.HasExtendedSettingsSheet
    AddResult ws.Name & ": "
    AddResult sv.Counts.ToString(sms, 4)
    Dim Lines() As String
    Lines = VBA.Split(txResult.Text, VBA.vbCrLf)
    If (UBound(Lines)) > 9 Then
        txResult.SetFocus
        txResult.ScrollBars = MSForms.fmScrollBarsVertical
    Else
        txResult.ScrollBars = MSForms.fmScrollBarsNone
    End If
    #If Mac Then
        txResult.SetFocus
        txResult.ScrollBars = MSForms.fmScrollBarsVertical
    #End If
    ThisWorkbook.formatComments ws
DO_VALIDATE_ERROR:
    If (lScreenUpdating <> ThisWorkbook.Application.ScreenUpdating) Then
        ThisWorkbook.Application.ScreenUpdating = lScreenUpdating
    End If
    If (lProtected) Then
        mUtils.ProtectSheet ws
    End If

End Sub



Private Sub AddResult(ByVal str As String)
    lbInfo.Visible = False
    Me.txResult.Locked = False
    txResult.Text = txResult & str & vbNewLine
    txResult.Enabled = True
    txResult.Visible = True
End Sub
Attribute VB_Name = "STEPValidatedProduct"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Private mProductID As String
Private mErrors As New Collection
Private mModifiedObjects As New Collection
Private mCellStatuses As New Collection

Public Property Let productid(ByVal Value As String)
    mProductID = Value
End Property

Public Property Get productid() As String
    productid = mProductID
End Property

Public Sub AddModifiedValue(ByVal attributeID As String, ByVal modifValue As String, ByVal pCellAddr As String)
    Dim i As Integer, mo As STEPModifiedObject
    For i = 1 To mModifiedObjects.Count
        Set mo = mModifiedObjects.Item(i)
        If (pCellAddr <> "") Then
            If (pCellAddr = mo.CellAddress) Then
                Exit Sub
            ElseIf (mo.CellAddress <> "") Then
                Exit For
            End If
            
        End If
        If (mo.ObjectType = STEPModifiedValue And mo.id = attributeID) Then
            'bugger - this must meen that we have the column twice
            Exit Sub
        End If
    Next
    Set mo = New STEPModifiedObject
    mo.id = attributeID
    mo.ObjectType = STEPModifiedValue
    mo.ModifiedValue = modifValue
    mo.CellAddress = pCellAddr
    mModifiedObjects.Add mo
End Sub

Public Sub AddModifiedMultiValue(ByVal attributeID As String, ByRef modifiedvalues() As String)
    Dim i As Integer, mo As STEPModifiedObject
    For i = 1 To mModifiedObjects.Count
        Set mo = mModifiedObjects.Item(i)
        If (mo.ObjectType = STEPModifiedMultiValue And mo.id = attributeID) Then
            'bugger - this must meen that we have the column twice
            Exit Sub
        End If
    Next
    Set mo = New STEPModifiedObject
    mo.id = attributeID
    mo.ObjectType = STEPModifiedMultiValue
    mo.ModifiedValue = modifiedvalues
    mModifiedObjects.Add mo
End Sub


Private Sub AddError(ByVal pid As String, ByVal pType As ErrorObjectType, ByVal err As String, ByVal pCellAddress As String)
    Dim Index As Integer, e As STEPValidationError
    For Index = 1 To mErrors.Count
        'for multivalues (values,references and batches) concat errors
        Set e = mErrors.Item(Index)
        If ((pCellAddress <> "")) Then
            If (pCellAddress = e.CellAddress) Then
                e.ValidationError = e.ValidationError & vbNewLine & err
                Exit Sub
            ElseIf (e.CellAddress <> "") Then
                Exit For
            End If
        End If
        If (e.ObjectType = pType) Then
            If (e.id = pid) Then
                e.ValidationError = e.ValidationError & vbNewLine & err
                Exit Sub
            End If
        End If
    Next
    
    Set e = New STEPValidationError
    e.ObjectType = pType
    e.id = pid
    e.ValidationError = err
    e.CellAddress = pCellAddress
    mErrors.Add e
End Sub

Public Sub AddProductError(ByVal err As String)
    AddError Me.productid, STEPProductError, err, ""
End Sub
Public Sub AddAttributeError(ByVal attributeID As String, ByVal err As String, ByVal pCellAddress As String)
    AddError attributeID, STEPAttributeError, err, pCellAddress
End Sub
Public Sub AddReferenceError(ByVal referenceID As String, ByVal err As String, ByVal pCellAddress As String)
    AddError referenceID, STEPReferenceError, err, pCellAddress
End Sub
Public Sub AddLinkError(ByVal linkID As String, ByVal err As String, ByVal pCellAddress As String)
    AddError linkID, STEPLinkError, err, pCellAddress
End Sub

Public Sub AddBatchError(ByVal err As String, ByVal pCellAddress As String)
    AddError Me.productid, STEPBatchError, err, pCellAddress
End Sub


Public Sub AddNameError(ByVal err As String, ByVal pCellAddress As String)
    AddError Me.productid, STEPNameError, err, pCellAddress
End Sub
Public Property Get ValidationErrors() As Collection
    Set ValidationErrors = mErrors
End Property

Public Property Get ValidationErrorCount() As Long
    ValidationErrorCount = mErrors.Count
End Property

Public Property Get ModificationsCount() As Long
    ModificationsCount = mModifiedObjects.Count
End Property

Public Property Get Modifications() As Collection
    Set Modifications = mModifiedObjects
End Property

Public Sub AddCellStatus(ByVal pCellStatus As STEPCellStatus)
    mCellStatuses.Add pCellStatus
End Sub

Public Property Get CellStatuses() As Collection
    Set CellStatuses = mCellStatuses
End Property

Public Property Get CellStatusesCount() As Long
    CellStatusesCount = mCellStatuses.Count
End Property

Private Sub Class_Terminate()
    Set mModifiedObjects = Nothing
    Set mErrors = Nothing
End Sub
Attribute VB_Name = "STEPValidationCounts"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Const C_PRODUCTS = 1
Private Const C_VALIDATEDPRODUCTS = 2
Private Const C_FAILEDVALIDATIONPRODUCTS = 3
Private Const C_MISSING_MANDATORY_PRODUCTS = 4
Private Const C_MISSING_MANDATORY_VALUES = 5
Private Const C_VALUE_ERRORS = 6
Private Const C_REFERENCE_ERRORS = 7
Private Const C_NAME_ERROR = 8
Private Const C_PRODUCT_ERROR = 9
Private Const C_LINK_ERRORS = 10
Private Const C_SHEET_ERROR_ROWS = 11

Private mCounts(C_PRODUCTS To C_SHEET_ERROR_ROWS) As Long
Private mLocale As New STEPLocalization

Public Function ToString(ByVal isSmartsheet As Boolean, Optional ByVal indent As Integer = 0) As String
    Dim pre As String, i As Integer, pre2 As String
    For i = 1 To indent
        pre = pre & " "
    Next
    pre2 = pre & pre

    Dim s As String
    If (ErrorSum = 0) Then
        If (Products = 0) Then
            s = pre & mLocale.GetLocalizationString("STEPSheetValidationCountsNothing")
        ElseIf (Products = 1) Then
            s = pre & mLocale.GetLocalizationString("STEPSheetValidationCountsOk")
        Else
            s = pre & mLocale.GetLocalizationString("STEPSheetValidationCountsAllOk") & VBA.Format(Products, "#,##0") & mLocale.GetLocalizationString("STEPSheetValidationCountsAllOk2")
        End If
        If RowWithErrorCount > 0 Then
            s = s & vbNewLine
            s = s & MakeLine(pre, mLocale.GetLocalizationString("STEPSheetValidationCountsErrors"), RowWithErrorCount)
        End If
    Else

        s = MakeLine(pre, mLocale.GetLocalizationString("STEPSheetValidationCountsExamined"), Products)
        s = s & MakeLine(pre, mLocale.GetLocalizationString("STEPSheetValidationCountsTotalErrors"), ProductErrors + MissingMandatoryValues + RefrenceErrors + LinkErrors + ValueErrors + NameErrors)
        If isSmartsheet Then
            s = s & MakeLine(pre2, mLocale.GetLocalizationString("STEPSheetValidationCountsRejected"), ProductErrors)
        Else
            s = s & MakeLine(pre2, mLocale.GetLocalizationString("STEPSheetValidationCountsInvalidIDs"), ProductErrors)
        End If
        s = s & MakeLine(pre2, mLocale.GetLocalizationString("STEPSheetValidationCountsInvalidValues"), ValueErrors + NameErrors)
        s = s & MakeLine(pre2, mLocale.GetLocalizationString("STEPSheetValidationCountsMissingRequired"), MissingMandatoryValues)
        s = s & MakeLine(pre2, mLocale.GetLocalizationString("STEPSheetValidationCountsInvalidReferences"), RefrenceErrors)
        s = s & MakeLine(pre2, mLocale.GetLocalizationString("STEPSheetValidationCountsInvalidLinks"), LinkErrors)
        s = s & MakeLine(pre, mLocale.GetLocalizationString("STEPSheetValidationCountsProductsWithError"), RowWithErrorCount)
    End If
    ToString = s & vbNewLine
End Function

Private Function MakeLine(ByVal prefix As String, ByVal txt As String, ByVal cnt As Long) As String
    If (cnt <= 0) Then
        MakeLine = ""
    Else
        MakeLine = prefix & txt & ": " & VBA.Format(cnt, "#,##0") & vbNewLine
    End If
End Function

Public Sub Clear()
    Dim i As Integer
    For i = LBound(mCounts) To UBound(mCounts)
        mCounts(i) = 0
    Next
End Sub

Private Sub Increment(ByVal Index, Optional ByVal Count As Long = 1)
    mCounts(Index) = mCounts(Index) + Count
End Sub

Public Sub AddProducts(Optional ByVal Count As Long = 1)
    Increment C_PRODUCTS, Count
End Sub
Public Sub AddValidateProducts(Optional ByVal Count As Long = 1)
    Increment C_VALIDATEDPRODUCTS, Count
End Sub
Public Sub AddValidationFailedProducts(Optional ByVal Count As Long = 1)
    Increment C_FAILEDVALIDATIONPRODUCTS, Count
End Sub
Public Sub AddMissingMandatoryProducts(Optional ByVal Count As Long = 1)
    Increment C_MISSING_MANDATORY_PRODUCTS, Count
End Sub
Public Sub AddMissingMandatoryValues(Optional ByVal Count As Long = 1)
    Increment C_MISSING_MANDATORY_VALUES, Count
End Sub
Public Sub AddValueErrors(Optional ByVal Count As Long = 1)
    Increment C_VALUE_ERRORS, Count
End Sub
Public Sub AddReferenceErrors(Optional ByVal Count As Long = 1)
    Increment C_REFERENCE_ERRORS, Count
End Sub
Public Sub AddLinkErrors(Optional ByVal Count As Long = 1)
    Increment C_LINK_ERRORS, Count
End Sub
Public Sub AddNameErrors(Optional ByVal Count As Long = 1)
    Increment C_NAME_ERROR, Count
End Sub
Public Sub AddProductError(Optional ByVal Count As Long = 1)
    Increment C_PRODUCT_ERROR, Count
End Sub

Public Property Get Products() As Long
    Products = mCounts(C_PRODUCTS)
End Property

Public Property Get ValidateProducts() As Long
    ValidateProducts = mCounts(C_VALIDATEDPRODUCTS)
End Property

Public Property Get FailedValidationProducts() As Long
    FailedValidationProducts = mCounts(C_FAILEDVALIDATIONPRODUCTS)
End Property

Public Property Get MissingMandatoryProducts() As Long
    MissingMandatoryProducts = mCounts(C_MISSING_MANDATORY_PRODUCTS)
End Property

Public Property Get MissingMandatoryValues() As Long
    MissingMandatoryValues = mCounts(C_MISSING_MANDATORY_VALUES)
End Property

Public Property Get ValueErrors() As Long
    ValueErrors = mCounts(C_VALUE_ERRORS)
End Property

Public Property Get RefrenceErrors() As Long
    RefrenceErrors = mCounts(C_REFERENCE_ERRORS)
End Property

Public Property Get LinkErrors() As Long
    LinkErrors = mCounts(C_LINK_ERRORS)
End Property

Public Property Get NameErrors() As Long
    NameErrors = mCounts(C_NAME_ERROR)
End Property

Public Property Get ProductErrors() As Long
    ProductErrors = mCounts(C_PRODUCT_ERROR)
End Property

Public Property Get ErrorSum() As Long
    ErrorSum = MissingMandatoryValues + RefrenceErrors + NameErrors + ValueErrors + ProductErrors + LinkErrors
End Property

Public Sub AddRowWithErrorCount(ByVal cnt As Long)
    Increment C_SHEET_ERROR_ROWS, cnt
End Sub

Public Property Get RowWithErrorCount() As Long
    RowWithErrorCount = mCounts(C_SHEET_ERROR_ROWS)
End Property

Attribute VB_Name = "STEPValidationError"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public Enum ErrorObjectType
    STEPProductError = 1
    STEPAttributeError = 2
    STEPReferenceError = 3
    STEPNameError = 4
    STEPBatchError = 5
    STEPLinkError = 6
End Enum

Private mID As String
Private mObjectType As ErrorObjectType
Private mValidationError As String
Private mCellAddress As String

Public Property Let id(ByVal Value As String)
    mID = Value
End Property

Public Property Get id() As String
    id = mID
End Property

Public Property Let ObjectType(ByVal pType As ErrorObjectType)
    mObjectType = pType
End Property

Public Property Get ObjectType() As ErrorObjectType
    ObjectType = mObjectType
End Property

Public Property Get ValidationError() As String
    ValidationError = mValidationError
End Property

Public Property Let ValidationError(ByVal pError As String)
    mValidationError = pError
End Property

Public Property Let CellAddress(ByVal pCellAddress As String)
    mCellAddress = pCellAddress
End Property

Public Property Get CellAddress() As String
    CellAddress = mCellAddress
End Property

Private Sub Class_Initialize()
    mValidationError = ""
End Sub
Attribute VB_Name = "STEPXmlAttribute"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'Class created by ASEME v/Anders Villy Ehrenreich Erikse
' avee42@gmail.com
'www.aseme.dk
Private mName As String
Private mValue As String

Public Property Let Value(s As String)
    mValue = s
End Property

Public Property Get Value() As String
    Value = mValue
End Property

Public Property Let Name(s As String)
    mName = s
End Property

Public Property Get Name() As String
    Name = mName
End Property

Public Function Xml() As String
    'escape characters not handled yet
    Xml = mName & "='" & ThisWorkbook.escapeXmlValue(mValue) & "'"
End Function

Attribute VB_Name = "STEPXmlDom"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'Class created by ASEME v/Anders Villy Ehrenreich Erikse
' avee42@gmail.com
'www.aseme.dk
'Class mimics an xml dom
'Can parse and print xml by building a tag structure of xml nodes
'Document element is the root node
'But there can be processing instructions and comment nodes at the same xml level as the root node


Private mAsync As Boolean
Private mDocumentElement As STEPXmlNode
Private mNodes As Collection
Private mParseError As STEPXmlParseError
Private mLocale As New STEPLocalization


'Parser states used in the parsing function
Private Enum xmlParserStates
    beforeTagStart = 1
    beginNodeType = 2
    tagProcessingInstruction = 3
    tagcommentary = 4
    tagName = 5
    endNodeType = 6
    nodeContent = 7
    tagAttributes = 8
    nodedone = 9
End Enum

Private Property Get Nodes() As Collection
    If mNodes Is Nothing Then
        Set mNodes = New Collection
    End If
    Set Nodes = mNodes
End Property

Public Function createProcessingInstruction(mltype As String, encoding As String) As STEPXmlNode
Dim pi As STEPXmlNode

Set pi = New STEPXmlNode
pi.NodeType = PROCESSINGINSTRUCTION
Call pi.addAttributes(encoding, 1, Len(encoding))
pi.NodeName = mltype
Set createProcessingInstruction = pi
End Function

Public Property Get async() As Boolean
async = mAsync
End Property

Public Property Let async(ByVal asyn As Boolean)
mAsync = asyn
End Property

Public Property Get DocumentElement() As STEPXmlNode
    If (mDocumentElement Is Nothing) Then
        Set mDocumentElement = New STEPXmlNode
        Call Nodes.Add(mDocumentElement)
    End If
    Set DocumentElement = mDocumentElement
End Property

Public Property Let DocumentElement(nd As STEPXmlNode)
    While (0 < Nodes.Count)
        Nodes.Remove (1)
    Wend
    Set mDocumentElement = nd
    Call Nodes.Add(nd)
End Property
'Can parse an xml string
'If the string is not xml, it will just be viewed as one big text node
'Parser is generally forgiving
Public Sub Parse(ByVal xmlstr As String)
    Dim nd As STEPXmlNode
    Dim i As Long
    Dim documentElementFound As Boolean
    documentElementFound = False
    i = 1
    While (i <= Len(xmlstr))
        Set nd = New STEPXmlNode
        i = ParseXml(xmlstr, i, Len(xmlstr), nd) 'Parse one node and return the position for further parsing
        If (nd.NodeType <> UNKNOWN Or i <> 0) Then
            Call Nodes.Add(nd)
        Else
            Call m_parseError.SetErr(1010, "Unable to parse xml node", "Dom")
            err.Raise 1010, , mLocale.GetLocalizationString("STEPXMLDomUnableToParse")
            Exit Sub
        End If
        If (nd.NodeType = START_END Or nd.NodeType = UNARY) Then
            If Not documentElementFound Then
                DocumentElement = nd
            Else
                Call m_parseError.SetErr(1001, "More than one xml root in document", "Dom")
                err.Raise 1001, , mLocale.GetLocalizationString("STEPXMLDomMoreThanOne")
            End If
            documentElementFound = True
        End If
    Wend
End Sub

Public Sub clearNodes()
    Set mNodes = New Collection
End Sub

Private Sub ClearDocumentElement()
    DocumentElement.NodeName = ""
    DocumentElement.NodeType = UNKNOWN
    DocumentElement.NodeText = ""
    DocumentElement.clearChildren
    DocumentElement.clearAttributes
End Sub

'Function loads xml into the top-level node the documentelement, overwriting any content it might have
Public Sub LoadXML(ByVal xmlstr As String)
    Dim i As Integer
    Call ClearDocumentElement
    i = ParseXml(xmlstr, 1, Len(xmlstr), DocumentElement)
    If DocumentElement.NodeType = UNKNOWN Or i = 0 Then
        Call m_parseError.SetErr(1002, "Unable to parse xml node", "Dom")
        err.Raise 1002, , mLocale.GetLocalizationString("STEPXMLDomUnableToParse")
    End If
End Sub

'This function will parse exactly one node in an xml string and return the position in the string, where the parser got to...

Private Function ParseXml(ByVal xmlstr As String, ByVal start As Long, ByVal strlen As Long, nd As STEPXmlNode) As Long
'assume well formed xml
    Dim parserState As xmlParserStates
    Dim i As Long

    i = start

    On Error GoTo DOM_PARSE_ERROR
    'strip spaces
    While (VBA.mID(xmlstr, i, 1) = " " Or VBA.mID(xmlstr, i, 1) = VBA.Chr(13) Or VBA.mID(xmlstr, i, 1) = VBA.Chr(10) Or VBA.mID(xmlstr, i, 1) = VBA.Chr(9))
        i = i + 1
    Wend

    nd.NodeType = UNKNOWN
    parserState = beforeTagStart
    While (i <= strlen)
        Select Case parserState
            Case beforeTagStart 'Before tag start, either a node of some kind or a text node (just a string)
                If (VBA.mID(xmlstr, i, 1) = "<") Then 'We hit a tag start, assume it is a node
                    parserState = beginNodeType
                    i = i + 1
                Else
                    nd.NodeType = TEXTNODE 'Its a text node, parse it up and exit the function hope that there is a tag after the text node
                    ParseXml = nd.addNodeText(xmlstr, i, strlen, "<", 1)
                    Exit Function
                End If
            Case beginNodeType 'We hit a tag start so no try to figure out what kind of node it is
                If (VBA.mID(xmlstr, i, 1) = "?") Then 'Processing instruction
                    i = i + 1
                    parserState = tagProcessingInstruction
                ElseIf (VBA.mID(xmlstr, i, 4) = "!-- ") Then 'Comment
                    i = i + 4
                    parserState = tagcommentary
                ElseIf (VBA.mID(xmlstr, i, 1) = "/") Then 'Error
                    err.Raise 1003, , mLocale.GetLocalizationString("STEPXMLEndWithoutBegin")
                    Exit Function
                Else
                    parserState = tagName 'Else parse for a tag name
                End If
            Case tagProcessingInstruction
                nd.NodeType = PROCESSINGINSTRUCTION
                parserState = tagName
            Case tagcommentary
                nd.NodeType = COMMENTARY 'If it is a comment, we are done
                ParseXml = nd.addNodeText(xmlstr, i, Len(xmlstr), " -->", 4) + 4
                Exit Function
            Case tagName
                i = nd.addName(xmlstr, i, strlen) 'Add the tag name and see how the tag ends
                parserState = endNodeType
            Case endNodeType
                If (VBA.mID(xmlstr, i, 1) = " ") Then 'strip spaces
                    i = i + 1
                ElseIf (VBA.mID(xmlstr, i, 1) = ">") Then 'Normal start node there could be content and there should then be an end node
                    nd.NodeType = START_END
                    i = i + 1
                    parserState = nodeContent
                ElseIf (VBA.mID(xmlstr, i, 2) = "/>") Then 'Unary node, do not parse content
                    nd.NodeType = UNARY
                    ParseXml = i + 2
                    Exit Function
                ElseIf (VBA.mID(xmlstr, i, 2) = "?>") Then 'Endof processing instruction and we are done
                    If nd.NodeType <> PROCESSINGINSTRUCTION Then
                        err.Raise 1007, , mLocale.GetLocalizationString("STEPXMLIllegalTag")
                    End If
                    ParseXml = i + 2
                    Exit Function
                Else
                    parserState = tagAttributes 'Encountered not space character and none tag end character, go for attributes
                End If
            Case nodeContent
                'Full start_end tag found so not we go for content->subnodes
                Dim endtaglen As Integer
                Dim endtagtext As String
                Dim foundinstr As Long

                endtagtext = "</" & nd.NodeName & ">"
                endtaglen = Len(endtagtext)
                foundinstr = InStr(i, xmlstr, endtagtext, vbTextCompare)
                If (foundinstr = 0) Then
                    err.Raise 1008, , mLocale.GetLocalizationString("STEPXMLTagEnd")
                    ParseXml = 0
                    Exit Function
                End If
                While (i < foundinstr) 'Parse untill we find the end tag .. also works for <a><a></a></a>
                    Dim newnode As STEPXmlNode
                    Set newnode = New STEPXmlNode

                    i = ParseXml(xmlstr, i, foundinstr, newnode)
                    If (newnode.NodeType = UNKNOWN) Then
                        If (i = 0) Then
                            err.Raise 1009, mLocale.GetLocalizationString("STEPXMLSubnodeParse")
                            ParseXml = 0
                            Exit Function
                        End If
                    Else
                        Call nd.ChildNodes.Add(newnode)
                    End If
                Wend
                i = i + endtaglen
                parserState = nodedone
            Case tagAttributes
                i = nd.addAttributes(xmlstr, i, InStr(i, xmlstr, ">", vbTextCompare))
                parserState = endNodeType
            Case nodedone
                ParseXml = i
                Exit Function
            Case Else
                err.Raise 1004, , mLocale.GetLocalizationString("STEPXMLParserStateUnknown")
        End Select
    Wend
    ParseXml = i 'return the position in the xml string where we got to
    Exit Function
DOM_PARSE_ERROR:
    Call m_parseError.SetErr(err.Number, err.Description, err.Source)
    err.Raise err.Number, err.Description, err.Source
End Function

'insert a node before another named node
Public Sub InsertBefore(pi As STEPXmlNode, elm As STEPXmlNode)
Dim i As Integer

For i = 1 To Nodes.Count
    If elm.NodeName = Nodes.Item(i).NodeName Then
        Call Nodes.Add(pi, , i)
    End If
Next i
End Sub
'Create an element and return it, not linked into the dom tree
Public Function createElement(txt As String) As STEPXmlNode
    Dim nd As New STEPXmlNode
    nd.NodeName = txt
    nd.NodeType = START_END
    Set createElement = nd
End Function
'Create a text node and return it, not linked into the dom
Public Function createTextNode(txt As String) As STEPXmlNode
    Dim tnd As New STEPXmlNode
    tnd.NodeType = TEXTNODE
    tnd.NodeText = txt
    Set createTextNode = tnd
End Function
'return the xml representation of the dom tree
Public Property Get Xml() As String
    Dim lTimer As New STEPTimer
    lTimer.StartTimer "    Building XML from DOM"
    Dim i As Integer
    Dim str As String
    str = ""
    For i = 1 To Nodes.Count
        If (i = 1) Then
            str = str & Nodes(i).Xml()
        Else
            str = str & vbNewLine & Nodes(i).Xml()
        End If
        
    Next i
    Xml = str
    lTimer.StopTimer "( xml length:" & Len(str) & ")"
End Property

Private Property Get m_parseError() As STEPXmlParseError
    If mParseError Is Nothing Then
        Set mParseError = New STEPXmlParseError
    End If
    Set m_parseError = mParseError
End Property

'Create a parse error
Public Function ParseError() As STEPXmlParseError
    Set ParseError = m_parseError
End Function

'Find all nodes by a certain name in the dom, add them to a list and return them
Private Sub getNodeByName(nm As String, nd As STEPXmlNode, res As STEPXmlNodeList)
    Dim cnd As STEPXmlNode
    Dim rs As STEPXmlNode
    
    If (nd.NodeName = nm And (nd.NodeType = START_END Or nd.NodeType = UNARY)) Then
        Call res.Add(nd)
    End If
    
    For Each cnd In nd.ChildNodes
        Call getNodeByName(nm, cnd, res)
    Next cnd
    
End Sub
'Create a node list and search for all tags with that name
Public Function getElementsByTagName(NodeName As String) As STEPXmlNodeList
    Dim nd As STEPXmlNode
    Dim rnd As STEPXmlNode
    Dim res As STEPXmlNodeList
    
    Set res = New STEPXmlNodeList
    
    For Each nd In Nodes
       Call getNodeByName(NodeName, nd, res)
    Next nd
    Set getElementsByTagName = res
End Function

Attribute VB_Name = "STEPXmlHttp"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Private mlasterror As String
Private mLastStatusCode As String
Private mStepURL As String
Private mUserName As String
Private mPassword As String
Private mToken As String
Private mTimeOut As Integer
Private mResponseXLM As STEPXmlDom
Private mResponseText As String
Private mLocale As New STEPLocalization


'SEE:http://p2p.wrox.com/112342-post4.html

'Oh the joys of character encodings :D
'Some basic facts which may help are:
'- using DOM.xml always results in a UTF-16 encoding regardless of any encoding set in your PI
'- using DOM.save respects the encoding set in your PI
'- internally VB/ASP strings are COM BSTR, which are UTF-16 I believe
'- XMLHTTP sends using UTF-8 by default

'A. in the VB:
'1. use a DOM document to construct the xml rather than building it using a string, and add a PI to the DOM which specifies the encoding you want to use.
'2. when sending via XMLHTTP pass in the DOM doc to the send method (don't pass in the DOM.xml because this doesn't necessarily preserve encoding)
'3. when receiving the XML back from the XMLHTTP send, use the responseXML property which will give you a DOM object directly


Public Function Init(ByVal stepurl As String, Optional ByVal username As String = "", Optional ByVal password As String = "", Optional ByVal timeout As Integer = -1, Optional ByVal token As String = "") As Boolean
    mlasterror = ""
    Dim o As STEPHttpServerCommunication
    'test get XmlHttp
    Set o = GetXmlHttp()
    If (o Is Nothing) Then
        Init = False
    Else
        Set o = Nothing
        mStepURL = stepurl
        mUserName = username
        mPassword = password
        mTimeOut = timeout
        mToken = token
        Init = True
    End If

End Function

Public Function GetXmlHttp() As STEPHttpServerCommunication
    Dim xmlhttp As STEPHttpServerCommunication

    Set xmlhttp = New STEPHttpServerCommunication

    If (xmlhttp.testCommunication()) Then
        Set GetXmlHttp = New STEPHttpServerCommunication
    Else
        Set GetXmlHttp = Nothing
    End If
End Function

'Private Function GetXmlHttp() As Object
'    Dim obj As Object
'    On Error Resume Next
'    Set obj = CreateObject("MSXML2.XMLHTTP")
'    If err.Number <> 0 Then
'        err.Clear
'        Set obj = CreateObject("MSXML.XMLHTTPRequest")
'    End If
'    If err.Number <> 0 Then
'        mLastError = err.Description
'        Set obj = Nothing
'    End If
'    Set GetXmlHttp = obj
'    On Error GoTo 0
'End Function

Private Function OpenHttpPost(oHttp As STEPHttpServerCommunication) As Boolean
    On Error GoTo OPEN_ERR
    If (Len(mUserName) > 0 And Len(mPassword) > 0) Then
        oHttp.Open1 "POST", mStepURL, False, mUserName, mPassword
    ElseIf (Len(mUserName) > 0 And Len(mToken) > 0) Then
        oHttp.Open1 "POST", mStepURL, False, mUserName, , mToken
    Else
        oHttp.Open1 "POST", mStepURL, False
    End If
    OpenHttpPost = True
    If (mTimeOut > 0) Then
        oHttp.timeout = mTimeOut
    End If
    On Error GoTo 0
    Exit Function
OPEN_ERR:
    mlasterror = err.Description
    OpenHttpPost = False
    On Error GoTo 0
End Function

Public Function PostText(ByVal xmlText As String) As Boolean
    Set mResponseXLM = Nothing
    mResponseText = ""
    Dim oHttp As STEPHttpServerCommunication
    Set oHttp = GetXmlHttp()
    If (Not OpenHttpPost(oHttp)) Then
        PostText = False
        Set oHttp = Nothing
        Exit Function
    End If
    On Error GoTo POST_ERR
    oHttp.setRequestHeader "Content-Type", "text/xml; charset:UTF-8;"
    oHttp.send (xmlText)
    Set mResponseXLM = oHttp.ResponseXML
    mResponseText = oHttp.ResponseText
    If (oHttp.Status <> 200) Then
        err.Raise vbObjectError + 1002, "Server", mLocale.GetLocalizationString("STEPXMLHttpStatus") & oHttp.statusText & " (" & oHttp.Status & ")"
    End If
    Set oHttp = Nothing
    On Error GoTo 0
    PostText = True
    Exit Function
POST_ERR:
    On Error Resume Next
    Dim log As New STEPLogger
    log.Severe "STEPXmlHttp.PostText", "XmlHttp.staus:" & oHttp.Status & " - " & oHttp.statusText & " [" & xmlText & "]"
    mlasterror = mLocale.GetLocalizationString("STEPXMLHttpErrorValidation") & vbNewLine & " (" & oHttp.Status & " - " & oHttp.statusText & ")"
    mLastStatusCode = oHttp.Status
    Set log = Nothing
    Set oHttp = Nothing
    Set mResponseXLM = Nothing
    mResponseText = ""
    PostText = False
    On Error GoTo 0
End Function
Public Function PostXML(dom As STEPXmlDom) As Boolean
    Dim lTimer As New STEPTimer
    Set mResponseXLM = Nothing
    mResponseText = ""
    Dim oHttp As STEPHttpServerCommunication
    lTimer.StartTimer "  Getting Xml HTTP"
    Set oHttp = GetXmlHttp()
    lTimer.StopTimer
    lTimer.StartTimer "  Open Post"
    If (Not OpenHttpPost(oHttp)) Then
        PostXML = False
        Set oHttp = Nothing
        Exit Function
    End If
    lTimer.StopTimer
    On Error GoTo POST_ERR
    lTimer.StartTimer "  Posting XML"
    Call oHttp.senddom(dom)
    lTimer.StopTimer
    lTimer.StartTimer "  Getting response"
    Set mResponseXLM = oHttp.ResponseXML
    mResponseText = oHttp.ResponseText
    lTimer.StopTimer
    If (oHttp.Status <> 200) Then
        err.Raise vbObjectError + 1002, "Server", mLocale.GetLocalizationString("STEPXMLHttpStatus") & oHttp.statusText & " (" & oHttp.Status & ")"
    End If
    Set oHttp = Nothing
    On Error GoTo 0
    PostXML = True
    Exit Function
POST_ERR:
    Dim eNumber
    eNumber = err.Number
    Dim eDescription
    eDescription = err.Description
    On Error Resume Next
    Dim log As New STEPLogger
    Dim statusCodes As New STEPHttpStatusCodes
    Dim statusText As String
    Dim fullStatusText As String
    mLastStatusCode = oHttp.Status
    If (mLastStatusCode <> 200) Then
        statusText = statusCodes.GetStatusText(oHttp.Status)
        fullStatusText = statusCodes.GetFullStatusText(oHttp.Status)
        log.Severe "STEPXmlHttp.PostXML", "XmlHttp.staus:" & oHttp.Status & " - " & fullStatusText & " [" & dom.Xml & "]"
        mlasterror = mLocale.GetLocalizationString("STEPXMLHttpErrorRequest") & vbNewLine & " (" & oHttp.Status & " - " & statusText & ")"
    Else
        log.Severe "STEPXmlHttp.PostXML", "Unexpected error: " & eNumber & ":" & eDescription
        mlasterror = mLocale.GetLocalizationString("STEPXMLHttpUnexpected") & vbNewLine & " (" & eNumber & " - " & eDescription & ")"
    End If
    Set log = Nothing
    Set oHttp = Nothing
    Set mResponseXLM = Nothing
    mResponseText = ""
    PostXML = False
    On Error GoTo 0
End Function


Public Property Get ResponseXML() As Object
    Set ResponseXML = mResponseXLM
End Property

Public Property Get ResponseText() As String
    ResponseText = mResponseText
End Property

Public Property Get ErrorDescription() As String
    ErrorDescription = mlasterror
End Property

Public Property Get statusCode() As String
    statusCode = mLastStatusCode
End Property

Attribute VB_Name = "STEPXmlNode"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'Class created by ASEME v/Anders Villy Ehrenreich Erikse
' avee42@gmail.com
'www.aseme.dk
'Class mimics XML node classes used by the MS Dom
'class can print nodes to XML and carry out certain parsing of node name, attributes and node text
Option Explicit
Private mNodeType As STEPXmlNodeType
Private mNodeName As String
Private mAttributes As Collection
Private mChildren As Collection
Private mNodeText As String
Private mLocale As New STEPLocalization
'Node types can be
'<? ...=...?> Processinginstruction
'<tag></tag> Start-end tag
'<tag/> unary tag
'<!-- aaa --> Commentary
'ipsom dolor eris .. Text node
Public Enum STEPXmlNodeType
    PROCESSINGINSTRUCTION = 1
    START_END = 2
    UNARY = 3
    COMMENTARY = 4
    TEXTNODE = 5
    UNKNOWN = 6
End Enum

'Property used for text nodes and processing instructions
Public Property Let NodeText(nt As String)
    mNodeText = nt
End Property

Public Property Get NodeText() As String
    NodeText = mNodeText
End Property
'Parsing node text from xml string
'End of text represents at what characters the function should expect the text (node) to end .. could be at <
Public Function addNodeText(s As String, start As Long, strlen As Long, endoftext As String, lenofend As Integer) As Long
Dim i As Long
Dim lenEnd As Long
Dim startOf As Long
'escape characters not yet handled xxx
   i = start
   lenEnd = lenofend
    'strip leading spaces
    While (i <= strlen And VBA.mID(s, i, 1) = " ")
        i = i + 1
    Wend

    startOf = i

    If (InStr(1, s, endoftext, vbTextCompare) = 0) Then
        lenEnd = 0
    End If

    While (i <= strlen - lenEnd And VBA.mID(s, i, lenEnd) <> endoftext)
        i = i + 1
    Wend

    NodeText = VBA.mID(s, startOf, i - startOf)
    addNodeText = i
End Function
'Parses the name of a tag from an XML string
Public Function addName(s As String, start As Long, strlen As Long) As Long
    Dim i As Long
    Dim startOf As Long

    i = start
    'strip leading spaces
    While (i <= strlen And VBA.mID(s, i, 1) = " ")
        i = i + 1
    Wend

    startOf = i

    While (i <= strlen And VBA.mID(s, i, 1) <> " " And VBA.mID(s, i, 1) <> ">" And VBA.mID(s, i, 1) <> "/")
        i = i + 1
    Wend

    NodeName = VBA.mID(s, startOf, i - startOf)
    addName = i
End Function
'Parses attributes from an xml string
Public Function addAttributes(s As String, start As Long, strlen As Long) As Long

Dim i As Long
Dim startOf As Long
Dim attrName As String
Dim attrval As String
' escape characters not yet handled
'strip leading spaces
i = start

If (i >= strlen - 2) Then
    addAttributes = i
    Exit Function
End If

While (i <= strlen And VBA.mID(s, i, 1) = " ")
    i = i + 1
Wend
'search to end of attribute name
startOf = i
While (i <= strlen And VBA.mID(s, i, 1) <> "=")
    i = i + 1
Wend

If (VBA.mID(s, i, 1) <> "=") Then
    err.Raise 1005, , mLocale.GetLocalizationString("STEPXMLNodeMalformedAttribute")
    addAttributes = 0
    Exit Function
End If

attrName = VBA.mID(s, startOf, i - startOf)
'strip =
i = i + 1
startOf = i
Dim delim As String

delim = VBA.mID(s, i, 1)

If (delim <> "'" And delim <> """") Then
    err.Raise 1005, , "Malformed attribute in XML node"
    addAttributes = 0
    Exit Function
End If
i = i + 1

While (i <= strlen And VBA.mID(s, i, 1) <> delim)
    i = i + 1
Wend
i = i + 1
attrval = VBA.mID(s, startOf, i - startOf)

If (VBA.mID(attrval, 1, 1) = "'" Or VBA.mID(attrval, 1, 1) = """") Then
    attrval = VBA.mID(attrval, 2, Len(attrval) - 1)
End If

If (VBA.mID(attrval, Len(attrval), 1) = "'" Or VBA.mID(attrval, Len(attrval), 1) = """") Then
    attrval = VBA.mID(attrval, 1, Len(attrval) - 1)
End If

If (Len(attrName) < 1 Or Len(attrval) < 1) Then
    err.Raise 1005, , "Malformed attribute in XML node"
    addAttributes = 0
    Exit Function
End If

Call SetAttribute(attrName, attrval)

addAttributes = addAttributes(s, i, strlen)
End Function
'Function making sure that the collection is nothing error does not occur
Public Property Get Attributes() As Collection
    If (mAttributes Is Nothing) Then
        Set mAttributes = New Collection
    End If
    Set Attributes = mAttributes
End Property

Public Property Let Attributes(coll As Collection)
    Set mAttributes = coll
End Property
'Function making sure that the collection is nothing error does not occur
Public Property Get children() As Collection
    If (mChildren Is Nothing) Then
        Set mChildren = New Collection
    End If
    Set children = mChildren
End Property

Public Property Let children(coll As Collection)
    Set mChildren = coll
End Property

Public Property Let NodeType(tp As STEPXmlNodeType)
    mNodeType = tp
End Property
Public Property Get NodeType() As STEPXmlNodeType
    NodeType = mNodeType
End Property


Public Property Let NodeName(nn As String)
    mNodeName = nn
End Property
Public Property Get NodeName() As String
    NodeName = mNodeName
End Property
Public Sub SetAttribute(ByVal attrName As String, attrValue As String)
    Dim attr As STEPXmlAttribute
    
    Set attr = New STEPXmlAttribute
    attr.Name = attrName
    attr.Value = attrValue
    
    Call Attributes.Add(attr)
End Sub

Public Sub appendChild(Child As STEPXmlNode)
    Call children.Add(Child)
End Sub

Public Property Get ChildNodes() As Collection
    Set ChildNodes = children
End Property

'Searches for an attribute within a node
Public Function getAttributeNode(attrName As String) As STEPXmlAttribute
    Dim i As Integer
    
    For i = 1 To Attributes.Count
        If (Attributes.Item(i).Name = attrName) Then
            Set getAttributeNode = Attributes.Item(i)
            Exit Function
        End If
    Next i
'    For i = 1 To children.count
'        Dim attr As STEPXmlAttribute
'        Set attr = children.item(i).getAttributeNode(attrName)
'        If Not attr Is Nothing Then
'            Set getAttributeNode = attr
'            Exit Function
'        End If
'    Next i
    Set getAttributeNode = Nothing
End Function
'Returns xml text representing the node and all subnodes
Public Function Xml() As String
    Xml = formattedXml("")
End Function

Public Function formattedXml(leadingSpaces As String) As String
Dim i As Integer
Dim s As String
Dim xmlattributes As Boolean
Dim xmlsubnodes As Boolean
Dim leads As String

leads = "" 'leadingSpaces

xmlattributes = False
xmlsubnodes = False
'start of tag <,<? or <!--
    Select Case (mNodeType)
        Case PROCESSINGINSTRUCTION
            s = leads & "<?" & NodeName
            xmlattributes = True
        Case START_END
            s = leads & "<" & NodeName
            xmlattributes = True
        Case UNARY
            s = leads & "<" & NodeName
            xmlattributes = True
        Case COMMENTARY
            formattedXml = leads & "<!-- " & mNodeText & " -->"
            Exit Function
        Case TEXTNODE
            'xxx escape characters not handled yet
            formattedXml = leads & ThisWorkbook.escapeXmlValue(mNodeText)
            Exit Function
        Case Else
            formattedXml = ""
            Exit Function
    End Select
    'add tag attributes
    If (xmlattributes) Then
        For i = 1 To Attributes.Count
            s = s & " " & Attributes.Item(i).Xml()
        Next i
    End If
    'end the tag
    Select Case (mNodeType)
        Case PROCESSINGINSTRUCTION
            formattedXml = s & "?>"
            Exit Function
        Case START_END
            s = s & ">"
        Case UNARY
            formattedXml = s & "/>"
            Exit Function
        Case Else
            formattedXml = ""
            Exit Function
    End Select
    'xml the subnodes
    For i = 1 To children.Count
           s = s & children.Item(i).formattedXml(leads & "     ") ' no newline added
    Next i
    's = s & vbNewLine
    'xml the endnode
    Select Case (mNodeType)
        Case START_END
            formattedXml = s & leads & "</" & NodeName & ">"
            Exit Function
          Case Else
            formattedXml = ""
            Exit Function
    End Select

End Function

Public Sub clearChildren()
    Set mChildren = New Collection
End Sub

Public Sub clearAttributes()
    Set mAttributes = New Collection
End Sub

Attribute VB_Name = "STEPXmlNodeList"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'Class created by ASEME v/Anders Villy Ehrenreich Erikse
' avee42@gmail.com
'www.aseme.dk
'Class used in search functions in the STEPXmlDom class
'Basically just a collection of nodes that can be iterated
'The class mimics an array class, returned by the MS Dom classes

Private mNodes As Collection

Private Property Get Nodes() As Collection
    If mNodes Is Nothing Then
        Set mNodes = New Collection
    End If
    
    Set Nodes = mNodes
End Property

Public Sub Add(xn As STEPXmlNode)
    Call Nodes.Add(xn)
End Sub

Public Function Item(i As Integer) As STEPXmlNode
    Set Item = Nodes.Item(i)
End Function

Public Function length() As Integer
    length = Nodes.Count
End Function
Attribute VB_Name = "STEPXmlParseError"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'Class created by ASEME v/Anders Villy Ehrenreich Erikse
' avee42@gmail.com
'www.aseme.dk
'Class mimics a DOMError where the functions using this class can propogate errors to the user

Private mErrorCode As Integer
Private mReason As String
Private mSourceText As String

Public Sub SetErr(errorCode As Integer, reason As String, sourcetext As String)
    mErrorCode = errorCode
    mReason = reason
    mSourceText = sourcetext
End Sub

Public Function errorCode() As Integer
    errorCode = mErrorCode
End Function

Public Function reason() As String
    reason = mReason
End Function

Public Function srcText() As String
    srcText = mSourceText
End Function
Attribute VB_Name = "Sheet1"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "ThisWorkbook"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit
Private mUtils As New STEPSheetUtils
Private mCHandler As New STEPCommentsHandler
Private mDDRHandler As New STEPDuplicateDeleteRowHandler
Private mEscapeUtils As New STEPEscapeUtils
Private mTemplateProductHelper As New STEPTemplateProductHelper
Private selectionHandler As New STEPSelectionHandler


Private Sub Workbook_BeforeSave(ByVal SaveAsUI As Boolean, cancel As Boolean)
Dim ws As Worksheet
    For Each ws In ThisWorkbook.Sheets
       If (TypeOf ws Is Worksheet) Then
            If (mUtils.IsProductsSheet(ws)) Then
                ReleaseLocksAndFormats ws
            End If
        End If
    Next
End Sub

Private Sub Workbook_Open()
    'sometimes sheets can be left in an undetermined state. Set this on open to try to get back
    Dim mCHandler As STEPCommentsHandler
    Dim lFirstOpen As Boolean
    Dim lTimer As New STEPTimer
    lFirstOpen = False
    Me.Application.EnableEvents = True
    If (mUtils.HasSettingsSheet) Then
        On Error GoTo OPEN_ERROR
        Me.Application.ScreenUpdating = False
        Me.Application.EnableEvents = False
        lFirstOpen = Not mUtils.LovsApplied
        lTimer.StartTimer "Fix cover"
        FixCoverSheet
        lTimer.StopTimer
        lTimer.StartTimer "Setup all product sheets"
        SetupProductSheets
        lTimer.StopTimer
        If (lFirstOpen) Then lTimer.StartTimer "Apply lovs"
        ApplyAllLovs
        If (lFirstOpen) Then lTimer.StopTimer
        lTimer.StartTimer "Apply inheritance"
        ApplyInheritance
        lTimer.StopTimer
        lTimer.StartTimer "Apply Decimal separator"
        ApplyDecimalSeparator
        lTimer.StopTimer
        lTimer.StartTimer "Apply importer errors"
        ApplyImportErrors
        lTimer.StopTimer
        'For error smartsheets LOV's are already applied so we should look to ImporterErrors
        If (lFirstOpen Or mUtils.ImporterErrorsApplied) Then
            lTimer.StartTimer "Apply cell status"
            ApplyCellStatuses
            lTimer.StopTimer
            lTimer.StartTimer "Fix all comments"
            FixAllComments
            lTimer.StopTimer
        End If
        lTimer.StartTimer "Set very hidden"
        SetHidden xlSheetVeryHidden 'Hiding settings sheets from user
        lTimer.StopTimer
        If (lFirstOpen) Then
            ActivateCover
        End If
        mUtils.UnmarkMatchEntireCellContents
    End If
OPEN_ERROR:
    Me.Application.ScreenUpdating = True
    Me.Application.EnableEvents = True
End Sub

Private Sub ActivateCover()
    'seems like it is now undetermined what is the active sheet when the workbook
    'try to set it here without throwing errors
    On Error GoTo ACTIVATE_ERR
    ThisWorkbook.Sheets("Cover").Activate
    Exit Sub
ACTIVATE_ERR:
    err.Clear
End Sub

Private Sub FixAllComments()
    Dim wsv, ws As Worksheet
    For Each wsv In ThisWorkbook.Sheets
        If (TypeOf wsv Is Worksheet) Then
            Set ws = wsv
            mCHandler.formatComments ws
        End If
    Next

End Sub

Private Sub ApplyCellStatuses()
    'apply exported cell status
    'first open of workbook only
    Dim wsv As Worksheet
    Dim tracker As STEPCellStatusTracker
    For Each wsv In ThisWorkbook.Sheets
        If (TypeOf wsv Is Worksheet) Then
            If (mUtils.IsProductsSheet(wsv)) Then
                Set tracker = New STEPCellStatusTracker
                tracker.ApplyAll wsv
                Set tracker = Nothing
            End If
        End If
    Next
End Sub


Private Sub FixCoverSheet()
    'if changes are made to serverside SmartBook.createDefaultSheets it must be reflected here
    Const COLOR_COLUMN = 2
    Const FIRST_COLOR_ROW = 12

    'piggy-back on lovs to only do this once
    If (mUtils.LovsApplied) Then
       Exit Sub
    End If
    If Not mUtils.HasExtendedSettingsSheet Then
        'quick-sheets can have custom cover-sheets and we generally do not care
        Exit Sub
    End If
    On Error GoTo FIX_ERR
    Dim marker As STEPCellMarker
    Set marker = New STEPCellMarker
    Dim ea As Boolean, unprot As Boolean
    unprot = False
    Dim deleteTemplateProductColorRow As Boolean
    deleteTemplateProductColorRow = Not mTemplateProductHelper.anyTemplateProductRowInWorkbook(ThisWorkbook)
    Dim wsv, ws As Worksheet
    For Each wsv In ThisWorkbook.Sheets
        If (TypeOf wsv Is Worksheet) Then
            Set ws = wsv
            If (ws.Index > 1) Then
                GoTo FIX_ERR
            End If
        End If
        If (StrComp(ws.Name, "Cover") = 0) Then
            unprot = True
            mUtils.UnProtectSheet ws
            Dim cells As Range
            Set cells = ws.Range(ws.cells(FIRST_COLOR_ROW, COLOR_COLUMN), ws.cells(FIRST_COLOR_ROW, COLOR_COLUMN))
            marker.MarkValidMandatory cells
            Set cells = ws.Range(ws.cells(FIRST_COLOR_ROW + 1, COLOR_COLUMN), ws.cells(FIRST_COLOR_ROW + 1, COLOR_COLUMN))
            marker.MarkValidReadonly cells
            If Not IsEmpty(ws.cells(FIRST_COLOR_ROW + 4, COLOR_COLUMN)) Then
                Set cells = ws.Range(ws.cells(FIRST_COLOR_ROW + 2, COLOR_COLUMN), ws.cells(FIRST_COLOR_ROW + 2, COLOR_COLUMN))
                marker.MarkCellStatus cells, STEPCellInoperative
                Set cells = ws.Range(ws.cells(FIRST_COLOR_ROW + 3, COLOR_COLUMN), ws.cells(FIRST_COLOR_ROW + 3, COLOR_COLUMN))
                marker.MarkInvalid cells, ws.cells(FIRST_COLOR_ROW + 3, COLOR_COLUMN)
                If (deleteTemplateProductColorRow) Then
                    ws.Rows(FIRST_COLOR_ROW + 4).EntireRow.Delete
                Else
                    Set cells = ws.Range(ws.cells(FIRST_COLOR_ROW + 4, COLOR_COLUMN), ws.cells(FIRST_COLOR_ROW + 4, COLOR_COLUMN))
                    marker.MarkCellStatus cells, STEPCellTemplateProduct
                End If
            Else
                Set cells = ws.Range(ws.cells(FIRST_COLOR_ROW + 2, COLOR_COLUMN), ws.cells(FIRST_COLOR_ROW + 2, COLOR_COLUMN))
                marker.MarkInvalid cells, ws.cells(FIRST_COLOR_ROW, COLOR_COLUMN + 3)
                If (deleteTemplateProductColorRow) Then
                    ws.Rows(FIRST_COLOR_ROW + 3).EntireRow.Delete
                Else
                    Set cells = ws.Range(ws.cells(FIRST_COLOR_ROW + 3, COLOR_COLUMN), ws.cells(FIRST_COLOR_ROW + 3, COLOR_COLUMN))
                    marker.MarkCellStatus cells, STEPCellTemplateProduct
                End If
            End If
            GoTo FIX_ERR
        End If
    Next
FIX_ERR:
    If (unprot) Then
        mUtils.ProtectSheet ws
    End If
End Sub

Private Sub SetHidden(ByVal visibility As XlSheetVisibility)
    SetVisibility "STEPSettings", visibility
    SetVisibility "STEPSmartSheetSettings", visibility
    SetVisibility "STEPSmartSheetModelInfo", visibility
    SetVisibility "STEPLov", visibility
    SetVisibility "STEPChanges", visibility
    SetVisibility "STEPSmartSheetImporterErrors", visibility
    SetVisibility "STEPLogging", visibility
    SetVisibility "STEPLocalization", visibility
End Sub

Private Sub SetVisibility(ByVal sheetname As String, ByVal visibility As XlSheetVisibility)
    On Error GoTo VISIBILITY_ERR
    If (Not ThisWorkbook.Sheets(sheetname) Is Nothing) Then
        ThisWorkbook.Sheets(sheetname).Visible = visibility
    End If
    Exit Sub
VISIBILITY_ERR:
    err.Clear
End Sub

Private Sub ApplyImportErrors()
    Dim mErrorSheetUtils As STEPErrorSheetUtils
    Set mErrorSheetUtils = New STEPErrorSheetUtils
    mErrorSheetUtils.ApplyImporterErrors
    Set mErrorSheetUtils = Nothing
End Sub

Private Sub ApplyDecimalSeparator()
    Dim decimalUtil As STEPSeparatorUtils
    Set decimalUtil = New STEPSeparatorUtils
    decimalUtil.ApplyReplace
    Set decimalUtil = Nothing
End Sub

Private Sub ApplyAllLovs()
    Dim util As New STEPLovUtils
    util.ApplyLovs
End Sub

Private Sub ApplyInheritance()
    If (Not mUtils.HasExtendedSettingsSheet) Then
        Dim util As New STEPInheritanceUtils
        util.ApplyInheritance
    End If
End Sub

Private Sub Workbook_SheetActivate(ByVal Sh As Object)
    If (TypeOf Sh Is Worksheet) Then
        Dim ws As Worksheet
        Set ws = Sh
        If (mUtils.IsProductsSheet(ws)) Then
            If (Not ws.ProtectionMode) Then
                'for unknow reasons initial protection of product sheets sometimes fails in .xmls
                mUtils.ProtectSheet ws
            End If
        End If
    End If
End Sub
Private Function CombineCells(cells1 As Range, cells2 As Range) As Range
    If (cells1 Is Nothing) Then
        Set CombineCells = cells2
    Else
        If (cells2 Is Nothing) Then
            Set CombineCells = cells1
        Else
            Set CombineCells = Union(cells1, cells2)
        End If
    End If
End Function

Private Sub Workbook_SheetChange(ByVal Sh As Object, ByVal Target As Range)
    If (TypeOf Sh Is Worksheet) Then
        Dim cell As Range
        Dim cells As Range
        For Each cell In Target
            If (mUtils.IsWorkingColumn(Sh, cell.Column)) Then
                'doing formulas in working column cells can change the number format to text
                'make sure the number format is correct after changing cells
                mUtils.SetNumberFormat cell
            Else
                Set cells = CombineCells(cells, cell)
            End If
        Next cell
        If (Not cells Is Nothing) Then
            Dim sc As New STEPChangeTracker
            sc.change Sh, cells
        End If
    End If
End Sub



Public Sub SetupProductSheets()
    Dim su As New STEPSheetSetup
    Dim sc As New STEPChangeTracker
    sc.AssureChangesSheetIsCreated
    On Error GoTo ADD_ERR
    Dim aee As Boolean
    aee = Me.Application.EnableEvents
    Me.Application.EnableEvents = False
    Dim wsv, ws As Worksheet
    For Each wsv In ThisWorkbook.Sheets
        If (TypeOf wsv Is Worksheet) Then
            Set ws = wsv
            su.SetUp ws
        End If
    Next
ADD_ERR:
    Me.Application.EnableEvents = aee
End Sub


Public Sub RemoveSheetButtons()
    Dim su As New STEPSheetSetup
    On Error GoTo REMOVE_ERR
    Dim wsv, ws As Worksheet
    For Each wsv In ThisWorkbook.Sheets
        If (TypeOf wsv Is Worksheet) Then
            Set ws = wsv
            su.RemoveSheetButton ws
        End If
    Next
REMOVE_ERR:
End Sub


Public Sub ValidateActiveSheet()
    Dim f As New STEPValidateForm
    f.ValidateSheet ThisWorkbook.ActiveSheet
End Sub

Public Sub formatComments(ByVal ws As Worksheet)
    mCHandler.formatComments ws
End Sub

Public Sub ValidateWorkbook()
    Dim f As New STEPValidateForm
    f.ValidateBook ThisWorkbook
End Sub

Private Sub Workbook_SheetSelectionChange(ByVal Sh As Object, ByVal Target As Range)
    selectionHandler.handle Sh, Target
End Sub


Public Sub NextError()
    mCHandler.NextError ThisWorkbook.ActiveSheet
End Sub

Public Sub DeleteRow()
    mDDRHandler.DeleteRow ThisWorkbook.ActiveSheet
End Sub

Public Sub DuplicateRow()
    mDDRHandler.DuplicateRow ThisWorkbook.ActiveSheet
End Sub

Private Sub ReleaseLocksAndFormats(ws As Worksheet)
    Dim localSeparator As Boolean
    localSeparator = mUtils.UseLocalDecimalSeparator
    Dim firstRow As Integer, lastRow As Integer
    Dim col As Integer, lastcol As Integer, row As Integer
    Dim changes As New STEPChangeTracker
    Dim statuses As New STEPCellStatusTracker
    Dim screenUpd As Boolean, enableEvt As Boolean
    Dim cell As Range
    screenUpd = ThisWorkbook.Application.ScreenUpdating
    enableEvt = ThisWorkbook.Application.EnableEvents
    On Error GoTo FMT_ERR
    ThisWorkbook.Application.ScreenUpdating = False
    ThisWorkbook.Application.EnableEvents = False
    firstRow = mUtils.FirstProductRow(ws, False)
    If (mUtils.HasExtendedSettingsSheet) Then
        lastRow = mUtils.GetLastRow(ws, 1)
    Else
        If (mUtils.IsInitiateWorkbook) Then
            lastRow = mUtils.LastInitiateRow(ws)
        Else
            lastRow = mUtils.GetLastRow(ws, 2)
        End If
    End If
    lastcol = mUtils.GetLastCol(ws, mUtils.ColumnReadOnlyRowIndex)
    statuses.Init ws.Name
    For row = firstRow To lastRow
        If changes.IsProductChanged(ws.Name, cells(row, mUtils.GetIDColumnIndex), row) Then
            For col = 1 To lastcol
                Set cell = ws.cells(row, col)
                If mUtils.IsColumnReadOnly(ws, col) Then
                    If (Not cell.Locked) Then cell.Locked = True
                ElseIf (mUtils.IsWorkingColumn(ws, col)) Then
                    'Nothing
                ElseIf Not statuses.GetCellStatus(ws.cells(row, col).Address) Is Nothing Then
                    'do not release individual cells that has been locked by validation
                    If (Not cell.Locked) Then cell.Locked = True
                Else
                    If (cell.Locked) Then cell.Locked = False
                    mUtils.SetNumberFormat cell
                    Dim var
                    Dim strval As String
                    var = cell.Value
                    Select Case VarType(var)
                        Case vbNull
                        Case vbEmpty
                        Case vbString
                        Case vbSingle, vbDouble, vbDecimal
                            If (localSeparator) Then
                                'use clients native separator - importer will convert to something STEP understands
                                strval = VBA.Format$(var)
                            Else
                                'the str function always uses . as speparator and unless specifically instructed to use the
                                'clients native decimal separator just do what STEP likes best
                                strval = VBA.Trim$(VBA.str$(var))
                            End If
                            cell.Value = strval
                        Case Else
                            strval = VBA.Format(var)
                            cell.Value = strval
                    End Select
                End If
            Next col
        End If

    Next row
    'lock headers
    firstRow = firstRow - 1
    ws.Range(ws.cells(firstRow, 1), ws.cells(firstRow, lastcol)).Locked = True
FMT_ERR:
    ThisWorkbook.Application.ScreenUpdating = screenUpd
    ThisWorkbook.Application.EnableEvents = enableEvt
End Sub

'wrapper around utility-class
Public Function escapeXmlValue(ByVal strXMLValue As String) As String
    escapeXmlValue = mEscapeUtils.escapeXmlValue(strXMLValue)
End Function

'wrapper around utility-class
Public Function unescapeXmlValue(ByVal strXMLValue As String) As String
    unescapeXmlValue = mEscapeUtils.unescapeXmlValue(strXMLValue)
End Function


Attribute VB_Name = "clsNode"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'Build 024
'***************************************************************************
'
' Authors:  JKP Application Development Services, info@jkp-ads.com, http://www.jkp-ads.com
'           Peter Thornton, pmbthornton@gmail.com
'
' (c)2013, all rights reserved to the authors
'
' You are free to use and adapt the code in these modules for
' your own purposes and to distribute as part of your overall project.
' However all headers and copyright notices should remain intact
'
' You may not publish the code in these modules, for example on a web site,
' without the explicit consent of the authors
'***************************************************************************

'-------------------------------------------------------------------------
' Module    : clsNode
' Company   : JKP Application Development Services (c)
' Author    : Jan Karel Pieterse (www.jkp-ads.com)
' Created   : 15-01-2013
' Purpose   : Holds all information of a node of the tree
'-------------------------------------------------------------------------
Option Explicit

Private mbExpanded As Boolean

Private mcolChildNodes As Collection

Private moParentNode As clsNode
Private moLastActiveNode As clsNode
Private moTree As clsTreeView

Private msKey As String
Private mvCaption

Private mlChecked As Long        ' PT checkbox tristate boolean 0/-1 or 1 for null
'Private mbVisible As Boolean        ' PT determines if the node can be displayed
Private mnIndex As Long             ' PT order added to Treeview's mcolNodes, won't change
Private mlVisIndex As Long          ' PT the visible order in the current view, changes with expand/collapse
Private mvIconMainKey               ' PT string name or numeric index as icon Key for the Image collection
Private mvIconExpandedKey           ' PT ditto for expanded icon
Private mlIconCnt As Long           ' PT number of icons availabel for this node 0, 1 or 2
Private msngTextWidth As Single     ' PT autosized text width before the node is widened beyond the frame
Private mlBackColor As Long         ' PT
Private mbBold As Boolean           ' PT
Private mlForeColor As Long         ' PT
Private mvTag

Private WithEvents mctlControl As MSForms.label
Attribute mctlControl.VB_VarHelpID = -1
Private WithEvents mctlExpander As MSForms.label
Attribute mctlExpander.VB_VarHelpID = -1
Private WithEvents moEditBox As MSForms.TextBox     ' PT editbox
Attribute moEditBox.VB_VarHelpID = -1
Private WithEvents mctlCheckBox As MSForms.label    ' PT checkbox
Attribute mctlCheckBox.VB_VarHelpID = -1

Private mctlExpanderBox As MSForms.label
Private mctlVLine As MSForms.label  ' PT vertical line, only the first child node with children will have a vertical line
Private mctlHLine As MSForms.label  ' PT horizontal line
Private mctlIcon As MSForms.Image   ' PT separate icon image control

Public Enum ndSortOrder
    ndAscending = 1
    ndDescending = 2
End Enum
Public Enum ndCompareMethod
    ndBinaryCompare = 0
    ndTextCompare = 1
End Enum
Public Enum ndMouse
    ndDown = 1
    ndUp = 2
    ndMove = 3
    ndBeforeDragOver = 4
    ndBeforeDropOrPaste = 5
End Enum

#If Mac Then
    Const mcFullWidth As Long = 800
#Else
    Const mcFullWidth As Long = 600
#End If

'*********************
'* Public Properties *
'*********************

Public Property Get BackColor() As Long

    BackColor = mlBackColor ' if zero the treecaller will apply the frame container's backcolor

End Property

Public Property Let BackColor(lColor As Long)
'PT if lColor is written as 0/black, change it to 1 as 0 means default
    mlBackColor = lColor
    If mlBackColor = 0 Then mlBackColor = 1
    If Not mctlControl Is Nothing Then
        mctlControl.BackColor = lColor
    End If
End Property

Public Property Get Bold() As Boolean
    Bold = mbBold
End Property

Public Property Let Bold(bBold As Boolean)
    mbBold = bBold
    If Not mctlControl Is Nothing Then
        mctlControl.Font.Bold = mbBold
    End If
End Property

Public Property Get Caption()
    Caption = mvCaption
End Property

Public Property Let Caption(ByVal vCaption)
    mvCaption = vCaption
    If Not mctlControl Is Nothing Then
        mctlControl.Caption = CStr(vCaption)
    End If
End Property

Public Property Get Child() As clsNode
' PT Returns a reference to the first Child node, if any
    On Error Resume Next
    Set Child = mcolChildNodes(1)
End Property

Public Property Get Checked()    ' PT
     ' Checked values are -1 true, 0 false, +1 mixed
     ' If TriState is enabled be careful not to return a potential +1 to a boolean or it'll coerce to True
    Checked = mlChecked
End Property

Public Property Let Checked(vChecked)  ' PT
    Dim bFlag As Boolean, bTriState As Boolean
    Dim lChecked As Long
    Dim cChild As clsNode

    ' Checked values are -1 true, 0 false, +1 mixed
    ' if vChecked is a boolean Checked will coerce to -1 or 0
    ' if vChecked is Null Checked is set as +1

    If VarType(vChecked) = vbBoolean Then
        lChecked = vChecked
    ElseIf IsNull(vChecked) Then
        lChecked = 1
    ElseIf vChecked >= -1 And vChecked <= 1 Then
        lChecked = vChecked
    End If

    bFlag = lChecked <> mlChecked
    mlChecked = lChecked

    If Not mctlCheckBox Is Nothing And bFlag Then
        moTree.Changed = True
        UpdateCheckbox
    End If
    
    If Not moTree Is Nothing Then    ' eg during clone
        bFlag = moTree.CheckBoxes(bTriState)
        If bTriState Then
            If ParentNode.Caption <> "RootHolder" Then
                ParentNode.CheckTriStateParent
            End If
            
            If Not ChildNodes Is Nothing Then
                For Each cChild In ChildNodes
                    cChild.CheckTriStateChildren mlChecked
                Next
            End If
        End If
    End If
    
End Property

Public Property Get ChildNodes() As Collection
    If mcolChildNodes Is Nothing Then
        Set mcolChildNodes = New Collection
    End If
    Set ChildNodes = mcolChildNodes
End Property

Public Property Set ChildNodes(colChildNodes As Collection)
    Set mcolChildNodes = colChildNodes
End Property

Public Property Get Expanded() As Boolean
    Expanded = mbExpanded
End Property

Public Property Let Expanded(ByVal bExpanded As Boolean)
    mbExpanded = bExpanded
    If Not Me.Expander Is Nothing Then
        UpdateExpanded bControlOnly:=False
    ElseIf Not Me.Control Is Nothing Then
        UpdateExpanded bControlOnly:=True
    End If
End Property

Public Property Get ForeColor() As Long
    ForeColor = mlForeColor
End Property

Public Property Let ForeColor(lColor As Long)
'PT if lColor is written as 0/black, change it to 1 as 0 means default
    mlForeColor = lColor
    If mlForeColor = 0 Then mlForeColor = 1
    If Not mctlControl Is Nothing Then
        mctlControl.ForeColor = lColor
    End If
End Property

Public Property Get FirstSibling() As clsNode
    If Not moParentNode Is Nothing Then    ' PT Root has no parent
        Set FirstSibling = moParentNode.GetChild(1)
    End If
End Property

Public Property Get LastSibling() As clsNode
    If Not moParentNode Is Nothing Then    ' PT Root has no parent
        Set LastSibling = moParentNode.GetChild(-1)    ' -1 flags GetChild to return the last Child
    End If
End Property

Public Property Get ImageExpanded()
' PT string name or numeric index for the main icon key
    ImageExpanded = mvIconExpandedKey
End Property

Public Property Let ImageExpanded(vImageExpanded)
' PT string name or numeric index for an expanded icon key
    On Error GoTo errExit
    If Not IsMissing(vImageExpanded) Then
        If Not IsEmpty(vImageExpanded) Then
            If Len(mvIconMainKey) = 0 Then
                mvIconMainKey = vImageExpanded
            End If
            mvIconExpandedKey = vImageExpanded
            mlIconCnt = 2
        End If
    End If
errExit:
End Property

Public Property Get ImageMain()
' PT string name or numeric index for the main icon key
    ImageMain = mvIconMainKey
End Property

Public Property Let ImageMain(vImageMain)
' PT string name or numeric index for the main icon key
    On Error GoTo errExit
    If Not IsMissing(vImageMain) Then
        If Not IsEmpty(vImageMain) Then
            mvIconMainKey = vImageMain
            If mlIconCnt = 0 Then mlIconCnt = 1
        End If
    End If
errExit:
End Property

Public Property Get Key() As String
    Key = msKey
End Property

Public Property Let Key(ByVal sKey As String)
    Dim bIsInMainCol As Boolean
    Dim i As Long
    Dim cTmp As clsNode

    On Error GoTo errH

    If Tree Is Nothing Then
        msKey = sKey
        Exit Property
    ElseIf msKey = sKey Or Len(sKey) = 0 Then
        Exit Property
    End If

    On Error Resume Next
    Set cTmp = Tree.Nodes.Item(sKey)
    On Error GoTo errH

    If Not cTmp Is Nothing Then
        err.Raise 457    ' standard duplicate key error
    End If

    ' to change the Key, remove Me and add Me back where it was with the new key
    For Each cTmp In Tree.Nodes
        i = i + 1
        If cTmp Is Me Then
            bIsInMainCol = True
            Exit For
        End If
    Next

    If bIsInMainCol Then
        With Tree.Nodes
            .Remove i
            If .Count Then
                .Add Me, sKey, i
            Else
                .Add Me
            End If
        End With
    Else
        ' Let Key  called by via move/copy
    End If

    msKey = sKey

    Exit Property
errH:
    err.Raise err.Number, "Let Key", err.Description
End Property

Public Property Get level() As Long
    Dim lLevel As Long
    Dim cNode As clsNode

    On Error GoTo errH
    lLevel = -1
    Set cNode = Me.ParentNode
    While Not cNode Is Nothing
        lLevel = lLevel + 1
        Set cNode = cNode.ParentNode
    Wend
    level = lLevel
    Exit Property
errH:
    #If DebugMode = 1 Then
        Stop
        Resume
    #End If
End Property

Public Property Get NextNode() As clsNode    ' can't name this proc 'Next' in VBA
' PT return the next sibling if there is one
    Dim i As Long
    Dim cNode As clsNode

    With Me.ParentNode
        For Each cNode In .ChildNodes
            i = i + 1
            If cNode Is Me Then
                Exit For
            End If
        Next
        If .ChildNodes.Count > i Then
            Set NextNode = .ChildNodes(i + 1)
        End If
    End With
End Property

Public Property Get ParentNode() As clsNode
    Set ParentNode = moParentNode
End Property

Public Property Set ParentNode(oParentNode As clsNode)
    Set moParentNode = oParentNode
End Property

Public Property Get Previous() As clsNode
' PT return the previous sibling if there is one
    Dim i As Long
    Dim cNode As clsNode

    With Me.ParentNode
        For Each cNode In Me.ParentNode.ChildNodes
            i = i + 1
            If cNode Is Me Then
                Exit For
            End If
        Next
        If i > 1 Then
            Set NextNode = .ChildNodes(i - 1)
        End If
    End With
End Property

Public Property Get Root() As clsNode
    Dim cTmp As clsNode
    Set cTmp = Me
    Do While Not cTmp.ParentNode.ParentNode Is Nothing
        Set cTmp = cTmp.ParentNode
    Loop
    Set Root = cTmp
End Property

Public Property Get Tag()
    Tag = mvTag
End Property

Public Property Let Tag(vTag)
    mvTag = vTag
End Property


'*****************************
'* Public subs and functions *
'*****************************

Public Function Sort(Optional ByVal ndOrder As ndSortOrder = ndAscending, _
                     Optional ByVal ndCompare As ndCompareMethod = ndTextCompare) As Boolean
' PT Sorts the child nodes,
'    returns True if the order has changed to flag Refresh should be called
    Dim sCaptions() As String
    Dim lStart As Long, lLast As Long, i As Long
    Dim colNodes As New Collection
    Dim bIsUnSorted As Boolean
    Dim idx() As Long
    On Error GoTo errExit
    lStart = 1
    lLast = ChildNodes.Count    ' error if no childnodes to sort

    If lLast = 1 Then
        ' nothing to sort
        Exit Function
    End If

    ReDim idx(lStart To lLast) As Long
    ReDim sCaptions(lStart To lLast) As String
    For i = lStart To lLast
        idx(i) = i
        sCaptions(i) = ChildNodes.Item(i).Caption
    Next

    If ndOrder <> ndAscending Then ndOrder = -1    ' descending
    If ndCompare <> ndTextCompare Then ndCompare = ndBinaryCompare

    Call BinarySortIndexText(sCaptions(), lStart, lLast, idx, ndOrder, ndCompare)

    For i = lStart To lLast - 1
        If idx(i) <> idx(i + 1) - 1 Then
            bIsUnSorted = True
            Exit For
        End If
    Next

    If bIsUnSorted Then
        For i = lStart To lLast
            colNodes.Add ChildNodes(idx(i))
        Next
        Set ChildNodes = colNodes
        Sort = True
    End If

errExit:
'   Probably(?) any error was because there were no childnodes, no need to raise an error
End Function

Public Function AddChild(Optional sKey As String, _
                         Optional vCaption, _
                         Optional vImageMain, _
                         Optional vImageExpanded) As clsNode

    Dim cChild As clsNode

    On Error GoTo errH
    Set cChild = New clsNode

    With moTree.Nodes

        If Len(sKey) Then
100         .Add cChild, sKey
101
            cChild.Key = sKey
        Else
            .Add cChild
        End If

        cChild.Index = .Count
    End With

    If mcolChildNodes Is Nothing Then
        Set mcolChildNodes = New Collection
    End If

    mcolChildNodes.Add cChild

    With cChild
        If Not IsMissing(vImageMain) Then
            If Len(vImageMain) Then
                .ImageMain = vImageMain
            End If
        End If

        If Not IsMissing(vImageExpanded) Then
            If Len(vImageExpanded) Then
                .ImageExpanded = vImageExpanded
            End If
        End If

        .Caption = vCaption

        Set .Tree = moTree
        Set .ParentNode = Me
    End With

    Set AddChild = cChild

    Exit Function
errH:
    #If DebugMode = 1 Then
        Stop
        Resume
    #End If

    If Erl = 100 And err.Number = 457 Then
        err.Raise vbObjectError + 1, "clsNode.AddChild", "Duplicate key: '" & sKey & "'"
    Else
        err.Raise err.Number, "clsNode.AddChild", err.Description
    End If
End Function

Public Function ChildIndex(sKey As String) As Long
'-------------------------------------------------------------------------
' Procedure : ChildIndex
' Company   : JKP Application Development Services (c)
' Author    : Jan Karel Pieterse (www.jkp-ads.com)
' Created   : 15-01-2013
' Purpose   : Returns the index of a childnode using its key
'-------------------------------------------------------------------------
    Dim cNode As clsNode
    Dim lCt As Long
    For Each cNode In mcolChildNodes
        lCt = lCt + 1
        If sKey = cNode.Key Then
            ChildIndex = lCt
            Set cNode = Nothing
            Exit Function
        End If
    Next
    Set cNode = Nothing
End Function

Public Function FullPath() As String
' PT, get all the grand/parent keys
' assumes use of key

    Dim s As String
    Dim cNode As clsNode

    On Error GoTo errDone
    s = Me.Key
    Set cNode = Me

    While err.Number = 0
        Set cNode = cNode.ParentNode
        s = cNode.Key & "\" & s
    Wend

errDone:
    FullPath = s
End Function

Public Function GetChild(vKey As Variant) As clsNode
'-------------------------------------------------------------------------
' Procedure : GetChild
' Company   : JKP Application Development Services (c)
' Author    : Jan Karel Pieterse (www.jkp-ads.com)
' Created   : 15-01-2013
' Purpose   : Returns a childnode using its key
'-------------------------------------------------------------------------
    Dim cNode As clsNode
    Dim lIdx As Long

    If VarType(vKey) = vbString Then

        For Each cNode In mcolChildNodes
            If vKey = cNode.Key Then
                Set GetChild = cNode
                Set cNode = Nothing
                Exit Function
            End If
        Next

    ElseIf Not mcolChildNodes Is Nothing Then
        lIdx = vKey
        If lIdx = -1 Then
            lIdx = mcolChildNodes.Count
        End If
        If lIdx > 0 Then
            Set GetChild = mcolChildNodes(lIdx)
        Else: Set mcolChildNodes = Nothing
        End If
    End If

    Set cNode = Nothing
End Function


'*************************************************************************
'*    Friend Properties, Subs & Funtions                                 *
'*    ** these procedures are visible throughout the project but should  *
'*    ** only be used to communicate with the TreeView, ie clsTreeView   *
'*************************************************************************



'' PT new properties in 006PT2:
'' Created, CreatedButton, Checked, CheckBoxName, Index, VisIndex
''

Friend Property Get Control() As MSForms.label
    Set Control = mctlControl
End Property

Friend Property Set Control(ctlControl As MSForms.label)
    Set mctlControl = ctlControl
    If Not mctlControl Is Nothing Then
        If Not moTree Is Nothing Then
            'simple assigning the font from the treecontrol eventually destroys it; instead copy all properties
            mctlControl.Font.Bold = moTree.TreeControl.Font.Bold
            mctlControl.Font.Charset = moTree.TreeControl.Font.Charset
            mctlControl.Font.Italic = moTree.TreeControl.Font.Italic
            mctlControl.Font.Name = moTree.TreeControl.Font.Name
            mctlControl.Font.size = moTree.TreeControl.Font.size
            'setting Strikethrough value does crazy things - it becomes always true
            mctlControl.Font.Underline = moTree.TreeControl.Font.Underline
        Else
            Stop
        End If
    End If
End Property

Friend Property Get Index() As Long    ' PT
    Index = mnIndex
End Property

Friend Property Let Index(idx As Long)
' PT Index: the order this node was added to Treeview's collection mcolNodes
'    Index will never increase but may decrement if previously added nodes are removed
    mnIndex = idx
End Property

Friend Property Let VisIndex(lVisIndex As Long)
    mlVisIndex = lVisIndex
End Property

Friend Property Get VisIndex() As Long    ' PT
    VisIndex = mlVisIndex
End Property

Friend Property Get Tree() As clsTreeView
    Set Tree = moTree
End Property

Friend Property Set Tree(oTree As clsTreeView)
    Set moTree = oTree
End Property

Friend Property Get Checkbox() As MSForms.Control
    Set Checkbox = mctlCheckBox
End Property

Friend Property Set Checkbox(oCtl As MSForms.Control)
    Set mctlCheckBox = oCtl
End Property

Friend Property Get Expander() As MSForms.label
    Set Expander = mctlExpander
End Property

Friend Property Set Expander(ctlExpander As MSForms.label)
    Set mctlExpander = ctlExpander
End Property

Friend Property Get ExpanderBox() As MSForms.label
    Set ExpanderBox = mctlExpanderBox
End Property

Friend Property Set ExpanderBox(ctlExpanderBox As MSForms.label)
    Set mctlExpanderBox = ctlExpanderBox
End Property

Friend Property Set HLine(ctlHLine As MSForms.label)
    Set mctlHLine = ctlHLine
End Property

Friend Property Get HLine() As MSForms.label
    Set HLine = mctlHLine
End Property

Friend Property Set Icon(ctlIcon As MSForms.Image)
    Set mctlIcon = ctlIcon
End Property

Friend Property Get Icon() As MSForms.Image
    Set Icon = mctlIcon
End Property

Friend Property Get TextWidth() As Single
    TextWidth = msngTextWidth
End Property

Friend Property Let TextWidth(sngTextWidth As Single)
    msngTextWidth = sngTextWidth
End Property

Friend Property Get VLine() As MSForms.label
    Set VLine = mctlVLine
End Property

Friend Property Set VLine(ctlVLine As MSForms.label)
    Set mctlVLine = ctlVLine
End Property

Friend Sub CheckTriStateParent()
' PT set triState value of parent according to its childnodes' values
    Dim alChecked(-1 To 1) As Long
    Dim cChild As clsNode

    If Not ChildNodes Is Nothing Then
        For Each cChild In ChildNodes
            alChecked(cChild.Checked) = alChecked(cChild.Checked) + 1
        Next
        If alChecked(1) Then
            alChecked(1) = 1
        ElseIf alChecked(-1) = ChildNodes.Count Then
            alChecked(1) = -1
        ElseIf alChecked(0) = ChildNodes.Count Then
            alChecked(1) = 0
        Else
            alChecked(1) = 1
        End If
        
        If Checked <> alChecked(1) Then
            mlChecked = alChecked(1)
            UpdateCheckbox
        End If

    End If
    
    If Not Me.Caption = "RootHolder" Then
        If Not ParentNode.ParentNode Is Nothing Then
            ParentNode.CheckTriStateParent
        End If
    End If

End Sub

Friend Sub CheckTriStateChildren(lChecked As Long)
' PT, make checked values of children same as parent's
'     only called if triState is enabled
Dim cChild As clsNode

    mlChecked = lChecked
    UpdateCheckbox

    If Not ChildNodes Is Nothing Then
        For Each cChild In ChildNodes
            cChild.CheckTriStateChildren lChecked
        Next
    End If
End Sub

Friend Function hasIcon(vKey) As Boolean
' PT get the appropriate icon key/index, if any
    If mlIconCnt = 2 And mbExpanded Then
        vKey = mvIconExpandedKey
        hasIcon = True    'Not IsEmpty(vKey) '(True
    ElseIf mlIconCnt Then
        vKey = mvIconMainKey
        hasIcon = True    'Not IsEmpty(vKey)
    End If
End Function

Friend Sub EditBox(bEnterEdit As Boolean)    '  PT new in 006PT2 ,,move to clsTreView
'-------------------------------------------------------------------------
' Procedure : moCtl_Click
' Author    : Peter Thornton
' Created   : 20-01-2013
' Purpose   : Enter/exit Editmode, show/hide the edit textbox
'-------------------------------------------------------------------------
    On Error Resume Next
    Set moEditBox = moTree.TreeControl.Controls("EditBox")
    On Error GoTo 0

    If bEnterEdit Then
    
        If moEditBox Is Nothing Then
            Set moEditBox = moTree.TreeControl.Controls.Add("forms.textbox.1", False)
            moEditBox.Name = "EditBox"
        End If

        With moEditBox
            .Left = Control.Left - 3
            .top = Control.top - 1.5
            .AutoSize = True
            .BorderStyle = MSForms.fmBorderStyleSingle
            .Text = Caption
            Control.Visible = False    ' hide the node label while editing
            .ZOrder 0
            .Visible = True
            .SelStart = 0
            .SelLength = Len(.Text)
            .SetFocus
        End With

    ElseIf Not moEditBox Is Nothing Then
        ' exit editmode
        If Not moEditBox Is Nothing Then
            ' error if moEditBox has already been removed
            On Error Resume Next
            moEditBox.Visible = False
            moEditBox.Text = ""
            Set moEditBox = Nothing
        End If
        Control.Visible = True

    End If
End Sub

Friend Function RemoveChild(cNode As clsNode) As Boolean
'PT remove a node from the collection,
'   note, this is only one part of the process of removing a node

    Dim lCt As Long
    Dim cTmp As clsNode
    On Error GoTo errH

    For Each cTmp In mcolChildNodes
        lCt = lCt + 1
        If cTmp Is cNode Then
            mcolChildNodes.Remove lCt
            RemoveChild = True
            Exit For
        End If
    Next

    If mcolChildNodes.Count = 0 Then
        Set mcolChildNodes = Nothing
        Me.Expanded = False
    End If

    Exit Function
errH:
    err.Raise vbObjectError, "RemoveChild", err.Description
End Function

Friend Sub RemoveNodeControls()
    Dim cChild As clsNode
    If Not ChildNodes Is Nothing Then
        For Each cChild In ChildNodes
            cChild.RemoveNodeControls
        Next
    End If
    DeleteNodeControls False
End Sub

Friend Sub TerminateNode(Optional bDeleteNodeControls As Boolean)
'-------------------------------------------------------------------------
' Procedure : TerminateNode
' Company   : JKP Application Development Services (c)
' Author    : Jan Karel Pieterse (www.jkp-ads.com)
' Created   : 15-01-2013
' Purpose   : Terminates the class instance
'-------------------------------------------------------------------------
    Dim cChild As clsNode
    'Instead of the Terminate event of the class we use this public
    'method so it can be explicitly called by parent classes.
    'This is done because to break the two way or circular references
    'between the parent child classes.
    
    'The most important call in this routine is to destroy the reference
    'between this node class and the parent treeview class -
    '    < Set moTree = Nothing >
    'Once all the moTree references to have been destroyed everything else will
    ' 'tear down' normally

    If Not ChildNodes Is Nothing Then
        For Each cChild In ChildNodes
            ' recursively drill down to all child nodes in this branch
            cChild.TerminateNode bDeleteNodeControls
        Next
    End If

    ' If deleting individual nodes while the treeview is running we also want to
    ' remove all associated controls as well as removing references
    
    If bDeleteNodeControls Then
        DeleteNodeControls True
        If bDeleteNodeControls Then
            Index = -1
        End If
    End If

    Set mcolChildNodes = Nothing
    Set moTree = Nothing
End Sub


'******************************
'* Private subs and functions *
'******************************

Private Sub BinarySortIndexText(sCaptions() As String, ByVal lStart As Long, ByVal lEnd As Long, ByRef idx() As Long, ndOrder As Long, ndCompare As ndCompareMethod)
' PT sorts the index array based on the string array
    Dim lSmall As Long, lLarge As Long, sMid As String, lTmp As Long

    lSmall = lStart
    lLarge = lEnd
    sMid = sCaptions(idx((lSmall + lLarge) / 2))

    Do While lSmall <= lLarge
        Do While (StrComp(sCaptions(idx(lSmall)), sMid, ndCompare) = -ndOrder And lSmall < lEnd)
            lSmall = lSmall + 1
        Loop
        Do While (StrComp(sCaptions(idx(lLarge)), sMid, ndCompare) = ndOrder And lLarge > lStart)
            lLarge = lLarge - 1
        Loop
        If lSmall <= lLarge Then
            lTmp = idx(lSmall)
            idx(lSmall) = idx(lLarge)
            idx(lLarge) = lTmp
            lSmall = lSmall + 1
            lLarge = lLarge - 1
        End If
    Loop

    If lStart <= lLarge Then
        Call BinarySortIndexText(sCaptions(), lStart, lLarge, idx, ndOrder, ndCompare)
    End If
    If lSmall <= lEnd Then
        Call BinarySortIndexText(sCaptions(), lSmall, lEnd, idx, ndOrder, ndCompare)
    End If
End Sub

Private Sub DeleteNodeControls(bClearIndex As Boolean)
'PT Delete all controls linked to this node

    On Error GoTo errH

    With moTree.TreeControl.Controls
        If Not mctlControl Is Nothing Then
            .Remove mctlControl.Name
            Set mctlControl = Nothing
            If Not mctlHLine Is Nothing Then
                .Remove mctlHLine.Name
                Set mctlHLine = Nothing
            End If
            If Not mctlIcon Is Nothing Then
                .Remove mctlIcon.Name
                Set mctlIcon = Nothing
            End If
            If Not mctlIcon Is Nothing Then
                .Remove mctlIcon.Name
                Set mctlIcon = Nothing
            End If
        End If

        If Not mctlExpander Is Nothing Then
            .Remove mctlExpander.Name
            Set mctlExpander = Nothing
        End If
        If Not mctlExpanderBox Is Nothing Then
            .Remove mctlExpanderBox.Name
            Set mctlExpanderBox = Nothing
        End If
        If Not mctlVLine Is Nothing Then
            .Remove mctlVLine.Name
            Set mctlVLine = Nothing
        End If


        If Not moEditBox Is Nothing Then
            .Remove moEditBox.Name
            Set moEditBox = Nothing
        End If
        If Not mctlCheckBox Is Nothing Then
            .Remove mctlCheckBox.Name
            Set mctlCheckBox = Nothing
        End If

        If Not Me.ParentNode Is Nothing Then
            ' if Me is the last child delete parent's expander and VLine (if it has one)
            If FirstSibling Is LastSibling Then

                If Not Me.ParentNode.VLine Is Nothing Then
                    .Remove Me.ParentNode.VLine.Name
                    Set Me.ParentNode.VLine = Nothing
                End If
                
                If Not Me.ParentNode.ExpanderBox Is Nothing Then
                    .Remove Me.ParentNode.ExpanderBox.Name
                    Set Me.ParentNode.ExpanderBox = Nothing
                End If

                If Not Me.ParentNode.Expander Is Nothing Then
                    .Remove Me.ParentNode.Expander.Name
                    Set Me.ParentNode.Expander = Nothing
                End If

                Me.ParentNode.Expanded = False

            End If

        End If

    End With

    If bClearIndex Then
        Me.Index = -1  ' flag this node to be removed from mcolNodes in NodeRemove
    End If

    Exit Sub
errH:
    ' Stop
    Resume Next
End Sub

Private Function UpdateCheckbox()
Dim pic As StdPicture
    If Not mctlCheckBox Is Nothing Then
        With mctlCheckBox
            If moTree.GetCheckboxIcon(mlChecked, pic) Then
                .Picture = pic
            Else
                .Caption = IIf(mlChecked, "a", "")
                If (mlChecked = 1) <> (.ForeColor = RGB(180, 180, 180)) Then
                    .ForeColor = IIf(mlChecked = 1, RGB(180, 180, 180), vbWindowText)
                End If
            End If
        End With
    End If
End Function

Private Sub UpdateExpanded(bControlOnly As Boolean)
'-------------------------------------------------------------------------
' Procedure : UpdateExpanded
' Author    : Peter Thornton
' Created   : 27-01-2013
' Purpose   : Called via an Expander click or arrow keys
'             Updates the Expanded property and changes +/- caption
'-------------------------------------------------------------------------
    Dim bFullWidth As Boolean
    Dim vKey
    Dim pic As StdPicture

    If Not bControlOnly Then
        With Me.Expander
            If moTree.GetExpanderIcon(mbExpanded, pic) Then
                .Picture = pic
            Else
                If mbExpanded Then
                    .Caption = "-"
                Else
                    .Caption = "+"
                End If
            End If
        End With
    End If

    On Error GoTo errExit
    If Me.hasIcon(vKey) Then
        If moTree.GetNodeIcon(vKey, pic, bFullWidth) Then
            If bFullWidth Then
                Me.Icon.Picture = pic   ' potential error if Icon is nothing, let error abort
            Else
                Me.Control.Picture = pic
            End If
        End If
    End If
errExit:
End Sub


'***********************
'*   Node Events       *
'***********************

Private Sub mctlCheckBox_Click()    ' PT new in 006PT2
'-------------------------------------------------------------------------
' Procedure : moCtl_Click
' Author    : Peter Thornton
' Created   : 20-01-2013
' Purpose   : Event fires when a Checkbox label is clicked
'-------------------------------------------------------------------------
    If moTree.EditMode(Me) Then
        ' exit editmode if in editmode
        moTree.EditMode(Me) = False
    End If
    If mlChecked = 0 Then
    
        Checked = -1
    Else
        Checked = 0
    End If
    
    Set moTree.ActiveNode = Me
    moTree.NodeClick mctlCheckBox, Me    ' share the checkbox click event
End Sub

Private Sub mctlControl_Click()
'-------------------------------------------------------------------------
' Procedure : mctlControl_Click
' Company   : JKP Application Development Services (c)
' Author    : Jan Karel Pieterse (www.jkp-ads.com)
' Created   : 15-01-2013
' Purpose   : Event fires when a treebranch is clicked
'-------------------------------------------------------------------------

' PT the call to NodeClick will raise the click event to the form
Dim bFlag As Boolean

    If Not moLastActiveNode Is Nothing Then
        moLastActiveNode.Control.BorderStyle = MSForms.fmBorderStyleNone
        Set moLastActiveNode = Nothing
        bFlag = True
    End If

    If moTree.ActiveNode Is Nothing Then
        Set moTree.ActiveNode = Me
        bFlag = True
    ElseIf Not bFlag Then
        bFlag = mctlControl.BorderStyle <> MSForms.fmBorderStyleNone
    End If
    
    If Not moTree.ActiveNode Is Me Or bFlag Then
        ' only raise the event the first time the node is activated
        'moTree.NodeClick Control, Me XXXXX
         
         ' if preferred the click event is always raised to the form (even if the
         ' node was previously active) simply comment or remove this If/EndIf check
    End If

End Sub

Private Sub mctlControl_DblClick(ByVal cancel As MSForms.ReturnBoolean)
' PT  a node label has been double-clicked, enter edit-mode if manual editing is enabled
    Dim bDummy As Boolean

        If moTree.EnableLabelEdit(bDummy) Then
            moTree.EditMode(Me) = True
            EditBox bEnterEdit:=True
        End If
        Me.Tree.mynodepicker.mTree_DblClick
End Sub

Private Sub mctlControl_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
'PT temporarily activate and highlight the MouseDown node and a grey border to the previous activenode
'   MouseUp and Click events will confirm the action or reset the previous active node
Dim bFlag As Boolean

    If moTree.ActiveNode Is Me Then
        bFlag = Me.Control.BackColor = vbHighlight
       ' bFlag = bFlag Or Me.Control.BorderStyle = fmBorderStyleSingle ' in Access this should be uncommented
    End If
    
    If Not bFlag Then
        Set moLastActiveNode = moTree.ActiveNode
        Set moTree.ActiveNode = Me
        If Not moLastActiveNode Is Nothing Then
            moLastActiveNode.Control.BorderStyle = MSForms.fmBorderStyleSingle
            moLastActiveNode.Control.BorderColor = RGB(200, 200, 200)
        End If
    End If

    If moTree.EditMode(Me) Then
        ' if any node is in edit mode exit edit mode
        moTree.EditMode(Me) = False
    End If

End Sub

Private Sub mctlControl_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
' PT MouseUp fires before the Click event, at this point we don't know 100% if user
'    definately wants to activate the MouseDown node. If user drags the mouse off the MouseDown node the
'    Click event will not fire which means user wants to cancel and revert to the previous activenode.
'
'    If MouseUp occurs with the cursor not over the node reset the original activenode

Dim bFlag As Boolean
Dim bMouseIsOver As Boolean
Dim bMoveCopy As Boolean

    If Not moLastActiveNode Is Nothing Then
        With Me.Control
            ' is the mouse over the node or within a pixel of it
            bMouseIsOver = (X >= -1 And X <= .Width + 1) And (Y >= -1 And Y <= .Height + 1)
        End With
        
        If Not bMouseIsOver Then
            ' if the last-activenode was marked for MoveCopy we will need to reset it
            bFlag = moLastActiveNode Is moTree.MoveCopyNode(bMoveCopy)

            ' reset the original activenode
            moLastActiveNode.Control.BorderStyle = MSForms.fmBorderStyleNone
            Set moTree.ActiveNode = moLastActiveNode

            If bFlag Then
                Set moTree.MoveCopyNode(bMoveCopy) = moLastActiveNode
            End If

            Set moLastActiveNode = Nothing
            
        ElseIf Button = 2 Then
            ' the click event doesn't fire with right click so explicitly call it
            mctlControl_Click
        End If
    End If

End Sub

Private Sub mctlExpander_Click()
'
    Expanded = Not Expanded
    If moTree.EditMode(Me) Then
        ' if any node is in edit mode exit edit mode
        moTree.EditMode(Me) = False
    End If
    Tree.NodeClick Expander, Me
End Sub

Private Sub moEditBox_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)    'PT
' PT Textbox key events to Enter or Esc the Editbox,   006PT2

    Dim bCancel As Boolean
    Dim bSort As Boolean
    Dim sNewText As String

    If KeyCode = vbKeyReturn Then
        sNewText = moEditBox.Value
        If sNewText = Caption Then
            KeyCode = vbKeyEscape
        Else
            bCancel = moTree.RaiseAfterLabelEdit(Me, sNewText)
            If Not bCancel Then
                Me.Caption = moEditBox.Value
                Control.Caption = sNewText

                Control.AutoSize = True
                TextWidth = Control.Width
                Control.AutoSize = False
                If TextWidth < mcFullWidth And moTree.FullWidth Then
                    Control.Width = mcFullWidth
                End If
                moTree.Changed = True
                moTree.NodeClick Control, Me
                bCancel = moTree.LabelEdit(bSort)
                If bSort Then
                    If Me.ParentNode.Sort Then
                        moTree.Refresh
                    End If
                End If
            End If
            EditBox False
        End If
    End If
    If KeyCode = vbKeyEscape Then
        moTree.EditMode(Me) = False
        EditBox False
    End If
End Sub

Private Sub Class_Initialize()
' default properties
    mbExpanded = True  ' default
    
    #If DebugMode = 1 Then
        gClsNodeInit = gClsNodeInit + 1    ' PT, for testing only, remove, see ClassCounts() in the normal module
    #End If
End Sub

Private Sub Class_Terminate()
    #If DebugMode = 1 Then
        gClsNodeTerm = gClsNodeTerm + 1    ' PT, for testing,
    #End If
    Set moTree = Nothing
End Sub
Attribute VB_Name = "clsTreeView"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'Build 024
'***************************************************************************
'
' Authors:  JKP Application Development Services, info@jkp-ads.com, http://www.jkp-ads.com
'           Peter Thornton, pmbthornton@gmail.com
'
' (c)2013, all rights reserved to the authors
'
' You are free to use and adapt the code in these modules for
' your own purposes and to distribute as part of your overall project.
' However all headers and copyright notices should remain intact
'
' You may not publish the code in these modules, for example on a web site,
' without the explicit consent of the authors
'***************************************************************************

'-------------------------------------------------------------------------
' Module    : clsTreeView
' Company   : JKP Application Development Services (c)
' Author    : Jan Karel Pieterse (www.jkp-ads.com)
' Created   : 15-01-2013
' Purpose   : Creates a VBA Treeview control in a frame on your UserForm
'-------------------------------------------------------------------------
Option Explicit
#Const HostProject = "Excel" ', or Access or Word

Public WithEvents TreeControl As MSForms.Frame
Attribute TreeControl.VB_VarHelpID = -1

Private mbInActive                  'PT the treeview is not in focus
Private mbAlwaysRedesign As Boolean    'PT temporary flag to force mbRedesign=true, see Move()
Private mbAutoSort As Boolean       'PT sort siblings after manual edit
Private mbChanged As Boolean        'PT "dirty", user has edited node(s)
Private mbCheckboxes As Boolean     'PT show checkboxes
Private mbLabelEdit As Boolean      'PT allow manual editing with F2 and double click
Private mbTriState As Boolean       'PT enable tripple state checkboxes
Private mbCheckboxImage As Boolean  'PT determins if icons are used for checkboxes
Private mbEditMode As Boolean       'PT flag if in editmode
Private mbFullWidth As Boolean      'PT use separate image controls for icons, can highlight nodes to full width
Private mbGotIcons As Boolean       'PT got a collection of images
Private mbExpanderImage As Boolean  'PT determines if icons will be used for collapse/expand controls
Private mbKeyDown As Boolean        'PT Enter-keyup in a Textbox occurs when next control gets focus
Private mbMove As Boolean           'PT flag intention of the MoveCopyNode
Private mbRedesign As Boolean       'PT flag to reset all dim's after changing NodeHeight or Indentation at runtime
Private mbRootButton As Boolean     'PT Root has an expander button
Private mbShowExpanders As Boolean  'PT Show +/- buttons
Private mbShowLines As Boolean      'PT determines if lines will be created and shown
Private mlBackColor As Long         'PT frameholder's backcolor
Private mlForeColor As Long         'PT frameholder's ForeColor
Private mlLabelEdit As Long         'PT 0-Automatic, 1-Manual can't be edited
Private mlNodesCreated As Long      'PT in/de-cremented as nodes are added/deleted from mcolNodes
Private mlNodesDeleted As Long      'PT incremented as node.controls are deleted, purpose to give unique id for control names
Private mlVisCount As Long          'PT incremented from zero as each node is displayed
Private mlVisOrder() As Long        'PT an index array to identify displayed nodes in the order as displayed
Private msAppName As String         'JKP: Title of messageboxes
Private msngChkBoxPad As Single     'PT offset if using checkboxes
Private msngChkBoxSize As Single    'PT checkbox size
Private msngIndent As Single        'PT default 15
Private msngLineLeft As Single      'PT Left pos of Root H & V lines, 3 + alpha
Private msngNodeHeight As Single    'JKP: vertical distance between nodes
Private msngRootLine As Single      'PT if mbRootButton, same as msngIndent, else 0
Private msngTopChk As Single        'PT top checkbox  (these "tops" are offsets down from the top a given node)
Private msngTopExpB As Single       'PT top expander button (a label)
Private msngTopExpT As Single       'PT top expander text (a label)
Private msngTopHV As Single         'PT top for Horiz' & Vert' lines (mid height of a node + top padding))
Private msngTopIcon As Single       'PT top icon
Private msngTopLabel As Single      'PT top node label, if font height less than NodeHeight
Private msngVisTop As Single        'PT activenode top relative to scroll-top
Private msngMaxWidths() As Single   'PT array, max width of text in each level, helps determine scroll-width
Private moActiveNode As clsNode     'JKP: refers to the selected node
Private moEditNode As clsNode       'PT the node in EditMode
Private moMoveNode As clsNode       'PT node waiting to be moved
Private moRootHolder As clsNode     'PT parent for the root node(s), although a clsNode it's not a real node
Private mcolIcons As Collection     'PT collection of stdPicture objects, their names as keys
Private mcolNodes As Collection     'JKP: global collection of all the nodes
Private moCheckboxImage(-1 To 1) As StdPicture   'PT checkbox true/false/triState icons
Private moExpanderImage(-1 To 0) As StdPicture   'PT collapse/expand icons
#If HostProject = "Access" Then
  Private moForm As Access.Form     'PT the main form, eg to return debug stats to the caption
#Else
  Private moForm As MSForms.UserForm
#End If
''-----------------------------------------------------------

'Public Enum tvMouse
'    tvDown = 1
'    tvUp = 2
'    tvMove = 3
'    tvBeforeDragOver = 4
'    tvBeforeDropOrPaste = 5
'End Enum

Public Enum tvTreeRelationship
    tvFirst = 0
    tvLast = 1
    tvNext = 2
    tvPrevious = 3
    tvChild = 4
End Enum

Event Click(cNode As clsNode)       'Node clcick event
Event NodeCheck(cNode As clsNode)   'Checkbox change event
Event AfterLabelEdit(ByRef cancel As Boolean, NewString As String, cNode As clsNode)
Event KeyDown(cNode As clsNode, ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
                    
Private Type POINTAPI
    X As Long
    Y As Long
End Type

#If VBA7 Then
    Private Declare PtrSafe Function GetCursorPos Lib "user32.dll" ( _
            ByRef lpPoint As POINTAPI) As Long
    Private Declare PtrSafe Function SetCursorPos Lib "user32.dll" ( _
            ByVal X As Long, _
            ByVal Y As Long) As Long
    Private Declare PtrSafe Function getTickCount Lib "kernel32.dll" Alias "GetTickCount" () As Long
#Else
    Private Declare Function GetCursorPos Lib "user32.dll" ( _
                                          ByRef lpPoint As POINTAPI) As Long
    Private Declare Function SetCursorPos Lib "user32.dll" ( _
                                          ByVal X As Long, _
                                          ByVal Y As Long) As Long
    Private Declare Function getTickCount Lib "kernel32.dll" Alias "GetTickCount" () As Long
#End If

' Mac displays at 72 pixels per 72 points vs (typically) 96/72 in Windows
' The respective constants help size and position node controls appropriatelly in the different OS
' Search the project for instances of the Mac constant

#If Mac Then
    Const mcCheckboxFont As Long = 13
    Const mcCheckboxPad As Single = 19
    Const mcCheckboxPadImg As Single = 15
    Const mcChkBoxSize As Single = 13
    Const mcExpanderFont As Long = 13
    Const mcExpButSize As Single = 15
    Const mcExpBoxSize As Long = 12
    Const mcFullWidth As Long = 800
    Const mcIconPad As Single = 17
    Const mcIconSize As Long = 16
    Const mcTLpad As Long = 4
    Const mcLineLeft As Single = mcTLpad + 10
    Const mcPtPxl As Single = 1
#Else
    Const mcCheckboxFont As Long = 10
    Const mcCheckboxPad As Single = 15
    Const mcCheckboxPadImg As Single = 11.25
    Const mcChkBoxSize As Single = 10.5
    Const mcExpanderFont As Long = 10
    Const mcExpButSize As Single = 11.25
    Const mcExpBoxSize As Long = 9
    Const mcFullWidth As Long = 600
    Const mcIconPad As Single = 14.25
    Const mcIconSize As Long = 12
    Const mcTLpad As Long = 3
    Const mcLineLeft As Single = mcTLpad + 7.5
    Const mcPtPxl As Single = 0.75
#End If

Private Const mcSource As String = "clsTreeView"
Private mForm As STEPNodePicker

Public Property Set mynodepicker(fm As STEPNodePicker)
    Set mForm = fm
End Property

Public Property Get mynodepicker() As STEPNodePicker
    Set mynodepicker = mForm
End Property

'***************************
'*    Public Properties    *
'***************************

Public Property Get ActiveNode() As clsNode
    Set ActiveNode = moActiveNode
End Property

Public Property Set ActiveNode(oActiveNode As clsNode)
'-------------------------------------------------------------------------
' Procedure : ActiveNode
' Company   : JKP Application Development Services (c)
' Author    : Jan Karel Pieterse (www.jkp-ads.com)
' Created   : 17-01-2013
' Purpose   : Setting the activenode also updates the node colors
'             and ensures the node is scrolled into view
'-------------------------------------------------------------------------

    Dim cTmp As clsNode
    If oActiveNode Is MoveCopyNode(False) Then
        Set MoveCopyNode(False) = Nothing
    End If

    If moActiveNode Is oActiveNode Then
        SetActiveNodeColor
        Exit Property
    End If
    
    ResetActiveNodeColor ActiveNode

    If oActiveNode.Control Is Nothing Then
        Set cTmp = oActiveNode.ParentNode
        While Not cTmp.Caption = "RootHolder"
            cTmp.Expanded = True
            Set cTmp = cTmp.ParentNode
        Wend

        If mlNodesCreated Then
            BuildRoot False
        End If

    End If

    Set moActiveNode = oActiveNode
    SetActiveNodeColor

End Property

Public Sub ExpandNode(cNode As clsNode)
    Dim cTmp As clsNode

    Set cTmp = cNode.ParentNode
    While Not cTmp.Caption = "RootHolder"
        cTmp.Expanded = True
    Wend
    
End Sub

Public Property Get AppName() As String
    AppName = msAppName
End Property

Public Property Let AppName(ByVal sAppName As String)
    msAppName = sAppName
End Property

Public Property Get Changed() As Boolean
'PT user has edited node(s) and/or changed Checked value(s)
    Changed = mbChanged
End Property

Public Property Let Changed(ByVal bChanged As Boolean)
' called after manual edit and Checked change
    Dim sngChangedRight As Single
    Dim sngIconPad As Single
    Dim pic As StdPicture
    Dim v
    
    mbChanged = bChanged
    If Not ActiveNode Is Nothing Then
    
        sngChangedRight = ActiveNode.Control.Left + ActiveNode.TextWidth + 15
        
        If mbFullWidth Then
            If ActiveNode.hasIcon(v) Then
                sngIconPad = mcIconPad
            End If
        End If
        
        If ActiveNode.TextWidth + sngIconPad > msngMaxWidths(ActiveNode.level) Then
            msngMaxWidths(ActiveNode.level) = ActiveNode.TextWidth + sngIconPad
        End If
        
        With Me.TreeControl

            If MaxNodeWidth > .InsideWidth Then

                If .ScrollBars > MSForms.fmScrollBarsHorizontal Then
                    .ScrollBars = MSForms.fmScrollBarsBoth
                Else
                    .ScrollBars = MSForms.fmScrollBarsHorizontal
                End If
                
                .ScrollWidth = MaxNodeWidth + mcTLpad
                
                If .ScrollLeft + .InsideWidth < sngChangedRight Then
                    .ScrollLeft = sngChangedRight - .InsideWidth + mcTLpad
                End If
                
            End If
        End With
    End If

End Property

Public Property Get CheckBoxes(Optional bTriState As Boolean) As Boolean    ' PT
    CheckBoxes = mbCheckboxes
    bTriState = mbTriState
End Property

Public Property Let CheckBoxes(Optional bTriState As Boolean, ByVal bCheckboxes As Boolean)   ' PT
    Dim bOrig As Boolean
    Dim bOrigTriState As Boolean

    bOrig = mbCheckboxes
    mbCheckboxes = bCheckboxes

    bOrigTriState = mbTriState
    mbTriState = bTriState
    If bCheckboxes Then
        msngChkBoxPad = mcCheckboxPad
        If msngNodeHeight < mcExpButSize Then msngNodeHeight = mcExpButSize
    Else
        msngChkBoxPad = 0
    End If

    If Not TreeControl Is Nothing Then

        If TreeControl.Controls.Count And (bOrig <> mbCheckboxes Or bOrigTriState <> mbTriState) Then
            ' Checkboxes added changed after start-up so update the treeview
            mbRedesign = True
            Refresh
        End If
    End If

End Property

#If HostProject = "Access" Then
    Public Property Set Form(frm As Access.Form)
        Set moForm = frm
    End Property
#Else
    Public Property Set Form(frm As MSForms.UserForm)
        Set moForm = frm
    End Property
#End If

Public Property Get FullWidth() As Boolean
    FullWidth = mbFullWidth
End Property

Public Property Let FullWidth(bFullWidth As Boolean)
    mbFullWidth = bFullWidth
End Property

Public Property Set Images(objImages As Object)
    Dim sDesc As String
    Dim pic As stdole.StdPicture
    Dim obj As Object
    ' PT  objImages can be a collection of StdPicture objects
    '     a Frame containing only Image controls (or controls with an image handle)
    '     stdole.IPictureDisp or stdole.StdPicture  objects
    
    On Error GoTo errH
    If TypeName(objImages) = "Collection" Then
        Set mcolIcons = objImages
100     For Each pic In mcolIcons
            ' if not a valid picture let the error abort
        Next
    Else
        Set mcolIcons = New Collection

        '#If HostProject = "Access" Then
            '' if the frame is on an Access form include .Object
            'For Each obj In objImages.Object.Controls

200         For Each obj In objImages.Controls
                mcolIcons.Add obj.Picture, obj.Name
            Next
    End If

    ' Flag we have a valid collection of images
    mbGotIcons = mcolIcons.Count >= 1
    
    Exit Property
errH:
    Set mcolIcons = Nothing
    If Erl = 100 Then
        sDesc = "The obImages collection includes an invalue StdPicture object"
    ElseIf Erl = 200 Then
        sDesc = "A control in objImages does not contain a valid Picture object"
    End If
    sDesc = sDesc & vbNewLine & err.Description
        
    err.Raise err.Number, "Images", sDesc

End Property

Public Property Get Indentation() As Single
    Indentation = msngIndent
End Property

Public Property Let Indentation(sngIndent As Single)
    Dim cNode As clsNode
    Dim sngOld As Single

    sngOld = msngIndent

    #If Mac Then
        If sngIndent < 16 Then
            msngIndent = 16    ' min indent ?
        ElseIf sngIndent > 80 Then
            msngIndent = 80    ' max indent
        Else
            msngIndent = Int(sngIndent)
        End If
    #Else
        If sngIndent < 12 Then
            msngIndent = 12    ' min indent ?
        ElseIf sngIndent > 60 Then
            msngIndent = 60    ' max indent
        Else
            msngIndent = Int((sngIndent * 2 + mcPtPxl) / 3 * 2) * mcPtPxl
        End If
    #End If

    If mbRootButton Then msngRootLine = msngIndent

    If Not TreeControl Is Nothing And Not (sngOld = msngIndent) Then
        ' changed after start-up so update the treview
        If TreeControl.Controls.Count Then
            Set cNode = Me.ActiveNode
            Refresh
            If Not cNode Is Nothing Then
                Set ActiveNode = cNode
            End If
        End If
    End If
End Property
Public Property Get EnableLabelEdit(Optional bAutoSort As Boolean) As Boolean
    EnableLabelEdit = mbLabelEdit
    bAutoSort = mbAutoSort
End Property

Public Property Let EnableLabelEdit(Optional bAutoSort As Boolean, ByVal bLabelEdit As Boolean)    ' PT
' optional bAutoSort: automatically resort siblings after a manual edit
    mbLabelEdit = bLabelEdit
    mbAutoSort = bAutoSort
End Property

Public Property Get LabelEdit(Optional bAutoSort As Boolean) As Long    ' PT
' PT,  equivalent to Treeview.LabelEdit
' 0/tvwAutomatic nodes can be manually edited
' optional bAutoSort: automatically resort siblings after a manual edit

    LabelEdit = mlLabelEdit
    bAutoSort = mbAutoSort
End Property

Public Property Let LabelEdit(Optional bAutoSort As Boolean, ByVal nLabelEdit As Long)    ' PT
    mlLabelEdit = nLabelEdit
    mbLabelEdit = (nLabelEdit = 0)
    mbAutoSort = bAutoSort
End Property

Public Property Get MoveCopyNode(Optional bMove As Boolean, Optional lColor As Long) As clsNode
    bMove = mbMove
    Set MoveCopyNode = moMoveNode
End Property
Public Property Set MoveCopyNode(Optional bMove As Boolean, Optional lColor As Long, cNode As clsNode)
    Static lOrigBackcolor As Long

    mbMove = bMove
    If lColor = 0 Then
        If bMove Then
            lColor = RGB(255, 231, 162)
        Else: lColor = RGB(159, 249, 174)
        End If
    End If

    If Not moMoveNode Is Nothing Then
        moMoveNode.BackColor = lOrigBackcolor
        moMoveNode.Control.BackColor = lOrigBackcolor
        Set moMoveNode = Nothing
    Else

    End If

    If Not cNode Is Nothing Then
        lOrigBackcolor = cNode.BackColor
        If lOrigBackcolor = 0 Then lOrigBackcolor = mlBackColor
        cNode.BackColor = lColor

        cNode.Control.BackColor = cNode.BackColor
        cNode.Control.ForeColor = cNode.ForeColor
        Set moMoveNode = cNode
    Else

    End If
End Property

'Public Property Get MultiSelect() As Boolean
'    MultiSelect = mbMultiSelect
'End Property
'Public Property Let MultiSelect(mbMultiSelect As Boolean)
'    mbMultiSelect = MultiSelect
'End Property

Public Property Get NodeHeight() As Single
    If msngNodeHeight = 0 Then msngNodeHeight = 12
    NodeHeight = msngNodeHeight
End Property

Public Property Let NodeHeight(ByVal sngNodeHeight As Single)
    Dim cNode As clsNode
    Dim sngOld As Single

    sngOld = msngNodeHeight

    #If Mac Then
        If sngNodeHeight < 12 Then  ' height of expander-box is 9
            msngNodeHeight = 12
        ElseIf sngNodeHeight > 60 Then
            msngNodeHeight = 60
        Else
            msngNodeHeight = Int(sngNodeHeight)
        End If
    #Else
        If sngNodeHeight < 9 Then  ' height of expander-box is 9
            msngNodeHeight = 9
        ElseIf sngNodeHeight > 45 Then
            msngNodeHeight = 45
        Else
            msngNodeHeight = Int((sngNodeHeight * 2 + mcPtPxl) / 3 * 2) * mcPtPxl
        End If

    #End If
    If mbRootButton Then msngRootLine = msngIndent
    If Not TreeControl Is Nothing And Not (sngOld = msngNodeHeight) Then
        If TreeControl.Controls.Count Then
            Set cNode = Me.ActiveNode
            Refresh
            If Not cNode Is Nothing Then
                Set ActiveNode = cNode
            End If
        End If
    End If
End Property

Public Property Get Nodes() As Collection
' Global collection of the nodes
' *DO NOT USE* its Nodes.Add and Nodes.Remove methods
' To add & remove nodes use clsNode.AddChild() or clsTreeView.NodeAdd and clsTeevView.NodeRemove()
    If mcolNodes Is Nothing Then Set mcolNodes = New Collection
    Set Nodes = mcolNodes
End Property

Public Property Get RootButton() As Boolean
    If mbRootButton Then RootButton = 1
End Property

Public Property Let RootButton(lRootLeader As Boolean)
' PT The Root nodes have expanders and lines (if mbShowlines)

    mbRootButton = lRootLeader
    If mbRootButton Then
        msngRootLine = msngIndent
    Else
        msngRootLine = 0
    End If

    If Not Me.TreeControl Is Nothing Then
        If Not moRootHolder Is Nothing Then
            If Not moRootHolder.ChildNodes Is Nothing Then
                Refresh
            End If
        End If
    End If
End Property

Public Property Get RootNodes() As Collection
'PT returns the collection of Root-nodes
' **should be treated as read only. Use AddRoot and NodeRemove to add/remove a root node**
    Set RootNodes = moRootHolder.ChildNodes
End Property

Public Property Get ShowExpanders() As Boolean
    ShowExpanders = mbShowExpanders
End Property

Public Property Let ShowExpanders(bShowExpanders As Boolean)

    mbShowExpanders = bShowExpanders
    
    If Not TreeControl Is Nothing Then
        If TreeControl.Controls.Count Then
            Refresh
        End If
    End If
End Property

Public Property Get ShowLines() As Boolean
    ShowLines = mbShowLines
End Property

Public Property Let ShowLines(bShowLines As Boolean)
' PT Show horizontal & vertical lines
Dim bOrig As Boolean
Dim cNode As clsNode

    bOrig = mbShowLines
    mbShowLines = bShowLines

    If Not TreeControl Is Nothing Then
        If TreeControl.Controls.Count Then
            If bOrig <> mbShowLines Then
                ' ShowLines added after start-up so update the treeview
                Refresh
            End If
        End If
    End If

End Property

'***********************************
'*    Public functions and subs    *
'***********************************

Public Function AddRoot(Optional sKey As String, Optional vCaption, Optional vImageMain, Optional vImageExpanded) As clsNode

    On Error GoTo errH

    If moRootHolder Is Nothing Then
        Set moRootHolder = New clsNode
        Set moRootHolder.ChildNodes = New Collection
        Set moRootHolder.Tree = Me
        moRootHolder.Caption = "RootHolder"
        If mcolNodes Is Nothing Then
            Set mcolNodes = New Collection
        End If
    End If

    Set AddRoot = moRootHolder.AddChild(sKey, vCaption, vImageMain, vImageExpanded)

    Exit Function
errH:
    #If DebugMode = 1 Then
        Stop
        Resume
    #End If
    err.Raise err.Number, "AddRoot", err.Description

End Function

Public Sub CheckboxImage(picFalse As StdPicture, picTrue As StdPicture, Optional picTriState As StdPicture)
    On Error GoTo errExit:
    Set moCheckboxImage(0) = picFalse
    Set moCheckboxImage(-1) = picTrue
    If Not IsMissing(picTriState) Then
        Set moCheckboxImage(1) = picTriState
    End If

    mbCheckboxImage = True
errExit:
End Sub

Public Sub EnterExit(bExit As Boolean)
'PT WithEvents can't trap Enter/Exit events, if we need them here they can be
'   called from the TreeControl's Enter/Exit events in the form
    mbInActive = bExit
    SetActiveNodeColor bExit ' apply appropriate vbInactiveCaptionText / vbHighlight

End Sub

Public Sub ExpanderImage(picMinus As StdPicture, picPlus As StdPicture)
    On Error GoTo errExit:
    Set moExpanderImage(0) = picPlus
    Set moExpanderImage(-1) = picMinus
    mbExpanderImage = True
errExit:
End Sub

Public Sub ExpandToLevel(lExpansionLevel As Long, Optional bReActivate As Boolean = True)
' PT call SetTreeExpansionLevel and reactivates the closest expanded parent if necessary
'    eg, if activeNode.level = 4 and lExpansionLevel = 2, the activenode's grandparent will be activated
    Dim cTmp As clsNode

    Call SetTreeExpansionLevel(lExpansionLevel - 1)

    If bReActivate Then
        If ActiveNode.level > lExpansionLevel Then
            Set cTmp = ActiveNode.ParentNode
            While cTmp.level > lExpansionLevel
                Set cTmp = cTmp.ParentNode
            Wend
            Set ActiveNode = cTmp
        End If
    End If
    
End Sub

Public Sub Copy(cSource As clsNode, cDest As clsNode, _
                Optional vBefore, Optional ByVal vAfter, _
                Optional ByVal bShowError As Boolean)
                
    Set MoveCopyNode(False) = Nothing
    Clone cDest, cSource, vBefore, vAfter
    SetActiveNodeColor
    
End Sub

Public Sub Move(cSource As clsNode, cDest As clsNode, _
                Optional vBefore, Optional ByVal vAfter, _
                Optional ByVal bShowError As Boolean)
' PT Move source node + children to destination node
'    cannot move the Root and cannot move to a descendant
'   vBefore/vAfter work as for normal collection; error if invalid, eg a new collection, after the last item, etc
'
    Dim sErrDesc As String
    Dim bIsParent As Boolean
    Dim cNode As clsNode
    Dim cSourceParent As clsNode

    Set MoveCopyNode(False) = Nothing
    On Error GoTo errH

    If cSource Is Nothing Or cDest Is Nothing Or cSource Is cDest Then   ' Or cSource Is Root
        Exit Sub
    End If

    Set cNode = cDest
    bIsParent = False
    Do
        Set cNode = cNode.ParentNode
        bIsParent = cNode Is cSource
    Loop Until cNode Is Nothing Or bIsParent

    If bIsParent Then
        err.Raise vbObjectError + 110
    End If

    If cDest.ChildNodes Is Nothing Then
        ' the child becomes a parent for the first time
        Set cDest.ChildNodes = New Collection
        ' expander & VLine will get created automatically if necessary
    End If

    AddNodeToCol cDest.ChildNodes, cSource, False, vBefore, vAfter

    Set cSourceParent = cSource.ParentNode
    With cSourceParent
        .RemoveChild cSource '
        ' if the old parent has no more children remove its expander & VLine

        If .ChildNodes Is Nothing Then

            If Not .Expander Is Nothing Then
                Me.TreeControl.Controls.Remove .Expander.Name
                Set .Expander = Nothing
            End If

            If Not .ExpanderBox Is Nothing Then
                Me.TreeControl.Controls.Remove .ExpanderBox.Name
                Set .ExpanderBox = Nothing
            End If

            If Not .VLine Is Nothing Then
                Me.TreeControl.Controls.Remove .VLine.Name
                Set .VLine = Nothing
            End If

            .Expanded = False

        End If
    End With

    Set cSource.ParentNode = cDest
    cDest.Expanded = True
    
    If mbTriState Then
        cDest.CheckTriStateParent
        cSourceParent.CheckTriStateParent
    End If
    
    SetActiveNodeColor
    mbAlwaysRedesign = True    ' ensure Left's get recalc'd during future refresh

    Exit Sub
errH:

    Select Case err.Number
    Case vbObjectError + 110
        sErrDesc = "Cannot cut and move a Node to a descendant node"
    Case Else
        sErrDesc = "Move: " & err.Description
    End Select

    If bShowError Then
        MsgBox sErrDesc, , AppName
    Else
        err.Raise err.Number, mcSource, "Move: " & sErrDesc
    End If

End Sub

Public Function NodeAdd(Optional vRelative, _
                        Optional vRelationship, _
                        Optional sKey As String, _
                        Optional vCaption, _
                        Optional vImageMain, _
                        Optional vImageExpanded) As clsNode    '  As tvTreevRelationship

'PT, similar to the old tv's nodes.add method
'    main difference is vRelative can be a Node object as well as a key or index
'    see also clsNode.AddChild

    Dim i As Long
    Dim cNode As clsNode
    Dim cRelative As clsNode
    Dim cParent As clsNode
    Dim cTmp As clsNode
    '    tvFirst = 0  tvlast = 1 tvNext = 2 tvprevious = 3  tvChild = 4

    If IsMissing(vRelative) Then

        Set NodeAdd = Me.AddRoot(sKey, vCaption, vImageMain, vImageExpanded)
        Exit Function
    Else

        On Error Resume Next
        Set cRelative = vRelative
        If cRelative Is Nothing Then
            Set cRelative = mcolNodes(vRelative)
        End If

        On Error GoTo errH
        If cRelative Is Nothing Then
            err.Raise vbObjectError + 100, "NodeAdd", "vRelative is not a valid node or a node.key"
        End If
    End If

    If IsMissing(vRelationship) Then
        vRelationship = tvTreeRelationship.tvNext    ' default
    End If

    If vRelationship = tvChild Or cRelative Is cRelative.Root Then
        Set cParent = cRelative
    Else
        Set cParent = cRelative.ParentNode
    End If

    Set cNode = New clsNode

    If Len(sKey) Then
100     mcolNodes.Add cNode, sKey
101
    Else
        mcolNodes.Add cNode
    End If

    If cParent.ChildNodes Is Nothing Then
        Set cParent.ChildNodes = New Collection
    End If

    With cParent.ChildNodes
        If .Count = 0 Then
            .Add cNode
        Else
            i = 0
            If vRelationship = tvNext Or vRelationship = tvPrevious Then
                For Each cTmp In cParent.ChildNodes
                    i = i + 1
                    If cTmp Is cRelative Then
                        Exit For
                    End If
                Next
            End If
            Select Case vRelationship
            Case tvFirst: .Add cNode, , 1
            Case tvLast: .Add cNode, after:=.Count
            Case tvNext: .Add cNode, after:=i
            Case tvPrevious: .Add cNode, before:=i
            Case tvChild: .Add cNode
            End Select
        End If
    End With

    With cNode
        .Key = sKey
        .Caption = CStr(vCaption)
        .ImageMain = vImageMain
        .ImageExpanded = vImageExpanded
        .Index = mcolNodes.Count
        Set .ParentNode = cParent
        Set .Tree = Me
    End With

    Set cNode.Tree = Me    ' do this after let key = skey
    Set NodeAdd = cNode

    Exit Function
errH:
    If mcolNodes Is Nothing Then
        Set mcolNodes = New Collection
        Resume
    End If
    If Erl = 100 And err.Number = 457 Then
        err.Raise vbObjectError + 1, "clsNode.AddChild", "Duplicate key: '" & sKey & "'"
    Else
        #If DebugMode = 1 Then
            Stop
            Resume
        #End If
        err.Raise err.Number, "clsNode.AddChild", err.Description
    End If
End Function

Public Sub NodeRemove(cNode As clsNode)
' PT Remove a Node, its children and grandchildrem
'    remove all associated controls and tear down class objects
'    Call Refresh() when done removing nodes

    Dim lIdx As Long
    Dim lNodeCtlsOrig As Long
    Dim cParent As clsNode
    Dim cNodeAbove As clsNode, cnd As clsNode
    
    On Error GoTo errH

    Set cNodeAbove = NextVisibleNodeInTree(cNode, bUp:=True)
    Set cParent = cNode.ParentNode

    cNode.TerminateNode True

    cParent.RemoveChild cNode
    
    cNode.Index = -1    ' flag to get removed from mcolNodes in the loop
    If ActiveNode Is cNode Then
        Set moActiveNode = Nothing
    End If
    Set moEditNode = Nothing

    lIdx = 0
    lNodeCtlsOrig = mlNodesCreated
    mlNodesCreated = 0
    
    For Each cnd In mcolNodes
        lIdx = lIdx + 1
        If cnd.Index = -1 Then
            mcolNodes.Remove lIdx
            lIdx = lIdx - 1
        Else
            mlNodesCreated = mlNodesCreated - CLng(Not cnd.Control Is Nothing)
            cnd.Index = lIdx
        End If
    Next

    mlNodesDeleted = mlNodesDeleted + lNodeCtlsOrig - mlNodesCreated

    Set cNode = Nothing    ' should terminate the class

    If mlNodesCreated Then
        If Not cNodeAbove Is Nothing Then
            Set Me.ActiveNode = cNodeAbove
        ElseIf mcolNodes.Count Then
            Set Me.ActiveNode = mcolNodes(1)
        End If
    Else
        'all nodes deleted
        Erase mlVisOrder
        Erase msngMaxWidths
        mlVisCount = 0
        mlNodesCreated = 0
        mlNodesDeleted = 0
    End If

    Exit Sub
errH:
    #If DebugMode = 1 Then
        Debug.Print err.Description, err.Number
        Stop
        Resume
    #End If
End Sub

Public Sub NodesClear()
' PT,  similar to Treeview.Nodes.Clear
    Dim i As Long
    On Error GoTo errH

    If Not TreeControl Is Nothing Then
        With TreeControl
            For i = TreeControl.Controls.Count - 1 To 0 Step -1
                TreeControl.Controls.Remove i
            Next
            .ScrollBars = MSForms.fmScrollBarsNone
        End With
    End If
    
    Erase mlVisOrder
    Erase msngMaxWidths
    mlVisCount = 0
    mlNodesCreated = 0
    mlNodesDeleted = 0
    
    TerminateTree

    mbChanged = False

    Exit Sub
errH:
    #If DebugMode = 1 Then
        Stop
        Resume
    #End If
End Sub

Public Sub PopulateTree()
' PT add and displays all the controls for the Treeview for the first time

    MsgBox "In beta-023 PopulateTree() was depricated and merged with Refresh()" & vbNewLine & vbNewLine & _
            "Please replace ''PopulateTree'' with ''Refresh'' in your code", , AppName
    
    Refresh

End Sub

Public Sub Refresh()
' Create node controls as required the first time respective parent's Expanded property = true
' hide or show and (re)position node controls as required
' Call Refresh after changing any Treeview properties or after adding/removing/moving any nodes
' or making any change that will alter placement of nodes in the treeview
    Dim bInit As Boolean

    If Me.TreeControl Is Nothing Then
        TerminateTree
        ' a Frame (container for the treeview) should have been referrenced to me.TreeControl
        err.Raise vbObjectError + 10, mcSource, "Refresh: 'TreeControl' frame is not referenced"
        
    ElseIf moRootHolder Is Nothing Then
        '
        err.Raise vbObjectError + 11, mcSource, "Refresh: No Root nodes have been created"
    ElseIf moRootHolder.ChildNodes Is Nothing Then
        ' nothing to do
        mlVisCount = 0
        mlNodesCreated = 0
        mlNodesDeleted = 0
        Erase mlVisOrder
        Erase msngMaxWidths
        Exit Sub
        
    ElseIf Me.TreeControl.Controls.Count = 0 Then
        ' display the treeview for first time
        bInit = True
    Else
        ' ensure all node properties are checked, eg after changing indentation or nodeheight during runtime
        mbRedesign = True
    End If

    On Error GoTo errExit

    BuildRoot bInit

    Exit Sub

errExit:
    err.Raise err.Number, mcSource, "Error in BuildRoot: " & err.Description
End Sub

Public Sub ScrollToView(Optional cNode As clsNode, _
                        Optional Top1Bottom2 As Long, _
                        Optional bCollapseOthers As Boolean)
' PT scrolls the treeview to position the node in view
' Top1Bottom2= 0 roughly 1/3 from the top
' Top1Bottom2= 1 or -1 at the top
' Top1Bottom2= 2 or -2 at the bottom

    Dim bIsVisible As Boolean
    Dim bWasCollapsed As Boolean
    Dim lVisIndex As Long
    Dim sngTop As Single
    Dim sngBot As Single
    Dim sngVisHt As Single
    Dim sngScrollTop As Single
    Dim cTmp As clsNode

    If cNode Is Nothing Then
        Set cNode = ActiveNode
    End If

    If bCollapseOthers Then
        SetTreeExpansionLevel 0
    End If
    
    Set cTmp = cNode.ParentNode
    While Not cTmp.Caption = "RootHolder"
        If Not cTmp.Expanded Then
            bWasCollapsed = True
            cTmp.Expanded = True
        End If
        Set cTmp = cTmp.ParentNode
    Wend
    
    If bWasCollapsed Then
        BuildRoot False
    End If

    lVisIndex = cNode.VisIndex
    sngBot = mcTLpad + lVisIndex * NodeHeight
    sngTop = sngBot - NodeHeight

    With TreeControl
        sngVisHt = .InsideHeight
        If .ScrollBars = MSForms.fmScrollBarsBoth Or .ScrollBars = MSForms.fmScrollBarsHorizontal Then
            sngVisHt = sngVisHt - 15    ' roughly(?) width of a scrollbar
        End If

        bIsVisible = sngTop > .ScrollTop And _
                     sngBot < .ScrollTop + sngVisHt
        
        If Not bIsVisible Or Top1Bottom2 > 0 Then
        
            If Top1Bottom2 < 0 Then Top1Bottom2 = Top1Bottom2 * -1
            
            If Top1Bottom2 = 0 Then  ' place about 1/3 from top
                sngScrollTop = lVisIndex * NodeHeight - .InsideHeight / 3

            ElseIf Top1Bottom2 = 1 Then  ' scroll to top
                sngScrollTop = sngTop - mcTLpad
            Else
                sngScrollTop = sngBot - sngVisHt + mcTLpad    ' scroll to bottom
            End If

            If sngScrollTop < 0 Then
                sngScrollTop = 0
            End If

            .ScrollTop = sngScrollTop
        End If
    End With
End Sub

Public Sub TerminateTree()
'-------------------------------------------------------------------------
' Procedure : TerminateTree
' Company   : JKP Application Development Services (c)
' Author    : Jan Karel Pieterse (www.jkp-ads.com)
' Created   : 15-01-2013
' Purpose   : Terminates this class' instance
'-------------------------------------------------------------------------
Dim cNode As clsNode
    'Instead of the terminate event of the class
    'we use this public method so it can be
    'explicitly called by parent classes
    'this is done because we'll end up having multiple circular references
    'between parent and child classes, which may cause the terminate events to be ignored.

    If Not moRootHolder Is Nothing Then
        If Not moRootHolder.ChildNodes Is Nothing Then
            For Each cNode In moRootHolder.ChildNodes

                cNode.TerminateNode
            Next
        End If
        moRootHolder.TerminateNode
    End If
    
    Set moMoveNode = Nothing
    Set moEditNode = Nothing
    Set moActiveNode = Nothing
    Set moRootHolder = Nothing
    Set mcolNodes = Nothing
    
    '** by design TerminateTree does NOT reset treeview properties or remove
    '** the reference TreeControl reference to the treeview's Frame control
    '
    '   If the form is being unloaded it's enough to call TerminateTree in it's close event, node controls will automatically unload with the form.
    '   However the treeview is to be cleared or moved but the main form is not being unloaded
    '   call the NodesRemove method which will remove all node controls then call TerminateTree
End Sub

'***********************************************************************************************
'*    Friend properties, functions and subs                                                    *
'*    although visible throughout the project these are only intended to be called by clsNodes *
'***********************************************************************************************

Friend Property Get EditMode(cNode As clsNode) As Boolean  ' PT
    EditMode = mbEditMode
End Property

Friend Property Let EditMode(cNode As clsNode, ByVal bEditMode As Boolean)  ' PT

    Set MoveCopyNode(False) = Nothing
    mbEditMode = bEditMode

    If Not moEditNode Is Nothing Then
        moEditNode.EditBox False
    End If


    If bEditMode Then
        Set moEditNode = cNode
    Else
        Set moEditNode = Nothing
    End If
End Property

Friend Function GetExpanderIcon(bExpanded As Boolean, pic As StdPicture) As Boolean
    If mbExpanderImage Then
        Set pic = moExpanderImage(bExpanded)
        GetExpanderIcon = True
    End If
End Function
Friend Function GetCheckboxIcon(lChecked As Long, pic As StdPicture) As Boolean
    If mbCheckboxImage Then
        Set pic = moCheckboxImage(lChecked)
        GetCheckboxIcon = True
    End If
End Function

Friend Function GetNodeIcon(vKey, pic As StdPicture, bFullWidth As Boolean) As Boolean
    On Error GoTo errExit
    Set pic = mcolIcons(vKey)
    bFullWidth = mbFullWidth
    GetNodeIcon = True
errExit:
End Function

Friend Function RaiseAfterLabelEdit(cNode As clsNode, sNewText As String) As Boolean
' PT called from moEditBox_KeyDown after vbKeyEnter
'
    Dim cancel As Boolean
    RaiseEvent AfterLabelEdit(cancel, sNewText, cNode)
    RaiseAfterLabelEdit = cancel
End Function

Friend Sub NodeClick(ByRef oCtl As MSForms.Control, ByRef cNode As clsNode)
'-------------------------------------------------------------------------
' Procedure : NodeClick
' Company   : JKP Application Development Services (c)
' Author    : Jan Karel Pieterse (www.jkp-ads.com)
' Created   : 15-01-2013
' Purpose   : Handles clicks on the treeview. Called from clsNode
'-------------------------------------------------------------------------

' PT also called from checkbox (label) click event in clsNode
    Dim bFlag As Boolean
    Dim lngViewable As Long
    Dim cLastChild As clsNode

    If oCtl.Name Like "Exp*" Then
        bFlag = Not ActiveNode Is cNode
        If bFlag Then
            Set ActiveNode = cNode
        End If

        BuildRoot False

        If cNode.Expanded Then
            If Not cNode.ChildNodes Is Nothing Then
                If cNode.ChildNodes.Count > 0 Then
                    Set cLastChild = cNode.ChildNodes.Item(cNode.ChildNodes.Count)
                    If Not NodeIsVisible(cLastChild, lngViewable) Then
                        If lngViewable > cNode.ChildNodes.Count Then
                            ScrollToView cLastChild, Top1Bottom2:=2
                        Else
                            ScrollToView cNode, Top1Bottom2:=1
                        End If
                    End If
                End If
            End If
        End If
        If bFlag Then
            RaiseEvent Click(cNode)
        End If
        '------------------------------
        'ONEKING-429 fix: moved call to form load/expand from the end of this sub
        'so that nodes only gets loaded if its actually a "expand-box" that's clicked
        'AVAD
        If Not mForm Is Nothing Then
            Call mForm.mTree_Expand(cNode)
        End If
        '------------------------------
    ElseIf oCtl.Name Like "CheckBox*" Then   ' PT
        ' RaiseEvent for the checkbox moved to clsNode
        RaiseEvent NodeCheck(cNode)

    ElseIf oCtl.Name Like "Node*" Then
        If Not ActiveNode Is cNode Then
            Set ActiveNode = cNode
        Else
            SetActiveNodeColor
        End If
        RaiseEvent Click(cNode)
    End If
End Sub

Friend Function UniqueKey(sKey As String) As String
    Dim cNode As clsNode
    For Each cNode In Nodes
        If cNode.Key = sKey Then
            err.Raise vbObjectError + 1, "clsTreeView", "Duplicate key: '" & sKey & "'"
        End If
    Next
    UniqueKey = sKey
End Function

'************************************
'*    Private functions and subs    *
'************************************

Private Sub Class_Initialize()
' Set Root = New clsNode
' Set moRoot = New clsNode ' maybe(?) but keep Root() as read only

' set some defaults
    mbRootButton = True
    mbShowExpanders = True
    mbShowLines = True
    #If Mac Then
        msngIndent = 20
        msngNodeHeight = 16
    #Else
        msngIndent = 15
        msngNodeHeight = 12
    #End If
    msngRootLine = msngIndent
    msAppName = "TreeView"
    
    #If DebugMode = 1 Then
        gClsTreeViewInit = gClsTreeViewInit + 1    'for testing only
    #End If
    
End Sub

Private Sub Class_Terminate()
    #If DebugMode = 1 Then
        gClsTreeViewTerm = gClsTreeViewTerm + 1
    #End If
End Sub

Private Function AddNodeToCol(colNodes As Collection, cAddNode As clsNode, bTreeCol As Boolean, Optional vBefore, Optional vAfter)
    Dim i As Long
    Dim sKey As String
    Dim cTmp As clsNode
    Dim pos As Long

    If bTreeCol Then sKey = cAddNode.Key

    If Len(sKey) Then
        On Error Resume Next
        i = 0
        Set cTmp = colNodes(sKey)
        If Not cTmp Is Nothing Then
            pos = InStr(1, sKey, "_copy:")
            If pos Then
                sKey = VBA.Left$(sKey, pos - 1)
            End If
            sKey = sKey & "_copy:"
            While Not cTmp Is Nothing
                Set cTmp = Nothing
                i = i + 1
                Set cTmp = colNodes(sKey & i)
            Wend
            sKey = sKey & i

            If bTreeCol Then
                cAddNode.Key = sKey
            End If

        End If

        On Error GoTo 0    ' error returns to caller

        If IsMissing(vBefore) And IsMissing(vAfter) Then
            colNodes.Add cAddNode, sKey
        ElseIf IsMissing(vAfter) Then
            colNodes.Add cAddNode, sKey, vBefore
        Else
            colNodes.Add cAddNode, sKey, , vAfter
        End If

    Else    ' no key
        If IsMissing(vBefore) And IsMissing(vAfter) Then
            colNodes.Add cAddNode
        ElseIf IsMissing(vAfter) Then
            colNodes.Add cAddNode, , vBefore
        Else
            colNodes.Add cAddNode, , , vAfter
        End If
    End If
End Function

'Access part of disabling CTRL+Break for BuildRoot sub
Private Function ChangeProperty(strPropertyName As String, varPropertyType As Variant, varPropertyValue As Variant) As Integer
#If HostProject = "Access" Then
    On Error GoTo Err_ChangeProperty
    Dim MyDB As DAO.Database
    Dim MyProperty As DAO.Property

    Set MyDB = CurrentDb()

    'Property exists, so set its Value
    MyDB.Properties(strPropertyName) = varPropertyValue
    ChangeProperty = True

Exit_ChangeProperty:
    Exit Function

Err_ChangeProperty:
    If err.Number = 3270 Then       'Property not found
        'Since the Property isn't found, create it!
        Set MyProperty = MyDB.CreateProperty(strPropertyName, varPropertyType, varPropertyValue)
        MyDB.Properties.Append MyProperty
        Resume Next
    Else
   'Unknown Error
    ChangeProperty = False
        Resume Exit_ChangeProperty
    End If

  #Else
    Exit Function
  #End If
End Function

Private Sub BuildRoot(bInit As Boolean)
    Dim bCursorWait As Boolean
    Dim bTriStateOrig As Boolean
    Dim lLastRootVisIndex As Long
    Dim sngActiveNodeScrollTop As Single    ' PT distance activenode was from scrolltop top before refresh, if visible
    Dim sngChkBoxPad As Single
    Dim sngHeightAllNodes As Single
    Dim sngIconPad As Single
    Dim sngMaxWidth As Single
    Dim cRoot As clsNode
    Dim objCtrl As MSForms.Control
    Dim pt As POINTAPI
    Dim vIconKey

    Dim sCap As String
    Dim sngTickCnt As Single

    On Error GoTo locErr

    #If DebugMode Then
        #If Win32 Or Win64 Then
            sngTickCnt = getTickCount
        #Else  ' Mac
            sngTickCnt = Timer
        #End If
    #End If

    bInit = TreeControl.Count = 0

    'TODO find equivalent for cancel key in Access & Word
    'Temporary solution - disable special keys for Access & Word to prevent user from getting into the code
    'There are no error handling on Ctrl+break on Word & Access such as xlErrorHandler in Excel, so we just disable_
    '_Ctrl+Break and in the end of sub turn it on. Unfortunately, we can't catch CTRL+Break in Access and Word, so _
    '_it will be better to prevent user from getting into the code. That's the strange Microsoft restrict.

    #If HostProject = "Access" Then
        ChangeProperty "AllowSpecialKeys", dbBoolean, False
    #ElseIf HostProject = "Word" Then
        Application.EnableCancelKey = wdCancelDisabled
    #Else
        Application.EnableCancelKey = xlErrorHandler
    #End If

    If mbAlwaysRedesign Then mbRedesign = True

    '    mcChkBoxSize = 10.5    ' 11.25
    '    mcLineLeft = 3 + 7.5    'msngIndent / 2

    ' PT if these arrays aren't large enough Redim Preserve is done in error handler
    ReDim mlVisOrder(1 To mlNodesCreated + 100)
    If bInit Or mbRedesign Then
        ReDim msngMaxWidths(0 To 7)
    End If

    If mcolNodes.Count - mlNodesCreated > 400 Then
        ' creating many controls might take a while
        #If HostProject = "Access" Then
            Application.DoCmd.Hourglass True
        #ElseIf HostProject = "Word" Then
            System.Cursor = wdCursorWait
        #Else
            Application.Cursor = xlWait
        #End If
        bCursorWait = True
    End If
    If Not bInit Then
        If NodeIsVisible Then
            sngActiveNodeScrollTop = (ActiveNode.VisIndex - 1) * NodeHeight - Me.TreeControl.ScrollTop
        End If
    End If

    mlVisCount = 0
    bTriStateOrig = mbTriState
    mbTriState = False

    If CheckBoxes Then
        If mbCheckboxImage Then
            sngChkBoxPad = mcCheckboxPadImg
        Else
            sngChkBoxPad = mcCheckboxPad
        End If
        If mcChkBoxSize > msngNodeHeight Then
            msngNodeHeight = mcChkBoxSize
        End If
    End If

    ' work out respective offsets to various node controls from node tops
    msngTopExpB = mcTLpad + (msngNodeHeight - mcExpButSize) / 2 + 1.5
    If mbExpanderImage Then
        msngTopExpT = mcTLpad + (msngNodeHeight - (mcExpButSize - 4)) / 2
    Else
        msngTopExpT = mcTLpad + (msngNodeHeight - mcExpButSize) / 2
    End If

    msngTopChk = mcTLpad + (msngNodeHeight - mcChkBoxSize) / 2
    msngTopIcon = mcTLpad + (msngNodeHeight - mcIconSize) / 2
    msngTopHV = mcTLpad + msngNodeHeight / 2
    Call Round75


    With TreeControl
        mlBackColor = .BackColor    ' default colours for node labels
        mlForeColor = .ForeColor

        If bInit Then
            .SpecialEffect = 2    ' fmSpecialEffectSunken
        Else
            ' PT, refresh, start by hiding all the controls
            For Each objCtrl In .Controls
                objCtrl.Visible = False
            Next
        End If


        For Each cRoot In moRootHolder.ChildNodes
            sngIconPad = 0
            If mbFullWidth Then
                If mbGotIcons And cRoot.hasIcon(vIconKey) Then
                    sngIconPad = mcIconPad
                End If
            End If

            If cRoot.Control Is Nothing Then
                mlNodesCreated = mlNodesCreated + 1
                'Add the rootnode to the tree
                Set cRoot.Control = TreeControl.Controls.Add("Forms.label.1", "Node" & mlNodesDeleted + mlNodesCreated, False)
                With cRoot.Control

                    If Not mbFullWidth And mbGotIcons Then
                        If cRoot.hasIcon(vIconKey) Then
                            .PicturePosition = MSForms.fmPicturePositionLeftCenter
                            .Picture = mcolIcons(vIconKey)
                        End If
                    End If

                    .top = mcTLpad + mlVisCount * msngNodeHeight
                    .Left = mcTLpad + msngRootLine + sngIconPad + msngChkBoxPad

                    If cRoot.BackColor Then
                        .BackColor = cRoot.BackColor
                    End If
                    If cRoot.ForeColor Then
                        .ForeColor = cRoot.ForeColor
                    End If

                    If cRoot.Bold Then .Font.Bold = True
                    .Caption = cRoot.Caption
                    .AutoSize = True
                    .WordWrap = False

                    cRoot.TextWidth = .Width

                    If .Width + sngIconPad > msngMaxWidths(0) Then
                        msngMaxWidths(0) = .Width + sngIconPad
                    End If

                    ' calc msngTopLabel to align node label to mid NodeHeight
                    ' first calc min NodeHeight if not set higher by user
                    If .Height > msngNodeHeight Then
                        ' optimal HodeHeight for the current font
                        msngNodeHeight = .Height    ' 'don't use the Property method or Refresh will be called
                    ElseIf .Height < msngNodeHeight Then
                        #If Mac Then
                            msngTopLabel = Int(msngNodeHeight - .Height) / 2
                        #Else
                            msngTopLabel = Int((msngNodeHeight - .Height + mcPtPxl) / 3 * 2) * mcPtPxl
                        #End If
                        .top = mcTLpad + msngTopLabel + mlVisCount * msngNodeHeight
                    End If

                    If mbFullWidth Then
                        If msngTopLabel < mcFullWidth Then
                            .Width = mcFullWidth
                            .AutoSize = False
                        End If
                    End If

                    .WordWrap = False
                    .ZOrder 0
                    .Visible = True

                End With
            Else

                With cRoot.Control

                    If mbRedesign Then
                        .Left = mcTLpad + msngRootLine + sngIconPad + msngChkBoxPad

                        If cRoot.TextWidth + sngIconPad > msngMaxWidths(0) Then
                            msngMaxWidths(0) = cRoot.TextWidth + sngIconPad
                        End If
                    End If

                    If .Height > msngNodeHeight Then
                        msngNodeHeight = .Height
                    ElseIf .Height < msngNodeHeight Then
                        #If Mac Then
                            msngTopLabel = Int(msngNodeHeight - .Height) / 2
                        #Else
                            msngTopLabel = Int((msngNodeHeight - .Height + mcPtPxl) / 3 * 2) * mcPtPxl
                        #End If
                    End If

                    .top = mcTLpad + msngTopLabel + mlVisCount * msngNodeHeight

                    .Visible = True

                End With
            End If

            ' horizontal line
            If mbRootButton And mbShowLines Then
                If cRoot.HLine Is Nothing Then
                    Set cRoot.HLine = TreeControl.Controls.Add("Forms.label.1", "HLine" & cRoot.Control.Name, False)
                    With cRoot.HLine
                        .top = msngTopHV + mlVisCount * msngNodeHeight
                        .Left = mcLineLeft
                        .Caption = ""
                        .BorderStyle = MSForms.fmBorderStyleSingle
                        .BorderColor = vbScrollBars
                        .Width = msngIndent
                        .Height = mcPtPxl
                        .TextAlign = MSForms.fmTextAlignCenter
                        .BackStyle = MSForms.fmBackStyleTransparent
                        .ZOrder 1
                        .Visible = True
                    End With
                Else
                    With cRoot.HLine
                        .Width = msngIndent
                        .top = msngTopHV + mlVisCount * msngNodeHeight  ' 3 + NodeHeight/2 (to nearest 0.75)
                        .Visible = True
                    End With
                End If
            End If

            ' Checkbox
            If CheckBoxes Then
                If cRoot.Checkbox Is Nothing Then
                    Set cRoot.Checkbox = TreeControl.Controls.Add("Forms.label.1", "CheckBox" & cRoot.Control.Name, False)
                    With cRoot.Checkbox
                        .Left = mcTLpad + msngRootLine
                        .top = msngTopChk + mlVisCount * msngNodeHeight

                        If mbCheckboxImage Then
                            'Use an image
                            .BorderStyle = MSForms.fmBorderStyleNone
                            .Picture = moCheckboxImage(cRoot.Checked)
                            .PicturePosition = MSForms.fmPicturePositionLeftTop
                            .AutoSize = True
                            '.Width = 7.5
                            '.Height = 7.5
                        Else
                            .Width = mcChkBoxSize
                            .Height = mcChkBoxSize
                            .Font.Name = "Marlett"  ' "a" is a tick
                            .FontSize = mcCheckboxFont     '9
                            .BorderStyle = MSForms.fmBorderStyleSingle
                            .BackColor = vbWindowBackground
                            .ForeColor = vbWindowText
                        End If
                        If cRoot.Checked Then cRoot.Checked = True
                        .Visible = True
                    End With
                Else
                    With cRoot.Checkbox
                        .Left = mcTLpad + msngRootLine
                        .top = msngTopChk + mlVisCount * msngNodeHeight
                        .Visible = True
                    End With
                End If
            End If

            ' Icon
            If mbFullWidth And mbGotIcons Then
                If cRoot.hasIcon(vIconKey) Then
                    If cRoot.Icon Is Nothing Then
                        Set cRoot.Icon = TreeControl.Controls.Add("Forms.Image.1", "Icon" & cRoot.Control.Name, False)
                        With cRoot.Icon
                            .BackStyle = MSForms.fmBackStyleTransparent
                            .BorderStyle = MSForms.fmBorderStyleNone
                            '.AutoSize
                            .Width = mcIconSize
                            .Height = mcIconSize
                            .Left = mcTLpad + msngRootLine + msngChkBoxPad
                            .top = msngTopIcon + mlVisCount * msngNodeHeight
                            .Picture = mcolIcons(vIconKey)
                            .BackStyle = MSForms.fmBackStyleTransparent
                            .Visible = True
                        End With
                    Else
                        With cRoot.Icon
                            .Left = mcTLpad + msngRootLine + msngChkBoxPad
                            .top = msngTopIcon + mlVisCount * msngNodeHeight
                            .Visible = True
                        End With
                    End If
                Else
                    sngIconPad = 0
                End If
            End If

            mlVisCount = mlVisCount + 1
            mlVisOrder(mlVisCount) = cRoot.Index
            cRoot.VisIndex = mlVisCount

            lLastRootVisIndex = mlVisCount

            'Now add this root's children
            If Not cRoot.ChildNodes Is Nothing Then
                If (cRoot.ChildNodes.Count > 0) Then
                    BuildTree cRoot, 1, True
                End If
            End If

        Next

        'Vertical line for multiple roots
        If mbRootButton And mbShowLines Then
            If moRootHolder.ChildNodes.Count > 1 Then

                If moRootHolder.VLine Is Nothing Then
                    Set moRootHolder.VLine = TreeControl.Controls.Add("forms.label.1", "VLine_Roots")
                    With moRootHolder.VLine
                        .ZOrder 1
                        .Width = mcPtPxl
                        .Caption = ""
                        .BorderColor = vbScrollBars
                        .BorderStyle = MSForms.fmBorderStyleSingle
                        .top = msngTopHV
                        .Left = mcLineLeft
                        .Height = (lLastRootVisIndex - 1) * msngNodeHeight
                    End With

                Else

                    With moRootHolder.VLine
                        .top = msngTopHV
                        .Height = (lLastRootVisIndex - 1) * msngNodeHeight
                        .Visible = True
                    End With
                End If

            End If
        End If

        sngHeightAllNodes = mlVisCount * NodeHeight + (mcTLpad * 2)    ' mcTLpad for top/bottom padding
        If bInit Then
            .ScrollHeight = 0
            .ScrollLeft = 0
        End If

        sngMaxWidth = MaxNodeWidth

        If sngHeightAllNodes > .InsideHeight Then
            If sngMaxWidth + 15 > .InsideWidth Then
                .ScrollBars = MSForms.fmScrollBarsBoth
                .ScrollWidth = sngMaxWidth + mcTLpad
            Else
                .ScrollBars = MSForms.fmScrollBarsVertical
                .ScrollLeft = 0
                .ScrollWidth = 0
            End If
            .ScrollHeight = sngHeightAllNodes
        Else
            If sngMaxWidth > .InsideWidth + IIf(.ScrollBars > 1, 15, 0) Then
                .ScrollBars = MSForms.fmScrollBarsHorizontal
                .ScrollWidth = sngMaxWidth + mcTLpad
            Else
                .ScrollBars = MSForms.fmScrollBarsNone
                .ScrollLeft = 0
                .ScrollWidth = 0
            End If

            .ScrollTop = 0
            .ScrollHeight = 0
        End If

        If bInit Then    ' startup
            '' make the first root node active but don't highlight it
            Set moActiveNode = moRootHolder.ChildNodes(1)
            '' or if preferred highlighted at startup
            'Set ActiveNode = moRootHolder.ChildNodes(1)
        ElseIf Not ActiveNode Is Nothing Then
            If Not NodeIsVisible Then
                .ScrollTop = (ActiveNode.VisIndex - 1) * NodeHeight - sngActiveNodeScrollTop
            End If
        End If

    End With

    #If DebugMode Then
        #If Win32 Or Win64 Then
            sngTickCnt = (getTickCount - sngTickCnt) / 1000
        #Else  ' if Mac
            sngTickCnt = Timer - sngTickCnt
        #End If

        sCap = "Seconds: " & Format(sngTickCnt, "0.00") & _
               "    Nodes: " & mcolNodes.Count & _
               "  created: " & mlNodesCreated & _
               "  visible: " & mlVisCount & _
               "    Total controls: " & TreeControl.Controls.Count
               
        #If HostProject = "Access" Then
            If Not moForm Is Nothing Then
                moForm.Caption = sCap
            End If
        #Else
            Me.TreeControl.parent.Caption = sCap
        #End If
    #End If

    mbRedesign = False
    mbTriState = bTriStateOrig
done:

    If bCursorWait Then

        #If HostProject = "Access" Then
            Application.DoCmd.Hourglass False
        #ElseIf HostProject = "Word" Then
            System.Cursor = wdCursorNormal
        #Else
            Application.Cursor = xlDefault
        #End If

        #If Win32 Or Win64 Then
            ' in some systems the cursor fails to reset to default, this forces it
            GetCursorPos pt
            SetCursorPos pt.X, pt.Y
        #End If
    End If

    'TODO: implement API equivalent for cancel key in Access & Word
    #If HostProject = "Access" Then
    #ElseIf HostProject = "Word" Then
    #Else
        Application.EnableCancelKey = xlInterrupt
    #End If
    
    Exit Sub

locErr:
    mbRedesign = False
    mbTriState = bTriStateOrig

    If err.Number = 9 And (mlVisCount = UBound(mlVisOrder) + 1) Then
        ' most likely an array needs enlarging
        If mlVisCount = UBound(mlVisOrder) + 1 Then
            ReDim Preserve mlVisOrder(LBound(mlVisOrder) To mlVisCount + 100)
            Resume
        End If
    ElseIf err.Number = 18 Then
        ' user pressed ctrl-break
        MsgBox "Loading/refreshing Treeview aborted", , AppName
        NodesClear
        Resume done
    End If

    #If DebugMode = 1 Then
        Debug.Print err.Number, err.Description
        Stop
        Resume
    #End If

    err.Raise err.Number, "BuildRoot", err.Description
End Sub

Private Sub BuildTree(cNode As clsNode, ByVal lLevel As Long, Optional lMaxLevel As Long = -1)
    Dim cChild As clsNode
    Dim lVLineTopIdx As Long

   ' On Error GoTo locErr

    If (lLevel > 1 Or mbRootButton) And mbShowExpanders And cNode.ChildNodes.Count > 0 Then

        'Expand/collapse button box (not needed if we use icons are used for expanders)
        If Not mbExpanderImage Then
            If cNode.ExpanderBox Is Nothing Then
                Set cNode.ExpanderBox = TreeControl.Controls.Add("Forms.label.1", "ExpBox" & cNode.Control.Name, False)
                With cNode.ExpanderBox
                    .top = (mlVisCount - 1) * NodeHeight + msngTopExpB
                    .Left = mcTLpad * 2 + (lLevel - 2) * msngIndent + msngRootLine
                    .Width = mcExpBoxSize
                    .Height = mcExpBoxSize
                    .BorderStyle = MSForms.fmBorderStyleSingle
                    .BorderColor = vbScrollBars
                    .BackStyle = MSForms.fmBackStyleOpaque
                    .Visible = True
                End With
            Else
                With cNode.ExpanderBox
                    If mbRedesign Then .Left = mcTLpad * 2 + (lLevel - 2) * msngIndent + msngRootLine
                    .top = (mlVisCount - 1) * NodeHeight + msngTopExpB
                    .Visible = True
                End With
            End If
        End If

        'Expand/collapse button text (or icon)
        If cNode.Expander Is Nothing Then
            Set cNode.Expander = TreeControl.Controls.Add("Forms.label.1", "ExpText" & cNode.Control.Name, False)
            With cNode.Expander
                .Left = mcTLpad * 2 + (lLevel - 2) * msngIndent + msngRootLine
                .top = (mlVisCount - 1) * NodeHeight + msngTopExpT

                If mbExpanderImage Then
                    'Use an image
                    .AutoSize = True
                    .Width = 7.5
                    .Height = 7.5
                    .BorderStyle = MSForms.fmBorderStyleNone
                    .PicturePosition = MSForms.fmPicturePositionLeftTop
                    .Picture = moExpanderImage(cNode.Expanded)
                    #If Mac Then
                        .BackStyle = MSForms.fmBackStyleTransparent
                    #End If
                Else
                    'use +/- text
                    .Width = mcExpButSize
                    .Height = mcExpButSize

                    If cNode.Expanded = True Then
                        .Caption = "-"
                        .Font.Bold = True
                    Else
                        .Caption = "+"
                        .Font.Bold = False
                    End If

                    .Font.size = mcExpanderFont
                    .TextAlign = MSForms.fmTextAlignCenter
                    .BackStyle = MSForms.fmBackStyleTransparent
                End If
                .Visible = True
            End With
        Else
            With cNode.Expander
                If mbRedesign Then .Left = mcTLpad * 2 + (lLevel - 2) * msngIndent + msngRootLine
                .top = (mlVisCount - 1) * NodeHeight + msngTopExpT
                .Visible = True
            End With
        End If

    End If  ' lLevel > 1 Or mbRootButton) And mbShowExpanders

    If cNode.Expanded And (lMaxLevel < lLevel Or lMaxLevel = -1) Then

        'Vertical line
        If mbShowLines Then
            If cNode.VLine Is Nothing Then
                Set cNode.VLine = TreeControl.Controls.Add("Forms.label.1", "VLine" & cNode.Control.Name, False)
                lVLineTopIdx = mlVisCount
                With cNode.VLine
                    .ZOrder 1
                    .top = msngTopHV + (lVLineTopIdx - 1) * NodeHeight
                    .Left = mcLineLeft + msngRootLine + msngIndent * (lLevel - 1)
                    .Width = mcPtPxl
                    .Height = NodeHeight
                    .Caption = ""
                    .BorderColor = vbScrollBars
                    .BorderStyle = MSForms.fmBorderStyleSingle
                    .Visible = True
                End With

            Else
                lVLineTopIdx = mlVisCount
                With cNode.VLine
                    .top = msngTopHV + (lVLineTopIdx - 1) * NodeHeight
                    If mbRedesign Then
                        .Left = mcLineLeft + msngRootLine + msngIndent * (lLevel - 1)
                        .Visible = True
                    End If
                End With
            End If
        End If

        For Each cChild In cNode.ChildNodes

            ' extend the vertical line
            If mbShowLines Then
                With cNode.VLine
                    .Height = (mlVisCount - lVLineTopIdx + 1) * msngNodeHeight
                    .Visible = True
                End With
            End If

            BuildNodeControls cChild, lLevel

            If Not cChild.ChildNodes Is Nothing Then
                BuildTree cChild, lLevel + 1
            End If

        Next

    End If    ' cNode.Expanded And (lMaxLevel < lLevel Or lMaxLevel = -1)

    Exit Sub

'locErr:
'    #If DebugMode = 1 Then
'        Stop
'        Resume
'    #End If
End Sub

Private Sub BuildNodeControls(cNode As clsNode, ByVal lLevel As Long)
' PT, create or (un)hide the controls, size & position to suit
' all created nodes have a caption, and optionally a horizontal line, checkbox and seperate icon

    Dim sngIconPad As Single
    Dim sName As String
    Dim vKey

    On Error GoTo locErr

  '  Application.EnableCancelKey = xlErrorHandler

    If cNode.Control Is Nothing Then
        mlNodesCreated = mlNodesCreated + 1
        sName = "Node" & mlNodesDeleted + mlNodesCreated
    ElseIf mbRedesign Then
         sName = cNode.Control.Name
    End If

    'Horizontal line
    If mbShowLines Then
        If cNode.HLine Is Nothing Then
            Set cNode.HLine = TreeControl.Controls.Add("Forms.label.1", "HLine" & sName, False)
            With cNode.HLine
                .Left = mcLineLeft + msngRootLine + msngIndent * (lLevel - 1)
                .top = msngTopHV + mlVisCount * NodeHeight
                .Width = msngIndent
                .Height = mcPtPxl
                .Caption = ""
                .BorderStyle = MSForms.fmBorderStyleSingle
                .BorderColor = vbScrollBars
                 If mbRedesign Then
                    .ZOrder 1
                 End If
                .Visible = True
            End With
        Else
            With cNode.HLine
                If mbRedesign Then
                    .Left = mcLineLeft + msngRootLine + msngIndent * (lLevel - 1)
                    .Width = msngIndent
                End If
                .top = msngTopHV + mlVisCount * NodeHeight
                .Visible = True
            End With
        End If
    End If

    ' Checkbox
    If CheckBoxes Then
        If cNode.Checkbox Is Nothing Then
            Set cNode.Checkbox = TreeControl.Controls.Add("Forms.label.1", "CheckBox" & sName, False)
            With cNode.Checkbox
                .Left = mcTLpad + msngRootLine + msngIndent * lLevel
                .top = mlVisCount * NodeHeight + msngTopChk

                If mbCheckboxImage Then
                    'Use an image
                    .BorderStyle = MSForms.fmBorderStyleNone
                    .Picture = moCheckboxImage(cNode.Checked)
                    .PicturePosition = MSForms.fmPicturePositionLeftBottom
                    .AutoSize = True
                Else

                    .Width = mcChkBoxSize
                    .Height = mcChkBoxSize
                    .Font.Name = "Marlett"
                    .Font.size = 10
                    .TextAlign = MSForms.fmTextAlignCenter
                    .BorderStyle = MSForms.fmBorderStyleSingle
                    If cNode.Checked Then
                        .Caption = "a"
                        If cNode.Checked = 1 Then
                            .ForeColor = RGB(180, 180, 180)
                        End If
                    End If
                End If

                .Visible = True
            End With
        Else
            With cNode.Checkbox
                If mbRedesign Then .Left = mcTLpad + msngRootLine + msngIndent * lLevel
                .top = mlVisCount * NodeHeight + msngTopChk
                .Visible = True
            End With
        End If
    End If

    ' Icon, in its own image control if using FullWidth, otherwise it goes in the label
    If mbFullWidth And mbGotIcons Then
        If cNode.hasIcon(vKey) Then
            sngIconPad = mcIconPad
            If cNode.Icon Is Nothing Then
                Set cNode.Icon = TreeControl.Controls.Add("Forms.Image.1", "Icon" & sName, False)
                With cNode.Icon
                    .BorderStyle = MSForms.fmBorderStyleNone
                    .Left = mcTLpad + msngRootLine + msngIndent * lLevel + msngChkBoxPad
                    .top = mlVisCount * NodeHeight + msngTopIcon
                    '.AutoSize
                    .Width = mcIconSize
                    .Height = mcIconSize
                    .BackStyle = MSForms.fmBackStyleTransparent
                    .Picture = mcolIcons(vKey)
                    .BackStyle = MSForms.fmBackStyleTransparent
                    .Visible = True
                End With
            Else
                With cNode.Icon
                    If mbRedesign Then
                        .Left = mcTLpad + msngRootLine + msngIndent * lLevel + msngChkBoxPad
                    End If
                    .top = mlVisCount * NodeHeight + msngTopIcon
                    .Visible = True
                End With
            End If
        Else
            sngIconPad = 0
        End If
    End If
    
    'The node itself
    If cNode.Control Is Nothing Then
        
        Set cNode.Control = TreeControl.Controls.Add("Forms.label.1", sName, False)
        With cNode.Control
            .WordWrap = False
            .AutoSize = True
            .Left = mcTLpad + msngRootLine + msngIndent * lLevel + msngChkBoxPad + sngIconPad
            .top = mcTLpad + msngTopLabel + mlVisCount * NodeHeight

            If Not mbFullWidth And mbGotIcons Then
                If cNode.hasIcon(vKey) Then
                    .PicturePosition = MSForms.fmPicturePositionLeftCenter
                    .Picture = mcolIcons(vKey)
                End If
            End If

            If cNode.Bold Then .Font.Bold = True
            .WordWrap = False
            .AutoSize = True
            .Caption = cNode.Caption
            cNode.TextWidth = .Width

            If cNode.TextWidth + sngIconPad > msngMaxWidths(lLevel) Then
                msngMaxWidths(lLevel) = cNode.TextWidth + sngIconPad
            End If

            If mbFullWidth Then
                .AutoSize = False
                If .Width <= mcFullWidth Then .Width = mcFullWidth
            End If
            If cNode.BackColor Then
                .BackColor = cNode.BackColor
            End If
            If cNode.ForeColor Then
                .ForeColor = cNode.ForeColor
            End If
            .Visible = True
        End With

    Else
        With cNode.Control
            If mbRedesign Then
                .Left = mcTLpad + msngRootLine + msngIndent * lLevel + sngIconPad + msngChkBoxPad

                If cNode.TextWidth + sngIconPad > msngMaxWidths(lLevel) Then
                    msngMaxWidths(lLevel) = cNode.TextWidth + sngIconPad
                End If
            End If

            .top = mlVisCount * NodeHeight + mcTLpad + msngTopLabel
            .Visible = True
        End With

    End If

    mlVisCount = mlVisCount + 1
    mlVisOrder(mlVisCount) = cNode.Index
    cNode.VisIndex = mlVisCount

    Exit Sub

locErr:
    If err.Number = 9 Then
        ' most likely an array needs enlarging
        If mlVisCount = UBound(mlVisOrder) + 1 Then
            ReDim Preserve mlVisOrder(LBound(mlVisOrder) To mlVisCount + 100)
            Resume
        ElseIf lLevel > UBound(msngMaxWidths) Then
            ReDim Preserve msngMaxWidths(LBound(msngMaxWidths) To lLevel + 5)
            Resume
        End If
    ElseIf err.Number = 18 Then
        err.Raise 18    ' user pressed ctrl-break, pass to BuildRoot
    Else
        #If DebugMode = 1 Then
            Stop
            Resume
        #End If
        err.Raise err.Number, "BuildNodeControls", err.Description
    End If

End Sub

Private Sub Clone(cParent As clsNode, cNode As clsNode, Optional vBefore, Optional ByVal vAfter)
' PT clone a node and add the 4-way references
    Dim bTriStateOrig As Boolean
    Dim cClone As clsNode
    Dim cChild As clsNode
     
    On Error GoTo errH

    If cParent Is Nothing Or cNode Is Nothing Then
        Exit Sub
    End If

    bTriStateOrig = mbTriState
    mbTriState = False
    
    Set cClone = New clsNode

    With cNode
        If .BackColor = 0 Then .BackColor = mlBackColor
        cClone.BackColor = .BackColor
        cClone.Caption = .Caption
        cClone.Checked = .Checked
        cClone.Expanded = .Expanded
        If .ForeColor = 0 Then .ForeColor = mlForeColor
        cClone.ImageExpanded = .ImageExpanded
        cClone.ImageMain = .ImageMain
        cClone.ForeColor = .ForeColor
        cClone.Key = .Key
    End With

    If cParent.ChildNodes Is Nothing Then
        Set cParent.ChildNodes = New Collection
    End If

    Set cClone.ParentNode = cParent

    If Not cNode.ChildNodes Is Nothing Then
        For Each cChild In cNode.ChildNodes
            Clone cClone, cChild    ' don't pass vBefore/vAfter
        Next
    End If

    AddNodeToCol cParent.ChildNodes, cClone, False, vBefore, vAfter

    Set cClone.Tree = Me
    
    AddNodeToCol mcolNodes, cClone, bTreeCol:=True

    cClone.Index = Nodes.Count
    
    mbTriState = bTriStateOrig
    If mbTriState Then
        cClone.ParentNode.CheckTriStateParent
    End If
    
    Exit Sub

errH:
    #If DebugMode = 1 Then
        Debug.Print err.Description
        Stop
        Resume
    #End If
    mbTriState = bTriStateOrig
End Sub

Private Function MaxNodeWidth() As Single
'-------------------------------------------------------------------------
' Procedure : MaxNodeWidth
' Author    : Peter Thornton
' Created   : 27-01-2013
' Purpose   : Get the max right for horizontal scroll
'-------------------------------------------------------------------------
    Dim lLevel As Long
    Dim sngMax As Single

    ''' msngMaxWidths(), contains maximum text-width + additional icon width (if any) in each level
    '  tot-width = 3 + msngRootLine + msngIndent * lLevel + msngChkBoxPad + [ msngIconPad + text-width]

    For lLevel = 0 To UBound(msngMaxWidths)
        If msngMaxWidths(lLevel) Then
            If mcTLpad + msngRootLine + msngIndent * lLevel + msngChkBoxPad + msngMaxWidths(lLevel) > sngMax Then
                sngMax = mcTLpad + msngRootLine + msngIndent * lLevel + msngChkBoxPad + msngMaxWidths(lLevel)
            End If
        End If
    Next
    MaxNodeWidth = sngMax
    
End Function

Private Function NextVisibleNodeInTree(ByRef cStartNode As clsNode, Optional bUp As Boolean = True) As clsNode
'-------------------------------------------------------------------------
' Procedure : NextVisibleNodeInTree
' Company   : JKP Application Development Services (c)
' Author    : Jan Karel Pieterse (www.jkp-ads.com)
' Created   : 16-01-2013
' Purpose   : Function that returns either the next or the previous node adjacent to the active node
'-------------------------------------------------------------------------

    Dim lStep As Long
    Dim lNextVis As Long    'PT

    On Error GoTo errH
    If bUp Then lStep = -1 Else lStep = 1

    If cStartNode Is Nothing Then
        Set NextVisibleNodeInTree = mcolNodes(1)
    Else

        lNextVis = cStartNode.VisIndex
        lNextVis = lNextVis + lStep
        If lNextVis >= 1 And lNextVis <= mlVisCount Then
            lNextVis = mlVisOrder(lNextVis)
            Set NextVisibleNodeInTree = mcolNodes(lNextVis)
        End If
    End If
    Exit Function
errH:
    #If DebugMode = 1 Then
        Stop
        Debug.Print err.Description
        Resume
    #End If
End Function

Private Function NodeIsVisible(Optional cNode As clsNode, Optional lngCntVisible As Long) As Boolean
Dim idxFirstVis As Long
Dim idxLastVis As Long

    If TreeControl Is Nothing Then
        Exit Function
    End If

    With TreeControl
        idxFirstVis = .ScrollTop / NodeHeight + 1
        lngCntVisible = (.InsideHeight - mcTLpad) / NodeHeight
        idxLastVis = lngCntVisible + idxFirstVis - 1
    End With

    If cNode Is Nothing Then
        If Not ActiveNode Is Nothing Then

            Set cNode = ActiveNode
        Else
            Exit Function
        End If
    End If

    If idxLastVis > mlVisCount Then idxLastVis = mlVisCount

    If Not cNode Is Nothing Then
        NodeIsVisible = cNode.VisIndex >= idxFirstVis And cNode.VisIndex <= idxLastVis
    End If

End Function

Private Sub ResetActiveNodeColor(cNode As clsNode)
    Dim lBColor As Long
    Dim lFColor As Long
    If Not cNode Is Nothing Then
        lBColor = cNode.BackColor
        lFColor = cNode.ForeColor
        With cNode.Control
            .BorderStyle = MSForms.fmBorderStyleNone
            .BackColor = IIf(lBColor, lBColor, mlBackColor)
            .ForeColor = IIf(lFColor, lFColor, mlForeColor)
        End With
    End If
End Sub

Private Sub Round75()
'-------------------------------------------------------------------------
' Procedure : Round75
' Author    : Peter Thornton
' Created   : 29-01-2013
' Purpose   : Make size & position dims a factor of 0.75 points (units of 1 pixel)
'-------------------------------------------------------------------------
#If Mac Then
    msngTopExpB = Int(msngTopExpB)
    msngTopExpT = Int(msngTopExpT)
    msngTopHV = Int(msngTopHV)
    msngTopIcon = Int(msngTopIcon)
    msngTopChk = Int(msngTopChk)
    msngTopLabel = Int(msngTopLabel)
#Else
    msngTopExpB = Int((msngTopExpB * 2 + mcPtPxl) / 3 * 2) * mcPtPxl
    msngTopExpT = Int((msngTopExpT * 2 + mcPtPxl) / 3 * 2) * mcPtPxl
    msngTopHV = Int((msngTopHV * 2 + mcPtPxl) / 3 * 2) * mcPtPxl
    msngTopIcon = Int((msngTopIcon * 2 + mcPtPxl) / 3 * 2) * mcPtPxl
    msngTopChk = Int((msngTopChk * 2 + mcPtPxl) / 3 * 2) * mcPtPxl
    msngTopLabel = Int((msngTopLabel * 2 + mcPtPxl) / 3 * 2) * mcPtPxl
#End If
End Sub

Private Sub SetActiveNodeColor(Optional bInactive)

    If Not ActiveNode Is Nothing Then

        If IsMissing(bInactive) Then
            On Error Resume Next
            #If HostProject = "Access" Then
                bInactive = mbInActive
            #Else
                bInactive = Not Me.TreeControl Is Me.TreeControl.parent.ActiveControl
            #End If
            On Error GoTo 0
        End If

         ' system highlight colours, bInactive set and called from EnterExit event

        With ActiveNode.Control
            If bInactive Then
            ''' when treeeview not in focus
            
                ResetActiveNodeColor moActiveNode
                '' just a grey border
                .BorderStyle = MSForms.fmBorderStyleSingle
                .BorderColor = RGB(190, 190, 190)
                
                '' inactive colours
'                .BackColor = vbInactiveTitleBar
'                .ForeColor = vbWindowText
            Else
                ' in focus
                .BorderStyle = MSForms.fmBorderStyleNone
                .BackColor = vbHighlight
                .ForeColor = vbHighlightText
            End If
        End With

    End If
End Sub

Private Sub SetTreeExpansionLevel(lLevel As Long, Optional lCurLevel As Long, _
                                          Optional cNode As clsNode, Optional bExit As Boolean = False)
'-------------------------------------------------------------------------
' Procedure : SetTreeExpansionLevel
' Company   : JKP Application Development Services (c)
' Author    : Jan Karel Pieterse (www.jkp-ads.com)
' Created   : 17-01-2013
' Purpose   : Updates the expanded properties according to lLevel
'             Called recursively.
'-------------------------------------------------------------------------
    Dim cChild As clsNode
    If bExit Then Exit Sub
    If cNode Is Nothing Then

        For Each cNode In moRootHolder.ChildNodes
            If lLevel > -1 Then
                cNode.Expanded = True
            Else
                cNode.Expanded = False
            End If
            If Not cNode.ChildNodes Is Nothing Then
                For Each cChild In cNode.ChildNodes
                    cChild.Expanded = (lLevel > lCurLevel)
                    SetTreeExpansionLevel lLevel, lCurLevel + 1, cChild, False
                Next
            End If
        Next

    ElseIf Not cNode.ChildNodes Is Nothing Then
        For Each cChild In cNode.ChildNodes
            cChild.Expanded = (lLevel > lCurLevel)
            SetTreeExpansionLevel lLevel, lCurLevel + 1, cChild, False
        Next
    End If
End Sub


'*********************************************************************************************
'*    Private events    *
'**********************************************************************************************

Private Sub TreeControl_Click()
' PT exit editmode if an empty part of the treeview is clicked
    EditMode(ActiveNode) = False
End Sub

Private Sub TreeControl_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
    Dim sngVisTop As Single
    Dim cNode As clsNode

    ' PT toggle expand/collapse with key Enter
    If KeyCode = vbKeyReturn Then
        If ActiveNode.Expanded Then
            KeyCode = vbKeyLeft
        Else
            KeyCode = vbKeyRight
        End If
    End If

    If Not ActiveNode Is Nothing Then
        Select Case KeyCode

        Case vbKeyLeft
            If ActiveNode.level = 0 And Not mbRootButton Then
                ' don't attempt to collapse the Root if it doesn't have a button

            ElseIf Not ActiveNode.ChildNodes Is Nothing Then
                If ActiveNode.Expanded Then
                    ActiveNode.Expanded = False
                    BuildRoot False
                Else
                    If Not ActiveNode.ParentNode Is Nothing Then
                        If ActiveNode.ParentNode.Expanded Then
                            'If Not ActiveNode.ParentNode.Level = 0 And mbRootButton Then
                            If ActiveNode.ParentNode.level >= 0 Then
                                Set ActiveNode = ActiveNode.ParentNode
                                ScrollToView , -1
                                NodeClick ActiveNode.Control, ActiveNode    'AVDV
                            End If
                        End If
                    End If
                End If
            Else
                If Not ActiveNode.ParentNode Is Nothing Then
                    If ActiveNode.ParentNode.level = 0 And Not mbRootButton Then
                        ' don't attempt to collapse the Root if it doesn't have a button
                        ' redundant ?
                    ElseIf ActiveNode.ParentNode.Expanded Then
                        If ActiveNode.ParentNode.Caption <> "RootHolder" Then
                            Set ActiveNode = ActiveNode.ParentNode
                            ScrollToView ActiveNode, -1
                            NodeClick ActiveNode.Control, ActiveNode    'AVDV
                        End If
                    End If
                End If
            End If

        Case vbKeyRight
            If Not ActiveNode.ChildNodes Is Nothing Then
                If ActiveNode.Expanded = False Then
                    ActiveNode.Expanded = True
                    If Not ActiveNode.Expander Is Nothing Then
                        NodeClick ActiveNode.Expander, ActiveNode  'AVDV
                        ' BuildRoot False will be called in NodeClick
                    Else
                        ' a Root node and mbRootButton = False
                        BuildRoot False
                    End If
                Else
                    'ONEKING-218 FIX
                    '---------
                    If (ActiveNode.ChildNodes.Count) Then Set ActiveNode = ActiveNode.ChildNodes(1) 'AVDV
                    '---------
                    NodeClick ActiveNode.Control, ActiveNode    'AVDV
                End If

            End If

        Case vbKeyUp, vbKeyDown
            'ONEKING-429: remove some lines here that would show children of last visible node even if collapsed
            '-it didn't do a prober expand and we really never want down-key to expand anything
            'AVAD

            Set cNode = NextVisibleNodeInTree(ActiveNode, (KeyCode = vbKeyUp))

            If Not cNode Is Nothing Then
                Set ActiveNode = cNode
                ScrollToView ActiveNode, IIf(KeyCode = vbKeyUp, -1, -2) ' the -ve means will scroll won't change if the node is visible
                NodeClick ActiveNode.Control, ActiveNode 'AVDV
            End If

        Case vbKeyPageUp, vbKeyPageDown
            'store the activenode's vertical position to reset a similar in the keyup
            If Not mbKeyDown Then
                sngVisTop = (ActiveNode.VisIndex - 1) * NodeHeight - TreeControl.ScrollTop
                If sngVisTop > 0 And sngVisTop < TreeControl.InsideHeight Then
                    msngVisTop = sngVisTop
                Else
                    msngVisTop = 0
                End If
            End If

        Case vbKeyEscape
            Set MoveCopyNode(False) = Nothing

        Case vbKeySpace  ' PT toggle checkbox with space
            If CheckBoxes Then
                ActiveNode.Checked = Not ActiveNode.Checked

                RaiseEvent NodeCheck(ActiveNode)
            End If
        End Select

        mbKeyDown = True    ' PT

        RaiseEvent KeyDown(ActiveNode, KeyCode, Shift)
    Else
        If Not mcolNodes Is Nothing Then
            If mcolNodes.Count Then
                Set ActiveNode = mcolNodes(1)
            End If
        End If
    End If

End Sub

Private Sub TreeControl_KeyUp(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
'-------------------------------------------------------------------------
' Procedure : TreeControl_KeyUp
' Company   : JKP Application Development Services (c)
' Author    : Jan Karel Pieterse (www.jkp-ads.com)
' Created   : 17-01-2013
' Purpose   : Handles collapsing and expanding of the tree using left and right arrow keys
'             and moving up/down the tree using up/down arrow keys
'             Also handles folding of the tree when you use the numeric keys.
'-------------------------------------------------------------------------
    Dim lIdx As Long
    Dim sngNewScrollTop As Single

    If Not mbKeyDown Then    'PT
        ' PT KeyDown was initiated in some other control,
        '   eg Key Enter in the Editbox or tabbing to the treecontrol (enter event)
        Exit Sub
    Else

        mbKeyDown = False
    End If

    If Not ActiveNode Is Nothing Then

        Select Case KeyCode

        ' PT look into moving more key events into KeyDown

        Case 48 To 57, 96 To 105
            If KeyCode >= 96 Then KeyCode = KeyCode - 48
            If (KeyCode > vbKey0 Or mbRootButton) And Shift = 0 Then
                'SetTreeExpansionLevel (KeyCode - 49)
                ExpandToLevel (KeyCode - 48)
                BuildRoot False
            End If

        Case vbKeyF2, 93   ' F2 & key right/context menu (?) PT
            If mbLabelEdit Then
                If Not ActiveNode Is Nothing Then
                    EditMode(ActiveNode) = True
                    ActiveNode.EditBox True
                End If
            End If
        Case vbKeyPageUp, vbKeyPageDown
            ' PT activate node in the same position as previous activenode when scrolling
            With Me.TreeControl
                sngNewScrollTop = .ScrollTop
                lIdx = (sngNewScrollTop + msngVisTop) / NodeHeight + 1

                If (lIdx - 1) * NodeHeight < .ScrollTop Then
                    lIdx = lIdx + 1

                ElseIf lIdx * NodeHeight > .InsideHeight + .ScrollTop Then
                    lIdx = lIdx - 1
                End If
            End With

            If lIdx > 1 And lIdx <= mlVisCount Then
                lIdx = mlVisOrder(lIdx)
                Set ActiveNode = mcolNodes(lIdx)
            End If
            
        Case vbKeyHome, vbKeyEnd
            If KeyCode = vbKeyHome Then lIdx = 1 Else lIdx = mlVisCount
            lIdx = mlVisOrder(lIdx)
            If ActiveNode.Index <> lIdx Then
                Set ActiveNode = mcolNodes(lIdx)
            End If
        Case Else

        End Select
    Else
        If Not mcolNodes Is Nothing Then
            If mcolNodes.Count Then
                Set ActiveNode = mcolNodes(1)
            End If
        End If
    End If
    
End Sub


' InQuest injected base64 decoded content
' zjej
' Szjej
' ^>'$z
' ^>'$z
' :&j)
' )bz{Cy
' Ej)^t
' Ej)^t
' -O*^
' *'O*^
' h~+H
' *'~(.
' Lmzw^u'
' Lmzw^u'
' -O*^
' zjej
' -O*^6
' Szjej
' zjej
' zjej
' 	e:M
' :-jQ+
' ~`ZrD

INQUEST-PP=macro
