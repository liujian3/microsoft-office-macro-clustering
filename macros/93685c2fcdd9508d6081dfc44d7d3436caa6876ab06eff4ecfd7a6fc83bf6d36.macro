Attribute VB_Name = "BGDoc"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Option Compare Text

Public WithEvents ThisDoc As Document
Attribute ThisDoc.VB_VarHelpID = -1
Public DocState As BGDocState
Public Manager As BGDocManager
Public InSave As Boolean
Public DX As DOCXML
Public ReadOnly As Boolean
Public NewTranslation As Boolean

' DV Variables
Public FormName As String
Public ConvertToFullName As String
Public SaveAsTempFullName As String
Public SaveFileName As String
Public SaveFolder As String

Public ShowForm As Boolean

Private BackupIsForm As String
Private BackupConvertToFullName As String
Private BackupSaveAsTempFullName As String
Private BackupSaveFileName As String
Private BackupSaveFolder As String

Private AtOpenXML As New MSXML2.DOMDocument60
Private AtUpdateXML As New MSXML2.DOMDocument60

Public App As Word.Application

' -- Initialization --

Private Sub Class_Initialize()
    InSave = False
    ShowForm = False
End Sub

Private Sub Class_Terminate()
    Set DX = Nothing
    Set Manager = Nothing
    Set ThisDoc = Nothing
    Set App = Nothing
End Sub

Public Sub ClearDVs()
    FormName = ""
    ConvertToFullName = ""
    SaveAsTempFullName = ""
    SaveFileName = ""
    SaveFolder = ""
    WriteDVs
End Sub

Public Sub SetFormName(val As String)
    FormName = val
    DV ThisDoc, "FormName", FormName
End Sub

Public Sub SetConvertToFullName(val As String)
    ConvertToFullName = val
    DV ThisDoc, "ConvertToFullName", ConvertToFullName
End Sub

Public Sub SetSaveAsTempFullName(val As String)
    SaveAsTempFullName = val
    DV ThisDoc, "SaveAsTempFullName", SaveAsTempFullName
End Sub

Public Sub SetSaveFileName(val As String)
    SaveFileName = val
    DV ThisDoc, "SaveFileName", SaveFileName
End Sub

Public Sub SetSaveFolder(val As String)
    SaveFolder = val
    DV ThisDoc, "SaveFolder", SaveFolder
End Sub

Public Sub ReadDVs()
    FormName = DV(ThisDoc, "FormName")
    ConvertToFullName = DV(ThisDoc, "ConvertToFullName")
    SaveAsTempFullName = DV(ThisDoc, "SaveAsTempFullName")
    SaveFileName = DV(ThisDoc, "SaveFileName")
    SaveFolder = DV(ThisDoc, "SaveFolder")
End Sub

Public Sub BackupDVs()
    BackupIsForm = DV(ThisDoc, "FormName")
    BackupConvertToFullName = DV(ThisDoc, "ConvertToFullName")
    BackupSaveAsTempFullName = DV(ThisDoc, "SaveAsTempFullName")
    BackupSaveFileName = DV(ThisDoc, "SaveFileName")
    BackupSaveFolder = DV(ThisDoc, "SaveFolder")
End Sub

Public Sub RestoreDVs()
    DV ThisDoc, "FormName", BackupIsForm
    DV ThisDoc, "ConvertToFullName", BackupConvertToFullName
    DV ThisDoc, "SaveAsTempFullName", BackupSaveAsTempFullName
    DV ThisDoc, "SaveFileName", BackupSaveFileName
    DV ThisDoc, "SaveFolder", BackupSaveFolder
End Sub

Public Sub WriteDVs()
    DV ThisDoc, "FormName", FormName
    DV ThisDoc, "ConvertToFullName", ConvertToFullName
    DV ThisDoc, "SaveAsTempFullName", SaveAsTempFullName
    DV ThisDoc, "SaveFileName", SaveFileName
    DV ThisDoc, "SaveFolder", SaveFolder
End Sub

Public Sub Init(bgm As BGDocManager, doc As Document, stateOpen As BGDocState)
    Dim SavedCorrectly As Boolean
    SavedCorrectly = True
    Set Manager = bgm
    Set ThisDoc = doc
    Set App = ThisDoc.Application
    ReadOnly = ThisDoc.ReadOnly
    
    If ThisDoc.attachedTemplate.fullName <> ThisDocument.fullName Then
        DocState = dsNotBGDoc
    ElseIf ThisDoc.fullName = ThisDocument.fullName Then
        DocState = dsTemplate
    End If
    If DocState = dsNotBGDoc Or DocState = dsTemplate Then
        Exit Sub
    End If
    
    Set DX = New DOCXML
    DX.Init Me
    
    Dim ReadFormName As String
    If DX.TryReadText("/DocumentInfo/DocumentInfo-Form", ReadFormName) Then
        If ReadFormName > "" Then
            If stateOpen = dsAutoOpen Then
                ' Close and create new
                Dim newFullName As String
                newFullName = ThisDoc.fullName
                ThisDoc.Close wdDoNotSaveChanges
                Me.Manager.Docs.Remove CVar(newFullName)
                App.Documents.Add newFullName, , , True
                Exit Sub
            Else
                SetFormName ReadFormName
                SetSaveFolder DX.ReadText("/DocumentInfo/DocumentInfo-SaveFolder")
                SetSaveFileName DX.ReadText("/DocumentInfo/DocumentInfo-SaveFileName")
            End If
        Else
            ReadDVs
        End If
    Else
        ReadDVs
    End If
    
    If stateOpen = dsDocument Then
        DocState = dsDocument
    ElseIf ThisDoc.ActiveWindow.Visible = False Then
        DocState = IIf(stateOpen = dsAutoNew, dsNoAutoNew, dsNoAutoOpen)
    ElseIf ReadFormName > "" Then
        DocState = dsUseForm
    Else
        DocState = stateOpen
    End If
    
    Dim IsNewDocument As Boolean
    IsNewDocument = (ThisDoc.Name = ThisDoc.fullName) Or (DocState = dsUseForm)
    
    
    If DocState = dsAutoOpen Then
        SavedCorrectly = (DX.ReadText("/DocumentInfo/DocumentInfo-FullName") > "")
    End If
    
    ' Run Update
    If ThisDoc Is ActiveDocument Then
        Select Case DocState
            Case dsAutoNew
                Update "Form"
                DocState = dsDocument
            Case dsAutoOpen
                DocState = dsDocument
            Case dsUseForm
                Update "Form"
                DocState = dsDocument
        End Select
    End If
    
'    If IsNewDocument Then
'        SavedOk = SaveAsTemp(dsDocument)
'    End If
    
    If ThisDoc Is ActiveDocument And stateOpen <> dsDocument Then
        Dim Saved As Boolean
        Saved = ThisDoc.Saved
        'SavedAt = ""
        
        If Not ThisDoc.ReadOnly Then
            DX.DeleteNode "/DocumentInfo/DocumentInfo-ShowFullName"
            DX.DeleteNode "/DocumentInfo/DocumentInfo-FullName"
            WriteDVs
        End If
        If Not (Saved = ThisDoc.Saved) Then
            ThisDoc.Saved = Saved
        End If
        
        If App.DisplayDocumentInformationPanel Then App.DisplayDocumentInformationPanel = False
        
        Application.ScreenRefresh
        If FormName = "" And ThisDoc.Bookmarks.Exists("Start") Then
            Selection.GoTo What:=wdGoToBookmark, Name:="Start"
            Selection.find.ClearFormatting
            With Selection.find
                .text = ""
                .Replacement.text = ""
                .Forward = True
                .Wrap = wdFindAsk
                .Format = False
                .MatchCase = False
                .MatchWholeWord = False
                .MatchByte = False
                .MatchWildcards = False
                .MatchSoundsLike = False
                .MatchAllWordForms = False
            End With
            ThisDoc.Bookmarks("Start").Delete
            ActiveWindow.ScrollIntoView Selection.Range, True
        End If
        
        Dim i As Integer
        i = 0
        On Error GoTo RibbonNotReady
ShowRibbon:
        i = i + 1
        If i = 100 Then
            Exit Sub
        End If
        DoEvents
        Sleep 10
        DoEvents
       
        If Not DocRibbon Is Nothing Then
            DocRibbon.ActivateTab "documentTab"
        Else
            'Set DocRibbon = Nothing
        End If
        
        If Not SavedCorrectly Then
            MsgBox "Metadata may be invalid. Something went wrong the last time the document was saved. Please update and save the document if possible.", vbCritical + vbOKOnly, "Document error"
        End If
        Exit Sub
RibbonNotReady:
        Resume ShowRibbon
   End If
End Sub

' -- Events --

'Private Sub Doc_BuildingBlockInsert(ByVal Range As Range, ByVal Name As String, ByVal Category As String, ByVal BlockType As String, ByVal Template As String)
'    If DocState = dsNotBGDoc Then Exit Sub
'    'Debug.Print "Doc_BuildingBlockInsert: " & Doc.Name
'End Sub
'
'Private Sub Doc_Close()
'    If DocState = dsNotBGDoc Then Exit Sub
'    Debug.Print Now, "Doc_Close: " & doc.Name
'End Sub
'
'Private Sub Doc_New()
'    If DocState = dsNotBGDoc Then Exit Sub
'    Debug.Print Now, "Doc_New: " & doc.Name
'End Sub
'
'Private Sub Doc_ContentControlAfterAdd(ByVal NewContentControl As ContentControl, ByVal InUndoRedo As Boolean)
'    If DocState = dsNotBGDoc Then Exit Sub
'    'Debug.Print Now, "Doc_ContentControlAfterAdd", Doc.Name
'End Sub
'
'Private Sub Doc_Open()
'    If DocState = dsNotBGDoc Then Exit Sub
'    Debug.Print Now, "Doc_Open", doc.Name
'End Sub
'
'Private Sub ThisDoc_XMLAfterInsert(ByVal NewXMLNode As XMLNode, ByVal InUndoRedo As Boolean)
'    MsgBox "Attached"
'End Sub

' -- Saving and closing --

Public Function SaveAsTemp(newDocState As BGDocState) As Boolean
    On Error GoTo Catch
    
    Dim tmpFileName As String
    Dim BackupFullName As String
    BackupFullName = ThisDoc.fullName
    
    On Error Resume Next
    MkDir UserTemp() & "\BGdoc"
    On Error GoTo 0
    If (ThisDoc.Name = ThisDoc.fullName) Then 'New, not from form
        If FormName > "" Then
            SaveAsTempFullName = FormName & ".docx"
        Else
            SaveAsTempFullName = DX.ReadText("/DocumentInfo/DocumentInfo-DocType") & ".docx"
        End If
        SetSaveAsTempFullName UserTemp() & "\BGdoc\" & Mid(SaveAsTempFullName, 1, InStrRev(SaveAsTempFullName, ".") - 1) & " " & Format(Now, "yyyy-mm-dd HH.nn.ss") & ".docx"
    ElseIf SaveAsTempFullName > "" Then ' already saved as temporary file
        ' Just in case
        'If SaveFileName = "" Then SetSaveFileName DX.ReadText("/DocumentInfo/DocumentInfo-SaveFileName")
        'If SaveFolder = "" Then SetSaveFolder DX.ReadText("/DocumentInfo/DocumentInfo-SaveFolder")
    ElseIf SaveAsTempFullName = "" Then ' Already saved with ordinary name
        SaveAsTempFullName = ThisDoc.Name
        SetSaveAsTempFullName UserTemp() & "\BGdoc\" & Mid(SaveAsTempFullName, 1, InStrRev(SaveAsTempFullName, ".") - 1) & " " & Format(Now, "yyyy-mm-dd HH.nn.ss") & ".docx"
        'SetSaveFileName ThisDoc.Name
        'SetSaveFolder ThisDoc.path
    End If
    
    Dim SavedIsForm As String
    Dim IsSaved As Boolean
    IsSaved = ThisDoc.Saved
    SavedIsForm = FormName
    SetFormName ""
    DX.DeleteNode "/DocumentInfo/DocumentInfo-Form"
    InSave = True
    ThisDoc.SaveAs2 SaveAsTempFullName, , , , False
    InSave = False
    'Update Manager
    SetFormName SavedIsForm
    If ThisDoc.Saved <> IsSaved Then ThisDoc.Saved = IsSaved
    
    If SaveAsTempFullName <> BackupFullName Then
         Me.Manager.Docs.Add SaveAsTempFullName, Me
         Me.Manager.Docs.Remove CVar(BackupFullName)
    End If
    DocState = newDocState
    SaveAsTemp = True
   
Finally:
    On Error GoTo 0
    Exit Function
    
Catch:
    Dim e As New BGError
    e.OnError
    SaveAsTemp = False
    Resume Finally
   
End Function

Public Function HandleSave(doc As Document, method As String, ByRef Cancel As Boolean, SaveAsUi As Boolean) As Boolean
    ' Returns True If Saved
    ' Cancel is True If Calling Method Should Cancel it's action
    
    Debug.Print Now; " *HandleSave, "; method; ": "; doc.fullName
    'Exit Sub
    If method = "DocumentBeforeClose" Then
        Dim res As VbMsgBoxResult
        If SaveAsTempFullName > "" Then
            res = MsgBox("Do you want to save your changes to '" & doc.Name & "'?" + vbCrLf + vbCrLf + "If you click 'No' a temporary file will be available in '" & doc.path & "'", vbYesNoCancel + vbDefaultButton1 + vbExclamation, "Closing document")
        Else
            res = MsgBox("Do you want to save your changes to '" & doc.Name & "'?" + vbCrLf + vbCrLf + "If you click 'No' a temporary file will be available in '" & UserTemp & "'", vbYesNoCancel + vbDefaultButton1 + vbExclamation, "Closing document")
        End If
        Select Case res
            Case vbYes
                Cancel = False
            Case vbNo
                SaveAsTemp dsDocument
                doc.Saved = True
                Cancel = False
                Exit Function
            Case vbCancel
                Cancel = True
                Exit Function
        End Select
    Else
        Cancel = True
    End If
    
    Dim oNode As CustomXMLNode
    Dim showFullName As String
    Dim fullNameOld As String
    Dim IsConversion As Boolean
    
    Dim FullNameToUse As String
    Dim ShowDialog As Boolean
    Dim dialogInputFullName As String
    
    Dim BackupFullName As String
    BackupFullName = doc.fullName
    
    ' Handle save
    Application.DisplayAlerts = wdAlertsNone
    DX.Init Me
    IsConversion = False
    BackupDVs
        
    ShowDialog = (BatchSaveAsFullName = "") And _
                ( _
                    SaveAsUi _
                    Or (SaveAsTempFullName > "") _
                    Or (doc.fullName = doc.Name) _
                 ) ' Last one possible if Attached template
    
    If ShowDialog Then
        If SaveAsTempFullName > "" Or (doc.fullName = doc.Name) Then 'New
            Dim tempFolder As String
            Dim tempFileName As String
            
            If FormName = "" Then
                If SaveFileName > "" Then
                    tempFileName = CalculateTitle(SaveFileName, DX)
                End If
                If SaveFolder > "" Then
                    tempFolder = CalculateTitle(SaveFolder, DX)
                Else
                    tempFolder = Dialogs(wdDialogToolsOptionsFileLocations).Setting
                End If
            Else
                tempFileName = ""
                tempFolder = Dialogs(wdDialogToolsOptionsFileLocations).Setting
            End If
            
'            If Not Right$(tempFolder, 1) = "\" And Not Right$(tempFolder, 1) = "/" Then
'                tempFolder = IIf(InStr(SaveFolder, "\") > 0, "\", "/")
'            End If
            ' Test Exists on SaveFolder !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            
            dialogInputFullName = FixPath(CombinePaths(tempFolder, tempFileName))
        Else ' SaveAsUI
            dialogInputFullName = FixPath(doc.fullName)
        End If
        
'        ElseIf (doc.fullName <> doc.Name) And Not (doc.fullName = SaveAsTempFullName) Then
'            dialogInputFullName = doc.fullName
'        ElseIf (ConvertToFullName > "") And Not (doc.fullName = SaveAsTempFullName) Then
'            dialogInputFullName = FixPath(ConvertToFullName)
'        Else
'            dialogInputFullName = Dialogs(wdDialogToolsOptionsFileLocations).Setting
'            If Not Right$(dialogInputFullName, 1) = "\" And Not Right$(dialogInputFullName, 1) = "/" Then
'                dialogInputFullName = dialogInputFullName + IIf(InStr(dialogInputFullName, "\") > 0, "\", "/")
'            End If
'            dialogInputFullName = FixPath(dialogInputFullName)
'        End If
            
        Application.FileDialog(msoFileDialogSaveAs).initialFilename = dialogInputFullName
        Application.FileDialog(msoFileDialogSaveAs).Title = ""
        Application.FileDialog(msoFileDialogSaveAs).ButtonName = ""
        Application.FileDialog(msoFileDialogSaveAs).FilterIndex = 1

        Dim choice As Integer
        choice = Application.FileDialog(msoFileDialogSaveAs).show
        If choice = 0 Then 'Don't save
            Cancel = True
            Exit Function
        Else
            FullNameToUse = Application.FileDialog(msoFileDialogSaveAs).SelectedItems(1)
            If FullNameToUse = "" Then
                Exit Function
            Else
                FullNameToUse = FixPath(FullNameToUse, False)
            End If
        End If
    ElseIf BatchSaveAsFullName = "" Then
        FullNameToUse = FixPath(doc.fullName)
    Else
        FullNameToUse = FixPath(BatchSaveAsFullName)
    End If
    
    
    ' Prepare to save to SharePoint
    If LCase(GetSite(FullNameToUse)) Like "http*" Or LCase(FixPath(FullNameToUse, "\")) Like "*\\crisnet\*" Or LCase(FixPath(FullNameToUse, "\")) Like "*\\extranet.crisplant.com\*" Then
        Dim webFolder As String
        webFolder = LCase(FixPath(FullNameToUse))
        webFolder = IIf(InStrRev(webFolder, "\") > 0, Mid(webFolder, 1, InStrRev(webFolder, "\")), Mid(webFolder, 1, InStrRev(webFolder, "/")))
        'webFolder = FixPath(webFolder, "http")
        If GetURLStatus(webFolder) = "200" Then
            fullNameOld = Mid(FullNameToUse, 1, InStrRev(FullNameToUse, ".")) & "doc"
            If GetURLStatus(fullNameOld) = "200" Then
                If GetURLStatus(FullNameToUse) <> "200" Then
                    IsConversion = True
                    ' Move SharePoint file
                    Debug.Print "Move " & fullNameOld & " to " & FullNameToUse
                    Dim moveResult As String
                    moveResult = MoveSharePointFile(fullNameOld, FullNameToUse)
                    If LCase(moveResult) = LCase(FullNameToUse) Then
                        CheckOut FullNameToUse
                    End If
                Else
                    MsgBox "Converted file '" & FullNameToUse & "'already exists", vbCritical + vbOKOnly, "Cannot move SharePoint file"
                    Cancel = True
                    Exit Function
                End If
            End If
        End If
    End If
    ' Show FileMame
    showFullName = FullNameToUse
    If InStr(showFullName, "_Converted_") > 0 Then
        Dim start As Integer
        start = InStr(showFullName, "_Converted_")
        showFullName = Mid(showFullName, 1, start - 1) & Mid(showFullName, start + 20)
    End If
    
    Dim cc As ContentControl
    Dim docCCs As ContentControls
    Set docCCs = doc.SelectContentControlsByTag("DocumentInfo-FileName:DocumentInformation")
    If docCCs.Count <> 0 Then
        For Each cc In docCCs
            cc.LockContents = False
            cc.Range.text = showFullName
            cc.LockContents = True
        Next
    End If
    
    
    'Save
    DX.WriteText "/DocumentInfo/DocumentInfo-ShowFullName", showFullName
    DX.WriteText "/DocumentInfo/DocumentInfo-FullName", FullNameToUse
    
    If FormName > "" Then
        DX.SetNode "/DocumentInfo", "DocumentInfo-Form", FormName
        DX.SetNode "/DocumentInfo", "DocumentInfo-SaveFolder", SaveFolder
        DX.SetNode "/DocumentInfo", "DocumentInfo-SaveFileName", SaveFileName
    Else
        DX.DeleteNode "/DocumentInfo/DocumentInfo-Form"
        DX.DeleteNode "/DocumentInfo/DocumentInfo-SaveFolder"
        DX.DeleteNode "/DocumentInfo/DocumentInfo-SaveFileName"
    End If
    
    ClearDVs

    On Error GoTo FailedToSave
    If LCase(FullNameToUse) = LCase(doc.fullName) Then
        InSave = True
        doc.Save
        InSave = False
    ElseIf LCase(FullNameToUse) Like "*.docx" Then
        InSave = True
        doc.SaveAs2 FullNameToUse, , , , (BatchSaveAsFullName = "")
        InSave = False
    Else
        InSave = True
        Application.FileDialog(msoFileDialogSaveAs).Execute 'Save as other format?
        InSave = False
    End If
    On Error GoTo 0
    
    Set doc = ActiveDocument ' Application.Documents(FullNameToUse)
    Dim Saved As Boolean
    Saved = doc.Saved
    
    If Not (Saved = doc.Saved) Then
        doc.Saved = Saved
    End If
    

ExitSub:
    
    Application.DisplayDocumentInformationPanel = False
    Application.DisplayAlerts = wdAlertsAll
    
    If doc.fullName <> BackupFullName Then
        Me.Manager.Docs.Add doc.fullName, Me
        Me.Manager.Docs.Remove CVar(BackupFullName)
    End If
    
    If IsConversion Then
        ConvertedFullName = doc.fullName
        Application.OnTime Now + TimeValue("00:00:01"), "bg_Support.AfterSave"
    End If
    Exit Function
    
FailedToSave:
    ' Restore
    RestoreDVs
    DX.DeleteNode "/DocumentInfo/DocumentInfo-Form"
    DX.DeleteNode "/DocumentInfo/DocumentInfo-SaveFolder"
    DX.DeleteNode "/DocumentInfo/DocumentInfo-SaveFileName"
            
    Dim result As String
    result = doc.ContentTypeProperties.validate()
    If result > "" Then
        Application.DisplayDocumentInformationPanel = True
    Else
        MsgBox "File not saved!" & vbCrLf & Err.Description, vbCritical + vbOKOnly, "Save document"
    End If
    Resume ExitSub
    
End Function

Public Sub Update(method As String)
    Dim frm As MainForm
    Dim updated As Boolean
    updated = True
    
    DX.Init Me
    DX.method = method
    Select Case method
    Case "Form"
        DX.LanguageUpdated = False
        'DX.StructureUpdated = False
        DX.UpdateCaptions = False
        DX.ReplaceRegistered = False
        
        DX.DoUpdate = True
        DX.DoReadTranslation = False
        DX.DoFixDocument = False
        Set frm = New MainForm
        frm.Init DX
        frm.show
    Case "Refresh"
        DX.LanguageUpdated = True
        'DX.StructureUpdated = True
        DX.UpdateCaptions = True
        DX.ReplaceRegistered = True
        
        DX.DoUpdate = True
        DX.DoReadTranslation = True
        DX.DoFixDocument = False
    Case "Full"
        DX.LanguageUpdated = True
        'DX.StructureUpdated = True
        DX.UpdateCaptions = True
        DX.ReplaceRegistered = True
        
        DX.DoUpdate = True
        DX.DoReadTranslation = True
        DX.DoFixDocument = True
    Case "Convert"
        DX.LanguageUpdated = True
        'DX.StructureUpdated = True
        DX.UpdateCaptions = True
        DX.ReplaceRegistered = True
        
        DX.DoUpdate = True
        DX.DoReadTranslation = False
        DX.DoFixDocument = True
    End Select
    
    If DX.DoUpdate Then
        DX.Prolog "Update Document - " & method, False
        
        Set TimerForm = New UpdateForm
        TimerForm.Init Me, "UpdateDocument"
        TimerForm.show vbModal
        updated = True
        
        If ThisDoc.Characters.Count <= 2 Then
            ThisDoc.Range.Delete
            Dim p As Paragraph
            Set p = ThisDoc.Paragraphs.Add(ThisDoc.Range)
            p.Range.LanguageId = ThisDoc.Styles(wdStyleNormal).LanguageId
            p.Style = wdStyleHeading1
        End If
        DX.updated = updated
        DX.Epilog
    End If

End Sub

Public Sub ConvertToBGDoc(fromFullName As String)
    Dim docFrom As Document
    
    DX.Init Me
    DX.method = "Convert"
    Set DX.ConversionHistory = New Scripting.Dictionary
    DX.WriteText "/DocumentInfo/DocumentInfo-WorkflowLabel", "Conversion Draft"
    
' Test
'    DX.AddError "Picture: Missing file"
'    DX.AddError "Picture: File newer"
'    DX.AddWarning "Date: Frontpage, Header"
    
    If fromFullName = "" Then
        Set docFrom = Nothing
    Else
        On Error Resume Next
        Dim i As Integer
        For i = 1 To Application.Documents.Count
            If Application.Documents(i).fullName = fromFullName Then
                Set docFrom = Application.Documents(i)
                Exit For
            End If
        Next
        On Error GoTo 0
    End If
    
    ThisDoc.Activate
    ThisDoc.ActiveWindow.Visible = True
    Set DX.fromDoc = docFrom
    
    Set TimerForm = New UpdateForm
    TimerForm.Init Me, "ConvertDocument"
    TimerForm.show vbModal
    
    Update "Form"
End Sub

Public Function BatchConvertToBGDoc(fromFullName As Variant, toFullName As String, workflowLabel As Variant, image As Variant, projectNo As Variant) As String
    On Error GoTo OnError
    Dim strError As String
    
    Dim docFrom As Document
    DX.Init Me
    Set DX.ConversionHistory = New Scripting.Dictionary
    If workflowLabel > "" Then DX.WriteText "/DocumentInfo/DocumentInfo-WorkflowLabel", workflowLabel
    If projectNo > "" Then DX.WriteText "/DocumentInfo/DocumentInfo-ProjectNo", projectNo
    If image > "" Then DX.WriteText "/DocumentInfo/DocumentInfo-CompanyLogo", "http://crisnet/project/spteam/Pictures/" & image

'    DX.AddError "Picture: Missing file"
'    DX.AddError "Picture: File newer"
'    DX.AddWarning "Date: Frontpage, Header"

    ErrorProfile = epBatch
    DX.method = "Convert"
    If fromFullName = "" Then
        Set docFrom = Nothing
    Else
        On Error Resume Next
        Dim i As Integer
        For i = 1 To Application.Documents.Count
            If Application.Documents(i).fullName = fromFullName Then
                Set docFrom = Application.Documents(i)
                Exit For
            End If
        Next
        On Error GoTo 0
    End If
    If docFrom Is Nothing Then
        On Error Resume Next
        Set docFrom = Application.Documents.Open(fromFullName, , , False)
        On Error GoTo 0
    End If
    
    If Not docFrom Is Nothing Then
        Dim Skip As Boolean
        Dim Template As String
        Dim altTemplate As String
        altTemplate = ""
        Template = docFrom.attachedTemplate.Name
        On Error Resume Next
        altTemplate = docFrom.BuiltInDocumentProperties.Item("Template").value
        On Error GoTo 0
        Skip = Not UsesOldDocumentationTemplate(Template, altTemplate)
        
        If Skip Then
            docFrom.Close wdDoNotSaveChanges
            BatchConvertToBGDoc = "Skipped:Wrong template"
            Exit Function
        Else
            Set DX.fromDoc = docFrom
            ThisDoc.Activate
            ConvertDocument
            BatchSaveAsFullName = toFullName
            BatchConvertToBGDoc = DX.ConversionHistoryToString()
        End If
    Else
        BatchConvertToBGDoc = "Skipped:Document not found"
    End If
    Exit Function
    
    
ReturnError:
    DX.AddError strError
    BatchConvertToBGDoc = DX.ConversionHistoryToString()
    
    Exit Function
OnError:
    strError = Err.Number & ". " & Err.Description
    Resume ReturnError
    
End Function

Public Sub ConvertDocument(Optional closeAgain As Boolean = True, Optional screenUpdate As Boolean = False)
    Application.ScreenUpdating = screenUpdate
    Dim paperFormat As String
    Dim showFrontMatter As Boolean
    Dim fromDoc As Document
    Dim updated As Boolean
    updated = False
    
    Dim aRevHist() As String
    Dim ok As Boolean
    ok = True
    
    DX.WriteLog "Start conversion"
    
    Dim fromDocFullName As String
    Set fromDoc = DX.fromDoc
    fromDocFullName = fromDoc.fullName
    DX.OrgFileDate = GetFileDate(fromDocFullName)
    closeAgain = fromDoc.Saved
    
'    If fromDocFullName = "" Then
'        MsgBox "Please provide a file to import", vbExclamation & vbOKOnly, "Cannot convert document"
'        ok = False
'        Exit Sub
'    End If
'
'    If fromDoc Is Nothing Then
'        MsgBox "Unable to open '" & fromDocFullName & "'. Not allowed due to Trust Center settibgs?", vbExclamation & vbOKOnly, "Cannot convert document"
'        ok = False
'        Exit Sub
'    End If
'
'    If fromDoc.CanCheckin Then
'        MsgBox "Document must be checked in to be converted '" & fromDocFullName & "'", vbExclamation & vbOKOnly, "Cannot convert document"
'        ok = False
'        Exit Sub
'    End If
    
    
    Dim strSaveFolder As String
    Dim strSaveFileName As String
    
    'PLY!
    If InStr(fromDocFullName, "/") > 0 Then
        strSaveFolder = FixPath(Mid(fromDocFullName, 1, InStrRev(fromDocFullName, "/")))
        strSaveFileName = Mid(fromDocFullName, InStrRev(fromDocFullName, "/") + 1)
    Else
        strSaveFolder = FixPath(Mid(fromDocFullName, 1, InStrRev(fromDocFullName, "\")))
        strSaveFileName = Mid(fromDocFullName, InStrRev(fromDocFullName, "\") + 1)
    End If
    strSaveFileName = FixPath(Mid(strSaveFileName, 1, InStrRev(strSaveFileName, ".")) & "docx")
    
    DX.WriteText "/DocumentInfo/DocumentInfo-SaveFolder", strSaveFolder
    DX.WriteText "/DocumentInfo/DocumentInfo-SaveFileName", strSaveFileName
    
'    If fromDoc.CanCheckin Then
'        On Error Resume Next
'        fromDoc.CheckIn False ' Discard CheckOut
'        On Error GoTo 0
'        Set fromDoc = Application.Documents.Open(fromDocFullName, False, True, False, , , , , , , , True)
'        ok = Not fromDoc.CanCheckin
'    End If
    
    If ok Then
        ' Read Properties
        Dim fromFile As New CPDocFile
        
        Dim Head1 As String
        Dim Head2 As String
        Dim Head3 As String
        Dim Head4 As String
        Dim DateText As String
        Dim IniText As String
        Dim Section As String
        Dim Copyright As String
        Dim Language As String
        Dim comments As String
        Dim fld As field
        Dim ifld As Long
        
        fromDoc.Activate
    
        If Selection.Range.StoryType = 5 Then
            SendKeys "{Esc}", False
            DoEvents
            If Selection.Range.StoryType = 5 Then
                SendKeys "{Esc}", False
                DoEvents
            End If
        End If
        DoEvents

        DX.WriteLog "Unlink includetext and WordPerfect"
        Dim fldCount As Integer
        fldCount = fromDoc.fields.Count
        Dim fldPrev As field
        If Not fldCount = 0 Then
            Set fld = fromDoc.fields(fldCount)
            Do While Not fld Is Nothing
                Set fldPrev = fld.Previous
                If fld.Type = wdFieldIncludeText Then
                    fld.Unlink
                ElseIf Trim(LCase(fld.code)) Like "include *" Then
                    fld.Unlink
                End If
                Set fld = fldPrev
            Loop
        End If
'
'        For ifld = fldCount To 1 Step -1
'            Set fld = fromDoc.fields(ifld)
'            If fld.type = wdFieldIncludeText Then
'                fld.Unlink
'            ElseIf Trim(LCase(fld.code)) Like "include *" Then
'                fld.Unlink
'            End If
'        Next
        
        DX.WriteLog "Read document information"
        GetVariablesFromDocument Head1, Head2, Head3, Head4, DateText, IniText, Section, Copyright
        comments = fromDoc.BuiltInDocumentProperties("Comments")
                
        fromDoc.Content.Select
        DeleteSectionBreaks

         With ActiveWindow.View
            DX.ShowRevisionsAndComments = .ShowRevisionsAndComments
            DX.RevisionsView = .RevisionsView
            .ShowRevisionsAndComments = False
            .RevisionsView = wdRevisionsViewFinal
        End With
        

        DX.WriteLog "Determine paper format and language"
        paperFormat = GetPaperFormatFromPageSetup(fromDoc)
        
        ' GetLanguage
        fromFile.LanguageCode = DX.GetLanguageFromFileName(fromDoc.Name)
        ReadLanguageFromDocument fromDoc, fromFile
        
        DX.WriteLog "Read front page"
        ReadFrontPage fromDoc, fromFile
        fromFile.FPJournalExtra = Replace(Replace(Trim(fromFile.FPJournalExtra), "(", ""), ")", "")
        If fromFile.FPCopyright > "" Or fromFile.FPLine1 > "" Or fromFile.FPLine2 > "" Or fromFile.FPLine3 > "" Or fromFile.FPLine4 > "" Then
            showFrontMatter = True
        End If
        
        ' Prepare Shapes
        DX.WriteLog "Mark pictures"
        
        Dim bgpmFrom As New BGPictureManager
        ok = bgpmFrom.ReadRange(fromDoc.Content, DX, True)
        
'        For ifld = FromDoc.fields.count To 1 Step -1
'            Set fld = FromDoc.fields(ifld)
'            If Trim(LCase(fld.code)) Like "includepicture *" Then
'                fld.Unlink
'            End If
'        Next
        
        ' Copy/Paste
        DX.WriteLog "Copy content into document"
        fromDoc.Range.Select
        Selection.copy
        ThisDoc.Activate
        
        With ActiveWindow.View
            .ShowRevisionsAndComments = False
            .RevisionsView = wdRevisionsViewFinal
        End With
        
        'If doc.ContentControls.Count > 0 Then doc.ContentControls(1).LockContentControl = False
        ThisDoc.Range.Delete
        On Error Resume Next
        ThisDoc.Range.Paste
        If Err.Number <> 0 Then
            On Error GoTo 0
            DX.AddError "Unable to insert document content:" & Err.Description & ". Orginal must to be fixed."
        End If
        On Error GoTo 0
        
        ' Get Picture information
        DX.WriteLog "Read pictures"
        If ok Then
           ok = bgpmFrom.ReadOldFilename(DX, True)
            If ok Then
                ok = bgpmFrom.ReadInfo(DX, False)
            End If
            
'            If ok Then
'                ok = bgpmFrom.BreakBrokenLinks
'            End If
            If ok Then
                ok = bgpmFrom.Read(DX, True, False, False)
'                If ok Then
'                    ok = bgpmFrom.BreakBrokenLinks
'                End If
            End If
        End If
        
        ' All actions on fromDoc must be finished here
        
        ThisDoc.Activate
        DX.Prolog "Import Document"
        
        ' All Actions on doc below here
        
        If fromFile.LanguageCode > "" Then
            DX.WriteText "/DocumentInfo/DocumentInfo-Language", fromFile.LanguageCode
        Else
            DX.WriteText "/DocumentInfo/DocumentInfo-Language", fromFile.LanguageId
        End If
        
        ' Perhaps get Language and Paper from Variables before Clear
        ClearVariables ThisDoc
        
        ' Add Conversion fields to XML
        DX.WriteConversion fromDocFullName, Format(Now, "YYYY-MM-DD HH.mm:ss"), GetUserFullName, bgpmFrom
        SetConvertToFullName FixPath(Mid(fromDocFullName, 1, InStrRev(fromDocFullName, ".")) & "docx", False)
        SetSaveFileName strSaveFileName
        SetSaveFolder strSaveFolder
        
        DX.UnlockAllContentControls
        
        DX.WriteLog "Update pictures"
        ' Change Pictures to V
        Dim bgpm As New BGPictureManager
        ok = bgpm.ReadRange(ThisDoc.Content, DX)
        If ok Then
            ok = bgpm.ReadInfo(DX, False)
            'Application.screenUpdating = True
            If ok Then
                ok = bgpm.BreakBrokenLinks
            End If
            If ok Then
'                ok = bgpm.Read(True)
'                If ok Then
                    ok = bgpm.ChangePicturesToV(bgpmFrom)
'                End If
            End If
        End If
        DX.CheckParagraphs
        DX.DocType = GetDocType(Section)
        If DX.DocType = "O & M Document" And DX.FoundCaptionRes Then
            DX.DocType = "O & M Spare Parts Catalogue"
        End If
        If DX.DocType = "" Then
            DX.DocType = "Project Document"
        End If
                    
        ' Read Revisions
        DX.WriteLog "Read revison history"
        
        aRevHist = DX.ReadRevisions()
        Dim revisions As Integer
        Dim showRevision As Boolean
        revisions = UBound(aRevHist, 1) + 1
        If revisions > 0 And aRevHist(0, 0) > "" Then
            showRevision = True
            showFrontMatter = True
            DX.WriteText "/DocumentInfo/DocumentInfo-RevisionHistory-Show", "Standard"
        Else
            showRevision = False
            DX.WriteText "/DocumentInfo/DocumentInfo-RevisionHistory-Show", ""
            aRevHist = DX.ReadRevisionHistoryFromCommnets(comments)
            revisions = UBound(aRevHist, 1) + 1
            If revisions > 0 And aRevHist(0, 0) > "" Then
                showRevision = True
            End If
        End If
        
        If showRevision Then
            DX.WriteText "/DocumentInfo/DocumentInfo-Revision", Replace(aRevHist(revisions - 1, 0), Chr(11), vbCr)
            DX.WriteText "/DocumentInfo/DocumentInfo-Date", Replace(aRevHist(revisions - 1, 1), Chr(11), vbCr)
            DX.WriteText "/DocumentInfo/DocumentInfo-Author", Replace(aRevHist(revisions - 1, 2), Chr(11), vbCr)
            DX.WriteText "/DocumentInfo/DocumentInfo-Description", Replace(aRevHist(revisions - 1, 3), Chr(11), vbCr)
        Else
            DX.WriteText "/DocumentInfo/DocumentInfo-Revision", GetNewMajor("")
            DX.WriteText "/DocumentInfo/DocumentInfo-Date", Format(Now, "YYYY-MM-DD")
            DX.WriteText "/DocumentInfo/DocumentInfo-Author", UserName
            DX.WriteText "/DocumentInfo/DocumentInfo-Description", ""
        End If
        'If revisions > 1 Then
            DX.WriteRevisionHistory aRevHist
        'End If
        
        DX.WriteLog "Read TOC, TOF and TOT"

        ' Read TOC, TOF, TOT
        showFrontMatter = showFrontMatter Or ReadCaptionTOCTOFTOT(ThisDoc, DX)
        
        DX.WriteLog "Apply new styles"
        ' Reload Styles
        ThisDoc.CopyStylesFromTemplate ThisDoc.attachedTemplate.fullName
        
        ' Update XML
        DX.WriteLog "Set paper format"
        DX.NewPaperFormat = paperFormat
        DX.ChangePaperFormat
        
        DX.WriteText "/DocumentInfo/DocumentInfo-DocType", DX.DocType
        DX.WriteText "/DocumentInfo/DocumentInfo-DocMainType", DX.GetPropertyValue(DX.DocType, "DocMainType")
        DX.WriteText "/DocumentInfo/DocumentInfo-HeadingLayout", DX.GetPropertyValue(DX.DocType, "HeadingLayout")
        DX.WriteText "/DocumentInfo/DocumentInfo-FrontMatter", DX.GetPropertyValue(DX.DocType, "FrontMatter")
        DX.WriteText "/DocumentInfo/DocumentInfo-CaptionHeading", DX.GetPropertyValue(DX.DocType, "CaptionHeading")
        DX.WriteText "/DocumentInfo/DocumentInfo-DocumentInformation", DX.GetPropertyValue(DX.DocType, "DocumentInformation")
        DX.WriteText "/DocumentInfo/DocumentInfo-FrontPage", DX.GetPropertyValue(DX.DocType, "FrontPage")
        DX.WriteText "/DocumentInfo/DocumentInfo-RevisionHistory", DX.GetPropertyValue(DX.DocType, "RevisionHistory")
        DX.WriteText "/DocumentInfo/DocumentInfo-TOC", DX.GetPropertyValue(DX.DocType, "TOC")
        DX.WriteText "/DocumentInfo/DocumentInfo-TOC-HeadingLevels", DX.GetPropertyValue(DX.DocType, "TOC-HeadingLevels")
        DX.WriteText "/DocumentInfo/DocumentInfo-TOC-Headings", DX.GetPropertyValue(DX.DocType, "TOC-Headings")
        DX.WriteText "/DocumentInfo/DocumentInfo-TOF", DX.GetPropertyValue(DX.DocType, "TOF")
        DX.WriteText "/DocumentInfo/DocumentInfo-TOT", DX.GetPropertyValue(DX.DocType, "TOT")
        DX.WriteText "/DocumentInfo/DocumentInfo-PDFLayout", DX.GetPropertyValue(DX.DocType, "PDFLayout")
        
        If DX.FoundHeadingOrParmheadOrHeadingPart = False Then
            DX.WriteText "/DocumentInfo/DocumentInfo-TOC", ""
        Else
            DX.WriteText "/DocumentInfo/DocumentInfo-TOC", "Standard"
        End If
        If showFrontMatter Then
            DX.WriteText "/DocumentInfo/DocumentInfo-FrontMatter", ""
        Else
            DX.WriteText "/DocumentInfo/DocumentInfo-FrontMatter", "Hide"
        End If
        
        'DX.WriteText "/DocumentInfo/DocumentInfo-WorkflowLabel", "Conversion Draft"
        
        DX.WriteText "/DocumentInfo/DocumentInfo-TitleLine1", DX.ReplaceRText(Head1)
        DX.WriteText "/DocumentInfo/DocumentInfo-TitleLine2", DX.ReplaceRText(Head2)
        DX.WriteText "/DocumentInfo/DocumentInfo-TitleLine3", DX.ReplaceRText(Head3)
        DX.WriteText "/DocumentInfo/DocumentInfo-TitleLine4", DX.ReplaceRText(Head4)
        
        DX.WriteText "/DocumentInfo/DocumentInfo-DocNo", DX.ReplaceRText(Section)
        DX.WriteText "/DocumentInfo/DocumentInfo-SupplierFileName", DX.ReplaceRText(fromFile.FPJournalExtra)
        
        DX.WriteText "/DocumentInfo/DocumentInfo-DocTitle", CalculateTitle(DX.GetPropertyValue(DX.DocType, "DocTitle", True), DX)
        DX.WriteText "/DocumentInfo/DocumentInfo-DocSearchTitle", CalculateTitle(DX.GetPropertyValue(DX.DocType, "DocSearchTitle", True), DX)
        
        ThisDoc.BuiltInDocumentProperties("Title").value = CalculateTitle(DX.GetPropertyValue(DX.DocType, "Title", True), DX)
        ThisDoc.BuiltInDocumentProperties("Subject").value = CalculateTitle(DX.GetPropertyValue(DX.DocType, "Subject", True), DX)
        
        DX.WriteLog "Delete old front matter"
        
        If showFrontMatter Then DX.MoveTextBoxesToLastPage
        ' Delete Old FrontMatter
        Dim rngDelete As Range
        Dim para As Paragraph
        Dim i As Integer
        Dim rngRevisionTable As Range
       
        If DX.RevisionTableIndex > 0 Then
            Set rngRevisionTable = ThisDoc.Content.Tables(DX.RevisionTableIndex).Range
        End If
        
        If ThisDoc.TablesOfFigures.Count > 0 Then
            i = ThisDoc.TablesOfFigures.Count
            Set rngDelete = ThisDoc.TablesOfFigures(i).Range
            rngDelete.SetRange 0, rngDelete.End
            rngDelete.Delete
            rngDelete.SetRange 0, 1
            Set para = rngDelete.Paragraphs(1)
            Do While Replace(Replace(Trim(para.Range.text), vbCr, ""), vbCrLf, "") = ""
                rngDelete.Delete
                rngDelete.SetRange 0, 1
                Set para = rngDelete.Paragraphs(1)
            Loop
        End If
        
        If ThisDoc.TablesOfContents.Count > 0 Then
            i = ThisDoc.TablesOfContents.Count
            Set rngDelete = ThisDoc.TablesOfContents(i).Range
            rngDelete.SetRange 0, rngDelete.End
            rngDelete.Delete
'            rngDelete.SetRange 0, 1
'            Set para = rngDelete.Paragraphs(1)
'            Do While Replace(Replace(Trim(para.Range.text), vbCr, ""), vbCrLf, "") = ""
'                rngDelete.Delete
'                rngDelete.SetRange 0, 1
'                Set para = rngDelete.Paragraphs(1)
'            Loop
        End If
        
        If DX.RevisionTableIndex > 0 Then
            Set rngDelete = rngRevisionTable.Duplicate
            Set rngRevisionTable = rngRevisionTable.GoTo(What:=wdGoToHeading, Which:=wdGoToPrevious)
            rngRevisionTable.Collapse wdCollapseStart
            rngDelete.SetRange rngRevisionTable.start, rngDelete.End
            rngDelete.Delete
            rngDelete.SetRange rngRevisionTable.start, rngRevisionTable.start
            Set para = rngDelete.Paragraphs(1)
            Dim paraPriv As Paragraph
            Do While Replace(Replace(Trim(para.Range.text), vbCr, ""), vbCrLf, "") = ""
                Set paraPriv = para.Previous
                para.Range.Delete
                Set para = paraPriv
                If para Is Nothing Then Exit Do
            Loop
        End If
        
        If showFrontMatter Then DX.MoveTextBoxesToFirstPage
        
        Dim strt As Long
        Dim rng As Range
        strt = ThisDoc.GoTo(wdGoToPage, wdGoToLast).start
        Set rng = ThisDoc.Range(strt - 1, ActiveDocument.Range.End)
        If rng.End - rng.start = 2 Then
            rng.Delete
        End If
        
        ' Update Document
        DX.DoFixDocument = True
        DX.DoUpdate = True
        DX.DoReadTranslation = False
        DX.LanguageUpdated = True
        DX.UpdateCaptions = True
        DX.ReplaceRegistered = True
                
        DX.UpdateDocument False
        
        ' End Update
        updated = True
        
    End If

    If closeAgain And Not fromDoc Is Nothing Then
        fromDoc.Close wdDoNotSaveChanges
        Set fromDoc = Nothing
    End If
    
   
    ThisDoc.Activate
    
    With ActiveWindow.View
        If .ShowRevisionsAndComments <> DX.ShowRevisionsAndComments Then .ShowRevisionsAndComments = DX.ShowRevisionsAndComments
        If .RevisionsView <> DX.RevisionsView Then .RevisionsView = DX.RevisionsView
    End With
    
TestExit:

    DX.updated = updated
    DX.Epilog
    DoEvents
    If Not DocRibbon Is Nothing Then
        On Error Resume Next
        DocRibbon.ActivateTab "documentTab"
        On Error GoTo 0
    End If
End Sub

Public Function UpdateDocument(Optional screenUpdate As Boolean = False) As Boolean
    DX.UpdateDocument screenUpdate
End Function


Attribute VB_Name = "BGDocManager"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Option Compare Text

Public Docs As Scripting.Dictionary
Public WithEvents App As Word.Application
Attribute App.VB_VarHelpID = -1

Private Sub Class_Initialize()
    'Debug.Print Now, "Class_Initialize"
    Set Docs = New Scripting.Dictionary
    Set App = Application
End Sub

Private Sub Class_Terminate()
    Set Docs = Nothing
    Set App = Nothing
End Sub

Public Function Init(Optional docAdd As Document = Nothing) As BGDocManager
    Dim key As Variant
    Dim found As Boolean
    Dim doc As Document
    
    If Not ReadTemplateComments Then
        ReadTemplate
    End If
    
    If Not FoundUserName Then
        GetUserNameAndDeleteOldFiles
    End If

    If Docs Is Nothing Then Set Docs = New Scripting.Dictionary
    If App Is Nothing Then Set App = Application
    For Each doc In App.Documents
        If Not Docs.Exists(doc.fullName) Then
            Dim isDocAdd As Boolean
            isDocAdd = Not (docAdd Is Nothing)
            If isDocAdd Then isDocAdd = (docAdd Is doc)
            If Not isDocAdd Then
                Debug.Print Now; "  Init_Add"; ": "; doc.fullName;
                Dim bgd As New BGDoc
                bgd.Init Me, doc, dsDocument
                Docs.Add doc.fullName, bgd
            End If
        End If
    Next
    For Each key In Docs.Keys
        found = False
        For Each doc In App.Documents
            If key = doc.fullName Then
                found = True
                Exit For
            End If
        Next
        If Not found Then
            Debug.Print Now; "  Init_Close"; ": "; key
            Set bgd = Docs(key)
            Set bgd.ThisDoc = Nothing
            Set bgd.Manager = Nothing
            Docs.Remove key
        End If
    Next
    Set Init = Me
End Function

' -- Methods --

Public Function AddDoc(doc As Document, stateOpen As BGDocState) As BGDoc
    On Error GoTo Catch
    
    Dim key As Variant
    Dim bgd As BGDoc
    Dim state As BGDocState
    
    If Docs Is Nothing Then
        Init doc
    End If
    
    key = doc.fullName
    If Docs.Exists(key) Then
        Set bgd = Docs(key)
    Else
        Set bgd = New BGDoc
        Docs.Add doc.fullName, bgd
    End If
    
    bgd.Init Me, doc, stateOpen

Finally:
    On Error GoTo 0
    Set AddDoc = bgd
    Exit Function
    
Catch:
    Dim e As New BGError
    e.OnError
    Set bgd = Nothing
    Resume Finally
End Function

Public Function GetBGDoc(doc As Document) As BGDoc
    Dim key As Variant
    Dim bgd As BGDoc
    
    key = doc.fullName
    If Docs.Exists(key) Then
        On Error GoTo SearchOneByOne
        Set bgd = Docs(key)
        On Error GoTo 0
    Else
        Set bgd = Nothing
    End If
    Set GetBGDoc = bgd
    
    Exit Function
    
ResumeSearchOneByOne:
    Dim bgdLooper As BGDoc
    On Error GoTo 0
    For Each bgdLooper In Docs.items
        If bgdLooper.ThisDoc.fullName = key Then
            Set bgd = bgdLooper
            Exit For
        End If
    Next
    If Not bgd Is Nothing Then
        Set GetBGDoc = bgd
    End If
    Exit Function
    
SearchOneByOne:
    Resume ResumeSearchOneByOne
    
End Function

Public Function GetBGDocFromFullName(fullName As String) As BGDoc
    On Error GoTo Catch
    
    Dim key As Variant
    Dim doc As Document
    Dim bgd As BGDoc
    Dim found As Boolean
    found = False
    
    For Each doc In App.Documents
        If fullName = doc.fullName Then
            found = True
            Exit For
        End If
    Next
    
    If Not found Then
        Set bgd = Nothing
    Else
        key = doc.fullName
        If Docs.Exists(key) Then
            Set bgd = Docs(key)
        Else
            Set bgd = Nothing
        End If
    End If
    
Finally:
    On Error GoTo 0
    Set GetBGDocFromFullName = bgd
    Exit Function
   
Catch:
    Dim e As New BGError
    e.OnError
    Set bgd = Nothing
    Resume Finally
End Function

Private Sub App_DocumentChange()
    'Debug.Print Now, "App_DocumentChange"
    On Error GoTo NoDocuments
    If Not ActiveDocument Is Nothing Then
        'GetManager.Init "App_DocumentChange", ActiveDocument.fullName
        'Debug.Print Now, "ChangedTo: "; ActiveDocument.fullName
    Else
        'GetManager.Init "App_DocumentChange", "NoDocument"
        'MsgBox "Last"
    End If
    On Error Resume Next

ExitSub:
    Exit Sub
    
NoDocuments:
    Resume ExitSub

End Sub

Private Sub App_DocumentOpen(ByVal doc As Document)
    'GetManager.Init "App_DocumentOpen", doc.fullName
End Sub

Private Sub App_NewDocument(ByVal doc As Document)
    'GetManager.Init "App_NewDocument", doc.fullName
End Sub

Private Sub App_Quit()
    'GetManager.Init "Quit", ""
End Sub

Private Sub App_WindowActivate(ByVal doc As Document, ByVal Wn As Window)
    'Debug.Print Now, "App_WindowActivate", doc.fullName
    'GetManager.Init "App_WindowActivate", doc.fullName
End Sub

Private Sub App_WindowDeactivate(ByVal doc As Document, ByVal Wn As Window)
    'GetManager.Init "App_WindowDeactivate", doc.fullName
End Sub

Public Function Count() As Integer
    Count = Docs.Count
End Function

'Public Function SaveDoc(fullName As String, Optional saveAs As String = "") As String
'    Dim bgd As BGDoc
'    Dim doc As Document
'
'    If Docs.Exists(fullName) Then
'        Set bgd = Docs(fullName)
'        Set doc = bgd.ThisDoc
'        If doc.Saved And saveAs = "" Then
'            SaveDoc = "NotFound"
'        ElseIf saveAs = "" Then
'            doc.Save
'            SaveDoc = ""
'        Else
'            doc.SaveAs2 saveAs
'            SaveDoc = ""
'        End If
'    Else
'        SaveDoc = "NotFound"
'    End If
'End Function

Private Function SkipSave(doc As Document) As Boolean
    Dim Skip As Boolean
    Skip = False
    ' Skip if another template or is template itself
    Dim attachedTemplate As String
    attachedTemplate = ""
    On Error Resume Next
    attachedTemplate = doc.attachedTemplate
    On Error GoTo 0
    If Not LCase(attachedTemplate) Like "bgdoc.dotm" Then
        Skip = True
    ElseIf LCase(doc.Name) Like "*.dot?" Then
        Skip = True
    End If
    SkipSave = Skip

End Function

Private Sub App_DocumentBeforeClose(ByVal doc As Document, Cancel As Boolean)
    'Debug.Print Now; "  App_DocumentBeforeClose"; ": "; Doc.fullName
    If SkipSave(doc) Then Exit Sub
    
    If doc.Saved Then
        If doc.CanCheckin Then
            Exit Sub
'            If vbOK = MsgBox("The document is checked out. Do you wan't to check it in?", vbOKCancel + vbQuestion, "Closing document") Then
'                Exit Sub
'            Else
'                Cancel = True
'                Exit Sub
'            End If
        Else
            Exit Sub
        End If
    End If
    
    Dim bgd As BGDoc
    Set bgd = GetBGDoc(doc)
    If bgd Is Nothing Then
        Init
        Set bgd = GetBGDoc(doc)
    End If
    ' Handle save
    Dim SavedCancel As Boolean
    Dim ByRefCancel As Boolean
    Dim SavedSaveAsUI As Boolean
    Dim ByRefSaveAsUI As Boolean
    SavedCancel = Cancel
    ByRefCancel = SavedCancel
    SavedSaveAsUI = (doc.fullName = doc.Name)
    ByRefSaveAsUI = SavedSaveAsUI
    
    bgd.HandleSave doc, "DocumentBeforeClose", ByRefCancel, ByRefSaveAsUI
    
    Debug.Print "BeforeClose.ByRefCancel: "; ByRefCancel
    
    Cancel = ByRefCancel
    Set bgd = Nothing

End Sub

Private Sub App_DocumentBeforeSave(ByVal doc As Document, SaveAsUi As Boolean, Cancel As Boolean)
    'Debug.Print Now; "  App_DocumentBeforeSave"; ": "; Doc.fullName
    ' Skip if AutoSave
    Dim inAutoSave As Boolean
    inAutoSave = False
    On Error Resume Next
    inAutoSave = doc.IsInAutosave
    On Error GoTo 0
    If inAutoSave Then Exit Sub
    On Error Resume Next
    inAutoSave = WordBasic.IsAutoSaveEvent
    On Error GoTo 0
    If inAutoSave Then Exit Sub
    If SkipSave(doc) Then Exit Sub
    
    If doc.Saved Then
        If doc.CanCheckin And Not SaveAsUi Then
'            Stop
'            MsgBox "CheckIn?"
'            Cancel = True
'            Exit Sub
        ElseIf SaveAsUi Then
            ' HandleSave
        Else
            'Stop
'            Exit Sub
        End If
    End If
    
    Dim bgd As BGDoc
    Set bgd = GetBGDoc(doc)
    If bgd.InSave Then Exit Sub
    
    Dim SavedCancel As Boolean
    Dim ByRefCancel As Boolean
    Dim SavedSaveAsUI As Boolean
    Dim ByRefSaveAsUI As Boolean
    SavedCancel = Cancel
    ByRefCancel = SavedCancel
    SavedSaveAsUI = SaveAsUi
    ByRefSaveAsUI = SavedSaveAsUI
    
    bgd.HandleSave doc, "DocumentBeforeSave", ByRefCancel, ByRefSaveAsUI
    Cancel = ByRefCancel
    
    'SaveAsUi = ByRefSaveAsUI
    'Debug.Print "BeforeSave.ByRefCancel: "; ByRefCancel
    Set bgd = Nothing
End Sub

Attribute VB_Name = "BGError"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public Description As String 'Description of the error that occurred
Public HelpContext As Long 'Context ID for the Help file
Public HelpFile As String 'Path and filename of the Help file
Public LastDllError As Long 'Last error that occurred in a 32-bit dynamic link library (DLL)
Public Number As Long 'Number of the error that was set
Public source As String 'System in which the error occurred
Public Line As Integer ' Line number where the error occurred
Public ErrorLevel As BGErrorLevel

Private Sub Class_Initialize()
    If Err.Number = 0 Then
        Me.Description = "Object not Found"
        Me.HelpContext = 0
        Me.HelpFile = ""
        Me.LastDllError = 0
        Me.Line = 0
        Me.Number = 514
        Me.source = "'Unknown location'"
        Me.ErrorLevel = elError
    Else
        Me.Description = Err.Description
        Me.HelpContext = Err.HelpContext
        Me.HelpFile = Err.HelpFile
        Me.LastDllError = Err.LastDllError
        Me.Line = Erl
        Me.Number = Err.Number
        Me.source = Err.source
        Me.ErrorLevel = elError
        If Err.HelpFile = "" And Err.HelpContext <> 0 Then
            Me.HelpContext = 0
            Me.ErrorLevel = Err.HelpContext
        End If
    End If
End Sub

Public Function OnError(Optional ProposedErrorLevel As BGErrorLevel = elError) As Boolean
    Dim strError As String
    Dim ReportError As Boolean
    Dim ActualErrorLevel As BGErrorLevel
    ActualErrorLevel = ErrorLevel
    If ActualErrorLevel = elError Then ActualErrorLevel = ProposedErrorLevel
    
    If Line > 0 Then
        strError = "Error in " & source & vbCrLf & vbCrLf & "Error in line : " & Line & vbCrLf & vbCrLf & Description
    Else
        strError = "Error in " & source & vbCrLf & vbCrLf & Description
    End If
    
    Dim strPrompt As String
    strPrompt = "BGdoc Error"
    
    Dim msgBoxResult As VbMsgBoxStyle
    msgBoxResult = vbCritical
    Select Case ActualErrorLevel
    Case elCritical
        msgBoxResult = vbCritical + vbOKOnly
        ReportError = True
    Case elError
        msgBoxResult = vbExclamation + vbOKOnly
        ReportError = True
    Case elWarning
        msgBoxResult = vbExclamation + vbOKOnly
        ReportError = True
    Case elAskStop
        strError = strError & vbCrLf & vbCrLf & "Stop?"
        msgBoxResult = vbQuestion + vbYesNo + vbDefaultButton1
        ReportError = True
    Case elAskContinue
        strError = strError & vbCrLf & vbCrLf & "Continue?"
        msgBoxResult = vbQuestion + vbYesNo + vbDefaultButton2
        ReportError = True
    Case Else
        msgBoxResult = vbInformation + vbOKOnly
        ReportError = True
    End Select
    
    If HelpFile > "" And HelpContext <> 0 Then
        msgBoxResult = msgBoxResult + vbMsgBoxHelpButton
        If msgBoxResult And vbQuestion Then
            ReportError = Not (vbYes = MsgBox(strError, msgBoxResult, strPrompt, HelpFile, HelpContext))
        Else
            MsgBox strError, msgBoxResult, strPrompt, HelpFile, HelpContext
        End If
    Else
        If msgBoxResult And vbQuestion Then
            ReportError = Not (vbYes = MsgBox(strError, msgBoxResult, strPrompt))
        Else
            MsgBox strError, msgBoxResult, strPrompt
        End If
    End If
    
    OnError = ReportError
End Function



Attribute VB_Name = "BGPicture"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public CollectionRange As Range
Public doc As Document
Public key As String
Public IsPictureOrObject As Boolean
Public HasPictureFormat As Boolean
Public HasCrop As Boolean
Public HasPictureFormatCrop As Boolean
Public HasPictureFormatCropTopLeft As Boolean
Public Disk As String
Public ShapeType As String
Public WordFile As String
Public Selected As Boolean
Public TypeOfPicture As PictureType
Public Missing As Boolean
Public saveAs As String
Public MaybeFoundAt As String
Public SourceDate As Date
Public OutOfDate As Boolean
Public Range As Range
Public Hyperlink As Hyperlink
Public IsLinked As Boolean
Public LinkType As String
Public InvalidLink As Boolean
Public LinkFormat As LinkFormat
Public InlineShape As InlineShape
Public SavePictureWithDocument As Boolean
Public Shape As Shape
Public image As image
Public Title As String
Public SourcePath As String
Public SourceName As String
Public sourceFullName As String
Public SourceExtension As String
Public AlternativeText As String
Public HyperlinkAddress As String
Public HyperlinkText As String
Public page As Integer
Public INLIndex As Integer
Public SHPIndex As Integer
Public IsField As Boolean
Public field As field
Public FieldCode As String
Public FieldCount As Integer
Public caption As String

Public RangeStart As Long
Public RangeEnd As Long

Public Top As Single
Public Left As Single

Public Height As Single
Public Width As Single
Public CropLeft As Single
Public CropTop As Single
Public CropRight As Single
Public CropBottom As Single
Public Brightness As Single
Public Contrast As Single
Public Rotation As Single
Public ColorType As MsoPictureColorType

Public LockAspectRatio As MsoTriState
Public LineVisible As MsoTriState
Public LineTransparency As Single
Public LineWeight As Single

Public FillVisible As MsoTriState
Public FillTransparency As Single
Public FillBackColor As ColorFormat
Public FillForeColor As ColorFormat

Public CropPictureHeight As Single
Public CropPictureOffsetX As Single
Public CropPictureOffsetY As Single
Public CropPictureWidth As Single
Public CropShapeHeight As Single
Public CropShapeLeft As Single
Public CropShapeTop As Single
Public CropShapeWidth As Single

Public FoundFile As String
Public HasAutoUpdate As Boolean
Public AutoUpdate As Boolean
Public LinkFormatType As WdLinkType

Public RelativeVerticalPosition As WdRelativeVerticalPosition
Public RelativeHorizontalPosition As WdRelativeHorizontalPosition
Public RelativeVerticalSize As WdRelativeVerticalSize
Public RelativeHorizontalSize As WdRelativeHorizontalSize

Public IsEmbed As Boolean

Private Function ReadInline(DX As DOCXML, Optional doFindFile As Boolean = False, Optional findPage As Boolean = False, Optional findCaption As Boolean = False, Optional force As Boolean = False) As Boolean
On Error GoTo Failed
    Dim ok As Boolean
    Dim shp As InlineShape
    Dim fld As field
    Dim rng As Range
    Dim rngCaption As Range
    Dim resumeAt As String

    Set shp = InlineShape ' CollectionRange.InlineShapes(INLIndex)
    Set rng = shp.Range.Duplicate
    RangeStart = shp.Range.start
    RangeEnd = shp.Range.End
    Set Range = rng
    
    IsPictureOrObject = InlineIsPictureOrObject(shp)
    If Not shp.LinkFormat Is Nothing Then
        Me.IsLinked = True
        Me.LinkFormat = shp.LinkFormat
        If Me.FoundFile = "" Or doFindFile Then
            If force Then
                shp.Range.fields.Update
                If rng.InlineShapes.Count > 0 Then
                    Set shp = rng.InlineShapes(1)
                    Set Me.InlineShape = shp
                    Set rng = shp.Range.Duplicate
                    RangeStart = shp.Range.start
                    RangeEnd = shp.Range.End
                    Set Range = rng
                Else
                    Set shp = Nothing
                    ReadInline = False
                    Exit Function
                End If
            End If
            If Not shp Is Nothing Then
                Me.sourceFullName = shp.LinkFormat.sourceFullName
                Me.SourceName = shp.LinkFormat.SourceName
                Me.SourcePath = shp.LinkFormat.SourcePath
                Me.SavePictureWithDocument = shp.LinkFormat.SavePictureWithDocument
                Me.LinkFormatType = shp.LinkFormat.Type
                Me.HasAutoUpdate = True
                Me.AutoUpdate = False
                On Error Resume Next
                Me.AutoUpdate = shp.LinkFormat.AutoUpdate
                If Err.Number > 0 Then
                    Me.HasAutoUpdate = False
                Else
                    Me.HasAutoUpdate = True
                End If
            End If
            On Error GoTo Failed
        End If
    Else
        Me.IsLinked = False
        Me.sourceFullName = ""
        Me.SourceName = ""
        Me.SourcePath = ""
        Me.SavePictureWithDocument = True
        Me.LinkFormatType = 0
        Me.HasAutoUpdate = False
        Me.AutoUpdate = False
    End If
    
    If findPage Then
        Me.page = shp.Range.Information(wdActiveEndPageNumber)
    End If
    
    If findCaption Then
        On Error Resume Next
        Set rngCaption = Nothing
        Set rngCaption = rng.Paragraphs.Last.Next.Range
        On Error GoTo Failed
        If Not rngCaption Is Nothing Then
            If rngCaption.Parent.Styles(rngCaption.Style) = rngCaption.Parent.Styles(wdStyleCaption) Then
                Me.caption = Replace(Replace(rngCaption.text, vbTab, " "), vbCr, "")
            End If
        End If
    End If
    Me.AlternativeText = shp.AlternativeText
    Me.Disk = "Embedded"
    If Me.sourceFullName > "" Then
        If Me.LinkFormat.SavePictureWithDocument Then
            Me.Disk = "Linked and embedded. Not checked"
        Else
            Me.Disk = "Linked only!. Not checked"
        End If
    End If
    If doFindFile And Me.sourceFullName > "" Then
        Me.FoundFile = findFile(sourceFullName)
        If Me.FoundFile = "" And Not rng Is Nothing Then
            For Each fld In rng.fields
'                If fld.Type = wdFieldIncludePicture Then
'                    Debug.Print "wdFieldIncludePicture ", Trim(fld.code) ' , GetFileNameFromCode(fld.code), FindFile(GetFileNameFromCode(fld.code))
'                ElseIf fld.Type = wdFieldEmbed Then
'                    Debug.Print "wdFieldEmbed          ", Trim(fld.code) ' , GetFileNameFromCode(fld.code), FindFile(GetFileNameFromCode(fld.code))
'                ElseIf fld.Type = wdFieldShape Then
'                    Debug.Print "wdFieldShape          ", Trim(fld.code)
'                Else
'                    Debug.Print fld.Type, Trim(fld.code)
'                End If
                Me.FoundFile = findFile(GetFileNameFromCode(fld.code))
                If Me.FoundFile > "" Then
                    Exit For
                End If
            Next
        End If
        If Me.FoundFile = "" And Not rng Is Nothing Then
            If InStr(sourceFullName, "/") > 0 Then
                Me.FoundFile = FindDocumentationFile(Replace(sourceFullName, "/", "\"), shp.Parent.path)
            End If
        End If
        If Me.FoundFile = "" And Not rng Is Nothing Then
            Me.FoundFile = FindDocumentationFile(sourceFullName, shp.Parent.path)
        End If
        
        If Me.FoundFile = "" And Me.SavePictureWithDocument = False Then
            Me.Disk = "Missing in document and on disk!"
        ElseIf Me.FoundFile = "" Then
            Me.Disk = "Missing on disk!"
        Else
            Dim dtFile As Date
            dtFile = GetFileDate(Me.FoundFile)
            Me.SourceDate = dtFile
            If dtFile > DX.OrgFileDate Then
                OutOfDate = True
                Me.AlternativeText = UpdateAlternativeText(Me.InlineShape.AlternativeText, "OutOfDate", UTCTime(Now))
            Else
                OutOfDate = False
            End If
            Dim dtLastSaved As Date
            Dim dtUpdated As Date
            Dim Saved As Boolean
            Saved = True
            dtLastSaved = shp.Range.Parent.BuiltInDocumentProperties(12)
            dtUpdated = GetTime(Me.AlternativeText, "Updated")
            If dtLastSaved < dtUpdated Then
                dtLastSaved = dtUpdated
            End If
            If dtLastSaved < #1/1/1950# Then
                Saved = False
                dtLastSaved = Now - 0.5
            End If
            If dtFile = #12:00:00 PM# Then
                Me.Disk = "Error reading disk."
            ElseIf Me.SavePictureWithDocument = False Then
                Me.Disk = "Linked only!"
            ElseIf dtFile < dtLastSaved Then
                Me.Disk = "Embedded and linked"
            ElseIf Format(dtFile, "YYYY-MM-DD") = Format(Now, "YYYY-MM-DD") Then
                Me.Disk = "Edited Today " & Format(dtFile, "HH:mm")
            ElseIf Format(dtFile + 1, "YYYY-MM-DD") = Format(Now, "YYYY-MM-DD") Then
                Me.Disk = "Edited Yesterday " & Format(dtFile, "HH:mm")
            Else
                Me.Disk = "Edited " & Format(dtFile, "YYYY-MM-DD HH:mm")
            End If
        End If
        Me.AlternativeText = UpdateAlternativeText(Me.AlternativeText, "Checked")
    End If
    'Me.InlineShape.Reset
ExitIt:
    On Error GoTo 0
    ReadInline = ok
    Exit Function
   
Failed:
    Select Case Err.Number
    Case 91 'Object variable or With block variable not set
        Resume Next
    Case 4198 'Command failed
        Resume Next
    Case 5825: 'Object has been deleted.
        Resume Next
    Case Else
        Debug.Print "Case " & Err.Number & " '" & Err.Description
        Stop
        Resume Next
        ok = False
        Resume ExitIt
    End Select
End Function

Private Function ReadShape(DX As DOCXML, Optional doFindFile As Boolean = False, Optional findPage As Boolean = False, Optional findCaption As Boolean = False, Optional force As Boolean = False) As Boolean
On Error GoTo Failed
    Dim ok As Boolean
    Dim shp As Shape
    Dim fld As field
    Dim rng As Range
    Dim rngCaption As Range
    Dim resumeAt As String

    Set shp = Shape 'CollectionRange.ShapeRange(SHPIndex)
    Set rng = shp.Anchor.Duplicate
    RangeStart = shp.Anchor.start
    RangeEnd = shp.Anchor.End
    Set Range = rng
    
    IsPictureOrObject = ShapeIsPictureOrObject(shp)
    
    If Not shp.LinkFormat Is Nothing Then
        IsLinked = True
        If Me.FoundFile = "" Then
            If force Then
                shp.Anchor.fields.Update
            End If
            Me.sourceFullName = shp.LinkFormat.sourceFullName
            Me.SourceName = shp.LinkFormat.SourceName
            Me.SourcePath = shp.LinkFormat.SourcePath
            Me.SavePictureWithDocument = shp.LinkFormat.SavePictureWithDocument
            Me.LinkFormatType = shp.LinkFormat.Type
            Me.HasAutoUpdate = True
            Me.AutoUpdate = False
            On Error Resume Next
            Me.AutoUpdate = shp.LinkFormat.AutoUpdate
            If Err.Number > 0 Then
                Me.HasAutoUpdate = False
            Else
                Me.HasAutoUpdate = True
            End If
            On Error GoTo Failed
        End If
    Else
        Me.IsLinked = False
        Me.sourceFullName = ""
        Me.SourceName = ""
        Me.SourcePath = ""
        Me.SavePictureWithDocument = True
        Me.LinkFormatType = 0
        Me.HasAutoUpdate = False
        Me.AutoUpdate = False
    End If
    
    If findPage Then
        Me.page = shp.Anchor.Information(wdActiveEndPageNumber)
    End If
    
    If findCaption Then
        On Error Resume Next
        Set rngCaption = Nothing
        Set rngCaption = rng.Paragraphs.Last.Next.Range
        On Error GoTo Failed
        If Not rngCaption Is Nothing Then
            If rngCaption.Parent.Styles(rngCaption.Style) = rngCaption.Parent.Styles(wdStyleCaption) Then
                Me.caption = Replace(Replace(rngCaption.text, vbTab, " "), vbCr, "")
            End If
        End If
    End If
    
    Me.AlternativeText = shp.AlternativeText
    Me.Disk = "Embedded"
    If Me.sourceFullName > "" Then
        If Me.LinkFormat.SavePictureWithDocument Then
            Me.Disk = "Embedded and linked. Not checked"
        Else
            Me.Disk = "Linked only!. Not checked"
        End If
    End If
    If doFindFile And Me.sourceFullName > "" Then
        Me.FoundFile = findFile(sourceFullName)
        If Me.FoundFile = "" Then
            For Each fld In rng.fields
'                If fld.Type = wdFieldIncludePicture Then
'                    Debug.Print "wdFieldIncludePicture ", Trim(fld.code) ' , GetFileNameFromCode(fld.code), FindFile(GetFileNameFromCode(fld.code))
'                ElseIf fld.Type = wdFieldEmbed Then
'                    Debug.Print "wdFieldEmbed          ", Trim(fld.code) ' , GetFileNameFromCode(fld.code), FindFile(GetFileNameFromCode(fld.code))
'                ElseIf fld.Type = wdFieldShape Then
'                    Debug.Print "wdFieldShape          ", Trim(fld.code)
'                Else
'                    Debug.Print fld.Type, Trim(fld.code)
'                End If
                Me.FoundFile = findFile(GetFileNameFromCode(fld.code))
                If Me.FoundFile > "" Then
                    Exit For
                End If
            Next
        End If
        If Me.FoundFile = "" Then
            If InStr(sourceFullName, "/") > 0 Then
                Me.FoundFile = FindDocumentationFile(Replace(sourceFullName, "/", "\"), shp.Parent.path)
            End If
        End If
        If Me.FoundFile = "" Then
            Me.FoundFile = FindDocumentationFile(sourceFullName, shp.Parent.path)
        End If

        If Me.FoundFile = "" And Me.SavePictureWithDocument = False Then
           Me.Disk = "Missing in document and on disk!"
        ElseIf Me.FoundFile = "" Then
            Me.Disk = "Missing on disk!"
        Else
            Dim dtFile As Date
            dtFile = GetFileDate(Me.FoundFile)
            If dtFile > DX.OrgFileDate Then
                OutOfDate = True
                Me.AlternativeText = UpdateAlternativeText(Me.AlternativeText, "OutOfDate", UTCTime(Now))
            Else
                OutOfDate = False
            End If
            Dim dtLastSaved As Date
            Dim dtUpdated As Date
            Dim Saved As Boolean
            Saved = True
            dtLastSaved = shp.Anchor.Parent.BuiltInDocumentProperties(12)
            dtUpdated = GetTime(Me.AlternativeText, "Updated")
            If dtLastSaved < dtUpdated Then
                dtLastSaved = dtUpdated
            End If
            If dtLastSaved < #1/1/1950# Then
                Saved = False
                dtLastSaved = Now - 0.5
            End If
            If dtFile = #12:00:00 PM# Then
                Me.Disk = "Error reading disk."
            ElseIf Me.SavePictureWithDocument = False Then
                Me.Disk = "Linked only!"
            ElseIf dtFile < dtLastSaved Then
                Me.Disk = "Embedded and linked"
            ElseIf Format(dtFile, "YYYY-MM-DD") = Format(Now, "YYYY-MM-DD") Then
                Me.Disk = "Edited Today " & Format(dtFile, "HH:mm")
            ElseIf Format(dtFile + 1, "YYYY-MM-DD") = Format(Now, "YYYY-MM-DD") Then
                Me.Disk = "Edited Yesterday " & Format(dtFile, "HH:mm")
            Else
                Me.Disk = "Edited " & Format(dtFile, "YYYY-MM-DD HH:mm")
            End If
        End If
        Me.AlternativeText = UpdateAlternativeText(Me.AlternativeText, "Checked")
    End If

ExitIt:
    On Error GoTo 0
    ReadShape = ok
    Exit Function
    
Failed:
    Select Case Err.Number
    Case 91 'Object variable or With block variable not set
        Resume Next
    Case 4198 'Command failed
        Resume Next
    Case 5825: 'Object has been deleted.
        Resume Next
    Case Else
        Debug.Print "Case " & Err.Number & " '" & Err.Description
        Stop
        Resume Next
        ok = False
        Resume ExitIt
    End Select
End Function

Public Function Read(DX As DOCXML, Optional findFile As Boolean = True, Optional findPage As Boolean = False, Optional findCaption As Boolean = False, Optional force As Boolean = False) As Boolean
    If Me.TypeOfPicture = PictureType.InlineType Then
        ShapeType = "Inline"
        Read = ReadInline(DX, findFile, findPage, findCaption, force)
    ElseIf Me.TypeOfPicture = PictureType.ShapeType Then
        ShapeType = "Shape"
        Read = ReadShape(DX, findFile, findPage, findCaption, force)
'    ElseIf Me.TypeOfPicture = PictureType.Embed Then
'        ShapeType = "Embed"
'        Read = ReadEmbed
    Else
        Read = False
    End If
    
    
End Function

Public Sub AddIDInAltText(DX As DOCXML)
On Error GoTo Failed
  Dim rng As Range

' Insert Error Handling
    If Me.TypeOfPicture = PictureType.InlineType Then
        InlineShape.AlternativeText = InlineShape.AlternativeText & "[ID:" & key & "]"
    ElseIf Me.TypeOfPicture = PictureType.ShapeType Then
        Shape.AlternativeText = Shape.AlternativeText & "[ID:" & key & "]"
    Else
        Stop
    End If
    On Error GoTo 0
    Exit Sub
    
ResumeUnknown:
    On Error GoTo UnableToDeletePicture
    DX.AddError "Search for text '[[Unknown Error]]' in converted document:" & key & ", " & Me.saveAs & ". Orginal may need to be fixed."
    If Me.TypeOfPicture = PictureType.InlineType Then
        Set rng = InlineShape.Range.Duplicate
        InlineShape.Delete
    ElseIf Me.TypeOfPicture = PictureType.ShapeType Then
        Set rng = InlineShape.Range.Duplicate
        Shape.Delete
    End If
    rng.text = "[[Unknown Error]]"
    Exit Sub
    
ResumeFailed:
    On Error GoTo UnableToDeletePicture
    DX.AddError "Search for text '[[Deleted picture]]' in converted document:" & key & ", " & Me.saveAs & ". Orginal may need to be fixed."
    If Me.TypeOfPicture = PictureType.InlineType Then
        Set rng = InlineShape.Range.Duplicate
        InlineShape.Delete
    ElseIf Me.TypeOfPicture = PictureType.ShapeType Then
        Set rng = InlineShape.Range.Duplicate
        Shape.Delete
    End If
    rng.text = "[[Deleted picture]]"
    Exit Sub
    
UnableToDeletePicture:
    On Error GoTo 0
    DX.AddError "Search for text '[[Unable to delete picture]]' in converted document:" & key & ", " & Me.saveAs & ". Orginal may need to be fixed."
    rng.Collapse wdCollapseStart
    rng.text = "[[Unable to delete picture]]"
    Exit Sub
Failed:
    Select Case Err.Number
    Case 4198
        Resume ResumeFailed
    Case Else
        Resume ResumeUnknown
    End Select

End Sub

Public Function ReadFormat() As Boolean
On Error GoTo Failed
    Dim ok As Boolean
    Dim shp As Object
    Dim ishp As InlineShape
    Dim sShp As Shape
    
    Dim fld As field
    Dim rng As Range
    Dim resumeAt As String

    HasPictureFormat = True
    HasCrop = True
    HasPictureFormatCrop = True
    HasPictureFormatCropTopLeft = True

    If Me.TypeOfPicture = PictureType.InlineType Then
        Set shp = Me.InlineShape
    ElseIf Me.TypeOfPicture = PictureType.ShapeType Then
        Set shp = Me.Shape
    ElseIf Me.TypeOfPicture = PictureType.EmbedType Then
        Stop
    End If
    resumeAt = "Next"
    Me.LockAspectRatio = shp.LockAspectRatio
    Me.FillVisible = shp.Fill.Visible
    Me.FillTransparency = shp.Fill.Transparency
    Me.LineWeight = shp.Line.Weight
    Me.LineTransparency = shp.Line.Transparency
    Me.LineVisible = shp.Line.Visible
    Me.LockAspectRatio = shp.LockAspectRatio
    Me.Height = shp.Height
    Me.Width = shp.Width
    Me.AlternativeText = shp.AlternativeText
    
    If Me.TypeOfPicture = PictureType.ShapeType Then
        Me.Top = shp.Top
        Me.Left = shp.Left
        Me.RelativeHorizontalPosition = shp.RelativeHorizontalPosition
        Me.RelativeVerticalPosition = shp.RelativeVerticalPosition
        Me.RelativeHorizontalSize = shp.RelativeHorizontalSize
        Me.RelativeVerticalSize = shp.RelativeVerticalSize
        Me.Rotation = shp.Rotation
    End If
    
    resumeAt = "ResumeNoPictureFormat"
    If Not shp.PictureFormat Is Nothing Then
        resumeAt = "Next"
        Me.Brightness = shp.PictureFormat.Brightness
        Me.Contrast = shp.PictureFormat.Contrast
        Me.ColorType = shp.PictureFormat.ColorType
        resumeAt = "ResumeNoCrop"
        Me.CropLeft = shp.PictureFormat.CropLeft
        Me.CropRight = shp.PictureFormat.CropRight
        Me.CropTop = shp.PictureFormat.CropTop
        Me.CropBottom = shp.PictureFormat.CropBottom
ResumeNoCrop:
        resumeAt = "ResumeNoPictureFormatCrop"
        Me.CropPictureHeight = shp.PictureFormat.Crop.PictureHeight
        Me.CropPictureOffsetX = shp.PictureFormat.Crop.PictureOffsetX
        Me.CropPictureOffsetY = shp.PictureFormat.Crop.PictureOffsetY
        Me.CropPictureWidth = shp.PictureFormat.Crop.PictureWidth
        Me.CropShapeHeight = shp.PictureFormat.Crop.ShapeHeight
        Me.CropShapeWidth = shp.PictureFormat.Crop.ShapeWidth
        resumeAt = "ResumeNoPictureFormatCropTopLeft"
        Me.CropShapeLeft = shp.PictureFormat.Crop.ShapeLeft
        Me.CropShapeTop = shp.PictureFormat.Crop.ShapeTop
    End If
ResumeNoPictureFormat:
    resumeAt = ""
    ok = True
    
ExitIt:
    On Error GoTo 0
    ReadFormat = ok
    Exit Function

Failed:
    Select Case Err.Number
    Case -2147024891, -2147024809, 438, 445
        'This member can only be accessed for a picture or an OLE object.
        'Operation is not supported by the current object
        'Object doesn't support this property or method,
        'Object doesn't support this action
        If resumeAt = "ResumeNoPictureFormat" Then
            HasPictureFormat = False
            HasCrop = False
            HasPictureFormatCrop = False
            HasPictureFormatCropTopLeft = False
            Resume ResumeNoPictureFormat
        ElseIf resumeAt = "ResumeNoCrop" Then
            HasCrop = False
            Resume ResumeNoCrop
        ElseIf resumeAt = "ResumeNoPictureFormatCrop" Then
            HasPictureFormatCrop = False
            HasPictureFormatCropTopLeft = False
            Resume ResumeNoPictureFormat
        ElseIf resumeAt = "ResumeNoPictureFormatCropTopLeft" Then
            HasPictureFormatCropTopLeft = False
            Resume ResumeNoPictureFormat
        ElseIf resumeAt = "Next" Then
            Resume Next
        Else
            Stop
        End If
    Case Else
        Debug.Print "Case " & Err.Number & " '" & Err.Description
        ok = False
        Resume ExitIt
    End Select
End Function

Public Function WriteFormat(Optional ByVal bgpFrom As BGPicture = Nothing) As Boolean
On Error GoTo Failed
    Dim ok As Boolean
    Dim shp As Object
    Dim fld As field
    Dim rng As Range
    Dim rngInsert As Range
    Dim resumeAt As String
    
    If Me.TypeOfPicture = PictureType.InlineType Then
        Set shp = InlineShape
        Set rng = shp.Range.Duplicate
        RangeStart = shp.Range.start
        RangeEnd = shp.Range.End
    ElseIf Me.TypeOfPicture = PictureType.ShapeType Then
        Set shp = Shape
        Set rng = shp.Anchor.Duplicate
        RangeStart = shp.Anchor.start
        RangeEnd = shp.Anchor.End
    ElseIf bgpFrom.TypeOfPicture = PictureType.EmbedType Then
        Stop
    End If
    
    If bgpFrom Is Nothing Then Set bgpFrom = Me
    
    If bgpFrom.TypeOfPicture = PictureType.ShapeType Then
        'Application.screenUpdating = True
        shp.RelativeHorizontalPosition = bgpFrom.RelativeHorizontalPosition
        shp.RelativeVerticalPosition = bgpFrom.RelativeVerticalPosition
        shp.RelativeHorizontalSize = bgpFrom.RelativeHorizontalSize
        shp.RelativeVerticalSize = bgpFrom.RelativeVerticalSize
        shp.Rotation = bgpFrom.Rotation
        'Application.screenUpdating = False
    End If
    
    
'    shp.Fill.Visible = bgpFrom.FillVisible
'    If bgpFrom.FillTransparency > -2147483640# Then shp.Fill.Transparency = bgpFrom.FillTransparency
'    If bgpFrom.LineWeight > -2147483640# Then shp.Line.Weight = bgpFrom.LineWeight
'    If bgpFrom.LineTransparency > -2147483640# Then shp.Line.Transparency = bgpFrom.LineTransparency
'    shp.Line.Visible = bgpFrom.LineVisible
'    shp.LockAspectRatio = bgpFrom.LockAspectRatio
    
    shp.LockAspectRatio = False
    shp.Height = bgpFrom.Height
    shp.Width = bgpFrom.Width

'    If bgpFrom.Top > -2147483640# Then shp.Top = bgpFrom.Top
'    If bgpFrom.Left > -2147483640# Then shp.Left = bgpFrom.Left

'    resumeAt = "Next"
    
    resumeAt = "ResumeNoPictureFormat"
    If bgpFrom.HasPictureFormatCrop And Me.HasPictureFormatCrop Then
        If bgpFrom.CropPictureHeight > -2147483640# Then shp.PictureFormat.Crop.PictureHeight = bgpFrom.CropPictureHeight
        If bgpFrom.CropPictureOffsetX > -2147483640# Then shp.PictureFormat.Crop.PictureOffsetX = bgpFrom.CropPictureOffsetX
        If bgpFrom.CropPictureOffsetY > -2147483640# Then shp.PictureFormat.Crop.PictureOffsetY = bgpFrom.CropPictureOffsetY
        If bgpFrom.CropPictureWidth > -2147483640# Then shp.PictureFormat.Crop.PictureWidth = bgpFrom.CropPictureWidth
        If bgpFrom.CropShapeHeight > -2147483640# Then shp.PictureFormat.Crop.ShapeHeight = bgpFrom.CropShapeHeight
        If bgpFrom.CropShapeWidth > -2147483640# Then shp.PictureFormat.Crop.ShapeWidth = bgpFrom.CropShapeWidth
        If bgpFrom.HasPictureFormatCropTopLeft And Me.HasPictureFormatCropTopLeft Then
            If bgpFrom.CropShapeLeft > -2147483640# Then shp.PictureFormat.Crop.ShapeLeft = bgpFrom.CropShapeLeft
            If bgpFrom.CropShapeTop > -2147483640# Then shp.PictureFormat.Crop.ShapeTop = bgpFrom.CropShapeTop
        End If
    ElseIf bgpFrom.HasPictureFormat And Me.HasPictureFormat Then
        shp.PictureFormat.Brightness = bgpFrom.Brightness
        shp.PictureFormat.Contrast = bgpFrom.Contrast
        shp.PictureFormat.ColorType = bgpFrom.ColorType
        If bgpFrom.CropLeft > -2147483640# Then shp.PictureFormat.CropLeft = bgpFrom.CropLeft
        If bgpFrom.CropTop > -2147483640# Then shp.PictureFormat.CropTop = bgpFrom.CropTop
        If bgpFrom.CropBottom > -2147483640# Then shp.PictureFormat.CropBottom = bgpFrom.CropBottom
        If bgpFrom.CropRight > -2147483640# Then shp.PictureFormat.CropRight = bgpFrom.CropRight
    End If

    shp.LockAspectRatio = Me.LockAspectRatio

ResumeNoPictureFormat:
    resumeAt = ""
    ok = True
    
ExitIt:
    On Error GoTo 0
    WriteFormat = ok
    Exit Function

Failed:
    Select Case Err.Number
    Case -2147024891 'This member can only be accessed for a picture or an OLE object.
        If resumeAt = "ResumeNoPictureFormat" Then
            Resume ResumeNoPictureFormat
        Else
            Stop
        End If
    Case 438, 445 'Object doesn't support this property or method, 'Object doesn't support this action
        If resumeAt = "Next" Then
            Resume Next
        Else
            Stop
        End If
    Case -2147024809, 5 'Operation is not supported by the current object, 'Invalid procedure call or argument
        If resumeAt = "Next" Then
            Resume Next
        ElseIf resumeAt = "ResumeNoPictureFormat" Then 'The specified parameter has an invalid value.
            Resume Next
        Else
            Debug.Print vbTab & "Case " & Err.Number & " '" & Err.Description
            Stop
        End If
    Case Else
        Debug.Print vbTab & "Case " & Err.Number & " '" & Err.Description
        Stop
    End Select
End Function

Public Function ReApplyFormat() As Boolean
On Error GoTo Failed
    Dim ok As Boolean
    Dim shp As Object
    Dim fld As field
    Dim rng As Range
    Dim rngInsert As Range
    Dim resumeAt As String
    
    If TypeOfPicture = PictureType.InlineType Then
        Set shp = InlineShape
        Set rng = shp.Range.Duplicate
    ElseIf TypeOfPicture = PictureType.ShapeType Then
        Set shp = Shape
        Set rng = shp.Anchor.Duplicate
    ElseIf Me.TypeOfPicture = PictureType.EmbedType Then
        Stop
    End If
    
    shp.LockAspectRatio = False
    shp.Height = Height
    shp.Width = Width
    shp.AlternativeText = Me.AlternativeText

    resumeAt = "ResumeNoPictureFormat"
    If HasPictureFormatCrop And Me.HasPictureFormatCrop Then
        If CropPictureHeight > -2147483640# Then shp.PictureFormat.Crop.PictureHeight = CropPictureHeight
        If CropPictureOffsetX > -2147483640# Then shp.PictureFormat.Crop.PictureOffsetX = CropPictureOffsetX
        If CropPictureOffsetY > -2147483640# Then shp.PictureFormat.Crop.PictureOffsetY = CropPictureOffsetY
        If CropPictureWidth > -2147483640# Then shp.PictureFormat.Crop.PictureWidth = CropPictureWidth
        If CropShapeHeight > -2147483640# Then shp.PictureFormat.Crop.ShapeHeight = CropShapeHeight
        If CropShapeWidth > -2147483640# Then shp.PictureFormat.Crop.ShapeWidth = CropShapeWidth
        If HasPictureFormatCropTopLeft And Me.HasPictureFormatCropTopLeft Then
            If CropShapeLeft > -2147483640# Then shp.PictureFormat.Crop.ShapeLeft = CropShapeLeft
            If CropShapeTop > -2147483640# Then shp.PictureFormat.Crop.ShapeTop = CropShapeTop
        End If
    ElseIf HasPictureFormat And Me.HasPictureFormat Then
        resumeAt = "Next"
        shp.PictureFormat.Brightness = Brightness
        shp.PictureFormat.Contrast = Contrast
        shp.PictureFormat.ColorType = ColorType
        If CropLeft > -2147483640# Then shp.PictureFormat.CropLeft = CropLeft
        If CropTop > -2147483640# Then shp.PictureFormat.CropTop = CropTop
        If CropBottom > -2147483640# Then shp.PictureFormat.CropBottom = CropBottom
        If CropRight > -2147483640# Then shp.PictureFormat.CropRight = CropRight
    End If

    shp.LockAspectRatio = Me.LockAspectRatio

ResumeNoPictureFormat:
    resumeAt = ""
    ok = True
    
ExitIt:
    On Error GoTo 0
    ReApplyFormat = ok
    Exit Function

Failed:
    Select Case Err.Number
    Case -2147024891 'This member can only be accessed for a picture or an OLE object.
        If resumeAt = "ResumeNoPictureFormat" Then
            Resume ResumeNoPictureFormat
        Else
            Stop
        End If
    Case 438, 445 'Object doesn't support this property or method, 'Object doesn't support this action
        If resumeAt = "Next" Then
            Resume Next
        Else
            Stop
        End If
    Case -2147024809 'Operation is not supported by the current object
        If resumeAt = "Next" Then
            Resume Next
        Else
            Stop
        End If
    Case 5 'Invalid procedure call or argument
        If resumeAt = "Next" Then
            Resume Next
        Else
            Debug.Print vbTab & "Case " & Err.Number & " '" & Err.Description
            Stop
        End If
    Case Else
        Debug.Print vbTab & "Case " & Err.Number & " '" & Err.Description
        Stop
    End Select
End Function


Public Function BreakLink() As Boolean
On Error GoTo Failed
    Dim ok As Boolean
    Dim shp As Object
    Dim fld As field
    Dim rng As Range
    Dim rngInsert As Range
    
    Dim resumeAt As String

    If Me.TypeOfPicture = PictureType.InlineType Then
        Set shp = InlineShape
        Set rng = shp.Range.Duplicate
        RangeStart = shp.Range.start
        RangeEnd = shp.Range.End
    ElseIf Me.TypeOfPicture = PictureType.ShapeType Then
        Set shp = Shape
        Set rng = shp.Anchor.Duplicate
        RangeStart = shp.Anchor.start
        RangeEnd = shp.Anchor.End
    ElseIf Me.TypeOfPicture = PictureType.EmbedType Then
        Stop
    End If
    
    
    If (Me.sourceFullName > "" And Me.FoundFile = "") Then
        Dim tempImageName As String
        Dim inlDelete As InlineShape
        Dim rngDelete As Range
        If Me.TypeOfPicture = PictureType.InlineType Then
            Set rngInsert = shp.Range.Duplicate
            Set rngDelete = shp.Range.Duplicate
            tempImageName = WriteToTemporaryPictureFile()
            rngDelete.Delete
            Set shp = rngInsert.InlineShapes.AddPicture(tempImageName, False, True, rngInsert)
        ElseIf Me.TypeOfPicture = PictureType.ShapeType Then
            Set rngInsert = shp.Anchor.Duplicate
            Set rngDelete = shp.Anchor.Duplicate
            tempImageName = WriteToTemporaryPictureFile()
            rngDelete.Delete
            Dim inl As InlineShape
            Set inl = rngInsert.InlineShapes.AddPicture(tempImageName, False, True, rngInsert)
            Set shp = inl.ConvertToShape
        End If
        KillFilesAndFolder tempImageName
    Else
        If Not shp.LinkFormat Is Nothing Then
            shp.LinkFormat.BreakLink
        End If
    End If
    sourceFullName = ""
    SourceExtension = ""
    SourceName = ""
    SourcePath = ""
    
    If Me.TypeOfPicture = PictureType.InlineType Then
        Set InlineShape = shp
        Set rng = shp.Range.Duplicate
        Set Range = rng
        RangeStart = shp.Range.start
        RangeEnd = shp.Range.End
        ok = Me.ReApplyFormat
    ElseIf Me.TypeOfPicture = PictureType.ShapeType Then
        Set Shape = shp
        Set rng = shp.Anchor.Duplicate
        Set Range = rng
        RangeStart = shp.Anchor.start
        RangeEnd = shp.Anchor.End
        ok = Me.ReApplyFormat
    ElseIf Me.TypeOfPicture = PictureType.EmbedType Then
        Stop
    Else
        ok = True
    End If
    
    
ExitIt:
    On Error GoTo 0
    BreakLink = ok
    Exit Function

Failed:
    Select Case Err.Number
'    Case -2147024891 'This member can only be accessed for a picture or an OLE object.
'        If resumeAt = "ResumeNoPictureFormat" Then
'            Resume ResumeNoPictureFormat
'        Else
'            Stop
'        End If
'    Case 438, 445 'Object doesn't support this property or method, 'Object doesn't support this action
'        If resumeAt = "Next" Then
'            Resume Next
'        Else
'            Stop
'        End If
    Case Else
        Debug.Print "Case " & Err.Number & " '" & Err.Description
        ok = False
        Resume ExitIt
    End Select
End Function

Public Function ResizePercent(percentSize As Integer) As Boolean
On Error GoTo Failed
    Dim ok As Boolean
    Dim shp As Object
    Dim resumeAt As String

    If Me.TypeOfPicture = PictureType.InlineType Then
        Set shp = InlineShape ' CollectionRange.InlineShapes(INLIndex)
         shp.ScaleHeight = percentSize
         shp.ScaleWidth = percentSize
    ElseIf Me.TypeOfPicture = PictureType.ShapeType Then
        Set shp = Shape 'CollectionRange.ShapeRange(SHPIndex)
         shp.ScaleHeight Factor:=(percentSize / 100), RelativeToOriginalSize:=msoCTrue
         shp.ScaleWidth Factor:=(percentSize / 100), RelativeToOriginalSize:=msoCTrue
    ElseIf Me.TypeOfPicture = PictureType.EmbedType Then
        Stop
    End If
    
    resumeAt = ""
    ok = True
    
ExitIt:
    On Error GoTo 0
    ResizePercent = ok
    Exit Function

Failed:
    Select Case Err.Number
    Case Else
        Debug.Print "Case " & Err.Number & " '" & Err.Description
        ok = False
        Resume ExitIt
    End Select
 End Function

Public Sub KillFilesAndFolder(strFullName As String)
    Dim filesFolder As String
    
    If strFullName > "" Then
        filesFolder = Mid(strFullName, 1, InStrRev(strFullName, "\"))
        Kill filesFolder & "*.*"
        RmDir filesFolder
        Kill Mid(strFullName, 1, InStrRev(strFullName, "_files") - 1) & ".htm"
    End If
End Sub



Public Function WriteToTemporaryPictureFile() As String
On Error GoTo Failed
    
    Dim filesFolder As String
    Dim lWritePos As Long
    Dim vData() As Byte
    Dim prefix As String
    Dim inl As InlineShape
    Dim shp As Shape
    Dim inlNew As InlineShape
    Dim shpNew As Shape
    Dim newDoc As Document
    
    Dim tempFileName As String
    tempFileName = GetTempFile("pic", "htm")

    Dim DX As New DOCXML
    DX.Init
    DX.Prolog "Write To Temporary Picture File"

    If Me.TypeOfPicture = PictureType.InlineType Then
        Set inl = InlineShape
    Else
        Set shp = Shape
        Set inl = shp.ConvertToInlineShape
    End If
    
    inl.reset
    inl.LockAspectRatio = False
    inl.ScaleHeight = 100
    inl.ScaleWidth = 100
    inl.LockAspectRatio = True
    inl.Range.copy
    
    DX.updated = False
    DX.Epilog
    Set DX = Nothing

    Set newDoc = Application.Documents.Add(Visible:=False)
    newDoc.Range.Paste
    If newDoc.InlineShapes.Count > 0 Then
        Set inlNew = newDoc.InlineShapes(1)
        Set shpNew = inlNew.ConvertToShape
    Else
        Set shpNew = newDoc.Shapes(1)
        Set inlNew = shpNew.ConvertToInlineShape
        inlNew.reset
        Set shpNew = inlNew.ConvertToShape
    End If
    
    shpNew.LockAspectRatio = False
    shpNew.ScaleHeight 1, msoCTrue
    shpNew.ScaleWidth 1, msoCTrue
    shpNew.Line.Visible = msoFalse
    shpNew.Rotation = 0
    shpNew.LockAspectRatio = True
    Set inlNew = shpNew.ConvertToInlineShape
    
    filesFolder = Replace(tempFileName, ".htm", "_files")
    newDoc.SaveAs2 tempFileName, wdFormatHTML, , , False, , , , True
    newDoc.Close wdDoNotSaveChanges
    
    Dim strFile As String
    strFile = Dir(filesFolder & "\image*")
    Do While Len(strFile) > 0
        Exit Do
        strFile = Dir
    Loop
    
    If strFile > "" Then
        Debug.Print strFile
    End If
    
    
    'vData = inlNew.Range.EnhMetaFileBits
    
    'Open strFullName For Binary Access Write As #1
    'lWritePos = 1
    'Put #1, lWritePos, vData
    'Close #1
    
    '    Dim ok As Boolean
    '    Dim shp As Object
    '    Dim resumeAt As String
    '    Dim vData() As Byte
    '    Dim lWritePos As Long
    '
    '    If Me.TypeOfPicture = PictureType.InlineType Then
    '        Set shp = InlineShape
    '        vData = shp.Range.EnhMetaFileBits
    '    ElseIf Me.TypeOfPicture = PictureType.ShapeType Then
    '        Set shp = Shape
    '        vData = shp.Anchor.EnhMetaFileBits
    '    ElseIf Me.TypeOfPicture = PictureType.EmbedType Then
    '        Stop
    '    End If
    '
    '    Open strFullName For Binary Access Write As #1
    '    lWritePos = 1
    '    Put #1, lWritePos, vData
    '    Close #1

    
ExitIt:
    On Error GoTo 0
    WriteToTemporaryPictureFile = filesFolder & "\" & strFile
    Exit Function

Failed:
    Select Case Err.Number
    Case Else
        Debug.Print "Case " & Err.Number & " '" & Err.Description
        Resume ExitIt
    End Select
 End Function

Public Function ChangePictureToV(Optional bgpmFrom As BGPictureManager = Nothing) As Boolean
On Error GoTo Failed
    Dim ok As Boolean
    Dim shp As Object
    Dim fld As field
    Dim rng As Range
    Dim rngInsert As Range
    Dim resumeAt As String
    Dim key As Variant
    Dim found As Boolean
    
    Dim bgpSearch As BGPicture
    Dim bgpFrom As BGPicture
    found = False
    If Me.TypeOfPicture = PictureType.InlineType Then
        Set shp = InlineShape
        Set rng = shp.Range.Duplicate
        RangeStart = shp.Range.start
        RangeEnd = shp.Range.End
        If bgpmFrom Is Nothing Then
            Set bgpFrom = Me
            found = True
        Else
            For Each key In bgpmFrom.GetBGPictures.Keys
                Set bgpSearch = bgpmFrom.GetBGPictures(key)
                If AlternativeText Like "*" & bgpSearch.key & "*" Then
                    Set bgpFrom = bgpSearch
                    found = True
                    Exit For
                End If
            Next
        End If
    ElseIf Me.TypeOfPicture = PictureType.ShapeType Then
        Set shp = Shape
        Set rng = shp.Anchor.Duplicate
        RangeStart = shp.Anchor.start
        RangeEnd = shp.Anchor.End
        If bgpmFrom Is Nothing Then
            Set bgpFrom = Me
            found = True
        Else
            For Each key In bgpmFrom.GetBGPictures.Keys
                Set bgpSearch = bgpmFrom.GetBGPictures(key)
                If AlternativeText Like "*" & bgpSearch.key & "*" Then
                    Set bgpFrom = bgpSearch
                    found = True
                    Exit For
                End If
            Next
        End If
    ElseIf Me.TypeOfPicture = PictureType.EmbedType Then
        Stop
    End If
    
    If Not found Then
        'Me.ReApplyFormat
    ElseIf bgpFrom.FoundFile > "" Then
        Dim newFileName As String
        newFileName = FixPath(bgpFrom.FoundFile)
        If Me.sourceFullName <> newFileName Then
            If Me.TypeOfPicture = PictureType.InlineType Then
                Set rngInsert = shp.Range.Duplicate
                shp.Range.Delete
                Set shp = rngInsert.InlineShapes.AddPicture(newFileName, True, True, rngInsert)
                If bgpFrom.Rotation <> 0 Then
                    Set shp = shp.ConvertToShape
                    shp.Rotation = bgpFrom.Rotation
                    Set shp = shp.ConvertToInlineShape
                End If
                Set InlineShape = shp
                Set rng = shp.Range.Duplicate
                RangeStart = shp.Range.start
                RangeEnd = shp.Range.End
            ElseIf Me.TypeOfPicture = PictureType.ShapeType Then
                Set rngInsert = shp.Anchor.Duplicate
                shp.Anchor.Delete
                Dim inl As InlineShape
                Set inl = rngInsert.InlineShapes.AddPicture(newFileName, True, True, rngInsert)
                Set shp = inl.ConvertToShape
                If bgpFrom.Rotation <> 0 Then
                    shp.Rotation = bgpFrom.Rotation
                End If
                Set Shape = shp
                Set rng = shp.Anchor.Duplicate
                RangeStart = shp.Anchor.start
                RangeEnd = shp.Anchor.End
            End If
            Me.ReApplyFormat
        End If
'    ElseIf bgpFrom.sourceFullName > "" Then
'        bgpFrom.WriteToTemporaryPictureFile ("D:\test.emf")
    Else
        'Me.ReApplyFormat
    End If
    
ResumeNoPictureFormat:
    resumeAt = ""
    
ExitIt:
    On Error GoTo 0
    ChangePictureToV = ok
    Exit Function

Failed:
    Select Case Err.Number
'    Case -2147024891 'This member can only be accessed for a picture or an OLE object.
'        If resumeAt = "ResumeNoPictureFormat" Then
'            Resume ResumeNoPictureFormat
'        Else
'            Stop
'        End If
'    Case 438, 445 'Object doesn't support this property or method, 'Object doesn't support this action
'        If resumeAt = "Next" Then
'            Resume Next
'        Else
'            Stop
'        End If
'    Case -2147024809 'Operation is not supported by the current object
'        If resumeAt = "Next" Then
'            Resume Next
'        Else
'            Stop
'        End If
    Case Else
        Debug.Print "Case " & Err.Number & " '" & Err.Description
        Debug.Print AlternativeText
        ok = False
        Resume ExitIt
    End Select
End Function
Attribute VB_Name = "BGPictureManager"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private BGPictures As Scripting.Dictionary
Public CollectionRange As Range
Public doc As Document

Private Sub Class_Initialize()
    Set BGPictures = New Scripting.Dictionary
End Sub

Public Function GetBGPictures() As Scripting.Dictionary
    Set GetBGPictures = BGPictures
End Function


'Public Function Remove(key As String) As Boolean
'On Error GoTo Failed
'    Dim ok As Boolean
'    If Contains(key) Then
'        BGPictures.Remove (key)
'    End If
'    ok = Not Contains(key)
'ExitIt:
'    On Error GoTo 0
'    Remove = ok
'    Exit Function
'Failed:
'    ok = False
'    Resume ExitIt
'
'End Function
'
'
'Public Function Add(bgPic As Variant, key As String, Optional Force As Boolean = False) As Boolean
'On Error GoTo Failed
'    Dim ok As Boolean
'    If Contains(key) Then
'        If Force Then
'            BGPictures.Remove (key)
'        Else
'            ok = False
'        End If
'    End If
'    If Not Contains(key) Then
'        BGPictures.Add bgPic, key
'        ok = Contains(key)
'    End If
'ExitIt:
'    On Error GoTo 0
'    Add = ok
'    Exit Function
'Failed:
'    ok = False
'    Resume ExitIt
'
'End Function
'
'Public Function Contains(key As String) As Boolean
'    Dim dummy As Variant
'
'    On Error Resume Next
'    Set dummy = BGPictures(key)
'    Contains = (Err.Number = 0)
'    Err.Clear
'End Function

Public Function ReadRange(rng As Range, DX As DOCXML, Optional AddIDInAltText As Boolean = False) As Boolean
On Error GoTo Failed
    Dim ok As Boolean
    
    Set CollectionRange = rng
    Set doc = rng.Document
    
    Dim inl As InlineShape
    Dim shp As Shape
    Dim i As Integer
    Dim iInline As Integer
    Dim iShape As Integer
    Dim key As String
    
    Dim bgp As BGPicture
    
    i = 0
    iInline = 0
    iShape = 0
    Set BGPictures = New Scripting.Dictionary
        
    For Each inl In rng.InlineShapes
        i = i + 1
        iInline = iInline + 1
        Set bgp = New BGPicture
        
        Set bgp.doc = doc
        Set bgp.CollectionRange = CollectionRange
        bgp.INLIndex = iInline
        bgp.TypeOfPicture = PictureType.InlineType
        Set bgp.InlineShape = inl
        bgp.key = Format(inl.Range.start, "00000000") & "." & Format(i, "00000")
        BGPictures.Add bgp.key, bgp
        If AddIDInAltText Then bgp.AddIDInAltText DX
    Next
    
    For Each shp In rng.ShapeRange
        i = i + 1
        iShape = iShape + 1
        Set bgp = New BGPicture
        Set bgp.doc = doc
        Set bgp.CollectionRange = CollectionRange
        bgp.SHPIndex = iShape
        bgp.TypeOfPicture = PictureType.ShapeType
        Set bgp.Shape = shp
        bgp.key = Format(shp.Anchor.start, "00000000") & "." & Format(i, "00000")
        BGPictures.Add bgp.key, bgp
        If AddIDInAltText Then bgp.AddIDInAltText DX
    Next
     
    SortDictionary BGPictures, True
    ok = True
ExitIt:
    On Error GoTo 0
    ReadRange = ok
    Exit Function
Failed:
    ok = False
    Resume ExitIt

End Function

Public Function Read(DX As DOCXML, Optional findFile As Boolean = False, Optional findPage As Boolean = False, Optional findCaption As Boolean = False) As Boolean
On Error GoTo Failed
    Dim ok As Boolean

    Dim bgp As BGPicture
    Dim key As Variant
    For Each key In BGPictures.Keys
        Set bgp = BGPictures(key)
        bgp.Read DX, findFile, findPage, findCaption
    Next

    ok = True
ExitIt:
    On Error GoTo 0
    Read = ok
    Exit Function
Failed:
    ok = False
    Resume ExitIt
End Function

Public Function ReadOldFilename(DX As DOCXML, Optional force As Boolean = False) As Boolean
On Error GoTo Failed
    Dim ok As Boolean
    Dim key As Variant
    Dim bgp As BGPicture
    
    For Each key In BGPictures.Keys
        Set bgp = BGPictures(key)
        bgp.Read DX, True, False, False, force
    Next

    ok = True
ExitIt:
    On Error GoTo 0
    ReadOldFilename = ok
    Exit Function
Failed:
    ok = False
    Resume ExitIt
End Function


Public Function ReadInfo(DX As DOCXML, Optional force As Boolean = False) As Boolean
On Error GoTo Failed
    Dim ok As Boolean
    Dim key As Variant
    
    Dim bgp As BGPicture
    For Each key In BGPictures.Keys
        Set bgp = BGPictures(key)
        bgp.ReadFormat
        bgp.Read DX, True, False, False, False
    Next

    If force Then
        For Each key In BGPictures.Keys
            Set bgp = BGPictures(key)
            bgp.Read DX, True, False, False, True
        Next
    End If

    ok = True
ExitIt:
    On Error GoTo 0
    ReadInfo = ok
    Exit Function
Failed:
    ok = False
    Resume ExitIt
End Function

Public Function BreakBrokenLinks() As Boolean
On Error GoTo Failed
    Dim ok As Boolean
    Dim key As Variant
    Dim bgp As BGPicture
    Dim i As Integer
    Dim fld As field
    Dim rng As Range
    
    For Each key In BGPictures.Keys
        Set bgp = BGPictures(key)
        If (bgp.sourceFullName > "" And bgp.FoundFile = "") Then
'            Set rng = bgp.Range.Duplicate
'            rng.Select
'            Selection.MoveRight Unit:=wdCharacter, count:=1, Extend:=wdExtend
'            Selection.MoveLeft Unit:=wdCharacter, count:=1, Extend:=wdExtend
'            Set rng = Selection.Range
            'rng.MoveEnd wdCharacter, 1
'            If rng.fields.count > 0 Then
'                For i = rng.fields.count To 1 Step -1
'                    Set fld = rng.fields(i)
'                    If LCase(Trim(fld.code)) Like "include*" Then
'                        fld.Unlink
'                    End If
'                Next
'            Else
                bgp.BreakLink
'            End If
        End If
    Next
    
    ok = True
ExitIt:
    On Error GoTo 0
    BreakBrokenLinks = ok
    Exit Function
Failed:
    ok = False
    Resume ExitIt
End Function

Public Function ChangePicturesToV(Optional bgpmFrom As BGPictureManager = Nothing) As Boolean
On Error GoTo Failed
    Dim ok As Boolean
    Dim key As Variant
    Dim bgp As BGPicture
    For Each key In BGPictures.Keys
        Set bgp = BGPictures(key)
        bgp.ChangePictureToV bgpmFrom
    Next
    
    ok = True
ExitIt:
    On Error GoTo 0
    ChangePicturesToV = ok
    Exit Function
Failed:
    ok = False
    Resume ExitIt
End Function


Attribute VB_Name = "CPDocFile"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public LanguageCode As String
Public LanguageId As Integer
Public Frontpage As Boolean
Public Pages As Integer
Public LanguageFromPara As String
Public Paragraphs As Integer

Public HFLine1 As String
Public HFLine2 As String
Public HFLine3 As String
Public HFLine4 As String
Public HFLine5 As String

Public FPLine1 As String
Public FPLine2 As String
Public FPLine3 As String
Public FPLine4 As String
Public FPLine5 As String
Public FPLine6 As String

Public FPCopyright As String
Public FPDisclaimer As String
Public FPDate As Date
Public FPDateCP As String
Public FPJournal As String
Public FPJournalExtra As String
Public FPRevision As String
Public FPPages As String
Public FPInitials As String


'Public row As Integer
'Public RootFolder As String
'Public SubFolder As String
'Public name As String
'Public DirectoryName As String
'Public fullName As String
'Public Extension As String
'Public Created As Date
'Public Modified As Date
'Public Read As Date
'Public Pictures As Integer
'Public Missing As Integer
'Public IsLinked As Integer
'Public OutOfDate As Integer
'Public saveAs As Integer
'Public MaybeFound As Integer
'Public MultiField As Integer
'Public Convert As Boolean
'Public Upgrade As Boolean
'Public Converted As Date
'Public DocLanguageCode As String
'Public line1 As String
'Public line2 As String
'Public Line3 As String
'Public Line4 As String
'Public Revision As String
'Public Section As String
'Public Language As String

'Public template As String
'Public Paper As String
'Public Errors As String
'Public Differences As String
'Public Copyright As String
'Public DateCP As String
'Public HeaderName As String
'Public Company As String
'Public Ini As String
'Public Initials As String
'Public RevInitials As String
'Public RevRevision As String
'Public RevDateCP As String
'Public RevDate As Date
'Public RevComment As String
'Public altTemplate As String
'Public projectNo As String
'Public PictureDirectory As String
'Public VDate As Date
'Public HFDate As Date
'Public SectionNo As String
'Public HFSectionNo As String
'Public LineCount As Integer

'Public HFRevision As String
'Public HFSection As String
'Public HFCopyright As String
'Public HFDateCP As String
'Public HFIni As String


Attribute VB_Name = "DOCXML"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Const NS As String = "http://beumergroup.com/namespaces/bgdoc"
Const PathLanguage As String = "/DocumentInfo/DocumentInfo-Language"

'------------------------
' New Update variables

Private JumpToPart As String
Private Language As String

Private ScreenUpdating As Boolean
Private rngReturnTo As Range
Private cc As ContentControl
Private rng As Range
Private stry As Range
Private aTag() As String
Private path As String
Private gotoEnd As Boolean

Private pageHeight As Single
' Private rngInsert As Range

Private rngStart As Range
Private moveBooks As Long
Private bk As Bookmark
Private bkRng As Range
Private iBK As Long

Private value As String
Private HeadingLayout As String

Private rngDelete As Range
Private paraStart As Long
Private para As Paragraph

Private headingLevels As Integer
Private addedStyles As String
Private TermReg As String

'------------------------

Public ThisBGD As BGDoc
Public ThisDoc As Document
Public fromDoc As Document
Public ConversionHistory As Scripting.Dictionary

Public method As String
Public DoFixDocument As Boolean
Public DoUpdate As Boolean
Public DoReadTranslation As Boolean

Public prefix As String
Public SPXML As CustomXMLPart
Public CustomXML As CustomXMLPart
Public OriginalXML As New MSXML2.DOMDocument60
Public RevCount As Integer
Public RevisionTableIndex As Integer

Public ReplaceRegistered As Boolean
Public RebuildFrontMatter As Boolean
Public RebuildTOC As Boolean
Public UpdateCaptions As Boolean
Public FieldsUpdated As Boolean
'Public StructureUpdated As Boolean
Public LanguageUpdated As Boolean
Public CompanyLogoUpdated As Boolean
Public OldLanguage As String
Public NewPaperFormat As String
Public OrgFileDate As Date
Public ShowRevisionsAndComments As Boolean
Public RevisionsView  As WdRevisionsView

Public Saved As Boolean
Public updated As Boolean
Public Undo As Word.UndoRecord
Public DocType As String

Public IsNewDocument As Boolean
Public OldTranslation As Boolean
Private showFrontMatter As String
Private ShowSupplierFileName As String
Private ShowFrontPage As String
Private ShowDocumentInformation As String
Private ShowRevisions As String
Private ShowTOC As String
Private ShowTOF As String
Private ShowTOT As String
Private CaptionHeading As String
Private PDFLayOut As String

Private ccFrontMatter As ContentControl
Private ccFrontPage As ContentControl
Private ccFrontPageHeader As ContentControl
Private ccFrontPageFooter As ContentControl
Private ccTranslation As ContentControl
Private ccTOC As ContentControl
Private ccTOF As ContentControl
Private ccTOT As ContentControl
Private ccTOCLabel As ContentControl
Private ccTOFLabel As ContentControl
Private ccTOTLabel As ContentControl
Private ccHeader As ContentControl
Private ccFooter As ContentControl
Private ccDocumentInformation As ContentControl
Private ccFileName As ContentControl
Private ccSupplierFileName As ContentControl
Private ccSupplierFileNameLabel As ContentControl
Private ccCopyright As ContentControl
Private ccDisclaimer As ContentControl
Private ccRevisions As ContentControl
Public FoundHeadingOrParmheadOrHeadingPart As Boolean
Public FoundCaptionRes As Boolean
Public ErrorNo As Long

Private aRevHist() As String

Private Sub Class_Initialize()
    Set ThisDoc = Nothing
End Sub
    
Public Sub Init(Optional bgd As BGDoc = Nothing)

    ErrorNo = 0
    
    If Not bgd Is Nothing Then
        Set ThisBGD = bgd
        Set ThisDoc = bgd.ThisDoc
    Else
        Set ThisDoc = ActiveDocument
        Set ThisBGD = GetB
    End If

    
    Dim parts As CustomXMLParts
    Dim strPrefix As String

    Set parts = ThisDoc.CustomXMLParts.SelectByNamespace(NS)
    If parts.Count = 0 Then
        Dim tmp As Document
        Dim tmpTemp As Template
        Set tmpTemp = ThisDoc.attachedTemplate
        Set tmp = tmpTemp.OpenAsDocument
        Dim partFromTemplate As CustomXMLPart
        
        Set parts = tmp.CustomXMLParts.SelectByNamespace(NS)
        If Not parts.Count = 0 Then
            Set CustomXML = ThisDoc.CustomXMLParts.Add(parts(1).XML)
            Set parts = ThisDoc.CustomXMLParts.SelectByNamespace(NS)
            prefix = parts(1).NamespaceManager.LookupPrefix(NS) & ":"
            Set parts = Nothing
            tmp.Close wdDoNotSaveChanges
            Set tmp = Nothing
            Set tmpTemp = Nothing
        
            Dim thcStyle As Style
            On Error Resume Next
            Set thcStyle = ThisDoc.Styles("Table Header Center")
            On Error GoTo 0
            If thcStyle Is Nothing Then
                 ThisDoc.CopyStylesFromTemplate (ThisDoc.attachedTemplate.fullName)
            End If
            NewPaperFormat = "Detect"
        End If
    Else
        Set CustomXML = parts(1)
        prefix = parts(1).NamespaceManager.LookupPrefix(NS) & ":"
        Set parts = Nothing
    End If
    
    Dim WasSaved As Boolean
    WasSaved = ThisDoc.Saved
    If Not ThisDoc.ReadOnly Then
'        ' New Fields
'        Dim oNode As CustomXMLNode
'        Dim TryIntentionallyLeftBlank As String
'        If Not TryReadText("/DocumentLabel/DocumentLabel-IntentionallyLeftBlank", TryIntentionallyLeftBlank) Then
'              Set oNode = AddNode("/DocumentLabel", "DocumentLabel-IntentionallyLeftBlank", "Intentionally Left Blank")
'        End If
'        Dim TryPDFLayout As String
'        If Not TryReadText("/DocumentInfo/DocumentInfo-PDFLayout", TryPDFLayout) Then
'              Set oNode = AddNode("/DocumentInfo", "DocumentInfo-PDFLayout", "Standard")
'        End If
'        Dim TryHeadingLayout As String
'        If Not TryReadText("/DocumentInfo/DocumentInfo-HeadingLayout", TryHeadingLayout) Then
'              Set oNode = AddNode("/DocumentInfo", "DocumentInfo-HeadingLayout", "Standard")
'        End If
'
'        Dim TryFullName As String
'        If Not TryReadText("/DocumentInfo/DocumentInfo-FullName", TryFullName) Then
'              Set oNode = AddNode("/DocumentInfo", "DocumentInfo-FullName", "")
'        End If
'        Dim TryShowFullName As String
'        If Not TryReadText("/DocumentInfo/DocumentInfo-ShowFullName", TryShowFullName) Then
'              Set oNode = AddNode("/DocumentInfo", "DocumentInfo-ShowFullName", "")
'        End If
'        Dim TrySaveFolder As String
'        If Not TryReadText("/DocumentInfo/DocumentInfo-SaveFolder", TrySaveFolder) Then
'              Set oNode = AddNode("/DocumentInfo", "DocumentInfo-SaveFolder", "")
'        End If
'        Dim TrySaveFileName As String
'        If Not TryReadText("/DocumentInfo/DocumentInfo-SaveFileName", TrySaveFileName) Then
'              Set oNode = AddNode("/DocumentInfo", "DocumentInfo-SaveFileName", "")
'        End If
'
'        Dim TryDocType As String
'        If Not TryReadText("/DocumentInfo/DocumentInfo-DocType", TryDocType) Then
'            Set oNode = RenameNode("/DocumentInfo", "DocumentInfo-Layout", "DocumentInfo-DocType")
'            If oNode.text = "" Or oNode.text = "Standard Documentation" Then
'                oNode.text = "O & M Document"
'                AddNode "/DocumentInfo", "DocumentInfo-DocMainType", "O & M Document"
'            ElseIf oNode.text = "Spare Parts Catalogue" Then
'                oNode.text = "O & M Spare Parts Catalogue"
'                AddNode "DocumentInfo-DocMainType", "O & M Spare Parts Catalogue", False
'            End If
'            Set oNode = RenameNode("/DocumentInfo", "DocumentInfo-ClassificationLevel", "DocumentInfo-ClassificationLabel")
'            Set oNode = RenameNode("/DocumentInfo", "DocumentInfo-Status", "DocumentInfo-WorkflowLabel")
'        Else
'            Set oNode = ReadNode("/DocumentInfo/DocumentInfo-DocType")
'            If oNode.text = "" Or oNode.text = "Standard Documentation" Then
'                oNode.text = "O & M Document"
'                AddNode "DocumentInfo-DocMainType", "O & M Document", False
'            ElseIf oNode.text = "Standard Document" Then
'                oNode.text = "Project Document"
'            ElseIf oNode.text = "Standard Sheet" Then
'                oNode.text = "BDK Standard Sheet"
'            ElseIf oNode.text = "Spare Parts Catalogue" Then
'                oNode.text = "O & M Spare Parts Catalogue"
'                AddNode "DocumentInfo-DocMainType", "O & M Spare Parts Catalogue", False
'            End If
'        End If
    End If
    OriginalXML.LoadXML Replace(CustomXML.XML, "xmlns=""" & NS & """", "")
     
    RebuildFrontMatter = False
    RebuildTOC = False
    UpdateCaptions = False
    ReplaceRegistered = False
    FieldsUpdated = False
    LanguageUpdated = False
    CompanyLogoUpdated = False
    OldLanguage = ReadText(PathLanguage)
    
    If ThisDoc.Saved <> WasSaved Then ThisDoc.Saved = WasSaved
    
End Sub

Public Function ReadRevisionHistory() As String()

    Dim i As Integer
    Dim oRevHist As CustomXMLNode
    Set oRevHist = ReadNode("/DocumentInfo/DocumentInfo-RevisionHistory")
    RevCount = oRevHist.SelectNodes(prefix & "Revision").Count + 1
    
    ReDim aRevHist(RevCount - 1, 4)
    Dim oRow As CustomXMLNode
    i = 0
    For Each oRow In oRevHist.SelectNodes(prefix & "Revision")
        aRevHist(i, 0) = oRow.SelectSingleNode("./" & prefix & "No").text
        aRevHist(i, 1) = oRow.SelectSingleNode("./" & prefix & "Date").text
        aRevHist(i, 2) = oRow.SelectSingleNode("./" & prefix & "Author").text
        aRevHist(i, 3) = oRow.SelectSingleNode("./" & prefix & "Description").text
        i = i + 1
    Next
    aRevHist(i, 0) = ReadText("/DocumentInfo/DocumentInfo-Revision")
    aRevHist(i, 1) = ReadText("/DocumentInfo/DocumentInfo-Date")
    aRevHist(i, 2) = ReadText("/DocumentInfo/DocumentInfo-Author")
    aRevHist(i, 3) = ReadText("/DocumentInfo/DocumentInfo-Description")
    
    Set oRevHist = Nothing
    aRevHist = OrderRevisionHistory(aRevHist)
    ReadRevisionHistory = aRevHist
    
End Function

Public Function GetRevisionHistory() As Variant
    GetRevisionHistory = aRevHist
End Function

Public Function AddNode(ByVal path As String, nodeName As String, ByVal value As Variant) As CustomXMLNode ', Optional structureUpdate As Boolean = False
    Dim oNode As CustomXMLNode
    path = Replace(path, "/", "/" & prefix)
    On Error Resume Next
    Set oNode = CustomXML.SelectSingleNode(prefix & "doc" & path)
    On Error GoTo 0
    If Not oNode Is Nothing Then
        oNode.AppendChildNode nodeName, NS, msoCustomXMLNodeElement
        Set oNode = oNode.LastChild
        If oNode.text <> value Then
            oNode.text = value
            FieldsUpdated = True
'            If structureUpdate Then
'                'StructureUpdated = True
'            End If
        End If
        Set AddNode = oNode
    Else
        Set AddNode = Nothing
    End If
End Function

Public Function RenameNode(ByVal path As String, oldNodeName As String, newNodeName As String) As CustomXMLNode
    Dim oNode As CustomXMLNode
    Dim oldNode As CustomXMLNode
    Dim newNode As CustomXMLNode
    
    path = Replace(path, "/", "/" & prefix)
    On Error Resume Next
    Set oNode = CustomXML.SelectSingleNode(prefix & "doc" & path)
    On Error GoTo 0
    If Not oNode Is Nothing Then
        On Error Resume Next
        Set oldNode = oNode.SelectSingleNode(prefix & oldNodeName)
        On Error GoTo 0
        If Not oldNode Is Nothing Then
            oNode.AppendChildNode newNodeName, NS, msoCustomXMLNodeElement
            Set newNode = oNode.LastChild
            If newNode Is Nothing Then
                Set RenameNode = Nothing
                Exit Function
            Else
                Dim oChild As CustomXMLNode
                For Each oChild In oldNode.ChildNodes
                    If oChild.NodeType = msoCustomXMLNodeText Then
                        newNode.AppendChildNode newNodeName, "", msoCustomXMLNodeText, oChild.text
                    Else
                        newNode.AppendChildSubtree oChild.XML
                    End If
                Next
                oNode.RemoveChild oldNode
            End If
        Else
            Set RenameNode = Nothing
            Exit Function
        End If
        
                
        Set RenameNode = newNode
    Else
        Set RenameNode = Nothing
    End If
End Function

Public Sub WriteConversion(fromDocFullName As String, atTime As String, user As String, bgpmFrom As BGPictureManager)
    Dim oConv As CustomXMLNode
    Dim oNode As CustomXMLNode
    Set oConv = ReadNode("/DocumentInfo/Conversion")
    If Not oConv Is Nothing Then
        For Each oNode In oConv.ChildNodes
            oConv.RemoveChild oNode
        Next
    Else
        Set oNode = ReadNode("/DocumentInfo")
        oNode.AppendChildNode "Conversion", NS, msoCustomXMLNodeElement
        Set oConv = oNode.LastChild
    End If
    
'    Dim oOutOfDate As CustomXMLNode
'    Dim key As Variant
'    Dim bgp As BGPicture
'    If Not bgpmFrom Is Nothing Then
'        For Each key In bgpmFrom.GetBGPictures
'            Set bgp = bgpmFrom.GetBGPictures(key)
'            If bgp.OutOfDate Then
'                If oOutOfDate Is Nothing Then
'                    oConv.AppendChildNode "OutOfDate", NS, msoCustomXMLNodeElement
'                    Set oOutOfDate = oNode.LastChild
'                End If
'                oOutOfDate.AppendChildNode "File", NS
'                oOutOfDate.LastChild.AppendChildNode "File", NS, msoCustomXMLNodeText, bgp.FoundFile
'            End If
'        Next
'    End If
    
    
    Dim key As Variant
    Dim bgp As BGPicture
    If Not bgpmFrom Is Nothing Then
        For Each key In bgpmFrom.GetBGPictures
            Set bgp = bgpmFrom.GetBGPictures(key)
            If bgp.OutOfDate Then
                AddWarning "Inserted newer version of picture from disk:'" & bgp.FoundFile & "'. Text may no longer apply."
            End If
        Next
    End If
    
    oConv.AppendChildNode "Conversion-History", NS
    oConv.LastChild.AppendChildNode "Conversion-History", NS, msoCustomXMLNodeText, ConversionHistoryToString
    oConv.AppendChildNode "Conversion-FromDoc", NS
    oConv.LastChild.AppendChildNode "Conversion-FromDoc", NS, msoCustomXMLNodeText, fromDocFullName
    oConv.AppendChildNode "Conversion-AtTime", NS
    oConv.LastChild.AppendChildNode "Conversion-AtTime", NS, msoCustomXMLNodeText, atTime
    oConv.AppendChildNode "Conversion-User", NS
    oConv.LastChild.AppendChildNode "Conversion-User", NS, msoCustomXMLNodeText, user

End Sub

Public Sub WriteRevisionHistory(aNewRevHist() As String)
    Dim i As Integer
    Dim oRevHist As CustomXMLNode
    Dim oNode As CustomXMLNode
    Set oRevHist = ReadNode("/DocumentInfo/DocumentInfo-RevisionHistory")
    
    aRevHist = aNewRevHist
    RevCount = UBound(aRevHist, 1)
    For Each oNode In oRevHist.ChildNodes
        oRevHist.RemoveChild oNode
    Next
    For i = 0 To RevCount - 1
        oRevHist.AppendChildNode "Revision", NS, msoCustomXMLNodeElement
        Set oNode = oRevHist.LastChild
        oNode.AppendChildNode "No", NS
        oNode.LastChild.AppendChildNode "No", NS, msoCustomXMLNodeText, Replace(Replace(aRevHist(i, 0), Chr(11), vbCr), Chr(31), "")
        oNode.AppendChildNode "Date", NS
        oNode.LastChild.AppendChildNode "Date", NS, msoCustomXMLNodeText, Replace(aRevHist(i, 1), Chr(11), vbCr)
        oNode.AppendChildNode "Author", NS
        oNode.LastChild.AppendChildNode "Author", NS, msoCustomXMLNodeText, Replace(aRevHist(i, 2), Chr(11), vbCr)
        oNode.AppendChildNode "Description", NS
        oNode.LastChild.AppendChildNode "Description", NS, msoCustomXMLNodeText, Replace(aRevHist(i, 3), Chr(11), vbCr)
    Next
    Set oNode = Nothing
    Set oRevHist = Nothing
End Sub

Public Function ReadNode(ByVal path As String) As CustomXMLNode
    Dim oNode As CustomXMLNode
    path = Replace(path, "/", "/" & prefix)
    Set oNode = CustomXML.SelectSingleNode(prefix & "doc" & path)
    Set ReadNode = oNode
End Function

Public Function DeleteNode(ByVal path As String) As Boolean
    Dim oNode As CustomXMLNode
    path = Replace(path, "/", "/" & prefix)
    Set oNode = CustomXML.SelectSingleNode(prefix & "doc" & path)
    If oNode Is Nothing Then
        DeleteNode = False
    Else
        oNode.Delete
        DeleteNode = True
    End If
End Function

Public Function TryReadText(ByVal path As String, ByRef assignTo As String) As Boolean
    Dim oNode As CustomXMLNode
    Dim value As String
    If path Like "/DocumentInfo/DocumentInfo-??" Then
        Dim pv As String
        pv = Replace(path, "/DocumentInfo/DocumentInfo-", "")
        
        Dim pvLine As String
        Dim pvPart As String
        Dim str As String
        Dim aValue() As String
        
        pvLine = Right(pv, 1)
        pvPart = Left(pv, 1)
        If Not pvLine = "1" And Not pvLine = "2" And Not pvLine = "3" And Not pvPart = "P" And Not pvPart = "V" Then
            TryReadText = False
        Else
            path = Replace("/DocumentInfo/DocumentInfo-FrontPageInfo", "/", "/" & prefix)
            Set oNode = CustomXML.SelectSingleNode(prefix & "doc" & path)
            If oNode Is Nothing Then
                assignTo = " "
                TryReadText = True
            Else
                value = oNode.text
                Set oNode = Nothing
                Dim aPV() As String
                aPV = Split(value, vbLf)
                If UBound(aPV) < CInt(pvLine - 1) Then
                    assignTo = " "
                    TryReadText = True
                Else
                    aValue = Split(aPV(CInt(pvLine - 1)), ":", 2)
                    If pvPart = "P" Then
                        value = aValue(0)
                    ElseIf UBound(aValue) = 1 Then
                        value = aValue(1)
                    Else
                        value = ""
                    End If
                    If value = "" Then value = " "
                    assignTo = value
                    TryReadText = True
                End If
            End If
        End If
    Else
        path = Replace(path, "/", "/" & prefix)
        On Error Resume Next
        Set oNode = CustomXML.SelectSingleNode(prefix & "doc" & path)
        On Error GoTo 0
        If oNode Is Nothing Then
            TryReadText = False
        Else
            value = oNode.text
            Set oNode = Nothing
            assignTo = value
            TryReadText = True
        End If
    End If
End Function


Public Function ReadText(ByVal path As String) As String
    Dim oNode As CustomXMLNode
    path = Replace(path, "/", "/" & prefix)
    Dim value As String
    Set oNode = CustomXML.SelectSingleNode(prefix & "doc" & path)
    If oNode Is Nothing Then
        value = ""
    Else
        value = oNode.text
    End If
    Set oNode = Nothing
    ReadText = value
End Function

Public Function DataHasChanged() As Boolean
    Dim prefix As String
    prefix = "/DocumentInfo/DocumentInfo-"
    ' Check revison first.
    If HasChanged(prefix & "Revision") Then DataHasChanged = True: Exit Function
    If HasChanged(prefix & "Date") Then DataHasChanged = True: Exit Function
    If HasChanged(prefix & "Description") Then DataHasChanged = True: Exit Function
    If HasChanged(prefix & "ClassificationLabel") Then DataHasChanged = True: Exit Function
    If HasChanged(prefix & "WorkflowLabel") Then DataHasChanged = True: Exit Function
    If HasChanged(prefix & "Author") Then DataHasChanged = True: Exit Function
    ' Then document info
    If HasChanged(prefix & "TitleLine1") Then DataHasChanged = True: Exit Function
    If HasChanged(prefix & "TitleLine2") Then DataHasChanged = True: Exit Function
    If HasChanged(prefix & "TitleLine3") Then DataHasChanged = True: Exit Function
    If HasChanged(prefix & "TitleLine4") Then DataHasChanged = True: Exit Function
    If HasChanged(prefix & "TitleLine5") Then DataHasChanged = True: Exit Function
    If HasChanged(prefix & "DocNo") Then DataHasChanged = True: Exit Function
    If HasChanged(prefix & "ProjectNo") Then DataHasChanged = True: Exit Function
    If HasChanged(prefix & "FileName") Then DataHasChanged = True: Exit Function
    If HasChanged(prefix & "SupplierFileName") Then DataHasChanged = True: Exit Function
    If HasChanged(prefix & "FrontPageInfo") Then DataHasChanged = True: Exit Function
    
    ' Then Language dependent values - Never?
    If HasChanged(prefix & "Copyright") Then DataHasChanged = True: Exit Function
    If HasChanged(prefix & "Disclaimer") Then DataHasChanged = True: Exit Function
    
    DataHasChanged = False
End Function

Public Function LanguageHasChanged() As Boolean
    Dim prefix As String
    prefix = "/DocumentInfo/DocumentInfo-"
    If HasChanged(prefix & "Language") Then LanguageHasChanged = True: Exit Function
    LanguageHasChanged = False
End Function

Public Function DocTypeHasChanged() As Boolean
    Dim prefix As String
    prefix = "/DocumentInfo/DocumentInfo-"
    If HasChanged(prefix & "DocType") Then DocTypeHasChanged = True: Exit Function
    DocTypeHasChanged = False
End Function

Public Function FrontMatterHasChanged() As Boolean
    Dim prefix As String
    prefix = "/DocumentInfo/DocumentInfo-"
    If HasChanged(prefix & "FrontMatter") Then FrontMatterHasChanged = True: Exit Function
    FrontMatterHasChanged = False
End Function

Public Function SetupHasChanged() As Boolean
    Dim prefix As String
    prefix = "/DocumentInfo/DocumentInfo-"
    If HasChanged(prefix & "FrontMatter") Then SetupHasChanged = True: Exit Function
    If HasChanged(prefix & "FrontPage") Then SetupHasChanged = True: Exit Function
    If HasChanged(prefix & "DocumentInformation") Then SetupHasChanged = True: Exit Function
    If HasChanged(prefix & "Language") Then SetupHasChanged = True: Exit Function
    If HasChanged(prefix & "DocType") Then SetupHasChanged = True: Exit Function
    If HasChanged(prefix & "RevisionHistory-Show") Then SetupHasChanged = True: Exit Function
    If HasChanged(prefix & "TOC") Then SetupHasChanged = True: Exit Function
    If HasChanged(prefix & "TOC-HeadingLevels") Then SetupHasChanged = True: Exit Function
    If HasChanged(prefix & "TOC-Headings") Then SetupHasChanged = True: Exit Function
    If HasChanged(prefix & "TOF") Then SetupHasChanged = True: Exit Function
    If HasChanged(prefix & "CaptionHeading") Then SetupHasChanged = True: Exit Function
    If HasChanged(prefix & "Logo") Then SetupHasChanged = True: Exit Function
    If HasChanged(prefix & "SupplierFileName") Then SetupHasChanged = True: Exit Function
    If HasChanged(prefix & "CompanyLogo") Then SetupHasChanged = True: Exit Function
    If ThisBGD.NewTranslation Then SetupHasChanged = True: Exit Function
    If OldTranslation Then SetupHasChanged = True: Exit Function
    SetupHasChanged = False
End Function

Public Function HasChanged(ByVal pathOrSimplePath As String) As Boolean
    If InStr(pathOrSimplePath, "/") <= 0 Then pathOrSimplePath = "/DocumentInfo/DocumentInfo-" & pathOrSimplePath
    Dim oNode As MSXML2.IXMLDOMNode
    Set oNode = OriginalXML.DocumentElement.SelectSingleNode("/doc" & pathOrSimplePath)
    If oNode Is Nothing Then
        HasChanged = True
    Else
        HasChanged = (Me.ReadText(pathOrSimplePath) <> oNode.text)
    End If
End Function

Public Function WriteNode(ByVal path As String, ByVal value As Variant) As CustomXMLNode
    Dim oNode As CustomXMLNode
    path = Replace(path, "/", "/" & prefix)
    Set oNode = CustomXML.SelectSingleNode(prefix & "doc" & path)
    If oNode.text <> value Then
        oNode.text = value
        FieldsUpdated = True
'        If structureUpdate Then
'            'StructureUpdated = True
'        End If
    End If
    Set WriteNode = oNode
End Function

Public Function SetNode(ByVal path As String, nodeName As String, ByVal value As Variant) As CustomXMLNode
    Dim oNode As CustomXMLNode
    Dim childPath As String
    Dim prefixPath As String
    childPath = path & "/" & nodeName
    prefixPath = prefix & "doc" & Replace(childPath, "/", "/" & prefix)
    Set oNode = CustomXML.SelectSingleNode(prefixPath)
    If oNode Is Nothing Then
        Set SetNode = AddNode(path, nodeName, value)
    Else
        Set SetNode = WriteNode(childPath, value)
    End If
End Function

Public Function WriteText(ByVal path As String, ByVal value As Variant) As String
    On Error GoTo CannotUpdate
    Dim oNode As CustomXMLNode
    Dim oldValue As String
    
    path = Replace(path, "/", "/" & prefix)
    Set oNode = CustomXML.SelectSingleNode(prefix & "doc" & path)
    oldValue = oNode.text
    If oldValue <> value Then
        oNode.text = value
        FieldsUpdated = True
'        If structureUpdate Then
'            'StructureUpdated = True
'        End If
    End If
ExitUpdate:
    On Error GoTo 0
    Set oNode = Nothing
    WriteText = oldValue
    Exit Function
CannotUpdate:
    Resume ExitUpdate
    
End Function


Public Sub SetLanguage()
    Language = ReadText(PathLanguage)
    If Language = "" Then Language = "2057"
    If Language = "1034" Then Language = "3082" ' Spanish Traditional Sort => Modern Sort
    
    If OldLanguage <> Language Or LanguageUpdated Then
        LanguageUpdated = True
        FieldsUpdated = True
        UpdateCaptions = True
        
        Dim rows As Integer
        Dim row As Integer
        
        Dim i As Integer
        Dim j As Integer
        
        rows = UBound(aLanguages, 1)
        For row = 0 To rows
            If aLanguages(row, 0) = Language Then Exit For
        Next
        If row > rows Then
            Language = "2057"
            For row = 0 To rows
                If aLanguages(row, 0) = Language Then Exit For
            Next
        End If
        ' Update all language values
        WriteText PathLanguage, Language
        
        For i = 0 To UBound(LanguageFields)
            Dim iLanguage As String
            Dim iPathLanguage As String
            iLanguage = LanguageFields(i)
            iPathLanguage = PathLanguageFields(i)
            For j = 1 To UBound(LanguageFieldIndexes)
                If LanguageFieldIndexes(j) = iLanguage Then
                        WriteText iPathLanguage, aLanguages(row, j + 1)
                End If
            Next
        Next
    End If
End Sub

Public Function ReplaceRText(str As String) As String
    If str = "" Then
        ReplaceRText = ""
    Else
        ' ((?:^|\W)(CrisBag(?:\W||fffd|||fffd||$))|(?:^|\W)(BEUMER(?:\W||fffd|||fffd||$))|(?:^|\W)(autover(?:\W||fffd|||fffd||$))|(?:^|\W)(CrisBelt(?:\W||fffd|||fffd||$)))
        Dim rows As Integer
        Dim i As Integer
        Dim loops As Integer
        
        rows = UBound(aTerms, 1)
        For loops = 1 To 3
            For i = 0 To rows
                If str Like "*Crist*" And aTerms(i, 0) Like "*Crist*" Then
                    Debug.Print str
                    Stop
                End If
                str = Replace(str, aTerms(i, 0), aTerms(i, 1), , , vbTextCompare)
            Next
'
'        str = Replace(str, "CrisBag", "CrisBag|fffd|", , , vbTextCompare)
'        str = Replace(str, "Crisclaim", "CrisClaim|fffd|", , , vbTextCompare)
'        str = Replace(str, "Crisbelt", "CrisBelt|fffd|", , , vbTextCompare)
'        str = Replace(str, "Rampmate", "RampMate|fffd|", , , vbTextCompare)
'        str = Replace(str, "Crisstore", "CrisStore|fffd|", , , vbTextCompare)
'        str = Replace(str, "Autover", "autover|fffd|", , , vbTextCompare)
'        str = Replace(str, "Autoca", "autoca|fffd|", , , vbTextCompare)
'        str = Replace(str, "CrisCheck", "CrisCheck|fffd|", , , vbTextCompare)
'        str = Replace(str, "Crisplant", "Crisplant", , , vbTextCompare)
'        str = Replace(str, "BEUMER", "BEUMER", , , vbTextCompare)
'        str = Replace(str, "Christoph Beumer", "Christoph Beumer", , , vbTextCompare)
            str = Replace(str, "|fffd||fffd|", "|fffd|")
            str = Replace(str, "|fffd||fffd|", "|fffd|")
        Next
        
        ReplaceRText = str
    End If
End Function

Public Sub WriteLog(str As String)
On Error GoTo LogFailed
    'Debug.Print Now, str
    If Not TimerForm Is Nothing Then
        TimerForm.WriteLog str
    End If

ExitSub:
    On Error GoTo 0
    Exit Sub
    
LogFailed:
    Resume ExitSub
End Sub
    
Private Sub FillRevisionHistory(cc As ContentControl)
    Dim tbl As table
    Dim aRevHist() As String
    Dim RevCount As Integer
    Dim i As Integer
    Set tbl = cc.Range.Tables(1)
    aRevHist = ReadRevisionHistory
    RevCount = UBound(aRevHist, 1)
    For i = tbl.rows.Count To RevCount + 1
         tbl.rows.Add
    Next i
    For i = tbl.rows.Count To RevCount + 3 Step -1
         tbl.rows.Last.Delete
    Next
    For i = 0 To RevCount
        tbl.Cell(i + 2, 1).Range.text = aRevHist(i, 0)
        tbl.Cell(i + 2, 2).Range.text = aRevHist(i, 1)
        tbl.Cell(i + 2, 3).Range.text = aRevHist(i, 2)
        tbl.Cell(i + 2, 4).Range.text = aRevHist(i, 3)
    Next
End Sub

Public Sub ReformatTOC(rng As Range)
    InsertTabInFirstChar ThisDoc.Styles(WdBuiltinStyle.wdStyleTOC9).NameLocal
    ReplaceStyleInRange rng, ThisDoc.Styles(WdBuiltinStyle.wdStyleTOC1).NameLocal, "TOC1cp"
    ReplaceStyleInRange rng, ThisDoc.Styles(WdBuiltinStyle.wdStyleTOC2).NameLocal, "TOC2cp"
    ReplaceStyleInRange rng, ThisDoc.Styles(WdBuiltinStyle.wdStyleTOC3).NameLocal, "TOC3cp"
    ReplaceStyleInRange rng, ThisDoc.Styles(WdBuiltinStyle.wdStyleTOC4).NameLocal, "TOC4cp"
    ReplaceStyleInRange rng, ThisDoc.Styles(WdBuiltinStyle.wdStyleTOC5).NameLocal, "TOC5cp"
    ReplaceStyleInRange rng, ThisDoc.Styles(WdBuiltinStyle.wdStyleTOC6).NameLocal, "TOC6cp"
    ReplaceStyleInRange rng, ThisDoc.Styles(WdBuiltinStyle.wdStyleTOC7).NameLocal, "TOC7cp"
    ReplaceStyleInRange rng, ThisDoc.Styles(WdBuiltinStyle.wdStyleTOC8).NameLocal, "TOC8cp"
    ReplaceStyleInRange rng, ThisDoc.Styles(WdBuiltinStyle.wdStyleTOC9).NameLocal, "TOC9cp"
    ReplaceStyleInRange rng, ThisDoc.Styles(WdBuiltinStyle.wdStyleTableOfFigures).NameLocal, "Table of FiguresCP"
End Sub


Public Sub ReformatTOCOld(rng As Range)
    InsertTabInFirstChar ThisDoc.Styles(WdBuiltinStyle.wdStyleTOC9).NameLocal
    ReplaceStyleInRange ThisDoc.Content, ThisDoc.Styles(WdBuiltinStyle.wdStyleTOC1).NameLocal, "TOC1cp"
    ReplaceStyleInRange ThisDoc.Content, ThisDoc.Styles(WdBuiltinStyle.wdStyleTOC2).NameLocal, "TOC2cp"
    ReplaceStyleInRange ThisDoc.Content, ThisDoc.Styles(WdBuiltinStyle.wdStyleTOC3).NameLocal, "TOC3cp"
    ReplaceStyleInRange ThisDoc.Content, ThisDoc.Styles(WdBuiltinStyle.wdStyleTOC4).NameLocal, "TOC4cp"
    ReplaceStyleInRange ThisDoc.Content, ThisDoc.Styles(WdBuiltinStyle.wdStyleTOC5).NameLocal, "TOC5cp"
    ReplaceStyleInRange ThisDoc.Content, ThisDoc.Styles(WdBuiltinStyle.wdStyleTOC6).NameLocal, "TOC6cp"
    ReplaceStyleInRange ThisDoc.Content, ThisDoc.Styles(WdBuiltinStyle.wdStyleTOC7).NameLocal, "TOC7cp"
    ReplaceStyleInRange ThisDoc.Content, ThisDoc.Styles(WdBuiltinStyle.wdStyleTOC8).NameLocal, "TOC8cp"
    ReplaceStyleInRange ThisDoc.Content, ThisDoc.Styles(WdBuiltinStyle.wdStyleTOC9).NameLocal, "TOC9cp"
    ReplaceStyleInRange ThisDoc.Content, ThisDoc.Styles(WdBuiltinStyle.wdStyleTableOfFigures).NameLocal, "Table of FiguresCP"
End Sub

Public Sub InsertTabInFirstChar(styleName As String)
    Dim rng As Range
    Set rng = ThisDoc.Content
    With rng.find
         .ClearFormatting
         .Style = styleName
         While .Execute
            rng.InsertBefore vbTab
         Wend
    End With
End Sub

Public Sub ReformatTOCHyperlinks()
    Dim rng As Range
    Set rng = Nothing
    On Error Resume Next
    Set rng = ThisDoc.TablesOfContents.Item(1).Range
    'rng.Select
    On Error GoTo 0
    If Not rng Is Nothing Then ReplaceStyleInRange rng, ThisDoc.Styles(wdStyleHyperlink).NameLocal, "HyperLinkCP"
    Set rng = Nothing
    On Error Resume Next
    Set rng = ThisDoc.TablesOfFigures.Item(1).Range
    On Error GoTo 0
    If Not rng Is Nothing Then ReplaceStyleInRange rng, ThisDoc.Styles(wdStyleHyperlink).NameLocal, "HyperLinkCP"
    Set rng = Nothing
    On Error Resume Next
    Set rng = ThisDoc.TablesOfFigures.Item(2).Range
    On Error GoTo 0
    If Not rng Is Nothing Then ReplaceStyleInRange rng, ThisDoc.Styles(wdStyleHyperlink).NameLocal, "HyperLinkCP"

End Sub

Private Sub ReplaceStyleInRange(rng As Range, oldStyle As Variant, NewStyle As String)
    
    With rng.find
         .ClearFormatting
         .Style = oldStyle
         .Replacement.Style = NewStyle
         .Execute
         'rng.Select
         If .found Then
            .Execute Replace:=wdReplaceAll
         End If
     End With
End Sub


Public Sub SetHeaderFooter(Optional force As Boolean = False)
    Dim rngInsert As Range
    Dim cc As ContentControl
    Dim head As Range
    Dim foot As Range
    
    
    Dim ccsPH As ContentControls
    Dim ccsPF As ContentControls
    Set ccsPH = ThisDoc.SelectContentControlsByTag("Container:PrimaryHeader")
    Set ccsPF = ThisDoc.SelectContentControlsByTag("Container:PrimaryFooter")
    
    If Not force And (ccsPH.Count > 0 And ccsPF.Count > 0) Then Exit Sub
    
    Set head = ThisDoc.Sections(1).Headers(wdHeaderFooterPrimary).Range
    Set foot = ThisDoc.Sections(1).Footers(wdHeaderFooterPrimary).Range
    head.Delete
    foot.Delete
    Set rngInsert = ThisDoc.attachedTemplate.BuildingBlockEntries("zzHeader").Insert(Where:=head, RichText:=True)
    Set rngInsert = ThisDoc.attachedTemplate.BuildingBlockEntries("zzFooter").Insert(Where:=foot, RichText:=True)
    Set head = ThisDoc.Sections(1).Headers(wdHeaderFooterPrimary).Range
    Set foot = ThisDoc.Sections(1).Footers(wdHeaderFooterPrimary).Range
    head.Paragraphs.Last.Range.Delete
    foot.Paragraphs.Last.Range.Delete
    
End Sub


Public Sub SpecialFirstHeaderFooter(Optional force As Boolean = False)
    Dim rngInsert As Range
    Dim cc As ContentControl
    Dim head As Range
    Dim foot As Range
    
    Dim ccsFPH As ContentControls
    Dim ccsFPF As ContentControls
    Set ccsFPH = ThisDoc.SelectContentControlsByTag("Container:FirstPageHeader")
    Set ccsFPF = ThisDoc.SelectContentControlsByTag("Container:FirstPageFooter")
    If ccsFPF.Count = 0 Then Set ccsFPF = ThisDoc.SelectContentControlsByTag("Container:FrontPageFooter") ' Old
    
    With ThisDoc.PageSetup
        On Error Resume Next
        If Not .DifferentFirstPageHeaderFooter Then .DifferentFirstPageHeaderFooter = True
        On Error GoTo 0
    End With
    
    If Not force And (ccsFPH.Count > 0 And ccsFPF.Count > 0) Then Exit Sub
    
    Set head = ThisDoc.Sections(1).Headers(wdHeaderFooterFirstPage).Range
    Set foot = ThisDoc.Sections(1).Footers(wdHeaderFooterFirstPage).Range
    head.Delete
    foot.Delete
    Set rngInsert = ThisDoc.attachedTemplate.BuildingBlockEntries("zzFrontPageHeader").Insert(Where:=head, RichText:=True)
    Set rngInsert = ThisDoc.attachedTemplate.BuildingBlockEntries("zzFrontPageFooter").Insert(Where:=foot, RichText:=True)
    Set head = ThisDoc.Sections(1).Headers(wdHeaderFooterFirstPage).Range
    Set foot = ThisDoc.Sections(1).Footers(wdHeaderFooterFirstPage).Range
    head.Paragraphs.Last.Range.Delete
    foot.Paragraphs.Last.Range.Delete
End Sub

Public Sub Prolog(UndoText As String, Optional screenUpdate As Boolean = False)
        
    On Error GoTo ExitSub
    Saved = ThisDoc.Saved
    updated = False
    Set Undo = Application.UndoRecord
    Undo.StartCustomRecord UndoText
    System.Cursor = wdCursorWait
    Application.ScreenUpdating = screenUpdate
    On Error GoTo 0
    GoTo ExitSubClean
ExitSub:
    On Error GoTo 0
    updated = False
    System.Cursor = wdCursorNormal
ExitSubClean:
    Exit Sub
End Sub


Public Sub Epilog()
    On Error GoTo ExitSub
    If updated Then
        Undo.EndCustomRecord
        ThisDoc.Saved = False
    Else
        Undo.EndCustomRecord
        ThisDoc.Undo
        ThisDoc.Saved = Saved
    End If
ExitSub:
    On Error GoTo 0
    updated = False
    Application.ScreenUpdating = True
    System.Cursor = wdCursorNormal
    Exit Sub
End Sub


Public Function GetPaperFormat() As String
    Dim paperFormat As String
    Select Case ThisDoc.PageSetup.PaperSize
    Case wdPaperA4
        paperFormat = "A4"
    Case wdPaperA3
        paperFormat = "A3"
    Case wdPaperLetter
        paperFormat = "Letter"
    Case wdPaperTabloid, 1
        paperFormat = "Tabloid"
    Case Else
    End Select
    If paperFormat > "" Then
        If ThisDoc.PageSetup.Orientation = wdOrientPortrait Then
            paperFormat = paperFormat & " - Portrait"
        Else
            paperFormat = paperFormat & " - Landscape"
        End If
    End If
    GetPaperFormat = paperFormat
End Function



Public Sub ChangePaperFormat()
    
    If NewPaperFormat = "Detect" Then NewPaperFormat = GetPaperFormatFromPageSetup(ThisDoc)
    
    Dim useDocument As Boolean
    useDocument = False
    Dim obj As Object
    Set obj = Selection
    
    On Error GoTo ErrorReDo
ReDo:
    With obj.PageSetup
        Select Case NewPaperFormat
        Case "A4 - Portrait"
            .PaperSize = wdPaperA4
            .Orientation = wdOrientPortrait
            .TopMargin = 99.25
            .BottomMargin = 81.5 ' 77.5 ' 44.5
            .LeftMargin = 70.9
            .RightMargin = 70.9
            .HeaderDistance = 31.2
            .FooterDistance = 21.85 ' 17.85
            '.PageWidth = 595.35
            '.PageHeight = 842
        Case "Letter - Portrait"
            .PaperSize = wdPaperLetter
            .Orientation = wdOrientPortrait
            .TopMargin = 99.25
            .BottomMargin = 81.5 ' 77.5 ' 44.5
            .LeftMargin = 70.9
            .RightMargin = 70.9
            .HeaderDistance = 31.2
            .FooterDistance = 21.85 ' 17.85
            '.PageWidth = 612
            '.PageHeight = 792
        Case "A4 - Landscape"
            .PaperSize = wdPaperA4
            .Orientation = wdOrientLandscape
            .TopMargin = CentimetersToPoints(4.1) '99.25
            .BottomMargin = 81.5 ' 77.5 ' 44.5
            .LeftMargin = CentimetersToPoints(1#)  '70.9
            .RightMargin = CentimetersToPoints(1#)  '70.9
            .HeaderDistance = CentimetersToPoints(1.7) '31.2
            .FooterDistance = 21.85 ' 17.85
            '.PageWidth = 842
            '.PageHeight = 595.35
        Case "Letter - Landscape"
            .PaperSize = wdPaperLetter
            .Orientation = wdOrientLandscape
            .TopMargin = CentimetersToPoints(4.1) '99.25
            .BottomMargin = 81.5 ' 77.5 ' 44.5
            .LeftMargin = CentimetersToPoints(1#)  '70.9
            .RightMargin = CentimetersToPoints(1#)  '70.9
            .HeaderDistance = CentimetersToPoints(1.7) '31.2
            .FooterDistance = 21.85 ' 17.85
            '.PageWidth = 792
            '.PageHeight = 612
        Case "A3 - Portrait"
            .PaperSize = wdPaperA3
            .Orientation = wdOrientPortrait
            .TopMargin = 99.25
            .BottomMargin = 81.5 ' 77.5 ' 44.5
            .LeftMargin = 70.9
            .RightMargin = 70.9
            .HeaderDistance = 31.2
            .FooterDistance = 21.85 ' 17.85
            '.PageWidth = 842
            '.PageHeight = 595.35 * 2
        Case "Tabloid/Ledger - Portrait"
            .PaperSize = wdPaperTabloid
            .Orientation = wdOrientPortrait
            .TopMargin = 99.25
            .BottomMargin = 81.5 ' 77.5 ' 44.5
            .LeftMargin = 70.9
            .RightMargin = 70.9
            .HeaderDistance = 31.2
            .FooterDistance = 21.85 ' 17.85
            '.PageWidth = 792
            '.PageHeight = 612 * 2
        Case "A3 - Landscape"
            .PaperSize = wdPaperA3
            .Orientation = wdOrientLandscape
            .TopMargin = 99.25
            .BottomMargin = 81.5 ' 77.5 ' 44.5
            .LeftMargin = 70.9
            .RightMargin = 70.9
            .HeaderDistance = 31.2
            .FooterDistance = 21.85 ' 17.85
            '.PageWidth = 595.35 * 2
            '.PageHeight = 842
        Case "Tabloid/Ledger - Landscape"
            .PaperSize = wdPaperTabloid
            .Orientation = wdOrientLandscape
            .TopMargin = 99.25
            .BottomMargin = 81.5 ' 77.5 ' 44.5
            .LeftMargin = 70.9
            .RightMargin = 70.9
            .HeaderDistance = 31.2
            .FooterDistance = 21.85 ' 17.85
            '.PageWidth = 612 * 2
            '.PageHeight = 792
        End Select
    End With
    
NoReDo:
    SetTabs NewPaperFormat
    NewPaperFormat = ""
    
    Exit Sub
    
ErrorReDo:
    If useDocument Then
        Resume NoReDo
    Else
        useDocument = True
        Set obj = ThisDoc
        Resume ReDo
    End If
End Sub

Private Sub SetTabs(paperFormat As String)
    SetTabsOnStyle ThisDoc, paperFormat, "TOC1cp"
    SetTabsOnStyle ThisDoc, paperFormat, "Table of Figures"
End Sub

Private Sub SetTabsOnStyle(doc As Document, paperFormat As String, styleName As String)
    Dim tabStop As Double
    tabStop = doc.PageSetup.PageWidth - 141.8
    With doc.Styles(styleName)
        
        .AutomaticallyUpdate = False
        .ParagraphFormat.TabStops.ClearAll
        .ParagraphFormat.TabStops.Add Position:=85.05, Alignment:=wdAlignTabLeft, Leader:=wdTabLeaderSpaces
        Select Case paperFormat
        Case "A4 - Portrait"
            .ParagraphFormat.TabStops.Add Position:=tabStop, Alignment:=wdAlignTabRight, Leader:=wdTabLeaderDots
        Case "Letter - Portrait"
            .ParagraphFormat.TabStops.Add Position:=tabStop, Alignment:=wdAlignTabRight, Leader:=wdTabLeaderDots
        Case "A4 - Landscape"
            .ParagraphFormat.TabStops.Add Position:=tabStop + 85.05, Alignment:=wdAlignTabRight, Leader:=wdTabLeaderDots
        Case "Letter - Landscape"
            .ParagraphFormat.TabStops.Add Position:=tabStop + 85.05, Alignment:=wdAlignTabRight, Leader:=wdTabLeaderDots
        Case "A3 - Portrait"
            .ParagraphFormat.TabStops.Add Position:=tabStop, Alignment:=wdAlignTabRight, Leader:=wdTabLeaderDots
        Case "Tabloid/Ledger - Portrait"
            .ParagraphFormat.TabStops.Add Position:=tabStop, Alignment:=wdAlignTabRight, Leader:=wdTabLeaderDots
        Case "A3 - Landscape"
            .ParagraphFormat.TabStops.Add Position:=tabStop, Alignment:=wdAlignTabRight, Leader:=wdTabLeaderDots
        Case "Tabloid/Ledger - Landscape"
            .ParagraphFormat.TabStops.Add Position:=tabStop, Alignment:=wdAlignTabRight, Leader:=wdTabLeaderDots
        End Select
    End With
End Sub

Public Sub SetCaptions(figureOrTable As String)
    Dim collCC As ContentControls
    Dim aCC() As Variant
    Dim cc As ContentControl
    Dim ccRng As Range
    Dim rng As Range
    Dim rngInsert As Range
    Dim fld As field
    Dim code As String
    Dim idx As Integer
    
    Dim lastStyleref As String
    lastStyleref = ""
    Dim resetSeq As Boolean
    resetSeq = False
    
    
    Dim CaptionHeading As String
    Dim caption As String
    
    CaptionHeading = ReadText("/DocumentInfo/DocumentInfo-CaptionHeading")
    caption = ReadText("/DocumentLabel/DocumentLabel-" & figureOrTable & "Caption")
    
    Set collCC = ThisDoc.SelectContentControlsByTag("DocumentLabel-" & figureOrTable & "Caption")
    
    If collCC.Count > 0 Then
        ReDim aCC(collCC.Count - 1, 1) As Variant
        Dim i As Integer
        For i = 1 To collCC.Count
            aCC(i - 1, 1) = i
            aCC(i - 1, 0) = collCC(i).Range.start
        Next
        QuickSortArray aCC
        
        For i = 1 To collCC.Count
            idx = aCC(i - 1, 1)
            Set cc = collCC(idx)
            Set ccRng = cc.Range
            If ccRng.text <> caption Then ccRng.text = caption
        Next
        
        For i = 1 To collCC.Count
            idx = aCC(i - 1, 1)
            Set cc = collCC(idx)
            Set ccRng = cc.Range
            If ccRng.text <> caption Then ccRng.text = caption
            Set rng = ccRng.Paragraphs(1).Range
            Debug.Print rng.text
            For Each fld In rng.fields
                Debug.Print fld.code.text
            Next
            If rng.fields.Count > 0 Then
                For Each fld In rng.fields
                    'If i = 3 Then Debug.Print fld.code.Text, fld.Result.Text
                    If Not Trim(LCase(fld.code.text)) Like "ref*" Then fld.Update
                Next
                Set fld = rng.fields(1)
                code = Trim(LCase(fld.code.text))
                If code Like "ref*" Then
                    'Debug.Print code
                    ' fld.Update
                ElseIf Not InStr(1, code, caption, vbTextCompare) And Not Trim(LCase(fld.code.text)) Like "styleref*" Then
                    'Debug.Print code
                    If CaptionHeading <> "none" Then
                        Set rngInsert = ccRng.Duplicate
                        rngInsert.MoveEnd wdCharacter, 2
                        rngInsert.Collapse wdCollapseEnd
                        rngInsert.InsertAfter "-"
                        rngInsert.Collapse wdCollapseStart
                        Set fld = rngInsert.fields.Add(rngInsert)
                        fld.code.text = "STYLEREF """ & CaptionHeading & """ \n"
                        fld.Update
                    End If
                Else
                    'Debug.Print code
                    If CaptionHeading = "none" Then 'none
                        If Not code Like "seq*" Then
                            'Debug.Print "none:Remove field"
                            Set rngInsert = fld.result.Duplicate
                            fld.Delete
                            rngInsert.MoveEnd wdCharacter, 1
                            rngInsert.Delete
                        End If
                        Set fld = rng.fields(rng.fields.Count)
                        fld.Update
                        If lastStyleref <> "1" Then
                            resetSeq = True
                        End If
                        lastStyleref = "1"
                    Else ' 1..3
                        If Trim(LCase(fld.code.text)) Like "styleref*" Then
                            'Debug.Print "1..3:update field"
                            If Not InStr(1, fld.code.text, CaptionHeading, vbTextCompare) > 0 Then
                                fld.code.text = "STYLEREF """ & CaptionHeading & """ \n"
                                fld.Update
                            End If
                            If lastStyleref <> fld.result.text Then
                                resetSeq = True
                            End If
                            lastStyleref = fld.result.text
                        Else
                            'Debug.Print "1..3:insert seq field"
                            Set rngInsert = ccRng.Duplicate
                            rngInsert.MoveEnd wdCharacter, 2
                            rngInsert.Collapse wdCollapseEnd
                            rngInsert.InsertAfter "-"
                            rngInsert.Collapse wdCollapseStart
                            Set fld = rngInsert.fields.Add(rngInsert)
                            fld.code.text = "STYLEREF """ & CaptionHeading & """ \n"
                            fld.Update
                        End If
                    End If
                    Set fld = rng.fields(rng.fields.Count)
                    'fld.Select
                    'Debug.Print i, "Table", fld.Code.Text, fld.Code.Start, fld.Result.Text
                    If resetSeq Then
                        If Not LCase(fld.code.text) Like "*\r*" Then
                            If Not (fld.code.text = Replace(fld.code.text & " \r 1", "  ", " ")) Then
                                fld.code.text = Replace(fld.code.text & " \r 1", "  ", " ")
                            End If
                        Else
                            'If Not (fld.code.Text = Replace(fld.code.Text, "  ", " ")) Then
                            '    fld.code.Text = Replace(fld.code.Text, "  ", " ")
                            'End If
                        End If
                    Else
                        If LCase(fld.code.text) Like "*\r*" Then
                            If Not (fld.code.text = Replace(Replace(Replace(fld.code.text, "\r 1", ""), "\r1", ""), "  ", " ")) Then
                                fld.code.text = Replace(Replace(Replace(fld.code.text, "\r 1", ""), "\r1", ""), "  ", " ")
                            End If
                        Else
                            'If Not (fld.code.Text = Replace(fld.code.Text, "  ", " ")) Then
                            '    fld.code.Text = Replace(fld.code.Text, "  ", " ")
                            'End If
                        End If
                    End If
                    fld.Update
                    resetSeq = False
                End If
            End If
        Next
    End If
        
'    Set collCC = ThisDoc.SelectContentControlsByTag("DocumentLabel-" & figureOrTable & "Caption")
'
'    If collCC.Count > 0 Then
'        ReDim aCC(collCC.Count - 1, 1) As Variant
'        For i = 1 To collCC.Count
'            aCC(i - 1, 1) = i
'            aCC(i - 1, 0) = collCC(i).Range.Start
'        Next
'        QuickSortArray aCC
'
'        For i = 1 To collCC.Count
'            idx = aCC(i - 1, 1)
'            Set cc = collCC(idx)
'            Set ccRng = cc.Range
'            If ccRng.Text <> caption Then ccRng.Text = caption
''            Set rng = ccRng.Paragraphs(1).Range
''            'Debug.Print rng.Text
''            If rng.fields.Count > 0 Then
''                Set fld = rng.fields(1)
''                code = Trim(LCase(fld.code.Text))
''                If code Like "ref*" Then
''                    fld.Update
''                End If
''            End If
'        Next
'
'    End If

End Sub

Public Function GetFirstContentControlByTag(tag As String) As ContentControl
    Dim ccs As ContentControls
    Set ccs = ThisDoc.SelectContentControlsByTag(tag)
    If ccs.Count = 0 Then
        Set GetFirstContentControlByTag = Nothing
    Else
        Set GetFirstContentControlByTag = ccs(1)
    End If
End Function

Public Sub ResetContentControls()
    Set ccRevisions = Nothing
    Set ccFrontPage = Nothing
    Set ccDocumentInformation = Nothing
    Set ccFileName = Nothing
    Set ccSupplierFileName = Nothing
    Set ccSupplierFileNameLabel = Nothing
    Set ccCopyright = Nothing
    Set ccDisclaimer = Nothing
    Set ccTranslation = Nothing
    Set ccTOC = Nothing
    Set ccTOF = Nothing
    Set ccTOT = Nothing
    Set ccTOCLabel = Nothing
    Set ccTOFLabel = Nothing
    Set ccTOTLabel = Nothing
    Set ccFrontPageHeader = Nothing
    Set ccFrontPageFooter = Nothing
End Sub

Public Sub GetMainDocInfo()
  
    CaptionHeading = ReadText("/DocumentInfo/DocumentInfo-CaptionHeading")
    If DocType = "" Then DocType = ReadText("/DocumentInfo/DocumentInfo-DocType")
    Set ccFrontMatter = GetFirstContentControlByTag("DocumentInfo-FrontMatter:DocumentInformation")
    Set ccRevisions = GetFirstContentControlByTag("DocumentInfo-Revisions:DocumentInformation")
    Set ccFrontPage = GetFirstContentControlByTag("DocumentInfo-FrontPage:FrontPage")
    Set ccDocumentInformation = GetFirstContentControlByTag("DocumentInfo-DocumentInformation:DocumentInformation")
    Set ccFileName = GetFirstContentControlByTag("DocumentInfo-FileName:DocumentInformation")
    Set ccSupplierFileName = GetFirstContentControlByTag("DocumentInfo-SupplierFileName:DocumentInformation")
    Set ccSupplierFileNameLabel = GetFirstContentControlByTag("DocumentLabel-SupplierFileName:DocumentInformation")
    Set ccCopyright = GetFirstContentControlByTag("DocumentInfo-Copyright:DocumentInformation")
    Set ccDisclaimer = GetFirstContentControlByTag("DocumentInfo-Disclaimer:DocumentInformation")
    Set ccTranslation = GetFirstContentControlByTag("DocumentInfo-Translation")
    Set ccTOC = GetFirstContentControlByTag("DocumentInfo-TOC:DocumentInformation")
    Set ccTOF = GetFirstContentControlByTag("DocumentInfo-TOF:DocumentInformation")
    Set ccTOT = GetFirstContentControlByTag("DocumentInfo-TOT:DocumentInformation")
    Set ccTOCLabel = GetFirstContentControlByTag("DocumentInfo-TOCLabel:DocumentInformation")
    Set ccTOFLabel = GetFirstContentControlByTag("DocumentInfo-TOFLabel:DocumentInformation")
    Set ccTOTLabel = GetFirstContentControlByTag("DocumentInfo-TOTLabel:DocumentInformation")
    Set ccFrontPageHeader = GetFirstContentControlByTag("DocumentInfo-Logo:FrontPageHeader")
    Set ccHeader = GetFirstContentControlByTag("DocumentInfo-Logo:Header")
    Set ccFrontPageFooter = GetFirstContentControlByTag("DocumentInfo-Copyright:FrontPageFooter")
    Set ccFooter = GetFirstContentControlByTag("DocumentInfo-Copyright:Footer")
    
    showFrontMatter = ReadText("/DocumentInfo/DocumentInfo-FrontMatter")
    If ThisBGD.NewTranslation Then
        showFrontMatter = "Translation"
    End If
    OldTranslation = Not (ccTranslation Is Nothing)
    
    If showFrontMatter = "Translation" Then
        ' Transfer text from line 1 to 5
        ShowFrontPage = ""
        ShowSupplierFileName = ""
        ShowDocumentInformation = ""
        ShowRevisions = ReadText("/DocumentInfo/DocumentInfo-RevisionHistory-Show")
        ShowTOC = ""
        ShowTOF = ""
        ShowTOT = ""
    Else
        ShowFrontPage = ReadText("/DocumentInfo/DocumentInfo-FrontPage")
        ShowSupplierFileName = ReadText("/DocumentInfo/DocumentInfo-SupplierFileName")
        ShowDocumentInformation = ReadText("/DocumentInfo/DocumentInfo-DocumentInformation")
        ShowRevisions = ReadText("/DocumentInfo/DocumentInfo-RevisionHistory-Show")
        ShowTOC = ReadText("/DocumentInfo/DocumentInfo-TOC")
        ShowTOF = ReadText("/DocumentInfo/DocumentInfo-TOF")
        ShowTOT = ReadText("/DocumentInfo/DocumentInfo-TOT")
    End If
    
    If showFrontMatter = "" _
    And (ShowFrontPage = "") _
    And (ShowSupplierFileName = "") _
    And (ShowDocumentInformation = "") _
    And (ShowRevisions = "") _
    And (ShowTOC = "") _
    And (ShowTOF = "") _
    And (ShowTOT = "") Then
       showFrontMatter = "Hide"
    End If
    
    If showFrontMatter = "" Then
        If (ShowFrontPage <> "Standard") <> (ccFrontPage Is Nothing) _
        Or (ShowSupplierFileName = "") <> (ccSupplierFileName Is Nothing) _
        Or (ShowDocumentInformation <> "Standard") <> (ccDocumentInformation Is Nothing) _
        Or (ShowRevisions <> "Standard") <> (ccRevisions Is Nothing) _
        Or (ShowTOC <> "Standard") <> (ccTOC Is Nothing) _
        Or (ShowTOF <> "Standard") <> (ccTOF Is Nothing) _
        Or (ShowTOT <> "Standard") <> (ccTOT Is Nothing) _
        Or Not ccTranslation Is Nothing Or showFrontMatter = "Translation" Then
           RebuildFrontMatter = True
        End If
    ElseIf showFrontMatter = "Translation" And ccTranslation Is Nothing Then
        RebuildFrontMatter = True
    ElseIf showFrontMatter = "Translation" Then
        RebuildFrontMatter = True
    End If
    
End Sub

Public Function ReloadTemplateStyles() As Boolean
    Dim ccs As Collection
    Set ccs = UnlockAllContentControls
    ThisDoc.CopyStylesFromTemplate (ThisDoc.attachedTemplate.fullName)
    LanguageUpdated = True
    SetLanguage
    LockAllContentControls ccs
    ReloadTemplateStyles = True
    
End Function

Public Function SetStyle(styNameOrNo As Variant) As Boolean
    Dim updated As Boolean
    updated = True
    
    On Error GoTo ReturnError
    Dim sty As Style
    Set sty = ThisDoc.Styles(styNameOrNo)
    Selection.Style = sty
    On Error GoTo 0

DoExit:
    SetStyle = updated
    Exit Function

ReturnError:
    updated = False
    Resume DoExit
End Function

Public Sub GetTranslation()
    Dim str As String
    Dim cc As ContentControl
    Set cc = GetFirstContentControlByTag("DocumentInfo-TitleLine1:Translation")
    Dim ccRevisions As ContentControl
    Set ccRevisions = GetFirstContentControlByTag("DocumentInfo-Revisions:DocumentInformation")
    If Not cc Is Nothing Then
        If cc.ShowingPlaceholderText Then
            str = ""
        Else
            str = ReplaceRText(Trim(cc.Range.text))
        End If
        WriteText "/DocumentInfo/DocumentInfo-TitleLine1", str
    End If
    Set cc = GetFirstContentControlByTag("DocumentInfo-TitleLine2:Translation")
    If Not cc Is Nothing Then
        If cc.ShowingPlaceholderText Then
            str = ""
        Else
            str = ReplaceRText(Trim(cc.Range.text))
        End If
        WriteText "/DocumentInfo/DocumentInfo-TitleLine2", str
    End If
    Set cc = GetFirstContentControlByTag("DocumentInfo-TitleLine3:Translation")
    If Not cc Is Nothing Then
        If cc.ShowingPlaceholderText Then
            str = ""
        Else
            str = ReplaceRText(Trim(cc.Range.text))
        End If
        WriteText "/DocumentInfo/DocumentInfo-TitleLine3", str
    End If
    Set cc = GetFirstContentControlByTag("DocumentInfo-TitleLine4:Translation")
    If Not cc Is Nothing Then
        If cc.ShowingPlaceholderText Then
            str = ""
        Else
            str = ReplaceRText(Trim(cc.Range.text))
        End If
        WriteText "/DocumentInfo/DocumentInfo-TitleLine4", str
    End If
    Set cc = GetFirstContentControlByTag("DocumentInfo-TitleLine5:Translation")
    If Not cc Is Nothing Then
        If cc.ShowingPlaceholderText Then
            str = ""
        Else
            str = ReplaceRText(Trim(cc.Range.text))
        End If
        WriteText "/DocumentInfo/DocumentInfo-TitleLine5", str
    End If
    If Not ccRevisions Is Nothing Then
        Dim revisions As Integer
        Dim revisionsDoc As Integer
        Dim aRevHistDoc() As String
        Dim aRevHist() As String
        aRevHistDoc = ReadRevisions(False)
        
        'Merge with existing revision history
        aRevHist = ReadRevisionHistory
        
        revisions = UBound(aRevHist, 1) + 1
        revisionsDoc = UBound(aRevHistDoc, 1) + 1
        If revisions <> revisionsDoc Then
            MsgBox "Number of revisions has changed during translation", vbCritical + vbOKOnly, "Error in Translated Document"
        ElseIf revisions > 0 And aRevHist(0, 0) > "" Then
            'Copy revision descriptions
            Dim r As Integer
            For r = 0 To revisions - 1
                aRevHist(r, 3) = Replace(aRevHistDoc(revisions - r - 1, 3), Chr(11), vbCr)
            Next
            
            WriteText "/DocumentInfo/DocumentInfo-Revision", Replace(aRevHist(revisions - 1, 0), Chr(11), vbCr)
            WriteText "/DocumentInfo/DocumentInfo-Date", Replace(aRevHist(revisions - 1, 1), Chr(11), vbCr)
            WriteText "/DocumentInfo/DocumentInfo-Author", Replace(aRevHist(revisions - 1, 2), Chr(11), vbCr)
            WriteText "/DocumentInfo/DocumentInfo-Description", Replace(aRevHist(revisions - 1, 3), Chr(11), vbCr)
        Else
            WriteText "/DocumentInfo/DocumentInfo-Revision", GetNewMajor("")
            WriteText "/DocumentInfo/DocumentInfo-Date", Format(Now, "YYYY-MM-DD")
            WriteText "/DocumentInfo/DocumentInfo-Author", UserName
            WriteText "/DocumentInfo/DocumentInfo-Description", ""
        End If
        WriteRevisionHistory aRevHist
    End If
    
End Sub

Public Sub SetContentProperties(DocType As String)
    Dim prop As MetaProperty
    Dim i As Integer
    Dim j As Integer
    Dim formula As String
    Dim field As String

    Set prop = Nothing
    On Error Resume Next
    Set prop = ThisDoc.ContentTypeProperties(1)
    On Error GoTo 0
    If prop Is Nothing Then Exit Sub

    For i = 2 To UBound(aDocumentTypes)
        If aDocumentTypes(i, 0) = DocType Then
            Exit For
        End If
    Next
    
    For Each prop In ThisDoc.ContentTypeProperties
        Select Case prop.Name
        Case "Title Line 1"
            prop.value = ReadText("/DocumentInfo/DocumentInfo-TitleLine1")
        Case "Title Line 2"
            prop.value = ReadText("/DocumentInfo/DocumentInfo-TitleLine2")
        Case "Title Line 3"
            prop.value = ReadText("/DocumentInfo/DocumentInfo-TitleLine3")
        Case "Title Line 4"
            prop.value = ReadText("/DocumentInfo/DocumentInfo-TitleLine4")
        Case "Title Line 5"
            prop.value = ReadText("/DocumentInfo/DocumentInfo-TitleLine5")
        Case "Doc Type"
            prop.value = ReadText("/DocumentInfo/DocumentInfo-DocType")
        Case "Classification Label"
            prop.value = ReadText("/DocumentInfo/DocumentInfo-ClassificationLabel")
        Case "Project No."
            prop.value = ReadText("/DocumentInfo/DocumentInfo-ProjectNo")
        Case "Workflow Label"
            prop.value = ReadText("/DocumentInfo/DocumentInfo-WorkflowLabel")
        Case "Additional ID"
            prop.value = ReadText("/DocumentInfo/DocumentInfo-FrontPageInfo")
        Case "Doc No."
            prop.value = ReadText("/DocumentInfo/DocumentInfo-DocNo")
        Case "Supplier File Name"
            prop.value = ReadText("/DocumentInfo/DocumentInfo-SupplierFileName")
        
        
        'Revision
        Case "Rev No."
            prop.value = ReadText("/DocumentInfo/DocumentInfo-Revision")
        Case "Rev Date"
            prop.value = ReadText("/DocumentInfo/DocumentInfo-Date")
        Case "Rev Description"
            prop.value = ReadText("/DocumentInfo/DocumentInfo-Description")
        Case "Rev Author"
            prop.value = ReadText("/DocumentInfo/DocumentInfo-Author")
        
        ' Lookup
        Case "Doc Type"
            prop.value = DocType
        Case "Doc Main Type"
            Dim docMainType As String
            prop.value = "Project Document"
            docMainType = "Project Document"
            For j = 0 To UBound(aDocumentTypes, 1)
                If aDocumentTypes(j, 0) = DocType Then
                    prop.value = aDocumentTypes(j, 1)
                    Exit For
                End If
            Next
        Case "Language"
            Dim lang As String
            Dim l As Integer
            lang = ReadText("/DocumentInfo/DocumentInfo-Language")
            For l = 0 To UBound(aLanguages, 1)
                If aLanguages(l, 0) = lang Then
                    lang = aLanguages(l, 3)
                    Exit For
                End If
            Next
            If l > UBound(aLanguages, 1) Then
                prop.value = ""
            Else
                prop.value = lang
            End If
            If prop.validate > "" Then ' Failed
                prop.value = UCase(lang)
            End If
            If prop.validate > "" Then ' Failed again
                prop.value = lang
            End If
        ' RegEx From DocNo
        Case "Part"
            Dim strPart As String
            strPart = ReadText("/DocumentInfo/DocumentInfo-DocNo")
            If Not InStr(strPart, "/") > 0 Then
                strPart = "-"
            Else
                strPart = Trim(Split(strPart, "/")(0))
            End If
            prop.value = strPart
            If prop.validate > "" Then ' Failed
                If Len(strPart) > 1 Then
                    prop.value = Left(strPart, 1) & "-" & Mid(strPart, 2)
                End If
            End If
            If prop.validate > "" Then ' Failed again
                prop.value = strPart
            End If
        Case "Section"
            Dim strSection As String
            strSection = ReadText("/DocumentInfo/DocumentInfo-DocNo")
            If Not InStr(strSection, "/") > 0 Then
                strSection = "-"
            Else
                strSection = Trim(Split(strSection, "/")(1))
            End If
            prop.value = strSection
        ' Calculate from ProjectNo + DocNo
        Case "Doc Order"
            Dim strDocOrder As String
            Dim No1 As String
            Dim No2 As String
            Dim No3 As String
            Dim No4 As String
            Dim aNo() As String
            strDocOrder = ReadText("/DocumentInfo/DocumentInfo-DocNo")
            If Not InStr(strDocOrder, "/") > 0 Then
                strDocOrder = ""
            Else
                No1 = Trim(Split(strDocOrder, "/")(0))
                No4 = Trim(Split(strDocOrder, "/")(1))
                If No1 = "" Then
                    No1 = "0000"
                ElseIf Left(UCase(No1), 1) = "O" Then
                    No1 = "35" & Right("00" & No1, 2)
                ElseIf Left(UCase(No1), 1) = "M" Then
                    No1 = "55" & Right("00" & Mid(No1, 2), 2)
                Else
                    No1 = "75" & Right("00" & Mid(No1, 2), 2)
                End If
                If No4 > "" Then
                    No4 = Replace(No4, "-", "")
                    No2 = Left(No4, 1)
                    No3 = Mid(No4, 2)
                    No4 = ""
                End If
                If No3 = "" Then
                ElseIf InStr(No3, ".") > 0 Then
                    aNo = Split(No3, ".")
                    No3 = Right("00" & aNo(0), 2)
                    No4 = Right("00" & aNo(1), 2)
                Else
                    No3 = "00" & No3
                End If
                strDocOrder = No1 & No2 & No3 & No4
            End If
            prop.value = strDocOrder
        
        ' ????
        Case "Description"
            prop.value = ReadText("/DocumentInfo/DocumentInfo-Description")
        
        'Formula
        Case "Doc Search Title", "Doc Title"
            If i <= UBound(aDocumentTypes) Then
                For j = 1 To UBound(aDocumentTypes, 2)
                    field = aDocumentTypes(0, j)
                    formula = aDocumentTypes(i, j)
                    Select Case field
                        Case "DocSearchTitle", "DocTitle"
                            prop.value = CalculateTitle(formula, Me)
                    End Select
                Next
            End If
        End Select
        'Debug.Print prop.name, prop.value 'If prop.value = "" Then
        'Debug.Print "Case """ & prop.name & """"
        'Debug.Print , "prop.Value = ReadText(""/DocumentInfo/DocumentInfo-" & Replace(Replace(prop.name, "Title ", "Title"), " ", "") & """)"
    Next

End Sub

Public Sub UpdateContentInformation()
    Dim DocNo As String
    Dim line1 As String
    Dim line2 As String
    Dim Line3 As String
    Dim Line4 As String
    Dim Line5 As String
    Dim Title As String
    Dim Author As String
    Dim projectNo As String
    Dim NewTitle As String
    Dim NewSubject As String
    Dim DocType As String
    Dim formula As String
    Dim field As String
    Dim i As Integer
    Dim j As Integer
    
    line1 = ReadText("/DocumentInfo/DocumentInfo-TitleLine1")
    line2 = ReadText("/DocumentInfo/DocumentInfo-TitleLine2")
    Line3 = ReadText("/DocumentInfo/DocumentInfo-TitleLine3")
    Line4 = ReadText("/DocumentInfo/DocumentInfo-TitleLine4")
    Line5 = ReadText("/DocumentInfo/DocumentInfo-TitleLine5")
    DocNo = ReadText("/DocumentInfo/DocumentInfo-DocNo")
    projectNo = ReadText("/DocumentInfo/DocumentInfo-ProjectNo")
    Author = ReadText("/DocumentInfo/DocumentInfo-Author")
    DocType = ReadText("/DocumentInfo/DocumentInfo-DocType")
    
    CDP ThisDoc, "Title Line 1", msoPropertyTypeString, line1, True
    CDP ThisDoc, "Title Line 2", msoPropertyTypeString, line2, True
    CDP ThisDoc, "Title Line 3", msoPropertyTypeString, Line4, True
    CDP ThisDoc, "Title Line 4", msoPropertyTypeString, Line4, True
    CDP ThisDoc, "Title Line 5", msoPropertyTypeString, Line5, True
    CDP ThisDoc, "Doc No.", msoPropertyTypeString, DocNo, True
    CDP ThisDoc, "Project No.", msoPropertyTypeString, projectNo, True
    CDP ThisDoc, "Doc Type", msoPropertyTypeString, DocType, True
    
    CDP ThisDoc, "Classification Label", msoPropertyTypeString, ReadText("/DocumentInfo/DocumentInfo-ClassificationLabel"), True
    CDP ThisDoc, "Workflow Label", msoPropertyTypeString, ReadText("/DocumentInfo/DocumentInfo-WorkflowLabel"), True
    CDP ThisDoc, "Additional ID", msoPropertyTypeString, ReadText("/DocumentInfo/DocumentInfo-FrontPageInfo"), True
    CDP ThisDoc, "Supplier File Name", msoPropertyTypeString, ReadText("/DocumentInfo/DocumentInfo-SupplierFileName"), True
    CDP ThisDoc, "Rev No.", msoPropertyTypeString, ReadText("/DocumentInfo/DocumentInfo-Revision"), True
    CDP ThisDoc, "Rev Date", msoPropertyTypeString, ReadText("/DocumentInfo/DocumentInfo-Date"), True
    CDP ThisDoc, "Rev Description", msoPropertyTypeString, ReadText("/DocumentInfo/DocumentInfo-Description"), True
    CDP ThisDoc, "Rev Author", msoPropertyTypeString, ReadText("/DocumentInfo/DocumentInfo-Author"), True
    
    
    For i = 2 To UBound(aDocumentTypes)
        If aDocumentTypes(i, 0) = DocType Then
            Exit For
        End If
    Next
    If i <= UBound(aDocumentTypes) Then
        For j = 1 To UBound(aDocumentTypes, 2)
            field = aDocumentTypes(0, j)
            formula = aDocumentTypes(i, j)
            Select Case field
                Case "DocSearchTitle"
                    CDP ThisDoc, "Doc Search Title", msoPropertyTypeString, CalculateTitle(formula, Me), True
                Case "DocTitle"
                    CDP ThisDoc, "Doc Title", msoPropertyTypeString, CalculateTitle(formula, Me), True
            End Select
        Next
    End If
    
    If i <= UBound(aDocumentTypes) Then
        For j = 1 To UBound(aDocumentTypes, 2)
            field = aDocumentTypes(0, j)
            formula = aDocumentTypes(i, j)
            Select Case field
                Case "Title", "Subject"
                    ThisDoc.BuiltInDocumentProperties(field) = CalculateTitle(formula, Me)
            End Select
        Next
    Else ' Old Method
'        If DocNo > "" Then
'            NewTitle = DocNo
'            If Line3 > "" Then NewTitle = IIf(NewTitle > "", NewTitle & ", ", "") & Line3
'            If Line4 > "" Then NewTitle = IIf(NewTitle > "", NewTitle & " - ", "") & Line4
'            If Line5 > "" Then NewTitle = IIf(NewTitle > "", NewTitle & " - ", "") & Line5
'            If line1 > "" Then NewSubject = line1
'            If line2 > "" Then NewSubject = IIf(NewSubject > "", NewSubject & " - ", "") & line2
'        Else
'            NewTitle = projectNo
'            If line1 > "" Then NewTitle = IIf(NewTitle > "", NewTitle & ", ", "") & line1
'            If line2 > "" Then NewTitle = IIf(NewTitle > "", NewTitle & " - ", "") & line2
'            If Line3 > "" Then NewSubject = Line3
'            If Line4 > "" Then NewSubject = IIf(NewSubject > "", NewSubject & " - ", "") & Line4
'            If Line5 > "" Then NewSubject = IIf(NewSubject > "", NewSubject & " - ", "") & Line5
'        End If
'
'        If ThisDoc.BuiltInDocumentProperties("Author") <> Author Then
'            ThisDoc.BuiltInDocumentProperties("Author") = Author
'        End If
'
'        If ThisDoc.BuiltInDocumentProperties("Subject") <> NewSubject Then
'            ThisDoc.BuiltInDocumentProperties("Subject") = NewSubject
'        End If
'
'        Title = ThisDoc.BuiltInDocumentProperties("Title")
'        If Title <> NewTitle Then
'            ThisDoc.BuiltInDocumentProperties("Title") = NewTitle
'        End If
    End If
    SetContentProperties DocType
End Sub

Function GetLanguageFromFileName(fileName As String) As String
    fileName = UCase(fileName)
    Dim RegExpObj As Object
    Dim matches As Object
    Dim lang As String
    Dim code As String
    Dim found As Boolean
    found = False
    Set RegExpObj = CreateObject("vbscript.regexp")
    With RegExpObj
        .Pattern = "[_0-9]([A-Z][A-Z])[_0-9\.]"
        If .Test(fileName) Then
            found = True
        End If
        If Not found Then
            .Pattern = "[_0-9]([A-Z][A-Z])([0-9A-Z]?[_0-9\.][0-9])."
            If .Test(fileName) Then
                found = True
            End If
        End If
        If found Then
            Set matches = .Execute(fileName)
            lang = matches(0).SubMatches(0)
            Dim i As Integer
            For i = 0 To UBound(aLanguages, 1)
                If aLanguages(i, 4) Like "*" & UCase(lang) & "*" Then
                    code = aLanguages(i, 0)
                    Exit For
                End If
            Next
            Select Case UCase(lang)
            Case "UK", "US"
                code = "2057"
            Case "DK"
                code = "1030"
            End Select
        Else
            code = ""
        End If
        
        
    End With
    GetLanguageFromFileName = code
End Function

Public Sub FixOldCaptions()
    Dim fld As field
    Dim fldStyleref As field
    
    Dim rng As Range
    Dim rngHead As Range
    Dim fixField As Boolean
    Dim cc As ContentControl
    
    Dim CaptionHeading As String
    Dim FigureCaption As String
    Dim TableCaption As String
    Dim rngFld As Range
    Dim sty As Style
    
    Dim caption As String
    Dim tag As String
    
    CaptionHeading = ReadText("/DocumentInfo/DocumentInfo-CaptionHeading")
    FigureCaption = ReadText("/DocumentLabel/DocumentLabel-FigureCaption")
    TableCaption = ReadText("/DocumentLabel/DocumentLabel-TableCaption")
    
    For Each fld In GetDocumentRange.fields
        fixField = False
        If fld.Type = wdFieldSequence Then
            Set rng = fld.result.Paragraphs.first.Range
            Set sty = rng.Style
            If Not rng.ContentControls.Count > 0 Then
                Set rngHead = rng.Duplicate
                'Debug.Print fld.code, fld.result, fld.result.Paragraphs(1).Range.text, rngHead.ShapeRange.count, rngHead.InlineShapes.count, rngHead.fields.count, rng.ShapeRange.count, rng.InlineShapes.count, rng.fields.count
                If rngHead.fields.Count > 1 And Not (rngHead.fields(1).Type = wdFieldStyleRef) And Not (rngHead.fields(1).Type = wdFieldSequence) Then
                    'Debug.Print "Extra Field"
                    rngHead.start = rngHead.fields(1).result.End + 1
                    rngHead.InsertParagraphBefore
                    rngHead.start = rngHead.start + 1
                    rngHead.Select
                End If
                Do While rngHead.ShapeRange.Count + rngHead.InlineShapes.Count > 0
                    'Application.screenUpdating = True
                    rngHead.SetRange rngHead.start + rngHead.ShapeRange.Count + rngHead.InlineShapes.Count, fld.code.start - 1
                    'rngHead.Select
                Loop
                'If rngHead.fields.count > 0 Then
                '    rngHead.SetRange rngHead.fields(rngHead.fields.count).code.End + 1, fld.code.start - 1
                'End If
                'If rngHead.fields.count > 0 Then
                '    rngHead.SetRange rngHead.fields(rngHead.fields.count).result.End + 1, fld.code.start - 1
                'End If
                rngHead.SetRange rngHead.start, fld.code.start - 1
                'rngHead.Select
                Dim rngBB As Range
                
                If fld.code Like "*Table*" Then
                    fixField = True
                    caption = TableCaption
                    tag = "DocumentLabel-TableCaption"
                    rngHead.text = ""
                    Set rngBB = ThisDoc.attachedTemplate.BuildingBlockEntries("zzTableCaption").Insert(Where:=rngHead, RichText:=True)
                    rng.Style = ThisDoc.Styles("CaptionTable")
                ElseIf fld.code Like "*Figure*" Then
                    fixField = True
                    caption = FigureCaption
                    tag = "DocumentLabel-FigureCaption"
                    'If rngHead.fields.count > 0 Then rngHead.fields(1).Delete
                    rngHead.text = ""
                    Set rngBB = ThisDoc.attachedTemplate.BuildingBlockEntries("zzFigureCaption").Insert(Where:=rngHead, RichText:=True)
                    rng.Style = ThisDoc.Styles(wdStyleCaption)
                End If
                If fixField Then
                        Set fldStyleref = rngBB.fields(1)
    
                        If CaptionHeading = "none" Then
                            Set rngFld = fldStyleref.result.Duplicate
                            fldStyleref.Delete
                            rngFld.MoveEnd
                            rngFld.text = ""
                        Else
                            fldStyleref.code.text = "STYLEREF """ & CaptionHeading & """ \n"
                        End If
                        
                        
                        Set rngFld = fld.result.Duplicate
                        rngFld.SetRange rngFld.End + 1, rngFld.End + 2
                        Do While (rngFld.text = " " Or rngFld.text = "." Or rngFld.text = ":" Or rngFld.text = vbTab)
                            rngFld.text = ""
                            rngFld.SetRange rngFld.End, rngFld.End + 1
                        Loop
                        fld.Delete
                        rng.fields.Update
                End If
            End If
        End If
    Next
    
   Dim book As Bookmark
   Dim aCode() As String
   Dim bookRef As String
   Dim i As Integer
   
   For Each fld In GetDocumentRange.fields
        If fld.Type = wdFieldRef Then
            'fld.ShowCodes = True
            'Debug.Print fld.code
            aCode = Split(Trim(fld.code.text), " ")
            For i = 0 To UBound(aCode)
                If LCase(aCode(i)) Like "_ref*" Then
                    Exit For
                End If
            Next
            If i <= UBound(aCode) Then ' Found hidden bookmark reference
                bookRef = aCode(i)
                'Debug.Print "=> " & bookRef
                Set book = Nothing
                On Error Resume Next
                Set book = ThisDoc.Bookmarks(bookRef)
                On Error GoTo 0
                If Not book Is Nothing Then
                    If book.Range.ContentControls.Count > 0 Then
                        If book.Range.text Like "* " & vbTab Then
                            Set rng = book.Range.Duplicate
                            rng.SetRange book.Range.start, book.Range.End - 2
                            ThisDoc.Bookmarks.Add bookRef, rng
                        End If
                    End If
                    'fld.code.text = "REF " & bookRef & " \h"
                    'Debug.Print book.Range.Text
                End If
            End If
            'fld.Update
        ElseIf fld.Type = WdFieldType.wdFieldPageRef Then
            'fld.ShowCodes = True
            'Debug.Print fld.code
            aCode = Split(Trim(fld.code.text), " ")
            For i = 0 To UBound(aCode)
                If LCase(aCode(i)) Like "_ref*" Then
                    Exit For
                End If
            Next
            If i <= UBound(aCode) Then ' Found hidden bookmark reference
                bookRef = aCode(i)
                'Debug.Print "=> " & bookRef
                Set book = Nothing
                On Error Resume Next
                Set book = ThisDoc.Bookmarks(bookRef)
                On Error GoTo 0
                If Not book Is Nothing Then
                    If book.Range.ContentControls.Count > 0 Then
                        If book.Range.text Like "* " & vbTab Then
                            Set rng = book.Range.Duplicate
                            rng.SetRange book.Range.start, book.Range.End - 2
                            ThisDoc.Bookmarks.Add bookRef, rng
                        End If
                    End If
                    'fld.code.text = "PAGEREF " & bookRef & " \h"
                    'Debug.Print book.Range.Text
                End If
            End If
            'fld.Update
        End If
    Next fld
     
    
End Sub

Public Function ReadRevisions(Optional Sort As Boolean = True) As String()
    Dim aRevHist() As String
    ReDim aRevHist(0, 4)

    Dim str As String
    Dim strRev As String
    Dim tbl As Word.table
    Dim ce As Word.Cell
    Dim ce1 As Word.Cell
    Dim r As Word.row
    Dim r1 As Word.row
    Dim i As Integer
    Dim rng As Range
    Dim revisions As Integer
    revisions = 0
    Dim RevRevision As String
    Dim RevDateCP As String
    Dim RevInitials As String
    Dim RevComment As String
    Dim RevDate As String
    Dim revIndex As Integer
    revIndex = -1
    
    Set rng = ThisDoc.Content
    If rng.Tables.Count = 0 Then
        revIndex = -1
    End If
    If revIndex = -1 And rng.Tables.Count >= 1 Then
        Set tbl = rng.Tables(1)
        If tbl.Columns.Count = 4 Then
            revIndex = 1
        End If
    End If
    If revIndex = -1 And rng.Tables.Count >= 2 Then
        Set tbl = rng.Tables(2)
        If tbl.Columns.Count = 4 Then
            revIndex = 2
        End If
    End If
    If revIndex = -1 And rng.Tables.Count >= 3 Then
        Set tbl = rng.Tables(3)
        If tbl.Columns.Count = 4 Then
            revIndex = 3
        End If
    End If
    If revIndex = -1 Then
        revIndex = 0
    Else
        Set r = tbl.rows.Last
        Set r1 = tbl.rows.first
        Set ce = r.Cells(1)
        Set ce1 = r1.Cells(1)
        strRev = Replace(Trim(Left(ce1.Range.text, Len(ce1.Range.text) - 2)), ".", "")
        If strRev = "||" Or (Len(strRev) > 2 And (TableRevNames.Exists(LCase(strRev)) Or RevNames Like "*|" & LCase(strRev) & "*")) Then '  Or LCase(strRev) = "rev" Or LCase(strRev) = "rev." Or LCase(strRev) = "ausg."
            Do While Not r.IsFirst
                str = Trim(Left(ce.Range.text, Len(ce.Range.text) - 2))
                If str > "" And Not (str = "||" Or LCase(str) = "rev" Or LCase(str) = "rev." Or LCase(str) = "ausg.") Then
                    RevRevision = Trim(Replace(Replace(Replace(r.Cells(1).Range.text, vbCr, ""), vbTab, ""), ChrW(7), ""))
                    RevDateCP = Trim(Replace(Replace(Replace(r.Cells(2).Range.text, vbCr, ""), vbTab, ""), ChrW(7), ""))
                    RevInitials = Trim(Replace(Replace(Replace(r.Cells(3).Range.text, vbCr, ""), vbTab, ""), ChrW(7), ""))
                    RevComment = Trim(Replace(r.Cells(4).Range.text, ChrW(7), ""))
'                    If Len(RevRevision) > 1 Then RevRevision = Left(RevRevision, Len(RevRevision) - 1)
'                    If Len(RevInitials) > 1 Then RevInitials = Left(RevInitials, Len(RevInitials) - 1)
                    If Len(RevDateCP) > 1 Then
'                        RevDateCP = Left(RevDateCP, Len(RevDateCP) - 1)
                        RevDate = GetDateFromCrisplantDate(RevDateCP)
                        If IsDate(RevDate) Then
                            RevDate = Format(RevDate, "YYYY-MM-DD")
                        End If
                    End If
                    If Len(RevComment) > 0 Then
                        Do While Right(RevComment, 1) = vbCr Or Right(RevComment, 1) = vbLf
                            RevComment = Trim(Left(RevComment, Len(RevComment) - 1))
                        Loop
                    End If
                    If RevRevision & RevDateCP & RevInitials & RevComment > "" Then
                        revisions = revisions + 1
                        ReDimPreserve aRevHist, revisions - 1, 4
                        aRevHist(revisions - 1, 0) = RevRevision
                        aRevHist(revisions - 1, 1) = RevDate
                        aRevHist(revisions - 1, 2) = IIf(LCase(RevInitials) = "init", "Full Name", RevInitials)
                        aRevHist(revisions - 1, 3) = RevComment
                    End If
                End If
                Set r = r.Previous
                Set ce = r.Cells(1)
            Loop
            If Sort Then aRevHist = OrderRevisionHistory(aRevHist)
        Else
            revIndex = 0
        End If
    End If
    RevisionTableIndex = revIndex
    ReadRevisions = aRevHist
End Function

Public Function MoveTextBoxesToLastPage() As Boolean
On Error GoTo Failed
    Dim ok As Boolean
    
    Dim shp As Shape
    Dim i As Integer
    
    Dim rng As Range
    Set rng = ThisDoc.Content
    rng.SetRange 0, 0
    rng.Select
    rng.End = Selection.Bookmarks("\Page").Range.End
    
    Selection.EndKey Unit:=wdStory
    Selection.InsertBreak Type:=wdPageBreak
    Selection.InsertAfter "LastPage - Delete Again"
    
    For i = rng.ShapeRange.Count To 1 Step -1
        Set shp = rng.ShapeRange(i)
        If shp.Type = msoTextBox Then
            shp.LockAnchor = False
            shp.Select
            Selection.copy
            ThisDoc.Paragraphs.Last.Range.Select
            Selection.Collapse wdCollapseEnd
            Selection.PasteAndFormat wdPasteDefault
        End If
    Next
    ok = True
    
ExitIt:
    On Error GoTo 0
    MoveTextBoxesToLastPage = ok
    Exit Function

Failed:
    Select Case Err.Number
    Case Else
        Debug.Print "Case " & Err.Number & " '" & Err.Description
        ok = False
        Resume ExitIt
    End Select
End Function

Public Function MoveTextBoxesToFirstPage() As Boolean
On Error GoTo Failed
    Dim ok As Boolean
    
    Dim shp As Shape
    Dim i As Integer
    
    Dim rng As Range
    
    ThisDoc.Content.Paragraphs.Last.Range.Select
    'Selection.Collapse wdCollapseStart
    'Selection.Bookmarks("\Page").Range.Select
    Set rng = Selection.Range
    For i = rng.ShapeRange.Count To 1 Step -1
        Set shp = rng.ShapeRange(i)
        If shp.Type = msoTextBox Then
            shp.LockAnchor = False
            shp.Select
            Selection.Cut
            ThisDoc.Paragraphs.first.Range.Select
            Selection.Collapse wdCollapseStart
            Selection.PasteAndFormat wdPasteDefault
        End If
    Next
    
    Dim strt As Long
    strt = ThisDoc.GoTo(wdGoToPage, wdGoToLast).start
    Set rng = ThisDoc.Range(strt - 1, ThisDoc.Range.End)
    rng.Delete

'    ThisDoc.Content.Paragraphs.Last.Range.Select
'    Selection.Delete

    ok = True
    
ExitIt:
    On Error GoTo 0
    MoveTextBoxesToFirstPage = ok
    Exit Function

Failed:
    Select Case Err.Number
    Case Else
        Debug.Print "Case " & Err.Number & " '" & Err.Description
        ok = False
        Resume ExitIt
    End Select
End Function

Public Function ReadRevisionHistoryFromCommnets(comments As String) As String()
    Dim aRevHist() As String
    ReDim aRevHist(0, 4)
    Dim revisions As Integer
    revisions = 0

    Dim IsRevisionHistory As Boolean
    IsRevisionHistory = True
    Dim str As Variant
    Dim aComments() As String
    Dim aRevision() As String
    aComments = Split(Replace(comments, vbCr, vbLf), vbLf)
    For Each str In aComments
        'Debug.Print Trim(str)
        If InStr(str, ": ") <= 0 Then
            IsRevisionHistory = False
        Else
            aRevision = Split(Trim(str), ": ", 2)
            If UBound(aRevision) = 1 Then
                If Not IsNumeric(Trim(aRevision(0))) Then
                    IsRevisionHistory = False
                Else
                    If Not Fix(Trim(aRevision(0)) = Trim(aRevision(0))) Then
                        IsRevisionHistory = False
                    Else ' Valid
                        revisions = revisions + 1
                        ReDimPreserve aRevHist, revisions - 1, 4
                        aRevHist(revisions - 1, 0) = "0_" & Fix(Trim(aRevision(0)))
                        aRevHist(revisions - 1, 1) = ""
                        aRevHist(revisions - 1, 2) = ""
                        aRevHist(revisions - 1, 3) = Trim(aRevision(1))
                        'Debug.Print Fix(Trim(aRevision(0))), Trim(aRevision(1))
                    End If
                End If
            Else
                IsRevisionHistory = False
            End If
        End If
    Next
    'Debug.Print IsRevisionHistory
    ReadRevisionHistoryFromCommnets = aRevHist
End Function

Public Function GetDocumentRange() As Range
    Dim rng As Range
    Dim ccFrontMatter As ContentControl
    Set ccFrontMatter = GetFirstContentControlByTag("DocumentInfo-FrontMatter:DocumentInformation")
    Set rng = ThisDoc.Range
    If Not ccFrontMatter Is Nothing Then
        rng.start = ccFrontMatter.Range.End + 1
    End If
    Set GetDocumentRange = rng
End Function

Public Sub ReplaceWith(rng As Range, str As String)
    Dim find As String
    Dim repl As String
    Dim Registered As Boolean
    Dim aStr() As String
    aStr = Split(str, "|")
    find = aStr(0)
    repl = aStr(1)
        
    Dim repStr As String
    repStr = str
    rng.find.ClearFormatting
    rng.find.Replacement.ClearFormatting
    With rng.find
        .text = find
        .Replacement.text = repl
        .Forward = True
        .Wrap = wdFindContinue
        .Format = False
        .MatchCase = True
        .MatchWholeWord = True
        .MatchByte = False
        .MatchWildcards = False
        .MatchSoundsLike = False
        .MatchAllWordForms = False
    End With
    rng.find.Execute Replace:=wdReplaceAll
End Sub

Public Sub CheckProductNames()
    Dim m As Integer
    Dim s As Integer
    Dim match
    Dim submatch As String
    Dim T As Integer
    Dim fi As String
    Dim rep As String
    Dim i As Integer
    Dim rng As Range
    
    Dim W As Long
    Dim guard As String
    Dim str As String
    
    Dim re As Object
    Dim matches As Object
    Dim fiMatches As Object
    Dim repMatches As Object
    Dim IsMatch As Boolean
    Dim iwordsCI As Integer
    Dim iwords As Integer
    Dim wordFound As String
    Dim symbolFound As String
    
    Dim fiFound As String
    Dim fiSymbolFound As String
    Dim repFound As String
    Dim repSymbolFound As String
    Dim repl As String
    Dim words As Scripting.Dictionary
    Dim wordsCI As Scripting.Dictionary
    Dim wordAT As Scripting.Dictionary
    Dim guardAT As Scripting.Dictionary
    Dim symbolAT As Scripting.Dictionary
    Dim replWith As Scripting.Dictionary
    Dim AllCaps As Boolean
    
    
    Dim c As Collection
    Dim fixes As Boolean
    Dim loops As Integer
    fixes = True
    loops = 0
    'Debug.Print Now
    AllCaps = ThisDoc.Styles(WdBuiltinStyle.wdStyleHeading1).Font.AllCaps
    If AllCaps Then ThisDoc.Styles(WdBuiltinStyle.wdStyleHeading1).Font.AllCaps = False
    
CheckTerms:
    Do While fixes And loops <= 3
        
        Set words = New Scripting.Dictionary
        Set wordsCI = New Scripting.Dictionary
        Set wordAT = New Scripting.Dictionary
        Set guardAT = New Scripting.Dictionary
        Set symbolAT = New Scripting.Dictionary
        Set replWith = New Scripting.Dictionary
        wordsCI.CompareMode = vbTextCompare ' Text Compare
        
        fixes = False
        loops = loops + 1
        str = Replace(Replace(Replace(Replace(Replace(GetDocumentRange.text, vbCr, " x "), vbLf, " x "), vbTab, " x "), vbCrLf, " x "), Chr(7), " x ")
        
        Set re = CreateObject("vbscript.regexp")
        With re
            .IgnoreCase = True
            .Global = True
            .Pattern = "([\w-]+)([|fffd|||fffd|]?)" '"([^ ,.()'""!?;|fffd||fffd|]+)([|fffd|||fffd|]?)" ' "([^ |fffd||fffd|]+)([|fffd|||fffd|]?)" ' "([^\r\n \t|fffd||fffd|]+)([|fffd|||fffd|]?)" '"(\b[^\s]+\b)([|fffd|||fffd|]?)"
            If .Test(str) Then
                Set matches = .Execute(str)
                For m = 0 To matches.Count - 1
                    Set match = matches(m)
                    wordFound = match.SubMatches(0)
                    symbolFound = match.SubMatches(1)
                    If Not words.Exists(wordFound) Then
                        Set c = New Collection
                        c.Add m
                        words.Add wordFound, c
                    Else
                        words(wordFound).Add m
                    End If
                    If Not wordsCI.Exists(wordFound) Then
                        Set c = New Collection
                        c.Add m
                        wordsCI.Add wordFound, c
                    Else
                        wordsCI(wordFound).Add m
                    End If
                    wordAT.Add m, wordFound
                    symbolAT.Add m, symbolFound
                    'Debug.Print match, submatch, match.FirstIndex
                Next
                
                For T = UBound(aTerms, 1) To 0 Step -1
                    fi = aTerms(T, 0)
                    rep = aTerms(T, 1)
                    If .Test(fi) And .Test(rep) Then
                        'If t = 15 Then Stop
                        Set fiMatches = .Execute(fi)
                        Set match = fiMatches(0)
                        fiFound = match.SubMatches(0)
                        fiSymbolFound = match.SubMatches(1)
                        Set repMatches = .Execute(rep)
                        Set match = repMatches(0)
                        repFound = match.SubMatches(0)
                        repSymbolFound = match.SubMatches(1)
                        
                        If wordsCI.Exists(fiFound) Then
                            For iwordsCI = 1 To wordsCI(fiFound).Count
                                IsMatch = True
                                W = wordsCI(fiFound).Item(iwordsCI)
                                If fiSymbolFound > "" And symbolAT(W) <> fiSymbolFound Then IsMatch = False
                                For m = 1 To fiMatches.Count - 1
                                    If LCase(wordAT(W + m)) <> LCase(fiMatches(m).SubMatches(0)) Then IsMatch = False
                                    If fiMatches(m).SubMatches(1) > "" And symbolAT(W + m) <> fiMatches(m).SubMatches(1) Then IsMatch = False
                                Next
                                If IsMatch Then
                                    'Debug.Print "Found at "; w, fi, fiFound, fiSymbolFound
                                    ' Check if already formatted correct
                                    W = wordsCI(fiFound).Item(iwordsCI)
                                    If wordAT(W) <> repFound Then IsMatch = False
                                    If repSymbolFound > "" And symbolAT(W) <> repSymbolFound Then IsMatch = False
                                    repl = wordAT(W) & IIf(repSymbolFound > "", symbolAT(W), "")
                                    For m = 1 To repMatches.Count - 1
                                        If wordAT(W + m) <> repMatches(m).SubMatches(0) Then IsMatch = False
                                        If repMatches(m).SubMatches(1) > "" And symbolAT(W + m) <> repMatches(m).SubMatches(1) Then IsMatch = False
                                        repl = repl & " " & wordAT(W + m) & IIf(repMatches(m).SubMatches(1) > "", symbolAT(W + m), "")
                                    Next
                                    For m = 0 To repMatches.Count - 1
                                        guard = CStr(W + m)
                                        If Not guardAT.Exists(guard) Then
                                            guardAT.Add guard, True
                                        Else
                                            IsMatch = True
                                        End If
                                    Next
                                    If Not IsMatch Then
                                        'Debug.Print "Replace '" & repl & "' at " & w & " with '" & rep & "'"
                                        If Not replWith.Exists(repl & "|" & rep) Then
                                            replWith.Add repl & "|" & rep, True
                                        End If
                                    Else
                                        'Debug.Print "Keep '" & repl & "' at " & w & " since it matches '" & rep & "'"
                                    End If
                                End If
                            Next
                        Else
                            'Debug.Print "Not Found", fiFound, fiSymbolFound
                        End If
                    End If
    '                Debug.Print fi, rep
                Next
                Dim strR As Variant
                For Each strR In replWith
                    fixes = True
                    'Debug.Print strR
                    ReplaceWith GetDocumentRange, CStr(strR)
                Next
            End If
        End With
        'Debug.Print
    Loop
    
    str = Replace(Replace(Replace(Replace(Replace(GetDocumentRange.text, vbCr, " x "), vbLf, " x "), vbTab, " x "), vbCrLf, " x "), Chr(7), " x ")
    If InStr(str, "|fffd||fffd|") > 0 Then
        Set rng = GetDocumentRange
        rng.find.Font.reset
        With rng.find
            .text = "|fffd||fffd|"
            .Replacement.text = "|fffd|"
            .Wrap = wdFindContinue
            .Format = True
            .MatchCase = False
            .MatchWholeWord = False
            .MatchWildcards = False
            .MatchSoundsLike = False
            .MatchAllWordForms = False
        End With
        rng.find.Execute Replace:=wdReplaceAll
    End If
    
    str = Replace(Replace(Replace(Replace(Replace(GetDocumentRange.text, vbCr, " x "), vbLf, " x "), vbTab, " x "), vbCrLf, " x "), Chr(7), " x ")
    If InStr(str, "|fffd||fffd|") > 0 Then
        Set rng = GetDocumentRange
        rng.find.Font.reset
        With rng.find
            .text = "|fffd||fffd|"
            .Replacement.text = "|fffd|"
            .Wrap = wdFindContinue
            .Format = True
            .MatchCase = False
            .MatchWholeWord = False
            .MatchWildcards = False
            .MatchSoundsLike = False
            .MatchAllWordForms = False
        End With
        rng.find.Execute Replace:=wdReplaceAll
    End If
    
    
    str = Replace(Replace(Replace(Replace(Replace(GetDocumentRange.text, vbCr, " x "), vbLf, " x "), vbTab, " x "), vbCrLf, " x "), Chr(7), " x ")
    If InStr(str, "|fffd|") > 0 Then
        Set rng = GetDocumentRange
        rng.find.Font.Superscript = False
        rng.find.Replacement.Font.Superscript = True
        With rng.find
            .text = "|fffd|"
            .Replacement.text = "|fffd|"
            .Wrap = wdFindContinue
            .Format = True
            .MatchCase = False
            .MatchWholeWord = False
            .MatchWildcards = False
            .MatchSoundsLike = False
            .MatchAllWordForms = False
        End With
        rng.find.Execute Replace:=wdReplaceAll
    End If
        
    Set rng = GetDocumentRange
    rng.find.ClearFormatting
    rng.find.Replacement.ClearFormatting
    Set rng = GetDocumentRange
    With rng.find
        .text = ""
        .Replacement.text = ""
        .Forward = True
        .Wrap = wdFindContinue
        .Format = False
        .MatchCase = False
        .MatchWholeWord = False
        .MatchWildcards = False
        .MatchSoundsLike = False
        .MatchAllWordForms = False
    End With
    
    If AllCaps Then ThisDoc.Styles(WdBuiltinStyle.wdStyleHeading1).Font.AllCaps = True
End Sub

Public Sub FixBookmarks()
    Dim rng As Range
    Dim book As Bookmark
    Dim fld As field
    Dim str As String
    
    Dim books As New Scripting.Dictionary
    Dim refs As New Scripting.Dictionary
    Dim failrefs As New Scripting.Dictionary
    
    books.CompareMode = TextCompare
    refs.CompareMode = TextCompare
    failrefs.CompareMode = TextCompare
    
    Set rng = ThisDoc.Range
    rng.Bookmarks.ShowHidden = True
    
    For Each book In rng.Bookmarks
        books.Add book.Name, book
    Next
    rng.Bookmarks.ShowHidden = False
    
    Set rng = ThisDoc.Range
    
    Dim RegExpObj As Object
    Dim matches As Object
    Set RegExpObj = CreateObject("vbscript.regexp")
    With RegExpObj
        .IgnoreCase = True
        .Pattern = "(_(?:REF|TOC|HLT|PAGEREF)\d*)"
        For Each fld In rng.fields
            str = fld.code.text
            If .Test(fld.code.text) Then
                Set matches = .Execute(fld.code.text)
                'Debug.Print str, matches(0)
                str = CStr(matches(0))
                If books.Exists(str) Then
                    books.Remove str
                    If Not refs.Exists(str) Then
                        refs.Add str, fld
                    End If
                Else
                    If Not refs.Exists(str) Then
                        If Not failrefs.Exists(str) Then
                            failrefs.Add str, fld
                        End If
                    End If
                End If
            End If
        Next
    End With
    With RegExpObj
        .IgnoreCase = True
        .Pattern = "REF [^\\]*(.*)"
        For Each fld In rng.fields
            If fld.Type = wdFieldRef Then
                str = fld.code.text
                If .Test(fld.code.text) Then
                    Set matches = .Execute(fld.code.text)
                    'Debug.Print str, matches(0)
                    str = CStr(matches(0).SubMatches(0))
                    If Not LCase(str) Like "*\h*" Then
                        fld.code.text = Trim(Replace(fld.code.text & " \h ", "  ", " "))
                        fld.Update
                    End If
                End If
            End If
        Next
    End With
    Dim v As Variant 'Delete unused hidden bookmarks
    For Each v In books
        If Left(v, 1) = "_" Then
            ThisDoc.Bookmarks(v).Delete
        End If
    Next
End Sub

Public Function RemoveR0Fields() As Boolean
On Error GoTo Failed
    Dim ok As Boolean
    Dim fld As field
    Dim fldPrev As field
    Dim seq As String
    
    seq = "zzzzzzzzz"
    For Each fld In GetDocumentRange.fields
        If LCase(fld.code.text) Like "*seq *\r0*" Then
            Set fldPrev = fld
            seq = Mid(Trim(Split(Trim(fld.code.text), "\r0 \h", , vbTextCompare)(0)), 5)
            'Debug.Print fld.code.Text, seq
        ElseIf LCase(fld.code.text) Like LCase("*seq " & seq & "*") And Not LCase(fld.code.text) Like LCase("*\r*") Then
            fld.Select
            'Debug.Print fld.code.Text, seq
            fld.code.text = Replace(fld.code.text, seq, seq & " \r1", , , vbTextCompare)
            fldPrev.Delete
            fld.Update
            seq = "zzzzzzzzz"
        Else
            Set fldPrev = Nothing
            seq = "zzzzzzzzz"
        End If
    Next
    
    ok = True
ExitIt:
    On Error GoTo 0
    RemoveR0Fields = ok
    Exit Function
   
Failed:
    Select Case Err.Number
    Case Else
        Debug.Print "Case " & Err.Number & " '" & Err.Description
        Stop
        Resume Next
        ok = False
        Resume ExitIt
    End Select
End Function


Public Sub CheckParagraphs()  ' SLOW. Rewrite
    
    FoundHeadingOrParmheadOrHeadingPart = False
    FoundCaptionRes = False
    Dim breakBefore As Boolean
    Dim sty As Style
    Dim para As Paragraph
    ThisDoc.Bookmarks.ShowHidden = True
    
    For Each para In GetDocumentRange.Paragraphs
        If Not para.Range.Style Is Nothing Then
            If para.Range.Style >= ThisDoc.Styles(wdStyleHeading1) And para.Range.Style <= ThisDoc.Styles(wdStyleHeading9) Then
                'para.Reset
                If method = "Convert" Then breakBefore = para.Range.ParagraphFormat.PageBreakBefore
                para.Range.Style = para.Range.Style
'                para.Range.ParagraphFormat.Reset
'                para.Range.Font.Reset
                If method = "Convert" Then para.Range.ParagraphFormat.PageBreakBefore = breakBefore
            End If
            If para.Range.Style >= ThisDoc.Styles(wdStyleHeading1) And para.Range.Style <= ThisDoc.Styles(wdStyleHeading8) Then
'                para.Range.ParagraphFormat.TabStops.ClearAll
'                para.Range.ParagraphFormat.TabStops.Add Position:=64.05, Alignment:=wdAlignTabLeft, Leader:=wdTabLeaderSpaces
                FoundHeadingOrParmheadOrHeadingPart = True
            End If
            If para.Range.Style = "wpsDumps" Then
                ConvertWPSDumpFontLine para
            End If
            
            If para.Range.Style = "CaptionRes" And para.Range.fields.Count > 0 Then
                Dim rng As Range
                Set rng = para.Range
                Dim IsSeq As Boolean
                Dim IsRef As Boolean
                Dim strField As String
                Dim strResult
                strField = para.Range.fields(1).code
                strResult = para.Range.fields(1).result
                IsSeq = (LCase(strField) Like "*seq*")
                IsRef = (LCase(strField) Like "*ref*" And Not LCase(strField) Like "*\r*")
                Dim bk As Bookmark
                Dim aBKName() As String
                Dim bkName As String
                Set bk = Nothing
                Dim iBK As Integer
                If rng.Bookmarks.Count > 0 Then
                    ReDim aBKName(1 To rng.Bookmarks.Count)
                    For iBK = UBound(aBKName) To 1 Step -1
                        Set bk = rng.Bookmarks(iBK)
                        aBKName(iBK) = bk.Name
                        bk.Delete
                    Next
                Else
                    Erase aBKName
                End If
                If IsSeq Then
                    FoundCaptionRes = True
                    rng.End = rng.End - 1
                    Do While rng.ShapeRange.Count > 0
                        rng.start = rng.start + 1
                    Loop
                    If InStr(rng.text, vbTab) > 0 Then
                        rng.text = Split(rng.text, vbTab, 2)(1)
                    Else
                        rng.text = Trim(Split(rng.text, strResult, 2)(1))
                    End If
                    If (Not aBKName) = -1 Then
                    Else
                        For iBK = 1 To UBound(aBKName)
                            Set bk = ThisDoc.Bookmarks.Add(aBKName(iBK), rng)
                        Next
                    End If
                    para.Range.Style = wdStyleHeading1
                    para.Range.ParagraphFormat.TabStops.ClearAll
                    para.Range.ParagraphFormat.TabStops.Add Position:=64.05, Alignment:=wdAlignTabLeft, Leader:=wdTabLeaderSpaces
                ElseIf IsRef Then
                    Dim fieldNo As field
                    Set rng = para.Range
                    Do While rng.ShapeRange.Count > 0
                        rng.start = rng.start + 1
                    Loop
                    rng.End = rng.start
                    rng.text = vbTab
                    rng.End = rng.start
                    Set fieldNo = rng.fields.Add(rng, wdFieldEmpty, Trim(strField) & " \r")
                    
                    If (Not aBKName) = -1 Then
                    Else
                        For iBK = 1 To UBound(aBKName)
                            Set bk = ThisDoc.Bookmarks.Add(aBKName(iBK), rng)
                        Next
                    End If
                End If
            End If
            If para.Range.Style = "ParmHead" Or para.Range.Style = "HeadingPart" Then
                FoundHeadingOrParmheadOrHeadingPart = True
            End If
        End If
    Next
End Sub

'--------------------------------------------------------------------------------------
' Update
'--------------------------------------------------------------------------------------

Public Sub UpdatePrepare()
    Dim rngInsert As Range
    Application.ScreenUpdating = ScreenUpdating
    
    WriteLog "Reading document information"
    If ActiveWindow.View.SplitSpecial <> wdPaneNone Then
        ActiveWindow.Panes(2).Close
    End If

    ActiveWindow.ActivePane.View.SeekView = wdSeekMainDocument

    Set rngReturnTo = Selection.Range
    
    Selection.Range.MoveEnd wdStory
    
    LockMainContentControls False
    If rngReturnTo.start + 1 >= ThisDoc.Range.End Then
        gotoEnd = True
    End If
    
    SetLanguage
    GetMainDocInfo
    
    If Len(ThisDoc.BuiltInDocumentProperties("Comments").value) > 200 Then
        If Left(ThisDoc.BuiltInDocumentProperties("Comments").value, 20) Like "*|||Languages*" And Not ThisDoc.Name Like "BGdoc.dotm" Then
            ThisDoc.BuiltInDocumentProperties("Comments").value = ""
        End If
    End If
    
'    Set rngInsert = ThisDoc.Range(0, 0)
'    rngInsert.Collapse wdCollapseStart
'    rngInsert.Select
    
    If ThisDoc.Range.End > 0 Then
        ThisDoc.Range(ThisDoc.Range.End - 1, ThisDoc.Range.End).Select
        Selection.Range.Collapse wdCollapseEnd
        Selection.Range.start = Selection.Range.End
    End If
   
    If showFrontMatter = "Translation" Then
        WriteLog "Reading translated information"
        If DoReadTranslation Then GetTranslation
        If Not ccFrontMatter Is Nothing Then
            ccFrontMatter.Delete True
            Set ccFrontMatter = Nothing
            ThisDoc.Range.Paragraphs(1).Range.Delete
        End If
        ResetContentControls
    End If

    SetPageHeight
    
End Sub

Public Sub UpdateDocumentRangeFields()
    Dim flds As fields
    Dim fld As field
    Dim fldPrev As field
    Set flds = GetDocumentRange.fields
    Dim fldCount As Integer
    fldCount = flds.Count
    
'    Set fld = flds(fldCount)
'    Do While Not fld Is Nothing
'        Set fldPrev = fld.Previous
'        fld.Update
'        Set fld = fldPrev
'    Loop
    
    Dim i As Integer
    For i = fldCount To 1 Step -1
        Set fld = flds(i)
        'Debug.Print fld.code.text
        fld.Update
    Next
End Sub

Public Sub UpdateDocumentRangeFieldsPageRef()
    Dim flds As fields
    Dim fld As field
    Dim fldPrev As field
    Set flds = GetDocumentRange.fields
    Dim fldCount As Integer
    fldCount = flds.Count
    If Not fldCount = 0 Then
        Set fld = flds(fldCount)
        Do While Not fld Is Nothing
            Set fldPrev = fld.Previous
            If fld.Type = wdFieldPageRef Then fld.Update
            Set fld = fldPrev
        Loop
    End If
End Sub


Private Function UpdateStylesAndParagraphs()
    WriteLog "Updating heading styles"
    
    If HasChanged("HeadingLayout") Or method = "Convert" Then
        HeadingLayout = ReadText("/DocumentInfo/DocumentInfo-HeadingLayout")
        
        Select Case HeadingLayout
        Case "Spare Parts Catalogue"
            'ThisDoc.Styles(wdStyleHeading1).ParagraphFormat.SpaceBefore = 3
            ThisDoc.Styles(wdStyleHeading1).Font.Position = -3
            ThisDoc.Styles(wdStyleHeading1).ParagraphFormat.SpaceBefore = 0
            
            ThisDoc.Styles(wdStyleHeading1).Font.AllCaps = False
            ThisDoc.Styles(wdStyleHeading1).ParagraphFormat.PageBreakBefore = True
            SetHeadingListTemplateColor wdColorBlack
            
            ThisDoc.Styles("TOC1cp ").ParagraphFormat.SpaceBefore = 3
            ThisDoc.Styles("TOC1cp ").Font.AllCaps = False
        Case "No Numbering, No Page Break"
            'ThisDoc.Styles(wdStyleHeading1).ParagraphFormat.SpaceBefore = 18
            ThisDoc.Styles(wdStyleHeading1).Font.Position = -18
            ThisDoc.Styles(wdStyleHeading1).ParagraphFormat.SpaceBefore = 0
            
            ThisDoc.Styles(wdStyleHeading1).Font.AllCaps = False
            ThisDoc.Styles(wdStyleHeading1).ParagraphFormat.PageBreakBefore = False
            SetHeadingListTemplateColor wdColorWhite
            
            ThisDoc.Styles("TOC1cp ").ParagraphFormat.SpaceBefore = 18
            ThisDoc.Styles("TOC1cp ").Font.AllCaps = False
        Case "No Page Break"
            'ThisDoc.Styles(wdStyleHeading1).ParagraphFormat.SpaceBefore = 18
            ThisDoc.Styles(wdStyleHeading1).Font.Position = -18
            ThisDoc.Styles(wdStyleHeading1).ParagraphFormat.SpaceBefore = 0
            
            ThisDoc.Styles(wdStyleHeading1).Font.AllCaps = False
            ThisDoc.Styles(wdStyleHeading1).ParagraphFormat.PageBreakBefore = False
            SetHeadingListTemplateColor wdColorBlack
            
            ThisDoc.Styles("TOC1cp ").ParagraphFormat.SpaceBefore = 18
            ThisDoc.Styles("TOC1cp ").Font.AllCaps = False
        Case Else
            'ThisDoc.Styles(wdStyleHeading1).ParagraphFormat.SpaceBefore = 24
            ThisDoc.Styles(wdStyleHeading1).Font.Position = -24
            ThisDoc.Styles(wdStyleHeading1).ParagraphFormat.SpaceBefore = 0
            
            
            ThisDoc.Styles(wdStyleHeading1).Font.AllCaps = True
            ThisDoc.Styles(wdStyleHeading1).ParagraphFormat.PageBreakBefore = True
            SetHeadingListTemplateColor wdColorBlack
            
            ThisDoc.Styles("TOC1cp ").ParagraphFormat.SpaceBefore = 12
            ThisDoc.Styles("TOC1cp ").Font.AllCaps = True
        End Select
        
        CheckParagraphs
    End If
    
    If HasChanged("Language") Then
        ' Update language in document
        ThisDoc.Styles(wdStyleNormal).LanguageId = Language
        If Language = "2052" Then 'Chinese
            ThisDoc.Styles(wdStyleNormal).Font.Name = "Microsoft YaHei"
            With ThisDoc.Styles("Table Text").ParagraphFormat
                .LineSpacingRule = wdLineSpaceSingle
                .SpaceBefore = 3
                .SpaceAfter = 3
                '.SpaceAfterAuto = False
                '.SpaceBeforeAuto = False
            End With
        ElseIf Language = "1042" Then 'Korean
            ThisDoc.Styles(wdStyleNormal).Font.Name = "Malgun Gothic"
            With ThisDoc.Styles("Table Text").ParagraphFormat
                .LineSpacingRule = wdLineSpaceExactly
                .LineSpacing = 11
                .SpaceBefore = 2
                .SpaceAfter = 2
                '.SpaceAfterAuto = False
                '.SpaceBeforeAuto = False
            End With
        Else
            ThisDoc.Styles(wdStyleNormal).Font.Name = "Arial"
            With ThisDoc.Styles("Table Text").ParagraphFormat
                .LineSpacingRule = wdLineSpaceSingle
                .SpaceBefore = 3
                .SpaceAfter = 3
                '.SpaceAfterAuto = False
                '.SpaceBeforeAuto = False
            End With
        End If
    
        Dim storyRng As Range
        For Each storyRng In ThisDoc.StoryRanges
            storyRng.LanguageId = Language
        Next
        ThisDoc.Range.LanguageId = Language
    End If
    
End Function

Private Sub SetPageHeight()
    Dim rngInsert As Range
    ' Temporary placement
    Set rngInsert = ThisDoc.Range(0, 0)
    rngInsert.Collapse wdCollapseStart
    rngInsert.Select
    pageHeight = rngInsert.PageSetup.pageHeight
    If pageHeight = 0 Then
        On Error Resume Next
        pageHeight = rngInsert.PageSetup.pageHeight
        On Error Resume Next
        If pageHeight = 0 Then
            On Error Resume Next
            pageHeight = ThisDoc.Sections(1).PageSetup.pageHeight
            On Error Resume Next
        End If
    End If
End Sub

Public Sub UpdateLayout()
    Dim rngInsert As Range
    SetPageHeight
    If NewPaperFormat > "" Then
        WriteLog "Change paper format"
        ChangePaperFormat
        SetPageHeight
    End If
    
    Set rngInsert = ThisDoc.Range(0, 0)
    
    WriteLog "Updating header/footer"
    SetHeaderFooter
    
    WriteLog "Updating styles"
    UpdateStylesAndParagraphs
    
    WriteLog "Updating captions"
    RemoveR0Fields
    FixOldCaptions
    SetCaptions "Figure"
    SetCaptions "Table"
   
    WriteLog "Updating fields"
    UpdateDocumentRangeFields
    
    WriteLog "Updating bookmarks"
    FixBookmarks

    If ReplaceRegistered Then
        WriteLog "Check product names"
        CheckProductNames
    End If

    
    WriteLog "Updating front matter"
    Select Case showFrontMatter
    Case "Translation", ""
        If ThisDoc.Tables.Count > 0 Then
            If ThisDoc.Tables(1).Range.start = 0 Then
                Selection.HomeKey Unit:=wdStory
                Selection.SplitTable
                Selection.Style = ThisDoc.Styles("Paragraph1")
                Selection.Range.Collapse wdCollapseEnd
                Selection.Range.start = Selection.Range.End
                Set rngInsert = ThisDoc.Range(0, 0)
                rngInsert.Collapse wdCollapseStart
            End If
        End If
        If ccFrontMatter Is Nothing Then
            Set bkRng = ThisDoc.Range
            bkRng.Bookmarks.ShowHidden = True
            
            For iBK = ThisDoc.Bookmarks.Count To 1 Step -1
                Set bk = ThisDoc.Bookmarks(iBK)
                Set bkRng = bk.Range
                If ThisDoc.Bookmarks(iBK).start = 0 Then
                    'Debug.Print "Before", bk.name, bkRng.start, bkRng.End, bkRng.text; "!"
                End If
            Next
            
            rngInsert.Paragraphs.Add
            rngInsert.Style = wdStyleNormal
            Set ccFrontMatter = rngInsert.ContentControls.Add(wdContentControlRichText, rngInsert)
            ccFrontMatter.tag = "DocumentInfo-FrontMatter:DocumentInformation"
            RebuildFrontMatter = True
            ccFrontMatter.Range.Delete
            
            If Not ccFrontMatter Is Nothing Then
                Set rngStart = ccFrontMatter.Range
                moveBooks = rngStart.End + 2
                'Debug.Print "FrontMatter", rngStart.start, rngStart.End, rngStart.End - rngStart.start, rngStart.text; "!"
                
                For iBK = ThisDoc.Bookmarks.Count To 1 Step -1
                    If ThisDoc.Bookmarks(iBK).start = 0 Then
                        Set bk = ThisDoc.Bookmarks(iBK)
                        Set bkRng = bk.Range
                        'Debug.Print ">>", bk.name, bkRng.start, bkRng.End, bkRng.text; "!"
                        'bkRng.End = bkRng.End + moveBooks
                        bkRng.start = moveBooks
                        bkRng.Bookmarks.Add bk.Name
                        'Debug.Print "After", bk.name, bk.Range.start, bk.Range.End, rngStart.End - rngStart.start, bk.Range.text; "!", vbCrLf
                    End If
                Next
            End If
            Set bkRng = ThisDoc.Range
            bkRng.Bookmarks.ShowHidden = False
            
        ElseIf RebuildFrontMatter Then
            ccFrontMatter.Range.Delete
            ThisDoc.Range.Paragraphs(1).Range.Delete
            ResetContentControls
        End If
        Set rngInsert = ccFrontMatter.Range
        rngInsert.Collapse wdCollapseEnd

        If RebuildFrontMatter Then
            If showFrontMatter = "" Then
                If ShowFrontPage > "" Then
                    SpecialFirstHeaderFooter
                    CompanyLogoUpdated = True
                    ThisDoc.PageSetup.DifferentFirstPageHeaderFooter = True
                    Set rngInsert = ThisDoc.attachedTemplate.BuildingBlockEntries("zzFrontPage").Insert(Where:=rngInsert, RichText:=True)
                    
                    Set ccFrontPage = rngInsert.ContentControls(1)
                    ccFrontPage.Range.Paragraphs(1).Range.Font.reset
                    ccFrontPage.Range.Paragraphs(1).Format.PageBreakBefore = False
                Else
                    ThisDoc.PageSetup.DifferentFirstPageHeaderFooter = False
                End If
                Set rngInsert = ccFrontMatter.Range
                rngInsert.Collapse wdCollapseEnd
                If ShowDocumentInformation > "" Then
                    If ccDocumentInformation Is Nothing Or (ShowSupplierFileName > "" And ccSupplierFileName Is Nothing) Then
                        If Not ccDocumentInformation Is Nothing Then
                            ccDocumentInformation.Delete True
                        End If
                        Set rngInsert = ThisDoc.attachedTemplate.BuildingBlockEntries("zzDocumentInformation").Insert(Where:=rngInsert, RichText:=True)
                        Set ccDocumentInformation = rngInsert.ContentControls(1)
                        Set ccFileName = GetFirstContentControlByTag("DocumentInfo-FileName:DocumentInformation")
                        Set ccSupplierFileName = GetFirstContentControlByTag("DocumentInfo-SupplierFileName:DocumentInformation")
                        Set ccSupplierFileNameLabel = GetFirstContentControlByTag("DocumentLabel-SupplierFileName:DocumentInformation")
                        Set ccCopyright = GetFirstContentControlByTag("DocumentInfo-Copyright:DocumentInformation")
                        Set ccDisclaimer = GetFirstContentControlByTag("DocumentInfo-Disclaimer:DocumentInformation")
                    End If
                    If ShowSupplierFileName = "" And Not ccSupplierFileName Is Nothing Then
                        ccSupplierFileName.Range.Paragraphs(1).Range.Delete
                        Set ccSupplierFileName = Nothing
                    End If
                    If ShowSupplierFileName = "" And Not ccSupplierFileNameLabel Is Nothing Then
                        ccSupplierFileNameLabel.Range.Paragraphs(1).Range.Delete
                        Set ccSupplierFileNameLabel = Nothing
                    End If
                    ccDocumentInformation.Range.Paragraphs(1).Range.Font.reset
                End If
                Set rngInsert = ccFrontMatter.Range
                rngInsert.Collapse wdCollapseEnd
                If ShowRevisions > "" Then
                    Set rngInsert = ThisDoc.attachedTemplate.BuildingBlockEntries("zzRevisions").Insert(Where:=rngInsert, RichText:=True)
                    Set ccRevisions = GetFirstContentControlByTag("DocumentInfo-Revisions:DocumentInformation")
                End If
                Set rngInsert = ccFrontMatter.Range
                rngInsert.Collapse wdCollapseEnd
                If ShowTOC > "" Then
                    If ccTOC Is Nothing Then
                        Set rngInsert = ThisDoc.attachedTemplate.BuildingBlockEntries("zzTOC").Insert(Where:=rngInsert, RichText:=True)
                        Set ccTOC = rngInsert.ContentControls(1)
                    Else
                        Set rngInsert = ccTOC.Range.Duplicate
                        rngInsert.Collapse wdCollapseEnd
                    End If
                End If
                Set rngInsert = ccFrontMatter.Range
                rngInsert.Collapse wdCollapseEnd
                If ShowTOF > "" Then
                    If ccTOF Is Nothing Then
                        Set rngInsert = ThisDoc.attachedTemplate.BuildingBlockEntries("zzTOF").Insert(Where:=rngInsert, RichText:=True)
                        Set ccTOF = rngInsert.ContentControls(1)
                    Else
                        Set rngInsert = ccTOF.Range.Duplicate
                        rngInsert.Collapse wdCollapseEnd
                    End If
                    ccTOF.Range.Paragraphs(1).Range.Font.reset
                End If
                Set rngInsert = ccFrontMatter.Range
                rngInsert.Collapse wdCollapseEnd
                If ShowTOT > "" Then
                    If ccTOT Is Nothing Then
                        Set rngInsert = ThisDoc.attachedTemplate.BuildingBlockEntries("zzTOT").Insert(Where:=rngInsert, RichText:=True)
                        Set ccTOT = rngInsert.ContentControls(1)
                    Else
                        Set rngInsert = ccTOT.Range.Duplicate
                        rngInsert.Collapse wdCollapseEnd
                    End If
                    ccTOT.Range.Paragraphs(1).Range.Font.reset
                End If
                Set rngInsert = ccFrontMatter.Range
                rngInsert.Collapse wdCollapseEnd
                rngInsert.MoveStart wdCharacter, -1
                rngInsert.Delete
            End If
        End If
        If showFrontMatter = "Translation" Then
            If ccTranslation Is Nothing Then
                Set rngInsert = ccFrontMatter.Range
                Set rngInsert = ThisDoc.attachedTemplate.BuildingBlockEntries("zzTranslation").Insert(Where:=rngInsert, RichText:=True)
                Set ccTranslation = rngInsert.ContentControls(1)
                Set rngInsert = ccFrontMatter.Range
                rngInsert.Collapse wdCollapseEnd
                If ShowRevisions > "" Then
                    Set rngInsert = ThisDoc.attachedTemplate.BuildingBlockEntries("zzRevisions").Insert(Where:=rngInsert, RichText:=True)
                    Set ccRevisions = GetFirstContentControlByTag("DocumentInfo-Revisions:DocumentInformation")
                    FillRevisionHistory ccRevisions
                    Set rngInsert = ccFrontMatter.Range
                    rngInsert.Collapse wdCollapseEnd
                End If
                
                rngInsert.MoveStart wdCharacter, -1
                rngInsert.Delete
            End If
        End If
    Case "Hide"
        If Not ccFrontMatter Is Nothing Then
           ccFrontMatter.Delete True
           Set ccFrontMatter = Nothing
           ThisDoc.Range.Paragraphs(1).Range.Delete
           ResetContentControls
        ElseIf Not ccTranslation Is Nothing Then
           ccTranslation.Delete True
           Set ccTranslation = Nothing
           ThisDoc.Range.Paragraphs(1).Range.Delete
           ResetContentControls
        End If
        If Not ThisDoc.PageSetup.DifferentFirstPageHeaderFooter = False Then ThisDoc.PageSetup.DifferentFirstPageHeaderFooter = False
        
    End Select

End Sub

Private Sub UpdateContentInStory(stry As Range)
    Set rng = stry
    
    Dim strStatus As String
    If TryReadText("/DocumentInfo/DocumentInfo-ClassificationLabel", value) Then
        strStatus = value
    End If
    If strStatus = " " Then strStatus = ""
    If TryReadText("/DocumentInfo/DocumentInfo-WorkflowLabel", value) Then
        If strStatus > "" And value > "" Then
            strStatus = strStatus & " " & ChrW(8226) & " " & value
        ElseIf value > "" Then
            strStatus = value
        End If
    End If
    If strStatus = "" Then strStatus = " "
    
    If (stry.StoryType = wdFirstPageHeaderStory Or stry.StoryType = wdPrimaryHeaderStory) Then
        If rng.ShapeRange.Count > 0 Then
            Dim ishp As Integer
            Dim shp As Shape
            Dim shpCount As Integer
            shpCount = rng.ShapeRange.Count
            For ishp = shpCount To 1 Step -1
'                WriteLog CStr(ishp)
                If rng.ShapeRange(ishp).Type = msoTextBox Then
                    Set shp = rng.ShapeRange(ishp)
                    Set cc = shp.TextFrame.TextRange.ContentControls(1)
                    cc.LockContents = False
'                    With shp.TextFrame
'                        If Not .MarginBottom = 0 Then .MarginBottom = 0
'                        If Not .MarginLeft = 0 Then .MarginLeft = 0
'                        If Not .MarginRight = 0 Then .MarginRight = 0
'                        If Not .MarginTop = 0 Then .MarginRight = 0
'                    End With
                    
                    Dim ccIsAtTop As Boolean
                    ccIsAtTop = (shp.TextFrame.Orientation = msoTextOrientationHorizontal)
                    
                    If (ccIsAtTop And pageHeight < 700) Then
                        If Not shp.Top = 34 Then shp.Top = 34
                    ElseIf (ccIsAtTop And pageHeight >= 700) Then
                        If Not shp.Top = -34 Then shp.Top = -34
                    End If

                    If (ccIsAtTop And pageHeight < 700) Then
                        If Not cc.Range.text = strStatus Then cc.Range.text = strStatus
                    ElseIf (ccIsAtTop And pageHeight >= 700) Then
                        If Not cc.Range.text = " " Then cc.Range.text = " "
                    ElseIf (Not ccIsAtTop And pageHeight >= 700) Then
                        If Not cc.Range.text = strStatus Then cc.Range.text = strStatus
                    Else
                        If Not cc.Range.text = " " Then cc.Range.text = " "
                    End If


'                    If Not cc.Range.Style = "Table Header Center" Then
'                        cc.Range.Style = "Table Header Center"
'                        cc.Range.Font.TextColor = RGB(0, 157, 224)
'                        cc.Range.Font.Size = 12
'                        cc.Range.Font.Bold = True
'                    End If
'
'                    If ThisDoc.Styles(wdStyleNormal).Font.name = "Arial" Then
'                        If Not cc.Range.ParagraphFormat.SpaceBefore = 6 Then cc.Range.ParagraphFormat.SpaceBefore = 6
'                        If Not cc.Range.ParagraphFormat.SpaceAfter = 0 Then cc.Range.ParagraphFormat.SpaceAfter = 0
'                    Else
'                        If Not cc.Range.ParagraphFormat.SpaceBefore = 3 Then cc.Range.ParagraphFormat.SpaceBefore = 3
'                        If Not cc.Range.ParagraphFormat.SpaceAfter = 3 Then cc.Range.ParagraphFormat.SpaceAfter = 3
'                    End If
                    'cc.LockContents = True
                End If
            Next
        End If
    End If
    
    
    Dim strFormula As String
    Dim wasLocked As Boolean
    
    If stry.StoryType = wdMainTextStory And Not ccFrontMatter Is Nothing Then
        Set rng = GetDocumentRange
        Dim ccs As New Collection
        LockUnlockContentControlsInRange False, rng, ccs
        For Each cc In rng.ContentControls
            wasLocked = cc.LockContents
            If wasLocked Then cc.LockContents = False
            If cc.tag Like "Calculate:*" Then
                strFormula = cc.Title
                If ccTranslation Is Nothing Then
                    cc.Range.text = CalculateTitle(strFormula, , False)
                Else
                    cc.Range.text = "|||"
                End If
            End If
            If wasLocked Then cc.LockContents = True
        Next
        LockUnlockContentControlsInRange True, rng, ccs
        Set rng = ccFrontMatter.Range
    ElseIf stry.StoryType = wdMainTextStory And ccFrontMatter Is Nothing Then
        For Each cc In stry.ContentControls
            wasLocked = cc.LockContents
            If wasLocked Then cc.LockContents = False
            If cc.tag Like "Calculate:*" Then
                strFormula = cc.Title
                cc.Range.text = CalculateTitle(strFormula, , False)
            End If
            If wasLocked Then cc.LockContents = True
        Next
        rng.start = 0
        rng.End = 0
    End If

    Do
        For Each cc In rng.ContentControls
            aTag = Split(cc.tag, ":")
            path = "/" & Split(aTag(0), "-")(0) & "/" & aTag(0)
            ''Debug.Print cc.Tag, aTag(0), path
            If path = "/DocumentInfo/DocumentInfo-Revisions" Then
                If Not showFrontMatter = "Translation" Then
                    FillRevisionHistory cc
                End If
            ElseIf path = "/DocumentInfo/DocumentInfo-Logo" Then
                Dim changePicture As Boolean
                changePicture = False
                If cc.Range.ShapeRange.Count = 0 And cc.Range.InlineShapes.Count = 0 Then
                    changePicture = True
                End If
                If Not cc.Range.ShapeRange.Count = 0 Then
                    If cc.Range.ShapeRange(1).AlternativeText <> "BEUMER Group 1.0" Then
                        changePicture = True
                    End If
                End If
                If Not cc.Range.InlineShapes.Count = 0 Then
                    If cc.Range.InlineShapes(1).AlternativeText <> "BEUMER Group 1.0" Then
                        changePicture = True
                    End If
                End If
                If changePicture Then
                    cc.Range.text = ""
                    ThisDoc.attachedTemplate.BuildingBlockEntries("zzLogo").Insert Where:=cc.Range, RichText:=True
                End If
            ElseIf path = "/DocumentInfo/DocumentInfo-CompanyLogo" Then
                If aTag(1) Like "FrontPageHeader" Then
                    If CompanyLogoUpdated Then
                        Dim NewLogoPath As String
                        NewLogoPath = ReadText(path)
                        cc.Range.text = " "
                        If NewLogoPath > "" Then
                            cc.Range.InlineShapes.AddPicture NewLogoPath, False, True, cc.Range
                            With cc.Range.InlineShapes(1)
                                .LockAspectRatio = msoCTrue
                                Dim scaling As Double
                                scaling = (48 / .Height) * (.ScaleHeight / 100)
                                If scaling * .Width > 240 Then
                                    scaling = (240 / .Width)
                                End If
                                .ScaleHeight = 100 * scaling
                            End With
                        End If
                        CompanyLogoUpdated = False
                    End If
                End If
            ElseIf path = "/DocumentInfo/DocumentInfo-FileName" Then ' This is Not In the XML
                cc.Range.text = FixPath(ThisDoc.fullName)
                If Not cc.Range.Font.Name = "Arial" Then cc.Range.Font.Name = "Arial"
            ElseIf cc.tag = "DocumentLabel-ProjectNo:FrontPage" Then
                If ReadText("/DocumentInfo/DocumentInfo-ProjectNo") = "" Then
                    cc.Range.text = " "
                Else
                    cc.Range.text = ReadText(path)
                End If
            ElseIf path = "/DocumentInfo/DocumentInfo-TOC" Then
                headingLevels = ReadText("/DocumentInfo/DocumentInfo-TOC-HeadingLevels")
                addedStyles = ReadText("/DocumentInfo/DocumentInfo-TOC-Headings")
                If addedStyles > "" Then
                    'addedStyles = "HEADINGPART;9;PARMHEAD;9;Dummy,1,HEADINGPART,9,PARMHEAD,9"
                    addedStyles = "PARMHEAD;9;Dummy,1,PARMHEAD,9"
                End If
                Set ccTOC = cc
'                ElseIf path = "/DocumentLabel/DocumentLabel-Front" Then
'                    cc.Range.Text = "<|"
            ElseIf path = "/DocumentInfo/DocumentInfo-Translation" Then
                cc.Range.Paragraphs.Alignment = wdAlignParagraphLeft

            ElseIf path = "/DocumentInfo/DocumentInfo-TOF" Then
                'Do Nothing
            ElseIf path = "/DocumentInfo/DocumentInfo-TOT" Then
                'Do Nothing
            ElseIf path = "/DocumentInfo/DocumentInfo-FrontPage" Then
                'Do Nothing
            ElseIf path = "/DocumentInfo/DocumentInfo-FrontMatter" Then
                'Do Nothing
            ElseIf path = "/DocumentInfo/DocumentInfo-DocumentInformation" Then
                'Do Nothing
            ElseIf path = "/DocumentInfo/DocumentInfo-LeftBlank" Then
                'Do Nothing

            ElseIf cc.tag Like "DocumentInfo-Status:*" Then
                cc.Range.text = " "
            ElseIf TryReadText(path, value) Then
                cc.Range.text = ""
                cc.Range.LanguageId = Language
                If value > "" Then
                    If Not ((showFrontMatter = "Translation") And (cc.tag Like "*Header*" Or cc.tag Like "*Footer*")) Then
                        cc.Range.text = ReplaceRText(value)
                    Else
                        cc.Range.text = " "
                    End If
                    If showFrontMatter = "Translation" Then
                        If cc.tag Like "DocumentLabel-RevisionHistory*" Then
                            cc.Range.text = " "
                        End If
                        If cc.tag = "DocumentLabel-RevisionHistory-Revision:DocumentInformation" Then
                            cc.Range.text = "|||"
                        End If
                    End If

                    If InStr(cc.Range.text, vbCr) > 0 Then
                        cc.Range.text = Replace(cc.Range.text, vbCr, Chr(11))
                    End If
                    cc.Range.Characters(1).LanguageId = Language
                    cc.Range.Font.hidden = False
                    If InStr(cc.Range.text, "|fffd|") > 0 Then
                        ' Raise Registered
                        Dim ch As Range
                        For Each ch In cc.Range.Characters
                            If ch.text = "|fffd|" Then
                                ch.Font.Superscript = True
                            End If
                        Next
                    End If
                Else
                    cc.Range.text = " "
                End If
            ElseIf path = "/Container/Container" Then
                'Do Nothing
            ElseIf path = "/Unlocked/Unlocked" Then
                'Do Nothing
            Else
                'Stop
            End If
        Next
        Set rng = rng.NextStoryRange
        If ActiveWindow.View.SplitSpecial = wdPaneNone Then
            ActiveWindow.ActivePane.View.Type = wdPrintView
        Else
            ActiveWindow.ActivePane.Close
            ActiveWindow.View.Type = wdPrintView
        End If
    Loop While Not rng Is Nothing
End Sub

Public Sub UpdateContent()
    WriteLog "Updating header content"
    UpdateContentInStory ThisDoc.StoryRanges(wdPrimaryHeaderStory)
    UpdateContentInStory ThisDoc.StoryRanges(wdFirstPageHeaderStory)
    WriteLog "Updating footer content"
    UpdateContentInStory ThisDoc.StoryRanges(wdPrimaryFooterStory)
    UpdateContentInStory ThisDoc.StoryRanges(wdFirstPageFooterStory)
    
    WriteLog "Updating main content"
    UpdateContentInStory ThisDoc.StoryRanges(wdMainTextStory)
    
    WriteLog "Updating content information"
    UpdateContentInformation
End Sub

Private Sub UpdateOptional()

End Sub

Public Sub UpdateFinish()
    Dim rngInsert As Range
    WriteLog "Remove empty paragraphs at end of document"
    Set para = ThisDoc.Range.Paragraphs.Last
    Do While Replace(Replace(Trim(para.Range.text), vbCr, ""), vbCrLf, "") = "" And (para.Range.ShapeRange.Count + para.Range.InlineShapes.Count = 0) And para.Style.NameLocal <> ThisDoc.Styles(WdBuiltinStyle.wdStyleHeading1)
        If paraStart = para.Range.start Then
            Exit Do
        Else
            paraStart = para.Range.start
        End If
        Set rngDelete = para.Range
        'Debug.Print rngDelete.start, rngDelete.End
        If rngDelete.ShapeRange.Count + rngDelete.InlineShapes.Count = 0 Then
            On Error Resume Next
            rngDelete.Delete
            On Error GoTo 0
        End If
        If Err.Number > 0 Then Exit Do
        Set para = ActiveDocument.Range.Paragraphs.Last
    Loop
    
    'If HasChanged(CaptionHeading) Or HasChanged("Language") Then UpdateDocumentRangeFields
    
    ' Remove LeftBlank
    Dim rngDel As Range

    Set cc = GetFirstContentControlByTag("DocumentInfo-LeftBlank:DocumentInformation")
    If Not cc Is Nothing Then
        Set rngDel = cc.Range.Duplicate
        cc.Delete True
        rngDel.Delete
    End If

    WriteLog "Resizing front page and revisions"
    If Not ccFrontPage Is Nothing Then
        'ccFrontPage.Range.Paragraphs.first.Style = "Paragraph1"
        'ccFrontPage.Range.Paragraphs.Last.Style = "Paragraph1"
        Dim projectHeight As Single
        Dim mainHeight As Single
        Dim headerFooterHeight As Single
        Dim linesRowHeightExtra As Single
        Set rngInsert = ccFrontPage.Range.Duplicate '.Tables(1).Range.Duplicate
        With rngInsert.Paragraphs(1)
            .SpaceBefore = 0
            .SpaceAfter = 0
        End With
        With rngInsert.Paragraphs(1).Range.Font
            .Size = 1
            .ColorIndex = wdWhite
            .Position = 0
        End With
        With rngInsert.Tables(1)
            .rows(4).Height = 80
            .rows(5).Height = 3
            .rows(5).Range.Style = "Paragraph1"
            .rows(5).Range.ParagraphFormat.SpaceBefore = 0
            .rows(5).Range.ParagraphFormat.SpaceAfter = 0
            .rows(2).Height = 150
            .rows(1).Height = 80
            .rows(3).Height = 10
        End With
        
        projectHeight = rngInsert.Tables(1).rows(4).Height
        mainHeight = rngInsert.Tables(1).rows(2).Height
        linesRowHeightExtra = 6 'mainHeight - 114
        headerFooterHeight = 228
        If Language = "2052" Or Language = "1042" Then
            headerFooterHeight = 244
        End If
        Dim H As Single
        H = ((pageHeight - headerFooterHeight - mainHeight - projectHeight - linesRowHeightExtra) / 2)
        If H < 80 Then
            rngInsert.Tables(1).rows(1).Height = 80
            rngInsert.Tables(1).rows(3).Height = 2 * H - 80
        Else
            rngInsert.Tables(1).rows(1).Height = H + 20
            rngInsert.Tables(1).rows(3).Height = rngInsert.Tables(1).rows(1).Height - 20
        End If
    End If
    
    
    ' Resize revisions
    If Not ccRevisions Is Nothing Then
        ccRevisions.Range.Paragraphs(1).Range.Font.AllCaps = False
        'If Not ccRevisions.Range.Characters(1) = vbTab Then
        '    ccRevisions.Range.InsertBefore vbTab
        'End If
        ccRevisions.Range.Paragraphs(1).KeepWithNext = True
        Dim tblRevisions As table
        Set tblRevisions = ccRevisions.Range.Tables(1)
        If Not showFrontMatter = "Translation" Then
            tblRevisions.rows(1).HeadingFormat = True
        Else
            tblRevisions.rows(1).HeadingFormat = False
        End If
'        tblRevisions.rows.AllowBreakAcrossPages = True
        tblRevisions.Range.ParagraphFormat.KeepWithNext = False
        tblRevisions.Range.Paragraphs.KeepWithNext = False
'        tblRevisions.rows(1).Range.ParagraphFormat.KeepWithNext = False
'        tblRevisions.rows(1).Range.Paragraphs.KeepWithNext = False
        Dim col As Column
        Dim ce As Cell
        Dim longest As Integer
        longest = 0
        Set col = tblRevisions.Columns(4)
        For Each ce In col.Cells
        If ce.Range.Characters.Count > longest Then
            longest = ce.Range.Characters.Count
        End If
        Next
    
        tblRevisions.Columns(1).Width = 40
        tblRevisions.Columns(2).Width = 64
        If longest > 22 Then
            tblRevisions.Columns(3).Width = 80
            tblRevisions.Columns(4).Width = Selection.PageSetup.PageWidth - (220 + 64.05 + 151.8 - 9.5) + 36
        Else
            tblRevisions.Columns(3).Width = 116
            tblRevisions.Columns(4).Width = Selection.PageSetup.PageWidth - (220 + 64.05 + 151.8 - 9.5)
        End If
    End If

    Dim i As Integer
    'TOC \O "1-6" \T "PARMHEAD;9" \T "HEADINGPART;9" \H
   
    If Not ccTOC Is Nothing Then
        Dim rngToc As Range
        Set rngToc = ThisDoc.TablesOfContents(1).Range.Duplicate
        If RebuildTOC Then
            Set rngToc = ThisDoc.TablesOfContents(1).Range
            rngToc.Delete
        End If
        
        If ThisDoc.TablesOfContents.Count = 0 Then
            WriteLog "Inserting new TOC"
            'ThisDoc.TablesOfContents(1).Delete
            ThisDoc.TablesOfContents.Add Range:=rngToc, RightAlignPageNumbers:=True, UseHeadingStyles:=True, UpperHeadingLevel:=1, _
                LowerHeadingLevel:=headingLevels, IncludePageNumbers:=True, addedStyles:=addedStyles, _
                UseHyperlinks:=True, HidePageNumbersInWeb:=False, UseOutlineLevels:=False
            ThisDoc.TablesOfContents(1).TabLeader = wdTabLeaderDots
            ThisDoc.TablesOfContents.Format = wdIndexIndent
        Else
            Dim hs As HeadingStyle
            For Each hs In ThisDoc.TablesOfContents(1).HeadingStyles
                If LCase(hs.Style) = LCase("HeadingPart") Then
                    hs.Delete
                    Exit For
                End If
            Next
            WriteLog "Updating TOC"
            ThisDoc.TablesOfContents(1).Update
        End If
        
        ccTOC.Range.Paragraphs(ccTOC.Range.Paragraphs.Count).Style = "Paragraph1"
        With ccTOC.Range.Paragraphs(1).Range.Font
            .Spacing = 2
            .Underline = wdUnderlineSingle
            .Bold = True
            .Size = 12
        End With
        With ccTOC.Range.Paragraphs(1).Range.ParagraphFormat
            .SpaceBefore = 24
            .SpaceAfter = 3
        End With
        With ccTOC.Range.Paragraphs(2).Range.ParagraphFormat
            .SpaceBefore = 4
            .SpaceAfter = 0
        End With
        Set rng = ccTOC.Range.Paragraphs(3).Range
        rng.Collapse wdCollapseStart
        rng.Select
        
        ' Delete Front link
        If Not ccFrontPage Is Nothing Then
            Selection.Move wdCharacter, 1
            Selection.MoveEnd WdUnits.wdParagraph, 1
            Selection.TypeBackspace
        End If
        
        ' Keep Document Information
        If Not ccDocumentInformation Is Nothing Then
            Selection.MoveDown wdLine, 1
        Else
            With ccTOC.Range.Paragraphs(2).Range.ParagraphFormat
                .SpaceBefore = 4
                .SpaceAfter = 4
            End With
        End If
        
        ' Delete Contents
        If headingLevels > 1 Then
            Selection.Move wdCharacter, 1
            Selection.MoveEnd WdUnits.wdParagraph, 1
            Selection.TypeBackspace
        End If
        
        ' Delete Revisions
        If Not ccRevisions Is Nothing And headingLevels > 1 Then
            Selection.Move wdCharacter, 1
            Selection.MoveEnd WdUnits.wdParagraph, 1
            Selection.TypeBackspace
        End If
        
        WriteLog "Reformat TOC and update TOC hyperlinks"
        ReformatTOC ThisDoc.TablesOfContents(1).Range
        ReformatTOCHyperlinks
        
        If HeadingLayout = "No Numbering, No Page Break" Then
            For Each para In ThisDoc.TablesOfContents(1).Range.Paragraphs
                If (para.Range.text Like "#*.*" & vbTab & "*") Then
                    Dim tabRange As Range
                    Set tabRange = para.Range.Duplicate
                    tabRange.End = tabRange.start
                    Do While Not tabRange.text Like "*" & vbTab
                        tabRange.End = tabRange.End + 1
                    Loop
                    tabRange.End = tabRange.End - 1
                    tabRange.Font.color = wdColorWhite
                End If
            Next
        End If
    End If
    
    For i = 1 To ThisDoc.TablesOfFigures.Count
        If i = 1 Then WriteLog "Updating TOF, TOT"
        ThisDoc.TablesOfFigures(i).Update
    Next
    
    If Not ccTOF Is Nothing Then
        With ccTOF.Range.Paragraphs(1).Range.ParagraphFormat
            .SpaceBefore = 24
            .SpaceAfter = 3
        End With
        With ccTOF.Range.Paragraphs(2).Range.ParagraphFormat
            .SpaceBefore = 4
            .SpaceAfter = 8
        End With
     
        ccTOF.Range.Paragraphs(1).KeepWithNext = True
        ccTOF.Range.Paragraphs(2).KeepWithNext = True
    End If
    If Not ccTOT Is Nothing Then
        With ccTOT.Range.Paragraphs(1).Range.ParagraphFormat
            .SpaceBefore = 24
            .SpaceAfter = 3
        End With
        With ccTOT.Range.Paragraphs(2).Range.ParagraphFormat
            .SpaceBefore = 4
            .SpaceAfter = 8
        End With
        ccTOT.Range.Paragraphs(1).KeepWithNext = True
        ccTOT.Range.Paragraphs(2).KeepWithNext = True
    End If
   
    Dim aText() As String
    Dim pg As Integer
    Dim tocStart As Integer
    Dim fld As field
    
    PDFLayOut = ReadText("/DocumentInfo/DocumentInfo-PDFLayout")
    If Not ccFrontPage Is Nothing And Not ccTOC Is Nothing And Not ccDocumentInformation Is Nothing Then
        If PDFLayOut = "Two Page Right" Then
            ThisDoc.TablesOfContents(1).UpdatePageNumbers
            WriteLog "Updating PDF layout"
            For Each para In ThisDoc.TablesOfContents(1).Range.Paragraphs
                If para.Range.text Like "#*.*" & vbTab & "*" Then
                    aText = Split(para.Range.text, vbTab)
                    pg = aText(UBound(aText))
                    Exit For
                End If
            Next
            tocStart = ccTOC.Range.Paragraphs.first.Range.Information(WdInformation.wdActiveEndAdjustedPageNumber)
            'Debug.Print pg, tocStart
            If pg Mod 2 = 1 Then
                 If (pg - tocStart) Mod 2 = 0 Then
                    Set cc = GetFirstContentControlByTag("DocumentInfo-FrontPage:FrontPage")
                    Set rngInsert = cc.Range
                    rngInsert.Collapse wdCollapseEnd
                    ThisDoc.attachedTemplate.BuildingBlockEntries("zzLeftBlank").Insert Where:=rngInsert, RichText:=True
                Else
                    Set cc = ccTOC
                    Set rngInsert = cc.Range
                    rngInsert.Collapse wdCollapseStart
                    ThisDoc.attachedTemplate.BuildingBlockEntries("zzLeftBlank").Insert Where:=rngInsert, RichText:=True
                End If
            End If
        End If
    End If
       
    WriteLog "Updating page numbering"
    UpdateDocumentRangeFieldsPageRef
    
    For i = 1 To ThisDoc.TablesOfContents.Count
         ThisDoc.TablesOfContents(i).UpdatePageNumbers
    Next
    For i = 1 To ThisDoc.TablesOfFigures.Count
        ThisDoc.TablesOfFigures(i).UpdatePageNumbers
    Next

    LockMainContentControls True
    'TestUnlockAll
ExitSub:



End Sub

Public Function UpdateDocument(Optional screenUpdate As Boolean = False) As Boolean
    ScreenUpdating = screenUpdate
    UpdatePrepare
'    If HasChanged(PathLanguage) Then
'        'Stop
'    End If
'    If DataHasChanged() Then
'        'Stop
'    End If
'    If FrontMatterHasChanged() Then
'        'Stop
'    End If
'    If DocTypeHasChanged() Then
'        'Stop
'    End If
'    If SetupHasChanged() Then
'        'Stop
'    End If
    Dim fullUpdate As Boolean
    fullUpdate = (NewPaperFormat > "" Or FrontMatterHasChanged Or SetupHasChanged Or method <> "Form")

    If fullUpdate And (JumpToPart = "" Or JumpToPart = "UpdateLayout") Then UpdateLayout
    If JumpToPart = "" Or JumpToPart = "UpdateContent" Then UpdateContent
    
    'If JumpToPart = "" Or JumpToPart = "UpdateOptional" Then UpdateOptional
    'If fullUpdate And (JumpToPart = "" Or JumpToPart = "UpdateFinish") Then
    UpdateFinish
    If JumpToPart = "Error" Then
        ' Error handling
    End If
    '
    
    If gotoEnd Then
        ThisDoc.Characters.Last.Select
        Selection.Collapse wdCollapseEnd
    Else
        rngReturnTo.Select
    End If
    'ActiveWindow.ScrollIntoView Selection.Range, True
    
    'StructureUpdated = False
    LanguageUpdated = False
    CompanyLogoUpdated = False
    NewPaperFormat = ""
    OldLanguage = ReadText(PathLanguage)
    
    updated = True
    WriteLog "Done.."
End Function

Public Sub AddConversionHistory(key As Variant, value As String)
    ErrorNo = ErrorNo + 1
    key = key & "." & Right("000000" & ErrorNo, 6)
    ConversionHistory.Add key, value
End Sub

Public Sub AddError(value As String)
    Dim key As String
    key = "Error"
    AddConversionHistory key, value
End Sub

Public Sub AddWarning(value As String)
    Dim key As String
    key = "Warning"
    AddConversionHistory key, value
End Sub

Public Function ConversionHistoryToString() As String
    Dim key As Variant
    Dim str As String
    str = ""
    For Each key In ConversionHistory.Keys
        str = str & IIf(str = "", "", vbLf) & key & "|" & ConversionHistory(key)
    Next
    ConversionHistoryToString = str
End Function

Public Sub InsertCalculatedCC(strFormula As String)
    Dim isUpdated As Boolean
    isUpdated = True
    
    If Not IsLocked Then
        Prolog "Insert Control: " & strFormula
        On Error GoTo UpdatedFalse
        Dim cc As ContentControl
        Set cc = Selection.Range.ContentControls.Add(wdContentControlRichText)
        cc.tag = "Calculate:"
        cc.Title = strFormula
        cc.Range.text = CalculateTitle(strFormula, , False)
        cc.SetPlaceholderText , , " "
        'cc.LockContents = True
        cc.Range.Select
        Selection.Collapse wdCollapseEnd
        Selection.MoveRight
        Selection.InsertBefore " "
        Selection.Collapse wdCollapseEnd
        On Error GoTo 0
    Else
        Exit Sub
    End If
ExitSub:
    updated = isUpdated
    Epilog
    
    Exit Sub
    
UpdatedFalse:
    isUpdated = False
    Resume ExitSub

End Sub

Public Sub LockUnlockContentControlsInRange(blnLock As Boolean, rng As Range, Optional ByRef ccs As Collection = Nothing)
    Dim cc As ContentControl
    If ccs Is Nothing Then
        For Each cc In rng.ContentControls
            If Not cc.LockContents = blnLock Then
                cc.LockContents = blnLock
            End If
        Next cc
    Else
        If blnLock Then
            For Each cc In ccs
                If Not cc.LockContents = True Then
                    cc.LockContents = True
                End If
            Next cc
        Else
            For Each cc In rng.ContentControls
                If Not cc.LockContents = False Then
                    cc.LockContents = False
                    ccs.Add cc
                End If
            Next cc
        End If
    End If
End Sub

Public Sub LockAllContentControls(ccs As Collection)
    Dim cc As ContentControl

    For Each cc In ccs
        cc.LockContents = True
    Next
    GetFirstContentControlByTag("DocumentInfo-FrontMatter:DocumentInformation").LockContentControl = True
    
End Sub

Public Sub LockMainContentControls(blnLock As Boolean)
    Dim ccFrontMatter As ContentControl
    Dim cc As ContentControl
    Set ccFrontMatter = GetFirstContentControlByTag("DocumentInfo-FrontMatter:DocumentInformation")
    
    LockUnlockContentControlsInRange blnLock, ThisDoc.StoryRanges(wdFirstPageHeaderStory)
    LockUnlockContentControlsInRange blnLock, ThisDoc.StoryRanges(wdFirstPageFooterStory)
    LockUnlockContentControlsInRange blnLock, ThisDoc.StoryRanges(wdPrimaryHeaderStory)
    LockUnlockContentControlsInRange blnLock, ThisDoc.StoryRanges(wdPrimaryFooterStory)
    
    If Not ccFrontMatter Is Nothing Then
        If Not blnLock Then
            ccFrontMatter.LockContentControl = False
            ccFrontMatter.LockContents = False
        End If
        For Each cc In ccFrontMatter.Range.ContentControls
            cc.LockContents = blnLock
        Next cc
        If Not ccTranslation Is Nothing Then
            For Each cc In ccTranslation.Range.ContentControls
                cc.LockContents = False
            Next cc
            If Not ccRevisions Is Nothing Then
                ccRevisions.LockContents = False
            End If
        End If
        If blnLock Then
            ccFrontMatter.LockContentControl = True
            ccFrontMatter.LockContents = True
        End If
    End If
End Sub

'Public Function UnlockContentControls(rng As Range) As Collection
'    Dim ccs As New Collection
'    Dim cc As ContentControl
'
'    For Each cc In rng.ContentControls
'        If cc.LockContents Then
'            ccs.Add cc
'            cc.LockContents = False
'        End If
'    Next
'    Set UnlockContentControls = ccs
'End Function

Public Function UnlockAllContentControls() As Collection
    Dim ccs As New Collection
    Dim cc As ContentControl
    On Error Resume Next
    GetFirstContentControlByTag("DocumentInfo-FrontMatter:DocumentInformation").LockContentControl = False
    On Error GoTo 0
    LockUnlockContentControlsInRange False, ThisDoc.Range, ccs
    Set UnlockAllContentControls = ccs
End Function

Public Function GetPropertyValue(strDocType As String, strProperty As String, Optional justValue As Boolean = False) As String
    Dim i As Integer
    Dim field As String
    Dim value As String
    Dim mode As String
    
    For i = 2 To UBound(aDocumentTypes)
        If aDocumentTypes(i, 0) = strDocType Then
            Exit For
        End If
    Next
    If i <= UBound(aDocumentTypes) Then
        Dim j As Integer
        For j = 1 To UBound(aDocumentTypes, 2)
            mode = ""
            field = aDocumentTypes(0, j)
            If field = strProperty Then
                value = aDocumentTypes(i, j)
                If justValue Then
                    GetPropertyValue = value
                Else
                    If value = "" Then 'Set empty if not new
                        mode = "SetValue"
                        value = ""
                    ElseIf value = "#" Then 'Do nothing
                        mode = "SetDefault"
                    ElseIf value = "%" Then 'Set default if not new
                        mode = "SetDefault"
                        value = ""
                    ElseIf Left(value, 1) = "!" Then 'Force value
                        mode = "ForceValue"
                        value = Mid(value, 2)
                        If value = "%" Then
                            mode = "ForceDefault"
                            value = ""
                        End If
                    Else 'Set value if not new
                        mode = "SetValue"
                    End If
                    ' Find value
                    Select Case mode
                        Case "SetDefault", "ForceDefault"
                            Dim defaultValue As String
                            value = aDocumentTypes(1, j)
                    End Select
                    GetPropertyValue = ReplaceRText(value)
                End If
                Exit For
            End If
        Next
    Else
        GetPropertyValue = ""
    End If
    
End Function


Attribute VB_Name = "DocType"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'Public Index As Integer
'
'Public Function Init(strDocType As String)
'    Dim i As Integer
'
'    If Not ReadTemplateComments Then
'        Dim DX As DOCXML
'        Set DX = New DOCXML
'        DX.Init
'        Set DX = Nothing
'    End If
'
'    For i = 2 To UBound(aDocumentTypes)
'        If aDocumentTypes(i, 0) = strDocType Then
'            Exit For
'        End If
'    Next
'    If i >= UBound(aDocumentTypes) Then
'        Index = -1
'    Else
'        Index = i
'    End If
'End Function
'
'Public Function GetValue(strProperty As String) As String
'    Dim j As Integer
'    Dim field As String
'    Dim value As String
'    Dim mode As String
'
'    For j = 1 To UBound(aDocumentTypes, 2)
'        mode = ""
'        field = aDocumentTypes(0, j)
'        If field = strProperty Then Exit For
'    Next
'    If i >= UBound(aDocumentTypes) Then
'        GetValue = "NotFound"
'    Else
'        value = aDocumentTypes(Index, j)
'        If value = "" Then
'            mode = "DoNothing"
'        ElseIf value = "%" Then 'Set default if empty
'            mode = "SetDefaultIfEmpty"
'            value = ""
'        ElseIf Left(value, 1) = "#" Then 'Set value if default or empty
'            mode = "SetValueIfDefaultOrEmpty"
'            value = ""
'        ElseIf Left(value, 1) = "!" Then 'Force set value
'            mode = "SetValue"
'            value = Mid(value, 2)
'            If value = "%" Then
'                mode = "SetDefault"
'                value = ""
'            End If
'        Else 'Set value if not default
'            mode = "SetValueIfEmpty"
'        End If
'        If mode = "DoNothing" Then
'            GetValue = "DoNothing"
'        Else
'            GetValue = mode
'            'SetValue i, j, mode, field, value
'        End If
'    End If
'
'End Function
Attribute VB_Name = "InsertCalculatedField"
Attribute VB_Base = "0{ED9F59D3-6C12-4144-AD9E-74EDBDE78D90}{2CF23EC9-2F9A-4AF5-B091-2D82242B3295}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Dim DX As DOCXML

Public Sub DoOk()
    DX.InsertCalculatedCC TextBoxFormula.text
    Set DX = Nothing
    Unload Me
End Sub

Public Sub DoCancel()
    Set DX = Nothing
    Unload Me
End Sub

Private Sub ComboBoxInsertField_Change()
    Dim formulaLen As Integer
    Dim formulaStart As Integer
    
    Dim txt As String
    txt = ComboBoxInsertField.text
    formulaLen = Len(txt) + 4
    formulaStart = TextBoxFormula.SelStart
    
    If txt > "" Then
        TextBoxFormula.SelText = "[[" & txt & "]]"
        TextBoxFormula.SelStart = formulaStart
        TextBoxFormula.SelLength = formulaLen
    Else
        TextBoxFormula.SelText = ""
        TextBoxFormula.SelStart = formulaStart
        TextBoxFormula.SelLength = 0
    End If

End Sub

Private Sub CommandButtonCancel_Click()
    DoCancel
End Sub

Private Sub CommandButtonOk_Click()
    DoOk
End Sub

Private Sub TextBoxFormula_Change()
    lblResult.caption = CalculateTitle(TextBoxFormula.text, DX)
End Sub

Private Sub UserForm_Initialize()
    Set DX = New DOCXML
    DX.Init
End Sub

Private Sub UserForm_Layout()
  
    Dim fields() As String
    fields = Split(",Author,Date,DocNo,Language,LanguageCode,TitleLine1,TitleLine2,TitleLine3,TitleLine4,TitleLine5,MainProjectNo,ProjectNo,Revision,SupplierFileName", ",")
    
    With ComboBoxInsertField
        .List = fields
        .AutoWordSelect = True
    End With

End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    If CloseMode = 0 Then 'Red X
        DoCancel
    End If
End Sub

Attribute VB_Name = "MainForm"
Attribute VB_Base = "0{B7416B40-5F12-4828-9F47-65DBC11E6389}{733AEA61-0711-469E-B246-C27261792F41}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public DX As DOCXML
Public RevCount As Integer
Private aRevHist() As String
Private CompanyLogoPath As String
Private NewCompanyLogoPath As String
Private TOC As String
Private InChange As Boolean
Private ShowConversion As Boolean
Private ShowForm As Boolean
Private IsNewDoc As Boolean
Private WasTranslation As Boolean

Public Sub DoOk()

    DX.Prolog "Updating from Form"

    DX.WriteText "/DocumentInfo/DocumentInfo-FrontMatter", IIf(Me.OptionButtonShowFrontMatter.value = True, "", "Hide")
    DX.WriteText "/DocumentInfo/DocumentInfo-ClassificationLabel", DX.ReplaceRText(Me.TextBoxClassificationLabel)
    
    DX.WriteText "/DocumentInfo/DocumentInfo-WorkflowLabel", DX.ReplaceRText(Me.TextBoxWorkflowLabel)
    DX.WriteText "/DocumentInfo/DocumentInfo-TitleLine1", DX.ReplaceRText(Me.TextBoxLine1)
    DX.WriteText "/DocumentInfo/DocumentInfo-TitleLine2", DX.ReplaceRText(Me.TextBoxLine2)
    DX.WriteText "/DocumentInfo/DocumentInfo-TitleLine3", DX.ReplaceRText(Me.TextBoxLine3)
    DX.WriteText "/DocumentInfo/DocumentInfo-TitleLine4", DX.ReplaceRText(Me.TextBoxLine4)
    DX.WriteText "/DocumentInfo/DocumentInfo-TitleLine5", DX.ReplaceRText(Me.TextBoxLine5)
    DX.WriteText "/DocumentInfo/DocumentInfo-FrontPageInfo", DX.ReplaceRText(Me.TextBoxFrontPageInfo)
    DX.WriteText "/DocumentInfo/DocumentInfo-DocType", Me.cmbDocType.text
    DX.WriteText "/DocumentInfo/DocumentInfo-PDFLayout", Me.cmbPDFLayout.text
    DX.WriteText "/DocumentInfo/DocumentInfo-HeadingLayout", Me.cmbHeadingLayout.text
    
    DX.WriteText "/DocumentInfo/DocumentInfo-DocNo", DX.ReplaceRText(Me.TextBoxDocNo)
    DX.WriteText "/DocumentInfo/DocumentInfo-ProjectNo", DX.ReplaceRText(Me.TextBoxProjectNo)
    DX.WriteText "/DocumentInfo/DocumentInfo-Author", Me.TextBoxAuthor
    DX.WriteText "/DocumentInfo/DocumentInfo-Date", Me.TextBoxDate
    DX.WriteText "/DocumentInfo/DocumentInfo-Revision", Me.TextBoxRevision
    DX.WriteText "/DocumentInfo/DocumentInfo-Description", DX.ReplaceRText(Me.TextBoxDescription)
    DX.WriteText "/DocumentInfo/DocumentInfo-SupplierFileName", DX.ReplaceRText(Me.TextBoxSupplierFileName)

    DX.WriteText "/DocumentInfo/DocumentInfo-CaptionHeading", Me.cmbCaptionHeading.text
    DX.WriteText "/DocumentInfo/DocumentInfo-TOC-HeadingLevels", Me.cmbHeadingLevels.text
    DX.WriteText "/DocumentInfo/DocumentInfo-TOC-Headings", IIf(Me.CheckBoxIncludeParmHead.value = True, "Include Parm Head", "")
    
    DX.WriteText "/DocumentInfo/DocumentInfo-TOC", IIf(Me.CheckBoxTableOfContents.value = True, "Standard", "")
    DX.WriteText "/DocumentInfo/DocumentInfo-TOF", IIf(Me.CheckBoxTableOfFigures.value = True, "Standard", "")
    DX.WriteText "/DocumentInfo/DocumentInfo-TOT", IIf(Me.CheckBoxTableOfTables.value = True, "Standard", "")
    DX.WriteText "/DocumentInfo/DocumentInfo-FrontPage", IIf(Me.CheckBoxFrontPage.value = True, "Standard", "")
    DX.WriteText "/DocumentInfo/DocumentInfo-DocumentInformation", IIf(Me.CheckBoxDocumentInformation.value = True, "Standard", "")
    DX.WriteText "/DocumentInfo/DocumentInfo-RevisionHistory-Show", IIf(Me.CheckBoxTableOfRevisions.value = True, "Standard", "")
    DX.WriteText "/DocumentInfo/DocumentInfo-Language", cmbLanguage.value
    
    If cmbCaptionHeading.text <> DX.ReadText("/DocumentInfo/DocumentInfo-CaptionHeading") Then
        DX.UpdateCaptions = True
    End If
    
    If TOC <> Me.cmbHeadingLevels.text & DX.ReadText("/DocumentInfo/DocumentInfo-TOC-Headings") Then
        DX.RebuildTOC = True
    End If
    
    If NewCompanyLogoPath <> CompanyLogoPath Then
        DX.WriteText "/DocumentInfo/DocumentInfo-CompanyLogo", NewCompanyLogoPath
        DX.CompanyLogoUpdated = True
    End If
    
    If cmbPaper.text <> DX.GetPaperFormat Then
        DX.NewPaperFormat = cmbPaper.text
    End If
    
    GetRevisionHistory
    DX.WriteRevisionHistory aRevHist
    
    DX.ThisBGD.NewTranslation = CheckBoxTranslation.value
    DX.DoUpdate = True
    DX.DoReadTranslation = False
    Application.DisplayDocumentInformationPanel = False
    Unload Me
End Sub

Public Function GetRevisionHistory() As Variant
    aRevHist(RevCount - 1, 0) = Me.TextBoxRevision.text
    aRevHist(RevCount - 1, 1) = Me.TextBoxDate.text
    aRevHist(RevCount - 1, 2) = Me.TextBoxAuthor.text
    aRevHist(RevCount - 1, 3) = Me.TextBoxDescription.text
    GetRevisionHistory = aRevHist
End Function

Public Function SetRevisionHistory(aNewRevHist() As String, NewRevCount As Integer) As Variant
    aRevHist = OrderRevisionHistory(aNewRevHist)
    RevCount = NewRevCount
    Me.TextBoxRevision.text = aRevHist(RevCount - 1, 0)
    Me.TextBoxDate.text = aRevHist(RevCount - 1, 1)
    Me.TextBoxAuthor.text = aRevHist(RevCount - 1, 2)
    Me.TextBoxDescription.text = aRevHist(RevCount - 1, 3)
End Function

Public Sub DoCancel()
    If Not DX Is Nothing Then
        If DX.ReadText("/DocumentInfo/DocumentInfo-Language") = "" Then
            DX.WriteText "/DocumentInfo/DocumentInfo-Language", 2057
            Me.OptionButtonHideFrontMatter.value = True
            DX.LanguageUpdated = True
            DoOk
        Else
            DX.DoUpdate = False
            DX.DoReadTranslation = False
            Application.DisplayDocumentInformationPanel = False
            Unload Me
        End If
    End If

End Sub

Private Sub cmbAcceptConversion_Click()
    DX.DeleteNode "/DocumentInfo/Conversion"
    MultiPageMain.value = MultiPageMain.Pages("PageMain").Index
    Me.TextBoxWorkflowLabel.text = ""
    Me.TextBoxLine1.SetFocus
    MultiPageMain.Pages("PageConversion").Visible = False
End Sub

Private Sub cmbClassificationLabel_Change()
    TextBoxClassificationLabel.value = cmbClassificationLabel.value
End Sub

Private Sub SetValue(i As Integer, j As Integer, mode As String, field As String, value As String)
    Dim oldValue As String
    Dim force As Boolean
    
    Dim defaultValue As String
    Select Case field
        Case "DocMainType", "Title", "Subject", "DocTitle", "DocSearchTitle", "Logo"
            Exit Sub
    End Select
    
    defaultValue = aDocumentTypes(1, j)
    
'    Select Case field
'        Case "PDFLayout"
'            oldValue = TextBoxPDFLayout.text
'        Case "HeadingLayout"
'            oldValue = TextBoxHeadingLayout.text
'        Case "ClassificationLabel"
'            oldValue = TextBoxClassificationLabel.text
'        Case "WorkflowLabel"
'            oldValue = TextBoxWorkflowLabel.text
'        Case "DocNo"
'            oldValue = TextBoxDocNo.text
'        Case "CaptionHeading"
'            oldValue = cmbCaptionHeading.text
'        Case "DocumentInformation"
'            oldValue = IIf(Me.CheckBoxDocumentInformation.value = True, "Standard", "")
'        Case "FrontMatter"
'            oldValue = IIf(Me.OptionButtonShowFrontMatter.value = True, "", IIf(Me.OptionButtonHideFrontMatter.value = True, "Hide", "Translation"))
'        Case "FrontPage"
'            oldValue = TextBoxClassificationLabel.text
'        Case "FrontPageInfo"
'            oldValue = TextBoxFrontPageInfo.text
''        Case "Logo"
''            oldValue = IIf(NewCompanyLogoPath = "", CompanyLogoPath, NewCompanyLogoPath)
'        Case "ProjectNo"
'            oldValue = TextBoxProjectNo.text
'        Case "RevisionHistory-Show"
'            oldValue = IIf(Me.CheckBoxTableOfRevisions.value = True, "Standard", "")
'        Case "TOC"
'            oldValue = IIf(Me.CheckBoxTableOfContents.value = True, "Standard", "")
'        Case "TOC-HeadingLevels"
'            oldValue = cmbHeadingLevels.text
'        Case "TOC-Headings"
'            oldValue = IIf(Me.CheckBoxIncludeParmHead.value = True, "Include Parm Head", "")
'        Case "TOF"
'            oldValue = IIf(Me.CheckBoxTableOfFigures.value = True, "Standard", "")
'        Case "TOT"
'            oldValue = IIf(Me.CheckBoxTableOfTables.value = True, "Standard", "")
'    End Select
    
    ' Debug Print i, j, mode, field, value, oldValue, defaultValue
    
    ' Find value
    Select Case mode
        Case "SetDefault"
            value = defaultValue
            force = False
        Case "ForceDefault"
            value = defaultValue
            force = True
        Case "SetValue"
            force = False
        Case "ForceValue"
            force = True
        Case "DoNothing"
            force = False
    End Select
    value = DX.ReplaceRText(value)
    ' Debug.Print oldValue, value
    
    Dim ctrl As control
    Set ctrl = Nothing
    Dim ctrlLabel As control
    Set ctrlLabel = Nothing
    
    
    Select Case field
        Case "PDFLayout"
            If mode <> "DoNothing" Then Me.cmbPDFLayout = value
            Set ctrl = Me.cmbPDFLayout
            Set ctrlLabel = Me.LabelPDFLayout
        Case "HeadingLayout"
            If mode <> "DoNothing" Then Me.cmbHeadingLayout = value
            Set ctrl = Me.cmbHeadingLayout
            Set ctrlLabel = Me.LabelHeadingLayout
        Case "ClassificationLabel"
            If mode <> "DoNothing" Then Me.TextBoxClassificationLabel = value
            Set ctrl = Me.TextBoxClassificationLabel
        Case "WorkflowLabel"
            If mode <> "DoNothing" Then Me.TextBoxWorkflowLabel = value
            Set ctrl = Me.TextBoxWorkflowLabel
        Case "DocNo"
            If mode <> "DoNothing" Then Me.TextBoxDocNo = value
            Set ctrl = Me.TextBoxDocNo
        Case "CaptionHeading"
            If mode <> "DoNothing" Then Me.cmbCaptionHeading.value = value
            Set ctrl = Me.cmbCaptionHeading
            Set ctrlLabel = Me.LabelHeadingCaption
        Case "DocumentInformation"
            If mode <> "DoNothing" Then Me.CheckBoxDocumentInformation = (value > "")
            Set ctrl = Me.CheckBoxDocumentInformation
        Case "FrontMatter"
            Select Case value
            Case ""
                If mode <> "DoNothing" Then Me.OptionButtonShowFrontMatter.value = True
            Case "Hide"
                If mode <> "DoNothing" Then Me.OptionButtonHideFrontMatter.value = True
            End Select
            If force Then
                On Error Resume Next
                Me.OptionButtonShowFrontMatter.Enabled = False
                Me.OptionButtonHideFrontMatter.Enabled = False
                On Error GoTo 0
            Else
                On Error Resume Next
                Me.OptionButtonShowFrontMatter.Enabled = True
                Me.OptionButtonHideFrontMatter.Enabled = True
                On Error GoTo 0
            End If
        Case "FrontPage"
            If mode <> "DoNothing" Then Me.CheckBoxFrontPage = (value > "")
            Set ctrl = Me.CheckBoxFrontPage
        Case "FrontPageInfo"
            If mode <> "DoNothing" Then Me.TextBoxFrontPageInfo = value
            Set ctrl = Me.TextBoxFrontPageInfo
'        Case "Logo"
        Case "ProjectNo"
            If mode <> "DoNothing" Then Me.TextBoxProjectNo = value
            Set ctrl = Me.TextBoxProjectNo
        Case "RevisionHistory-Show"
            If mode <> "DoNothing" Then Me.CheckBoxTableOfRevisions = (value > "")
            Set ctrl = Me.CheckBoxTableOfRevisions
        Case "TOC"
            If mode <> "DoNothing" Then Me.CheckBoxTableOfContents = (value > "")
            Set ctrl = Me.CheckBoxTableOfContents
        Case "TOC-HeadingLevels"
            If mode <> "DoNothing" Then Me.cmbHeadingLevels = value
            Set ctrl = Me.cmbHeadingLevels
            Set ctrlLabel = Me.LabelHeadingLevels
        Case "TOC-Headings"
            If mode <> "DoNothing" Then Me.CheckBoxIncludeParmHead = (value > "")
            Set ctrl = Me.CheckBoxIncludeParmHead
        Case "TOF"
            If mode <> "DoNothing" Then Me.CheckBoxTableOfFigures = (value > "")
            Set ctrl = Me.CheckBoxTableOfFigures
        Case "TOT"
            If mode <> "DoNothing" Then Me.CheckBoxTableOfTables = (value > "")
            Set ctrl = Me.CheckBoxTableOfTables
    End Select
    
    If Not ctrl Is Nothing Then
        If force Then
            On Error Resume Next
            ctrl.Enabled = False
            On Error GoTo 0
        Else
            On Error Resume Next
            ctrl.Enabled = True
            On Error GoTo 0
        End If
    End If
      
    If Not ctrlLabel Is Nothing Then
        If force Then
            On Error Resume Next
            ctrlLabel.Enabled = False
            On Error GoTo 0
        Else
            On Error Resume Next
            ctrlLabel.Enabled = True
            On Error GoTo 0
        End If
    End If
      
End Sub


Private Sub cmbCompare_Click()
    CompareWithConversionBase Me
End Sub

Private Sub cmbDocType_Change()
    Dim i As Integer
    
    
    For i = 2 To UBound(aDocumentTypes)
        If aDocumentTypes(i, 0) = cmbDocType.text Then
            Exit For
        End If
    Next
    If i <= UBound(aDocumentTypes) Then
        Dim j As Integer
        For j = 1 To UBound(aDocumentTypes, 2)
            Dim field As String
            Dim value As String
            Dim mode As String
            mode = ""
            field = aDocumentTypes(0, j)
            value = aDocumentTypes(i, j)
            If value = "" Then 'Set empty if not new
                mode = "SetValue"
                value = ""
            ElseIf value = "#" Then 'Do nothing
                mode = "DoNothing"
            ElseIf value = "%" Then 'Set default if not new
                mode = "SetDefault"
                value = ""
            ElseIf Left(value, 1) = "!" Then 'Force value
                mode = "ForceValue"
                value = Mid(value, 2)
                If value = "%" Then
                    mode = "ForceDefault"
                    value = ""
                End If
            Else 'Set value if not new
                mode = "SetValue"
            End If
            SetValue i, j, mode, field, value
        Next
    End If
    
End Sub

Private Sub cmbMainDocType_Change()
    If Not InChange Then
        InChange = True
        InitializeDocType True
        InChange = False
    End If
End Sub

Private Sub cmbDocType_Enter()
'    SendKeys "%{Down}"
End Sub

Private Sub cmbWorkflowLabel_Change()
    TextBoxWorkflowLabel.value = cmbWorkflowLabel.value
End Sub

Private Sub CommandButtonCancel_Click()
    DoCancel
End Sub

Private Sub CommandButtonLoadImage_Click()
    Dim rng As Range
    Dim rngPic As Range
  
    With Application.FileDialog(msoFileDialogFilePicker)
        .AllowMultiSelect = False
        .ButtonName = "Load image"
        .Title = "Select an image file"
        .Filters.Add "Image", "*.emf; *.wmf; *.png; *.gif; *.jpg; *.jpeg", 1
        .Filters.Add "All files", "*.*", 2
        .InitialView = msoFileDialogViewLargeIcons
        .initialFilename = "\\crisnet\project\spteam\Pictures\"
        If .show = -1 Then
            NewCompanyLogoPath = .SelectedItems(1)
            If CompanyLogoPath <> NewCompanyLogoPath Then
                ImageCompanyLogo.Picture = Nothing
                If NewCompanyLogoPath > "" Then
                    On Error GoTo ErrorPicture
                    'ImageCompanyLogo.Picture = LoadPicture(Replace(Replace(NewCompanyLogoPath, "http:", "", , , vbTextCompare), "/", "\"))
                    Set ImageCompanyLogo.Picture = LoadPictureGDI(Replace(Replace(NewCompanyLogoPath, "http:", "", , , vbTextCompare), "/", "\"))
                    On Error GoTo 0
                End If
            End If
        Else
        
        End If
    End With
ExitSub:
    Exit Sub
ErrorPicture:
    ' Restore old logo
    ImageCompanyLogo.Picture = Nothing
    If CompanyLogoPath > "" Then
        Dim ccRestore As ContentControl
        Set ccRestore = ActiveDocument.SelectContentControlsByTag("DocumentInfo-CompanyLogo:FrontPageHeader")(1)
        If ccRestore.Range.InlineShapes.Count > 0 Then
            ccRestore.Range.InlineShapes(1).Range.CopyAsPicture
        End If
        ImageCompanyLogo.Picture = PastePicture()
    End If
    NewCompanyLogoPath = CompanyLogoPath
    If Not rng Is Nothing Then
        rng.Select
    End If
    If Not rngPic Is Nothing Then
        rngPic.Delete
    End If
    
    MsgBox "Failed loading picture. Some files are not usable.", vbCritical + vbOKOnly, "Load image"
    
    
    Resume ExitSub
End Sub

Private Sub CommandButtonquickGuide_Click()
    Dim myShell As Object
    Set myShell = CreateObject("WScript.Shell")
    myShell.run "http://extranet.crisplant.com/site/SoftwareProducts/Shared%20Documents/Documentation/BGdoc%20Template/BGdoc_QuickGuide_EN.pdf"
End Sub

Private Sub CommandButtonRemoveLogo_Click()
    NewCompanyLogoPath = ""
    ImageCompanyLogo.Picture = Nothing
End Sub


Private Sub CommandButtonNewMajor_Click()
    AddRevision GetNewMajor(Me.TextBoxRevision.text)
End Sub

Private Sub CommandButtonNewMinor_Click()
    AddRevision GetNewMinor(Me.TextBoxRevision.text)
End Sub

Private Sub AddRevision(newRev As String)
    aRevHist(RevCount - 1, 0) = Me.TextBoxRevision.text
    aRevHist(RevCount - 1, 1) = Me.TextBoxDate.text
    aRevHist(RevCount - 1, 2) = Me.TextBoxAuthor.text
    aRevHist(RevCount - 1, 3) = Me.TextBoxDescription.text
    ReDimPreserve aRevHist, RevCount, 4
    RevCount = RevCount + 1
    Me.TextBoxRevision.text = newRev
    Me.TextBoxDate.text = Format(Now, "YYYY-MM-DD")
    Me.TextBoxAuthor.text = UserName
    Me.TextBoxDescription.text = ""
    aRevHist(RevCount - 1, 0) = Me.TextBoxRevision.text
    aRevHist(RevCount - 1, 1) = Me.TextBoxDate.text
    aRevHist(RevCount - 1, 2) = Me.TextBoxAuthor.text
    aRevHist(RevCount - 1, 3) = Me.TextBoxDescription.text
    If Not UserName = "" Then
        Me.TextBoxDescription.SetFocus
    Else
        Me.TextBoxAuthor.SetFocus
    End If
End Sub

Private Sub CommandButtonOk_Click()
    DoOk
End Sub

Private Sub RevisionHistory_Click()
    Dim frmRevision As New RevisionHistoryForm
    Set frmRevision.CalledFrom = Me
    frmRevision.Display
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    If CloseMode = 0 Then 'Red X
        DoCancel
    End If
End Sub

Public Sub Init(useDX As DOCXML)
    'Debug.Print PointsToPixels(Me.Width), PointsToPixels(Me.Height), PointsToPixels(Application.ActiveWindow.UsableWidth), PointsToPixels(Application.ActiveWindow.UsableHeight)
    InChange = True
    ShowConversion = False
    
    Set DX = useDX
    Dim data() As String
    Dim Language As String
    Dim rows As Integer
    Dim listIndex As Integer
    Dim i As Integer
    Dim cc As ContentControl
    Dim str As String
    
    For i = 1 To 12
        str = Right("00" & i, 2)
        Me.Controls("lbl" & str).Visible = False
        Me.Controls("txt" & str).Visible = False
    Next
    
    
    ' Initialize form fields
    
    Dim oConv As CustomXMLNode
    Set oConv = DX.ReadNode("/DocumentInfo/Conversion")
    If Not oConv Is Nothing Then
        ShowConversion = True
    End If
    
    If ShowConversion Then
        Me.MultiPageMain.Pages("PageConversion").Visible = True
        Me.MultiPageMain.value = Me.MultiPageMain.Pages("PageConversion").Index
        ' Fill Out Conversion Controls
        Me.TextBoxConvertedFrom = DX.ReadText("/DocumentInfo/Conversion/Conversion-FromDoc")
        Me.TextBoxConvertedBy = DX.ReadText("/DocumentInfo/Conversion/Conversion-User")
        Me.TextBoxConvertedAt = DX.ReadText("/DocumentInfo/Conversion/Conversion-AtTime")
        Dim strConversionHistory As String
        strConversionHistory = DX.ReadText("/DocumentInfo/Conversion/Conversion-History")
        If strConversionHistory > "" Then
            Dim aStrConversionHistory() As String
            Dim strErrors As String
            Dim strWarnings As String
            aStrConversionHistory = Split(strConversionHistory, vbLf)
            Dim var As Variant
            For Each var In aStrConversionHistory
                If var Like "Error*" Then
                    strErrors = strErrors & IIf(strErrors = "", "", vbLf) & Split(var, "|", 2)(1)
                ElseIf var Like "Warning*" Then
                    strWarnings = strWarnings & IIf(strWarnings = "", "", vbLf) & Split(var, "|", 2)(1)
                End If
            Next
        
            TextBoxErrorsAndWarnings.text = IIf(strErrors > "", "Errors:" & vbLf, "") & strErrors & IIf(strErrors > "" And strWarnings > "", vbLf & vbLf, "") & IIf(strWarnings > "", "Warnings:" & vbLf, "") & strWarnings
        
        End If
    Else
        Me.MultiPageMain.Pages("PageConversion").Visible = False
        Me.MultiPageMain.value = Me.MultiPageMain.Pages("PageMain").Index
        Me.TextBoxLine1.SetFocus
    End If
    
    str = ""
    Dim frontMatter As String
    If Not DX.TryReadText("/DocumentInfo/DocumentInfo-FrontMatter", frontMatter) Then frontMatter = ""
    Select Case frontMatter
    Case ""
        Me.OptionButtonShowFrontMatter.value = True
    Case "Hide"
        Me.OptionButtonHideFrontMatter.value = True
    End Select
    
    
' PLY!
'    Case "Translation"
'        Me.OptionButtonShowTranslation.value = True
    If Not DX.GetFirstContentControlByTag("DocumentInfo-Translation") Is Nothing Then
        DX.GetTranslation
        DX.DoReadTranslation = False
    End If
    
    DX.WriteText "/DocumentInfo/DocumentInfo-FrontMatter", IIf(Me.OptionButtonShowFrontMatter.value = True, "", IIf(Me.OptionButtonHideFrontMatter.value = True, "Hide", "Translation"))
    
    Me.TextBoxWorkflowLabel = DX.ReadText("/DocumentInfo/DocumentInfo-WorkflowLabel")
    Me.TextBoxClassificationLabel = DX.ReadText("/DocumentInfo/DocumentInfo-ClassificationLabel")
    
    Me.TextBoxLine1 = DX.ReadText("/DocumentInfo/DocumentInfo-TitleLine1")
    Me.TextBoxLine2 = DX.ReadText("/DocumentInfo/DocumentInfo-TitleLine2")
    Me.TextBoxLine3 = DX.ReadText("/DocumentInfo/DocumentInfo-TitleLine3")
    Me.TextBoxLine4 = DX.ReadText("/DocumentInfo/DocumentInfo-TitleLine4")
    Me.TextBoxLine5 = DX.ReadText("/DocumentInfo/DocumentInfo-TitleLine5")
    Me.TextBoxDocNo = DX.ReadText("/DocumentInfo/DocumentInfo-DocNo")
    Me.TextBoxProjectNo = DX.ReadText("/DocumentInfo/DocumentInfo-ProjectNo")
    
    Me.TextBoxRevision = DX.ReadText("/DocumentInfo/DocumentInfo-Revision")
    If Me.TextBoxRevision = "" Then
        Me.TextBoxRevision = GetNewMajor("")
        Me.TextBoxDate = Format(Now, "YYYY-MM-DD")
        Me.TextBoxAuthor = UserName
    Else
        Me.TextBoxDate = DX.ReadText("/DocumentInfo/DocumentInfo-Date")
        Me.TextBoxAuthor = DX.ReadText("/DocumentInfo/DocumentInfo-Author")
        Me.TextBoxDescription = DX.ReadText("/DocumentInfo/DocumentInfo-Description")
    End If
    
    Me.TextBoxSupplierFileName = DX.ReadText("/DocumentInfo/DocumentInfo-SupplierFileName")
    
    Me.cmbPDFLayout.value = DX.ReadText("/DocumentInfo/DocumentInfo-PDFLayout")
    Me.cmbHeadingLayout.value = DX.ReadText("/DocumentInfo/DocumentInfo-HeadingLayout")
    
    Me.cmbHeadingLevels.text = DX.ReadText("/DocumentInfo/DocumentInfo-TOC-HeadingLevels")
    If Me.cmbHeadingLevels.text = "" Then
        Me.cmbHeadingLevels.text = "6"
        Me.CheckBoxIncludeParmHead = True
    Else
        Me.CheckBoxIncludeParmHead = (DX.ReadText("/DocumentInfo/DocumentInfo-TOC-Headings") > "")
    End If
    
    TOC = Me.cmbHeadingLevels.text & DX.ReadText("/DocumentInfo/DocumentInfo-TOC-Headings")
    
    Me.cmbDocType.text = DX.ReadText("/DocumentInfo/DocumentInfo-DocType")
    If Me.cmbDocType.text = "" Then Me.cmbDocType.text = "Project Document"
    Me.cmbMainDocType.text = mainDocType(cmbDocType.text)
    Me.TextBoxFrontPageInfo = DX.ReadText("/DocumentInfo/DocumentInfo-FrontPageInfo")
   
    Me.cmbCaptionHeading.text = DX.ReadText("/DocumentInfo/DocumentInfo-CaptionHeading")
    If Me.cmbCaptionHeading.text = "" Then
        Me.cmbCaptionHeading.text = "1"
        Me.CheckBoxFrontPage = True
        Me.CheckBoxTableOfContents = True
        Me.CheckBoxTableOfFigures = False
        Me.CheckBoxTableOfTables = False
        Me.CheckBoxDocumentInformation = True
        Me.CheckBoxTableOfRevisions = True
    Else
        Me.CheckBoxFrontPage = (DX.ReadText("/DocumentInfo/DocumentInfo-FrontPage") > "")
        Me.CheckBoxTableOfContents = (DX.ReadText("/DocumentInfo/DocumentInfo-TOC") > "")
        Me.CheckBoxTableOfFigures = (DX.ReadText("/DocumentInfo/DocumentInfo-TOF") > "")
        Me.CheckBoxTableOfTables = (DX.ReadText("/DocumentInfo/DocumentInfo-TOT") > "")
        Me.CheckBoxDocumentInformation = (DX.ReadText("/DocumentInfo/DocumentInfo-DocumentInformation") > "")
        Me.CheckBoxTableOfRevisions = (DX.ReadText("/DocumentInfo/DocumentInfo-RevisionHistory-Show") > "")
    End If
    
    
    ' Set Customer Logo in Form
    CompanyLogoPath = DX.ReadText("/DocumentInfo/DocumentInfo-CompanyLogo")
    NewCompanyLogoPath = CompanyLogoPath
    On Error Resume Next
    Set cc = ActiveDocument.SelectContentControlsByTag("DocumentInfo-CompanyLogo:FrontPageHeader")(1)
    On Error GoTo 0
    If Not cc Is Nothing Then
        If CompanyLogoPath > "" Then
            Dim clip As DataObject
            Dim hasStr As Boolean
            Set clip = New DataObject
            clip.GetFromClipboard
            If clip.GetFormat(1) Then
                str = clip.GetText
                hasStr = True
            End If
            
            If cc.Range.InlineShapes.Count > 0 Then
                cc.Range.InlineShapes(1).Range.CopyAsPicture
            End If
            ImageCompanyLogo.Picture = PastePicture()
            
            If hasStr Then
                 clip.SetText str
                 clip.PutInClipboard
            End If
            Set clip = Nothing
        End If
    End If
    ' Initialize Paper
    With cmbPaper
        .List = Array("A4 - Portrait", "Letter - Portrait", "A3 - Portrait", "Tabloid/Ledger - Portrait", _
                      "A4 - Landscape", "Letter - Landscape", "A3 - Landscape", "Tabloid/Ledger - Landscape")
        .AutoWordSelect = True
    End With
    cmbPaper.text = DX.GetPaperFormat
    
    ' Initalize languages
    Language = DX.ReadText("/DocumentInfo/DocumentInfo-Language")
    If Language = "" Then
        IsNewDoc = True
        Language = "2057"
    Else
        IsNewDoc = False
    End If
    listIndex = 1
    
    rows = UBound(aLanguages, 1)
    For i = 0 To rows - 1
        If aLanguages(i, 0) = Language Then
            listIndex = i
            Exit For
        End If
    Next
    
    With cmbLanguage
        .List = aLanguages
        .ListRows = rows + 1
        .listIndex = listIndex
        If rows > 25 Then .ListRows = 25
    End With

    With cmbHeadingLevels
        .List = Array("1", "2", "3", "4", "5", "6", "7", "8")
        .AutoWordSelect = True
    End With
    
    With cmbPDFLayout
        .List = Array("Standard", "Two Page Right")
        .AutoWordSelect = True
    End With
    
    With cmbHeadingLayout
        .List = Array("Standard", "Spare Parts Catalogue", "No Page Break", "No Numbering", "No Page Break")
        .AutoWordSelect = True
    End With
    
    With cmbWorkflowLabel
        .List = Array("", "Draft", "Reviewed", "Approved", "For translation") ', "Ready for Doc dept", "Ready for translation", "eDoc version", "Tracked changes")
        .AutoWordSelect = True
    End With
    
    With cmbClassificationLabel
        .List = Array("", "Secret", "Confidential", "Restricted", "Official", "Unclassified")
        .AutoWordSelect = True
    End With
    
    With cmbCaptionHeading
        .List = Array("1", "2", "3", "none")
        .AutoWordSelect = True
    End With
    
    DX.ReadRevisionHistory
    RevCount = DX.RevCount
    ReDim aRevHist(RevCount - 1, 4)
    aRevHist = DX.GetRevisionHistory
    
    InitializeDocType
    
    InChange = False
    
    If ActiveDocument.ReadOnly Then
        Dim ctrl As control
        For Each ctrl In Me.Controls
            ctrl.Enabled = False
        Next
        CommandButtonCancel.Enabled = True
        CommandButtonquickGuide.Enabled = True
        MultiPageMain.Enabled = True
        frameRevison.Enabled = True
        RevisionHistory.Enabled = True
    End If
    
End Sub

Public Sub InitializeDocType(Optional GetFirstForMainDocType As Boolean = False)
    Dim rows As Integer
    Dim rowsForType As Integer
    Dim aMainDocTypes() As String
    Dim newMainDocType As String
    Dim m As Integer
    Dim i As Integer
    m = 0
    rows = UBound(aDocumentTypes, 1)
    rowsForType = 0

    With cmbDocType
        ReDim aDocTypes(rows - 2)
        For i = 2 To rows
            If aDocumentTypes(i, 1) = cmbMainDocType.text Then
                aDocTypes(rowsForType) = aDocumentTypes(i, 0)
                rowsForType = rowsForType + 1
            End If
            newMainDocType = aDocumentTypes(i, 1)
            Dim iM As Integer
            For iM = 0 To m - 1
                If aMainDocTypes(iM) = newMainDocType Then
                    Exit For
                End If
            Next
            If iM = m Then 'new
                ReDim Preserve aMainDocTypes(m)
                aMainDocTypes(m) = newMainDocType
                m = m + 1
            End If
        Next
        ReDim Preserve aDocTypes(rowsForType - 1)
        .ListRows = rows - 1
        If rows - 1 > 25 Then .ListRows = 25
        .List = aDocTypes
        .AutoWordSelect = True
        If rowsForType = 1 Then
            .Visible = False
        Else
            .Visible = True
        End If
    End With
    
    With cmbMainDocType
        .List = aMainDocTypes
    End With
    
    If GetFirstForMainDocType And rowsForType > 1 Then
        cmbDocType.SetFocus
        cmbDocType.text = ""
        SendKeys "%{Down}"
    ElseIf GetFirstForMainDocType Then
        For i = 2 To rows
            If aDocumentTypes(i, 1) = cmbMainDocType.text Then
                cmbDocType.text = aDocumentTypes(i, 0)
                Exit For
            End If
        Next
    End If
    IsNewDoc = False
    
End Sub

Public Function mainDocType(DocType As String) As String
    Dim newMainDocType As String
    Dim rows As Integer
    Dim i As Integer
    rows = UBound(aDocumentTypes, 1)
    For i = 2 To rows
        If aDocumentTypes(i, 0) = DocType Then
            newMainDocType = aDocumentTypes(i, 1)
            Exit For
        End If
    Next
    mainDocType = newMainDocType
End Function

Attribute VB_Name = "MarkAsForm"
Attribute VB_Base = "0{5EFE6204-F158-4D2B-BC72-05623E3FD73F}{8C8F5021-1226-4F96-A8DA-8DF2E8C9ECC5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Dim bgd As BGDoc
Dim DX As DOCXML
Dim SaveAsForm As String
Dim addProp() As String

Public Sub DoOk()
    If SaveAsForm > "" Then
        bgd.SetFormName SaveAsForm
        bgd.SetSaveFileName Trim(TextBoxSaveFileName.text)
        bgd.SetSaveFolder Trim(TextBoxSaveFolder.text)
    Else
        bgd.SetFormName ""
    End If
    Set bgd = Nothing
    
    ' Save Properties
    
    DX.WriteText "/DocumentInfo/DocumentInfo-DocType", Trim(TextBoxDocType.text)
    
    DX.WriteText "/DocumentType/DocumentType-AdditionalProperties", Trim(TextBoxAdditionalProperties.text)
    DX.WriteText "/DocumentType/DocumentType-CalculatedProperties", Trim(TextBoxCalculatedProperties.text)
    DX.WriteText "/DocumentType/DocumentType-DocSearchTitle", Trim(TextBoxDocSearchTitle.text)
    DX.WriteText "/DocumentType/DocumentType-DocTitle", Trim(TextBoxDocTitle.text)
    DX.WriteText "/DocumentType/DocumentType-LockedProperties", Trim(TextBoxLockedProperties.text)
    DX.WriteText "/DocumentType/DocumentType-MandatoryProperties", Trim(TextBoxMandatoryProperties.text)
    DX.WriteText "/DocumentType/DocumentType-SaveFileName", Trim(TextBoxSaveFileName.text)
    DX.WriteText "/DocumentType/DocumentType-SaveFolder", Trim(TextBoxSaveFolder.text)
    DX.WriteText "/DocumentType/DocumentType-SharePointProperties", Trim(TextBoxSharePointProperties.text)
    DX.WriteText "/DocumentType/DocumentType-Subject", Trim(TextBoxSubject.text)
    DX.WriteText "/DocumentType/DocumentType-Title", Trim(TextBoxTitle.text)
    
    If ListBoxGoto.listIndex < 4 Then
        If DX.ThisDoc.Bookmarks.Exists("Start") Then
            DX.ThisDoc.Bookmarks("Start").Delete
        End If
        Dim rng As Range
        Select Case ListBoxGoto.listIndex
            Case 0 ' "Start of document"
            ' No bookmark
            
            Case 1 ' "Start of document text"
            Set rng = DX.GetDocumentRange
            rng.Collapse wdCollapseStart
            On Error Resume Next
            rng.Move wdCharacter, 1
            On Error GoTo 0
            DX.ThisDoc.Bookmarks.Add "Start", rng
            
            Case 2 ' "End of document"
            Set rng = ActiveDocument.Content
            rng.Collapse wdCollapseEnd
            DX.ThisDoc.Bookmarks.Add "Start", rng
            
            Case 3 ' "New Bookmark at current cursor"
            Set rng = DX.ThisDoc.Application.Selection.Range
            rng.Collapse wdCollapseStart
            DX.ThisDoc.Bookmarks.Add "Start", rng
            
        End Select
    End If
    
    
    Unload Me
End Sub

Public Sub DoCancel()
    Unload Me
End Sub

Private Sub UpdateTextFromCombo(cmb As control, tbox As control, Optional blocked As Boolean = True)
    Dim formulaLen As Integer
    Dim formulaStart As Integer
    
    Dim text As String
    text = cmb.text
    If blocked Then
        formulaLen = Len(text) + 4
    Else
        formulaLen = Len(text)
    End If
    formulaStart = tbox.SelStart
    
    If text > "" Then
        If blocked Then
            tbox.SelText = "[[" & text & "]]"
        Else
            tbox.SelText = text
        End If
        tbox.SelStart = formulaStart
        tbox.SelLength = formulaLen
    Else
        tbox.SelText = ""
        tbox.SelStart = formulaStart
        tbox.SelLength = 0
    End If
End Sub

Private Sub ComboBoxCalculatedProperties_Change()
    UpdateTextFromCombo ComboBoxCalculatedProperties, TextBoxCalculatedProperties
End Sub

Private Sub ComboBoxDocSearchTitle_Change()
    UpdateTextFromCombo ComboBoxDocSearchTitle, TextBoxDocSearchTitle
End Sub

Private Sub ComboBoxDocTitle_Change()
    UpdateTextFromCombo ComboBoxDocTitle, TextBoxDocTitle
End Sub

Private Sub ComboBoxFileNameField_Change()
    UpdateTextFromCombo ComboBoxFileNameField, TextBoxSaveFileName
End Sub

Private Sub ComboBoxFolderField_Change()
    UpdateTextFromCombo ComboBoxFolderField, TextBoxSaveFolder
End Sub

Private Sub ComboBoxLockedProperties_Change()
    UpdateTextFromCombo ComboBoxLockedProperties, TextBoxLockedProperties, False
End Sub

Private Sub ComboBoxMandatoryProperties_Change()
    UpdateTextFromCombo ComboBoxMandatoryProperties, TextBoxMandatoryProperties, False
End Sub

Private Sub ComboBoxSharePointProperties_Change()
    UpdateTextFromCombo ComboBoxSharePointProperties, TextBoxSharePointProperties
End Sub

Private Sub ComboBoxSubject_Change()
    UpdateTextFromCombo ComboBoxSubject, TextBoxSubject
End Sub

Private Sub ComboBoxSuggestedDocSearchTitle_Change()
    UpdateTextFromCombo ComboBoxSuggestedDocSearchTitle, TextBoxDocSearchTitle, False
End Sub

Private Sub ComboBoxSuggestedDocTitle_Change()
    UpdateTextFromCombo ComboBoxSuggestedDocTitle, TextBoxDocTitle, False
End Sub

Private Sub ComboBoxSuggestedSubject_Change()
    UpdateTextFromCombo ComboBoxSuggestedSubject, TextBoxSubject, False
End Sub

Private Sub ComboBoxSuggestedTitle_Change()
    UpdateTextFromCombo ComboBoxSuggestedTitle, TextBoxTitle, False
End Sub

Private Sub ComboBoxTitle_Change()
    UpdateTextFromCombo ComboBoxTitle, TextBoxTitle
End Sub

Private Sub CommandButtonCancel_Click()
    DoCancel
End Sub

Private Sub CommandButtonOk_Click()
    If Trim(TextBoxDocType) = "" Then
        MsgBox "Please give the form a telling name", vbOKOnly, "Missing name of form"
    ElseIf IsValidFileName(Trim(TextBoxDocType)) Then
        SaveAsForm = Trim(TextBoxDocType)
        DoOk
    Else
        MsgBox "Please give the form a name that is a valid filename", vbOKOnly, "Unfortunate name for the form"
    End If
End Sub
 
Private Sub CommandButtonRemove_Click()
    SaveAsForm = ""
    DoOk
End Sub

Private Sub TextBoxAdditionalProperties_Change()
    Dim result As String
    result = ""
    Dim aAP() As String
    Dim aP() As String
    
    Dim updated As Boolean
    updated = False
    
    Dim i As Integer
    Dim j As Integer
    
    aAP = Split(Trim(TextBoxAdditionalProperties.text), vbCrLf)
    If TextBoxAdditionalProperties = "" Then
        updated = True
    ElseIf (Not addProp) = -1 Then  ' Empty
        updated = True
    ElseIf UBound(aAP) <> UBound(addProp) Then
        updated = True
    Else
        For i = 0 To UBound(aAP)
            aP = Split(Trim(aAP(i)), "|")
            If aP(0) <> addProp(j) Then
                updated = True
            End If
        Next
    End If
    If updated Then
        Dim aNewProp() As String
        For i = 0 To UBound(aAP)
            aP = Split(Trim(aAP(i)), "|")
            For j = 0 To 0 'UBound(aP)
                If aAP(i) > "" Then
                    ReDim Preserve aNewProp(i)
                    aNewProp(i) = Trim(aP(0))
                    result = result & IIf(result > "", vbCrLf, "") & Trim(aP(0))
                End If
            Next
        Next
        addProp = aNewProp
    End If
    txtCalcResult.text = result
End Sub

Private Sub TextBoxCalculatedProperties_Change()
    txtCalcResult.text = CalculateMultiLineTitle(TextBoxCalculatedProperties.text, DX)
End Sub

Private Sub TextBoxCalculatedProperties_Enter()
    txtCalcResult.text = CalculateMultiLineTitle(TextBoxCalculatedProperties.text, DX)
End Sub

Private Sub TextBoxDocSearchTitle_Change()
    txtCalcResult.text = CalculateMultiLineTitle(TextBoxDocSearchTitle.text, DX)
End Sub

Private Sub TextBoxDocSearchTitle_Enter()
    txtCalcResult.text = CalculateMultiLineTitle(TextBoxDocSearchTitle.text, DX)
End Sub

Private Sub TextBoxDocTitle_Change()
    txtCalcResult.text = CalculateMultiLineTitle(TextBoxDocTitle.text, DX)
End Sub

Private Sub TextBoxDocTitle_Enter()
    txtCalcResult.text = CalculateMultiLineTitle(TextBoxDocTitle.text, DX)
End Sub

Private Sub TextBoxSaveFileName_Change()
    txtCalcResult.text = CalculateMultiLineTitle(TextBoxSaveFileName.text, DX)
End Sub

Private Sub TextBoxSaveFileName_Enter()
    txtCalcResult.text = CalculateMultiLineTitle(TextBoxSaveFileName.text, DX)
End Sub

Private Sub TextBoxSaveFolder_Change()
    txtCalcResult.text = CalculateMultiLineTitle(TextBoxSaveFolder.text, DX)
End Sub

Private Sub TextBoxSaveFolder_Enter()
    txtCalcResult.text = CalculateMultiLineTitle(TextBoxSaveFolder.text, DX)
End Sub

Private Sub TextBoxSharePointProperties_Change()
    txtCalcResult.text = CalculateMultiLineTitle(TextBoxSharePointProperties.text, DX)
End Sub

Private Sub TextBoxSharePointProperties_Enter()
    txtCalcResult.text = CalculateMultiLineTitle(TextBoxSharePointProperties.text, DX)
End Sub

Private Sub TextBoxSubject_Change()
    txtCalcResult.text = CalculateMultiLineTitle(TextBoxSubject.text, DX)
End Sub

Private Sub TextBoxSubject_Enter()
    txtCalcResult.text = CalculateMultiLineTitle(TextBoxSubject.text, DX)
End Sub

Private Sub TextBoxTitle_Change()
    txtCalcResult.text = CalculateMultiLineTitle(TextBoxTitle.text, DX)
End Sub

Private Sub TextBoxTitle_Enter()
    txtCalcResult.text = CalculateMultiLineTitle(TextBoxTitle.text, DX)
End Sub

Private Sub UserForm_Initialize()
    Set bgd = GetManager.Init.GetBGDoc(ActiveDocument)
    Set DX = New DOCXML
    DX.Init
End Sub

Private Sub UserForm_Layout()
    ' Read Form XML
    
    TextBoxDocType.text = DX.ReadText("/DocumentInfo/DocumentInfo-DocType")
    
    TextBoxAdditionalProperties.text = DX.ReadText("/DocumentType/DocumentType-AdditionalProperties")
    TextBoxCalculatedProperties.text = DX.ReadText("/DocumentType/DocumentType-CalculatedProperties")
    TextBoxDocSearchTitle.text = DX.ReadText("/DocumentType/DocumentType-DocSearchTitle")
    TextBoxDocTitle.text = DX.ReadText("/DocumentType/DocumentType-DocTitle")
    TextBoxLockedProperties.text = DX.ReadText("/DocumentType/DocumentType-LockedProperties")
    TextBoxMandatoryProperties.text = DX.ReadText("/DocumentType/DocumentType-MandatoryProperties")
    TextBoxSaveFileName.text = DX.ReadText("/DocumentType/DocumentType-SaveFileName")
    TextBoxSaveFolder.text = DX.ReadText("/DocumentType/DocumentType-SaveFolder")
    TextBoxSharePointProperties.text = DX.ReadText("/DocumentType/DocumentType-SharePointProperties")
    TextBoxSubject.text = DX.ReadText("/DocumentType/DocumentType-Subject")
    TextBoxTitle.text = DX.ReadText("/DocumentType/DocumentType-Title")
    
    
    SaveAsForm = bgd.FormName '(DV(DX.ThisDoc, "FormName") > "")
    TextBoxSaveFolder.text = Trim(bgd.SaveFolder)
    TextBoxSaveFileName.text = Trim(bgd.SaveFileName)
    
'    If SaveAsForm > "" Then
'        TextBoxDocType = SaveAsForm
'        lblQuestion.caption = "Already used as a form for new documents. Change path and file name or change to normal document?"
'    Else
'        lblQuestion.caption = "Use this document as a form for creating new documents?"
'    End If
 
    FillComboBoxes
    
    Dim fields() As String
    fields = Split("|[[ProjectNo]] - [[DocNo]], [[TitleLine1]] - [[TitleLine2]]|[[DocNo]], [[TitleLine3]] - [[TitleLine4]] - [[TitleLine5]]|[[DocNo]], [[TitleLine1]] - [[TitleLine2]] - [[TitleLine3]] - [[TitleLine4]]|[[TitleLine1]] - [[TitleLine2]] - [[TitleLine3]] - [[TitleLine4]] - [[TitleLine5]]", "|")
    FillComboBox ComboBoxSuggestedTitle, fields
    
    fields = Split("|[[TitleLine3]] - [[TitleLine4]] - [[TitleLine5]]|[[TitleLine1]] - [[TitleLine2]]|[[TitleLine5]]", "|")
    FillComboBox ComboBoxSuggestedSubject, fields
    
    fields = Split("|[[TitleLine1]] - [[TitleLine2]]|[[TitleLine3]] - [[TitleLine4]] - [[TitleLine5]]|[[TitleLine1]] - [[TitleLine2]] - [[TitleLine3]]|[[TitleLine4]] - [[TitleLine5]]", "|")
    FillComboBox ComboBoxSuggestedDocTitle, fields
    
    fields = Split("|[[ProjectNo]] - [[DocNo]], [[TitleLine1]] - [[TitleLine2]] - [[TitleLine3]] - [[TitleLine4]] - [[TitleLine5]]|[[ProjectNo]] - [[DocNo]], [[TitleLine3]] - [[TitleLine4]] - [[TitleLine5]] ([[TitleLine1]] - [[TitleLine2]])|[[DocNo]], [[TitleLine1]] - [[TitleLine2]] - [[TitleLine3]] - [[TitleLine4]]|[[TitleLine1]] - [[TitleLine2]], [[TitleLine3]] - [[TitleLine4]] - [[TitleLine5]]", "|")
    FillComboBox ComboBoxSuggestedDocSearchTitle, fields
    
    
    With ListBoxGoto
        If DX.ThisDoc.Bookmarks.Exists("Start") Then
            .List = Array("Start of document", "Start of document text", "End of document", "New Bookmark at current cursor", "Current Start bookmark")
            .listIndex = 4
        Else
            .List = Array("Start of document", "Start of document text", "End of document", "New Bookmark at current cursor")
            .listIndex = 0
        End If
    End With

End Sub

Private Sub FillComboBoxes()
    Dim fields() As String
    fields = Split(",Author,Date,DocNo,FormName,Language,LanguageCode,TitleLine1,TitleLine2,TitleLine3,TitleLine4,TitleLine5,MainProjectNo,ProjectNo,Revision,SupplierFileName", ",")
    
    FillComboBox ComboBoxLockedProperties, fields
    FillComboBox ComboBoxMandatoryProperties, fields
    FillComboBox ComboBoxFolderField, fields
    FillComboBox ComboBoxFileNameField, fields
    FillComboBox ComboBoxCalculatedProperties, fields
    FillComboBox ComboBoxSubject, fields
    FillComboBox ComboBoxTitle, fields
    FillComboBox ComboBoxDocTitle, fields
    FillComboBox ComboBoxDocSearchTitle, fields
    FillComboBox ComboBoxSharePointProperties, fields
End Sub

Private Sub FillComboBox(cmb As control, fields() As String)
    With cmb
        .List = fields
        .AutoWordSelect = True
    End With
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    If CloseMode = 0 Then 'Red X
        DoCancel
    End If
End Sub

Attribute VB_Name = "PictureTool"
Attribute VB_Base = "0{2018D1A3-725D-4025-84F2-70E0F6131403}{C174D914-8A13-4BCD-987A-D11C6B727439}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
    
Private PicRange As Range
Private bgpm As BGPictureManager
Private current As String
Private DoneLoad As Boolean
Private ActiveFilter As String

Private Embedded As Integer
Private EmbeddedAndLinked As Integer
Private MissingInDocumentAndOnDisk As Integer
Private MissingOnDisk As Integer
Private EditedOnDisk As Integer
Private LinkedOnly As Integer

Private DX As DOCXML

Public Sub DoClose()
    Set DX = Nothing
    Unload Me
End Sub

Private Sub cmdAll_Click()
    FillList "All"
End Sub

Private Sub cmdBreakLink_Click()
    Dim key As String
    If Not lstPictures.listIndex = -1 Then
        key = lstPictures.List(lstPictures.listIndex, 0)
        BreakLink key
    End If
End Sub

Private Sub cmdChangeToV_Click()
    Dim key As String
    If Not lstPictures.listIndex = -1 Then
        key = lstPictures.List(lstPictures.listIndex, 0)
        Dim bgp As BGPicture
        Set bgp = bgpm.GetBGPictures(key)
        
        Dim DX As New DOCXML
        DX.Init
        DX.Prolog "Change to V:"
        bgp.ChangePictureToV
        bgp.Read DX, True, True, True
        
        DX.updated = True
        DX.Epilog
        Set DX = Nothing
        
        FillList ActiveFilter, lstPictures.listIndex
    End If
End Sub

Private Sub cmdCheckAll_Click()
    Dim ok As Boolean
    ok = bgpm.Read(DX, True, False, False)
    RefillList
    
End Sub

Private Sub cmdClose_Click()
    DoClose
End Sub

Private Sub GotoPicture(key As String)
    current = key
    Dim bgp As BGPicture
    Set bgp = bgpm.GetBGPictures(current)
    If bgp.TypeOfPicture = InlineType Then
        bgp.InlineShape.Range.Select
        bgp.InlineShape.Range.Parent.ActiveWindow.ScrollIntoView bgp.Range
    Else
        bgp.Shape.Anchor.Select
        bgp.Shape.Anchor.Parent.ActiveWindow.ScrollIntoView bgp.Range
    End If
    Unload Me
End Sub


Private Sub cmdEditedOnDisk_Click()
    FillList "Edited"
End Sub

Private Sub cmdEditCancel_Click()
    Dim Name As String
    txtPath.text = txtBackupPath.text
    If InStr(txtPath.text, divider(True)) > 0 Then
        Name = Mid(txtPath, InStrRev(txtPath.text, divider(True)) + 1)
        txtName.text = Name
        txtDirectory.text = Left(txtPath.text, Len(txtPath.text) - 1 - Len(Name))
    Else
        txtDirectory.text = ""
        txtName.text = txtPath.text
    End If

End Sub

Private Sub cmdEditReplace_Click()
    Dim key As String
    If lstPictures.listIndex = -1 Then
        Exit Sub
    End If
    
    key = lstPictures.List(lstPictures.listIndex, 0)
    If txtPath.text = "" Then Exit Sub
    If Dir(txtPath.text) = "" Then Exit Sub
On Error GoTo Failed
    Dim DX As New DOCXML
    DX.Init
    DX.Prolog "Replace picture"
    
    Dim bgp As BGPicture
    Dim bgpDict As Scripting.Dictionary
    Set bgpDict = bgpm.GetBGPictures
    Set bgp = bgpDict(key)

    Dim fileName As String
    fileName = FixPath(txtPath.text)
   
    Dim inlSelect As InlineShape
    Dim shpSelect As Shape
    Dim rng As Range
    
    If bgp.ShapeType = "Inline" Then
        Set inlSelect = bgp.InlineShape
        Set rng = inlSelect.Range.Duplicate
        inlSelect.Delete
        rng.Select
        Set inlSelect = Selection.InlineShapes.AddPicture(fileName:=fileName, LinkToFile:=True, SaveWithDocument:=True, Range:=Selection.Range)
        With Selection
             .Expand Unit:=wdParagraph
             inlSelect.PictureFormat.ColorType = msoPictureAutomatic
             If inlSelect.Width > Selection.PageSetup.PageWidth - Selection.PageSetup.RightMargin - Selection.PageSetup.LeftMargin - 64.06 Then
                 inlSelect.LockAspectRatio = msoTrue
                 inlSelect.Width = Selection.PageSetup.PageWidth - Selection.PageSetup.RightMargin - Selection.PageSetup.LeftMargin - 64.06
             Else
                 inlSelect.LockAspectRatio = msoTrue
             End If
             If Selection.Information(wdWithInTable) Then
                 If inlSelect.Width > Selection.Cells(1).Width Then
                     inlSelect.LockAspectRatio = msoTrue
                     inlSelect.Width = Selection.Cells(1).Width
                 End If
             End If
             .Collapse Direction:=wdCollapseEnd
        End With
        Set bgp.InlineShape = inlSelect
        Set bgp.Range = inlSelect.Range
        bgp.RangeStart = inlSelect.Range.start
        bgp.RangeEnd = inlSelect.Range.End
        inlSelect.Select
    Else
        Set shpSelect = bgp.Shape
        Set rng = shpSelect.Anchor.Duplicate
        shpSelect.Delete
        rng.Select
        Set shpSelect = Selection.InlineShapes.AddPicture(fileName:=fileName, LinkToFile:=True, SaveWithDocument:=True, Range:=Selection.Range).ConvertToShape
        With Selection
             .Expand Unit:=wdParagraph
             shpSelect.PictureFormat.ColorType = msoPictureAutomatic
             If shpSelect.Width > Selection.PageSetup.PageWidth - Selection.PageSetup.RightMargin - Selection.PageSetup.LeftMargin - 64.06 Then
                 shpSelect.LockAspectRatio = msoTrue
                 shpSelect.Width = Selection.PageSetup.PageWidth - Selection.PageSetup.RightMargin - Selection.PageSetup.LeftMargin - 64.06
             Else
                 shpSelect.LockAspectRatio = msoTrue
             End If
             If Selection.Information(wdWithInTable) Then
                 If shpSelect.Width > Selection.Cells(1).Width Then
                     shpSelect.LockAspectRatio = msoTrue
                     shpSelect.Width = Selection.Cells(1).Width
                 End If
             End If
             .Collapse Direction:=wdCollapseEnd
        End With
        Set bgp.Shape = shpSelect
        Set bgp.Range = shpSelect.Anchor
        bgp.RangeStart = shpSelect.Anchor.start
        bgp.RangeEnd = shpSelect.Anchor.End
        shpSelect.Select
    End If
    
    bgp.Read DX, True, True, True
    FillList ActiveFilter, lstPictures.listIndex
    
    DX.updated = True
ExitSub:
    On Error GoTo 0
    If Not DX Is Nothing Then
        DX.Epilog
        Set DX = Nothing
    End If
    
    Exit Sub
Failed:
    If Not DX Is Nothing Then DX.updated = False
    Resume ExitSub
End Sub

Private Sub cmdEmbeddded_Click()
    FillList "Embedded"
End Sub

Private Sub cmdEmbeddedAndLinked_Click()
    FillList "Embedded and linked"
End Sub

Private Sub cmdGoToPicture_Click()
    Dim key As String
    If Not lstPictures.listIndex = -1 Then
        key = lstPictures.List(lstPictures.listIndex, 0)
    End If
    GotoPicture key
End Sub

Private Sub cmdLinkedOnly_Click()
    FillList "Linked only!"
End Sub

Private Sub cmdMissingInDocumentAndOnDisk_Click()
    FillList "Missing in document and on disk!"
End Sub

Private Sub cmdMissingOnDisk_Click()
    FillList "Missing on disk!"
End Sub

Private Sub cmdRefreshAll_Click()
    Dim bgp As BGPicture
    Dim key As String
    Dim bgpColl As Scripting.Dictionary
    Set bgpColl = bgpm.GetBGPictures
    
    Dim i As Integer
    For i = 0 To lstPictures.ListCount - 1
        key = lstPictures.List(i, 0)
        Set bgp = bgpColl(key)
        If bgp.Disk Like "Edited*" Or bgp.Disk = "Embedded and linked" Then
            RefreshFromDisk key
        End If
    Next
End Sub

Private Sub cmdRefreshEdited_Click()
    Dim bgp As BGPicture
    Dim key As String
    Dim bgpColl As Scripting.Dictionary
    Set bgpColl = bgpm.GetBGPictures
    
    Dim i As Integer
    For i = 0 To lstPictures.ListCount - 1
        key = lstPictures.List(i, 0)
        Set bgp = bgpColl(key)
        If bgp.Disk Like "Edited*" Then
            RefreshFromDisk key
        End If
    Next
End Sub

Private Sub cmdRefreshFromDisk_Click()
    Dim key As String
    If Not lstPictures.listIndex = -1 Then
        key = lstPictures.List(lstPictures.listIndex, 0)
        RefreshFromDisk key

    End If
End Sub

Public Sub BreakLink(key As String)
On Error GoTo Failed
    Dim DX As New DOCXML
    DX.Init
    DX.Prolog "Break Link"
    
    Dim bgp As BGPicture
    Dim bgpDict As Scripting.Dictionary
    Set bgpDict = bgpm.GetBGPictures
    Set bgp = bgpDict(key)
    
    Dim inlSelect As InlineShape
    Dim shpSelect As Shape

    bgp.BreakLink

'    If bgp.ShapeType = "Inline" Then
'        Set inlSelect = bgp.InlineShape
'        If Not inlSelect.LinkFormat Is Nothing Then
'            inlSelect.LinkFormat.BreakLink
'        End If
'    Else
'        Set shpSelect = bgp.Shape
'        If Not shpSelect.LinkFormat Is Nothing Then
'            shpSelect.LinkFormat.BreakLink
'        End If
'    End If
    
    bgp.Read DX, True, True, True
    FillList ActiveFilter, lstPictures.listIndex
    
    DX.updated = True
ExitSub:
    On Error GoTo 0
    If Not DX Is Nothing Then
        DX.Epilog
        Set DX = Nothing
    End If
    
    Exit Sub
Failed:
    If Not DX Is Nothing Then DX.updated = False
    Resume ExitSub
End Sub

Public Sub RefreshFromDisk(key As String)
On Error GoTo Failed
    Dim DX As New DOCXML
    DX.Init
    DX.Prolog "Refresh Picture From Disk"
    
    Dim bgp As BGPicture
    Dim bgpDict As Scripting.Dictionary
    Set bgpDict = bgpm.GetBGPictures
    Set bgp = bgpDict(key)
    
    Dim inlSelect As InlineShape
    Dim shpSelect As Shape

    If bgp.ShapeType = "Inline" Then
        Set inlSelect = bgp.InlineShape
        If Not inlSelect.LinkFormat Is Nothing Then
            inlSelect.LinkFormat.Update
            inlSelect.AlternativeText = UpdateAlternativeText(inlSelect.AlternativeText, "Updated")
        End If
    Else
        Set shpSelect = bgp.Shape
        If Not shpSelect.LinkFormat Is Nothing Then
            shpSelect.LinkFormat.Update
            shpSelect.AlternativeText = UpdateAlternativeText(shpSelect.AlternativeText, "Updated")
        End If
    End If
    
    bgp.Read DX, True, True, True
    FillList ActiveFilter, lstPictures.listIndex

    DX.updated = True
ExitSub:
    On Error GoTo 0
    If Not DX Is Nothing Then
        DX.Epilog
        Set DX = Nothing
    End If
    
    Exit Sub
Failed:
    If Not DX Is Nothing Then DX.updated = False
    Resume ExitSub
End Sub

Private Sub cmdReplace_Click()
'    MsgBox "Not yet implemented"
'    Exit Sub
    

    Dim key As String
    If lstPictures.listIndex = -1 Then
        Exit Sub
    End If
    
    key = lstPictures.List(lstPictures.listIndex, 0)
    
On Error GoTo Failed
    Dim DX As New DOCXML
    DX.Init
    DX.Prolog "Replace picture"
    
    Dim bgp As BGPicture
    Dim bgpDict As Scripting.Dictionary
    Set bgpDict = bgpm.GetBGPictures
    Set bgp = bgpDict(key)

    Dim fileName As String
    With Dialogs(wdDialogInsertPicture)
        .Display
        If .Name <> "" Then
           fileName = .Name
           fileName = FixPath(fileName)
           
            Dim inlSelect As InlineShape
            Dim shpSelect As Shape
            Dim rng As Range
            
            If bgp.ShapeType = "Inline" Then
                Set inlSelect = bgp.InlineShape
                Set rng = inlSelect.Range.Duplicate
                inlSelect.Delete
                rng.Select
                Set inlSelect = Selection.InlineShapes.AddPicture(fileName:=fileName, LinkToFile:=True, SaveWithDocument:=True, Range:=Selection.Range)
                With Selection
                     .Expand Unit:=wdParagraph
                     inlSelect.PictureFormat.ColorType = msoPictureAutomatic
                     If inlSelect.Width > Selection.PageSetup.PageWidth - Selection.PageSetup.RightMargin - Selection.PageSetup.LeftMargin - 64.06 Then
                         inlSelect.LockAspectRatio = msoTrue
                         inlSelect.Width = Selection.PageSetup.PageWidth - Selection.PageSetup.RightMargin - Selection.PageSetup.LeftMargin - 64.06
                     Else
                         inlSelect.LockAspectRatio = msoTrue
                     End If
                     If Selection.Information(wdWithInTable) Then
                         If inlSelect.Width > Selection.Cells(1).Width Then
                             inlSelect.LockAspectRatio = msoTrue
                             inlSelect.Width = Selection.Cells(1).Width
                         End If
                     End If
                     .Collapse Direction:=wdCollapseEnd
                End With
                Set bgp.InlineShape = inlSelect
                Set bgp.Range = inlSelect.Range
                bgp.RangeStart = inlSelect.Range.start
                bgp.RangeEnd = inlSelect.Range.End
                inlSelect.Select
            Else
                Set shpSelect = bgp.Shape
                Set rng = shpSelect.Anchor.Duplicate
                shpSelect.Delete
                rng.Select
                Set shpSelect = Selection.InlineShapes.AddPicture(fileName:=fileName, LinkToFile:=True, SaveWithDocument:=True, Range:=Selection.Range).ConvertToShape
                With Selection
                     .Expand Unit:=wdParagraph
                     shpSelect.PictureFormat.ColorType = msoPictureAutomatic
                     If shpSelect.Width > Selection.PageSetup.PageWidth - Selection.PageSetup.RightMargin - Selection.PageSetup.LeftMargin - 64.06 Then
                         shpSelect.LockAspectRatio = msoTrue
                         shpSelect.Width = Selection.PageSetup.PageWidth - Selection.PageSetup.RightMargin - Selection.PageSetup.LeftMargin - 64.06
                     Else
                         shpSelect.LockAspectRatio = msoTrue
                     End If
                     If Selection.Information(wdWithInTable) Then
                         If shpSelect.Width > Selection.Cells(1).Width Then
                             shpSelect.LockAspectRatio = msoTrue
                             shpSelect.Width = Selection.Cells(1).Width
                         End If
                     End If
                     .Collapse Direction:=wdCollapseEnd
                End With
                Set bgp.Shape = shpSelect
                Set bgp.Range = shpSelect.Anchor
                bgp.RangeStart = shpSelect.Anchor.start
                bgp.RangeEnd = shpSelect.Anchor.End
                shpSelect.Select
            End If
           
        End If
    End With
    
    bgp.Read DX, True, True, True
    FillList ActiveFilter, lstPictures.listIndex

    
    DX.updated = True
ExitSub:
    On Error GoTo 0
    If Not DX Is Nothing Then
        DX.Epilog
        Set DX = Nothing
    End If
    
    Exit Sub
Failed:
    If Not DX Is Nothing Then DX.updated = False
    Resume ExitSub
End Sub

Private Sub cmdSaveACopy_Click()
    Dim key As String
    If Not lstPictures.listIndex = -1 Then
        key = lstPictures.List(lstPictures.listIndex, 0)
        SaveToDisk key, False
    End If
End Sub

Private Sub cmdSaveAndUpdateLink_Click()
'    MsgBox "Not yet working"
'    Exit Sub
    Dim key As String
    If Not lstPictures.listIndex = -1 Then
        key = lstPictures.List(lstPictures.listIndex, 0)
        SaveToDisk key, True
    End If
End Sub

Private Sub lstPictures_Change()
    Dim key As String
    If Not lstPictures.listIndex = -1 Then
        key = lstPictures.List(lstPictures.listIndex, 0)
        ShowPicture key
    End If
End Sub

Private Sub lstPictures_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    Dim key As String
    If Not lstPictures.listIndex = -1 Then
        key = lstPictures.List(lstPictures.listIndex, 0)
    End If
    GotoPicture key
End Sub

Private Function IsActive(controlName As String) As Boolean
    If Me.ActiveControl Is Nothing Then
        IsActive = False
        Exit Function
    End If
    Dim ctl As control
    Set ctl = ActiveControl
    Do While TypeOf ctl Is MSForms.Frame
       Set ctl = ctl.ActiveControl
    Loop
    IsActive = (controlName = ctl.Name)
End Function

Private Function divider(Optional full As Boolean = False) As String
    Dim check As String
    check = txtDirectory.text
    If full Then
        check = txtPath.text
    End If
    
    If InStr(check, "/") > 0 Then
        divider = "/"
    Else
        divider = "\"
    End If
End Function

Private Sub txtDirectory_Change()
    If IsActive(txtDirectory.Name) Then
        txtPath = txtDirectory.text & divider() & txtName.text
        'Debug.Print txtDirectory.text
    End If
End Sub

Private Sub txtName_Change()
    If IsActive(txtName.Name) Then
        txtPath = txtDirectory.text & divider() & txtName.text
        'Debug.Print txtName.text
    End If
End Sub

Private Sub txtPath_Change()
    If IsActive(txtPath.Name) Then
        Dim Name As String
        If InStr(txtPath.text, divider(True)) > 0 Then
            Name = Mid(txtPath, InStrRev(txtPath.text, divider(True)) + 1)
            txtName.text = Name
            txtDirectory.text = Left(txtPath.text, Len(txtPath.text) - 1 - Len(Name))
        Else
            txtDirectory.text = ""
            txtName.text = txtPath.text
        End If
        'Debug.Print txtPath.text
    End If
    Dim bgp As BGPicture
    Set bgp = bgpm.GetBGPictures(current)
    ShowCommands bgp
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    If CloseMode = 0 Then 'Red X
        DoClose
    End If
End Sub

Private Sub UserForm_Initialize()
    Set DX = New DOCXML
    DX.Init
    
    Application.ScreenUpdating = False
    Set bgpm = New BGPictureManager
    DoneLoad = False
    StopTimer = False
    Reschedule = True ' Run only once
    If Selection.Range.InlineShapes.Count > 0 Or Selection.Range.ShapeRange.Count > 0 Then
        Init DX, Selection.Range
    Else
        Init DX
    End If
    DoEvents
    Dim ok As Boolean
    ok = bgpm.Read(DX, False, False, False)
    ' RefillList
    Application.ScreenUpdating = True
    
End Sub

Private Sub UserForm_Terminate()
    StopTimer = True
    Set TimerForm = Nothing
    Application.OnTime Now, "bg_FormTimers.PictureToolOnTimer"
End Sub

Private Sub ScheduleNextTrigger()
    Application.OnTime Now + TimeValue("00:00:01"), "bg_FormTimers.PictureToolOnTimer"
End Sub

'Public Sub OnTimer()
'    Debug.Print Now, StopTimer, Reschedule
'    If Not StopTimer Then
'    ''//... Trigger whatever task you want here
'        Debug.Print "My actions"
'        If DoneLoad Then
'            Dim ok As Boolean
'            ok = BGPM.Read(DX, True, False, False)
'
'            RefillList
'
'            'Me.cmdAll.caption = UTCTIME(Now)
'            'Me.Repaint
'            'Me.Hide
'            StopTimer = True
'            Reschedule = False
'            'Me.Show vbModal
'        End If
'        DoEvents
'    ''//Then schedule it to run again
'        If Reschedule Then
'            ScheduleNextTrigger
'        End If
'    End If
'End Sub

Public Function Init(DX As DOCXML, Optional rng As Range = Nothing) As Integer
    On Error Resume Next
    ActiveWindow.View.ShowFieldCodes = False
    On Error GoTo 0
    
    Dim ok As Boolean
    If rng Is Nothing Then
        Set PicRange = ActiveDocument.Content
    Else
        Set PicRange = rng
    End If
    
    ok = bgpm.ReadRange(PicRange, DX)
    If ok Then
        ok = bgpm.ReadInfo(DX)
        If ok Then
            ok = bgpm.Read(DX, False, True, True)
        End If
    End If

    FillList
    
    DoneLoad = True
    
    If ActiveDocument.ReadOnly Then
        cmdBreakLink.Enabled = False
        cmdChangeToV.Enabled = False
        cmdCheckAll.Enabled = False
        cmdRefreshAll.Enabled = False
        cmdRefreshEdited.Enabled = False
        cmdRefreshFromDisk.Enabled = False
        cmdReplace.Enabled = False
        cmdSaveAndUpdateLink.Enabled = False
    End If
    
    
    Init = bgpm.GetBGPictures.Count
    
End Function

Private Sub ShowCommands(bgp As BGPicture)
    If txtPath.text = txtBackupPath.text Then
        cmdEditReplace.Visible = False
        cmdEditCancel.Visible = False
        If UCase(bgp.SourcePath) Like "L:*" Then
            cmdChangeToV.Visible = True
        Else
            cmdChangeToV.Visible = False
        End If
        If bgp.Disk = "Missing in document and on disk!" Then
            cmdBreakLink.Visible = False
            cmdRefreshFromDisk.Visible = False
            cmdReplace.Visible = False
            cmdSaveACopy.Visible = False
            cmdSaveAndUpdateLink.Visible = False
        ElseIf bgp.Disk = "Missing on disk!" Then
            cmdBreakLink.Visible = True
            cmdRefreshFromDisk.Visible = False
            cmdReplace.Visible = True
            cmdSaveACopy.Visible = True
            cmdSaveAndUpdateLink.Visible = True
        Else
            cmdReplace.Visible = True
            cmdSaveACopy.Visible = True
            cmdSaveAndUpdateLink.Visible = True
            If bgp.IsLinked Then
                cmdBreakLink.Visible = True
                cmdRefreshFromDisk.Visible = True
            Else
                cmdBreakLink.Visible = False
                cmdRefreshFromDisk.Visible = False
            End If
        End If
    Else
        cmdBreakLink.Visible = False
        cmdRefreshFromDisk.Visible = False
        cmdReplace.Visible = False
        cmdSaveACopy.Visible = False
        cmdSaveAndUpdateLink.Visible = False
        cmdEditReplace.Visible = True
        cmdEditCancel.Visible = True
        cmdChangeToV.Visible = False
    End If
End Sub

Private Sub ShowPicture(key As String, Optional GetPicture As Boolean = False)
    Dim bgp As BGPicture
    current = key
    Dim bgpDict As Scripting.Dictionary
    Set bgpDict = bgpm.GetBGPictures
    Set bgp = bgpDict(current)
    Me.txtName = bgp.SourceName
    Me.txtDirectory = bgp.SourcePath
    Me.txtPath = bgp.sourceFullName
    Me.txtBackupPath = bgp.sourceFullName
    
    If bgp.Disk Like "*Not checked" Then
        bgp.Read DX, True, False, False
        Me.lstPictures.List(lstPictures.listIndex, 4) = bgp.Disk
    End If
    
    If bgp.caption > "" Then
        framePictureInfo.caption = bgp.caption
    Else
        framePictureInfo.caption = "Picture on page " & bgp.page
    End If
    
    If bgp.ShapeType = "Inline" Then
        If Not bgp.Range Is Nothing Then
            bgp.Range.CopyAsPicture
            Me.imgPicture.Picture = PastePicture()
        End If
    ElseIf bgp.ShapeType = "Shape" Then
        bgp.Shape.Select
        Selection.CopyAsPicture
        Me.imgPicture.Picture = PastePicture()
    End If
    ShowCommands bgp
   
End Sub

Public Sub FillList(Optional filterName As String = "All", Optional Index As Integer = 0)
    Dim show As Boolean
    Dim shapeTypeText As String
    Dim caption As String
    Dim page As String
    Dim bgp As BGPicture
    Dim key As Variant
    Dim bgpColl As Scripting.Dictionary
    Dim i As Integer
    i = 0
    Set bgpColl = bgpm.GetBGPictures
    Me.lstPictures.Clear
    For Each key In bgpColl.Keys
        show = False
        Set bgp = bgpColl(key)
        If bgp.IsPictureOrObject Then
            If bgp.Disk = "Linked only!" Then
                bgp.Disk = "Embedded and linked"
                bgp.SavePictureWithDocument = True
                If bgp.ShapeType = "Shape" Then
                    bgp.Shape.LinkFormat.SavePictureWithDocument = True
                Else
                    bgp.InlineShape.LinkFormat.SavePictureWithDocument = True
                End If
                LinkedOnly = LinkedOnly - 1
                EmbeddedAndLinked = EmbeddedAndLinked + 1
            End If
            If filterName = "All" Then
                show = True
            Else
                Select Case filterName
                    Case "Embedded", "Embedded and linked", "Missing on disk!", "Missing in document and on disk!", "Linked only!"
                        If bgp.Disk = filterName Then
                            show = True
                        End If
                    Case Else
                        If bgp.Disk Like filterName & "*" Then
                            show = True
                        End If
                End Select
            End If
            If show Then
                page = "   " & bgp.page
                If bgp.page > 9 Then page = " " & bgp.page
                If bgp.page > 99 Then page = bgp.page
                If bgp.caption > "" Then
                    caption = bgp.caption
                Else
                    caption = bgp.SourceName
                End If
                lstPictures.AddItem bgp.key
                lstPictures.List(i, 1) = page
                lstPictures.List(i, 2) = caption
                lstPictures.List(i, 3) = bgp.ShapeType
                lstPictures.List(i, 4) = bgp.Disk
                i = i + 1
            End If
        End If
    Next
    ActiveFilter = filterName
    If lstPictures.ListCount > 0 Then lstPictures.listIndex = Index
End Sub

Public Sub RefillList()
    Dim bgp As BGPicture
    Dim key As Variant
    Dim bgpColl As Scripting.Dictionary
    Set bgpColl = bgpm.GetBGPictures
    
    Dim i As Integer
    For i = 0 To lstPictures.ListCount - 1
        key = lstPictures.List(i, 0)
        Set bgp = bgpColl(key)
        lstPictures.List(i, 4) = bgp.Disk
        Select Case bgp.Disk
        Case "Embedded"
            Embedded = Embedded + 1
        Case "Embedded and linked"
            EmbeddedAndLinked = EmbeddedAndLinked + 1
        Case "Missing on disk!"
            MissingOnDisk = MissingOnDisk + 1
        Case "Linked only!"
            LinkedOnly = LinkedOnly + 1
        Case "Missing in document and on disk!"
            MissingInDocumentAndOnDisk = MissingInDocumentAndOnDisk + 1
        Case Else
            If bgp.Disk Like "Edited*" Then
                EditedOnDisk = EditedOnDisk + 1
            End If
        End Select
    Next
    FillList "All"
    ShowOrHideFilters
End Sub

Private Sub ShowOrHideFilters()
    If Embedded > 0 Then cmdEmbeddded.Visible = True Else cmdEmbeddded.Visible = False
    If EmbeddedAndLinked > 0 Then cmdEmbeddedAndLinked.Visible = True Else cmdEmbeddedAndLinked.Visible = False
    If MissingOnDisk > 0 Then cmdMissingOnDisk.Visible = True Else cmdMissingOnDisk.Visible = False
    If LinkedOnly > 0 Then cmdLinkedOnly.Visible = True Else cmdLinkedOnly.Visible = False
    If MissingInDocumentAndOnDisk > 0 Then cmdMissingInDocumentAndOnDisk.Visible = True Else cmdMissingInDocumentAndOnDisk.Visible = False
    If EditedOnDisk > 0 Then
        cmdEditedOnDisk.Visible = True
        cmdRefreshEdited.Visible = True
    Else
        cmdRefreshEdited.Visible = False
        cmdEditedOnDisk.Visible = False
    End If
    If EmbeddedAndLinked + MissingInDocumentAndOnDisk + MissingOnDisk + LinkedOnly + EditedOnDisk > 0 Then
        cmdRefreshAll.Visible = True
        cmdCheckAll.Visible = True
        lblActions.Visible = True
    Else
        cmdRefreshAll.Visible = False
        cmdCheckAll.Visible = False
        lblActions.Visible = False
    End If
End Sub


Public Sub SaveToDisk(key As String, UpdateFileLocation As Boolean)
    Dim DX As New DOCXML
    DX.Init
    
    Dim bgp As BGPicture
    Dim bgpDict As Scripting.Dictionary
    Set bgpDict = bgpm.GetBGPictures
    Set bgp = bgpDict(key)
    
    Dim Addin As Object
    Dim fullFileName As String
    Dim folder As String
    Dim fileName As String
    If bgp.SourcePath > "" Then folder = bgp.SourcePath
    If bgp.SourceName > "" Then fileName = bgp.SourceName
    
'    Dim obj As Object
'    Set Addin = GetAutomationObject()
    
'    If Not Addin Is Nothing Then
'        If bgp.ShapeType = "Inline" Then
'            Set obj = bgp.InlineShape
'        Else
'            Set obj = bgp.Shape
'        End If
'        fullFileName = Addin.SavePictureToDisk(bgp.ShapeType, obj, folder, fileName)
'        'fullFileName = "\\beumer.com\public\HomeDirs\Sub\Denmark\AAR\ply\My Pictures\T1.jpg"
'        If fullFileName > "" Then
'            fullFileName = FixPath(fullFileName)
'        End If
'    Else
        Dim strTempFile As String
        Dim ext As String
        strTempFile = bgp.WriteToTemporaryPictureFile()
        ext = Mid(strTempFile, InStrRev(strTempFile, ".") + 1)

        Dim strFilter As String
        Dim lngFlags As Long
        Dim defaultFileName As String
        If fileName > "" Then defaultFileName = Mid(fileName, 1, InStrRev(fileName, ".") - 1) & "." & ext
        
        strFilter = ahtAddFilterItem(strFilter, UCase(ext) & " Files (*." & ext & ")", "*." & UCase(ext) & "")
        Dim result As Variant
        
        ActiveWindowHandle = GetActiveWindow
        fullFileName = ahtCommonFileOpenSave(fileName:=defaultFileName, InitialDir:=folder, Filter:=strFilter, FilterIndex:=1, flags:=lngFlags, DialogTitle:="Save picture", OpenFile:=False)
        If fullFileName > "" Then
            fullFileName = FixPath(fullFileName)
            FileCopy strTempFile, fullFileName
            bgp.KillFilesAndFolder strTempFile
        End If
 '   End If
    
    If Not UpdateFileLocation Or fullFileName = "" Then Exit Sub
    bgp.Range.Select
    
    Dim inl As InlineShape
    Dim shp As Shape
    
On Error GoTo Failed
    DX.Prolog "Save Picture To Disk and Update"
    Dim rngInsert As Range
    Dim rng As Range
    If bgp.TypeOfPicture = PictureType.InlineType Then
        Set inl = bgp.InlineShape
        Set rngInsert = inl.Range.Duplicate
        inl.Range.Delete
        Set inl = rngInsert.InlineShapes.AddPicture(fullFileName, True, True, rngInsert)
        Set rng = inl.Range.Duplicate
        Set bgp.InlineShape = inl
        Set bgp.Range = inl.Range
        bgp.RangeStart = inl.Range.start
        bgp.RangeEnd = inl.Range.End
    ElseIf bgp.TypeOfPicture = PictureType.ShapeType Then
        Set shp = bgp.Shape
        Set rngInsert = shp.Anchor.Duplicate
        shp.Anchor.Delete
        Set inl = rngInsert.InlineShapes.AddPicture(fullFileName, True, True, rngInsert)
        Set shp = inl.ConvertToShape
        Set bgp.Shape = shp
        Set bgp.Range = shp.Anchor
        Set rng = shp.Anchor.Duplicate
        bgp.RangeStart = shp.Anchor.start
        bgp.RangeEnd = shp.Anchor.End
    End If

    bgp.ReApplyFormat

'    If bgp.ShapeType = "Inline" Then
'        Set inlSelect = bgp.InlineShape
'        inlSelect.Delete
'
'    Else
'        Dim anchorRange As Range
'        Dim dTop As Double
'        Dim dLeft As Double
'        Dim dHeight As Double
'        Dim dWidth As Double
'        Set shpSelect = bgp.Shape
'        With Document.Shapes(i)
'            .RelativeHorizontalPosition = Microsoft.Office.Interop.Word.WdRelativeHorizontalPosition.wdRelativeHorizontalPositionPage
'            dTop = .Top
'            dLeft = .Left
'            dHeight = .Height
'            dWidth = .Width
'            anchorRange = .Anchor.Duplicate
'            .Delete
'        End With
'
'        Set Shape = Document.Shapes.AddPicture(FileName:=sPathPicture, _
'            SaveWithDocument:=True, _
'            Left:=dLeft - Document.PageSetup.LeftMargin, _
'            Top:=dTop, _
'            Width:=dWidth, _
'            Height:=dHeight, _
'            Anchor:=anchorRange)
'
'    End If
    
    bgp.Read DX, True, False, False
    FillList ActiveFilter, lstPictures.listIndex
    DX.updated = True
ExitSub:
    On Error GoTo 0
    If Not DX Is Nothing Then
        DX.Epilog
        Set DX = Nothing
    End If
    
    Exit Sub
Failed:
    If Not DX Is Nothing Then DX.updated = False
    Resume ExitSub
End Sub

'Private Sub SavePicture()
'    If Doc.FullName <> Doc.name Then
'        Application.FileDialog(msoFileDialogSaveAs).InitialFileName = Doc.path & IIf(InStr(Doc.FullName, "\") > 0, "\", "/")
'    Else
'        Dim FileSaveAsSetting As String
'        FileSaveAsSetting = Dialogs(wdDialogToolsOptionsFileLocations).Setting
'        If Not Right$(FileSaveAsSetting, 1) = "\" And Not Right$(FileSaveAsSetting, 1) = "/" Then
'            FileSaveAsSetting = FileSaveAsSetting + IIf(InStr(FileSaveAsSetting, "\") > 0, "\", "/")
'        End If
'
'        Application.FileDialog(msoFileDialogSaveAs).InitialFileName = FileSaveAsSetting
'    End If
'
'    Application.FileDialog(msoFileDialogSaveAs).Title = ""
'    Application.FileDialog(msoFileDialogSaveAs).ButtonName = ""
'    Application.FileDialog(msoFileDialogSaveAs).FilterIndex = 1
'
'    Dim choice As Integer
'    choice = Application.FileDialog(msoFileDialogSaveAs).show
'    If choice <> 0 Then
'        FileName = FixPath(Application.FileDialog(msoFileDialogSaveAs).SelectedItems(1))
'    End If
'End Sub

'Public Sub UpdateImages(ByRef convertCount As Integer, ByRef errorConvertCount As Integer)
'        For i As Integer = BPictures.Count - 1 To 0 Step -1
'            Dim bPic As BPicture = BPictures(i)
'            Dim bPicSaved As BPicture = BPicturesSaved(i)
'            If Not bPicSaved.Missing Then
'                Dim rng As Range
'                Dim tempBPic As BPicture = Nothing
'                rng = RemoveImage(BPictures(i))
'                If rng Is Nothing Then Continue For
'                tempBPic = DummyImage(bPic, BPicturesSaved(i).FoundFile)
'                InsertImage(rng, tempBPic, BPicturesSaved(i))
'                convertCount += 1
'            Else
'                errorConvertCount += 1
'            End If
'        Next
'    End Sub
'
'
'   Public Function SaveImage(bPic As BPicture, Optional path As String = "") As BPicture
'        Dim filterIndex As Integer = 0
'        Dim format As Imaging.ImageFormat = Nothing
'
'        If bPic.Image Is Nothing Then
'            Return Nothing
'        End If
'
'        Dim index = bPic.Index
'        If path = "" Then
'            Dim sfd As SaveFileDialog = Nothing
'            Try
'                sfd = New SaveFileDialog()
'                sfd.InitialDirectory = FixPath(Doc.Application.Options.DefaultFilePath(Word.WdDefaultFilePath.wdPicturesPath))
'                sfd.fileName = bPic.SourceName
'                sfd.Filter = "JPG files (*.jpg)|*.jpg|PNG files (*.png)|*.png|BMP files (*.bmp)|*.bmp|EMF files (*.emf)|*.emf|WMF files (*.wmf)|*.wmf|All files (*.*)|*.*"
'                ' Find eksisterende filtype
'                filterIndex = GetFilterIndex(bPic.SourceName)
'                sfd.filterIndex = filterIndex
'                sfd.RestoreDirectory = True
'
'                If sfd.ShowDialog() = DialogResult.ok Then
'                    path = sfd.fileName
'                End If
'            Catch ex As Exception
'                Debug.Print (ex.Message)
'            Finally
'                If Not sfd Is Nothing Then
'                    sfd.Dispose()
'                End If
'            End Try
'        End If
'
'        If path = "" Then Return Nothing
'        filterIndex = GetFilterIndex(path)
'
'        If filterIndex = 1 Then
'            format = Imaging.ImageFormat.Jpeg
'        ElseIf filterIndex = 2 Then
'            format = Imaging.ImageFormat.Png
'        ElseIf filterIndex = 3 Then
'            format = Imaging.ImageFormat.Bmp
'        ElseIf filterIndex = 4 Then
'            format = Imaging.ImageFormat.Emf
'        ElseIf filterIndex = 5 Then
'            format = Imaging.ImageFormat.Wmf
'        Else
'            Return Nothing
'        End If
'
'        Try
'            bPic.Image.Save(path, format)
'            Dim tempBPic As New BPicture
'            tempBPic.index = bPic.index
'            tempBPic.PictureType = bPic.PictureType
'            tempBPic.sourceFullName = path
'            tempBPic.SourcePath = System.IO.path.GetDirectoryName(path)
'            tempBPic.SourceName = System.IO.path.GetFileName(path)
'            Return tempBPic
'        Catch ex As Exception
'            Debug.Print (ex.Message)
'            Return Nothing
'            'MsgBox("Unable to save. " & ex.Message)
'        End Try
'
'    End Function
Attribute VB_Name = "RevisionHistoryForm"
Attribute VB_Base = "0{B42EEB47-CDC3-4378-8D0E-63BF852E06B2}{4D76181A-8B68-4A31-8EC9-6D2760EF3A6C}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public CalledFrom As MainForm
Public SelectedIndex As Integer
Public RevCount As Integer
Private aRevHist() As String
Public Init As Boolean

Public Sub Display()
    ' Actual initialize
    aRevHist = CalledFrom.GetRevisionHistory
    ListBoxRevisions.List = aRevHist
    RevCount = CalledFrom.RevCount
    SelectedIndex = RevCount - 1
    ListBoxRevisions.listIndex = SelectedIndex
    
    If ActiveDocument.ReadOnly Then
        Dim ctrl As control
        For Each ctrl In Me.Controls
            ctrl.Enabled = False
        Next
        CommandButtonCancel.Enabled = True
    End If
    Me.show
    
End Sub

Public Sub Update()
    Dim i As Integer
    aRevHist = OrderRevisionHistory(aRevHist)
    For i = 0 To RevCount - 1
        If aRevHist(i, 0) = TextBoxRevNo.text And aRevHist(i, 1) = TextBoxRevDate.text And aRevHist(i, 2) = TextBoxRevAuthor.text And aRevHist(i, 3) = TextBoxRevDescription.text Then
            SelectedIndex = i
            Exit For
        End If
    Next
    ListBoxRevisions.List = aRevHist
    ListBoxRevisions.listIndex = SelectedIndex
End Sub

Private Sub UpdateTextboxes()
    Init = True
    TextBoxRevNo.text = ListBoxRevisions.List(SelectedIndex, 0)
    TextBoxRevDate.text = ListBoxRevisions.List(SelectedIndex, 1)
    TextBoxRevAuthor.text = ListBoxRevisions.List(SelectedIndex, 2)
    TextBoxRevDescription.text = ListBoxRevisions.List(SelectedIndex, 3)
    Init = False
End Sub

Private Sub UpdateRevisionList()
    aRevHist(SelectedIndex, 0) = TextBoxRevNo.text
    aRevHist(SelectedIndex, 1) = TextBoxRevDate.text
    aRevHist(SelectedIndex, 2) = TextBoxRevAuthor.text
    aRevHist(SelectedIndex, 3) = TextBoxRevDescription.text
    Init = True
    Update
    Init = False
End Sub

Private Sub CommandButtonCancel_Click()
    DoCancel
End Sub

Private Sub CommandButtonDelete_Click()
    If RevCount = 1 Then
        DeleteAll
    Else
        Dim i As Integer
    
        For i = SelectedIndex + 1 To RevCount - 1
            aRevHist(i - 1, 0) = aRevHist(i, 0)
            aRevHist(i - 1, 1) = aRevHist(i, 1)
            aRevHist(i - 1, 2) = aRevHist(i, 2)
            aRevHist(i - 1, 3) = aRevHist(i, 3)
        Next
        ReDimPreserve aRevHist, RevCount - 2, 4
        RevCount = RevCount - 1
        If SelectedIndex > RevCount - 1 Then SelectedIndex = RevCount - 1
        Update
    End If
End Sub

Private Sub CommandButtonDeleteAll_Click()
    DeleteAll
End Sub

Private Sub DeleteAll()
    Init = True
    ReDim aRevHist(0, 4)
    RevCount = 1
    SelectedIndex = 0
    aRevHist(SelectedIndex, 0) = GetNewMajor("")
    aRevHist(SelectedIndex, 1) = Format(Now, "YYYY-MM-DD")
    aRevHist(SelectedIndex, 2) = UserName
    If Not UserName = "" Then
        Me.TextBoxRevDescription.SetFocus
    Else
        Me.TextBoxRevAuthor.SetFocus
    End If
    ListBoxRevisions.List = aRevHist
    ListBoxRevisions.listIndex = SelectedIndex
    UpdateTextboxes
    Init = False
End Sub


Private Sub CommandButtonNewMajor_Click()
    AddRevision "Major"
End Sub

Private Sub CommandButtonNewMinor_Click()
    AddRevision "Minor"
End Sub

Private Sub AddRevision(MinorOrMajor As String)
    Dim newRev As String
    Init = True
    aRevHist(SelectedIndex, 0) = Me.TextBoxRevNo.text
    aRevHist(SelectedIndex, 1) = Me.TextBoxRevDate.text
    aRevHist(SelectedIndex, 2) = Me.TextBoxRevAuthor.text
    aRevHist(SelectedIndex, 3) = Me.TextBoxRevDescription.text
    ReDimPreserve aRevHist, RevCount, 4
    RevCount = RevCount + 1
    SelectedIndex = RevCount - 1
    If MinorOrMajor = "Minor" Then
        newRev = GetNewMinor(aRevHist(SelectedIndex - 1, 0))
    Else
        newRev = GetNewMajor(aRevHist(SelectedIndex - 1, 0))
    End If
    aRevHist(SelectedIndex, 0) = newRev
    aRevHist(SelectedIndex, 1) = Format(Now, "YYYY-MM-DD")
    aRevHist(SelectedIndex, 2) = UserName
    aRevHist(SelectedIndex, 3) = ""
    If Not UserName = "" Then
        Me.TextBoxRevDescription.SetFocus
    Else
        Me.TextBoxRevAuthor.SetFocus
    End If
    TextBoxRevNo.text = aRevHist(SelectedIndex, 0)
    TextBoxRevDate.text = aRevHist(SelectedIndex, 1)
    TextBoxRevAuthor.text = aRevHist(SelectedIndex, 2)
    TextBoxRevDescription.text = aRevHist(SelectedIndex, 3)
    Update
    Init = False
End Sub

Private Sub CommandButtonOk_Click()
    DoOk
End Sub

Private Sub ListBoxRevisions_Change()
    If Not Init Then
        SelectedIndex = ListBoxRevisions.listIndex
        UpdateTextboxes
    End If
End Sub

Private Sub TextBoxRevAuthor_Change()
    If Not Init Then UpdateRevisionList
End Sub

Private Sub TextBoxRevDate_Change()
    If Not Init Then UpdateRevisionList
End Sub

Private Sub TextBoxRevDescription_Change()
    If Not Init Then UpdateRevisionList
End Sub

Private Sub TextBoxRevNo_Change()
    If Not Init Then UpdateRevisionList
End Sub

Public Sub DoOk()
    CalledFrom.SetRevisionHistory aRevHist, RevCount
    Unload Me
End Sub

Public Sub DoCancel()
    Unload Me
End Sub

Private Sub UserForm_Initialize()
    Set CalledFrom = Nothing
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    If CloseMode = 0 Then 'Red X
        DoCancel
    End If
End Sub
Attribute VB_Name = "ThisDocument"
Attribute VB_Base = "0{00020906-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Private Sub Document_BuildingBlockInsert(ByVal Range As Range, ByVal Name As String, ByVal Category As String, ByVal BlockType As String, ByVal Template As String)
    'Debug.Print Now, "Document_BuildingBlockInsert", ActiveDocument.fullName
End Sub

Private Sub Document_ContentControlAfterAdd(ByVal NewContentControl As ContentControl, ByVal InUndoRedo As Boolean)
    'Debug.Print Now, "Document_ContentControlAfterAdd", ActiveDocument.fullName
End Sub

Private Sub Document_Close()
    'Debug.Print Now, "Document_Close", ActiveDocument.fullName
End Sub

Private Sub Document_New()
    'Debug.Print Now, "Document_New", ActiveDocument.fullName
End Sub

Private Sub Document_Open()
    'Debug.Print Now, "Document_Open", ActiveDocument.fullName
End Sub

Private Sub Document_XMLAfterInsert(ByVal NewXMLNode As XMLNode, ByVal InUndoRedo As Boolean)
    'Debug.Print Now, "Document_XMLAfterInsert", ActiveDocument.fullName
End Sub
Attribute VB_Name = "UpdateForm"
Attribute VB_Base = "0{BEC696A8-618A-4346-AC22-A13A9AB31691}{01BE0EF1-51B9-4531-9090-096E37841781}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public bgd As BGDoc
Private ToDo As String

Public Sub WriteLog(str As String)
    Me.TextBoxLog.text = Me.TextBoxLog.text & vbCrLf & Format(Now, "HH:mm:ss") & vbTab & str ' & ", " & Application.screenUpdating
    Me.Repaint
    DoEvents
End Sub

Public Sub Init(useBGD As BGDoc, run As String)
    Set bgd = useBGD
    ToDo = run
End Sub

Private Sub UserForm_Activate()
    Me.BorderStyle = fmBorderStyleNone
    Select Case ToDo
    Case "UpdateDocument"
        ToDo = ""
        bgd.UpdateDocument
    Case "ConvertDocument"
        ToDo = ""
        bgd.ConvertDocument
    End Select
    
    Unload Me

End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    If CloseMode = 0 Then 'Red X
        Cancel = True
    End If
End Sub
Attribute VB_Name = "bg_Application"
Option Explicit

Public ErrorProfile As BGErrorProfile

Public DocRibbon As IRibbonUI
Public Manager As BGDocManager
Public B As BGDoc
Public Const EmptyBGDoc As Variant = Empty
Public MissingBGDoc As New BGDoc

Public Function NoObject(source As String, Optional lineNo As Long = 0) As BGError
    Dim bge As New BGError
    bge.source = source
    bge.Line = lineNo
    Set NoObject = bge
End Function

Public Function GetB(Optional doc As Document = Nothing) As BGDoc
    If doc Is Nothing Then Set doc = ActiveDocument
    Dim bgd As BGDoc
    Set bgd = GetManager.Init(doc).GetBGDoc(doc)
    If bgd Is Nothing Then
        Set bgd = GetManager.Init(doc).AddDoc(doc, dsDocument)
    End If
    Set GetB = bgd
End Function

Public Function GetBFromFullName(fullName As String) As BGDoc
    Set GetBFromFullName = GetManager.GetBGDocFromFullName(fullName)
End Function

Public Sub ResetManager()
    GetManager(True).Init
End Sub

Public Function GetManager(Optional reset As Boolean = False) As BGDocManager
    Dim testApp As Application
    On Error Resume Next
    Set testApp = Manager.App
    On Error GoTo Catch
    
    If testApp Is Nothing Then
        Set Manager = New BGDocManager
    Else
        If reset Then
            Set Manager.App = Nothing
            Set Manager = Nothing
            Set Manager = New BGDocManager
        End If
    End If
    Set GetManager = Manager
    Exit Function
    
NoManager:
    On Error GoTo 0
    Set GetManager = Nothing
    Exit Function
    
Catch:
    Dim e As New BGError
    e.OnError
    Resume NoManager
End Function

Public Sub BGdoc_onLoad(ribbon As IRibbonUI)
    'Debug.Print Now, "BGdoc_onLoad"
    Dim i As Integer
    i = 0
    On Error GoTo RibbonNotReady
SetRibbon:
    i = i + 1
    If i = 100 Then
        Exit Sub
    End If
    Do While Documents.Count = 0
      DoEvents
      Sleep 10
      DoEvents
    Loop
    
HasFoundDocument:
    On Error GoTo 0
    Set DocRibbon = ribbon
    On Error Resume Next
    DocRibbon.ActivateTab "documentTab"
    On Error GoTo 0

    Exit Sub
RibbonNotReady:
'    Stop
    Resume SetRibbon

End Sub

Public Sub AutoNew()
'    Debug.Print Now, "AutoNew"
    GetManager.Init(ActiveDocument).AddDoc ActiveDocument, dsAutoNew
End Sub

Public Sub AutoOpen()
'    Debug.Print Now, "AutoOpen"
    GetManager.Init(ActiveDocument).AddDoc ActiveDocument, dsAutoOpen
End Sub

'Public Sub AutoClose()
'    Debug.Print Now, "AutoClose"
'    'GetManager.Init "AutoClose", ActiveDocument.fullName
'    Application.OnTime Now + TimeValue("00:00:01"), "bg_Support.AfterAutoClose"
'End Sub
'
'Public Sub AutoExec()
'    Debug.Print Now, "AutoExec"
'End Sub
'
'Public Sub AutoExit()
'    Debug.Print Now, "AutoExit"
'End Sub

Public Sub ReadTemplate()
    Dim i As Integer
    Dim j As Integer
    Dim T As Integer
    Dim aTables() As String
    Dim table As String
    Dim values() As String
    Dim rows As Integer
    Dim cols As Integer
    Dim aRow() As String
    Dim re As Object
    Dim matches As Object
    
    aTables = Split(ThisDocument.BuiltInDocumentProperties("Comments"), vbCr + "|||")
    For T = 1 To UBound(aTables) - 1 Step 2
        table = aTables(T)
        values = Split(aTables(T + 1), vbCr)
        Select Case table
        Case "DocumentTypes"
            rows = UBound(values)
            cols = UBound(Split(values(0), vbTab))
            ReDim aDocumentTypes(rows, cols)
            For i = 0 To rows
                aRow = Split(values(i), vbTab)
                For j = 0 To cols
                    aDocumentTypes(i, j) = aRow(j)
                Next
            Next
        Case "Terms"
            rows = UBound(values)
            cols = UBound(Split(values(0), vbTab))
            ReDim aTerms(cols - 1, rows + 1)
            
            Set re = CreateObject("vbscript.regexp")
            With re
                .IgnoreCase = True
                .Global = True
                .Pattern = "([^ |fffd||fffd|]+)([|fffd|||fffd|]?)" ' Must match the other one
            
                For i = 0 To rows
                    aRow = Split(values(i), vbTab)
                    For j = 1 To cols
                        aTerms(j - 1, i) = Trim(aRow(j))
                    Next
                Next
                For j = 0 To cols - 1
                    If .Test(aTerms(j, 1)) Then
                       Set matches = .Execute(aTerms(j, 1))
                       aTerms(j, rows + 1) = matches.Count
                    Else
                       aTerms(j, rows + 1) = 1
                    End If
                Next
            End With
            
            QuickSortArray aTerms, , , CLng(rows + 1)
'                ' Create term regular expression
'                rows = UBound(aTerms, 1)
'                ' (?:^|\W)(CrisBag(?:\W||fffd|||fffd||$)
'                TermReg = "("
'                For i = 0 To rows
'                    TermReg = TermReg & "(?:^|\W)(" & aTerms(i, 0) & "(?:\W||fffd|||fffd||$|"
'                Next
'                TermReg = Left(TermReg, Len(TermReg) - 1) & ")"
'                Stop
            
        Case "Languages"
            Set Months = New Scripting.Dictionary
            Set TableRevNames = New Scripting.Dictionary
            rows = UBound(values)
            cols = UBound(Split(values(0), vbTab))
            ReDim LanguageFieldIndexes(cols)
            ReDim aLanguages(rows - 1, cols + 1)
            aRow = Split(values(0), vbTab)
            For j = 0 To cols
                LanguageFieldIndexes(j) = aRow(j)
            Next
            For i = 1 To rows
                aRow = Split(values(i), vbTab)
                aLanguages(i - 1, 0) = aRow(0)
                aLanguages(i - 1, 1) = aRow(1) '& " - " & aRow(3)
                For j = 1 To cols
                    aLanguages(i - 1, j + 1) = aRow(j)
                    If LanguageFieldIndexes(j) = "DocumentLabel-Revision" _
                    Or LanguageFieldIndexes(j) = "RevisionNameInTable" Then
                        If aRow(j) > "" Then
                            RevNames = RevNames & "|" & LCase(aRow(j))
                        End If
                    End If
                    If LanguageFieldIndexes(j) = "DocumentLabel-RevisionHistory-Revision" Then
                        If aRow(j) > "" And Not TableRevNames.Exists(LCase(Replace(aRow(j), ".", ""))) Then
                            TableRevNames.Add LCase(Replace(aRow(j), ".", "")), LCase(Replace(aRow(j), ".", ""))
                        End If
                    End If
                    If LanguageFieldIndexes(j) Like "Month##" Then
                        If aRow(j) > "" And Not Months.Exists(LCase(aRow(j))) Then
                            Months.Add aRow(j), Right(LanguageFieldIndexes(j), 2)
                            If UCase(aRow(j)) <> aRow(j) Then Months.Add UCase(aRow(j)), Right(LanguageFieldIndexes(j), 2)
                            If LCase(aRow(j)) <> aRow(j) Then Months.Add LCase(aRow(j)), Right(LanguageFieldIndexes(j), 2)
                        End If
                    End If
                Next
            Next
            QuickSortArray aLanguages, , , 1
        End Select
    Next
    LanguageFields = Array("DocumentLabel-FigureCaption", "DocumentLabel-TableCaption", "DocumentLabel-Author", "DocumentLabel-Copyright", "DocumentLabel-Date", "DocumentLabel-DocumentInformation", "DocumentLabel-FileName", "DocumentLabel-Front", "DocumentLabel-IntentionallyLeftBlank", "DocumentLabel-Page", "DocumentLabel-ProjectNo", "DocumentLabel-Revision", "DocumentLabel-RevisionHistory", "DocumentLabel-RevisionHistory-Author", "DocumentLabel-RevisionHistory-Date", "DocumentLabel-RevisionHistory-Description", "DocumentLabel-RevisionHistory-Revision", "DocumentLabel-SupplierFileName", "DocumentLabel-TOC", "DocumentLabel-TOF", "DocumentLabel-TOT", "DocumentInfo-Copyright", "DocumentInfo-Disclaimer")
    PathLanguageFields = Array("/DocumentLabel/DocumentLabel-FigureCaption", "/DocumentLabel/DocumentLabel-TableCaption", "/DocumentLabel/DocumentLabel-Author", "/DocumentLabel/DocumentLabel-Copyright", "/DocumentLabel/DocumentLabel-Date", "/DocumentLabel/DocumentLabel-DocumentInformation", "/DocumentLabel/DocumentLabel-FileName", "/DocumentLabel/DocumentLabel-Front", _
    "/DocumentLabel/DocumentLabel-IntentionallyLeftBlank", "/DocumentLabel/DocumentLabel-Page", "/DocumentLabel/DocumentLabel-ProjectNo", "/DocumentLabel/DocumentLabel-Revision", "/DocumentLabel/DocumentLabel-RevisionHistory", "/DocumentLabel/DocumentLabel-RevisionHistory-Author", "/DocumentLabel/DocumentLabel-RevisionHistory-Date", "/DocumentLabel/DocumentLabel-RevisionHistory-Description", "/DocumentLabel/DocumentLabel-RevisionHistory-Revision", "/DocumentLabel/DocumentLabel-SupplierFileName", "/DocumentLabel/DocumentLabel-TOC", "/DocumentLabel/DocumentLabel-TOF", "/DocumentLabel/DocumentLabel-TOT", "/DocumentInfo/DocumentInfo-Copyright", "/DocumentInfo/DocumentInfo-Disclaimer")
    
Conv437Unicode = Array( _
&H0, &H1, &H2, &H3, &H4, &H5, &H6, &H7, &H8, &H9, &HA, &HB, &HC, &HD, &HE, &HF, &H10, &H11, &H12, &H13, &H14, &H15, &H16, &H17, &H18, &H19, &H1A, &H1B, &H1C, &H1D, &H1E, &H1F, &H20, &H21, &H22, &H23, &H24, &H25, &H26, &H27, &H28, &H29, &H2A, &H2B, &H2C, &H2D, &H2E, &H2F, &H30, &H31, &H32, &H33, &H34, &H35, &H36, &H37, &H38, &H39, &H3A, &H3B, &H3C, &H3D, &H3E, &H3F, &H40, &H41, &H42, &H43, &H44, &H45, &H46, &H47, &H48, &H49, &H4A, &H4B, &H4C, &H4D, &H4E, &H4F, &H50, &H51, &H52, &H53, &H54, &H55, &H56, &H57, &H58, &H59, &H5A, &H5B, &H5C, &H5D, &H5E, &H5F, &H60, &H61, &H62, &H63, &H64, &H65, &H66, &H67, &H68, &H69, &H6A, &H6B, &H6C, &H6D, &H6E, &H6F, &H70, &H71, &H72, &H73, &H74, &H75, &H76, &H77, &H78, &H79, &H7A, &H7B, &H7C, &H7D, &H7E, _
&H7F, &HC7, &HFC, &HE9, &HE2, &HE4, &HE0, &HE5, &HE7, &HEA, &HEB, &HE8, &HEF, &HEE, &HEC, &HC4, &HC5, &HC9, &HE6, &HC6, &HF4, &HF6, &HF2, &HFB, &HF9, &HFF, &HD6, &HDC, &HA2, &HA3, &HA5, &H20A7, &H192, &HE1, &HED, &HF3, &HFA, &HF1, &HD1, &HAA, &HBA, &HBF, &H2310, &HAC, &HBD, &HBC, &HA1, &HAB, &HBB, &H2591, &H2592, &H2593, &H2502, &H2524, &H2561, &H2562, &H2556, &H2555, &H2563, &H2551, &H2557, &H255D, &H255C, &H255B, &H2510, &H2514, &H2534, &H252C, &H251C, &H2500, &H253C, &H255E, &H255F, &H255A, &H2554, &H2569, &H2566, &H2560, &H2550, &H256C, &H2567, &H2568, &H2564, &H2565, &H2559, &H2558, &H2552, &H2553, &H256B, &H256A, &H2518, &H250C, &H2588, &H2584, &H258C, &H2590, &H2580, &H3B1, &HDF, &H393, &H3C0, &H3A3, &H3C3, &HB5, &H3C4, &H3A6, &H398, &H3A9, &H3B4, &H221E, &H3C6, &H3B5, &H2229, &H2261, &HB1, &H2265, &H2264, &H2320, &H2321, &HF7, &H2248, &HB0, &H2219, &HB7, &H221A, &H207F, &HB2, _
&H25A0, &HA0)
    
Conv850Unicode = Array( _
&H0, &H1, &H2, &H3, &H4, &H5, &H6, &H7, &H8, &H9, &HA, &HB, &HC, &HD, &HE, &HF, &H10, &H11, &H12, &H13, &H14, &H15, &H16, &H17, &H18, &H19, &H1A, &H1B, &H1C, &H1D, &H1E, &H1F, &H20, &H21, &H22, &H23, &H24, &H25, &H26, &H27, &H28, &H29, &H2A, &H2B, &H2C, &H2D, &H2E, &H2F, &H30, &H31, &H32, &H33, &H34, &H35, &H36, &H37, &H38, &H39, &H3A, &H3B, &H3C, &H3D, &H3E, &H3F, &H40, &H41, &H42, &H43, &H44, &H45, &H46, &H47, &H48, &H49, &H4A, &H4B, &H4C, &H4D, &H4E, &H4F, &H50, &H51, &H52, &H53, &H54, &H55, &H56, &H57, &H58, &H59, &H5A, &H5B, &H5C, &H5D, &H5E, &H5F, &H60, &H61, &H62, &H63, &H64, &H65, &H66, &H67, &H68, &H69, &H6A, &H6B, &H6C, &H6D, &H6E, &H6F, &H70, &H71, &H72, &H73, &H74, &H75, &H76, &H77, &H78, &H79, &H7A, &H7B, &H7C, _
&H7D, &H7E, &H7F, &HC7, &HFC, &HE9, &HE2, &HE4, &HE0, &HE5, &HE7, &HEA, &HEB, &HE8, &HEF, &HEE, &HEC, &HC4, &HC5, &HC9, &HE6, &HC6, &HF4, &HF6, &HF2, &HFB, &HF9, &HFF, &HD6, &HDC, &HF8, &HA3, &HD8, &HD7, &H192, &HE1, &HED, &HF3, &HFA, &HF1, &HD1, &HAA, &HBA, &HBF, &HAE, _
&HAC, &HBD, &HBC, &HA1, &HAB, &HBB, &H2591, &H2592, &H2593, &H2502, &H2524, &HC1, &HC2, &HC0, &HA9, &H2563, &H2551, &H2557, &H255D, &HA2, &HA5, &H2510, &H2514, &H2534, &H252C, &H251C, &H2500, &H253C, &HE3, &HC3, &H255A, &H2554, &H2569, &H2566, &H2560, &H2550, &H256C, &HA4, &HF0, &HD0, &HCA, &HCB, &HC8, &H131, &HCD, &HCE, &HCF, &H2518, &H250C, &H2588, &H2584, &HA6, &HCC, &H2580, &HD3, &HDF, &HD4, &HD2, &HF5, &HD5, &HB5, &HFE, &HDE, &HDA, &HDB, &HD9, &HFD, &HDD, &HAF, &HB4, &HAD, &HB1, &H2017, &HBE, &HB6, &HA7, &HF7, &HB8, &HB0, &HA8, &HB7, &HB9, &HB3, &HB2, &H25A0, &HA0)
    
    
Conv863Unicode = Array( _
&H0, &H1, &H2, &H3, &H4, &H5, &H6, &H7, &H8, &H9, &HA, &HB, &HC, &HD, &HE, &HF, &H10, &H11, &H12, &H13, &H14, &H15, &H16, &H17, &H18, &H19, &H1A, &H1B, &H1C, &H1D, &H1E, &H1F, &H20, &H21, &H22, &H23, &H24, &H25, &H26, &H27, &H28, &H29, &H2A, &H2B, &H2C, &H2D, &H2E, &H2F, &H30, &H31, &H32, &H33, &H34, &H35, &H36, &H37, &H38, &H39, &H3A, &H3B, &H3C, &H3D, &H3E, &H3F, &H40, &H41, &H42, &H43, &H44, &H45, &H46, &H47, &H48, &H49, &H4A, &H4B, &H4C, &H4D, &H4E, &H4F, &H50, &H51, &H52, &H53, &H54, &H55, &H56, &H57, _
&H58, &H59, &H5A, &H5B, &H5C, &H5D, &H5E, &H5F, &H60, &H61, &H62, &H63, &H64, &H65, &H66, &H67, &H68, &H69, &H6A, &H6B, &H6C, &H6D, &H6E, &H6F, &H70, &H71, &H72, &H73, &H74, &H75, &H76, &H77, &H78, &H79, &H7A, &H7B, &H7C, &H7D, &H7E, &H7F, &HC7, &HFC, &HE9, &HE2, &HC2, &HE0, &HB6, &HE7, &HEA, &HEB, &HE8, &HEF, &HEE, &H2017, &HC0, &HA7, &HC9, &HC8, &HCA, &HF4, &HCB, &HCF, &HFB, &HF9, &HA4, &HD4, &HDC, &HA2, &HA3, &HD9, &HDB, &H192, &HA6, &HB4, &HF3, &HFA, &HA8, &HB8, &HB3, &HAF, &HCE, &H2310, &HAC, &HBD, &HBC, &HBE, &HAB, &HBB, _
&H2591, &H2592, &H2593, &H2502, &H2524, &H2561, &H2562, &H2556, &H2555, &H2563, &H2551, &H2557, &H255D, &H255C, &H255B, &H2510, &H2514, &H2534, &H252C, &H251C, &H2500, &H253C, &H255E, &H255F, &H255A, &H2554, &H2569, &H2566, &H2560, &H2550, &H256C, &H2567, &H2568, &H2564, &H2565, &H2559, &H2558, &H2552, &H2553, &H256B, _
&H256A, &H2518, &H250C, &H2588, &H2584, &H258C, &H2590, &H2580, &H3B1, &HDF, &H393, &H3C0, &H3A3, &H3C3, &HB5, &H3C4, &H3A6, &H398, &H3A9, &H3B4, &H221E, &H3C6, &H3B5, &H2229, &H2261, &HB1, &H2265, &H2264, &H2320, &H2321, &HF7, &H2248, &HB0, &H2219, &HB7, &H221A, &H207F, &HB2, &H25A0, &HA0)

    
    ReadTemplateComments = True
End Sub

Public Sub GetUserNameAndDeleteOldFiles()
    UserName = GetUserFullName
    FoundUserName = True
    ' Delete old temp files
    DeleteOldFiles UserTemp() & "\BGdoc\PDF", 14
    DeleteOldFiles UserTemp() & "\BGdoc", 14
    DeleteOldFiles UserTemp() & "\Draft", 14
    DeleteOldFiles UserTemp() & "\Conversion", 14
End Sub


Attribute VB_Name = "bg_CI"
Option Explicit
Option Compare Text

Public Sub QuickSortArray(ByRef SortArray As Variant, Optional lngMin As Long = -1, Optional lngMax As Long = -1, Optional lngColumn As Long = 0)
    On Error Resume Next

    'Sort a 2-Dimensional array

    ' SampleUsage: sort arrData by the contents of column 3
    '
    '   QuickSortArray arrData, , , 3

    '
    'Posted by Jim Rech 10/20/98 Excel.Programming

    'Modifications, Nigel Heffernan:

    '       ' Escape failed comparison with empty variant
    '       ' Defensive coding: check inputs

    Dim i As Long
    Dim j As Long
    Dim varMid As Variant
    Dim arrRowTemp As Variant
    Dim lngColTemp As Long

    If IsEmpty(SortArray) Then
        Exit Sub
    End If
    If InStr(TypeName(SortArray), "()") < 1 Then  'IsArray() is somewhat broken: Look for brackets in the type name
        Exit Sub
    End If
    If lngMin = -1 Then
        lngMin = LBound(SortArray, 1)
    End If
    If lngMax = -1 Then
        lngMax = UBound(SortArray, 1)
    End If
    If lngMin >= lngMax Then    ' no sorting required
        Exit Sub
    End If

    i = lngMin
    j = lngMax

    varMid = Empty
    varMid = SortArray((lngMin + lngMax) \ 2, lngColumn)

    ' We  send 'Empty' and invalid data items to the end of the list:
    If IsObject(varMid) Then  ' note that we don't check isObject(SortArray(n)) - varMid *might* pick up a valid default member or property
        i = lngMax
        j = lngMin
    ElseIf IsEmpty(varMid) Then
        i = lngMax
        j = lngMin
    ElseIf IsNull(varMid) Then
        i = lngMax
        j = lngMin
    ElseIf varMid = "" Then
        i = lngMax
        j = lngMin
    ElseIf VarType(varMid) = vbError Then
        i = lngMax
        j = lngMin
    ElseIf VarType(varMid) > 17 Then
        i = lngMax
        j = lngMin
    End If

    While i <= j
        While SortArray(i, lngColumn) < varMid And i < lngMax
            i = i + 1
        Wend
        While varMid < SortArray(j, lngColumn) And j > lngMin
            j = j - 1
        Wend

        If i <= j Then
            ' Swap the rows
            ReDim arrRowTemp(LBound(SortArray, 2) To UBound(SortArray, 2))
            For lngColTemp = LBound(SortArray, 2) To UBound(SortArray, 2)
                arrRowTemp(lngColTemp) = SortArray(i, lngColTemp)
                SortArray(i, lngColTemp) = SortArray(j, lngColTemp)
                SortArray(j, lngColTemp) = arrRowTemp(lngColTemp)
            Next lngColTemp
            Erase arrRowTemp

            i = i + 1
            j = j - 1
        End If
    Wend

    If (lngMin < j) Then Call QuickSortArray(SortArray, lngMin, j, lngColumn)
    If (i < lngMax) Then Call QuickSortArray(SortArray, i, lngMax, lngColumn)

End Sub
Attribute VB_Name = "bg_Callbacks"
Option Explicit

Public ActiveWindowHandle As LongPtr

Public Sub ActivateDocumentTab()
    If Not DocRibbon Is Nothing Then
        DoEvents
        Sleep 10
        On Error Resume Next
        DocRibbon.ActivateTab "documentTab"
        On Error GoTo 0
        DoEvents
    End If
End Sub

Public Sub ButtonInsertProperty_Click(control As IRibbonControl)
    If Not IsLocked Then
        Dim DX As New DOCXML
        Dim shortId As String
        shortId = Replace(control.ID, "ButtonInsertProperty", "")
        shortId = "[[" & shortId & "]]"
        DX.InsertCalculatedCC shortId
        Set DX = Nothing
    End If
    
End Sub


Public Sub ButtonBGdocSaveAs_Click(control As IRibbonControl)
    Dim bgd As BGDoc
    Dim ByRefCancel As Boolean
    Dim ByRefSaveAsUI As Boolean
    ByRefCancel = False
    ByRefSaveAsUI = True
    
    Set bgd = GetManager.GetBGDoc(ActiveDocument)
    If Not bgd Is Nothing Then
        bgd.HandleSave ActiveDocument, "DocumenTBeforeSave", ByRefCancel, ByRefSaveAsUI
    Else
    End If
    
End Sub


Sub ButtonMarkAsForm_Click(control As IRibbonControl)
    If Not ActiveDocument.ReadOnly Then
        Dim frm As New MarkAsForm
        frm.show
    End If
End Sub

Sub ButtonConvertToBGDoc_Click(control As IRibbonControl)
    Dim doc As Document
    Dim fromDoc As Document
    Set doc = Application.Documents.Add(ActiveDocument.attachedTemplate.fullName, , , False)
    
    Dim fromDocFullName As String
    fromDocFullName = OpenConvertFileDialog()
    If fromDocFullName > "" Then
        On Error Resume Next
        Set fromDoc = Application.Documents(fromDocFullName)
        On Error GoTo 0
        If fromDoc Is Nothing Then
            On Error Resume Next
            Set fromDoc = Application.Documents.Open(fromDocFullName, False, True, False, , , , , , , , True)
            On Error GoTo 0
            If fromDoc Is Nothing Then
                MsgBox "Unable to open '" & fromDocFullName & "'. Not allowed due to Trust Center settibgs?", vbExclamation & vbOKOnly, "Cannot convert document"
                Exit Sub
            End If
            If fromDoc.CanCheckin Then
                MsgBox "Document must be checked in to be converted '" & fromDocFullName & "'", vbExclamation & vbOKOnly, "Cannot convert document"
                Exit Sub
            End If
            If LCase(fromDoc.fullName) Like "http*" Then
                Dim notOk As String
                notOk = CanMoveSharePointFile(fromDoc.fullName)
                If notOk > "" Then
                    If LCase(notOk) Like "*heckout*" Then
                        MsgBox "Converting '" & fromDocFullName & "' is not possible." & vbCrLf & vbCrLf & notOk, vbExclamation & vbOKOnly, "Cannot convert document"
                    Else
                        MsgBox "Document must be checked in to be converted '" & fromDocFullName & "'." & vbCrLf & vbCrLf & notOk, vbExclamation & vbOKOnly, "Cannot convert document"
                    End If
                    Exit Sub
                End If
            End If
        End If
        ConvertDocumentToBGDoc fromDocFullName, doc.fullName
        ActivateDocumentTab
    End If
End Sub

'Private Sub ConvertDocumentToBGDocFromDoc()
'    Dim language As String
'    Dim DX  As New DOCXML
'    DX.Init
'    language = DX.ReadText("/DocumentInfo/DocumentInfo-Language")
'    Set DX = Nothing
'    If language = "" Then
'        ConvertDocumentCommand
'    Else
'        If vbOK = MsgBox("The current document is not empty. Do you really want to replace the existing content?", vbOKCancel + vbCritical + vbApplicationModal, "Import Document") Then
'            ConvertDocumentCommand
'        End If
'    End If
'
'End Sub

Sub ButtonDocumentForm_Click(control As IRibbonControl)
    GetManager.Init.GetBGDoc(ActiveDocument).Update "Form"
End Sub

Sub ButtonRefreshDocument_Click(control As IRibbonControl)
    GetManager.Init.GetBGDoc(ActiveDocument).Update "Refresh"
End Sub

'Sub ButtonCloneDocument_Click(control As IRibbonControl)
'    MsgBox "Clone Document"
'End Sub

Sub ButtonInsertCalculatedField_Click(control As IRibbonControl)
    If Not IsLocked Then
        Dim frm As New InsertCalculatedField
        frm.show
    End If
End Sub

Sub ButtonPDFDraft_Click(control As IRibbonControl)
    Dim ok As Boolean
    Dim fileName As String
    Dim ShowPDF As Boolean
    Dim Addin As Object
    Dim NoAddIn As Boolean
    Dim pdfFilename As String
    
    Set Addin = GetAutomationObject
    NoAddIn = (Addin Is Nothing)
    
    ShowPDF = False
    
    fileName = ActiveDocument.Name
    If InStr(fileName, ".") = 0 Then
        fileName = fileName & ".pdf"
    Else
        fileName = Mid(fileName, 1, InStrRev(fileName, ".")) & "pdf"
    End If
    
    On Error Resume Next
    MkDir UserTemp() & "\BGdoc"
    MkDir UserTemp() & "\BGdoc\PDF"
    On Error GoTo 0
    
    If ActiveDocument.Name = ActiveDocument.fullName Or GetB.SaveAsTempFullName > "" Then
        pdfFilename = UserTemp() & "\BGdoc\PDF\Draft " & fileName
        On Error Resume Next
        ActiveDocument.ExportAsFixedFormat OutputFileName:= _
            pdfFilename, ExportFormat:= _
            wdExportFormatPDF, OpenAfterExport:=NoAddIn, OptimizeFor:= _
            wdExportOptimizeForPrint, Range:=wdExportAllDocument, from:=1, To:=1, _
            Item:=wdExportDocumentContent, IncludeDocProps:=True, KeepIRM:=True, _
            CreateBookmarks:=wdExportCreateHeadingBookmarks, DocStructureTags:=False, _
            BitmapMissingFonts:=True, UseISO19005_1:=False
            
            ShowPDF = True
            
        On Error GoTo 0
    Else
        Dim FileSaveAsSetting As String
        FileSaveAsSetting = ActiveDocument.path
        
        If Not Right$(FileSaveAsSetting, 1) = "\" And Not Right$(FileSaveAsSetting, 1) = "/" Then
            FileSaveAsSetting = FileSaveAsSetting + IIf(InStr(FileSaveAsSetting, "\") > 0, "\", "/")
        End If
        
        Dim dlg As FileDialog
        Set dlg = Application.FileDialog(msoFileDialogSaveAs)
        
        With Application.FileDialog(msoFileDialogSaveAs)
            .Title = "Save Copy as PDF"
            .AllowMultiSelect = False
            .ButtonName = "Save PDF"
            .FilterIndex = 7
            .initialFilename = FileSaveAsSetting & fileName
        End With
        Dim choice As Integer
        choice = Application.FileDialog(msoFileDialogSaveAs).show
        If choice <> 0 Then
            pdfFilename = FixPath(dlg.SelectedItems(1))
            dlg.Title = ""
            dlg.ButtonName = ""
            dlg.FilterIndex = 1
            Set dlg = Nothing
            ok = (pdfFilename > "")
'            ok = (Len(GetFileName(pdfFilename)) = 0)
'            If Not ok Then
'                ok = (vbOK = MsgBox("Overwrite file? ", vbCritical + vbOKCancel, "Save Copy as PDF"))
'            End If

            If ok Then
                ActiveDocument.ExportAsFixedFormat OutputFileName:= _
                    pdfFilename, ExportFormat:= _
                    wdExportFormatPDF, OpenAfterExport:=NoAddIn, OptimizeFor:= _
                    wdExportOptimizeForPrint, Range:=wdExportAllDocument, from:=1, To:=1, _
                    Item:=wdExportDocumentContent, IncludeDocProps:=True, KeepIRM:=True, _
                    CreateBookmarks:=wdExportCreateHeadingBookmarks, DocStructureTags:=False, _
                    BitmapMissingFonts:=True, UseISO19005_1:=False
                
                    ShowPDF = True
                
                On Error GoTo 0
            End If
        Else
            ok = (vbOK = MsgBox("Open temporary draft? ", vbCritical + vbOKCancel, "Save Copy as PDF"))
            If ok Then
                pdfFilename = UserTemp() & "\BGdoc\PDF\Draft " & fileName
                On Error Resume Next
                ActiveDocument.ExportAsFixedFormat OutputFileName:= _
                    pdfFilename, ExportFormat:= _
                    wdExportFormatPDF, OpenAfterExport:=NoAddIn, OptimizeFor:= _
                    wdExportOptimizeForPrint, Range:=wdExportAllDocument, from:=1, To:=1, _
                    Item:=wdExportDocumentContent, IncludeDocProps:=True, KeepIRM:=True, _
                    CreateBookmarks:=wdExportCreateHeadingBookmarks, DocStructureTags:=False, _
                    BitmapMissingFonts:=True, UseISO19005_1:=False
                
                    ShowPDF = True
                
                On Error GoTo 0
            End If
        End If
        
    End If
    
    If Not NoAddIn And ShowPDF Then
        Dim DX As New DOCXML
        Dim DocType As String
        Dim PDFLayOut As String
        DX.Init
        PDFLayOut = DX.ReadText("/DocumentInfo/DocumentInfo-PDFLayout")
   
        Addin.ModifyPDF pdfFilename, PDFLayOut
        Shell "explorer.exe """ & pdfFilename & """"
    End If
 
End Sub

'Sub ButtonTranslateDocument_Click(control As IRibbonControl)
'    ' MsgBox "Translate in Across"
'    Dim DX As New DOCXML
'    DX.Init
'
'    DX.LanguageUpdated = True
'    'DX.StructureUpdated = True
'    DX.FieldsUpdated = True
'    DX.WriteText "/DocumentInfo/DocumentInfo-FrontMatter", "Translate"
'    DX.UpdateDocument
'    Set DX = Nothing
'End Sub


Sub ButtonFigNumberPartList_Click(control As IRibbonControl)
    ' Obsolete
    MsgBox "Please call me on this one: Fig Number Part List"
    'CpFigRes.Main
    'Rewrite
End Sub

Sub ButtonChangePaperFormatA4Letter_Click(control As IRibbonControl)
    ' Obsolete
    MsgBox "ButtonChangePaperFormatA4Letter - Remove"
    'ChangePaperformatA4OrLetter
    'Rewrite
End Sub

Sub ButtonSetVisibleStyles_Click(control As IRibbonControl)
    ' Obsolete
    'MsgBox "ButtonSetVisibleStyles"
    SetVisibleStyles
End Sub

Sub ButtonComposeMasterFromFile_Click(control As IRibbonControl)
    'MsgBox "ButtonComposeMasterFromFile"
    'ComposeMasterFromFile.MAIN
    NewComposeMaster
    'Keep for now
End Sub

Sub ButtonFigureNumber_Click(control As IRibbonControl)
    FigureNumber
End Sub

Sub ButtonFigureItemList_Click(control As IRibbonControl)
    PosListTable
End Sub

Sub InsertTodaysDate()
    
    Dim updated As Boolean
    updated = True
    If Not IsLocked Then
        Dim DX As New DOCXML
        DX.Init
        DX.Prolog "Insert Todays Date", False
        On Error GoTo UpdatedFalse
            Selection.Collapse wdCollapseEnd
            Selection.text = Format(Now, "YYYY-MM-DD") & " "
            Selection.Collapse wdCollapseEnd
        On Error GoTo 0
ExitSub:
        DX.updated = updated
        DX.Epilog
        Set DX = Nothing
    End If
    
    Exit Sub
    
UpdatedFalse:
    updated = False
    Resume ExitSub
    
End Sub

Public Sub FigureNumber()
    If Not IsLocked Then
        Dim DX As New DOCXML
        DX.Init
        DX.Prolog "Insert Figure Caption"
        DX.updated = InsertNumber(DX, "Figure")
        DX.Epilog
        Set DX = Nothing
    End If
End Sub

Public Sub TableNumber()
    If Not IsLocked Then
        Dim DX As New DOCXML
        DX.Init
        DX.Prolog "Insert Table Caption"
        DX.updated = InsertNumber(DX, "Table")
        DX.Epilog
        Set DX = Nothing
    End If
End Sub

Sub ButtonTableNumber_Click(control As IRibbonControl)
    TableNumber
End Sub

Public Function InsertNumber(DX As DOCXML, tableOrFigure As String) As Boolean
    Dim CaptionHeading As String
    Dim FigureCaption As String
    Dim TableCaption As String
    Dim para As Paragraph
    Dim path As String
    Dim aTag() As String
    Dim startPos As Long
    Dim endPos As Long
    Dim rngText As Range
    Dim search As String
    Dim no As Integer
    Dim i As Integer
    Dim j As Integer
    Dim rng As Range
    Dim again As Boolean
    Dim first As Boolean
    Dim fldSeq As field
    Dim rngFound As Range
    
    startPos = Selection.Range.start
    Dim cc As ContentControl
    
    CaptionHeading = DX.ReadText("/DocumentInfo/DocumentInfo-CaptionHeading")
    FigureCaption = DX.ReadText("/DocumentLabel/DocumentLabel-FigureCaption")
    TableCaption = DX.ReadText("/DocumentLabel/DocumentLabel-TableCaption")
    
    On Error Resume Next
    Selection.Paragraphs(1).Range.Select
    Selection.Collapse wdCollapseStart

    ActiveDocument.attachedTemplate.BuildingBlockEntries("zz" & tableOrFigure & "Caption").Insert Where:=Selection.Range, RichText:=True
    If Err.Number <> 0 Then
    On Error GoTo 0
        MsgBox "Cannot insert caption here!", vbCritical + vbOKOnly, "Insert Caption Error"
        InsertNumber = False
        Exit Function
    End If
    On Error GoTo 0
    
    Set para = Selection.Paragraphs(Selection.Paragraphs.Count)
    Set cc = para.Range.ContentControls(1)
    
    aTag = Split(cc.tag, ":")
    path = "/" & Split(aTag(0), "-")(0) & "/" & aTag(0)
    If path = "/DocumentLabel/DocumentLabel-FigureCaption" Then
        cc.Range.text = FigureCaption
    ElseIf path = "/DocumentLabel/DocumentLabel-TableCaption" Then
        cc.Range.text = TableCaption
    End If
    
    Dim fld As field
    Set fld = para.Range.fields(1)
    
    If CaptionHeading = "none" Then
        Dim rngFld As Range
        Set rngFld = fld.result.Duplicate
        fld.Delete
        rngFld.MoveEnd
        rngFld.text = ""
    Else
        fld.code.text = "STYLEREF """ & CaptionHeading & """ \n"
    End If
    
    para.Style = IIf(tableOrFigure = "Figure", ActiveDocument.Styles(WdBuiltinStyle.wdStyleCaption), ActiveDocument.Styles("CaptionTable"))
    para.Range.fields.Update
    
    DX.SetCaptions tableOrFigure
    InsertNumber = True

End Function

Sub ButtonInsertCaution_Click(control As IRibbonControl)
    InsertCaution
End Sub

Sub ButtonInsertNotice_Click(control As IRibbonControl)
    InsertNotice
End Sub

Sub ButtonInsertHint_Click(control As IRibbonControl)
    InsertHint
End Sub

Sub ButtonInsertWarning_Click(control As IRibbonControl)
    InsertWarning
End Sub

Sub InsertCaution()
    InsertBlock "Caution"
End Sub

Sub InsertNotice()
    InsertBlock "Notice"
End Sub

Sub InsertWarning()
    InsertBlock "Warning"
End Sub

Sub InsertHint()
    InsertBlock "Hint"
End Sub


Sub InsertBlock(block As String)
    Dim updated As Boolean
    updated = True
    
    If Not IsLocked Then
        Dim DX As New DOCXML
        DX.Init
        DX.Prolog "Insert " & block
        
        On Error GoTo UpdatedFalse
        ActiveDocument.attachedTemplate.BuildingBlockEntries("zz" & block).Insert Where:=Selection.Range, RichText:=True
        Selection.MoveUp Unit:=wdLine, Count:=3
        Selection.MoveRight Unit:=wdCell
        On Error GoTo 0
ExitSub:
        DX.updated = updated
        DX.Epilog
        Set DX = Nothing
    End If
    
    Exit Sub
    
UpdatedFalse:
    updated = False
    Resume ExitSub
End Sub


Sub ButtonInsertPictureFromMenu_Click(control As IRibbonControl)
    BGInsertPicture
End Sub

Sub ButtonInsertPictureWithFormatting_Click(control As IRibbonControl)
    BGInsertPictureWithFormatting
End Sub

Sub ButtonShowwdDialogFormatParagraphTabTextFlow_Click(control As IRibbonControl)
    ShowDialogFormatParagraphTabTextFlow
End Sub

Public Sub ShowDialogFormatParagraphTabTextFlow()
    On Error GoTo ExitSub
    With Application.Dialogs.Item(wdDialogFormatParagraph)
        .DefaultTab = wdDialogFormatParagraphTabTextFlow
        .show
    End With
ExitSub:
    On Error GoTo 0
    Exit Sub
    
End Sub

Sub ButtonKeepWithNext_Click(control As IRibbonControl)
    KeepWithNext
End Sub

Public Sub KeepWithNext()
    If Not IsLocked Then
        On Error GoTo ExitSub
        Application.Selection.ParagraphFormat.KeepWithNext = Not Application.Selection.ParagraphFormat.KeepWithNext
ExitSub:
        On Error GoTo 0
    End If
End Sub

Sub ButtonKeepLinesTogether_Click(control As IRibbonControl)
    KeepLinesTogether
End Sub

Public Sub KeepLinesTogether()
    If Not IsLocked Then
        On Error GoTo ExitSub
        Application.Selection.ParagraphFormat.KeepTogether = Not Application.Selection.ParagraphFormat.KeepTogether
ExitSub:
        On Error GoTo 0
    End If
End Sub

Sub ButtonPageBreakBefore_Click(control As IRibbonControl)
    PageBreakBefore
End Sub

Public Sub PageBreakBefore()
    If Not IsLocked Then
        On Error GoTo ExitSub
        Application.Selection.ParagraphFormat.PageBreakBefore = Not Application.Selection.ParagraphFormat.PageBreakBefore
ExitSub:
        On Error GoTo 0
    End If
End Sub

Sub ButtonNoRowSplit_Click(control As IRibbonControl)
    NoRowSplit
End Sub

Public Sub NoRowSplit()
    If Not IsLocked Then
        On Error GoTo ExitSub
        Application.Selection.rows.AllowBreakAcrossPages = Not Application.Selection.rows.AllowBreakAcrossPages
ExitSub:
        On Error GoTo 0
    End If
End Sub

Sub ButtonJustifyTable_Click(control As IRibbonControl)
    JustifyTable
End Sub

Public Sub JustifyTable()
    If Not IsLocked Then
        On Error GoTo ExitSub
            Dim sty As Style
            Set sty = ActiveDocument.Styles(wdStyleNormal)
            If sty.ParagraphFormat.LeftIndent > 63 Then
                If sty.ParagraphFormat.LeftIndent < 65 Then
                    With Application.Selection.Tables(1)
                        .TopPadding = Application.CentimetersToPoints(0)
                        .BottomPadding = Application.CentimetersToPoints(0)
                        .LeftPadding = Application.CentimetersToPoints(0.1)
                        .RightPadding = Application.CentimetersToPoints(0.1)
                        .Spacing = 0
                        .AllowPageBreaks = True
                        .AllowAutoFit = False
                        .rows.LeftIndent = Application.CentimetersToPoints(2.26)
                        .PreferredWidthType = WdPreferredWidthType.wdPreferredWidthPercent
                        .PreferredWidth = 86
                    End With
                Else
                    Selection.Tables(1).AutoFitBehavior (Word.WdAutoFitBehavior.wdAutoFitWindow)
                End If
            Else
                Selection.Tables(1).AutoFitBehavior (Word.WdAutoFitBehavior.wdAutoFitWindow)
            End If
ExitSub:
        On Error GoTo 0
    End If
End Sub

Sub ButtonPrintCurrentPage_Click(control As IRibbonControl)
    PrintCurrentPage
End Sub

Public Sub PrintCurrentPage()
    On Error GoTo ExitSub
    ActiveDocument.PrintOut background:=True, Append:=False, _
                           Range:=Word.WdPrintOutRange.wdPrintCurrentPage, _
                           Item:=Word.WdPrintOutItem.wdPrintDocumentContent, _
                           Copies:="1", Pages:="1", PageType:=Word.WdPrintOutPages.wdPrintAllPages, _
                           PrintToFile:=False, Collate:=True, ManualDuplexPrint:=False
ExitSub:
    On Error GoTo 0
    Exit Sub
End Sub

  
Public Sub PosListTable()
    If Not IsLocked Then
        Dim DX As New DOCXML
        DX.Init
        DX.Prolog "Insert Parts List"
    
On Error GoTo Failed
        ActiveDocument.Tables.Add Range:=Selection.Range, NumRows:=1, NumColumns:= _
            4, DefaultTableBehavior:=wdWord9TableBehavior, AutoFitBehavior:= _
            wdAutoFitFixed
        ActiveWindow.View.TableGridlines = Not ActiveWindow.View.TableGridlines
        Selection.Tables(1).Select
        SetStyle "PosListeTable", DX
        Selection.Tables(1).PreferredWidthType = wdPreferredWidthPoints
        Selection.Tables(1).PreferredWidth = CentimetersToPoints(14)
        Selection.Tables(1).rows.LeftIndent = CentimetersToPoints(2.26)
        Selection.rows.AllowBreakAcrossPages = False
        Selection.Borders(wdBorderTop).LineStyle = wdLineStyleNone
        Selection.Borders(wdBorderLeft).LineStyle = wdLineStyleNone
        Selection.Borders(wdBorderBottom).LineStyle = wdLineStyleNone
        Selection.Borders(wdBorderRight).LineStyle = wdLineStyleNone
        Selection.Borders(wdBorderHorizontal).LineStyle = wdLineStyleNone
        Selection.Borders(wdBorderVertical).LineStyle = wdLineStyleNone
        Selection.Borders(wdBorderDiagonalDown).LineStyle = wdLineStyleNone
        Selection.Borders(wdBorderDiagonalUp).LineStyle = wdLineStyleNone
        Selection.Tables(1).Select
        Selection.SelectColumn
        Selection.MoveLeft Unit:=wdCharacter, Count:=3, Extend:=wdExtend
        Selection.SelectColumn
        Selection.Columns.PreferredWidthType = wdPreferredWidthPoints
        Selection.Columns.PreferredWidth = CentimetersToPoints(0.6)
        Selection.Move Unit:=wdColumn, Count:=1
        Selection.SelectColumn
        Selection.Columns.PreferredWidthType = wdPreferredWidthPoints
        Selection.Columns.PreferredWidth = CentimetersToPoints(7)
        Selection.Move Unit:=wdColumn, Count:=1
        Selection.SelectColumn
        Selection.Columns.PreferredWidthType = wdPreferredWidthPoints
        Selection.Columns.PreferredWidth = CentimetersToPoints(0.6)
        Selection.Move Unit:=wdColumn, Count:=1
        Selection.SelectColumn
        Selection.Columns.PreferredWidthType = wdPreferredWidthPoints
        Selection.Columns.PreferredWidth = CentimetersToPoints(7)
        Selection.rows.AllowBreakAcrossPages = False
        Selection.Tables(1).Select
        With Selection.Tables(1)
            .TopPadding = CentimetersToPoints(0)
            .BottomPadding = CentimetersToPoints(0)
            .LeftPadding = CentimetersToPoints(0.1)
            .RightPadding = CentimetersToPoints(0.1)
            .Spacing = 0
            .AllowPageBreaks = True
            .AllowAutoFit = True
            Selection.MoveLeft Unit:=wdCharacter, Count:=1
            Selection.MoveRight Unit:=wdCell, Count:=1
            .Cell(1, 1).Range.text = "1."
            .Cell(1, 3).Range.text = "2."
        End With
        DX.updated = True
        
        
ExitFunction:
    
        On Error GoTo 0
        DX.Epilog
        Set DX = Nothing
    End If
    
    Exit Sub
Failed:
    DX.updated = False
    Resume ExitFunction
End Sub
        
Public Sub BGInsertNormalNum()
    InsertSequenceNumber "NormalNum", "NormalNum"
End Sub

Public Sub BGInsertSeqNum()
    InsertSequenceNumber "SeqNum", "NormalNum"
End Sub

Public Sub BGInsertSeqNum2()
    InsertSequenceNumber "SeqNum2", "NormalNum"
End Sub

Public Sub BGInsertSeqNum3()
    InsertSequenceNumber "SeqNum3", "NormalNum"
End Sub

Public Sub BGInsertSeqNum4()
    InsertSequenceNumber "SeqNum4", "NormalNum"
End Sub

Public Sub InsertSequenceNumber(styleName As String, seqName As String)
    If Not IsLocked Then
        Dim fld As field
        Dim oldStyle As String
        Dim rng As Range
        
        Dim DX As New DOCXML
        DX.Init
        DX.Prolog styleName
        LeaveContentControl
        oldStyle = Selection.Paragraphs(1).Range.Style.NameLocal
        If (oldStyle Like "Seq*" Or oldStyle Like "NormalNum*") And Selection.Paragraphs(1).Range.fields.Count >= 1 Then
            SetStyle styleName, DX
            Set fld = Selection.Paragraphs(1).Range.fields(1)
            If styleName = "NormalNum" And oldStyle Like "Seq*" Then
                Set rng = fld.result
                rng.Collapse wdCollapseEnd
                rng.Delete wdCharacter, 1
                Set rng = Selection.Paragraphs(1).Range
                rng.Collapse wdCollapseStart
                rng.InsertBefore "."
            ElseIf oldStyle = "NormalNum" And styleName Like "Seq*" Then
                Set rng = fld.result
                rng.MoveEnd wdCharacter, 1
                rng.Collapse wdCollapseEnd
                rng.InsertAfter "."
                Set rng = Selection.Paragraphs(1).Range
                rng.Collapse wdCollapseStart
                rng.Delete wdCharacter, 1
            End If
        Else
            SetStyle styleName, DX
            Selection.Paragraphs(1).Range.Select
            Selection.Collapse wdCollapseStart
            LeaveContentControl
            If Not styleName Like "Seq*" Then Selection.TypeText "."
            Selection.Paragraphs(1).Range.Select
            Selection.Collapse wdCollapseStart
            Selection.text = ""
            Selection.Collapse wdCollapseEnd
            If Not styleName Like "Seq*" Then Selection.Move wdCharacter, 1
            Set fld = Selection.fields.Add(Range:=Selection.Range, Type:=wdFieldSequence, text:=seqName, PreserveFormatting:=False)
            fld.Select
            Selection.Collapse wdCollapseEnd
            If styleName Like "Seq*" Then Selection.TypeText "."
            Selection.TypeText text:=vbTab
            Selection.Paragraphs(1).Range.Select
            Selection.MoveEnd wdCharacter, -1
            Selection.Collapse wdCollapseEnd
        End If
        DX.updated = True
        DX.Epilog
        Set DX = Nothing
    End If
End Sub

Public Sub BGResetNormalNum()
    Dim rng As Range
    Dim fld As field
    Dim updated As Boolean
    updated = True
    
    If Not IsLocked Then
        Dim DX As New DOCXML
        DX.Init
        DX.Prolog "Reset NormalNum"
        
        Set rng = Selection.Paragraphs(1).Range
        If rng.fields.Count > 0 Then
            Set fld = rng.fields(1)
            If Trim(LCase(fld.code.text)) Like "seq normalnum*" Then
                Dim strValue As String
                strValue = Replace(Replace(InputBox("Enter new start number:", "Reset numbering", "1"), ".", "x"), ",", "x")
                If IsNumeric(strValue) Then
                    If Abs(Int(strValue)) = strValue Then
                        fld.code.text = "SEQ NormalNum " & "\r" & strValue & " \* MERGEFORMAT"
                        ActiveDocument.Range(rng.start, ActiveDocument.Range.End).fields.Update
                    Else
                        updated = False
                        MsgBox "Not a valid number", vbOKOnly, "Cannot Reset Number"
                    End If
                Else
                    updated = False
                    MsgBox "Not a valid number", vbOKOnly, "Cannot Reset Number"
                End If
            End If
        Else
            updated = False
            MsgBox "Insert a number field first", vbOKOnly, "Cannot Reset Number"
        End If
        
        DX.updated = updated
        DX.Epilog
        Set DX = Nothing
        
    End If
End Sub

Public Function NextImage(rng As Range) As Boolean
    Dim inl As InlineShape
    Dim shp As Shape
    Dim i As Integer
    
    If rng.End >= ActiveDocument.Content.End Then
        NextImage = False
        Exit Function
    End If
    
    rng.SetRange rng.End, ActiveDocument.Content.End
    If rng.InlineShapes.Count > 0 Then
        For i = 1 To rng.InlineShapes.Count
            Set inl = rng.InlineShapes(i)
            If InlineIsPictureOrObject(inl) Then
                Exit For
            End If
        Next
        If i > rng.InlineShapes.Count Then
            Set inl = Nothing
        End If
    End If
    If rng.ShapeRange.Count > 0 Then
        For i = 1 To rng.ShapeRange.Count
            Set shp = rng.ShapeRange(i)
            If ShapeIsPictureOrObject(shp) Then
                Exit For
            End If
        Next
        If i > rng.ShapeRange.Count Then
            Set shp = Nothing
        End If
    End If
    If inl Is Nothing And shp Is Nothing Then
        NextImage = False
    ElseIf Not inl Is Nothing Then
        If shp Is Nothing Then
            inl.Select
            ActiveWindow.ScrollIntoView inl
        Else
            If shp.Anchor.start < inl.Range.start Then
                shp.Select
                ActiveWindow.ScrollIntoView shp
            Else
                inl.Select
                ActiveWindow.ScrollIntoView inl
            End If
        End If
        NextImage = True
    Else
        shp.Select
        ActiveWindow.ScrollIntoView shp
            NextImage = True
    End If
End Function

Public Function PreviousImage(rng As Range) As Boolean
    Dim inl As InlineShape
    Dim shp As Shape
    Dim i As Integer
    
    If rng.start <= ActiveDocument.Content.start Then
        PreviousImage = False
        Exit Function
    End If
    
    rng.SetRange ActiveDocument.Content.start, rng.start
    If rng.InlineShapes.Count > 0 Then
        For i = rng.InlineShapes.Count To 1 Step -1
            Set inl = rng.InlineShapes(i)
            If InlineIsPictureOrObject(inl) Then
                Exit For
            End If
        Next
        If i = 0 Then
            Set inl = Nothing
        End If
    End If
    If rng.ShapeRange.Count > 0 Then
        For i = rng.ShapeRange.Count To 1 Step -1
            Set shp = rng.ShapeRange(i)
            If ShapeIsPictureOrObject(shp) Then
                Exit For
            End If
        Next
        If i = 0 Then
            Set shp = Nothing
        End If
    End If
    If inl Is Nothing And shp Is Nothing Then
        PreviousImage = False
    ElseIf Not inl Is Nothing Then
        If shp Is Nothing Then
            inl.Select
            ActiveWindow.ScrollIntoView inl
        Else
            If shp.Anchor.start > inl.Range.start Then
                shp.Select
                ActiveWindow.ScrollIntoView shp
            Else
                inl.Select
                ActiveWindow.ScrollIntoView inl
            End If
        End If
        PreviousImage = True
    Else
        shp.Select
        ActiveWindow.ScrollIntoView shp
        PreviousImage = True
    End If
End Function


Public Sub ButtonNextImage_Click(control As IRibbonControl)
    NextImage Selection.Range

End Sub

Public Sub ButtonFirstImage_Click(control As IRibbonControl)
    
    Selection.HomeKey Unit:=wdStory
    NextImage Selection.Range
End Sub

Public Sub ButtonLastImage_Click(control As IRibbonControl)
    
    Selection.EndKey Unit:=wdStory
    PreviousImage Selection.Range
   
End Sub

Public Sub ButtonPreviousImage_Click(control As IRibbonControl)
    PreviousImage Selection.Range

End Sub

Public Sub ButtonCheckPictures_Click(control As IRibbonControl)
    ActiveWindowHandle = GetActiveWindow

    Dim frm As New PictureTool
    frm.show vbModal
End Sub

Public Sub ButtonRefreshPictureFromDisk_Click(control As IRibbonControl)
    RefreshPictureFromDisk
End Sub

Public Sub RefreshPictureFromDisk()
    If Not IsLocked Then
    
On Error GoTo Failed
        Dim DX As New DOCXML
        Dim rng As Range
        Set rng = Selection.Range
        If rng.InlineShapes.Count + rng.ShapeRange.Count = 1 Then
            DX.Init
            DX.Prolog "Refresh Picture From Disk"

            Dim inlSelect As InlineShape
            Dim shpSelect As Shape
            Dim idxSelect As Integer

            If rng.InlineShapes.Count = 1 Then
                Set inlSelect = rng.InlineShapes(1)
                If Not inlSelect.LinkFormat Is Nothing Then
                    inlSelect.LinkFormat.Update
                End If
            Else
                Set shpSelect = rng.ShapeRange(1)
                If Not shpSelect.LinkFormat Is Nothing Then
                    shpSelect.LinkFormat.Update
                End If
            End If

            DX.updated = True
        Else
            MsgBox ("Select a single picture")
            Exit Sub
        End If
ExitSub:
        On Error GoTo 0
        If Not DX Is Nothing Then
            DX.Epilog
            Set DX = Nothing
        End If
    End If
    
    Exit Sub
Failed:
    If Not DX Is Nothing Then DX.updated = False
    Resume ExitSub
End Sub
            
Public Sub ButtonH1_Click(control As IRibbonControl)
    If Not IsLocked Then SetStyle wdStyleHeading1
End Sub

Public Sub ButtonH2_Click(control As IRibbonControl)
    If Not IsLocked Then SetStyle wdStyleHeading2
End Sub

Public Sub ButtonH3_Click(control As IRibbonControl)
    If Not IsLocked Then SetStyle wdStyleHeading3
End Sub

Public Sub ButtonH4_Click(control As IRibbonControl)
    If Not IsLocked Then SetStyle wdStyleHeading4
End Sub

Public Sub ButtonH5_Click(control As IRibbonControl)
    If Not IsLocked Then SetStyle wdStyleHeading5
End Sub

Public Sub ButtonH6_Click(control As IRibbonControl)
    If Not IsLocked Then SetStyle wdStyleHeading6
End Sub

Public Sub ButtonH7_Click(control As IRibbonControl)
    If Not IsLocked Then SetStyle wdStyleHeading7
End Sub

Public Sub ButtonH8_Click(control As IRibbonControl)
    If Not IsLocked Then SetStyle wdStyleHeading8
End Sub

Public Sub ButtonH9_Click(control As IRibbonControl)
    If Not IsLocked Then SetStyle "ParmHead"
End Sub

Sub ButtonNormal_Click(control As IRibbonControl)
    If Not IsLocked Then SetStyle wdStyleNormal
End Sub

Sub ButtonNormalNum_Click(control As IRibbonControl)
    BGInsertNormalNum
End Sub

Sub ButtonResetNum_Click(control As IRibbonControl)
    BGResetNormalNum
End Sub

Sub ButtonBullet1_Click(control As IRibbonControl)
    If Not IsLocked Then SetStyle "BulletList"
End Sub

Sub ButtonBullet2_Click(control As IRibbonControl)
    If Not IsLocked Then SetStyle "BulletList 2"
End Sub

Sub ButtonBullet3_Click(control As IRibbonControl)
    If Not IsLocked Then SetStyle "BulletList 3"
End Sub

Sub ButtonNumList1_Click(control As IRibbonControl)
    If Not IsLocked Then SetStyle "NumList"
End Sub

Sub ButtonNumList2_Click(control As IRibbonControl)
    If Not IsLocked Then SetStyle "NumList 2"
End Sub

Sub ButtonNumList3_Click(control As IRibbonControl)
    If Not IsLocked Then SetStyle "NumList 3"
End Sub

Sub ButtonNumListA_Click(control As IRibbonControl)
    If Not IsLocked Then SetStyle "NumListAlpha"
End Sub

Sub ButtonSeqNum1_Click(control As IRibbonControl)
    BGInsertSeqNum
End Sub

Sub ButtonSeqNum2_Click(control As IRibbonControl)
    BGInsertSeqNum2
End Sub

Sub ButtonSeqNum3_Click(control As IRibbonControl)
    BGInsertSeqNum3
End Sub

Sub ButtonSeqNum4_Click(control As IRibbonControl)
    BGInsertSeqNum4
End Sub

Sub ButtonSeqNumR_Click(control As IRibbonControl)
    BGResetNormalNum
End Sub

Sub ButtonIndent1_Click(control As IRibbonControl)
    If Not IsLocked Then SetStyle "Indent"
End Sub

Sub ButtonIndent2_Click(control As IRibbonControl)
    If Not IsLocked Then SetStyle "Indent 2"
End Sub

Sub ButtonIndent3_Click(control As IRibbonControl)
    If Not IsLocked Then SetStyle "Indent 3"
End Sub

Sub ButtonHangingIndent1_Click(control As IRibbonControl)
    If Not IsLocked Then SetStyle "Hanging Indent"
End Sub

Sub ButtonHangingIndent2_Click(control As IRibbonControl)
    If Not IsLocked Then SetStyle "Hanging Indent 2"
End Sub

Sub ButtonHangingIndent3_Click(control As IRibbonControl)
    If Not IsLocked Then SetStyle "Hanging Indent 3"
End Sub

Sub ButtonHangingIndentI1_Click(control As IRibbonControl)
    If Not IsLocked Then SetStyle "Hanging Indent i1"
End Sub

Sub ButtonHangingIndentI2_Click(control As IRibbonControl)
    If Not IsLocked Then SetStyle "Hanging Indent i2"
End Sub

Sub ButtonHangingIndentI3_Click(control As IRibbonControl)
    If Not IsLocked Then SetStyle "Hanging Indent i3"
End Sub

Sub ButtonHangingIndentII1_Click(control As IRibbonControl)
    If Not IsLocked Then SetStyle "Hanging Indent ii1"
End Sub

Sub ButtonHangingIndentII2_Click(control As IRibbonControl)
    If Not IsLocked Then SetStyle "Hanging Indent ii2"
End Sub

Sub ButtonHangingIndentII3_Click(control As IRibbonControl)
    If Not IsLocked Then SetStyle "Hanging Indent ii3"
End Sub

Sub ButtonHangingIndentNo_Click(control As IRibbonControl)
    If Not IsLocked Then SetStyle "Hanging Indent No."
End Sub

Sub ButtonTableNormalHeader_Click(control As IRibbonControl)
    If Not IsLocked Then SetStyle "Table Header"
End Sub

Sub ButtonTableNormalHeaderCenter_Click(control As IRibbonControl)
    If Not IsLocked Then SetStyle "Table Header Center"
End Sub

Sub ButtonTableNormalHeaderRight_Click(control As IRibbonControl)
    If Not IsLocked Then SetStyle "Table Header Right"
End Sub

Sub ButtonTableNormalText_Click(control As IRibbonControl)
    If Not IsLocked Then SetStyle "Table Text"
End Sub

Sub ButtonTableNormalTextCenter_Click(control As IRibbonControl)
    If Not IsLocked Then SetStyle "Table Text center"
End Sub

Sub ButtonTableNormalTextRight_Click(control As IRibbonControl)
    If Not IsLocked Then SetStyle "Table Text right"
End Sub

Sub ButtonTableNormalBulletList_Click(control As IRibbonControl)
    If Not IsLocked Then SetStyle "TableBulletList"
End Sub

Sub ButtonTableNormalNumList_Click(control As IRibbonControl)
    If Not IsLocked Then SetStyle "TableNumList"
End Sub

Sub ButtonTableNormalIndent_Click(control As IRibbonControl)
    If Not IsLocked Then SetStyle "Table Indent"
End Sub

Sub ButtonTableSmallHeader_Click(control As IRibbonControl)
    If Not IsLocked Then SetStyle "Table Header Small"
End Sub

Sub ButtonTableSmallHeaderCenter_Click(control As IRibbonControl)
    If Not IsLocked Then SetStyle "Table Header Small C"
End Sub

Sub ButtonTableSmallHeaderRight_Click(control As IRibbonControl)
    If Not IsLocked Then SetStyle "Table Header Small R"
End Sub

Sub ButtonTableSmallText_Click(control As IRibbonControl)
    If Not IsLocked Then SetStyle "Table Small"
End Sub

Sub ButtonTableSmallTextCenter_Click(control As IRibbonControl)
    If Not IsLocked Then SetStyle "Table Small Center"
End Sub

Sub ButtonTableSmallTextRight_Click(control As IRibbonControl)
    If Not IsLocked Then SetStyle "Table Small Right"
End Sub

Sub ButtonTableSmallBulletList_Click(control As IRibbonControl)
    If Not IsLocked Then SetStyle "TableBulletListSmall"
End Sub

Sub ButtonTableSmallNumList_Click(control As IRibbonControl)
    If Not IsLocked Then SetStyle "TableNumListSmall"
End Sub

Sub ButtonTableSmallIndent_Click(control As IRibbonControl)
    If Not IsLocked Then SetStyle "Table Indent Small"
End Sub

Sub ButtonBold_Click(control As IRibbonControl)
    If Not IsLocked Then SetStyle "NormalBold"
End Sub

Sub ButtonBGDocQuickGuide_Click(control As IRibbonControl)
    Dim myShell As Object
    Set myShell = CreateObject("WScript.Shell")
    myShell.run "http://extranet.crisplant.com/site/SoftwareProducts/Shared%20Documents/Documentation/BGdoc%20Template/BGdoc_QuickGuide_EN.pdf"
End Sub

Sub ButtonBGdocUserGuide_Click(control As IRibbonControl)
    Dim myShell As Object
    Set myShell = CreateObject("WScript.Shell")
    myShell.run "http://extranet.crisplant.com/site/SoftwareProducts/Shared%20Documents/Documentation/BGdoc%20Template/BGdoc_UserGuide_EN.pdf"
End Sub

Sub ButtonInsertPictureFrame_Click(control As IRibbonControl)
    If Not IsLocked Then SetStyle "Figur"
End Sub

Sub ButtonUpdateStyles_Click(control As IRibbonControl)
    If Not ActiveDocument.ReadOnly Then
        Dim DX As New DOCXML
        DX.Init
        DX.Prolog "Reload Template Styles"
        DX.updated = DX.ReloadTemplateStyles
        DX.Epilog
        Set DX = Nothing
    End If
End Sub

Sub ButtonInsertDate_Click(control As IRibbonControl)
    Dim updated As Boolean
    updated = True
    
    If Not IsLocked Then
        Dim DX As New DOCXML
        DX.Init
        DX.Prolog "Insert Date"
        On Error GoTo UpdatedFalse
        LeaveContentControl
        Dim cc As ContentControl
        Set cc = Selection.Range.ContentControls.Add(wdContentControlDate)
        cc.DateDisplayFormat = "yyyy-MM-dd"
        cc.SetPlaceholderText , , " Enter a Date "
        
        On Error GoTo 0
ExitSub:
        DX.updated = updated
        DX.Epilog
        Set DX = Nothing
    End If
    
    Exit Sub
    
UpdatedFalse:
    updated = False
    Resume ExitSub

End Sub

Sub KeepSiegling()
'
' KeepSiegling Macro
' Macroen fjerner alle linjer m|fffd|rket med [VAR270] (Ammeraal belts)
'
    If Not ActiveDocument.ReadOnly Then
        Selection.HomeKey Unit:=wdStory
        Selection.find.ClearFormatting
        With Selection.find
            .text = "[VAR270]"
            .Replacement.text = ""
            .Forward = True
            .Wrap = wdFindContinue
            .Format = False
            .MatchCase = False
            .MatchWholeWord = False
            .MatchByte = False
            .MatchWildcards = False
            .MatchSoundsLike = False
            .MatchAllWordForms = False
        End With
        Selection.find.Execute
        While Selection.find.found
        Selection.SelectRow
        Selection.rows.Delete
            Selection.find.Execute
        Wend
        
        Selection.HomeKey Unit:=wdStory
        Selection.find.ClearFormatting
        Selection.find.Replacement.ClearFormatting
        With Selection.find
            .text = "[VAR0]"
            .Replacement.text = ""
            .Forward = True
            .Wrap = wdFindContinue
            .Format = False
            .MatchCase = False
            .MatchWholeWord = False
            .MatchByte = False
            .MatchWildcards = False
            .MatchSoundsLike = False
            .MatchAllWordForms = False
        End With
        Selection.find.Execute Replace:=wdReplaceAll
    End If
End Sub
Sub KeepAmmeraal()
'
' KeepAmmeraal Macro
' Macroen fjerner alle linjer m|fffd|rket med [VAR270] (Ammeraal belts)
'
    If Not ActiveDocument.ReadOnly Then
        Selection.HomeKey Unit:=wdStory
        Selection.find.ClearFormatting
        With Selection.find
            .text = "[VAR0]"
            .Replacement.text = ""
            .Forward = True
            .Wrap = wdFindContinue
            .Format = False
            .MatchCase = False
            .MatchWholeWord = False
            .MatchByte = False
            .MatchWildcards = False
            .MatchSoundsLike = False
            .MatchAllWordForms = False
        End With
        Selection.find.Execute
        While Selection.find.found
        Selection.SelectRow
        Selection.rows.Delete
            Selection.find.Execute
        Wend
        
        
        Selection.HomeKey Unit:=wdStory
        Selection.find.ClearFormatting
        Selection.find.Replacement.ClearFormatting
        With Selection.find
            .text = "[VAR270]"
            .Replacement.text = ""
            .Forward = True
            .Wrap = wdFindContinue
            .Format = False
            .MatchCase = False
            .MatchWholeWord = False
            .MatchByte = False
            .MatchWildcards = False
            .MatchSoundsLike = False
            .MatchAllWordForms = False
        End With
        Selection.find.Execute Replace:=wdReplaceAll
    End If
End Sub

Sub ButtonKeepAmmeraal_Click(control As IRibbonControl)
    If Not IsLocked Then KeepAmmeraal
End Sub

Sub ButtonKeepSiegling_Click(control As IRibbonControl)
    If Not IsLocked Then KeepSiegling
End Sub

Sub ButtonFullUpdate_Click(control As IRibbonControl)
    'Obsolete
    'GetManager.GetBGDoc(ActiveDocument).Update "Full"
End Sub

Public Sub CompareWithConversionBase(frm As MainForm)
    frm.DoCancel
    Dim fullName As String
    Dim OldDoc As Document
    
    Dim DX As New DOCXML
    DX.Init
    Dim oNode As CustomXMLNode
    Set oNode = DX.ReadNode("/DocumentInfo/Conversion/Conversion-FromDoc")
    'ConversionFrom - Deleted
    'If oNode Is Nothing Then Set oNode = DX.ReadNode("/DocumentInfo/Conversion/Conversion-FromDoc")
    If Not oNode Is Nothing Then
        fullName = FixPath(oNode.text)
        On Error Resume Next
        Set OldDoc = Application.Documents.Open(fullName, , False, False)
        On Error GoTo 0
        If Not OldDoc Is Nothing Then
            OldDoc.Activate
            ActiveWindow.ActivePane.View.Zoom.PageFit = wdPageFitFullPage
            Selection.HomeKey Unit:=wdStory
            DX.ThisDoc.Activate
            ActiveWindow.ActivePane.View.Zoom.PageFit = wdPageFitFullPage
            Selection.HomeKey Unit:=wdStory
            DoEvents
            DX.ThisDoc.Activate
            Selection.HomeKey Unit:=wdStory
            DoEvents
            DX.ThisDoc.Windows.CompareSideBySideWith OldDoc
            DX.ThisDoc.Windows.ResetPositionsSideBySide
            DX.ThisDoc.Windows.SyncScrollingSideBySide = False
        End If
    End If
    Set DX = Nothing
End Sub

Attribute VB_Name = "bg_Convert"
Option Explicit

Public Sub ConvertDocumentToBGDoc(fromFullName As Variant, toFullName As Variant)
    GetManager.GetBGDocFromFullName(CStr(toFullName)).ConvertToBGDoc CStr(fromFullName)
    ActivateDocumentTab
End Sub

Public Function BatchConvertDocumentToBGDoc(fromFullName As Variant, toFullName As Variant, workflowLabel As Variant, image As Variant, projectNo As Variant, docTo As Word.Document) As String
    GetManager.GetBGDoc(docTo).BatchConvertToBGDoc CStr(fromFullName), CStr(toFullName), workflowLabel, image, projectNo
End Function

Public Function UsesOldDocumentationTemplate(Template As String, altTemplate As String) As Boolean
    Dim templates() As Variant
    Template = LCase(Template)
    altTemplate = LCase(altTemplate)
    Dim found As Boolean
    found = False
    Dim i As Integer
    
    templates = Array("cpdoc1_0.dot", "cpdoc2_0.dot", "cpdoc2000.dot", "cpdoc2003.dot", "cpdoc2010.dotm", _
                                               "cpir2002.dot", "cpmap2000.dot", "cpmap2003.dot", "fki_chronopost_w2000.dot", _
                                               "fki_sd_11038.dot", "fki_solystic_w2000.dot", "fki_spia_doc2003.dot", "fki_spia_doc2003_zh.dot", "fkidoc2003.dot", _
                                               "fkiirdoc2000.dot", "fkiirdoc2003.dot", "mechanica_2003.dot", "mod|fffd|leword.dot", "motion06_2003.dot", _
                                               "t_aena_doc2003.dot", "t_changi_doc2003.dot", "t_cp-doha_2003.dot", "t_fki-doha_2003.dot", "vi_fki_cdg1.dot", "wcldocustyle.dot")
        
    For i = 1 To UBound(templates)
        If Template = templates(i) Then
            found = True
            Exit For
        End If
    Next
    If Not found Then
        For i = 1 To UBound(templates)
            If altTemplate = templates(i) Then
                found = True
                Exit For
            End If
        Next
    End If
    UsesOldDocumentationTemplate = found
End Function

Public Function ReadCaptionTOCTOFTOT(doc As Document, DX As DOCXML) As Boolean
    Dim showFrontMatter As Boolean
    Dim rng As Range
    Dim tocs As TablesOfContents
    Dim TOC As TableOfContents
    Dim tofs As TablesOfFigures
    Dim tof As TableOfFigures
    Dim hs As HeadingStyle
    DX.WriteText "/DocumentInfo/DocumentInfo-TOC", ""
    DX.WriteText "/DocumentInfo/DocumentInfo-TOF", ""
    DX.WriteText "/DocumentInfo/DocumentInfo-TOT", ""
    
    Set tocs = doc.TablesOfContents
    
    'Debug.Print "TOCS"
    If tocs.Count > 0 Then
        showFrontMatter = True
        DX.WriteText "/DocumentInfo/DocumentInfo-TOC", "Standard"
        Set TOC = tocs(1)
        Set rng = TOC.Range
        'Debug.Print rng.fields(1).code
        DX.WriteText "/DocumentInfo/DocumentInfo-TOC", "Standard"
        If DX.DocType = "O & M Spare Parts Catalogue" Then
            DX.WriteText "/DocumentInfo/DocumentInfo-TOC-HeadingLevels", "1"
        Else
            DX.WriteText "/DocumentInfo/DocumentInfo-TOC-HeadingLevels", TOC.LowerHeadingLevel
        End If
        DX.WriteText "/DocumentInfo/DocumentInfo-TOC-Headings", IIf(TOC.HeadingStyles.Count > 0, "Include Parm Head", "")
    End If
   
    'Debug.Print "TOFS"
    Set tofs = doc.TablesOfFigures
    For Each tof In tofs
        showFrontMatter = True
        Set rng = tof.Range
        'Debug.Print rng.fields(1).code
        If LCase(tof.caption) = "figure" Then
            DX.WriteText "/DocumentInfo/DocumentInfo-TOF", "Standard"
        ElseIf LCase(tof.caption) = "table" Then
            DX.WriteText "/DocumentInfo/DocumentInfo-TOT", "Standard"
        ElseIf LCase(tof.HeadingStyles(1)) = "caption" Then
                DX.WriteText "/DocumentInfo/DocumentInfo-TOF", "Standard"
        ElseIf LCase(tof.HeadingStyles(1)) = "captiontable" Then
                DX.WriteText "/DocumentInfo/DocumentInfo-TOT", "Standard"
        End If
    Next
    
    'Fields
    DX.WriteText "/DocumentInfo/DocumentInfo-CaptionHeading", "none"
    Dim fld As field
    Dim foundTableOrFigure As Boolean
    foundTableOrFigure = False
    For Each fld In doc.fields
        If fld.Type = wdFieldStyleRef Then
            'Debug.Print fld.code
            If LCase(fld.code) Like "*""1""*" Or LCase(fld.code) Like "* 1 *" Or LCase(fld.code) Like "*heading 1*" Then
                DX.WriteText "/DocumentInfo/DocumentInfo-CaptionHeading", "1"
                Exit For
            End If
            If LCase(fld.code) Like "*""2""*" Or LCase(fld.code) Like "* 2 *" Or LCase(fld.code) Like "*heading 2*" Then
                DX.WriteText "/DocumentInfo/DocumentInfo-CaptionHeading", "2"
                Exit For
            End If
            If LCase(fld.code) Like "*""3""*" Or LCase(fld.code) Like "* 3 *" Or LCase(fld.code) Like "*heading 3*" Then
                DX.WriteText "/DocumentInfo/DocumentInfo-CaptionHeading", "3"
                Exit For
            End If
        ElseIf fld.Type = wdFieldSequence Then
            If LCase(fld.code.text) Like "*table*" Or LCase(fld.code.text) Like "*figure*" Then
                foundTableOrFigure = True
            End If
        End If
    Next
    If DX.ReadText("/DocumentInfo/DocumentInfo-CaptionHeading") = "none" And Not foundTableOrFigure Then
        DX.WriteText "/DocumentInfo/DocumentInfo-CaptionHeading", "1"
    End If
    ReadCaptionTOCTOFTOT = showFrontMatter
End Function

Public Sub ReadFrontPage(doc As Document, file As CPDocFile)
    Dim rngFP As Word.Range
    Dim rngCP As Word.Range
    Dim aValue() As String
    Dim rngData As Word.Range
    Dim value As String
    
    If doc.Bookmarks.Exists("FPTitlePosition") Or doc.Bookmarks.Exists("FPTitlePos") Then
        file.Frontpage = True
        Set rngFP = Nothing
        If doc.Bookmarks.Exists("FPTitlePosition") Then
            Set rngFP = doc.Bookmarks("FPTitlePosition").Range
        Else
            Set rngFP = doc.Bookmarks("FPTitlePos").Range
        End If
        rngFP.Collapse (WdCollapseDirection.wdCollapseEnd)
        rngFP.Expand (WdUnits.wdParagraph)
        file.FPLine1 = Trim(Replace(Replace(rngFP.text, vbCr, ""), vbTab, ""))
        rngFP.Collapse (WdCollapseDirection.wdCollapseEnd)
        rngFP.Expand (WdUnits.wdParagraph)
        file.FPLine2 = Trim(Replace(Replace(rngFP.text, vbCr, ""), vbTab, ""))
        rngFP.Collapse (WdCollapseDirection.wdCollapseEnd)
        rngFP.Expand (WdUnits.wdParagraph)
        file.FPLine3 = Trim(Replace(Replace(rngFP.text, vbCr, ""), vbTab, ""))
        rngFP.Collapse (WdCollapseDirection.wdCollapseEnd)
        rngFP.Expand (WdUnits.wdParagraph)
        file.FPLine4 = Trim(Replace(Replace(rngFP.text, vbCr, ""), vbTab, ""))
        rngFP.Collapse (WdCollapseDirection.wdCollapseEnd)
        rngFP.Expand (WdUnits.wdParagraph)
        file.FPLine5 = Trim(Replace(Replace(rngFP.text, vbCr, ""), vbTab, ""))
        rngFP.Collapse (WdCollapseDirection.wdCollapseEnd)
        rngFP.Expand (WdUnits.wdParagraph)
        file.FPLine6 = Trim(Replace(Replace(rngFP.text, vbCr, ""), vbTab, ""))

        If file.FPLine4 = "" Then
            If LCase(file.FPLine3) = LCase(file.HFLine4) Then
                file.FPLine4 = file.FPLine3
                file.FPLine3 = ""
            End If
        End If
        If file.FPLine3 = "" Then
            If LCase(file.FPLine2) = LCase(file.HFLine3) Then
                file.FPLine3 = file.FPLine2
                file.FPLine2 = ""
            End If
        End If
        If file.FPLine2 = "" Then
            If LCase(file.FPLine1) = LCase(file.HFLine2) Then
                file.FPLine2 = file.FPLine1
                file.FPLine1 = ""
            End If
        End If
    End If

    If doc.Bookmarks.Exists("CCrisplantText") Then
        Set rngCP = doc.Bookmarks("CCrisplantText").Range
        rngCP.Expand (WdUnits.wdParagraph)
        file.FPCopyright = Trim(Replace(Replace(rngCP.text, vbCr, ""), vbTab, ""))
    End If
    If doc.Bookmarks.Exists("FPCopyrightText") Then
        Set rngCP = doc.Bookmarks("FPCopyrightText").Range
        rngCP.Expand (WdUnits.wdParagraph)
        file.FPDisclaimer = Trim(Replace(Replace(Replace(Replace(rngCP.text, vbCr, ""), vbTab, ""), vbLf, ""), Chr(7), ""))
    End If
    If doc.Bookmarks.Exists("FPDocDataPos") Then
        Set rngData = doc.Bookmarks("FPDocDataPos").Range

        rngData.Expand (WdUnits.wdParagraph)
        value = Trim(rngData.text)
        If value = vbCr Then
            rngData.Collapse (WdCollapseDirection.wdCollapseEnd)
            rngData.Expand (WdUnits.wdParagraph)
            value = Trim(rngData.text)
        End If
        If Not value = vbCr And value > "" Then
            If rngData.fields.Count = 1 Then
                file.FPJournal = rngData.fields(1).result.text
                aValue = Split(value, vbTab)
                file.FPJournalExtra = Trim(Replace(aValue(UBound(aValue)), vbCr, ""))
                If Len(file.FPJournalExtra) > Len(file.FPJournal) Then
                    file.FPJournalExtra = Trim(Mid(file.FPJournalExtra, Len(file.FPJournal) + 1))
                Else
                    file.FPJournalExtra = ""
                End If
            Else
                aValue = Split(value, vbTab)
                file.FPJournal = Trim(Replace(aValue(UBound(aValue)), vbCr, ""))
            End If
        End If
        rngData.Collapse (WdCollapseDirection.wdCollapseEnd)
        rngData.Expand (WdUnits.wdParagraph)
        value = Trim(rngData.text)
        If value > "" Then
            aValue = Split(value, vbTab)
            file.FPDateCP = Trim(Replace(aValue(UBound(aValue)), vbCr, ""))
            file.FPDate = GetDateFromCrisplantDate(file.FPDateCP, Format(Now, "YYYY-MM-DD"))
        End If
        rngData.Collapse (WdCollapseDirection.wdCollapseEnd)
        rngData.Expand (WdUnits.wdParagraph)
        value = Trim(rngData.text)
        If value > "" Then
            aValue = Split(value, vbTab)
            file.FPRevision = Trim(Replace(aValue(UBound(aValue)), vbCr, ""))
        End If
        rngData.Collapse (WdCollapseDirection.wdCollapseEnd)
        rngData.Expand (WdUnits.wdParagraph)
        value = Trim(rngData.text)
        If value > "" Then
            aValue = Split(value, vbTab)
            file.FPPages = Trim(Replace(aValue(UBound(aValue)), vbCr, ""))
        End If
        rngData.Collapse (WdCollapseDirection.wdCollapseEnd)
        rngData.Expand (WdUnits.wdParagraph)
        value = Trim(rngData.text)
        If value > "" Then
            aValue = Split(value, vbTab)
            file.FPInitials = Trim(Replace(aValue(UBound(aValue)), vbCr, ""))
        End If
    End If

End Sub

Public Sub ReadLanguageFromDocument(doc As Document, file As CPDocFile)
    Dim i As Integer
    Randomize
    
    file.Pages = doc.ComputeStatistics(WdStatistic.wdStatisticPages)
    file.Paragraphs = doc.ComputeStatistics(WdStatistic.wdStatisticParagraphs)
    If file.Paragraphs > 0 Then
        Dim LanguageCodes As New Collection
        Dim LCIDs As New Collection
        Dim lookups As Integer
        lookups = file.Pages * 5
        If lookups > 50 Then lookups = 50
        For i = 1 To lookups
            Dim pNo As Integer
            pNo = CInt(Int((file.Paragraphs - 1 + 1) * Rnd())) + 1
            Dim para As Word.Paragraph
            Set para = doc.Paragraphs(pNo)
            Dim langId As String
            langId = CStr(para.Range.LanguageId)
            If Not Contains(LanguageCodes, langId) Then
                LanguageCodes.Add 1, langId
                LCIDs.Add langId
            Else
                Dim c As Integer
                c = LanguageCodes(langId)
                LanguageCodes.Remove langId
                LanguageCodes.Add c + 1, langId
            End If
        Next
        Dim max As Integer
        Dim maxKey As String
        Dim key As Variant
        maxKey = "0"
        For Each key In LCIDs
            If key <> "9999999" And LanguageCodes(key) > max Then
                maxKey = key
                max = LanguageCodes(key)
            End If
        Next
        If maxKey = "0" Then
            maxKey = "2057"
        End If
        file.LanguageId = CInt(maxKey)
        If file.LanguageId = 1033 Then file.LanguageId = 2057
        file.LanguageFromPara = UCase(GetLanguageCode2CharFromLCID(maxKey))
    Else
        file.LanguageId = 2057
        file.LanguageFromPara = "EN"
    End If
End Sub



Public Sub GetVariablesFromDocumentCPdoc1_0(ByRef Head1, ByRef Head2, ByRef Head3, ByRef Head4, ByRef DateText, ByRef IniText, ByRef Section, ByRef Copyright)
    Dim Line As Integer
    Dim lines As Integer
    Dim para As Paragraph
    Dim aText() As String
    
    Selection.EndKey Unit:=wdStory, Extend:=wdExtend
    lines = Selection.Paragraphs.Count
    For Line = 1 To lines
        Set para = Selection.Paragraphs(Line)
        aText = Split(Replace(para.Range.text, vbCr, ""), vbTab)
        Select Case Line
            Case 1
                If UBound(aText) = 2 Then
                    Head1 = aText(1)
                    DateText = aText(2)
                End If
            Case 2
                If UBound(aText) = 1 Then
                    Head2 = aText(1)
                End If
            Case 3
                If UBound(aText) = 2 Then
                    If Head2 = "" Then
                        Head2 = aText(1)
                    End If
                    Section = aText(2)
                    Dim aSection() As String
                    aSection = Split(Section, " ", 2)
                    If UBound(aSection) = 1 Then
                        Section = aSection(1)
                    End If
                End If
            
            Case 4
                If UBound(aText) = 1 Then
                    Head3 = aText(1)
                End If
            
            Case 5
                If UBound(aText) = 2 Then
                    Head4 = aText(1)
                End If
        End Select
    Next
    
End Sub


Public Sub GetVariablesFromDocument(ByRef Head1, ByRef Head2, ByRef Head3, ByRef Head4, ByRef DateText, ByRef IniText, ByRef Section, ByRef Copyright)
    If ActiveWindow.View.SplitSpecial <> wdPaneNone Then
        ActiveWindow.Panes(2).Close
    End If
    If Not ActiveWindow.ActivePane.View.Type = wdPrintView Then
        ActiveWindow.ActivePane.View.Type = wdPrintView
    End If
    ActiveWindow.ActivePane.View.SeekView = wdSeekCurrentPageHeader
    If LCase(ActiveDocument.attachedTemplate.Name) = LCase("CPDOC1_0.DOT") Or LCase(ActiveDocument.BuiltInDocumentProperties("Template")) = LCase("CPDOC1_0.DOT") Then
        GetVariablesFromDocumentCPdoc1_0 Head1, Head2, Head3, Head4, DateText, IniText, Section, Copyright
        Exit Sub
    End If
    On Error Resume Next
    Selection.EndKey Unit:=wdLine, Extend:=wdExtend
    Selection.MoveLeft Unit:=wdCharacter, Count:=1, Extend:=wdExtend
    On Error GoTo 0
    Head1 = Selection.text
    If Asc(Head1) = 13 Then
        Head1 = ""
    Else
        Selection.MoveRight Unit:=wdCharacter, Count:=1
    End If
'
    Selection.MoveDown Unit:=wdLine, Count:=1
    Selection.HomeKey Unit:=wdLine, Extend:=wdExtend
    Head2 = Selection.text
    If Not Head2 = "" Then
        If Asc(Head2) = 13 Or Head2 = "|fffd|" Then
            Head2 = ""
        End If
    End If
    
    ' New Method
    On Error GoTo SkipHF
    Dim line1 As String
    line1 = ""
    Dim line2 As String
    line2 = ""
    Selection.WholeStory
    line1 = Selection.Paragraphs(1).Range.text
    If Not line1 = "" Then
        If Asc(line1) = 13 Or line1 = "|fffd|" Then
            line1 = ""
        Else
            line1 = Left(line1, Len(line1) - 1)
        End If
    End If

    line2 = Selection.Paragraphs(2).Range.text
    If Not line2 = "" Then
        If Asc(line2) = 13 Or line2 = "|fffd|" Then
            line2 = ""
        Else
            line2 = Left(line2, Len(line2) - 1)
        End If
    End If
    If Len(line1) > Len(Head1) Then
        Head1 = line1
    End If
    If Len(line2) > Len(Head2) Then
        Head2 = line2
    End If
SkipHF:
    On Error GoTo 0
    
    ActiveWindow.ActivePane.View.SeekView = wdSeekCurrentPageFooter
    
    Selection.EndKey Unit:=wdLine, Extend:=wdExtend
    Selection.MoveLeft Unit:=wdCharacter, Count:=1, Extend:=wdExtend
    Copyright = Selection.text
    Selection.HomeKey Unit:=wdLine
    Selection.MoveDown Unit:=wdLine, Count:=1

'
    Selection.EndKey Unit:=wdLine, Extend:=wdExtend
    Selection.MoveLeft Unit:=wdCharacter, Count:=1, Extend:=wdExtend
    Dim Footer1 As String
    Footer1 = Selection.text
    Dim aFooter1() As String
    aFooter1 = Split(Footer1, vbTab)
    If UBound(aFooter1) = 2 Then
        DateText = aFooter1(0)
        Head3 = aFooter1(1)
        Section = aFooter1(2)
    End If
    
    Selection.MoveLeft Unit:=wdCharacter, Count:=1
    Selection.MoveDown Unit:=wdLine, Count:=1
    Selection.EndKey Unit:=wdLine, Extend:=wdExtend
    Selection.MoveLeft Unit:=wdCharacter, Count:=1, Extend:=wdExtend
    
    Dim Footer2 As String
    Footer2 = Selection.text
    Dim aFooter2() As String
    aFooter2 = Split(Footer2, vbTab)
    If UBound(aFooter2) = 2 Then
        IniText = aFooter2(0)
        Head4 = aFooter2(1)
    ElseIf UBound(aFooter2) = 3 Then
        IniText = aFooter2(0)
        Head4 = aFooter2(1)
        Section = aFooter2(2)
    End If
    
    If ActiveWindow.View.SplitSpecial <> wdPaneNone Then
        ActiveWindow.Panes(2).Close
    End If
    If Not ActiveWindow.ActivePane.View.Type = wdPrintView Then
        ActiveWindow.ActivePane.View.Type = wdPrintView
    End If

End Sub

Sub DeleteSectionBreaks()
    Selection.find.ClearFormatting
    Selection.find.Replacement.ClearFormatting
     With Selection.find
        .text = "^b"
        .Replacement.text = ""
        .Forward = True
        .Wrap = wdFindContinue
        .Format = False
        .MatchCase = False
        .MatchWholeWord = False
        .MatchByte = False
        .MatchAllWordForms = False
        .MatchSoundsLike = False
        .MatchWildcards = False
        .MatchFuzzy = False
    End With
    Selection.find.Execute Replace:=wdReplaceAll
 End Sub

'Public Sub ConvertDocumentCommand()
'    Dim Doc As Document
'    Set Doc = ActiveDocument
'
'    Dim DX As New DOCXML
'    DX.Init Doc
'
'    Dim bgDocFullName As String
'    Dim testDocumentFullName As String
'    testDocumentFullName = ""
'
'    'testDocumentFullName = "D:\_DocumentationDemo 2015-09-23\Testrapport_BGdoc_20160916_1.doc"
'    'testDocumentFullName = "D:\_DocumentationDemo 2015-09-23\A1_UK2_0.doc"
'    bgDocFullName = ActiveDocument.AttachedTemplate.FullName ' "D:\_DocumentationDemo 2015-09-23\BGdoc.dotm"
'
'    If testDocumentFullName > "" Then
'        Dim docFrom As Document
'        On Error Resume Next
'        Set docFrom = Application.Documents(testDocumentFullName)
'        On Error GoTo 0
'        If docFrom Is Nothing Then
'            Set docFrom = Application.Documents.Open(testDocumentFullName, False, True, False, , , , , , , , True)
'        End If
'        Doc.Activate
'        Set DX.FromDoc = docFrom
'        Set TimerForm = New Update
'        TimerForm.Init DX, "ConvertDocument"
'        TimerForm.show vbModeless
'    Else
'        Set TimerForm = New Update
'        TimerForm.Init DX, "ConvertDocument"
'        TimerForm.show vbModeless
'    End If
'
''    Doc.Activate
''    Set frm = New MainForm
''    frm.Show
'
'End Sub


Public Sub ConvertWPSDumpFontLine(para As Paragraph)
    Dim str As String
    Dim rng As Range
    Dim ch As String
    Dim val As Long
    Dim newVal As Long
    Dim strOut As String
    Set rng = para.Range.Duplicate
    rng.End = rng.End - 1
    
    Dim i As Long
    Dim length As Long
    str = rng.text
    For i = 1 To Len(str)
        ch = Mid(str, i, 1)
        val = AscW(ch) And &HFFFF&
        If val > 255 Then
            newVal = 32 'Debug.Print val
        Else
            newVal = Conv437Unicode(val)
        End If
        strOut = strOut & ChrW(newVal)
    Next
    rng.text = strOut
End Sub

Public Sub GConvertWPSDumpFont()
    Dim doc As Document
    Dim para As Paragraph
    Dim rng As Range
    Dim lineNo As Long
    Dim str As String
    Conv437Unicode = Array( _
&H0, &H1, &H2, &H3, &H4, &H5, &H6, &H7, &H8, &H9, &HA, &HB, &HC, &HD, &HE, &HF, &H10, &H11, &H12, &H13, &H14, &H15, &H16, &H17, &H18, &H19, &H1A, &H1B, &H1C, &H1D, &H1E, &H1F, &H20, &H21, &H22, &H23, &H24, &H25, &H26, &H27, &H28, &H29, &H2A, &H2B, &H2C, &H2D, &H2E, &H2F, &H30, &H31, &H32, &H33, &H34, &H35, &H36, &H37, &H38, &H39, &H3A, &H3B, &H3C, &H3D, &H3E, &H3F, &H40, &H41, &H42, &H43, &H44, &H45, &H46, &H47, &H48, &H49, &H4A, &H4B, &H4C, &H4D, &H4E, &H4F, &H50, &H51, &H52, &H53, &H54, &H55, &H56, &H57, &H58, &H59, &H5A, &H5B, &H5C, &H5D, &H5E, &H5F, &H60, &H61, &H62, &H63, &H64, &H65, &H66, &H67, &H68, &H69, &H6A, &H6B, &H6C, &H6D, &H6E, &H6F, &H70, &H71, &H72, &H73, &H74, &H75, &H76, &H77, &H78, &H79, &H7A, &H7B, &H7C, &H7D, &H7E, _
 &H7F, &HC7, &HFC, &HE9, &HE2, &HE4, &HE0, &HE5, &HE7, &HEA, &HEB, &HE8, &HEF, &HEE, &HEC, &HC4, &HC5, &HC9, &HE6, &HC6, &HF4, &HF6, &HF2, &HFB, &HF9, &HFF, &HD6, &HDC, &HA2, &HA3, &HA5, &H20A7, &H192, &HE1, &HED, &HF3, &HFA, &HF1, &HD1, &HAA, &HBA, &HBF, &H2310, &HAC, &HBD, &HBC, &HA1, &HAB, &HBB, &H2591, &H2592, &H2593, &H2502, &H2524, &H2561, &H2562, &H2556, &H2555, &H2563, &H2551, &H2557, &H255D, &H255C, &H255B, &H2510, &H2514, &H2534, &H252C, &H251C, &H2500, &H253C, &H255E, &H255F, &H255A, &H2554, &H2569, &H2566, &H2560, &H2550, &H256C, &H2567, &H2568, &H2564, &H2565, &H2559, &H2558, &H2552, &H2553, &H256B, &H256A, &H2518, &H250C, &H2588, &H2584, &H258C, &H2590, &H2580, &H3B1, &HDF, &H393, &H3C0, &H3A3, &H3C3, &HB5, &H3C4, &H3A6, &H398, &H3A9, &H3B4, &H221E, &H3C6, &H3B5, &H2229, &H2261, &HB1, &H2265, &H2264, &H2320, &H2321, &HF7, &H2248, &HB0, &H2219, &HB7, &H221A, &H207F, &HB2, _
 &H25A0, &HA0)
 
    Conv850Unicode = Array( _
 &H0, &H1, &H2, &H3, &H4, &H5, &H6, &H7, &H8, &H9, &HA, &HB, &HC, &HD, &HE, &HF, &H10, &H11, &H12, &H13, &H14, &H15, &H16, &H17, &H18, &H19, &H1A, &H1B, &H1C, &H1D, &H1E, &H1F, &H20, &H21, &H22, &H23, &H24, &H25, &H26, &H27, &H28, &H29, &H2A, &H2B, &H2C, &H2D, &H2E, &H2F, &H30, &H31, &H32, &H33, &H34, &H35, &H36, &H37, &H38, &H39, &H3A, &H3B, &H3C, &H3D, &H3E, &H3F, &H40, &H41, &H42, &H43, &H44, &H45, &H46, &H47, &H48, &H49, &H4A, &H4B, &H4C, &H4D, &H4E, &H4F, &H50, &H51, &H52, &H53, &H54, &H55, &H56, &H57, &H58, &H59, &H5A, &H5B, &H5C, &H5D, &H5E, &H5F, &H60, &H61, &H62, &H63, &H64, &H65, &H66, &H67, &H68, &H69, &H6A, &H6B, &H6C, &H6D, &H6E, &H6F, &H70, &H71, &H72, &H73, &H74, &H75, &H76, &H77, &H78, &H79, &H7A, &H7B, &H7C, _
 &H7D, &H7E, &H7F, &HC7, &HFC, &HE9, &HE2, &HE4, &HE0, &HE5, &HE7, &HEA, &HEB, &HE8, &HEF, &HEE, &HEC, &HC4, &HC5, &HC9, &HE6, &HC6, &HF4, &HF6, &HF2, &HFB, &HF9, &HFF, &HD6, &HDC, &HF8, &HA3, &HD8, &HD7, &H192, &HE1, &HED, &HF3, &HFA, &HF1, &HD1, &HAA, &HBA, &HBF, &HAE, _
 &HAC, &HBD, &HBC, &HA1, &HAB, &HBB, &H2591, &H2592, &H2593, &H2502, &H2524, &HC1, &HC2, &HC0, &HA9, &H2563, &H2551, &H2557, &H255D, &HA2, &HA5, &H2510, &H2514, &H2534, &H252C, &H251C, &H2500, &H253C, &HE3, &HC3, &H255A, &H2554, &H2569, &H2566, &H2560, &H2550, &H256C, &HA4, &HF0, &HD0, &HCA, &HCB, &HC8, &H131, &HCD, &HCE, &HCF, &H2518, &H250C, &H2588, &H2584, &HA6, &HCC, &H2580, &HD3, &HDF, &HD4, &HD2, &HF5, &HD5, &HB5, &HFE, &HDE, &HDA, &HDB, &HD9, &HFD, &HDD, &HAF, &HB4, &HAD, &HB1, &H2017, &HBE, &HB6, &HA7, &HF7, &HB8, &HB0, &HA8, &HB7, &HB9, &HB3, &HB2, &H25A0, &HA0)
        
    Conv863Unicode = Array( _
&H0, &H1, &H2, &H3, &H4, &H5, &H6, &H7, &H8, &H9, &HA, &HB, &HC, &HD, &HE, &HF, &H10, &H11, &H12, &H13, &H14, &H15, &H16, &H17, &H18, &H19, &H1A, &H1B, &H1C, &H1D, &H1E, &H1F, &H20, &H21, &H22, &H23, &H24, &H25, &H26, &H27, &H28, &H29, &H2A, &H2B, &H2C, &H2D, &H2E, &H2F, &H30, &H31, &H32, &H33, &H34, &H35, &H36, &H37, &H38, &H39, &H3A, &H3B, &H3C, &H3D, &H3E, &H3F, &H40, &H41, &H42, &H43, &H44, &H45, &H46, &H47, &H48, &H49, &H4A, &H4B, &H4C, &H4D, &H4E, &H4F, &H50, &H51, &H52, &H53, &H54, &H55, &H56, &H57, _
&H58, &H59, &H5A, &H5B, &H5C, &H5D, &H5E, &H5F, &H60, &H61, &H62, &H63, &H64, &H65, &H66, &H67, &H68, &H69, &H6A, &H6B, &H6C, &H6D, &H6E, &H6F, &H70, &H71, &H72, &H73, &H74, &H75, &H76, &H77, &H78, &H79, &H7A, &H7B, &H7C, &H7D, &H7E, &H7F, &HC7, &HFC, &HE9, &HE2, &HC2, &HE0, &HB6, &HE7, &HEA, &HEB, &HE8, &HEF, &HEE, &H2017, &HC0, &HA7, &HC9, &HC8, &HCA, &HF4, &HCB, &HCF, &HFB, &HF9, &HA4, &HD4, &HDC, &HA2, &HA3, &HD9, &HDB, &H192, &HA6, &HB4, &HF3, &HFA, &HA8, &HB8, &HB3, &HAF, &HCE, &H2310, &HAC, &HBD, &HBC, &HBE, &HAB, &HBB, _
&H2591, &H2592, &H2593, &H2502, &H2524, &H2561, &H2562, &H2556, &H2555, &H2563, &H2551, &H2557, &H255D, &H255C, &H255B, &H2510, &H2514, &H2534, &H252C, &H251C, &H2500, &H253C, &H255E, &H255F, &H255A, &H2554, &H2569, &H2566, &H2560, &H2550, &H256C, &H2567, &H2568, &H2564, &H2565, &H2559, &H2558, &H2552, &H2553, &H256B, _
&H256A, &H2518, &H250C, &H2588, &H2584, &H258C, &H2590, &H2580, &H3B1, &HDF, &H393, &H3C0, &H3A3, &H3C3, &HB5, &H3C4, &H3A6, &H398, &H3A9, &H3B4, &H221E, &H3C6, &H3B5, &H2229, &H2261, &HB1, &H2265, &H2264, &H2320, &H2321, &HF7, &H2248, &HB0, &H2219, &HB7, &H221A, &H207F, &HB2, &H25A0, &HA0)
    
 
    Set doc = ActiveDocument
    For Each para In doc.Range.Paragraphs
        lineNo = lineNo + 1
        If para.Style = "wpsDumps" Then
            If lineNo >= 1 Then
                ConvertWPSDumpFontLine para
'                ActiveDocument.Characters.Last.Select
'                Selection.Collapse
'                Selection.text = str
            End If
        Else
            lineNo = 0
        End If
    Next
    
End Sub
Attribute VB_Name = "bg_FormTimers"
Option Explicit

Public Reschedule  As Boolean
Public StopTimer  As Boolean
Public TimerForm As Object

' Never Use B from here

Public Sub PictureToolOnTimer()
    On Error GoTo CloseIt
    If Not TimerForm Is Nothing Then TimerForm.OnTimer
    On Error GoTo 0
ExitSub:

    Exit Sub
CloseIt:
    Set TimerForm = Nothing
    Resume ExitSub
End Sub
Attribute VB_Name = "bg_Test"
'Option Explicit
'
'
'Public Sub RaiseRegistered()
'    Dim Head1 As String
'    Dim Head2 As String
'    Dim Head3 As String
'    Dim Head4 As String
'
'    Head1 = WordBasic.[GetDocumentVar$]("Head1")
'    Head2 = WordBasic.[GetDocumentVar$]("Head2")
'    Head3 = WordBasic.[GetDocumentVar$]("Head3")
'    Head4 = WordBasic.[GetDocumentVar$]("Head4")
'
'    If InStr(Head1, "|fffd|") > 0 Or InStr(Head2, "|fffd|") > 0 Then
'        ActiveDocument.StoryRanges(wdPrimaryHeaderStory).Select
'        Selection.find.Font.Superscript = False
'        Selection.find.Replacement.Font.Superscript = True
'        With Selection.find
'            .text = "|fffd|"
'            .Replacement.text = "|fffd|"
'            .Wrap = wdFindContinue
'            .Format = True
'            .MatchCase = False
'            .MatchWholeWord = False
'            .MatchWildcards = True
'            .MatchSoundsLike = False
'            .MatchAllWordForms = False
'        End With
'        Selection.find.Execute Replace:=wdReplaceAll
'    End If
'
'    If InStr(Head3, "|fffd|") > 0 Or InStr(Head4, "|fffd|") > 0 Then
'        ActiveDocument.StoryRanges(wdPrimaryFooterStory).Select
'        Selection.find.Font.Superscript = False
'        Selection.find.Replacement.Font.Superscript = True
'        With Selection.find
'            .text = "|fffd|"
'            .Replacement.text = "|fffd|"
'            .Wrap = wdFindContinue
'            .Format = True
'            .MatchCase = False
'            .MatchWholeWord = False
'            .MatchWildcards = True
'            .MatchSoundsLike = False
'            .MatchAllWordForms = False
'        End With
'        Selection.find.Execute Replace:=wdReplaceAll
'    End If
'
'    If InStr(Head1, "|fffd|") > 0 Or InStr(Head2, "|fffd|") > 0 _
'    Or InStr(Head3, "|fffd|") > 0 Or InStr(Head4, "|fffd|") > 0 Then
'        Selection.find.ClearFormatting
'        Selection.find.Replacement.ClearFormatting
'        With Selection.find
'            .text = ""
'            .Replacement.text = ""
'            .Forward = True
'            .Wrap = wdFindContinue
'            .Format = False
'            .MatchCase = False
'            .MatchWholeWord = False
'            .MatchWildcards = False
'            .MatchSoundsLike = False
'            .MatchAllWordForms = False
'        End With
'    End If
'
'    Selection.Collapse wdCollapseStart
'    On Error Resume Next
'    ActiveWindow.ActivePane.Close
'    ActiveWindow.ActivePane.View = wdPrintView
'    On Error GoTo 0
'
'
'End Sub
'
'Sub ListVisibleStyles()
'    Dim oSty As Style
'    Dim oLoopSty As Style
'    Dim oArray As Variant
'    Dim i As Long
'    Dim str As String
'
'
'    For Each oSty In ActiveDocument.Styles
'        If oSty.Visibility = False Then
'            'Debug.Print oSty.NameLocal, oSty.Type, oSty.QuickStyle, oSty.BuiltIn
'            If oSty.BuiltIn Then
'                For i = -1 To -1000 Step -1
'                    Set oLoopSty = ActiveDocument.Styles(i)
'                    If oLoopSty.NameLocal = oSty.NameLocal Then
'                        str = str & i & ", "
'                        Exit For
'                   End If
'               Next
'            Else
'                str = str & oSty.NameLocal & ", "
'            End If
'        End If
'    Next
'    Debug.Print str
'
''    str = "1, 2, 5, BoxText, BoxTextCenter, BulletList, BulletList 2, BulletList 3, 24, CaptionRes, CaptionTable, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 53, 54, 55, 56, 57, 58, 59, Figur, FigurRes, Front, Hanging Indent, Hanging Indent 2, Hanging Indent 3, Hanging Indent i1, Hanging Indent i2, Hanging Indent i3, Hanging Indent ii1, Hanging Indent ii2, Hanging Indent ii3, Hanging Indent No., 98, 99, 100, 101, 102, 103, 104, 105, HeadingFrontPage, HeadingPart, Indent, Indent 2, Indent 3, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, LineDraw, LineDraw2, LineDrawDumps, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, MotorUnit, 241, NormalBold, NormalNum, NumList, NumList 2, NumList 3, NumListAlpha,"
''    str = str & "ParmHead , pos1, PosListe, PosListeTable, Qty, Qty1, SeqNum, SeqNum2, SeqNum3, SeqNum4, SubjectRes, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, Table Header, Table Header Center, Table Header Right, Table Header Small, Table Header Small C, Table Header Small R, Table Indent, Table Indent Small, 310, 311, 312, 313, 314, 315, 316, 317, Table of FiguresCP, 322, 323, 324, 325, Table Small, Table Small Center, Table Small Right, 329, 330, Table Text, Table text Center, Table text Right, 334, 335, 336, 337, TableBulletList, TableBulletListSmall, TableNumList, TableNumListSmall, TegnText, TegnTextRight, Toc Head, Toc Title, Toc Title Fig, Toc Title Res, TOC1cp, TOC2cp, TOC3cp, TOC4cp, TOC5cp, TOC6cp, TOC7cp, TOC8cp, TOC9cp, TOC9cpRes, TOC9Res, TOCHeadChapt, TocHeadChapt, TocTitleRes, wps format, wpsDumps"
'
'
' End Sub
'
'Public Sub InsertShape()
'    Dim cc As ContentControl
'    Dim rng As Range
'    Selection.SelectCell
'    Set cc = Selection.Range.ContentControls(1)
'    Debug.Print cc.tag
'    cc.Range.text = "Here"
'    Set rng = cc.Range
'    ActiveDocument.Shapes.AddPicture "\\beumer.com\public\HomeDirs\Sub\Denmark\AAR\ply\My Pictures\Chronopost.gif", False, True, 0, 0, 200, 48, rng
'    Debug.Print cc.tag
'End Sub
'
'Sub GetActiveStyles()
'    Application.ScreenUpdating = False
'    Dim RngStory As Range, oSty As Style, StrType As String, StrStyles As String
'    With ActiveDocument
'        For Each oSty In .Styles
'            For Each RngStory In .StoryRanges
'                With RngStory.find
'                    .ClearFormatting
'                    .text = ""
'                    .Replacement.text = ""
'                    .Style = oSty.NameLocal
'                    .Forward = True
'                    .Wrap = wdFindStop
'                    .Format = True
'                    .Execute
'                    If .found Then
'                        Select Case oSty.Type
'                        Case wdStyleTypeCharacter: StrType = "Character"
'                        Case wdStyleTypeList: StrType = "list"
'                        Case wdStyleTypeParagraph: StrType = "Paragraph"
'                        Case wdStyleTypeTable: StrType = "Table"
'                        End Select
'                        StrStyles = StrStyles & oSty.NameLocal & " (" & StrType & ")" & vbCr
'                        Exit For
'                    End If
'                End With
'            Next RngStory
'        Next oSty
'    End With
'    Debug.Print StrStyles
'    Application.ScreenUpdating = True
'End Sub
'
'
'Public Sub TestUpdateCaptions()
'    Dim DX As New DOCXML
'    DX.Init
'    DX.Prolog "Test Update Captions"
'    DX.UpdateCaptions = True
'    DX.SetCaptions "Figure"
'    DX.SetCaptions "Table"
'    DX.UpdateCaptions = False
'    DX.updated = True
'    DX.Epilog
'    Set DX = Nothing
'End Sub
'
'Public Sub TestPrologEpilog()
'    Dim DX As New DOCXML
'    DX.Init
'    DX.Prolog "Test Undo"
'    Selection.text = "Undo Test"
'    DX.updated = True
'    DX.Epilog
'    Set DX = Nothing
'End Sub
'
'Public Sub TestSetLanguage()
'    Dim DX As New DOCXML
'    DX.Init
'    DX.Prolog "Test Set Language"
'    DX.SetLanguage
'    DX.updated = True
'    DX.Epilog
'    Set DX = Nothing
'
'
'End Sub
'
'Public Sub XButtonNextImage_Click(control As IRibbonControl)
'    Dim Addin As COMAddIn
'    Dim automationObject As Object
'    On Error Resume Next
'    Set Addin = Application.COMAddIns("Word BGOA")
'    On Error GoTo 0
'    If Not Addin Is Nothing Then
'        Set automationObject = Addin.Object
'        automationObject.OpenTemplate Application, "C:\BEUMERGroup\Office2007\WorkgroupTemplates\Standard\Standard Sheet.dot"
'    End If
'End Sub
'
'Public Sub tt()
'    Dim cc As ContentControl
'    Set cc = ActiveDocument.ContentControls(1)
'    cc.Range.Select
'    Dim rng As Range
'    Set rng = cc.Range
'    rng.Select
'    rng.Collapse wdCollapseEnd
'    rng.Select
'    rng.MoveStart wdCharacter, -1
'    rng.Select
'    rng.Delete
'End Sub
'
'Public Sub ListAllContentControls()
'    Dim cc As ContentControl
'    Dim stry As Range
'    For Each stry In ActiveDocument.StoryRanges
'        Debug.Print stry.StoryType
'        For Each cc In stry.ContentControls
'            If Not cc.PlaceholderText Is Nothing Then
'                If cc.tag Like "*Line2*" Or cc.PlaceholderText Like "*Line2*" Then
'                    Debug.Print cc.tag, cc.PlaceholderText
'                End If
'            Else
'                cc.Range.Select
'                cc.SetPlaceholderText , , " "
'                Debug.Print cc.tag, "Nothing"
'            End If
'          cc.SetPlaceholderText , , cc.tag
'        Next
'
'    Next
'End Sub
'
'
'Sub Demo()
'Dim fldSeq As field
'Dim rngText As Range
'Dim rng As Range
'Dim i As Integer
'Dim first As Boolean
'    first = True
'Dim endPos As Long
'Set rngText = ActiveDocument.Range
'endPos = rngText.End
'With rngText
'  With .find
'    .ClearFormatting
'    .text = "Table 1.2"
'    .Forward = True
'    .Style = ActiveDocument.Styles(WdBuiltinStyle.wdStyleCaption)
'    .Format = True
'    .Execute
'  End With
'  Do While .find.found
'    i = i + 1
'    If i > 100 Then Stop
'    Set rng = .Duplicate
'    rng.SetRange .start + 1, endPos
'    Set fldSeq = rng.fields(2)
'    If first Then
'        Debug.Print "First", .start, .End, .text ', .Information(wdWithInTable)
'        first = False
'        If Not LCase(fldSeq.code.text) Like "*\r*" Then
'            fldSeq.code.text = fldSeq.code.text & " \r 1"
'        End If
'        fldSeq.Update
'    Else
'        If LCase(fldSeq.code.text) Like "*\r*" Then
'            fldSeq.code.text = Replace(fldSeq.code.text, "\r 1", "")
'        End If
'        fldSeq.Update
'        Debug.Print .start, .End, .text ' , .Information(wdWithInTable)
'    End If
'    .End = .End + 1
'    .Collapse wdCollapseEnd
'    .find.Execute
'  Loop
'End With
'Debug.Print i & " ranges found."
'End Sub
'
'Public Sub ListContentControlsInSelection()
'    Dim cc As ContentControl
'    Dim ccs As ContentControls
'    Dim rng As Range
'
'    Dim cmt As Comment
'    Set cmt = Selection.comments.Add(Selection.Range, "DeleteAgain")
'    cmt.Delete
'    Debug.Print Selection.start, Selection.End
'
'    Set ccs = Selection.Range.ContentControls
'    If ccs.Count > 0 Then
'        Debug.Print ccs.Count
'        If Selection.Range.InRange(ccs(1).Range) Then
'            Debug.Print "InRange"
'        ElseIf (Selection.Range.start > ccs(1).Range.start And Selection.Range.start < ccs(1).Range.End) _
'        Or (Selection.Range.End < ccs(1).Range.End And Selection.Range.End > ccs(1).Range.start) Then
'            Debug.Print "Intersect"
'        End If
'    Else
'        If Selection.Tables.Count > 0 Then
'            Set rng = Selection.Cells(1).Range ' Tables(Selection.Tables.Count).Range
'            rng.End = Selection.Range.start
'        Else
'            Set rng = ActiveDocument.Range(1, Selection.Range.start)
'        End If
'
'        'rng.Select
'        Set ccs = rng.ContentControls
'        If ccs.Count > 0 Then
'            Debug.Print ccs.Count
'            Dim i As Integer
''            For i = 1 To ccs.Count
''                Debug.Print ccs(i).tag, ccs(i).Range.Start, ccs(i).Range.End
''            Next
'            Set cc = ccs(ccs.Count)
'        ElseIf ActiveDocument.ContentControls.Count > 0 Then
'            Set cc = ActiveDocument.ContentControls(1)
'        End If
'        If Not cc Is Nothing Then
'            If cc.Range.End < Selection.Range.start Then
'                If ccs.Count < ActiveDocument.ContentControls.Count Then
'                    Set cc = ccs(ccs.Count + 1)
'                End If
'            End If
'            Debug.Print cc.tag, cc.Range.start, cc.Range.End, cc.LockContents
'        End If
'        If (Selection.Range.start > cc.Range.start And Selection.Range.start < cc.Range.End) _
'        Or (Selection.Range.End < cc.Range.End And Selection.Range.End > cc.Range.start) Then
'            Debug.Print "Intersect"
'        End If
'    End If
'
'End Sub
'
'Public Sub aaIsLocked()
'    'ActiveDocument.ContentControls(1).LockContents = True
'    Dim cc As ContentControl
'    Dim ccs As ContentControls
'
'    Dim locked As Boolean
'    locked = False
'    Dim rng As Range
'    Set rng = Selection.Range.Duplicate
'    Dim rngTest As Range
'
'    Set ccs = rng.ContentControls
'
'    If ccs.Count > 0 Then
'        For Each cc In ccs
'            If cc.LockContents = True Then
'                locked = True
'                Exit For
'            End If
'        Next
'    End If
'
'    Set rngTest = rng.Duplicate
'
'    If locked = False Then
'        rngTest.SetRange rng.start, rng.start
'        On Error GoTo StyleFail
'        rngTest.Style = rng.Style ' ActiveDocument.Styles(wdStyleNormal)
'        On Error GoTo 0
'    End If
'
'    If locked = False Then
'        rngTest.SetRange rng.End, rng.End
'        On Error GoTo StyleFail
'        rngTest.Style = rng.Style ' ActiveDocument.Styles(wdStyleNormal)
'        On Error GoTo 0
'    End If
'
'
'ExitIsLocked:
'    Debug.Print locked
'    Exit Sub
'StyleFail:
'    locked = True
'    Resume ExitIsLocked
'End Sub
'
'
'Public Sub AddTableCCs()
'    Dim stry As Range
'    Dim rng As Range
'    Dim tbl As table
'    Dim cc As ContentControl
'    Dim ccs As Collection
'
'
'    Set stry = ActiveDocument.StoryRanges(wdFirstPageHeaderStory)
'    Set tbl = stry.Tables(1)
'    Set ccs = UnlockContentControls(tbl.Range)
'    Set cc = stry.ContentControls.Add(wdContentControlRichText, tbl.Range)
'    cc.tag = "Container:FirstPageHeader"
'    LockContentControls ccs
'    cc.LockContents = True
'
'    Set stry = ActiveDocument.StoryRanges(wdFirstPageFooterStory)
'    Set tbl = stry.Tables(1)
'    Set ccs = UnlockContentControls(tbl.Range)
'    Set cc = stry.ContentControls.Add(wdContentControlRichText, tbl.Range)
'    cc.tag = "Container:FirstPageFooter"
'    LockContentControls ccs
'    cc.LockContents = True
'
'    Set stry = ActiveDocument.StoryRanges(wdPrimaryHeaderStory)
'    Set tbl = stry.Tables(1)
'    Set ccs = UnlockContentControls(tbl.Range)
'    Set cc = stry.ContentControls.Add(wdContentControlRichText, tbl.Range)
'    cc.tag = "Container:PrimaryHeader"
'    LockContentControls ccs
'    cc.LockContents = True
'
'    Set stry = ActiveDocument.StoryRanges(wdPrimaryFooterStory)
'    Set tbl = stry.Tables(1)
'    Set ccs = UnlockContentControls(tbl.Range)
'    Set cc = stry.ContentControls.Add(wdContentControlRichText, tbl.Range)
'    cc.tag = "Container:PrimaryFooter"
'    LockContentControls ccs
'    cc.LockContents = True
'
'End Sub
'
'
'Public Sub TestInsertPic()
'    Dim rng As Range
'    Dim rngPic As Range
'    Dim inl As InlineShape
'    Set rng = Selection.Range
'    Set rngPic = ActiveDocument.StoryRanges(wdMainTextStory).Duplicate
'    rngPic.Collapse wdCollapseEnd
'    Set inl = rngPic.InlineShapes.AddPicture("\\crisnet\project\spteam\Pictures\Vancouver Airport.png", False, True, rngPic)
'    inl.Select
'    'inl.Range.CopyAsPicture
'End Sub
'
'Sub FigureCaption()
'    Dim d As Word.Dialog
'    Set d = Word.Dialogs(wdDialogInsertCrossReference)
'    d.referencetype = "Figure"
'    d.show
'    Set d = Nothing
'End Sub
'
'
'Sub TableCaption()
'    Dim varTables As Variant
'    varTables = ActiveDocument.GetCrossReferenceItems("Figure")
'
'    Dim d As Word.Dialog
'    Set d = Word.Dialogs(wdDialogInsertCrossReference)
'    d.referencetype = "Table"
'    Debug.Print d.ReferenceKind
'    d.ReferenceKind = 32 'wdOnlyLabelAndNumber
'    d.InsertAsHyperlink = 1
'    d.InsertPosition = 0
'    d.show
'    Set d = Nothing
'End Sub
'
'Public Sub TestReadReadCaptionTOCTOFTOT()
'    Dim DX As New DOCXML
'    DX.Init
'    ReadCaptionTOCTOFTOT ActiveDocument, DX
'    Set DX = Nothing
'End Sub
'
'Public Sub TestRead()
'    Dim DX As New DOCXML
'    Dim file As New CPDocFile
'    DX.Init
'    ReadLanguageFromDocument ActiveDocument, file
'    Set DX = Nothing
'End Sub
'
''Public Sub TestReadPictures()
''    Dim doc As Document
''    Set doc = ActiveDocument
''
''    Application.DisplayAlerts = wdAlertsNone
''    Dim ok As Boolean
''    Dim bgp As BGPicture
''    Dim coll As Collection
''
''    Dim BGPM As New BGPictureManager
''
''    Dim testDocumentFullName As String
''    'testDocumentFullName = "D:\_DocumentationDemo 2015-09-23\A1_UK2_0.doc" ' Missing file on user desktop
''    'testDocumentFullName = "D:\_DocumentationDemo 2015-09-23\A31UK6_2.doc" ' All found directly
''    'testDocumentFullName = "D:\_DocumentationDemo 2015-09-23\G1_UK1_0.DOC" ' Object has been deleted. Still found
''    testDocumentFullName = "D:\_DocumentationDemo 2015-09-23\F3_US1_0.doc"  ' 3 pictures, all found directly
''    'testDocumentFullName = "D:\_DocumentationDemo 2015-09-23\F1_US1_0.doc"  ' 6 pictures, all found directly
''    'testDocumentFullName = "D:\_DocumentationDemo 2015-09-23\F1_UK2_0.doc"  ' 24 pictures, one AutoShape
''    'testDocumentFullName = "D:\_DocumentationDemo 2015-09-23\H2000CUK__00.doc"  ' 11 pictures, all found
''    'testDocumentFullName = "D:\_DocumentationDemo 2015-09-23\U_CB5923_EN_00.docx"  ' 15 pictures, all found when force
''    'testDocumentFullName = "D:\_DocumentationDemo 2015-09-23\CBAG_H04_EN.doc"  'No pictures, ok
''    'testDocumentFullName = "D:\_DocumentationDemo 2015-09-23\TMPUK2000_3_0_EXT.doc"  'internal pictures only, (Older user guide)
''    'testDocumentFullName = "D:\_DocumentationDemo 2015-09-23\U_CB5310-_EN_01.doc"  'Many pictures, all found
''    'testDocumentFullName = "D:\_DocumentationDemo 2015-09-23\U0500_UK__05NS.doc"  'Many pictures, all found, except one user
''    'testDocumentFullName = "D:\_DocumentationDemo 2015-09-23\U0500_UK__05NS.doc"  'Many pictures, all found, except one user
''    'testDocumentFullName = "D:\_DocumentationDemo 2015-09-23\H0500CDK__00.doc"  '6 pictures, all found, used to fail resize
''    'testDocumentFullName = "D:\_DocumentationDemo 2015-09-23\3A_F1_UK3_0.doc"  '30 pictures, all found
''    'testDocumentFullName = "D:\_DocumentationDemo 2015-09-23\U1000_UK__01NS.doc"  '8 pictures, all found
''    'testDocumentFullName = "D:\_DocumentationDemo 2015-09-23\3A_F1_UK3_0.docx"  'old V: mapping, all found
''    'testDocumentFullName = "D:\_DocumentationDemo 2015-09-23\3A_B__UK2_0.doc"  '../../ files found in _Pictures, _Grafik
''    'testDocumentFullName = "D:\_DocumentationDemo 2015-09-23\H3052_UK__00.docx"  '7 pictures, all found
''    'testDocumentFullName = "D:\_DocumentationDemo 2015-09-23\0501ou130_ZH.doc"  'Chinese, All  internal
''    'testDocumentFullName = "D:\_DocumentationDemo 2015-09-23\OPNL_C02_UK.docx"  '3 pictures, all found
''    'testDocumentFullName = "D:\_DocumentationDemo 2015-09-23\CBAG_G01_03_EN.docx"  '8 pictures, all found
''    'testDocumentFullName = "D:\_DocumentationDemo 2015-09-23\SORT2H02____UK.doc"  '14 pictures, one deleted
''    'testDocumentFullName = "D:\_DocumentationDemo 2015-09-23\SORT2H02____UK - BreakTest.doc"  '14 pictures, one deleted
''
''    Dim docFrom As Document
''    On Error Resume Next
''    Set docFrom = Application.Documents(testDocumentFullName)
''    On Error GoTo 0
''    If docFrom Is Nothing Then
''        Set docFrom = Application.Documents.Open(testDocumentFullName, False, True, False, , , , , , , , True)
''    End If
''
'''    Set bgp = New BGPicture
'''    Debug.Print "Contains 22", BGPM.Contains("22")
'''    ok = BGPM.Add(bgp, "22")
'''    Debug.Print "Add 22", ok
'''    ok = BGPM.Add(bgp, "22")
'''    Debug.Print "Add 22", ok
'''    ok = BGPM.Add(bgp, "22", True)
'''    Debug.Print "Add 22 Force", ok
'''    Debug.Print "Contains 22", BGPM.Contains("22")
'''    ok = BGPM.Remove("22")
'''    Debug.Print "Remove 22", ok
'''    Debug.Print "Contains 22", BGPM.Contains("22")
''
''    ok = BGPM.ReadRange(docFrom.Content)
''    If ok Then
''        ok = BGPM.ReadInfo(DX, True)
''        If ok Then
''            ok = BGPM.BreakBrokenLinks
''        End If
''        Set coll = BGPM.GetBGPictures
''        Dim i As Integer
''        i = 0
''        For Each bgp In coll
''            i = i + 1
''            If bgp.sourceFullName > "" Then
''                If bgp.FoundFile = "" Then
''                    Debug.Print i, bgp.TypeOfPicture, "Not Found", bgp.sourceFullName
''                Else
''                    Debug.Print i, bgp.TypeOfPicture, "Found    ", bgp.sourceFullName, bgp.FoundFile
''                End If
''            Else
''                If bgp.FoundFile = "" Then
''                    Debug.Print i, bgp.TypeOfPicture, "Internal, not found", bgp.sourceFullName
''                Else
''                    Debug.Print i, bgp.TypeOfPicture, "Internal, found    ", bgp.sourceFullName, bgp.FoundFile
''                End If
''            End If
''        Next
''        Application.DisplayAlerts = wdAlertsAll
''    End If
''
''    doc.Activate
''End Sub
'
'Public Sub TestRemoveR0Field()
'    Dim DX As New DOCXML
'    DX.Init
'    DX.Prolog "Test Remove R0 Fields"
'    DX.updated = DX.RemoveR0Fields
'    DX.Epilog
'    Set DX = Nothing
'End Sub
'
'
'Public Sub TestMoveTextBoxes()
'    Dim doc As Document
'    Set doc = ActiveDocument
'    Dim txt As TextBox
'    Dim shp As Shape
'    Dim i As Integer
'
'    Dim rng As Range
'    Set rng = doc.Range
'    rng.SetRange 0, 0
'    rng.Select
'    rng.End = Selection.bookMarks("\Page").Range.End
'
'    Selection.EndKey Unit:=wdStory
'    Selection.InsertBreak Type:=wdPageBreak
'    Selection.InsertAfter "LastPage - Delete Again"
'
'    For i = rng.ShapeRange.Count To 1 Step -1
'        Set shp = rng.ShapeRange(i)
'        If shp.Type = msoTextBox Then
'            shp.LockAnchor = False
'            shp.Select
'            Selection.copy
'            doc.Paragraphs.Last.Range.Select
'            Selection.Collapse wdCollapseEnd
'            Selection.PasteAndFormat wdPasteDefault
'        End If
'    Next
'
'    doc.Content.Paragraphs.first.Range.Select
'    Selection.bookMarks("\Page").Range.Select
'    Selection.Delete
'
'    doc.Content.Paragraphs.Last.Range.Select
'    'Selection.Collapse wdCollapseStart
'    'Selection.Bookmarks("\Page").Range.Select
'    Set rng = Selection.Range
'    For i = rng.ShapeRange.Count To 1 Step -1
'        Set shp = rng.ShapeRange(i)
'        If shp.Type = msoTextBox Then
'            shp.LockAnchor = False
'            shp.Select
'            Selection.Cut
'            doc.Paragraphs.first.Range.Select
'            Selection.Collapse wdCollapseStart
'            Selection.PasteAndFormat wdPasteDefault
'        End If
'    Next
'    doc.Content.Paragraphs.Last.Range.Select
'    Selection.Delete
'
'End Sub
'
'
'Public Sub StartHeading(heading As WdBuiltinStyle, Optional hidden As Boolean = False)
'    Dim DX As New DOCXML
'    DX.Init
'    DX.Prolog "Start Heading"
'    Selection.Paragraphs(1).Range.Select
'    Selection.Collapse wdCollapseStart
'    Selection.Style = ActiveDocument.Styles(heading)
'    With Selection.ParagraphFormat
'        If heading = wdStyleHeading1 Then
'            .SpaceBefore = 24
'            .SpaceAfter = 3
'        Else
'            .SpaceBefore = 15
'            .SpaceAfter = 3
'        End If
'        .FirstLineIndent = -64.05
'        .TabStops.ClearAll
'        .TabStops.Add 64.05
'    End With
'    Selection.Range.ListFormat.RemoveNumbers NumberType:=wdNumberParagraph
'    With Selection.Paragraphs(1).Range.Font
'        If Not hidden Then
'            .Size = 12
'            .Bold = True
'        Else
'            .Size = 1
'            .ColorIndex = wdWhite
'        End If
'
'    End With
'    If Not Selection.Paragraphs(1).Range.Characters(1) = vbTab Then Selection.text = vbTab
'
'    DX.updated = True
'    DX.Epilog
'    Set DX = Nothing
'
'End Sub
'
'Public Sub TestStyling()
'    StartHeading WdBuiltinStyle.wdStyleHeading1, False
'End Sub
'
'Public Sub TestUnlockAll()
'    Dim DX As New DOCXML
'    DX.Init
'    DX.Prolog "Unlock All"
'    UnlockAllContentControls DX.ThisDoc
'    DX.LockMainContentControls False
'    DX.updated = True
'    DX.Epilog
'    Set DX = Nothing
'End Sub
'
'Public Sub TestNewContents()
'    Dim DX As New DOCXML
'    DX.Init
'    DX.Prolog "Unlock All", True
'    UnlockAllContentControls DX.ThisDoc
'
'    Dim ccTOC As ContentControl
'    Dim ccFrontPage As ContentControl
'    Dim ccDocumentInformation As ContentControl
'    Dim ccRevisions As ContentControl
'
'    Set ccTOC = DX.GetFirstContentControlByTag("DocumentInfo-TOC:DocumentInformation")
'
'    Set ccFrontPage = DX.GetFirstContentControlByTag("DocumentInfo-FrontPage:FrontPage")
'    Set ccDocumentInformation = DX.GetFirstContentControlByTag("DocumentInfo-DocumentInformation:DocumentInformation")
'    Set ccRevisions = DX.GetFirstContentControlByTag("DocumentInfo-Revisions:DocumentInformation")
'
'    Dim rng As Range
'
'    Set rng = ccTOC.Range.Paragraphs(3).Range
'    rng.Collapse wdCollapseStart
'    rng.Select
'
'    ' Delete Front link
'    If Not ccFrontPage Is Nothing Then
'        Selection.Move wdCharacter, 1
'        Selection.MoveEnd WdUnits.wdParagraph, 1
'        Selection.TypeBackspace
'    End If
'    ' Keep Document Information
'    If Not ccDocumentInformation Is Nothing Then
'        Selection.MoveDown wdLine, 1
'    Else
'        With ccTOC.Range.Paragraphs(2).Range.ParagraphFormat
'            .SpaceBefore = 4
'            .SpaceAfter = 4
'        End With
'    End If
'
'    ' Delete Contents
'    Selection.Move wdCharacter, 1
'    Selection.MoveEnd WdUnits.wdParagraph, 1
'    Selection.TypeBackspace
'
'
'    ' Delete Revisions
'    If Not ccRevisions Is Nothing Then
'        Selection.Move wdCharacter, 1
'        Selection.MoveEnd WdUnits.wdParagraph, 1
'        Selection.TypeBackspace
'    End If
'
'
''    rng.MoveEnd WdUnits.wdParagraph, 1
''    rng.MoveEnd wdCharacter, -1
''    rng.Select
''    Selection.Delete Unit:=wdCharacter, Count:=1
''    Selection.MoveDown wdLine, 1
''    Selection.TypeBackspace
''    Selection.MoveDown wdLine, 1
''    Selection.MoveRight Unit:=wdCharacter, Count:=1
''    Selection.MoveLeft Unit:=wdCharacter, Count:=1, Extend:=wdExtend
''    Selection.Delete Unit:=wdCharacter, Count:=1
''    If False Then
''        Selection.MoveDown wdLine, 1
''        Selection.MoveRight Unit:=wdCharacter, Count:=1
''        Selection.MoveLeft Unit:=wdCharacter, Count:=1, Extend:=wdExtend
''        Selection.Delete Unit:=wdCharacter, Count:=1
''    End If
'''    Selection.MoveRight Unit:=wdCharacter, Count:=1
''    Selection.MoveLeft Unit:=wdCharacter, Count:=1, Extend:=wdExtend
''    Selection.TypeBackspace
''    Selection.TypeBackspace
'''    Selection.MoveLeft Unit:=wdCharacter, Count:=1, Extend:=wdExtend
'''    Selection.Delete Unit:=wdCharacter, Count:=1
'''    Selection.TypeBackspace
''    'Selection.MoveLeft Unit:=wdCharacter, Count:=1
''    'Selection.Delete Unit:=wdCharacter, Count:=1
'
'    DX.updated = True
'    DX.Epilog
'    Set DX = Nothing
'End Sub
'
'Function GetPageRange(intpagenum As Integer) As Variant
'Dim intPageCount As Integer
'
'    Set GetPageRange = Nothing
'    For intPageCount = 1 To Selection.Information(wdNumberOfPagesInDocument)
'        If intPageCount = intpagenum Then
'            Set GetPageRange = ActiveDocument.bookMarks("\Page").Range
'            GetPageRange.Select
'            Exit For
'        End If
'    Next
'
'End Function
'
'Sub getapage()
'Dim rng As Variant
'Dim intpagenum As Integer
'
'    intpagenum = -3
'    Set rng = GetPageRange(intpagenum)
'    If TypeName(rng) = "Range" Then
'        Debug.Print rng.start & " " & rng.End
'    Else
'        Debug.Print "page number " & intpagenum & " NOT found"
'    End If
'
'End Sub
'
'Sub GetPageRange2()
'     Dim rng As Range
'     Dim p As Integer
'
'     p = 22
'     Set rng = ActiveDocument.Range
'     Selection.GoTo wdGoToPage, wdGoToAbsolute, p
'     rng.start = Selection.start
'     Selection.GoTo wdGoToPage, wdGoToNext
'     If Selection.start > rng.start Then
'         rng.End = Selection.start
'     Else
'         rng.End = ActiveDocument.Range.End
'     End If
'     rng.Select
'
' End Sub
'
'Public Sub TestSpeed()
'    Dim DX As New DOCXML
'    DX.Init
'    DX.Prolog "Test Speed", False
'
'    Dim i As Integer
'    Dim inl As InlineShape
'    Dim fld As field
'    Dim str As String
'    Dim para As Paragraph
'    Dim guard As Integer
'    Dim rng As Range
'    Dim rngAll As Range
'    Set rngAll = DX.GetDocumentRange
'    Dim start As Long
'    Dim book As Bookmark
'    Dim cc As ContentControl
'    Dim cross As String
'    Dim c As Integer
'    Dim aCross() As String
'    Dim shp As Shape
'    Dim current As Long
'    Dim objects() As Object
'
'
'    Dim loops As Integer
'    loops = 10
'
''    For i = DX.ThisDoc.InlineShapes.Count To 1 Step -1
''        Set inl = DX.ThisDoc.InlineShapes(i)
''        inl.Delete
''    Next
'
'
'    Debug.Print "Start", Format(Now, "HH:mm:ss")
'
'    For i = 1 To loops
'        Set rng = rngAll.Duplicate
'
'        Dim intPageCount As Integer
'        Dim intpage As Integer
'        intPageCount = DX.ThisDoc.BuiltInDocumentProperties("Number of Pages")
'        For intpage = 1 To intPageCount  'To 1 Step -1
'            Set rng = Selection.GoTo(What:=wdGoToPage, Which:=wdGoToAbsolute, name:=CStr(intpage))
'            Set rng = DX.ThisDoc.bookMarks("\page").Range
'            str = rng.start & rng.End
'            'If i = 1 Then Debug.Print str
'        Next
'    Next
'    Debug.Print "Pages", Format(Now, "HH:mm:ss")
'
''    For i = 1 To loops
''        aCross = DX.ThisDoc.GetCrossReferenceItems(wdRefTypeHeading)
''        For c = 1 To UBound(aCross)
''            str = c & aCross(c)
''            'Debug.Print c, aCross(c)
''        Next
''    Next
''    Debug.Print "Cross Headings", format(Now, "HH:mm:ss")
''
''    For i = 1 To loops
''        aCross = DX.ThisDoc.GetCrossReferenceItems(wdRefTypeBookmark)
''        For c = 1 To UBound(aCross)
''            str = c & aCross(c)
''            'Debug.Print c, aCross(c)
''        Next
''    Next
''    Debug.Print "Cross Bookmark", format(Now, "HH:mm:ss")
''
''    For i = 1 To loops
''        aCross = DX.ThisDoc.GetCrossReferenceItems(wdRefTypeNumberedItem)
''        For c = 1 To UBound(aCross)
''            str = c & aCross(c)
''            'Debug.Print c, aCross(c)
''        Next
''    Next
''    Debug.Print "Cross Numbered", format(Now, "HH:mm:ss")
'
'
'
'    For i = 1 To loops
'        Set rng = rngAll.Duplicate
'        rng.bookMarks.ShowHidden = True
'        For Each book In rng.bookMarks
'            str = book.name & book.start & book.End
''            On Error Resume Next
''            Debug.Print book.Name, book.start, book.End, book.Range.Style, DX.ThisDoc.Styles(book.Range.Style).ListLevelNumber, book.Range.Text
''            On Error GoTo 0
'        Next
'        rng.bookMarks.ShowHidden = False
'    Next
'
'    Debug.Print "Book", Format(Now, "HH:mm:ss")
'
'    For i = 1 To loops
'        Set rng = rngAll.Duplicate
'        For Each cc In rng.ContentControls
'            str = cc.Title & cc.tag & cc.Range.start & cc.Range.End
'            'Debug.Print cc.Range.Paragraphs.first.Range.Text
'        Next
'    Next
'    Debug.Print "CC", Format(Now, "HH:mm:ss")
'
'    Dim aStyles() As Variant
'    aStyles = Array("wpsDumps", "CaptionRes", "HeadingPart", "ParmHead")
'    'aStyles = Array(wdStyleHeading1, wdStyleHeading2, wdStyleHeading3, wdStyleHeading4, wdStyleHeading5, wdStyleHeading6, wdStyleHeading7, wdStyleHeading8, wdStyleHeading9, "wpsDumps", "CaptionRes", "HeadingPart", "ParmHead")
'    For i = 1 To loops
'        Dim styNo As Integer
'        Dim sty As Variant
'        For styNo = 0 To UBound(aStyles)
'            sty = aStyles(styNo)
'            Set rng = rngAll.Duplicate
'            start = rngAll.start - 1
'            guard = 1000
'            With rng.find
'                .ClearFormatting
'                .Style = sty
'                .Forward = True
'                .Format = True
'                .Wrap = wdFindContinue
'                .Execute
'                Do While .found And guard > 0
'                    If rng.start <= start Then Exit Do
'                    guard = guard - 1
'                    'Debug.Print guard
'                    start = rng.start
'                    str = rng.text & rng.start & rng.End
'                    .Execute
'                Loop
'            End With
'        Next
'    Next
'    Debug.Print "Styles", Format(Now, "HH:mm:ss")
'
'    For i = 1 To loops
'        Set rng = rngAll.Duplicate
'        rng.start = 0
'        rng.End = 0
'        Do
'            current = rng.start
'            Set rng = rng.GoTo(What:=wdGoToHeading, Which:=wdGoToNext)
'            If rng.start = current Then
'                ' We haven't moved because there are no more headings
'                Exit Do
'            End If
'            str = rng.Paragraphs.first.Range.text & rng.Style.NameLocal & rng.start & rng.End
'
''        If heading.Paragraphs(1).OutlineLevel = wdOutlineLevel4 Then
''
''            ' Now this is a level 4 heading. Let's do something with it.
''            ' heading.Expand Unit:=wdParagraph
''            ' Debug.Print heading.Text
''
''        End If
'        Loop
'    Next
'
'    Debug.Print "Headings", Format(Now, "HH:mm:ss")
'
''
''    For i = 1 To loops
''        Set rng = rngAll.Duplicate
''        Dim paras As Paragraphs
''        Set paras = rng.Paragraphs
''        For Each para In paras
''            Set rng = para.Range
''            str = rng.text & para.Style.NameLocal & rng.start & rng.End
''    '        If fld.Type <> 3 And fld.Type <> 10 And fld.Type <> 12 And fld.Type <> 37 And fld.Type <> 58 And fld.Type <> 84 Then
''    '            Debug.Print fld.Type
''    '        End If
''    '        If fld.Type = 3 Then
''    '            fld.Update
''    '            Debug.Print fld.code, fld.Result
''    '        End If
''        Next
''    Next
''    Debug.Print "Paragraphs", format(Now, "HH:mm:ss")
''
''    For i = 1 To loops
''        Set rng = rngAll.Duplicate
''        Dim paraNext As Paragraph
''        Set para = rng.Paragraphs.first
''        Do While Not para Is Nothing
''            Set paraNext = para.Next
''        'If para.Style = doc.Styles(wdStyleHeading1) Then
''            Set rng = para.Range
''            str = rng.text & para.Style.NameLocal & rng.start & rng.End
''             'para.Range.HighlightColorIndex = wdBrightGreen
''        'End If
''            Set para = paraNext
''        Loop
''    Next
''    Debug.Print "Paragraphs (NEXT)", format(Now, "HH:mm:ss")
''
'    For i = 1 To loops
'        Set rng = rngAll.Duplicate
'        Dim paraPrevious As Paragraph
'        Set para = rng.Paragraphs.Last
'        Do While Not para Is Nothing
'            Set paraPrevious = para.Previous
'        'If para.Style = doc.Styles(wdStyleHeading1) Then
'            Set rng = para.Range
'            'str = rng.text & rng.start & rng.End
'            str = rng.text & para.Style.NameLocal & rng.start & rng.End
'             'para.Range.HighlightColorIndex = wdBrightGreen
'        'End If
'            Set para = paraPrevious
'        Loop
'    Next
'    Debug.Print "Paragraphs (Previous)", Format(Now, "HH:mm:ss")
'
'
'    For i = 1 To loops
'        Set rng = rngAll.Duplicate
'        For Each fld In rng.fields
'            str = fld.Type & fld.result.text & fld.code.text & fld.result.start & fld.result.End & fld.code.start & fld.code.End
'    '        If fld.Type <> 3 And fld.Type <> 10 And fld.Type <> 12 And fld.Type <> 37 And fld.Type <> 58 And fld.Type <> 84 Then
'    '            Debug.Print fld.Type
'    '        End If
'    '        If fld.Type = 3 Then
'    '            fld.Update
'    '            Debug.Print fld.code, fld.Result
'    '        End If
'        Next
'    Next
'    Debug.Print "Field", Format(Now, "HH:mm:ss")
'
'    Dim fldPrev As field
'    For i = 1 To loops
'        Set rng = rngAll.Duplicate
'        Set fld = rng.fields(rng.fields.Count)
'        Do While Not fld Is Nothing
'            Set fldPrev = fld.Previous
'            str = fld.Type & fld.result.text & fld.code.text & fld.result.start & fld.result.End & fld.code.start & fld.code.End
'            Set fld = fldPrev
'        Loop
'    Next
'    Debug.Print "Field (Previous)", Format(Now, "HH:mm:ss")
'
'    For i = 1 To loops
'        Set rng = rngAll.Duplicate
'        For Each inl In rng.InlineShapes
'            str = inl.Range.start & inl.Range.End & inl.Height & inl.Width
'        Next
'    Next
'    Debug.Print "Inline", Format(Now, "HH:mm:ss")
'
'    For i = 1 To loops
'        Set rng = rngAll.Duplicate
'        For Each shp In rng.ShapeRange
'            str = shp.Anchor.start & shp.Anchor.End & shp.Height & shp.Width
'        Next
'    Next
'    Debug.Print "Shape", Format(Now, "HH:mm:ss")
'    Debug.Print "--------------------------------------------"
'
'
'    DX.updated = True
'    DX.Epilog
'    Set DX = Nothing
'End Sub
'
'
''
''Public Sub FixBookmarks()
''    Dim rng As Range
''    Dim book As Bookmark
''    Dim fld As Field
''    Dim Str As String
''
''    Dim books As New Scripting.Dictionary
''    Dim refs As New Scripting.Dictionary
''    Dim failrefs As New Scripting.Dictionary
''
''    books.CompareMode = TextCompare
''    refs.CompareMode = TextCompare
''    failrefs.CompareMode = TextCompare
''
''    Set rng = ActiveDocument.Range
''    rng.Bookmarks.ShowHidden = True
''    Debug.Print rng.Bookmarks.count
''    For Each book In rng.Bookmarks
''        books.Add book.name, book
''
''        Str = book.name & book.start & book.End
''        If Not book.Range.Style Is Nothing Then
''       ' On Error Resume Next
'''            Debug.Print book.name, book.start, book.End, book.Range.Style, book.Range.Text ', DX.ThisDoc.Styles(book.Range.Style).ListLevelNumber
''        Else
'''            Debug.Print book.name, book.start, book.End, "-", book.Range.Text ', DX.ThisDoc.Styles(book.Range.Style).ListLevelNumber
''        End If
''        'On Error GoTo 0
''    Next
''    rng.Bookmarks.ShowHidden = False
''
''    Set rng = ActiveDocument.Range
''    'Debug.Print rng.fields.count
''
''    Dim RegExpObj As Object
''    Dim matches As Object
''    Set RegExpObj = CreateObject("vbscript.regexp")
''    With RegExpObj
''        .IgnoreCase = True
'''        .Global = True
''        .Pattern = "(_(?:REF|TOC|HLT|PAGEREF)\d*)"
''        For Each fld In rng.fields
''            Str = fld.code.text
''            If .Test(fld.code.text) Then
''                Set matches = .Execute(fld.code.text)
''                Debug.Print Str, matches(0)
''                Str = CStr(matches(0))
''                If books.Exists(Str) Then
''                    books.Remove Str
''                    If Not refs.Exists(Str) Then
''                        refs.Add Str, fld
''                    End If
''                Else
''                    If Not refs.Exists(Str) Then
''                        If Not failrefs.Exists(Str) Then
''                            failrefs.Add Str, fld
''                        End If
''                    End If
''                End If
''            End If
''        Next
''    End With
''    Dim f As Variant
''    For Each f In failrefs
''        Debug.Print f
''    Next
''    Dim V As Variant
''    For Each V In books
''        'Debug.Print ActiveDocument.Bookmarks(V).name
''        ActiveDocument.Bookmarks(V).Delete
''    Next
''
''        'str = fld.Result.Text & fld.code.Text & fld.Result.start & fld.Result.End & fld.code.start & fld.code.End
'''        If fld.Type <> 3 And fld.Type <> 10 And fld.Type <> 12 And fld.Type <> 37 And fld.Type <> 58 And fld.Type <> 84 Then
'''            Debug.Print fld.Type
'''        End If
'''        If fld.Type = 3 Then
'''            fld.Update
'''            If LCase(fld.code) Like LCase("*_REF*") Then Debug.Print fld.code, fld.Result
'''        End If
''
''End Sub
'
'Sub ClearBookmarks()
'     Dim intNumBookmarks As Integer
'     Dim i As Integer
'     Dim d As Integer
'     Dim name As String
'
'
'     Dim ToDelete() As String
'
'     ActiveDocument.bookMarks.ShowHidden = True
'     intNumBookmarks = ActiveDocument.bookMarks.Count
'
'     ReDim ToDelete(intNumBookmarks)
'
'     ActiveWindow.View.ShowFieldCodes = True
'
'     For i = 1 To intNumBookmarks
'         name = ActiveDocument.bookMarks(i).name
'         Selection.HomeKey Unit:=wdStory
'         Selection.find.ClearFormatting
'         With Selection.find
'            .text = name
'            .Replacement.text = ""
'            .Forward = True
'            .Wrap = wdFindAsk
'            .Format = False
'            .MatchCase = False
'            .MatchWholeWord = False
'            .MatchKashida = False
'            .MatchDiacritics = False
'            .MatchAlefHamza = False
'            .MatchControl = False
'            .MatchWildcards = False
'            .MatchSoundsLike = False
'            .MatchAllWordForms = False
'         End With
'         If Not Selection.find.Execute Then
'             d = d + 1
'             ToDelete(d) = name
'         End If
'     Next i
'     If d > 0 Then
'        For i = d To 1 Step -1
'            ActiveDocument.bookMarks(ToDelete(i)).Delete
'        Next i
'     End If
'     ActiveDocument.bookMarks.ShowHidden = True
'     ActiveWindow.View.ShowFieldCodes = False
' End Sub
'
'
'Public Sub TestMoveSharePointViaBGOA()
'    Dim docUrl As String
'    Dim newDocUrl As String
'    Dim user As String
'
'    Dim Addin As Object
'
'    docUrl = "http://crisnet/project/90010/Project/00_Sales/Test.docx"
'    newDocUrl = "http://crisnet/project/90010/Project/00_Sales/Test.doc"
'    user = "matrix\adminply"
'
'    Set Addin = GetAutomationObject
'    If Not Addin Is Nothing Then
'        Dim res As String
'        res = Addin.HelloWorld
'        Debug.Print res
'        res = Addin.MoveFileInSharePoint(docUrl, newDocUrl, user)
'        Debug.Print res
'    End If
'End Sub
'
'Sub TestInlinqWebServiceUpgrade()
'
'    Dim WebRequest As New XMLHTTP60
'    Dim strRequest As String
'    Dim docResponse As New DOMDocument60
'
'    Const urlRef As String = "http://crisnet/_vti_bin/SharePointPortalManagement.WebServices.asmx"
'
'    strRequest = _
'        "<?xml version='1.0' encoding='utf-8'?> " & _
'        "<soap12:Envelope xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance' xmlns:xsd='http://www.w3.org/2001/XMLSchema' xmlns:soap12='http://www.w3.org/2003/05/soap-envelope'> " & _
'        "  <soap12:Body> " & _
'        "    <UpgradeDocument xmlns='http://beumergroup.com/' >" & _
'        "       <url>http://crisnet/project/90010/Project/00_Sales/Test.doc</url>" & _
'        "       <newUrl>http://crisnet/project/90010/Project/00_Sales/Test.docx</newUrl>" & _
'        "       <user>matrix\adminply</user>" & _
'        "    </UpgradeDocument>" & _
'        "  </soap12:Body> " & _
'        "</soap12:Envelope>"
'
'    WebRequest.Open "POST", urlRef, False
'    'WebRequest.setRequestHeader "Content-Type", "application/soap+xml; charset=utf-8"
'    WebRequest.setRequestHeader "Content-Type", "text/xml; charset=utf-8"
'    'WebRequest.setRequestHeader "Content-Length", "length"
'    'WebRequest.setRequestHeader "Content-Length", Len(strRequest)
'    WebRequest.setRequestHeader "HOST", "crisnet"
'    WebRequest.setRequestHeader "SOAPAction", "http://beumergroup.com/UpgradeDocument"
'
'    WebRequest.send strRequest
'
'    Set docResponse = WebRequest.responseXML
'    Debug.Print docResponse.text
'    docResponse.setProperty "SelectionNamespaces", "xmlns:x='http://schemas.microsoft.com/sharepoint/soap/'"
'
'    Debug.Print docResponse.SelectNodes("//x:_sList").length ' >>> Now it Works!!
'End Sub
'
'Sub TestHelloWorldWebService()
'    Dim docUrl As String
'    Dim newDocUrl As String
'    Dim user As String
'
'    docUrl = "http://crisnet/project/90010/Project/00_Sales/Test.docx"
'    newDocUrl = "http://crisnet/project/90010/Project/00_Sales/Test.doc"
'    user = "matrix\adminply"
'
'
'Const urlRef As String = "http://crisnet/project/90010/_vti_bin/SharePointPortalManagement.WebServices.asmx"
'Dim WebRequest As New XMLHTTP60, strRequest As String
'WebRequest.Open "POST", urlRef, False
'WebRequest.setRequestHeader "Content-Type", "text/xml; charset=utf-8"
'WebRequest.setRequestHeader "Content-Length", "length"
'WebRequest.setRequestHeader "SOAPAction", "http://beumergroup.com/HelloWorld"
'strRequest = _
'    "<?xml version='1.0' encoding='utf-8'?> " & _
'    "<soap:Envelope xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance' xmlns:xsd='http://www.w3.org/2001/XMLSchema' xmlns:soap='http://www.w3.org/2003/05/soap-envelope'> " & _
'    "  <soap:Body> " & _
'    "    <HelloWorld xmlns='http://tempuri.org/' />" & _
'    "  </soap:Body> " & _
'    "</soap:Envelope>"
'
''    "    <UpgradeDocument xmlns='http://tempuri.org/' >" & _
''    "       <url>http://crisnet/project/90010/Project/00_Sales/Test.doc</url>" & _
''    "       <newUrl>http://crisnet/project/90010/Project/00_Sales/Test.docx</newUrl>" & _
''    "       <user>matrix\adminply</user>" & _
'
'
'WebRequest.send strRequest
'
'Dim docResponse As New DOMDocument60
'Set docResponse = WebRequest.responseXML
'Debug.Print docResponse.text
'docResponse.setProperty "SelectionNamespaces", "xmlns:x='http://schemas.microsoft.com/sharepoint/soap/'"
'
'Debug.Print docResponse.SelectNodes("//x:_sList").length ' >>> Now it Works!!
'End Sub
'
'
'Public Sub TestMoveTextBoxesToFirstPage()
'    Dim DX As New DOCXML
'    DX.Init
'    DX.Prolog "TestMoveTextBoxesToFirstPage", True
'
'    DX.MoveTextBoxesToFirstPage
'    DX.updated = True
'    DX.Epilog
'    Set DX = Nothing
'
'End Sub
'
'Public Sub TestFixBookmarks()
'    Dim DX As New DOCXML
'    DX.Init
'    DX.Prolog "Test Fix Bookmarks", True
'    DX.FixBookmarks
'    DX.FixOldCaptions
'    DX.updated = True
'    DX.Epilog
'    Set DX = Nothing
'
'End Sub
'
'
'Public Sub HighlightCrossRefs()
'    Dim DX As New DOCXML
'    DX.Init
'    DX.Prolog "Highlight bookmarks", True
'     ActiveDocument.bookMarks.ShowHidden = True
'     Dim bk As Bookmark
'     For Each bk In ActiveDocument.bookMarks
'         If LCase(Left(bk.name, 4)) = "_ref" Then
'             If bk.Range.HighlightColorIndex <> wdNoHighlight Then
'                bk.Range.HighlightColorIndex = wdTeal
'             Else
'                bk.Range.HighlightColorIndex = wdPink
'             End If
'         End If
'     Next
'     ActiveDocument.bookMarks.ShowHidden = True
'    DX.updated = True
'    DX.Epilog
'    Set DX = Nothing
'
' End Sub
'
'Public Sub BeforeBookmark()
'    Dim DX As New DOCXML
'    DX.Init
'    DX.Prolog "Before Bookmark", True
'
'    Dim bk As Bookmark
'    Dim oOriginal As Range
'    Dim oRng As Range
'    Dim sText As String: sText = "toto"
'    Dim bkName As String
'    Dim i As Integer
'    For i = Selection.bookMarks.Count To 1 Step -1
'        Set bk = Selection.bookMarks(i)
'        bkName = bk.name
'        Debug.Print bk.name, bk.start, bk.End
'        If i > 1 Then
'            bk.Delete
'        Else
'            Set oRng = bk.Range
'            oRng.InsertBefore sText
'            oRng.MoveStart Count:=Len(sText)
''            oRng.MoveEnd count:=Len(sText)
'            'bk.Delete
'            oRng.bookMarks.Add bkName
'        End If
'    Next
'    DX.updated = True
'    DX.Epilog
'    Set DX = Nothing
'End Sub
'
'Public Sub TestRenameXML()
'    Dim DX As New DOCXML
'    DX.Init
'    DX.Prolog "Before Bookmark", True
'    Dim oNode As CustomXMLNode
'    'Set oNode = DX.RenameNode("/DocumentInfo", "ConvertedFrom", "Conversion")
'    'Set oNode = DX.RenameNode("/DocumentInfo", "Conversion", "ConvertedFrom")
'    DX.updated = True
'    DX.Epilog
'    Set DX = Nothing
'End Sub
'
'Public Sub TestA()
'    Dim rng As Range
'    Dim p As Long
'    Dim i As Long
'    Dim para As Paragraph
'    Dim found As Boolean
'
'
'    If Selection.Range.ShapeRange.Count > 0 Then
'        For p = 1 To Selection.Paragraphs.Count
'            Set para = Selection.Paragraphs(p)
'            Set rng = para.Range
'            Dim rngCh As Range
'            For i = rng.start To rng.End
'                Set rngCh = rng.Duplicate
'                rngCh.start = i
'                rngCh.End = i + 1
'                Debug.Print i, "!" & rngCh.text & "!"
'                If rngCh.ShapeRange.Count > 0 Then
'                    Debug.Print "-----------------> " & rngCh.ShapeRange.Count & " " & rngCh.ShapeRange(1).name
'                    'found = True
'                    'Exit For
'                End If
'            Next
'            'If found Then Exit For
'        Next
'    '        rng.End = rng.End - 1
'    '        rng.Select
'    '        rng.text = "Changed"
'
'    End If
'End Sub
'
'
'Sub ResetPictureSizes()
'     Dim ILS As InlineShape
'     Dim shp As Shape
'     Dim i As Integer
'
'     For i = ActiveDocument.InlineShapes.Count To 1 Step -1
'     Set ILS = ActiveDocument.InlineShapes(i)
'        Set shp = ILS.ConvertToShape
'         shp.ScaleHeight Factor:=1, RelativeToOriginalSize:=msoTrue
'         shp.ScaleWidth Factor:=1, RelativeToOriginalSize:=msoTrue
'        Set ILS = shp.ConvertToInlineShape
'        ' ILS.Reset
'     Next
'
'     For Each shp In ActiveDocument.Shapes
'         shp.ScaleHeight Factor:=1, RelativeToOriginalSize:=msoTrue
'         shp.ScaleWidth Factor:=1, RelativeToOriginalSize:=msoTrue
'     Next
' End Sub
'
'Public Sub SaveImage()
'
''Dim ImageStream As Object
'Dim fileName As String
'Dim lWritePos As Long
'Dim vData() As Byte
'Dim prefix As String
'Dim inl As InlineShape
'Dim shp As Shape
'Dim inlNew As InlineShape
'Dim shpNew As Shape
'Dim doc As Document
'Dim newDoc As Document
'
'Set doc = ActiveDocument
'
'Dim ScreenUpdating As Boolean
'ScreenUpdating = Application.ScreenUpdating
'Application.ScreenUpdating = True
'
'If doc.InlineShapes.Count > 0 Then
'    prefix = "inl"
'ElseIf doc.Shapes.Count > 0 Then
'    prefix = "shp"
'End If
'
'If prefix > "" Then
'    Set newDoc = Application.Documents.Add(Visible:=False)
'End If
'
'If prefix = "inl" Then
'    Set inl = doc.InlineShapes(1)
'ElseIf prefix = "shp" Then
'    Set shp = doc.Shapes(1)
'    Set inl = shp.ConvertToInlineShape
'End If
'
'inl.Reset
'inl.LockAspectRatio = False
'inl.ScaleHeight = 100
'inl.ScaleWidth = 100
'inl.LockAspectRatio = True
'inl.Range.copy
'
'If prefix > "" Then
'    newDoc.Range.Paste
'    If newDoc.InlineShapes.Count > 0 Then
'        Set inlNew = newDoc.InlineShapes(1)
'        Set shpNew = inlNew.ConvertToShape
'    Else
'        Set shpNew = newDoc.Shapes(1)
'        Set inlNew = shpNew.ConvertToInlineShape
'        inlNew.Reset
'        Set shpNew = inlNew.ConvertToShape
'    End If
'
'    shpNew.LockAspectRatio = False
'    shpNew.ScaleHeight 1, msoCTrue
'    shpNew.ScaleWidth 1, msoCTrue
'    shpNew.line.Visible = msoFalse
'    shpNew.LockAspectRatio = True
'    vData = shpNew.Anchor.EnhMetaFileBits
'
'    fileName = GetTempFile(prefix, "emf")
'    Open fileName For Binary Access Write As #1
'    lWritePos = 1
'    Put #1, lWritePos, vData
'    Close #1
'
'    Set inlNew = shpNew.ConvertToInlineShape
'    vData = inlNew.Range.EnhMetaFileBits
'    fileName = GetTempFile(prefix, "emf")
'    Open fileName For Binary Access Write As #1
'    lWritePos = 1
'    Put #1, lWritePos, vData
'    Close #1
'
'    'newDoc.Close wdDoNotSaveChanges
'
'End If
'
'End Sub
'
'Public Sub ReadText()
'    Dim rng As Range
'    'Dim cc As ContentControl
'    'Set cc = ActiveDocument.ContentControls(1)
'
'    Set rng = Selection.Range.Paragraphs.first.Range.Characters(2)
'    'Debug.Print rng.text & "!"; AscW(rng.text); rng.XML(True)
'    Dim doc As Document
'    Set doc = Application.Documents.Add()
'    doc.Range.InsertAfter Selection.XML
'    doc.Activate
'
'End Sub
'
'Public Sub BreakiLinks()
'    Dim fld As field
'    Dim rng As Range
'    Dim inl As InlineShape
'    Dim i As Integer
'
'    Set inl = ActiveDocument.InlineShapes(1)
'    Set rng = inl.Range
'    If rng.fields.Count > 0 Then
'        For i = rng.fields.Count To 1 Step -1
'        Set fld = rng.fields(i)
'            If LCase(Trim(fld.code)) Like "includepicture*" Then
'                Debug.Print fld.code
'                fld.Unlink
'            End If
'        Next
'    End If
'
'End Sub
'
'Public Sub SaveImage2()
'Dim fileName As String
'Dim lWritePos As Long
'Dim vData() As Byte
'Dim prefix As String
'Dim inl As InlineShape
'Dim shp As Shape
'Dim inlNew As InlineShape
'Dim shpNew As Shape
'Dim doc As Document
'Dim newDoc As Document
'
'Dim book As Bookmark
'    Set inlNew = ActiveDocument.InlineShapes(1)
'    'inlNew.Select
'    'Set book = ActiveDocument.Bookmarks.Add(Selection.Range)
'    vData = Selection.EnhMetaFileBits
'    fileName = GetTempFile(prefix, "emf")
'    Open fileName For Binary Access Write As #1
'    lWritePos = 1
'    Put #1, lWritePos, vData
'    Close #1
'End Sub
'
'
'Public Sub SaveImage3()
'
''Dim ImageStream As Object
'Dim fileName As String
'Dim filesFolder As String
'Dim lWritePos As Long
'Dim vData() As Byte
'Dim prefix As String
'Dim inl As InlineShape
'Dim shp As Shape
'Dim inlNew As InlineShape
'Dim shpNew As Shape
'Dim doc As Document
'Dim newDoc As Document
'
'Set doc = ActiveDocument
'
'Dim ScreenUpdating As Boolean
'ScreenUpdating = Application.ScreenUpdating
'Application.ScreenUpdating = True
'
'If doc.InlineShapes.Count > 0 Then
'    prefix = "inl"
'ElseIf doc.Shapes.Count > 0 Then
'    prefix = "shp"
'End If
'
'If prefix > "" Then
'    Set newDoc = Application.Documents.Add(Visible:=False)
'End If
'
'If prefix = "inl" Then
'    Set inl = doc.InlineShapes(1)
'ElseIf prefix = "shp" Then
'    Set shp = doc.Shapes(1)
'    Set inl = shp.ConvertToInlineShape
'End If
'
'inl.Reset
'inl.LockAspectRatio = False
'inl.ScaleHeight = 100
'inl.ScaleWidth = 100
'inl.LockAspectRatio = True
'
'inl.Range.copy
'
'If prefix > "" Then
'    newDoc.Range.Paste
'    If newDoc.InlineShapes.Count > 0 Then
'        Set inlNew = newDoc.InlineShapes(1)
'        Set shpNew = inlNew.ConvertToShape
'    Else
'        Set shpNew = newDoc.Shapes(1)
'        Set inlNew = shpNew.ConvertToInlineShape
'        inlNew.Reset
'        Set shpNew = inlNew.ConvertToShape
'    End If
'
'    shpNew.LockAspectRatio = False
'    shpNew.ScaleHeight 1, msoCTrue
'    shpNew.ScaleWidth 1, msoCTrue
'    shpNew.line.Visible = msoFalse
'    shpNew.LockAspectRatio = True
'
'    fileName = GetTempFile(prefix, "htm")
'    filesFolder = Replace(fileName, ".htm", "_files")
'    newDoc.SaveAs2 fileName, wdFormatHTML, , , False, , , , True
'    newDoc.Close wdDoNotSaveChanges
'
'    Dim StrFile As String
'    StrFile = Dir(filesFolder & "\image*")
'    Do While Len(StrFile) > 0
'        Debug.Print StrFile
'        StrFile = Dir
'    Loop
'    If StrFile > "" Then
'        Debug.Print StrFile
'    End If
'
'End If
'
'End Sub
'
'Sub IterateParasTheFastAndFlexibleWay()
' Dim doc As Document
' Dim para As Paragraph
' Dim paraNext As Paragraph
' Dim str As String
' Set doc = ActiveDocument
' Debug.Print Now
' Set para = doc.Paragraphs.first
' Do While Not para Is Nothing
' Set paraNext = para.Next
' 'If para.Style = doc.Styles(wdStyleHeading1) Then
'      str = para.Range.text & para.Style.NameLocal & para.Range.start & para.Range.End
'      'para.Range.HighlightColorIndex = wdBrightGreen
' 'End If
' Set para = paraNext
' Loop
' Debug.Print Now
'
' End Sub
'
'Public Sub TestContentTypeProperties()
'    Dim prop As MetaProperty
'    Dim DX As New DOCXML
'    DX.Init
'    DX.Prolog "Test", False
'
'    For Each prop In ActiveDocument.ContentTypeProperties
'        Select Case prop.name
'        Case "Title Line 1"
'            prop.value = DX.ReadText("/DocumentInfo/DocumentInfo-TitleLine1")
'        Case "Title Line 2"
'            prop.value = DX.ReadText("/DocumentInfo/DocumentInfo-TitleLine2")
'        Case "Title Line 3"
'            prop.value = DX.ReadText("/DocumentInfo/DocumentInfo-TitleLine3")
'        Case "Title Line 4"
'            prop.value = DX.ReadText("/DocumentInfo/DocumentInfo-TitleLine4")
'        Case "Title Line 5"
'            prop.value = DX.ReadText("/DocumentInfo/DocumentInfo-TitleLine5")
'        Case "Doc Type"
'            prop.value = DX.ReadText("/DocumentInfo/DocumentInfo-DocType")
'        Case "Classification Label"
'            prop.value = DX.ReadText("/DocumentInfo/DocumentInfo-ClassificationLabel")
'        Case "Project No."
'            prop.value = DX.ReadText("/DocumentInfo/DocumentInfo-ProjectNo")
'        Case "Workflow Label"
'            prop.value = DX.ReadText("/DocumentInfo/DocumentInfo-WorkflowLabel")
'        Case "Additional ID"
'            prop.value = DX.ReadText("/DocumentInfo/DocumentInfo-FrontPageInfo")
'        Case "Doc No."
'            prop.value = DX.ReadText("/DocumentInfo/DocumentInfo-DocNo")
'        Case "Supplier File Name"
'            prop.value = DX.ReadText("/DocumentInfo/DocumentInfo-SupplierFileName")
'
'
'        'Revision
'        Case "Rev No."
'            prop.value = DX.ReadText("/DocumentInfo/DocumentInfo-Revision")
'        Case "Rev Date"
'            prop.value = DX.ReadText("/DocumentInfo/DocumentInfo-Date")
'        Case "Rev Description"
'            prop.value = DX.ReadText("/DocumentInfo/DocumentInfo-Description")
'        Case "Rev Author"
'            prop.value = DX.ReadText("/DocumentInfo/DocumentInfo-Author")
'
'        ' Lookup
'        Case "Doc Main Type"
'            Dim docMainType As String
'            prop.value = "Project Document"
'            docMainType = DX.ReadText("/DocumentInfo/DocumentInfo-DocType")
'            Dim j As Integer
'            For j = 0 To UBound(aDocumentTypes, 1)
'                If aDocumentTypes(j, 0) = docMainType Then
'                    prop.value = aDocumentTypes(j, 1)
'                    Exit For
'                End If
'            Next
'        Case "Language"
'            Dim i As Integer
'            Dim lang As String
'            lang = DX.ReadText("/DocumentInfo/DocumentInfo-Language")
'            For i = 0 To UBound(aLanguages, 1)
'                If aLanguages(i, 0) = lang Then
'                    lang = aLanguages(i, 3)
'                    Exit For
'                End If
'            Next
'            If i > UBound(aLanguages, 1) Then
'                prop.value = ""
'            Else
'                prop.value = lang
'            End If
'
'        ' RegEx From DocNo
'        Case "Part"
'            Dim strPart As String
'            strPart = DX.ReadText("/DocumentInfo/DocumentInfo-DocNo")
'            If Not InStr(strPart, "/") > 0 Then
'                strPart = "-"
'            Else
'                strPart = Trim(Split(strPart, "/")(0))
'            End If
'            prop.value = strPart
'        Case "Section"
'            Dim strSection As String
'            strSection = DX.ReadText("/DocumentInfo/DocumentInfo-DocNo")
'            If Not InStr(strSection, "/") > 0 Then
'                strSection = "-"
'            Else
'                strSection = Trim(Split(strSection, "/")(1))
'            End If
'            prop.value = strSection
'        ' Calculate from ProjectNo + DocNo
'        Case "Doc Order"
'            Dim strDocOrder As String
'            Dim No1 As String
'            Dim No2 As String
'            Dim No3 As String
'            Dim No4 As String
'            Dim aNo() As String
'            strDocOrder = DX.ReadText("/DocumentInfo/DocumentInfo-DocNo")
'            If Not InStr(strDocOrder, "/") > 0 Then
'                strDocOrder = ""
'            Else
'                No1 = Trim(Split(strDocOrder, "/")(0))
'                No4 = Trim(Split(strDocOrder, "/")(1))
'                If No1 = "" Then
'                    No1 = "0000"
'                ElseIf Left(UCase(No1), 1) = "O" Then
'                    No1 = "35" & Right("00" & No1, 2)
'                ElseIf Left(UCase(No1), 1) = "M" Then
'                    No1 = "55" & Right("00" & Mid(No1, 2), 2)
'                Else
'                    No1 = "75" & Right("00" & Mid(No1, 2), 2)
'                End If
'                If No4 > "" Then
'                    No4 = Replace(No4, "-", "")
'                    No2 = Left(No4, 1)
'                    No3 = Mid(No4, 2)
'                    No4 = ""
'                End If
'                If No3 = "" Then
'                ElseIf InStr(No3, ".") > 0 Then
'                    aNo = Split(No3, ".")
'                    No3 = Right("00" & aNo(0), 2)
'                    No4 = Right("00" & aNo(1), 2)
'                Else
'                    No3 = "00" & No3
'                End If
'                strDocOrder = No1 & No2 & No3 & No4
'            End If
'            prop.value = strDocOrder
'
'        ' ????
'        Case "Description"
'            prop.value = DX.ReadText("/DocumentInfo/DocumentInfo-Description")
'
'        'Formula
'        Case "Doc Search Title"
'            'prop.value = DX.ReadText("/DocumentInfo/DocumentInfo-DocSearchTitle")
'        Case "Doc Title"
'            'prop.value = DX.ReadText("/DocumentInfo/DocumentInfo-DocTitle")
'
'
'        End Select
'        Debug.Print prop.name, prop.value 'If prop.value = "" Then
'        'Debug.Print "Case """ & prop.name & """"
'        'Debug.Print , "prop.Value = DX.ReadText(""/DocumentInfo/DocumentInfo-" & Replace(Replace(prop.name, "Title ", "Title"), " ", "") & """)"
'    Next
'
'    DX.updated = True
'    DX.Epilog
'    Set DX = Nothing
'
'
'End Sub
'
'Public Sub TestMeta()
'    Dim prop As MetaProperty
'    Dim result As String
'
'    Dim DX As New DOCXML
'    DX.Init
'    DX.Prolog "Test", False
'    Dim validate As Boolean
'
'    For Each prop In ActiveDocument.ContentTypeProperties
'        validate = False
'        Select Case prop.name
'        Case "Language"
'            validate = True
'            Dim i As Integer
'            Dim lang As String
'            lang = DX.ReadText("/DocumentInfo/DocumentInfo-Language")
'            For i = 0 To UBound(aLanguages, 1)
'                If aLanguages(i, 0) = lang Then
'                    lang = aLanguages(i, 3)
'                    Exit For
'                End If
'            Next
'            If i > UBound(aLanguages, 1) Then
'                prop.value = ""
'            Else
'                prop.value = lang
'                If prop.validate > "" Then ' Failed
'                    prop.value = UCase(lang)
'                End If
'                If prop.validate > "" Then ' Failed again
'                    prop.value = lang
'                End If
'            End If
'
'        Case "Part"
'            validate = True
'            Dim strPart As String
'            strPart = DX.ReadText("/DocumentInfo/DocumentInfo-DocNo")
'            If Not InStr(strPart, "/") > 0 Then
'                strPart = "-"
'            Else
'                strPart = Trim(Split(strPart, "/")(0))
'            End If
'            prop.value = strPart
'        Case "Status"
'            validate = True
'        End Select
'        If validate Then
'            result = prop.validate
'            Debug.Print prop.name, prop.value, Not (result > "")
'        End If
'    Next
'
'    DX.updated = True
'    DX.Epilog
'    Set DX = Nothing
'End Sub
'
'Public Sub TestDocType()
'    Dim d As New DocType
'    d.Init ("Standard Sheet")
'    Debug.Print d.Index, d.GetValue("HeadingLayout")
'End Sub
'
'Public Sub TestPreviousParagraphSpeed()
'    Dim DX As New DOCXML
'    DX.Init
'    DX.Prolog "Test Speed", False
'
'    Dim i As Integer
'    Dim inl As InlineShape
'    Dim fld As field
'    Dim str As String
'    Dim strPara As String
'    Dim para As Paragraph
'    Dim guard As Integer
'    Dim rng As Range
'    Dim rngAll As Range
'    Set rngAll = DX.GetDocumentRange
'    Dim start As Long
'    Dim book As Bookmark
'    Dim cc As ContentControl
'    Dim cross As String
'    Dim c As Integer
'    Dim aCross() As String
'    Dim shp As Shape
'    Dim current As Long
'    Dim objects() As Object
'    Dim paraStart As Long
'    Dim paraEnd As Long
'
'
'    Dim loops As Integer
'    loops = 1
'
'    Debug.Print "Start", Format(Now, "HH:mm:ss")
'    For i = 1 To loops
'        Set rng = rngAll.Duplicate
'        Dim paraPrevious As Paragraph
'        Set para = rng.Paragraphs.Last
'        Do While Not para Is Nothing
'            Set paraPrevious = para.Previous
'
'            Set rng = para.Range
'            paraStart = rng.start
'            paraEnd = rng.End
'
'            strPara = "------------ PARA, " & Replace(Replace(Replace(rng.text, vbCrLf, "|"), vbCr, "|"), vbLf, "|") & ", " & para.Style.NameLocal & ", " & paraStart & ", " & paraEnd
'
'            rng.bookMarks.ShowHidden = True
'            For Each book In rng.bookMarks
'                str = "Book, " & book.name & ", " & book.start & ", " & book.End & ", " & paraStart & ", " & paraEnd
'                If book.start < paraStart Or book.End > paraEnd Then
'                    Debug.Print strPara: strPara = ""
'                    Debug.Print str
'                End If
'            Next
'            rng.bookMarks.ShowHidden = False
'
'            For Each fld In rng.fields
'                str = "Field, " & fld.code.text & ", " & fld.result.text & ", " & fld.code.text & ", " & fld.result.start & ", " & fld.result.End & ", " & paraStart & ", " & paraEnd & ", " & fld.code.start & ", " & fld.code.End
'                If fld.result.start < paraStart Or fld.result.End > paraEnd Then
'                    Debug.Print strPara: strPara = ""
'                    Debug.Print str
'                End If
'            Next
'
'            For Each inl In rng.InlineShapes
'                str = "Inline, " & inl.Range.start & ", " & inl.Range.End & ", " & paraStart & ", " & paraEnd & ", " & inl.Height & ", " & inl.Width & inl.Type
'                If inl.Range.start < paraStart Or inl.Range.End > paraEnd Then
'                    Debug.Print strPara: strPara = ""
'                    Debug.Print str
'                End If
'            Next
'
'            For Each shp In rng.ShapeRange
'                str = "Shape, " & shp.Anchor.start & ", " & shp.Anchor.End & ", " & paraStart & ", " & paraEnd & ", " & shp.Height & ", " & shp.Width & ", " & shp.Type
'                If shp.Anchor.start < paraStart Or shp.Anchor.End > paraEnd Then
'                    Debug.Print strPara: strPara = ""
'                    Debug.Print str
'                End If
'            Next
'
'            For Each cc In rng.ContentControls
'                str = "CC, " & cc.Title & ", " & cc.tag & ", " & cc.Range.start & ", " & cc.Range.End & ", " & paraStart & ", " & paraEnd
'                If cc.Range.start < paraStart Or cc.Range.End > paraEnd Then
'                    Debug.Print strPara: strPara = ""
'                    Debug.Print str
'                End If
'            Next
'
'            Set para = paraPrevious
'        Loop
'    Next
'    Debug.Print "Paragraphs (Previous)", Format(Now, "HH:mm:ss")
'    DX.updated = True
'    DX.Epilog
'    Set DX = Nothing
'
'End Sub
'
'Public Sub TestFixOldCaptions()
'    Dim DX As New DOCXML
'    DX.Init
'    DX.Prolog "Test"
'    UnlockAllContentControls DX.ThisDoc
'    DX.FixOldCaptions
'    DX.LockMainContentControls False
'    DX.updated = True
'    DX.Epilog
'    Set DX = Nothing
'End Sub
'
'Public Sub TestRefresh()
'    Update "Refresh"
'    Exit Sub
'
'    Application.ScreenUpdating = False
'    Dim toDX As DOCXML
'    Dim DX As New DOCXML
'    DX.Init
'    DX.WriteLog "Start"
'    Dim fromDocFullName As String
'    Dim toDoc As Document
'    Dim fromDoc As Document
'    Dim tmpFileName As String
'    Dim ok As Boolean
'    Dim bgpmTo As New BGPictureManager
'    Dim bgpmFrom As New BGPictureManager
'    fromDocFullName = "\\filer-dk1\documentation\Dokument\ATS\Master_OM\Maintenance\M2_SORT\C-1_(808492master)\SORT_C01_DA_work_version_do-not-use.doc"
'
'    'fromDocFullName = OpenConvertFileDialog()
'    If fromDocFullName > "" Then
'        On Error Resume Next
'        Set toDoc = Application.Documents(fromDocFullName)
'        On Error GoTo 0
'        If Not toDoc Is Nothing Then
'            toDoc.Close wdDoNotSaveChanges
'            Set toDoc = Nothing
'            On Error Resume Next
'            Set toDoc = Application.Documents(fromDocFullName)
'            On Error GoTo 0
'        End If
'        If toDoc Is Nothing Then
'            Set toDoc = Application.Documents.Open(fromDocFullName, False, True, False, , , , , , , , True)
'            fromDocFullName = toDoc.fullName
'        Else
'            MsgBox "Alraedy open. Cannot convert"
'            Exit Sub
'        End If
'    End If
'    DX.WriteLog "Opened"
'
'    On Error Resume Next
'    MkDir UserTemp() & "\Conversion"
'    On Error GoTo 0
'    If LCase(fromDocFullName) Like "*.doc" Then
'        tmpFileName = UserTemp() & "\Conversion\" & toDoc.name & "x"
'    Else
'        tmpFileName = UserTemp() & "\Conversion\" & toDoc.name
'    End If
'
'
'    toDoc.Convert
'    toDoc.Compatibility(wdDontUseHTMLParagraphAutoSpacing) = True
'    toDoc.SaveAs2 tmpFileName, WdSaveFormat.wdFormatXMLDocument, , , False, , , , , , , , , , , , False
'    DX.WriteLog "Saved temp"
'    toDoc.attachedTemplate = DX.ThisDoc.attachedTemplate
'    Set toDX = New DOCXML
'    toDX.Init toDoc
'
'    DX.WriteLog "Converted and saved"
'
'    Set fromDoc = Application.Documents.Open(fromDocFullName, False, True, False, , , , , , , , True)
'    ok = bgpmFrom.ReadRange(fromDoc.Content, DX, True)
'
'    DX.WriteLog "Reopened original"
'
'    If ok Then
'        ok = bgpmFrom.ReadOldFilename(toDX, True)
'        If ok Then
'            ok = bgpmFrom.ReadInfo(toDX, False)
'        End If
'        If ok Then
'            ok = bgpmFrom.Read(toDX, True, False, False)
'        End If
'    End If
'
'    DX.WriteLog "Read picures from original"
'
'
'    Dim bgpFrom As BGPicture
'    Dim bgpTo As BGPicture
'    Dim key As Variant
'
''    DX.WriteLog "Start checking files"
''    For Each key In bgpmFrom.GetBGPictures.Keys
''        Set bgpFrom = bgpmFrom.GetBGPictures(key)
''        On Error Resume Next
''        Set bgpTo = bgpmTo.GetBGPictures(key)
''        On Error GoTo 0
''        If bgpTo Is Nothing Then
''            'Debug.Print key, bgpFrom.sourceFullName, "Not found.."
''        Else
''            bgpTo.Read toDX, True, False, False, False
''            'Debug.Print key, bgpFrom.sourceFullName, bgpTo.FoundFile
''        End If
''    Next
'
'    ' Change Pictures to V
'    ok = bgpmTo.ReadRange(toDoc.Content, DX, False)
'    If ok Then
'        ok = bgpmTo.ReadInfo(toDX, False)
'        If ok Then
'            ok = bgpmTo.BreakBrokenLinks
'        End If
'        If ok Then
'            ok = bgpmTo.ChangePicturesToV(bgpmFrom)
'        End If
'    End If
'
'    DX.WriteLog "Updated pictures"
'
'    Application.ScreenUpdating = True
'
'
'    Stop
'
'End Sub
'
'Public Sub TestCheckParagraphs()
'    Dim DX As New DOCXML
'    DX.Init
'    DX.Prolog "Check Paragraphs", False
'    'DX.FixBookmarks
'    DX.CheckParagraphs "Standard Document"
'    DX.updated = True
'    DX.Epilog
'    Set DX = Nothing
'End Sub
'
'Sub TestCheckOut()
'    Dim docUrl As String
'    Dim newDocUrl As String
'    Dim user As String
'
'    docUrl = "http://crisnet/project/90010/Project/00_Sales/Test.docx"
'
'    Const urlRef As String = "http://crisnet/project/90010/_vti_bin/Lists.asmx"
'    Dim WebRequest As New XMLHTTP60, strRequest As String
'    WebRequest.Open "POST", urlRef, False
'    WebRequest.setRequestHeader "Content-Type", "text/xml; charset=utf-8"
'    WebRequest.setRequestHeader "Content-Length", "length"
'    WebRequest.setRequestHeader "SOAPAction", "http://schemas.microsoft.com/sharepoint/soap/CheckOutFile"
'
'    strRequest = _
'    "<?xml version='1.0' encoding='utf-8'?>" & _
'    "<soap:Envelope xmlns:soap='http://schemas.xmlsoap.org/soap/envelope/' xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance' xmlns:xsd='http://www.w3.org/2001/XMLSchema'>" & _
'    "  <soap:Body>" & _
'    "    <CheckOutFile xmlns='http://schemas.microsoft.com/sharepoint/soap/'>" & _
'    "      <pageUrl>" & docUrl & "</pageUrl>" & _
'    "      <checkoutToLocal>true</checkoutToLocal>" & _
'    "      <lastmodified/>" & _
'    "    </CheckOutFile>" & _
'    "  </soap:Body>" & _
'    "</soap:Envelope>"
'
'
'    WebRequest.send strRequest
'
'    Dim docResponse As New DOMDocument60
'    Set docResponse = WebRequest.responseXML
'    Debug.Print docResponse.text
'End Sub
'
'
'Sub TestMoveSharePoint()
'    Dim docUrl As String
'    Dim newDocUrl As String
'    Dim user As String
'
'    docUrl = "http://crisnet/project/90010/Project/00_Sales/Test.docx"
'    'newDocUrl = "http://crisnet/project/90010/Documentation/Test.docx"
'    newDocUrl = "http://crisnet/project/90010/Project/00_Sales/Test.doc"
'    user = "matrix\adminply"
'    user = "beumer-de\khm"
'
'
'Const urlRef As String = "http://crisnet/project/90010/_vti_bin/SharePointPortalManagement.WebServices.asmx"
'Dim WebRequest As New XMLHTTP60, strRequest As String
'WebRequest.Open "POST", urlRef, False
'WebRequest.setRequestHeader "Content-Type", "text/xml; charset=utf-8"
'WebRequest.setRequestHeader "Content-Length", "length"
'WebRequest.setRequestHeader "SOAPAction", "http://beumergroup.com/UpgradeDocument"
'strRequest = _
'    "<?xml version='1.0' encoding='utf-8'?> " & _
'    "<soap:Envelope xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance' xmlns:xsd='http://www.w3.org/2001/XMLSchema' xmlns:soap='http://www.w3.org/2003/05/soap-envelope'> " & _
'    "  <soap:Body> " & _
'    "    <UpgradeDocument xmlns='http://beumergroup.com/' >" & _
'    "       <url>" & docUrl & "</url>" & _
'    "       <newUrl>" & newDocUrl & "</newUrl>" & _
'    "       <user>" & user & "</user>" & _
'    "    </UpgradeDocument>" & _
'    "  </soap:Body> " & _
'    "</soap:Envelope>"
'
''    "    <UpgradeDocument xmlns='http://tempuri.org/' >" & _
''    "       <url>http://crisnet/project/90010/Project/00_Sales/Test.doc</url>" & _
''    "       <newUrl>http://crisnet/project/90010/Project/00_Sales/Test.docx</newUrl>" & _
''    "       <user>matrix\adminply</user>" & _
'
'
'WebRequest.send strRequest
'
'Dim docResponse As New DOMDocument60
'Set docResponse = WebRequest.responseXML
'Debug.Print docResponse.text
'docResponse.setProperty "SelectionNamespaces", "xmlns:x='http://schemas.microsoft.com/sharepoint/soap/'"
'
'Debug.Print docResponse.SelectNodes("//x:_sList").length ' >>> Now it Works!!
'End Sub
'
'Public Sub GetSPCatalog()
'
'    Debug.Print Options.DefaultFilePath(wdDocumentsPath)
'    Debug.Print Options.DefaultFilePath(wdCurrentFolderPath)
'
'
'    Dim dlgS As Dialog
'    Set dlgS = Application.Dialogs(wdDialogFileSaveAs)
'    Debug.Print dlgS.name
'
'    Debug.Print Options.DefaultFilePath(wdDocumentsPath)
'    Debug.Print Options.DefaultFilePath(wdCurrentFolderPath)
'
'
''    Dim dlg As FileDialog
''    Set dlg = Application.FileDialog(msoFileDialogSaveAs)
''    Debug.Print dlg.initialFilename
''    dlg.show
''    Debug.Print dlg.initialFilename
''    Set dlg = Nothing
'
''            If SaveFolder Or (doc.fullName <> doc.name) Then
''                Application.FileDialog(msoFileDialogSaveAs).initialFilename = doc.fullName 'doc.path & IIf(InStr(doc.fullName, "\") > 0, "\", "/")
''            Else
''
''                Dim initialFilename As String
''                initialFilename = FixPath(DV(doc, "ConvertToFullName"))
''                If initialFilename > "" Then
''                    Application.FileDialog(msoFileDialogSaveAs).initialFilename = initialFilename
''                Else
''                    Dim FileSaveAsSetting As String
''                    FileSaveAsSetting = Dialogs(wdDialogToolsOptionsFileLocations).Setting
''                    If Not Right$(FileSaveAsSetting, 1) = "\" And Not Right$(FileSaveAsSetting, 1) = "/" Then
''                        FileSaveAsSetting = FileSaveAsSetting + IIf(InStr(FileSaveAsSetting, "\") > 0, "\", "/")
''                    End If
''
''                    Application.FileDialog(msoFileDialogSaveAs).initialFilename = FixPath(FileSaveAsSetting)
''                End If
''            End If
''
''            Application.FileDialog(msoFileDialogSaveAs).Title = ""
''            Application.FileDialog(msoFileDialogSaveAs).ButtonName = ""
''            Application.FileDialog(msoFileDialogSaveAs).FilterIndex = 1
''
''            Dim choice As Integer
''            choice = Application.FileDialog(msoFileDialogSaveAs).show
''
'End Sub
'
'    Sub EnumSEVars()
'        Dim strVar As String
'        Dim i As Long
'        For i = 1 To 255
'            strVar = Environ$(i)
'            If LenB(strVar) = 0& Then Exit For
'            Debug.Print strVar
'        Next
'    End Sub
'Sub Command_Line_Call()
'Dim strCmdText As String
'Dim aCmdData() As String
'strCmdText = Trim$(Command$)
'Debug.Print strCmdText
'aCmdData = Split(strCmdText, ",")
'
'End Sub
'
'Public Sub AfterSaveLocal()
'    MsgBox "Saved Special"
'End Sub
'
'Public Sub TestOnTime()
'    Application.OnTime Now + TimeValue("00:00:02"), "bg_Test.AfterSaveLocal"
'    'Application.OnTime Now + TimeValue("00:00:02"), "BGdocProject.bg_Support.AfterSave"
'End Sub
'
'Public Sub TestUpdateContent()
'    Dim DX As New DOCXML
'    DX.Init
'    DX.Prolog "Update Contents"
'
'    DX.UpdatePrepare
'    'DX.UpdateLayout
'    DX.UpdateContent
'    'DX.UpdateFinish
'
'    DX.updated = True
'    DX.Epilog
'    DX.WriteLog "----------Done-------------"
'    Set DX = Nothing
'End Sub
'
'Public Sub Test()
'    Dim DX As New DOCXML
'    DX.Init
'    DX.WriteLog "----------Start-------------"
'    DX.Prolog "HeaderFooter", True
'
'    DX.SetHeaderFooter True
'    DX.SpecialFirstHeaderFooter True
'
'    DX.updated = True
'    DX.Epilog
'    DX.WriteLog "----------Done-------------"
'    Set DX = Nothing
'End Sub
'
'Public Sub RiibonTest()
'    Dim app As Application
'    Set app = Application
'    Dim btn As CommandBarButton
'    Set btn = app.CommandBars.FindControl(msoControlButton, 113)
'    Debug.Print btn.Enabled
'
'End Sub
'
'
'Public Sub ResetAllContentControls()
'    Dim cc As ContentControl
'    Dim rng As Range
'    Dim stry As Range
'    Dim aTag() As String
'    Dim path As String
'
'    ActiveDocument.Styles("Placeholder Text").Font.Size = 5
'
'    For Each stry In ActiveDocument.StoryRanges
'        Set rng = stry
'        Do
'            For Each cc In rng.ContentControls
'                If cc.tag Like "*Logo*" Or cc.tag Like "*Info*TOC*" Or cc.tag Like "*Info*TOF*" Or cc.tag Like "*Info*TOT*" _
'                Or cc.tag = "DocumentInfo-FrontPage" Or cc.tag = "DocumentInfo-Translation" Or cc.tag Like "*:Translation" Then
'                    ' Do Nothing
'                ElseIf cc.tag Like "*:Translation" Then
'                    cc.Range.text = ""
'                    cc.SetPlaceholderText , , cc.tag
'                ElseIf cc.tag = "DocumentLabel-Front:FrontPage" Then
'                    cc.Range.text = "<|"
'                ElseIf cc.tag = "DocumentInfo-Revisions:DocumentInformation" Then
'                    Dim tbl As table
'                    Dim row As Integer
'                    Set tbl = cc.Range.Tables(1)
'                    For row = tbl.rows.Count To 3 Step -1
'                        tbl.rows(row).Delete
'                    Next
'                    tbl.Cell(2, 1).Range.text = ""
'                    tbl.Cell(2, 2).Range.text = ""
'                    tbl.Cell(2, 3).Range.text = ""
'                    tbl.Cell(2, 4).Range.text = ""
'                    tbl.Cell(1, 1).LeftPadding = 0
'                    tbl.Cell(2, 1).LeftPadding = 0
'                    tbl.Cell(1, 4).RightPadding = 0
'                    tbl.Cell(2, 4).RightPadding = 0
'                Else
'                    cc.Range.text = ""
'                    cc.SetPlaceholderText , , cc.tag
'                End If
'                If cc.tag Like "DocumentInfo-WorkflowLabel:*" Then
'                    cc.Range.Font.TextColor = RGB(0, 157, 224)
'                End If
'
'            Next
'            Set rng = rng.NextStoryRange
'        Loop While Not rng Is Nothing
'    Next
'End Sub
'
'
'
Public Sub ListCC()
    Debug.Print "---"
    Dim cc As ContentControl
    For Each cc In ActiveDocument.Range.ContentControls
        Debug.Print cc.tag, cc.LockContents
    Next
End Sub

Public Sub FixLang()
    If ActiveDocument.Characters.Count <= 2 Then
        ActiveDocument.Range.Delete
        Dim p As Paragraph
        Set p = ActiveDocument.Paragraphs.Add(ActiveDocument.Range)
        p.Range.LanguageId = 1031
        p.Style = wdStyleHeading1
    End If
End Sub

Public Sub TestUnlockAll()
    Dim DX As New DOCXML
    DX.Init
    DX.Prolog "Unlock All"
    DX.UnlockAllContentControls
    DX.LockMainContentControls False
    DX.updated = True
    DX.Epilog
    Set DX = Nothing
End Sub

Public Sub TestSetNode()
    Dim DX As New DOCXML
    DX.Init
    DX.Prolog "Test Set Node"
    DX.SetNode "/DocumentInfo", "DocumentInfo-ShowFullName", "A"
    Debug.Print DX.ReadText("/DocumentInfo/DocumentInfo-ShowFullName")
    DX.SetNode "/DocumentInfo", "DocumentInfo-ShowFullName", "B"
    Debug.Print DX.ReadText("/DocumentInfo/DocumentInfo-ShowFullName")
    DX.DeleteNode "/DocumentInfo/DocumentInfo-ShowFullName"
    DX.updated = True
    DX.Epilog
    Set DX = Nothing
End Sub

Public Sub DeleteLastPage()
    Dim strt As Long
    Dim rng As Range
    strt = ActiveDocument.GoTo(wdGoToPage, wdGoToLast).start
    Set rng = ActiveDocument.Range(strt - 1, ActiveDocument.Range.End)
    If rng.End - rng.start = 2 Then
        rng.Delete
    End If
End Sub
Attribute VB_Name = "bg_support"
Option Explicit

' ActiveWorkbook.SaveAs Filename:="D:\LangTable.txt", FileFormat:=xlUnicodeText

Public UserName As String
Public CachedUserTemp As String

Public FoundUserName As Boolean
Public BatchSaveAsFullName As String
Public ConvertedFullName As String

Public ReadTemplateComments As Boolean

Public aLanguages() As String
Public aTerms() As String
Public aDocumentTypes() As String
Public aDocTypes() As String

Public LanguageFieldIndexes() As Variant
Public LanguageFields() As Variant
Public PathLanguageFields() As Variant
Public Months As Scripting.Dictionary
Public TableRevNames As Scripting.Dictionary
Public RevNames As String
Public Conv437Unicode() As Variant
Public Conv850Unicode() As Variant
Public Conv863Unicode() As Variant

Public Const rootV As String = "V:\Documentation\BDK"
Public Const rootL As String = "L:\Dokument"

Public Enum PictureType
    InlineType
    ShapeType
    EmbedType
End Enum

Public Enum BGDocState
    dsAutoNew
    dsAutoOpen
    dsNoAutoNew
    dsNoAutoOpen
    dsUseForm
    dsIsForm
    dsDocument
    dsTemplate
    dsNotBGDoc
End Enum

Public Enum BGErrorLevel
    elTrace
    elInfo
    elWarning
    elAskContinue
    elAskStop
    elError
    elCritical
End Enum

Public Enum BGErrorProfile
    epStandard
    epBatch
    epDebug
    epStopOnError
End Enum


Public Declare PtrSafe Sub Sleep Lib "kernel32" (ByVal ms As LongPtr)

'Public Declare Function GetActiveWindow Lib "User32" () As Long
Public Declare PtrSafe Function GetActiveWindow Lib "user32" () As LongPtr

'Private Declare Function MakeSureDirectoryPathExists Lib "imagehlp.dll" (ByVal lpPath As String) As Long
 
'Public Sub MakeFullDir(strPath As String, IsDirectory As Boolean)
'    If IsDirectory Then
'        If Right(strPath, 1) <> "\" Then strPath = strPath & "\" 'Optional depending upon intent
'        MakeSureDirectoryPathExists strPath
'    Else
'        strPath = Left(strPath, InStrRev(strPath, "\"))
'        MakeSureDirectoryPathExists strPath
'    End If
'
'End Sub
'

'Public Sub FileSaveAs()
'    MsgBox "SaveAs"
'End Sub

'Public Sub FileSave()
'    MsgBox "Save"
'End Sub

Public Function OrderRevisionHistory(aRevHist() As String) As String()
    Dim i As Integer
    Dim singleLetter As Boolean
    singleLetter = True
    For i = 0 To UBound(aRevHist)
        If aRevHist(i, 0) <> Left(aRevHist(i, 0), 1) Then
            singleLetter = False
        End If
        Dim nums() As String
        nums = GetNums(aRevHist(i, 0))
        Dim j As Integer
        Dim str As String
        str = ""
        For j = 0 To UBound(nums)
            str = str & Right("000000000" & nums(j), 8) & "."
        Next
        aRevHist(i, 4) = str
    Next
    If singleLetter Then
    For i = 0 To UBound(aRevHist)
        aRevHist(i, 4) = aRevHist(i, 0)
    Next
    
    End If
    
    QuickSortArray aRevHist, , , 4
    OrderRevisionHistory = aRevHist
End Function


Public Sub ReDimPreserve(ByRef Arr() As String, ByVal size1 As Long, ByVal size2 As Long)
Dim arr2() As String
Dim x As Long, Y As Long

'Check if it's an array first
If Not IsArray(Arr) Then Exit Sub

'create new array with initial start
ReDim arr2(LBound(Arr, 1) To size1, LBound(Arr, 2) To size2)

Dim copy As Integer
copy = UBound(Arr, 1)
If UBound(arr2, 1) < copy Then copy = UBound(arr2, 1)
'loop through first
For x = LBound(Arr, 1) To copy
    For Y = LBound(Arr, 2) To UBound(Arr, 2)
        'if its in range, then append to new array the same way
        arr2(x, Y) = Arr(x, Y)
    Next
Next
'return byref
Arr = arr2
End Sub

Function GetNewMajor(revStr As String) As String
    If Len(revStr) = 1 Then
        GetNewMajor = GetNextSingle(revStr)
    Else
        Dim RegExpObj As Object
        Dim matches As Object
        Dim NewMajor As String
        Set RegExpObj = CreateObject("vbscript.regexp")
        With RegExpObj
            .Pattern = "([^\d]*)(\d+)([^\d]*)(\d+)+([^\d]?)(\d+)*(.*)"
            If .Test(revStr) Then
                Set matches = .Execute(revStr)
                NewMajor = matches(0).SubMatches(0) & CStr(CInt(matches(0).SubMatches(1)) + 1) & matches(0).SubMatches(2) & "0"
                If matches(0).SubMatches(4) <> "" Then
                    If IsEmpty(matches(0).SubMatches(5)) Then
                        NewMajor = NewMajor & matches(0).SubMatches(4) & matches(0).SubMatches(6)
                    ElseIf IsNumeric(matches(0).SubMatches(5)) Then
                        NewMajor = NewMajor & matches(0).SubMatches(4) & "0" & matches(0).SubMatches(6)
                    Else
                        NewMajor = NewMajor & matches(0).SubMatches(4) & "0" & matches(0).SubMatches(6)
                    End If
                Else
                    NewMajor = NewMajor & matches(0).SubMatches(4) & matches(0).SubMatches(5) & matches(0).SubMatches(6)
                End If
            Else
                NewMajor = "1_0"
            End If
        End With
        GetNewMajor = NewMajor
    End If
End Function


Function GetNewMinor(revStr As String) As String
    If Len(revStr) = 1 Then
        GetNewMinor = GetNextSingle(revStr)
    Else
        Dim RegExpObj As Object
        Dim matches As Object
        Dim NewMinor As String
        Set RegExpObj = CreateObject("vbscript.regexp")
        With RegExpObj
            .Pattern = "([^\d]*)(\d+)([^\d]*)(\d+)+([^\d]?)(\d+)*(.*)"
            If .Test(revStr) Then
                Set matches = .Execute(revStr)
                NewMinor = matches(0).SubMatches(0) & matches(0).SubMatches(1) & matches(0).SubMatches(2) & CStr(CInt(matches(0).SubMatches(3)) + 1) & matches(0).SubMatches(4) & IIf(Not IsEmpty(matches(0).SubMatches(5)), "0", "") & matches(0).SubMatches(6)
            Else
                NewMinor = "0_1"
            End If
        End With
        GetNewMinor = NewMinor
    End If
End Function

Function GetNextSingle(revStr As String) As String
    Dim newChar As String
    If Len(revStr) = 1 Then
        newChar = revStr
        Select Case newChar
        Case "9"
            newChar = "A"
        Case "Z"
            newChar = "a"
        Case Else
            newChar = Chr(Asc(newChar) + 1)
        End Select
        GetNextSingle = newChar
    Else
        GetNextSingle = "1_0"
    End If
End Function

Function GetNums(ByVal strIn As String) As Variant  'Array of numeric strings
    Dim RegExpObj As Object
    Dim NumStr As String

    Set RegExpObj = CreateObject("vbscript.regexp")
    With RegExpObj
        .Global = True
        .Pattern = "[^\d]+"
        NumStr = .Replace(strIn, " ")
    End With

    GetNums = Split(Trim(NumStr), " ")
End Function

Public Sub BGInsertPictureWithFormatting()
    If Not IsLocked Then
        Dim DX As New DOCXML
        DX.Init
        DX.Prolog "Insert Picture with Frame"
        Dim fileName As String
    
        With Dialogs(wdDialogInsertPicture)
            .Display
            If .Name <> "" Then
               fileName = .Name
               fileName = FixPath(fileName)
               Selection.Style = ActiveDocument.Styles("Figur")
               Selection.InsertParagraph
               Selection.InlineShapes.AddPicture fileName:=fileName, LinkToFile:=True, SaveWithDocument:=True, Range:=Selection.Range
'               Application.screenUpdating = False
               With Selection
                    .Expand Unit:=wdParagraph
                    .InlineShapes(1).PictureFormat.ColorType = msoPictureAutomatic
                    If .InlineShapes(1).Width > Selection.PageSetup.PageWidth - Selection.PageSetup.RightMargin - Selection.PageSetup.LeftMargin - 64.06 Then
                        .InlineShapes(1).LockAspectRatio = msoTrue
                        .InlineShapes(1).Width = Selection.PageSetup.PageWidth - Selection.PageSetup.RightMargin - Selection.PageSetup.LeftMargin - 64.06
                    Else
                        .InlineShapes(1).LockAspectRatio = msoTrue
                    End If
                    If Selection.Information(wdWithInTable) Then
                        Selection.ParagraphFormat.LeftIndent = 0
                        If .InlineShapes(1).Width > Selection.Cells(1).Width Then
                            .InlineShapes(1).LockAspectRatio = msoTrue
                            .InlineShapes(1).Width = Selection.Cells(1).Width
                        End If
                    End If
                    .InlineShapes(1).AlternativeText = UpdateAlternativeText(.InlineShapes(1).AlternativeText, "Updated")
                    .Collapse Direction:=wdCollapseEnd
                    .Collapse Direction:=wdCollapseEnd
                    .Style = ActiveDocument.Styles(wdStyleCaption).NameLocal
               End With
'               Application.screenUpdating = True
            End If
        End With
        DX.updated = True
        DX.Epilog
    End If
End Sub

Public Sub BGInsertPicture()
    If Not IsLocked Then
        Dim DX As New DOCXML
        DX.Init
        DX.Prolog "Insert Picture"
        Dim fileName As String
        With Dialogs(wdDialogInsertPicture)
            .Display
            If .Name <> "" Then
               fileName = .Name
               fileName = FixPath(fileName)
               Selection.InlineShapes.AddPicture fileName:=fileName, LinkToFile:=True, SaveWithDocument:=True, Range:=Selection.Range
               With Selection
                    .Expand Unit:=wdParagraph
                    .InlineShapes(1).PictureFormat.ColorType = msoPictureAutomatic
                    If .InlineShapes(1).Width > Selection.PageSetup.PageWidth - Selection.PageSetup.RightMargin - Selection.PageSetup.LeftMargin - 64.06 Then
                        .InlineShapes(1).LockAspectRatio = msoTrue
                        .InlineShapes(1).Width = Selection.PageSetup.PageWidth - Selection.PageSetup.RightMargin - Selection.PageSetup.LeftMargin - 64.06
                    Else
                        .InlineShapes(1).LockAspectRatio = msoTrue
                    End If
                    If Selection.Information(wdWithInTable) Then
                        If .InlineShapes(1).Width > Selection.Cells(1).Width Then
                            .InlineShapes(1).LockAspectRatio = msoTrue
                            .InlineShapes(1).Width = Selection.Cells(1).Width
                        End If
                    End If
                    .InlineShapes(1).AlternativeText = UpdateAlternativeText(.InlineShapes(1).AlternativeText, "Updated")
                    .Collapse Direction:=wdCollapseEnd
               End With
            End If
        End With
        DX.updated = True
        DX.Epilog
   End If
    

End Sub

Sub SetVisibleStyles()
    Dim str As String
    Dim i As Long
    Dim strSty As String
    Dim oSty As Style
    
    str = "-110, -109, -111, BoxText, BoxTextCenter, BulletList, BulletList 2, BulletList 3, -35, CaptionRes, CaptionTable, -172, -190, -204, -218, -232, -246, -260, -171, -189, -203, -217, -231, -245, -259, -170, -188, -202, -216, -230, -244, -258, -169, -187, -201, -215, -229, -243, -257, Figur, FigurRes, Front, Hanging Indent, Hanging Indent 2, Hanging Indent 3, Hanging Indent i1, Hanging Indent i2, Hanging Indent i3, Hanging Indent ii1, Hanging Indent ii2, Hanging Indent ii3, Hanging Indent No., -2, -3, -4, -5, -6, -7, -8, -9, HeadingFrontPage, HeadingPart, Indent, Indent 2, Indent 3, -161, -175, -193, -207, -221, -235, -249, -160, -174, -192, -206, -220, -234, -248, -159, -173, -191, -205, -219, -233, -247, LineDraw, LineDraw2, LineDrawDumps, -166, -184, -198, -212, -226, -240, -254, -167, -185, -199, -213, -227, -241, -255, -168, -186, -200, -214, -228, -242, -256, -164, -178, -196, -210, -224, -238, -252, -165, -183, -197, -211, -225, -239, -253, -162, -176, -194, -208, -222, "
    str = str & "-236, -250, -163, -177, -195, -209, -223, -237, -251, MotorUnit, -1, NormalBold, NormalNum, NumList, NumList 2, NumList 3, NumListAlpha, ParmHead, pos1, PosListe, PosListeTable, Qty, Qty1, SeqNum, "
    str = str & "SeqNum2, SeqNum3, SeqNum4, SubjectRes, -143, -144, -145, -115, -116, -117, -118, -119, -120, -121, -122, -123, -124, -125, -126, -146, -147, -155, -127, -128, -129, -130, -131, -132, -133, -134, Table Header, Table Header Center, Table Header Right, Table Header Small, Table Header Small C, Table Header Small R, Table Indent, Table Indent Small, -135, -136, -137, -138, -139, -140, -141, -142, Table of FiguresCP, -148, -112, -113, -114, Table Small, Table Small Center, Table Small Right, -149, -150, Table Text, Table text Center, Table text Right, -156, -151, -152, -153, TableBulletList, TableBulletListSmall, TableNumList, TableNumListSmall, TegnText, TegnTextRight, Toc Head, Toc Title, Toc Title Fig, Toc Title Res, TOC1cp, TOC2cp, TOC3cp, TOC4cp, TOC5cp, TOC6cp, TOC7cp, TOC8cp, TOC9cp, TOC9cpRes, TOC9Res, TOCHeadChapt, TocHeadChapt, TocTitleRes, wps format, wpsDumps"

'    str = "1, 2, 5, BoxText, BoxTextCenter, BulletList, BulletList 2, BulletList 3, 24, CaptionRes, CaptionTable, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 53, 54, 55, 56, 57, 58, 59, Figur, FigurRes, Front, Hanging Indent, Hanging Indent 2, Hanging Indent 3, Hanging Indent i1, Hanging Indent i2, Hanging Indent i3, Hanging Indent ii1, Hanging Indent ii2, Hanging Indent ii3, Hanging Indent No., 98, 99, 100, 101, 102, 103, 104, 105, HeadingFrontPage, HeadingPart, Indent, Indent 2, Indent 3, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, LineDraw, LineDraw2, LineDrawDumps, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, MotorUnit, 241, NormalBold, NormalNum, NumList, NumList 2, NumList 3, NumListAlpha, "
'    str = str & "ParmHead , pos1, PosListe, PosListeTable, Qty, Qty1, SeqNum, SeqNum2, SeqNum3, SeqNum4, SubjectRes, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, Table Header, Table Header Center, Table Header Right, Table Header Small, Table Header Small C, Table Header Small R, Table Indent, Table Indent Small, 310, 311, 312, 313, 314, 315, 316, 317, Table of FiguresCP, 322, 323, 324, 325, Table Small, Table Small Center, Table Small Right, 329, 330, Table Text, Table text Center, Table text Right, 334, 335, 336, 337, TableBulletList, TableBulletListSmall, TableNumList, TableNumListSmall, TegnText, TegnTextRight, Toc Head, Toc Title, Toc Title Fig, Toc Title Res, TOC1cp, TOC2cp, TOC3cp, TOC4cp, TOC5cp, TOC6cp, TOC7cp, TOC8cp, TOC9cp, TOC9cpRes, TOC9Res, TOCHeadChapt, TocHeadChapt, TocTitleRes, wpsFormat, wpsDumps"
   
    Dim aStr() As String
    aStr = Split(Replace(str, ", ", ","), ",")
    
    For Each oSty In ActiveDocument.Styles
        oSty.Visibility = True
    Next
    
    For i = 1 To UBound(aStr)
        strSty = Trim(aStr(i))
        ActiveDocument.Styles(strSty).Visibility = False
        'Debug.Print strSty, ActiveDocument.Styles(strSty).NameLocal
    Next
    
    ActiveDocument.StyleSortMethod = wdStyleSortByName
    ActiveDocument.FormattingShowFilter = wdShowFilterStylesAvailable
End Sub

Public Function FixPath(fullName As String, Optional urlType As String = "") As String
' urlType: /, \,htpp,https
    Dim newFullName As String
    newFullName = URLDecode(fullName)
    If InStr(newFullName, "\") > 0 Then
        newFullName = Replace(newFullName, "\\com-dk2\documentation\Dokument", rootV, , , vbTextCompare)
        newFullName = Replace(newFullName, "V:\WorkDirs\Sub\Denmark\WorkAAR\Documentation\Dokument", rootV, , , vbTextCompare)
        newFullName = Replace(newFullName, "\\filer-dk1\Documentation\Dokument", rootV, , , vbTextCompare)
        newFullName = Replace(newFullName, rootL, rootV, , , vbTextCompare)
        newFullName = Replace(newFullName, "\CPInc\", "\ats\", , , vbTextCompare)
    End If
    If urlType = "/" Then
        newFullName = Replace(Replace(Replace(newFullName, "\", "/"), "http:", ""), "https:", "")
    ElseIf urlType = "\" Then
        newFullName = Replace(Replace(Replace(newFullName, "/", "\"), "http:", ""), "https:", "")
    ElseIf urlType = "http" Then
        newFullName = "http:" & Replace(Replace(Replace(newFullName, "\", "/"), "http:", ""), "https:", "")
    ElseIf urlType = "https" Then
        newFullName = "https:" & Replace(Replace(Replace(newFullName, "\", "/"), "http:", ""), "https:", "")
    ElseIf urlType = "ssl" Then
        newFullName = Replace(Replace(Replace(newFullName, "/", "\"), "http:", ""), "https:", "")
        If newFullName Like "\\*" Then
            If InStr(Mid(newFullName, 3), "\") > 0 Then
                newFullName = "\\" & Split(Mid(newFullName, 3), "\", 2)(0) & "@SSL\" & Split(Mid(newFullName, 3), "\", 2)(1)
            End If
        End If
    End If
    FixPath = newFullName
End Function


Public Function MakeFullUNC(fullName As String, Optional slashToBackslash As Boolean = True) As String
    Dim testFullname As String
    testFullname = URLDecode(fullName)
    If slashToBackslash Then testFullname = Replace(testFullname, "/", "\")
    testFullname = Replace(testFullname, "http:", "", , , vbTextCompare)
    testFullname = Replace(testFullname, "https:", "", , , vbTextCompare)
    testFullname = Replace(testFullname, "\\com-dk2\documentation\Dokument", rootV, , , vbTextCompare)
    testFullname = Replace(testFullname, "V:\WorkDirs\Sub\Denmark\WorkAAR\Documentation\Dokument", rootV, , , vbTextCompare)
    testFullname = Replace(testFullname, "\\filer-dk1\Documentation\Dokument", rootV, , , vbTextCompare)
    testFullname = Replace(testFullname, rootL, rootV, , , vbTextCompare)
    testFullname = Replace(testFullname, "\CPInc\", "\ats\", , , vbTextCompare)
    MakeFullUNC = testFullname
End Function

Public Function URLDecode(ByVal strEncodedURL As String) As String
   Dim str As String
   str = strEncodedURL
   If Len(str) > 0 Then
      str = Replace(str, "&amp", " & ")
      str = Replace(str, "&#03", Chr(39))
      str = Replace(str, "&quo", Chr(34))
      str = Replace(str, "+", " ")
      str = Replace(str, "%3A", ":")
      str = Replace(str, "%2A", "*")
      str = Replace(str, "%40", "@")
      str = Replace(str, "%2D", "-")
      str = Replace(str, "%5F", "_")
      str = Replace(str, "%2B", "+")
      str = Replace(str, "%2E", ".")
      str = Replace(str, "%2F", "/")

      URLDecode = str
  Else
    URLDecode = ""
  End If
End Function


'Public Sub ReplaceInMainStories()
'    Dim stry As Range
'    For Each stry In ActiveDocument.StoryRanges
'        If stry.StoryType = wdMainTextStory _
'        Or stry.StoryType = wdTextFrameStory Then
'            stry.Select
'            ReplaceCompanySpecific
'        End If
'    Next
'End Sub
'

'Public Sub ReplaceRegisteredFrontPage()
'    Dim updateScreen As Boolean
'    updateScreen = Application.ScreenUpdating
'    Application.ScreenUpdating = False
'    On Error GoTo screenUpdate
'
'    Selection.HomeKey Unit:=wdStory
'    ActiveDocument.bookMarks("\Page").Range.Select
'    ReplaceCompanySpecific
'    RaiseRegistered
'screenUpdate:
'    On Error GoTo 0
'    If updateScreen Then Application.ScreenUpdating = True
'End Sub

'Public Sub ReplaceCompanySpecific()
'
'    ReplaceSingle "CrisBag", True
'    ReplaceSingle "CrisClaim", True
'    ReplaceSingle "CrisBelt", True
'    ReplaceSingle "RampMate", True
'    ReplaceSingle "CrisStore", True
'    ReplaceSingle "CrisCheck", True
'    ReplaceSingle "autover", True
'    ReplaceSingle "autoca", True
'    ReplaceSingle "Crisplant|fffd|", True
'    ReplaceSingle "BEUMER", False
'    ReplaceSingle "Cristoph Beumer", False
'
'    Selection.find.Font.Reset
'    With Selection.find
'        .text = "|fffd||fffd||fffd|"
'        .Replacement.text = "|fffd|"
'        .Wrap = wdFindContinue
'        .Format = True
'        .MatchCase = False
'        .MatchWholeWord = False
'        .MatchWildcards = False
'        .MatchSoundsLike = False
'        .MatchAllWordForms = False
'    End With
'    Selection.find.Execute Replace:=wdReplaceAll
'
'    Selection.find.Font.Reset
'    With Selection.find
'        .text = "|fffd||fffd|"
'        .Replacement.text = "|fffd|"
'        .Wrap = wdFindContinue
'        .Format = True
'        .MatchCase = False
'        .MatchWholeWord = False
'        .MatchWildcards = False
'        .MatchSoundsLike = False
'        .MatchAllWordForms = False
'    End With
'    Selection.find.Execute Replace:=wdReplaceAll
'
'    Selection.find.Font.Reset
'    With Selection.find
'        .text = "|fffd||fffd|"
'        .Replacement.text = "|fffd|"
'        .Wrap = wdFindContinue
'        .Format = True
'        .MatchCase = False
'        .MatchWholeWord = False
'        .MatchWildcards = False
'        .MatchSoundsLike = False
'        .MatchAllWordForms = False
'    End With
'    Selection.find.Execute Replace:=wdReplaceAll
'
'
'    Selection.find.Font.Superscript = False
'    Selection.find.Replacement.Font.Superscript = True
'    With Selection.find
'        .text = "|fffd|"
'        .Replacement.text = "|fffd|"
'        .Wrap = wdFindContinue
'        .Format = True
'        .MatchCase = False
'        .MatchWholeWord = False
'        .MatchWildcards = False
'        .MatchSoundsLike = False
'        .MatchAllWordForms = False
'    End With
'    Selection.find.Execute Replace:=wdReplaceAll
'
'
'    Selection.find.ClearFormatting
'    Selection.find.Replacement.ClearFormatting
'    With Selection.find
'        .text = ""
'        .Replacement.text = ""
'        .Forward = True
'        .Wrap = wdFindContinue
'        .Format = False
'        .MatchCase = False
'        .MatchWholeWord = False
'        .MatchWildcards = False
'        .MatchSoundsLike = False
'        .MatchAllWordForms = False
'    End With
'
'End Sub
'
'Public Sub ReplaceSingle(str As String, Optional Registered As Boolean = False)
'    Dim repStr As String
'    repStr = str
'    Selection.find.ClearFormatting
'    Selection.find.Replacement.ClearFormatting
'    With Selection.find
'        .text = UCase(str)
'        .Replacement.text = LCase(str)
'        .Forward = True
'        .Wrap = wdFindContinue
'        .Format = False
'        .MatchCase = True
'        .MatchWholeWord = True
'        .MatchByte = False
'        .MatchWildcards = False
'        .MatchSoundsLike = False
'        .MatchAllWordForms = False
'    End With
'    Selection.find.Execute Replace:=wdReplaceAll
'
'    If Registered Then repStr = str & "|fffd|"
'
'    Selection.find.ClearFormatting
'    Selection.find.Replacement.ClearFormatting
'    With Selection.find
'        .text = str
'        .Replacement.text = repStr
'        .Forward = True
'        .Wrap = wdFindContinue
'        .Format = False
'        .MatchCase = False
'        .MatchWholeWord = True
'        .MatchByte = False
'        .MatchWildcards = False
'        .MatchSoundsLike = False
'        .MatchAllWordForms = False
'    End With
'    Selection.find.Execute Replace:=wdReplaceAll
'End Sub

Function GetUserFullName() As String
    Dim objWin32NLP As Object
    Dim objItem As Object
    Dim strName As String
    strName = ""
    On Error Resume Next
    ' Win32_NetworkLoginProfile class  https://msdn.microsoft.com/en-us/library/aa394221%28v=vs.85%29.aspx
    Set objWin32NLP = GetObject("WinMgmts:").InstancesOf("Win32_NetworkLoginProfile")
    If Err.Number <> 0 Then
      strName = Environ$("UserName")
    Else
        For Each objItem In objWin32NLP
            If objItem.flags > 0 Then
                strName = objItem.fullName
                If InStr(strName, ",") > 0 Then
                    Dim aStrName() As String
                    aStrName = Split(strName, ",", 2)
                    strName = Trim(aStrName(1)) & " " & Trim(aStrName(0))
                End If
            End If
        Next
    End If
    GetUserFullName = strName
End Function

'Public Function IsLockedOld() As Boolean
'    Dim firstParaRange As Range
'    Dim lastParaRange As Range
'    Dim rngParas As Range
'    Dim cc As ContentControl
'    Dim ccs As ContentControls
'    Dim rng As Range
'    Dim locked As Boolean
'    locked = False
'
'    Set firstParaRange = Selection.Range.Paragraphs.first.Range
'    Set lastParaRange = Selection.Range.Paragraphs.Last.Range
'
'    Set rngParas = Selection.Range.Duplicate
'    rngParas.start = firstParaRange.start
'    rngParas.End = lastParaRange.End
'    Set ccs = rngParas.ContentControls
'    If ccs.Count > 0 Then
'        For Each cc In ccs
'            If cc.LockContents = True Then
'                locked = True
'                Exit For
'            End If
'        Next
'    End If
'    IsLockedOld = locked
'
'End Function

'Public Function IsLocked() As Boolean
'    Dim ScreenUpdating As Boolean
'    ScreenUpdating = Application.ScreenUpdating
'    If ScreenUpdating = True Then Application.ScreenUpdating = False
'    Dim cc As ContentControl
'    Dim ccs As ContentControls
'
'    Dim locked As Boolean
'    locked = False
'    Dim rng As Range
'    Dim rngTest As Range
'
'    Set rng = Selection.Range.Duplicate
'    Set ccs = rng.ContentControls
'
'    If ccs.Count > 0 Then
'        For Each cc In ccs
'            If cc.LockContents = True Then
'                locked = True
'                Exit For
'            End If
'        Next
'    End If
'
'    Set rngTest = rng.Duplicate
'
'    Dim objUndo As UndoRecord
'    Set objUndo = Application.UndoRecord
'    objUndo.StartCustomRecord "IsLocked"
'    If locked = False Then
'        rngTest.SetRange rng.start, rng.start
'        On Error GoTo StyleFail
'        rngTest.Style = rng.Style ' ActiveDocument.Styles(wdStyleNormal)
'        On Error GoTo 0
'    End If
'
'    If locked = False Then
'        rngTest.SetRange rng.End, rng.End
'        On Error GoTo StyleFail
'        rngTest.Style = rng.Style ' ActiveDocument.Styles(wdStyleNormal)
'        On Error GoTo 0
'    End If
'
'ExitIsLocked:
'    DV ActiveDocument, "IsLocked", ""
'    DV ActiveDocument, "IsLocked", "True"
'    objUndo.EndCustomRecord
'    ActiveDocument.Undo
'    rng.Select
'    IsLocked = locked
'    If ScreenUpdating <> Application.ScreenUpdating Then Application.ScreenUpdating = ScreenUpdating
'    Exit Function
'StyleFail:
'    locked = True
'    Resume ExitIsLocked
'
'End Function

Public Function IsLocked()
    IsLocked = Not CommandBars.FindControl(msoControlButton, 113).Enabled Or ActiveDocument.ReadOnly
End Function


Public Function OpenConvertFileDialog() As String
   Dim fullName As String
   fullName = ""
   Dim fd As Office.FileDialog
   Set fd = Application.FileDialog(msoFileDialogOpen)

   With fd
        .AllowMultiSelect = False
        Dim FileSaveAsSetting As String
        FileSaveAsSetting = Dialogs(wdDialogToolsOptionsFileLocations).Setting
        If Not Right$(FileSaveAsSetting, 1) = "\" And Not Right$(FileSaveAsSetting, 1) = "/" Then
            FileSaveAsSetting = FileSaveAsSetting + IIf(InStr(FileSaveAsSetting, "\") > 0, "\", "/")
        End If
        .initialFilename = FileSaveAsSetting
        ' Set the title of the dialog box.
        .Title = "Please select the file to import"
        
        .Filters.Clear
        .Filters.Add "Word", "*.doc, *.docx"
        .Filters.Add "All Files", "*.*"
        
        If .show = True Then
          fullName = .SelectedItems(1)
        End If
        .Title = ""
        .Filters.Clear
   End With
   Set fd = Nothing
   OpenConvertFileDialog = fullName
End Function

Public Function GetLanguageCode2CharFromLCID(ByVal lang2Char As String) As String
    Dim val As String
        
    Select Case LCase(lang2Char)
    Case "1025"
        val = "ar"
    Case "1026"
        val = "bg"
    Case "1027"
        val = "ca"
    Case "1028"
        val = "zh"
    Case "1029"
        val = "cs"
    Case "1030"
        val = "da"
    Case "1031"
        val = "de"
    Case "1032"
        val = "el"
    Case "1033"
        val = "en"
    Case "1034", "3082"
        val = "es"
    Case "1035"
        val = "fi"
    Case "1036"
        val = "fr"
    Case "1037"
        val = "he"
    Case "1038"
        val = "hu"
    Case "1039"
        val = "is"
    Case "1040"
        val = "it"
    Case "1041"
        val = "ja"
    Case "1042"
        val = "ko"
    Case "1043"
        val = "nl"
    Case "1044"
        val = "nb"
    Case "1045"
        val = "pl"
    Case "1046"
        val = "pt"
    Case "1047"
        val = "rm"
    Case "1048"
        val = "ro"
    Case "1049"
        val = "ru"
    Case "1050"
        val = "hr"
    Case "1051"
        val = "sk"
    Case "1052"
        val = "sq"
    Case "1053"
        val = "sv"
    Case "1054"
        val = "th"
    Case "1055"
        val = "tr"
    Case "1056"
        val = "ur"
    Case "1057"
        val = "id"
    Case "1058"
        val = "uk"
    Case "1059"
        val = "be"
    Case "1060"
        val = "sl"
    Case "1061"
        val = "et"
    Case "1062"
        val = "lv"
    Case "1063"
        val = "lt"
    Case "1064"
        val = "tg"
    Case "1065"
        val = "fa"
    Case "1066"
        val = "vi"
    Case "1067"
        val = "hy"
    Case "1068"
        val = "az"
    Case "1069"
        val = "eu"
    Case "1070"
        val = "sb"
    Case "1071"
        val = "mk"
    Case "1072"
        val = ""
    Case "1073"
        val = "ts"
    Case "1074"
        val = "tn"
    Case "1075"
        val = ""
    Case "1076"
        val = "xh"
    Case "1077"
        val = "zu"
    Case "1078"
        val = "af"
    Case "1079"
        val = "ka"
    Case "1080"
        val = "fo"
    Case "1081"
        val = "hi"
    Case "1082"
        val = "mt"
    Case "1083"
        val = ""
    Case "1084"
        val = "gd"
    Case "1085"
        val = "yi"
    Case "1086"
        val = "ms"
    Case "1087"
        val = "kk"
    Case "1088"
        val = ""
    Case "1089"
        val = "sw"
    Case "1090"
        val = "tk"
    Case "1091"
        val = "uz"
    Case "1092"
        val = "tt"
    Case "1093"
        val = "bn"
    Case "1094"
        val = "pa"
    Case "1095"
        val = "gu"
    Case "1096"
        val = "or"
    Case "1097"
        val = "ta"
    Case "1098"
        val = "te"
    Case "1099"
        val = "kn"
    Case "1100"
        val = "ml"
    Case "1101"
        val = "as"
    Case "1102"
        val = "mr"
    Case "1103"
        val = "sa"
    Case "1104"
        val = "mn"
    Case "1105"
        val = "bo"
    Case "1106"
        val = "cy"
    Case "1107"
        val = "km"
    Case "1108"
        val = "lo"
    Case "1109"
        val = "my"
    Case "1110"
        val = "gl"
    Case "1111"
        val = ""
    Case "1112"
        val = ""
    Case "1113"
        val = "sd"
    Case "1114"
        val = ""
    Case "1115"
        val = "si"
    Case "1118"
        val = "am"
    Case "1120"
        val = "ks"
    Case "1121"
        val = "ne"
    Case "1122"
        val = ""
    Case "1124"
        val = ""
    Case "1125"
        val = "dv"
    Case "1126"
        val = ""
    Case "1136"
        val = ""
    Case "1140"
        val = "gn"
    Case "1142"
        val = "la"
    Case "1143"
        val = "so"
    Case "1153"
        val = "mi"
    Case "1279"
        val = ""
    Case "2049"
        val = "ar"
    Case "2052"
        val = "zh"
    Case "2055"
        val = "de"
    Case "2057"
        val = "en"
    Case "2058"
        val = "es"
    Case "2060"
        val = "fr"
    Case "2064"
        val = "it"
    Case "2067"
        val = "nl"
    Case "2068"
        val = "nn"
    Case "2070"
        val = "pt"
    Case "2072"
        val = "ro"
    Case "2073"
        val = "ru"
    Case "2074"
        val = "sr"
    Case "2077"
        val = "sv"
    Case "2092"
        val = "az"
    Case "2108"
        val = "gd"
    Case "2110"
        val = "ms"
    Case "2115"
        val = "uz"
    Case "2117"
        val = "bn"
    Case "2128"
        val = "mn"
    Case "3073"
        val = "ar"
    Case "3076"
        val = "zh"
    Case "3079"
        val = "de"
    Case "3081"
        val = "en"
    Case "3084"
        val = "fr"
    Case "3098"
        val = "sr"
    Case "4097"
        val = "ar"
    Case "4100"
        val = "zh"
    Case "4103"
        val = "de"
    Case "4105"
        val = "en"
    Case "4106"
        val = "es"
    Case "4108"
        val = "fr"
    Case "5121"
        val = "ar"
    Case "5124"
        val = "zh"
    Case "5127"
        val = "de"
    Case "5129"
        val = "en"
    Case "5130"
        val = "es"
    Case "5132"
        val = "fr"
    Case "5146"
        val = "bs"
    Case "6145"
        val = "ar"
    Case "6153"
        val = "en"
    Case "6154"
        val = "es"
    Case "6156"
        val = "fr"
    Case "7169"
        val = "ar"
    Case "7177"
        val = "en"
    Case "7178"
        val = "es"
    Case "7180"
        val = "fr"
    Case "8193"
        val = "ar"
    Case "8201"
        val = "en"
    Case "8202"
        val = "es"
    Case "9217"
        val = "ar"
    Case "9225"
        val = "en"
    Case "9226"
        val = "es"
    Case "9228"
        val = "fr"
    Case "10241"
        val = "ar"
    Case "10249"
        val = "en"
    Case "10250"
        val = "es"
    Case "10252"
        val = "fr"
    Case "11265"
        val = "ar"
    Case "11273"
        val = "en"
    Case "11274"
        val = "es"
    Case "11276"
        val = "fr"
    Case "12289"
        val = "ar"
    Case "12297"
        val = "en"
    Case "12298"
        val = "es"
    Case "12300"
        val = "fr"
    Case "13313"
        val = "ar"
    Case "13321"
        val = "en"
    Case "13322"
        val = "es"
    Case "13324"
        val = "fr"
    Case "14337"
        val = "ar"
    Case "14346"
        val = "es"
    Case "14348"
        val = "fr"
    Case "15361"
        val = "ar"
    Case "15370"
        val = "es"
    Case "16385"
        val = "ar"
    Case "16393"
        val = "en"
    Case "16394"
        val = "es"
    Case "17418"
        val = "es"
    Case "18442"
        val = "es"
    Case "19466"
        val = "es"
    Case "20490"
        val = "es"
    Case Else
        val = "2057"
    End Select
    GetLanguageCode2CharFromLCID = val
End Function


Public Function GetDateFromCrisplantDate(ByVal crisplantDate As String, Optional defaultDate As String = "YYYY-MM-DD") As String
    Dim aCrisplantDate() As String
    Dim i As Integer
    Dim reps As Integer
    
    Dim Day As String
    Dim Month As String
    Dim Year As String
    
    
    crisplantDate = Replace(Replace(Replace(Replace(Replace(Replace(crisplantDate, ChrW(26376), "-"), ChrW(24180), "-"), ChrW(26085), ""), ChrW(-20156), "-"), ChrW(-14636), "-"), ChrW(-14468), "")
    
    If crisplantDate Like "####[!0-9]##[!0-9]##*" Or crisplantDate Like "####[!0-9]#[!0-9]##*" Or crisplantDate Like "####[!0-9]##[!0-9]#*" Or crisplantDate Like "####[!0-9]#[!0-9]#*" Then
        reps = 0
        For i = 1 To Len(crisplantDate)
            If AscW(Mid(crisplantDate, i, 1)) < 48 Or AscW(Mid(crisplantDate, i, 1)) > 57 Then
                reps = reps + 1
                Mid(crisplantDate, i, 1) = "-"
            End If
        Next
        If reps > 2 Then
            i = InStr(crisplantDate, "-")
            i = InStr(i + 1, crisplantDate, "-")
            i = InStr(i + 1, crisplantDate, "-")
            crisplantDate = Left(crisplantDate, i - 1)
        End If
        GetDateFromCrisplantDate = crisplantDate
    Else
        If crisplantDate Like "* de *" Then
            crisplantDate = Replace(crisplantDate, " de ", " ")
        End If
        aCrisplantDate() = Split(Replace(Replace(Replace(Replace(crisplantDate, Chr(160), " "), ".", ""), ",", ""), "-", " "), " ")
        For i = 0 To UBound(aCrisplantDate)
             If i > 2 Then
             Else
                 If IsNumeric(aCrisplantDate(i)) Then
                    If Len(aCrisplantDate(i)) > 2 Or aCrisplantDate(i) > 31 Then
                        Year = Right("19" & aCrisplantDate(i), 4)
                    Else
                        Day = Right("00" & aCrisplantDate(i), 2)
                    End If
                 Else
                    If Months.Exists(aCrisplantDate(i)) Then
                        Month = Months(aCrisplantDate(i))
                    ElseIf Months.Exists(UCase(aCrisplantDate(i))) Then
                        Month = Months(UCase(aCrisplantDate(i)))
                    ElseIf Months.Exists(LCase(aCrisplantDate(i))) Then
                        Month = Months(LCase(aCrisplantDate(i)))
                    Else
                        Select Case LCase(aCrisplantDate(i))
                           Case "jan"
                               Month = 1
                           Case "feb"
                               Month = 2
                           Case "mar"
                               Month = 3
                           Case "apr"
                               Month = 4
                           Case "maj"
                               Month = 5
                           Case "jun"
                               Month = 6
                           Case "jul"
                               Month = 7
                           Case "aug"
                               Month = 8
                           Case "sep"
                               Month = 9
                           Case "okt"
                               Month = 10
                           Case "nov"
                               Month = 11
                           Case "dec"
                               Month = 12
                           Case "m|fffd|r"
                               Month = 3
                           Case "mai"
                               Month = 5
                           Case "dez"
                               Month = 12
                           Case "f|fffd|v"
                               Month = 2
                           Case "avr"
                               Month = 4
                           Case "juin"
                               Month = 6
                           Case "juil"
                               Month = 7
                           Case "ao|fffd|t"
                               Month = 8
                           Case "oct"
                               Month = 10
                           Case "d|fffd|c"
                               Month = 12
                           Case "ene"
                               Month = 1
                           Case "abr"
                               Month = 4
                           Case "may"
                               Month = 5
                           Case "ago"
                               Month = 8
                           Case "dic"
                               Month = 12
                           Case "fev"
                               Month = 2
                           Case "set"
                               Month = 9
                           Case "Out"
                               Month = 10
                           Case "sept"
                               Month = 9
                            ' Italian
                            Case "gen"
                                Month = 1
                            Case "feb"
                                Month = 2
                            Case "mar"
                                Month = 3
                            Case "apr"
                                Month = 4
                            Case "mag"
                                Month = 5
                            Case "giu"
                                Month = 6
                            Case "lug"
                                Month = 7
                            Case "ago"
                                Month = 8
                            Case "set"
                                Month = 9
                            Case "ott"
                                Month = 10
                            Case "nov"
                                Month = 11
                            Case "dic"
                                Month = 12
                           Case Else
                               Month = "  "
                        End Select
                        Month = Right("00" & Month, 2)
                    End If
                End If
            End If
        Next
        If Month = "  " And Year > "" And Day > "" Then
            GetDateFromCrisplantDate = Year & "-" & "01" & "-" & Day
        Else
            GetDateFromCrisplantDate = IIf(Year & "-" & Month & "-" & Day = "-  -", defaultDate, Year & "-" & Month & "-" & Day)
        End If
    End If
 End Function
    
Public Function GetPaperFormatFromPageSetup(doc As Document) As String
    Dim paperFormat As String
    With doc.PageSetup
        
        If Abs(.pageHeight - 842) < 0.1 Then
            If .pageHeight < .PageWidth Then
                paperFormat = "A3 - Landscape"
            Else
                paperFormat = "A4 - Portrait"
            End If
        ElseIf Abs(.PageWidth - 842) < 0.1 Then
            If .pageHeight < .PageWidth Then
                paperFormat = "A4 - Landscape"
            Else
                paperFormat = "A3 - Portrait"
            End If
        ElseIf Abs(.pageHeight - 792) < 0.1 Then
            If .pageHeight < .PageWidth Then
                paperFormat = "Tabloid/Ledger - Landscape"
            Else
                paperFormat = "Letter - Portrait"
            End If
        ElseIf Abs(.PageWidth - 792) < 0.1 Then
            If .pageHeight < .PageWidth Then
                paperFormat = "Letter - Portrait"
            Else
                paperFormat = "Tabloid/Ledger - Landscape"
            End If
        End If
    End With
    GetPaperFormatFromPageSetup = paperFormat
    
End Function

Public Function Contains(col As Collection, key As Variant) As Boolean
    On Error Resume Next
    col (key)
    Contains = (Err.Number = 0)
    Err.Clear
End Function

Public Function findFile(sourceFullName As String) As String
    On Error GoTo Failed
    Dim ok As Boolean
    
    Dim FoundFile As String
    Dim strFindFile As String
    
    FoundFile = ""
    strFindFile = FixPath(sourceFullName)
    If strFindFile = "" Then
        FoundFile = ""
    ElseIf GetFileName(strFindFile) <> "" Then
        FoundFile = strFindFile
    Else
        FoundFile = ""
    End If
    ok = (FoundFile > "")
ExitIt:
    On Error GoTo 0
    If ok Then
        findFile = FoundFile
    End If
    Exit Function

Failed:
    Select Case Err.Number
    Case 52 'Bad file name or number
        ok = False
        Resume ExitIt
    Case Else
        Debug.Print "Case " & Err.Number & " '" & Err.Description
        Stop
        Resume Next
        ok = False
        Resume ExitIt
    End Select
    
End Function

Public Function GetFileName(strFile As String, Optional urlType As String = "") As String
    Dim strFound As String
    strFound = ""
    On Error Resume Next
    strFound = Dir(FixPath(strFile, urlType))
    On Error GoTo 0
    GetFileName = strFound
End Function

Public Function GetFileDate(strFile As String, Optional urlType As String = "") As Date
    Dim dtFile As Date
    On Error Resume Next
    dtFile = FileDateTime(FixPath(strFile, urlType))
    On Error GoTo 0
    GetFileDate = dtFile
End Function

Public Function FindDocumentationFile(sourceFullName As String, docPath As String) As String
    Dim FoundFile As String
    Dim findFile As String
    Dim FindPath As String
    Dim aFullname() As String
    Dim i As Integer
    Dim path As String
    Dim testFile As String
    
    FoundFile = ""
    findFile = FixPath(sourceFullName)
    FindPath = FixPath(docPath)
    If findFile = "" Then
        FoundFile = ""
    ElseIf GetFileName(findFile) <> "" Then
        FoundFile = findFile
    Else
        path = ""
        aFullname = Split(findFile, "\")
        
        For i = UBound(aFullname) To 2 Step -1
            path = "\" & aFullname(i) & path
            testFile = rootV & path
            'If testFile = "L:\Dokument\ats\_Pictures\LS-4000\05 LSM\05A034_03.jpg" Then Stop
            If GetFileName(testFile) <> "" Then
                Debug.Print "*"; testFile
                FoundFile = testFile
                Exit For
            End If
        Next
    End If
    If FoundFile = "" Then
        If LCase(sourceFullName) Like LCase("*\_Pictures\*") Then
            testFile = rootV & "\ATS" & Mid(sourceFullName, InStr(1, sourceFullName, "\_Pictures\", vbTextCompare))
            If GetFileName(testFile) <> "" Then
                FoundFile = testFile
            End If
        End If
    End If
    If FoundFile = "" Then
        If LCase(sourceFullName) Like LCase("*\_Grafik\*") Then
            testFile = rootV & "\ATS" & Mid(sourceFullName, InStr(1, sourceFullName, "\_Grafik\", vbTextCompare))
            If GetFileName(testFile) <> "" Then
                FoundFile = testFile
            End If
        End If
    End If
    
    FindDocumentationFile = FoundFile
End Function

Public Function GetFileNameFromCode(fldCode As String) As String
    Dim RegExpObj As Object
    Dim str As String
    str = Replace(Replace(fldCode, "\\", "|"), "/", "#")
    Dim matches As Object
    Dim fileName As String
    Set RegExpObj = CreateObject("vbscript.regexp")
    With RegExpObj
        .IgnoreCase = True
        .Pattern = "(INCLUDEPICTURE|EMBED) ([^\\$]*)"
        If .Test(str) Then
            Set matches = .Execute(str)
            fileName = Replace(Replace(Trim(matches(0).SubMatches(1)), "#", "/"), "|", "\")
        Else
            fileName = ""
        End If
    End With
    GetFileNameFromCode = fileName
End Function

Public Function GetClipBoardText() As String
   Dim str As String
   Dim DataObj As MSForms.DataObject
   Set DataObj = New MSForms.DataObject '<~~ Amended as per jp's suggestion

   On Error GoTo Whoa

   '~~> Get data from the clipboard.
   DataObj.GetFromClipboard

   '~~> Get clipboard contents
   str = DataObj.GetText(1)
   GetClipBoardText = str

ExitIt:
   Exit Function
   
Whoa:
   GetClipBoardText = ""
   Resume ExitIt
End Function

Function FileExists(ByVal FileToTest As String, Optional urlType As String = "") As Boolean
   FileExists = (GetFileName(FileToTest, urlType) <> "")
End Function

Sub DeleteFile(ByVal FileToDelete As String)
   If FileExists(FileToDelete) Then 'See above
      SetAttr FileToDelete, vbNormal
      Kill FileToDelete
   End If
End Sub

Public Function InlineIsPictureOrObject(shp As Word.InlineShape) As Boolean
     If shp.Type >= 1 And shp.Type <= 5 Then
         If ((shp.Width < 40 And shp.Height < 25) Or (shp.Width < 30 And shp.Height < 30)) _
         And shp.Range.Style.NameLocal = "Table Text" And shp.LinkFormat Is Nothing Then
             InlineIsPictureOrObject = False
         Else
             InlineIsPictureOrObject = True
         End If
     Else
         InlineIsPictureOrObject = False
     End If
 End Function

 Public Function ShapeIsPictureOrObject(shp As Word.Shape) As Boolean
     If shp.Type = 7 Or shp.Type = 10 Or shp.Type = 11 Or shp.Type = 12 Or shp.Type = 13 Then
         If ((shp.Width < 40 And shp.Height < 25) Or (shp.Width < 30 And shp.Height < 30)) _
         And shp.Anchor.Style.NameLocal = "Table Text" And shp.LinkFormat Is Nothing Then
             ShapeIsPictureOrObject = False
         Else
             ShapeIsPictureOrObject = True
         End If
     Else
         ShapeIsPictureOrObject = False
     End If
 End Function

Public Function GetAutomationObject() As Object
    Dim Addin As COMAddIn
    Set Addin = Nothing
    On Error Resume Next
    Dim i As Integer
    For i = 1 To Application.COMAddIns.Count
        If Application.COMAddIns(i).ProgID Like "*BGOA*" Then
            Set Addin = Application.COMAddIns(i)
            Exit For
        End If
    Next
    On Error GoTo 0
    If Addin Is Nothing Then
        Set GetAutomationObject = Nothing
    Else
        Set GetAutomationObject = Addin.Object
    End If
End Function

Public Function UpdateAlternativeText(text As String, action As String, Optional atTime As Date = #12:00:00 AM#) As String
    Dim RegExpObj As Object
    Dim matches As Object
    Dim lang As String
    Dim code As String
    Dim found As Boolean
    found = False
    If atTime = #12:00:00 AM# Then atTime = UTCTime(Now)
    
    Set RegExpObj = CreateObject("vbscript.regexp")
    With RegExpObj
        .Global = True
        .Pattern = "(\[" & action & ":(\d{2}-\d{2}-\d{4} \d{2}:\d{2}:\d{2})\])"
        If .Test(text) Then
            found = True
        End If
        If found Then
            text = RegExpObj.Replace(text, "[" & action & ":" & atTime & "]")
        Else
            text = "[" & action & ":" & atTime & "]" & IIf(text = "", "", vbCrLf) & text ', "YYYY-MM-DD HH:mm:ss") & "]"
        End If
    End With
    UpdateAlternativeText = text
End Function

Public Function GetTime(text As String, action As String) As Date
    Dim RegExpObj As Object
    Dim matches As Object
    Dim lang As String
    Dim code As String
    Dim found As Boolean
    Dim dt As Date
    
    found = False
    Set RegExpObj = CreateObject("vbscript.regexp")
    With RegExpObj
        .Global = True
        .Pattern = "(\[" & action & ":(\d{2})-(\d{2})-(\d{4}) (\d{2}:\d{2}:\d{2})\])"
        If .Test(text) Then
            found = True
        End If
        If found Then
            Set matches = .Execute(text)
            dt = LocalTime(CDate(matches(0).SubMatches(3) & "-" & matches(0).SubMatches(2) & "-" & matches(0).SubMatches(1) & " " & matches(0).SubMatches(4)))
        Else
            dt = #12:00:00 PM#
        End If
    End With
    GetTime = dt
End Function

Public Function CalculateMultiLineTitle(formula As String, Optional DX As DOCXML = Nothing, Optional KeepLineFeeds As Boolean = False) As String
    Dim aFormula() As String
    Dim str As Variant
    Dim result As String
    Dim part As String
    
    aFormula = Split(formula, vbCrLf)
    For Each str In aFormula
        If Not IsEmpty(str) Then
            part = CalculateTitle(CStr(str), DX, KeepLineFeeds)
            If part > "" Then
                result = result & IIf(result > "", vbCrLf, "") & CalculateTitle(CStr(str), DX, KeepLineFeeds)
            End If
        End If
    Next
    CalculateMultiLineTitle = result
End Function


Public Function CalculateTitle(formula As String, Optional DX As DOCXML = Nothing, Optional KeepLineFeeds As Boolean = False) As String
    If DX Is Nothing Then
        Set DX = New DOCXML
        DX.Init
    End If
    On Error GoTo ErrorCalculate
        
    Dim i As Integer
    Dim re As Object
    Dim matches As Object
    Dim match As Object
    Dim strFixed As String
    Dim strLookup As String
    Dim strValue As String
    Dim aResult() As String
    Dim strResult As String
    strResult = ""
    Dim strDivider As String
    strDivider = ""
    Dim HighestDivider As Integer
    HighestDivider = -1
    Dim CurrentDivider As Integer
    CurrentDivider = -1
    Dim strCurrentDivider As String
    strCurrentDivider = ""
    Dim HasFirst As Boolean
    HasFirst = False
    
    Dim reProj As Object
    Dim matchesProj As Object
    
    
    Const More = 2
    Const Fixed = 1
    Const Calc = 0
    
    Dim m As Integer
    Dim aMatch() As String
    
    Set re = CreateObject("vbscript.regexp")
    With re
         .IgnoreCase = True
         .Global = True
         .Pattern = ".+?(?=\[\[)|\[\[.*"
         If .Test(formula) Then
             Set matches = .Execute(formula)
             ReDim aResult(matches.Count - 1, 3)
             For m = 0 To matches.Count - 1
                 Set match = matches(m)
                 aMatch = Split(match, "]]")
                 If UBound(aMatch) = 1 Then
                    strLookup = Mid(aMatch(0), 3)
                    aResult(m, Fixed) = aMatch(1)
                 Else
                    strLookup = ""
                    aResult(m, Fixed) = aMatch(0)
                    If m = 0 Then HasFirst = True
                 End If
                 If strLookup > "" Then
                    'Calculate. Remember LanguageCode
                    Dim tryRead As String
                    If strLookup = "Language" Then
                        If DX.TryReadText("/DocumentInfo/DocumentInfo-Language", tryRead) Then
                            For i = 0 To UBound(aLanguages, 1)
                                If aLanguages(i, 0) = tryRead Then
                                    aResult(m, Calc) = aLanguages(i, 2)
                                    Exit For
                                End If
                            Next
                        End If
                    ElseIf strLookup = "FormName" Then
                        If DX.ThisBGD.FormName > "" Then
                             aResult(m, Calc) = DX.ThisBGD.FormName
                        Else
                             aResult(m, Calc) = ""
                        End If
                    ElseIf strLookup = "MainProjectNo" Then
                        If DX.TryReadText("/DocumentInfo/DocumentInfo-ProjectNo", tryRead) Then
                            If tryRead = "" Then
                                aResult(m, Calc) = ""
                            Else
                                Set reProj = CreateObject("vbscript.regexp")
                                With reProj
                                    .IgnoreCase = True
                                    .Global = True
                                    .Pattern = "^(?:[sS]|)([\d|-]*).*$"
                                    If .Test(tryRead) Then
                                        Set matchesProj = .Execute(tryRead)
                                        aResult(m, Calc) = matchesProj(0).SubMatches(0)
                                    End If
                                End With
                            End If
                        End If
                    ElseIf strLookup = "LanguageCode" Then
                        If DX.TryReadText("/DocumentInfo/DocumentInfo-Language", tryRead) Then
                            For i = 0 To UBound(aLanguages, 1)
                                If aLanguages(i, 0) = tryRead Then
                                    aResult(m, Calc) = aLanguages(i, 3)
                                    Exit For
                                End If
                            Next
                        End If
                    ElseIf strLookup = "Date" Then
                        If DX.TryReadText("/DocumentInfo/DocumentInfo-Date", tryRead) Then
                            aResult(m, Calc) = Left(tryRead, 10)
                        End If
                    ElseIf strLookup Like "Line*" Then
                        If DX.TryReadText("/DocumentInfo/DocumentInfo-Title" & strLookup, tryRead) Then
                            aResult(m, Calc) = tryRead
                        End If
                    Else
                        If DX.TryReadText("/DocumentInfo/DocumentInfo-" & strLookup, tryRead) Then
                            aResult(m, Calc) = tryRead
                        End If
                    End If
                 End If
             Next
             For m = matches.Count - 2 To 0 Step -1
                 If aResult(m + 1, Calc) > "" Or aResult(m + 1, More) > "" Then
                    aResult(m, More) = "More"
                 End If
                 'Debug.Print matches(m), aResult(m, Calc), aResult(m, Fixed), aResult(m, More)
             Next
             Dim mStart As Integer
             mStart = 0
             If HasFirst And aResult(0, More) > "" Then
                mStart = 1
             End If
                         
             For m = mStart To matches.Count - 1
                If aResult(m, Calc) > "" Then
                    If strResult > "" And strDivider > "" Then
                        strResult = strResult & strDivider
                        strDivider = ""
                        HighestDivider = -1
                    End If
                    strResult = strResult & aResult(m, Calc)
                End If
                
                strCurrentDivider = aResult(m, Fixed)
                If strCurrentDivider > "" Then
                    'If m = 0 Then
                        'CurrentDivider = 99
                    If m = matches.Count - 1 Then
                        CurrentDivider = 98
                    ElseIf Len(Trim(strCurrentDivider)) > 1 Then
                        CurrentDivider = 5
                    ElseIf InStr(strCurrentDivider, ":") > 0 Then
                        CurrentDivider = 4
                    ElseIf InStr(strCurrentDivider, ",") > 0 Then
                        CurrentDivider = 3
                    ElseIf InStr(strCurrentDivider, "-") > 0 Then
                        CurrentDivider = 2
                    ElseIf Len(Trim(strCurrentDivider)) = 1 Then
                        CurrentDivider = 1
                    ElseIf InStr(strCurrentDivider, " ") > 0 Then
                        CurrentDivider = 0
                    Else
                        CurrentDivider = -1
                    End If
                End If
                If CurrentDivider >= HighestDivider Then
                    HighestDivider = CurrentDivider
                    strDivider = strCurrentDivider
                End If
                
                If strResult > "" And HighestDivider = 98 Then ' Last
                    strResult = strResult & strDivider
                End If
             Next
             If HasFirst And strResult > "" Then
                strResult = aResult(0, Fixed) & strResult
             End If
         Else
            strResult = formula
         End If
         
    End With
    
    On Error GoTo 0
    If KeepLineFeeds Then
        CalculateTitle = strResult
    Else
        CalculateTitle = Replace(Replace(Replace(strResult, vbCr, ". "), vbLf, ". "), ".. ", ". ")
    End If
    Exit Function
ResumeErrorCalculate:
    CalculateTitle = "Error in formula!"
    Exit Function
    
ErrorCalculate:
    Resume ResumeErrorCalculate
End Function

Public Function IsMatch(str As String, reg As String) As Boolean
    Dim ok As Boolean
    Dim re As Object
    Dim matches As Object
    Dim match As Object
    
    ok = False
    
    Set re = CreateObject("vbscript.regexp")
    With re
         .IgnoreCase = True
         .Global = True
         .Pattern = reg
         If .Test(str) Then
            ok = True
         End If
    End With
    
    IsMatch = ok
End Function

Public Function GetDocType(DocNo As String) As String
    Dim DocType As String
    
    If IsMatch(DocNo, "^.*\/.*$") Then
        DocType = "O & M Document"
    ElseIf IsMatch(DocNo, "^(F)(?:[0-9])+.*$") Then
        DocType = "Functional Description"
    ElseIf IsMatch(DocNo, "^(E)_CB(?:[0-9])?.*$") Then
        DocType = "Element Description"
    ElseIf IsMatch(DocNo, "^(H)(?:[0-9])+.*$") Then
        DocType = "Hardware Description"
    ElseIf IsMatch(DocNo, "^[0-9]+(?:_(M)_)+.*$|^(M)(?:_CB|_|)?(?:[0-9])+.*$") Then
        DocType = "Installation Instruction"
    ElseIf IsMatch(DocNo, "^(P)(?:[0-9])+.*$") Then
        DocType = "Design rules"
    ElseIf IsMatch(DocNo, "^(R)(?:_CB|_|)?(?:[0-9])+.*$") Then
        DocType = "Spare Parts List"
    ElseIf IsMatch(DocNo, "^(RE)(?:[0-9])+.*$") Then
        DocType = "Retrofit Instruction"
    ElseIf IsMatch(DocNo, "^(T)(?:_CB|_|)?.*([0-9]{2,})+.*$") Then
        DocType = "Preventive Maintenance"
    ElseIf IsMatch(DocNo, "^(U)(?:_CB|_|)?(?:[0-9])+.*$") Then
        DocType = "Replacement Instruction"
    ElseIf IsMatch(DocNo, "^(O)(?:_CB|_|).*$") Then
        DocType = "Operator Instruction"
    Else
        DocType = ""
    End If
    GetDocType = DocType
    
End Function

Public Sub NewComposeMaster()
    Dim rng As Range
    Dim sgmFile As String
    Dim FileSaveAsSetting As String
    Dim NextLine As String
    Dim styH As Style
  
    Dim Paper As String
    Dim SaveTheFile As Boolean
    Dim PrintTheFile As Boolean
    Dim MakeFileFilter As String
    Dim SecBreak As Boolean
    Dim MakeFileDir As String
    Dim MakeFileName As String
    Dim tagName As String
    Dim tagText As String
    Dim GoToBye As Boolean
    Dim currentDir As String
    Dim IncludeResult As Boolean
    Dim DocFileName As String
    Dim firstFile As Boolean
    
    Dim DX As New DOCXML
    DX.Init
    DX.method = "Update"
    DX.Prolog "Compose Master"
    
    firstFile = True
    
    With Application.FileDialog(msoFileDialogFilePicker)
        .Filters.Clear
        .AllowMultiSelect = False
        .ButtonName = "Load SGM file"
        .Title = "Select an SGM file"
        .Filters.Add "SGM File", "*.sgm", 1
        .FilterIndex = 1
        .Filters.Add "All files", "*.*", 2
        .InitialView = msoFileDialogViewLargeIcons
        FileSaveAsSetting = Dialogs(wdDialogToolsOptionsFileLocations).Setting
        If Not Right$(FileSaveAsSetting, 1) = "\" And Not Right$(FileSaveAsSetting, 1) = "/" Then
            FileSaveAsSetting = FileSaveAsSetting + IIf(InStr(FileSaveAsSetting, "\") > 0, "\", "/")
        End If
        .initialFilename = FileSaveAsSetting
        If .show = -1 Then
            sgmFile = .SelectedItems(1)
            .Filters.Clear
        Else
            .Filters.Clear
            GoTo ExitSub
        End If
    End With
    sgmFile = FixPath(sgmFile)
    If Dir(sgmFile) > "" Then
        On Error Resume Next
        Close
        On Error GoTo 0

        Open sgmFile For Input As 1
        While Not EOF(1)
            Line Input #1, NextLine
            NextLine = Trim(NextLine)
            ExtractParaTag NextLine, tagName, tagText
            tagName = UCase(tagName)
            Select Case tagName
            Case "CHDIR"
                currentDir = tagText
            Case "CHDIR2"
                'Skip
                'currentDir = tagText
            Case "SECBREAK ON"
                SecBreak = True
            Case "SECBREAK OFF"
                SecBreak = False
            Case "INCL"
                tagText = currentDir & IIf(InStr(currentDir, "\") > 0, "\", "/") & tagText
                If firstFile Then
                    Set styH = ActiveDocument.Paragraphs.Last.Style
                    If styH = ActiveDocument.Styles(-2).NameLocal Then
                        If ActiveDocument.Paragraphs.Last.Range.text = vbCr Then
                        ActiveDocument.Paragraphs.Last.Range.Delete
                        End If
                    End If
                    Selection.MoveEnd wdStory
                    Selection.Collapse wdCollapseEnd
                    Selection.InsertParagraphAfter
                    Selection.MoveEnd wdStory
                    Selection.Collapse wdCollapseEnd
                End If
                
                If False And firstFile Then
                    Dim FileDoesExist As Boolean
                    FileDoesExist = FileExists(tagText)
                    If FileDoesExist Then
                        firstFile = False
                        Dim doc As Document
                        Dim attachedTemplate As Template
                        Set attachedTemplate = ActiveDocument.attachedTemplate
                        Set doc = Application.Documents.Add(tagText, , , False)
                        If Not doc.attachedTemplate = attachedTemplate Then
                            doc.attachedTemplate = attachedTemplate.fullName
                        End If
                        doc.ActiveWindow.Visible = True
                        doc.Activate
                        If DX.ReadText("/DocumentInfo/DocumentInfo-DocType") = "" Then
                            Dim DocType As String
                            Dim aDocType() As String
                            DocType = Replace(tagText, "/", "\")
                            If InStr(DocType, "\") > 0 Then
                                DocType = Mid(DocType, InStrRev(DocType, "\") + 1)
                            End If
                            DocType = GetDocType(DocType)
                            If DocType = "" Then
                                DocType = "Project Document"
                            End If
                            DX.DocType = DocType
                            DX.WriteText "/DocumentInfo/DocumentInfo-DocType", DocType
                        End If
                        Set styH = ActiveDocument.Paragraphs.Last.Style
                        If styH = ActiveDocument.Styles(-2).NameLocal Then
                            If ActiveDocument.Paragraphs.Last.Range.text = vbCr Then
                            ActiveDocument.Paragraphs.Last.Range.Delete
                            End If
                        End If
                        Selection.MoveEnd wdStory
                        Selection.Collapse wdCollapseEnd
                    Else
                        GoToBye = True
                    End If
                Else
                    IncludeResult = IncludeTheFile(tagText, SecBreak)
                    If IncludeResult = False Then
                        GoToBye = True
                    End If
                End If
            Case "SAVE"
                SaveTheFile = True
                DocFileName = tagText
            Case "PRINT"
                PrintTheFile = True
                Case Else
                Rem Nothing
            End Select
            If GoToBye = True Then GoTo Bye
        Wend
Bye:
        Close
        
        DX.UpdateDocument
        DX.updated = True
        DX.Epilog
        Set DX = Nothing
    End If

ExitSub:
    Exit Sub
ErrorSub:
    
    DX.updated = False
    DX.Epilog
    Set DX = Nothing
    
    Resume ExitSub
End Sub

Private Function IncludeTheFile(file As String, SecBreak As Boolean)
    Dim FileDoesExist As Boolean
    Dim ShallWeGoOn As Boolean
    FileDoesExist = FileExists(file)
    If FileDoesExist Then
        If False And SecBreak = True Then
    '        WordBasic.InsertBreak Type:=2
    '        WordBasic.InsertField "INCLUDETEXT " + Current + "\\" + File
    '        WordBasic.ViewHeader
    '        WordBasic.ToggleHeaderFooterLink
    '        WordBasic.GoToHeaderFooter
    '        WordBasic.ToggleHeaderFooterLink
    '        WordBasic.ToggleHeaderFooterLink
    '        WordBasic.EndOfDocument
    '        WordBasic.StartOfLine 1
    '        WordBasic.FormatFont AllCaps:=1
    '        WordBasic.Insert "(" + WordBasic.[DefaultDir](0) + "\" + File + ")"
    '        WordBasic.CloseViewHeaderFooter
    '        IncludeTheFile = -1
    '        WordBasic.EndOfDocument
        Else
            Selection.InsertFile file
            IncludeTheFile = True
            Selection.EndKey Unit:=wdStory
        End If
    Else
        ShallWeGoOn = MsgBox("Include File: " + file + " not found! Continue?", "Make File Error", 4 + 32)
        If ShallWeGoOn Then
            IncludeTheFile = True
          Else
            IncludeTheFile = False
        End If
    End If
End Function

Private Sub ExtractParaTag(text As String, ByRef tagName As String, ByRef tagText As String)
    Dim StartTagBegin As Long
    Dim StartTagEnd As Long
    tagName = ""
    tagText = text
    StartTagBegin = InStr(text, "<")
    StartTagEnd = InStr(text, ">")
    If StartTagBegin = 1 And StartTagEnd > 1 Then
        tagName = Mid(text, StartTagBegin + 1, StartTagEnd - StartTagBegin - 1)
        If StartTagEnd < Len(text) Then
        tagText = Mid(text, StartTagEnd + 1, Len(text) - StartTagEnd + 1)
        Else
            tagText = ""
        End If
    End If
    tagName = Trim(tagName)
    tagText = Trim(tagText)
End Sub

Public Sub SetHeadingListTemplateColor(color As Long)
    Dim headStyle As Style
    Dim templ As ListTemplate
    Dim i As Integer
    
    Set headStyle = ActiveDocument.Styles(wdStyleHeading1)
    Set templ = headStyle.ListTemplate
    For i = 1 To 8
        templ.ListLevels(i).Font.color = color ' wdColorBlack
    Next
End Sub

Public Function CDP(doc As Word.Document, strProperty As String, Optional mdpType As MsoDocProperties = msoPropertyTypeString, Optional varValue As Variant = Null, Optional blnForce As Boolean = False) As Object
' CustomDocumentProperty
' Empty string deletes property
' ? CDP(ActiveDocument, "Palle", msoPropertyTypeString, "aString").Value 'V|fffd|rdien
' ? CDP(ActiveDocument, "Palle", msoPropertyTypeBoolean, True, True) 'datatype changed
' ? CDP(ActiveDocument, "Palle")
' ? CDP(ActiveDocument, "Palle",,"") 'property deleted
    
    Dim prp As Object 'DocumentProperty
    
    Set prp = Nothing
    On Error Resume Next
    Set prp = doc.CustomDocumentProperties(strProperty)
    On Error GoTo 0
    If prp Is Nothing Then
        If Not IsNull(varValue) And varValue <> "" Then
            On Error Resume Next
            doc.CustomDocumentProperties.Add _
                Name:=strProperty, LinkToContent:=False, value:=varValue, Type:=mdpType
            Set prp = doc.CustomDocumentProperties(strProperty)
            On Error GoTo 0
        End If
    Else
        If Not IsNull(varValue) Then
            If varValue = "" Then ' DELETE PROPERTY!
                prp.Delete
                Set prp = Nothing
            Else
                If prp.Type = mdpType Then
                    On Error Resume Next
                    prp.value = varValue
                    On Error GoTo 0
                    If Not prp.value = varValue Then
                        Set prp = Nothing
                    End If
                Else
                    If blnForce Then ' Change type of this property
                        On Error Resume Next
                        prp.Delete
                        doc.CustomDocumentProperties.Add _
                            Name:=strProperty, LinkToContent:=False, value:=varValue, Type:=mdpType
                            Set prp = Nothing
                            Set prp = doc.CustomDocumentProperties(strProperty)
                        On Error GoTo 0
                    Else
                        Set prp = Nothing
                    End If
                End If
            End If
        End If
    End If
    Set CDP = prp
End Function

Public Function BDP(doc As Word.Document, strProperty As String, Optional varValue As Variant = Null) As Object
' BuiltInDocumentProperty
' Empty string clears property
' ? BDP(ActiveDocument, "Subject").Value 'V|fffd|rdien
' ? BDP(ActiveDocument, "Subject","aNewValue") 'V|fffd|rdien
' ? BDP(ActiveDocument, "Subject","") 'Clear

    Dim prp As Object 'DocumentProperty
    Set prp = Nothing
    On Error Resume Next
    Set prp = doc.BuiltInDocumentProperties(strProperty)
    On Error GoTo 0
    If Not IsNull(varValue) Then
        On Error Resume Next
        prp.value = varValue
        On Error GoTo 0
        If Not prp.value = varValue Then
            Set prp = Nothing
        End If
    End If
    Set BDP = prp
End Function

Public Sub ClearVariables(doc As Word.Document)
    Dim i As Integer
    Dim v As Variable
    For i = doc.Variables.Count To 1 Step -1
        Set v = doc.Variables(i)
        v.Delete
    Next
End Sub

Public Function DV(doc As Word.Document, strProperty As String, Optional varValue As Variant = Null) As Variant
' Document Variable
' Empty string clears variable
' ? DV(ActiveDocument, "AVariable").Value 'Get value
' ? DV(ActiveDocument, "AVariable","aNewValue") 'Set value
' ? DV(ActiveDocument, "AVariable","") 'Clear variable
    Dim v As Variable
    For Each v In doc.Variables
        If v.Name = strProperty Then
            Exit For
        End If
    Next
    If Not v Is Nothing Then
        If Not v.Name = strProperty Then Set v = Nothing
    End If
    
    If Not IsNull(varValue) Then
        If varValue = "" Then
            If Not v Is Nothing Then
                v.Delete
                Set v = Nothing
                DV = ""
            Else
                DV = ""
            End If
        Else
            If v Is Nothing Then
                Set v = doc.Variables.Add(strProperty, varValue)
            Else
                v.value = varValue
            End If
            Set DV = v
        End If
    Else
        If v Is Nothing Then
            DV = ""
        Else
            DV = v.value
        End If
    End If
End Function

Public Sub CheckOut(docUrl As String, Optional OpenAgain As Boolean = False)
    Dim site As String
    Dim user As String
    site = GetSite(docUrl)
    
    ' docUrl = "http://crisnet/project/90010/Project/00_Sales/Test.docx"

    Dim urlRef As String
    urlRef = site & "/_vti_bin/Lists.asmx"
    
    Dim WebRequest As New XMLHTTP60, strRequest As String
    WebRequest.Open "POST", urlRef, False
    WebRequest.setRequestHeader "Content-Type", "text/xml; charset=utf-8"
    WebRequest.setRequestHeader "Content-Length", "length"
    WebRequest.setRequestHeader "SOAPAction", "http://schemas.microsoft.com/sharepoint/soap/CheckOutFile"
    
    strRequest = _
    "<?xml version='1.0' encoding='utf-8'?>" & _
    "<soap:Envelope xmlns:soap='http://schemas.xmlsoap.org/soap/envelope/' xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance' xmlns:xsd='http://www.w3.org/2001/XMLSchema'>" & _
    "  <soap:Body>" & _
    "    <CheckOutFile xmlns='http://schemas.microsoft.com/sharepoint/soap/'>" & _
    "      <pageUrl>" & docUrl & "</pageUrl>" & _
    "      <checkoutToLocal>true</checkoutToLocal>" & _
    "      <lastmodified/>" & _
    "    </CheckOutFile>" & _
    "  </soap:Body>" & _
    "</soap:Envelope>"

    WebRequest.send strRequest

    Dim docResponse As New DOMDocument60
    Set docResponse = WebRequest.responseXML
    Debug.Print docResponse.text
    
    If OpenAgain Then
        Application.Documents.Open docUrl, , , True
    End If
End Sub

Public Function CombinePaths(strFirst As String, strLast As String, Optional defaultDivider As String = "\") As String
    Dim divider As String
    If InStr(strFirst, "/") > 0 Then
        divider = "/"
        strLast = Replace(strLast, "\", "/")
    Else
        divider = "\"
        strLast = Replace(strLast, "/", "\")
    End If
    If divider = "" Then
        If InStr(strLast, "/") > 0 Then
            divider = "/"
        Else
            divider = "\"
        End If
    End If
    If divider = "" Then divider = defaultDivider
    If Right(strFirst, 1) = divider Then
        strFirst = Mid(strFirst, 1, Len(strFirst) - 1)
    End If
    If Left(strLast, 1) = divider Then
        strLast = Mid(strLast, 2)
    End If
    CombinePaths = strFirst & divider & strLast
    
End Function

Public Sub AfterSave()
    Dim doc As Document
    If ConvertedFullName > "" Then
        Set doc = ActiveDocument
        'GetManager.Init(doc).AddDoc doc, dsDocument
        If doc.CanCheckin Then
            On Error Resume Next
            doc.CheckInWithVersion True, "Converted to BGdoc document format", True, WdCheckInVersionType.wdCheckInMinorVersion
            'doc.CheckIn True, "Converted to BGdoc document format", False 'Checkin as Major
            On Error GoTo 0
'            On Error Resume Next
'            If Documents.CanCheckOut(ConvertedFullName) Then
'                Documents.CheckOut (ConvertedFullName)
'            End If
'            On Error GoTo 0
            ConvertedFullName = ""
        End If
    Else
'        Stop
'        GetManager.Init
  End If
End Sub

Public Sub AfterAutoClose()
Stop
    Set Manager = GetManager.Init
End Sub


Public Function DeleteOldFiles(strPathToFiles As String, intDays As Integer)
    Dim FSO As New Scripting.FileSystemObject
    Dim file As Scripting.file
     
    If FSO.FolderExists(strPathToFiles) Then 'Check that the folder exists
        For Each file In FSO.GetFolder(strPathToFiles).Files
            If DateDiff("d", file.DateLastModified, Now) > intDays Then
                On Error Resume Next
                file.Delete
                On Error GoTo 0
            End If
        Next
    End If
End Function

Public Function FolderExists(strFolderPath As String) As Boolean
    On Error Resume Next
    FolderExists = (GetAttr(strFolderPath) And vbDirectory) = vbDirectory
    On Error GoTo 0
End Function

Public Function UserTemp() As String
    If CachedUserTemp = "" Then
        Dim strTemp As String
        strTemp = ""
        On Error Resume Next
        strTemp = Environ("LocalAppData") & "\Temp"
        On Error GoTo 0
        If strTemp > "" Then
            On Error Resume Next
            MkDir strTemp
            On Error GoTo 0
            If Not FolderExists(strTemp) Then
                On Error Resume Next
                strTemp = Environ("Temp")
                On Error GoTo 0
            End If
        Else
            On Error Resume Next
            strTemp = Environ("Temp")
            On Error GoTo 0
        End If
        CachedUserTemp = strTemp
    End If
    UserTemp = CachedUserTemp
    
End Function

Public Sub SetStyle(styNameOrNo As Variant, Optional DX As DOCXML = Nothing)
    Dim sty As Style
    Set sty = ActiveDocument.Styles(styNameOrNo)
    Dim WithUndo As Boolean
    If DX Is Nothing Then
        Set DX = New DOCXML
        DX.Init
        DX.Prolog sty.NameLocal
        DX.updated = DX.SetStyle(sty)
        DX.Epilog
        Set DX = Nothing
    Else
        DX.SetStyle sty
    End If

End Sub

Public Function GetTempFile(Optional sPrefix As String = "", Optional fileType As String = "tmp") As String
    Dim s As String * 8 'fixed length string with 8 characters
    Dim n As Integer
    Dim ch As Integer 'the character
    
    Randomize
    For n = 1 To Len(s) 'don't hardcode the length twice
        Do
            ch = Rnd() * 127 'This could be more efficient.
            '48 is '0', 57 is '9', 65 is 'A', 90 is 'Z', 97 is 'a', 122 is 'z'.
        Loop While ch < 48 Or ch > 57 And ch < 65 Or ch > 90 And ch < 97 Or ch > 122
        Mid(s, n, 1) = Chr(ch) 'bit more efficient than concatenation
    Next
    
    GetTempFile = UserTemp & "\" & sPrefix & s & "." & fileType
End Function

Public Sub LeaveContentControl()
    Dim rng As Range
    Dim rngPara As Range
    
    Set rng = Selection.Range.Duplicate
    Set rngPara = rng.Paragraphs(1).Range
    
    If rng.ContentControls.Count = 0 And rngPara.ContentControls.Count > 0 Then
        rngPara.Select
        rngPara.Collapse wdCollapseStart
        rngPara.Select
    End If
End Sub

'Function GetHeader(sURL As String) As String
'    ' ? GetHeader("https://extranet.crisplant.com/Project/90010/21/From_BG_to_PLYTest/Project Document 2017-04-30 00.24.04.docx")
'    Dim WebRequest As Object
'    Set WebRequest = CreateObject("MSXML2.XMLHTTP")
'
'    WebRequest.Open "HEAD", sURL, False
'    WebRequest.send
'    GetHeader = WebRequest.getAllResponseHeaders()
'
'End Function

'Public Function MakeWebRequest(method, url, post_data) As String
'    ' ? MakeWebRequest("HEAD", "https://extranet.crisplant.com/Project/90010/21/From_BG_to_PLYTest/Project Document 2017-04-30 00.24.04.docx", "")
'
'    ' make sure to include the Microsoft WinHTTP Services in the project
'    ' tools -> references -> Microsoft WinHTTP Services, version 5.1
'    ' http://www.808.dk/?code-simplewinhttprequest
'    ' http://msdn.microsoft.com/en-us/library/windows/desktop/aa384106(v=vs.85).aspx
'    ' http://www.neilstuff.com/winhttp/
'
'    ' create the request object
'    Dim req As New WinHttpRequest
'    'Set req = CreateObject("WinHttp.WinHttpRequest.5.1")
'
'    ' set timeouts
'    ' http://msdn.microsoft.com/en-us/library/windows/desktop/aa384061(v=vs.85).aspx
'    ' SetTimeouts(resolveTimeout, ConnectTimeout, SendTimeout, ReceiveTimeout)
'    req.setTimeouts 5000, 5000, 5000, 5000
'    'req.setTimeouts 50000, 50000, 50000, 50000
'
'    ' make the request, http verb (method), url, false to force syncronous
'    ' open(http method, absolute uri to request, async (true: async, false: sync)
'    req.Open method, url, False
'    req.SetAutoLogonPolicy 0
'
'    ' handle post content type
'    If method = "POST" Then
'        req.setRequestHeader "Content-type", "application/x-www-form-urlencoded"
'    End If
'
'
'    ' set WinHttpRequestOption enumerations
'    ' http://msdn.microsoft.com/en-us/library/windows/desktop/aa384108(v=vs.85).aspx
'
'    ' set user agent
'    ' req.Option(0) = "Echovoice VBA HTTP Bot v0.1"
'
'    ' set ssl ignore errors
'    '   13056: ignore errors
'    '   0: break on errors
'    req.Option(4) = 13056
'
'    ' set redirects
'    req.Option(6) = False
'
'    ' allow http to redirect to https
'    req.Option(12) = False
'
'    ' send request
'    ' send post data, should be blank for a get request
'    req.send post_data
'    Dim str As String
'    str = req.getAllResponseHeaders
'    Debug.Print str
'    ' read response and return
'    MakeWebRequest = req.getResponseHeader("Connection") 'req.ResponseText
'
'End Function

'Function GetDataFromURL(strURL, strMethod, strPostData)
'' ? GetDataFromURL("http://www.808.dk/", "GET", "")
'  Dim lngTimeout
'  Dim strUserAgentString
'  Dim intSslErrorIgnoreFlags
'  Dim blnEnableRedirects
'  Dim blnEnableHttpsToHttpRedirects
'  Dim strHostOverride
'  Dim strLogin
'  Dim strPassword
'  Dim strResponseText
'  Dim objWinHttp
'  lngTimeout = 5000
'  strUserAgentString = "http_requester/0.1"
'  intSslErrorIgnoreFlags = 13056 ' 13056: ignore all err, 0: accept no err
'  blnEnableRedirects = True 'True
'  blnEnableHttpsToHttpRedirects = True
'  strHostOverride = ""
'  strLogin = ""
'  strPassword = ""
'  Set objWinHttp = CreateObject("WinHttp.WinHttpRequest.5.1")
'  objWinHttp.setTimeouts lngTimeout, lngTimeout, lngTimeout, lngTimeout
'  objWinHttp.Open strMethod, strURL
'  If strMethod = "POST" Then
'    objWinHttp.setRequestHeader "Content-type", _
'      "application/x-www-form-urlencoded"
'  End If
'  If strHostOverride <> "" Then
'    objWinHttp.setRequestHeader "Host", strHostOverride
'  End If
'  objWinHttp.Option(0) = strUserAgentString
'  objWinHttp.Option(4) = intSslErrorIgnoreFlags
'  objWinHttp.Option(6) = blnEnableRedirects
'  objWinHttp.Option(12) = blnEnableHttpsToHttpRedirects
'  If (strLogin <> "") And (strPassword <> "") Then
'    objWinHttp.SetCredentials strLogin, strPassword, 0
'  End If
'  On Error Resume Next
'  objWinHttp.send (strPostData)
'  If Err.Number = 0 Then
'    If objWinHttp.Status = "200" Then
'      GetDataFromURL = objWinHttp.responseText
'    Else
'      GetDataFromURL = "HTTP " & objWinHttp.Status & " " & _
'        objWinHttp.StatusText
'    End If
'  Else
'    GetDataFromURL = "Error " & Err.Number & " " & Err.source & " " & _
'      Err.Description
'  End If
'  On Error GoTo 0
'  Set objWinHttp = Nothing
'End Function

'Function GetStatusFromURL(strURL)
'' ? GetDataFromURL("http://www.808.dk/", "GET", "")
'  Dim lngTimeout
'  Dim strUserAgentString
'  Dim intSslErrorIgnoreFlags
'  Dim blnEnableRedirects
'  Dim blnEnableHttpsToHttpRedirects
'  Dim strHostOverride
'  Dim strLogin
'  Dim strPassword
'  Dim strResponseText
'  Dim objWinHttp
'  lngTimeout = 5000
'  strUserAgentString = "http_requester/0.1"
'  intSslErrorIgnoreFlags = 13056 ' 13056: ignore all err, 0: accept no err
'  blnEnableRedirects = True 'True
'  blnEnableHttpsToHttpRedirects = True
'  strHostOverride = ""
'  strLogin = ""
'  strPassword = ""
'  Set objWinHttp = CreateObject("WinHttp.WinHttpRequest.5.1")
'  objWinHttp.SetAutoLogonPolicy 0
'
'  objWinHttp.setTimeouts lngTimeout, lngTimeout, lngTimeout, lngTimeout
'  objWinHttp.Open "HEAD", strURL
'  If strHostOverride <> "" Then
'    objWinHttp.setRequestHeader "Host", strHostOverride
'  End If
'  objWinHttp.Option(0) = strUserAgentString
'  objWinHttp.Option(4) = intSslErrorIgnoreFlags
'  objWinHttp.Option(6) = blnEnableRedirects
'  objWinHttp.Option(12) = blnEnableHttpsToHttpRedirects
'  On Error Resume Next
'  objWinHttp.send ""
'  If Err.Number = 0 Then
'    GetStatusFromURL = Trim(objWinHttp.Status)
'  Else
'    GetStatusFromURL = "499"
'  End If
'  On Error GoTo 0
'  Set objWinHttp = Nothing
'End Function

Public Function MoveSharePointFile(docUrl As String, newDocUrl As String, Optional timeout As Single = 30) As String
    ' ? MoveSharePointFile("https://extranet.crisplant.com/Project/90010/21/Shared Documents/PLY/G1_UK1_0.doc", "https://extranet.crisplant.com/Project/90010/21/Shared Documents/PLY/G1_UK1_0.docx")
    On Error GoTo Catch
    
    Dim user As String
    Dim site As String
    Dim result As String
    
    Dim StartTime As Single, TimeElapsed As Single
    Dim StartDate As Date
    StartDate = Date
    StartTime = Timer
    
    site = GetSite(docUrl, timeout)
    If Not site Like "http*" Then
        MoveSharePointFile = site
        Exit Function
    End If
    user = GetSPUser(docUrl, timeout)

    Dim urlRef As String
    urlRef = CombinePaths(site, "/_vti_bin/SharePointPortalManagement.WebServices.asmx")
    
    Dim WebRequest As New XMLHTTP60, strRequest As String
    WebRequest.Open "POST", urlRef, True
    WebRequest.setRequestHeader "Content-Type", "text/xml; charset=utf-8"
    WebRequest.setRequestHeader "Content-Length", "length"
    WebRequest.setRequestHeader "SOAPAction", "http://beumergroup.com/UpgradeDocument"
    strRequest = _
    "<?xml version='1.0' encoding='utf-8'?> " & _
    "<soap:Envelope xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance' xmlns:xsd='http://www.w3.org/2001/XMLSchema' xmlns:soap='http://www.w3.org/2003/05/soap-envelope'> " & _
    "  <soap:Body> " & _
    "    <UpgradeDocument xmlns='http://beumergroup.com/' >" & _
    "       <url>" & docUrl & "</url>" & _
    "       <newUrl>" & newDocUrl & "</newUrl>" & _
    "       <user>" & user & "</user>" & _
    "    </UpgradeDocument>" & _
    "  </soap:Body> " & _
    "</soap:Envelope>"

    WebRequest.send strRequest
        
    Do While WebRequest.readyState <> 4
        DoEvents
        TimeElapsed = 86400 * (Date - StartDate) + Timer - StartTime
        'Debug.Print "Waiting.." & TimeElapsed
        If TimeElapsed > timeout Then
            result = "TimedOut:" & CStr(timeout)
            GoTo Finally
        End If
    Loop
    
    If WebRequest.Status >= "200" And WebRequest.Status < "300" Then
        result = WebRequest.responseXML.text
    Else
        result = "NotFound:" & WebRequest.Status
    End If
    
Finally:
    On Error GoTo 0
    MoveSharePointFile = result
    Exit Function
    
Catch:
ErrorExit:
    result = "Error:" & Err.Description
    Resume Finally
End Function

Public Function CanMoveSharePointFile(docUrl As String, Optional timeout As Single = 30) As String
    ' ? CanMoveSharePointFile("https://extranet.crisplant.com/Project/90010/21/Shared Documents/PLY/G1_UK1_0.doc")
    On Error GoTo Catch

    Dim site As String
    Dim user As String
    Dim result As String
    
    Dim StartTime As Single, TimeElapsed As Single
    Dim StartDate As Date
    StartDate = Date
    StartTime = Timer
    
    site = GetSite(docUrl, timeout)
    If Not site Like "http*" Then
        CanMoveSharePointFile = site
        Exit Function
    End If
    user = GetSPUser(docUrl, timeout)

    Dim urlRef As String
    urlRef = CombinePaths(site, "/_vti_bin/SharePointPortalManagement.WebServices.asmx")
    
    Dim WebRequest As New XMLHTTP60
    Dim strRequest As String

    WebRequest.Open "POST", urlRef, True
    WebRequest.setRequestHeader "Content-Type", "text/xml; charset=utf-8"
    WebRequest.setRequestHeader "Content-Length", "length"
    WebRequest.setRequestHeader "SOAPAction", "http://beumergroup.com/CanUpgradeDocument"
    strRequest = _
    "<?xml version='1.0' encoding='utf-8'?> " & _
    "<soap:Envelope xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance' xmlns:xsd='http://www.w3.org/2001/XMLSchema' xmlns:soap='http://www.w3.org/2003/05/soap-envelope'> " & _
    "  <soap:Body> " & _
    "    <CanUpgradeDocument xmlns='http://beumergroup.com/' >" & _
    "       <url>" & docUrl & "</url>" & _
    "       <user>" & user & "</user>" & _
    "    </CanUpgradeDocument>" & _
    "  </soap:Body> " & _
    "</soap:Envelope>"

    WebRequest.send strRequest
    
    Do While WebRequest.readyState <> 4
        DoEvents
        TimeElapsed = 86400 * (Date - StartDate) + Timer - StartTime
        'Debug.Print "Waiting.." & TimeElapsed
        If TimeElapsed > timeout Then
            result = "TimedOut:" & CStr(timeout)
            GoTo Finally
        End If
    Loop
    
    If WebRequest.Status >= "200" And WebRequest.Status < "300" Then
        result = WebRequest.responseXML.text
    Else
        result = "NotFound:" & WebRequest.Status
    End If
    
Finally:
    On Error GoTo 0
    CanMoveSharePointFile = result
    Exit Function
    
Catch:
ErrorExit:
    result = "Error:" & Err.Description
    Resume Finally
End Function

Public Function ConvertHttpDate(strDate As String) As Date
    Dim MyMonth As Integer
   
    Select Case UCase(Mid(strDate, 4, 3))
        Case "JAN": MyMonth = 1
        Case "FEB": MyMonth = 2
        Case "MAR": MyMonth = 3
        Case "APR": MyMonth = 4
        Case "MAY": MyMonth = 5
        Case "JUN": MyMonth = 6
        Case "JUL": MyMonth = 7
        Case "AUG": MyMonth = 8
        Case "SEP": MyMonth = 9
        Case "OCT": MyMonth = 10
        Case "NOV": MyMonth = 11
        Case "DEC": MyMonth = 12
    End Select
   
    ConvertHttpDate = DateValue(Right(strDate, 4) & "/" & MyMonth & "/" & Left(strDate, 2))
End Function


'Public Function GetSiteOld(docPath As String, Optional http As String = "http:") As String
'    Dim lastBS As Integer
'    Dim aspx As String
'    Do While True
'        aspx = ""
'        If InStrRev(docPath, "/") > 0 Then
'            docPath = Left(docPath, InStrRev(docPath, "/") - 1)
'            On Error Resume Next
'            aspx = Dir(docPath & "/*.aspx")
'            On Error GoTo 0
'            If aspx > "" Then
'                GetSite = http & docPath
'                Exit Do
'            End If
'        Else
'            GetSite = ""
'            Exit Do
'        End If
'    Loop
'End Function

Public Function GetUrlProtocol(url As String, protocol As String, Optional timeout As Single = 30) As String
    On Error GoTo Catch

    Dim WebRequest As New XMLHTTP60
    Dim result As String

    Dim StartTime As Single, TimeElapsed As Single
    Dim StartDate As Date
    StartDate = Date
    StartTime = Timer
    
    WebRequest.Open IIf(protocol = "STATUS", "HEAD", protocol), url, True
    WebRequest.send
    
    Do While WebRequest.readyState <> 4
        DoEvents
        TimeElapsed = 86400 * (Date - StartDate) + Timer - StartTime
        'Debug.Print "Waiting.." & TimeElapsed
        If TimeElapsed > timeout Then
            result = "TimedOut:" & CStr(timeout)
            GoTo Finally
        End If
    Loop
    
    If WebRequest.Status >= "200" And WebRequest.Status < "300" Then
        If protocol = "HEAD" Then
            result = "Found:" & WebRequest.getAllResponseHeaders
        ElseIf protocol = "STATUS" Then
            result = WebRequest.Status
        Else
            result = "Found:" & WebRequest.responseText
        End If
    Else
        If protocol = "HEAD" Then
            result = "NotFound:" & WebRequest.Status
        ElseIf protocol = "STATUS" Then
            result = WebRequest.Status
        Else
            result = "NotFound:" & WebRequest.Status
        End If
    End If
    
'    Debug.Print url
'    Debug.Print "--------------------------------------------------------------------------------"
'    Debug.Print WebRequest.getAllResponseHeaders

Finally:
    On Error GoTo 0
    GetUrlProtocol = result
    Exit Function
    
Catch:
ErrorExit:
    result = "Error:" & Err.Description
    Resume Finally
End Function

Public Function GetURLHead(url As String, Optional timeout As Single = 30) As String
'Print GetURLHead("https://extranet.crisplant.com/Project/90010/21/Shared Documents/Test.docx")
'Print GetURLHead("https://extranet.crisplant.com/Project/90010/21/Shared Documents")
'Print GetURLHead("https://extranet.crisplant.com/Project/90010/21")
'Print GetURLHead("https://extranet.crisplant.com/Project/90010/21/_vti_bin/Discovery.asmx")
    GetURLHead = GetUrlProtocol(url, "HEAD", timeout)
End Function

Public Function GetURLStatus(url As String, Optional timeout As Single = 30) As String
'Print GetURLStatus("https://extranet.crisplant.com/Project/90010/21/Shared Documents/Test.docx")
'Print GetURLStatus("https://extranet.crisplant.com/Project/90010/21/Shared Documents")
'Print GetURLStatus("https://extranet.crisplant.com/Project/90010/21")
'Print GetURLStatus("https://extranet.crisplant.com/Project/90010/21/_vti_bin/Discovery.asmx")
' Print GetURLStatus("https://extranet.crisplant.com/Project/90010/21/Shared Documents/Test.docxx")
    GetURLStatus = GetUrlProtocol(url, "STATUS", timeout)
End Function

Public Function GetURLPage(url As String, Optional timeout As Single = 30) As String
'Print GetURLPage("https://extranet.crisplant.com/Project/90010/21/Shared Documents/Test.docx")
'Print GetURLPage("https://extranet.crisplant.com/Project/90010/21/Shared Documents")
'Print GetURLPage("https://extranet.crisplant.com/Project/90010/21")
'Print GetURLPage("https://extranet.crisplant.com/Project/90010/21/_vti_bin/Discovery.asmx")

    GetURLPage = GetUrlProtocol(url, "GET", timeout)
End Function

Public Function GetURLDate(url As String, Optional timeout As Single = 30) As Date
    Dim head As String
    Dim NetDate As String
    Dim NetTime As Date
    Dim LocDate As Date
    
    head = GetURLHead(url, timeout)
    
    If head Like "Found:*" Then
        Dim aResult() As String
        aResult = Split(Mid(head, 7), vbCrLf)
        Dim i As Integer
        Dim res As String
        For i = 0 To UBound(aResult)
            res = aResult(i)
            If res Like "Last-Modified:*" Then
                res = Mid(res, 21, Len(res) - 24)
            
                NetDate = Left(res, Len(res) - 9) '30 Sep 2013
                NetTime = Right(res, 8) '18:33:23
                LocDate = ConvertHttpDate(NetDate)
                GetURLDate = LocalTime(LocDate + NetTime)
                Exit Function
            End If
        Next
        GetURLDate = #12:00:00 PM#
    Else
        GetURLDate = #12:00:00 PM#
    End If
    
End Function

'Public Function GetSiteOld(docUrl As String) As String
'    Dim head As String
'    Do While True
'        head = GetURLHead(docUrl) '  & "/_vti_bin/Discovery.asmx"
'        If head Like "Found:*" Then
'            Dim aResult() As String
'            aResult = Split(Mid(head, 7), vbCrLf)
'            Dim i As Integer
'            Dim res As String
'            For i = 0 To UBound(aResult)
'                res = aResult(i)
'                If res Like "Set-Cookie:*/_vti_bin/Discovery.asmx*" Then
'                    GetSiteOld = URLDecode(Mid(res, 13, InStr(res, "%2FDiscovery") - 13))
'                    Exit Do
'                End If
'            Next
'            GetSiteOld = "NotFound:CookieMissing"
'            Exit Do
'        ElseIf head Like "NotFound:440" Then
'            GetSiteOld = head
'            Exit Do
'        End If
'        If InStrRev(docUrl, "/") > 0 Then
'            docUrl = Left(docUrl, InStrRev(docUrl, "/") - 1)
'        Else
'            GetSiteOld = "NotFound:WrongPath"
'            Exit Do
'        End If
'    Loop
'End Function

Function GetSPUser(docUrl As String, Optional timeout As Single = 30) As String
' FieldInternalName="Name".*?-->\s*([^&]*)

    Dim site As String
    Dim aspx As String
    Dim re As Object
    Dim matches As Object
    
    site = GetSite(docUrl)
    If Not site Like "http*" Then
        GetSPUser = site
        Exit Function
    End If
    aspx = GetURLPage(site & "/_layouts/userdisp.aspx?Force=True&" & CStr(Now), timeout)
    
    Set re = CreateObject("vbscript.regexp")
    With re
        .IgnoreCase = True
        .Global = True
        .Pattern = "FieldInternalName=""Name""[^>]*>\s*([^&]*)"
        If .Test(aspx) Then
           Set matches = .Execute(aspx)
           GetSPUser = matches(0).SubMatches(0)
        Else
           GetSPUser = "NoUser:" & aspx
        End If
    End With
End Function

'Public Function GetSite(docUrl As String) As String
'    Dim aspx As String
'    Do While True
'        Debug.Print docUrl
'        aspx = GetURLPage(docUrl & "/_vti_bin/Webs.asmx")
'        If aspx Like "Found:*" Then
'            Dim start As Long
'            start = InStr(aspx, "WebUrlFromPageUrl")
'            If start > 0 Then
'                GetSite = Mid(aspx, start, 2000)
'                Exit Do
'            Else
'                'GetSite = "NotFound:WebUrlFromPageUrlMissing"
'                'Exit Do
'            End If
'        ElseIf aspx Like "NotFound:440" Then
'            GetSite = aspx
'            Exit Do
'        End If
'        If InStrRev(docUrl, "/") > 0 Then
'            docUrl = Left(docUrl, InStrRev(docUrl, "/") - 1)
'        Else
'            GetSite = "NotFound:WrongPath"
'            Exit Do
'        End If
'    Loop
'End Function
' ? GetUrlProtocol("https://extranet.crisplant.com/Project/90010/21" & "/_vti_bin/Webs.asmx", "HEAD")
'https://extranet.crisplant.com/Project/90010/21/Shared Documents

'Public Function GetSiteNoTimeout(docUrl As String) As String
'    ' Rewrite with Timeout!!!
'    Dim site As String
'
'    Dim urlRef As String
'    urlRef = docUrl & "/_vti_bin/Webs.asmx"
'
'    Dim WebRequest As New XMLHTTP60
'    Dim strRequest As String
'    WebRequest.Open "POST", urlRef, False
'    WebRequest.setRequestHeader "Content-Type", "text/xml; charset=utf-8"
'    WebRequest.setRequestHeader "Content-Length", "length"
'    WebRequest.setRequestHeader "SOAPAction", "http://schemas.microsoft.com/sharepoint/soap/WebUrlFromPageUrl"
'
'    strRequest = _
'    "<?xml version='1.0' encoding='utf-8'?>" & _
'    "<soap:Envelope xmlns:soap='http://schemas.xmlsoap.org/soap/envelope/' xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance' xmlns:xsd='http://www.w3.org/2001/XMLSchema'>" & _
'    "  <soap:Body>" & _
'    "    <WebUrlFromPageUrl xmlns='http://schemas.microsoft.com/sharepoint/soap/'>" & _
'    "      <pageUrl>" & docUrl & "</pageUrl>" & _
'    "    </WebUrlFromPageUrl>" & _
'    "  </soap:Body>" & _
'    "</soap:Envelope>"
'
'    WebRequest.send strRequest
'
'    Dim docResponse As New DOMDocument60
'    Set docResponse = WebRequest.responseXML
'    GetSiteNoTimeout = docResponse.text
'End Function

Public Function GetSite(docUrl As String, Optional timeout As Single = 30) As String
    ' ? GetSite("https://extranet.crisplant.com/Project/90010/21/Shared Documents/Test.docx")

    On Error GoTo Catch

    Dim WebRequest As New XMLHTTP60
    Dim result As String

    Dim StartTime As Single, TimeElapsed As Single
    Dim StartDate As Date
    StartDate = Date
    StartTime = Timer
    
    Dim urlRef As String
    urlRef = docUrl & "/_vti_bin/Webs.asmx"
    
    Dim strRequest As String
    WebRequest.Open "POST", urlRef, True
    WebRequest.setRequestHeader "Content-Type", "text/xml; charset=utf-8"
    WebRequest.setRequestHeader "Content-Length", "length"
    WebRequest.setRequestHeader "SOAPAction", "http://schemas.microsoft.com/sharepoint/soap/WebUrlFromPageUrl"
    
    strRequest = _
    "<?xml version='1.0' encoding='utf-8'?>" & _
    "<soap:Envelope xmlns:soap='http://schemas.xmlsoap.org/soap/envelope/' xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance' xmlns:xsd='http://www.w3.org/2001/XMLSchema'>" & _
    "  <soap:Body>" & _
    "    <WebUrlFromPageUrl xmlns='http://schemas.microsoft.com/sharepoint/soap/'>" & _
    "      <pageUrl>" & docUrl & "</pageUrl>" & _
    "    </WebUrlFromPageUrl>" & _
    "  </soap:Body>" & _
    "</soap:Envelope>"
    
    WebRequest.send strRequest
    
    Do While WebRequest.readyState <> 4
        DoEvents
        TimeElapsed = 86400 * (Date - StartDate) + Timer - StartTime
        'Debug.Print "Waiting.." & TimeElapsed
        If TimeElapsed > timeout Then
            result = "TimedOut:" & CStr(timeout)
            GoTo Finally
        End If
    Loop
    
    If WebRequest.Status >= "200" And WebRequest.Status < "300" Then
        result = WebRequest.responseXML.text
        If result = "" Then
            result = GetURLHead(docUrl, timeout)
        End If
    Else
        result = "NotFound:" & WebRequest.Status
    End If
    
'    Debug.Print url
'    Debug.Print "--------------------------------------------------------------------------------"
'    Debug.Print WebRequest.getAllResponseHeaders

Finally:
    On Error GoTo 0
    GetSite = result
    Exit Function
    
Catch:
ErrorExit:
    result = "Error:" & Err.Description
    Resume Finally
End Function

Public Function IsValidFileName(fileName As String) As Boolean
' /^(?!\.)(?!com[0-9]$)(?!con$)(?!lpt[0-9]$)(?!nul$)(?!prn$)[^\|\*\?\\:<>/$"]*[^\.\|\*\?\\:<>/$"]+$/
    Dim RegExpObj As Object
    Dim matches As Object
    Dim NewMajor As String
    Set RegExpObj = CreateObject("vbscript.regexp")
    With RegExpObj
        .Pattern = "[\\\/:\*\?""<>\|]"
        If .Test(fileName) Then
            IsValidFileName = False
        Else
            IsValidFileName = True
        End If
    End With
End Function



Attribute VB_Name = "ext_ChipPearson"
Option Explicit
Option Compare Text

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' modQSortInPlace
' By Chip Pearson, www.cpearson.com, chip@cpearson.com
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' This module contains the QSortInPlace procedure and private supporting procedures.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Public Function QSortInPlace( _
    ByRef InputArray As Variant, _
    Optional ByVal LB As Long = -1&, _
    Optional ByVal UB As Long = -1&, _
    Optional ByVal Descending As Boolean = False, _
    Optional ByVal CompareMode As VbCompareMethod = vbTextCompare, _
    Optional ByVal NoAlerts As Boolean = False) As Boolean
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' QSortInPlace
'
' This function sorts the array InputArray in place -- this is, the original array in the
' calling procedure is sorted. It will work with either string data or numeric data.
' It need not sort the entire array. You can sort only part of the array by setting the LB and
' UB parameters to the first (LB) and last (UB) element indexes that you want to sort.
' LB and UB are optional parameters. If omitted LB is set to the LBound of InputArray, and if
' omitted UB is set to the UBound of the InputArray. If you want to sort the entire array,
' omit the LB and UB parameters, or set both to -1, or set LB = LBound(InputArray) and set
' UB to UBound(InputArray).
'
' By default, the sort method is case INSENSTIVE (case doens't matter: "A", "b", "C", "d").
' To make it case SENSITIVE (case matters: "A" "C" "b" "d"), set the CompareMode argument
' to vbBinaryCompare (=0). If Compare mode is omitted or is any value other than vbBinaryCompare,
' it is assumed to be vbTextCompare and the sorting is done case INSENSITIVE.
'
' The function returns TRUE if the array was successfully sorted or FALSE if an error
' occurred. If an error occurs (e.g., LB > UB), a message box indicating the error is
' displayed. To suppress message boxes, set the NoAlerts parameter to TRUE.
'
''''''''''''''''''''''''''''''''''''''
' MODIFYING THIS CODE:
''''''''''''''''''''''''''''''''''''''
' If you modify this code and you call "Exit Procedure", you MUST decrment the RecursionLevel
' variable. E.g.,
'       If SomethingThatCausesAnExit Then
'           RecursionLevel = RecursionLevel - 1
'           Exit Function
'       End If
'''''''''''''''''''''''''''''''''''''''
'
' Note: If you coerce InputArray to a ByVal argument, QSortInPlace will not be
' able to reference the InputArray in the calling procedure and the array will
' not be sorted.
'
' This function uses the following procedures. These are declared as Private procedures
' at the end of this module:
'       IsArrayAllocated
'       IsSimpleDataType
'       IsSimpleNumericType
'       QSortCompare
'       NumberOfArrayDimensions
'       ReverseArrayInPlace
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Dim temp As Variant
Dim Buffer As Variant
Dim CurLow As Long
Dim CurHigh As Long
Dim CurMidpoint As Long
Dim Ndx As Long
Dim pCompareMode As VbCompareMethod

'''''''''''''''''''''''''
' Set the default result.
'''''''''''''''''''''''''
QSortInPlace = False

''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' This variable is used to determine the level
' of recursion  (the function calling itself).
' RecursionLevel is incremented when this procedure
' is called, either initially by a calling procedure
' or recursively by itself. The variable is decremented
' when the procedure exits. We do the input parameter
' validation only when RecursionLevel is 1 (when
' the function is called by another function, not
' when it is called recursively).
''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Static RecursionLevel As Long


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Keep track of the recursion level -- that is, how many
' times the procedure has called itself.
' Carry out the validation routines only when this
' procedure is first called. Don't run the
' validations on a recursive call to the
' procedure.
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
RecursionLevel = RecursionLevel + 1

If RecursionLevel = 1 Then
    ''''''''''''''''''''''''''''''''''
    ' Ensure InputArray is an array.
    ''''''''''''''''''''''''''''''''''
    If IsArray(InputArray) = False Then
        If NoAlerts = False Then
            MsgBox "The InputArray parameter is not an array."
        End If
        '''''''''''''''''''''''''''''''''''''''''''''''''''''''
        ' InputArray is not an array. Exit with a False result.
        '''''''''''''''''''''''''''''''''''''''''''''''''''''''
        RecursionLevel = RecursionLevel - 1
        Exit Function
    End If
    
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' Test LB and UB. If < 0 then set to LBound and UBound
    ' of the InputArray.
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    If LB < 0 Then
        LB = LBound(InputArray)
    End If
    If UB < 0 Then
        UB = UBound(InputArray)
    End If
    
    Select Case NumberOfArrayDimensions(InputArray)
        Case 0
            ''''''''''''''''''''''''''''''''''''''''''
            ' Zero dimensions indicates an unallocated
            ' dynamic array.
            ''''''''''''''''''''''''''''''''''''''''''
            If NoAlerts = False Then
                MsgBox "The InputArray is an empty, unallocated array."
            End If
            RecursionLevel = RecursionLevel - 1
            Exit Function
        Case 1
            ''''''''''''''''''''''''''''''''''''''''''
            ' We sort ONLY single dimensional arrays.
            ''''''''''''''''''''''''''''''''''''''''''
        Case Else
            ''''''''''''''''''''''''''''''''''''''''''
            ' We sort ONLY single dimensional arrays.
            ''''''''''''''''''''''''''''''''''''''''''
            If NoAlerts = False Then
                MsgBox "The InputArray is multi-dimensional." & _
                      "QSortInPlace works only on single-dimensional arrays."
            End If
            RecursionLevel = RecursionLevel - 1
            Exit Function
    End Select
    '''''''''''''''''''''''''''''''''''''''''''''''''''
    ' Ensure that InputArray is an array of simple data
    ' types, not other arrays or objects. This tests
    ' the data type of only the first element of
    ' InputArray. If InputArray is an array of Variants,
    ' subsequent data types may not be simple data types
    ' (e.g., they may be objects or other arrays), and
    ' this may cause QSortInPlace to fail on the StrComp
    ' operation.
    '''''''''''''''''''''''''''''''''''''''''''''''''''
    If IsSimpleDataType(InputArray(LBound(InputArray))) = False Then
        If NoAlerts = False Then
            MsgBox "InputArray is not an array of simple data types."
            RecursionLevel = RecursionLevel - 1
            Exit Function
        End If
    End If
    ''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' ensure that the LB parameter is valid.
    ''''''''''''''''''''''''''''''''''''''''''''''''''''
    Select Case LB
        Case Is < LBound(InputArray)
            If NoAlerts = False Then
                MsgBox "The LB lower bound parameter is less than the LBound of the InputArray"
            End If
            RecursionLevel = RecursionLevel - 1
            Exit Function
        Case Is > UBound(InputArray)
            If NoAlerts = False Then
                MsgBox "The LB lower bound parameter is greater than the UBound of the InputArray"
            End If
            RecursionLevel = RecursionLevel - 1
            Exit Function
        Case Is > UB
            If NoAlerts = False Then
                MsgBox "The LB lower bound parameter is greater than the UB upper bound parameter."
            End If
            RecursionLevel = RecursionLevel - 1
            Exit Function
    End Select

    ''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' ensure the UB parameter is valid.
    ''''''''''''''''''''''''''''''''''''''''''''''''''''
    Select Case UB
        Case Is > UBound(InputArray)
            If NoAlerts = False Then
                MsgBox "The UB upper bound parameter is greater than the upper bound of the InputArray."
            End If
            RecursionLevel = RecursionLevel - 1
            Exit Function
        Case Is < LBound(InputArray)
            If NoAlerts = False Then
                MsgBox "The UB upper bound parameter is less than the lower bound of the InputArray."
            End If
            RecursionLevel = RecursionLevel - 1
            Exit Function
        Case Is < LB
            If NoAlerts = False Then
                MsgBox "the UB upper bound parameter is less than the LB lower bound parameter."
            End If
            RecursionLevel = RecursionLevel - 1
            Exit Function
    End Select

    ''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' if UB = LB, we have nothing to sort, so get out.
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''
    If UB = LB Then
        QSortInPlace = True
        RecursionLevel = RecursionLevel - 1
        Exit Function
    End If

End If ' RecursionLevel = 1

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Ensure that CompareMode is either vbBinaryCompare  or
' vbTextCompare. If it is neither, default to vbTextCompare.
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
If (CompareMode = vbBinaryCompare) Or (CompareMode = vbTextCompare) Then
    pCompareMode = CompareMode
Else
    pCompareMode = vbTextCompare
End If

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Begin the actual sorting process.
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
CurLow = LB
CurHigh = UB

If LB = 0 Then
    CurMidpoint = ((LB + UB) \ 2) + 1
Else
    CurMidpoint = (LB + UB) \ 2 ' note integer division (\) here
End If
temp = InputArray(CurMidpoint)

Do While (CurLow <= CurHigh)
    
    Do While QSortCompare(V1:=InputArray(CurLow), V2:=temp, CompareMode:=pCompareMode) < 0
        CurLow = CurLow + 1
        If CurLow = UB Then
            Exit Do
        End If
    Loop
    
    Do While QSortCompare(V1:=temp, V2:=InputArray(CurHigh), CompareMode:=pCompareMode) < 0
        CurHigh = CurHigh - 1
        If CurHigh = LB Then
           Exit Do
        End If
    Loop

    If (CurLow <= CurHigh) Then
        Buffer = InputArray(CurLow)
        InputArray(CurLow) = InputArray(CurHigh)
        InputArray(CurHigh) = Buffer
        CurLow = CurLow + 1
        CurHigh = CurHigh - 1
    End If
Loop

If LB < CurHigh Then
    QSortInPlace InputArray:=InputArray, LB:=LB, UB:=CurHigh, _
        Descending:=Descending, CompareMode:=pCompareMode, NoAlerts:=True
End If

If CurLow < UB Then
    QSortInPlace InputArray:=InputArray, LB:=CurLow, UB:=UB, _
        Descending:=Descending, CompareMode:=pCompareMode, NoAlerts:=True
End If

'''''''''''''''''''''''''''''''''''''
' If Descending is True, reverse the
' order of the array, but only if the
' recursion level is 1.
'''''''''''''''''''''''''''''''''''''
If Descending = True Then
    If RecursionLevel = 1 Then
        ReverseArrayInPlace2 InputArray, LB, UB
    End If
End If

RecursionLevel = RecursionLevel - 1
QSortInPlace = True
End Function

Public Function QSortCompare(V1 As Variant, V2 As Variant, _
    Optional CompareMode As VbCompareMethod = vbTextCompare) As Long
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' QSortCompare
' This function is used in QSortInPlace to compare two elements. If
' V1 AND V2 are both numeric data types (integer, long, single, double)
' they are converted to Doubles and compared. If V1 and V2 are BOTH strings
' that contain numeric data, they are converted to Doubles and compared.
' If either V1 or V2 is a string and does NOT contain numeric data, both
' V1 and V2 are converted to Strings and compared with StrComp.
'
' The result is -1 if V1 < V2,
'                0 if V1 = V2
'                1 if V1 > V2
' For text comparisons, case sensitivity is controlled by CompareMode.
' If this is vbBinaryCompare, the result is case SENSITIVE. If this
' is omitted or any other value, the result is case INSENSITIVE.
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Dim D1 As Double
Dim D2 As Double
Dim S1 As String
Dim S2 As String

Dim Compare As VbCompareMethod
''''''''''''''''''''''''''''''''''''''''''''''''
' Test CompareMode. Any value other than
' vbBinaryCompare will default to vbTextCompare.
''''''''''''''''''''''''''''''''''''''''''''''''
If CompareMode = vbBinaryCompare Or CompareMode = vbTextCompare Then
    Compare = CompareMode
Else
    Compare = vbTextCompare
End If
'''''''''''''''''''''''''''''''''''''''''''''''
' If either V1 or V2 is either an array or
' an Object, raise a error 13 - Type Mismatch.
'''''''''''''''''''''''''''''''''''''''''''''''
If IsArray(V1) = True Or IsArray(V2) = True Then
    Err.Raise 13
    Exit Function
End If
If IsObject(V1) = True Or IsObject(V2) = True Then
    Err.Raise 13
    Exit Function
End If

If IsSimpleNumericType(V1) = True Then
    If IsSimpleNumericType(V2) = True Then
        '''''''''''''''''''''''''''''''''''''
        ' If BOTH V1 and V2 are numeric data
        ' types, then convert to Doubles and
        ' do an arithmetic compare and
        ' return the result.
        '''''''''''''''''''''''''''''''''''''
        D1 = CDbl(V1)
        D2 = CDbl(V2)
        If D1 = D2 Then
            QSortCompare = 0
            Exit Function
        End If
        If D1 < D2 Then
            QSortCompare = -1
            Exit Function
        End If
        If D1 > D2 Then
            QSortCompare = 1
            Exit Function
        End If
    End If
End If
''''''''''''''''''''''''''''''''''''''''''''
' Either V1 or V2 was not numeric data type.
' Test whether BOTH V1 AND V2 are numeric
' strings. If BOTH are numeric, convert to
' Doubles and do a arithmetic comparison.
''''''''''''''''''''''''''''''''''''''''''''
If IsNumeric(V1) = True And IsNumeric(V2) = True Then
    D1 = CDbl(V1)
    D2 = CDbl(V2)
    If D1 = D2 Then
        QSortCompare = 0
        Exit Function
    End If
    If D1 < D2 Then
        QSortCompare = -1
        Exit Function
    End If
    If D1 > D2 Then
        QSortCompare = 1
        Exit Function
    End If
End If
''''''''''''''''''''''''''''''''''''''''''''''
' Either or both V1 and V2 was not numeric
' string. In this case, convert to Strings
' and use StrComp to compare.
''''''''''''''''''''''''''''''''''''''''''''''
S1 = CStr(V1)
S2 = CStr(V2)
QSortCompare = StrComp(S1, S2, Compare)

End Function



Public Function NumberOfArrayDimensions(Arr As Variant) As Integer
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' NumberOfArrayDimensions
' This function returns the number of dimensions of an array. An unallocated dynamic array
' has 0 dimensions. This condition can also be tested with IsArrayEmpty.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Dim Ndx As Integer
Dim res As Integer
On Error Resume Next
' Loop, increasing the dimension index Ndx, until an error occurs.
' An error will occur when Ndx exceeds the number of dimension
' in the array. Return Ndx - 1.
Do
    Ndx = Ndx + 1
    res = UBound(Arr, Ndx)
Loop Until Err.Number <> 0

NumberOfArrayDimensions = Ndx - 1

End Function
 
Public Function ReverseArrayInPlace(InputArray As Variant, _
    Optional NoAlerts As Boolean = False) As Boolean
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' ReverseArrayInPlace
' This procedure reverses the order of an array in place -- this is, the array variable
' in the calling procedure is sorted. An error will occur if InputArray is not an array,
 'if it is an empty, unallocated array, or if the number of dimensions is not 1.
'
' NOTE: Before calling the ReverseArrayInPlace procedure, consider if your needs can
' be met by simply reading the existing array in reverse order (Step -1). If so, you can save
' the overhead added to your application by calling this function.
'
' The function returns TRUE if the array was successfully reversed, or FALSE if
' an error occurred.
'
' If an error occurred, a message box is displayed indicating the error. To suppress
' the message box and simply return FALSE, set the NoAlerts parameter to TRUE.
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Dim temp As Variant
Dim Ndx As Long
Dim Ndx2 As Long
Dim OrigN As Long
Dim NewN As Long
Dim NewArr() As Variant

''''''''''''''''''''''''''''''''
' Set the default return value.
''''''''''''''''''''''''''''''''
ReverseArrayInPlace = False

'''''''''''''''''''''''''''''''''
' Ensure we have an array
'''''''''''''''''''''''''''''''''
If IsArray(InputArray) = False Then
   If NoAlerts = False Then
        MsgBox "The InputArray parameter is not an array."
    End If
    Exit Function
End If

''''''''''''''''''''''''''''''''''''''
' Test the number of dimensions of the
' InputArray. If 0, we have an empty,
' unallocated array. Get out with
' an error message. If greater than
' one, we have a multi-dimensional
' array, which is not allowed. Only
' an allocated 1-dimensional array is
' allowed.
''''''''''''''''''''''''''''''''''''''
Select Case NumberOfArrayDimensions(InputArray)
    Case 0
        '''''''''''''''''''''''''''''''''''''''''''
        ' Zero dimensions indicates an unallocated
        ' dynamic array.
        '''''''''''''''''''''''''''''''''''''''''''
        If NoAlerts = False Then
            MsgBox "The input array is an empty, unallocated array."
        End If
        Exit Function
    Case 1
        '''''''''''''''''''''''''''''''''''''''''''
        ' We can reverse ONLY a single dimensional
        ' arrray.
        '''''''''''''''''''''''''''''''''''''''''''
    Case Else
        '''''''''''''''''''''''''''''''''''''''''''
        ' We can reverse ONLY a single dimensional
        ' arrray.
        '''''''''''''''''''''''''''''''''''''''''''
        If NoAlerts = False Then
            MsgBox "The input array multi-dimensional. ReverseArrayInPlace works only " & _
                   "on single-dimensional arrays."
        End If
        Exit Function

End Select

'''''''''''''''''''''''''''''''''''''''''''''
' Ensure that we have only simple data types,
' not an array of objects or arrays.
'''''''''''''''''''''''''''''''''''''''''''''
If IsSimpleDataType(InputArray(LBound(InputArray))) = False Then
    If NoAlerts = False Then
        MsgBox "The input array contains arrays, objects, or other complex data types." & vbCrLf & _
            "ReverseArrayInPlace can reverse only arrays of simple data types."
        Exit Function
    End If
End If

ReDim NewArr(LBound(InputArray) To UBound(InputArray))
NewN = UBound(NewArr)
For OrigN = LBound(InputArray) To UBound(InputArray)
    NewArr(NewN) = InputArray(OrigN)
    NewN = NewN - 1
Next OrigN

For NewN = LBound(NewArr) To UBound(NewArr)
    InputArray(NewN) = NewArr(NewN)
Next NewN

ReverseArrayInPlace = True
End Function


Public Function ReverseArrayInPlace2(InputArray As Variant, _
    Optional LB As Long = -1, Optional UB As Long = -1, _
    Optional NoAlerts As Boolean = False) As Boolean
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' ReverseArrayInPlace2
' This reverses the order of elements in InputArray. To reverse the entire array, omit or
' set to less than 0 the LB and UB parameters. To reverse only part of tbe array, set LB and/or
' UB to the LBound and UBound of the sub array to be reversed.
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Dim n As Long
Dim temp As Variant
Dim Ndx As Long
Dim Ndx2 As Long
Dim OrigN As Long
Dim NewN As Long
Dim NewArr() As Variant

''''''''''''''''''''''''''''''''
' Set the default return value.
''''''''''''''''''''''''''''''''
ReverseArrayInPlace2 = False

'''''''''''''''''''''''''''''''''
' Ensure we have an array
'''''''''''''''''''''''''''''''''
If IsArray(InputArray) = False Then
    If NoAlerts = False Then
        MsgBox "The InputArray parameter is not an array."
    End If
    Exit Function
End If

''''''''''''''''''''''''''''''''''''''
' Test the number of dimensions of the
' InputArray. If 0, we have an empty,
' unallocated array. Get out with
' an error message. If greater than
' one, we have a multi-dimensional
' array, which is not allowed. Only
' an allocated 1-dimensional array is
' allowed.
''''''''''''''''''''''''''''''''''''''
Select Case NumberOfArrayDimensions(InputArray)
    Case 0
        '''''''''''''''''''''''''''''''''''''''''''
        ' Zero dimensions indicates an unallocated
        ' dynamic array.
        '''''''''''''''''''''''''''''''''''''''''''
        If NoAlerts = False Then
            MsgBox "The input array is an empty, unallocated array."
        End If
        Exit Function
    Case 1
        '''''''''''''''''''''''''''''''''''''''''''
        ' We can reverse ONLY a single dimensional
        ' arrray.
        '''''''''''''''''''''''''''''''''''''''''''
    Case Else
        '''''''''''''''''''''''''''''''''''''''''''
        ' We can reverse ONLY a single dimensional
        ' arrray.
        '''''''''''''''''''''''''''''''''''''''''''
        If NoAlerts = False Then
            MsgBox "The input array multi-dimensional. ReverseArrayInPlace works only " & _
                   "on single-dimensional arrays."
        End If
        Exit Function

End Select

'''''''''''''''''''''''''''''''''''''''''''''
' Ensure that we have only simple data types,
' not an array of objects or arrays.
'''''''''''''''''''''''''''''''''''''''''''''
If IsSimpleDataType(InputArray(LBound(InputArray))) = False Then
    If NoAlerts = False Then
        MsgBox "The input array contains arrays, objects, or other complex data types." & vbCrLf & _
            "ReverseArrayInPlace can reverse only arrays of simple data types."
        Exit Function
    End If
End If

If LB < 0 Then
    LB = LBound(InputArray)
End If
If UB < 0 Then
    UB = UBound(InputArray)
End If

For n = LB To (LB + ((UB - LB - 1) \ 2))
    temp = InputArray(n)
    InputArray(n) = InputArray(UB - (n - LB))
    InputArray(UB - (n - LB)) = temp
Next n

ReverseArrayInPlace2 = True
End Function



Public Function IsSimpleNumericType(v As Variant) As Boolean
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' IsSimpleNumericType
' This returns TRUE if V is one of the following data types:
'        vbBoolean
'        vbByte
'        vbCurrency
'        vbDate
'        vbDecimal
'        vbDouble
'        vbInteger
'        vbLong
'        vbSingle
'        vbVariant if it contains a numeric value
' It returns FALSE for any other data type, including any array
' or vbEmpty.
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
If IsSimpleDataType(v) = True Then
    Select Case VarType(v)
        Case vbBoolean, _
                vbByte, _
                vbCurrency, _
                vbDate, _
                vbDecimal, _
                vbDouble, _
                vbInteger, _
                vbLong, _
                vbSingle
            IsSimpleNumericType = True
        Case vbVariant
            If IsNumeric(v) = True Then
                IsSimpleNumericType = True
            Else
                IsSimpleNumericType = False
            End If
        Case Else
            IsSimpleNumericType = False
    End Select
Else
    IsSimpleNumericType = False
End If
End Function

Public Function IsSimpleDataType(v As Variant) As Boolean
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' IsSimpleDataType
' This function returns TRUE if V is one of the following
' variable types (as returned by the VarType function:
'    vbBoolean
'    vbByte
'    vbCurrency
'    vbDate
'    vbDecimal
'    vbDouble
'    vbEmpty
'    vbError
'    vbInteger
'    vbLong
'    vbNull
'    vbSingle
'    vbString
'    vbVariant
'
' It returns FALSE if V is any one of the following variable
' types:
'    vbArray
'    vbDataObject
'    vbObject
'    vbUserDefinedType
'    or if it is an array of any type.

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
On Error Resume Next
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Test if V is an array. We can't just use VarType(V) = vbArray
' because the VarType of an array is vbArray + VarType(type
' of array element). E.g, the VarType of an Array of Longs is
' 8195 = vbArray + vbLong.
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
If IsArray(v) = True Then
    IsSimpleDataType = False
    Exit Function
End If
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' We must also explicitly check whether V is an object, rather
' relying on VarType(V) to equal vbObject. The reason is that
' if V is an object and that object has a default proprety, VarType
' returns the data type of the default property. For example, if
' V is an Excel.Range object pointing to cell A1, and A1 contains
' 12345, VarType(V) would return vbDouble, the since Value is
' the default property of an Excel.Range object and the default
' numeric type of Value in Excel is Double. Thus, in order to
' prevent this type of behavior with default properties, we test
' IsObject(V) to see if V is an object.
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
If IsObject(v) = True Then
    IsSimpleDataType = False
    Exit Function
End If
'''''''''''''''''''''''''''''''''''''
' Test the value returned by VarType.
'''''''''''''''''''''''''''''''''''''
Select Case VarType(v)
    Case vbArray, vbDataObject, vbObject, vbUserDefinedType
        '''''''''''''''''''''''
        ' not simple data types
        '''''''''''''''''''''''
        IsSimpleDataType = False
    Case Else
        ''''''''''''''''''''''''''''''''''''
        ' otherwise it is a simple data type
        ''''''''''''''''''''''''''''''''''''
        IsSimpleDataType = True
End Select

End Function

Public Function IsArrayAllocated(Arr As Variant) As Boolean
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' IsArrayAllocated
' Returns TRUE if the array is allocated (either a static array or a dynamic array that has been
' sized with Redim) or FALSE if the array has not been allocated (a dynamic that has not yet
' been sized with Redim, or a dynamic array that has been Erased).
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Dim n As Long

'''''''''''''''''''''''''''''''''''''''''''''''''''
' If Arr is not an array, return FALSE and get out.
'''''''''''''''''''''''''''''''''''''''''''''''''''
If IsArray(Arr) = False Then
    IsArrayAllocated = False
    Exit Function
End If

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Try to get the UBound of the array. If the array has not been allocated,
' an error will occur. Test Err.Number to see if an error occured.
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
On Error Resume Next
n = UBound(Arr, 1)
If Err.Number = 0 Then
    '''''''''''''''''''''''''''''''''''''
    ' No error. Array has been allocated.
    '''''''''''''''''''''''''''''''''''''
    IsArrayAllocated = True
Else
    '''''''''''''''''''''''''''''''''''''
    ' Error. Unallocated array.
    '''''''''''''''''''''''''''''''''''''
    IsArrayAllocated = False
End If

End Function


Public Sub SortDictionary(Dict As Scripting.Dictionary, _
    SortByKey As Boolean, _
    Optional Descending As Boolean = False, _
    Optional CompareMode As VbCompareMethod = vbTextCompare)
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' SortDictionary
' This sorts a Dictionary object. If SortByKey is False, the
' the sort is done based on the Items of the Dictionary, and
' these items must be simple data types. They may not be
' Object, Arrays, or User-Defined Types. If SortByKey is True,
' the Dictionary is sorted by Key value, and the Items in the
' Dictionary may be Object as well as simple variables.
'
' If sort by key is True, all element of the Dictionary
' must have a non-blank Key value. If Key is vbNullString
' the procedure will terminate.
'
' By defualt, sorting is done in Ascending order. You can
' sort by Descending order by setting the Descending parameter
' to True.
'
' By default, text comparisons are done case-INSENSITIVE (e.g.,
' "a" = "A"). To use case-SENSITIVE comparisons (e.g., "a" <> "A")
' set CompareMode to vbBinaryCompare.
'
' Note: This procedure requires the
' QSortInPlace function, which is described and available for
' download at www.cpearson.com/excel/qsort.htm .
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Dim Ndx As Long
Dim KeyValue As String
Dim ItemValue As Variant
Dim Arr() As Variant
Dim KeyArr() As String
Dim VTypes() As VbVarType


Dim v As Variant
Dim SplitArr As Variant

Dim TempDict As Scripting.Dictionary
'''''''''''''''''''''''''''''
' Ensure Dict is not Nothing.
'''''''''''''''''''''''''''''
If Dict Is Nothing Then
    Exit Sub
End If
''''''''''''''''''''''''''''
' If the number of elements
' in Dict is 0 or 1, no
' sorting is required.
''''''''''''''''''''''''''''
If (Dict.Count = 0) Or (Dict.Count = 1) Then
    Exit Sub
End If

''''''''''''''''''''''''''''
' Create a new TempDict.
''''''''''''''''''''''''''''
Set TempDict = New Scripting.Dictionary

If SortByKey = True Then
    ''''''''''''''''''''''''''''''''''''''''
    ' We're sorting by key. Redim the Arr
    ' to the number of elements in the
    ' Dict object, and load that array
    ' with the key names.
    ''''''''''''''''''''''''''''''''''''''''
    ReDim Arr(0 To Dict.Count - 1)
    
    For Ndx = 0 To Dict.Count - 1
        Arr(Ndx) = Dict.Keys(Ndx)
    Next Ndx
    
    ''''''''''''''''''''''''''''''''''''''
    ' Sort the key names.
    ''''''''''''''''''''''''''''''''''''''
    QSortInPlace InputArray:=Arr, LB:=-1, UB:=-1, Descending:=Descending, CompareMode:=CompareMode
    ''''''''''''''''''''''''''''''''''''''''''''
    ' Load TempDict. The key value come from
    ' our sorted array of keys Arr, and the
    ' Item comes from the original Dict object.
    ''''''''''''''''''''''''''''''''''''''''''''
    For Ndx = 0 To Dict.Count - 1
        KeyValue = Arr(Ndx)
        TempDict.Add key:=KeyValue, Item:=Dict.Item(KeyValue)
    Next Ndx
    '''''''''''''''''''''''''''''''''
    ' Set the passed in Dict object
    ' to our TempDict object.
    '''''''''''''''''''''''''''''''''
    Set Dict = TempDict
    ''''''''''''''''''''''''''''''''
    ' This is the end of processing.
    ''''''''''''''''''''''''''''''''
Else
    '''''''''''''''''''''''''''''''''''''''''''''''
    ' Here, we're sorting by items. The Items must
    ' be simple data types. They may NOT be Objects,
    ' arrays, or UserDefineTypes.
    ' First, ReDim Arr and VTypes to the number
    ' of elements in the Dict object. Arr will
    ' hold a string containing
    '   Item & vbNullChar & Key
    ' This keeps the association between the
    ' item and its key.
    '''''''''''''''''''''''''''''''''''''''''''''''
    ReDim Arr(0 To Dict.Count - 1)
    ReDim VTypes(0 To Dict.Count - 1)

    For Ndx = 0 To Dict.Count - 1
        If (IsObject(Dict.items(Ndx)) = True) Or _
            (IsArray(Dict.items(Ndx)) = True) Or _
            VarType(Dict.items(Ndx)) = vbUserDefinedType Then
            Debug.Print "***** ITEM IN DICTIONARY WAS OBJECT OR ARRAY OR UDT"
            Exit Sub
        End If
        ''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        ' Here, we create a string containing
        '       Item & vbNullChar & Key
        ' This preserves the associate between an item and its
        ' key. Store the VarType of the Item in the VTypes
        ' array. We'll use these values later to convert
        ' back to the proper data type for Item.
        ''''''''''''''''''''''''''''''''''''''''''''''''''''''''
            Arr(Ndx) = Dict.items(Ndx) & vbNullChar & Dict.Keys(Ndx)
            VTypes(Ndx) = VarType(Dict.items(Ndx))
            
    Next Ndx
    ''''''''''''''''''''''''''''''''''
    ' Sort the array that contains the
    ' items of the Dictionary along
    ' with their associated keys
    ''''''''''''''''''''''''''''''''''
    QSortInPlace InputArray:=Arr, LB:=-1, UB:=-1, Descending:=Descending, CompareMode:=vbTextCompare
    
    For Ndx = LBound(Arr) To UBound(Arr)
        '''''''''''''''''''''''''''''''''''''
        ' Loop trhogh the array of sorted
        ' Items, Split based on vbNullChar
        ' to get the Key from the element
        ' of the array Arr.
        SplitArr = Split(Arr(Ndx), vbNullChar)
        ''''''''''''''''''''''''''''''''''''''''''
        ' It may have been possible that item in
        ' the dictionary contains a vbNullChar.
        ' Therefore, use UBound to get the
        ' key value, which will necessarily
        ' be the last item of SplitArr.
        ' Then Redim Preserve SplitArr
        ' to UBound - 1 to get rid of the
        ' Key element, and use Join
        ' to reassemble to original value
        ' of the Item.
        '''''''''''''''''''''''''''''''''''''''''
        KeyValue = SplitArr(UBound(SplitArr))
        ReDim Preserve SplitArr(LBound(SplitArr) To UBound(SplitArr) - 1)
        ItemValue = Join(SplitArr, vbNullChar)
        '''''''''''''''''''''''''''''''''''''''
        ' Join will set ItemValue to a string
        ' regardless of what the original
        ' data type was. Test the VTypes(Ndx)
        ' value to convert ItemValue back to
        ' the proper data type.
        '''''''''''''''''''''''''''''''''''''''
        Select Case VTypes(Ndx)
            Case vbBoolean
                ItemValue = CBool(ItemValue)
            Case vbByte
                ItemValue = CByte(ItemValue)
            Case vbCurrency
                ItemValue = CCur(ItemValue)
            Case vbDate
                ItemValue = CDate(ItemValue)
            Case vbDecimal
                ItemValue = CDec(ItemValue)
            Case vbDouble
                ItemValue = CDbl(ItemValue)
            Case vbInteger
                ItemValue = CInt(ItemValue)
            Case vbLong
                ItemValue = CLng(ItemValue)
            Case vbSingle
                ItemValue = CSng(ItemValue)
            Case vbString
                ItemValue = CStr(ItemValue)
            Case Else
                ItemValue = ItemValue
        End Select
        ''''''''''''''''''''''''''''''''''''''
        ' Finally, add the Item and Key to
        ' our TempDict dictionary.
        
        TempDict.Add key:=KeyValue, Item:=ItemValue
    Next Ndx
End If


'''''''''''''''''''''''''''''''''
' Set the passed in Dict object
' to our TempDict object.
'''''''''''''''''''''''''''''''''
Set Dict = TempDict
End Sub





Attribute VB_Name = "ext_CopyPicture"
'***************************************************************************
'*
'* MODULE NAME:     Paste Picture
'* AUTHOR & DATE:   STEPHEN BULLEN, Office Automation Ltd
'*                  15 November 1998
'*
'* CONTACT:         Stephen@oaltd.co.uk
'* WEB SITE:        http://www.oaltd.co.uk
'*
'* DESCRIPTION:     Creates a standard Picture object from whatever is on the clipboard.
'*                  This object can then be assigned to (for example) and Image control
'*                  on a userform.  The PastePicture function takes an optional argument of
'*                  the picture type - xlBitmap or xlPicture.
'*
'*                  The code requires a reference to the "OLE Automation" type library
'*
'*                  The code in this module has been derived from a number of sources
'*                  discovered on MSDN.
'*
'*                  To use it, just copy this module into your project, then you can use:
'*                      Set Image1.Picture = PastePicture(xlPicture)
'*                  to paste a picture of whatever is on the clipboard into a standard image control.
'*
'* PROCEDURES:
'*   PastePicture   The entry point for the routine
'*   CreatePicture  Private function to convert a bitmap or metafile handle to an OLE reference
'*   fnOLEError     Get the error text for an OLE error code
'***************************************************************************

Option Explicit
Option Compare Text

''' User-Defined Types for API Calls

'Declare a UDT to store a GUID for the IPicture OLE Interface
Private Type GUID
    Data1 As Long
    Data2 As Integer
    Data3 As Integer
    Data4(0 To 7) As Byte
End Type

'Declare a UDT to store the bitmap information
'Private Type PICTDESC
'    Size As Long
'    Type As Long
'    hPic As Long
'    hPal As Long
'End Type

Private Type PICTDESC
    Size As Long
    Type As Long
    hPic As LongPtr
    hPal As LongPtr
End Type


'''Windows API Function Declarations

'Does the clipboard contain a bitmap/metafile?
Private Declare PtrSafe Function IsClipboardFormatAvailable Lib "user32" (ByVal wFormat As Long) As Long
'Private Declare Function IsClipboardFormatAvailable Lib "User32" (ByVal wFormat As Integer) As Long

'Open the clipboard to read
Private Declare PtrSafe Function OpenClipboard Lib "user32" (ByVal hwnd As LongPtr) As Long
'Private Declare Function OpenClipboard Lib "user32" (ByVal hwnd As Long) As Long

'Get a pointer to the bitmap/metafile
'Private Declare PtrSafe Function GetClipboardData Lib "user32" Alias "GetClipboardDataA" (ByVal wFormat As Long) As LongPtr
'Private Declare Function GetClipboardData Lib "user32" (ByVal wFormat As Integer) As Long
Private Declare PtrSafe Function GetClipboardData Lib "user32" (ByVal wFormat As Integer) As LongPtr

'Close the clipboard
Private Declare PtrSafe Function CloseClipboard Lib "user32" () As Long
'Private Declare Function CloseClipboard Lib "user32" () As Long

'Convert the handle into an OLE IPicture interface.
Private Declare PtrSafe Function OleCreatePictureIndirect Lib "oleaut32.dll" (PicDesc As PICTDESC, RefIID As GUID, ByVal fPictureOwnsHandle As LongPtr, IPic As IPicture) As LongPtr
'Private Declare Function OleCreatePictureIndirect Lib "olepro32.dll" (PicDesc As PICTDESC, RefIID As GUID, ByVal fPictureOwnsHandle As Long, IPic As IPicture) As Long

'Create our own copy of the metafile, so it doesn't get wiped out by subsequent clipboard updates.
Declare PtrSafe Function CopyEnhMetaFile Lib "gdi32" Alias "CopyEnhMetaFileA" (ByVal hemfSrc As LongPtr, ByVal lpszFile As String) As LongPtr
'Declare Function CopyEnhMetaFile Lib "gdi32" Alias "CopyEnhMetaFileA" (ByVal hemfSrc As Long, ByVal lpszFile As String) As Long

'Create our own copy of the bitmap, so it doesn't get wiped out by subsequent clipboard updates.
Declare PtrSafe Function CopyImage Lib "user32" (ByVal handle As LongPtr, ByVal un1 As Long, ByVal n1 As Long, ByVal n2 As Long, ByVal un2 As Long) As LongPtr
'Declare Function CopyImage Lib "user32" (ByVal handle As Long, ByVal un1 As Long, ByVal n1 As Long, ByVal n2 As Long, ByVal un2 As Long) As Long

'The API format types we're interested in
Public Const CF_BITMAP = 2
Const CF_PALETTE = 9
Public Const CF_ENHMETAFILE = 14
Const IMAGE_BITMAP = 0
Const LR_COPYRETURNORG = &H4

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''' Subroutine: PastePicture
'''
''' Purpose:    Get a Picture object showing whatever's on the clipboard.
'''
''' Arguments:  lXlPicType - The type of picture to create.  Can be one of:
'''                          xlPicture to create a metafile (default)
'''                          xlBitmap to create a bitmap
'''
''' Date        Developer           Action
''' --------------------------------------------------------------------------
''' 30 Oct 98   Stephen Bullen      Created
''' 15 Nov 98   Stephen Bullen      Updated to create our own copies of the clipboard images
'''

Function PastePicture(Optional lPicType As Long = CF_ENHMETAFILE) As IPicture

'Some pointers
Dim H As Long, hPicAvail As Long, hPtr As LongPtr, hPal As Long, hCopy As LongPtr ' lPicType As Long,

'Convert the type of picture requested from the xl constant to the API constant
' lPicType = IIf(lXlPicType = xlBitmap, CF_BITMAP, CF_ENHMETAFILE)

'Check if the clipboard contains the required format
hPicAvail = IsClipboardFormatAvailable(lPicType)

If hPicAvail <> 0 Then
    'Get access to the clipboard
    H = OpenClipboard(0&)

    If H > 0 Then
        'Get a handle to the image data
        hPtr = GetClipboardData(lPicType)

        'Create our own copy of the image on the clipboard, in the appropriate format.
        If lPicType = CF_BITMAP Then
            hCopy = CopyImage(hPtr, IMAGE_BITMAP, 0, 0, LR_COPYRETURNORG)
        Else
            hCopy = CopyEnhMetaFile(hPtr, vbNullString)
        End If

        'Release the clipboard to other programs
        H = CloseClipboard

        'If we got a handle to the image, convert it into a Picture object and return it
        If hPtr <> 0 Then Set PastePicture = CreatePicture(hCopy, 0, lPicType)
    End If
End If

End Function


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''' Subroutine: CreatePicture
'''
''' Purpose:    Converts a image (and palette) handle into a Picture object.
'''
'''             Requires a reference to the "OLE Automation" type library
'''
''' Arguments:  None
'''
''' Date        Developer           Action
''' --------------------------------------------------------------------------
''' 30 Oct 98  Stephen Bullen      Created
'''

Private Function CreatePicture(ByVal hPic As LongPtr, ByVal hPal As Long, ByVal lPicType) As IPicture

' IPicture requires a reference to "OLE Automation"
Dim r As LongPtr, uPicInfo As PICTDESC, IID_IDispatch As GUID, IPic As IPicture

'OLE Picture types
Const PICTYPE_BITMAP = 1
Const PICTYPE_ENHMETAFILE = 4

' Create the Interface GUID (for the IPicture interface)
With IID_IDispatch
    .Data1 = &H7BF80980
    .Data2 = &HBF32
    .Data3 = &H101A
    .Data4(0) = &H8B
    .Data4(1) = &HBB
    .Data4(2) = &H0
    .Data4(3) = &HAA
    .Data4(4) = &H0
    .Data4(5) = &H30
    .Data4(6) = &HC
    .Data4(7) = &HAB
End With

' Fill uPicInfo with necessary parts.
With uPicInfo
    .Size = Len(uPicInfo)                                                   ' Length of structure.
    .Type = IIf(lPicType = CF_BITMAP, PICTYPE_BITMAP, PICTYPE_ENHMETAFILE)  ' Type of Picture
    .hPic = hPic                                                            ' Handle to image.
    .hPal = IIf(lPicType = CF_BITMAP, hPal, 0)                              ' Handle to palette (if bitmap).
End With

' Create the Picture object.
r = OleCreatePictureIndirect(uPicInfo, IID_IDispatch, True, IPic)

' If an error occured, show the description
If r <> 0 Then Debug.Print "Create Picture: " & fnOLEError(r)

' Return the new Picture object.
Set CreatePicture = IPic

End Function

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''' Subroutine: fnOLEError
'''
''' Purpose:    Gets the message text for standard OLE errors
'''
''' Arguments:  None
'''
''' Date        Developer           Action
''' --------------------------------------------------------------------------
''' 30 Oct 98   Stephen Bullen      Created
'''

Private Function fnOLEError(lErrNum As LongPtr) As String

'OLECreatePictureIndirect return values
Const E_ABORT = &H80004004
Const E_ACCESSDENIED = &H80070005
Const E_FAIL = &H80004005
Const E_HANDLE = &H80070006
Const E_INVALIDARG = &H80070057
Const E_NOINTERFACE = &H80004002
Const E_NOTIMPL = &H80004001
Const E_OUTOFMEMORY = &H8007000E
Const E_POINTER = &H80004003
Const E_UNEXPECTED = &H8000FFFF
Const S_OK = &H0

Select Case lErrNum
Case E_ABORT
    fnOLEError = " Aborted"
Case E_ACCESSDENIED
    fnOLEError = " Access Denied"
Case E_FAIL
    fnOLEError = " General Failure"
Case E_HANDLE
    fnOLEError = " Bad/Missing Handle"
Case E_INVALIDARG
    fnOLEError = " Invalid Argument"
Case E_NOINTERFACE
    fnOLEError = " No Interface"
Case E_NOTIMPL
    fnOLEError = " Not Implemented"
Case E_OUTOFMEMORY
    fnOLEError = " Out of Memory"
Case E_POINTER
    fnOLEError = " Invalid Pointer"
Case E_UNEXPECTED
    fnOLEError = " Unknown Error"
Case S_OK
    fnOLEError = " Success!"
End Select

End Function


Attribute VB_Name = "ext_LoadImage"
'This module provides a LoadPictureGDI function, which can
'be used instead of VBA's LoadPicture, to load a wide variety
'of image types from disk - including png.
'
'The png format is used in Office 2007-2010 to provide images that
'include an alpha channel for each pixel's transparency
'
'Author:    Stephen Bullen
'Date:      31 October, 2006
'Email:     stephen@oaltd.co.uk

'Updated :  30 December, 2010
'By :       Rob Bovey
'Reason :   Also working now in the 64 bit version of Office 2010

Option Explicit

'Declare a UDT to store a GUID for the IPicture OLE Interface
Private Type GUID
    Data1 As Long
    Data2 As Integer
    Data3 As Integer
    Data4(0 To 7) As Byte
End Type


#If VBA7 Then
    'Declare a UDT to store the bitmap information
    Private Type PICTDESC
        Size As Long
        Type As Long
        hPic As LongPtr
        hPal As LongPtr
    End Type
    
    'Declare a UDT to store the GDI+ Startup information
    Private Type GdiplusStartupInput
        GdiplusVersion As Long
        DebugEventCallback As LongPtr
        SuppressBackgroundThread As Long
        SuppressExternalCodecs As Long
    End Type
    
    'Windows API calls into the GDI+ library
    Private Declare PtrSafe Function GdiplusStartup Lib "GDIPlus" (token As LongPtr, inputbuf As GdiplusStartupInput, Optional ByVal outputbuf As LongPtr = 0) As Long
    Private Declare PtrSafe Function GdipCreateBitmapFromFile Lib "GDIPlus" (ByVal fileName As LongPtr, bitmap As LongPtr) As Long
    Private Declare PtrSafe Function GdipCreateHBITMAPFromBitmap Lib "GDIPlus" (ByVal bitmap As LongPtr, hbmReturn As LongPtr, ByVal background As LongPtr) As Long
    Private Declare PtrSafe Function GdipDisposeImage Lib "GDIPlus" (ByVal image As LongPtr) As Long
    Private Declare PtrSafe Sub GdiplusShutdown Lib "GDIPlus" (ByVal token As LongPtr)
    Private Declare PtrSafe Function OleCreatePictureIndirect Lib "oleaut32" (PicDesc As PICTDESC, RefIID As GUID, ByVal fPictureOwnsHandle As Long, IPic As IPicture) As Long
#Else
    'Declare a UDT to store the bitmap information
    Private Type PICTDESC
        Size As Long
        Type As Long
        hPic As Long
        hPal As Long
    End Type
    
    'Declare a UDT to store the GDI+ Startup information
    Private Type GdiplusStartupInput
        GdiplusVersion As Long
        DebugEventCallback As Long
        SuppressBackgroundThread As Long
        SuppressExternalCodecs As Long
    End Type
    
    'Windows API calls into the GDI+ library
    Private Declare Function GdiplusStartup Lib "GDIPlus" (token As Long, inputbuf As GdiplusStartupInput, Optional ByVal outputbuf As Long = 0) As Long
    Private Declare Function GdipCreateBitmapFromFile Lib "GDIPlus" (ByVal fileName As Long, bitmap As Long) As Long
    Private Declare Function GdipCreateHBITMAPFromBitmap Lib "GDIPlus" (ByVal bitmap As Long, hbmReturn As Long, ByVal background As Long) As Long
    Private Declare Function GdipDisposeImage Lib "GDIPlus" (ByVal image As Long) As Long
    Private Declare Sub GdiplusShutdown Lib "GDIPlus" (ByVal token As Long)
    Private Declare Function OleCreatePictureIndirect Lib "oleaut32" (PicDesc As PICTDESC, RefIID As GUID, ByVal fPictureOwnsHandle As Long, IPic As IPicture) As Long
#End If

' Procedure:    LoadPictureGDI
' Purpose:      Loads an image using GDI+
' Returns:      The image as an IPicture Object
Public Function LoadPictureGDI(ByVal sFilename As String) As IPicture

    Dim uGdiInput As GdiplusStartupInput
    Dim lResult As Long
#If VBA7 Then
    Dim hGdiPlus As LongPtr
    Dim hGdiImage As LongPtr
    Dim hBitmap As LongPtr
#Else
    Dim hGdiPlus As Long
    Dim hGdiImage As Long
    Dim hBitmap As Long
#End If

    'Initialize GDI+
    uGdiInput.GdiplusVersion = 1
    lResult = GdiplusStartup(hGdiPlus, uGdiInput)

    If lResult = 0 Then

        'Load the image
        lResult = GdipCreateBitmapFromFile(StrPtr(sFilename), hGdiImage)

        If lResult = 0 Then

            'Create a bitmap handle from the GDI image
            lResult = GdipCreateHBITMAPFromBitmap(hGdiImage, hBitmap, 0)

            'Create the IPicture object from the bitmap handle
            Set LoadPictureGDI = CreateIPicture(hBitmap)

            'Tidy up
            GdipDisposeImage hGdiImage
        End If

        'Shutdown GDI+
        GdiplusShutdown hGdiPlus
    End If
End Function


' Procedure:    CreateIPicture
' Purpose:      Converts a image handle into an IPicture object.
' Returns:      The IPicture object
#If VBA7 Then
Private Function CreateIPicture(ByVal hPic As LongPtr) As IPicture
#Else
Private Function CreateIPicture(ByVal hPic As Long) As IPicture
#End If
    Dim lResult As Long
    Dim uPicInfo As PICTDESC
    Dim IID_IDispatch As GUID
    Dim IPic As IPicture

    'OLE Picture types
    Const PICTYPE_BITMAP = 1

    ' Create the Interface GUID (for the IPicture interface)
    With IID_IDispatch
        .Data1 = &H7BF80980
        .Data2 = &HBF32
        .Data3 = &H101A
        .Data4(0) = &H8B
        .Data4(1) = &HBB
        .Data4(2) = &H0
        .Data4(3) = &HAA
        .Data4(4) = &H0
        .Data4(5) = &H30
        .Data4(6) = &HC
        .Data4(7) = &HAB
    End With

    ' Fill uPicInfo with necessary parts.
    With uPicInfo
        .Size = Len(uPicInfo)
        .Type = PICTYPE_BITMAP
        .hPic = hPic
        .hPal = 0
    End With

    ' Create the Picture object.
    lResult = OleCreatePictureIndirect(uPicInfo, IID_IDispatch, True, IPic)

    ' Return the new Picture object.
    Set CreateIPicture = IPic
End Function


Attribute VB_Name = "ext_OpenSaveAPI"
Option Explicit

'***************** Code Start **************
' This code was originally written by Ken Getz.
' It is not to be altered or distributed, 'except as part of an application.
' You are free to use it in any application,
' provided the copyright notice is left unchanged.
'
' Code originally courtesy of:
' Microsoft Access 95 How-To
' Ken Getz and Paul Litwin
' Waite Group Press, 1996
' Revised to support multiple files:
' 28 December 2007

Type tagOPENFILENAME
    lStructSize As Long
    hwndOwner As LongPtr
    hInstance As LongPtr
    strFilter As String
    strCustomFilter As String
    nMaxCustFilter As Long
    nFilterIndex As Long
    strFile As String
    nMaxFile As Long
    strFileTitle As String
    nMaxFileTitle As Long
    strInitialDir As String
    strTitle As String
    flags As Long
    nFileOffset As Integer
    nFileExtension As Integer
    strDefExt As String
    lCustData As Long
    lpfnHook As LongPtr
    lpTemplateName As String
End Type

'#If Win64 = 1 And VBA7 = 1 Then
'    Declare PtrSafe Function aht_apiGetOpenFileName Lib "comdlg32.dll" Alias "GetOpenFileNameA" (OFN As tagOPENFILENAME) As Boolean
'
'    Private Declare PtrSafe Function apiGetLocaleInfo Lib "kernel32" Alias "GetLocaleInfoA" (ByVal Locale As Long, ByVal LCType As Long, ByVal lpLCData As String, ByVal cchData As Long) As Long
'
'    Private Declare PtrSafe Function LoadLibraryRegister Lib "kernel32" Alias "LoadLibraryA" (ByVal lpLibFileName$) As Long
'
'    Public Declare PtrSafe Function SetDllDirectoryA Lib "kernel32" (ByVal lpPathName As String) As Long
'
'    Private Declare PtrSafe Function GetProcAddressRegister Lib "kernel32" Alias _
'    "GetProcAddress" (ByVal hModule&, ByVal lpProcName$) As Long
'
'    Private Declare PtrSafe Function CreateThreadForRegister Lib "kernel32" Alias _
'    "CreateThread" (lpThreadAttributes As Any, ByVal dwStackSize&, ByVal lpStartAddress&, _
'    ByVal lpparameter&, ByVal dwCreationFlags&, ThreadID&) As Long
'#Else
'    Declare Function aht_apiGetOpenFileName Lib "comdlg32.dll" Alias "GetOpenFileNameA" (OFN As tagOPENFILENAME) As Boolean
'
'    Private Declare Function apiGetLocaleInfo Lib "kernel32" Alias "GetLocaleInfoA" (ByVal Locale As Long, ByVal LCType As Long, ByVal lpLCData As String, ByVal cchData As Long) As Long
'
'    Private Declare Function LoadLibraryRegister Lib "kernel32" Alias "LoadLibraryA" (ByVal lpLibFileName$) As Long
'
'    Public Declare Function SetDllDirectoryA Lib "kernel32" (ByVal lpPathName As String) As Long
'
'    Private Declare Function GetProcAddressRegister Lib "kernel32" Alias _
'    "GetProcAddress" (ByVal hModule&, ByVal lpProcName$) As Long
'
'    Private Declare Function CreateThreadForRegister Lib "kernel32" Alias _
'    "CreateThread" (lpThreadAttributes As Any, ByVal dwStackSize&, ByVal lpStartAddress&, _
'    ByVal lpparameter&, ByVal dwCreationFlags&, ThreadID&) As Long
'#End If

Declare PtrSafe Function aht_apiGetOpenFileName Lib "comdlg32.dll" Alias "GetOpenFileNameA" (OFN As tagOPENFILENAME) As Boolean
'Declare Function aht_apiGetOpenFileName Lib "comdlg32.dll" Alias "GetOpenFileNameA" (OFN As tagOPENFILENAME) As Boolean

Declare PtrSafe Function aht_apiGetSaveFileName Lib "comdlg32.dll" Alias "GetSaveFileNameA" (OFN As tagOPENFILENAME) As Boolean
'Declare Function aht_apiGetSaveFileName Lib "comdlg32.dll" Alias "GetSaveFileNameA" (OFN As tagOPENFILENAME) As Boolean

Declare PtrSafe Function CommDlgExtendedError Lib "comdlg32.dll" () As Long
'Declare Function CommDlgExtendedError Lib "comdlg32.dll" () As Long

'Private Declare PtrSafe Function GetOpenFileName Lib "comdlg32.dll" Alias "GetOpenFileNameA" (pOpenfilename As OPENFILENAME) As Long
'
'Private Declare PtrSafe Function GetSaveFileName Lib "comdlg32.dll" Alias "GetSaveFileNameA" (pOpenfilename As OPENFILENAME) As Long
'
'Private Declare PtrSafe Function SHBrowseForFolder Lib "shell32.dll" Alias "SHBrowseForFolderA" (lpBrowseInfo As BrowseInfo) As Long
'
'Private Declare PtrSafe Function SHGetPathFromIDList Lib "shell32.dll" (ByVal pidList As LongPtr, ByVal lpBuffer As String) As Long


Global Const ahtOFN_READONLY = &H1
Global Const ahtOFN_OVERWRITEPROMPT = &H2
Global Const ahtOFN_HIDEREADONLY = &H4
Global Const ahtOFN_NOCHANGEDIR = &H8
Global Const ahtOFN_SHOWHELP = &H10
' You won't use these.
'Global Const ahtOFN_ENABLEHOOK = &H20
'Global Const ahtOFN_ENABLETEMPLATE = &H40
'Global Const ahtOFN_ENABLETEMPLATEHANDLE = &H80
Global Const ahtOFN_NOVALIDATE = &H100
Global Const ahtOFN_ALLOWMULTISELECT = &H200
Global Const ahtOFN_EXTENSIONDIFFERENT = &H400
Global Const ahtOFN_PATHMUSTEXIST = &H800
Global Const ahtOFN_FILEMUSTEXIST = &H1000
Global Const ahtOFN_CREATEPROMPT = &H2000
Global Const ahtOFN_SHAREAWARE = &H4000
Global Const ahtOFN_NOREADONLYRETURN = &H8000
Global Const ahtOFN_NOTESTFILECREATE = &H10000
Global Const ahtOFN_NONETWORKBUTTON = &H20000
Global Const ahtOFN_NOLONGNAMES = &H40000
' New for Windows 95
Global Const ahtOFN_EXPLORER = &H80000
Global Const ahtOFN_NODEREFERENCELINKS = &H100000
Global Const ahtOFN_LONGNAMES = &H200000

Function TestIt()
    ActiveWindowHandle = GetActiveWindow

    Dim strFilter As String
    Dim lngFlags As Long
    strFilter = ahtAddFilterItem(strFilter, "Access Files (*.mda, *.mdb)", "*.MDA;*.MDB")
    strFilter = ahtAddFilterItem(strFilter, "dBASE Files (*.dbf)", "*.DBF")
    strFilter = ahtAddFilterItem(strFilter, "Text Files (*.txt)", "*.TXT")
    strFilter = ahtAddFilterItem(strFilter, "All Files (*.*)", "*.*")

    ' Uncomment this line to try the example
    ' allowing multiple file names:
    ' lngFlags = ahtOFN_ALLOWMULTISELECT Or ahtOFN_EXPLORER

    Dim result As Variant

    result = ahtCommonFileOpenSave(InitialDir:="C:\", _
        Filter:=strFilter, FilterIndex:=3, flags:=lngFlags, _
        DialogTitle:="Save picture", OpenFile:=False)

    If lngFlags And ahtOFN_ALLOWMULTISELECT Then
        If IsArray(result) Then
            Dim i As Integer
            For i = 0 To UBound(result)
                MsgBox result(i)
            Next i
        Else
            MsgBox result
        End If
    Else
        MsgBox result
    End If

    ' Since you passed in a variable for lngFlags,
    ' the function places the output flags value in the variable.
    Debug.Print Hex(lngFlags)
End Function

Function GetOpenFile(Optional varDirectory As Variant, _
    Optional varTitleForDialog As Variant) As Variant

    ' Here's an example that gets an Access database name.
    Dim strFilter As String
    Dim lngFlags As Long
    Dim varFileName As Variant

    ' Specify that the chosen file must already exist,
    ' don't change directories when you're done
    ' Also, don't bother displaying
    ' the read-only box. It'll only confuse people.
    lngFlags = ahtOFN_FILEMUSTEXIST Or _
                ahtOFN_HIDEREADONLY Or ahtOFN_NOCHANGEDIR
    If IsMissing(varDirectory) Then
        varDirectory = ""
    End If
    If IsMissing(varTitleForDialog) Then
        varTitleForDialog = ""
    End If

    ' Define the filter string and allocate space in the "c"
    ' string Duplicate this line with changes as necessary for
    ' more file templates.
    strFilter = ahtAddFilterItem(strFilter, _
                "Access (*.mdb)", "*.MDB;*.MDA")

    ' Now actually call to get the file name.
    varFileName = ahtCommonFileOpenSave( _
                    OpenFile:=True, _
                    InitialDir:=varDirectory, _
                    Filter:=strFilter, _
                    flags:=lngFlags, _
                    DialogTitle:=varTitleForDialog)
    If Not IsNull(varFileName) Then
        varFileName = TrimNull(varFileName)
    End If
    GetOpenFile = varFileName
End Function

Function ahtCommonFileOpenSave( _
            Optional ByRef flags As Variant, _
            Optional ByVal InitialDir As Variant, _
            Optional ByVal Filter As Variant, _
            Optional ByVal FilterIndex As Variant, _
            Optional ByVal DefaultExt As Variant, _
            Optional ByVal fileName As Variant, _
            Optional ByVal DialogTitle As Variant, _
            Optional ByVal hwnd As Variant, _
            Optional ByVal OpenFile As Variant) As Variant

    ' This is the entry point you'll use to call the common
    ' file open/save dialog. The parameters are listed
    ' below, and all are optional.
    '
    ' In:
    ' Flags: one or more of the ahtOFN_* constants, OR'd together.
    ' InitialDir: the directory in which to first look
    ' Filter: a set of file filters, set up by calling
    ' AddFilterItem. See examples.
    ' FilterIndex: 1-based integer indicating which filter
    ' set to use, by default (1 if unspecified)
    ' DefaultExt: Extension to use if the user doesn't enter one.
    ' Only useful on file saves.
    ' FileName: Default value for the file name text box.
    ' DialogTitle: Title for the dialog.
    ' hWnd: parent window handle
    ' OpenFile: Boolean(True=Open File/False=Save As)
    ' Out:
    ' Return Value: Either Null or the selected filename
    Dim OFN As tagOPENFILENAME
    Dim strFileName As String
    Dim strFileTitle As String
    Dim fResult As Boolean

    ' Give the dialog a caption title.
    If IsMissing(InitialDir) Then InitialDir = CurDir
    If IsMissing(Filter) Then Filter = ""
    If IsMissing(FilterIndex) Then FilterIndex = 1
    If IsMissing(flags) Then flags = 0&
    If IsMissing(DefaultExt) Then DefaultExt = ""
    If IsMissing(fileName) Then fileName = ""
    If IsMissing(DialogTitle) Then DialogTitle = ""
    If IsMissing(hwnd) Then hwnd = ActiveWindowHandle 'Application.hWndWAccessApp
    If IsMissing(OpenFile) Then OpenFile = True
    ' Allocate string space for the returned strings.
    strFileName = Left(fileName & String(256, 0), 256)
    strFileTitle = String(256, 0)
    ' Set up the data structure before you call the function
    With OFN
        .lStructSize = LenB(OFN)
        .hwndOwner = hwnd
        .strFilter = Filter
        .nFilterIndex = FilterIndex
        .strFile = strFileName
        .nMaxFile = Len(strFileName)
        .strFileTitle = strFileTitle
        .nMaxFileTitle = Len(strFileTitle)
        .strTitle = DialogTitle
        .flags = flags
        .strDefExt = DefaultExt
        .strInitialDir = InitialDir
        ' Didn't think most people would want to deal with
        ' these options.
        .hInstance = 0
        '.strCustomFilter = ""
        '.nMaxCustFilter = 0
        .lpfnHook = 0
        'New for NT 4.0
        .strCustomFilter = String(255, 0)
        .nMaxCustFilter = 255
    End With
    ' This will pass the desired data structure to the
    ' Windows API, which will in turn it uses to display
    ' the Open/Save As Dialog.
    If OpenFile Then
        fResult = aht_apiGetOpenFileName(OFN)
    Else
        fResult = aht_apiGetSaveFileName(OFN)
    End If

    ' The function call filled in the strFileTitle member
    ' of the structure. You'll have to write special code
    ' to retrieve that if you're interested.
    If fResult Then
        ' You might care to check the Flags member of the
        ' structure to get information about the chosen file.
        ' In this example, if you bothered to pass in a
        ' value for Flags, we'll fill it in with the outgoing
        ' Flags value.
        If Not IsMissing(flags) Then flags = OFN.flags
        If flags And ahtOFN_ALLOWMULTISELECT Then
            ' Return the full array.
            Dim items As Variant
            Dim value As String
            value = OFN.strFile
            ' Get rid of empty items:
            Dim i As Integer
            For i = Len(value) To 1 Step -1
              If Mid$(value, i, 1) <> Chr$(0) Then
                Exit For
              End If
            Next i
            value = Mid(value, 1, i)

            ' Break the list up at null characters:
            items = Split(value, Chr(0))

            ' Loop through the items in the "array",
            ' and build full file names:
            Dim numItems As Integer
            Dim result() As String

            numItems = UBound(items) + 1
            If numItems > 1 Then
                ReDim result(0 To numItems - 2)
                For i = 1 To numItems - 1
                    result(i - 1) = FixPath(items(0)) & items(i)
                Next i
                ahtCommonFileOpenSave = result
            Else
                ' If you only select a single item,
                ' Windows just places it in item 0.
                ahtCommonFileOpenSave = items(0)
            End If
        Else
            ahtCommonFileOpenSave = TrimNull(OFN.strFile)
        End If
    Else
        ahtCommonFileOpenSave = vbNullString
    End If
End Function

Function ahtAddFilterItem(strFilter As String, _
    strDescription As String, Optional varItem As Variant) As String

    ' Tack a new chunk onto the file filter.
    ' That is, take the old value, stick onto it the description,
    ' (like "Databases"), a null character, the skeleton
    ' (like "*.mdb;*.mda") and a final null character.
    If IsMissing(varItem) Then varItem = "*.*"
    ahtAddFilterItem = strFilter & _
                strDescription & vbNullChar & _
                varItem & vbNullChar
End Function

Private Function TrimNull(ByVal strItem As String) As String
    Dim intPos As Integer

    intPos = InStr(strItem, vbNullChar)
    If intPos > 0 Then
        TrimNull = Left(strItem, intPos - 1)
    Else
        TrimNull = strItem
    End If
End Function

Private Function FixPath(ByVal path As String) As String
    If Right$(path, 1) <> "\" Then
        FixPath = path & "\"
    Else
        FixPath = path
    End If
End Function

'************** Code End *****************



Attribute VB_Name = "ext_UTCTime"
Option Explicit

' Use the PtrSafe attribute for x64 installations
Private Declare PtrSafe Function FileTimeToLocalFileTime Lib "kernel32" (lpFileTime As FILETIME, ByRef lpLocalFileTime As FILETIME) As Long
Private Declare PtrSafe Function LocalFileTimeToFileTime Lib "kernel32" (lpLocalFileTime As FILETIME, ByRef lpFileTime As FILETIME) As Long
Private Declare PtrSafe Function SystemTimeToFileTime Lib "kernel32" (lpSystemTime As SYSTEMTIME, ByRef lpFileTime As FILETIME) As Long
Private Declare PtrSafe Function FileTimeToSystemTime Lib "kernel32" (lpFileTime As FILETIME, ByRef lpSystemTime As SYSTEMTIME) As Long

Public Type FILETIME
  LowDateTime As Long
  HighDateTime As Long
End Type

Public Type SYSTEMTIME
  Year As Integer
  Month As Integer
  DayOfWeek As Integer
  Day As Integer
  Hour As Integer
  Minute As Integer
  Second As Integer
  Milliseconds As Integer
End Type


'===============================================================================
' Convert local time to UTC
'===============================================================================
Public Function UTCTime(local_time As Date) As Date
  Dim oLocalFileTime As FILETIME
  Dim oUtcFileTime As FILETIME
  Dim oSystemTime As SYSTEMTIME

  ' Convert to a SYSTEMTIME
  oSystemTime = DateToSystemTime(local_time)

  ' 1. Convert to a FILETIME
  ' 2. Convert to UTC time
  ' 3. Convert to a SYSTEMTIME
  Call SystemTimeToFileTime(oSystemTime, oLocalFileTime)
  Call LocalFileTimeToFileTime(oLocalFileTime, oUtcFileTime)
  Call FileTimeToSystemTime(oUtcFileTime, oSystemTime)

  ' Convert to a Date
  UTCTime = SystemTimeToDate(oSystemTime)
End Function



'===============================================================================
' Convert UTC to local time
'===============================================================================
Public Function LocalTime(utc_time As Date) As Date
  Dim oLocalFileTime As FILETIME
  Dim oUtcFileTime As FILETIME
  Dim oSystemTime As SYSTEMTIME

  ' Convert to a SYSTEMTIME.
  oSystemTime = DateToSystemTime(utc_time)

  ' 1. Convert to a FILETIME
  ' 2. Convert to local time
  ' 3. Convert to a SYSTEMTIME
  Call SystemTimeToFileTime(oSystemTime, oUtcFileTime)
  Call FileTimeToLocalFileTime(oUtcFileTime, oLocalFileTime)
  Call FileTimeToSystemTime(oLocalFileTime, oSystemTime)

  ' Convert to a Date
  LocalTime = SystemTimeToDate(oSystemTime)
End Function



'===============================================================================
' Convert a Date to a SYSTEMTIME
'===============================================================================
Function DateToSystemTime(value As Date) As SYSTEMTIME
  With DateToSystemTime
    .Year = Year(value)
    .Month = Month(value)
    .Day = Day(value)
    .Hour = Hour(value)
    .Minute = Minute(value)
    .Second = Second(value)
  End With
End Function



'===============================================================================
' Convert a SYSTEMTIME to a Date
'===============================================================================
Private Function SystemTimeToDate(value As SYSTEMTIME) As Date
  With value
    SystemTimeToDate = _
      DateSerial(.Year, .Month, .Day) + _
      TimeSerial(.Hour, .Minute, .Second)
  End With
End Function



' InQuest injected base64 decoded content
' YMjg
' Kjx.j
' Ryhr@%
' ^:WE
' ,>'-
' h>'-
' z{Ki
' %F'!M
' $Ryhr@
' 1"w%
' BjW.
' LjwZ
' j{%j
' z{H#
' e"w^
' rJ'^
' Kjx.j
' jZ "{
' -"yb
' /j)ZnW
' z+xYZ
' )^N)

INQUEST-PP=macro
