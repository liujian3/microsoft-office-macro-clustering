Attribute VB_Name = "ACC"
Option Explicit

Function GetCurDBProperty(prop As String) As String
On Error Resume Next
  GetCurDBProperty = ""
  GetCurDBProperty = m_App.CurrentDb.Properties(prop)
End Function

Function GetValueFromField(ByRef rs As Object, fieldname As String, defvalue) As Variant
  On Error GoTo nogo
    
  GetValueFromField = defvalue
  If Not IsNull(rs.Fields(fieldname).value) Then
    GetValueFromField = rs.Fields(fieldname).value
  End If
  
nogo:
  
End Function


Sub XLACCStoreValsToDB(ByVal analyseWarErfolgreich As Boolean)
  
On Error GoTo nogo
  
  If G_Conn Is Nothing Then Exit Sub
  
  If theidvDateiID <= 0 Then Exit Sub
  
  If analyseWarErfolgreich = False Then
    Exit Sub
  End If
  
  G_Conn.Execute "DELETE FROM idvDateienVBALib WHERE idvDateiID=" & theidvDateiID
  
  AddStatus FMT0("CHECK_53")
  
  Dim rs As Object
  Dim rsecc As Object
'  Dim rslinks As Object
  Dim riskrs As Object
  Dim rsParam As Object
  Dim rsLib As Object

  Set riskrs = OpenRS("SELECT * FROM ACCDateienRisiko where idvDateiID = -1", G_Conn, MYadOpenDynamic, MYadLockOptimistic)
  Set rs = OpenRS("SELECT * FROM ACCAnalyse where idvDateiID = -1", G_Conn, MYadOpenDynamic, MYadLockOptimistic)
  Set rsecc = OpenRS("SELECT * FROM idvDateien WHERE idvDateiID = " & theidvDateiID, G_Conn, MYadOpenDynamic, MYadLockOptimistic)
  Set rsParam = OpenRS("SELECT * FROM gParameter order by ParameterID", G_Conn, MYadOpenDynamic, MYadLockReadOnly)
'  Set rslinks = GetRS("SELECT * FROM ECCVerknuepfungen")
  Set rsLib = OpenRS("SELECT * FROM idvDateienVBALib WHERE idvDateiID = " & theidvDateiID, G_Conn, MYadOpenDynamic, MYadLockOptimistic)
  
'  If riskrs Is Nothing Or rs Is Nothing Or rsecc Is Nothing Then
  If riskrs Is Nothing Or rs Is Nothing Or rsecc Is Nothing Or rsParam Is Nothing Or rsLib Is Nothing Then
    If Not riskrs Is Nothing Then
      riskrs.Close
      Set riskrs = Nothing
    End If
    If Not rs Is Nothing Then
      rs.Close
      Set rs = Nothing
    End If
    If Not rsecc Is Nothing Then
      rsecc.Close
      Set rsecc = Nothing
    End If
    If Not rsParam Is Nothing Then
      rsParam.Close
      Set rsParam = Nothing
    End If
'    If Not rslinks Is Nothing Then
'      rslinks.Close
'      Set rslinks = Nothing
'    End If
    If Not rsLib Is Nothing Then
      rsLib.Close
      Set rsLib = Nothing
    End If
    
    Exit Sub
  End If
  
  rs.AddNew
  rs.Fields("idvDateiID").value = theidvDateiID
  Dim nowdate As Date
  If theTrackerFreigabe Then
    nowdate = theTrackerFreigabeDatum
  Else
    nowdate = Now
  End If
  rs.Fields("Datum").value = nowdate
  rs.Fields("Dateigroesse").value = MyFileLen(theFilename)
  
  On Error Resume Next
  Dim i As Long
  
  ' Status immer speichern.
  rs.Fields("StatusID").value = XLScriptGetSimpleVar("STATUSID").m_Value
  rsecc.Fields("ScanstatusID").value = XLScriptGetSimpleVar("STATUSID").m_Value
  
  If analyseWarErfolgreich Then
    If Not XLScriptGetSimpleVar("CREATIONDATE") Is Nothing Then
      Dim d As Date
      d = IIf(IsDate(XLScriptGetSimpleVar("CREATIONDATE").m_Value) = True, XLScriptGetSimpleVar("CREATIONDATE").m_Value, DateSerial(1900, 1, 1))
      If d < #1/1/1900# Then d = #1/1/1900#
      rs.Fields("Erstellungsdatum").value = d
    Else
      rs.Fields("Erstellungsdatum").value = DateSerial(1900, 1, 1)
    End If
    
    If Not XLScriptGetSimpleVar("AUTHOR") Is Nothing Then
      rs.Fields("Ersteller").value = Left(XLScriptGetSimpleVar("AUTHOR").m_Value, 24)
    Else
      rs.Fields("Ersteller").value = ""
    End If
  
'  If Not XLScriptGetArray("EXTERNALFILES") Is Nothing Then
'    If XLScriptGetArray("EXTERNALFILES").items.count > 0 Then
'      For i = 1 To XLScriptGetArray("EXTERNALFILES").items.count
'        rslinks.AddNew
        
'        rslinks.Fields("idvDateiID").Value = theIdvDateiID
'        rslinks.Fields("Datum").Value = nowdate
'        rslinks.Fields("Dateiname").Value = XLScriptGetArray("EXTERNALFILES").items(i).m_SortName
'        rslinks.Update
'      Next i
'    End If
'  End If
'  rslinks.Close
'  Set rslinks = Nothing
  
  
    If Not XLScriptGetArray2D("LIBS") Is Nothing Then
      If XLScriptGetArray2D("LIBS").items.count > 0 Then
        For i = 1 To XLScriptGetArray2D("LIBS").items.count
          rsLib.AddNew
          rsLib.Fields("idvDateiID").value = theidvDateiID
          rsLib.Fields("LIBNAME").value = UCase(Left(XLScriptGetArray2D("LIBS").items(i)("LIBNAME"), rsLib.Fields("LIBNAME").DefinedSize))
          rsLib.Fields("LIBDESCRIPTION").value = Left(XLScriptGetArray2D("LIBS").items(i)("LIBDESCRIPTION"), rsLib.Fields("LIBDESCRIPTION").DefinedSize)
          rsLib.Fields("LIBTYPE").value = XLScriptGetArray2D("LIBS").items(i)("LIBTYPE")
          rsLib.Fields("MAJOR").value = XLScriptGetArray2D("LIBS").items(i)("MAJOR")
          rsLib.Fields("MINOR").value = XLScriptGetArray2D("LIBS").items(i)("MINOR")
          rsLib.Fields("PATH").value = UCase(XLScriptGetArray2D("LIBS").items(i)("PATH"))
          rsLib.Fields("GUID").value = Left(XLScriptGetArray2D("LIBS").items(i)("GUID"), rsLib.Fields("GUID").DefinedSize)
          rsLib.Fields("BUILTIN").value = XLScriptGetArray2D("LIBS").items(i)("BUILTIN")
          rsLib.Fields("ISBROKEN").value = XLScriptGetArray2D("LIBS").items(i)("ISBROKEN")
          rsLib.Update
        Next i
      End If
    End If
  
  
    i = 1
    Dim item
    For Each item In m_AllVars
      Select Case TypeName(item)
        Case "XLScriptArray"
          Debug.Print TypeName(item), item.m_SortName
        Case "XLScriptArray2D"
          Debug.Print TypeName(item), item.m_SortName
  
          If item.m_SortName = "RiskItems" Then
            Dim litem
            For Each litem In item.items
              riskrs.AddNew
              riskrs.Fields("idvDateiID").value = theidvDateiID
              riskrs.Fields("Datum").value = nowdate
              riskrs.Fields("Name").value = Left(litem(1), 20)
              riskrs.Fields("Wert").value = litem(2)
              riskrs.Fields("Farbe").value = litem(3)
              riskrs.Update
            Next litem
          End If
        Case "XLScriptSimpleVar"
  '        Debug.Print TypeName(item), item.m_Txt, item.m_Value
   
          Debug.Print "SimpleVar: " & item.m_Txt & " = " & item.m_Value
'          If item.m_Txt = "ALLOWBREAKINTOCODE" Then
'            Debug.Print "gaga"
'          End If
          If DBFieldItemExists(rs, item.m_Txt) Then
            'If UCase(item.m_Value) = "WAHR" Or UCase(item.m_Value) = "TRUE" Then
            If IsTrue(item.m_Value) Then
              rs.Fields(item.m_Txt).value = 1
            'ElseIf UCase(item.m_Value) = "FALSCH" Or UCase(item.m_Value) = "FALSE" Then
            ElseIf IsFalse(item.m_Value) Then
              rs.Fields(item.m_Txt).value = 0
            ElseIf rs.Fields(item.m_Txt).Type = 11 And item.m_Value = "" Then
              rs.Fields(item.m_Txt).value = 0
            ElseIf rs.Fields(item.m_Txt).Type = 131 Then
              rs.Fields(item.m_Txt).value = IIf(item.m_Value = "", 0, item.m_Value)
            Else
              rs.Fields(item.m_Txt).value = item.m_Value
            End If
          End If
        Case "XLScriptVar"
          Debug.Print TypeName(item), item.m_SortName
      End Select
      i = i + 1
    Next item
  End If
  
  rs.Update
  rs.Close
  Set rs = Nothing
  
  riskrs.Close
  Set riskrs = Nothing
  
  rsecc.Fields("LetzterScan").value = nowdate
  
  If FileExists(theFilename) Then
    rsecc.Fields("Dateidatum").value = MyFileDateTime(theFilename)
  End If

  If analyseWarErfolgreich Then
    rsecc.Fields("CheckerVersion").value = MyACCVersion
    rsecc.Fields("ScanRisiko").value = CDbl(XLScriptGetSimpleVar("TotalRisk").m_Value)
    rsecc.Fields("ECCFormelnGesamt").value = XLScriptGetSimpleVar("FORMULAAMOUNT").m_Value
    rsecc.Fields("ECCFormelnIndividuell").value = XLScriptGetSimpleVar("FORMULAINDIVAMOUNT").m_Value
    rsecc.Fields("Checksumme").value = Mid(XLScriptGetSimpleVar("CHECKSUM").m_Value, 2)
    
    If Not XLScriptGetSimpleVar("AUTHOR") Is Nothing Then
      rsecc.Fields("Ersteller").value = Left(XLScriptGetSimpleVar("AUTHOR").m_Value, 24)
    Else
      rsecc.Fields("Ersteller").value = ""
    End If
    If Not XLScriptGetSimpleVar("CREATIONDATE") Is Nothing Then
      d = IIf(IsDate(XLScriptGetSimpleVar("CREATIONDATE").m_Value) = True, XLScriptGetSimpleVar("CREATIONDATE").m_Value, DateSerial(1900, 1, 1))
      If d < #1/1/1900# Then d = #1/1/1900#
      rsecc.Fields("Erstellungsdatum").value = d
    Else
      rsecc.Fields("Erstellungsdatum").value = DateSerial(1900, 1, 1)
    End If
    
    If theTrackerFreigabe = True Then
      Dim ok As Boolean
      ok = True
      If (rsecc.Fields("Risikowert").value >= GetValueFromField(rsParam, "DateienVersionierenAbRisk", 1) And GetValueFromField(rsParam, "DateienVersionierenAbRisk", 1) <> -1) Or _
        GetValueFromField(rsParam, "EincheckenBeiPrgfreigabe", False) <> False Then
          ok = CheckInFile(rsecc, theTrackerFreigabeDatum)
      End If
      
      If ok Then
        ' Neu, der Checker setzt auch die Freigaben!
        G_Conn.Execute "DELETE FROM idvDateienFreigaben WHERE idvDateiID=" & theidvDateiID & " AND Version = " & rsecc.Fields("Version")
  '      G_Conn.Execute "Insert into idvDateienFreigaben (idvDateiID,Version,Datum,FreigebenderUser,Kommentar,Status,FreigabeChecksumme,CCEmpfaenger) Values( " & theidvDateiID & _
  '        ", '" & rsecc.Fields("Version") & "', '" & theTrackerFreigabeDatum & "', '" & theFreigabeuser & "', '" & theFreigabekommentar & "', '0', '" & XLScriptGetSimpleVar("CHECKSUM").m_Value & "', '" & theFreigabeCCListe & "')"
        
  '      G_Conn.Execute "Insert into idvDateienFreigaben (idvDateiID,Version,Datum,FreigebenderUser,Kommentar,Status,FreigabeChecksumme,CCEmpfaenger) Values( '" & theidvDateiID & _
  '        "', '" & rsecc.Fields("Version") & "', '" & Format(theTrackerFreigabeDatum, "YYYY-MM-DD hh:mm:ss") & "', '" & theFreigabeuser & "', '" & theFreigabekommentar & "', '0', '" & Mid(XLScriptGetSimpleVar("CHECKSUM").m_Value, 2) & "', '" & theFreigabeCCListe & "')"
        
        Dim trs As Object
        Set trs = OpenRS("SELECT * FROM idvDateienFreigaben WHERE idvDateiID=" & theidvDateiID & " AND Version = " & rsecc.Fields("Version").value, G_Conn, MYadOpenDynamic, MYadLockOptimistic)
        If trs Is Nothing Then
          ok = False
        Else
          If trs.EOF Then
            trs.AddNew
            trs.Fields("idvDateiID").value = theidvDateiID
            trs.Fields("Version").value = rsecc.Fields("Version").value
            ' Major/Minor
            trs.Fields("MajorVersion").value = rsecc.Fields("MajorVersion").value
            trs.Fields("MinorVersion").value = rsecc.Fields("MinorVersion").value
            ' Freigabe Initiierung speichern
            trs.Fields("FreigabeInitiierung").value = rsecc.Fields("FreigabeInitiierung").value
            trs.Fields("FreigabeInitiierendeUser").value = Left(UCase(GetSafeFieldPlus(rsecc, "SpeichernderUserLogonID", "")), 24)
          End If
          trs.Fields("Datum").value = theTrackerFreigabeDatum
          trs.Fields("FreigebenderUser").value = Left(UCase(theFreigabeuser), 50)
          trs.Fields("Kommentar").value = theFreigabekommentar
          trs.Fields("Status").value = 0
          trs.Fields("FreigabeChecksumme").value = Mid(XLScriptGetSimpleVar("CHECKSUM").m_Value, 2)
          trs.Fields("CCEmpfaenger").value = ""
          trs.Update
          trs.Close
        End If
        Set trs = Nothing
        
        If ok Then
            rsecc.Fields("FreigabeChecksumme").value = Mid(XLScriptGetSimpleVar("CHECKSUM").m_Value, 2)
            rsecc.Fields("FreigabeStatus").value = 2
            rsecc.Fields("FreigabeidvDateiID").value = theidvDateiID
            rsecc.Fields("FreigabeVersion").value = rsecc.Fields("Version")
            
            SaveSetting _
               appname:="Stromwerken", _
               Section:=ProgNameShort, _
               Key:="FreigabeErteilt", _
               setting:=1
            'AddStatus "Freigabe erfolgreich durchgef|fffd|hrt!"
            AddStatus FMT0("ACC_1")
            StoreUserCommunicateValue "FG", "1"
        Else
            'AddStatus "Freigabe nicht erfolgreich!"
            AddStatus FMT0("ACC_2")
            StoreUserCommunicateValue "FG", "0"
        End If
      Else
        'AddStatus "Freigabe nicht erfolgreich!"
        AddStatus FMT0("ACC_2")
        StoreUserCommunicateValue "FG", "0"
      End If
    ElseIf theTrackerFreigabe = True And analyseWarErfolgreich = False Then
        'AddStatus "Freigabe nicht erfolgreich!"
        AddStatus FMT0("ACC_2")
        StoreUserCommunicateValue "FG", "0"
    End If
  End If
  
  rsecc.Update
  
nogo:
  If Err.Number <> 0 Then
    DebugPrint DebType.tERROR, "XLStoreValsToDB: " & Err.Number & " - " & Err.Description
    Err.Clear
  End If
On Error Resume Next

  CloseRs rsecc
  CloseRs rsParam
  CloseRs rsLib
  
  LogPrint "XLACCStoreValsToDB-Finished"
  
End Sub

Sub CloseRs(ByRef rs)
On Error Resume Next
  If rs.EditMode <> 0 Then
    rs.CancelUpdate
  End If
  rs.Close
  Set rs = Nothing
End Sub


Attribute VB_Name = "AboutDlg"
Attribute VB_Base = "0{A6B64E8E-63AE-45F9-A56A-14921C092CF7}{473FED3F-7440-4306-AB3C-C72E30E35856}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Private Sub CommandButton1_Click()
    AboutDlg.Hide
End Sub

Private Sub Label3_Click()
  On Error Resume Next
  'Call Shell("explorer.exe http://www.stromwerken.de", 1)
  Call Shell("explorer.exe " & FMT0("INETLINK_1"), 1)
End Sub

Private Sub UserForm_Initialize()
  gTranslation.TranslateForm Me
End Sub
Attribute VB_Name = "AccContainer"
Option Explicit

Const L_Backcol As Long = 34

Sub PrintAccessContainer(ByRef ws As Worksheet, ByRef c As Range)

  On Error GoTo 0
  Dim MyLastTime As Date
  MyLastTime = Now

  Dim y As Long
  Dim x As Long
  
  y = c.Row
  x = c.Column
  
  Dim fld As XLFld
  
  If Not CollectionObjectExists(m_Flds, "AllPermissionsDatabaseDoc") Then
    c.value = "Missing Def AllPermissionsDatabaseDoc"
    Exit Sub
  End If

  Set fld = m_Flds("AllPermissionsDatabaseDoc")
  
  Dim cnt As Long
  cnt = 0
  
  Dim ccontainer As Container
  ws.Range(ws.Cells(y, x), ws.Cells(y, x + 8)).Font.Bold = True
  ws.Range(ws.Cells(y, x), ws.Cells(y, x + 8)).Interior.ColorIndex = L_Backcol
  ws.Cells(y, x).value = FMT0("ACCCONTAINER_3")
  y = y + 1
  
  For Each ccontainer In m_DB.Containers
    ws.Cells(y, x).value = ccontainer.name
    ws.Cells(y, x).Font.ColorIndex = 3
    ws.Cells(y, x).Font.Bold = True
    y = y + 1
    
    ws.Cells(y, x + 1).value = "Owner"
    ws.Cells(y, x + 2).value = "UserName"
    ws.Cells(y, x + 3).value = "AllPermissions"
    ws.Cells(y, x + 4).value = "Permissions"
    ws.Cells(y, x + 5).value = "Inherit"
    ws.Range(ws.Cells(y, x + 1), ws.Cells(y, x + 8)).Font.Bold = True
    ws.Range(ws.Cells(y, x + 1), ws.Cells(y, x + 8)).Interior.ColorIndex = L_Backcol
    ws.Cells(y, x + 2).value = "UserName"
    y = y + 1
    
    ws.Cells(y, x + 1).value = ccontainer.Owner
    ws.Cells(y, x + 2).value = ccontainer.UserName
    ws.Cells(y, x + 3).value = GetBitfieldResult(fld, ccontainer.AllPermissions, ",n")
    ws.Cells(y, x + 4).value = ccontainer.Permissions
    ws.Cells(y, x + 5).value = ccontainer.Inherit
    FrameIt ws, y, x + 1, x + 8
    y = y + 2
    
    ws.Cells(y, x + 2).value = "Document"
    ws.Range(ws.Cells(y, x + 2), ws.Cells(y, x + 8)).Font.Bold = True
    ws.Range(ws.Cells(y, x + 2), ws.Cells(y, x + 8)).Interior.ColorIndex = L_Backcol
    y = y + 1
    
    Dim Doc As Document
    For Each Doc In ccontainer.Documents
      ws.Cells(y, x + 2).value = Doc.name
      ws.Cells(y, x + 2).Font.Bold = True
      y = y + 1
    
      ws.Cells(y, x + 3).value = FMT0("ACCCONTAINER_1") ' Eigenschaft
      ws.Cells(y, x + 4).value = FMT0("ACCCONTAINER_2") ' Wert
      ws.Cells(y, x + 5).value = FMT0("ACCCONTAINER_1") ' Eigenschaft
      ws.Cells(y, x + 6).value = FMT0("ACCCONTAINER_2") ' Wert
      ws.Cells(y, x + 7).value = FMT0("ACCCONTAINER_1") ' Eigenschaft
      ws.Cells(y, x + 8).value = FMT0("ACCCONTAINER_2") ' Wert
      ws.Range(ws.Cells(y, x + 3), ws.Cells(y, x + 8)).Font.Bold = True
      ws.Range(ws.Cells(y, x + 3), ws.Cells(y, x + 8)).Interior.ColorIndex = L_Backcol
      y = y + 1
    
      Dim tx As Long
      tx = 0
      
      Dim prop As Property
      For Each prop In Doc.Properties
        ws.Cells(y, x + 3 + tx).value = prop.name
'        If prop.name = "NameMap" Then
'          Debug.Print "gaga"
'        End If
        ws.Cells(y, x + 4 + tx).value = "'" & ItemGetValue(prop)
        tx = tx + 2
        If tx = 6 Then
          tx = 0
          FrameIt ws, y, x + 3, x + 8
          y = y + 1
        End If
      Next prop
      If tx <> 0 Then
        FrameIt ws, y, x + 3, x + 8
      End If
      y = y + 1
    Next Doc
    y = y + 1
    cnt = cnt + 1
    If MyLastTime + TimeValue("0:00:02") < Now Then
      'UpdateStatus "Generiere Ergebnisbatt " & m_WS.name & " - " & cnt & " / " & ref.count
      UpdateStatus FMT3("XLSCRIPT_14", ws.name, cnt, m_DB.Containers.count)
      MyLastTime = Now
    End If
    If Beenden Then Exit Sub
  Next ccontainer
  
  'UpdateStatus "Generiere Ergebnisbatt " & m_WS.name & " - " & cnt & " / " & ref.count
  UpdateStatus FMT3("XLSCRIPT_14", ws.name, cnt, m_DB.Containers.count)
  
nogo:
  Set fld = Nothing
End Sub

Private Sub FrameIt(ByRef ws As Worksheet, ByVal y As Long, ByVal x1 As Long, ByVal x2 As Long)
    With ws.Range(ws.Cells(y, x1), ws.Cells(y, x2)).Borders(xlEdgeLeft)
        .LineStyle = xlContinuous
'        .ColorIndex = xlAutomatic
'        .TintAndShade = 0
        .Weight = xlHairline
    End With
    With ws.Range(ws.Cells(y, x1), ws.Cells(y, x2)).Borders(xlEdgeTop)
        .LineStyle = xlContinuous
        .Weight = xlHairline
    End With
    With ws.Range(ws.Cells(y, x1), ws.Cells(y, x2)).Borders(xlEdgeBottom)
        .LineStyle = xlContinuous
        .Weight = xlHairline
    End With
    With ws.Range(ws.Cells(y, x1), ws.Cells(y, x2)).Borders(xlEdgeRight)
        .LineStyle = xlContinuous
        .Weight = xlHairline
    End With
End Sub

Function ItemGetValue(ByRef p) As String
  On Error Resume Next
  ItemGetValue = p.value
End Function
Attribute VB_Name = "BitteWarten"
Attribute VB_Base = "0{F70E086A-B9DA-45C1-96B1-A49E6CEE6085}{6D873356-27D8-4080-BF8B-E0EE4CA90B97}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit


Private Sub UserForm_Activate()
  'Me.Hinweistext = "Suche nach Access 97..."
  Me.Hinweistext = FMT0("BW_3")
  DoEvents
  MainMenu.V8.Enabled = CheckAccessVersion(8)
  'Me.Hinweistext = "Suche nach Access 2000..."
  Me.Hinweistext = FMT0("BW_4")
  DoEvents
  MainMenu.V9.Enabled = CheckAccessVersion(9)
  'Me.Hinweistext = "Suche nach Access 2002/XP..."
  Me.Hinweistext = FMT0("BW_5")
  DoEvents
  MainMenu.V10.Enabled = CheckAccessVersion(10)
  'Me.Hinweistext = "Suche nach Access 2003..."
  Me.Hinweistext = FMT0("BW_6")
  DoEvents
  MainMenu.V11.Enabled = CheckAccessVersion(11)
  DoEvents
  MainMenu.V12.Enabled = CheckAccessVersion(12)
  DoEvents
  MainMenu.V14.Enabled = CheckAccessVersion(14)
  DoEvents
  MainMenu.V15.Enabled = CheckAccessVersion(15)
  DoEvents
  MainMenu.V16.Enabled = CheckAccessVersion(16)
  DoEvents
  Me.Hide
End Sub

Private Sub UserForm_Initialize()
  gTranslation.TranslateForm Me
End Sub
Attribute VB_Name = "CAppCommand"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public m_Command As String
Public m_ParameterString As String
Public m_Parameter As Collection


Sub Init(ByVal cmdstring As String)
  Dim pos As Long
  pos = InStr(cmdstring, " ")
  If pos > 0 Then
    m_Command = UCase(Trim(Left(cmdstring, pos - 1)))
    m_ParameterString = Trim(Mid(cmdstring, pos + 1, 10000))
  Else
    m_Command = UCase(Trim(cmdstring))
  End If
  Set m_Parameter = New Collection
End Sub

Sub AddParameter(ByVal partype As Long, ByVal parname As String, ByVal paroptional)
  Dim cacp As New CAppCommandParameter
  cacp.Init partype, parname, paroptional
  m_Parameter.Add cacp
End Sub

Function CheckValues(ByRef errString As String) As Boolean

  Dim parstring As String
  parstring = m_ParameterString
  
  Dim cacp As CAppCommandParameter
  For Each cacp In m_Parameter
    cacp.CheckValue parstring, errString
  Next cacp
    
  If Len(Trim(parstring)) > 0 Then
    errString = errString & IIf(errString <> "", vbCrLf, "") & "Unbekannte oder nicht erlaubte Parameter '" & parstring & "'"
  End If
  
  If errString <> "" Then
    errString = "Error in Command '" & m_Command & "': " & errString
  End If
  
End Function

Function GetValue(ByRef parname As String) As Variant
  Dim cacp As CAppCommandParameter
  For Each cacp In m_Parameter
    If cacp.m_Name = parname Then
      GetValue = cacp.m_Value
      Exit Function
    End If
  Next cacp
  GetValue = ""
End Function

Function ParameterExists(ByRef parname As String) As Boolean
  Dim cacp As CAppCommandParameter
  For Each cacp In m_Parameter
    If cacp.m_Name = parname Then
      If cacp.m_Found Then
        ParameterExists = True
      End If
      Exit Function
    End If
  Next cacp
  ParameterExists = False
End Function


Attribute VB_Name = "CAppCommandParameter"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public m_Type As Long
Public m_Optional As Boolean
Public m_Name As String
Public m_Value As String
Public m_Found As Boolean

Public Sub Init(ByVal partype As Long, ByVal parname As String, ByVal paroptional As Boolean)
  m_Type = partype
  m_Name = UCase(parname)
  m_Optional = paroptional
End Sub

Function CheckValue(ByRef parstring As String, ByRef errString As String) As Boolean
  Dim startPos As Long
  Dim pos As Long
  Dim s As String
  Dim ts As String
  Dim tPos As Long
  
  If InStr(parstring, m_Name) > 0 Then
    CheckValue = True
    startPos = InStr(UCase(parstring), m_Name)
    pos = startPos + Len(m_Name)
    s = GetNextValue(parstring, pos, " ")
    
    Dim ok As Boolean
    Select Case m_Type
      Case 0    ' Kein Wert
        m_Found = True
      Case vbInteger
        If IsNumeric(s) Then
          m_Value = s
          m_Found = True
        Else
          errString = errString & IIf(errString <> "", vbCrLf, "") & "Der Wert '" & s & "' in " & m_Name & " ist nicht numerisch!"
          CheckValue = False
        End If
      Case vbTime
        ok = True
        If Not IsDate(s) Then
          ok = False
        End If
        
        If ok Then
          tPos = InStr(s, " ")
          If tPos > 0 Then
            s = Trim(Mid(s, tPos + 1))
          End If
          ts = s
          If Len(ts) <> 8 Then ok = False
          If ok Then If Mid(ts, 3, 1) <> ":" Then ok = False
          If ok Then If Mid(ts, 6, 1) <> ":" Then ok = False
          If ok Then
            If IsNumeric(Val(Mid(ts, 1, 2))) Then
              If Val(Mid(ts, 1, 2)) < 0 Or Val(Mid(ts, 1, 2)) > 23 Then ok = False
            Else
              ok = False
            End If
          End If
          If ok Then
            If IsNumeric(Val(Mid(ts, 4, 2))) Then
              If Val(Mid(ts, 4, 2)) < 0 Or Val(Mid(ts, 4, 2)) > 59 Then ok = False
            Else
              ok = False
            End If
          End If
          If ok Then
            If IsNumeric(Val(Mid(ts, 7, 2))) Then
              If Val(Mid(ts, 7, 2)) < 0 Or Val(Mid(ts, 7, 2)) > 59 Then ok = False
            Else
              ok = False
            End If
          End If
        End If
        
        If ok Then
          m_Value = s
          m_Found = True
        Else
          errString = errString & IIf(errString <> "", vbCrLf, "") & "Der Wert '" & s & "' in " & m_Name & " ist keine Uhrzeit (hh:mm:ss)!"
          CheckValue = False
        End If
      
      Case vbString
        m_Value = s
        m_Found = True
'        Else
'          errString = errString & IIf(errString <> "", vbCrLf, "") & "Der Wert '" & S & "' in " & m_Name & " ist keine String!"
'          CheckValue = False
'        End If
    
      Case vbDate
        If IsDate(s) Then
          m_Value = s
          m_Found = True
        Else
          errString = errString & IIf(errString <> "", vbCrLf, "") & "Der Wert '" & s & "' in " & m_Name & " ist keine Datum!"
          CheckValue = False
        End If
      
      Case Else
        MsgBox "UNDEFINED TYPE in CAppCommandParameter.CheckValue"
    End Select
    Dim newparstring As String
    If startPos > 1 Then
      newparstring = Left(parstring, startPos - 1)
    End If
    If pos < Len(parstring) Then
      newparstring = newparstring & Mid(parstring, pos)
    End If
    parstring = newparstring
  End If

  If m_Found = False And errString = "" And m_Optional = False Then
    CheckValue = False
    errString = errString & IIf(errString <> "", vbCrLf, "") & "Der Parameter " & m_Name & " wurde nicht angegeben, ist aber erforderlich!"
  End If

End Function


Attribute VB_Name = "CfgReader"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Dim m_Lines As Collection
Dim m_Sec As Collection

Private Function GetNextLine(ByRef s As String) As String

    Dim rs As String
    Do
        rs = GetLine(s)
        If Len(Trim(rs)) > 0 Then
            GetNextLine = Trim(rs)
            Exit Function
        End If
        If Len(Trim(s)) <= 0 Then
            GetNextLine = ""
            s = ""
            Exit Function
        End If
    Loop
End Function


Public Sub GetCFGString(ByVal txt As String)
    If m_Lines Is Nothing Then
      Set m_Lines = New Collection
      Set m_Sec = New Collection
    End If
    If Len(txt) = 0 Then Exit Sub
    Dim s As String
    Do
        s = GetNextLine(txt)
        If Len(s) <= 0 Then Exit Do
        If UCase(Left(s, 9)) = "MERGECFG " Then
          GetCfgUniversal Mid(s, 10)
        Else
          If Len(Trim(s)) > 0 Then
            m_Lines.Add s
          End If
          m_Sec.Add s
        End If
    Loop
End Sub

Function GetCfgUTF8(fname As String) As Boolean
  On Error GoTo couldntOpenFile
    Dim adoStream As Object
    Set adoStream = CreateObject("ADODB.Stream")
    
    adoStream.Charset = "UTF-8"
    adoStream.Open
    adoStream.LoadFromFile fname
    GetCFGString adoStream.ReadText
    adoStream.Close
    Set adoStream = Nothing
    GetCfgUTF8 = True
    Exit Function

couldntOpenFile:
  GetCfgUTF8 = False

End Function

Private Function GetEncodingString(encoding As Long) As String
    Select Case encoding
    Case CP_ACP: GetEncodingString = "ANSI"
    Case CP_UTF8: GetEncodingString = "UTF8"
    Case CP_UTF16_LE: GetEncodingString = "UTF16 LE"
    Case CP_UTF16_BE: GetEncodingString = "UTF16 BE"
    Case CP_UTF32_LE: GetEncodingString = "UTF32 LE"
    Case CP_UTF32_BE: GetEncodingString = "UTF32 BE"
    Case Else: GetEncodingString = "Codepage " & CStr(encoding)
    End Select
End Function

Private Function GetCfgUniversal(fname As String) As Boolean
  On Error GoTo couldntOpenFile
    'Dim ff As Long
    'ff = FreeFile
    'Call OpenForInput(fname, ff, encoding)
    Dim encoding As Long
    Dim fileContents As String
    Dim bom As Boolean
    fileContents = GetContents(fname, encoding, -1, bom)
    DebugPrint tInfo, fname & " opened with encoding: " & GetEncodingString(encoding) & IIf(bom, " BOM", " no BOM")
    
    Call GetCFGString(fileContents)
    GetCfgUniversal = True
    
    Exit Function

couldntOpenFile:
  GetCfgUniversal = False
End Function

Function GetCfg(fname As String) As Boolean
  On Error GoTo couldntOpenFile
  
  Set m_Lines = New Collection
  Set m_Sec = New Collection
  Call GetCfgUniversal(fname)
  
  GetCfg = True
  Exit Function
couldntOpenFile:
  GetCfg = False
End Function

Function GetSection(sec As String) As Boolean
  Set m_Sec = New Collection
  GetSection = GetSectionValues(sec, m_Sec)
End Function

Function GetValue(s As String) As String
  Dim i As Long
  If m_Sec Is Nothing Then Exit Function
  For i = 1 To m_Sec.count
    If Left(m_Sec(i), Len(s) + 1) = s & "=" Then
      GetValue = Trim(Mid(m_Sec(i), Len(s) + 2))
      Exit Function
    ElseIf Left(m_Sec(i), Len(s) + 1) = s & " " Then
        Dim pos As Long
        pos = InStr(m_Sec(i), "=")
        If pos > 0 Then
            GetValue = Trim(Mid(m_Sec(i), pos + 1))
            Exit Function
        End If
    End If
  Next i
  GetValue = ""
End Function

Function GetSectionValues(sec As String, ByRef c As Collection) As Boolean
  Set c = New Collection
  Dim i As Long
  Dim found As Boolean
  found = False
  If Not m_Lines Is Nothing Then
    For i = 1 To m_Lines.count
      If m_Lines(i) = "[" & sec & "]" Then
        i = i + 1
        Do While i <= m_Lines.count
          If Left(m_Lines(i), 1) <> "[" Then
            c.Add m_Lines(i)
            found = True
            i = i + 1
          Else
            Exit Do
          End If
        Loop
      End If
      If i > m_Lines.count Then Exit For
    Next i
  End If
  GetSectionValues = found
End Function


Attribute VB_Name = "Check"
Option Explicit

Public Const SHOW_GVAR As Boolean = False
Public G_VarNames As Collection

Public UseDefinedDesc As Boolean

Dim EmptyList As Variant
Dim QueryDefFields As Variant
Dim RelationFields As Variant
Dim TableElementProperties As Variant
Dim FormControlNegProperties As Variant
'Dim FormProperties As Variant
Dim FormNegProperties As Variant

Dim ExtrudeModules As Integer
Dim ExtrudeTables As Integer
Dim ExtrudeRelations As Integer
Dim ExtrudeQueries As Integer
Dim ExtrudeFormModules As Integer
Dim ExtrudeForms As Integer
Dim ExtrudeScripts As Integer

Dim LogFilename As String
Dim CurrentObject As String
Dim ErrorFileOpen As Boolean
Dim temppath As String


Dim StartTime
Dim StartDate
Dim ProgStartTime
Dim LastTime

Dim TotalTicks As Double
Dim Ticks As Double
Dim LastTicks As Double

Dim count As Long
Dim Totalamount As Long

Const ModuleTicks = 500
Const FormModuleTicks = 645.1
Const TableIndexesTicks = 28
Const TablePropertiesTicks = 0.28
Const TableFieldTicks = 0.28

' Const FormPropertiesTicks = 13
Const FormNegPropertiesTicks = 70.58
Const FormControlPropertiesTicks = 47.18

Const QueryPropertyTicks = 110
Const QueryFieldTicks = 110
Const QueryParameterTicks = 40
Const ScriptTicks = 2

Const QueryDefFieldsSize = 2
Const RelationFieldsSize = 3
Const TableElementPropertiesSize = 9
Const FormControlNegPropertiesSize = 17
Const FormNegPropertiesSize = 36
' Const FormPropertiesSize = 86

Const RelationMul = 1

Global Const ChecksumMod As Long = &H100000


Dim MyEventCount As Integer


Public m_ResultWorkbook As Excel.Workbook
Dim m_Status As String

Dim m_VarGroups As Collection
Dim m_FN As Collection
Dim m_WS As Worksheet

Dim m_ConnectedDBs As Collection

#If VBA7 Then
Private Declare PtrSafe Function SetKeyboardState _
    Lib "user32" _
    (lppbKeyState As Any) _
    As Long
    
Private Declare PtrSafe Function GetKeyboardState _
    Lib "user32" (pbKeyState As Any) _
    As Long

Private Declare PtrSafe Function GetWindowThreadProcessId _
    Lib "user32" _
    (ByVal hwnd As LongPtr, _
    lpdwProcessId As Long) _
    As Long

Private Declare PtrSafe Function AttachThreadInput _
    Lib "user32" _
    (ByVal idAttach As Long, _
    ByVal idAttachTo As Long, _
    ByVal fAttach As Long) _
    As Long

Private Declare PtrSafe Function SetForegroundWindow _
    Lib "user32" _
    (ByVal hwnd As LongPtr) _
    As Long

Private Declare PtrSafe Function SetFocusAPI _
    Lib "user32" Alias "SetFocus" _
    (ByVal hwnd As LongPtr) _
    As Long
#Else
Private Declare Function SetKeyboardState _
    Lib "user32" _
    (lppbKeyState As Any) _
    As Long
    
Private Declare Function GetKeyboardState _
    Lib "user32" (pbKeyState As Any) _
    As Long

Private Declare Function GetWindowThreadProcessId _
    Lib "user32" _
    (ByVal hwnd As Long, _
    lpdwProcessId As Long) _
    As Long

Private Declare Function AttachThreadInput _
    Lib "user32" _
    (ByVal idAttach As Long, _
    ByVal idAttachTo As Long, _
    ByVal fAttach As Long) _
    As Long

Private Declare Function SetForegroundWindow _
    Lib "user32" _
    (ByVal hwnd As Long) _
    As Long

Private Declare Function SetFocusAPI _
    Lib "user32" Alias "SetFocus" _
    (ByVal hwnd As Long) _
    As Long
#End If

Private Const VK_SHIFT = &H10
Private Const VK_LSHIFT = &HA0
Private Const VK_RSHIFT = &HA1


Function AddChecksumCollectionRelation(ff As Integer, ByRef checksum As Long, ByRef col As Variant, ByRef xlsarr As XLScriptArray2D, txtExtension As String) As Long
  On Error Resume Next
  Dim tChecksum As Long
  tChecksum = 0
  Dim item
  For Each item In col
'    Debug.Print item.name, CStr(item)
     tChecksum = (tChecksum + AddChecksumRelation(ff, checksum, item, xlsarr, txtExtension)) Mod ChecksumMod
  Next item
  AddChecksumCollectionRelation = tChecksum
  Exit Function
nogo:
  Resume Next
End Function


Function AddChecksumRelation(ff As Integer, ByRef checksum As Long, ByRef ctrl As Variant, Optional ByRef xlsarr As XLScriptArray2D = Nothing, Optional txtExtension As String = "", Optional alternativerName As String = "") As Long
  On Error Resume Next
  
  Dim item
  Dim tChecksum As Long
  tChecksum = 0
  
  If alternativerName = "" Then
    alternativerName = ctrl.name
  End If
  
  For Each item In ctrl.Properties
'    Debug.Print item.name, CStr(item)
    tChecksum = (tChecksum + AddChecksum(checksum, CStr(item), txtExtension & alternativerName & "." & item.name, ff)) Mod ChecksumMod
  Next item
  
  If Not xlsarr Is Nothing Then
    xlsarr.AddLine alternativerName
    xlsarr.AddVar "NAME", alternativerName
    xlsarr.AddVar "FULLNAME", txtExtension & alternativerName
    xlsarr.AddVar "CHECKSUM", CStr("h" & Hex(tChecksum))
  End If
  
  AddChecksumRelation = tChecksum
  
  Exit Function
nogo:
  Resume Next
End Function


Function AddChecksumCollection(ff As Integer, ByRef checksum As Long, ByRef col As Variant, ByRef xlsarr As XLScriptArray2D, txtExtension As String) As Long
  On Error Resume Next
  Dim item
  Dim tChecksum As Long
  tChecksum = 0

'Debug.Print "AddChecksumCollection 0 - " & Time
  For Each item In col
    tChecksum = (tChecksum + AddChecksumControl(ff, checksum, item, xlsarr, txtExtension)) Mod ChecksumMod
  Next item
  
  AddChecksumCollection = tChecksum
  
'Debug.Print "AddChecksumCollection 1 - " & Time
  Exit Function
nogo:
  Resume Next
End Function


Function AddChecksumControl(ff As Integer, ByRef checksum As Long, ByRef ctrl As Variant, Optional ByRef xlsarr As XLScriptArray2D = Nothing, Optional txtExtension As String = "", Optional alternativerName As String = "") As Long
  On Error Resume Next
  
  Dim item
  Dim tChecksum As Long
  tChecksum = 0
  
  If alternativerName = "" Then
    alternativerName = ctrl.name
  End If
  
  If SHOW_GVAR Then
    If G_VarNames Is Nothing Then
      Set G_VarNames = New Collection
    End If
  End If
  
'  Dim ff
'  ff = FreeFile
'  Open "D:\Temp\" & ctrl.name & ".prop.txt" For Output As #ff
  
' Debug.Print "AddChecksumControl 0 - " & Time
' Dim t
' t = Time
  For Each item In ctrl.Properties
  
'    Print #ff, item.name
'    Print #ff, "     " & CStr(item)
  
    Select Case item.name
      Case "LastUpdated"
      Case "Hwnd"
      Case "LogicalPageWidth"
      Case "PrtMip"
      Case "PrtDevMode"
      Case "PrtDevNames"
      Case "PrtDevModeW"
      Case "Properties"
      Case "NameMap"
      Case "GUID"
      Case "Attributes"
      Case "RecordCount"
      Case "ListWidth"
      Case "ColumnWidths"
      Case "ColumnWidth"
      Case "WindowWidth"
      Case "WindowHeight"
      Case "InsideWidth"
      Case "InsideHeight"
      Case "WindowTop"
      Case "WindowLeft"
      Case "Width"
      Case "Height"
      Case "Top"
      Case "Left"

      Case "ConflictTable"
      Case "ReplicaFilter"
      Case "PartialReplica"
      Case "AlternateBackShade", "AlternateBackThemeColorIndex", "AlternateBackTint"
      Case "BackColor", "BackShade", "BackStyle", "BackThemeColorIndex", "BackTint"
      Case "BorderColor", "BorderLineStyle", "BorderShade", "BorderStyle", "BorderThemeColorIndex", "BorderTint", "BorderWidth", "BottomMargin", "BottomPadding"
      Case "Count", "CurrentSectionLeft", "CurrentSectionTop", "CurrentView", "DatasheetAlternateBackColor", "DatasheetBackColor", "DatasheetBackShade", "DatasheetBackThemeColorIndex", "DatasheetBackTint", "DatasheetBorderLineStyle"
      Case "DatasheetColumnHeaderUnderlineStyle", "DatasheetFontHeight", "DatasheetFontItalic", "DatasheetFontName", "DatasheetFontUnderline", "DatasheetFontWeight", "DatasheetForeColor", "DatasheetForeShade", "DatasheetForeThemeColorIndex", "DatasheetForeTint", "DatasheetGridlinesBehavior", "DatasheetGridlinesColor", "DatasheetGridlinesShade", "DatasheetGridlinesThemeColorIndex", "DatasheetGridlinesTint", "FastLaserPrinting"
      Case "FontBold", "FontItalic", "FontName", "FontSize", "FontUnderline", "FontWeight", "ForeColor", "ForeShade", "ForeThemeColorIndex", "ForeTint"
      Case "GridX", "GridY", "GridlineColor", "GridlineShade", "GridlineStyleBottom", "GridlineStyleLeft", "GridlineStyleRight", "GridlineStyleTop", "GridlineThemeColorIndex", "GridlineTint", "GridlineWidthBottom", "GridlineWidthLeft", "GridlineWidthRight", "GridlineWidthTop"
      Case "HorizontalDatasheetGridlineStyle", "HoverColor", "HoverForeColor", "HoverForeShade", "HoverForeThemeColorIndex", "HoverForeTint", "HoverShade", "HoverThemeColorIndex", "HoverTint"
      Case "ImageHeight", "ImageWidth", "InSelection", "Item"
      Case "KeyPreview", "KeyboardLanguage", "Layout", "LayoutForPrint", "LayoutID", "LeftMargin", "LeftPadding"
      Case "ListCount", "ListIndex", "ListItemsEditForm", "ListRows", "LpOleObject", "ObjectPalette", "ObjectVerbsCount", "OldBorderStyle", "OpenArgs", "OptionValue", "OrdinalPosition", "OriginalValue", "PageIndex", "PaintPalette", "Painting", "PaletteSource", "Picture", "PictureAlignment", "PictureCaptionArrangement", "PictureData", "PicturePalette", "PictureSizeMode", "PictureTiling", "PictureType"
      Case "PressedColor", "PressedForeColor", "PressedForeShade", "PressedForeThemeColorIndex", "PressedForeTint", "PressedShade", "PressedThemeColorIndex", "PressedTint", "PrtDevNamesW", "QuickStyle", "QuickStyleMask", "RightMargin", "RightPadding", "RowEnd", "RowHeight", "SaveSplitterBarPosition"
      Case "Section", "SelHeight", "SelLeft", "SelLength", "SelStart", "SelText", "SelTop", "SelWidth", "Shadow", "Shape", "Size", "SizeMode", "SmartTags", "SoftEdges", "SpecialEffect", "SplitFormDatasheet", "SplitFormOrientation", "SplitFormPrinting", "SplitFormSize", "SplitFormSplitterBar", "StatusBarText", "Style", "SubdatasheetExpanded", "SubdatasheetHeight", "TabFixedHeight", "TabFixedWidth", "TabIndex", "TabStop"
      Case "TextAlign", "TextFontCharSet", "TextFormat", "ThemeFontIndex", "ThemeName", "TimerInterval", "TopMargin", "TopPadding", "Transparent", "UseDefaultPaperSize", "UseTheme", "Value", "Vertical", "VerticalAnchor", "VerticalDatasheetGridlineStyle", "VisibleValue", "WaitForPostProcessing"

      ' BIS hier hin wir NIX gemacht!!!
      
      Case "Action", "AfterDelConfirm", "AfterDelConfirmEmMacro", "AfterFinalRender", "AfterFinalRenderEmMacro", "AfterInsert", "AfterInsertEmMacro", "AfterLayout", "AfterLayoutEmMacro", "AfterRender", "AfterRenderEmMacro", "AfterUpdate", "AfterUpdateEmMacro", "AggregateType", "Alignment", "AllowAdditions", "AllowAutoCorrect", "AllowDatasheetView", "AllowDeletions", "AllowDesignChanges", "AllowEditing", "AllowEdits", "AllowFilters", "AllowFormView", "AllowLayoutView", "AllowPivotChartView", "AllowPivotTableView", "AllowUpdating", "AllowValueListEdits", "AllowZeroLength", "AppendOnly", "AutoActivate", "AutoCenter", "AutoExpand", "AutoRepeat", "AutoResize", "AutoTab", "BeforeDelConfirm", "BeforeDelConfirmEmMacro", "BeforeInsert", "BeforeInsertEmMacro", "BeforeQuery"
        tChecksum = (tChecksum + AddChecksum(checksum, CStr(item), txtExtension & alternativerName & "." & item.name, ff)) Mod ChecksumMod
      Case "BeforeQueryEmMacro", "BeforeRender", "BeforeRenderEmMacro", "BeforeScreenTip", "BeforeScreenTipEmMacro", "BeforeUpdate", "BeforeUpdateEmMacro", "Bevel", "BoundColumn", "CanGrow", "CanShrink", "Cancel", "Caption", "Class", "CloseButton", "CollatingOrder", "ColumnCount", "ColumnEnd", "ColumnHeads", "ColumnHidden", "ColumnOrder", "ColumnStart", "CommandBeforeExecuteEmMacro", "CommandCheckedEmMacro", "CommandEnabledEmMacro", "CommandExecuteEmMacro", "ConditionalFormat", "ConditionalFormat14", "Connect", "ControlBox", "ControlSource", "ControlTipText", "ControlType", "CurrencyLCID", "CursorOnHover", "Custom", "Cycle", "DataChangeEmMacro", "DataEntry", "DataSetChangeEmMacro", "DataUpdatable"
        tChecksum = (tChecksum + AddChecksum(checksum, CStr(item), txtExtension & alternativerName & "." & item.name, ff)) Mod ChecksumMod
      Case "DatasheetCaption", "DatasheetCellsEffect", "DateCreated", "DecimalPlaces", "Default", "DefaultEditing", "DefaultValue", "DefaultView", "DisplayAsHyperlink", "DisplayControl", "DisplayOnSharePointSite", "DisplayType", "DisplayViewsOnSharePointSite", "DisplayWhen", "DividingLines", "Enabled", "EnterKeyBehavior", "EventProcPrefix", "Expression"
        tChecksum = (tChecksum + AddChecksum(checksum, CStr(item), txtExtension & alternativerName & "." & item.name, ff)) Mod ChecksumMod
      Case "FetchDefaults", "FieldSize", "Filter", "FilterLookup", "FilterOn", "FilterOnEmptyMaster", "FilterOnLoad", "FitToScreen", "ForeignName", "ForeignTable", "Format", "FrozenColumns", "FuriganaControl", "Glow", "Gradient", "HasModule", "HelpContextId", "HelpFile", "HideNewField", "HorizontalAnchor"
        tChecksum = (tChecksum + AddChecksum(checksum, CStr(item), txtExtension & alternativerName & "." & item.name, ff)) Mod ChecksumMod
      Case "HyperlinkAddress", "HyperlinkBinderDescription", "HyperlinkSubAddress", "HyperlinkTarget", "IMEHold", "IMEMode", "IMESentenceMode", "ImageData", "InheritValueList", "InputMask", "IsHyperlink", "LimitToList", "LineSlant", "LineSpacing", "LinkChildFields", "LinkMasterFields", "Locked", "MaxButton", "MenuBar", "MinButton", "MinMaxButtons", "Modal", "MouseWheelEmMacro", "Moveable", "MultiRow", "MultiSelect", "Name", "NavigationButtons", "NavigationCaption", "NumeralShapes", "OLEClass", "OLEType", "OLETypeAllowed", "OnActivate", "OnActivateEmMacro", "OnApplyFilter", "OnApplyFilterEmMacro", "OnChange", "OnChangeEmMacro"
        tChecksum = (tChecksum + AddChecksum(checksum, CStr(item), txtExtension & alternativerName & "." & item.name, ff)) Mod ChecksumMod
      Case "OnClick", "OnClickEmMacro", "OnClose", "OnCloseEmMacro", "OnCmdBeforeExecute", "OnCmdChecked", "OnCmdEnabled", "OnCmdExecute", "OnConnect", "OnConnectEmMacro", "OnCurrent", "OnCurrentEmMacro", "OnDataChange", "OnDataSetChange", "OnDblClick", "OnDblClickEmMacro", "OnDeactivate", "OnDeactivateEmMacro", "OnDelete", "OnDeleteEmMacro", "OnDirty", "OnDirtyEmMacro", "OnDisconnect", "OnDisconnectEmMacro", "OnEnter", "OnEnterEmMacro", "OnError", "OnErrorEmMacro", "OnExit", "OnExitEmMacro", "OnFilter", "OnFilterEmMacro", "OnGotFocus", "OnGotFocusEmMacro", "OnKeyDown", "OnKeyDownEmMacro", "OnKeyPress", "OnKeyPressEmMacro", "OnKeyUp", "OnKeyUpEmMacro", "OnLoad", "OnLoadEmMacro", "OnLostFocus", "OnLostFocusEmMacro", "OnMouseDown", "OnMouseDownEmMacro", "OnMouseMove", "OnMouseMoveEmMacro", "OnMouseUp", "OnMouseUpEmMacro", "OnMouseWheel", "OnNotInList", "OnNotInListEmMacro", "OnOpen", "OnOpenEmMacro"
        tChecksum = (tChecksum + AddChecksum(checksum, CStr(item), txtExtension & alternativerName & "." & item.name, ff)) Mod ChecksumMod
      Case "OnPivotTableChange", "OnQuery", "OnResize", "OnResizeEmMacro", "OnSelectionChange", "OnTimer", "OnTimerEmMacro", "OnUndo", "OnUndoEmMacro", "OnUnload", "OnUnloadEmMacro", "OnUpdated", "OnUpdatedEmMacro", "OnViewChange", "OrderBy", "OrderByOn", "OrderByOnLoad", "Orientation", "PivotTableChangeEmMacro", "PopUp", "QueryEmMacro", "ReadingOrder", "RecordLocks", "RecordSelectors", "RecordSource", "RecordsetType", "Required", "ResultType"
        tChecksum = (tChecksum + AddChecksum(checksum, CStr(item), txtExtension & alternativerName & "." & item.name, ff)) Mod ChecksumMod
      Case "RibbonName", "RowSource", "RowSourceType", "RowStart", "ScrollBarAlign", "ScrollBars", "SelectionChangeEmMacro", "SeparatorCharacters", "ShortcutMenu", "ShortcutMenuBar", "ShowDatePicker", "ShowGrid", "ShowOnlyRowSourceValues", "ShowPageHeaderAndPageFooter", "SourceDoc", "SourceField", "SourceItem", "SourceObject", "SourceTable", "SourceTableName", "Table", "Tag", "Text"
        tChecksum = (tChecksum + AddChecksum(checksum, CStr(item), txtExtension & alternativerName & "." & item.name, ff)) Mod ChecksumMod
      Case "Toolbar", "TotalsRow", "TripleState", "Type", "UnicodeCompression", "Updatable", "UpdateOptions", "ValidateOnSet", "ValidationRule", "ValidationText", "VarOleObject", "Verb", "ViewChangeEmMacro", "ViewsAllowed", "Visible"
        tChecksum = (tChecksum + AddChecksum(checksum, CStr(item), txtExtension & alternativerName & "." & item.name, ff)) Mod ChecksumMod
      
      
      Case Else
        If SHOW_GVAR Then
          AddGVar item.name
        End If
    End Select
  Next item
'   If t - Time > 0 Then
'     Debug.Print "AddChecksumControl (" & ctrl.name & ") 1 - " & Time & " - " & t - Time
'   End If
  
  

   If Not xlsarr Is Nothing Then
     xlsarr.AddLine alternativerName
     xlsarr.AddVar "NAME", alternativerName
     xlsarr.AddVar "FULLNAME", txtExtension & alternativerName
     xlsarr.AddVar "CHECKSUM", CStr("h" & Hex(tChecksum))
   End If
  
    AddChecksumControl = tChecksum
  
  Exit Function
nogo:
  Resume Next
End Function

Sub AddGVar(ByVal varname As String)
On Error GoTo nogo
  If SHOW_GVAR Then
    If G_VarNames.count = 0 Then
      G_VarNames.Add varname, varname
    Else
      Dim i As Long
      Dim found As Boolean
      
      For i = 1 To G_VarNames.count
        If varname < G_VarNames(i) Then
          G_VarNames.Add varname, varname, i
          found = True
          Exit For
        End If
      Next i
      
      If Not found Then
        G_VarNames.Add varname, varname
      End If
      
    End If
  End If
nogo:
End Sub

Function AddChecksumAndVar(ff As Integer, n As String, ByRef checksum As Long, txt As String, ByRef xlsarr As XLScriptArray2D, txtExtension As String) As Long
  On Error Resume Next
  
  Dim item
  Dim tChecksum As Long
  tChecksum = AddChecksum(checksum, txt, txtExtension & "." & n, ff)

  xlsarr.AddLine n
  xlsarr.AddVar "NAME", n
  xlsarr.AddVar "FULLNAME", txtExtension & n
  xlsarr.AddVar "CHECKSUM", CStr("h" & Hex(tChecksum))
  
  AddChecksumAndVar = tChecksum
  
  Exit Function
nogo:
  Resume Next
End Function


Function AddChecksum(ByRef checksum As Long, txt As String, vName As String, ff As Integer) As Long
  Dim tChecksum As Long
  Dim counter As Long
  Dim l As Long
  
  l = Len(vName)
  If l > 0 Then
    For counter = 1 To l
      tChecksum = (tChecksum + CLng(Asc(Mid(vName, counter, 1))) * counter) Mod ChecksumMod
    Next counter
  End If
  
  l = Len(txt)
  If l > 0 Then
    For counter = 1 To l
      tChecksum = (tChecksum + CLng(Asc(Mid(txt, counter, 1))) * counter) Mod ChecksumMod
    Next counter
  End If

  checksum = (checksum + tChecksum) Mod ChecksumMod
  AddChecksum = tChecksum

  If ff <> -1 Then Print #ff, vName & "," & CStr("h" & Hex(tChecksum)) & "," & "|\_" & txt & "_/|"

End Function

Function AddToChecksum(hexstr As String, l As Long) As String

  Dim tChecksum As String
  tChecksum = CLng("&H" & hexstr)
  AddToChecksum = Hex((tChecksum + l) Mod ChecksumMod)

End Function



Public Sub Analyze(Filename As String, orifilename As String)
  
  ' XXX
  On Error GoTo handleError
  
  Dim checksum As Long
  checksum = 0
  
  Dim hadError As Boolean
  hadError = False
  
  StartTime = Time
  StartDate = Now
  StatusFormUpdate

  Set m_FN = New Collection
  
  If Not ReadGroups Then Exit Sub
  
  'LogPrintECCSCanLog theFilename & " (ID: " & theidvDateiID & ") - Starte Analyse", True
  'LogPrintECCSCanLog 0, 0, FMT2("CHECK_1", theFilename, theidvDateiID), True
  LogPrintECCSCanLog theidvDateiID, 0, "Starte Analyse: " & theFilename, True
  'AddStatus "Analysiere: " & orifilename
  AddStatus FMT1("CHECK_2", orifilename)
  'AddStatus "Initialisierung"
  AddStatus FMT0("CHECK_3")
    
  If AR_UseDB = False And G_CreateResfile <= 0 Then
    GenerateResultWorkbook m_ResultWorkbook
  
    If MainMenu.V8.value = True Then
      CreateAccessApp 8
      theAccessScannerVersion = 8
    ElseIf MainMenu.V9.value = True Then
      CreateAccessApp 9
      theAccessScannerVersion = 9
    ElseIf MainMenu.V10.value = True Then
      CreateAccessApp 10
      theAccessScannerVersion = 10
    ElseIf MainMenu.V11.value = True Then
      CreateAccessApp 11
      theAccessScannerVersion = 11
    ElseIf MainMenu.V12.value = True Then
      CreateAccessApp 12
      theAccessScannerVersion = 12
    ElseIf MainMenu.V14.value = True Then
      CreateAccessApp 14
      theAccessScannerVersion = 14
    ElseIf MainMenu.V15.value = True Then
      CreateAccessApp 15
      theAccessScannerVersion = 15
    ElseIf MainMenu.V16.value = True Then
      CreateAccessApp 16
      theAccessScannerVersion = 16
    End If
  Else
  
    If G_CreateResfile > 0 Then
      GenerateResultWorkbook m_ResultWorkbook
    End If
    
  
    If CheckAccessVersion(16) Then
      CreateAccessApp 16
      theAccessScannerVersion = 16
    ElseIf CheckAccessVersion(15) Then
      CreateAccessApp 15
      theAccessScannerVersion = 15
    ElseIf CheckAccessVersion(14) Then
      CreateAccessApp 14
      theAccessScannerVersion = 14
    ElseIf CheckAccessVersion(12) Then
      CreateAccessApp 12
      theAccessScannerVersion = 12
    ElseIf CheckAccessVersion(11) Then
      CreateAccessApp 11
      theAccessScannerVersion = 11
    ElseIf CheckAccessVersion(10) Then
      CreateAccessApp 10
      theAccessScannerVersion = 10
    ElseIf CheckAccessVersion(9) Then
      CreateAccessApp 9
      theAccessScannerVersion = 9
    ElseIf CheckAccessVersion(8) Then
      CreateAccessApp 8
      theAccessScannerVersion = 8
    Else
      Set m_ResultWorkbook = Nothing
      Exit Sub
    End If
  End If
  
'  Dim m_App As Object
'  Set m_App = CreateObject("Access.Application, 10")
  
  SetLiveStatus
  DoEvents
  
'  Dim adminPW As String
'  adminPW = InputBox("Bitte geben Sie, falls notwendig, das Administratorpasswort an:")


  ' Scriptengine initialisieren
  Dim tWB As Excel.Workbook
  
  If AR_UseDB Then
    StoreComm True
  End If

  SetLiveStatus
  
  XLScriptInitGlobals Application, m_ResultWorkbook


  
  'AddStatus "|fffd|ffne DB"
  AddStatus FMT0("CHECK_4")
  If Not OpenAnalyzeDB(Filename, orifilename) Then
    Set m_Workspace = Nothing
    Set m_DB = Nothing
    m_App.Quit
    Set m_App = Nothing
    AddStatus FMT1("CHECK_52", orifilename)
    hadError = True
    XLScriptAddSimpleVar "STATUS", FMT0("SCANERG_5")
    XLScriptAddSimpleVar "STATUSID", "5"
    'LogPrintECCSCanLog theFilename & " (ID: " & theidvDateiID & ") - Ergebnis: Datei konnte nicht ge|fffd|ffnet werden", True
    LogPrintECCSCanLog theidvDateiID, 5, "Ergebnis: Datei konnte nicht ge|fffd|ffnet werden", True
    GoTo closeStuff
  End If
  SetLiveStatus
  
  'AddStatus "Pr|fffd|fe Bypass"
'  AddStatus FMT0("CHECK_6")
'  If AccAppHasProperty(m_App, "AllowBypassKey") Then
'    If m_App.CurrentDb.Properties("AllowBypassKey") = False Then
'      m_App.CurrentDb.Properties("AllowBypassKey") = True
'      m_App.CloseCurrentDatabase
'      If Not OpenAnalyzeDB(Filename, orifilename) Then
'        m_App.Quit
'        Set m_App = Nothing
'        hadError = True
'        'LogPrintECCSCanLog theFilename & " (ID: " & theidvDateiID & ") - Ergebnis: Datei konnte nicht ge|fffd|ffnet werden", True
'        XLScriptAddSimpleVar "STATUS", FMT0("SCANERG_5")
'        XLScriptAddSimpleVar "STATUSID", "5"
'        LogPrintECCSCanLog theidvDateiID, 5, FMT2("CHECK_5", theFilename, theidvDateiID), True
'        GoTo closeStuff
'      End If
'    End If
'  End If
'  SetLiveStatus
  
  ' XXX
  m_App.Visible = True
  m_App.DoCmd.RunCommand 11 ' acCmdAppMinimize
  
  Set m_Workspace = m_App.DBEngine.Workspaces(0)
  
  Set m_ConnectedDBs = New Collection
    
  'AddStatus "Start"
  AddStatus FMT0("START_1")
  DoEvents
  
  ' -------------------------------------------
  ' Z|fffd|hler
  ' -------------------------------------------
  ' Anzahl Tabellen
  Dim totalTableAmount As Long
  totalTableAmount = 0
  
  Dim totalQueryAmount As Long
  totalQueryAmount = 0
  
  Dim totalFormAmount As Long
  totalFormAmount = 0
  
  Dim totalReportAmount As Long
  totalReportAmount = 0
  
  Dim totalScriptAmount As Long
  totalScriptAmount = 0
  
  Dim totalModuleAmount As Long
  totalModuleAmount = 0
  
  Dim VbaProtected As Long
  VbaProtected = 0
  
  Dim totalRestModuleAmount As Long
  totalRestModuleAmount = 0
  
  Dim totalClassModuleAmount As Long
  totalClassModuleAmount = 0
  
  Dim totalFormModuleAmount As Long
  totalFormModuleAmount = 0
  
  Dim totalReportModuleAmount As Long
  totalReportModuleAmount = 0
  
  Dim totalTableFieldAmount As Long
  totalTableFieldAmount = 0
  
  Dim totalReferencedTablesAmount As Long
  totalReferencedTablesAmount = 0
  
  Dim totalDatasetAmount As Long
  totalDatasetAmount = 0
  
  Dim totalIndicesAmount As Long
  totalIndicesAmount = 0
  
  Dim totalDatafieldAmount As Long
  totalDatafieldAmount = 0
  
  Dim totalControlsOnFormsAmount As Long
  totalControlsOnFormsAmount = 0
  
  Dim totalEditControlsOnFormsAmount As Long
  totalEditControlsOnFormsAmount = 0
  
  Dim totalProgramEditControlsOnFormsAmount As Long
  totalProgramEditControlsOnFormsAmount = 0
  
  Dim totalSubFormAmount As Long
  totalSubFormAmount = 0
  
  Dim totalVBALineAmount As Long
  totalVBALineAmount = 0
  
  Dim totalVBACommentsAmount As Long
  totalVBACommentsAmount = 0
  
  Dim totalTabelCommentAmount As Long
  totalTabelCommentAmount = 0
  
  Dim totalSQLCommentAmount As Long
  totalSQLCommentAmount = 0
  
  Dim totalFormCommentAmount As Long
  totalFormCommentAmount = 0
  
  Dim totalReportCommentAmount As Long
  totalReportCommentAmount = 0
  
  Dim totalScriptCommentAmount As Long
  totalScriptCommentAmount = 0
  
  Dim totalVBAModuleCommentAmount As Long
  totalVBAModuleCommentAmount = 0
  
  Dim totalScriptLineAmount As Long
  totalScriptLineAmount = 0
  
  Dim totalScriptCommentLinesAmount As Long
  totalScriptCommentLinesAmount = 0
  
  Dim totalReferencedDBAmount As Long
  totalReferencedDBAmount = 0
  
  Dim totalRelationFieldAmount As Long
  totalRelationFieldAmount = 0
  Dim totalActiveXAmount As Long
  totalActiveXAmount = 0
  
  Dim xlsarr As XLScriptArray
  Dim xlsv As XLScriptVar
  
  
  Dim xlsarrChecksum As XLScriptArray2D ' Tabellen, Formulare
  Dim xlsarrChecksumObjekt As XLScriptArray2D ' Objekte
  Dim xlsarrChecksumFld As XLScriptArray2D ' Felder
  
  ' -------------------------------------------
  ' -------------------------------------------
  
  
  ' Alle Namen besorgen
'  Set m_DB = OpenDatabase(m_AccFilename, , , "Access; pwd=" & adminPW)
  Set m_DB = m_App.DBEngine.Workspaces(0).Databases(0)
  
  If m_DB Is Nothing Then
    Set m_Workspace = Nothing
    Set m_DB = Nothing
    m_App.Quit
    
    XLScriptAddSimpleVar "STATUS", FMT0("SCANERG_5")
    XLScriptAddSimpleVar "STATUSID", "5"
    If AR_UseDB = False Then
        ' Datei %1 konnte nicht ge|fffd|ffnet werden, ggf. ist das Passwort falsch.
        MsgBox FMT1("CHECK_52", orifilename), vbCritical, FMT0("MAIN_1")
    Else
        LogPrintECCSCanLog theidvDateiID, 5, "Ergebnis: FEHLER: Datei Passwortgesch|fffd|tzt"
    End If
    
    GoTo closeStuff
  End If
  
  ' Tabellen
  ' Abfragen
  ' VBA
  ' Formulare
  ' Reports
  ' Gruppenberechtigungen
  ' Personenberechtigungen
  ' Scripte
  ' Ergebnistabellen * 2
  
  TotalTicks = 10
  
' DATABASE=database;
  Dim element
  Dim subelement
  Dim sub2element
  
  'AddStatus "Tiefenanalyse"
  AddStatus FMT0("CHECK_7")


'  Dim titem
'  For Each titem In m_DB.Containers!Tables.Documents
'    titem.UserName = "norman"
'    Debug.Print titem.name & " - " & titem.UserName & " - " & titem.Permissions
'    titem.UserName = "admin"
'    Debug.Print titem.name & " - " & titem.UserName & " - " & titem.Permissions
'  Next titem



  SetLiveStatus
  
  
  XLScriptAddSimpleVar "SAVEDATE", Format(MyFileDateTime(theFilename), "Short Date") & " - " & Format(MyFileDateTime(theFilename), "Short Time")
  XLScriptAddSimpleVar "FILESIZEKB", CLng(MyFileLen(theFilename) / 1024)
  XLScriptAddSimpleVar "FILESIZE", MyFileLen(theFilename)
  
  CheckLibs
  
  SetLiveStatus
  Dim ff As Integer
  ff = -1
  Dim tnow
  tnow = Now
  
  If G_LogPrintChecksum Then
    ff = FreeFile
    Open G_cfgLogpfad & "\" & GetFileNameAndExtension(orifilename) & "." & Format(year(tnow), "0000") & "-" & Format(month(tnow), "00") & "-" & Format(day(tnow), "00") & " " & Format(Hour(tnow), "00") & "_" & Format(Minute(tnow), "00") & "_" & Format(Second(tnow), "00") & ".chk.txt" For Output As #ff
  End If
  
  Set xlsarrChecksum = XLScriptAddArray2D("CHECKSUMARR")
  
  Set xlsarr = XLScriptAddArray("CONNECTEDDBS")
    
  ' ANALYSE
  
  LastTime = Time
  Ticks = 0
  LastTicks = 0
  
  ' -------------------------------------------
  
  ' -------------------------------------------
  ' Die Tabellen
  ' -------------------------------------------
  
  Dim i As Long
  Dim tableY As Long
  tableY = 2
'  GenerateSheet "Tabellen", m_ResultWorkbook
  
  StatusFormUpdate
  GetDefsAndResultsheets
  StatusFormUpdate
  
  Dim tChecksum As Long
  Dim item
  Dim x As Long
  Dim varGroupIdx As Long
  varGroupIdx = GetVarGroup("Tabellen")
  
  'AddStatus "Tabellen..."
  AddStatus FMT0("CHECK_8")
  If varGroupIdx > 0 Then
    '----------------------------------------------------------
    'SetStatus "Tabellen"
    SetStatus FMT0("CHECK_9")
    '----------------------------------------------------------
    Set xlsarrChecksumObjekt = xlsarrChecksum.AddXLScriptArray2D("Tabellen")
    
    x = 1
    For Each item In m_VarGroups(varGroupIdx).m_Vars
      SetLiveStatus
'      Workbooks(m_ResultWorkbook).Sheets("Tabellen").Cells(1, x) = item.m_Name
      If item.m_Type = "d" Then
'        Workbooks(m_ResultWorkbook).Sheets("Tabellen").Columns(x).NumberFormat = "d/m/yy;@"
      End If
      x = x + 1
    Next item
    ' ProgressForm.Status.Refresh
    For i = 0 To m_DB.TableDefs.count - 1
      StatusFormUpdate
      
      If GetSetting(appname:="Stromwerken", Section:="ACC", Key:="AbortAction", Default:="") <> "" Then
        SaveSetting appname:="Stromwerken", Section:="ACC", Key:="AbortAction", setting:=""
        Beenden = True
      End If
      If Beenden = True Then Exit For
      
      If m_DB.TableDefs(i).Attributes = 0 Then
        'UpdateStatus "Tabelle: " & m_DB.TableDefs(i).name
        UpdateStatus FMT1("CHECK_10", m_DB.TableDefs(i).name)
        AddChecksumControl ff, checksum, m_DB.TableDefs(i), xlsarrChecksumObjekt, "Tabelle."
        Set xlsarrChecksumFld = xlsarrChecksumObjekt.AddXLScriptArray2DToCurrentLine("OBJFIELDS")
'        AddChecksumCollection ff, checksum, m_DB.TableDefs(I).Fields, xlsarrChecksumFld, "Tabelle." & m_DB.TableDefs(I).name & "."
        tChecksum = AddChecksumCollection(ff, checksum, m_DB.TableDefs(i).Fields, Nothing, "Tabelle." & m_DB.TableDefs(i).name & ".")
        xlsarrChecksumObjekt.items(xlsarrChecksumObjekt.items.count)("CHECKSUM").SetValue "CHECKSUM", "h" & AddToChecksum(Mid(xlsarrChecksumObjekt.items(xlsarrChecksumObjekt.items.count)("CHECKSUM").Properties(1), 2), tChecksum)
        
        StatusFormUpdate
        
        totalTableAmount = totalTableAmount + 1
        totalTableFieldAmount = totalTableFieldAmount + m_DB.TableDefs(i).Fields.count
        
        Dim tCount As Long
        tCount = 0
        If m_DB.TableDefs(i).Fields.count > 0 Then
          Dim countRs As Recordset
          Set countRs = m_DB.OpenRecordset( _
            "SELECT Count([" & m_DB.TableDefs(i).Fields(0).name & "]) AS [CNT] FROM [" & _
            m_DB.TableDefs(i).name & "]" _
            )
          tCount = countRs("CNT")
          countRs.Close
          Set countRs = Nothing
        End If
        
        totalDatasetAmount = totalDatasetAmount + tCount
        totalIndicesAmount = totalIndicesAmount + m_DB.TableDefs(i).Indexes.count
        totalDatafieldAmount = totalDatafieldAmount + m_DB.TableDefs(i).Fields.count * tCount
      ElseIf (m_DB.TableDefs(i).Attributes And &H80000003) = 0 Then
        
        'UpdateStatus "Tabelle: " & m_DB.TableDefs(i).name
        UpdateStatus FMT1("CHECK_10", m_DB.TableDefs(i).name)
        AddChecksumControl ff, checksum, m_DB.TableDefs(i), xlsarrChecksumObjekt, "Tabelle."
      
        totalTableAmount = totalTableAmount + 1
        totalTableFieldAmount = totalTableFieldAmount + m_DB.TableDefs(i).Fields.count
        
        ' dbAttachedTable + dbAttachedExclusive + dbAttachedODBC + dbAttachSavePWD
        
        If (m_DB.TableDefs(i).Attributes And (&H40000000 + &H10000 + &H20000000 + &H20000)) <> 0 Then
          totalReferencedTablesAmount = totalReferencedTablesAmount + 1
          ' If Not ConnectExists(m_DB.TableDefs(I).Connect) Then
          '   totalReferencedDBAmount = totalReferencedDBAmount + 1
          ' End If
        End If
      End If
    Next
    Ticks = Ticks + 1 / m_DB.TableDefs.count
    UpdateStatusOLD
  Else
    Ticks = Ticks + 1
    UpdateStatusOLD
  End If
  TickDebug ("Tables")
  
'  Workbooks(m_ResultWorkbook).Sheets("Tabellen").Cells(1, 1).Select
'  Workbooks(m_ResultWorkbook).Sheets("Tabellen").Cells.EntireColumn.AutoFit
'  Workbooks(m_ResultWorkbook).Sheets("Tabellen").Cells.EntireRow.AutoFit
  
  '----------------------------------------------------------
  'SetStatus "Abfragen"
  SetStatus FMT0("CHECK_11")
  '----------------------------------------------------------
  ' ProgressForm.Status.Refresh
  If m_DB.QueryDefs.count > 0 Then
    Set xlsarrChecksumObjekt = xlsarrChecksum.AddXLScriptArray2D("SQLs")
    For i = 0 To m_DB.QueryDefs.count - 1
        
        If GetSetting(appname:="Stromwerken", Section:="ACC", Key:="AbortAction", Default:="") <> "" Then
          SaveSetting appname:="Stromwerken", Section:="ACC", Key:="AbortAction", setting:=""
          Beenden = True
        End If
        If Beenden = True Then Exit For
        
        If Left(m_DB.QueryDefs(i).name, 1) <> "~" Then
          AddChecksumAndVar ff, m_DB.QueryDefs(i).name, checksum, Replace(Replace(m_DB.QueryDefs(i).Sql, "[", ""), "]", ""), xlsarrChecksumObjekt, "SQL."
          totalQueryAmount = totalQueryAmount + 1
        End If
        Ticks = Ticks + 1 / m_DB.QueryDefs.count
      UpdateStatusOLD
    Next
  Else
    Ticks = Ticks + 1
    UpdateStatusOLD
  End If
  
  TickDebug ("Queries")
  
  '----------------------------------------------------------
  'SetStatus "VBA-Code"
  SetStatus FMT0("CHECK_12")
  '----------------------------------------------------------
  ' ProgressForm.Status.Refresh
  Dim mdl
  
  Set xlsarr = XLScriptAddArray("MODULES")
  
  Set xlsarrChecksumObjekt = Nothing
  If m_DB.Containers.count > 0 Then
    For Each element In m_DB.Containers
        
        If GetSetting(appname:="Stromwerken", Section:="ACC", Key:="AbortAction", Default:="") <> "" Then
          SaveSetting appname:="Stromwerken", Section:="ACC", Key:="AbortAction", setting:=""
          Beenden = True
        End If
        If Beenden = True Then Exit For
        
        Select Case element.name
          Case "Modules"
            If xlsarrChecksumObjekt Is Nothing Then
              Set xlsarrChecksumObjekt = xlsarrChecksum.AddXLScriptArray2D("VBA-Module")
            End If
            
            For Each subelement In element.Documents
              
              CurrentObject = subelement.name
              
  '            m_App.Application.SaveAsText acModule, subelement.name, G_cfgTemppfad & "\ACCExt-" & GetUserName & ".txt"
              
  '            Set xlsv = New XLScriptVar
  '            xlsv.Init
  '            Extract G_cfgTemppfad & "\ACCExt-" & GetUserName & ".txt", acModule, xlsv
              
  
              
  '            xlsarr.
              
              If PropertyNameExists(m_DB.Containers("Modules").Documents(subelement.name), "Description") Then
                If Len(Trim(m_DB.Containers("Modules").Documents(subelement.name).Properties("Description"))) >= 20 Then
                  totalVBAModuleCommentAmount = totalVBAModuleCommentAmount + 1
                End If
              End If
              
              m_App.DoCmd.OpenModule subelement.name
              Set mdl = m_App.Modules(subelement.name)
              mdl.Application.Visible = False
              
              If Not VBAModuleAccessable(mdl) Then
                VbaProtected = 1
              Else
                Select Case mdl.Type
                  Case 0 ' acStandardModule
                    totalModuleAmount = totalModuleAmount + 1
                  Case 1 ' acClassModule
                    totalClassModuleAmount = totalClassModuleAmount + 1
                  Case Else
                    totalRestModuleAmount = totalRestModuleAmount + 1
                End Select
                
                CountLOC ff, mdl, totalVBALineAmount, totalVBACommentsAmount, checksum, subelement.name, xlsarrChecksumObjekt, "VBA-Modul.", tChecksum
  '          AddChecksumAndVar m_DB.QueryDefs(I).name, checksum, m_DB.QueryDefs(I).Sql, xlsarrChecksumObjekt, "SQLs."
                
                ExtractModule mdl, True, subelement, "MDB"
              End If
              
              count = count + 1
              UpdateStatusOLD
              StatusFormUpdate
              Set mdl = Nothing
            Next
        End Select
      Ticks = Ticks + 1 / m_DB.Containers.count
      UpdateStatusOLD
    Next
  Else
    Ticks = Ticks + 1
    UpdateStatusOLD
  End If
  
  
  
  '----------------------------------------------------------
  'SetStatus "Formulare und Formular-VBA-Module"
  SetStatus FMT0("CHECK_48")
  '----------------------------------------------------------
  ' ProgressForm.Status.Refresh
  'AddStatus "Formulare..."
  AddStatus FMT0("CHECK_13")
  Set xlsarrChecksumObjekt = Nothing
  If m_DB.Containers.count > 0 Then
    For Each element In m_DB.Containers
      
      If GetSetting(appname:="Stromwerken", Section:="ACC", Key:="AbortAction", Default:="") <> "" Then
        SaveSetting appname:="Stromwerken", Section:="ACC", Key:="AbortAction", setting:=""
        Beenden = True
      End If
      If Beenden = True Then Exit For
      
      Select Case element.name
        Case "Forms"
          If xlsarrChecksumObjekt Is Nothing Then
            Set xlsarrChecksumObjekt = xlsarrChecksum.AddXLScriptArray2D("Formulare")
          End If
          For Each subelement In element.Documents
            'UpdateStatus "Formular: " & subelement.name
            UpdateStatus FMT1("CHECK_47", subelement.name)
          
            totalFormAmount = totalFormAmount + 1
            
            If PropertyNameExists(m_DB.Containers("Forms").Documents(subelement.name), "Description") Then
              If Len(Trim(m_DB.Containers("Forms").Documents(subelement.name).Properties("Description"))) >= 20 Then
                totalFormCommentAmount = totalFormCommentAmount + 1
              End If
            End If
            
            CurrentObject = subelement.name
            If Not IsMde(m_App) Then
              m_App.DoCmd.OpenForm CurrentObject, 1 ' acDesign
              totalControlsOnFormsAmount = totalControlsOnFormsAmount + m_App.FORMS(subelement.name).Controls.count
              
              AddChecksumControl ff, checksum, m_App.FORMS(subelement.name), xlsarrChecksumObjekt, "Formular."
              Set xlsarrChecksumFld = xlsarrChecksumObjekt.AddXLScriptArray2DToCurrentLine("OBJFIELDS")
  '            AddChecksumCollection ff, checksum, m_App.FORMS(subelement.name).Controls, xlsarrChecksumFld, "Formular." & subelement.name & "."
              tChecksum = AddChecksumCollection(ff, checksum, m_App.FORMS(subelement.name).Controls, Nothing, "Formular." & subelement.name & ".")
              xlsarrChecksumObjekt.items(xlsarrChecksumObjekt.items.count)("CHECKSUM").SetValue "CHECKSUM", "h" & AddToChecksum(Mid(xlsarrChecksumObjekt.items(xlsarrChecksumObjekt.items.count)("CHECKSUM").Properties(1), 2), tChecksum)
            
              Dim controlItem ' As Control
              For Each controlItem In m_App.FORMS(subelement.name).Controls
                
  '              AddChecksumControl checksum, controlItem
                
                Select Case controlItem.controltype
                  Case 112 ' acSubform
                    totalSubFormAmount = totalSubFormAmount + 1
                  
                  ' acOptionButton, acCheckBox, acOptionGroup, acTextBox, acListBox, acComboBox, acToggleButton
                  Case 105, 106, 107, 109, 110, 111, 122
                    If Len(controlItem.ControlSource) > 0 And Left(controlItem.ControlSource, 1) <> "=" Then
                      totalEditControlsOnFormsAmount = totalEditControlsOnFormsAmount + 1
                    Else
                      totalProgramEditControlsOnFormsAmount = totalProgramEditControlsOnFormsAmount + 1
                    End If
                  Case 119
                    totalActiveXAmount = totalActiveXAmount + 1
                End Select
              Next controlItem
              Set mdl = m_App.FORMS(CurrentObject).Module
              mdl.Application.Visible = False
  '            ExtractModule mdl, True, subelement, "MDB"
              If CountLOC(ff, mdl, totalVBALineAmount, totalVBACommentsAmount, checksum, "*VBA-Modul", xlsarrChecksumFld, "Formular." & subelement.name & ".", tChecksum) > 0 Then
                totalFormModuleAmount = totalFormModuleAmount + 1
              End If
              xlsarrChecksumObjekt.items(xlsarrChecksumObjekt.items.count)("CHECKSUM").SetValue "CHECKSUM", "h" & AddToChecksum(Mid(xlsarrChecksumObjekt.items(xlsarrChecksumObjekt.items.count)("CHECKSUM").Properties(1), 2), tChecksum)
            End If
            count = count + 1
            UpdateStatusOLD
            Set mdl = Nothing
                  
            ' Das Formular selbst
'            ExtractProperties m_App.Forms(subelement.name).Properties, _
'              m_App.Forms(subelement.name).name, _
'              FormNegProperties, "FORM", True
            
            
            UpdateStatusOLD
            
            ' und die controls
            If Not IsMde(m_App) Then
            Dim frm
            Set frm = m_App.FORMS(CurrentObject)
'            ExtractFormControls (frm)
            m_App.DoCmd.Close 2, CurrentObject ' acForm
            Set frm = Nothing
            End If
            UpdateStatusOLD
          Next
      End Select
      Ticks = Ticks + 1 / m_DB.Containers.count
      UpdateStatusOLD
    Next
  Else
    Ticks = Ticks + 1
    UpdateStatusOLD
  End If

  TickDebug ("Modules")
  '----------------------------------------------------------
  'SetStatus "Reports und Report-VBA-Module"
  SetStatus FMT0("CHECK_49")
  '----------------------------------------------------------
  ' ProgressForm.Status.Refresh
  'AddStatus "Reports und VBA-Module..."
  AddStatus FMT0("CHECK_14")
  Set xlsarrChecksumObjekt = Nothing
  If m_DB.Containers.count > 0 Then
    For Each element In m_DB.Containers
      
      If GetSetting(appname:="Stromwerken", Section:="ACC", Key:="AbortAction", Default:="") <> "" Then
        SaveSetting appname:="Stromwerken", Section:="ACC", Key:="AbortAction", setting:=""
        Beenden = True
      End If
      If Beenden = True Then Exit For
      
      Select Case element.name
        Case "Reports"
          If xlsarrChecksumObjekt Is Nothing Then
            Set xlsarrChecksumObjekt = xlsarrChecksum.AddXLScriptArray2D("Reports")
          End If
          For Each subelement In element.Documents
            'UpdateStatus "Report: " & subelement.name
            UpdateStatus FMT1("CHECK_15", subelement.name)
            totalReportAmount = totalReportAmount + 1
            
            If PropertyNameExists(m_DB.Containers("Reports").Documents(subelement.name), "Description") Then
              If Len(Trim(m_DB.Containers("Reports").Documents(subelement.name).Properties("Description"))) >= 20 Then
                totalReportCommentAmount = totalReportCommentAmount + 1
              End If
            End If
            
            CurrentObject = subelement.name
            If Not IsMde(m_App) Then
            m_App.DoCmd.OpenReport CurrentObject, 1 'acDesign
            
            AddChecksumControl ff, checksum, m_App.Reports(CurrentObject), xlsarrChecksumObjekt, "Report."
            Set xlsarrChecksumFld = xlsarrChecksumObjekt.AddXLScriptArray2DToCurrentLine("OBJFIELDS")
'            AddChecksumCollection ff, checksum, m_App.Reports(CurrentObject).Controls, xlsarrChecksumFld, "Report." & subelement.name & "."
            tChecksum = AddChecksumCollection(ff, checksum, m_App.Reports(CurrentObject).Controls, Nothing, "Report." & subelement.name & ".")
            xlsarrChecksumObjekt.items(xlsarrChecksumObjekt.items.count)("CHECKSUM").SetValue "CHECKSUM", "h" & AddToChecksum(Mid(xlsarrChecksumObjekt.items(xlsarrChecksumObjekt.items.count)("CHECKSUM").Properties(1), 2), tChecksum)
            
'            For Each controlItem In m_App.Reports(CurrentObject).Controls
'              AddChecksumControl checksum, controlItem
'            Next controlItem
            
            If m_App.Reports(CurrentObject).hasmodule Then
              Set mdl = m_App.Reports(CurrentObject).Module
              mdl.Application.Visible = False
              If CountLOC(ff, mdl, totalVBALineAmount, totalVBACommentsAmount, checksum, "*VBA-Modul", xlsarrChecksumFld, "Report." & subelement.name & ".", tChecksum) > 0 Then
                totalReportModuleAmount = totalReportModuleAmount + 1
              End If
              xlsarrChecksumObjekt.items(xlsarrChecksumObjekt.items.count)("CHECKSUM").SetValue "CHECKSUM", "h" & AddToChecksum(Mid(xlsarrChecksumObjekt.items(xlsarrChecksumObjekt.items.count)("CHECKSUM").Properties(1), 2), tChecksum)
              ExtractModule mdl, True, subelement, "MDB"
            End If
'            ExtractModule mdl, True, subelement, "MDB"
            count = count + 1
            UpdateStatusOLD
            Set mdl = Nothing
                  
            ' Das Formular selbst
'            ExtractProperties m_App.Forms(subelement.name).Properties, _
'              m_App.Forms(subelement.name).name, _
'              FormNegProperties, "FORM", True
            
            UpdateStatusOLD
            
            ' und die controls
            Dim rpt
            Set rpt = m_App.Reports(CurrentObject)
'            ExtractFormControls (frm)
            m_App.DoCmd.Close 3, CurrentObject ' acReport
            Set rpt = Nothing
            End If
            UpdateStatusOLD
          Next
      End Select
      Ticks = Ticks + 1 / m_DB.Containers.count
      UpdateStatusOLD
    Next
  Else
    Ticks = Ticks + 1
    UpdateStatusOLD
  End If


  TickDebug ("Permissions")
  Dim lngExecute As Long, lngReadDef As Long, _
   lngWritedef As Long, lngReadData As Long, lngUpdateData As Long, lngDeleteData As Long, _
   lngInsertData As Long, lngDBAdmin As Long, lngDBExclusive As Long
  Dim perm As Long
  
  '----------------------------------------------------------
  'SetStatus "Extracting group permissions"
  SetStatus FMT0("CHECK_16")
  '----------------------------------------------------------
  Set xlsarr = XLScriptAddArray("GROUPPERMISSIONS")

  If m_Workspace.Groups.count > 0 Then
    For Each element In m_Workspace.Groups
      
      If GetSetting(appname:="Stromwerken", Section:="ACC", Key:="AbortAction", Default:="") <> "" Then
        SaveSetting appname:="Stromwerken", Section:="ACC", Key:="AbortAction", setting:=""
        Beenden = True
      End If
      If Beenden = True Then Exit For
      
      For Each subelement In m_DB.Containers
        For Each sub2element In subelement.Documents
          If Left(sub2element.name, 1) <> "~" Then
            perm = GetPermission(element.name, CStr(subelement.name), sub2element.name)
            Set xlsv = New XLScriptVar
            xlsv.Init "PermissionGroupObject: " & sub2element.name
            xlsv.Properties.Add element.name, "GROUP"
            xlsv.Properties.Add subelement.name, "OBJECTTYPE"
            xlsv.Properties.Add sub2element.name, "OBJECTNAME"
            
            GetFlags subelement.name, _
              lngExecute, _
              lngReadDef, _
              lngWritedef, _
              lngReadData, _
              lngUpdateData, _
              lngDeleteData, _
              lngInsertData, _
              lngDBAdmin, _
              lngDBExclusive
            
            ' dbSecFullAccess
            xlsv.Properties.Add IIf((perm And 1048575) = 1048575, "X", "'-"), "FULLACCESS"
            
            xlsv.Properties.Add IIf(lngExecute > 0, IIf((perm And lngExecute) = lngExecute, "X", "'-"), " "), "EXECUTEOPEN"
            xlsv.Properties.Add IIf(lngReadDef > 0, IIf((perm And lngReadDef) = lngReadDef, "X", "'-"), " "), "READDEF"
            xlsv.Properties.Add IIf(lngWritedef > 0, IIf((perm And lngWritedef) = lngWritedef, "X", "'-"), " "), "WRITEDEF"
            xlsv.Properties.Add IIf(lngReadData > 0, IIf((perm And lngReadData) = lngReadData, "X", "'-"), " "), "READDATA"
            If FullVersion = False Then
              xlsv.Properties.Add "Demo", "UPDATEDATA"
              xlsv.Properties.Add "Demo", "DELETEDATA"
            Else
              xlsv.Properties.Add IIf(lngUpdateData > 0, IIf((perm And lngUpdateData) = lngUpdateData, "X", "'-"), " "), "UPDATEDATA"
              xlsv.Properties.Add IIf(lngDeleteData > 0, IIf((perm And lngDeleteData) = lngDeleteData, "X", "'-"), " "), "DELETEDATA"
            End If
            xlsv.Properties.Add IIf(lngInsertData > 0, IIf((perm And lngInsertData) = lngInsertData, "X", "'-"), " "), "INSERTDATA"
            xlsv.Properties.Add IIf(lngDBAdmin > 0, IIf((perm And lngDBAdmin) = lngDBAdmin, "X", "'-"), " "), "DBADMIN"
            xlsv.Properties.Add IIf(lngDBExclusive > 0, IIf((perm And lngDBExclusive) = lngInsertData, "X", "'-"), " "), "DBEXCLUSIVE"
            
            xlsarr.AddXLScriptVar xlsv
          End If
        Next sub2element
        Ticks = Ticks + 1 / (m_Workspace.Groups.count * m_DB.Containers.count)
        UpdateStatusOLD
      Next subelement
    Next element
  Else
    Ticks = Ticks + 1
    UpdateStatusOLD
  End If


  '----------------------------------------------------------
  'SetStatus "Extracting user permissions"
  SetStatus FMT0("CHECK_17")
  '----------------------------------------------------------
  Set xlsarr = XLScriptAddArray("USERPERMISSIONS")

  If m_Workspace.Users.count > 0 Then
    For Each element In m_Workspace.Users
      
      If GetSetting(appname:="Stromwerken", Section:="ACC", Key:="AbortAction", Default:="") <> "" Then
        SaveSetting appname:="Stromwerken", Section:="ACC", Key:="AbortAction", setting:=""
        Beenden = True
      End If
      If Beenden = True Then Exit For
      
      For Each subelement In m_DB.Containers
        For Each sub2element In subelement.Documents
          If Left(sub2element.name, 1) <> "~" Then
            perm = GetPermission(element.name, CStr(subelement.name), sub2element.name)
            Set xlsv = New XLScriptVar
            xlsv.Init "PermissionGroupObject: " & sub2element.name
            xlsv.Properties.Add element.name, "GROUP"
            xlsv.Properties.Add subelement.name, "OBJECTTYPE"
            xlsv.Properties.Add sub2element.name, "OBJECTNAME"
            
            GetFlags subelement.name, _
              lngExecute, _
              lngReadDef, _
              lngWritedef, _
              lngReadData, _
              lngUpdateData, _
              lngDeleteData, _
              lngInsertData, _
              lngDBAdmin, _
              lngDBExclusive
            
            ' dbSecFullAccess
            xlsv.Properties.Add IIf((perm And 1048575) = 1048575, "X", "'-"), "FULLACCESS"
            
            xlsv.Properties.Add IIf(lngExecute > 0, IIf((perm And lngExecute) = lngExecute, "X", "'-"), " "), "EXECUTEOPEN"
            xlsv.Properties.Add IIf(lngReadDef > 0, IIf((perm And lngReadDef) = lngReadDef, "X", "'-"), " "), "READDEF"
            xlsv.Properties.Add IIf(lngWritedef > 0, IIf((perm And lngWritedef) = lngWritedef, "X", "'-"), " "), "WRITEDEF"
            xlsv.Properties.Add IIf(lngReadData > 0, IIf((perm And lngReadData) = lngReadData, "X", "'-"), " "), "READDATA"
            If FullVersion = False Then
              xlsv.Properties.Add "Demo", "UPDATEDATA"
              xlsv.Properties.Add "Demo", "DELETEDATA"
            Else
              xlsv.Properties.Add IIf(lngUpdateData > 0, IIf((perm And lngUpdateData) = lngUpdateData, "X", "'-"), " "), "UPDATEDATA"
              xlsv.Properties.Add IIf(lngDeleteData > 0, IIf((perm And lngDeleteData) = lngDeleteData, "X", "'-"), " "), "DELETEDATA"
            End If
            xlsv.Properties.Add IIf(lngInsertData > 0, IIf((perm And lngInsertData) = lngInsertData, "X", "'-"), " "), "INSERTDATA"
            xlsv.Properties.Add IIf(lngDBAdmin > 0, IIf((perm And lngDBAdmin) = lngDBAdmin, "X", "'-"), " "), "DBADMIN"
            xlsv.Properties.Add IIf(lngDBExclusive > 0, IIf((perm And lngDBExclusive) = lngInsertData, "X", "'-"), " "), "DBEXCLUSIVE"
            
            xlsarr.AddXLScriptVar xlsv
          End If
        Next sub2element
        Ticks = Ticks + 1 / (m_Workspace.Users.count * m_DB.Containers.count)
        UpdateStatusOLD
      Next subelement
    Next element
  Else
    Ticks = Ticks + 1
    UpdateStatusOLD
  End If


  TickDebug ("Modules")
  
  '----------------------------------------------------------
  'SetStatus "Extracting scripts"
  SetStatus FMT0("CHECK_18")
  '----------------------------------------------------------
  ' ProgressForm.Status.Refresh
  
  Set xlsarr = XLScriptAddArray("MACROS")
  Set xlsarrChecksumObjekt = Nothing
  If m_DB.Containers.count > 0 Then
    For Each element In m_DB.Containers
      
      If GetSetting(appname:="Stromwerken", Section:="ACC", Key:="AbortAction", Default:="") <> "" Then
        SaveSetting appname:="Stromwerken", Section:="ACC", Key:="AbortAction", setting:=""
        Beenden = True
      End If
      If Beenden = True Then Exit For
      
      Select Case element.name
        Case "Scripts"
          If xlsarrChecksumObjekt Is Nothing Then
            Set xlsarrChecksumObjekt = xlsarrChecksum.AddXLScriptArray2D("Makros")
          End If
          tChecksum = 0
          
          For Each subelement In element.Documents
            CurrentObject = subelement.name
            totalScriptAmount = totalScriptAmount + 1
            
            If PropertyNameExists(m_DB.Containers("Scripts").Documents(subelement.name), "Description") Then
              If Len(Trim(m_DB.Containers("Scripts").Documents(subelement.name).Properties("Description"))) >= 20 Then
                totalScriptCommentAmount = totalScriptCommentAmount + 1
              End If
            End If
            
            m_App.Application.SaveAsText 4, subelement.name, G_cfgTemppfad & "\ACCExt-" & GetUserName & ".txt"  ' acMacro
            
            Set xlsv = New XLScriptVar
            xlsv.Init "Macro: " & subelement.name
            xlsv.Properties.Add subelement.name, "NAME"
            xlsv.Properties.Add "MACRO", "TYPE"
            xlsarr.AddXLScriptVar xlsv
            Extract ff, G_cfgTemppfad & "\ACCExt-" & GetUserName & ".txt", 4, xlsv, totalScriptLineAmount, totalScriptCommentLinesAmount, checksum, subelement.name, xlsarrChecksumObjekt, "Makro."  ' acMacro
'            xlsarrChecksumObjekt.items(xlsarrChecksumObjekt.items.count)("CHECKSUM").SetValue "CHECKSUM", "h" & AddToChecksum(Mid(xlsarrChecksumObjekt.items(xlsarrChecksumObjekt.items.count)("CHECKSUM").Properties(1), 2), tChecksum)
            
            count = count + 1
            UpdateStatusOLD
            Set mdl = Nothing
          Next
      End Select
      Ticks = Ticks + 1 / m_DB.Containers.count
      UpdateStatusOLD
    Next
  Else
    Ticks = Ticks + 1
    UpdateStatusOLD
  End If
    
  TickDebug ("Scripts")
  
  
  ' ----------------------------------
  ' Relationsfelder Z|fffd|hlen
  ' ----------------------------------
  Set xlsarrChecksumObjekt = xlsarrChecksum.AddXLScriptArray2D("Beziehungen")
  'AddStatus "Beziehungen..."
  AddStatus FMT0("CHECK_19")
  If m_DB.Relations.count > 0 Then
    For Each element In m_DB.Relations
      
      If GetSetting(appname:="Stromwerken", Section:="ACC", Key:="AbortAction", Default:="") <> "" Then
        SaveSetting appname:="Stromwerken", Section:="ACC", Key:="AbortAction", setting:=""
        Beenden = True
      End If
      If Beenden = True Then Exit For
      
      'UpdateStatus "Beziehung: " & element.Table & "->" & element.ForeignTable
      UpdateStatus FMT2("CHECK_20", element.Table, element.ForeignTable)
      totalRelationFieldAmount = totalRelationFieldAmount + element.Fields.count
      Ticks = Ticks + 1 / m_DB.Relations.count
'      AddChecksumControl checksum, element
      
      AddChecksumControl ff, checksum, element, xlsarrChecksumObjekt, "Beziehung.", element.Table & "->" & element.ForeignTable & "." & IIf(InStrRev(element.name, ".") > 0, Mid(element.name, InStrRev(element.name, ".") + 1), element.name)
      Set xlsarrChecksumFld = xlsarrChecksumObjekt.AddXLScriptArray2DToCurrentLine("OBJFIELDS")
'      AddChecksumCollectionRelation ff, checksum, element.Fields, xlsarrChecksumFld, "Beziehung." & element.Table & "->" & element.ForeignTable & "."
      tChecksum = AddChecksumCollectionRelation(ff, checksum, element.Fields, Nothing, "Beziehung." & element.Table & "->" & element.ForeignTable & "." & IIf(InStrRev(element.name, ".") > 0, Mid(element.name, InStrRev(element.name, ".") + 1), element.name) & ".")
      xlsarrChecksumObjekt.items(xlsarrChecksumObjekt.items.count)("CHECKSUM").SetValue "CHECKSUM", "h" & AddToChecksum(Mid(xlsarrChecksumObjekt.items(xlsarrChecksumObjekt.items.count)("CHECKSUM").Properties(1), 2), tChecksum)
      
'      AddChecksumCollection checksum, element.Fields, Nothing, ""
      UpdateStatusOLD
    Next element
  Else
    Ticks = Ticks + 1
    UpdateStatusOLD
  End If
      
      ' Die Relations
    '  If ExtrudeRelations Then
    '    Print #1, "!DEX_BEGIN_RELATIONS"
    '    For i = 0 To m_DB.Relations.Count - 1
    '      ExtractRelation m_DB.Relations(i)
    '      Count = Count + 1
    '      UpdateStatusOLD
    '    Next
    '    Print #1, "!DEX_END_RELATIONS"
    '  End If
      
    '  TickDebug ("Relations")
  
  
'  Debug.Print "Ticks: " & Ticks & " Totalticks: " & TotalTicks
      
  ' ProgressForm.Hide
'  Unload ProgressForm
'  Set ProgressForm = Nothing


    XLScriptAddSimpleVar "AUTHOR", GetDocProp(m_DB, "Author")
    XLScriptAddSimpleVar "CREATIONDATE", GetDocProp(m_DB, "Creation date")
    XLScriptAddSimpleVar "STATUS", FMT0("SCANERG_4")
    XLScriptAddSimpleVar "STATUSID", "4"


    XLScriptAddSimpleVar "DATE", StartDate
    XLScriptAddSimpleVar "TIMEELAPSED", Format(Time - StartTime, "hh:mm:ss")
    XLScriptAddSimpleVar "TABLES", totalTableAmount
    XLScriptAddSimpleVar "SQLS", IIf(FullVersion = False, "Demo", totalQueryAmount)
    XLScriptAddSimpleVar "VBAPROTECTED", VbaProtected
    XLScriptAddSimpleVar "VBAMODULES", totalModuleAmount
    XLScriptAddSimpleVar "VBACLASSMODULES", totalClassModuleAmount
    XLScriptAddSimpleVar "VBARESTMODULES", IIf(FullVersion = False, "Demo", totalRestModuleAmount)
    XLScriptAddSimpleVar "FORMS", totalFormAmount
    XLScriptAddSimpleVar "FORMMODULES", totalFormModuleAmount
    XLScriptAddSimpleVar "SCRIPTS", totalScriptAmount
    XLScriptAddSimpleVar "REPORTS", IIf(FullVersion = False, "Demo", totalReportAmount)
    XLScriptAddSimpleVar "REPORTMODULES", totalReportModuleAmount
    XLScriptAddSimpleVar "FILE", orifilename

    XLScriptAddSimpleVar "TABLEFIELDS", totalTableFieldAmount
    XLScriptAddSimpleVar "SUBFORMS", IIf(FullVersion = False, "Demo", totalSubFormAmount)
    XLScriptAddSimpleVar "DATASETS", totalDatasetAmount
    XLScriptAddSimpleVar "DATAFIELDS", totalDatafieldAmount
    XLScriptAddSimpleVar "CONTROLSONFORMS", totalControlsOnFormsAmount
    XLScriptAddSimpleVar "EDITCONTROLSONFORMS", totalEditControlsOnFormsAmount
    XLScriptAddSimpleVar "PROGRAMEDITCONTROLSONFORMS", totalProgramEditControlsOnFormsAmount
    
    XLScriptAddSimpleVar "ACTIVEXONFORMS", IIf(FullVersion = False, "Demo", totalActiveXAmount)
    XLScriptAddSimpleVar "VBALINES", totalVBALineAmount
    XLScriptAddSimpleVar "VBACOMMENTLINES", totalVBACommentsAmount
    XLScriptAddSimpleVar "SCRIPTLINES", totalScriptLineAmount
    XLScriptAddSimpleVar "SCRIPTCOMMENTLINES", totalScriptCommentLinesAmount
    XLScriptAddSimpleVar "INDICES", totalIndicesAmount
    XLScriptAddSimpleVar "REFERENCEDDBS", IIf(FullVersion = False, "Demo", totalReferencedDBAmount)
    XLScriptAddSimpleVar "REFERENCEDTABLES", totalReferencedTablesAmount
    XLScriptAddSimpleVar "RELATIONFIELDS", totalRelationFieldAmount

    XLScriptAddSimpleVar "TABLECOMMENTS", totalTabelCommentAmount
    XLScriptAddSimpleVar "SQLCOMMENTS", totalSQLCommentAmount
    XLScriptAddSimpleVar "FORMCOMMENTS", totalFormCommentAmount
    XLScriptAddSimpleVar "REPORTCOMMENTS", IIf(FullVersion = False, "Demo", totalReportCommentAmount)
    XLScriptAddSimpleVar "SCRIPTCOMMENTS", IIf(FullVersion = False, "Demo", totalScriptCommentAmount)
    XLScriptAddSimpleVar "VBAMODULECOMMENTS", totalVBAModuleCommentAmount
  
    XLScriptAddSimpleVar "RELATIONS", m_App.CurrentDb.Relations.count
    XLScriptAddSimpleVar "REFERENCEAM", m_App.References.count
    XLScriptAddSimpleVar "ISCOMP", m_App.IsCompiled
    XLScriptAddSimpleVar "PRODUCTCODE", Left(m_App.ProductCode, 50)
    XLScriptAddSimpleVar "CONNECT", Left(m_App.CurrentDb.Connect, 120)
    XLScriptAddSimpleVar "QUERYTIMEOUT", m_App.CurrentDb.QueryTimeout
    XLScriptAddSimpleVar "UPDATABLE", m_App.CurrentDb.Updatable
    XLScriptAddSimpleVar "VERSION", Left(m_App.CurrentDb.Version, 8)
    XLScriptAddSimpleVar "REPLICAID", m_App.CurrentDb.ReplicaID
    XLScriptAddSimpleVar "APPTITLE", Left(GetCurDBProperty("APP TITLE"), 120)
    XLScriptAddSimpleVar "STARTUPSHOWDBWINDOW", GetCurDBProperty("STARTUPSHOWDBWINDOW")
    XLScriptAddSimpleVar "ALLOWSHORTCUTMENUS", GetCurDBProperty("ALLOWSHORTCUTMENUS")
    XLScriptAddSimpleVar "ALLOWFULLMENUS", GetCurDBProperty("ALLOWFULLMENUS")
    XLScriptAddSimpleVar "ALLOWBUILTINTOOLBARS", GetCurDBProperty("ALLOWBUILTINTOOLBARS")
    XLScriptAddSimpleVar "ALLOWTOOLBARCHANGES", GetCurDBProperty("ALLOWTOOLBARCHANGES")
    XLScriptAddSimpleVar "ALLOWBREAKINTOCODE", GetCurDBProperty("ALLOWBREAKINTOCODE")
    XLScriptAddSimpleVar "ALLOWSPECIALKEYS", GetCurDBProperty("ALLOWSPECIALKEYS")
  
    XLScriptAddSimpleVar "CHECKSUM", "h" & Hex(checksum)
  
printResults:

  If Not Beenden Then
    If GetRiskValues() Then
      CreateRisk
    Else
      If AR_UseDB Then
        SaveSetting appname:="Stromwerken", Section:=ProgNameShort, Key:="ProcResult", setting:=Right(StatusForm.ProgText, 2048)
      End If
      Set m_Workspace = Nothing
      Set m_DB = Nothing
      m_App.Quit
      Set m_WS = Nothing
      Set m_FN = Nothing
      Set m_App = Nothing
      
      Set m_ResultWorkbook = Nothing
      Exit Sub
    End If
  End If
  
  If Not AR_UseDB Or G_CreateResfile > 0 Then
            Dim ws As Worksheet
            
            m_ResultWorkbook.Application.Calculation = xlCalculationManual
            m_ResultWorkbook.Application.ScreenUpdating = False
            m_ResultWorkbook.Application.EnableEvents = False
            If Not m_ResultWorkbook Is Nothing Then
              '  AddStatus "Generiere Ergebnisbl|fffd|tter"
                For Each ws In m_ResultWorkbook.Sheets
                  If ws.name <> "Log" Then
                    'AddStatus "Generiere Ergenbisblatt " & ws.name
                    AddStatus FMT1("CHECK_21", ws.name)
                    Helpers.ACCreateHeaderAndFooter ws, orifilename
                    XLScriptInit ws, 1
    '                XLScriptSetValues TheResults, ws.Cells
                    XLScriptExecCode ws.Cells, 0, 0
                    XLScriptExit
                  End If
                  Ticks = Ticks + 1 / m_ResultWorkbook.Sheets.count
                  UpdateStatusOLD
                Next ws
                For Each ws In m_ResultWorkbook.Sheets
                  If ws.name <> "Log" Then
                    XLScriptInit ws, 2
                    XLScriptExecCode ws.Cells, 0, 0
                    XLScriptExit
                  
                    If ws.name <> "Log" Then
                      ws.Cells.EntireColumn.AutoFit
                      ws.Cells.EntireRow.AutoFit
                    End If
                    ws.Cells(3, 1).Activate
                  End If
                  Ticks = Ticks + 1 / m_ResultWorkbook.Sheets.count
                  UpdateStatusOLD
                Next ws
                'AddStatus "Generiere Ergenbisbl|fffd|tter - Fertig"
                AddStatus FMT0("CHECK_22")
                m_ResultWorkbook.Sheets(1).Activate
            End If
            m_ResultWorkbook.Application.EnableEvents = False
            m_ResultWorkbook.Application.ScreenUpdating = True
            m_ResultWorkbook.Application.Calculation = xlCalculationAutomatic
            m_ResultWorkbook.Application.Visible = True
            
            ' Und Resultfile speichern!
            Select Case G_CreateResfile
                ' In Current Command!
              Case 1
                If G_ResfileDestID <= 0 Then
                  If Not m_ResultWorkbook Is Nothing Then CloseWB m_ResultWorkbook
                Else
                  Dim fname As String
                  If Not m_ResultWorkbook Is Nothing Then
                    m_ResultWorkbook.Worksheets(1).Activate
                    fname = StoreTempResultFile(m_ResultWorkbook)
                    CloseWB Workbooks(GetFileNameAndExtension(fname))
                  
                  Dim rs As Object
                  Dim errstr As String
                    Set rs = OpenRS("select ResultBlob, ResultBlobFileExtension, idvDateiID, Dateiname FROM gCommunicate WHERE InternalID = " & G_ResfileDestID, G_Conn, MYadOpenDynamic, MYadLockOptimistic)
                    If Not rs Is Nothing Then
                      If Not rs.EOF Then
                        CheckInBinary "ResultBlob", rs, fname, errstr
                        rs.Fields("ResultBlobFileExtension").value = "xlsx"
                        rs.Fields("idvDateiID").value = theidvDateiID
                        rs.Fields("Dateiname").value = theFilename
                        rs.Update
                      Else
                        DebugPrint tERROR, "ECC-Ergebnisdatei konnte nicht zum Scheduler Kommando (gCommunicate) mit der ID " & G_ResfileDestID & " hinzugef|fffd|gt werden."
                      End If
                      rs.Close
                      Set rs = Nothing
                    End If
                  End If
                End If
              Case 2  ' Do Nothing
              
              Case 3
              
              Case 4  ' Save in RESFfile
                m_ResultWorkbook.Save
                CloseWB m_ResultWorkbook
              
            End Select
  End If
  
  MyKill G_cfgTemppfad & "\ACCExt-" & GetUserName & ".txt"
  AddStatus "----------------------------------------------------------------"
  
  
  Set m_Workspace = Nothing
  Set m_DB = Nothing
'  m_App.CloseCurrentDatabase
  m_App.Quit

closeStuff:
  Set m_WS = Nothing
  Set m_FN = Nothing
  Set m_App = Nothing
  
  If AR_UseDB = True Then
    If hadError = True Or Beenden = True Then
      XLACCStoreValsToDB False
    Else
      'LogPrintECCSCanLog theFilename & " (ID: " & theidvDateiID & ") - Ergebnis: Analyse erfolgreich beendet, Checksumme: " & XLScriptGetSimpleVar("CHECKSUM").m_Value, True
      LogPrintECCSCanLog theidvDateiID, 4, "Ergebnis: Analyse erfolgreich beendet, Checksumme: " & XLScriptGetSimpleVar("CHECKSUM").m_Value, True
      XLACCStoreValsToDB Not hadError
    End If
    ResetRisks
  End If
  
  If AR_UseDB Then
    SaveSetting appname:="Stromwerken", Section:=ProgNameShort, Key:="ProcResult", setting:=Right(StatusForm.ProgText, 2048)
  End If
  
  XLScriptExitGlobals
  
  If G_LogPrintChecksum Then
    If ff <> -1 Then Close #ff
  End If
  
  SaveSetting appname:="Stromwerken", Section:="AccessTracker", Key:="IgnoreThisOne", setting:="False"
  
  Dim tCnt As Long
  For tCnt = 1 To 20
    Sleep 100
    DoEvents
  Next tCnt
  
  Set m_ResultWorkbook = Nothing
  
  Exit Sub
'-----------------------------------------------------
handleError:
    Dim terrstr As String
'    errstr = "Error (" & ProgressForm.Status & ") Object: " & CurrentObject & " - " & Err.Description & "(ErrNr: " & Err.Number & ")"
    terrstr = FMT4("CHECK_24", m_Status, CurrentObject, Err.Description, Err.Number)
    XLScriptAddLogEntry terrstr
    Resume Next
End Sub

Function StoreTempResultFile(ByRef resultWB As Workbook)
On Error GoTo nogo
  Dim fname As String
  fname = CreateTempFile("Tmp") & ".xlsx"
  resultWB.SaveAs fname
  StoreTempResultFile = fname
  Exit Function
nogo:

End Function

Sub AddError(nfo As String)
    Dim s As String
    s = GetSetting(appname:="Stromwerken", Section:=ProgNameShort, Key:="Error")
    SaveSetting appname:="Stromwerken", Section:=ProgNameShort, Key:="Error", setting:= _
      IIf(s <> "", s & vbCrLf, "") & nfo
End Sub
Sub CreateRisk()
  Dim rt As RiskTab
  
  Dim ri As XLScriptArray2D
  Set ri = XLScriptAddArray2D("RiskItems")
  
  Dim totalrisk As Double
  
  
  totalrisk = 0
  
  For Each rt In G_RiskTabs
    ri.AddLine UCase(rt.m_TabName)
    
    ri.AddValue "Tabname", rt.m_TabName ' TranslateText(rt.m_TabName)
    
    Dim risk As Double
    risk = 0
    
    
    Dim rv As RiskVal
    For Each rv In rt.m_Vals
    
      Select Case rv.m_Type
      
        Case C_RISK_TYPE_ECC
      
'              Dim xlssv As XLScriptSimpleVar
'              Set xlssv = XLScriptGetSimpleVar(rv.m_Parameter)
              
              Dim v As String
              v = XLScriptGetVarValue(rv.m_Parameter, Nothing)
              
              If v = "" Then
'                Debug.Print "Unknown risk var: " & rv.m_Parameter
                'MsgBox "Unknown risk var: " & rv.m_Parameter, vbCritical, "Access-Checker"
                MsgBox FMT1("CHECK_25", rv.m_Parameter), vbCritical, FMT0("MAIN_1")
              Else
                  
                  If Len(v) > 0 Then
                      
                        Dim rr As RiskRange
                        For Each rr In rv.m_Vals
                            
                            Select Case rr.m_Comparison
                              Case C_RISK_COMP_TYPE_LESS
                                If Val(v) < rr.m_Value Then
                                  risk = risk + rr.m_Risk
                                  XLScriptAddSimpleVar rv.m_Parameter & "BC", IIf(rr.m_Risk < rt.m_Low, rt.m_LowColour, IIf(rr.m_Risk < rt.m_Med, rt.m_MedColour, rt.m_HighColour))
                                  Exit For
                                End If
                              Case C_RISK_COMP_TYPE_LESSEQUAL
                                If Val(v) <= rr.m_Value Then
                                  risk = risk + rr.m_Risk
                                  XLScriptAddSimpleVar rv.m_Parameter & "BC", IIf(rr.m_Risk < rt.m_Low, rt.m_LowColour, IIf(rr.m_Risk < rt.m_Med, rt.m_MedColour, rt.m_HighColour))
                                  Exit For
                                End If
                              Case C_RISK_COMP_TYPE_EQUAL
                                If Val(v) = rr.m_Value Then
                                  risk = risk + rr.m_Risk
                                  XLScriptAddSimpleVar rv.m_Parameter & "BC", IIf(rr.m_Risk < rt.m_Low, rt.m_LowColour, IIf(rr.m_Risk < rt.m_Med, rt.m_MedColour, rt.m_HighColour))
                                  Exit For
                                End If
                              Case C_RISK_COMP_TYPE_LARGER
                                If Val(v) > rr.m_Value Then
                                  risk = risk + rr.m_Risk
                                  XLScriptAddSimpleVar rv.m_Parameter & "BC", IIf(rr.m_Risk < rt.m_Low, rt.m_LowColour, IIf(rr.m_Risk < rt.m_Med, rt.m_MedColour, rt.m_HighColour))
                                  Exit For
                                End If
                              Case C_RISK_COMP_TYPE_LARGEREQUAL
                                If Val(v) >= rr.m_Value Then
                                  risk = risk + rr.m_Risk
                                  XLScriptAddSimpleVar rv.m_Parameter & "BC", IIf(rr.m_Risk < rt.m_Low, rt.m_LowColour, IIf(rr.m_Risk < rt.m_Med, rt.m_MedColour, rt.m_HighColour))
                                  Exit For
                                End If
                            End Select
                            
                        Next rr
                  
                  
                  End If
              End If
        Case C_RISK_TYPE_FORMULA_CONTAINS, C_RISK_TYPE_WHITE_LIST, C_RISK_TYPE_NOT_IN_WHITE_LIST
        
              For Each rr In rv.m_Vals
                  
                  Select Case rr.m_Comparison
                    Case C_RISK_COMP_TYPE_LESS
                      If rv.m_Matches < rr.m_Value Then
                        risk = risk + rr.m_Risk
                        Exit For
                      End If
                    Case C_RISK_COMP_TYPE_LESSEQUAL
                      If rv.m_Matches <= rr.m_Value Then
                        risk = risk + rr.m_Risk
                        Exit For
                      End If
                    Case C_RISK_COMP_TYPE_EQUAL
                      If rv.m_Matches = rr.m_Value Then
                        risk = risk + rr.m_Risk
                        Exit For
                      End If
                    Case C_RISK_COMP_TYPE_LARGER
                      If rv.m_Matches > rr.m_Value Then
                        risk = risk + rr.m_Risk
                        Exit For
                      End If
                    Case C_RISK_COMP_TYPE_LARGEREQUAL
                      If rv.m_Matches >= rr.m_Value Then
                        risk = risk + rr.m_Risk
                        Exit For
                      End If
                  End Select
                  
              Next rr
        
      End Select
    Next rv
    
    
    ri.AddValue "Risk", CStr(IIf(risk > 1, 1, risk * 1))
    
    Dim multi As Double
    
    If risk < rt.m_Low Then
      ri.AddValue "Col", rt.m_LowColour
      multi = rt.m_LowMulti
    ElseIf risk < rt.m_Med Then
      ri.AddValue "Col", rt.m_MedColour
      multi = rt.m_MedMulti
    Else
      ri.AddValue "Col", rt.m_HighColour
      multi = rt.m_HighMulti
    End If
    
    totalrisk = totalrisk + multi * risk * rt.m_Weight
    
  Next rt
  
  XLScriptAddSimpleVar "TotalRisk", CStr(IIf(totalrisk > 1, 1, totalrisk))
  
  If totalrisk <= G_RiskLow Then
    XLScriptAddSimpleVar "TotalRiskCol", CStr(G_RiskLowCol)
  ElseIf totalrisk <= G_RiskMed Then
    XLScriptAddSimpleVar "TotalRiskCol", CStr(G_RiskMedCol)
  Else
    XLScriptAddSimpleVar "TotalRiskCol", CStr(G_RiskHighCol)
  End If
  
  
  ' Und das Gesamtrisiko ermitteln
  
End Sub

Function GetExcelFile(Filename As String, ByRef oxlwbook As Excel.Workbook) As Boolean
  Dim msgBoxText                As String
  
  GetExcelFile = True
  On Error GoTo fehler
  Set oxlwbook = Workbooks.Open(ShortFileName(Filename))
  SaveSetting _
     appname:="Stromwerken", _
     Section:=ProgNameShort, _
     Key:="LiveStatusCaption", _
     setting:=Application.Caption
  Exit Function
  
fehler:
  GetExcelFile = False
End Function


Function GetRiskValues() As Boolean
  GetRiskValues = False
  Dim wb As Excel.Workbook
  Dim rs
  
  Dim riskFilePath As String
  riskFilePath = gTranslation.GetLocalizedFile(ThisWorkbook.path & "\Access-Checker Risk.xls")
  
  Dim regeln As String
  Dim risiken As String
  Dim gesamtrisiko As String
  
  If AR_UseDB = False Then
    If Not GetExcelFile(riskFilePath, wb) Then
      'MsgBox "Die Risikodatei '" & ThisWorkbook.path & "\Access-Checker Risk.xls' fehlt. Es kann keine Risikoanalyse vorgenommen werden!", vbCritical, "Access-Checker"
      MsgBox FMT1("CHECK_26", ThisWorkbook.path), vbCritical, FMT0("MAIN_1")
      Exit Function
    End If
    
    ' Die Sheet-Namen sind hier hard-coded fuer alle unterstuetzten Sprachen.
    ' Begruendung: Wenn Kunden diese Dateien zwischen Instituten in verschiedenen Laendern austauschen/deployen, muss das mit allen Sprachvarianten der files funktionieren.
    ' Also eine englische Version muss das deutsche File lesen koennen. Deshalb werden die Namen nicht aus der Translation gelesen.
    regeln = TranslationSheetExists(wb, Array("Regeln", "Rules"))
    risiken = TranslationSheetExists(wb, Array("Risiken", "Risks"))
    gesamtrisiko = TranslationSheetExists(wb, Array("Gesamtrisiko", "Total Risk"))
    
    If Not WorksheetExists(wb, regeln) Then
      'MsgBox "Es existiert keine Tabelle mit dem Namen 'Regeln' in der Datei '" & ThisWorkbook.path & "\Access-Checker Risk.xls' fehlt. Es kann keine Risikoanalyse vorgenommen werden!", vbCritical, "Access-Checker"
      MsgBox FMT1("CHECK_27", ThisWorkbook.path), vbCritical, FMT0("MAIN_1")
      Exit Function
    End If
    
    If Not WorksheetExists(wb, risiken) Then
      'MsgBox "Es existiert keine Tabelle mit dem Namen 'Risiken' in der Datei '" & ThisWorkbook.path & "\Access-Checker Risk.xls' fehlt. Es kann keine Risikoanalyse vorgenommen werden!", vbCritical, "Access-Checker"
      MsgBox FMT1("CHECK_28", ThisWorkbook.path), vbCritical, FMT0("MAIN_1")
      Exit Function
    End If
    
    If Not WorksheetExists(wb, gesamtrisiko) Then
      'MsgBox "Es existiert keine Tabelle mit dem Namen 'Gesamtrisiko' in der Datei '" & ThisWorkbook.path & "\Access-Checker Risk.xls' fehlt. Es kann keine Gesamtrisikoanalyse vorgenommen werden!", vbCritical, "Access-Checker"
      MsgBox FMT1("CHECK_29", ThisWorkbook.path), vbCritical, FMT0("MAIN_1")
      Exit Function
    End If
    
    
    With wb.Sheets(gesamtrisiko)
      
      G_RiskLow = .Cells(2, 2)
      G_RiskMed = .Cells(3, 2)
      G_RiskLowCol = .Cells(2, 3).Interior.Color
      G_RiskMedCol = .Cells(3, 3).Interior.Color
      G_RiskHighCol = .Cells(4, 3).Interior.Color
    
    End With
  Else
      
      Set rs = CreateObject("ADODB.recordset")
      rs.Open "SELECT * FROM ACCRisikoGesamt", G_Conn, 2, 1
      If rs.EOF Then
        If Not AR_UseDB Then
          'MsgBox "Es sind keine GesamtRisikodaten in der Datenbank des IDV-Trackers enthalten. Es kann keine Gesamtrisikoanalyse vorgenommen werden!", vbCritical, "Access-Checker"
          MsgBox FMT0("CHECK_30"), vbCritical, FMT0("MAIN_1")
        Else
          'AddStatus "Es sind keine GesamtRisikodaten in der Datenbank des IDV-Trackers enthalten. Es kann keine Gesamtrisikoanalyse vorgenommen werden!"
          AddStatus FMT0("CHECK_30")
        End If
        rs.Close
        Set rs = Nothing
        Exit Function
      End If
      
      G_RiskLow = rs.Fields("Gering").value
      G_RiskMed = rs.Fields("Mittel").value
      G_RiskLowCol = rs.Fields("GeringFarbe").value
      G_RiskMedCol = rs.Fields("MittelFarbe").value
      G_RiskHighCol = rs.Fields("HochFarbe").value
      
      rs.Close
      Set rs = Nothing
  End If
  
  Set G_RiskTabs = New Collection
  Set G_RiskContains = New Collection
  Set G_WhiteList = New Collection
  
  
  If AR_UseDB = False Then
    Dim y As Long
    y = 2
    Dim rt As RiskTab
    With wb.Worksheets(risiken)
      Do While Not IsEmpty(.Cells(y, 1))
      
        Set rt = New RiskTab
        If Not rt.Init(wb, y, regeln, risiken) Then Exit Function
        G_RiskTabs.Add rt, .Cells(y, 1)
        y = y + 1
      Loop
    End With
    wb.Close False
    Set wb = Nothing
  
  
  Else
      
      Set rs = CreateObject("ADODB.recordset")
      rs.Open "SELECT * FROM ACCRisiken", G_Conn, 2, 1
      If rs.EOF Then
        If Not AR_UseDB Then
          'MsgBox "Es sind keine Risikodaten in der Datenbank des IDV-Trackers enthalten. Es kann keine Gesamtrisikoanalyse vorgenommen werden!", vbCritical, "Access-Checker"
          MsgBox FMT0("CHECK_31"), vbCritical, FMT0("MAIN_1")
        Else
          'AddStatus "Es sind keine Risikodaten in der Datenbank des IDV-Trackers enthalten. Es kann keine Gesamtrisikoanalyse vorgenommen werden!"
          AddStatus FMT0("CHECK_31")
        End If
        rs.Close
        Set rs = Nothing
        Exit Function
      End If
      
      
      Do While Not rs.EOF
      
        Set rt = New RiskTab
        If Not rt.InitDB(G_Conn, rs) Then
          rs.Close
          Set rs = Nothing
          Exit Function
        End If
        G_RiskTabs.Add rt, rs.Fields("Risiko").value
        rs.MoveNext
      Loop
      
      rs.Close
      Set rs = Nothing
  End If
  
  GetRiskValues = True
End Function

Public Sub ResetRisks()
    Dim rtitem As RiskTab
    Dim rvitem As RiskVal
    On Error Resume Next
    If Not G_RiskTabs Is Nothing Then
      For Each rtitem In G_RiskTabs
          For Each rvitem In rtitem.m_Vals
              rvitem.m_Hit = False
              rvitem.m_Matches = 0
              rvitem.m_FirstMatch = ""
              rvitem.m_FirstMatchAddress = ""
          Next rvitem
      Next rtitem
    End If
    
    If Not G_RiskContains Is Nothing Then
      For Each rvitem In G_RiskContains
          rvitem.m_Hit = False
          rvitem.m_Matches = 0
          rvitem.m_FirstMatch = ""
          rvitem.m_FirstMatchAddress = ""
      Next rvitem
    End If
    
    If Not G_WhiteList Is Nothing Then
      For Each rvitem In G_WhiteList
          rvitem.m_Hit = False
          rvitem.m_Matches = 0
          rvitem.m_FirstMatch = ""
          rvitem.m_FirstMatchAddress = ""
      Next rvitem
    End If

End Sub

Function BuildCacheName(f As String, typ As String, name As String) As String
    BuildCacheName = f & "." & typ & "." & name & ".cache"
End Function
Function NeedsUpdate(t As Date, f As String, typ As String, name As String) As Boolean
    NeedsUpdate = True
    Dim fname As String
    fname = BuildCacheName(f, typ, name)
    On Error GoTo errorHandler
    If t < MyFileDateTime(fname) Then
        NeedsUpdate = False
    End If
    Exit Function
errorHandler:
End Function


Public Sub DoMyEvents()
  MyEventCount = MyEventCount + 1
  If MyEventCount > 10 Then
    DoEvents
    MyEventCount = 0
  End If
End Sub
Private Sub TickDebug(name As String)
  StatusFormUpdate
  If Ticks > LastTicks Then
'    Debug.Print name & ": " & Format((Time - LastTime), "Long Time") & _
'      "  Ticks: " & Ticks - LastTicks & _
'      "  Ticktime: " & ((Time - LastTime) * 100000) / (Ticks - LastTicks)
  Else
'    Debug.Print "None: " & name
  End If
  LastTicks = Ticks
  LastTime = Time
End Sub

Private Sub UpdateStatusOLD()
  StatusFormUpdate
  DoEvents
  If Ticks > TotalTicks Then
    Ticks = TotalTicks
  End If
  If TotalTicks > 0 Then
      StatusForm.ProgressTxt = Format(Ticks / TotalTicks, "Percent")
      ' ProgressForm.ProgressText.Refresh
      StatusForm.ProgressB.Width = StatusForm.ProgressTxt.Width * Ticks / TotalTicks
      
      Dim spentTime, remainingTime
      spentTime = Time - StartTime
      
      If Ticks > 0 Then
        remainingTime = (spentTime * (TotalTicks - Ticks)) / Ticks
        ' ProgressForm.ProgressTime = Format(remainingTime, "hh:mm:ss")
        ' ProgressForm.ProgressTime.Refresh
        ' ProgressForm.EstimatedEnd = Format(Time + remainingTime, "hh:mm:ss")
        ' ProgressForm.EstimatedEnd.Refresh
    '    ' ProgressForm.Refresh
      End If
      DoEvents
  End If
  SetLiveStatus
End Sub


Sub MyMain()

  ErrorFileOpen = False
  
  Dim cacheName As String
  Dim cache(1024) As String
  Dim cacheCnt As Integer
  cacheCnt = 0
  
  CurrentObject = "Startup"
  
  On Error GoTo handleError
  
  MyEventCount = 0
  ProgStartTime = Time
   
  TotalTicks = 0
  ' ProgressForm.ProgBar.Max = 100
  ' ProgressForm.Show vbModeless
  
  'Parameter festlegen
  EmptyList = Array("-")
  QueryDefFields = Array("SourceField", "SourceTable", "-")
  RelationFields = Array("Name", "ForeignName", "AllowZeroLength", "-")
  TableElementProperties = Array("Type", "Attributes", "Size", "DataUpdatable", _
    "DefaultValue", "ValidationRule", "ValidationText", "Required", "AllowZeroLength", _
    "Description", "-")
  
' X X X
 FormControlNegProperties = Array( _
    "TabStop", "TabIndex", "Left", "Top", "Width", _
    "Height", "ForeColor", "FontName", "FontSize", "FontWeight", _
    "FontItalic", "FontUnderline", "TextFontCharSet", "FontBold", "ColumnWidth", _
    "ColumnOrder", "ColumnHidden", "Name", "ObjectPalette", "PictureData", "PrtDevModeW", _
    "-")
  
' FormControlProperties = Array( _
'    "Type", "Name", "Size", "SourceField", "SourceTable", "DataUpdatable", "DefaultValue", "ValidationRule", "ValidationText", "Required", _
'    "AllowZeroLength", "AppendOnly", "Expression", "ColumnHidden", "DisplayControl", "RowSourceType", "BoundColumn", "ColumnCount", _
'    "ColumnHeads", "AllowMultipleValues", "AllowValueListEdits", "ShowOnlyRowSourceValues", "Description", "", "", "", "", "", _
'    "", "", "", "", "", "", "", "", "", "", _
'    "", "", "", "", "", "", "", "", "", "", _
'    "-")
  
  
'  FormProperties = Array("RecordSource", "Filter", "FilterOn", "OrderBy", "OrderByOn", _
'    "AllowFilters", "Caption", "DefaultView", "ViewsAllowed", "AllowEditing", _
'    "DefaultEditing", "AllowEdits", "AllowDeletions", "AllowAdditions", "DataEntry", _
'    "AllowUpdating", "RecordsetType", "RecordLocks", "ScrollBars", "RecordSelectors", _
'    "NavigationButtons", "DividingLines", "AutoResize", "AutoCenter", "PopUp", "Modal", _
'    "BorderStyle", "ControlBox", "MinButton", "MaxButton", "MinMaxButtons", _
'    "CloseButton", "WhatsThisButton", "Picture", "PictureType", "PictureSizeMode", _
'    "PictureAlignment", "PictureTiling", "Cycle", "MenuBar", "Toolbar", "ShortcutMenu", _
'    "ShortcutMenuBar", "LayoutForPrint", "FastLaserPrinting", "HelpFile", _
'    "HelpContextID", "RowHeight", "Visible", "Painting", "PaletteSource", _
'    "Tag", "PaintPalette", "OpenArgs", "OnCurrent", "BeforeInsert", "AfterInsert", _
'    "BeforeUpdate", "AfterUpdate", "OnDelete", "BeforeDelConfirm", "AfterDelConfirm", _
'    "OnOpen", "OnLoad", "OnResize", "OnUnload", "OnClose", "OnActivate", _
'    "OnDeactivate", "OnGotFocus", "OnLostFocus", "OnClick", "OnDblClick", "OnMouseDown", _
'    "OnMouseMove", "OnMouseUp", "OnKeyDown", "OnKeyUp", "OnKeyPress", "KeyPreview", _
'    "OnError", "OnFilter", "OnApplyFilter", "OnTimer", "TimerInterval", "HasModule", _
'    "RowSourceType", "RowSource", "ColumnHeads", "ColumnCount", " - ")
  
  FormNegProperties = Array("Width", "GridX", "GridY", "DatasheetFontName", _
    "DatasheetFontHeight", "DatasheetFontWeight", "DatasheetFontItalic", _
    "DatasheetFontUnderline", "DatasheetGridlinesBehavior", "DatasheetGridlinesColor", _
    "DatasheetCellsEffect", "DatasheetForeColor", "ShowGrid", "DatasheetBackColor", _
    "hWnd", "Count", "LogicalPageWidth", "PrtMip", "PrtDevMode", "PrtDevNames", _
    "FrozenColumns", "Name", "PaletteSource", "WindowWidth", "WindowHeight", _
    "CurrentView", "CurrentSectionTop", "CurrentSectionLeft", "SelLeft", _
    "SelTop", "SelWidth", "SelHeight", "PictureData", "InsideHeight", "InsideWidth", _
    "PicturePalette", "-")
 
  
  
  
  
  Dim i As Integer
  
  ' Parameter einlesen
    
  Dim Filename As String
  Dim destfile As String
  Dim Command As String
  
  UseDefinedDesc = False
  
'  filename = Application.GetOpenFilename("Access-Dateien,*.mdb", 1)
'  If filename = False Then Exit Sub
  
  DoEvents
  

  Dim dummyString As String
  
  
'  If Not FileExists(App.Path & "\DexMsA.cfg") Then
'    MsgBox "Couldn't open " & App.Path & "\DexMsA.cfg!", vbCritical
'    Unload ProgressForm
'    Set ProgressForm = Nothing
'    Exit Sub
'  End If
  
  
'  Open App.Path & "\DexMsA.cfg" For Input As #1
  
  
'  If Err.Number <> 0 Then
'    MsgBox "Couldn't open " & App.Path & "\DexMsA.cfg!", vbCritical
'    Unload ProgressForm
'    Set ProgressForm = Nothing
'    Exit Sub
'  End If
  Input #1, dummyString
  Input #1, LogFilename
  
  Err.Number = 0
  Open LogFilename For Append As #2
  If Err.Number <> 0 Then
    'MsgBox "Couldn't open logfile!", vbCritical
    MsgBox FMT0("CHECK_32"), vbCritical
    ' ProgressForm.Hide
'    Unload ProgressForm
'    Set ProgressForm = Nothing
    
    Exit Sub
  End If
  ErrorFileOpen = True
  
  Input #1, dummyString
  Input #1, Command
  
      Input #1, dummyString
      Input #1, Filename
      Input #1, dummyString
      Input #1, destfile
      Input #1, dummyString
      Input #1, ExtrudeModules
      Input #1, dummyString
      Input #1, ExtrudeTables
      Input #1, dummyString
      Input #1, ExtrudeRelations
      Input #1, dummyString
      Input #1, ExtrudeQueries
      Input #1, dummyString
      Input #1, ExtrudeFormModules
      Input #1, dummyString
      Input #1, ExtrudeScripts
      Input #1, dummyString
      Input #1, ExtrudeForms
      Close #1
      
      DoEvents
      
      If Not FileExists(Filename) Then
        ' Debug.Print "Error (" & ProgressForm.Status & ") Object: " & CurrentObject & " - File " & Filename & " not found!"
'        If ErrorFileOpen Then
'            Print #2, "Error (" & ProgressForm.Status & ") Object: " & CurrentObject & " - File " & Filename & " not found!"
'        End If
'        ProgressForm.Hide
'        Unload ProgressForm
        Exit Sub
      End If
      
      ' ProgressForm.Filename = Filename
      
      Dim appAccess As Object
      Set appAccess = CreateObject("Access.Application.8")
      
      DoEvents
      
      SaveSetting appname:="Stromwerken", Section:="AccessTracker", Key:="IgnoreThisOne", setting:="True"
      appAccess.OpenCurrentDatabase Filename
      
      appAccess.DoCmd.RunCommand 11 ' acCmdAppMinimize
        
      DoEvents
      
      ' Alle Namen besorgen
      Dim db As Database
      Set db = OpenDatabase(Filename)
      Dim element
      Dim subelement
      
      count = 0
      Totalamount = 0
      ' Erst wird gez|fffd|hlt
      
      DoEvents
      
      ' *********************************************************************
      ' Erst z|fffd|hlen z|fffd|hlen
      ' *********************************************************************
      
      'Dann die Tabellen
      If ExtrudeTables Then
        'SetStatus "Counting tables"
        SetStatus FMT0("CHECK_33")
        ' ProgressForm.Status.Refresh
        For Each element In db.TableDefs
          If (element.Attributes And &H80000002) = 0 Then
            If element.Updatable = True Then
                CurrentObject = element.name
                If NeedsUpdate(element.LastUpdated, destfile, "TBL", CurrentObject) Then
                    DoEvents
                    Totalamount = Totalamount + 1
                    TotalTicks = TotalTicks + element.Indexes.count * TableIndexesTicks
                    TotalTicks = TotalTicks + element.Properties.count * TablePropertiesTicks
                    TotalTicks = TotalTicks + element.Fields.count * TableElementPropertiesSize * TableFieldTicks
                End If
            End If
          End If
        Next
      End If
      
      DoEvents
      
      ' Die Abfragen
      If ExtrudeQueries Then
        'SetStatus "Counting queries"
        SetStatus FMT0("CHECK_34")
        ' ProgressForm.Status.Refresh
        For Each element In db.QueryDefs
            If Left(element.name, 1) <> "~" Then
                CurrentObject = element.name
                If NeedsUpdate(element.LastUpdated, destfile, "QRY", CurrentObject) Then
                    DoEvents
                    Totalamount = Totalamount + 1
                    TotalTicks = TotalTicks + element.Properties.count * QueryPropertyTicks
                    TotalTicks = TotalTicks + element.Fields.count * QueryDefFieldsSize * QueryFieldTicks
                    TotalTicks = TotalTicks + element.Parameters.count * QueryParameterTicks
                End If
            End If
        Next
      End If
      
      DoEvents
      
      
      ' Die Module
      If ExtrudeModules Then
        'SetStatus "Counting modules"
        SetStatus FMT0("CHECK_35")
        ' ProgressForm.Status.Refresh
        
        For Each element In db.Containers
          Select Case element.name
            Case "Modules"
                For Each subelement In element.Documents
                  CurrentObject = subelement.name
                  If NeedsUpdate(subelement.LastUpdated, destfile, "MOD", CurrentObject) Then
                    Totalamount = Totalamount + 1
                    TotalTicks = TotalTicks + ModuleTicks
                  End If
                Next
          End Select
        Next
      End If
      
      DoEvents
      
      
      ' Formularmodule und Formulare
      If ExtrudeFormModules Or ExtrudeForms Then
        SetStatus "Counting forms and form-modules"
        ' ProgressForm.Status.Refresh
        
        For Each element In db.Containers
          Select Case element.name
            Case "Forms"
                For Each subelement In element.Documents
                  CurrentObject = subelement.name
                  If NeedsUpdate(subelement.LastUpdated, destfile, "FRM", CurrentObject) Then
                      appAccess.DoCmd.OpenForm subelement.name, 1 ' acDesign
                      If ExtrudeFormModules Then
                        Totalamount = Totalamount + 1
                        TotalTicks = TotalTicks + FormModuleTicks
                      End If
                      If ExtrudeForms Then
                        ' erst die Formulare selbst
                        Totalamount = Totalamount + 1
    '                    TotalTicks = TotalTicks + FormPropertiesSize * FormPropertiesTicks
                        TotalTicks = TotalTicks + (appAccess.FORMS(subelement.name).Properties.count - FormNegPropertiesSize) * FormNegPropertiesTicks
                        ' Dann die Controls
                        Dim telement
                        For Each telement In appAccess.FORMS(subelement.name)
                          TotalTicks = TotalTicks + (telement.Properties.count - FormControlNegPropertiesSize) * FormControlPropertiesTicks
                        Next
                      End If
                   End If
                Next
          End Select
        Next
      End If
      
      DoEvents
      
      If ExtrudeScripts Then
        'SetStatus "Counting scripts"
        SetStatus FMT0("CHECK_36")
        ' ProgressForm.Status.Refresh
        
        For Each element In db.Containers
          Select Case element.name
            Case "Scripts"
                For Each subelement In element.Documents
                  CurrentObject = subelement.name
                  If NeedsUpdate(subelement.LastUpdated, destfile, "SCR", CurrentObject) Then
                    Totalamount = Totalamount + 1
                    TotalTicks = TotalTicks + ScriptTicks
                  End If
                Next
          End Select
        Next
      End If
      
      DoEvents
      
      ' Die Relations
    '  If ExtrudeRelations Then
    '    For Each element In db.Relations
    '      Totalamount = Totalamount + 1
    '      TotalTicks = TotalTicks + element.Properties.Count
    '      TotalTicks = TotalTicks + element.Fields.Count * RelationFieldsSize
    '    Next
    '  End If
      
      '-------------------------------------------
      ' Jetzt gehts looooos
      '-------------------------------------------
      StartTime = Time
      LastTime = Time
      Ticks = 0
      LastTicks = 0
      
      'Dann die Tabellen
      If ExtrudeTables Then
        'SetStatus "Extracting tables"
        SetStatus FMT0("CHECK_37")
        ' ProgressForm.Status.Refresh
        For i = 0 To db.TableDefs.count - 1
          If (db.TableDefs(i).Attributes And &H80000002) = 0 Then
            If db.TableDefs(i).Updatable = True Then
                CurrentObject = db.TableDefs(i).name
'                Print #3, "!DEX_INCLUDE "; cacheName
                cacheName = BuildCacheName(destfile, "TBL", CurrentObject)
                cache(cacheCnt) = cacheName
                cacheCnt = cacheCnt + 1
                If NeedsUpdate(db.TableDefs(i).LastUpdated, destfile, "TBL", CurrentObject) Then
                  Open cacheName For Output As #1
                    ExtractTable db.TableDefs(i)
                    count = count + 1
                  Close #1
                End If
            End If
          End If
          UpdateStatusOLD
        Next
      End If
      
      TickDebug ("Tables")
      
      ' Und die Abfragen
      If ExtrudeQueries Then
        'SetStatus "Extracting queries"
        SetStatus FMT0("CHECK_38")
        ' ProgressForm.Status.Refresh
        For i = 0 To db.QueryDefs.count - 1
            If Left(db.QueryDefs(i).name, 1) <> "~" Then
                CurrentObject = db.QueryDefs(i).name
'                Print #3, "!DEX_INCLUDE "; cacheName
                cacheName = BuildCacheName(destfile, "QRY", CurrentObject)
                cache(cacheCnt) = cacheName
                cacheCnt = cacheCnt + 1
                If NeedsUpdate(db.QueryDefs(i).LastUpdated, destfile, "QRY", CurrentObject) Then
                  Open cacheName For Output As #1
                    ExtractQuery db.QueryDefs(i)
                    count = count + 1
                    UpdateStatusOLD
                  Close #1
                End If
            End If
        Next
      End If
      
      TickDebug ("Queries")
      
      
      ' Und jetzt die Code-Module extrahieren
      If ExtrudeModules Then
        'SetStatus "Extracting modules"
        SetStatus FMT0("CHECK_39")
        ' ProgressForm.Status.Refresh
        For Each element In db.Containers
            Select Case element.name
              Case "Modules"
                For Each subelement In element.Documents
                  CurrentObject = subelement.name
    '              Debug.Print "Found Module " & subelement.name
                  cacheName = BuildCacheName(destfile, "MOD", CurrentObject)
                  cache(cacheCnt) = cacheName
                  cacheCnt = cacheCnt + 1
                  If NeedsUpdate(subelement.LastUpdated, destfile, "MOD", CurrentObject) Then
                    Open cacheName For Output As #1
                        appAccess.DoCmd.OpenModule subelement.name
                        Dim mdl
                        Set mdl = appAccess.Modules(subelement.name)
                        mdl.Application.Visible = False
                        ExtractModule mdl, False, subelement, "MDB"
                        count = count + 1
                        Ticks = Ticks + ModuleTicks
                        UpdateStatusOLD
                        Set mdl = Nothing
                    Close #1
                  End If
                Next
            End Select
        Next
      End If
      
      ' Formular-Code-Module extrahieren
      If ExtrudeFormModules Or ExtrudeForms Then
        'SetStatus "Extracting forms and form-modules"
        SetStatus FMT0("CHECK_40")
        ' ProgressForm.Status.Refresh
        For Each element In db.Containers
            Select Case element.name
              Case "Forms"
                For Each subelement In element.Documents
                  CurrentObject = subelement.name
    '              Debug.Print "Found Form " & subelement.name
'                  appAccess.DoCmd.OpenForm subelement.name, acDesign
'                  Print #3, "!DEX_INCLUDE "; cacheName
                  cacheName = BuildCacheName(destfile, "FRM", CurrentObject)
                  cache(cacheCnt) = cacheName
                  cacheCnt = cacheCnt + 1
                  If NeedsUpdate(subelement.LastUpdated, destfile, "FRM", CurrentObject) Then
                    Open cacheName For Output As #1
                      If ExtrudeFormModules Then
                        If appAccess.FORMS(subelement.name).hasmodule Then
                          Set mdl = appAccess.FORMS(subelement.name).Module
                          mdl.Application.Visible = False
                          ExtractModule mdl, True, subelement, "MDB"
                        End If
                        count = count + 1
                        Ticks = Ticks + FormModuleTicks
                        UpdateStatusOLD
                        Set mdl = Nothing
                      End If
                      If ExtrudeForms Then
                        Print #1, "!DEX_BEGIN_BLOCK "; subelement.name
                        Print #1, "!DEX_TYPE FORM"
                        
                        ' Das Formular selbst
                        Call ExtractProperties(appAccess.FORMS(subelement.name).Properties, _
                          appAccess.FORMS(subelement.name).name, _
                          FormNegProperties, "FORM", True)
    '                    Ticks = Ticks + FormPropertiesSize * FormPropertiesTicks
                        Ticks = Ticks + (appAccess.FORMS(subelement.name).Properties.count - FormNegPropertiesSize) * FormNegPropertiesTicks
                        
                        UpdateStatusOLD
                        
                        ' und die controls
                        Dim frm
                        Set frm = appAccess.FORMS(subelement.name)
                        ExtractFormControls (frm)
                        Set frm = Nothing
                        UpdateStatusOLD
                        Print #1, "!DEX_END_BLOCK"
                      End If
                    Close #1
                  End If
                Next
            End Select
        Next
      End If
      
      TickDebug ("Modules")
      
      ' Scripte extrahieren
      If ExtrudeScripts Then
        'SetStatus "Extracting scripts"
        SetStatus FMT0("CHECK_41")
        ' ProgressForm.Status.Refresh
        For Each element In db.Containers
            Select Case element.name
              Case "Scripts"
'                Print #3, "!DEX_INCLUDE "; cacheName
                For Each subelement In element.Documents
                    CurrentObject = subelement.name
                    cacheName = BuildCacheName(destfile, "SCR", CurrentObject)
                    cache(cacheCnt) = cacheName
                    cacheCnt = cacheCnt + 1
                    If NeedsUpdate(subelement.LastUpdated, destfile, "SCR", CurrentObject) Then
                      Open cacheName For Output As #1
        '              Debug.Print "Found Script " & subelement.name
'                      Set mdl = appAccess.Modules(subelement.name).Module
        '              ExtractModule mdl
                      Print #1, "!DEX_BEGIN_BLOCK "; subelement.name
                      Print #1, "!DEX_TYPE SCRIPT"
                      Print #1, "!DEX_END_BLOCK"
                      count = count + 1
                      Ticks = Ticks + ScriptTicks
                      UpdateStatusOLD
                      Set mdl = Nothing
                      Close #1
                    End If
                Next
            End Select
        Next
      End If
      
      TickDebug ("Scripts")
      
      
      ' Die Relations
    '  If ExtrudeRelations Then
    '    Print #1, "!DEX_BEGIN_RELATIONS"
    '    For i = 0 To db.Relations.Count - 1
    '      ExtractRelation db.Relations(i)
    '      Count = Count + 1
    '      UpdateStatusOLD
    '    Next
    '    Print #1, "!DEX_END_RELATIONS"
    '  End If
      
    '  TickDebug ("Relations")
      
      'SetStatus "Shutting down DB"
      SetStatus FMT0("CHECK_42")
      ' ProgressForm.Status.Refresh
      
      db.Close
      
      appAccess.CloseCurrentDatabase
      Set appAccess = Nothing
      
      If cacheCnt > 0 Then
        'SetStatus "Building file"
        SetStatus FMT0("CHECK_43")
        ' ProgressForm.Status.Refresh
        
        Open destfile For Output As #1
        Dim cnt As Integer
        For cnt = 0 To cacheCnt - 1
'            Debug.Print cache(cnt)
            Open cache(cnt) For Binary Access Read As #3
              Print #1, Input(MyFileLen(cache(cnt)), #3)
            Close #3
        Next cnt
        
        Close #1
      End If
'      Debug.Print "Ticks: " & Ticks & " Totalticks: " & TotalTicks
      
  ' ProgressForm.Hide
'  Unload ProgressForm
'  Set ProgressForm = Nothing
  
  Close #2
  
  Exit Sub
'-----------------------------------------------------
handleError:
    Dim errstr As String
'    errstr = "Error (" & ProgressForm.Status & ") Object: " & CurrentObject & " - " & Err.Description & "(ErrNr: " & Err.Number & ")"
    Debug.Print errstr
    If ErrorFileOpen Then
        Print #2, errstr
    End If
    Resume Next
'-----------------------------------------------------

End Sub

Function ExtractTableFields(fld As Fields, name As String)
  On Error Resume Next

  Dim element
  Dim dummy As Integer
  ' Felder ausgeben
  Print #1, "!DEX_BEGIN_TABLE_FIELDS "; name
  For Each element In fld
    With element
      Call ExtractProperties(.Properties, .name, TableElementProperties, "TABLE_FIELD")
    End With
  Next element
  Ticks = Ticks + fld.count * TableElementPropertiesSize * TableFieldTicks
  UpdateStatusOLD
  Print #1, "!DEX_END_TABLE_FIELDS "; name

End Function
  
  
Private Sub ExtractQueryFields(fld As Fields, name As String)
  On Error Resume Next

  Dim element
  ' Felder ausgeben
  Print #1, "!DEX_BEGIN_QUERY_FIELDS "; name
  For Each element In fld
    With element
      DoMyEvents
      Print #1, "!DEX_BEGIN_QUERY_FIELD "; .name
      Dim i
      i = 0
      While QueryDefFields(i) <> "-"
        Print #1, "!DEX_FN "; QueryDefFields(i)
'        Print #1, "!DEX_FT "; GetVartypeText(.Properties(QueryDefFields(i)).Type)
        Print #1, "!DEX_FV "; .Properties(QueryDefFields(i)).value
        i = i + 1
      Wend
      Print #1, "!DEX_END_QUERY_FIELD"
    End With
  Next element
  Ticks = Ticks + fld.count * QueryDefFieldsSize * QueryFieldTicks
  UpdateStatusOLD
  Print #1, "!DEX_END_QUERY_FIELDS"

End Sub
  
Sub ExtractRelationFields(fld As Fields, name As String)
  On Error Resume Next

  Dim element
  ' Felder ausgeben
  Print #1, "!DEX_BEGIN_RELATION_FIELDS "; name
  For Each element In fld
    DoMyEvents
    With element
      Print #1, "!DEX_BEGIN_RELATION_FIELD "; .name
      Dim i
      While RelationFields(i) <> "-"
        Print #1, "!DEX_RN "; RelationFields(i)
'        Print #1, "!DEX_RT "; GetVartypeText(.Properties(RelationFields(i)).Type)
        Print #1, "!DEX_RV "; .Properties(RelationFields(i)).value
        i = i + 1
      Wend
      Print #1, "!DEX_END_RELATION_FIELD"
    End With
  Next element
  Ticks = Ticks + fld.count * RelationFieldsSize
  UpdateStatusOLD
  Print #1, "!DEX_END_RELATION_FIELDS"
End Sub


Private Sub ExtractTable(element As TableDef)
    On Error Resume Next
    Dim i As Integer
    Dim subelement
  
    Print #1, "!DEX_BEGIN_BLOCK "; element.name
    Print #1, "!DEX_TYPE TABLE"
    
    ' Properties ausgeben
    Call ExtractProperties(element.Properties, element.name, EmptyList, "TABLE")
    Ticks = Ticks + element.Properties.count * TablePropertiesTicks
    UpdateStatusOLD
    
    ' Indizes der Tabelle schreiben
    Print #1, "!DEX_BEGIN_TABLE_INDEXES "; element.name
    For Each subelement In element.Indexes
      With subelement
        Print #1, "!DEX_INDEX " & .name
        Print #1, "!DEX_INDEX_TYPE " & .Fields
      End With
    Next subelement
    Print #1, "!DEX_END_TABLE_INDEXES"
    Ticks = Ticks + element.Indexes.count * TableIndexesTicks
    UpdateStatusOLD
    
    ' Felder ausgeben
    ExtractTableFields element.Fields, element.name
    
    Print #1, "!DEX_END_BLOCK "

End Sub

Sub ExtractQuery(element As QueryDef)
  On Error Resume Next
  Dim i As Integer
  
  With element
  
    Print #1, "!DEX_BEGIN_BLOCK "; .name
    Print #1, "!DEX_TYPE SQL_QUERY"
  
    If UseDefinedDesc Then
      Print #1, "!DEX_QUERY_DESC " & .Properties("Description")
      Print #1, "!DEX_CHANGES " & .LastUpdated
      Print #1, "!DEX_QUERY_CONNECT " & .Connect
      Print #1, "!DEX_QUERY_SQL " & .Sql
    End If
  
    ' Properties ausgeben
    Call ExtractProperties(.Properties, .name, EmptyList, "QUERY")
    Ticks = Ticks + .Properties.count * QueryPropertyTicks
    UpdateStatusOLD
  
    ' Felder ausgeben
    ExtractQueryFields .Fields, .name
    
    ' Parameter schreiben
    Print #1, "!DEX_BEGIN_PARAMETERS "; .name
      Dim subelement
      For Each subelement In element.Parameters
        DoMyEvents
        With subelement
          Print #1, "!DEX_BEGIN_PARAMETER " & .name
'          Print #1, "!DEX_PARAMETER_TYPE "; GetVartypeText(.Type)
          Print #1, "!DEX_END_PARAMETER"
        End With
      Next subelement
    Print #1, "!DEX_END_PARAMETERS"
    Ticks = Ticks + element.Parameters.count * QueryParameterTicks
  
  End With
  Print #1, "!DEX_END_BLOCK "
End Sub



Sub ExtractRelation(element As Relation)
  On Error Resume Next
  Dim i As Integer
  
  With element
  
    Print #1, "!DEX_BEGIN_BLOCK "; .name
    Print #1, "!DEX_TYPE RELATION"
  
    If UseDefinedDesc Then
      Print #1, "!DEX_RELATION_DESC " & .Properties("Description")
      Print #1, "!DEX_RELATION_TABLE " & .Table
      Print #1, "!DEX_RELATION_FOREIGN_TABLE " & .ForeignTable
    End If
    
    ' Properties ausgeben
    Call ExtractProperties(.Properties, element.name, EmptyList, "RELATION")
    Ticks = Ticks + .Properties.count
    UpdateStatusOLD
  
    ' Felder ausgeben
    ExtractRelationFields element.Fields, element.name
  
  End With
  Print #1, "!DEX_END_BLOCK "
End Sub


Function GetControlTypeText(controltype As Integer) As String
  GetControlTypeText = "Unknown"
'  Select Case controltype
'    Case acLabel
'      GetControlTypeText = "Label"
'    Case acRectangle
'      GetControlTypeText = "Rectangle"
'    Case acLine
'      GetControlTypeText = "Line"
'    Case acImage
'      GetControlTypeText = "Image"
'    Case acCommandButton
'      GetControlTypeText = "CommandButton"
'    Case acOptionButton
'      GetControlTypeText = "OptionButton"
'    Case acCheckBox
'      GetControlTypeText = "CheckBox"
'    Case acOptionGroup
'      GetControlTypeText = "OptionGroup"
'    Case acBoundObjectFrame
'      GetControlTypeText = "BoundObjectFrame"
'    Case acTextBox
'      GetControlTypeText = "TextBox"
'    Case acListBox
'      GetControlTypeText = "ListBox"
'    Case acComboBox
'      GetControlTypeText = "ComboBox"
'    Case acSubform
'      GetControlTypeText = "SubForm"
'    Case acObjectFrame
'      GetControlTypeText = "ObjectFrame"
'    Case acPageBreak
'      GetControlTypeText = "PageBreak"
'    Case acPage
'      GetControlTypeText = "Page"
'    Case acCustomControl
'      GetControlTypeText = "CustomControl"
'    Case acToggleButton
'      GetControlTypeText = "ToggleButton"
'    Case acTabCtl
'      GetControlTypeText = "TabControl"
'  End Select
End Function

Function GetVartypeText(vartype As Integer) As String
  GetVartypeText = "Unknown"
  Select Case vartype
    Case vbEmpty
      GetVartypeText = "vbEmpty"
    Case vbNull
      GetVartypeText = "vbNull"
    Case vbInteger
      GetVartypeText = "vbInteger"
    Case vbLong
      GetVartypeText = "vbLong"
    Case vbSingle
      GetVartypeText = "vbSingle"
    Case vbDouble
      GetVartypeText = "vbDouble"
    Case vbCurrency
      GetVartypeText = "vbCurrency"
    Case vbDate
      GetVartypeText = "vbDate"
    Case vbString
      GetVartypeText = "vbString"
    Case vbObject
      GetVartypeText = "vbObject"
    Case vbError
      GetVartypeText = "vbError"
    Case vbBoolean
      GetVartypeText = "vbBoolean"
    Case vbVariant
      GetVartypeText = "vbVariant"
    Case vbDataObject
      GetVartypeText = "vbDataObject"
    Case vbDecimal
      GetVartypeText = "vbDecimal"
    Case vbByte
      GetVartypeText = "vbByte"
    Case vbArray
      GetVartypeText = "vbArray"
  End Select
End Function

Function CountLOC(ff As Integer, mdl, ByRef totalVBALineAmount As Long, ByRef totalVBACommentsAmount As Long, ByRef checksum As Long, modName As String, ByRef xlsarr As XLScriptArray2D, txtExtension As String, ByRef partChecksum As Long) As Long
  partChecksum = 0
  Dim i As Integer
  Dim loc As Integer
  Dim filledLines As Long
  
  loc = mdl.CountOfLines
  
  Dim tSource As String
  
  For i = 1 To loc
    Dim pos As Long
          
    Dim tstr As String
    pos = InStr(RemoveStrings(mdl.Lines(i, 1)), "'")
    
    If pos > 0 Then
      If Len(Mid(mdl.Lines(i, 1), pos + 1)) >= 8 Then
        totalVBACommentsAmount = totalVBACommentsAmount + 1
      End If
      If pos > 1 Then
        tstr = Trim(Left(RemoveStrings(mdl.Lines(i, 1)), pos - 1))
      End If
    Else
      tstr = Trim(mdl.Lines(i, 1))
    End If
    
    If Len(tstr) > 0 Then
      totalVBALineAmount = totalVBALineAmount + 1
      filledLines = filledLines + 1
    End If
    
    tSource = tSource & Trim(mdl.Lines(i, 1)) & vbCrLf
  
  Next
  
  partChecksum = AddChecksumAndVar(ff, modName, checksum, tSource, xlsarr, txtExtension)
  
  If filledLines = 2 And mdl.Lines(1, 1) = "Option Compare Database" And mdl.Lines(2, 1) = "Option Explicit" Then
      totalVBALineAmount = totalVBALineAmount - 2
      filledLines = filledLines - 2
  End If
  CountLOC = filledLines
End Function

Function RemoveStrings(ByVal txt As String) As String
  Dim pos As Long
  Dim pos2 As Long
  Do
    pos = InStr(txt, Chr(34))
    If pos <= 0 Then Exit Do
    pos2 = InStr(pos + 1, txt, Chr(34))
    If pos2 <= 0 Then Exit Do
    Dim tstr As String
    tstr = ""
    If pos > 1 Then tstr = Left(txt, pos - 1)
    If pos2 < Len(txt) Then tstr = tstr & Mid(txt, pos2 + 1)
    txt = tstr
  Loop
  RemoveStrings = txt
End Function

Sub ExtractModule(mdl, isForm As Boolean, obj, extType As String, Optional modtype As Long = -1)

  Exit Sub
  
  
  Print #1, "!DEX_BEGIN_BLOCK "; mdl.name
  If isForm Then
'    Debug.Print "Extracting Form " & mdl.name
    Print #1, "!DEX_TYPE FORM_CODE"
  Else
    If extType = "MDB" Then
      Select Case mdl.Type
        Case 0 ' acStandardModule
  '        Debug.Print "Extracting Module " & mdl.name
          Print #1, "!DEX_TYPE MODULE"
        Case 1 ' acClassModule
  '        Debug.Print "Extracting Class " & mdl.name
          Print #1, "!DEX_TYPE CLASS"
        Case Else
          Exit Sub
      End Select
    ElseIf extType = "XLS" Then
      If modtype = 2 Then
        Print #1, "!DEX_TYPE CLASS"
      ElseIf modtype = 3 Then
        Print #1, "!DEX_TYPE FORM_CODE"
      Else
        Print #1, "!DEX_TYPE MODULE"
      End If
    End If
  End If
  
  If extType = "MDB" Then
    Print #1, "!DEX_PN DateCreated"
    Print #1, "!DEX_PV " & obj.Properties("DateCreated")
    Print #1, "!DEX_PN LastUpdated"
    Print #1, "!DEX_PV " & obj.Properties("LastUpdated")
  End If
  
  Dim i As Integer
  Dim loc As Integer
  Dim code As String
  Dim tstr As String
  
  loc = mdl.CountOfLines
  For i = 1 To loc
    DoMyEvents
    Dim pos As Long
    
    ' Formulare holen
    If extType = "MDB" Then
      pos = InStr(mdl.Lines(i, 1), "DoCmd.OpenForm ")
      ' Dann holen wir auch die DoCmd.OpenForm
      If pos > 0 Then
          pos = pos + Len("DoCmd.OpenForm ")
          tstr = Mid(mdl.Lines(i, 1), pos)
          If Left(tstr, 1) = Chr(&H22) Then
              pos = InStr(2, tstr, Chr(&H22))
              If pos > 0 Then
                  Print #1, "!DEX_USES |FORM "; Mid(tstr, 2, pos - 2)
              End If
          End If
      End If
      
      ' Macros holen
      pos = InStr(mdl.Lines(i, 1), "DoCmd.RunMacro ")
      ' Dann holen wir auch die DoCmd.OpenForm
      If pos > 0 Then
          pos = pos + Len("DoCmd.RunMacro ")
          tstr = Mid(mdl.Lines(i, 1), pos)
          If Left(tstr, 1) = Chr(&H22) Then
              pos = InStr(2, tstr, Chr(&H22))
              If pos > 0 Then
                  Print #1, "!DEX_USES |MACRO "; Mid(tstr, 2, pos - 2)
              End If
          End If
      End If
      
      ' Reports holen
      pos = InStr(mdl.Lines(i, 1), "DoCmd.OpenReport ")
      ' Dann holen wir auch die DoCmd.OpenForm
      If pos > 0 Then
          pos = pos + Len("DoCmd.OpenReport ")
          tstr = Mid(mdl.Lines(i, 1), pos)
          If Left(tstr, 1) = Chr(&H22) Then
              pos = InStr(2, tstr, Chr(&H22))
              If pos > 0 Then
                  Print #1, "!DEX_USES |REPORT "; Mid(tstr, 2, pos - 2)
              End If
          End If
      End If
    End If
    
    ' Snipits bearbeiten
    If InStr(mdl.Lines(i, 1), "'// SNIPIT") > 0 Then
      Print #1, "!DEX_LINE "; i
      Print #1, "!DEX_SNIPIT"
      i = i + 1
      While InStr(mdl.Lines(i, 1), "'// SNIPIT") = 0
        Print #1, mdl.Lines(i, 1)
        i = i + 1
      Wend
      Print #1, "!DEX_SNIPIT"
    End If
    
    Dim tPos As Long
    If InStr(mdl.Lines(i, 1), "'// TODO") > 0 Or _
      InStr(mdl.Lines(i, 1), "'// TBD") > 0 Or _
      InStr(mdl.Lines(i, 1), "'// IDEA") > 0 Or _
      InStr(mdl.Lines(i, 1), "'// REMINDER") > 0 Or _
      InStr(mdl.Lines(i, 1), "'// KNOWN BUG") > 0 Or _
      InStr(mdl.Lines(i, 1), "'// NOTE") > 0 _
      Then
      Print #1, "!DEX_LINE "; i
      tPos = InStr(mdl.Lines(i, 1), "'// ")
      Print #1, Mid(mdl.Lines(i, 1), tPos + 1)
      i = i + 1
      While InStr(mdl.Lines(i, 1), "'// ") <> 0
        tPos = InStr(mdl.Lines(i, 1), "'// ")
        Print #1, Mid(mdl.Lines(i, 1), tPos + 1)
        i = i + 1
      Wend
    End If
    
    
    If InStr(mdl.Lines(i, 1), "'/*|") > 0 Then
      Print #1, "!DEX_LINE "; i
      Print #1, Mid(mdl.Lines(i, 1), 2)
      Do
        i = i + 1
        Print #1, Mid(mdl.Lines(i, 1), 2)
      Loop While InStr(mdl.Lines(i, 1), "*/") = 0
      ' Und jetzt noch den Funktionskopf besorgen!
      If i < loc Then
          If (InStr(mdl.Lines(i + 1, 1), "Sub") <> 0) Or _
             (InStr(mdl.Lines(i + 1, 1), "Function") <> 0) Then
            Do
              i = i + 1
              Print #1, mdl.Lines(i, 1)
            Loop While InStr(mdl.Lines(i, 1), ")") = 0
          End If
      End If
'    ElseIf (InStr(mdl.Lines(i, 1), "Sub") <> 0) Or _
'           (InStr(mdl.Lines(i, 1), "Function") <> 0) Then
'        Print #1, "!DEX_FUNC " & mdl.Lines(i, 1)
    End If
  Next
  
  Print #1, "!DEX_END_BLOCK"

End Sub

Public Sub ExtractProperties(element As Variant, name As String, propNames As Variant, _
  propNameDex As String, Optional useAsNegList As Boolean = False)
  On Error Resume Next
  If Not UseDefinedDesc Then
    
    Print #1, "!DEX_BEGIN_" & propNameDex & "_PROPERTIES "; name
    ' Properties ausgeben
    Dim i
    If propNames(0) = "-" Then
      For i = 0 To element.count - 1
        With element(i)
            DoMyEvents
            Print #1, "!DEX_PN "; .name
'            Print #1, "!DEX_PT "; GetVartypeText(.Type)
            If .name = "Type" Then
                Print #1, "!DEX_PV "; GetVartypeText(.value)
            ElseIf .name = "ControlType" Then
                Print #1, "!DEX_PV "; GetControlTypeText(.value)
            Else
                Print #1, "!DEX_PV "; .value
            End If
        End With
      Next i
    Else
      If useAsNegList Then
          For i = 0 To element.count - 1
            With element(i)
                DoMyEvents
                
                Dim found As Boolean
                Dim q As Integer
                found = False
                q = 0
                While (propNames(q) <> "-")
                  If .name = propNames(q) Then
                    found = True
                  End If
                  q = q + 1
                Wend
                If Not found Then
                    Print #1, "!DEX_PN "; .name
        '            Print #1, "!DEX_PT "; GetVartypeText(.Type)
                    If .name = "Type" Then
                        Print #1, "!DEX_PV "; GetVartypeText(.value)
                    ElseIf .name = "ControlType" Then
                        Print #1, "!DEX_PV "; GetControlTypeText(.value)
                    Else
                        Print #1, "!DEX_PV "; .value
                    End If
                End If
            End With
          Next i
      Else
          While (propNames(i) <> "-")
            DoMyEvents
            Print #1, "!DEX_PN "; propNames(i)
    '        Print #1, "!DEX_PT "; GetVartypeText(element(propNames(i)).Type)
            If propNames(i) = "Type" Then
                Print #1, "!DEX_PV "; GetVartypeText(element(propNames(i)).value)
            ElseIf propNames(i) = "ControlType" Then
                Print #1, "!DEX_PV "; GetControlTypeText(propNames(i).value)
            Else
                Print #1, "!DEX_PV "; element(propNames(i)).value
            End If
            i = i + 1
          Wend
        End If
    End If
      Print #1, "!DEX_END_" & propNameDex & "_PROPERTIES "
  End If
End Sub


Sub ExtractFormControls(frm As Object)
  Dim element
  Dim subelement
  
  For Each element In frm
      DoMyEvents
'      Print #1, "!DEX_BEGIN_QUERY_FIELD "; .name
'      Print #1, "!DEX_END_QUERY_FIELD"
    Call ExtractProperties(element.Properties, _
        element.name, _
        FormControlNegProperties, "FORM_CONTROLS", True)
      
    Ticks = Ticks + (element.Properties.count - FormControlNegPropertiesSize) * FormControlPropertiesTicks
    UpdateStatusOLD
  
  Next element

End Sub


Sub GenerateResultWorkbook(ByRef reswb As Excel.Workbook)
    
    Dim i As Long
    
    Dim xl As Excel.Application
    Set xl = New Excel.Application
'    xl.Visible = True
    
    Dim resFile As String
    
    If G_ResfileTemplate <> "" Then
      resFile = gTranslation.GetLocalizedFile(G_ResfileTemplate)
      xl.EnableEvents = False
      Set reswb = xl.Workbooks.Add(resFile)
      xl.EnableEvents = True
    ElseIf G_Resfile <> "" Then
      resFile = gTranslation.GetLocalizedFile(G_Resfile)
      xl.EnableEvents = False
      Set reswb = xl.Workbooks.Open(G_Resfile)
      xl.EnableEvents = True
    ElseIf FileExists(ThisWorkbook.path & "\ACC-Res_Indiv.xltx") Then
      resFile = gTranslation.GetLocalizedFile(ThisWorkbook.path & "\ACC-Einzelanalyse_Indiv.xltx")
      xl.EnableEvents = False
      Set reswb = xl.Workbooks.Add(resFile)
      xl.EnableEvents = True
    Else
      resFile = gTranslation.GetLocalizedFile(ThisWorkbook.path & "\ACC-Einzelanalyse.xltx")
      xl.EnableEvents = False
      Set reswb = xl.Workbooks.Add(resFile)
      xl.EnableEvents = True
    End If
    
    Helpers.ACCreateHeaderAndFooter xl.ActiveSheet

    Set xl = Nothing
End Sub

Sub SetStatus(st As String)
  m_Status = st
  ' ProgressForm.Status = "Building file"
  ' ProgressForm.Status.Refresh
End Sub

Function ReadGroups() As Boolean

  Set m_VarGroups = Nothing
  Set m_VarGroups = New Collection
  ReadGroups = False
  On Error GoTo errReadGroups
  
  Dim resFile As String
  resFile = ThisWorkbook.path & "\ACC-Res.xls"
  Dim oxlwbook As Excel.Workbook
  'Set oxlwbook = Workbooks.Open(ThisWorkbook.path & "\ACC-Res.xls", False, True, , "13d4a!Psw(7dd)=", , True)
  Set oxlwbook = Workbooks.Open(resFile, False, True, , "13d4a!Psw(7dd)=", , True)
  
  Dim y As Long
  y = 2
  Dim lastVarGroup As VarGroup
  
  Do While Not IsEmpty(oxlwbook.Sheets("Groups").Cells(y, 3)) Or _
           Not IsEmpty(oxlwbook.Sheets("Groups").Cells(y + 1, 3)) Or _
           Not IsEmpty(oxlwbook.Sheets("Groups").Cells(y + 2, 3))
    
    ' Neue Gruppe
    If Not IsEmpty(oxlwbook.Sheets("Groups").Cells(y, 1)) Then
      Set lastVarGroup = New VarGroup
      lastVarGroup.Init
      lastVarGroup.m_Name = oxlwbook.Sheets("Groups").Cells(y, 1)
      lastVarGroup.m_Type = oxlwbook.Sheets("Groups").Cells(y, 2)
      m_VarGroups.Add lastVarGroup
    End If
    
    If Not IsEmpty(oxlwbook.Sheets("Groups").Cells(y, 3)) Then
      Dim v As Var
      Set v = New Var
      v.m_Name = oxlwbook.Sheets("Groups").Cells(y, 3)
      v.m_Type = oxlwbook.Sheets("Groups").Cells(y, 4)
      v.m_Translation = oxlwbook.Sheets("Groups").Cells(y, 5)
      lastVarGroup.m_Vars.Add v
    End If
    
    y = y + 1
  Loop
  
  oxlwbook.Close False
  Set oxlwbook = Nothing
  ReadGroups = True
  Exit Function
errReadGroups:
End Function

Function GetVarGroup(name As String) As Long
  GetVarGroup = 0
  Dim item As VarGroup
  For Each item In m_VarGroups
    GetVarGroup = GetVarGroup + 1
    If item.m_Name = name Then Exit Function
  Next item
End Function


Sub GetDefsAndResultsheets()
  On Error GoTo 0
  
  Dim oxlwbook As Excel.Workbook
  
  Dim resFile As String
  resFile = ThisWorkbook.path & "\ACC-Res.xls"
  'Set oxlwbook = Workbooks.Open(ThisWorkbook.path & "\ACC-Res.xls", False, True, , "13d4a!Psw(7dd)=", , True)
  Set oxlwbook = Workbooks.Open(resFile, False, True, , "13d4a!Psw(7dd)=", , True)
  Dim y As Long
  y = 2
  
  
  Dim c As Range
  'Set c = oxlwbook.Sheets("Defs").Cells.Find(What:="Definitionen", LookIn:=xlValues, LookAt:= _
  '      xlWhole, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=True)
  Set c = TranslationFindCells(oxlwbook.Sheets("Defs"), Array("Definitionen", "Definitions"), LookIn:=xlValues, LookAt:= _
        xlWhole, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=True)
  If Not c Is Nothing Then
    y = c.Row + 1
    Dim f As XLFld
    Do While Not IsEmpty(oxlwbook.Sheets("Defs").Cells(y, 1))
    
      Select Case oxlwbook.Sheets("Defs").Cells(y, 2)
        Case "Field"
          Set f = New XLFld
          f.Init oxlwbook.Sheets("Defs").Cells(y, 1)
          y = y + 1
          Do While Not IsEmpty(oxlwbook.Sheets("Defs").Cells(y, 3))
            Dim fv As XLFldVal
            Set fv = New XLFldVal
            fv.m_Value = CLng(oxlwbook.Sheets("Defs").Cells(y, 2).value)
            fv.m_Txt = oxlwbook.Sheets("Defs").Cells(y, 3).value
            f.m_Col.Add fv
            y = y + 1
          Loop
          m_Flds.Add f, f.m_Name
      End Select
      y = y + 1
    Loop
  End If
  
  oxlwbook.Close False
  Set oxlwbook = Nothing
End Sub


Function CountReadable(ref) As Boolean
  On Error GoTo notReadable
  Dim i As Long
  i = ref.count
  CountReadable = True
  Exit Function
  
notReadable:
  CountReadable = False
End Function

Public Function AccessDBHasPassword(path As String) As Boolean
  Dim db As DAO.Database
  
  If Dir(path) = "" Then
  'Return 0 if file does not exist
     AccessDBHasPassword = False
     Exit Function
  End If
  
  On Error GoTo errorline
  SaveSetting _
         appname:="Stromwerken", _
         Section:="AccessTracker", _
         Key:="IgnoreThisOne", _
         setting:="True"
  
'  Dim ws As Workspace
'  Set ws = DBEngine.Workspaces(0)
'  Set db = ws.OpenDatabase(Path)
'  ado.opendatanbase
'  db.Close
'  Set ws = Nothing




   Dim cn As Object
  
   
   ' Set the provider, open the database,
   'and create a new table called tblSequential.
   'Change "findseek.mdb" to "findseek.accdb" for Access 2007.
   'Change the Provider to "Microsoft.ACE.OLEDB.12.0" for
   'Access 2007 ACCDB databases.
   
  Set cn = CreateObject("ADODB.Connection")
  If theAccessScannerVersion >= 12 Then
    cn.Provider = "Microsoft.ACE.OLEDB.12.0"
  Else
    cn.Provider = "Microsoft.Jet.OLEDB.4.0"
  End If
  cn.Open "Data Source=" & path
'  cn.Open "Data Source=d:\development\Temp\ACCAnalyse.accdb"
  
  AccessDBHasPassword = False
  cn.Close
  Set cn = Nothing
  
  SaveSetting appname:="Stromwerken", Section:="AccessTracker", Key:="IgnoreThisOne", setting:="False"
  
  Exit Function

errorline:
      
  AccessDBHasPassword = True
  Set cn = Nothing
'  Set ws = Nothing
  SaveSetting appname:="Stromwerken", Section:="AccessTracker", Key:="IgnoreThisOne", setting:="False"
  Exit Function
End Function

Function GetAccessDBNoAutoexec(ByVal strMDBPath As String, PW As String) As Boolean


    On Error GoTo ErrHandler
    
    Dim TIdSrc As Long, TIdDest As Long
    Dim abytCodesSrc(0 To 255) As Byte
    Dim abytCodesDest(0 To 255) As Byte

    If (Len(Dir$(strMDBPath, vbNormal)) = 0) Then
        Err.Raise 53
    End If

    With m_App
        SetDbBypass G_AnalyseFile, True
        .Visible = True

        ' attach to process
        TIdSrc = GetWindowThreadProcessId( _
                            Application.hwnd, ByVal 0)
        TIdDest = GetWindowThreadProcessId( _
                            .hWndAccessApp, ByVal 0)
                
        If CBool(AttachThreadInput(TIdSrc, TIdDest, True)) Then
            Call SetForegroundWindow(.hWndAccessApp)
            Call SetFocusAPI(.hWndAccessApp)
            
            ' Set Shift state
            Call GetKeyboardState(abytCodesSrc(0))
            Call GetKeyboardState(abytCodesDest(0))
            abytCodesDest(VK_SHIFT) = 128
            Call SetKeyboardState(abytCodesDest(0))
        
            ' Open a mdb with Autoexec
            SaveSetting appname:="Stromwerken", Section:="AccessTracker", Key:="IgnoreThisOne", setting:="True"
            Call .OpenCurrentDatabase(strMDBPath, True, PW)
            
            ' Revert back keyboard state
            Call SetKeyboardState(abytCodesSrc(0))
        End If
        ' release
        Call AttachThreadInput(TIdSrc, TIdDest, False)
        Call SetForegroundWindow(Application.hwnd)
        Call SetFocusAPI(Application.hwnd)
        ClearMRU strMDBPath
    End With
    
    If m_App.CurrentDb Is Nothing Then
      GetAccessDBNoAutoexec = False
    Else
      GetAccessDBNoAutoexec = True
    End If

    Exit Function
ErrHandler:
    If Not AR_UseDB Then
      'MsgBox "Err: " & Err.Description
      MsgBox FMT1("CHECK_50", Err.Description)
      If (TIdDest) Then Call AttachThreadInput(TIdSrc, TIdDest, False)
      Call SetForegroundWindow(Application.hWndAccessApp)
      With Err
          .Raise .Number, .Source, .Description, .HelpFile, .HelpContext
      End With
    Else
      'AddStatus "FEHLER: " & Err.Description
      AddStatus FMT1("CHECK_51", Err.Description)
    End If
    
End Function

Public Sub ClearMRU(ByVal fname As String)
On Error GoTo nogo
Const HKEY_CURRENT_USER = &H80000001

Dim strComputer: strComputer = "."
Dim objReg: Set objReg = GetObject("winmgmts:{impersonationLevel=impersonate}!\\" & strComputer & "\root\default:StdRegProv")
Dim strKeyPath: strKeyPath = "SOFTWARE\Microsoft\Office"
Dim arrSubKeys

objReg.EnumKey HKEY_CURRENT_USER, strKeyPath, arrSubKeys
Dim subkey
Dim arrChildKeys
Dim arrTypes
Dim childkey
For Each subkey In arrSubKeys
    If Right(subkey, 2) = ".0" Then
        objReg.EnumValues HKEY_CURRENT_USER, strKeyPath & "\" & subkey & "\Access\File MRU", arrChildKeys, arrTypes
        If IsArray(arrChildKeys) Then
            For Each childkey In arrChildKeys
              
              Dim value
              objReg.getStringValue HKEY_CURRENT_USER, strKeyPath & "\" & subkey & "\Access\File MRU", childkey, value
              Debug.Print childkey & " = " & value
              If InStr(value, fname) > 0 Then
                objReg.DeleteValue HKEY_CURRENT_USER, strKeyPath & "\" & subkey & "\Access\File MRU", childkey
              End If
            Next
        End If
    End If
Next
Set objReg = Nothing
Exit Sub
nogo:
End Sub


Function OpenAnalyzeDB(ByVal fname As String, ByVal oriname As String) As Boolean
    On Error GoTo noOpen

    Dim PW As String
    If AccessDBHasPassword(fname) Then
      ' XLScriptAddSimpleVar "STATUS", "Datei Passwortgesch|fffd|tzt"
      ' XLScriptAddSimpleVar "STATUSID", "5"
      If AR_UseDB = True Then
        'AddStatus "*** Die Datenbank ist mit einem Datei-|fffd|ffnen-Passwort gesch|fffd|tzt und kann deshalb nicht analysiert werden!"
        'AddStatus FMT0("CHECK_44")
        'Exit Function
        PW = GetFilePassword(G_Conn, oriname)
        
        If PW = "" Then
          XLScriptAddSimpleVar "STATUS", "Datei Passwortgesch|fffd|tzt"
          XLScriptAddSimpleVar "STATUSID", "5"
          'AddStatus "*** Die Datenbank ist mit einem Datei-|fffd|ffnen-Passwort gesch|fffd|tzt und kann deshalb nicht analysiert werden!"
          AddStatus FMT0("CHECK_44")
          Exit Function
        End If
      End If
      
      If Not AR_UseDB Then
        If PW = "" Then
          'pw = InputBox("Die Datenbank ist mit einem Datei-|fffd|ffnen-Passwort gesch|fffd|tzt. Bitte geben Sie das Passwort ein", "Access-Checker")
          PW = InputBox(FMT0("CHECK_45"), FMT0("MAIN_1"))
        
          If PW = "" Then
            Exit Function
          End If
        End If
      End If
    End If
    
    OpenAnalyzeDB = GetAccessDBNoAutoexec(fname, PW)
    
    Exit Function
    
noOpen:
'  XLScriptAddSimpleVar "STATUS", "Datei Passwortgesch|fffd|tzt"
'  XLScriptAddSimpleVar "STATUSID", "1"
  Dim errstr As String
'    errstr = "Error (" & ProgressForm.Status & ") Object: " & CurrentObject & " - " & Err.Description & "(ErrNr: " & Err.Number & ")"
  'errstr = "Error: (" & m_Status & ") Object: " & CurrentObject & " - " & Err.Description & "(ErrNr: " & Err.Number & ")"
  errstr = FMT4("CHECK_24", m_Status, CurrentObject, Err.Description, Err.Number)
  XLScriptAddLogEntry errstr
  OpenAnalyzeDB = False

End Function


Function ConnectExists(connectstring As String) As Boolean
  On Error GoTo doesntExist
  Dim tcs As String
  
  tcs = GetConnectDB(connectstring)
  Dim s As String
  s = m_ConnectedDBs(tcs)
  ConnectExists = True
  Exit Function
doesntExist:
  ConnectExists = False
  m_ConnectedDBs.Add tcs, tcs
  Dim xlsarr As XLScriptArray
  Set xlsarr = XLScriptGetArray("CONNECTEDDBS")
  xlsarr.AddValue "", tcs
End Function

Function GetConnectDB(txt As String)
  Dim pos As Long
  GetConnectDB = txt
  pos = InStr(txt, ";DATABASE=")
  If pos <= 0 Then Exit Function
  GetConnectDB = Mid(txt, pos + 10)
End Function

Sub GetFlags(n As String, _
            ByRef lngExecute As Long, _
            ByRef lngReadDef As Long, _
            ByRef lngWritedef As Long, _
            ByRef lngReadData As Long, _
            ByRef lngUpdateData As Long, _
            ByRef lngDeleteData As Long, _
            ByRef lngInsertData As Long, _
            ByRef lngDBAdmin As Long, _
            ByRef lngDBExclusive As Long)
  
          lngExecute = -1
          lngReadDef = -1
          lngWritedef = -1
          lngReadData = -1
          lngUpdateData = -1
          lngDeleteData = -1
          lngInsertData = -1
          lngDBAdmin = -1
          lngDBExclusive = -1
          
          Select Case n
            Case "Databases"
              lngExecute = 2 'dbSecDBOpen
              lngDBAdmin = 8 'dbSecDBAdmin
              lngDBExclusive = 4 ' dbSecDBExclusive

            Case "Forms", "Reports"
              lngExecute = 256 ' acSecFrmRptExecute
              lngReadDef = 4 ' acSecFrmRptReadDef
              lngWritedef = 65548 ' acSecFrmRptWriteDef

            Case "Tables", "Queries"
              lngReadDef = 4 ' dbSecReadDef
              lngWritedef = 65548 'dbSecWriteDef
              lngReadData = 20 ' dbSecRetrieveData
              lngUpdateData = 64 ' dbSecReplaceData
              lngInsertData = 32 ' dbSecInsertData
              lngDeleteData = 128 ' dbSecDeleteData 'DbSecDeleteData

            Case "Modules"
              lngReadDef = 2 ' acSecModReadDef
              lngWritedef = 65542 ' acSecModWriteDef

            Case "Macros", "Scripts"
              lngReadDef = 10 ' acSecMacReadDef
              lngWritedef = 65542 ' acSecMacWriteDef
              lngExecute = 8 ' acSecMacExecute

          End Select
End Sub

Sub StatusFormUpdate()
  StatusForm.VergangeneZeit.Caption = Format(Now() - StartTime, "hh:ss")
  SetLiveStatus
End Sub

Function AccAppHasProperty(ByRef app As Object, ByVal keyname As String)
    Dim s As String
    On Error GoTo nogo
    s = CStr(app.CurrentDb.Properties(keyname).value)
    AccAppHasProperty = True
    Exit Function
nogo:
    AccAppHasProperty = False
End Function

Function GetDocProp(ByRef dbs As Object, ByVal txt As String) As String

    Dim prp As DAO.Property
    Const conPropNotFoundError = 3270
 
    ' Datenbank holen
    On Error GoTo Change_Bye
    If txt = "Creation date" Then
      GetDocProp = dbs.Containers("Databases").Documents("SummaryInfo").Properties("DateCreated")
    Else
      GetDocProp = dbs.Containers("Databases").Documents("SummaryInfo").Properties(txt)
    End If
    
    ' dbs.Properties(txt)
 
Change_Bye:
    Exit Function

End Function


Sub LogPrint(ByVal str As String, Optional ByVal dur As Double = 0)
  If G_LogEnabled Then
    If G_cfgLogpfad = "" Then
      AddTextToFile Now() & "; " & Chr(34) & str & Chr(34), ThisWorkbook.path & "\ACC-Log-" & GetUserName & ".txt"
    Else
      AddTextToFile Now() & "; " & Chr(34) & str & Chr(34), G_cfgLogpfad & "\ACC-Log-" & GetUserName & ".txt"
    End If
  End If

'  If Not AR_UseDB Or G_CreateResfile > 0 Then
'    If Not m_ResultWorkbook Is Nothing Then
'      m_ResultWorkbook.Sheets("Log").Cells(m_LogY, 1) = str
'      m_LogY = m_LogY + 1
'    End If
'  End If
End Sub


Public Sub PrintTabellen(ByRef ws As Worksheet, y As Long, x As Long)
  Dim cnt As Long
  Dim td As TableDef
  Dim MyLastTime As Date
  With ws
      MyLastTime = Now
      cnt = 0
      For Each td In m_DB.TableDefs
      
        If MyLastTime + TimeValue("0:00:02") < Now Then
          'UpdateStatus "Generiere Ergebnisbatt " & ws.name & " - " & cnt & " / " & m_DB.TableDefs.count
          UpdateStatus FMT3("CHECK_46", ws.name, cnt, m_DB.TableDefs.count)
          MyLastTime = Now
        End If
        If Beenden Then Exit Sub
        If (td.Attributes And &H80000002) = 0 Then
              
      '        if td.Attributes
              
              .Cells(y, x) = CStr(td.name)
              
              If PropertyNameExists(td.Properties, "DESCRIPTION") Then
                .Cells(y, x + 1) = "'" & td.Properties("DESCRIPTION")
              Else
                .Cells(y, x + 1) = "'-/-"
              End If
              
              With ws.Range(.Cells(y, x + 1), .Cells(y, x + 5))
          '      .HorizontalAlignment = xlCenterAcrossSelection
          '      .VerticalAlignment = xlTop
          '      .WrapText = True
              End With
              y = y + 1
              Dim fld As Field
              For Each fld In td.Fields
                .Cells(y, x + 3) = fld.name
                
                With .Cells(y, x + 3).Font
                    .FontStyle = "Bold"
                    .ColorIndex = 3
                End With
                
                
                If PropertyNameExists(fld.Properties, "DESCRIPTION") Then
                  .Cells(y, x + 4) = "'" & fld.Properties("DESCRIPTION")
                Else
                  .Cells(y, x + 4) = "'-/-"
                End If
                
                
          '      With ws.Range(.Cells(y, x + 4), .Cells(y, x + 9))
          '        .HorizontalAlignment = xlCenterAcrossSelection
          '        .VerticalAlignment = xlTop
          '        .WrapText = True
          '      End With
                y = y + 1
                .Cells(y, x + 3) = "Attribute"
                With .Cells(y, x + 3).Font
                    .FontStyle = "Bold"
                End With
          
                DoPrintBitfieldExt CStr(fld.Attributes), "AttributesField", ", ", .Cells(y, x + 5)
                y = y + 1
                
                Dim prop As Property
                Dim tx As Long
                tx = 0
                For Each prop In fld.Properties
                  .Cells(y, x + 3 + tx) = prop.name
                  .Cells(y, x + 4 + tx).WrapText = True
                  .Cells(y, x + 4 + tx) = "'" & GetPropertyValue(prop)
                  tx = tx + 2
                  If tx = 6 Then
                    tx = 0
                    y = y + 1
                  End If
                Next prop
                If tx = 6 Then
                  y = y + 1
'                  Rows("42:42").EntireRow.AutoFit
                Else
                  y = y + 2
                End If
              
              Next fld
        End If
        cnt = cnt + 1
      Next td
  End With
  'UpdateStatus "Generiere Ergebnisbatt " & ws.name & " - " & cnt & " / " & m_DB.TableDefs.count
  UpdateStatus FMT3("CHECK_46", ws.name, cnt, m_DB.TableDefs.count)
End Sub

Function GetPropertyValue(ByRef p As Property)
  On Error Resume Next
  GetPropertyValue = "-/-"
  GetPropertyValue = p.value
End Function

Sub CheckLibs()
On Error Resume Next
  Dim libs As Object
  Set libs = XLScriptAddArray2D("LIBS")
  
  Dim x As Long
  With m_App.VBE.ActiveVBProject
    For x = 1 To .References.count
      libs.AddLine
      libs.AddValue "LIBNAME", .References(x).name
      libs.AddValue "LIBDESCRIPTION", .References(x).Description
      libs.AddValue "LIBTYPE", .References(x).Type
      libs.AddValue "MAJOR", .References(x).Major
      libs.AddValue "MINOR", .References(x).Minor
      libs.AddValue "PATH", .References(x).fullpath
      libs.AddValue "GUID", .References(x).GUID
      libs.AddValue "BUILTIN", .References(x).BuiltIn
      libs.AddValue "ISBROKEN", .References(x).isbroken
    Next x
  End With

  Set libs = Nothing
End Sub

Function VBAModuleAccessable(ByRef mdl) As Boolean
On Error GoTo nogo:
  Dim i As Long
  i = mdl.Type
  VBAModuleAccessable = True
  Exit Function
nogo:
End Function

Function IsMde(ByRef app As Object) As Boolean
  On Error GoTo nogo
  If UCase(Right(m_App.CurrentDb.name, 6)) = ".ACCDE" Or UCase(Right(m_App.CurrentDb.name, 4)) = ".ADE" Or UCase(Right(m_App.CurrentDb.name, 4)) = ".MDE" Then
    IsMde = True
  End If
  Exit Function
nogo:
End Function
Attribute VB_Name = "CheckinStuff"
Option Explicit

#If VBA7 Then
Declare PtrSafe Sub SWCompressFile Lib "SWPacker.dll" (ByVal a As String, ByVal Level As Integer)
Declare PtrSafe Sub SWDecompressFile Lib "SWPacker.dll" (ByVal a As String)
Declare PtrSafe Sub SWTest Lib "SWPacker.dll" ()
Private Declare PtrSafe Function FreeLibrary Lib "kernel32" (ByVal hLibModule As Long) As Long
Private Declare PtrSafe Function LoadLibrary Lib "kernel32" Alias "LoadLibraryA" (ByVal lpLibFileName As String) As Long
#Else
Declare Sub SWCompressFile Lib "SWPacker.dll" (ByVal a As String, ByVal Level As Integer)
Declare Sub SWDecompressFile Lib "SWPacker.dll" (ByVal a As String)
Declare Sub SWTest Lib "SWPacker.dll" ()
Private Declare Function FreeLibrary Lib "kernel32" (ByVal hLibModule As Long) As Long
Private Declare Function LoadLibrary Lib "kernel32" Alias "LoadLibraryA" (ByVal lpLibFileName As String) As Long
#End If

Function CheckInFile(ByRef rs As Object, checkindat As Date) As Boolean

On Error GoTo nogo

  Dim logtrack As Long
  logtrack = 0

  CheckInFile = False
  
  If Len(G_cfgTemppfad) > 0 Then
      logtrack = 1
      
      'erst mal alte killen falls vorhanden
      If FileExists(G_cfgTemppfad & "\" & rs.Fields("Hash").value) Then
          logtrack = 2
          MyKill G_cfgTemppfad & "\" & rs.Fields("Hash").value
          logtrack = 3
          If FileExists(G_cfgTemppfad & "\" & rs.Fields("Hash").value) Then
            logtrack = 4
            ' DebugPrint DebType.tERROR, "Tempor|fffd|re Datei f|fffd|r '" & rs.Fields("Dateiname").Value & "' nicht gel|fffd|scht(1)"
            ' MsgBox "FEHLER: Die tempor|fffd|re Datei '" & G_cfgTemppfad & "\" & rs.Fields("Hash").Value & "' konnte nicht gel|fffd|scht werden. Bitte informieren Sie Ihre Administration!", vbCritical + vbSystemModal, ProgNameLong & " " & MyVersion
            'AddStatus "FEHLER: Die tempor|fffd|re Datei '" & G_cfgTemppfad & "\" & rs.Fields("Hash").value & "' konnte nicht gel|fffd|scht werden. Bitte informieren Sie Ihre Administration!"
            AddStatus FMT2("CHECKIN_1", G_cfgTemppfad, rs.Fields("Hash").value)
            Exit Function
          End If
          logtrack = 5
      End If
      
      logtrack = 6
      If Not PathExists(G_cfgTemppfad) Then
        ' DebugPrint DebType.tERROR, "CheckInFile: TempPathMissing '" & rs.Fields("Dateiname").Value & "'"
        'AddStatus "FEHLER: Der tempor|fffd|re Pfad existiert nicht '" & rs.Fields("Dateiname").value & "'"
        AddStatus FMT1("CHECKIN_2", rs.Fields("Dateiname").value)
        Exit Function
      End If
      CopyFile rs.Fields("Dateiname").value, G_cfgTemppfad & "\" & rs.Fields("Hash").value, 0
      logtrack = 7

      If FileExists(G_cfgTemppfad & "\" & rs.Fields("Hash").value) Then
          logtrack = 8
          Dim fehler As String
          If Not xlCheckInBinary(rs.Fields("idvDateiID").value, rs.Fields("Version").value, checkindat, G_cfgTemppfad & "\" & rs.Fields("Hash").value, fehler) Then
            ' DebugPrint DebType.tdebug, "Die Datei '" & rs.Fields("Dateiname").Value & "' konnte nicht eingecheckt werden"
            'AddStatus "FEHLER: Die Datei konnte nicht auf dem Datenbankserver eingecheckt werden! Es wird ein zweiter Versuch gestartet..."
            AddStatus FMT0("CHECKIN_7")
            Sleep 3000
            If Not xlCheckInBinary(rs.Fields("idvDateiID").value, rs.Fields("Version").value, checkindat, G_cfgTemppfad & "\" & rs.Fields("Hash").value, fehler) Then
              ' DebugPrint DebType.tdebug, "Die Datei '" & rs.Fields("Dateiname").Value & "' konnte nicht eingecheckt werden"
              ' MsgBox "Die Datei konnte nicht auf dem Datenbankserver eingecheckt werden! Bitte versuchen Sie es sp|fffd|ter noch einmal!", vbCritical + vbSystemModal, ProgNameLong & " " & MyVersion
              'AddStatus "FEHLER: Die Datei konnte nicht auf dem Datenbankserver eingecheckt werden! Bitte versuchen Sie es sp|fffd|ter noch einmal!"
              DebugPrint DebType.tERROR, "Die Datei '" & rs.Fields("Dateiname").value & "' konnte nicht eingecheckt werden. (" & fehler & ")"
              AddStatus FMT0("CHECKIN_3") & vbCrLf & "(" & fehler & ")"
            Else
              CheckInFile = True
            End If
          Else
            CheckInFile = True
          End If
          logtrack = 9
          MyKill G_cfgTemppfad & "\" & rs.Fields("Hash").value
          
          If FileExists(G_cfgTemppfad & "\" & rs.Fields("Hash").value) Then
            ' DebugPrint DebType.tdebug, "Tempor|fffd|re Datei f|fffd|r '" & rs.Fields("Dateiname").Value & "' nicht gel|fffd|scht(2)"
            ' MsgBox "FEHLER: Die tempor|fffd|re Datei '" & G_cfgTemppfad & "\" & rs.Fields("Hash").Value & "' konnte nicht gel|fffd|scht werden. Bitte informieren Sie Ihre Administration!", vbCritical + vbSystemModal, ProgNameLong & " " & MyVersion & " (Build: " & app.Major & "-" & app.Minor & "-" & app.Revision & ")"
          End If

          logtrack = 19
          Exit Function
      Else
        ' DebugPrint DebType.tERROR, "CheckInFile: No checkin (" & logtrack & "): " & rs.Fields("Dateiname").Value
        ' MsgBox "FEHLER: Die Datei konnte nicht in den tempor|fffd|ren Pfad kopiert werden! Die Datei kann nicht eingecheck werden! Bitte informieren Sie die Administration!", vbCritical + vbSystemModal, ProgNameLong & " " & MyVersion & " (Build: " & app.Major & "-" & app.Minor & "-" & app.Revision & ")"
        'AddStatus "FEHLER: Die Datei konnte nicht in den tempor|fffd|ren Pfad kopiert werden! Die Datei kann nicht eingecheck werden! Bitte informieren Sie die Administration!"
        AddStatus FMT0("CHECKIN_4")
      End If
  Else
    ' DebugPrint DebType.tERROR, "CheckInFile: No checkin (" & logtrack & "): " & rs.Fields("Dateiname").Value
    ' MsgBox "FEHLER: Es ist kein tempor|fffd|rer Pfad konfiguriert! Die Datei kann nicht eingecheck werden! Bitte informieren Sie die Administration!", vbCritical + vbSystemModal, ProgNameLong & " " & MyVersion & " (Build: " & app.Major & "-" & app.Minor & "-" & app.Revision & ")"
    'AddStatus "FEHLER: Es ist kein tempor|fffd|rer Pfad konfiguriert! Die Datei kann nicht eingecheck werden! Bitte informieren Sie die Administration!"
    AddStatus FMT0("CHECKIN_5")
  End If
  
  Exit Function
nogo:
  ' DebugPrint DebType.tERROR, "CheckInFile:" & logtrack
  ' MsgBox "FEHLER: Die Datei '" & rs.Fields("Dateiname").Value & "' kann nicht eingecheck werden!" & Err.Number & " - " & Err.Description & " - " & Err.Source, vbCritical + vbSystemModal, ProgNameLong & " " & MyVersion & " (Build: " & app.Major & "-" & app.Minor & "-" & app.Revision & ")"
  'AddStatus "FEHLER: Die Datei '" & rs.Fields("Dateiname").value & "' kann nicht eingecheck werden!" & Err.Number & " - " & Err.Description & " - " & Err.Source
  AddStatus FMT4("CHECKIN_6", rs.Fields("Dateiname").value, Err.Number, Err.Description, Err.Source)
End Function

Public Function PackFile(ByVal Filename As String, ByVal copyToTemp As Boolean) As String
    On Error GoTo fehlerPackFile
    
    PackFile = ""
    Dim tempFilename As String
    If copyToTemp Then
        tempFilename = GetFileNameAndPath(CreateTempFile("Tmp")) & GetFileName(Filename)
        CopyFile Filename, tempFilename
    Else
        tempFilename = Filename
    End If
    PackFile = tempFilename

    ' 57 = '0'+9, wird als Ziffer von SWCompressFile in einen String geschrieben
    If FileExists(tempFilename) Then
      Dim lb As Long, pa As Long
      lb = LoadLibrary(ThisWorkbook.path & "\..\bin\SWPacker.dll")
      If lb <> 0 Then
        SWCompressFile tempFilename, 50
        ' MsgBox "Datei gepackt!"
        PackFile = tempFilename + ".gz"
        FreeLibrary lb
      End If
    End If
    
    ' es wurde gepackt und die TempDatei wurde auch oben durch Kopieren erstellt
    ' dann m|fffd|ssen wir die hier wieder l|fffd|schen
    If PackFile <> tempFilename And copyToTemp = True Then
        MyKill tempFilename
    End If
    Exit Function
fehlerPackFile:
On Error GoTo rausAusFunktion
    If lb <> 0 Then
      FreeLibrary lb
    End If
    If PackFile <> tempFilename And copyToTemp = True Then
        MyKill tempFilename
    End If
rausAusFunktion:
End Function

Public Function GetSplitSize() As Long
    ' ab welcher Gr|fffd||fffd|e legen wir mehrere Eintr|fffd|ge in der xlBin Blobs an,
    ' damit wir bei gro|fffd|en Dateien kein OutOfMemory bekommen
    GetSplitSize = CLng(1024) * CLng(1024) * CLng(16)
End Function


Public Function xlCheckInBinary(ByVal idvDateiID As Long, ByVal Version As Long, ByVal dat As Date, ByVal fname As String, ByRef fehler As String) As Boolean
        On Error GoTo fehler
        
        LogPrint "xlCheckInBinary-Start"

        ' Erst mal eine eventuell bereits eingecheckte Datei rauswerfen!
        ' !!!! nicht mehr direkt |fffd|ber xlBin l|fffd|schen sondern |fffd|ber den xlBinUpdate View
        ' ansonsten geht das nicht mit dem Security Zeugs
        ' G_conn.Execute "DELETE FROM xlBin WHERE idvDateiID = " & idvDateiID & " and Version = " & Version
        G_Conn.Execute "DELETE FROM A_XLBINUPDATE WHERE idvDateiID = " & idvDateiID & " and Version = " & Version

        Dim rs As Object
        ' !!!! hier jetzt |fffd|ber den neuen View f|fffd|r die xlBins gehen
        ' ansonsten bekommt man keinen Recordset zur|fffd|ck
'        Set rs = OpenRS("SELECT * FROM xlBin where xlBinID = -1", G_conn, MYadOpenDynamic, MYadLockOptimistic)
        
        If G_DBType <> G_SQL_Server Then
          Set rs = OpenRS("SELECT * FROM A_XLBININSERT WHERE xlBinID = -1", G_Conn, MYadOpenDynamic, MYadLockOptimistic)
          If rs Is Nothing Then
            xlCheckInBinary = False
            fehler = "Der erforderliche Recordset konnte nicht ge|fffd|ffnet werden"
            Exit Function
          End If
        End If
        
        Dim zippedFilename As String
        zippedFilename = PackFile(fname, True)

        DoEvents
        
        Dim splitFilenames() As String
        Dim step As Long
        If (SplitFile(zippedFilename, GetSplitSize(), splitFilenames)) Then
        Else
            ReDim splitFilenames(0)
            splitFilenames(0) = zippedFilename
        End If
        
        LogPrint "xlCheckInBinary-1"
        For step = LBound(splitFilenames) To UBound(splitFilenames)
        
            If G_DBType = G_SQL_Server Then
                If Not CheckInBinarySQLServer(G_Conn, splitFilenames(step), idvDateiID, Version, dat, step, zippedFilename, fehler) Then
                  DebugPrint tdebug, "xlCheckInBin-Datei NICHT eingef|fffd|gt"
                  xlCheckInBinary = False
                  Exit For
                Else
                  xlCheckInBinary = True
                End If
            Else
                'LogPrint "xlCheckInBinary-1"
                rs.AddNew
                rs.Fields("idvDateiID").value = idvDateiID
                rs.Fields("Version").value = Version
                rs.Fields("Datum").value = dat
                rs.Fields("Compressed").value = IIf(Right(zippedFilename, 3) = ".gz", 1, 0)
                rs.Fields("Step").value = step
                
                Dim errstr As String
                If Not CheckInBinary("Binary", rs, splitFilenames(step), errstr) Then
                  DebugPrint tdebug, "xlCheckInBin-Datei NICHT eingef|fffd|gt"
                  rs.CancelUpdate
                  xlCheckInBinary = False
                  Exit For
                Else
                  rs.Update
                  xlCheckInBinary = True
                End If
            End If
        Next
        If G_DBType <> G_SQL_Server Then
          rs.Close
          Set rs = Nothing
        End If
        
        If zippedFilename <> fname Then
            MyKill zippedFilename
        End If
        For step = LBound(splitFilenames) To UBound(splitFilenames)
            If splitFilenames(step) <> fname Then
                MyKill splitFilenames(step)
            End If
        Next
        LogPrint "xlCheckInBinary-Finished"
        Exit Function
fehler:
        fehler = fehler & IIf(fehler <> "", vbCrLf, "") & "xlCheckInBinary: " & Err.Number & " - " & Err.Description
        Debug.Print fehler
'        If Not rs Is Nothing Then
'          rs.Close
          Set rs = Nothing
'        End If
        xlCheckInBinary = False
End Function


Private Function CheckInBinarySQLServer(ByRef conn As Object, ByVal datafile As String, ByVal idvDateiID As Long, ByVal Version As Long, ByVal dat As Date, ByVal step As Long, ByVal zippedFilename As String, ByRef fehler As String) As Boolean

On Error GoTo nogo
   Dim adoStream               As Object
   Dim adoCmd                  As Object
    
   Set adoStream = CreateObject("ADODB.Stream")
   Set adoCmd = CreateObject("ADODB.Command")
    
   adoStream.Type = 1 ' adTypeBinary
   adoStream.Open
   adoStream.LoadFromFile datafile 'It fails if file is open
        
   With adoCmd
        .CommandText = "INSERT INTO A_XLBININSERT (idvDateiID,Version,Datum,Compressed,Binary,Step) VALUES (?,?,?,?,?,?)" ' Query
        .CommandType = 1 ' adCmdText
        
        '---adding parameters
        ' 1 adParamInput
        
        ' 3 adInteger
        ' 20 adBigInt
        ' 7 adDate
        ' 2 adSmallInt
        ' 204 adVarBinary
        ' 205 adLongVarBinary
        ' 135 adDBTimeStamp A date/time stamp (yyyymmddhhmmss plus a fraction in billionths).
        
        .Parameters.Append .CreateParameter("@idvDateiID", 20, 1, 0, idvDateiID)
        .Parameters.Append .CreateParameter("@Version", 20, 1, 0, Version)
        .Parameters.Append .CreateParameter("@Datum", 135, 1, , CDate(dat))
        .Parameters.Append .CreateParameter("@Compressed", 3, 1, 0, IIf(Right(zippedFilename, 3) = ".gz", 1, 0))
        .Parameters.Append .CreateParameter("@Binary", 205, 1, adoStream.Size, adoStream.Read)
        .Parameters.Append .CreateParameter("@Step", 20, 1, 0, step)

        '---
   End With
    
   adoCmd.ActiveConnection = conn
   adoCmd.Execute
   CheckInBinarySQLServer = True
   Exit Function
nogo:
   fehler = fehler & IIf(fehler <> "", vbCrLf, "") & "CheckInBinarySQLServer: " & Err.Number & " - " & Err.Description
End Function

Private Sub TestCheckInFile()
    Dim fehler As String
    InitApp
    Set G_Conn = GetConnection
    Debug.Print xlCheckInBinary(88, 1, Now, "C:\Users\norman\Documents\|fffd|berpr|fffd|fung Autokorrelationen.xlsx", fehler)
    Debug.Print fehler
    G_Conn.Close
    Set G_Conn = Nothing
End Sub
Public Function CheckInBinary(ByVal fieldname As String, ByRef rs As Object, ByVal fname As String, ByRef errstr As String) As Boolean

    On Error GoTo fehler
    
    If Not FileExists(fname) Then
      'errstr = errstr & IIf(errstr <> "", vbCrLf, "") & "Die Datei '" & fname & "' existiert nicht."
      errstr = errstr & IIf(errstr <> "", vbCrLf, "") & FMT1("BLOBSTUFF_1", fname)
      Exit Function
    End If
    
    Dim Doc As Object
    Set Doc = CreateObject("ADODB.Stream")
    
    Dim SavedPointer As Long
    'SavedPointer = Screen.MousePointer  ' Save mouse pointer.
    'Screen.MousePointer = 11
           
    DebugPrint tdebug, "CheckInBinary-Start"
    With Doc
        .Type = 1 ' adTypeBinary
        .Open
        .LoadFromFile fname
    End With
    rs.Fields(fieldname).value = Doc.Read
    
    DebugPrint tdebug, "CheckInBinary-Eingef|fffd|gt"
    'Screen.MousePointer = SavedPointer
    CheckInBinary = True
    DebugPrint tdebug, "CheckInBinary-Ende"
    
    Exit Function

fehler:
    errstr = Err.Number & " - " & Err.Description & " - " & Err.Source & " - Datei: " & fname
    DebugPrint tERROR, "CheckInBinary: " & Err.Number & " - " & Err.Description & " - " & Err.Source & " - Datei: " & fname
'        If Err.Number = 32755 Then Exit Function
End Function
Attribute VB_Name = "CommStuff"
Option Explicit

Sub StoreComm(ison As Boolean)
  On Error Resume Next
  
  If G_Conn Is Nothing Then Exit Sub
  
  Dim rsACCScan As Object
  Dim count As Long
  
  Set rsACCScan = OpenRS("select Count(idvDateiId) as count from ACCScan", G_Conn, MYadOpenDynamic, MYadLockReadOnly)
  count = rsACCScan.Fields("count").value
  rsACCScan.Close
  
  Set rsACCScan = OpenRS("select * FROM gCommunicate WHERE Interface = 'ACC'", G_Conn, MYadOpenDynamic, MYadLockOptimistic)
  If Not rsACCScan Is Nothing Then
    If rsACCScan.EOF Then
      rsACCScan.AddNew
      rsACCScan.Fields("Interface").value = "ACC"
    End If
    rsACCScan.Fields("COMM").value = "SCAN=" & IIf(ison, "ON", "OFF") & vbCrLf & "RESTSCAN=" & count & vbCrLf & "DATE=" & Now & vbCrLf & "FILENAME=" & theFilename
    rsACCScan.Update
    rsACCScan.Close
    Set rsACCScan = Nothing
  End If

End Sub

Sub StoreUserCommunicateValue(prefix As String, s As String)

  On Error Resume Next
  
  If G_Conn Is Nothing Then Exit Sub
  
  Dim rsACCScan As Object
  Dim count As Long
  
  Set rsACCScan = OpenRS("select * FROM gCommunicate WHERE Interface = '" & prefix & "-" & GetUserName & "'", G_Conn, MYadOpenDynamic, MYadLockOptimistic)
  If Not rsACCScan Is Nothing Then
    If rsACCScan.EOF Then
      rsACCScan.AddNew
      rsACCScan.Fields("Interface").value = prefix & "-" & GetUserName
    End If
    rsACCScan.Fields("COMM").value = s
    rsACCScan.Update
    rsACCScan.Close
    Set rsACCScan = Nothing
  End If

End Sub


Attribute VB_Name = "DBStuff"
Option Explicit

Public G_DBUser As String
Public G_DBUserPasswort As String
Public G_DBType As Long

Public gCHR As String
Public gCursorLocation As Long

Public Const G_SQL_Anywhere As Integer = 1
Public Const G_SQL_Server As Integer = 2
Public Const G_MySQL As Integer = 3
Public Const G_Access As Integer = 4
Public Const G_Oracle As Integer = 5

Function GetConnection(Optional ByVal waitendless As Boolean = False) As Object

    Dim conn
    Set conn = CreateObject("ADODB.Connection")
    If G_Cursorlocation <> 2 And G_Cursorlocation <> 3 Then
      G_Cursorlocation = 3
    End If
    conn.CursorLocation = G_Cursorlocation
    On Error Resume Next

    Set GetConnection = Nothing
    Dim cnt As Long
    cnt = 0
checkAgain:
    conn.Open G_DBConnectionString, G_DBUser, G_DBUserPasswort
    
    If Err.Number <> 0 Then
        Debug.Print Err.Description
        Err.Clear
        Sleep 50
        cnt = cnt + 1
        If Not waitendless Then
            If cnt >= 100 Then
                conn = Nothing
                Exit Function
            End If
            GoTo checkAgain
        End If
    End If

    Set GetConnection = conn

End Function


Sub GetDBUser(ByRef cfg As CfgReader)
    
    G_DBUser = "IDVTTECHUSER"
    G_DBUserPasswort = "12SD3Ax$!d7%fd/"

    Dim s As String
    If cfg.GetSection("DB") = True Then
        s = cfg.GetValue("USER")
        If s <> "" Then
            G_DBUser = Crypt(s, "uIq2%7/=}pJIi39x?", False)
        End If
        s = cfg.GetValue("PASSWORD")
        If s <> "" Then
            G_DBUserPasswort = Crypt(s, "uIq2%7/=}pJIi39x?", False)
        End If
        s = cfg.GetValue("DBTYPE")
        If s <> "" Then
            G_DBType = CLng(s)
        End If
    End If
End Sub


Function Crypt(Inp As String, Key As String, Mode As Boolean) As String
    Dim z As String
    Dim i As Integer, Position As Integer
    Dim cptZahl As Long, orgZahl As Long
    Dim keyZahl As Long, cptString As String
    
    For i = 1 To Len(Inp)
            Position = Position + 1
            If Position > Len(Key) Then Position = 1
            keyZahl = Asc(Mid(Key, Position, 1))
            
            If Mode Then
            
                'Verschl|fffd|sseln
                orgZahl = Asc(Mid(Inp, i, 1))
                cptZahl = orgZahl Xor keyZahl
                cptString = Hex(cptZahl)
                If Len(cptString) < 2 Then cptString = "0" & cptString
                z = z & cptString
            
            Else
            
                'Entschl|fffd|sseln
                If i > Len(Inp) \ 2 Then Exit For
                cptZahl = CByte("&H" & Mid$(Inp, i * 2 - 1, 2))
                orgZahl = cptZahl Xor keyZahl
                z = z & Chr$(orgZahl)
            
            End If
        Next i
     
        Crypt = z
End Function




Sub WBRemoveTags()

    Dim nameItem As Excel.name

GoAgain:
    Dim i As Long
    If ThisWorkbook.names.count > 0 Then
      For i = 1 To ThisWorkbook.names.count
          If ThisWorkbook.names(i).Visible = False Then
              If Left(ThisWorkbook.names(i).name, Len("_IDVTracker")) = "_IDVTracker" Then
                  ThisWorkbook.names.item(i).Delete
                  GoTo GoAgain
              End If
          End If
      Next i
    End If

End Sub


Function DBFieldItemExists(ByRef rs As Object, fieldname As String) As Boolean
  On Error GoTo nogo
  Dim s As String
  s = rs.Fields(fieldname).name
  DBFieldItemExists = True
  Exit Function
nogo:
End Function

Function GetSafeFieldPlus(ByRef rs As Object, ByVal fieldname As String, Optional defaultVal As Variant) As Variant
  On Error Resume Next
  If Not IsNull(rs.Fields(fieldname).value) Then
    GetSafeFieldPlus = rs.Fields(fieldname).value
  Else
    If Not IsMissing(defaultVal) Then
      GetSafeFieldPlus = defaultVal
    End If
  End If
End Function

Function GetTargetRSFromFilename(ByRef conn As Object, ByVal uncpathfname, ByRef rs As Object, ByRef curId As Long) As Boolean
    GetTargetRSFromFilename = False
    
    Dim uncpathfnameDB As String
    uncpathfnameDB = GetDateinameInDatenbank(uncpathfname)
    
    Dim hash As String
    hash = GetFileHash(uncpathfnameDB)

    Set rs = OpenRS("SELECT * FROM idvDateien WHERE " & _
      gCHR & "HASH" & gCHR & " = '" & hash & "'" & _
      " and geloescht = 0", conn, MYadOpenDynamic, MYadLockReadOnly)

    If Not rs Is Nothing Then
        If rs.EOF = False Then
            curId = rs.Fields("idvDateiID").value
            GetTargetRSFromFilename = True
            Exit Function
        End If
        rs.Close
    End If
    Set rs = Nothing

End Function

Public Function GetDateinameInDatenbank(ByVal uncpathfname As String) As String

    GetDateinameInDatenbank = UCase(uncpathfname)
    If IsHttpFilename(uncpathfname) Then
        If True = True Then
            GetDateinameInDatenbank = uncpathfname
        End If
    End If

End Function


Public Function IsHttpFilename(ByVal uncpathfname As String) As Boolean
    IsHttpFilename = False
    If IsURL(uncpathfname) Then
        IsHttpFilename = True
    End If
    
    If UCase(Left(uncpathfname, 16)) = "\\VBOXSRV\MYWORK" Then
        IsHttpFilename = True
    End If
End Function

Attribute VB_Name = "DebugStuff"
Option Explicit

Enum DebType
    tERROR = 1
    tInfo = 2
    tTime = 3
    tdebug = 4
    tMail = 5
    tSystem = 6
    tToFile = 7
End Enum

Public G_PARAM_DebugInfosLoggen As Boolean
Public G_IgnoreFutureWriteWindows As Boolean

Public G_LogThisUser As Boolean
Public G_PARAM_CollectDebug As Boolean

Public G_LogToWindow As Boolean
Public G_LogWriteIgnore As Boolean

Private L_InDebugPrint As Boolean


Public Const G_LOG_EXTERNE_KOPIE As Long = 1              ' Die Datei wurde durch eine andere Datei au|fffd|erhalb des IDV-Tracker-Systems |fffd|berschrieben. Wahrscheinlich hat der User eine Datei mit dem Explorer |fffd|ber die Originaldatei kopiert.
Public Const G_LOG_NEUE_FREIGABE_ENTFERNT As Long = 2     ' F|fffd|r die Datei wurde eine neue Version erzeugt. Dadurch wurde die Programmfreigabe aufgehoben.
Public Const G_LOG_NEUE_VERSION As Long = 3               ' F|fffd|r die Datei wurde eine neue Version erzeugt.
Public Const G_LOG_BLATSCHUTZ_ENTFERNEN_INIT As Long = 4  ' Blattschutz-Entfernung initiiert
Public Const G_LOG_BLATTSCHUTZ_ENTFERNT As Long = 5       ' Blattschutz entfernt
Public Const G_LOG_BLATTSCHUTZ_ANGEBRACHT As Long = 6     ' Blattschutz angebracht

Private Sub SetConnectTimeout(ByRef conn)
  On Error Resume Next
  conn.Execute "SET LOCK_TIMEOUT 5000"
  conn.Properties("Jet OLEDB:Lock Delay") = 5000 ' 90 + Int(Rnd * 60)
  Err.Clear
End Sub

#If NOLOGTODB = 0 Then
Sub AddTextToLogDB(ByVal md As DebType, ByVal str As String, dur As Double, ByVal logExp As Long, ByVal idvDateiID As Long)
    
    On Error GoTo nogo
    
    Dim rs As Object
    Set rs = CreateObject("ADODB.Recordset")

    rs.Open "SELECT * FROM idvDateienEventLog WHERE EventTyp = -1", G_Conn, MYadOpenDynamic, MYadLockOptimistic
    
    If rs Is Nothing Then
      Exit Sub
    End If
    
    Do While Len(str) > 0
      rs.AddNew
      rs.Fields("EventTyp").value = md
      rs.Fields("EventLogErlaeuterungID").value = logExp
      rs.Fields("Datum").value = Now
      rs.Fields("Text").value = Left(str, 255)
      rs.Fields("Zeit").value = dur
      rs.Fields("AppID").value = MyAppID
      rs.Fields("idvDateiID").value = idvDateiID
      rs.Fields("userLogonId").value = Left(GetUserName, 24)
      rs.Update
      str = Mid(str, 255, 10000)
    Loop

nogo:
'    If Not rs Is Nothing Then
'      rs.Close
      Set rs = Nothing
'    End If
    


End Sub
#End If

Sub DebugPrint(ByVal md As DebType, ByVal str As String, Optional ByVal dur As Double = 0, Optional ByVal logExp As Long = 0, Optional ByVal idvDateiID As Long = 0, Optional logToECCSCanLog As Boolean = False)

    If L_InDebugPrint Then Exit Sub

    L_InDebugPrint = True
    
    ' Ausgabe f|fffd|r Debug-Window
    If md = DebType.tERROR Then
      If UCase(Right(ThisWorkbook.name, 1)) = "S" Then
        Debug.Print "ND: " & Now() & "; " & Chr(34) & "Err: " & str & Chr(34) & "; " & dur
      End If
'      If G_LogToWindow = True Then
'        frmLogWindow.LogText.Text = Right(frmLogWindow.LogText.Text & vbCrLf & "*** " & Now() & "; " & Chr(34) & "Err: " & str & Chr(34) & "; " & dur, 16000)
'        If Len(frmLogWindow.LogText.Text) > 0 Then
'          frmLogWindow.LogText.SelStart = Len(frmLogWindow.LogText.Text)
'        End If
'      End If
    Else
      If UCase(Right(ThisWorkbook.name, 1)) = "S" Then
        Debug.Print "ND: " & Now() & "; " & Chr(34) & str & Chr(34) & "; " & dur
      End If
'      If G_LogToWindow = True Then
'        frmLogWindow.LogText.Text = Right(frmLogWindow.LogText.Text & vbCrLf & Now() & "; " & Chr(34) & str & Chr(34) & "; " & dur, 16000)
'        If Len(frmLogWindow.LogText.Text) > 0 Then
'          frmLogWindow.LogText.SelStart = Len(frmLogWindow.LogText.Text)
'        End If
'      End If
    End If
    
'    If G_LogEnabled Then
'      If G_cfgLogpfad = "" Then
'        AddTextToFile Now() & "; " & Chr(34) & str & Chr(34), ThisWorkbook.path & "\ECC-Log-" & GetUserName & ".txt"
'      Else
'        AddTextToFile Now() & "; " & Chr(34) & str & Chr(34), G_cfgLogpfad & "\ECC-Log-" & GetUserName & ".txt"
'      End If
'    End If
    
    If AR_StartedByApp = SWAPPID_IDVSuiteScheduler Then
      If logToECCSCanLog Then
        If G_cfgLogpfad <> "" Then
          If FileExists(G_cfgLogpfad & "\IDV-Suite Scheduler-" & GetUserName & ".txt") Then
            AddTextToFile Now() & ",0, Typ: 7, ID: " & idvDateiID & "," & Chr(34) & str & Chr(34), G_cfgLogpfad & "\IDV-Suite Scheduler-" & GetUserName & ".txt"
          End If
        End If
      End If
    End If
    
    If G_LogEnabled Then
      If G_cfgLogpfad = "" Then
        AddTextToFile Now() & "; " & Chr(34) & str & Chr(34), ThisWorkbook.path & "\ECC-Log-" & GetUserName & ".txt"
      Else
        AddTextToFile Now() & "; " & Chr(34) & str & Chr(34), G_cfgLogpfad & "\ECC-Log-" & GetUserName & ".txt"
      End If
    End If
    
    
'    If G_AllowLoggingToStorage Then
'        If md = 1 Or _
'            (md = 2 And (G_cfgDebugInfosLoggen = True Or (G_PARAM_DebugInfosLoggen = True And G_LogThisUser = True))) Or _
'            (md = 3 And (G_cfgDebugInfosLoggen = True Or (G_PARAM_DebugInfosLoggen = True And G_LogThisUser = True))) Or _
'            (md = 4 And (G_cfgDebugInfosLoggen = True Or (G_PARAM_DebugInfosLoggen = True And G_LogThisUser = True))) Or _
'             md = 5 Or _
'             md = 6 Then
'
'            If md = DebType.tError Then
'                AddTextToLogDB md, "Err: " & str, dur, logExp, idvDateiID
'            Else
'                AddTextToLogDB md, str, dur, logExp, idvDateiID
'            End If
'        End If
'    End If
    

    L_InDebugPrint = False

End Sub


Public Function AddTextToLogfile(ByVal strData As String, _
     ByVal fullpath As String, _
       Optional ByVal ErrInfo As String = "") As Boolean

    On Error GoTo CatchEx

    If G_LogWriteIgnore = True Then Exit Function
    
    Dim fn As Long
    Dim cnt As Long
    cnt = 0
    
    fn = FreeFile
    Dim s As String

GoAgain:

    If PathExists(GetPath(fullpath)) Then
      Do
        If FOpenAppend(fullpath, fn) Then
          Print #fn, strData
          Close fn
          AddTextToLogfile = True
          Exit Do
        Else
          Sleep 100
          cnt = cnt + 1
          If cnt >= 10 Then
            AddTextToLogfile = False
            G_LogWriteIgnore = True
            If Not G_IgnoreFutureWriteWindows Then
              'If MsgBox("ACHTUNG: Die Log-Datei kann nicht in '" & fullpath & "' gespeichert werden, vermutlich haben Sie keine Schreibrechte in diesem Ordner. Bitte informieren Sie die Administration. M|fffd|chten Sie, dass das Log in einem Fenster ausgegeben wird?", vbYesNo + vbCritical, ProgNameLong & " " & MyVersion) = vbYes Then
              If MsgBox(FMT1("DEBUGSTUFF_1", fullpath), vbYesNo + vbCritical, ProgNameLong & " " & MyVersion) = vbYes Then
                G_LogToWindow = True
                ' frmLogWindow.Caption = ProgNameLong & " " & MyVersion & " - Log..."
                ' frmLogWindow.Show vbModeless
                G_IgnoreFutureWriteWindows = True
              End If
            End If
            Exit Function
          End If
        End If
      Loop
    Else
      G_LogWriteIgnore = True
      'If MsgBox("ACHTUNG: Die Log-Datei kann nicht in '" & GetPath(fullpath) & "' gespeichert werden, der Pfad existiert nicht. Bitte informieren Sie die Administration. M|fffd|chten Sie, dass das Log in einem Fenster ausgegeben wird?", vbYesNo + vbCritical, ProgNameLong & " " & MyVersion) = vbYes Then
      If MsgBox(FMT1("DEBUGSTUFF_2", GetPath(fullpath)), vbYesNo + vbCritical, ProgNameLong & " " & MyVersion) = vbYes Then
        G_LogToWindow = True
        'frmLogWindow.Caption = ProgNameLong & " " & MyVersion & " - Log..."
'        frmLogWindow.Caption = ProgNameLong & " " & MyVersion & " - " & FMT0("DEBUGSTUFF_3")
'        frmLogWindow.Show vbModeless
      End If
    End If
    Exit Function

CatchEx:

End Function




Private Function FOpenAppend(fname As String, ByRef fn As Long) As Boolean
  On Error GoTo nogo
  Open fname For Append As fn
  FOpenAppend = True
  Exit Function
nogo:
        
End Function





Attribute VB_Name = "DieseArbeitsmappe"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Extractor"
Option Explicit

Private m_FName As String
Private m_Type As Long
Private m_Xlsv As XLScriptVar
Private m_Txt As String

Private Sub OverreadLine(ByRef codeValRet As String)
  On Error GoTo 0
  Dim i As Long
  i = 1
  Do While i < Len(codeValRet) And Mid(codeValRet, i, 1) <> vbCr And Mid(codeValRet, i, 1) <> vbLf
    i = i + 1
  Loop
  Do While i < Len(codeValRet) And (Mid(codeValRet, i, 1) = vbCr Or Mid(codeValRet, i, 1) = vbLf)
    i = i + 1
  Loop
  If i > 1 Then
    codeValRet = Mid(codeValRet, i)
  End If
End Sub

Private Function GetNextChar(ByRef codeValRet As String) As String
  On Error GoTo 0
  OverreadBlanks codeValRet
  If Len(codeValRet) > 0 Then
    GetNextChar = Left(codeValRet, 1)
    codeValRet = Mid(codeValRet, 2)
  End If
End Function

Private Sub OverreadBlanks(ByRef codeValRet As String)
  On Error GoTo 0
  Dim i As Long
  i = 1
  Do While Mid(codeValRet, i, 1) = " " Or Mid(codeValRet, i, 1) = vbCr Or Mid(codeValRet, i, 1) = vbLf
    i = i + 1
  Loop
  If i > 1 Then
    codeValRet = Mid(codeValRet, i)
  End If
End Sub

Private Function GetToken(ByRef codeValRet As String) As String
  On Error GoTo 0
  Dim token As String
  Dim i As Long
  i = 0
  OverreadBlanks codeValRet
  If Left(codeValRet, 1) = Chr(34) Then
    codeValRet = Mid(codeValRet, 2)
    Do While Mid(codeValRet, i + 1, 1) <> Chr(34) And i < Len(codeValRet)
      i = i + 1
    Loop
    If i > 0 Then
      token = Left(codeValRet, i)
      codeValRet = Mid(codeValRet, i + 1)
      If Left(codeValRet, 1) = Chr(34) Then
        codeValRet = Mid(codeValRet, 2)
      End If
      OverreadBlanks codeValRet
    End If
  Else
    If ((Mid(codeValRet, i + 1, 1) >= "a" And Mid(codeValRet, i + 1, 1) <= "z") Or _
      (Mid(codeValRet, i + 1, 1) >= "A" And Mid(codeValRet, i + 1, 1) <= "Z")) And i < Len(codeValRet) Then
      Do While ((Mid(codeValRet, i + 1, 1) >= "a" And Mid(codeValRet, i + 1, 1) <= "z") Or _
        (Mid(codeValRet, i + 1, 1) >= "A" And Mid(codeValRet, i + 1, 1) <= "Z") Or _
        (Mid(codeValRet, i + 1, 1) >= "0" And Mid(codeValRet, i + 1, 1) <= "9") Or _
         Mid(codeValRet, i + 1, 1) = "_" Or _
         Mid(codeValRet, i + 1, 1) = "|fffd|" Or _
         Mid(codeValRet, i + 1, 1) = "|fffd|" Or _
         Mid(codeValRet, i + 1, 1) = "|fffd|" Or _
         Mid(codeValRet, i + 1, 1) = "|fffd|" Or _
         Mid(codeValRet, i + 1, 1) = "|fffd|" Or _
         Mid(codeValRet, i + 1, 1) = "|fffd|" Or _
         Mid(codeValRet, i + 1, 1) = "|fffd|" _
         ) And i < Len(codeValRet)
        i = i + 1
      Loop
      If i > 0 Then
        token = Left(codeValRet, i)
        codeValRet = Mid(codeValRet, i + 1)
        OverreadBlanks codeValRet
      End If
    Else
      token = GetNextChar(codeValRet)
    End If
  End If
  
  GetToken = token
End Function


Sub TestFRead()
  Dim ttext As String
  ttext = pvReadFile("D:\development\Access-Checker\..\Temp\ACCExt-" & GetUserName & ".txt")
  
  Debug.Print ttext
End Sub

Sub Extract(ff As Integer, fname As String, typ As Long, ByRef xlsv As XLScriptVar, ByRef loc As Long, ByRef locomm As Long, ByRef checksum As Long, modName As String, ByRef xlsarr As XLScriptArray2D, txtExtension As String)
  
  m_FName = fname
  m_Type = typ
  Set m_Xlsv = xlsv
  
  If Not FileExists(fname) Then Exit Sub
  
'  Dim ff
'  ff = FreeFile
'  Open fname For Input As #ff
'  m_Txt = Input(MyFileLen(fname), #ff)
'  Close #ff
    
  m_Txt = pvReadFile(fname)
  
'  AddChecksum checksum, m_Txt
    
  m_Xlsv.Properties.Add m_Txt, "CODE"
  m_Txt = RemoveComments(m_Txt)
'  Debug.Print txt

  If m_Type = 4 Then ' acMacro
    ExtractMacro ff, loc, locomm, checksum, modName, xlsarr, txtExtension
  Else
    AddChecksum checksum, m_Txt, txtExtension & ".CODE", ff
  End If
  
End Sub

Sub ExtractMacro(ff As Integer, ByRef loc As Long, ByRef locomm As Long, ByRef checksum As Long, modName As String, ByRef xlsarr As XLScriptArray2D, txtExtension As String)
  Dim tok As String
  Dim tok2 As String
  Dim tTxt As String
  Do
    If Left(Trim(m_Txt), 5) = "Begin" Then Exit Do
    GetLine m_Txt
  Loop While Len(m_Txt) > 0
    
  Do While Len(m_Txt) > 0
        tok2 = Trim(GetLine(m_Txt))
        tTxt = tTxt & tok2 & vbCrLf
        
'        tChecksum = AddChecksum(checksum, tok2, txtExtension & ".CODE", ff)
        
        If tok2 = "Action =""OpenTable""" Then
          Dim txlsv As XLScriptVar
          Set txlsv = m_Xlsv.GetScriptVar("USES")
          Dim ref As XLScriptArray
          Set ref = txlsv.GetScriptArray("TABLES")
          Do While GetToken(m_Txt) <> "Argument"
          Loop
          If GetNextChar(m_Txt) = "=" Then
            Dim tstr As String
            tstr = GetString(m_Txt)
          End If
          ref.items.Add tstr
        End If
        If Left(tok2, 9) = "Comment =" Then
          If Len(Trim(Mid(tok2, 10))) >= 8 Then
            locomm = locomm + 1
          End If
        End If
  Loop
  AddChecksumAndVar ff, modName, checksum, tTxt, xlsarr, txtExtension & "*CODE"
      
End Sub


Function RemoveComments(ByVal txt As String) As String
  Dim i As Long
  Dim nutxt As String
  For i = 1 To Len(txt)
    If Mid(txt, i, 1) = Chr(34) Then
      nutxt = nutxt + Mid(txt, i, 1)
      i = i + 1
      While Mid(txt, i, 1) <> Chr(34)
        nutxt = nutxt + Mid(txt, i, 1)
        i = i + 1
      Wend
      nutxt = nutxt + Mid(txt, i, 1)
    ElseIf Mid(txt, i, 1) = "'" Then
      While Mid(txt, i, 1) <> Chr(10) And Mid(txt, i, 1) <> Chr(13)
        i = i + 1
      Wend
      nutxt = nutxt + Mid(txt, i, 1)
    Else
      nutxt = nutxt + Mid(txt, i, 1)
    End If
  Next i
  RemoveComments = nutxt
End Function

Attribute VB_Name = "FileFuncs"
Option Explicit

'  Shell File Operations

Private Const FO_MOVE = &H1
Private Const FO_COPY = &H2
Private Const FO_DELETE = &H3
Private Const FO_RENAME = &H4
Private Const FOF_MULTIDESTFILES = &H1
Private Const FOF_CONFIRMMOUSE = &H2
Private Const FOF_SILENT = &H4                      '  don't create progress/report
Private Const FOF_RENAMEONCOLLISION = &H8
Private Const FOF_NOCONFIRMATION = &H10             '  Don't prompt the user.
Private Const FOF_WANTMAPPINGHANDLE = &H20          '  Fill in SHFILEOPSTRUCT.hNameMappings
                                      '  Must be freed using SHFreeNameMappings
Private Const FOF_ALLOWUNDO = &H40
Private Const FOF_FILESONLY = &H80                  '  on *.*, do only files
Private Const FOF_SIMPLEPROGRESS = &H100            '  means don't show names of files
Private Const FOF_NOCONFIRMMKDIR = &H200            '  don't confirm making any needed dirs

#If VBA7 And Win64 Then
  ' Done
     Type SHFILEOPSTRUCT
         hwnd As LongPtr
         wFunc As Long
         pFrom As String
         pTo As String
         fFlags As Integer
         fAborted As Boolean
         hNameMaps As LongPtr
         sProgress As String
     End Type
     Declare PtrSafe Function SHFileOperation Lib "shell32.dll" Alias "SHFileOperationA" _
                                      (lpFileOp As SHFILEOPSTRUCT) As LongPtr
 #Else
     Type SHFILEOPSTRUCT
         hwnd As Long
         wFunc As Long
         pFrom As String
         pTo As String
         fFlags As Integer
         fAborted As Boolean
         hNameMaps As Long
         sProgress As String
     End Type
     Declare Function SHFileOperation Lib "shell32.dll" Alias "SHFileOperationA" _
                                      (lpFileOp As SHFILEOPSTRUCT) As Long
 #End If

Const OFN_READONLY           As Long = &H1
Const OFN_EXPLORER           As Long = &H80000
Const OFN_LONGNAMES          As Long = &H200000
Const OFN_CREATEPROMPT       As Long = &H2000
Const OFN_NODEREFERENCELINKS As Long = &H100000
Const OFN_OVERWRITEPROMPT    As Long = &H2
Const OFN_HIDEREADONLY       As Long = &H4
Const OFS_FILE_OPEN_FLAGS    As Long = OFN_EXPLORER _
                                    Or OFN_LONGNAMES _
                                    Or OFN_CREATEPROMPT _
                                    Or OFN_NODEREFERENCELINKS
Const OFS_FILE_SAVE_FLAGS    As Long = OFN_EXPLORER _
                                    Or OFN_LONGNAMES _
                                    Or OFN_OVERWRITEPROMPT _
                                    Or OFN_HIDEREADONLY
#If VBA7 And Win64 Then

Public Declare PtrSafe Function GetOpenFileName Lib "comdlg32.dll" Alias _
             "GetOpenFileNameA" (pOpenfilename As OPENFILENAME) As Long
        
     Public Type OPENFILENAME
         lStructSize As Long
         hwndOwner As LongPtr
         hInstance As LongPtr
         lpstrFilter As String
         lpstrCustomFilter As String
         nMaxCustFilter As Long
         nFilterIndex  As Long
         lpstrFile As String
         nMaxFile As Long
         lpstrFileTitle As String
         nMaxFileTitle  As Long
         lpstrInitialDir As String
         lpstrTitle As String
         flags As Long
         nFileOffset As Integer
         nFileExtension As Integer
         lpstrDefExt As String
         lCustData As LongPtr
         lpfnHook As LongPtr
         lpTemplateName As String
     End Type
    

  ' Done
Private Declare PtrSafe Function GetParent Lib "user32" (ByVal hwnd As LongPtr) As LongPtr
' Private Declare PtrSafe Function SetWindowText Lib "user32" Alias "SetWindowTextA" (ByVal hwnd As LongPtr, ByVal lpString As String) As Long
' Private Declare PtrSafe Function MoveWindow Lib "user32" (ByVal hwnd As LongPtr, ByVal x As Long, ByVal y As Long, ByVal nWidth As Long, ByVal nHeight As Long, ByVal bRepaint As Long) As Long
  

Declare PtrSafe Function GetSaveFileName Lib "comdlg32.dll" Alias _
    "GetSaveFileNameA" (pOpenfilename As OPENFILENAME) As Long
Declare PtrSafe Function GetShortPathName Lib "Kernel32.dll" Alias _
    "GetShortPathNameA" (ByVal lpszLongPath As String, _
                         ByVal lpszShortPath As String, _
                         ByVal cchBuffer As Long) As Long


Private Declare PtrSafe Sub CoTaskMemFree Lib "ole32.dll" _
     (ByVal hMem As LongPtr)

Private Declare PtrSafe Function lstrcat Lib "kernel32" Alias "lstrcatA" (ByVal lpString1 As String, ByVal lpString2 As String) As LongPtr

Private Declare PtrSafe Function SHGetPathFromIDList Lib "shell32" _
   (ByVal pidList As LongPtr, ByVal lpBuffer As String) As Long


     Public Type BROWSEINFO
         lngHWnd As LongPtr
         pidlRoot As LongPtr
         pszDisplayName As String
         lpszTitle As String
         ulFlags As Long
         lpfn As LongPtr
         lParam As LongPtr
         iImage As Long
     End Type
                         
     Private Declare PtrSafe Function SHBrowseForFolder Lib "shell32.dll" Alias "SHBrowseForFolderA" _
         (lpBrowseInfo As BROWSEINFO) As Long

#Else

    Public Declare Function GetOpenFileName Lib "comdlg32.dll" Alias _
             "GetOpenFileNameA" (pOpenfilename As OPENFILENAME) As Long
        
     Public Type OPENFILENAME
         lStructSize As Long
         hwndOwner As Long
         hInstance As Long
         lpstrFilter As String
         lpstrCustomFilter As String
         nMaxCustFilter As Long
         nFilterIndex  As Long
         lpstrFile As String
         nMaxFile As Long
         lpstrFileTitle As String
         nMaxFileTitle  As Long
         lpstrInitialDir As String
         lpstrTitle As String
         flags As Long
         nFileOffset As Integer
         nFileExtension As Integer
         lpstrDefExt As String
         lCustData As Long
         lpfnHook As Long
         lpTemplateName As String
     End Type

Private Declare Function GetParent Lib "user32" (ByVal hwnd As Long) As Long
' Private Declare Function SetWindowText Lib "user32" Alias "SetWindowTextA" (ByVal hwnd As Long, ByVal lpString As String) As Long
' Private Declare Function MoveWindow Lib "user32" (ByVal hwnd As Long, ByVal x As Long, ByVal y As Long, ByVal nWidth As Long, ByVal nHeight As Long, ByVal bRepaint As Long) As Long
   
  
Declare Function GetSaveFileName Lib "comdlg32.dll" Alias _
    "GetSaveFileNameA" (pOpenfilename As OPENFILENAME) As Long
Declare Function GetShortPathName Lib "Kernel32.dll" Alias _
    "GetShortPathNameA" (ByVal lpszLongPath As String, _
                         ByVal lpszShortPath As String, _
                         ByVal cchBuffer As Long) As Long


Private Declare Sub CoTaskMemFree Lib "ole32.dll" _
     (ByVal hMem As Long)

Private Declare Function lstrcat Lib "kernel32" _
    Alias "lstrcatA" (ByVal lpString1 As String, _
    ByVal lpString2 As String) As Long

Private Declare Function SHGetPathFromIDList Lib "shell32" _
   (ByVal pidList As Long, ByVal lpBuffer As String) As Long


     Public Type BROWSEINFO
         lngHWnd As Long
         pidlRoot As Long
         pszDisplayName As String
         lpszTitle As String
         ulFlags As Long
         lpfn As Long
         lParam As Long
         iImage As Long
     End Type
                         
     Private Declare Function SHBrowseForFolder Lib "shell32.dll" Alias "SHBrowseForFolderA" _
         (lpBrowseInfo As BROWSEINFO) As Long

#End If

Public Sub SyncCopy(Dateiname$, zielverzeichnis$)

Dim filenames$
Dim i As Integer
Dim shellinfo As SHFILEOPSTRUCT

filenames = Dateiname + Chr(0)

With shellinfo
        .hwnd = 0 ' Screen.ActiveForm.Hwnd
        .wFunc = FO_COPY
        .pFrom = filenames
        .pTo = zielverzeichnis
        .fFlags = FOF_FILESONLY + FOF_NOCONFIRMATION + FOF_NOCONFIRMMKDIR + FOF_SILENT
End With

SHFileOperation shellinfo

End Sub

' Dateioperationen

Public Sub CopyFile(Dateiname$, zielverzeichnis$, Optional inklusiveUnterverzeichnisse)

  Dim arr(1) As String
  arr(0) = Dateiname
  
  CopyPlus arr, zielverzeichnis, inklusiveUnterverzeichnisse

End Sub

Public Sub CopyPlus(dateinamen$(), zielverzeichnis$, Optional inklusiveUnterverzeichnisse)

Dim filenames$
Dim i As Integer
Dim shellinfo As SHFILEOPSTRUCT

For i = 0 To UBound(dateinamen)
    filenames = filenames & dateinamen(i) + Chr(0)
Next i
filenames = filenames + Chr(0)

With shellinfo
        .hwnd = 0 ' Screen.ActiveForm.Hwnd
        .wFunc = FO_COPY
        .pFrom = filenames
        .pTo = zielverzeichnis
        If Not IsMissing(inklusiveUnterverzeichnisse) Then
            If Not inklusiveUnterverzeichnisse Then .fFlags = FOF_FILESONLY
        End If
End With

SHFileOperation shellinfo

End Sub

Public Function Move(dateinamen$(), zielverzeichnis$, Optional inklusiveUnterverzeichnisse)

Dim filenames$
Dim i As Integer
Dim shellinfo As SHFILEOPSTRUCT

For i = 0 To UBound(dateinamen)
    filenames = filenames & dateinamen(i) + Chr(0)
Next i
filenames = filenames + Chr(0)

With shellinfo
        .hwnd = 0 ' Screen.ActiveForm.Hwnd
        .wFunc = FO_COPY
        .pFrom = filenames
        .pTo = zielverzeichnis
        If Not IsMissing(inklusiveUnterverzeichnisse) Then
            If Not inklusiveUnterverzeichnisse Then .fFlags = FOF_FILESONLY
        End If
End With

SHFileOperation shellinfo

End Function

Public Function Delete(dateinamen$(), Optional inklusiveUnterverzeichnisse)
Dim filenames$
Dim i As Integer
Dim shellinfo As SHFILEOPSTRUCT

For i = 0 To UBound(dateinamen)
    filenames = filenames & dateinamen(i) + Chr(0)
Next i
filenames = filenames + Chr(0)

With shellinfo
        .hwnd = 0 ' Screen.ActiveForm.Hwnd
        .wFunc = FO_DELETE
        .pFrom = filenames
        .pTo = "" + Chr(0)
        If Not IsMissing(inklusiveUnterverzeichnisse) Then
            If Not inklusiveUnterverzeichnisse Then .fFlags = FOF_FILESONLY
        End If
End With

SHFileOperation shellinfo

End Function


Function GetPath(ByVal p As String) As String
  If InStrRev(p, "\") > 0 Then
    GetPath = Left(p, InStrRev(p, "\") - 1)
    Exit Function
  End If
  GetPath = p
End Function

Function GetExtension(ByVal p As String) As String
    Dim slash As Long
    slash = InStrRev(p, "\")
    Dim dot As Long
    dot = InStrRev(p, ".")
    
    If dot > slash Then
        GetExtension = Mid(p, dot + 1)
        Exit Function
    End If
    GetExtension = ""
End Function




Public Function DateinameMitVersionsnummer(name As String, Version As String, mitDatum As Boolean)
    
    ' nur den Dateinamen nehmen
    Dim slash As Long
    slash = InStrRev(name, "\")
    If slash > 0 Then
        name = Mid(name, slash + 1)
    End If
    Version = Trim(Version)
    
    ' und vor der Extension noch die Versionsnummer eintragen
    Dim dot As Long
    dot = InStrRev(name, ".")
    If dot > 0 Then
        Dim ext As String
        ext = Mid(name, dot)
        
        name = Left(name, dot - 1) & "_V" & Version
        If mitDatum Then
' NN - 7.8.2011
            name = name & "_" & year(Now) & "_" & month(Now) & "_" & day(Now)
' NN - 7.8.2011 - ENDE
        End If
        name = name & ext
    Else
        name = name & "_V" & Version
        If mitDatum Then
' NN - 7.8.2011
            name = name & "_" & year(Now) & "_" & month(Now) & "_" & day(Now)
' NN - 7.8.2011 - ENDE
        End If
    End If
    
    DateinameMitVersionsnummer = name

End Function

Function GetFileNameAndExtension(ByVal fn As String)
    Dim File As String
    Dim path As String
    Dim ext As String
    
    fileSplit fn, path, File, ext
    GetFileNameAndExtension = File & "." & ext
End Function

Sub fileSplit(ByVal s$, ByRef path$, ByRef File$, ByRef ext$)
    ' die Prozedur zerlegt den Dateinamen S in Path, Name, Extension
    Dim i%
    For i = Len(s) To 1 Step -1
        If Mid(s, i, 1) = "\" Or Mid(s, i, 1) = "/" Then   ' keine Extension vorhanden
            ext = ""
            Exit For
        End If
        If Mid(s, i, 1) = "." Then
            ext = Right(s, Len(s) - i)
            s = Left(s, i - 1)
            Exit For
        End If
    Next i
    i = Len(s)
    If InStr(s, "\") <> 0 Then
        While Mid(s, i, 1) <> "\"
            i = i - 1
        Wend
    ElseIf InStr(s, "/") <> 0 Then
        While Mid(s, i, 1) <> "/"
            i = i - 1
        Wend
    End If
    path = Left(s, i)
    File = Right(s, Len(s) - i)

End Sub

Function ShowFileDialog(sInitDir As String, s|fffd|berschrift As String, sFilter As String, Optional saveDlg = False, Optional fname As String = "") As String
    ' Calls the API File Save Dialog Window
    ' Returns full path to new File
    
    On Error GoTo Err_fFileDialog
    
    ' Call the File Common Dialog Window
    Dim clsDialog As Object
    Dim strTemp As String
    Dim strFname As String
    
    Set clsDialog = New clsCommonDialog
    
    ' Fill in our structure
    ' I'll leave in how to select Gif and Jpeg to
    ' show you how to build the Filter in case you want
    ' to use this code in another project.
    clsDialog.Filter = sFilter ' "PDF (*.PDF)" & Chr$(0) & "*.PDF" & Chr$(0)
    'clsDialog.Filter = clsDialog.Filter & "Gif (*.GIF)" & Chr$(0) & "*.GIF" & Chr$(0)
    'clsDialog.Filter = "ALL (*.*)" & Chr$(0) & "*.*" & Chr$(0)
    clsDialog.hDC = 0
    clsDialog.MaxFileSize = 256
    clsDialog.Max = 256
    clsDialog.FileTitle = vbNullString
    clsDialog.DialogTitle = s|fffd|berschrift
    clsDialog.InitDir = sInitDir & vbNullString
    clsDialog.DefaultExt = vbNullString
    clsDialog.Filename = fname
    
    ' Display the File Dialog
    If saveDlg Then
      clsDialog.ShowSave
    Else
      clsDialog.ShowOpen
    End If
    
    ' See if user clicked Cancel or even selected
    ' the very same file already selected
    If clsDialog.APIReturn = 1 Then
      strFname = clsDialog.Filename
    Else
      strFname = ""
    End If
    'If Len(strFname & vbNullString) = 0 Then
    ' Raise the exception
     ' Err.Raise vbObjectError + 513, "clsPrintToFit.fFileDialog", _
      '"Please type in a Name for a New File"
    'End If
    
    ' Return File Path and Name
    ShowFileDialog = strFname
    
Exit_fFileDialog:
    
    Err.Clear
    Set clsDialog = Nothing
    Exit Function
    
Err_fFileDialog:
    ShowFileDialog = ""
    MsgBox Err.Description, vbOKOnly, Err.Source & ":" & Err.Number
    Resume Exit_fFileDialog

End Function





Attribute VB_Name = "Globals"
Option Explicit

Global GSprache As Long
'Public Const MyVersion As String = "Version 2.1"
Public Const MyVersionString As String = "2.3"
Public Const MyInternalVersion As Long = 9
Public Const ProgNameShort As String = "ACC"
Public Const ProgNameLong As String = "Access-Checker"
Public Const MyAppID = 13

Public AR_UseDB  As Boolean
Public AR_StartedByApp As StromwerkenAppID

' Diese Version wird in der IDV-Suite verwendet, um mit dem "richtigen" ACC zu Scannen. Version 0 ist der "Ur-ACC". Dier Versionsnummer
' |fffd|ndert sich nur, wenn sich auch der Checksummenalogrithmus |fffd|ndert.
Public Const MyACCVersion As Long = 1


Public G_ACCPro As Boolean

Public trs As String
Public trsShrt As String
Public FullVersion As Boolean

Public trsLngSelect As String

Public theAccessScannerVersion As Long

Public xlsDateien As Collection
Public inaccessablePaths As Collection
Public Funcs As Collection
Public TotalUsedBytes As Long
Public TotalUsedFiles As Long
Public TotalUnusedBytes As Long
Public TotalUnusedFiles As Long
Public TotalUnusedBytesOlder As Long
Public TotalUnusedFilesOlder As Long
Public TotalUnusedBytesSmaller As Long
Public TotalUnusedFilesSmaller As Long
Public TotalUnusedBytesDouble As Long
Public TotalUnusedFilesDouble As Long

Public LastProgText As String
Public ProgText As String
Public theFilename As String

Public Trans

Public Const MYadOpenDynamic As Long = 2
Public Const MYadLockPessimistic As Long = 2
Public Const MYadLockOptimistic As Long = 3
Public Const MYadLockReadOnly As Long = 1

Public G_cfgLogpfad As String
Public G_cfgTemppfad As String
Public G_cfgKeypfad As String
Public G_cfgPasswortpfad As String


Public G_RiskTabs As Collection ' RiskTab
Public G_RiskContains As Collection ' RiskVal
Public G_WhiteList As Collection ' RiskVal

Public Const C_RISK_TYPE_ECC As Long = 1
Public Const C_RISK_TYPE_FORMULA_CONTAINS As Long = 2
Public Const C_RISK_TYPE_NOT_IN_WHITE_LIST As Long = 3
Public Const C_RISK_TYPE_WHITE_LIST As Long = 4

Public Const C_RISK_COMP_TYPE_LESS As Long = 1
Public Const C_RISK_COMP_TYPE_LESSEQUAL As Long = 2
Public Const C_RISK_COMP_TYPE_EQUAL As Long = 3
Public Const C_RISK_COMP_TYPE_LARGEREQUAL As Long = 4
Public Const C_RISK_COMP_TYPE_LARGER As Long = 5


Public G_RiskLow As Double
Public G_RiskMed As Double
Public G_RiskLowCol As Long
Public G_RiskMedCol As Long
Public G_RiskHighCol As Long
Public G_ColorCells As Boolean

Public G_Cursorlocation As Long

Public G_DBConnectionString As String
Public G_AnalyseFile As String

Public G_StartScan As Date
Public G_EndScan As Date

Public G_SchedulerTimeCheckIgnore As Boolean

Public Function MyVersion() As String
  MyVersion = FMT1("GLOBALS_1", MyVersionString)
End Function

Function FormulaAnalyzable(c) As Boolean
  FormulaAnalyzable = True
  On Error GoTo notAnalyzable
  If c.Formula = "a" Then
  End If
  Exit Function
notAnalyzable:
  FormulaAnalyzable = False
End Function

Function TranslateFunc(s As String) As String
  On Error GoTo noTrans
  TranslateFunc = Trans(s)
  Exit Function
noTrans:
  TranslateFunc = s
End Function


Sub FreeAllMem()
'  ActiveSheet.UsedRange
  Set Trans = Nothing
  Set xlsDateien = Nothing
  Set inaccessablePaths = Nothing
  Set Funcs = Nothing
End Sub


Sub ScanDirs(Pfad As String, nichtaelterals As Long, nichtkleinerals As Long, gleichenamenignorieren As Boolean, unterverzeichnisseIgnorieren As Boolean)

'   .MousePointer = fmMousePointerHourGlass
'  Me.MousePointer = fmMousePointerDefault

    Dim name As String
    Dim Verzeichnisse As New Collection
    ' Erst mal alle Verzeichnisse holen!
    On Error GoTo inaccessablePath
    name = Dir(Pfad & "\*.*", vbDirectory) ' Ersten Eintrag abrufen.
'    On Error GoTo 0
  On Error Resume Next
    Do While name <> ""    ' Schleife beginnen.
        ' Aktuelles und |fffd|bergeordnetes Verzeichnis ignorieren.
        If name <> "." And name <> ".." Then
            ' Mit bit-weisem Vergleich sicherstellen, da|fffd| name ein
            ' Verzeichnis ist.
            Err.Number = 0
            If (GetAttr(Pfad & "\" & name) And vbDirectory) = vbDirectory Then
                If Err.Number = 0 Then Verzeichnisse.Add Pfad & "\" & name  ' Eintrag nur anzeigen, wenn es sich
            Else
                ' Ansonsten ist es eine Datei! Wenn es ein Excel-Sheet ist, dann wird
                ' es in die xlsDateien - Collection mitaufgenommen
                If UCase(Right(name, 4)) = ".XLS" Or UCase(Right(name, 4)) = ".XLT" Or UCase(Right(name, 4)) = ".XLA" Then
                    ' Nicht die eigene Datei!!!!!
                    If ThisWorkbook.FullName <> Pfad & "\" & name Then
                      Dim used As Boolean
                      used = False
                      ' Wenn die Dateikriterien passen
                      If MyFileLen(Pfad & "\" & name) >= nichtkleinerals * 1024 Then
                        Dim fd As Date
                        fd = Format(MyFileDateTime(Pfad & "\" & name), "Short Date")
                        If Format(DateAdd("m", -nichtaelterals, Now()), "Short Date") <= fd Then
                          If gleichenamenignorieren = True Then
                            If FilenameDoesntExistAbove(Pfad, name) Then
                              xlsDateien.Add Pfad & "\" & name
                              used = True
                            Else
                              TotalUnusedBytesDouble = TotalUnusedBytesDouble + MyFileLen(Pfad & "\" & name)
                              TotalUnusedFilesDouble = TotalUnusedFilesDouble + 1
                            End If
                          Else
                            xlsDateien.Add Pfad & "\" & name
                            used = True
                          End If
                        Else
                          TotalUnusedBytesOlder = TotalUnusedBytesOlder + MyFileLen(Pfad & "\" & name)
                          TotalUnusedFilesOlder = TotalUnusedFilesOlder + 1
                        End If
                      Else
                        TotalUnusedBytesSmaller = TotalUnusedBytesSmaller + MyFileLen(Pfad & "\" & name)
                        TotalUnusedFilesSmaller = TotalUnusedFilesSmaller + 1
                      End If
                      If Not used Then
                        TotalUnusedBytes = TotalUnusedBytes + MyFileLen(Pfad & "\" & name)
                        TotalUnusedFiles = TotalUnusedFiles + 1
                      Else
                        TotalUsedBytes = TotalUsedBytes + MyFileLen(Pfad & "\" & name)
                        TotalUsedFiles = TotalUsedFiles + 1
                      End If
                    End If
                End If
            End If
        End If
        name = Dir ' N|fffd|chsten Eintrag abrufen.
    Loop
    
    Dim item
    Dim tstring As String
    If Not unterverzeichnisseIgnorieren Then
      For Each item In Verzeichnisse
          tstring = item
          ScanDirs tstring, nichtaelterals, nichtkleinerals, gleichenamenignorieren, unterverzeichnisseIgnorieren
      Next item
    End If
    
    Set Verzeichnisse = Nothing

    Exit Sub
    
inaccessablePath:
    inaccessablePaths.Add Pfad

End Sub



Function GetPermission(usrGrp As String, objclass As String, objname As String) As Long
  Dim d As Document
  Set d = m_DB.Containers(objclass).Documents(objname)
  d.UserName = usrGrp
  GetPermission = d.Permissions
End Function

Function DoThat(t As String) As String

    Dim i As Long
    Dim s2 As String
    For i = 1 To Len(t)
        If Mid(t, i, 1) = "@" Then
            s2 = s2 + vbLf
        ElseIf Mid(t, i, 1) = "^" Then
            s2 = s2 + " "
        ElseIf Mid(t, i, 1) >= "0" And Mid(t, i, 1) <= "9" Then
          s2 = s2 + Chr(Asc("0") + Asc("9") - Asc(Mid(t, i, 1)))
        ElseIf Mid(t, i, 1) >= "a" And Mid(t, i, 1) <= "z" Then
          s2 = s2 + Chr(Asc("a") + Asc("z") - Asc(Mid(t, i, 1)))
        ElseIf Mid(t, i, 1) >= "A" And Mid(t, i, 1) <= "Z" Then
          s2 = s2 + Chr(Asc("A") + Asc("Z") - Asc(Mid(t, i, 1)))
        Else
            s2 = s2 + Mid(t, i, 1)
        End If
    Next i
    
    DoThat = s2
End Function


Sub GetDataOld()
  On Error GoTo noData
  Dim app As Excel.Application
  Dim wb As Excel.Workbook
  Set app = New Excel.Application
  Set wb = app.Workbooks.Open(ThisWorkbook.path & "\" & DoThat("HDIvh.coz"), False, True, , "k$a5iUTe4hf2!/{", , True, , , False, False, , False)
    If wb.Sheets(1).Cells(1, 1) = "1fdd34/lkMTzdfZZQ12()//|fffd|245mNGNndflRltdaf''++.,LpiUGF" Then
      If Len(wb.Sheets(1).Cells(5, 1)) > 0 Then
        FullVersion = True
        trs = DoThat(wb.Sheets(1).Cells(5, 1))
        trsShrt = DoThat(wb.Sheets(1).Cells(5, 2))
        trsLngSelect = wb.Sheets(1).Cells(5, 3)
      End If
    End If
  wb.Close False
  Set wb = Nothing
  app.Quit
  Set app = Nothing
  Exit Sub
noData:
  Exit Sub
End Sub

Sub InitApp()
  Dim cfg As CfgReader
  Dim s As String
  
  Set cfg = New CfgReader
  
  G_cfgKeypfad = ThisWorkbook.path
  G_cfgLogpfad = ThisWorkbook.path
  G_cfgTemppfad = ThisWorkbook.path
  G_cfgPasswortpfad = ThisWorkbook.path
  
  If FileExists(ThisWorkbook.path & "\ACC.cfg") = True Or FileExists(ThisWorkbook.path & "\..\cfg\IDV-Suite.cfg") = True Or FileExists(ThisWorkbook.path & "\..\..\cfg\IDV-Suite.cfg") = True Then

      If FileExists(ThisWorkbook.path & "\ACC.cfg") = True Then
        cfg.GetCfg ThisWorkbook.path & "\ACC.cfg"
      ElseIf FileExists(ThisWorkbook.path & "\..\cfg\IDV-Suite.cfg") Then
        cfg.GetCfg ThisWorkbook.path & "\..\cfg\IDV-Suite.cfg"
      ElseIf FileExists(ThisWorkbook.path & "\..\..\cfg\IDV-Suite.cfg") Then
        cfg.GetCfg ThisWorkbook.path & "\..\..\cfg\IDV-Suite.cfg"
      End If
      
      Call InitTranslation(ThisWorkbook.path, "ACC", cfg)
      
      GetDBUser cfg
      
      If cfg.GetSection("DB") = True Then
        G_DBConnectionString = cfg.GetValue("CONNECTIONSTRING")
      End If
      
      If cfg.GetSection("ACC") = True Then
          s = cfg.GetValue("HELLOWORLD")
          'If UCase(s) = "JA" Then
          If IsYes(s) Then
            'MsgBox "Hinweis: Der AccessChecker wurde gestartet. Sie k|fffd|nnen diesen Hinweis in der Datei ACC.cfg (oder IDV-Suite.cfg)) deaktivieren. Stellen Sie dort bitte den Parameter HELLOWORLD auf Nein", vbInformation
            MsgBox FMT0("GLOBALS_2"), vbInformation
          End If
          s = cfg.GetValue("LOG")
          'If UCase(s) = "JA" Then
          If IsYes(s) Then
            G_LogEnabled = True
          End If
          s = cfg.GetValue("LOGPRINTCHECKSUM")
          'If UCase(s) = "JA" Then
          If IsYes(s) Then
            G_LogPrintChecksum = True
          End If
      
      End If
      If cfg.GetSection("GLOBALS") = True Then
          G_cfgKeypfad = GetRelativePath(G_cfgKeypfad, cfg.GetValue("KEYPFAD"))
          G_cfgLogpfad = GetRelativePath(G_cfgLogpfad, cfg.GetValue("LOGPFAD"))
          G_cfgTemppfad = GetRelativePath(G_cfgTemppfad, cfg.GetValue("TEMPPFAD"))
          G_cfgPasswortpfad = GetRelativePath(G_cfgPasswortpfad, cfg.GetValue("PASSWORTPFAD"))
          
          s = cfg.GetValue("CURSORLOCATION")
          If UCase(s) = "SERVER" Then
            G_Cursorlocation = 2 ' ADODB.adUseServer
          Else
            G_Cursorlocation = 3 ' ADODB.adUseClient
          End If
      End If
      
      If cfg.GetSection("DBCONNECTEXT") = True Then
        Dim connnectCount As Long
        Dim drv As String
        For connnectCount = 1 To 10
          drv = cfg.GetValue("DRIVER" & connnectCount)
          If drv <> "" Then
            If FileExists(drv) Then
              G_DBConnectionString = cfg.GetValue("CONNECTIONSTRING" & connnectCount)
              Exit For
            End If
          End If
        Next connnectCount
      End If
      
      If AR_UseDB Then
        If cfg.GetSection("IDV-Suite Scheduler") = True Then
            If cfg.GetValue("KEYPFAD") <> "" Then
              G_cfgKeypfad = GetRelativePath(G_cfgKeypfad, cfg.GetValue("KEYPFAD"))
            End If
            If cfg.GetValue("LOGPFAD") <> "" Then
              G_cfgLogpfad = GetRelativePath(G_cfgLogpfad, cfg.GetValue("LOGPFAD"))
            End If
            If cfg.GetValue("TEMPPFAD") <> "" Then
              G_cfgTemppfad = GetRelativePath(G_cfgTemppfad, cfg.GetValue("TEMPPFAD"))
            End If
            If cfg.GetValue("PASSWORTPFAD") <> "" Then
              G_cfgPasswortpfad = GetRelativePath(G_cfgPasswortpfad, cfg.GetValue("PASSWORTPFAD"))
            End If
        End If
      End If
  Else
      Call InitTranslation(ThisWorkbook.path, "ACC", cfg)
  End If
  
  ClearLog

  LogPrint "ACC Start"

  DebugPrint tInfo, "Keypfad: " & G_cfgKeypfad
  DebugPrint tInfo, "Logpfad: " & G_cfgLogpfad
  DebugPrint tInfo, "Temppfad: " & G_cfgTemppfad
  DebugPrint tInfo, "Passwortpfad: " & G_cfgPasswortpfad
  DebugPrint tInfo, "AR_UseDB: " & IIf(AR_UseDB, "True", False)
  
  LogPrint "Programmteilpr|fffd|fung"
  Dim tmpfname As String
  
  'tmpfname = ThisWorkbook.path & "\ACC-Res.xls"
  tmpfname = gTranslation.GetLocalizedFile(ThisWorkbook.path & "\ACC-Einzelanalyse.xltx")
  
  If Not FileExists(tmpfname) Then
    If AR_UseDB = False Then
      'MsgBox "Die Datei '" & tmpfname & "' existiert nicht, der Access-Checker kann nicht ausgef|fffd|hrt werden!"
      MsgBox FMT1("GLOBALS_3", tmpfname)
    Else
      'AddStatus "Die Datei '" & tmpfname & "' existiert nicht, der Access-Checker kann nicht ausgef|fffd|hrt werden!"
      AddStatus FMT1("GLOBALS_3", tmpfname)
    End If
    Exit Sub
  End If
  
  LogPrint "Caption setzen"
  'Application.Caption = "Access-Checker"
  Application.Caption = ProgNameLong
  
    gCHR = ""
    gCursorLocation = 2
    If FileExists(ThisWorkbook.path & "\" & "oracle.cfg") = True Then
        gCHR = """"
        gCursorLocation = 3
    End If
  
  
  GetData
End Sub
Attribute VB_Name = "Hash"
Option Explicit

Private Const BITS_TO_A_BYTE = 8
Private Const BYTES_TO_A_WORD = 4
Private Const BITS_TO_A_WORD = 32

#If VBA7 Then
Private Declare PtrSafe Function apiGetComputerName Lib "kernel32" Alias _
    "GetComputerNameA" (ByVal lpBuffer As String, nSize As Long) As Long
#Else
Private Declare Function apiGetComputerName Lib "kernel32" Alias _
    "GetComputerNameA" (ByVal lpBuffer As String, nSize As Long) As Long
#End If

Public Function GetComputerName() As String
'Returns the computername
    Dim lngLen As Long, lngX As Long
    Dim strCompName As String
    lngLen = 16
    strCompName = String$(lngLen, 0)
    lngX = apiGetComputerName(strCompName, lngLen)
    If lngX <> 0 Then
        GetComputerName = Left$(strCompName, lngLen)
    Else
        GetComputerName = ""
    End If
End Function

Function GetDocProp(wb As Excel.Workbook, txt As String) As String
  On Error Resume Next
  GetDocProp = ""
  GetDocProp = wb.BuiltinDocumentProperties(txt)
End Function

Function GetFileHash(ByVal uncpathfname As String) As String

    If Mid(uncpathfname, 2, 1) = ":" Then
        GetFileHash = SHA256(uncpathfname)
'        GetFileHash = SHA256(uncpathfname & "|" & GetDocProp(wb, "Author") & GetDocProp(wb, "Creation date"))
    Else
        GetFileHash = SHA256(uncpathfname & "|" & GetComputerName)
'        GetFileHash = SHA256(uncpathfname & "|" & GetComputerName & "|" & GetDocProp(wb, "Author") & GetDocProp(wb, "Creation date"))
    End If

End Function


Private Function LShift(lValue, iShiftBits)
Dim m_lOnBits
m_lOnBits = Array(CLng(1), CLng(3), CLng(7), CLng(15), CLng(31), CLng(63), CLng(127), CLng(255), CLng(511), CLng(1023), CLng(2047), CLng(4095), CLng(8191), CLng(16383), CLng(32767), CLng(65535), CLng(131071), CLng(262143), CLng(524287), CLng(1048575), CLng(2097151), CLng(4194303), CLng(8388607), CLng(16777215), CLng(33554431), CLng(67108863), CLng(134217727), CLng(268435455), CLng(536870911), CLng(1073741823), CLng(2147483647))

Dim m_l2Power
m_l2Power = Array(1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824)


    If iShiftBits = 0 Then
        LShift = lValue
        Exit Function
    ElseIf iShiftBits = 31 Then
        If lValue And 1 Then
            LShift = &H80000000
        Else
            LShift = 0
        End If
        Exit Function
    ElseIf iShiftBits < 0 Or iShiftBits > 31 Then
        Err.Raise 6
    End If
    
    If (lValue And m_l2Power(31 - iShiftBits)) Then
        LShift = ((lValue And m_lOnBits(31 - (iShiftBits + 1))) * m_l2Power(iShiftBits)) Or &H80000000
    Else
        LShift = ((lValue And m_lOnBits(31 - iShiftBits)) * m_l2Power(iShiftBits))
    End If
End Function



Private Function RShift(lValue, iShiftBits)

  Dim m_l2Power
  m_l2Power = Array(1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824)

    If iShiftBits = 0 Then
        RShift = lValue
        Exit Function
    ElseIf iShiftBits = 31 Then
        If lValue And &H80000000 Then
            RShift = 1
        Else
            RShift = 0
        End If
        Exit Function
    ElseIf iShiftBits < 0 Or iShiftBits > 31 Then
        Err.Raise 6
    End If
    
    RShift = (lValue And &H7FFFFFFE) \ m_l2Power(iShiftBits)
    
    If (lValue And &H80000000) Then
        RShift = (RShift Or (&H40000000 \ m_l2Power(iShiftBits - 1)))
    End If
End Function



Private Function AddUnsigned(lX, lY)
    Dim lX4, lY4, lX8, lY8, lResult
 
    lX8 = lX And &H80000000
    lY8 = lY And &H80000000
    lX4 = lX And &H40000000
    lY4 = lY And &H40000000
 
    lResult = (lX And &H3FFFFFFF) + (lY And &H3FFFFFFF)
 
    If lX4 And lY4 Then
        lResult = lResult Xor &H80000000 Xor lX8 Xor lY8
    ElseIf lX4 Or lY4 Then
        If lResult And &H40000000 Then
            lResult = lResult Xor &HC0000000 Xor lX8 Xor lY8
        Else
            lResult = lResult Xor &H40000000 Xor lX8 Xor lY8
        End If
    Else
        lResult = lResult Xor lX8 Xor lY8
    End If
 
    AddUnsigned = lResult
End Function



Private Function Ch(x, y, z)
    Ch = ((x And y) Xor ((Not x) And z))
End Function



Private Function Maj(x, y, z)
    Maj = ((x And y) Xor (x And z) Xor (y And z))
End Function



Private Function s(x, n)
Dim m_lOnBits, m_l2Power, K
m_lOnBits = Array(CLng(1), CLng(3), CLng(7), CLng(15), CLng(31), CLng(63), CLng(127), CLng(255), CLng(511), CLng(1023), CLng(2047), CLng(4095), CLng(8191), CLng(16383), CLng(32767), CLng(65535), CLng(131071), CLng(262143), CLng(524287), CLng(1048575), CLng(2097151), CLng(4194303), CLng(8388607), CLng(16777215), CLng(33554431), CLng(67108863), CLng(134217727), CLng(268435455), CLng(536870911), CLng(1073741823), CLng(2147483647))

m_l2Power = Array(1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824)
K = Array(&H428A2F98, &H71374491, &HB5C0FBCF, &HE9B5DBA5, &H3956C25B, &H59F111F1, &H923F82A4, &HAB1C5ED5, &HD807AA98, &H12835B01, &H243185BE, &H550C7DC3, &H72BE5D74, &H80DEB1FE, &H9BDC06A7, &HC19BF174, &HE49B69C1, &HEFBE4786, &HFC19DC6, &H240CA1CC, &H2DE92C6F, &H4A7484AA, &H5CB0A9DC, &H76F988DA, &H983E5152, &HA831C66D, &HB00327C8, &HBF597FC7, &HC6E00BF3, &HD5A79147, &H6CA6351, &H14292967, &H27B70A85, &H2E1B2138, &H4D2C6DFC, &H53380D13, &H650A7354, &H766A0ABB, &H81C2C92E, &H92722C85, &HA2BFE8A1, &HA81A664B, &HC24B8B70, &HC76C51A3, &HD192E819, &HD6990624, &HF40E3585, &H106AA070, &H19A4C116, &H1E376C08, &H2748774C, &H34B0BCB5, &H391C0CB3, &H4ED8AA4A, &H5B9CCA4F, &H682E6FF3, &H748F82EE, &H78A5636F, &H84C87814, &H8CC70208, &H90BEFFFA, &HA4506CEB, &HBEF9A3F7, &HC67178F2)

    s = (RShift(x, (n And m_lOnBits(4))) Or LShift(x, (32 - (n And m_lOnBits(4)))))
End Function



Private Function r(x, n)
Dim m_lOnBits
m_lOnBits = Array(CLng(1), CLng(3), CLng(7), CLng(15), CLng(31), CLng(63), CLng(127), CLng(255), CLng(511), CLng(1023), CLng(2047), CLng(4095), CLng(8191), CLng(16383), CLng(32767), CLng(65535), CLng(131071), CLng(262143), CLng(524287), CLng(1048575), CLng(2097151), CLng(4194303), CLng(8388607), CLng(16777215), CLng(33554431), CLng(67108863), CLng(134217727), CLng(268435455), CLng(536870911), CLng(1073741823), CLng(2147483647))

    r = RShift(x, CLng(n And m_lOnBits(4)))
End Function



Private Function Sigma0(x)
    Sigma0 = (s(x, 2) Xor s(x, 13) Xor s(x, 22))
End Function



Private Function Sigma1(x)
    Sigma1 = (s(x, 6) Xor s(x, 11) Xor s(x, 25))
End Function



Private Function Gamma0(x)
    Gamma0 = (s(x, 7) Xor s(x, 18) Xor r(x, 3))
End Function



Private Function Gamma1(x)
    Gamma1 = (s(x, 17) Xor s(x, 19) Xor r(x, 10))
End Function



Private Function ConvertToWordArray(sMessage)
    Dim lMessageLength, lNumberOfWords, lWordArray(), lBytePosition, lByteCount
    Dim lWordCount, lByte
    
    Const MODULUS_BITS = 512
    Const CONGRUENT_BITS = 448
    
    lMessageLength = Len(sMessage)
    
    lNumberOfWords = (((lMessageLength + ((MODULUS_BITS - CONGRUENT_BITS) \ BITS_TO_A_BYTE)) \ (MODULUS_BITS \ BITS_TO_A_BYTE)) + 1) * (MODULUS_BITS \ BITS_TO_A_WORD)
    ReDim lWordArray(lNumberOfWords - 1)
    
    lBytePosition = 0
    lByteCount = 0
    Do Until lByteCount >= lMessageLength
        lWordCount = lByteCount \ BYTES_TO_A_WORD
        
        lBytePosition = (3 - (lByteCount Mod BYTES_TO_A_WORD)) * BITS_TO_A_BYTE
        
        lByte = AscB(Mid(sMessage, lByteCount + 1, 1))
        
        lWordArray(lWordCount) = lWordArray(lWordCount) Or LShift(lByte, lBytePosition)
        lByteCount = lByteCount + 1
    Loop

    lWordCount = lByteCount \ BYTES_TO_A_WORD
    lBytePosition = (3 - (lByteCount Mod BYTES_TO_A_WORD)) * BITS_TO_A_BYTE

    lWordArray(lWordCount) = lWordArray(lWordCount) Or LShift(&H80, lBytePosition)

    lWordArray(lNumberOfWords - 1) = LShift(lMessageLength, 3)
    lWordArray(lNumberOfWords - 2) = RShift(lMessageLength, 29)
    
    ConvertToWordArray = lWordArray
End Function



Public Function SHA256(sMessage)

Dim K
K = Array(&H428A2F98, &H71374491, &HB5C0FBCF, &HE9B5DBA5, &H3956C25B, &H59F111F1, &H923F82A4, &HAB1C5ED5, &HD807AA98, &H12835B01, &H243185BE, &H550C7DC3, &H72BE5D74, &H80DEB1FE, &H9BDC06A7, &HC19BF174, &HE49B69C1, &HEFBE4786, &HFC19DC6, &H240CA1CC, &H2DE92C6F, &H4A7484AA, &H5CB0A9DC, &H76F988DA, &H983E5152, &HA831C66D, &HB00327C8, &HBF597FC7, &HC6E00BF3, &HD5A79147, &H6CA6351, &H14292967, &H27B70A85, &H2E1B2138, &H4D2C6DFC, &H53380D13, &H650A7354, &H766A0ABB, &H81C2C92E, &H92722C85, &HA2BFE8A1, &HA81A664B, &HC24B8B70, &HC76C51A3, &HD192E819, &HD6990624, &HF40E3585, &H106AA070, &H19A4C116, &H1E376C08, &H2748774C, &H34B0BCB5, &H391C0CB3, &H4ED8AA4A, &H5B9CCA4F, &H682E6FF3, &H748F82EE, &H78A5636F, &H84C87814, &H8CC70208, &H90BEFFFA, &HA4506CEB, &HBEF9A3F7, &HC67178F2)
    Dim hash, m, w(63), a, b, c, d, e, f, g, h, i, j, t1, t2
    
    hash = Array(&H6A09E667, &HBB67AE85, &H3C6EF372, &HA54FF53A, &H510E527F, &H9B05688C, &H1F83D9AB, &H5BE0CD19)
    
    m = ConvertToWordArray(sMessage)
    
    For i = 0 To UBound(m) Step 16
        a = hash(0)
        b = hash(1)
        c = hash(2)
        d = hash(3)
        e = hash(4)
        f = hash(5)
        g = hash(6)
        h = hash(7)
        
        For j = 0 To 63
            If j < 16 Then
                w(j) = m(j + i)
            Else
                w(j) = AddUnsigned(AddUnsigned(AddUnsigned(Gamma1(w(j - 2)), w(j - 7)), Gamma0(w(j - 15))), w(j - 16))
            End If
                
            t1 = AddUnsigned(AddUnsigned(AddUnsigned(AddUnsigned(h, Sigma1(e)), Ch(e, f, g)), K(j)), w(j))
            t2 = AddUnsigned(Sigma0(a), Maj(a, b, c))
            
            h = g
            g = f
            f = e
            e = AddUnsigned(d, t1)
            d = c
            c = b
            b = a
            a = AddUnsigned(t1, t2)
        Next
        
        hash(0) = AddUnsigned(a, hash(0))
        hash(1) = AddUnsigned(b, hash(1))
        hash(2) = AddUnsigned(c, hash(2))
        hash(3) = AddUnsigned(d, hash(3))
        hash(4) = AddUnsigned(e, hash(4))
        hash(5) = AddUnsigned(f, hash(5))
        hash(6) = AddUnsigned(g, hash(6))
        hash(7) = AddUnsigned(h, hash(7))
    Next
    
    SHA256 = LCase(Right("00000000" & Hex(hash(0)), 8) & Right("00000000" & Hex(hash(1)), 8) & Right("00000000" & Hex(hash(2)), 8) & Right("00000000" & Hex(hash(3)), 8) & Right("00000000" & Hex(hash(4)), 8) & Right("00000000" & Hex(hash(5)), 8) & Right("00000000" & Hex(hash(6)), 8) & Right("00000000" & Hex(hash(7)), 8))
End Function



Attribute VB_Name = "Helpers"
Option Explicit

Public G_LogEnabled As Boolean
Public G_LogPrintChecksum As Boolean

Public Const vbTime As Long = 1000

Const NoError = 0       'The Function call was successful

#If VBA7 Then
Public Declare PtrSafe Sub Sleep Lib "kernel32" (ByVal _
  dwMilliseconds As Long)

Declare PtrSafe Function WNetGetUser Lib "mpr.dll" _
   Alias "WNetGetUserA" (ByVal lpName As String, _
   ByVal lpUserName As String, lpnLength As Long) As Long


Private Declare PtrSafe Function apiGetComputerName Lib "kernel32" Alias _
    "GetComputerNameA" (ByVal lpBuffer As String, nSize As Long) As Long
Public Declare PtrSafe Function FindExecutable Lib "shell32.dll" Alias _
    "FindExecutableA" (ByVal lpFile As String, ByVal lpDirectory As String, ByVal lpResult As String) As Long

Public Declare PtrSafe Function apiGetTempPath Lib "kernel32" Alias "GetTempPathA" (ByVal nBufferLength As Long, ByVal lpBuffer As String) As Long

Private Declare PtrSafe Function GetTempFileName Lib "kernel32" _
         Alias "GetTempFileNameA" (ByVal lpszPath As String, _
         ByVal lpPrefixString As String, ByVal wUnique As Long, _
         ByVal lpTempFileName As String) As Long

#Else
Public Declare Sub Sleep Lib "kernel32" (ByVal _
  dwMilliseconds As Long)

Declare Function WNetGetUser Lib "mpr.dll" _
   Alias "WNetGetUserA" (ByVal lpName As String, _
   ByVal lpUserName As String, lpnLength As Long) As Long


Private Declare Function apiGetComputerName Lib "kernel32" Alias _
    "GetComputerNameA" (ByVal lpBuffer As String, nSize As Long) As Long
Public Declare Function FindExecutable Lib "shell32.dll" Alias _
    "FindExecutableA" (ByVal lpFile As String, ByVal lpDirectory As String, ByVal lpResult As String) As Long

Public Declare Function apiGetTempPath Lib "kernel32" Alias "GetTempPathA" (ByVal nBufferLength As Long, ByVal lpBuffer As String) As Long

Private Declare Function GetTempFileName Lib "kernel32" _
         Alias "GetTempFileNameA" (ByVal lpszPath As String, _
         ByVal lpPrefixString As String, ByVal wUnique As Long, _
         ByVal lpTempFileName As String) As Long


#End If

Function pvReadFile(sFile) As String
    Const ForReading = 1
    Dim sPrefix
 
    With CreateObject("Scripting.FileSystemObject")
        sPrefix = .OpenTextFile(sFile, ForReading, False, False).Read(3)
    End With
    If Left(sPrefix, 3) <> Chr(&HEF) & Chr(&HBB) & Chr(&HBF) Then
        With CreateObject("Scripting.FileSystemObject")
            pvReadFile = .OpenTextFile(sFile, ForReading, False, Left(sPrefix, 2) = Chr(&HFF) & Chr(&HFE)).ReadAll()
        End With
    Else
        With CreateObject("ADODB.Stream")
            .Open
            If Left(sPrefix, 2) = Chr(&HFF) & Chr(&HFE) Then
                .Charset = "Unicode"
            ElseIf Left(sPrefix, 3) = Chr(&HEF) & Chr(&HBB) & Chr(&HBF) Then
                .Charset = "UTF-8"
            Else
                .Charset = "_autodetect"
            End If
            .LoadFromFile sFile
            pvReadFile = .ReadText
        End With
    End If
End Function


Public Sub ACCreateHeaderAndFooter(ws As Worksheet, Optional Filename As String = "")
    On Error Resume Next
    ' Datum der Generierung in die Fu|fffd|zeile eintragen
    With ws.PageSetup
        Dim usr As String
        usr = Environ("USERNAME")
        If Len(usr) Then
            '.LeftFooter = "Generiert am: " & Now() & " von " & usr
            .LeftFooter = FMT2("HELPERS_1", Now(), usr)
        Else
            '.LeftFooter = "Generiert am: " & Now()
            .LeftFooter = FMT1("HELPERS_2", Now())
        End If
        .CenterHeader = "&16" & ws.name
        .RightHeader = "&7 Access-Checker " & MainMenu.Vers & vbLf & MainMenu.Cop
        '.LeftHeader = "&7 " & trsShrt & IIf(Len(Filename) > 0, vbLf & "Datei: '" & Filename & "'", "")
        .LeftHeader = "&7 " & trsShrt & IIf(Len(Filename) > 0, vbLf & FMT1("HELPERS_3", Filename), "")
    End With

End Sub


Function SheetHasPassword(oXLWsheet)
    SheetHasPassword = True
    On Error GoTo password_notok
    ' Wir probieren das Ganze mit einem idiotischen Passwort
    oXLWsheet.Unprotect "12%%XXy<11!A"
    SheetHasPassword = False
password_notok:
End Function

Function WorkbookHasPassword(oxlwbook)
    WorkbookHasPassword = True
    On Error GoTo password_notok
    ' Wir probieren das Ganze mit einem idiotischen Passwort
    oxlwbook.Unprotect "12%%XXy<11!A"
    WorkbookHasPassword = False
password_notok:
End Function

Public Function StringAdd(stringlist, txt As String) As Boolean
    StringAdd = False
    Dim item
    For Each item In stringlist
        If item = txt Then Exit Function
    Next item
    StringAdd = True
    stringlist.Add txt
End Function

Function CheckVBAAccessAllowed() As Boolean
  CheckVBAAccessAllowed = True
  On Error GoTo noVBA
  If ThisWorkbook.VBProject.Protection = 1 Then ' vbext_pp_locked
  End If
  Exit Function
noVBA:
  CheckVBAAccessAllowed = False
End Function

Function FilenameDoesntExistAbove(Pfad As String, name As String) As Boolean
  Dim item
  Dim pos As Long
  FilenameDoesntExistAbove = True
  If Len(Pfad) <= 1 Then Exit Function
  pos = Len(Pfad)
  pos = pos - 1
  Do
    pos = InStrMyRev(Pfad, "\", pos)
    If pos < 0 Then Exit Do
    For Each item In xlsDateien
      If Left(Pfad, pos) & name = item Then
        FilenameDoesntExistAbove = False
        Exit Function
      End If
    Next item
    pos = pos - 1
  Loop While pos > 0
End Function

Function InStrMyRev(str As String, v As String, Optional pos As Long = 0) As Long
  Dim i As Long
  If Not IsMissing(pos) And pos > 0 Then
    i = pos
  Else
    i = Len(str)
  End If
  Do While i > 0
    If Mid(str, i, Len(v)) = v Then
      InStrMyRev = i
      Exit Function
    End If
    i = i - 1
  Loop
  InStrMyRev = 0
End Function


Sub AddStatus(txt As String, Optional col As Long = 196)
  LastProgText = ProgText
  If Len(ProgText) > 0 Then
    ProgText = ProgText & vbCrLf & txt
  Else
    ProgText = txt
  End If
  
  StatusForm.ProgText = Right(ProgText, 16000)
  StatusForm.Repaint
  StatusForm.ProgText.SelStart = Len(ProgText)
  
  If theTrackerFreigabe Then
    StoreUserCommunicateValue "TU", ProgText
  End If
  
  StatusFormUpdate
  
  SetLiveStatus
  
'    StatusForm.ProgText.CurLine = 10000
'  WriteTimeStamp
'  WriteToSheet cfgMappenname, Texte(GSprache, TXT_ANS_MASSENANALYSE), TheMassAnalysisY, 2, txt, col
'  WriteToSheet cfgMappenname, Texte(GSprache, TXT_ANS_MASSENANALYSE), TheMassAnalysisY, 3, CStr(CurrentStatus), col
End Sub
Sub UpdateStatus(txt As String)
  If Len(LastProgText) > 0 Then
    ProgText = LastProgText & vbCrLf & txt
  Else
    ProgText = txt
  End If
  
  StatusForm.ProgText = Right(ProgText, 16000)
  StatusForm.Repaint
  StatusForm.ProgText.SelStart = Len(ProgText)
  
  If theTrackerFreigabe Then
    StoreUserCommunicateValue "TU", ProgText
  End If
'    StatusForm.ProgText.CurLine = 10000
'  WriteTimeStamp
'  WriteToSheet cfgMappenname, Texte(GSprache, TXT_ANS_MASSENANALYSE), TheMassAnalysisY, 2, txt
'  WriteToSheet cfgMappenname, Texte(GSprache, TXT_ANS_MASSENANALYSE), TheMassAnalysisY, 3, CStr(CurrentStatus)
End Sub

Function MyOpenFile(ByVal fullpath As String, ByVal fn As Long)
    On Error GoTo nogo:
    
    Open fullpath For Append As fn
    MyOpenFile = True
    Exit Function
nogo:
    MyOpenFile = False

End Function

Public Function AddTextToFile(ByVal strData As String, _
     ByVal fullpath As String, _
       Optional ByVal ErrInfo As String = "") As Boolean

    Dim fn As Long
    fn = FreeFile
    Dim s As String
    
    Dim i As Long
    i = 0

    While i < 5
      If MyOpenFile(fullpath, fn) Then
        Print #fn, strData
        Close fn
        AddTextToFile = True
        Exit Function
      End If
      i = i + 1
      Sleep 10
    Wend

    AddTextToFile = False
    Exit Function

End Function

Sub ClearLog()
  On Error Resume Next
  Kill ThisWorkbook.path & "\ACC-Log-" & GetUserName & ".txt"
End Sub

Function GetRelativePath(ByVal stdpath As String, ByVal cfgpath As String) As String
  Dim s As String
  If cfgpath = "" Then s = stdpath
  
  If cfgpath = "USERTEMP" Then
    cfgpath = GetTempPath
    If Right(cfgpath, 1) = "\" Then
      cfgpath = Left(cfgpath, Len(cfgpath) - 1)
    End If
  End If
  
  If Left(cfgpath, 2) = "\\" Or Left(cfgpath, 2) = "//" Or Mid(cfgpath, 2, 1) = ":" Then
    s = cfgpath
  Else
    s = ThisWorkbook.path & "\" & cfgpath
  End If
  
  If Not PathExists(s) Then
    MkFullDir s
    If Not PathExists(s) Then
'      If AR_UseDB = False Then
'        MsgBox "ACHTUNG: Der Pfad '" & s & "' konnte nicht erzeugt werden. Das Programm wird voraussichtlich nicht korrekt funktionieren. Bitte gew|fffd|hrleisten Sie, dass der Pfad existiert!", vbCritical
'      Else
        'AddStatus "ACHTUNG: Der Pfad '" & s & "' konnte nicht erzeugt werden."
        AddStatus FMT1("HELPERS_4", s)
'      End If
    End If
  End If
  
  GetRelativePath = s
End Function

Function GetUserName() As String

   ' Buffer size for the return string.
   Const lpnLength As Integer = 255

   ' Get return buffer space.
   Dim status As Integer

   ' For getting user information.
   Dim lpName, lpUserName As String

   ' Assign the buffer size constant to lpUserName.
   lpUserName = Space$(lpnLength + 1)

   ' Get the log-on name of the person using product.
   status = WNetGetUser(lpName, lpUserName, lpnLength)

   ' See whether error occurred.
   If status = NoError Then
      ' This line removes the null character. Strings in C are null-
      ' terminated. Strings in Visual Basic are not null-terminated.
      ' The null character must be removed from the C strings to be used
      ' cleanly in Visual Basic.
      lpUserName = Left$(lpUserName, InStr(lpUserName, Chr(0)) - 1)
   Else

      ' An error occurred.
'         MsgBox "Unable to get the name."
      'lpUserName = "Unbekannt"
      lpUserName = FMT0("HELPERS_5")
   End If

   ' Display the name of the person logged on to the machine.
'      MsgBox "The person logged on this machine is: " & lpUserName

    GetUserName = lpUserName

End Function

Sub MkFullDir(ByVal p As String)
  On Error Resume Next
  Dim pos As Long
  pos = 4
  Do
    pos = InStr(pos, p, "\")
    If pos > 0 Then
      MkDir Left(p, pos - 1)
    Else
      MkDir p
      Exit Sub
    End If
    pos = pos + 1
  Loop While pos > 0
End Sub

Function GetRangeCount(ByRef rng) As Double
  On Error Resume Next
  
  GetRangeCount = CDbl(rng.count)
  If Err.Number <> 0 Then
    Err.Clear
    GetRangeCount = CDbl(rng.Countlarge)
  End If
  
End Function

Function ConvGermanDateKey(d As String) As String
    Dim sp() As String
    sp = Split(d, ".")
    If UBound(sp) - LBound(sp) + 1 = 3 Then
        ConvGermanDateKey = DateSerial(CInt(sp(2)), CInt(sp(1)), CInt(sp(0)))
    Else
        ConvGermanDateKey = d
    End If
End Function

Function ConvGermanDate(d As String) As Date
    Dim td As Date
    
    On Error GoTo errorEnd
    td = DateSerial(1900, 1, 1)
    
    If IsDate(d) Then
        td = CDate(d)
    Else
      Dim dots As Long
      Dim pos1 As Long
      Dim pos2 As Long
      Dim endPos As Long
      
      dots = 0
      
      pos1 = InStr(d, ".")
      If pos1 > 0 Then
          dots = dots + 1
          
          pos2 = InStr(pos1 + 1, d, ".")
          If pos2 > 0 Then
              dots = dots + 1
              endPos = InStr(pos2 + 1, d, " ")
              If endPos <= 0 Then endPos = Len(d) + 1
          End If
      End If
      
      If dots = 2 Then
          Dim day As String
          Dim month As String
          Dim year As String
          day = Mid(d, 1, pos1 - 1)
          month = Mid(d, pos1 + 1, pos2 - pos1 - 1)
          year = Mid(d, pos2 + 1, endPos - pos2 - 1)
          td = DateSerial(year, month, day) & IIf(CDate(d) <> DateSerial(year, month, day), " " & Hour(d) & ":" & Minute(d) & ":" & Second(d), "")
      End If
    End If
    
    If td < DateSerial(1900, 1, 1) Then
      td = DateSerial(1900, 1, 1) & " " & Hour(d) & ":" & Minute(d) & ":" & Second(d)
    End If
    
errorEnd:
    ConvGermanDate = td
End Function

Function WorksheetExists(wb As Workbook, wsname As String)
  On Error GoTo doesntExist
  WorksheetExists = False
  
  Dim s As String
  s = wb.Sheets(wsname).name
  WorksheetExists = True
  Exit Function
doesntExist:
End Function


Function IsFullyNumeric(v As String) As Boolean
  Dim l As Long
  l = Len(v)
  If l = 0 Then Exit Function
  Dim i As Long
  For i = 1 To l
    If (Mid(v, i, 1) < "0" Or Mid(v, i, 1) > "9") And Mid(v, i, 1) <> "." Then Exit For
  Next i
  If i = l Then IsFullyNumeric = True
End Function

Function IsTime(ts As String) As Boolean
  Dim ok As Boolean
  ok = True
  If Len(ts) <> 8 Then ok = False
  If ok Then If Mid(ts, 3, 1) <> ":" Then ok = False
  If ok Then If Mid(ts, 6, 1) <> ":" Then ok = False
  If ok Then
    If IsNumeric(Val(Mid(ts, 1, 2))) Then
      If Val(Mid(ts, 1, 2)) < 0 Or Val(Mid(ts, 1, 2)) > 23 Then ok = False
    Else
      ok = False
    End If
  End If
  If ok Then
    If IsNumeric(Val(Mid(ts, 4, 2))) Then
      If Val(Mid(ts, 4, 2)) < 0 Or Val(Mid(ts, 4, 2)) > 59 Then ok = False
    Else
      ok = False
    End If
  End If
  IsTime = ok
End Function


Function MyFileLen(ByVal fname As String) As Long
  On Error GoTo nogo:
  MyFileLen = 0
  If UCase(Left(fname, 5)) = "HTTP:" Or UCase(Left(fname, 6)) = "HTTPS:" Then
    Dim sz As Long
    Dim modDate As Date
    If URLExists(fname, sz, modDate) Then
      MyFileLen = sz
    End If
  Else
    MyFileLen = fileLen(fname)
  End If
  Exit Function
nogo:
End Function

Function MyFileDateTime(ByVal fname As String) As Date
  MyFileDateTime = 0
  On Error GoTo nogo
  If UCase(Left(fname, 5)) = "HTTP:" Or UCase(Left(fname, 6)) = "HTTPS:" Then
    Dim sz As Long
    Dim modDate As Date
    If URLExists(fname, sz, modDate) Then
      MyFileDateTime = modDate
    End If
  Else
    MyFileDateTime = FileDateTime(fname)
  End If
  Exit Function
nogo:
  If Len(fname) > 260 Then
     MyFileDateTime = MyFileDateTimeLongName(fname)
  Else
    DebugPrint tdebug, "MyFileDateTime failed for: '" & fname & "' - " & Err.Number & " - " & Err.Description
  End If
End Function

Function MyFileDateTimeLongName(fname As String) As Date
On Error GoTo nogo
    If Len(fname) > 260 Then
        fname = "\\?\UNC\" & Mid$(fname, 3)
    End If
    
    Dim fs
    Dim f
    Set fs = CreateObject("Scripting.FileSystemObject")
    Set f = fs.GetFile(fname)
    
    MyFileDateTimeLongName = f.DateLastModified
    Exit Function
nogo:
    DebugPrint tdebug, "MyFileDateTimeLongName failed for: '" & fname & "' - " & Err.Number & " - " & Err.Description
    MyFileDateTimeLongName = 0
End Function

Public Function ShortFileName(ByVal long_name As String) As String
    If UCase(Left(long_name, 5)) = "HTTP:" Or UCase(Left(long_name, 6)) = "HTTPS:" Then
      ShortFileName = long_name
      Exit Function
    End If
    
    'Returns the short filename associated w
    '     ith sLongFilename
    Dim lRet As Long
    Dim sShortFilename As String
    'First attempt using 1024 character buff
    '     er.
    sShortFilename = String$(1024, " ")
    lRet = GetShortPathName(long_name, sShortFilename, Len(sShortFilename))
    
    'If buffer is too small lRet contains bu
    '     ffer size needed.


    If lRet > Len(sShortFilename) Then
        'Increase buffer size...
        sShortFilename = String$(lRet + 1, " ")
        'and try again.
        lRet = GetShortPathName(long_name, sShortFilename, Len(sShortFilename))
    End If
    
    'lRet contains the number of characters
    '     returned.


    If lRet > 0 Then
        ShortFileName = Left$(sShortFilename, lRet)
    End If
    
    If Trim(ShortFileName) = "" Then
      ShortFileName = long_name
    End If
    
End Function

Function FileExists(ByVal Dateiname$) As Boolean
    'Die Funktion pr|fffd|ft, ob eine Datei vorhanden ist
On Error GoTo fehler:
  Dim res As Boolean
  If UCase(Left(Dateiname, 5)) = "HTTP:" Or UCase(Left(Dateiname, 6)) = "HTTPS:" Then
    Dim sz As Long
    Dim modDate As Date
    FileExists = URLExists(Dateiname, sz, modDate)
  Else
    res = Dir$(Dateiname) <> ""
    If res = False Then
      res = Dir$(GetDriveAndPathFromUNC(Dateiname)) <> ""
    End If
    FileExists = res
  End If
    Exit Function
fehler:
    FileExists = False
    If Len(Dateiname) > 260 Then
        FileExists = MyFileExistsLongName(Dateiname)
    End If
End Function

Function MyFileExistsLongName(ByVal fname As String) As Boolean
On Error GoTo nogo
    If Len(fname) > 260 Then
        fname = "\\?\UNC\" & Mid$(fname, 3)
    End If
    
    Dim fs
    Set fs = CreateObject("Scripting.FileSystemObject")
    MyFileExistsLongName = fs.FileExists(fname)
    Exit Function
nogo:
    MyFileExistsLongName = False
End Function

Function URLExists(url As String, ByRef sz As Long, ByRef modDate As Date) As Boolean
    Dim Request As Object
    Dim ff As Integer
    Dim rc As Variant
    On Error GoTo EndNow
    sz = 0
    modDate = 0
    URLExists = False
    Set Request = CreateObject("MSXML2.XMLHTTP")
    With Request
      .Open "HEAD", url, False
      Request.SetRequestHeader "Cache-Control", "no-store, no-cache"
      Request.SetRequestHeader "Pragma", "no-cache"
      .Send
      If .readyState = 4 Then
        URLExists = True
        sz = .getResponseHeader("Content-Length")
        Dim s As String
        s = Mid(Request.getResponseHeader("Last-Modified"), 6, 1000)
        s = Left(s, Len(s) - 4)
        modDate = CDate(s)
      Else
        .abort
      End If
    End With
    Set Request = Nothing
    Exit Function
EndNow:
    Debug.Print Err.Description
    Set Request = Nothing
End Function


Sub LogPrintECCSCanLog(ByVal id As Long, ByVal status As Long, ByVal str As String, Optional writeFileStatusInfoForScheduler As Boolean = False)
  If AR_StartedByApp = SWAPPID_IDVSuiteScheduler Then
    If status = 9 Then
      AddError str
    End If
    DebugPrint tToFile, ProgNameShort & MyACCVersion & " - " & str, 0, 0, id, True
'    If writeFileStatusInfoForScheduler Then
      SetFileStatusInfo str
'    End If
    If status > 0 Then
      SaveSetting appname:="Stromwerken", Section:="IDVSS", Key:="ACCScanResult" & status, setting:=GetSetting(appname:="Stromwerken", Section:="IDVSS", Key:="ACCScanResult" & status, Default:=0) + 1
    End If
  End If
End Sub

Function GetTempPath() As String
  Dim RetVal As Long
  Dim pathbuffer As String * 512
  
  Dim l As Long
  l = apiGetTempPath(512, pathbuffer)
  If l > 0 Then
    GetTempPath = Trim(Left(pathbuffer, l))
  End If
End Function


Private Function FOpen(fname As String, ByRef fn As Long) As Boolean
  On Error GoTo nogo
  Open fname For Binary Access Read As fn
  FOpen = True
  Exit Function
nogo:
        
End Function

Private Function FOpenWrite(fname As String, ByRef fn As Long) As Boolean
  On Error GoTo nogo
  Open fname For Binary Access Write As fn
  FOpenWrite = True
  Exit Function
nogo:
        
End Function

Private Function FClose(ByRef fn As Long) As Boolean
  On Error GoTo nogo
  Close fn
  FClose = True
  Exit Function
nogo:
        
End Function
Function SplitFile(ByVal Filename As String, ByVal splitSize As Long, ByRef splitFilenames() As String) As Boolean

    SplitFile = False

On Error GoTo nogo
    
    Dim fileLen As Long
    fileLen = MyFileLen(Filename)
    
    ' wenn wir kleiner sind als 1 Split, dann wird nicht gesplitted
    If fileLen <= splitSize Then
        Exit Function
    End If

    Dim steps As Long
    ' Integer Division, da muss man ein \ nehmen
    steps = (fileLen \ splitSize)
    Dim remainingSize As Long
    remainingSize = fileLen Mod splitSize
    ' wenn es genau ein Vielfaches der SplitSize ist, dann m|fffd|ssen wir einen Split weniger machen
    If remainingSize = 0 Then
        steps = steps - 1
    End If
        
    Dim fn As Long
    fn = FreeFile
    
    Dim einMB As Long
    einMB = CLng(1024) * CLng(1024)

    SplitFile = True
    
    ReDim Preserve splitFilenames(steps)

    Dim buffer(CLng(1024) * CLng(1024) - CLng(1)) As Byte
    Dim BufferRemaining() As Byte
    If FOpen(Filename, fn) Then
        Dim step
        For step = 0 To steps
            Dim fnOut As Long
            fnOut = FreeFile
            
            Dim fileNameOutput As String
            fileNameOutput = Filename & "_" & step
            If FOpenWrite(fileNameOutput, fnOut) Then
                
                splitFilenames(step) = fileNameOutput
                
                Dim internalSteps As Long
                internalSteps = splitSize / einMB
                
                Dim intStep
                For intStep = 0 To internalSteps - 1
                    Dim strData As String
                    
                    If fileLen <= einMB Then
                        ReDim BufferRemaining(fileLen - 1)
                        Get #fn, , BufferRemaining
                        Put #fnOut, , BufferRemaining
                        fileLen = 0
                        Exit For
                    Else
                        Get #fn, , buffer
                        Put #fnOut, , buffer
                    End If
                    fileLen = fileLen - einMB
                Next
                Close #fnOut
            Else
                ' nicht geklappt, alles wieder l|fffd|schen
                SplitFile = False
                ' auf jeden Fall aufh|fffd|ren
                step = steps + 1
                Exit For
            End If
        Next
        Close #fn
    End If

    Exit Function
nogo:
    SplitFile = False
End Function

Public Function CreateTempFile(sPrefix As String) As String
   Dim sTmpPath As String * 512
   Dim sTmpName As String * 576
   Dim nRet As Long

   nRet = apiGetTempPath(512, sTmpPath)
   If (nRet > 0 And nRet < 512) Then
      nRet = GetTempFileName(sTmpPath, sPrefix, 0, sTmpName)
      If nRet <> 0 Then
         CreateTempFile = Left$(sTmpName, _
            InStr(sTmpName, vbNullChar) - 1)
         MyKill CreateTempFile
      End If
   End If
End Function

Function GetFileName(ByVal fn As String) As String
    Dim File As String
    Dim path As String
    Dim ext As String

    fileSplit fn, path, File, ext
    GetFileName = File
End Function


Function GetFilePath(ByVal fn As String)
    Dim File As String
    Dim path As String
    Dim ext As String
    
    fileSplit fn, path, File, ext
    GetFilePath = Left(path, Len(path) - 1)
End Function

Function GetFileNameAndPath(ByVal fn As String)
    Dim File As String
    Dim path As String
    Dim ext As String
    
    fileSplit fn, path, File, ext
    GetFileNameAndPath = path & File
End Function

Function GetFileExtension(ByVal fn As String)
    Dim File As String
    Dim path As String
    Dim ext As String
    
    fileSplit fn, path, File, ext
    GetFileExtension = ext
End Function

Public Function MyGetTempFilename(ByVal temppath As String, ByVal sPrefix As String) As String
   Dim sTmpName As String * 576
   Dim nRet As Long

   nRet = GetTempFileName(temppath, "TMP", 0, sTmpName)
   If nRet <> 0 Then
     MyGetTempFilename = Left$(sTmpName, InStr(sTmpName, vbNullChar) - 1)
     MyKill MyGetTempFilename
     MyGetTempFilename = temppath & "\" & sPrefix & GetFileNameAndExtension(MyGetTempFilename)
   End If
End Function

Public Function CollectionObjectExists(ByRef c As Collection, name As String) As Boolean
  On Error GoTo notReadable
  Dim s
  Set s = c(name)
  Set s = Nothing
  CollectionObjectExists = True
  Exit Function
  
notReadable:
  CollectionObjectExists = False
End Function

' Wenn d zwischen t1 und t2 liegt true, ansonsten false
' t1 und t2 sind immer die Stunden eines Tages. Wenn t2 kleiner t1 ist, dann wird |fffd|ber Mitternacht gerechnet
Function TimeInScope(d As Date, t1 As Date, t2 As Date) As Boolean
  ' Erst mal die Tagesiformationen loswerden
  t1 = GetTime(t1)
  t2 = GetTime(t2)
  d = GetTime(d)

  TimeInScope = False

  ' Z.B. zwischen 08:00:00 und 09:00:00
  If t1 < t2 Then
      If t1 <= d And d <= t2 Then
          TimeInScope = True
      End If
  Else
      If d >= t1 Or d <= t2 Then
          TimeInScope = True
      End If
  End If
End Function

Function GetTime(d As Date) As Date
  On Error Resume Next
  GetTime = CDate("00:00:00")
  GetTime = TimeValue(d)
End Function

Public Function GetNextValue(ByVal sbsValue As String, ByRef startIndex As Long, Optional delim As String = ";") As String

    Dim l As Long
    l = Len(sbsValue)
    Dim startAnfuehrungsstriche As Long
    Dim anfuehrungsstriche As Long
    Dim laenge As Long
    
    Dim nextValue As String
    nextValue = ""
    
    If startIndex <= l Then
        laenge = 0
        If Mid(sbsValue, startIndex, 1) = Chr$(34) Then
            startAnfuehrungsstriche = 1
            anfuehrungsstriche = 1
            startIndex = startIndex + 1
        End If
        
        While startIndex + laenge <= l
            Dim c As String
            c = Mid(sbsValue, startIndex + laenge, 1)
            If c = Chr$(34) Then
                ' 3 Anf|fffd|hrungszeichen sind dann
                If Mid(sbsValue, startIndex + laenge, 2) = Chr$(34) & Chr$(34) Then
                    laenge = laenge + 2
                Else
                    anfuehrungsstriche = 1 - anfuehrungsstriche
                    laenge = laenge + 1
                End If
            ElseIf c = delim Then
                If anfuehrungsstriche = 0 Then
                    GoTo raus
                Else
                    laenge = laenge + 1
                End If
            Else
                laenge = laenge + 1
            End If
        Wend
raus:
        nextValue = Mid(sbsValue, startIndex, laenge - startAnfuehrungsstriche)
        ' nextValue = Replace(nextValue, Chr$(34) & Chr$(34), "'") ' Chr$(34))
        startIndex = startIndex + laenge + 1
    End If
    GetNextValue = nextValue

End Function

Public Function IsTestUser() As Boolean
  Dim curUser As String
  curUser = GetUserName
    If curUser = "dirk" Or _
        curUser = "dwinter" Or _
        curUser = "norman" Or _
        curUser = "nneubert" Or _
        curUser = "rolf" Or _
        curUser = "rlangenberg" Then
        
        IsTestUser = True
    End If
End Function

Function MyTimeValue24H(ByVal s As String) As String
  
  ' 2019/01/01 12:00:00 AM
  Debug.Print Format(s, "hh:mm:ss")
  MyTimeValue24H = Format(s, "hh:mm:ss")
    
End Function

Public Function GetUserNameUCASE() As String
    GetUserNameUCASE = UCase(GetUserName)
End Function

Function IsURL(ByVal Dateiname$) As Boolean
  If UCase(Left(Dateiname, 5)) = "HTTP:" Or UCase(Left(Dateiname, 6)) = "HTTPS:" Then
    IsURL = True
  End If
End Function

Public Function DecryptPasswort(ByVal s As String) As String
    DecryptPasswort = Crypt(s, "T0)7/hJy+\1TrcpI?", False)
End Function

Attribute VB_Name = "INetCheckVersion"
Option Explicit


Public G_InternetVersion As String
Public G_InternetAvailable As Boolean
Public G_InternetInternalVersion As Long
Public G_InternetLicenseVersion As Long
Public G_UpdateAvailable As Boolean
Public G_UpdateString As String
Public G_MyLicencseVersion As Long
Public G_Wartung As Boolean
Public G_WartungBis As Date

Public G_UpdateText As String
Public G_Lizenzen As Long
Public G_FullDemoBis As Date

Public G_Lizenznehmer As String
Public G_LizenznehmerAdresse As String


'Declares for direct ping
#If VBA7 And Win64 Then
Private Declare PtrSafe Function InternetOpen Lib "wininet.dll" Alias "InternetOpenA" (ByVal lpszAgent As String, ByVal dwAccessType As Long, ByVal lpszProxyName As String, ByVal lpszProxyBypass As String, ByVal dwFlags As Long) As Long
Private Declare PtrSafe Function InternetOpenUrl Lib "wininet.dll" Alias "InternetOpenUrlA" (ByVal hInet As LongPtr, ByVal lpszUrl As String, ByVal lpszHeaders As String, ByVal dwHeadersLength As Long, ByVal dwFlags As Long, ByVal dwContext As Long) As Long
Private Declare PtrSafe Function InternetCloseHandle Lib "wininet.dll" (ByVal hInet As LongPtr) As Long
Private Declare PtrSafe Function InternetReadFile Lib "wininet.dll" _
    (ByVal hFile As LongPtr, ByVal sBuffer As String, ByVal lNumBytesToRead As Long, _
    lNumberOfBytesRead As LongPtr) As Integer
Private Declare PtrSafe Function InternetGetLastResponseInfo Lib "wininet.dll" Alias "InternetGetLastResponseInfoA" _
    (lpdwError As Long, ByVal lpszBuffer As String, ByVal lpdwBufferLength As Long) As Integer
#Else
Private Declare Function InternetOpen Lib "wininet.dll" Alias "InternetOpenA" (ByVal lpszAgent As String, ByVal dwAccessType As Long, ByVal lpszProxyName As String, ByVal lpszProxyBypass As String, ByVal dwFlags As Long) As Long
Private Declare Function InternetOpenUrl Lib "wininet.dll" Alias "InternetOpenUrlA" (ByVal hInet As Long, ByVal lpszUrl As String, ByVal lpszHeaders As String, ByVal dwHeadersLength As Long, ByVal dwFlags As Long, ByVal dwContext As Long) As Long
Private Declare Function InternetCloseHandle Lib "wininet.dll" (ByVal hInet As Long) As Long
Private Declare Function InternetReadFile Lib "wininet.dll" _
    (ByVal hFile As Long, ByVal sBuffer As String, ByVal lNumBytesToRead As Long, _
    lNumberOfBytesRead As Long) As Integer
Private Declare Function InternetGetLastResponseInfo Lib "wininet.dll" Alias "InternetGetLastResponseInfoA" _
    (lpdwError As Long, ByVal lpszBuffer As String, ByVal lpdwBufferLength As Long) As Integer
#End If

Private Const INTERNET_OPEN_TYPE_PRECONFIG = 0
Private Const INTERNET_FLAG_RELOAD = &H80000000
Private Const INTERNET_FLAG_KEEP_CONNECTION = &H400000
Private Const INTERNET_FLAG_NO_CACHE_WRITE = &H4000000

Dim hInet As Long
Dim hUrl As Long
Dim flags As Long
Dim url As Variant

Function GetLine(ByRef txt As String) As String
  Dim pos As Long
  Dim res As String
  pos = InStr(txt, vbCr)
  If pos > 0 Then
    res = Left(txt, pos - 1)
  Else
    res = txt
  End If
  If pos > 0 Then
    txt = Mid(txt, 2 + pos)
  Else
    txt = ""
  End If
  
  GetLine = res

End Function


Public Function CheckINetConnection() As Boolean
  hInet = InternetOpen(" ", INTERNET_OPEN_TYPE_PRECONFIG, vbNullString, vbNullString, 0&)
  If hInet Then
    flags = INTERNET_FLAG_KEEP_CONNECTION Or INTERNET_FLAG_NO_CACHE_WRITE Or INTERNET_FLAG_RELOAD
    hUrl = InternetOpenUrl(hInet, "http://www.stromwerke.de", vbNullString, 0, flags, 0)
    If hUrl Then
        CheckINetConnection = True
        Call InternetCloseHandle(hUrl)
      Else
        CheckINetConnection = False
      End If
   End If
   Call InternetCloseHandle(hInet)
End Function

Public Sub CheckVersion(checkEveryDays As Long, sec As String, fname As String, fname2 As String, currentVersion As String, internalCurrentVersion As Long)

On Error GoTo exitfunc

  G_InternetVersion = "Nicht verbunden"
  G_InternetAvailable = False
  G_UpdateAvailable = False

  Dim d As Date
 
  SaveSetting _
     appname:="Stromwerken", _
     Section:=sec, _
     Key:="VersionDate", _
     setting:=Now
     
     
  Dim ret As String
  Dim ret2 As String
  
     
  If LoadInetFile(fname, ret) = True And LoadInetFile(fname2, G_UpdateText) = True Then
  
        G_InternetVersion = GetLine(ret)
        If Left(G_InternetVersion, 2) = "<!" Then
          G_InternetAvailable = False
          G_InternetVersion = "Nicht verf|fffd|gbar"
          Exit Sub
        Else
        
          G_InternetInternalVersion = CLng(GetLine(ret))
          G_UpdateString = GetLine(ret)
          G_InternetLicenseVersion = CLng(GetLine(ret))
          
          G_InternetAvailable = True
            
          If internalCurrentVersion < G_InternetInternalVersion Then
          
            G_UpdateAvailable = True
            
            d = GetSetting( _
               appname:="Stromwerken", _
               Section:=sec, _
               Key:="VersionDate", Default:=DateSerial(2000, 1, 1))
            
            If DateAdd("d", checkEveryDays, d) <= Now Then
              CheckInternetUpdateMenu
            End If
            
          End If
        End If
  End If
  Exit Sub

exitfunc:
  Exit Sub
  
End Sub

Function DoThat(t As String) As String

    Dim i As Long
    Dim s2 As String
    For i = 1 To Len(t)
        If Mid(t, i, 1) = "@" Then
            s2 = s2 + vbLf
        ElseIf Mid(t, i, 1) = "^" Then
            s2 = s2 + " "
        ElseIf Mid(t, i, 1) >= "0" And Mid(t, i, 1) <= "9" Then
          s2 = s2 + Chr(Asc("0") + Asc("9") - Asc(Mid(t, i, 1)))
        ElseIf Mid(t, i, 1) >= "a" And Mid(t, i, 1) <= "z" Then
          s2 = s2 + Chr(Asc("a") + Asc("z") - Asc(Mid(t, i, 1)))
        ElseIf Mid(t, i, 1) >= "A" And Mid(t, i, 1) <= "Z" Then
          s2 = s2 + Chr(Asc("A") + Asc("Z") - Asc(Mid(t, i, 1)))
        Else
            s2 = s2 + Mid(t, i, 1)
        End If
    Next i
    
    DoThat = s2
End Function



Function GetSWResItem(ByVal pos As Long, ff As Long) As String
  Dim res As String
  
  If FileExists(G_cfgKeypfad & "\swres.swk") Then
    Open G_cfgKeypfad & "\swres.swk" For Binary Access Read As #ff ' Len = 4
  ElseIf FileExists(ThisWorkbook.path & "\swres.swk") Then
    Open ThisWorkbook.path & "\swres.swk" For Binary Access Read As #ff ' Len = 4
  Else
    Exit Function
  End If
  
  Dim l As Long
  Get #ff, pos, l

  Dim charc As Long

  ' ENC2
  If l = 1 Then
    Get #ff, pos + 4, l
  
  
  '  Close ff
  '  Open AktVerz & "\swres.swk" For Binary Access Read As #ff ' Len = 1
    For charc = 1 To l
      Dim tchar As Byte
      Get #ff, pos + 7 + charc, tchar
      tchar = tchar Xor (1 + 2 + 4 + 16 + 64)
      res = res & Chr(tchar)
    Next charc
    Close ff
    Do
      pos = InStr(res, "\n")
      If pos <= 0 Then Exit Do
      res = Left(res, pos - 1) & vbCrLf & Mid(res, pos + 2)
    Loop
    GetSWResItem = res
  
  ' ENC3 - LZW
  ElseIf l = 2 Then
    Get #ff, pos + 4, l
  
  '  Close ff
  '  Open AktVerz & "\swres.swk" For Binary Access Read As #ff ' Len = 1
    Dim lval As Long
    Dim arr() As Long
    ReDim arr(l)
    
    For charc = 1 To l
      Get #ff, pos + 4 + charc * 4, lval
      arr(charc - 1) = lval
    Next charc
    Close ff
    
    Dim LZW As New LZW
    res = LZW.DecompressArray(l, arr)
    Set LZW = Nothing
    
    Do
      pos = InStr(res, "\n")
      If pos <= 0 Then Exit Do
      res = Left(res, pos - 1) & vbCrLf & Mid(res, pos + 2)
    Loop
    GetSWResItem = res
  End If
End Function

Sub GetData()
  On Error GoTo noData
  
  G_Lizenzen = -3
  G_ACCPro = False
  
  If FileExists(G_cfgKeypfad & "\swres.swk") Or FileExists(ThisWorkbook.path & "\swres.swk") Then
    Dim ff As Long
    ff = FreeFile
    Dim s As String
    
    s = GetSWResItem(1000, ff)
    If InStr(s, "ACC,") > 0 Or InStr(s, "ACCPRO,") > 0 Then
    
      If InStr(s, "ACCPRO,") > 0 Then
        G_ACCPro = True
      End If
    
      G_Lizenznehmer = GetSWResItem(2000, ff)
      G_LizenznehmerAdresse = GetSWResItem(2400, ff)
      G_MyLicencseVersion = Val(GetSWResItem(4200, ff))
      G_Lizenzen = Val(GetSWResItem(4300, ff))
      
      
'      s = GetSWResItem(3200, ff)
      s = ConvGermanDateKey(GetSWResItem(4400, ff))
      If Len(s) > 0 Then
        If IsDate(s) Then
          G_FullDemoBis = CDate(s)
        End If
      End If
      G_Wartung = IIf(UCase(GetSWResItem(4500, ff)) = "JA", True, False)
      
      If G_Wartung Then
        ' s = GetSWResItem(3400, ff)
        s = ConvGermanDateKey(GetSWResItem(4600, ff))
        If Len(s) > 0 Then
          If IsDate(s) Then
            G_WartungBis = CDate(s)
          End If
        End If
      End If
      
      FullVersion = True
      
      If G_Lizenzen = -1 Then
        'trs = "Full-Demo" & vbCrLf & vbCrLf & G_Lizenznehmer & vbCrLf & G_LizenznehmerAdresse & vbCrLf & vbCrLf & "Einsatz nur zu Testzwecken!"
        trs = FMT2("INETCHKV_1", G_Lizenznehmer, G_LizenznehmerAdresse)
        'trsShrt = "Full-Demo " & G_Lizenznehmer & " - Einsatz nur zu Testzwecken!"
        trsShrt = FMT1("INETCHKV_2", G_Lizenznehmer)
      ElseIf G_Lizenzen = 0 And Now < G_FullDemoBis Then
        'trs = "Full-Demo bis zum " & G_FullDemoBis & vbCrLf & vbCrLf & G_Lizenznehmer & vbCrLf & vbCrLf & G_LizenznehmerAdresse
        trs = FMT3("INETCHKV_3", G_FullDemoBis, G_Lizenznehmer, G_LizenznehmerAdresse)
        'trsShrt = "Full-Demo bis zum " & G_FullDemoBis & " - " & G_Lizenznehmer
        trsShrt = FMT2("INETCHKV_4", G_FullDemoBis, G_Lizenznehmer)
      ElseIf G_Lizenzen = 0 And Now >= G_FullDemoBis Then
        'trs = "Demoversion" & vbCrLf & vbCrLf & G_Lizenznehmer & vbCrLf & vbCrLf & G_LizenznehmerAdresse
        trs = FMT2("INETCHKV_5", G_Lizenznehmer, G_LizenznehmerAdresse)
        'trsShrt = "Demoversion " & G_Lizenznehmer
        trsShrt = FMT1("INETCHKV_6", G_Lizenznehmer)
      ElseIf G_Lizenzen = -2 Then
        'trs = "Gesamthauslizenz" & vbCrLf & vbCrLf & G_Lizenznehmer & vbCrLf & vbCrLf & G_LizenznehmerAdresse
        trs = FMT2("INETCHKV_7", G_Lizenznehmer, G_LizenznehmerAdresse)
        'trsShrt = "Gesamthauslizenz " & G_Lizenznehmer
        trsShrt = FMT1("INETCHKV_8", G_Lizenznehmer)
      ElseIf G_Lizenzen = 1 Then
        'trs = G_Lizenzen & " Lizenz" & vbCrLf & vbCrLf & G_Lizenznehmer & vbCrLf & vbCrLf & G_LizenznehmerAdresse
        trs = FMT3("INETCHKV_9", G_Lizenzen, G_Lizenznehmer, G_LizenznehmerAdresse)
        'trsShrt = G_Lizenzen & "Lizenz " & G_Lizenznehmer
        trsShrt = FMT2("INETCHKV_10", G_Lizenzen, G_Lizenznehmer)
      Else
        'trs = G_Lizenzen & " Lizenzen" & vbCrLf & vbCrLf & G_Lizenznehmer & vbCrLf & vbCrLf & G_LizenznehmerAdresse
        trs = FMT3("INETCHKV_11", G_Lizenzen, G_Lizenznehmer, G_LizenznehmerAdresse)
        'trsShrt = G_Lizenzen & "Lizenzen " & G_Lizenznehmer
        trsShrt = FMT2("INETCHKV_12", G_Lizenzen, G_Lizenznehmer)
      End If
      
      If G_Wartung Then
        'trs = trs & vbCrLf & vbCrLf & IIf(G_WartungBis <> 0, "Wartung bis: " & G_WartungBis & IIf(Now > G_WartungBis, " (ABGELAUFEN)", ""), "")
        trs = trs & vbCrLf & vbCrLf & IIf(G_WartungBis <> 0, FMT1("INETCHKV_13", G_WartungBis) & IIf(Now > G_WartungBis, FMT0("INETCHKV_14"), ""), "")
      End If
      
    End If
  Else
    ' GetDataOld
        trs = FMT2("INETCHKV_5", G_Lizenznehmer, G_LizenznehmerAdresse)
        'trsShrt = "Demoversion " & G_Lizenznehmer
        trsShrt = FMT1("INETCHKV_6", G_Lizenznehmer)
  End If
  
  
noData:
  Exit Sub
End Sub


Sub CheckInternetUpdateMenu()


  If G_MyLicencseVersion < G_InternetLicenseVersion And FullVersion = True Then
    'INetUpdate.Headline.Caption = "Im Internet liegt eine neue Version des Programms vor."
    INetUpdate.Headline.Caption = FMT0("INETCHKV_15")
    'INetUpdate.Kostenpflichtig.Caption = "Die neue Version ist kostenpflichtig. Bitte wenden Sie sich an info@stromwerken.de, um eine Update-Lizenz zu erwerben. Ohne neuen Lizenz-Key l|fffd|uft das Programm als DEMO!"
    INetUpdate.Kostenpflichtig.Caption = FMT0("INETCHKV_16")
  Else
    'INetUpdate.Headline.Caption = "Im Internet liegt eine neue Version des Programms vor."
    INetUpdate.Headline.Caption = FMT0("INETCHKV_15")
    INetUpdate.Kostenpflichtig.Caption = ""
  End If
  
  INetUpdate.UpdateText = G_UpdateText
  
  INetUpdate.Show
End Sub



Public Function LoadInetFile(fname As String, ByRef ret As String, Optional fsize As Long = 0) As Boolean
  Dim hInet As Long
  Dim hUrl As Long
  Dim flags As Long
  Dim url As Variant
  
  LoadInetFile = False
  
  hInet = InternetOpen(" ", INTERNET_OPEN_TYPE_PRECONFIG, vbNullString, vbNullString, 0&)
  If hInet Then
    flags = INTERNET_FLAG_KEEP_CONNECTION Or INTERNET_FLAG_NO_CACHE_WRITE Or INTERNET_FLAG_RELOAD
    hUrl = InternetOpenUrl(hInet, "http://www.stromwerken.de/" & fname, vbNullString, 0, flags, 0)
    If hUrl Then
        
        Dim sReadBuf As String * 1024
        Dim flagMoreData As Boolean
#If VBA7 And Win64 Then
        Dim bytesRead As LongLong
#Else
        Dim bytesRead As Long
#End If
        Dim wRet As Integer
        Dim lastErr As Long
        Dim s As String
        
        flagMoreData = True
        Do While flagMoreData
            sReadBuf = vbNullString
            wRet = InternetReadFile(hUrl, sReadBuf, Len(sReadBuf), bytesRead)
            If Err.LastDllError <> 0 Then
                lastErr = Err.LastDllError
                ret = "Error (wininet.dll," & lastErr & ")"
                GoTo exitfunc
            End If
            If wRet <> 1 Then
                ret = "Error"
                GoTo exitfunc
            End If
            s = s & Left$(sReadBuf, CLng(bytesRead))
            If Not CBool(bytesRead) Then flagMoreData = False
        Loop
        ret = s
        
        Call InternetCloseHandle(hUrl)
        Call InternetCloseHandle(hInet)
        LoadInetFile = True
        Exit Function
    Else
      Call InternetCloseHandle(hInet)
    End If
  End If
  Exit Function

exitfunc:
    If hUrl <> 0 Then InternetCloseHandle (hUrl)
    If hInet <> 0 Then InternetCloseHandle (hInet)
End Function






Attribute VB_Name = "INetUpdate"
Attribute VB_Base = "0{B20D8534-57A8-4930-950E-31544AC5AD3E}{46D9CAF6-77B1-4E50-9823-EDD024DD7902}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Sub cmdAbbrechen_Click()
  Me.Hide
End Sub

Private Sub cmdDownload_Click()
  Me.Hide
  On Error Resume Next
  Call Shell("explorer.exe " & G_UpdateString, 1)
  ThisWorkbook.Close False
End Sub

Private Sub UserForm_Initialize()
  gTranslation.TranslateForm Me
End Sub
Attribute VB_Name = "KillStuff"
Option Explicit


#If VBA7 Then
  Private Declare PtrSafe Function GetCurrentProcessId Lib "kernel32" () As Long
  
  Private Declare PtrSafe Function OpenProcess Lib "kernel32" _
    (ByVal dwDesiredAccess As Long, _
    ByVal bInheritHandle As Long, _
    ByVal dwProcessId As Long) As Long
  
  Private Declare PtrSafe Function TerminateProcess Lib "kernel32" ( _
      ByVal hProcess As Long, _
      ByVal uExitCode As Long _
      ) As Long
      
  Private Declare PtrSafe Function CloseHandle Lib "kernel32" ( _
      ByVal hObject As LongPtr _
      ) As Long
  
  Declare PtrSafe Function GetVersion Lib "kernel32" () As Long

  Private Declare PtrSafe Function GetCurrentProcess Lib "kernel32" () As Long
  Private Declare PtrSafe Function OpenProcessToken Lib "advapi32.dll" (ByVal ProcessHandle As LongPtr, ByVal DesiredAccess As Long, TokenHandle As LongPtr) As Long
  Private Declare PtrSafe Function LookupPrivilegeValue Lib "advapi32.dll" Alias "LookupPrivilegeValueA" (ByVal lpSystemName As String, ByVal lpName As String, lpLuid As LUID) As Long
  Private Declare PtrSafe Function AdjustTokenPrivileges Lib "advapi32.dll" (ByVal TokenHandle As LongPtr, ByVal DisableAllPrivileges As Long, NewState As TOKEN_PRIVILEGES, ByVal BufferLength As Long, PreviousState As Any, ReturnLength As Long) As Long

#Else
  Private Declare Function GetCurrentProcessId Lib "kernel32" () As Long
  
  Private Declare Function OpenProcess Lib "kernel32" _
    (ByVal dwDesiredAccess As Long, _
    ByVal bInheritHandle As Long, _
    ByVal dwProcessId As Long) As Long
  
  Private Declare Function TerminateProcess Lib "kernel32" ( _
      ByVal hProcess As Long, _
      ByVal uExitCode As Long _
      ) As Long
      
  Private Declare Function CloseHandle Lib "kernel32" ( _
      ByVal hObject As Long _
      ) As Long

  Private Declare Function GetVersion Lib "kernel32" () As Long
  Private Declare Function GetCurrentProcess Lib "kernel32" () As Long
  Private Declare Function OpenProcessToken Lib "advapi32" (ByVal ProcessHandle As Long, ByVal DesiredAccess As Long, TokenHandle As Long) As Long
  Private Declare Function LookupPrivilegeValue Lib "advapi32" Alias "LookupPrivilegeValueA" (ByVal lpSystemName As String, ByVal lpName As String, lpLuid As LUID) As Long
  Private Declare Function AdjustTokenPrivileges Lib "advapi32" (ByVal TokenHandle As Long, ByVal DisableAllPrivileges As Long, NewState As TOKEN_PRIVILEGES, ByVal BufferLength As Long, PreviousState As Any, ReturnLength As Any) As Long


#End If


Const MAX_PATH& = 260


Private Type LUID
  lowpart As Long
  highpart As Long
End Type

Private Type TOKEN_PRIVILEGES
  PrivilegeCount As Long
  LuidUDT As LUID
  Attributes As Long
End Type

Const TOKEN_ADJUST_PRIVILEGES = &H20
Const TOKEN_QUERY = &H8
Const SE_PRIVILEGE_ENABLED = &H2
Const PROCESS_ALL_ACCESS = &H1F0FFF


Type PROCESSENTRY32
  dwSize As Long
  cntUsage As Long
  th32ProcessID As Long
  th32DefaultHeapID As Long
  th32ModuleID As Long
  cntThreads As Long
  th32ParentProcessID As Long
  pcPriClassBase As Long
  dwFlags As Long
  szexeFile As String * MAX_PATH
End Type


Function TerminateExe(exename As String, ByVal usrname As String) As Boolean
    Dim Process As Object
    For Each Process In GetObject("winmgmts:").ExecQuery("Select Name from Win32_Process Where Name = '" & exename & "'")
        If usrname = "" Then
'            Process.Terminate
            ' Sicher ist sicher!
            KillProcess Process.Handle
            TerminateExe = True
        Else
          Dim strNameOfUser
          Process.GetOwner strNameOfUser
          If strNameOfUser = usrname Then
            KillProcess Process.Handle
'            Process.Terminate
          End If
        End If
    Next
    
    ' und den noch hinterher
'    Shell "C:\Windows\System32\TASKKILL /F /FI " & Chr(34) & "USERNAME eq " & GetUserName() & Chr(34) & " /IM " & exename & " /T", vbHide
    
End Function


'Terminate any application and return an exit code to Windows.
Function KillProcess(ByVal hProcessID As Long, Optional ByVal exitCode As Long) As Boolean
#If VBA7 Then
  Dim hToken As LongPtr
#Else
  Dim hToken As Long
#End If

  Dim hProcess As Long

  Dim tp As TOKEN_PRIVILEGES
  
  
  If GetVersion() >= 0 Then
    If OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES Or TOKEN_QUERY, hToken) = 0 Then
    GoTo CleanUp
    End If
    
    If LookupPrivilegeValue("", "SeDebugPrivilege", tp.LuidUDT) = 0 Then
    GoTo CleanUp
    End If
    
    tp.PrivilegeCount = 1
    tp.Attributes = SE_PRIVILEGE_ENABLED
    
    If AdjustTokenPrivileges(hToken, False, tp, 0, ByVal 0&, ByVal 0&) = 0 Then
    GoTo CleanUp
    End If
  End If
  
  hProcess = OpenProcess(PROCESS_ALL_ACCESS, 0, hProcessID)
  If hProcess Then
  
  KillProcess = (TerminateProcess(hProcess, exitCode) <> 0)
  ' close the process handle
  CloseHandle hProcess
  End If
  
  If GetVersion() >= 0 Then
  ' under NT restore original privileges
  tp.Attributes = 0
  AdjustTokenPrivileges hToken, False, tp, 0, ByVal 0&, ByVal 0&
  
CleanUp:
  If hToken Then CloseHandle hToken
  End If

End Function



Sub RegAddProgPID(ByVal progName As String, Optional ByVal pid As Long = -1)
  If pid = -1 Then pid = GetCurrentProcessId
  If Not RegHasProgPID(progName, pid) Then
    SaveSetting appname:="Stromwerken", Section:=progName, Key:="ProcessIDs", setting:= _
     GetSetting(appname:="Stromwerken", Section:=progName, Key:="ProcessIDs", Default:="") & "(" & pid & ")"
  End If
End Sub
Sub RegRemoveProgPID(ByVal progName As String, Optional ByVal pid As Long = -1)
  If pid = -1 Then pid = GetCurrentProcessId
  Dim s As String
  s = GetSetting(appname:="Stromwerken", Section:=progName, Key:="ProcessIDs", Default:="")
  s = Replace(s, "(" & pid & ")", "")
  SaveSetting appname:="Stromwerken", Section:=progName, Key:="ProcessIDs", setting:=s
End Sub
Function RegHasProgPID(ByVal progName As String, ByVal pid As Long) As Boolean
  RegHasProgPID = InStr(GetSetting(appname:="Stromwerken", Section:=progName, Key:="ProcessIDs", Default:=""), "(" & pid & ")") > 0
End Function

' Returns -1 is no PID left
Function RegRemoveNextProgPID(ByVal progName As String) As Long
  Dim s As String
  s = GetSetting(appname:="Stromwerken", Section:=progName, Key:="ProcessIDs", Default:="")
  If Left(s, 1) = "(" Then
    Dim v As Long
    Dim pos As Long
    pos = InStr(s, ")")
    If pos > 0 Then
      v = Mid(s, 2, pos - 2)
      RegRemoveProgPID progName, v
    Else
      v = -1
    End If
    RegRemoveNextProgPID = v
  Else
     RegRemoveNextProgPID = -1
  End If

End Function

Sub RegKillAllRunningProgPIDs(ByVal progName As String, Optional exceptForMe As Boolean = False)
  Dim v As Long
  Dim pid As Long
  Dim foundPid As Boolean
  If exceptForMe Then
    pid = GetCurrentProcessId
  Else
    pid = -1
  End If
  Do
    v = RegRemoveNextProgPID(progName)
    If v < 0 Then Exit Do
    If pid > 0 Then
      If v <> pid Then
        KillProcess v
        ' Und auch noch mal hiermit probieren!
'        Shell "C:\Windows\System32\TASKKILL.exe /PID " & v & " /F /T", vbHide
      Else
        foundPid = True
      End If
    Else
      KillProcess v
      ' Und auch noch mal hiermit probieren!
'      Shell "C:\Windows\System32\TASKKILL.exe /PID " & v & " /F /T", vbHide
    End If
  Loop
  If foundPid Then
    RegAddProgPID progName, foundPid
  End If
End Sub

Function TerminateExeByPID(ByVal pid As Long) As Boolean
    Dim Process As Object
    For Each Process In GetObject("winmgmts:").ExecQuery("Select ProcessID from Win32_Process Where ProcessID = " & pid)
      Process.Terminate
      TerminateExeByPID = True
    Next
End Function

Sub ResetScannerKeys(ByVal scanner As String)
    SaveSetting appname:="Stromwerken", Section:=scanner, Key:="LiveStatusTime", setting:=#1/1/1900#
    SaveSetting appname:="Stromwerken", Section:=scanner, Key:="LiveStatus", setting:=""
    SaveSetting appname:="Stromwerken", Section:=scanner, Key:="COMMAND", setting:=""
    SaveSetting appname:="Stromwerken", Section:=scanner, Key:="Restart", setting:=0
    SaveSetting appname:="Stromwerken", Section:=scanner, Key:="AbortAction", setting:=""
    SaveSetting appname:="Stromwerken", Section:="IDVSS", Key:=scanner & "ScanFinished", setting:="0"
    SaveSetting appname:="Stromwerken", Section:="IDVSS", Key:=scanner & "FileScanRunning", setting:="0"
End Sub

Sub DoTaskKillAccessChecker()

  ' Es kann nur einen geben!
  TerminateExe "werfault.exe", GetUserName
  TerminateExe "dwwin.exe", GetUserName
  TerminateExe "dw20.exe", GetUserName
  TerminateExe "ACCdaemon.exe", GetUserName
  TerminateExe "Excelcnv.exe", GetUserName
  TerminateExe "MSAccess.exe", GetUserName
  RegKillAllRunningProgPIDs "ACC", True
  ClearResilience
'  ResetScannerKeys "ECC"
End Sub




Attribute VB_Name = "LForItem"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public m_Prefix As String
Public m_Val As String
Public m_X As Long
Public m_Y As Long

Attribute VB_Name = "LZW"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

'Private Data Members
Private flgFirstTime As Boolean
Private arr() As String
Private m_CharacterBytesCount As Integer


'Properties
Public Property Get CharacterBytesCount() As Integer
    CharacterBytesCount = m_CharacterBytesCount
End Property

Public Property Let CharacterBytesCount(ByVal vNewValue As Integer)
    m_CharacterBytesCount = vNewValue
End Property

'Private Methods
Private Function Add(ByVal Entry As String) As Long

   If flgFirstTime Then
        flgFirstTime = False
    Else
        ReDim Preserve arr(UBound(arr) + 1)
    End If
    
    arr(UBound(arr)) = Entry
    'Arr(UBound(Arr)).Code = ubund(
    
    Add = UBound(arr)
    
End Function

Private Function IsExists(ByVal Entry As String) As Boolean
    Dim i As Long
    Dim flg As Boolean
    flg = False
    
    For i = LBound(arr) To UBound(arr)
        If arr(i) = Entry Then
            flg = True
            Exit For
        End If
    Next i
    
    IsExists = flg
    
End Function

Private Function IsIndexExists(ByVal index As Long) As Boolean
    
    Dim flg As Boolean
    flg = False
    
    If index <= UBound(arr) Then
        flg = True
    Else
        flg = False
    End If
    
    IsIndexExists = flg
    
End Function

Private Function GetValue(ByVal index As Long) As String
    If IsIndexExists(index) Then
        GetValue = arr(index)
    Else
        GetValue = ""
    End If
End Function

Private Function GetIndexOf(ByVal Entry As String) As Long
    
    Dim i As Long
    Dim ReturnCode As Long
    ReturnCode = -1
    
    For i = LBound(arr) To UBound(arr)
        If arr(i) = Entry Then
            ReturnCode = i
            Exit For
        End If
    Next i
    
    GetIndexOf = ReturnCode
    
End Function

Private Sub Class_Initialize()
    ReDim arr(0) As String
    flgFirstTime = True
    m_CharacterBytesCount = 2
End Sub

Private Function mrtLeft(ByVal InputString As String, ByVal Length As Long) As String
    If Len(InputString) >= Length Then
        mrtLeft = Left(InputString, Length)
    Else
        mrtLeft = InputString
    End If
End Function

Private Sub InitializeDictionary()
    Dim i As Long
    For i = 0 To (2 ^ (m_CharacterBytesCount * 8)) - 1
        Add (ChrW(i))
    Next
End Sub

Private Function Length() As Long
    Length = UBound(arr)
End Function

'Public methods
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Public Function Compress(ByVal UncompressedData As String, ByRef valam As Long, ByRef arr() As Long) As String

    Dim w As String
    Dim c As String
    Dim wc As String
    'Dim dic As New Dictionary
    Dim Output As String
    Dim code As Long
    
    Dim i As Long
    InitializeDictionary
    valam = 0
    
    ReDim arr(1024)
    Dim curarrsize As Long
    curarrsize = 1024
     
    w = ""
    For i = 1 To Len(UncompressedData)
        
        c = Mid(UncompressedData, i, 1)
        wc = w + c
        If IsExists(wc) Then
            w = wc
        Else
            code = Add(wc)
            code = GetIndexOf(w)
            Output = Output & IIf(Output = "", "", ",") & code
            arr(valam) = code
            valam = valam + 1
            If valam > curarrsize Then
              curarrsize = curarrsize + 1024
              ReDim Preserve arr(curarrsize)
            End If
            w = c
        End If
        
        '?
    
    Next i
    
    Output = Output & IIf(Output = "", "", ",") & GetIndexOf(w)
    arr(valam) = GetIndexOf(w)
    valam = valam + 1
    
    Compress = Output

End Function


Public Function DecompressArray(valam As Long, arr() As Long) As String
  Dim compresseddata As String
  Dim i As Long
  For i = 0 To valam - 1
    compresseddata = compresseddata & IIf(compresseddata = "", "", ",") & arr(i)
  Next i
  DecompressArray = Decompress(compresseddata)
End Function

Public Function Decompress(ByVal compresseddata As String) As String
    
    If compresseddata = "" Then Exit Function
    
    'Dim dic As New Dictionary
    
    InitializeDictionary

    Dim Output As String
    Dim Entry As String

    Dim K As String
    Dim w As String
    Dim i As Long
    
    Dim arrCompressedData() As String
    ListSplit arrCompressedData, compresseddata, "," '  arrCompressedData = Split(compresseddata, ",")
    
    K = arrCompressedData(0)
    Output = Output & GetValue(K)
    w = K
    
    For i = 1 To UBound(arrCompressedData)
    
        K = arrCompressedData(i)
        
        If IsIndexExists(K) Then
        
            Entry = GetValue(K)
            
        ElseIf IsIndexExists(K) = False And K = Length + 1 Then
            
            Entry = GetValue(w) + mrtLeft(GetValue(w), 1)
            
        Else
        
            'MsgBox "Bad compressed."
            Dim errMsg As String
            errMsg = "Bad compressed."
            MsgBox errMsg
            
        End If
        
        Output = Output + Entry
        
        Add (GetValue(w) + mrtLeft(Entry, 1))
        
        w = GetIndexOf(Entry)
        
    Next
    
    Decompress = Output
    
End Function


 Function ListSplit(ArrayReturn() As String, ByVal StringToSplit As String, _
 SplitAt As String) As Integer
   Dim intInstr As Integer
   Dim intCount As Integer
   Dim strTemp As String

   intCount = -1
   intInstr = InStr(StringToSplit, SplitAt)
   Do While intInstr > 0
     intCount = intCount + 1
     ReDim Preserve ArrayReturn(0 To intCount)
     ArrayReturn(intCount) = Left(StringToSplit, intInstr - 1)
     StringToSplit = Mid(StringToSplit, intInstr + 1)
     intInstr = InStr(StringToSplit, SplitAt)
   Loop
   If Len(StringToSplit) > 0 Then
     intCount = intCount + 1
     ReDim Preserve ArrayReturn(0 To intCount)
     ArrayReturn(intCount) = StringToSplit
   End If
   ListSplit = intCount
 End Function







Attribute VB_Name = "MainMenu"
Attribute VB_Base = "0{45060588-42AF-4EA1-A97C-9B99EA224DA1}{436D3710-1C92-4EFC-9D84-D929F624F5F9}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public Function AnyAccessVersionEnabled() As Boolean
  If V8.Enabled = False And V9.Enabled = False And V10.Enabled = False And V11.Enabled = False And V12.Enabled = False And _
      V14.Enabled = False And V15.Enabled = False And V16.Enabled = False Then
    AnyAccessVersionEnabled = False
  Else
    AnyAccessVersionEnabled = True
  End If
End Function

Private Sub AktualisierungenSuchen_Click()
  SaveSetting _
     appname:="Stromwerken", _
     Section:=ProgNameShort, _
     Key:="NoAutoUpdate", _
     setting:=0

  CheckVersion 1, "ACC", "ACCVersionN.txt", "ACCVersionN2.txt", MyVersion, MyInternalVersion

End Sub

Private Sub Analyse_Click()
  Dim tFname
  'tFname = Application.GetOpenFileName("Access-Dateien,*.md*;*.acc*", 1, "Datei ausw|fffd|hlen")
  tFname = Application.GetOpenFileName(FMT0("MAIN_7") & ",*.md*;*.acc*", 1, FMT0("MAIN_8"))
  If tFname = False Then Exit Sub
  theFilename = tFname
  
  Me.Hide
  StatusForm.Filename = ""
  StatusForm.ProgText = ""
  StatusForm.ProgressB.Width = 0
  ProgText = ""
  LastProgText = ""
  
  ' Application.OnTime Now + TimeValue("00:00:03"), "DoEinzelanalyse"
  StatusForm.Show vbModeless
  DoEinzelanalyse
End Sub

Private Sub Label16_Click()
  On Error Resume Next
  'Call Shell("explorer.exe http://www.stromwerken.de", 1)
  Call Shell("explorer.exe " & FMT0("INETLINK_1"), 1)
End Sub

Private Sub ProgrammBeenden_Click()
  Me.Hide
End Sub

Private Sub UserForm_Initialize()
  gTranslation.TranslateForm Me
End Sub
Attribute VB_Name = "PW"
Option Explicit

    Public Sub SortiereIndex(ByVal zeile As String, ByRef zIndex() As Long)
        Dim i As Long
        Dim l As Long

        For i = 1 To 8
            Dim kl As String
            kl = Mid(zeile, i, 1)
            Dim klindex As Integer
            klindex = 1
            For l = 2 To 8
                If kl = " " Or Mid(zeile, l, 1) < kl Then
                    If Mid(zeile, l, 1) <> " " Then
                        kl = Mid(zeile, l, 1)
                        klindex = l
                    End If
                End If
            Next
            zIndex(i) = klindex
            Mid(zeile, klindex, 1) = " "
        Next
    End Sub

    Public Function FirmenPasswort(ByVal firmenname As String) As String
        Dim zeichen(8) As String
        
        firmenname = Replace(firmenname, vbCr, "")
        firmenname = Replace(firmenname, vbLf, "")
        firmenname = Replace(firmenname, vbTab, "")

        zeichen(3) = "mnbvcxy&"
        zeichen(4) = "ASDFGHJK"
        zeichen(5) = "12345678"
        zeichen(6) = "QWER?\{}"
        zeichen(7) = "&[]*+-/|fffd|"
        zeichen(8) = "!(/&abcd"

        Dim zeile As String
        Dim spalte As String

        zeile = ""
        spalte = ""

        Dim i As Long
        Dim l As Long
        Dim m As Long
        If Len(firmenname) < 16 Then
            firmenname = firmenname & Left("Ein16stellenText", 16 - Len(firmenname))
        End If
        m = Len(firmenname) / 2
        For i = 0 To 3
            zeile = zeile & Mid(firmenname, m - i, 1)
            zeile = zeile & Mid(firmenname, m + i + 1, 1)
            spalte = spalte & Mid(firmenname, m - i - 4, 1)
            spalte = spalte & Mid(firmenname, m + i + 5, 1)
        Next i
        zeile = Replace(zeile, " ", "A")
        spalte = Replace(spalte, " ", "B")
        zeichen(1) = zeile
        zeichen(2) = spalte

        ' Sortieren und Indizes merken
        Dim zIndex(8) As Long
        Dim sindex(8) As Long
        SortiereIndex zeile, zIndex
        SortiereIndex spalte, sindex

        For i = 1 To 8
            Dim z As String
            z = ""
            For l = 1 To 8
                z = z & Mid(zeichen(i), zIndex(l), 1)
            Next
            zeichen(i) = z
        Next

        Dim result(8) As String

        For i = 1 To 8
            result(i) = "00000000"
        Next

        Dim s As Long
        For s = 1 To 8
            For l = 1 To 8
                Mid(result(l), s, 1) = Mid(zeichen(sindex(l)), s, 1)
            Next
        Next

        FirmenPasswort = result(1) & result(2) & result(3) & result(4) & result(7) & result(8)

    End Function

Public Function GetStandardPassword() As String
    GetStandardPassword = FirmenPasswort(G_LizenznehmerAdresse)  ' "NDR9)oio0(rrl5/mfk677&" & Left(G_Lizenznehmer & "        ", 8)
End Function

Public Function GetFileOpenPassword(ByRef rs As Object) As String
    GetFileOpenPassword = ""
On Error GoTo fehler
    If Not rs Is Nothing Then
        Dim berechtigungAn As Boolean
        berechtigungAn = False
        If rs.Fields("Dateiberechtigungen").value <> 0 Then
            berechtigungAn = True
        End If
        If berechtigungAn = True Then
            GetFileOpenPassword = GetStandardPassword()
        End If
    End If
    Exit Function
    
fehler:
    GetFileOpenPassword = ""
    
End Function


Public Function GetFilePassword(ByRef conn As Object, ByVal fname As String) As String
    GetFilePassword = ""
    
    Dim rs As Object
    Dim curId As Long
    Dim hash As String

    ' Wenn Sie bereits gespeichert wurde...
    Dim wasLocked As Boolean
    If GetTargetRSFromFilename(conn, GetUNCPath(fname), rs, curId) Then
        If Not rs Is Nothing Then
            If rs.Fields("Dateiberechtigungen").value <> 0 Then
                ' Berechtigung des aktuellen Users pr|fffd|fen
                
                Dim rsBerechtigung As Object
                Set rsBerechtigung = CreateObject("ADODB.Recordset")
                rsBerechtigung.Open "Select * from idvDateienBerechtigungen where idvDateiID = " & curId & " and typ = 1 and Berechtigungstraeger = '" & GetUserNameUCASE() & "'", conn, MYadOpenDynamic, MYadLockReadOnly
                If Not rsBerechtigung Is Nothing Then
                    If rsBerechtigung.EOF = False Then
                        GetFilePassword = GetStandardPassword()
                    End If
                    rsBerechtigung.Close
                End If
                Set rsBerechtigung = Nothing
            
                rs.Close
                Set rs = Nothing
                Exit Function
            Else
                Dim rsPW As Object
                Set rsPW = CreateObject("ADODB.Recordset")
                rsPW.Open "Select Passwort from idvDateienPW where idvDateiID = " & curId & " and PWTyp = 1", conn, MYadOpenDynamic, MYadLockReadOnly
                If Not rsPW Is Nothing Then
                    If rsPW.EOF = False Then
                        GetFilePassword = DecryptPasswort(rsPW.Fields("Passwort").value)
                    End If
                    rsPW.Close
                End If
                Set rsPW = Nothing
            End If
            rs.Close
            Set rs = Nothing
        End If
    End If
    Exit Function
    
fehler:
    GetFilePassword = ""
    
End Function




Attribute VB_Name = "RegStuff"
Option Explicit

'API Function and Constant Declarations
'--------------------------------------


Public Enum ERegistryValueTypes
'Predefined Value Types
    REG_NONE = (0)                         'No value type
    REG_SZ = (1)                           'Unicode nul terminated string
    REG_EXPAND_SZ = (2)                    'Unicode nul terminated string w/enviornment var
    REG_BINARY = (3)                       'Free form binary
    REG_DWORD = (4)                        '32-bit number
    REG_DWORD_LITTLE_ENDIAN = (4)          '32-bit number (same as REG_DWORD)
    REG_DWORD_BIG_ENDIAN = (5)             '32-bit number
    REG_LINK = (6)                         'Symbolic Link (unicode)
    REG_MULTI_SZ = (7)                     'Multiple Unicode strings
    REG_RESOURCE_LIST = (8)                'Resource list in the resource map
    REG_FULL_RESOURCE_DESCRIPTOR = (9)     'Resource list in the hardware description
    REG_RESOURCE_REQUIREMENTS_LIST = (10)
End Enum

'***Declare the keys that should exist.
'***Typically applications will put information under HKEY_CURRENT_USER
Global Const HKEY_CLASSES_ROOT = &H80000000
Global Const HKEY_CURRENT_USER = &H80000001
Global Const HKEY_LOCAL_MACHINE = &H80000002
Global Const HKEY_USERS = &H80000003

'***Errors
Global Const ERROR_NONE = 0
Global Const ERROR_BADDB = 1
Global Const ERROR_BADKEY = 2
Global Const ERROR_CANTOPEN = 3
Global Const ERROR_CANTREAD = 4
Global Const ERROR_CANTWRITE = 5
Global Const ERROR_OUTOFMEMORY = 6
Global Const ERROR_INVALID_PARAMETER = 7
Global Const ERROR_ACCESS_DENIED = 8
Global Const ERROR_INVALID_PARAMETERS = 87
Global Const ERROR_NO_MORE_ITEMS = 259

'***Gives all users full access to the key
Global Const KEY_ALL_ACCESS = &H3F

'***Creates a key that is persistent
Global Const REG_OPTION_NON_VOLATILE = 0

Global gstrAppVersion As String

'***Registry API declarations

#If VBA7 Then
  Declare PtrSafe Function RegCloseKey Lib "advapi32.dll" ( _
      ByVal hKey As Long _
  ) As Long
  
  Declare PtrSafe Function RegCreateKeyEx Lib "advapi32.dll" Alias "RegCreateKeyExA" ( _
      ByVal hKey As Long, _
      ByVal lpSubKey As String, _
      ByVal Reserved As Long, _
      ByVal lpClass As String, _
      ByVal dwOptions As Long, _
      ByVal samDesired As Long, _
      ByVal lpSecurityAttributes As Long, _
      phkResult As Long, _
      lpdwDisposition As Long _
  ) As Long
  
  Declare PtrSafe Function RegOpenKeyEx Lib "advapi32.dll" Alias "RegOpenKeyExA" ( _
      ByVal hKey As Long, _
      ByVal lpSubKey As String, _
      ByVal ulOptions As Long, _
      ByVal samDesired As Long, _
      phkResult As Long _
  ) As Long
  
  Declare PtrSafe Function RegQueryValueExString Lib "advapi32.dll" Alias "RegQueryValueExA" ( _
      ByVal hKey As Long, _
      ByVal lpValueName As String, _
      ByVal lpReserved As Long, _
      lpType As Long, _
      ByVal lpData As String, _
      lpcbData As Long _
  ) As Long
  
  Declare PtrSafe Function RegQueryValueExLong Lib "advapi32.dll" Alias _
  "RegQueryValueExA" (ByVal hKey As Long, ByVal lpValueName As _
  String, ByVal lpReserved As Long, lpType As Long, lpData As _
  Long, lpcbData As Long) As Long
  
  Declare PtrSafe Function RegQueryValueExNULL Lib "advapi32.dll" Alias _
  "RegQueryValueExA" (ByVal hKey As Long, ByVal lpValueName As _
  String, ByVal lpReserved As Long, lpType As Long, ByVal lpData _
  As Long, lpcbData As Long) As Long
  
  Declare PtrSafe Function RegSetValueExString Lib "advapi32.dll" Alias _
  "RegSetValueExA" (ByVal hKey As Long, ByVal lpValueName As String, _
  ByVal Reserved As Long, ByVal dwType As Long, ByVal lpValue As _
  String, ByVal cbData As Long) As Long
  
  Declare PtrSafe Function RegSetValueExLong Lib "advapi32.dll" Alias _
  "RegSetValueExA" (ByVal hKey As Long, ByVal lpValueName As String, _
  ByVal Reserved As Long, ByVal dwType As Long, lpValue As Long, _
  ByVal cbData As Long) As Long

  Private Declare PtrSafe Function SHDeleteKey Lib "shlwapi.dll" Alias "SHDeleteKeyA" (ByVal hKey As Long, ByVal pszSubKey As String) As Long
#Else
  Declare Function RegCloseKey Lib "advapi32.dll" ( _
      ByVal hKey As Long _
  ) As Long
  
  Declare Function RegCreateKeyEx Lib "advapi32.dll" Alias "RegCreateKeyExA" ( _
      ByVal hKey As Long, _
      ByVal lpSubKey As String, _
      ByVal Reserved As Long, _
      ByVal lpClass As String, _
      ByVal dwOptions As Long, _
      ByVal samDesired As Long, _
      ByVal lpSecurityAttributes As Long, _
      phkResult As Long, _
      lpdwDisposition As Long _
  ) As Long
  
  Declare Function RegOpenKeyEx Lib "advapi32.dll" Alias "RegOpenKeyExA" ( _
      ByVal hKey As Long, _
      ByVal lpSubKey As String, _
      ByVal ulOptions As Long, _
      ByVal samDesired As Long, _
      phkResult As Long _
  ) As Long
  
  Declare Function RegQueryValueExString Lib "advapi32.dll" Alias "RegQueryValueExA" ( _
      ByVal hKey As Long, _
      ByVal lpValueName As String, _
      ByVal lpReserved As Long, _
      lpType As Long, _
      ByVal lpData As String, _
      lpcbData As Long _
  ) As Long
  
  Declare Function RegQueryValueExLong Lib "advapi32.dll" Alias _
  "RegQueryValueExA" (ByVal hKey As Long, ByVal lpValueName As _
  String, ByVal lpReserved As Long, lpType As Long, lpData As _
  Long, lpcbData As Long) As Long
  
  Declare Function RegQueryValueExNULL Lib "advapi32.dll" Alias _
  "RegQueryValueExA" (ByVal hKey As Long, ByVal lpValueName As _
  String, ByVal lpReserved As Long, lpType As Long, ByVal lpData _
  As Long, lpcbData As Long) As Long
  
  Declare Function RegSetValueExString Lib "advapi32.dll" Alias _
  "RegSetValueExA" (ByVal hKey As Long, ByVal lpValueName As String, _
  ByVal Reserved As Long, ByVal dwType As Long, ByVal lpValue As _
  String, ByVal cbData As Long) As Long
  
  Declare Function RegSetValueExLong Lib "advapi32.dll" Alias _
  "RegSetValueExA" (ByVal hKey As Long, ByVal lpValueName As String, _
  ByVal Reserved As Long, ByVal dwType As Long, lpValue As Long, _
  ByVal cbData As Long) As Long

  Private Declare Function SHDeleteKey Lib "shlwapi.dll" Alias "SHDeleteKeyA" (ByVal hKey As Long, ByVal pszSubKey As String) As Long
#End If


Public Function SetValueEx( _
    ByVal hKey As Long, _
    sValueName As String, _
    lType As Long, _
    vValue As Variant _
) As Long

'*** Called By: SetKeyValue
'*** Description: Wrapper function around the registry API calls
'*** RegSetValueExString/Long. Determines if the value
'*** is a string or a long and calls the appropriate API.
'*** Return Value: Returns the API call's return value, which is its
'*** status (successful, error).

Dim lValue As Long
Dim sValue As String

    Select Case lType
        '***String
        Case REG_SZ
            sValue = vValue
            SetValueEx = RegSetValueExString(hKey, sValueName, 0&, lType, sValue, Len(sValue))
        '***32-bit number
        Case REG_DWORD
            lValue = vValue
            SetValueEx = RegSetValueExLong(hKey, sValueName, 0&, lType, lValue, 4)
    End Select
    
End Function

Private Function QueryValueEx( _
    ByVal lhKey As Long, _
    ByVal szValueName As String, _
    vValue As Variant _
) As Long

'*** Called By: QueryValue
'*** Description: Wrapper function around the registry API calls to
'*** RegQueryValueExLong and RegQueryValueExString.
'*** Determines size and type of data to be read.
'*** Determines if the value is a string or a long
'*** and calls the appropriate API.
'*** Return Value: Returns the API call's return value, which is its
'*** status (successful, error). The parameter vValue
'*** contains the value queried.

Dim cch As Long
Dim lrc As Long
Dim lType As Long
Dim lValue As Long
Dim sValue As String

On Error GoTo QueryValueExError

    ' Determine the size and type of data to be read
    lrc = RegQueryValueExNULL(lhKey, szValueName, 0&, lType, 0&, cch)
    
    If lrc <> ERROR_NONE Then Error 5
    
    Select Case lType
        ' For strings
        Case REG_SZ:
            sValue = String(cch, 0)
            lrc = RegQueryValueExString(lhKey, szValueName, 0&, lType, sValue, cch)
            If lrc = ERROR_NONE Then
                If Mid(sValue, cch, 1) = Chr(0) Then
                vValue = Left$(sValue, cch - 1) ' get rid of trailing AsciiZ
            Else
                vValue = Left$(sValue, cch)
            End If
            Else
                vValue = Empty
            End If
            ' For DWORDS
        Case REG_DWORD:
            lrc = RegQueryValueExLong(lhKey, szValueName, 0&, lType, lValue, cch)
            If lrc = ERROR_NONE Then vValue = lValue
        Case Else
            'all other data types not supported
            lrc = -1
    End Select

QueryValueExExit:
QueryValueEx = lrc

Exit Function

QueryValueExError:
    Resume QueryValueExExit ' Hmmmm
End Function

Public Sub CreateNewKey(sNewKeyName As String, lPredefinedKey As Long)
'***With this procedure a call of
'*** CreateNewKey "TestKey", HKEY_CURRENT_USER
'***will create a key called TestKey immediately under HKEY_CURRENT_USER.
'***Calling CreateNewKey like this
'*** CreateNewKey "TestKey\SubKey1\SubKey2", HKEY_CURRENT_USER
'***will create a three-nested keys beginning with TestKey immediately under
'***HKEY_CURRENT_USER, Subkey1 subordinate to TestKey, and SubKey3 under
'***SubKey2.

'*** Called by: your own code to create keys
'*** Description: Wrapper around the RegCreateKeyEx API call.

Dim hNewKey As Long 'handle to the new key
Dim lRetVal As Long 'result of the RegCreateKeyEx function

    lRetVal = RegCreateKeyEx( _
        lPredefinedKey, _
        sNewKeyName, _
        0&, _
        vbNullString, _
        REG_OPTION_NON_VOLATILE, _
        KEY_ALL_ACCESS, _
        0&, _
        hNewKey, _
        lRetVal _
    )
    
    RegCloseKey hNewKey

End Sub

Public Sub SetKeyValue( _
    ByVal lpParentKey As Long, _
    sKeyName As String, _
    sValueName As String, _
    vValueSetting As Variant, _
    lValueType As Long _
)

'*** Called By: Your code when you want to set a KeyValue
'*** Description: Opens the key you want to set, calls the wrapper
'*** function SetValueEx, and closes key.
'*** ADD ERROR HANDLING!!

Dim lRetVal As Long 'result of the SetValueEx function
Dim hKey As Long 'handle of open key

    'open the specified key
    lRetVal = RegOpenKeyEx(lpParentKey, sKeyName, 0, KEY_ALL_ACCESS, hKey)
    ' write the value
    lRetVal = SetValueEx(hKey, sValueName, lValueType, vValueSetting)
    ' close the key
    RegCloseKey (hKey)
    
End Sub
Public Function QueryValue( _
    ByVal lpParentKey As Long, _
    sKeyName As String, _
    sValueName As String _
) As Variant

'*** Called By: Your code when you want to set a read a KeyValue
'*** Description: Opens the key you want to set, calls the wrapper
'*** function QueryValueEx, closes key.
'*** Return Value: The value you are querying
'*** ADD ERROR HANDLING!!

Dim lRetVal As Long 'result of the API functions
Dim hKey As Long 'handle of opened key
Dim vValue As Variant 'setting of queried value

    ' open the key
    lRetVal = RegOpenKeyEx(lpParentKey, sKeyName, 0, KEY_ALL_ACCESS, hKey)
    ' get the value
    lRetVal = QueryValueEx(hKey, sValueName, vValue)
    ' close the key
    RegCloseKey (hKey)
    
    QueryValue = vValue
    
End Function

Public Sub TestRegModule()

'
' This procedure demonstrates the use of this module
' All code below here is demo code
'
    CreateKeyDriver
    Debug.Print "Created key Cosmic Example and TestVals"
    
    SetStringValueDriver
    Debug.Print "Created the TestStringVal"
    
    SetNumberValueDriver
    Debug.Print "Created the TestNumVal"
    
    ReadValueDriver

End

End Sub

Sub CreateKeyDriver()

'
' demo code
'

'*** Calls the CreateNewKey procedure
'*** Description: Creates Cosmic Example key and TestVals subkey under
'*** HKEY_CURRENT_USER\Software\VB and VBA Program Settings
'*** If Software and/or VB and VBA Program Settings do not
'*** exist, they are created.
'*** Usage: Use this as an example of how you would use the CreateNewKey
'*** procedure.

Dim sNewKey As String
Dim lPredefinedKeyValue As Long

    sNewKey = "Software\VB and VBA Program Settings\Cosmic Example\TestVals"
    lPredefinedKeyValue = HKEY_CURRENT_USER
    
    CreateNewKey sNewKey, lPredefinedKeyValue
    
End Sub

Sub SetStringValueDriver()

'
' demo code
'

'*** Calls the SetKeyValue procedure
'*** Description: Sets the value TestStringVal under the
'*** Cosmic Example\TestVals key and sets it to
'*** VB App Created. If it doesn't exist, it creates it.
'*** Usage: Use this as an example of how you would use the SetKeyValue
'*** procedure.

Dim sKey As String '***Key under which to create the value
Dim sValue As String '***Value name to set
Dim vSetting As Variant '***What to set the Value to
Dim sType As Long '***Value type -- string or number

    sKey = "Software\VB and VBA Program Settings\Cosmic Example\TestVals"
    sValue = "TestStringVal"
    vSetting = "VB App Created"
    sType = REG_SZ

    SetKeyValue HKEY_CURRENT_USER, sKey, sValue, vSetting, sType

End Sub
Sub SetNumberValueDriver()

'
' demo code
'

'*** Calls the SetKeyValue procedure
'*** Description: Sets the value TestNumVal under the
'*** Cosmic Example\TestVals key and sets it to 5.
'*** If it doesn't exist, it creates it.
'*** Usage: Use this as an example of how you would use the SetKeyValue
'*** procedure.

Dim sKey As String '***Key under which to create the value
Dim sValue As String '***Value name to set
Dim vSetting As Variant '***Wht to set the Value to
Dim sType As Long '***Value type -- string or number

    sKey = "Software\VB and VBA Program Settings\Cosmic Example\TestVals"
    sValue = "TestNumVal"
    vSetting = 5
    sType = REG_DWORD
    
    SetKeyValue HKEY_CURRENT_USER, sKey, sValue, vSetting, sType

End Sub

Sub ReadValueDriver()

'
' demo code
'

'*** Calls the QueryValue function
'*** Description: Reads the value TestNumVal and TestStringVal under
'*** the Cosmic Example\TestVals key.
'*** Usage: Use this as an example of how you would use the QueryValue
'*** procedure.

Dim sKey As String '***Key under which to create the value
Dim sValue As String '***Value name to set
Dim vSetting As Variant

    sKey = "Software\VB and VBA Program Settings\Cosmic Example\TestVals"
    sValue = "TestStringVal"
    
    '***Read the String value
    vSetting = QueryValue(HKEY_CURRENT_USER, sKey, sValue)
    Debug.Print "TestStringVal is " & vSetting
    
    sValue = "TestNumVal"
    '***Read the number value
    vSetting = QueryValue(HKEY_CURRENT_USER, sKey, sValue)
    Debug.Print "TestNumVal is " & vSetting

End Sub

Sub TestKey()
  
  CreateNewKey "Software\Microsoft\Office\12.0\Excel\Options", HKEY_CURRENT_USER
  SetKeyValue HKEY_CURRENT_USER, "Software\Microsoft\Office\12.0\Excel\Options", "NoShowCnvMsg", 1, REG_DWORD
  Debug.Print "Test:" & QueryValue(HKEY_CURRENT_USER, "Software\Microsoft\Office\12.0\Excel\Options", "NoShowCnvMsg")
End Sub

Function RegBinaryToLong(arrValue, pos)
  Dim l As Long
  
  l = arrValue(pos)
  l = l + arrValue(pos + 1) * 256
  l = l + arrValue(pos + 2) * 256 * 256
  l = l + arrValue(pos + 3) * 256 * 256 * 256
  RegBinaryToLong = l
End Function

Function RegBinaryToStringPos(arrValue, pos, l)
  Dim strInfo As String
  strInfo = ""
  Dim i As Long
  For i = pos To pos + l - 1
   If arrValue(i) <> 0 Then strInfo = strInfo & Chr(arrValue(i))
  Next
 RegBinaryToStringPos = strInfo
End Function

Sub DeleteResilience(vernr, officeapp)
    Dim hDefKey
    Dim strSubKeyPath As String
    Dim oReg As Object
    Dim i As Long
    Dim arrValueNames ' As Object
    Dim arrTypes ' As Object
    Dim arrBytes ' As Object
    Dim strValueName ' As String
    Dim l As Long
    Dim t As String
    Dim l2 As Long
    Dim t2 As String
    
    Dim sec As String
    Dim root As String
    Dim Key As String
    Dim areaKey As Long
    
    
    hDefKey = HKEY_CURRENT_USER
    strSubKeyPath = "Software\Microsoft\Office\" & vernr & ".0\" & officeapp & "\Resiliency\DisabledItems"
    Set oReg = GetObject("winmgmts:{impersonationLevel=impersonate}!\\.\root\default:StdRegProv")
    oReg.EnumValues hDefKey, strSubKeyPath, arrValueNames, arrTypes
  
    If Not IsNull(arrValueNames) Then
        For i = LBound(arrValueNames) To UBound(arrValueNames)
      
          strValueName = arrValueNames(i)
      
          Select Case arrTypes(i)
            Case REG_BINARY
              oReg.GetBinaryValue hDefKey, strSubKeyPath, strValueName, arrBytes
              l = RegBinaryToLong(arrBytes, 4)
              t = UCase(RegBinaryToStringPos(arrBytes, 12, l))
              l2 = RegBinaryToLong(arrBytes, 8)
              t2 = UCase(RegBinaryToStringPos(arrBytes, 12 + l, l2))
              
              If InStr(t, "EXCELTRACKER") > 0 Or InStr(t2, "EXCELTRACKER") > 0 Or InStr(t, "ACCESSTRACKER") > 0 Or InStr(t2, "ACCESSTRACKER") > 0 Or _
     InStr(t, "EXCEL-SHEET-CHECKER") > 0 Or InStr(t2, "EXCEL-SHEET-CHECKER") > 0 Or InStr(t, "ACCESS-CHECKER") > 0 Or InStr(t2, "ACCESS-CHECKER") > 0 Or _
     InStr(t, "EXCEL-FILE-COMPARE") > 0 Or InStr(t2, "EXCEL-FILE-COMPARE") > 0 Or InStr(t, "EXCEL-SHEET-QA") > 0 Or InStr(t2, "EXCEL-SHEET-QA") > 0 Or _
     InStr(t, "EXCELPROTECT") > 0 Or InStr(t2, "EXCELPROTECT") > 0 Then
                oReg.DeleteValue hDefKey, strSubKeyPath, strValueName
              End If
          End Select
        Next
    End If

#If PROJECT_IDVSCHEDULER = 1 Then
    DeleteKeyAndSubkeys HKEY_CURRENT_USER, "Software\Microsoft\Office\" & vernr & ".0\" & officeapp & "\Resiliency\DocumentRecovery"
#End If

End Sub


' =====================================================================
' Clear Resilience
' =====================================================================
Sub ClearResilience()
On Error Resume Next
Dim i As Long
For i = 10 To 18
   DeleteResilience i, "Excel"
   DeleteResilience i, "Access"
Next

End Sub


Private Sub DeleteKeyAndSubkeys(ByVal root As Long, ByVal Key As String)
    Const ERROR_SUCCESS = 0&
    Const KEY_ALL_ACCESS = &H3F
    Dim strKey As String
    Dim lngPos As Long
    Dim lngHandle As Long

    lngPos = InStrRev(Key, "\")
    If lngPos = 0 Then
        strKey = Key
        Key = ""
    Else
        strKey = Mid$(Key, lngPos + 1)
        Key = Left$(Key, lngPos - 1)
    End If
    If RegOpenKeyEx(root, Key, 0&, KEY_ALL_ACCESS, lngHandle) = ERROR_SUCCESS Then
        SHDeleteKey lngHandle, strKey
        RegCloseKey lngHandle
    End If

End Sub





Attribute VB_Name = "RiskRange"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public m_Comparison As Long
Public m_Value As Long
Public m_Risk As Double


Attribute VB_Name = "RiskTab"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public m_TabName As String
Public m_Vals As Collection

Public m_Weight As Double
Public m_Low As Double
Public m_LowColour As Long
Public m_LowMulti As Double
Public m_Med As Double
Public m_MedColour As Long
Public m_MedMulti As Double
Public m_HighColour As Long
Public m_HighMulti As Double

Private Sub Class_Initialize()
  Set m_Vals = New Collection
End Sub

Public Function Init(wb As Workbook, y As Long, regeln As String, risiken As String)
  Init = False
  
  m_TabName = wb.Worksheets(risiken).Cells(y, 1)
  
  If Not WorksheetExists(wb, regeln) Then
    'MsgBox "Es existiert keine Tabelle mit dem Namen 'Regeln' in der Datei '" & ThisWorkbook.path & "\Access-Checker Risk.xls' fehlt. F|fffd|r den Bereich '" & m_TabName & "' kann keine Risikoanalyse vorgenommen werden!", vbCritical, "Access-Checker"
    MsgBox FMT2("RISKTAB_1", ThisWorkbook.path, m_TabName), vbCritical, "Access-Checker"
    Exit Function
  End If
  
  Dim y2 As Long
  y2 = 2
  Dim rv As RiskVal
  Do While Not IsEmpty(wb.Sheets(regeln).Cells(y2, 1)) Or Not IsEmpty(wb.Sheets(regeln).Cells(y2 + 1, 1)) Or Not IsEmpty(wb.Sheets(regeln).Cells(y2 + 2, 1))
    If Not IsEmpty(wb.Sheets(regeln).Cells(y2, 1)) Then
      If wb.Sheets(regeln).Cells(y2, 1) = m_TabName Then
        Set rv = New RiskVal
        If Not rv.Init(wb.Sheets(regeln), y2) Then
          Exit Function
        End If
        m_Vals.Add rv
      End If
    End If
    y2 = y2 + 1
  Loop
  
  With wb.Worksheets(risiken)
    m_Weight = .Cells(y, 2)
    m_Low = .Cells(y, 3)
    m_LowColour = .Cells(y, 4).Interior.Color
    m_LowMulti = .Cells(y, 5)
    m_Med = .Cells(y, 6)
    m_MedColour = .Cells(y, 7).Interior.Color
    m_MedMulti = .Cells(y, 8)
    m_HighColour = .Cells(y, 9).Interior.Color
    m_HighMulti = .Cells(y, 10)
  End With
  
  ' Und dann noch die Einzelwerte besorgen
  
  
  
  Init = True
End Function


Public Function InitDB(conn, riskrs)
  InitDB = False
  
  m_TabName = riskrs.Fields("Risiko").value
  
  Dim rs
  Set rs = CreateObject("ADODB.recordset")
  rs.Open "SELECT * FROM ACCRegeln WHERE ACCRisikoID = " & riskrs.Fields("ACCRisikoID").value, conn, 2, 1
  If rs.EOF Then
    rs.Close
    Set rs = Nothing
    'MsgBox "Es sind keine Regeln f|fffd|r das Risiko '" & riskrs.Fields("ACCRisikoID").value & "' in der Datenbank des IDV-Trackers enthalten. Es kann keine Gesamtrisikoanalyse vorgenommen werden!", vbCritical, "Access-Checker"
    If AR_UseDB Then
      AddStatus FMT1("RISKTAB_2", riskrs.Fields("ACCRisikoID").value)
    Else
      MsgBox FMT1("RISKTAB_2", riskrs.Fields("ACCRisikoID").value), vbCritical, "Access-Checker"
    End If
    Exit Function
  End If
  
  Dim rv As RiskVal
  Do While Not rs.EOF
    Set rv = New RiskVal
    If Not rv.InitDB(conn, rs) Then
      Exit Function
    End If
    m_Vals.Add rv
    rs.MoveNext
  Loop
  
  rs.Close
  Set rs = Nothing
  
  With riskrs
    m_Weight = .Fields("Gewichtung").value
    m_Low = .Fields("Gering").value
    m_LowColour = .Fields("GeringFarbe").value
    m_LowMulti = .Fields("GeringMultiplikator").value
    m_Med = .Fields("Mittel").value
    m_MedColour = .Fields("MittelFarbe").value
    m_MedMulti = .Fields("MittelMultiplikator").value
    m_HighColour = .Fields("HochFarbe").value
    m_HighMulti = .Fields("HochMultiplikator").value
  End With
  
  ' Und dann noch die Einzelwerte besorgen
  
  
  
  InitDB = True
End Function


Attribute VB_Name = "RiskVal"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public m_Type As Long
Public m_Parameter As String
Public m_Vals As Collection
Public m_ParameterList As Collection
Public m_IdenticalAm As Long
Public m_Matches As Long
Public m_FirstMatch As String
Public m_FirstMatchAddress As String
Public m_Hit As Boolean

Private Sub Class_Initialize()
  Set m_Vals = New Collection
End Sub


Public Function Init(ws As Worksheet, line As Long) As Boolean
  
  Dim pos As Long
  Dim param As String
  
  ' Die Sprachen sind hier hard-codiert
  ' Das ist die Spalte Typ in 'Access-Checker Risk.xls'
  ' Momentan geht nur Englisch und Deutsch
  
  Init = False
  Select Case ws.Cells(line, 2)
    Case "ACC"
          m_Type = C_RISK_TYPE_ECC
    Case "Formula contains", "Formel enth|fffd|lt"
          m_Type = C_RISK_TYPE_FORMULA_CONTAINS
          
          Set m_ParameterList = New Collection
          
          m_Matches = 0
          m_FirstMatch = ""
          
          param = ws.Cells(line, 3)
    
          pos = InStr(param, ",")
          If pos <= 0 Then
            'MsgBox "ERROR: 'Formel enth|fffd|lt' muss als ersten Wert in 'Parameter / Schl|fffd|ssewort' einen numerischen Wert aufweisen! Datei 'Access-Checker Risk.xls' Tabelle '" & ws.name & " Zeile " & line, vbCritical, "Access-Checker"
            MsgBox FMT2("RISKVAL_1", ws.name, line), vbCritical, "Access-Checker"
            Exit Function
          End If
          If Not IsNumeric(Trim(Left(param, pos - 1))) Then
            'MsgBox "ERROR: 'Formel enth|fffd|lt' muss als ersten Wert in 'Parameter / Schl|fffd|ssewort' einen numerischen Wert aufweisen! Datei 'Access-Checker Risk.xls' Tabelle '" & ws.name & " Zeile " & line, vbCritical, "Access-Checker"
            MsgBox FMT2("RISKVAL_1", ws.name, line), vbCritical, "Access-Checker"
            Exit Function
          End If
          
          m_IdenticalAm = CLng(Trim(Left(param, pos - 1)))
          param = Mid(param, pos + 1)
          
          Do
            pos = InStr(param, ",")
            If pos <= 0 Then Exit Do
            If Left(Trim(Left(param, pos - 1)), 1) = "$" Or Left(Trim(Left(param, pos - 1)), 1) = "|" Then
              m_ParameterList.Add UCase(Trim(Left(param, pos - 1)))
            Else
'              m_ParameterList.Add UCase(TranslateFuncToE(Trim(Left(param, pos - 1))))
              m_ParameterList.Add UCase(Trim(Left(param, pos - 1)))
            End If
            param = Mid(param, pos + 1)
          Loop
                
          If Len(param) > 0 Then
            m_ParameterList.Add Trim(param)
          End If
          
          G_RiskContains.Add Me
      
    Case "In list", "Not in list", "Nicht in Liste"
          
          Set m_ParameterList = New Collection
          
          m_Matches = 0
          m_FirstMatch = ""
          
          If ws.Cells(line, 2) = "Whitelist" Then
            m_Type = C_RISK_TYPE_WHITE_LIST
          Else
            m_Type = C_RISK_TYPE_NOT_IN_WHITE_LIST
          End If
          
          param = ws.Cells(line, 3)
    
          Do
            pos = InStr(param, ",")
            If pos <= 0 Then Exit Do
            If Left(Trim(Left(param, pos - 1)), 1) = "$" Or Left(Trim(Left(param, pos - 1)), 1) = "|" Then
              m_ParameterList.Add UCase(Trim(Left(param, pos - 1)))
            Else
'              m_ParameterList.Add UCase(TranslateFuncToE(Trim(Left(param, pos - 1))))
              m_ParameterList.Add UCase(Trim(Left(param, pos - 1)))
            End If
            param = Mid(param, pos + 1)
          Loop
                
          If Len(param) > 0 Then
            m_ParameterList.Add Trim(param)
          End If
          
          
          G_WhiteList.Add Me
      
    Case Else
      'MsgBox "ERROR: Unbekannter Typ '" & ws.Cells(line, 2) & "' in 'Access-Checker Risk.xls' Tabelle '" & ws.name & " Zeile " & line, vbCritical, "Access-Checker"
      MsgBox FMT3("RISKVAL_2", ws.Cells(line, 2), ws.name, line), vbCritical, "Access-Checker"
      Exit Function
  End Select
  
  m_Parameter = ws.Cells(line, 3)
  Dim x As Long
  x = 4
  With ws
    Do While Not IsEmpty(.Cells(line, x))
      If Not AddVal(ws, x, .Cells(line, x), .Cells(line, x + 1), .Cells(line, x + 2), ws.name, line) Then Exit Function
      x = x + 3
    Loop
  End With
  Init = True
  
End Function

Public Function AddVal(ws As Worksheet, x As Long, comp As String, v As String, risk As Double, sheetname As String, line As Long) As Boolean
  AddVal = False
  Dim rr As New RiskRange
  Select Case comp
    Case "<"
      rr.m_Comparison = C_RISK_COMP_TYPE_LESS
    Case "<="
      rr.m_Comparison = C_RISK_COMP_TYPE_LESSEQUAL
    Case "="
      rr.m_Comparison = C_RISK_COMP_TYPE_EQUAL
    Case ">="
      rr.m_Comparison = C_RISK_COMP_TYPE_LARGEREQUAL
    Case ">"
      rr.m_Comparison = C_RISK_COMP_TYPE_LARGER
    Case Else
      'MsgBox "ERROR: Unbekannter Vergleichsoperator '" & comp & "' in 'Access-Checker Risk.xls' Tabelle '" & sheetname & " Zelle " & ws.Cells(line, x).Address, vbCritical, "Access-Checker"
      MsgBox FMT3("RISKVAL_3", comp, sheetname, ws.Cells(line, x).Address), vbCritical, "Access-Checker"
      Exit Function
  End Select
  
  If Not IsNumeric(v) Then
    'MsgBox "ERROR: Nicht numerischer Wert in 'Access-Checker Risk.xls' Tabelle '" & sheetname & " Zelle " & ws.Cells(line, x + 1).Address, vbCritical, "Access-Checker"
    MsgBox FMT2("RISKVAL_4", sheetname, ws.Cells(line, x + 1).Address), vbCritical, "Access-Checker"
    Exit Function
  End If
  
  If Not IsNumeric(risk) Then
    'MsgBox "ERROR: Nicht numerischer Wert in 'Access-Checker Risk.xls' Tabelle '" & sheetname & " Zelle " & ws.Cells(line, x + 2).Address, vbCritical, "Access-Checker"
    MsgBox FMT2("RISKVAL_4", sheetname, ws.Cells(line, x + 2).Address), vbCritical, "Access-Checker"
    Exit Function
  End If
  
  If Val(risk) < 0 Or Val(risk) > 1 Then
    'MsgBox "ERROR: Risiko muss zwischen 0% und 100% liegen in 'Access-Checker Risk.xls' Tabelle '" & sheetname & " Zelle " & ws.Cells(line, x + 1).Address, vbCritical, "Access-Checker"
    MsgBox FMT2("RISKVAL_5", sheetname, ws.Cells(line, x + 1).Address), vbCritical, "Access-Checker"
    Exit Function
  End If
  
  
  rr.m_Value = v
  rr.m_Risk = risk
  
  m_Vals.Add rr
  
  AddVal = True
End Function




Sub CheckFunc(s As String)
  Dim i As Long
  If m_ParameterList.count <= 0 Then Exit Sub
  Dim foundone As Boolean
  For i = 1 To m_ParameterList.count
    If m_ParameterList(i) = s Then
      foundone = True
      Exit For
    End If
  Next i

  If foundone Then
    If m_Type = C_RISK_TYPE_WHITE_LIST Then
      m_Hit = True
      m_Matches = m_Matches + 1
    End If
  Else
    If m_Type = C_RISK_TYPE_NOT_IN_WHITE_LIST Then
      m_Hit = True
      m_Matches = m_Matches + 1
    End If
  End If

End Sub


Public Function InitDB(conn, rs) As Boolean
  
  Dim pos As Long
  Dim param As String
  
  InitDB = False
  
  Select Case rs.Fields("ACCTypID").value
    Case C_RISK_TYPE_ECC
          m_Type = C_RISK_TYPE_ECC
    Case C_RISK_TYPE_FORMULA_CONTAINS
          m_Type = C_RISK_TYPE_FORMULA_CONTAINS
          
          Set m_ParameterList = New Collection
          
          m_Matches = 0
          m_FirstMatch = ""
          
          param = rs.Fields("Parameter").value
    
          pos = InStr(param, ",")
          If pos <= 0 Then
            'MsgBox "ERROR: 'Formul enth|fffd|lt' muss als ersten Wert in 'Parameter / Schl|fffd|ssewort' einen numerischen Wert aufweisen! Tabelle 'ACCRegeln'", vbCritical, "Access-Checker"
            MsgBox FMT0("RISKVAL_6"), vbCritical, "Access-Checker"
            Exit Function
          End If
          If Not IsNumeric(Trim(Left(param, pos - 1))) Then
            'MsgBox "ERROR: 'Formul enth|fffd|lt' muss als ersten Wert in 'Parameter / Schl|fffd|ssewort' einen numerischen Wert aufweisen! Tabelle 'ACCRegeln'", vbCritical, "Access-Checker"
            MsgBox FMT0("RISKVAL_6"), vbCritical, "Access-Checker"
            Exit Function
          End If
          
          m_IdenticalAm = CLng(Trim(Left(param, pos - 1)))
          param = Mid(param, pos + 1)
          
          Do
            pos = InStr(param, ",")
            If pos <= 0 Then Exit Do
            If Left(Trim(Left(param, pos - 1)), 1) = "$" Or Left(Trim(Left(param, pos - 1)), 1) = "|" Then
              m_ParameterList.Add UCase(Trim(Left(param, pos - 1)))
            Else
'              m_ParameterList.Add UCase(TranslateFuncToE(Trim(Left(param, pos - 1))))
              m_ParameterList.Add UCase(Trim(Left(param, pos - 1)))
            End If
            param = Mid(param, pos + 1)
          Loop
                
          If Len(param) > 0 Then
            m_ParameterList.Add Trim(param)
          End If
          
          G_RiskContains.Add Me
      
    Case C_RISK_TYPE_WHITE_LIST, C_RISK_TYPE_NOT_IN_WHITE_LIST
          
          m_Type = rs.Fields("ACCTypID").value
          
          Set m_ParameterList = New Collection
          
          m_Matches = 0
          m_FirstMatch = ""
          
          m_Type = rs.Fields("ACCTypID").value
          
          param = rs.Fields("Parameter").value
    
          Do
            pos = InStr(param, ",")
            If pos <= 0 Then Exit Do
            If Left(Trim(Left(param, pos - 1)), 1) = "$" Or Left(Trim(Left(param, pos - 1)), 1) = "|" Then
              m_ParameterList.Add UCase(Trim(Left(param, pos - 1)))
            Else
'              m_ParameterList.Add UCase(TranslateFuncToE(Trim(Left(param, pos - 1))))
              m_ParameterList.Add UCase(Trim(Left(param, pos - 1)))
            End If
            param = Mid(param, pos + 1)
          Loop
                
          If Len(param) > 0 Then
            m_ParameterList.Add Trim(param)
          End If
          
          
          G_WhiteList.Add Me
      
    Case Else
      'MsgBox "ERROR: Unbekannter Typ in Tabelle 'ACCRegeln'", vbCritical, "Access-Checker"
      MsgBox FMT0("RISKVAL_7"), vbCritical, "Access-Checker"
      Exit Function
  End Select
  
  m_Parameter = rs.Fields("Parameter").value
  
  
  Dim errs
  Set errs = CreateObject("ADODB.recordset")
  errs.Open "SELECT * FROM ACCEinzelregeln WHERE ACCRegelID = " & rs.Fields("ACCRegelID").value & " ORDER BY id", conn, 2, 1
  If errs.EOF Then
    'MsgBox "Es sind keine Einzelregeln f|fffd|r die Regel '" & rs.Fields("ACCRegelID").value & "' in der Datenbank des IDV-Trackers enthalten. Es kann keine Gesamtrisikoanalyse vorgenommen werden!", vbCritical, "Access-Checker"
    MsgBox FMT1("RISKVAL_8", rs.Fields("ACCRegelID").value), vbCritical, "Access-Checker"
    errs.Close
    Set errs = Nothing
    Exit Function
  End If
  
  
  Do While Not errs.EOF
    If Not AddValDB(errs.Fields("OperatorID").value, errs.Fields("GefundeneZellen").value, errs.Fields("Risiko").value) Then Exit Function
    errs.MoveNext
  Loop
  InitDB = True
  
End Function


Public Function AddValDB(comp As String, v As String, risk As Double) As Boolean
  AddValDB = False
  Dim rr As New RiskRange
  
  rr.m_Comparison = comp
  
  If Val(risk) < 0 Or Val(risk) > 1 Then
    'MsgBox "ERROR: Risiko muss zwischen 0% und 100% liegen in Tabelle 'ACCEinzelregeln', Spalte 'Risiko'", vbCritical, "Access-Checker"
    MsgBox FMT0("RISKVAL_9"), vbCritical, "Access-Checker"
    Exit Function
  End If
  
  rr.m_Value = v
  rr.m_Risk = risk
  
  m_Vals.Add rr
  
  AddValDB = True
End Function


Attribute VB_Name = "SWAppID"
Option Explicit

Public Enum StromwerkenAppID
SWAPPID_IDVSuite = 1
SWAPPID_ExcelTracker = 2
SWAPPID_AccessTracker = 3
SWAPPID_ExcelSheetChecker = 4
SWAPPID_IDVSuiteScheduler = 5
SWAPPID_PluginCheck = 6
SWAPPID_ECCDaemon = 7
SWAPPID_ExcelFileCompare = 8
SWAPPID_ExcelSheetQA = 9
SWAPPID_ExcelProtect = 10
SWAPPID_ACCDaemon = 11
SWAPPID_SWKeyManager = 12
SWAPPID_AccessChecker = 13
SWAPPID_FileTracker = 14
End Enum


Attribute VB_Name = "SWFuncs"
Option Explicit

'Declares for direct ping
#If VBA7 Then
Private Declare PtrSafe Function InternetOpen Lib "wininet.dll" Alias "InternetOpenA" (ByVal lpszAgent As String, ByVal dwAccessType As Long, ByVal lpszProxyName As String, ByVal lpszProxyBypass As String, ByVal dwFlags As Long) As Long
Private Declare PtrSafe Function InternetOpenUrl Lib "wininet.dll" Alias "InternetOpenUrlA" (ByVal hInet As LongPtr, ByVal lpszUrl As String, ByVal lpszHeaders As String, ByVal dwHeadersLength As Long, ByVal dwFlags As Long, ByVal dwContext As Long) As Long
Private Declare PtrSafe Function InternetCloseHandle Lib "wininet.dll" (ByVal hInet As LongPtr) As Long
Private Declare PtrSafe Function InternetReadFile Lib "wininet.dll" _
    (ByVal hFile As LongPtr, ByVal sBuffer As String, ByVal lNumBytesToRead As Long, _
    lNumberOfBytesRead As LongPtr) As Integer
Private Declare PtrSafe Function InternetGetLastResponseInfo Lib "wininet.dll" Alias "InternetGetLastResponseInfoA" _
    (lpdwError As Long, ByVal lpszBuffer As String, ByVal lpdwBufferLength As Long) As Integer
#Else
Private Declare Function InternetOpen Lib "wininet.dll" Alias "InternetOpenA" (ByVal lpszAgent As String, ByVal dwAccessType As Long, ByVal lpszProxyName As String, ByVal lpszProxyBypass As String, ByVal dwFlags As Long) As Long
Private Declare Function InternetOpenUrl Lib "wininet.dll" Alias "InternetOpenUrlA" (ByVal hInet As Long, ByVal lpszUrl As String, ByVal lpszHeaders As String, ByVal dwHeadersLength As Long, ByVal dwFlags As Long, ByVal dwContext As Long) As Long
Private Declare Function InternetCloseHandle Lib "wininet.dll" (ByVal hInet As Long) As Long
Private Declare Function InternetReadFile Lib "wininet.dll" _
    (ByVal hFile As Long, ByVal sBuffer As String, ByVal lNumBytesToRead As Long, _
    lNumberOfBytesRead As Long) As Integer
Private Declare Function InternetGetLastResponseInfo Lib "wininet.dll" Alias "InternetGetLastResponseInfoA" _
    (lpdwError As Long, ByVal lpszBuffer As String, ByVal lpdwBufferLength As Long) As Integer
#End If

Private Const INTERNET_OPEN_TYPE_PRECONFIG = 0
Private Const INTERNET_FLAG_RELOAD = &H80000000
Private Const INTERNET_FLAG_KEEP_CONNECTION = &H400000
Private Const INTERNET_FLAG_NO_CACHE_WRITE = &H4000000


Public Function CheckINetConnection() As Boolean
  Dim hInet As Long
  Dim hUrl As Long
  Dim flags As Long
  Dim url As Variant
  
  hInet = InternetOpen(" ", INTERNET_OPEN_TYPE_PRECONFIG, vbNullString, vbNullString, 0&)
  If hInet Then
    flags = INTERNET_FLAG_KEEP_CONNECTION Or INTERNET_FLAG_NO_CACHE_WRITE Or INTERNET_FLAG_RELOAD
    hUrl = InternetOpenUrl(hInet, "http://www.stromwerken.de", vbNullString, 0, flags, 0)
    If hUrl Then
        CheckINetConnection = True
        Call InternetCloseHandle(hUrl)
      Else
        CheckINetConnection = False
      End If
   End If
   Call InternetCloseHandle(hInet)
End Function

Private Function GetLine(ByRef txt As String) As String
  Dim pos As Long
  Dim res As String
  pos = InStr(txt, vbCr)
  If pos > 0 Then
    res = Left(txt, pos - 1)
  Else
    res = txt
  End If
  If pos > 0 Then
    txt = Mid(txt, 2 + pos)
  Else
    txt = ""
  End If
  
  GetLine = res

End Function

Function MySpc(l As Long) As String
  If l > 0 Then
    Dim i As Long
    For i = 1 To l
      MySpc = MySpc + " "
    Next i
  End If
End Function

Function MakeFileName(n As String)
  Dim newn As String
  Dim i As Long
  If Len(i) > 0 Then
    For i = 1 To Len(n)
      Select Case Mid(n, i, 1)
        Case ":"
          newn = newn & "-"
        Case "\", "/", "*", "?", Chr(34), "<", ">", "|"
          newn = newn & "_"
        Case Else
          newn = newn + Mid(n, i, 1)
      End Select
    Next i
  End If
  MakeFileName = newn
End Function

Function InStrMyRev(str As String, v As String, Optional pos As Long = 0) As Long
  Dim i As Long
  If Not IsMissing(pos) And pos > 0 Then
    i = pos
  Else
    i = Len(str)
  End If
  Do While i > 0
    If Mid(str, i, Len(v)) = v Then
      InStrMyRev = i
      Exit Function
    End If
    i = i - 1
  Loop
  InStrMyRev = 0
End Function

Function FileUpToDate(dst As String, src As String)
  FileUpToDate = True
'  If Not FileExists(dst) Then
'    FileUpToDate = False
'    Exit Function
'  ElseIf FileDateTime(dst) < FileDateTime(src) Then
  On Error GoTo dstFileMissing
  
  If MyFileDateTime(dst) < MyFileDateTime(src) Then
    FileUpToDate = False
    Exit Function
  End If
  
  Exit Function
dstFileMissing:
  FileUpToDate = False
  
End Function

Function PathExists(Dateiname$) As Boolean
  On Error GoTo fehler:
  Dim b As Boolean
  
  b = Dir$(Dateiname, vbDirectory) <> ""
  If Not b Then
    b = Dir$(Dateiname & "\", vbDirectory) <> ""
  End If
  PathExists = b
  Exit Function
fehler:
    PathExists = False
    Resume Next
End Function

Attribute VB_Name = "Scan"
Option Explicit

Public theidvDateiID As Long
Public theOEID As Long
Public theFreigabekommentar As String
Public theFreigabeCCListe  As String
Public theFreigabeuser As String

Sub ShowStatusForm(ByVal Headline As String)
  StatusForm.ProgressB.Width = 0
'  StatusForm.ProgressBT.Width = 0
  StatusForm.Filename = Headline
  StatusForm.VergangeneZeit = ""
  StatusForm.Restdauer = ""
  StatusForm.ProgText = ""
  LastProgText = ""
  ProgText = ""
'  StatusForm.BitteWarten.Visible = False
  DoEvents
  
'  If AR_UseDB Then
'    StatusForm.cmdAbbrechen.Visible = False
'    StatusForm.BitteWarten.Visible = True
'  Else
'    StatusForm.cmdAbbrechen.Visible = True
'  End If
  
  StatusForm.Show vbModeless
 
End Sub

Sub SetFileStatusInfo(nfo As String)
    Dim s As String
    s = GetSetting(appname:="Stromwerken", Section:="IDVSS", Key:="FileStatusInfo")
    SaveSetting appname:="Stromwerken", Section:="IDVSS", Key:="FileStatusInfo", setting:= _
      IIf(s <> "", s & vbCrLf, "") & nfo
End Sub

Sub CloseWB(ByRef subWB As Workbook)
  On Error Resume Next
  subWB.Close False
  Set subWB = Nothing

End Sub

Attribute VB_Name = "ScanFile"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public m_Name As String
Public m_OEID As Long
Public m_idvDateiID As Long
Public m_CheckerSettings As Long


Attribute VB_Name = "Start"
Option Explicit

Public G_Conn As Object

Public G_DaemonCommand As String
Public G_FileAlreadyOpen As Boolean
Public G_CreateResfile As Long
Public G_ResfileDestID As Long
Public G_ResfileTemplate As String
Public G_Resfile As String

Dim Startpath As String
Public ResName As String

Public StartedByDaemon  As Boolean

Public theTrackerFreigabe As Boolean
Public theTrackerFreigabeDatum As Date
Public theTrackerFachrisiko As Double

Public m_LogY As Long

#If VBA7 Then
    Private Declare PtrSafe Function SetForegroundWindow Lib "user32" _
               (ByVal hwnd As LongPtr) As LongPtr
    Private Declare PtrSafe Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (Destination As Any, Source As Any, ByVal Length As Long)
    Private Declare PtrSafe Function GetCurrentProcessId Lib "kernel32" () As Long
#Else
    Private Declare Function GetCurrentProcessId Lib "kernel32" () As Long
    Private Declare Function SetForegroundWindow Lib "user32" _
               (ByVal hwnd As Long) As Long
    Private Declare Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (Destination As Any, Source As Any, ByVal Length As Long)
#End If

Sub Auto_Open()
  
  Dim starttimeset As Boolean
  Dim endtimeset As Boolean

'  SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="COMMAND", setting:="SCANID /IDCALLER:" & SWAPPID_IDVSuiteScheduler & " /ID:10046"
'  SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="COMMAND", setting:="DAEMON"
'  SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="COMMAND", setting:="MASSANALYSE /STARTTIME: 09:31:07 /ENDTIME:10:31:06"

  SaveSetting appname:="Stromwerken", Section:=ProgNameShort, Key:="TrackerFreigabe", setting:="False"
  SaveSetting appname:="Stromwerken", Section:=ProgNameShort, Key:="ProcResult", setting:=""
  
  SetLiveStatus
  
  If GetSetting(appname:="Stromwerken", Section:="ACC", Key:="AbortAction", Default:="") <> "" Then
    SaveSetting appname:="Stromwerken", Section:="ACC", Key:="AbortAction", setting:=""
    SaveSetting appname:="Stromwerken", Section:=ProgNameShort, Key:="ProcessID", setting:=""
    SaveSetting appname:="Stromwerken", Section:=ProgNameShort, Key:="LiveStatusTime", setting:=#1/1/1900#
    Application.Quit
  End If
  
  m_LogY = 2

  Startpath = ThisWorkbook.path
  


  Dim commandString As String
  Dim appc As New CAppCommand
  Dim errString As String
  
  commandString = GetSetting(appname:="Stromwerken", Section:=ProgNameShort, Key:="COMMAND", Default:="")
  
  Dim errstr As String
  
  ' MsgBox "COMMAND: " & commandString
  If commandString <> "" Then
    DebugPrint tInfo, "Command String: " & commandString
    SaveSetting appname:="Stromwerken", Section:=ProgNameShort, Key:="COMMAND", setting:=""
    appc.Init commandString
    Select Case appc.m_Command
      
      Case "SCANID"
        AR_UseDB = True
        appc.AddParameter vbInteger, "/IDCALLER:", False
        appc.AddParameter vbInteger, "/ID:", False
        appc.AddParameter vbInteger, "/RES:", True
        appc.AddParameter vbInteger, "/DESTID:", True
        appc.AddParameter vbString, "/RESTEMPLATE:", True
        appc.AddParameter vbString, "/RESFILE:", True
        appc.CheckValues errString
        If errString = "" Then
          AR_StartedByApp = Val(appc.GetValue("/IDCALLER:"))
          theidvDateiID = Val(appc.GetValue("/ID:"))
          G_CreateResfile = Val(appc.GetValue("/RES:"))
          G_ResfileDestID = Val(appc.GetValue("/DESTID:"))
          G_ResfileTemplate = appc.GetValue("/RESTEMPLATE:")
          G_Resfile = appc.GetValue("/RESFILE:")
        End If
      
      Case "DAEMON"
        StartedByDaemon = True
        appc.AddParameter vbInteger, "/IDCALLER:", False
        appc.AddParameter 0, "/DB", True
        appc.AddParameter vbTime, "/STARTTIME:", True
        appc.AddParameter vbTime, "/ENDTIME:", True
        appc.CheckValues errString
        AR_StartedByApp = Val(appc.GetValue("/IDCALLER:"))
        If errString = "" Then
          AR_UseDB = appc.ParameterExists("/DB")
          If IsTime(appc.GetValue("/STARTTIME:")) Then
            G_StartScan = CDate(appc.GetValue("/STARTTIME:"))
            starttimeset = True
          End If
          If IsTime(appc.GetValue("/ENDTIME:")) Then
            G_EndScan = CDate(appc.GetValue("/ENDTIME:"))
            endtimeset = True
          End If
        End If
      
      Case "MASSANALYSE"
        AR_UseDB = True
        appc.AddParameter vbTime, "/STARTTIME:", True
        appc.AddParameter vbTime, "/ENDTIME:", True
        appc.CheckValues errString
        AR_StartedByApp = SWAPPID_IDVSuiteScheduler
        If errString = "" Then
          If IsTime(appc.GetValue("/STARTTIME:")) Then
            G_StartScan = CDate(appc.GetValue("/STARTTIME:"))
            starttimeset = True
          End If
          If IsTime(appc.GetValue("/ENDTIME:")) Then
            G_EndScan = CDate(appc.GetValue("/ENDTIME:"))
            endtimeset = True
          End If
        End If
        
      Case "APPROVAL"
      
        AR_UseDB = True
        appc.AddParameter vbInteger, "/IDCALLER:", False
        appc.AddParameter vbInteger, "/ID:", False
        appc.AddParameter vbDate, "/DATE:", False
        appc.AddParameter vbString, "/COMMENT:", False
        appc.AddParameter vbString, "/USER:", False
        appc.AddParameter vbInteger, "/RES:", True
        appc.AddParameter vbInteger, "/DESTID:", True
        appc.AddParameter vbString, "/RESTEMPLATE:", True
        appc.AddParameter vbString, "/RESFILE:", True
        appc.CheckValues errString
        AR_StartedByApp = SWAPPID_IDVSuiteScheduler
        AR_StartedByApp = Val(appc.GetValue("/IDCALLER:"))
        If errString = "" Then
          theTrackerFreigabe = True
          theidvDateiID = Val(appc.GetValue("/ID:"))
          theTrackerFreigabeDatum = CDate(appc.GetValue("/DATE:"))
          theFreigabekommentar = appc.GetValue("/COMMENT:")
          theFreigabeuser = appc.GetValue("/USER:")
          G_CreateResfile = Val(appc.GetValue("/RES:"))
          G_ResfileDestID = Val(appc.GetValue("/DESTID:"))
          DebugPrint tInfo, "APPROVAL DateiID:" & theidvDateiID & " User: " & theFreigabeuser
          G_ResfileTemplate = appc.GetValue("/RESTEMPLATE:")
          G_Resfile = appc.GetValue("/RESFILE:")
        End If
    End Select
  End If

  If AR_UseDB Then
    G_DaemonCommand = "DAEMON /IDCALLER:" & AR_StartedByApp & " /DB" & IIf(starttimeset, " /STARTTIME:" & MyTimeValue24H(G_StartScan), "") & IIf(endtimeset, " /ENDTIME:" & MyTimeValue24H(G_EndScan), "")
    SaveSetting appname:="Stromwerken", Section:=ProgNameShort, Key:="DAEMONCOMMAND", setting:=G_DaemonCommand
  Else
    G_DaemonCommand = "DAEMON /IDCALLER:" & AR_StartedByApp & IIf(starttimeset, " /STARTTIME:" & MyTimeValue24H(G_StartScan), "") & IIf(endtimeset, " /ENDTIME:" & MyTimeValue24H(G_EndScan), "")
    SaveSetting appname:="Stromwerken", Section:=ProgNameShort, Key:="DAEMONCOMMAND", setting:=G_DaemonCommand
  End If

  ' Wird dazwischen gemacht, damit wir auch den Logpfad und alles andere haben
  InitApp
  
  LogPrintECCSCanLog 0, 0, "V" & MyVersion & " (Rel: " & MyACCVersion & ") Start!"
  
  If Not TrackerTimeInScope() Then
    SaveSetting appname:="Stromwerken", Section:=ProgNameShort, Key:="LiveStatusTime", setting:=#1/1/1900#
    SaveSetting appname:="Stromwerken", Section:=ProgNameShort, Key:="Restart", setting:=0
    SaveSetting appname:="Stromwerken", Section:="IDVSS", Key:="CallbackExcelStart", setting:=1
    ThisWorkbook.Saved = True
    Application.EnableEvents = True
    RegRemoveProgPID "ACC"
    Application.Quit
    Exit Sub
  End If
  
  ' ------------------------------------------------------------------------------
  ' Commands
  ' ------------------------------------------------------------------------------
  If commandString <> "" Then
    If errString <> "" Then
      errString = errString & " (|fffd|bergebener Command-String: " & commandString & ")"
'      LogPrint errString
      LogPrintECCSCanLog 0, 9, errString, True
      If AR_StartedByApp <> SWAPPID_IDVSuiteScheduler Then
        MsgBox errString, vbCritical, ProgNameShort & " V" & MyVersion
      End If
      If G_FileAlreadyOpen = True Then
        ThisWorkbook.Close False
        Exit Sub
      Else
        SaveSetting appname:="Stromwerken", Section:=ProgNameShort, Key:="LiveStatusTime", setting:=#1/1/1900#
        SaveSetting appname:="Stromwerken", Section:=ProgNameShort, Key:="Restart", setting:=0
        SaveSetting appname:="Stromwerken", Section:="IDVSS", Key:="CallbackExcelStart", setting:=1
        ThisWorkbook.Saved = True
        Application.EnableEvents = True
        RegRemoveProgPID "ACC"
        Application.Quit
        Exit Sub
      End If
    End If
  
    ' Ab hier werden die einzelnen Kommandos ausgef|fffd|hrt
    If AR_UseDB Then
      
      RegAddProgPID "ACC"
      If theTrackerFreigabe = False And AR_StartedByApp <> 3 Then
        DoTaskKillAccessChecker
      End If
      SaveSetting appname:="Stromwerken", Section:=ProgNameShort, Key:="LiveStatusTime", setting:=#1/1/1900#
      SaveSetting appname:="Stromwerken", Section:=ProgNameShort, Key:="Restart", setting:=0
      SaveSetting appname:="Stromwerken", Section:="IDVSS", Key:="CallbackExcelStart", setting:=1
    
      LogPrint "CheckConnection"
      Set G_Conn = GetConnection()
      
      If G_Conn Is Nothing Then
        LogPrintECCSCanLog 0, 9, "Keine DB-Connection vorhanden", True
        If AR_StartedByApp <> SWAPPID_IDVSuiteScheduler Then
          If theTrackerFreigabe Then
            'MsgBox "Eine Freigabe ist kann nicht durchgef|fffd|hrt werden, da das Datenbanksystem nicht erreichbar ist.", vbCritical
            MsgBox FMT0("START_1"), vbCritical
          End If
        End If
        SaveSetting appname:="Stromwerken", Section:=ProgNameShort, Key:="LiveStatusTime", setting:=#1/1/1900#
        SaveSetting appname:="Stromwerken", Section:=ProgNameShort, Key:="Restart", setting:=0
        SaveSetting appname:="Stromwerken", Section:="IDVSS", Key:="CallbackExcelStart", setting:=1
        ThisWorkbook.Saved = True
        Application.EnableEvents = True
        RegRemoveProgPID "ACC"
        Application.Quit
        Exit Sub
      Else
        LogPrint "1. Connect erfolgreich"
      End If
    
    End If
  
    ' ------------------------------------------------------------------------------
    ' Command Execution
    ' ------------------------------------------------------------------------------
    Dim rs
    Select Case appc.m_Command
      
      Case "SCANID", "APPROVAL"
        Set rs = OpenRS("SELECT Dateiname FROM idvDateien WHERE idvDateiID=" & theidvDateiID, G_Conn, MYadLockOptimistic, MYadLockReadOnly)
        If rs Is Nothing Then
          LogPrintECCSCanLog 0, 9, "idvDateien konnte nicht ge|fffd|ffnet werden", True
        ElseIf rs.EOF Then
          LogPrintECCSCanLog theidvDateiID, 9, "DateiID nicht vorhanden!", True
        End If
        theFilename = rs.Fields("Dateiname").value
        rs.Close
        Set rs = Nothing
        G_SchedulerTimeCheckIgnore = True
        XLScriptInitDebug
        ShowStatusForm theFilename
        DoEinzelanalyse
        SaveSetting appname:="Stromwerken", Section:="IDVSS", Key:="ACCScanFinished", setting:="1"
      
      Case "DAEMON"
        ShowStatusForm ""
        DoMassenanalyse
    
      Case "MASSANALYSE"
        LogPrint "MASSANALYSE: " & G_StartScan & " - " & G_EndScan
        StoreUserCommunicateValue "TU", ""
        StoreUserCommunicateValue "FG", ""
        ShowStatusForm ""
        DoMassenanalyse
      
      Case Else
'        LogPrint "Unknown Command: " & commandString
        LogPrintECCSCanLog 0, 9, "Unknown Command: " & commandString, True
        If IsTestUser Then
          MsgBox "Unknown Command: " & commandString
        End If
        If Not G_Conn Is Nothing Then
          G_Conn.Close
          Set G_Conn = Nothing
        End If
        SaveSetting appname:="Stromwerken", Section:=ProgNameShort, Key:="LiveStatusTime", setting:=#1/1/1900#
        SaveSetting appname:="Stromwerken", Section:=ProgNameShort, Key:="Restart", setting:=0
        SaveSetting appname:="Stromwerken", Section:="IDVSS", Key:="CallbackExcelStart", setting:=1
        ThisWorkbook.Saved = True
        Application.EnableEvents = True
        RegRemoveProgPID "ACC"
        Application.Quit
      
    End Select
    Exit Sub
  End If
  
  ' ---------------------------------------------------------
  ' Normales Men|fffd|
  ' ---------------------------------------------------------
  LogPrint "StandardStart"

  ClearLog

  If AR_UseDB = False Then
    SetForegroundWindow Application.hwnd
  End If


  Dim found As Boolean
  Dim c
  For Each c In Application.CommandBars("Worksheet Menu Bar").Controls
      If c.Caption = "ACC" Then
          Application.CommandBars("Worksheet Menu Bar").Controls("ACC").Delete
          Exit For
      End If
  Next c
  
  
  Dim cbb As CommandBarPopup
  Dim scbb As CommandBarButton
  
  Set cbb = Application.CommandBars("Worksheet Menu Bar").Controls.Add(Type:=msoControlPopup)
  
  'cbb.Caption = "ACC"
  cbb.Caption = ProgNameShort
  Set scbb = cbb.Controls.Add
  scbb.BeginGroup = False
  scbb.Style = msoButtonCaption
  'scbb.Caption = "Start"
  scbb.Caption = FMT0("START_1")
  scbb.OnAction = "auto_open"
  'scbb.TooltipText = "Startet den Access-Checker"
  scbb.TooltipText = FMT0("START_2")
  
  Set scbb = cbb.Controls.Add
  scbb.BeginGroup = False
  scbb.Style = msoButtonCaption
  'scbb.Caption = "Aus Men|fffd| entfernen"
  scbb.Caption = FMT0("START_3")
  scbb.OnAction = "AccessSheetCheckRemoveMenu"
  'scbb.TooltipText = "Entfernt den Access-Checker"
  scbb.TooltipText = FMT0("START_4")
  
  If UCase(ThisWorkbook.name) = "ACCESS-CHECKER.XLS" Or UCase(ThisWorkbook.name) = "ACCESS-CHECKER.XLA" Then
      AccessSheetCheckShowMainMenu
  End If
  
End Sub

Sub DoEinzelanalyse()
  
  On Error Resume Next
  If Not FileExists(theFilename) Then
    'AddStatus "Datei '" & theFilename & "nicht mehr vorhanden."
    AddStatus FMT1("START_5", theFilename)
  ElseIf CreateTempAnalyseFile(theFilename) Then
     Analyze G_AnalyseFile, theFilename
     SetAttr G_AnalyseFile, vbNormal
     Kill G_AnalyseFile
  Else
    Sleep 10000
  End If
  
  StatusForm.Hide
  m_LogY = 2
  
  
  If SHOW_GVAR Then
    If Not G_VarNames Is Nothing Then
      Dim i As Long
      If G_VarNames.count > 0 Then
        Dim s As String
        For i = 1 To G_VarNames.count
          s = s & Chr(34) & G_VarNames(i) & Chr(34) & ", "
          If Len(s) > 900 Then
            Debug.Print s
            s = ""
          End If
        Next i
        Debug.Print s
      End If
    End If
  End If

  If AR_UseDB Then
    If Not G_Conn Is Nothing Then
      G_Conn.Close
      Set G_Conn = Nothing
    End If
  End If
    
  SaveSetting appname:="Stromwerken", Section:=ProgNameShort, Key:="ProcessID", setting:=""
  SaveSetting appname:="Stromwerken", Section:=ProgNameShort, Key:="LiveStatusTime", setting:=#1/1/1900#
  SaveSetting appname:="Stromwerken", Section:="IDVSS", Key:="ACCScanFinished", setting:="1"
'  If (AR_UseDB = False Or AR_StartedByApp = SWAPPID_AccessTracker Or G_CreateResfile = 2) And theTrackerFreigabe = False Then
'    ThisWorkbook.Close False
'  Else
    Application.Quit
'  End If
  
End Sub

Function CreateTempAnalyseFile(ByVal fname As String) As Boolean


  CreateTempAnalyseFile = False
  
  MkFullDir G_cfgTemppfad
  G_AnalyseFile = MyGetTempFilename(G_cfgTemppfad, "ACCAnalyse-") & "." & GetExtension(fname)
  If FileExists(G_AnalyseFile) Then
    SetAttr G_AnalyseFile, vbNormal
    MyKill G_AnalyseFile
  End If
  If Not FileExists(G_AnalyseFile) Then
    CopyFile theFilename, G_AnalyseFile
    If FileExists(G_AnalyseFile) Then
      'AddStatus "Tempor|fffd|re Kopie der Datei erzeugt, starte Analyse..."
      AddStatus FMT0("START_6")
      CreateTempAnalyseFile = True
      Exit Function
    Else
      If AR_UseDB Then
        'AddStatus "Datei '" & theFilename & " konnte nicht kopiert werden (zum Scan wird eine tempor|fffd|re Kopie ben|fffd|tigt)."
        AddStatus FMT1("START_7", theFilename)
        'LogPrintECCSCanLog theFilename & " (ID: " & theidvDateiID & ") - Datei konnte nicht kopiert werden (zum Scan wird eine tempor|fffd|re Kopie ben|fffd|tigt).", True
        LogPrintECCSCanLog theidvDateiID, 7, FMT2("START_8", theFilename, theidvDateiID), True
      Else
        'AddStatus "Tempor|fffd|re Kopie '" & G_cfgTemppfad & "\ACCAnalyse.mdb konnte nicht erzeugt werden! Bitte warten, Anaylse wird in 10 Sekunden beendet."
        AddStatus FMT1("START_9", G_cfgTemppfad)
      End If
    End If
  Else
    If AR_UseDB Then
      'AddStatus "Tempor|fffd|re Datei '" & G_cfgTemppfad & "\ACCAnalyse.mdb konnte nicht gel|fffd|scht werden!"
      AddStatus FMT1("START_10", G_cfgTemppfad)
      'LogPrintECCSCanLog theFilename & " (ID: " & theidvDateiID & ") - Tempor|fffd|re Datei '" & G_cfgTemppfad & "\ACCAnalyse.mdb konnte nicht gel|fffd|scht werden!", True
      LogPrintECCSCanLog theidvDateiID, 8, FMT3("START_11", theFilename, theidvDateiID, G_cfgTemppfad), True
    Else
      'AddStatus "Tempor|fffd|re Datei '" & G_cfgTemppfad & "\ACCAnalyse.mdb konnte nicht gel|fffd|scht werden! Die Datei ist vermutlich durch einen anderen User gelockt. Bitte warten, Anaylse wird in 10 Sekunden beendet."
      AddStatus FMT1("START_12", G_cfgTemppfad)
    End If
  End If

End Function

Public Sub SetDbBypass(strDbName As String, bAllowBypass As Boolean)
 On Error GoTo Err_Handler

 'bAllowBypass = True - allows use of Shift Bypass Key
 'bAllowBypass = False - prevents use of Shift Bypass Key

 Dim db As DAO.Database
 Dim ws As DAO.Workspace
 Dim prop As DAO.Property
 Dim strPropName As String
 Dim strMsg As String
 Dim bValue As Boolean

 Set ws = m_App.DBEngine.Workspaces(0)
 Set db = ws.OpenDatabase(strDbName)

 strPropName = "AllowBypassKey"
 db.Properties(strPropName) = bAllowBypass
 bValue = db.Properties("AllowBypassKey").value
 strMsg = strPropName & " property = " & _
 bValue & vbCrLf & vbCrLf & _
 "External database:" & vbCrLf & strDbName
' MsgBox strMsg, vbInformation, "SHIFT BYPASS RESET"

Exit_Sub:
db.Close
 Set ws = Nothing
 Set db = Nothing
 Set prop = Nothing
 Exit Sub
Err_Handler:
 If Err = 3270 Then 'Property not found - create and append
 Set prop = db.CreateProperty(strPropName, dbBoolean, bAllowBypass)
 db.Properties.Append prop
 Resume
 Else
 strMsg = "Error No " & Err.Number & ": " & Err.Description
' MsgBox strMsg, vbExclamation, "SET DATABASE BYPASS ERROR"
 End If
  GoTo Exit_Sub
End Sub

Sub DoMassenanalyse()
  
  Dim rs As Object
  
  Set rs = CreateObject("ADODB.recordset")
  rs.Open "SELECT ACCScan.idvDateiID, ACCScan.Dateiname, ACCScan.OEID, ACCScan.ScanStatus, idvDateien.LetzterScan, idvDateien.FreigabeStatus, idvDateien.CheckerVersion, idvDateien.CheckerSettings FROM ACCScan INNER JOIN idvDateien ON ACCScan.idvDateiID = idvDateien.idvDateiID WHERE ACCScan.idvDateiID > 0 and (idvDateien.CheckerVersion = " & MyACCVersion & " OR idvDateien.CheckerVersion = -1 OR idvDateien.CheckerVersion is NULL OR idvDateien.FreigabeStatus = 0)", G_Conn, MYadOpenDynamic, MYadLockOptimistic
'  rs.Open "SELECT * FROM ACCScan", G_Conn, MYadOpenDynamic, MYadLockOptimistic
  
  
  Set xlsDateien = New Collection
  Do While Not rs.EOF
  
    Dim sf As ScanFile
    If GetSafeFieldPlus(rs, "idvDateiID", 0) > 0 Then
      Set sf = New ScanFile
      sf.m_Name = GetDriveAndPathFromUNC(rs.Fields("Dateiname").value)
      If Not IsNull(rs.Fields("OEID").value) Then
        sf.m_OEID = rs.Fields("OEID").value
      Else
        sf.m_OEID = 0
      End If
      If IsNull(rs.Fields("idvDateiID").value) Then
        sf.m_idvDateiID = 0
      Else
        sf.m_idvDateiID = rs.Fields("idvDateiID").value
      End If
      
      sf.m_CheckerSettings = -1
      If IsNull(rs.Fields("LetzterScan").value) = False Or rs.Fields("FreigabeStatus").value = 2 Then
        If Not IsNull(rs.Fields("CheckerSettings").value) Then
          sf.m_CheckerSettings = rs.Fields("CheckerSettings").value
        End If
      End If
      
      xlsDateien.Add sf
    End If
    rs.MoveNext
  Loop
  rs.Close
  Set rs = Nothing
  
  
  If xlsDateien.count > 0 Then
  
      DoEvents
      StartDaemon
  
      Dim i As Long
      Dim currentEntry As Long
      
      For i = 1 To xlsDateien.count
        If Not TrackerTimeInScope() Then Exit For
        
        Dim currentscanstatus As Long
      
        Set rs = CreateObject("ADODB.recordset")
        rs.Open "SELECT ScanStatus FROM ACCScan WHERE idvDateiID=" & xlsDateien(i).m_idvDateiID, G_Conn, MYadOpenDynamic, MYadLockReadOnly
        If Not rs.EOF Then
          currentscanstatus = rs.Fields("ScanStatus").value
        Else
          currentscanstatus = -1
        End If
        rs.Close
        Set rs = Nothing
        
        If GetSetting(appname:="Stromwerken", Section:="ACC", Key:="AbortAction", Default:="") <> "" Then
          SaveSetting appname:="Stromwerken", Section:="ACC", Key:="AbortAction", setting:=""
          Beenden = True
        End If
        If Beenden = True Then Exit For
        
        If Not FileAllowed(xlsDateien(i).m_Name) Then
            ' Datei '%1' wird aufgrund des unbekannten Dateityps ignoriert.
            theFilename = xlsDateien(i).m_Name
            theidvDateiID = xlsDateien(i).m_idvDateiID
            If xlsDateien(i).m_Name <> "" Then
              AddStatus FMT1("CHECK_56", xlsDateien(i).m_Name)
              LogPrintECCSCanLog theidvDateiID, 0, "Datei aufgrund des unbekannten Dateityps ignoriert.", True
            End If
        Else
        
          theFilename = xlsDateien(i).m_Name
          theidvDateiID = xlsDateien(i).m_idvDateiID
          
          If currentscanstatus >= 1 Then
            
            AddStatus FMT1("CHECK_2", theFilename)
            AddStatus FMT0("SCANERG_1")
            XLScriptInitGlobals Application, Nothing
            XLScriptAddSimpleVar "FILE", theFilename
            XLScriptAddSimpleVar "NAME", theFilename
            XLScriptAddSimpleVar "SAVEDATE", Format(MyFileDateTime(theFilename), "Short Date") & " - " & Format(MyFileDateTime(theFilename), "Short Time")
            XLScriptAddSimpleVar "FILESIZEKB", CLng(MyFileLen(theFilename) / 1024)
            XLScriptAddSimpleVar "FILESIZE", MyFileLen(theFilename)
            XLScriptAddSimpleVar "STATUS", FMT0("SCANERG_1") ' "Datei/Analyse fehlerhaft"
            XLScriptAddSimpleVar "STATUSID", "1"
            XLACCStoreValsToDB False
            XLScriptExitGlobals
            ' %1 (ID: %2) - Ergebnis: Analyse mehrfach fehlerhaft, Analyse wird abgebrochen
            LogPrintECCSCanLog theidvDateiID, 1, "Ergebnis: Analyse mehrfach fehlerhaft, Analyse wird abgebrochen", True
            
          ElseIf currentscanstatus <> -1 Then
            
            Set rs = CreateObject("ADODB.recordset")
            rs.Open "SELECT * FROM ACCScan WHERE idvDateiID=" & theidvDateiID, G_Conn, MYadOpenDynamic, MYadLockOptimistic
            If Not rs.EOF Then
              rs.Fields("ScanStatus").value = rs.Fields("ScanStatus").value + 1
              rs.Update
            End If
            rs.Close
            Set rs = Nothing
            
            StatusForm.Filename = theFilename
            DoEvents
            
            If Not FileExists(theFilename) Then
              'AddStatus "Datei '" & theFilename & "nicht mehr vorhanden."
              AddStatus FMT1("START_5", theFilename)
            Else
              If CreateTempAnalyseFile(theFilename) Then
                Analyze G_AnalyseFile, theFilename
                SetAttr G_AnalyseFile, vbNormal
                MyKill G_cfgTemppfad & "\ACCAnalyse-*.*"  ' G_AnalyseFile
              End If
            End If
          End If
        End If
      
        If TrackerTimeInScope() Then
          Set rs = CreateObject("ADODB.recordset")
          rs.Open "SELECT * FROM ACCScan WHERE idvDateiID=" & theidvDateiID, G_Conn, MYadOpenDynamic, MYadLockOptimistic
          If Not rs.EOF Then
            rs.Delete
          End If
          rs.Close
          Set rs = Nothing
        End If
      
      Next i
  
      EndDaemon
      
  End If
  
  
  
  If AR_UseDB = True And Beenden = False Then
    
    MyKill G_cfgTemppfad & "\ACCAnalyse-*.*"  ' G_AnalyseFile
          
    If TrackerTimeInScope() Then
            If GetSetting(appname:="Stromwerken", Section:="IDVSS", Key:="ACCFileScanRunning", Default:="0") <> 1 Then
                  Dim accNewVer As Long
                  accNewVer = -1
                  Set rs = CreateObject("ADODB.recordset")
                  rs.Open "SELECT * FROM ACCScan WHERE CheckerVersion < " & MyACCVersion & " AND CheckerVersion >= 0 ORDER BY CheckerVersion DESC", G_Conn, MYadOpenDynamic, MYadLockOptimistic
                  If Not rs.EOF Then
                    accNewVer = rs.Fields("CheckerVersion").value
                  End If
                  rs.Close
                  
                  ' das hier wird nur gemacht, wenn das auch wirklich der aktuelle Scanner ist
                  If InStr(UCase(ThisWorkbook.name), "CHECKER") > 0 Then
                    Dim am As Long
                    
                    am = 0
        '            rs.Open "SELECT count(idvDateiID) as cnt FROM ACCScan WHERE CheckerVersion = " & MyACCVersion & " or CheckerVersion < 0", G_Conn, MYadOpenDynamic, MYadLockOptimistic
                    rs.Open "SELECT count(ACCScan.idvDateiID) as cnt FROM ACCScan INNER JOIN idvDateien ON ACCScan.idvDateiID = idvDateien.idvDateiID WHERE ACCScan.idvDateiID > 0 and (idvDateien.CheckerVersion = " & MyACCVersion & " OR idvDateien.CheckerVersion = -1 OR idvDateien.CheckerVersion is NULL OR idvDateien.FreigabeStatus = 0)", G_Conn, MYadOpenDynamic, MYadLockOptimistic
                    If Not rs.EOF Then
                      am = rs.Fields("cnt").value
                    End If
                    rs.Close
                    
                    If am > 0 Then
                      Set rs = Nothing
                      RestartScanner
                      Exit Sub
                    End If
                    
                    am = 0
                    rs.Open "SELECT count(idvDateiID) as cnt FROM ACCScan WHERE CheckerVersion >= 0 and CheckerVersion < " & MyACCVersion, G_Conn, MYadOpenDynamic, MYadLockOptimistic
                    If Not rs.EOF Then
                      am = rs.Fields("cnt").value
                    End If
                    rs.Close
                  
                    ' Es werden %1 Dateien mit |fffd|lteren Versionen des Access-Checkers gescannt.
                    LogPrintECCSCanLog 0, 0, FMT1("CHECK_55", am), True
                    If InStr(UCase(ThisWorkbook.name), "ACCESS-CHECKER") > 0 Then
                      SaveSetting appname:="Stromwerken", Section:="IDVSS", Key:="ACCScanResult10", setting:=am
                    End If
                  
                  End If
                  
                  Set rs = Nothing
        
                  If accNewVer >= 0 Then
                    'AddStatus "Schlie|fffd|e ACC f|fffd|r Neustart als Version " & eccNewVer
                    AddStatus FMT1("START_19", accNewVer)
                    LogPrintECCSCanLog 0, 0, "ACC-Restart als Version " & accNewVer
                    
                    Sleep 2000
                    
                    SaveSetting appname:="Stromwerken", Section:="ACC", Key:="StartedByTracker", setting:="True"
                    SaveSetting appname:="Stromwerken", Section:="ACC", Key:="StartedByTrackerFirstTime", setting:="True"
                    SaveSetting appname:="Stromwerken", Section:="ACC", Key:="StartedByDaemon", setting:="False"
                    ' SaveSetting appname:="Stromwerken", Section:="ACC", Key:="StartedByDaemon", setting:="True"
                    ' SaveSetting AppName:="Stromwerken", Section:="ECC", Key:="StartedByTrackerFirstTime", Setting:="True"
                     
                    ' OLD VERSION STUFF!
                    SaveSetting appname:="Stromwerken", Section:="ACC", Key:="TrackerFile", setting:="@"
                    SaveSetting appname:="Stromwerken", Section:="ACC", Key:="TrackerLogPassword", setting:="true"
                    SaveSetting appname:="Stromwerken", Section:="ACC", Key:="TrackerShowStatusform", setting:="True"
                    SaveSetting appname:="Stromwerken", Section:="ACC", Key:="TrackerFreigabe", setting:="False"
                    
                    SaveSetting appname:="Stromwerken", Section:="ACC", Key:="StartScan", setting:=G_StartScan
                    SaveSetting appname:="Stromwerken", Section:="ACC", Key:="EndScan", setting:=G_EndScan
                    ' OLD VERSION STUFF END!
                    
                    ThisWorkbook.Saved = True
                    GConnClose
                    
                    SetLiveStatus
                    LogPrint "ACC Restart (Rel: " & accNewVer & ")"
                    If FileExists(ThisWorkbook.path & "\ACCV" & accNewVer & ".xls") Then
                      SaveSetting appname:="Stromwerken", Section:=ProgNameShort, Key:="Restart", setting:=1
                      SaveSetting appname:="Stromwerken", Section:=ProgNameShort, Key:="LiveStatusExec", setting:="ACCV" & accNewVer & ".xls"
                      SaveSetting appname:="Stromwerken", Section:=ProgNameShort, Key:="StartedByTracker", setting:=IIf(AR_UseDB, "True", "False")
                      SaveSetting appname:="Stromwerken", Section:=ProgNameShort, Key:="ProcessID", setting:=""
                      RegRemoveProgPID "ACC"
                      StartExcelDatei ThisWorkbook.path & "\ACCV" & accNewVer & ".xls"
                    Else
                      SaveSetting appname:="Stromwerken", Section:=ProgNameShort, Key:="Restart", setting:=1
                      SaveSetting appname:="Stromwerken", Section:=ProgNameShort, Key:="LiveStatusExec", setting:="ACCV" & accNewVer & ".xla"
                      SaveSetting appname:="Stromwerken", Section:=ProgNameShort, Key:="StartedByTracker", setting:=IIf(AR_UseDB, "True", "False")
                      SaveSetting appname:="Stromwerken", Section:=ProgNameShort, Key:="ProcessID", setting:=""
                      RegRemoveProgPID "ACC"
                      StartExcelDatei ThisWorkbook.path & "\ACCV" & accNewVer & ".xla"
                    End If
                   
                    Application.EnableEvents = True
                    Application.Quit
                    Exit Sub
                  Else
                    StoreComm False
                    LogPrintECCSCanLog 0, 0, "Schlie|fffd|e ACC, alle Analysen beendet"
                    SaveSetting appname:="Stromwerken", Section:="IDVSS", Key:="ACCScanFinished", setting:="1"
                  End If
            End If
    End If
  End If
  
  GConnClose

  StatusForm.Hide
  SaveSetting appname:="Stromwerken", Section:=ProgNameShort, Key:="ProcessID", setting:=""
  SaveSetting appname:="Stromwerken", Section:=ProgNameShort, Key:="LiveStatusTime", setting:=#1/1/1900#
  RegRemoveProgPID "ACC"
  Application.Quit

End Sub

Function FileAllowed(ByVal Filename As String) As Boolean
  
' Current formats
' Access Blank Project Template .adn
' Access Database (2007 and later) .accdb
' Access Database Runtime (2007 and later) .accdr
' Access Database Template (2007 and later) .accdt
' Access Add-In (2007 and later) .accda
' Access Workgroup, database for user-level security. .mdw
' Protected Access Database, with compiled VBA and macros (2007 and later) .accde
' Windows Shortcut: Access Macro .mam
' Windows Shortcut: Access Query .maq
' Windows Shortcut: Access Report .mar
' Windows Shortcut: Access Table .mat
' Windows Shortcut: Access Form .maf
' Access lock files (associated with .accdb) .laccdb

' Legacy formats
' Protected Access Data Project (not supported in 2013) .ade
' Access Data Project (not supported in 2013) .adp
' Access Database (2003 and earlier) .mdb
' Access Database (Pocket Access for Windows CE) .cdb
' Access Database, used for addins (Access 2, 95, 97),
' previously used for workgroups (Access 2) .mda
' Access Blank Database Template (2003 and earlier) .mdn
' Access Add-in Data (2003 and earlier) .mdt
' Access (SQL Server) detached database (2000) .mdf
' Protected Access Database, with compiled VBA and macros (2003 and earlier) .mde
  
  Select Case UCase(GetFileExtension(Filename))
    Case "ADP", "ADN", "ACCDB", "ACCDT", "ACCDA", "ACCDE", "MDB", "MDA", "MDE"
      FileAllowed = True
  End Select
End Function

Function MyKill(fname As String) As Boolean
  On Error GoTo nogo
  Kill fname
  MyKill = True
  Exit Function
nogo:
End Function

Sub Auto_Close()
    On Error Resume Next
'    Application.CommandBars("Worksheet Menu Bar").Controls("Access-Checker").Delete
End Sub

Public Sub AccessSheetCheckShowMainMenu()

  Dim accResFile As String
  Dim resFilePath As String
  
  resFilePath = ThisWorkbook.path & "\ACC-Res.xls" ' gTranslation.GetLocalizedFile(ThisWorkbook.path & "\ACC-Einzelanalyse.xltx")
  accResFile = GetFileNameAndExtension(resFilePath)
  
  'If FileExists(ThisWorkbook.path & "\ACC-Res.xls") Then
  If FileExists(resFilePath) Then
    'ResName = ThisWorkbook.path & "\ACC-Res.xls"
    ResName = resFilePath
  Else
    If AR_UseDB = False Then
      'MsgBox "Datei '" & ThisWorkbook.path & "\ACC-Res.xls' nicht gefunden!", vbCritical
      MsgBox FMT2("START_13", ThisWorkbook.path, accResFile), vbCritical
    Else
      'AddStatus "Datei '" & ThisWorkbook.path & "\ACC-Res.xls' nicht gefunden!", vbCritical
      AddStatus FMT2("START_13", ThisWorkbook.path, accResFile), vbCritical
    End If
    Exit Sub
  End If

  FullVersion = False
  GetData
  
    If GSprache = 0 Then
      GSprache = 1
      SaveSetting _
         appname:="Stromwerken", _
         Section:=ProgNameShort, _
         Key:="Sprache", _
         setting:=GSprache
    End If
    
    ' GSprache = 2 ' English Version
    
    
    If Len(Startpath) = 0 Then
        Startpath = ThisWorkbook.path
    End If
    MainMenu.Vers.Caption = MyVersion
    MainMenu.Label1.Caption = trs
    
    BitteWarten.Show
    
    If MainMenu.AnyAccessVersionEnabled() = False Then
      'MsgBox "Error: Es wurde keine installierte Version von Access97, 2000, 2002, 2003 oder 2007 gefunden. Das Programm wird abgebrochen!", vbCritical
      MsgBox FMT0("START_14"), vbCritical
      Application.CommandBars("Worksheet Menu Bar").Controls("ACC").Delete
      ThisWorkbook.Close False
    End If
    If MainMenu.V16.Enabled = True Then
      MainMenu.V16.value = True
    ElseIf MainMenu.V15.Enabled = True Then
      MainMenu.V15.value = True
    ElseIf MainMenu.V14.Enabled = True Then
      MainMenu.V14.value = True
    ElseIf MainMenu.V12.Enabled = True Then
      MainMenu.V12.value = True
    ElseIf MainMenu.V11.Enabled = True Then
      MainMenu.V11.value = True
    ElseIf MainMenu.V10.Enabled = True Then
      MainMenu.V10.value = True
    ElseIf MainMenu.V9.Enabled = True Then
      MainMenu.V9.value = True
    ElseIf MainMenu.V8.Enabled = True Then
      MainMenu.V8.value = True
    End If
    If FullVersion = False Then
      trs = ThisWorkbook.Sheets("Hinweis").Cells(1, 3)
      trsShrt = ThisWorkbook.Sheets("Hinweis").Cells(1, 4)
    End If
    
    MainMenu.Cop = "|fffd|2005 - " & year(Now)
    MainMenu.Show
End Sub

Sub AccessSheetCheckRemoveMenu()
    On Error Resume Next
    'If MsgBox("Sind Sie sicher, dass Sie den Access-Checker aus dem Men|fffd| entfernen m|fffd|chten?", vbYesNo) = vbYes Then
    If MsgBox(FMT0("START_15"), vbYesNo) = vbYes Then
        Application.CommandBars("Worksheet Menu Bar").Controls("ACC").Delete
        ThisWorkbook.Close False
    End If
End Sub




Function OpenRS(ByVal sqlstring As String, ByRef conn As Object, ByVal cursorytype As Long, ByVal locktype As Long) As Object
        Dim rs As Object
        Set rs = CreateObject("ADODB.Recordset")
        On Error Resume Next

        Set OpenRS = Nothing
        Dim cnt As Long
        cnt = 0
checkAgain:
        rs.Open sqlstring, conn, cursorytype, locktype
        If Err.Number <> 0 Then
            Debug.Print Err.Description
            Err.Clear
            Sleep 50
            cnt = cnt + 1
            If cnt >= 100 Then
                rs = Nothing
                Exit Function
            End If
            GoTo checkAgain
        End If

        Set OpenRS = rs
End Function


Sub StartDaemon()

  LogPrint "StartDaemon 1"
  
  'Application.Caption = "Access-Checker"
  Application.Caption = ProgNameLong
  'AddStatus "Starte ACCDaemon"
  AddStatus FMT0("START_16")
'  SaveECCDaemon
  SetLiveStatus
  LogPrint "StartDaemon 2"
  
  SaveSetting _
     appname:="Stromwerken", _
     Section:=ProgNameShort, _
     Key:="LiveStatusCaption", _
     setting:=Application.Caption
  SaveSetting _
     appname:="Stromwerken", _
     Section:=ProgNameShort, _
     Key:="LiveStatusExec", _
     setting:=ThisWorkbook.name
  
  LogPrint "StartDaemon 3"
  
'  Debug.Print "APPHWND: " & Application.Hwnd
'  Debug.Print "PROCESS: " & GetCurrentProcess
  
'  Dim L_HWND As Long
  
  'Microsoft Excel - Mappe1.xls = Caption der Excelanwendung
'  L_HWND = FindWindow("XLMain", Application.Caption)
'  Debug.Print "PROCESS: " & L_HWND

'  Debug.Print ThisWorkbook.Path & "\ECCDaemon.exe "
  
  SetLiveStatus
  
  
  LogPrint "StartDaemon 4"
  
  If AR_UseDB = True And G_cfgLogpfad <> "" Then
    SaveSetting appname:="Stromwerken", Section:="ACC", Key:="DaemonLog", setting:=G_cfgLogpfad & "\IDV-Suite Scheduler-" & GetUserName & ".txt"
  Else
    SaveSetting appname:="Stromwerken", Section:="ACC", Key:="DaemonLog", setting:=""
  End If
  
'  Call Shell(ThisWorkbook.Path & "\ECCDaemon.exe " & Chr(34) & Application.Caption & Chr(34) & " " & ThisWorkbook.name & " 1", vbMinimizedNoFocus)
  If Not FileExists(ThisWorkbook.path & "\ACCDaemon.exe") Then
    'AddStatus "Datei '" & ThisWorkbook.path & "\ACCDaemon.exe' nicht vorhanden, der ACCDaemon kann nicht gestartet werden!"
    AddStatus FMT1("START_17", ThisWorkbook.path)
  Else
    Call Shell(ThisWorkbook.path & "\ACCDaemon.exe " & Chr(34) & Application.Caption & Chr(34) & " " & ThisWorkbook.name, vbMinimizedNoFocus)
  End If
'  Call Shell(ThisWorkbook.Path & "\ECCDaemon.exe " & GetCurrentProcess & " " & ThisWorkbook.name, vbMinimizedNoFocus)
  LogPrint "StartDaemon End"
End Sub

Sub EndDaemon()
  
  SaveSetting _
     appname:="Stromwerken", _
     Section:=ProgNameShort, _
     Key:="LiveStatus", _
     setting:="Finished"
  
  On Error Resume Next
'  Application.OnTime NextTime, "SetLiveStatus", , False
End Sub

Sub SetLiveStatus()

  SaveSetting _
     appname:="Stromwerken", _
     Section:=ProgNameShort, _
     Key:="LiveStatusTime", _
     setting:=Now
  
  SaveSetting _
     appname:="Stromwerken", _
     Section:=ProgNameShort, _
     Key:="LiveStatus", _
     setting:="Alive"

'  NextTime = Now + TimeValue("00:01:00")
'  Application.OnTime NextTime, "SetLiveStatus"
  
End Sub




Public Function AnwendungFuerDatei(ByVal a_Datei As String) As String
  'Datei: Pfad + Dateinamen einer existierenden Datei
  Dim Pfad As String * 255
  
  Call FindExecutable(a_Datei, vbNullString, Pfad)
  
  If "" <> Trim(Pfad) Then
     Pfad = Trim(Left(Pfad, InStr(Pfad, vbNullChar) - 1))
  End If
  AnwendungFuerDatei = Trim(Pfad)
End Function

Sub StartExcelDatei(Filename As String)
   Dim s2 As String, s3 As String, n As Long
   
   s2 = AnwendungFuerDatei(Filename)
   
   If UCase(Right(s2, 9)) <> "EXCEL.EXE" Then
     DebugPrint tERROR, "Datei '" & s2 & "' ist nicht Excel! Die Datei '" & Filename & "' kann deshalb nicht ge|fffd|ffnet werden!"
     Exit Sub
   End If
   
   If "" <> s2 Then
      s3 = Chr(34) & s2 & Chr(34) & " /e /automation /r " & Chr(34) & ShortFileName(Filename) & Chr(34)
      If GetSetting(appname:="Stromwerken", Section:="ACC", Key:="TrackerShowStatusform", Default:="True") = "True" Then
        LogPrintECCSCanLog 0, 0, "Start (normal focus): " & s3
        n = Shell(s3, vbNormalFocus)
      Else
        LogPrintECCSCanLog 0, 0, "Start (hidden): " & s3
        n = Shell(s3, vbHide)
      End If
   Else
      'MsgBox "Anwendungprogramm f|fffd|r " & Filename & " nicht gefunden/installiert!"
      MsgBox FMT1("START_20", Filename)
   End If
End Sub

Sub GConnClose()
  On Error Resume Next
  If Not G_Conn Is Nothing Then
    G_Conn.Close
    Set G_Conn = Nothing
  End If
End Sub

Function TrackerTimeInScope() As Boolean
  
  TrackerTimeInScope = True
  
  If AR_UseDB = False Then Exit Function
  
  If theTrackerFreigabe Then Exit Function
  
  If G_SchedulerTimeCheckIgnore Then Exit Function
  
  If TimeInScope(Now, G_StartScan, G_EndScan) Then Exit Function
    
  TrackerTimeInScope = False
  
End Function


Sub RestartScanner()
  
  LogPrintECCSCanLog 0, 0, "Restart"
  SaveSetting appname:="Stromwerken", Section:=ProgNameShort, Key:="Restart", setting:=1
  SaveSetting appname:="Stromwerken", Section:=ProgNameShort, Key:="COMMAND", setting:=G_DaemonCommand
  RegRemoveProgPID "ACC"
  StartExcelDatei ThisWorkbook.FullName
  ThisWorkbook.Saved = True
  Application.EnableEvents = True
  Application.Quit
End Sub

Attribute VB_Name = "StatusForm"
Attribute VB_Base = "0{C3105E5B-5CAA-4B74-BAB7-1BDD8C1E1EE6}{E4D83905-8F0E-4E42-AC7F-7557BCB93893}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Sub UserForm_Initialize()
  gTranslation.TranslateForm Me
End Sub
Attribute VB_Name = "Tabelle1"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Tabelle2"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Control = "CommandButton1, 1, 0, MSForms, CommandButton"
Private Sub CommandButton1_Click()
  Auto_Open
End Sub
Attribute VB_Name = "Translation"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

#If VBA6 Or VBA7 Then
    Const IS_VBA = True
#Else
    Const IS_VBA = False
#End If

' ------------------------------------------------------------------
Private Const NoError = 0       'The Function call was successful

Private Const LOCALE_USER_DEFAULT = &H400
Private Const LOCALE_SISO639LANGNAME = &H59
Private Const LOCALE_SISO3166CTRYNAME = &H5A

#If VBA7 Then
    Private Declare PtrSafe Function WNetGetUser Lib "mpr.dll" _
          Alias "WNetGetUserA" (ByVal lpName As String, _
          ByVal lpUserName As String, lpnLength As Long) As Long
          
    ' Caution:  If the user default locale is a custom locale, an application cannot accurately tag data
    ' with the value or exchange it. In this case, the application should use GetUserDefaultLocaleName
    ' (available starting with Windows Vista) in preference to GetUserDefaultLCID.
    Private Declare PtrSafe Function GetUserDefaultLCID Lib "kernel32" () As Long
    
    ' List of Language Identifier Constants and Strings:
    ' https://msdn.microsoft.com/library/dd318693.aspx
    Private Declare PtrSafe Function GetLocaleInfo Lib "kernel32" Alias "GetLocaleInfoA" ( _
        ByVal Locale As Long, _
        ByVal LCType As Long, _
        ByVal lpLCData As String, _
        ByVal cchData As Long) As Long

    ' Available since Vista
    'GetUserDefaultUILanguage
    
#Else
    Private Declare Function WNetGetUser Lib "mpr.dll" _
          Alias "WNetGetUserA" (ByVal lpName As String, _
          ByVal lpUserName As String, lpnLength As Long) As Long
    
    Private Declare Function GetUserDefaultLCID Lib "kernel32" () As Long
    
    Private Declare Function GetLocaleInfo Lib "kernel32" Alias "GetLocaleInfoA" ( _
        ByVal Locale As Long, _
        ByVal LCType As Long, _
        ByVal lpLCData As String, _
        ByVal cchData As Long) As Long
    
#End If

' ------------------------------------------------------------------


' 0 = fallback language
Private mStringTables(2) As Collection
Private mLangIDs(2) As String
Private mCurrentUser As String

Public Property Get CurrentUser() As String
    CurrentUser = mCurrentUser
End Property


Private Sub Class_Initialize()
    mCurrentUser = GetTranslationUserName
End Sub

Public Function StartupInit(installRoot As String, app As String, Optional overrideLang As String = "") As Boolean
    On Error GoTo nogo
    ' User Language ermitteln (xy-uv)
    Dim lang As String
    If overrideLang <> "" Then
        lang = overrideLang
    Else
        'lang = GetUserLanguage
        ' Direkt das nehmen was Windows reportet
        lang = GetWindowsLanguageString
    End If
    
    Dim path As String
    Dim paths(1) As String
    Dim userPaths(1) As String
    
    Dim tries As Long
    For tries = 0 To 1
    
      paths(0) = installRoot & "\Translate\" & app & "_" & lang & ".txt"
      userPaths(0) = installRoot & "\Translate\" & app & "_" & lang & "_indiv.txt"
      
      paths(1) = installRoot & "\..\Translate\" & app & "_" & lang & ".txt"
      userPaths(1) = installRoot & "\..\Translate\" & app & "_" & lang & "_indiv.txt"
      
      Dim i As Long
      For i = 0 To UBound(paths)
          If Init(0, paths(i), lang) = True Then
              ' Und auch versuchen die user strings zu laden (falls es die gibt)
              Init 1, userPaths(i), lang
              StartupInit = True
              Exit Function
          End If
      Next i
      
      ' Nix gefunden -> Fallback language setzen
      lang = GetFallbackLanguage(lang)
    
    Next tries
    
nogo:
    StartupInit = False
End Function

Public Function Init(index As Long, path As String, langId As String) As Boolean
    Init = False
    If index >= UBound(mLangIDs) Then
        Exit Function
    End If
    
    mLangIDs(index) = UCase(langId)
    Dim c As Collection
    Set c = LoadStringTable(path)
    If c Is Nothing Then
        Exit Function
    End If
    Set mStringTables(index) = c
    Init = True
End Function

Public Sub Clear()
    Set mStringTables(0) = New Collection
    Set mStringTables(1) = New Collection
End Sub

Public Function GetLocalizedFile(path As String) As String
    Dim lang As String
    If UBound(mLangIDs) > 0 Then
        If mLangIDs(0) <> "" Then
            lang = mLangIDs(0)
        End If
    End If
    If lang = "" Then
        lang = GetWindowsLanguageString
    End If
    
    GetLocalizedFile = LocalizedFileExists(path, lang)
End Function

' Splitted path\filename.ext aus path
' Und sucht dann nach
' path\filename_lang.ext
' Wenn nix gefunden, wird lang mit einem fallback replaced.
' de-de fuer alles was de-xy
' en-gb fuer alles andere
' Oder halt den original path wenn es nichts davon gibt.
' Der gefundene pfad wird returned oder "" wenn es gar nix gibt.
Public Function LocalizedFileExists(path As String, lang As String) As String
    On Error GoTo nogo
    
    LocalizedFileExists = path
    Dim newPath As String
    
    If lang <> "" Then
        ' Direkt nach der uebergebenen Sprache in lang suchen
        newPath = InternalLocalizedFileExists(path, lang)
        If newPath <> "" Then
            LocalizedFileExists = newPath
            Exit Function
        End If
        
        ' Nix gefunden -> fallback Sprache nehmen
        If Len(lang) > 2 Then
            ' Wenn es was deutsches ist, dann nach de-de suchen
            If UCase(lang) <> "DE-DEB" And InStr(UCase(lang), "DE") > 0 Then
                newPath = InternalLocalizedFileExists(path, "de-de")
                If newPath <> "" Then
                    LocalizedFileExists = newPath
                    Exit Function
                End If
            End If
        End If
        
        ' Bis hier hin nix gefunden -> nach "en-gb" suchen
        If UCase(lang) <> "DE-DE" Then
            newPath = InternalLocalizedFileExists(path, "en-gb")
            If newPath <> "" Then
                LocalizedFileExists = newPath
                Exit Function
            End If
        End If
    End If
    
nogo:
    If Not FileExists(LocalizedFileExists) Then
        LocalizedFileExists = ""
    End If
End Function

Private Function InternalLocalizedFileExists(path As String, lang As String) As String
    On Error GoTo nogo
    
    Dim newPath As String
    Dim p As String
    Dim Filename As String
    Dim ext As String
    fileSplit path, p, Filename, ext

    newPath = FmtInternal("%1%2_%3.%4", p, Filename, lang, ext)
    If newPath <> "" And FileExists(newPath) Then
        InternalLocalizedFileExists = newPath
        Exit Function
    End If
nogo:
End Function

Public Sub AddString(tableIdx As Long, id As String, s As String)
    mStringTables(tableIdx).Add s, id
End Sub

Public Function StringExists(id As String) As Boolean
    If id = "" Then
        StringExists = True
        Exit Function
    End If
    On Error GoTo nogo
    Dim s As String
    s = mStringTables(0).item(UCase(id))
    StringExists = True
    Exit Function
nogo:
    StringExists = False
End Function

Public Function GetString(id As String) As String
    On Error GoTo nogo
    If id = "" Then
        Exit Function
    End If
    
    If mStringTables(1) Is Nothing Then
        GetString = GetFallbackString(id)
        Exit Function
    End If
    GetString = mStringTables(1).item(UCase(id))
    Exit Function
nogo:
    GetString = GetFallbackString(id)
End Function

Public Function GetFallbackString(id As String) As String
    On Error GoTo nogo
    If mStringTables(0) Is Nothing Then
        GetFallbackString = id & ": ***MISSING***"
        Exit Function
    End If
    
    GetFallbackString = mStringTables(0).item(UCase(id))
    Exit Function
nogo:
    GetFallbackString = id & ": ***MISSING***"
End Function

Public Function FormatString(FMT As String, _
                             Optional arg1 As String = vbNullChar, _
                             Optional arg2 As String = vbNullChar, _
                             Optional arg3 As String = vbNullChar, _
                             Optional arg4 As String = vbNullChar, _
                             Optional arg5 As String = vbNullChar, _
                             Optional arg6 As String = vbNullChar, _
                             Optional arg7 As String = vbNullChar, _
                             Optional arg8 As String = vbNullChar, _
                             Optional arg9 As String = vbNullChar _
                             ) As String
                             
    On Error GoTo nogo
    
    Dim argarray(8) As String
    If IsTestUser Then
        argarray(0) = arg1
        argarray(1) = arg2
        argarray(2) = arg3
        argarray(3) = arg4
        argarray(4) = arg5
        argarray(5) = arg6
        argarray(6) = arg7
        argarray(7) = arg8
        argarray(8) = arg9
        
        Dim i As Long
        ' Erstmal checken ob wir fuer jeden Placeholder einen Parameter uebergeben bekommen haben
        ' Hier koennte man auch IsMissing nehmen - aber dann muessen alle args vom Type Variant sein.
        For i = 1 To 9
            If InStr(FMT, "%" & i) > 0 Then
                If argarray(i - 1) = vbNullChar Then
                    MsgBox FMT & vbCrLf & vbCrLf & "ERROR in FormatString: No arg for %" & i, vbCritical
                    Exit Function
                End If
            End If
        Next i
    Else
        argarray(0) = IIf(arg1 = vbNullChar, "", arg1)
        argarray(1) = IIf(arg2 = vbNullChar, "", arg2)
        argarray(2) = IIf(arg3 = vbNullChar, "", arg3)
        argarray(3) = IIf(arg4 = vbNullChar, "", arg4)
        argarray(4) = IIf(arg5 = vbNullChar, "", arg5)
        argarray(5) = IIf(arg6 = vbNullChar, "", arg6)
        argarray(6) = IIf(arg7 = vbNullChar, "", arg7)
        argarray(7) = IIf(arg8 = vbNullChar, "", arg8)
        argarray(8) = IIf(arg9 = vbNullChar, "", arg9)
    End If
    
    Dim r As String
    r = FMT
    
    r = Replace(r, "%%", "%")
    r = Replace(r, "\n", vbCrLf)
    r = Replace(r, "\t", vbTab)
    
    For i = 1 To 9
        r = Replace(r, "%" & i, argarray(i - 1))
    Next i
    
    FormatString = r
    Exit Function

nogo:
    FormatString = "ERROR " & FMT
End Function

#If TEST_BUILD = 1 Then
#Else
#End If

'Public Function FormatString(fmt As String, _
'                             Optional arg1 As String, _
'                             Optional arg2 As String, _
'                             Optional arg3 As String, _
'                             Optional arg4 As String, _
'                             Optional arg5 As String, _
'                             Optional arg6 As String, _
'                             Optional arg7 As String, _
'                             Optional arg8 As String, _
'                             Optional arg9 As String _
'                             ) As String
'    On Error GoTo nogo
'
'    Dim argarray(8) As String
'    argarray(0) = arg1
'    argarray(1) = arg2
'    argarray(2) = arg3
'    argarray(3) = arg4
'    argarray(4) = arg5
'    argarray(5) = arg6
'    argarray(6) = arg7
'    argarray(7) = arg8
'    argarray(8) = arg9
'    Dim i As Long
'    Dim r As String
'    r = fmt
'    For i = 1 To 9
'        r = Replace(r, "%" & i, argarray(i - 1))
'    Next i
'    r = Replace(r, "%%", "%")
'    r = Replace(r, "\n", vbCrLf)
'    r = Replace(r, "\t", vbTab)
'
'    FormatString = r
'    Exit Function
'
'nogo:
'    FormatString = "ERROR " & fmt
'End Function

Private Function GetTranslationTags(controlTag As String) As String()
    Dim tags() As String
    ' Argh.  Die Split Funktion in VBA gibt ein Element zurueck bei Split("test", ",")
    ' In VB6 aber nicht.
    ' Dann haben wir eine eigene implementierung fuer Split in MailSenden.bas. Die ist wie die VB6 version
    ' Also immer stur ein ',' dranhaengen
    tags = Split(controlTag & ",", ",")
    
    Dim invalidTags() As String
    invalidTags = Split("FIXLEFT,FIXTOP,NORESIZE", ",")
    
    Dim result As String
    
    Dim t As Variant
    For Each t In tags
        t = Trim(t)
        If t <> "" And Not IsOneOf(UCase(t), invalidTags) Then
            If Len(result) > 0 Then
                result = result & "," & t
            Else
                result = t
            End If
        End If
    Next t
    GetTranslationTags = Split(result & ",", ",")
End Function

Private Function IsOneOf(s As String, arr() As String) As Boolean
    IsOneOf = False
    If Len(s) = 0 Then
        Exit Function
    End If
    
    Dim e As Variant
    For Each e In arr
        If s = e Then
            IsOneOf = True
            Exit Function
        End If
    Next e
End Function

Private Sub TranslateControl(ctl As Object)
    On Error GoTo nogo
    Dim tag As String
    tag = ctl.tag
    If tag <> "" Then
        Dim tags() As String
        tags = GetTranslationTags(tag)
    
        ' Caption
        Dim s As String
        s = FMT0(tags(0))
        If s <> "" Then
#If IS_VBA Then
            If TypeOf ctl Is MSForms.TextBox Then
#Else
            If TypeOf ctl Is TextBox Then
#End If
                ctl.Text = s
            'ElseIf TypeOf ctl Is MSForms.UserForm Then
            Else
                ctl.Caption = s
            End If
        End If
        
        ' ControlTipText
        If UBound(tags) > 0 Then
            s = FMT0(tags(1))
            If s <> "" Then
#If IS_VBA Then
                If TypeOf ctl Is MSForms.MultiPage Then
                    ' MultiPage hat keinen tooltip
                Else
                    ctl.ControlTipText = s
                End If
#Else
                ctl.TooltipText = s
#End If
            End If
        End If
    End If

    Exit Sub
nogo:
    Debug.Print Err.Description
End Sub

Public Sub TranslateForm(frm As Object)
    TranslateControl frm
    
    
    Dim ctl As Object
    For Each ctl In frm.Controls
        
        'If ctl.ControlType = acTextBox Then
#If IS_VBA Then
        If TypeOf ctl Is MSForms.MultiPage Then
#Else
        If False Then
#End If
            TranslateControl ctl
            Dim page As Object
            For Each page In ctl.Pages
                TranslateControl page
            Next page
#If IS_VBA Then
        ElseIf TypeOf ctl Is MSForms.Frame Then
            TranslateForm ctl
#Else
        'ElseIf TypeOf ctl Is Frame Then
#End If
        Else
            TranslateControl ctl
        'ElseIf ctl.ControlType = acSubform Then
        '    TranslateForm frm(ctl.name).Form
        End If
    Next ctl
    
End Sub

' Die Sprache die der user in Windows eingestellt hat
' Rueckgabewert: Eine unserer supporteten languages
Public Function GetUserLanguage() As String
    Dim lcid As Long
    lcid = GetUserDefaultLCID()
    GetUserLanguage = MapLCIDToInternalLanguage(lcid)
End Function

' Die Sprache des installierten Ms Office
' Rueckgabewert: Eine unserer supporteten languages
Public Function GetMsOfficeLanguage() As String
    Dim lcid As Long
    lcid = Application.LanguageSettings.LanguageID(msoLanguageIDUI)
    GetMsOfficeLanguage = MapLCIDToInternalLanguage(lcid)
End Function



' -------------------------------------------------------------------
'
' -------------------------------------------------------------------

Function LoadStringTable(path As String) As Collection
    On Error GoTo nogo
    Set LoadStringTable = Nothing
    
    Const ForReading = 1
    Const TristateUseDefault = -2, TristateTrue = -1, TristateFalse = 0
    
    Dim fs, f, ts
    Set ts = Nothing
    Set fs = CreateObject("Scripting.FileSystemObject")
    Set ts = fs.OpenTextFile(path, ForReading, False, TristateTrue)
    
    'Dim sheet As Worksheet
    'Set sheet = ThisWorkbook.Sheets("Test")
    'Dim y As Long
    'y = 1
    
    Dim c As New Collection
    Dim s As String
    Do While ts.AtEndOfStream <> True
        ' This really is a Unicode string, although the debugger and MsgBox show ??
        s = ts.ReadLine
        'sheet.Cells(y, 1) = s
        'y = y + 1
        
        If ExtractString(s, c) Then
        End If
    Loop
    Set LoadStringTable = c
nogo:
    If Not ts Is Nothing Then
        ts.Close
        Set ts = Nothing
    End If
    If Not fs Is Nothing Then
        Set fs = Nothing
    End If
End Function

Function ExtractString(line As String, c As Collection) As Boolean
    On Error GoTo nogo
    
    ExtractString = False
    If line = "" Then
        Exit Function
    End If
    If Left(line, 1) = "'" Then
        Exit Function
    End If
    
    Dim pos As Long
    pos = InStr(line, " ")
    If pos <= 0 Then
        Exit Function
    End If
    
    Dim id As String
    Dim value As String
    id = Left(line, pos - 1)
    value = Mid(line, pos + 1, Len(line) - pos)
    If Not CollectionStringExists(c, id) Then
        c.Add value, id
    End If
    
    ExtractString = True
    Exit Function
nogo:
    MsgBox Err.Description
End Function

Private Function IsTestUser() As Boolean
    If mCurrentUser = "dirk" Or _
        mCurrentUser = "dwinter" Or _
        mCurrentUser = "norman" Or _
        mCurrentUser = "nneubert" Or _
        mCurrentUser = "rolf" Or _
        mCurrentUser = "rlangenberg" Then
        
        IsTestUser = True
    End If
End Function

Private Function GetTranslationUserName() As String
   ' Buffer size for the return string.
   Const lpnLength As Integer = 255

   ' Get return buffer space.
   Dim status As Integer

   ' For getting user information.
   Dim lpName, lpUserName As String

   ' Assign the buffer size constant to lpUserName.
   lpUserName = Space$(lpnLength + 1)

   ' Get the log-on name of the person using product.
   status = WNetGetUser(lpName, lpUserName, lpnLength)

   ' See whether error occurred.
   If status = NoError Then
      ' This line removes the null character. Strings in C are null-
      ' terminated. Strings in Visual Basic are not null-terminated.
      ' The null character must be removed from the C strings to be used
      ' cleanly in Visual Basic.
      lpUserName = Left$(lpUserName, InStr(lpUserName, Chr(0)) - 1)
   Else
      lpUserName = "Unbekannt"
   End If

    GetTranslationUserName = lpUserName
End Function

Private Function CollectionStringExists(c As Collection, name As String) As Boolean
  On Error GoTo notReadable
  Dim s As String
  s = c(name)
  CollectionStringExists = True
  Exit Function
  
notReadable:
  CollectionStringExists = False
End Function

Private Function LCIDToLanguageCode(lcid As Long) As String

    ' Locale IDs
    ' https://msdn.microsoft.com/en-us/goglobal/bb964664
    'Arabic (Saudi Arabia)                1025
    'Arabic (Iraq)                        2049
    'Arabic (Egypt)                       3073
    'Arabic (Libya)                       4097
    'Arabic (Algeria)                     5121
    'Arabic (Morocco)                     6145
    'Arabic (Tunisia)                     7169
    'Arabic (Oman)                        8193
    'Arabic (Yemen)                       9217
    'Arabic (Syria)                      10241
    'Arabic (Jordan)                     11265
    'Arabic (Lebanon)                    12289
    'Arabic (Kuwait)                     13313
    'Arabic (U.A.E.)                     14337
    'Arabic (Bahrain)                    15361
    'Arabic (Qatar)                      16385
    'Bulgarian                            1026
    'Catalan                              1027
    'Chinese (Taiwan)                     1028
    'Chinese (PRC)                        2052
    'Chinese (Hong Kong SAR               3076
    'Chinese (Singapore)                  4100
    'Czech                                1029
    'Danish                               1030
    'German (Germany)                     1031
    'German (Swiss)                       2055
    'German (Austrian)                    3079
    'German (Luxembourg)                  4103
    'German (Liechtenstein)               5127
    'Greek                                1032
    'English (United States)              1033
    'English (United Kingdom)             2057
    'English (Australian)                 3081
    'English (Canadian)                   4105
    'English (New Zealand)                5129
    'English (Ireland)                    6153
    'English (South Africa)               7177
    'English (Jamaica)                    8201
    'English (Caribbean)                  9225
    'English (Belize)                    10249
    'English (Trinidad)                  11273
    'Spanish (Traditional Sort)           1034
    'Spanish (Mexican)                    2058
    'Spanish (Modern Sort)                3082
    'Spanish (Guatemala)                  4106
    'Spanish (Costa Rica)                 5130
    'Spanish (Panama)                     6154
    'Spanish (Dominican Republic)         7178
    'Spanish (Venezuela)                  8202
    'Spanish (Colombia)                   9226
    'Spanish (Peru)                      10250
    'Spanish (Argentina)                 11274
    'Spanish (Ecuador)                   12298
    'Spanish (Chile)                     13322
    'Spanish (Uruguay)                   14346
    'Spanish (Paraguay)                  15370
    'Spanish (Bolivia)                   16394
    'Spanish (El Salvador)               17418
    'Spanish (Honduras)                  18442
    'Spanish (Nicaragua)                 19466
    'Spanish (Puerto Rico)               20490
    'Finnish                              1035
    'French (Standard)                    1036
    'French (Belgian)                     2060
    'French (Canadian)                    3084
    'French (Swiss)                       4108
    'French (Luxembourg)                  5132
    'Hebrew                               1037
    'Hungarian                            1038
    'Icelandic                            1039
    'Italian (Standard)                   1040
    'Italian (Swiss)                      2064
    'Japanese                             1041
    'Korean                               1042
    'Korean (Johab)                       2066
    'Dutch (Standard)                     1043
    'Dutch (Belgian)                      2067
    'Norwegian (Bokmal)                   1044
    'Norwegian (Nynorsk)                  2068
    'Polish                               1045
    'Portuguese (Brazil)                  1046
    'Portuguese (Portugal)                2070
    'Romanian                             1048
    'Russian                              1049
    'Croatian                             1050
    'Serbian (Latin)                      2074
    'Serbian (Cyrillic)                   3098
    'Slovak                               1051
    'Albanian                             1052
    'Swedish                              1053
    'Swedish (Finland)                    2077
    'Thai                                 1054
    'Turkish                              1055
    'Indonesian                           1057
    'Ukrainian                            1058
    'Belarusian                           1059
    'Slovenian                            1060
    'Estonian                             1061
    'Latvian                              1062
    'Lithuanian                           1063
    'Farsi                                1065
    'Vietnamese                           1066
    'Basque                               1069
    'Afrikaans                            1078
    'Faeroese                             1080

    'Dim langs As Variant
    'langs = [{1031, "de-de"; 2055, "de-ch"}]
    'langs = Array( _
    '        1031, "de-de" _
    '    )
    
    ' Default ist Englisch
    LCIDToLanguageCode = "en-gb"

    ' https://msdn.microsoft.com/en-us/library/ee825488(v=cs.20).aspx
    Select Case lcid
    Case 1031
        'German (Germany)
        LCIDToLanguageCode = "de-de"
    Case 2055
        'German (Swiss)
        LCIDToLanguageCode = "de-ch"
    Case 3079
        'German (Austrian)
        LCIDToLanguageCode = "de-at"
    Case 4103
        'German (Luxembourg)
        LCIDToLanguageCode = "de-lu"
    Case 5127
        'German (Liechtenstein)
        LCIDToLanguageCode = "de-li"
        
    Case 1033
        'English (United States)
        LCIDToLanguageCode = "en-us"
    Case 2057
        'English (United Kingdom)
        LCIDToLanguageCode = "en-gb"
    Case 3081
        'English (Australian)
        LCIDToLanguageCode = "en-au"
    Case 4105
        'English (Canadian)
        LCIDToLanguageCode = "en-ca"
    Case 5129
        'English (New Zealand)
        LCIDToLanguageCode = "en-nz"
    Case 6153
        'English (Ireland)
        LCIDToLanguageCode = "en-ie"
    Case 7177
        'English (South Africa)
        LCIDToLanguageCode = "en-za"
    Case 8201
        'English (Jamaica)
        LCIDToLanguageCode = "en-jm"
    Case 9225
        'English (Caribbean)
        LCIDToLanguageCode = "en-cb"
    Case 10249
        'English (Belize)
        LCIDToLanguageCode = "en-bz"
    Case 11273
        'English (Trinidad and Tobago)
        LCIDToLanguageCode = "en-tt"
    End Select
End Function

Private Function MapLCIDToInternalLanguage(lcid As Long) As String
    Dim langCulture As String
    langCulture = LCIDToLanguageCode(lcid)
    
    ' Alles was de-xy hat wird auf de-de abgebildet
    If Left(langCulture, 2) = "de" Then
        MapLCIDToInternalLanguage = LANG_DE_DE
    Else
        ' Alles andere wird en-gb
        MapLCIDToInternalLanguage = LANG_EN_GB
    End If
    
End Function

Public Function GetWindowsLanguageString() As String
    On Error GoTo nogo
    
    Dim ret As Long
    Dim loc As String
    Dim windowsLang As String
    
    loc = Space$(255)
    ret = GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SISO639LANGNAME, loc, 9)
    loc = Left$(loc, InStr(loc, Chr(0)) - 1)
    windowsLang = loc & "-"
    
    loc = Space$(255)
    ret = GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SISO3166CTRYNAME, loc, 9)
    loc = Left$(loc, InStr(loc, Chr(0)) - 1)
    windowsLang = windowsLang & loc
    
    GetWindowsLanguageString = LCase(windowsLang)
    Exit Function
nogo:
    GetWindowsLanguageString = "en-gb"
End Function

Private Function GetFallbackLanguage(lang As String) As String
    ' Alles was de-xy hat wird auf de-de abgebildet
    If Left(lang, 2) = "de" Then
        GetFallbackLanguage = LANG_DE_DE
    Else
        ' Alles andere wird en-gb
        GetFallbackLanguage = LANG_EN_GB
    End If
End Function







Attribute VB_Name = "TranslationHelpers"
Option Explicit

' Fallbacksprachen
' Regeln:
 '  File APP_en-xy.txt nicht da -> APP_en-gb.txt benutzen
 '  File APP_de-xy.txt nicht da -> APP_de-de.txt benutzen
 '  File APP_xy-uv.txt nicht da -> APP_en-gb.txt benutzen
Public Const LANG_EN_GB As String = "en-gb"
Public Const LANG_DE_DE As String = "de-de"

Public gTranslation As New Translation

Public Function InitTranslation(path As String, langFile As String, cfg As CfgReader) As Boolean
    InitTranslation = False
    Dim overrideLanguage As String
    If Not cfg Is Nothing Then
        If cfg.GetSection("GLOBALS") = True Then
            overrideLanguage = cfg.GetValue("LANGUAGE")
        End If
    End If
    If Not gTranslation.StartupInit(path, langFile, overrideLanguage) Then
        ' Sprachdateien wurden nicht geladen
        MsgBox FmtInternal("Missing language files ('%1_en-gb.txt')!" & vbCrLf & vbCrLf & "Die Sprachdateien wurden nicht gefunden ('%1_de-de.txt')!", langFile), vbCritical
        Exit Function
    End If
    InitTranslation = True
End Function

Public Function FMT0(f As String) As String
    FMT0 = FmtInternal(TR(f))
End Function

Public Function FMT1(f As String, _
                     ByVal arg1 As String) As String
    FMT1 = FmtInternal(TR(f), arg1)
End Function

Public Function FMT2(f As String, _
                     ByVal arg1 As String, _
                     ByVal arg2 As String) As String
    FMT2 = FmtInternal(TR(f), arg1, arg2)
End Function

Public Function FMT3(f As String, _
                     ByVal arg1 As String, _
                     ByVal arg2 As String, _
                     ByVal arg3 As String) As String
    FMT3 = FmtInternal(TR(f), arg1, arg2, arg3)
End Function

Public Function FMT4(f As String, _
                     ByVal arg1 As String, _
                     ByVal arg2 As String, _
                     ByVal arg3 As String, _
                     ByVal arg4 As String) As String
    FMT4 = FmtInternal(TR(f), arg1, arg2, arg3, arg4)
End Function

Public Function FMT5(f As String, _
                     ByVal arg1 As String, _
                     ByVal arg2 As String, _
                     ByVal arg3 As String, _
                     ByVal arg4 As String, _
                     ByVal arg5 As String) As String
    FMT5 = FmtInternal(TR(f), arg1, arg2, arg3, arg4, arg5)
End Function

Public Function GetTranslationString(id As String, fallback As String) As String
    If gTranslation.StringExists(id) Then
        GetTranslationString = gTranslation.GetString(id)
        Exit Function
    End If
    GetTranslationString = fallback
End Function

Public Function TR(id As String) As String
'    If gTranslation Is Nothing Then
'        TR = "gTranslation Not Initialized"
'        Exit Function
'    End If
    TR = gTranslation.GetString(id)
End Function

Public Function FmtInternal(f As String, _
                    Optional arg1 As String = vbNullChar, _
                    Optional arg2 As String = vbNullChar, _
                    Optional arg3 As String = vbNullChar, _
                    Optional arg4 As String = vbNullChar, _
                    Optional arg5 As String = vbNullChar, _
                    Optional arg6 As String = vbNullChar, _
                    Optional arg7 As String = vbNullChar, _
                    Optional arg8 As String = vbNullChar, _
                    Optional arg9 As String = vbNullChar _
                    ) As String
    FmtInternal = gTranslation.FormatString(f, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)
End Function

Public Function IsYes(s As String) As Boolean
  If UCase(s) = "JA" Or UCase(s) = "YES" Then
    IsYes = True
  End If
End Function

Public Function IsNo(s As String) As Boolean
  If UCase(s) = "NEIN" Or UCase(s) = "NO" Then
    IsNo = True
  End If
End Function

Public Function IsTrue(s As String) As Boolean
    If UCase(s) = "WAHR" Or UCase(s) = "TRUE" Then
        IsTrue = True
    End If
End Function

Public Function IsFalse(s As String) As Boolean
    If UCase(s) = "FALSCH" Or UCase(s) = "FALSE" Then
        IsFalse = True
    End If
End Function

Private Function MyWorksheetExists(ByRef wb, wsname As String) As Boolean
    On Error GoTo nogo
    Dim ws
    Set ws = wb.Worksheets(wsname)
    Set ws = Nothing
    MyWorksheetExists = True
    Exit Function
nogo:
End Function

Public Function TranslationSheetExists(ByRef wb As Workbook, names As Variant) As String
    On Error GoTo nogo
    Dim name As String
    If IsArray(names) Then
        Dim n As Variant
        For Each n In names
            name = CStr(n)
            If MyWorksheetExists(wb, name) Then
                TranslationSheetExists = name
                Exit Function
            End If
        Next n
        If UBound(names) >= 0 Then
            TranslationSheetExists = CStr(names(0))
            Exit Function
        End If
    Else
        name = CStr(names)
        If MyWorksheetExists(wb, name) Then
            TranslationSheetExists = name
            Exit Function
        End If
    End If
nogo:
    
End Function

' Das gleiche wie Cells.Find - aber probiert mehrere Strings zu finden (fuer mehrere Sprachen)
Public Function TranslationFindCells(ws As Worksheet, What As Variant, LookIn As Excel.XlFindLookIn, _
                                     LookAt As Excel.XlLookAt, SearchOrder As Excel.XlSearchOrder, _
                                     SearchDirection As Excel.XlSearchDirection, MatchCase As Boolean) As Range
  Set TranslationFindCells = Nothing
  Dim s As Variant
  For Each s In What
    Dim r As Range
    Set r = ws.Cells.Find(CStr(s), LookIn:=LookIn, LookAt:=LookAt, SearchOrder:=SearchOrder, SearchDirection:=SearchDirection, MatchCase:=MatchCase)
    If Not r Is Nothing Then
      Set TranslationFindCells = r
      Exit Function
    End If
  Next s
End Function

' This works because Debug.Print is omitted in the compiled code
Public Function InIDE() As Boolean
  On Error Resume Next
  Debug.Print 0 / 0
  InIDE = Err.Number <> 0
End Function



Attribute VB_Name = "UNC"
Option Explicit
    

' Fuer CacheMappedDrives()
'Dim mMappedDrives As Collection
Dim mMappedDrives(0 To 25) As String
Dim mUsedDriveLetters(0 To 25) As String
Dim mNumUsedDrives As Integer
    
#If VBA7 Then
Private Declare PtrSafe Function WNetGetConnectionA Lib "mpr.dll" ( _
  ByVal lpszLocalName As String, _
  ByVal lpszRemoteName As String, _
  cbRemoteName As Long) As Long
#Else
Private Declare Function WNetGetConnectionA Lib "mpr.dll" ( _
  ByVal lpszLocalName As String, _
  ByVal lpszRemoteName As String, _
  cbRemoteName As Long) As Long
#End If

Public Function GetUNCPath(ByVal sLocalPath As String) As String
    '// -----------------------------------------------------------------
    '// Methode:   | Konvertiert einen Pfad in UNC-Pfad (\\SERVER\...)
    '// -----------------------------------------------------------------
    '// Parameter: | sLocalPath = g|fffd|ltiger, lokaler Pfad (X:\..)
    '// -----------------------------------------------------------------
    '// R|fffd|ckgabe:  | bei Erfolg = UNC-Pfad
    '//            | bei Fehler = sLocalPath
    '// -----------------------------------------------------------------
    Const NO_ERROR As Long = 0
    Dim sUNCPath As String
    Dim sResult As String
    Dim sDrive As String

    On Error Resume Next
    GetUNCPath = sLocalPath
    If Mid$(sLocalPath, 2, 1) <> ":" Then Exit Function
    '// Die API-Funktion ben|fffd|tigt nur das Laufwerk!
    sDrive = Left$(sLocalPath, 2)
    sUNCPath = Space$(260)
    If WNetGetConnectionA(sDrive, sUNCPath, Len(sUNCPath)) = NO_ERROR Then
        sResult = Left$(sUNCPath, InStr(sUNCPath, vbNullChar) - 1)
        If Len(sResult) > 0 Then
            GetUNCPath = sResult & Mid$(sLocalPath, 3)
        End If
    End If

End Function

Public Sub CacheMappedDrives()
    mNumUsedDrives = 0
    Dim i As Integer
    For i = 65 To 90
        Dim strUNCPath As String
        strUNCPath = ""
        If GetUNCPathShort(Chr(i) & ":", strUNCPath) = 0 Then
            mMappedDrives(mNumUsedDrives) = UCase(strUNCPath)
            mUsedDriveLetters(mNumUsedDrives) = Chr(i)
            mNumUsedDrives = mNumUsedDrives + 1
        Else
        
        End If
    Next i
End Sub

' Wir nehmen an uncPath ist all upper case
Public Function GetCachedMappedDrive(uncPath As String) As String
    GetCachedMappedDrive = uncPath
    Dim i As Integer
    For i = 0 To mNumUsedDrives - 1
        If mMappedDrives(i) = Left$(uncPath, Len(mMappedDrives(i))) Then
            GetCachedMappedDrive = mUsedDriveLetters(i) & ":" & Mid$(uncPath, Len(mMappedDrives(i)) + 1)
            Exit For
        End If
    Next i
End Function

Function GetDriveAndPathFromUNC(ByVal strFullPath As String) As String

    If Mid(strFullPath, 2, 1) = ":" Then
      GetDriveAndPathFromUNC = strFullPath
      Exit Function
    End If

    Dim strUNC As String
    Dim i As Integer
    Dim s As String

    s = strFullPath

    For i = 65 To 90
        If GetUNCPathShort(Chr(i) & ":", strUNC) = 0 Then
            If UCase(strUNC) = UCase(Left(strFullPath, Len(strUNC))) Then
              If Len(Chr(i) & ":" & Mid(strFullPath, Len(strUNC) + 1, Len(strFullPath) - (Len(strUNC)))) < Len(s) Then
                s = Chr(i) & ":" & Mid(strFullPath, Len(strUNC) + 1, Len(strFullPath) - (Len(strUNC)))
              End If
            End If
        End If
    Next i
    
    GetDriveAndPathFromUNC = s
    
End Function


Function GetUNCPathShort(ByVal strDriveLetter As String, _
    ByRef strUNCPath As String) As Long
    On Local Error GoTo GetUNCPath_Err
    Dim strMsg As String
    Dim lngReturn As Long
    Dim strLocalName As String
    Dim strRemoteName As String
    Dim lngRemoteName As Long
    strLocalName = strDriveLetter
    strRemoteName = String$(255, Chr$(32))
    
    lngRemoteName = Len(strRemoteName)
    'Attempt to grab UNC
    lngReturn = WNetGetConnectionA(strLocalName, _
    strRemoteName, _
    lngRemoteName)


    If lngReturn = 0 Then
        
        'No problems - return the UNC
        'to the passed ByRef string
        GetUNCPathShort = 0
        
        
        ' only works for omni 2 build
        ' strUNCPath = LTrim(strRemoteName)
        ' strUNCPath = Left$(strUNCPath, Len(str
        '     UNCPath) - 1)
        
        
        ' less acurate potential for error if se
        '     rver or share contains spaces.
        
        If InStr(strRemoteName, Chr(0)) > 0 Then
          strUNCPath = Left(strRemoteName, InStr(strRemoteName, Chr(0)) - 1)
        Else
          strUNCPath = Mid(strRemoteName, 1, (InStr(1, strRemoteName, " ", 1)) - 2)
        End If
        
        
    Else
        'Problems - so return original
        'drive letter and error number
        GetUNCPathShort = lngReturn
        strUNCPath = strDriveLetter & "\"
    End If
GetUNCPath_End:
    Exit Function
GetUNCPath_Err:
    GetUNCPathShort = 1
    strUNCPath = strDriveLetter
    Resume GetUNCPath_End
End Function



Attribute VB_Name = "UnicodeFile"
Option Explicit

#If VBA7 And Win64 Then

  Private Declare PtrSafe Function MultiByteToWideChar Lib "Kernel32.dll" ( _
      ByVal codePage As Long, _
      ByVal dwFlags As Long, _
      ByVal lpMultiByteStr As LongPtr, _
      ByVal cbMultiByte As LongPtr, _
      ByVal lpWideCharStr As LongPtr, _
      ByVal cchWideChar As Long _
  ) As Long

  Private Declare PtrSafe Function WideCharToMultiByte Lib "kernel32" ( _
      ByVal codePage As Long, ByVal dwFlags As Long, _
      ByVal lpWideCharStr As LongPtr, ByVal cchWideChar As LongPtr, _
      ByVal lpMultiByteStr As LongPtr, ByVal cchMultiByte As LongPtr, _
      ByVal lpDefaultChar As LongPtr, ByVal lpUsedDefaultChar As LongPtr) As Long
        
#Else
  Private Declare Function MultiByteToWideChar Lib "Kernel32.dll" ( _
      ByVal codePage As Long, _
      ByVal dwFlags As Long, _
      ByVal lpMultiByteStr As Long, _
      ByVal cbMultiByte As Long, _
      ByVal lpWideCharStr As Long, _
      ByVal cchWideChar As Long _
  ) As Long
  
  Private Declare Function WideCharToMultiByte Lib "Kernel32.dll" ( _
      ByVal codePage As Long, _
      ByVal dwFlags As Long, _
      ByVal lpWideCharStr As Long, _
      ByVal cchWideChar As Long, _
      ByVal lpMultiByteStr As Long, _
      ByVal cbMultiByte As Long, _
      ByVal lpDefaultChar As Long, _
      ByVal lpUsedDefaultChar As Long _
  ) As Long
#End If

Public Const CP_ACP        As Long = 0          ' Default ANSI code page.
Public Const CP_UTF8       As Long = 65001      ' UTF8.
Public Const CP_UTF16_LE   As Long = 1200       ' UTF16 - little endian.
Public Const CP_UTF16_BE   As Long = 1201       ' UTF16 - big endian.
Public Const CP_UTF32_LE   As Long = 12000      ' UTF32 - little endian.
Public Const CP_UTF32_BE   As Long = 12001      ' UTF32 - big endian.

' Purpose:  Heuristic to determine whether bytes in a file are UTF-8.
Private Function FileBytesAreUTF8(ByVal the_iFileNo As Integer) As Boolean

    Const knSampleByteSize          As Long = 2048
    Dim nLof                        As Long
    Dim nByteCount                  As Long
    Dim nByteIndex                  As Long
    Dim nCharExtraByteCount         As Long
    Dim bytValue                    As Byte

    ' We look at the first <knSampleByteSize> bytes of the file. However, if the file is smaller, we will have to
    ' use the smaller size.
    nLof = LOF(the_iFileNo)
    If nLof < knSampleByteSize Then
        nByteCount = nLof
    Else
        nByteCount = knSampleByteSize
    End If

    ' Go to the start of the file.
    Seek #the_iFileNo, 1

    For nByteIndex = 1 To nByteCount

        Get #the_iFileNo, , bytValue

        ' If the character we are processing has bytes beyond 1, then we are onto the next character.
        If nCharExtraByteCount = 0 Then
            '
            ' The UTF-8 specification says that the first byte of a character has masking bits which indicate how many bytes follow.
            '
            ' See: http://en.wikipedia.org/wiki/UTF-8#Description
            '
            ' Bytes in
            ' sequence   Byte 1   Byte 2   Byte 3   Byte 4
            ' 1          0xxxxxxx
            ' 2          110xxxxx 10xxxxxx
            ' 3          1110xxxx 10xxxxxx 10xxxxxx
            ' 4          11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
            '
            If (bytValue And &H80) = &H0 Then
                nCharExtraByteCount = 0
            ElseIf (bytValue And &HE0) = &HC0 Then
                nCharExtraByteCount = 1
            ElseIf (bytValue And &HF0) = &HE0 Then
                nCharExtraByteCount = 2
            ElseIf (bytValue And &HF8) = &HF0 Then
                nCharExtraByteCount = 3
            Else
                ' If none of these masks were matched, then this can't be a UTF-8 character.
                FileBytesAreUTF8 = False
                Exit Function
            End If
        Else
            ' All following bytes must be masked as in the table above.
            If (bytValue And &HC0) = &H80 Then
                nCharExtraByteCount = nCharExtraByteCount - 1
                If nCharExtraByteCount = 0 Then
                    FileBytesAreUTF8 = True
                End If
            Else
                ' Not a UTF8 character.
                FileBytesAreUTF8 = False
                Exit Function
            End If
        End If

    Next nByteIndex

End Function

' Purpose:  Take a string whose bytes are in the byte array <the_abytCPString>, with code page <the_nCodePage>, convert to a VB string.
Private Function FromCPString(ByRef the_abytCPString() As Byte, ByVal the_nCodePage As Long) As String

    Dim sOutput                     As String
    Dim nValueLen                   As Long
    Dim nOutputCharLen              As Long

    ' If the code page says this is already compatible with the VB string, then just copy it into the string. No messing.
    If the_nCodePage = CP_UTF16_LE Then
        FromCPString = the_abytCPString()
    Else

        ' Cache the input length.
        nValueLen = UBound(the_abytCPString) - LBound(the_abytCPString) + 1

        ' See how big the output buffer will be.
        nOutputCharLen = MultiByteToWideChar(the_nCodePage, 0&, VarPtr(the_abytCPString(LBound(the_abytCPString))), nValueLen, 0&, 0&)

        ' Resize output byte array to the size of the UTF-8 string.
        sOutput = Space$(nOutputCharLen)

        ' Make this API call again, this time giving a pointer to the output byte array.
        MultiByteToWideChar the_nCodePage, 0&, VarPtr(the_abytCPString(LBound(the_abytCPString))), nValueLen, StrPtr(sOutput), nOutputCharLen

        ' Return the array.
        FromCPString = sOutput

    End If

End Function

Public Function GetContents(ByVal the_sTextFile As String, ByRef out_nCodePage As Long, Optional ByVal the_nDesiredCodePage As Long = -1, Optional ByRef out_bContainedBOM As Boolean) As String

    Dim iFileNo                     As Integer
    Dim abytFileContents()          As Byte
    Dim nDataSize                   As Long

    iFileNo = FreeFile

    OpenForInput the_sTextFile, iFileNo, out_nCodePage, the_nDesiredCodePage, out_bContainedBOM

    ' We want to read the entire contents of the file (not including any BOM value).
    ' After calling OpenForInput(), the file pointer should be positioned after any BOM.
    ' So size file contents buffer to <file size> - <current position> + 1.
    nDataSize = LOF(iFileNo) - Seek(iFileNo) + 1
    ReDim abytFileContents(1 To nDataSize)
    Get #iFileNo, , abytFileContents()

    Close iFileNo

    ' Now we must convert this to UTF-8. But we have to first convert to the Windows NT standard UTF-16 LE.
    GetContents = FromCPString(abytFileContents(), out_nCodePage)

End Function


' Diese Funktion ist langsam!!!!!!!!!!!!!

' Purpose:  Reads up to the end of the current line of the file, repositions to the beginning of the next line, if any, and
'           outputs all characters found.
' Inputs:   the_nFileNo     The number of the file.
' Outputs:  out_sLine       The line from the current position in the file.
' Return:   True if there is more data.
Public Function LineInputUTF8(ByVal the_nFileNo As Integer, ByRef out_sLine As String) As Boolean

    Dim bytValue            As Byte
    Dim abytLine()          As Byte
    Dim nStartOfLinePos     As Long
    Dim nEndOfLinePos       As Long
    Dim nStartOfNextLine    As Long
    Dim nLineLen            As Long

    ' Save the current file position as the beginning of the line, and cache this value.
    nStartOfLinePos = Seek(the_nFileNo)

    ' Retrieves the first byte from the current position.
    Get #the_nFileNo, , bytValue

    ' Loop until the end of file is encountered.
    Do Until EOF(the_nFileNo)

        ' Check whether this byte represents a carriage return or line feed character (indicating new line).
        If bytValue = 13 Or bytValue = 10 Then
            ' By this point, the current position is *after* the CR or LF character, so to get the position of the
            ' last byte in the line, we must go back two bytes.
            nEndOfLinePos = Seek(the_nFileNo) - 2

            ' If this is a carriage return, then we must check the next character.
            If bytValue = 13 Then
                Get #the_nFileNo, , bytValue
                ' Is this a line feed?
                If bytValue = 10 Then
                ' Yes. Assume that CR-LF counts as a single NewLine. So the start of the next line should skip over the line feed.
                    nStartOfNextLine = nEndOfLinePos + 3
                Else
                ' No. The start of the next line is the current position.
                    nStartOfNextLine = nEndOfLinePos + 2
                End If
            ElseIf bytValue = 10 Then
            ' If this is a line feed, then the start of the next line is the current position.
                nStartOfNextLine = nEndOfLinePos + 2
            End If

            ' Since we have processed all the bytes in the line, exit the loop.
            Exit Do
        End If

        ' Get the next byte.
        Get #the_nFileNo, , bytValue
    Loop

    ' Check to see if there was an end of line.
    If nEndOfLinePos = 0 Then
    ' No, this is the end of the file - so use all the remaining characters.
        nLineLen = Seek(the_nFileNo) - nStartOfLinePos - 1
    Else
    ' Yes - so use all the characters up to the end of line position.
        nLineLen = nEndOfLinePos - nStartOfLinePos + 1
    End If

    ' Is this line empty?
    If nLineLen = 0 Then
    ' Yes - just return an empty string.
        out_sLine = vbNullString
    Else
    ' No - pull all the bytes from the beginning to the end of the line into a byte array, and then convert that from UTF-8 to a VB string.
        ReDim abytLine(1 To nLineLen)
        Get #the_nFileNo, nStartOfLinePos, abytLine()
        out_sLine = FromCPString(abytLine(), CP_UTF8)
    End If

    ' If there is a line afterwards, then move to the beginning of the line, and return True.
    If nStartOfNextLine > 0 Then
        Seek #the_nFileNo, nStartOfNextLine
        LineInputUTF8 = True
    End If

End Function

' Purpose:  Analogue of 'Open "fileName" For Input As #fileNo' - but also return what type of text this is via a Code Page value.
' Inputs:   the_sFileName
'           the_iFileNo
'           (the_nDesiredCodePage)  The code page that you want to use with this file.
'                                   If this value is set to the default, -1, this indicates that the code page will be ascertained from the file.
' Outputs:  out_nCodePage           There are only six valid values that are returned if <the_nDesiredCodePage> was set to -1.
'               CP_ACP        ANSI code page
'               CP_UTF8       UTF-8
'               CP_UTF16LE    UTF-16 Little Endian (VB and NT default string encoding)
'               CP_UTF16BE    UTF-16 Big Endian
'               CP_UTF32LE    UTF-32 Little Endian
'               CP_UTF32BE    UTF-32 Big Endian
'           (out_bContainedBOM)     If this was set to True, then the file started with a BOM (Byte Order Marker).
Public Sub OpenForInput(ByRef the_sFilename As String, ByVal the_iFileNo As Integer, ByRef out_nCodePage As Long, Optional ByVal the_nDesiredCodePage As Long = -1, Optional ByRef out_bContainedBOM As Boolean)

    ' Note if we want to take account of every case, we should read in the first four bytes, and check for UTF-32 low and high endian BOMs, check
    ' the first three bytes for the UTF-8 BOM, and finally check the first two bytes for UTF-16 low and hight endian BOMs.
    Dim abytBOM(1 To 4)             As Byte
    Dim nCodePage                   As Long

    ' By default, there is no BOM.
    out_bContainedBOM = False

    Open the_sFilename For Binary Access Read As #the_iFileNo

    ' We are interested in -1 (ascertain code page), and then various UTF encodings.
    Select Case the_nDesiredCodePage
    Case -1, CP_UTF8, CP_UTF16_BE, CP_UTF16_LE, CP_UTF32_BE, CP_UTF32_LE

        ' Default code page.
        nCodePage = CP_ACP

        ' Pull in the first four bytes to determine the BOM (byte order marker).
        Get #the_iFileNo, , abytBOM()

        ' The following are the BOMs for text files:
        '
        ' FF FE         UTF-16, little endian
        ' FE FF         UTF-16, big endian
        ' EF BB BF      UTF-8
        ' FF FE 00 00   UTF-32, little endian
        ' 00 00 FE FF   UTF-32, big-endian
        '
        ' Work out the code page from this information.

        Select Case abytBOM(1)
        Case &HFF
            If abytBOM(2) = &HFE Then
                If abytBOM(3) = 0 And abytBOM(4) = 0 Then
                    nCodePage = CP_UTF32_LE
                Else
                    nCodePage = CP_UTF16_LE
                End If
            End If
        Case &HFE
            If abytBOM(2) = &HFF Then
                nCodePage = CP_UTF16_BE
            End If
        Case &HEF
            If abytBOM(2) = &HBB And abytBOM(3) = &HBF Then
                nCodePage = CP_UTF8
            End If
        Case &H0
            If abytBOM(2) = &H0 And abytBOM(3) = &HFE And abytBOM(4) = &HFF Then
                nCodePage = CP_UTF32_BE
            End If
        End Select

        ' Did we match any BOMs?
        If nCodePage = CP_ACP Then
        ' No - we are still defaulting to the ANSI code page.
            ' Special check for UTF-8. The BOM is not specified in the standard for UTF-8, but according to Wikipedia (which is always right :-) ),
            ' only Microsoft includes this marker at the beginning of files.
            If FileBytesAreUTF8(the_iFileNo) Then
                out_nCodePage = CP_UTF8
            Else
                out_nCodePage = CP_ACP
            End If
        Else
        ' Yes - we have worked out the code page from the BOM.
            ' If no code page was suggested, we now return the code page we found.
            If the_nDesiredCodePage = -1 Then
                out_nCodePage = nCodePage
            End If

            ' Inform the caller that a BOM was found.
            out_bContainedBOM = True
        End If

        ' Reset the file pointer to the beginning of the file data.
        If out_bContainedBOM Then
            ' Note that if the code page found was one of the two UTF-32 values, then we are already in the correct position.
            ' Otherwise, we have to move to just after the end of the BOM.
            Select Case nCodePage
            Case CP_UTF16_BE, CP_UTF16_LE
                Seek #the_iFileNo, 3
            Case CP_UTF8
                Seek #the_iFileNo, 4
            End Select
        Else
            ' There is no BOM, so simply go the beginning of the file.
            Seek #the_iFileNo, 1
        End If

    Case Else
        out_nCodePage = the_nDesiredCodePage
    End Select

End Sub

' Purpose:  Analogue of 'Open "fileName" For Append As #fileNo'
Public Sub OpenForAppend(ByRef the_sFilename As String, ByVal the_iFileNo As Integer, Optional ByVal the_nCodePage As Long = CP_ACP, Optional ByVal the_bPrefixWithBOM As Boolean = True)

    ' Open the file and move to the end of the file.
    Open the_sFilename For Binary Access Write As #the_iFileNo
    Seek the_iFileNo, LOF(the_iFileNo) + 1

    If the_bPrefixWithBOM Then
        WriteBOM the_iFileNo, the_nCodePage
    End If

End Sub

' Purpose:  Analogue of 'Open "fileName" For Output As #fileNo'
Public Sub OpenForOutput(ByRef the_sFilename As String, ByVal the_iFileNo As Integer, Optional ByVal the_nCodePage As Long = CP_ACP, Optional ByVal the_bPrefixWithBOM As Boolean = True)

    ' Ensure we overwrite the file by deleting it ...
    On Error Resume Next
    Kill the_sFilename
    On Error GoTo 0

    ' ... before creating it.
    Open the_sFilename For Binary Access Write As #the_iFileNo

    If the_bPrefixWithBOM Then
        WriteBOM the_iFileNo, the_nCodePage
    End If

End Sub

' Purpose:  Analogue of the 'Print #fileNo, value' statement. But only one value allowed.
'           Setting <the_bAppendNewLine> = False is analagous to 'Print #fileNo, value;'.
Public Sub Print_(ByVal the_iFileNo As Integer, ByRef the_sValue As String, Optional ByVal the_nCodePage As Long = CP_ACP, Optional ByVal the_bAppendNewLine As Boolean = True)

    Const kbytNull                  As Byte = 0
    Const kbytCarriageReturn        As Byte = 13
    Const kbytNewLine               As Byte = 10

    Put #the_iFileNo, , ToCPString(the_sValue, the_nCodePage)

    If the_bAppendNewLine Then
        Select Case the_nCodePage
        Case CP_UTF16_BE
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytCarriageReturn
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNewLine
        Case CP_UTF16_LE
            Put #the_iFileNo, , kbytCarriageReturn
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNewLine
            Put #the_iFileNo, , kbytNull
        Case CP_UTF32_BE
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytCarriageReturn
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNewLine
        Case CP_UTF32_LE
            Put #the_iFileNo, , kbytCarriageReturn
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNewLine
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNull
        Case Else
            Put #the_iFileNo, , kbytCarriageReturn
            Put #the_iFileNo, , kbytNewLine
        End Select
    End If

End Sub

Public Sub PutContents(ByRef the_sFilename As String, ByRef the_sFileContents As String, Optional ByVal the_nCodePage As Long = CP_ACP, Optional the_bPrefixWithBOM As Boolean)

    Dim iFileNo                     As Integer

    iFileNo = FreeFile
    OpenForOutput the_sFilename, iFileNo, the_nCodePage, the_bPrefixWithBOM
    Print_ iFileNo, the_sFileContents, the_nCodePage, False
    Close iFileNo

End Sub

' Purpose:  Converts a VB string (UTF-16) to UTF8 - as a binary array.
Private Function ToCPString(ByRef the_sValue As String, ByVal the_nCodePage As Long) As Byte()

    Dim abytOutput()                As Byte
    Dim nValueLen                   As Long
    Dim nOutputByteLen              As Long

    If the_nCodePage = CP_UTF16_LE Then
        ToCPString = the_sValue
    Else

        ' Cache the input length.
        nValueLen = Len(the_sValue)

        ' See how big the output buffer will be.
        nOutputByteLen = WideCharToMultiByte(the_nCodePage, 0&, StrPtr(the_sValue), nValueLen, 0&, 0&, 0&, 0&)

        If nOutputByteLen > 0 Then
            ' Resize output byte array to the size of the UTF-8 string.
            ReDim abytOutput(1 To nOutputByteLen)

            ' Make this API call again, this time giving a pointer to the output byte array.
            WideCharToMultiByte the_nCodePage, 0&, StrPtr(the_sValue), nValueLen, VarPtr(abytOutput(1)), nOutputByteLen, 0&, 0&
        End If

        ' Return the array.
        ToCPString = abytOutput()

    End If

End Function

Private Sub WriteBOM(ByVal the_iFileNo As Integer, ByVal the_nCodePage As Long)

    ' FF FE         UTF-16, little endian
    ' FE FF         UTF-16, big endian
    ' EF BB BF      UTF-8
    ' FF FE 00 00   UTF-32, little endian
    ' 00 00 FE FF   UTF-32, big-endian

    Select Case the_nCodePage
    Case CP_UTF8
        Put #the_iFileNo, , CByte(&HEF)
        Put #the_iFileNo, , CByte(&HBB)
        Put #the_iFileNo, , CByte(&HBF)
    Case CP_UTF16_LE
        Put #the_iFileNo, , CByte(&HFF)
        Put #the_iFileNo, , CByte(&HFE)
    Case CP_UTF16_BE
        Put #the_iFileNo, , CByte(&HFE)
        Put #the_iFileNo, , CByte(&HFF)
    Case CP_UTF32_LE
        Put #the_iFileNo, , CByte(&HFF)
        Put #the_iFileNo, , CByte(&HFE)
        Put #the_iFileNo, , CByte(&H0)
        Put #the_iFileNo, , CByte(&H0)
    Case CP_UTF32_BE
        Put #the_iFileNo, , CByte(&H0)
        Put #the_iFileNo, , CByte(&H0)
        Put #the_iFileNo, , CByte(&HFE)
        Put #the_iFileNo, , CByte(&HFF)
    End Select

End Sub





Attribute VB_Name = "Var"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False



Public m_Name As String
Public m_Type As String
Public m_Translation As String

Attribute VB_Name = "VarGroup"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False



Public m_Name As String
Public m_Vars As Collection
Public m_Type As String

Sub Init()
  Set m_Vars = New Collection
End Sub

Attribute VB_Name = "XLFld"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Public m_Name As String
Public m_Col As Collection

Public Sub Init(n As String)
  m_Name = n
  Set m_Col = New Collection
End Sub

Attribute VB_Name = "XLFldVal"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Public m_Value As Long
Public m_Txt As String


Attribute VB_Name = "XLForNext"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False



Public m_Name As String
Public m_Ref
Public m_Current As Long
Public m_Width As Long
Public m_WidthCurrent As Long
Attribute VB_Name = "XLScript"
Option Explicit

Public Beenden As Boolean

' Public m_LogY As Long
Private m_WS As Excel.Worksheet
Public m_Flds As Collection
Private m_FN As Collection
Private m_CodeStart As String
Private m_Log As Collection

Private m_SimpleVars As Collection
Private m_Vars As Collection
Private m_VarArray As Collection
Private m_VarArray2D As Collection
Private m_GlobalObjects As Collection

#Const USE_MDB = True
' #Const USE_XLS = True


#Const USE_LATE_BINDING_MDB = True
#Const USE_LATE_BINDING_XLS = False

#If USE_MDB = True Then
  Private m_ResultWorkbook As Excel.Workbook
#End If


#If USE_LATE_BINDING_MDB = True Then
  Public m_App As Object
  Public m_DB As Object
  Public m_Workspace As Object
#Else
  Public m_App As Access.Application
  Public m_DB As Database
  Public m_Workspace As Workspace
#End If

#If USE_LATE_BINDING_XLS = True Then
  Global m_Workbook As Object
  Global m_Excel As Object
#Else
  Global m_Workbook As Excel.Workbook
  Global m_Excel As Excel.Application
#End If

Public Const XLSCript_Debug As Boolean = False
Private m_InPrint As Boolean

Public m_AllVars As Collection

Private MyLastTime As Date

Public Function XLScriptCreateAccessApp(v As Long) As Object
  Set XLScriptCreateAccessApp = CreateObject("Access.Application." & v)
End Function

Public Function XLScriptCheckAccessVersion(v As Long) As Boolean
XLScriptCheckAccessVersion = False
On Error Resume Next
  Dim o As Object
  SaveSetting appname:="Stromwerken", Section:="AccessTracker", Key:="IgnoreThisOne", setting:="True"
  Set o = CreateObject("Access.Application." & v)
  If Not o Is Nothing Then
    XLScriptCheckAccessVersion = True
    o.CloseCurrentDatabase
    o.Quit
    Set o = Nothing
  End If
  SaveSetting appname:="Stromwerken", Section:="AccessTracker", Key:="IgnoreThisOne", setting:="False"
End Function

Public Sub XLScriptStore(fn As String)
  Dim ff As Integer
  ff = FreeFile
  Open fn For Output As #ff
    Dim item
    If m_VarArray2D.count > 0 Then
      For Each item In m_VarArray2D
        item.Store ff
      Next item
    End If
    If m_VarArray.count > 0 Then
      For Each item In m_VarArray
        item.Store ff
      Next item
    End If
    If m_Vars.count > 0 Then
      For Each item In m_Vars
        item.Store ff
      Next item
    End If
  Close #ff
End Sub

Public Sub XLScriptRegisterGlobalObject(n As String, o As Variant)
  
  On Error Resume Next
  m_GlobalObjects.Remove n
  
  Dim gob As XLScriptGlobalObject
  Set gob = New XLScriptGlobalObject
  gob.m_Name = n
  gob.m_Object = o
  m_GlobalObjects.Add gob, CStr(n)

End Sub

Public Function XLScriptGetGlobalObject(n As String) As Variant
  On Error GoTo NoObject
  Set XLScriptGetGlobalObject = Nothing
  Set XLScriptGetGlobalObject = m_GlobalObjects(n)
  
  Exit Function
NoObject:
  'If Not StartedByTracker Then MsgBox "ERROR: XLScriptGetGlobalObject: Object '" & n & "' not found!", vbCritical, "XLScript"
  If AR_UseDB = False Then MsgBox FMT1("XLSCRIPT_1", n), vbCritical, "XLScript"
End Function

Public Sub XLScriptInitDebug()
  If XLSCript_Debug = True Or AR_UseDB = True Then
    Set m_AllVars = New Collection
  End If
End Sub

Public Sub XLDumpNonprinted()
  If XLSCript_Debug Then
    Dim item
    For Each item In m_AllVars
      If Not item.m_WasPrinted Then
        Select Case TypeName(item)
          Case "XLScriptArray"
            Debug.Print TypeName(item), item.m_SortName
          Case "XLScriptArray2D"
            Debug.Print TypeName(item), item.m_SortName
          Case "XLScriptSimpleVar"
            Debug.Print TypeName(item), item.m_Txt, item.m_Value
          Case "XLScriptVar"
            Debug.Print TypeName(item), item.m_SortName
          Case Else
            Debug.Print "Unknown Type: " & TypeName(item)
        End Select
      End If
    Next item
  End If
End Sub

#If USE_MDB = True Then
Public Sub XLScriptInitGlobals(ByRef ex As Excel.Application, wb As Excel.Workbook)
  Set m_GlobalObjects = New Collection
  Set m_FN = New Collection
  Set m_Flds = New Collection
  Set m_VarArray2D = New Collection
  Set m_VarArray = New Collection
  Set m_Vars = New Collection
  Set m_SimpleVars = New Collection
  Set m_AllVars = New Collection
  Set m_ResultWorkbook = wb
  Set m_Excel = ex
End Sub
Public Sub XLScriptExitGlobals()
  Set m_FN = Nothing
  Set m_Flds = Nothing
  Set m_VarArray2D = Nothing
  Set m_VarArray = Nothing
  Set m_Vars = Nothing
  Set m_SimpleVars = Nothing
  Set m_GlobalObjects = Nothing
  Set m_Excel = Nothing
  Set m_ResultWorkbook = Nothing
End Sub

#Else
Public Sub XLScriptInitGlobals()
'  If m_LogY <= 0 Then m_LogY = 1
  Set m_GlobalObjects = New Collection
  Set m_FN = New Collection
  Set m_Flds = New Collection
  Set m_VarArray2D = New Collection
  Set m_VarArray = New Collection
  Set m_Vars = New Collection
  Set m_SimpleVars = New Collection
  Set m_Log = New Collection
End Sub

Public Sub XLScriptExitGlobals()
  Set m_FN = Nothing
  Set m_Flds = Nothing
  Set m_VarArray2D = Nothing
  Set m_VarArray = Nothing
  Set m_Vars = Nothing
  Set m_SimpleVars = Nothing
  Set m_Log = Nothing
  Set m_GlobalObjects = Nothing
End Sub
#End If
Public Sub XLScriptInit(ByRef ws As Excel.Worksheet, passstring As String)
  Set m_WS = ws
  m_WS.Activate
  m_CodeStart = "<!" & passstring & " "
End Sub
Public Sub XLScriptExit()
  Set m_WS = Nothing
End Sub

Public Function XLScriptCreateArray2D(n As String) As XLScriptArray2D
  Dim da As XLScriptArray2D
  Set da = New XLScriptArray2D
  da.Init n
  Set XLScriptCreateArray2D = da
  
End Function

Public Function XLScriptAddArray2D(n As String) As XLScriptArray2D
  Dim da As XLScriptArray2D
  Set da = XLScriptCreateArray2D(n)
  m_VarArray2D.Add da, CStr(n)
  Set XLScriptAddArray2D = da

  If XLSCript_Debug = True Or AR_UseDB = True Then
    If Not m_AllVars Is Nothing Then m_AllVars.Add da
  End If
End Function

Public Function XLScriptAddArray(n As String) As XLScriptArray
  Dim da As XLScriptArray
  Set da = New XLScriptArray
  da.Init n
  m_VarArray.Add da, CStr(n)
  Set XLScriptAddArray = da

  If XLSCript_Debug = True Or AR_UseDB = True Then
    If Not m_AllVars Is Nothing Then m_AllVars.Add da
  End If
End Function

Public Function XLScriptGetArray(n As String) As XLScriptArray
On Error GoTo notFound
  Set XLScriptGetArray = Nothing
  Set XLScriptGetArray = m_VarArray(CStr(n))
  Exit Function
notFound:
  'If Not StartedByTracker Then MsgBox "ERROR: XLScriptGetArray: Array '" & n & "' not found!", vbCritical, "XLScript"
  If Not AR_UseDB Then MsgBox FMT1("XLSCRIPT_2", n), vbCritical, "XLScript"
End Function

Public Function XLScriptGetArray2D(n As String) As XLScriptArray2D
On Error GoTo notFound
  Set XLScriptGetArray2D = Nothing
  Set XLScriptGetArray2D = m_VarArray2D(CStr(n))
  Exit Function
notFound:
  'If Not StartedByTracker Then MsgBox "ERROR: XLScriptGetArray2D: Array '" & n & "' not found!", vbCritical, "XLScript"
  If Not AR_UseDB Then MsgBox FMT1("XLSCRIPT_3", n), vbCritical, "XLScript"
End Function


Public Function XLScriptAddVar(n As String) As XLScriptVar
  Dim da As XLScriptVar
  Set da = New XLScriptVar
  da.Init n
  m_Vars.Add da, CStr(n)
  Set XLScriptAddVar = da
  
  If XLSCript_Debug = True Or AR_UseDB = True Then
    If Not m_AllVars Is Nothing Then m_AllVars.Add da
  End If
End Function

Public Function XLScriptAddSimpleVar(n As String, v) As XLScriptSimpleVar
  Dim da As XLScriptSimpleVar
  
  If ObjectNameExists(m_SimpleVars, n) Then
    m_SimpleVars.Remove n
  End If
  
  Set da = New XLScriptSimpleVar
  da.m_Txt = n
  da.m_Value = CStr(v)
  m_SimpleVars.Add da, CStr(n)
  Set XLScriptAddSimpleVar = da

  If XLSCript_Debug = True Or AR_UseDB = True Then
    If Not m_AllVars Is Nothing Then m_AllVars.Add da
  End If
End Function

Public Function XLScriptGetSimpleVar(n As String) As XLScriptSimpleVar
  Set XLScriptGetSimpleVar = Nothing
  On Error Resume Next
  Set XLScriptGetSimpleVar = m_SimpleVars(n)
End Function

' Public Sub XLScriptSetValues(c As Collection, ByRef rng As Range)
'   Dim item
'   For Each item In c
'     SetValue rng, item.m_Txt, CStr(item.m_Value)
'   Next item
' End Sub

' Private Sub SetValue(ByRef rng As Range, varTag As String, cellVal As String)
'   On Error GoTo 0
'   Dim c
'   Do
'     Set c = rng.Find(What:="<<" & varTag & ">>", LookIn:=xlValues, LookAt:= _
'           xlPart, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=True)
'     If Not c Is Nothing Then
'       c.Value = MyReplace(c.Value, "<<" & varTag & ">>", cellVal)
'     End If
'   Loop While Not c Is Nothing
'   Do
'     Set c = rng.Find(What:="__" & varTag & "__", LookIn:=xlFormulas, LookAt:= _
'           xlPart, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=True)
'     If Not c Is Nothing Then
'       c.Formula = MyReplace(c.Formula, "__" & varTag & "__", cellVal)
'     End If
'   Loop While Not c Is Nothing
' End Sub

Private Function MyReplace(txt As String, searchtxt As String, replacetxt As String, Optional checkStartAndEnd As Boolean = False, Optional ignoreIn As String = "") As String
  Dim txtPos As Long
  Dim tStringRep As String
  Dim res As String
  Dim ok As Boolean
  MyReplace = txt
  If InStr(txt, searchtxt) = 0 Then Exit Function
  Dim inIgnore As Boolean
  
  inIgnore = False
  
  For txtPos = 1 To Len(txt)
    If Len(ignoreIn) > 0 Then
      If Mid(txt, txtPos, Len(ignoreIn)) = ignoreIn Then
        If Not inIgnore Then
          inIgnore = True
        Else
          inIgnore = False
        End If
      End If
    End If
    
    If Not inIgnore Then
      If Mid(txt, txtPos, Len(searchtxt)) = searchtxt Then
        ok = True
        Dim tval As String
        If checkStartAndEnd Then
          If txtPos > 1 Then
            tval = Mid(txt, txtPos - 1, 1)
            If (tval >= "a" And tval <= "z") Or _
               (tval >= "A" And tval <= "Z") Or _
               (tval >= "0" And tval <= "9") Or _
               tval = "_" Then
                ok = False
            End If
          End If
          If txtPos + Len(searchtxt) <= Len(txt) Then
            tval = Mid(txt, txtPos + Len(searchtxt), 1)
            If (tval >= "a" And tval <= "z") Or _
               (tval >= "A" And tval <= "Z") Or _
               (tval >= "0" And tval <= "9") Or _
               tval = "_" Then
                ok = False
            End If
          End If
        End If
        If ok Then
          res = res + replacetxt
          txtPos = txtPos + Len(searchtxt) - 1
        Else
          res = res + Mid(txt, txtPos, 1)
        End If
      Else
        res = res + Mid(txt, txtPos, 1)
      End If
    Else
      res = res + Mid(txt, txtPos, 1)
    End If
  Next txtPos
  MyReplace = res
End Function

Sub XLScriptCleanUpTags(rng As Range)
'  On Error GoTo 0
  
  Dim c As Range
  Do
    Set c = rng.Find(What:="<!? INSERTLINEABOVE", LookIn:=xlValues, LookAt:= _
      xlPart, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=False)
    If c Is Nothing Then Exit Do
    c.Parent.Rows(c.Row).Delete Shift:=xlUp
  Loop
  
  Do
    Set c = rng.Find(What:="<!? PB", LookIn:=xlValues, LookAt:= _
      xlPart, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=False)
    If c Is Nothing Then Exit Do
    c.Delete Shift:=xlUp
  Loop
End Sub


Function XLScriptExecCode(rng As Range, reclevel As Long, rightoffset As Long) As Long
  Dim addedLines As Long
  addedLines = 0
  
  On Error GoTo 0
  Dim c As Range
  Dim tstring As String
  Dim tleft As String
  Dim tRight As String
  Set c = Nothing
  
  Dim firstC As Range
  Set firstC = Nothing
  Dim nextC As Range
  
  Do
    
'    Cells.Find(What:=m_CodeStart, After:=ActiveCell, LookIn:=xlValues, LookAt:= _
'        xlPart, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=True, _
'        SearchFormat:=False).Activate
    
    If GetRangeCount(rng) = 1 Then
      If InStr(rng.value, m_CodeStart) > 0 Then
        Set c = rng
      Else
        Set c = Nothing
      End If
    Else
      
      ' Erste gefundene Zelle abfragen
      If Not c Is Nothing And IsValid(c) And Not firstC Is Nothing And IsValid(firstC) = True Then
        If firstC.Row = c.Row And firstC.Column = c.Column Then
          Set c = Nothing
        End If
      ElseIf c Is Nothing Or Not IsValid(c) Then
        Set c = rng.Find(What:=m_CodeStart, LookIn:=xlValues, LookAt:= _
              xlPart, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=True)
        ' Erste gefundene Zelle speichern
        If Not c Is Nothing And firstC Is Nothing Then
          Set firstC = c
        End If
      Else
        Exit Do
      End If
    End If
    
    If Not c Is Nothing And IsValid(c) Then
    
      Set nextC = rng.FindNext(c)
        
      Dim pos As Long
      Dim pos2 As Long
      pos = 0
      ' ---------------------------------------------------
      
      Do
        
        If c Is Nothing Then Exit Do
        If Not IsValid(c) Then Exit Do
        
        pos = InStr(pos + 1, c.value, m_CodeStart)
        If pos = 0 Then Exit Do
        
        pos2 = InStr(pos, c.value, "!>")
        
        Dim codeVal As String
        Dim code As String
        If pos2 > 0 Then
          code = Mid(c.value, pos + Len(m_CodeStart), pos2 - pos - Len(m_CodeStart))
        Else
          code = Mid(c.value, pos + Len(m_CodeStart))
        End If
        
        codeVal = code
        
        Dim newcellval As String
        newcellval = ""
        
        Dim dontdeleteentry As Boolean
        dontdeleteentry = False
        
        Do
          Dim tok As String
          tok = GetToken(codeVal)
          If Len(tok) > 0 Then
            Select Case UCase(tok)
              Case "ADDRIGHT"
                tstring = GetExpression(codeVal, c)
                c.Parent.Cells(c.Row, c.Column + 1).value = _
                  c.Parent.Cells(c.Row, c.Column + 1).value + _
                  Val(MyReplace(tstring, ",", "."))
                  
              Case "INSERTLINEABOVE"
                If firstC.Row = c.Row Then
                  Set firstC = c.Parent.Cells(c.Row + 1, c.Column)
                End If
                m_WS.Rows(c.Row).Insert
                c.value = ""
                Set c = c.Parent.Cells(c.Row + 1, c.Column)
                dontdeleteentry = True
              Case "BACKCOL"
                tstring = GetExpression(codeVal, c)
                
                If IsNumeric(tstring) Then
                  c.Interior.Color = Val(tstring)
                End If
                
              Case "P"
                newcellval = DoPrint(codeVal, c, rightoffset)
              
              Case "PB"
                DoPrintBelow codeVal, c, rightoffset
                dontdeleteentry = True
              
              Case "PRINTBITFIELD"
                DoPrintBitfield codeVal, c
                dontdeleteentry = True
              
              Case "PRINTACCESSCONTAINER"
                PrintAccessContainer c.Parent, c

              Case "FOR"
                addedLines = addedLines + DoFor(codeVal, c, rng, reclevel + 1)
                If GetSetting(appname:="Stromwerken", Section:=ProgNameShort, Key:="AbortAction", Default:="") <> "" Then
                  SaveSetting appname:="Stromwerken", Section:="ACC", Key:="AbortAction", setting:=""
                  Beenden = True
                End If
                If Beenden Then Exit Function
              
              Case "LFOR"
                addedLines = addedLines + DoLFor(codeVal, c, rng, reclevel + 1)
                If GetSetting(appname:="Stromwerken", Section:=ProgNameShort, Key:="AbortAction", Default:="") <> "" Then
                  SaveSetting appname:="Stromwerken", Section:="ACC", Key:="AbortAction", setting:=""
                  Beenden = True
                End If
                If Beenden Then Exit Function
              
              Case "ROWAUTOFIT"
                c.Parent.Cells.EntireRow.AutoFit
              
              Case "COLUMNAUTOFIT"
                c.Parent.Cells.EntireColumn.AutoFit
              
              Case "DEBUG"
                Err.Raise vbObjectError + 1, "XLScript", "DEBUG forced by XLScript"
                Debug.Print "Debug forced"
              
              Case "DIAGDATA"
                addedLines = addedLines - 2
                DoDiagData codeVal, c, rng
                
              Case "PRINTTABELLEN"
                PrintTabellen m_WS, c.Row, c.Column
                dontdeleteentry = True
              
              Case Else
                'XLScriptAddLogEntry "Error: Unknown command '" & tok & "' in '" & code & "'! " & m_WS.name & "!" & c.Address & " Value: " & c.value
                XLScriptAddLogEntry FMT5("XLSCRIPT_4", tok, code, m_WS.name, c.Address, c.value)
                'MsgBox "Error: Unknown command '" & tok & "' in '" & code & "'! " & m_WS.name & "!" & c.Address & " Value: " & c.value, vbCritical, "XLScript"
                MsgBox FMT5("XLSCRIPT_4", tok, code, m_WS.name, c.Address, c.value), vbCritical, "XLScript"
                Beenden = True
                Exit Function
            
            End Select
          End If
        Loop While tok <> ""
        
        ' Und jetzt den neuen Zellwert in die Zelle schreiben
        Dim l As String
        Dim r As String
        
        l = ""
        If pos > 1 Then
          l = Left(c.value, pos - 1)
        End If
        
        r = ""
        If pos2 > 0 Then
          If pos + 2 < Len(c.value) Then
            r = Mid(c.value, pos2 + 2)
          End If
        End If
        
        If dontdeleteentry = False Then
          If Not c Is Nothing Then
            If IsValid(c) Then
          
              If IsNumeric(MyReplace(l & newcellval & r, ",", ".")) Then
                c.value = Val(MyReplace(l & newcellval & r, ",", "."))
              ElseIf IsDate(l & newcellval & r) Then
                c.value = CDate(l & newcellval & r)
              Else
                c.value = l & newcellval & r
              End If
              pos = Len(l & newcellval) - 1
              If pos < 0 Then pos = 0
            End If
          End If
        End If
      Loop
      
    End If
  
    If Not GetRangeCount(rng) = 1 And Not c Is Nothing Then
      Set c = nextC
    End If
  
  Loop While Not c Is Nothing
  
  XLScriptExecCode = addedLines
End Function

Private Sub OverreadLine(ByRef codeValRet As String)
  On Error GoTo 0
  Dim i As Long
  i = 1
  Do While i < Len(codeValRet) And Mid(codeValRet, i, 1) <> vbCr And Mid(codeValRet, i, 1) <> vbLf
    i = i + 1
  Loop
  Do While i < Len(codeValRet) And (Mid(codeValRet, i, 1) = vbCr Or Mid(codeValRet, i, 1) = vbLf)
    i = i + 1
  Loop
  If i > 1 Then
    codeValRet = Mid(codeValRet, i)
  End If
End Sub

Private Sub OverreadBlanks(ByRef codeValRet As String)
  On Error GoTo 0
  Dim i As Long
  i = 1
  Do While Mid(codeValRet, i, 1) = " " Or Mid(codeValRet, i, 1) = vbCr Or Mid(codeValRet, i, 1) = vbLf
    i = i + 1
  Loop
  If i > 1 Then
    codeValRet = Mid(codeValRet, i)
  End If
End Sub

Private Sub GetComma(ByRef codeValRet As String, ByRef c As Range)
  On Error GoTo 0
  OverreadBlanks codeValRet
  If Left(codeValRet, 1) <> "," Then
    'XLScriptAddLogEntry "Error: Missing comma! " & m_WS.name & "!" & c.Address & " Value: " & c.value
    XLScriptAddLogEntry FMT3("XLSCRIPT_5", m_WS.name, c.Address, c.value)
  End If
  codeValRet = Mid(codeValRet, 2)
End Sub

Private Function GetDef(ByRef codeValRet As String, ByRef c As Range) As XLFld
  On Error GoTo 0
  OverreadBlanks codeValRet
  
  Dim tok As String
  tok = GetToken(codeValRet)
  
  Dim item As XLFld
  If m_Flds.count > 0 Then
    For Each item In m_Flds
      If item.m_Name = tok Then
        Set GetDef = item
        Exit Function
      End If
    Next item
  End If
  
  'XLScriptAddLogEntry "Error: Undefined Def '" & tok & "'! " & m_WS.name & "!" & c.Address & " Value: " & c.value
  XLScriptAddLogEntry FMT4("XLSCRIPT_6", tok, m_WS.name, c.Address, c.value)
End Function

Private Function GetNumber(ByRef codeValRet As String) As String
  On Error GoTo 0
  Dim token As String
  Dim i As Long
  i = 0
  OverreadBlanks codeValRet
  
  Do While ((Mid(codeValRet, i + 1, 1) >= "0" And Mid(codeValRet, i + 1, 1) <= "9") Or _
    (Mid(codeValRet, i + 1, 1) = ".")) And i < Len(codeValRet)
    i = i + 1
  Loop
  If i > 0 Then
    token = Left(codeValRet, i)
    codeValRet = Mid(codeValRet, i + 1)
    OverreadBlanks codeValRet
  End If
  
  GetNumber = token
End Function

Private Function GetLine(ByRef codeValRet As String) As String
  On Error GoTo 0
  OverreadBlanks codeValRet
  Dim i As Long
  i = 0
  Do While i < Len(codeValRet) - 1 And Mid(codeValRet, i + 1, 1) <> vbCr And Mid(codeValRet, i + 1, 1) <> vbLf
    i = i + 1
  Loop
  If i > 0 Then
    GetLine = Left(codeValRet, i)
    codeValRet = Mid(codeValRet, i + 1)
  End If
End Function

Private Function GetNextChar(ByRef codeValRet As String) As String
  On Error GoTo 0
  OverreadBlanks codeValRet
  If Len(codeValRet) > 0 Then
    GetNextChar = Left(codeValRet, 1)
    codeValRet = Mid(codeValRet, 2)
  End If
End Function

Function GetString(ByRef codeValRet As String) As String
  On Error GoTo 0
  Dim token As String
  Dim i As Long
  i = 0
  OverreadBlanks codeValRet
  If Left(codeValRet, 1) = Chr(34) Then
    codeValRet = Mid(codeValRet, 2)
    Do While Mid(codeValRet, i + 1, 1) <> Chr(34) And i < Len(codeValRet)
      i = i + 1
    Loop
    If i > 0 Then
      token = Left(codeValRet, i)
      codeValRet = Mid(codeValRet, i + 1)
      If Left(codeValRet, 1) = Chr(34) Then
        codeValRet = Mid(codeValRet, 2)
      End If
      OverreadBlanks codeValRet
    End If
  End If
  
  GetString = token
End Function


Private Function GetToken(ByRef codeValRet As String) As String
  On Error GoTo 0
  Dim token As String
  Dim i As Long
  i = 0
  OverreadBlanks codeValRet
  If Left(codeValRet, 1) = Chr(34) Then
    codeValRet = Mid(codeValRet, 2)
    Do While Mid(codeValRet, i + 1, 1) <> Chr(34) And i < Len(codeValRet)
      i = i + 1
    Loop
    If i > 0 Then
      token = Left(codeValRet, i)
      codeValRet = Mid(codeValRet, i + 1)
      If Left(codeValRet, 1) = Chr(34) Then
        codeValRet = Mid(codeValRet, 2)
      End If
      OverreadBlanks codeValRet
    End If
  Else
    If ((Mid(codeValRet, i + 1, 1) >= "a" And Mid(codeValRet, i + 1, 1) <= "z") Or _
      (Mid(codeValRet, i + 1, 1) >= "A" And Mid(codeValRet, i + 1, 1) <= "Z")) And i < Len(codeValRet) Then
      Do While ((Mid(codeValRet, i + 1, 1) >= "a" And Mid(codeValRet, i + 1, 1) <= "z") Or _
        (Mid(codeValRet, i + 1, 1) >= "A" And Mid(codeValRet, i + 1, 1) <= "Z") Or _
        (Mid(codeValRet, i + 1, 1) >= "0" And Mid(codeValRet, i + 1, 1) <= "9") Or _
         Mid(codeValRet, i + 1, 1) = "_" Or _
         Mid(codeValRet, i + 1, 1) = "|fffd|" Or _
         Mid(codeValRet, i + 1, 1) = "|fffd|" Or _
         Mid(codeValRet, i + 1, 1) = "|fffd|" Or _
         Mid(codeValRet, i + 1, 1) = "|fffd|" Or _
         Mid(codeValRet, i + 1, 1) = "|fffd|" Or _
         Mid(codeValRet, i + 1, 1) = "|fffd|" Or _
         Mid(codeValRet, i + 1, 1) = "|fffd|" _
         ) And i < Len(codeValRet)
        i = i + 1
      Loop
      If i > 0 Then
        token = Left(codeValRet, i)
        codeValRet = Mid(codeValRet, i + 1)
        OverreadBlanks codeValRet
      End If
    Else
      token = GetNextChar(codeValRet)
    End If
  End If
  
  GetToken = token
End Function

Private Function DoPrint(ByRef codeValRet As String, ByRef c As Range, Optional rightoffset As Long = 0) As String
  On Error GoTo 0
  Dim res As String
  m_InPrint = True
  
  CheckSubParams codeValRet, c
  
  res = GetExpression(codeValRet, c)
  m_InPrint = False
  If res = "" Then
    DoPrint = "'-/-"
'    c.Parent.Cells(c.Row, c.Column + rightoffset).Value = "'-/-"
'    XLScriptAddLogEntry "Error: PRINT missing expression! " & m_WS.name & "!" & c.Address & " Value: " & c.Value
    Exit Function
  End If
  
  DoPrint = res
'  c.Parent.Cells(c.Row, c.Column + rightoffset).Value = res
End Function

Private Sub DoPrintBelow(ByRef codeValRet As String, ByRef c As Range, Optional rightoffset As Long = 0)
  On Error GoTo 0
  Dim res As String
  
  Dim y As Long
  y = c.Row + 1
  Do While Not IsEmpty(m_WS.Cells(y, c.Column))
    y = y + 50
  Loop
  
  If y > 1 Then
    Do While IsEmpty(m_WS.Cells(y, c.Column))
      y = y - 1
    Loop
    y = y + 1
  End If
  
'  Debug.Print codeValRet
  CheckSubParams codeValRet, m_WS.Cells(y, c.Column)
  
  res = GetExpression(codeValRet, c)
  
  If res = "" Then
    m_WS.Cells(y, c.Column).value = "'-/-"
    Exit Sub
  End If
  
  If IsFullyNumeric(MyReplace(res, ",", ".")) Then
    m_WS.Cells(y, c.Column).value = Val(MyReplace(res, ",", "."))
  Else
    m_WS.Cells(y, c.Column).value = res
  End If
'  m_WS.Cells(y, c.Column).NumberFormat = c.NumberFormat
'  m_WS.Cells(y, c.Column).Interior.Color = c.Interior.Color
'  m_WS.Cells(y, c.Column).Font.Color = c.Font.Color
End Sub

Sub CheckSubParams(ByRef codeValRet As String, ByRef c As Range)
  Dim s As String
  If Left(codeValRet, 1) <> "(" Then Exit Sub
  codeValRet = Mid(codeValRet, 2)
  s = GetToken(codeValRet)
  Select Case s
    Case "BC"
      If Left(codeValRet, 1) <> ":" Then
        'XLScriptAddLogEntry "BC must be followed by ':' in " & m_WS.name & "!" & c.Address & " Value: " & c.value
        XLScriptAddLogEntry FMT3("XLSCRIPT_7", m_WS.name, c.Address, c.value)
        Exit Sub
      End If
      codeValRet = Mid(codeValRet, 2)
      s = GetExpression(codeValRet, c)
      If IsNumeric(s) Then
        c.Interior.Color = Val(s)
      Else
        c.Interior.Color = RGB(255, 255, 255)
      End If
      If Left(codeValRet, 1) <> ")" Then
        'XLScriptAddLogEntry "Sub param must be followed by ')' or ';' in " & m_WS.name & "!" & c.Address & " Value: " & c.value
        XLScriptAddLogEntry FMT3("XLSCRIPT_8", m_WS.name, c.Address, c.value)
        Exit Sub
      End If
      codeValRet = Mid(codeValRet, 2)
      OverreadBlanks codeValRet
  End Select
End Sub


Public Sub DoPrintBitfield(ByRef codeValRet As String, ByRef c As Range)
  On Error GoTo 0
  Dim res As String
  Dim tCodeValRet As String
  tCodeValRet = codeValRet
  res = GetExpression(codeValRet, c)
  
  If res = "" Then
    'XLScriptAddLogEntry "Error: Expression not found (" & tCodeValRet & ")! " & m_WS.name & "!" & c.Address & " Value: " & c.value
    XLScriptAddLogEntry FMT4("XLSCRIPT_9", tCodeValRet, m_WS.name, c.Address, c.value)
  End If
  GetComma codeValRet, c
  
  Dim f As XLFld
  Set f = GetDef(codeValRet, c)
  GetComma codeValRet, c
  
  Dim sep As String
  sep = GetExpression(codeValRet, c)
  
  Dim onlyExistant As Boolean
  onlyExistant = True
  
  Dim foundone As Boolean
  foundone = False
  c.value = ""
  Dim item As XLFldVal
  
  Dim cnt As Long
  Dim x As Long
  Dim rv As String
  Dim first As Boolean
  first = False
  x = &H80000000
  
  If Not onlyExistant Then
    c.value = "0x" & Hex(CLng(res)) & " (" & res & ")"
  End If
  
  Dim i As Long
  
  For cnt = 1 To 32
    If (res And x) <> 0 Then
    
      foundone = False
      For Each item In f.m_Col
        If x = item.m_Value Then
          foundone = True
          If Len(c.value) > 0 Then
            For i = 1 To Len(sep)
              If Mid(sep, i, 1) = "n" Then
                c.value = c.value & vbLf
              Else
                c.value = c.value & Mid(sep, i, 1)
              End If
            Next i
          End If
          
          If onlyExistant Then
            c.value = c.value & item.m_Txt
          Else
            c.value = c.value & "0x" & Hex(item.m_Value) & " - " & item.m_Txt
          End If
          
        End If
      Next item
      
      If Not onlyExistant Then
        If Not foundone Then
          If Len(c.value) > 0 Then
            For i = 1 To Len(sep)
              If Mid(sep, i, 1) = "n" Then
                c.value = c.value & vbLf
              Else
                c.value = c.value & Mid(sep, i, 1)
              End If
            Next i
          End If
          
          c.value = c.value & "0x" & Hex(x) & " - ???"
        End If
      End If
    End If
    x = x / 2
    If x < 0 Then x = x * (-1)
  Next cnt
  If Len(c.value) = 0 Then
   c.value = "'-"
  End If
'  If Not foundOne Then c.Value = res
End Sub

Function GetBitfieldResult(ByRef f As XLFld, ByVal res As String, ByVal sep As String) As String
  Dim foundone As Boolean
  foundone = False
  Dim item As XLFldVal
  
  Dim cnt As Long
  Dim x As Long
  Dim rv As String
  Dim first As Boolean
  first = False
  x = &H80000000
  
  Dim i As Long
  For cnt = 1 To 32
    If (res And x) <> 0 Then
    
      foundone = False
      For Each item In f.m_Col
        If x = item.m_Value Then
          foundone = True
          If Len(GetBitfieldResult) > 0 Then
            For i = 1 To Len(sep)
              If Mid(sep, i, 1) = "n" Then
                GetBitfieldResult = GetBitfieldResult & vbLf
              Else
                GetBitfieldResult = GetBitfieldResult & Mid(sep, i, 1)
              End If
            Next i
          End If
          
          GetBitfieldResult = GetBitfieldResult & item.m_Txt
        End If
      Next item
      
    End If
    x = x / 2
    If x < 0 Then x = x * (-1)
  Next cnt
  If Len(GetBitfieldResult) = 0 Then
   GetBitfieldResult = "'-"
  End If

End Function

Public Sub DoPrintBitfieldExt(att As String, bitfieldname As String, sep As String, ByRef c As Range)
  On Error GoTo 0
  Dim res As String
  res = att
  
  Dim f As XLFld
  Set f = GetDef(bitfieldname, c)
  
  Dim onlyExistant As Boolean
  onlyExistant = True
  
  Dim foundone As Boolean
  foundone = False
  c.value = ""
  Dim item As XLFldVal
  
  Dim cnt As Long
  Dim x As Long
  Dim rv As String
  Dim first As Boolean
  first = False
  x = &H80000000
  
  If Not onlyExistant Then
    c.value = "0x" & Hex(CLng(res)) & " (" & res & ")"
  End If
  
  Dim i As Long
  
  For cnt = 1 To 32
    If (res And x) <> 0 Then
    
      foundone = False
      For Each item In f.m_Col
        If x = item.m_Value Then
          foundone = True
          If Len(c.value) > 0 Then
            For i = 1 To Len(sep)
              If Mid(sep, i, 1) = "n" Then
                c.value = c.value & vbLf
              Else
                c.value = c.value & Mid(sep, i, 1)
              End If
            Next i
          End If
          
          If onlyExistant Then
            c.value = c.value & item.m_Txt
          Else
            c.value = c.value & "0x" & Hex(item.m_Value) & " - " & item.m_Txt
          End If
          
        End If
      Next item
      
      If Not onlyExistant Then
        If Not foundone Then
          If Len(c.value) > 0 Then
            For i = 1 To Len(sep)
              If Mid(sep, i, 1) = "n" Then
                c.value = c.value & vbLf
              Else
                c.value = c.value & Mid(sep, i, 1)
              End If
            Next i
          End If
          
          c.value = c.value & "0x" & Hex(x) & " - ???"
        End If
      End If
    End If
    x = x / 2
    If x < 0 Then x = x * (-1)
  Next cnt
  If Len(c.value) = 0 Then
   c.value = "'-"
  End If
'  If Not foundOne Then c.Value = res
End Sub


Private Function ValToBin(v As Long) As String
  Dim i As Long
  Dim x As Long
  Dim rv As String
  Dim first As Boolean
  first = True
  x = &H80000000
  rv = "b"
  For i = 1 To 32
    If (v And x) <> 0 Then
      first = False
      rv = rv & "1"
    Else
      If Not first Then
        rv = rv & "0"
      End If
    End If
    x = x / 2
    If x < 0 Then x = x * (-1)
  Next i
  If first Then
    rv = "b0"
  End If
  ValToBin = rv
End Function

Private Function DoFor(ByRef codeValRet As String, ByRef c As Range, rng As Range, reclevel As Long) As Long
  
  DoFor = 0
  On Error GoTo 0
  Dim tok As String
  tok = GetToken(codeValRet)
  
'  If c.Value = "<! FOR EACH item IN FuncAm" Then
'    Debug.Print "gaga"
'  End If
  

'  If c.Value = "<! FOR EACH subitem IN item.items WIDTH 4" Then
'    Debug.Print "gaga"
'  End If
  
  If UCase(tok) <> "EACH" Then
    'XLScriptAddLogEntry "Error: EACH expected! " & m_WS.name & "!" & c.Address & " Value: " & c.value
    XLScriptAddLogEntry FMT3("XLSCRIPT_10", m_WS.name, c.Address, c.value)
    Exit Function
  End If
  
  Dim res As String
  res = GetVarName(codeValRet, c)
  If res = "" Then
    c.value = "'-/-"
'    XLScriptAddLogEntry "Error: PRINT missing expression! " & m_WS.name & "!" & c.Address & " Value: " & c.Value
    Exit Function
  End If
  
  tok = GetToken(codeValRet)
  If UCase(tok) <> "IN" Then
    'XLScriptAddLogEntry "Error: IN expected! " & m_WS.name & "!" & c.Address & " Value: " & c.value
    XLScriptAddLogEntry FMT3("XLSCRIPT_11", m_WS.name, c.Address, c.value)
    Exit Function
  End If
  
  Dim ref
  m_InPrint = True
  Set ref = GetRef(codeValRet, c)
  m_InPrint = False
  
  Dim widthAm As Long
  widthAm = 1
  tok = GetToken(codeValRet)
  If UCase(tok) = "WIDTH" Then
    tok = GetNumber(codeValRet)
    If Not IsNumeric(tok) Then
      'XLScriptAddLogEntry "Error: WIDTH must be followed by numeric value! " & m_WS.name & "!" & c.Address & " Value: " & c.value
      XLScriptAddLogEntry FMT3("XLSCRIPT_12", m_WS.name, c.Address, c.value)
    Else
      widthAm = CLng(tok)
    End If
  End If
  
  
  ' OK, jetzt das Ende des FOR Befehls suchen
  Dim cEnd As Range
  Set cEnd = rng.Find(What:=m_CodeStart & "NEXT " & res, LookIn:=xlValues, LookAt:= _
        xlWhole, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=False)
  
  If cEnd Is Nothing Then
    'XLScriptAddLogEntry "Error: FOR EACH missing NEXT! " & m_WS.name & "!" & c.Address & " Value: " & c.value
    XLScriptAddLogEntry FMT3("XLSCRIPT_13", m_WS.name, c.Address, c.value)
  End If
  
  Dim forwidth As Long
  forwidth = cEnd.Column - c.Column + 1
  Dim forheight As Long
  forheight = cEnd.Row - c.Row + 1 - 2
  If CountReadable(ref) Then
  
    Dim fn As XLForNext
    Set fn = New XLForNext
    fn.m_Name = res
    Set fn.m_Ref = ref
    fn.m_Current = 1
    fn.m_Width = widthAm
    fn.m_WidthCurrent = 0
    m_FN.Add fn
    
    ' Ok, kopieren, dann exec
    
    Dim cnt As Long
    
    Dim addedLines As Long
    addedLines = 0
    Dim maxAddLines As Long
    maxAddLines = -10000
    
    If reclevel = 1 Then MyLastTime = Now
    
    If ref.count > 0 Then
      For cnt = 1 To ref.count
      
        fn.m_Current = cnt - 1 + GetCollectionStart(fn.m_Ref)
        
        If reclevel = 1 Then
          If MyLastTime + TimeValue("0:00:02") < Now Then
            'UpdateStatus "Generiere Ergebnisbatt " & m_WS.name & " - " & cnt & " / " & ref.count
            UpdateStatus FMT3("XLSCRIPT_14", m_WS.name, cnt, ref.count)
            MyLastTime = Now
          End If
          If GetSetting(appname:="Stromwerken", Section:=ProgNameShort, Key:="AbortAction", Default:="") <> "" Then
            SaveSetting appname:="Stromwerken", Section:="ACC", Key:="AbortAction", setting:=""
            Beenden = True
          End If
          If Beenden Then Exit Function
        End If
        
        If fn.m_WidthCurrent = 0 Then
          m_WS.Range(m_WS.Cells(cEnd.Row + 1 + addedLines, c.Column), _
                m_WS.Cells(cEnd.Row + 1 + addedLines + forheight - 1, c.Column + forwidth * widthAm - 1)).Insert Shift:=xlDown
          maxAddLines = -10000
        End If
        
        m_WS.Range(m_WS.Cells(c.Row + 1, c.Column), m_WS.Cells(cEnd.Row - 1, cEnd.Column)).Copy
        m_WS.Cells(cEnd.Row + 1 + addedLines, c.Column + fn.m_WidthCurrent * forwidth).PasteSpecial xlPasteAll
        
        Dim newlines As Long
        newlines = XLScriptExecCode(m_WS.Range(m_WS.Cells(cEnd.Row + 1 + addedLines, c.Column + fn.m_WidthCurrent * forwidth), m_WS.Cells(cEnd.Row + 1 + addedLines + cEnd.Row - c.Row - 2, cEnd.Column + fn.m_WidthCurrent * forwidth)), reclevel + 1, fn.m_WidthCurrent)
        If newlines > maxAddLines Then
          maxAddLines = newlines
        End If
        
        fn.m_WidthCurrent = fn.m_WidthCurrent + 1
        
        If fn.m_WidthCurrent = fn.m_Width Then
          addedLines = addedLines + maxAddLines
          addedLines = addedLines + cEnd.Row - c.Row - 1
          fn.m_WidthCurrent = 0
        End If
      Next cnt
      If reclevel = 1 Then
        'UpdateStatus "Generiere Ergebnisbatt " & m_WS.name & " - " & cnt - 1 & " / " & ref.count
        UpdateStatus FMT3("XLSCRIPT_14", m_WS.name, cnt - 1, ref.count)
        MyLastTime = Now
      End If
    
      If fn.m_WidthCurrent > 0 Then
        addedLines = addedLines + maxAddLines
        addedLines = addedLines + cEnd.Row - c.Row - 1
      End If
    Else
    
      m_WS.Range(m_WS.Cells(cEnd.Row + 1, c.Column), _
            m_WS.Cells(cEnd.Row + 1 + forheight - 1, c.Column + forwidth * widthAm - 1)).Insert Shift:=xlDown
      m_WS.Cells(cEnd.Row + 1, c.Column) = "'-/-"
      addedLines = 1
    End If
    
    cnt = 1
    Dim item As XLForNext
    For Each item In m_FN
      If item.m_Name = fn.m_Name Then
        m_FN.Remove cnt
        Exit For
      End If
      cnt = cnt + 1
    Next item
  
  Else
  
    m_WS.Range(m_WS.Cells(cEnd.Row + 1, c.Column), _
          m_WS.Cells(cEnd.Row + 1 + forheight - 1, c.Column + forwidth * widthAm - 1)).Insert Shift:=xlDown
    m_WS.Cells(cEnd.Row + 1, c.Column) = "'-/-"
    addedLines = 1
  End If
  
  addedLines = addedLines - (cEnd.Row - c.Row + 1)
  m_WS.Range(m_WS.Cells(c.Row, c.Column), m_WS.Cells(cEnd.Row, c.Column + forwidth * widthAm - 1)).Delete Shift:=xlUp
  
  
  DoFor = addedLines
End Function

Private Function DoLFor(ByRef codeValRet As String, ByRef c As Range, rng As Range, reclevel As Long) As Long
  
  DoLFor = 0
  On Error GoTo 0
  Dim tok As String
  tok = GetToken(codeValRet)
  
'  If c.Value = "<! FOR EACH item IN FuncAm" Then
'    Debug.Print "gaga"
'  End If
  

'  If c.Value = "<! FOR EACH subitem IN item.items WIDTH 4" Then
'    Debug.Print "gaga"
'  End If
  
  If UCase(tok) <> "EACH" Then
    'XLScriptAddLogEntry "Error: EACH expected! " & m_WS.name & "!" & c.Address & " Value: " & c.value
    XLScriptAddLogEntry FMT3("XLSCRIPT_10", m_WS.name, c.Address, c.value)
    Exit Function
  End If
  
  Dim res As String
  res = GetVarName(codeValRet, c)
  If res = "" Then
    c.value = "'-/-"
'    XLScriptAddLogEntry "Error: PRINT missing expression! " & m_WS.name & "!" & c.Address & " Value: " & c.Value
    Exit Function
  End If
  
  tok = GetToken(codeValRet)
  If UCase(tok) <> "IN" Then
    'XLScriptAddLogEntry "Error: IN expected! " & m_WS.name & "!" & c.Address & " Value: " & c.value
    XLScriptAddLogEntry FMT3("XLSCRIPT_11", m_WS.name, c.Address, c.value)
    Exit Function
  End If
  
  Dim ref
  m_InPrint = True
  Set ref = GetRef(codeValRet, c)
  m_InPrint = False
  
  Dim widthAm As Long
  widthAm = 1
  tok = GetToken(codeValRet)
  If UCase(tok) = "WIDTH" Then
    tok = GetNumber(codeValRet)
    If Not IsNumeric(tok) Then
      'XLScriptAddLogEntry "Error: WIDTH must be followed by numeric value! " & m_WS.name & "!" & c.Address & " Value: " & c.value
      XLScriptAddLogEntry FMT3("XLSCRIPT_12", m_WS.name, c.Address, c.value)
    Else
      widthAm = CLng(tok)
    End If
  End If
  
  
  ' OK, jetzt das Ende des FOR Befehls suchen
  Dim cEnd As Range
  Set cEnd = rng.Find(What:=m_CodeStart & "LNEXT " & res, LookIn:=xlValues, LookAt:= _
        xlWhole, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=False)
  
  If cEnd Is Nothing Then
    'XLScriptAddLogEntry "Error: FOR EACH missing NEXT! " & m_WS.name & "!" & c.Address & " Value: " & c.value
    XLScriptAddLogEntry FMT3("XLSCRIPT_13", m_WS.name, c.Address, c.value)
  End If
  
  Dim forwidth As Long
  forwidth = cEnd.Column - c.Column + 1
  Dim forheight As Long
  forheight = cEnd.Row - c.Row + 1 - 2
  
  
  If CountReadable(ref) Then
  
    Dim fn As XLForNext
    Set fn = New XLForNext
    fn.m_Name = res
    Set fn.m_Ref = ref
    fn.m_Current = 1
    fn.m_Width = widthAm
    fn.m_WidthCurrent = 0
    m_FN.Add fn
    
    ' Ok, kopieren, dann exec
    
    Dim cnt As Long
    
    Dim addedLines As Long
    addedLines = 0
    Dim maxAddLines As Long
    maxAddLines = -10000
    
    If reclevel = 1 Then MyLastTime = Now
    
    
    If ref.count > 0 Then
    
      Dim lforlines As Long
      lforlines = CLng(ref.count / widthAm) + IIf(ref.count Mod widthAm = 0, 0, 1)
      
      m_WS.Range(m_WS.Cells(cEnd.Row + 1, c.Column), _
            m_WS.Cells(cEnd.Row + 1 + lforlines - 1, c.Column + forwidth * widthAm - 1)).Insert Shift:=xlDown
      m_WS.Range(m_WS.Cells(c.Row + 1, c.Column), m_WS.Cells(cEnd.Row - 1, cEnd.Column)).Copy
      m_WS.Range(m_WS.Cells(cEnd.Row + 1, c.Column), m_WS.Cells(cEnd.Row + 1 + lforlines - 1, c.Column + forwidth * widthAm - 1)).PasteSpecial xlPasteAll
      
      cnt = 1
      Dim lforam As Long
      lforam = lforlines * widthAm
      
      Dim printvals As New Collection
      Dim tC As Range
      Dim xlf As LForItem
      For Each tC In m_WS.Range(m_WS.Cells(c.Row + 1, c.Column), m_WS.Cells(cEnd.Row - 1, cEnd.Column))
        ' F<!1 P item.FNCOUNT
        Dim tPos As Long
        Dim tleft As String
        tPos = InStr(tC.value, m_CodeStart & "P " & res)
        If tPos > 0 Then
          Set xlf = New LForItem
          xlf.m_Prefix = ""
          If tPos > 1 Then
            xlf.m_Prefix = Left(tC.value, tPos - 1)
          End If
          xlf.m_Val = Mid(tC.value, tPos + Len(m_CodeStart & "P " & res & "."))
          xlf.m_X = tC.Column - c.Column
          xlf.m_Y = tC.Row - c.Row - 1
          printvals.Add xlf
          
        End If
      Next tC
      
      
      
      For cnt = 1 To lforam
      
        fn.m_Current = cnt - 1 + GetCollectionStart(fn.m_Ref)
        
        If reclevel = 1 Then
          If MyLastTime + TimeValue("0:00:02") < Now Then
            'UpdateStatus "Generiere Ergebnisblatt " & m_WS.name & " - " & cnt & " / " & ref.count
            UpdateStatus FMT3("XLSCRIPT_14", m_WS.name, cnt, ref.count)
            MyLastTime = Now
          End If
          If GetSetting(appname:="Stromwerken", Section:=ProgNameShort, Key:="AbortAction", Default:="") <> "" Then
            SaveSetting appname:="Stromwerken", Section:="ACC", Key:="AbortAction", setting:=""
            Beenden = True
          End If
          If Beenden Then Exit Function
        End If
        
        Dim newlines As Long
        
        maxAddLines = 0
        If cnt > ref.count Then
          For Each xlf In printvals
            m_WS.Cells(cEnd.Row + 1 + addedLines + xlf.m_Y, c.Column + fn.m_WidthCurrent * forwidth + xlf.m_X).value = ""
          Next xlf
        Else
'          newlines = XLScriptExecCode(m_WS.Range(m_WS.Cells(cEnd.Row + 1 + addedLines, c.Column + fn.m_WidthCurrent * forwidth), m_WS.Cells(cEnd.Row + 1 + addedLines + cEnd.Row - c.Row - 2, cEnd.Column + fn.m_WidthCurrent * forwidth)), reclevel + 1, fn.m_WidthCurrent)
          For Each xlf In printvals
          
            Dim tstring As String
            tstring = xlf.m_Val
            Set tC = m_WS.Cells(cEnd.Row + 1 + addedLines + xlf.m_Y, c.Column + fn.m_WidthCurrent * forwidth + xlf.m_X)
            If tstring = "" Then
              tC.value = xlf.m_Prefix & ref(cnt)
            ElseIf tstring = "FNCOUNT" Then
              tC.value = xlf.m_Prefix & cnt
            Else
              If VarValueExists(ref(cnt), tstring) Then
                tC.value = xlf.m_Prefix & ref(cnt)(tstring)
              End If
            End If
          Next xlf
        End If
        
        fn.m_WidthCurrent = fn.m_WidthCurrent + 1
        
        If fn.m_WidthCurrent = fn.m_Width Then
          addedLines = addedLines + maxAddLines
          addedLines = addedLines + cEnd.Row - c.Row - 1
          fn.m_WidthCurrent = 0
        End If
      Next cnt
      If reclevel = 1 Then
        'UpdateStatus "Generiere Ergebnisblatt " & m_WS.name & " - " & cnt - 1 & " / " & ref.count
        UpdateStatus FMT3("XLSCRIPT_14", m_WS.name, cnt - 1, ref.count)
        MyLastTime = Now
      End If
      If fn.m_WidthCurrent > 0 Then
        addedLines = addedLines + maxAddLines
        addedLines = addedLines + cEnd.Row - c.Row - 1
      End If
    Else
    
      m_WS.Range(m_WS.Cells(cEnd.Row + 1, c.Column), _
            m_WS.Cells(cEnd.Row + 1 + forheight - 1, c.Column + forwidth * widthAm - 1)).Insert Shift:=xlDown
      m_WS.Cells(cEnd.Row + 1, c.Column) = "'-/-"
      addedLines = 1
    End If
    
    cnt = 1
    Dim item As XLForNext
    For Each item In m_FN
      If item.m_Name = fn.m_Name Then
        m_FN.Remove cnt
        Exit For
      End If
      cnt = cnt + 1
    Next item
  
  Else
  
    m_WS.Range(m_WS.Cells(cEnd.Row + 1, c.Column), _
          m_WS.Cells(cEnd.Row + 1 + forheight - 1, c.Column + forwidth * widthAm - 1)).Insert Shift:=xlDown
    m_WS.Cells(cEnd.Row + 1, c.Column) = "'-/-"
    addedLines = 1
  End If
  
  addedLines = addedLines - (cEnd.Row - c.Row + 1)
  m_WS.Range(m_WS.Cells(c.Row, c.Column), m_WS.Cells(cEnd.Row, c.Column + forwidth * widthAm - 1)).Delete Shift:=xlUp
  
  
  DoLFor = addedLines
End Function


Private Sub DoDiagData(ByRef codeValRet As String, ByRef c As Range, rng As Range)
  
  On Error GoTo 0
  
  Dim endofline As String
  endofline = codeValRet
  Dim tok As String
  tok = GetToken(codeValRet)
  
  ' OK, jetzt das Ende des DIAGDATA Befehls suchen
  Dim cEnd As Range
  Set cEnd = rng.Find(What:=m_CodeStart & "DIAGDATAEND " & endofline, LookIn:=xlValues, LookAt:= _
        xlPart, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=False)
  
  If cEnd Is Nothing Then
    'XLScriptAddLogEntry "Error: DIAGDATA " & tok & " missing DIAGDATAEND " & tok & "! " & m_WS.name & "!" & c.Address & " Value: " & c.value
    XLScriptAddLogEntry FMT5("XLSCRIPT_15", tok, tok, m_WS.name, c.Address, c.value)
    c.EntireRow.Delete
    Exit Sub
  End If
  
  Dim coitem As ChartObject
  Dim cgitem As ChartGroup
  Dim scitem As Series
  If m_WS.ChartObjects.count > 0 Then
    For Each coitem In m_WS.ChartObjects
      If UCase(coitem.name) = UCase(tok) Then
        For Each cgitem In coitem.Chart.ChartGroups
          Set scitem = cgitem.SeriesCollection(1)
'          If IsReadableFormula(scitem) Then
            scitem.Formula = "=SERIES(," & m_WS.name & "!" & m_WS.Cells(c.Row + 1, c.Column).Address & _
              ":" & m_WS.Cells(cEnd.Row - 1, c.Column).Address & _
              "," & m_WS.name & "!" & m_WS.Cells(c.Row + 1, cEnd.Column).Address & ":" & _
              m_WS.Cells(cEnd.Row - 1, cEnd.Column).Address & ",1)"
'          End If
        Next cgitem
      End If
    Next coitem
  End If
  
  cEnd.EntireRow.Delete
  c.EntireRow.Delete
  
End Sub


Private Function GetCollectionStart(c)
  On Error GoTo start1
  If IsObject(c(0)) Then
  End If
  GetCollectionStart = 0
  Exit Function
start1:
  GetCollectionStart = 1
End Function

Private Function GetExpression(ByRef codeValRet As String, c As Range) As String
  Dim pos As Long
  On Error GoTo 0
  OverreadBlanks codeValRet
  ' Summe auf eine Variable eines Arrays bilden
  If UCase(Left(codeValRet, 4)) = "SUM " Then
    codeValRet = Mid(codeValRet, 4)
    Dim ref
    Set ref = GetRef(codeValRet, c)
    If Not ref Is Nothing Then
      GetComma codeValRet, c
      Dim tok As String
      tok = GetToken(codeValRet)
      Dim item
      Dim s As Long
      s = 0
      For Each item In ref
        If PropertyNameExists(item, tok) Then
          s = s + CLng(item.Properties(UCase(tok)))
        Else
          If GetUserName = "norman" Then XLScriptAddLogEntry "Warning: Variable '" & tok & "' not existant! " & m_WS.name & "!" & c.Address & " Value: " & c.value
        End If
      Next item
      GetExpression = s
      Exit Function
    End If
'  ElseIf Left(codeValRet, 1) >= "0" And Left(codeValRet, 1) <= "9" Then
  ElseIf (Left(codeValRet, 1) >= "a" And Left(codeValRet, 1) <= "z") Or (Left(codeValRet, 1) >= "A" And Left(codeValRet, 1) <= "Z") Then
    GetExpression = XLScriptGetVarValue(codeValRet, c)
    Exit Function
  ElseIf (Left(codeValRet, 1) = "*") Then
    pos = InStr(codeValRet, ")")
    If pos > 0 Then
      Dim endstr As String
      endstr = Mid(codeValRet, 2, pos - 2)
      Dim tp As String
      tp = Mid(codeValRet, pos + 1) & endstr
      GetExpression = GetExpression(tp, c)
      codeValRet = Mid(codeValRet, pos)
    End If
    Exit Function
  ElseIf Left(codeValRet, 1) = Chr(34) Then
    pos = InStr(2, codeValRet, Chr(34))
    If pos > 0 Then
      GetExpression = Mid(codeValRet, 2, pos - 2)
      codeValRet = Mid(codeValRet, pos + 1)
      Exit Function
    Else
      'XLScriptAddLogEntry "Error: " & Chr(22) & " missing! " & m_WS.name & "!" & c.Address & " Value: " & c.value
      XLScriptAddLogEntry FMT3("XLSCRIPT_16", m_WS.name, c.Address, c.value)
    End If
  End If
End Function

Private Function GetVarName(ByRef codeValRet As String, ByRef c As Range) As String
  On Error GoTo 0
  Dim tok As String
  Dim res As String
  tok = GetToken(codeValRet)
  If Len(tok) > 0 Then
    If Left(tok, 1) >= "a" Or Left(tok, 1) <= "z" Or Left(tok, 1) >= "A" Or Left(tok, 1) <= "Z" Then
      GetVarName = tok
      Exit Function
    End If
  End If
  'XLScriptAddLogEntry "Error: '" & tok & "' is not a variable name! " & m_WS.name & "!" & c.Address & " Value: " & c.value
  XLScriptAddLogEntry FMT4("XLSCRIPT_17", tok, m_WS.name, c.Address, c.value)
End Function

Function XLScriptGetVarValue(ByRef codeValRet As String, c As Range) As String
  On Error GoTo 0
  Dim tok As String
  Dim res As String
  Dim wasdot As Boolean
  wasdot = False
  
  Dim goitem As XLScriptGlobalObject
  
  tok = GetToken(codeValRet)
  If Len(tok) > 0 Then
  
    If Left(codeValRet, 1) = "." Then
      codeValRet = Mid(codeValRet, 2)
      wasdot = True
    End If
    
    Select Case UCase(tok)
   
#If USE_MDB = True Then
      Case "DB"
        res = XLScriptGetDBVarValue(codeValRet, m_DB, c)
      Case "WS"
        res = XLScriptGetDBVarValue(codeValRet, m_Workspace, c)
      Case "APP"
        res = XLScriptGetDBVarValue(codeValRet, m_App, c)
#End If
      Case "XL"
        res = XLScriptGetDBVarValue(codeValRet, m_Excel, c)
#If USE_XLS = True Then
      Case "XLWB"
        res = XLScriptGetDBVarValue(codeValRet, m_Workbook, c)
#End If
      Case Else
    
        Dim found As Boolean
        found = False
        
        For Each goitem In m_GlobalObjects
          If UCase(goitem.m_Name) = UCase(tok) Then
            res = XLScriptGetDBVarValue(codeValRet, goitem.m_Object, c)
            found = True
            Exit For
          End If
        Next goitem
        
        If Not found Then
          Dim item As XLForNext
          For Each item In m_FN
            If UCase(item.m_Name) = UCase(tok) Then
              res = XLScriptGetDBVarValue(codeValRet, item.m_Ref(item.m_Current), c, item)
'              If m_InPrint = True And XLSCript_Debug = True Then
'                item.m_Ref(item.m_Current).m_WasPrinted = True
'              End If
              found = True
              Exit For
            End If
          Next item
        End If
        
        ' Dann wollen wir doch mal nach "normalen" VariablenArrays schauen, die das Programm ermittelt hat
        If Not found Then
          Dim vaitem2d As XLScriptArray2D
          For Each vaitem2d In m_VarArray2D
            If UCase(vaitem2d.Properties("NAME")) = UCase(tok) Then
              
              res = XLScriptGetDBVarValue(codeValRet, vaitem2d.items, c, vaitem2d)
              
              If m_InPrint = True And XLSCript_Debug = True Then
                vaitem2d.m_WasPrinted = True
              End If
'              If wasdot Then
'                Set res = vaitem2d.items(codeValRet).items
'              End If
              found = True
              Exit For
            End If
          Next vaitem2d
        End If
        
            
        If Not found Then
          Dim svitem As XLScriptSimpleVar
          For Each svitem In m_SimpleVars
            If UCase(svitem.m_Txt) = UCase(tok) Then
              res = svitem.m_Value
              If m_InPrint = True And XLSCript_Debug = True Then
                svitem.m_WasPrinted = True
              End If
              found = True
              Exit For
            End If
          Next svitem
        End If
        
        
        If Not found Then
          Dim vaitem As XLScriptArray
          For Each vaitem In m_VarArray
            If UCase(vaitem.Properties("NAME")) = UCase(tok) Then
              res = XLScriptGetDBVarValue(codeValRet, vaitem.items, c, vaitem)
              If m_InPrint = True And XLSCript_Debug = True Then
                vaitem.m_WasPrinted = True
              End If
              found = True
              Exit For
            End If
          Next vaitem
        End If
        
        
        If Not found Then
          
          If IsValid(c) Then
            'XLScriptAddLogEntry "Error: '" & tok & "' is not a variable name! " & m_WS.name & "!" & c.Address & " Value: " & c.value
            XLScriptAddLogEntry FMT4("XLSCRIPT_17", tok, m_WS.name, c.Address, c.value)
          Else
            'XLScriptAddLogEntry "Error: '" & tok & "' is not a variable name!"
            XLScriptAddLogEntry FMT1("XLSCRIPT_18", tok)
          End If
        
          Do While wasdot
            wasdot = False
            tok = GetToken(codeValRet)
            If Len(tok) > 0 Then
              If Left(codeValRet, 1) = "." Then
                codeValRet = Mid(codeValRet, 2)
                wasdot = True
              End If
            
            End If
            
          Loop
        End If
    End Select
  End If
  XLScriptGetVarValue = res
End Function

Function XLScriptGetDBVarValue(ByRef codeValRet As String, par, c As Range, Optional obj = Nothing) As String
  On Error GoTo getError
  
  If Len(codeValRet) = 0 Or _
    (Left(codeValRet, 1) <> "." And _
    Not ((Left(codeValRet, 1) >= "a" And Left(codeValRet, 1) <= "z") Or (Left(codeValRet, 1) >= "A" And Left(codeValRet, 1) <= "Z"))) Then
    XLScriptGetDBVarValue = par
    Exit Function
  End If
  
  Dim tok As String
  Dim res As String
  
'  If Left(codeValRet, 1) = "(" Then
'    codeValRet = Mid(codeValRet, 2)
'    res = GetExpression(codeValRet, c)
  
'    If Not Left(codeValRet, 1) = ")" Then
'      XLScriptAddLogEntry "Error: '" & tok & "(' is missing ')'! " & m_WS.name & "!" & c.Address & " Value: " & c.Value
'    End If
    
  
  tok = GetToken(codeValRet)
  Dim wasdot As Long
  wasdot = False
  If Len(tok) > 0 Then
    If Left(codeValRet, 1) = "." Then
      codeValRet = Mid(codeValRet, 2)
      wasdot = True
    End If
    
    If VarValueExists(par, tok) Then
      res = par(tok)
    ElseIf XLScriptVarInCollectionExists(par, tok) Then
      res = par(tok).Properties(tok)
    ElseIf wasdot = True And ObjectNameExists(par, tok) = True Then
      res = XLScriptGetDBVarValue(codeValRet, par(tok), c)
    ElseIf PropertyNameExists(par, tok) = True Then
      res = par.Properties(tok)
    Else
      Select Case UCase(tok)
        Case "FNCOUNT"
          If Not obj Is Nothing Then
            res = obj.m_Current
          Else
            'XLScriptAddLogEntry "Error: '" & tok & "' is not initialized! " & m_WS.name & "!" & c.Address & " Value: " & c.value
            XLScriptAddLogEntry FMT4("XLSCRIPT_19", tok, m_WS.name, c.Address, c.value)
          End If
        Case "ADAPTIVEMENUS"
          res = par.AdaptiveMenus
        Case "ADAPTIVEMENU"
          res = par.AdaptiveMenu
        Case "BUILD"
          res = par.Build
        Case "BUILTIN"
          res = par.BuiltIn
        Case "COMADDINS"
          res = XLScriptGetDBVarValue(codeValRet, par.COMAddIns, c)
        Case "COMMANDBARS"
          res = XLScriptGetDBVarValue(codeValRet, par.CommandBars, c)
        Case "CONNECT"
          res = par.Connect
        Case "CONTEXT"
          res = par.Context
        Case "COUNT"
          res = par.count
        Case "CREATOR"
          res = par.Creator
        Case "DBENGINE"
          res = XLScriptGetDBVarValue(codeValRet, par.DBEngine, c)
        Case "DESCRIPTION"
          If PropertyNameExists(par, "DESCRIPTION") Then
            res = par.Properties("DESCRIPTION")
          Else
            res = par.Description
          End If
        Case "DISABLEASKAQUESTIONDROPDOWN"
          res = par.DisableAskAQuestionDropdown
        Case "DISABLECUSTOMIZE"
          res = par.DisableCustomize
        Case "DISPLAYFONTS"
          res = par.DisplayFonts
        Case "DISPLAYKEYSINTOOLTIPS"
          res = par.DisplayKeysInTooltips
        Case "DISPLAYTOOLTIPS"
          res = par.DisplayTooltips
        Case "ENABLED"
          res = par.Enabled
        Case "FIELDS"
          res = XLScriptGetDBVarValue(codeValRet, par.Fields, c)
        Case "FULLPATH"
          res = par.fullpath
        Case "GUID"
          res = par.GUID
        Case "INDEXES"
          res = XLScriptGetDBVarValue(codeValRet, par.Indexesm, c)
        Case "ISBROKEN"
          res = par.isbroken
        Case "ISCOMPILED"
          res = par.IsCompiled
        Case "ITEMS"
          res = par.items
        Case "NAME"
          res = par.name
        Case "VALUE"
          res = par.value
        Case "ATTRIBUTES"
          res = par.Attributes
        Case "NAMELOCAL"
          res = par.NameLocal
        Case "PRINTERS"
          res = XLScriptGetDBVarValue(codeValRet, par.Printers, c)
        Case "PRODUCTCODE"
          res = par.ProductCode
        Case "PROGID"
          res = par.ProgId
        Case "REFERENCES"
          res = XLScriptGetDBVarValue(codeValRet, par.References, c)
        Case "REFERSTO"
          res = par.RefersToLocal
        Case "RELATIONS"
          res = XLScriptGetDBVarValue(codeValRet, par.Relations, c)
        Case "SHEETS"
          res = par.Worksheets
        Case "VERSION"
          res = par.Version
        Case "VISIBLE"
          res = par.Visible

        Case Else
          res = XLScriptGetDBVarValue(codeValRet, par.Properties(UCase(tok)), c)
      End Select
    End If
  End If
  XLScriptGetDBVarValue = res
  Exit Function
getError:
  If Len(tok) > 0 Then
    If GetUserName = "norman" Then XLScriptAddLogEntry "Warning: " & Err.Description & "  - Token: '" & tok & "' - " & m_WS.name & "!" & c.Address & " Value: " & c.value
  Else
    If GetUserName = "norman" Then XLScriptAddLogEntry "Warning: " & Err.Description & " - " & m_WS.name & "!" & c.Address & " Value: " & c.value
  End If
  
End Function

Private Function GetRef(ByRef codeValRet As String, c As Range)
  On Error GoTo 0
  Dim tok As String
  Dim res
  Dim wasdot As Boolean
  wasdot = False
  tok = GetToken(codeValRet)
  If Len(tok) > 0 Then
    If Left(codeValRet, 1) = "." Then
      codeValRet = Trim(Mid(codeValRet, 2))
      wasdot = True
    End If
    Select Case UCase(tok)

#If USE_MDB = True Then
      Case "DB"
        Set res = GetDBRef(codeValRet, m_DB, c)
      Case "WS"
        Set res = GetDBRef(codeValRet, m_Workspace, c)
      Case "APP"
        Set res = GetDBRef(codeValRet, m_App, c)
#End If
      Case "XL"
        Set res = GetDBRef(codeValRet, m_Excel, c)
#If USE_XLS = True Then
      Case "XLWB"
        Set res = GetDBRef(codeValRet, m_Workbook, c)
#End If
      Case Else
        Dim found As Boolean
        found = False
        
        Dim goitem As XLScriptGlobalObject
        For Each goitem In m_GlobalObjects
          If UCase(goitem.m_Name) = UCase(tok) Then
            res = GetDBRef(codeValRet, goitem.m_Object, c)
            found = True
            Exit For
          End If
        Next goitem
            
            
        ' Ansonsten muss es eigentlich eine Variable sein...
        Dim item As XLForNext
        For Each item In m_FN
          If UCase(item.m_Name) = UCase(tok) Then
            Set res = GetDBRef(codeValRet, item.m_Ref(item.m_Current), c, item)
            found = True
            Exit For
          End If
        Next item
        
        ' Dann wollen wir doch mal nach "normalen" VariablenArrays schauen, die das Programm ermittelt hat
        If Not found Then
          Dim vaitem As XLScriptArray2D
          For Each vaitem In m_VarArray2D
            If UCase(vaitem.Properties("NAME")) = UCase(tok) Then
              Set res = vaitem.items
              If m_InPrint = True And XLSCript_Debug = True Then
                vaitem.m_WasPrinted = True
              End If
              If wasdot Then
                If ObjectNameExists(vaitem.items, codeValRet) Then
                  Set res = vaitem.items(codeValRet).items
                Else
                  Set res = Nothing
                End If
              End If
              If Not res Is Nothing Then
                found = True
              End If
              Exit For
            End If
          Next vaitem
        End If
        
        If Not found Then
          Dim vasitem As XLScriptArray
          For Each vasitem In m_VarArray
            If UCase(vasitem.Properties("NAME")) = UCase(tok) Then
              Set res = vasitem.items
              If m_InPrint = True And XLSCript_Debug = True Then
                vasitem.m_WasPrinted = True
              End If
              found = True
              Exit For
            End If
          Next vasitem
        End If
        
        If Not found Then
          'XLScriptAddLogEntry "Error: '" & tok & "' is not a variable name! " & m_WS.name & "!" & c.Address & " Value: " & c.value
          XLScriptAddLogEntry FMT4("XLSCRIPT_17", tok, m_WS.name, c.Address, c.value)
        End If
    End Select
  End If
  If Not IsEmpty(res) Then
    Set GetRef = res
  Else
    Set GetRef = Nothing
  End If
End Function

Private Function GetDBRef(ByRef codeValRet As String, par, c As Range, Optional obj = Nothing)
  On Error GoTo getError
  
  If Len(codeValRet) = 0 Or _
    (Left(codeValRet, 1) <> "." And _
    Not ((Left(codeValRet, 1) >= "a" And Left(codeValRet, 1) <= "z") Or (Left(codeValRet, 1) >= "A" And Left(codeValRet, 1) <= "Z")) Or UCase(Left(codeValRet, 6)) = "WIDTH ") Then
    Set GetDBRef = par
    Exit Function
  End If
  
  Dim tok As String
  Dim res
  tok = GetToken(codeValRet)
  If Len(tok) > 0 Then
  
    If Left(codeValRet, 1) = "." Then
      codeValRet = Mid(codeValRet, 2)
    End If
    
    
'    If PropertyNameExists(par, tok) Then
'      Set res = GetDBRef(codeValRet, par.Properties(UCase(tok)), c)
'    Else
      Select Case UCase(tok)
        Case "FNCOUNT"
          If Not obj Is Nothing Then
            res = obj.m_Current
          Else
            'XLScriptAddLogEntry "Error: '" & tok & "' is not initialized! " & m_WS.name & "!" & c.Address & " Value: " & c.value
            XLScriptAddLogEntry FMT4("XLSCRIPT_19", tok, m_WS.name, c.Address, c.value)
          End If
        Case "CONTAINERS"
          Set res = GetDBRef(codeValRet, par.Containers, c)
        Case "DBENGINE"
          Set res = GetDBRef(codeValRet, par.DBEngine, c)
        Case "REFERENCES"
          Set res = GetDBRef(codeValRet, par.References, c)
        Case "RELATIONS"
          Set res = GetDBRef(codeValRet, par.Relations, c)
        Case "DOCUMENTS"
          Set res = GetDBRef(codeValRet, par.Documents, c)
        Case "FIELDS"
          Set res = GetDBRef(codeValRet, par.Fields, c)
        Case "INDEXES"
          Set res = GetDBRef(codeValRet, par.Indexes, c)
        Case "PRINTERS"
          Set res = GetDBRef(codeValRet, par.Printers, c)
        Case "COMADDINS"
          Set res = GetDBRef(codeValRet, par.COMAddIns, c)
        Case "COMMANDBARS"
          Set res = GetDBRef(codeValRet, par.CommandBars, c)
        Case "PROPERTIES"
          Set res = GetDBRef(codeValRet, par.Properties, c)
        Case "COUNT"
          Set res = par.count
        Case "BUILD"
          Set res = par.Build
        Case "ISCOMPILED"
          Set res = par.IsCompiled
        Case "PRODUCTCODE"
          Set res = par.ProductCode
        Case "VERSION"
          Set res = par.Version
        Case "TABLEDEFS"
          Set res = GetDBRef(codeValRet, par.TableDefs, c)
        Case "GROUPS"
          Set res = GetDBRef(codeValRet, par.Groups, c)
        Case "USERS"
          Set res = GetDBRef(codeValRet, par.Users, c)
        Case "NAMES"
          Set res = GetDBRef(codeValRet, par.names, c)
        Case "ITEMS"
          Set res = par.items
        Case "QUERYDEFS"
          Set res = GetDBRef(codeValRet, par.QueryDefs, c)
          
        Case Else
          If PropertyNameExists(par, UCase(tok)) Then
            Set res = GetDBRef(codeValRet, par.Properties(UCase(tok)), c)
          ElseIf ObjectNameExists(par, UCase(tok)) Then
            Set res = GetDBRef(codeValRet, par(UCase(tok)), c)
          End If
      End Select
'    End If
  End If
  Set GetDBRef = res
  Exit Function
getError:
  
  If Len(tok) > 0 Then
    If GetUserName = "norman" Then XLScriptAddLogEntry "Warning: " & Err.Description & "  - Token: '" & tok & "' - " & m_WS.name & "!" & c.Address & " Value: " & c.value
  Else
    If GetUserName = "norman" Then XLScriptAddLogEntry "Warning: " & Err.Description & " - " & m_WS.name & "!" & c.Address & " Value: " & c.value
  End If
  Set GetDBRef = Nothing
End Function


Public Sub XLScriptAddLogEntry(s As String)
'  If Not m_ResultWorkbook Is Nothing Then
'    m_ResultWorkbook.Sheets("Log").Cells(m_LogY, 1) = s
'    m_LogY = m_LogY + 1
'  End If
  AddStatus s
'  m_Log.Add s
End Sub


Private Function CountReadable(ref) As Boolean
  On Error GoTo notReadable
  Dim i As Long
  i = ref.count
  CountReadable = True
  Exit Function
  
notReadable:
  CountReadable = False
End Function


Public Function IsReadableFormula(anything) As Boolean
  On Error GoTo nopeNotReadable
'  Debug.Print anything.Formula
  IsReadableFormula = True
  Exit Function
nopeNotReadable:
  IsReadableFormula = False
End Function

Function XLScriptGetNewObject(s As String) As Object
  Select Case s
    Case "XLScriptVar"
      Set XLScriptGetNewObject = New XLScriptVar
      Exit Function
    Case "XLScriptSimpleVar"
      Set XLScriptGetNewObject = New XLScriptSimpleVar
      Exit Function
    Case Else
      Err.Raise vbObjectError + 27, "XLScript.XLScript", "Unknown XLScriptGetNewObject type '" & s & "'"
  End Select
End Function


Function IsValid(c As Range) As Boolean
  IsValid = False
  On Error GoTo notValid
  Dim tstr
  tstr = c.value
  IsValid = True
  Exit Function
notValid:
End Function

Public Function XLScriptVarInCollectionExists(par, name As String) As Boolean
  On Error GoTo notReadable
  Dim s As String
  If TypeName(par) = "Collection" Then
    If TypeName(par(name)) = "XLScriptVar" Then
      XLScriptVarInCollectionExists = True
      Exit Function
    End If
  End If
  
notReadable:
  XLScriptVarInCollectionExists = False
End Function

Public Function VarValueExists(par, name As String) As Boolean
  On Error GoTo notReadable
  Dim s As String
  s = CStr(par(UCase(name)))
  VarValueExists = True
  Exit Function
  
notReadable:
  VarValueExists = False
End Function

Public Function ObjectNameExists(par, name As String) As Variant
  On Error GoTo notReadable
  Dim s As Variant
  Set s = par(name)
  ObjectNameExists = True
  Exit Function
  
notReadable:
  ObjectNameExists = False
End Function

Public Function PropertyNameExists(par, name As String) As Boolean
  On Error Resume Next
  PropertyNameExists = True
  Dim s As String
  s = CStr(par.Properties(UCase(name)))
  If Err.Number = 0 Then Exit Function
'XXX
  Err.Clear
  Dim t
  Set t = par.Properties(UCase(name))
  If Err.Number = 0 Then Exit Function
  
  PropertyNameExists = False
End Function





#If USE_MDB = True Then
Public Sub CreateAccessApp(v As Long)
  #If USE_LATE_BINDING_MDB Then
'    Set m_App = CreateObject("Access.Application")
    Set m_App = CreateObject("Access.Application." & v)
  #Else
    Set m_App = New Access.Application
  #End If
End Sub
#End If

#If USE_MDB = True Then
' http://www.fmsinc.com/microsoftaccess/history/versions.htm
' 2016  16
' 2013  15
' 2010  14
' 2007  12
' 2003  11
' 2002  10
' 2000  9
' 97    8
Public Function CheckAccessVersion(v As Long) As Boolean
CheckAccessVersion = False
On Error Resume Next
'  #If USE_LATE_BINDING_MDB Then
'    Set m_App = CreateObject("Access.Application")
    Dim o As Object
    SaveSetting appname:="Stromwerken", Section:="AccessTracker", Key:="IgnoreThisOne", setting:="True"
    Set o = CreateObject("Access.Application." & v)
    If Not o Is Nothing Then
      CheckAccessVersion = True
      o.CloseCurrentDatabase
      o.Quit
      Set o = Nothing
    End If
    SaveSetting appname:="Stromwerken", Section:="AccessTracker", Key:="IgnoreThisOne", setting:="False"
'  #Else
'    Set m_App = New Access.Application
'  #End If
End Function
#End If



Attribute VB_Name = "XLScriptArray"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

Public m_SortName As String
Public items As Collection
Public Properties As Collection
Public m_WasPrinted As Boolean


Public Sub Init(Optional n As String = "", Optional v As String = "")
  Set Properties = New Collection
  m_SortName = n
  Properties.Add n, "NAME"
  Properties.Add v, "VAL"
  Set items = New Collection
End Sub

Public Sub AddValue(n As String, v As String)
  If Len(n) > 0 Then
    items.Add v, UCase(n)
  Else
    items.Add v
  End If
End Sub

Function AddNameAndValue(n As String, v As String) As XLScriptVar
  Dim dv As XLScriptVar
  Set dv = New XLScriptVar
  dv.Init n
  dv.Properties.Add n, "NAME"
  dv.Properties.Add v, "VAL"
  items.Add dv, CStr(n)
  Set AddNameAndValue = dv
End Function

Sub AddXLScriptVar(ByRef xlsv As XLScriptVar)
  items.Add xlsv
End Sub

Public Sub AddToValue(propertyName As String, v)
  On Error Resume Next
  If Len(propertyName) > 0 Then
    Dim nv
    nv = Properties(propertyName)
    nv = nv + v
    Properties.Remove UCase(propertyName)
    Properties.Add nv, UCase(propertyName)
  End If
  Exit Sub
'wasMissing:
'    Properties.Add nv, v
End Sub



Attribute VB_Name = "XLScriptArray2D"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public m_SortName As String
Public items As Collection
Public itemKeys As Collection
Public Properties As Collection
Public PropertyKeys As Collection
Public m_WasPrinted As Boolean

Public Sub Store(nr As Integer)
'  assert 0
'  Close #1
  Write #nr, "XLScriptArray2D"
  Write #nr, m_SortName
  Dim item
  Write #nr, items.count
  Dim i As Long
  If items.count > 0 Then
    For i = 1 To items.count
      Select Case TypeName(items(i))
        Case "Collection"
          Dim tcoll As Collection
          Set tcoll = items(i)
          Dim tcollkeys As Collection
          Set tcollkeys = itemKeys(i)
          Dim ti As Long
          If tcoll.count > 0 Then
            For ti = 1 To tcoll.count
              Select Case TypeName(tcoll(ti))
                Case "String"
                  Write #nr, tcollkeys(ti), tcoll(ti)
                Case Else
                  Debug.Print "Unknown type: " & TypeName(tcoll(ti))
              End Select
            Next ti
          End If
          Set tcoll = Nothing
          Set tcollkeys = Nothing
        Case "XLScriptArray"
          items(i).Store nr
        Case Else
          Debug.Print "Unknown type: " & TypeName(items(i))
      End Select
  '    Write #nr, itemKeys(i)
  '    Write #nr, items(i)
    Next i
  End If
  Write #nr, Properties.count
  If Properties.count > 0 Then
    For i = 1 To Properties.count
      Write #nr, PropertyKeys(i), Properties(i)
    Next i
  End If
End Sub
Public Sub ReStore(nr As Integer)
  Dim am As Long
  Input #nr, am
  Dim i As Long
  Set Properties = New Collection
  For i = 1 To am
    Dim otype As String
    Input #nr, otype
    Dim sortname As String
    Input #nr, sortname
    Dim tObject
    Set tObject = XLScriptGetNewObject(otype)
    tObject.m_SortName = sortname
    Properties.Add tObject, sortname
    tObject.ReStore nr
  Next i
End Sub


Public Sub Init(Optional name As String = "")
  m_SortName = name
  Set items = New Collection
  Set itemKeys = New Collection
  Set Properties = New Collection
  Set PropertyKeys = New Collection
  Properties.Add name, "NAME"
  PropertyKeys.Add "NAME", "NAME"
End Sub

Public Sub AddLine(Optional linename As String = "")
  Dim al As Collection
  Set al = New Collection
  If Len(linename) = 0 Then
    items.Add al
  Else
    items.Add al, linename
  End If
  Set al = New Collection
  itemKeys.Add al
End Sub

Public Function CurrentLine() As Variant
  Set CurrentLine = items(items.count)
End Function

Public Sub AddValue(n As String, v As String)
  If Len(n) > 0 Then
    items(items.count).Add v, UCase(n)
    itemKeys(items.count).Add UCase(n), UCase(n)
  Else
    items(items.count).Add v
    itemKeys(items.count).Add ""
  End If
End Sub

Public Sub AddToValue(n As String, v)
  On Error Resume Next
  If Len(n) > 0 Then
    Dim nv
    nv = items(items.count).item(UCase(n))
    nv = nv + v
    items(items.count).Remove UCase(n)
    items(items.count).Add nv, UCase(n)
  End If
End Sub

Public Sub SetValue(n As String, v)
  On Error Resume Next
  If Len(n) > 0 Then
    items(items.count).Remove UCase(n)
    items(items.count).Add v, UCase(n)
  End If
End Sub


Public Sub AddVar(n As String, v As String)
'  items(items.count).AddNameAndValue n, v
  Dim dv As XLScriptVar
  Set dv = New XLScriptVar
  dv.Init n
  dv.Properties.Add v, n
  items(items.count).Add dv, CStr(n)
End Sub


Public Sub AddNameAndValue(n As String, v As String)
'  items(items.count).AddNameAndValue n, v
  Dim dv As XLScriptVar
  Set dv = New XLScriptVar
  dv.Init n
  dv.Properties.Add n, "NAME"
  dv.Properties.Add v, "VAL"
  items.Add dv, CStr(n)

End Sub

Public Function AddXLScriptArray(n As String, Optional v As String = "") As XLScriptArray
  
  Dim dsa As XLScriptArray
  Set dsa = New XLScriptArray
  dsa.Init n, v
  items.Add dsa, UCase(n)
  itemKeys.Add UCase(n), UCase(n)
  
  Set AddXLScriptArray = dsa

End Function

Public Function AddXLScriptArray2D(n As String) As XLScriptArray2D
  Dim da As XLScriptArray2D
  Set da = New XLScriptArray2D
  da.Init n
  items.Add da, UCase(n)
  itemKeys.Add UCase(n), UCase(n)
  
  Set AddXLScriptArray2D = da

End Function

Public Function AddXLScriptArray2DToCurrentLine(n As String) As XLScriptArray2D
  Set AddXLScriptArray2DToCurrentLine = Nothing
  If items.count <= 0 Then Exit Function
  Dim da As XLScriptArray2D
  Set da = New XLScriptArray2D
  da.Init
  items(items.count).Add da, UCase(n)
  itemKeys(items.count).Add UCase(n), UCase(n)
  
  Set AddXLScriptArray2DToCurrentLine = da

End Function

Public Function AddXLScriptArrayToCurrentLine(n As String, Optional v As String = "") As XLScriptArray
  
  Dim dsa As XLScriptArray
  Set dsa = New XLScriptArray
  dsa.Init n, v
  items(items.count).Add dsa, UCase(n)
  itemKeys(items.count).Add UCase(n), UCase(n)
  
  Set AddXLScriptArrayToCurrentLine = dsa

End Function


Attribute VB_Name = "XLScriptForNext"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

    Public m_Name As String
    Public m_Ref
    Public m_Current As Integer
    Public m_Width As Integer
    Public m_WidthCurrent As Integer
Attribute VB_Name = "XLScriptGlobalObject"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public m_Object As Variant
Public m_Name As String



Attribute VB_Name = "XLScriptSimpleVar"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

Public m_Value As String
Public m_Txt As String
Public m_WasPrinted As Boolean

Attribute VB_Name = "XLScriptVar"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

Public m_SortName As String
Public Properties As Collection
Public PropertyKeys As Collection
Public m_WasPrinted As Boolean

Public Sub Store(nr As Integer)
  Write #nr, "XLScriptVar"
  Write #nr, m_SortName
  Write #nr, Properties.count
  Dim i As Long
  If Properties.count > 0 Then
    For i = 1 To Properties.count
      Write #nr, PropertyKeys(i), Properties(i)
    Next i
  End If
End Sub
Public Sub ReStore(nr As Integer)
  Dim am As Long
  Input #nr, am
  Dim i As Long
  Set Properties = New Collection
  For i = 1 To am
    Dim otype As String
    Input #nr, otype
    Dim sortname As String
    Input #nr, sortname
    Dim tObject
    Set tObject = XLScriptGetNewObject(otype)
    tObject.m_SortName = sortname
    Properties.Add tObject, sortname
    PropertyKeys.Add sortname, sortname
    tObject.ReStore nr
  Next i
End Sub
Public Sub Init(ByVal n As String)
  Set Properties = New Collection
  Set PropertyKeys = New Collection
  m_SortName = n
End Sub



Function GetScriptVar(n As String) As XLScriptVar
  If Not ScriptVarExists(n) Then
    Dim tsv As XLScriptVar
    Set tsv = New XLScriptVar
    tsv.Init n
    tsv.m_SortName = UCase(n)
    Properties.Add tsv, UCase(n)
    PropertyKeys.Add UCase(n), UCase(n)
  End If
  Set GetScriptVar = Properties(UCase(n))
End Function

Function GetScriptArray(n As String) As XLScriptArray
  If Not ScriptVarExists(n) Then
    Dim tsv As XLScriptArray
    Set tsv = New XLScriptArray
    tsv.Init n
    tsv.m_SortName = UCase(n)
    Properties.Add tsv, UCase(n)
    PropertyKeys.Add UCase(n), UCase(n)
  End If
  Set GetScriptArray = Properties(UCase(n))
End Function

Function ScriptVarExists(n As String) As Boolean
  On Error GoTo doesntExist
  ScriptVarExists = True
  Dim tobj
  Set tobj = Properties(UCase(n))
doesntExist:
  ScriptVarExists = False
End Function

Public Sub AddToValue(propertyName As String, v)
  On Error Resume Next
  If Len(propertyName) > 0 Then
    Dim nv
    nv = Properties(propertyName)
    nv = nv + v
    Properties.Remove UCase(propertyName)
    Properties.Add nv, UCase(propertyName)
  End If
End Sub

Public Sub SetValue(propertyName As String, v)
  On Error Resume Next
  If Len(propertyName) > 0 Then
    Properties.Remove UCase(propertyName)
    Properties.Add v, UCase(propertyName)
  End If
End Sub



Attribute VB_Name = "aaa_XLStuff"

Option Explicit

Private Sub CreateXLAXLAM()
  Application.DisplayAlerts = False
  WBRemoveTags
  ThisWorkbook.IsAddin = True
'  ThisWorkbook.SaveAs ThisWorkbook.path & "\Access-Checker.xlam", xlOpenXMLAddIn
  ThisWorkbook.SaveAs ThisWorkbook.path & "\Access-Checker.xla", xlAddIn
  ThisWorkbook.IsAddin = False
  ThisWorkbook.Saved = True
  Application.DisplayAlerts = True
End Sub


Private Sub WBRemoveTags()

    Dim nameItem As Excel.name

GoAgain:
    Dim i As Long
    If ThisWorkbook.names.count > 0 Then
      For i = 1 To ThisWorkbook.names.count
          If ThisWorkbook.names(i).Visible = False Then
              If Left(ThisWorkbook.names(i).name, Len("_IDVTracker")) = "_IDVTracker" Then
                  ThisWorkbook.names.item(i).Delete
                  GoTo GoAgain
              End If
          End If
      Next i
    End If

End Sub
Attribute VB_Name = "clsCommonDialog"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'|fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd|
'|fffd|VERSION 1.0 CLASS
'|fffd|BEGIN
'|fffd|  MultiUse = -1  'True
'|fffd|  Persistable = 0  'NotPersistable
'|fffd|  DataBindingBehavior = 0  'vbNone
'|fffd|  DataSourceBehavior = 0   'vbNone
'|fffd|  MTSTransactionMode = 0   'NotAnMTSObject
'|fffd|End
'|fffd|Attribute VB_Name = "clsCommonDialog"
'|fffd|Attribute VB_GlobalNameSpace = False
'|fffd|Attribute VB_Creatable = True
'|fffd|Attribute VB_PredeclaredId = False
'|fffd|Attribute VB_Exposed = True
'|fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd|
 
Option Explicit
' This code is from the Microsoft Knowledge Base.

#If VBA7 Then
'API function called by ChooseColor method
Private Declare PtrSafe Function ChooseColor Lib "comdlg32.dll" Alias "ChooseColorA" (pChoosecolor As ChooseColor) As Long

'API function called by ShowOpen method
Private Declare PtrSafe Function GetOpenFileName Lib "comdlg32.dll" Alias "GetOpenFileNameA" (pOpenfilename As OPENFILENAME) As Long

'API function called by ShowSave method
Private Declare PtrSafe Function GetSaveFileName Lib "comdlg32.dll" Alias "GetSaveFileNameA" (pOpenfilename As OPENFILENAME) As Long

'API function to retrieve extended error information
Private Declare PtrSafe Function CommDlgExtendedError Lib "comdlg32.dll" () As Long

'API memory functions
Private Declare PtrSafe Function GlobalAlloc Lib "kernel32" (ByVal wFlags As Long, ByVal dwBytes As Long) As LongPtr
Private Declare PtrSafe Function GlobalFree Lib "kernel32" (ByVal hMem As LongPtr) As LongPtr
Private Declare PtrSafe Function GlobalLock Lib "kernel32" (ByVal hMem As LongPtr) As LongPtr
Private Declare PtrSafe Function GlobalUnlock Lib "kernel32" (ByVal hMem As LongPtr) As LongPtr

Private Declare PtrSafe Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" ( _
         hpvDest As Any, hpvSource As Any, ByVal cbCopy As LongPtr)
#Else
'API function called by ChooseColor method
Private Declare Function ChooseColor Lib "comdlg32.dll" Alias "ChooseColorA" (pChoosecolor As ChooseColor) As Long

'API function called by ShowOpen method
Private Declare Function GetOpenFileName Lib "comdlg32.dll" Alias "GetOpenFileNameA" (pOpenfilename As OPENFILENAME) As Long

'API function called by ShowSave method
Private Declare Function GetSaveFileName Lib "comdlg32.dll" Alias "GetSaveFileNameA" (pOpenfilename As OPENFILENAME) As Long

'API function to retrieve extended error information
Private Declare Function CommDlgExtendedError Lib "comdlg32.dll" () As Long

'API memory functions
Private Declare Function GlobalAlloc Lib "kernel32" (ByVal wFlags As Long, ByVal dwBytes As Long) As Long
Private Declare Function GlobalFree Lib "kernel32" (ByVal hMem As Long) As Long
Private Declare Function GlobalLock Lib "kernel32" (ByVal hMem As Long) As Long
Private Declare Function GlobalUnlock Lib "kernel32" (ByVal hMem As Long) As Long

Private Declare Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" ( _
         hpvDest As Any, hpvSource As Any, ByVal cbCopy As Long)
 #End If

'constants for API memory functions
Private Const GMEM_MOVEABLE = &H2
Private Const GMEM_ZEROINIT = &H40
Private Const GHND = (GMEM_MOVEABLE Or GMEM_ZEROINIT)
 
 
'data buffer for the ChooseColor function
Private Type ChooseColor
        lStructSize As Long
        hwndOwner As Long
        hInstance As Long
        rgbResult As Long
        lpCustColors As Long
        flags As Long
        lCustData As Long
        lpfnHook As Long
        lpTemplateName As String
End Type

'data buffer for the GetOpenFileName and GetSaveFileName functions
Private Type OPENFILENAME
        lStructSize As Long
        hwndOwner As Long
        hInstance As Long
        lpstrFilter As String
        lpstrCustomFilter As String
        nMaxCustFilter As Long
        iFilterIndex As Long
        lpstrFile As String
        nMaxFile As Long
        lpstrFileTitle As String
        nMaxFileTitle As Long
        lpstrInitialDir As String
        lpstrTitle As String
        flags As Long
        nFileOffset As Integer
        nFileExtension As Integer
        lpstrDefExt As String
        lCustData As Long
        lpfnHook As Long
        lpTemplateName As String
End Type


'internal property buffers

Private iAction As Integer         'internal buffer for Action property
Private bCancelError As Boolean    'internal buffer for CancelError property
Private lColor As Long             'internal buffer for Color property
Private lCopies As Long            'internal buffer for lCopies property
Private sDefaultExt As String      'internal buffer for sDefaultExt property
Private sDialogTitle As String     'internal buffer for DialogTitle property
Private sFilename As String        'internal buffer for FileName property
Private sFileTitle As String       'internal buffer for FileTitle property
Private sFilter As String          'internal buffer for Filter property
Private iFilterIndex As Integer    'internal buffer for FilterIndex property
Private lFlags As Long             'internal buffer for Flags property
Private lhdc As Long               'internal buffer for hdc property
Private sInitDir As String         'internal buffer for InitDir property
Private lMax As Long               'internal buffer for Max property
Private lMaxFileSize As Long       'internal buffer for MaxFileSize property
Private lMin As Long               'internal buffer for Min property
Private objObject As Object        'internal buffer for Object property

Private lApiReturn As Long          'internal buffer for APIReturn property
Private lExtendedError As Long      'internal buffer for ExtendedError property



'constants for color dialog

Private Const CDERR_DIALOGFAILURE = &HFFFF
Private Const CDERR_FINDRESFAILURE = &H6
Private Const CDERR_GENERALCODES = &H0
Private Const CDERR_INITIALIZATION = &H2
Private Const CDERR_LOADRESFAILURE = &H7
Private Const CDERR_LOADSTRFAILURE = &H5
Private Const CDERR_LOCKRESFAILURE = &H8
Private Const CDERR_MEMALLOCFAILURE = &H9
Private Const CDERR_MEMLOCKFAILURE = &HA
Private Const CDERR_NOHINSTANCE = &H4
Private Const CDERR_NOHOOK = &HB
Private Const CDERR_NOTEMPLATE = &H3
Private Const CDERR_REGISTERMSGFAIL = &HC
Private Const CDERR_STRUCTSIZE = &H1


'constants for file dialog

Private Const FNERR_BUFFERTOOSMALL = &H3003
Private Const FNERR_FILENAMECODES = &H3000
Private Const FNERR_INVALIDFILENAME = &H3002
Private Const FNERR_SUBCLASSFAILURE = &H3001

Public Property Get Filter() As String
    'return object's Filter property
    Filter = sFilter
End Property


Public Sub ShowOpen()
    'display the file open dialog box
    ShowFileDialog (1)  'Action property - ShowOpen
End Sub

Public Sub ShowSave()
    'display the file save dialog box
    ShowFileDialog (2)  'Action property - ShowSave
End Sub

Public Property Get Filename() As String
    'return object's FileName property
    Filename = sFilename
End Property

Public Property Let Filename(vNewValue As String)
    'assign object's FileName property
    sFilename = vNewValue
End Property

Public Property Let Filter(vNewValue As String)
    'assign object's Filter property
    sFilter = vNewValue
End Property

Private Function sLeftOfNull(ByVal sIn As String)
    'returns the part of sIn preceding Chr$(0)
    Dim lNullPos As Long
    
    'init output
    sLeftOfNull = sIn
    
    'get position of first Chr$(0) in sIn
    lNullPos = InStr(sIn, Chr$(0))
    
    'return part of sIn to left of first Chr$(0) if found
    If lNullPos > 0 Then
        sLeftOfNull = Mid$(sIn, 1, lNullPos - 1)
    End If
    
End Function


Public Property Get Action() As Integer
    'Return object's Action property
    Action = iAction
End Property

Private Function sAPIFilter(sIn)
    'prepares sIn for use as a filter string in API common dialog functions
    Dim lChrNdx As Long
    Dim sOneChr As String
    Dim sOutStr As String
    
    'convert any | characters to nulls
    For lChrNdx = 1 To Len(sIn)
        sOneChr = Mid$(sIn, lChrNdx, 1)
        If sOneChr = "|" Then
            sOutStr = sOutStr & Chr$(0)
        Else
            sOutStr = sOutStr & sOneChr
        End If
    Next
    
    'add a null to the end
    sOutStr = sOutStr & Chr$(0)
    
    'return sOutStr
    sAPIFilter = sOutStr
    
End Function

Public Property Get FilterIndex() As Integer
    'return object's FilterIndex property
    FilterIndex = iFilterIndex
End Property

Public Property Let FilterIndex(vNewValue As Integer)
    iFilterIndex = vNewValue
End Property

Public Property Get CancelError() As Boolean
    'Return object's CancelError property
    CancelError = bCancelError
End Property

Public Property Let CancelError(vNewValue As Boolean)
    'Assign object's CancelError property
    bCancelError = vNewValue
End Property

Public Property Get Color() As Long
    'return object's Color property
    Color = lColor
End Property

Public Property Let Color(vNewValue As Long)
    'assign object's Color property
    lColor = vNewValue
End Property

Public Property Get DefaultExt() As String
    'return object's DefaultExt property
    DefaultExt = sDefaultExt
End Property

Public Property Let DefaultExt(vNewValue As String)
    'assign object's DefaultExt property
    sDefaultExt = vNewValue
End Property

Public Property Get DialogTitle() As String
    'return object's FileName property
    DialogTitle = sDialogTitle
End Property

Public Property Let DialogTitle(vNewValue As String)
    'assign object's DialogTitle property
    sDialogTitle = vNewValue
End Property

Public Property Get flags() As Long
    'return object's Flags property
    flags = lFlags
End Property

Public Property Let flags(vNewValue As Long)
    'assign object's Flags property
    lFlags = vNewValue
End Property

Public Property Get hDC() As Long
    'Return object's hDC property
    hDC = lhdc
End Property

Public Property Let hDC(vNewValue As Long)
    'Assign object's hDC property
    lhdc = vNewValue
End Property

Public Property Get InitDir() As String
    'Return object's InitDir property
    InitDir = sInitDir
End Property

Public Property Let InitDir(vNewValue As String)
    'Assign object's InitDir property
    sInitDir = vNewValue
End Property

Public Property Get Max() As Long
    'Return object's Max property
    Max = lMax
End Property

Public Property Let Max(vNewValue As Long)
    'Assign object's - property
    lMax = vNewValue
End Property

Public Property Get MaxFileSize() As Long
    'Return object's MaxFileSize property
    MaxFileSize = lMaxFileSize
End Property

Public Property Let MaxFileSize(vNewValue As Long)
    'Assign object's MaxFileSize property
    lMaxFileSize = vNewValue
End Property

Public Property Get Min() As Long
    'Return object's Min property
    Min = lMin
End Property

Public Property Let Min(vNewValue As Long)
    'Assign object's Min property
    lMin = vNewValue
End Property

Public Property Get Object() As Object
    'Return object's Object property
    Object = objObject
End Property

Public Property Let Object(vNewValue As Object)
    'Assign object's Object property
    objObject = vNewValue
End Property

Public Property Get FileTitle() As String
    'return object's FileTitle property
    FileTitle = sFileTitle
End Property

Public Property Let FileTitle(vNewValue As String)
    'assign object's FileTitle property
    sFileTitle = vNewValue
End Property

Public Property Get APIReturn() As Long
    'return object's APIReturn property
    APIReturn = lApiReturn
End Property

Public Property Get ExtendedError() As Long
    'return object's ExtendedError property
    ExtendedError = lExtendedError
End Property


Private Function sByteArrayToString(abBytes() As Byte) As String
    'return a string from a byte array
    Dim lBytePoint As Long
    Dim lByteVal As Long
    Dim sOut As String
    
    'init array pointer
    lBytePoint = LBound(abBytes)
    
    'fill sOut with characters in array
    While lBytePoint <= UBound(abBytes)
        
        lByteVal = abBytes(lBytePoint)
        
        'return sOut and stop if Chr$(0) is encountered
        If lByteVal = 0 Then
            sByteArrayToString = sOut
            Exit Function
        Else
            sOut = sOut & Chr$(lByteVal)
        End If
        
        lBytePoint = lBytePoint + 1
    
    Wend
    
    'return sOut if Chr$(0) wasn't encountered
    sByteArrayToString = sOut
    
End Function
Private Sub ShowFileDialog(ByVal iAction As Integer)
    
    'display the file dialog for ShowOpen or ShowSave
    
    Dim tOpenFile As OPENFILENAME
    Dim lMaxSize As Long
    Dim sFileNameBuff As String
    Dim sFileTitleBuff As String
    
    On Error GoTo ShowFileDialogError
    
    
    '***    init property buffers
    
    iAction = iAction  'Action property
    lApiReturn = 0  'APIReturn property
    lExtendedError = 0  'ExtendedError property
        
    
    '***    prepare tOpenFile data
    
    'tOpenFile.lStructSize As Long
    tOpenFile.lStructSize = Len(tOpenFile)
    
    'tOpenFile.hWndOwner As Long - init from hdc property
    tOpenFile.hwndOwner = 0& ' Just use 0 !
    
    'tOpenFile.lpstrFilter As String - init from Filter property
    tOpenFile.lpstrFilter = sAPIFilter(sFilter)
        
    'tOpenFile.iFilterIndex As Long - init from FilterIndex property
    tOpenFile.iFilterIndex = iFilterIndex
    
    'tOpenFile.lpstrFile As String
        'determine size of buffer from MaxFileSize property
        If lMaxFileSize > 0 Then
            lMaxSize = lMaxFileSize
        Else
            lMaxSize = 256
        End If
    
    'tOpenFile.lpstrFile As Long - init from FileName property
        'prepare sFileNameBuff
        sFileNameBuff = sFilename
        'pad with spaces
        While Len(sFileNameBuff) < lMaxSize - 1
            sFileNameBuff = sFileNameBuff & " "
        Wend
        'trim to length of lMaxFileSize - 1
       sFileNameBuff = Mid$(sFileNameBuff, 1, lMaxFileSize - 1)
        'null terminate
        sFileNameBuff = sFileNameBuff & Chr$(0)
    tOpenFile.lpstrFile = sFileNameBuff
    
    'nMaxFile As Long - init from MaxFileSize property
    If lMaxFileSize <> 255 Then  'default is 255
        tOpenFile.nMaxFile = lMaxFileSize
    End If
            
    'lpstrFileTitle As String - init from FileTitle property
        'prepare sFileTitleBuff
        sFileTitleBuff = sFileTitle
        'pad with spaces
        While Len(sFileTitleBuff) < lMaxSize - 1
            sFileTitleBuff = sFileTitleBuff & " "
        Wend
        'trim to length of lMaxFileSize - 1
        sFileTitleBuff = Mid$(sFileTitleBuff, 1, lMaxFileSize - 1)
        'null terminate
        sFileTitleBuff = sFileTitleBuff & Chr$(0)
    tOpenFile.lpstrFileTitle = sFileTitleBuff
        
    'tOpenFile.lpstrInitialDir As String - init from InitDir property
    tOpenFile.lpstrInitialDir = sInitDir
    
    'tOpenFile.lpstrTitle As String - init from DialogTitle property
    tOpenFile.lpstrTitle = sDialogTitle
    
    'tOpenFile.flags As Long - init from Flags property
    tOpenFile.flags = lFlags
        
    'tOpenFile.lpstrDefExt As String - init from DefaultExt property
    tOpenFile.lpstrDefExt = sDefaultExt
    
    
    '***    call the GetOpenFileName API function
    Select Case iAction
        Case 1  'ShowOpen
            lApiReturn = GetOpenFileName(tOpenFile)
        Case 2  'ShowSave
            lApiReturn = GetSaveFileName(tOpenFile)
        Case Else   'unknown action
            Exit Sub
    End Select
    
    
    '***    handle return from GetOpenFileName API function
    Select Case lApiReturn
        
        Case 0  'user canceled
        If bCancelError = True Then
            'generate an error
            Err.Raise (2001)
            Exit Sub
        End If
        
        Case 1  'user selected or entered a file
            'sFileName gets part of tOpenFile.lpstrFile to the left of first Chr$(0)
            sFilename = sLeftOfNull(tOpenFile.lpstrFile)
            sFileTitle = sLeftOfNull(tOpenFile.lpstrFileTitle)
        
        Case Else   'an error occured
            'call CommDlgExtendedError
            lExtendedError = CommDlgExtendedError
        
    End Select
    

Exit Sub

ShowFileDialogError:
    
    Exit Sub

End Sub










' InQuest injected base64 decoded content
' $zp^
' zw^R
' Z+y8^
' Z+y8^
' *'~*
' jwAy
' +xL^r
' 0:yrF
' W-'+
' 'tZ(
' x(^rB 
' z{Uz
' KnjX

INQUEST-PP=macro
