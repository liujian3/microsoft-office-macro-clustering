Attribute VB_Name = "CFormResizer"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
' Description:  Makes a userform resizeable and handles the sizing and positioning
'               of all controls, using resizing information specified in each
'               control's Tag property.
'
' Authors:      Stephen Bullen, www.oaltd.co.uk
'               Rob Bovey, www.appspro.com
'

Option Explicit

' **************************************************************
' Windows API Declarations and Constants Follow
' **************************************************************

'Find the userform's window handle

#If VBA7 Then
    Dim mhwndForm As LongPtr                                 'The userform's window handle
    Private Declare PtrSafe Function FindWindow Lib "User32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As LongPtr
    'Get the userform's window style
    Private Declare PtrSafe Function GetWindowLongptr Lib "User32" Alias "GetWindowLongA" (ByVal hwnd As LongPtr, ByVal nIndex As Long) As LongPtr
    'Set the userform's window style
    Private Declare PtrSafe Function SetWindowLongPtr Lib "User32" Alias "SetWindowLongA" (ByVal hwnd As LongPtr, ByVal nIndex As Long, ByVal dwNewLong As LongPtr) As LongPtr
#Else
    Dim mhwndForm As Long                                 'The userform's window handle
    Private Declare Function FindWindow Lib "User32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
    'Get the userform's window style
    Private Declare Function GetWindowLongptr Lib "User32" Alias "GetWindowLongA" (ByVal hwnd As Long, ByVal nIndex As Long) As Long
    'Set the userform's window style
    Private Declare Function SetWindowLongPtr Lib "User32" Alias "SetWindowLongA" (ByVal hwnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
#End If



'The offset of a window's style
Private Const GWL_STYLE As Long = (-16)

'Style to add a sizable frame
Private Const WS_THICKFRAME As Long = &H40000
'
' added min & max crw 18/10/04
'
Private Const WS_MINIMIZEBOX As Long = &H20000        'Style to add a Minimize box on the title bar
Private Const WS_MAXIMIZEBOX As Long = &H10000        'Style to add a Maximize box to the title bar
''''''''''''''''''''''''''''''''''''''''''''''''''
' Module-level Declarations Follow
''''''''''''''''''''''''''''''''''''''''''''''''''
Dim moForm As Object                                  'The userform we're handling

Dim mdWidth As Double                                 'The previous width of the form
Dim mdHeight As Double                                'The previous height of the form
Dim msRegKey As String                                'The registry key for storing the form's size and position



''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Comments: Default for the registry key to store the dimensions
'
' Date          Developer       Action
' --------------------------------------------------------------
' 05 Jun 04     Stephen Bullen  Created
'
Private Sub Class_Initialize()
'JKP 598: not needed!!!
'10  msRegKey = gsFxlNameRegKey         ''' crw 18/10/04 use name mgr registry location
End Sub



''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Comments: Properties to identify where in the registry to store
'           the userform position information
'
' Date          Developer       Action
' --------------------------------------------------------------
' 05 Jun 04     Stephen Bullen  Created
'
Public Property Let RegistryKey(sNew As String)
10  msRegKey = sNew
End Property

Public Property Get RegistryKey() As String
10  RegistryKey = msRegKey
End Property


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Comments: We're told which form to handle the resizing for,
'           set in the UserForm_Initialize event. Make the form
'           resizable and set its size and position
'
' Arguments:    oForm       The userform to handle
'
' Date          Developer       Action
' --------------------------------------------------------------
' 05 Jun 04     Stephen Bullen  Created
'
Public Property Set Form(oNew As Object)

    Dim sSizes As String, vaSizes As Variant
    #If VBA7 Then
        Dim iStyle As LongPtr
    #Else
        Dim iStyle As Long
    #End If

    'Remember the form for later
10  Set moForm = oNew

    'Get the userform's window handle
20  If Val(Application.Version) < 9 Then
30      mhwndForm = FindWindow("ThunderXFrame", moForm.Caption)    'XL97
40  Else
50      mhwndForm = FindWindow("ThunderDFrame", moForm.Caption)    'XL2000
60  End If


    'Make the form resizable
70  iStyle = GetWindowLongptr(mhwndForm, GWL_STYLE)
80  iStyle = iStyle Or WS_THICKFRAME
90  iStyle = iStyle Or WS_MINIMIZEBOX
100 iStyle = iStyle Or WS_MAXIMIZEBOX
110 SetWindowLongPtr mhwndForm, GWL_STYLE, iStyle

    'Read its dimensions from the registry (if there)
    'The string has the form of "<Top>;<Left>;<Height>;<Width>"
120 sSizes = GetSetting(msRegKey, "Forms", moForm.Name, "")

    'Remember the current size for use in the Resize routine

130 mdWidth = moForm.Width

140 mdHeight = moForm.Height

150 If sSizes <> "" Then
        'If we got a dimension string, split it into its parts
160     vaSizes = Split5(sSizes, ";")

        'Make sure we got 4 elements!
170     ReDim Preserve vaSizes(0 To 3)

        'Set the form's size and position
180     moForm.Top = Val(vaSizes(0))
190     moForm.Left = Val(vaSizes(1))
200     moForm.Height = Val(vaSizes(2))
210     moForm.Width = Val(vaSizes(3))

        'Set to manual startup position
220     moForm.StartUpPosition = 0
230 End If

End Property


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Comments: Called from the User_Form resize event. Also triggered
'           when we change the size ourself
'
' Date          Developer       Action
' --------------------------------------------------------------
' 05 Jun 04     Stephen Bullen  Created
' 18 Oct 04     Charles Williams Exit if minimised (height<30)
'
Public Sub FormResize()

    Dim dWidthAdj As Double, dHeightAdj As Double
    Dim bSomeWidthChange As Boolean
    Dim bSomeHeightChange As Boolean
    Dim sTag As String
    Dim oCtl As MSForms.control

    Static bResizing As Boolean
10  On Error Resume Next
    'Resizing can be triggered from within this routine,
    'so use a flag to prevent recursion
20  If bResizing Then Exit Sub
30  If moForm.InsideHeight = 0 Then Exit Sub          ''' crw 18/10/04
40  bResizing = True

    'Calculate the change in height and width

50  dHeightAdj = moForm.Height - mdHeight

60  dWidthAdj = moForm.Width - mdWidth

    'Check if we can perform the adjustment
    '(i.e. widths and heights can't be negative)
70  For Each oCtl In moForm.Controls

        'Read the control's Tag property, which contains the resizing info

80      sTag = UCase(oCtl.Tag)

        'If we're changing the Top, check that it won't move off the top
        'of the form
90      If InStr(1, sTag, "T", vbBinaryCompare) Then
100         If oCtl.Top + dHeightAdj * ResizeFactor(sTag, "T") <= 0 Then
110             moForm.Height = mdHeight
120         End If

130         bSomeHeightChange = True
140     End If

        'If we're changing the Left, check that it won't move off the
        'left of the form
150     If InStr(1, sTag, "L", vbBinaryCompare) Then
160         If oCtl.Left + dWidthAdj * ResizeFactor(sTag, "L") <= 0 Then
170             moForm.Width = mdWidth
180         End If

190         bSomeWidthChange = True
200     End If

        'If we're changing the Height, check that it won't go negative
210     If InStr(1, sTag, "H", vbBinaryCompare) Then
220         If oCtl.Height + dHeightAdj * ResizeFactor(sTag, "H") <= 0 Then
230             moForm.Height = mdHeight
240         End If

250         bSomeHeightChange = True
260     End If

        'If we're changing the Width, check that it won't go negative
270     If InStr(1, sTag, "W", vbBinaryCompare) Then
280         If oCtl.Width + dWidthAdj * ResizeFactor(sTag, "W") <= 0 Then
290             moForm.Width = mdWidth
300         End If

310         bSomeWidthChange = True
320     End If
330 Next                                              'Control

    'If none of the controls move or size,
    'don't allow the form to resize in that direction

340 If Not bSomeHeightChange Then moForm.Height = mdHeight
350 If Not bSomeWidthChange Then moForm.Width = mdWidth

    'Recalculate the height and width changes,
    'in case the previous checks reset them
360 dHeightAdj = moForm.Height - mdHeight
370 dWidthAdj = moForm.Width - mdWidth

    'Loop through all the controls on the form,
    'adjusting their position and size
380 For Each oCtl In moForm.Controls
390     With oCtl
400         sTag = UCase(.Tag)

            'Changing the Top
410         If InStr(1, sTag, "T", vbBinaryCompare) Then
420             .Top = .Top + dHeightAdj * ResizeFactor(sTag, "T")
430         End If

            'Changing the Left
440         If InStr(1, sTag, "L", vbBinaryCompare) Then
450             .Left = .Left + dWidthAdj * ResizeFactor(sTag, "L")
460         End If

            'Changing the Height
470         If InStr(1, sTag, "H", vbBinaryCompare) Then
480             .Height = .Height + dHeightAdj * ResizeFactor(sTag, "H")
490         End If

            'Changing the Width
500         If InStr(1, sTag, "W", vbBinaryCompare) Then
510             .Width = .Width + dWidthAdj * ResizeFactor(sTag, "W")
520         End If
530     End With
540 Next                                              'Control

    'Remember the new dimensions of the form for next time

550 mdWidth = moForm.Width

560 mdHeight = moForm.Height

    'Store the size and position in the registry
570 With moForm
580     SaveSetting msRegKey, "Forms", .Name, Str(.Top) & ";" & _
                                              Str(.Left) & ";" & _
                                              Str(.Height) & ";" & Str(.Width)
590 End With

    'Reset the recursion flag, now that we're done
600 bResizing = False

End Sub



''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Comments: Function to locate a property letter (T, L, H or W)
'           in the Tag string and return the resizing factor for it
'
' Arguments:    sTag        The full text of the control's Tag string
'               sChange     The resize letter to look for (T, L, H or W)
'
' Returns:      The percentage change factor
'
' Date          Developer       Action
' --------------------------------------------------------------
' 05 Jun 04     Stephen Bullen  Created
'
Private Function ResizeFactor(sTag As String, sChange As String)

    Dim iPos As Long, dfactor As Double

    'Locate the property letter in the tag string
10  iPos = InStr(1, sTag, sChange, vbBinaryCompare)

    'If we found it...
20  If iPos > 0 Then

        '... read the number following it
30      dfactor = Val(Mid$(sTag, iPos + 1))

        'If there was no number, use a factor of 100%
40      If dfactor = 0 Then dfactor = 1
50  End If

    'Return the factor
60  ResizeFactor = dfactor

End Function

Public Function Split5(Expression As String, _
                       Delimiter As String) As Variant
' by Donald, donald@xbeat.net, 20000916
'
' modified for VBA5 crw 8/10/2005
'
' fixed ismissing problems crw 18/10/04
'
    Const BUFFERDIM As Long = 1024
    Dim cntSplit As Long
    Dim posStart As Long
    Dim posFound As Long
    Dim lenDelimiter As Long
    Dim sArray() As String
    Dim ubArray As Long
    Dim Count As Long

10  Count = -1

    ' If IsMissing(Delimiter) Then Delimiter = " "
    ' If IsMissing(Count) Then Count = -1

    '30  If Count = 0 Then
    '        ' return unbound Variant array
    '40      Split5 = Array()
    '50      Exit Function
    '60  End If

20  lenDelimiter = Len(Delimiter)
30  If lenDelimiter = 0 Then
        ' return expression in single-element Variant array
40      Split5 = Array(Expression)
50  Else
60      posStart = 1
70      ubArray = -1
80      Do
90          If cntSplit > ubArray Then
100             ubArray = ubArray + BUFFERDIM
110             ReDim Preserve sArray(ubArray)
120         End If
130         posFound = InStr(posStart, Expression, Delimiter, vbBinaryCompare)
140         If cntSplit + 1 = Count Then
150             sArray(cntSplit) = Mid$(Expression, posStart)
160             Exit Do
170         Else
180             If posFound Then
190                 sArray(cntSplit) = Mid$(Expression, posStart, posFound - posStart)
200                 posStart = posFound + lenDelimiter
210                 cntSplit = cntSplit + 1
220             Else
230                 sArray(cntSplit) = Mid$(Expression, posStart)
240             End If
250         End If
260     Loop While posFound
        ' shrink to actual size
270     ReDim Preserve sArray(cntSplit)
        ' return string array as Variant array
280     Split5 = sArray
290 End If

End Function

Private Sub Class_Terminate()
10  Set moForm = Nothing
End Sub


Attribute VB_Name = "CMenuHandler"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private WithEvents CustomMenu As VBIDE.CommandBarEvents
Attribute CustomMenu.VB_VarHelpID = -1

Private WithEvents CustomButton As VBIDE.CommandBarEvents
Attribute CustomButton.VB_VarHelpID = -1

Private WithEvents xlApp As Excel.Application
Attribute xlApp.VB_VarHelpID = -1

Private moBar As CommandBar
Private mctlCustom As CommandBarComboBox
Private mctlLabel As CommandBarButton
Private mctlRefresh As CommandBarButton

Private Const msTag As String = "RangeNames"

Private Sub Class_Initialize()
10  On Error Resume Next
    'Remove old bar
'    aplicatie.End
20  Application.VBE.CommandBars(msTag).Delete
30  On Error GoTo locerr

40  Set moBar = Application.VBE.CommandBars.Add(Name:=msTag, temporary:=True)
50  moBar.Visible = GetSetting(gsAppName, "VBECommandBar", "Visible", True)
60  moBar.Position = msoBarTop
70  AddMenuItem
80  AddItems
90  moBar.Visible = GetSetting(gsAppName, "VBECommandBar", "Visible", True)
100 Set xlApp = Excel.Application
TidyUp:
110 Exit Sub
locerr:
End Sub


Private Sub Class_Terminate()
10  On Error Resume Next
20  Set CustomMenu = Nothing
30  Set CustomButton = Nothing
40  SaveSetting gsAppName, "VBECommandbar", "Visible", CStr(CInt(moBar.Visible))
50  moBar.Delete
60  Set moBar = Nothing
70  Set mctlLabel = Nothing
80  Set mctlRefresh = Nothing
90  Set mctlCustom = Nothing
End Sub

Private Sub CustomButton_Click(ByVal CommandBarControl As Object, handled As Boolean, CancelDefault As Boolean)
10  AddItems
End Sub

Private Sub CustomMenu_Click(ByVal cmdBar As Object, handled As Boolean, Cancel As Boolean)
10  On Error GoTo locerr
20  Application.SendKeys cmdBar.Text
TidyUp:
30  Exit Sub
locerr:
End Sub

Private Sub AddMenuItem()
'Assume no controls on bar; create them

'Label
10  Set mctlLabel = moBar.Controls.Add(msoControlButton, , , , True)
20  mctlLabel.Caption = "Insert Names"
30  mctlLabel.Style = msoButtonCaption

    'Combobox with names
40  Set mctlCustom = moBar.Controls.Add(msoControlComboBox)
50  mctlCustom.Caption = msTag
60  mctlCustom.BeginGroup = True
70  mctlCustom.Tag = msTag
80  mctlCustom.Width = 200
90  mctlCustom.DropDownWidth = 350
    ''' Set a reference to the Event object for the custom menu item.

100 Set CustomMenu = Application.VBE.Events.CommandBarEvents(mctlCustom)

    'Refresh button
110 Set mctlRefresh = moBar.Controls.Add(msoControlButton, , , , True)
120 mctlRefresh.Caption = "Refresh"
130 mctlRefresh.Style = msoButtonCaption
    ''' Set a reference to the Event object for the custom menu item.

140 Set CustomButton = Application.VBE.Events.CommandBarEvents(mctlRefresh)

End Sub

Private Sub xlapp_WindowActivate(ByVal Wb As Workbook, ByVal Wn As Window)
10  AddItems
End Sub

Private Sub AddItems()
    Dim lCount As Long
    '
    ' CRW 11/9/2008
    '
10  On Error GoTo SkipAdd
20  If Not (mctlCustom Is Nothing) Then

30      With mctlCustom
40          .Clear
            '
            ' CRW 7/12/2007
            '
50          If Not ActiveWorkbook Is Nothing Then
60              If GetNameTableCount() > 0 Then
70                  For lCount = 1 To GetNameTableCount()
80                      .AddItem ActiveWorkbook.Names(lCount).Name
90                  Next
100             End If
110         End If
120     End With
130 End If
SkipAdd:
End Sub

Attribute VB_Name = "FxlWizards"
Option Explicit
Option Base 1
Option Private Module
'---------------------------------------------------------------------------------------
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2000-2008. All rights reserved
'
' FastExcel Version 3
'
' Module to contain Wizard code
'
' written by: Charles Williams
'             Decision Models Ltd
'
'---------------------------------------------------------------------------------------

Sub StartDynWiz()
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2000-2010. All rights reserved
'
' modified 29-Oct 2010 Francais
'
    Dim ufDynWiz As Object
    Dim varDynWizTexts As Variant
10  GetLangUI
20  GetLangTexts "ufDynWizStep14", varDynWizTexts
    '30  If giFXLLang = 1 Then
    '40      Set ufDynWiz = ufDynWizStep14FR
    '50  Else
30  Set ufDynWiz = ufDynWizStep14
    '70  End If
    'ufDynWiz.Caption = "FastExcel Dynamic Range Wizard - Step 1 of 5"
40  ufDynWiz.Caption = ReworkMsg(GetLangString(2, varDynWizTexts), 1)
50  ufDynWiz.butBack.Enabled = False
60  ufDynWiz.MultiWiz14.Value = 0
70  ufDynWiz.RefEdit1.Visible = False
80  GetMaxRowsCols ActiveWorkbook
90  ufDynWiz.Show
End Sub
Attribute VB_Name = "MScreen"
'
' Description:  Contains API constants, variables, declarations and procedures
'               to demonstrate API routines related to the screen
'
' Author:       Stephen Bullen, www.oaltd.co.uk
'

Option Explicit
Option Private Module

' **************************************************************
' Declarations for the SystemMetrics, ScreenWidth and ScreenHeight example functions
' **************************************************************
''''''''''''''''''''''''''''''''''''''''''''''''''
' Constants used in the GetSystemMetrics call
''''''''''''''''''''''''''''''''''''''''''''''''''
Private Const SM_CXSCREEN = 0                         'Screen width
Private Const SM_CYSCREEN = 1                         'Screen height

''''''''''''''''''''''''''''''''''''''''''''''''''
' Public enum to expose the constants with
' friendly names in the intellisense dropdown
''''''''''''''''''''''''''''''''''''''''''''''''''

'Public Enum SystemMetricsConstants
'    smScreenWidth = SM_CXSCREEN
'    smScreenHeight = SM_CYSCREEN
'End Enum

''''''''''''''''''''''''''''''''''''''''''''''''''
' Function Declarations
''''''''''''''''''''''''''''''''''''''''''''''''''
'Get a specific system-related metric
#If VBA7 Then

    Private Declare PtrSafe Function GetSystemMetrics Lib "User32" (ByVal nIndex As Long) As Long

    ' **************************************************************
    ' Declarations for the PointsPerPixel example function
    ' **************************************************************
    ''''''''''''''''''''''''''''''''''''''''''''''''''
    ' Constants used in the GetDeviceCaps call
    ''''''''''''''''''''''''''''''''''''''''''''''''''
    Private Const LOGPIXELSX = 88                         '  Pixels/inch in X

    ''''''''''''''''''''''''''''''''''''''''''''''''''
    ' Module constants used in the example function
    ''''''''''''''''''''''''''''''''''''''''''''''''''
    'A point is defined as 1/72 inches
    Private Const POINTS_PER_INCH As Long = 72

    ''''''''''''''''''''''''''''''''''''''''''''''''''
    ' Function Declarations
    ''''''''''''''''''''''''''''''''''''''''''''''''''
    'Get a handle to the Device Context (a drawing layer) for a window

    Private Declare PtrSafe Function GetDC Lib "User32" (ByVal hwnd As LongPtr) As LongPtr

    'Get the capabilities of a device, from its Decive Context

    Private Declare PtrSafe Function GetDeviceCaps Lib "gdi32" (ByVal hDC As LongPtr, ByVal nIndex As Long) As Long

    'Release the handle to the Device Context, to tidy up

    Private Declare PtrSafe Function ReleaseDC Lib "User32" (ByVal hwnd As LongPtr, ByVal hDC As LongPtr) As Long
#Else

    Private Declare Function GetSystemMetrics Lib "User32" (ByVal nIndex As Long) As Long

    ' **************************************************************
    ' Declarations for the PointsPerPixel example function
    ' **************************************************************
    ''''''''''''''''''''''''''''''''''''''''''''''''''
    ' Constants used in the GetDeviceCaps call
    ''''''''''''''''''''''''''''''''''''''''''''''''''
    Private Const LOGPIXELSX = 88                         '  Pixels/inch in X

    ''''''''''''''''''''''''''''''''''''''''''''''''''
    ' Module constants used in the example function
    ''''''''''''''''''''''''''''''''''''''''''''''''''
    'A point is defined as 1/72 inches
    Private Const POINTS_PER_INCH As Long = 72

    ''''''''''''''''''''''''''''''''''''''''''''''''''
    ' Function Declarations
    ''''''''''''''''''''''''''''''''''''''''''''''''''
    'Get a handle to the Device Context (a drawing layer) for a window

    Private Declare Function GetDC Lib "User32" (ByVal hwnd As Long) As Long

    'Get the capabilities of a device, from its Decive Context

    Private Declare Function GetDeviceCaps Lib "gdi32" (ByVal hDC As Long, ByVal nIndex As Long) As Long

    'Release the handle to the Device Context, to tidy up

    Private Declare Function ReleaseDC Lib "User32" (ByVal hwnd As Long, ByVal hDC As Long) As Long
#End If

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Comments: Wrapper for the GetSystemMetrics API function,
'           using the SystemMetricsConstants Enum
'
' Arguments:    uIndex      One of the SystemMetricsConstants values,
'                           specifying which metric to retrieve
'
' Returns:      Long        The value of the required metric
'
' Date          Developer       Action
' --------------------------------------------------------------
' 02 Jun 04     Stephen Bullen  Created
'
Public Function SystemMetrics(ByVal uIndex As Long) As Long
10  SystemMetrics = GetSystemMetrics(uIndex)
End Function


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Comments: Retrieve the width of the screen, in pixels
'
' Arguments:    None
'
' Returns:      Long        The width of the screen, in pixels
'
' Date          Developer       Action
' --------------------------------------------------------------
' 02 Jun 04     Stephen Bullen  Created
'
Public Function ScreenWidth() As Long
10  ScreenWidth = GetSystemMetrics(SM_CXSCREEN)
End Function


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Comments: Retrieve the height of the screen, in pixels
'
' Arguments:    None
'
' Returns:      Long        The height of the screen, in pixels
'
' Date          Developer       Action
' --------------------------------------------------------------
' 02 Jun 04     Stephen Bullen  Created
'
Public Function ScreenHeight() As Long
10  ScreenHeight = GetSystemMetrics(SM_CYSCREEN)
End Function


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Comments: Calculates the size of a pixel, in points.
'           This depends on the user's DPI setting, from
'           Control Panel > Display > Settings > Advanced > General
'           The 'Normal' setting is 96dpi, in which 1 pixel = 0.75 points
'           The 'Large' setting is 120dpi, in which 1 pixel = 0.8 points
'
' Arguments:    None
'
' Returns:      Double      The size of a pixel, in points.
'
' Date          Developer       Action
' --------------------------------------------------------------
' 02 Jun 04     Stephen Bullen  Created
'
Public Function PointsPerPixel() As Double
    #If VBA7 Then
        Dim hDC As LongPtr
    #Else
        Dim hDC As Long
    #End If
    Dim lDotsPerInch As Long

    'Get the Device Context of the desktop window (i.e. the screen)
10  hDC = GetDC(0)

    'Get the user's DPI setting
20  lDotsPerInch = GetDeviceCaps(hDC, LOGPIXELSX)

    'Divide the 72 points-per-inch by the dpi to give the width of a pixel
30  PointsPerPixel = POINTS_PER_INCH / lDotsPerInch

    'Release the Device Context, to tidy up
40  ReleaseDC 0, hDC

End Function

Attribute VB_Name = "NameEventClass"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Option Base 1
Option Compare Text

Public WithEvents NameApp As Application
Attribute NameApp.VB_VarHelpID = -1


'***************************************************************
'*                                                             *
'* All subs and functions in this module:                      *
'* Copyright |fffd| Decision Models 2002-2010. All rights Reserved  *
'* except where shown as                                       *
'* Copyright |fffd| J.K. Pieterse 2002-2010. All Rights Reserved    *
'*                                                             *
'***************************************************************
'
' application events module for Name manager
'

'Public clSelectEvent As New SelectEventClass          ''' event class variable: crw 8 Jan 2003
Private mbDisableSheetEvent As Boolean

Private Sub NameApp_SheetActivate(ByVal Sh As Object)
'
' Copyright Decision Models 2002-2010. All Rights Reserved
'
'JKP Jan 10 2003 check if userform is showing and if event is disabled
10  If Not gbFormIsShowing Or mbDisableSheetEvent Then Exit Sub
20  If gbRefsActiveSheet Then
30      Application.EnableEvents = False
40      CheckFixNames
50      gbListChanged = False                         ''' no command to cancel
60      Application.EnableEvents = True
70  End If
End Sub



Private Sub NameApp_WorkbookActivate(ByVal Wb As Excel.Workbook)
'
' Copyright Decision Models 2002-2010. All Rights Reserved
'
'JKP 13-7-2009: update VBA menu
10  CreateVBEMenu
    'JKP Jan 10 2003 check if userform is showing
20  If Not gbFormIsShowing Then Exit Sub
30  CheckFixNames
40  gbListChanged = False                             ''' no command to cancel
50  If Not ActiveWorkbook Is Nothing Then
60      gfrmNameManager.Caption = gsAppName & " - " & ActiveWorkbook.Name
        '
        ' need to reset the resizer class after changing the caption !!!
        '
70      gfrmNameManager.ResetResizer
80  End If
End Sub

Public Property Get DisableSheetEvent() As Boolean
10  DisableSheetEvent = mbDisableSheetEvent
End Property

Public Property Let DisableSheetEvent(ByVal bDisableSheetEvent As Boolean)
10  mbDisableSheetEvent = bDisableSheetEvent
End Property
Attribute VB_Name = "Sheet1"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Attribute VB_Name = "Sheet5"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Attribute VB_Name = "Sheet6"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True


Option Explicit

Attribute VB_Name = "ThisWorkbook"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True

Attribute VB_Name = "clsFoundObjects"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

'JKP Build 626: compare text, otherwise Like does not work as expected!
Option Compare Text                                   'Replace needs this!

Private moFoundObject As Object
Private msFoundProperty As String
Private msFoundString As String
Private msFoundInBook As String

Private mlDoReplace As Long

Private Sub Class_Terminate()
10  Set moFoundObject = Nothing
End Sub

Private Function ReplaceVBAString(ByVal sFoundString As String, ByVal sOldName As String, ByVal sNewName As String)
'-------------------------------------------------------------------------
' Procedure : ReplaceVBAString
' Company   : JKP Application Development Services (c)
' Author    : Jan Karel Pieterse (www.jkp-ads.com)
' Created   : 10-2-2015
' Purpose   : Replace a name in VBA
'-------------------------------------------------------------------------
    Dim vValidCharAfter As Variant
    Dim vValidCharBefore As Variant
    Dim lCharAfter As Long
    Dim lCharbefore As Long
    Dim sToReplace As String
    Dim sToFind As String
10  vValidCharAfter = Array("""", ", ", ")", "]")   'Valid characters after a name: '"' ', ' ')' ']'
20  vValidCharBefore = Array("""", ", ", "(", "[")  'Valid characters before a name: '"' ', ' '(' '['
30  For lCharAfter = LBound(vValidCharAfter) To UBound(vValidCharAfter)
40      For lCharbefore = LBound(vValidCharBefore) To UBound(vValidCharBefore)
50          sToReplace = vValidCharBefore(lCharbefore) & sNewName & vValidCharAfter(lCharAfter)
60          sToFind = vValidCharBefore(lCharbefore) & sOldName & vValidCharAfter(lCharAfter)
70          If InStr(sFoundString, sToFind) > 0 Then
80              sFoundString = Replace(sFoundString, sToFind, sToReplace)
90          End If
100     Next
110 Next
120 ReplaceVBAString = sFoundString
End Function

Public Property Get FoundObject() As Object
10  Set FoundObject = moFoundObject
End Property

Public Property Set FoundObject(objFoundObject As Object)
10  Set moFoundObject = objFoundObject
End Property

Public Property Get FoundProperty() As String
10  FoundProperty = msFoundProperty
End Property

Public Property Let FoundProperty(ByVal sFoundProperty As String)
10  msFoundProperty = sFoundProperty
End Property

Public Property Get FoundString() As String
10  FoundString = msFoundString
End Property

Public Property Let FoundString(ByVal sFoundString As String)
10  msFoundString = sFoundString
End Property

Public Property Get FoundObjName() As String
10  With FoundObject
20      Select Case TypeName(FoundObject)
        Case "Range"
30          FoundObjName = .Parent.Name & "!" & .Address & ", " & .Cells(1, 1).FormulaLocal
40      Case "ChartTitle"
50          On Error Resume Next
60          FoundObjName = ""
70          Err.Clear
80          FoundObjName = "Chart title on " & .Parent.Name & ", " & Me.FoundString
90      Case "Shape"
100         FoundObjName = "Shape " & .Name & " on " & .Parent.Name & ", " & .Formula
110     Case "OLEObject"
120         Select Case FoundProperty
            Case "ListFillRange"
130             FoundObjName = "OLE object " & .Name & " on " & .Parent.Name & ": ListFillRange, " & .LinkedCell
140         Case "LinkedCell"
150             FoundObjName = "OLE object " & .Name & " on " & .Parent.Name & ": LinkedCell, " & .LinkedCell
160         End Select
170     Case "TextBox", "Picture", "Button", "Arc", "Drawing", "Oval", "Rectangle"
180         FoundObjName = "Drawing object " & .Name & " on " & .Parent.Name & ", " & .Formula
190     Case "CheckBox", "DropDown", "ListBox", "Spinner", "ScrollBar", "OptionButton"
200         Select Case FoundProperty
            Case "ListFillRange"
210             FoundObjName = "Control " & .Name & " on " & .Parent.Name & ", ListFillRange, " & .ListFillRange
220         Case "LinkedCell"
230             FoundObjName = "Control " & .Name & " on " & .Parent.Name & ": LinkedCell, " & .LinkedCell
240         End Select
250     Case "Name"
260         FoundObjName = "Name: " & .Name & ", " & .RefersToLocal
270     Case "Series"
280         FoundObjName = "Chart Series on " & .Parent.Parent.Name & ": " & .Formula
290     Case "Validation"
300         Select Case FoundProperty
            Case "Formula1"
310             FoundObjName = "Validation formula. Cell:" & .Parent.Address & ", " & .Formula1
320         Case "Formula2"
330             FoundObjName = "Validation formula. Cell:" & .Parent.Address & ", " & .Formula2
340         End Select
350     Case "FormatCondition"
360         Select Case FoundProperty
            Case "Formula1"
370             FoundObjName = "Conditional formatting formula. Cell:" & .Parent.Address & ", " & .Formula1
380         Case "Formula2"
390             FoundObjName = "Conditional formatting formula. Cell:" & .Parent.Address & ", " & .Formula2
400         End Select
410     Case "CodeModule"
420         FoundObjName = FoundObject.Name & ", " & FoundString
        Case "Hyperlink"
            FoundObjName = "Hyperlink. Cell: " & .Parent.Address & ", " & FoundString
430     End Select
440 End With
End Property

Public Function Rename(ByVal sOldName As String, ByVal sNewName As String) As Boolean
    Dim sStr As String
    Dim lPos As Long
    Dim oActive As Range
    Dim oPrev As Range
    Dim vSheets As Variant
    Dim sFound As String
10  On Error Resume Next
20  Err.Clear
30  sStr = FoundString
40  With FoundObject
        'determine of local name and on localised sheet
50      If TypeName(FoundObject) = "Range" Then
60          If IsNameLocal(sOldName, False) Then
70              If InStr(sOldName, "!") > 0 Then
                    'JKP Build 626: Test yielded false positives when sheets exist whos names are contained in other sheet names,
                    'Like 'Sheet1 (2)' and Sheet1
80                  If Replace(Replace(Replace(sOldName, Mid(sOldName, InStr(sOldName, "!") + 1, Len(sOldName)), ""), "'", ""), "!", "") = FoundObject.Parent.Name Then
90                      sOldName = Mid(sOldName, InStr(sOldName, "!") + 1, Len(sOldName))
100                     sNewName = Mid(sNewName, InStr(sNewName, "!") + 1, Len(sNewName))
110                 End If
120             End If
130         End If
140     End If
150     If TypeName(FoundObject) <> "CodeModule" Then
160         While IsNameThere(sStr, sOldName) > 0
170             lPos = IsNameThere(sStr, sOldName)
180             sStr = Replace5(sStr, sOldName, sNewName, lPos, 1, vbTextCompare)
190         Wend
200     Else
210         sStr = Replace5(sStr, Chr(34) & sOldName & Chr(34), Chr(34) & sNewName & Chr(34))
220         sStr = Replace5(sStr, "(" & sOldName & ")", "(" & sNewName & ")")
230         sStr = Replace5(sStr, "[" & sOldName & "]", "[" & sNewName & "]")
240         If InStr(sOldName, "!") Then
250             sStr = Replace5(sStr, Chr(34) & Mid(sOldName, InStr(sOldName, "!") + 1, Len(sOldName)) & Chr(34), Chr(34) & Mid(sNewName, InStr(sNewName, "!") + 1, Len(sNewName)) & Chr(34))
260             sStr = Replace5(sStr, "(" & Mid(sOldName, InStr(sOldName, "!") + 1, Len(sOldName)) & ")", "(" & Mid(sNewName, InStr(sNewName, "!") + 1, Len(sNewName)) & ")")
270         End If
280     End If
290     If gbAcknowledge And (Not gbNoMoreAcknowledge) Then
300         If TypeName(FoundObject) = "CodeModule" Then
310             Application.Visible = False
320             SelectVBA FoundObject, CLng(Mid(FoundProperty, InStr(FoundProperty, " ")))
330         Else
340             Application.Visible = True
350             SelectObj FoundObject
360         End If
370         DoReplace = ShowMsg(ReworkMsg(gsMsgs(100), sOldName, sNewName, FoundObjName), vbQuestion + vbYesNoCancel)
380         If IsShiftPressed Then
390             gbNoMoreAcknowledge = True
400             Do
410                 DoEvents
420             Loop Until Not IsShiftPressed
430         End If
440     Else
450         DoReplace = vbYes
460     End If
470     Err.Clear
480     Select Case DoReplace
        Case vbYes
490         Select Case TypeName(FoundObject)
            Case "Name"
500             If IsNameRelative(FindName(.Name).RefersToR1C1) Then
510                 On Error Resume Next
520                 Set oPrev = ActiveCell
530                 vSheets = FindReferencedSheets(.RefersTo)
540                 If UBound(vSheets) > 0 Then
                        'Somehow, now we really need cel A1 activated, otherwise the relative references change!
                        'JKP Build 566: prevent sheetchange event
550                     gclNameEvent.DisableSheetEvent = True
560                     Worksheets(vSheets(1)).Activate
                        'JKP Build 566: restore sheetchange event
570                     gclNameEvent.DisableSheetEvent = False
580                     Range("A1").Select
590                     sStr = FindName(.Name).RefersTo
600                     sStr = Replace5(sStr, sOldName, sNewName, lPos, 1, vbTextCompare)
610                     .RefersTo = sStr
                        'JKP Build 566: prevent sheetchange event
620                     gclNameEvent.DisableSheetEvent = True
630                     oPrev.Parent.Activate
                        'JKP Build 566: restore sheetchange event
640                     gclNameEvent.DisableSheetEvent = False
650                     oPrev.Select
660                 Else
670                     ShowMsg ReworkMsg(gsMsgs(92), .Name), vbOKOnly + vbInformation
680                 End If
690             Else
700                 .RefersTo = sStr
710             End If
720         Case "Range"
730             If .HasArray Then
740                 .FormulaArray = sStr
750             Else
760                 .Formula = sStr
770             End If
780         Case "FormatCondition"
790             If FoundProperty = "Formula1" Then
800                 .Modify Type:=.Type, Formula1:=sStr, Operator:=.Operator
810             Else
820                 .Modify Type:=.Type, Formula2:=sStr, Operator:=.Operator
830             End If
840         Case "Validation"
850             If FoundProperty = "Formula1" Then
860                 .Modify Type:=.Type, Formula1:=sStr
870             Else
880                 .Modify Type:=.Type, Formula2:=sStr
890             End If
900         Case "Shape"
910             .OnAction = sStr
920         Case "OLEObject"
930             Select Case FoundProperty
                Case "LinkedCell"
940                 .LinkedCell = Right(sStr, Len(sStr) - 1)
950                 If .LinkedCell = Right(sStr, Len(sStr) - 1) Then
960                     Err.Clear
970                 End If
980             Case "ListFillRange"
990                 .ListFillRange = Right(sStr, Len(sStr) - 1)
1000                If .ListFillRange = Right(sStr, Len(sStr) - 1) Then
1010                    Err.Clear
1020                End If
1030            End Select
1040        Case "TextBox", "Picture", "Button", "Arc", "Drawing", "Oval", "Rectangle"
1050            Select Case FoundProperty
                Case "Formula"
1060                .Formula = Right(sStr, Len(sStr) - 1)
1070            End Select
1080        Case "CheckBox", "DropDown", "ListBox", "Spinner", "ScrollBar", "OptionButton", "ComboBox"
1090            Select Case FoundProperty
                Case "LinkedCell"
1100                If sStr Like "=*" Then
1110                    .LinkedCell = Right(sStr, Len(sStr) - 1)
1120                Else
1130                    .LinkedCell = sStr
1140                End If
1150            Case "ListFillRange"
1160                If sStr Like "=*" Then
1170                    .ListFillRange = Right(sStr, Len(sStr) - 1)
1180                Else
1190                    .ListFillRange = sStr
1200                End If
1210            End Select
1220        Case "PivotTable"
1230            Select Case FoundProperty
                    'Not sure, but I suspect not needed
                Case "Connection"
1240                .Connection = sStr
                    'Not sure, but I suspect not needed
1250            Case "CommandText"
1260                .CommandText = sStr
1270            Case "SourceData"
1280                .SourceData = sStr
1290            End Select
                'Not sure, but I suspect not needed
1300        Case "QueryTable"
1310            Select Case FoundProperty
                Case "Connection"
1320                .Connection = sStr
1330            Case "CommandText"
1340                .CommandText = sStr
1350            End Select
            Case "Hyperlink"
                Select Case FoundProperty
                Case "Address"
                    .Address = sStr
                Case "SubAddress"
                    .SubAddress = sStr
                End Select
1360        Case "Series"
1370            sStr = Replace5(sStr, "!'", "!")
1380            sStr = Replace5(sStr, "',", ",")
1390            .Formula = sStr
1400        Case "DataLabel"
1410            sStr = Application.ConvertFormula(sStr, xlA1, xlR1C1)
1420            .Caption = sStr
1430        Case "ChartTitle"
1440            sStr = Application.ConvertFormula(sStr, xlA1, xlR1C1)
1450            .Caption = sStr
1460        Case "AxisTitle"
1470            sStr = Application.ConvertFormula(sStr, xlA1, xlR1C1)
1480            .Caption = sStr
1490        Case "CodeModule"
1500            With FoundObject
1510                lPos = CLng(Mid(FoundProperty, InStr(FoundProperty, " ")))
1520                If FoundString Like "*""" & sOldName & """*" Or FoundString Like "*, " & sOldName & """*" Or FoundString Like "*""" & sOldName & ", *" _
                       Or FoundString Like "*(" & sOldName & ")*" Or FoundString Like "*[[]" & sOldName & "[]]*" Then
1530                    sStr = ReplaceVBAString(FoundString, sOldName, sNewName)
1540                    .DeleteLines lPos, 1
1550                    .InsertLines lPos, sStr
1560                End If
1570            End With
1580        End Select
1590    Case vbNo
1600        Rename = False
1610    Case vbCancel
1620        Rename = False
1630        gbBreak = True
1640    End Select
1650 End With
1660 If Err.Number = 0 Then
1670    Rename = True
1680 End If
End Function

Public Property Get FoundInBook() As String
10  FoundInBook = msFoundInBook
End Property

Public Property Let FoundInBook(ByVal sFoundInBook As String)
10  msFoundInBook = sFoundInBook
End Property

Public Property Get DoReplace() As Long
10  DoReplace = mlDoReplace
End Property

Public Property Let DoReplace(ByVal lDoReplace As Long)
10  mlDoReplace = lDoReplace
End Property


Attribute VB_Name = "fxlHelp"
Option Explicit
'---------------------------------------------------------------------------------------
'Windows API calls:
'---------------------------------------------------------------------------------------
'Launch the HTML help files in the HTML Help viewer
#If VBA7 Then
    Private Declare PtrSafe Function HTMLHelpShowContents Lib "hhctrl.ocx" _
            Alias "HtmlHelpA" (ByVal hwnd As LongPtr, _
                               ByVal lpHelpFile As String, _
                               ByVal wCommand As Long, _
                               ByVal dwData As Long) As Long

    'Launch the HTML help files in the HTML Help viewer with the Search tab active
    Private Declare PtrSafe Function HTMLHelpShowSearch Lib "hhctrl.ocx" _
            Alias "HtmlHelpA" (ByVal hwnd As LongPtr, _
                               ByVal lpHelpFile As String, _
                               ByVal wCommand As Long, _
                               ByRef dwData As tagHH_FTS_QUERY) As Long


#Else
    Private Declare Function HTMLHelpShowContents Lib "hhctrl.ocx" _
                                                  Alias "HtmlHelpA" (ByVal hwnd As Long, _
                                                                     ByVal lpHelpFile As String, _
                                                                     ByVal wCommand As Long, _
                                                                     ByVal dwData As Long) As Long

    'Launch the HTML help files in the HTML Help viewer with the Search tab active
    Private Declare Function HTMLHelpShowSearch Lib "hhctrl.ocx" _
                                                Alias "HtmlHelpA" (ByVal hwnd As Long, _
                                                                   ByVal lpHelpFile As String, _
                                                                   ByVal wCommand As Long, _
                                                                   ByRef dwData As tagHH_FTS_QUERY) As Long

#End If
'---------------------------------------------------------------------------------------
'User Defined Types
'---------------------------------------------------------------------------------------
Private Type tagHH_FTS_QUERY
    'Date Created : Unknown
    'Source       : http://frogleg.mvps.org/helptechnologies/htmlhelp/
    'Type Purpose : Required paramaters for accessing the HTML Help Search tab
    cbStruct As Long
    fUniCodeStrings As Long
    pszSearchQuery As String
    iProximity As Long
    fStemmedSearch As Long
    fTitleOnly As Long
    fExecute As Long
    pszWindow As String
End Type

'---------------------------------------------------------------------------------------
'Public Enums
'---------------------------------------------------------------------------------------
'Public Enum HelpType
''Date Created : October 13,2006 11:09
''Author       : Ken Puls (www.excelguru.ca)
''Enum Purpose : Allow use of constants in the 'HelpType' argument
'    HelpType_Show = 0
'    HelpType_Contents = 1
'    HelpType_Index = 2
'    HelpType_Search = 3
'    HelpType_Context = 4
'End Enum

'---------------------------------------------------------------------------------------
'Public Functions
'---------------------------------------------------------------------------------------
Public Sub ShowHelp(ByVal lType As Long, ByVal strHelpPath As String, _
                    Optional ByVal lContextID As Long = 0)
'Date Created : October 13,2006 11:09
'Author       : Ken Puls (www.excelguru.ca)
'Macro Purpose: Open a CHM (Compiled HTML Help) file at the correct location as
'               specified by the user

    Dim lSuccess As Long
    Dim HH_FTS_QUERY As tagHH_FTS_QUERY

    'Check what point user wants file opened at
10  Select Case lType
    Case Is = 0
        'Display the help file at last selected item
20      lSuccess = HTMLHelpShowContents(0, strHelpPath, &H0, 0)
30  Case Is = 1
        'Display the table of contents at last selected item
40      lSuccess = HTMLHelpShowContents(0, strHelpPath, &H1, 0)
50  Case Is = 2
        'Display the index.
60      lSuccess = HTMLHelpShowContents(0, strHelpPath, &H2, 0)
70  Case Is = 3
        'Display full text search.
80      With HH_FTS_QUERY
90          .cbStruct = Len(HH_FTS_QUERY)
100         .fUniCodeStrings = 0&
110         .pszSearchQuery = ""
120         .iProximity = 0&
130         .fStemmedSearch = 0&
140         .fTitleOnly = 0&
150         .fExecute = 1&
160         .pszWindow = ""
170     End With
180     lSuccess = HTMLHelpShowSearch(0, strHelpPath, _
                                      &H3, HH_FTS_QUERY)
190 Case Is = 4
200     If lContextID = 0 Then
            'No context provided, open at top level
210         lSuccess = HTMLHelpShowContents(0, strHelpPath, &H1, 0)
220     Else
            'Ensure that Contents window is active
230         HTMLHelpShowContents 0, strHelpPath, &H1, 0
            'Open at context ID provided
240         lSuccess = HTMLHelpShowContents(0, strHelpPath, &HF, lContextID)
250     End If
260 End Select

270 If lSuccess = 0 Then
        'Was not succesful opening file
        'ShowHelp = False
280 Else
        'Opened successfully
        'ShowHelp = True
290 End If

End Sub


Attribute VB_Name = "fxlLanguage"
Option Explicit
Option Base 1
Option Private Module
Option Compare Text

Public Const gcLangBook As String = "fxlLang.xla"               ' name of workbook containing language strings
Public giFXLLang As Long                                ' fxl language: -1, Auto, 0=English, 2=French
Public gvarGlobalTexts As Variant                       ' global translated texts
Public gvarCalcTimeTexts As Variant                     ' calculation timing translated texts
Public gvarCleanTexts As Variant
Public giLang As Long                                   ' NM Language: -1 Auto, 0 Englisg, 1 Dansk, ...
'---------------------------------------------------------------------------------------
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2010-2013. All rights reserved
'
Sub GetLangTexts(strTopic As String, varLangText As Variant)
    Dim oLangBook As Workbook
10  On Error Resume Next
20  Set oLangBook = Workbooks(gcLangBook)
30  If oLangBook Is Nothing Then
40      Set oLangBook = Workbooks.Open(ThisWorkbook.Path & "\" & gcLangBook)
50  End If
60  On Error GoTo 0
70  If oLangBook Is Nothing Then
80      Application.ScreenUpdating = True
90      gjErr = 1
100     MsgBox "Unable to find Language File '" & ThisWorkbook.Path & "\" & gcLangBook & "' - Please Reinstall FastExcel", vbOKOnly + vbCritical, gstrFastXL
110     ThisWorkbook.Close
120 End If
130 varLangText = Workbooks(gcLangBook).Names(strTopic).RefersToRange.CurrentRegion
End Sub
Function GetLangString(jMsgID As Long, varLangText As Variant) As String
    Dim j As Long

10  GetLangString = "LangText not Found " & CStr(jMsgID)
20  On Error Resume Next
30  For j = 1 To UBound(varLangText)
40      If CLng(varLangText(j, 1)) = jMsgID Then
50          GetLangString = CStr(varLangText(j, giFXLLang + 2))
60          Exit For
70      End If
80  Next j
End Function
Sub GetGlobalTexts()
10  GetLangTexts "Globals", gvarGlobalTexts
20  GetLangTexts "CalcTimes", gvarCalcTimeTexts
End Sub
Sub GetLangUI()
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2010. All rights reserved
'
' determine Excel's UI Language & Set FXL and NM Language
'
    Dim jSetLang As Long
    Dim vLang As Variant
    '
    ' FXL Language
    '
10  jSetLang = CInt(GetSetting(gstrFastXL, "Settings", "FXLLang", -1))
20  If jSetLang = -1 Then
30      giFXLLang = 0
40      If Val(Application.Version) >= 9 Then
50          On Error Resume Next
60          vLang = Application.VLookup(Application.LanguageSettings.LanguageID(2), ThisWorkbook.Names("LCIDS").RefersToRange, 4, False)
70          If Not IsError(vLang) Then giFXLLang = CLng(vLang)
80      End If
90  Else
100     giFXLLang = jSetLang
110 End If
    '
    ' NM Language
    '
120 jSetLang = CInt(GetSetting(gsFxlNameRegKey, "Settings", "Lang", -1))
130 If jSetLang = -1 Then
140     giLang = 0
150     If Val(Application.Version) >= 9 Then
160         On Error Resume Next
170         vLang = Application.VLookup(Application.LanguageSettings.LanguageID(2), ThisWorkbook.Names("LCIDS").RefersToRange, 3, False)
180         If Not IsError(vLang) Then giLang = CLng(vLang)
190     End If
200 Else
210     giLang = jSetLang
220 End If
230 ReadMessages


End Sub
Function ReworkMsg(ByVal sMsg As String, _
                   Optional ByVal Arg1 As String, _
                   Optional ByVal Arg2 As String, _
                   Optional ByVal Arg3 As String, _
                   Optional ByVal Arg4 As String, _
                   Optional ByVal Arg5 As String) As String
10  If Not IsMissing(Arg1) Then
20      sMsg = Replace5(sMsg, "_ARG1_", Arg1)
30  End If
40  If Not IsMissing(Arg2) Then
50      sMsg = Replace5(sMsg, "_ARG2_", Arg2)
60  End If
70  If Not IsMissing(Arg3) Then
80      sMsg = Replace5(sMsg, "_ARG3_", Arg3)
90  End If
100 If Not IsMissing(Arg4) Then
110     sMsg = Replace5(sMsg, "_ARG4_", Arg4)
120 End If
130 If Not IsMissing(Arg5) Then
140     sMsg = Replace5(sMsg, "_ARG5_", Arg5)
150 End If
160 sMsg = Replace5(sMsg, "_NEWLINE_", vbNewLine)
170 ReworkMsg = sMsg
End Function

Sub ReadMessages()
    Dim iCount As Long
    Dim INMLang As Long
    Dim vLang As Variant
    '
    ' CRW 4/11/2010 - Auto
    '
10  ReDim gsMsgs(10)
    '
    ' Auto
    '
20  If giLang = -1 Then
        '
        ' find language based on LCID
        '
30      INMLang = 0
40      If Val(Application.Version) >= 9 Then
50          On Error Resume Next
60          vLang = Application.VLookup(Application.LanguageSettings.LanguageID(2), ThisWorkbook.Names("LCIDS").RefersToRange, 3, False)
70          If Not IsError(vLang) Then INMLang = CLng(vLang)
80          On Error GoTo 0
90      End If
100 Else
110     INMLang = giLang
120 End If

130 For iCount = 1 To 500
140     If ThisWorkbook.Names("Messages").RefersToRange.Offset(iCount - 1, INMLang).Value = "" Then Exit For
150     ReDim Preserve gsMsgs(iCount)
160     gsMsgs(iCount) = ThisWorkbook.Names("Messages").RefersToRange.Offset(iCount - 1, INMLang).Value
170 Next
    '
    ' only make menu if not FXL version
    '
180 If Not gbFxl Then MakeMenu
190 ReDim gsTxtufNameManager(10)
200 For iCount = 1 To 500
210     If ThisWorkbook.Names("ufNameManager").RefersToRange.Offset(iCount - 1, INMLang).Value = "" Then Exit For
220     ReDim Preserve gsTxtufNameManager(iCount)
230     gsTxtufNameManager(iCount) = ThisWorkbook.Names("ufNameManager").RefersToRange.Offset(iCount - 1, INMLang).Value
240 Next
250 For iCount = 1 To 500
260     If ThisWorkbook.Names("uflocalsheets").RefersToRange.Offset(iCount - 1, INMLang).Value = "" Then Exit For
270     ReDim Preserve gsTxtufLocalSheets(iCount)
280     gsTxtufLocalSheets(iCount) = ThisWorkbook.Names("uflocalsheets").RefersToRange.Offset(iCount - 1, INMLang).Value
290 Next
300 For iCount = 1 To 500
310     If ThisWorkbook.Names("ufanalyse").RefersToRange.Offset(iCount - 1, INMLang).Value = "" Then Exit For
320     ReDim Preserve gsTxtufAnalyse(iCount)
330     gsTxtufAnalyse(iCount) = ThisWorkbook.Names("ufanalyse").RefersToRange.Offset(iCount - 1, INMLang).Value
340 Next
350 For iCount = 1 To 50
360     If ThisWorkbook.Names("Language").RefersToRange.Offset(0, iCount - 1).Value = "" Then Exit For
370     ReDim Preserve gsTxtLang(iCount)
380     gsTxtLang(iCount) = ThisWorkbook.Names("Language").RefersToRange.Offset(0, iCount - 1).Value
390 Next
400 ReDim gsTxtufAddName(10)
410 For iCount = 1 To 500
420     If ThisWorkbook.Names("ufAddName").RefersToRange.Offset(iCount - 1, INMLang).Value = "" Then Exit For
430     ReDim Preserve gsTxtufAddName(iCount)
440     gsTxtufAddName(iCount) = ThisWorkbook.Names("ufAddName").RefersToRange.Offset(iCount - 1, INMLang).Value
450 Next
460 For iCount = 1 To 500
470     If ThisWorkbook.Names("ufwhereused").RefersToRange.Offset(iCount - 1, INMLang).Value = "" Then Exit For
480     ReDim Preserve gsTxtufWhereUsed(iCount)
490     gsTxtufWhereUsed(iCount) = ThisWorkbook.Names("ufwhereused").RefersToRange.Offset(iCount - 1, INMLang).Value
500 Next
510 For iCount = 1 To 500
520     If ThisWorkbook.Names("ufSelectARange").RefersToRange.Offset(iCount - 1, INMLang).Value = "" Then Exit For
530     ReDim Preserve gstxtufSelectARange(iCount)
540     gstxtufSelectARange(iCount) = ThisWorkbook.Names("ufSelectARange").RefersToRange.Offset(iCount - 1, INMLang).Value
550 Next
'560 ListErrorCodes
End Sub

Attribute VB_Name = "fxlNMExcel2007"
Option Explicit
Option Private Module

Dim moRibbon As IRibbonUI    'IRibbonUI

'Note conditional compilation!  Used because VBA7 (64bit) uses a different API declaration syntax
#If VBA7 Then
    Private Declare PtrSafe Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" _
           (ByRef destination As Any, ByRef SOURCE As Any, ByVal Length As Long)
#Else
    Private Declare Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" _
                                  (ByRef destination As Any, ByRef SOURCE As Any, ByVal Length As Long)
#End If

'Rememeber the pointer to the ribbon object so you can invalidate it and such.
#If VBA7 Then
Private Function GetRibbon(ByVal lRibbonPointer As LongPtr) As Object
#Else
Private Function GetRibbon(ByVal lRibbonPointer As Long) As Object
#End If
Dim oribbon As IRibbonUI
CopyMemory oribbon, lRibbonPointer, LenB(lRibbonPointer)
Set GetRibbon = oribbon
Set oribbon = Nothing
End Function

Public Function GetRibbonObjectReference() As IRibbonUI
    If moRibbon Is Nothing Then
        Set moRibbon = GetRibbon(Sheet1.Range("RibbonPointer").Value)
    End If
    Set GetRibbonObjectReference = moRibbon
End Function

Public Sub InValidateRibbonNM(Optional Dummy As Boolean)
    GetRibbonObjectReference.Invalidate
End Sub

'Callback for customUI.onLoad
Sub rxNMcustomUI_onLoad(ribbon As IRibbonUI)
    Set moRibbon = ribbon
    Sheet1.Range("RibbonPointer").Value = ObjPtr(ribbon)
    ThisWorkbook.Saved = True
End Sub


Sub ManageNames2007(control As Object)
'Used to start NM from Excel 2007 ribbon
10  ManageNames
End Sub

Sub GetShortCutKey2007(control As Object)
'Used to call SetShortcutKey from Excel 2007 Ribbon
10  GetShortCutKey
End Sub

Sub ResetScreenPosition2007(control As Object)
10  ResetScreenPosition
End Sub

'Callback for VBECheckbox getPressed
Sub VBECheckbox_getPressed(control As IRibbonControl, ByRef returnedVal)
    returnedVal = gbVBEInterface
End Sub

'Callback for VBECheckbox onAction
Sub VBECheckbox_onAction(control As IRibbonControl, pressed As Boolean)
10  If Not gbVarsOK Then InitNameManager
20  gbVBEInterface = pressed
30  SaveSettings
40  If gbVBEInterface Then CreateVBEMenu
End Sub

Attribute VB_Name = "fxlNameFuncs"
Option Explicit
Option Compare Text
Option Base 1
'
' funcs for Name Managaer Dynamic Range Wizard: INDEX version (can't use XLL Funcs - Excel Bug)
'
Private Function COUNTUSEDROWS(theRow As Range)
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2014. All rights reserved
'
' counts the rows to the last used row on the referenced sheet
'
    Dim oRng As Range

10  Application.Volatile (True)
20  On Error GoTo funcfail
30  Set oRng = theRow.Parent.UsedRange
40  COUNTUSEDROWS = oRng.Row + oRng.Rows.Count - theRow.Row
50  If COUNTUSEDROWS < 0 Then COUNTUSEDROWS = 1
60  Set oRng = Nothing
70  Exit Function
funcfail:
80  COUNTUSEDROWS = CVErr(xlErrValue)
End Function
Private Function COUNTUSEDCOLS(theColumn As Range)
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2014. All rights reserved
'
' counts the columns to the last used-range column on the referenced sheet
'
    Dim oRng As Range
10  Application.Volatile (True)
20  On Error GoTo funcfail
30  Set oRng = theColumn.Parent.UsedRange
40  COUNTUSEDCOLS = oRng.Column + oRng.Columns.Count - theColumn.Column
50  If COUNTUSEDCOLS < 0 Then COUNTUSEDCOLS = 1
60  Set oRng = Nothing
70  Exit Function
funcfail:
80  COUNTUSEDCOLS = CVErr(xlErrValue)
End Function
Private Function COUNTROWS(theColumns As Range)
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2014. All rights reserved
'
' counts the rows to the max(last nonblank row) in the columns
'
    Dim oRng As Range
    Dim j As Long
    Dim jStartcol As Long
    Dim jStartrow As Long
    Dim jRows As Long
    Dim nRowsCount As Long
10  Application.Volatile (True)
20  On Error GoTo funcfail
30  COUNTROWS = 1
40  With theColumns
50      Set oRng = .Parent.Cells
60      GetMaxRowsCols .Parent.Parent
70      nRowsCount = gMaxRows
80      jStartrow = .Row                              ''' upper left row
90      jStartcol = .Column                           ''' upper left col
100     For j = 1 To .Columns.Count
110         If oRng(nRowsCount, jStartcol - 1 + j) = "" Then
120             jRows = oRng(nRowsCount, jStartcol - 1 + j).End(xlUp).Row - jStartrow + 1
130         Else
140             jRows = nRowsCount - jStartrow + 1
150         End If
160         If COUNTROWS < jRows Then COUNTROWS = jRows
170     Next j
180 End With
190 Set oRng = Nothing
200 Exit Function
funcfail:
210 COUNTROWS = CVErr(xlErrValue)
End Function
Private Function COUNTCOLS(theRows As Range)
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2014. All rights reserved
'
' counts the columns to the last nonblank col in the rows
'
    Dim oRng As Range
    Dim j As Long
    Dim jStartcol As Long
    Dim jStartrow As Long
    Dim jCols As Long
    Dim nColsCount As Long
10  Application.Volatile (True)
20  On Error GoTo funcfail
30  COUNTCOLS = 1
40  With theRows
50      GetMaxRowsCols .Parent.Parent
60      Set oRng = .Parent.Cells
70      nColsCount = gMaxCols
80      jStartrow = .Row                              ''' upper left row
90      jStartcol = .Column                           ''' upper left col
100     For j = 1 To .Rows.Count
110         If oRng(jStartrow - 1 + j, nColsCount) = "" Then
120             jCols = oRng(jStartrow - 1 + j, nColsCount).End(xlToLeft).Column - jStartcol + 1
130         Else
140             jCols = nColsCount - jStartcol + 1
150         End If
160         If COUNTCOLS < jCols Then COUNTCOLS = jCols
170     Next j
180 End With
190 Set oRng = Nothing
200 Exit Function
funcfail:
210 COUNTCOLS = CVErr(xlErrValue)
End Function

Private Function COUNTCONTIGROWS(theColumns As Range)
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2014. All rights reserved
'
' counts the rows to the last nonblank row down from the cells
' min rows is 1
'
    Dim oRng As Range
    Dim j As Long
    Dim jStartcol As Long
    Dim jStartrow As Long
    Dim jRows As Long
    Dim nRowsCount As Long

10  Application.Volatile (True)
20  On Error GoTo funcfail
30  With theColumns
40      GetMaxRowsCols .Parent.Parent
50      jStartcol = .Column
60      jStartrow = .Row
70      nRowsCount = gMaxRows
80  End With
90  COUNTCONTIGROWS = 1
100 For j = 1 To theColumns.Columns.Count
110     jRows = 0
120     Set oRng = theColumns.Cells(1, j)
130     If jStartrow = nRowsCount Then
            '
            ' last row so always 1
            '
140         jRows = 1
150     ElseIf IsEmpty(oRng.Offset(1, 0)) Then
            '
            ' next row is empty so always 1
            '
160         jRows = 1
170     ElseIf jStartrow = nRowsCount - 1 Then
            '
            ' last but 1 row and last row is not empty so 2
            '
180         jRows = 2
190     ElseIf IsEmpty(oRng.Offset(2, 0)) Then
            '
            ' row 2 is not empty but row 3 is
            '
200         jRows = 2
210     End If
220     If jRows = 0 Then
            '
            ' no special conditions so go down from row 2
            '
230         jRows = oRng.Offset(1, 0).End(xlDown).Row - jStartrow + 1
240     End If
250     If COUNTCONTIGROWS < jRows Then COUNTCONTIGROWS = jRows
260 Next j
270 Set oRng = Nothing
280 Exit Function
funcfail:
290 COUNTCONTIGROWS = CVErr(xlErrValue)
End Function
Private Function COUNTCONTIGCOLS(theRows As Range)
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2014. All rights reserved
'
' counts the columns to the last nonblank col right from the cells
'
    Dim oRng As Range
    Dim j As Long
    Dim jStartcol As Long
    Dim jStartrow As Long
    Dim jCols As Long
    Dim nColsCount As Long

10  Application.Volatile (True)
20  On Error GoTo funcfail
30  With theRows
40      GetMaxRowsCols .Parent.Parent
50      jStartcol = .Column
60      jStartrow = .Row
70      nColsCount = gMaxCols
80  End With
90  COUNTCONTIGCOLS = 1
100 For j = 1 To theRows.Rows.Count
110     jCols = 0
120     Set oRng = theRows.Cells(j, 1)
130     If oRng.Column = nColsCount Then
            '
            ' last column so always 1
            '
140         jCols = 1
150     ElseIf IsEmpty(oRng.Offset(0, 1)) Then
            '
            ' next column is empty so always 1
            '
160         jCols = 1
170     ElseIf oRng.Column = nColsCount - 1 Then
            '
            ' last but 1 column and last column is not empty so 2
            '
180         jCols = 2
190     ElseIf IsEmpty(oRng.Offset(0, 2)) Then
            '
            ' col 2 is not empty but col 3 is
            '
200         jCols = 2
210     End If
220     If jCols = 0 Then
            '
            ' no special conditions so go right from col 2
            '
230         jCols = oRng.Offset(0, 1).End(xlToRight).Column - jStartcol + 1
240     End If
250     If COUNTCONTIGCOLS < jCols Then COUNTCONTIGCOLS = jCols
260 Next j
270 Set oRng = Nothing
280 Exit Function
funcfail:
290 COUNTCONTIGCOLS = CVErr(xlErrValue)
End Function

Private Function ReplaceVBAString(ByVal sFoundString As String, ByVal sOldName As String, ByVal sNewName As String)
'-------------------------------------------------------------------------
' Procedure : ReplaceVBAString
' Company   : JKP Application Development Services (c)
' Author    : Jan Karel Pieterse (www.jkp-ads.com)
' Created   : 10-2-2015
' Purpose   : Replace a name in VBA
'-------------------------------------------------------------------------
    Dim vValidCharAfter As Variant
    Dim vValidCharBefore As Variant
    Dim lCharAfter As Long
    Dim lCharbefore As Long
    Dim sToReplace As String
    Dim sToFind As String
10  vValidCharAfter = Array("""", ", ", ")", "]")   'Valid characters after a name: '"' ', ' ')' ']'
20  vValidCharBefore = Array("""", ", ", "(", "[")  'Valid characters before a name: '"' ', ' '(' '['
30  For lCharAfter = LBound(vValidCharAfter) To UBound(vValidCharAfter)
40      For lCharbefore = LBound(vValidCharBefore) To UBound(vValidCharBefore)
50          sToReplace = vValidCharBefore(lCharbefore) & sNewName & vValidCharAfter(lCharAfter)
60          sToFind = vValidCharBefore(lCharbefore) & sOldName & vValidCharAfter(lCharAfter)
70          If InStr(sFoundString, sToFind) > 0 Then
80              sFoundString = Replace(sFoundString, sToFind, sToReplace)
90          End If
100     Next
110 Next
120 ReplaceVBAString = sFoundString
End Function
Attribute VB_Name = "fxlNameManager"
Option Explicit
Option Private Module
Option Compare Text
'
'***************************************************************
'*                                                             *
'* All subs and functions in this module:                      *
'* Copyright |fffd| J.K. Pieterse 2002-2010. All Rights Reserved    *
'* except where shown as                                       *
'* Copyright |fffd| Decision Models 2000-2010. All rights Reserved  *
'*                                                             *
'***************************************************************
'

'Dim cControl As CommandBarControl                 ''' Commandbar control of name manager
Public gfrmLocalSheets As ufLocalsheets                  ''' Object to contain the ufLocalsheets userform
Dim goActiveBook As Workbook
Public gsShortCutKey As String

Public goRelAnchor As Range                           ''' the cell that was active when the user started to edit a relative name

Public gfrmAnalyse As ufAnalyse                       ''' Object to contain the Analyse userform
Public gfrmNameManager As ufNameManager               ''' Object to contain the NameManager userform
Public gfrmReplace As ufReplace                       ''' Object to contain the Replace form
Public gfrmAddName As ufAddName                       ''' Object to contain the addname form

Public gbAcknowledge As Boolean                       ''' Acknowledge changes
Public gbActiveCellChecked As Boolean                 ''' Editing relative name, True if user has acknowledged active cell.
Public gbAddSheet As Boolean                          ''' true if sheet has been added for localglobal problem
Public gbAllNames As Boolean                          ''' True to show both local and global
Public gbOrFilters As Boolean                         ''' True if the user has chosen to OR the filters
Public gbInvertFilters As Boolean                     ''' true if the user has chosen to Invert the filters (NOT)
Public gbBreak As Boolean                             ''' true if user pressed break
Public gbChangedRefersTo As Boolean                   ''' RefersTo has changed
Public gbContains As Boolean                          ''' Filter using string in tgbContains
Public gbDisableEvents As Boolean                     ''' Disable events
Public gbDuplicate As Boolean                         ''' duplicate global local
Public gbError As Boolean                             ''' Filter on errors
Public gbExternal As Boolean                          ''' Filter on External references
Public gbFindWild As Boolean                          ''' true if use wildcards in Find
Public gbFixSplit As Boolean                          ''' true if the the splitter bar position is fixed
Public gbFormIsShowing As Boolean                     ''' True if userform is showing
Public gbFormBig As Boolean                           ''' True if Form is at maximum size
Public gbFormula As Boolean                           ''' Not Range
Public gbFound As Boolean                             ''' True if a name has been found
Public gbGlobal As Boolean                            ''' Show only global names
Public gbGoTo As Boolean                              ''' crw dec 22 2002
Public gbHide As Boolean                              ''' True: hide the selected name
Public gbIconButtons As Boolean                       ''' True: show buttons with Icons
Public gbIsRelative As Boolean                        ''' True: is a relative name
Public gbKeep As Boolean
Public gbListChanged As Boolean                       ''' list of names has changed: crw 3/1/2003
Public gbLocalActive As Boolean                      ''' Filter names local to active sheet
Public gbLocalGlobalWarning As Boolean                ''' Set to true when warning message about unused names has been shown gsMsgs(34)
Public gbLocalAll As Boolean                          ''' Filter local names
Public gbMacDone As Boolean                           ''' True if userform has been corrected for Mac
Public gbMacOS As Boolean                             ''' True if on Mac
Public gbMacX As Boolean                              ''' True if Mac XL 10
Public gbMinimized As Boolean                         ''' True if Form is minimized
Public gbMultiArea As Boolean                         ''' multi area range
Public gbNoFilter As Boolean                          ''' No type filter
Public gbNoMoreAcknowledge As Boolean                 ''' Stop asking to acknowledge replacing
Public gbOverlap As Boolean                           ''' overlapping names
Public gbOptChange As Boolean                         ''' Options have changed
Public gbRefresh As Boolean                           ''' refresh command
Public gbRefsActiveSheet As Boolean                   ''' refersto active sheet
Public gbRelative As Boolean                          ''' relative names
Public gbRenameError As Boolean                       ''' True when an error has hapenned during rename
Public gbRepAll As Boolean                            ''' true if replace all
Public gbRepErr As Boolean                            ''' true if error in replaced formula
Public gbRepWild As Boolean                           ''' memory: true if wildfind in rep
Public gbRepScope As Boolean                          ''' memory: false if selected only in Rep
Public gbRepFound As Boolean                          ''' true if successful find or replace
Public gbShortCutKey As Boolean                       ''' True if there is a shortcutkey
Public gbShowRefersto As Boolean                      ''' Show refersto in lbxnames
Public gbVBEInterface As Boolean                      ''' Display interface in VBE (so that we can disable it for users experiencing trouble with the compile error)

'JKP Oct 14 2005: obsolete
'Public bSelected() As Boolean                     ''' Name is selected in userform

Public gbSelections() As Boolean                      ''' also name is selected in userform, used in replace
Public gbSelectedaSheet As Boolean                    ''' Did user select a sheet to localise to?
Public gbSelectedCells As Boolean                     ''' selected cells
Public gbShow3D As Boolean                            ''' 3D range
Public gbShowHidden As Boolean                        ''' Filter on hidden names
Public gbShowSysNames As Boolean                      ''' True to show system names like Print_Area
Public gbShowVisible As Boolean                       ''' Visible
Public gbShowTables As Boolean                          ''' show only table names
Public gbShowNames As Boolean                           ''' show only Names
'Public bSort As Boolean                           ''' True: Sort names so sheets are together
Public gbUnUsed As Boolean                            ''' Unused names
Public gbVarsOK As Boolean                            ''' Check if project has been reset
Public gbVisible() As Boolean                         ''' Is name visible
Public gbTable() As Boolean                           ''' Is name a table
Public gbWarned As Boolean                            ''' False to give warning when a name is like =!A1
Public gbWarnedTrustAccessVBA As Boolean              ''' False to give warning about trust vba access

Public gclNameEvent As New NameEventClass             ''' event class variable: crw 8 Jan 2003

Public glActive As Long                               ''' First selected name in lbxnames
Public glCalcMode As Long                             ''' Remember calculation mode when Name Manager starts
Public glChanged As Long                              ''' count of names that have been changed in replaceall
Public glNameCount As Long                            ''' count of names currently in gsNames()
Public glNamegsSelected As Long                       ''' number of selected items in listbox
Public gctlLocalControl As control                    ''' Used in ufNameManager class module
Public glR1C1 As Long                                 ''' the reference mode currently in use by name manager
Public glShowCount As Long                            ''' The number of names shown (buildoverlaps)
Public glLastSplitLeft As Long                        ''' last left of the moved splitterbar

Public gMaxRows As Long                               ' max number of rows this version
Public gMaxCols As Long                               ' max number of cols this version

Public gsAppName As String                            ''' Name of this application
Public gsContains As String                           ''' The substring to search for
Public gsMsgs() As String
Public gsNames() As String                            ''' Array of names in workbook
Public gsNewRefersTo As String                        ''' Edited RefersTo property
Public gsRefersto() As String                         ''' Array of Current RefersTo properties
Public gsSavedSheetName As String                     ''' name of the activesheet
Public gsSheet As String                              ''' Name of sheet to localise to
Public gstrActiveAddress As String                    ''' address  of activecell
Public gsTxtufAddName() As String
Public gsTxtufAnalyse() As String
Public gsTxtufLocalSheets() As String
Public gsTxtufNameManager() As String
Public gstxtufSelectARange() As String
Public gsTxtufWhereUsed() As String
Public gsTxtLang() As String
Public gsFind As String                               ''' text to look for in find/replace
Public gsReplace As String                            ''' text to replace with in find/replace
Public gsSelected() As String                         ''' List of selected names in lbxnames
Public gsValidChars                                   ''' JKP Build 562: read from worksheet

Public gvSheetsReferredTo As Variant                  ''' List of sheets referred to in global name
'Public gvErrorCodes As Variant                        ''' List of Excel cell error codes

Public Const gbFxl As Boolean = False              ''' True if embedded in FastExcel
'
' error trace
'
Public glStackPtr As Long                             ''' pointer to stack
Public gstrStack() As String                          ''' string array for procedure names
Public gblDebug As Boolean                            ''' debug switch
Public gjErr As Long

Public Const gsBuild As String = "668"                ''' Build number
Public Const gsIllegalFirstChars As String = ".0123456789?|fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd|"    ''' JKP Build 562: names cannot start with these
Public Const gsVersion As String = "4.3"              ''' Version number
'
' crw 18/10/04
'
Public Const gsFxlNameRegKey As String = "FXLNameMgr"    ''' RegKey for settings
Public Const gstrFastXL As String = "FastExcel3"       ''' app name


''' *** auto-open and auto-close not required in FastExcel Version

Sub auto_open()
'If gbFxl Then Exit Sub
10  On Error Resume Next
20  Application.OnKey "+^%{F8}", "ToggleDebugTrace2"  ''' toggle debug trace
30  On Error GoTo 0
40  PushStack3 "Auto_Open"
    '
    ' crw 4/11/2010
50  GetLangUI

60  If Not gbVarsOK Then InitNameManager
70  MakeMenu
80  CreateVBEMenu
90  GetMaxRowsCols ActiveWorkbook
GoExit:
100 PopStack3
End Sub

Sub auto_close()
'If gbFxl Then Exit Sub
10  PushStack3 "Auto_Close"
20  If UserForms.Count > 0 Then
30      On Error Resume Next
40      Unload gfrmNameManager
50      Unload gfrmLocalSheets
60      Set gfrmNameManager = Nothing
70      Set gfrmLocalSheets = Nothing
80  End If
90  RemoveMenu
100 DestroyVBEMenu
110 ResetShortCutKey
GoExit:
120 PopStack3
End Sub
Sub StartDynWiz2()
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2005-2010. All rights reserved
'
' dummy Dynamic range wizard routine for name manager
' comment out this line in Name Manager
'
10  If gbFxl Then StartDynWiz
End Sub
Sub GetMaxRowsCols(oBk As Workbook)
'
' CRW 20/4/2007: Get max rows and cols
'
' CRW 14/3/2008: fix for Compatibility workbooks in 2007
'
10  If Val(Application.Version) >= 12 Then
20      gMaxRows = 1048576
30      gMaxCols = 16384
40      If Not oBk Is Nothing Then
50          If oBk.Excel8CompatibilityMode Then
60              gMaxRows = 65536
70              gMaxCols = 256
80          End If
90      End If
100 Else
110     gMaxRows = 65536
120     gMaxCols = 256
130 End If
End Sub
Public Sub NameAppTrap2()
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2003-2010. All rights reserved
'
' setup application events: called from InitializeUF
'
' JKP Jan 10 2003: Don't use this for Mac and for XL97
10  PushStack3 "NameAppTrap2"
20  If gbMacOS Then GoTo GoExit
30  If Val(Application.Version) < 9 Then GoTo GoExit
40  If gclNameEvent.NameApp Is Nothing Then
50      Set gclNameEvent.NameApp = Application
60  End If
GoExit:
70  PopStack3
End Sub
'JKP: Added to initialize
' CRW Tables 24 Apr 2014
Sub InitNameManager()
10  PushStack3 "InitNameManager"
20  ReDim gsSelected(1)
30  gbVarsOK = True
40  GetSettings
50  ResetShortCutKey
60  SetShortCutKey
70  gbOrFilters = False
80  gbNoFilter = True
90  gbExternal = False
100 gbError = False
110 gbShowHidden = False
120 gbShowVisible = False
130 gbShow3D = False
140 gbShowTables = False
150 gbShowNames = False
160 gbMultiArea = False
170 gbFormula = False
180 gbRelative = False
190 gbOverlap = False
200 gbSelectedCells = False
210 gbRefsActiveSheet = False
220 gbDuplicate = False
230 ReadMessages
240 gsAppName = IIf(gbFxl, "FastExcel Name Manager Pro " & gsVersion, "Name Manager " & gsVersion)
    'check for Mac
250 gbMacX = False
260 If Application.OperatingSystem Like "*Mac*" Then
270     gbMacOS = True
280     gbMacDone = False
290     If Val(Application.Version) >= 10 Then gbMacX = True
300 Else
310     gbMacOS = False
320 End If
GoExit:
330 PopStack3
End Sub
Sub ManageNames()
10  PushStack3 "ManageNames"
20  If Not gbVarsOK Then InitNameManager
    'On Error Resume Next
    ' JKP, Dec 9 2002: added check for presence of workbook
30  Set goActiveBook = ActiveWorkbook
40  If goActiveBook Is Nothing Then
50      ShowMsg ReworkMsg(gsMsgs(1)), vbOKOnly + vbExclamation
60      GoTo GoExit
70  End If
80  If GetNameTableCount() = 0 Then
90      ShowMsg ReworkMsg(gsMsgs(2)), vbOKOnly + vbExclamation
        'JKP 18 nov 2002: removed exit sub, do not stop if no names, to pickup from list
100 End If
    'JKP build 622: next line moved here to avoid RT Error when no wb's open.
110 glCalcMode = Application.Calculation
120 ShowNMForm
GoExit:
130 PopStack3
End Sub

Sub ShowNMForm()
    Dim lCursor As Long
10  PushStack3 "ShowNMForm"
    '
    ' crw 20/9/2006 do not automatically create frmanalyse
    '
    '10  If gfrmAnalyse Is Nothing Then
    '20      Set gfrmAnalyse = New ufAnalyse
    '30  End If

    'JKP Jan 07 2003 : added to change handling of forms
20  If Not gfrmNameManager Is Nothing Then
30      On Error Resume Next
40      gfrmNameManager.Hide
50      Unload gfrmNameManager
60  End If
70  Set gfrmNameManager = Nothing                     ''' crw 20/9/2006
80  If gfrmNameManager Is Nothing Then
90      Set gfrmNameManager = New ufNameManager
100 End If
    '
    ' crw add relative, selected, overlap
    ' Crw Nov5 2002, add visible,3d, multiarea, formula
110 gbAllNames = Not (gbGlobal Or gbLocalActive Or gbLocalAll)
    'JKP Jan 30 2003: added gbDuplicate
    ' crw 18 Oct 2005 added gbRefsActiveSheet
120 gbNoFilter = Not (gbExternal Or gbError Or gbShowHidden Or gbShowVisible Or gbShow3D _
                      Or gbMultiArea Or gbFormula Or gbRelative Or gbOverlap Or gbSelectedCells Or gbRefsActiveSheet Or gbDuplicate)

130 gbDisableEvents = False
140 glActive = 1
150 FindAllNames
160 gfrmNameManager.InitializeUF                      ''' crw 19/12/2002; show after hide does not initialise
170 lCursor = Application.Cursor                      ''' crw 19/12/2002
    '
    'Added by Matthew Henson -Test for platform
180 gbFormIsShowing = True
190 If Val(Application.Version) = 8 Or gbMacOS = True Then
200     gfrmNameManager.Show
210 Else
        ' JKP, Dec 9 2002: changed name of sub
220     ShowModeless
230 End If
    ' JKP Dec 5 2002
240 If lCursor = xlWait Then
250     Application.Cursor = xlDefault
260 Else
270     Application.Cursor = lCursor                  ''' crw 19/12/2002
280 End If
GoExit:
    '
    ' crw 9/Dec/2003: Cleanup object variables
    '
290 On Error Resume Next
300 Set goActiveBook = Nothing
310 PopStack3
End Sub
Sub DeleteNames()
'
' crw 23 April 2014 tables
'
    Dim lCount As Long
    Dim sTemp As String
    Dim lCalcSave As Long
    Dim bUnapply As Boolean

10  PushStack3 "DeleteNames"
    '
    ' modified crw Nov 11 2002
    '
    ' crw oct 29 deleted oSheet
    '
20  If gbAcknowledge Then
30      If ShowMsg(ReworkMsg(gsMsgs(3)), vbYesNo + vbQuestion) = vbNo Then
40          ShowMsg ReworkMsg(gsMsgs(4)), vbOKOnly + vbExclamation
50          GoTo GoExit
60      End If
70  End If
    'JKP Build 626: ask to unapply names
80  Select Case ShowMsg(ReworkMsg(gsMsgs(107)), vbQuestion + vbYesNoCancel)
    Case vbYes
90      bUnapply = True
100 Case vbNo
110     bUnapply = False
120 Case vbCancel
130     GoTo GoExit
140 End Select

    ' crw Nov 15 2002 switch off calculation
150 lCalcSave = Application.Calculation
160 Application.Calculation = xlCalculationManual
170 Application.ScreenUpdating = False
180 gbAddSheet = False                                ''' crw apr 12 2003
190 With gfrmNameManager
200     For lCount = 0 To .lbxNames.ListCount - 1
210         If .lbxNames.Selected(lCount) <> 0 Then
220             sTemp = .lbxNames.List(lCount)
230             If Not IsTableName(sTemp) Then DeleteAName sTemp, bUnapply
240             If gbBreak Then Exit For
250         End If
260     Next
270 End With
280 DeleteAddSheet                                    ''' crw apr 12 2003
290 If Application.Calculation <> lCalcSave Then Application.Calculation = lCalcSave
300 Application.ScreenUpdating = True
GoExit:
310 PopStack3
End Sub

Sub DeleteAName(sTemp As String, Optional bUnapply As Boolean = False)
'
' modified crw nov 11,12 2002
'
    Dim bSwitch As Boolean                                  ''' crw nov 7 2002
    Dim oName As Name
    Dim oName2 As Name                                      ''' crw 22 Oct 2005
    Dim strRefersTo As String

10  PushStack3 "DeleteAName"
    '
    ' switch sheets if global local - crw 2/11/2005
    '
20  bSwitch = False
30  If TypeName(ActiveSheet) <> "Worksheet" Then
40      bSwitch = True
50      SwitchtoDifferentSheet sTemp
60  Else
70      If IsNameGlobalLocal(ActiveSheet, sTemp) Then
80          bSwitch = True
90          SwitchtoDifferentSheet sTemp
100     End If
110 End If
    '
    ' CRW Oct 18 2002: Listbox changed to multicolumn

    'JKP Feb 6 2003: Check if name is valid!
    '
    ' crw 1 April 2005, better error handling
    '
    'JKP 13-7-2009, more rigorous name deleting, don't check for valid characters,
    '               but first try to delete.
120 Set oName = FindName(sTemp)
130 If Not oName Is Nothing Then
140     On Error Resume Next
150     strRefersTo = oName.RefersTo
160     oName.Delete
        'JKP build 626: unapply deleted names
170     If bUnapply Then
180         UnApplyName sTemp, strRefersTo
190     End If
200     On Error GoTo 0
210 Else
        'Deleting name failed, check if it is an invalid name
220     If IsNameValid(sTemp, True) Then

230         Set oName = FindName(sTemp)
240         strRefersTo = ""
250         On Error Resume Next
260         strRefersTo = oName.RefersTo

270         If IsNameRefersToLegal(sTemp, strRefersTo) Then
280             On Error GoTo Trap
290             oName.Delete                    ''' crw 22 oct 2005
300             On Error Resume Next
310         Else
320             gbBreak = IllegalNames(sTemp)
330         End If
340     End If
350 End If
360 If bSwitch Then SwitchSheetBack                 ' crw nov8 2002
GoExit:
370 Set oName = Nothing
380 PopStack3
390 Exit Sub
Trap:
    'JKP Feb 5 2003: added Error trap
    ' crw Apr 12 2003: fixed the error message
400 ShowMsg ReworkMsg(gsMsgs(5), sTemp, Err.Description), vbOKOnly + vbCritical
410 Resume Next

End Sub
Sub FindAllNames()
'
' modified CRW 20 Oct 2002: use A1 or R1C1 style, optimise Redim
'
' CRW 23 April 2014 : Tables
'
    Dim oName As Name
    Dim oTable As ListObject
    Dim oSht1 As Object
    Dim oSht2 As Object
    Dim blScreenUpdating As Boolean
    Dim lTotNames As Long
10  PushStack3 "FindAllNames"
    ' jkp 28 may 2003
20  blScreenUpdating = Application.ScreenUpdating
    'Application.ScreenUpdating = False  ''' crw 6/10/2005
30  Set oSht1 = ActiveSheet
40  gbActiveCellChecked = False
50  gbIsRelative = False
60  If GetNameTableCount() = 0 Then
70      glNameCount = 0
80      GoTo GoExit
90  End If
100 lTotNames = GetNameTableCount()
110 ReDim gsNames(lTotNames)
120 ReDim gsRefersto(lTotNames)
130 ReDim gbVisible(lTotNames)
140 ReDim gbTable(lTotNames)
150 glNameCount = 0
    '
    ' get defined names
    '
160 For glNameCount = 1 To ActiveWorkbook.Names.Count
170     Set oName = ActiveWorkbook.Names(glNameCount)
        'If 100 * (glNameCount / 100) = glNameCount Then Application.StatusBar = ReworkMsg(gsMsgs(65), glNameCount, lTotNames)
180     If glNameCount > UBound(gsNames) Then
190         ReDim Preserve gsNames(glNameCount + 10)
200         ReDim Preserve gsRefersto(glNameCount + 10)
210         ReDim Preserve gbVisible(glNameCount + 10)
220         ReDim Preserve gbTable(glNameCount + 10)
230     End If
240     gsNames(glNameCount) = oName.NameLocal
        '
        ' CRW Oct 20 2002: use A1 or R1C1 style according to the Application setting
        '
        ' CRW Jul 1 2003: get refersto for local and relative names
        '
250     gsRefersto(glNameCount) = strGetRefersTo(oName)

260     gbVisible(glNameCount) = oName.Visible
270     gbTable(glNameCount) = False
280 Next
290 glNameCount = ActiveWorkbook.Names.Count
    '
    ' get table names
    '
300 If gbFxl Then
310     For Each oSht2 In ActiveWorkbook.Worksheets
320         For Each oTable In oSht2.ListObjects
330             glNameCount = glNameCount + 1
340             If glNameCount > UBound(gsNames) Then
350                 ReDim Preserve gsNames(glNameCount + 10)
360                 ReDim Preserve gsRefersto(glNameCount + 10)
370                 ReDim Preserve gbVisible(glNameCount + 10)
380                 ReDim Preserve gbTable(glNameCount + 10)
390             End If
400             gsNames(glNameCount) = oTable.Name
410             gsRefersto(glNameCount) = "'" & oTable.Parent.Name & "'!" & oTable.Range.Address(, , Application.ReferenceStyle)
420             gbVisible(glNameCount) = True
430             gbTable(glNameCount) = True
440         Next oTable
450     Next oSht2
460 End If
470 If glNameCount <> UBound(gsNames) Then
480     ReDim Preserve gsNames(glNameCount)
490     ReDim Preserve gsRefersto(glNameCount)
500     ReDim Preserve gbVisible(glNameCount)
510 End If
520 glR1C1 = Application.ReferenceStyle               ''' crw dec 30 store current name manager setting
530 Set oName = Nothing                               ''' crw
540 If gfrmNameManager.lblSortNameAsc.SpecialEffect = fmSpecialEffectSunken Then
        'Sort by Name Ascending
550     QuickSort gsNames, 1, UBound(gsNames), "Names", True
560 ElseIf gfrmNameManager.lblSortNameDesc.SpecialEffect = fmSpecialEffectSunken Then
        'Sort by Name Descending
570     QuickSort gsNames, 1, UBound(gsNames), "Names", False
580 ElseIf gfrmNameManager.lblSortRefersAsc.SpecialEffect = fmSpecialEffectSunken Then
        'Sort by RefersTo Ascending
590     QuickSort gsRefersto, 1, UBound(gsRefersto), "RefersTo", True
600 ElseIf gfrmNameManager.lblSortRefersDesc.SpecialEffect = fmSpecialEffectSunken Then
        'Sort by RefersTo Descending
610     QuickSort gsRefersto, 1, UBound(gsRefersto), "RefersTo", False
620 End If
    '330 If bSort Then SortNames
GoExit:
630 Set oSht2 = ActiveSheet
640 If Not oSht1 Is oSht2 Then
        'JKP Build 566: prevent sheetchange event
650     gclNameEvent.DisableSheetEvent = True
660     oSht1.Activate
670     gclNameEvent.DisableSheetEvent = False
680 End If
690 If Not Application.ScreenUpdating = blScreenUpdating Then
700     Application.ScreenUpdating = blScreenUpdating
710 End If
720 PopStack3
End Sub
Function GetNameTableCount() As Long
'
' crw 23/4/2015
'
    Dim oSht As Worksheet
10  GetNameTableCount = ActiveWorkbook.Names.Count
20  If gbFxl Then
30      For Each oSht In ActiveWorkbook.Worksheets
40          GetNameTableCount = GetNameTableCount + oSht.ListObjects.Count
50      Next oSht
60  End If
End Function
Sub ToggleScope()
'
' crw 23 April 2014 Tables
10  PushStack3 "ToggleScope"
20  With gfrmNameManager
        '
        ' uses JK's listbox
        '
30      gbAllNames = (.lbxShow.ListIndex = 0)
40      gbGlobal = (.lbxShow.ListIndex = 1)
50      gbLocalAll = (.lbxShow.ListIndex = 2)
60      gbLocalActive = (.lbxShow.ListIndex = 3)
        '
        ' multiselect crw 27 dec 2002
        '
70      gbNoFilter = (.lbxFilter.Selected(0))
80      gbShowNames = (.lbxFilter.Selected(1))      ''' crw 23 april 2014
90      gbShowTables = (.lbxFilter.Selected(2))     ''' crw 23 april 2014

100     gbExternal = (.lbxFilter.Selected(3))
110     gbError = (.lbxFilter.Selected(4))
120     gbShowHidden = (.lbxFilter.Selected(5))
        '
        ' crw additional filters Oct 18, Nov 5, Nov 11
        '
130     gbShowVisible = (.lbxFilter.Selected(6))
140     gbShow3D = (.lbxFilter.Selected(7))
150     gbMultiArea = (.lbxFilter.Selected(8))
160     gbFormula = (.lbxFilter.Selected(9))
170     gbRelative = (.lbxFilter.Selected(10))         ''' crw oct 18 2002
180     gbSelectedCells = (.lbxFilter.Selected(11))    ''' crw Oct 21 2001
190     gbOverlap = (.lbxFilter.Selected(12))         ''' crw Oct 21 2002
200     gbDuplicate = (.lbxFilter.Selected(13))       ''' crw Nov 11 2002
        '190     If gbFxl Then gbRefsActiveSheet = (.lbxFilter.Selected(12))    ''' crw 18 Oct 2005
210     gbRefsActiveSheet = (.lbxFilter.Selected(14))
220 End With
GoExit:
230 PopStack3
End Sub
Sub ListTheNames()
      '
      ' modified 18 October 2002, CRW: multicolumn listbox
      ' modified 18-21 October, CRW: additional filters
      ' modified 29 October 2002: use Jan Karel's listboxes etc
      ' modified CRW Nov 5,11 additional filters
      '
      ' modified crw 13/1/2003 break and error handling
      ' modified CRW 30/1/2003 removed IIF for performance reasons
      ' modified crw 18/10/2005 invert filter
      ' modified crw 23/4/2014 Tables
      '
          Dim lAreasCount As Long                           ''' crw Nov 11 2002
          Dim lCount As Long
          Dim bShow As Boolean
          Dim vBoxContent() As Variant                      ''' rows and cols for listbox
          Dim lNamesIndex() As Long                         ''' array of indexes to names
          Dim lNamesIndex2() As Long                        ''' array of indexes to overlapping names
          Dim lMaxLength1 As Long                           ''' max length of a name to be shown
          Dim lMaxLength2 As Long                           ''' max length of refersto/names2
          Dim lSaveCursor As Long                           ''' crw Nov 11 2002
          Dim sMsg As String                                ''' status message
          Dim bInstrName As Boolean
          Dim bInstrRefersto As Boolean
          Dim dWidth As Double                              'letter-width in points
          Dim oRng1 As Range
          Dim lSplitLeft As Long
          Dim strRefersTo As String

10    Application.EnableCancelKey = xlErrorHandler

20    ReDim lNamesIndex(glNameCount) As Long
30    ReDim lNamesIndex2(glNameCount) As Long
          'JKP Apr 20 2006: reset warning message (gsMsgs(34)) for unused name search.
40    gbLocalGlobalWarning = False
50    PushStack3 "ListTheNames"

60    glShowCount = 0
          ' crw Nov 4 2002
70    gbDisableEvents = True
          ' JKP Jan 02 2003
          'Application.ScreenUpdating = False  ''' crw 6/10/2005
80    With gfrmNameManager
90      .lbxNames.Clear
        '.lbxNames.Height = 168 ''' crw 7/10/2005
100     If gbMacOS Then
110         If gbMacX Then
120             .lbxNames.Height = 210
130         Else
140             .lbxNames.Height = 215                'adjusted by hand, MCH Dec 03
150         End If
160     End If

        'next line replaced by workaround, MCH 6 Dec 03
        '        .lblCount.Top = .lbxNames.Top + .lbxNames.Height + 8
170     If gbMacOS Then
180         If gbMacX Then
190             .lblCount.Top = .lbxNames.Top + .lbxNames.Height + 1
200         Else
210             .lblCount.Top = .lbxNames.Top + .lbxNames.Height + 1
220         End If
230     Else
240         .lblCount.Top = .lbxNames.Top + .lbxNames.Height + 6
250     End If

        ' crw Nov 11 2002
260     lSaveCursor = Application.Cursor
270     Application.Cursor = xlWait

280     On Error Resume Next                          ''' extend error handling over show testing crw Dec 30 2002

290     gbBreak = False                               ''' crw 13/1/2003 break handling

300     For lCount = 1 To glNameCount
310         If Err = 18 Then gbBreak = True
320         If (lCount Mod 10) = 0 Then
330             Application.StatusBar = CStr(lCount) & "/" & CStr(glNameCount)
340         End If
350         bShow = True
            ' crw 13/1/2003 break handling
360         If gbBreak Then
370             Application.OnTime Now, "ResetAll"
380             GoTo GoExit
390         End If
            'JKP Dec 16 2002: Added wildcard search
400         If gbContains Then
410             Err.Clear
420             bInstrName = Application.WorksheetFunction.Search(gsContains, gsNames(lCount)) > 0
430             If Err <> 0 Then
440                 bInstrName = False
450             End If
460             Err.Clear
470             bInstrRefersto = Application.WorksheetFunction.Search(gsContains, gsRefersto(lCount)) > 0
480             If Err <> 0 Then
490                 bInstrRefersto = False
500             End If
510         Else
520             bInstrName = True
530             bInstrRefersto = True
540         End If
            '
            ' crw 17/9/2003
            '
550         If Not gbShowSysNames Then
560             bShow = Not IsSysName(FindName(gsNames(lCount)).Name)
570         End If
580         If bShow And (gbContains And Not gbOverlap) Then bShow = bInstrName Or _
               (gbShowRefersto And bInstrRefersto)

590         If bShow And gbLocalAll Then
600             If gbTable(lCount) Then
610                 bShow = False
620             Else
630                 bShow = IsNameLocal(gsNames(lCount), False)
640             End If
650         End If
660         If bShow And gbLocalActive Then
670             If gbTable(lCount) Then
680                 bShow = False
690             Else
700                 bShow = (InStr(gsNames(lCount), ActiveSheet.Name & "!") = 1 Or InStr(gsNames(lCount), ActiveSheet.Name & "'!") = 2)
710             End If
720         End If
            ' changed to allow for peculiar names CRW 30/1/2003
730         If bShow And gbGlobal Then
740             If gbTable(lCount) Then
750                 bShow = True
760             Else
770                 bShow = Not IsNameLocal(gsNames(lCount), False)
780             End If
790         End If
            'JKP, 11-10-2002
            'Skip if bshow=false because name is out of scope
800         If bShow Then
                '
                ' defined names only - CRW 23 April 2014
                '
810             If (bShow Or gbOrFilters) And gbShowNames And gbFxl Then
820                 bShow = Not gbTable(lCount)
830                 If bShow And gbOrFilters Then GoTo GoOrFilter
840             End If
                '
                ' Table names only - CRW 23 April 2014
                '
850             If (bShow Or gbOrFilters) And gbShowTables And gbFxl Then
860                 bShow = gbTable(lCount)
870                 If bShow And gbOrFilters Then GoTo GoOrFilter
880             End If
                ' have to use A1 ref style because relative R1C1 may contain []
                ' JKP Jan 29 2003: changed to avoid errors with peculiar sheetnames
890             If (bShow Or gbOrFilters) And gbExternal Then
900                 If gbTable(lCount) Then
910                     bShow = False
920                 Else
                        ' JKP Feb 10 2003: changed so only real externals are found, containing .???]  .
                        ' CRW 4/12/2007: allow for external global names which dont have [] : look for .XLS! .XLA! .XLAM! etc
                        ' CRW 24/11/2016: allow for external names with quotes
930                     strRefersTo = FindName(gsNames(lCount)).RefersTo
940                     bShow = (strRefersTo Like "*[[]*[]]*[!]*") Or (strRefersTo Like "*.xl?!*") _
                                Or (strRefersTo Like "*.xl??!*") _
                                Or (strRefersTo Like "='*.xl?'!*") Or (strRefersTo Like "='*.xl??'!*")
950                 End If
                    'If bShow And IsEmpty(ActiveWorkbook.LinkSources) Then bShow = False
960                 If bShow And gbOrFilters Then GoTo GoOrFilter
970             End If
      '980             If (bShow Or gbOrFilters) And gbError Then
      '990                 bShow = (HasHashInFormula(gsRefersto(lCount)) = True) Or (Not IsNameValid(gsNames(lCount), False))
      '1000                If bShow And gbOrFilters Then GoTo GoOrFilter
      '1010            End If
980             If (bShow Or gbOrFilters) And gbError Then
                    '
                    ' CRW 29/1/19 - use US english refersto to avoid localisation problems
                    '
                    '830                 bShow = (HasHashInFormula(gsRefersto(lCount)) = True) Or (Not IsNameValid(gsNames(lCount), False))
990                 strRefersTo = ""
1000                If IsTableName(gsNames(lCount)) Then
                        '
                        ' table refersto created from address are always english ?
                        '
1010                    strRefersTo = gsRefersto(lCount)
1020                Else
                        '
                        ' englsih refersto
                        '
1030                    strRefersTo = FindName(gsNames(lCount)).RefersTo
1040                End If
1050                bShow = (HasHashInFormula(strRefersTo) = True) Or (Not IsNameValid(gsNames(lCount), False))
1060                If bShow And gbOrFilters Then GoTo GoOrFilter
1070            End If
1080            If (bShow Or gbOrFilters) And gbShowHidden Then
1090                bShow = Not gbVisible(lCount)
1100                If bShow And gbOrFilters Then GoTo GoOrFilter
1110            End If
1120            If (bShow Or gbOrFilters) And gbShowVisible Then
1130                bShow = gbVisible(lCount)
1140                If bShow And gbOrFilters Then GoTo GoOrFilter
1150            End If
1160            If (bShow Or gbOrFilters) And gbShow3D Then
1170                bShow = IsNameThreeD(lCount)
1180                If bShow And gbOrFilters Then GoTo GoOrFilter
1190            End If
1200            If (bShow Or gbOrFilters) And (gbMultiArea Or gbFormula) Then
                    'lAreasCount = Name2DRangeAreas(FindName(gsNames(lCount)))
1210                If gbTable(lCount) Then
1220                    strRefersTo = gsRefersto(lCount)
1230                Else
1240                    strRefersTo = FindName(gsNames(lCount)).RefersTo
1250                End If
1260                lAreasCount = Name2DRangeAreasRef(strRefersTo)
1270                If gbMultiArea Then bShow = (lAreasCount > 1)
                    ' crw 2 Aug 2006
1280                If (bShow Or gbOrFilters) And gbFormula Then bShow = (lAreasCount = 0)
                    'If (bShow Or gbOrFilters) And gbOrFilters Then GoTo GoOrFilter
1290                If bShow And gbOrFilters Then GoTo GoOrFilter
1300            End If
                '
1310            If (bShow Or gbOrFilters) And gbRelative Then
1320                If gbTable(lCount) Then
1330                    bShow = False
1340                Else
1350                    bShow = IsNameRelative(FindName(gsNames(lCount)).RefersToR1C1)
1360                End If
1370                If bShow And gbOrFilters Then GoTo GoOrFilter
1380            End If
1390            If (bShow Or gbOrFilters) And gbSelectedCells Then
1400                bShow = IsNameselected(lCount)
1410                If bShow And gbOrFilters Then GoTo GoOrFilter
1420            End If
                '
                ' add filter for active sheet
                '
1430            If (bShow Or gbOrFilters) And gbRefsActiveSheet Then
1440                bShow = IsNameRefertoActiveSheet(lCount)
1450                If bShow And gbOrFilters Then GoTo GoOrFilter
1460            End If

1470            If (bShow Or gbOrFilters) And gbDuplicate Then
1480                bShow = IsNameDuplicate(lCount)
1490                If bShow And gbOrFilters Then GoTo GoOrFilter
1500            End If
                '
                ' unused
                '
1510            If (bShow Or gbOrFilters) And gbUnUsed And Not gbTable(lCount) Then
1520                Set gcFoundObjects = New Collection
1530                If gbBreak Then
1540                    Stop
1550                    Exit Sub
1560                End If
1570                FindNames gsNames(lCount), True
1580                gbBreak = False
1590                bShow = (gcFoundObjects.Count = 0)
1600            End If
GoOrFilter:
1610            If gbOverlap And (bShow Or gbOrFilters) Then
                    '
                    ' crw 13/1/2003 only check overlap if its a range
                    '
1620                Set oRng1 = Nothing
1630                Set oRng1 = Range(gsNames(lCount))
1640                If Not oRng1 Is Nothing Then
1650                    BuildOverlaps lCount, glShowCount, lNamesIndex(), lNamesIndex2(), oRng1
1660                End If
                    '
                    ' crw 18 oct 2005: select all not bshow if user has inverted the filter
                    '
1670            ElseIf (bShow And Not gbInvertFilters) Or (gbInvertFilters And Not bShow) Then
1680                If glShowCount > UBound(lNamesIndex) Then ReDim Preserve lNamesIndex(UBound(lNamesIndex) + 10) As Long
1690                lNamesIndex(glShowCount) = lCount
1700                glShowCount = glShowCount + 1
1710            End If
1720        End If
1730    Next


1740    Application.EnableCancelKey = xlInterrupt
1750    On Error GoTo 0                               ''' crw dec 30 2002
        '
        ' CRW Oct 18 2002: 2 column listbox
        '
        ' build vboxcontent  and find the maximum lengths of the names and the refersto/names2
        '
1760    If glShowCount > 0 Then
1770        ReDim vBoxContent(glShowCount - 1, 1) As Variant
1780        lMaxLength1 = 0
1790        lMaxLength2 = 0
1800        For lCount = 0 To glShowCount - 1
1810            vBoxContent(lCount, 0) = gsNames(lNamesIndex(lCount))
1820            If Len(gsNames(lNamesIndex(lCount))) > lMaxLength1 Then lMaxLength1 = Len(gsNames(lNamesIndex(lCount)))
1830            If gbOverlap Then
                    '
                    ' none in refersto/overlaps with column if invertfilters
                    ' crw 2/nov/2005
                    '
1840                If Not gbInvertFilters Then
1850                    vBoxContent(lCount, 1) = gsNames(lNamesIndex2(lCount))
1860                Else
1870                    vBoxContent(lCount, 1) = "None"
1880                End If
1890                If Len(vBoxContent(lCount, 1)) > lMaxLength2 Then lMaxLength2 = Len(vBoxContent(lCount, 1))
1900            Else
1910                If gbShowRefersto Then
1920                    vBoxContent(lCount, 1) = gsRefersto(lNamesIndex(lCount))
1930                    If Len(gsRefersto(lNamesIndex(lCount))) > lMaxLength2 Then lMaxLength2 = Len(gsRefersto(lNamesIndex(lCount)))
1940                End If
1950            End If
1960        Next lCount
            '
            ' set column widths
            '
1970        If lMaxLength1 < 12 Then lMaxLength1 = 12    ''' crw 18 oct 2005 allow for sort buttons
1980        If gbMacOS And lMaxLength1 < 10 Then lMaxLength1 = 10
1990        dWidth = 5.25                             ''' crw 1/1/2003
2000        If gbMacOS Then dWidth = 6.3
2010        If gbMacX Then dWidth = 6.3
            '
            ' crw 7/10/2005 : make sure the splitter bar and some of the refersto always show
            '
            ' crw 18/10/2005 : adjusted column widths to allow for visible splitter bar & sort buttons
            '
2020        If lMaxLength1 > (.Width - 220) / dWidth Then lMaxLength1 = (.Width - 220) / dWidth
2030        If Not gbFixSplit Then
                '
                ' do not allow the automatic movement to move past the last manual set of the splitter bar
                '
                '            If glLastSplitLeft > 0 Then
                '                lSplitLeft = (glLastSplitLeft - .lblColumn1.Left - 3) / dWidth
                '                If lMaxLength1 > lSplitLeft Then lMaxLength1 = lSplitLeft
                '            End If
                '
                ' crw 18/10/2005 fix showrefersto & overlap
                '
2040            If Not (gbShowRefersto Or gbOverlap) Then
2050                .lbxNames.ColumnWidths = Int(.lbxNames.Width - 4) & ";0"
2060                .lblColumn1.Width = .lbxNames.Width - 4
2070                .lblColumn2.Left = .lbxNames.Width + 10
2080                .lblColumn2.Width = 2


                    'crw 18/10/2005 Move the splitter bar & sort buttons
2090                .lblSplitterBar.Left = .lblColumn1.Left + .lblColumn1.Width + 1
2100                .lblSortNameDesc.Left = .lblColumn1.Left + .lblColumn1.Width - .lblSortNameDesc.Width - 1.5
2110                .lblSortNameAsc.Left = .lblSortNameDesc.Left - .lblSortNameAsc.Width

2120                .lblSortRefersDesc.Left = .lblColumn2.Left + .lblColumn2.Width + 10
2130                .lblSortRefersAsc.Left = .lblSortRefersDesc.Left - .lblSortRefersAsc.Width
2140            Else

                    ' crw nov 18 adjusted column1 width etc
2150                lMaxLength2 = IIf(lMaxLength2 > 100, 100, lMaxLength2)
2160                .lbxNames.ColumnWidths = CStr(CInt(lMaxLength1 * dWidth + 2)) & ";" & CStr(CInt(lMaxLength2 * dWidth))
2170                .lblColumn1.Width = lMaxLength1 * dWidth + 2

                    'SB 07 Oct 04 Move the splitter bar too
2180                .lblSplitterBar.Left = .lblColumn1.Left + .lblColumn1.Width + 1.5

                    'SB 12 Oct 04 Move the Name Sort buttons
2190                .lblSortNameDesc.Left = .lblColumn1.Left + .lblColumn1.Width - .lblSortNameDesc.Width - 1.5
2200                .lblSortNameAsc.Left = .lblSortNameDesc.Left - .lblSortNameAsc.Width

2210                .lblColumn2.Left = .lblColumn1.Left + lMaxLength1 * dWidth + 9

2220                If lMaxLength1 * dWidth + 2 < .lbxNames.Width Then    ''' crw dec27 2002
2230                    .lblColumn2.Width = Abs(.lbxNames.Width - (lMaxLength1 * dWidth) - 9)

                        'SB 12 Oct 04 Move the Name Sort buttons
2240                    .lblSortRefersDesc.Left = .lblColumn2.Left + .lblColumn2.Width - .lblSortRefersDesc.Width - 1.5
2250                    .lblSortRefersAsc.Left = .lblSortRefersDesc.Left - .lblSortRefersAsc.Width

2260                End If
2270            End If

2280        End If
            '
            ' fill listbox: switch to single item method if list has changed (weird bug) crw 3/2/2003
            '
            'If (bMulti And gbMacOS) Or gbListChanged Then    crw 17/9/2003
            '
            ' only fill formanalyse if there
            '
2290        If (gbShowRefersto And gbMacOS) Or gbListChanged Then    'Mac modification 31 Dec 02
2300            For lCount = 0 To glShowCount - 1
2310                .lbxNames.AddItem vBoxContent(lCount, 0)
2320                .lbxNames.List(lCount, 1) = vBoxContent(lCount, 1)
2330                If Not gfrmAnalyse Is Nothing Then gfrmAnalyse.cbbNames.AddItem gsNames(lCount)
2340            Next lCount
2350        Else
2360            .lbxNames.List() = vBoxContent
2370            If Not gfrmAnalyse Is Nothing Then gfrmAnalyse.cbbNames.List() = gsNames
2380        End If
2390    End If

2400    If .lbxNames.ListCount > 0 Then
2410        .lbxNames.AddItem " "
2420    End If
        ' end of 2 column listbox code
        '

Finish:
2430    Set oRng1 = Nothing

2440    .lblCount = ReworkMsg(gsMsgs(61), glShowCount, glNameCount)
        'Application.ScreenUpdating = True  ''' crw 16/10/2005
2450    Application.StatusBar = False
2460    Application.Cursor = lSaveCursor              ''' crw Nov 12
2470    gbDisableEvents = False
2480  End With
GoExit:

2490  PopStack3
End Sub
Sub GetIndex()
'
' rewritten CRW Nov 4
' restores the selection of names
' checks if the selection exists in the listbox
'  if so gets the index to gsNames of the selected name
' otherwise selects the first name in the listbox
'
' note does not change the list of selected names
'
' performance improved crw 13/1/2003
'
    Dim lCount As Long
    Dim jName As Long
    Dim jMaxNames As Long
    Dim sActivecell As String
    Dim blScreenUpdating As Boolean
    Dim oSht As Worksheet
    Dim lPos As Long
    Dim str1 As String
    Dim vActive As Variant

10  PushStack3 "GetIndex"
20  blScreenUpdating = Application.ScreenUpdating
    'Application.ScreenUpdating = False         ''' crw 16/10/2005
30  With gfrmNameManager
40      gbDisableEvents = True
50      glActive = 0
60      .tbEditName = ""
70      If .lbxNames.ListCount > 0 Then
80          If glNamegsSelected > 0 Then
90              glNamegsSelected = 0
100             With .lbxNames

                    'JKP Oct 14 2005: obsolete
                    '110                 ReDim Preserve bSelected(getnametablecount()) As Boolean

110                 jMaxNames = UBound(gsSelected)

                    '
                    ' crw 20/10/04 use new string array of selected names
                    ' loop on selected names in gsSelected

120                 For jName = 1 To jMaxNames
130                     If Len(gsSelected(jName)) > 0 Then
                            '
                            ' try to find the name in the listbox
                            '
140                         For lCount = 0 To .ListCount - 1
150                             If gsSelected(jName) = .List(lCount, 0) Then
                                    '
                                    ' name is found in the listbox
                                    ' now try to find it in gsNames
                                    '
160                                 If .MultiSelect = fmMultiSelectSingle Then
                                        'JKP Jan 07 2005 added check for overlaps
                                        'avoids changing selection
170                                     If Not gbOverlap Then
180                                         .ListIndex = lCount
190                                     End If
                                        '
                                        ' get index to gsNames
                                        '
200                                     vActive = vCustomMatch(gsSelected(jName), gsNames, 0)
210                                     If Not IsError(vActive) Then
220                                         glActive = vActive - 1
230                                         glNamegsSelected = 1
240                                     End If
250                                     Exit For
260                                 Else
270                                     .Selected(lCount) = True
280                                     glNamegsSelected = glNamegsSelected + 1
290                                     If glActive = 0 Then
                                            '
                                            ' get index to gsNames
                                            '
300                                         vActive = vCustomMatch(gsSelected(jName), gsNames, 0)
310                                         If Not IsError(vActive) Then
320                                             glActive = vActive - 1
330                                         End If
340                                         Exit For
350                                     End If
360                                 End If
370                             End If
380                         Next lCount
390                     End If
400                 Next jName
410             End With
420             On Error GoTo 0
430         End If

            '
440         If glActive <= 0 Or glNamegsSelected = 0 Then
                ' crw Nov 7, fix default
450             vActive = vCustomMatch(.lbxNames.List(0, 0), gsNames, 0)
460             If Not IsError(vActive) Then
470                 glActive = vActive - 1
480                 glNamegsSelected = 1
490             End If
500             If .lbxNames.MultiSelect = fmMultiSelectSingle Then
510                 .lbxNames.ListIndex = 0
520             Else
530                 .lbxNames.Selected(0) = True
540             End If
550         End If

560         If Len(gsNames(glActive)) > 0 Then
570             If gbTable(glActive) Then
580                 .tbEditName = strGetTableRefersTo(FindTableName(gsNames(glActive)))
590             Else
600                 .tbEditName = strGetRefersTo(FindName(gsNames(glActive)))
610             End If
620         Else
630             .tbEditName = ""
640         End If

650         ShowlblRefersto                           ''' change the name refersto label
660     End If
        '
        ' crw nov 12 auto goto when selection changes or filter changes
        '
        '????
        'GoActiveName
670     gbDisableEvents = False
680 End With
    '    Exit Sub
    'nomatch:
    '    Resume nextname
GoExit:
690 Set oSht = Nothing
    '
    ' crw jul 7 2003 switch off active cell checked
    '
700 gbActiveCellChecked = False
710 If Application.ScreenUpdating <> blScreenUpdating Then
720     Application.ScreenUpdating = blScreenUpdating
730 End If
740 PopStack3
End Sub
Sub RememberSelectedNames()
'JKP 13 Oct 2005: Stores list of selected names in lbxnames
' crw 18/oct/04 optimise redim
'
    Dim lCount As Long
10  PushStack3 "RememberSelectedNames"
20  With gfrmNameManager
30      ReDim gsSelected(10) As String
40      glNamegsSelected = 0
50      If .lbxNames.ListCount > 0 Then
            'prevent last entry to be selected
60          If funCountSelected = 1 And .lbxNames.Selected(.lbxNames.ListCount - 1) Then
70              .GetTopIndex
80              .lbxNames.Selected(.lbxNames.ListCount - 1) = False
90              .lbxNames.Selected(.lbxNames.ListCount - 2) = True
100             .SetTopIndex
110         Else
                '
                ' crw 20 Oct 2005: dont reset unless needed
                '
120             If .lbxNames.Selected(.lbxNames.ListCount - 1) Then
130                 .GetTopIndex
140                 .lbxNames.Selected(.lbxNames.ListCount - 1) = False
150                 .SetTopIndex
160             End If
170         End If
180         For lCount = 0 To .lbxNames.ListCount - 2
190             If .lbxNames.Selected(lCount) Then
200                 glNamegsSelected = glNamegsSelected + 1
210                 If glNamegsSelected > UBound(gsSelected) Then ReDim Preserve gsSelected(glNamegsSelected + 10)
220                 gsSelected(glNamegsSelected) = .lbxNames.List(lCount)
230             End If
240         Next
250     End If
260 End With
270 If glNamegsSelected > 0 Then
280     ReDim Preserve gsSelected(glNamegsSelected)
290 Else
300     ReDim Preserve gsSelected(1)
310 End If
320 PopStack3
End Sub
'Sub RememberSelectedNames()
'' crw Nov 4 2002: store indexes to selected names on exit from the names listbox
'' crw Nov 5 2002: better error handling
'    Dim j As Long
'    Dim jName As Variant       ''' index to gsNames
'
'10  PushStack3 "RememberSelectedNames"
'20  With gfrmNameManager
'30      ReDim bSelected(getnametablecount()) As Boolean
'40      glNamegsSelected = 0
'50      If .lbxNames.ListCount > 0 Then
'60          If .lbxNames.MultiSelect = fmMultiSelectSingle Then
'70              On Error GoTo nosingle
'80              jName = vcustommatch(.lbxNames.Value, gsNames, 0) - 1
'90              bSelected(jName) = True
'100             glNamegsSelected = 1
'110         Else
'120             On Error GoTo nomultiple
'130             For j = 0 To .lbxNames.ListCount - 1
'140                 If .lbxNames.Selected(j) Then
'150                     jName = vcustommatch(.lbxNames.List(j, 0), gsNames, 0) - 1
'160                     bSelected(jName) = True
'170                     glNamegsSelected = glNamegsSelected + 1
'180                 End If
'nextname:
'190             Next j
'200         End If
'210     End If
'220 End With
'nosingle:
'230 PopStack3
'240 Exit Sub
'nomultiple:
'250 Resume nextname
'End Sub
Sub AcceptChange()
' crw nov 7 globallocal

    Dim lCursorSave As Long
    Dim glCalcMode As Long
    Dim bWasRelative As Boolean
    Dim sOldRefLocal As String
    Dim blTable As Boolean
    Dim oTable As ListObject
    Dim stradRange As String
    Dim iPos As String


10  PushStack3 "AcceptChange"
20  lCursorSave = Application.Cursor                  ''' crw nov 12 2002
30  glCalcMode = Application.Calculation
40  Application.Calculation = xlCalculationManual
50  gbAddSheet = False                                ''' crw apr 12 2003
60  If gsRefersto(glActive) <> gsNewRefersTo And gsNewRefersTo <> "" Then
70      If IsNameValid(gsNames(glActive), True) Then
80          If IsTableName(gsNames(glActive)) Then
90              On Error GoTo NoResize
100             Set oTable = FindTableName(gsNames(glActive))
110             If oTable Is Nothing Then
120                 MsgBox "Cannot find table '" & gsNames(glActive) & "'", vbOKOnly + vbCritical, gstrFastXL
130                 GoTo GoExit
140             End If
150             stradRange = gsNewRefersTo
160             iPos = InStr(gsNewRefersTo, "!")
170             If iPos > 0 Then
180                 stradRange = Right(stradRange, Len(stradRange) - iPos)
190             End If
200             oTable.Resize Range(stradRange)
210             On Error GoTo 0
220         Else
                '
                ' check if relative and active cell changed crw 8/10/2005
                '
230             If IsNameRelative(FindName(gsNames(glActive)).RefersToR1C1) Then
240                 If goRelAnchor.Address <> ActiveCell.Address Then

                        ' ********** new message

250                     MsgBox gsMsgs(78), vbOKOnly + vbCritical, gsAppName
260                     gbRepErr = True
270                     Exit Sub
280                 End If
290             End If
                '
                ' crw 26 feb 2005: fix for change ignored unless gbAcknowledge
                '
300             If gbAcknowledge Then
310                 If ShowMsg(ReworkMsg(gsMsgs(58), gsNames(glActive), gsRefersto(glActive), gsNewRefersTo), vbQuestion + vbYesNo) = vbNo Then
320                     gsNewRefersTo = gsRefersto(glActive)
                        '
                        ' crw 9/9/2005: exit from replace all if user cancels
                        '
330                     gbRepErr = True
340                     Exit Sub
350                 End If
360             End If
                'JKP Jan 30 2003: local names on sheets cause trouble when containing "[" or "]" or chr(3)
370             If Not IsNameRefersToLegal(gsNames(glActive), gsRefersto(glActive)) Then
380                 gbBreak = IllegalNames(gsNames(glActive))
390             Else
                    ' crw nov 7,12 ; set cursor to wait
400                 Application.Cursor = xlWait
                    '
                    ' crw 2 July 2003 check for name being changed from abs to rel
                    '
                    'JKP 13-7-2009: ask for confirmation when changing form absolute to relative
410                 bWasRelative = IsNameRelative(FindName(gsNames(glActive)).RefersToR1C1)
420                 sOldRefLocal = FindName(gsNames(glActive)).RefersToLocal
430                 ChangeRefersTo gsNewRefersTo
440                 If Not bWasRelative And IsNameRelative(FindName(gsNames(glActive)).RefersToR1C1) Then
                        '
                        ' warn user that name has been changed from absolute to relative
                        '
450                     If ShowMsg(ReworkMsg(gsMsgs(6), gsNames(glActive)), vbExclamation + vbYesNo) = vbYes Then
                            'Do nothing, change accepted
460                     Else
                            'Revert change
470                         ChangeRefersTo sOldRefLocal
480                         gsNewRefersTo = sOldRefLocal
490                     End If
500                 Else
510                     ChangeRefersTo gsNewRefersTo
520                 End If
530             End If
540         End If
550     Else
560         gsNewRefersTo = gsRefersto(glActive)
570     End If
580 End If
590 DeleteAddSheet                                    ''' crw apr 12 2003
    ' crw nov 5 2002
GoExit:
600 Application.Cursor = lCursorSave
610 If Application.Calculation <> glCalcMode Then Application.Calculation = glCalcMode
620 PopStack3
630 Exit Sub
NoResize:
640 On Error GoTo 0
650 MsgBox "Resize for Table '" & gsNames(glActive) & "' Failed", vbOKOnly + vbExclamation, gstrFastXL
    'ChangeRefersTo sOldRefLocal
660 gsNewRefersTo = sOldRefLocal
670 GoTo GoExit
End Sub
Sub ChangeRefersTo(sNewRefersTo As String)
'
' crw 2 july 2003 : split out code to sub
'
' crw 6/10/2005 eliminate screen upadting unless switching sheets
'
    Dim gbGlobalLocal As Boolean
10  PushStack3 "ChangeRefersto"
20  gsRefersto(glActive) = sNewRefersTo

    ' crw Nov 7: switch to different sheetwhen required
30  gbGlobalLocal = False
40  If IsNameGlobalLocal(ActiveSheet, gsNames(glActive)) Then
50      gbGlobalLocal = True
60      Application.ScreenUpdating = False
70      SwitchtoDifferentSheet gsNames(glActive)
80  End If
90  DoEvents                                          ''' get ready for sendkeys
    'On Error Resume Next

    'JKP Jan 02 2003 changed to new sub

100 RedefineAName gsNames(glActive), gsRefersto(glActive)
    ' crw nov 7: switchback when required
110 If gbGlobalLocal Then
120     SwitchSheetBack
130     Application.ScreenUpdating = True
140 End If
    '
    ' crw 19/8/2005 removed following line
    '
    'ActiveWorkbook.Names(glActive).Visible = gbVisible(glActive)
150 PopStack3
End Sub
Sub AddAName()

10  PushStack3 "AddAName"
20  Application.Dialogs(xlDialogDefineName).Show
GoExit:
30  PopStack3
End Sub
Sub RemoveBar()

10  PushStack3 "RemoveBar"
20  On Error Resume Next

30  Application.CommandBars("ManageNames").Delete
GoExit:
40  PopStack3
End Sub
Sub CreateBar()
    Dim oBar As CommandBar
    Dim oControl As CommandBarControl

10  PushStack3 "CreateBar"
20  RemoveBar

30  Set oBar = Application.CommandBars.Add
40  Set oControl = oBar.Controls.Add(Id:=855, Before:=1)
50  oBar.Name = "ManageNames"
60  oBar.Visible = True
70  oControl.OnAction = "ManageNames"
80  oControl.Caption = "Name Manager"
GoExit:
90  PopStack3
End Sub
Sub HideUnhideNames(sAction As String)

10  PushStack3 "HideUnhideNames"
    Dim lCount As Long
    Dim lCurrent As Long
    Dim sTemp As String
    Dim vCurrent As Variant
20  If gbAcknowledge Then
30      If ShowMsg(ReworkMsg(gsMsgs(7), sAction), vbYesNo + vbQuestion) = vbNo Then
40          ShowMsg ReworkMsg(gsMsgs(8), sAction), vbOKOnly + vbExclamation
50          GoTo GoExit
60      End If
70  End If
80  With gfrmNameManager
90      For lCount = 0 To .lbxNames.ListCount - 1
100         If .lbxNames.Selected(lCount) <> 0 Then
110             sTemp = .lbxNames.List(lCount)
                '
                ' CRW 23 April 2014 Tables
                '
120             If Not IsTableName(sTemp) Then
                    '
                    ' crw 18 Oct 2002: 2 column listbox
                    ' crw 11/aug/2006 fix for custommamtch
                    '
130                 vCurrent = vCustomMatch(sTemp, gsNames, 0)
140                 If Not IsError(vCurrent) Then
150                     vCurrent = vCurrent - 1
160                     HideUnhideAName CLng(vCurrent), gbHide
170                 End If
180             End If
190         End If
200     Next
210 End With
GoExit:
220 PopStack3
End Sub
Sub HideUnhideAName(lIndex As Long, bHidden As Boolean)

10  PushStack3 "HideUnhideAName"
20  If bHidden Then
30      FindName(gsNames(lIndex)).Visible = False
40      gbVisible(lIndex) = False
50  Else
60      FindName(gsNames(lIndex)).Visible = True
70      gbVisible(lIndex) = True
80  End If
GoExit:
90  PopStack3
End Sub

Function MakeSendKey(ByVal sKeysToSend As String) As String
    Dim strTest As String

10  PushStack3 "MakeSendKey"
    ' JKP fix NM 644 31 Oct 2014
20  sKeysToSend = Replace5(sKeysToSend, "{", "_FXLNM1_{_FXLNM2_")
30  sKeysToSend = Replace5(sKeysToSend, "}", "_FXLNM1_}_FXLNM2_")
40  sKeysToSend = Replace5(sKeysToSend, "_FXLNM1_", "{")
50  sKeysToSend = Replace5(sKeysToSend, "_FXLNM2_", "}")
60  sKeysToSend = Replace5(sKeysToSend, "[", "{[}")
70  sKeysToSend = Replace5(sKeysToSend, "]", "{]}")
80  sKeysToSend = Replace5(sKeysToSend, "+", "{+}")
90  sKeysToSend = Replace5(sKeysToSend, "^", "{^}")
100 sKeysToSend = Replace5(sKeysToSend, "%", "{%}")
110 sKeysToSend = Replace5(sKeysToSend, "~", "{~}")
120 sKeysToSend = Replace5(sKeysToSend, "(", "{(}")
130 sKeysToSend = Replace5(sKeysToSend, ")", "{)}")
140 SendKeys "'c~"
150 strTest = InputBox("")
    '
    ' CRW 25 June 2014 - fix for traditional Chinese!
    '
160 If strTest = Chr(231) Then
170     sKeysToSend = Replace5(sKeysToSend, "'", "' ", 1)
180 End If
190 MakeSendKey = sKeysToSend
GoExit:
200 PopStack3
End Function

Sub ListNamesOnSheet()
    Dim oListsheet As Worksheet
    Dim oCurSheet As Worksheet
    Dim oName As Name
    Dim lCount As Long
    Dim glCalcMode As Long
    Dim bListAll As Boolean
    Dim j As Long
    Dim oTable As Range

    ''' CRW 25 June 2014 Tables

10  If TypeName(ActiveSheet) = "Worksheet" Then
20      Set oCurSheet = ActiveSheet
30  End If
40  PushStack3 "ListNamesOnSheet"
50  If gbAcknowledge Then
60      If ShowMsg(ReworkMsg(gsMsgs(9)), vbYesNo + vbQuestion) = vbNo Then
70          GoTo GoExit
80      End If
90  End If
    ' JKP: Jan 24 2003: filter the list?
100 If ShowMsg(ReworkMsg(gsMsgs(10)), vbYesNo + vbQuestion) = vbNo Then
110     bListAll = True
120 Else
130     bListAll = False
140 End If
    '
    ' JKP, nov 4 2002: Moved the screenupdating and added turning off Calculation
    '
150 Application.ScreenUpdating = False
160 glCalcMode = Application.Calculation
170 Application.Calculation = xlCalculationManual
180 lCount = 1
190 On Error Resume Next
200 Set oListsheet = ActiveWorkbook.Worksheets("Names " & Format(Now, "yyyy-mmm-dd"))
210 If oListsheet Is Nothing Then
        'JKP Build 566: prevent sheetchange event
220     gclNameEvent.DisableSheetEvent = True
230     Set oListsheet = ActiveWorkbook.Worksheets.Add
240     If Not oCurSheet Is Nothing Then oCurSheet.Activate
250     gclNameEvent.DisableSheetEvent = False
260 Else
270     If gbAcknowledge Then
            'JKP Jan 24 2003: fixed to tidyup (set calcmode back and screenupdating)
280         If ShowMsg(ReworkMsg(gsMsgs(11), oListsheet.Name), vbYesNo + vbQuestion) = vbNo Then GoTo TidyUp
290     End If
300     oListsheet.UsedRange.EntireColumn.Delete
310 End If

320 With oListsheet
330     .Name = "Names " & Format(Now, "yyyy-mmm-dd")
340     .Cells.NumberFormat = "@"
350     .Cells(1, 1) = "Name"
360     .Cells(1, 2) = "RefersToLocal"
370     .Cells(1, 3) = "Visible"
380     .Cells(1, 4) = "Local name"
390     .Cells(1, 5) = "Error"
400     .Cells(1, 6) = "External link"
        ' crw Nov 5 added extra columns
410     .Cells(1, 7) = "Relative"
420     .Cells(1, 8) = "3-D"
430     .Cells(1, 9) = "Areas"
440     .Cells(1, 10) = "Cells"
        'JKP Feb 7 2003: added a column
450     .Cells(1, 11) = "UnUsed"
460     .Cells(1, 12) = "RefersToRange"
470     .Range(.Cells(1, 1), .Cells(1, 11)).Font.Bold = True
        'JKP build 566: prevent sheetchange event
480     gclNameEvent.DisableSheetEvent = True
490     .Activate
500     gclNameEvent.DisableSheetEvent = False
510     .Cells(1, 1).Select                           ''' crw july 5 2003: relative names always rel to a1

520     For Each oName In ActiveWorkbook.Names
            'JKP: Jan 08 2003 Omit Filterdatabase names of the listsheet
530         If Not oName.Name Like "'Names ####-???-##'*" Then
                ' crw 2/8/2006 use name local
540             If bListAll Or IsNameOnUF(oName.NameLocal) Then
550                 lCount = lCount + 1
560                 .Cells(lCount, 1) = oName.Name
                    ' crw modified 31 Oct 2002
                    ' crw modified 1 July 2003
                    ' CRW added "'" 16/02/15
570                 .Cells(lCount, 2) = "'" & strGetRefersTo(oName)
580                 .Cells(lCount, 3) = oName.Visible    'visible name
590                 .Cells(lCount, 4) = InStr(oName.NameLocal, "!") > 0    'local name
                    'JKP Feb 7 2003: Fixed #REF for international users
                    'JKP Feb 7 2003: Added check for valid name
600                 .Cells(lCount, 5) = (HasHashInFormula(oName.RefersTo) = True Or (Not (IsNameValid(oName.Name, False))))    'name With Error
                    ' crw remodified Oct 31 2002
610                 .Cells(lCount, 6) = InStr(oName.RefersTo, "[") > 0    'name withexternal link
                    ' crw nov 5
620                 .Cells(lCount, 7) = IsNameRelative(FindName(oName.Name).RefersToR1C1)    ' relative
630                 .Cells(lCount, 8) = IsNameThreeD(oName.Index)    ' 3-d
640                 .Cells(lCount, 9) = Name2DRangeAreas(FindName(oName.Name))    ' num of areas , 0 if not resolvable as a range
                    ' crw 18 nov 2002 fix count
650                 .Cells(lCount, 10) = FindName(oName.NameLocal).RefersToRange.Cells.Count    ' num of cells
                    'JKP Feb 7 2003: added a column with used property if applicable
660                 If gbUnUsed Then
670                     If IsNameOnUF(oName.NameLocal) Then
680                         .Cells(lCount, 11) = True
690                     Else
700                         .Cells(lCount, 11) = False
710                     End If
720                 Else
730                     .Cells(lCount, 11) = "Not checked"
740                 End If
750                 .Cells(lCount, 12) = FindName(oName.NameLocal).RefersToRange.Address(external:=True)
760             End If
770         End If
780     Next
        '
        ' add table names crw Jun 25 2014
        '
790     If gbFxl Then
800         For j = 1 To glNameCount
810             If IsTableName(gsNames(j)) Then
820                 If bListAll Or IsNameOnUF(gsNames(j)) Then
830                     lCount = lCount + 1
840                     .Cells(lCount, 1) = gsNames(j)
                        ' CRW added "'" 16/02/15
850                     .Cells(lCount, 2) = "'" & gsRefersto(j)
860                     .Cells(lCount, 3) = True    'visible name
870                     .Cells(lCount, 4) = "Table"
880                     .Cells(lCount, 9) = 1
890                     Set oTable = Nothing
900                     Set oTable = Range(gsRefersto(j))
910                     .Cells(lCount, 10) = oTable.Cells.Count
920                     .Cells(lCount, 11) = "Not checked"
930                     .Cells(lCount, 12) = gsRefersto(j)
940                 End If
950             End If
960         Next j
970     End If


980     .UsedRange.Cells.EntireColumn.AutoFit
        'JKP: added to avoid too wide refersto column
990     .Cells(, 2).EntireColumn.ColumnWidth = 47
        '
        'JKP: nov. 4 2002: wrap refersto
        '
1000    .Cells(, 2).EntireColumn.WrapText = True
        ' crw nov 5

1010    .UsedRange.AutoFilter
1020 End With
    '
    'JKP nov. 4 2002: Restore calc mode
    '
TidyUp:
1030 If Application.Calculation <> glCalcMode Then Application.Calculation = glCalcMode
1040 Application.ScreenUpdating = True
1050 Set oListsheet = Nothing
1060 oCurSheet.Activate
GoExit:
1070 PopStack3
End Sub

Sub PickUpNamesFromList()
    Dim oListsheet As Worksheet
    Dim rRow As Range
    Dim oNewName As Name
    Dim sName As String
    Dim sNewName As String
    Dim lCalcSave As Long
    Dim lListSheetCount As Long
    Dim oListRange As Range

    '
    ' CRW 25 June 2014 : ignore tables
    '

10  PushStack3 "PickUpNamesFromList"
20  If gbAcknowledge Then
30      If ShowMsg(ReworkMsg(gsMsgs(12)), vbYesNo + vbQuestion) = vbNo Then
40          GoTo GoExit
50      End If
60  End If
    ' JKP: changed the check for a list sheet
70  lListSheetCount = CountListSheets
80  If lListSheetCount = 0 Then
90      ShowMsg ReworkMsg(gsMsgs(13)), vbOKOnly + vbExclamation
100     GoTo GoExit
110 End If
120 If lListSheetCount = 1 Then
130     Set oListsheet = ActiveSheet
140 Else
150     ShowMsg ReworkMsg(gsMsgs(72)), vbInformation + vbOKOnly
160 End If
    '
    ' crw july 5 2003: always do pickup relative to cell cell A1
    '
170 On Error Resume Next

    '180 Set oListRange = (ReworkMsg(gsMsgs(73)), gsAppName, Selection.Address, , , , , 8)

    'JKP Build 554: new range selecting form to prevent error with sheets with conditional
    '               formatting formulas
180 If SelectARange(ReworkMsg(gsMsgs(73)), gsAppName, oListRange) = False Then GoTo GoExit

190 On Error GoTo Failure
200 Application.ScreenUpdating = False
210 lCalcSave = Application.Calculation
220 Application.Calculation = xlCalculationManual
230 For Each rRow In oListRange.Cells.EntireRow.Rows
240     If rRow.Row <> 1 Then
250         If rRow.Cells(, 1).Value <> "" Then
260             Set oNewName = Nothing
270             sName = rRow.Cells(, 1).Value
280             On Error GoTo Failure                 ''' crw nov 18 2002
290             DoEvents                              ''' crw 18 nov 2002
300             If Not IsTableName(sName) Then
310                 sNewName = rRow.Cells(, 1).Value
                    'JKP Jan 30 2003: added because apostrophe sometimes is missing
320                 If InStr(sNewName, "'!") > 0 Then
330                     If Left$(sNewName, 1) <> "'" Then
340                         sNewName = "'" & sNewName
350                     End If
360                 End If
                    ' CRW 16/02/15 added a DoEvents
370                 DoEvents
                    'JKP Jan 02 2002, changed to call to sub
380                 RedefineAName sNewName, rRow.Cells(, 2).Value
390                 Set oNewName = FindName(sNewName)
400                 If Not (oNewName Is Nothing) Then
410                     oNewName.Visible = rRow.Cells(, 3)
420                 End If
430             End If
440         End If
450     End If
460 Next
470 On Error Resume Next
480 Set rRow = Nothing
490 Set oListsheet = Nothing
500 Set oNewName = Nothing
510 Application.ScreenUpdating = True
520 If Application.Calculation <> lCalcSave Then Application.Calculation = lCalcSave
GoExit:
530 PopStack3
540 Exit Sub
Failure:
550 ShowMsg ReworkMsg(gsMsgs(14), sName, Err.Description), vbOKOnly + vbCritical
560 Resume Next
End Sub

Function CountListSheets() As Long
    Dim oListsheet As Worksheet
    Dim iCount As Long
10  iCount = 0
20  PushStack3 "CountListSheets"
30  CountListSheets = False
40  For Each oListsheet In ActiveWorkbook.Worksheets
        'JKP 18 NOV 2002: changed INSTR to LIKE
50      If oListsheet.Name Like "Names ####-???-##" Then
60          iCount = iCount + 1
70      End If
80  Next
90  CountListSheets = iCount
100 Set oListsheet = Nothing
GoExit:
110 PopStack3
End Function

Sub MakeMenu()
    Dim cControl1 As CommandBarControl
    Dim cControl2 As CommandBarControl
10  PushStack3 "MakeMenu"
    'JKP Build 570: Disable for Excel 2007 xml workbooks
20  If Val(Application.Version) > 11 And _
       (UCase(Right(ThisWorkbook.Name, 4)) = "xlsm" _
        Or UCase(Right(ThisWorkbook.Name, 4)) = "xlam") Then Exit Sub
30  On Error Resume Next
40  RemoveMenu                                        'Prevent duplicate menu's

50  Set cControl1 = Application.CommandBars(1).FindControl(Id:=30007).Controls.Add(Type:=msoControlPopup, temporary:=True)
60  cControl1.Caption = gsMsgs(104)
70  Set cControl2 = cControl1.Controls.Add(Type:=msoControlButton, temporary:=True)
80  With cControl2
90      If gbShortCutKey Then
100         .Caption = gsMsgs(104) & "            " & "ctrl+shift+" & gsShortCutKey
110     Else
120         .Caption = gsMsgs(104)
130     End If
140     .OnAction = "fxlNameManager.ManageNames"
150 End With
160 Set cControl2 = cControl1.Controls.Add(Type:=msoControlButton, temporary:=True)
170 With cControl2
180     .Caption = gsMsgs(85)
190     .OnAction = "fxlNameManager.GetShortCutKey"
200 End With
210 Set cControl2 = cControl1.Controls.Add(Type:=msoControlButton, temporary:=True)
220 With cControl2
230     .Caption = gsMsgs(86)
240     .OnAction = "fxlNameManager.CreateBar"
250 End With
260 Set cControl2 = cControl1.Controls.Add(Type:=msoControlButton, temporary:=True)
270 With cControl2
280     .Caption = gsMsgs(103)
290     .OnAction = "fxlNameManager2.ResetScreenPosition"
300 End With

310 On Error GoTo 0
GoExit:
320 PopStack3
End Sub
Sub RemoveMenu()

10  PushStack3 "RemoveMenu"
20  On Error Resume Next
    'JKP Jan 09 2003: Menu not removed after reset project.

30  Application.CommandBars(1).FindControl(Id:=30007).Controls(gsMsgs(104)).Delete
40  On Error GoTo 0
GoExit:
50  PopStack3
End Sub
Sub ShowModeless()

10  PushStack3 "ShowModeless"
    #If VBA6 Or VBA7 Then
20      gfrmNameManager.Show vbModeless
    #End If
GoExit:
30  PopStack3
End Sub

Function IsNameRelative(sRefersToR1C1 As String) As Boolean
'
' function to return true if the name definition has a direct relative component
' Copyright |fffd| Decision Models 2002-2010. All rights Reserved
'
    Dim str1 As String

10  PushStack3 "IsNameRelative"
20  IsNameRelative = False
30  On Error GoTo GoExit
40  Application.EnableCancelKey = xlErrorHandler
    ' JKP Jan 29 2003: changed to avoid errors with peculiar sheetnames
50  str1 = Application.ConvertFormula(sRefersToR1C1, xlR1C1, xlR1C1)
60  If Len(str1) > 0 Then
70      If str1 <> Application.ConvertFormula(str1, xlR1C1, xlR1C1, xlAbsolute) Then IsNameRelative = True
80  End If
90  PopStack3
100 Exit Function
GoExit:
110 If Err = 18 Then
120     gbBreak = True
130 End If
140 Application.EnableCancelKey = xlInterrupt
150 On Error GoTo 0
160 PopStack3
End Function

Function IsNameselected(lNameIndex As Long) As Boolean
'
' function to return true if the name definition intersects any of the selected cells
' Copyright |fffd| Decision Models 2002-2010. All rights Reserved
'
    Dim oCell As Range

10  PushStack3 "IsNameselected"
20  IsNameselected = False
30  On Error GoTo GoExit
40  Application.EnableCancelKey = xlErrorHandler
50  If Not Selection Is Nothing Then
        ' crw Oct 31 check book name as well as sheet name
60      If Range(gsNames(lNameIndex)).Parent.Name = Selection.Parent.Name And _
           Range(gsNames(lNameIndex)).Parent.Parent.Name = Selection.Parent.Parent.Name Then
70          If Not Intersect(Range(gsNames(lNameIndex)), Selection) Is Nothing Then IsNameselected = True
80      End If
90  End If
100 PopStack3
110 Exit Function
GoExit:
120 If Err = 18 Then gbBreak = True
130 Application.EnableCancelKey = xlInterrupt
140 Set oCell = Nothing
150 On Error GoTo 0
160 PopStack3
End Function
Function IsNameRefertoActiveSheet(lNameIndex As Long) As Boolean
'
' function to return true if the name definition intersects any of the cells on the active sheet
' Copyright |fffd| Decision Models 2005-2010. All rights Reserved
'
    Dim oSheetRange As Range
10  PushStack3 "IsNameRefertoActiveSheet"
20  IsNameRefertoActiveSheet = False
30  On Error GoTo GoExit
40  Application.EnableCancelKey = xlErrorHandler
50  If Not ActiveSheet Is Nothing Then
        ' crw Oct 31 check book name as well as sheet name
60      If Range(gsNames(lNameIndex)).Parent.Name = ActiveSheet.Name And _
           Range(gsNames(lNameIndex)).Parent.Parent.Name = ActiveSheet.Parent.Name Then
            '
            ' fix for used range not starting in A1 - CRW 02Oct2009
            '
70          Set oSheetRange = ActiveSheet.Range("A1").Resize(ActiveSheet.UsedRange.Row + ActiveSheet.UsedRange.Rows.Count - 1, ActiveSheet.UsedRange.Column + ActiveSheet.UsedRange.Columns.Count - 1)
80          If Not Intersect(Range(gsNames(lNameIndex)), oSheetRange) Is Nothing Then IsNameRefertoActiveSheet = True
90          Set oSheetRange = Nothing
100     End If
110 End If
120 PopStack3
130 Exit Function
GoExit:
140 If Err = 18 Then gbBreak = True
150 Application.EnableCancelKey = xlInterrupt
160 On Error GoTo 0
170 PopStack3
End Function
Function IsNameThreeD(lNameIndex As Long) As Boolean
'
' function to return true if the name refers to a range of sheets
' Copyright Decision Models 2002-2010. All Rights Reserved
'
    Dim oSheet As Worksheet

10  PushStack3 "IsNameThreed"
20  IsNameThreeD = False
30  On Error GoTo nextsheet
40  Application.EnableCancelKey = xlErrorHandler
50  For Each oSheet In ActiveWorkbook.Worksheets
60      If InStr(gsRefersto(lNameIndex), oSheet.Name & ":") > 0 Then
70          IsNameThreeD = True
80          Exit For
90      End If
TheNext:
100 Next
GoExit:
110 Set oSheet = Nothing
120 Application.EnableCancelKey = xlInterrupt
130 PopStack3
140 Exit Function
nextsheet:
150 If Err <> 18 Then
160     Resume TheNext
170 Else
180     gbBreak = True
190     On Error GoTo 0
200     GoTo GoExit
210 End If
End Function
Function Name2DRangeAreas(oNm As Name) As Long
'
' function to return the number of ranges contained in the name
' returns zero if the name cannot be resolved as a range
' Copyright Decision Models 2002-2010. All Rights Reserved
'
10  PushStack3 "Name2DRangeAreas"
20  Name2DRangeAreas = 0
30  On Error GoTo not2drange
40  Application.EnableCancelKey = xlErrorHandler
50  Name2DRangeAreas = oNm.RefersToRange.Areas.Count
60  PopStack3
70  Exit Function
not2drange:
80  If Err = 18 Then gbBreak = True
90  Application.EnableCancelKey = xlInterrupt
100 On Error GoTo 0
110 PopStack3
End Function
Function Name2DRangeAreasRef(strRefersTo As String) As Long
'
' function to return the number of ranges contained in the refersto
' returns zero if the refersto cannot be resolved as a range
' or the refersto is a formula
' Copyright Decision Models 2002-2010. All Rights Reserved
'
' CRW 28/11/2016 - fix for dynamic range formulas
'
    Dim OpenPos As Long
    Dim QuotePos As Long
10  PushStack3 "Name2DRangeAreasRef"
20  Name2DRangeAreasRef = 0
30  On Error GoTo not2drange
40  Application.EnableCancelKey = xlErrorHandler
50  Name2DRangeAreasRef = Range(strRefersTo).Areas.Count
60  If Name2DRangeAreasRef = 1 Then
        '
        ' check for refersto formula returning a range
        '
70      OpenPos = InStr(strRefersTo, "(")
80      QuotePos = InStr(strRefersTo, "'")
90      If OpenPos > 0 Then
            '
            ' its a formula
            '
100         If QuotePos > 0 Then
                '
                ' if ( comes after ' then its a sheetname containing (
                '
110             If OpenPos < QuotePos Then Name2DRangeAreasRef = 0
120         Else
130             Name2DRangeAreasRef = 0
140         End If
150     End If
160 End If
170 PopStack3
180 Exit Function
not2drange:
190 If Err = 18 Then gbBreak = True
200 Application.EnableCancelKey = xlInterrupt
210 On Error GoTo 0
220 PopStack3
End Function
Sub BuildOverlaps(lCount As Long, glShowCount As Long, lNamesIndex() As Long, lNamesIndex2() As Long, oRng1 As Range)
'
' sub to add indexes to namesindex & namesindex2 if the name definition overlaps any other name definition
' 28 Oct 2002 crw; added exclusions
'
' Crw 13/1/2003: error handling and performance
'
' crw 18 oct 2005 : added invert filter
'
' Copyright Decision Models 2002-2010. All Rights Reserved
'
    Dim j As Long
    Dim jX As Long
    Dim strExclusions(3) As String
    ' modified, JKP
    Dim bSkip As Boolean
    Dim oRng2 As Range
    Dim bShow As Boolean

10  PushStack3 "BuildOverlaps"

20  strExclusions(1) = "*_FilterDatabase"
30  strExclusions(2) = "*Print_Area"
40  strExclusions(3) = "*Print_Titles"

50  bSkip = False
60  If lCount < glNameCount Then
        '
        ' check exclude for the first name
        '
70      For jX = 1 To 3
            ' modified, JKP
80          If gsNames(lCount) Like strExclusions(jX) Then
90              bSkip = True
100             Exit For
110         End If
120     Next jX
        ' modified, JKP
130     If Not bSkip Then
140         On Error GoTo TheNext
150         Application.EnableCancelKey = xlErrorHandler
            '
            ' if invert then stop as soon as found an overlap
            '
160         If gbInvertFilters Then bShow = False
            '
            ' check this name against all subsequent names
            '
170         For j = lCount + 1 To glNameCount
                '
                ' set to false for each name unless invert
                '
180             If Not gbInvertFilters Then bShow = False
190             Set oRng2 = Range(gsNames(j))
                ' crw Oct 31 2002 add book name check
200             If oRng1.Parent.Name = oRng2.Parent.Name And _
                   oRng1.Parent.Parent.Name = oRng2.Parent.Parent.Name Then
                    '
                    ' check exclude for the second name
                    '
210                 For jX = 1 To 3
220                     If gsNames(j) Like strExclusions(jX) Then
230                         bSkip = True
240                         Exit For
250                     End If
260                 Next jX
270                 If Not bSkip Then
                        '
                        ' check contains before the intersect
                        '
280                     If Not gbContains Or _
                           (gbContains And _
                            ((InStr(gsNames(j), gsContains) > 0) Or (InStr(gsNames(lCount), gsContains) > 0))) Then
290                         DoEvents
300                         If Not Intersect(oRng1, oRng2) Is Nothing Then

310                             bShow = True

320                         End If
330                     End If
340                     If bShow And Not gbInvertFilters Then
350                         If glShowCount > UBound(lNamesIndex) Then
360                             ReDim Preserve lNamesIndex(UBound(lNamesIndex) + 10) As Long
370                             ReDim Preserve lNamesIndex2(UBound(lNamesIndex) + 10) As Long
380                         End If
390                         lNamesIndex(glShowCount) = lCount
400                         lNamesIndex2(glShowCount) = j
410                         glShowCount = glShowCount + 1
420                     End If
                        '
                        ' invert and overlap stop
                        '
430                     If bShow And gbInvertFilters Then Exit For

440                 End If
450             End If
nextname:
460         Next j
            '
            ' if invert and not overlap show
            '
470         If Not bShow And gbInvertFilters Then
480             If glShowCount > UBound(lNamesIndex) Then
490                 ReDim Preserve lNamesIndex(UBound(lNamesIndex) + 10) As Long
500                 ReDim Preserve lNamesIndex2(UBound(lNamesIndex) + 10) As Long
510             End If
520             lNamesIndex(glShowCount) = lCount
530             lNamesIndex2(glShowCount) = -1        ''' None
540             glShowCount = glShowCount + 1
550         End If
560     End If
570 End If
GoExit:
580 Application.EnableCancelKey = xlInterrupt
590 Set oRng2 = Nothing
600 PopStack3
610 Exit Sub
TheNext:
620 If Err <> 18 Then
630     Resume nextname
640 Else
650     On Error GoTo 0
660     gbBreak = True
670     GoTo GoExit
680 End If
End Sub
'JKP Jan 08 2003: added sheet argument and changed second argument to name i.s.o. index
Function IsNameGlobalLocal(oSheet As Worksheet, sName As String) As Boolean
'
' function to check if the name is a global name with the same name as a local name on the sheet
' Copyright Decision Models 2002-2010. All Rights Reserved
'
    Dim oName As Name

10  PushStack3 "IsNameGlobalLocal"
20  IsNameGlobalLocal = False
30  On Error GoTo Errhandl
40  Application.EnableCancelKey = xlErrorHandler
    '
    ' crw 2/11/2005 use findnamelocal
    '
50  Set oName = FindNameLocal(oSheet, sName)

60  On Error GoTo 0
70  If Not oName Is Nothing Then IsNameGlobalLocal = True
GoExit:
80  Set oName = Nothing
90  PopStack3
100 Exit Function
Errhandl:
110 If Err = 18 Then
120     gbBreak = True
130     Application.EnableCancelKey = xlInterrupt
140     On Error GoTo 0
150 Else
160     Resume Next
170 End If
180 GoTo GoExit
End Function
Sub SwitchtoDifferentSheet(sGlobalName As String)
'
' Copyright Decision Models 2002-2010. All Rights Reserved
' crw nov 12 2002 allow for quoted sheetnames
'
' change to another sheet that does not contain a localised Global name, if none then add one
'
    Dim oSht As Worksheet
    Dim oAddSheet As Worksheet
    Dim oName As Name
    Dim bNeedSheet As Boolean

10  PushStack3 "SwitchtoDifferentSheet"
20  bNeedSheet = False
    '
    ' store current sheet and cell for switchback
    '
30  gsSavedSheetName = ActiveSheet.Name
    'JKP build 544: avoid errors when on chart sheet!
40  If TypeName(ActiveSheet) = "Worksheet" Then
50      gstrActiveAddress = ActiveCell.Address
60  End If
70  If ActiveWorkbook.Worksheets.Count = 1 Then
80      bNeedSheet = True
90  Else
100     bNeedSheet = True
        '
        ' look for sheet without a local name same as global name
        '
110     For Each oSht In ActiveWorkbook.Worksheets
120         If oSht.Name <> gsSavedSheetName Then     ''' skip active sheet
130             On Error Resume Next
                '
                ' use findnamelocal crw 2 Nov 2005
                '
140             Set oName = Nothing
150             Set oName = FindNameLocal(oSht, sGlobalName)
160             If oName Is Nothing Then
170                 gclNameEvent.DisableSheetEvent = True
180                 oSht.Activate
190                 Application.GoTo oSht.Range(gstrActiveAddress)
200                 gclNameEvent.DisableSheetEvent = False
210                 bNeedSheet = False
220                 Exit For
230             End If
240         End If
250     Next oSht
260 End If
    '
    ' if could not find a sheet then add one
    '
270 If bNeedSheet Then
280     If Not IsBookProtected(True) Then             ''' crw Nov 11 2002
290         Application.DisplayAlerts = False
300         On Error Resume Next
310         Set oAddSheet = ActiveWorkbook.Worksheets("QQFxlTemp999")
320         On Error GoTo 0
330         If oAddSheet Is Nothing Then
340             ActiveWorkbook.Worksheets.Add.Name = "QQFxlTemp999"
                '
                ' keep active cell the same to handle relative names
                '
350             Application.GoTo ActiveWorkbook.Worksheets("QQFxlTemp999").Range(gstrActiveAddress)
                '
                ' flag sheet as added
                '
360             gbAddSheet = True
370         End If
380         Application.DisplayAlerts = True
390     End If
400 End If
GoExit:
410 Set oName = Nothing
420 Set oSht = Nothing
430 Set oAddSheet = Nothing
440 PopStack3
End Sub
Sub SwitchSheetBack()
'
' Copyright Decision Models 2002-2010. All Rights Reserved
'
' change back to original sheet

10  PushStack3 "SwitchSheetBack"

20  On Error Resume Next
    'JKP Build 566: don't fire sheetchange event
30  gclNameEvent.DisableSheetEvent = True
40  ActiveWorkbook.Sheets(gsSavedSheetName).Activate
50  gclNameEvent.DisableSheetEvent = False
60  If TypeName(ActiveSheet) = "Worksheet" Then
70      Application.GoTo Range(gstrActiveAddress)
80  End If
GoExit:
90  PopStack3
End Sub
Sub DeleteAddSheet()
'
' Copyright Decision Models 2002-2010. All Rights Reserved
'
' delete added sheet
'

10  PushStack3 "DeleteAddSheet"
20  If gbAddSheet Then
30      Application.DisplayAlerts = False
40      On Error Resume Next
50      If Not IsBookProtected(False) Then
60          ActiveWorkbook.Worksheets("QQFxlTemp999").Delete
70      End If
80      On Error GoTo 0
90      Application.DisplayAlerts = True
100 End If
110 gbAddSheet = False
GoExit:
120 PopStack3
End Sub
Sub Localise()
'
' Copyright Decision Models 2002-2010. All Rights Reserved
'
' localise all selected names
'
' reworked crw 2 Nov 2005
'
' CRW 23 April 2014 Tables
'
    Dim lCount As Long
    Dim sTemp As String
    Dim sActiveSheet As String
    Dim lCalcSave As Long
    Dim lCursorSave As Long
    Dim bNameCancel As Boolean
    Dim bglActiveSheet As Boolean
    Dim nTots As Long
    Dim vNamesInNames() As Variant
10  lCalcSave = Application.Calculation

20  PushStack3 "Localise"

30  bglActiveSheet = False                            ''' crw april 13: choose active sheet question only once
40  If gbAcknowledge Then
50      If ShowMsg(ReworkMsg(gsMsgs(15)), vbYesNo + vbQuestion) = vbNo Then
60          ShowMsg ReworkMsg(gsMsgs(16)), vbOKOnly + vbInformation
70          GoTo GoExit
80      End If
90      gbKeep = ShowMsg(ReworkMsg(gsMsgs(17)), vbQuestion + vbYesNo) = vbNo
100 Else
110     gbKeep = True
120 End If
    '
    ' refresh the namesinnames array
    '
130 AllNamesInNames nTots, vNamesInNames()
    '
    ' switch to manual if needed because adding names triggers a recalc
    '
140 If Not Application.Calculation = xlCalculationManual Then Application.Calculation = xlCalculationManual
150 With gfrmNameManager
160     bNameCancel = False
170     For lCount = 0 To .lbxNames.ListCount - 1
180         If .lbxNames.Selected(lCount) Then
190             sTemp = .lbxNames.List(lCount, 0)
200             If Not IsTableName(sTemp) Then          ''' ignore tables
                    '
                    ' disallow local names
                    '
210                 If IsNameLocal(sTemp, False) Then
                        'JKP: 16 Dec 2002, added "Escape" opportunity: CRW dec 19 2002 : always exit
220                     ShowMsg ReworkMsg(gsMsgs(18), sTemp), vbOKOnly + vbCritical
230                     Exit For
240                 Else
250                     GlobalToLocal sTemp, bNameCancel, gbKeep, bglActiveSheet, nTots, vNamesInNames
260                     If bNameCancel Then Exit For      ''' crw dec 19 2002
270                 End If
280             End If
290         End If
300     Next lCount
310 End With

GoExit:
320 If Application.Calculation <> lCalcSave Then Application.Calculation = lCalcSave
330 PopStack3
End Sub


Sub GlobalToLocal(sGlobalName As String, bNameCancel As Boolean, gbKeep As Boolean, bglActiveSheet As Boolean, nTots As Long, vNamesInNames() As Variant)
'
' Copyright Decision Models 2002-2010. All Rights Reserved
'
' convert a name definition from global to local. crw Nov 7 2002
'
' reworked crw 25 october 2005
'
    Dim sGlobalReferstoR1C1 As String
    Dim sGlobalRefersto As String
    Dim bExists As Boolean
    Dim oName As Name
    Dim oActCell As Range

10  PushStack3 "GlobalToLocal"

20  bExists = False
30  gsSheet = ""                                      ''' initialise
    ' check for validity
40  If IsNameValid(sGlobalName, True) = False Then
50      gbBreak = True
60      GoTo GoExit
70  End If

80  Set oName = FindName(sGlobalName)
90  If oName Is Nothing Then GoTo Fail
100 sGlobalReferstoR1C1 = oName.RefersToR1C1
110 sGlobalRefersto = oName.RefersTo
120 If HasHashInFormula(sGlobalRefersto) = True Then
        '
        ' skip names containing errors
        '
130     gbBreak = True
140 Else
        '
        ' get the sheet to localise to
        '
150     gvSheetsReferredTo = FindReferencedSheets(sGlobalReferstoR1C1)    ''' get all sheets referenced
160     If UBound(gvSheetsReferredTo) > 1 Then
            '
            ' multiple sheets referenced: get user to choose
            '
170         ShowMsg ReworkMsg(gsMsgs(23), sGlobalName), vbOKOnly + vbExclamation    ''' Select sheet to localise to
180         GetTheSheet sGlobalName, False
190         If gbSelectedaSheet = False Then
200             ShowMsg ReworkMsg(gsMsgs(24), sGlobalName), vbOKOnly + vbCritical    ''' cancel, no selection
210             bNameCancel = True
220             GoTo GoExit
230         End If
240     Else
250         gsSheet = gvSheetsReferredTo(1)
260     End If
270     If gsSheet = "" Then
            '
            ' only ask first time (BglActiveSheet=false): crw apr 13 2003
            ' no sheets referred to, ask if use active sheet
            '
280         If Not bglActiveSheet Then
290             If ShowMsg(ReworkMsg(gsMsgs(25), sGlobalName), vbYesNo + vbQuestion) = vbNo Then GoTo GoExit
300         End If
310         bglActiveSheet = True                     ''' dont ask again
320         gsSheet = ActiveSheet.Name                ''' use active sheet
330     End If
        '
        ' if there already is a local name
        '
340     On Error Resume Next
350     Set oName = Nothing
360     Set oName = FindNameLocal(Worksheets(gsSheet), sGlobalName)
370     If Not oName Is Nothing Then
380         bExists = True
390     End If

400     On Error GoTo Fail
410     If bExists Then
            '
            ''' already defined, ask if choose another sheet
            '
420         If ShowMsg(ReworkMsg(gsMsgs(26), sGlobalName, gsSheet), vbYesNo + vbExclamation) <> vbYes Then
430             bNameCancel = True
440             GoTo GoExit
450         Else
460             GetTheSheet sGlobalName, True
470             If gbSelectedaSheet = False Then
480                 ShowMsg ReworkMsg(gsMsgs(24), sGlobalName), vbOKOnly + vbCritical    ''' cancel, no selection
490                 bNameCancel = True
500                 GoTo GoExit
510             End If
520         End If
530     End If
        '
        ' if we have a sheet to localise to
        '
540     If Not bNameCancel Then
            'JKP April 14 2005: first delete global name, then add local name.
550         If Not gbKeep Then
560             DeleteAName sGlobalName
                '
                ' check all names ; if refersto this name then change the ref to local
                '
570             If nTots > 0 Then ChangeNameRefersto sGlobalName, "'" & gsSheet & "'!" & sGlobalName, nTots, vNamesInNames()
580         End If

590         On Error GoTo Fail
600         ActiveWorkbook.Worksheets(gsSheet).Names.Add Name:=("'" & gsSheet & "'!" & sGlobalName), RefersToR1C1:=sGlobalReferstoR1C1
610         On Error GoTo 0

620     End If
630 End If
GoExit:
640 On Error GoTo 0
650 Set oName = Nothing
660 PopStack3
670 Exit Sub
Fail:
680 On Error GoTo 0
690 ShowMsg ReworkMsg(gsMsgs(27), sGlobalName, gsSheet), vbCritical + vbOKOnly    ''' unable to localise
700 Set oName = Nothing
    '
    'JKP: Test whether name localisation has succeeded, if not, restore global name!
    '
710 On Error Resume Next
720 Set oName = FindNameLocal(Worksheets(gsSheet), sGlobalName)
730 If oName Is Nothing Then
740     If Not gbKeep Then
750         RedefineAName sGlobalName, sGlobalRefersto
760     End If
770 End If
780 GoTo GoExit
End Sub
Sub Globalise()
'
' Copyright Decision Models 2002-2010. All Rights Reserved
'
' Globalise all selected names
'
' reworked crw 2 Nov 2005
'
' CRW 23 April 2014 tables
'
    Dim lCount As Long
    Dim sTemp As String
    Dim lCalcSave As Long
    Dim lCursorSave As Long
    Dim bNameCancel As Boolean
    Dim nTots As Long
    Dim vNamesInNames() As Variant

10  PushStack3 "Globalise"

20  If gbAcknowledge Then
30      If ShowMsg(ReworkMsg(gsMsgs(19)), vbYesNo + vbQuestion) = vbNo Then
40          ShowMsg ReworkMsg(gsMsgs(20)), vbOKOnly + vbInformation
50          GoTo GoExit
60      End If
70      gbKeep = ShowMsg(ReworkMsg(gsMsgs(21)), vbQuestion + vbYesNo) = vbNo
80  Else
90      gbKeep = True
100 End If
    '
    ' switch to manual if needed because adding names triggers a recalc
    '
110 lCalcSave = Application.Calculation
120 If Application.Calculation <> xlCalculationManual Then Application.Calculation = xlCalculationManual
130 If Application.ScreenUpdating = True Then Application.ScreenUpdating = False

140 gbAddSheet = False                                ''' crw apr 12 2003
    '
    ' refresh the namesinnames array
    '
150 AllNamesInNames nTots, vNamesInNames()

160 bNameCancel = False
170 With gfrmNameManager
180     For lCount = 0 To .lbxNames.ListCount - 1
190         If .lbxNames.Selected(lCount) Then
200             sTemp = .lbxNames.List(lCount, 0)
210             If Not IsTableName(sTemp) Then          ''' ignore tables
                    '
                    ' disallow global names
                    ' crw Dec 19: exit at first error
                    '
220                 If Not IsNameLocal(sTemp, False) Then
230                     ShowMsg ReworkMsg(gsMsgs(22), sTemp), vbOKOnly + vbCritical
240                     Exit For
250                 Else
260                     LocalToGlobal sTemp, bNameCancel, gbKeep, nTots, vNamesInNames
270                     If bNameCancel Then Exit For      ''' crw dec 19 2002
280                 End If
290             End If
300         End If
310     Next lCount
320 End With
    '
    ' if extra sheet was added then delete it
    '
330 DeleteAddSheet                                    ''' crw apr 12 2003
340 If Application.Calculation <> lCalcSave Then Application.Calculation = lCalcSave
350 If Application.ScreenUpdating = False Then Application.ScreenUpdating = True

GoExit:
360 PopStack3
End Sub
Sub LocalToGlobal(sLocalName As String, bNameCancel As Boolean, gbKeep As Boolean, nTots As Long, vNamesInNames() As Variant)
'
' Copyright Decision Models 2002-2010. All Rights Reserved
'
' modified crw Nov 12,13 2002: multiple names & sheets
'
' reworked crw 2 Nov 2005
'
    Dim sLocalRefersto As String
    Dim sLocalReferstoR1C1 As String
    Dim sGlobalName As String
    Dim bExists As Boolean
    Dim bSwitch As Boolean
    Dim oName As Name
    Dim oActCell As Range

10  PushStack3 "LocalToGlobal"

    'JKP Feb 6 2003: check for validity
20  If IsNameValid(sLocalName, True) = False Then
30      gbBreak = True
40      GoTo GoExit
50  End If


60  bSwitch = False
70  sGlobalName = Right$(sLocalName, Len(sLocalName) - FindExclamationRev(sLocalName))
    '
    ' check if global name already exists
    '
80  bExists = False
90  Set oName = FindName(sGlobalName)
100 If Not oName Is Nothing Then bExists = True

110 If bExists Then
120     ShowMsg ReworkMsg(gsMsgs(28), sLocalName), vbOKOnly + vbCritical
130     bNameCancel = True
140 Else
150     Set oName = Nothing
160     Set oName = FindName(sLocalName)
170     If oName Is Nothing Then GoTo Fail
180     sLocalReferstoR1C1 = oName.RefersToR1C1
190     sLocalRefersto = oName.RefersTo
        '
        ' if there is a local name on this sheet with the same name then find a different sheet
        ' crw Nov 13
        '
200     If IsNameGlobalLocal(ActiveSheet, sGlobalName) Then
210         bSwitch = True
220         SwitchtoDifferentSheet sGlobalName
230     End If
        '
        ' add the name
        '
240     On Error GoTo Fail
250     ActiveWorkbook.Names.Add Name:=(sGlobalName), RefersToR1C1:=sLocalReferstoR1C1

260     If Not gbKeep Then
270         DeleteAName sLocalName
            '
            ' check all names ; if refersto this name then change the ref to Global
            '
280         If nTots > 0 Then ChangeNameRefersto sLocalName, sGlobalName, nTots, vNamesInNames()
290     End If
300     If bSwitch Then SwitchSheetBack

310 End If
GoExit:
320 Set oName = Nothing
330 PopStack3
340 Exit Sub
Fail:
350 ShowMsg ReworkMsg(gsMsgs(29), sLocalName), vbCritical + vbOKOnly
360 Resume GoExit
End Sub
Sub ChangeNameRefersto(strName1 As String, strName2 As String, nTots As Long, vNamesInNames() As Variant)
'
' Copyright Decision Models 2005-2010. All Rights Reserved
' change all references in names from the Name1 to the Name2
' rewritten by crw 25/10/2005
' generalised crw 2/11/2005
'
    Dim oName As Name
    Dim strRefersTo As String
    Dim lPos As Long
    Dim k As Long
    Dim j As Long
    Dim k2 As Long
    Dim jPos As Long
    Dim jLenbefore As Long
    Dim jLenAfter As Long
    Dim jOffset As Long
    Dim jNamesDone As Long
    Dim strLeft As String
    Dim strRight As String
    Dim strReferstoR1c1 As String
    Dim strThisName As String
    Dim strLastName As String
    Dim nTots2 As Long
    Dim vNamesinNames2() As Variant

10  PushStack3 "ChangeLocalNameRefersto"

20  jOffset = 0
30  For k = 0 To UBound(vNamesInNames)
40      If k > 0 Then
            '
            ' if a name has just been processed, refresh vNamesInNames for the last name
            '
50          If vNamesInNames(k - 1, 0) = strLastName And vNamesInNames(k, 0) <> strLastName Then
60              OneNameInNames Names(strLastName), nTots2, vNamesinNames2()
70              If nTots2 >= 0 Then

80                  For j = 0 To nTots2
90                      For k2 = 0 To 5
100                         vNamesInNames(k - vNamesInNames(k - 1, 5) + j, k2) = vNamesinNames2(j, k2)
110                     Next k2
120                 Next j
130             End If
140         End If
150     End If
        '
        ' if this name contains the name to be replaced
        '
160     If vNamesInNames(k, 1) = strName1 Then
170         strThisName = vNamesInNames(k, 0)
180         If strThisName = "Products.ProductNameRange" Then
190             k = k
200         End If
210         strReferstoR1c1 = Names(strThisName).RefersToR1C1
220         jLenbefore = Len(strReferstoR1c1)
230         strLeft = ""
240         strRight = ""

250         If strThisName <> strLastName Then jOffset = 0
            '
            ' if name found does not start at pos1
            ' get the token before the namefound
            '
260         If vNamesInNames(k, 2) + jOffset > 1 Then strLeft = Left(strReferstoR1c1, vNamesInNames(k, 2) - 1 + jOffset)
            '
            ' if there is something after the namefound then get it
            '
270         If Len(strReferstoR1c1) > (Len(strLeft) + vNamesInNames(k, 3)) Then strRight = Right(strReferstoR1c1, Len(strReferstoR1c1) - (Len(strLeft) + vNamesInNames(k, 3)))
            '
            ' reassemble
            '
280         strReferstoR1c1 = strLeft & strName2 & strRight
290         jLenAfter = Len(strReferstoR1c1)
300         Names(strThisName).RefersToR1C1 = strReferstoR1c1
310         jOffset = Len(Names(strThisName).RefersToR1C1) - jLenbefore
320         strLastName = strThisName
330     End If
340 Next k
    '
    ' now change the name itself in VnamesInNames(k , 0)
    '
350 For k = 0 To UBound(vNamesInNames)
360     If vNamesInNames(k, 0) = strName1 Then vNamesInNames(k, 0) = strName2
370 Next k
GoExit:
380 PopStack3
390 Exit Sub
Fail:

End Sub

Sub ChangeGlobalNameRefersto(strLocalName As String, strGlobalName As String)
'
' Copyright Decision Models 2003-2010. All Rights Reserved
' change all references in names from the Local name to the Global name
'
    Dim oName As Name
    Dim strRefersTo As String
    Dim lPos As Long

10  PushStack3 "ChangeGlobalNameRefersto"
20  For Each oName In ActiveWorkbook.Names
30      strRefersTo = oName.RefersTo
40      Do
50          lPos = IsNameThere(strRefersTo, strLocalName)
60          If lPos > 0 Then
70              strReplace strRefersTo, lPos, strLocalName, strGlobalName
80          End If
90      Loop Until lPos = 0
100     If strRefersTo <> oName.RefersTo Then oName.RefersTo = strRefersTo
110 Next oName

120 Set oName = Nothing
GoExit:
130 PopStack3
End Sub
Function IsBookProtected(bMsg As Boolean) As Boolean
'
' Copyright Decision Models 2002-2010. All Rights Reserved
'
' function to check if the activeworkbook is protected
'

10  PushStack3 "IsBookProtected"
20  IsBookProtected = False
30  If ActiveWorkbook.ProtectStructure Or ActiveWorkbook.ProtectWindows Then IsBookProtected = True
40  If IsBookProtected And bMsg Then
50      ShowMsg ReworkMsg(gsMsgs(30)), vbOKOnly + vbCritical
60  End If
GoExit:
70  PopStack3
End Function
Function IsSheetProtected(oSheet As Object, bMsg As Boolean) As Boolean
'
' Copyright Decision Models 2002-2010. All Rights Reserved
'
' function to check if a worksheet is protected
'

10  PushStack3 "IsSheetProtected"
20  IsSheetProtected = False
30  If oSheet.ProtectContents Then IsSheetProtected = True
40  If IsSheetProtected And bMsg Then
50      ShowMsg ReworkMsg(gsMsgs(31), oSheet.Name), vbOKOnly + vbCritical
60  End If
GoExit:
70  PopStack3
End Function
Function IsNameDuplicate(lNameIndex) As Long
'
' Copyright Decision Models 2002-2010. All Rights Reserved
'
' function to check if the name is local and has a global duplicate, or is global and has a local duplicate
'
    Dim oName As Name
    Dim sName As String
    Dim oSht As Worksheet
    Dim sGlobalName As String
    Dim j As Long

10  PushStack3 "IsNameDuplicate"
20  IsNameDuplicate = False
30  j = FindExclamationRev(gsNames(lNameIndex))
40  On Error GoTo Errhandl
50  Application.EnableCancelKey = xlErrorHandler
60  If j > 0 Then
70      sGlobalName = Right$(gsNames(lNameIndex), Len(gsNames(lNameIndex)) - j)
80      sName = FindName(sGlobalName).Name
90      If sName = sGlobalName Then IsNameDuplicate = True
100 Else
        '        For Each osht In ActiveWorkbook.Worksheets
        '           Set oName = FindName(osht.Name & "!" & gsNames(lNameIndex))
        '          If oName Is Nothing Then Set oName = FindName("'" & osht.Name & "'!" & gsNames(lNameIndex))
        '         If Not oName Is Nothing Then
        '            IsNameDuplicate = True
        '           Exit For
        '      End If
        ' Next
        '
        ' crw 11 Aug 2006 use custommatchlike
        '
110     IsNameDuplicate = Not (IsError(vCustomMatchLike("*!" & gsNames(lNameIndex), gsNames, 0)))
120 End If
GoExit:
130 Set oName = Nothing
140 Set oSht = Nothing
150 PopStack3
160 Exit Function
Errhandl:
170 If Err = 18 Then
180     gbBreak = True
190     Application.EnableCancelKey = xlInterrupt
200     On Error GoTo 0
210     GoTo GoExit
220 Else
230     Resume Next
240 End If
End Function
Sub GoActiveName()
'
' Copyright Decision Models 2002-2010. All Rights Reserved
'
'
' crw dec 22 2002: toggle on goto
'
' CRW 27 April 2014 Tables
'
    Dim bDummy As Boolean

10  PushStack3 "GoActiveName"
    '   If Not bMulti Then
    'If gbGoTo Then
20  On Error GoTo GoExit
    'JKP 15-nov-2002: don't change selection when on names list sheet!!
    ' crw 18 nov 2002 change instr to like
    'If ActiveSheet.Name Like "Names ####-???-##" Then GoTo goexit
    ' JKP, Jan 02 2002: don't go to other workbook!
    ' JKP Jan 29 2003: changed to avoid errors with peculiar sheetnames
    'If (InStr(FindName(gsNames(glActive)).RefersTo, "[") > 0) Then GoTo GoExit
30  If IsTableName(gsNames(glActive)) Then
40      If gbFxl Then Application.GoTo reference:=Range(gsRefersto(glActive)).CurrentRegion, Scroll:=True
50  Else
60      bDummy = GoToName(FindName(gsNames(glActive)))
70  End If
    'End If
GoExit:
80  PopStack3
End Sub
Function GoToName(oNm As Name) As Boolean
'
' Copyright Decision Models 2002-2010. All Rights Reserved
'
' mod crw 2 August 2006: goto region then select name
'
' CRW 26/1/2010 use visible range, fix 3-d names, multiarea names, relative names
'
    Dim strGoName As String
    Dim strSheetName As String

10  PushStack3 "GoToName"
20  On Error GoTo nogo
30  GoToName = False
40  gbAddSheet = False                                ''' crw apr 12 2003
    '
    'JKP build 557: disable events
50  Application.EnableEvents = False

    'If InStr(oNm.RefersTo, "[") = 0 Then
60  GoToName = True
70  If IsNameGlobalLocal(ActiveSheet, oNm.Name) Then
        'JKP Jan 08 2003: switch to other sheet to prevent selecting local name
80      SwitchtoDifferentSheet oNm.Name
90      strGoName = "'" & ActiveWorkbook.Name & "'!" & oNm.Name
100     NameScroll strGoName
110     DeleteAddSheet                        ''' crw apr 12 2003
120 Else
130     If IsNameThreeD(glActive) Then
140         strSheetName = Mid(gsRefersto(glActive), 2, InStr(gsRefersto(glActive), ":") - 2)
150         If Left(strSheetName, 1) = "'" Then strSheetName = Right(strSheetName, Len(strSheetName) - 1)
160         If Right(strSheetName, 1) = "'" Then strSheetName = Left(strSheetName, Len(strSheetName) - 1)
170         strGoName = Mid(gsRefersto(glActive), InStr(gsRefersto(glActive), "!") + 1)
180         If InStr(strGoName, ",") Then strGoName = Left(strGoName, InStr(strGoName, ",") - 1)
190         strGoName = "'" & strSheetName & "'!" & strGoName
200         NameScroll strGoName
210     Else
220         NameScroll oNm.Name
230     End If
240 End If
    'End If
GoExit:
    'JKP build 557: enable events
250 Application.EnableEvents = True
260 PopStack3
270 Exit Function
nogo:
280 Beep
290 GoToName = False
300 GoTo GoExit
End Function
Sub NameScroll(strGoName As String)
'
' Copyright Decision Models 2010. All Rights Reserved
' Scroll to region containing the name/rangeref unless its already visible
'
10  PushStack3 "NameScroll"
20  Application.EnableEvents = True
30  Range(strGoName).Parent.Activate
40  If Intersect(ActiveWindow.VisibleRange, Range(strGoName)) Is Nothing Then
50      Application.GoTo reference:=Range(strGoName).CurrentRegion, Scroll:=True
60  End If
70  Range(strGoName).Select
    'JKP, kludge to overcome the effect of selecting
    'all entries between (0) and the one clicked.
    'This only happened at first start of Name Manager.
80  gfrmNameManager.lbxFilter.SetFocus
90  gfrmNameManager.lbxNames.SetFocus
100 PopStack3
End Sub
Function FindReferencedSheets(gsRefersto As String) As Variant
    Dim oSheet As Worksheet
    Dim sMatches() As String
    Dim lCount As Long
    Dim lTest As Long

10  PushStack3 "FindReferencedSheets"
20  If IsEmpty(gsValidChars) Then gsValidChars = GetValidCharlist
    '
    ' first element (0) is always returned empty
    '
30  ReDim sMatches(1)
40  lCount = 0
50  For Each oSheet In ActiveWorkbook.Worksheets
        'JKP: april 14 2005. Changed search for sheetnames to make sure
        'JKP: "aSheet1" is not found when Sheet1 is the sheet we're looking for!
        ' crw 18/8/2005 shorter code
60      lTest = InStr(gsRefersto, oSheet.Name & "!") + InStr(gsRefersto, "'" & oSheet.Name & "'!") _
              + InStr(gsRefersto, oSheet.Name & ":") + InStr(gsRefersto, "'" & oSheet.Name & "':") _
              + InStr(gsRefersto, ":" & oSheet.Name) + InStr(gsRefersto, ":'" & oSheet.Name & "'")
70      If lTest > 0 Then
            '
            ' check that preceding character is NOT a valid char or '
            '
80          If InStr("'" & gsValidChars, Mid(gsRefersto, lTest - 1, 1)) = 0 Then
90              lCount = lCount + 1
100             ReDim Preserve sMatches(lCount)
110             sMatches(lCount) = oSheet.Name
120         End If
130     End If
140 Next
150 If lCount >= 1 Then
160     FindReferencedSheets = sMatches
170 Else
        '
        ' crw 18/8/2005 fix for non-array variant
        '
180     FindReferencedSheets = Array("", "")
190 End If
GoExit:
200 PopStack3
End Function
Sub GetTheSheet(sName As String, blAllSheets As Boolean)
' crw dec 19 2002 save and restore cursor and screenupdating
'
' crw 2 Nov 2005 : blAllSheets to show all sheets that do not have this name locally
'
    Dim lCount As Long
    Dim bScreenUpdating As Boolean
    Dim lCursor As Long
    Dim oSht As Worksheet
    Dim oLocalName As Name

10  PushStack3 "GetTheSheet"
    'JKP Jan 07 2003: changed handling of forms
20  If gfrmLocalSheets Is Nothing Then
30      Set gfrmLocalSheets = New ufLocalsheets
40  End If
50  With gfrmLocalSheets
60      .lblSelect.Caption = ReworkMsg(gsTxtufLocalSheets(2), sName)
70      .lbxSheets.Clear

80      If Not blAllSheets Then
            '
            ' show all the sheets referred to by the name
            '
90          For lCount = 0 To UBound(gvSheetsReferredTo) - 1
100             .lbxSheets.AddItem gvSheetsReferredTo(lCount + 1)
110         Next
120     Else
            '
            ' show all sheets without sName as local to sheet
            '
130         On Error Resume Next
140         For Each oSht In Worksheets
150             Set oLocalName = Nothing
160             Set oLocalName = FindNameLocal(oSht, sName)
170             If oLocalName Is Nothing Then .lbxSheets.AddItem oSht.Name
180         Next oSht
190         On Error GoTo 0
200     End If
210     bScreenUpdating = Application.ScreenUpdating
220     lCursor = Application.Cursor
230     If Application.ScreenUpdating <> True Then Application.ScreenUpdating = True
240     Application.Cursor = xlDefault
250     If .lbxSheets.ListCount > 0 Then
260         .Show
270     Else
280         MsgBox gsMsgs(87), vbOKOnly + vbCritical, gsAppName
290     End If
300     If Not Application.ScreenUpdating = bScreenUpdating Then Application.ScreenUpdating = bScreenUpdating
310     Application.Cursor = lCursor
320 End With
330 Set gfrmLocalSheets = Nothing
GoExit:
340 PopStack3
End Sub
Sub CheckFixNames()
'
' Copyright Decision Models 2002-2010. All Rights Reserved
'
' check that the number of names is the same and that the reference style is the same: if not then rebuild the name list
'
    Dim sCurrentName As String
    Dim sCurrentRefersto As String                    ''' crw 8/1/2003
    Dim sActualRefersto As String                     ''' crw 8/1/2003
    Dim blScreenUpdating As Boolean
10  On Error Resume Next

20  PushStack3 "CheckFixNames"
30  blScreenUpdating = Application.ScreenUpdating
    'Application.ScreenUpdating = False   ''' crw 16/10/2005
40  gbListChanged = False
50  If glActive > 0 Then
60      sCurrentName = gsNames(glActive)
        ' crw jan 30: skip refersto if GoTo
        'If Not gbGoTo Then
        ''' crw 8/1/2003 : check refersto as well as name
70      sCurrentRefersto = gsRefersto(glActive)
80      On Error Resume Next
        ' JKP Jan 29 2003: Changed to avoid errors with peculiar sheetnames
        '
        ' crw 1 july 2003: use strGetRefersto
        '
90      sActualRefersto = strGetRefersTo(FindName(gsNames(glActive)))
        'End If
        ' crw 8/1/2003: also check for refresh and refersto change
100 End If
110 If glNameCount <> GetNameTableCount() Or _
       glR1C1 <> Application.ReferenceStyle Or gbRefresh _
       Or (Not IsNameRelative(FindName(gsNames(glActive)).RefersToR1C1) And sCurrentRefersto <> sActualRefersto) Or _
       gbRefsActiveSheet Then
120     gbDisableEvents = True
130     gbListChanged = True                          ''' so that listthenames knows
        '
        ' crw 7/1/2003 ; switch off unused if list reset
        '
140     gbUnUsed = False
150     gfrmNameManager.cbUnused = False
160     FindAllNames
170     ListTheNames
180     GetIndex
190     SetHideUnhide                                 ''' crw 8/1/2003
200     SetGlobLoc                                    ''' crw 8/1/2003
210     gbListChanged = False
        'JKP Jan 09 2003: refresh fails on workbook without names
220     If glActive <> 0 Then
230         If gsNames(glActive) <> sCurrentName Or glNamegsSelected > 1 Then
240             gbListChanged = True                  ''' cancel the operation
250         End If
260     End If
270     gbDisableEvents = False
280 End If
290 If gfrmNameManager.lbxNames.ListCount = 0 Then
300     DisableThings
310 Else
320     EnableThings
330 End If
GoExit:
340 If Application.ScreenUpdating <> blScreenUpdating Then
350     Application.ScreenUpdating = blScreenUpdating
360 End If
370 PopStack3
End Sub

'JKP Jan 02 2002. Added to circumvent a problem with non-US
'keyboards when using sendkeys
'
' crw 1/8/2005: revert to switching sheet when defining a local name
'
Sub RedefineAName(sName As String, sNewRefersTo As String)
    Dim bSwitchSheet As Boolean
    Dim oSheet As Object
    Dim bNew As Boolean
    Dim strWhere As String
    Dim oNm As Name
    Dim bVisible As Boolean
'Debug.Print "Start of redefineaname, name: " & sName, "Refersto: " & sNewRefersTo
10  strWhere = "RedefineAName"
20  PushStack3 strWhere
30  bNew = FindName(sName) Is Nothing
40  If bNew = False Then

50      bVisible = FindName(sName).Visible
60  Else
70      If gbShowHidden Then
80          bVisible = False
90      ElseIf gbShowVisible Then
100         bVisible = True
110     Else
120         bVisible = True
130     End If
140 End If
150 If Not IsNameRefersToLegal(sName, sNewRefersTo) Then
160     IllegalNames sName
170 Else
180     If TypeName(ActiveSheet) <> "Worksheet" Then
190         Set oSheet = ActiveSheet
200         bSwitchSheet = True
210         SwitchtoDifferentSheet sName
220     ElseIf TypeName(Selection) <> "Range" Then
230         ActiveSheet.Range("A1").Select
240     Else
250         If IsNameGlobalLocal(ActiveSheet, sName) Then
260             Set oSheet = ActiveSheet
270             bSwitchSheet = True
280             SwitchtoDifferentSheet sName
290         End If
300     End If
310     If bNew Then
320         Set oNm = ActiveWorkbook.Names.Add(sName, "1")
330     Else
340         Set oNm = FindName(sName)
350     End If
360     If Len(sNewRefersTo) > 225 And InStr(sNewRefersTo, "(") = 0 Then
370         SetLongName oNm, sNewRefersTo
380     ElseIf Len(sNewRefersTo) > 243 Then
390         ShowMsg ReworkMsg(gsMsgs(81)), vbOKOnly + vbCritical
400     Else
'   JKP 20171030: Office 2016 has wrecked DataObject, moved to sub to use API if needed
410         PutIntoClipBoard sNewRefersTo
480         If IsNameLocal(sName, bNew) Or InStr(sName, "'!") > 0 Then
490             bSwitchSheet = True
500             Set oSheet = ActiveSheet
510             If FindName(sName) Is Nothing Then
520                 Worksheets(Replace5(Left$(sName, FindExclamationRev(sName) - 1), "'", "")).Select
530             Else
                    'JKP: 13-7-2009, sheet may be hidden
540                 On Error Resume Next
550                 FindName(sName).Parent.Select
560                 On Error GoTo 0
570             End If
580         End If
590         Err.Clear
Debug.Print "Name before sendkeys: " & sName, "SendKeyName: " & MakeSendKey(sName), "Refersto: " & sNewRefersTo
            DoEvents
600         SendKeys MakeSendKey(sName) & "{TAB 2}" & "^v~"
610         If Err.Number = 0 Then
620             Application.Dialogs(xlDialogDefineName).Show
630         Else
640             ShowMsg ReworkMsg(gsMsgs(32)), vbOKOnly + vbCritical
650             Err.Clear
660         End If
670         DoEvents
680     End If
690     FindName(sName).Visible = bVisible
700     If bSwitchSheet Then
710         oSheet.Select
720     End If
730 End If
GoExit:
740 PopStack3
End Sub

Sub GetShortCutKey()

10  Do
20      gsShortCutKey = InputBox(ReworkMsg(gsMsgs(84)), gsAppName, gsShortCutKey)
30  Loop Until Len(gsShortCutKey) <= 1
40  If Len(gsShortCutKey) = 1 Then
50      If Not gsShortCutKey Like "[a-zA-Z]" Then
60          ShowMsg ReworkMsg(gsMsgs(91)), vbOKOnly + vbInformation
70          gsShortCutKey = "n"
80      End If
90      ResetShortCutKey
100     SetShortCutKey
110     SaveSettings
120     MakeMenu
130 End If
End Sub

Sub SetShortCutKey()
10  If gsShortCutKey Like "[a-zA-Z]" And gsShortCutKey <> "" Then
20      On Error Resume Next
30      Application.OnKey "^+" & gsShortCutKey, "ManageNames"
40      On Error GoTo 0
50  End If
End Sub

Sub ResetShortCutKey()
10  If gsShortCutKey <> "" Then
20      On Error Resume Next
30      Application.OnKey "^+" & gsShortCutKey
40  End If
End Sub

Function IsNewNameValid(sNewName As String) As Boolean
'JKP: Apr 20 2006: added.
'Function checks whether syntax of a new name is legal
'Also checks whether sheet(s) referred to exist.
    Dim sSheet As String
    Dim oSh As Worksheet
10  If InStr(sNewName, "!") > 0 Then
20      sSheet = Left(sNewName, InStr(sNewName, "!") - 1)
        '
        ' CRW 16 Jan 2007
        ' strip single quotes from start and end of sheet name
        '
30      If Left(sSheet, 1) = "'" Then sSheet = Right(sSheet, Len(sSheet) - 1)
40      If Right(sSheet, 1) = "'" Then sSheet = Left(sSheet, Len(sSheet) - 1)
50      On Error Resume Next
60      Set oSh = ActiveWorkbook.Worksheets(sSheet)
70      If oSh Is Nothing Then
80          IsNewNameValid = False
90          ShowMsg ReworkMsg(gsMsgs(93)), vbOKOnly + vbInformation
100     Else
110         IsNewNameValid = True
120     End If
130 Else
140     IsNewNameValid = True
150 End If
End Function

Function HasHiddenCells(oSh As Object, bMsg As Boolean) As Boolean
    Dim jCells1 As Currency
    Dim jCells2 As Currency

10  PushStack3 "HasHiddenCells"
20  HasHiddenCells = False
30  If TypeName(oSh) = "Worksheet" Then
        '
        ' CRW 22 June 2011
        ' avoid  overflow with large grid
        '
40      jCells1 = oSh.Rows.Count * oSh.Columns.Count
50      jCells2 = oSh.Cells.SpecialCells(xlCellTypeVisible).Rows.Count * oSh.Cells.SpecialCells(xlCellTypeVisible).Columns.Count
60      HasHiddenCells = (jCells1 <> jCells2)
70      If HasHiddenCells And bMsg Then
80          ShowMsg ReworkMsg(gsMsgs(96), oSh.Name), vbOKOnly + vbCritical
90      End If
100 Else
110     HasHiddenCells = False
120 End If
End Function

Public Function InStrRev01( _
       sCheck As String, _
       sMatch As String, _
       Optional Start As Long = -1, _
       Optional Compare As Long = vbBinaryCompare) As Long
' by Donald, donald@xbeat.net, rev. 001, 20000923
' strategy: search left to right until no more
    Dim lenSearchFor As Long
    Dim posFound As Long

10  lenSearchFor = Len(sMatch)

20  If lenSearchFor Then
30      If Start <= 0 Then
40          Start = Len(sCheck)
50      End If
60      Do
70          posFound = InStr(InStrRev01 + 1, sCheck, sMatch, Compare)
80          If posFound And (posFound + lenSearchFor - 1 <= Start) Then
                ' match
90              InStrRev01 = posFound
100         Else
                ' no more
110             Exit Function
120         End If
            ' condition not necessary
130     Loop
140 Else
        ' as VB6 InStrRev
150     If Start <= Len(sCheck) Then
160         InStrRev01 = Start
170     End If
180 End If

End Function
Function RangeCount(theRange As Range) As Currency
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2014. All rights reserved
' count cells for XL2003 and big grid versions
'
    Dim nRows As Currency
    Dim nCols As Currency
    Dim rng As Range

10  PushStack3 "RangeCount"

20  If Not theRange Is Nothing Then
30      If theRange.Areas.Count > 1 Then
            '
            ' count each area separately
            '
40          For Each rng In theRange.Areas
50              nRows = rng.Rows.Count
60              nCols = rng.Columns.Count
70              RangeCount = RangeCount + nRows * nCols
80          Next rng
90      Else
100         nRows = theRange.Rows.Count
110         nCols = theRange.Columns.Count
120         RangeCount = RangeCount + nRows * nCols
130     End If
140 End If
Fail:
150 PopStack3
End Function

Function GetValidCharlist() As Variant
    Dim vVal As Variant
    Dim lRow As Long
    GetValidCharlist = vbEmpty
    vVal = ThisWorkbook.Worksheets("ValidChars").Range("ValidChars").Value2
    For lRow = LBound(vVal, 1) To UBound(vVal, 1)
        GetValidCharlist = GetValidCharlist & vVal(lRow, 1)
    Next
End Function
Attribute VB_Name = "fxlNameManager2"
Option Explicit
Option Private Module
Option Compare Text
'
'***************************************************************
'*                                                             *
'* All subs and functions in this module:                      *
'* Copyright |fffd| J.K. Pieterse 2002-2010. All Rights Reserved    *
'* except where shown as                                       *
'* Copyright |fffd| Decision Models 2002-2010. All rights Reserved  *
'*                                                             *
'***************************************************************
'

Function IsNameThere(sFormula As String, sName As String) As Long
'
' crw 12 april 2003 return position of sname in sformula, else 0
'
    Dim lPos As Long
    Dim sCharBefore As String
    Dim sCharAfter As String
    Dim bThere As Boolean
    Dim lStart As Long
    Dim lPosFound As Long                             ''' position of first character of sname

10  PushStack3 "IsNameThere"
20  bThere = False
30  If IsEmpty(gsValidChars) Then gsValidChars = GetValidCharlist
40  If Left$(sFormula, 1) = "=" And (Len(sFormula) - 1) >= Len(sName) Then
50      lStart = 1
60      lPos = InStr(lStart, sFormula, sName)
        'JKP Jan 06 2003: fixed bugs regarding Instr position
        '
70      If lPos > 0 Then                              ''' crw april 12 2003
80          Do
90              lPosFound = lPos                      ''' crw april 12 2003
100             If lPos > 1 Then
110                 sCharBefore = Mid(sFormula, lPos - 1, 1)
120             Else
130                 sCharBefore = " "
140             End If
                'Check if preceded by filename!
150             If sCharBefore = "!" Then
                    ' JKP Apr 4 2003, changed the three IsNameThere lines to use bThere
160                 If IsNameThere(sFormula, ActiveWorkbook.Name & "!" & sName) > 0 Then
170                     bThere = True
                        ' JKP APril 16, 2003: Exit when found!
180                     Exit Do
190                 ElseIf IsNameThere(sFormula, "'" & ActiveWorkbook.Name & "'!" & sName) > 0 Then
200                     bThere = True
                        ' JKP APril 16, 2003: Exit when found!
210                     Exit Do
                        ' JKP June 6, 2003: Check if in string in formula (INDIRECT function?)
220                 ElseIf Mid(sFormula, lPos - 2, 1) = Chr(34) Then
230                     ShowMsg ReworkMsg(gsMsgs(33)), vbInformation + vbOKOnly
240                     bThere = True
250                 Else
260                     bThere = False
270                 End If
280             End If
290             If lPos + Len(sName) - 1 = Len(sFormula) Then
300                 sCharAfter = " "
310             Else
320                 sCharAfter = Mid(sFormula, lPos + Len(sName), 1)
330             End If
                ' JKP April 16 2003: used a variable for legal characters
340             If sCharBefore <> """" And InStr("!" & gsValidChars, sCharBefore) = 0 Then
350                 If sCharAfter <> """" And InStr("!" & gsValidChars, sCharAfter) = 0 Then
360                     If sCharAfter <> "!" And sCharAfter <> "'" And sCharAfter <> "$" And sCharBefore <> "'" Or (sCharAfter = "'" And sCharBefore = "'") Then
370                         bThere = True
380                         Exit Do
390                     End If
400                 End If
410             ElseIf sCharBefore = """" And sCharAfter = """" Then
420                 If lPos >= 10 Then
430                     If Mid(sFormula, lPos - 10, 10) = "INDIRECT(""" Then
440                         bThere = True
450                         Exit Do
460                     End If
470                 End If
480             End If
                'JKP Build 579: Wrong: did not find last entry in a formula. Now corrected.
490             lStart = Len(sName) + lPos            '+lstart
500             lPos = InStr(lStart, sFormula, sName)
510         Loop Until lPos = 0 Or bThere
520     End If
530 ElseIf sName = sFormula Then
540     lPosFound = 1
550     bThere = True
560 End If
570 If bThere Then
580     IsNameThere = lPosFound                       ''' crw april 12 2003
590 Else
600     IsNameThere = 0
610 End If
GoExit:
620 PopStack3
End Function

'JKP Jan 06 2003: renamed sub, included Bill Manville's revisions
'JKP Jan 09 2003: added argument whether or not to check for global/local.
' crw 29 may 2003: changed object to range and worksheet

Function FindNameInCells(sName As String, iFirstSheet As Long, iLastSheet As Long, bCheckGlobalLocalName As Boolean) As Long
    Dim iCount As Long
    '    Dim oLookRange As Object
    '    Dim oSheet As Object
    Dim oLookRange As Range
    Dim oSheet As Object
    Dim rFirstcell As Range
    Dim rNextCell As Range
    Dim lCountFound As Long
    Dim lType As Long
    Dim sWhatToFind As String
    Dim sSheetname As String

10  PushStack3 "FindNameInCells"
20  sWhatToFind = sName
30  lCountFound = 0
40  If sWhatToFind <> "" And Not gbBreak Then
50      lType = xlFormulas
60      For iCount = iFirstSheet To iLastSheet
70          Set oSheet = ActiveWorkbook.Sheets(iCount)
80          If TypeName(oSheet) = "Worksheet" Then
90              sSheetname = oSheet.Name



                'JKP: Jan 08 2003 added check for duplicate local name on the searched sheet
100             If bCheckGlobalLocalName And IsNameGlobalLocal(oSheet, sName) Then
                    'JKP: Apr 20 2006: show msg only once!
110                 If Not gbLocalGlobalWarning Then
120                     gbLocalGlobalWarning = True
130                     ShowMsg ReworkMsg(gsMsgs(34), sName, sSheetname), vbExclamation
140                 End If
150             Else
                    'JKP Jan 08 2003: check if local name *and* on sheet it belongs to
160                 If InStr(sName, "!") > 0 Then
170                     If InStr(sName, sSheetname) > 0 Then
180                         If FindNameInCells(Right$(sWhatToFind, Len(sWhatToFind) - FindExclamationRev(sName)), oSheet.Index, oSheet.Index, False) > 0 Then
190                             lCountFound = 1
200                             Exit For
210                         End If
220                     End If
230                 End If

240                 Set oLookRange = oSheet.Cells

250                 Set rFirstcell = oLookRange.Find(What:=sWhatToFind, LookIn:=lType, LookAt _
                                                                                     :=xlPart, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=False)
260                 If Not rFirstcell Is Nothing Then
270                     Set rNextCell = rFirstcell
280                     Do
290                         If rNextCell.HasFormula Then
300                             lCountFound = lCountFound + IsNameThere(rNextCell.Formula, sWhatToFind)
310                             If lCountFound > 0 Then Exit For
320                         End If
330                         Set rNextCell = oLookRange.FindNext(After:=rNextCell)
340                         If rNextCell Is Nothing Then Exit Do
350                     Loop While rNextCell.Address <> rFirstcell.Address And lCountFound = 0
360                 End If
370             End If
380         End If
            'JKP APril 16 2003: exit for when found!
390         If lCountFound > 0 Then Exit For
400     Next
410     If lCountFound = 0 Then
420         For iCount = 1 To glNameCount
430             If InStr(gsRefersto(iCount), sWhatToFind) > 0 Then
440                 lCountFound = lCountFound + IsNameThere(gsRefersto(iCount), sWhatToFind)
450                 If lCountFound > 0 Then Exit For
460             End If
470         Next
480     End If
490 End If
500 FindNameInCells = lCountFound
    'JKP Jan 08 2003: clear objects
510 Set oSheet = Nothing
520 Set oLookRange = Nothing
530 Set rNextCell = Nothing
540 Set rFirstcell = Nothing
GoExit:
550 PopStack3
End Function

Public Sub SetHideUnhide()
    Dim lCountSelected As Long

    '
    ' crw Nov 4
    '
    'JKP Okt 18 2005. Count selected names
10  PushStack3 "SetHideUnhide"
20  lCountSelected = funCountSelected
30  With gfrmNameManager
        '
        ' crw 18/10/04 remove selected cehck
        '
        'If funCountSelected > 0 And getnametablecount() > 0 _
         '     And .lbxNames.ListCount > 0 Then
40      If GetNameTableCount() > 0 _
           And .lbxNames.ListCount > 0 Then
50          .lblSortNameAsc.Visible = True
60          .lblSortNameDesc.Visible = True
70          .lblSortRefersAsc.Visible = True
80          .lblSortRefersDesc.Visible = True
90          .cbDelete.Visible = True
100         .cbEvaluate.Visible = True
110         .cbGlobalise.Visible = True
120         .cbHide.Visible = True
130         .cbList.Visible = True
140         .cbLocalise.Visible = True

150         .cmbDelete2.Enabled = True
160         .cmbEvaluate2.Enabled = True
170         .cmbGlobalise2.Enabled = True
180         .cmbHide2.Enabled = True
190         .cmbList2.Enabled = True
200         .cmbLocalise2.Enabled = True

210         If gbFxl Then .cbMap.Visible = True
220         If gbFxl Then .cbReplace.Visible = True
230         .cbUnhide.Visible = True
240         .cbUsed.Visible = True
250         .cbAnalyse.Visible = True
260         .cbClearHighlight.Visible = True
270         .cbHighlight.Visible = True

280         .cmbUnhide2.Enabled = True
290         .cmbUsed2.Enabled = True
300         .cmbAnalyse2.Enabled = True
310         .cmbClearHighlight2.Enabled = True
320         .cmbHighlight2.Enabled = True
330         If gbOverlap Then
340             .cbHide.Visible = True
350             .cbUnhide.Visible = True
360             .cmbHide2.Enabled = True
370             .cmbUnhide2.Enabled = True
380         Else
390             If lCountSelected = 1 Then
400                 If gbVisible(glActive) Then
410                     .cbHide.Visible = True
420                     .cbUnhide.Visible = False
430                     .cmbHide2.Enabled = True
440                     .cmbUnhide2.Enabled = False
450                 Else
460                     .cbHide.Visible = False
470                     .cbUnhide.Visible = True
480                     .cmbHide2.Enabled = False
490                     .cmbUnhide2.Enabled = True
500                 End If
510             Else
520                 .cbHide.Visible = True
530                 .cbUnhide.Visible = True
540                 .cmbHide2.Enabled = True
550                 .cmbUnhide2.Enabled = True
560             End If
570         End If
580     Else
590         .lblSortNameAsc.Visible = False
600         .lblSortNameDesc.Visible = False
610         .lblSortRefersAsc.Visible = False
620         .lblSortRefersDesc.Visible = False
630         .cbDelete.Visible = False
640         .cbEvaluate.Visible = False
650         .cbGlobalise.Visible = False
660         .cbHide.Visible = False
670         .cbList.Visible = False
680         .cbLocalise.Visible = False

690         .cmbDelete2.Enabled = False
700         .cmbEvaluate2.Enabled = False
710         .cmbGlobalise2.Enabled = False
720         .cmbHide2.Enabled = False
730         .cmbList2.Enabled = False
740         .cmbLocalise2.Enabled = False

750         If gbFxl Then .cbMap.Visible = False
760         If gbFxl Then .cbReplace.Visible = False
770         .cbUnhide.Visible = False
780         .cbUsed.Visible = False
790         .cbAnalyse.Visible = False
800         .cbClearHighlight.Visible = False
810         .cbHighlight.Visible = False

820         .cmbUnhide2.Enabled = False
830         .cmbUsed2.Enabled = False
840         .cmbAnalyse2.Enabled = False
850         .cmbClearHighlight2.Enabled = False
860         .cmbHighlight2.Enabled = False
870     End If
880 End With
GoExit:
890 PopStack3
End Sub
Public Sub SetGlobLoc()
'
' Copyright Decision Models 2002-2010. All Rights Reserved
' crw 11 nov 2002, enable disable the globalise/localise buttons
'
    Dim lCountSelected As Long
10  lCountSelected = funCountSelected
20  PushStack3 "SetGlobLoc"
30  With gfrmNameManager
40      If lCountSelected > 0 Then
            'If bMulti And Not gbOverlap Then        crw 17/9/2003
50          If lCountSelected > 1 And Not gbOverlap Then
60              .cbGlobalise.Visible = True
70              .cbLocalise.Visible = True
80              .cmbGlobalise2.Enabled = True
90              .cmbLocalise2.Enabled = True
100         Else
110             If InStr(gsNames(glActive), "!") > 0 Then
120                 .cbGlobalise.Visible = True
130                 .cbLocalise.Visible = False
140                 .cmbGlobalise2.Enabled = True
150                 .cmbLocalise2.Enabled = False
160             Else
170                 .cbGlobalise.Visible = False
180                 .cbLocalise.Visible = True
190                 .cmbGlobalise2.Enabled = False
200                 .cmbLocalise2.Enabled = True

210             End If
220         End If
230     Else
240         .cbGlobalise.Visible = False
250         .cbLocalise.Visible = False
260         .cmbGlobalise2.Enabled = False
270         .cmbLocalise2.Enabled = False

280     End If
290 End With
GoExit:
300 PopStack3
End Sub
'JKP Jan 14 2003: unload form, reset variables after a break.
Sub ResetAll()

10  PushStack3 "ResetAll"
    'JKP Jan 14 2003: added to reset filters after a break
20  gbGlobal = False
30  gbLocalActive = False
    '
    ' CRW 24 april 2014 Tables
    '
40  gbLocalAll = False
50  gbExternal = False
60  gbError = False
70  gbShowHidden = False
80  gbShowVisible = False
90  gbShowTables = False
100 gbShowNames = False
110 gbShow3D = False
120 gbMultiArea = False
130 gbFormula = False
140 gbRelative = False
150 gbOverlap = False
160 gbSelectedCells = False
170 gbRefsActiveSheet = False                         ''' crw 18 Oct 2005
    'JKP Jan 14 2003: unload form if break has been performed
180 If Not gfrmNameManager Is Nothing Then
190     Unload gfrmNameManager
200     Set gfrmNameManager = Nothing
210 End If
220 Application.StatusBar = False
230 Application.Cursor = xlDefault
240 If Application.Calculation <> glCalcMode Then Application.Calculation = glCalcMode
GoExit:
250 PopStack3
End Sub
Sub IsNameUsed()

10  PushStack3 "IsNameUsed"
20  If gfrmNameManager.lbxNames.ListCount = 0 Then GoTo GoExit
30  If FindNameInCells(gsNames(glActive), 1, ActiveWorkbook.Sheets.Count, True) = 0 Then
40      ShowMsg ReworkMsg(gsMsgs(35), gsNames(glActive)), vbInformation
50  Else
60      ShowMsg ReworkMsg(gsMsgs(36), gsNames(glActive)), vbInformation
70  End If
GoExit:
80  PopStack3
End Sub

Function IsNameOnUF(sName As String) As Boolean
    Dim lCount As Long

10  PushStack3 "IsNameOnUf"
20  IsNameOnUF = False
30  With gfrmNameManager
40      For lCount = 0 To .lbxNames.ListCount - 1
50          If sName = .lbxNames.List(lCount, 0) Then
60              IsNameOnUF = True
70              Exit For
80          End If
90      Next
100 End With
GoExit:
110 PopStack3
End Function

Function FindName(sName As String) As Name
' JKP Jan 29 2003: added to avoid errors with peculiar sheetnames
' JKP Jan 31 2003: Better version, Courtesy Bill Manville.
' crw 6/10/04 handle zerolength strings
' crw 22/10/04 speedup string handling
' crw 2//1/2005: bug fix for set=nothing
'
    Dim oName As Name
    Dim strName As String

10  PushStack3 "FindName"
20  Set FindName = Nothing
30  If Len(sName) > 0 And ActiveWorkbook.Names.Count > 0 Then
40      On Error Resume Next
50      Set FindName = ActiveWorkbook.Names(, sName)
        '
        ' crw 2/8/2006 if not found try Namelocal instead
        '
60      If FindName Is Nothing Then Set FindName = ActiveWorkbook.Names(sName)
        'JKP Build 610: sName may contain an apostroph which isn't needed
70      If Err <> 0 Or (FindName.NameLocal <> sName And FindName.NameLocal <> Replace5(sName, "'", "")) Then
80          On Error GoTo 0
90          Set FindName = Nothing
100         For Each oName In ActiveWorkbook.Names
110             strName = oName.Name
120             If Len(strName) = Len(sName) Then
130                 If strName = sName Then
140                     Set FindName = oName
150                     GoTo GoExit
160                 End If
170             End If
180         Next
190     End If
200 End If
GoExit:
210 PopStack3
End Function
Function FindTableName(sName As String) As ListObject
'
' CRW 27 April 2014 - get the table object corresponding to a table name
'
    Dim oSht As Worksheet
    Dim oTable As ListObject
10  For Each oSht In ActiveWorkbook.Worksheets
20      For Each oTable In oSht.ListObjects
30          If oTable.Name = sName Then
40              Set FindTableName = oTable
50              Exit For
60          End If
70      Next oTable
80  Next oSht

End Function
Function FindNameLocal(oSheet As Worksheet, sName As String) As Name
'
' crw 22/10/04 version to find a name localised to a sheet
'
' JKP Jan 29 2003: added to avoid errors with peculiar sheetnames
' JKP Jan 31 2003: Better version, Courtesy Bill Manville.
' crw 6/10/04 handle zerolength strings
' crw 2/11/2005 bug fixes for strName and set=nothing and quoted/unquoted names
'
    Dim oName As Name
    Dim strLocalName As String
    Dim strLocalNameNoQuote
    Dim strName As String

10  PushStack3 "FindNameLocal"
20  Set FindNameLocal = Nothing
30  If Len(sName) > 0 And Not oSheet Is Nothing And oSheet.Names.Count > 0 Then
40      On Error Resume Next
50      strLocalName = "'" & oSheet.Name & "'!" & sName
60      strLocalNameNoQuote = oSheet.Name & "!" & sName
70      Set FindNameLocal = oSheet.Names(strLocalName)
80      If Err <> 0 Or (FindNameLocal.NameLocal <> strLocalName And FindNameLocal.NameLocal <> strLocalNameNoQuote) Then
90          On Error GoTo 0
100         Set FindNameLocal = Nothing
110         For Each oName In oSheet.Names
120             strName = oName.Name
130             If Len(strLocalName) = Len(strName) Or Len(strLocalNameNoQuote) = Len(strName) Then
140                 If strName = strLocalName Or strName = strLocalNameNoQuote Then
150                     Set FindNameLocal = oName
160                     GoTo GoExit
170                 End If
180             End If
190         Next
200     End If
210 End If
GoExit:
220 PopStack3
End Function

Function IsNameLocal(sName As String, bNew As Boolean) As Boolean
'JKP Jan 30 2003: detect if local name
' CRW 24 April 2014 Tables
    Dim oNm As Name
10  PushStack3 "IsNameLocal"
20  IsNameLocal = False
30  If bNew Then
40      If InStr(sName, "!") + InStr(sName, "'!") > 0 Then
50          IsNameLocal = True
60      End If
70  Else
80      On Error Resume Next
90      Set oNm = FindName(sName)
100     On Error GoTo 0
110     If Not oNm Is Nothing Then  ''' tables are always global
120         If TypeName(FindName(sName).Parent) = "Workbook" Then
                ' global
130             IsNameLocal = False
140         Else
                ' local
150             IsNameLocal = True
160         End If
170     End If
180 End If
GoExit:
190 PopStack3
End Function
'JKP Jan 30 2003: find position of last exclamation character
Function FindExclamationRev(sString As String) As Long
' gofaster version crw 30/1/2003
    Dim jPos As Long

10  PushStack3 "FindExclamationRev"
20  FindExclamationRev = 0
30  jPos = 0
40  Do
50      jPos = InStr(jPos + 1, sString, "!", vbBinaryCompare)
60      If jPos > 0 Then
70          FindExclamationRev = jPos
80      Else
90          Exit Do
100     End If
110 Loop
GoExit:
120 PopStack3
End Function
'JKP Jan 30 2003 Name is not legal, show msg
Function IllegalNames(ByVal sName As String) As Boolean

10  PushStack3 "IllegalNames"
20  IllegalNames = Not ShowMsg(ReworkMsg(gsMsgs(37), sName), vbCritical + vbOKCancel)
GoExit:
30  PopStack3
End Function

'JKP Jan 30 2003: Check to see if a name is legal
Function IsNameRefersToLegal(sName As String, sRefersTo As String) As Boolean
    Dim oSheet As Worksheet
    Dim sSheetname As String

10  PushStack3 "IsNameReferstoLegal"
20  IsNameRefersToLegal = True
30  If InStr(sName, "]") > 0 Or InStr(sName, "[") > 0 _
       Or InStr(sName, Chr(3)) > 0 Then
40      IsNameRefersToLegal = False
50  Else
60      For Each oSheet In ActiveWorkbook.Worksheets
70          sSheetname = oSheet.Name
80          If InStr(sRefersTo, sSheetname) > 0 Then
90              If InStr(sSheetname, "]") > 0 Or InStr(sSheetname, "[") > 0 _
                   Or InStr(sSheetname, Chr(3)) > 0 Then
100                 IsNameRefersToLegal = False
110             End If
120         End If
130     Next
140 End If
GoExit:
150 PopStack3
End Function
' JKP Feb 6 2003: added to fix corrupt names
Sub FixAllNames()
'
' CRW 03 Oct 2009 remove Dim - its a global
'
'    Dim glR1C1 As Long

10  PushStack3 "FixAllNames"
20  glR1C1 = Application.ReferenceStyle
30  Application.ReferenceStyle = xlR1C1
40  Application.ReferenceStyle = xlA1
50  Application.ReferenceStyle = glR1C1
GoExit:
60  PopStack3
End Sub
' JKP Feb 6 2003: added to check if name is corrupt
Function IsNameValid(ByVal sName As String, bPrompt As Boolean) As Boolean
    Dim lCount As Long
    Dim bIllegal As Boolean
    Dim sWorkName As String

10  PushStack3 "IsNameValid"
20  If IsEmpty(gsValidChars) Then gsValidChars = GetValidCharlist
30  bIllegal = False
40  If InStr(sName, "!") > 0 Then
50      sWorkName = Right(sName, Len(sName) - FindExclamationRev(sName))
60  Else
70      sWorkName = sName
80  End If
    'JKP Build 556: Name cannot start with any of these characters!
90  bIllegal = (InStr(gsIllegalFirstChars, Left(sName, 1)) > 0)
100 If Not bIllegal Then
110     For lCount = 1 To Len(sWorkName)
120         If Not bIllegal Then
130             If InStr(gsValidChars, LCase(Mid(sWorkName, lCount, 1))) = 0 Then
140                 bIllegal = True
150                 Exit For
160             End If

170         End If
180     Next
190 End If
200 If bPrompt And bIllegal Then
210     If ShowMsg(ReworkMsg(gsMsgs(38), sName), vbQuestion + vbYesNo) = vbYes Then
220         gbBreak = True
230         FixAllNames
240     End If
250 End If
260 IsNameValid = Not bIllegal
GoExit:
270 PopStack3
End Function


Sub strReplace(strInput As String, lPos As Long, strFrom As String, strTo As String)
'
' Copyright Decision Models 2003-2010. All Rights Reserved
'
' replace strfrom with strto starting at position lPos in strInput
'
    Dim strLeft As String
    Dim strRight As String

10  PushStack3 "strReplace"
20  If lPos > 1 Then strLeft = Left(strInput, lPos - 1)
30  If Len(strInput) > lPos + Len(strFrom) - 1 Then strRight = Right(strInput, Len(strInput) - (lPos + Len(strFrom) - 1))
40  strInput = strLeft & strTo & strRight
GoExit:
50  PopStack3
End Sub
Sub PushStack3(sproc As String)
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2002-2010 All rights reserved
'
' sub to store procedure name string in gstrStack array
'
    Dim j As Long
    Dim str1 As String
10  If glStackPtr <= 0 Then
20      ReDim gstrStack(20) As String
30      glStackPtr = 1
40      gstrStack(glStackPtr) = sproc
50  Else
60      If gstrStack(glStackPtr) = sproc Then
70          Exit Sub
80      Else
90          glStackPtr = glStackPtr + 1
100         If UBound(gstrStack) < glStackPtr Then
110             ReDim Preserve gstrStack(glStackPtr + 10) As String
120         End If
130         gstrStack(glStackPtr) = sproc
140     End If
150 End If
160 If gblDebug Then
170     For j = 1 To glStackPtr
180         str1 = str1 & " "
190     Next j
200     Debug.Print str1 & glStackPtr & " > " & gstrStack(glStackPtr) & " " & Erl
210 End If
End Sub
Sub PopStack3()
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2002-2010 All rights reserved
'
' sub to remove procedure name string from gstrStack array
'
    Dim j As Long
    Dim str1 As String
10  If glStackPtr > 0 Then
20      If gblDebug Then
30          For j = 1 To glStackPtr
40              str1 = str1 & " "
50          Next j
60          Debug.Print str1 & glStackPtr & " < " & gstrStack(glStackPtr) & " " & Erl
70      End If
80      gstrStack(glStackPtr) = ""
90      glStackPtr = glStackPtr - 1
100 End If
End Sub
Function strGetStack2()
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2002-2010 All rights reserved
'
' function to return stack as string
'
    Dim j As Long
10  strGetStack2 = ""
20  If glStackPtr > 0 Then
30      For j = 1 To glStackPtr
40          strGetStack2 = strGetStack2 & gstrStack(j) & ">"
50      Next j
60  End If
End Function
Sub ToggleDebugTrace2()
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2003-2010 All rights reserved
'
10  gblDebug = Not gblDebug
20  MsgBox "Debug Trace is " & CStr(gblDebug), vbQuestion + vbYesNo
End Sub

Sub GetRightActiveCell()
    Dim oActive As Range
    Dim oNm As Name
    Dim str1 As String
    Dim j As Long

10  PushStack3 "GetRightActiveCell"

20  On Error Resume Next
    '
    ' crw 18/8/2005: fix for no sheet found
    '
    '30  str1 = FindReferencedSheets(gsRefersto(glActive))(1)
    '40  If str1 <> "" Then Worksheets(str1).Activate
    '
    ' crw 19 Aug: reworked the message
    '
    '30  Set oActive = Application.InputBox(gsMsgs(64) & vbCrLf & vbCrLf & gsNames(glActive), "Relative Name Anchor Cell", _
     '                                       ActiveCell.Address(, , Application.ReferenceStyle), , , , , 8)
    'JKP July 7 2003: fixed problems with getrightactivecell: on cancel change focus on form

    'JKP Build 554: new range selecting form to prevent error with sheets with conditional
    '               formatting formulas
30  If SelectARange(gsMsgs(64) & vbCrLf & vbCrLf & gsNames(glActive), "Relative Name Anchor Cell", oActive) = False Then
40      gbActiveCellChecked = False
50      gfrmNameManager.lbxNames.SetFocus
60      GoTo GoExit
70  End If

80  gbActiveCellChecked = True
90  Set oNm = FindName(gsNames(glActive))
    '
    ' switch to active cell if changed
    '
100 If Not oActive Is ActiveCell Then
110     Application.GoTo oActive
120 End If
    '
    ' store the anchor cell crw 7/10/2005
    '
130 Set goRelAnchor = ActiveCell


140 gsRefersto(glActive) = strGetRefersTo(oNm)
    '
    ' crw 7/10/04
    ' change the refersto in the listbox
    '
150 With gfrmNameManager
160     For j = 0 To .lbxNames.ListCount - 1
170         If .lbxNames.Selected(j) Then
180             .lbxNames.List(j, 1) = gsRefersto(glActive)
190             Exit For
200         End If
210     Next j
220     .tbEditName = gsRefersto(glActive)
230     If Len(gsNames(glActive)) < 33 Then
240         str1 = gsNames(glActive)
250     Else
260         str1 = Left(gsNames(glActive), 33)
270     End If
280     .lblRefersto = ReworkMsg(gsMsgs(63), str1, ActiveCell.Address(, , Application.ReferenceStyle))
290 End With
GoExit:
300 Set oActive = Nothing
310 Set oNm = Nothing
320 PopStack3
End Sub

Function strGetRefersTo(oNm As Name)
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2003-2018 All rights reserved
'
' get the refers to property for a name, allowing for local relative names
'
' rewritten crw 6/10/2005
'
' 29/1/19 - use us english rather than local if gilang=0 (English requested)
'
    Dim oCurrent As Worksheet
 
10  PushStack3 "strGetRefersTo"
20  If oNm Is Nothing Then GoTo Fail
30  On Error Resume Next                              ''' crw 11 July 2003
 
40  If Len(oNm.RefersToLocal) > 225 And InStr(oNm.RefersTo, "(") = 0 Then
50      strGetRefersTo = GetLongRef(oNm)
60  Else
70      If Application.ReferenceStyle = xlA1 Then
80          If giLang = 0 Then
90              strGetRefersTo = oNm.RefersTo
100         Else
110             strGetRefersTo = oNm.RefersToLocal
120         End If
130     Else
140         If giLang = 0 Then
150             strGetRefersTo = oNm.RefersToR1C1
160         Else
170             strGetRefersTo = oNm.RefersToR1C1Local
180         End If
190     End If
200 End If
 
    '
    ' check for dangerous names
    '
210 If Not gbWarned And Left(strGetRefersTo, 2) = "=!" Then
220     gbWarned = ShowMsg(ReworkMsg(gsMsgs(39), oNm.Name, CStr(strGetRefersTo)), vbExclamation + vbYesNo) = vbNo
230 End If
Fail:
240 Set oCurrent = Nothing
250 PopStack3
260 Exit Function
End Function

Function strGetTableRefersTo(oTable As ListObject) As String
'
' CRw 23 April 2014 : get the refersto for a table
' fix for 2003 5 June 2014
'
10  strGetTableRefersTo = "'" & oTable.Parent.Name & "'!" & oTable.Range.Address(, , Application.ReferenceStyle)
End Function
Function funCountSelected() As Long
    Dim lCount As Long
10  With gfrmNameManager
20      funCountSelected = 0                          ''' crw 17/9/2003
30      For lCount = 0 To .lbxNames.ListCount - 1
40          If .lbxNames.Selected(lCount) <> 0 Then
50              funCountSelected = funCountSelected + 1
60          End If
70      Next
80  End With
End Function

Sub GetSettings()
'
' settings are saved as strings: booleans needs to be converted to avoid language problems
'
10  On Error Resume Next
    'JKP build 576: first set defaults
20  gbAcknowledge = True
30  gbGoTo = False
40  gbShowRefersto = True
50  gbShowSysNames = True
60  gsShortCutKey = "n"
70  gbShortCutKey = True
80  gbIconButtons = True

    'JKP Build 576: prevent error messages so settings from previous versions don't cause
    'runtime errors

90  gbAcknowledge = CBool(GetSetting(gsFxlNameRegKey, "Settings", "Ack", CInt(True)))
    '
    ' CRW 4/11/2010 - change default to Auto
    '
    '100   If gbFxl Then
    '110     giLang = -1
    '120   Else
100 giLang = CInt(GetSetting(gsFxlNameRegKey, "Settings", "Lang", -1))
    '140   End If
    'gbGoTo = CBool(GetSetting(gsFxlNameRegKey, "Settings", "GoTo", CInt(False)))
110 gbShowRefersto = CBool(GetSetting(gsFxlNameRegKey, "Settings", "ShowRefers", CInt(True)))
111 gbVBEInterface = CBool(GetSetting(gsFxlNameRegKey, "Settings", "ShowInVBE", CInt(True)))
120 gbShowSysNames = CBool(GetSetting(gsFxlNameRegKey, "Settings", "ShowSysNames", CInt(True)))
130 gsShortCutKey = GetSetting(gsFxlNameRegKey, "Settings", "ShortCutKey", "n")
140 gbShortCutKey = CBool(GetSetting(gsFxlNameRegKey, "Settings", "HasShortCutKey", CInt(True)))
150 If gbShortCutKey = False And gsShortCutKey <> "" Then
160     gbShortCutKey = True
170 End If
180 gbIconButtons = CBool(GetSetting(gsFxlNameRegKey, "Settings", "IconButtons", CInt(True)))
190 gsValidChars = GetValidCharlist
End Sub

Sub SaveSettings()
      '
      ' settings are saved as strings: booleans needs to be converted to avoid language problems
      '
10    SaveSetting gsFxlNameRegKey, "Settings", "Ack", CStr(CInt(gbAcknowledge))
          'SaveSetting gsFxlNameRegKey, "Settings", "GoTo", CStr(CInt(gbGoTo))
20    SaveSetting gsFxlNameRegKey, "Settings", "ShowRefers", CStr(CInt(gbShowRefersto))
30    SaveSetting gsFxlNameRegKey, "Settings", "ShowSysNames", CStr(CInt(gbShowSysNames))
40    SaveSetting gsFxlNameRegKey, "Settings", "IconButtons", CStr(CInt(gbIconButtons))
50    SaveSetting gsFxlNameRegKey, "Settings", "ShowInVBE", CStr(CInt(gbVBEInterface))
60    If gsShortCutKey = "" Then
70      gbShortCutKey = False
80    Else
90      gbShortCutKey = True
100   End If
110   SaveSetting gsFxlNameRegKey, "Settings", "ShortCutKey", gsShortCutKey
120   SaveSetting gsFxlNameRegKey, "Settings", "HasShortCutKey", CStr(CInt(gbShortCutKey))
          'If Not gbFxl Then
130   SaveSetting gsFxlNameRegKey, "Settings", "Lang", CStr(giLang)
          'End If
End Sub

Function ShowMsg(ByVal sMsg As String, ByVal lButs As Long) As Long
'
' crw 22/10/04: switch screenupdating for msgbox if needed
'
    Dim bScreenUpdate As Boolean
10  bScreenUpdate = Application.ScreenUpdating
20  If Not Application.ScreenUpdating Then Application.ScreenUpdating = True
30  ShowMsg = MsgBox(sMsg, lButs, gsAppName)
40  If Application.ScreenUpdating <> bScreenUpdate Then Application.ScreenUpdating = bScreenUpdate
End Function

Function IsSysName(sName As String) As Boolean
10  If sName Like "*_FilterDatabase" Then
20      IsSysName = True
30      Exit Function
40  End If
50  If sName Like "*Print_Area" Then
60      IsSysName = True
70      Exit Function
80  End If
90  If sName Like "*Print_Titles" Then
100     IsSysName = True
110 End If
120 If sName Like "*.wvu.*" Then
130     IsSysName = True
140 End If
150 If sName Like "*wrn.*" Then
160     IsSysName = True
170 End If
180 If sName Like "*!Criteria" Then
190     IsSysName = True
200 End If
210 If LCase(sName) Like "slicer_*" Then
220     IsSysName = True
230 End If
240 If LCase(sName) Like "*_xlfn.*" Then
250     IsSysName = True
260 End If
End Function
Sub SortNames()
'10  QSortNames 1, UBound(gsNames)
'JKP: 11-10-2005: Inserted a similar sorting routine
10  QuickSort gsNames, 1, UBound(gsNames), "Names", True
End Sub
'Sub QSortNames(jStart As Long, jEnd As Long)
''
'' sort gsNames and the corresponding gsRefersto and gbVisible in locale collating sequence
''
'' input
''
''           jstart    The first item to sort between
''           jend    The last item to sort between
''
'' adapted from Stephen Bullen and John Walkenbach code
''
'    Dim jStart2 As Long
'    Dim jEnd2 As Long
'    Dim str1 As String
'    Dim str2 As String
'    Dim str3 As String
'    Dim bTemp As Boolean
'    '
'    'Set new extremes to old extremes
'    '
'10  jStart2 = jStart
'20  jEnd2 = jEnd
'    '
'    'Get value of array item in middle of new extremes
'    '
'30  str1 = gsNames((jStart + jEnd) \ 2)
'    '
'    'Loop for all the items in the array between the extremes
'    '
'40  While jStart2 < jEnd2
'        '
'        'Find the first item that is greater than the mid-point item
'        '
'50      While gsNames(jStart2) < str1 And jStart2 < jEnd
'60          jStart2 = jStart2 + 1
'70      Wend
'        '
'        'Find the last item that is less than the mid-point item
'        '
'80      While gsNames(jEnd2) > str1 And jEnd2 > jStart
'90          jEnd2 = jEnd2 - 1
'100     Wend
'        '
'        'If the two items are in the wrong order, swap them
'        '
'110     If jStart2 < jEnd2 Then
'120         str2 = gsNames(jStart2)
'130         str3 = gsRefersto(jStart2)
'140         bTemp = gbVisible(jStart2)
'150         gsNames(jStart2) = gsNames(jEnd2)
'160         gsRefersto(jStart2) = gsRefersto(jEnd2)
'170         gbVisible(jStart2) = gbVisible(jEnd2)
'180         gsNames(jEnd2) = str2
'190         gsRefersto(jEnd2) = str3
'200         gbVisible(jEnd2) = bTemp
'210     End If
'        '
'        'If the pointers are not together, advance to the next item
'        '
'220     If jStart2 <= jEnd2 Then
'230         jStart2 = jStart2 + 1
'240         jEnd2 = jEnd2 - 1
'250     End If
'260 Wend
'    '
'    'Recurse to sort the lower half of the extremes
'    '
'270 If jEnd2 > jStart Then QSortNames jStart, jEnd2
'    '
'    'Recurse to sort the upper half of the extremes
'    '
'280 If jStart2 < jEnd Then QSortNames jStart2, jEnd
'
'GoExit:
'290 PopStack3
'End Sub

Sub QuickSort(strArray() As String, intBottom As Long, intTop As Long, sToSort As String, bAtoZ As Boolean)
    Dim strPivot As String, strTemp As String
    Dim intBottomTemp As Long, intTopTemp As Long
    Dim str2 As String
    Dim str3 As String
    Dim bTemp As Boolean
10  intBottomTemp = intBottom
20  intTopTemp = intTop
30  strPivot = strArray((intBottom + intTop) \ 2)
40  While (intBottomTemp <= intTopTemp)
50      If bAtoZ Then
60          While (strArray(intBottomTemp) < strPivot And intBottomTemp < intTop)
70              intBottomTemp = intBottomTemp + 1
80          Wend
90      Else
100         While (strArray(intBottomTemp) > strPivot And intBottomTemp < intTop)
110             intBottomTemp = intBottomTemp + 1
120         Wend
130     End If
140     If bAtoZ Then
150         While (strPivot < strArray(intTopTemp) And intTopTemp > intBottom)
160             intTopTemp = intTopTemp - 1
170         Wend
180     Else
190         While (strPivot > strArray(intTopTemp) And intTopTemp > intBottom)
200             intTopTemp = intTopTemp - 1
210         Wend
220     End If
230     If intBottomTemp < intTopTemp Then
240         strTemp = strArray(intBottomTemp)
250         strArray(intBottomTemp) = strArray(intTopTemp)
260         strArray(intTopTemp) = strTemp
270         If sToSort = "Names" Then
280             str3 = gsRefersto(intBottomTemp)
290             gsRefersto(intBottomTemp) = gsRefersto(intTopTemp)
300             gsRefersto(intTopTemp) = str3
310         Else
320             str2 = gsNames(intBottomTemp)
330             gsNames(intBottomTemp) = gsNames(intTopTemp)
340             gsNames(intTopTemp) = str2
350         End If

            'JKP Oct 14 2005: obsolete
            '            bTemp = bSelected(intBottomTemp)
            '            bSelected(intBottomTemp) = bSelected(intTopTemp)
            '            bSelected(intTopTemp) = bTemp

360         bTemp = gbVisible(intBottomTemp)
370         gbVisible(intBottomTemp) = gbVisible(intTopTemp)
380         gbVisible(intTopTemp) = bTemp
            '
            ' CRW 24 April 2014 Tables
            '
390         bTemp = gbTable(intBottomTemp)
400         gbTable(intBottomTemp) = gbTable(intTopTemp)
410         gbTable(intTopTemp) = bTemp
420     End If
430     If intBottomTemp <= intTopTemp Then
440         intBottomTemp = intBottomTemp + 1
450         intTopTemp = intTopTemp - 1
460     End If
470 Wend
    'the function calls itself until everything is in good order
480 If (intBottom < intTopTemp) Then QuickSort strArray, intBottom, intTopTemp, sToSort, bAtoZ
490 If (intBottomTemp < intTop) Then QuickSort strArray, intBottomTemp, intTop, sToSort, bAtoZ
End Sub


Function EvalInCell(sStr As String, nRows As Long, kCols As Long) As String
'
' evaluate a string by entering it as a formula into a cell
' or as an array formula into multiple cells.
' nrows and kcols give the dimensions of the range to use
'
' modified crw 20/2/2005
'

    Dim oSh As Worksheet
    Dim oRange As Range
    Dim k As Long
    Dim j As Long
    Dim lRows As Long
    Dim lCols As Long

10  If Left(sStr, 1) <> "=" Then sStr = "=" & sStr
20  k = kCols
30  j = nRows
40  If k = 0 Then k = 1
50  If j = 0 Then j = 1
60  Set oSh = Worksheets.Add

70  Set oRange = oSh.Range("a1").Resize(j, k)

    'On Error Resume Next
    'Set oRange = Application.InputBox(ReworkMsg(gsMsgs(69)), gsAppName, "=$A$1", , , , , 8)
80  Application.ScreenUpdating = False
90  Application.DisplayAlerts = False
100 If k = 1 And j = 1 Then
110     On Error GoTo Fail
120     oRange.Formula = sStr
130     On Error GoTo 0
140     If IsEmpty(oRange) Then
150         EvalInCell = "0"
160     Else
170         EvalInCell = oRange.Text
180     End If
190 Else
200     On Error GoTo Fail
210     oRange.FormulaArray = sStr
220     On Error GoTo 0
230     EvalInCell = ""
240     For lRows = 1 To j
250         For lCols = 1 To k
260             If IsEmpty(oRange(lRows, lCols)) Then
270                 EvalInCell = EvalInCell & "0,"
280             Else
290                 If oRange(lRows, lCols) = "" And Application.IsText(oRange(lRows, lCols)) Then
300                     EvalInCell = EvalInCell & """"","
310                 Else
320                     EvalInCell = EvalInCell & oRange(lRows, lCols).Text
330                     EvalInCell = EvalInCell & ","
340                 End If
350             End If
360         Next
370         EvalInCell = Left(EvalInCell, Len(EvalInCell) - 1) & ";" & vbNewLine
380     Next
390     EvalInCell = Left(EvalInCell, Len(EvalInCell) - 3)
400 End If
Finish:
410 On Error Resume Next
420 oSh.Delete
430 Application.DisplayAlerts = True
440 Application.ScreenUpdating = True
450 Exit Function
Fail:
    '
    ' show #Ref if error entering the string
    '
460 On Error GoTo 0
470 EvalInCell = EvalInCell & " #Ref!"
480 GoTo Finish
End Function

Sub AnalyseName()
10  Set gfrmAnalyse = Nothing
20  If gfrmAnalyse Is Nothing Then
30      Set gfrmAnalyse = New ufAnalyse
40  End If
50  gfrmAnalyse.Initialise
60  gfrmAnalyse.Show
70  gfrmNameManager.InitializeUF
    '    If Val(Application.Version) = 8 Or gbMacOS = True Then
    '        gfrmNameManager.Show
    '    Else
    '        ShowModeless
    '    End If
End Sub

Function funTryToAnalyse(ByVal sStr As String, bMsg As Boolean, oParent As Worksheet) As String
    Dim vEval As Variant
    Dim lRows As Long
    Dim lCols As Long
    Dim lRowcount As Long
    Dim lColcount As Long
    Dim lCt As Long
    Dim strEval As String

    'On Error Resume Next
10  If Left(sStr, 1) <> "=" Then
20      sStr = "=" & sStr
30  End If
40  If IsNameRefersToLegal("", sStr) Then
        '
        ' CRW 19/Feb/2005 : use worksheet evaluate if local
        '
50      If oParent Is Nothing Then
60          vEval = Application.Evaluate(sStr)
70      Else
80          vEval = oParent.Evaluate(sStr)
90      End If
100     On Error Resume Next
110     lRows = 0
120     lCols = 0
130     lRows = UBound(vEval, 1)
140     lCols = UBound(vEval, 2)
150     On Error GoTo 0
        '
        ' dont see what this code is doing
        '
        '                If IsEmpty(vEval) Then
        '                    vEval = Application.Evaluate(sStr)
        '               End If
160     If Not IsError(vEval) Then
170         If IsArray(vEval) Then

180             strEval = Application.International(xlLeftBrace)
190             For lRowcount = 1 To lRows
200                 If lCols > 0 Then
210                     For lColcount = 1 To lCols
220                         If lColcount > 1 Then strEval = strEval & ", "
230                         lCt = lCt + 1
                            '                            If IsEmpty(vEval(lRowcount, lColcount)) Then
                            '                                strEval = strEval & "0"
                            '                            Else
                            'strEval = strEval & CStr(vEval(lRowcount, lColcount))
240                         strEval = strEval & strError(vEval(lRowcount, lColcount))
                            'End If
250                     Next lColcount
260                 Else
270                     lCt = lCt + 1
                        '                        If IsEmpty(vEval(lRowcount)) Then
                        '                            strEval = strEval & "0"
                        '                        Else
                        'strEval = strEval & CStr(vEval(lRowcount, lColcount))
280                     strEval = strEval & strError(vEval(lRowcount))
                        ' End If
290                 End If
300                 strEval = strEval & " ;" & vbNewLine
310             Next lRowcount
320             strEval = Left(strEval, Len(strEval) - 4)
330             strEval = strEval & Application.International(xlRightBrace)
340         Else
350             strEval = strError(vEval)
360         End If
370     Else
380         strEval = Application.International(xlLeftBrace) & EvalInCell(sStr, lRows, lCols) & Application.International(xlRightBrace)
390     End If
        '        If strEval = "" Or strEval = "{}" Then
        '            If bMsg Then ShowMsg ReworkMsg(gsMsgs(66)), vbOKOnly + vbExclamation
        '        Else
400     funTryToAnalyse = strEval
410     If bMsg Then ShowMsg ReworkMsg(gsMsgs(67), sStr, Left(strEval, 1000) & " ....."), vbInformation + vbOKOnly
        '        End If
420 Else
430     ShowMsg ReworkMsg(gsMsgs(70), sStr), vbOKOnly + vbInformation
440 End If
End Function

Function funExpand(ByVal sStr As String, oParent As Worksheet)
    Dim iClosePos() As Long
    Dim iCount As Long
    Dim iCount1 As Long
    Dim iOpen As Long                                 'Holds number of opening parens
    Dim iOpencount As Long
    Dim iOpencount1 As Long
    Dim iOpenPos() As Long
    Dim iLevel() As Long
    Dim iMaxLevel As Long
    Dim sTemp As String
    Dim sTemp1 As String

10  iOpen = Len(sStr) - Len(Replace5(sStr, "(", ""))
20  ReDim iOpenPos(iOpen)
30  ReDim iClosePos(iOpen)
40  ReDim iLevel(iOpen)
50  funExpand = ""
60  iMaxLevel = 0
70  For iCount = 1 To Len(sStr)
80      If Mid(sStr, iCount, 1) = "(" Then
90          iOpencount = iOpencount + 1
100         iOpenPos(iOpencount) = iCount
110         For iCount1 = iCount + 1 To Len(sStr)
120             If Mid(sStr, iCount1, 1) = "(" Then
130                 iOpencount1 = iOpencount1 + 1
140             ElseIf Mid(sStr, iCount1, 1) = ")" Then
150                 If iOpencount1 = 0 Then
160                     iClosePos(iOpencount) = iCount1
170                     Exit For
180                 Else
190                     iOpencount1 = iOpencount1 - 1
200                 End If
210             End If
220         Next
230     End If
240 Next
250 If iOpencount = 0 Then
260     funExpand = funTryToAnalyse(sStr, False, oParent)
270     Exit Function
280 End If
290 sTemp = sStr
300 sTemp = Mid(sTemp, iOpenPos(iOpencount), iClosePos(iOpencount) - iOpenPos(iOpencount) + 1)
310 sTemp1 = funTryToAnalyse(sTemp, False, oParent)
320 If sTemp1 <> "" Then
330     sStr = Replace5(sStr, sTemp, sTemp1)
340 End If
350 funExpand = sStr
End Function

Function GetActiveCell(ByVal glActive As Long) As String
    Dim oCurrent As Worksheet
    Dim str1 As String
    '
    ' crw 7/10/04 dont switch sheets
    '
    '10  Set oCurrent = ActiveSheet
    '20  str1 = FindReferencedSheets(gsRefersto(glActive))(1)
    '30  If str1 <> "" Then Worksheets(str1).Activate
10  GetActiveCell = ActiveCell.Address(ReferenceStyle:=glR1C1)
    '50  oCurrent.Activate
    '60  Set oCurrent = Nothing
End Function

Sub MarkupNames(iScope As Long, bFiltered As Boolean)
'iScope=1: workbook, iScope=2: Active sheet
    Dim oNm As Name
    Dim bDo As Boolean
    Dim bTemp As Boolean
    Dim bSelected As Boolean
    Dim lScreenUpdate As Long
    Dim sFailed As String
    '
    ' CRW 12/2/2010 : gsSelected is a zero lbound array
    '
    '10  If UBound(gsSelected) > 1 Then
10  If UBound(gsSelected) > 0 Then
20      If ShowMsg(gsMsgs(80), vbQuestion + vbYesNo) = vbYes Then bSelected = True
30  End If
40  Application.StatusBar = gsMsgs(77)
50  If ShowMsg(ReworkMsg(gsMsgs(75)), vbQuestion + vbYesNo) = vbYes Then
60      RemoveShapes
70  End If
80  sFailed = ""
90  lScreenUpdate = Application.ScreenUpdating
100 Application.ScreenUpdating = False
110 bDo = False
120 For Each oNm In ActiveWorkbook.Names
130     If iScope = 2 Then
140         If (oNm.RefersToRange.Parent Is ActiveSheet) Then
150             bDo = True
160         Else
170             bDo = False
180         End If
190     Else
200         bDo = True
210     End If
        '
        ' fix 2/8/2006: use namelocal when comparing to listbox names
        '
220     bDo = bDo And IsNameOnUF(oNm.NameLocal)
230     If bDo Then
240         bDo = bDo And Not IsNameRelative(oNm.RefersToR1C1)
250         If bSelected Then
260             On Error Resume Next
270             bTemp = vCustomMatch(oNm.NameLocal, gsSelected, 0) > 0
280             On Error GoTo 0
290             bDo = bTemp
300             bTemp = False
310         End If
320         If bDo Then
330             If AddShape(oNm) = False Then
340                 sFailed = sFailed & oNm.Name & ", "
350             End If
360         End If
370     End If
380 Next
390 If Len(sFailed) > 0 Then
400     sFailed = Left(sFailed, Len(sFailed) - 2)
410     ShowMsg ReworkMsg(gsMsgs(74), sFailed), vbInformation + vbOKOnly
420 End If
430 Application.StatusBar = False
440 If Application.ScreenUpdating <> lScreenUpdate Then
450     Application.ScreenUpdating = lScreenUpdate
460 End If
End Sub

Function AddShape(oNm As Name) As Boolean
    Dim oRange As Range
    Dim oArea As Range
    Dim oShape As Shape
    Dim oSheet As Worksheet
    Dim dTop As Double
    Dim dLeft As Double
    Dim dWidth As Double
    Dim dHeight As Double
    Dim oSel As Object
    Dim iTxtsize As Long
10  Set oSel = Selection
20  On Error Resume Next
30  If GoToName(oNm) Then
40      Set oRange = Selection
50  Else
        'Could not goto name, assume not a range reference
60      AddShape = True
70      Exit Function
80  End If
90  Set oSheet = oRange.Parent
100 For Each oArea In oRange.Areas

110     dTop = oArea.Cells(1, 1).Top

120     dLeft = oArea.Cells(1, 1).Left

130     dWidth = oArea.Cells(oArea.Rows.Count, oArea.Columns.Count).Left + oArea.Cells(oArea.Rows.Count, oArea.Columns.Count).Width - dLeft

140     dHeight = oArea.Cells(oArea.Rows.Count, oArea.Columns.Count).Top + oArea.Cells(oArea.Rows.Count, oArea.Columns.Count).Height - dTop
150     iTxtsize = CInt(Application.Min(36, Application.Max(Application.Min(dWidth / 2, dHeight / 30), 8)))
160     Set oShape = oSheet.Shapes.AddTextbox(msoTextOrientationHorizontal, dLeft, dTop, dWidth, dHeight)
170     With oShape
180         With .TextFrame
190             .Characters.Text = oNm.Name
200             .HorizontalAlignment = xlHAlignLeft
210             .VerticalAlignment = xlVAlignTop
220             If dWidth > dHeight Then
230                 .Orientation = xlHorizontal
240             Else
250                 .Orientation = msoTextOrientationUpward
260             End If
270             .AutoSize = False
280         End With
290         .Name = "NameManager." & .Name
300         .Fill.ForeColor.SchemeColor = 13
310         .Fill.Transparency = 0.9
320         With .Line
330             .Weight = 1#
340             .DashStyle = msoLineDash
350             .Style = msoLineSingle
360             .Transparency = 0#
370             .Visible = msoTrue
380             .ForeColor.RGB = RGB(255, 0, 0)
390             .BackColor.RGB = RGB(255, 255, 255)
400         End With
410         With .TextFrame.Characters(1, .TextFrame.Characters.Count).Font
420             .Name = "Arial"
430             .FontStyle = "bold"
440             .Size = iTxtsize
450             .Strikethrough = False
460             .Superscript = False
470             .Subscript = False
480             .OutlineFont = False
490             .Shadow = False
500             .Underline = xlUnderlineStyleNone
510             .ColorIndex = 3
520         End With
530     End With
540 Next
550 If oShape Is Nothing Then
560     AddShape = False
570 Else
580     AddShape = True
590 End If
600 oSel.Select
End Function
Sub RemoveShapes()
    Dim oShape As Shape
    Dim oSheet As Worksheet
10  For Each oSheet In ActiveWorkbook.Worksheets
20      For Each oShape In oSheet.Shapes
30          If Left(oShape.Name, 12) = "NameManager." Then
40              oShape.Delete
50          End If
60      Next
70  Next
End Sub
Public Function Replace5(ByRef Text As String, _
                         ByRef sOld As String, ByRef sNew As String, _
                         Optional ByVal Start As Long = 1, _
                         Optional ByVal Count As Long = 2147483647, _
                         Optional ByVal Compare As Long = vbBinaryCompare _
                       ) As String
' by Jost Schwider, jost@schwider.de, 20001218

10  If LenB(sOld) Then

20      If Compare = vbBinaryCompare Then
30          Replace5Bin Replace5, Text, Text, _
                        sOld, sNew, Start, Count
40      Else
50          Replace5Bin Replace5, Text, LCase$(Text), _
                        LCase$(sOld), sNew, Start, Count
60      End If

70  Else                                              'Suchstring ist leer:
80      Replace5 = Text
90  End If
End Function

Private Static Sub Replace5Bin(ByRef result As String, _
                               ByRef Text As String, ByRef Search As String, _
                               ByRef sOld As String, ByRef sNew As String, _
                               ByVal Start As Long, ByVal Count As Long _
                                                  )
' by Jost Schwider, jost@schwider.de, 20001218
    Dim TextLen As Long
    Dim OldLen As Long
    Dim NewLen As Long
    Dim ReadPos As Long
    Dim WritePos As Long
    Dim CopyLen As Long
    Dim Buffer As String
    Dim BufferLen As Long
    Dim BufferPosNew As Long
    Dim BufferPosNext As Long

    'Ersten Treffer bestimmen:
10  If Start < 2 Then
20      Start = InStrB(Search, sOld)
30  Else
40      Start = InStrB(Start + Start - 1, Search, sOld)
50  End If
60  If Start Then

70      OldLen = LenB(sOld)
80      NewLen = LenB(sNew)
90      Select Case NewLen
        Case OldLen                                   'einfaches |fffd|berschreiben:

100         result = Text
110         For Count = 1 To Count
120             MidB$(result, Start) = sNew
130             Start = InStrB(Start + OldLen, Search, sOld)
140             If Start = 0 Then Exit Sub
150         Next Count
160         Exit Sub

170     Case Is < OldLen                              'Ergebnis wird k|fffd|rzer:

            'Buffer initialisieren:
180         TextLen = LenB(Text)
190         If TextLen > BufferLen Then
200             Buffer = Text
210             BufferLen = TextLen
220         End If

            'Ersetzen:
230         ReadPos = 1
240         WritePos = 1
250         If NewLen Then

                'Einzuf|fffd|genden Text beachten:
260             For Count = 1 To Count
270                 CopyLen = Start - ReadPos
280                 If CopyLen Then
290                     BufferPosNew = WritePos + CopyLen
300                     MidB$(Buffer, WritePos) = MidB$(Text, ReadPos, CopyLen)
310                     MidB$(Buffer, BufferPosNew) = sNew
320                     WritePos = BufferPosNew + NewLen
330                 Else
340                     MidB$(Buffer, WritePos) = sNew
350                     WritePos = WritePos + NewLen
360                 End If
370                 ReadPos = Start + OldLen
380                 Start = InStrB(ReadPos, Search, sOld)
390                 If Start = 0 Then Exit For
400             Next Count

410         Else

                'Einzuf|fffd|genden Text ignorieren (weil leer):
420             For Count = 1 To Count
430                 CopyLen = Start - ReadPos
440                 If CopyLen Then
450                     MidB$(Buffer, WritePos) = MidB$(Text, ReadPos, CopyLen)
460                     WritePos = WritePos + CopyLen
470                 End If
480                 ReadPos = Start + OldLen
490                 Start = InStrB(ReadPos, Search, sOld)
500                 If Start = 0 Then Exit For
510             Next Count

520         End If

            'Ergebnis zusammenbauen:
530         If ReadPos > TextLen Then
540             result = LeftB$(Buffer, WritePos - 1)
550         Else
560             MidB$(Buffer, WritePos) = MidB$(Text, ReadPos)
570             result = LeftB$(Buffer, WritePos + LenB(Text) - ReadPos)
580         End If
590         Exit Sub

600     Case Else                                     'Ergebnis wird l|fffd|nger:

            'Buffer initialisieren:
610         TextLen = LenB(Text)
620         BufferPosNew = TextLen + NewLen
630         If BufferPosNew > BufferLen Then
640             Buffer = Space$(BufferPosNew)
650             BufferLen = LenB(Buffer)
660         End If

            'Ersetzung:
670         ReadPos = 1
680         WritePos = 1
690         For Count = 1 To Count
700             CopyLen = Start - ReadPos
710             If CopyLen Then
                    'Positionen berechnen:
720                 BufferPosNew = WritePos + CopyLen
730                 BufferPosNext = BufferPosNew + NewLen

                    'Ggf. Buffer vergr|fffd||fffd|ern:
740                 If BufferPosNext > BufferLen Then
750                     Buffer = Buffer & Space$(BufferPosNext)
760                     BufferLen = LenB(Buffer)
770                 End If

                    'String "patchen":
780                 MidB$(Buffer, WritePos) = MidB$(Text, ReadPos, CopyLen)
790                 MidB$(Buffer, BufferPosNew) = sNew
800             Else
                    'Position bestimmen:
810                 BufferPosNext = WritePos + NewLen

                    'Ggf. Buffer vergr|fffd||fffd|ern:
820                 If BufferPosNext > BufferLen Then
830                     Buffer = Buffer & Space$(BufferPosNext)
840                     BufferLen = LenB(Buffer)
850                 End If

                    'String "patchen":
860                 MidB$(Buffer, WritePos) = sNew
870             End If
880             WritePos = BufferPosNext
890             ReadPos = Start + OldLen
900             Start = InStrB(ReadPos, Search, sOld)
910             If Start = 0 Then Exit For
920         Next Count

            'Ergebnis zusammenbauen:
930         If ReadPos > TextLen Then
940             result = LeftB$(Buffer, WritePos - 1)
950         Else
960             BufferPosNext = WritePos + TextLen - ReadPos
970             If BufferPosNext < BufferLen Then
980                 MidB$(Buffer, WritePos) = MidB$(Text, ReadPos)
990                 result = LeftB$(Buffer, BufferPosNext)
1000            Else
1010                result = LeftB$(Buffer, WritePos - 1) & MidB$(Text, ReadPos)
1020            End If
1030        End If
1040        Exit Sub

1050    End Select

1060 Else                                             'Kein Treffer:
1070    result = Text
1080 End If
End Sub
Function strError(vError As Variant) As Variant
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2005-2010 All rights reserved
'
' convert a variant containing an error to an Excel error string
' if the vraiant does not contain an error then convert to string
'
10  strError = ""
20  If Not IsError(vError) Then
30      On Error Resume Next
40      If IsEmpty(vError) Then
50          strError = 0
60      Else
70          strError = CStr(vError)
80      End If
90      On Error GoTo 0
100 Else
110     On Error GoTo Fail
120     Select Case CLng(vError)
        Case xlErrDiv0
130         strError = "#Div/0"
140     Case xlErrNA
150         strError = "#N/A"
160     Case xlErrName
170         strError = "#Name?"
180     Case xlErrNull
190         strError = "#Null!"
200     Case xlErrNum
210         strError = "#Num!"
220     Case xlErrValue
230         strError = "#Value!"
240     Case xlErrRef
250         strError = "#Ref!"
260     Case Else
270         strError = "#N/A"
280     End Select
290 End If
300 Exit Function
Fail:
310 On Error GoTo 0
320 strError = "#N/A"
End Function

Private Function ReplaceSeparators(ByVal gsRefersto As String) As String
    Dim iCount As Long
    Dim sTemp As String
    Dim bInaString As Boolean
    Dim bInArray As Boolean
    Dim bInaNumber As Boolean
    Dim sSep1 As String                               'column delimeter, has to be a comma
    Dim sSep2 As String                               'row delimeter, has to be a semicolon
10  sSep1 = Mid(ThisWorkbook.Names("array").RefersToLocal, 7, 1)
20  sSep2 = Mid(ThisWorkbook.Names("array").RefersToLocal, 12, 1)
    'JKP build 462: No point in doing all this if all American settings apply
30  If sSep1 = "," And sSep2 = ";" And Application.International(xlDecimalSeparator) = "." And Application.International(xlListSeparator) = "," Then
40      ReplaceSeparators = gsRefersto
50  Else
60      bInaString = False
70      For iCount = 1 To Len(gsRefersto)
80          sTemp = Mid(gsRefersto, iCount, 1)
90          Select Case sTemp
            Case Chr(34)
100             If bInaString Then
110                 If Mid(gsRefersto, iCount + 1, 1) <> Chr(34) Then
120                     bInaString = False
130                 Else
140                     iCount = iCount + 1
150                 End If
160             Else
170                 bInaString = True
180             End If
190         Case Application.International(xlRightBrace)
200             bInArray = False
210         Case Application.International(xlLeftBrace)
220             bInArray = True
230         End Select
240         If Mid(gsRefersto, iCount, 1) Like "#" Then
250             bInaNumber = True
260         Else
270             If bInaNumber And Mid(gsRefersto, iCount, 1) <> Application.International(xlDecimalSeparator) Then
280                 bInaNumber = False
290             End If
300         End If
310         If Not bInaString Then
320             If bInaNumber And Mid(gsRefersto, iCount, 1) = Application.International(xlDecimalSeparator) Then
330                 gsRefersto = Left(gsRefersto, iCount - 1) & "." & Right(gsRefersto, Len(gsRefersto) - iCount)
340             End If
350             If Not bInArray Then
360                 If Mid(gsRefersto, iCount, 1) = Application.International(xlListSeparator) Then
370                     gsRefersto = Left(gsRefersto, iCount - 1) & "," & Right(gsRefersto, Len(gsRefersto) - iCount)
380                 End If
390             Else
400                 Select Case Mid(gsRefersto, iCount, 1)
                    Case sSep1
410                     gsRefersto = Left(gsRefersto, iCount - 1) & "," & Right(gsRefersto, Len(gsRefersto) - iCount)
420                 Case sSep2
430                     gsRefersto = Left(gsRefersto, iCount - 1) & ";" & Right(gsRefersto, Len(gsRefersto) - iCount)
440                 End Select
450             End If
460         End If
470     Next
480     ReplaceSeparators = gsRefersto
490 End If
End Function

Function GetLongRef(ByVal oNm As Name) As String
'JKP May 2005: added to get a name with a loooong refersto string
    Dim oArea As Range
    Dim sAddress As String
    Dim oCurrent As Worksheet
    Dim sListSep As String
    Dim sSheetname As String

10  sListSep = Application.International(xlListSeparator)
20  Set oCurrent = ActiveSheet
30  Application.ScreenUpdating = False
    '
    ' fix for misiing sheet crw 18/8/2005
    '
40  sSheetname = FindReferencedSheets(oNm.RefersTo)(1)
50  If sSheetname <> "" Then
        'JKP Build 566: prevent sheetchange event
60      gclNameEvent.DisableSheetEvent = True
70      Worksheets(sSheetname).Activate
        'JKP Build 566: restore sheetchange event
80      gclNameEvent.DisableSheetEvent = False
90  Else
100     sSheetname = ActiveSheet.Name
110 End If
120 If QuotesRequired(sSheetname, ActiveWorkbook) Then
130     sSheetname = "'" & sSheetname & "'"
140 End If
150 For Each oArea In ActiveSheet.Range(oNm.Name).Areas
160     If sAddress = "" Then
170         sAddress = "=" & sSheetname & "!" & oArea.Address(ReferenceStyle:=Application.ReferenceStyle)
180     Else
190         sAddress = sAddress & sListSep & sSheetname & "!" & oArea.Address(ReferenceStyle:=Application.ReferenceStyle)
200     End If
210 Next
220 GetLongRef = sAddress
230 If Not (oCurrent Is ActiveSheet) Then
        'JKP Build 566: prevent sheetchange event
240     gclNameEvent.DisableSheetEvent = True
250     oCurrent.Activate
        'JKP Build 566: restore sheetchange event
260     gclNameEvent.DisableSheetEvent = False
270 End If
End Function

Sub SetLongName(oNm As Name, gsRefersto As String)
'JKP May 2005: added to set a name with a loooong refersto string
    Dim iCount As Long
    Dim oRange As Range
    Dim sAddress As String
    Dim iTotArea As Long
    Dim iLast As Long
    Dim iNext As Long
    Dim sName As String
    Dim sListSep As String
10  sName = oNm.Name
20  sListSep = Application.International(xlListSeparator)
30  iTotArea = Len(gsRefersto) - Len(Replace5(gsRefersto, sListSep, "")) + 1
40  sAddress = ""
50  iLast = 1
60  For iCount = 1 To iTotArea
70      If iLast = 1 Then
80          iNext = InStr(2, gsRefersto, sListSep)
90          If iNext = 0 Then
100             GoTo Error
110         End If
120         sAddress = Mid(gsRefersto, 2, iNext - 2)
130         If Application.ReferenceStyle = xlR1C1 Then _
               sAddress = Application.ConvertFormula(sAddress, xlR1C1, xlA1)
140     Else
150         iNext = InStr(iLast + 1, gsRefersto, sListSep)
160         If iNext = 0 Then iNext = Len(gsRefersto) + 1
170         sAddress = Mid(gsRefersto, iLast + 1, iNext - iLast - 1)
180         If Application.ReferenceStyle = xlR1C1 Then _
               sAddress = Application.ConvertFormula(sAddress, xlR1C1, xlA1)
190     End If
200     If iLast = 1 Then

210         Set oRange = Worksheets(Replace5(Left(sAddress, InStr(sAddress, "!") - 1), "'", "")).Range(Mid(sAddress, InStr(sAddress, "!") + 1))
220     Else

230         Set oRange = Union(oRange, Worksheets(Replace5(Left(sAddress, InStr(sAddress, "!") - 1), "'", "")).Range(Mid(sAddress, InStr(sAddress, "!") + 1)))
240     End If
250     iLast = iNext
260 Next
270 On Error Resume Next
    '
    ' CRW 9 Oct 2009 use DeleteAName
    '
    '280 oNm.Delete
280 DeleteAName oNm.Name
290 oRange.Name = sName
300 Exit Sub
Error:
310 If oNm.RefersTo = "=1" Then
        '
        ' CRW 9 Oct 2009 use DeleteAName
        '
        '320 oNm.Delete
320     DeleteAName oNm.Name
330 End If
340 MsgBox gsMsgs(82), vbOKOnly + vbInformation, gsAppName
End Sub

Function QuotesRequired(myShtName As String, wkbk As Workbook) As Boolean
'JKP May 13 2005: added to check for quotes
    Dim myFormula As String
10  On Error Resume Next
20  myFormula = Application.ConvertFormula("=" & myShtName & "!A1", xlA1, xlR1C1)
30  If myFormula Like "*" & myShtName & "'!*" Then
40      QuotesRequired = True
50  Else
60      QuotesRequired = False
70  End If
80  On Error GoTo 0
End Function


Sub DoNameSelected()
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2005-2010 All rights reserved
'
' called whenever the selection changes in the listbox
'
10  If gbDisableEvents Then Exit Sub
20  gbDisableEvents = True
30  PushStack3 "DoNameSelected"
40  If glNameCount <> GetNameTableCount() Or _
       glR1C1 <> Application.ReferenceStyle Or gbRefresh Then CheckFixNames
50  If gfrmNameManager.lbxNames.ListCount = 0 Then
60      DisableThings
70  Else
80      EnableThings
90  End If
100 gbListChanged = False
110 Handle_lbxName
120 gfrmNameManager.GetTopIndex
130 gbListChanged = False
140 gbDisableEvents = False
GoExit:
150 PopStack3
End Sub
Sub DoNameAfterUpdate()
'
' called whenever the refersto in the refersto box has been modified
'
10  If gbChangedRefersTo = False Then Exit Sub
20  gbChangedRefersTo = False
30  If gbDisableEvents Then Exit Sub
40  gbDisableEvents = True

50  PushStack3 "DoNameAfterUpdate"
60  With gfrmNameManager
70      gsNewRefersTo = .tbEditName.Text              ''' crw 6/1/2003 changed position
80      CheckFixNames                                 ''' crw dec 29 2002
90      If Not gbListChanged Then                     ''' crw fix 6/1/2003: added Not
100         gbUnUsed = False                          ''' switch off unused crw 7/1/2003
110         .cbUnused = False
120         GetIndex
130         AcceptChange
140         FindAllNames
150         ListTheNames
160         GetIndex
170         If .lbxNames.ListCount = 0 Then
180             DisableThings
190             .tbEditName = ""
200         Else
210             EnableThings
220             .tbEditName = gsRefersto(glActive)
230         End If
240         SetHideUnhide
250         SetGlobLoc                                ''' crw nov 11 2002
260     Else
270         ShowMsg gsMsgs(56), vbOKOnly + vbCritical
280     End If
290     gbListChanged = False
300     gbDisableEvents = False
310 End With
GoExit:
320 PopStack3
End Sub
Sub DoNameCharChanged()
'
' called whenever a character in the refersto box is changed
'
'
' the text in the refersto box has changed
' so check for relative and >240 characters
'
10  If gbDisableEvents Then Exit Sub
20  PushStack3 "DoNameCharChanged"
    'JKP july 7 2003: fixed problems with getrightactivecell
    ' crw 30 july 2003 only check if cell is relative
    ' CRW 03 October 2009 : ignore if R1C1 mode
30  If gbIsRelative And glR1C1 <> xlR1C1 Then
40      If Not gbActiveCellChecked Then GetRightActiveCell
50  End If
60  With gfrmNameManager
70      If InStr(.tbEditName.Text, "(") <> 0 Then
80          If Len(.tbEditName.Text) > 240 Then
90              .tbEditName.Text = Left(.tbEditName.Text, 240)
100         End If
110     End If
120 End With
130 gbChangedRefersTo = True
GoExit:
140 PopStack3
End Sub
Sub DisableThings()

10  PushStack3 "DisableThings"
20  With gfrmNameManager
30      .cbEvaluate.Visible = False
40      .cbLocalise.Visible = False
50      .cbAnalyse.Visible = False
60      .cbDelete.Visible = False
70      .cbHide.Visible = False
80      .cbUnhide.Visible = False
90      .cbUsed.Visible = False
100     .tbEditName.Enabled = False
110     .cbAnalyse.Visible = False

        'JKP April 7: handle text buttons
120     .cmbEvaluate2.Enabled = False
130     .cmbLocalise2.Enabled = False
140     .cmbAnalyse2.Enabled = False
150     .cmbDelete2.Enabled = False
160     .cmbHide2.Enabled = False
170     .cmbUnhide2.Enabled = False
180     .cmbUsed2.Enabled = False
190     .cmbAnalyse2.Enabled = False
200 End With
210 PopStack3
End Sub

Sub EnableThings()
'
' modified crw Oct 31 Multi, overlap & Column2
' modified CRW Nov 4 2002, remove CgbHide & Cbunhide, fix multiselect

10  PushStack3 "EnableThings"
20  With gfrmNameManager
30      .cbPickup.Visible = CountListSheets > 0
40      .cbAnalyse.Visible = True
50      .cbLocalise.Visible = True
60      .cbEvaluate.Visible = True
70      .cbDelete.Visible = True
80      .tbEditName.Enabled = True                    ''' crw nov 1 2000, visible unless relative
90      .cbUsed.Visible = True
100     .cbEvaluate.Visible = True
        '        .lbxNames.MultiSelect = fmMultiSelectExtended    ' crw nov 4

        'JKP April 7: handle text buttons
110     .cmbAnalyse2.Visible = True
120     .cmbPickup2.Enabled = CountListSheets > 0
130     .cmbAnalyse2.Enabled = True
140     .cmbLocalise2.Enabled = True
150     .cmbEvaluate2.Enabled = True
160     .cmbDelete2.Enabled = True
170     .cmbUsed2.Enabled = True
180     .cmbEvaluate2.Enabled = True
        '        .lbxNames.MultiSelect = fmMultiSelectExtended    ' crw nov 4
190     .cmbAnalyse2.Enabled = True
200     If funCountSelected > 1 Then
210         .tbEditName.Enabled = False               ''' crw 17/9/2003
220         .cbAnalyse.Visible = False
230         .cmbAnalyse2.Enabled = False
240     End If
250     If gbOverlap Then
260         .lblColumn2.Caption = gsTxtufNameManager(43)
270         .lbxNames.MultiSelect = fmMultiSelectSingle
280     Else
290         .lblColumn2.Caption = gsTxtufNameManager(17)
300         .lbxNames.MultiSelect = fmMultiSelectExtended
310     End If
320 End With
330 PopStack3
End Sub
Sub Handle_lbxName()
'
' crw Nov 12 2002 fix for multi drag: separate events for Multi and single
' crw nov 12 2002 fix workbook names containing blanks
' crw nov 4 2002 remember names, remove tbedit, sethideunhide
'    If (Not bMulti) Or gbOverlap Then

10  PushStack3 "Handle_lbxName"
20  RememberSelectedNames
30  If gfrmNameManager.lbxNames.ListCount <> 0 Then
40      EnableThings
50  Else
60      DisableThings
70  End If
80  GetIndex
90  SetHideUnhide
100 SetGlobLoc
110 PopStack3
End Sub


Sub ShowlblRefersto()

    Dim jName As Long
    Dim sActivecell As String
    Dim str1 As String
10  With gfrmNameManager
        '
        ' CRW July 1 2003: show relative to for global or local relative names
        '
20      gbIsRelative = False
        '
        ' CRW 23 April 2014 Table
        '
30      If Not gbTable(glActive) Then gbIsRelative = IsNameRelative(FindName(gsNames(glActive)).RefersToR1C1)
40      If gbIsRelative Then
50          sActivecell = GetActiveCell(glActive)
60          If Len(gsNames(glActive)) < 33 Then
70              str1 = gsNames(glActive)
80          Else
90              str1 = Left(gsNames(glActive), 33)
100         End If
110         gfrmNameManager.lblRefersto = ReworkMsg(gsMsgs(63), str1, sActivecell)
            '
            ' crw 7/10/04
            ' change the refersto in the listbox
            '
            ' crw 2/11/2005 do not change if overlap
            '
120         If Not gbOverlap Then
130             For jName = 0 To .lbxNames.ListCount - 1
140                 If .lbxNames.Selected(jName) Then
150                     .lbxNames.List(jName, 1) = .tbEditName
160                     Exit For
170                 End If
180             Next jName
190         End If
200     Else
210         If Len(gsNames(glActive)) < 41 Then
220             str1 = gsNames(glActive)
230         Else
240             str1 = Left(gsNames(glActive), 41)
250         End If
260         gfrmNameManager.lblRefersto = ReworkMsg(gsTxtufNameManager(8), str1)
270     End If
280 End With
End Sub

Sub AddNameShow()
10  If gfrmAddName Is Nothing Then
20      Set gfrmAddName = New ufAddName
30  End If
40  gfrmAddName.InitializeUF
50  If gbShowHidden Then
60      gfrmAddName.cbxHidden = True
70  Else
80      gfrmAddName.cbxHidden = False
90  End If

100 If Val(Application.Version) = 8 Or gbMacOS = True Then
110     gfrmAddName.Show
120 Else
130     ShowModelessAddName
140 End If
End Sub

Sub ShowModelessAddName()
    #If VBA6 Or VBA7 Then
10      gfrmAddName.Show vbModeless
    #End If
End Sub

Sub NextArea()
10  gfrmAddName.SetNextArea
End Sub

Sub SelectAddNameForm()
10  gfrmAddName.ActivateForm
End Sub

Function SelectARange(sPrompt As String, sCaption As String, oReturnedRange As Range) As Boolean
    Dim frmSelectCells As ufSelectCells
10  Set frmSelectCells = New ufSelectCells
20  With frmSelectCells
30      .PromptText = sPrompt
40      .CaptionText = gsAppName
50      If TypeName(Selection) = "Range" Then
60          .StartAddress = Selection.Address(external:=True)
70      End If
80      .Initialise
90      .Show
100     If .OK Then
110         Set oReturnedRange = .ReturnedRange
120         If oReturnedRange Is Nothing Then
130             SelectARange = False
140         Else
150             SelectARange = True
160         End If
170     Else
180         SelectARange = False
190     End If
200 End With
210 Unload frmSelectCells
220 Set frmSelectCells = Nothing
End Function

Public Function vCustomMatch(ByRef szLookFor As String, ByRef aszLookIn() As String, ByVal lDummy As Long) As Variant
'
' crw 2/aug/2006: adapted for speed from Rob Bovey routine
'
    Dim bLocated As Boolean
    Dim lIndex As Long
    Dim lCount As Long
    Dim lLen As Long
10  PushStack3 "vCustomMatch"
20  bLocated = False
30  lLen = Len(szLookFor)
40  For lIndex = LBound(aszLookIn) To UBound(aszLookIn)
50      lCount = lCount + 1
60      If Len(aszLookIn(lIndex)) = lLen Then
70          If lLen = 0 Then
80              bLocated = True
90              Exit For
100         Else
110             bLocated = (InStrB(1, aszLookIn(lIndex), szLookFor, vbBinaryCompare) <> 0)
120             If bLocated Then Exit For
130         End If
140     End If
150 Next lIndex
160 If bLocated Then vCustomMatch = lCount Else vCustomMatch = CVErr(xlErrNA)
170 PopStack3
End Function
Public Function IsTableName(strName As String) As Boolean
'
' find if the name is a table
'
    Dim vIX As Variant
10  IsTableName = False
20  vIX = vCustomMatch(strName, gsNames(), 0)
30  If Not IsError(vIX) Then
40      If CLng(vIX) > 0 Then IsTableName = gbTable(CLng(vIX - 1))
50  End If
End Function
Public Function vCustomMatchLike(ByRef szLookFor As String, ByRef aszLookIn() As String, ByVal lDummy As Long) As Variant
'
' crw 11/aug/2006: Wildcard Match
'
    Dim bLocated As Boolean
    Dim lIndex As Long
    Dim lCount As Long
    Dim lLen As Long
10  PushStack3 "vCustomMatchLike"
20  bLocated = False
30  lLen = Len(szLookFor)
40  For lIndex = LBound(aszLookIn) To UBound(aszLookIn)
50      lCount = lCount + 1
60      If lLen = 0 Then
70          bLocated = True
80          Exit For
90      Else
100         bLocated = aszLookIn(lIndex) Like szLookFor
110         If bLocated Then Exit For
120     End If
130 Next lIndex
140 If bLocated Then vCustomMatchLike = lCount Else vCustomMatchLike = CVErr(xlErrNA)
150 PopStack3
End Function

Public Function HasHashInFormula(ByRef sRefersTo As String) As Boolean
'-------------------------------------------------------------------------
' Procedure : HasHashInFormula
' Company   : JKP Application Development Services (c) 2005
' Author    : Jan Karel Pieterse
' Created   : 14-2-2007
' Purpose   : Finds out whether a refersto formula contains a # symbol,
'             Ignores sheetnames with that symbol
'-------------------------------------------------------------------------
'JKP bld 664: use cverr error values
    Dim sErr As Variant
    Dim lCt As Long
    'xlErrNull  2000
    'xlErrDiv0  2007
    'xlErrValue 2015
    'xlErrRef   2023
    'xlErrName  2029
    'xlErrNum   2036
    'xlErrNA    2042
    'xlErrGettingData   2043
    'xlErrSpill 2045
    'xlErrConnect   2046
    'xlErrBlocked   2047
    'xlErrUnknown   2048
    'xlErrField 2049
    'xlErrCalc  2050
10  sErr = Array("#NULL!", "#DIV/0!", "#VALUE!", "#REF!", "#NAME?", "#NUM!", "#N/A", "#GETTING_DATA", "#SPILL!", "#VALUE!", "#VALUE!", "#UNKNOWN!", "#FIELD!", "#CALC!")
20  lCt = 1
30  For lCt = LBound(sErr) To UBound(sErr)
40      If InStr(sRefersTo, sErr(lCt)) > 0 Then
50          HasHashInFormula = True
60          Exit Function
70      End If
80  Next
End Function
Public Sub ResetScreenPosition()
10  If Not gfrmNameManager Is Nothing Then
20      Unload gfrmNameManager
30      Set gfrmNameManager = Nothing
40  End If
50  On Error Resume Next
60  DeleteSetting gsFxlNameRegKey, "Forms"
70  ManageNames
End Sub

Public Sub UnApplyName(sName As String, sRefersTo As String)
'-------------------------------------------------------------------------
' Procedure:   UnApplyName
' Company   : JKP Application Development Services (c)
' Author    : Jan Karel Pieterse (www.jkp-ads.com)
' Created   : 21-10-2010
' Purpose   : Unapplies sName on all formulas on all sheets
'-------------------------------------------------------------------------
    Dim bLocalNameOnLocalSheet
    Dim sNewFormula As String
    Dim lCount As Long
    #If VBA7 Then
        Dim hwndForm As LongPtr
    #Else
        Dim hwndForm As Long
    #End If
10  PushStack3 "UnApplyName"
20  Set gcFoundObjects = Nothing
30  FindNames sName
40  If Not gcFoundObjects Is Nothing Then
50      For lCount = 1 To gcFoundObjects.Count
60          If gcFoundObjects(lCount).Rename(sName, Right(sRefersTo, Len(sRefersTo) - 1)) = False Then
70              gbRenameError = True
80          End If
90          If gbBreak Then Exit For
100     Next
110 End If
120 Application.Visible = True
130 If gfrmNameManager.Visible Then
140     If Val(Application.Version) < 9 Then
150         hwndForm = FindWindow("ThunderXFrame", gfrmNameManager.Caption)    'XL97
160     Else
170         hwndForm = FindWindow("ThunderDFrame", gfrmNameManager.Caption)    'XL2000
180     End If
190     SetActiveWindow hwndForm
200 End If

210 PopStack3
End Sub

Sub UnapplyNames()
'-------------------------------------------------------------------------
' Procedure : UnapplyNames
' Company   : JKP Application Development Services (c)
' Author    : Jan Karel Pieterse (www.jkp-ads.com)
' Created   : 16-2-2011
' Mopdified : CRW 27 April 2014 Tables
' Purpose   : Unapplies selected names
'-------------------------------------------------------------------------
    Dim lCount As Long
    Dim sName As String
    Dim sRefersTo As String
    Dim lCalcSave As Long
    Dim bUnapply As Boolean
    Dim oName As Name
    Dim oTable As ListObject
    Dim blTold As Boolean
    Dim iMsg As Long

10  PushStack3 "UnapplyNames"

20  If gbAcknowledge Then
30      If ShowMsg(ReworkMsg(gsMsgs(107)), vbYesNo + vbQuestion) = vbNo Then
40          ShowMsg ReworkMsg(gsMsgs(4)), vbOKOnly + vbExclamation
50          GoTo GoExit
60      End If
70  End If

80  lCalcSave = Application.Calculation
90  Application.Calculation = xlCalculationManual
100 Application.ScreenUpdating = False
110 gbAddSheet = False
120 With gfrmNameManager
130     For lCount = 0 To .lbxNames.ListCount - 1
140         If .lbxNames.Selected(lCount) <> 0 Then
150             sName = .lbxNames.List(lCount)
160             If IsTableName(sName) Then
170                 If Not blTold Then
180                     iMsg = MsgBox("Convert All Selected Tables to Ranges?", vbYesNo + vbQuestion, gstrFastXL)
190                     If iMsg = vbNo Then Exit For
200                     blTold = True
210                 End If
220                 Set oTable = Nothing
230                 Set oTable = FindTableName(sName)
240                 If Not oTable Is Nothing Then
250                     oTable.Unlist
260                 End If
270             Else
280                 Set oName = FindName(sName)
290                 If Not oName Is Nothing Then
300                     On Error Resume Next
310                     sRefersTo = oName.RefersTo
320                     If Err.Number = 0 Then
330                         UnApplyName sName, sRefersTo
340                     Else

350                     End If
360                 End If
370                 If gbBreak Then Exit For
380             End If
390         End If
400     Next
410 End With
420 DeleteAddSheet
430 If Application.Calculation <> lCalcSave Then Application.Calculation = lCalcSave
440 Application.ScreenUpdating = True
GoExit:
450 PopStack3
End Sub

Sub ChangeTableName(sOldName As String, sNewName As String)
    Dim oTable As ListObject
10  Set oTable = Range(sOldName).Parent.ListObjects(sOldName)
20  oTable.Name = sNewName
End Sub


Attribute VB_Name = "fxlParserNM"
Option Explicit
Option Base 0
Option Compare Binary
Public Const strR As String = "R"
Public Const strC As String = "C"
Public Const strDQ As String = """"
Public Const strSQ As String = "'"
Public Const strEndParen As String = ")"
Public Const strStartChars As String = "=(+-,/*><& :!^" & vbLf    ''' characters that can come before the start of a name
Public Const strEndChars As String = ",)+-/*><=&: ^%" & vbLf    ''' characters that can come after the end of the name
#If VBA7 Then
    Private Declare PtrSafe Function IsCharAlphaNumericA Lib "User32" (ByVal byChar As Byte) As Long
#Else
    Private Declare Function IsCharAlphaNumericA Lib "User32" (ByVal byChar As Byte) As Long
#End If

Sub DoNameMap(blCalledbyNM As Boolean)
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2000-2010. All rights reserved
'
' build a map of where names are used (formulas and names)
'
' skip adjacent non-unique formulas

    Dim strFormula As String
    Dim strNamesFound() As String
    Dim nNamesFound As Long
    Dim nTots As Long
    Dim j As Long
    Dim k As Long
    Dim oCell As Range
    Dim strLastformula As String
    Dim vArr1 As Variant
    Dim StrLastFormulas() As String
    Dim jRow As Long
    Dim jCol As Long
    Dim kcount As Long
    Dim dTime As Double
    Dim dTotTime As Double
    Dim kk As Long
    Dim oSht As Worksheet
    Dim jLastRow As Long
    Dim jFirstrow As Long
    Dim jLastUsedRow As Long
    Dim jLastCol As Long
    Dim oRng As Range
    Dim oNm As Name
    Dim vOut() As Variant
    Dim vOut2() As Variant
    Dim vNamesInNames() As Variant
    Dim nOut As Long
    Dim oRngSet As Range
    Dim strad As String
    Dim lCalcSave As Long
    Dim blSameFormula As Boolean
    Dim nSameAs As Long
    Dim iMsg As Long
    Dim kChunk As Long
    Dim NamesMap() As Long
    Dim strBookNames() As String
    Dim strSheetNames() As String
    Dim nTotNames() As Long

    Dim blResume As Boolean
    Dim lErrLine As Long
    Dim intErrNum As Long


10  blResume = False
20  On Error GoTo Fail

30  PushStack3 "DoNameMap"
40  lCalcSave = Application.Calculation
50  Application.ScreenUpdating = False
60  Application.Calculation = xlManual
    '
    ' prepare output sheet
    '
70  blResume = True
80  Set oSht = Nothing
90  Set oSht = ActiveWorkbook.Worksheets("NameMap")
100 If oSht Is Nothing Then
110     ActiveWorkbook.Worksheets.Add.Name = "NameMap"
120 Else

130     oSht.UsedRange.Clear
140 End If
150 blResume = False
    '
    ' write headings
    '
160 Worksheets("NameMap").Range("a1") = "Name"
170 Worksheets("NameMap").Range("b1") = "Total"
180 ReDim strSheetNames(0, 254)
190 k = -1
200 For Each oSht In Worksheets
210     If oSht.Name <> "NameMap" Then
220         k = k + 1
230         If k < 255 Then
240             strSheetNames(0, k) = oSht.Name
250         Else
260             iMsg = MsgBox("Only the first 255 worksheets will be mapped", vbOKCancel, gsAppName)
270             If iMsg = vbCancel Then Exit Sub
280             Exit For
290         End If
300     End If
310 Next oSht

    '
    'dTime = MicroTimer
    '
    ' get names used in range formulae
    '
320 NamesInRanges nTotNames(), NamesMap(), strBookNames()
    '
    ' write out the output
    '

330 Worksheets("NameMap").Range("c1").Resize(1, UBound(NamesMap, 2) + 1) = strSheetNames
340 Worksheets("NameMap").Range("a2").Resize(UBound(strBookNames) + 1, 1) = Application.Transpose(strBookNames)
350 Worksheets("NameMap").Range("b2").Resize(UBound(nTotNames) + 1, 1) = nTotNames
360 Worksheets("NameMap").Range("c2").Resize(UBound(nTotNames) + 1, UBound(NamesMap, 2) + 1) = NamesMap
    '
    ' get names referredto by names
    '
370 AllNamesInNames nTots, vNamesInNames()

    '
    ' write out the output
    '
380 If nTots >= 0 Then
390     k = Worksheets("NameMap").Range("A65536").End(xlUp).Row + 2
400     Worksheets("NameMap").Range("a2").Offset(k, 0) = "Name"
410     Worksheets("NameMap").Range("b2").Offset(k, 0) = "ContainsName"
420     Worksheets("NameMap").Range("c2").Offset(k, 0) = "StartPos"
430     Worksheets("NameMap").Range("D2").Offset(k, 0) = "nChars"
440     Worksheets("NameMap").Range("E2").Offset(k, 0) = "NameType"
450     Worksheets("NameMap").Range("F2").Offset(k, 0) = "nNames"
460     Worksheets("NameMap").Range("A2").Offset(k + 1, 0).Resize(nTots + 1, 6) = vNamesInNames
470 End If
    'dTotTime = dTotTime + MicroTimer - dTime
    'MsgBox dTotTime
GoExit:
Cleanup:
480 Application.ScreenUpdating = True
490 Application.StatusBar = False
500 Application.Calculation = lCalcSave
510 PopStack3
520 Exit Sub
    '
    ' error handling and trace
    '
Fail:
530 lErrLine = Erl
540 If Err = 18 Then
550     Application.StatusBar = "Processing Interrupted in " & "DoNameMap"
560     Resume Errbreak
570 Else
        '
        ' not user interrupt
        '
580     If blResume Then
            '
            ' if resume next flagged
            '
590         Resume Next
600     Else

            '
            ' trap error number
            '
610         intErrNum = Err
620         Application.Cursor = xlDefault
            '
            ' warn user
            '
630         MsgBox "Error " & CStr(intErrNum) & " at " & lErrLine & " in " & "DoNameMap" & vbCrLf & " Stack " & strGetStack2, vbOKOnly + vbCritical, gstrFastXL
640         Resume Cleanup
650     End If
660 End If
670 GoTo GoExit

Errbreak:
    '
    ' user interrupted
    '
680 Err.Clear
690 On Error GoTo Cleanup
700 Application.Cursor = xlDefault
    '
710 MsgBox "Name Map Interrupted at " & lErrLine & " " & "DoNameMap" & vbCrLf & "Stack " & strGetStack2, vbOKOnly + vbCritical, gstrFastXL
720 GoTo Cleanup
End Sub
Sub NamesInRanges(nTotNames() As Long, NamesMap() As Long, strBookNames() As String)
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2000-2010. All rights reserved
'
' build a map of where names are used in ranges
'
' skip adjacent non-unique formulas
'
    Dim strFormula As String
    Dim strNamesFound() As String
    Dim jNameChars() As Long
    Dim nNamesFound As Long
    Dim jNamesFoundIdx() As Long
    Dim j As Long
    Dim k As Long
    Dim oCell As Range
    Dim strLastformula As String
    Dim vArr1 As Variant
    Dim StrLastFormulas() As String
    Dim jRow As Long
    Dim jCol As Long
    Dim kcount As Long
    Dim kk As Long
    Dim oSht As Worksheet
    Dim jLastRow As Long
    Dim jFirstrow As Long
    Dim jLastUsedRow As Long
    Dim jLastCol As Long
    Dim oRng As Range
    Dim oNm As Name
    Dim vjBookName As Variant
    Dim jBookName As Long
    Dim jSheet As Long
    Dim nOut As Long
    Dim oRngSet As Range
    Dim strad As String
    Dim lCalcSave As Long
    Dim blSameFormula As Boolean
    Dim nSameCol As Long
    Dim iMsg As Long
    Dim kChunk As Long
    Dim blFoundIt As Boolean
    Dim kExtraNames As Long
    Dim nNamesStored As Long
    Dim jLastColFound As Long
    Dim nLastNamesFound() As Long
    Dim strBookName As String
    Dim bRelIndirect As Boolean

    Dim blResume As Boolean
    Dim lErrLine As Long
    Dim intErrNum As Long

10  PushStack3 "NamesInRanges"
20  blResume = False
30  On Error GoTo Fail
40  kChunk = 10
50  kExtraNames = 500

60  nNamesStored = Names.Count

70  If Worksheets.Count < 256 Then
80      ReDim NamesMap(Names.Count + kExtraNames, Worksheets.Count - 2) As Long
90  Else
100     ReDim NamesMap(Names.Count + kExtraNames, 254) As Long
110 End If

120 ReDim strBookNames(Names.Count + kExtraNames) As String

130 jBookName = -1
140 For Each oNm In Names
150     jBookName = jBookName + 1
160     strBookNames(jBookName) = oNm.Name
170 Next oNm
    'QSort strBookNames, 0, jBookName
180 strBookName = ActiveWorkbook.Name
190 If InStr(strBookName, " ") > 0 Then
200     strBookName = "'" & strBookName & "'!"
210 Else
220     strBookName = strBookName & "!"
230 End If
240 jSheet = -1
250 For Each oSht In ActiveWorkbook.Worksheets
260     If oSht.Name <> "NameMap" Then
270         jSheet = jSheet + 1
280         If oSht.ProtectContents Then
290             iMsg = MsgBox("Worksheet '" & oSht.Name & "' is protected and will be not analysed for Names: Continue?", vbOKCancel + vbQuestion, gsAppName)
300             If iMsg = vbCancel Then Exit For
310         Else
320             Application.StatusBar = "Checking sheet '" & oSht.Name & "' for names"
330             Set oRng = oSht.UsedRange
340             If oRng Is Nothing Then
350             Else
360                 jLastUsedRow = oRng.Row + oRng.Rows.Count - 1
370                 jLastCol = oRng.Column + oRng.Columns.Count - 1
380             End If
390             blResume = True
400             Set oRng = Nothing
410             Set oRng = oSht.UsedRange.SpecialCells(xlCellTypeFormulas, 23)
420             blResume = False
430             If Not oRng Is Nothing Then
440                 jLastRow = 0

450                 ReDim StrLastFormulas(jLastCol) As String
460                 ReDim jNamesFoundIdx(Names.Count - 1, jLastCol) As Long
470                 ReDim nLastNamesFound(jLastCol) As Long
480                 strLastformula = ""
490                 jLastColFound = 0
500                 For Each oCell In oRng
510                     jRow = oCell.Row
520                     jCol = oCell.Column
                        '
                        ' get/cache a block of formulae and extract the formula for the current cell
                        '
530                     If jRow > jLastRow Or jRow < jFirstrow Then
540                         k = kChunk
550                         If jRow + k - 1 > jLastUsedRow Then k = jLastUsedRow - jRow + 1
560                         On Error GoTo GetError
570                         vArr1 = oSht.Range("a1").Offset(jRow - 1).Resize(k, jLastCol).FormulaR1C1
580                         On Error GoTo Fail
590                         jLastRow = jRow + k - 1
600                         jFirstrow = jRow
610                     End If
620                     strFormula = ""
630                     If k <= 1 And jLastCol <= 1 Then
640                         strFormula = vArr1
650                     Else
660                         strFormula = vArr1(jRow - jFirstrow + 1, jCol)
670                     End If

GotFormula:

                        '
                        ' skip formulae identical to previous horizontal or vertical formula
                        '
680                     blSameFormula = False
690                     If LenB(strFormula) = LenB(strLastformula) Then
700                         If InStrB(1, strFormula, strLastformula, vbBinaryCompare) > 0 Then
710                             blSameFormula = True
720                             nSameCol = jLastColFound    ''' same as last find
730                         End If
740                     End If
750                     If Not blSameFormula And LenB(strFormula) = LenB(StrLastFormulas(jCol)) Then
760                         If InStrB(1, strFormula, StrLastFormulas(jCol), vbBinaryCompare) > 0 Then
770                             blSameFormula = True
780                             nSameCol = jCol       ''' same as this column above
790                         End If
800                     End If
                        '
                        ' if different formula or last was indirect containing a relative formula
                        '
810                     If Not blSameFormula Or bRelIndirect Then
820                         strLastformula = strFormula

                            '
                            ' parse the formula
                            '
830                         For kk = 1 To 1
840                             ParseNamesR1C1 strBookName, oSht, oCell, Trim$(UCase$(strFormula)), strFormula, nNamesFound, strNamesFound(), jNameChars(), bRelIndirect
850                         Next kk
860                         If nNamesFound > 0 Then
                                '
                                ' get and store indexes to names found
                                '

                                '
                                ' store results
                                '
870                             jLastColFound = jCol
880                             nLastNamesFound(jCol) = nNamesFound
890                             For j = 0 To nNamesFound - 1
900                                 blFoundIt = False
910                                 vjBookName = vCustomMatch(strNamesFound(j), strBookNames, 0)
920                                 If Not IsError(vjBookName) Then
930                                     jBookName = CLng(vjBookName) - 1
940                                     If strBookNames(jBookName) = strNamesFound(j) Then
950                                         blFoundIt = True
960                                         jNamesFoundIdx(j, jCol) = jBookName
970                                         NamesMap(jBookName, jSheet) = NamesMap(jBookName, jSheet) + 1
980                                     End If
990                                 End If
1000                                If Not blFoundIt Then
                                        '
                                        ' name not found in workbook names so add as an extra name
                                        '
1010                                    nNamesStored = nNamesStored + 1
1020                                    jBookName = nNamesStored - 1
1030                                    strBookNames(jBookName) = strNamesFound(j)
1040                                    jNamesFoundIdx(j, jCol) = jBookName
1050                                    NamesMap(jBookName, jSheet) = NamesMap(jBookName, jSheet) + 1
1060                                End If
                                    '                                            nTots = nTots + 1
                                    '                                            If nTots > UBound(vOut, 2) Then ReDim Preserve vOut(2, nTots + 100)
                                    '                                            vOut(0, nTots) = oSht.Name
                                    '                                            vOut(1, nTots) = oCell.Address
                                    '                                            vOut(2, nTots) = strNamesFound(j)
1070                            Next j
1080                        Else
1090                            nLastNamesFound(jCol) = 0
1100                        End If
1110                    Else
                            '
                            ' same formula
                            '
1120                        If nLastNamesFound(nSameCol) > 0 Then
1130                            For j = 0 To nLastNamesFound(nSameCol) - 1
1140                                NamesMap(jNamesFoundIdx(j, nSameCol), jSheet) = NamesMap(jNamesFoundIdx(j, nSameCol), jSheet) + 1
1150                            Next j
1160                        End If
1170                    End If
1180                    StrLastFormulas(jCol) = strFormula
1190                Next oCell
1200            End If
1210        End If
1220    End If
1230 Next oSht

1240 ReDim Preserve strBookNames(nNamesStored - 1)
1250 ReDim nTotNames(nNamesStored - 1, 0) As Long
    '
    ' calc totals
    '
1260 For j = 0 To nNamesStored - 1
1270    For k = 0 To UBound(NamesMap, 2)
1280        If NamesMap(j, k) > 0 Then
1290            nTotNames(j, 0) = nTotNames(j, 0) + NamesMap(j, k)
1300        End If
1310    Next k
1320 Next j
    '
    ' redim and transpose the output
    '
    '    ReDim vOut2(nTots, 2)
    '    For j = 0 To nTots
    '        For k = 0 To 2
    '            vOut2(j, k) = vOut(k, j)
    '        Next k
    '    Next j
Cleanup:
GoExit:
1330 PopStack3
1340 Exit Sub
    '
    ' error handling and trace
    '
Fail:
1350 lErrLine = Erl
1360 If Err = 18 Then
1370    Application.StatusBar = "Processing Interrupted in " & "NameInRanges"
1380    Resume Errbreak
1390 Else
        '
        ' not user interrupt
        '
1400    If blResume Then
            '
            ' if resume next flagged
            '
1410        Resume Next
1420    Else

            '
            ' trap error number
            '
1430        intErrNum = Err
1440        Application.Cursor = xlDefault
            '
            ' warn user
            '
1450        iMsg = MsgBox("Error " & CStr(intErrNum) & " at " & lErrLine & " in " & "NameInRanges" & vbCrLf & " Stack " & strGetStack2, vbOKOnly + vbCritical, gstrFastXL)
1460        Resume Cleanup
1470    End If
1480 End If
1490 GoTo GoExit

Errbreak:
    '
    ' user interrupted
    '
1500 Err.Clear
1510 On Error GoTo Cleanup
1520 Application.Cursor = xlDefault
    '
1530 iMsg = MsgBox("Name Map Interrupted at " & lErrLine & " " & "NameInRanges" & vbCrLf & "Stack " & strGetStack2, vbOKOnly + vbCritical, gstrFastXL)
1540 GoTo Cleanup
GetError:
    '
    ' if there is an error getting a block of formulae try getting a single cell
    '
1550 On Error GoTo Fail
1560 strFormula = oCell.FormulaR1C1
1570 jLastRow = jRow
1580 jFirstrow = jRow
1590 Resume GotFormula
End Sub
Sub AllNamesInNames(nTots As Long, vNamesinNames2() As Variant)
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2000-2010. All rights reserved
'
'
'  parse out names referred to by names
'
    Dim oSht As Worksheet
    Dim oNm As Name
    Dim nNamesFound As Long
    Dim strNamesFound() As String
    Dim jNameChars() As Long
    Dim vNamesInNames() As Variant
    Dim k As Long
    Dim j As Long
    Dim strBookName As String
    Dim bRelIndirect As Boolean

    Dim blResume As Boolean
    Dim lErrLine As Long
    Dim intErrNum As Long


10  blResume = False
20  On Error GoTo Fail

30  PushStack3 "AllNamesInNames"
40  strBookName = ActiveWorkbook.Name
50  If InStr(strBookName, " ") > 0 Then
60      strBookName = "'" & strBookName & "'!"
70  Else
80      strBookName = strBookName & "!"
90  End If
100 If Names.Count > 0 Then
110     nTots = -1
120     ReDim vNamesInNames(5, Names.Count)
130     Set oSht = ActiveSheet
140     Application.StatusBar = "Finding Names embedded in Names"
150     For Each oNm In Names
160         On Error Resume Next
170         If TypeOf oNm.Parent Is Worksheet Then
180             If Err = 0 Then Set oSht = oNm.Parent
190         End If
200         On Error GoTo 0

210         ParseNamesR1C1 strBookName, oSht, ActiveCell, Trim$(UCase$(oNm.RefersToR1C1)), oNm.RefersToR1C1, nNamesFound, strNamesFound(), jNameChars(), bRelIndirect
220         If nNamesFound > 0 Then
230             For j = 0 To nNamesFound - 1
240                 nTots = nTots + 1
250                 If nTots > UBound(vNamesInNames, 2) Then ReDim Preserve vNamesInNames(5, nTots + 100)
260                 vNamesInNames(0, nTots) = oNm.Name
270                 vNamesInNames(1, nTots) = strNamesFound(j)
280                 vNamesInNames(2, nTots) = jNameChars(j, 0)
290                 vNamesInNames(3, nTots) = jNameChars(j, 1)
300                 vNamesInNames(4, nTots) = jNameChars(j, 2)
310                 vNamesInNames(5, nTots) = nNamesFound
320             Next j
330         End If
340     Next oNm
        '
        ' resize and transpose output array
        '
350     If nTots >= 0 Then
360         ReDim vNamesinNames2(nTots, 5)
370         For j = 0 To nTots
380             For k = 0 To 5
390                 vNamesinNames2(j, k) = vNamesInNames(k, j)
400             Next k
410         Next j
420     End If
430 End If

Cleanup:
GoExit:
440 PopStack3
450 Exit Sub
    '
    ' error handling and trace
    '
Fail:
460 lErrLine = Erl
470 If Err = 18 Then
480     Application.StatusBar = "Processing Interrupted in " & "AllNamesInNames"
490     Resume Errbreak
500 Else
        '
        ' not user interrupt
        '
510     If blResume Then
            '
            ' if resume next flagged
            '
520         Resume Next
530     Else

            '
            ' trap error number
            '
540         intErrNum = Err
550         Application.Cursor = xlDefault
            '
            ' warn user
            '
560         MsgBox "Error " & CStr(intErrNum) & " at " & lErrLine & " in " & "AllNamesInNames" & vbCrLf & " Stack " & strGetStack2, vbOKOnly + vbCritical, gstrFastXL
570         Resume Cleanup
580     End If
590 End If
600 GoTo GoExit

Errbreak:
    '
    ' user interrupted
    '
610 Err.Clear
620 On Error GoTo Cleanup
630 Application.Cursor = xlDefault
    '
640 MsgBox "Name Map Interrupted at " & lErrLine & " " & "AllNamesInNames" & vbCrLf & "Stack " & strGetStack2, vbOKOnly + vbCritical, gstrFastXL
650 GoTo Cleanup
End Sub
Sub OneNameInNames(oNm As Name, nTots As Long, vNamesinNames2() As Variant)
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2000-2010. All rights reserved
'
'
'  parse out names referred to by this name
'
    Dim oSht As Worksheet
    Dim nNamesFound As Long
    Dim strNamesFound() As String
    Dim jNameChars() As Long
    Dim vNamesInNames() As Variant
    Dim k As Long
    Dim j As Long
    Dim strBookName As String
    Dim bRelIndirect As Boolean

    Dim blResume As Boolean
    Dim lErrLine As Long
    Dim intErrNum As Long


10  blResume = False
20  On Error GoTo Fail

30  PushStack3 "OneNamesInNames"
40  strBookName = ActiveWorkbook.Name
50  If InStr(strBookName, " ") > 0 Then
60      strBookName = "'" & strBookName & "'!"
70  Else
80      strBookName = strBookName & "!"
90  End If
100 If Names.Count > 0 Then
110     nTots = -1
120     ReDim vNamesInNames(5, Names.Count)
130     Set oSht = ActiveSheet


140     On Error Resume Next
150     If TypeOf oNm.Parent Is Worksheet Then
160         If Err = 0 Then Set oSht = oNm.Parent
170     End If
180     On Error GoTo 0

190     ParseNamesR1C1 strBookName, oSht, ActiveCell, Trim$(UCase$(oNm.RefersToR1C1)), oNm.RefersToR1C1, nNamesFound, strNamesFound(), jNameChars(), bRelIndirect
200     If nNamesFound > 0 Then
210         For j = 0 To nNamesFound - 1
220             nTots = nTots + 1
230             If nTots > UBound(vNamesInNames, 2) Then ReDim Preserve vNamesInNames(5, nTots + 100)
240             vNamesInNames(0, nTots) = oNm.Name
250             vNamesInNames(1, nTots) = strNamesFound(j)
260             vNamesInNames(2, nTots) = jNameChars(j, 0)
270             vNamesInNames(3, nTots) = jNameChars(j, 1)
280             vNamesInNames(4, nTots) = jNameChars(j, 2)
290             vNamesInNames(5, nTots) = nNamesFound
300         Next j
310     End If
        '
        ' resize and transpose output array
        '
320     If nTots >= 0 Then
330         ReDim vNamesinNames2(nTots, 5)
340         For j = 0 To nTots
350             For k = 0 To 5
360                 vNamesinNames2(j, k) = vNamesInNames(k, j)
370             Next k
380         Next j
390     End If
400 End If
Cleanup:
GoExit:
410 PopStack3
420 Exit Sub
    '
    ' error handling and trace
    '
Fail:
430 lErrLine = Erl
440 If Err = 18 Then
450     Application.StatusBar = "Processing Interrupted in " & "OneNamesInNames"
460     Resume Errbreak
470 Else
        '
        ' not user interrupt
        '
480     If blResume Then
            '
            ' if resume next flagged
            '
490         Resume Next
500     Else

            '
            ' trap error number
            '
510         intErrNum = Err
520         Application.Cursor = xlDefault
            '
            ' warn user
            '
530         MsgBox "Error " & CStr(intErrNum) & " at " & lErrLine & " in " & "OneNamesInNames" & vbCrLf & " Stack " & strGetStack2, vbOKOnly + vbCritical, gstrFastXL
540         Resume Cleanup
550     End If
560 End If
570 GoTo GoExit

Errbreak:
    '
    ' user interrupted
    '
580 Err.Clear
590 On Error GoTo Cleanup
600 Application.Cursor = xlDefault
    '
610 MsgBox "Name Map Interrupted at " & lErrLine & " " & "OneNamesInNames" & vbCrLf & "Stack " & strGetStack2, vbOKOnly + vbCritical, gstrFastXL
620 GoTo Cleanup
End Sub

Sub CheckR1C1NA(kStart As Long, bIsName As Boolean, strNameString As String, kAsc As Long, ArrBytes() As Byte, jStarter As Long)
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2000-2010. All rights reserved
'
' check for r1c1 and true/false and N/A & DDE
'
    Dim vBool As Variant

10  If kStart = 82 Or kStart = 67 Then bIsName = Not IsR1C1(strNameString)
20  On Error Resume Next
30  vBool = CBool(strNameString)
40  If Err = 0 Then bIsName = False
50  On Error GoTo 0
    '
    ' check for #N/A
    '
60  If bIsName And Len(strNameString) = 1 Then
70      If ArrBytes(jStarter + 2) = 65 Then
80          If ArrBytes(jStarter) = 47 Then
90              If jStarter - 4 >= 0 Then
100                 If ArrBytes(jStarter - 2) = 78 And ArrBytes(jStarter - 4) = 35 Then bIsName = False
110             End If
120         End If
130     End If
140 End If

End Sub
Private Function IsR1C1(theString As String) As Boolean
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2000-2010. All rights reserved
'
' check if theString is an R1C1 reference
'
    Dim str1 As String
    Dim k As Long
    Dim jLen As Long

10  IsR1C1 = False
    On Error GoTo Fail:
20  jLen = Len(theString)
30  If jLen = 2 Then
40      IsR1C1 = True
50  Else
60      str1 = Right$(theString, jLen - 1)
70      k = InStrB(1, str1, strC, vbBinaryCompare) \ 2 + 1
80      If k > 0 Then Mid$(str1, k, 1) = "1"
90      jLen = CLng(str1)
100     If jLen <= 655361256 Then IsR1C1 = True
110 End If

Fail:
End Function
Sub GetPrefix(jStarter As Long, jPrevStarter As Long, theFormula As String, ArrBytes() As Byte, strBookName As String, nPos As Long, nChars As Long, jNameType As Long, strPrefix As String)
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2000-2010. All rights reserved
'
' if start character is ! find the prefix
'
    Dim k As Long
    Dim kStart As Long
    Dim nPos2 As Long
    Dim nChars2 As Long
10  strPrefix = vbNullString
    '
    ' if previous character is ' then look for the matching '
    '
20  If ArrBytes(jStarter - 2) = 39 Then
30      If jStarter >= 4 Then
40          For k = jStarter - 4 To 0 Step -2
50              If ArrBytes(k) = 39 Then
60                  kStart = k
70                  Exit For
80              End If
90          Next k
100         nPos2 = kStart \ 2 + 1                    ''' start char
110         nChars2 = nChars + jStarter \ 2 + 1 - kStart \ 2 - 1 + 1    ''' increase num of chars
120         strPrefix = Mid$(theFormula, kStart \ 2 + 1, jStarter \ 2 + 1 - kStart \ 2 - 1 + 1)
130     End If
140 Else
        '
        ' use previous startchar
        '
150     If jStarter >= 2 And jPrevStarter < jStarter Then
160         nPos2 = jPrevStarter \ 2 + 2
170         nChars2 = nChars + jStarter \ 2 - jPrevStarter \ 2
180         strPrefix = Mid$(theFormula, jPrevStarter \ 2 + 2, jStarter \ 2 - jPrevStarter \ 2)
190     End If
200 End If
    '
    ' check if prefix is the name of the active book: if so its a global name on a sheet with a dup local
    ' nameofworkbook!name or 'Name of workook'!name
    ' so remove the prefix
    '
210 If Len(strPrefix) > 0 Then
        '
        ' check for DDE
        '
220     If InStrB(1, strPrefix, "|", vbBinaryCompare) > 0 Then
230         jNameType = -1
240     Else
            '
            ' reset the startpos and nchars
            '
250         nPos = nPos2
260         nChars = nChars2

270         If Len(strPrefix) = Len(strBookName) Then
280             If strPrefix = strBookName Then strPrefix = vbNullString
290             jNameType = 1
300         Else
310             jNameType = 2                         ''' local not on home sheet
320         End If
330     End If
340 End If
End Sub
Sub PointQuotes(ArrBytes() As Byte, nB As Long, jPointer As Long, strUpperFormula As String, blDQuotes As Boolean, blSQuotes As Boolean)
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2000-2010. All rights reserved
'
'
' move pointer to exclude pairs of quotes
'
    Dim jEndQuote As Long
10  If ArrBytes(jPointer) = 34 Then
20      blDQuotes = Not blDQuotes
30      If blDQuotes Then
40          jEndQuote = InStr(jPointer \ 2 + 2, strUpperFormula, strDQ, vbBinaryCompare)
50          If jEndQuote > 0 Then
60              jPointer = (jEndQuote - 1) * 2 + 2
70              blDQuotes = False

80          End If
90      End If
100 End If
110 If jPointer >= nB Then Exit Sub
120 If ArrBytes(jPointer) = 39 Then
130     blSQuotes = Not blSQuotes
140     If blSQuotes Then
150         jEndQuote = InStr(jPointer \ 2 + 2, strUpperFormula, strSQ, vbBinaryCompare)
160         If jEndQuote > 0 Then
170             jPointer = (jEndQuote - 1) * 2 + 2
180             blSQuotes = False
190         End If
200     End If
210 End If
End Sub
Sub GetLocalPrefix(oSht As Worksheet, strNameString As String, strPrefix As String, jNameType As Long)
    Dim oName As Name
    Dim strSheetName As String
    '
    ' check for local name on home sheet
    '
10  If oSht.Names.Count > 0 Then
20      On Error Resume Next
30      Set oName = Nothing
40      strSheetName = "'" & oSht.Name & "'!"
50      Set oName = oSht.Names(strSheetName & strNameString)
60      On Error GoTo 0
70      If oName Is Nothing Then
80          strPrefix = vbNullString
90      Else
            '
            ' set prefix to sheetname! to match name in NamesCollection
            ' but do not change nchars becuase its not in the formula
            '
100         jNameType = 3
110         strPrefix = oName.Name
120     End If
130 End If
End Sub
Sub ParseNamesR1C1(strBookName As String, oSht As Worksheet, oCell As Range, strUpperFormula As String, strFormula As String, nNamesFound As Long, strNamesFound() As String, jNameChars() As Long, bRelIndirect As Boolean)
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2000-2010. All rights reserved
'
' parse an Uppercased R1C1 formula for Names (strUpperFormula)
'
' input:
' strBookName : a prefix string for the active book ('Book Name'!)
' oSht : the worksheet on which the formula resides ( used with local names)
' oCell : the cell containing the formula (used with indirect)
' strUpperFormula : trimmed uppercase R1C1 formula to be parsed
' strFormula: trimmed mixed case R1C1 formula from which the names will be returned
'
' returns:
' the equivalent uncased names (from strFormula) in strNamesfound
' the number of names found in nNamesFound
' the startcharacter position, number of characters and nametype in jNameChars

' nametype=-1 DDE link not a name
' nametype=1 global
' nametype=2 local not on home sheet
' nametype=3 local on home sheet
' nametype=4 found in indirect

' bRelIndirect  true if name was found in realtive indirect: switch off skip formula optimisation
' note that the number of characters in the formula is not neccessarily the length of the name
'
    Dim ArrBytes() As Byte

    Dim strNameString As String
    Dim str1 As String
    Dim nB As Long
    Dim j As Long
    Dim j2 As Long
    Dim k As Long
    Dim k2 As Long
    Dim jStarter As Long
    Dim jPrevStarter As Long
    Dim jPointer As Long
    Dim kAsc As Long
    Dim kStart As Long
    Dim bFoundChar As Boolean
    Dim bIsName As Boolean
    Dim vBool As Variant
    Dim oName As Name
    Dim strPrefix As String
    Dim strSheetName As String
    Dim blDQuotes As Boolean
    Dim blSQuotes As Boolean
    Dim strFuncString As String
    Dim jEndParen As Long
    Dim vEval As Variant
    Dim vEvalString As Variant
    Dim vEvalString2 As Variant
    Dim strEvalString As String
    Dim nNamesFound2 As Long
    Dim StrNamesFound2() As String
    Dim jNameChars2() As Long
    Dim bRelIndirect2 As Boolean
    Dim oSht2 As Worksheet
    Dim nPos As Long                                  ''' position of firstcharacter of name in formula 9could be prefix)
    Dim nChars As Long                                ''' number of chars for prefix+name in formula
    Dim jNameType As Long                             ''' type of name

    Dim blResume As Boolean
    Dim lErrLine As Long
    Dim intErrNum As Long


10  blResume = False
20  On Error GoTo Fail

30  PushStack3 "ParseNamesR1C1"

40  nNamesFound = 0
50  bRelIndirect = False
60  ReDim strNamesFound(Len(strUpperFormula) \ 2) As String
70  ReDim jNameChars(Len(strUpperFormula) \ 2, 2) As Long

80  ArrBytes = strUpperFormula                        ''' create byte array
90  nB = UBound(ArrBytes)

100 jPointer = -2
110 blDQuotes = False
120 blSQuotes = False

130 For j = 0 To nB Step 2
140     jPointer = jPointer + 2
150     If jPointer >= nB Then
160         Exit For
170     Else
            '
            ' handle quotes
            '
180         PointQuotes ArrBytes(), nB, jPointer, strUpperFormula, blDQuotes, blSQuotes

190         If jPointer >= nB Then Exit For

200         If Not blDQuotes And Not blSQuotes Then
                '
                ' is this character a valid start character
                '
210             bFoundChar = InStrB(1, strStartChars, Chr$(ArrBytes(jPointer)), vbBinaryCompare) > 0
                '
220             If bFoundChar Then
230                 jPrevStarter = jStarter
240                 jStarter = jPointer
250                 kStart = 0
                    '
                    ' scan for valid name characters and end characters
                    '
260                 For j2 = jStarter To nB Step 2
270                     jPointer = jPointer + 2
280                     If jPointer <= nB Then
290                         kAsc = ArrBytes(jPointer)
300                         If jPointer = jStarter + 2 Then
310                             If (kAsc >= 65 And kAsc <= 90) Or (kAsc >= 192 And kAsc <= 222) Or kAsc = 95 Then
                                    '
                                    ' first char is A-Z (with/without accents) or _
                                      '
320                                 kStart = kAsc
330                             Else
                                    '
                                    ' not a valid name character, go back and test for first char
                                    '
340                                 jPointer = jPointer - 2
350                                 Exit For
360                             End If
370                         Else
380                             bFoundChar = IsCharAlphaNumericA(kAsc) = 1 Or kAsc = 46 Or kAsc = 63 Or kAsc = 92 Or kAsc = 95 Or kAsc = 145
                                '
                                ' valid subsequent name char A-Z, 0-9, _, ., \, ?
                                '
390                             If bFoundChar Then
400                                 If jPointer = nB - 1 Then
                                        '
                                        ' its a name at the end, store it unless ..
                                        '
410                                     jNameType = 1    ''' global
420                                     nPos = jStarter \ 2 + 2    ''' start char
430                                     nChars = jPointer \ 2 - jStarter \ 2    ''' num of chars
440                                     strNameString = Mid$(strFormula, nPos, nChars)

450                                     bIsName = True
                                        '
                                        ' check for r1c1 and True/false and #N/A
                                        '
460                                     CheckR1C1NA kStart, bIsName, strNameString, kAsc, ArrBytes(), jStarter

                                        '
                                        ' store name
                                        '
470                                     If bIsName Then
                                            '
                                            ' get prefix if start char was !
                                            '
480                                         If ArrBytes(jStarter) = 33 Then
490                                             GetPrefix jStarter, jPrevStarter, strFormula, ArrBytes(), strBookName, nPos, nChars, jNameType, strPrefix
500                                         Else
                                                '
                                                ' check for local name on home sheet
                                                '
510                                             GetLocalPrefix oSht, strNameString, strPrefix, jNameType
520                                         End If
                                            '
                                            ' store name & nameChars if not DDE link
                                            '
530                                         If jNameType > 0 Then    ''' dde nametype=-1
540                                             nNamesFound = nNamesFound + 1
550                                             If jNameType = 3 Then
560                                                 strNamesFound(nNamesFound - 1) = strPrefix
570                                             Else
580                                                 strNamesFound(nNamesFound - 1) = strPrefix & strNameString
590                                             End If
600                                             jNameChars(nNamesFound - 1, 0) = nPos    ''' start pos
610                                             jNameChars(nNamesFound - 1, 1) = nChars    ''' number of chars in formula
620                                             jNameChars(nNamesFound - 1, 2) = jNameType    ''' nametype
630                                         End If
640                                     End If

650                                 End If
660                             Else
                                    '
                                    ' check if valid endchar
                                    '
670                                 bFoundChar = InStrB(1, strEndChars, Chr$(kAsc), vbBinaryCompare) > 0
                                    '
680                                 If bFoundChar Then
690                                     nPos = jStarter \ 2 + 2
700                                     nChars = jPointer \ 2 + 1 - jStarter \ 2 - 2
710                                     strNameString = Mid$(strFormula, nPos, nChars)

720                                     If Len(strNameString) > 0 Then
                                            '
                                            ' end char, so store unless ...
                                            '
730                                         bIsName = True
                                            '
                                            ' check for r1c1 and true/false
                                            '
740                                         CheckR1C1NA kStart, bIsName, strNameString, kAsc, ArrBytes(), jStarter

750                                         If bIsName Then
760                                             jNameType = 1
                                                '
                                                ' get prefix if start char was !
                                                '
770                                             If ArrBytes(jStarter) = 33 Then
780                                                 GetPrefix jStarter, jPrevStarter, strFormula, ArrBytes(), strBookName, nPos, nChars, jNameType, strPrefix
790                                             Else
                                                    '
                                                    ' check for local name on home sheet
                                                    '
800                                                 GetLocalPrefix oSht, strNameString, strPrefix, jNameType
810                                             End If
                                                '
                                                ' if endcharacter is : could be a name or a sheet
                                                ' (name:name or Sheet1:Sheet2!ref)
                                                '
820                                             If kAsc = 58 And ArrBytes(jStarter) <> 33 Then
                                                    '
                                                    ' see if name exists as a worksheet
                                                    '
830                                                 Set oSht2 = Nothing
840                                                 blResume = True

850                                                 Set oSht2 = Worksheets(strNameString)
860                                                 If Not oSht2 Is Nothing Then bIsName = False
870                                                 Set oSht2 = Nothing
880                                                 blResume = False
                                                    '
                                                    ' not a sheet so must be a name
                                                    '
890                                                 If bIsName And Len(strPrefix) = 0 Then
                                                        '
                                                        ' check for local name on home sheet
                                                        '
900                                                     GetLocalPrefix oSht, strNameString, strPrefix, jNameType
910                                                 End If

920                                             End If
930                                         End If
940                                         If jNameType <= 0 Then bIsName = False    ''' ignore DDE references
950                                         If bIsName Then
                                                '
                                                ' its a name, store it
                                                '
960                                             nNamesFound = nNamesFound + 1
970                                             If jNameType = 3 Then
980                                                 strNamesFound(nNamesFound - 1) = strPrefix
990                                             Else
1000                                                strNamesFound(nNamesFound - 1) = strPrefix & strNameString
1010                                            End If
1020                                            jNameChars(nNamesFound - 1, 0) = nPos    ''' start pos
1030                                            jNameChars(nNamesFound - 1, 1) = nChars    ''' number of chars in formula
1040                                            jNameChars(nNamesFound - 1, 2) = jNameType    ''' nametype
1050                                            jPointer = jPointer - 2
1060                                            Exit For
1070                                        Else
                                                '
                                                ' not a name
                                                '
1080                                            jPointer = jPointer - 2
1090                                            Exit For
1100                                        End If

1110                                    End If
1120                                Else
                                        '
                                        ' not a name unless INDIRECT(
                                        '
1130                                    If kAsc = 40 Then
                                            '
                                            ' itsa function(
                                            '
1140                                        If (jPointer \ 2 + 1 - jStarter \ 2 - 2) = 8 Then
1150                                            strFuncString = Mid$(strUpperFormula, jStarter \ 2 + 2, jPointer \ 2 + 1 - jStarter \ 2 - 2)
1160                                            If InStrB(1, strFuncString, "INDIRECT", vbBinaryCompare) Then
1170                                                jEndParen = jFindEndParen(ArrBytes, jPointer)
1180                                                If jEndParen > 0 And jEndParen > jPointer \ 2 + 2 Then
1190                                                    nPos = jPointer \ 2 + 2
1200                                                    nChars = jEndParen - jPointer \ 2 - 1
1210                                                    vEvalString = "=" & Mid$(strFormula, jPointer \ 2 + 2, nChars)
                                                        '
                                                        ' check for relative
                                                        '
1220                                                    On Error GoTo NotIndirectName
1230                                                    vEvalString2 = Application.ConvertFormula(vEvalString, xlR1C1, xlR1C1, xlAbsolute)
1240                                                    If Not IsError(vEvalString2) And vEvalString2 <> vEvalString Then bRelIndirect = True
                                                        '
                                                        ' clean out hard returns & convert to A1 for evaluate
                                                        '
1250                                                    vEvalString = Application.ConvertFormula(vEvalString, xlR1C1, xlA1, xlAbsolute, oCell)
1260                                                    strEvalString = CStr(vEvalString)
1270                                                    strEvalString = Replace5(strEvalString, vbLf, " ")
1280                                                    vEval = oSht.Evaluate(strEvalString)
1290                                                    If Not IsError(vEval) Then

                                                            '
                                                            ' convert to R1C1 formula! & recurse to see if this contains a name
                                                            '
1300                                                        strEvalString = Application.ConvertFormula("=" & CStr(vEval), xlA1, xlR1C1)
                                                            '
                                                            ' get rid of the bookname
                                                            '
1310                                                        strEvalString = Replace5(CStr(strEvalString), "[" & oSht.Parent.Name & "]", "")
1320                                                        ParseNamesR1C1 strBookName, oSht, oCell, Trim$(UCase$(strEvalString)), strEvalString, nNamesFound2, StrNamesFound2(), jNameChars2(), bRelIndirect2

1330                                                        If nNamesFound2 > 0 Then
1340                                                            For k = 1 To nNamesFound2
1350                                                                nNamesFound = nNamesFound + 1
1360                                                                strNamesFound(nNamesFound - 1) = Names(StrNamesFound2(k - 1)).Name
                                                                    '
                                                                    ' name was found in INDIRECT
                                                                    '
1370                                                                jNameType = 4
1380                                                                jNameChars(nNamesFound - 1, 2) = jNameType
                                                                    '
                                                                    ' use length of expression for Indirect
                                                                    '
1390                                                                jNameChars(nNamesFound - 1, 1) = nChars
                                                                    '
                                                                    ' start pos of expression for indirect
                                                                    '
1400                                                                jNameChars(nNamesFound - 1, 0) = nPos

1410                                                            Next k
1420                                                        End If
1430                                                    End If
NotIndirect:
1440                                                    On Error GoTo Fail
1450                                                End If
1460                                            End If
1470                                        End If
1480                                    End If
1490                                    jPointer = jPointer - 2
1500                                    Exit For
1510                                End If
1520                            End If
1530                        End If
1540                    End If
1550                Next j2
1560            End If
1570        End If
1580    End If
1590 Next j

GoExit:
Cleanup:
1600 PopStack3
1610 Exit Sub
    '
    ' error handling and trace
    '
Fail:
1620 lErrLine = Erl
1630 If Err = 18 Then
1640    Application.StatusBar = "Processing Interrupted in " & "ParseNamesR1C1"
1650    Resume Errbreak
1660 Else
        '
        ' not user interrupt
        '
1670    If blResume Then
            '
            ' if resume next flagged
            '
1680        Resume Next
1690    Else

            '
            ' trap error number
            '
1700        intErrNum = Err
1710        Application.Cursor = xlDefault
            '
            ' warn user
            '
1720        MsgBox "Error " & CStr(intErrNum) & " at " & lErrLine & " in " & "ParseNamesR1C1" & vbCrLf & " Stack " & strGetStack2, vbOKOnly + vbCritical, gstrFastXL
1730        Resume Cleanup
1740    End If
1750 End If
1760 GoTo GoExit

Errbreak:
    '
    ' user interrupted
    '
1770 Err.Clear
1780 On Error GoTo Cleanup
1790 Application.Cursor = xlDefault
    '
1800 MsgBox "Name Map Interrupted at " & lErrLine & " " & "ParseNamesR1C1" & vbCrLf & "Stack " & strGetStack2, vbOKOnly + vbCritical, gstrFastXL
1810 GoTo Cleanup

NotIndirectName:
1820 Resume NotIndirect
End Sub
Private Function jFindEndParen(ArrBytes() As Byte, jPointer As Long)
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2000-2010. All rights reserved
'
' find the character position of the closing parenthesis
'
' input is a byte array of the string and a pointer that points to the opening paren
'
' loop down arrbytes, inc nparens if (, dec if )
' if nparens=0 we have the end
'
    Dim nParens As Long
    Dim k As Long
    Dim str1 As String

10  jFindEndParen = 0
20  nParens = 1
30  For k = jPointer + 2 To UBound(ArrBytes) - 1 Step 2
40      str1 = str1 & Chr$(ArrBytes(k))
50      If ArrBytes(k) = 40 Then                      ''' (
60          nParens = nParens + 1
70      ElseIf ArrBytes(k) = 41 Then                  ''' )
80          nParens = nParens - 1
90          If nParens = 0 Then
100             jFindEndParen = k \ 2
110             Exit For
120         End If
130     End If
140 Next k

End Function
Sub ansinumbers()
    Dim arr() As Byte
    Dim j As Long
    Dim jR As Long
10  arr = Trim(gsValidChars)
20  For j = 0 To UBound(arr) Step 2
30      jR = jR + 1
40      Worksheets("Sheet1").Range("a1").Offset(jR, 2) = CStr(arr(j)) & "  " & Chr(arr(j))
50      Worksheets("Sheet1").Range("a1").Offset(jR, 3) = CBool(IsCharAlphaNumericA(arr(j)))
60  Next j
End Sub
Sub namescolls()
    Dim oNames As Names
10  Set oNames = Names
End Sub
Attribute VB_Name = "fxlVBEMenu"
'-------------------------------------------------------------------------
' Module    : fxlVBEMenu
' Company   : JKP Application Development Services (c)
' Author    : Jan Karel Pieterse
' Created   : 6-12-2007
' Purpose   : Creates and destroys VBE menu
'-------------------------------------------------------------------------
Option Explicit

Dim mcMenuHandler As CMenuHandler

Dim mbVBEMenuOK As Boolean

Sub CreateVBEMenu()
10  If Not gbVarsOK Then InitNameManager
20  If gbVBEInterface Then
30      Application.OnTime Now, "VBEMenuOK"
40      DestroyVBEMenu
50      Set mcMenuHandler = New CMenuHandler
60      mbVBEMenuOK = True
70  End If
End Sub

Sub DestroyVBEMenu()
10  If Not gbVarsOK Then InitNameManager
20  If gbVBEInterface Then
30      Set mcMenuHandler = Nothing
40  End If
End Sub

Sub VBEMenuOK()
10  If Not mbVBEMenuOK Then
20      If Not gbVarsOK Then InitNameManager
30      MsgBox "It seems trying to create the Name Manager menu for the VBA Editor fails." & vbNewLine & _
               "To ensure Name Manager functions properly without errors, this feature is now turned off", vbInformation + vbOKOnly, gsAppName
40      gbVBEInterface = False
50      SaveSetting gsFxlNameRegKey, "Settings", "ShowInVBE", CStr(CInt(gbVBEInterface))
60      InValidateRibbonNM
70  End If
End Sub

Attribute VB_Name = "mSearch"
Option Explicit
Option Compare Text                                   'ChangedJustCapitalisation needs this!!!
Option Private Module

Public gcFoundObjects As Collection
Dim mbAllowChartTypeChange As Boolean
Dim mbAllowChartTypeChangeAll As Boolean

'Declare API
#If VBA7 Then
  Private Declare PtrSafe Function GetKeyState Lib "User32" (ByVal vKey As Long) As Integer
#Else
  Private Declare Function GetKeyState Lib "User32" (ByVal vKey As Long) As Integer
#End If

Const SHIFT_KEY = 16
Private Const KEY_MASK As Integer = &HFF80 ' decimal -128

'''''''''''''''''''''''''''''''''''''''''
' KEY CONSTANTS. Values taken
' from VC++ 6.0 WinUser.h file.
'''''''''''''''''''''''''''''''''''''''''
Private Const VK_LSHIFT = &HA0
Private Const VK_RSHIFT = &HA1
Private Const VK_LCONTROL = &HA2
Private Const VK_RCONTROL = &HA3
Private Const VK_LMENU = &HA4
Private Const VK_RMENU = &HA5
'''''''''''''''''''''''''''''''''''''''''
' The following four constants simply
' provide other names, CTRL and ALT,
' for CONTROL and MENU. "CTRL" and
' "ALT" are more familiar than
' "CONTROL" and "MENU". These constants
' provide no additional functionality.
' They simply provide more familiar
' names.
'''''''''''''''''''''''''''''''''''''''''
Private Const VK_LALT = VK_LMENU
Private Const VK_RALT = VK_RMENU
Private Const VK_LCTRL = VK_LCONTROL
Private Const VK_RCTRL = VK_RCONTROL

''''''''''''''''''''''''''''''''''''''''''''
' The following constants are used to specify,
' when testing CTRL, ALT, or SHIFT, whether
' the Left key, the Right key, either the
' Left OR Right key, or BOTH the Left AND
' Right keys are down.
'
' By default, the key-test procedures make
' no distinction between the Left and Right
' keys and will return TRUE if either the
' Left or Right (or both) key is down.
''''''''''''''''''''''''''''''''''''''''''''
Public Const BothLeftAndRightKeys = 0
Public Const LeftKey = 1
Public Const RightKey = 2
Public Const LeftKeyOrRightKey = 3

Public Function IsShiftPressed() As Boolean
'Returns True if shift key is pressed
10  IsShiftPressed = (GetKeyState(SHIFT_KEY) < 0)
End Function

Public Function IsAltKeyDown(Optional LeftOrRightKey As Long = LeftKeyOrRightKey) As Boolean
''''''''''''''''''''''''''''''''''''''''''''''''
' IsAltKeyDown
' Returns TRUE or FALSE indicating whether the
' ALT key is down.
'
' If LeftOrRightKey is omitted or LeftKeyOrRightKey,
' the function return TRUE if either the left or the
' right ALT key is down. If LeftKeyOrRightKey is
' LeftKey, then only the Left ALT key is tested.
' If LeftKeyOrRightKey is RightKey, only the Right
' ALT key is tested. If LeftOrRightKey is
' BothLeftAndRightKeys, the codes tests whether
' both the Left and Right keys are down. The default
' is to test for either Left or Right, making no
' distiction between Left and Right.
''''''''''''''''''''''''''''''''''''''''''''''''
    Dim Res As Long
    
    Select Case LeftOrRightKey
        Case LeftKey
            Res = GetKeyState(VK_LALT) And KEY_MASK
        Case RightKey
            Res = GetKeyState(VK_RALT) And KEY_MASK
        Case BothLeftAndRightKeys
            Res = (GetKeyState(VK_LALT) And GetKeyState(VK_RALT) And KEY_MASK)
        Case Else
            Res = GetKeyState(vbKeyMenu) And KEY_MASK
    End Select
    IsAltKeyDown = CBool(Res)
End Function

Sub FindNames(ByVal sWhatToFind As String, Optional bBreakOnFound As Boolean = False)
    Dim bFirst As Boolean
    Dim bFound As Boolean
    Dim oLookRange As Object                          'Used when looking in a range of cells only
    Dim oName As Name
    Dim oSheet As Object
    Dim sHoldName As String
    Dim oArea As Range
    Dim oCell As Range
    Dim oDone As Range                                'holds cells already done
    Dim oFirstcell As Range                           'First cell found
    Dim oFoundRange As Range                          'Collects the areas the string is found in
    Dim oNextCell As Range                            'Current cell found
    Dim oToDo As Range                                'Holds all cells that have to be reported
    Dim oPrevSelectedObject As Object                 'Holds current selection
    Dim oPrevSelectedObjectSheet As Object            'Holds current selection on each sheet
    Dim sFormula As String
    Dim bUpdate As Boolean
10  On Error GoTo GoExit
20  Application.EnableCancelKey = xlErrorHandler
30  PushStack3 "FindNames"
40  bUpdate = Application.ScreenUpdating
50  Application.ScreenUpdating = False
60  Set oPrevSelectedObject = Selection
70  sHoldName = sWhatToFind
80  For Each oSheet In ActiveWorkbook.Sheets
90      If gbBreak Then
100         Application.OnTime Now, "ResetAll"
110         GoTo GoExit
120     End If
130     gbFound = False
140     If oSheet.Visible = xlSheetVisible Then
150         oSheet.Select
160         Set oPrevSelectedObjectSheet = Selection
170         sWhatToFind = sHoldName
180         If InStr(sHoldName, "!") > 0 Then
                'JKP Build 558: if name is local and we're looking on the local sheet,
                'strip sheetname from name
190             If sHoldName Like "'" & oSheet.Name & "'!*" Or sHoldName Like oSheet.Name & "!*" Then
200                 sWhatToFind = Mid(sHoldName, InStr(sHoldName, "!") + 1, Len(sHoldName))
210             End If
220         End If
230         If (Not FindName("'" & oSheet.Name & "'!" & sHoldName) Is Nothing) _
               Or (Not FindName(oSheet.Name & "!" & sHoldName) Is Nothing) Then
                'JKP Build 558: looking for a global name, but
                'Sheet has a local name with the same name, skip worksheet
240         Else
250             ScanSheet ActiveWorkbook, oSheet, oSheet.Name, sWhatToFind, sHoldName
260             If TypeName(oSheet) = "Worksheet" Then
270                 On Error Resume Next
280                 Set oToDo = Nothing
290                 Set oDone = Nothing
300                 Set oFoundRange = Nothing
310                 Set oFirstcell = Nothing
320                 Set oNextCell = Nothing
330                 Set oLookRange = oSheet.UsedRange
                    'empty sheet?
340                 If Not oLookRange Is Nothing Then

350                     Set oFirstcell = oLookRange.Find(What:=sWhatToFind, LookIn:=xlFormulas, LookAt _
                                                                                              :=xlPart, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=False)
360                     If Not oFirstcell Is Nothing Then
370                         bFirst = True
380                         On Error Resume Next
                            ' First collect all ranges containing the string
390                         Do While (Not oNextCell Is Nothing) And (Not oNextCell.Address = oFirstcell.Address)
400                             If bFirst Then
410                                 Set oNextCell = oFirstcell
420                                 bFirst = False
430                                 Set oFoundRange = oFirstcell
440                             End If
450                             Set oNextCell = oLookRange.FindNext(After:=oNextCell)

460                             If oNextCell Is Nothing Then Exit Do

470                             If Not oNextCell.Address = oFirstcell.Address Then
480                                 Set oFoundRange = Union(oFoundRange, oNextCell)
490                             End If
500                             If gbBreak Then Exit Do
510                         Loop
520                     End If

530                     If Not oFoundRange Is Nothing Then
540                         Set oDone = Nothing
                            'Now collect ranges with same formula (or with a value)
                            'and report those
550                         For Each oArea In oFoundRange.Areas
560                             Set oDone = oArea.Cells(1, 1)
                                ' rDone will contain the set of cells already
                                ' dealt with
570                             Set oToDo = oArea.Cells(1, 1)
                                ' oToDo builds up to a range that has all
                                ' the cells in oArea with the same formula
580                             Do
                                    ' look at each cell in this Area
590                                 For Each oCell In oArea.Cells
600                                     If Intersect(oDone, oCell) Is Nothing Then
                                            ' we haven't reported this cell already
610                                         If oToDo Is Nothing Then
620                                             Set oToDo = oCell
630                                         ElseIf oCell.FormulaR1C1 = oToDo.Cells(1, 1).FormulaR1C1 Then
                                                ' same formula in ocell as in otodo's first cell
                                                ' add ocell to otodo
640                                             Set oToDo = Union(oToDo, oCell)
650                                         End If
660                                     End If
                                        'End If
670                                 Next oCell
680                                 On Error Resume Next
                                    ' this may fail if the formula is too long
690                                 sFormula = oToDo.Range("A1").Formula
700                                 If Err Then
710                                     sFormula = "[Formula too long to report]"
720                                 End If

730                                 If Left(sFormula, 1) = "=" Then
740                                     AddItems oToDo, sFormula, "FormulaLocal", sWhatToFind, bBreakOnFound
750                                     If gbFound Then Exit Sub
760                                 End If
770                                 Set oDone = Union(oDone, oToDo)
                                    ' ready for the next lot of cells in the area
780                                 Set oToDo = Nothing
790                             Loop Until oDone.Address = oArea.Address
800                         Next
810                     End If
820                 End If
830             End If
840         End If
850         SelectObj oPrevSelectedObjectSheet
860     End If
    ScanHyperlinks oSheet, sWhatToFind, bBreakOnFound
870 Next
880 For Each oName In ActiveWorkbook.Names

890     bFound = False
900     bFound = InStr(UCase(oName.RefersTo), UCase(sWhatToFind)) > 0
910     If bFound Then
920         AddItems oName, oName.RefersTo, "RefersTo", sWhatToFind, bBreakOnFound
930         If gbFound Then Exit Sub
940     End If
950 Next
960 If Not gbFound Then
970     sWhatToFind = sHoldName
980     LookInVBA sWhatToFind
990 End If
GoExit:

1000 If Err.Number = 18 Then gbBreak = True
1010 On Error Resume Next
1020 SelectObj oPrevSelectedObject
1030 Application.ScreenUpdating = bUpdate
1040 PopStack3
End Sub

Sub AddItems(oObj As Object, sFoundString As String, sProperty As String, sWhatToFind As String, Optional bBreakOnFound As Boolean = False)
    Dim clsFoundObject As clsFoundObjects
    ' 1=Range
    ' 2=Name
    ' 3=DrawingObject
    ' 4=ChartObject
    ' 5=Comment
    ' 6=FormatCondition
    ' 7=Validation
    ' 8=Hyperlink
    ' 9=PivotTable
    ' 10=Querytable
    ' 11=LeftHeader
    ' 12=CenterHeader
    ' 13=RightHeader
    ' 14=LeftFooter
    ' 15=CenterFooter
    ' 16=RightFooter
10  If IsNameThere(sFoundString, sWhatToFind) Or sFoundString = sWhatToFind Then
20      If gcFoundObjects Is Nothing Then
30          Set gcFoundObjects = New Collection
40      End If
50      If Not clsFoundObject Is Nothing Then
60          Set clsFoundObject = Nothing
70      End If
80      Set clsFoundObject = New clsFoundObjects
90      With clsFoundObject
100         Set .FoundObject = oObj
110         .FoundString = sFoundString
120         .FoundProperty = sProperty
130     End With
140     gcFoundObjects.Add clsFoundObject
150     If bBreakOnFound Then
160         gbFound = True
170     End If
180 End If
End Sub

Sub ScanObjects(oBook As Workbook, oCollection As Object, sChosenName As String, sWhatToFind As String, sHoldName As String, Optional bBreakOnFound As Boolean = False)
' scan through the drawing objects in oCollection
    Dim oObj As Object
    Dim sString As String
    Dim oGroup As Object
    Dim stMembers() As String
    Dim i As Integer
    Dim lObj As Long
    Dim bShared As Boolean
    Dim lPos As String
10  bShared = False
20  On Error GoTo locerr
    'For Each obj In oCollection '- problem: groupobject components appear (unless they have explicit names!)

30  For lObj = oCollection.Count To 1 Step -1
40      Set oObj = oCollection(lObj)
        ' any drawing object could be linked to a macro
        ' once had a problem with a malformed object that had no accessible properties
50      On Error Resume Next
60      If Not TypeName(oObj) = "Comment" Then
70          If TypeName(oObj) <> "Shape" Then
80              sString = oObj.OnAction
90          End If
100     End If
110     If Err Then
120         sString = "[Name unobtainable]"
130         sString = oObj.Name
140         On Error GoTo locerr
            '            If sString <> "[Name unobtainable]" Then
            '                glMsgCount = glMsgCount + 1
            '                ReDim Preserve ggsMsgs(glMsgCount)
            '                ggsMsgs(glMsgCount) = "I cannot obtain the properties of " & TypeName(oObj) & " " & sString & " on " & sChosenName & Chr(13) & _
                             '                       "Possibly it contains the data you are looking for; you will need to check it yourself"
            '            Else
            '                glMsgCount = glMsgCount + 1
            '                ReDim Preserve ggsMsgs(glMsgCount)
            '                ggsMsgs(glMsgCount) = "I cannot obtain the properties of a " & TypeName(oObj) & " on " & sChosenName
            '            End If
150     Else
160         If sString <> "" Then
170             lPos = GetPos(sString, sWhatToFind, 1)
180             If lPos > 0 Then
190                 AddItems oObj, sString, "OnAction", sWhatToFind, bBreakOnFound
200                 If gbFound Then Exit Sub
210             End If
220         End If

            ' some drawing objects have formula properties
230         Select Case TypeName(oObj)

            Case "TextBox", "Picture", "Button", "Arc", "Drawing", "Oval", "Rectangle"
240             sString = ""
250             On Error Resume Next
260             lPos = 0
270             sString = oObj.Formula
280             On Error GoTo locerr
290             lPos = GetPos(sString, sWhatToFind, 1)
300             If lPos > 0 Then
310                 If oObj.Visible And Not bShared Then oObj.Select
                    'List oobj.Formula or Caption
320                 AddItems oObj, "=" & sString, "Formula", sWhatToFind, bBreakOnFound
330                 If gbFound Then Exit Sub
340             End If

350         Case "OLEObject"
360             If oObj.OLEType = xlOLELink Then
                    'iOLEFound = iOLEFound + 1
370             Else
                    'Control toolbox control ?
380                 On Error Resume Next
390                 sString = ""
400                 sString = oObj.LinkedCell
410                 On Error GoTo locerr
420                 If sString <> "" Then
430                     lPos = GetPos(sString, sWhatToFind, 1)
440                     If lPos > 0 Then
450                         If oObj.Visible And Not bShared Then oObj.Select
                            'List LinkedString only if lookin formulas is true?
460                         AddItems oObj, "=" & sString, "LinkedCell", sWhatToFind, bBreakOnFound
470                         If gbFound Then Exit Sub
480                     End If
490                 End If
500                 On Error Resume Next
510                 sString = ""
520                 sString = oObj.ListFillRange
530                 On Error GoTo locerr
540                 If sString <> "" Then
550                     lPos = GetPos(sString, sWhatToFind, 1)
560                     If lPos > 0 Then
570                         If oObj.Visible And Not bShared Then oObj.Select
                            'List ListFillRange only if lookin formulas is true?
580                         AddItems oObj, "=" & sString, "ListFillRange", sWhatToFind, bBreakOnFound
590                         If gbFound Then Exit Sub
600                     End If
610                 End If
620             End If
630         Case "GroupObject"
640             sString = oObj.Name
650             Set oGroup = oObj.Ungroup
                ' there is a problem regrouping a group containing a group object, so get an array of names
660             ReDim stMembers(1 To oGroup.Count)
670             For i = 1 To oGroup.Count
680                 stMembers(i) = oGroup(i).Name
690             Next
700             ScanObjects oBook, oGroup, "GroupObject " & sString & " in " & sChosenName, sWhatToFind, sHoldName
                ' regroup
710             ActiveSheet.DrawingObjects(1, stMembers()).Group.Name = sString

720         Case "ChartObject"
                ' check the Chart
730             ScanSheet oBook, oObj.Chart, "Chart " & oObj.Name & " on " & sChosenName, sWhatToFind, sHoldName

740         Case "CheckBox", "DropDown", "ListBox", "Spinner", "ScrollBar", "OptionButton", "ComboBox"
750             sString = oObj.LinkedCell
760             lPos = GetPos(sString, sWhatToFind, 1)
770             If lPos > 0 Then
780                 If oObj.Visible And Not bShared Then oObj.Select
                    'List LinkedString only if lookin formulas is true?
790                 AddItems oObj, sString, "LinkedCell", sWhatToFind, bBreakOnFound
800                 If gbFound Then Exit Sub
810             End If
820             On Error Resume Next
830             sString = ""
840             sString = oObj.ListFillRange
850             On Error GoTo locerr
860             If sString <> "" Then
870                 lPos = GetPos(sString, sWhatToFind, 1)
880                 If lPos > 0 Then
890                     If oObj.Visible And Not bShared Then oObj.Select
                        'This property contains no = sign, add it!
900                     AddItems oObj, "=" & sString, "ListFillRange", sWhatToFind, bBreakOnFound
910                     If gbFound Then Exit Sub
920                 End If
930             End If
940         End Select
950     End If
960 Next
970 Exit Sub
locerr:
980 If Err = 18 Then
990     gbBreak = True
1000 End If
End Sub

Sub ScanSheet(oBook As Workbook, oChosen As Object, sChosenName As String, sWhatToFind As String, sHoldName As String, Optional bBreakOnFound As Boolean = False)
' scan through the object oChosen looking for the link string sWhatToFind
' Note that ScanSheet can call itself recursively if it finds a ChartObject
' on oChosen, to look for links in the contained Chart
    Dim oObj As Object, oSeries As Series
    Dim oPivot As PivotTable
    Dim oQuery As QueryTable
    Dim sString As String, iSeries As Integer, lCCT As Long
    Dim oAxis As Axis, iAxis As Integer, iAxisGroup As Integer
    Dim stStage As String
    Dim iPoint As Integer
    Dim bLabel As Boolean
    Dim lPos As Long
    Dim bHasFormula As Boolean
    Dim iCount As Integer
    Dim bChangedChartType As Boolean
10  On Error GoTo locerr
20  mbAllowChartTypeChange = False
30  If oBook.DisplayDrawingObjects <> xlHide Then
40      ScanObjects oBook, oChosen.DrawingObjects, sChosenName, sWhatToFind, sHoldName
50  End If
60  If TypeName(oChosen) = "Worksheet" Then
70      ScanObjects oBook, oChosen.Comments, sChosenName, sWhatToFind, sHoldName
80  End If

    ' now for additional checks for particular types of oChosen
90  If TypeName(oChosen) = "Worksheet" Then
        ' look in cell formulae
        'cut code from scansheet #1 to dummy
100     For Each oPivot In oChosen.PivotTables
110         If TypeName(oPivot.SourceData) <> "String" Then
                'Pivots using external data can be ignored
120         Else
130             sString = oPivot.SourceData
140             sString = Application.ConvertFormula(sString, xlR1C1, xlA1)
150             If GetPos(sString, sWhatToFind, 1) > 0 Then
160                 AddItems oPivot, sString, "SourceData", sWhatToFind, bBreakOnFound
170                 If gbFound Then Exit Sub
180             End If
190         End If
200     Next

210     ScanFormatConditions oChosen, sWhatToFind
220     ScanValidations oChosen, sWhatToFind
        'Query Tables can be ignored

230 ElseIf TypeName(oChosen) = "Chart" Then
        ' for some checks we need the chart (or chart object) activated
240     If TypeName(oChosen.Parent) = "ChartObject" Then
250         If oChosen.Parent.Visible Then
260             On Error Resume Next
270             oChosen.Parent.Activate
280             If Err Then
                    '                    ggsMsgs(glMsgCount) = "I couldn't activate ChartObject " & oChosen.Parent.Name & " on sheet " & oChosen.Parent.Parent.Name & Chr(13) & _
                                         '                            "Some properties of the chart may not be checkable"
290             End If
300             On Error GoTo locerr
310         End If
320     End If
        ' look in chart series
330     For iSeries = oChosen.SeriesCollection.Count To 1 Step -1    ' backwards in case of deletions
340         stStage = "Series " & iSeries
            ' potential problem with series formula being inaccessible
            ' seems to go away if series is changed to Area
350         lCCT = -1
360         Set oSeries = oChosen.SeriesCollection(iSeries)
370         sString = ""
380         On Error Resume Next
390         sString = oSeries.Formula

400         If Err Then
                '                If Not (mbAllowChartTypeChange Or mbAllowChartTypeChangeAll) _
                                 '                        And gbDisAllowChartTypeChangeAll <> True Then
                '                    If frmAllowChartTypeChange Is Nothing Then
                '                        Set frmAllowChartTypeChange = New ufAllowChartTypeChange
                '                    End If
                '                    frmAllowChartTypeChange.tbxMessage = _
                                     '                            "I cannot access the formula of:" & vbNewLine & vbNewLine & _
                                     '                            "series " & iSeries & " of " & sChosenName & vbNewLine & vbNewLine & _
                                     '                            "Possibly it contains the string you are looking for;" & _
                                     '                            vbNewLine & vbNewLine & "Must I temporarily change the chart type" & _
                                     '                            " in order to try to access this information?" _
                                     '                            & vbNewLine & "(The appearance of the series might be affected!!)"
                '                    frmAllowChartTypeChange.Show
                '                End If
                '                If oSeries.ChartType <> -4111 Then
                '                    If mbAllowChartTypeChange Or mbAllowChartTypeChangeAll Then
                '                        bChangedChartType = True
                '                        lCCT = oSeries.ChartType
                '                        Err = 0
                '                        ' try changing to Area chart as then it seems possible to access the series properties
                '                        oSeries.ChartType = xlArea
                '                    End If
                '                Else
                '                    'Special kind of line chart (example: just markers, no line), cannot be restored
                '                End If
                '                sString = oSeries.Formula
                '                If Err Then
                '                    On Error GoTo locErr
                '                    glMsgCount = glMsgCount + 1
                '                    ReDim Preserve ggsMsgs(glMsgCount)
                '                    ggsMsgs(glMsgCount) = "I cannot access the formula of series " & iSeries & " of " & sChosenName & Chr(13) & _
                                     '                            "Possibly it contains the string you are looking for; you will need to look into it yourself"
                '                End If
410         End If
420         On Error GoTo locerr
430         If sString <> "" Then
440             lPos = GetPos(sString, sHoldName, 1)
450         End If
460         If lPos > 0 Then
470             AddItems oSeries, sString, "formula", sHoldName, bBreakOnFound
480             If gbFound Then Exit Sub
490         End If
            ' try data labels
500         If Not oSeries Is Nothing Then
510             For iPoint = 1 To oSeries.Points.Count
520                 On Error Resume Next
530                 bLabel = oSeries.Points(iPoint).HasDataLabel
540                 If Err <> 0 Then
550                     Err = 0
560                     If lCCT <> xlArea Then
                            '                            If Not (mbAllowChartTypeChange Or mbAllowChartTypeChangeAll) _
                                                         '                                    And gbDisAllowChartTypeChangeAll <> True Then
                            '                                If frmAllowChartTypeChange Is Nothing Then
                            '                                    Set frmAllowChartTypeChange = New ufAllowChartTypeChange
                            '                                End If
                            '                                frmAllowChartTypeChange.tbxMessage = _
                                                             '                                        "I cannot access the formula of:" & vbNewLine & vbNewLine & _
                                                             '                                        "series " & iSeries & " of " & sChosenName & vbNewLine & vbNewLine & _
                                                             '                                        "Possibly it contains the string you are looking for;" & _
                                                             '                                        vbNewLine & vbNewLine & "Must I temporarily change the chart type" & _
                                                             '                                        " in order to try to access this information?" _
                                                             '                                        & vbNewLine & "(The appearance of the series might be affected!!)"
                            '                                frmAllowChartTypeChange.Show
                            '                                Set frmAllowChartTypeChange = Nothing
                            '                                If oSeries.ChartType <> -4111 Then
                            '                                    If mbAllowChartTypeChange Or mbAllowChartTypeChangeAll Then
                            '                                        bChangedChartType = True
                            '                                        lCCT = oSeries.ChartType
                            '                                        oSeries.ChartType = xlArea
                            '                                    End If
                            '                                End If
                            '                            Else
                            '                                ggsMsgs(glMsgCount) = "I cannot access the formula of series " & iSeries & " of " & sChosenName & Chr(13) & _
                                                             '                                        "Possibly it contains the string you are looking for; you will need to look into it yourself"
                            '                                'Special kind of line chart (example: just markers, no line), cannot be restored
                            '                            End If
570                     End If
580                     bLabel = oSeries.Points(iPoint).HasDataLabel
590                     If Err Then bLabel = True     ' to force the problem out
600                 End If
610                 Err.Clear
620                 If bLabel Then
630                     bHasFormula = False
640                     bHasFormula = Left(ExecuteExcel4Macro("GET.FORMULA(""Text S" & iSeries & "P" & iPoint & """)"), 1) = "="
650                     If bHasFormula Then
660                         sString = ExecuteExcel4Macro("GET.FORMULA(""Text S" & iSeries & "P" & iPoint & """)")
670                         sString = Application.ConvertFormula(sString, xlR1C1, xlA1)
680                     Else
690                         sString = oSeries.Points(iPoint).DataLabel.Text
700                     End If
710                     If Err Then
                            '                            glMsgCount = glMsgCount + 1
                            '                            ReDim Preserve ggsMsgs(glMsgCount)
                            '                            ggsMsgs(glMsgCount) = "I cannot access datalabel " & iPoint & " of series " & iSeries & " of " & sChosenName & Chr(13) & _
                                                         '                                    "Possibly it contains the string you are looking for; you will need to check it yourself"
                            '                            ' don't bother to continue
720                         GoTo NoMorePoints
730                     End If
740                     On Error GoTo locerr
750                     If sString <> "" Then
760                         lPos = GetPos(sString, sWhatToFind, 1)
770                     End If
780                     If lPos > 0 Then
790                         With oSeries.Points(iPoint)
800                             Set oObj = .DataLabel
810                             AddItems oObj, sString, "Formula", sWhatToFind, bBreakOnFound
820                             If gbFound Then Exit Sub
830                         End With
840                     End If
850                 End If
860                 On Error GoTo locerr
870             Next iPoint
NoMorePoints:
880             On Error GoTo locerr
890         End If
            ' try to restore the chart type if we had to change it
900         If bChangedChartType = True Then
910             On Error Resume Next
920             oSeries.ChartType = lCCT
930             lCCT = -1
940             bChangedChartType = False
950             On Error GoTo locerr
960         End If
970     Next iSeries
        ' There may be a link in a chart title or axis title
        ' but no VBA property gives us access to it - have to use Excel4macro.
980     If oChosen.HasTitle Then
990         stStage = "ChartTitle"
1000        On Error Resume Next
1010        bHasFormula = Left(ExecuteExcel4Macro("GET.FORMULA(""Title"")"), 1) = "="
1020        If Err Then
                '                glMsgCount = glMsgCount + 1
                '                ReDim Preserve ggsMsgs(glMsgCount)
                '                ggsMsgs(glMsgCount) = "I cannot access the chart title of " & sChosenName & Chr(13) & _
                                 '                        "Possibly it contains the data you are looking for; You will need to check it yourself"
1030        End If
1040        On Error GoTo locerr
1050        If bHasFormula Then
1060            sString = CStr(ExecuteExcel4Macro("GET.FORMULA(""Title"")"))
1070            sString = Application.ConvertFormula(sString, xlR1C1, xlA1)
1080        Else
1090            sString = oChosen.ChartTitle.Text
1100        End If
1110        Set oObj = oChosen.ChartTitle
1120        lPos = GetPos(sString, sWhatToFind, 1)
1130        If lPos > 0 Then
                'List sString (chart title formula) or ChartTitle.text
1140            AddItems oObj, sString, "Formula", sWhatToFind, bBreakOnFound
1150            If gbFound Then Exit Sub
1160        End If
1170    End If
1180    For iAxisGroup = xlPrimary To xlSecondary Step (xlSecondary - xlPrimary)
1190        For iAxis = xlCategory To xlSeries
1200            stStage = "AxisTitle " & iAxisGroup & ":" & iAxis
1210            Set oAxis = Nothing
1220            On Error Resume Next
1230            Set oAxis = oChosen.Axes(iAxis, iAxisGroup)
1240            If Err = 0 Then
1250                On Error GoTo locerr
1260                If oAxis.HasTitle Then
1270                    On Error Resume Next
1280                    Set oObj = oAxis.AxisTitle    ' may fail on protected sheet
1290                    If Err Then
                            '                            On Error GoTo locErr
                            '                            glMsgCount = glMsgCount + 1
                            '                            ReDim Preserve ggsMsgs(glMsgCount)
                            '                            ggsMsgs(glMsgCount) = "I cannot access the axis title of " & sChosenName & Chr(13) & _
                                                         '                                    "Possibly it contains the data you are looking for; You will need to check it yourself"
1300                    Else
1310                        On Error GoTo locerr
1320                        bHasFormula = Left(ExecuteExcel4Macro("GET.FORMULA(""" & oObj.Name & """)"), 1) = "="
1330                        If bHasFormula Then
1340                            sString = ExecuteExcel4Macro("GET.FORMULA(""" & oObj.Name & """)")
1350                            sString = Application.ConvertFormula(sString, xlR1C1, xlA1)
1360                        Else
1370                            sString = oObj.Text
1380                        End If
1390                        lPos = GetPos(sString, sWhatToFind, 1)
1400                        If lPos > 0 Then
                                'list st or oaxis.axistitle.text
1410                            AddItems oObj, sString, "formula", sWhatToFind, bBreakOnFound
1420                            If gbFound Then Exit Sub
1430                        ElseIf sString = "" And iAxisGroup = xlSecondary Then
                                '                                glMsgCount = glMsgCount + 1
                                '                                ReDim Preserve ggsMsgs(glMsgCount)
                                '                                ggsMsgs(glMsgCount) = "Can't get the secondary axis title's formula of chart " & sChosenName
1440                        End If
1450                    End If
1460                End If
1470            End If
1480            On Error GoTo locerr
1490        Next iAxis
1500    Next iAxisGroup
1510 End If
1520 Exit Sub
locerr:
1530 If Err = 18 Then
1540    gbBreak = True
1550    Exit Sub
1560 Else
1570    Resume Next
1580 End If
End Sub

Function GetPos(sString As String, sWhatToFind As String, lStartPos As Long) As Long
    Dim lPos As Long
10  lPos = 0
20  On Error Resume Next
30  lPos = Application.Search(sWhatToFind, sString, lStartPos)
40  GetPos = lPos
End Function

Sub ScanFormatConditions(oSheet As Worksheet, sWhatToFind As String, Optional bBreakOnFound As Boolean = False)
    Dim oCell As Range
    Dim oSet As Range
    Dim oArea As Range
    Dim oCond As FormatCondition
    Dim iCount As Integer
    Dim bFound As Boolean
    Dim oDone As Range
10  Set oSet = oSheet.UsedRange
20  Set oSet = Nothing
30  On Error Resume Next
40  Set oSet = oSheet.Cells.SpecialCells(xlCellTypeAllFormatConditions)
50  If oSet Is Nothing Then Exit Sub
60  On Error GoTo locerr
70  For Each oArea In oSet.Areas
80      For Each oCell In oArea.Cells
90          iCount = 0
100         If Intersect(oDone, oCell) Is Nothing Then
110             Set oCell = oArea.SpecialCells(xlCellTypeSameFormatConditions)
120             If oDone Is Nothing Then
130                 Set oDone = oCell
140             Else
150                 Set oDone = Union(oDone, oCell)
160             End If
170             For Each oCond In oCell.FormatConditions
180                 iCount = iCount + 1
190                 On Error Resume Next
200                 bFound = False
210                 bFound = GetPos(oCond.Formula1, sWhatToFind, 1)
220                 On Error GoTo locerr
230                 If bFound Then
240                     AddItems oCond, oCond.Formula1, "Formula1", sWhatToFind, bBreakOnFound
250                     If gbFound Then Exit Sub
260                 End If
270                 On Error Resume Next
280                 bFound = False
290                 bFound = GetPos(oCond.Formula2, sWhatToFind, 1)
300                 On Error GoTo locerr
310                 If bFound Then
320                     AddItems oCond, oCond.Formula2, "Formula2", sWhatToFind, bBreakOnFound
330                     If gbFound Then Exit Sub
340                 End If
350             Next
360         End If
370     Next
380 Next
390 Exit Sub
locerr:
400 Resume Next
End Sub

Sub ScanValidations(oSheet As Worksheet, sWhatToFind As String, Optional bBreakOnFound As Boolean)
    Dim oCell As Range
    Dim oSet As Range
    Dim oArea As Range
    Dim iCount As Integer
    Dim sFormula As String
10  Set oSet = oSheet.UsedRange
20  Set oSet = Nothing
30  On Error Resume Next
40  Set oSet = oSheet.Cells.SpecialCells(xlCellTypeAllValidation)
50  If oSet Is Nothing Then Exit Sub
60  On Error GoTo locerr
70  For Each oArea In oSet.Areas
80      For Each oCell In oArea.Cells
90          iCount = 0
100         On Error Resume Next
110         sFormula = ""
120         sFormula = oCell.Validation.Formula1
130         On Error GoTo locerr
140         If sFormula <> "" And Left(sFormula, 1) = "=" Then
150             If GetPos(sFormula, sWhatToFind, 1) Then
160                 AddItems oCell.Validation, oCell.Validation.Formula1, "Formula1", sWhatToFind, bBreakOnFound
170                 If gbFound Then Exit Sub
180             End If
190             If GetPos(oCell.Validation.Formula2, sWhatToFind, 1) Then
200                 AddItems oCell.Validation, oCell.Validation.Formula2, "Formula2", sWhatToFind, bBreakOnFound
210                 If gbFound Then Exit Sub
220             End If
230         End If
240     Next
250 Next

260 Exit Sub

locerr:
270 Resume Next
End Sub

Function ReplaceName(sOldName As String, sNewName As String, Optional bSilent As Boolean = False) As Long
    Dim lCount As Long
    Dim sReferstoLocal As String
    Dim oSh As Object
    Dim sMsg As String
    Dim bJustCapitalisation As Boolean
    Dim bStoreAcknowledge As Boolean
10  bStoreAcknowledge = gbAcknowledge
20  If bSilent Then gbAcknowledge = False
30  bJustCapitalisation = ChangedJustCapitalisation(sNewName, sOldName)
40  If Application.ReferenceStyle = xlA1 Then
50      sReferstoLocal = FindName(sOldName).RefersToLocal
60  Else
70      sReferstoLocal = FindName(sOldName).RefersToR1C1Local
80  End If
90  Set gcFoundObjects = Nothing
100 If Not bJustCapitalisation Then
110     FindNames sOldName
120     If gbAcknowledge Then
130         For Each oSh In ActiveWorkbook.Sheets
140             sMsg = ""
150             If IsSheetProtected(oSh, False) Then
160                 sMsg = ReworkMsg(gsMsgs(95), oSh.Name)
                    '170                   ElseIf HasHiddenCells(oSh, False) Then
                    '180                       sMsg = ReworkMsg(gsMsgs(96), oSh.Name)
170             End If
180             If sMsg <> "" Then
190                 ReplaceName = MsgBox(sMsg & ReworkMsg(gsMsgs(97)), vbOKCancel + vbCritical, gsAppName)
200                 If ReplaceName = vbCancel Then
210                     Exit Function
220                 End If
230             End If
240         Next
250     End If
260 End If
270 If bJustCapitalisation Then
        'likely than only capitalisation has changed, first delete old name.
280     DeleteAName sOldName
290 End If
300 RedefineAName sNewName, sReferstoLocal
310 If Not bJustCapitalisation Then
320     If Not gcFoundObjects Is Nothing Then
330         For lCount = 1 To gcFoundObjects.Count
340             If gcFoundObjects(lCount).Rename(sOldName, sNewName) = False Then
350                 gbRenameError = True
360             End If
370             If gbBreak Then Exit For
380         Next
390     End If
400     DeleteAName sOldName
410 End If
420 gbAcknowledge = bStoreAcknowledge
End Function

Function ChangedJustCapitalisation(sStr1, sStr2) As Boolean
'Checks if two strings are only different regarding capitalisation
'Assumes Option compare text
    Dim lPos As Long
10  If sStr1 = sStr2 Then
20      For lPos = 1 To IIf(Len(sStr1) > Len(sStr2), Len(sStr2), Len(sStr1))
30          If Asc(Mid(sStr1, lPos, 1)) <> Asc(Mid(sStr2, lPos, 1)) Then
40              ChangedJustCapitalisation = True
50              Exit For
60          End If
70      Next
80  End If
End Function

Sub LookForName(sName As String)
    Dim frmWhereUsed As ufWhereUsed
10  Set gcFoundObjects = Nothing
20  Set gcFoundObjects = New Collection
30  Set frmWhereUsed = New ufWhereUsed
40  With frmWhereUsed
50      .NameToLookFor = sName
60      .Initialise
        #If VBA6 Or VBA7 Then
70          .Show vbModeless
        #Else
80          .Show
        #End If
90  End With
100 Set frmWhereUsed = Nothing
End Sub

Function GetSheet(oObj As Object) As Object
    Dim oParent As Object
    Dim oPrevParent As Object

10  Set oParent = oObj.Parent
20  While Not TypeName(oParent) = "Workbook" Or TypeName(oParent) = "Application"
30      Set oPrevParent = oParent

40      Set oParent = oParent.Parent
50  Wend
60  Set GetSheet = oPrevParent
End Function

Function SelectObj(ByRef oObj As Object) As Boolean
    Static bObj As Boolean
10  On Error Resume Next
20  If TypeName(oObj.Parent) = "Application" Then
30      oObj.Select
40      bObj = True
50  Else
60      SelectObj oObj.Parent
70      If bObj Then
80          oObj.Activate
90          oObj.Select
100     End If
110 End If
120 SelectObj = True
130 If Err > 0 Then SelectObj = False                 'Not selected, Unable to ? (e.g. Name obj)
End Function

Sub LookInVBA(sName As String)
    Dim oComp As VBIDE.VBComponent
    Dim oBk As Workbook
    Dim clsFoundObject As clsFoundObjects
    Dim lCount As Long
    Dim sGlobName As String
10  If sName Like "*!*" Then
20      sGlobName = Mid(sName, InStr(sName, "!") + 1, Len(sName))
30  End If
40  On Error GoTo locerr
50  Application.EnableCancelKey = xlErrorHandler
60  Set oBk = ActiveWorkbook
70  For Each oComp In oBk.VBProject.VBComponents
80      Select Case oComp.Type
        Case vbext_ct_ClassModule, vbext_ct_Document, vbext_ct_StdModule
90          For lCount = 1 To oComp.CodeModule.CountOfLines
100             If (oComp.CodeModule.Lines(lCount, 1) Like "*""" & sName & """*" Or _
                    oComp.CodeModule.Lines(lCount, 1) Like "*, " & sName & """*" Or _
                    oComp.CodeModule.Lines(lCount, 1) Like "*""" & sName & ", *" Or _
                    oComp.CodeModule.Lines(lCount, 1) Like "*(" & sName & ")*" Or _
                    oComp.CodeModule.Lines(lCount, 1) Like "*[[]" & sName & "[]]*") Or _
                    ((oComp.CodeModule.Lines(lCount, 1) Like "*""" & sGlobName & """*" _
                      Or oComp.CodeModule.Lines(lCount, 1) Like "*(" & sGlobName & ")*") And sGlobName <> "") Then
110                 If gcFoundObjects Is Nothing Then
120                     Set gcFoundObjects = New Collection
130                 End If
140                 If Not clsFoundObject Is Nothing Then
150                     Set clsFoundObject = Nothing
160                 End If
170                 Set clsFoundObject = New clsFoundObjects
180                 With clsFoundObject
190                     Set .FoundObject = oComp.CodeModule
200                     .FoundString = oComp.CodeModule.Lines(lCount, 1)
210                     .FoundProperty = "Line " & lCount
220                     .FoundInBook = ActiveWorkbook.FullName
230                 End With
240                 gcFoundObjects.Add clsFoundObject
250             End If
260         Next
270     End Select
280 Next
TidyUp:
290 Exit Sub
locerr:
300 If Err.Number = 1004 Then
310     If Not gbWarnedTrustAccessVBA Then
320         ShowMsg ReworkMsg(gsMsgs(101)), vbOKOnly + vbExclamation
330         gbWarnedTrustAccessVBA = True
340         Resume TidyUp
350     End If
360 ElseIf Err = 18 Then
370     gbBreak = True
380     Resume TidyUp
390 End If
400 Resume Next
End Sub

Function SelectVBA(oFoundObj As CodeModule, lLine As Long)
10  Application.Visible = False

20  Application.VBE.MainWindow.Visible = True
30  oFoundObj.CodePane.Show

40  Application.VBE.ActiveCodePane.SetSelection lLine, 1, lLine + 1, 1
End Function

Sub ScanHyperlinks(oSheet As Worksheet, sName2Find As String, bBreakOnFound As Boolean)
    Dim oHyperlink As Hyperlink
    Dim sText As String
    For Each oHyperlink In oSheet.Hyperlinks
        If GetPos(oHyperlink.Address, sName2Find, 1) > 0 Then
            AddItems oHyperlink, oHyperlink.Address, "Address", sName2Find, bBreakOnFound
        End If
        If GetPos(oHyperlink.SubAddress, sName2Find, 1) > 0 Then
            AddItems oHyperlink, oHyperlink.SubAddress, "SubAddress", sName2Find, bBreakOnFound
        End If
    Next
End Sub

Attribute VB_Name = "modAPIDeclarations"
Option Explicit
Option Private Module

#If VBA7 Then
    Public Declare PtrSafe Function FindWindow Lib "User32" Alias "FindWindowA" _
           (ByVal lpClassName As String, ByVal lpWindowName As String) As LongPtr
    Public Declare PtrSafe Function SetActiveWindow Lib "user32.dll" (ByVal hwnd As LongPtr) As LongPtr
    Private Declare PtrSafe Sub SetWindowPos Lib "User32" (ByVal hwnd As LongPtr, ByVal hWndInsertAfter As LongPtr, _
                                                           ByVal x As Long, ByVal Y As Long, ByVal cx As Long, ByVal cy As Long, ByVal wFlags As Long)
    Private Const HWND_TOPMOST As LongPtr = -1
    Private Const HWND_NOTOPMOST As LongPtr = -2

    'JKP build 637: handle parent window for Excel 2013 and later
    Private Declare PtrSafe Function FindWindowA Lib "User32" (ByVal lpClassName As String, ByVal lpWindowName As String) As LongPtr
    #If Win64 Then
        Private Declare PtrSafe Function SetWindowLongA Lib "User32" Alias "SetWindowLongPtrA" (ByVal hwnd As LongPtr, ByVal nIndex As Long, ByVal dwNewLong As LongPtr) As LongPtr
    #Else
        Private Declare PtrSafe Function SetWindowLongA Lib "User32" (ByVal hwnd As LongPtr, ByVal nIndex As Long, ByVal dwNewLong As LongPtr) As LongPtr
    #End If
    Private Declare PtrSafe Function SetForegroundWindow Lib "User32" (ByVal hwnd As LongPtr) As Long
#Else
    Public Declare Function FindWindow Lib "User32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
    Public Declare Function SetActiveWindow Lib "user32.dll" (ByVal hwnd As Long) As Long
    Private Declare Sub SetWindowPos Lib "User32" (ByVal hwnd As Long, ByVal hWndInsertAfter As Long, _
                                                   ByVal x As Long, ByVal Y As Long, ByVal cx As Long, ByVal cy As Long, ByVal wFlags As Long)
    Private Const HWND_TOPMOST As Long = -1
    Private Const HWND_NOTOPMOST As Long = -2

    'JKP build 637: handle parent window for Excel 2013 and later
    Private Declare Function FindWindowA Lib "User32" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
    Private Declare Function SetWindowLongA Lib "User32" (ByVal hwnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
    Private Declare Function SetForegroundWindow Lib "User32" (ByVal hwnd As Long) As Long
#End If

'Clipboard stuff build 657
'build 659: changed ") as Long" to ") As LongPtr"
#If VBA7 Then
    Private Declare PtrSafe Function GlobalUnlock Lib "kernel32" (ByVal hMem As LongPtr) As LongPtr
    Private Declare PtrSafe Function GlobalLock Lib "kernel32" (ByVal hMem As LongPtr) As LongPtr
    Private Declare PtrSafe Function GlobalAlloc Lib "kernel32" (ByVal wFlags As LongPtr, ByVal dwBytes As LongPtr) As LongPtr
    Private Declare PtrSafe Function CloseClipboard Lib "User32" () As LongPtr
    Private Declare PtrSafe Function OpenClipboard Lib "User32" (ByVal hwnd As LongPtr) As LongPtr
    Private Declare PtrSafe Function EmptyClipboard Lib "User32" () As LongPtr
    Private Declare PtrSafe Function lstrcpy Lib "kernel32" (ByVal lpString1 As Any, ByVal lpString2 As Any) As LongPtr
    Private Declare PtrSafe Function SetClipboardData Lib "User32" (ByVal wFormat As LongPtr, ByVal hMem As LongPtr) As LongPtr
#Else
    Private Declare Function GlobalUnlock Lib "kernel32" (ByVal hMem As Long) As Long
    Private Declare Function GlobalLock Lib "kernel32" (ByVal hMem As Long) As Long
    Private Declare Function GlobalAlloc Lib "kernel32" (ByVal wFlags As Long, ByVal dwBytes As Long) As Long
    Private Declare Function CloseClipboard Lib "User32" () As Long
    Private Declare Function OpenClipboard Lib "User32" (ByVal hwnd As Long) As Long
    Private Declare Function EmptyClipboard Lib "User32" () As Long
    Private Declare Function lstrcpy Lib "kernel32" (ByVal lpString1 As Any, ByVal lpString2 As Any) As Long
    Private Declare Function SetClipboardData Lib "User32" (ByVal wFormat As Long, ByVal hMem As Long) As Long
#End If
Public Const GHND = &H42
Public Const CF_TEXT = 1
Public Const MAXSIZE = 4096

Private Const SWP_NOSIZE As Long = &H1
Private Const SWP_NOMOVE As Long = &H2
Private Const SWP_NOACTIVATE As Long = &H10
Private Const SWP_SHOWWINDOW As Long = &H40

#If VBA7 Then
Public Sub MakeTopmost(hwndForm As LongPtr, pblnMakeTopmost As Boolean)
    Dim lngParm As LongPtr
#Else
Public Sub MakeTopmost(hwndForm As Long, pblnMakeTopmost As Boolean)
    Dim lngParm As Long
#End If
10 lngParm = IIf(hwndForm, HWND_TOPMOST, HWND_NOTOPMOST)
20 SetWindowPos hwndForm, lngParm, 0, 0, 0, 0, (SWP_NOACTIVATE Or SWP_SHOWWINDOW Or SWP_NOMOVE Or SWP_NOSIZE)
End Sub

Sub PutIntoClipBoard(sText As String)
    Dim oDataObject As DataObject
    Application.CutCopyMode = False
'    If Val(Application.Version) >= 16 Then
        ClipBoard_SetData sText
'    Else
'        Set oDataObject = Nothing
'        Set oDataObject = New DataObject
'        With oDataObject
'            .SetText sText
'            .PutInClipboard
'        End With
'    End If
End Sub


Public Function ClipBoard_SetData(sPutToClip As String) As Boolean

' www.msdn.microsoft.com/en-us/library/office/ff192913.aspx

#If VBA7 Then
    Dim hGlobalMemory As LongPtr
    Dim lpGlobalMemory As LongPtr
    Dim hClipMemory As LongPtr
    Dim x As LongPtr
#Else
    Dim hGlobalMemory As Long
    Dim lpGlobalMemory As Long
    Dim hClipMemory As Long
    Dim x As Long
#End If
    On Error GoTo ExitWithError_

    ' Allocate moveable global memory
    hGlobalMemory = GlobalAlloc(GHND, Len(sPutToClip) + 1)

    ' Lock the block to get a far pointer to this memory
    lpGlobalMemory = GlobalLock(hGlobalMemory)

    ' Copy the string to this global memory
    lpGlobalMemory = lstrcpy(lpGlobalMemory, sPutToClip)

    ' Unlock the memory
    If GlobalUnlock(hGlobalMemory) <> 0 Then
        MsgBox "Memory location could not be unlocked. Clipboard copy aborted", vbCritical, "API Clipboard Copy"
        GoTo ExitWithError_
    End If

    ' Open the Clipboard to copy data to
    If OpenClipboard(0&) = 0 Then
        MsgBox "Clipboard could not be opened. Copy aborted!", vbCritical, "API Clipboard Copy"
        GoTo ExitWithError_
    End If

    ' Clear the Clipboard
    x = EmptyClipboard()

    ' Copy the data to the Clipboard
    hClipMemory = SetClipboardData(CF_TEXT, hGlobalMemory)
    ClipBoard_SetData = True

    If CloseClipboard() = 0 Then
        MsgBox "Clipboard could not be closed!", vbCritical, "API Clipboard Copy"
    End If
    Exit Function
ExitWithError_:
    On Error Resume Next
    If Err.Number > 0 Then MsgBox "Clipboard error: " & Err.Description, vbCritical, "API Clipboard Copy"
    ClipBoard_SetData = False

End Function

Attribute VB_Name = "modMsgBox"
Option Explicit
Option Private Module

Function ShowMessageBox(sMsg As String, sBut1 As String, sBut2 As String, sBut3 As String, _
                        lDefault As Long, lCancel As Long, bInput As Boolean, sReturnText As String) As Long
    Dim frmInput As ufInputBox
10  Set frmInput = New ufInputBox
20  With frmInput
30      .Caption = gsAppName
40      .Message = sMsg
50      If sBut1 = "" Then
60          .cmbBut1.Visible = False
70      Else
80          .cmbBut1.Caption = sBut1
90      End If
100     If sBut2 = "" Then
110         .cmbBut2.Visible = False
120     Else
130         .cmbBut2.Caption = sBut2
140     End If
150     If sBut3 = "" Then
160         .cmbBut3.Visible = False
170     Else
180         .cmbBut3.Caption = sBut3
190     End If

200     .Controls("cmbBut" & lDefault).Default = True
210     .Controls("cmbBut" & lCancel).Cancel = True
220     .IsInputBox = bInput
230     If bInput Then
240         .ReturnText = sReturnText
250     End If
260     .Initialize
270     .Show
280     ShowMessageBox = .PressedButton
290     sReturnText = .ReturnText
300 End With
310 Unload frmInput
320 Set frmInput = Nothing
End Function


Attribute VB_Name = "ufAddName"
Attribute VB_Base = "0{709BAA17-8E95-49DA-817F-5C6CCC4769C9}{DFDD317C-171C-44EF-AF2A-4B9475E6395E}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2000-2010. All rights reserved
Option Explicit

'SB+
'Declare an object for our CFormResizer class to handle resizing for this form
Dim mclsResizer As CFormResizer

Dim gbDisableEvents As Boolean
Dim gbMinimized As Boolean
Dim bUpdate As Boolean

Dim lFormHeight As Long
Dim lFormWidth As Long
Dim lSelStart As Long
Dim lSelLen As Long

Dim sAddNameRange As String                           ''' Holds current range for addname event code
Dim sAddNameSheet As String                           ''' Holds current sheet for addname event code
Dim msNewRefersTo As String

Dim mdOldtbxTop As Double                             ''' Holds Current position of tbxNewRefersto
Dim mdOldtbxLeft As Double                            ''' Holds Current position of tbxNewRefersto
Dim mdOldFormHeight As Double                         ''' Holds Current size of Form
Dim mdOldFormWidth As Double                          ''' Holds Current size of form

Dim moCurrentWorkBook As Workbook

Public WithEvents NameSelectApp As Application
Attribute NameSelectApp.VB_VarHelpID = -1

#If VBA7 Then
    Dim mhwndForm As LongPtr                                 'The userform's window handle
#Else
    Dim mhwndForm As Long                                 'The userform's window handle
#End If

Private Sub cmbCopy_Click()
10  Me.tbxNewRefersTo.Text = Me.lblRefersto.Caption
End Sub
Private Sub NameSelectApp_WorkbookActivate(ByVal Wb As Workbook)
    Dim str1 As String
10  str1 = Wb.Name
    'NameSelectApp_SheetSelectionChange ActiveSheet, ActiveCell
End Sub
Private Sub NameSelectApp_SheetSelectionChange(ByVal Sh As Object, ByVal Target As Range)
    Dim sLeft As String
    Dim sRight As String
    Dim sListSep As String
    '
    ' set flag to indicate form has been reszied to small
    ' crw 10 May 2007
    '
10  gbMinimized = True

20  sListSep = Application.International(xlListSeparator)
30  sAddNameRange = Target.Address
40  While InStr(sAddNameRange, ",") > 0
50      strReplace sAddNameRange, InStr(sAddNameRange, ","), ",", sListSep & "'" & sAddNameSheet & "'!"
60  Wend
70  sAddNameSheet = "[" & Sh.Parent.Name & "]" & Sh.Name
80  gbDisableEvents = True
90  sLeft = Left(Me.tbxNewRefersTo, lSelStart)
100 sRight = Mid(Me.tbxNewRefersTo, lSelStart + lSelLen + 1, Len(Me.tbxNewRefersTo))
110 Me.tbxNewRefersTo.Text = sLeft & "'" & sAddNameSheet & "'!" & _
                             sAddNameRange & sRight
120 lSelLen = Len("'" & sAddNameSheet & "'!" & sAddNameRange)
130 Me.tbxNewRefersTo.SelLength = lSelLen
    'JKP build 547: Minimize form
140 If mdOldtbxLeft = 0 Then

150     mdOldtbxLeft = tbxNewRefersTo.Left
160 End If
170 If mdOldtbxTop = 0 Then

180     mdOldtbxTop = tbxNewRefersTo.Top
190 End If
200 If mdOldFormWidth = 0 Then

210     mdOldFormWidth = Me.Width
220 End If
230 If mdOldFormHeight = 0 Then

240     mdOldFormHeight = Me.Height
250 End If
260 Me.tbxNewRefersTo.Top = 0
270 Me.tbxNewRefersTo.Left = 0
280 lblNewName.Visible = False
290 lblNewRefersTo.Visible = False
300 tbxNewName.Visible = False
310 Me.Width = tbxNewRefersTo.Width
320 Me.Height = tbxNewRefersTo.Height
330 gbDisableEvents = False
End Sub

Public Sub SetNextArea()
    Dim sLeft As String
    Dim sRight As String
10  sAddNameRange = sAddNameRange
20  sAddNameSheet = sAddNameSheet
30  gbDisableEvents = True
40  sLeft = Left(Me.tbxNewRefersTo, lSelStart)
50  sRight = Mid(Me.tbxNewRefersTo, lSelStart + lSelLen + 1, Len(Me.tbxNewRefersTo))
60  Me.tbxNewRefersTo.Text = sLeft & "'" & sAddNameSheet & "'!" & sAddNameRange _
                           & Application.International(xlListSeparator) & sRight
70  lSelLen = Len("'" & sAddNameSheet & "'!" & sAddNameRange) + 1
80  lSelStart = lSelStart + lSelLen
90  Me.tbxNewRefersTo.SelStart = lSelStart
100 Me.tbxNewRefersTo.SelLength = 0
110 gbDisableEvents = False
End Sub

Public Sub ActivateForm()
10  gbDisableEvents = True
20  BackInForm
30  SetActiveWindow mhwndForm
40  Me.tbxNewRefersTo.SetFocus
50  SendKeys "{tab}+{tab}"
60  DoEvents
70  gbDisableEvents = False
End Sub

Sub InitializeUF()
    Dim lCount As Long
    '
    ' form is not small size crw 10 May 2007 build 586
    '
10  gbMinimized = False

20  Set moCurrentWorkBook = ActiveWorkbook

30  SetTexts
40  With Me.cbbNames
50      .Clear
60      For lCount = 1 To GetNameTableCount()
70          .AddItem gsNames(lCount)
80      Next
90      If .ListCount > 0 Then
100         .ListIndex = glActive - 1
110     Else
120         Me.lblRefersto = ""
130     End If
140 End With
150 With Me.cbbScope
160     .Clear
170     .AddItem "Global"
180     .AddItem gsTxtufAddName(20)
190     For lCount = 1 To ActiveWorkbook.Worksheets.Count
200         .AddItem ActiveWorkbook.Worksheets(lCount).Name
210     Next
220     .ListIndex = 0
230 End With
240 Me.tbxNewName = ""
250 Me.tbxNewRefersTo = "="
260 If Val(Application.Version) > 8 Or Application.International(xlDecimalSeparator) = "." Then
        'If used with Excel 97, this seems to mess up the decimal key on the num
        'keypad for users that have a different decimal separator from the period.
270     Set mclsResizer = New CFormResizer

        'Tell it where to store the form dimensions
280     mclsResizer.RegistryKey = gsFxlNameRegKey     ''' crw 18/10/2005

        'Tell it which form it's handling
290     Set mclsResizer.Form = Me
300     If Val(Application.Version) < 9 Then
310         mhwndForm = FindWindow("ThunderXFrame", Me.Caption)    'XL97
320     Else
330         mhwndForm = FindWindow("ThunderDFrame", Me.Caption)    'XL2000
340     End If
350 End If
End Sub



Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
'
' handle resized form CRW 10 May 2007 build 586
'
10  If gbMinimized Then
20      gbDisableEvents = True
30      If lblNewName.Visible = False Then
40          BackInForm
50      End If
60      lSelStart = Me.tbxNewRefersTo.SelStart
70      lSelLen = Me.tbxNewRefersTo.SelLength
80      msNewRefersTo = Me.tbxNewRefersTo.Text
90      gbDisableEvents = False
100     gbMinimized = False
110 Else
120     cmbClose_Click
130 End If
140 Cancel = True
End Sub

Private Sub UserForm_Resize()
10  If gbDisableEvents Then Exit Sub
20  If gbMinimized Or Me.InsideHeight <= 0 Or Me.Height < 38 Then
        'Me.Height = 38
        'Me.Width = 105
30  Else
40      mclsResizer.FormResize
50  End If
End Sub

Private Sub SetTexts()
    Dim iCount As Long
10  With Me
20      .Caption = gsTxtufAddName(1)
30      .cbbNames.ControlTipText = gsTxtufAddName(2)
40      .cbxHidden.Caption = gsTxtufAddName(3)
50      .cmbAdd.Caption = gsTxtufAddName(4)
60      .cmbAdd.ControlTipText = gsTxtufAddName(5)
70      .cmbClose.Caption = gsTxtufAddName(6)
80      .cmbClose.ControlTipText = gsTxtufAddName(7)
90      .cmbCopy.Caption = gsTxtufAddName(8)
100     .cmbCopy.ControlTipText = gsTxtufAddName(9)
110     .lblExistingName.Caption = gsTxtufAddName(10)
120     .lblNewName.Caption = gsTxtufAddName(11)
130     .lblNewRefersTo.Caption = gsTxtufAddName(12)
140     .lblReferstoCaption.Caption = gsTxtufAddName(13)
150     .lblScope.Caption = gsTxtufAddName(14)
160     .tbxNewRefersTo.ControlTipText = gsTxtufAddName(15)
170     .tbxNewName.ControlTipText = gsTxtufAddName(16)
180     .cbbScope.ControlTipText = gsTxtufAddName(17)
190     .cbxHidden.ControlTipText = gsTxtufAddName(18)
200     .lblRefersto.ControlTipText = gsTxtufAddName(19)
210 End With
End Sub

Private Sub cbbNames_Change()
10  Me.lblRefersto.Caption = strGetRefersTo(FindName(Me.cbbNames.Text))
End Sub

Private Sub cmbAdd_Click()
    Dim sNewName As String
    Dim oNm As Name
    Dim sCellAddress As String
    Dim oSh As Worksheet
10  If Me.tbxNewName = "" Then Exit Sub
20  If Me.tbxNewRefersTo = "" Then Exit Sub
    'JKP 13-7-2009: first define global name, then localise
30  sNewName = Me.tbxNewName
40  If IsNameValid(sNewName, False) Then
        'JKP Build 610: If "Each sheet" is selected,
        'define a local name for each visible sheet
        'JKP bld 658: make sure alt key is released
50      Do
60          DoEvents
70      Loop Until IsAltKeyDown = False
80      If cbbScope.Text = gsTxtufAddName(20) Then
90          sCellAddress = Range(tbxNewRefersTo).Address
100         For Each oSh In ActiveWorkbook.Worksheets
110             If oSh.Visible = xlSheetVisible Then
120                 oSh.Activate
130                 RedefineAName "'" & oSh.Name & "'!" & sNewName, "='" & oSh.Name & "'!" & sCellAddress
140             End If
150         Next
160         bUpdate = True
170     Else
180         RedefineAName sNewName, Me.tbxNewRefersTo
190         On Error Resume Next
200         Set oNm = FindName(sNewName)
210         On Error GoTo 0
220         If Not oNm Is Nothing Then
230             oNm.Visible = (Me.cbxHidden = False)
240             bUpdate = True
250         End If
260         If Not oNm Is Nothing Then
                'JKP 13-7-2009: now check if name has been defined.
                'If local name, convert name to local.
270             If Me.cbbScope.Text = "Global" Then
280             Else
290                 ActiveWorkbook.Worksheets(Me.cbbScope.Text).Names.Add Name:=("'" & Me.cbbScope.Text & "'!" & sNewName), RefersToR1C1:=oNm.RefersToR1C1
                    '
                    ' CRW 9 Oct 2009 : use DeleteAName sub to handle Global/Local problems
                    '
300                 DeleteAName oNm.Name
310             End If
320         End If
330     End If
340 Else
350     MsgBox gsMsgs(83), vbOKOnly + vbCritical, gsAppName
360 End If
End Sub

Private Sub cmbClose_Click()
10  If bUpdate = False And Me.tbxNewName <> "" Then
20      If MsgBox(gsMsgs(88), vbYesNo + vbQuestion, gsAppName) = vbYes Then
30          Me.Hide
40          Set Me.NameSelectApp = Nothing
            'Set mclsResizer = Nothing
50          Application.OnTime Now, "ShowNMForm"
60          Exit Sub
70      End If
80  Else
90      Set Me.NameSelectApp = Nothing
100     Me.Hide
        'Set mclsResizer = Nothing
110     Application.OnTime Now, "ShowNMForm"
120 End If
130 Application.OnKey Application.International(xlListSeparator)
140 Application.OnKey "~"
    'JKP Build 613: Office 2010 chokes if not set to nothing!
150 Set mclsResizer = Nothing
End Sub

Private Sub tbxNewRefersTo_Change()
10  If gbDisableEvents Then Exit Sub
20  bUpdate = False
30  lSelStart = Me.tbxNewRefersTo.SelStart
40  lSelLen = Me.tbxNewRefersTo.SelLength
50  msNewRefersTo = Me.tbxNewRefersTo.Text
60  If Me.NameSelectApp Is Nothing Then
70      Set Me.NameSelectApp = Application
80      Application.OnKey Application.International(xlListSeparator), "NextArea"
90      Application.OnKey "~", "SelectAddNameForm"
100 End If
End Sub

Private Sub tbxNewRefersTo_Exit(ByVal Cancel As MSForms.ReturnBoolean)
10  Set Me.NameSelectApp = Nothing
20  Application.OnKey Application.International(xlListSeparator)
30  Application.OnKey "~"
End Sub

Private Sub tbxNewRefersTo_KeyUp(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
10  If gbDisableEvents Then Exit Sub
20  gbDisableEvents = True
30  If KeyCode = 113 Then

40  Else
50      lSelStart = Me.tbxNewRefersTo.SelStart
60      lSelLen = Me.tbxNewRefersTo.SelLength
70      msNewRefersTo = Me.tbxNewRefersTo.Text
80  End If
90  gbDisableEvents = False
End Sub

Private Sub tbxNewRefersTo_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single)
10  If gbDisableEvents Then Exit Sub
20  gbDisableEvents = True
30  If lblNewName.Visible = False Then
40      BackInForm
50  End If
60  lSelStart = Me.tbxNewRefersTo.SelStart
70  lSelLen = Me.tbxNewRefersTo.SelLength
80  msNewRefersTo = Me.tbxNewRefersTo.Text
90  gbDisableEvents = False
End Sub

Private Sub tbxNewRefersTo_Enter()
10  If gbDisableEvents Then Exit Sub
20  If Me.NameSelectApp Is Nothing Then
30      Set Me.NameSelectApp = Application
40      Application.OnKey Application.International(xlListSeparator), "NextArea"
50      Application.OnKey "~", "SelectAddNameForm"
60  End If
End Sub

Private Sub BackInForm()
'JKP build 547: restore form size
10  Application.EnableEvents = False

20  moCurrentWorkBook.Activate
30  Application.EnableEvents = True

40  If mdOldFormHeight <> 0 Then
50      Me.Height = mdOldFormHeight
60  End If
70  If mdOldFormWidth <> 0 Then
80      Me.Width = mdOldFormWidth
90  End If
100 If mdOldtbxLeft <> 0 Then
110     tbxNewRefersTo.Left = mdOldtbxLeft
120 End If
130 If mdOldtbxTop <> 0 Then
140     tbxNewRefersTo.Top = mdOldtbxTop
150 End If
160 lblNewName.Visible = True
170 lblNewRefersTo.Visible = True
180 tbxNewName.Visible = True
190 If Me.NameSelectApp Is Nothing Then Stop
End Sub


Attribute VB_Name = "ufAnalyse"
Attribute VB_Base = "0{DEA0BFD5-D788-4B8D-BDD7-DAA45B261DAD}{25F938CE-900E-4A35-951F-4BA4FF6D617A}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Dim sPart As String
Dim oParent As Worksheet
Private Sub cbbNames_Change()
    Dim oName As Name
10  Set oName = FindName(Me.cbbNames.Value)
20  Set oParent = Nothing
30  If Not oName Is Nothing Then
40      Me.tbxRefersTo = oName.RefersToLocal
        '
        ' crw 20/2/2005
        ' set oparent to the parent worksheet of a local name, or nothing
        '
50      If IsNameLocal(oName.Name, False) Then        '''crw 20/2/2005

60          Set oParent = oName.Parent
70      End If
80  Else
90      Me.tbxRefersTo = ""
100 End If
End Sub

Private Sub cmbReset_Click()
    Dim oName As Name
10  With Me
20      Set oName = FindName(.cbbNames.Value)
30      Set oParent = Nothing
40      If Not oName Is Nothing Then
50          Me.tbxRefersTo = oName.RefersToLocal
            '
            ' crw 20/2/2005
            ' set oparent to the parent worksheet of a local name, or nothing
            '
60          If IsNameLocal(oName.Name, False) Then    '''crw 20/2/2005

70              Set oParent = oName.Parent
80          End If
90      Else
100         Me.tbxRefersTo = ""
110     End If
120 End With
End Sub

Private Sub cmdClose_Click()
10  Set oParent = Nothing
20  Unload Me
30  Set gfrmAnalyse = Nothing
End Sub

Private Sub cmdEvalPart_Click()
    Dim sResult As String
    Dim sWhole As String
10  With Me.tbxRefersTo
20      sWhole = .Text
30      sPart = Mid(.Text, .SelStart + 1, .SelLength)
40      If sPart = "" Then
50          ShowMsg gsMsgs(68), vbInformation + vbOKOnly
60      Else
70          sResult = funTryToAnalyse(sPart, True, oParent)
80          If sResult <> "" Then
90              .Text = Replace5(sWhole, sPart, sResult)
100         End If
110     End If
120 End With
End Sub

Sub Initialise()
    Dim oName As Name
    '
    ' CRW 27 April 2014 Tables
    '
10  SetTexts
20  With Me
30      For Each oName In ActiveWorkbook.Names
40          .cbbNames.AddItem FindName(oName.Name).Name
50      Next
60      .cbbNames.Value = gsNames(glActive)
70      .tbxRefersTo.Value = gsRefersto(glActive)
80      Set oName = FindName(.cbbNames.Value)
90      Set oParent = Nothing
        '
        ' crw 20/2/2005
        ' set oparent to the parent worksheet of a local name, or nothing
        '
100     If Not oName Is Nothing Then
110         If IsNameLocal(oName.Name, False) Then        '''crw 20/2/2005
120             Set oParent = oName.Parent
130         End If
140     End If
150     If gbMacOS Then
160         On Error Resume Next
170         For Each gctlLocalControl In Controls
180             With gctlLocalControl
190                 .Font.Size = 10
200                 .Font.Name = "Geneva"
210             End With
220         Next
230         On Error GoTo 0

240         If gbMacX = False Then
250             .cbbNames.Move 84, 6, 186, 21
260             .cmbReset.Move 150, 176, 56, 26
270             .cmdClose.Move 216, 176, 56, 26
280             .cmdEvalPart.Move 6, 176, 56, 26
290             .cmdExpand.Move 66, 176, 56, 26
300             .lblAnalysing.Move 9, 8, 78, 12
310             .tbxRefersTo.Move 6, 40, 264, 130
320         Else
330             .Width = 277
340             .Height = 235
350             .cbbNames.Move 84, 6, 186, 21
360             .cmbReset.Move 144, 180, 59, 22
370             .cmdClose.Move 212, 180, 59, 22
380             .cmdEvalPart.Move 6, 180, 59, 22
390             .cmdExpand.Move 74, 180, 59, 22
400             .lblAnalysing.Move 10, 9, 78, 12
410             .tbxRefersTo.Move 6, 37, 264, 130
420         End If
430     End If
440 End With
End Sub

Private Sub cmdExpand_Click()
    Dim sResult As String
10  With Me.tbxRefersTo
20      sResult = funExpand(.Text, oParent)
30      If sResult <> "" Then
40          .Text = sResult
50      End If
60  End With
End Sub

Private Sub SetTexts()
10  With Me
20      .Caption = gsTxtufAnalyse(1)
30      .cmdClose.Caption = gsTxtufAnalyse(2)
40      .cmdClose.ControlTipText = gsTxtufAnalyse(3)
50      .tbxRefersTo.ControlTipText = gsTxtufAnalyse(6)
60      .cmdEvalPart.Caption = gsTxtufAnalyse(7)
70      .cmdEvalPart.ControlTipText = gsTxtufAnalyse(8)
80      .cmdExpand.Caption = gsTxtufAnalyse(9)
90      .cmdExpand.ControlTipText = gsTxtufAnalyse(10)
100     .cmbReset.Caption = gsTxtufAnalyse(11)
110     .cmbReset.ControlTipText = gsTxtufAnalyse(12)
120     .lblAnalysing.Caption = gsTxtufAnalyse(13)
130 End With
End Sub


Attribute VB_Name = "ufDynWizStep14"
Attribute VB_Base = "0{839DB7CA-1E68-4D8F-988E-2AD8AA51CE9D}{B4318D6B-215C-41BD-8E45-649C69157921}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Option Base 0
Option Compare Text
' FXLV3 - uses version 2 of counting functions
' option to use INDEX or OFFSET
'--------------------------------------------------------------------
Dim lPageSeq(4) As Long                               ''' array of page sequence numbers
Dim strAnchorRef As String                            ''' step2 (anchor) refedit text
Dim strAnchorCell As String
Dim strOldAnchorRef As String                         ''' actual refedit content
Dim strRowRef As String                               ''' step 3 (row) refedit text
Dim strOldRowRef As String
Dim strColRef As String                               ''' step4 (column) refedit text
Dim strOldColRef As String
Dim jFirstrow As Long                                 ''' first row number from anchor
Dim jFirstCol As Long                                 ''' first col number from anchor
Dim jLastRow As Long                                  ''' last row from anchor
Dim jLastCol As Long                                  ''' last col from anchor
Const strValidchars As String = ".?\_0123456789a|fffd||fffd||fffd||fffd||fffd||fffd||fffd|bc|fffd|d|fffd|e|fffd||fffd||fffd||fffd|f|fffd|ghi|fffd||fffd||fffd||fffd|jklmn|fffd|o|fffd||fffd||fffd||fffd||fffd||fffd||fffd|pqrs|fffd||fffd|t|fffd|u|fffd||fffd||fffd||fffd|vwxy|fffd||fffd|z|fffd|"    'JKP Feb 6 2003 Valid characters for names
Dim oAnchor As Range                                  ''' anchor cell for dynamic range
Dim oRowref As Range                                  ''' row reference
Dim oColref As Range                                  ''' column reference
Dim jPageWiz As Long                                  ''' step number -1 or wizards
Dim varDynWizTexts As Variant
Private Sub butBack_Click()
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2003. All rights reserved
'
' Back button
'
10  Me.butNext.Caption = "Next >>"
20  jPageWiz = jPageWiz - 1
30  Me.MultiWiz14.Value = lPageSeq(jPageWiz)
40  CheckRefEditVisible
    'Me.Caption = "FastExcel Dynamic Range Wizard - Step " & CStr(jPageWiz + 1) & " of 5"
50  Me.Caption = ReworkMsg(GetLangString(2, varDynWizTexts), CStr(jPageWiz + 1))
60  If jPageWiz = 0 Then
        '
        ' step 1
        '
70      Me.butBack.Enabled = False
80  ElseIf jPageWiz = 1 Then
        '
        ' step 2
        '
90      If Me.RefEdit1.Visible Then
100         strOldRowRef = Me.RefEdit1.Text
110         strRowRef = Trim(Me.RefEdit1.Text)
120         If Len(strRowRef) > 0 And Application.ReferenceStyle = xlR1C1 Then
130             strRowRef = ConvertReftoA1(strRowRef, True)
140         End If
150     End If

160     If Me.optRows Then
            '
            ' cols are fixed: single or multiple
            '
            'Me.lblStep2Expand.Caption = "You have chosen to expand the range by rows and to keep the columns fixed."
170         Me.lblStep2Expand.Caption = GetLangString(3, varDynWizTexts)
            'Me.lblStep2select.Caption = "Also select any additional fixed columns to be included in the dynamic range. The additional fixed columns must be selected in the same row as the anchor cell."
180         Me.lblStep2select.Caption = GetLangString(4, varDynWizTexts)
190     ElseIf Me.optCols Then
            '
            ' rows are fixed
            '
            'Me.lblStep2Expand.Caption = "You have chosen to expand the range by columns and to keep the rows fixed."
200         Me.lblStep2Expand.Caption = GetLangString(5, varDynWizTexts)
            'Me.lblStep2select.Caption = "Also select any additional fixed rows to be included in the dynamic range. The additional fixed rows must be selected in the same column as the anchor cell."
210         Me.lblStep2select.Caption = GetLangString(6, varDynWizTexts)
220     Else
            '
            ' both
            '
            'Me.lblStep2Expand.Caption = "You have chosen to expand the range by both rows and columns."
230         Me.lblStep2Expand.Caption = GetLangString(7, varDynWizTexts)
240         Me.lblStep2select.Caption = ""
250     End If
        '
260     If Not IsEmpty(strOldAnchorRef) And Len(strOldAnchorRef) > 0 Then
270         Me.RefEdit1 = strOldAnchorRef
280     Else
290         Me.RefEdit1 = ActiveCell.Address
300     End If
310     Me.RefEdit1.SetFocus
320 ElseIf jPageWiz = 2 Then
        '
        ' step 3
        '
330     If Me.RefEdit1.Visible Then
340         strOldColRef = Me.RefEdit1.Text
350         strColRef = Trim(Me.RefEdit1.Text)
360         If Len(strColRef) > 0 And Application.ReferenceStyle = xlR1C1 Then
370             strColRef = ConvertReftoA1(strColRef, True)
380         End If
390     End If
400     If Not IsEmpty(strOldRowRef) Then
410         Me.RefEdit1 = strOldRowRef
420     Else
430         Me.RefEdit1 = ""
440     End If
450     If Me.optSelCellRow Then Me.RefEdit1.SetFocus
460     If Me.optCols Then
            'Me.lblStep3Anchormsg.Caption = "You have selected " & CStr(jLastRow - jFirstrow + 1) & " fixed rows and your anchor is:"
470         Me.lblStep3Anchormsg.Caption = ReworkMsg(GetLangString(8, varDynWizTexts), CStr(jLastRow - jFirstrow + 1))
480         Me.lblAnchorCol.Caption = strAnchorRef
            '
490     End If
500     If (Me.optLastRow Or Me.optLastContigRow) And Me.optRows Then
510         Me.frameStep3a.Visible = True
520     Else
530         Me.frameStep3a.Visible = False
540     End If
550 ElseIf jPageWiz = 3 Then
        '
        ' step 4
        '
560     If Not IsEmpty(strOldColRef) Then
570         Me.RefEdit1 = strOldColRef
580     Else
590         Me.RefEdit1 = ""
600     End If
610     If Me.optSelCellCol Then Me.RefEdit1.SetFocus
620     If Me.optRows Then
            '
            ' cols are fixed
            '
            'Me.lblStep4AnchorMsg.Caption = "You have selected " & CStr(jLastCol - jFirstCol + 1) & " fixed columns and your anchor is:"
630         Me.lblStep4AnchorMsg.Caption = ReworkMsg(GetLangString(9, varDynWizTexts), CStr(jLastCol - jFirstCol + 1))
640         Me.lblAnchorRow.Caption = strAnchorRef
650     End If
660     If Me.optCols And (Me.optLastCol Or Me.optLastContigCol) Then
670         Me.frameStep4a.Visible = True
680     Else
690         Me.frameStep4a.Visible = False
700     End If
710 End If
End Sub

Private Sub butCan_Click()
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2003. All rights reserved
'
' cancel button: cleanup
'
10  Me.MultiWiz14.Value = 1
20  jPageWiz = 0
30  Set oAnchor = Nothing
40  Set oRowref = Nothing
50  Set oColref = Nothing
60  Unload Me
End Sub

Private Sub butHelp_Click()
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2003. All rights reserved
'
10  Select Case jPageWiz
    Case 0
20      ShowHelp 4, ThisWorkbook.Path & "\FastExcelV3.chm", 926
30  Case 1
40      ShowHelp 4, ThisWorkbook.Path & "\FastExcelV3.chm", 927
50  Case 2
60      ShowHelp 4, ThisWorkbook.Path & "\FastExcelV3.chm", 928
70  Case 3
80      ShowHelp 4, ThisWorkbook.Path & "\FastExcelV3.chm", 937
90  Case 4
100     ShowHelp 4, ThisWorkbook.Path & "\FastExcelV3.chm", 946
110 End Select
End Sub

Private Sub butNext_Click()
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2003. All rights reserved
'
' major action routine for wizard
'
    Dim jError As Long                                ''' 0=OK, 1=Exit, 2=reuse name
    Dim strRefersTo As String
    Dim strFinish As String
    Dim iMsg As Long
10  Me.butBack.Enabled = True
20  Select Case jPageWiz
    Case 4
        '
        ' exit step 5
        '
30      If Len(Me.tbxName) = 0 Then
            'MsgBox "Please enter a Name for the dynamic range", vbOKOnly + vbExclamation, gsAppName
40          MsgBox GetLangString(10, varDynWizTexts), vbOKOnly + vbExclamation, gsAppName
50          GoTo GoExit
60      Else
70          jError = CheckValidName(Me.tbxName)
80          If jError = 1 Then GoTo GoExit
            '
            ' construct string
            '
90          If Me.optOffset Then
100             BuildOffsetRefersTo strRefersTo
110         Else
120             BuildIndexRefersTo strRefersTo
130         End If
140         If strRefersTo = "" Then GoTo GoExit
            '
            ' insert/replace name
            '
150         On Error GoTo insertfail
160         If jError = 2 Then
170             ActiveWorkbook.Names(Trim(Me.tbxName)).RefersTo = strRefersTo
180         Else
190             ActiveWorkbook.Names.Add Name:=Trim(Me.tbxName), RefersTo:=strRefersTo
200         End If
            '
            ' finish
            '
            'strFinish = "You have successfully created the Dynamic Range name '" & Me.tbxName & "' :" & vbCrLf
210         strFinish = ReworkMsg(GetLangString(11, varDynWizTexts), Me.tbxName) & vbCrLf
            ' anchor
220         strFinish = strFinish & ReworkMsg(GetLangString(12, varDynWizTexts), strAnchorRef) & vbCrLf
230         If Me.optRows Then
                '- Dynamic row expansion with_ARG3_ fixed column(s)
240             strFinish = strFinish & ReworkMsg(GetLangString(13, varDynWizTexts), CStr(jLastCol - jFirstCol + 1)) & vbCrLf
250         ElseIf Me.optCols Then
                'strFinish = strFinish & " - Dynamic column expansion with " & CStr(jLastRow - jFirstrow + 1) & " fixed row(s), " & vbCrLf
260             strFinish = strFinish & ReworkMsg(GetLangString(14, varDynWizTexts), CStr(jLastRow - jFirstrow + 1)) & vbCrLf
270         Else
                'strFinish = strFinish & " - Dynamic row and column expansion"
280             strFinish = strFinish & GetLangString(15, varDynWizTexts)
290         End If
            '                strFinish = strFinish & vbCrLf & vbCrLf & "Create another Dynamic range Name?"
            '                iMsg = MsgBox(strFinish, vbQuestion + vbYesNo, gsAppName)
300         iMsg = MsgBox(strFinish, vbInformation + vbOKOnly, gsAppName)
310         jPageWiz = 0
320         Me.MultiWiz14.Value = 0
330         Set oAnchor = Nothing
340         Set oRowref = Nothing
350         Set oColref = Nothing
360         Me.butBack.Enabled = False
            'Me.butNext.Caption = "Next >>"
370         Me.butNext.Caption = GetLangString(29, varDynWizTexts)
            'Me.Caption = "FastExcel Dynamic Range Wizard - Step 1" & " of 5"
380         Me.Caption = ReworkMsg(GetLangString(2, varDynWizTexts), CStr(1))
390         CheckRefEditVisible
            'If iMsg = vbNo Then Unload Me
400         Unload Me
410     End If
420 Case 3
        '
        ' exit step 4
        '
430     If Me.RefEdit1.Visible Then
440         strOldColRef = Me.RefEdit1.Text
450         strColRef = Trim(Me.RefEdit1.Text)
460         If Len(strColRef) > 0 And Application.ReferenceStyle = xlR1C1 Then
470             strColRef = ConvertReftoA1(strColRef, True)
480         End If
490         On Error Resume Next
500         Set oColref = Nothing
510         Set oColref = Range(strColRef).Cells(1, 1)
520         If oColref Is Nothing Or Err <> 0 Then
530             On Error GoTo 0
                'MsgBox "Please select a valid cell in this workbook containing the number of columns", vbExclamation + vbOKOnly, gsAppName
540             MsgBox GetLangString(17, varDynWizTexts), vbExclamation + vbOKOnly, gsAppName

550             GoTo GoExit
560         Else
570             On Error GoTo 0
580         End If
590     Else
600         strColRef = ""
610     End If
        'Me.Caption = "FastExcel Dynamic Range Wizard - Step 5" & " of 5"

620     jPageWiz = jPageWiz + 1
630     CheckRefEditVisible
640     Me.MultiWiz14.Value = lPageSeq(jPageWiz)
        'Me.butNext.Caption = "Finish"
650     Me.butNext.Caption = GetLangString(30, varDynWizTexts)
660     Me.tbxName.SetFocus
670 Case 2
        '
        ' exit step 3
        '
        ' check rowref
        '
680     If Me.RefEdit1.Visible Then
690         strOldRowRef = Me.RefEdit1.Text
700         strRowRef = Trim(Me.RefEdit1.Text)
710         If Len(strRowRef) > 0 And Application.ReferenceStyle = xlR1C1 Then
720             strRowRef = ConvertReftoA1(strRowRef, True)
730         End If
740         On Error Resume Next
750         Set oRowref = Nothing
760         Set oRowref = Range(strRowRef).Cells(1, 1)
770         If oRowref Is Nothing Or Err <> 0 Then
780             On Error GoTo 0
                'MsgBox "Please select a valid cell in this workbook containing the number of rows", vbExclamation + vbOKOnly, gsAppName
790             MsgBox GetLangString(16, varDynWizTexts), vbExclamation + vbOKOnly, gsAppName
800             GoTo GoExit
810         Else
820             On Error GoTo 0
830         End If
840     Else
850         strRowRef = ""
860     End If
        '
        'Me.Caption = "FastExcel Dynamic Range Wizard - Step 4" & " of 5"
870     Me.Caption = ReworkMsg(GetLangString(2, varDynWizTexts), CStr(4))
880     If Me.optCols And (Me.optLastCol Or Me.optLastContigCol) Then
890         Me.frameStep4a.Visible = True
900     Else
910         Me.frameStep4a.Visible = False
920     End If
930     jPageWiz = jPageWiz + 1
940     CheckRefEditVisible
950     If Not IsEmpty(strOldColRef) Then
960         Me.RefEdit1 = strOldColRef
970     Else
980         Me.RefEdit1 = ""
990     End If
1000    If Me.optSelCellCol Then Me.RefEdit1.SetFocus
1010    Me.MultiWiz14.Value = lPageSeq(jPageWiz)
        'Me.butNext.Caption = "Next >>"
1020    Me.butNext.Caption = GetLangString(29, varDynWizTexts)
1030    If Me.optRows Then
            '
            ' cols are fixed
            '
            'Me.lblStep4AnchorMsg.Caption = "You have selected " & CStr(jLastCol - jFirstCol + 1) & " fixed columns and your anchor is:"
1040        Me.lblStep4AnchorMsg.Caption = ReworkMsg(GetLangString(9, varDynWizTexts), CStr(jLastCol - jFirstCol + 1))
1050        Me.lblAnchorRow.Caption = strAnchorRef
1060    End If
1070 Case 1
        '
        ' exit step 2
        '
        ' check anchor cell
        '
1080    On Error Resume Next
1090    Set oAnchor = Nothing
1100    jFirstrow = 0
1110    jFirstCol = 0
1120    strOldAnchorRef = Me.RefEdit1.Text
1130    strAnchorRef = Trim(Me.RefEdit1.Text)
1140    If Len(strAnchorRef) > 0 And Application.ReferenceStyle = xlR1C1 Then
1150        strAnchorRef = ConvertReftoA1(strAnchorRef, True)
1160    End If
1170    Set oAnchor = Range(strAnchorRef)
1180    If oAnchor Is Nothing Or Err <> 0 Then
1190        On Error GoTo 0
            'MsgBox "Please select a valid Anchor cell in this workbook.", vbExclamation + vbOKOnly, gsAppName
1200        MsgBox GetLangString(18, varDynWizTexts), vbExclamation + vbOKOnly, gsAppName

1210        GoTo GoExit
1220    Else
1230        On Error GoTo 0
1240        jFirstrow = oAnchor.Row
1250        jFirstCol = oAnchor.Column
1260        jLastRow = jFirstrow + oAnchor.Rows.Count - 1
1270        jLastCol = jFirstCol + oAnchor.Columns.Count - 1
1280        If Me.optBoth And (jLastRow > jFirstrow Or jLastCol > jFirstCol) Then
                'MsgBox "You have chosen to expand by both rows and columns." & vbCrLf & "But your selected anchor contains more than one cell." & vbCrLf & vbCrLf & "Please select a single cell.", vbOKOnly + vbExclamation, gsAppName
1290            MsgBox GetLangString(19, varDynWizTexts), vbExclamation + vbOKOnly, gsAppName
1300            Me.RefEdit1.SetFocus
1310            GoTo GoExit
1320        End If
1330        If Me.optRows And jLastRow > jFirstrow Then
                'MsgBox "You have chosen to expand by rows." & vbCrLf & "But your selected anchor contains more than one row." & vbCrLf & vbCrLf & "Please select cell(s) in a single row.", vbOKOnly + vbExclamation, gsAppName
1340            MsgBox GetLangString(20, varDynWizTexts), vbExclamation + vbOKOnly, gsAppName
1350            Me.RefEdit1.SetFocus
1360            GoTo GoExit
1370        End If
1380        If Me.optCols And jLastCol > jFirstCol Then
                'MsgBox "You have chosen to expand by columns." & vbCrLf & "But your selected anchor contains more than one column." & vbCrLf & vbCrLf & "Please select cell(s) in a single column.", vbOKOnly + vbExclamation, gsAppName
1390            MsgBox GetLangString(21, varDynWizTexts), vbExclamation + vbOKOnly, gsAppName
1400            Me.RefEdit1.SetFocus
1410            GoTo GoExit
1420        End If
1430        strAnchorCell = oAnchor.Cells(1, 1).Address
1440        If InStr(strAnchorCell, "!") = 0 Then
1450            strAnchorCell = "'" & oAnchor.Parent.Name & "'!" & strAnchorCell
1460        End If
            '                On Error Resume Next
            '                If Application.ReferenceStyle = xlR1C1 Then
            '                    strAnchorCell = ConvertReftoA1(strAnchorCell, True)
            '                End If
            '                On Error GoTo 0
1470        SetPageSeq
1480        jPageWiz = jPageWiz + 1
1490        Me.MultiWiz14.Value = lPageSeq(jPageWiz)
1500        CheckRefEditVisible
            'Me.Caption = "FastExcel Dynamic Range Wizard - Step 3" & " of 5"
1510        Me.Caption = ReworkMsg(GetLangString(2, varDynWizTexts), CStr(3))
            ' Me.butNext.Caption = "Next >>"
1520        Me.butNext.Caption = GetLangString(29, varDynWizTexts)
1530        If Me.optRows And (Me.optLastRow Or Me.optLastContigRow) Then
1540            Me.frameStep3a.Visible = True
1550        Else
1560            Me.frameStep3a.Visible = False
1570        End If
            '
1580        If Not IsEmpty(strOldRowRef) And Len(strOldRowRef) > 0 Then
1590            Me.RefEdit1 = strOldRowRef
1600        Else
1610            Me.RefEdit1 = ""
1620        End If
1630        If Me.optSelCellRow Then Me.RefEdit1.SetFocus
1640        If Me.optCols Then
                'Me.lblStep3Anchormsg.Caption = "You have selected " & CStr(jLastRow - jFirstrow + 1) & " fixed rows and your anchor is:"
1650            Me.lblStep3Anchormsg.Caption = ReworkMsg(GetLangString(8, varDynWizTexts), CStr(jLastRow - jFirstrow + 1))
1660            Me.lblAnchorCol.Caption = strAnchorRef
                '
1670        End If
1680    End If
1690 Case 0
        '
        ' exit step 1
        '
1700    SetPageSeq
1710    jPageWiz = jPageWiz + 1
1720    Me.MultiWiz14.Value = lPageSeq(jPageWiz)
        'Me.Caption = "FastExcel Dynamic Range Wizard - Step 2" & " of 5"
1730    Me.Caption = ReworkMsg(GetLangString(2, varDynWizTexts), CStr(2))
1740    Me.butBack.Enabled = True
        'Me.butNext.Caption = "Next >>"
1750    Me.butNext.Caption = GetLangString(29, varDynWizTexts)
1760    CheckRefEditVisible
        '
1770    If Me.optRows Then
            '
            ' cols are fixed: single or multiple
            '
            'Me.lblStep2Expand.Caption = "You have chosen to expand the range by rows and to keep the columns fixed."
1780        Me.lblStep2Expand.Caption = GetLangString(3, varDynWizTexts)
            'Me.lblStep2select.Caption = "Also select any additional fixed columns to be included in the dynamic range. The additional fixed columns must be selected in the same row as the anchor cell."
1790        Me.lblStep2select.Caption = GetLangString(4, varDynWizTexts)
1800        Me.frameStep3a.Visible = True
1810    ElseIf Me.optCols Then
            '
            ' rows are fixed
            '
            'Me.lblStep2Expand.Caption = "You have chosen to expand the range by columns and to keep the rows fixed."
1820        Me.lblStep2Expand.Caption = GetLangString(5, varDynWizTexts)
            'Me.lblStep2select.Caption = "Also select any additional fixed rows to be included in the dynamic range. The additional fixed rows must be selected in the same column as the anchor cell."
1830        Me.lblStep2select.Caption = GetLangString(6, varDynWizTexts)
1840        Me.frameStep3a.Visible = False
1850    Else
            '
            ' both
            '
            'Me.lblStep2Expand.Caption = "You have chosen to expand the range by both rows and columns."
1860        Me.lblStep2Expand.Caption = GetLangString(7, varDynWizTexts)
1870        Me.lblStep2select.Caption = ""
1880        Me.frameStep3a.Visible = False
1890    End If
        '
        ' setup refedit for anchor
        '
1900    If Not IsEmpty(strOldAnchorRef) And Len(strOldAnchorRef) > 0 Then
1910        Me.RefEdit1 = strOldAnchorRef
1920    Else
            '
            ' handle r1c1 crw 17/10/2005
            '
1930        Me.RefEdit1 = ActiveCell.Address(ReferenceStyle:=Application.ReferenceStyle)

1940    End If
1950    Me.RefEdit1.SetFocus
1960 End Select
1970 Exit Sub
insertfail:
1980 On Error GoTo 0
    'MsgBox "Unable to create Dynamic Range name " & Me.tbxName & " " & strRefersto, vbOKOnly + vbCritical, gsAppName
1990 MsgBox ReworkMsg(GetLangString(22, varDynWizTexts), Me.tbxName, strRefersTo), vbOKOnly + vbCritical, gsAppName
GoExit:
2000 Set oAnchor = Nothing
2010 Set oRowref = Nothing
2020 Set oColref = Nothing
End Sub
Private Sub CheckRefEditVisible()
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2003. All rights reserved
'
' sets the visible property of the refedit control
'
10  Me.RefEdit1.Visible = False
20  If (jPageWiz = 1) Or _
       (jPageWiz = 2 And optSelCellRow) Or _
       (jPageWiz = 3 And optSelCellCol) Then
30      Me.RefEdit1.Visible = True
40  End If
End Sub
Private Sub SetPageSeq()
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2003. All rights reserved
'
' controls which pages of the control are shown
'
'
' optrows sequence
'
10  lPageSeq(0) = 0
20  lPageSeq(1) = 1
30  lPageSeq(2) = 2
40  lPageSeq(3) = 5
50  lPageSeq(4) = 6
60  If Me.optCols Then
        '
        ' optcols changes
        '
70      lPageSeq(2) = 3
80      lPageSeq(3) = 4
90  End If
100 If Me.optBoth Then
        '
        ' optboth changes
        '
110     lPageSeq(2) = 2
120     lPageSeq(3) = 4
130 End If
End Sub



Private Sub optColsAll_Click()
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2003. All rights reserved
'
10  Me.RefEdit1.Visible = False
End Sub

Private Sub optColsAnchor_Click()
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2003. All rights reserved
'
10  Me.RefEdit1.Visible = False
End Sub

Private Sub optCountaCols_Click()
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2003. All rights reserved
'
10  Me.RefEdit1.Visible = False
20  Me.frameStep4a.Visible = False
End Sub

Private Sub optCountaRows_Click()
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2003. All rights reserved
'
10  Me.RefEdit1.Visible = False
20  Me.frameStep3a.Visible = False
End Sub

Private Sub optlastCol_Click()
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2003. All rights reserved
'
10  Me.RefEdit1.Visible = False
20  Me.frameStep4a.Visible = True
End Sub

Private Sub optlastContigCol_Click()
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2003. All rights reserved
'
10  Me.RefEdit1.Visible = False
20  Me.frameStep4a.Visible = True
End Sub

Private Sub optLastContigRow_Click()
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2003. All rights reserved
'
10  Me.RefEdit1.Visible = False
20  Me.frameStep3a.Visible = True
End Sub

Private Sub optLastRow_Click()
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2003. All rights reserved
'
10  Me.RefEdit1.Visible = False
20  Me.frameStep3a.Visible = True
End Sub

Private Sub optRowsAll_Click()
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2003. All rights reserved
'
10  Me.RefEdit1.Visible = False
End Sub

Private Sub optRowsAnchor_Click()
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2003. All rights reserved
'
10  Me.RefEdit1.Visible = False
End Sub

Private Sub optSelCellCol_Click()
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2003. All rights reserved
'
10  Me.RefEdit1.Visible = True
20  Me.RefEdit1.SetFocus
30  Me.frameStep4a.Visible = False
End Sub

Private Sub optSelCellRow_Click()
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2003. All rights reserved
'
10  Me.RefEdit1.Visible = True
20  Me.RefEdit1.SetFocus
30  Me.frameStep3a.Visible = False
End Sub

Private Sub optUsedCol_Click()
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2003. All rights reserved
'
10  Me.RefEdit1.Visible = False
20  Me.frameStep4a.Visible = False
End Sub

Private Sub optUsedRow_Click()
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2003. All rights reserved
'
10  Me.RefEdit1.Visible = False
20  Me.frameStep3a.Visible = False
End Sub

Private Sub UserForm_Initialize()
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2003. All rights reserved
'
10  jPageWiz = 0
20  Me.tbxName = ""
30  Set oAnchor = Nothing
40  Set oRowref = Nothing
50  Set oColref = Nothing
60  Me.RefEdit1.Visible = False
70  GetLangTexts "ufDynWizStep14", varDynWizTexts
End Sub
Private Function CheckValidName(strInputName As String) As Long
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2003. All rights reserved
'
' checks that the name of a name is valid
'
' returns
' 0=OK
' 1=error
' 2= Ok but replace
'
' mod crw 10 June 2014 : use characters from dialog text box, use lower case and binary compare
'
    Dim j As Long
    Dim vAnsa As Variant
    Dim oNm As Name
    Dim lenName As Long
    Dim strName As String

10  strName = Trim(strInputName)
20  lenName = Len(strName)
30  strName = LCase(strName)

40  If IsEmpty(gsValidChars) Then gsValidChars = GetValidCharlist

    '
    ' starts with number?
    '
50  CheckValidName = 0                                ''' ok
60  If Not Left(strName, 1) Like "[a-z]" Then
70      CheckValidName = 1
        'MsgBox "Name " & strName & " must start with a letter", vbExclamation + vbOKOnly, gsAppName
80      MsgBox ReworkMsg(GetLangString(23, varDynWizTexts), strName), vbExclamation + vbOKOnly, gsAppName

90      Exit Function
100 End If
    '
    ' contains invalid character?
    '
110 For j = 1 To lenName
120     If InStr(1, gsValidChars, Mid$(strName, j, 1), vbBinaryCompare) = 0 Then
130         CheckValidName = 1
            'MsgBox "Name " & strName & " contains invalid characters", vbExclamation + vbOKOnly, gsAppName
140         MsgBox ReworkMsg(GetLangString(24, varDynWizTexts), strName), vbExclamation + vbOKOnly, gsAppName
150         Exit For
160     End If
170 Next j
    '
    ' looks like a range ?
    '
180 If lenName > 1 Then
        '
        ' [a-z] followed by numbers
        '
190     If IsNumeric(Right(strName, lenName - 1)) Then CheckValidName = 1
200 End If
210 If lenName > 2 Then
        '
        ' [a-i][a-v] followed by numbers
        '
220     If Left(strName, 2) Like "[a-i][a-v]" And IsNumeric(Right(strName, lenName - 2)) Then CheckValidName = 1
230 End If
    '
    ' check for RC type names:
    ' strip out all R and C and if whats left is numeric
    '
240 On Error Resume Next
250 If InStr(strName, "R") > 0 Then strName = Application.Substitute(strName, "R", "")
260 If InStr(strName, "C") > 0 Then strName = Application.Substitute(strName, "C", "")
270 If IsNumeric(strName) Or Len(strName) = 0 Then CheckValidName = 1
280 On Error GoTo 0
290 If CheckValidName = 1 Then
        'MsgBox "Name " & strInputName & " cannot look like a cell reference", vbExclamation + vbOKOnly, gsAppName
300     MsgBox ReworkMsg(GetLangString(25, varDynWizTexts), strInputName), vbExclamation + vbOKOnly, gsAppName

310     Exit Function
320 End If
    '
    ' already exists ?
    '
330 On Error Resume Next
340 Set oNm = ActiveWorkbook.Names(strName)
350 If Not oNm Is Nothing Then
        'vAnsa = MsgBox("Name '" & strName & "' already exists: Overwrite?", vbExclamation + vbYesNo, gsAppName)
360     vAnsa = MsgBox(ReworkMsg(GetLangString(26, varDynWizTexts), strName), vbExclamation + vbYesNo, gsAppName)

370     If vAnsa = vbYes Then
380         CheckValidName = 2
390     Else
400         CheckValidName = 1
410     End If
420 End If
430 Set oNm = Nothing
440 On Error GoTo 0
End Function
Private Sub BuildOffsetRefersTo(strRefersTo As String)
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2003. All rights reserved
'
'
' build expression of type
'
' =OFFSET(anchorcell,0,0,dynrownum,dyncolnum)
'
' assumes everything is in a1 style
'
10  strRefersTo = "=OFFSET(" & strAnchorCell & ",0,0,"
    '
    ' rows
    '
20  If Me.optCols Then
        '
        ' not dynamic rows
        '
30      If jFirstrow = jLastRow Then
40          strRefersTo = strRefersTo & "1,"
50      Else
60          If jLastRow < jFirstrow Then
70              strRefersTo = ""
                'MsgBox "Last row number " & CStr(jLastRow) & " in dynamic range is before first row number " & CStr(jFirstrow), vbOKOnly + vbCritical, gsAppName
80              MsgBox ReworkMsg(GetLangString(27, varDynWizTexts), CStr(jLastRow), CStr(jFirstrow)), vbOKOnly + vbCritical, gsAppName

90              Exit Sub
100         Else
110             strRefersTo = strRefersTo & CStr(jLastRow - jFirstrow + 1) & ","
120         End If
130     End If
140 Else
        '
        ' dynamic rows
        '
150     If Me.optLastRow Then
160         If Me.optRowsAnchor Then
170             strRefersTo = strRefersTo & "COUNTROWS2(" & strAnchorCell & "),"
180         Else
190             strRefersTo = strRefersTo & "COUNTROWS2(" & strAnchorRef & "),"
200         End If
210     ElseIf Me.optLastContigRow Then
220         If Me.optRowsAnchor Then
230             strRefersTo = strRefersTo & "COUNTCONTIGROWS2(" & strAnchorCell & "),"
240         Else
250             strRefersTo = strRefersTo & "COUNTCONTIGROWS2(" & strAnchorRef & "),"
260         End If
270     ElseIf Me.optUsedRow Then
280         strRefersTo = strRefersTo & "COUNTUSEDROWS2(" & strAnchorCell & "),"
290     ElseIf Me.optCountaRows Then
300         If jLastRow < jFirstrow Then
310             strRefersTo = ""
                'MsgBox "Last row number " & CStr(jLastRow) & " in dynamic range is before first row number " & CStr(jFirstrow), vbOKOnly + vbCritical, gsAppName
320             MsgBox ReworkMsg(GetLangString(27, varDynWizTexts), CStr(jLastRow), CStr(jFirstrow)), vbOKOnly + vbCritical, gsAppName

330             Exit Sub
340         Else
350             If jLastRow > jFirstrow Then
360                 strRefersTo = strRefersTo & "COUNTA($" & strColid(jFirstCol) & "$" & CStr(jFirstrow) & ":$" & strColid(jFirstCol) & "$" & CStr(jLastRow) & "),"
370             Else
380                 strRefersTo = strRefersTo & "COUNTA($" & strColid(jFirstCol) & "$" & CStr(jFirstrow) & ":$" & strColid(jFirstCol) & "$" & CStr(gMaxRows) & "),"
390             End If
400         End If
410     ElseIf Me.optSelCellRow Then
420         strRefersTo = strRefersTo & strRowRef & ","
430     End If
440 End If
    '
    ' columns
    '
450 If Me.optRows Then
        '
        ' not dynamic cols
        '
460     If jFirstCol = jLastCol Then
470         strRefersTo = strRefersTo & "1"
480     Else
490         If jLastCol < jFirstCol Then
500             strRefersTo = ""
                'MsgBox "Last col number " & CStr(jLastCol) & " in dynamic range is before first col number " & CStr(jFirstCol), vbOKOnly + vbCritical, gsAppName
510             MsgBox ReworkMsg(GetLangString(28, varDynWizTexts), CStr(jLastCol), CStr(jFirstCol)), vbOKOnly + vbCritical, gsAppName

520             Exit Sub
530         Else
540             strRefersTo = strRefersTo & CStr(jLastCol - jFirstCol + 1)
550         End If
560     End If
570 Else
        '
        ' dynamic cols
        '
580     If Me.optLastCol Then
590         If Me.optColsAnchor Then
600             strRefersTo = strRefersTo & "COUNTCOLS2(" & strAnchorCell & ")"
610         Else
620             strRefersTo = strRefersTo & "COUNTCOLS2(" & strAnchorRef & ")"
630         End If
640     ElseIf Me.optLastContigCol Then
650         If Me.optColsAnchor Then
660             strRefersTo = strRefersTo & "COUNTCONTIGCOLS2(" & strAnchorCell & ")"
670         Else
680             strRefersTo = strRefersTo & "COUNTCONTIGCOLS2(" & strAnchorRef & ")"
690         End If
700     ElseIf Me.optUsedCol Then
710         strRefersTo = strRefersTo & "COUNTUSEDCOLS2(" & strAnchorCell & ")"
720     ElseIf Me.optCountaCols Then
730         If jLastCol < jFirstCol Then
740             strRefersTo = ""
                'MsgBox "Last col number " & CStr(jLastCol) & " in dynamic range is before first col number " & CStr(jFirstCol), vbOKOnly + vbCritical, gsAppName
750             MsgBox ReworkMsg(GetLangString(28, varDynWizTexts), CStr(jLastCol), CStr(jFirstCol)), vbOKOnly + vbCritical, gsAppName
760             Exit Sub
770         Else
780             If jLastCol > jFirstCol Then
790                 strRefersTo = strRefersTo & "COUNTA($" & strColid(jFirstCol) & "$" & CStr(jFirstrow) & ":$" & strColid(jLastCol) & "$" & CStr(jFirstrow) & ")"
800             Else
810                 strRefersTo = strRefersTo & "COUNTA($" & strColid(jFirstCol) & "$" & CStr(jFirstrow) & ":$" & strColid(gMaxCols) & "$" & CStr(jFirstrow) & ")"
820             End If
830         End If
840     ElseIf Me.optSelCellCol Then
850         strRefersTo = strRefersTo & strColRef
860     End If
870 End If
880 strRefersTo = strRefersTo & ")"
End Sub
Private Sub BuildIndexRefersTo(strRefersTo As String)
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2003. All rights reserved
'
' build expression of type
'
' =strAnchorCell:INDEX(AnchorCellColumn(s),countrows in column+startrow-1)    ''' vertical
' =strAnchorCell:INDEX(AnchorCellrow,,countCols in row)          ''' horizontal
' =strAnchorCell:INDEX(Allrows,countCols in row)          ''' horizontal
'
' assumes everything is in a1 style
' NOTE *** has to use VBA funcs becos otherwise Excel crashes!
'
    Dim strEndCol As String

10  strRefersTo = "=" & strAnchorCell & ":INDEX("
    '
    ' rows
    '
20  If Me.optCols Then
        '
        ' static rows: expand cols only
        '
30      If jFirstrow = jLastRow Then
            'strRefersto = strRefersto & "1,"
40          strRefersTo = strRefersTo & "$" & CStr(jFirstrow) & ":$" & CStr(jFirstrow) & ",,"
50      Else
60          If jLastRow < jFirstrow Then
70              strRefersTo = ""
                'MsgBox "Last row number " & CStr(jLastRow) & " in dynamic range is before first row number " & CStr(jFirstrow), vbOKOnly + vbCritical, gsAppName
80              MsgBox ReworkMsg(GetLangString(27, varDynWizTexts), CStr(jLastRow), CStr(jFirstrow)), vbOKOnly + vbCritical, gsAppName

90              Exit Sub
100         Else
                'strRefersto = strRefersto & CStr(jLastrow - jFirstrow + 1)
110             strRefersTo = strRefersTo & "$" & CStr(jFirstrow) & ":$" & CStr(jLastRow) & ",,"
120         End If
130     End If
140 Else
        '
        ' dynamic rows: expand rows
        '
150     If Me.optBoth Then
            '
            ' if expand both rows and cols index through all available cols
            '
160         strRefersTo = strRefersTo & "$" & strColid(jFirstCol) & ":$" & strColid(gMaxCols) & ","
170     End If

180     If Me.optLastRow Then
190         If Me.optRowsAnchor Then
200             If Not Me.optBoth Then strRefersTo = strRefersTo & "$" & strColid(jFirstCol) & ":$" & strColid(jLastCol) & ","
210             strRefersTo = strRefersTo & "COUNTROWS(" & strAnchorCell & ")+ROW(" & strAnchorCell & ") - 1,"
220         Else
230             If Not Me.optBoth Then strRefersTo = strRefersTo & "$" & strColid(jFirstCol) & ":$" & strColid(jLastCol) & ","
240             strRefersTo = strRefersTo & "COUNTROWS(" & strAnchorRef & ")+ROW(" & strAnchorCell & ") - 1,"
250         End If
260     ElseIf Me.optLastContigRow Then
270         If Me.optRowsAnchor Then
280             If Not Me.optBoth Then strRefersTo = strRefersTo & "$" & strColid(jFirstCol) & ":$" & strColid(jLastCol) & ","
290             strRefersTo = strRefersTo & "COUNTCONTIGROWS(" & strAnchorCell & ")+ROW(" & strAnchorCell & ") - 1,"
300         Else
310             If Not Me.optBoth Then strRefersTo = strRefersTo & "$" & strColid(jFirstCol) & ":$" & strColid(jLastCol) & ","
320             strRefersTo = strRefersTo & "COUNTCONTIGROWS(" & strAnchorRef & ")+ROW(" & strAnchorCell & ") - 1,"
330         End If
340     ElseIf Me.optUsedRow Then
350         If Not Me.optBoth Then strRefersTo = strRefersTo & "$" & strColid(jFirstCol) & ":$" & strColid(jLastCol) & ","
360         strRefersTo = strRefersTo & "COUNTUSEDROWS(" & strAnchorCell & ")+ROW(" & strAnchorCell & ") - 1,"
370     ElseIf Me.optCountaRows Then
380         If jLastRow < jFirstrow Then
390             strRefersTo = ""
                'MsgBox "Last row number " & strcolid(jLastRow) & " in dynamic range is before first row number " & strcolid(jFirstrow), vbOKOnly + vbCritical, gsAppName
400             MsgBox ReworkMsg(GetLangString(27, varDynWizTexts), CStr(jLastRow), CStr(jFirstrow)), vbOKOnly + vbCritical, gsAppName

410             Exit Sub
420         Else
430             If Not Me.optBoth Then strRefersTo = strRefersTo & "$" & strColid(jFirstCol) & ":$" & strColid(jLastCol) & ","
440             If jLastRow > jFirstrow Then
450                 strRefersTo = strRefersTo & "COUNTA($" & strColid(jFirstCol) & "$" & CStr(jFirstrow) & ":$" & _
                                  strColid(jFirstCol) & "$" & CStr(jLastRow) & ")+ROW(" & strAnchorCell & ") - 1,"
460             Else
470                 strRefersTo = strRefersTo & "COUNTA($" & strColid(jFirstCol) & "$" & CStr(jFirstrow) & ":$" & _
                                  strColid(jFirstCol) & "$" & CStr(gMaxRows) & ")+ROW(" & strAnchorCell & ") - 1,"
480             End If
490         End If
500     ElseIf Me.optSelCellRow Then
510         If Not Me.optBoth Then strRefersTo = strRefersTo & "$" & strColid(jFirstCol) & ":$" & strColid(jLastCol) & ","
520         strRefersTo = strRefersTo & strRowRef & "+ROW(" & strAnchorCell & ") - 1,"
530     End If
540 End If
    '
    ' columns
    '
550 If Me.optRows Then
        '
        ' static cols : expand rows only
        '
560     If jFirstCol = jLastCol Then
570         strRefersTo = strRefersTo & CStr(jLastCol - jFirstCol + 1)
            'strRefersto = strRefersto & "$" & strColid(jFirstCol) & ":$" & strColid(jFirstCol)
            'strRefersto = strRefersto & CStr(jFirstCol)
580     Else
590         If jLastCol < jFirstCol Then
600             strRefersTo = ""
                'MsgBox "Last col number " & CStr(jLastCol) & " in dynamic range is before first col number " & CStr(jFirstCol), vbOKOnly + vbCritical, gsAppName
610             MsgBox ReworkMsg(GetLangString(28, varDynWizTexts), CStr(jLastCol), CStr(jFirstCol)), vbOKOnly + vbCritical, gsAppName

620             Exit Sub
630         Else
640             strRefersTo = strRefersTo & CStr(jLastCol - jFirstCol + 1)
                'strRefersto = strRefersto & "$" & strColid(jLastCol) & ":$" & strColid(jLastCol)
650         End If
660     End If
670 Else
        '
        ' dynamic cols only or both
        '
680     If Me.optBoth Then
690         strEndCol = ")"                                         ''' counting starts at jFirstcol
700     Else
710         strEndCol = ")+COLUMN(" & strAnchorCell & ") - 1"       ''' counting starts at col 1
720     End If
730     If Me.optLastCol Then
740         If Me.optColsAnchor Then
750             strRefersTo = strRefersTo & "COUNTCOLS(" & strAnchorCell & strEndCol
760         Else
770             strRefersTo = strRefersTo & "COUNTCOLS(" & strAnchorRef & strEndCol
780         End If
790     ElseIf Me.optLastContigCol Then
800         If Me.optColsAnchor Then
810             strRefersTo = strRefersTo & "COUNTCONTIGCOLS(" & strAnchorCell & strEndCol
820         Else
830             strRefersTo = strRefersTo & "COUNTCONTIGCOLS(" & strAnchorRef & strEndCol
840         End If
850     ElseIf Me.optUsedCol Then
860         strRefersTo = strRefersTo & "COUNTUSEDCOLS(" & strAnchorCell & strEndCol
870     ElseIf Me.optCountaCols Then
880         If jLastCol < jFirstCol Then
890             strRefersTo = ""
                'MsgBox "Last col number " & CStr(jLastCol) & " in dynamic range is before first col number " & CStr(jFirstCol), vbOKOnly + vbCritical, gsAppName
900             MsgBox ReworkMsg(GetLangString(28, varDynWizTexts), CStr(jLastCol), CStr(jFirstCol)), vbOKOnly + vbCritical, gsAppName
910             Exit Sub
920         Else
930             If jLastCol > jFirstCol Then
940                 strRefersTo = strRefersTo & "COUNTA($" & strColid(jFirstCol) & "$" & CStr(jFirstrow) & ":$" & _
                                  strColid(jLastCol) & "$" & CStr(jFirstrow) & strEndCol
950             Else
960                 strRefersTo = strRefersTo & "COUNTA($" & strColid(jFirstCol) & "$" & CStr(jFirstrow) & ":$" & _
                                  strColid(gMaxCols) & "$" & CStr(jFirstrow) & strEndCol
970             End If
980         End If
990     ElseIf Me.optSelCellCol Then
1000        If Me.optBoth Then
1010            strRefersTo = strRefersTo & strColRef
1020        Else
1030            strRefersTo = strRefersTo & strColRef & "+COLUMN(" & strAnchorCell & ") - 1"
1040        End If
1050    End If
1060 End If

1070 strRefersTo = strRefersTo & ")"
End Sub
Private Function ConvertReftoA1(strReference As String, bStripBook As Boolean) As String
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2003. All rights reserved
'
' converts an r1c1 reference to A1 and optionally strips off the book name
'
' fixes crw 17/10/04
'
    Dim jOpen As Long
    Dim jClose As Long
10  On Error GoTo funcfail
20  ConvertReftoA1 = ""
30  strReference = Trim(strReference)
40  If Len(strReference) > 0 Then
50      ConvertReftoA1 = Application.ConvertFormula("=" & strReference, xlR1C1, xlA1)
60      ConvertReftoA1 = Right(ConvertReftoA1, Len(ConvertReftoA1) - 1)
70      If bStripBook Then
80          jOpen = InStr(ConvertReftoA1, "[")
90          jClose = InStr(ConvertReftoA1, "]")
100         If jOpen > 0 And jClose > 0 And jClose > jOpen Then
110             If jOpen = 1 Then
120                 ConvertReftoA1 = Right(ConvertReftoA1, Len(ConvertReftoA1) - jClose)
130             Else
140                 ConvertReftoA1 = Left(ConvertReftoA1, jOpen - 1) & Right(ConvertReftoA1, Len(ConvertReftoA1) - jClose)
150             End If
160         End If
170     End If
180 End If
190 Exit Function
funcfail:
200 ConvertReftoA1 = ""
End Function
Private Function strColid(jColNo As Long) As Variant
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 1997-2008
' returns column name/id of colno
' fix for Excel 2008 1/4/2008
'
10  If jColNo > 0 And jColNo <= 16384 Then
20      If jColNo < 27 Then
30          strColid = Chr$(((jColNo - 1) Mod 26) + 65)
40      ElseIf jColNo < 703 Then
50          strColid = Chr$(64 + Int((jColNo - 1) / 26)) & Chr$(((jColNo - 1) Mod 26) + 65)
60      Else
70          strColid = Chr$(64 + Int((jColNo - 27) / 676)) & Chr$(64 + Int((jColNo - Int((jColNo - 27) / 676) * 676 - 1) / 26)) & Chr$(((jColNo - 1) Mod 26) + 65)
80      End If
90  Else
100     strColid = CVErr(xlErrNA)
110 End If
End Function

Attribute VB_Name = "ufEvaluate"
Attribute VB_Base = "0{A63812AF-2931-407C-8BA6-421990B03095}{E0512CF1-BEB0-468A-A395-DFA568C77FCC}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Private Sub butOK_Click()
10  Unload Me
End Sub
Attribute VB_Name = "ufInputBox"
Attribute VB_Base = "0{51B7A10B-131A-41B3-A2F8-A06914D5AB31}{D7950DEE-5916-46F5-AB86-5DC9AD137091}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private mlPressedButton As Long

Private mbIsInputBox As Boolean
Private msMessage As String
Private msReturnText As String
Private msTitle As String

Private Sub cmbBut1_Click()
10  PressedButton = 1
20  Me.Hide
End Sub

Private Sub cmbBut2_Click()
10  PressedButton = 2
20  Me.Hide
End Sub

Private Sub cmbBut3_Click()
10  PressedButton = 3
20  Me.Hide
End Sub

Public Sub Initialize()
10  tbxMsg.Text = Message
20  tbxInput.Visible = IsInputBox
30  If IsInputBox Then
40      tbxInput = ReturnText
50  Else
60      Me.Height = Me.Height - tbxInput.Height - 6
70      cmbBut1.Top = tbxMsg.Top + tbxMsg.Height + 6
80      cmbBut2.Top = tbxMsg.Top + tbxMsg.Height + 6
90      cmbBut3.Top = tbxMsg.Top + tbxMsg.Height + 6
100 End If
End Sub

Public Property Get PressedButton() As Long
10  PressedButton = mlPressedButton
End Property

Public Property Let PressedButton(ByVal lPressedButton As Long)
10  mlPressedButton = lPressedButton
End Property

Public Property Get Title() As String
10  Title = msTitle
End Property

Public Property Let Title(ByVal sTitle As String)
10  msTitle = sTitle
End Property

Public Property Get IsInputBox() As Boolean
10  IsInputBox = mbIsInputBox
End Property

Public Property Let IsInputBox(ByVal bIsInputBox As Boolean)
10  mbIsInputBox = bIsInputBox
End Property

Public Property Get ReturnText() As String
10  ReturnText = msReturnText
End Property

Public Property Let ReturnText(ByVal sReturnText As String)
10  msReturnText = sReturnText
End Property


Public Property Get Message() As String
10  Message = msMessage
End Property

Public Property Let Message(ByVal sMessage As String)
10  msMessage = sMessage
End Property

Private Sub tbxInput_Change()
10  ReturnText = tbxInput.Value
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
10  Cancel = True
20  Me.Hide
End Sub

Attribute VB_Name = "ufLocalsheets"
Attribute VB_Base = "0{06D865D8-9392-44A1-8B5A-8ACC05006C8C}{49A0E1BF-516F-461F-8888-88B2EFA34672}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Option Compare Text

Private Sub cbCan_Click()
'
' Copyright Decision Models 2002-2010. All Rights Reserved
'

10  PushStack3 "cbCan_click"
20  gbSelectedaSheet = False
30  Unload Me
40  PopStack3
End Sub

Private Sub cbOK_Click()
'
' Copyright Decision Models 2002-2010. All Rights Reserved
'
    Dim jListindex As Long

10  PushStack3 "cbOK_Click"

20  With Me
30      gsSheet = ""
40      For jListindex = 0 To .lbxSheets.ListCount - 1
50          If .lbxSheets.Selected(jListindex) Then
60              gsSheet = .lbxSheets.List(jListindex, 0)
70              Exit For
80          End If
90      Next
100 End With
110 If gsSheet <> "" Then
120     gbSelectedaSheet = True
130 Else
140     gbSelectedaSheet = False
150 End If
160 Unload Me
170 PopStack3
End Sub

Private Sub UserForm_Initialize()

10  PushStack3 "LocalSheetsUserForm_Initialize"
20  SetTexts
30  If gbMacOS = True Then
40      On Error Resume Next
50      For Each gctlLocalControl In Controls
60          With gctlLocalControl
70              .Font.Size = 11
80              .Font.Name = "Geneva"
90              .Left = .Left + 20
100         End With
110     Next
120     With Me
130         .Width = 297
140         If gbMacX = False Then
150             cbCan.Move 110, 224, 56, 26
160             cbOK.Move 32, 224, 56, 26
170             lblSelect.Move 18, 7, 261, 14
180             lbxSheets.Move 18, 26, 280, 198
190         Else
200             cbCan.Move 110, 222, 56, 24
210             cbOK.Move 32, 222, 56, 24
220             lblSelect.Move 18, 7, 261, 14
230             lbxSheets.Move 18, 26, 280, 198
240         End If
250     End With
260 End If
270 PopStack3
End Sub
Private Sub SetTexts()
10  PushStack3 "setTexts"
20  With Me
30      .Caption = gsTxtufLocalSheets(1)
40      .cbOK.Caption = gsTxtufLocalSheets(3)
50      .cbOK.ControlTipText = gsTxtufLocalSheets(4)
60      .cbCan.Caption = gsTxtufLocalSheets(5)
70      .cbCan.ControlTipText = gsTxtufLocalSheets(6)
80      .lbxSheets.ControlTipText = gsTxtufLocalSheets(7)
90  End With
100 PopStack3
End Sub



Attribute VB_Name = "ufNameManager"
Attribute VB_Base = "0{608BDAEF-EE50-4684-8964-DA52C89B8446}{9A2FF829-CC05-434E-BFE7-18631EB82F58}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Option Compare Text
Option Base 1
'***************************************************************
'*                                                             *
'* All subs and functions in this module:                      *
'* Copyright |fffd| J.K. Pieterse 2002-2010. All Rights Reserved    *
'* except where shown as                                       *
'* Copyright |fffd| Decision Models 2002-2010. All rights Reserved  *
'*                                                             *
'***************************************************************
Dim gbMinimized As Boolean
Dim lFormHeight As Long
Dim lFormWidth As Long
Dim lTopIndex As Long
Private Const mlGrey As Long = &H80000004
Private Const mlWhite As Long = 16777215
Private Const mlDarkGrey As Long = &HC0C0C0
'SB+
'Declare an object for our CFormResizer class to handle resizing for this form
Dim mclsResizer As CFormResizer

'Module variables to handle the splitter bar
Dim mbSplitterMoving As Boolean
Dim mdSplitterOrigin As Double

#If VBA7 Then
    Dim mhwndForm As LongPtr                                 'The userform's window handle
    Private mXLHwnd As LongPtr    'Excel's window handle
    Private Declare PtrSafe Function FindWindow32 Lib "User32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As LongPtr
    Private Declare PtrSafe Function SetWindowLongPtr Lib "User32" Alias "SetWindowLongA" (ByVal hwnd As LongPtr, ByVal nIndex As Long, ByVal dwNewLong As LongPtr) As LongPtr
    Private Declare PtrSafe Function SetForegroundWindow Lib "User32" (ByVal hwnd As LongPtr) As Long
#Else
    Dim mhwndForm As Long                                 'The userform's window handle
    Private mXLHwnd As Long    'Excel's window handle
    Private Declare Function FindWindow32 Lib "User32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
    Private Declare Function SetWindowLongPtr Lib "User32" Alias "SetWindowLongA" (ByVal hwnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
    Private Declare Function SetForegroundWindow Lib "User32" (ByVal hwnd As Long) As Long
#End If

Const GWL_HWNDPARENT As Long = -8
Private WithEvents xlApp As Excel.Application
Attribute xlApp.VB_VarHelpID = -1

Private Sub cbAnalyse_Click()
10  cmbAnalyse_Click
End Sub

Private Sub cbGoBack_Click()
' Copyright |fffd| Decision Models 2010. All rights Reserved
10  If Not gbFxl Then
20      MsgBox "Sorry, this feature is only available in FastExcel", vbOKOnly + vbInformation, gsAppName
30  Else
40      On Error Resume Next
50      Application.GoTo
60      On Error GoTo 0
70  End If
End Sub

Private Sub cbGoto_Click()
' Copyright |fffd| Decision Models 2010. All rights Reserved
10  GoActiveName
End Sub

Private Sub cbAbout_Click()
'
' FastExcel Version
'
10  PushStack3 "cbAbout_Click"
20  If gbFxl Then
30      ShowMsg ReworkMsg(gsMsgs(41), gsVersion, gsBuild), vbOKOnly + vbInformation
40  Else
50      ShowMsg ReworkMsg(gsMsgs(42), gsVersion, gsBuild), vbOKOnly + vbInformation
60  End If
70  PopStack3
End Sub

Private Sub cbbLang_Change()
'
' mod CRW 4/11/2010 - Auto
'
10  If gbDisableEvents Then Exit Sub
20  gbDisableEvents = True
30  giLang = Me.cbbLang.ListIndex - 1       ''' CRW Auto is -1, English is 0 etc
40  SaveSettings
50  ReadMessages
60  gbDisableEvents = False
70  InitializeUF
End Sub

Private Sub cbUnName_Click()
10  UnapplyNames
End Sub

Private Sub cmbGoBack_Click()
10  cbGoBack_Click
End Sub

Private Sub cmbGoto_Click()
10  cbGoto_Click
End Sub

Private Sub cbList_Click()

10  PushStack3 "cbListClick"
20  CheckFixNames                                     ''' crw dec 29 2002
    ' Me.Hide
30  If Not gbListChanged Then
40      ListNamesOnSheet
50      If CountListSheets > 0 Then
60          Me.cbPickup.Visible = True
70          ShowMsg ReworkMsg(gsMsgs(71)), vbInformation + vbOKOnly
80      Else
90          Me.cbPickup.Visible = False
100     End If
110 Else
        ' crw Jan 3 2003
120     ShowMsg gsMsgs(51), vbOKOnly + vbCritical
130 End If
140 gbListChanged = False
150 PopStack3
End Sub

Private Sub cbMap_Click()
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2005-2010 All rights reserved
' build a Name map
'
10  If Not gbFxl Then
20      MsgBox "Sorry, this feature is only available in FastExcel", vbOKOnly + vbInformation, gsAppName
30  Else
40      PushStack3 "cbMap_Click"
50      DoNameMap True          ''' called from NM
60      PopStack3
70  End If
End Sub

Private Sub cbNot_Click()
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2005-2010 All rights reserved
'
10  If Not gbFxl Then
20      If gbDisableEvents Then Exit Sub
30      gbDisableEvents = True
40      Me.cbNot = False
50      MsgBox "Sorry, this feature is only available in FastExcel", vbOKOnly + vbInformation, gsAppName
60      Application.EnableEvents = False
70      gbInvertFilters = Me.cbNot
80      gbDisableEvents = False
90  Else
100     If gbDisableEvents Then Exit Sub
110     gbDisableEvents = True
120     PushStack3 "cbNot"
130     gbInvertFilters = Me.cbNot
140     CheckFixNames                                     ''' crw Jan 3 2003
150     ToggleScope
160     ListTheNames
170     If Me.lbxNames.ListCount = 0 Then
180         DisableThings
190     Else
200         EnableThings
210     End If
        ' crw Nov 4
220     GetIndex
230     SetHideUnhide
240     SetGlobLoc                                        ''' crw nov 11 2002
250     gbListChanged = False
260     gbDisableEvents = False
GoExit:
270     PopStack3
280 End If
End Sub

Private Sub cbPickup_Click()

10  PushStack3 "cbPickup_Click"
20  CheckFixNames
30  If CountListSheets = 0 Then
40      GoTo GoExit
50  End If
60  If Not gbListChanged Then
        'Me.Hide
70      PickUpNamesFromList
80      FindAllNames
90      ListTheNames
100     GetIndex
110 Else
        ' crw Jan 3 2003
120     ShowMsg gsMsgs(53), vbOKOnly + vbCritical
130 End If
140 gbListChanged = False
GoExit:
150 PopStack3
End Sub

Private Sub cbRename_Click()
10  RenameAName
End Sub

Private Sub cbReplace_Click()
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2005-2010 All rights reserved
' find and replace the refersto
'
    Dim j As Long
10  If Not gbFxl Then
20      MsgBox "Sorry, this feature is only available in FastExcel", vbOKOnly + vbInformation, gsAppName
30  Else
40      PushStack3 "cbReplace"
        '
        ' create form
        '
50      If Not gfrmReplace Is Nothing Then
60          Unload gfrmReplace
70      End If
80      Set gfrmReplace = Nothing
90      If gfrmReplace Is Nothing Then
100         Set gfrmReplace = New ufReplace
110     End If

120     If Me.lbxNames.ListCount > 0 Then
            '
            ' store selections

130         ReDim gbSelections(Me.lbxNames.ListCount)
140         For j = 1 To Me.lbxNames.ListCount
150             gbSelections(j) = False
160             If Me.lbxNames.Selected(j - 1) Then
170                 gbSelections(j) = True
180             End If
190         Next j
            '
            ' reset to last paramaeters
            '
200         gfrmReplace.tbxFind = gsFind
210         gfrmReplace.tbxReplace = gsReplace
220         If gbRepScope Then
230             gfrmReplace.optSelOnly = False
240             gfrmReplace.optAll = True
250         Else
260             gfrmReplace.optSelOnly = True
270             gfrmReplace.optAll = False
280         End If
290         If gbRepWild Then
300             gfrmReplace.chkWildFind = True
310         Else
320             gfrmReplace.chkWildFind = False
330         End If
            '
            ' reset has-found
            '
340         gbRepFound = False
            '
            ' show the form
            '
            '            #If VBA6 OR VBA7 Then
            '                gfrmReplace.Show vbModeless
            '            #Else
350         gfrmReplace.Show
            '           #End If

360     End If
370     PopStack3
380 End If
End Sub

Private Sub cbWizard_Click()
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2003-2010. All Rights Reserved
' launch the dynamic range wizard
'
10  If Not gbFxl Then
20      MsgBox "Sorry, this feature is only available in FastExcel", vbOKOnly + vbInformation, gsAppName
30  Else
40      PushStack3 "cbWizard_Click"
50      StartDynWiz2
60      cbRefresh_Click
70      PopStack3
80  End If
End Sub

Private Sub cmbAbout2_Click()
10  cbAbout_Click
End Sub

Private Sub cmbAdd2_Click()
10  cbAdd_Click
End Sub

Private Sub cmbAnalyse2_Click()
10  cmbAnalyse_Click
End Sub

Private Sub cbClearHighlight_Click()
10  If ShowMsg(ReworkMsg(gsMsgs(76)), vbQuestion + vbYesNo) = vbYes Then
20      RemoveShapes
30  End If
End Sub

Private Sub cmbClearHighlight2_Click()
10  cbClearHighlight_Click
End Sub

Private Sub cmbDelete2_Click()
10  cbDelete_Click
End Sub

Private Sub cmbEvaluate2_Click()
10  cbEvaluate_Click
End Sub

Private Sub cmbGlobalise2_Click()
10  cbGlobalise_Click
End Sub

Private Sub cmbHelp_Click()
10  cbHelp_Click
End Sub

Private Sub cmbHide2_Click()
10  cbHide_Click
End Sub

Private Sub cbHighlight_Click()
10  RememberSelectedNames
20  MarkupNames 1, True
End Sub

Private Sub cbHelp_Click()
10  If Not gbFxl Then
20      MsgBox "Sorry, this feature is only available in FastExcel", vbOKOnly + vbInformation, gsAppName
30  Else
40      PushStack3 "cbHelpClick"
50      ShowHelp 4, ThisWorkbook.Path & "\FastExcelV3.chm", 174
        '      Application.Help ThisWorkbook.Path & "\FastExcelUser2.hlp", 174
60      PopStack3
70  End If
End Sub

Private Sub cbClose_Click()
10  PushStack3 "cbClose_Click"
20  mclsResizer.FormResize
    'Me.Hide
30  gbFormIsShowing = False
40  gbDisableEvents = False
50  Application.Cursor = xlDefault
60  Application.Calculation = glCalcMode
70  gbActiveCellChecked = False
80  gbIsRelative = False
90  Set mclsResizer = Nothing
100 Unload Me
110 Set gfrmNameManager = Nothing
120 PopStack3

End Sub

Sub cbDelete_Click()
10  If gbDisableEvents Then Exit Sub
20  gbDisableEvents = True
30  PushStack3 "cbDelete_Click"
40  GetTopIndex
50  CheckFixNames                                     ''' crw dec 29 2002
60  If Me.lbxNames.ListCount = 0 Then
70      DisableThings
80  Else
90      EnableThings
100 End If
110 If Not gbListChanged Then
120     DeleteNames
130     FindAllNames
140     ListTheNames
150     GetIndex
160     If Me.lbxNames.ListCount = 0 Then
170         DisableThings
180     Else
190         EnableThings
200     End If
210     SetHideUnhide                                 ' crw nov 4 2002
220     SetGlobLoc                                    ' crw nov11 2002
230 Else
240     ShowMsg ReworkMsg(gsMsgs(40)), vbOKOnly + vbCritical
250 End If
260 SetTopIndex
270 gbListChanged = False
280 gbDisableEvents = False
GoExit:
290 PopStack3
End Sub

Private Sub cbAdd_Click()
10  If gbDisableEvents Then Exit Sub
20  PushStack3 "cbAddClick"
30  gbDisableEvents = True
40  Me.Hide
50  Application.OnTime Now, "AddNameShow"

    '    GetTopIndex
    '40  AddaName
    '50  FindAllNames
    '60  ListTheNames
    '    SetTopIndex
    '70  GetIndex
    '80  If Me.lbxNames.ListCount = 0 Then
    '90      DisableThings
    '100 Else
    '110     EnableThings
    '120 End If
    '130 SetHideUnhide       ' crw nov 4 2002
    '140 SetGlobLoc          ''' crw nov 11 2002

60  gbDisableEvents = False
GoExit:
70  PopStack3
End Sub

Private Sub cbcontaining_Click()
10  If gbDisableEvents Then Exit Sub
20  gbDisableEvents = True
30  PushStack3 "cbContaining_Click"
40  gbContains = Me.cbContaining.Value
50  gsContains = Me.tbContains.Value
60  ListTheNames
70  GetIndex
80  If Me.lbxNames.ListCount = 0 Then
90      DisableThings
100 Else
110     EnableThings
120 End If
130 SetHideUnhide                                     '  crw nov 4 2002
140 SetGlobLoc                                        ''' crw nov 11 2002
150 gbDisableEvents = False
GoExit:
160 PopStack3
End Sub

Sub cbEvaluate_Click()
'
' evaluate a name and msgbox the results
' 28 Oct 2002 CRW: max 1000 chars 50 rows
' Copyright Decision Models 2002-2010. All Rights Reserved
'
' crw 1/11/2002 fix multiple names
' crw 1/7/2003 fix evaluation of local and relative names
' crw 19/2/2005 fix names containing XLM
' crw 19/2/2005 fix error handling
' crw 19/2/2005 evaluate the name rather than the refersto
'
' crw 21/5/2005 handle duplicate global local
'
' crw 8/10/2005 try to evaluate the reference if relative name
'
' crw 22/4/2014 use textbox on form & international separators
'
    Dim oSht As Worksheet
    Dim vEval As Variant
    Dim strEval As String
    Dim strEval2 As String
    Dim j As Long
    Dim k As Long
    Dim jCt As Long
    Dim jRows As Long
    Dim kCols As Long
    Dim iMsg As Long
    Dim bEval As Boolean
    Dim oNm As Name
    Dim oParent As Worksheet
    Dim bSwitch As Boolean

10  If gbDisableEvents Then Exit Sub
    'Me.Hide
20  gbDisableEvents = True
30  PushStack3 "cbEvaluate_Click"
40  CheckFixNames                                     ''' crw dec 29 2002
50  If Not gbListChanged Then
60      GetIndex
70      bEval = True
80      Set oParent = Nothing                         ''' crw feb 19 2005
90      If Me.lbxNames.ListCount <> 0 Then
100         If glNamegsSelected = 0 Then
110             Beep
120             bEval = False
130         ElseIf glNamegsSelected > 1 Then
140             If ShowMsg(ReworkMsg(gsMsgs(43)), vbYesNo + vbQuestion) = vbNo Then
150                 bEval = False
160             End If
170         End If
180         If IsNameThreeD(glActive) Then
190             ShowMsg ReworkMsg(gsMsgs(44)), vbOKOnly + vbExclamation
200             bEval = False
210         End If
            '            If InStr(gsRefersto(glActive), "#") > 0 Then
            '               ShowMsg ReworkMsg(gsMsgs(45)), vbOKOnly + vbExclamation
            '              bEval = False
            '         End If
220         If bEval Then
230             Err.Clear
240             If IsTableName(gsNames(glActive)) Then
250                 ufEvaluate.lblRowsCols = "Table '" & gsNames(glActive) & "' has "
260                 vEval = Range(gsNames(glActive)).Parent.Evaluate(gsRefersto(glActive))

270             Else
280                 Set oNm = FindName(gsNames(glActive))
290                 If Not oNm Is Nothing Then ufEvaluate.lblRowsCols = "Name '" & oNm.Name & "' has "
300                 If IsNameLocal(gsNames(glActive), False) Then

310                     Set oParent = oNm.Parent
320                     Set oSht = ActiveSheet
330                     oNm.Parent.Activate
                        '
                        ' evaluate always evaluates relative names wr to A1
                        ' so try evaluating the refersto first
                        '
340                     If IsNameRelative(oNm.RefersToR1C1) Then
350                         vEval = oParent.Evaluate(oNm.RefersTo)
360                         If IsError(vEval) Then vEval = oParent.Evaluate("=" & oNm.Name)
370                     Else
380                         vEval = oParent.Evaluate("=" & oNm.Name)
390                     End If
400                     oSht.Activate
410                     Set oSht = Nothing
420                 Else
430                     Set oSht = ActiveSheet
440                     bSwitch = False
450                     If IsNameGlobalLocal(oSht, gsNames(glActive)) Then
460                         bSwitch = True
470                         SwitchtoDifferentSheet gsNames(glActive)
480                     End If
490                     Set oParent = Nothing
500                     If IsNameRelative(oNm.RefersToR1C1) Then
510                         vEval = Evaluate(oNm.RefersTo)
520                         If IsError(vEval) Then vEval = Evaluate("=" & oNm.Name)
530                     Else
540                         vEval = Evaluate("=" & oNm.Name)
550                     End If
560                     If bSwitch Then SwitchSheetBack
570                 End If
580             End If
590             On Error Resume Next
600             jRows = 0
610             kCols = 0
620             jRows = UBound(vEval, 1)
630             kCols = UBound(vEval, 2)
640
650             On Error GoTo 0
660             If IsArray(vEval) Then
670                 ufEvaluate.lblRowsCols = ufEvaluate.lblRowsCols & CStr(jRows) & " " & gsMsgs(106) & " "
680                 If kCols < 2 Then
690                     ufEvaluate.lblRowsCols = ufEvaluate.lblRowsCols & "1 Column" & " "
700                 Else
710                     ufEvaluate.lblRowsCols = ufEvaluate.lblRowsCols & CStr(kCols) & " " & gsMsgs(105) & " "
720                 End If
                    '
                    ' handle 1 or 2 dimensions
                    '
730                 For j = 1 To jRows
740                     If kCols > 0 Then
750                         For k = 1 To kCols
760                             If k > 1 Then strEval = strEval & Application.International(xlColumnSeparator) & " "
770                             jCt = jCt + 1
780                             strEval = strEval & strError(vEval(j, k))
790                         Next k
800                     Else
810                         jCt = jCt + 1
820                         strEval = strEval & strError(vEval(j))
830                     End If
840                     strEval = strEval & Application.International(xlRowSeparator) & " " & vbCrLf
850                 Next j
860             Else
870                 ufEvaluate.lblRowsCols = ufEvaluate.lblRowsCols & " 1 row and 1 column"
880                 strEval = strError(vEval)
890             End If
900             If IsError(vEval) Then
910                 bEval = False
920             Else
930                 If IsArray(vEval) Then
940                     If kCols > 0 Then
950                         If IsError(vEval(1, 1)) Then
960                             bEval = False
970                         End If
980                     Else
990                         If IsError(vEval(1)) Then
1000                            bEval = False
1010                        End If
1020                    End If
1030                End If
1040            End If
1050            If bEval Then
1060                ufEvaluate.tbxEval = strEval
1070                ufEvaluate.tbxEval.SelStart = 0
1080                ufEvaluate.Show
1090            Else
1100                If IsNameRefersToLegal(oNm.Name, oNm.RefersTo) Then
1110                    strEval2 = EvalInCell(oNm.Name, jRows, kCols)
1120                    If Left(strEval2, 1) = "#" Then
                            '
                            ' if incell returns an error use Evaluated string (seems to have better error handling?)
                            '
1130                        ufEvaluate.tbxEval = strEval
1140                        ufEvaluate.tbxEval.SelStart = 0
1150                        ufEvaluate.Show
1160                    Else
1170                        ufEvaluate.tbxEval = strEval2
1180                        ufEvaluate.tbxEval.SelStart = 0
1190                        ufEvaluate.Show
1200                    End If
1210                Else
1220                    ShowMsg ReworkMsg(gsMsgs(70), oNm.Name), vbOKOnly + vbInformation
1230                End If
1240            End If
1250        End If
1260    End If
1270 Else
1280    ShowMsg gsMsgs(48), vbOKOnly + vbCritical
1290 End If
GoExit:
1300 Set oNm = Nothing
1310 gbListChanged = False
1320 gbDisableEvents = False
    '    If Val(Application.Version) = 8 Or gbMacOS = True Then
    '        gfrmNameManager.Show
    '    Else
    '        ShowModeless
    '    End If
1330 PopStack3
End Sub

Sub cbGlobalise_Click()
'
' Copyright Decision Models 2002-2010. All Rights Reserved
'
10  If gbDisableEvents Then Exit Sub
20  gbDisableEvents = True
30  PushStack3 "cbGlobalise_Click"
40  GetTopIndex
50  CheckFixNames
60  If Not gbListChanged Then                         ''' crw dec 29 2002
70      If Me.lbxNames.ListCount > 0 Then
80          Globalise
90          FindAllNames
100         ListTheNames
110         GetIndex
120         SetGlobLoc                                ''' crw nov 11 2002
130     End If
140 Else
        ' crw Jan 3 2003
150     ShowMsg gsMsgs(49), vbOKOnly + vbCritical
160 End If
170 SetTopIndex
180 gbListChanged = False
190 gbDisableEvents = False
GoExit:
200 PopStack3
End Sub

Sub cbHide_Click()

10  If gbDisableEvents Then Exit Sub
20  gbDisableEvents = True
30  PushStack3 "cbHide_Click"
40  GetTopIndex
50  CheckFixNames                                     ''' crw dec 29 2002
60  If Me.lbxNames.ListCount = 0 Then
70      DisableThings
80  Else
90      EnableThings
100 End If
110 If Not gbListChanged Then
120     gbHide = True
130     GetIndex
        ' crw Nov 4 2002
        'If bMulti or gbOverlap Then RememberSelected
140     HideUnhideNames gsMsgs(59)
150     ListTheNames
160     GetIndex
        ' crw Nov 4 2002
        'If bMulti or gbOverlap Then RestoreSelected
170     If Me.lbxNames.ListCount = 0 Then
180         DisableThings
190     Else
200         EnableThings
210     End If
220     SetHideUnhide                                 ' crw nov 4 2002
230     SetGlobLoc                                    ''' crw nov 11 2002
240 Else
        ' crw Jan 3 2003
250     ShowMsg gsMsgs(50), vbOKOnly + vbCritical
260 End If
270 SetTopIndex
280 gbListChanged = False
290 gbDisableEvents = False
GoExit:
300 PopStack3
End Sub

Sub cbLocalise_Click()
'
' Copyright Decision Models 2002-2010. All Rights Reserved
'

10  If gbDisableEvents Then Exit Sub
20  gbDisableEvents = True
30  PushStack3 "cbLocalise_Click"
40  GetTopIndex
50  CheckFixNames
60  If Me.lbxNames.ListCount = 0 Then
70      DisableThings
80  Else
90      EnableThings
100 End If
110 If Not gbListChanged Then
120     If Me.lbxNames.ListCount > 0 Then
130         Localise
140         FindAllNames
150         ListTheNames
160         GetIndex
170         SetGlobLoc                                ''' crw nov 11 2002
180     End If
190 Else
        ' crw Jan 3 2003
200     ShowMsg gsMsgs(52), vbOKOnly + vbCritical
210 End If
220 SetTopIndex
230 gbListChanged = False
240 gbDisableEvents = False
GoExit:
250 PopStack3
End Sub

Private Sub cbRefresh_Click()
'
' Copyright Decision Models 2003-2010. All Rights Reserved
'
' refresh the names list, refersto etc

10  If gbDisableEvents Then Exit Sub
20  gbDisableEvents = True
30  PushStack3 "cbRefresh_Click"
40  GetTopIndex
50  gbRefresh = True
60  CheckFixNames
70  If Me.lbxNames.ListCount = 0 Then
80      DisableThings
90  Else
100     EnableThings
110 End If
120 gbListChanged = False
130 gbRefresh = False
140 gbDisableEvents = False
150 SetTopIndex
GoExit:
160 PopStack3
End Sub

Sub cbUnhide_Click()

10  If gbDisableEvents Then Exit Sub
20  gbDisableEvents = True
30  PushStack3 "cbUnhide_Click"
40  GetTopIndex
50  CheckFixNames                                     ''' crw dec 29 2002
60  If Me.lbxNames.ListCount = 0 Then
70      DisableThings
80  Else
90      EnableThings
100 End If
110 If Not gbListChanged Then
120     gbHide = False
130     GetIndex
        ' crw nov 4 2002
        'If bMulti or gbOverlap Then RememberSelected
140     HideUnhideNames gsMsgs(60)
150     ListTheNames
160     GetIndex
170     If Me.lbxNames.ListCount = 0 Then
180         DisableThings
190     Else
200         EnableThings
210     End If
        ' crw nov 4 2002
220     SetHideUnhide
230     SetGlobLoc                                    ''' crw nov 11 2002
        'If bMulti or gbOverlap Then RestoreSelected
240 Else
        ' crw Jan 3 2003
250     ShowMsg gsMsgs(54), vbOKOnly + vbCritical
260 End If
270 SetTopIndex
280 gbListChanged = False
290 gbDisableEvents = False
GoExit:
300 PopStack3
End Sub

Private Sub cbUnUsed_Click()
'
' Copyright Decision Models 2002-2010. All Rights Reserved
'
' crw jan 5 2003: separate checkbox for unused
'
    Dim iMsg As Long

10  If gbDisableEvents Then Exit Sub
20  gbDisableEvents = True
30  PushStack3 "cbUnUsed_Click"
40  gbUnUsed = False
50  If Me.cbUnused Then
        ''' crw 11 July 2003 changed message
60      iMsg = ShowMsg(ReworkMsg(gsMsgs(55)), vbYesNo + vbExclamation)
70      If iMsg = vbNo Then
80          gbUnUsed = False
90          Me.cbUnused = False
            'JKP Jan 13 2003 Exit on No
100         gbListChanged = False
110         gbDisableEvents = False
120         GoTo GoExit
130     Else
140         gbUnUsed = True
150     End If
160 End If
170 CheckFixNames                                     ''' crw Jan 3 2003
180 ToggleScope
190 ListTheNames
200 If Me.lbxNames.ListCount = 0 Then
210     DisableThings
220 Else
230     EnableThings
240 End If
    ' crw Nov 4
250 GetIndex
260 SetHideUnhide
270 SetGlobLoc                                        ''' crw nov 11 2002
280 gbListChanged = False
290 gbDisableEvents = False
GoExit:
300 PopStack3
End Sub

Sub cbUsed_Click()
'
' added JKP: Jan 24 2003
'
' ignore table names CRW 27 April 2014
'
10  If gbDisableEvents Then Exit Sub
20  gbDisableEvents = True
30  PushStack3 "cbUsed_Click"
40  CheckFixNames
50  If Me.lbxNames.ListCount = 0 Then
60      DisableThings
70  Else
80      EnableThings
90  End If
100 GetIndex
    '110 IsNameUsed
110 Me.Hide
120 If IsTableName(gsNames(glActive)) Then
130     Beep
140 Else
150     LookForName gsNames(glActive)
160 End If
170 gbDisableEvents = False
GoExit:
180 PopStack3
End Sub

Private Sub cmbAnalyse_Click()
10  GetIndex
    'Me.Hide
20  AnalyseName
End Sub

Private Sub cmbHighlight2_Click()
10  cbHighlight_Click
End Sub

Private Sub cmbList2_Click()
10  cbList_Click
End Sub

Private Sub cmbLocalise2_Click()
10  cbLocalise_Click
End Sub

Private Sub cmbMap_Click()
10  cbMap_Click
End Sub

'Private Sub cmbMinimize_Click()
'10  gbMinimized = True
'20  lFormHeight = Me.Height
'30  lFormWidth = Me.Width
'40  With Me
'        .Height = 38
'50      .Width = 105
'60      .cmbRestore.Visible = True
'        .lblSortNameAsc.Visible = False
'        .lblSortNameDesc.Visible = False
'    End With
'End Sub

Private Sub cmbPickup2_Click()
10  cbPickup_Click
End Sub

Private Sub cmbRefresh2_Click()
10  cbRefresh_Click
End Sub

Private Sub cmbRename_Click()
10  cbRename_Click
End Sub

Private Sub cmbReplace_Click()
10  cbReplace_Click
End Sub

Private Sub cmbRestore_Click()
10  If Not gbMinimized Then Exit Sub
20  With Me
30      .cmbRestore.Visible = False
40      .Height = lFormHeight
50      .Width = lFormWidth
60      .lblSortNameAsc.Visible = True
70      .lblSortNameDesc.Visible = True
80  End With
90  gbMinimized = False
End Sub

Private Sub cmbUnhide2_Click()
10  cbUnhide_Click
End Sub

Private Sub cmbUnName_Click()
10  cbUnName_Click
End Sub

Private Sub cmbUsed2_Click()
10  cbUsed_Click
End Sub

Private Sub cmbWizard_Click()
10  cbWizard_Click
End Sub

Private Sub lblCount_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single)
10  If Button = 1 Then
20      mbSplitterMoving = True
30      mdSplitterOrigin = Y
40  End If

End Sub

Private Sub lblCount_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single)

    Dim dChange As Double

    'Are we doing a drag?
10  If mbSplitterMoving Then

        'Find where we moved to
20      dChange = (Y - mdSplitterOrigin) / PointsPerPixel

        'Adjust the control sizes and positions to match the splitter
30      If (lbxNames.Height + dChange > 45) And (tbEditName.Height - dChange > 30) Then
40          lblCount.Top = lblCount.Top + dChange
50          lblRefersto.Top = lblRefersto.Top + dChange
60          lbxNames.Height = lbxNames.Height + dChange
70          tbEditName.Height = tbEditName.Height - dChange
80          tbEditName.Top = tbEditName.Top + dChange
90      End If
100 End If

End Sub

Private Sub lblCount_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single)
10  If Button = 1 Then mbSplitterMoving = False
End Sub

Private Sub lblSortNameDesc_Click()
10  RememberSelectedNames
20  If lblSortNameDesc.SpecialEffect = fmSpecialEffectSunken Then
        'No Sorting
30      lblSortNameDesc.SpecialEffect = fmSpecialEffectRaised
40      FindAllNames
50  Else
        'Sort by Name Descending
60      QuickSort gsNames, 1, UBound(gsNames), "Names", False
70      lblSortNameDesc.SpecialEffect = fmSpecialEffectSunken
80      lblSortNameAsc.SpecialEffect = fmSpecialEffectRaised
90      lblSortRefersDesc.SpecialEffect = fmSpecialEffectRaised
100     lblSortRefersAsc.SpecialEffect = fmSpecialEffectRaised
110 End If
120 ListTheNames
130 GetIndex
140 SetTopIndexAfterSort
150 SetHideUnhide
160 SetGlobLoc
End Sub

Private Sub lblSortNameAsc_Click()
10  RememberSelectedNames
20  If lblSortNameAsc.SpecialEffect = fmSpecialEffectSunken Then
30      lblSortNameAsc.SpecialEffect = fmSpecialEffectRaised
        'No Sorting
40      FindAllNames
50  Else
        'Sort by Name Ascending
60      QuickSort gsNames, 1, UBound(gsNames), "Names", True
70      lblSortNameDesc.SpecialEffect = fmSpecialEffectRaised
80      lblSortNameAsc.SpecialEffect = fmSpecialEffectSunken
90      lblSortRefersDesc.SpecialEffect = fmSpecialEffectRaised
100     lblSortRefersAsc.SpecialEffect = fmSpecialEffectRaised
110 End If
120 ListTheNames
130 GetIndex
140 SetTopIndexAfterSort
150 SetHideUnhide
160 SetGlobLoc
End Sub

Private Sub lblSortRefersDesc_Click()
10  RememberSelectedNames
20  If lblSortRefersDesc.SpecialEffect = fmSpecialEffectSunken Then
30      lblSortRefersDesc.SpecialEffect = fmSpecialEffectRaised
        'No Sorting
40      FindAllNames
50  Else
        'Sort by RefersTo Descending
60      QuickSort gsRefersto, 1, UBound(gsRefersto), "RefersTo", False
70      lblSortNameDesc.SpecialEffect = fmSpecialEffectRaised
80      lblSortNameAsc.SpecialEffect = fmSpecialEffectRaised
90      lblSortRefersDesc.SpecialEffect = fmSpecialEffectSunken
100     lblSortRefersAsc.SpecialEffect = fmSpecialEffectRaised
110 End If
120 ListTheNames
130 GetIndex
140 SetTopIndexAfterSort
150 SetHideUnhide
160 SetGlobLoc
End Sub

Private Sub lblSortRefersAsc_Click()
10  RememberSelectedNames
20  If lblSortRefersAsc.SpecialEffect = fmSpecialEffectSunken Then
30      lblSortRefersAsc.SpecialEffect = fmSpecialEffectRaised
        'No Sorting
40      FindAllNames
50  Else
        'Sort by RefersTo Ascending
60      QuickSort gsRefersto, 1, UBound(gsRefersto), "RefersTo", True
70      lblSortNameDesc.SpecialEffect = fmSpecialEffectRaised
80      lblSortNameAsc.SpecialEffect = fmSpecialEffectRaised
90      lblSortRefersDesc.SpecialEffect = fmSpecialEffectRaised
100     lblSortRefersAsc.SpecialEffect = fmSpecialEffectSunken
110 End If
120 ListTheNames
130 GetIndex
140 SetTopIndexAfterSort
150 SetHideUnhide
160 SetGlobLoc
End Sub

Private Sub lblSplitterBar_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
10  gbFixSplit = False
20  RememberSelectedNames
30  ListTheNames
40  GetIndex
End Sub

Private Sub lbxFilter_KeyUp(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
'
' added keyup event crw 1/1/2003
'
10  If gbDisableEvents Then Exit Sub
    ' JKP July 11, 2003: added Home ane End key.
20  If KeyCode <> vbKeyUp And KeyCode <> vbKeyDown And KeyCode <> vbKeyEnd And KeyCode <> vbKeyHome Then Exit Sub
30  PushStack3 "lbxFilter_KeyUp"
40  gbDisableEvents = True
    '
    ' crw 23 April 2014 : Tables
    '
50  If Not gbFxl And (Me.lbxFilter.Selected(1) Or Me.lbxFilter.Selected(2)) Then
60      MsgBox "Sorry, filtering Table Names is only available in FastExcel", vbOKOnly + vbInformation, gsAppName
70      Me.lbxFilter.Selected(1) = False
80      Me.lbxFilter.Selected(2) = False
90  End If

    'JKP 21 Oct 2005: added a blank last entry,
    '                 prevent selecting of that one and restore last filter settings

100 If Me.lbxFilter.Selected(Me.lbxFilter.ListCount - 1) Then
110     Me.lbxFilter.Selected(Me.lbxFilter.ListCount - 1) = False
120     SetFilters
130     GoTo GoExit
140 End If


150 CheckFixNames                                     ''' crw Jan 3 2003
160 gbUnUsed = False                                  ''' switch off unused crw 7/1/2003
170 Me.cbUnused = False
180 ToggleScope
190 ListTheNames
200 If Me.lbxNames.ListCount = 0 Then
210     DisableThings
220 Else
230     EnableThings
240 End If
    ' crw Nov 4
250 GetIndex
260 SetTopIndexAfterSort
270 SetHideUnhide
280 SetGlobLoc                                        ''' crw nov 11 2002
290 gbListChanged = False
300 gbDisableEvents = False
GoExit:
310 PopStack3
End Sub

Private Sub lbxFilter_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single)

' changed to mouseup event crw 27/12/2002

10  If gbDisableEvents Then Exit Sub
20  gbDisableEvents = True

    'JKP 21 Oct 2005: added a blank last entry,
    '                 prevent selecting of that one and restore last filter settings
30  PushStack3 "lbxFilter_MouseUp"
    '
    ' crw 23 April 2014 : Tables
    '
40  If Not gbFxl And (Me.lbxFilter.Selected(1) Or Me.lbxFilter.Selected(2)) Then
50      MsgBox "Sorry, filtering Table Names is only available in FastExcel", vbOKOnly + vbInformation, gsAppName
60      Me.lbxFilter.Selected(1) = False
70      Me.lbxFilter.Selected(2) = False
80  End If

90  If Me.lbxFilter.Selected(Me.lbxFilter.ListCount - 1) Then
100     Me.lbxFilter.Selected(Me.lbxFilter.ListCount - 1) = False
110     SetFilters
120     GoTo GoExit
130 End If

140 CheckFixNames                                     ''' crw Jan 3 2003
150 gbUnUsed = False                                  ''' switch off unused crw 7/1/2003
160 Me.cbUnused = False
170 ToggleScope
180 ListTheNames
190 If Me.lbxNames.ListCount = 0 Then
200     DisableThings
210 Else
220     EnableThings
230 End If
    ' crw Nov 4
240 GetIndex
250 SetTopIndexAfterSort
260 SetHideUnhide
270 SetGlobLoc                                        ''' crw nov 11 2002
GoExit:
280 gbListChanged = False
290 gbDisableEvents = False
300 PopStack3
End Sub

Private Sub lbxNames_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
10  GoActiveName
End Sub

Private Sub lbxNames_KeyUp(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
    Dim sNewName As String
    Dim sOldName As String
    '
    ' Copyright Decision Models 2002-2010. All Rights Reserved
    ' name selection: keystrokes
    '
10  PushStack3 "lbxNames_Keyup"
    ' Only get selected names when either no shift is being held, or when shift is released
20  If KeyCode = 16 Or Shift = 0 Then
30      DoNameSelected
40  End If
    'JKP Build 626: changed to refer directly to click events of action buttons
    'so all actions are taken appropriately
50  If KeyCode = 113 Then
60      cbRename_Click
70  End If
80  If KeyCode = 46 Then
90      cbDelete_Click
100 End If
GoExit:
110 PopStack3
End Sub

Private Sub lbxNames_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single)
'
' Copyright Decision Models 2002-2010. All Rights Reserved
' name selection: Mouse clicks
'
10  PushStack3 "lbxNames_Mouseup"
20  DoNameSelected
GoExit:
30  PopStack3
End Sub

Private Sub lbxOptions_Change()
    Dim bChanged As Boolean

    ' CRW: removed GOTO option 9/2/2010

10  If gbDisableEvents Then Exit Sub
20  PushStack3 "lbxOptionsChange"
30  gbDisableEvents = True

40  With Me.lbxOptions
50      gbAcknowledge = .Selected(0)
        'gbGoTo = .Selected(1)
        '70            If bSort <> .Selected(2) Then
        '80                bSort = .Selected(2)
        '90                bChanged = True
        '100           End If
60      If gbShowSysNames <> .Selected(1) Then
70          gbShowSysNames = .Selected(1)
80          bChanged = True
90      End If
100     If gbShowRefersto <> .Selected(2) Then
110         gbShowRefersto = .Selected(2)
120         bChanged = True
130     End If
140     If .Selected(3) Then
150         If glR1C1 = xlA1 Then
160             Application.ReferenceStyle = xlR1C1
170             glR1C1 = xlR1C1
180             bChanged = True
190         End If
200     Else
210         If glR1C1 = xlR1C1 Then
220             Application.ReferenceStyle = xlA1
230             glR1C1 = xlA1
240             bChanged = True
250         End If
260     End If
270     gbIconButtons = .Selected(4)
280     ChangButtons gbIconButtons
290     SaveSettings
300     If bChanged Then
310         FindAllNames
320         ListTheNames
330         Me.lblSortRefersAsc.Enabled = gbShowRefersto
340         Me.lblSortRefersDesc.Enabled = gbShowRefersto
            '
            ' fix for r1c1 mode change
            '
            ' fix for mode change with nonames in workbook: crw 24/9/2005
            '
350         If glActive <> 0 Then
360             On Error Resume Next
370             Me.tbEditName = gsRefersto(glActive)
                '
                ' fix for mode change with relative: crw 20/10/2005
                '
380             ShowlblRefersto                       ''' change the name refersto label
390             On Error GoTo 0
400         End If
410     End If
420 End With
430 gbDisableEvents = False
440 PopStack3
End Sub

'Private Sub lbxShow_Click()
'10  If gbDisableEvents Then Exit Sub
'20  gbDisableEvents = True
'30  PushStack3 "lbxShow_Click"
'40  CheckFixNames   ''' crw Jan 3 2003
'50  gbUnUsed = False             ''' switch off unused crw 7/1/2003
'60  Me.cbUnUsed = False
'70  ToggleScope
'80  ListTheNames
'90  If Me.lbxNames.ListCount = 0 Then
'100     DisableThings
'110 Else
'120     EnableThings
'130 End If
'140 GetIndex
'    SetTopIndexAfterSort
'150 SetHideUnhide           ' crw nov 4 2002
'160 SetGlobLoc          ''' crw nov 11 2002
'170 gbListChanged = False
'180 gbDisableEvents = False
'GoExit:
'190 PopStack3
'End Sub

Private Sub lbxShow_KeyUp(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
10  If gbDisableEvents Then Exit Sub
20  gbDisableEvents = True
30  PushStack3 "lbxShow_KeyUp"
40  With Me.lbxShow
50      If .ListIndex = .ListCount - 1 Then
60          If gbAllNames Then .ListIndex = 0
70          If gbGlobal Then .ListIndex = 1
80          If gbLocalAll Then .ListIndex = 2
90          If gbLocalActive Then .ListIndex = 3
100     End If
110 End With
120 CheckFixNames                                     ''' crw Jan 3 2003
130 gbUnUsed = False                                  ''' switch off unused crw 7/1/2003
140 Me.cbUnused = False
150 ToggleScope
160 ListTheNames
170 If Me.lbxNames.ListCount = 0 Then
180     DisableThings
190 Else
200     EnableThings
210 End If
220 GetIndex
230 SetTopIndexAfterSort
240 SetHideUnhide                                     ' crw nov 4 2002
250 SetGlobLoc                                        ''' crw nov 11 2002
260 gbListChanged = False
270 gbDisableEvents = False
GoExit:
280 PopStack3

End Sub

Private Sub lbxShow_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single)
10  If gbDisableEvents Then Exit Sub
20  gbDisableEvents = True
30  PushStack3 "lbxShow_MouseUp"
40  With Me.lbxShow
50      If .ListIndex = .ListCount - 1 Then
60          If gbAllNames Then .ListIndex = 0
70          If gbGlobal Then .ListIndex = 1
80          If gbLocalAll Then .ListIndex = 2
90          If gbLocalActive Then .ListIndex = 3
100     End If
110 End With
120 CheckFixNames                                     ''' crw Jan 3 2003
130 gbUnUsed = False                                  ''' switch off unused crw 7/1/2003
140 Me.cbUnused = False
150 ToggleScope
160 ListTheNames
170 If Me.lbxNames.ListCount = 0 Then
180     DisableThings
190 Else
200     EnableThings
210 End If
220 GetIndex
230 SetTopIndexAfterSort
240 SetHideUnhide                                     ' crw nov 4 2002
250 SetGlobLoc                                        ''' crw nov 11 2002
260 gbListChanged = False
270 gbDisableEvents = False
GoExit:
280 PopStack3

End Sub

Private Sub obtAnd_Click()
10  If gbDisableEvents Then Exit Sub
20  gbDisableEvents = True
30  gbOrFilters = False
40  ListTheNames
50  gbDisableEvents = False
End Sub

Private Sub obtOr_Click()
10  If gbDisableEvents Then Exit Sub
20  gbDisableEvents = True
30  gbOrFilters = True
40  ListTheNames
50  gbDisableEvents = False
End Sub

Private Sub tbContains_AfterUpdate()
'
' crw Oct 31 : overlap and selectedceslls only on whole field
'
' JKP Feb 6 2003: Added check for amount of names
10  If gbOverlap Or gbSelectedCells Or gbRefsActiveSheet Or glNameCount > 100 Then
20      If gbDisableEvents Then Exit Sub
30      gbDisableEvents = True
40      PushStack3 "tbContains_AfterUpdate"
50      gsContains = Me.tbContains.Value
60      If gsContains = "" Then
70          gbContains = False
80          Me.cbContaining = False
90      Else
100         gbContains = True
110         Me.cbContaining = True
120     End If
130     gbUnUsed = False                              ''' switch off unused crw 7/1/2003
140     Me.cbUnused = False
150     ListTheNames
160     GetIndex
170     If Me.lbxNames.ListCount = 0 Then
180         DisableThings
190     Else
200         EnableThings
210     End If
220     SetHideUnhide                                 ' crw nov 4 2002
230     SetGlobLoc                                    ''' crw nov 11 2002
240     gbDisableEvents = False
GoExit:
250     PopStack3
260 End If
End Sub

Private Sub tbContains_Change()
'
' crw Oct 31 : overlap and selectedceslls only on whole field
'
' JKP Feb 5 2003: Added restriction for many names

10  If Not (gbOverlap Or gbSelectedCells Or gbRefsActiveSheet Or glNameCount > 100) Then
20      If gbDisableEvents Then Exit Sub
30      PushStack3 "tbContains_Change"
40      gbDisableEvents = True
50      gsContains = Me.tbContains.Value
60      If gsContains = "" Then
70          gbContains = False
80          Me.cbContaining = False
90      Else
100         gbContains = True
110         Me.cbContaining = True
120     End If
130     gbUnUsed = False                              ''' switch off unused crw 7/1/2003
140     Me.cbUnused = False
150     ListTheNames
160     GetIndex
170     If Me.lbxNames.ListCount = 0 Then
180         DisableThings
190     Else
200         EnableThings
210     End If
220     SetHideUnhide
230     SetGlobLoc                                    ''' crw nov 11 2002
GoExit:
240     PopStack3
250 End If
End Sub

Private Sub tbEditName_AfterUpdate()
'
' update the refersto if it has changed
'
10  If gbChangedRefersTo = False Then Exit Sub
20  If gbDisableEvents Then Exit Sub
30  PushStack3 "tbEditName_AfterUpdate"
40  DoNameAfterUpdate
50  SetTopIndex
GoExit:
60  PopStack3
End Sub

Private Sub tbEditName_Change()
'
' the text in the refersto box has changed
' so check for relative and >240 characters
'
10  If gbDisableEvents Then Exit Sub
20  PushStack3 "tbEditName_Change"
30  DoNameCharChanged
GoExit:
40  PopStack3
End Sub

Private Sub tbEditName_Enter()
'
' the user has clicked in the refersto box
'

10  If gbDisableEvents Then Exit Sub
20  PushStack3 "tbEditName_Enter"
30  gbChangedRefersTo = True
40  GetTopIndex
    'crw 30 July 2003 only check cell if relative
    ' crw 03 Oct 2009 only check if realtive and A1 mode
50  If gbIsRelative And glR1C1 = xlA1 Then
        'JKP july 7 2003: fixed problems with getrightactivecell
60      If Not gbActiveCellChecked Then
70          Me.Hide
80          GetRightActiveCell
90          If Val(Application.Version) = 8 Or gbMacOS = True Then
100             gbDisableEvents = False
110             Me.Show
120         Else
130             ShowModeless
140         End If
150     End If
160 End If
170 gbDisableEvents = False
GoExit:
180 PopStack3
End Sub

Sub InitializeUF()
10  If gbDisableEvents Then Exit Sub
20  PushStack3 "UfNameManager_InitializeUF"
30  gbDisableEvents = True
40  gbMinimized = False
50  Me.Height = 428
    'JKP Apr 6 2006:  Position buttons
60  ChangButtons gbIconButtons
70  Me.cmbRestore.Visible = False

80  Me.cbHelp.Enabled = True
90  Me.cbWizard.Enabled = True
100 Me.cbMap.Enabled = True
110 Me.cbNot.Enabled = True
120 Me.cbReplace.Enabled = True
130 Me.cbUnName.Enabled = True
140 Me.cmbHelp.Enabled = True
150 Me.cmbWizard.Enabled = True
160 Me.cmbMap.Enabled = True
170 Me.cmbReplace.Enabled = True
180 Me.cmbUnName.Enabled = True
190 If Val(Application.Version) >= 15 Then
200     mhwndForm = FindWindow32("ThunderDFrame", Caption)
210     If xlApp Is Nothing Then Set xlApp = Excel.Application
220 End If


230 gbInvertFilters = Me.cbNot
    '
    ' crw adapt for jan-karel's listboxes
    '
    'gbContains = False
    '
    ' crw jan 5 2003: Unused checkbox
    '
240 Me.cbUnused = False
250 gbUnUsed = False
260 With Me

        '
        ' CRW  12/2/2010
        '
270     If Not ActiveWorkbook Is Nothing Then
280         .Caption = gsAppName & " - " & ActiveWorkbook.Name
290     Else
300         .Caption = gsAppName
310     End If
320     .cbContaining = gbContains                    ''' crw 7/1/2003
        '.lbxNames.Height = 166         ''' crw 7/10/2005
330     If gbContains Then
340         .tbContains = gsContains
350     Else
360         .tbContains = ""
370     End If
380     .obtAnd = Not gbOrFilters

390     If gbMacOS Then
400         If gbMacX Then
410             .lbxNames.Height = 210
420         Else
430             .lbxNames.Height = 215
440         End If
450     End If
        '  JKP Sept 8 2003
460     SetTexts
470     .tbEditName.Enabled = True
480     .lblRefersto.Visible = True
490     .lbxNames.Clear
500     If gbAllNames Then .lbxShow.ListIndex = 0
510     If gbGlobal Then .lbxShow.ListIndex = 1
520     If gbLocalAll Then .lbxShow.ListIndex = 2
530     If gbLocalActive Then .lbxShow.ListIndex = 3
        '
        ' crw dec 27 2002 : multiselect filter
        '
        'JKP, kludge to overcome the effect of selecting
        'all entries between (0) and the one clicked.
        'This only happened at first start of Name Manager.
540     .lbxFilter.SetFocus
550     .lbxNames.SetFocus
560     SetFilters
        '
        ' CRW removed GoTo option 9/2/2010
        '
570     With .lbxOptions
580         .Selected(0) = gbAcknowledge
            '.Selected(1) = gbGoTo
            '550         .Selected(2) = bSort
590         .Selected(1) = gbShowSysNames
600         .Selected(2) = gbShowRefersto
610         .Selected(3) = (Application.ReferenceStyle = xlR1C1)
620         .Selected(4) = gbIconButtons
630     End With
640     glR1C1 = Application.ReferenceStyle
650     If gbOverlap Then
660         .lblColumn2.Caption = gsTxtufNameManager(43)
670     Else
680         .lblColumn2.Caption = gsTxtufNameManager(17)
690     End If
700     ListTheNames
710     If .lbxNames.ListCount = 0 Then
720         DisableThings
730     Else
740         EnableThings
750     End If
        ' crw nov 4 2002
760 End With

770 GetIndex
780 SetHideUnhide
790 SetGlobLoc                                        ''' crw nov 11 2002
800 SetTopIndexAfterSort
    'JKP Sep 19 2003: moved this bit because otherwise listindex(0) is always selected

810 If funCountSelected = 0 Then
820     glActive = 1
        '
        ' crw 17/9/2003 use selected if multiselect
        '
830     If Me.lbxNames.MultiSelect = fmMultiSelectSingle Then
840         Me.lbxNames.ListIndex = 0
850     Else
860         If Me.lbxNames.ListCount <> 0 Then
870             Me.lbxNames.Selected(0) = True
880             Me.tbEditName.Enabled = True
890         End If
900     End If
910 End If


920 gbDisableEvents = False

930 NameAppTrap2                                      ''' crw Jan 8 2003 enable application events

    'Adaptation for Mac (Matthew Henson 6 Dec 03)
    'Have already tested for platform, now adjust form if running on Mac
940 If gbMacOS = True Then
950     If gbMacDone Then GoTo GoExit
960     gbMacDone = True
970     On Error Resume Next                          'in case control has no font property
980     For Each gctlLocalControl In Me.Controls
990         With gctlLocalControl.Font
1000            .Size = 10
1010            .Name = "Geneva"
1020        End With
1030    Next gctlLocalControl
1040    With Me.fraFilter.Font
1050        .Size = 9
1060        .Bold = True
1070    End With
1080    On Error GoTo 0
1090    If gbMacX = False Then
            'procedure if running on Excel 8 or 9 (98 or 2001)
            'qwert
1100        With Me
1110            .Height = 420
1120            .Width = 557
                'These two items retain horizontal settings already made by the ListTheNames procedure
1130            With .lblColumn1
1140                .Top = 6
1150                .Height = 13
1160                If Not gbShowRefersto And Not gbOverlap Then _
                       .Width = .Width + 360 - lbxNames.Width    'the 360 (added by hand) as the eventual width of lbxNames
1170            End With
1180            With .lblColumn2
1190                .Top = 6
1200                .Height = 13
1210                If gbShowRefersto Or gbOverlap Then
1220                    .Width = .Width + 360 - lbxNames.Width    'the 360 (added by hand) as the eventual width of lbxNames
1230                Else
1240                    .Width = 0
1250                End If
1260            End With
1270            Me.lblSortRefersAsc.Enabled = gbShowRefersto
1280            Me.lblSortRefersDesc.Enabled = gbShowRefersto
1290            .cbAdd.Move 81, 333, 64, 26
1300            .cbClose.Move 475, 360, 64, 26
1310            .cbContaining.Move 6, 259, 150, 18
1320            .cbDelete.Move 81, 360, 64, 26
1330            .cbEvaluate.Move 306, 333, 64, 26
1340            .cbGlobalise.Move 156, 360, 64, 26
1350            .cbHide.Move 6, 333, 64, 26
1360            .cbLocalise.Move 156, 333, 64, 26
1370            .cbRefresh.Move 400, 360, 64, 26
1380            .cbUnhide.Move 6, 360, 64, 26
1390            .cbUnused.Move 6, 298, 150, 19
1400            .cbUsed.Move 231, 333, 64, 26
1410            .cbAnalyse.Move 306, 360, 64, 26
1420            .fraFilter.Move 371, 2, 167, 325
1430            .Label1.Move 13, 75, 85, 13
1440            .Label2.Move 13, 6, 99, 13
1450            .lblCount.Move 6, 244, 141, 14
1460            .lblRefersto.Move 6, 265, 120, 13
1470            .lbxFilter.Move 4, 105, 155, 152
1480            .lbxNames.Move 6, 24, 360, 215        'to match value above
1490            .lbxShow.Move 4, 18, 155, 53
1500            .obtAnd.Move 18, 87, 50, 18
1510            .obtOr.Move 60, 87, 50, 18
1520            .tbContains.Move 4, 277, 155, 19
1530            .tbEditName.Move 6, 278, 360, 49

1540            .lblCount.Top = .lbxNames.Top + .lbxNames.Height + 1    '(by hand, to fit ListTheNames)

1550        End With
1560    Else
            'procedure if running on Excel 10 (Excel X)
1570        With Me
1580            .Height = 428
1590            .Width = 550
1600            With .lblColumn1
1610                .Top = 8
1620                .Height = 13
1630                If Not gbShowRefersto And Not gbOverlap Then _
                       .Width = .Width + 360 - lbxNames.Width    'the 360 (added by hand) as the eventual width of lbxNames
1640            End With
1650            With .lblColumn2
1660                .Top = 8
1670                .Height = 13
1680                If gbShowRefersto Or gbOverlap Then
1690                    .Width = .Width + 360 - lbxNames.Width    'the 360 (added by hand) as the eventual width of lbxNames
1700                Else
1710                    .Width = 0
1720                End If
1730            End With
1740            .cbAdd.Move 81, 341, 59, 22
1750            .cbClose.Move 484, 373, 59, 22
1760            .cbContaining.Move 3, 261, 158, 20
1770            .cbDelete.Move 81, 373, 59, 22
1780            .cbEvaluate.Move 306, 341, 59, 22
1790            .cbGlobalise.Move 156, 373, 59, 22
1800            .cbHide.Move 6, 341, 59, 22
1810            .cbLocalise.Move 156, 341, 59, 22
1820            .cbRefresh.Move 409, 373, 59, 22
1830            .cbUnhide.Move 6, 373, 59, 22
1840            .cbUnused.Move 3, 300, 158, 20
1850            .cbUsed.Move 231, 341, 59, 22
1860            .cbAnalyse.Move 306, 373, 59, 22
1870            .fraFilter.Move 371, 2, 173, 330
1880            .Label1.Move 12, 75, 85, 13
1890            .Label2.Move 12, 6, 99, 13
1900            .lblCount.Move 6, 234, 141, 14
1910            .lblRefersto.Move 6, 260, 350, 13
1920            .lbxFilter.Move 4, 108, 161, 152
1930            .lbxNames.Move 6, 24, 360, 210
1940            .lbxShow.Move 4, 19, 161, 53
1950            .obtAnd.Move 18, 89, 50, 18
1960            .obtOr.Move 69, 89, 50, 18
1970            .tbContains.Move 4, 280, 161, 20
1980            .tbEditName.Move 6, 278, 360, 54

1990            .lblCount.Top = .lbxNames.Top + .lbxNames.Height + 1    '(by hand, to fit ListTheNames)
2000        End With
2010    End If
2020 End If
GoExit:

2030 PopStack3
End Sub

Private Sub UserForm_Activate()
10  If Val(Application.Version) > 8 Or Application.International(xlDecimalSeparator) = "." Then
        'JKP Build 554:
        'If we have Excel 97 and a different separator from the dot,
        'don't make this form resize to prevent trouble with the dot key
        'on the num keypad
        'Create the instance of the class
20      If mclsResizer Is Nothing Then
30          Set mclsResizer = New CFormResizer

            'Tell it where to store the form dimensions
40          mclsResizer.RegistryKey = gsFxlNameRegKey     ''' crw 18/10/2005

            'Tell it which form it's handling
50          Set mclsResizer.Form = Me
60      End If
70  End If
End Sub

Sub ResetResizer()
'
' CRW 20/2/10
' reset the resizer after the form titlebar has been reset
'
10  Set mclsResizer = Nothing
20  UserForm_Activate
End Sub

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Comments: When the form is resized, the UserForm_Resize event
'           is raised, which we just pass on to the Resizer class
'
' Date          Developer       Action
' --------------------------------------------------------------
' 07 Oct 04     Stephen Bullen  Initial version
'
Private Sub UserForm_Resize()
10  If mclsResizer Is Nothing Then Exit Sub
20  If gbMinimized Or Me.InsideHeight <= 0 Or Me.Height < 38 Then
        'Me.Height = 38
        'Me.Width = 105
30  Else
40      mclsResizer.FormResize
50  End If

End Sub

Private Sub SetFilters()
'
' CRW 24 April 2014 Tables
10  With Me.lbxFilter
20      .Selected(0) = gbNoFilter
30      .Selected(1) = gbShowNames
40      .Selected(2) = gbShowTables
50      .Selected(3) = gbExternal
60      .Selected(4) = gbError
70      .Selected(5) = gbShowHidden
80      .Selected(6) = gbShowVisible
90      .Selected(7) = gbShow3D
100     .Selected(8) = gbMultiArea
110     .Selected(9) = gbFormula
120     .Selected(10) = gbRelative
130     .Selected(11) = gbSelectedCells
140     .Selected(12) = gbOverlap
150     .Selected(13) = gbDuplicate
160     .Selected(14) = gbRefsActiveSheet
170 End With
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
'JKP Build 587: prevent errors here
10  On Error Resume Next
    ' crw dec 19 2002
20  PushStack3 "UserForm_QueryClose"

30  If Val(Application.Version) > 8 Or Application.International(xlDecimalSeparator) = "." Then
        'SB 07 Oct 04
40      cmbRestore_Click
50      If Not mclsResizer Is Nothing Then mclsResizer.FormResize
60  End If
    '
    ' crw 20/9/2006
    '
    'JKP Build 613: always do this part!
    '60  If CloseMode <> vbFormCode Then
70  If Not mclsResizer Is Nothing Then mclsResizer.FormResize
    'If Not mclsResizer Is Nothing Then Set mclsResizer = Nothing
    'Me.Hide
80  Set mclsResizer = Nothing
90  Unload Me
100 Set gfrmNameManager = Nothing
    'JKP Jan 10 2003 set to false to stop workbookchange event handler
110 gbFormIsShowing = False
120 gbDisableEvents = False
130 Cancel = False                                    ''' crw 20/9/2006
140 Application.Cursor = xlDefault
150 Application.Calculation = glCalcMode
    '150 End If
160 PopStack3
End Sub

Private Sub SetTexts()
'
' crw 23 April 2014 Tables
'
    Dim iCount As Long
10  PushStack3 "settexts"
20  With Me
30      .cbClose.Caption = gsTxtufNameManager(1)
40      .cbClose.ControlTipText = gsTxtufNameManager(2)
50      .tbEditName.ControlTipText = gsTxtufNameManager(3)
60      .cmbDelete2.Caption = gsTxtufNameManager(4)
70      .cmbDelete2.ControlTipText = gsTxtufNameManager(5)
80      .cbDelete.ControlTipText = gsTxtufNameManager(5)
90      .cmbAdd2.Caption = gsTxtufNameManager(6)
100     .cbAdd.ControlTipText = gsTxtufNameManager(7)
110     .cmbAdd2.ControlTipText = gsTxtufNameManager(7)
120     .lblRefersto.Caption = gsTxtufNameManager(8)
130     .lblRefersto.ControlTipText = gsTxtufNameManager(9)
140     .cmbHide2.Caption = gsTxtufNameManager(10)
150     .cbHide.ControlTipText = gsTxtufNameManager(11)
160     .cmbHide2.ControlTipText = gsTxtufNameManager(11)
170     .cmbUnhide2.Caption = gsTxtufNameManager(12)
180     .cbUnhide.ControlTipText = gsTxtufNameManager(13)
190     .cmbUnhide2.ControlTipText = gsTxtufNameManager(13)
200     .cmbEvaluate2.Caption = gsTxtufNameManager(14)
210     .cbEvaluate.ControlTipText = gsTxtufNameManager(15)
220     .cmbEvaluate2.ControlTipText = gsTxtufNameManager(15)
230     .lblColumn1.Caption = gsTxtufNameManager(16)
240     .lblColumn2.Caption = gsTxtufNameManager(17)
250     .cmbLocalise2.Caption = gsTxtufNameManager(18)
260     .cbLocalise.ControlTipText = gsTxtufNameManager(19)
270     .cmbLocalise2.ControlTipText = gsTxtufNameManager(19)
280     .cmbGlobalise2.Caption = gsTxtufNameManager(20)
290     .cbGlobalise.ControlTipText = gsTxtufNameManager(21)
300     .cmbGlobalise2.ControlTipText = gsTxtufNameManager(21)
310     .cmbRefresh2.Caption = gsTxtufNameManager(22)
320     .cbRefresh.ControlTipText = gsTxtufNameManager(23)
330     .cmbRefresh2.ControlTipText = gsTxtufNameManager(23)
340     .lbxNames.ControlTipText = gsTxtufNameManager(24)
350     .fraFilter.Caption = gsTxtufNameManager(25)
360     .fraFilter.ControlTipText = gsTxtufNameManager(26)
370     .tbContains.ControlTipText = gsTxtufNameManager(27)
380     .cbContaining.Caption = gsTxtufNameManager(28)
390     .cbContaining.ControlTipText = gsTxtufNameManager(29)
400     .Label2.Caption = gsTxtufNameManager(30)
410     .Label2.ControlTipText = gsTxtufNameManager(31)
420     .Label1.Caption = gsTxtufNameManager(32)
430     .Label1.ControlTipText = gsTxtufNameManager(33)
440     .lbxShow.ControlTipText = gsTxtufNameManager(34)
450     .lbxFilter.ControlTipText = gsTxtufNameManager(35)
460     .cbUnused.Caption = gsTxtufNameManager(36)
470     .cbUnused.ControlTipText = gsTxtufNameManager(37)
480     .cmbUsed2.Caption = gsTxtufNameManager(38)
490     .cbUsed.ControlTipText = gsTxtufNameManager(39)
500     .cmbUsed2.ControlTipText = gsTxtufNameManager(39)
510     .cbHelp.Caption = gsTxtufNameManager(40)
520     .obtAnd.Caption = gsTxtufNameManager(60)
530     .obtAnd.ControlTipText = gsTxtufNameManager(61)
540     .obtOr.Caption = gsTxtufNameManager(62)
550     .obtOr.ControlTipText = gsTxtufNameManager(63)
560     .cmbAnalyse2.Caption = gsTxtufNameManager(64)
570     .cbAnalyse.ControlTipText = gsTxtufNameManager(65)
580     .cmbAnalyse2.ControlTipText = gsTxtufNameManager(65)
590     .cmbList2.Caption = gsTxtufNameManager(66)
600     .cbList.ControlTipText = gsTxtufNameManager(67)
610     .cmbList2.ControlTipText = gsTxtufNameManager(67)
620     .cmbPickup2.Caption = gsTxtufNameManager(68)
630     .cbPickup.ControlTipText = gsTxtufNameManager(69)
640     .cmbPickup2.ControlTipText = gsTxtufNameManager(69)
        '        .cmbMore.Caption = gsTxtufNameManager(70)
        '       .cmbMore.ControlTipText = gsTxtufNameManager(72)
650     .cmbHighlight2.Caption = gsTxtufNameManager(73)
660     .cbHighlight.ControlTipText = gsTxtufNameManager(74)
670     .cmbHighlight2.ControlTipText = gsTxtufNameManager(74)
680     .cmbClearHighlight2.Caption = gsTxtufNameManager(75)
690     .cbClearHighlight.ControlTipText = gsTxtufNameManager(76)
700     .cmbClearHighlight2.ControlTipText = gsTxtufNameManager(76)
        '.cmbMinimize.ControlTipText = gsTxtufNameManager(77)
710     .cmbRestore.Caption = gsTxtufNameManager(78)
720     .cmbRestore.ControlTipText = gsTxtufNameManager(79)
        '
        ' CRW: removed GoTo option 9/2/2010
        '
730     .lbxOptions.Clear
740     .lbxOptions.AddItem gsTxtufNameManager(80)
        '750     .lbxOptions.AddItem gsTxtufNameManager(81) ' goto
        '490     .lbxOptions.AddItem gsTxtufNameManager(82)
750     .lbxOptions.AddItem gsTxtufNameManager(83)
760     .lbxOptions.AddItem gsTxtufNameManager(84)
770     .lbxOptions.AddItem gsTxtufNameManager(85)
780     .lbxOptions.AddItem gsTxtufNameManager(100)

790     .cbbLang.ControlTipText = gsTxtufNameManager(86)
800     .cmbAbout2.Caption = gsTxtufNameManager(88)
810     .cbAbout.ControlTipText = gsTxtufNameManager(89)
820     .cmbAbout2.ControlTipText = gsTxtufNameManager(89)
830     .lbxOptions.ControlTipText = gsTxtufNameManager(90)
840     .lblSortNameDesc.ControlTipText = gsTxtufNameManager(91)
850     .lblSortNameAsc.ControlTipText = gsTxtufNameManager(92)
860     .lblSortRefersDesc.ControlTipText = gsTxtufNameManager(93)
870     .lblSortRefersAsc.ControlTipText = gsTxtufNameManager(94)
880     .cbNot.Caption = gsTxtufNameManager(95)
890     .cbNot.ControlTipText = gsTxtufNameManager(96)
900     .lblSplitterBar.ControlTipText = gsTxtufNameManager(97)
910     .lblCount.ControlTipText = gsTxtufNameManager(98)
920     .cbUnName.Caption = gsTxtufNameManager(101)
930     .cbUnName.ControlTipText = gsTxtufNameManager(102)
940     .cmbUnName.Caption = gsTxtufNameManager(101)
950     .cmbUnName.ControlTipText = gsTxtufNameManager(102)
960     With .cbbLang
            'If gbFxl Then
            '    .Visible = False
            'Else
970         .Visible = True
980         .Clear
            '
            ' CRW 4/11/2010 Auto
            '
990         .AddItem "Auto"
1000        For iCount = 1 To UBound(gsTxtLang)
1010            If gsTxtLang(iCount) = "" Then Exit For
1020            .AddItem gsTxtLang(iCount)
1030        Next
1040        .ListIndex = giLang + 1
            'End If
1050    End With

1060 End With
1070 Me.lbxShow.Clear
1080 Me.lbxFilter.Clear
1090 With Me.lbxShow
1100    For iCount = 44 To 47
1110        .AddItem gsTxtufNameManager(iCount)
1120    Next
1130    .AddItem " "
1140 End With
1150 With Me.lbxFilter
1160    .AddItem gsTxtufNameManager(48)             ''' all
1170    .AddItem gsTxtufNameManager(103)     ''' defined names only
1180    .AddItem gsTxtufNameManager(104)     ''' table names only
1190    For iCount = 49 To 59
1200        .AddItem gsTxtufNameManager(iCount)
1210    Next
        '
        ' crw 18 October 2005 temp fix
        '
1220    .AddItem gsTxtufNameManager(99)               'Active sheet
1230    .AddItem " "                                  'blank line
1240 End With
1250 PopStack3
End Sub

''''''''''''''''''''''''''''''''''''''''''''''''''
' Code to Implement the Splitter Bar Follows
''''''''''''''''''''''''''''''''''''''''''''''''''


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Comments: When pressing down the left mouse button over the label,
'           initiate the dragging and remember where we started
'
' Date          Developer       Action
' --------------------------------------------------------------
' 07 Oct 04     Stephen Bullen  Created
'
Private Sub lblSplitterBar_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single)
10  If Button = 1 Then
20      mbSplitterMoving = True
30      mdSplitterOrigin = x
40      RememberSelectedNames
50  End If
End Sub

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Comments: When releasing the left mouse button, stop the dragging
'
' Date          Developer       Action
' --------------------------------------------------------------
' 07 Oct 04     Stephen Bullen  Created
'
Private Sub lblSplitterBar_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single)
10  If Button = 1 Then
20      mbSplitterMoving = False
30      GetIndex
40  End If
End Sub

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Comments: When moving the mouse over the label and we're in
'           'drag' mode (i.e. dragging the splitter), move all
'           the controls appropriately
'
' Date          Developer       Action
' --------------------------------------------------------------
' 07 Oct 04     Stephen Bullen  Created
' 18 Oct 04     Charles Williams remember splitter bar position
'
Private Sub lblSplitterBar_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single)

    Dim dChange As Double

    'Are we doing a drag?
10  If mbSplitterMoving Then
20      GetTopIndex
        'Find where we moved to
30      dChange = (x - mdSplitterOrigin) / PointsPerPixel

        'Adjust the control sizes and positions to match the splitter
40      If (lblColumn1.Width + dChange > 70) And (lblColumn2.Width - dChange > 70) Then

            'The left label changes size
50          lblColumn1.Width = lblColumn1.Width + dChange

            'The left sort buttons move
60          lblSortNameDesc.Left = lblSortNameDesc.Left + dChange
70          lblSortNameAsc.Left = lblSortNameAsc.Left + dChange

            'The splitter bar in the middle moves
80          lblSplitterBar.Left = lblSplitterBar.Left + dChange

            ' remember the splitter bar position

90          glLastSplitLeft = lblSplitterBar.Left
100         gbFixSplit = True
            'The right label moves and changes size
110         lblColumn2.Left = lblColumn2.Left + dChange
120         lblColumn2.Width = lblColumn2.Width - dChange

            'The list box columns change
130         lbxNames.ColumnWidths = Int(lblColumn1.Width) & Mid$(lbxNames.ColumnWidths, InStr(1, lbxNames.ColumnWidths, ";"))
140         SetTopIndex
150     End If
160 End If

End Sub

Sub GetTopIndex()
10  lTopIndex = Me.lbxNames.TopIndex
End Sub

Sub SetTopIndex()
10  If Me.lbxNames.ListCount <= lTopIndex Or Me.lbxNames.ListCount = 0 Then Exit Sub
20  Me.lbxNames.TopIndex = lTopIndex
End Sub

Sub SetTopIndexAfterSort()
    Dim lPos As Long
10  On Error Resume Next
20  With Me.lbxNames
30      For lPos = 0 To .ListCount
40          If .Selected(lPos) Then
50              .TopIndex = Application.Max(0, lPos - 5)
60              Exit Sub
70          End If
80      Next
90      .TopIndex = 0
100 End With
End Sub

Private Sub ChangButtons(bIcons As Boolean)
10  If bIcons Then
20      frmButtons1.Top = 12
30      frmButtons1.Left = 3
40      frmButtons1.Visible = True
50      frmButtons2.Left = 3
60      frmButtons2.Top = 500
70      frmButtons2.Visible = False
80  Else
90      frmButtons1.Top = 500
100     frmButtons1.Left = 3
110     frmButtons1.Visible = False
120     frmButtons2.Left = 3
130     frmButtons2.Top = 6
140     frmButtons2.Visible = True
150 End If
End Sub

Private Sub RenameAName()
    Dim sNewName As String
    Dim sOldName As String
    Dim bDone As Boolean
    Dim blTable As Boolean
    Dim oTable As ListObject

10  Me.Hide
20  gbBreak = False
30  gbRenameError = False
40  gbNoMoreAcknowledge = False
50  GetIndex
60  sOldName = gsNames(glActive)
70  sNewName = sOldName
80  blTable = IsTableName(sOldName)
90  Do
100     If ShowMessageBox(ReworkMsg(gsMsgs(90), sNewName), "OK", "Cancel", "", 1, 2, True, sNewName) = 1 Then
110     Else
120         sNewName = ""
130     End If
        '90      sNewName = InputBox(ReworkMsg(gsMsgs(90), sNewName), gsAppName, sOldname)
140     If (sNewName <> sOldName Or ChangedJustCapitalisation(sNewName, sOldName)) _
           And sNewName <> "" Then
150         If IsNewNameValid(sNewName) Then
160             If blTable Then
                    '
                    ' crw 5 june 2014
                    '
170                 If Not FindTableName(sNewName) Is Nothing Then
                        ' new table name already exists
180                     ShowMsg ReworkMsg(gsMsgs(89)), vbInformation + vbOKOnly
190                     Exit Sub
200                 End If

210                 Set oTable = FindTableName(sOldName)
220                 If oTable Is Nothing Then
230                     MsgBox "Cannot find Table '" & sOldName & "'", vbOKOnly + vbCritical, gstrFastXL
240                     Exit Sub
250                 End If
260                 oTable.Name = sNewName
270                 cbRefresh_Click
280                 Application.Cursor = xlDefault
290                 bDone = True
300             Else
310                 If Not FindName(sNewName) Is Nothing Then
                        'New name already exists
320                     If ChangedJustCapitalisation(sNewName, sOldName) Then
                            'changed capitalisation!
330                     Else
340                         ShowMsg ReworkMsg(gsMsgs(89)), vbInformation + vbOKOnly
350                         Exit Sub
360                     End If
370                 End If
380                 Application.Cursor = xlWait
390                 If ReplaceName(sOldName, sNewName) = vbCancel Then
400                     ShowMsg gsMsgs(98), vbOKOnly + vbExclamation
410                 End If
420                 cbRefresh_Click
430                 Application.Cursor = xlDefault
440                 bDone = True
450             End If
460         End If
470     Else
480         bDone = True
490     End If
500 Loop Until bDone = True
510 If gbRenameError Then
520     If ShowMsg(ReworkMsg(gsMsgs(99), sOldName), vbYesNo + vbExclamation) = vbYes Then
            '            Me.Hide
530         LookForName sOldName
540     End If
550 End If
560 Application.Visible = True
570 Set gcFoundObjects = Nothing
    #If VBA6 Or VBA7 Then
580     Me.Show vbModeless
    #Else
590     gbDisableEvents = False
600     Me.Show
    #End If
End Sub

Private Sub xlapp_WindowActivate(ByVal Wb As Workbook, ByVal Wn As Window)
10  If Val(Application.Version) >= 15 And mhwndForm <> 0 Then  'Basear o form na janela ativa do Excel.
20      mXLHwnd = Application.hwnd    'Always get because in Excel 15 SDI each wb has its window with different handle.
30      SetWindowLongPtr mhwndForm, GWL_HWNDPARENT, mXLHwnd
40      SetForegroundWindow mhwndForm
50  End If
End Sub

Private Sub xlapp_WindowResize(ByVal Wb As Workbook, ByVal Wn As Window)
10  If Not Me.Visible Then Me.Show vbModeless
End Sub

Private Sub xlapp_WorkbookBeforeClose(ByVal Wb As Workbook, Cancel As Boolean)
10  SetWindowLongPtr mhwndForm, GWL_HWNDPARENT, 0&
End Sub


Attribute VB_Name = "ufReplace"
Attribute VB_Base = "0{FA7D8111-3155-40B2-B52F-1238AFC6E4F7}{A16FCF78-3856-4EA2-A00D-0B417EDC9D3D}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Option Base 1
Option Compare Text
Dim jLastFound As Long
Dim jLastSelected As Long
Dim jFirstSelected As Long
Dim nFound As Long
Private Sub butClose_Click()
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2005-2010. All rights reserved
'
'
' restore selections
'
10  PushStack3 "Repcloseclick"
20  RestoreSelects False
30  DoNameSelected
40  gbRepWild = Me.chkWildFind
50  gbRepScope = Not Me.optSelOnly
60  gsFind = Me.tbxFind
70  gsReplace = Me.tbxReplace
80  Unload Me
90  PopStack3
End Sub
Private Sub butFindNext_Click()
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2005-2010. All rights reserved
'
10  PushStack3 "butFindNext"
20  gbRepAll = False
30  nFound = 0
40  GetLastSelected
50  If Me.optSelOnly Then RestoreSelects True
60  If jLastFound = 0 Then jLastFound = jFirstSelected
70  FindNext
80  PopStack3
End Sub
Private Sub butRepAll_Click()
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2005-2010. All rights reserved
'
' crw 17/10/04 : switch off acknowledgement
'
    Dim lCounter As Long
    Dim bSaveAck As Boolean

10  PushStack3 "butRepAll"
20  gbRepAll = True
30  gbRepErr = False
40  nFound = 0                                        ''' number found
50  glChanged = 0
60  lCounter = 0
70  Application.ScreenUpdating = False
80  GetLastSelected
90  jLastFound = jFirstSelected - 1
100 bSaveAck = gbAcknowledge
110 If bSaveAck Then gbAcknowledge = False
120 Do
130     lCounter = lCounter + 1
140     If lCounter > gfrmNameManager.lbxNames.ListCount Then Exit Do
150     FindNext
160     If nFound > 0 And Not gbRepErr Then
170         DoReplace
180         If gbRepErr Then Exit Do
190     Else
200         Exit Do
210     End If
220 Loop
230 If bSaveAck <> gbAcknowledge Then gbAcknowledge = bSaveAck
240 RestoreSelects True
250 Application.ScreenUpdating = True
260 gbRepAll = False
270 If glChanged > 0 Then Unload Me
280 MsgBox CStr(glChanged) & " Names have been changed", vbOKOnly + vbInformation, gsAppName
290 PopStack3
End Sub
Private Sub butReplace_Click()
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2005-2010. All rights reserved
'
'
' replace findtext with replace text in refersto box
' and then update the names refersto
'
' check for something to find
'
10  PushStack3 "butReplaceClick"
20  gbRepAll = False
30  gbRepErr = False
40  glChanged = 0
50  nFound = 0
60  GetLastSelected
70  If jLastFound = 0 And jFirstSelected > 0 Then jLastFound = jFirstSelected - 1
80  FindNext
    '
    ' check nfound 17/10/04
    '
90  If nFound > 0 Then DoReplace
100 PopStack3
End Sub
Private Sub RestoreSelects(blAlways As Boolean)
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2005-2010. All rights reserved
'
    Dim bTop As Boolean
    Dim j As Long

10  PushStack3 "RestoreSelects"
20  If blAlways Or (Not gbRepFound) Then
        '
        ' restore selections
        '
30      bTop = False
40      For j = 1 To gfrmNameManager.lbxNames.ListCount
50          gfrmNameManager.lbxNames.Selected(j - 1) = False
60          If j <= UBound(gbSelections) Then
70              If gbSelections(j) Then
80                  gfrmNameManager.lbxNames.Selected(j - 1) = True
90                  If Not bTop Then
100                     gfrmNameManager.lbxNames.TopIndex = j - 1
110                     bTop = True
120                 End If
130             End If
140         End If
150     Next j
160 End If
170 PopStack3
End Sub

Private Sub FindNext()
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2005-2010. All rights reserved
'
    Dim j As Long
    Dim jPoint As Long
    Dim blFound As Boolean

10  PushStack3 "findNext"
20  gsFind = CStr(Me.tbxFind)
30  For j = 1 To gfrmNameManager.lbxNames.ListCount
40      gfrmNameManager.lbxNames.Selected(j - 1) = False
50  Next j
60  If Not Len(gsFind) = 0 Then
70      blFound = False

80      jPoint = jLastFound
90      For j = 1 To gfrmNameManager.lbxNames.ListCount
100         jPoint = jPoint + 1
110         If jPoint > gfrmNameManager.lbxNames.ListCount Then jPoint = 1
120         If Me.optSelOnly Then
130             If gbRepAll And jLastSelected <> 0 And (jPoint > jLastSelected Or jLastSelected = -1) Then
140                 gbRepErr = True
150             Else
160                 If jLastSelected = jPoint Then jLastSelected = -1    ''' kill next
170                 If jPoint <= UBound(gbSelections) Then
180                     If gbSelections(jPoint) Then
190                         If jFindIt(jPoint) > 0 Then
200                             blFound = True
210                             gbRepFound = True
220                             nFound = nFound + 1
230                             Exit For
240                         End If
250                     End If
260                 End If
270             End If
280         Else
290             If jFindIt(jPoint) > 0 Then
300                 blFound = True
310                 gbRepFound = True
320                 nFound = nFound + 1
330                 Exit For
340             End If
350         End If
360     Next j
370     If Not blFound And nFound = 0 Then
380         MsgBox "Could not find: '" & gsFind & "'", vbOKOnly + vbExclamation, gsAppName
390     End If
400 Else
410     MsgBox "Please enter the Text to find", vbOKOnly + vbExclamation, gsAppName
420 End If
430 If Not blFound Then nFound = 0
440 PopStack3
End Sub
Private Function jFindIt(jPoint As Long) As Long
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2005-2010. All rights reserved
'
'
' find the start position of strfind within the current refersto
'
' select the found name and scroll it to to the top
'
10  PushStack3 "jFindit"
20  jFindIt = 0
30  If Not IsNull(gfrmNameManager.lbxNames.List(jPoint - 1, 1)) Then jFindIt = kFind(gfrmNameManager.lbxNames.List(jPoint - 1, 1))

40  If jFindIt > 0 Then
50      gfrmNameManager.lbxNames.Selected(jPoint - 1) = True
60      If Not gbRepAll Then gfrmNameManager.lbxNames.TopIndex = jPoint - 1
70      DoNameSelected
80      jLastFound = jPoint
90  End If
100 PopStack3
End Function

Private Sub DoReplace()
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2005-2010. All rights reserved
'
'
' replace findtext with replace text in refersto box
' and then update the names refersto
'
'
    Dim strInput As String
    Dim strOutput As String
    '
    ' check for something to find
    '
    Dim jPos As Long

10  PushStack3 "DoReplace"
20  gsFind = CStr(Me.tbxFind)
30  gsReplace = CStr(Me.tbxReplace)

40  If Len(gsFind) > 0 Then
50      jPos = kFind(gfrmNameManager.tbEditName)
60      If jPos > 0 Then
70          strInput = gfrmNameManager.tbEditName
80          If Me.chkWildFind Then
90              Call WildReplace(strInput, gsFind, gsReplace, strOutput)
100         Else
110             strOutput = Replace5(strInput, gsFind, gsReplace, , , vbTextCompare)
120         End If
130         glChanged = glChanged + 1
140         DoNameCharChanged
150         gfrmNameManager.tbEditName = strOutput
160         DoNameAfterUpdate
170     Else
180         MsgBox "Cannot find '" & gsFind & "' in '" & gfrmNameManager.tbEditName & "' ; Replace failed", vbOKOnly + vbExclamation, gsAppName
190     End If
200 Else
210     MsgBox "Please enter the Text to find", vbOKOnly + vbExclamation, gsAppName
220 End If
230 PopStack3
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2005-2010. All rights reserved
'
10  PushStack3 "Rep_QueryClose"
20  If CloseMode = vbFormControlMenu Then
        '
        ' crw 16/10/04
        '
        '30      Cancel = True
        '40      gbRepWild = Me.chkWildFind
        '50      gbRepScope = Not Me.optSelOnly
        '60      gsFind = Me.tbxFind
        '70      gsReplace = Me.tbxReplace
        '80      Unload Me
30      butClose_Click
40  End If
50  PopStack3
End Sub
Private Function kFind(strLook As String) As Long
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2005-2010. All rights reserved
'
'
' find strfind in strlook
' return 0 if not found
' use wild card search if requested
'
    Dim vFindIt As Variant

10  PushStack3 "kFind"
20  kFind = 0
30  If Len(gsFind) > 0 And Len(strLook) > 0 Then
40      If Me.chkWildFind Then
50          vFindIt = Application.Search(gsFind, strLook)
60          If Not IsError(vFindIt) Then
70              If vFindIt > 0 Then kFind = CLng(vFindIt)
80          End If
90      Else
100         kFind = InStr(strLook, gsFind)
110     End If
120 End If
130 PopStack3
End Function
Private Sub WildReplace(strInput As String, strFind As String, strReplace As String, strOutput As String)
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2005-2010. All rights reserved
'
' use replace method for wildcard replace
'
' crw 18/10/04 ; use Language sheet rather than FXLTemplate
'
    Dim oChangeCell As Range
    Dim blEquals As Boolean

10  PushStack3 "WildReplace"
20  Set oChangeCell = ThisWorkbook.Worksheets("LanguageSheet").Range("Q1")

30  blEquals = False
40  If Left(strInput, 1) = "=" Then
50      blEquals = True
60      strInput = "~" & Right(strInput, Len(strInput) - 1)
70  End If
80  oChangeCell.ClearContents
90  oChangeCell = strInput
100 oChangeCell.Replace What:=strFind, Replacement:=strReplace, LookAt:=xlPart, _
                        SearchOrder:=xlByRows, MatchCase:=False
110 strOutput = oChangeCell
120 If blEquals Then strOutput = "=" & Right(strOutput, Len(strOutput) - 1)
130 Set oChangeCell = Nothing
140 PopStack3
End Sub
Private Sub GetLastSelected()
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2005-2010. All rights reserved
'
' get the index of the first & last selected name
'
    Dim j As Long

10  PushStack3 "GetLastSelected"
20  jLastSelected = 0
30  jFirstSelected = 0

40  For j = 1 To gfrmNameManager.lbxNames.ListCount
50      If j < UBound(gbSelections) Then
60          If gbSelections(j) Then
70              If Me.optSelOnly Then jLastSelected = j
80              If jFirstSelected = 0 Then jFirstSelected = j
90          End If
100     End If
110 Next j
120 PopStack3

End Sub


Attribute VB_Name = "ufReplaceFR"
Attribute VB_Base = "0{D01077E2-86E3-48AD-A5E8-518E2F500E94}{7BC02F11-EC15-4CB3-BB33-7FB78C8EF434}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Option Base 1
Option Compare Text
Dim jLastFound As Long
Dim jLastSelected As Long
Dim jFirstSelected As Long
Dim nFound As Long
Private Sub butClose_Click()
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2005-2010. All rights reserved
'
'
' restore selections
'
10  PushStack3 "Repcloseclick"
20  RestoreSelects False
30  DoNameSelected
40  gbRepWild = Me.chkWildFind
50  gbRepScope = Not Me.optSelOnly
60  gsFind = Me.tbxFind
70  gsReplace = Me.tbxReplace
80  Unload Me
90  PopStack3
End Sub
Private Sub butFindNext_Click()
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2005-2010. All rights reserved
'
10  PushStack3 "butFindNext"
20  gbRepAll = False
30  nFound = 0
40  GetLastSelected
50  If Me.optSelOnly Then RestoreSelects True
60  If jLastFound = 0 Then jLastFound = jFirstSelected
70  FindNext
80  PopStack3
End Sub
Private Sub butRepAll_Click()
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2005-2010. All rights reserved
'
' crw 17/10/04 : switch off acknowledgement
'
    Dim lCounter As Long
    Dim bSaveAck As Boolean

10  PushStack3 "butRepAll"
20  gbRepAll = True
30  gbRepErr = False
40  nFound = 0                                        ''' number found
50  glChanged = 0
60  lCounter = 0
70  Application.ScreenUpdating = False
80  GetLastSelected
90  jLastFound = jFirstSelected - 1
100 bSaveAck = gbAcknowledge
110 If bSaveAck Then gbAcknowledge = False
120 Do
130     lCounter = lCounter + 1
140     If lCounter > gfrmNameManager.lbxNames.ListCount Then Exit Do
150     FindNext
160     If nFound > 0 And Not gbRepErr Then
170         DoReplace
180         If gbRepErr Then Exit Do
190     Else
200         Exit Do
210     End If
220 Loop
230 If bSaveAck <> gbAcknowledge Then gbAcknowledge = bSaveAck
240 RestoreSelects True
250 Application.ScreenUpdating = True
260 gbRepAll = False
270 If glChanged > 0 Then Unload Me
280 MsgBox CStr(glChanged) & " Names have been changed", vbOKOnly + vbInformation, gsAppName
290 PopStack3
End Sub
Private Sub butReplace_Click()
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2005-2010. All rights reserved
'
'
' replace findtext with replace text in refersto box
' and then update the names refersto
'
' check for something to find
'
10  PushStack3 "butReplaceClick"
20  gbRepAll = False
30  gbRepErr = False
40  glChanged = 0
50  nFound = 0
60  GetLastSelected
70  If jLastFound = 0 And jFirstSelected > 0 Then jLastFound = jFirstSelected - 1
80  FindNext
    '
    ' check nfound 17/10/04
    '
90  If nFound > 0 Then DoReplace
100 PopStack3
End Sub
Private Sub RestoreSelects(blAlways As Boolean)
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2005-2010. All rights reserved
'
    Dim bTop As Boolean
    Dim j As Long

10  PushStack3 "RestoreSelects"
20  If blAlways Or (Not gbRepFound) Then
        '
        ' restore selections
        '
30      bTop = False
40      For j = 1 To gfrmNameManager.lbxNames.ListCount
50          gfrmNameManager.lbxNames.Selected(j - 1) = False
60          If j <= UBound(gbSelections) Then
70              If gbSelections(j) Then
80                  gfrmNameManager.lbxNames.Selected(j - 1) = True
90                  If Not bTop Then
100                     gfrmNameManager.lbxNames.TopIndex = j - 1
110                     bTop = True
120                 End If
130             End If
140         End If
150     Next j
160 End If
170 PopStack3
End Sub

Private Sub FindNext()
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2005-2010. All rights reserved
'
    Dim j As Long
    Dim jPoint As Long
    Dim blFound As Boolean

10  PushStack3 "findNext"
20  gsFind = CStr(Me.tbxFind)
30  For j = 1 To gfrmNameManager.lbxNames.ListCount
40      gfrmNameManager.lbxNames.Selected(j - 1) = False
50  Next j
60  If Not Len(gsFind) = 0 Then
70      blFound = False

80      jPoint = jLastFound
90      For j = 1 To gfrmNameManager.lbxNames.ListCount
100         jPoint = jPoint + 1
110         If jPoint > gfrmNameManager.lbxNames.ListCount Then jPoint = 1
120         If Me.optSelOnly Then
130             If gbRepAll And jLastSelected <> 0 And (jPoint > jLastSelected Or jLastSelected = -1) Then
140                 gbRepErr = True
150             Else
160                 If jLastSelected = jPoint Then jLastSelected = -1    ''' kill next
170                 If jPoint <= UBound(gbSelections) Then
180                     If gbSelections(jPoint) Then
190                         If jFindIt(jPoint) > 0 Then
200                             blFound = True
210                             gbRepFound = True
220                             nFound = nFound + 1
230                             Exit For
240                         End If
250                     End If
260                 End If
270             End If
280         Else
290             If jFindIt(jPoint) > 0 Then
300                 blFound = True
310                 gbRepFound = True
320                 nFound = nFound + 1
330                 Exit For
340             End If
350         End If
360     Next j
370     If Not blFound And nFound = 0 Then
380         MsgBox "Could not find: '" & gsFind & "'", vbOKOnly + vbExclamation, gsAppName
390     End If
400 Else
410     MsgBox "Please enter the Text to find", vbOKOnly + vbExclamation, gsAppName
420 End If
430 If Not blFound Then nFound = 0
440 PopStack3
End Sub
Private Function jFindIt(jPoint As Long) As Long
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2005-2010. All rights reserved
'
'
' find the start position of strfind within the current refersto
'
' select the found name and scroll it to to the top
'
10  PushStack3 "jFindit"
20  jFindIt = 0
30  If Not IsNull(gfrmNameManager.lbxNames.List(jPoint - 1, 1)) Then jFindIt = kFind(gfrmNameManager.lbxNames.List(jPoint - 1, 1))

40  If jFindIt > 0 Then
50      gfrmNameManager.lbxNames.Selected(jPoint - 1) = True
60      If Not gbRepAll Then gfrmNameManager.lbxNames.TopIndex = jPoint - 1
70      DoNameSelected
80      jLastFound = jPoint
90  End If
100 PopStack3
End Function

Private Sub DoReplace()
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2005-2010. All rights reserved
'
'
' replace findtext with replace text in refersto box
' and then update the names refersto
'
'
    Dim strInput As String
    Dim strOutput As String
    '
    ' check for something to find
    '
    Dim jPos As Long

10  PushStack3 "DoReplace"
20  gsFind = CStr(Me.tbxFind)
30  gsReplace = CStr(Me.tbxReplace)

40  If Len(gsFind) > 0 Then
50      jPos = kFind(gfrmNameManager.tbEditName)
60      If jPos > 0 Then
70          strInput = gfrmNameManager.tbEditName
80          If Me.chkWildFind Then
90              Call WildReplace(strInput, gsFind, gsReplace, strOutput)
100         Else
110             strOutput = Replace5(strInput, gsFind, gsReplace, , , vbTextCompare)
120         End If
130         glChanged = glChanged + 1
140         DoNameCharChanged
150         gfrmNameManager.tbEditName = strOutput
160         DoNameAfterUpdate
170     Else
180         MsgBox "Cannot find '" & gsFind & "' in '" & gfrmNameManager.tbEditName & "' ; Replace failed", vbOKOnly + vbExclamation, gsAppName
190     End If
200 Else
210     MsgBox "Please enter the Text to find", vbOKOnly + vbExclamation, gsAppName
220 End If
230 PopStack3
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2005-2010. All rights reserved
'
10  PushStack3 "Rep_QueryClose"
20  If CloseMode = vbFormControlMenu Then
        '
        ' crw 16/10/04
        '
        '30      Cancel = True
        '40      gbRepWild = Me.chkWildFind
        '50      gbRepScope = Not Me.optSelOnly
        '60      gsFind = Me.tbxFind
        '70      gsReplace = Me.tbxReplace
        '80      Unload Me
30      butClose_Click
40  End If
50  PopStack3
End Sub
Private Function kFind(strLook As String) As Long
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2005-2010. All rights reserved
'
'
' find strfind in strlook
' return 0 if not found
' use wild card search if requested
'
    Dim vFindIt As Variant

10  PushStack3 "kFind"
20  kFind = 0
30  If Len(gsFind) > 0 And Len(strLook) > 0 Then
40      If Me.chkWildFind Then
50          vFindIt = Application.Search(gsFind, strLook)
60          If Not IsError(vFindIt) Then
70              If vFindIt > 0 Then kFind = CLng(vFindIt)
80          End If
90      Else
100         kFind = InStr(strLook, gsFind)
110     End If
120 End If
130 PopStack3
End Function
Private Sub WildReplace(strInput As String, strFind As String, strReplace As String, strOutput As String)
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2005-2010. All rights reserved
'
' use replace method for wildcard replace
'
' crw 18/10/04 ; use Language sheet rather than FXLTemplate
'
    Dim oChangeCell As Range
    Dim blEquals As Boolean

10  PushStack3 "WildReplace"
20  Set oChangeCell = ThisWorkbook.Worksheets("LanguageSheet").Range("Q1")

30  blEquals = False
40  If Left(strInput, 1) = "=" Then
50      blEquals = True
60      strInput = "~" & Right(strInput, Len(strInput) - 1)
70  End If
80  oChangeCell.ClearContents
90  oChangeCell = strInput
100 oChangeCell.Replace What:=strFind, Replacement:=strReplace, LookAt:=xlPart, _
                        SearchOrder:=xlByRows, MatchCase:=False
110 strOutput = oChangeCell
120 If blEquals Then strOutput = "=" & Right(strOutput, Len(strOutput) - 1)
130 Set oChangeCell = Nothing
140 PopStack3
End Sub
Private Sub GetLastSelected()
'
' COPYRIGHT |fffd| DECISION MODELS LIMITED 2005-2010. All rights reserved
'
' get the index of the first & last selected name
'
    Dim j As Long

10  PushStack3 "GetLastSelected"
20  jLastSelected = 0
30  jFirstSelected = 0

40  For j = 1 To gfrmNameManager.lbxNames.ListCount
50      If j < UBound(gbSelections) Then
60          If gbSelections(j) Then
70              If Me.optSelOnly Then jLastSelected = j
80              If jFirstSelected = 0 Then jFirstSelected = j
90          End If
100     End If
110 Next j
120 PopStack3

End Sub




Attribute VB_Name = "ufSelectCells"
Attribute VB_Base = "0{AFE262A4-B540-4AC2-AB3C-13E4775454C3}{AA4CDB73-6E31-4750-B53E-DDF868BAE800}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private mbOK As Boolean
Private moReturnedRange As Range
Private msPromptText As String
Private msCaptionText As String
Private msStartAddress As String

#If VBA7 Then
    Dim mhwndForm As LongPtr                                 'The userform's window handle
    Private Declare PtrSafe Function FindWindow32 Lib "User32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As LongPtr
#Else
    Dim mhwndForm As Long                                 'The userform's window handle
    Private Declare Function FindWindow32 Lib "User32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
#End If

Public Sub Initialise()
10  SetTexts
20  cmbOK.Enabled = False
30  lblQuestion.Caption = msPromptText
40  Me.Caption = CaptionText
50  refSelectCells.Text = StartAddress
End Sub

Private Sub cmbCancel_Click()
10  OK = False
20  Me.Hide
End Sub

Private Sub cmbOK_Click()
10  If refSelectCells.Text <> "" Then
20      If TypeName(Selection) = "Range" Then
30          If IsValidRef(refSelectCells.Text) Then
40              OK = True
50          End If
60      End If
70  End If
80  Me.Hide
End Sub

Public Property Get OK() As Boolean
10  OK = mbOK
End Property

Public Property Let OK(ByVal bOK As Boolean)
10  mbOK = bOK
End Property

Public Property Get ReturnedRange() As Range
    Dim sRef As String
    Dim oSh As Worksheet
10  On Error Resume Next
20  sRef = refSelectCells.Text
30  If OK And IsValidRef(sRef) Then
40      If InStr(sRef, "!") Then
50          Set oSh = ActiveWorkbook.Worksheets(Application.Substitute(Left(sRef, InStr(sRef, "!") - 1), "'", ""))
60      Else
70          Set oSh = ActiveSheet
80      End If

90      Set moReturnedRange = oSh.Range(Mid(sRef, InStr(sRef, "!") + 1))
100     Set ReturnedRange = moReturnedRange
110 End If
End Property

Public Property Set ReturnedRange(oReturnedRange As Range)
10  Set moReturnedRange = oReturnedRange
End Property

Public Function IsValidRef(sRef As String) As Boolean
'-------------------------------------------------------------------------
' Procedure : IsValidRef Created by Jan Karel Pieterse
' Company   : JKP Application Development Services (c) 2005
' Author    : Jan Karel Pieterse
' Created   : 21-12-2005
' Purpose   : Checks of argument is a valid cell reference
'-------------------------------------------------------------------------
    Dim sTemp As String
    Dim oSh As Worksheet
    Dim oCell As Range
    '    On Error GoTo LocErr
10  IsValidRef = False
20  On Error Resume Next
30  sTemp = Left(sRef, InStr(sRef, "!") - 1)
40  sTemp = Replace5(sTemp, "=", "")
50  If Not IsIn(ActiveWorkbook.Worksheets, sTemp) Then
60      IsValidRef = False
70      Exit Function
80  End If
90  Set oSh = ActiveWorkbook.Worksheets(sTemp)
100 If oSh Is Nothing Then
110     Set oSh = ActiveWorkbook.Worksheets(Replace5(sTemp, "'", ""))
120 End If
130 sTemp = Right(sRef, Len(sRef) - InStr(sRef, "!"))
140 Set oCell = oSh.Range(sTemp)
150 If oCell Is Nothing Then
160     IsValidRef = False
170 Else
180     IsValidRef = True
190 End If
    'TidyUp:
    '    Exit Function
    'LocErr:
    '    If ReportError(Err.Description, Err.Number, "ufUploadWizard", "IsValidRef") = vbRetry Then
    '        Resume
    '    Else
    '        Resume TidyUp
    '    End If
End Function

Function IsIn(vCollection As Variant, ByVal sName As String) As Boolean
'-------------------------------------------------------------------------
' Procedure : funIsIn Created by Jan Karel Pieterse
' Company   : JKP Application Development Services (c) 2005
' Author    : Jan Karel Pieterse
' Created   : 28-12-2005
' Purpose   : Determines if object is in collection
'-------------------------------------------------------------------------
    Dim oObj As Object
10  On Error Resume Next
20  Set oObj = vCollection(sName)
30  If oObj Is Nothing Then
40      IsIn = False
50  Else
60      IsIn = True
70  End If
80  If IsIn = False Then
90      sName = Replace5(sName, "'", "")
100     Set oObj = vCollection(sName)
110     If oObj Is Nothing Then
120         IsIn = False
130     Else
140         IsIn = True
150     End If
160 End If
End Function

Public Property Let PromptText(ByVal sPromptText As String)
10  msPromptText = sPromptText
End Property

Private Sub refSelectCells_Change()
10  If IsValidRef(refSelectCells.Text) Then
20      cmbOK.Enabled = True
30  Else
40      cmbOK.Enabled = False
50  End If
End Sub

Public Property Get CaptionText() As String
10  CaptionText = msCaptionText
End Property

Public Property Let CaptionText(ByVal sCaptionText As String)
10  msCaptionText = sCaptionText
End Property

Private Sub UserForm_Activate()
10  If Val(Application.Version) >= 15 Then
20      mhwndForm = FindWindow32("ThunderDFrame", Me.Caption)
30      MakeTopmost mhwndForm, True
40  End If
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
10  If CloseMode <> vbFormCode Then
20      Cancel = True
30      Me.cmbCancel.SetFocus
40      cmbCancel_Click
50  End If
End Sub

Public Property Get StartAddress() As String
10  msStartAddress = Mid(msStartAddress, InStr(msStartAddress, "]") + 1)
20  If InStr(msStartAddress, "'") > 2 And Left(msStartAddress, 1) <> "'" Then
30      msStartAddress = "'" & msStartAddress
40  End If
50  StartAddress = msStartAddress
End Property

Public Property Let StartAddress(sStartAddress As String)
10  msStartAddress = sStartAddress
End Property

Private Sub SetTexts()
10  With cmbCancel
20      .Accelerator = gstxtufSelectARange(1)
30      .Caption = gstxtufSelectARange(2)
40      .ControlTipText = gstxtufSelectARange(3)
50  End With
60  With cmbOK
70      .Accelerator = gstxtufSelectARange(4)
80      .Caption = gstxtufSelectARange(5)
90      .ControlTipText = gstxtufSelectARange(6)
100 End With
End Sub

Attribute VB_Name = "ufWhereUsed"
Attribute VB_Base = "0{09C87AD5-5919-417B-9A10-3E7BDE1BE6A5}{5E1D6DE9-9281-46AE-B28E-48A006C62A68}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Const MCSNODEKEYROOT As String = "Root"

Private msNameToLookFor As String

' SetWindowLongA API constant.
Private Const GWL_HWNDPARENT As Long = -8


#If VBA7 Then
    Dim mhwndForm As LongPtr
    Private Declare PtrSafe Function SetWindowLongPtr Lib "User32" Alias "SetWindowLongA" (ByVal hwnd As LongPtr, ByVal nIndex As Long, ByVal dwNewLong As LongPtr) As LongPtr
    Private Declare PtrSafe Function FindWindow Lib "User32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As LongPtr
    Private Declare PtrSafe Function SetActiveWindow Lib "user32.dll" (ByVal hwnd As LongPtr) As LongPtr
#Else
    Dim mhwndForm As Long
    Private Declare Function SetWindowLongPtr Lib "User32" Alias "SetWindowLongA" (ByVal hwnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
    Private Declare Function FindWindow Lib "User32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
    Private Declare Function SetActiveWindow Lib "user32.dll" (ByVal hwnd As Long) As Long
#End If

'SB+
'Declare an object for our CFormResizer class to handle resizing for this form
Dim mclsResizer As CFormResizer


Private mobjPrevSelectedObj As Object
Private mbDisableEvent As Boolean

Public Sub Initialise()
    Dim lCount As Long
    Dim sName As String
10  If Val(Application.Version) < 9 Then
20      mhwndForm = FindWindow("ThunderXFrame", Me.Caption)    'XL97
30  Else
40      mhwndForm = FindWindow("ThunderDFrame", Me.Caption)    'XL2000
50  End If
60  Set PrevSelectedObj = Selection
70  cbbNames.Clear
80  For lCount = 1 To ActiveWorkbook.Names.Count
90      sName = ActiveWorkbook.Names(lCount).Name
100     cbbNames.AddItem sName
110 Next
120 If mclsResizer Is Nothing Then
130     Set mclsResizer = New CFormResizer
        'Tell it where to store the form dimensions
140     mclsResizer.RegistryKey = gsFxlNameRegKey     ''' crw 18/10/2005
        'Tell it which form it's handling
150     Set mclsResizer.Form = Me
160 End If
170 mbDisableEvent = True
180 cbbNames.Value = NameToLookFor
190 mbDisableEvent = False
200 FillTree
210 SetTexts
End Sub

Public Sub FillTree()
    Dim oFoundObj As clsFoundObjects
    Dim oSh As Object
    Dim sNodeToAddTo As String
    Dim sMsg As String
    Dim lCount As Long
10  FindNames NameToLookFor
20  With lbxNameLocations
30      .Clear
40      .AddItem ActiveWorkbook.FullName
50      On Error Resume Next
60      For Each oSh In ActiveWorkbook.Sheets
70          sMsg = ""
80          If IsSheetProtected(oSh, False) Then
90              sMsg = ReworkMsg(gsMsgs(95), oSh.Name)
100         End If
110         If HasHiddenCells(oSh, False) Then
120             If sMsg <> "" Then
130                 sMsg = sMsg & ", " & ReworkMsg(gsMsgs(96), oSh.Name)
140             Else
150                 sMsg = ReworkMsg(gsMsgs(96), oSh.Name)
160             End If
170         End If
180         If sMsg <> "" Then
190             .AddItem gsMsgs(94) & ": " & sMsg
200         End If

210     Next
220     If Not gcFoundObjects Is Nothing Then
230         If gcFoundObjects.Count > 0 Then
240             For Each oFoundObj In gcFoundObjects
250                 Set oSh = Nothing
260                 Set oSh = GetSheet(oFoundObj.FoundObject)
270                 If oSh Is Nothing Then
280                     Select Case TypeName(oFoundObj.FoundObject)
                        Case "Name"
290                         sNodeToAddTo = "Name: " & oFoundObj.FoundObject.Name
300                     Case "CodeModule"
310                         sNodeToAddTo = "VBProject: " & oFoundObj.FoundInBook
320                     End Select
330                 Else
340                     sNodeToAddTo = oSh.Name
350                 End If
360                 .AddItem sNodeToAddTo & ", " & oFoundObj.FoundObjName    ' & ", " & oFoundObj.FoundObjName
370             Next
380         Else
390             .AddItem ReworkMsg(gsMsgs(102), Me.NameToLookFor)
400         End If
410     Else
420         .AddItem ReworkMsg(gsMsgs(102), Me.NameToLookFor)
430     End If
440 End With
End Sub

Private Sub cbbNames_Change()
10  If mbDisableEvent Then Exit Sub
20  Set gcFoundObjects = Nothing
30  NameToLookFor = cbbNames.Text
40  FillTree
End Sub

Private Sub cmbClose_Click()
10  Application.Visible = True
20  SelectObj PrevSelectedObj
    '
    ' CRW 17 April 2014: whereused can be called externally as well as from NM
    '
30  If Not gfrmNameManager Is Nothing Then Application.OnTime Now, "ShowNMForm"
40  Unload Me
End Sub

Private Sub cmbSearch_Click()
10  Set gcFoundObjects = Nothing
20  NameToLookFor = cbbNames.Text
30  FillTree
End Sub

Private Sub lbxNameLocations_click()
    Static bInVBE As Boolean
    Dim oFoundObj As clsFoundObjects
10  If Not gcFoundObjects Is Nothing Then
20      For Each oFoundObj In gcFoundObjects
30          If lbxNameLocations.Value Like "*" & oFoundObj.FoundObjName & "*" Then
40              Select Case TypeName(oFoundObj.FoundObject)
                Case "CodeModule"
                    'Me.Hide
50                  SelectVBA oFoundObj.FoundObject, CLng(Mid(oFoundObj.FoundProperty, InStr(oFoundObj.FoundProperty, " ")))
                    'Me.Show
60                  If Not bInVBE Then
70                      ParentForm2VBE
80                  End If
90                  bInVBE = True
100             Case Else
110                 If Application.Visible = False Then
120                     Application.Visible = True
130                 End If
140                 SelectObj oFoundObj.FoundObject
150                 If bInVBE Then
160                     ParentForm2XL
170                 End If
180                 bInVBE = False
190             End Select
200             Exit For
210         End If
220     Next
230 End If
End Sub

Private Sub SetTexts()
    Dim iCount As Long
10  PushStack3 "settexts"
20  cmbClose.Caption = gsTxtufWhereUsed(1)
30  cmbClose.Accelerator = gsTxtufWhereUsed(2)
40  cmbClose.Caption = gsTxtufWhereUsed(3)
50  cmbClose.ControlTipText = gsTxtufWhereUsed(4)
60  cbbNames.ControlTipText = gsTxtufWhereUsed(5)
70  lbxNameLocations.ControlTipText = gsTxtufWhereUsed(6)
80  PopStack3
End Sub

Public Property Get NameToLookFor() As String
10  NameToLookFor = msNameToLookFor
End Property

Public Property Let NameToLookFor(ByVal sNameToLookFor As String)
10  msNameToLookFor = sNameToLookFor
20  lblWhere.Caption = ReworkMsg(gsTxtufWhereUsed(1), msNameToLookFor)
End Property

Private Sub UserForm_Activate()
10  If Val(Application.Version) >= 15 Then
20      mhwndForm = FindWindow("ThunderDFrame", Me.Caption)
30      MakeTopmost mhwndForm, True
40  End If
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
10  If CloseMode = vbFormControlMenu Then
20      mclsResizer.FormResize
        'Set mclsResizer = Nothing
30      Me.Hide
40      Application.Visible = True
50      SelectObj PrevSelectedObj
        '
        ' CRW 17 April 2014: whereused can be called externally as well as from NM
        '
60      If Not gfrmNameManager Is Nothing Then Application.OnTime Now, "ShowNMForm"
70      Unload Me
80  End If
End Sub

Private Sub UserForm_Resize()
    Static bMinimized As Boolean

10  If mclsResizer Is Nothing Then Exit Sub
20  If Me.Height < 20 Then
30      bMinimized = True
40  ElseIf bMinimized Then
50      bMinimized = False
60  Else
70      mclsResizer.FormResize
80  End If
End Sub

Public Property Get PrevSelectedObj() As Object
10  Set PrevSelectedObj = mobjPrevSelectedObj
End Property

Public Property Set PrevSelectedObj(objPrevSelectedObj As Object)
10  Set mobjPrevSelectedObj = objPrevSelectedObj
End Property

Private Sub UserForm_Terminate()
10  Set mclsResizer = Nothing
End Sub

Private Sub ParentForm2XL()
10  SetWindowLongPtr mhwndForm, GWL_HWNDPARENT, FindWindow("XLMAIN", Application.Caption)
20  SetActiveWindow mhwndForm
End Sub

Private Sub ParentForm2VBE()

10  SetWindowLongPtr mhwndForm, GWL_HWNDPARENT, Application.VBE.MainWindow.hwnd
20  SetActiveWindow mhwndForm
End Sub



' InQuest injected base64 decoded content
' K+-zc

INQUEST-PP=macro
