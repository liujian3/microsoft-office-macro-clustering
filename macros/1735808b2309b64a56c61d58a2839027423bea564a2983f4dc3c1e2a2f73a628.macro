Attribute VB_Name = "AAA_ExportCode"
Option Explicit

Private Sub CreateXLAXLAM()
  ThisWorkbook.IsAddin = True
  ThisWorkbook.SaveAs ThisWorkbook.path & "\Excel-Sheet-QA.xla", xlAddIn
  ThisWorkbook.IsAddin = False
  ThisWorkbook.Saved = True
End Sub

Sub ResetRight()
  Application.CommandBars("Cell").Reset
  Application.CommandBars("cell").Enabled = True
  Application.CommandBars("PLY").Reset
  Application.CommandBars("ply").Enabled = True
  Application.CommandBars("Column").Reset
  Application.CommandBars("Column").Enabled = True
  Application.CommandBars("Row").Reset
  Application.CommandBars("Row").Enabled = True
  Application.CommandBars("Worksheet Menu Bar").Reset
  Application.CommandBars("Worksheet Menu Bar").Enabled = True
End Sub


Private Sub WBRemoveTags()

    Dim nameItem As Excel.name

GoAgain:
    Dim i As Long
    If ThisWorkbook.names.Count > 0 Then
      For i = 1 To ThisWorkbook.names.Count
          If ThisWorkbook.names(i).Visible = False Then
              If Left(ThisWorkbook.names(i).name, Len("_IDVTracker")) = "_IDVTracker" Then
                  ThisWorkbook.names.item(i).Delete
                  GoTo GoAgain
              End If
          End If
      Next i
    End If

End Sub



Private Sub ExportMyModules()

  Dim cm
  Dim counter As Long
  MkFullDir ThisWorkbook.path & "\vba"
  MyKill ThisWorkbook.path & "\vba\*.bas"
  MyKill ThisWorkbook.path & "\vba\*.cls"
  MyKill ThisWorkbook.path & "\vba\*.frx"
  MyKill ThisWorkbook.path & "\vba\*.frm"
  For Each cm In ThisWorkbook.VBProject.VBComponents
    If Not IsNull(cm) Then
      If cm.CodeModule.CountOfLines > 0 Then
        ExportVBComponent cm, ThisWorkbook.path & "\vba"
      End If
    End If
  Next

End Sub

Private Sub ExportToVB6Project()
  
  Dim pth As String
  pth = "D:\development\Excel-Sheet-QA.VB6"

  Dim cm
  Dim counter As Long
  For Each cm In ThisWorkbook.VBProject.VBComponents
    If Not IsNull(cm) Then
      If cm.CodeModule.CountOfLines > 0 Then
        ExportVBComponent cm, pth & "", , , True
      End If
    End If
  Next

End Sub

Private Sub ExportToDotNetProject()
  
  Dim pth As String
  pth = "D:\development\Exp\ESQA.NET"

  Dim cm
  Dim counter As Long
  For Each cm In ThisWorkbook.VBProject.VBComponents
    If Not IsNull(cm) Then
      If cm.CodeModule.CountOfLines > 0 Then
        ExportVBComponent cm, pth & "", , , , True
      End If
    End If
  Next

End Sub

Private Function ReplaceTextInTextfileVB6(ByVal strFile As String) As Boolean
  Dim pos1 As Long
  Dim pos2 As Long
  Dim tFile As String
  On Error GoTo binCheck
  tFile = ReadTextfile(strFile)
  If Len(tFile) > 0 Then
    tFile = Replace(tFile, " ActiveWorkbook", " Application.ActiveWorkbook")
    tFile = Replace(tFile, "(ActiveWorkbook", "(Application.ActiveWorkbook")
    tFile = Replace(tFile, " ActiveSheet", " Application.ActiveSheet")
    tFile = Replace(tFile, "(ActiveSheet", "(Application.ActiveSheet")
    MyKill strFile
    WriteTextfile strFile, tFile
    ReplaceTextInTextfileVB6 = True
    Exit Function
  End If
  
binCheck:
End Function



Private Function ExportVBComponent(ByRef VBComp, _
                FolderName As String, _
                Optional filename As String, _
                Optional OverwriteExisting As Boolean = True, _
                Optional vb6Ext As Boolean = False, _
                Optional vbnetExt As Boolean = False) As Boolean
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' This function exports the code module of a VBComponent to a text
    ' file. If FileName is missing, the code will be exported to
    ' a file with the same name as the VBComponent followed by the
    ' appropriate extension.
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    Dim Extension As String
    Dim fname As String
    Extension = GetFileExtension(VBComp:=VBComp)
    If Trim(filename) = vbNullString Then
        fname = VBComp.name & Extension
    Else
        fname = filename
        If InStr(1, fname, ".", vbBinaryCompare) = 0 Then
            fname = fname & Extension
        End If
    End If
    
    If StrComp(Right(FolderName, 1), "\", vbBinaryCompare) = 0 Then
        fname = FolderName & fname
    Else
        fname = FolderName & "\" & fname
    End If
    
    If Dir(fname, vbNormal + vbHidden + vbSystem) <> vbNullString Then
        If OverwriteExisting = True Then
            Kill fname
        Else
            ExportVBComponent = False
            Exit Function
        End If
    End If
    
    VBComp.Export filename:=fname
    
    If vb6Ext Then
      If Not ReplaceTextInTextfileVB6(fname) Then
        Debug.Print "No Replace in " & fname
      End If
    End If
    
    If vbnetExt Then
      Name fname As GetFileNameAndPath(fname) & ".vb"
    End If
    
    ExportVBComponent = True
    
    
    End Function
    
    
    
    
Private Function GetFileExtension(ByRef VBComp) As String
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' This returns the appropriate file extension based on the Type of
' the VBComponent.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    Select Case VBComp.Type
        Case 2 ' vbext_ct_ClassModule
            GetFileExtension = ".cls"
        Case 100 ' vbext_ct_Document
            GetFileExtension = ".cls"
        Case 3 ' vbext_ct_MSForm
            GetFileExtension = ".frm"
        Case 1 ' vbext_ct_StdModule
            GetFileExtension = ".bas"
        Case Else
            GetFileExtension = ".bas"
    End Select
    
End Function




Attribute VB_Name = "AboutDlg"
Attribute VB_Base = "0{8416F6C5-2778-44A4-8F9D-B48464F76851}{1EB29A5D-9C42-46B7-A313-BEC17A54343D}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Private Sub CommandButton1_Click()
    AboutDlg.Hide
End Sub

Private Sub Image1_Click()
  On Error Resume Next
  'Call Shell("explorer.exe http://www.stromwerken.de", 1)
  Call Shell("explorer.exe http://" & FMT0("ABOUT_4"), 1)
End Sub

Private Sub Label3_Click()
  On Error Resume Next
  'Call Shell("explorer.exe http://www.stromwerken.de", 1)
  Call Shell("explorer.exe http://" & FMT0("ABOUT_4"), 1)
End Sub

Private Sub UserForm_Initialize()
  gTranslation.TranslateForm Me
End Sub
Attribute VB_Name = "AnalyzeWorker"
Option Explicit

Public G_AI() As CAnalyzeItem
Public G_Localerror As Collection
Public G_FoundCells As Long
Public G_Info_Y As Long
Public G_OriginalWBName As String
Public G_Clones As Collection
Public G_TotalCellsAnalyzed As Long

Sub DoFind(s As String)

On Error GoTo CatchError
  
  thefConstants = False
  If InStr(s, "ESQAFindConstants") > 0 Then thefConstants = True
  thefTextNumbers = False
  If InStr(s, "ESQAFindTextNumbers") > 0 Then thefTextNumbers = True
  thefUnusedNumbers = False
  If InStr(s, "ESQAFindUnusedNumbers") > 0 Then thefUnusedNumbers = True
  thefUnprotectedFormulas = False
  If InStr(s, "ESQAFindFormulaCellsWithoutProtection") > 0 Then thefUnprotectedFormulas = True
  thefErrors = False
  If InStr(s, "ESQAFindErrors") > 0 Then thefErrors = True
  thefForgottenCells = False
  If InStr(s, "ESQAFindForgottenCells") > 0 Then thefForgottenCells = True
  thefInvisibleCells = False
  If InStr(s, "ESQAFindInvisibleCells") > 0 Then thefInvisibleCells = True
  thefExternals = False
  If InStr(s, "ESQAFindExternals") > 0 Then thefExternals = True
  

  G_FoundCells = 0
  Set G_Localerror = New Collection
  
  If Not DoPreparations() Then
    CheckForErrorMessageBox
    Exit Sub
  End If
  
  Dim i As Long
  ReDim G_AI(AI_Max) As CAnalyzeItem
  For i = 1 To AI_Max
    Set G_AI(i) = New CAnalyzeItem
  Next i
  
  G_AI(AI_Constants).Init AI_Constants, thefConstants
  G_AI(AI_UnusedNumbers).Init AI_UnusedNumbers, thefUnusedNumbers
  G_AI(AI_TextNumbers).Init AI_TextNumbers, thefTextNumbers
  G_AI(AI_UnprotectedFormulas).Init AI_UnprotectedFormulas, thefUnprotectedFormulas
  G_AI(AI_Errors).Init AI_Errors, thefErrors
  G_AI(AI_ForgottenCells).Init AI_ForgottenCells, thefForgottenCells
  G_AI(AI_InvisibleCells).Init AI_InvisibleCells, thefInvisibleCells
  G_AI(AI_Externals).Init AI_Externals, thefExternals
  
  Dim errBereich As String
  
  Dim t As Date
  t = Now
  
  errBereich = "1"
  
  ' -----------------------------------------------
  ' Dateiname bestimmen
  ' -----------------------------------------------
  Dim tFName As String
  tFName = ActiveWorkbook.FullName
  If UCase(Right(tFName, 13)) = ".ANALYSE.ESQA" Then
    tFName = Left(tFName, Len(tFName) - 13)
  End If

  ' -----------------------------------------------
  ' Todos laden
  ' -----------------------------------------------
  'If Not G_cTodo.LoadTodoList(tFName & ".ESQATD", ThisWorkbook.path & "\TodoHlp\Todo%1%.mht", tFName, "Empfehlungen / Todos f|fffd|r " & tFName, ThisWorkbook.path & "\Excel-Sheet-QA-Todo.cfg") Then
'  If Not G_cTodo.LoadTodoList(tFName & ".ESQATD", ThisWorkbook.path & "\TodoHlp\Todo%1%.mht", tFName, FMT1("MKOMPLEXE_2", tFName), ThisWorkbook.path & "\Excel-Sheet-QA-Todo.cfg") Then
    'G_cTodo.CreateNewList "ESQA", tFName & ".ESQATD", ThisWorkbook.path & "\TodoHlp\Todo%1%.mht", tFName, "Todos f|fffd|r " & tFName, ThisWorkbook.path & "\Excel-Sheet-QA-Todo.cfg"
'    G_cTodo.CreateNewList "ESQA", tFName & ".ESQATD", ThisWorkbook.path & "\TodoHlp\Todo%1%.mht", tFName, FMT1("MKOMPLEXE_2", tFName), ThisWorkbook.path & "\Excel-Sheet-QA-Todo.cfg"
'  End If
  
  
  ' -----------------------------------------------
  ' Bestimmung aktuelles Worksheet
  ' -----------------------------------------------
  Dim currentactivesheet As Worksheet
  If TypeName(ActiveSheet) = "Worksheet" Then
    Set currentactivesheet = ActiveSheet
  Else
    Set currentactivesheet = Nothing
  End If
  
  errBereich = "2"
  If Not currentactivesheet Is Nothing Then AnalyseCreateResbook currentactivesheet
  
  errBereich = "5"
  
  Dim auswertanzahl As Long
  auswertanzahl = 0
  
  Dim wsactivated As Boolean
  
  errBereich = "6"
  Dim ws As Worksheet
  
  
  ' -----------------------------------------------
  ' Entsperren der Worksheets und Formatr|fffd|cksetzung
  ' -----------------------------------------------
  Dim calc As Long
  Dim bEnableEvents As Boolean
  Dim bScreenUpdating As Boolean
  DisableExcel calc, bScreenUpdating, bEnableEvents
    
  If ColourCurrentTable Then
        ' -----------------------------------------------
        ' Klone
        ' -----------------------------------------------
        If TypeName(ActiveSheet) = "Worksheet" Then
          ResetSheetFormats ActiveSheet
        End If
  Else
    For Each ws In ActiveWorkbook.Worksheets
      If Left(ws.name, 5) <> "ESQA." Then
        If TypeName(ws) = "Worksheet" Then
          ResetSheetFormats ws
        End If
      End If
      If Abbruch Then Exit For
    Next ws
  End If
  
  ' -----------------------------------------------
  ' Ergebnissheets bauen
  ' -----------------------------------------------
  ' Pr|fffd|fung f|fffd|r unsichtbare Zellen, ob die Originaldatei ge|fffd|ffnet ist
  DisableExcelNoStore
  If thefInvisibleCells Then
    Dim wbname As String
    wbname = Left(ActiveWorkbook.name, Len(ActiveWorkbook.name) - 13)
    If Not WorkbookExists(wbname) Then
      'MsgBox "Um diese Funktion auszuf|fffd|hren muss die Originaldatei ge|fffd|ffnet sein, da nur dort die Formatierungen noch vorhanden sind.", vbCritical, "ESQA " & MyVersion
      MsgBox FMT0("MSTART_63"), vbCritical, "ESQA " & MyVersion
      thefInvisibleCells = False
      G_AI(AI_InvisibleCells).m_Active = False
    End If
  End If
  
  AnalyseCreateRessheet auswertanzahl, currentactivesheet
  
  DisableExcelNoStore
  ' Pr|fffd|fen bei vergessenen Zellen, ob die verkn|fffd|pften Dateien ge|fffd|ffnet sind
  Dim oneNotFound As Boolean
  If thefForgottenCells Then
    If HasExternalLinks(ActiveWorkbook) Then
      If thefForgottenCells Then
        ' Und jetzt alle verlinkten |fffd|ffnen (falls m|fffd|glich)
        If Not OpenAllLinks(ActiveWorkbook) Then
          oneNotFound = True
'            UpdateStatus "", -1
'            thefForgottenCells = False
'            G_AI(AI_ForgottenCells).m_Active = False
        End If
      End If
      
      If oneNotFound Then
        'MsgBox "Achtung: Es konnten nicht alle verlinkten Dateien ge|fffd|ffnet werden. Bitte pr|fffd|fen Sie die Linkliste (Bearbeiten/Verkn|fffd|pfungen) und laden die Dateien manuell. Die Funktion wird abgebrochen!", vbCritical, "ESQA " & MyVersion
        MsgBox FMT0("MSTART_91"), vbCritical, "ESQA " & MyVersion
        G_AI(AI_ForgottenCells).AddResultText ""
        G_AI(AI_ForgottenCells).AddResultText FMT0("MSTART_91"), True, RGB(255, 0, 0)
        G_AI(AI_ForgottenCells).AddResultText ""
      End If
    End If
  End If
  
  
  errBereich = "18"
  
  ' xxx
  ' ACHTUNG: HIER KEINEN CODE EINF|fffd|GEN, DA FORGOTTEN CELLS evtl. andere Dateien ge|fffd|ffnet hat!
  
  ' -----------------------------------------------
  ' Noch mal Worksheet aktivieren
  ' -----------------------------------------------
  If Not currentactivesheet Is Nothing Then ActivateWorksheet currentactivesheet
  
  Dim localerror As New Collection
  
  G_OriginalWBName = Left(ActiveWorkbook.name, Len(ActiveWorkbook.name) - 13)

  
  ' -----------------------------------------------
  ' Berechnung aus
  ' -----------------------------------------------
  DisableExcelNoStore


  ' -----------------------------------------------
  ' Nur das aktuelle Worksheet oder alle?
  ' -----------------------------------------------
  
#If TIMECHECK = 1 Then
  Set G_HRT = New HighResTimer
#End If
  
  G_TotalCellsAnalyzed = 0
  If ColourCurrentTable Then
    AnalyseWS ActiveSheet
  Else
    errBereich = "18.2"
    For Each ws In ActiveWorkbook.Worksheets
      AnalyseWS ws
      If Abbruch Then Exit For
    Next ws
  End If
  
#If TIMECHECK = 1 Then
  G_HRT.Dump
  Set G_HRT = Nothing
#End If
  
  
  DisableExcelNoStore
  
  Dim restext As String
  
  'If ColourCurrentTable Then restext = "Auswertung f|fffd|r Tabelle '" & ActiveSheet.name & "'" & vbLf & vbLf & restext
  If ColourCurrentTable Then restext = FMT1("MCOL_2", ActiveSheet.name)

  'If FullVersion = False Then restext = "Demoversion: Es werden nur die ersten 10 Spalten * 40 Zeilen eingef|fffd|rbt. Die genannten Mengen beziehen sich auf das Gesamtdokument!" & vbLf & vbLf & restext
  If FullVersion = False Then restext = FMT0("MCOL_1") & restext
  
  restext = restext & AnalyseSetResultTexts
  
  ' -----------------------------------------------
  ' ABBRUCH?
  ' -----------------------------------------------
  If Abbruch Then
    'restext = restext & "Aktion abgebrochen!" & vbCrLf
    restext = restext & FMT0("MSTART_76") & vbCrLf
  End If
  
  ' -----------------------------------------------
  ' FEHLER?
  ' -----------------------------------------------
  If G_AnalyzeErrors > 0 Then
    'restext = restext & G_AnalyzeErrors & "Zelle(n) konnten nicht analysiert werden! Die entsprechenden Zellen sind im Ergebnisreport aufgef|fffd|hrt." & vbCrLf
    restext = restext & FMT1("MSTART_77", G_AnalyzeErrors) & vbCrLf
  End If
 
  
  UpdateStatus "", -1
  StatusForm.Hide
  
  errBereich = "30"
  EnableExcel calc, bEnableEvents, bScreenUpdating
  
  CheckErrorMessage
  
  If TypeName(currentactivesheet) = "Worksheet" Then currentactivesheet.Activate
  
  SetStartSheetAndCell

  ' -----------------------------------------------
  ' Ergebnis in MSG-Box ausgeben
  ' -----------------------------------------------
  If Abbruch = False And restext <> "" And AnalyseActive = True Then
    
    restext = FMT0("MSTART_89") & " " & ElapsedTime(Now, t) & " - " & FMT1("MSTART_90", G_TotalCellsAnalyzed) & vbCrLf & vbCrLf & restext

    If theResbook Is Nothing Then
      MsgBox restext, vbInformation, "ESQA " & MyVersion
    Else
        'If MsgBox(restext & vbLf & vbLf & "Wollen Sie zum Ergebnisblatt wechseln?", vbYesNo, "ESQA " & MyVersion) = vbYes Then
        If MsgBox(restext & vbLf & vbLf & FMT0("MSTART_78"), vbYesNo, "ESQA " & MyVersion) = vbYes Then
        
          If auswertanzahl > 1 Then
            theResbook.Sheets("ESQA.Info").Activate
          Else
              AnalyseActivateResultSheet
          End If
        End If
    End If
    CheckForErrorMessageBox
    
  End If
  
  Exit Sub

CatchError:

  G_ErrorCount = G_ErrorCount + 1
  G_ErrorText = G_ErrorText & "Error in DoFindFunc (Area: " & errBereich & "): " & Err.Number & " - " & Err.Description & vbCrLf
  Resume Next
  
End Sub

Sub CheckForErrorMessageBox()
    If G_ErrorCount > 0 Then
      MsgBox "Errors: " & G_ErrorCount & vbCrLf & vbCrLf & G_ErrorText
    End If
End Sub

Function AnalyseActive() As Boolean
  Dim i As Long
  For i = 1 To AI_Max
    If G_AI(i).m_Active Then
      AnalyseActive = True
      Exit Function
    End If
  Next i
End Function
Sub AnalyseInitWS(ByRef ws As Worksheet)
  Set G_Clones = New Collection
  
  If theResbook Is Nothing Then Exit Sub
      
  Dim i As Long
  For i = 1 To AI_Max
    G_AI(i).InitWS ws
  Next i
End Sub

Sub AnalyseFinalizeWS(ByRef ws As Worksheet)
  Dim i As Long
  For i = 1 To AI_Max
    G_AI(i).FinalizeWS ws
  Next i
  Set G_Clones = Nothing
End Sub

Sub AnalyseActivateResultSheet()
  Dim i As Long
  For i = 1 To AI_Max
    If G_AI(i).ActivateResultSheet Then Exit Sub
  Next i
End Sub


Function AnalyseSetResultTexts() As String
  Dim i As Long
  Dim ts As String
  
  G_Info_Y = INFO_StartY
  For i = 1 To AI_Max
    Dim s As String
    s = G_AI(i).SetResultText
    If s <> "" Then
      ts = ts & IIf(ts <> "", vbCrLf, "") & s
    End If
  Next i
  AnalyseSetResultTexts = ts
End Function

Sub AnalyseCreateRessheet(ByRef auswertanzahl As Long, ByRef currentactivesheet As Worksheet)
  Dim i As Long
  For i = 1 To AI_Max
    G_AI(i).CreateRessheet auswertanzahl, currentactivesheet
  Next i

End Sub

Sub AnalyseCreateResbook(currentactivesheet As Worksheet)

  On Error Resume Next
  
  Set theRessheet = Nothing
  Set theResbook = Nothing
  theRessheetY = 0
  
  Dim found As Boolean
  found = False
  Dim resbook As Workbook
  
  ' -----------------------------------------------
  ' Gibt es schon ein INFO-Blatt?
  ' -----------------------------------------------
  If G_ErgebnisseInEigenerDatei = False Then
      ' Wenn alle Ergebnisse ins Analyse-Sheet sollen
      For Each theRessheet In ActiveWorkbook.Worksheets
        If theRessheet.name = "ESQA.Info" Then
          If Left(theRessheet.Cells(1, 1), Len("Excel-Sheet-QA")) = "Excel-Sheet-QA" Then
            If UCase(theRessheet.Cells(3, 1)) & ".ANALYSE.ESQA" = UCase(ActiveWorkbook.FullName) Or UCase(theRessheet.Cells(3, 1)) = UCase(ActiveWorkbook.FullName) Then
              found = True
              Exit For
            End If
          End If
        End If
      Next theRessheet
  Else
      For Each resbook In Workbooks
        For Each theRessheet In resbook.Worksheets
          If theRessheet.name = "ESQA.Info" Then
            If Left(theRessheet.Cells(1, 1), Len("Excel-Sheet-QA")) = "Excel-Sheet-QA" Then
              If UCase(theRessheet.Cells(3, 1)) & ".ANALYSE.ESQA" = UCase(ActiveWorkbook.FullName) Or UCase(theRessheet.Cells(3, 1)) = UCase(ActiveWorkbook.FullName) Then
                found = True
                Exit For
              End If
            End If
          End If
        Next theRessheet
        If found = True Then Exit For
      Next resbook
  End If
  
  ' -----------------------------------------------
  ' Kein INFO-Blatt vorhanden
  ' -----------------------------------------------
  If Not found Then
    ' Wenn alle Ergebnisse ins Analyse-Sheet sollen
    If G_ErgebnisseInEigenerDatei = False Then
        Set theResbook = ActiveWorkbook
        theResbook.Sheets.Add , theResbook.Sheets(theResbook.Sheets.Count)
        theResbook.Sheets(theResbook.Sheets.Count).name = "ESQA.Info"
        Set theRessheet = ActiveSheet
        
    Else
        Workbooks.Add
        Set theResbook = ActiveWorkbook
        Set theRessheet = ActiveSheet
        
        Sheets(1).name = "ESQA.Info"
        Application.DisplayAlerts = False
        Sheets(2).Delete
        Sheets(2).Delete
        Application.DisplayAlerts = True
    End If
    
    'theRessheet.Cells(1, 1) = "Excel-Sheet-QA - " & MyVersion & " |fffd| Stromwerken 2001 - " & year(Now) & " - Lizenz f|fffd|r: " & RemoveText(G_Lizenznehmer, vbCr) & IIf(FullVersion = False, " - Demoversion!", "")
    theRessheet.Cells(1, 1) = FMT3("RESULTSHEET_1", MyVersion, year(Now), RemoveText(G_Lizenznehmer, vbCr)) & IIf(FullVersion = False, FMT0("RESULTSHEET_2"), "")
    theRessheet.Cells(3, 1) = Replace(currentactivesheet.Parent.FullName, ".ANALYSE.ESQA", "")
    
    With theRessheet.Cells(1, 1).Font
        .bold = True
        .name = "Arial"
        .Size = 10
        .ColorIndex = 3
    End With
    theRessheet.Cells(3, 1).Font.bold = True
    
    theRessheetY = 4
    If Len(currentactivesheet.Parent.Title) > 0 Then
      'theRessheet.Cells(theRessheetY, 1) = "Titel:"
      theRessheet.Cells(theRessheetY, 1) = FMT0("RESULTSHEET_3")
      theRessheet.Cells(theRessheetY, 2) = currentactivesheet.Parent.Title
      theRessheetY = theRessheetY + 1
    End If
    If Len(currentactivesheet.Parent.Author) > 0 Then
      'theRessheet.Cells(theRessheetY, 1) = "Autor:"
      theRessheet.Cells(theRessheetY, 1) = FMT0("RESULTSHEET_4")
      theRessheet.Cells(theRessheetY, 2) = currentactivesheet.Parent.Author
      theRessheetY = theRessheetY + 1
    End If
    If Len(currentactivesheet.Parent.Subject) > 0 Then
      'theRessheet.Cells(theRessheetY, 1) = "Thema:"
      theRessheet.Cells(theRessheetY, 1) = FMT0("RESULTSHEET_5")
      theRessheet.Cells(theRessheetY, 2) = currentactivesheet.Parent.Subject
      theRessheetY = theRessheetY + 1
    End If

  Else
    Set theResbook = theRessheet.Parent
  End If
  
  currentactivesheet.Activate
End Sub


Sub AnalyseWS(ByRef ws As Worksheet)
On Error GoTo CatchError

 Dim errBereich As String
       
   If Left(ws.name, 5) <> "ESQA." Then
    If TypeName(ws) = "Worksheet" Then
      errBereich = "1"
      AnalyseInitWS ws
      
      Dim lineCount As Long
      Dim totalLineAmount As Long
      Dim lastCell As Range
      Dim lineCells As Range
      Dim c As Range
      Dim lastTime As Date
        
      Dim lastRow As Long
      ws.ScrollArea = ""
      lastRow = GetLastRow(ws)
      
      errBereich = "2"
      
      If lastRow > 0 Then
                    
        totalLineAmount = lastRow
        
        If lastRow > 40 And FullVersion = False Then
          lastRow = 40
        End If
        
        DisableExcelNoStore
        
        lastTime = Now
        For lineCount = 1 To lastRow
                ' --------------------------------------------------
                ' Formel-Funktionen
                ' --------------------------------------------------
                Set lineCells = GetFormulaRangeLine(ws, lineCount)
          
                If Not lineCells Is Nothing Then
                    For Each c In lineCells
                      If c.HasFormula Then
                              errBereich = "WS:" & c.Parent.name & "!" & c.Address
      
                              If Not FormulaAnalyzable(c) Then
                                ' XXX
                              Else
                                    ' NEIN, Formel kann analysiert werden!
                                    ' --------------------------------------------------
                                    ' Clone identifizieren
                                    ' --------------------------------------------------
                                    Dim cs As CCloneStuff
                                    
                                    isClone c, cs
                                    ' --------------------------------------------------
                                    ' Wenn NICHT Clon
                                    ' --------------------------------------------------
                                    If thefConstants Then G_AI(AI_Constants).FindConstants c, cs
                                    If thefForgottenCells Then G_AI(AI_ForgottenCells).FindForgottenCells c
                                    If thefErrors Then G_AI(AI_Errors).FindErrors c, cs
                                    If thefUnprotectedFormulas Then G_AI(AI_UnprotectedFormulas).FindUnprotectedFormulas c
                                    If thefInvisibleCells Then G_AI(AI_InvisibleCells).FindInvisibleCells c, cs
                                    If thefExternals Then G_AI(AI_Externals).FindExternals c, cs
                              End If
                      End If
                    Next c
                    G_TotalCellsAnalyzed = G_TotalCellsAnalyzed + lineCells.Count
                End If
                ' --------------------------------------------------
                ' Nicht-Formel-Zellen
                ' --------------------------------------------------
                Set lineCells = GetNonFormulaRangeLine(ws, lineCount)
          
                If Not lineCells Is Nothing Then
                
'                    Dim tn As Boolean
'                    If thefUnusedNumbers Then
'                      tn = False
'                      If G_AI(AI_UnusedNumbers).FindUnusedNumbers(lineCells) Then
'                        tn = True
'                      End If
'                    End If
                
                    For Each c In lineCells
                         
                        If IsNumeric(c.value) = True Then
'                          If thefUnusedNumbers = True And tn = True Then G_AI(AI_UnusedNumbers).FindUnusedNumbers c
                          If thefUnusedNumbers Then G_AI(AI_UnusedNumbers).FindUnusedNumbers c
                          If thefTextNumbers Then G_AI(AI_TextNumbers).FindTextNumbers c
                        End If
                        If thefInvisibleCells Then G_AI(AI_InvisibleCells).FindInvisibleCells c, Nothing
                    Next c
                    G_TotalCellsAnalyzed = G_TotalCellsAnalyzed + lineCells.Count
                End If
          
          
'          If lineCount Mod 1 = 0 Then
          If lastTime + TimeValue("0:00:01") <= Now Or lineCount Mod 2 = 0 Then
            'UpdateStatus "Analysiere '" & ActiveSheet.name & "'", CDbl(cnt) / CDbl(totalamount)
            UpdateStatus FMT1("START_10", ws.name), CDbl(lineCount) / CDbl(totalLineAmount)
            lastTime = Now
          End If
          If Abbruch Then Exit For
        Next lineCount
      End If
      
    End If
  End If
  
  If thefUnusedNumbers Then
    ws.ClearArrows
  End If
  
  errBereich = "3"
  AnalyseFinalizeWS ws
  errBereich = "4"
  
  Exit Sub
CatchError:

  G_ErrorCount = G_ErrorCount + 1
  G_ErrorText = G_ErrorText & "Error in AnalyseWS (Area: " & errBereich & "): " & Err.Number & " - " & Err.Description & vbCrLf
  Resume Next
End Sub

Function isClone(ByRef c As Range, ByRef cs As CCloneStuff) As Boolean
  
  If Not FormulaR1C1Readable(c) Then
    isClone = False
    Exit Function
  End If

  On Error GoTo notExistant
  Dim a As String
  a = c.FormulaR1C1
  Set cs = G_Clones(a)
  isClone = True
  cs.AddClone c
  
  Exit Function
notExistant:
  isClone = False
  Set cs = New CCloneStuff
  cs.m_Formula = a
  G_Clones.Add cs, a
End Function


Function GetErrorTexts() As String
  Dim s As String
  If G_AnalyzeErrors > 0 Then
    s = vbCrLf & vbCrLf & FMT1("HELPERS_19", G_AnalyzeErrors)
  End If
  
  If G_FormatErrorCount > 0 Then
    s = s & vbCrLf & vbCrLf & FMT1("HELPERS_3", G_FormatErrorCount)
  End If
  GetErrorTexts = s
End Function

Function ElapsedTime(endTime As Date, startTime As Date) As String
    Dim strOutput As String
    Dim Interval As Date
     
    ' Calculate the time interval.
    Interval = endTime - startTime
  
    ' Format and print the time interval in seconds.
    ' strOutput = Int(CSng(Interval * 24 * 3600)) & " Seconds"
    ' Debug.Print strOutput
         
    ' Format and print the time interval in minutes and seconds.
    ' strOutput = Int(CSng(Interval * 24 * 60)) & ":" & Format(Interval, "ss") _
    '     & " Minutes:Seconds"
    ' Debug.Print strOutput
     
    ' Format and print the time interval in hours, minutes and seconds.
    ' strOutput = Int(CSng(Interval * 24)) & ":" & Format(Interval, "nn:ss") _
           & " Hours:Minutes:Seconds"
    
    ElapsedTime = Format(Int(CSng(Interval * 24)), "00") & ":" & Format(Interval, "nn:ss")
         
    ' Format and print the time interval in days, hours, minutes and seconds.
    ' strOutput = Int(CSng(Interval)) & " days " & Format(Interval, "hh") _
    '     & " Hours " & Format(Interval, "nn") & " Minutes " & _
    '     Format(Interval, "ss") & " Seconds"
    ' Debug.Print strOutput
 
End Function

Attribute VB_Name = "BitteWarten"
Attribute VB_Base = "0{1F6E775B-E501-4E93-B6EE-67C6D71D7598}{1DE363CF-12E4-4B73-96D0-C5599303D7FF}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Private Sub UserForm_Initialize()
  gTranslation.TranslateForm Me
End Sub
Attribute VB_Name = "CAnalyzeItem"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public Enum AnalyzeType
  AI_Constants = 1
  AI_UnusedNumbers = 2
  AI_TextNumbers = 3
  AI_UnprotectedFormulas = 4
  AI_Errors = 5
  AI_ForgottenCells = 6
  AI_InvisibleCells = 7
  AI_Externals = 8
  
  AI_Max = 8
End Enum

Private Const LC_Txt As String = _
  "AI_Constants               ,MSTART_55,     MSTART_55,     MSTART_69," & _
  "AI_UnusedNumbers           ,MSTART_58,     MSTART_59,     MSTART_71," & _
  "AI_TextNumbers             ,MSTART_56,     MSTART_57,     MSTART_70," & _
  "AI_UnprotectedFormulas     ,MSTART_60,     MSTART_60,     MSTART_72," & _
  "AI_Errors                  ,MSTART_54,     MSTART_54,     MSTART_68," & _
  "AI_ForgottenCells          ,MSTART_66,     MSTART_66,     MSTART_74," & _
  "AI_InvisibleCells          ,MSTART_64,     MSTART_64,     MSTART_75," & _
  "AI_Externals               ,MFEXTERNALS_1, MFEXTERNALS_2, MFEXTERNALS_5"


'  "AI_EmptyCellsUsedByFormulas,MSTART_61,MSTART_62,MSTART_73," & _


Public m_Type As AnalyzeType
Public m_Active As Boolean
Public m_Resultsheet As Worksheet
Public m_ResultsheetY As Long
Public m_ResultsheetName As String
Public m_ResultsheetHeadline As String
Public m_Amount As Long
Public m_AmountClones As Long
Public m_AmountWS As Long
Public m_AmountClonesWS As Long
Public m_CellAreas As CCellAreas

Public m_WSMaxx As Long
Public m_WSMaxy As Long

Private Enum AnalyzeText
  AT_AnalyseName = 1
  AT_Sheetname = 2
  AT_Sheetheadline = 3
  AT_Result = 4
  
  AT_Max = 4
End Enum

Private m_Texts(AT_Max) As String

' Alles mit Parametern

Public m_AnalyseName As String
Public m_Todoname As String
Public m_Formatname As String
Public m_CanUseClones As Boolean

Private Enum Param
  P_AnalyseName = 1
  P_Todoname = 2
  P_Formatname = 3
  P_CanUseClones = 4
  P_PrintArea = 5
  P_BWdth = 6
  P_CWdth = 7
  P_DWdth = 8
  
  P_Max = 8
End Enum

Private Const LC_Param As String = _
  "Name                       ,TODO,        FORMATS,                               CANUSECLONES, PRINTAREA, BW, CW, DW," & _
  "AI_Constants               ,ESQACONST,   ESQAFindConstants,                     true,         C,         73, 25,   ," & _
  "AI_UnusedNumbers           ,ESQAUNNR,    ESQAFindUnusedNumbers,                 ,             B,         73, 25,   ," & _
  "AI_TextNumbers             ,ESQATXTNR,   ESQAFindTextNumbers,                   ,             B,         73, 25,   ," & _
  "AI_UnprotectedFormulas     ,ESQAUPROT,   ESQAFindFormulaCellsWithoutProtection, ,             B,         73, 25,   ," & _
  "AI_Errors                  ,ESQAERR,     ESQAFindErrors,                        true,         C,         73, 25,   ," & _
  "AI_ForgottenCells          ,ESQAFORGOT,  ESQAFindForgottenCells1,               ,             D,         25, 10, 73," & _
  "AI_InvisibleCells          ,ESQAINVISIB, ESQAFindInvisibleCells,                true,         C,         73, 25,   ," & _
  "AI_Externals               ,,            ESQAFindExternals,                     true,         C,         73, 25, 73,"

Private Function GettextTag(ByVal at As AnalyzeText) As String
  GettextTag = Trim(Split(LC_Txt, ",")((m_Type - 1) * AT_Max + at - 1))
End Function

Private Function GetParameterText(ByVal p As Param)
  GetParameterText = Trim(Split(LC_Param, ",")((m_Type) * P_Max + p - 1))
End Function

Sub Init(ByVal t As AnalyzeType, ByVal active As Boolean)
  m_Type = t
  m_ResultsheetY = 1
  m_ResultsheetName = FMT0(GettextTag(AT_Sheetname))
  m_ResultsheetHeadline = FMT0(GettextTag(AT_Sheetheadline))
  m_Active = active

  m_AnalyseName = GetParameterText(P_AnalyseName)
  m_Todoname = GetParameterText(P_Todoname)
  m_Formatname = GetParameterText(P_Formatname)
  m_CanUseClones = GetParameterText(P_CanUseClones) = "true"

End Sub

Sub InitWS(ByRef ws As Worksheet)

  If Not m_Active Then Exit Sub
  
  Set G_Clones = New Collection
  
  If m_Type = AI_UnusedNumbers Or m_Type = AI_UnprotectedFormulas Or m_Type = AI_InvisibleCells Then
    Set m_CellAreas = New CCellAreas
  End If
  
  m_WSMaxx = ws.Columns.Count
  m_WSMaxy = ws.Rows.Count
  
  If m_Resultsheet Is Nothing Then Exit Sub
  
  m_AmountWS = 0
  m_AmountClonesWS = 0
  
  'theRessheet.Cells(theRessheetY, 1) = "Tabelle: '" & ActiveSheet.name & "'"
  m_Resultsheet.Cells(m_ResultsheetY, 1) = FMT1("ANALYSE_1", ws.name)
  m_Resultsheet.Cells(m_ResultsheetY, 1).Font.bold = True
  
  If m_CanUseClones Then
    m_Resultsheet.Cells(m_ResultsheetY, 3) = FMT0("ANALYSE_3")
    m_Resultsheet.Cells(m_ResultsheetY, 3).Font.bold = True
  End If
  m_ResultsheetY = m_ResultsheetY + 1
End Sub

Function AddResultText(ByVal t As String, Optional bold As Boolean = False, Optional col As Long = 0) As String
    m_Resultsheet.Cells(m_ResultsheetY, 1) = t
    If bold Then m_Resultsheet.Cells(m_ResultsheetY, 1).Font.bold = True
    m_Resultsheet.Cells(m_ResultsheetY, 1).Font.Color = col
    m_ResultsheetY = m_ResultsheetY + 1
End Function



Sub CorrectCloneRow(ByVal y As Long, ByVal addedLines)
  Dim cs As CCloneStuff
  If Not G_Clones Is Nothing Then
    If G_Clones.Count > 0 Then
      For Each cs In G_Clones
        If cs.isCloneOfType(m_Type) Then
          If cs.GetAIRow(m_Type) > y Then
            cs.SetAIRow m_Type, cs.GetAIRow(m_Type) + addedLines
          End If
        End If
      Next cs
    End If
  End If

End Sub


Sub FinalizeWS(ByRef ws As Worksheet)
  If Not m_Active Then Exit Sub
  
  If m_Resultsheet Is Nothing Then Exit Sub
  
  ' Jetzt holen wir noch alle Kloninfos!
  Dim cs As CCloneStuff
  If Not G_Clones Is Nothing Then
    If G_Clones.Count > 0 Then
      For Each cs In G_Clones
        If cs.isCloneOfType(m_Type) Then
          If cs.GetAIRow(m_Type) > 0 Then
            If cs.m_Amount > 0 Then
              Dim clones As String
              clones = cs.CrunchClones
              If G_KloneEinzeln Then
                  Dim addedLines As Long
                  addedLines = 0
                  m_Resultsheet.Cells(cs.GetAIRow(m_Type) + addedLines, 3) = cs.m_Amount
                  cs.InsertClonesAsSingleLines ws.Parent.FullName, ws.name, m_Resultsheet, cs.GetAIRow(m_Type) + 1, addedLines
                  CorrectCloneRow cs.GetAIRow(m_Type), addedLines
                  m_ResultsheetY = m_ResultsheetY + addedLines
              Else
                  m_Resultsheet.Cells(cs.GetAIRow(m_Type), 3) = cs.m_Amount & IIf(clones <> "", " - " & clones, "")
              End If
            Else
              m_Resultsheet.Cells(cs.GetAIRow(m_Type), 3) = "'-/-"
            End If
          End If
        End If
      Next cs
    End If
  End If
  
  Dim ca As CCellArea
  If Not m_CellAreas Is Nothing Then
    m_CellAreas.Crunch
    For Each ca In m_CellAreas.m_Cells
      m_Resultsheet.Cells(m_ResultsheetY, 1).FormulaLocal = "=HYPERLINK(" & Chr(34) & Replace(ws.Parent.FullName, ".ANALYSE.ESQA", "") & "#'" & ws.name & "'!" & ca.GetAreaString & Chr(34) & ";" & Chr(34) & ca.GetAreaString & Chr(34) & ")"
      ' m_Resultsheet.Cells(m_ResultsheetY, 2) = "'" & GetFormula(c)
      m_ResultsheetY = m_ResultsheetY + 1
    Next ca
  End If

  
  
  
  
    'theRessheet.Cells(theRessheetY, 1) = "%1 Zelle(n) gefunden."
  m_Resultsheet.Cells(m_ResultsheetY, 1) = FMT1("ANALYSE_2", m_AmountWS)
'  If m_AmountClonesWS <= 0 Then
'    m_Resultsheet.Cells(m_ResultsheetY, 1) = FMT1("ANALYSE_2", m_AmountWS)
'  Else
'    'theRessheet.Cells(theRessheetY, 1) = "%1 individuelle Zelle(n) und %2 Klone gefunden."
'    m_Resultsheet.Cells(m_ResultsheetY, 1) = FMT2("ANALYSE_3", m_AmountWS, m_AmountClonesWS)
'  End If
  
  m_ResultsheetY = m_ResultsheetY + 2
  
  m_Amount = m_Amount + m_AmountWS
  m_AmountClones = m_AmountClones + m_AmountClonesWS
End Sub

Function SetResultText() As String
  If m_Active Then
    'restext = restext & fconstAmount & " Zelle(n) mit Konstanten in Formeln gefunden." & vbCrLf
    SetResultText = FMT1(GettextTag(AT_Result), m_Amount + m_AmountClones) & IIf(m_AmountClones > 0, " " & FMT1("ANALYSE_5", m_AmountClones), "")
    If Not theResbook Is Nothing Then
      'theResbook.Sheets("ESQA.Info").Hyperlinks.Add Anchor:=theResbook.Sheets("ESQA.Info").Cells(INFO_ConstantsY, 1), Address:="", SubAddress:= _
      '    "'ESQA.Formeln mit Konstanten'!A1", TextToDisplay:=fconstAmount & " Zelle(n) mit Konstanten in Formeln gefunden."
      theResbook.Sheets("ESQA.Info").Hyperlinks.Add Anchor:=theResbook.Sheets("ESQA.Info").Cells(G_Info_Y, 1), Address:="", SubAddress:= _
          "'ESQA." & m_ResultsheetName & "'!A1", TextToDisplay:=FMT1(GettextTag(AT_Result), m_Amount) & IIf(m_AmountClones > 0, " " & FMT1("ANALYSE_5", m_AmountClones), "")
      G_Info_Y = G_Info_Y + 1
    End If
'    G_cTodo.RemoveAllNonModifiedContents m_Todoname
  End If
End Function

Function ActivateResultSheet() As Boolean
  If Not m_Active Then Exit Function
  theResbook.Sheets("ESQA." & FMT0(GettextTag(AT_Sheetname))).Activate
  ActivateResultSheet = True
End Function


Sub CreateRessheet(ByRef auswertanzahl As Long, currentactivesheet As Worksheet)

  If Not m_Active Then Exit Sub
  
  Set m_Resultsheet = Nothing

  auswertanzahl = auswertanzahl + 1

  On Error Resume Next

  If theResbook Is Nothing Then Exit Sub
  If SheetExists(theResbook, "ESQA." & m_ResultsheetName) Then
    theResbook.Sheets("ESQA." & m_ResultsheetName).Cells.Delete Shift:=xlUp
    Set m_Resultsheet = theResbook.Sheets("ESQA." & m_ResultsheetName)
  Else
    theResbook.Sheets.Add , theResbook.Sheets(theResbook.Sheets.Count)
    theResbook.Sheets(theResbook.Sheets.Count).name = "ESQA." & m_ResultsheetName
    Set m_Resultsheet = theResbook.Sheets("ESQA." & m_ResultsheetName)
  
  
    'theResbook.Sheets("ESQA." & m_ResultsheetName).Cells(1, 1) = "Excel-Sheet-QA - " & MyVersion & " |fffd| Stromwerken 2001 - " & year(Now) & " - Lizenz f|fffd|r: " & RemoveText(G_Lizenznehmer, vbCr) & IIf(FullVersion = False, " - Demoversion!", "")
    m_Resultsheet.Cells(1, 1) = FMT3("RESULTSHEET_1", MyVersion, year(Now), RemoveText(G_Lizenznehmer, vbCr)) & IIf(FullVersion = False, FMT0("RESULTSHEET_2"), "")
    m_Resultsheet.Cells(3, 1) = Replace(currentactivesheet.Parent.FullName, ".ANALYSE.ESQA", "")
  
  End If
  
  m_Resultsheet.Cells(1, 1) = m_ResultsheetHeadline & " (" & Now() & ")"
  m_Resultsheet.Cells(2, 1) = Replace(currentactivesheet.Parent.FullName, ".ANALYSE.ESQA", "")
    
  'm_Resultsheet.Hyperlinks.Add Anchor:=m_Resultsheet.Cells(3, 1), Address:="", SubAddress:= _
  '    "ESQA.Info!A1", TextToDisplay:="Zur|fffd|ck zur |fffd|bersicht"
  m_Resultsheet.Hyperlinks.Add Anchor:=m_Resultsheet.Cells(3, 1), Address:="", SubAddress:= _
      "ESQA.Info!A1", TextToDisplay:=FMT0("RESULTSHEET_6")
    
    
  With m_Resultsheet.Cells(1, 1).Font
    .bold = True
    .ColorIndex = 3
    .Size = 10
  End With
  
  With m_Resultsheet.Columns("A:B")
      .HorizontalAlignment = xlGeneral
      .VerticalAlignment = xlTop
      .WrapText = False
      .Orientation = 0
      .AddIndent = False
      .IndentLevel = 0
      .ShrinkToFit = False
      .ReadingOrder = xlContext
      .MergeCells = False
  End With
  With m_Resultsheet.Columns("B:B")
      .ColumnWidth = GetParameterText(P_BWdth)
      .WrapText = True
  End With
  If GetParameterText(P_CWdth) <> "" Then
    With m_Resultsheet.Columns("C:C")
        .ColumnWidth = GetParameterText(P_CWdth)
        .WrapText = True
    End With
  End If
  If GetParameterText(P_DWdth) <> "" Then
    With m_Resultsheet.Columns("D:D")
        .ColumnWidth = GetParameterText(P_DWdth)
        .WrapText = True
    End With
  End If
  
  Application.PrintCommunication = False
  With m_Resultsheet.PageSetup
      .PrintArea = "$A:$" & GetParameterText(P_PrintArea)
      .LeftHeader = ""
      .CenterHeader = ""
      .RightHeader = ""
      .LeftFooter = ""
      .CenterFooter = ""
      .RightFooter = ""
      .FitToPagesWide = 1
      .FitToPagesTall = False
  End With
  Application.PrintCommunication = True
  
  m_ResultsheetY = 5
End Sub

Sub PrintResult(ByRef c As Range)
  If Not theResbook Is Nothing Then
    ' theRessheetConstants.Cells(theRessheetConstantsY, 1) = RemoveText(c.Address, "$")
    m_Resultsheet.Cells(m_ResultsheetY, 1).FormulaLocal = "=HYPERLINK(" & Chr(34) & Replace(c.Parent.Parent.FullName, ".ANALYSE.ESQA", "") & "#'" & c.Parent.name & "'!" & c.Address & Chr(34) & ";" & Chr(34) & RemoveText(c.Address, "$") & Chr(34) & ")"
    ' theRessheetConstants.Hyperlinks.Add Anchor:=theRessheetConstants.Cells(m_ResultsheetY, 1), Address:="", SubAddress:= _
    '   "'" & c.Parent.Name & "'!" & c.Address, TextToDisplay:=RemoveText(c.Address, "$")
    m_Resultsheet.Cells(m_ResultsheetY, 2) = "'" & GetFormula(c)
    
    m_ResultsheetY = m_ResultsheetY + 1
  End If
End Sub


' ------------------------------------------------------------------------------
' FindConstants
' ------------------------------------------------------------------------------
Sub FindConstants(ByRef c As Range, ByRef cs As CCloneStuff)
    
 On Error GoTo CatchError
#If TIMECHECK = 1 Then
  G_HRT.StartCounting "FindConstants"
#End If
 
'  If Not m_Active Then Exit Sub
    Dim i As Long
    Dim foundConst As Boolean
    foundConst = False
    
    If Not cs.isCloneOfType(m_Type) Then
    
      If Not FormulaR1C1Readable(c) Then
        G_Localerror.Add RemoveText(c.Address, "$")
        G_AnalyzeErrors = G_AnalyzeErrors + 1
      Else
        Dim formulaStr As String
        
        formulaStr = RemoveStrings(c.FormulaR1C1, Chr(34), Chr(34))
        formulaStr = RemoveStrings(formulaStr, "'", "'")
        formulaStr = RemoveStrings(formulaStr, "[", "]")
        formulaStr = Replace(formulaStr, "/1000", "")
        formulaStr = Replace(formulaStr, "*1000", "")
        formulaStr = Replace(formulaStr, "/100", "")
        formulaStr = Replace(formulaStr, "*100", "")
        formulaStr = RemoveVariableNames(formulaStr)
        
        Dim findstr As String
        findstr = "+-*/^"
        
        Dim lenformulaStr As Long
        lenformulaStr = Len(formulaStr)
        For i = 1 To Len(findstr)
          Dim pos As Long
          pos = 1
          Do
            pos = InStr(pos, formulaStr, Mid(findstr, i, 1))
            If pos <= 0 Or pos >= lenformulaStr Then Exit Do
            Dim curChar As String
            curChar = Mid(formulaStr, pos + 1, 1)
            If (curChar >= "0" And curChar <= "9") Then
              foundConst = True
              Exit For
            End If
            pos = pos + 1
          Loop
        Next i
      End If
    End If
    
    If foundConst = True Or cs.isCloneOfType(m_Type) = True Then
      m_AmountWS = m_AmountWS + 1
      G_FoundCells = G_FoundCells + 1
      
      If G_FoundCells < G_MarkCellsAmount Then
        If G_ColorCells Then
          G_CellFormats("ESQAFindConstants").SetFormat c
        End If
        AddMyComment c, FMT0("CONSTANTS_3"), IIf(Len(c.Formula) > 20, 600, 160), 24 '"Konstante in Formel"
'        If G_TodoErzeugen Then
'          G_cTodo.ModifyContent "ESQACONST", ActiveSheet.name & "!" & RemoveText(c.Address, "$"), True
'        End If
      End If
    End If
  
    If foundConst = True Then
      cs.SetAIRow m_Type, m_ResultsheetY
      PrintResult c
    End If
    
  
#If TIMECHECK = 1 Then
  G_HRT.StopCounting "FindConstants"
#End If

  Exit Sub
CatchError:
  ErrorHandler "FindConstants", "", c
  Resume Next

End Sub

' ------------------------------------------------------------------------------
' FindUnusedNumbers
' ------------------------------------------------------------------------------
' Liefert TRUE, wenn keine der Zellen einen Nachfolger hatte!
Function FindUnusedNumbers(ByRef c As Range) As Boolean

 On Error GoTo CatchError
#If TIMECHECK = 1 Then
  G_HRT.StartCounting "FindUnusedNumbers"
#End If
  
  Dim deps As Range
  Set deps = Nothing
  If Not CellHasDependents(c) Then
      Err = 0
      
      m_AmountWS = m_AmountWS + c.Count
      G_FoundCells = G_FoundCells + c.Count
      
      If Not theResbook Is Nothing Then
        ' m_Resultsheet.Cells(m_ResultsheetY, 1) = RemoveText(c.Address, "$")
        ' m_Resultsheet.Cells(m_ResultsheetY, 1).FormulaLocal = "=HYPERLINK(" & Chr(34) & replace(c.Parent.Parent.FullName, ".ANALYSE.ESQA","") & "#'" & c.Parent.name & "'!" & c.Address & Chr(34) & ";" & Chr(34) & RemoveText(c.Address, "$") & Chr(34) & ")"
        ' m_Resultsheet.Cells(m_ResultsheetY, 2) = "'" & GetFormula(c)
        ' m_ResultsheetY = m_ResultsheetY + 1
      
        m_CellAreas.CheckAddCell c
      
      End If
      
      If G_FoundCells < G_MarkCellsAmount Then
        If G_ColorCells Then
          G_CellFormats("ESQAFindUnusedNumbers").SetFormat c
        End If
        'AddMyComment c, "Ungenutzte Zahl", 120, 12
        AddMyComment c, FMT0("MUNUSEDN_2"), 120, 12
'        If G_TodoErzeugen Then
'          G_cTodo.ModifyContent "ESQAUNNR", ActiveSheet.name & "!" & RemoveText(c.Address, "$"), True
'        End If
      End If
  End If
  
#If TIMECHECK = 1 Then
  G_HRT.StopCounting "FindUnusedNumbers"
#End If
  Exit Function
CatchError:
  ErrorHandler "FindUnusedNumbers", "", c
  Resume Next
End Function


' ------------------------------------------------------------------------------
' FindTextNumbers
' ------------------------------------------------------------------------------
Sub FindTextNumbers(ByRef c As Range)
  
On Error GoTo CatchError
#If TIMECHECK = 1 Then
  G_HRT.StartCounting "FindTextNumbers"
#End If
  
  If Not IsError(c) Then
      If Len(c.value) > 0 Then
        If IsNumeric(c.value) = True Then
          If Application.WorksheetFunction.IsNumber(c) = False Then
                
              m_AmountWS = m_AmountWS + 1
              G_FoundCells = G_FoundCells + 1
              
              ' c.Interior.ColorIndex = 4
              If G_FoundCells < G_MarkCellsAmount Then
                If G_ColorCells Then
                  G_CellFormats("ESQAFindTextNumbers").SetFormat c
                End If
                'AddMyComment c, "Fehlerhafte Formatierung", 120, 12
                AddMyComment c, FMT0("MTEXTN_2"), 120, 12
'                If G_TodoErzeugen Then
'                  G_cTodo.ModifyContent "ESQATXTNR", ActiveSheet.name & "!" & RemoveText(c.Address, "$"), True
'                End If
              End If
              
              If Not theResbook Is Nothing Then
                ' m_Resultsheet.Cells(m_ResultsheetY, 1) = RemoveText(c.Address, "$")
                m_Resultsheet.Cells(m_ResultsheetY, 1).FormulaLocal = "=HYPERLINK(" & Chr(34) & Replace(c.Parent.Parent.FullName, ".ANALYSE.ESQA", "") & "#'" & c.Parent.name & "'!" & c.Address & Chr(34) & ";" & Chr(34) & RemoveText(c.Address, "$") & Chr(34) & ")"
                m_Resultsheet.Cells(m_ResultsheetY, 2) = "'" & GetFormula(c)
                m_ResultsheetY = m_ResultsheetY + 1
              End If
          End If
        End If
      End If
  End If
  
#If TIMECHECK = 1 Then
  G_HRT.StopCounting "FindTextNumbers"
#End If

  Exit Sub
CatchError:
  ErrorHandler "FindTextNumbers", "", c
  Resume Next
End Sub

' ------------------------------------------------------------------------------
' FindUnprotectedFormulas
' ------------------------------------------------------------------------------
Sub FindUnprotectedFormulas(ByRef c As Range)
  
On Error GoTo CatchError
    
#If TIMECHECK = 1 Then
  G_HRT.StartCounting "FindUnprotectedFormulas"
#End If

  If c.Locked = False Then
        
      m_AmountWS = m_AmountWS + 1
      G_FoundCells = G_FoundCells + 1
      If G_FoundCells < G_MarkCellsAmount Then
        If G_ColorCells Then
          G_CellFormats("ESQAFindFormulaCellsWithoutProtection").SetFormat c
        End If
        'AddMyComment c, "Ungesch|fffd|tzte Formel", 120, 12
        AddMyComment c, FMT0("MUNPROT_2"), 120, 12
      End If
        
      If Not theResbook Is Nothing Then
        ' m_Resultsheet.Cells(m_ResultsheetY, 1) = RemoveText(c.Address, "$")
        ' m_Resultsheet.Cells(m_ResultsheetY, 1).FormulaLocal = "=HYPERLINK(" & Chr(34) & replace(c.Parent.Parent.FullName, ".ANALYSE.ESQA","") & "#'" & c.Parent.name & "'!" & c.Address & Chr(34) & ";" & Chr(34) & RemoveText(c.Address, "$") & Chr(34) & ")"
        ' m_Resultsheet.Cells(m_ResultsheetY, 2) = "'" & GetFormula(c)
        ' m_ResultsheetY = m_ResultsheetY + 1
        m_CellAreas.CheckAddCell c
'        If G_TodoErzeugen Then
'          G_cTodo.ModifyContent "ESQAUPROT", ActiveSheet.name & "!" & RemoveText(c.Address, "$"), True
'        End If
      End If
      
  End If

#If TIMECHECK = 1 Then
  G_HRT.StopCounting "FindUnprotectedFormulas"
#End If
  Exit Sub
CatchError:
  ErrorHandler "FindUnprotectedFormulas", "", c
  Resume Next
End Sub


' ------------------------------------------------------------------------------
' FindErrors
' ------------------------------------------------------------------------------
Sub FindErrors(ByRef c As Range, ByRef cs As CCloneStuff)
  
 On Error GoTo CatchError
#If TIMECHECK = 1 Then
  G_HRT.StartCounting "FindErrors"
#End If
  
  If IsError(c) Then
    m_AmountWS = m_AmountWS + 1
    G_FoundCells = G_FoundCells + 1
    
    If G_FoundCells < G_MarkCellsAmount Then
      If G_ColorCells Then
        G_CellFormats("ESQAFindErrors").SetFormat c
      End If
      'AddMyComment c, "Formel mit Fehler", 120, 12
      AddMyComment c, FMT0("MERRORS_2"), 120, 12
'      G_cTodo.ModifyContent "ESQAERR", ActiveSheet.name & "!" & RemoveText(c.Address, "$"), True
    End If
    
    If Not cs.isCloneOfType(m_Type) Then
      cs.SetAIRow m_Type, m_ResultsheetY
      If Not theResbook Is Nothing Then
        ' theRessheet.Cells(theRessheetY, 1) = RemoveText(c.Address, "$")
        m_Resultsheet.Cells(m_ResultsheetY, 1).FormulaLocal = "=HYPERLINK(" & Chr(34) & Replace(c.Parent.Parent.FullName, ".ANALYSE.ESQA", "") & "#'" & c.Parent.name & "'!" & c.Address & Chr(34) & ";" & Chr(34) & RemoveText(c.Address, "$") & Chr(34) & ")"
        m_Resultsheet.Cells(m_ResultsheetY, 2) = "'" & GetFormula(c)
        m_ResultsheetY = m_ResultsheetY + 1
      End If
    End If
  End If
  
#If TIMECHECK = 1 Then
  G_HRT.StopCounting "FindErrors"
#End If
  Exit Sub
CatchError:
  ErrorHandler "FindErrors", "", c
  Resume Next
End Sub



' ------------------------------------------------------------------------------
' FindForgottenCells
' ------------------------------------------------------------------------------
Sub FindForgottenCells(ByRef c As Range)

 On Error GoTo CatchError
#If TIMECHECK = 1 Then
  G_HRT.StartCounting "FindForgottenCells"
#End If
 
  
  Dim col As Collection
  
'  If c.Parent.name = "Kontrolle" And c.Address = "$D$8" Then
'    Debug.Print "gaga"
'  End If
  
  If GetArrows(c, col, True, True) Then
'        Set deps = c.DirectPrecedents
    Dim area As Range
    
    For Each area In col ' deps.Areas
      Dim pos As Long
      pos = InStr(area.Address, ":")
      If pos > 0 Then
      
        Dim x1 As Long
        Dim y1 As Long
        Dim x2 As Long
        Dim y2 As Long
        
        x1 = area.Column
        y1 = area.Row
        x2 = area.Column + area.Columns.Count - 1
        y2 = area.Row + area.Rows.Count - 1
      
'        If IsNumeric(Right(area.Address, 1)) Then
      
'          Dim c1 As Range, c2 As Range
'          Set c1 = area.Areas(1).Parent.Range(Left(area.Areas(1).Address, pos - 1)) ' area.Parent.Range(Left(area.Address, pos - 1))
'          Set c2 = area.Areas(1).Parent.Range(Mid(area.Areas(1).Address, pos + 1)) ' area.Parent.Range(Mid(area.Address, pos + 1))
          
          Dim x As Long
          Dim y As Long
          
          If y1 <> y2 Then
            y = y2 + 1
            If y < m_WSMaxy Then
              For x = x1 To x2
                CheckCell c, area.Areas(1).Parent.Cells(y, x), area
              
              Next x
            End If
            y = y1 - 1
            If y > 0 Then
              For x = x1 To x2
                CheckCell c, area.Areas(1).Parent.Cells(y, x), area
              Next x
            End If
          End If
          
          If x1 <> x2 Then
            x = x2 + 1
            If x < m_WSMaxx Then
              For y = y1 To y2
                CheckCell c, area.Areas(1).Parent.Cells(y, x), area
              Next y
            End If
          
            x = x1 - 1
            If x > 0 Then
              For y = y1 To y2
                CheckCell c, area.Areas(1).Parent.Cells(y, x), area
              Next y
            End If
          
          End If
          
        'End If
      End If
    Next area
  End If
  
#If TIMECHECK = 1 Then
  G_HRT.StopCounting "FindForgottenCells"
#End If
  
  Exit Sub
CatchError:
  ErrorHandler "FindForgottenCells", "", c
  Resume Next

End Sub


Private Sub CheckCell(c As Range, tc As Range, area As Range)
 
  If IsNumeric(tc.value) Then
    If tc.value <> "" And tc.Address <> c.Address Then
    
      m_AmountWS = m_AmountWS + 1
      G_FoundCells = G_FoundCells + 1

      If G_FoundCells < G_MarkCellsAmount Then
        If G_ColorCells Then
          G_CellFormats("ESQAFindForgottenCells1").SetFormat c
        End If
      End If
      
      If c.Worksheet.Parent.name = tc.Worksheet.Parent.name Then
          G_CellFormats("ESQAFindForgottenCells2").SetFormat tc
          If c.Worksheet.name = tc.Parent.name Then
              ' local
              If G_FoundCells < G_MarkCellsAmount Then
                  'AddMyComment c, "Formel, bei der eventuell die Zelle " & RemoveText(tc.Address, "$") & " vergessen wurde.", 600, 12
                  AddMyComment c, FMT1("MFORGOTTEN_4", RemoveText(tc.Address, "$")), 600, 12
                 'AddMyComment tc, "Zelle, die eventuell in der Formel " & RemoveText(c.Address, "$") & " vergessen wurde.", 600, 12
                  AddMyComment tc, FMT1("MFORGOTTEN_5", RemoveText(c.Address, "$")), 600, 12
              End If
              If Not theResbook Is Nothing Then
                ' theRessheet.Cells(theRessheetY, 3) = RemoveText(tc.Address, "$")
                m_Resultsheet.Cells(m_ResultsheetY, 3).FormulaLocal = "=HYPERLINK(" & Chr(34) & Replace(tc.Parent.Parent.FullName, ".ANALYSE.ESQA", "") & "#'" & tc.Parent.name & "'!" & tc.Address & Chr(34) & ";" & Chr(34) & RemoveText(tc.Address, "$") & Chr(34) & ")"
              End If
          
          Else
              If G_FoundCells < G_MarkCellsAmount Then
                  'AddMyComment c, "Formel, bei der eventuell die Zelle " & tc.Parent.name & "'!" & RemoveText(tc.Address, "$") & " vergessen wurde.", 600, 12
                  AddMyComment c, FMT1("MFORGOTTEN_4", tc.Parent.name & "'!" & RemoveText(tc.Address, "$")), 600, 12
                  'AddMyComment tc, "Zelle, die eventuell in der Formel " & c.Parent.name & "'!" & RemoveText(c.Address, "$") & " vergessen wurde.", 600, 12
                  AddMyComment tc, FMT1("MFORGOTTEN_5", c.Parent.name & "'!" & RemoveText(c.Address, "$")), 600, 12
              End If
              If Not theResbook Is Nothing Then
                ' m_Resultsheet.Cells(m_ResultsheetY, 3) = c.Parent.Name & "'!" & RemoveText(tc.Address, "$")
                m_Resultsheet.Cells(m_ResultsheetY, 3).FormulaLocal = "=HYPERLINK(" & Chr(34) & Replace(tc.Parent.Parent.FullName, ".ANALYSE.ESQA", "") & "#'" & tc.Parent.name & "'!" & tc.Address & Chr(34) & ";" & Chr(34) & RemoveText(tc.Address, "$") & Chr(34) & ")"
              End If
          End If
      Else
          ' external
        'AddMyComment c, "Formel, bei der eventuell die Zelle " & RemoveText(tc.Address(external:=True), "$") & " vergessen wurde.", 600, 12
        If G_FoundCells < G_MarkCellsAmount Then
          AddMyComment c, FMT1("MFORGOTTEN_4", RemoveText(tc.Address(external:=True), "$")), 600, 12
        End If
'        G_cTodo.ModifyContent "ESQAFORGOT", ActiveSheet.name & "!" & RemoveText(c.Address, "$"), True, False
'          AddMyComment tc, "Zelle, die eventuell in der Formel " & RemoveText(c.Address(external:=True), "$") & " vergessen wurde.", 600, 12
        If Not theResbook Is Nothing Then m_Resultsheet.Cells(m_ResultsheetY, 3) = RemoveText(tc.Address(external:=True), "$")
      End If
      
      
      If Not theResbook Is Nothing Then
        ' m_Resultsheet.Cells(m_ResultsheetY, 1) = RemoveText(c.Address, "$")
        m_Resultsheet.Cells(m_ResultsheetY, 1).FormulaLocal = "=HYPERLINK(" & Chr(34) & Replace(c.Parent.Parent.FullName, ".ANALYSE.ESQA", "") & "#'" & c.Parent.name & "'!" & c.Address & Chr(34) & ";" & Chr(34) & RemoveText(c.Address, "$") & Chr(34) & ")"
        'm_Resultsheet.Cells(m_ResultsheetY, 2) = "ber|fffd|cksichtigt evtl. nicht"
        m_Resultsheet.Cells(m_ResultsheetY, 2) = FMT0("MFORGOTTEN_6")
      '                        m_Resultsheet.Cells(m_ResultsheetY, 3) = RemoveText(tc.Address, "$")
        m_Resultsheet.Cells(m_ResultsheetY, 4) = "'" & GetFormula(c)
        m_ResultsheetY = m_ResultsheetY + 1
      End If
      
    End If
  End If
End Sub

' ------------------------------------------------------------------------------
' FindInvisibleCells
' ------------------------------------------------------------------------------
Sub FindInvisibleCells(ByRef c As Range, ByRef cs As CCloneStuff)
  
On Error GoTo CatchError
#If TIMECHECK = 1 Then
  G_HRT.StartCounting "FindInvisibleCells"
#End If

    Dim isCloneOfType As Boolean
    If Not cs Is Nothing Then
      isCloneOfType = cs.isCloneOfType(m_Type)
    End If


    If Not isCloneOfType Then
        Dim tc As Range
        Set tc = Workbooks(G_OriginalWBName).Worksheets(c.Parent.name).Range(c.Address)
        
        Dim foundOne As Boolean
        foundOne = False
        
        Dim cfcolor As Long
        If Not IsNull(tc.Font.Color) Then
          cfcolor = tc.Font.Color
        End If
        Dim cicolor As Long
        cicolor = tc.Interior.Color
        
        ' Farben und Formatierungen
        If (Abs(cfcolor Mod 256 - cicolor Mod 256) <= 24 And _
           Abs(cfcolor \ 256 Mod 256 - cicolor \ 256 Mod 256) <= 24 And _
           Abs(cfcolor \ 65536 Mod 256 - cicolor \ 65536 Mod 256) <= 24) Or _
           tc.NumberFormat = ";;;" Then
           foundOne = True
        Else
        ' Bedingte Formatierung
          If tc.FormatConditions.Count > 0 Then
            Dim fccnt As Long
            For fccnt = 1 To tc.FormatConditions.Count
              
              If Not IsNull(tc.FormatConditions(fccnt).Font.Color) Then
                cfcolor = tc.FormatConditions(fccnt).Font.Color
              End If
              If Not IsNull(tc.FormatConditions(fccnt).Interior.Color) Then
                cicolor = tc.FormatConditions(fccnt).Interior.Color
              End If
              
              If (Abs(cfcolor Mod 256 - cicolor Mod 256) <= 24 And _
                 Abs(cfcolor \ 256 Mod 256 - cicolor \ 256 Mod 256) <= 24 And _
                 Abs(cfcolor \ 65536 Mod 256 - cicolor \ 65536 Mod 256) <= 24) Then
                 foundOne = True
                 Exit For
              End If
            Next fccnt
          End If
        End If
    End If
    
    If foundOne = True Or isCloneOfType = True Then
      m_AmountWS = m_AmountWS + 1
      G_FoundCells = G_FoundCells + 1
      
      ' c.Interior.ColorIndex = 4
      If G_FoundCells < G_MarkCellsAmount Then
        If G_ColorCells Then
          G_CellFormats("ESQAFindInvisibleCells").SetFormat c
        End If
        'AddMyComment c, "Unsichtbare Zelle", 120, 12
        AddMyComment c, FMT0("MINVISIBLE_2"), 120, 12
      End If
      
      If Not theResbook Is Nothing Then
        If Not cs Is Nothing Then
              ' theRessheet.Cells(theRessheetY, 1) = RemoveText(c.Address, "$")
'              m_Resultsheet.Cells(m_ResultsheetY, 1).FormulaLocal = "=HYPERLINK(" & Chr(34) & Replace(c.Parent.Parent.FullName, ".ANALYSE.ESQA", "") & "#'" & c.Parent.name & "'!" & c.Address & Chr(34) & ";" & Chr(34) & RemoveText(c.Address, "$") & Chr(34) & ")"
'              m_Resultsheet.Cells(m_ResultsheetY, 2) = "'" & GetFormula(c)
'              m_ResultsheetY = m_ResultsheetY + 1
      '        G_cTodo.ModifyContent "ESQAINVISIB", ActiveSheet.name & "!" & RemoveText(c.Address, "$"), True
        Else
          m_CellAreas.CheckAddCell c
        End If
        
      End If
                 
    End If
  
    If foundOne = True And Not cs Is Nothing Then
      cs.SetAIRow m_Type, m_ResultsheetY
      PrintResult c
    End If
  
  
#If TIMECHECK = 1 Then
  G_HRT.StopCounting "FindInvisibleCells"
#End If
  Exit Sub
CatchError:
  ErrorHandler "FindInvisibleCells", "", c
  Resume Next
End Sub


' ------------------------------------------------------------------------------
' FindExternals
' ------------------------------------------------------------------------------
Sub FindExternals(ByRef c As Range, ByRef cs As CCloneStuff)

On Error GoTo CatchError
#If TIMECHECK = 1 Then
  G_HRT.StartCounting "FindExternals"
#End If
    
  If UCase(c.Formula) Like "*.XL?]*" Or UCase(c.Formula) Like "*.XL??]*" Then
    m_AmountWS = m_AmountWS + 1
    G_FoundCells = G_FoundCells + 1
  
    If G_FoundCells < G_MarkCellsAmount Then
      If G_ColorCells Then
        G_CellFormats("ESQAFindExternals").SetFormat c
      End If
      'AddMyComment c, "Verkn|fffd|pfung auf externe Datei", 160, 24
      AddMyComment c, FMT0("MFEXTERNALS_8"), 160, 24
    End If
    
    If Not cs.isCloneOfType(m_Type) Then
      cs.SetAIRow m_Type, m_ResultsheetY
      PrintResult c
    End If
    
  End If
  
#If TIMECHECK = 1 Then
  G_HRT.StopCounting "FindExternals"
#End If

  Exit Sub
CatchError:
  ErrorHandler "FindExternals", "", c
  Resume Next
End Sub

Attribute VB_Name = "CCellArea"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public m_X1 As Long
Public m_X2 As Long
Public m_Y1 As Long
Public m_Y2 As Long

Function Width() As Long
  Width = m_X2 - m_X1 + 1
End Function

Function Height() As Long
  Height = m_Y2 - m_Y1 + 1
End Function

Sub SetCell(y As Long, x As Long)
  m_X1 = x
  m_X2 = x
  m_Y1 = y
  m_Y2 = y
End Sub


Function CheckAddCell(ByRef c As Range) As Boolean
  With c
    If (.Column = m_X1 - 1 Or .Column = m_X2 + 1) Then
      If m_Y1 = m_Y2 And .Row = m_Y1 Then
        CheckAddCell = True
        If .Column < m_X1 Then m_X1 = .Column
        If .Column > m_X2 Then m_X2 = .Column
      End If
    ElseIf (.Row = m_Y1 - 1 Or .Row = m_Y2 + 1) Then
      If m_X1 = m_X2 And .Column = m_X1 Then
        CheckAddCell = True
        If .Row < m_Y1 Then m_Y1 = .Row
        If .Row > m_Y2 Then m_Y2 = .Row
      End If
    End If
  End With
End Function
Function CheckAddCellXY(y As Long, x As Long) As Boolean
  If (x = m_X1 - 1 Or x = m_X2 + 1) Then
    If m_Y1 = m_Y2 And y = m_Y1 Then
      CheckAddCellXY = True
      If x < m_X1 Then m_X1 = x
      If x > m_X2 Then m_X2 = x
    End If
  ElseIf (y = m_Y1 - 1 Or y = m_Y2 + 1) Then
    If m_X1 = m_X2 And x = m_X1 Then
      CheckAddCellXY = True
      If y < m_Y1 Then m_Y1 = y
      If y > m_Y2 Then m_Y2 = y
    End If
  End If
End Function

Function CheckAddArea(ByRef c As CCellArea) As Boolean
  
  With c
    If (m_X2 = .m_X1 - 1 Or m_X1 = .m_X2 + 1) Then
      If m_Y1 = .m_Y1 And m_Y2 = .m_Y2 Then
        CheckAddArea = True
        If .m_X1 < m_X1 Then m_X1 = .m_X1
        If .m_X2 > m_X2 Then m_X2 = .m_X2
      End If
    ElseIf (m_Y2 = .m_Y1 - 1 Or m_Y1 = .m_Y2 + 1) Then
      If m_X1 = .m_X1 And m_X2 = .m_X2 Then
        CheckAddArea = True
        If .m_Y1 < m_Y1 Then m_Y1 = .m_Y1
        If .m_Y2 > m_Y2 Then m_Y2 = .m_Y2
      End If
    End If
  End With
End Function

Function GetAreaString() As String
  GetAreaString = RemoveText(Range(Cells(m_Y1, m_X1), Cells(m_Y2, m_X2)).Address, "$")
End Function
Attribute VB_Name = "CCellAreas"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public m_Cells As Collection
Private m_LastCrunch As Long
Private m_CrunchCnt As Long

Private Sub Class_Initialize()
  Set m_Cells = New Collection
End Sub

Function CheckAddCell(ByRef c As Range) As Boolean
  Dim ca As CCellArea
  If m_Cells.Count > 0 Then
    Set ca = m_Cells(m_Cells.Count)
    With ca
      If .m_X2 + 1 = c.Column And .m_Y1 = .m_Y2 And .m_Y1 = c.Row Then
        .m_X2 = .m_X2 + 1
        CheckAddCell = True
'        Debug.Print "Added " & .m_X1 & "," & .m_X2 & "," & .m_Y1 & "," & .m_Y2 & " - " & c.Column & "," & c.Row
        Exit Function
'      Else
'        Debug.Print "Dropp " & .m_X1 & "," & .m_X2 & "," & .m_Y1 & "," & .m_Y2 & " - " & c.Column & "," & c.Row
      End If
    End With
    
'    For Each ca In m_Cells
'      If ca.CheckAddCell(c) Then
'        CheckAddCell = True
'        Exit Function
'      End If
'    Next ca
  End If
  Set ca = New CCellArea
  ca.SetCell c.Row, c.Column
  m_Cells.Add ca
  
  If m_Cells.Count - m_LastCrunch > 100 Then
    m_CrunchCnt = m_CrunchCnt + 1
    Dim am As Long
    am = m_Cells.Count
    Crunch m_LastCrunch - 1
    m_LastCrunch = m_Cells.Count
'    Debug.Print m_CrunchCnt & ": " & am & " --> " & m_Cells.Count
  End If
  
End Function

Sub Crunch(Optional ByVal pos As Long = 1)
  If pos <= 0 Then pos = 1
  If m_Cells.Count > 1 Then
    Dim i1 As Long, i2 As Long
    For i1 = m_Cells.Count - 1 To pos Step -1
      For i2 = m_Cells.Count To i1 + 1 Step -1
        If m_Cells(i1).CheckAddArea(m_Cells(i2)) Then
          m_Cells.Remove i2
        End If
      Next i2
    Next i1
  End If
  
  
Exit Sub
  Dim found As Boolean
  
  found = True
  
  Do While found
    found = False
    If m_Cells.Count > 1 Then
'      Dim i1 As Long, i2 As Long
      For i1 = 1 To m_Cells.Count - 1
        For i2 = i1 + 1 To m_Cells.Count
          If m_Cells(i1).CheckAddArea(m_Cells(i2)) Then
            found = True
            m_Cells.Remove i2
            Exit For
          End If
        Next i2
        If found Then Exit For
      Next i1
    End If
  Loop
  
End Sub

Function GetAreaString(ByVal maxStringLength As Long) As String

  Dim s As String
  Dim ca As CCellArea
  If m_Cells.Count > 0 Then
    For Each ca In m_Cells
      s = s & IIf(s <> "", ",", "") & ca.GetAreaString
      If Len(s) > maxStringLength Then
        s = s & ",..."
        Exit For
      End If
      
    Next ca
  End If
  GetAreaString = s

End Function

Sub InsertClonesAsSingleLines(ByVal fname As String, ByVal wssheetname As String, ByRef ressheet As Worksheet, ByVal y As Long, ByRef addedLines As Long)
  
  Dim ca As CCellArea
  If m_Cells.Count > 0 Then
    ressheet.Rows(y + addedLines & ":" & y + addedLines + m_Cells.Count - 1).Insert Shift:=xlDown ', CopyOrigin:=xlFormatFromLeftOrAbove
    For Each ca In m_Cells
      ressheet.Cells(y + addedLines, 3).FormulaLocal = "=HYPERLINK(" & Chr(34) & Replace(fname, ".ANALYSE.ESQA", "") & "#'" & wssheetname & "'!" & ca.GetAreaString & Chr(34) & ";" & Chr(34) & ca.GetAreaString & Chr(34) & ")"
'      Debug.Print Replace(fname, ".ANALYSE.ESQA", "") & "#'" & wssheetname & "'!" & ca.GetAreaString
      y = y + 1
    Next ca
    addedLines = addedLines + m_Cells.Count
'    Debug.Print addedLines
  End If
End Sub

Attribute VB_Name = "CCloneStuff"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public m_Formula As String
Public m_Amount As Long
Private m_AIRow() As Long
Private m_AIClone() As Boolean
Private m_NoMoreClones As Boolean
Public m_CellAreas As CCellAreas


Private Sub Class_Initialize()
  ReDim m_AIRow(AI_Max) As Long
  ReDim m_AIClone(AI_Max) As Boolean
  Set m_CellAreas = New CCellAreas
End Sub

Public Sub SetAIRow(ByVal aitype As AnalyzeType, ByVal r As Long)
  m_AIRow(aitype) = r
  m_AIClone(aitype) = True
End Sub

Public Function GetAIRow(ByVal aitype As AnalyzeType) As Long
  GetAIRow = m_AIRow(aitype)
End Function

Public Function isCloneOfType(ByVal aitype As AnalyzeType) As Boolean
  isCloneOfType = m_AIClone(aitype)
End Function

Sub AddClone(ByRef c As Range)

  m_Amount = m_Amount + 1
  
  If m_NoMoreClones Then Exit Sub
  
  If m_CellAreas.CheckAddCell(c) Then Exit Sub
  
  If m_CellAreas.m_Cells.Count > 10 Then
    m_NoMoreClones = True
  End If
End Sub
  
Function CrunchClones() As String
  m_CellAreas.Crunch
  CrunchClones = GetCloneString
End Function

Function GetCloneString() As String
  GetCloneString = m_CellAreas.GetAreaString(200)
End Function

Sub InsertClonesAsSingleLines(ByVal fname As String, ByVal wssheetname As String, ByRef ressheet As Worksheet, ByVal y As Long, ByRef addedLines As Long)
  m_CellAreas.InsertClonesAsSingleLines fname, wssheetname, ressheet, y, addedLines
End Sub


Attribute VB_Name = "CellFormat"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private m_InteriorColorIndex As Long
Private m_InteriorColor As Long

Private m_xlEdgeLeftLineStyle As Long
Private m_xlEdgeLeftWeight As Long
Private m_xlEdgeLeftColor As Long
Private m_xlEdgeTopLineStyle As Long
Private m_xlEdgeTopWeight As Long
Private m_xlEdgeTopColor As Long
Private m_xlEdgeBottomLineStyle As Long
Private m_xlEdgeBottomWeight As Long
Private m_xlEdgeBottomColor As Long
Private m_xlEdgeRightLineStyle As Long
Private m_xlEdgeRightWeight As Long
Private m_xlEdgeRightColor As Long


Public Sub GetFormat(ByRef c As Range)
  m_InteriorColorIndex = c.Interior.ColorIndex
  m_InteriorColor = c.Interior.Color
  
  With c
    With .Borders(xlEdgeLeft)
      m_xlEdgeLeftLineStyle = .LineStyle
      m_xlEdgeLeftWeight = .Weight
      m_xlEdgeLeftColor = .Color
    End With
    With .Borders(xlEdgeTop)
      m_xlEdgeTopLineStyle = .LineStyle
      m_xlEdgeTopWeight = .Weight
      m_xlEdgeTopColor = .Color
    End With
    With .Borders(xlEdgeBottom)
      m_xlEdgeBottomLineStyle = .LineStyle
      m_xlEdgeBottomWeight = .Weight
      m_xlEdgeBottomColor = .Color
    End With
    With .Borders(xlEdgeRight)
      m_xlEdgeRightLineStyle = .LineStyle
      m_xlEdgeRightWeight = .Weight
      m_xlEdgeRightColor = .Color
    End With
  End With

End Sub

Public Sub SetFormat(ByRef c As Range)
  On Error GoTo nogo
  If m_InteriorColorIndex <> xlColorIndexNone Then
    c.Interior.Color = m_InteriorColor
  End If

  Dim doFrameCell As Boolean
  With c
    With .Borders(xlEdgeLeft)
      If m_xlEdgeLeftLineStyle <> xlLineStyleNone Then
        .LineStyle = m_xlEdgeLeftLineStyle
        .Weight = m_xlEdgeLeftWeight
        .Color = m_xlEdgeLeftColor
        doFrameCell = True
      End If
    End With
    With .Borders(xlEdgeTop)
      If m_xlEdgeTopLineStyle <> xlLineStyleNone Then
        .LineStyle = m_xlEdgeTopLineStyle
        .Weight = m_xlEdgeTopWeight
        .Color = m_xlEdgeTopColor
        doFrameCell = True
      End If
    End With
    With .Borders(xlEdgeBottom)
      If m_xlEdgeBottomLineStyle <> xlLineStyleNone Then
        .LineStyle = m_xlEdgeBottomLineStyle
        .Weight = m_xlEdgeBottomWeight
        .Color = m_xlEdgeBottomColor
        doFrameCell = True
      End If
    End With
    With .Borders(xlEdgeRight)
      If m_xlEdgeRightLineStyle <> xlLineStyleNone Then
        .LineStyle = m_xlEdgeRightLineStyle
        .Weight = m_xlEdgeRightWeight
        .Color = m_xlEdgeRightColor
        doFrameCell = True
      End If
    End With
    If doFrameCell Then FrameCell c
  End With
  Exit Sub
nogo:
End Sub
Attribute VB_Name = "CfgReader"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Dim m_Lines As Collection
Dim m_Sec As Collection
Dim m_SecList As Collection

Dim m_CurSec As String

Private Sub Class_Initialize()
  Set m_Lines = New Collection
  Set m_Sec = New Collection
  Set m_SecList = New Collection
  m_CurSec = ""
End Sub

Private Function GetLine(ByRef txt As String) As String
    Dim pos As Long
    Dim res As String
    pos = InStr(txt, vbCr)
    If pos > 0 Then
        res = Left(txt, pos - 1)
    Else
        res = txt
    End If
    If pos > 0 Then
        txt = Mid(txt, 2 + pos)
    Else
        txt = ""
    End If

    GetLine = res

End Function

Private Function GetNextLine(ByRef s As String) As String

    Dim rs As String
    Do
        rs = GetLine(s)
        If Len(Trim(rs)) > 0 Then
            GetNextLine = Trim(rs)
            Exit Function
        End If
        If Len(Trim(s)) <= 0 Then
            GetNextLine = ""
            s = ""
            Exit Function
        End If
    Loop
End Function


Public Sub GetCFGString(ByVal txt As String)
    Dim secName As String
    Set m_Lines = New Collection
    Set m_Sec = New Collection

    If Len(txt) = 0 Then Exit Sub
    Dim s As String
    Do
        s = GetNextLine(txt)
        If Len(s) <= 0 Then Exit Do
        If Len(Trim(s)) > 0 Then
          m_Lines.Add s
        End If
        If Len(Trim(s)) > 0 Then
          m_Sec.Add s
        End If
        
        If Left(Trim(s), 1) = "[" And InStr(Trim(s), "]") > 0 Then
          m_SecList.Add New Collection, Trim(s)
          secName = Trim(s)
        Else
          If secName <> "" Then
            Dim parm As String
            Dim pos As Long
            pos = InStr(Trim(s), "=")
            If pos > 0 Then
              m_SecList(secName).Add Trim(Mid(Trim(s), pos + 1)), Left(Trim(s), pos - 1)
            End If
          End If
        End If
    Loop
End Sub

Function GetCfgUTF8(fname As String) As Boolean
  On Error GoTo couldntOpenFile
    Dim adoStream As Object
    Set adoStream = CreateObject("ADODB.Stream")
    
    adoStream.Charset = "UTF-8"
    adoStream.Open
    adoStream.LoadFromFile fname
    GetCFGString adoStream.ReadText
    adoStream.Close
    Set adoStream = Nothing
    GetCfgUTF8 = True
    Exit Function

couldntOpenFile:
  GetCfgUTF8 = False

End Function

Private Function GetEncodingString(encoding As Long) As String
    Select Case encoding
    Case CP_ACP: GetEncodingString = "ANSI"
    Case CP_UTF8: GetEncodingString = "UTF8"
    Case CP_UTF16_LE: GetEncodingString = "UTF16 LE"
    Case CP_UTF16_BE: GetEncodingString = "UTF16 BE"
    Case CP_UTF32_LE: GetEncodingString = "UTF32 LE"
    Case CP_UTF32_BE: GetEncodingString = "UTF32 BE"
    Case Else: GetEncodingString = "Codepage " & CStr(encoding)
    End Select
End Function

Private Function GetCfgUniversal(fname As String) As Boolean
  On Error GoTo couldntOpenFile
    'Dim ff As Long
    'ff = FreeFile
    'Call OpenForInput(fname, ff, encoding)
    Dim encoding As Long
    Dim fileContents As String
    Dim bom As Boolean
    fileContents = GetContents(fname, encoding, -1, bom)
'    DebugPrint tInfo, fname & " opened with encoding: " & GetEncodingString(encoding) & IIf(bom, " BOM", " no BOM")
    
    Call GetCFGString(fileContents)
    GetCfgUniversal = True
    
    Exit Function

couldntOpenFile:
  GetCfgUniversal = False
End Function

Function GetCfg(fname As String) As Boolean
  On Error GoTo couldntOpenFile
  Set m_Lines = New Collection
  Set m_Sec = New Collection
  Call GetCfgUniversal(fname)
  
  GetCfg = True
  Exit Function
couldntOpenFile:
  GetCfg = False
End Function

Function SaveCFG(fname As String) As Boolean
  On Error GoTo couldntOpenFile
  
  Dim ff As Long
  ff = FreeFile
  Dim s As String
  
  Open fname For Output As #ff
  
  If m_Lines.Count > 0 Then
    Dim i As Long
    For i = 1 To m_Lines.Count
      If i > 1 And Left(m_Lines(i), 1) = "[" Then
        Print #ff, ""
      End If
      If Len(Trim(m_Lines(i))) > 0 Then
        Print #ff, m_Lines(i)
      End If
    Next i
  End If
  
  Close #ff
  
  SaveCFG = True
  Exit Function
couldntOpenFile:
  SaveCFG = False
End Function


Function GetSection(sec As String) As Boolean
  Set m_Sec = New Collection
  GetSection = GetSectionValues(sec, m_Sec)
  m_CurSec = sec
End Function

Function GetValue(s As String) As String
  On Error Resume Next
  Dim i As Long
  If m_CurSec <> "" Then
     GetValue = m_SecList("[" & m_CurSec & "]")(s)
     Exit Function
  Else
    For i = 1 To m_Sec.Count
      If Left(m_Sec(i), Len(s) + 1) = s & "=" Then
        GetValue = Trim(Mid(m_Sec(i), Len(s) + 2))
        Exit Function
      ElseIf Left(m_Sec(i), Len(s) + 1) = s & " " Then
          Dim pos As Long
          pos = InStr(m_Sec(i), "=")
          If pos > 0 Then
              GetValue = Trim(Mid(m_Sec(i), pos + 1))
              Exit Function
          End If
      End If
    Next i
  End If
  GetValue = ""
End Function

Sub RemoveSectionValue(sec As String, s As String)
  Dim i As Long
  For i = 1 To m_Lines.Count
    If m_Lines(i) = "[" & sec & "]" Then
      i = i + 1
      Do While i <= m_Lines.Count
        If Left(m_Lines(i), 1) <> "[" Then
          If Left(m_Lines(i), Len(s) + 1) = s & "=" Then
            m_Lines.Remove i
            m_SecList("[" & sec & "]").Remove s
            Exit Sub
          End If
          i = i + 1
        Else
          Exit Sub
        End If
      Loop
      Exit Sub
    End If
  Next i
End Sub

Sub RemoveSection(sec As String)
  Dim i As Long
  Dim secLine As Long
  For i = 1 To m_Lines.Count
    If m_Lines(i) = "[" & sec & "]" Then
      secLine = i
      i = i + 1
      Do While i <= m_Lines.Count
        If Left(m_Lines(i), 1) <> "[" Then
          i = i + 1
        Else
          Exit For
        End If
      Loop
      
      m_SecList.Remove "[" & sec & "]"
      
      i = i - 1
      Do While i >= secLine
        m_Lines.Remove (i)
        i = i - 1
      Loop
      Exit For
    End If
  Next i
End Sub



Function GetSectionValue(sec As String, s As String) As String
On Error Resume Next
  GetSectionValue = ""
  GetSectionValue = m_SecList("[" & sec & "]")(s)
  Exit Function

  Dim i As Long
  For i = 1 To m_Lines.Count
    If m_Lines(i) = "[" & sec & "]" Then
      i = i + 1
      Do While i <= m_Lines.Count
        If Left(m_Lines(i), 1) <> "[" Then
          If Left(m_Lines(i), Len(s) + 1) = s & "=" Then
            GetSectionValue = Trim(Mid(m_Lines(i), Len(s) + 2))
            Exit Function
          End If
          i = i + 1
        Else
          Exit Function
        End If
      Loop
    End If
  Next i
End Function

Sub SetSectionValue(sec As String, s As String, v As String)
  Dim i As Long
  Dim secFound As Boolean
  For i = 1 To m_Lines.Count
    If m_Lines(i) = "[" & sec & "]" Then
      secFound = True
      i = i + 1
      Do While i <= m_Lines.Count
        If Left(m_Lines(i), 1) <> "[" Then
          If Left(m_Lines(i), Len(s) + 1) = s & "=" Then
            m_Lines.Add s & "=" & v, , i
            m_Lines.Remove i + 1
            m_SecList("[" & sec & "]").Remove s
            m_SecList("[" & sec & "]").Add v, s
            Exit Sub
          End If
          i = i + 1
        Else
          If i > m_Lines.Count Then
            m_Lines.Add s & "=" & v
            m_SecList("[" & sec & "]").Add v, s
          Else
            m_Lines.Add s & "=" & v, , i
            m_SecList("[" & sec & "]").Add v, s
          End If
          Exit Sub
        End If
      Loop
      
      If i > m_Lines.Count Then
        m_Lines.Add s & "=" & v
        m_SecList("[" & sec & "]").Add v, s
      End If
      
    End If
  Next i
  
  If Not secFound Then
     m_SecList.Add New Collection, "[" & sec & "]"
     m_SecList("[" & sec & "]").Add v, s
     m_Lines.Add "[" & sec & "]"
     m_Lines.Add s & "=" & v
  End If

End Sub

Function GetSectionValues(sec As String, ByRef c As Collection) As Boolean
  Set c = New Collection
  Dim i As Long
  Dim found As Boolean
  found = False
  For i = 1 To m_Lines.Count
    If m_Lines(i) = "[" & sec & "]" Then
      i = i + 1
      Do While i <= m_Lines.Count
        If Left(m_Lines(i), 1) <> "[" Then
          c.Add m_Lines(i)
          found = True
          i = i + 1
        Else
          Exit Do
        End If
      Loop
    End If
    If i > m_Lines.Count Then Exit For
  Next i
  GetSectionValues = found
End Function






Attribute VB_Name = "CloneInfo"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public m_Color As Long
Public m_Pattern As Long
Public m_Formula As String
Public m_MotherCell As Range
Public m_Count As Long
Attribute VB_Name = "ComplexEntry"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public m_Farbe As Long
Public m_|fffd|berschrift As String
Public m_Details As String
Public m_KW As Collection
Public m_Typ As Long
Public m_Typ1Anzahl As Long
Attribute VB_Name = "ComplexFormulas"
Attribute VB_Base = "0{03A7B008-9817-42CB-A046-4E2857E5ED39}{43926CE6-7CC8-4AB1-B042-40CB6ACF46EA}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public AllListItems As String
Public SelectedListItems As Collection

Private Sub BracNum_Change()
  SaveSetting _
     appname:="Stromwerken", _
     Section:="ESQA", _
     Key:="BracNum", _
     Setting:=BracNum
End Sub

Private Sub cmdClose_Click()
  Me.Hide
End Sub

Private Sub FindTxt_Change()
  SaveSetting _
     appname:="Stromwerken", _
     Section:="ESQA", _
     Key:="FindTxt", _
     Setting:=FindTxt
End Sub

Private Sub FormulaList_Click()

  Set SelectedListItems = New Collection
  AllListItems = ""
  
  Dim i As Long
  SearchDetails = ""
  If Searches.ListCount <= 0 Then Exit Sub
  For i = 0 To Searches.ListCount - 1
    If Searches.Selected(i) Then
    
      SelectedListItems.Add KomplexListe(i + 1)
    
      If Len(AllListItems) > 0 Then
        AllListItems = AllListItems & "," & KomplexListe(i + 1).m_|fffd|berschrift
      Else
        AllListItems = KomplexListe(i + 1).m_|fffd|berschrift
      End If
    End If
  Next i


  If Len(AllListItems) = 0 Then
    'MsgBox "Bitte w|fffd|hlen Sie mindestens einen Eintrag der Liste aus.", vbInformation, "ESQA " & MyVersion
    MsgBox FMT0("COMPLEXF_12"), vbInformation, "ESQA " & MyVersion
    Exit Sub
  End If

  Me.Hide

  If Not DoPreparations() Then Exit Sub
  
  CreateResbook ActiveSheet
  
  Dim listensuche As String
  listensuche = FMT0("COMPLEXF_13")
  'CreateRessheet "Listensuche", "Zellen mit bestimmten Suchw|fffd|rtern einer Liste", ActiveSheet
  'SetRessheet "Listensuche"
  CreateRessheet listensuche, FMT0("COMPLEXF_14"), ActiveSheet
  SetRessheet listensuche
  'PrintComment "Listenelemente: " & AllListItems
  PrintComment FMT0("COMPLEXF_15") & AllListItems
  
  ESQAFormulasListe
End Sub

Private Sub FormulasWithText_Click()

  Me.Hide

  If Not DoPreparations() Then Exit Sub
  
  CreateResbook ActiveSheet
  
  Dim textsuche As String
  textsuche = FMT0("COMPLEXF_16")
  'CreateRessheet "Textsuche", "Zellen mit bestimmten Suchw|fffd|rtern", ActiveSheet
  'SetRessheet "Textsuche"
  CreateRessheet textsuche, FMT0("COMPLEXF_17"), ActiveSheet
  SetRessheet textsuche
  'PrintComment "Suchw|fffd|rter: " & ComplexFormulas.FindTxt
  PrintComment FMT0("COMPLEXF_18") & ComplexFormulas.FindTxt
  
  ESQAFormulasWithText

End Sub

Private Sub MatrixFormeln_Click()

  Me.Hide

  If Not DoPreparations() Then Exit Sub
  
  CreateResbook ActiveSheet
  
  Dim MatrixFormeln As String
  MatrixFormeln = FMT0("COMPLEXF_19")
  'CreateRessheet "Matrix-Formeln", "Matrix-Formeln", ActiveSheet
  'SetRessheet matrixformeln
  CreateRessheet MatrixFormeln, FMT0("COMPLEXF_19"), ActiveSheet
  SetRessheet MatrixFormeln
  
  ESQAMatrix
End Sub

Private Sub MoreThanXBracs_Click()
  If Not IsNumeric(BracNum) Then
    'MsgBox "Bitte erfassen Sie eine Zahl", vbCritical, "ESQA " & MyVersion
    MsgBox FMT0("COMPLEXF_20"), vbCritical, "ESQA " & MyVersion
    Exit Sub
  End If

  If BracNum <= 0 Then
    'MsgBox "Bitte erfassen Sie eine Zahl > 0", vbCritical, "ESQA " & MyVersion
    MsgBox FMT0("COMPLEXF_21"), vbCritical, "ESQA " & MyVersion
    Exit Sub
  End If

  Me.Hide

  If Not DoPreparations() Then Exit Sub
  
  CreateResbook ActiveSheet
  'CreateRessheet "Mehr als X Klammern", "Zellen mit mehr als " & ComplexFormulas.BracNum & " ge|fffd|ffneten Klammern", ActiveSheet
  'SetRessheet "Mehr als X Klammern"
  CreateRessheet FMT0("COMPLEXF_22"), FMT1("COMPLEXF_23", ComplexFormulas.BracNum), ActiveSheet
  SetRessheet FMT0("COMPLEXF_22")
  
  ESQAMoreThanXBracs
End Sub

Private Sub Searches_Change()
  Dim i As Long
  SearchDetails = ""
  If Searches.ListCount <= 0 Then Exit Sub
  For i = 0 To Searches.ListCount - 1
    If Searches.Selected(i) Then
      If Len(SearchDetails) > 0 Then
        SearchDetails = SearchDetails & vbCrLf & KomplexListe(i + 1).m_Details
      Else
        SearchDetails = KomplexListe(i + 1).m_Details
      End If
    
      If KomplexListe(i + 1).m_Typ = 1 Then
        SearchDetails = SearchDetails & " (" & KomplexListe(i + 1).m_Typ1Anzahl & " x)"
      End If
    End If
  Next i
End Sub

Private Sub Searches_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
  FormulaList_Click
End Sub

Private Sub UserForm_Initialize()
  gTranslation.TranslateForm Me
End Sub

Attribute VB_Name = "DieseArbeitsmappe"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Private Sub Workbook_Open()
  
  G_HiglyEncryptedSheetPW = 0
  
  CheckStartupStuff
      
  If Len(trs) Then StartDlg.Label1 = trs
                
  
  StartDlg.CVersion = MyVersion

'  StartDlg.CVersion = MyVersion & vbCrLf & IIf(MyInternalVersion <> G_InternetInternalVersion, "Internet: " & G_InternetVersion & vbCrLf, "") & _
'      IIf(G_InternetAvailable, _
'            IIf(FullVersion = False, _
'                  "Demoversion", _
'                  IIf(MyInternalVersion < G_InternetInternalVersion, _
'                          IIf(G_MyLicencseVersion >= G_InternetLicenseVersion, "Kostenfreies Update", "Kostenpflichtiges Update"), _
'                          "" _
'                  ) _
'            ), _
'            "" _
'      )
  
  If GetSetting(appname:="Stromwerken", Section:="Excel-Sheet-QA", Key:="FirstStartDone", Default:="") = "True" Then
     ' Wenn ich als ADDIN geladen wurde, dann mache ich nix!
     If Not LoadedAsAddin Then
       'MsgBox "ESQA wurde geladen, die Funktionen stehen jetzt |fffd|ber den Men|fffd|eintrag f|fffd|r ESQA zur Verf|fffd|gung.", vbInformation, "ESQA " & MyVersion
       MsgBox FMT0("THISWB_1"), vbInformation, "ESQA " & MyVersion
     End If
     Exit Sub
  End If
  
  SaveSetting appname:="Stromwerken", Section:="Excel-Sheet-QA", Key:="FirstStartDone", Setting:="True"
  
  StartDlg.Cop = "|fffd| 2001 - " & year(Now)

  If G_UpdateAvailable Then StartDlg.cmdUpdate.Visible = True
  LogPrint "Prepare to show menu"
  StartDlg.Show
'    If Not StartDlg.IsOk Then ThisWorkbook.Close False

End Sub
Attribute VB_Name = "ESQAFind"
Option Explicit

Dim wbname As String
Dim currentWS As String
Dim currentCellx As Long
Dim currentCelly As Long


Public Sub ESQAFinden()
  CheckStartupStuff
  
  On Error GoTo raffIchNet
  Dim ws As Worksheet
  Dim c As Range
  currentWS = ""
  wbname = ActiveWorkbook.name
  
  Dim ccnt As Long
  Dim rotChar
  Dim lastTime
  lastTime = Now
  rotChar = Array("|", "/", "-", "\")
  ccnt = 0
  Dim tCnt As Long
  tCnt = 0
  
  Dim i As Long
  For i = 1 To Worksheets.Count
    If Worksheets(i).name = ActiveSheet.name Then
      Exit For
    End If
  Next i
  
  Dim startChecking As Boolean
  startChecking = False
  Dim endIndex As Long
  endIndex = i
  
'  For Each ws In ActiveWorkbook.Worksheets
  Do
    If startChecking = True And endIndex = i Then
      Exit Do
    End If
    Set ws = ActiveWorkbook.Worksheets(i)
    currentWS = ws.name
    If Left(ws.name, 5) <> "ESQA." Then
          '    If ws.ProtectContents = True Then
          '      If SheetHasPassword(ws) Then
                  For Each c In ws.UsedRange
                    currentCelly = c.Row
                    currentCellx = c.Column
                    If c.Interior.ColorIndex <> xlNone Or _
                      (c.Borders(xlEdgeLeft).LineStyle <> xlLineStyleNone And _
                      c.Borders(xlEdgeRight).LineStyle <> xlLineStyleNone And _
                      c.Borders(xlEdgeTop).LineStyle <> xlLineStyleNone And _
                      c.Borders(xlEdgeBottom).LineStyle <> xlLineStyleNone) _
                        Then ' = 8 Or c.Interior.ColorIndex = 4 Or c.Interior.ColorIndex = 6 Then
                      ws.Activate
                      c.Activate
                      Application.StatusBar = ""
                      Exit Sub
                    End If
                    If tCnt > 100 Then
                      tCnt = 0
                      lastTime = Now
                      'Application.StatusBar = "Bitte warten, Suche l|fffd|uft (Tabelle '" & ws.name & "'). " & rotChar(ccnt)
                      Application.StatusBar = FMT2("ESQAFIND_1", ws.name, rotChar(ccnt))
                      ccnt = ccnt + 1
                      If ccnt = 4 Then ccnt = 0
                    End If
                    tCnt = tCnt + 1
                  Next c
          '      End If
          '    End If
    End If
    i = i + 1
    If i > Worksheets.Count Then
      i = 1
    End If
    startChecking = True
  Loop
  'MsgBox "Keine Zellen gefunden.", vbInformation, "ESQA " & MyVersion
  MsgBox FMT0("ESQAFIND_2"), vbInformation, "ESQA " & MyVersion
  currentWS = ""
  Application.StatusBar = ""
  Exit Sub
raffIchNet:
  'MsgBox "Es trat ein unvorhergesehener Fehler auf (ESQAFinden): " & Err.Description, vbCritical, "ESQA " & MyVersion
  MsgBox FMT1("ESQAFIND_3", Err.Description), vbCritical, "ESQA " & MyVersion
  Application.StatusBar = ""

End Sub

Public Sub ESQAWFinden()
  CheckStartupStuff
  
  On Error GoTo raffIchNet

  Dim ws As Worksheet
  Dim c As Range
  Dim ccnt As Long
  Dim rotChar
  rotChar = Array("|", "/", "-", "\")
  ccnt = 0
  Dim tCnt As Long
  tCnt = 0
  
  Dim r As Range
  
  Set ws = ActiveSheet
  Set r = Selection
  Dim start As Boolean
  start = True
  Dim endfind As Boolean
  endfind = False
  
  Do
    For Each c In ActiveSheet.UsedRange
      If endfind Then
        If c.Row >= r.Row Or (c.Row = r.Row And c.Column >= r.Column) Then
          'MsgBox "Keine Zellen gefunden", vbInformation, "ESQA " & MyVersion
          MsgBox FMT0("ESQAFIND_2"), vbInformation, "ESQA " & MyVersion
          Application.StatusBar = ""
          Exit Sub
        End If
      End If
      If start Then
        If c.Row > r.Row Or (c.Column > r.Column And c.Row = r.Row) Then
          start = False
        End If
      End If
      If Not start Then
        If c.Interior.ColorIndex <> xlNone Or _
            (c.Borders(xlEdgeLeft).LineStyle <> xlLineStyleNone And _
            c.Borders(xlEdgeRight).LineStyle <> xlLineStyleNone And _
            c.Borders(xlEdgeTop).LineStyle <> xlLineStyleNone And _
            c.Borders(xlEdgeBottom).LineStyle <> xlLineStyleNone) _
              Then ' = 8 Or c.Interior.ColorIndex = 4 Or c.Interior.ColorIndex = 6 Then
          c.Activate
          Application.StatusBar = ""
          Exit Sub
        End If
      End If
      
      If tCnt > 100 Then
        tCnt = 0
        'Application.StatusBar = "Bitte warten, Suche l|fffd|uft (Tabelle '" & ws.name & "'). " & rotChar(ccnt)
        Application.StatusBar = FMT2("ESQAFIND_1", ws.name, rotChar(ccnt))
        ccnt = ccnt + 1
        If ccnt = 4 Then ccnt = 0
      End If
      tCnt = tCnt + 1
    Next c
    
    ' Ok, das aktuelle Worksheet "erh|fffd|hen"
    Dim i As Long
    For i = 1 To Worksheets.Count
      If Sheets(i).name = ActiveSheet.name Then
        i = i + 1
        If i > Worksheets.Count Then i = 1
        Sheets(i).Activate
        If Sheets(i) Is ws Then
          endfind = True
        End If
        Exit For
      End If
    Next i
  Loop
  
  Application.StatusBar = ""
  Exit Sub
raffIchNet:
  'MsgBox "Es trat ein unvorhergesehener Fehler auf (ESQAWFinden): " & Err.Description, vbCritical, "ESQA " & MyVersion
  MsgBox FMT1("ESQAFIND_4", Err.Description), vbCritical, "ESQA " & MyVersion
  Application.StatusBar = ""
End Sub

Public Sub ESQATxtFinden()
  CheckStartupStuff
  
  On Error GoTo raffIchNet

  Dim ws As Worksheet
  Dim c As Range
  Dim ccnt As Long
  Dim rotChar
  rotChar = Array("|", "/", "-", "\")
  ccnt = 0
  Dim tCnt As Long
  tCnt = 0
  
  Dim r As Range
  
  Set ws = ActiveSheet
  Set r = Selection
  Dim start As Boolean
  start = True
  Dim endfind As Boolean
  endfind = False
  
  Do
    For Each c In ActiveSheet.UsedRange
      If endfind Then
        If c.Row >= r.Row Or (c.Row = r.Row And c.Column >= r.Column) Then
          'MsgBox "Keine Zellen gefunden", vbInformation, "ESQA " & MyVersion
          MsgBox FMT0("ESQAFIND_2"), vbInformation, "ESQA " & MyVersion
          Application.StatusBar = ""
          Exit Sub
        End If
      End If
      If start Then
        If c.Row > r.Row Or (c.Column > r.Column And c.Row = r.Row) Then
          start = False
        End If
      End If
      If Not start Then
        If InStr(c.Formula, theSearchtext) > 0 Then
          c.Activate
          Application.StatusBar = ""
          Exit Sub
        End If
      End If
      
      If tCnt > 100 Then
        tCnt = 0
        'Application.StatusBar = "Bitte warten, Suche l|fffd|uft (Tabelle '" & ws.name & "'). " & rotChar(ccnt)
        Application.StatusBar = FMT2("ESQAFIND_1", ws.name, rotChar(ccnt))
        ccnt = ccnt + 1
        If ccnt = 4 Then ccnt = 0
      End If
      tCnt = tCnt + 1
    Next c
    
    ' Ok, das aktuelle Worksheet "erh|fffd|hen"
    Dim i As Long
    For i = 1 To Worksheets.Count
      If Sheets(i).name = ActiveSheet.name Then
        i = i + 1
        If i > Worksheets.Count Then i = 1
        Sheets(i).Activate
        If Sheets(i) Is ws Then
          endfind = True
        End If
        Exit For
      End If
    Next i
  Loop
  
  Application.StatusBar = ""
  Exit Sub
raffIchNet:
  'MsgBox "Es trat ein unvorhergesehener Fehler auf (ESQATxtFinden): " & Err.Description, vbCritical, "ESQA " & MyVersion
  MsgBox FMT1("ESQAFIND_5", Err.Description), vbCritical, "ESQA " & MyVersion
  Application.StatusBar = ""
End Sub

Attribute VB_Name = "FileFuncs"
Option Explicit

'  Shell File Operations

Private Const FO_MOVE = &H1
Private Const FO_COPY = &H2
Private Const FO_DELETE = &H3
Private Const FO_RENAME = &H4
Private Const FOF_MULTIDESTFILES = &H1
Private Const FOF_CONFIRMMOUSE = &H2
Private Const FOF_SILENT = &H4                      '  don't create progress/report
Private Const FOF_RENAMEONCOLLISION = &H8
Private Const FOF_NOCONFIRMATION = &H10             '  Don't prompt the user.
Private Const FOF_WANTMAPPINGHANDLE = &H20          '  Fill in SHFILEOPSTRUCT.hNameMappings
                                      '  Must be freed using SHFreeNameMappings
Private Const FOF_ALLOWUNDO = &H40
Private Const FOF_FILESONLY = &H80                  '  on *.*, do only files
Private Const FOF_SIMPLEPROGRESS = &H100            '  means don't show names of files
Private Const FOF_NOCONFIRMMKDIR = &H200            '  don't confirm making any needed dirs

#If VBA7 Then

Private Type SHFILEOPSTRUCT
        Hwnd As LongPtr
        wFunc As LongPtr
        pFrom As String
        pTo As String
        fFlags As Integer
        fAnyOperationsAborted As Boolean
        hNameMappings As LongPtr
        lpszProgressTitle As String '  only used if FOF_SIMPLEPROGRESS
End Type


Private Declare PtrSafe Function SHFileOperation Lib "shell32.dll" Alias "SHFileOperationA" (lpFileOp As SHFILEOPSTRUCT) As Long
#Else

Private Type SHFILEOPSTRUCT
        Hwnd As Long
        wFunc As Long
        pFrom As String
        pTo As String
        fFlags As Integer
        fAnyOperationsAborted As Boolean
        hNameMappings As Long
        lpszProgressTitle As String '  only used if FOF_SIMPLEPROGRESS
End Type


Private Declare Function SHFileOperation Lib "shell32.dll" Alias "SHFileOperationA" (lpFileOp As SHFILEOPSTRUCT) As Long
#End If



Public Sub SyncCopy(Dateiname$, zielverzeichnis$)

Dim filenames$
Dim i As Integer
Dim shellinfo As SHFILEOPSTRUCT

filenames = Dateiname + Chr(0)

With shellinfo
        .Hwnd = 0 ' Screen.ActiveForm.Hwnd
        .wFunc = FO_COPY
        .pFrom = filenames
        .pTo = zielverzeichnis
        .fFlags = FOF_FILESONLY + FOF_NOCONFIRMMKDIR + FOF_SILENT  '+ FOF_NOCONFIRMATION
End With

SHFileOperation shellinfo

End Sub


Function GetPath(ByVal p As String) As String
  If InStrRev(p, "\") > 0 Then
    GetPath = Left(p, InStrRev(p, "\") - 1)
    Exit Function
  End If
  GetPath = p
End Function


Public Function DelTree(ByVal path As String) As Boolean
' L?scht mithilfe des FileSystemObject (ScrRun.dll) einen
' Verzeichnisbaum (sofern m?glich).
' Kann der Baum nicht komplett gel?scht werden, wird als
' Funktionsr?ckgabewert FALSE verwendet.
' Hinweis: Die Dateien werden direkt gel?scht, nicht
' lediglich in den Papierkorb verschoben!
Dim FSO As Object
  On Error Resume Next
  ' FileSystemObject instanzieren
  Set FSO = CreateObject("Scripting.FileSystemObject")
  ' Konnte das Objekt instanziert werden?
  If Err.Number <> 0 Then
 Exit Function
  End If
  ' Die DeleteFolder-Methode des Objekts aufrufen
  FSO.DeleteFolder path, True
  ' Trat beim L?schen ein Fehler auf?
  If Err.Number <> 0 Then
 Exit Function
  End If
  ' Fehlerfreie Abarbeitung => R?ckgabewert TRUE
  DelTree = True
End Function
Function ReadTextfile(ByVal strFileName As String) As String
  Dim iFile As Integer
  Dim fileWasOpen As Boolean
  fileWasOpen = False
  iFile = FreeFile
  On Error GoTo nogo
  Open strFileName For Input As #iFile
  fileWasOpen = True
  ReadTextfile = Input(LOF(iFile), iFile)
  Close #iFile
  Exit Function
nogo:
  If fileWasOpen Then
      Close #iFile
  End If
End Function
Function WriteTextfile(ByVal strFileName As String, txt As String) As String
  Dim iFile As Integer
  iFile = FreeFile
  On Error GoTo nogo
  Open strFileName For Output As #iFile
  Print #iFile, txt
  Close #iFile
  Exit Function
nogo:
End Function

Attribute VB_Name = "Globals"
Option Explicit

' Wenn das 1 ist wird getrackt, wie viel zeit die einzelnen Funktionen ben|fffd|tigen.
#If TIMECHECK = 1 Then
  Public G_HRT As HighResTimer
#End If

Global GSprache As Long
'Public Const MyVersion As String = "Version 2.5a"
Public Const MyVersionNumber As String = "2.8.1"
Public Const progNameShort As String = "ESQA"
Public Const ProgNameLong As String = "Excel-Sheet-QA"
Public Const MyInternalVersion As Long = 19
Public Const MyProgramLicenseVersion As Long = 0
Public Const MyFreeUsage As Date = 1 / 4 / 2019
Public trs As String
Public trsShrt As String
Public FullVersion As Boolean

Public LastProgText As String
Public ProgText As String
Public theSearchtext As String
Public Abbruch As Boolean
Public G_ErrorCount As Long
Public G_FormatErrorCount As Long
Public G_AnalyzeErrors As Long
Public G_ErrorText As String

Public G_InternetVersion As String
Public G_InternetAvailable As Boolean
Public G_InternetInternalVersion As Long
Public G_InternetLicenseVersion As Long
Public G_UpdateAvailable As Boolean
Public G_UpdateString As String
Public G_MyLicencseVersion As Long
Public G_UpdateText As String
Public G_Lizenzen As Long
Public G_FullDemoBis As Date
Public G_Wartung As Boolean
Public G_WartungBis As Date

Public G_Lizenznehmer As String
Public G_LizenznehmerAdresse As String

Public G_KommentareErzeugen As Boolean
Public G_KloneEinzeln As Boolean
Public G_ErgebnisseInEigenerDatei As Boolean

Public G_cfgLogpfad As String
Public G_cfgTemppfad As String
Public G_cfgKeypfad As String
Public G_cfgPasswortpfad As String

Public G_ModulmenueDeaktivieren As Boolean

'Public G_cTodo As CTodo

Public G_MarkCellsAmount As Long
Public G_ColorCells As Boolean

'Public KeyWrdsGE As Collection
'Public KeyWrdsEG As Collection
Public KomplexListe As Collection

Public G_HiglyEncryptedSheetPW As Long
Public G_HiglyEncryptedWorkbookPW  As Long

Public Const INFO_StartY As Long = 10

Public Const INFO_ConstantsY As Long = INFO_StartY + 0
Public Const INFO_UnusednumbersY As Long = INFO_StartY + 1
Public Const INFO_TextnumbersY As Long = INFO_StartY + 2
Public Const INFO_UnprotectedY As Long = INFO_StartY + 3
Public Const INFO_ErrorsY As Long = INFO_StartY + 4
Public Const INFO_ForgottenY As Long = INFO_StartY + 5
Public Const INFO_LinkedY As Long = INFO_StartY + 6
Public Const INFO_LinkedCellsY As Long = INFO_StartY + 7
Public Const INFO_ComplexBracY As Long = INFO_StartY + 8
Public Const INFO_ComplexMatrixY As Long = INFO_StartY + 9
Public Const INFO_ComplexTextY As Long = INFO_StartY + 10
Public Const INFO_ComplexListY As Long = INFO_StartY + 11
Public Const INFO_InvisibleY As Long = INFO_StartY + 12

Public G_All_ESQAFindConstants As Boolean
Public G_All_ESQAFindUnusedNumbers As Boolean
Public G_All_ESQAFindTextNumbers As Boolean
Public G_All_ESQAFindFormulaCellsWithoutProtection As Boolean
Public G_All_ESQAFindErrors As Boolean
Public G_All_ESQAFindForgottenCells As Boolean
Public G_All_ESQAFindInvisibleCells As Boolean
Public G_All_ESQAFindExternals As Boolean


' Public Const INFO_ReferenceY As Long = INFO_StartY + 6
Public Function MyVersion() As String
  MyVersion = FMT1("GLOBALS_1", MyVersionNumber)
End Function

Function FormulaAnalyzable(c) As Boolean
  FormulaAnalyzable = True
  On Error GoTo notAnalyzable
  If c.Formula = "a" Then
  End If
  Exit Function
notAnalyzable:
  FormulaAnalyzable = False
End Function



Sub FreeAllMem()
'  ActiveSheet.UsedRange
End Sub


Function GetCorrespondingFontColor(backIdx As Long)
  Select Case backIdx
    Case 4, 6, 8, 15, 19, 20, 24, 27, 28, 33, 34, 35, 36, 37, 38, 39, 40
      GetCorrespondingFontColor = 1
    Case Else
      GetCorrespondingFontColor = 2
  End Select
End Function

Sub ResetSheetFormats(ByRef ws As Worksheet)
  On Error Resume Next
  UpdateStatus FMT1("START_11", ws.name), -1
  
  With ws.Cells
     .ClearFormats
     .ClearComments
     .FormatConditions.Delete
  End With
  ws.Visible = xlSheetVisible

  UnfoldGroups ws
  ShowAllCells ws
End Sub

Sub ResetSheetFormatsOld(ByRef ws As Worksheet)
  On Error Resume Next
  UpdateStatus FMT1("START_11", ws.name), -1
'  actsheet.Cells.ClearFormats
  
  Dim lastTime As Date
  lastTime = Now
  
  Dim lineCells As Range
  Dim lineCount As Long
  Dim totalLineAmount As Long
  Dim lastRow As Long
  ws.ScrollArea = ""
  lastRow = GetLastRow(ws)
   
  If lastRow > 0 Then
     totalLineAmount = lastRow
     If lastRow > 40 And FullVersion = False Then
       lastRow = 40
     End If
     For lineCount = 1 To lastRow
       With ws.Rows(lineCount)
          .ClearFormats
          .ClearComments
          .FormatConditions.Delete
       End With
       If Abbruch Then Exit For
     Next lineCount
    If lastTime + TimeValue("0:00:01") <= Now Then
      'UpdateStatus "Analysiere '" & ActiveSheet.name & "'", CDbl(cnt) / CDbl(totalamount)
      UpdateStatus FMT1("START_11", ws.name), CDbl(lineCount) / CDbl(totalLineAmount)
      lastTime = Now
    End If
  End If
  Set lineCells = Nothing
  
  ws.Visible = xlSheetVisible

  UnfoldGroups ws
  ShowAllCells ws
End Sub

Sub ShowAllCells(ByRef oxlwsheet)
On Error Resume Next
  oxlwsheet.Rows.AutoFit
  oxlwsheet.Columns.AutoFit
End Sub

Sub UnfoldGroups(ByRef oxlwsheet)
On Error Resume Next
  oxlwsheet.Outline.ShowLevels 8, 8
End Sub



' Wird nicht benutzt!
#If wird_nicht_benutzt Then

Private Sub TranslateEnglishToGerman()
  Dim KeyWrdsEG As Collection
  Set KeyWrdsEG = New Collection
  
  
  Dim ff As Integer
  ff = FreeFile
  
  Dim l As Long
  Dim pos As Long
  
  Open ThisWorkbook.path & "\Excel-Sheet-QA Formula reference.txt" For Input As #ff
  l = 1
  Do While Not EOF(ff)
    Dim engl As String, deut As String
    Input #ff, engl
    pos = InStr(engl, " ")
    If pos <= 0 Then
      'MsgBox "In Zeile " & l & " fehlt ein Leerzeichen. Das Keyword-Paar muss durch ein Leerzeichen getrennt sein", vbCritical, "ESQA " & MyVersion
      MsgBox FMT1("GLOBALS_2", l), vbCritical, "ESQA " & MyVersion
      Close ff
      Exit Sub
    End If
    deut = Trim(Mid(engl, pos))
    engl = Trim(Left(engl, pos))
    KeyWrdsEG.Add deut, engl
    l = l + 1
  Loop
  Close ff
  
  Dim txt As String
  DoTrans KeyWrdsEG, "DAVERAGE,DGET,DMAX,DMIN,DPRODUCT,DESTDEV,DESTDEVP,DSUM,DVAR,DVARP,GETPIVOTDATA"
  DoTrans KeyWrdsEG, "CALL,REGISTER.ID,SQLREQUEST"
  DoTrans KeyWrdsEG, "ACCRINT,ACCRINTM,AMORDEGRC,AMORLINC,COUPDAYBS,COUPDAYS,COUPDAYSNC,COUPNCD,COUPNUM,COUPPCD,CUMIPMT,CUMPRINC,DB,DDB,DISC,DURATION,EFFECT,FV,FVSCHEDULE,INTRATE,IPMT,IRR,MDURATION,MIRR,NOMINAL,NPER,NPV,ODDFPRICE,ODDFYIELD,ODDLPRICE,ODDLYIELD,PMT,PPMT,PRICE,PRICEDISC,PRICEMAT,PV,RATE,RECEIVED,SLN,SYD,TBILLEQ,TBILLPRICE,TBILLYIELD,VDB,XIRR,XNPV,YIELD,YIELDDISC,YIELDMAT"
  DoTrans KeyWrdsEG, "ADDRESS,AREAS,CHOOSE,COLUMN,COLUMNS,HLOOKUP,HYPERLINK,INDEX,INDIRECT,LOOKUP,MATCH,OFFSET,ROW,ROWS,TRANSPOSE,VLOOKUP"
  DoTrans KeyWrdsEG, "AVEDEV,AVERAGE,AVERAGEA,BETADIST,BETAINV,BINOMDIST,CHIDIST,CHIINV,CHITEST,CONFIDENCE,CORREL,COUNT,COUNTA,COVAR,CRITBINOM,DEVSQ,EXPONDIST,FDIST,FINV,FISHER,FISHERINV,FORECAST,FREQUENCY,FTEST,GAMMADIST,GAMMAINV,GAMMALN,GEOMEAN,GROWTH,HARMEAN,HYPGEOMDIST,INTERCEPT,KURT,LARGE,LINEST,LOGEST,LOGINV,LOGNORMDIST,MEDIAN,MODE,NEGBINOMDIST,NORMDIST,NORMINV,NORMSDIST,NORMSINV,PEARSON,PERCENTILE,PERCENTRANK,PERMUT,POISSON,PROB,QUARTILE,RANK,RSQ,SKEW,SLOPE,SMALL,STANDARDIZE,STDEV,STDEVA,STDEVP,STDEVPASTEYX,TDIST,TINV,TREND,TRIMMEAN,TTEST,VAR,VARA,VARP,VARPA,WEIBULL,ZTEST"
  
End Sub


Sub DoTrans(ByRef KeyWrdsGE As Collection, txt As String)
  Dim Param As String
  Param = txt
  Dim res As String
  Dim pos As Long
  
  Dim neww As String
  
  Do
    pos = InStr(Param, ",")
    If pos <= 0 Then Exit Do
    If Len(Left(Param, pos - 1)) > 0 Then
      neww = TranslateKeywordGE(Left(Param, pos - 1), KeyWrdsGE)
      If Len(neww) > 0 Then
        If Len(res) = 0 Then
          res = neww
        Else
          res = res & "," & neww
        End If
      End If
    End If
    Param = Mid(Param, pos + 1)
  Loop
  
  If Len(Param) > 0 Then
    neww = TranslateKeywordGE(Param, KeyWrdsGE)
    If Len(neww) > 0 Then
      If Len(res) = 0 Then
        res = neww
      Else
        res = res & "," & neww
      End If
    End If
  End If
  
  Debug.Print res

End Sub

Function TranslateKeywordGE(w As String, ByRef KeyWrdsGE As Collection) As String

On Error GoTo notrans

  TranslateKeywordGE = KeyWrdsGE(w)
  Exit Function

notrans:
  TranslateKeywordGE = ""
End Function

#End If


Public Function CollectionItemExists(c As Collection, name As String) As Boolean
  On Error GoTo notReadable
  Dim s
  s = CStr(c(name))
  CollectionItemExists = True
  Exit Function
  
notReadable:
  CollectionItemExists = False
End Function

Sub ErrorHandler(ByVal funcname As String, ByVal errBereich As String, ByRef c As Range)

  If UCase(GetUserName()) = "NORMAN" Then
    MsgBox Err.Number & " " & Err.Description
  End If
  If Err.Number = 1004 Then
    G_FormatErrorCount = G_FormatErrorCount + 1
  Else
    G_ErrorCount = G_ErrorCount + 1
    G_ErrorText = G_ErrorText & "Error in " & funcname & IIf(errBereich <> "", " (Area: " & errBereich & ")", "") & ": " & Err.Number & " - " & Err.Description & vbCrLf
    If Not c Is Nothing Then
      G_ErrorText = G_ErrorText & " (" & c.Parent.name & "!" & c.Address & ")" & vbLf
    Else
      G_ErrorText = G_ErrorText & vbLf
    End If
  End If
End Sub


Attribute VB_Name = "Helpers"
Option Explicit

Const NoError = 0       'The Function call was successful

#If VBA7 Then
Public Declare PtrSafe Sub Sleep Lib "kernel32" (ByVal _
  dwMilliseconds As Long)

Declare PtrSafe Function WNetGetUser Lib "mpr.dll" _
      Alias "WNetGetUserA" (ByVal lpName As String, _
      ByVal lpUserName As String, lpnLength As Long) As Long

Private Declare PtrSafe Function GetShortPathName Lib "Kernel32.dll" _
  Alias "GetShortPathNameA" ( _
  ByVal lpszLongPath As String, _
  ByVal lpszShortPath As String, _
  ByVal cchBuffer As Long) As Long

Public Declare PtrSafe Function FindExecutable Lib "shell32.dll" Alias _
    "FindExecutableA" (ByVal lpFile As String, ByVal lpDirectory As String, ByVal lpResult As String) As Long

Public Declare PtrSafe Function apiGetTempPath Lib "kernel32" Alias "GetTempPathA" (ByVal nBufferLength As Long, ByVal lpBuffer As String) As Long

#Else
Public Declare Sub Sleep Lib "kernel32" (ByVal _
  dwMilliseconds As Long)

Declare Function WNetGetUser Lib "mpr.dll" _
      Alias "WNetGetUserA" (ByVal lpName As String, _
      ByVal lpUserName As String, lpnLength As Long) As Long

Private Declare Function GetShortPathName Lib "Kernel32.dll" _
  Alias "GetShortPathNameA" ( _
  ByVal lpszLongPath As String, _
  ByVal lpszShortPath As String, _
  ByVal cchBuffer As Long) As Long

Public Declare Function FindExecutable Lib "shell32.dll" Alias _
    "FindExecutableA" (ByVal lpFile As String, ByVal lpDirectory As String, ByVal lpResult As String) As Long

Public Declare Function apiGetTempPath Lib "kernel32" Alias "GetTempPathA" (ByVal nBufferLength As Long, ByVal lpBuffer As String) As Long

#End If

Public G_LogEnabled As Boolean


Function GetTempPath(Optional ByVal noTrailingBackslash As Boolean = False) As String
  Dim RetVal As Long
  Dim pathbuffer As String * 512
  
  Dim l As Long
  Dim s As String
  l = apiGetTempPath(512, pathbuffer)
  If l > 0 Then
    s = Trim(Left(pathbuffer, l))
  End If
  If Right(s, 1) = "\" Then
    s = Left(s, Len(s) - 1)
  End If
  GetTempPath = s
End Function

Function SheetHasPassword(oxlwsheet)
    SheetHasPassword = True
    On Error GoTo password_notok
    ' Wir probieren das Ganze mit einem idiotischen Passwort
    oxlwsheet.Unprotect "12%%XXy<11!A"
    SheetHasPassword = False
password_notok:
End Function

Function WorkbookHasPassword(oXLWbook)
    WorkbookHasPassword = True
    On Error GoTo password_notok
    ' Wir probieren das Ganze mit einem idiotischen Passwort
    oXLWbook.Unprotect "12%%XXy<11!A"
    WorkbookHasPassword = False
password_notok:
End Function

Public Function StringAdd(stringlist, txt As String) As Boolean
    StringAdd = False
    Dim item
    For Each item In stringlist
        If item = txt Then Exit Function
    Next item
    StringAdd = True
    stringlist.Add txt
End Function

Function InStrMyRev(str As String, v As String, Optional pos As Long = 0) As Long
  Dim i As Long
  If Not IsMissing(pos) And pos > 0 Then
    i = pos
  Else
    i = Len(str)
  End If
  Do While i > 0
    If Mid(str, i, Len(v)) = v Then
      InStrMyRev = i
      Exit Function
    End If
    i = i - 1
  Loop
  InStrMyRev = 0
End Function


Function FileExists(ByVal Dateiname$) As Boolean
    'Die Funktion pr|fffd|ft, ob eine Datei vorhanden ist
On Error GoTo fehler:

  If Trim(Dateiname$) = "" Then Exit Function

  Dim res As Boolean
  If UCase(Left(Dateiname, 5)) = "HTTP:" Or UCase(Left(Dateiname, 6)) = "HTTPS:" Then
    Dim sz As Long
    Dim modDate As Date
    FileExists = URLExists(Dateiname, sz, modDate)
  Else
    res = Dir$(Dateiname) <> ""
    If res = False Then
      res = Dir$(GetDriveAndPathFromUNC(Dateiname)) <> ""
    End If
    FileExists = res
  End If
    Exit Function
fehler:
    FileExists = False
    If Len(Dateiname) > 260 Then
        FileExists = MyFileExistsLongName(Dateiname)
    End If
End Function

Function MyFileExistsLongName(ByVal fname As String) As Boolean
On Error GoTo nogo
    If Len(fname) > 260 Then
        fname = "\\?\UNC\" & Mid$(fname, 3)
    End If
    
    Dim fs
    Set fs = CreateObject("Scripting.FileSystemObject")
    MyFileExistsLongName = fs.FileExists(fname)
    Exit Function
nogo:
    MyFileExistsLongName = False
End Function

Function URLExists(url As String, ByRef sz As Long, ByRef modDate As Date) As Boolean
    Dim Request As Object
    Dim ff As Integer
    Dim rc As Variant
    On Error GoTo EndNow
    sz = 0
    modDate = 0
    URLExists = False
    Set Request = CreateObject("MSXML2.XMLHTTP")
    With Request
      .Open "HEAD", url, False
      Request.SetRequestHeader "Cache-Control", "no-store, no-cache"
      Request.SetRequestHeader "Pragma", "no-cache"
      .Send
      If .readyState = 4 Then
        URLExists = True
        sz = .getResponseHeader("Content-Length")
        Dim s As String
        s = Mid(Request.getResponseHeader("Last-Modified"), 6, 1000)
        s = Left(s, Len(s) - 4)
        modDate = CDate(s)
      Else
        .abort
      End If
    End With
    Set Request = Nothing
    Exit Function
EndNow:
    Debug.Print Err.Description
    Set Request = Nothing
End Function

Sub AddStatus(txt As String, Optional col As Long = 196)
  
  Application.StatusBar = txt
End Sub
Sub UpdateStatus(txt As String, percentDone As Double)
  StatusForm.CurrentStatus = txt
  If percentDone >= 0 Then
    StatusForm.FrameProgress.Caption = Format(percentDone, "Percent")
    StatusForm.LabelProgress.Width = percentDone * (StatusForm.FrameProgress.Width - 10)
    Application.StatusBar = txt & " " & StatusForm.FrameProgress.Caption
  Else
    Application.StatusBar = txt
  End If
  DoEvents
'  StatusForm.Repaint
End Sub

Function RemoveVariableNames(ByVal txt As String) As String
  Dim i As Long
  Dim pos As Long
  Dim pos2 As Long
  Dim foundOne As Boolean
  
  Do
    foundOne = False
    For i = 1 To Len(txt)
      Dim curChar As String
      curChar = Mid(txt, i, 1)
      If (curChar >= "a" And curChar <= "z") Or _
         (curChar >= "A" And curChar <= "Z") Then
        pos = i
        Do While i < Len(txt)
          curChar = Mid(txt, i, 1)
          If Not ((curChar >= "a" And curChar <= "z") Or _
                  (curChar >= "A" And curChar <= "Z") Or _
                  (curChar >= "0" And curChar <= "9") Or _
                  curChar >= "_") Then
            Exit Do
          End If
          i = i + 1
        Loop
        pos2 = i
        Dim tStr As String
        tStr = ""
        If pos > 1 Then tStr = Left(txt, pos - 1)
        If pos2 < Len(txt) Then tStr = tStr & Mid(txt, pos2)
        txt = tStr
        foundOne = True
        Exit For
      End If
    Next i
  Loop While foundOne
  RemoveVariableNames = txt
End Function

Function RemoveStrings(ByVal txt As String, remstr As String, remstr2 As String) As String
  Dim pos As Long
  Dim pos2 As Long
  Do
    pos = InStr(txt, remstr)
    If pos <= 0 Then Exit Do
    pos2 = InStr(pos + 1, txt, remstr2)
    If pos2 <= 0 Then Exit Do
    Dim tStr As String
    tStr = ""
    If pos > 1 Then tStr = Left(txt, pos - 1)
    If pos2 < Len(txt) Then tStr = tStr & Mid(txt, pos2 + 1)
    txt = tStr
  Loop
  RemoveStrings = txt
End Function

Function RemoveText(ByVal txt As String, remstr As String) As String
  Dim pos As Long
  Do
    pos = InStr(txt, remstr)
    If pos <= 0 Then Exit Do
    Dim tStr As String
    tStr = ""
    If pos > 1 Then tStr = Left(txt, pos - 1)
    If pos + Len(remstr) <= Len(txt) Then tStr = tStr & Mid(txt, pos + Len(remstr))
    txt = tStr
  Loop
  RemoveText = txt
End Function


Sub FrameCell(c As Range)
  With c
    With .Borders(xlEdgeLeft)
      If .LineStyle = xlLineStyleNone Then
        .LineStyle = xlContinuous
        .Weight = xlHairline
        .ColorIndex = 1
      End If
    End With
    With .Borders(xlEdgeTop)
      If .LineStyle = xlLineStyleNone Then
        .LineStyle = xlContinuous
        .Weight = xlHairline
        .ColorIndex = 1
      End If
    End With
    With .Borders(xlEdgeBottom)
      If .LineStyle = xlLineStyleNone Then
        .LineStyle = xlContinuous
        .Weight = xlHairline
        .ColorIndex = 1
      End If
    End With
    With .Borders(xlEdgeRight)
      If .LineStyle = xlLineStyleNone Then
        .LineStyle = xlContinuous
        .Weight = xlHairline
        .ColorIndex = 1
      End If
    End With
  End With
End Sub

Sub CheckErrorMessage()
    CheckOccErrors
    
    If G_ErrorCount > 0 Then
      On Error GoTo nowrite
      Dim ff As Long
      ff = FreeFile
      
      Dim tmpPath As String
      If G_cfgTemppfad <> "" Then
        tmpPath = G_cfgTemppfad
      Else
        tmpPath = GetTempPath(True)
      End If
      
      
      Open tmpPath & "\Excel-Sheet-QA-Error.txt" For Output As ff
      Print #ff, G_ErrorText
      Close ff
      
      Dim anony As String
      If Not ActiveWorkbook Is Nothing Then
        If FileExists(ThisWorkbook.path & "\ExcelAnonymizer.exe") Then
          anony = ThisWorkbook.path & "\ExcelAnonymizer.exe"
        ElseIf FileExists(ThisWorkbook.path & "..\Tools\ExcelAnonymizer.exe") Then
          anony = ThisWorkbook.path & "..\Tools\ExcelAnonymizer.exe"
        End If
      End If
      
      If anony = "" Or GetOriginalFilename = "" Then
        'MsgBox "Es sind " & G_ErrorCount & " Fehler aufgetreten! Bitte setzen Sie sich mit uns in Verbindung (info@stromwerken.de) und senden uns die Datei '" & ThisWorkbook.path & "\Excel-Sheet-QA-Error.txt' per Mail zu. Vielen Dank!", vbCritical, "ESQA " & MyVersion
        MsgBox FMT2("HELPERS_1", G_ErrorCount, tmpPath), vbCritical, "ESQA " & MyVersion
      Else
        '
        MsgBox FMT3("HELPERS_21", G_ErrorCount, tmpPath, GetFileNameAndPath(GetOriginalFilename) & ".ANONYM." & GetFileExtension(GetOriginalFilename)), vbCritical, "ESQA " & MyVersion
        Call Shell(Chr(34) & anony & Chr(34) & " " & Chr(34) & GetOriginalFilename & Chr(34) & " /MSGBOX", 1)
      End If
    End If
    Exit Sub
nowrite:
    'MsgBox "Es sind " & G_ErrorCount & " Fehler aufgetreten! Eine Fehlerdatei konnte nicht erzeugt werden. Bitte setzen Sie sich mit uns in Verbindung (info@stromwerken.de). Vielen Dank!", vbCritical, "ESQA " & MyVersion
    MsgBox FMT1("HELPERS_2", G_ErrorCount), vbCritical, "ESQA " & MyVersion
End Sub

Sub AddMyComment(c As Range, txt As String, w As Long, h As Long)
  If Not G_KommentareErzeugen Then Exit Sub
  If c.Comment Is Nothing Then
    With c.AddComment
      .Text txt
      .Shape.Width = w
      .Shape.Height = h
    End With
  Else
    Dim neww As Long
    If c.Comment.Shape.Width < w Then
      neww = w
    Else
      neww = c.Comment.Shape.Width
    End If
    Dim newh As Long
    newh = h + c.Comment.Shape.Height '  + 12
    Dim newtxt As String
    newtxt = c.Comment.Text & vbLf & txt
    c.Comment.Delete
    With c.AddComment
      .Text newtxt
      .Shape.Width = neww
      .Shape.Height = newh
    End With
  End If
End Sub

Function CellHasDependents(ByRef c As Range) As Boolean

  'CellHasDependents = HasArrows(c, False, False)

  c.ShowDependents
  
  On Error Resume Next
  c.NavigateArrow False, 1, 1
  
  If Err.Number <> 0 Then
    Exit Function
  End If
          
  If c.Address(external:=True) = ActiveCell.Address(external:=True) Then
    c.Parent.ClearArrows
    Exit Function
  End If
          
  c.Parent.ClearArrows
  CellHasDependents = True

End Function
Function CellHasPrecedents(c As Range) As Boolean
  CellHasPrecedents = HasArrows(c, True, False)
End Function


Function CellHasDirectPrecedents(c As Range) As Boolean
  Dim deps As Range
  On Error GoTo noDeps
  Set deps = c.DirectPrecedents
  CellHasDirectPrecedents = True
  Exit Function
noDeps:
  CellHasDirectPrecedents = False
End Function

Sub CheckOccErrors()
  If G_FormatErrorCount > 0 Then
    'MsgBox G_FormatErrorCount & " Zelle(n) konnte nicht eingef|fffd|rbt werden, da die zu analysierende Excel-Datei zu viele Formate erhalten w|fffd|rde. Die Kommentare wurden trotzdem angebracht.", vbCritical, "ESQA " & MyVersion
    MsgBox FMT1("HELPERS_3", G_FormatErrorCount), vbCritical, "ESQA " & MyVersion
  End If
End Sub

Function GetFilePath(ByVal fn As String)
    Dim File As String
    Dim path As String
    Dim ext As String
    
    fileSplit fn, path, File, ext
    GetFilePath = Left(path, Len(path) - 1)
End Function

Function GetFileNameAndPath(ByVal fn As String)
    Dim File As String
    Dim path As String
    Dim ext As String
    
    fileSplit fn, path, File, ext
    GetFileNameAndPath = path & File
End Function

Function GetFileNameAndExtension(ByVal fn As String)
    Dim File As String
    Dim path As String
    Dim ext As String
    
    fileSplit fn, path, File, ext
    GetFileNameAndExtension = File & "." & ext
End Function

Function GetFileExtension(ByVal fn As String)
    Dim File As String
    Dim path As String
    Dim ext As String
    
    fileSplit fn, path, File, ext
    GetFileExtension = ext
End Function


Sub fileSplit(ByVal s$, ByRef path$, ByRef File$, ByRef ext$)
    ' die Prozedur zerlegt den Dateinamen S in Path, Name, Extension
    Dim i%
    For i = Len(s) To 1 Step -1
        If Mid(s, i, 1) = "\" Or Mid(s, i, 1) = "/" Then   ' keine Extension vorhanden
            ext = ""
            Exit For
        End If
        If Mid(s, i, 1) = "." Then
            ext = Right(s, Len(s) - i)
            s = Left(s, i - 1)
            Exit For
        End If
    Next i
    i = Len(s)
    If InStr(s, "\") <> 0 Then
        While Mid(s, i, 1) <> "\"
            i = i - 1
        Wend
    ElseIf InStr(s, "/") <> 0 Then
        While Mid(s, i, 1) <> "/"
            i = i - 1
        Wend
    End If
    path = Left(s, i)
    File = Right(s, Len(s) - i)

End Sub


Sub ESQAOpenCopy()
  CheckStartupStuff

  Dim wb As Workbook
  Set wb = ActiveWorkbook
  
  If GetFileExtension(ActiveWorkbook.FullName) = "ESQA" Then
    'MsgBox "Dies ist bereits eine ESQA-Datei", vbCritical, "ESQA " & MyVersion
    MsgBox FMT0("HELPERS_4"), vbCritical, "ESQA " & MyVersion
    Exit Sub
  End If

  If FileExists(ActiveWorkbook.FullName & ".ANALYSE.ESQA") Then
    
'    If Not ActiveWorkbook.Saved Then
'      MsgBox "Die aktuelle Datei weist Ver|fffd|nderungen auf und wurde noch nicht gespeichert. Bitte speichern Sie die Datei zuerst.", vbCritical, "ESQA " & MyVersion
'      Exit Sub
'    End If
    
    If Not GetFile(ActiveWorkbook.FullName & ".ANALYSE.ESQA", False) Then
      'MsgBox "Beim |fffd|ffnen der Datei " & ActiveWorkbook.FullName & ".ANALYSE.ESQA" & " ist ein nicht behebbarer Fehler aufgetreten.", vbCritical, "ESQA " & MyVersion
      MsgBox FMT1("HELPERS_5", ActiveWorkbook.FullName), vbCritical, "ESQA " & MyVersion
'    Else
'      wb.Close False
'      MsgBox "Die Originaldatei wurde geschlossen und die Sicherungskopie der Datei mit der Endung ESQA ge|fffd|ffnet! Diese Datei k|fffd|nnen Sie ver|fffd|ndern und auch speichern.", vbInformation, "ESQA " & MyVersion
    End If
  Else
    'MsgBox "F|fffd|r die aktuelle Datei existiert keine ESQA-Datei", vbInformation, "ESQA " & MyVersion
    MsgBox FMT0("HELPERS_6"), vbInformation, "ESQA " & MyVersion
  End If

End Sub


Function GetLastSaveTime(ByRef wb As Workbook) As Date
  On Error Resume Next
  Dim t As Date
  t = wb.BuiltinDocumentProperties("Last Save Time")
  If IsDate(t) Then
    GetLastSaveTime = t
    Exit Function
  End If
End Function

Sub PrintBuiltinProperties(ByRef wb As Workbook)
  On Error Resume Next
  Dim ti As Long
  For ti = 1 To wb.BuiltinDocumentProperties.Count
    Debug.Print wb.BuiltinDocumentProperties(ti).name & ": " & wb.BuiltinDocumentProperties(ti)
  Next ti

End Sub


Private Function SaveExcelFile(ByRef wb As Workbook) As Boolean
  On Error GoTo nogo
  wb.Save
  SaveExcelFile = True
nogo:
End Function

Function OpenCopy(ByRef wb As Workbook) As Boolean

  OpenCopy = False
  
  Dim wbfullname As String
  wbfullname = wb.FullName
  
  If UCase(GetFileExtension(wb.name)) = "ESQA" Then
    OpenCopy = True
    ShowStatusForm
    Exit Function
  End If
  
  If Not wb.Saved Then
    
    Dim quesres As Long
    'quesres = MsgBox("Die aktuelle Datei weist Ver|fffd|nderungen auf!" & vbCrLf & vbCrLf & "Dies kann, neben normalen Ver|fffd|nderungen einer Zelle durch einen User, z.B. durch die Verwendung bestimmter Formeln (jetzt(), heute(), indirekt() etc.) oder durch Verkn|fffd|pfungen mit anderen Dateien, auftreten." & vbCrLf & vbCrLf & "Soll mit der aktuell gespeicherten Excel-Datei bzw. der letzten Analysedatei garbeitet werden?" & vbCrLf & vbCrLf & "ACHTUNG: Bei NEIN wird die aktuelle Datei gespeichert und dann eine neue ESQA-Datei erzeugt! Bei ABBRUCH wird der Vorgang abgebrochen.", vbQuestion + vbYesNoCancel, "ESQA " & MyVersion)
    quesres = MsgBox(FMT0("HELPERS_20"), vbQuestion + vbYesNo, "ESQA " & MyVersion)
    If quesres = vbYes Then
      If Not SaveExcelFile(wb) Then
        OpenCopy = False
        Exit Function
      End If
    Else
      ' Erst mal pr|fffd|fen, ob die Analysedatei schon offen ist
      If WorkbookExistsByFilename(wb.FullName & ".ANALYSE.ESQA") Then
        ' Ja, ist offen, dann damit weiter arbeiten
        WorkbookActivateByFilename wb.FullName & ".ANALYSE.ESQA"
        OpenCopy = True
        ShowStatusForm
        Exit Function
      End If
    End If
  ' Erst mal pr|fffd|fen, ob die Analysedatei schon offen ist
  ElseIf WorkbookExistsByFilename(wb.FullName & ".ANALYSE.ESQA") Then
    WorkbookActivateByFilename wb.FullName & ".ANALYSE.ESQA"
    OpenCopy = True
    ShowStatusForm
    Exit Function
  End If
  
  Dim storedOldESQA As Boolean
  storedOldESQA = False
  
  If FileExists(wb.FullName & ".ANALYSE.ESQA") Then
    If MyFileDateTime(wb.FullName & ".ANALYSE.ESQA") < GetLastSaveTime(wb) Then
      
      If FileExists(wb.FullName & ".BKP.ESQA") Then
        Kill wb.FullName & ".BKP.ESQA"
      End If
      If Not FileExists(wb.FullName & ".BKP.ESQA") Then
        SyncCopy wb.FullName & ".ANALYSE.ESQA", wb.FullName & ".BKP.ESQA"
        storedOldESQA = True
      End If
      
      If WorkbookExistsByFilename(wb.FullName & ".ANALYSE.ESQA") Then
'        If MsgBox("Die Datei '" & wb.FullName & ".ANALYSE.ESQA' ist noch ge|fffd|ffnet! Soll sie geschlossen werden? (Bei NEIN wird der Vorgang abgebrochen)", vbQuestion + vbYesNo) = vbNo Then Exit Function
        Workbooks(GetFileNameAndExtension(wb.FullName & ".ANALYSE.ESQA")).Close False
      End If
      MyKill wb.FullName & ".ANALYSE.ESQA"
      If FileExists(wb.FullName & ".ANALYSE.ESQA") Then
        'MsgBox "Die Datei '" & wb.FullName & ".ANALYSE.ESQA' konnte nicht gel|fffd|scht werden. Der Vorgang wird abgebrochen!", vbCritical
        MsgBox FMT1("HELPERS_8", wb.FullName), vbCritical
        Exit Function
      End If
      
      
'      If MsgBox("ACHTUNG: Die aktuelle Datei ist J|fffd|NGER als die ESQA-Sicherheitskopie! Um Fehlanalysen vorzubeugen wird die ESQA-Datei jetzt neu erzeugt. Soll eine Sicherheitskopie der ESQA-Datei mit dem Namen '" & wb.FullName & ".ANALYSE.ESQA." & Format(Now(), "yyyy.mm.dd") & ".xls' erzeugt werden?", vbYesNo, "ESQA " & MyVersion) = vbYes Then
'        If FileExists(wb.FullName & ".ANALYSE.ESQA." & Format(Now(), "yyyy.mm.dd") & ".xls") Then
'          Kill wb.FullName & ".ANALYSE.ESQA." & Format(Now(), "yyyy.mm.dd") & ".xls"
'        End If
'        SyncCopy wb.FullName & ".ANALYSE.ESQA", wb.FullName & ".ANALYSE.ESQA." & Format(Now(), "yyyy.mm.dd") & ".xls"
'      End If
'      Kill wb.FullName & ".ANALYSE.ESQA"
    End If
  End If
  
  
  If FileExists(wb.FullName & ".ANALYSE.ESQA") Then
    If Not GetFile(wb.FullName & ".ANALYSE.ESQA", False) Then
      'If MsgBox("Beim |fffd|ffnen der Datei " & wb.FullName & ".ANALYSE.ESQA" & " ist ein Fehler aufgetreten. Soll die Datei gel|fffd|scht und neu angelegt werden?", vbYesNo, "ESQA " & MyVersion) = vbYes Then
      If MsgBox(FMT1("HELPERS_9", wb.FullName), vbYesNo, "ESQA " & MyVersion) = vbYes Then
        CreateCopyWithoutPasswordIfNecessary wb, wb.FullName, wb.FullName & ".ANALYSE.ESQA"
            If Not GetFile(wb.FullName & ".ANALYSE.ESQA", False) Then
              'MsgBox "Beim |fffd|ffnen der Datei " & wb.FullName & ".ANALYSE.ESQA" & " ist (erneut) ein nicht behebbarer Fehler aufgetreten. Bitte l|fffd|schen Sie die .ANALYSE.ESQA-Datei.", vbCritical, "ESQA " & MyVersion
              MsgBox FMT1("HELPERS_10", wb.FullName), vbCritical, "ESQA " & MyVersion
              OpenCopy = False
              Exit Function
            Else
              'MsgBox "Es wurde eine Sicherungskopie der Datei mit der Endung ESQA erzeugt! Diese Datei k|fffd|nnen Sie ver|fffd|ndern und auch speichern.", vbInformation, "ESQA " & MyVersion
              MsgBox FMT0("HELPERS_11"), vbInformation, "ESQA " & MyVersion
'              wb.Close False
              OpenCopy = True
            End If
'            Exit Function
      Else
        Exit Function
      End If
    Else
'      wb.Close False
      OpenCopy = True
'      MsgBox "Es wurde eine Sicherungskopie der Datei mit der Endung ESQA ge|fffd|ffnet! Diese Datei k|fffd|nnen Sie ver|fffd|ndern und auch speichern.", vbInformation, "ESQA " & MyVersion
'      Exit Function
    End If
  Else

    If Not FileExists(wb.FullName) Then
      'MsgBox "Die Datei wurde noch nicht gespeichert und kann deshalb nicht gepr|fffd|ft werden!", vbCritical, "ESQA " & MyVersion
      MsgBox FMT0("HELPERS_12"), vbCritical, "ESQA " & MyVersion
      OpenCopy = False
      Exit Function
    Else
      CreateCopyWithoutPasswordIfNecessary wb, wbfullname, wbfullname & ".ANALYSE.ESQA"
      If Not WorkbookExists(GetFileNameAndExtension(wbfullname)) Then
        GetFile wbfullname, False
        If WorkbookExists(GetFileNameAndExtension(wbfullname)) Then
          Set wb = Workbooks(GetFileNameAndExtension(wbfullname))
        Else
          OpenCopy = False
          Exit Function
        End If
      End If
      If Not GetFile(wbfullname & ".ANALYSE.ESQA", False) Then
        'MsgBox "Beim |fffd|ffnen der Datei " & wb.FullName & ".ANALYSE.ESQA" & " ist (erneut) ein nicht behebbarer Fehler aufgetreten. Bitte l|fffd|schen Sie die .ANALYSE.ESQA-Datei.", vbCritical, "ESQA " & MyVersion
        MsgBox FMT1("HELPERS_10", wb.FullName), vbCritical, "ESQA " & MyVersion
        OpenCopy = False
        Exit Function
      Else
'        MsgBox "Es wurde eine Sicherungskopie der Datei mit der Endung ESQA erzeugt! Diese Datei k|fffd|nnen Sie ver|fffd|ndern und auch speichern." & IIf(storedOldESQA, " Die bisherige ESQA-Datei wurde mit der Endung .BKP.ANALYSE.ESQA gesichert", ""), vbInformation, "ESQA " & MyVersion
'        wb.Close False
        OpenCopy = True
      End If
    End If
'    Exit Function
  End If
  
  ' Dann pr|fffd|fen wir am Ende nun einfach auf Passw|fffd|rter, falls noch welche drin sind werden sie (bei Dateiendung 3 Buchstaben)
  ' entfernt und die Datei nochmals gespeichert
  
  ShowStatusForm
  
  'StatusForm.CurrentStatus = "Bitte warten..."
  StatusForm.CurrentStatus = FMT0("BW_1")
  
  If Len(GetFileExtension(wb.name)) = 3 Then
    ' Wenn noch Passw|fffd|rter drauf sind wird versucht, die zu entfernen
    
    If WorkbookExistsByFilename(wb.FullName & ".ANALYSE.ESQA") Then
      Dim newwb As Workbook
      Set newwb = Workbooks(GetFileNameAndExtension(wb.FullName & ".ANALYSE.ESQA"))
      
      Dim calc As Long
      Dim bEnableEvents As Boolean
      Dim bScreenUpdating As Boolean
      DisableExcel calc, bScreenUpdating, bEnableEvents
      RemovePWWorkbook newwb
      Dim ws As Worksheet
      For Each ws In ActiveWorkbook.Worksheets
        If WorksheetsProtected(newwb.name) = True Or WorkbookProtected(newwb.name) = True Then
          RemovePW ws
        End If
      Next ws
      Set ws = Nothing
      Set newwb = Nothing
      Dim olden As Boolean
      olden = Application.DisplayAlerts
      Application.DisplayAlerts = False
      wb.Save
      Application.DisplayAlerts = olden
      EnableExcel calc, bScreenUpdating, bEnableEvents
    End If
  End If
End Function

'Function TranslateKeywordGE(w As String) As String

'On Error GoTo notrans

'  TranslateKeywordGE = KeyWrdsGE(w)
'  Exit Function

'notrans:
'  TranslateKeywordGE = w
'End Function

'Function TranslateKeywordEG(w As String) As String

'On Error GoTo notrans

'  TranslateKeywordEG = KeyWrdsEG(w)
'  Exit Function

'notrans:
'  TranslateKeywordEG = w
'End Function

Sub PrintComment(txt As String)

  If theRessheet Is Nothing Then Exit Sub

  Dim pos As Long
  Dim lastsec As Long
  pos = 1
  lastsec = 1

  Do
  
    pos = InStr(pos, txt, " ")
    If pos <= 0 Then
        theRessheet.Cells(theRessheetY, 1) = Mid(txt, lastsec)
        theRessheet.Cells(theRessheetY, 1).Font.Italic = True
        theRessheetY = theRessheetY + 1
        Exit Do
    Else
      If pos - lastsec > 100 Then
        theRessheet.Cells(theRessheetY, 1) = Mid(txt, lastsec, pos - lastsec)
        theRessheet.Cells(theRessheetY, 1).Font.Italic = True
        theRessheetY = theRessheetY + 1
        lastsec = pos + 1
      End If
      pos = pos + 1
    End If
  Loop
  theRessheetY = theRessheetY + 1
End Sub


Sub PrintHeader(txt As String)

  If theRessheet Is Nothing Then Exit Sub

  Dim pos As Long
  Dim lastsec As Long
  pos = 1
  lastsec = 1

  Do
  
    pos = InStr(pos, txt, " ")
    If pos <= 0 Then
        theRessheet.Cells(theRessheetY, 1) = Mid(txt, lastsec)
        theRessheet.Cells(theRessheetY, 1).Font.bold = True
        theRessheetY = theRessheetY + 1
        Exit Do
    Else
      If pos - lastsec > 100 Then
        theRessheet.Cells(theRessheetY, 1) = Mid(txt, lastsec, pos - lastsec)
        theRessheet.Cells(theRessheetY, 1).Font.bold = True
        theRessheetY = theRessheetY + 1
        lastsec = pos + 1
      End If
      pos = pos + 1
    End If
    

  Loop
End Sub

Function SheetExists(wb As Workbook, sheetname As String)
On Error GoTo doesntExist
  Dim s As String
  s = wb.Sheets(sheetname).name
  SheetExists = True
  Exit Function
doesntExist:
  SheetExists = False
End Function

Function FormulaLocalOK(c As Range) As Boolean
  On Error GoTo notOK
  Dim s As String
  s = c.FormulaLocal
  FormulaLocalOK = True
  Exit Function
notOK:
  FormulaLocalOK = False
End Function

Function FormulaR1C1Readable(c As Range) As Boolean
  On Error GoTo notOK
  Dim s As String
  s = c.FormulaR1C1
  FormulaR1C1Readable = True
  Exit Function
notOK:
  FormulaR1C1Readable = False
End Function

Function FormulaR1C1ReadableAndMarkIfNot(c As Range) As Boolean
  On Error GoTo notOK
  Dim s As String
  s = c.FormulaR1C1
  FormulaR1C1ReadableAndMarkIfNot = True
  Exit Function
notOK:
  FormulaR1C1ReadableAndMarkIfNot = False

  With c
    With .Borders(xlDiagonalDown)
        .LineStyle = xlContinuous
        .Weight = xlThin
        .ColorIndex = 1
    End With
    With .Borders(xlDiagonalUp)
        .LineStyle = xlContinuous
        .Weight = xlThin
        .ColorIndex = 1
    End With
    FrameCell c
    'AddMyComment c, "Formel nicht analysierbar!!!", 220, 24
    AddMyComment c, FMT0("MCOL_CLONES_2"), 220, 24
  End With
  G_AnalyzeErrors = G_AnalyzeErrors + 1
End Function



Function GetFormula(c As Range) As String
  On Error Resume Next
  GetFormula = c.FormulaLocal
  If Err.Number = 0 Then Exit Function
  Err.Clear
  GetFormula = "ENG: " & c.Formula
  If Err.Number = 0 Then Exit Function
  Err.Clear
  GetFormula = "### " & CStr(c.value)
  If Err.Number = 0 Then Exit Function
  Err.Clear
  'GetFormula = "!!! Unbekannter Fehler !!!"
  GetFormula = FMT0("HELPERS_14")
End Function

Sub ClearLog()
  On Error Resume Next
  If G_cfgLogpfad = "" Then
    Kill ThisWorkbook.path & "\ESQA-Log-" & GetUserName & ".txt"
  Else
    Kill G_cfgTemppfad & "\ESQA-Log-" & GetUserName & ".txt"
  End If
End Sub

Sub LogPrint(ByVal str As String, Optional ByVal dur As Double = 0)
  If G_LogEnabled Then
    If G_cfgLogpfad = "" Then
      AddTextToFile Now() & "; " & Chr(34) & str & Chr(34), ThisWorkbook.path & "\ESQA-Log-" & GetUserName & ".txt"
    Else
      AddTextToFile Now() & "; " & Chr(34) & str & Chr(34), G_cfgLogpfad & "\ESQA-Log-" & GetUserName & ".txt"
    End If
  End If
End Sub

Public Function AddTextToFile(ByVal strData As String, _
     ByVal FullPath As String, _
       Optional ByVal ErrInfo As String = "") As Boolean

    Dim fn As Long
    fn = FreeFile
    Dim s As String

GoAgain:

    On Error GoTo CatchEx

    Open FullPath For Append As fn
    Print #fn, strData
    Close fn

    AddTextToFile = True
    Exit Function

CatchEx:
    Sleep 100
    GoTo GoAgain
End Function

Function ConvGermanDateKey(d As String) As String
    Dim sp() As String
    sp = Split(d, ".")
    If UBound(sp) - LBound(sp) + 1 = 3 Then
        ConvGermanDateKey = DateSerial(CInt(sp(2)), CInt(sp(1)), CInt(sp(0)))
    Else
        ConvGermanDateKey = d
    End If
End Function

Function ConvGermanDate(d As String) As Date
    Dim td As Date
    
    On Error GoTo errorEnd
    td = DateSerial(1900, 1, 1)
    
    If IsDate(d) Then
        td = CDate(d)
    Else
      Dim dots As Long
      Dim pos1 As Long
      Dim pos2 As Long
      Dim endPos As Long
      
      dots = 0
      
      pos1 = InStr(d, ".")
      If pos1 > 0 Then
          dots = dots + 1
          
          pos2 = InStr(pos1 + 1, d, ".")
          If pos2 > 0 Then
              dots = dots + 1
              endPos = InStr(pos2 + 1, d, " ")
              If endPos <= 0 Then endPos = Len(d) + 1
          End If
      End If
      
      If dots = 2 Then
          Dim day As String
          Dim month As String
          Dim year As String
          day = Mid(d, 1, pos1 - 1)
          month = Mid(d, pos1 + 1, pos2 - pos1 - 1)
          year = Mid(d, pos2 + 1, endPos - pos2 - 1)
          td = DateSerial(year, month, day) & IIf(CDate(d) <> DateSerial(year, month, day), " " & Hour(d) & ":" & Minute(d) & ":" & Second(d), "")
      End If
    End If
    
    If td < DateSerial(1900, 1, 1) Then
      td = DateSerial(1900, 1, 1) & " " & Hour(d) & ":" & Minute(d) & ":" & Second(d)
    End If
    
errorEnd:
    ConvGermanDate = td
End Function

Function GetUserName() As String

   ' Buffer size for the return string.
   Const lpnLength As Integer = 255

   ' Get return buffer space.
   Dim status As Integer

   ' For getting user information.
   Dim lpName, lpUserName As String

   ' Assign the buffer size constant to lpUserName.
   lpUserName = Space$(lpnLength + 1)

   ' Get the log-on name of the person using product.
   status = WNetGetUser(lpName, lpUserName, lpnLength)

   ' See whether error occurred.
   If status = NoError Then
      ' This line removes the null character. Strings in C are null-
      ' terminated. Strings in Visual Basic are not null-terminated.
      ' The null character must be removed from the C strings to be used
      ' cleanly in Visual Basic.
      lpUserName = Left$(lpUserName, InStr(lpUserName, Chr(0)) - 1)
   Else

      ' An error occurred.
'         MsgBox "Unable to get the name."
      'lpUserName = "Unbekannt"
      lpUserName = FMT0("HELPERS_15")
   End If

   ' Display the name of the person logged on to the machine.
'      MsgBox "The person logged on this machine is: " & lpUserName

    GetUserName = lpUserName

End Function

Function GetRelativePath(ByVal stdpath As String, ByVal cfgpath As String) As String
  Dim s As String
  If cfgpath = "" Then s = stdpath
  
  If cfgpath = "USERTEMP" Then
    cfgpath = GetTempPath
    If Right(cfgpath, 1) = "\" Then
      cfgpath = Left(cfgpath, Len(cfgpath) - 1)
    End If
  End If
  
  If Left(cfgpath, 2) = "\\" Or Left(cfgpath, 2) = "//" Or Mid(cfgpath, 2, 1) = ":" Then
    s = cfgpath
  Else
    s = ThisWorkbook.path & "\" & cfgpath
  End If
  
  If Not PathExists(s) Then
    MkFullDir s
    If Not PathExists(s) Then
'      If Not StartedByTracker Then
'        MsgBox "ACHTUNG: Der Pfad '" & s & "' konnte nicht erzeugt werden. Das Programm wird voraussichtlich nicht korrekt funktionieren. Bitte gew|fffd|hrleisten Sie, dass der Pfad existiert!", vbCritical
'      Else
        'AddStatus "ACHTUNG: Der Pfad '" & s & "' konnte nicht erzeugt werden."
        AddStatus FMT1("HELPERS_16", s)
'      End If
    End If
  End If
  
  GetRelativePath = s
End Function

Function PathExists(Dateiname$) As Boolean
  On Error GoTo fehler:
  Dim b As Boolean
  
  b = Dir$(Dateiname, vbDirectory) <> ""
  If Not b Then
    b = Dir$(Dateiname & "\", vbDirectory) <> ""
  End If
  PathExists = b
  Exit Function
fehler:
    PathExists = False
    Resume Next
End Function

Sub MkFullDir(ByVal p As String)
  On Error Resume Next
  Dim pos As Long
  pos = 4
  Do
    pos = InStr(pos, p, "\")
    If pos > 0 Then
      MkDir Left(p, pos - 1)
    Else
      MkDir p
      Exit Sub
    End If
    pos = pos + 1
  Loop While pos > 0
End Sub

Function GetNextText(s As String, ByRef pos As Long) As String
  If Len(s) > 0 And pos > 0 Then
    Dim lastpos As Long
    lastpos = pos
      
    pos = InStr(pos, s, ",")
    If pos > 0 Then
      
      GetNextText = Trim(Mid(s, lastpos, pos - lastpos))
      pos = pos + 1
      Exit Function
    ElseIf lastpos <= Len(s) Then
      GetNextText = Trim(Mid(s, lastpos))
      pos = Len(s) + 1
      Exit Function
    Else
      pos = -1
      GetNextText = ""
      Exit Function
    End If
  Else
    pos = -1
    GetNextText = ""
    Exit Function
  End If

End Function

Function ControlExists(ByRef bar, ctrlName As String) As Boolean
  On Error GoTo nogo
  
  Dim a
  Set a = Application.CommandBars("Worksheet Menu Bar").Controls("ESQA").Controls(ctrlName)
  Set a = Nothing
  ControlExists = True
  Exit Function
nogo:
End Function

Sub MyKill(fname As String)
On Error Resume Next
  Kill fname
End Sub

' Return the short file name for a long file name.
Public Function ShortFileName(ByVal long_name As String) As String
    If UCase(Left(long_name, 5)) = "HTTP:" Or UCase(Left(long_name, 6)) = "HTTPS:" Then
      ShortFileName = long_name
      Exit Function
    End If
    
    'Returns the short filename associated w
    '     ith sLongFilename
    Dim lRet As Long
    Dim sShortFilename As String
    'First attempt using 1024 character buff
    '     er.
    sShortFilename = String$(1024, " ")
    lRet = GetShortPathName(long_name, sShortFilename, Len(sShortFilename))
    
    'If buffer is too small lRet contains bu
    '     ffer size needed.


    If lRet > Len(sShortFilename) Then
        'Increase buffer size...
        sShortFilename = String$(lRet + 1, " ")
        'and try again.
        lRet = GetShortPathName(long_name, sShortFilename, Len(sShortFilename))
    End If
    
    'lRet contains the number of characters
    '     returned.


    If lRet > 0 Then
        ShortFileName = Left$(sShortFilename, lRet)
    End If
    
    If Trim(ShortFileName) = "" Then
      ShortFileName = long_name
    End If
    
End Function

Sub OpenFileWithApp(fname As String)
  If FileExists(fname) Then
    Dim s2 As String, s3 As String, n As Long
    
    s2 = AnwendungFuerDatei(fname)
    If "" <> s2 Then
       s3 = Chr(34) & ShortFileName(s2) & Chr(34) & " " & Chr(34) & ShortFileName(fname) & Chr(34)
       n = Shell(s3, vbNormalFocus)
    Else
       'MsgBox "Anwendungprogramm f|fffd|r " & fname & " nicht gefunden/installiert!"
       MsgBox FMT1("HELPERS_17", fname)
    End If
  Else
    'MsgBox "Datei '" & fname & "' nicht vorhanden.", vbCritical
    MsgBox FMT1("HELPERS_18", fname), vbCritical
  End If
End Sub


Public Function AnwendungFuerDatei(ByVal a_Datei As String) As String
  'Datei: Pfad + Dateinamen einer existierenden Datei
  Dim Pfad As String * 255
  
  Call FindExecutable(a_Datei, vbNullString, Pfad)
  
  If "" <> Trim(Pfad) Then
     Pfad = Trim(Left(Pfad, InStr(Pfad, vbNullChar) - 1))
  End If
  AnwendungFuerDatei = Trim(Pfad)
End Function

Public Sub DisableExcelNoStore()
  Application.EnableEvents = False
  Application.ScreenUpdating = False
  Application.Calculation = xlCalculationManual
  
End Sub

Public Sub DisableExcel(ByRef calc As Long, ByRef bEnableEvents As Boolean, ByRef bScreenUpdating As Boolean)
  calc = Application.Calculation
  bEnableEvents = Application.EnableEvents
  bScreenUpdating = Application.ScreenUpdating
  
  Application.EnableEvents = False
  Application.ScreenUpdating = False
  Application.Calculation = xlCalculationManual
  
End Sub

Public Sub EnableExcel(ByVal calc As Long, ByVal bEnableEvents As Boolean, ByVal bScreenUpdating As Boolean)
  Application.Calculation = calc
  Application.EnableEvents = bEnableEvents
  Application.ScreenUpdating = bScreenUpdating
End Sub

Function MyFileLen(ByVal fname As String) As Long
  On Error GoTo nogo:
  MyFileLen = 0
  If UCase(Left(fname, 5)) = "HTTP:" Or UCase(Left(fname, 6)) = "HTTPS:" Then
    Dim sz As Long
    Dim modDate As Date
    If URLExists(fname, sz, modDate) Then
      MyFileLen = sz
    End If
  Else
    MyFileLen = FileLen(fname)
  End If
  Exit Function
nogo:
End Function

Function MyFileDateTime(ByVal fname As String) As Date
  MyFileDateTime = 0
  On Error GoTo nogo
  If UCase(Left(fname, 5)) = "HTTP:" Or UCase(Left(fname, 6)) = "HTTPS:" Then
    Dim sz As Long
    Dim modDate As Date
    If URLExists(fname, sz, modDate) Then
      MyFileDateTime = modDate
    End If
  Else
    MyFileDateTime = FileDateTime(fname)
  End If
  Exit Function
nogo:
  If Len(fname) > 260 Then
     MyFileDateTime = MyFileDateTimeLongName(fname)
  Else
    ' DebugPrint tdebug, "MyFileDateTime failed for: '" & fname & "' - " & Err.Number & " - " & Err.Description
  End If
End Function

Function MyFileDateTimeLongName(fname As String) As Date
On Error GoTo nogo
    If Len(fname) > 260 Then
        fname = "\\?\UNC\" & Mid$(fname, 3)
    End If
    
    Dim fs
    Dim f
    Set fs = CreateObject("Scripting.FileSystemObject")
    Set f = fs.GetFile(fname)
    
    MyFileDateTimeLongName = f.DateLastModified
    Exit Function
nogo:
    ' DebugPrint tdebug, "MyFileDateTimeLongName failed for: '" & fname & "' - " & Err.Number & " - " & Err.Description
    MyFileDateTimeLongName = 0
End Function

Function LoadedAsAddin() As Boolean
  LoadedAsAddin = False
  Dim oAddIN As AddIn, vAd As String
  On Error GoTo fehler
  For Each oAddIN In Application.AddIns
    If UCase(oAddIN.name) = "EXCEL-SHEET-QA.XLA" Then
      If oAddIN.Installed = True Then
        LoadedAsAddin = True
        Exit Function
      End If
    End If
  Next oAddIN
  Exit Function
fehler:
End Function

Function GetExcelVersion() As Long
  GetExcelVersion = 0
  On Error Resume Next
  ' >= 12 = Excel 2007
  GetExcelVersion = CLng(Val(Application.Version))
End Function


Public Function CollectionStringExists(c As Collection, name As String) As Boolean
  On Error GoTo notReadable
  Dim s
  s = c(name)
  CollectionStringExists = True
  Exit Function
  
notReadable:
  CollectionStringExists = False
End Function


Attribute VB_Name = "HighResTimer"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

#If VBA7 Then
Private Declare PtrSafe Function QueryPerformanceCounter Lib "kernel32" _
                                 (x As Currency) As Boolean
Private Declare PtrSafe Function QueryPerformanceFrequency Lib "kernel32" _
                                 (x As Currency) As Boolean
      
Private Declare PtrSafe Function timeGetTime Lib "winmm.dll" () As Long

#Else

Private Declare Function QueryPerformanceCounter Lib "kernel32" _
                                 (x As Currency) As Boolean
Private Declare Function QueryPerformanceFrequency Lib "kernel32" _
                                 (x As Currency) As Boolean
      
Private Declare Function timeGetTime Lib "winmm.dll" () As Long

#End If



Enum TimeState
    started
    Stopped
End Enum


Private startTime, endTime As Long
Private dur As Double
Private state As Currency
Private m_TimeCol As Collection
Private m_TimeName As Collection
Private m_TotalTimeCol As Collection

Private m_LastCount As String

Private Sub Class_Initialize()
Static started As Boolean
    If started Then
      'MsgBox "HighResTimer already started!"
      MsgBox FMT0("HRT_1")
      Exit Sub
    End If
    started = True
    state = TimeState.Stopped
    DoStart

    StartCounting "TotalCount"

End Sub

Private Sub Class_Terminate()
    DoStop
    Set m_TimeCol = Nothing
    Set m_TotalTimeCol = Nothing
    Set m_TimeName = Nothing
    
End Sub

Public Sub StartCounting(s As String)
  
'  If m_LastCount <> "" Then
'    Dim d As Double
'    d = m_TotalTimeCol(m_LastCount) + CDbl(timeGetTime() - m_TimeCol(m_LastCount))
'    m_TotalTimeCol.Remove m_LastCount
'    m_TotalTimeCol.Add d, m_LastCount
'  End If
  
  
  If CollectionItemExists(m_TimeCol, s) Then
    m_TimeCol.Remove s
  End If
  m_TimeCol.Add timeGetTime(), s
  If Not CollectionItemExists(m_TotalTimeCol, s) Then
    m_TotalTimeCol.Add 0#, s
  End If
  If Not CollectionItemExists(m_TimeName, s) Then
    m_TimeName.Add s, s
  End If
End Sub
Public Sub StopCounting(s As String)
  If Not CollectionItemExists(m_TimeCol, s) Then
    'MsgBox "No count for: " & s
    MsgBox FMT1("HRT_2", s)
    Exit Sub
  End If

  Dim d As Double
  d = m_TotalTimeCol(s) + CDbl(timeGetTime() - m_TimeCol(s))
  m_TotalTimeCol.Remove s
  m_TotalTimeCol.Add d, s
  
  'm_LastCount = s & " - After"
'  m_LastCount = FMT1("HRT_3", s)
  
'  If CollectionItemExists(m_TimeCol, m_LastCount) Then
'    m_TimeCol.Remove m_LastCount
'  End If
'  m_TimeCol.Add timeGetTime(), m_LastCount
'  If Not CollectionItemExists(m_TotalTimeCol, m_LastCount) Then
'    m_TotalTimeCol.Add 0#, m_LastCount
'  End If
'  If Not CollectionItemExists(m_TimeName, m_LastCount) Then
'    m_TimeName.Add m_LastCount, m_LastCount
'  End If
  
  

End Sub

Function GetCount(s As String) As Double
  If Not CollectionItemExists(m_TotalTimeCol, s) Then
    'MsgBox "No count for: " & s
    MsgBox FMT1("HRT_4", s)
    Exit Function
  End If
  
  GetCount = m_TotalTimeCol(s) / 1000
End Function


Private Sub DoStart()
    If state = TimeState.started Then
        'MsgBox "Cant' start, already started", vbCritical + vbSystemModal, ProgNameLong & " " & MyVersion
        MsgBox FMT0("HRT_5"), vbCritical + vbSystemModal, ProgNameLong & " " & MyVersion
        Exit Sub
    End If
    state = TimeState.started
    startTime = timeGetTime()
    Set m_TimeCol = New Collection
    Set m_TotalTimeCol = New Collection
    Set m_TimeName = New Collection
End Sub

Private Function DoStop() As Double
    endTime = timeGetTime()
    If state = TimeState.Stopped Then
        'MsgBox "Cant' start, already started", vbCritical + vbSystemModal, ProgNameLong & " " & MyVersion
        MsgBox FMT0("HRT_5"), vbCritical + vbSystemModal, ProgNameLong & " " & MyVersion
        Exit Function
    End If
    state = TimeState.Stopped
    dur = CDbl((endTime - startTime) / 1000)
    DoStop = dur
End Function


Public Sub Dump()
  Dim s As String
  Dim i As Long
  Dim ts As String
  
  StopCounting "TotalCount"
  ts = ""
  
  Dim tot As Double
  tot = GetCount("TotalCount")
  
  Dim checked As Double
  checked = 0
  
  If m_TimeName.Count > 0 Then
    For i = 1 To m_TimeName.Count
      s = m_TimeName(i)
      ts = ts & s & ":" & IIf(Len(s) < 8, vbTab, "") & IIf(Len(s) < 16, vbTab, "") & IIf(Len(s) < 22, vbTab, "") & IIf(Len(s) < 30, vbTab, "") & vbTab & Format(GetCount(s), "000.00") & " Sec" & vbTab & Format(GetCount(s) / tot, "00.0%") & vbCrLf
      Debug.Print s & ": " & GetCount(s) & " Sec - " & Format(GetCount(s) / tot, "0.0%")
      checked = checked + GetCount(s)
    Next i
  End If
  
  'ts = ts & vbCrLf & "Checked: " & Format((checked - tot) / tot, "0.0%")
  ts = ts & vbCrLf & FMT0("HRT_6") & Format((checked - tot) / tot, "0.0%")
 
  MyKill ThisWorkbook.path & "\ECC-Profile.txt"
  AddTextToFile ts, ThisWorkbook.path & "\ECC-Profile.txt"
  
End Sub
Function GetCurrentCount(s As String) As Double
  If Not CollectionItemExists(m_TotalTimeCol, s) Then
    MsgBox "No count for: " & s
    Exit Function
  End If
  GetCurrentCount = (m_TotalTimeCol(s) + CDbl(timeGetTime() - m_TimeCol(s))) / 1000
End Function


Attribute VB_Name = "INetUpdate"
Attribute VB_Base = "0{B1C2E08A-4925-46EB-9D8D-00FB530EF1DB}{2244D08C-4002-4903-AEFE-013232345838}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Sub cmdAbbrechen_Click()
  Me.Hide
End Sub

Private Sub cmdDownload_Click()
  Me.Hide
  On Error Resume Next
  Call Shell("explorer.exe " & G_UpdateString, 1)
  
#If EXCELSHEETQADLL <> 1 Then
  ThisWorkbook.Close False
#End If
End Sub

Private Sub UserForm_Initialize()
  gTranslation.TranslateForm Me
End Sub
Attribute VB_Name = "InetCheckVersion"
Option Explicit

'Declares for direct ping
#If VBA7 Then
Private Declare PtrSafe Function InternetOpen Lib "wininet.dll" Alias "InternetOpenA" (ByVal lpszAgent As String, ByVal dwAccessType As Long, ByVal lpszProxyName As String, ByVal lpszProxyBypass As String, ByVal dwFlags As Long) As Long
Private Declare PtrSafe Function InternetOpenUrl Lib "wininet.dll" Alias "InternetOpenUrlA" (ByVal hInet As Long, ByVal lpszUrl As String, ByVal lpszHeaders As String, ByVal dwHeadersLength As Long, ByVal dwFlags As Long, ByVal dwContext As Long) As Long
Private Declare PtrSafe Function InternetCloseHandle Lib "wininet.dll" (ByVal hInet As Long) As Long
Private Declare PtrSafe Function InternetReadFile Lib "wininet.dll" _
    (ByVal hFile As Long, ByVal sBuffer As String, ByVal lNumBytesToRead As Long, _
    lNumberOfBytesRead As Long) As Integer
Private Declare PtrSafe Function InternetGetLastResponseInfo Lib "wininet.dll" Alias "InternetGetLastResponseInfoA" _
    (lpdwError As Long, ByVal lpszBuffer As String, ByVal lpdwBufferLength As Long) As Integer
#Else
Private Declare Function InternetOpen Lib "wininet.dll" Alias "InternetOpenA" (ByVal lpszAgent As String, ByVal dwAccessType As Long, ByVal lpszProxyName As String, ByVal lpszProxyBypass As String, ByVal dwFlags As Long) As Long
Private Declare Function InternetOpenUrl Lib "wininet.dll" Alias "InternetOpenUrlA" (ByVal hInet As Long, ByVal lpszUrl As String, ByVal lpszHeaders As String, ByVal dwHeadersLength As Long, ByVal dwFlags As Long, ByVal dwContext As Long) As Long
Private Declare Function InternetCloseHandle Lib "wininet.dll" (ByVal hInet As Long) As Long
Private Declare Function InternetReadFile Lib "wininet.dll" _
    (ByVal hFile As Long, ByVal sBuffer As String, ByVal lNumBytesToRead As Long, _
    lNumberOfBytesRead As Long) As Integer
Private Declare Function InternetGetLastResponseInfo Lib "wininet.dll" Alias "InternetGetLastResponseInfoA" _
    (lpdwError As Long, ByVal lpszBuffer As String, ByVal lpdwBufferLength As Long) As Integer
#End If

Private Const INTERNET_OPEN_TYPE_PRECONFIG = 0
Private Const INTERNET_FLAG_RELOAD = &H80000000
Private Const INTERNET_FLAG_KEEP_CONNECTION = &H400000
Private Const INTERNET_FLAG_NO_CACHE_WRITE = &H4000000

Dim hInet As Long
Dim hUrl As Long
Dim Flags As Long
Dim url As Variant


Public Function CheckINetConnection() As Boolean
  hInet = InternetOpen(" ", INTERNET_OPEN_TYPE_PRECONFIG, vbNullString, vbNullString, 0&)
  If hInet Then
    Flags = INTERNET_FLAG_KEEP_CONNECTION Or INTERNET_FLAG_NO_CACHE_WRITE Or INTERNET_FLAG_RELOAD
    hUrl = InternetOpenUrl(hInet, "http://www.stromwerke.de", vbNullString, 0, Flags, 0)
    If hUrl Then
        CheckINetConnection = True
        Call InternetCloseHandle(hUrl)
      Else
        CheckINetConnection = False
      End If
   End If
   Call InternetCloseHandle(hInet)
End Function

Public Sub CheckVersion(checkEveryDays As Long, sec As String, fname As String, fname2 As String, currentVersion As String, internalCurrentVersion As Long)

On Error GoTo exitfunc

  'G_InternetVersion = "Nicht verbunden"
  G_InternetVersion = FMT0("INET_1")
  G_InternetAvailable = False
  G_UpdateAvailable = False

  Dim d As Date
 
  SaveSetting _
     appname:="Stromwerken", _
     Section:=sec, _
     Key:="VersionDate", _
     Setting:=Now
     
     
  Dim Ret As String
  Dim ret2 As String
  
     
  If LoadInetFile(fname, Ret) = True And LoadInetFile(fname2, ret2) = True Then
  
        Dim pos As Long
        pos = InStr(Ret, ",")
        Dim pos2 As Long
        pos2 = InStr(Ret, "|")
        
        Dim pos3 As Long
        pos3 = InStr(Ret, vbCr)
        
        Dim pos4 As Long
        pos4 = InStr(ret2, vbCr)
        
        G_InternetLicenseVersion = CLng(Left(ret2, pos4 - 1))
        G_UpdateText = Mid(ret2, pos4 + 2)
        
        If pos2 > 0 Then
          If pos > 0 Then
            
            G_InternetVersion = Left(Ret, pos2 - 1)
              
            G_InternetAvailable = True
            If pos3 > 0 Then
              G_UpdateString = Mid(Ret, pos + 1, pos3 - pos - 1)
            Else
              G_UpdateString = Mid(Ret, pos + 1)
            End If
            G_InternetInternalVersion = CLng(Mid(Ret, pos2 + 1, pos - pos2 - 1))
              
            If internalCurrentVersion < CLng(Mid(Ret, pos2 + 1, pos - pos2 - 1)) Then
            
              G_UpdateAvailable = True
              
              d = GetSetting( _
                 appname:="Stromwerken", _
                 Section:=sec, _
                 Key:="VersionDate", Default:=DateSerial(2000, 1, 1))
              
              If DateAdd("d", checkEveryDays, d) <= Now Then
                CheckInternetUpdateMenu
              End If
              
            End If
          End If
        End If
        
  End If
  Exit Sub

exitfunc:
  Exit Sub
  
End Sub

Function DoThat(t As String) As String

    Dim i As Long
    Dim s2 As String
    For i = 1 To Len(t)
        If Mid(t, i, 1) = "@" Then
            s2 = s2 + vbLf
        ElseIf Mid(t, i, 1) = "^" Then
            s2 = s2 + " "
        ElseIf Mid(t, i, 1) >= "0" And Mid(t, i, 1) <= "9" Then
          s2 = s2 + Chr(Asc("0") + Asc("9") - Asc(Mid(t, i, 1)))
        ElseIf Mid(t, i, 1) >= "a" And Mid(t, i, 1) <= "z" Then
          s2 = s2 + Chr(Asc("a") + Asc("z") - Asc(Mid(t, i, 1)))
        ElseIf Mid(t, i, 1) >= "A" And Mid(t, i, 1) <= "Z" Then
          s2 = s2 + Chr(Asc("A") + Asc("Z") - Asc(Mid(t, i, 1)))
        Else
            s2 = s2 + Mid(t, i, 1)
        End If
    Next i
    
    DoThat = s2
End Function



Function GetSWResItem(ByVal pos As Long, ff As Long) As String
  Dim res As String
  
  If FileExists(ThisWorkbook.path & "\swres.swk") Then
    Open ThisWorkbook.path & "\swres.swk" For Binary Access Read As #ff ' Len = 4
  ElseIf FileExists(G_cfgKeypfad & "\swres.swk") Then
    Open G_cfgKeypfad & "\swres.swk" For Binary Access Read As #ff ' Len = 4
  Else
    Exit Function
  End If
  
  
  Dim l As Long
  Get #ff, pos, l

  Dim charc As Long

  ' ENC2
  If l = 1 Then
    Get #ff, pos + 4, l
  
  
  '  Close ff
  '  Open AktVerz & "\swres.swk" For Binary Access Read As #ff ' Len = 1
    For charc = 1 To l
      Dim tchar As Byte
      Get #ff, pos + 7 + charc, tchar
      tchar = tchar Xor (1 + 2 + 4 + 16 + 64)
      res = res & Chr(tchar)
    Next charc
    Close ff
    Do
      pos = InStr(res, "\n")
      If pos <= 0 Then Exit Do
      res = Left(res, pos - 1) & vbCrLf & Mid(res, pos + 2)
    Loop
    GetSWResItem = res
  
  ' ENC3 - LZW
  ElseIf l = 2 Then
    Get #ff, pos + 4, l
  
  '  Close ff
  '  Open AktVerz & "\swres.swk" For Binary Access Read As #ff ' Len = 1
    Dim lval As Long
    Dim arr() As Long
    ReDim arr(l)
    
    For charc = 1 To l
      Get #ff, pos + 4 + charc * 4, lval
      arr(charc - 1) = lval
    Next charc
    Close ff
    
    Dim LZW As New LZW
    res = LZW.DecompressArray(l, arr)
    Set LZW = Nothing
    
    Do
      pos = InStr(res, "\n")
      If pos <= 0 Then Exit Do
      res = Left(res, pos - 1) & vbCrLf & Mid(res, pos + 2)
    Loop
    GetSWResItem = res
  End If
End Function

Sub GetData()
  On Error GoTo noData
  
  If FileExists(G_cfgKeypfad & "\swres.swk") Or FileExists(ThisWorkbook.path & "\swres.swk") Then
  
    Dim newKeyFile As String
    Dim fname As String
    If FileExists(ThisWorkbook.path & "\swres.swk") Then
      fname = ThisWorkbook.path & "\swres.swk"
    ElseIf FileExists(G_cfgKeypfad & "\swres.swk") Then
      fname = G_cfgKeypfad & "\swres.swk"
    End If
    
    If MyFileLen(fname) <= 64000 Then
      newKeyFile = False
    Else
      newKeyFile = True
    End If
  
    Dim ff As Long
    ff = FreeFile
    Dim s As String
    
    If newKeyFile Then
      s = GetSWResItem(1000, ff)
      If InStr(s, "ESQA,") > 0 Or InStr(s, "ESQAPRO,") > 0 Then
        G_Lizenzen = Val(GetSWResItem(5500, ff))
        G_Lizenznehmer = GetSWResItem(2000, ff)
        G_LizenznehmerAdresse = GetSWResItem(2400, ff)
        G_MyLicencseVersion = Val(GetSWResItem(5400, ff))
      
        s = ConvGermanDateKey(GetSWResItem(5600, ff))
        If Len(s) > 0 Then
          If IsDate(s) Then
            If CDate(s) > #1/1/1900# Then
              G_FullDemoBis = CDate(s)
            End If
          End If
        End If
        'G_Wartung = IIf(UCase(GetSWResItem(5700, ff)) = "JA", True, False)
        G_Wartung = IIf(IsYes(GetSWResItem(5700, ff)), True, False)
        
        If G_Wartung Then
          ' s = GetSWResItem(3400, ff)
          s = ConvGermanDateKey(GetSWResItem(5800, ff))
          If Len(s) > 0 Then
            If IsDate(s) Then
              G_WartungBis = CDate(s)
            End If
          End If
        End If
        
        FullVersion = True
        
        If G_Lizenzen = -1 Then
          'trs = "Full-Demo" & vbCrLf & vbCrLf & G_Lizenznehmer & vbCrLf & G_LizenznehmerAdresse & vbCrLf & vbCrLf & "Einsatz nur zu Testzwecken!"
          trs = FMT2("INET_2", G_Lizenznehmer, G_LizenznehmerAdresse)
          'trsShrt = "Full-Demo " & G_Lizenznehmer & " - Einsatz nur zu Testzwecken!"
          trsShrt = FMT1("INET_3", G_Lizenznehmer)
        ElseIf G_Lizenzen = 0 And Now < G_FullDemoBis Then
          'trs = "Full-Demo bis zum " & G_FullDemoBis & vbCrLf & vbCrLf & G_Lizenznehmer & vbCrLf & vbCrLf & G_LizenznehmerAdresse
          trs = FMT3("INET_4", G_FullDemoBis, G_Lizenznehmer, G_LizenznehmerAdresse)
          'trsShrt = "Full-Demo bis zum " & G_FullDemoBis & " - " & G_Lizenznehmer
          trsShrt = FMT2("INET_5", G_FullDemoBis, G_Lizenznehmer)
        ElseIf G_Lizenzen = 0 And Now >= G_FullDemoBis Then
          'trs = "Demoversion" & vbCrLf & vbCrLf & G_Lizenznehmer & vbCrLf & vbCrLf & G_LizenznehmerAdresse
          trs = FMT2("INET_6", G_Lizenznehmer, G_LizenznehmerAdresse)
          'trsShrt = "Demoversion " & G_Lizenznehmer
          trsShrt = FMT1("INET_7", G_Lizenznehmer)
        ElseIf G_Lizenzen = -2 Then
          'trs = "Gesamthauslizenz" & vbCrLf & vbCrLf & G_Lizenznehmer & vbCrLf & vbCrLf & G_LizenznehmerAdresse
          trs = FMT2("INET_8", G_Lizenznehmer, G_LizenznehmerAdresse)
          'trsShrt = "Gesamthauslizenz " & G_Lizenznehmer
          trsShrt = FMT1("INET_9", G_Lizenznehmer)
        ElseIf G_Lizenzen = 1 Then
          'trs = G_Lizenzen & " Lizenz" & vbCrLf & vbCrLf & G_Lizenznehmer & vbCrLf & vbCrLf & G_LizenznehmerAdresse
          trs = FMT3("INET_10", G_Lizenzen, G_Lizenznehmer, G_LizenznehmerAdresse)
          'trsShrt = G_Lizenzen & "Lizenz " & G_Lizenznehmer
          trsShrt = FMT2("INET_11", G_Lizenzen, G_Lizenznehmer)
        Else
          'trs = G_Lizenzen & " Lizenzen" & vbCrLf & vbCrLf & G_Lizenznehmer & vbCrLf & vbCrLf & G_LizenznehmerAdresse
          trs = FMT3("INET_12", G_Lizenzen, G_Lizenznehmer, G_LizenznehmerAdresse)
          'trsShrt = G_Lizenzen & "Lizenzen " & G_Lizenznehmer
          trsShrt = FMT2("INET_13", G_Lizenzen, G_Lizenznehmer)
        End If
        
        If G_Wartung Then
          'trs = trs & vbCrLf & vbCrLf & IIf(G_WartungBis <> 0, "Wartung bis: " & G_WartungBis & IIf(Now > G_WartungBis, " (ABGELAUFEN)", ""), "")
          trs = trs & vbCrLf & vbCrLf & IIf(G_WartungBis <> 0, FMT1("INET_14", G_WartungBis) & IIf(Now > G_WartungBis, FMT0("INET_15"), ""), "")
        End If
        Exit Sub
      
      End If
    Else
      s = GetSWResItem(1000, ff)
      If s = "ESQA" Then
        G_Lizenzen = Val(GetSWResItem(1800, ff))
        G_Lizenznehmer = GetSWResItem(2000, ff)
        G_LizenznehmerAdresse = GetSWResItem(2400, ff)
        G_MyLicencseVersion = Val(GetSWResItem(3000, ff))
        FullVersion = True
        
        'trs = IIf(G_Lizenzen = 1, G_Lizenzen & " Lizenz", G_Lizenzen & " Lizenzen") & vbCrLf & vbCrLf & G_Lizenznehmer & vbCrLf & vbCrLf & G_LizenznehmerAdresse
        trs = IIf(G_Lizenzen = 1, G_Lizenzen & FMT0("INET_16"), G_Lizenzen & FMT0("INET_17")) & vbCrLf & vbCrLf & G_Lizenznehmer & vbCrLf & vbCrLf & G_LizenznehmerAdresse
        
        Exit Sub
      End If
    End If
  End If
  
  Exit Sub
noData:
  Exit Sub
End Sub



Sub CheckInternetUpdateMenu()


  If G_MyLicencseVersion < G_InternetLicenseVersion And FullVersion = True Then
    'INetUpdate.Headline.Caption = "Im Internet liegt eine neue Version des Programms vor."
    INetUpdate.Headline.Caption = FMT0("INET_18")
    'INetUpdate.Kostenpflichtig.Caption = "Die neue Version ist kostenpflichtig. Bitte wenden Sie sich an info@stromwerken.de, um eine Update-Lizenz zu erwerben. Ohne neuen Lizenz-Key l|fffd|uft das Programm befristet bis zum " & MyFreeUsage & " als Vollversion und danach als DEMO!"
    INetUpdate.Kostenpflichtig.Caption = FMT1("INET_19", MyFreeUsage)
  Else
    'INetUpdate.Headline.Caption = "Im Internet liegt eine neue Version des Programms vor."
    INetUpdate.Headline.Caption = FMT0("INET_18")
    INetUpdate.Kostenpflichtig.Caption = ""
  End If
  
  INetUpdate.UpdateText = G_UpdateText
  
  INetUpdate.Show
End Sub



Public Function LoadInetFile(fname As String, ByRef Ret As String, Optional fsize As Long = 0) As Boolean
  Dim hInet As Long
  Dim hUrl As Long
  Dim Flags As Long
  Dim url As Variant
  
  LoadInetFile = False
  
  hInet = InternetOpen(" ", INTERNET_OPEN_TYPE_PRECONFIG, vbNullString, vbNullString, 0&)
  If hInet Then
    Flags = INTERNET_FLAG_KEEP_CONNECTION Or INTERNET_FLAG_NO_CACHE_WRITE Or INTERNET_FLAG_RELOAD
    hUrl = InternetOpenUrl(hInet, "http://www.stromwerken.de/" & fname, vbNullString, 0, Flags, 0)
    If hUrl Then
        
        Dim sReadBuf As String * 1024
        Dim flagMoreData As Boolean
        Dim bytesRead As Long
        Dim wRet As Integer
        Dim lastErr As Long
        Dim s As String
        
        flagMoreData = True
        Do While flagMoreData
            sReadBuf = vbNullString
            wRet = InternetReadFile(hUrl, sReadBuf, Len(sReadBuf), bytesRead)
            If Err.LastDllError <> 0 Then
                lastErr = Err.LastDllError
                'Ret = "Error (wininet.dll," & lastErr & ")"
                Ret = FMT1("INET_20", lastErr)
                GoTo exitfunc
            End If
            If wRet <> 1 Then
                'Ret = "Error"
                Ret = FMT0("INET_21")
                GoTo exitfunc
            End If
            s = s & Left$(sReadBuf, bytesRead)
            If Not CBool(bytesRead) Then flagMoreData = False
        Loop
        Ret = s
        
        Call InternetCloseHandle(hUrl)
        Call InternetCloseHandle(hInet)
        LoadInetFile = True
        Exit Function
    Else
      Call InternetCloseHandle(hInet)
    End If
  End If
  Exit Function

exitfunc:
    If hUrl <> 0 Then InternetCloseHandle (hUrl)
    If hInet <> 0 Then InternetCloseHandle (hInet)
End Function

Attribute VB_Name = "LZW"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

'Private Data Members
Private flgFirstTime As Boolean
Private arr() As String
Private m_CharacterBytesCount As Integer


'Properties
Public Property Get CharacterBytesCount() As Integer
    CharacterBytesCount = m_CharacterBytesCount
End Property

Public Property Let CharacterBytesCount(ByVal vNewValue As Integer)
    m_CharacterBytesCount = vNewValue
End Property

'Private Methods
Private Function Add(ByVal Entry As String) As Long

   If flgFirstTime Then
        flgFirstTime = False
    Else
        ReDim Preserve arr(UBound(arr) + 1)
    End If
    
    arr(UBound(arr)) = Entry
    'Arr(UBound(Arr)).Code = ubund(
    
    Add = UBound(arr)
    
End Function

Private Function IsExists(ByVal Entry As String) As Boolean
    Dim i As Long
    Dim flg As Boolean
    flg = False
    
    For i = LBound(arr) To UBound(arr)
        If arr(i) = Entry Then
            flg = True
            Exit For
        End If
    Next i
    
    IsExists = flg
    
End Function

Private Function IsIndexExists(ByVal index As Long) As Boolean
    
    Dim flg As Boolean
    flg = False
    
    If index <= UBound(arr) Then
        flg = True
    Else
        flg = False
    End If
    
    IsIndexExists = flg
    
End Function

Private Function GetValue(ByVal index As Long) As String
    If IsIndexExists(index) Then
        GetValue = arr(index)
    Else
        GetValue = ""
    End If
End Function

Private Function GetIndexOf(ByVal Entry As String) As Long
    
    Dim i As Long
    Dim ReturnCode As Long
    ReturnCode = -1
    
    For i = LBound(arr) To UBound(arr)
        If arr(i) = Entry Then
            ReturnCode = i
            Exit For
        End If
    Next i
    
    GetIndexOf = ReturnCode
    
End Function

Private Sub Class_Initialize()
    ReDim arr(0) As String
    flgFirstTime = True
    m_CharacterBytesCount = 2
End Sub

Private Function mrtLeft(ByVal InputString As String, ByVal length As Long) As String
    If Len(InputString) >= length Then
        mrtLeft = Left(InputString, length)
    Else
        mrtLeft = InputString
    End If
End Function

Private Sub InitializeDictionary()
    Dim i As Long
    For i = 0 To (2 ^ (m_CharacterBytesCount * 8)) - 1
        Add (ChrW(i))
    Next
End Sub

Private Function length() As Long
    length = UBound(arr)
End Function

'Public methods
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Public Function Compress(ByVal UncompressedData As String, ByRef valam As Long, ByRef arr() As Long) As String

    Dim w As String
    Dim c As String
    Dim wc As String
    'Dim dic As New Dictionary
    Dim Output As String
    Dim Code As Long
    
    Dim i As Long
    InitializeDictionary
    valam = 0
    
    ReDim arr(1024)
    Dim curarrsize As Long
    curarrsize = 1024
     
    w = ""
    For i = 1 To Len(UncompressedData)
        
        c = Mid(UncompressedData, i, 1)
        wc = w + c
        If IsExists(wc) Then
            w = wc
        Else
            Code = Add(wc)
            Code = GetIndexOf(w)
            Output = Output & IIf(Output = "", "", ",") & Code
            arr(valam) = Code
            valam = valam + 1
            If valam > curarrsize Then
              curarrsize = curarrsize + 1024
              ReDim Preserve arr(curarrsize)
            End If
            w = c
        End If
        
        '?
    
    Next i
    
    Output = Output & IIf(Output = "", "", ",") & GetIndexOf(w)
    arr(valam) = GetIndexOf(w)
    valam = valam + 1
    
    Compress = Output

End Function


Public Function DecompressArray(valam As Long, arr() As Long) As String
  Dim compresseddata As String
  Dim i As Long
  For i = 0 To valam - 1
    compresseddata = compresseddata & IIf(compresseddata = "", "", ",") & arr(i)
  Next i
  DecompressArray = Decompress(compresseddata)
End Function

Public Function Decompress(ByVal compresseddata As String) As String
    
    If compresseddata = "" Then Exit Function
    
    'Dim dic As New Dictionary
    
    InitializeDictionary

    Dim Output As String
    Dim Entry As String

    Dim k As String
    Dim w As String
    Dim i As Long
    
    Dim arrCompressedData() As String
    arrCompressedData = Split(compresseddata, ",")
    
    k = arrCompressedData(0)
    Output = Output & GetValue(k)
    w = k
    
    For i = 1 To UBound(arrCompressedData)
    
        k = arrCompressedData(i)
        
        If IsIndexExists(k) Then
        
            Entry = GetValue(k)
            
        ElseIf IsIndexExists(k) = False And k = length + 1 Then
            
            Entry = GetValue(w) + mrtLeft(GetValue(w), 1)
            
        Else
        
            'MsgBox "Bad compressed."
            MsgBox FMT0("LZW_1")
            
        End If
        
        Output = Output + Entry
        
        Add (GetValue(w) + mrtLeft(Entry, 1))
        
        w = GetIndexOf(Entry)
        
    Next
    
    Decompress = Output
    
End Function




Attribute VB_Name = "MColourReferenceAmount"
Option Explicit

Sub ESQAColourReferenceAmount()
On Error GoTo CatchError
  
  CheckStartupStuff
  
  If Not DoPreparations() Then Exit Sub
  
  Dim calc As Long
  Dim bEnableEvents As Boolean
  Dim bScreenUpdating As Boolean
  DisableExcel calc, bScreenUpdating, bEnableEvents
  
  Dim errBereich As String
  errBereich = "1"

  Dim foundCells As Long
  
  errBereich = "3"
  foundCells = 0
  
  errBereich = "4"
  If ColourCurrentTable Then
    errBereich = "4.1"
'    RemovePasswordFromSheet ActiveSheet
    ResetSheetFormats ActiveSheet
    foundCells = foundCells + ColourReferenceAmount(ActiveSheet)
  Else
    errBereich = "4.2"
    Dim ws As Worksheet
    For Each ws In ActiveWorkbook.Worksheets
      If Left(ws.name, 5) <> "ESQA." Then
        errBereich = "4.3-" & ws.name
        ResetSheetFormats ws
        foundCells = foundCells + ColourReferenceAmount(ws)
      End If
      If Abbruch Then Exit For
    Next ws
  End If
  
  UpdateStatus "", -1
  StatusForm.Hide
  
  CheckErrorMessage
  
  SetStartSheetAndCell
  
  If Not Abbruch Then
    Dim tStr As String
    tStr = ""
    'If FullVersion = False Then tStr = "Demoversion: Es werden nur die ersten 10 Spalten * 40 Zeilen eingef|fffd|rbt. Die genannten Mengen beziehen sich auf das Gesamtdokument!" & vbLf & vbLf
    If FullVersion = False Then tStr = FMT0("MCOL_1")
'    MsgBox tStr & IIf(ColourCurrentTable = True, "Auswertung f|fffd|r Tabelle '" & ActiveSheet.name & "'" & vbLf & vbLf, "") & _
'      foundCells & " Zelle(n) vorhanden, die mindestens 1 mal oder |fffd|fter von anderen Zellen verwendet werden." & vbLf & _
'      "Formelzellen, die nirgends verwendet werden, haben links einen gr|fffd|nen Rand." & vbLf & _
'      "Konstanten, die nirgends verwendet werden, haben unten einen roten Rand.", vbInformation, "ESQA " & MyVersion
    MsgBox tStr & IIf(ColourCurrentTable = True, FMT1("MCOL_2", ActiveSheet.name), "") & FMT1("MCOL_10", foundCells) & GetErrorTexts, vbInformation, "ESQA " & MyVersion
  End If
'  MsgBox restext, vbInformation

  EnableExcel calc, bScreenUpdating, bEnableEvents
  
  Exit Sub
CatchError:

  G_ErrorCount = G_ErrorCount + 1
  'G_ErrorText = G_ErrorText & "ESQAColourReferenceAmountFunc: (Area: " & errBereich & "): " & Err.Number & " - " & Err.Description & vbCrLf
  G_ErrorText = FMT4("MCOL_4", G_ErrorText, errBereich, Err.Number, Err.Description)
  Resume Next
End Sub

Function ColourReferenceAmount(ByRef ws As Worksheet) As Long

  Dim funcname As String
  funcname = "ColourReferenceAmount"
  Dim foundCells As Long
  foundCells = 0
  
  On Error GoTo CatchError
  
  Dim errBereich As String
  Dim lineCells As Range
  Dim lineCount As Long
  Dim totalLineAmount As Long
  Dim lastRow As Long
'  ws.Activate
  ws.ScrollArea = ""
  lastRow = GetLastRow(ws)
   
  If lastRow > 0 Then
                 
     totalLineAmount = lastRow
     
     If lastRow > 40 And FullVersion = False Then
       lastRow = 40
     End If
     
     For lineCount = 1 To lastRow

          Set lineCells = GetFormulaRangeLine(ws, lineCount)
          If Not lineCells Is Nothing Then
            DoColourReferenceAmount lineCells, foundCells, errBereich
          End If
          Set lineCells = GetNonFormulaRangeLine(ws, lineCount)
          If Not lineCells Is Nothing Then
            DoColourReferenceAmount lineCells, foundCells, errBereich
          End If
  
          If lineCount Mod 5 = 0 Then
            'UpdateStatus "Analysiere '" & ActiveSheet.name & "'", CDbl(cnt) / CDbl(totalamount)
            UpdateStatus FMT1("START_10", ws.name), CDbl(lineCount) / CDbl(totalLineAmount)
          End If
          If Abbruch Then Exit For
      Next lineCount
  End If
  Set lineCells = Nothing
  ColourReferenceAmount = foundCells
  Exit Function
CatchError:

  G_ErrorCount = G_ErrorCount + 1
  G_ErrorText = G_ErrorText & "Error in " & funcname & " (Area: " & errBereich & "): " & Err.Number & " - " & Err.Description & vbCrLf
  Resume Next
  
End Function

Sub DoColourReferenceAmount(ByRef lineCells As Range, ByRef foundCells As Long, ByRef errBereich As String)
  
  Dim funcname As String
  funcname = "DoColourReferenceAmount"
  
  On Error GoTo CatchError
  
  Dim c As Range
  Dim deps As Collection
  Dim refString As String
  Dim i As Long
  
  For Each c In lineCells
    errBereich = "WS:" & c.Parent.name & "!" & c.Address
  
    If Abbruch Then Exit Sub
    Set deps = Nothing
    
'    If c.Parent.name = "Kontrolle" And c.Address = "$D$8" Then
'      Debug.Print "gaga"
'    End If
  
    
    If GetArrows(c, deps, False, False) Then
      If Not deps Is Nothing Then
          foundCells = foundCells + 1
          If deps.Count > 50 Then
            c.Interior.ColorIndex = 4
            c.Font.ColorIndex = GetCorrespondingFontColor(4)
  '              AddMyComment c, IIf(Left(c.Formula, 1) = "=", "Formel: ", "Konstante: ") & _
  '                    c.Formula & vbLf & deps.Count & " Zelle(n) nutzt / nutzen diesen Wert.", _
  '                    IIf(Len(c.Formula) > 20, 600, 400), 24
            AddMyComment c, deps.Count & FMT0("MCOL_7"), _
                  IIf(Len(c.Formula) > 20, 600, 400), 24
          ElseIf deps.Count > 0 Then
            c.Interior.ColorIndex = deps.Count + 5
            c.Font.ColorIndex = GetCorrespondingFontColor(deps.Count + 5)
            refString = ""
            Dim ti
            For Each ti In deps
              If c.Worksheet.name <> ti.Parent.name Then
                refString = refString & ti.Parent.name & "'!" & RemoveText(ti.Address, "$") & vbLf
              Else
                refString = refString & RemoveText(ti.Address, "$") & vbLf
              End If
            Next ti
            
            
            
  '              AddMyComment c, IIf(Left(c.Formula, 1) = "=", "Formel: ", "Konstante: ") & _
  '                    c.Formula & vbLf & deps.Count & " Zelle(n) nutzt / nutzen diesen Wert." & vbLf & refString, _
  '                    IIf(Len(c.Formula) > 20, 600, 400), 24 + 13 * deps.Count
            AddMyComment c, deps.Count & FMT0("MCOL_7") & vbLf & refString, _
                  IIf(Len(c.Formula) > 20, 600, 400), 24 + 13 * deps.Count
          End If
      End If
    Else
  '        c.Interior.ColorIndex = 3
  '          c.Font.ColorIndex = GetCorrespondingFontColor(3)
        If Not IsEmpty(c) Then
          If IsNumeric(c.value) Then
'                AddMyComment c, IIf(Left(c.Formula, 1) = "=", "Formel: ", "Konstante: ") & _
'                      c.Formula & vbLf & "Keine Zelle nutzt diesen Wert.", _
'                  IIf(Len(c.Formula) > 20, 600, 120), 24
            AddMyComment c, IIf(Left(c.Formula, 1) = "=", FMT0("MCOL_5"), FMT0("MCOL_6")) & _
                  c.Formula & vbLf & FMT0("MCOL_8"), _
              IIf(Len(c.Formula) > 20, 600, 120), 24
            If c.HasFormula Then
              With c.Borders(xlEdgeLeft)
                .LineStyle = xlContinuous
                .Weight = xlThick
                .ColorIndex = 4
              End With
            Else
              With c.Borders(xlEdgeBottom)
                .LineStyle = xlContinuous
                .Weight = xlThick
                .ColorIndex = 3
              End With
            End If
            FrameCell c
          End If
        End If
    End If
  Next c
  Exit Sub

CatchError:
  ErrorHandler funcname, errBereich, c
  Resume Next
End Sub
Attribute VB_Name = "MCoulourClones"
Option Explicit

Sub ESQAColourClones()
On Error GoTo CatchError
  CheckStartupStuff
  
  If Not DoPreparations() Then Exit Sub
  
  Dim calc As Long
  Dim bEnableEvents As Boolean
  Dim bScreenUpdating As Boolean
  DisableExcel calc, bScreenUpdating, bEnableEvents
  
  Dim foundCells As Long
  Dim foundClones As Long
  
  foundCells = 0
  foundClones = 0
  If ColourCurrentTable Then
    ResetSheetFormats ActiveSheet
    foundCells = foundCells + ColourClones(ActiveSheet, foundClones)
  Else
    Dim ws As Worksheet
    For Each ws In ActiveWorkbook.Worksheets
      If Left(ws.name, 5) <> "ESQA." Then
        ResetSheetFormats ws
        foundCells = foundCells + ColourClones(ws, foundClones)
      End If
      If Abbruch Then Exit For
    Next ws
  End If
  
  Dim tStr As String
  
  UpdateStatus "", -1
  StatusForm.Hide
  
  CheckErrorMessage
  
  EnableExcel calc, bScreenUpdating, bEnableEvents
  
  SetStartSheetAndCell
  
  If Not Abbruch Then
    tStr = ""
    'If FullVersion = False Then tStr = "Demoversion: Es werden nur die ersten 10 Spalten * 40 Zeilen eingef|fffd|rbt. Die genannten Mengen beziehen sich auf das Gesamtdokument!" & vbLf & vbLf
    If FullVersion = False Then tStr = FMT0("MCOL_1")
'    MsgBox tStr & IIf(ColourCurrentTable = True, "Auswertung f|fffd|r Tabelle '" & ActiveSheet.name & "'" & vbLf & vbLf, "") & _
'      "Insgesamt wurde(n) " & foundClones & " Zelle(n) aus " & foundCells & " Mutter-Zelle(n) geklont. " & vbLf & _
'      "Mutter-Zellen haben links einen roten Rand." & vbLf & _
'      "Einzigartige Formeln (von denen es keine Klone gibt) haben unten einen gr|fffd|nen Rand." & vbLf & _
'      G_AnalyzeErrors & " Zelle(n) konnten nicht analysiert werden und haben zwei schwarze Diagonalen.", vbInformation, "ESQA " & MyVersion
    MsgBox tStr & IIf(ColourCurrentTable = True, FMT1("MCOL_2", ActiveSheet.name), "") & _
      FMT2("MCOL_CLONES_7", foundClones, foundCells) & GetErrorTexts, vbInformation, "ESQA " & MyVersion
  End If
  
'  MsgBox restext, vbInformation

  Exit Sub
CatchError:
  G_ErrorCount = G_ErrorCount + 1
  G_ErrorText = G_ErrorText & "ESQAColourClonesFunc: (" & Err.Number & ") - " & Err.Description & vbLf
  Resume Next
End Sub

Function ColourClones(ByRef ws As Worksheet, ByRef foundClones As Long) As Long
  
  Dim funcname As String
  funcname = "ColourClones"
  Dim foundCells As Long
  foundCells = 0
  
  On Error GoTo CatchError
  
  Dim errBereich As String
  Dim lineCells As Range
  Dim lineCount As Long
  Dim totalLineAmount As Long
  Dim lastRow As Long
  ws.ScrollArea = ""
  lastRow = GetLastRow(ws)
'  ws.Activate
  
  If lastRow > 0 Then
                 
     totalLineAmount = lastRow
     
     If lastRow > 40 And FullVersion = False Then
       lastRow = 40
     End If
     
     Dim tCells As Collection
     Set tCells = New Collection
     Dim colorCount As Long
     colorCount = 6
     Dim colorSubCount As Long
     colorSubCount = 0
      
     For lineCount = 1 To lastRow

          Set lineCells = GetFormulaRangeLine(ws, lineCount)
          If Not lineCells Is Nothing Then
            DoColourClones lineCells, foundCells, errBereich, foundClones, tCells, colorCount, colorSubCount
          End If
          If lineCount Mod 5 = 0 Then
            'UpdateStatus "Analysiere '" & ActiveSheet.name & "'", CDbl(cnt) / CDbl(totalamount)
            UpdateStatus FMT1("START_10", ws.name), CDbl(lineCount) / CDbl(totalLineAmount)
          End If
          If Abbruch Then Exit For
      Next lineCount
  
      Dim ci As CloneInfo
      For Each ci In tCells
        If Abbruch Then Exit For
        If ci.m_Count > 0 Then
  '        AddMyComment ci.m_MotherCell, _
  '          "Formel: " & _
  '              ci.m_MotherCell.Formula & vbLf & "Die Formel wurde " & ci.m_Count & " mal geklont.", _
  '          IIf(Len(ci.m_MotherCell.Formula) > 20, 600, 160), 24
          AddMyComment ci.m_MotherCell, FMT2("MCOL_CLONES_5", ci.m_MotherCell.Formula, ci.m_Count), _
            IIf(Len(ci.m_MotherCell.Formula) > 20, 600, 160), 24
          With ci.m_MotherCell
            ' .Interior.ColorIndex = ci.m_Color
            .Interior.Pattern = ci.m_Pattern
            .Interior.ColorIndex = ci.m_Color
            .Font.ColorIndex = GetCorrespondingFontColor(ci.m_Color)
            With .Borders(xlEdgeLeft)
              .LineStyle = xlContinuous
              .Weight = xlThick
              .ColorIndex = 3
            End With
            FrameCell ci.m_MotherCell
          End With
          foundCells = foundCells + 1
        Else
          With ci.m_MotherCell
            With .Borders(xlEdgeBottom)
              .LineStyle = xlContinuous
              .Weight = xlThick
              .ColorIndex = 4
            End With
            FrameCell ci.m_MotherCell
  '          AddMyComment ci.m_MotherCell, _
  '            "Formel: " & _
  '                ci.m_MotherCell.Formula & vbLf & "Einzigartige Formel, die nirgends geklont wurde.", _
  '                IIf(Len(ci.m_MotherCell.Formula) > 20, 600, 220), 24
            AddMyComment ci.m_MotherCell, FMT1("MCOL_CLONES_6", ci.m_MotherCell.Formula), _
                  IIf(Len(ci.m_MotherCell.Formula) > 20, 600, 220), 24
          End With
        End If
      Next ci
      
      Set tCells = Nothing
  
  
  End If
  Set lineCells = Nothing
  ColourClones = foundCells
  Exit Function
CatchError:

  ErrorHandler funcname, errBereich, Nothing

  Resume Next
    
End Function

Function GetClone(ByRef tCells As Collection, ByRef f As String) As CloneInfo
  On Error Resume Next
  Set GetClone = Nothing
  Set GetClone = tCells(f)
End Function

Sub DoColourClones(ByRef lineCells As Range, ByRef foundCells As Long, ByRef errBereich As String, ByRef foundClones As Long, ByRef tCells As Collection, ByRef colorCount As Long, ByRef colorSubCount As Long)
  
  Dim funcname As String
  funcname = "DoColourClones"
  
  On Error GoTo CatchError
  
  Dim c As Range
  Dim deps As Range
  Dim refString As String
  Dim i As Long

'  On Error Resume Next

  For Each c In lineCells
    errBereich = "WS:" & c.Parent.name & "!" & c.Address
  
    Dim ci As CloneInfo
    If FormulaR1C1ReadableAndMarkIfNot(c) Then
      Set ci = GetClone(tCells, c.FormulaR1C1)
      
      If ci Is Nothing Then
        Set ci = New CloneInfo
        Set ci.m_MotherCell = c
        ci.m_Formula = c.FormulaR1C1
        ci.m_Count = 0
        tCells.Add ci, c.FormulaR1C1
      Else
        If ci.m_Count = 0 Then
          If colorCount <= 56 Then
            ci.m_Color = colorCount
          Else
            ci.m_Color = 6
            colorSubCount = colorSubCount + 1
          End If
          colorCount = colorCount + 1
        End If
        
        Select Case colorSubCount
          Case 0
            ci.m_Pattern = xlSolid
          Case 1
            ci.m_Pattern = xlLightUp
          Case 2
            ci.m_Pattern = xlLightDown
          Case 3
            ci.m_Pattern = xlGray8
          Case 4
            ci.m_Pattern = xlLightVertical
          Case 5
            ci.m_Pattern = xlLightHorizontal
          Case Else
            ci.m_Pattern = xlSolid
        End Select
        
        ci.m_Count = ci.m_Count + 1
'            AddMyComment c, "Formel: " & _
'                  c.Formula & vbLf & "Klon von " & ci.m_MotherCell.Address, _
'                  IIf(Len(c.Formula) > 20, 600, 160), 24
'        AddMyComment c, FMT0("MCOL_5") & _
'              c.Formula & vbLf & FMT1("MCOL_CLONES_3", ci.m_MotherCell.Address), _
'              IIf(Len(c.Formula) > 20, 600, 160), 24
        
        c.Interior.Pattern = ci.m_Pattern
        c.Interior.ColorIndex = ci.m_Color
        
        AddMyComment c, FMT1("MCOL_CLONES_3", ci.m_MotherCell.Address), _
              100, 12
        c.Font.ColorIndex = GetCorrespondingFontColor(ci.m_Color)
        foundClones = foundClones + 1
      End If
    End If
    
    If Abbruch Then Exit For
  Next c
  
  Exit Sub

CatchError:
  ErrorHandler funcname, errBereich, c
  Resume Next

End Sub
Attribute VB_Name = "MKomplexeFormeln"
Option Explicit

Function GetOriginalFilename() As String
  Dim tFName As String
  If ActiveWorkbook Is Nothing Then Exit Function
  tFName = ActiveWorkbook.FullName
  If UCase(Right(tFName, 13)) = ".ANALYSE.ESQA" Then
    tFName = Left(tFName, Len(tFName) - 13)
  End If
  GetOriginalFilename = tFName
End Function


Sub ESQAKomplexeFormeln()
  CheckStartupStuff
  
'  If Not FileExists(ThisWorkbook.path & "\Excel-Sheet-QA Formula reference.txt") Then
'    MsgBox "Die Datei '" & ThisWorkbook.path & "\Excel-Sheet-QA Formula reference.txt' fehlt. Die Funktion kann nicht ausgef|fffd|hrt werden. Bitte entpacken Sie die Dateien erneut aus der ZIP-Datei. Weitere Infos finden Sie im Handbuch.", vbCritical
'    Exit Sub
'  End If

  Dim tFName As String
  tFName = ActiveWorkbook.FullName
  If UCase(Right(tFName, 13)) = ".ANALYSE.ESQA" Then
    tFName = Left(tFName, Len(tFName) - 13)
  End If
  
  'If Not G_cTodo.LoadTodoList(tFName & ".ESQATD", ThisWorkbook.path & "\TodoHlp\Todo%1%.mht", tFName, "Empfehlungen / Todos f|fffd|r " & tFName, ThisWorkbook.path & "\Excel-Sheet-QA-Todo.cfg") Then
'  If Not G_cTodo.LoadTodoList(tFName & ".ESQATD", ThisWorkbook.path & "\TodoHlp\Todo%1%.mht", tFName, FMT1("MKOMPLEXE_1", tFName), ThisWorkbook.path & "\Excel-Sheet-QA-Todo.cfg") Then
    'G_cTodo.CreateNewList "ESQA", tFName & ".ESQATD", ThisWorkbook.path & "\TodoHlp\Todo%1%.mht", tFName, "Todos f|fffd|r " & tFName, ThisWorkbook.path & "\Excel-Sheet-QA-Todo.cfg"
'    G_cTodo.CreateNewList "ESQA", tFName & ".ESQATD", ThisWorkbook.path & "\TodoHlp\Todo%1%.mht", tFName, FMT1("MKOMPLEXE_2", tFName), ThisWorkbook.path & "\Excel-Sheet-QA-Todo.cfg"
'  End If

  Dim formulasFile As String
  formulasFile = gTranslation.GetLocalizedFile(ThisWorkbook.path & "\Excel-Sheet-QA Formulas.txt")

  'If Not FileExists(ThisWorkbook.path & "\Excel-Sheet-QA Formulas.txt") Then
  If Not FileExists(formulasFile) Then
    'MsgBox "Die Datei '" & ThisWorkbook.path & "\Excel-Sheet-QA Formulas.txt' fehlt. Die Funktion kann nicht ausgef|fffd|hrt werden. Bitte entpacken Sie die Dateien erneut aus der ZIP-Datei. Weitere Infos finden Sie im Handbuch.", vbCritical, "ESQA " & MyVersion
    MsgBox FMT1("MKOMPLEXE_3", formulasFile), vbCritical, "ESQA " & MyVersion
    Exit Sub
  End If
  
  Dim ff As Integer
  ff = FreeFile
  


'  Set KeyWrdsGE = New Collection
'  Set KeyWrdsEG = New Collection
  
'  Open ThisWorkbook.path & "\Excel-Sheet-QA Formula reference.txt" For Input As #ff
'  l = 1
'  Do While Not EOF(ff)
'    Dim engl As String, deut As String
'    Input #ff, engl
'    pos = InStr(engl, " ")
'    If pos <= 0 Then
'      MsgBox "In Zeile " & l & " fehlt ein Leerzeichen. Das Keyword-Paar muss durch ein Leerzeichen getrennt sein"
'      Close ff
'      Exit Sub
'    End If
'    deut = Trim(Mid(engl, pos))
'    engl = Trim(Left(engl, pos))
'    KeyWrdsGE.Add engl, deut
'    KeyWrdsEG.Add deut, engl
'    l = l + 1
'  Loop
'  Close ff


  ComplexFormulas.Searches.Clear
  
  Set KomplexListe = New Collection
  
  'Open ThisWorkbook.path & "\Excel-Sheet-QA Formulas.txt" For Input As #ff
  Open formulasFile For Input As #ff
  LoadFormulaList ff
  Close ff
  
  Dim myFormulasFile As String
  myFormulasFile = gTranslation.GetLocalizedFile(ThisWorkbook.path & "\Excel-Sheet-QA Ihre Formeln.txt")
  'If FileExists(ThisWorkbook.path & "\Excel-Sheet-QA Ihre Formeln.txt") Then
  If Not FileExists(myFormulasFile) Then
    ' Localization: Nochmal mit anderem Namen probieren
    myFormulasFile = gTranslation.GetLocalizedFile(ThisWorkbook.path & "\Excel-Sheet-QA indiv.txt")
  End If
  
  If FileExists(myFormulasFile) Then
    'Open ThisWorkbook.path & "\Excel-Sheet-QA Ihre Formeln.txt" For Input As #ff
    Open myFormulasFile For Input As #ff
    LoadFormulaList ff
    Close ff
  End If
  
  Dim indivFile As String
  indivFile = gTranslation.GetLocalizedFile(ThisWorkbook.path & "\Excel-Sheet-QA-Indiv.txt")
  'If FileExists(ThisWorkbook.path & "\Excel-Sheet-QA-Indiv.txt") Then
  If FileExists(indivFile) Then
    'Open ThisWorkbook.path & "\Excel-Sheet-QA-Indiv.txt" For Input As #ff
    Open indivFile For Input As #ff
    LoadFormulaList ff
    Close ff
  End If
  ComplexFormulas.FindTxt = GetSetting( _
    appname:="Stromwerken", _
    Section:="ESQA", _
    Key:="FindTxt", Default:="DBSUMME,SVERWEIS,WVERWEIS")

  ComplexFormulas.BracNum = GetSetting( _
    appname:="Stromwerken", _
    Section:="ESQA", _
    Key:="BracNum", Default:="3")
  
  ComplexFormulas.Show
  
End Sub

Sub LoadFormulaList(ff As Integer)
  Dim l As Long
  Dim pos As Long
  
  l = 1
  Do While Not EOF(ff)
  
    Dim ce As ComplexEntry
    Set ce = New ComplexEntry
    
    Dim Param As String
    Dim wert As Long
    
    Line Input #ff, Param
    l = l + 1
    
    Input #ff, wert
    ce.m_Farbe = wert
    Input #ff, wert
    ce.m_Typ = wert
    Input #ff, Param
    ce.m_|fffd|berschrift = Param
'    Debug.Print param
    
    If ce.m_Typ = 1 Then
      Input #ff, wert
      ce.m_Typ1Anzahl = wert
    End If
    
    Line Input #ff, Param
    ce.m_Details = Param
    
    Set ce.m_KW = New Collection
    
    Do
      pos = InStr(Param, ",")
      If pos <= 0 Then Exit Do
      ce.m_KW.Add Trim(Left(Param, pos - 1))
'      Debug.Print Trim(Left(param, pos - 1))
      Param = Mid(Param, pos + 1)
    Loop
    
    If Len(Param) > 0 Then
      ce.m_KW.Add Trim(Param)
'      Debug.Print Trim(param)
    End If
    
    KomplexListe.Add ce
    ComplexFormulas.Searches.AddItem ce.m_|fffd|berschrift
    l = l + 1
  Loop
End Sub

Sub ESQAMoreThanXBracs()
On Error GoTo CatchError
  
  Dim calc As Long
  Dim bEnableEvents As Boolean
  Dim bScreenUpdating As Boolean
  DisableExcel calc, bScreenUpdating, bEnableEvents
  
  Dim foundCells As Long
  Dim foundClones As Long
  
  foundCells = 0
  foundClones = 0
  Application.ScreenUpdating = False
  If ColourCurrentTable Then
    ResetSheetFormats ActiveSheet
    foundCells = foundCells + MoreThanXBracs(ActiveSheet)
  Else
  Dim ws As Worksheet
    For Each ws In ActiveWorkbook.Worksheets
      If Left(ws.name, 5) <> "ESQA." Then
        ResetSheetFormats ws
        foundCells = foundCells + MoreThanXBracs(ws)
      End If
      If Abbruch Then Exit For
    Next ws
  End If
  Application.ScreenUpdating = True
  
  Dim tStr As String
  tStr = ""
  'If FullVersion = False Then tStr = "Demoversion: Es werden nur die ersten 10 Spalten * 40 Zeilen eingef|fffd|rbt. Die genannten Mengen beziehen sich auf das Gesamtdokument!" & vbLf & vbLf
  If FullVersion = False Then tStr = FMT0("MCOL_1")
  
  UpdateStatus "", -1
  StatusForm.Hide
  
  CheckErrorMessage
  
  If Not Abbruch Then
    If theResbook Is Nothing Then
      'MsgBox tStr & IIf(ColourCurrentTable = True, "Auswertung f|fffd|r Tabelle '" & ActiveSheet.name & "'" & vbLf & vbLf, "") & _
      '  "Es wurde(n) " & foundCells & " Zellen mit mindestens " & ComplexFormulas.BracNum & " ge|fffd|ffneten Klammern gefunden.", vbInformation, "ESQA " & MyVersion
      MsgBox tStr & IIf(ColourCurrentTable = True, FMT1("MCOL_2", ActiveSheet.name), "") & _
        FMT2("MKOMPLEXE_4", foundCells, ComplexFormulas.BracNum) & GetErrorTexts, vbInformation, "ESQA " & MyVersion
    Else
      'If MsgBox(tStr & IIf(ColourCurrentTable = True, "Auswertung f|fffd|r Tabelle '" & ActiveSheet.name & "'" & vbLf & vbLf, "") & _
      '  "Es wurde(n) " & foundCells & " Zellen mit mindestens " & ComplexFormulas.BracNum & " ge|fffd|ffneten Klammern gefunden." & vbLf & vbLf & "Wollen Sie zum Ergebnisblatt wechseln?", vbYesNo, "ESQA " & MyVersion) = vbYes Then
      If MsgBox(tStr & IIf(ColourCurrentTable = True, FMT1("MCOL_2", ActiveSheet.name), "") & _
        FMT2("MKOMPLEXE_5", foundCells, ComplexFormulas.BracNum), vbYesNo, "ESQA " & MyVersion) = vbYes Then
        'theResbook.Sheets("ESQA.Mehr als X Klammern").Activate
        theResbook.Sheets("ESQA." & FMT0("COMPLEXF_22")).Activate
      End If
      
      'theResbook.Sheets("ESQA.Info").Hyperlinks.Add Anchor:=theResbook.Sheets("ESQA.Info").Cells(INFO_ComplexBracY, 1), Address:="", SubAddress:= _
      '    "'Mehr als X Klammern'!A1", TextToDisplay:="Es wurde(n) " & foundCells & " Zellen mit mindestens " & ComplexFormulas.BracNum & " ge|fffd|ffneten Klammern gefunden."
      theResbook.Sheets("ESQA.Info").Hyperlinks.Add Anchor:=theResbook.Sheets("ESQA.Info").Cells(INFO_ComplexBracY, 1), Address:="", SubAddress:= _
          "'" & FMT0("COMPLEXF_22") & "'!A1", TextToDisplay:=FMT2("MKOMPLEXE_4", foundCells, ComplexFormulas.BracNum)
    End If
  End If
  
'  MsgBox restext, vbInformation

  EnableExcel calc, bScreenUpdating, bEnableEvents
  
  Exit Sub
CatchError:
  G_ErrorCount = G_ErrorCount + 1
  G_ErrorText = G_ErrorText & "ESQAMoreThanXBracs: (" & Err.Number & ") - " & Err.Description & vbLf
  Resume Next
End Sub

Function MoreThanXBracs(ByRef ws As Worksheet) As Long

On Error GoTo CatchError
  
  If Not theResbook Is Nothing Then
    'theRessheet.Cells(theRessheetY, 1) = "Tabelle: '" & ActiveSheet.name & "'"
    theRessheet.Cells(theRessheetY, 1) = FMT1("CONSTANTS_1", ws.name)
    theRessheet.Cells(theRessheetY, 1).Font.bold = True
    theRessheetY = theRessheetY + 1
  End If
  
  
  If Not theResbook Is Nothing Then
    'theRessheet.Cells(theRessheetY, 1) = "0 Zellen mit mehr als " & ComplexFormulas.BracNum & " ge|fffd|ffneten Klammern gefunden."
    theRessheet.Cells(theRessheetY, 1) = FMT1("MKOMPLEXE_6", ComplexFormulas.BracNum)
    theRessheetY = theRessheetY + 2
  End If
  
  
  
  Dim foundCells As Long
  foundCells = 0
  Dim c As Range
                        
                        
  Dim errBereich As String
  Dim lineCells As Range
  Dim lineCount As Long
  Dim totalLineAmount As Long
  Dim lastRow As Long
  ws.ScrollArea = ""
  lastRow = GetLastRow(ws)
  
  If lastRow > 0 Then
                
    totalLineAmount = lastRow
    
    If lastRow > 40 And FullVersion = False Then
      lastRow = 40
    End If
    
    For lineCount = 1 To lastRow

            Set lineCells = GetFormulaRangeLine(ws, lineCount)
      
            If Not lineCells Is Nothing Then
                For Each c In lineCells
                        
                          errBereich = "WS:" & c.Parent.name & "!" & c.Address
                          Dim pos As Long
                          Dim posopen As Long
                          Dim posclose As Long
                          Dim bracam As Long
                          
                          bracam = 0
                          pos = 1
                          
                          Dim formulaStr As String
                          formulaStr = RemoveStrings(c.Formula, Chr(34), Chr(34))
                          formulaStr = RemoveStrings(formulaStr, "'", "'")
                          formulaStr = RemoveStrings(formulaStr, "[", "]")
                          
                          Do
                            
                            
                            posopen = InStr(pos, formulaStr, "(")
                            posclose = InStr(pos, formulaStr, ")")
                            
                      '      If posopen > 0 Then
                      '        Debug.Print "gaga"
                      '      End If
                            
                            
                            If posopen <= 0 Then
                              Exit Do
                            ElseIf posopen < posclose Then
                              bracam = bracam + 1
                              pos = posopen + 1
                            ElseIf posclose > 0 And posclose < posopen Then
                              bracam = bracam - 1
                              pos = posclose + 1
                            End If
                            
                            If bracam > ComplexFormulas.BracNum Then
                              
                              foundCells = foundCells + 1
                              If Not theResbook Is Nothing Then
                                ' theRessheet.Cells(theRessheetY, 1) = RemoveText(c.Address, "$")
                                theRessheet.Cells(theRessheetY, 1).FormulaLocal = "=HYPERLINK(" & Chr(34) & Replace(c.Parent.Parent.FullName, ".ANALYSE.ESQA", "") & "#'" & c.Parent.name & "'!" & c.Address & Chr(34) & ";" & Chr(34) & RemoveText(c.Address, "$") & Chr(34) & ")"
                                theRessheet.Cells(theRessheetY, 2) = "'" & GetFormula(c)
                                theRessheetY = theRessheetY + 1
                              End If
                              
'                              G_cTodo.ModifyContent "ESQACOMPLEXBRAC", ActiveSheet.name & "!" & RemoveText(c.Address, "$"), True
                              ' c.Interior.ColorIndex = 8
                              If foundCells <= G_MarkCellsAmount Then
                                If G_ColorCells Then
                                  G_CellFormats("ESQAComplexFormulas").SetFormat c
                                End If
                                'AddMyComment c, "Zelle mit mehr als " & ComplexFormulas.BracNum & " ge|fffd|ffneten Klammern", 160, 24
                                AddMyComment c, FMT1("MKOMPLEXE_7", ComplexFormulas.BracNum), 160, 24
                              End If
                              Exit Do
                            
                            End If
                            If Abbruch Then Exit For
                          Loop
                          
                          If Abbruch Then Exit For
                Next c
            End If
          If lineCount Mod 5 = 0 Then
            'UpdateStatus "Konstanten '" & ActiveSheet.name & "'", CDbl(cnt) / CDbl(totalamount)
            UpdateStatus FMT1("START_10", ws.name), CDbl(lineCount) / CDbl(totalLineAmount)
          End If
          If Abbruch Then Exit For
        Next lineCount
  End If
      
  
  
    
  If Not theResbook Is Nothing Then
    'theRessheet.Cells(theRessheetY, 1) = foundCells & " Zelle(n) mit mehr als " & ComplexFormulas.BracNum & " ge|fffd|ffneten Klammern gefunden."
    theRessheet.Cells(theRessheetY, 1) = FMT2("MKOMPLEXE_9", foundCells, ComplexFormulas.BracNum)
    theRessheetY = theRessheetY + 2
  End If
  
'  If G_TodoErzeugen Then
'    G_cTodo.RemoveAllNonModifiedContents "ESQACOMPLEXBRAC"
'    G_cTodo.Store
'  End If
  
  MoreThanXBracs = foundCells
  Exit Function
CatchError:
  ErrorHandler "MoreThanXBracs", errBereich, c
  Resume Next
End Function

Attribute VB_Name = "MKomplexeFormelnListe"
Option Explicit

Sub ESQAFormulasListe()
 On Error GoTo CatchError
  
  Dim calc As Long
  Dim bEnableEvents As Boolean
  Dim bScreenUpdating As Boolean
  DisableExcel calc, bScreenUpdating, bEnableEvents
  
  Dim foundCells As Long
  Dim foundClones As Long
  
  Dim localerrorcount As Long
  localerrorcount = 0
  
  foundCells = 0
  foundClones = 0
  Application.ScreenUpdating = False
  If ColourCurrentTable Then
    ResetSheetFormats ActiveSheet
    foundCells = foundCells + FormulasListe(ActiveSheet, localerrorcount)
  Else
    Dim ws As Worksheet
    For Each ws In ActiveWorkbook.Worksheets
      If Left(ws.name, 5) <> "ESQA." Then
        ResetSheetFormats ws
        foundCells = foundCells + FormulasListe(ws, localerrorcount)
      End If
      If Abbruch Then Exit For
    Next ws
  End If
  Application.ScreenUpdating = True
  
  Dim tStr As String
  tStr = ""
  'If FullVersion = False Then tStr = "Demoversion: Es werden nur die ersten 10 Spalten * 40 Zeilen eingef|fffd|rbt. Die genannten Mengen beziehen sich auf das Gesamtdokument!" & vbLf & vbLf
  If FullVersion = False Then tStr = FMT0("MCOL_1")
  
  UpdateStatus "", -1
  StatusForm.Hide
  
  CheckErrorMessage
  
  If Not Abbruch Then
    If theResbook Is Nothing Then
'      MsgBox tStr & IIf(ColourCurrentTable = True, "Auswertung f|fffd|r Tabelle '" & ActiveSheet.name & "'" & vbLf & vbLf, "") & _
'        "Es wurde(n) " & foundCells & " Zellen mit den von Ihnen angegebenen Suchw|fffd|rtern in den Listen '" & ComplexFormulas.AllListItems & "' gefunden." & vbLf & _
'        localerrorcount & " Zelle(n) konnten nicht in Deutsch analysiert werden, bitte verwenden Sie ggf. zus|fffd|tzlich englische Suchw|fffd|rter (IF, SUM etc)", vbInformation, "ESQA " & MyVersion
      MsgBox tStr & IIf(ColourCurrentTable = True, FMT1("MCOL_2", ActiveSheet.name), "") & _
        FMT2("MKOMPLEXEL_1", foundCells, ComplexFormulas.AllListItems) & IIf(localerrorcount > 0, FMT1("MKOMPLEXEL_13", localerrorcount) & vbCrLf & vbCrLf, "") & GetErrorTexts, vbInformation, "ESQA " & MyVersion
    Else
'      If MsgBox(tStr & IIf(ColourCurrentTable = True, "Auswertung f|fffd|r Tabelle '" & ActiveSheet.name & "'" & vbLf & vbLf, "") & _
'        "Es wurde(n) " & foundCells & " Zellen mit den von Ihnen angegebenen Suchw|fffd|rtern in den Listen '" & ComplexFormulas.AllListItems & "' gefunden." & vbLf & _
'        localerrorcount & " Zelle(n) konnten nicht in Deutsch analysiert werden, bitte verwenden Sie ggf. zus|fffd|tzlich englische Suchw|fffd|rter (IF, SUM etc)" & vbLf & vbLf & "Wollen Sie zum Ergebnisblatt wechseln?", vbYesNo, "ESQA " & MyVersion) = vbYes Then
      If MsgBox(tStr & IIf(ColourCurrentTable = True, FMT1("MCOL_2", ActiveSheet.name), "") & _
        FMT2("MKOMPLEXEL_1", foundCells, ComplexFormulas.AllListItems) & IIf(localerrorcount > 0, FMT1("MKOMPLEXEL_13", localerrorcount) & vbCrLf & vbCrLf, "") & vbCrLf & vbCrLf & FMT0("MKOMPLEXEL_2"), vbYesNo, "ESQA " & MyVersion) = vbYes Then
        theResbook.Sheets("ESQA.Listensuche").Activate
      End If
    
      'theResbook.Sheets("ESQA.Info").Hyperlinks.Add Anchor:=theResbook.Sheets("ESQA.Info").Cells(INFO_ComplexListY, 1), Address:="", SubAddress:= _
      '    "'Listensuche'!A1", TextToDisplay:="Es wurde(n) " & foundCells & " Zellen mit den von Ihnen angegebenen Suchw|fffd|rtern in den Listen '" & ComplexFormulas.AllListItems & "' gefunden."
      theResbook.Sheets("ESQA.Info").Hyperlinks.Add Anchor:=theResbook.Sheets("ESQA.Info").Cells(INFO_ComplexListY, 1), Address:="", SubAddress:= _
          "'" & FMT0("MKOMPLEXEL_3") & "'!A1", TextToDisplay:=FMT2("MKOMPLEXEL_4", foundCells, ComplexFormulas.AllListItems)
    
    End If
  End If
  
  
'  MsgBox restext, vbInformation

  
  Set ComplexFormulas.SelectedListItems = Nothing
  
  EnableExcel calc, bScreenUpdating, bEnableEvents
  
  Exit Sub
CatchError:
  G_ErrorCount = G_ErrorCount + 1
  G_ErrorText = G_ErrorText & "ESQAFormulasListe: (" & Err.Number & ") - " & Err.Description & vbLf
  Resume Next
End Sub

Function FormulasListe(ByRef ws As Worksheet, ByRef localerrorcount As Long) As Long

 On Error GoTo CatchError
  
  'PrintHeader "Tabelle: '" & ActiveSheet.name & "'"
  PrintHeader FMT1("CONSTANTS_1", ws.name)
  
  If Not theResbook Is Nothing Then
    'theRessheet.Cells(theRessheetY, 1) = "0 Zellen mit diesen Suchw|fffd|rtern gefunden"
    theRessheet.Cells(theRessheetY, 1) = FMT0("MKOMPLEXEL_5")
    theRessheetY = theRessheetY + 2
  End If
  
  If ComplexFormulas.SelectedListItems Is Nothing Then
'    MsgBox "Error ComplexFormulas.SelectedListItems"
    Exit Function
  End If
  
  
  Dim foundCells As Long
  foundCells = 0
  Dim c As Range
  
  Dim localerror As New Collection
  
  Dim errBereich As String
  Dim lineCells As Range
  Dim lineCount As Long
  Dim totalLineAmount As Long
  Dim lastRow As Long
  ws.ScrollArea = ""
  lastRow = GetLastRow(ws)
  
  If lastRow > 0 Then
                
    totalLineAmount = lastRow
    
    If lastRow > 40 And FullVersion = False Then
      lastRow = 40
    End If
    
    For lineCount = 1 To lastRow



            Set lineCells = GetFormulaRangeLine(ws, lineCount)
      
            If Not lineCells Is Nothing Then
                For Each c In lineCells
                      errBereich = "WS:" & c.Parent.name & "!" & c.Address
  
                          Dim i As Long
                          Dim foundOne As Boolean
                          foundOne = False
                          Dim uformula As String
                          
                          If Not FormulaLocalOK(c) Then
                            localerror.Add RemoveText(c.Address, "$")
                            localerrorcount = localerrorcount + 1
                          Else
                            uformula = UCase(c.FormulaLocal)
                            
                            Dim item As ComplexEntry
                            For Each item In ComplexFormulas.SelectedListItems
                              
                              If item.m_Typ = 0 Then
                                For i = 1 To item.m_KW.Count
                                  If InStr(uformula, item.m_KW(i)) > 0 Then
                                    foundOne = True
                                    If Not theResbook Is Nothing Then
                                      ' theRessheet.Cells(theRessheetY, 1) = RemoveText(c.Address, "$")
                                      theRessheet.Cells(theRessheetY, 1).FormulaLocal = "=HYPERLINK(" & Chr(34) & Replace(c.Parent.Parent.FullName, ".ANALYSE.ESQA", "") & "#'" & c.Parent.name & "'!" & c.Address & Chr(34) & ";" & Chr(34) & RemoveText(c.Address, "$") & Chr(34) & ")"
                                      'theRessheet.Cells(theRessheetY, 2) = "Zelle enth|fffd|lt '" & item.m_KW(i) & "'"
                                      theRessheet.Cells(theRessheetY, 2) = FMT1("MKOMPLEXEL_6", item.m_KW(i))
                                      theRessheet.Cells(theRessheetY, 3) = "'" & GetFormula(c)
                                      theRessheetY = theRessheetY + 1
                                    End If
                                    
'                                    G_cTodo.ModifyContent "ESQACOMPLEX", ActiveSheet.name & "!" & RemoveText(c.Address, "$"), True
                                    c.Interior.ColorIndex = item.m_Farbe
                                    'AddMyComment c, "Zelle enth|fffd|lt '" & item.m_KW(i) & "'", 160, 24
                                    AddMyComment c, FMT1("MKOMPLEXEL_6", item.m_KW(i)), 160, 24
                                  End If
                                Next i
                              Else
                              
                                Dim truecnt As Long
                                truecnt = 0
                                For i = 1 To item.m_KW.Count
                                  Dim pos As Long
                                  pos = 1
                                  Do
                                    pos = InStr(pos, uformula, item.m_KW(i))
                                    If pos <= 0 Then Exit Do
                                    pos = pos + 1
                                    truecnt = truecnt + 1
                                  Loop
                                Next i
                              
                                If truecnt >= item.m_Typ1Anzahl Then
                                    foundOne = True
                                    If Not theResbook Is Nothing Then
                                      ' theRessheet.Cells(theRessheetY, 1) = RemoveText(c.Address, "$")
                                      theRessheet.Cells(theRessheetY, 1).FormulaLocal = "=HYPERLINK(" & Chr(34) & Replace(c.Parent.Parent.FullName, ".ANALYSE.ESQA", "") & "#'" & c.Parent.name & "'!" & c.Address & Chr(34) & ";" & Chr(34) & RemoveText(c.Address, "$") & Chr(34) & ")"
                                      'theRessheet.Cells(theRessheetY, 2) = "Bedingung '" & item.m_|fffd|berschrift & "' erf|fffd|llt"
                                      theRessheet.Cells(theRessheetY, 2) = FMT1("MKOMPLEXEL_7", item.m_|fffd|berschrift)
                                      theRessheet.Cells(theRessheetY, 3) = "'" & GetFormula(c)
                                      theRessheetY = theRessheetY + 1
                                    End If
                                    
                                    c.Interior.ColorIndex = item.m_Farbe
                                    'AddMyComment c, "Bedingung '" & item.m_|fffd|berschrift & "' erf|fffd|llt (" & truecnt & " x erf|fffd|llt)", 600, 24
                                    AddMyComment c, FMT2("MKOMPLEXEL_8", item.m_|fffd|berschrift, truecnt), 600, 24
                                End If
                              
                              End If
                              
                            Next item
                            If Abbruch Then Exit For
                          End If
                            
                          If foundOne Then
                            foundCells = foundCells + 1
                          End If
                          
                          If Abbruch Then Exit For
                        Next c
                      End If
          If lineCount Mod 5 = 0 Then
            'UpdateStatus "Konstanten '" & ActiveSheet.name & "'", CDbl(cnt) / CDbl(totalamount)
            UpdateStatus FMT1("START_10", ws.name), CDbl(lineCount) / CDbl(totalLineAmount)
          End If
          If Abbruch Then Exit For
        Next lineCount
  End If
  
    
  If Not theResbook Is Nothing Then
    theRessheet.Columns("B:B").EntireColumn.AutoFit
    'theRessheet.Cells(theRessheetY, 1) = foundCells & " Zelle(n) mit diesen Suchw|fffd|rtern gefunden."
    theRessheet.Cells(theRessheetY, 1) = FMT1("MKOMPLEXEL_10", foundCells)
    theRessheetY = theRessheetY + 2
    
    If localerror.Count > 0 Then
      'theRessheet.Cells(theRessheetY, 1) = localerror.Count & " Zelle(n), die in Tabelle: '" & ActiveSheet.name & "' nicht analysiert werden konnten,"
      theRessheet.Cells(theRessheetY, 1) = FMT2("MKOMPLEXEL_11", localerror.Count, ws.name)
      theRessheet.Cells(theRessheetY, 1).Font.bold = True
      theRessheetY = theRessheetY + 1
      'theRessheet.Cells(theRessheetY, 1) = "weil die Formelzelle in der lokalen Sprache zu lang war:"
      theRessheet.Cells(theRessheetY, 1) = FMT0("MKOMPLEXEL_12")
      theRessheet.Cells(theRessheetY, 1).Font.bold = True
      theRessheetY = theRessheetY + 1
      
      Dim k As Long
      k = 1
      For i = 1 To localerror.Count
        theRessheet.Cells(theRessheetY, k) = localerror(i)
        k = k + 1
        If k = 6 Then
          k = 1
          theRessheetY = theRessheetY + 1
        End If
      Next i
      theRessheetY = theRessheetY + 2
    End If
  
  End If
  
  Set localerror = Nothing
  
  FormulasListe = foundCells
  
  Exit Function
CatchError:
  ErrorHandler "FormulasListe", errBereich, c
  Resume Next
End Function




Attribute VB_Name = "MKomplexeFormelnTextFinden"
Option Explicit

Sub ESQAFormulasWithText()
On Error GoTo CatchError
  
  Dim calc As Long
  Dim bEnableEvents As Boolean
  Dim bScreenUpdating As Boolean
  DisableExcel calc, bScreenUpdating, bEnableEvents
  
  Dim foundCells As Long
  Dim foundClones As Long
  
  Dim localerrorcount As Long
  localerrorcount = 0
  
  foundCells = 0
  foundClones = 0
  Application.ScreenUpdating = False
  If ColourCurrentTable Then
    ResetSheetFormats ActiveSheet
    foundCells = foundCells + FormulasWithText(ActiveSheet, localerrorcount)
  Else
    Dim ws As Worksheet
    For Each ws In ActiveWorkbook.Worksheets
      If Left(ws.name, 5) <> "ESQA." Then
          ResetSheetFormats ws
          foundCells = foundCells + FormulasWithText(ws, localerrorcount)
      End If
      If Abbruch Then Exit For
    Next ws
  End If
  Application.ScreenUpdating = True
  
  
  Dim tStr As String
  tStr = ""
  'If FullVersion = False Then tStr = "Demoversion: Es werden nur die ersten 10 Spalten * 40 Zeilen eingef|fffd|rbt. Die genannten Mengen beziehen sich auf das Gesamtdokument!" & vbLf & vbLf
  If FullVersion = False Then tStr = FMT0("MCOL_1")
  
  UpdateStatus "", -1
  StatusForm.Hide
  
  CheckErrorMessage
  
  If theResbook Is Nothing Then
'    MsgBox tStr & IIf(ColourCurrentTable = True, "Auswertung f|fffd|r Tabelle '" & ActiveSheet.name & "'" & vbLf & vbLf, "") & _
'      "Es wurde(n) " & foundCells & " Zellen mit den von Ihnen angegebenen Texten '" & ComplexFormulas.FindTxt & "' gefunden." & vbLf & _
'      localerrorcount & " Zelle(n) konnten nicht in Deutsch analysiert werden, bitte verwenden Sie ggf. zus|fffd|tzlich englische Suchw|fffd|rter (IF, SUM etc)", vbInformation, "ESQA " & MyVersion
    MsgBox tStr & IIf(ColourCurrentTable = True, FMT1("MCOL_2", ActiveSheet.name), "") & _
      FMT3("MKOMPLEXET_1", foundCells, ComplexFormulas.FindTxt, IIf(localerrorcount > 0, FMT1("MKOMPLEXET_6", localerrorcount) & vbCrLf, "")) & GetErrorTexts, vbInformation, "ESQA " & MyVersion
  Else
'    If MsgBox(tStr & IIf(ColourCurrentTable = True, "Auswertung f|fffd|r Tabelle '" & ActiveSheet.name & "'" & vbLf & vbLf, "") & _
'      "Es wurde(n) " & foundCells & " Zellen mit den von Ihnen angegebenen Texten '" & ComplexFormulas.FindTxt & "' gefunden." & vbLf & _
'      localerrorcount & " Zelle(n) konnten nicht in Deutsch analysiert werden, bitte verwenden Sie ggf. zus|fffd|tzlich englische Suchw|fffd|rter (IF, SUM etc)" & vbLf & vbLf & "Wollen Sie zum Ergebnisblatt wechseln?", vbYesNo, "ESQA " & MyVersion) = vbYes Then
    If MsgBox(tStr & IIf(ColourCurrentTable = True, FMT1("MCOL_2", ActiveSheet.name), "") & _
      FMT3("MKOMPLEXET_2", foundCells, ComplexFormulas.FindTxt, IIf(localerrorcount > 0, FMT1("MKOMPLEXET_6", localerrorcount) & vbCrLf, "")), vbYesNo, "ESQA " & MyVersion) = vbYes Then
      theResbook.Sheets("ESQA.Textsuche").Activate
    End If
  
    'theResbook.Sheets("ESQA.Info").Hyperlinks.Add Anchor:=theResbook.Sheets("ESQA.Info").Cells(INFO_ComplexTextY, 1), Address:="", SubAddress:= _
    '    "'Textsuche'!A1", TextToDisplay:="Es wurde(n) " & foundCells & " Zellen mit den von Ihnen angegebenen Texten '" & ComplexFormulas.FindTxt & "' gefunden."
    theResbook.Sheets("ESQA.Info").Hyperlinks.Add Anchor:=theResbook.Sheets("ESQA.Info").Cells(INFO_ComplexTextY, 1), Address:="", SubAddress:= _
        "'" & FMT0("MKOMPLEXET_3") & "'!A1", TextToDisplay:=FMT2("MKOMPLEXET_4", foundCells, ComplexFormulas.FindTxt)
  
  End If
  
  
  
'  MsgBox restext, vbInformation

  EnableExcel calc, bScreenUpdating, bEnableEvents
  
  Exit Sub
CatchError:
  G_ErrorCount = G_ErrorCount + 1
  G_ErrorText = G_ErrorText & "ESQAFormulasWithText: (" & Err.Number & ") - " & Err.Description & vbLf
  Resume Next
End Sub

Function FormulasWithText(ByRef ws As Worksheet, ByRef localerrorcount As Long) As Long

On Error GoTo CatchError
  
  If Not theResbook Is Nothing Then
    'theRessheet.Cells(theRessheetY, 1) = "Tabelle: '" & ActiveSheet.name & "'"
    theRessheet.Cells(theRessheetY, 1) = FMT1("CONSTANTS_1", ws.name)
    theRessheet.Cells(theRessheetY, 1).Font.bold = True
    theRessheetY = theRessheetY + 1
  End If
  
  
  ' die collection aufbauen
  Dim col As New Collection
  
  Dim pos As Long
  Dim Param As String
  Param = ComplexFormulas.FindTxt
  
  Do
    pos = InStr(Param, ",")
    If pos <= 0 Then Exit Do
    If Len(Left(Param, pos - 1)) > 0 Then
      col.Add Left(Param, pos - 1)
    End If
    Param = Mid(Param, pos + 1)
  Loop
  
  If Len(Param) > 0 Then
    col.Add Param
  End If
  
  
  Dim foundCells As Long
  foundCells = 0
  
  Dim c As Range
  Dim errBereich As String
  Dim lineCells As Range
  Dim lineCount As Long
  Dim totalLineAmount As Long
  Dim lastRow As Long
  ws.ScrollArea = ""
  lastRow = GetLastRow(ws)
  
  If lastRow > 0 Then
                
    totalLineAmount = lastRow
    
    If lastRow > 40 And FullVersion = False Then
      lastRow = 40
    End If
    
    Dim localerror As New Collection
    
    
    For lineCount = 1 To lastRow
            Set lineCells = GetFormulaRangeLine(ws, lineCount)
      
            If Not lineCells Is Nothing Then
                For Each c In lineCells
                            
                            errBereich = "WS:" & c.Parent.name & "!" & c.Address
  
                            Dim i As Long
                            Dim foundOne As Boolean
                            foundOne = False
                            Dim uformula As String
                            
                            If Not FormulaLocalOK(c) Then
                              localerror.Add RemoveText(c.Address, "$")
                              localerrorcount = localerrorcount + 1
                            Else
                              uformula = UCase(c.FormulaLocal)
                              For i = 1 To col.Count
                                If InStr(uformula, col(i)) > 0 Then
                                  foundOne = True
                                  If Not theResbook Is Nothing Then
                                    ' theRessheet.Cells(theRessheetY, 1) = RemoveText(c.Address, "$")
                                    theRessheet.Cells(theRessheetY, 1).FormulaLocal = "=HYPERLINK(" & Chr(34) & Replace(c.Parent.Parent.FullName, ".ANALYSE.ESQA", "") & "#'" & c.Parent.name & "'!" & c.Address & Chr(34) & ";" & Chr(34) & RemoveText(c.Address, "$") & Chr(34) & ")"
                                    theRessheet.Cells(theRessheetY, 2) = "'" & GetFormula(c)
                                    theRessheetY = theRessheetY + 1
                                  End If
                                  
                                  ' c.Interior.ColorIndex = 8
                                  If foundCells <= G_MarkCellsAmount Then
                                    If G_ColorCells Then
                                      G_CellFormats("ESQAComplexFormulas").SetFormat c
                                    End If
                                    'AddMyComment c, "Zelle enth|fffd|lt '" & col(i) & "'", 160, 24
                                    AddMyComment c, FMT1("MKOMPLEXEL_6", col(i)), 160, 24
                                  End If
                                End If
                              Next i
                            End If
                            
                            If foundOne Then
                              foundCells = foundCells + 1
                            End If
    
                Next c
            End If
  
            If lineCount Mod 5 = 0 Then
              'UpdateStatus "Konstanten '" & ActiveSheet.name & "'", CDbl(cnt) / CDbl(totalamount)
              UpdateStatus FMT1("START_10", ws.name), CDbl(lineCount) / CDbl(totalLineAmount)
            End If
            If Abbruch Then Exit For
    Next lineCount
  End If
      
  
  If Not theResbook Is Nothing Then
    'theRessheet.Cells(theRessheetY, 1) = foundCells & " Zelle(n) mit diesen Suchw|fffd|rtern gefunden."
    theRessheet.Cells(theRessheetY, 1) = FMT1("MKOMPLEXEL_10", foundCells)
    theRessheetY = theRessheetY + 2
  
    If localerror.Count > 0 Then
      'theRessheet.Cells(theRessheetY, 1) = localerror.Count & " Zelle(n), die in Tabelle: '" & ActiveSheet.name & "' nicht analysiert werden konnten,"
      theRessheet.Cells(theRessheetY, 1) = FMT2("MKOMPLEXEL_11", localerror.Count, ws.name)
      theRessheet.Cells(theRessheetY, 1).Font.bold = True
      theRessheetY = theRessheetY + 1
      'theRessheet.Cells(theRessheetY, 1) = "weil die Formelzelle in der lokalen Sprache zu lang war:"
      theRessheet.Cells(theRessheetY, 1) = FMT0("MKOMPLEXEL_12")
      theRessheet.Cells(theRessheetY, 1).Font.bold = True
      theRessheetY = theRessheetY + 1
      
      Dim k As Long
      k = 1
      For i = 1 To localerror.Count
        theRessheet.Cells(theRessheetY, k) = localerror(i)
        k = k + 1
        If k = 6 Then
          k = 1
          theRessheetY = theRessheetY + 1
        End If
      Next i
      theRessheetY = theRessheetY + 2
    End If
    
  End If
  
  Set localerror = Nothing
    
  Set col = Nothing
  
  FormulasWithText = foundCells
  Exit Function
CatchError:
  ErrorHandler "FormulasWithText", errBereich, c
  Resume Next
End Function


Attribute VB_Name = "MMatrix"
Option Explicit

Sub ESQAMatrix()
On Error GoTo CatchError
  CheckStartupStuff
  
  Dim calc As Long
  Dim bEnableEvents As Boolean
  Dim bScreenUpdating As Boolean
  DisableExcel calc, bScreenUpdating, bEnableEvents
  
  Dim foundCells As Long
  Dim foundClones As Long
  
  foundCells = 0
  foundClones = 0
  Application.ScreenUpdating = False
  If ColourCurrentTable Then
    ResetSheetFormats ActiveSheet
    foundCells = foundCells + Matrix(ActiveSheet)
  Else
    Dim ws As Worksheet
    For Each ws In ActiveWorkbook.Worksheets
      If Left(ws.name, 5) <> "ESQA." Then
        ResetSheetFormats ws
        foundCells = foundCells + Matrix(ws)
      End If
      If Abbruch Then Exit For
    Next ws
  End If
  Application.ScreenUpdating = True
  
  Dim tStr As String
  tStr = ""
  'If FullVersion = False Then tStr = "Demoversion: Es werden nur die ersten 10 Spalten * 40 Zeilen eingef|fffd|rbt. Die genannten Mengen beziehen sich auf das Gesamtdokument!" & vbLf & vbLf
  If FullVersion = False Then tStr = FMT0("MCOL_1")
  
  UpdateStatus "", -1
  StatusForm.Hide
  
  CheckErrorMessage
  
  If Not Abbruch Then
    If theResbook Is Nothing Then
      'MsgBox tStr & IIf(ColourCurrentTable = True, "Auswertung f|fffd|r Tabelle '" & ActiveSheet.name & "'" & vbLf & vbLf, "") & _
      '  "Es wurde(n) " & foundCells & " Matrix-Formelzelle(n) gefunden.", vbInformation, "ESQA " & MyVersion
      MsgBox tStr & IIf(ColourCurrentTable = True, FMT1("MCOL_2", ActiveSheet.name), "") & _
        FMT1("MMATRIX_1", foundCells) & GetErrorTexts, vbInformation, "ESQA " & MyVersion
    Else
      'If MsgBox(tStr & IIf(ColourCurrentTable = True, "Auswertung f|fffd|r Tabelle '" & ActiveSheet.name & "'" & vbLf & vbLf, "") & _
      '  "Es wurde(n) " & foundCells & " Matrix-Formelzelle(n) gefunden." & vbLf & vbLf & "Wollen Sie zum Ergebnisblatt wechseln?", vbYesNo, "ESQA " & MyVersion) = vbYes Then
      If MsgBox(tStr & IIf(ColourCurrentTable = True, FMT1("MCOL_2", ActiveSheet.name), "") & _
        FMT1("MMATRIX_2", foundCells), vbYesNo, "ESQA " & MyVersion) = vbYes Then
        theResbook.Sheets("ESQA.Matrix-Formeln").Activate
      End If
    
      'theResbook.Sheets("ESQA.Info").Hyperlinks.Add Anchor:=theResbook.Sheets("ESQA.Info").Cells(INFO_ComplexMatrixY, 1), Address:="", SubAddress:= _
      '    "'Matrix-Formeln'!A1", TextToDisplay:="Es wurde(n) " & foundCells & " Matrix-Formelzelle(n) gefunden."
      theResbook.Sheets("ESQA.Info").Hyperlinks.Add Anchor:=theResbook.Sheets("ESQA.Info").Cells(INFO_ComplexMatrixY, 1), Address:="", SubAddress:= _
          "'" & FMT0("MMATRIX_3") & "'!A1", TextToDisplay:=FMT1("MMATRIX_1", foundCells)
    
    End If
  End If
  
  
'  MsgBox restext, vbInformation

  EnableExcel calc, bScreenUpdating, bEnableEvents
  
  Exit Sub
CatchError:
  G_ErrorCount = G_ErrorCount + 1
  G_ErrorText = G_ErrorText & "ESQAMatrix: (" & Err.Number & ") - " & Err.Description & vbLf
  Resume Next
End Sub

Function Matrix(ByRef ws As Worksheet) As Long

On Error GoTo CatchError
  
  If Not theResbook Is Nothing Then
    'theRessheet.Cells(theRessheetY, 1) = "Tabelle: '" & ActiveSheet.name & "'"
    theRessheet.Cells(theRessheetY, 1) = FMT1("CONSTANTS_1", ws.name)
    theRessheet.Cells(theRessheetY, 1).Font.bold = True
    theRessheetY = theRessheetY + 1
  End If
  
  Dim foundCells As Long
  foundCells = 0
  
  Dim c As Range
  Dim errBereich As String
  Dim lineCells As Range
  Dim lineCount As Long
  Dim totalLineAmount As Long
  Dim lastRow As Long
  ws.ScrollArea = ""
  lastRow = GetLastRow(ws)
  
  If lastRow > 0 Then
                
    totalLineAmount = lastRow
    
    If lastRow > 40 And FullVersion = False Then
      lastRow = 40
    End If
    
    For lineCount = 1 To lastRow
            Set lineCells = GetFormulaRangeLine(ws, lineCount)
      
            If Not lineCells Is Nothing Then
                For Each c In lineCells
                  errBereich = "WS:" & c.Parent.name & "!" & c.Address
  
                  If c.HasArray Then
                
                    foundCells = foundCells + 1
                    If Not theResbook Is Nothing Then
                      ' theRessheet.Cells(theRessheetY, 1) = RemoveText(c.Address, "$")
                      theRessheet.Cells(theRessheetY, 1).FormulaLocal = "=HYPERLINK(" & Chr(34) & Replace(c.Parent.Parent.FullName, ".ANALYSE.ESQA", "") & "#'" & c.Parent.name & "'!" & c.Address & Chr(34) & ";" & Chr(34) & RemoveText(c.Address, "$") & Chr(34) & ")"
                      theRessheet.Cells(theRessheetY, 2) = "'{" & GetFormula(c) & "}"
                      theRessheetY = theRessheetY + 1
                    End If
                    
                    If foundCells <= G_MarkCellsAmount Then
                      If G_ColorCells Then
                        G_CellFormats("ESQAComplexFormulas").SetFormat c
                      End If
                      AddMyComment c, FMT0("MMATRIX_7"), 160, 24
                    End If
                  End If
                Next c
            End If
    
      If lineCount Mod 5 = 0 Then
        'UpdateStatus "Konstanten '" & ActiveSheet.name & "'", CDbl(cnt) / CDbl(totalamount)
        UpdateStatus FMT1("START_10", ws.name), CDbl(lineCount) / CDbl(totalLineAmount)
      End If
      If Abbruch Then Exit For
    Next lineCount
  End If
  
    
  If Not theResbook Is Nothing Then
    'theRessheet.Cells(theRessheetY, 1) = foundCells & " Matrix-Formelzelle(n) gefunden."
    theRessheet.Cells(theRessheetY, 1) = FMT1("MMATRIX_6", foundCells)
    theRessheetY = theRessheetY + 2
  End If
  
  Matrix = foundCells
  Exit Function
CatchError:
  ErrorHandler "Matrix", errBereich, c
  Resume Next
End Function




Attribute VB_Name = "OptionsDlg"
Attribute VB_Base = "0{81E8B205-0910-422D-AEC2-0311BF4FE0FB}{039D9D62-C0B3-4DC7-AB4F-38DBDFEFE69E}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Sub cmdOK_Click()
    If Val(MarkCellsAmount) <= 0 Then
      MarkCellsAmount = 1
    End If
    
    If Val(MarkCellsAmount) > 2000 Then
      MarkCellsAmount = 2000
    End If
    
    OptionsDlg.Hide

End Sub
Attribute VB_Name = "PleaseWait"
Attribute VB_Base = "0{4E15004E-8DC5-40D1-8C75-806C2DE65D74}{C91FB99E-D6F4-46FD-BDE2-E2476DA47A60}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Private Sub UserForm_Initialize()
  gTranslation.TranslateForm Me
End Sub
Attribute VB_Name = "RangeRetriever"
Option Explicit

Dim theCellAddress As String
Dim theCellFormula As String


Sub ESQACheckExternalReferences()
  CheckStartupStuff
  
  If ActiveWorkbook Is Nothing Then
    'MsgBox "Bitte |fffd|ffnen Sie erst eine Excel-Datei", vbInformation, "ESQA " & MyVersion
    MsgBox FMT0("RANGERET_1"), vbInformation, "ESQA " & MyVersion
    Exit Sub
  End If
  
  
  CreateResbook ActiveSheet

  'CreateRessheet "Verkn|fffd|pfte Dateien", "Verkn|fffd|pfte Dateien", ActiveSheet
  CreateRessheet FMT0("RANGERET_2"), FMT0("RANGERET_2"), ActiveSheet
  'SetRessheet "Verkn|fffd|pfte Dateien"
  SetRessheet FMT0("RANGERET_2")

'  If Not theResbook Is Nothing Then
'    theRessheet.Cells(theRessheetY, 1) = "Pr|fffd|fung verkn|fffd|pfter Dateien (" & Now() & ")"
'    theRessheet.Cells(theRessheetY, 1).Font.Bold = True
'    theRessheetY = theRessheetY + 1
'  End If


  Dim aLinks
  Dim i As Long
  aLinks = ActiveWorkbook.LinkSources(xlExcelLinks)
  If Not IsEmpty(aLinks) Then
      For i = 1 To UBound(aLinks)
        If FileExists(GetUNCPath(CStr(aLinks(i)))) Then
          'theRessheet.Cells(theRessheetY, 1) = GetUNCPath(CStr(aLinks(i))) & " (Datei vorhanden)"
          theRessheet.Cells(theRessheetY, 1) = FMT1("RANGERET_3", GetUNCPath(CStr(aLinks(i))))
        Else
          'theRessheet.Cells(theRessheetY, 1) = GetUNCPath(CStr(aLinks(i))) & " (Datei NICHT vorhanden!)"
          theRessheet.Cells(theRessheetY, 1) = FMT1("RANGERET_4", GetUNCPath(CStr(aLinks(i))))
'          G_cTodo.ModifyContent "ESQALINK", GetUNCPath(CStr(aLinks(i))), True
        End If
        theRessheetY = theRessheetY + 1
      Next i
    'theRessheet.Cells(theRessheetY, 1) = UBound(aLinks) & " verkn|fffd|pfte Datei(en)."
    theRessheet.Cells(theRessheetY, 1) = FMT1("RANGERET_5", UBound(aLinks))
    theRessheetY = theRessheetY + 1
    'theResbook.Sheets("ESQA.Info").Hyperlinks.Add Anchor:=theResbook.Sheets("ESQA.Info").Cells(INFO_LinkedY, 1), Address:="", SubAddress:= _
    '    "'Verkn|fffd|pfte Dateien'!A1", TextToDisplay:=UBound(aLinks) & " verkn|fffd|pfte Datei(en)."
    theResbook.Sheets("ESQA.Info").Hyperlinks.Add Anchor:=theResbook.Sheets("ESQA.Info").Cells(INFO_LinkedY, 1), Address:="", SubAddress:= _
        "'" & FMT0("RANGERET_2") & "'!A1", TextToDisplay:=FMT1("RANGERET_5", UBound(aLinks))
  
  Else
    'theRessheet.Cells(theRessheetY, 1) = "Keine verkn|fffd|pften Dateien vorhanden."
    theRessheet.Cells(theRessheetY, 1) = FMT0("RANGERET_6")
    theRessheetY = theRessheetY + 1
    'theResbook.Sheets("ESQA.Info").Hyperlinks.Add Anchor:=theResbook.Sheets("ESQA.Info").Cells(INFO_LinkedY, 1), Address:="", SubAddress:= _
    '    "'Verkn|fffd|pfte Dateien'!A1", TextToDisplay:="Keine verkn|fffd|pften Dateien vorhanden."
    theResbook.Sheets("ESQA.Info").Hyperlinks.Add Anchor:=theResbook.Sheets("ESQA.Info").Cells(INFO_LinkedY, 1), Address:="", SubAddress:= _
        "'" & FMT0("RANGERET_2") & "'!A1", TextToDisplay:=FMT0("RANGERET_6")
  End If
'  G_cTodo.RemoveAllNonModifiedContents "ESQALINK", True
'  theRessheet.Activate
  
End Sub

Sub CheckForLinkSources()
  
  Dim aLinks
  Dim i As Long
  aLinks = ActiveWorkbook.LinkSources(xlExcelLinks)
  If Not IsEmpty(aLinks) Then
      For i = 1 To UBound(aLinks)
          Debug.Print "Link " & i & ":" & Chr(13) & aLinks(i)
      Next i
  End If
End Sub

Function HasExternalLinks(wb As Workbook) As Boolean
  If Not IsEmpty(wb.LinkSources(xlExcelLinks)) Then
    HasExternalLinks = True
  Else
    HasExternalLinks = False
  End If
End Function

Function AllLinksOpen(wb As Workbook) As Boolean
  Dim aLinks
  Dim i As Long
  aLinks = wb.LinkSources(xlExcelLinks)
  If Not IsEmpty(aLinks) Then
      For i = 1 To UBound(aLinks)
          Dim lnk As String
          lnk = GetFileNameAndExtension(aLinks(i))
          Dim wbc As Workbook
          Dim found As Boolean
          found = False
          For Each wbc In Application.Workbooks
            If UCase(GetFileNameAndExtension(wbc.name)) = UCase(lnk) Then
              found = True
              Exit For
            End If
          Next wbc
          If Not found Then
            AllLinksOpen = False
            Exit Function
          End If
      Next i
  End If
  AllLinksOpen = True
End Function


Function OpenAllLinks(wb As Workbook) As Boolean
  Dim aLinks
  Dim i As Long
  aLinks = wb.LinkSources(xlExcelLinks)
  If Not IsEmpty(aLinks) Then
      For i = 1 To UBound(aLinks)
          Dim lnk As String
          lnk = aLinks(i)
          
          Dim wbc As Workbook
          Dim found As Boolean
          found = False
          For Each wbc In Application.Workbooks
            If UCase(wbc.FullName) = UCase(lnk) Then
              found = True
              Exit For
            End If
          Next wbc
          If Not found Then
            If Not GetFile(CStr(aLinks(i)), True) Then
              G_AI(AI_ForgottenCells).AddResultText lnk & " " & FMT0("MSTART_92")
              OpenAllLinks = False
              Exit Function
            Else
              G_AI(AI_ForgottenCells).AddResultText lnk
            End If
          Else
            G_AI(AI_ForgottenCells).AddResultText lnk
          End If
      Next i
  End If
  wb.Activate
  OpenAllLinks = True
End Function



Function GetFile(filename As String, writeProt As Boolean) As Boolean
  Dim msgBoxText                As String
  
  GetFile = True
  ' |fffd|ffnen der Datei - Bei Error auf Passwort pr|fffd|fen
  On Error GoTo hatPasswort
  Application.EnableEvents = False
  
  Dim arr() As Boolean
  ReDim arr(Workbooks.Count)
  Dim i As Long
  For i = 1 To Workbooks.Count
    arr(i) = Workbooks(i).Saved
  Next i
  
  Workbooks.Open filename, False, writeProt, , "Testpasswort", , True, , , True, False, , False
  
  For i = 1 To Workbooks.Count - 1
    Workbooks(i).Saved = arr(i)
  Next i
  
  Application.EnableEvents = True
  GetFile = True
  Exit Function
  
hatPasswort:

  Application.EnableEvents = True
  GetFile = False

End Function




Function HasArrows(c As Range, prec As Boolean, onlyAreas As Boolean) As Boolean
    
  HasArrows = False
  
'  Dim ac As Range
'  Set ac = ActiveCell
    
  Dim stMsg As String
  If prec = True Then
    c.ShowPrecedents
  Else
    c.ShowDependents
  End If

  If Not NavArrow(c, 1, 1, prec) Then
    c.Parent.ClearArrows
    Exit Function
  End If
          
  If c.Address(external:=True) = ActiveCell.Address(external:=True) Then
    c.Parent.ClearArrows
    Exit Function
  End If
          
  If onlyAreas Then
    If InStr(Selection.Address, ":") > 0 Then
      HasArrows = True
    End If
  Else
    HasArrows = True
  End If
          
  c.Parent.ClearArrows

End Function




Function GetArrows(c As Range, ByRef col As Collection, prec As Boolean, onlyAreas As Boolean) As Boolean
    
  Dim ac As Range
'  Set ac = ActiveCell
  Set col = New Collection
    
  Dim rLast As Range, iLinkNum As Integer, iArrowNum As Integer
  Dim stMsg As String
  ' c.Select
  Application.GoTo c
  
  ' Wenn die Zelle nicht selektiert werden konnte, dann ist sie eine Zelle aus einem verbundenen Bereich und damit nicht sichtbar!
  If c.Address <> ActiveCell.Address Then
    Exit Function
  End If
  
  If prec = True Then
    ActiveCell.ShowPrecedents
  Else
    ActiveCell.ShowDependents
  End If

  Set rLast = c
  iArrowNum = 1
  iLinkNum = 1
  
  
  Dim wasNewArrow As Boolean
  
  wasNewArrow = True
  
  Do
      Do
          Application.GoTo rLast
          
          On Error Resume Next
          ActiveCell.NavigateArrow TowardPrecedent:=prec, ArrowNumber:=iArrowNum, LinkNumber:=iLinkNum
          
'          If Not NavArrow(ActiveCell, iArrowNum, iLinkNum, prec) Then
          If Err.Number <> 0 Then
            If wasNewArrow Then
              rLast.Parent.ClearArrows
              Application.GoTo rLast
'              MsgBox "Precedents are" & stMsg
              Exit Function
            Else
              Exit Do
            End If
          End If
          On Error GoTo 0
          
          ' If iLinkNum > 10 Then
          If rLast.Address(external:=True) = ActiveCell.Address(external:=True) Then
              rLast.Parent.ClearArrows
              Application.GoTo rLast
              If col.Count > 0 Then GetArrows = True
              Exit Function
          End If
          
          If onlyAreas Then
            If InStr(Selection.Address, ":") > 0 Then
              col.Add Selection
            End If
          Else
            col.Add Selection
          End If
          
          iLinkNum = iLinkNum + 1  ' try another  link
          If iLinkNum Mod 200 = 0 Then
            UpdateStatus FMT0("BW_1") & " (" & c.Parent.name & "!" & c.Address & " - " & iArrowNum & "-" & iLinkNum & ")", -1
            If Abbruch = True Then
              c.Parent.ClearArrows
              Exit Function
            End If
          End If
          wasNewArrow = False
       Loop
       iLinkNum = 1
       wasNewArrow = True
       iArrowNum = iArrowNum + 1  'try another arrow
  Loop
  rLast.Parent.ClearArrows
  Application.GoTo rLast

  If col.Count > 0 Then GetArrows = True
  
'  ac.Activate

End Function

Function NavArrow(ByVal c As Range, ByVal iArrowNum As Long, ByVal iLinkNum As Long, ByVal prez As Boolean) As Boolean
  On Error GoTo waserror
  c.NavigateArrow TowardPrecedent:=prez, ArrowNumber:=iArrowNum, LinkNumber:=iLinkNum
  NavArrow = True
  Exit Function
waserror:
  NavArrow = False
End Function

Sub TestGetDep()
  Dim ar As Collection
  Dim typear As Collection
'  GetDependents "=SUMME('D:\Dev\Excel-Sheet-QA\Linked File\[TestdateiESQA Verlinkt.xls]Tabelle1'!$A$1:$A$3)", ar, typear
End Sub

' Typen
' 1 - Einzelreferenz
' 2 - Einzelreferenz auf andere Tabelle
' 3 - Einzelreferenz auf andere Datei

' 11 - Bereichsreferenz
' 12 - Bereichsreferenz auf andere Tabelle
' 13 - Bereichsreferenz auf andere Datei

Function GetDependentsTEST(c As Range, ByRef ar As Collection, ByRef typear As Collection)
  GetDependentsTEST = False
  
  Dim s As String
  
  Dim restype As Long
  
  theCellAddress = c.Address
  theCellFormula = c.Formula
  
  s = c.Formula
  
'  Debug.Print c.Address & " - " & c.Formula
  
  If Len(s) = 0 Then Exit Function
  If Left(s, 1) <> "=" Then Exit Function
  s = Mid(s, 2)
  
  Dim tpos As Long
  Dim lasttoken As String
  Do
    Dim tok As String
    tok = GetNextToken(s)
    If Len(tok) = 0 Then Exit Do
              
    restype = 0
    
    Select Case lasttoken
      Case "(", ",", "+", "-", "*", "/", "^"
        If Left(tok, 1) = "'" Then
          tpos = InStr(2, tok, "'")
          If tpos > 0 Then
            tpos = InStr(tpos + 1, tok, ":")
            If tpos > 0 Then
              restype = 6
            Else
              restype = 3
            End If
          Else
            MsgBox "Internal ERROR, refstart missing end, cell: " & theCellAddress & " - formula: " & theCellFormula, vbCritical, "ESQA " & MyVersion
          End If
        Else
          tpos = InStr(2, tok, "!")
          If tpos > 0 And Left(tok, 1) <> "#" Then
            tpos = InStr(tpos + 1, tok, ":")
            If tpos > 0 Then
              restype = 5
            Else
              restype = 2
            End If
          Else
            tpos = InStr(tok, ":")
            If tpos > 0 Then
              restype = 4
            Else
              restype = 1
            End If
          End If
        End If
        
        Dim ok As Long
        ok = False
        If restype > 1 Then
          ok = True
        ElseIf restype = 1 Then
          If InStr(tok, "$") > 0 Then
            ok = True
          ElseIf Len(tok) = 1 And Left(tok, 1) >= "A" And Left(tok, 1) <= "Z" Then
            ok = True
          ElseIf Len(tok) = 2 And Left(tok, 1) >= "A" And Left(tok, 1) <= "Z" And Mid(tok, 2, 1) >= "0" And Mid(tok, 2, 1) <= "9" Then
            ok = True
          ElseIf Len(tok) = 2 And Left(tok, 1) >= "A" And Left(tok, 1) <= "Z" And Mid(tok, 2, 1) >= "A" And Mid(tok, 2, 1) <= "Z" Then
            ok = True
          End If
        End If
          
'        If ok = True Then
'          Debug.Print "VAR " & restype & " - " & tok
'        End If
    End Select
    
    lasttoken = tok
  Loop
  
End Function

Function GetNextToken(ByRef s As String)
  Dim tok As String
  Dim pos As Long
  pos = 1
  Do While pos <= Len(s)
    Select Case Mid(s, pos, 1)
      Case "(", ",", ")", "+", "-", "*", "/", "^"
        If Len(tok) > 0 Then
          Exit Do
        Else
          tok = tok & Mid(s, pos, 1)
          Exit Do
        End If
      Case "'"
        tok = GetFileRef(pos, s)
        Exit Do
      Case Else
        tok = tok & Mid(s, pos, 1)
        pos = pos + 1
    End Select
  Loop
  
  RemoveToken s, tok
  
  GetNextToken = tok
   
End Function

Function GetFileRef(ByRef pos As Long, s As String) As String
  
  Dim tok As String
  
  pos = pos + 1
  tok = "'" & GetUntil(s, pos, "'")
  If Len(tok) = 1 Then
    'MsgBox "Internal ERROR, refstart missing end, cell: " & theCellAddress & " - formula: " & theCellFormula, vbCritical, "ESQA " & MyVersion
    MsgBox FMT2("RANGERET_7", theCellAddress, theCellFormula), vbCritical, "ESQA " & MyVersion
  End If
  If Mid(s, pos, 1) = "!" Then
    pos = pos + 1
    tok = tok + "!"
    Do While pos <= Len(s)
      Select Case Mid(s, pos, 1)
        Case "(", ",", ")", "+", "-", "*", "/", "^"
          If Len(tok) > 0 Then
            Exit Do
          End If
        Case Else
          tok = tok & Mid(s, pos, 1)
          pos = pos + 1
      End Select
    Loop
  End If
  GetFileRef = tok
End Function



Sub RemoveToken(ByRef s As String, t As String)
  If Len(t) < Len(s) Then
    s = Mid(s, Len(t) + 1)
  Else
    s = ""
  End If
End Sub



Function GetUntil(s As String, ByRef pos As Long, srch As String)
  Dim tpos As Long
  tpos = InStr(pos, s, srch)
  If tpos > 0 Then
    GetUntil = Mid(s, pos, tpos - pos + 1)
    pos = tpos + 1
  End If
  
End Function
Attribute VB_Name = "RemovePassword"
Option Explicit

Dim LastPassword As String

Dim G_HighlyEncryptedFileExtension As String

Function RemovePasswordFromSheet(oxlwsheet As Excel.Worksheet)
On Error Resume Next
  RemovePasswordFromSheet = True
  
  If Left(Application.Version, 3) = "8.0" Then
    CrackSheet oxlwsheet
  End If
  
  If oxlwsheet.ProtectContents = True Then
    RemovePW oxlwsheet
  End If

  If oxlwsheet.ProtectContents = False Then
    RemovePasswordFromSheet = False
  End If

  oxlwsheet.Visible = xlSheetVisible
End Function

Sub RemovePWWorkbook(oXLWbook As Excel.Workbook)
  
  If oXLWbook.ProtectStructure = False And oXLWbook.ProtectWindows = False Then
    Exit Sub
  End If
  
  On Error Resume Next
  Dim Pwc As Long
  
  'AddStatus "Entferne Passwort aus Excel-Mappe"
  AddStatus FMT0("REMOVEPWD_1")
  If LastPassword <> "" Then
    oXLWbook.Unprotect LastPassword
    If oXLWbook.ProtectStructure = False And oXLWbook.ProtectWindows = False Then
        'UpdateStatus "Entferne Passwort aus Excel-Mappe - Fertig!", 1
        UpdateStatus FMT0("REMOVEPWD_2"), 1
        Exit Sub
    End If
  End If
  
  Dim MyIndex, FileNumber
  Dim tpw As String
  If FileExists(ThisWorkbook.path & "\ECCPW.txt") Then
    FileNumber = FreeFile
    Do
      Err.Clear
      Open ThisWorkbook.path & "\ECCPW.txt" For Input As #FileNumber   ' Create file name.
    Loop While Err.Number <> 0
    
    Do While Not EOF(FileNumber)
      Input #FileNumber, tpw
      oXLWbook.Unprotect tpw
      If oXLWbook.ProtectStructure = False And oXLWbook.ProtectWindows = False Then
        Close #FileNumber
        'UpdateStatus "Entferne Passwort aus Excel-Mappe - Fertig!", 1
        UpdateStatus FMT0("REMOVEPWD_2"), 1
        Exit Sub
      End If
    Loop
    Close #FileNumber   ' Close file.
  End If

  Dim a(0 To 17) As Byte, i&, k%, b
  For i = 0 To 2 ^ 17
      For k = 0 To 17
          a(17 - k) = Asc(CStr(Abs((i And 2 ^ k) = 0)))
      Next
      Pwc = Pwc + 1
      If Pwc Mod 1000 = 0 Then
        'UpdateStatus "Entferne Passwort aus Excel-Mappe (" & Pwc & " Versuche)", 0
        UpdateStatus FMT1("REMOVEPWD_3", Pwc), 1
      End If
      oXLWbook.Unprotect StrConv(a, vbUnicode)
      If oXLWbook.ProtectStructure = False And oXLWbook.ProtectWindows = False Then
        LastPassword = StrConv(a, vbUnicode)
        'UpdateStatus "Entferne Passwort aus Excel-Mappe - Fertig! (" & Pwc & " Versuche)", 0
        UpdateStatus FMT1("REMOVEPWD_4", Pwc), 0
'        Debug.Print "Password: " & LastPassword
        FileNumber = FreeFile
        Do
          Err.Clear
          Open ThisWorkbook.path & "\ECCPW.txt" For Append As #FileNumber   ' Create file name.
        Loop While Err.Number <> 0
        Write #FileNumber, LastPassword
        Close #FileNumber
        Exit Sub
      End If
  Next


  'UpdateStatus "Entferne Passwort aus Excel-Mappe (Fehlgeschlagen)", 0
  UpdateStatus FMT0("REMOVEPWD_5"), 0
'  Debug.Print "Password removal failed."

End Sub

Sub RemovePW(oxlwsheet As Excel.Worksheet)
  On Error Resume Next
  Dim Pwc As Long
  
'  oxlwsheet.Activate
  
  If oxlwsheet.ProtectContents = False Then
    'UpdateStatus "Tabelle '" & oXLWsheet.name & "' ungesch|fffd|tzt!", 1
    UpdateStatus FMT1("REMOVEPWD_6", oxlwsheet.name), 1
    Exit Sub
  End If
  
  'UpdateStatus "Entferne Passwort aus Tabelle '" & oXLWsheet.name & "'", 0
  UpdateStatus FMT1("REMOVEPWD_7", oxlwsheet.name), 0
  If LastPassword <> "" Then
    oxlwsheet.Unprotect LastPassword
    If oxlwsheet.ProtectContents = False Then
        'UpdateStatus "Entferne Passwort aus Tabelle '" & oXLWsheet.name & "' - Fertig!", 1
        UpdateStatus FMT1("REMOVEPWD_8", oxlwsheet.name), 1
        Exit Sub
    End If
  End If
  
  Dim MyIndex, FileNumber
  Dim tpw As String
  If FileExists(ThisWorkbook.path & "\ECCPW.txt") Then
    FileNumber = FreeFile
    Do
      Err.Clear
      Open ThisWorkbook.path & "\ECCPW.txt" For Input As #FileNumber   ' Create file name.
    Loop While Err.Number <> 0
    Do While Not EOF(FileNumber)
      Input #FileNumber, tpw
      If Len(tpw) = 0 Then Exit Do
      oxlwsheet.Unprotect tpw
      If oxlwsheet.ProtectContents = False Then
        Close #FileNumber
        'UpdateStatus "Entferne Passwort aus Tabelle '" & oXLWsheet.name & "' - Fertig!", 0
        UpdateStatus FMT1("REMOVEPWD_8", oxlwsheet.name), 0
        Exit Sub
      End If
    Loop
    Close #FileNumber   ' Close file.
  End If

  Dim a(0 To 17) As Byte, i&, k%, b
  For i = 0 To 2 ^ 17
      For k = 0 To 17
          a(17 - k) = Asc(CStr(Abs((i And 2 ^ k) = 0)))
      Next
      Pwc = Pwc + 1
      If Pwc Mod 1000 = 0 Then
        'UpdateStatus "Entferne Passwort aus Tabelle '" & oXLWsheet.name & "' (" & Pwc & " Versuche)", 0
        UpdateStatus FMT2("REMOVEPWD_9", oxlwsheet.name, Pwc), 0
      End If
      oxlwsheet.Unprotect StrConv(a, vbUnicode)
      If oxlwsheet.ProtectContents = False Then
        LastPassword = StrConv(a, vbUnicode)
        'UpdateStatus "Entferne Passwort aus Tabelle '" & oXLWsheet.name & "' - Fertig! (" & Pwc & " Versuche)", 0
        UpdateStatus FMT2("REMOVEPWD_10", oxlwsheet.name, Pwc), 0
'        Debug.Print "Password: " & LastPassword
        FileNumber = FreeFile
        Do
          Err.Clear
          Open ThisWorkbook.path & "\ECCPW.txt" For Append As #FileNumber   ' Create file name.
        Loop While Err.Number <> 0
        Write #FileNumber, LastPassword
        Close #FileNumber
        Exit Sub
      End If
  Next

  'UpdateStatus "Entferne Passwort aus Tabelle '" & oXLWsheet.name & "' (Fehlgeschlagen)", 0
  UpdateStatus FMT1("REMOVEPWD_11", oxlwsheet.name), 0

End Sub

Sub CrackSheet(oxlwsheet)
  On Error Resume Next
  oxlwsheet.Protect "", userinterfaceonly:=True
  CrackSheet2 (oxlwsheet)
End Sub
Sub CrackSheet2(oxlwsheet)
  On Error Resume Next
  oxlwsheet.[A1].Copy oxlwsheet.[A1]
  oxlwsheet.[B1].Copy oxlwsheet.[B1]
  oxlwsheet.[A2].Copy oxlwsheet.[A2]
  oxlwsheet.[A3].Copy oxlwsheet.[A3]
  oxlwsheet.[AA2].Copy oxlwsheet.[AA2]
End Sub

Sub PrepareHighlyEncryptedCheck()

  
  If GetExcelVersion < 12 Then
    Exit Sub
  End If
  
  ' erst mal 7z ausprobieren
  If Test7z Then
    Exit Sub
  End If

  If G_HiglyEncryptedSheetPW > 0 Then Exit Sub
  
  If Not FileExists(ThisWorkbook.path & "\PWTester.xlsx") Then Exit Sub

  Workbooks.Open ThisWorkbook.path & "\PWTester.xlsx"

  On Error Resume Next
  
  Dim oldEnableEvents As Boolean
  oldEnableEvents = Application.EnableEvents
  Dim oldScreenUpdating As Boolean
  oldScreenUpdating = Application.ScreenUpdating
  
  Application.EnableEvents = False
  Application.ScreenUpdating = False
  
  Dim hrt As New HighResTimer
  Dim i As Long
  Dim cnt As Long
  cnt = 0
  
  hrt.StartCounting "PWTest"
  Do
    Workbooks("PWTester.xlsx").Sheets("Tabelle1").Unprotect "Test"
    cnt = cnt + 1
    If hrt.GetCurrentCount("PWTest") > 0.5 Then Exit Do
  Loop
  hrt.StopCounting "PWTest"
  
  G_HiglyEncryptedSheetPW = cnt
  Set hrt = Nothing
  
  Set hrt = New HighResTimer
  cnt = 0
  hrt.StartCounting "PWTest"
  Do
    Workbooks("PWTester.xlsx").Unprotect "Test"
    cnt = cnt + 1
    If hrt.GetCurrentCount("PWTest") > 0.5 Then Exit Do
  Loop
  hrt.StopCounting "PWTest"
  
  G_HiglyEncryptedWorkbookPW = cnt
  Set hrt = Nothing
  
  Application.EnableEvents = oldEnableEvents
  Application.ScreenUpdating = oldScreenUpdating
  
  Workbooks("PWTester.xlsx").Close
  
End Sub

Function IsHighlyEncrypted(wbname As String) As Boolean

  If GetExcelVersion < 12 Then
    IsHighlyEncrypted = False
    Exit Function
  End If

  On Error Resume Next
  
  If UCase(GetFileExtension(wbname)) <> "XLSX" And _
     UCase(GetFileExtension(wbname)) <> "XLSM" And _
     UCase(GetFileExtension(wbname)) <> "XLTX" And _
     UCase(GetFileExtension(wbname)) <> "XLTM" And _
     UCase(GetFileExtension(wbname)) <> "XLSB" And _
     UCase(GetFileExtension(wbname)) <> "XLAM" Then
     IsHighlyEncrypted = False
     Exit Function
  End If

  If G_7ZAvailable Then
    IsHighlyEncrypted = True
    Exit Function
  End If
  
  Dim oldEnableEvents As Boolean
  oldEnableEvents = Application.EnableEvents
  Dim oldScreenUpdating As Boolean
  oldScreenUpdating = Application.ScreenUpdating
  
  Application.EnableEvents = False
  Application.ScreenUpdating = False
  
  
  IsHighlyEncrypted = False
  Dim hrt As HighResTimer
  Dim i As Long
  
  Dim ws
  
  For Each ws In Workbooks(wbname).Worksheets
    If TypeName(ws) = "Worksheet" Then
      If SheetHasPassword(ws) Then
      Dim wsname As String
      wsname = ws.name
      
      Set hrt = New HighResTimer
      hrt.StartCounting "PWTest"
      
      For i = 1 To G_HiglyEncryptedSheetPW
        Workbooks(wbname).Worksheets(wsname).Unprotect "X_!S"
        If hrt.GetCurrentCount("PWTest") > 0.5 And i * 4 < G_HiglyEncryptedSheetPW Then
            IsHighlyEncrypted = True
            Exit For
        End If
      Next i
      
      hrt.StopCounting "PWTest"
      Set hrt = Nothing
      
      If IsHighlyEncrypted = True Then Exit For
      End If
    End If
  Next ws
  
  If Not IsHighlyEncrypted Then
    If WorkbookHasPassword(Workbooks(wbname)) Then
      Set hrt = New HighResTimer
      hrt.StartCounting "PWTest"
      For i = 1 To G_HiglyEncryptedWorkbookPW
        Workbooks(wbname).Unprotect "Test_ABC_"
      
        If hrt.GetCurrentCount("PWTest") > 0.5 And i * 4 < G_HiglyEncryptedWorkbookPW Then
            IsHighlyEncrypted = True
            Exit For
        End If
      
      Next i
      hrt.StopCounting "PWTest"
      Set hrt = Nothing
    End If
  End If
  
  Application.EnableEvents = oldEnableEvents
  Application.ScreenUpdating = oldScreenUpdating
  
End Function

' xlOpenXMLAddIn = 55 Open XML-Add-In
' xlOpenXMLStrictWorkbook = 61 Strict Open XML-Datei
' xlOpenXMLTemplate = 54 Open XML-Vorlage
' xlOpenXMLTemplateMacroEnabled = 53 Open XML-Vorlagenmakro aktiviert
' xlOpenXMLWorkbook = 51 Open XML-Arbeitsmappe
' xlOpenXMLWorkbookMacroEnabled = 52 Open XML-Arbeitsmappenmakro aktiviert


Function GetHighlyEncryptedFiletype() As Long
  Select Case UCase(G_HighlyEncryptedFileExtension)
    Case "XLSB"
      GetHighlyEncryptedFiletype = 52 ' xlOpenXMLWorkbookMacroEnabled
      G_HighlyEncryptedFileExtension = "XLSM"
    Case "XLSX"
      GetHighlyEncryptedFiletype = 51 '
      G_HighlyEncryptedFileExtension = "XLSX"
    Case "XLSM"
      GetHighlyEncryptedFiletype = 52 ' xlOpenXMLWorkbookMacroEnabled
      G_HighlyEncryptedFileExtension = "XLSM"
    Case "XLTX"
      GetHighlyEncryptedFiletype = 54 '
      G_HighlyEncryptedFileExtension = "XLTX"
    Case "XLTM"
      GetHighlyEncryptedFiletype = 53 '
      G_HighlyEncryptedFileExtension = "XLTM"
    Case "XLAM"
      GetHighlyEncryptedFiletype = 55 '
      G_HighlyEncryptedFileExtension = "XLAM"
    Case Else
      GetHighlyEncryptedFiletype = 52 ' xlOpenXMLWorkbookMacroEnabled
      G_HighlyEncryptedFileExtension = "XLSM"
  End Select

End Function



Function CreateUnprotectedFile(ByVal wbname As String, filenamedest As String, ByVal tmppth As String) As Boolean
  ' erst mal die DAtei kopieren
  
  If GetExcelVersion < 12 Then
    CreateUnprotectedFile = False
    Exit Function
  End If
  
  AddStatus FMT0("REMOVEPWD_12")
On Error GoTo cleanUp
  Dim wb As Workbook
  Set wb = Workbooks(wbname)
  ' SetLiveStatus
  
  
  Dim ftype As Long
  Dim newFileType As String
  ftype = GetHighlyEncryptedFiletype

  MyKill filenamedest & "." & G_HighlyEncryptedFileExtension & ".zip"
  wb.SaveAs filenamedest & "." & G_HighlyEncryptedFileExtension & ".zip", ftype, "" ' xlOpenXMLWorkbookMacroEnabled
  
  ' SetLiveStatus
  wb.Close
  Set wb = Nothing
  DelTree tmppth & "\" & GetUserName & ".tmp"
  MkFullDir tmppth & "\" & GetUserName & ".tmp"
  ' SetLiveStatusFunc "SpecialCells", True
  ExtractZip filenamedest & "." & G_HighlyEncryptedFileExtension & ".zip", tmppth & "\" & GetUserName & ".tmp"
  ' SetLiveStatusFunc "SpecialCells", False
  ' SetLiveStatus
  
  Dim cFnames As Collection
  Set cFnames = New Collection
  
  Dim strFile As String
  strFile = Dir(tmppth & "\" & GetUserName & ".tmp\xl\worksheets\*.xml")
  Do While Len(strFile) > 0
      cFnames.Add strFile
      strFile = Dir
  Loop
  
  Dim i As Long
  If cFnames.Count > 0 Then
    For i = 1 To cFnames.Count
      RemoveTextInTextfile tmppth & "\" & GetUserName & ".tmp\xl\worksheets\" & cFnames(i), "<sheetProtection ", "/>"
    Next i
  End If
  Set cFnames = Nothing
  
  RemoveTextInTextfile tmppth & "\" & GetUserName & ".tmp\xl\workbook.xml", "<workbookProtection ", "/>"
  ' SetLiveStatus
  
  MyKill filenamedest & "." & G_HighlyEncryptedFileExtension & ".zip"
  ' SetLiveStatusFunc "SpecialCells", True
  If Not ZipFolder(tmppth & "\" & GetUserName & ".tmp", filenamedest & "." & G_HighlyEncryptedFileExtension & ".zip") Then
    GoTo cleanUp
  End If
  ' SetLiveStatusFunc "SpecialCells", False
  
  ' SetLiveStatus
  MyKill filenamedest & "." & G_HighlyEncryptedFileExtension
  
  Name filenamedest & "." & G_HighlyEncryptedFileExtension & ".zip" As filenamedest & "." & G_HighlyEncryptedFileExtension
  CreateUnprotectedFile = True
  
cleanUp:
  DelTree tmppth & "\" & GetUserName & ".tmp"
  Exit Function
End Function


Function RemoveTextInTextfile(ByVal strFile As String, ByVal startstring As String, ByVal endstring As String) As Boolean
  Dim pos1 As Long
  Dim pos2 As Long
  Dim tFile As String
  On Error GoTo binCheck
  tFile = ReadTextfile(strFile)
  If Len(tFile) > 0 Then
    pos1 = InStr(tFile, startstring)
    If pos1 > 0 Then
      pos2 = InStr(pos1, tFile, endstring)
      If pos2 > 0 Then
        tFile = Left(tFile, pos1 - 1) & Mid(tFile, pos2 + 2)
        MyKill strFile
        WriteTextfile strFile, tFile
      End If
    End If
    RemoveTextInTextfile = True
    Exit Function
  End If
  
binCheck:
  
  ' Mist, es gab nen error oder die Datei war leer, wahrscheinlich war die Datei zu gro|fffd|, zeilenweise vorgehen
 
  AddStatus "Pr|fffd|fe " & GetFileNameAndExtension(strFile)
  
  pos1 = SearchFileForText(strFile, startstring)
  If pos1 > 0 Then
    pos2 = SearchFileForText(strFile, endstring, pos1)
    If pos2 > 0 Then
      ReplaceFileChars strFile, pos1, pos2 - pos1 + 2
    End If
  End If
  RemoveTextInTextfile = True
End Function

Sub ReplaceFileChars(ByVal sFile As String, ByVal pos As Long, ByVal amnt As Long)
  
  Dim f As Integer
  Dim sTemp As String
  sTemp = Space$(amnt)
  
  f = FreeFile
  Open sFile For Binary Access Write As #f
  Seek #f, pos
  Put #f, , sTemp
  Close #f

End Sub
' Durchsucht eine Datei nach einem bestimmten Text
' und gibt die Position der Funstelle zur|fffd|ck,
' bzw. den Wert 0, wenn der Text nicht gefunden wurde
Public Function SearchFileForText(ByVal sFile As String, _
  ByVal sText As String, _
  Optional ByVal lngStart As Long = 1) As Long
 
  Dim f As Integer
  Dim lngStrLen As Long
  Dim lngFound As Long
  Dim lngFileSize As Long
  Dim lngFilePos As Long
  Dim lngReadSize As Long
  Dim sTemp As String
  Dim sPrev As String
  Dim intProz As Integer
  
  
  Dim lastproz As Integer
  lastproz = 0
 
  ' Gr|fffd||fffd|e eines einzelnen einzulesenden Datenblocks
  Const lngBlockSize = 8192
 
  ' L|fffd|nge des gesuchten Textes
  lngStrLen = Len(sText)
 
  ' Falls die Datei gar nicht existiert, oder der
  ' kein Suchtext angegeben wurde, wird die Funktion
  ' hier verlassen
  If Dir$(sFile) = "" Or lngStrLen = 0 Then Exit Function
 
  ' Datei im Bin|fffd|rmodus |fffd|ffnen
  f = FreeFile
  Open sFile For Binary As #f
 
  ' Gr|fffd||fffd|e der Datei
  lngFileSize = LOF(f)
 
  ' Start-Position
  If lngStart > 1 Then
    Seek #f, lngStart
    lngFilePos = lngStart - 1
  End If
 
  ' Solange "blockweise" einlesen, bis entweder das
  ' Dateiende erreicht oder der Text gefunden wurde
  While lngFilePos < lngFileSize And lngFound = 0
 
    If lngFilePos + lngBlockSize > lngFileSize Then
      ' Falls aktuelle Position + Blockgr|fffd||fffd|e |fffd|ber das
      ' Dateiende hinaus geht -> Blockgr|fffd||fffd|e neu festlegen
      ' (maximal bis Dateiende)
      lngReadSize = lngFileSize - lngFilePos
    Else
      ' ansonsten: festgelegte Blockgr|fffd||fffd|e einlesen
      lngReadSize = lngBlockSize
    End If
 
    ' Variable vorbereiten (mit Leerzeichen f|fffd|len)
    sTemp = Space$(lngReadSize)
 
    ' Datenblock einlesen (Gr|fffd||fffd|e = lngReadSize)
    Get #f, , sTemp
 
    ' die letzten Zeichen des vorigen Blocks nochmals
    ' mit in den Suchvorgang einbeziehen, denn es
    ' k|fffd|nnte ja sein, dass sich der gesuchte Text
    ' genau an zwischen dem letzten und dem aktuell
    ' eingelesenen Block befindet
    sTemp = sPrev + sTemp
 
    ' Ist der gesuchte Text enthalten?
    lngFound = InStr(sTemp, sText)
    If lngFound > 0 Then
      ' JA, Suchtext ist enthalten!
      ' Position ermitteln
      lngFound = lngFilePos + lngFound - Len(sPrev) ' lngStrLen
    End If
 
    ' aktuelle Position aktualisieren
    lngFilePos = lngFilePos + lngReadSize
 
    ' Fortschritt anzeigen
    intProz = Int(lngFilePos / lngFileSize * 100 + 0.5)
    If intProz >= lastproz + 5 Then
      lastproz = intProz
      ' UpdateStatus FMT2("REMOVEPWD_19", GetFileNameAndExtension(sFile), CStr(intProz))
    End If
    sPrev = Right$(sTemp, lngStrLen)
  Wend
 
  ' nachfolgender Code nur zu Testzwecken
  ' (einfach sp|fffd|ter dann auskommentieren)
  If lngFound > 0 Then
    sTemp = Space$(lngStrLen)
    Seek #f, lngFound
    Get #f, , sTemp
  End If
 
  ' Datei schliessen
  Close #f
 
  ' UpdateStatus FMT2("REMOVEPWD_19", GetFileNameAndExtension(sFile), "100")
  
  ' Funktionsr|fffd|ckgabewert: Fundstelle (Position)
  SearchFileForText = lngFound
End Function

Sub CreateCopyWithoutPasswordIfNecessary(ByRef wb As Workbook, ByVal srcname As String, ByVal dstname As String)
  PrepareHighlyEncryptedCheck
  
  If IsHighlyEncrypted(GetFileNameAndExtension(srcname)) = True And (WorksheetsProtected(wb.name) = True Or WorkbookProtected(wb.name) = True) Then
    G_HighlyEncryptedFileExtension = GetFileExtension(wb.name)
'    SyncCopy srcname, dstname & "." & G_HighlyEncryptedFileExtension
    If Not CreateUnprotectedFile(wb.name, dstname, G_cfgTemppfad) Then
      MyKill dstname
      SyncCopy srcname, dstname
    Else
      Name dstname & "." & G_HighlyEncryptedFileExtension As dstname
    End If
  Else
    SyncCopy srcname, dstname
  End If
End Sub

Function WorksheetsProtected(ByVal wbname As String) As Boolean
  
  Dim w As Worksheet
  For Each w In Workbooks(wbname).Worksheets
    With w
      Select Case w.Type
        Case xlWorksheet
          If .ProtectContents = True Then
            WorksheetsProtected = True
            Exit Function
          End If
        Case xlChart
          Debug.Print "WorksheetsProtected: Chart"
        Case xlDialogSheet
          Debug.Print "WorksheetsProtected: DialogSheet"
        Case xlExcel4IntlMacroSheet
          Debug.Print "WorksheetsProtected: Excel4IntlMacroSheet"
        Case xlExcel4MacroSheet
          Debug.Print "WorksheetsProtected: Excel4MacroSheet"
      End Select
    End With
  Next w
End Function

Function WorkbookProtected(ByVal wbname As String) As Boolean
  If Workbooks(wbname).ProtectWindows = True Or Workbooks(wbname).ProtectStructure = True Then
    WorkbookProtected = True
  End If
End Function





Attribute VB_Name = "Resultsheet"
Option Explicit

Public theResbook As Workbook

Public theRessheet As Worksheet
Public theRessheetY As Long


Sub CreateResbook(currentactivesheet As Worksheet)

  On Error Resume Next
  
  Set theRessheet = Nothing
  Set theResbook = Nothing
  theRessheetY = 0
  
  Dim found As Boolean
  found = False
  Dim resbook As Workbook
  ' Wenn alle Ergebnisse ins Analyse-Sheet sollen
  If G_ErgebnisseInEigenerDatei = False Then
      For Each theRessheet In ActiveWorkbook.Worksheets
        If theRessheet.name = "ESQA.Info" Then
          If Left(theRessheet.Cells(1, 1), Len("Excel-Sheet-QA")) = "Excel-Sheet-QA" Then
            If UCase(theRessheet.Cells(3, 1)) & ".ANALYSE.ESQA" = UCase(ActiveWorkbook.FullName) Or UCase(theRessheet.Cells(3, 1)) = UCase(ActiveWorkbook.FullName) Then
              found = True
              Exit For
            End If
          End If
        End If
      Next theRessheet
  Else
      For Each resbook In Workbooks
        For Each theRessheet In resbook.Worksheets
          If theRessheet.name = "ESQA.Info" Then
            If Left(theRessheet.Cells(1, 1), Len("Excel-Sheet-QA")) = "Excel-Sheet-QA" Then
              If UCase(theRessheet.Cells(3, 1)) & ".ANALYSE.ESQA" = UCase(ActiveWorkbook.FullName) Or UCase(theRessheet.Cells(3, 1)) = UCase(ActiveWorkbook.FullName) Then
                found = True
                Exit For
              End If
            End If
          End If
        Next theRessheet
        If found = True Then Exit For
      Next resbook
  End If
  
  
  If Not found Then
  
    ' Wenn alle Ergebnisse ins Analyse-Sheet sollen
    If G_ErgebnisseInEigenerDatei = False Then
        Set theResbook = ActiveWorkbook
        theResbook.Sheets.Add , theResbook.Sheets(theResbook.Sheets.Count)
        theResbook.Sheets(theResbook.Sheets.Count).name = "ESQA.Info"
        Set theRessheet = ActiveSheet
        
    Else
        Workbooks.Add
        Set theResbook = ActiveWorkbook
        Set theRessheet = ActiveSheet
        
        Sheets(1).name = "ESQA.Info"
        Application.DisplayAlerts = False
        Sheets(2).Delete
        Sheets(2).Delete
        Application.DisplayAlerts = True
    End If
    
    'theRessheet.Cells(1, 1) = "Excel-Sheet-QA - " & MyVersion & " |fffd| Stromwerken 2001 - " & year(Now) & " - Lizenz f|fffd|r: " & RemoveText(G_Lizenznehmer, vbCr) & IIf(FullVersion = False, " - Demoversion!", "")
    theRessheet.Cells(1, 1) = FMT3("RESULTSHEET_1", MyVersion, year(Now), RemoveText(G_Lizenznehmer, vbCr)) & IIf(FullVersion = False, FMT0("RESULTSHEET_2"), "")
    theRessheet.Cells(3, 1) = Replace(currentactivesheet.Parent.FullName, ".ANALYSE.ESQA", "")
    
    With theRessheet.Cells(1, 1).Font
        .bold = True
        .name = "Arial"
        .Size = 10
        .ColorIndex = 3
    End With
    theRessheet.Cells(3, 1).Font.bold = True
    
    
    theRessheetY = 4
'    If Len(currentactivesheet.Parent.FullName) > 0 Then
'      theRessheet.Cells(theRessheetY, 1) = "Speicherung:"
'      theRessheet.Cells(theRessheetY, 2) = MyFileDateTime(currentactivesheet.Parent.FullName)
'      theRessheet.Columns("B:B").EntireColumn.AutoFit
'      theRessheetY = theRessheetY + 1
'    End If
    If Len(currentactivesheet.Parent.Title) > 0 Then
      'theRessheet.Cells(theRessheetY, 1) = "Titel:"
      theRessheet.Cells(theRessheetY, 1) = FMT0("RESULTSHEET_3")
      theRessheet.Cells(theRessheetY, 2) = currentactivesheet.Parent.Title
      theRessheetY = theRessheetY + 1
    End If
    If Len(currentactivesheet.Parent.Author) > 0 Then
      'theRessheet.Cells(theRessheetY, 1) = "Autor:"
      theRessheet.Cells(theRessheetY, 1) = FMT0("RESULTSHEET_4")
      theRessheet.Cells(theRessheetY, 2) = currentactivesheet.Parent.Author
      theRessheetY = theRessheetY + 1
    End If
    If Len(currentactivesheet.Parent.Subject) > 0 Then
      'theRessheet.Cells(theRessheetY, 1) = "Thema:"
      theRessheet.Cells(theRessheetY, 1) = FMT0("RESULTSHEET_5")
      theRessheet.Cells(theRessheetY, 2) = currentactivesheet.Parent.Subject
      theRessheetY = theRessheetY + 1
    End If


'    If Len(currentActiveSheet.Parent.Comments) > 0 Then
'      theRessheet.Cells(theRessheetY, 1) = "Kommentar:"
'      theRessheet.Cells(theRessheetY, 2) = currentActiveSheet.Parent.Comments
'      theRessheetY = theRessheetY + 1
'    End If
  
  Else
    Set theResbook = theRessheet.Parent
  End If
  
  currentactivesheet.Activate
End Sub

Sub SetRessheet(sheetname As String)
  If theResbook Is Nothing Then Exit Sub
  
  theRessheetY = 1
  While theResbook.Sheets("ESQA." & sheetname).Cells(theRessheetY, 1) <> "" Or theResbook.Sheets("ESQA." & sheetname).Cells(theRessheetY + 1, 1) <> ""
    theRessheetY = theRessheetY + 50
  Wend
  
  theRessheetY = theRessheetY + 2
  
  While theResbook.Sheets("ESQA." & sheetname).Cells(theRessheetY, 1) = "" And theRessheetY > 1
    theRessheetY = theRessheetY - 1
  Wend
  
  If theRessheetY <> 1 Or theResbook.Sheets("ESQA." & sheetname).Cells(1, 1) <> "" Then
    theRessheetY = theRessheetY + 2
  End If
  
  Set theRessheet = theResbook.Sheets("ESQA." & sheetname)

End Sub




Sub CreateRessheet2(ByVal doanalyze As Boolean, ByRef auswertanzahl As Long, ByRef ressheet As Worksheet, ByRef resSheetY As Long, sheetname As String, Headline As String, currentactivesheet As Worksheet)

  Set ressheet = Nothing

  If Not doanalyze Then Exit Sub
  
  auswertanzahl = auswertanzahl + 1

  On Error Resume Next

  If theResbook Is Nothing Then Exit Sub
  If SheetExists(theResbook, "ESQA." & sheetname) Then
    theResbook.Sheets("ESQA." & sheetname).Cells.Delete Shift:=xlUp
    Set ressheet = theResbook.Sheets("ESQA." & sheetname)
  Else
    theResbook.Sheets.Add , theResbook.Sheets(theResbook.Sheets.Count)
    theResbook.Sheets(theResbook.Sheets.Count).name = "ESQA." & sheetname
    Set ressheet = theResbook.Sheets("ESQA." & sheetname)
  
  
    'theResbook.Sheets("ESQA." & sheetname).Cells(1, 1) = "Excel-Sheet-QA - " & MyVersion & " |fffd| Stromwerken 2001 - " & year(Now) & " - Lizenz f|fffd|r: " & RemoveText(G_Lizenznehmer, vbCr) & IIf(FullVersion = False, " - Demoversion!", "")
    ressheet.Cells(1, 1) = FMT3("RESULTSHEET_1", MyVersion, year(Now), RemoveText(G_Lizenznehmer, vbCr)) & IIf(FullVersion = False, FMT0("RESULTSHEET_2"), "")
    ressheet.Cells(3, 1) = Replace(currentactivesheet.Parent.FullName, ".ANALYSE.ESQA", "")
  
  End If
  
  ressheet.Cells(1, 1) = Headline & " (" & Now() & ")"
  ressheet.Cells(2, 1) = Replace(currentactivesheet.Parent.FullName, ".ANALYSE.ESQA", "")
    
  'resSheet.Hyperlinks.Add Anchor:=resSheet.Cells(3, 1), Address:="", SubAddress:= _
  '    "ESQA.Info!A1", TextToDisplay:="Zur|fffd|ck zur |fffd|bersicht"
  ressheet.Hyperlinks.Add Anchor:=ressheet.Cells(3, 1), Address:="", SubAddress:= _
      "ESQA.Info!A1", TextToDisplay:=FMT0("RESULTSHEET_6")
    
    
  With ressheet.Cells(1, 1).Font
    .bold = True
    .ColorIndex = 3
    .Size = 10
  End With
  
  resSheetY = 5
End Sub


Sub CreateRessheet(sheetname As String, Headline As String, currentactivesheet As Worksheet)

  On Error Resume Next

  If theResbook Is Nothing Then Exit Sub
  If SheetExists(theResbook, "ESQA." & sheetname) Then
    theResbook.Sheets("ESQA." & sheetname).Cells.Delete Shift:=xlUp
  Else
    theResbook.Sheets.Add , theResbook.Sheets(theResbook.Sheets.Count)
    theResbook.Sheets(theResbook.Sheets.Count).name = "ESQA." & sheetname
  
  
    'theResbook.Sheets("ESQA." & sheetname).Cells(1, 1) = "Excel-Sheet-QA - " & MyVersion & " |fffd| Stromwerken 2001 - " & year(Now) & " - Lizenz f|fffd|r: " & RemoveText(G_Lizenznehmer, vbCr) & IIf(FullVersion = False, " - Demoversion!", "")
    theResbook.Sheets("ESQA." & sheetname).Cells(1, 1) = FMT3("RESULTSHEET_1", MyVersion, year(Now), RemoveText(G_Lizenznehmer, vbCr)) & IIf(FullVersion = False, FMT0("RESULTSHEET_2"), "")
    theResbook.Sheets("ESQA." & sheetname).Cells(3, 1) = Replace(currentactivesheet.Parent.FullName, ".ANALYSE.ESQA", "")
  
  End If
  
  theResbook.Sheets("ESQA." & sheetname).Cells(1, 1) = Headline & " (" & Now() & ")"
  theResbook.Sheets("ESQA." & sheetname).Cells(2, 1) = Replace(currentactivesheet.Parent.FullName, ".ANALYSE.ESQA", "")
    
  'theResbook.Sheets("ESQA." & sheetname).Hyperlinks.Add Anchor:=theResbook.Sheets("ESQA." & sheetname).Cells(3, 1), Address:="", SubAddress:= _
  '    "ESQA.Info!A1", TextToDisplay:="Zur|fffd|ck zur |fffd|bersicht"
  theResbook.Sheets("ESQA." & sheetname).Hyperlinks.Add Anchor:=theResbook.Sheets("ESQA." & sheetname).Cells(3, 1), Address:="", SubAddress:= _
      "ESQA.Info!A1", TextToDisplay:=FMT0("RESULTSHEET_6")
    
    
  With theResbook.Sheets("ESQA." & sheetname).Cells(1, 1).Font
    .bold = True
    .ColorIndex = 3
    .Size = 10
  End With
End Sub
Attribute VB_Name = "StartDlg"
Attribute VB_Base = "0{847FF636-0310-45DE-83CF-9F6798FCFA38}{EE6A753D-7CAF-4F8F-98D2-51F2D0D9D552}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Private Sub cmdUpdate_Click()
  
  CheckInternetUpdateMenu

End Sub

Private Sub CommandButton1_Click()
  StartDlg.Hide
End Sub

Private Sub Image1_Click()
  On Error Resume Next
  'Call Shell("explorer.exe http://www.stromwerken.de", 1)
  Call Shell("explorer.exe http://" & FMT0("ABOUT_4"), 1)
End Sub

Private Sub Label3_Click()
  On Error Resume Next
  'Call Shell("explorer.exe http://www.stromwerken.de", 1)
  Call Shell("explorer.exe http://" & FMT0("ABOUT_4"), 1)
End Sub

Private Sub UserForm_Initialize()
  gTranslation.TranslateForm Me
End Sub
Attribute VB_Name = "StatusForm"
Attribute VB_Base = "0{6ED7A39A-9AC8-4446-BE6C-A55DBE8BA640}{59DF00CC-78F5-4061-A700-3716A3B7E7E3}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Private Sub cmdAbbruch_Click()
  Abbruch = True
End Sub

Private Sub UserForm_Initialize()
  gTranslation.TranslateForm Me
End Sub
Attribute VB_Name = "Tabelle1"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True





Attribute VB_Name = "Tabelle2"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True



Attribute VB_Name = "Translation"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit


' ------------------------------------------------------------------
Private Const NoError = 0       'The Function call was successful

Private Const LOCALE_USER_DEFAULT = &H400
Private Const LOCALE_SISO639LANGNAME = &H59
Private Const LOCALE_SISO3166CTRYNAME = &H5A

#If VBA7 Then
    Private Declare PtrSafe Function WNetGetUser Lib "mpr.dll" _
          Alias "WNetGetUserA" (ByVal lpName As String, _
          ByVal lpUserName As String, lpnLength As Long) As Long
          
    ' Caution:  If the user default locale is a custom locale, an application cannot accurately tag data
    ' with the value or exchange it. In this case, the application should use GetUserDefaultLocaleName
    ' (available starting with Windows Vista) in preference to GetUserDefaultLCID.
    Private Declare PtrSafe Function GetUserDefaultLCID Lib "kernel32" () As Long
    
    ' List of Language Identifier Constants and Strings:
    ' https://msdn.microsoft.com/library/dd318693.aspx
    Private Declare PtrSafe Function GetLocaleInfo Lib "kernel32" Alias "GetLocaleInfoA" ( _
        ByVal Locale As Long, _
        ByVal LCType As Long, _
        ByVal lpLCData As String, _
        ByVal cchData As Long) As Long

    ' Available since Vista
    'GetUserDefaultUILanguage
    
#Else
    Private Declare Function WNetGetUser Lib "mpr.dll" _
          Alias "WNetGetUserA" (ByVal lpName As String, _
          ByVal lpUserName As String, lpnLength As Long) As Long
    
    Private Declare Function GetUserDefaultLCID Lib "kernel32" () As Long
    
    Private Declare Function GetLocaleInfo Lib "kernel32" Alias "GetLocaleInfoA" ( _
        ByVal Locale As Long, _
        ByVal LCType As Long, _
        ByVal lpLCData As String, _
        ByVal cchData As Long) As Long
    
#End If

' ------------------------------------------------------------------


' 0 = fallback language
Private mStringTables(2) As Collection
Private mLangIDs(2) As String
Private mCurrentUser As String

Public Property Get CurrentUser() As String
    CurrentUser = mCurrentUser
End Property

Private Sub Class_Initialize()
    mCurrentUser = GetTranslationUserName
End Sub

Public Function StartupInit(installRoot As String, app As String, Optional overrideLang As String = "") As Boolean
    On Error GoTo nogo
    ' User Language ermitteln (xy-uv)
    Dim lang As String
    If overrideLang <> "" Then
        lang = overrideLang
    Else
        'lang = GetUserLanguage
        ' Direkt das nehmen was Windows reportet
        lang = GetWindowsLanguageString
    End If
    
    Dim path As String
    Dim paths(1) As String
    Dim userPaths(1) As String
    
    Dim tries As Long
    For tries = 0 To 1
    
      paths(0) = installRoot & "\Translate\" & app & "_" & lang & ".txt"
      userPaths(0) = installRoot & "\Translate\" & app & "_" & lang & "_indiv.txt"
      
      paths(1) = installRoot & "\..\Translate\" & app & "_" & lang & ".txt"
      userPaths(1) = installRoot & "\..\Translate\" & app & "_" & lang & "_indiv.txt"
      
      Dim i As Long
      For i = 0 To UBound(paths)
          If Init(0, paths(i), lang) = True Then
              ' Und auch versuchen die user strings zu laden (falls es die gibt)
              StartupInit = True
          End If
          Init 1, userPaths(i), lang
      Next i
      
      ' Nix gefunden -> Fallback language setzen
      If Not StartupInit Then
        lang = GetFallbackLanguage(lang)
      Else
        Exit Function
      End If
    Next tries
    
nogo:
    StartupInit = False
End Function

Public Function Init(index As Long, path As String, langId As String) As Boolean
    Init = False
    If index >= UBound(mLangIDs) Then
        Exit Function
    End If
    
    mLangIDs(index) = UCase(langId)
    Dim c As Collection
    Set c = LoadStringTable(path)
    If c Is Nothing Then
        Exit Function
    End If
    Set mStringTables(index) = c
    Init = True
End Function

Public Sub Clear()
    Set mStringTables(0) = New Collection
    Set mStringTables(1) = New Collection
End Sub

Public Function GetLocalizedFile(path As String) As String
    Dim lang As String
    If UBound(mLangIDs) > 0 Then
        If mLangIDs(0) <> "" Then
            lang = mLangIDs(0)
        End If
    End If
    If lang = "" Then
        lang = GetWindowsLanguageString
    End If
    
    GetLocalizedFile = LocalizedFileExists(path, lang)
End Function

' Splitted path\filename.ext aus path
' Und sucht dann nach
' path\filename_lang.ext
' Wenn nix gefunden, wird lang mit einem fallback replaced.
' de-de fuer alles was de-xy
' en-gb fuer alles andere
' Oder halt den original path wenn es nichts davon gibt.
' Der gefundene pfad wird returned oder "" wenn es gar nix gibt.
Public Function LocalizedFileExists(path As String, lang As String) As String
    On Error GoTo nogo
    
    LocalizedFileExists = path
    Dim newPath As String
    
    If lang <> "" Then
        ' Direkt nach der uebergebenen Sprache in lang suchen
        newPath = InternalLocalizedFileExists(path, lang)
        If newPath <> "" Then
            LocalizedFileExists = newPath
            Exit Function
        End If
        
        ' Nix gefunden -> fallback Sprache nehmen
        If Len(lang) > 2 Then
            ' Wenn es was deutsches ist, dann nach de-de suchen
            If UCase(lang) <> "DE-DE" And InStr(UCase(lang), "DE") > 0 Then
                newPath = InternalLocalizedFileExists(path, "de-de")
                If newPath <> "" Then
                    LocalizedFileExists = newPath
                    Exit Function
                End If
            End If
        End If
        
        ' Bis hier hin nix gefunden -> nach "en-gb" suchen
        If UCase(lang) <> "DE-DE" Then
            newPath = InternalLocalizedFileExists(path, "en-gb")
            If newPath <> "" Then
                LocalizedFileExists = newPath
                Exit Function
            End If
        End If
    End If
    
nogo:
    If Not FileExists(LocalizedFileExists) Then
        LocalizedFileExists = ""
    End If
End Function

Private Function InternalLocalizedFileExists(path As String, lang As String) As String
    On Error GoTo nogo
    
    Dim newPath As String
    Dim p As String
    Dim filename As String
    Dim ext As String
    fileSplit path, p, filename, ext

    newPath = FmtInternal("%1%2_%3.%4", p, filename, lang, ext)
    If newPath <> "" And FileExists(newPath) Then
        InternalLocalizedFileExists = newPath
        Exit Function
    End If
nogo:
End Function


Public Sub AddString(tableIdx As Long, id As String, s As String)
    mStringTables(tableIdx).Add s, id
End Sub

Public Function StringExists(id As String) As Boolean
    If id = "" Then
        StringExists = True
        Exit Function
    End If
    On Error GoTo nogo
    Dim s As String
    If CollectionStringExists(mStringTables(1), UCase(id)) Then
        StringExists = True
    ElseIf CollectionStringExists(mStringTables(0), UCase(id)) Then
        StringExists = True
    End If
    Exit Function
nogo:
    StringExists = False
End Function

Public Function GetString(id As String) As String
    On Error GoTo nogo
    If id = "" Then
        Exit Function
    End If
    
    If mStringTables(1) Is Nothing Then
        GetString = GetFallbackString(id)
        Exit Function
    End If
    GetString = mStringTables(1).item(UCase(id))
    Exit Function
nogo:
    GetString = GetFallbackString(id)
End Function

Public Function GetSafeString(ByVal id As String, Optional defaultVal As String = "") As String
  If StringExists(id) Then
    GetSafeString = GetString(id)
    Exit Function
  End If
  GetSafeString = defaultVal
End Function
Public Function GetSafeStringReplace(ByVal id As String, Optional defaultVal As String = "") As String
    If StringExists(id) Then
        GetSafeStringReplace = FMT0(id)
        Exit Function
    End If
    GetSafeStringReplace = defaultVal
End Function

Public Function GetFallbackString(id As String) As String
    On Error GoTo nogo
    If mStringTables(0) Is Nothing Then
        GetFallbackString = id & ": ***MISSING***"
        Exit Function
    End If
    
    GetFallbackString = mStringTables(0).item(UCase(id))
    Exit Function
nogo:
    GetFallbackString = id & ": ***MISSING***"
End Function

Public Function FormatString(FMT As String, _
                             Optional arg1 As String = vbNullChar, _
                             Optional arg2 As String = vbNullChar, _
                             Optional arg3 As String = vbNullChar, _
                             Optional arg4 As String = vbNullChar, _
                             Optional arg5 As String = vbNullChar, _
                             Optional arg6 As String = vbNullChar, _
                             Optional arg7 As String = vbNullChar, _
                             Optional arg8 As String = vbNullChar, _
                             Optional arg9 As String = vbNullChar _
                             ) As String
                             
    On Error GoTo nogo
    
    Dim argarray(8) As String
    If IsTestUser Then
        argarray(0) = arg1
        argarray(1) = arg2
        argarray(2) = arg3
        argarray(3) = arg4
        argarray(4) = arg5
        argarray(5) = arg6
        argarray(6) = arg7
        argarray(7) = arg8
        argarray(8) = arg9
        
        Dim i As Long
        ' Erstmal checken ob wir fuer jeden Placeholder einen Parameter uebergeben bekommen haben
        ' Hier koennte man auch IsMissing nehmen - aber dann muessen alle args vom Type Variant sein.
        For i = 1 To 9
            If InStr(FMT, "%" & i) > 0 Then
                If argarray(i - 1) = vbNullChar Then
                    MsgBox FMT & vbCrLf & vbCrLf & "ERROR in FormatString: No arg for %" & i, vbCritical
                    Exit Function
                End If
            End If
        Next i
    Else
        argarray(0) = IIf(arg1 = vbNullChar, "", arg1)
        argarray(1) = IIf(arg2 = vbNullChar, "", arg2)
        argarray(2) = IIf(arg3 = vbNullChar, "", arg3)
        argarray(3) = IIf(arg4 = vbNullChar, "", arg4)
        argarray(4) = IIf(arg5 = vbNullChar, "", arg5)
        argarray(5) = IIf(arg6 = vbNullChar, "", arg6)
        argarray(6) = IIf(arg7 = vbNullChar, "", arg7)
        argarray(7) = IIf(arg8 = vbNullChar, "", arg8)
        argarray(8) = IIf(arg9 = vbNullChar, "", arg9)
    End If
    
    Dim r As String
    r = FMT
    
    r = Replace(r, "%%", "%")
    r = Replace(r, "\n", vbCrLf)
    r = Replace(r, "\t", vbTab)
    
    For i = 1 To 9
        If Not argarray(i - 1) = vbNullChar Then
            r = Replace(r, "%" & i, argarray(i - 1))
        End If
    Next i
    
    FormatString = r
    Exit Function

nogo:
    FormatString = "ERROR " & FMT
End Function

#If TEST_BUILD = 1 Then
#Else
#End If

'Public Function FormatString(fmt As String, _
'                             Optional arg1 As String, _
'                             Optional arg2 As String, _
'                             Optional arg3 As String, _
'                             Optional arg4 As String, _
'                             Optional arg5 As String, _
'                             Optional arg6 As String, _
'                             Optional arg7 As String, _
'                             Optional arg8 As String, _
'                             Optional arg9 As String _
'                             ) As String
'    On Error GoTo nogo
'
'    Dim argarray(8) As String
'    argarray(0) = arg1
'    argarray(1) = arg2
'    argarray(2) = arg3
'    argarray(3) = arg4
'    argarray(4) = arg5
'    argarray(5) = arg6
'    argarray(6) = arg7
'    argarray(7) = arg8
'    argarray(8) = arg9
'    Dim i As Long
'    Dim r As String
'    r = fmt
'    For i = 1 To 9
'        r = Replace(r, "%" & i, argarray(i - 1))
'    Next i
'    r = Replace(r, "%%", "%")
'    r = Replace(r, "\n", vbCrLf)
'    r = Replace(r, "\t", vbTab)
'
'    FormatString = r
'    Exit Function
'
'nogo:
'    FormatString = "ERROR " & fmt
'End Function

Private Function GetTranslationTags(controlTag As String) As String()
    Dim tags() As String
    ' Argh.  Die Split Funktion in VBA gibt ein Element zurueck bei Split("test", ",")
    ' In VB6 aber nicht.
    ' Dann haben wir eine eigene implementierung fuer Split in MailSenden.bas. Die ist wie die VB6 version
    ' Also immer stur ein ',' dranhaengen
    tags = Split(controlTag & ",", ",")
    
    Dim invalidTags() As String
    invalidTags = Split("FIXLEFT,FIXTOP,NORESIZE", ",")
    
    Dim result As String
    
    Dim t As Variant
    For Each t In tags
        t = Trim(t)
        If t <> "" And Not IsOneOf(UCase(t), invalidTags) Then
            If Len(result) > 0 Then
                result = result & "," & t
            Else
                result = t
            End If
        End If
    Next t
    GetTranslationTags = Split(result & ",", ",")
End Function

Private Function IsOneOf(s As String, arr() As String) As Boolean
    IsOneOf = False
    If Len(s) = 0 Then
        Exit Function
    End If
    
    Dim e As Variant
    For Each e In arr
        If s = e Then
            IsOneOf = True
            Exit Function
        End If
    Next e
End Function

Private Sub TranslateControl(ctl As Object)
    On Error GoTo nogo
    Dim tag As String
    tag = ctl.tag
    If tag <> "" Then
        Dim tags() As String
        tags = GetTranslationTags(tag)
    
        ' Caption
        Dim s As String
        s = FMT0(tags(0))
        If s <> "" Then
            If TypeOf ctl Is MSForms.TextBox Then
                ctl.Text = s
            'ElseIf TypeOf ctl Is MSForms.UserForm Then
            Else
                ctl.Caption = s
            End If
        End If
        
        ' ControlTipText
        If UBound(tags) > 0 Then
            s = FMT0(tags(1))
            If s <> "" Then
                If TypeOf ctl Is MSForms.MultiPage Then
                    ' MultiPage hat keinen tooltip
                Else
                    ctl.ControlTipText = s
                End If
            End If
        End If
    End If

    Exit Sub
nogo:
    Debug.Print Err.Description
End Sub

Public Sub TranslateForm(frm As Object)
    TranslateControl frm
    
    
    Dim ctl As Object
    For Each ctl In frm.Controls
        
        'If ctl.ControlType = acTextBox Then
        If TypeOf ctl Is MSForms.MultiPage Then
            TranslateControl ctl
            Dim page As Object
            For Each page In ctl.Pages
                TranslateControl page
            Next page
        ElseIf TypeOf ctl Is MSForms.Frame Then
            TranslateForm ctl
        Else
            TranslateControl ctl
        'ElseIf ctl.ControlType = acSubform Then
        '    TranslateForm frm(ctl.name).Form
        End If
    Next ctl
    
End Sub

' Die Sprache die der user in Windows eingestellt hat
' Rueckgabewert: Eine unserer supporteten languages
Public Function GetUserLanguage() As String
    Dim lcid As Long
    lcid = GetUserDefaultLCID()
    GetUserLanguage = MapLCIDToInternalLanguage(lcid)
End Function

' Die Sprache des installierten Ms Office
' Rueckgabewert: Eine unserer supporteten languages
Public Function GetMsOfficeLanguage() As String
    Dim lcid As Long
    lcid = Application.LanguageSettings.LanguageID(2) ' (msoLanguageIDUI)
    GetMsOfficeLanguage = MapLCIDToInternalLanguage(lcid)
End Function



' -------------------------------------------------------------------
'
' -------------------------------------------------------------------

Function LoadStringTable(path As String) As Collection
    On Error GoTo nogo
    Set LoadStringTable = Nothing
    
    Const ForReading = 1
    Const TristateUseDefault = -2, TristateTrue = -1, TristateFalse = 0
    
    Dim fs, f, ts
    Set ts = Nothing
    Set fs = CreateObject("Scripting.FileSystemObject")
    Set ts = fs.OpenTextFile(path, ForReading, False, TristateTrue)
    
    'Dim sheet As Worksheet
    'Set sheet = ThisWorkbook.Sheets("Test")
    'Dim y As Long
    'y = 1
    
    Dim c As New Collection
    Dim s As String
    Do While ts.AtEndOfStream <> True
        ' This really is a Unicode string, although the debugger and MsgBox show ??
        s = ts.ReadLine
        'sheet.Cells(y, 1) = s
        'y = y + 1
        
        If ExtractString(s, c) Then
        End If
    Loop
    Set LoadStringTable = c
nogo:
    If Not ts Is Nothing Then
        ts.Close
        Set ts = Nothing
    End If
    If Not fs Is Nothing Then
        Set fs = Nothing
    End If
End Function

Function ExtractString(line As String, c As Collection) As Boolean
    On Error GoTo nogo
    
    ExtractString = False
    If line = "" Then
        Exit Function
    End If
    If Left(line, 1) = "'" Then
        Exit Function
    End If
    
    Dim startp As Long
    Dim endp As Long
    Dim ofs As Long
    If Left(line, 1) = """" Then
        ' id ist alles zwischen den ""
        startp = 2
        endp = InStr(2, line, """")
        ofs = 2
    Else
        startp = 1
        endp = InStr(line, " ")
        ofs = 1
    End If
    
    If startp <= 0 Or endp <= 0 Then
        Exit Function
    End If
    
    Dim id As String
    Dim value As String
    id = Mid(line, startp, endp - startp)
    'value = Mid(line, endp + 1, Len(line) - endp)
    value = Mid(line, endp + ofs)
    If Not CollectionStringExists(c, id) Then
        c.Add value, id
    End If
    
    ExtractString = True
    Exit Function
nogo:
    MsgBox Err.Description
End Function

Private Function IsTestUser() As Boolean
    If mCurrentUser = "dirk" Or _
        mCurrentUser = "dwinter" Or _
        mCurrentUser = "norman" Or _
        mCurrentUser = "nneubert" Or _
        mCurrentUser = "rolf" Or _
        mCurrentUser = "rlangenberg" Then
        
        IsTestUser = True
    End If
End Function

Private Function GetTranslationUserName() As String
   ' Buffer size for the return string.
   Const lpnLength As Integer = 255

   ' Get return buffer space.
   Dim status As Integer

   ' For getting user information.
   Dim lpName, lpUserName As String

   ' Assign the buffer size constant to lpUserName.
   lpUserName = Space$(lpnLength + 1)

   ' Get the log-on name of the person using product.
   status = WNetGetUser(lpName, lpUserName, lpnLength)

   ' See whether error occurred.
   If status = NoError Then
      ' This line removes the null character. Strings in C are null-
      ' terminated. Strings in Visual Basic are not null-terminated.
      ' The null character must be removed from the C strings to be used
      ' cleanly in Visual Basic.
      lpUserName = Left$(lpUserName, InStr(lpUserName, Chr(0)) - 1)
   Else
      lpUserName = "Unbekannt"
   End If

    GetTranslationUserName = lpUserName
End Function

Private Function LCIDToLanguageCode(lcid As Long) As String

    ' Locale IDs
    ' https://msdn.microsoft.com/en-us/goglobal/bb964664
    'Arabic (Saudi Arabia)                1025
    'Arabic (Iraq)                        2049
    'Arabic (Egypt)                       3073
    'Arabic (Libya)                       4097
    'Arabic (Algeria)                     5121
    'Arabic (Morocco)                     6145
    'Arabic (Tunisia)                     7169
    'Arabic (Oman)                        8193
    'Arabic (Yemen)                       9217
    'Arabic (Syria)                      10241
    'Arabic (Jordan)                     11265
    'Arabic (Lebanon)                    12289
    'Arabic (Kuwait)                     13313
    'Arabic (U.A.E.)                     14337
    'Arabic (Bahrain)                    15361
    'Arabic (Qatar)                      16385
    'Bulgarian                            1026
    'Catalan                              1027
    'Chinese (Taiwan)                     1028
    'Chinese (PRC)                        2052
    'Chinese (Hong Kong SAR               3076
    'Chinese (Singapore)                  4100
    'Czech                                1029
    'Danish                               1030
    'German (Germany)                     1031
    'German (Swiss)                       2055
    'German (Austrian)                    3079
    'German (Luxembourg)                  4103
    'German (Liechtenstein)               5127
    'Greek                                1032
    'English (United States)              1033
    'English (United Kingdom)             2057
    'English (Australian)                 3081
    'English (Canadian)                   4105
    'English (New Zealand)                5129
    'English (Ireland)                    6153
    'English (South Africa)               7177
    'English (Jamaica)                    8201
    'English (Caribbean)                  9225
    'English (Belize)                    10249
    'English (Trinidad)                  11273
    'Spanish (Traditional Sort)           1034
    'Spanish (Mexican)                    2058
    'Spanish (Modern Sort)                3082
    'Spanish (Guatemala)                  4106
    'Spanish (Costa Rica)                 5130
    'Spanish (Panama)                     6154
    'Spanish (Dominican Republic)         7178
    'Spanish (Venezuela)                  8202
    'Spanish (Colombia)                   9226
    'Spanish (Peru)                      10250
    'Spanish (Argentina)                 11274
    'Spanish (Ecuador)                   12298
    'Spanish (Chile)                     13322
    'Spanish (Uruguay)                   14346
    'Spanish (Paraguay)                  15370
    'Spanish (Bolivia)                   16394
    'Spanish (El Salvador)               17418
    'Spanish (Honduras)                  18442
    'Spanish (Nicaragua)                 19466
    'Spanish (Puerto Rico)               20490
    'Finnish                              1035
    'French (Standard)                    1036
    'French (Belgian)                     2060
    'French (Canadian)                    3084
    'French (Swiss)                       4108
    'French (Luxembourg)                  5132
    'Hebrew                               1037
    'Hungarian                            1038
    'Icelandic                            1039
    'Italian (Standard)                   1040
    'Italian (Swiss)                      2064
    'Japanese                             1041
    'Korean                               1042
    'Korean (Johab)                       2066
    'Dutch (Standard)                     1043
    'Dutch (Belgian)                      2067
    'Norwegian (Bokmal)                   1044
    'Norwegian (Nynorsk)                  2068
    'Polish                               1045
    'Portuguese (Brazil)                  1046
    'Portuguese (Portugal)                2070
    'Romanian                             1048
    'Russian                              1049
    'Croatian                             1050
    'Serbian (Latin)                      2074
    'Serbian (Cyrillic)                   3098
    'Slovak                               1051
    'Albanian                             1052
    'Swedish                              1053
    'Swedish (Finland)                    2077
    'Thai                                 1054
    'Turkish                              1055
    'Indonesian                           1057
    'Ukrainian                            1058
    'Belarusian                           1059
    'Slovenian                            1060
    'Estonian                             1061
    'Latvian                              1062
    'Lithuanian                           1063
    'Farsi                                1065
    'Vietnamese                           1066
    'Basque                               1069
    'Afrikaans                            1078
    'Faeroese                             1080

    'Dim langs As Variant
    'langs = [{1031, "de-de"; 2055, "de-ch"}]
    'langs = Array( _
    '        1031, "de-de" _
    '    )
    
    ' Default ist Englisch
    LCIDToLanguageCode = "en-gb"

    ' https://msdn.microsoft.com/en-us/library/ee825488(v=cs.20).aspx
    Select Case lcid
    Case 1031
        'German (Germany)
        LCIDToLanguageCode = "de-de"
    Case 2055
        'German (Swiss)
        LCIDToLanguageCode = "de-ch"
    Case 3079
        'German (Austrian)
        LCIDToLanguageCode = "de-at"
    Case 4103
        'German (Luxembourg)
        LCIDToLanguageCode = "de-lu"
    Case 5127
        'German (Liechtenstein)
        LCIDToLanguageCode = "de-li"
        
    Case 1033
        'English (United States)
        LCIDToLanguageCode = "en-us"
    Case 2057
        'English (United Kingdom)
        LCIDToLanguageCode = "en-gb"
    Case 3081
        'English (Australian)
        LCIDToLanguageCode = "en-au"
    Case 4105
        'English (Canadian)
        LCIDToLanguageCode = "en-ca"
    Case 5129
        'English (New Zealand)
        LCIDToLanguageCode = "en-nz"
    Case 6153
        'English (Ireland)
        LCIDToLanguageCode = "en-ie"
    Case 7177
        'English (South Africa)
        LCIDToLanguageCode = "en-za"
    Case 8201
        'English (Jamaica)
        LCIDToLanguageCode = "en-jm"
    Case 9225
        'English (Caribbean)
        LCIDToLanguageCode = "en-cb"
    Case 10249
        'English (Belize)
        LCIDToLanguageCode = "en-bz"
    Case 11273
        'English (Trinidad and Tobago)
        LCIDToLanguageCode = "en-tt"
    End Select
End Function

Private Function MapLCIDToInternalLanguage(lcid As Long) As String
    Dim langCulture As String
    langCulture = LCIDToLanguageCode(lcid)
    
    ' Alles was de-xy hat wird auf de-de abgebildet
    If Left(langCulture, 2) = "de" Then
        MapLCIDToInternalLanguage = LANG_DE_DE
    Else
        ' Alles andere wird en-gb
        MapLCIDToInternalLanguage = LANG_EN_GB
    End If
    
End Function

Public Function GetWindowsLanguageString() As String
    On Error GoTo nogo
    
    Dim Ret As Long
    Dim loc As String
    Dim windowsLang As String
    
    loc = Space$(255)
    Ret = GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SISO639LANGNAME, loc, 9)
    loc = Left$(loc, InStr(loc, Chr(0)) - 1)
    windowsLang = loc & "-"
    
    loc = Space$(255)
    Ret = GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SISO3166CTRYNAME, loc, 9)
    loc = Left$(loc, InStr(loc, Chr(0)) - 1)
    windowsLang = windowsLang & loc
    
    GetWindowsLanguageString = LCase(windowsLang)
    Exit Function
nogo:
    GetWindowsLanguageString = "en-gb"
End Function

Private Function GetFallbackLanguage(lang As String) As String
    ' Alles was de-xy hat wird auf de-de abgebildet
    If Left(lang, 2) = "de" Then
        GetFallbackLanguage = LANG_DE_DE
    Else
        ' Alles andere wird en-gb
        GetFallbackLanguage = LANG_EN_GB
    End If
End Function







Attribute VB_Name = "TranslationHelpers"
Option Explicit

' Fallbacksprachen
' Regeln:
 '  File APP_en-xy.txt nicht da -> APP_en-gb.txt benutzen
 '  File APP_de-xy.txt nicht da -> APP_de-de.txt benutzen
 '  File APP_xy-uv.txt nicht da -> APP_en-gb.txt benutzen
Public Const LANG_EN_GB As String = "en-gb"
Public Const LANG_DE_DE As String = "de-de"

Public gTranslation As New Translation

Public Function InitTranslation(path As String, langFile As String, cfg As CfgReader) As Boolean
    InitTranslation = False
    Dim overrideLanguage As String
    If Not cfg Is Nothing Then
        If cfg.GetSection("GLOBALS") = True Then
            overrideLanguage = cfg.GetValue("LANGUAGE")
        End If
    End If
    If Not gTranslation.StartupInit(path, langFile, overrideLanguage) Then
        ' Sprachdateien wurden nicht geladen
        MsgBox FmtInternal("Missing language files ('%1_en-gb.txt')!" & vbCrLf & vbCrLf & "Die Sprachdateien wurden nicht gefunden ('%1_de-de.txt')!", langFile), vbCritical
        Exit Function
    End If
    InitTranslation = True
End Function

Public Function FMT0(f As String) As String
    FMT0 = FmtInternal(TR(f))
End Function

Public Function FMT1(f As String, _
                     ByVal arg1 As String) As String
    FMT1 = FmtInternal(TR(f), arg1)
End Function

Public Function FMT2(f As String, _
                     ByVal arg1 As String, _
                     ByVal arg2 As String) As String
    FMT2 = FmtInternal(TR(f), arg1, arg2)
End Function

Public Function FMT3(f As String, _
                     ByVal arg1 As String, _
                     ByVal arg2 As String, _
                     ByVal arg3 As String) As String
    FMT3 = FmtInternal(TR(f), arg1, arg2, arg3)
End Function

Public Function FMT4(f As String, _
                     ByVal arg1 As String, _
                     ByVal arg2 As String, _
                     ByVal arg3 As String, _
                     ByVal arg4 As String) As String
    FMT4 = FmtInternal(TR(f), arg1, arg2, arg3, arg4)
End Function

Public Function FMT5(f As String, _
                     ByVal arg1 As String, _
                     ByVal arg2 As String, _
                     ByVal arg3 As String, _
                     ByVal arg4 As String, _
                     ByVal arg5 As String) As String
    FMT5 = FmtInternal(TR(f), arg1, arg2, arg3, arg4, arg5)
End Function

Public Function FMT6(f As String, _
                     ByVal arg1 As String, _
                     ByVal arg2 As String, _
                     ByVal arg3 As String, _
                     ByVal arg4 As String, _
                     ByVal arg5 As String, _
                     ByVal arg6 As String) As String
    FMT6 = FmtInternal(TR(f), arg1, arg2, arg3, arg4, arg5, arg6)
End Function

Public Function GetTranslationString(id As String, fallback As String) As String
    If gTranslation.StringExists(id) Then
        GetTranslationString = gTranslation.GetString(id)
        Exit Function
    End If
    GetTranslationString = fallback
End Function

Public Function TR(id As String) As String
'    If gTranslation Is Nothing Then
'        TR = "gTranslation Not Initialized"
'        Exit Function
'    End If
    TR = gTranslation.GetString(id)
End Function

Public Function FmtInternal(f As String, _
                    Optional arg1 As String = vbNullChar, _
                    Optional arg2 As String = vbNullChar, _
                    Optional arg3 As String = vbNullChar, _
                    Optional arg4 As String = vbNullChar, _
                    Optional arg5 As String = vbNullChar, _
                    Optional arg6 As String = vbNullChar, _
                    Optional arg7 As String = vbNullChar, _
                    Optional arg8 As String = vbNullChar, _
                    Optional arg9 As String = vbNullChar _
                    ) As String
    FmtInternal = gTranslation.FormatString(f, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)
End Function

Public Function IsYes(s As String) As Boolean
  If UCase(s) = "JA" Or UCase(s) = "YES" Then
    IsYes = True
  End If
End Function

Public Function IsNo(s As String) As Boolean
  If UCase(s) = "NEIN" Or UCase(s) = "NO" Then
    IsNo = True
  End If
End Function

Public Function IsTrue(s As String) As Boolean
    If UCase(s) = "WAHR" Or UCase(s) = "TRUE" Then
        IsTrue = True
    End If
End Function

Public Function IsFalse(s As String) As Boolean
    If UCase(s) = "FALSCH" Or UCase(s) = "FALSE" Then
        IsFalse = True
    End If
End Function


Public Function TranslationSheetExists(ByRef wb As Workbook, names As Variant) As String
    On Error GoTo nogo
    Dim name As String
    If IsArray(names) Then
        Dim n As Variant
        For Each n In names
            name = CStr(n)
            If WorksheetExists(wb, name) Then
                TranslationSheetExists = name
                Exit Function
            End If
        Next n
        If UBound(names) >= 0 Then
            TranslationSheetExists = CStr(names(0))
            Exit Function
        End If
    Else
        name = CStr(names)
        If WorksheetExists(wb, name) Then
            TranslationSheetExists = name
            Exit Function
        End If
    End If
nogo:
    
End Function

' Das gleiche wie Cells.Find - aber probiert mehrere Strings zu finden (fuer mehrere Sprachen)
Public Function TranslationFindCells(ws As Worksheet, What As Variant, LookIn As Excel.XlFindLookIn, _
                                     LookAt As Excel.XlLookAt, SearchOrder As Excel.XlSearchOrder, _
                                     SearchDirection As Excel.XlSearchDirection, MatchCase As Boolean) As Range
  Set TranslationFindCells = Nothing
  Dim s As Variant
  For Each s In What
    Dim r As Range
    Set r = ws.Cells.Find(CStr(s), LookIn:=LookIn, LookAt:=LookAt, SearchOrder:=SearchOrder, SearchDirection:=SearchDirection, MatchCase:=MatchCase)
    If Not r Is Nothing Then
      Set TranslationFindCells = r
      Exit Function
    End If
  Next s
End Function

' This works because Debug.Print is omitted in the compiled code
Public Function InIDE() As Boolean
  On Error Resume Next
  Debug.Print 0 / 0
  InIDE = Err.Number <> 0
End Function



Attribute VB_Name = "UNC"
Option Explicit

' Fuer CacheMappedDrives()
'Dim mMappedDrives As Collection
Dim mMappedDrives(0 To 25) As String
Dim mUsedDriveLetters(0 To 25) As String
Dim mNumUsedDrives As Integer
    


#If VBA7 Then
Public Declare PtrSafe Function WNetGetConnectionA Lib "mpr.dll" (ByVal lpszLocalName As String, _
                                             ByVal lpszRemoteName As String, _
                                                   cbRemoteName As Long) As Long
#Else
Public Declare Function WNetGetConnectionA Lib "mpr.dll" (ByVal lpszLocalName As String, _
                                             ByVal lpszRemoteName As String, _
                                                   cbRemoteName As Long) As Long
#End If
                                                   
                                                  

Public Function GetUNCPath(ByVal sLocalPath As String) As String
    '// -----------------------------------------------------------------
    '// Methode:   | Konvertiert einen Pfad in UNC-Pfad (\\SERVER\...)
    '// -----------------------------------------------------------------
    '// Parameter: | sLocalPath = g|fffd|ltiger, lokaler Pfad (X:\..)
    '// -----------------------------------------------------------------
    '// R|fffd|ckgabe:  | bei Erfolg = UNC-Pfad
    '//            | bei Fehler = sLocalPath
    '// -----------------------------------------------------------------
    Const NO_ERROR As Long = 0
    Dim sUNCPath As String
    Dim sResult As String
    Dim sDrive As String

    On Error Resume Next
    GetUNCPath = sLocalPath
    If Mid$(sLocalPath, 2, 1) <> ":" Then Exit Function
    '// Die API-Funktion ben|fffd|tigt nur das Laufwerk!
    sDrive = Left$(sLocalPath, 2)
    sUNCPath = Space$(260)
    If WNetGetConnectionA(sDrive, sUNCPath, Len(sUNCPath)) = NO_ERROR Then
        sResult = Left$(sUNCPath, InStr(sUNCPath, vbNullChar) - 1)
        If Len(sResult) > 0 Then
            GetUNCPath = sResult & Mid$(sLocalPath, 3)
        End If
    End If

End Function

Public Sub CacheMappedDrives()
    mNumUsedDrives = 0
    Dim i As Integer
    For i = 65 To 90
        Dim strUNCPath As String
        strUNCPath = ""
        If GetUNCPathShort(Chr(i) & ":", strUNCPath) = 0 Then
            mMappedDrives(mNumUsedDrives) = UCase(strUNCPath)
            mUsedDriveLetters(mNumUsedDrives) = Chr(i)
            mNumUsedDrives = mNumUsedDrives + 1
        Else
        
        End If
    Next i
End Sub

' Wir nehmen an uncPath ist all upper case
Public Function GetCachedMappedDrive(uncPath As String) As String
    GetCachedMappedDrive = uncPath
    Dim i As Integer
    For i = 0 To mNumUsedDrives - 1
        If mMappedDrives(i) = Left$(uncPath, Len(mMappedDrives(i))) Then
            GetCachedMappedDrive = mUsedDriveLetters(i) & ":" & Mid$(uncPath, Len(mMappedDrives(i)) + 1)
            Exit For
        End If
    Next i
End Function

Function GetDriveAndPathFromUNC(ByVal strFullPath As String) As String

    If Mid(strFullPath, 2, 1) = ":" Then
      GetDriveAndPathFromUNC = strFullPath
      Exit Function
    End If

    Dim strUNC As String
    Dim i As Integer
    Dim s As String

    s = strFullPath

    For i = 65 To 90
        If GetUNCPathShort(Chr(i) & ":", strUNC) = 0 Then
            If UCase(strUNC) = UCase(Left(strFullPath, Len(strUNC))) Then
              If Len(Chr(i) & ":" & Mid(strFullPath, Len(strUNC) + 1, Len(strFullPath) - (Len(strUNC)))) < Len(s) Then
                s = Chr(i) & ":" & Mid(strFullPath, Len(strUNC) + 1, Len(strFullPath) - (Len(strUNC)))
              End If
            End If
        End If
    Next i
    
    GetDriveAndPathFromUNC = s
    
End Function


Function GetUNCPathShort(ByVal strDriveLetter As String, _
    ByRef strUNCPath As String) As Long
    On Local Error GoTo GetUNCPath_Err
    Dim strMsg As String
    Dim lngReturn As Long
    Dim strLocalName As String
    Dim strRemoteName As String
    Dim lngRemoteName As Long
    strLocalName = strDriveLetter
    strRemoteName = String$(255, Chr$(32))
    
    lngRemoteName = Len(strRemoteName)
    'Attempt to grab UNC
    lngReturn = WNetGetConnectionA(strLocalName, _
    strRemoteName, _
    lngRemoteName)


    If lngReturn = 0 Then
        
        'No problems - return the UNC
        'to the passed ByRef string
        GetUNCPathShort = 0
        
        
        ' only works for omni 2 build
        ' strUNCPath = LTrim(strRemoteName)
        ' strUNCPath = Left$(strUNCPath, Len(str
        '     UNCPath) - 1)
        
        
        ' less acurate potential for error if se
        '     rver or share contains spaces.
        
        If InStr(strRemoteName, Chr(0)) > 0 Then
          strUNCPath = Left(strRemoteName, InStr(strRemoteName, Chr(0)) - 1)
        Else
          strUNCPath = Mid(strRemoteName, 1, (InStr(1, strRemoteName, " ", 1)) - 2)
        End If
        
        
    Else
        'Problems - so return original
        'drive letter and error number
        GetUNCPathShort = lngReturn
        strUNCPath = strDriveLetter & "\"
    End If
GetUNCPath_End:
    Exit Function
GetUNCPath_Err:
    GetUNCPathShort = 1
    strUNCPath = strDriveLetter
    Resume GetUNCPath_End
End Function



Attribute VB_Name = "UnicodeFile"
Option Explicit

#If VBA7 And Win64 Then

  Private Declare PtrSafe Function MultiByteToWideChar Lib "Kernel32.dll" ( _
      ByVal codePage As Long, _
      ByVal dwFlags As Long, _
      ByVal lpMultiByteStr As LongPtr, _
      ByVal cbMultiByte As LongPtr, _
      ByVal lpWideCharStr As LongPtr, _
      ByVal cchWideChar As Long _
  ) As Long

  Private Declare PtrSafe Function WideCharToMultiByte Lib "kernel32" ( _
      ByVal codePage As Long, ByVal dwFlags As Long, _
      ByVal lpWideCharStr As LongPtr, ByVal cchWideChar As LongPtr, _
      ByVal lpMultiByteStr As LongPtr, ByVal cchMultiByte As LongPtr, _
      ByVal lpDefaultChar As LongPtr, ByVal lpUsedDefaultChar As LongPtr) As Long
        
#Else
  Private Declare Function MultiByteToWideChar Lib "Kernel32.dll" ( _
      ByVal codePage As Long, _
      ByVal dwFlags As Long, _
      ByVal lpMultiByteStr As Long, _
      ByVal cbMultiByte As Long, _
      ByVal lpWideCharStr As Long, _
      ByVal cchWideChar As Long _
  ) As Long
  
  Private Declare Function WideCharToMultiByte Lib "Kernel32.dll" ( _
      ByVal codePage As Long, _
      ByVal dwFlags As Long, _
      ByVal lpWideCharStr As Long, _
      ByVal cchWideChar As Long, _
      ByVal lpMultiByteStr As Long, _
      ByVal cbMultiByte As Long, _
      ByVal lpDefaultChar As Long, _
      ByVal lpUsedDefaultChar As Long _
  ) As Long
#End If

Public Const CP_ACP        As Long = 0          ' Default ANSI code page.
Public Const CP_UTF8       As Long = 65001      ' UTF8.
Public Const CP_UTF16_LE   As Long = 1200       ' UTF16 - little endian.
Public Const CP_UTF16_BE   As Long = 1201       ' UTF16 - big endian.
Public Const CP_UTF32_LE   As Long = 12000      ' UTF32 - little endian.
Public Const CP_UTF32_BE   As Long = 12001      ' UTF32 - big endian.

' Purpose:  Heuristic to determine whether bytes in a file are UTF-8.
Private Function FileBytesAreUTF8(ByVal the_iFileNo As Integer) As Boolean

    Const knSampleByteSize          As Long = 2048
    Dim nLof                        As Long
    Dim nByteCount                  As Long
    Dim nByteIndex                  As Long
    Dim nCharExtraByteCount         As Long
    Dim bytValue                    As Byte

    ' We look at the first <knSampleByteSize> bytes of the file. However, if the file is smaller, we will have to
    ' use the smaller size.
    nLof = LOF(the_iFileNo)
    If nLof < knSampleByteSize Then
        nByteCount = nLof
    Else
        nByteCount = knSampleByteSize
    End If

    ' Go to the start of the file.
    Seek #the_iFileNo, 1

    For nByteIndex = 1 To nByteCount

        Get #the_iFileNo, , bytValue

        ' If the character we are processing has bytes beyond 1, then we are onto the next character.
        If nCharExtraByteCount = 0 Then
            '
            ' The UTF-8 specification says that the first byte of a character has masking bits which indicate how many bytes follow.
            '
            ' See: http://en.wikipedia.org/wiki/UTF-8#Description
            '
            ' Bytes in
            ' sequence   Byte 1   Byte 2   Byte 3   Byte 4
            ' 1          0xxxxxxx
            ' 2          110xxxxx 10xxxxxx
            ' 3          1110xxxx 10xxxxxx 10xxxxxx
            ' 4          11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
            '
            If (bytValue And &H80) = &H0 Then
                nCharExtraByteCount = 0
            ElseIf (bytValue And &HE0) = &HC0 Then
                nCharExtraByteCount = 1
            ElseIf (bytValue And &HF0) = &HE0 Then
                nCharExtraByteCount = 2
            ElseIf (bytValue And &HF8) = &HF0 Then
                nCharExtraByteCount = 3
            Else
                ' If none of these masks were matched, then this can't be a UTF-8 character.
                FileBytesAreUTF8 = False
                Exit Function
            End If
        Else
            ' All following bytes must be masked as in the table above.
            If (bytValue And &HC0) = &H80 Then
                nCharExtraByteCount = nCharExtraByteCount - 1
                If nCharExtraByteCount = 0 Then
                    FileBytesAreUTF8 = True
                End If
            Else
                ' Not a UTF8 character.
                FileBytesAreUTF8 = False
                Exit Function
            End If
        End If

    Next nByteIndex

End Function

' Purpose:  Take a string whose bytes are in the byte array <the_abytCPString>, with code page <the_nCodePage>, convert to a VB string.
Private Function FromCPString(ByRef the_abytCPString() As Byte, ByVal the_nCodePage As Long) As String

    Dim sOutput                     As String
    Dim nValueLen                   As Long
    Dim nOutputCharLen              As Long

    ' If the code page says this is already compatible with the VB string, then just copy it into the string. No messing.
    If the_nCodePage = CP_UTF16_LE Then
        FromCPString = the_abytCPString()
    Else

        ' Cache the input length.
        nValueLen = UBound(the_abytCPString) - LBound(the_abytCPString) + 1

        ' See how big the output buffer will be.
        nOutputCharLen = MultiByteToWideChar(the_nCodePage, 0&, VarPtr(the_abytCPString(LBound(the_abytCPString))), nValueLen, 0&, 0&)

        ' Resize output byte array to the size of the UTF-8 string.
        sOutput = Space$(nOutputCharLen)

        ' Make this API call again, this time giving a pointer to the output byte array.
        MultiByteToWideChar the_nCodePage, 0&, VarPtr(the_abytCPString(LBound(the_abytCPString))), nValueLen, StrPtr(sOutput), nOutputCharLen

        ' Return the array.
        FromCPString = sOutput

    End If

End Function

Public Function GetContents(ByVal the_sTextFile As String, ByRef out_nCodePage As Long, Optional ByVal the_nDesiredCodePage As Long = -1, Optional ByRef out_bContainedBOM As Boolean) As String

    Dim iFileNo                     As Integer
    Dim abytFileContents()          As Byte
    Dim nDataSize                   As Long

    iFileNo = FreeFile

    OpenForInput the_sTextFile, iFileNo, out_nCodePage, the_nDesiredCodePage, out_bContainedBOM

    ' We want to read the entire contents of the file (not including any BOM value).
    ' After calling OpenForInput(), the file pointer should be positioned after any BOM.
    ' So size file contents buffer to <file size> - <current position> + 1.
    nDataSize = LOF(iFileNo) - Seek(iFileNo) + 1
    ReDim abytFileContents(1 To nDataSize)
    Get #iFileNo, , abytFileContents()

    Close iFileNo

    ' Now we must convert this to UTF-8. But we have to first convert to the Windows NT standard UTF-16 LE.
    GetContents = FromCPString(abytFileContents(), out_nCodePage)

End Function


' Diese Funktion ist langsam!!!!!!!!!!!!!

' Purpose:  Reads up to the end of the current line of the file, repositions to the beginning of the next line, if any, and
'           outputs all characters found.
' Inputs:   the_nFileNo     The number of the file.
' Outputs:  out_sLine       The line from the current position in the file.
' Return:   True if there is more data.
Public Function LineInputUTF8(ByVal the_nFileNo As Integer, ByRef out_sLine As String) As Boolean

    Dim bytValue            As Byte
    Dim abytLine()          As Byte
    Dim nStartOfLinePos     As Long
    Dim nEndOfLinePos       As Long
    Dim nStartOfNextLine    As Long
    Dim nLineLen            As Long

    ' Save the current file position as the beginning of the line, and cache this value.
    nStartOfLinePos = Seek(the_nFileNo)

    ' Retrieves the first byte from the current position.
    Get #the_nFileNo, , bytValue

    ' Loop until the end of file is encountered.
    Do Until EOF(the_nFileNo)

        ' Check whether this byte represents a carriage return or line feed character (indicating new line).
        If bytValue = 13 Or bytValue = 10 Then
            ' By this point, the current position is *after* the CR or LF character, so to get the position of the
            ' last byte in the line, we must go back two bytes.
            nEndOfLinePos = Seek(the_nFileNo) - 2

            ' If this is a carriage return, then we must check the next character.
            If bytValue = 13 Then
                Get #the_nFileNo, , bytValue
                ' Is this a line feed?
                If bytValue = 10 Then
                ' Yes. Assume that CR-LF counts as a single NewLine. So the start of the next line should skip over the line feed.
                    nStartOfNextLine = nEndOfLinePos + 3
                Else
                ' No. The start of the next line is the current position.
                    nStartOfNextLine = nEndOfLinePos + 2
                End If
            ElseIf bytValue = 10 Then
            ' If this is a line feed, then the start of the next line is the current position.
                nStartOfNextLine = nEndOfLinePos + 2
            End If

            ' Since we have processed all the bytes in the line, exit the loop.
            Exit Do
        End If

        ' Get the next byte.
        Get #the_nFileNo, , bytValue
    Loop

    ' Check to see if there was an end of line.
    If nEndOfLinePos = 0 Then
    ' No, this is the end of the file - so use all the remaining characters.
        nLineLen = Seek(the_nFileNo) - nStartOfLinePos - 1
    Else
    ' Yes - so use all the characters up to the end of line position.
        nLineLen = nEndOfLinePos - nStartOfLinePos + 1
    End If

    ' Is this line empty?
    If nLineLen = 0 Then
    ' Yes - just return an empty string.
        out_sLine = vbNullString
    Else
    ' No - pull all the bytes from the beginning to the end of the line into a byte array, and then convert that from UTF-8 to a VB string.
        ReDim abytLine(1 To nLineLen)
        Get #the_nFileNo, nStartOfLinePos, abytLine()
        out_sLine = FromCPString(abytLine(), CP_UTF8)
    End If

    ' If there is a line afterwards, then move to the beginning of the line, and return True.
    If nStartOfNextLine > 0 Then
        Seek #the_nFileNo, nStartOfNextLine
        LineInputUTF8 = True
    End If

End Function

' Purpose:  Analogue of 'Open "fileName" For Input As #fileNo' - but also return what type of text this is via a Code Page value.
' Inputs:   the_sFileName
'           the_iFileNo
'           (the_nDesiredCodePage)  The code page that you want to use with this file.
'                                   If this value is set to the default, -1, this indicates that the code page will be ascertained from the file.
' Outputs:  out_nCodePage           There are only six valid values that are returned if <the_nDesiredCodePage> was set to -1.
'               CP_ACP        ANSI code page
'               CP_UTF8       UTF-8
'               CP_UTF16LE    UTF-16 Little Endian (VB and NT default string encoding)
'               CP_UTF16BE    UTF-16 Big Endian
'               CP_UTF32LE    UTF-32 Little Endian
'               CP_UTF32BE    UTF-32 Big Endian
'           (out_bContainedBOM)     If this was set to True, then the file started with a BOM (Byte Order Marker).
Public Sub OpenForInput(ByRef the_sFilename As String, ByVal the_iFileNo As Integer, ByRef out_nCodePage As Long, Optional ByVal the_nDesiredCodePage As Long = -1, Optional ByRef out_bContainedBOM As Boolean)

    ' Note if we want to take account of every case, we should read in the first four bytes, and check for UTF-32 low and high endian BOMs, check
    ' the first three bytes for the UTF-8 BOM, and finally check the first two bytes for UTF-16 low and hight endian BOMs.
    Dim abytBOM(1 To 4)             As Byte
    Dim nCodePage                   As Long

    ' By default, there is no BOM.
    out_bContainedBOM = False

    Open the_sFilename For Binary Access Read As #the_iFileNo

    ' We are interested in -1 (ascertain code page), and then various UTF encodings.
    Select Case the_nDesiredCodePage
    Case -1, CP_UTF8, CP_UTF16_BE, CP_UTF16_LE, CP_UTF32_BE, CP_UTF32_LE

        ' Default code page.
        nCodePage = CP_ACP

        ' Pull in the first four bytes to determine the BOM (byte order marker).
        Get #the_iFileNo, , abytBOM()

        ' The following are the BOMs for text files:
        '
        ' FF FE         UTF-16, little endian
        ' FE FF         UTF-16, big endian
        ' EF BB BF      UTF-8
        ' FF FE 00 00   UTF-32, little endian
        ' 00 00 FE FF   UTF-32, big-endian
        '
        ' Work out the code page from this information.

        Select Case abytBOM(1)
        Case &HFF
            If abytBOM(2) = &HFE Then
                If abytBOM(3) = 0 And abytBOM(4) = 0 Then
                    nCodePage = CP_UTF32_LE
                Else
                    nCodePage = CP_UTF16_LE
                End If
            End If
        Case &HFE
            If abytBOM(2) = &HFF Then
                nCodePage = CP_UTF16_BE
            End If
        Case &HEF
            If abytBOM(2) = &HBB And abytBOM(3) = &HBF Then
                nCodePage = CP_UTF8
            End If
        Case &H0
            If abytBOM(2) = &H0 And abytBOM(3) = &HFE And abytBOM(4) = &HFF Then
                nCodePage = CP_UTF32_BE
            End If
        End Select

        ' Did we match any BOMs?
        If nCodePage = CP_ACP Then
        ' No - we are still defaulting to the ANSI code page.
            ' Special check for UTF-8. The BOM is not specified in the standard for UTF-8, but according to Wikipedia (which is always right :-) ),
            ' only Microsoft includes this marker at the beginning of files.
            If FileBytesAreUTF8(the_iFileNo) Then
                out_nCodePage = CP_UTF8
            Else
                out_nCodePage = CP_ACP
            End If
        Else
        ' Yes - we have worked out the code page from the BOM.
            ' If no code page was suggested, we now return the code page we found.
            If the_nDesiredCodePage = -1 Then
                out_nCodePage = nCodePage
            End If

            ' Inform the caller that a BOM was found.
            out_bContainedBOM = True
        End If

        ' Reset the file pointer to the beginning of the file data.
        If out_bContainedBOM Then
            ' Note that if the code page found was one of the two UTF-32 values, then we are already in the correct position.
            ' Otherwise, we have to move to just after the end of the BOM.
            Select Case nCodePage
            Case CP_UTF16_BE, CP_UTF16_LE
                Seek #the_iFileNo, 3
            Case CP_UTF8
                Seek #the_iFileNo, 4
            End Select
        Else
            ' There is no BOM, so simply go the beginning of the file.
            Seek #the_iFileNo, 1
        End If

    Case Else
        out_nCodePage = the_nDesiredCodePage
    End Select

End Sub

' Purpose:  Analogue of 'Open "fileName" For Append As #fileNo'
Public Sub OpenForAppend(ByRef the_sFilename As String, ByVal the_iFileNo As Integer, Optional ByVal the_nCodePage As Long = CP_ACP, Optional ByVal the_bPrefixWithBOM As Boolean = True)

    ' Open the file and move to the end of the file.
    Open the_sFilename For Binary Access Write As #the_iFileNo
    Seek the_iFileNo, LOF(the_iFileNo) + 1

    If the_bPrefixWithBOM Then
        WriteBOM the_iFileNo, the_nCodePage
    End If

End Sub

' Purpose:  Analogue of 'Open "fileName" For Output As #fileNo'
Public Sub OpenForOutput(ByRef the_sFilename As String, ByVal the_iFileNo As Integer, Optional ByVal the_nCodePage As Long = CP_ACP, Optional ByVal the_bPrefixWithBOM As Boolean = True)

    ' Ensure we overwrite the file by deleting it ...
    On Error Resume Next
    Kill the_sFilename
    On Error GoTo 0

    ' ... before creating it.
    Open the_sFilename For Binary Access Write As #the_iFileNo

    If the_bPrefixWithBOM Then
        WriteBOM the_iFileNo, the_nCodePage
    End If

End Sub

' Purpose:  Analogue of the 'Print #fileNo, value' statement. But only one value allowed.
'           Setting <the_bAppendNewLine> = False is analagous to 'Print #fileNo, value;'.
Public Sub Print_(ByVal the_iFileNo As Integer, ByRef the_sValue As String, Optional ByVal the_nCodePage As Long = CP_ACP, Optional ByVal the_bAppendNewLine As Boolean = True)

    Const kbytNull                  As Byte = 0
    Const kbytCarriageReturn        As Byte = 13
    Const kbytNewLine               As Byte = 10

    Put #the_iFileNo, , ToCPString(the_sValue, the_nCodePage)

    If the_bAppendNewLine Then
        Select Case the_nCodePage
        Case CP_UTF16_BE
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytCarriageReturn
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNewLine
        Case CP_UTF16_LE
            Put #the_iFileNo, , kbytCarriageReturn
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNewLine
            Put #the_iFileNo, , kbytNull
        Case CP_UTF32_BE
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytCarriageReturn
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNewLine
        Case CP_UTF32_LE
            Put #the_iFileNo, , kbytCarriageReturn
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNewLine
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNull
        Case Else
            Put #the_iFileNo, , kbytCarriageReturn
            Put #the_iFileNo, , kbytNewLine
        End Select
    End If

End Sub

Public Sub PutContents(ByRef the_sFilename As String, ByRef the_sFileContents As String, Optional ByVal the_nCodePage As Long = CP_ACP, Optional the_bPrefixWithBOM As Boolean)

    Dim iFileNo                     As Integer

    iFileNo = FreeFile
    OpenForOutput the_sFilename, iFileNo, the_nCodePage, the_bPrefixWithBOM
    Print_ iFileNo, the_sFileContents, the_nCodePage, False
    Close iFileNo

End Sub

' Purpose:  Converts a VB string (UTF-16) to UTF8 - as a binary array.
Private Function ToCPString(ByRef the_sValue As String, ByVal the_nCodePage As Long) As Byte()

    Dim abytOutput()                As Byte
    Dim nValueLen                   As Long
    Dim nOutputByteLen              As Long

    If the_nCodePage = CP_UTF16_LE Then
        ToCPString = the_sValue
    Else

        ' Cache the input length.
        nValueLen = Len(the_sValue)

        ' See how big the output buffer will be.
        nOutputByteLen = WideCharToMultiByte(the_nCodePage, 0&, StrPtr(the_sValue), nValueLen, 0&, 0&, 0&, 0&)

        If nOutputByteLen > 0 Then
            ' Resize output byte array to the size of the UTF-8 string.
            ReDim abytOutput(1 To nOutputByteLen)

            ' Make this API call again, this time giving a pointer to the output byte array.
            WideCharToMultiByte the_nCodePage, 0&, StrPtr(the_sValue), nValueLen, VarPtr(abytOutput(1)), nOutputByteLen, 0&, 0&
        End If

        ' Return the array.
        ToCPString = abytOutput()

    End If

End Function

Private Sub WriteBOM(ByVal the_iFileNo As Integer, ByVal the_nCodePage As Long)

    ' FF FE         UTF-16, little endian
    ' FE FF         UTF-16, big endian
    ' EF BB BF      UTF-8
    ' FF FE 00 00   UTF-32, little endian
    ' 00 00 FE FF   UTF-32, big-endian

    Select Case the_nCodePage
    Case CP_UTF8
        Put #the_iFileNo, , CByte(&HEF)
        Put #the_iFileNo, , CByte(&HBB)
        Put #the_iFileNo, , CByte(&HBF)
    Case CP_UTF16_LE
        Put #the_iFileNo, , CByte(&HFF)
        Put #the_iFileNo, , CByte(&HFE)
    Case CP_UTF16_BE
        Put #the_iFileNo, , CByte(&HFE)
        Put #the_iFileNo, , CByte(&HFF)
    Case CP_UTF32_LE
        Put #the_iFileNo, , CByte(&HFF)
        Put #the_iFileNo, , CByte(&HFE)
        Put #the_iFileNo, , CByte(&H0)
        Put #the_iFileNo, , CByte(&H0)
    Case CP_UTF32_BE
        Put #the_iFileNo, , CByte(&H0)
        Put #the_iFileNo, , CByte(&H0)
        Put #the_iFileNo, , CByte(&HFE)
        Put #the_iFileNo, , CByte(&HFF)
    End Select

End Sub





Attribute VB_Name = "XLHelpers"
Option Explicit

Function WorkbookExists(wbname As String) As Boolean
  On Error GoTo nogo
  Dim wb As Workbook
  Set wb = Workbooks(wbname)
  Set wb = Nothing
  WorkbookExists = True
  Exit Function
nogo:
End Function

Function WorkbookExistsByFilename(wbname As String) As Boolean
  Dim wb As Workbook
  For Each wb In Workbooks
    If UCase(wb.FullName) = UCase(wbname) Then
      WorkbookExistsByFilename = True
      Exit Function
    End If
  Next wb
  Exit Function
End Function

Sub WorkbookActivateByFilename(wbname As String)
  Dim wb As Workbook
  For Each wb In Workbooks
    If UCase(wb.FullName) = UCase(wbname) Then
      wb.Activate
      Exit Sub
    End If
  Next wb
  Exit Sub
End Sub

Function WorksheetExists(ByRef wb As Workbook, wsname As String) As Boolean
  On Error GoTo nogo
  Dim ws As Worksheet
  Set ws = wb.Worksheets(wsname)
  Set ws = Nothing
  WorksheetExists = True
  Exit Function
nogo:
End Function


Sub GetLastCell(ByRef oxlwsheet As Object, ByRef r As Range)
  On Error Resume Next
  Set r = Nothing
  Set r = oxlwsheet.Cells.SpecialCells(xlCellTypeLastCell)
End Sub

Function GetLastRow(ByRef oxlwsheet As Object) As Long
  On Error Resume Next
  
  GetLastRow = 0
  
  Dim r As Range
  Set r = Nothing
  Set r = oxlwsheet.Cells.SpecialCells(xlCellTypeLastCell)
  
  If r Is Nothing Then
    Set r = oxlwsheet.Range("A1")
  End If

  Dim r2 As Range
  Set r2 = Nothing
  Set r2 = oxlwsheet.Cells.SpecialCells(xlCellTypeLastCell)
  
  Set r2 = oxlwsheet.Cells.Find(What:="*", After:=oxlwsheet.Range("A1"), LookAt:=xlWhole, LookIn:=xlFormulas, SearchDirection:=xlPrevious)
  If r2 Is Nothing Then
    Set r2 = oxlwsheet.Range("A1")
  End If
  
  
  If r2.Row > 1 Then
    GetLastRow = r2.Row
  Else
    If r2.Row > r.Row Then
      GetLastRow = r2.Row
    Else
      GetLastRow = r.Row
    End If
  End If
  Set r = Nothing
  Set r2 = Nothing
End Function


Function GetFormulaRangeLine(oxlwsheet, l As Long)
  On Error Resume Next
  Dim olddisplayalerts As Boolean
  olddisplayalerts = Application.DisplayAlerts
  Set GetFormulaRangeLine = Nothing
  Application.DisplayAlerts = False
  Set GetFormulaRangeLine = oxlwsheet.Rows(l).SpecialCells(xlCellTypeFormulas)
  Application.DisplayAlerts = olddisplayalerts
End Function
Function GetNonFormulaRangeLine(oxlwsheet, l As Long)
  On Error Resume Next
  Dim olddisplayalerts As Boolean
  olddisplayalerts = Application.DisplayAlerts
  Set GetNonFormulaRangeLine = Nothing
  Application.DisplayAlerts = False
  Set GetNonFormulaRangeLine = oxlwsheet.Rows(l).SpecialCells(xlCellTypeConstants)
  Application.DisplayAlerts = olddisplayalerts
End Function





Attribute VB_Name = "ZipStuff"
Option Explicit

Public G_7ZAvailable As Boolean
Public G_7ZTested As Boolean


Sub ExtractZip(ByVal myZipFile, ByVal myTargetDir)
     Dim intOptions, objShell, objSource, objTarget

    If G_7ZAvailable Then
      Dim errstr As String
      If ExtractZip7Z(myZipFile, myTargetDir, errstr) Then
        Exit Sub
      End If
    End If

     Set objShell = CreateObject("Shell.Application")
     Set objSource = objShell.Namespace(myZipFile).items()
     Set objTarget = objShell.Namespace(myTargetDir)

      ' These are the available CopyHere options, according to MSDN
      ' (http://msdn2.microsoft.com/en-us/library/ms723207.aspx).
     ' On my test systems, however, the options were completely ignored.
     '      4: Do not display a progress dialog box.
     '      8: Give the file a new name in a move, copy, or rename
     '         operation if a file with the target name already exists.
     '     16: Click "Yes to All" in any dialog box that is displayed.
     '     64: Preserve undo information, if possible.
     '    128: Perform the operation on files only if a wildcard file
     '         name (*.*) is specified.
     '    256: Display a progress dialog box but do not show the file
     '         names.
     '    512: Do not confirm the creation of a new directory if the
     '         operation requires one to be created.
     '   1024: Do not display a user interface if an error occurs.
     '   4096: Only operate in the local directory.
     '         Don't operate recursively into subdirectories.
     '   8192: Do not copy connected files as a group.
     '         Only copy the specified files.
      intOptions = 256

      ' UnZIP the files
     objTarget.CopyHere objSource, intOptions

     ' Release the objects
     Set objSource = Nothing
     Set objTarget = Nothing
     Set objShell = Nothing
  End Sub
  
  
Sub NewZip(sPath)
    If Len(Dir(sPath)) > 0 Then Kill sPath
    Open sPath For Output As #1
    Print #1, Chr$(80) & Chr$(75) & Chr$(5) & Chr$(6) & String(18, 0)
    Close #1
End Sub
  
Function ZipFolder(ByVal myFolder As String, ByVal myZipFile As String) As Boolean
    Dim oFolder
    Dim oApp As Object

    If G_7ZAvailable Then
      Dim errstr As String
      If ZipFolder7Z(myFolder, myZipFile, errstr) Then
        ZipFolder = True
        Exit Function
      End If
    End If


    Set oApp = CreateObject("Shell.Application")

    NewZip myZipFile

    If Right(myFolder, 1) <> "\" Then
        myFolder = myFolder & "\"
    End If

    'Keep script waiting until Compressing is done
    On Error GoTo nogo
    
    'Copy the files to the compressed folder
    oApp.Namespace(CStr(myZipFile)).CopyHere oApp.Namespace(CStr(myFolder)).items

    Do Until oApp.Namespace(CStr(myZipFile)).items.Count = _
    oApp.Namespace(CStr(myFolder)).items.Count
        Application.Wait (Now + TimeValue("0:00:01"))
    Loop
    ZipFolder = True
    Exit Function
nogo:
End Function



Public Function ZipErrorDesc(Code As Long) As String
' Check the 7-zip exit codes
    '   See
    '       <a href="http://linux.die.net/man/1/7za">http://linux.die.net/man/1/7za</a>
    '   for details
    Dim errDesc$
    Select Case Code
        Case 0
            errDesc$ = ""
        Case 1
            errDesc$ = "Warning (Non fatal error(s)). For example, some files cannot be read during compressing. So they were not compressed"
        Case 2
            errDesc$ = "Fatal error"
        Case 7
            errDesc$ = "Bad command line parameters"
        Case 8
            errDesc$ = "Not enough memory for operation"
        Case 255
            errDesc$ = "User stopped the process with control-C" & _
                       "(or similar)"
        Case Else
            errDesc$ = "Unknown exit code"
    End Select
    
    ZipErrorDesc = errDesc$
    
End Function

Function ZipFolder7Z(ByVal myFolder As String, ByVal myZipFile As String, ByRef errstr As String) As Boolean
    If Not PathExists(myFolder) Then
      errstr = myFolder & " existiert nicht!"
      Exit Function
    End If
    If Not FileExists(ThisWorkbook.path & "\7za.exe") Then
      errstr = ThisWorkbook.path & "\7za.exe existiert nicht!"
      Exit Function
    End If

    Dim shellStr As String
    shellStr = Chr(34) & ThisWorkbook.path & "\7za.exe" & Chr(34) & " a " _
             & Chr(34) & myZipFile & Chr(34) & " " _
             & Chr(34) & myFolder & "\*.*" & Chr(34) & " -r"

    Dim res As Long
    res = ShellAndWait(shellStr)  ', vbHide
    If res = 0 Then
      ZipFolder7Z = True
    Else
      errstr = ZipErrorDesc(res)
    End If

End Function

Public Function ExtractZip7Z(ByVal myZipFile As String, ByVal myTargetDir As String, ByRef errstr As String) As Boolean
    
    If Not FileExists(myZipFile) Then
      errstr = myZipFile & " existiert nicht!"
      Exit Function
    End If
    If Not PathExists(myTargetDir) Then
      errstr = myTargetDir & " existiert nicht!"
      Exit Function
    End If
    If Not FileExists(ThisWorkbook.path & "\7za.exe") Then
      errstr = ThisWorkbook.path & "\7za.exe existiert nicht!"
      Exit Function
    End If
   'There are a few commands/Switches that you can change in the ShellStr
    'We use x command now to keep the folder stucture, replace it with e if you want only the files
    '-aoa Overwrite All existing files without prompt.
    '-aos Skip extracting of existing files.
    '-aou aUto rename extracting file (for example, name.txt will be renamed to name_1.txt).
    '-aot auto rename existing file (for example, name.txt will be renamed to name_1.txt).
    'Use -r if you also want to unzip the subfolders from the zip file
    'You can add -ppassword if you want to unzip a zip file with password (only .7z files)
    'Change "*.*" to for example "*.txt" if you only want to unzip the txt files
    'Use "*.xl*" for all Excel files: xls, xlsx, xlsm, xlsb
    Dim shellStr As String
    shellStr = Chr(34) & ThisWorkbook.path & "\7za.exe" & Chr(34) & " x -aoa -r " _
             & Chr(34) & myZipFile & Chr(34) _
             & " -o" & Chr(34) & myTargetDir & Chr(34) & " " & "*.*"

    Dim res As Long
    res = ShellAndWait(shellStr)  ', vbHide
    If res = 0 Then
      ExtractZip7Z = True
    Else
      errstr = ZipErrorDesc(res)
    End If
End Function

Private Function ShellAndWait(ByVal strPathName As String) As Long
    Dim WshShell As Object
    On Error GoTo Fin
    ShellAndWait = 999
    Set WshShell = CreateObject("WScript.Shell")
    ShellAndWait = WshShell.Run(strPathName, 0, True)
Fin:
    Set WshShell = Nothing
    ' If Err.Number <> 0 Then MsgBox "Error: " & _
    '     Err.Number & " " & Err.Description
End Function


Sub TestExt()
  Dim errstr As String
  If Not ExtractZip7Z("D:\IDV-SuiteNV\IDV-Suite\ESQA\PWTester.xlsx.zip", "D:\IDV-SuiteNV\IDV-Suite\ESQA\Testdepack", errstr) Then
    Debug.Print errstr
  Else
    Debug.Print "OK"
  End If

  If Not ZipFolder7Z("D:\IDV-SuiteNV\IDV-Suite\ESQA\Testdepack", "D:\IDV-SuiteNV\IDV-Suite\ESQA\PWTester.xlsx.Test.zip", errstr) Then
    Debug.Print errstr
  Else
    Debug.Print "OK"
  End If
End Sub

Function Test7z() As Boolean
  
  If G_7ZTested Then
    Test7z = G_7ZAvailable
    Exit Function
  End If
  
  G_7ZTested = True
  
  
  If Not FileExists(ThisWorkbook.path & "\7za.exe") Then
    Debug.Print ThisWorkbook.path & "\7za.exe existiert nicht!"
    Exit Function
  End If
  If Not FileExists(ThisWorkbook.path & "\PWTester.xlsx") Then
    Debug.Print ThisWorkbook.path & "\PWTester.xlsx existiert nicht!"
    Exit Function
  End If
  Dim errstr As String
  MkFullDir G_cfgTemppfad & "\" & GetUserName
  If Not PathExists(G_cfgTemppfad & "\" & GetUserName) Then
    Debug.Print G_cfgTemppfad & "\" & GetUserName & " existiert nicht!"
    Exit Function
  End If
  
  If Not ExtractZip7Z(ThisWorkbook.path & "\PWTester.xlsx", G_cfgTemppfad & "\" & GetUserName, errstr) Then
    Debug.Print errstr
  Else
    Debug.Print "OK"
  End If
  If Not FileExists(G_cfgTemppfad & "\" & GetUserName & "\xl\workbook.xml") Then
    Debug.Print ThisWorkbook.path & "\PWTester.xlsx existiert nicht!"
    Exit Function
  End If
  
  DelTree G_cfgTemppfad & "\" & GetUserName
  
  G_7ZAvailable = True
  Test7z = True

End Function
Attribute VB_Name = "start"
Option Explicit

Dim Startpath As String

Public thefConstants As Boolean
Public thefTextNumbers As Boolean
Public thefUnusedNumbers As Boolean
Public thefUnprotectedFormulas As Boolean
Public thefErrors As Boolean
Public thefForgottenCells As Boolean
Public thefInvisibleCells As Boolean
Public thefExternals As Boolean

Public G_ESQAFindConstants As Boolean
Public G_ESQAFindUnusedNumbers As Boolean
Public G_ESQAFindTextNumbers As Boolean
Public G_ESQAFindFormulaCellsWithoutProtection As Boolean
Public G_ESQAFindErrors As Boolean
Public G_ESQAFindForgottenCells As Boolean
Public G_ESQAFindInvisibleCells As Boolean
Public G_ESQAFindExternals As Boolean

Public G_CellFormats As Collection

Public G_InitDone As Boolean
Public G_StartSheetWB As String
Public G_StartSheetName As String
Public G_StartSheetCell As String

Public Function CheckStartupStuff()

'  If Not G_cTodo Is Nothing Then Exit Function
  
'  Set G_cTodo = New CTodo

  If G_InitDone Then Exit Function
  
  G_InitDone = True

  Dim cfg As New CfgReader
  Dim s As String
  
  Startpath = ThisWorkbook.path
  
  G_cfgKeypfad = ThisWorkbook.path
  G_cfgLogpfad = ThisWorkbook.path
  G_cfgTemppfad = ThisWorkbook.path
  G_cfgPasswortpfad = ThisWorkbook.path
  
'  ElseIf FileExists(ThisWorkbook.path & "\swres.swk") Then
'    Open ThisWorkbook.path & "\swres.swk" For Binary Access Read As #ff ' Len = 4
'  ElseIf FileExists(ThisWorkbook.Path & "\..\idv-suite\key\swres.swk") Then
'    Open ThisWorkbook.Path & "\..\idv-suite\key\swres.swk" For Binary Access Read As #ff ' Len = 4
  
  
  If FileExists(ThisWorkbook.path & "\ESQA.cfg") = True Or FileExists(ThisWorkbook.path & "\..\cfg\IDV-Suite.cfg") = True Or FileExists(ThisWorkbook.path & "\..\..\cfg\IDV-Suite.cfg") = True Then

      If FileExists(ThisWorkbook.path & "\..\cfg\IDV-Suite.cfg") Then
        cfg.GetCfg ThisWorkbook.path & "\..\cfg\IDV-Suite.cfg"
      ElseIf FileExists(ThisWorkbook.path & "\..\..\cfg\IDV-Suite.cfg") Then
        cfg.GetCfg ThisWorkbook.path & "\..\..\cfg\IDV-Suite.cfg"
      ElseIf FileExists(ThisWorkbook.path & "\ESQA.cfg") = True Then
        cfg.GetCfg ThisWorkbook.path & "\ESQA.cfg"
      End If
      
      Call InitTranslation(ThisWorkbook.path, "ESQA", cfg)
      
      If cfg.GetSection("ESQA") = True Then
          s = cfg.GetValue("LOG")
          If IsYes(s) Then
            G_LogEnabled = True
          End If
      End If
      If cfg.GetSection("GLOBALS") = True Then
          G_cfgKeypfad = GetRelativePath(G_cfgKeypfad, cfg.GetValue("KEYPFAD"))
          G_cfgLogpfad = GetRelativePath(G_cfgLogpfad, cfg.GetValue("LOGPFAD"))
          G_cfgTemppfad = GetRelativePath(G_cfgTemppfad, cfg.GetValue("TEMPPFAD"))
          G_cfgPasswortpfad = GetRelativePath(G_cfgPasswortpfad, cfg.GetValue("PASSWORTPFAD"))
          If IsNo(cfg.GetValue("MODULMEN|fffd|")) Then
            G_ModulmenueDeaktivieren = True
          End If
      End If
  Else
      Call InitTranslation(ThisWorkbook.path, "ESQA", cfg)
  End If
    
  ClearLog
    
  LogPrint "ESQA Start"
  
  If Not FileExists(ThisWorkbook.path & "\Excel-Sheet-QA-Menu.cfg") Then
    LogPrint "Es ist keine CFG-Datei Excel-Sheet-QA-Menu.cfg im Programmordner '" & ThisWorkbook.path & "' vorhanden"
    'MsgBox "Es ist keine CFG-Datei Excel-Sheet-QA-Menu.cfg im Programmordner '" & ThisWorkbook.path & "' vorhanden, das Programm wird beendet. ", vbCritical, "ESQA " & MyVersion
    MsgBox FMT1("MSTART_2", ThisWorkbook.path), vbCritical, "ESQA " & MyVersion
    Exit Function
  End If
  
  Dim formatFilePath As String
  formatFilePath = gTranslation.GetLocalizedFile(ThisWorkbook.path & "\Excel-Sheet-QA-Format.xls")
  'If Not FileExists(ThisWorkbook.path & "\Excel-Sheet-QA-Format.xls") Then
  If Not FileExists(formatFilePath) Then
    LogPrint "Es ist keine Format-Datei Excel-Sheet-QA-Format.xls im Programmordner '" & ThisWorkbook.path & "' vorhanden"
    'MsgBox "Es ist keine Format-Datei Excel-Sheet-QA-Format.xls im Programmordner '" & ThisWorkbook.path & "' vorhanden, das Programm wird beendet. ", vbCritical, "ESQA " & MyVersion
    MsgBox FMT1("MSTART_3", ThisWorkbook.path), vbCritical, "ESQA " & MyVersion
    Exit Function
  End If
  
  G_MyLicencseVersion = 0

  FullVersion = False
  G_UpdateAvailable = False
  
  GetData
  LogPrint "GetData finished"
  
'  CheckVersion 30, "ESQA", "ESQAVersion.txt", "ESQAVersion2.txt", MyVersion, MyInternalVersion
  
  If G_MyLicencseVersion < MyProgramLicenseVersion And FullVersion = True Then
    If Now < MyFreeUsage Then
      'MsgBox "Ihr Lizenzkey f|fffd|r dieses Programm ist veraltet. Um diese Version nutzen zu k|fffd|nnen, ben|fffd|tigen Sie einen neuen Lizenzkey, wenden Sie sich hierzu bitte an info@stromwerken.de. Das Programm kann bis zum " & MyFreeUsage & " mit dem vollen Funktionsumfang genutzt werden, danach steht nur noch die Demo zur Verf|fffd|gung.", vbCritical, "ESQA " & MyVersion
      MsgBox FMT1("MSTART_4", MyFreeUsage), vbCritical, "ESQA " & MyVersion
    Else
      'MsgBox "Ihr Lizenzkey f|fffd|r dieses Programm ist veraltet. Um diese Version nutzen zu k|fffd|nnen, ben|fffd|tigen Sie einen neuen Lizenzkey, wenden Sie sich hierzu bitte an info@stromwerken.de. Das Programm wird jetzt als Demoversion ausgef|fffd|hrt.", vbCritical, "ESQA " & MyVersion
      MsgBox FMT0("MSTART_5"), vbCritical, "ESQA " & MyVersion
      FullVersion = False
    End If
  End If
  LogPrint "License check finished"
  
  
  
  LogPrint "Set menu bar"
  Dim found As Boolean
  Dim c
  For Each c In Application.CommandBars("Worksheet Menu Bar").Controls
      If c.Caption = "ESQA" Then
          Application.CommandBars("Worksheet Menu Bar").Controls("ESQA").Delete
      End If
  Next c
  
  
  Dim cbb As CommandBarPopup
  Dim scbb As CommandBarButton
  
  
  Set G_CellFormats = New Collection
  
  LogPrint "Get format"
  
  Dim wb As Excel.Workbook
  Dim app As Excel.Application
  Set app = New Excel.Application
  
  
  Dim i As Long
  
  Dim indivFormatFile As String
  Dim formatFile As String
  indivFormatFile = ThisWorkbook.path & "\Excel-Sheet-QA-Format-Indiv.xls" ' gTranslation.GetLocalizedFile(ThisWorkbook.path & "\Excel-Sheet-QA-Format-Indiv.xls")
  formatFile = ThisWorkbook.path & "\Excel-Sheet-QA-Format.xls" ' gTranslation.GetLocalizedFile(ThisWorkbook.path & "\Excel-Sheet-QA-Format.xls")
  
  
  
  'If FileExists(ThisWorkbook.path & "\Excel-Sheet-QA-Format-Indiv.xls") Then
  If FileExists(indivFormatFile) Then
    'Set wb = app.Workbooks.Open(ThisWorkbook.path & "\Excel-Sheet-QA-Format-Indiv.xls", False, True, , , , True, , , False, False, , False)
    Set wb = app.Workbooks.Open(indivFormatFile, False, True, , , , True, , , False, False, , False)
  'ElseIf FileExists(ThisWorkbook.path & "\Excel-Sheet-QA-Format.xls") Then
  ElseIf FileExists(formatFile) Then
    'Set wb = app.Workbooks.Open(ThisWorkbook.path & "\Excel-Sheet-QA-Format.xls", False, True, , , , True, , , False, False, , False)
    Set wb = app.Workbooks.Open(formatFile, False, True, , , , True, , , False, False, , False)
  End If
  
  
  LogPrint "Format open"
  
  ' Dann mal alle Formate holen!
  Dim tCellFormat As CellFormat
  
  Set tCellFormat = New CellFormat
  tCellFormat.GetFormat wb.Sheets("ESQAFormat").Cells(4, 3)
  G_CellFormats.Add tCellFormat, "ESQAFindConstants"
  
  Set tCellFormat = New CellFormat
  tCellFormat.GetFormat wb.Sheets("ESQAFormat").Cells(6, 3)
  G_CellFormats.Add tCellFormat, "ESQAFindUnusedNumbers"
  
  Set tCellFormat = New CellFormat
  tCellFormat.GetFormat wb.Sheets("ESQAFormat").Cells(8, 3)
  G_CellFormats.Add tCellFormat, "ESQAFindTextNumbers"
  
  Set tCellFormat = New CellFormat
  tCellFormat.GetFormat wb.Sheets("ESQAFormat").Cells(10, 3)
  G_CellFormats.Add tCellFormat, "ESQAFindFormulaCellsWithoutProtection"
  
  Set tCellFormat = New CellFormat
  tCellFormat.GetFormat wb.Sheets("ESQAFormat").Cells(12, 3)
  G_CellFormats.Add tCellFormat, "ESQAFindErrors"
  
  Set tCellFormat = New CellFormat
  tCellFormat.GetFormat wb.Sheets("ESQAFormat").Cells(15, 3)
  G_CellFormats.Add tCellFormat, "ESQAFindForgottenCells1"
  
  Set tCellFormat = New CellFormat
  tCellFormat.GetFormat wb.Sheets("ESQAFormat").Cells(15, 5)
  G_CellFormats.Add tCellFormat, "ESQAFindForgottenCells2"
  
  Set tCellFormat = New CellFormat
  tCellFormat.GetFormat wb.Sheets("ESQAFormat").Cells(17, 3)
  G_CellFormats.Add tCellFormat, "ESQAComplexFormulas"
  
  Set tCellFormat = New CellFormat
  tCellFormat.GetFormat wb.Sheets("ESQAFormat").Cells(19, 3)
  G_CellFormats.Add tCellFormat, "ESQAFindExternals"
  
  Set tCellFormat = New CellFormat
  tCellFormat.GetFormat wb.Sheets("ESQAFormat").Cells(21, 3)
  G_CellFormats.Add tCellFormat, "ESQAFindInvisibleCells"
  
  wb.Close
  Set wb = Nothing
  app.Quit
  Set app = Nothing
  
  LogPrint "Format finished"
  
  ' Localization: Diese cfgs sind lagnuage neutral
  If FileExists(ThisWorkbook.path & "\Excel-Sheet-QA-Menu-Indiv.cfg") Then
    cfg.GetCfg ThisWorkbook.path & "\Excel-Sheet-QA-Menu-Indiv.cfg"
  ElseIf FileExists(ThisWorkbook.path & "\Excel-Sheet-QA-Menu.cfg") Then
    cfg.GetCfg ThisWorkbook.path & "\Excel-Sheet-QA-Menu.cfg"
  End If
  
  
#If EXCELSHEETQADLL <> 1 Then
        LogPrint "Check menu cfg"
        
        Set cbb = Application.CommandBars("Worksheet Menu Bar").Controls.Add(Type:=msoControlPopup)
        cbb.Caption = "ESQA"
        
        If cfg.GetSection("Menu") Then
        
          LogPrint "Special menu"
          
          Dim bBeginGroup As Boolean
          bBeginGroup = False
          
          Dim ESQAFindAllFound As Boolean
          ESQAFindAllFound = False
          
          For i = 1 To 30
            Select Case cfg.GetValue("Item" & i)
              
              Case "BeginGroup"
                  bBeginGroup = True
              
              Case "ESQAFindConstants"
                  Set scbb = cbb.Controls.Add
                  scbb.BeginGroup = bBeginGroup
                  bBeginGroup = False
                  scbb.Style = msoButtonCaption
                  'scbb.Caption = "Formeln mit Konstanten finden"
                  scbb.Caption = FMT0("MSTART_6")
                  scbb.OnAction = "ESQAFindConstants"
                  'scbb.DescriptionText = "Sucht Formeln, in denen konstante Ausdr|fffd|cke (z.B. *1,16 oder +5 etc.) enthalten sind."
                  scbb.DescriptionText = FMT0("MSTART_7")
                  G_ESQAFindConstants = True
                  If Not ESQAFindAllFound Then
                    G_All_ESQAFindConstants = True
                  End If
                  
              Case "ESQAFindUnusedNumbers"
                  Set scbb = cbb.Controls.Add
                  scbb.BeginGroup = bBeginGroup
                  bBeginGroup = False
                  scbb.Style = msoButtonCaption
                  'scbb.Caption = "Ungenutzte Zahlen finden"
                  scbb.Caption = FMT0("MSTART_8")
                  scbb.OnAction = "ESQAFindUnusedNumbers"
                  'scbb.DescriptionText = "Sucht Zellen mit Zahlen, die in keiner Formel genutzt werden."
                  scbb.DescriptionText = FMT0("MSTART_9")
                  G_ESQAFindUnusedNumbers = True
                  If Not ESQAFindAllFound Then
                    G_All_ESQAFindUnusedNumbers = True
                  End If
                  
              Case "ESQAFindTextNumbers"
                  Set scbb = cbb.Controls.Add
                  scbb.BeginGroup = bBeginGroup
                  bBeginGroup = False
                  scbb.Style = msoButtonCaption
                  'scbb.Caption = "'Textzahlen' finden"
                  scbb.Caption = FMT0("MSTART_10")
                  scbb.OnAction = "ESQAFindTextNumbers"
                  'scbb.DescriptionText = "Sucht Zellen mit Zahlen, die so formatiert sind, dass sie von Excel nicht als Zahl interpretiert werden und zu Fehlern f|fffd|hren."
                  scbb.DescriptionText = FMT0("MSTART_11")
                  G_ESQAFindTextNumbers = True
                  If Not ESQAFindAllFound Then
                    G_All_ESQAFindTextNumbers = True
                  End If
              
              Case "ESQAFindFormulaCellsWithoutProtection"
                  Set scbb = cbb.Controls.Add
                  scbb.BeginGroup = bBeginGroup
                  bBeginGroup = False
                  scbb.Style = msoButtonCaption
                  'scbb.Caption = "Formelzellen ohne Zellschutz finden"
                  scbb.Caption = FMT0("MSTART_12")
                  scbb.OnAction = "ESQAFindFormulaCellsWithoutProtection"
                  'scbb.DescriptionText = "Sucht Zellen mit Formeln, bei denen der Zellschutz nicht aktiviert ist (unabh|fffd|ngig von einem Blattschutz!)."
                  scbb.DescriptionText = FMT0("MSTART_13")
                  G_ESQAFindFormulaCellsWithoutProtection = True
                  If Not ESQAFindAllFound Then
                    G_All_ESQAFindFormulaCellsWithoutProtection = True
                  End If
              
              Case "ESQAFindErrors"
                  Set scbb = cbb.Controls.Add
                  scbb.BeginGroup = bBeginGroup
                  bBeginGroup = False
                  scbb.Style = msoButtonCaption
                  'scbb.Caption = "Formelzellen mit Fehlern finden"
                  scbb.Caption = FMT0("MSTART_14")
                  scbb.OnAction = "ESQAFindErrors"
                  'scbb.DescriptionText = "Sucht Zellen mit Formeln, in denen ein Fehler vorhanden ist."
                  scbb.DescriptionText = FMT0("MSTART_15")
                  G_ESQAFindErrors = True
                  If Not ESQAFindAllFound Then
                    G_All_ESQAFindErrors = True
                  End If
              
              Case "ESQAFindForgottenCells"
                  Set scbb = cbb.Controls.Add
                  scbb.BeginGroup = bBeginGroup
                  bBeginGroup = False
                  scbb.Style = msoButtonCaption
                  'scbb.Caption = "'Vergessene' Zellen finden"
                  scbb.Caption = FMT0("MSTART_16")
                  scbb.OnAction = "ESQAFindForgottenCells"
                  'scbb.DescriptionText = "Sucht Zellen, (evtl.) von Formeln vergessen wurden (z.B. in einer Summe fehlt die unterste Zeile)."
                  scbb.DescriptionText = FMT0("MSTART_17")
                  G_ESQAFindForgottenCells = True
                  If Not ESQAFindAllFound Then
                    G_All_ESQAFindForgottenCells = True
                  End If
              
              Case "ESQAFindInvisibleCells"
                  Set scbb = cbb.Controls.Add
                  scbb.BeginGroup = bBeginGroup
                  bBeginGroup = False
                  scbb.Style = msoButtonCaption
                  'scbb.Caption = "Unsichtbare Zellen finden"
                  scbb.Caption = FMT0("MSTART_18")
                  scbb.OnAction = "ESQAFindInvisibleCells"
                  'scbb.DescriptionText = "Sucht Zellen mit der Zahlenformatierung ;;; oder mit |fffd|hnlicher Hintergund- und Textfarbe (bis zu 16 RGB-Werte auseinander)."
                  scbb.DescriptionText = FMT0("MSTART_19")
                  G_ESQAFindInvisibleCells = True
                  If Not ESQAFindAllFound Then
                    G_All_ESQAFindInvisibleCells = True
                  End If
              
              Case "ESQAFindAll"
                  Set scbb = cbb.Controls.Add
                  scbb.BeginGroup = bBeginGroup
                  bBeginGroup = False
                  scbb.Style = msoButtonCaption
                  'scbb.Caption = "Alle ausf|fffd|hren"
                  scbb.Caption = FMT0("MSTART_20")
                  scbb.OnAction = "ESQAFindAll"
                  'scbb.DescriptionText = "F|fffd|hrt alle Suchfunktionen auf einmal aus."
                  scbb.DescriptionText = FMT0("MSTART_21")
                  ESQAFindAllFound = True
              
                  ' Sonstiges
              Case "ESQACheckExternalReferences"
                  Set scbb = cbb.Controls.Add
                  scbb.BeginGroup = bBeginGroup
                  bBeginGroup = False
                  scbb.Style = msoButtonCaption
                  'scbb.Caption = "Existenz verkn|fffd|pfter Dateien pr|fffd|fen"
                  scbb.Caption = FMT0("MSTART_22")
                  scbb.OnAction = "ESQACheckExternalReferences"
                  'scbb.DescriptionText = "Pr|fffd|ft, ob verkn|fffd|pfte Dateien vorhanden sind und zeigt an, ob die Dateien auch noch existieren."
                  scbb.DescriptionText = FMT0("MSTART_23")
              
              
                  ' Maps
               Case "ESQAColourReferenceAmount"
                 Set scbb = cbb.Controls.Add
                  scbb.BeginGroup = bBeginGroup
                  bBeginGroup = False
                  scbb.Style = msoButtonCaption
                  'scbb.Caption = "Referenzanzahl anzeigen"
                  scbb.Caption = FMT0("MSTART_24")
                  scbb.OnAction = "ESQAColourReferenceAmount"
                  'scbb.DescriptionText = "F|fffd|rbt Zellen in Abh|fffd|ngigkeit der Anzahl der referenzierenden Zellen ein."
                  scbb.DescriptionText = FMT0("MSTART_25")
              
               Case "ESQAColourClones"
                 Set scbb = cbb.Controls.Add
                  scbb.BeginGroup = bBeginGroup
                  bBeginGroup = False
                  scbb.Style = msoButtonCaption
                  'scbb.Caption = "Geklonte Formeln anzeigen"
                  scbb.Caption = FMT0("MSTART_26")
                  scbb.OnAction = "ESQAColourClones"
                  'scbb.DescriptionText = "F|fffd|rbt Zellen, die von anderen geklont wurden (durch Replizieren / Ziehen)."
                  scbb.DescriptionText = FMT0("MSTART_27")
              
              '    Set scbb = cbb.Controls.Add
              '    scbb.beginGroup = bBeginGroup
              '    bBeginGroup = False
              '    scbb.Style = msoButtonCaption
              '    scbb.Caption = "Start"
              '    scbb.OnAction = "ESQAShowMainMenu"
              '    scbb.DescriptionText = "Startet die Excel-Sheet-Analyse"
                  
                  
                  ' Finds
                  
              Case "ESQAFindExternals"
                  Set scbb = cbb.Controls.Add
                  scbb.BeginGroup = bBeginGroup
                  bBeginGroup = False
                  scbb.Style = msoButtonCaption
                  'scbb.Caption = "Zellen mit Verkn|fffd|pfungen auf externe Dateien"
                  scbb.Caption = FMT0("MSTART_28")
                  scbb.OnAction = "ESQAFindExternals"
                  'scbb.DescriptionText = "Alle Zellen, die auf eine andere Excel-Datei verweisen, werden eingef|fffd|rbt."
                  scbb.DescriptionText = FMT0("MSTART_29")
                  G_ESQAFindExternals = True
                  If Not ESQAFindAllFound Then
                    G_All_ESQAFindExternals = True
                  End If
                  
              Case "ESQAComplexFormulas"
                  Set scbb = cbb.Controls.Add
                  scbb.BeginGroup = bBeginGroup
                  bBeginGroup = False
                  scbb.Style = msoButtonCaption
                  'scbb.Caption = "Komplexe Formeln finden"
                  scbb.Caption = FMT0("MSTART_30")
                  scbb.OnAction = "ESQAKomplexeFormeln"
                  'scbb.DescriptionText = "Findet komplexere Formeln mit bestimmbaren Bedingungen."
                  scbb.DescriptionText = FMT0("MSTART_31")
                  
              ' Sonstiges
              Case "ESQAShowAll"
                  Set scbb = cbb.Controls.Add
                  scbb.BeginGroup = bBeginGroup
                  bBeginGroup = False
                  scbb.Style = msoButtonCaption
                  'scbb.Caption = "Alle Zellen (optimal) einblenden"
                  scbb.Caption = FMT0("MSTART_32")
                  scbb.OnAction = "ESQAAllesEinblendenFunc"
                  'scbb.DescriptionText = "Alle Zellen, die ausgeblendet waren, werden sichtbar gemacht. Zus|fffd|tzlich wird die optimale Breite f|fffd|r alle Zellen eingestellt."
                  scbb.DescriptionText = FMT0("MSTART_33")
                  
              Case "ESQAOpenCopy"
                  Set scbb = cbb.Controls.Add
                  scbb.BeginGroup = bBeginGroup
                  bBeginGroup = False
                  scbb.Style = msoButtonCaption
                  'scbb.Caption = "ESQA-Datei |fffd|ffnen"
                  scbb.Caption = FMT0("MSTART_34")
                  scbb.OnAction = "ESQAOpenCopy"
                  'scbb.DescriptionText = "|fffd|ffnet die ESQA-Datei (Sicherheitskopie) der aktuellen Datei (falls vorhanden)."
                  scbb.DescriptionText = FMT0("MSTART_35")
                  
                  
              '    Set scbb = cbb.Controls.Add
              '    scbb.beginGroup = bBeginGroup
              '    bBeginGroup = False
              '    scbb.Style = msoButtonCaption
              '    scbb.Caption = "Text in Formeln suchen"
              '    scbb.OnAction = "ESQATextInFormelnSuchen"
              '    scbb.DescriptionText = "Sucht in allen Tabellen nach bestimmten Texten in Formeln."
                  
              Case "ESQAShowBar"
                  Set scbb = cbb.Controls.Add
                  scbb.BeginGroup = bBeginGroup
                  bBeginGroup = False
                  scbb.Style = msoButtonCaption
                  'scbb.Caption = "Suchleiste anzeigen"
                  scbb.Caption = FMT0("MSTART_36")
                  scbb.OnAction = "ESQAShowBar"
                  'scbb.DescriptionText = "Zeigt eine Leiste an, mit der Sie die Ergebniszellen 'durchsteppen' k|fffd|nnen."
                  scbb.DescriptionText = FMT0("MSTART_37")
                  
                  
      '        Case "ESQACreateTodo"
      '            Set scbb = cbb.Controls.Add
      '            scbb.BeginGroup = bBeginGroup
      '            bBeginGroup = False
      '            scbb.Style = msoButtonCaption
      '            'scbb.Caption = "Todo-Datei erzeugen"
      '            scbb.Caption = FMT0("MSTART_38")
      '            scbb.OnAction = "ESQATododateiErzeugen"
      '            'scbb.DescriptionText = "Wenn aktiv werden Todo-Elemente f|fffd|r relevante Zellen erzeugt."
      '            scbb.DescriptionText = FMT0("MSTART_39")
                  
      '        Case "ESQAShowTodo"
      '            Set scbb = cbb.Controls.Add
      '            scbb.BeginGroup = bBeginGroup
      '            bBeginGroup = False
      '            scbb.Style = msoButtonCaption
      '            'scbb.Caption = "Empfehlungen / Todos anzeigen"
      '            scbb.Caption = FMT0("MSTART_40")
      '            scbb.OnAction = "ESQAShowTodo"
      '            'scbb.DescriptionText = "Zeigt die Empfehlungen und Todos f|fffd|r die Datei an."
      '            scbb.DescriptionText = FMT0("MSTART_41")
                  
            End Select
          Next i
        End If
        
        
        LogPrint "Add menu items"
        
        
        Set scbb = cbb.Controls.Add
        scbb.tag = "ESQAColourCurrentTable"
        scbb.BeginGroup = True
        scbb.Style = msoButtonCaption
        'scbb.Caption = "Nur aktuelle Tabelle einf|fffd|rben"
        scbb.Caption = FMT0("MSTART_42")
        scbb.OnAction = "ESQAColourCurrentTable"
        'scbb.DescriptionText = "Legt fest, ob die aktuelle Tabelle oder das gesamte Dokument eingef|fffd|rbt wird."
        scbb.DescriptionText = FMT0("MSTART_43")
        scbb.state = msoButtonUp
        
      '    Set scbb = cbb.Controls.Add
      '    scbb.BeginGroup = False
      '    scbb.Style = msoButtonCaption
      '    scbb.Caption = "Aus Men|fffd| entfernen"
      '    scbb.OnAction = "ESQARemoveMenu"
      '    scbb.DescriptionText = "Entfernt die Excel-Sheet-Analyse"
        
        Set scbb = cbb.Controls.Add
        scbb.BeginGroup = False
        scbb.Style = msoButtonCaption
        'scbb.Caption = "Kommentare erzeugen"
        scbb.Caption = FMT0("MSTART_44")
        scbb.OnAction = "ESQAKommentareErzeugen"
        'scbb.DescriptionText = "Wenn aktiv werden Kommentare an Zellen angebracht, ansonsten nur eingef|fffd|rbt."
        scbb.DescriptionText = FMT0("MSTART_45")
        
        Set scbb = cbb.Controls.Add
        scbb.BeginGroup = False
        scbb.Style = msoButtonCaption
        'scbb.Caption = "Ergebnisse in eigener Datei"
        scbb.Caption = FMT0("MSTART_46")
        scbb.OnAction = "ESQAErgebnisseInEigenerDatei"
        'scbb.DescriptionText = "Zeigt die Ergebnisse in einer eigenen, neuen Excel-Datei, wenn aktiviert. Ansonsten werden die Ergebnisse in der ESQA-Analyse-Datei angezeigt."
        scbb.DescriptionText = FMT0("MSTART_47")
        
        Set scbb = cbb.Controls.Add
        scbb.BeginGroup = False
        scbb.Style = msoButtonCaption
        'scbb.Caption = "Klone einzeln anzeigen"
        scbb.Caption = FMT0("MSTART_87")
        scbb.OnAction = "ESQAKloneEinzeln"
        'scbb.DescriptionText = "Jeder Klon wird in der Ergebnisdatei auch als anklickbarer Link angezeigt, damit alle Zellen direkt angesprungen werden k|fffd|nnen."
        scbb.DescriptionText = FMT0("MSTART_88")
        
        Set scbb = cbb.Controls.Add
        scbb.BeginGroup = False
        scbb.Style = msoButtonCaption
        'scbb.Caption = "Zellen einf|fffd|rben (zeitintensiv!)"
        scbb.Caption = FMT0("MSTART_83")
        scbb.OnAction = "ESQAZellenEinfaerben"
        'scbb.DescriptionText = "F|fffd|rbt 'gefundene' Zellen der ESQA-Analyse-Datei ein. Manche Auswertungen wie z.B. 'geklonte Formeln anzeigen' f|fffd|rben Zellen immer ein"
        scbb.DescriptionText = FMT0("MSTART_84")
        
        
        LogPrint "Save settings"
        
        If ControlExists(Application.CommandBars("Worksheet Menu Bar").Controls("ESQA"), FMT0("MSTART_44")) Then ' "Kommentare erzeugen"
          If GetSetting( _
            appname:="Stromwerken", _
            Section:="ESQA", _
            Key:="Comment", Default:=1) = 1 Then
            G_KommentareErzeugen = True
            'Application.CommandBars("Worksheet Menu Bar").Controls("ESQA").Controls("Kommentare erzeugen").state = msoButtonDown
            Application.CommandBars("Worksheet Menu Bar").Controls("ESQA").Controls(FMT0("MSTART_44")).state = msoButtonDown
          Else
            G_KommentareErzeugen = False
            'Application.CommandBars("Worksheet Menu Bar").Controls("ESQA").Controls("Kommentare erzeugen").state = msoButtonUp
            Application.CommandBars("Worksheet Menu Bar").Controls("ESQA").Controls(FMT0("MSTART_44")).state = msoButtonUp
          End If
        Else
          G_KommentareErzeugen = True
        End If
        
        
        If ControlExists(Application.CommandBars("Worksheet Menu Bar").Controls("ESQA"), FMT0("MSTART_87")) Then ' "Klone einzeln anzeigen"
          If GetSetting( _
            appname:="Stromwerken", _
            Section:="ESQA", _
            Key:="KloneEinzeln", Default:=1) = 0 Then
            G_KloneEinzeln = True
            'Application.CommandBars("Worksheet Menu Bar").Controls("ESQA").Controls("Klone einzeln anzeigen").state = msoButtonDown
            Application.CommandBars("Worksheet Menu Bar").Controls("ESQA").Controls(FMT0("MSTART_87")).state = msoButtonDown
          Else
            G_KloneEinzeln = False
            'Application.CommandBars("Worksheet Menu Bar").Controls("ESQA").Controls("Klone einzeln anzeigen").state = msoButtonUp
            Application.CommandBars("Worksheet Menu Bar").Controls("ESQA").Controls(FMT0("MSTART_87")).state = msoButtonUp
          End If
        Else
          G_KommentareErzeugen = True
        End If
        
        
        'If ControlExists(Application.CommandBars("Worksheet Menu Bar").Controls("ESQA"), "Ergebnisse in eigener Datei") Then
        If ControlExists(Application.CommandBars("Worksheet Menu Bar").Controls("ESQA"), FMT0("MSTART_46")) Then
          If GetSetting( _
            appname:="Stromwerken", _
            Section:="ESQA", _
            Key:="ErgebnisseInEigenerDatei", Default:=1) = 1 Then
            G_ErgebnisseInEigenerDatei = True
            'Application.CommandBars("Worksheet Menu Bar").Controls("ESQA").Controls("Ergebnisse in eigener Datei").state = msoButtonDown
            Application.CommandBars("Worksheet Menu Bar").Controls("ESQA").Controls(FMT0("MSTART_46")).state = msoButtonDown
          Else
            G_ErgebnisseInEigenerDatei = False
            'Application.CommandBars("Worksheet Menu Bar").Controls("ESQA").Controls("Ergebnisse in eigener Datei").state = msoButtonUp
            Application.CommandBars("Worksheet Menu Bar").Controls("ESQA").Controls(FMT0("MSTART_46")).state = msoButtonUp
          End If
        Else
          G_ErgebnisseInEigenerDatei = True
        End If
        
        If ControlExists(Application.CommandBars("Worksheet Menu Bar").Controls("ESQA"), FMT0("MSTART_83")) Then ' "Zellen einf|fffd|rben"
          If GetSetting( _
            appname:="Stromwerken", _
            Section:="ESQA", _
            Key:="ColorCells", Default:=1) = 1 Then
            G_ColorCells = True
            Application.CommandBars("Worksheet Menu Bar").Controls("ESQA").Controls(FMT0("MSTART_83")).state = msoButtonDown
          Else
            G_ColorCells = False
            Application.CommandBars("Worksheet Menu Bar").Controls("ESQA").Controls(FMT0("MSTART_83")).state = msoButtonUp
          End If
        Else
          G_ColorCells = True
        End If
        
        
        Set scbb = cbb.Controls.Add
        scbb.BeginGroup = False
        scbb.Style = msoButtonCaption
        'scbb.Caption = "Optionen"
        scbb.Caption = FMT0("MSTART_85")
        scbb.OnAction = "ESQAOptionen"
        'scbb.DescriptionText = "Zeigt Informationen zum Programm an."
        scbb.DescriptionText = FMT0("MSTART_86")
        
        
        Set scbb = cbb.Controls.Add
        scbb.BeginGroup = False
        scbb.Style = msoButtonCaption
        'scbb.Caption = "Info..."
        scbb.Caption = FMT0("MSTART_48")
        scbb.OnAction = "ESQAInfo"
        'scbb.DescriptionText = "Zeigt Informationen zum Programm an."
        scbb.DescriptionText = FMT0("MSTART_49")
          
        Set scbb = cbb.Controls.Add
        scbb.BeginGroup = False
        scbb.Style = msoButtonCaption
        'scbb.Caption = "Dokumentation"
        scbb.Caption = FMT0("MSTART_50")
        scbb.OnAction = "ESQAShowDoku"
        'scbb.DescriptionText = "Zeigt die Dokumentation des Programms an."
        scbb.DescriptionText = FMT0("MSTART_51")
#End If
  
  G_MarkCellsAmount = GetSetting(appname:="Stromwerken", Section:="ESQA", Key:="MarkCellsAmount", Default:=500)
  
  
  
  LogPrint "Start finished"
End Function

Sub Auto_Close()
    On Error Resume Next
    If G_ModulmenueDeaktivieren Then
      Application.CommandBars("Worksheet Menu Bar").Controls("ESQA").Delete
    End If
End Sub

Sub ESQAErgebnisseInEigenerDatei()
    CheckStartupStuff
    
    'If Application.CommandBars("Worksheet Menu Bar").Controls("ESQA").Controls("Ergebnisse in eigener Datei").state = msoButtonDown Then
    If Application.CommandBars("Worksheet Menu Bar").Controls("ESQA").Controls(FMT0("MSTART_46")).state = msoButtonDown Then
      'Application.CommandBars("Worksheet Menu Bar").Controls("ESQA").Controls("Ergebnisse in eigener Datei").state = msoButtonUp
      Application.CommandBars("Worksheet Menu Bar").Controls("ESQA").Controls(FMT0("MSTART_46")).state = msoButtonUp
      SaveSetting _
      appname:="Stromwerken", _
      Section:="ESQA", _
      Key:="ErgebnisseInEigenerDatei", Setting:=0
      G_ErgebnisseInEigenerDatei = False
    Else
      'Application.CommandBars("Worksheet Menu Bar").Controls("ESQA").Controls("Ergebnisse in eigener Datei").state = msoButtonDown
      Application.CommandBars("Worksheet Menu Bar").Controls("ESQA").Controls(FMT0("MSTART_46")).state = msoButtonDown
      SaveSetting _
      appname:="Stromwerken", _
      Section:="ESQA", _
      Key:="ErgebnisseInEigenerDatei", Setting:=1
      G_ErgebnisseInEigenerDatei = True
    End If

End Sub

Sub ESQAKloneEinzeln()
    CheckStartupStuff
    
    'If Application.CommandBars("Worksheet Menu Bar").Controls("ESQA").Controls("Klone einzeln anzeigen").state = msoButtonDown Then
    If Application.CommandBars("Worksheet Menu Bar").Controls("ESQA").Controls(FMT0("MSTART_87")).state = msoButtonDown Then
      'Application.CommandBars("Worksheet Menu Bar").Controls("ESQA").Controls("Klone einzeln anzeigen").state = msoButtonUp
      Application.CommandBars("Worksheet Menu Bar").Controls("ESQA").Controls(FMT0("MSTART_87")).state = msoButtonUp
      SaveSetting _
      appname:="Stromwerken", _
      Section:="ESQA", _
      Key:="KloneEinzeln", Setting:=0
      G_KloneEinzeln = False
    Else
      'Application.CommandBars("Worksheet Menu Bar").Controls("ESQA").Controls("Klone einzeln anzeigen").state = msoButtonDown
      Application.CommandBars("Worksheet Menu Bar").Controls("ESQA").Controls(FMT0("MSTART_87")).state = msoButtonDown
      SaveSetting _
      appname:="Stromwerken", _
      Section:="ESQA", _
      Key:="KloneEinzeln", Setting:=1
      G_KloneEinzeln = True
    End If
End Sub

Sub ESQAKommentareErzeugen()
    CheckStartupStuff
    
    'If Application.CommandBars("Worksheet Menu Bar").Controls("ESQA").Controls("Kommentare erzeugen").state = msoButtonDown Then
    If Application.CommandBars("Worksheet Menu Bar").Controls("ESQA").Controls(FMT0("MSTART_44")).state = msoButtonDown Then
      'Application.CommandBars("Worksheet Menu Bar").Controls("ESQA").Controls("Kommentare erzeugen").state = msoButtonUp
      Application.CommandBars("Worksheet Menu Bar").Controls("ESQA").Controls(FMT0("MSTART_44")).state = msoButtonUp
      SaveSetting _
      appname:="Stromwerken", _
      Section:="ESQA", _
      Key:="Comment", Setting:=0
      G_KommentareErzeugen = False
    Else
      'Application.CommandBars("Worksheet Menu Bar").Controls("ESQA").Controls("Kommentare erzeugen").state = msoButtonDown
      Application.CommandBars("Worksheet Menu Bar").Controls("ESQA").Controls(FMT0("MSTART_44")).state = msoButtonDown
      SaveSetting _
      appname:="Stromwerken", _
      Section:="ESQA", _
      Key:="Comment", Setting:=1
      G_KommentareErzeugen = True
    End If

End Sub

Sub ESQAZellenEinfaerben()
    CheckStartupStuff
    
    'If Application.CommandBars("Worksheet Menu Bar").Controls("ESQA").Controls("Zellen einf|fffd|rben (zeitintensiv!)").state = msoButtonDown Then
    If Application.CommandBars("Worksheet Menu Bar").Controls("ESQA").Controls(FMT0("MSTART_83")).state = msoButtonDown Then
      'Application.CommandBars("Worksheet Menu Bar").Controls("ESQA").Controls("Zellen einf|fffd|rben (zeitintensiv!)").state = msoButtonUp
      Application.CommandBars("Worksheet Menu Bar").Controls("ESQA").Controls(FMT0("MSTART_83")).state = msoButtonUp
      SaveSetting _
      appname:="Stromwerken", _
      Section:="ESQA", _
      Key:="ColorCells", Setting:=0
      G_ColorCells = False
    Else
      'Application.CommandBars("Worksheet Menu Bar").Controls("ESQA").Controls("Zellen einf|fffd|rben (zeitintensiv!)").state = msoButtonDown
      Application.CommandBars("Worksheet Menu Bar").Controls("ESQA").Controls(FMT0("MSTART_83")).state = msoButtonDown
      SaveSetting _
      appname:="Stromwerken", _
      Section:="ESQA", _
      Key:="ColorCells", Setting:=1
      G_ColorCells = True
    End If

End Sub


'Sub ESQARemoveMenu()
'    On Error Resume Next
'    'If MsgBox("Sind Sie sicher, dass Sie die Excel-Sheet-Analyse aus dem Men|fffd| entfernen m|fffd|chten?", vbYesNo, "ESQA " & MyVersion) = vbYes Then
'    If MsgBox(FMT0("MSTART_52"), vbYesNo, "ESQA " & MyVersion) = vbYes Then
'        Application.CommandBars("Worksheet Menu Bar").Controls("ESQA").Delete
'        ThisWorkbook.Close
'    End If
'End Sub


Function DoPreparations() As Boolean

  DoPreparations = False
  
  If ActiveWorkbook Is Nothing Then
    'MsgBox "Bitte |fffd|ffnen Sie erst eine Excel-Datei", vbInformation, "ESQA " & MyVersion
    MsgBox FMT0("MSTART_53"), vbInformation, "ESQA " & MyVersion
    Exit Function
  End If
  
  G_StartSheetCell = ActiveCell.Address
  G_StartSheetName = ActiveSheet.name
  
  Dim actsheetname As String
  
  If GetFileExtension(ActiveWorkbook.FullName) <> "ESQA" Then
    actsheetname = ActiveSheet.name
  End If
  
  G_FormatErrorCount = 0
  G_AnalyzeErrors = 0
  Abbruch = False
  G_ErrorCount = 0
  G_ErrorText = ""
  
  If Not OpenCopy(ActiveWorkbook) Then
    UpdateStatus "", -1
    StatusForm.Hide
    Exit Function
  End If

  GetData
  
  If actsheetname <> "" Then
    Dim ws As Worksheet
    For Each ws In ActiveWorkbook.Worksheets
      If ws.name = actsheetname Then
        ws.Activate
        Exit For
      End If
    Next ws
    
  End If
  
  G_StartSheetWB = ActiveWorkbook.name
  
  DoPreparations = True

End Function

Sub SetStartSheetAndCell()
  On Error Resume Next
  Workbooks(G_StartSheetWB).Activate
  Workbooks(G_StartSheetWB).Sheets(G_StartSheetName).Activate
  Workbooks(G_StartSheetWB).Sheets(G_StartSheetName).Range(G_StartSheetCell).Activate
  
End Sub


Sub ShowStatusForm()
  StatusForm.LabelProgress.Width = 0
  StatusForm.FrameProgress.Caption = Format(0, "0%")
  StatusForm.Show vbModeless
End Sub
  
Function ActivateWorksheet(ByRef ws As Worksheet) As Boolean
  On Error GoTo nogo
  ws.Activate
  ActivateWorksheet = True
  Exit Function
nogo:
  ActivateWorksheet = False
End Function
  
  


Sub ESQAFindConstants()
  CheckStartupStuff
  DoFind "ESQAFindConstants"
End Sub

Sub ESQAFindUnusedNumbers()
  CheckStartupStuff
  DoFind "ESQAFindUnusedNumbers"
End Sub

Sub ESQAFindTextNumbers()
  CheckStartupStuff
  DoFind "ESQAFindTextNumbers"
End Sub

Sub ESQAFindFormulaCellsWithoutProtection()
  CheckStartupStuff
  DoFind "ESQAFindFormulaCellsWithoutProtection"
End Sub

Sub ESQAFindErrors()
  CheckStartupStuff
  DoFind "ESQAFindErrors"
End Sub

Sub ESQAFindForgottenCells()
  CheckStartupStuff
  DoFind "ESQAFindForgottenCells"
End Sub

Sub ESQAFindInvisibleCells()
  CheckStartupStuff
  DoFind "ESQAFindInvisibleCells"
End Sub

Sub ESQAFindExternals()
  CheckStartupStuff
  DoFind "ESQAFindExternals"
End Sub

Sub ESQAFindAll()
  CheckStartupStuff
'  MsgBox "Achtung: Bei dieser Funktion kann es vorkommen, dass eine Zelle mehrere Kriterien erf|fffd|llt und somit die Zelle mehrmals eingef|fffd|rbt wird. Bitte achten Sie auf die entsprechenden Kommentare in den jeweiligen Zellen.", vbInformation, "ESQA " & MyVersion
  Dim s As String
  s = ""

  If G_All_ESQAFindConstants Then
      s = s & IIf(G_ESQAFindConstants, "ESQAFindConstants,", "")
  End If
  If G_All_ESQAFindTextNumbers Then
      s = s & IIf(G_ESQAFindTextNumbers, "ESQAFindTextNumbers,", "")
  End If
  If G_All_ESQAFindUnusedNumbers Then
      s = s & IIf(G_ESQAFindUnusedNumbers, "ESQAFindUnusedNumbers,", "")
  End If
  If G_All_ESQAFindFormulaCellsWithoutProtection Then
      s = s & IIf(G_ESQAFindFormulaCellsWithoutProtection, "ESQAFindFormulaCellsWithoutProtection,", "")
  End If
  If G_All_ESQAFindErrors Then
      s = s & IIf(G_ESQAFindErrors, "ESQAFindErrors,", "")
  End If
  If G_All_ESQAFindForgottenCells Then
      s = s & IIf(G_ESQAFindForgottenCells, "ESQAFindForgottenCells,", "")
  End If
  If G_All_ESQAFindInvisibleCells Then
      s = s & IIf(G_ESQAFindInvisibleCells, "ESQAFindInvisibleCells,", "")
  End If
  If G_All_ESQAFindExternals Then
      s = s & IIf(G_ESQAFindExternals, "ESQAFindExternals,", "")
  End If
  
  DoFind s
End Sub





Function GetCellRange(oxlwsheet, t As Long, Optional t2)
  Set GetCellRange = Nothing
  Application.DisplayAlerts = False
  On Error Resume Next
  If Not IsMissing(t2) Then
    Set GetCellRange = oxlwsheet.Cells.SpecialCells(t, t2)
  Else
    Set GetCellRange = oxlwsheet.Cells.SpecialCells(t)
  End If
  Application.DisplayAlerts = True
End Function

Function ShowBar() As Boolean
  On Error GoTo barMissing
  Application.CommandBars("ESQAZellenFinden").Visible = True
  ShowBar = True
  Exit Function

barMissing:
  ShowBar = False
End Function
Sub ESQAShowTodo()
  CheckStartupStuff
  
  If ActiveWorkbook Is Nothing Then
    'MsgBox "Bitte |fffd|ffnen Sie erst eine Excel-Datei!", vbInformation, "ESQA " & MyVersion
    MsgBox FMT0("RANGERET_1"), vbInformation, "ESQA " & MyVersion
    Exit Sub
  End If
  
'  If Not G_cTodo.TodoWindowOpen Then
'    MsgBox "Das Todo-Fenster ist bereits ge|fffd|ffnet. Schlie|fffd|en Sie das Fenster und rufen es f|fffd|r die gew|fffd|nschte Datei neu auf oder klicken Sie im Todo-Fenster auf 'Todoliste laden'", vbInformation, "ESQA " & MyVersion
'    Exit Sub
'  End If
  Dim tFName As String
  tFName = ActiveWorkbook.FullName
  If UCase(Right(tFName, 13)) = ".ANALYSE.ESQA" Then
    tFName = Left(tFName, Len(tFName) - 13)
  End If
  
  Application.Cursor = xlWait
'  If Not G_cTodo.LoadTodoList(tFName & ".ESQATD", ThisWorkbook.path & "\TodoHlp\Todo%1%.mht", tFName, "Todos f|fffd|r " & tFName, ThisWorkbook.path & "\Excel-Sheet-QA-Todo.cfg") Then
'    Application.Cursor = xlDefault
'    MsgBox "F|fffd|r die aktuelle Datei '" & tFName & "' existiert keine Todo-Datei.", vbCritical, "ESQA " & MyVersion
'  Else
    Application.Cursor = xlDefault
'    G_cTodo.ShowTodoWindow
'  End If
End Sub


Sub ESQAShowBar()
    CheckStartupStuff
    On Error GoTo ignore
    
    If ShowBar Then Exit Sub
    
    Dim myBar As CommandBar
    Set myBar = Application.CommandBars.Add(name:="ESQAZellenFinden", Position:=msoBarFloating, Temporary:=True)
    ' Und die Buttons hinzuf|fffd|gen
    Dim myControl
    Set myControl = myBar.Controls.Add(Type:=msoControlButton)
    ' Speicherbutton mit Grafik
    With myControl
        .FaceId = 141
        '.Caption = "Erste Zelle finden"
        .Caption = FMT0("MSTART_79")
        .OnAction = "ESQAFinden"  ' Funktion, die Aufgerufen werden soll, siehe Modul1
        .Style = msoButtonIconAndCaption
    End With
    
    Set myControl = myBar.Controls.Add(Type:=msoControlButton)
    ' Speicherbutton mit Grafik
    With myControl
        .FaceId = 570
        '.Caption = "Weitere finden"
        .Caption = FMT0("MSTART_80")
        .OnAction = "ESQAWFinden"  ' Funktion, die Aufgerufen werden soll, siehe Modul1
        .Style = msoButtonIconAndCaption
    End With
    
'    Set myControl = myBar.Controls.Add(Type:=msoControlButton)
    ' Speicherbutton mit Grafik
'    With myControl
'        .FaceId = 570
'        .Caption = "Text in Formeln"
'        .OnAction = "ESQATextInFormelnSuchen"  ' Funktion, die Aufgerufen werden soll, siehe Modul1
'        .Style = msoButtonIconAndCaption
'    End With
    
    
    ' Mich einschalten und den Schutz an
    With myBar
        .Visible = True
'        .Protection = 31 ' Mich kann man auch nicht zumachen :)
    End With
ignore:
End Sub

Sub ESQAAllesEinblenden()
  CheckStartupStuff
  
  'StatusForm.CurrentStatus = "Bitte warten..."
  StatusForm.CurrentStatus = FMT0("BW_1")
  
  Application.OnTime Now + TimeValue("00:00:01"), "ESQAAllesEinblendenFunc"
  PleaseWait.Show
End Sub

Sub ShowBitteWartenTime()
  PleaseWait.ShowTime = Time
  DoEvents
  If PleaseWait.Visible Then Application.OnTime Now + TimeValue("00:00:01"), "ShowBitteWartenTime"
End Sub

Sub ESQAAllesEinblendenFunc()
On Error Resume Next
  CheckStartupStuff
  
  If ActiveWorkbook Is Nothing Then
    'MsgBox "Bitte |fffd|ffnen Sie erst eine Excel-Datei", vbInformation, "ESQA " & MyVersion
    MsgBox FMT0("RANGERET_1"), vbInformation, "ESQA " & MyVersion
    Exit Sub
  End If
  
'  Application.OnTime Now + TimeValue("00:00:01"), "ShowBitteWartenTime"
  DoEvents
'  RemovePasswordFromSheet actsheet
  ActiveSheet.Cells.EntireRow.Hidden = False
  ActiveSheet.Cells.Rows.AutoFit
  ActiveSheet.Cells.EntireColumn.Hidden = False
  ActiveSheet.Cells.Columns.AutoFit
  PleaseWait.Hide
End Sub

Sub ESQAOptionen()
  CheckStartupStuff
  
  OptionsDlg.MarkCellsAmount = G_MarkCellsAmount
  OptionsDlg.Show
  G_MarkCellsAmount = OptionsDlg.MarkCellsAmount
  
  SaveSetting appname:="Stromwerken", Section:="ESQA", Key:="MarkCellsAmount", Setting:=G_MarkCellsAmount
  
End Sub

Sub ESQAInfo()
  CheckStartupStuff
  If Len(trs) Then AboutDlg.Label1 = trs
  AboutDlg.CVersion = MyVersion
  AboutDlg.Cop = "|fffd| 2001 - " & year(Now)
  AboutDlg.Show
End Sub

Sub ESQATextInFormelnSuchen()
  CheckStartupStuff
  
  'theSearchtext = InputBox("Bitte geben Sie den Suchtext ein", , theSearchtext)
  theSearchtext = InputBox(FMT0("MSTART_81"), , theSearchtext)
  If Len(theSearchtext) > 0 Then ESQATxtFinden
  
End Sub

' Sub ESQAShowDocs()
'  On Error GoTo hinweis
'  ThisWorkbook.Sheets("Docs").OLEObjects(1).Verb ':=xlPrimary
'  Exit Sub
'hinweis:
'  'MsgBox "Es ist ein Fehler aufgetreten. Bitte sorgen Sie daf|fffd|r, dass der Acrobat-Reader installiert ist.", vbCritical, "ESQA " & MyVersion
'  MsgBox FMT0("MSTART_82"), vbCritical, "ESQA " & MyVersion
'End Sub


Sub ESQAColourCurrentTable()
  CheckStartupStuff
  
  Dim scbb As CommandBarButton
  'Set scbb = CommandBars("Worksheet Menu Bar").Controls("ESQA").Controls("Nur aktuelle Tabelle einf|fffd|rben")
  Set scbb = CommandBars("Worksheet Menu Bar").Controls("ESQA").Controls(FMT0("MSTART_42"))
  If Not scbb Is Nothing Then
    If scbb.state = msoButtonUp Then
      scbb.state = msoButtonDown
    Else
      scbb.state = msoButtonUp
    End If
  End If
End Sub

Function ColourCurrentTable() As Boolean
  Dim scbb As CommandBarButton
  'Set scbb = CommandBars("Worksheet Menu Bar").Controls("ESQA").Controls("Nur aktuelle Tabelle einf|fffd|rben")
  Set scbb = CommandBars("Worksheet Menu Bar").Controls("ESQA").Controls(FMT0("MSTART_42"))
  If Not scbb Is Nothing Then
    If scbb.state = msoButtonUp Then
      ColourCurrentTable = False
    Else
      ColourCurrentTable = True
    End If
  End If
End Function


Sub ESQAShowDoku()
  Dim path As String
  path = gTranslation.GetLocalizedFile(ThisWorkbook.path & "\Excel-Sheet-QA.pdf")
  'OpenFileWithApp ThisWorkbook.path & "\Excel-Sheet-QA.pdf"
  OpenFileWithApp path
End Sub



' InQuest injected base64 decoded content
' z{Uz
' x"{e1
' m"qh

INQUEST-PP=macro
