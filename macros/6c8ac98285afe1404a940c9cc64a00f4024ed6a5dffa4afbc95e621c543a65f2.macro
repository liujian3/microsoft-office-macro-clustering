Attribute VB_Name = "About"
Option Explicit
'Modu|fffd| dodany wy|fffd||fffd|cznie do wy|fffd|wietlania makra InformacjeOAutorze
'--------------
'Modyfikcje:
'2018=09-16 Adaptacja modu|fffd|u z JPK
'--------------
Public Const ApplicationName = "NazwaSkoroszytu" 'obszar nazwany na arkuszu Techniczne, wykorzystywany w formularzu Licencja

Public Function ExpireMsg()
    If DemoVersion Then
        If IFormVersion Then
            ExpireMsg = GetText("IFormExpireDemoMsg")
        Else
            ExpireMsg = GetText("STDExpireDemoMsg")
        End If
    Else
        If IFormVersion Then
            ExpireMsg = GetText("IFormExpireMsg")
        Else
            ExpireMsg = GetText("STDExpireMsg")
        End If
    End If
End Function

Public Sub TekstLicencji()
   Dim ApName
   On Error Resume Next
   ApName = Range(ApplicationName)
   If Err.Number <> 0 Then
        MsgBox GetText("DemoLicenseMsg")
   Else
        Licencja.Show
   End If
   On Error GoTo 0
End Sub
Attribute VB_Name = "Arkusz1"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Private Sub Worksheet_Change(ByVal Target As Range)
    PreventFieldProtetction Target
End Sub
Attribute VB_Name = "Arkusz10"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True

Private Sub Worksheet_Change(ByVal Target As Range)
    PreventFieldProtetction Target
    UpdateRowVisibility Target 'Ukrywa odp. wiersze, gdy zmieni|fffd|o si|fffd| pole z numerem pozycji listy wersji sekcji (Lista "WyborWariantu")
End Sub

Attribute VB_Name = "Arkusz11"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True

Private Sub Worksheet_Change(ByVal Target As Range)
    PreventFieldProtetction Target
    UpdateRowVisibility Target 'Ukrywa odp. wiersze, gdy zmieni|fffd|o si|fffd| pole z numerem pozycji listy wersji sekcji (Lista "WyborWariantu")
End Sub

Attribute VB_Name = "Arkusz12"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True

Private Sub Worksheet_Change(ByVal Target As Range)
    PreventFieldProtetction Target
    UpdateRowVisibility Target 'Ukrywa odp. wiersze, gdy zmieni|fffd|o si|fffd| pole z numerem pozycji listy wersji sekcji
End Sub
Attribute VB_Name = "Arkusz2"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Arkusz3"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Private Sub Worksheet_Change(ByVal Target As Range)
    PreventFieldProtetction Target
    UpdateRowVisibility Target 'Ukrywa odp. wiersze, gdy zmieni|fffd|o si|fffd| pole z numerem pozycji listy wersji sekcji (Lista "WyborWariantu")
    UpdateP6Controls Target
End Sub
Attribute VB_Name = "Arkusz4"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Private Sub Worksheet_Change(ByVal Target As Range)
    OnChangeAmountBase Target 'Gdy zmieni si|fffd| baza kwot (w tys/ w z|fffd|)
End Sub


Attribute VB_Name = "Arkusz5"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Arkusz7"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Arkusz8"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Private Sub Worksheet_Change(ByVal Target As Range)
    PreventFieldProtetction Target
    UpdateRowVisibility Target 'Ukrywa/odkrywa podpozycje rozliczenia, gdy wczytali|fffd|my nowe dane
End Sub

Attribute VB_Name = "Arkusz9"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Private Sub Worksheet_Change(ByVal Target As Range)
    PreventFieldProtetction Target
    UpdateRowVisibility Target 'Ukrywa odp. wiersze, gdy zmieni|fffd|o si|fffd| pole z numerem pozycji listy wersji sekcji (Lista "WyborWariantu")
End Sub
Attribute VB_Name = "Attachement"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
'Obs|fffd|uga za|fffd||fffd|cznik|fffd|w do Excela
Private Const DefaultIcon = "shell32.dll,1" 'Domy|fffd|lny plik z ikonami i indeks wybranej ikony dla tych za|fffd||fffd|cznik|fffd|w, kt|fffd|re nie maj|fffd| w|fffd|asnej.
Private Const ValidExtensions = "pdf,doc,docx,xls,xlsx" 'Rozszerzenia plik|fffd|w, kt|fffd|re mog|fffd| by|fffd| poprawnie obs|fffd|u|fffd|one jako za|fffd||fffd|czniki (brak dobrej metody na zapisanie za|fffd||fffd|cznika)
Private Const AButton = "AttButton"
Private Const AttBorderColor = &HCCCCCC 'kolor ramki za|fffd||fffd|cznika
Private Const ZBottom = 1 'ZOrder za|fffd||fffd|cznika: "na sam d|fffd|"
'Prywatne dane obiektu:
Private myButton As Rectangle 'Przycisk, zwi|fffd|zany z obs|fffd|ug|fffd| za|fffd||fffd|cznika (To Shape.DrawingObject)
Private myCell As Range       'kom|fffd|rka prawej strony przycisku/obiektu (zazwyczaj przechowuje nazw|fffd| pliku za|fffd||fffd|cznika)
Private myObject As OLEObject 'obiekt za|fffd||fffd|cznika (mo|fffd|e by|fffd| Nothing, gdy jeszcze nie zosta|fffd| utworzony)

'Dla porz|fffd|dku (por. warunki w Initialize)
Private Sub Class_Initialize()
    Set myButton = Nothing
    Set myCell = Nothing
    Set myObject = Nothing
End Sub
'Funkcja zwraca domy|fffd|ln|fffd| ikon|fffd|, zarejestrowan|fffd| dla plik|fffd|w o rozszerzeniu Ext
'Argumenty:
'   Ext:    rozszerzenie pliku (z kropk|fffd|: np. ".pdf")
'UWAGA: funkcja zwraca dwuelementow|fffd| tablic|fffd| (0..1): (0):"<scie|fffd|ka do pliku zasob|fffd|w> (1):<indeks ikony>".
'Jezeli nic nie znajdzie - zwraca "shell32.dll","1" (dzi|fffd|ki temu jakas ikona zawsze si|fffd| poka|fffd|e)
Private Function FindDefaultIconFor(ByVal Ext As String) As Variant
    Dim reg As New Registry
    Dim icon As Variant
    Ext = LCase(Ext)
    icon = reg.Read(reg.HKCR, Ext & "\DefaultIcon", DefaultValue:=True) 'Najpierw szukamy w kluczu rozszerzenia....
    If IsEmpty(icon) Then 'Jak nie ma takiego zapisu:
        Dim ProgId As Variant
        ProgId = reg.Read(reg.HKCR, "." & Ext, DefaultValue:=True) 'Odczytaj ProgId dla tego rozszerzenia...
        icon = reg.Read(reg.HKCR, ProgId & "\DefaultIcon", DefaultValue:=True) 'I poszukaj w kluczu dla tego ProgId
    End If
    
    If IsEmpty(icon) Then
        icon = Split(DefaultIcon, ",")
    Else
        icon = Split(icon, ",")
    End If
    If UBound(icon) = 0 And LBound(icon) = 0 Then 'Dodaj|fffd| ten warunek na wszelki wypadek...
        FindDefaultIconFor = Array(icon(0), "0")
    Else
        FindDefaultIconFor = icon
    End If
End Function

'Zwraca rozszerzenie nazwy pliku, przechowywanego w myCell (mo|fffd|e zwr|fffd|ci|fffd| "", gdy kom|fffd|rka nie jest przypisana lub nazwa pliku nie istnieje)
Private Function Ext() As String
  Ext = ""
  If myCell Is Nothing Then Exit Function
  Ext = ExtensionOf(LCase(myCell.value))
End Function
'Zwraca obiekt (za|fffd||fffd|cznik) zwi|fffd|zany ze wskazan|fffd| kom|fffd|rk|fffd|, lub Nothing gdy nie istneje
Private Function FindObjectFor(ByVal cell As Range) As OLEObject
    Dim objs As OLEObjects, i As Integer
    Set FindObjectFor = Nothing
    Set objs = cell.Worksheet.OLEObjects
    For i = 1 To objs.count 'Wygl|fffd|da na to, |fffd|e For Each na kolekcji OLEObjects "g|fffd|upieje" gdy wszystkie obiekty maj|fffd| takie same nazwy i zwraca ci|fffd|gle pierwszy element
        If objs(i).TopLeftCell.Address = cell.Address Then
            Set FindObjectFor = objs(i)
            Exit For 'Znale|fffd|li|fffd|my
        End If
    Next i
End Function

'Pomocnicza funkcja, dodana dla uproszczenia kodu (wsp|fffd|pracuje z FindShapeFor()):
'Argumenty:
'   Shp: obiekt typu Shape, jak otrzymany z FindShapeFor
'Zwraca DrawingObject z podanego Shape (w tym przypadku to Rectangle)
Private Function DrawingObjectOf(ByVal Shp As shape) As Rectangle
    If Shp Is Nothing Then
        Set DrawingObjectOf = Nothing
    Else
        Set DrawingObjectOf = Shp.DrawingObject
    End If
End Function
'Zwraca True, gdy podany plik mo|fffd|e by|fffd| zapisany (do pliku lub w|fffd|z|fffd|a XML)
'Argumenty:
'   FileName: sprawdzany plik (oceniane jest jego rozszerzenie)
'UWAGA:Ta funkcja mo|fffd|e by|fffd| wywo|fffd|ana przed inicjalizacj|fffd| obiektu (aby mo|fffd|na by|fffd|o okre|fffd|li|fffd|, jak|fffd| form|fffd| incjalizacji wybra|fffd|)
Function CanBeSaved(ByVal FileName As String) As Boolean
    CanBeSaved = Contains(ValidExtensions, ExtensionOf(LCase(FileName))) 'File can be saved from Excel, if it belongs to the one of the handled file types
End Function

'Inicjalizacja obiektu
'Argumenty (alternatywnie):
'   Button: przycisk, sterujacy za|fffd||fffd|cznikiem (jego obszar TopLeft si|fffd| kom|fffd|rka na nazw|fffd| pliku)
'   Cell:   kom|fffd|rka, w kt|fffd|r|fffd| ma by|fffd| wstawiony ten za|fffd||fffd|cznik (mo|fffd|e zawiera|fffd| przycisk Button)
'   Obj:    osadzony obiekt (u|fffd|ywany przy poleceniu otwierania - Button i Cell mog|fffd| nie istnie|fffd|)
'Gdy podajemy bezpo|fffd|rednio kom|fffd|rk|fffd| lub obiekt, myButton mo|fffd|e pozosta|fffd| = Nothing (dla za|fffd||fffd|cznik|fffd|w w arkuszu "Ostrze|fffd|enia")
Sub Initialize(Optional ByVal Button As Rectangle = Nothing, Optional ByVal cell As Range = Nothing, Optional ByVal Obj As OLEObject = Nothing)
    If Not (Button Is Nothing) Then
        Set myButton = Button
        Set myCell = Button.TopLeftCell
        Set myObject = FindObjectFor(myCell)
    End If
    'Je|fffd|eli nie zainicjowano wykorzystuj|fffd|c Button:
    If myCell Is Nothing And Not (cell Is Nothing) Then
        Set myButton = DrawingObjectOf(FindShapeFor(cell, "Rectangle"))
        Set myCell = cell
        Set myObject = FindObjectFor(myCell)
    End If
    'Je|fffd|eli nie zainicjowano poprzez podanie Button lub Cell:
    If myObject Is Nothing And Not (Obj Is Nothing) Then 'Obiekt bez kom|fffd|rki z nazw|fffd| pliku i przycisku [x]
        Set myObject = Obj
        Set myButton = DrawingObjectOf(FindShapeFor(Obj.TopLeftCell, "Rectangle"))
        Set myCell = Obj.TopLeftCell
    End If
End Sub
'Wstawia do skoroszytu nowy za|fffd||fffd|cznik, uaktualnia odpowiednio UI
'Argumenty:
'   Path:   pe|fffd|na |fffd|cie|fffd|ka do pliku do wstawienia
'Ta funkcja przy okazji inicjalizuje pole myObject.
Sub Insert(ByVal Path As String)
    Dim icon, shape As shape, csheet As Worksheet
     If Not (myObject Is Nothing) Then Me.Remove 'Dla porz|fffd|dku (to nigdy nie powinno si|fffd| zdarzy|fffd|)
     Set csheet = ActiveSheet
     DisableScreenUpdating
On Error GoTo ErrHandler
     myCell.Worksheet.Activate
     myCell.Select 'Poprzednia selekcja zosta|fffd|a zapami|fffd|tana w UnprotectSheet i b|fffd|dzie odtworzona w ProtectSheet()
     icon = FindDefaultIconFor(ExtensionOf(LCase(Path))) '<icon> to dwuelementowa tablica: 0: plik ikon, 1: indeks ikony
     Set myObject = myCell.Worksheet.OLEObjects.Add(FileName:=Path _
                                                     , Link:=False _
                                                     , DisplayAsIcon:=True _
                                                     , IconLabel:=Replace(GetFileName(Path), "_", " ") _
                                                     , IconFileName:=icon(0), IconIndex:=icon(1))
     'Trzeba ten obiekt jeszcze "u|fffd|adni|fffd|":
     With myObject
         .Border.Color = AttBorderColor
         .SendToBack  'Aby by|fffd|o wida|fffd| ew. przycisk [X]
         .Select 'Makro mo|fffd|na skutecznie przypisa|fffd| tylko do ZAZNACZONEGO obiektu!
         Selection.OnAction = "AttachementClick"
    End With
     
    myCell.value = GetFileName(Path)
                 
    If Not (myButton Is Nothing) Then
         myButton.Caption = AttAssignedCaption
    End If
    
    If myObject.ProgId Like "Excel.Sheet.*" Then 'Plik Excela po wstawieniu zostaje, jako otwarty skoroszyt!
        Dim WbName As String
        WbName = FileNameOf(Path) 'Trzeba go usun|fffd||fffd|:
        If IsWorkbookLoaded(WbName) Then 'Tak si|fffd| mo|fffd|e zdarzy|fffd|, gdy przed chwil|fffd| za|fffd||fffd|czyli|fffd|my ten plik
            Workbooks(WbName).Close 'Wtedy go zamknijmy!
        End If
    End If
    
    Err.Clear 'Gdy wykonanie dosz|fffd|o do tej linii - lepiej usun|fffd||fffd| ewentualne "echa": b|fffd||fffd|dy po przeliczaniu arkusza
ErrHandler:
    If Err.Number <> 0 Then Err.Raise Err.Number, "Attachement", GetText("InsertAttachementError", GetFileName(Path), Err.Description)
    csheet.Activate
    EnableScreenUpdating
End Sub
'Usuwa za|fffd||fffd|cznik ze skoroszytu
Sub Remove()
    myCell.formula = ""
    
    If Not (myObject Is Nothing) Then
        myObject.Delete
        Set myObject = Nothing
    End If

    If Not (myButton Is Nothing) Then
        myButton.Caption = AttEmptyCaption
    End If
End Sub
'Otwiera (w odpowiednim programie) plik za|fffd||fffd|cznika
Sub Show()
    If Not (myObject Is Nothing) Then
        Dim result
        
        result = myObject.Verb(Verb:=xlPrimary) 'Otwiera osadzony dokument (UWAGA: czasami wyskakiwa|fffd| mi b|fffd||fffd|d 1004,
        
        If result And Ext() = "pdf" Then
            Dim reg As New Registry
            If reg.Read(reg.HKCR, ".pdf", DefaultValue:=True) = "AcroExch.Document.DC" Then 'Z tym konkretnym programem jest drobny problem:
                'Okno Adobe Acrobat DC po otwarciu dokumentu "znika" pod spodem Excela. Poni|fffd|sze polecenie ma przynajmniej spr|fffd|bowa|fffd| je przywo|fffd|a|fffd|:
                On Error Resume Next 'Je|fffd|eli nie ma Acrobata - ta poni|fffd|sza linia wywo|fffd|a b|fffd||fffd|d, dlatego Resume Next
                AppActivate "Adobe Acrobat Reader DC"
                Err.Clear
            End If
        End If
    End If
End Sub
'Pomocnicza funkcja - aby nie wywo|fffd|a|fffd| b|fffd||fffd|du w czasie pr|fffd|by odczytania nie obs|fffd|ugiwanego ProgId
'W takim przypadku zwraca ""
Private Function ProgId() As String
    On Error Resume Next
    ProgId = myObject.ProgId
End Function
'Wstawia do skoroszytu nowy za|fffd||fffd|cznik, uaktualnia odpowiednio UI
'Argumenty:
'   FileName:   nazwa pliku zapisania
'Ta funkcja przy okazji inicjalizuje pole myObject.
Sub Save(ByVal FileName As String)
    With myObject
        Dim PID As String
        PID = ProgId 'Zwraca "" gdy na komputerze nie ma zainstalowanego obiektu obs|fffd|uguj|fffd|cego ten za|fffd||fffd|cznik
        If PID Like "Word.Document*" Or PID Like "Excel.Sheet.*" Then 'Tradycyjna metoda Ole jest do|fffd||fffd| "si|fffd|owa":
            If FileExists(FileName) Then Kill FileName 'Zr|fffd|b na pocz|fffd|tku porz|fffd|dek, aby nie wyskoczy|fffd|o pytanie o nadpisanie skoroszytu...

            If PID Like "Excel.Sheet.*" Then 'Otwieramy w naszej w|fffd|asnej apliakcji
                Dim WbName As String
                WbName = FileNameOf(FileName)
                If IsWorkbookLoaded(WbName) Then 'Tak si|fffd| mo|fffd|e zdarzy|fffd|, gdy przed chwil|fffd| za|fffd||fffd|czyli|fffd|my ten plik
                    Workbooks(WbName).Close 'Wtedy go zamknijmy!
                End If
                .Verb xlVerbPrimary      'otwierany tym poleceniem plik!
                .Object.SaveCopyAs FileName 'Zapisujemy... (SaveAs nie dzia|fffd|a!)
                .Object.Close               'i zamykamy ten skoroszyt.
            Else
                .Verb xlVerbPrimary      'otwierany tym poleceniem plik!
                .Object.SaveAs FileName  'Kt|fffd|ry po prostu zapisujemy
                .Object.Application.Quit 'i zamykamy wywo|fffd|any program.
            End If
        Else
            If PID Like "Acro*.Document*" _
                Or (PID = "FoxitReader.Document" And LCase(FileName) Like "*.pdf") _
                Or (PID = "Package" And LCase(FileName) Like "*.pdf") _
                Or (PID = "" And LCase(FileName) Like "*.pdf") _
            Then 'Czy w|fffd|a|fffd|ciwie musimy wymaga|fffd| tego ProgId? A mo|fffd|e rozszerzenie wystarczy?
                PDF.SaveToFile myObject, FileName
            Else 'to si|fffd| nigdy nie powinno zdarzy|fffd|:
                Err.Raise CriticalError, "Attachement", GetText("UnknownDataType", PID, myCell.Worksheet.Name & "!" & myCell.Address)
            End If
        End If
    End With
End Sub


Attribute VB_Name = "Embedded"
Option Explicit
'Pomocnicza procedura, pozwalaj|fffd|ca odczyta|fffd| "surowe" dane pliku osadzonego w arkuszu
'(to jest przydatne przy odczytwaniu osadzonych plik|fffd|w PDF i XSD - kt|fffd|re mo|fffd|na traktowa|fffd| jako tekstowe, i kt|fffd|re sta|fffd|e znaczniki pocz|fffd|tku i ko|fffd|ca)
#If VBA7 Then
    Private Declare PtrSafe Function OpenClipboard Lib "user32" (ByVal hwnd As LongPtr) As Long
    Private Declare PtrSafe Function CloseClipboard Lib "user32" () As Long
    Private Declare PtrSafe Function EmptyClipboard Lib "user32" () As Long
    Private Declare PtrSafe Function GetClipboardData Lib "user32" (ByVal wFormat As Long) As LongPtr
    Private Declare PtrSafe Function GlobalLock Lib "kernel32" (ByVal hMem As LongPtr) As LongPtr
    Private Declare PtrSafe Function GlobalSize Lib "kernel32" (ByVal hMem As LongPtr) As LongPtr
    Private Declare PtrSafe Function GlobalUnlock Lib "kernel32" (ByVal hMem As LongPtr) As Long
    Private Declare PtrSafe Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (Destination As Any, Source As Any, ByVal Length As LongPtr)
#Else
    Private Declare Function OpenClipboard Lib "user32" (ByVal hwnd As Long) As Long
    Private Declare Function CloseClipboard Lib "user32" () As Long
    Private Declare Function EmptyClipboard Lib "user32" () As Long
    Private Declare Function GetClipboardData Lib "user32" (ByVal wFormat As Long) As Long
    Private Declare Function GlobalLock Lib "kernel32" (ByVal hMem As Long) As Long
    Private Declare Function GlobalSize Lib "kernel32" (ByVal hMem As Long) As Long
    Private Declare Function GlobalUnlock Lib "kernel32" (ByVal hMem As Long) As Long
    Private Declare Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (Destination As Any, Source As Any, ByVal Length As Long)
#End If

Private Const CF_NATIVE = &HC004&

'Odczytuje "surowe" dane wskazanego obiektu OLE i umieszcza je we wskazanym buforze
'Argumenty:
'   Obj:    obiekt OLE do odczytania
'   Buffer: bufor na dane (ta procedura zmienia rozmiar tej tablicy bajt|fffd|w). Pocz|fffd|tkowy indeks to 0
'           Przekazywany ByRef by nie kopiowac dodatkowo danych przy opuszczeniu tej procedury
Sub GetRawData(ByVal Obj As OLEObject, ByRef Buffer() As Byte)
    #If VBA7 Then
        Dim hClipMem As LongPtr, lMemSize As LongPtr, lMemPtr As LongPtr
    #Else
        Dim hClipMem As Long, lMemSize As Long, lMemPtr As Long
    #End If

    Obj.Copy
    DoEvents
    If OpenClipboard(0) Then
        hClipMem = GetClipboardData(CF_NATIVE)
        If hClipMem Then lMemSize = GlobalSize(hClipMem)
        If lMemSize Then lMemPtr = GlobalLock(hClipMem)
        If lMemPtr Then
            ReDim Buffer(0 To CLng(lMemSize) - 1) As Byte
            CopyMemory Buffer(0), ByVal lMemPtr, lMemSize
            Call GlobalUnlock(hClipMem)
        End If
        Call EmptyClipboard
        Call CloseClipboard
    End If
End Sub

Attribute VB_Name = "Export"
Option Explicit
'--------------
'Modyfikcje:
'2018-09-15 Adaptacja z pliku JPK
'--------------

'Pomocnicza funkcja: zwraca True gdy w|fffd|ze|fffd| ma ELEMENTY potomne (a nie same "techniczne" w|fffd|z|fffd|y, jak pole tekstowe czy komentarz)
'Argumenty:
'   node: potencjalny "rodzic" element|fffd|w potomnych (IXMLDOMNode)
'Funkcja dodana wy|fffd||fffd|cznie dla wi|fffd|kszej czytelno|fffd|ci kodu
Private Function HasElements(ByVal node As Object) As Boolean
    HasElements = (node.SelectNodes("./*").Length > 0)
End Function
'Pomocnicza funkcja: usuwa z w|fffd|z|fffd|a i potomnych wszelkie puste w|fffd|z|fffd|y
'(Wykorzystywana do upraszczania wynikowego pliku podczas eksportu)
'Argumenty:
'   node: "root", kt|fffd|rego potomstwo "czy|fffd|cimy" z pustych w|fffd|z|fffd||fffd|w (IXMLDOMElement)
Private Sub RemoveEmptyNodes(ByVal node As Object)
    Dim Child As Object 'IXMLDOMNode
    Dim nodeIsEmpty As Boolean
    
    nodeIsEmpty = (Len(node.text) = 0)
    Dim toRemove As New Collection 'Pomocnicza kolekcja na usuwane elementy (aby nie zmienia|fffd| listy w trakcie gdy po niej iterujemy)
    For Each Child In node.ChildNodes
        If Child.NodeType = NODE_ELEMENT Then
           If nodeIsEmpty Then
              toRemove.Add Child
           Else
              RemoveEmptyNodes Child
              If Not HasElements(Child) And Len(Child.text) = 0 Then
                toRemove.Add Child
              End If
           End If
        Else
            If Child.NodeType = NODE_COMMENT Then 'Usuwamy wszystkie komentarze
                toRemove.Add Child
            End If
        End If
    Next Child
    'To trzeba wykona|fffd| po iteracji po wszystkich w|fffd|z|fffd|ach:
    For Each Child In toRemove
        node.RemoveChild Child
    Next Child
End Sub
'Procedura "podpisuje" eksportowany plik komentarzem z nazw|fffd| ZigZak
'Argumenty:
'   xml:        dokument XML,
Private Sub AddCopyrightComment(ByVal xml As Object)
    Dim cmt As Object 'IXMLDOMComment
    Dim wersja As String
    Dim serial As String
    Dim czas As String
    On Error GoTo ErrHandler
    wersja = Range("NumerEdycji").value
    czas = Format(Now, "yyyy-MM-dd hh:mm:ss")
    serial = Range("NumerSeryjny")
    Set cmt = xml.createComment(GetText("CopyrightStatement", czas, wersja, serial))
    xml.DocumentElement.appendChild cmt
ErrHandler:
    Err.Clear 'To nie jest istotna operacja - jak si|fffd| nie uda, nie r|fffd|b afery
End Sub
'Procedura eksportuje dane do pliku XML
'Zwraca True, gdy uda|fffd|o si|fffd| zapisa|fffd| do pliku
'Argument:
'   FileName: nazwa pliku (gdy program nie ma si|fffd| o niego pyta|fffd| w oknie dialogowym)
Private Function ExportToXML(Optional ByVal FileName As Variant = "") As Boolean
    Dim xml As Object 'DOMDocument60
    Dim def As New ReportDef
    Dim map As New Mapper
    Dim calc
    
    ExportToXML = False 'Jeste|fffd|my pesymistami
    If Not IsEmpty(ExpireDate) And Now > ExpireDate Then
        MsgBox ExpireMsg
        Exit Function
    End If
    
    If IsDate(Range("DataDo")) And DemoVersion Then
        Dim yr, yb
        yr = Year(Range("DataDo"))
        yb = Year(Now) - 1
        If yr >= yb Then
            MsgBox GetText(IIf(IFormVersion, "IForm", "") & "DemoYearRestriction", yr)
            Exit Function
        End If
    End If
    
    PreserveStatusBar
    Application.DisplayStatusBar = True
    Application.cursor = xlWait
    'Porz|fffd|dki z kolumnami specjalnymi list:
    calc = Application.Calculation
    
    Application.StatusBar = GetText("PreparingToExport")
    Application.Calculation = xlCalculationManual
        
    SetReconciliationStatus (PerformReconciliation() <> 0) 'Zapal ewentualne flagi "[!]" przy niezgodnych kwotach
    
    Application.CalculateFull 'Dla |fffd|wi|fffd|tego spokoju: przelicz ca|fffd|y arkusz...
    Application.Calculation = calc 'Lepiej to w|fffd||fffd|czyc jak najpr|fffd|dzej, aby w przypadku b|fffd||fffd|du nie pozostawi|fffd| po sobie "|fffd|mieci" w konfiguracji programu

    On Error GoTo ErrHandler 'W |fffd|rodku tej sekcji mo|fffd|e si|fffd| trafi|fffd| b|fffd|ad:---------
    def.Initialize 'Inicjalizacja (wariant raportu jak wybrany w skoroszycie, ustawienia sekcji  na razie domy|fffd|lne)
    def.ReadFromLayout 'Pobierz ze skoroszytu aktualne ustawienie sekcji
    'Za|fffd|adowanie dokumentu wzorocowego (bez schemy wczytuje si|fffd| szybciej!):
    Set xml = def.xml 'Ten pusty dokument ma ju|fffd| dodane przestrzenie nazw wyszukiwania z odp. prefiksami
    If xml Is Nothing Then Exit Function 'Na wszelki wypadek

    map.Initialize xml, ForExport:=True 'Inicjalizacja mapowania, z optymalizacj|fffd| dla eksportu:
    
    Application.StatusBar = GetText("BuildingResultFile")
    
    'Wype|fffd|nienie danymi:
    map.Export
    'Usuwamy puste w|fffd|z|fffd|y:
    RemoveEmptyNodes xml.DocumentElement
    AddCopyrightComment xml
    
ErrHandler:
    If Err.Number <> 0 Then 'czy podczas przetwarzania wyst|fffd|pi|fffd| b|fffd||fffd|d?
        If Err.Number = vbObjectError Then 'B|fffd||fffd|d ju|fffd| zasygnalizowany (por. MarkXMLValueError())
            Application.StatusBar = GetText("OperationFailed")
        Else
            MsgBox GetText("ExportFailed", Err.Description), vbCritical, GetText("UnexpectedError")
        End If
        
        'Odtwarzamy stan Excela i wychodzimy:
        Application.cursor = xlDefault
        RestoreStatusBar StatusBarDelay
        Exit Function
    End If
    
    On Error GoTo 0 '--------------------------------------------
    
    Application.cursor = xlDefault 'Walidacja trwa kr|fffd|tko, wi|fffd|c nie ma co si|fffd| tu

    'Walidacja:
    Application.StatusBar = GetText("ReportValidation")
    Dim Validated
    Validated = ValidateXML(xml, map, def)
    If Validated = True Then
        'Zapisanie:
        Application.StatusBar = GetText("SavingReportFile")
        If FileName = "" Then 'Je|fffd|li nie okre|fffd|lono nazwy pliku: prosimy U|fffd|ytkownika o wskazanie:
                Dim NameIsValid
                FileName = ActiveWorkbook.Path & "\" & Split(ActiveWorkbook.Name, ".")(0) & ".xml" 'Domyslnie: nazwa tego skoroszytu, ale z rozszerzeniem *.xml
                
                Do 'P|fffd|tla na ewentualn|fffd| poprawk|fffd| nazwy pliku, gdy nieodpowiednia z punktu widzenia MF.
                    FileName = Application.GetSaveAsFilename(InitialFileName:=FileName, _
                                                                FileFilter:=GetText("SFFileFilter"), _
                                                                Title:=GetText("ExportToXML"), Buttontext:=GetText("SaveReport"))
                    If VarType(FileName) = vbString Then
                        NameIsValid = IsValidFileName(FileName) 'Ewentualne ostrze|fffd|enie przed nieprawid|fffd|ow|fffd| nazw|fffd| z punktu widzenia MF
                        If IsNull(NameIsValid) Then FileName = False 'U|fffd|ytkownik zrezygnowa|fffd|
                    Else
                        NameIsValid = Null
                    End If
                Loop While NameIsValid = False
        End If
        
        If VarType(FileName) = vbString Then
            On Error Resume Next
            xml.Save FileName
            If Err.Number = 0 Then
                Dim msg As String
                msg = GetText("DataSaved", FileName)
                If ShowModalConfirmation() Then MsgBox msg, vbInformation, GetText("SavingReportFile")
                Application.StatusBar = msg
                ExportToXML = True
            Else
                MsgBox GetText("DataNotSaved", FileName, Err.Description), vbExclamation, GetText("ProblemOnSaving")
            End If
            On Error GoTo 0
        Else 'By|fffd| mo|fffd|e tylko sprawdzali|fffd|my zawarto|fffd||fffd| arkusza:
            Application.StatusBar = GetText("ReportIsValid")
        End If
    Else
        If Validated = False Then
             Application.StatusBar = GetText("ValidationFailed")
        Else 'Validated = Null
             Application.StatusBar = GetText("ReportNotVerified") 'Z przyczyn technicznych
        End If
    End If
    
    RestoreStatusBar StatusBarDelay
End Function

Public Sub Export_SF()
    ExportToXML
End Sub
'Wykonuje sam|fffd| walidacj|fffd|, bez zapisywania
Public Sub Validate_SF()
    ExportToXML False
End Sub










Attribute VB_Name = "Import"
Option Explicit
'XPATH na kodFormularza (u|fffd|ywam local-name, bo element KodSprawozdania jest zawsze nie w lokalnej sf:, ale w konkretnej ns struktur danego raportu!)
'Import pliku JPK do arkusza
'--------------
'Modyfikacje:
'2018-09-15: Plik zaadaptowany z JPK
'--------------

'Pomocnicza funkcja, pokazuj|fffd|ca informacje o wczytanym pliku
'Argumenty:
'   msg:   komunikat
Private Sub ShowInformation(ByVal msg As String)
    If ShowModalConfirmation() Then MsgBox msg, vbInformation, GetText("ImportTitle")
    Application.StatusBar = msg
    RestoreStatusBar StatusBarDelay
End Sub
'Pomocznicza funkcja, pomagaj|fffd|ca okre|fffd|li|fffd| czy wczytywanie ma by|fffd| dost|fffd|pne
Function ImportAllowed()
    Dim rng As Range, flag As Long
    Set rng = Range("SF_XED")
    flag = Mid(rng.value, 2, 1) 'Drugi znak JPK_XED
    ImportAllowed = (flag <> "0")
End Function
'Pomocnicza funkcja, wczytuj|fffd|ca pojedynczy plik sprawozdania:
'Argumenty:
'   FileName:   nazwa pliku, z kt|fffd|rego mamy wczytywac dane
'Zwraca True, gdy si|fffd| uda|fffd|o, False w przeciwnym razie
Private Function ImportFromXML(ByVal FileName As String) As Boolean
    Dim xml As Object 'DOMDocument60
    Dim ExcludedWorksheets As String
    ImportFromXML = False 'Zak|fffd|adamy psymistycznie, by u|fffd|atwi|fffd| obs|fffd|ug|fffd| b|fffd||fffd|du
    Application.StatusBar = GetText("ImportingReportFile", FileName)
    Set xml = LoadXML(Path:=FileName)
    If xml Is Nothing Then
        Application.StatusBar = False
        Exit Function
    End If

    'OK, mamy za|fffd|adowany plik, kontynuujemy:
    Dim calc, stbar
    
    PreserveStatusBar
    Application.DisplayStatusBar = True
    Application.cursor = xlWait
    calc = Application.Calculation
    
    Application.StatusBar = GetText("PreparingToImport", FileName)
    Application.Calculation = xlCalculationManual
    Application.CalculateFull 'Aby na pewno uaktualni|fffd|y si|fffd| np. nazwy arkuszy w mapowaniach
    
    On Error GoTo ErrHandler
    
        Application.StatusBar = GetText("VeryfingReportFile", FileName)
        Dim def As New ReportDef
        def.Initialize xml:=xml '|fffd|aduje i weryfikuje.
        If def.xml Is Nothing Then 'Weryfikacja zako|fffd|czona niepowodzeniem (komunikaty wy|fffd|wietlone wewn|fffd|trz)
            ShowInformation GetText("ImportFailed", FileName)
            ImportFromXML = False
        Else
            Application.StatusBar = GetText("ImportingReportFile", FileName)
             ClearDataFields AllAreas:=True, WithDefaults:=False 'Czy|fffd|ci wszystkie pola raportu, ale nie wstawia formu|fffd| i warto|fffd|ci domy|fffd|lnych...
            Application.Calculate 'Przeliczamy (na wypadek gdyby|fffd|my w poprzednim kroku wyczy|fffd|cili arkusz...)
            def.map.Import 'Przepisuje dane do raportu z pliku XML
            def.ApplyToLayout 'gdy si|fffd| udalo zaimportowa|fffd| dane - uaktualnij wygl|fffd|d arkuszy skoroszytu (wczytany raport mo|fffd|e by|fffd| innego rodzaju)
            ShowInformation GetText("ImportSuceeded", FileName)
            ImportFromXML = True
        End If
    
ErrHandler:
    If Err.Number <> 0 Then
        MsgBox GetText("ImportFailure", Err.Description & vbCr & "(" & Hex(Err.Number) & ")"), vbExclamation, GetText("UnexpectedError")
        RestoreStatusBar 'Bo inaczej - zostanie.
    End If
    'A potem - ko|fffd|czymy
    Application.Calculate
    Application.Calculation = calc 'Lepiej to w|fffd||fffd|czyc jak najpr|fffd|dzej, aby w przypadku b|fffd||fffd|du nie pozostawi|fffd| po sobie "|fffd|mieci" w konfiguracji programu
    Application.cursor = xlDefault 'Walidacja trwa kr|fffd|tko, wi|fffd|c nie ma co si|fffd| tu

End Function
'Procedura importuje dane do arkusza Excela
'Argumenty:
'   FileName: opcjonalny: nazwa pliku, z kt|fffd|rego mamy wczytywac dane. Je|fffd|eli pomini|fffd|ta, program wy|fffd|wietli okno dialogowe
Public Sub Imports(Optional ByVal FileName As Variant = "")
    Dim xml As Object 'DOMDocument60
    
    If Not IsEmpty(ExpireDate) And Now > ExpireDate Then
        MsgBox ExpireMsg
        Exit Sub
    End If
    
    If Not ImportAllowed() Then
        MsgBox GetText("ImportNotAllowedMsg")
        Exit Sub
    End If

    If FileName = "" Then 'Je|fffd|li nie okre|fffd|lono nazwy pliku: prosimy U|fffd|ytkownika o wskazanie:
        Dim PrimaryFilter As String, Prompt As String, Command As String
            'Ustalamy, jakie pliki podpowiadamy domy|fffd|lnie do importu (gdy mamy komponenty importu od klienta, to nie b|fffd|d|fffd| *.xml)
            PrimaryFilter = GetText("SFFileImportFilter")
            Prompt = GetText("SelectImportFile")
            Command = GetText("OpenSFFile")
            'Wy|fffd|wietlamy okno dialogowe i odcztujemy rezultat
            FileName = Application.GetOpenFilename(FileFilter:=PrimaryFilter, Title:=Prompt, Buttontext:=Command, MultiSelect:=False)
    End If

    If FileName = False Then 'U|fffd|ytkownik zrezygnowa|fffd|
        Exit Sub
    Else 'Dopercyzowano nazw|fffd| pliku:
        ImportFromXML FileName
    End If
End Sub
Sub Import_SF()
    Imports
End Sub
'Funkcja dla programowego wczytywania skoroszytu
'Argumenty:
'   XMLFileName: nazwa pliku *.xml do wczytania
'   HideEditButtons: opcjonalny. True, je|fffd|eli ma by|fffd| schowana wi|fffd|kszo|fffd||fffd| przycisk|fffd|w edycji
'Zwraca True, gdy si|fffd| uda|fffd|o
Function ImportSFFile(ByVal XMLFileName As String, Optional ByVal HideEditButtons As Boolean = False) As Boolean
    If HideEditButtons Then HideShapes ActiveWorkbook.Worksheets(1), "Wczytaj,Zapisz,WyzerujWszystko,WyzerujDane,EditLinks"
    ImportSFFile = ImportFromXML(XMLFileName)
End Function
Attribute VB_Name = "Licencja"
Attribute VB_Base = "0{871E28ED-6C65-4356-B905-F1E2FD6320EF}{DF69E7A8-0760-459D-8BF7-AA9E20C38A10}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Sub CloseBtn_Click()
   Unload Me
End Sub

Private Sub UserForm_Initialize()
   Dim txt As String, Id As String, ApName, WaznaDo
   ApName = Range(ApplicationName)
   If IsEmpty(ExpireDate()) Then
      WaznaDo = "bezterminowej,"
   Else
      WaznaDo = "do " & Format(ExpireDate(), "yyyy-MM-dd")
   End If
   If IFormVersion Then 'Dla IForm mamy nieco inny tekst licencji (z ca|fffd|kowitym wy|fffd||fffd|czeniem odpowiedzialno|fffd|ci)
        Id = "iform.Licencja"
   Else
        Id = "Licencja"
   End If
   txt = GetTemplate(Id)
   Me!TextBox.value = Replace(Replace(txt, "{SF}", ApName), "{Okres}", WaznaDo)
   Me!TextBox.SetFocus
   Me!TextBox.CurLine = 0
End Sub
Attribute VB_Name = "MappedField"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
'Klasa reprezentuj|fffd|ca pojedyncze mapowanie (wiersz) z obszaru [mapowanie!Mapowanie]
'Sta|fffd|e odpowiadaj|fffd|ce poszczeg|fffd|lnym kolumnom obszaru mapowania:
Private Const CAddress = 1 'Kolumna z adresem kom|fffd|rek
Private Const CDefault = 2 'Kolumna z opcjonaln|fffd| warto|fffd|ci|fffd|, kt|fffd|r|fffd| nale|fffd|y wstawi|fffd| w kom|fffd|rk|fffd| |fffd|r|fffd|d|fffd|ow|fffd| przed zapisem, je|fffd|eli jest pusta.
Private Const CAttribute = 3 'Kolumna z ewentualna informacj|fffd| dodatkow|fffd| (u|fffd|ywana do poprawnej identyfikacji kom|fffd|rki z b|fffd||fffd|dem)
Private Const CNotForPartialReset = 4 'Kolumna mo|fffd|e zawiera|fffd| 0, puste, lub 1: kom|fffd|rki z 1 nie s|fffd| resetowane przy resecie cz|fffd|ciowym
Private Const CFlag = 5 'Kolumna z na ewentualne flagi
Private Const CType = 6 'Typ danych
Private Const CIndex = 7 'numer kolejny (w przypadku kilku takich samych element|fffd|w XML
Private Const CFormula = 8 'Opcjonalna formu|fffd|a, podstawiana przy resecie (mo|fffd|e by|fffd| to sta|fffd|a warto|fffd||fffd| domy|fffd|lna)
Private Const CParent = 9 'Base name elementu "rodzica"
Private Const CNodeName = 10 'nazwa elementu docelowego (wraz z przedrostkiem NS, wg listy NS z arkusza "techniczne")
Private Const CLabel = 11 'etykieta docelowego elementu
Private Const MaxTextLength = 2500 'Du|fffd|o mniej ni|fffd| 3500, bo przy wczytywaniu polskie znaki w UTF-8 licz|fffd| si|fffd| podw|fffd|jnie!
Private Const AmountBaseName = "NumerBazyRaportu" 'Pola nazwane na "WZlotych" (1)/"WTys" (2)
'Pola (wewn|fffd|trzne):
Private myRow As Range 'wiersz z obszaru "Mapowanie" z definicj|fffd| mapowania
Private myAltRow As Range 'pole (2 poziome kom|fffd|rki) z arkusza "Mapowanie", z alterantywn|fffd| |fffd|cie|fffd|k|fffd| (u|fffd|ywane przy imporcie dokument|fffd|w w starszej wersji)
Private myNode As Object '(IXMLDOMElement) 'w|fffd|z|fffd|y XML, odpowiadaj|fffd|cy mapowaniu
Private myRange As Range 'kom|fffd|rki skoroszytu, przypisane do w|fffd|z|fffd|a XML
'Pomocnicza funkcja, kt|fffd|ra zwraca True gdy kom|fffd|rka zawiera jak|fffd||fffd| b|fffd||fffd|dn|fffd| warto|fffd||fffd|
'Argumenty:
'   Cell: badana kom|fffd|rka
'Funkcja stworzona, gdy|fffd| b|fffd||fffd|dy typu "oveflow" wywo|fffd|anych przez Cell.value nie mo|fffd|na przechwyci|fffd| funkcj|fffd| IsError()
Private Function ContainsError(ByVal cell As Range) As Boolean
    On Error Resume Next
        ContainsError = IsError(cell.value)
    If Err.Number <> 0 Then ContainsError = True
    On Error GoTo 0
End Function
'Funkcja wyszukuje w tek|fffd|cie znaki kontrolne niedopuszczalne w pliku XML (od 0 do 31, bez vbTab, vbCr i vbLF)
'Argumenty:
'   str:    przeszukiwnay tekst
'Zwraca pierwszy znaleziony znak, lub "", gdy nic nie znalaz|fffd|o
Private Function FindControlCharacter(ByVal str As String) As String
    FindControlCharacter = ""
    Dim chr As String, i As Long
    For i = 1 To Len(str)
        chr = Mid(str, i, 1)
        If Asc(chr) < 32 And Not (chr = vbTab Or chr = vbCr Or chr = vbLf) Then
            FindControlCharacter = chr
            Exit Function
        End If
    Next i
End Function
'Zwraca XPath elementu
'Uwaga: dla element|fffd|w typu "Alternative" zwraca tablic|fffd|!
Function GetXPath()
    Dim xpath As Variant
    Select Case Me.flag
        Case "Pidx": 'Zak|fffd|adam, |fffd|e tej flagi nie ma element indeksowany, ani alternatywny
                    xpath = "//" & AncestorName & "[" & Me.NodeIndex & "]/" & nodeName
        Case "Alternative": 'Zak|fffd|adam, |fffd|e tej flagi nie ma element indeksowany, (flag si|fffd| tak|fffd|e nie |fffd||fffd|czy)
                    xpath = Split(Me.nodeName, ",") 'Tutaj xpath jest tablic|fffd|: pocz|fffd|tkowo ka|fffd|dy element to jedno NodeName
                    Dim i
                    For i = 0 To UBound(xpath)
                        xpath(i) = "//" & AncestorName & "/" & xpath(i)  'Przekszta|fffd|amy pojedycz|fffd| nazw|fffd| w|fffd|z|fffd|a w kompletne wyra|fffd|enie
                    Next i
        Case Else 'Pozosta|fffd|e przypadki: (w tym "Ancestor"):
                    xpath = "//" & AncestorName
                    If nodeName <> "." Then 'S|fffd| przypadki, gdy mapujemy si|fffd| bezpo|fffd|rednio na w|fffd|ze|fffd| rodzica:
                        If Me.flag = "Ancestor" Then
                            xpath = xpath & "//" & nodeName 'Flaga "Ancestor" informuje, |fffd|e <AncestorName> nie ejst bezpo|fffd|rednim rodzicem
                        Else
                            xpath = xpath & "/" & nodeName
                        End If
                    End If
                    If Not IsEmpty(Me.NodeIndex) Then
                        xpath = "(" & xpath & ")[" & Me.NodeIndex & "]" 'Tylko konkretny element...
                    End If
    End Select
    GetXPath = xpath
End Function
'Konstruktor (dla eksportu: znany wiersz, w|fffd|ze|fffd| XML do znalezienia)
'Argumenty:
'   row: wiersz z obszaru "Mapowanie" z definicj|fffd| mapowania
'   xml: [opcjonalny] dokument XML z kt|fffd|rego chcemy odczyta|fffd| lub zapisa|fffd| dane (DOMDocument60)
'   SkipHiddenSheets: [opcjonalny] pomi|fffd| mapowania dotycz|fffd|ce ukrytych arkuszy (domy|fffd|lnie: False)
'   AltRow: [opcjonany] alternatywne mapowanie (np. dotycz|fffd|ce poprzedniej wersji schematu) (Range)
'           UWAGA: *NIE* przekazuj AltRow z pustymi warto|fffd|ciami
'Zwraca True, gdy znaleziono po|fffd||fffd|czenie z dokumentem XML.
Function Initialize(ByVal row As Range, Optional ByVal xml As Object = Nothing, _
                        Optional ByVal SkipHiddenSheets As Boolean = False, Optional ByVal AltRow) As Boolean
    Initialize = False
    
    Set myRow = row
    
    If Not Me.IsValid Then Exit Function
    
    If IsMissing(AltRow) Then 'Ewentualne mapowanie w starszej wersji schematu (Musi zawiera|fffd| alternatywne mapowanie!)
        Set myAltRow = Nothing
    Else
        Set myAltRow = AltRow
    End If
    
    Set myRange = Range(myRow.cells(CAddress))
    'Spr|fffd|buj znale|fffd||fffd| w|fffd|ze|fffd| XML, odpowiadaj|fffd|cy tej definicji:
    Set myNode = Nothing
    If xml Is Nothing Then Exit Function
    'Podczas mapowania XML w pewnych przypadkach mo|fffd|emy pomin|fffd||fffd| ukryte lub puste pola: (nie b|fffd|dzie ich w|fffd|r|fffd|d usuni|fffd|tych p|fffd|l w myFields!)
    If SkipHiddenSheets Then '(Ma to znaczenie szczeg|fffd|lnie w przypadku Skonsolidowanej: XPath z indeksem s|fffd| bardzo kosztowne!)
        Dim skip As Boolean
        skip = (myRange.Worksheet.Visible <> xlSheetVisible)
        If Not skip Then skip = (myRange.EntireRow.Hidden)
        'Szczeg|fffd|lna optymalizacja z my|fffd|l|fffd| o jednostce skonsolidowanej(w razie problem|fffd|w - skomentuj):
        If Me.NodeIndex > 1 Or InStr(Me.AncestorName, "[") Then 'wykluczamy wszystkie puste pola element|fffd|w indeksowanych
            If Not skip Then skip = (myRange.value = "" And Me.DefaultValue = "") 'Pod ten warunek wpadaj|fffd| i warto|fffd|ci "", i Empty
        End If
        If skip Then Exit Function 'Zwracamy w takim przypadku 0
    End If
    
    'Dalsza cz|fffd||fffd| - to przypisanie mapowania do pola dokumentu
    Dim xpath As Variant
    Dim nodes As Object 'IXMLDOMNodeList
    
    'Initialize = 1 'Ta kom|fffd|rka jest widoczna: znajdzie si|fffd| albo na li|fffd|cie odrzuconych (1), albo zamapowanych (-1)
    
    xpath = GetXPath()
    
    If IsArray(xpath) Then 'to szczeg|fffd|lny przypadek z flag|fffd| "Alternative"
        Dim expr
        For Each expr In xpath
            Set nodes = xml.DocumentElement.SelectNodes(expr) 'Pierwszym elementem listy alterantyw powinien by|fffd| ten preferowany przy zapisie
            If nodes.Length > 0 Then Exit For 'Przerywamy te p|fffd|tl|fffd| dla pierwszego znalezionego elementu spo|fffd|r|fffd|d wymienionych alternatyw
        Next expr
    Else 'pozosta|fffd|e przypadki
        Set nodes = xml.DocumentElement.SelectNodes(xpath)
    End If

    Select Case nodes.Length
        Case 1:  'OK
                    Set myNode = nodes.item(0)
                    Initialize = True
        Case 0:
                 If Me.flag = "Exists" Then
                    'Trzeba sprawdzi|fffd|, czy przynajmniej istnieje w|fffd|ze|fffd| "rodzica":
                    xpath = "//" & AncestorName
                    Set nodes = xml.DocumentElement.SelectNodes(xpath)
                    Initialize = nodes.Length > 0 'Te mapowania zachowujemy nawet gdy nie ma docelowego w|fffd|z|fffd|a (o mo|fffd|e chodzi|fffd| o opracj|fffd| importu)
                 End If
                 'Wida|fffd| to pole jest tak|fffd|e wsp|fffd|dzielone z innym wariantem raportu, i to jest ta niew|fffd|a|fffd|ciwa definicja
                 'w takim przypadku nie robimy nic, aby zwr|fffd|ci|fffd| False.
                  'Err.Raise CriticalError, "MappedField", GetText("NoFieldMapped", xml.DocumentElement.BaseName, xpath)
        Case Else 'Wiele wynik|fffd|w?
            If Me.DataType = "Mtekst" Then 'Pola typu Mtekst mog|fffd| zawiera|fffd| wiele takich samych element|fffd|w
                Set myNode = nodes.item(0) 'zak|fffd|adamy, |fffd|e nast|fffd|pny w|fffd|ze|fffd| ma tak|fffd| sam|fffd| nazw|fffd| i jest dalsz|fffd| cz|fffd|ci|fffd| tekstu
                Initialize = True
            Else
                Err.Raise CriticalError, "MappedField", GetText("TooManyFieldsMapped", xml.DocumentElement.BaseName, xpath, nodes.Length, myRow.row)
            End If
    End Select
End Function
'Pomocnicza funkcja: nadaje kom|fffd|rce docelowej wartos|fffd| domy|fffd|ln|fffd| (wykonuje reset)
'Argumenty:
'   UseDefaults: True, je|fffd|eli w puste pola nale|fffd|y wstawia|fffd| warto|fffd|ci domy|fffd|lne
Private Sub ResetTargetCells(ByVal UseDefaults As Boolean)
    Select Case Me.DataType
        Case "ErrorMark":
            'nic
        Case "Plik":
            If IsEmpty(cell.value) Then Exit Sub 'Nie ma czego usuwa|fffd|:
            Dim pwd
            pwd = UnprotectSheet(myRange.Worksheet)
            If Not IsEmpty(pwd) Then
                Dim att As New Attachement
                att.Initialize cell:=myRange
                att.Remove
                myRange.formula = ""
                ProtectSheet myRange.Worksheet, pwd
            End If
        Case Else
            If Me.Hint = "ExportOnly" And myRange.Locked Then Exit Sub 'Pola podsumowania subpozycji w "Dodatkowych" s|fffd| chronione.
            Dim formula As String
            If myRange.cells.count = 1 Then
                If UseDefaults Then 'Podstaw warto|fffd|ci domy|fffd|lne/formu|fffd|y
                    formula = myRow.cells(CFormula).value 'Je|fffd|eli domy|fffd|lna formu|fffd|a nie jest pusta - przepisujemy!
                    Select Case formula 'Specjalne przypadki formu|fffd|:
                        Case "*SumUp": 'Sumowanie komorek nast|fffd|pnego poziomu agregacji sponad myRange
                                        formula = AggregateSumFormula(Me.cell, -1)
                        Case "*Sum": 'Zwyk|fffd|e sumowanie kom|fffd|rek nastepnego poziomu agregacji poni|fffd|ej myRange
                                        formula = AggregateSumFormula(Me.cell)
                    End Select
                Else
                    formula = ""
                End If
                myRange.formula = formula
            Else
                myRange.ClearContents
            End If
    End Select
End Sub
'Procedura ustawia zawarto|fffd||fffd| powi|fffd|zanego pola w Excelu na domy|fffd|ln|fffd|
'Argumenty:
'   Partialreset: je|fffd|eli True, nie resetuj kom|fffd|rek kt|fffd|rych pola definicji: CNotForPartialReset s|fffd| r|fffd|wne 1
'   UseDefaults:  je|fffd|eli True - w puste kom|fffd|rki wstaw warto|fffd|ci domy|fffd|lne
Sub ResetExcelField(ByVal PartialReset As Boolean, ByVal UseDefaults As Boolean)
    If PartialReset Then
        Dim flag
        flag = myRow.cells(CNotForPartialReset)

        If IsEmpty(flag) Then 'W zale|fffd|no|fffd|ci od typu:
            Select Case Me.DataType
            Case "Kwota", "Data":
                        ResetTargetCells UseDefaults
            Case Else
                'pomi|fffd|
            End Select
        Else
            If flag = 0 Then ResetTargetCells UseDefaults 'zawsze resetuj
        End If
    Else
        ResetTargetCells UseDefaults
    End If
End Sub
'Aktualizacja formatu wy|fffd|wietlania liczb, w zale|fffd|no|fffd|ci od bazy (w tysi|fffd|cach/w z|fffd|otych)
Sub UpdateAmountFormat()
    If Me.DataType = "Kwota" Then
        With Me.cell
            If Range(AmountBaseName) = 2 Then '1: z|fffd|ote, 2: tysi|fffd|ce
                .NumberFormat = "#,##0" 'tysi|fffd|ce bez miejsc dziesi|fffd|tnych
            Else
                .NumberFormat = "#,##0.00" 'z|fffd|ote - z groszami.
            End If
        End With
    End If
End Sub
'Metoda importuje do arkusza dane z odpowiedniego w|fffd|z|fffd|a XML do przypisanej kom|fffd|rki skoroszytu
'Argumenty:
'   CalculatedFields: lista, do kt|fffd|rej nale|fffd|y dodawa|fffd| pola obliczane (do p|fffd|niejszego sprawdzenia, czy s|fffd| identyczne z wynikiem)
'                     (mo|fffd|e by|fffd| Nothing - wtedy nadpisywane jest ka|fffd|de pole obliczane)
Sub Import(ByVal CalculatedFields As Collection)
    Dim text As Object 'IXMLDOMCharacterData
    Dim var As Variant
    If Me.Hint = "ExportOnly" Then Exit Sub
    If Not (CalculatedFields Is Nothing) _
       And Not IsEmpty(myRow.cells(CFormula).value) _
       And Me.flag <> "Exists" Then
        CalculatedFields.Add Me, Me.Id
        'Na pocz|fffd|tku wpiszemy w takie pola sta|fffd||fffd| warto|fffd||fffd| (kod poni|fffd|ej)
    End If
    Select Case Me.DataType
        Case "ErrorMark":
                Exit Sub
        Case "Data":
                Set text = TextNodeOf(myNode)
                If text Is Nothing Then Exit Sub Else var = text.data
                If IsDate(var) Then
                    myRange.cells(1).formula = var
                Else
                    myRange.cells(1).formula = "'" & var 'Czasami co|fffd|, co wygl|fffd|da wg Anglosas|fffd|w na dat|fffd|, wcale ni|fffd| nie jest!
                End If
                
        Case "Tekst":
                Set text = TextNodeOf(myNode)
                If text Is Nothing Then Exit Sub Else var = text.data
                myRange.cells(1).formula = "'" & var
                
        Case "Kwota", "Procent":
                Set text = TextNodeOf(myNode)
                If text Is Nothing Then Exit Sub Else var = text.data
                'Znak dziesi|fffd|tny w XML jest zawsze kropk|fffd|, wi|fffd|c najpro|fffd|ciej b|fffd|dzie przepisa|fffd| warto|fffd||fffd| jako formu|fffd||fffd| niezale|fffd|n|fffd| od lokalizacji:
                myRange.cells(1).formula = var
                If Me.DataType = "Procent" Then myRange.cells(1).value = (myRange.cells(1).value / 100#) 'Procenty w Excelu to zwyk|fffd|e u|fffd|amki
                
        Case "Logiczny":
                If Me.flag = "Exists" Then 'Mapowania z t|fffd| flag|fffd| s|fffd| wy|fffd||fffd|cznie logiczne.
                    If myNode Is Nothing Then var = "false" Else var = "true" 'Pole z flag|fffd| "Exists" odpowiada na pytanie, czy wskazany element w og|fffd|le istnieje
                Else
                    Set text = TextNodeOf(myNode)
                    If text Is Nothing Then Exit Sub Else var = text.data
                End If
                
                Select Case var
                    Case "true": myRange.cells(1).value = 1
                    Case "false": myRange.cells(1).value = 2
                    Case Else
                        'dziwne: niczego nie przepisujemy
                End Select

        Case "Mtekst":
                'Ewentualna kumulacja kilku kolejnych element|fffd|w z tekstem:
                Dim node As Object 'IXMLDOMNode
                Dim nName As String
                var = ""
                Set node = myNode
                nName = myNode.BaseName
                Do
                    If node.NodeType = NODE_ELEMENT Then 'je|fffd|eli to jest kolejny element o takiej samej nazwie...
                        If node.BaseName = nName Then
                            Set text = TextNodeOf(node)
                            If Not (text Is Nothing) Then var = var & text.data
                        Else 'Je|fffd|eli kolejny w|fffd|ze|fffd| ma inn|fffd| nazw|fffd| - koniec sekwencji!
                            Exit Do 'Wychodzimy z p|fffd|tli
                        End If
                    End If
                    Set node = node.NextSibling
                Loop Until node Is Nothing
                myRange.cells(1).formula = "'" & var
                
         Case "Plik":
                'Najpierw zidentyfikujemy w|fffd|z|fffd|y docelowe:
                    Dim Description As Object 'IXMLDOMNode
                    Dim contents As Object 'IXMLDOMNode
                    Dim FileName As String 'Pomocnicze: nazwa pliku (bez |fffd|cie|fffd|ki)
                    Dim pwd
                    pwd = UnprotectSheet(myRange.Worksheet)
                    If IsEmpty(pwd) Then Exit Sub
                    On Error GoTo ErrHandler
                        DisableScreenUpdating
                        Set Description = myNode.SelectSingleNode("dtsf:Nazwa")
                        Set text = TextNodeOf(Description)
                        If text Is Nothing Then Exit Sub Else FileName = text.data
                        
                        Set contents = myNode.SelectSingleNode("dtsf:Zawartosc")
                        Set text = TextNodeOf(contents)
                        If text Is Nothing Then Exit Sub 'je|fffd|eli nie jest Nothing: ten text.data mo|fffd|e by|fffd| bardzo d|fffd|ugi!
                        
                        'Zapisz ten tekst (w base64) jako binarny pierwowz|fffd|r:
                        Dim tmpPath As String, data As String
                        tmpPath = Environ("temp") & "\" & FileName
                        If FileExists(tmpPath) Then Kill tmpPath 'Na wszelki wypadek (Base64ToFile nie pozwala nadpisa|fffd| pliku)
                        Stream.Base64ToFile text.data, tmpPath
                        'Potem zainicjuj obiekt za|fffd||fffd|cznika:
                        Dim att As New Attachement
                        att.Initialize cell:=myRange
                        'Potem wstaw ten plik jako za|fffd||fffd|cznik do arkusza:
                        att.Insert tmpPath
                        'Na koniec nie zostawiac po sobie |fffd|mieci:
                        'If LCase(ExtensionOf(tmpPath)) <> "xlsx" Then Kill tmpPath
                        Kill tmpPath
ErrHandler: 'Importu pliku
                    Dim ErrNumber, ErrDescr
                    ErrNumber = Err.Number: ErrDescr = Err.Description 'ProtectSheet zeruje numer b|fffd||fffd|du
                    ProtectSheet myRange.Worksheet, pwd
                    EnableScreenUpdating

                    If ErrNumber <> 0 Then
                        If FileExists(tmpPath) Then 'Plik powsta|fffd| - wi|fffd|c mo|fffd|e spr|fffd|bowa|fffd| zapisa|fffd| plik na dysku?
                            Dim answer As VBA.VbMsgBoxResult
                            Dim Path
                            'Poka|fffd|, o kt|fffd|ry za|fffd||fffd|cznik chodzi
                            On Error Resume Next 'Na wszelki wypadek - aby ten drobny krok nie "wywali|fffd|" ca|fffd|ego skoroszytu
                                ShowCell Me.cell 'Poka|fffd|, o kt|fffd|ry za|fffd||fffd|cznik chodzi.
                            On Error GoTo 0
                            answer = MsgBox(ErrDescr & GetText("WriteToDiskInstead?"), _
                                                vbYesNoCancel Or vbDefaultButton1, GetText("UnexpectedError"))
                            If answer = vbYes Then
                                Path = Application.GetSaveAsFilename(InitialFileName:=Split(FileName, ".")(0), _
                                                                     FileFilter:=GetText("SpecificFileFilter", IIf(ExtensionOf(FileName) = "", "*", ExtensionOf(FileName))), _
                                                                     Title:=GetText("SavingAttachement"), _
                                                                     Buttontext:=GetText("SaveAttachement"))
                            End If
                            If VarType(Path) = vbString Then 'u|fffd|ytkownik wskaza|fffd|, gdzie mo|fffd|na zapisa|fffd| ten za|fffd||fffd|cznik:
                                If FileExists(Path) Then Kill Path 'Na wszelki wypadek (Base64ToFile nie pozwala nadpisa|fffd| pliku)
                                Stream.Base64ToFile text.data, Path 'W razie czego - to wywo|fffd|a b|fffd||fffd|d
                            Else
                                If answer = vbNo Then 'Przerywamy import:
                                    Err.Raise ErrNumber, "MappedField", ErrDescr 'Wy|fffd|wietl komunikat o b|fffd||fffd|dzie
                                Else
                                    'Nic: z poprzedniego okienka u|fffd|ytkownik wie, |fffd|e b|fffd|dzie mu brakowa|fffd| tego za|fffd||fffd|cznika
                                    'Nie zg|fffd|aszamy jednak b|fffd||fffd|du, aby nie przerwa|fffd| wczytywania
                                End If
                            End If
                        Else
                            Err.Raise ErrNumber, "MappedField", ErrDescr 'Wy|fffd|wietl komunikat o b|fffd||fffd|dzie
                        End If
                    End If
                    
        Case Else
            Err.Raise CriticalError, "MappedField", GetText("UnknownDataType", Me.DataType, Adr(myRow))
    End Select
End Sub
'Zwraca w|fffd|ze|fffd| reprezentuj|fffd|cy tekst (lub sekcj|fffd| CDATA) w podanym elemencie lub Nothing gdy nie istnieje
'Argumenty:
'   Elm: element XML (IXMLDOMElement) (reprezentuj|fffd|cy np. <REGON>0123456789</REGON>)
'Funkcja istnieje wy|fffd||fffd|cznie dlatego, |fffd|e w Windows 7 pr|fffd|by zapisania warto|fffd|ci do Elm.Text trwaj|fffd| o rz|fffd|d wielko|fffd|ci wolniej
'ni|fffd| zapisanie tego samego tekstu do pola .data jego elementu tekstowego. Wykorzystanie Elm.Text bardzo spowalnia|fffd|o wczytywanie,
'wi|fffd|c musia|fffd|em znale|fffd||fffd| lepsze rozwi|fffd|zanie
Private Function TextNodeOf(ByVal elm As Object) As Object 'IXMLDOMCharacterData
    Dim Child As Object 'IXMLDOMNode
    Set TextNodeOf = Nothing
    For Each Child In elm.ChildNodes
        If Child.NodeType = NODE_CDATA_SECTION Or Child.NodeType = NODE_TEXT Then
           Set TextNodeOf = Child
           Exit For
        End If
    Next Child
End Function
'Procedura zapisuje w w|fffd|le DOM podany tekst
'Argumenty:
'   node:   w|fffd|ze|fffd| XML, do kt|fffd|rego mamy co|fffd| wpisa|fffd| (IXMLDOMElement)
'   var:    wpisywana zawarto|fffd||fffd| kom|fffd|rki
Private Sub SetNodeText(ByVal node As Object, ByRef var)
    Dim text As Object 'IXMLDOMCharacterData
    Set text = TextNodeOf(node) 'Aby szybciej odczyta|fffd| warto|fffd||fffd| (a przynajmniej do|fffd|o|fffd|y|fffd| wszelkich stara|fffd|...)

    If text Is Nothing Then
        Set text = node.OwnerDocument.createTextNode(var)
        node.appendChild text
    Else
        text.data = var
    End If
End Sub

'Metoda eksportuje dane z arkusza do wskazanego w|fffd|z|fffd|a
Sub Export()
    Dim var As Variant
    Dim ErrNumber As Long, ErrDescription As String
    Dim default As Variant
    
    If cell.EntireRow.Hidden Then Exit Sub 'Kom|fffd|rek, kt|fffd|re powinny by|fffd| widoczne, a nie s|fffd| - nie przepisujemy.
    If cell.Worksheet.Visible <> xlSheetVisible Then Exit Sub 'Nie przepisujemy tak|fffd|e ukrytych arkuszy (bo mog|fffd| tam by|fffd| jakie|fffd| zapomniane dane)
    var = cell.value 'Gdyby u|fffd|y|fffd| Value2 - nie b|fffd|dzie b|fffd||fffd|du, ale tracimy przekszta|fffd|cenie na dat|fffd|.
    If IsEmpty(var) Or var = "" Then 'var mo|fffd|e by|fffd| "" dla kwot z formu|fffd|ami warunkowymi
        'Czy pole ma warto|fffd||fffd| domy|fffd|ln|fffd|?
        default = Me.DefaultValue
        If Not IsEmpty(default) Then 'Je|fffd|eli pole |fffd|r|fffd|d|fffd|owe jest puste - podstaw w nie warto|fffd||fffd| domy|fffd|ln|fffd|
            var = default
            If Not cell.Locked Then cell.value = default 'Wpisz warto|fffd||fffd| domy|fffd|ln|fffd| tak|fffd|e w skoroszyt, aby u|fffd|ytkownik nie by|fffd| zaskoczony.
        Else 'W przeciwnym razie - nie ma czego przepisywa|fffd|:
            Exit Sub
        End If
    End If
    
    Select Case Me.DataType
        Case "ErrorMark":
                Exit Sub
        Case "Data":
                var = Format(var, "yyyy-MM-dd") 'Aby na pewno data by|fffd|a we w|fffd|a|fffd|ciwym formacie
                SetNodeText myNode, var
                
        Case "Tekst":
                SetNodeText myNode, var
                
        Case "Procent":
                var = var * 100# 'W XML warto|fffd|ci procentowe s|fffd| pomno|fffd|one przez 100.
                var = FormatNumber(var, True) 'Zapisuj w XML zawsze z miejscami u|fffd|amkowymi
                SetNodeText myNode, var
                
        Case "Kwota":
                var = FormatNumber(var, Range(AmountBaseName) = 1) 'AmountBase = 1: z|fffd|ote, =2: tysi|fffd|ce
                SetNodeText myNode, var
                
        Case "Logiczny":
                If Me.flag = "Exists" Then Exit Sub 'Pola z t|fffd| flag|fffd| ignorujemy przy zapisie
                Select Case var
                    Case 1: var = "true"
                    Case 2: var = "false"
                    Case Else
                        Err.Raise CriticalError, "MappedField", GetText("ImproperBooleanMsg", var)
                End Select
                SetNodeText myNode, var
        Case "Mtekst":
                If Len(var) < MaxTextLength Then 'Obs|fffd|uguj jak zwyk|fffd|y tekst: zmie|fffd|ci si|fffd| w jeden element
                    SetNodeText myNode, var
                Else
                    Dim node As Object 'IXMLDOMElement
                    Dim prev As Object 'IXMLDOMElement
                    Dim text As String
                    
                    Set node = myNode
                    Set prev = Nothing
                    While Len(var) > 0
                        If Not (prev Is Nothing) Then
                            prev.ParentNode.InsertBefore node, prev.NextSibling 'Wstaw node za prev
                        End If
                        Set prev = node 'prev jest teraz PUSTYM w|fffd|z|fffd|em docelowym
                        Set node = node.CloneNode(True) 'Stw|fffd|rz nowy w|fffd|ze|fffd| (na razie - tak "na zapas)
                        '"wycinam" z lewej strony <var> fragment tekstu:
                        text = Left(var, MaxTextLength)
                        var = Mid(var, MaxTextLength + 1) '
                        
                        SetNodeText prev, text 'i zapisuj|fffd| go do prev (prev przestaje by|fffd| pusty)
                    Wend
                End If
         Case "Plik":
                'Najpierw zidentyfikujemy w|fffd|z|fffd|y docelowe:
                    Dim FileName As String 'Pomocnicze: nazwa pliku (bez |fffd|cie|fffd|ki)
                    Dim Description As Object 'IXMLDOMNode
                    Dim contents As Object 'IXMLDOMNode
                    FileName = var
                    Set Description = myNode.SelectSingleNode("dtsf:Nazwa")
                    Set contents = myNode.SelectSingleNode("dtsf:Zawartosc")
                    'Potem zainisjuj obiekt za|fffd||fffd|cznika:
                    Dim att As New Attachement
                    att.Initialize cell:=myRange
                    'Potem trzeba zapisa|fffd| ten za|fffd||fffd|cznik jako tymczasowy plik:
                    Dim tmpPath As String, data As String
                    tmpPath = Environ("temp") & "\" & FileName
                    att.Save tmpPath
                    'Nast|fffd|pnie odczytujemy CA|fffd||fffd| zawarto|fffd||fffd| tego pliku do zmiennej <data> typu String (max. 2GB danych)
                    Stream.FileToBase64 tmpPath, data
                    'Potem wype|fffd|niamy obydwa w|fffd|z|fffd|y elementu:
                    SetNodeText contents, data
                    SetNodeText Description, FileName
                    'Na koniec nie zostawiac po sobie |fffd|mieci:
                    Kill tmpPath
        Case Else
            Err.Raise CriticalError, "MappedField", GetText("UnknownDataType", Me.DataType, Adr(myRow))
    End Select
End Sub
'Identyfikatorem jest numer wiersza definicji tego mapowania w arkuszu "mapowanie"
Property Get Id() As String
    Id = "w" & myRow.row
End Property
'Pomocnicza metoda: dodaje nowy atrybut do wskazanego w|fffd|z|fffd|a
'Argumenty:
'   Node:   w|fffd|ze|fffd|, do kt|fffd|rego nale|fffd|y dodac atrybut (IXMLDOMElement)
'   name:   nazwa atrybutu
'   value:  warto|fffd||fffd| atrybutu
Private Sub AddAttribute(ByVal node As Object, ByVal Name As String, ByVal value As String)
    Dim att As Object 'IXMLDOMAttribute
    If node.Attributes.getNamedItem(Name) Is Nothing Then 'Ten element nie ma jeszcze takiego atrybutu
        Set att = myNode.OwnerDocument.createAttribute(Name)
        att.value = value
        node.Attributes.setNamedItem att
    End If
End Sub
'Metoda wykorzystywana przez Mapper.FindCellFor: dodaje do zamapowanego elementu atrybut "mapped",
'kt|fffd|rego warto|fffd|ci|fffd| jest numer wiersza definicji tego mapowania w arkuszu "mapowanie"
'UWAGA: zmienia dokument docelowy tak, |fffd|e przestaje by|fffd| zgodny ze swoim schematem XSD
Sub MarkNode()
    Dim node As Object 'IXMLDOMElement
    
    If Me.DataType = "MTekst" Then
        Dim prev As Object 'IXMLDOMElement
        Dim text As String
        
        Set node = myNode
        Set prev = Nothing
        While Not (node Is Nothing)
            If node.BaseName = myNode.BaseName Then
                AddAttribute node, "mapped", Me.Id
                Set node = node.NextSibling
            Else
                Set node = Nothing 'Koniec sekcji
            End If
        Wend
    Else
        If myNode Is Nothing Then Exit Sub
        AddAttribute myNode, "mapped", Me.Id 'dodaj atrybut @mapped, kt|fffd|rego warto|fffd|ci|fffd| jest numer wiersza myRow w arkuszu Map (klucz listy w obiekcie Mapper)
        If Me.Hint Like "MarkParent*" Then  'je|fffd|eli mamy dodatkowo oznaczy|fffd| tak|fffd|e element rodzica/rodzic|fffd|w (do poprawnego odnajdowania kom|fffd|rek z b|fffd||fffd|dnym elementem)
            Dim counter As Integer
            If myNode.ParentNode Is Nothing Then Exit Sub 'W|fffd|z|fffd|y, kt|fffd|re by|fffd|y puste i zosta|fffd|y "wyczysczone" z dokumentu nie maj|fffd| w|fffd|z|fffd|a "rodzica"
            'Ilu "przodk|fffd|w" wstecz mamy oznaczy|fffd|?
            If Me.Hint Like "MarkParent:#*" Then 'Liczb|fffd| przodk|fffd|w podajemy w Hint po dwukropku: 2, 3, ...
                Dim Pos As Integer
                Pos = InStr(Me.Hint, ":")
                counter = Mid(Me.Hint, Pos + 1)
            Else 'Domy|fffd|lnie: 1
                counter = 1
            End If
            Set node = myNode
            While counter > 0 And Not (node Is Nothing)
                counter = counter - 1
                Set node = node.ParentNode
                If Not (node Is Nothing) Then AddAttribute node, "mapped", Me.Id
            Wend
        End If
    End If
End Sub
'Informacja pomocnicza dla mapowania ("ExportOnly")
Property Get DefaultValue() As Variant
    DefaultValue = myRow.cells(CDefault)
End Property
'Informacja pomocnicza dla mapowania (np. "MarkParent" albo "ExportOnly")
Property Get Hint() As String
    Hint = myRow.cells(CAttribute)
End Property
'Nazwa elementu "g|fffd||fffd|wnego" (kluczowego "przodka" w|fffd|z|fffd|a XML)
Property Get AncestorName() As String
    If myAltRow Is Nothing Then
        AncestorName = myRow.cells(CParent)
    Else
        AncestorName = myAltRow.cells(1)
    End If
End Property
'Nazwa docelowego elementu XML
'UWAGA: gdy Me.Flag = "Alternative", ta w|fffd|a|fffd|ciwos|fffd| zwraca list|fffd| nazw, rozdzielonych przecinkami (bez spacji)
Property Get nodeName() As String
    If myAltRow Is Nothing Then
        nodeName = myRow.cells(CNodeName)
    Else
        nodeName = myAltRow.cells(2)
    End If
End Property
'Etykieta pola na arkuszu
Property Get Label() As String
    Label = myRow.cells(CLabel)
End Property
'Typ pola (na arkuszu mapowania)
Property Get DataType() As String
    DataType = myRow.cells(CType)
End Property
'opcjonalny indeks (na arkuszu mapowania)
Property Get NodeIndex()
    NodeIndex = myRow.cells(CIndex)
End Property
'opcjonalna Flaga (na arkuszu mapowania)
Property Get flag()
    flag = myRow.cells(CFlag)
End Property
'Kom|fffd|rka docelowa (obszar na / z danymi)
Property Get cell() As Range
    Set cell = myRange
End Property
'Powi|fffd|zany w|fffd|ze|fffd| XML
Property Get node() As Object
    Set node = myNode
End Property
'Zwraca False, gdy mapowanie nie powinno by|fffd| pretwarzane, bo jest puste
'(Nie jest przypisane do |fffd|adnej kom|fffd|rki)
Property Get IsValid() As Boolean
    Dim result As Boolean
    Dim fc
    fc = myRow.cells(CAddress)
    result = IsError(fc)
    If Not result Then result = IsEmpty(fc)
    If Not result Then result = (fc = "") 'Mapowania arkusza "Dodatkowe" s|fffd| w wariancie skonsolidowanym puste (z formu|fffd|y)
    IsValid = Not result
End Property
Attribute VB_Name = "Mapper"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
'Reprezentuje list|fffd| element|fffd|w z mapowaniami obszar|fffd|w Excela na pola dokumentu XML wskazanego podczas inicjalizacji
Private Const MapDefinitionsName = "Mapowanie" 'Nazwa obszaru z definicjami mapowa|fffd|
Private Const AltMapName = "PreviousMapping" 'Nag|fffd||fffd|wek (wiersz powy|fffd|ej) obszaru z alternatywnymi mapowaniami (dla importu starszych wersji)
Private myFields As Collection 'Kolekcja zweryfikowanych mapowa|fffd| (obiekt|fffd|w klasy MappedField)

'Pomocnicza funkcja: obszar z alternatywnym mapowaniem dla formatu podanego XML.
'Argumenty:
'   xml:    dokument xml
'Je|fffd|eli nie istnieje alternatywne mapowanie dla tego schematu - zwraca Nothing
Private Function InitializeAltList(ByVal xml As Object) As Range
        Dim version As String, Header As Range
        Set InitializeAltList = Nothing
        version = GetSchemaVersion(xml)
        If version = "" Then Exit Function 'Ten plik ma chyba z|fffd|y format.
        Set Header = Range(AltMapName)
        If Header Is Nothing Then Exit Function
        'Je|fffd|eli taki nag|fffd||fffd|wek istnieje: w pierwszej kom|fffd|rce powinna by|fffd| lista wersji schemy, kt|fffd|rych dotyczy
        If Contains(Header.cells(1), version) Then 'Je|fffd|eli wersja tego dokumentu to jedna ze starych wersji
            Set InitializeAltList = Header.EntireColumn 'AltList to kolumny z mapowaniami
        End If
End Function
'Pomocnicza funkcja: zwraca ewentualny obszar z alterantywnym mapowaniem dla wiersza row
'Argumenty:
'   row:        wiersz podstawowego mapowania
'   AltList:    alternatywna lista (zwr|fffd|cona przez InitializeAltList())
'Zwraca Nothing, gdy AltList jest Nothing lub jej wiersz zawiera puste warto|fffd|ci (czyli gdy tak czy siak - nie ma alternatywnego mapowania)
Private Function GetAltRow(ByVal row As Range, ByVal AltList As Range) As Range
    Dim AltRow As Range
    Set GetAltRow = Nothing
    If AltList Is Nothing Then Exit Function
    Set AltRow = AltList.Rows(row.row)
    If Not IsEmpty(AltRow.cells(1)) Then
        Set GetAltRow = AltRow
    End If
End Function
'Konstruktor
'Argumenty:
'   xml:                dokument XML (DOMDocument60) z kt|fffd|rego chcemy odczyta|fffd| lub zapisa|fffd| dane
'   ForExport: [opcjonalny] informacja, |fffd|e ten plik jest do eksportu (domy|fffd|lnie: False) - do optymalizacji eksportu w Skonsolidowanej
'Funkcja wywo|fffd|ywana tylko w trakcie importu lub eksportu, dla jednostki Skonsolidowanej potrafi naprawd|fffd|
'd|fffd|ugo trwa|fffd|, dlatego doda|fffd|em tu wy|fffd|wietlanie tekstu w pasku stanu Excela o post|fffd|pie.
'(Ukryciem tego napisu zajmuj|fffd| si|fffd| g|fffd||fffd|wne procedury eksportu/importu)
Sub Initialize(ByVal xml As Object, Optional ByVal ForExport As Boolean = False)
    Set myFields = New Collection
    Dim list As Range, AltList As Range, row As Range, item As MappedField
    Dim Prefix As String, i As Integer
    
    Prefix = GetText("MappingXMLFields|fffd|")
    Set list = Range(MapDefinitionsName)
    If ForExport Then
        Set AltList = Nothing
    Else
        Set AltList = InitializeAltList(xml)
    End If
    
    i = 0
    
On Error GoTo ErrHandler
    For Each row In list.Rows
        Set item = New MappedField
        If item.Initialize(row, xml, ForExport, GetAltRow(row, AltList)) Then 'To tak|fffd|e wyklucza wszystkie item.isValid = False, lub z niewidocznych arkuszy, gdy ForExport = True
            myFields.Add item, item.Id 'Kluczem kolekcji mapowa|fffd| jest numer wiersza w arkuszu "mapowanie" (przydatny przy identyfikacji zwrotnej)
        End If
        i = i + 1
        If i Mod 50 = 0 Then
            Application.StatusBar = Prefix & Format(i / list.Rows.count, "0%")
            DoEvents
        End If
    Next row
    Application.StatusBar = Prefix & Format(i / list.Rows.count, "0%")
    Exit Sub
ErrHandler: 'Aby debugowa|fffd| ew. b|fffd||fffd|dy mapowania:
    If item Is Nothing Then
        Err.Raise Err.Number, "Mapper", Err.Description
    Else
        Err.Raise Err.Number, "Mapper", GetText("MappingError", item.Id, Err.Description)
    End If
End Sub

'Eksport danych ze skoroszytu do przypisanego dokumentu XML.
'Zwraca True gdy si|fffd| uda|fffd|o
Sub Export()
  Dim item As MappedField
  On Error GoTo ErrHandler
  For Each item In myFields
    item.Export
  Next item
  Exit Sub
ErrHandler:
    Dim msg As String
    If item Is Nothing Then
        If Err.Number <> 0 Then Err.Raise Err.Number, Err.Source, Err.Description 'Przeka|fffd| dalej
    Else
        If Err.Number <> 0 Then 'czy podczas przetwarzania wyst|fffd|pi|fffd| b|fffd||fffd|d?
            ShowCell item.cell 'Zaznacz na arkuszu pole, kt|fffd|re spowodowa|fffd|o b|fffd||fffd|d.
            MsgBox GetText("ExportFailed", Err.Description), vbCritical, GetText("UnexpectedError")
            Err.Raise vbObjectError, "Mapper", msg 'Przeka|fffd| dalej, ale tylko do wy|fffd|wietlenia w pasku stanu
        End If
    End If
End Sub
'Import danych z przypisanego dokumentu XML.
'Zwraca True, gdy si|fffd| uda|fffd|o
Sub Import()
  Dim item As MappedField
  Dim CalculatedFields As New Collection 'Kolekcja p|fffd|l znalezionych w danych wej|fffd|ciowych, kt|fffd|re w naszej definicji maj|fffd| domy|fffd|ln|fffd| formu|fffd||fffd|
  For Each item In myFields
    If item.Id = "w2457" Then
        Debug.Print item.Id
    End If
    item.Import CalculatedFields
  Next item
  'Zapamietujemy oryginalne, odczytane z pliku warto|fffd|ci dla ka|fffd|dego z p|fffd|l, w kt|fffd|rych mamy domy|fffd|lne formu|fffd|y, i wstawiamy na to miejsce formu|fffd|y:
  Dim ImportedValues As New Collection 'Zwr|fffd||fffd| uwag|fffd|, |fffd|e wstawiamy formu|fffd|y tylko tam, gdzie w pliku wej|fffd|ciwowym by|fffd|y JAKIE|fffd| dane.
  For Each item In CalculatedFields
    ImportedValues.Add item.cell.value, item.Id
    item.ResetExcelField PartialReset:=False, UseDefaults:=True 'Wstawiamy na miejsce warto|fffd|ci domy|fffd|ln|fffd| formu|fffd||fffd|
  Next item
  Application.CalculateFull 'Przeliczamy ca|fffd|o|fffd||fffd| (aby formu|fffd|y uzyska|fffd|y warto|fffd|ci)
  'Odrzucamy formu|fffd|y, kt|fffd|re daj|fffd| inny rezultat ni|fffd| warto|fffd||fffd| oryginalnie odczytana z pliku:
  For Each item In CalculatedFields
    Dim importedVal, overwrite As Boolean
    importedVal = ImportedValues(item.Id)
    Select Case item.DataType
        Case "Kwota":
            If IsNumeric(item.cell.value) And IsNumeric(importedVal) Then
                overwrite = Abs(item.cell.value - importedVal) >= 0.01
            Else
                overwrite = (item.cell.value <> importedVal)
            End If
        Case Else
            overwrite = (item.cell.value <> importedVal)
    End Select
    If overwrite Then
        Debug.Print "Wynik formu|fffd|y w polu " & item.Id & " ('" & item.cell.value; "') zosta|fffd| zastapiony oryginaln|fffd| warto|fffd|ci|fffd| ('" & importedVal & "')"
        item.cell.value = importedVal
        Application.Calculate 'Ta warto|fffd||fffd| mo|fffd|e wp|fffd|yn|fffd||fffd| na inne
    End If
  Next item
End Sub
'Dodaje atrybuty @mapped, o warto|fffd|ci MappedField.Id, do do ka|fffd|ego zamapowanego w|fffd|z|fffd|a powi|fffd|zanego dokumentu XML
Sub MarkDocumentNodes()
  Dim item As MappedField
  For Each item In myFields
    item.MarkNode
  Next item
End Sub
'Pomocnicza funkcja: wyszukuje najbli|fffd|szy zamapowany w|fffd|ze|fffd| do podanego w|fffd|z|fffd|a XML
'Argumenty:
'   node: sprwdzamy ten w|fffd|ze|fffd| i jego kolejnych "rodzic|fffd|w" (IXMLDOMNode)
'Funkacja szuka pierwszego elementu o atrybucie "mapped", i zwraca jego warto|fffd||fffd| lub Empty, gdy niczego nie znalaz|fffd|a
Private Function FindMarkAttribute(ByVal node As Object)
    Dim att As Object 'IXMLDOMNode
    FindMarkAttribute = Empty
    If node Is Nothing Then Exit Function
    If node.NodeType = NODE_DOCUMENT Then Exit Function 'koniec hierarchii - niczego nie znale|fffd|li|fffd|my
    If node.NodeType = NODE_ELEMENT Then
        Set att = node.SelectSingleNode("@mapped")
        If att Is Nothing Then
            FindMarkAttribute = FindMarkAttribute(node.ParentNode)
        Else
            FindMarkAttribute = att.text
        End If
    Else
        FindMarkAttribute = FindMarkAttribute(node.ParentNode)
    End If
End Function
'Pomocnicza funkcja: wyszukuje w|fffd|r|fffd|d znalezionych, ale usuni|fffd|tych mapowa|fffd| pierwszej kom|fffd|rki zwi|fffd|zanej z w|fffd|z|fffd|em o podanej nazwie
'Argumenty:
'   SoughtName: nazwa bazowa poszukiwanego w|fffd|z|fffd|a (np. "InformacjaDodatkowa")
'Zwraca Id takiego pola, je|fffd|eli zosta|fffd|o znalezione, lub Empty
Private Function FindAmongRemovedFields(ByVal SoughtName As String)
    Dim Fld As MappedField, result
    result = Empty
    For Each Fld In myFields
        If Fld.node.ParentNode Is Nothing Then  'Tylko usuni|fffd|te w|fffd|z|fffd|y!
            If Fld.node.BaseName = SoughtName Or (Len(SoughtName) >= 2 And InStr(Fld.AncestorName, SoughtName) > 0) Then 'SoughtName > 2 znaki, bo czasami jest to litera "A", "B", "C", - i trafia na fragment jakiej|fffd| d|fffd|u|fffd|szej nazwy pola.
               result = Fld.Id
               Exit For
            End If
        End If
    Next Fld
    FindAmongRemovedFields = result
End Function

'Podaje id poprzedniego wiersza mapowania, w stosunku do odanego id
'Argumenty:
'   id: identyfikator mapowania (MappedField) - np. "w345"
'UWAGA: obliczone w ten spos|fffd|b id mo|fffd|e NIE istnie|fffd| - to tylko pr|fffd|ba
'Pomocnicza funkcja, dodana wy|fffd||fffd|cznie dla wi|fffd|kszej czytelno|fffd|ci kodu
Private Function PrevId(ByVal Id As String) As String
    PrevId = Left(Id, 1) & (CInt(Mid(Id, 2)) - 1)
End Function
'Podaje id nast|fffd|pnego wiersza mapowania, w stosunku do odanego id
'Argumenty:
'   id: identyfikator mapowania (MappedField) - np. "w345"
'UWAGA: oblicozne w ten spos|fffd|b id mo|fffd|e NIE istnie|fffd| - to tylko pr|fffd|ba
'Pomocnicza funkcja, dodana wy|fffd||fffd|cznie dla wi|fffd|kszej czytelno|fffd|ci kodu
Private Function NextId(ByVal Id As String) As String
    NextId = Left(Id, 1) & (CInt(Mid(Id, 2)) + 1)
End Function
'Funkcja pr|fffd|buje wyszuka|fffd| w li|fffd|cie zamapowanych element|fffd|w element o podanym id.
'Argumenty:
'   id:     identyfikato mapowania (np. "w345" - warto|fffd||fffd| MappedField.Id)
'   text:   tekst, ktory powinen wyst|fffd|pi|fffd| w xpath mapowania elementu. UWAGA: text = "" pasuje do wszystkiego
'Zwraca True, je|fffd|eli istnieje i w nazwie zawiera podany tekst
Private Function MatchField(ByVal Id As String, ByVal text As String) As Boolean
    Dim item As MappedField
    MatchField = False 'Zak|fffd|adamy pesymistycznie
    If KeyExists(Id, myFields) Then
        Set item = myFields(Id)
        MatchField = (InStr(item.nodeName, text) > 0) 'NodeName zawiera ca|fffd|y fragment |fffd|cie|fffd|ki XPath (to zawarto|fffd||fffd| pola z kolumny 'Element docelowy' arkusza "mapowanie")
    End If
End Function
'Funkcja pr|fffd|buje znale|fffd||fffd| kom|fffd|rk|fffd| docelow|fffd| arkusza, zwi|fffd|zan|fffd| z odanym w|fffd|z|fffd|em XML
'Argumenty
'   node:               w|fffd|ze|fffd| XML (IXMLDOMNode) zwr|fffd|cony przez walidacj|fffd|: gdy b|fffd||fffd|d polega na braku w|fffd|z|fffd|a,
'                       to jest nast|fffd|pca lub rodzic brakuj|fffd|cego elementu
'   SoughtNodeName:     nazwa w|fffd|z|fffd|a, kt|fffd|rego dotyczy b|fffd||fffd|d. (Np. nazwa bazowa brakuj|fffd|cego elementu)
'Je|fffd|eli funkcja nic nie znalaz|fffd|a - zwraca Nothing
'UWAGA: funkcja opiera si|fffd| na dodatkowych atrybutach, kt|fffd|re tworzy metoda MarkDocumentNodes. Koniecznie wywo|fffd|aj t|fffd| metod|fffd| wcze|fffd|niej!
Function FindCellFor(ByVal node As Object, ByVal SoughtNodeName As String) As Range
    Dim Id, item As MappedField
    
    Set FindCellFor = Nothing
    
    Id = FindMarkAttribute(node)
    If IsEmpty(Id) Then '<node> nie jest zamapowany. To si|fffd| zdarza dla b|fffd||fffd|d|fffd|w typu "w elemencie Y brakuje elementu B"
    
        'Spr|fffd|bujmy poszuka|fffd| w bezpo|fffd|rednich elemetach potomnych wskazanego w|fffd|z|fffd|a (pomo|fffd|e to np. w przypadku braku ostatniego pola):
        Dim i As Integer
        i = node.ChildNodes.Length 'Zaczynamy szuka|fffd| od ostatniego
        While i >= 0 And IsEmpty(Id)
            Id = FindMarkAttribute(node.ChildNodes(i))
            i = i - 1
        Wend
        
        If IsEmpty(Id) Then 'Nie znale|fffd|li|fffd|my?
            '|fffd|aden bezpo|fffd|redni potomek nie jest przypisany? Spr|fffd|bujmy w takim razie poszuka|fffd| w poprzednim w|fffd|le:
            Id = FindMarkAttribute(node.PreviousSibling)
        Else 'jeden z potomk|fffd|w zasobnika jest przypisany:
            If MatchField(Id, SoughtNodeName) Then 'Nazwa elementu si|fffd| zgadza z poszukowan|fffd|?
                Set FindCellFor = myFields(Id).cell
            Else 'Je|fffd|eli znaleziony element nie nazywa si|fffd| tak samo:
                If MatchField(NextId(Id), SoughtNodeName) Then 'Mo|fffd|e nast|fffd|pne pole na arkuszu mapowania pasuje? ("KwotaA"->"KwotaB")
                    Set FindCellFor = myFields(NextId(Id)).cell
                Else 'Nie, nast|fffd|pnie nie pasuje.
                    If Not Contains("KwotaA,KwotaB,NazwaPozycji", SoughtNodeName) Then 'Je|fffd|eli to nie trywialne pole - poszukaj pierwszego usuni|fffd|tego pola o tej nazwie...
                        Dim fid
                        fid = FindAmongRemovedFields(SoughtNodeName)
                        If Not IsEmpty(fid) Then Id = fid
                    Else
                        'nie mo|fffd|emy wskaza|fffd| brakuj|fffd|cej kom|fffd|rki - u|fffd|yj znalezionego id (por. poni|fffd|ej)
                    End If
                End If
            End If
        End If
        If IsEmpty(Id) And Not Contains("KwotaA,KwotaB,NazwaPozycji", SoughtNodeName) Then 'Ostatnia szansa: poszukaj pierwszego usuni|fffd|tego pola o tej nazwie...
            Id = FindAmongRemovedFields(SoughtNodeName)
        End If
    Else '<node> jest zamapowany:
        If MatchField(Id, SoughtNodeName) Then
            Set FindCellFor = myFields(Id).cell
        'Else 'Znaleziony w|fffd|ze|fffd| nie jest bezpo|fffd|redni|fffd| przyczyn|fffd| problemu: ** 2018-12-23: poni|fffd|szy kod zast|fffd|pi|fffd|em MarkParent:
            'If MatchField(PrevId(Id), SoughtNodeName) Then 'Spr|fffd|buj sprawdzi|fffd| poprzedni element - mo|fffd|e pasuje?
            '    Set FindCellFor = myFields(PrevId(Id)).cell
            'Else
            '    If MatchField(PrevId(PrevId(Id)), SoughtNodeName) Then 'Pr|fffd|bujemy jeszcze drugi poprzednik, bo np. obydwie daty w OkresOd ... OkresDo mog|fffd| by|fffd| nie wipisane
            '        Set FindCellFor = myFields(PrevId(PrevId(Id))).cell
            '    End If
            'End If
        End If
    End If
    
    
    If FindCellFor Is Nothing Then 'Nie znaleziono danej kom|fffd|rki
        If Not IsEmpty(Id) Then 'Trudno, gdy znaleziono jak|fffd|kolwiek - wska|fffd| j|fffd| na arkuszu.
            If KeyExists(Id, myFields) Then
                Set FindCellFor = myFields(Id).cell
            End If
        End If
    End If
End Function
Attribute VB_Name = "PDF"
Option Explicit
'pomocniczy modu|fffd|, do obs|fffd|ugi zapisywania za|fffd||fffd|cznik|fffd|w PDF Excela do odr|fffd|bnego pliku.
'Standardowa przegl|fffd|darka - Adobe Acrobat - nie udostepnia obiekt|fffd|w OLE umo|fffd|liwiaj|fffd|cych zapis

'Zapisuje podany obiekt (za|fffd||fffd|cznik PDF) do wskazanego pliku
'Argumenty:
'   Obj:    za|fffd||fffd|cznik (PDF)
'   Path:   |fffd|cie|fffd|ka, pod kt|fffd|r|fffd| trzeba zapisa|fffd| ten plik
Sub SaveToFile(ByVal Obj As OLEObject, ByVal Path As String)
    Dim data() As Byte 'Bufor na dane za|fffd||fffd|cznika
    Dim pFrom As Long, pTo As Long 'Pozycje: pocz|fffd|tku i ko|fffd|ca pliku PDF w tablicy Data
    GetRawData Obj, data 'Kopiujemy "surowe" dane obiektu do tablicy Data
    
    pFrom = InStrB(data, StrConv("%PDF", vbFromUnicode)) 'Pocz|fffd|tek w|fffd|a|fffd|ciwego pliku PDF w danych obiektu
    'Ko|fffd|ca pliku szukamy w p|fffd|tli, bo tekst %%EOF mo|fffd|e si|fffd| pojawi|fffd| wi|fffd|cej ni|fffd| raz (zazwyczaj dwa razy:)
    Dim Pos As Long
    Pos = pFrom
    Do
     pTo = Pos + 5
     Pos = InStrB(pTo, data, StrConv("%%EOF", vbFromUnicode))
    Loop While Pos > 0
    'W tym momencie mamy ju|fffd| ustalone: pFrom i pTo
    'Nie zaszkodzi ma|fffd|a weryfikacja:
    If pFrom = 0 Or pTo <= (pFrom + 5) Then
        Err.Raise CriticalError, "PDF", GetText("AttachementCorrupted", GetFileName(Path))
    End If
    If FileExists(Path) Then Kill Path 'Mia|fffd|em problemy z flagami ADOStream.SaveToFile, nie mog|fffd|em w tamtej procedurze wymusi|fffd| nadpisywania
    Stream.BinaryToFile data, Path, pFrom - 1, pTo - pFrom
End Sub
Attribute VB_Name = "Reconciliation"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
'Klasa reprezentuje pojedynczy wiersz uzgodnienia (tzn. uzgodnienie jednej, dw|fffd|ch lub trzech kom|fffd|rek z jakiego|fffd| zestawienia)
'Pomocnicza, dodana do obs|fffd|ugi ostrze|fffd|e|fffd| o wewn|fffd|trznej niezgodno|fffd|ci wybranych kwot.
'Podstawow|fffd| kom|fffd|rk|fffd| "odniesienia" do wszystkich pozosta|fffd|ych jest kom|fffd|rka "flagi", w kt|fffd|rej formu|fffd|a wy|fffd|wietla znak "!" lub "=".
'Po|fffd|o|fffd|enie wszystkich pozosta|fffd|ych kom|fffd|rek jest okre|fffd|lane poprzez offsety (patrz sta|fffd|e poni|fffd|ej) w stosunku do tej kom|fffd|rki

Private Const FirstDataFieldOfs = -4 'Domy|fffd|lny offset do pierwszego (tj. lewego) pola z danymi
Private Const LabelFieldOfs = 1 'Offset do etykiety p|fffd|l referencyjnych
Private Const FirstDiffFieldOfs = 6 'Offset do pierwszego pola z warto|fffd|ciami r|fffd|nic.
Private Const OffsToOffs = 9        'Offset do ewentualnych p|fffd|l z indywidualnym offsetem do pola danych

Private myFlag As Range 'Kom|fffd|rka wy|fffd|wietlaj|fffd|ca "!" lub "=". Przypisywana podczas inicjalizacji
'Inicjalizacja klasy
'Argumenty:
'   FlagCell:   kom|fffd|rka, zawieraj|fffd|ca "flag|fffd|" wiersza (o warto|fffd|ci "!" lub "=")
Sub Initialize(ByVal FlagCell As Range)
    Set myFlag = FlagCell
End Sub
'Zwraca jedno z p|fffd|l offsetu do danych
'Argumenty:
'   Index:  indeks pola: 0: okres bie|fffd||fffd|cy, 1: okres poprzedni, 2: przekszta|fffd|cone dane por|fffd|wnawcze
'UWAGA: gdy Index jest < 0 - zamieniamy na 0
Private Function OffsField(ByVal Index As Integer) As Range
    If Index < 0 Then Index = 0
    Set OffsField = myFlag.Offset(ColumnOffset:=OffsToOffs + Index)
End Function
'Zwraca jedno z p|fffd|l danych (tzn. tych odbezpieczonych, z zestawienia dla u|fffd|ytkownika, po lewej)
'Argumenty:
'   Index:  indeks pola: 0: okres bie|fffd||fffd|cy, 1: okres poprzedni, 2: przekszta|fffd|cone dane por|fffd|wnawcze
'UWAGA: gdy Index jest < 0 - zamieniamy na 0
Private Function DataField(ByVal Index As Integer) As Range
    Dim offs As Range
    If Index < 0 Then Index = 0
    Set offs = OffsField(Index)
    If IsEmpty(offs) Then 'Domy|fffd|lne po|fffd|o|fffd|enie danych
        Set DataField = myFlag.Offset(ColumnOffset:=FirstDataFieldOfs + Index)
    Else
        Set DataField = myFlag.Offset(ColumnOffset:=offs.value)
    End If
End Function

'Zwraca jedno z p|fffd|l r|fffd|nic (tych ukrytych, obliczanych)
'Argumenty:
'   Index:  indeks pola: 0: okres bie|fffd||fffd|cy, 1: okres poprzedni, 2: przekszta|fffd|cone dane por|fffd|wnawcze
'UWAGA: gdy Index jest < 0 - zamieniamy na 0
Private Function DiffField(ByVal Index As Integer) As Range
    If Index < 0 Then Index = 0
    Set DiffField = myFlag.Offset(ColumnOffset:=FirstDiffFieldOfs + Index)
End Function

'Zwraca kom|fffd|rk|fffd| z etykiet|fffd| tego warunku (po prawej od flagi)
Private Function Label() As Range
    Set Label = myFlag.Offset(ColumnOffset:=LabelFieldOfs)
End Function
'Zwraca indeks pierwszej kom|fffd|rki z r|fffd|nic|fffd| (0, 1 lub 2)
'lub -1, gdy wszystkie pola s|fffd| zgodne
Private Function FirstDifference() As Integer
    Dim i As Integer
    FirstDifference = -1 'Poczatkowo zak|fffd|adamy, |fffd|e wszystko si|fffd| zgadza
    For i = 0 To 2
        Dim Val
        Val = DiffField(i)
        If IsEmpty(Val) Or VBA.Round(Val, 2) = 0 Then
            'continue
        Else
            If FirstDifference < 0 Then FirstDifference = i 'Je|fffd|eli to pierwsza znaleziona r|fffd|nica:
        End If
    Next i
End Function
'Funkcja zaznacza pole danych (albo zwi|fffd|zane z niezgodno|fffd|ci|fffd|, a je|fffd|eli jej nie ma - pierwsze od lewej)
Sub SelectFirstDifference()
    Dim idx As Integer
    idx = FirstDifference
    ShowCell DataField(idx)
End Sub
'Funkcja wy|fffd|wietla komunikat o pierwszej niezgodno|fffd|ci w wierszu (bo mo|fffd|e by|fffd| ich wi|fffd|cej)
Sub DisplayMessage()
    Dim flg
    flg = myFlag.value
    If IsEmpty(flg) Or flg = "=" Then
        'nic nie wy|fffd|wietlaj - to jakie|fffd| nieporozumienie
    Else
        MsgBox GetText("ReconcDifference", Format(DiffField(FirstDifference), "# ##0.00"), Label())
    End If
End Sub
Attribute VB_Name = "Registry"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

'Pomocnicza klasa do czytania zawarto|fffd|ci rejestru
Private myWS As Object 'WScript.Shell

Private Sub Class_Initialize()
    Set myWS = CreateObject("WScript.Shell") 'W razie problem|fffd|w z inicjacja tego obiektu ta funkcja wygeneruje wyj|fffd|tek
End Sub

'W|fffd|a|fffd|ciwo|fffd|ci dla |fffd|atwiejszego podawania Root (stworzy|fffd|em je tylko dlatego, |fffd|e w klasach nie ma Public Const):
Property Get HKCU() As String
    HKCU = "HKEY_CURRENT_USER"
End Property

Property Get HKLM() As String
    HKLM = "HKEY_LOCAL_MACHINE"
End Property

Property Get HKCR() As String
    HKCR = "HKEY_CLASSES_ROOT"
End Property

Property Get HK_USERS() As String
    HK_USERS = "HKEY_USERS"
End Property

Property Get HK_CURRENT_CONFIG() As String
    HK_CURRENT_CONFIG = "HKEY_CURRENT_CONFIG"
End Property

'Zwraca warto|fffd||fffd| podanego klucza. Gdy nie istnieje/nie mo|fffd|e go odczyta|fffd| - zwraca Empty
'Argumenty:
'   Root:           jedna z pi|fffd|ciu sta|fffd|ych H*, przypisanych do tej klasy
'   Key:            reszta poszukiwanej |fffd|cie|fffd|ki
'   DefaultValue:   ustaw na True, gdy Key to jest klucz, dla kt|fffd|rego chcesz okre|fffd|li|fffd| warto|fffd||fffd| domy|fffd|ln|fffd|
'                   Dodany dla wi|fffd|kszej przejrzysto|fffd|ci kodu. Alternatywnie: mo|fffd|esz zako|fffd|czy|fffd| Key "\"
Function Read(ByVal root As String, Key As String, Optional ByVal DefaultValue = False) As Variant
  On Error Resume Next
  'read key from registry
  Read = myWS.RegRead(root & "\" & Key & IIf(DefaultValue, "\", "")) 'Aby odczyta|fffd| warto|fffd||fffd| domy|fffd|ln|fffd|, klucz musi by|fffd| zako|fffd|czony "\"
  If Err.Number <> 0 Then Read = Empty
  Err.Clear
End Function

'Zwraca True gdy RegKey istnieje, False w przeciwnym razie
'Argumenty:
'   Root:   jedna z pi|fffd|ciu sta|fffd|ych H*, przypisanych do tej klasy
'   Key:    reszta poszukiwanej |fffd|cie|fffd|ki
'   DefaultValue:   ustaw na True, gdy Key to jest klucz, dla kt|fffd|rego chcesz okre|fffd|li|fffd| warto|fffd||fffd| domy|fffd|ln|fffd|
'                   Dodany dla wi|fffd|kszej przejrzysto|fffd|ci kodu. Alternatywnie: mo|fffd|esz zako|fffd|czy|fffd| Key "\"
Function Exists(ByVal root As String, Key As String, Optional ByVal DefaultValue = False) As Boolean
    Exists = Not IsEmpty(Read(root, Key, DefaultValue))
End Function

Attribute VB_Name = "ReportDef"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
'Klasa z definicj|fffd| raportu (w zale|fffd|no|fffd|ci od sposobu inicjalizacji mo|fffd|e dotyczy|fffd|: albo aktualnego formularza,
'albo importowanego dokumentu)
'S|fffd|u|fffd|y m.in. do zarz|fffd|dzania wygl|fffd|dem raportu (widoczno|fffd|ci|fffd| poszczeg|fffd|lnych kontrolek i obszar|fffd|w na arkuszach)
'ale tak|fffd|e do dostaczenia w|fffd|a|fffd|ciwego wzorca dokumentu do wype|fffd|niania, lub do sprawdzania importowanego raportu,
'(zanim cokolwiek ulegnie zmianie w skoroszycie).
Private Const SF_NamespaceName = "SF_Namespace" 'Nazwa obszaru z szablonem url dla namespace
Private Const SF_XSD_Name = "XSD" 'Nazwa obszaru z szablonem URL schemy
Private Const XPathKodSprawozdania = "./*[local-name()='Naglowek']/*[local-name()='KodSprawozdania']/@kodSystemowy"
Private Const SelectedVariantName = "NumerWariantuRaportu" 'Pole z numerem wybranego w Nag|fffd||fffd|wku typu raportu
Private Const SelectedBaseName = "NumerBazyRaportu" 'Pole z numerem wybranej w Nag|fffd||fffd|wku bazy raportu
Private Const VariantListName = "ListaWariantowRaportow" 'definicje obs|fffd|ugiwamych typ|fffd|w raport|fffd|w
Private Const AmountBasesName = "BazyKwot" 'Lista definicji baz kwoty (w tysi|fffd|cach z|fffd|otych czy w z|fffd|otych)
Private Const NamespaceListName = "DetaleWeryfikacji" 'Lista z przestrzeniami nazw (w przysz|fffd|o|fffd|ci tak|fffd|e z XSD)
Private Const ReportVariantName = "WariantRaportuDropdown" 'Lista wariant|fffd|w raport|fffd|w
Private Const ControlLabelsName = "EtykietyObiektow" 'Lista lokalnych nazw (etykiet) kontrolek arkusza "Nag|fffd||fffd|wek"

Private Const CNSPrefix = 2 'W 2 kolumnie danych weryfikacji XML s|fffd| przedrostki przestrzeni nazw
Private Const CNSName = 3 'W 3 klumnie s|fffd| warto|fffd|ci odp. namespaces.
Private Const ExListName = "ReportDefHints" 'Lista wyj|fffd|tkami dla warto|fffd|ci zwracanych przez Info()
Private Const CExHint = 1 'W pierwszej kolumnie s|fffd| nazwy (grup) wyj|fffd|tk|fffd|w
Private Const CExVariant = 2 'W drugiej kolumnie s|fffd| id wariantu raportu, lub "default" gdy chodzi o wszystkie
Private Const CExAbout = 3 'W trzeciej kolumnie jest s|fffd|owo kluczowe (argument wywo|fffd|ania Info())
Private Const CExValue = 4 ' W czwartej kolumnie jest warto|fffd||fffd|, jak|fffd| ma zwr|fffd|ci|fffd| Inf()

Private Const SectionListName = "EtykietyArkuszy" 'lista arkuszy z kt|fffd|rych maj|fffd| by|fffd| tworzone sekcje raportu
Private Const ConsolidatedReportId = 5 'Numer raportu skonsolidowanego (wymaga specyficznego traktowania)

Private mySrc As Range 'Wiersz, opisuj|fffd|cy ten typ raportu
Private myABase As Range 'Wiersz z definicj|fffd| u|fffd|ywanej bazy kwot
Private myDoc As Object '(DOMDocument60) 'dokument XML (mo|fffd|e by|fffd| Nothing dla defnicji utworzonej na podstawie stanu skoroszytu)
Private mySections As Collection 'Kolekcja sekcji ("Nag|fffd||fffd|wek", "Wprowadzenie, "Bilans", "RZiS", ..) - ka|fffd|da odpowiada jednemu arkuszowi
Private myMap As Mapper 'mapowanie p|fffd|l - wykorzystywane podczas importu
Private myHints As Collection 'Kolekcja kolekcji: About -> Hint -> <Jednostka>|"default" -> warto|fffd||fffd| (wykorzystywana przez metod|fffd| Info())

'Pola definicji warantu raportu:
'* pierwsze 4 kolumny takie same w myABase i mySrc*
Private Const CPos = 1 'Nr kolejny
Private Const CValue = 2 'Warto|fffd||fffd| (symbol wariantu)
Private Const CLabel = 3 'Etkieta
Private Const CCode = 4 'Przedrostek kodu formularza (np. SFJMI)
Private Const CMaxOptions = 5 'nr kolumny z maksymaln|fffd| liczb|fffd| dost|fffd|pnych alternatyw sekcji
'Pomocnicza funkcja: zwraca obszar z definicj|fffd| raportu o podanym kodzie,
'lub wywo|fffd|uje b|fffd||fffd|d z odpowiednim komunikatem (i zwraca Nothing), je|fffd|eli obs|fffd|uga nie jest mo|fffd|liwa (np. ze wzgl|fffd|du na licencj|fffd|).
'Argumenty:
'   Code:   Tekst, np. "SFJMI", albo "SFSIN"
'UWAGA: zak|fffd|adam, |fffd|e b|fffd|dzie ZAWSZE wywo|fffd|ywana podczas wczytywania raportu - czyli z arkusza Nag|fffd||fffd|wek! (Bo robi|fffd| odwo|fffd|anie do ActiveSheet)
Private Function GetReportDef(ByVal Code As String) As Range
    Dim src As Range 'obszar z definicj|fffd| raportu
    Set src = FindOnList(Code, Range(VariantListName), CCode) 'Najpierw spr|fffd|buj znale|fffd||fffd|, czy w og|fffd|le obs|fffd|ugujemy ten typ raportu
    If src Is Nothing Then
        Err.Raise CriticalError, "ReportDef", GetText("WrongReportSymbol", Code)
    Else 'Obs|fffd|ugiwa|fffd| w og|fffd|le to obs|fffd|ugujemy, ale trzeba sprawdzi|fffd|, czy w tym skoroszycie:
        Dim nr, ThisName As String
        nr = src.cells(CPos) 'numer, jaki typ wczytywanego raportu ma na naszej li|fffd|cie
        ThisName = src.cells(CValue) 'Nazwa tego typu
        If ActiveSheet.cells(1, 1) = "Nag|fffd||fffd|wek" Then 'Etykieta arkusza mo|fffd|e by|fffd| zmieniona, pr|fffd|buj|fffd| rozpoznac nag|fffd||fffd|wek po ukrytym polu...
            Dim Header As Section, VariantDropdown As shape, VariantList As Range
            Set VariantDropdown = ActiveSheet.Shapes(ReportVariantName)
            Set VariantList = Range(VariantListName)
            If Not VariantDropdown.Visible Then 'Mo|fffd|na wczyta|fffd| tylko jeden typ raportu - aktualny
                Dim CurNr
                CurNr = Range(SelectedVariantName).value 'Numer aktualnie ustawionego raportu
                If nr = CurNr Then
                    Set GetReportDef = src
                    Exit Function
                Else 'Wyja|fffd|nij b|fffd||fffd|d:
                    Dim CurName As String
                    CurName = VariantList.Rows(CurNr).cells(CValue)
                    Err.Raise CriticalError, "ReportDef", GetText("ReportTypeNotHandled", ThisName, CurName)
                End If
            Else 'Nale|fffd|y sprawdzi|fffd|, czy ten wariant jest aktualnie udost|fffd|pniony na li|fffd|cie rozwijalnej
                Dim row As Range, CurNames As String, i As Integer
                CurNames = ""
                For i = 1 To Range(VariantDropdown.DrawingObject.ListFillRange).Rows.count
                    Set row = VariantList.Rows(i) 'ListFillRange kontrolki zwiera tylko jedn|fffd| kolumn|fffd| tej listy - nie mo|fffd|emy z niego bezpo|fffd|rednio czyta|fffd|...
                    If row.cells(CCode) = Code Then 'Znale|fffd|li|fffd|my!
                        Set GetReportDef = src
                        Exit Function
                    Else 'sk|fffd|adamy nazwy dopuszczalnych typ|fffd|w...
                        If CurNames <> "" Then CurNames = CurNames & "','"
                        CurNames = CurNames & row.cells(CValue)
                    End If
                Next i
                'Tu dojdziemy tylko wtedy, gdy nie znale|fffd|lismy tego typu:
                Err.Raise CriticalError, "ReportDef", GetText("ReportTypeNotHandled", ThisName, CurNames)
            End If
        Else 'Hmm - funkcja wywo|fffd|ana na innym arkuszy ni|fffd| "Nag|fffd||fffd|wek"! No trudno, lepiej przepu|fffd|ci|fffd| ni|fffd| wywali|fffd| si|fffd| z b|fffd||fffd|dem:
            Set GetReportDef = src
        End If
    End If
End Function
'Prywatna funkcja: zwraca numer wersji plik|fffd|w XSD, jakimi dysponuje skoroszyt
'Dodana dla wi|fffd|kszej przejrzysto|fffd|ci kodu
Private Function CurrentXSDVersion() As String
    CurrentXSDVersion = Split(Info("wersjaSchemy", "extra"), ",")(0)
End Function
'Inicjalizacja obiektu: (nadanie warto|fffd|ci wewn|fffd|trznym zmiennym: niczego nie zmienia na arkuszu)
'Argumenty:
'   ReportNumber: [opcjonalny] numer wybranego raportu (gdy tworzymy definicj|fffd| "z powietrza")
'   xml:          [opcjonalny] wczytywany raport (gdy importujemy nowy dokument) (MSXML2.DOMDocument60)
'Gdy nie importujemy dokumentu, xml jest Nothing.
'Gdy nie podasz |fffd|adnego z argument|fffd|w - definicja jest tworzona dla wariantu raportu aktualnie wybranego w arkuszu "Nag|fffd||fffd|wek"
Sub Initialize(Optional ReportNumber, Optional ByVal xml As Object = Nothing)
    Dim list As Range
    Dim Pos As Integer
    
    Set myHints = GetHints 'Aby funkcja Info() od razu mog|fffd|a dzia|fffd|a|fffd|.
    
    If xml Is Nothing Then 'Identyfikujemy struktur|fffd| na podstawie ustawe|fffd| skoroszytu
        If IsMissing(ReportNumber) Then
            Pos = Range(SelectedVariantName).value
        Else
            Pos = ReportNumber
        End If
        Set list = Range(VariantListName)
        If Pos > 0 And Pos <= list.Rows.count Then
            Set mySrc = list.Rows(Pos)
        Else
            Err.Raise CriticalError, "ReportDef", GetText("WrongReportNumber", Pos, list.Rows.count)
        End If
        Pos = Range(SelectedBaseName).value
        Set list = Range(AmountBasesName)
        If Pos > 0 And Pos <= list.Rows.count Then
            Set myABase = list.Rows(Pos)
        Else
            Err.Raise CriticalError, "ReportDef", GetText("WrongBaseNumber", Pos, list.Rows.count)
        End If
        
        Set mySections = GetSections
        
    Else '<ReportDesc> musi w takim razie by|fffd| podany:
        Dim Code As Object 'IXMLDOMAttribute
        Set Code = xml.DocumentElement.SelectSingleNode(XPathKodSprawozdania)
        If Code Is Nothing Then
            Err.Raise CriticalError, "ReportDef", GetText("WrongReportFormat")
        Else 'code.text to tekst w rodzaju "SFJMIZ (1)"
            Dim text As String
            'Do sprawdzania typu raportu b|fffd|dzimy potrzebowali list|fffd| sekcji:
            
            'Sprawd|fffd| najpierw, czy ten arkuz obs|fffd|uguje ten typ raportu:
            text = Left(Code.text, 5) 'przedrostek symbolu: np. "SFJMI"
            'Ocena, czy ten skoroszyt mo|fffd|e wczyta|fffd| plik o wskazanym kodzie:
            
            'Set mySrc = FindOnList(text, Range(VariantListName), CCode)
            'If mySrc Is Nothing Then Err.Raise CriticalError, "ReportDef", GetText("WrongReportSymbol", text)
            Set mySrc = GetReportDef(text) 'Ta linia mo|fffd|e wywo|fffd|a|fffd| b|fffd||fffd|d z odpowiednim komunikatem
            
            text = Mid(Code.text, 6, 1) 'Ostatni znak symbolu: "T" (ysi|fffd|ce) lub "Z"(|fffd|ote)
            Set myABase = FindOnList(text, Range(AmountBasesName), CCode)
            If myABase Is Nothing Then Err.Raise CriticalError, "ReportDef", GetText("WrongBaseSymbol", text)
            
            'Przygotowujemy ten dokument do dalszej "obr|fffd|bki" naszymi XPATH:
            AppendSearchNamespaces xml
            
            Set myMap = New Mapper
            myMap.Initialize xml 'B|fffd|dziemy potrzebowa|fffd| tej mapy do pod|fffd|wietlania p|fffd|l z b|fffd||fffd|dami
            
            If ValidateXML(xml, myMap, Me, Visualize:=False, ImportMode:="Import", _
                                    CurXSDVer:=CurrentXSDVersion()) = False Then Exit Sub 'Walidacja si|fffd| nie powiod|fffd|a...
                                   
            Set myDoc = xml

            'Aktualizujemy list|fffd| sekcji:
            Dim node As Object 'IXMLDOMNode
            Set mySections = GetSections 'W chwili pocz|fffd|tkowej ka|fffd|da z nich ma ustawienia domyslne dla danego typu raportu
            For Each node In myDoc.DocumentElement.ChildNodes '"dzie|fffd|mi" elementu g|fffd||fffd|wnego s|fffd| elementy kolejnych sekcji
                If node.NodeType = NODE_ELEMENT Then 'Spr|fffd|bujmy zidentyfikowa|fffd| t|fffd| sekcj|fffd|:
                  Dim sec As Section
                  For Each sec In mySections
                    If sec.MatchNode(node, Me.Info("Jednostka"), Me.Info("MaxOpcji")) Then Exit For  'Niezale|fffd|nie od wyniku, ta procedura resetuje Section.myVariant i Section.mySubelement (mog|fffd| sta|fffd| si|fffd| Nothing)
                  Next sec
                End If
            Next node
            'UWAGA: cz|fffd||fffd| sekcji jest opcjonalna, i ta mo|fffd|e nie by|fffd| zamapowana, gdy dokument |fffd|r|fffd|d|fffd|owy nie zawiera ich w|fffd|z|fffd||fffd|w
            'W zwi|fffd|zku z tym |fffd|e ostatnia sekcja jest obowi|fffd|zkowa,
        End If
    End If
End Sub
'Pomocnicza funkcja, zamieniaj|fffd|ca szablon wyra|fffd|enia w ostateczne wyra|fffd|enie
Private Function UpdateURL(ByVal Template As String) As String
    Dim text As String
    text = Template
    text = Replace(text, "{jednostka}", Info("Jednostka"))
    text = Replace(text, "{baza}", Info("BazaKwot"))
    UpdateURL = text
End Function
'Zwraca |fffd|cie|fffd|k|fffd| do pliku XSD
Public Property Get XSD() As String
    XSD = UpdateURL(Range(SF_XSD_Name))
End Property
'Zwraca przestrze|fffd| nazw tej definicji raportu
Public Property Get namespace() As String
    namespace = UpdateURL(Range(SF_NamespaceName))
End Property
'Pomocnicza funkcja: dodaje do dokumentu przestrzenie nazw do wyszukiwania XPath
'Argumenty:
'   doc:    dokument XML, do kt|fffd|rego nale|fffd|y dodac przestrzenie nazw. (DOMDocument60)
Private Sub AppendSearchNamespaces(ByVal doc As Object)
    Dim nspaces As String, list As Range, row As Range, text As String
    nspaces = ""
    Set list = Range(NamespaceListName)
    For Each row In list.Rows
        If IsEmpty(row.cells(CNSPrefix)) Then
            'Skip
        Else
            If Len(nspaces) > 0 Then nspaces = nspaces & " "
            text = row.cells(CNSName)
            text = Replace(text, "{nsPrefix}", Info("nsPrefix", "extra"))
            text = Replace(text, "{jednostka}", Info("Jednostka", "xmlns"))
            text = Replace(text, "{baza}", Info("BazaKwot"))
            nspaces = nspaces & "xmlns:" & row.cells(CNSPrefix) & "='" & text & "'"
        End If
    Next row
    
    doc.setProperty "SelectionNamespaces", nspaces
End Sub
'Pomocnicza funkcja: tworzy list|fffd| "sekcji" - arkuszy, bior|fffd|cych udzia|fffd| w tworzeniu XML-a
'Obudowa|fffd|em ka|fffd|dy z nich klas|fffd| Section i zwracam w postaci kolekcji o kluczu niezmienne Id arkusza.
'Pocz|fffd|tkowo ka|fffd|da z nowo utworzonych sekcji jest ustwiona na wariant domy|fffd|lny dla danego arkusza (i wariantu dokumentu)
Private Function GetSections() As Collection 'Kolekcja sekcji (klucz: id, czyli teksty: "Nag|fffd||fffd|wek", "Wprowadzenie", "Bilans", ...)
    Dim list As Range, row As Range, result As New Collection
    Dim sec As Section
    Set list = Range(SectionListName)
    For Each row In list.Rows
        If IsEmpty(row.cells(1, 1)) Then
            ' pomi|fffd|
        Else
            Set sec = New Section
            If sec.Initialize(row, mySrc) Then 'Inicjalizacja mo|fffd|e si|fffd| nie uda|fffd|, gdy odp. arkusz nie istnieje w skoroszycie (np. "Dodatkowe" w Skonsolidowanym)
                result.Add sec, sec.Id
            End If
        End If
    Next row
    Set GetSections = result
End Function
'Pomocnicza metoda u|fffd|ywana w GetHints: sprawdza, czy kolekcja <Col> zawiera element o kluczu <Key>
'Je|fffd|eli nie - dodaje do Col nowy element (kolekcj|fffd|), przypisan|fffd| do klucza <Key>
'Argumenty:
'   Key: poszukiwnay klucz
'   Col: sprawdzana kolekcja
Private Sub EnsureSubcollection(ByVal Key, ByVal Col As Collection)
    Dim subcol As Collection
    If Not KeyExists(Key, Col) Then
        Set subcol = New Collection
        Col.Add subcol, Key
    End If
End Sub
'Zwraca list|fffd| wyj|fffd|tk|fffd|w warto|fffd|ci zwracanych przez funkcj|fffd| Info()
'(dodana dla wi|fffd|kszej czytelno|fffd|ci kodu)
Private Function GetHints() As Collection
    Dim src As Range, result As New Collection
    Dim About, Hint, RepId, Val 'Pola aktualnej definicji
    
    For Each src In Range(ExListName).Rows
        Hint = src.cells(CExHint)
        If Not IsEmpty(Hint) Then
            RepId = src.cells(CExVariant)
            About = src.cells(CExAbout)
            Val = src.cells(CExValue)
            EnsureSubcollection About, result
            EnsureSubcollection Hint, result(About)
            result(About)(Hint).Add Val, RepId
        End If
    Next src
    Set GetHints = result
End Function
'Przestawia wygl|fffd|d arkuszy skoroszytu na taki, jak jest zapisany w tej definicji
Sub ApplyToLayout()
    'Wyb|fffd|r w|fffd|a|fffd|ciwego warantu raportu i bazy kwot:
    BeginCriticalSection 'Na wszelki wypadek - zmiana wariantu raportu zapewne wywo|fffd|uje obs|fffd|ug|fffd| zdarzenia - przestawi go na ustawienia domy|fffd|lne
        Range(SelectedVariantName).value = mySrc.cells(CPos)
        Range(SelectedBaseName).value = myABase.cells(CPos)
    EndCriticalSection
   
    'Przestawienie sekcji:
    Dim sec As Section
    For Each sec In mySections
        sec.ApplyToSheet mySrc.cells(CMaxOptions), mySrc.cells(CPos)  'Zmieniamy widoczno|fffd||fffd| element|fffd|w arkusza na takie, jakie opisuje sekcja
    Next sec
End Sub
'Odczytuje stan definicji z aktualnego stanu skoroszytu
Sub ReadFromLayout()
    Dim Pos As Integer, list As Range
    Dim sec As Section
    
    'Sprawa dotyczy sekcji, gdy|fffd| konstruktor tego obiektu powninen by|fffd| wywo|fffd|any w wersji bez dokumentu XML
    Pos = Range(SelectedVariantName).value
    Set list = Range(VariantListName)
    
    If Pos > 0 And Pos <= list.Rows.count Then
        Set mySrc = list.Rows(Pos)
    Else
        Err.Raise CriticalError, "ReportDef", GetText("WrongReportNumber", Pos, list.Rows.count)
    End If
    
    For Each sec In mySections
        sec.ReadFromSheet 'Odczytujemy stan sekcji tak, jak s|fffd| w tej chwili ustawione na arkuszach
    Next sec
End Sub
'Pomocnicza funkcja: zwraca informacje o konfiguracji
'Argumenty:
'   About:  identyfikator informacji:
'                   "Jednostka"  - "D|fffd|ugi" symbol jednostki wariantu: ("JednostkaInna", "JednostkaMala", "JednostkaMikro", ...)
'                   "BazaKwot"   - "D|fffd|ugi" symbol bazy kwot wariantu ("WZlotych" : "WTysiacach")
'                   "MaxOpcji"   - max. liczba mo|fffd|liwych wariant|fffd|w w sekcjiach raportu (1, 2, lub 3 dla JednostkiMikro)
'                   - inne, wyst|fffd|puj|fffd|ce w li|fffd|cie ReportDefHints, dla pustego typu wyj|fffd|tku (Hint) i wariantu raportu
'   Hint:   opcjonalny: identyfikator ewentualnego kontekstu wywo|fffd|ania: np. "xmlns" je|fffd|eli zwr|fffd|cona informacja ma by|fffd|
'                       wykorzystywana do wype|fffd|nienia symboli "{}" w przestrzeniach nazw XML
Function Info(ByVal About As String, Optional ByVal Hint As String = "")
    If Hint = "" Then
        Select Case About
            Case "Jednostka": Info = mySrc.cells(CValue)
            Case "BazaKwot":  Info = myABase.cells(CValue)
            Case "MaxOpcji":  Info = mySrc.cells(CMaxOptions)
            Case Else
                Info = Empty
        End Select
    Else
        Info = Info(About) 'Warto|fffd||fffd| domy|fffd|lna: jak bez dodatkowej wskaz|fffd|wki
        If KeyExists(About, myHints) Then 'A potem sprawd|fffd|, czy nie ma na to wyjatku:
            If KeyExists(Hint, myHints(About)) Then
                Dim VarId As String
                VarId = Info("Jednostka")
                If KeyExists(VarId, myHints(About)(Hint)) Then 'Dla tej jednostki mamy wyj|fffd|tek!
                    Info = myHints(About)(Hint)(VarId)
                Else
                    If KeyExists("default", myHints(About)(Hint)) Then 'Jak nie ma specyficznego dla jednostki - to mo|fffd|e jest to jaka|fffd| warto|fffd||fffd| wsp|fffd|lna dla wszystkich?
                        Info = myHints(About)(Hint)("default")
                    End If
                End If
            End If
        End If
    End If
End Function
'Zwraca wzorzec XML dokumentu (do wype|fffd|nienia podczas zapisu)
Property Get xml() As Object 'DOMDocument60
    If myDoc Is Nothing And Not (mySections Is Nothing) Then 'Tak mo|fffd|e by|fffd| dla definicji utworzonej na podstawie stanu skoroszytu
        Dim text As String
        
        text = GetTemplate("T" & mySrc.cells(CValue) & myABase.cells(CValue)) 'Najpierw bazowa "ramka"
        
        'Potem wstawiamy do poszczeg|fffd|lnych sekcji wybrane warianty:
        Dim sec As Section
        For Each sec In mySections
            sec.InsertTemplate text, Info("Jednostka")
        Next sec
        
        Set myDoc = LoadXML(xml:=text, LoadSchema:=False)  'Bez schemy wczytuje si|fffd| szybciej
        
        If Not (myDoc Is Nothing) Then
            AppendSearchNamespaces myDoc 'Dodaje do dokumentu przedorstki przestrzeni nazw do wyszukiwania XPath.
                                       'Domy|fffd|lna ma przedrostek "sf:"
        End If
    End If
    Set xml = myDoc
End Property
'Zwraca obiekt mapowa|fffd| (potrzebny do dalszych operacji importu) - inicjowany tylko dla definicji zwi|fffd|zanych z dokuemntem XML
Property Get map() As Mapper
    Set map = myMap
End Property
'Zwraca kolekcj|fffd| sekcji raportu (obiekt|fffd|w Section)
Property Get sections() As Collection
    Set sections = mySections
End Property
'Uaktualnia etykiety kontrolek
'(wywo|fffd|ywa|fffd| po zmianie j|fffd|zyka)
Sub UpdateLabels()
    Dim sec As Section, def As Range
    'Zmiana etykiet arkuszy:
    DisableScreenUpdating DisableCalc:=True
On Error GoTo ErrHandler
    For Each sec In mySections
        sec.UpdateLabel
    Next sec
    'Zmiana etyket kontrolek w arkuszu "Nag|fffd|owek"
    Set sec = mySections("Nag|fffd||fffd|wek")
    With sec.Sheet
        For Each def In Range(ControlLabelsName).Rows
            Dim ctrlName As String, ctrlLabel As String
            ctrlName = def.cells(1)
            ctrlLabel = def.cells(2)
            .Shapes(ctrlName).DrawingObject.Caption = ctrlLabel
        Next def
    End With
    Debug.Print "before Application.Calculate: Err.Number = " & Err.Number
    Application.CalculateFull 'Aby przeliczy|fffd| tak|fffd|e pola z funkcjami VB

ErrHandler:
    EnableScreenUpdating
    If Err.Number <> 0 Then MsgBox Err.Description & vbCr & "(" & Hex(Err.Number) & ")", vbExclamation, GetText("UnexpectedError")
End Sub
Attribute VB_Name = "Schema"
Option Explicit
'Obs|fffd|uga schemat|fffd|w XSD (s|fffd| osadzone w tym dokumencie)
Private Const XSD_ListName = "DetaleWeryfikacji"
Private Const CAttName = 1 'Pierwsza kolumna: na nazw|fffd| obiektu OLE z osadzonym plikiem (mo|fffd|e by|fffd| pusta)
Private Const CNPrefix = 2 'Druga kolumna: na prefiks przestrzeni nazw (mo|fffd|e byc pusta)
Private Const CNspace = 3  'Trzecia kolumna: XML namespace

'Odczytuje z osadzonego pliku schematu (obiekt OLE) jego zawarto|fffd||fffd|
'Argumenty:
'   Obj:        za|fffd||fffd|cznik (plik XSD)
'   Contents:    Zmienna (String), w kt|fffd|rej nale|fffd|y umie|fffd|ci|fffd| zawarto|fffd||fffd| oryginalnego pliku XSD (ByRef, by nie kopiowa|fffd| du|fffd|ych schemat|fffd|w)
Private Sub GetXSD(ByVal Obj As OLEObject, ByRef contents)
    Dim data() As Byte 'Bufor na dane za|fffd||fffd|cznika
    Dim pFrom As Long, pTo As Long 'Pozycje: pocz|fffd|tku i ko|fffd|ca pliku PDF w tablicy Data
    GetRawData Obj, data 'Kopiujemy "surowe" dane obiektu do tablicy Data
    
    pFrom = InStrB(data, StrConv("<?xml", vbFromUnicode)) 'Pocz|fffd|tek w|fffd|a|fffd|ciwego pliku PDF w danych obiektu
    pTo = InStrB(pFrom, data, StrConv("</xsd:schema>", vbFromUnicode))
    If pTo > 0 Then
        pTo = pTo + Len("</xsd:schema>")
    Else 'Czasami przedrostek to "xs:", a nie "xsd:":
        pTo = InStrB(pFrom, data, StrConv("</xs:schema>", vbFromUnicode))
          If pTo > 0 Then pTo = pTo + Len("</xs:schema>")
    End If
    'Nie zaszkodzi ma|fffd|a weryfikacja:
    If pFrom = 0 Or pTo <= (pFrom + 5) Then
        Err.Raise CriticalError, "XSD", GetText("AttachementCorrupted", Obj.Name)
    End If
    
    BinaryToString data, contents, Offset:=(pFrom - 1), Size:=(pTo - pFrom)
End Sub

'Pomocznicza procedura: dodaje zawarto|fffd||fffd| za|fffd||fffd|cznika <name> do obiektu SchemaCache
'Argumenty
'   schema: kolekcja schemat|fffd|w, do kt|fffd|rej mamy doda|fffd| kolejny (XMLSchemaCache60)
'   name: nazwa osadzonego za|fffd||fffd|cznika z plikiem XSD
'   namespace: przestrze|fffd| nazw, zwi|fffd|zana z tym schematem
'UWAGA: ta procedura mo|fffd|e zasygnalizowa|fffd| b|fffd||fffd|d: trzeba go przechwyci|fffd| w procedurze nadrz|fffd|dnej
Private Sub AddToXSDSchema(ByVal Schema As Object, ByVal Name As String, ByVal namespace As String)
    Dim doc As Object 'DOMDocument60
    Dim xml As String, result As Boolean
    
    GetXSD ActiveWorkbook.Sheets(InternalSheetName).OLEObjects(Name), xml 'Odczytaj tekst z osadzonego pliku XSD
    Set doc = LoadXML(xml:=xml, LoadSchema:=False)
    'Aby nie mno|fffd|y|fffd| wywo|fffd|ania b|fffd||fffd|du (Er.Raise) wprowadzi|fffd|em zmienn|fffd| pomocnicz|fffd| result:
    result = True
    If result Then result = result And Not (doc Is Nothing)
    If result Then result = result And Not (doc.DocumentElement Is Nothing)
    If result Then result = result And doc.xml <> ""
    If result = True Then 'Dokument schemy jest poprawnym dokumentem XML
        Schema.Add namespace, doc 'Ta linia mo|fffd|e tak|fffd|e wywo|fffd|a|fffd| b|fffd||fffd|d.
    Else
        Err.Raise CriticalError, "AddToXSDSchema", GetText("AttachementCorrupted", Name)
    End If
End Sub
'Pomocnicza funkcja, zwraca komplet lokalnych schemat|fffd|w XSD
Function GetLocalXSD() As Object 'XMLSchemaCache60
    Dim list As Range
        Dim cache As Object 'XMLSchemaCache60
        Dim i As Integer, AttName
        Set list = Range(XSD_ListName)
On Error GoTo GetLocalXSDErrHandler
        Set cache = CreateObject("MSXML2.XMLSchemaCache.6.0")
        cache.validateOnLoad = False
        For i = 1 To list.Rows.count
            AttName = list.cells(i, CAttName)
            If Not IsEmpty(AttName) Then
                AddToXSDSchema cache, AttName, list.cells(i, CNspace) 'za|fffd||fffd|czamy schemat z osadzonego obiektu, kojarz|fffd|c go z podan|fffd| przestrzeni|fffd| nazw
            End If
        Next i
        cache.Validate
        cache.validateOnLoad = True
        Set GetLocalXSD = cache
        Exit Function
GetLocalXSDErrHandler:
    MsgBox GetText("ErrorInXSDCaching", AttName, Err.Description), vbExclamation, GetText("Verification")
    Err.Clear
    Set GetLocalXSD = Nothing
End Function
Attribute VB_Name = "Section"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
'Klasa odpowiadaj|fffd|ca pojedynczemu arkuszowi - czyli pojedynczej "sekcji" docelowego pliku XML (Naglowek, Bilans, RZiS, itp.)
'Przechowuje tak|fffd|e informacje o wariancie sekcji. (Podobnie jak ReportDef, obiekt mo|fffd|na przypisac do innego wariantu ni|fffd| aktualnie
'wybrany w skoroszycie. To jest potrzebne podczas importu)
Private Const CName = 2 'Nr kolumny z nazw|fffd| sekcji
Private Const CId = 1 'Nr kolumny z niezmiennym identyfikatorem
Private Const CLabel = 3 'nr kolumny z etykiet|fffd|
Private Const CVariants = 4 'Ewentualny adres obszaru z wariantami arkusza
Private Const CMaxOptions = 5 'Ta kolumna w definicji wariantu raportu przechowuje max. liczb|fffd| opcji
Private Const CSubelements = 5 'Ewentualny adres obszaru z definicjami alternatywnych subelement|fffd|w sekcji (niepusty dla RZiS oraz rachunku przep|fffd|yw|fffd|w)
Private Const SelectedVariantName = "WybranyWariant" 'Pole z ko|fffd|c|fffd|wk|fffd| wybranego wariantu sekcji
Private Const SelectedPosName = "WybranaPozycja" 'Pole z numerem wybranego wariantu sekcji (uzywamy "po nazwie", gdy nie jest pod|fffd||fffd|czone do |fffd|adnej lisy rozwijalnej)
Private Const SelectedSubPosName = "WybranaPodpozycja" 'Pole z numerem wybranego usbwariantu sekcji (uzywamy "po nazwie", gdy nie jest pod|fffd||fffd|czone do |fffd|adnej lisy rozwijalnej)
Private Const SelectedSubelementName = "WybranySubelement" 'pole nazwane skorozytu, z symbolem pozycji wybranej na li|fffd|cie [WyborSubelementu]
Private Const VariantDropdownName = "WyborWariantu" 'Lista wyboru wariant|fffd|w (mo|fffd|e nie istnie|fffd|)
Private Const SubelementDropdownName = "WyborPodpozycji" 'Lista wyboru subelement|fffd|w (mo|fffd|e nie istnie|fffd|)
Private Const AdditionalHeadersName = "PodzialStron" 'obszary, kt|fffd|re nale|fffd|y pokaza|fffd| podczas wydruku, i schowa|fffd| zaraz potem
Private Const MapDefinitionsName = "Mapowanie" 'Nazwa obszaru z definicjami mapowa|fffd| p|fffd|l formularza na pola XML
Private Const EntityFieldName = "NazwaJednostki" 'Nazwa pola z nazw|fffd| jednostki podleg|fffd|ej na arkuszach "Dodatkowe (n)" (Jednostka skonsolidowana)
Private Const ConsolidatedReportId = 5 'Numer raportu skonsolidowanego (wymaga specyficznego traktowania)

Private mySheet As Worksheet 'powi|fffd|zany arkusz Excela
Private myDesc As Range 'wiersz opisu w tabeli
Private myVariant As Range 'wiersz opisuj|fffd|cy wybrany (w pliku importu lub przez u|fffd|ytkownika) wariant sekcji. Mo|fffd|e by|fffd| Nothing
Private mySubelement As Range 'Definicja subelementu (dla RZiS oraz rachunku przep|fffd|yw|fffd|w, dla pozosta|fffd|ych - Nothing)
Private myNode As Object 'IXMLDOMNode 'Zwi|fffd|zany w|fffd|ze|fffd| dokumentu XML (wartos|fffd| nadawana przy imporcie)
'Pomocnicza funkcja: znajduje arusz w skoroszycie - albo po etykiecie, albo po niezmiennym ID
'Argumenty:
'   Label:  etykieta arkusza (np. "Dodatkowe (1)") [UWAGA: mo|fffd|e si|fffd| zmieni|fffd| po zmianie j|fffd|zyka! Wtedy nie mo|fffd|na arkusza odnale|fffd||fffd| po tej nazwie]
'   Id:     unikalne id arkusza (wpisane w kom|fffd|rk|fffd| (1,1)) - np. "Dodatkowe 1"
'Funkcja mo|fffd|e nie znale|fffd||fffd| |fffd||fffd|danego arkusza - wtedy zwraca Nothing.
'Dodana dla wi|fffd|kszej przejrzysto|fffd|ci kodu w funkcji Initialize
Private Function FindWorksheet(ByVal Label As String, ByVal Id As String) As Worksheet
    Dim Sheet As Worksheet
    Set FindWorksheet = Nothing
    On Error Resume Next
        Set Sheet = ActiveWorkbook.Worksheets(Label)
    On Error GoTo 0
    If Sheet Is Nothing Then 'Drugie podej|fffd|cie: identyfikacja po celi (1,1)
        For Each Sheet In ActiveWorkbook.Worksheets
            If Sheet.cells(1, 1) = Id Then Set FindWorksheet = Sheet
        Next Sheet
    Else
        Set FindWorksheet = Sheet
    End If
End Function
'Konstruktor
'Argumenty:
'   desc:   opis arkusza (wiersz z obszaru 'EtykietyArkuszy')
'   ReportDesc: opis definicji tego raportu (wiersz z obszaru 'ListaWariantowRaportow')
'Zwraca True, gdy si|fffd| uda|fffd|o.
Function Initialize(ByVal desc As Range, ByVal ReportDesc As Range) As Boolean
    Set myDesc = desc
    Initialize = False
    Set mySheet = FindWorksheet(Me.Label, Me.Id)
    If mySheet Is Nothing Then Exit Function 'Zwraca False, gdy nie znalezionow w skoroszycie takiego arkusza
    If DebugVersion And _
       (mySheet.Visible = xlSheetVeryHidden Or _
       (mySheet.Visible = xlSheetHidden And mySheet.Name = "Dodatkowe") _
       ) Then Exit Function 'Na czas debugowania mo|fffd|emy ukrywa|fffd| (ale "na twardo") albo oczywiste sekcje (np. "Dodatkowe" w Skonsolidowanym)
    
    'Dalej - ju|fffd| powinno si|fffd| uda|fffd|.
    Initialize = True
    If IsEmpty(myDesc.cells(CVariants)) Then
        Set myVariant = Nothing
        Set mySubelement = Nothing
    Else 'Definicja zawiera w kolumnie "Odsy|fffd|acz do obszaru z wariantem" odpowiedni adres
        Dim var As Range 'Lista mo|fffd|liwych wariant|fffd|w sekcji
        Dim MaxPos As Integer 'Max. liczba pozycji do wyboru
        Set var = Range(myDesc.cells(CVariants))
        MaxPos = ReportDesc.cells(CMaxOptions)
        
        If var.Rows.count = 1 Then 'Nie ma co wybiera|fffd|
            Set myVariant = var.Rows(1)
        Else 'Je|fffd|eli lista wariant|fffd|w ma wi|fffd|cej wierszy ni|fffd| 1:
            If MaxPos = 1 Then 'Sta|fffd|a warto|fffd||fffd|!
                Set myVariant = FindOnList(ReportDesc.cells(CName), var, CName) 'W takim przypadku wyszukujemy wariant sekcji przypisany do nazwy wybranego wariantu raportu
            Else
                If MaxPos > var.Rows.count Then MaxPos = var.Rows.count 'W razie czego "przycinamy" max. liczb|fffd| pozycji do liczby dost|fffd|pnych pozycji listy
                                                                        '(np. 2 zamiast 3)
                'Mo|fffd|e by|fffd| jeszcze inaczej: wariant|fffd|w sekcji jest wi|fffd|cej ni|fffd| MaxPos, ale tych do wy|fffd|wietlenia jest MNIEJ
                'Wtedy takie wiersze "do pomini|fffd|cia" mo|fffd|emy je rozpozna|fffd| po pustej warto|fffd|ci w polu numeru:
                While IsEmpty(var.cells(MaxPos, CId)) And MaxPos > 1
                    MaxPos = MaxPos - 1
                Wend
                'W tym miejscu mamy ju|fffd| warto|fffd||fffd| MaxPos dostosowan|fffd| do "lokalnych warunk|fffd|w" skoroszytu.
                'W takim przypadku pozycj|fffd| domy|fffd|ln|fffd| jest zawsze ostatnia na li|fffd|cie:
                Set myVariant = var.Rows(MaxPos)
            End If
        End If
        
        If myVariant Is Nothing Then
            Set mySubelement = Nothing
        Else
            If IsEmpty(myVariant.cells(CSubelements)) Then 'Je|fffd|eli wybrany wariant nie ma przypisanego subelementu (np. "metoda bezpo|fffd|rednia" : "metoda po|fffd|rednia")
                Set mySubelement = Nothing
            Else 'Jaka|fffd| lista jest przypisana!
                Set var = Range(myVariant.cells(CSubelements)) 'Obszar definicji subelementu
                Set mySubelement = var.Rows(var.Rows.count) 'domy|fffd|lny Subelement to zawsze ostatni wiersz
            End If
        End If
    End If
End Function
'Druga cz|fffd||fffd| konstruktora, u|fffd|ywana podczas importu.
'Sprawdza, czy podany w|fffd|ze|fffd| odpowiada tej sekcji (mamy odczytany ju|fffd| myDesc)
'Argumenty:
'   Node:                w|fffd|ze|fffd| XML (IXMLDOMNode, bezpo|fffd|redni potomek g|fffd||fffd|wnego elementu), kt|fffd|rego nazwa bazowa (bez ns) mo|fffd|e odpowiada|fffd| tej sekcji
'   ReportVariantSymbol: nazwa wewn|fffd|trzna ("JednostkaInna", "Skonsolidowana", "JednostkaMikro", ...) wariantu raportu, do kt|fffd|rego nale|fffd|y <node>
'                        (potrzebna do rozstrzygni|fffd|cia w|fffd|tpliwo|fffd|ci, gdy|fffd| dwa r|fffd|ne raporty mog|fffd| mie|fffd| element sekcji o tej samej nazwie: Bilans, RZiS, itp.)
'   MaxOptions:          max. liczba opcji, przypisanych do aktualnego wariantu (1 [czyli jest jeden, sta|fffd|y wariant], albo 2, albo 3)
'Funkcja zmienia ewentualne myVariant i mySubelement, ale niczego nie zmienia na arkuszu
'Zwraca True gdy <node> zosta|fffd| dopasowany do tej sekcji, False w przeciwnym razie (gdy np. sekcja zosta|fffd|a ju|fffd| wcze|fffd|niej dopasowana)
'
'Uwaga: kolejne w|fffd|z|fffd|y w arkuszu skonsolidowanym s|fffd| parowane z sekcjami "Dodatkowe (n)" w p|fffd|tli ReportDef, dzi|fffd|ki wykluczaniu juz zamapowanych w|fffd|z|fffd||fffd|w
'(pod warunkiem, |fffd|e poszczeg|fffd|lne sekcje "Dodatkowe (n)" s|fffd| ustawione tak, jak akrusze). Inna sprawa, |fffd|e w tym przypadku poprawno|fffd||fffd| tego mapowania
'nie jest a|fffd| tak bardzo istotna (przypisania p|fffd|l Excela do p|fffd|l dokumentu obs|fffd|uguje Mapper, a nie Sections. A arkusze "Dodatkowe n" nie maj|fffd| zmiennych wariant|fffd|w)
Function MatchNode(ByVal node As Object, ByVal ReportVariantSymbol As String, ByVal MaxOptions As Integer) As Boolean

    MatchNode = False
    If Not (myNode Is Nothing) Then Exit Function 'Ta sekcja ju|fffd| jest zamapowana - nie trzeba dalej sprawdza|fffd|.
    'Niezale|fffd|nie od tego, czy wcze|fffd|niejsza pr|fffd|ba sie powiod|fffd|a, trzeba jeszcze sprawdzi|fffd|,
    'czy nazwa w|fffd|z|fffd|a to nie jeden z wariant|fffd|w tego formularza: (przecie|fffd| musimy tak|fffd|e wybra|fffd| ew. warianty sta|fffd|e)
    If IsEmpty(myDesc.cells(CVariants)) Then 'Nie mamy |fffd|adnego przypisanego wariantu...
        If node.BaseName = myDesc.cells(CName) Then 'Spr|fffd|bujmy zidentyfikowa|fffd| po uproszczonym symbolu elementu (np. "Naglowek", ....)
                                                    '(zadzia|fffd|a w przypadku sekcji Nag|fffd||fffd|wka)
            Set myNode = node
            MatchNode = True
            'Resetujemy wariant i subwariant
            Set myVariant = Nothing
            Set mySubelement = Nothing
        End If
    Else
        Dim variants As Range, Pos As Integer
        Set variants = Range(myDesc.cells(CVariants))
        
        If MaxOptions = 1 Then  'dla takich pojedynczych wierszy definicji sta|fffd|ych ariant|fffd|w trzeba jeszcze sprawdza|fffd| wariant raportu
                                '(bo np. i Skonsolidowana, i JednostkaInna, maj|fffd| sekcje o nazwe "Bilans", "RZiS", itd.)
            Pos = 0
            Do
                Pos = PosOnList(node.BaseName, variants.Columns(CVariants), Pos + 1) 'Dla ka|fffd|dego elementu, w kt|fffd|rym jest wymieniona nazwa tego w|fffd|z|fffd|a...
                If Pos > 0 Then
                    '.. Sprawd|fffd|, czy jednoczesnie zgadza si|fffd| tak|fffd|e nazwa wariantu raportu ("JednostkaInna", "Skonsolidowany", ....)
                    If variants.cells(Pos, CName) = ReportVariantSymbol Then Exit Do 'je|fffd|eli tak - to wiersz <Pos> to jest wiersz, kt|fffd|rego szukali|fffd|my!
                End If
            Loop While Pos > 0
            
        Else 'MaxOptions > 1 - istnieje wiele wariant|fffd|w sekcji dla tego wariantu raportu
            Pos = PosOnList(node.BaseName, variants.Columns(CVariants)) 'W tym przypadku kryterium jest tylko nazwa elementu XML.
            If Pos > MaxOptions Then 'Ten przypadek nie powinien si|fffd| nigdy przydarzy|fffd|!
                Pos = 0
            End If
        End If
        
        If Pos > 0 Then 'Znaleziono pasuj|fffd|cy wariant tej sekcji dla w|fffd|z|fffd|a <Node>:
            Set myVariant = variants.Rows(Pos)
            Set myNode = node
            MatchNode = True
            If IsEmpty(myVariant.cells(CSubelements)) Then
                Set mySubelement = Nothing
            Else 'ten wariant ma wpisany jaki|fffd| obszar na definicj|fffd| subelement|fffd|w...
                Dim subvariants As Range
                Dim children As Object 'IXMLDOMNodeList
                Dim Child As Object 'IXMLDOMNode
                Set subvariants = Range(myVariant.cells(CSubelements))
                Set children = myNode.SelectNodes("*") 'Odczytaj elementy potomne (czasami mo|fffd|e byc ich wi|fffd|cej ni|fffd| 1)
                If children.Length = 0 Then 'Taki przypadek nie powinien mie|fffd| ngdy miejsca:
                    Set mySubelement = Nothing
                Else
                    For Each Child In children
                        Set mySubelement = FindOnList(Child.BaseName, subvariants, CVariants) 'Subelementy identyfikujemy tylko na podstawie nazwy w|fffd|z|fffd|a XML
                        If Not (mySubelement Is Nothing) Then Exit For 'Znale|fffd|li|fffd|my!
                    Next Child
                End If
            End If
        End If
    End If

End Function
'Alternatywna druga cz|fffd||fffd| konstruktora: stan jak na arkuszu
Sub ReadFromSheet()
'Definicja zawiera w kolumnie "Odsy|fffd|acz do obszaru z wariantem" odpowiedni adres
    Dim var As Range 'Definicja wariantu
    Set var = GetRangeFor(SelectedVariantName, mySheet)
    If var Is Nothing Then
        Set myVariant = Nothing
        Set mySubelement = Nothing
    Else
        If IsEmpty(myDesc.cells(CVariants)) Or IsEmpty(var.value) Then
            Set myVariant = Nothing
            Set mySubelement = Nothing
        Else
            Set myVariant = FindOnList(var.value, Range(myDesc.cells(CVariants)), CName)
            Set mySubelement = Nothing
            'tu doda|fffd| ustalanie ewentualnego mySubelement:
            If Not (myVariant Is Nothing) Then
                Set var = GetRangeFor(SelectedSubelementName, mySheet)
                If var Is Nothing Or IsError(var) Then
                    Set mySubelement = Nothing
                Else
                    Set mySubelement = FindOnList(var.value, Range(myVariant.cells(CSubelements)), CName)
                End If
            End If
        End If
    End If
End Sub
'techniczna nazwa sekcji
Property Get Name()
    Name = myDesc.cells(CName).value
End Property
'Niezmienne Id sekcji
Property Get Id()
    Id = myDesc.cells(CId).value
End Property
'techniczna nazwa wariantu sekcji ("", gdy nie ma |fffd|adnego wariantu)
Property Get VariantName() As String
    If myVariant Is Nothing Then
        VariantName = ""
    Else
        VariantName = myVariant.cells(CName).value
    End If
End Property
'techniczna nazwa wybranego (spo|fffd|r|fffd|d mo|fffd|liwych alternatyw) ewentualnego podelementu sekcji ("", gdy nie ma |fffd|adnego podelementu)
Property Get SubelementName() As String
    If mySubelement Is Nothing Then
        SubelementName = ""
    Else
        SubelementName = mySubelement.cells(CName).value
    End If
End Property
'Zwraca adres w|fffd|z|fffd|a |fffd|r|fffd|d|fffd|owego dokumentu XML, skojarzonego z t|fffd| sekcj|fffd|
'Mo|fffd|e zwr|fffd|ci|fffd| Nothing, gdy sekcja ne zosta|fffd|a "skojarzona" z jakimkolwiek w|fffd|z|fffd|em
'Przy eksporcie do pliku XML zawsze zwraca Nothing, podczas gdy przy imporcie - tylko dla sekcji, kt|fffd|re nie istniej|fffd| w dokumencie |fffd|r|fffd|d|fffd|owym
Property Get node() As Object 'IXMLDOMNode
    Set node = myNode
End Property
'Zmienna etykieta sekcji (arkusza Excela) - zale|fffd|na od t|fffd|umaczenia
Property Get Label()
    Label = myDesc.cells(CLabel).value
End Property
'Wstawia w podany tekst pustego xml odp. sekcj|fffd|, pobran|fffd| z pola tekstowego z arkusza "techniczne"
'Argumenty:
'   xml: tekst dokumentu XML, kt|fffd|ry MO|fffd|E (nie musi) zawiera|fffd| tekst "{<sekcja>}", (np. "{Bilans}"). W taki fragment nale|fffd|y
'        wstawi|fffd| zawarto|fffd||fffd| pola tekstowego o symbolu "T" & sekcja & zawarto|fffd||fffd| pola["WybranyWariant"] z przypisanego arkusza.
'        Je|fffd|eli tekst <xml> nie zawiera elementu "{<sekcja>}" (np. "{Naglowek}") - nie r|fffd|b nic.
'   ReportName: nazwa aktualnego wariantu formularza ("JednostkaInna","Skonsolidowany", "JednostkaOp", ...)
Sub InsertTemplate(ByRef xml As String, ByVal ReportName As String)
    Dim placeholder As String
    placeholder = "{" & Me.Name & "}"
    If InStr(xml, placeholder) > 0 Then
        Dim TextName As String, ElementName As String
        ElementName = Split(Me.Name, " ")(0) 'Nazwa w sekcji XML nie mo|fffd|e zawiera|fffd| spacji - wyst|fffd|puj|fffd| w Skonsolidowanym, gdzie jest wiele sekcji "Dodatkowe"
        TextName = "T" & ElementName & Me.VariantName  'Nazwa pola tekstowego
        xml = Replace(xml, placeholder, GetTemplate(TextName, ReportName))
    End If
End Sub
'Pomocnicza funkcja: zwraca adres powi|fffd|zanej kom|fffd|rki (u|fffd|ywana w UpdateDropdown, dodana dla wi|fffd|kszej przejrzysto|fffd|ci kodu)
'Argumenty:
'   Shp:    kszta|fffd|t, zawieraj|fffd|cy list|fffd| DropDown (jako DrawingObject)
'Funkcja wprowadzona, gdy|fffd| okaza|fffd|o si|fffd| |fffd|e listy wariant|fffd|w i podwariant|fffd|w musz|fffd| byc od|fffd||fffd|czane od cel, gdy s|fffd| ukrywane.
'W przeciwnym razie przy okazji wstawienia nowego wiersza do arkusza nadpisuj|fffd| po|fffd||fffd|czon|fffd| kom|fffd|rk|fffd| swoj|fffd| zawarto|fffd|ci|fffd|!
'(UWAGA: lista Tak/Nie we Wprowadzenie.|fffd||fffd|czenie sp|fffd|ek pozostawia "2" gdy usuwam wiersz z pola tekstowego powy|fffd|ej. Tam
'zamaskowa|fffd|em to, zmieniaj|fffd|c format pola (bo to nie szkodzi).
Private Function LinkedCellAddress(ByVal Shp As shape) As String
    Select Case Shp.Name
        Case VariantDropdownName:
                LinkedCellAddress = GetRangeFor(SelectedPosName, Shp.Parent).Address
        Case SubelementDropdownName:
                LinkedCellAddress = GetRangeFor(SelectedSubPosName, Shp.Parent).Address
        Case Else 'Domyslnie: to, co obiekt ma przypisane
                LinkedCellAddress = Shp.DrawingObject.LinkedCell
    End Select
End Function
'Uaktualnia list|fffd| rozwijaln|fffd| i jej powi|fffd|zan|fffd| kom|fffd|rk|fffd|
'Argumenty:
'   Name:       nazwa listy rozwijalnej (gdy nie istnieje - program nie wykona tej procedury)
'   Value:      nowa wartosc dla kom|fffd|rki powi|fffd|zanej z list|fffd|
'   Visible:    true, gdy lista ma by|fffd| widoczna, False w przeciwnym razie
'   MaxOptions: opcjonalna: przeniesiona z definicji raportu max. liczba pozycji (dla list wariant|fffd|w sekcji)
'               (W razie potrzeby, gdy np. MaxOptions jest = 3, a lista zawiera wszystkiego 2 pozycjie, to ta procedura samoczynnie we|fffd|mie to pod uwag|fffd|
'                i nie wyd|fffd|u|fffd|y tej listy. Warunek: w definicji takiej listy wiersz 3 musi istnie|fffd|, ale by|fffd| pusty)
'   FieldName:  opcjonalne: nazwa kom|fffd|rki (arkusza), w ktor|fffd| nale|fffd|y wpisa|fffd| podan|fffd| warto|fffd||fffd|, gdy nie istneje lista <Name>
Private Sub UpdateDropdown(ByVal Name As String, ByVal value As Integer, ByVal Visible As Boolean, Optional ByVal MaxOptions, _
                                Optional ByVal FieldName)
    Dim Target As Range
    Dim shape As Object
    On Error Resume Next 'Nie wiemy, czy taka kontrolka na pewno istnieje:
        Set shape = mySheet.Shapes(Name)
    On Error GoTo 0
    If shape Is Nothing Then 'Nie ma tej listy rozwijalnej:
        If Not IsMissing(FieldName) Then 'Spr|fffd|buj ostatniej szansy: wpisz sam|fffd| warto|fffd||fffd| do podanej kom|fffd|rki
            Set Target = GetRangeFor(FieldName, mySheet)
            If Not (Target Is Nothing) Then Target.value = value 'Gdy arkusz zawiera takie pole - wype|fffd|nij je
        End If
    Else
        Dim list As Range
        With shape
            .Visible = Visible
            If Visible Then
                .DrawingObject.LinkedCell = LinkedCellAddress(shape)
            Else
                .DrawingObject.LinkedCell = "" 'W przeciwnym razie b|fffd|dzie nadpisywa|fffd| po|fffd||fffd|czon|fffd| kom|fffd|rk|fffd| przy ka|fffd|dym usuni|fffd|ciu/wstawieniu wiersza!
            End If
            Set Target = GetRangeFor(LinkedCellAddress(shape), mySheet) 'W ukrytych listach wariant|fffd|w i subwariant|fffd|w pole LinkedCell jest puste, st|fffd|d pomocnicza funkcja
            Set list = GetRangeFor(.DrawingObject.ListFillRange, mySheet)
            If Visible Then
                If IsMissing(MaxOptions) Then MaxOptions = list.Rows.count 'Aby nie zmienia|fffd| niczego
                If list.Rows.count <> MaxOptions Then
                   Set list = list.Resize(RowSize:=MaxOptions)
                   'Potem ewentualnie "przycinamy" do liczby faktycznie wype|fffd|nionych wierszy
                   While IsEmpty(list.Rows(list.Rows.count).cells(1)) And MaxOptions > 1
                        MaxOptions = MaxOptions - 1
                        Set list = list.Resize(RowSize:=MaxOptions)
                   Wend
                   .DrawingObject.ListFillRange = Adr(list)
                End If
            End If
        End With
        Target.value = value
    End If
End Sub
'Resetuje widoczno|fffd||fffd| element|fffd|w arkusza na takie, jakie wynikaj|fffd| z danych w tej sekcji
'Argumenty:
'   MaxOptions:     Max. liczba pozycji, kt|fffd|r|fffd| ma pokazywa|fffd| selektor
'                   Je|fffd|eli 1 - nie pokazuje selektora
'   ReportVariantId:Numer wybranego raportu - np. 5 (Skonsolidowana)
'Skraca (je|fffd|eli potrzeba) adresy |fffd|r|fffd|d|fffd|a listy. (Je|fffd|eli MaxSelectorPos =1: ukrywa selektor).
'Gdy listaw wyboru istnieje - ustawia domy|fffd|lny kod wariantu na najwy|fffd|szy.
'Zmiana numeru wariantu automatycznie prze|fffd||fffd|cza widoczno|fffd||fffd| p|fffd|l
'W przypadku raportu skonsolidowanego od|fffd|wie|fffd|a widoczno|fffd||fffd| wierszy we "Wprowadzaniu", lub widoczno|fffd||fffd| ca|fffd|ego skoroszytu "Dodatkowe (n)"
Sub ApplyToSheet(Optional ByVal MaxOptions As Integer = 1, Optional ByVal ReportVariantId As Integer = 0)
    
    If myVariant Is Nothing Then
        'arkusz jest sta|fffd|y - nie mamy nic do roboty
    Else 'Definicja zawiera w kolumnie "Odsy|fffd|acz do obszaru z wariantem" odpowiedni adres

        UpdateDropdown VariantDropdownName, myVariant.cells(CId), (MaxOptions > 1), MaxOptions, SelectedPosName  'Gdy w arkuszu nie ma listy VariantDropDown,
                                                                                                         'spr|fffd|buj przynajmniej uaktualni|fffd| kom|fffd|rk|fffd| SelecedPos
                                                                                                         '(Tak bedzie np. w "Rachunku przep|fffd|yw|fffd|w")
        
        If mySubelement Is Nothing Then
            UpdateDropdown SubelementDropdownName, 0, False 'W razie czego wyzeruj i ukryj kontrolk|fffd| (taka sytuacja wyst|fffd|pi dla fimy mikro w RZiS)
        Else
            UpdateDropdown SubelementDropdownName, mySubelement.cells(CId), True
        End If
        
        'Raport skonsolidowany ma cz|fffd||fffd| p|fffd|l zmiennych, kt|fffd|re mog|fffd| wymaga|fffd| ods|fffd|oni|fffd|cia:
        If ReportVariantId = ConsolidatedReportId Then 'Je|fffd|eli przestawilismy si|fffd| na raport skonsolidowany:
            'Poni|fffd|ej zrezygnowa|fffd|em z ukrywania nazw arkuszy w sta|fffd|ych, bo bardziej czytelne jest bezpo|fffd|rednie podanie ich symboli:
            If Me.Id = "Wprowadzenie" Then
                Application.Calculate 'Dopiero co zmienili|fffd|my pola: przelicz je teraz, aby si|fffd| uaktualni|fffd|y
                UpdateRowVisibility GetRangeFor(SelectedPosName, Me.Sheet) 'Wymuszamy od|fffd|wie|fffd|enie wierszy
            End If

            If Me.Id Like "Dodatkowe #*" Then 'Dla skonsolidowanego:
               Dim EntityName
               EntityName = GetRangeFor(EntityFieldName, Me.Sheet)
               If IsEmpty(EntityName) Or EntityName = "" Then
                 'nic - (w przysz|fffd|o|fffd|ci mo|fffd|e zastanowisz si|fffd| nad jak|fffd||fffd| logik|fffd| ukrywania arkuszy?)
               Else 'Je|fffd|eli nazwa jednostki podrz|fffd|dnej nie jest pusta: upewnij si|fffd|, |fffd|e arkusz jest ods|fffd|oni|fffd|ty.
                 If Me.Sheet.Visible <> xlSheetVisible Then Me.Sheet.Visible = xlSheetVisible
               End If
            End If
        Else
            If Me.Id = "Dodatkowe" Then
                Application.Calculate 'Dopiero co zmienili|fffd|my pola: przelicz je teraz, aby si|fffd| uaktualni|fffd|y
                'teraz tylko wszelki wypadek wymu|fffd| od|fffd|wie|fffd|enie widoczno|fffd|ci (ze wzgl|fffd|du na ewentualne subpozycje rozliczenia r|fffd|nic):
                UpdateRowVisibility GetRangeFor(SelectedPosName, Me.Sheet) 'Wymuszamy od|fffd|wie|fffd|enie wierszy
            End If
        End If
    End If

End Sub
'Dodaje dodatkowe podzia|fffd|y stron (i ods|fffd|ania przygotowane nag|fffd||fffd|wki)
'Wywo|fffd|ywac przed wydrukiem
Sub ShowAdditionalPageBreaks()
   Dim headers As Range
   Set headers = GetRangeFor(AdditionalHeadersName, mySheet)
   If headers Is Nothing Then Exit Sub 'ten arkusz nie ma |fffd|andych dodatkowych nag|fffd||fffd|wk|fffd|w
   
   Dim toShow As New Collection 'pomocnicza kolekcja p|fffd|l do wstawienia nag|fffd||fffd|wk|fffd|w (nie do ka|fffd|dego wstawiamy)
   Dim row As Range, previousRow As Range
   For Each row In headers.Rows
    If row.EntireRow.Hidden Then
        Set previousRow = mySheet.Rows(row.row - 1)
        If Not previousRow.EntireRow.Hidden Then toShow.Add row
    End If
   Next row
   If toShow.count = 0 Then Exit Sub
   Dim pwd
   pwd = UnprotectSheet(mySheet)
   If IsEmpty(pwd) Then Exit Sub 'Nie uda|fffd|o si|fffd| zdj|fffd||fffd| ochrony skoroszytu
            '(komunikat wy|fffd|wietli|fffd| UnprotectSheet())
   On Error GoTo ErrHandler
   
   For Each row In toShow
        row.EntireRow.Hidden = False
        mySheet.HPageBreaks.Add before:=row
   Next row
ErrHandler:
    Err.Clear
    ProtectSheet mySheet, pwd
End Sub

Sub HideAdditionalPageBreaks()
   Dim headers As Range
   
   Set headers = GetRangeFor(AdditionalHeadersName, mySheet)
   If headers Is Nothing Then Exit Sub 'ten arkusz nie ma |fffd|andych dodatkowych nag|fffd||fffd|wk|fffd|w
   
   Dim row As Range
   
   Dim pwd, pb As HPageBreak
   pwd = UnprotectSheet(mySheet)
   If IsEmpty(pwd) Then Exit Sub 'Nie uda|fffd|o si|fffd| zdj|fffd||fffd| ochrony skoroszytu
                                 '(komunikat wy|fffd|wietli|fffd| UnprotectSheet())
   On Error GoTo ErrHandler
   
   For Each row In headers.Rows
      If Not row.EntireRow.Hidden Then row.EntireRow.Hidden = True
   Next row
   
   For Each pb In mySheet.HPageBreaks
        If pb.Type = xlPageBreakManual Then pb.Delete
   Next pb
   
ErrHandler:
    Err.Clear
    ProtectSheet mySheet, pwd
End Sub
'Metoda uaktualnia formaty liczb w zale|fffd|no|fffd|ci od aktualnie wybranej bazy (w tys/w z|fffd|)
'Informacyjnie: zwraca liczb|fffd| wyzerowanych p|fffd|l
Sub UpdateAmountFormats()
    Dim list As Range, row As Range, item As MappedField
    Dim pwd
    pwd = UnprotectSheet(mySheet)
    If IsEmpty(pwd) Then Exit Sub 'ew. komunikaty pojawi|fffd| si|fffd| w UnprotectSheet
    On Error GoTo ErrHandler
        Set list = Range(MapDefinitionsName)
        For Each row In list.Rows
            Set item = New MappedField
            item.Initialize row
            If item.IsValid Then 'mapowanie aktualnie mo|fffd|e nie by|fffd| przypisane do |fffd|adnej kom|fffd|rki
                If item.cell.Worksheet Is mySheet Then 'Zmieniamy formaty tylko dla naszych kom|fffd|rek
                    item.UpdateAmountFormat
                End If
            End If
        Next row
ErrHandler:
    If Err.Number <> 0 Then 'czy podczas przetwarzania wyst|fffd|pi|fffd| b|fffd||fffd|d?
        If Err.Number = vbObjectError Then 'B|fffd||fffd|d ju|fffd| zasygnalizowany (por. MarkXMLValueError())
            Application.StatusBar = GetText("OperationFailed")
            RestoreStatusBar StatusBarDelay
        Else
            MsgBox GetText("ExportFailed", Err.Description), vbCritical, GetText("UnexpectedError")
        End If
    End If
    'Odtwarzamy stan Excela i wychodzimy:
    ProtectSheet mySheet, pwd
End Sub

Property Get Sheet() As Worksheet
    Set Sheet = mySheet
End Property
'Zmienia etykiet|fffd| przypisanego arkusza na tak|fffd|, jaka obecnie figuruje w definicji
'(do u|fffd|ycia po zmianie j|fffd|zyka)
Sub UpdateLabel()
    mySheet.Name = Me.Label
End Sub

Attribute VB_Name = "Stream"
Option Explicit
'Pomocniczy modu|fffd| do obs|fffd|ugi odczytywania i zapisywania r|fffd|norodnych "strumieni" danych
Private Const adTypeBinary = 1
Private Const adTypeText = 2
'Zapisuje dane binarne do wskazanego pliku
'Argumenty:
'Binary: Variant (aby pasowa|fffd| do metody Strea.Write), zawieraj|fffd|cy tablic|fffd| bajt|fffd|w [Binary() As Byte]. Pocz|fffd|tkowy indeks: 0
'Path:   |fffd|cie|fffd|ka, pod kt|fffd|r|fffd| nale|fffd|y zapisa|fffd| plik
'Offset: opcjonalny: liczba pierwszych bajt|fffd|w, kt|fffd|re nale|fffd|y pomin|fffd||fffd|
'Size:   opcjonalny: liczba bajt|fffd|w do przepisania
Sub BinaryToFile(ByRef Binary, ByVal Path As String, Optional ByVal Offset As Long = 0, Optional ByVal Size As Long = -1)
  'Create Stream object
  Dim BinaryStream 'As New Stream
  Set BinaryStream = CreateObject("ADODB.Stream")
  BinaryStream.Type = adTypeBinary
  'Open the stream And write binary data To the object
  BinaryStream.Open
  BinaryStream.Write Binary
  If Offset > 0 Or Size > 0 Then 'Zak|fffd|adam, |fffd|e nawet dwa dodatkowe masowe przepisania s|fffd| szybsze, ni|fffd| pojedyncze "bajt po bajcie"
    Dim Temp As Object 'Drugi, pomocniczy strumie|fffd|
    Set Temp = CreateObject("ADODB.Stream")
    Temp.Type = adTypeBinary
    Temp.Open
    If Size < 0 Then Size = UBound(Binary) + 1 - Offset '+1, bo pierwsza pozycja tablicy Binary ma indeks 0
    BinaryStream.Position = Offset
    BinaryStream.CopyTo Temp, Size
    BinaryStream.Close
    Set BinaryStream = Temp
  End If
  BinaryStream.Position = 0
  
  BinaryStream.SaveToFile Path
  
  BinaryStream.Close
  Set BinaryStream = Nothing
End Sub
'Zamienia dane zakodowane w standardzie Base64 na dane binarne i zapisuje do wskazanego pliku
'Argumenty:
'   base64: tekst enkodowanych danych (zywk|fffd|y String, przekazywany ByRef aby unikna|fffd| kopiowania danych)
'   Path:   |fffd|ciezka do pliku, w kt|fffd|rym nale|fffd|y zapisa|fffd| dane binarne
Sub Base64ToFile(ByRef Base64, ByVal Path As String)
  Dim oXML, oNode
  Dim BinaryData '() As Byte
  'Zamie|fffd| dane w Base64 na binarne:
  Set oXML = CreateObject("Msxml2.DOMDocument.3.0")
  Set oNode = oXML.createElement("base64")
  oNode.DataType = "bin.base64"
  oNode.text = Base64
  BinaryData = oNode.nodeTypedValue
  Set oNode = Nothing
  Set oXML = Nothing
  
  'Zapisz je do pliku:
  Dim BinaryStream 'As New Stream
  Set BinaryStream = CreateObject("ADODB.Stream")
  BinaryStream.Type = adTypeBinary

  'Open the stream And write binary data To the object
  BinaryStream.Open
  BinaryStream.Write BinaryData
  BinaryStream.SaveToFile Path
  BinaryStream.Close
End Sub

'Odczytuje ze wskazanego pliku dane binarne i zwraca je jako Base64
'Argumenty:
'   Path:   |fffd|ciezka do pliku, z danymi binarnymi
'   base64: tekst, w kt|fffd|rym nalezy podstawi|fffd| dane enkodowane w Base64 (zywk|fffd|y String, przekazywany ByRef aby unikna|fffd| kopiowania danych)
Sub FileToBase64(ByVal Path, ByRef Base64)
  'Odczytanie binarnych danych z pliku
  Dim BinaryStream 'As New Stream
  Dim BinaryData '() As Byte
  Set BinaryStream = CreateObject("ADODB.Stream")
  BinaryStream.Type = adTypeBinary
  BinaryStream.Open
  BinaryStream.LoadFromFile Path
  'get binary data from the object
  BinaryData = BinaryStream.Read
  BinaryStream.Close
  Set BinaryStream = Nothing
  
  'Konwersja danych binarnych na Base64:
  Dim oXML, oNode
  Set oXML = CreateObject("Msxml2.DOMDocument.3.0")
  Set oNode = oXML.createElement("base64")
  oNode.DataType = "bin.base64"
  oNode.nodeTypedValue = BinaryData
  Base64 = oNode.text
End Sub

'Konwersja fragmentu danych binarnych w UTF-8 lub innym kodowaniu na string
'Argumenty:
'   Binary:     tablica bajt|fffd|w (() As Byte), pierwszy indeks to 0
'   Text:       tekst (String), kt|fffd|ry mamy wype|fffd|ni|fffd| danymi (Byref, aby ich niepotrzebnie nie kopiowa|fffd|)
'   Charset:    opcjonalny: kodowanie znak|fffd|w w danych binarnych
'   Offset:     opcjonalne: miejsce, od kt|fffd|rego nale|fffd|y kopiowa|fffd| tekst (w bajtach)
'   Size:       opcjonalne: d|fffd|ugo|fffd||fffd| kopiowanych danych (w bajtach)
Sub BinaryToString(ByRef Binary, ByRef text, Optional ByVal Charset As String = "utf-8", _
                        Optional ByVal Offset As Long = 0, Optional ByVal Size As Long = -1)
  'Create Stream object
  Dim BinaryStream As Object 'New Stream
  Set BinaryStream = CreateObject("ADODB.Stream")

  'Specify stream type - we want To save binary data.
  BinaryStream.Type = adTypeBinary

  'Open the stream And write binary data To the object
  BinaryStream.Open
  BinaryStream.Write Binary

  If Offset > 0 Or Size > 0 Then 'Zak|fffd|adam, |fffd|e nawet dwa dodatkowe masowe przepisania s|fffd| szybsze, ni|fffd| pojedyncze "bajt po bajcie"
    Dim Temp As Object 'Drugi, pomocniczy strumie|fffd|
    Set Temp = CreateObject("ADODB.Stream")
    Temp.Type = adTypeBinary
    Temp.Open
    If Size < 0 Then Size = UBound(Binary) + 1 - Offset '+1, bo pierwsza pozycja tablicy Binary ma indeks 0
    BinaryStream.Position = Offset
    BinaryStream.CopyTo Temp, Size
    BinaryStream.Close
    Set BinaryStream = Temp
  End If

  'Change stream type To text/string
  BinaryStream.Position = 0
  BinaryStream.Type = adTypeText

  'Specify charset For the output text (unicode) data.
  BinaryStream.Charset = "utf-8"
  
  'Open the stream And get text/string data from the object
  text = BinaryStream.ReadText
  Set BinaryStream = Nothing
End Sub
'Konwersja fragmentu tekstu w Base64 na dane binarne
'Argumenty:
'   Base64: dane enkodowane w Base64
'Zwraca tablic|fffd| bajt|fffd|w (() As Byte), pierwszy indeks to 0
Private Function DecodeBase64(ByRef Base64 As String) As Byte()
  Dim oXML, oNode
  'Zamie|fffd| dane w Base64 na binarne:
  Set oXML = CreateObject("Msxml2.DOMDocument.3.0")
  Set oNode = oXML.createElement("base64")
  oNode.DataType = "bin.base64"
  oNode.text = Base64
  DecodeBase64 = oNode.nodeTypedValue
  Set oNode = Nothing
  Set oXML = Nothing
End Function
'Pomocnicza funkcja do dekodowania danych w Base64 (u|fffd|ywane w LoadXML do odczytania danych podpisanych przez Certum)
'Argumenty:
'   Base64: tekst, kt|fffd|ry trzeba odenkodowa|fffd| (przekazywany poprzez ByRef, aby oszcz|fffd|dzi|fffd| pami|fffd||fffd|)
Function Decode(ByRef Base64 As String) As String
   Dim result As String
   Dim UTF_8() As Byte
   UTF_8 = DecodeBase64(Base64)
   BinaryToString UTF_8, result
   Decode = result
End Function
Attribute VB_Name = "Ten_skoroszyt"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True

Attribute VB_Name = "UIUtils"
Option Explicit
'Modu|fffd| zawiera procedury obs|fffd|ugi r|fffd|nych kontrolek w tym skoroszycie, m.in.
'kontrolki do obs|fffd|ugi "przycisk|fffd|w" Shrink/Expand, u|fffd|ywanych do poszerzania/skracania p|fffd|l opisowych
'S|fffd| to dwa TextBox-y, umieszczone z prawej, u do|fffd|u pola opisowego.
'Czcionk|fffd| Windngs3 s|fffd| w nich napisane strza|fffd|ki
'
'S|fffd| tu tak|fffd|e procedury zwi|fffd|zane z obs|fffd|ug|fffd| widoczno|fffd|ci zawarto|fffd|ci poszczeg|fffd|lnych skoroszyt|fffd|w
'W ka|fffd|dym "publicznym" skoroszycie pierwsza kolumna zawiera flagi widoczno|fffd|ci (liczby) lub puste kom|fffd|rki,
'oraz 3 obszary nazwane arkusza:
'   WybranaPozycja  - numer z listy,
'   WybranyWariant  - ko|fffd|c|fffd|wka nazwy pola tekstowego ze wzorcem formularza
'   WyborWariantu   - lista (Shape), pod|fffd||fffd|czona do WybranaPozycja (nazwana, bo dla niektorych wariant|fffd|w trzeba je chowa|fffd|)
'
#If VBA7 Then
    Private Declare PtrSafe Function GetCursorPos Lib "user32" (lpPoint As POINTAPI) As Long
#Else
    Private Declare Function GetCursorPos Lib "user32" (lpPoint As POINTAPI) As Long
#End If

Type POINTAPI
    x As Long
    y As Long
End Type

Public Const StatusBarDelay = 5 's (Standardowy czas wy|fffd|wietlania komunikatu)

Private Const SheetProtectionPwd = "informacja" 'standardowe has|fffd|o ochrony arkuszy
'Etykiety przycisk|fffd|w za|fffd||fffd|cznik|fffd|w (u|fffd|ywane w klasie Attachement):
Public Const AttEmptyCaption = "..." 'etykieta przycisku bez za|fffd||fffd|cznika
Public Const AttAssignedCaption = "X" 'etykieta przycisku z za|fffd||fffd|cznikiem
'Inne sta|fffd|e:
Private Const DialogFlagsName = "KomunikatyWOknachDialogowych" 'Pole z flagami dot. okien dialogowych (ci|fffd|g "0" i "1")
'Zmienne lokalne:
Private SbState As Variant 'oryginalny stan StatusBar

'Etykiety kontrolek (Windings3 zamienia je na strza|fffd|ki)
Private Const CExpand = ","
Private Const CShrink = "+"
Private Const MinHeight = 3 'Kontrolka nie mo|fffd|e mie|fffd| mniej ni|fffd| 3 wiersze
'Flagi widoczno|fffd|ci w kolumnie A to maski, z kt|fffd|rymi jest por|fffd|wnywana warto|fffd||fffd| 2^[WybranaPozycja]
'Je|fffd|eli po por|fffd|wnaniu flaga = por|fffd|wnywanej warto|fffd|ci: wiersz jest widoczny, a gdy 0 - ukryty.
Private Const MaxRows = 2000 'Zak|fffd|adamy, |fffd|e |fffd|aden arkusz nie b|fffd|dzie zawiera|fffd| wi|fffd|cej ni|fffd| tyle wierszy
Private Const ListPosName = "WybranaPozycja" 'pole nazwane skoroszytu, z numerem wybranej pozycji wybranej na li|fffd|cie [WyborWariantu]
Private Const SubPosName = "WybranaPodpozycja" 'pole nazwane skoroszytu, z numerem wybranej pozycji wybranej na li|fffd|cie [WyborSubelementu]
Private Const MapDefinitionsName = "Mapowanie" 'Nazwa obszaru z definicjami mapowa|fffd| p|fffd|l formularza na pola XML
Private Const AmountBaseName = "NumerBazyRaportu" 'Pole z numerem wybranej bazy: na "WZlotych" (1)/"WTys" (2)
Private Const ReconcilationFlagName = "WrfKwot" 'Pole (Boolean) steruj|fffd|ce wy|fffd|wietlaniem komunikat|fffd|w o niezgodno|fffd|ciach kwot (znaczki "!"/"=" przy podsumowaniu Bilansu)
Private Const ReconcilationDlgName = "CtrlWrfKwot" 'Pole (Integer) steruj|fffd|ce wy|fffd|wietlaniem komunikat|fffd|w o niezgodno|fffd|ciach kwot w oknach dialogowych (wyb|fffd|r z listy rozijalnej z arkusza "Nag|fffd||fffd|wek")

'Obs|fffd|uga list jednostek w arkuszu "Wprowadzenie":
Private Const HiddenColumn = 3     'dane dla przycisk|fffd|w Up i Down s|fffd| w kolumie "C" arkusza.
Private Const ListMarker = "break" 'S|fffd|owo umieszczane w 3 kolumnie szarego wiersza rozpoczynaj|fffd|cego i ko|fffd|cz|fffd|cego listy
Private Const ListButtonColumn = 18 'Kolumna zawieraj|fffd|ca przyciski Up/Down, steruj|fffd|ce list|fffd|.
Private Const UpButtonFullHeight = 20 'Wysoko|fffd||fffd| wiersza z widoczn|fffd| kontrolk|fffd| "Up"
Private Const UpButtonMinHeight = 7 'Wysoko|fffd||fffd| wiersza z niewidoczn|fffd| kontrolk|fffd| "Up"
'Nazwy tymczasowych plik|fffd|w (do obej|fffd|cia b|fffd||fffd|du w Excelu 2010 z listami wydruku):
Private Const TempName = "e-sprawozdanie (duplikat).xlsm"
Private Const DamagedName = "e-sprawozdanie (uszkodzony).xlsm" 'Chwilowa nazwa dla uszkodoznego skoroszytu (aby mo|fffd|na by|fffd|o za|fffd|adowa|fffd| docelowy)
Private Const UndoListCtrlId = 128 'Niezale|fffd|ny od j|fffd|zyka numer listy rozwijalnej "Undo" na nigdy nie wy|fffd|wietlanym pasku przycisk|fffd|w "a' la Excel 2003"
Private Const PasteCtrlId = 6002 'Niezale|fffd|ny od j|fffd|zyka numer polecenia "Wklej" na nigdy nie wy|fffd|wietlanym pasku przycisk|fffd|w "a' la Excel 2003"
Private Const FormatPDF = 57 'tajemnicza sta|fffd|a Excela dla SaveAs dialog, bez nazwy symbolicznej

Private mySelectionStack As Collection 'stos zapami|fffd|tanych selekcji: wk|fffd|ada do niego UnprotectSheet, zdejmuje ProtectSheet
Private myUpdateScreenLevel As Long   'Ka|fffd|de DisableScreenUpdating zwi|fffd|ksza ten licznik o 1, a EnableScreenUpdating - zmniejsza o 1.
Private myOriginalCalcMode  As Variant 'Je|fffd|eli nie jest Empty: odtwarzaj przeliczanie wraz z flag|fffd| ScreenUpdate
'(gdy arkusz nie by|fffd| zabezpiczony, nic nie jest ani wk|fffd|adane, ani zdejmowanie)

'Zwraca obiekt skoroszytu (Range lub Shape) kt|fffd|ry zosta|fffd| ostatnio klikni|fffd|ty
Private Function GetClickedObject() As Object
    Dim mouse As POINTAPI 'Pozycja myszki
    ' Odczytaj pozycje myszki w chwili klikni|fffd|cia:
    GetCursorPos mouse
    Set GetClickedObject = ActiveWindow.RangeFromPoint(mouse.x, mouse.y) 'Sprawd|fffd|, w co klineli|fffd|my
End Function
'Zapami|fffd|tuje, czy status bar by|fffd| widoczny czy nie:
'Argumenty:
'   DoNotHide: opcjonalny parametr (w istocie doda|fffd|em go tylko po to, by procedura nie pojawi|fffd|a si|fffd| w|fffd|r|fffd|d makr)
Public Sub PreserveStatusBar(Optional ByVal DoNotHide As Boolean = False)
    Application.StatusBar = False
    If DoNotHide Or IsEmpty(SbState) Then
        Application.DisplayStatusBar = True
    Else
        Application.DisplayStatusBar = SbState
    End If
End Sub
'Odtwarza stan paska stanu - pozostawiaj|fffd|c ewentualny napis przez okre|fffd|lon|fffd| liczb|fffd| sekun
'Argumenty
'   Delay:  opcjonalny: op|fffd|nienie przywr|fffd|cenia paska stanu Excela (w sekundach)
Public Sub RestoreStatusBar(Optional ByVal Delay As Integer = 0)
    If Delay = 0 Then
        ClearStatusBar
    Else
        Application.OnTime Now + Delay * TimeValue("00:00:01"), "ClearStatusBar"
    End If
End Sub
'Pomocnicza procedura "gasz|fffd|ca" komunikat w Status Bar
'Argumenty:
'   DoNotHide: opcjonalny: True, je|fffd|eli status bar ma pozosta|fffd| widoczny (nawet je|fffd|eli poprzednio nie by|fffd|)
Public Sub ClearStatusBar(Optional ByVal DoNotHide As Boolean = False)
    Application.StatusBar = False
    If DoNotHide Or IsEmpty(SbState) Then
        Application.DisplayStatusBar = True
    Else
        Application.DisplayStatusBar = SbState
    End If
End Sub
'Zwi|fffd|ksza licznik wy|fffd||fffd|cze|fffd| (gdy zaczyna od 0 - naprawd|fffd| wy|fffd||fffd|cza aktualizacj|fffd| ekranu)
'Argumenty:
'   DisableCalc: True, je|fffd|eli tak|fffd|e wy|fffd||fffd|czyc przeliczanie p|fffd|l
Public Sub DisableScreenUpdating(Optional ByVal DisableCalc As Boolean = False)
    If myUpdateScreenLevel = 0 Then
        Application.ScreenUpdating = False
    End If
    If DisableCalc And myOriginalCalcMode = Empty Then
        myOriginalCalcMode = Application.Calculation
        Application.Calculation = xlCalculationManual
    End If
    myUpdateScreenLevel = myUpdateScreenLevel + 1
End Sub
'Zwi|fffd|ksza licznik w|fffd||fffd|cze|fffd| (gdy osi|fffd|ga 0 - naprawd|fffd| w|fffd||fffd|cza aktualizacj|fffd| ekranu)
'Argumenty:
'   ForceCalculation: ustaw na True, je|fffd|eli przy wychodzeniu z ostatniego zagnie|fffd|d|fffd|enia ma przeliczy|fffd| skoroszyt
'                     gdy u|fffd|ytkownik ma ustawione przeliczanie r|fffd|czne
Public Sub EnableScreenUpdating(Optional ByVal ForceCalculation As Boolean)
    myUpdateScreenLevel = myUpdateScreenLevel - 1
    If myUpdateScreenLevel <= 0 Then
        If Not IsEmpty(myOriginalCalcMode) Then
            If myOriginalCalcMode <> xlCalculationManual Or ForceCalculation Then Application.Calculate
            Application.Calculation = myOriginalCalcMode
            myOriginalCalcMode = Empty
        End If
        Application.ScreenUpdating = True
        myUpdateScreenLevel = 0
    End If
End Sub
'Czy pokazywac komunikat o wczytaniu/zapisaniu pliku w oknie dialogowym?
Function ShowModalConfirmation() As Boolean
    Dim map As String
    map = Range(DialogFlagsName)
    ShowModalConfirmation = (Mid(map, 1, 1) = "1")
End Function
'Czy weryfikowa|fffd| wewn|fffd|trzn|fffd| zgodno|fffd||fffd| wybranych kwot sprawozdania?
'Zwraca:
'   0: nie
'   1: tak, jako ostrze|fffd|enie (do obej|fffd|cia)
'   2: tak, jako b|fffd||fffd|d (tzn. nie do obej|fffd|cia)
Function PerformReconciliation() As Integer
    If Range(ReconcilationDlgName) = 1 Then '"u|fffd|yj ustawie|fffd| domy|fffd|lnych"
        Dim map As String
        map = Range(DialogFlagsName)
        PerformReconciliation = Mid(map, 2, 1)
    Else 'Wystarczy odj|fffd||fffd| od numeru pozycji w li|fffd|cie rozwijalnej "ObslugaNiezgodnosci" liczb|fffd| 2:
        PerformReconciliation = Range(ReconcilationDlgName) - 2
    End If
End Function

'Procedura przestawia status wy|fffd|wietlania flag uzgodnie|fffd|
'Argumenty
'   Enabled: True, je|fffd|eli ma by|fffd| w|fffd||fffd|czony
'Procedura po prostu zmienia jedno z p|fffd|l technicznych, dodana dla wi|fffd|kszej czytelno|fffd|ci kodu
Sub SetReconciliationStatus(ByVal Enabled As Boolean)
    'Application.EnableEvents = False
    Range(ReconcilationFlagName) = Enabled
    'Application.EnableEvents = True
End Sub

'Trzecia flaga: nie obs|fffd|ugiwana
Function ShowModalLocalSchemaInformation() As Boolean
    Dim map As String
    map = Range(DialogFlagsName)
    ShowModalLocalSchemaInformation = (Mid(map, 3, 1) = "1")
End Function
'Zwraca drugi przycisk Expand/Shrink - drug|fffd| cze|fffd||fffd| pary, do kt|fffd|rej nale|fffd|y Target
'Argumenty:
'   Target: "przycisk" (TextBox), dla kt|fffd|rego szukamy "bli|fffd|niak"
'Gdy z jakich|fffd| przyczyn niczego nie znalaz|fffd| - zwraca Nothing
Private Function FindPairFor(ByVal Target As TextBox) As TextBox
    Dim ctl As shape
    Dim Sheet As Worksheet
    
    Set FindPairFor = Nothing
    Set Sheet = ActiveWorkbook.ActiveSheet
    For Each ctl In Sheet.Shapes
       If ctl.AutoShapeType = msoShapeRectangle Then ' TextBox
            With ctl.DrawingObject
                If Target.TopLeftCell.Address = .TopLeftCell.Address And Target.Name <> .Name Then
                    Set FindPairFor = ctl.DrawingObject
                    Exit For
                End If
            End With
       End If
    Next ctl
End Function
'Funkcja zwraca liczb|fffd| wierszy wskazanego pola (musi by|fffd| scalone)
'Argumenty:
'   Target:    kontrolka Shrink/Expand
Private Function MergedFieldHeight(ByVal Target As TextBox) As Long
    Dim cell As Range, count As Long
    Set cell = Target.TopLeftCell.Offset(ColumnOffset:=-1)  'cell to prawa dolna kom|fffd|rka pola opisu
    count = 1
    Do While cell.row > 1
        Set cell = cell.Offset(RowOffset:=-1) 'kom|fffd|rka z poprzedniego wiersza
        If cell.MergeCells = True Then
            count = count + 1
        Else
            Exit Do
        End If
    Loop
    MergedFieldHeight = count
End Function
'Procedura zaznacza pole tekstowe, zwi|fffd|zane z kontrolk|fffd|
'Argumenty:
'   Target:    kontrolka Shrink/Expand
'Funkcja dodana tylko dla wi|fffd|kszej przejrzysto|fffd|ci kodu
Private Sub SelectAssociatedField(ByVal Target As TextBox)
    Target.TopLeftCell.Offset(ColumnOffset:=-1).Select
End Sub

'Procedura dla przycisk|fffd|w zmniejszaj|fffd|cych/zwi|fffd|kszaj|fffd|cych wysoko|fffd||fffd| (liczb|fffd| wierszy)
'p|fffd|l opisowych (dwie strza|fffd|ki po prawej stronie ka|fffd|dego pola)
Sub OnClickExpandShrinkRow()
    Dim Target As TextBox 'Klikni|fffd|ty "przycisk"
    ' Odczytaj pozycje myszki w chwili klikni|fffd|cia:
    Set Target = GetClickedObject() 'Sprawd|fffd|, w co klikneli|fffd|my
    If TypeName(Target) = "TextBox" Then 'OK, zaczynaj dzia|fffd|anie
        Dim row As Range, SheetProtect
        Set row = Target.TopLeftCell.EntireRow
        SheetProtect = UnprotectSheet(ActiveSheet, False)
        If IsEmpty(SheetProtect) Then Exit Sub 'Nie uda|fffd|o si|fffd| zdj|fffd||fffd| ochrony skoroszytu
            'nic (komunikat wy|fffd|wietli|fffd| UnprotectSheet())
            
        Application.EnableEvents = False 'wywo|fffd|anie row.Delete, row.Insert (poni|fffd|ej) wbija|fffd|o "2" w r|fffd|ne miejsca arkusza!
        On Error GoTo ErrHandler
        
        Select Case Target.Caption
            Case CExpand:
                       
                            row.Insert Shift:=xlDown
                            'Uzupe|fffd|nij ew. znacznik ukrycia:
                            If Not IsEmpty(row.cells(1)) Then 'W nowo dodanym wierszu trzeba uzupelni|fffd| mask|fffd| widoczno|fffd|ci
                                row.Offset(RowOffset:=-1).cells(1).value = row.cells(1).value
                            End If
                            Set Target = FindPairFor(Target)                'Znajd|fffd| przycisk "Shrink"
                            If Not (Target Is Nothing) Then Target.Visible = True  'i wy|fffd|wietl go
                            SelectAssociatedField Target
                        
            Case CShrink:
                            Set row = row.Offset(RowOffset:=-1)                       'usuwamy wcze|fffd|niejszy wiersz
                            row.Delete Shift:=xlUp
                            SelectAssociatedField Target
                            'Je|fffd|eli pole osi|fffd|gn|fffd|o minimaln|fffd| wysoko|fffd||fffd| - ukryj przycisk zmniejszania
                            If MergedFieldHeight(Target) <= MinHeight Then
                                Target.Visible = False
                            End If
        End Select
        Err.Clear 'Gdy wykonanie dosz|fffd|o do tej linii - lepiej usun|fffd||fffd| ewentualne "echa": b|fffd||fffd|dy po przeliczaniu arkusza
ErrHandler:
        If Err.Number <> 0 Then MsgBox Err.Description & vbCr & "(" & Hex(Err.Number) & ")", vbExclamation, GetText("UnexpectedError")
        Application.EnableEvents = True
        ProtectSheet ActiveSheet, SheetProtect, False 'Je|fffd|eli arkusz by|fffd| chroniony - zabezpiecz go z powrotem
    End If
End Sub
'Zwraca nazw|fffd| pliku z rozszerzeniem, ale bez |fffd|cie|fffd|ki dost|fffd|pu (np. "shell32.dll")
'Argumenty:
'   Path: pe|fffd|na |fffd|cie|fffd|ka dost|fffd|pu do pliku (np. "C:\Windows\shell32.dll")
Function GetFileName(ByVal Path As String) As String
    Dim Pos As Long
    Path = Replace(Path, "/", "\") 'Na wszelki wypadek
    Pos = InStrRev(Path, "\") 'pozycja ostatniego "\"
    GetFileName = Mid(Path, Pos + 1) 'Gdy nie by|fffd|o w tek|fffd|cie "\", to Pos = 0 i kopiuje do FileName ca|fffd||fffd| |fffd|cie|fffd|k|fffd|
End Function
'Funkcja zwraca True, gdy nazwa pliku jest poprawna, False gdy u|fffd|ytkownik chce poprawi|fffd|, Null gdy chce zrezygnowa|fffd|
'Argumenty:
'   Path:       |fffd|cie|fffd|ka do pliku (pe|fffd|na), zawieraj|fffd|ca nazw|fffd| pliku
'   ForImport:  opcjonalna podpowied|fffd|, |fffd|e chodzi o wczytywanie, a nie zapis pliku (to wymaga nieco innych komunikat|fffd|w)
'(Stworzona aby ostrzega|fffd| przed nazwami, kt|fffd|re s|fffd| niepoprawne z punktu widzenia serwer|fffd|w MF)
Function IsValidFileName(ByVal Path As String, Optional ByVal ForImport As Boolean = False) As Variant
    Dim FileName As String, msg As String, i As Integer
    'Wyodr|fffd|bnienie nazwy pliku:
    FileName = GetFileName(Path)
    'Analiza nazwy:
    msg = "" 'Zak|fffd|adamy, |fffd|e b|fffd|dzie dobrze.
    For i = 1 To Len(FileName)
        'Sprawd|fffd| czy znak jest w|fffd|a|fffd|ciwy:
        If Mid(FileName, i, 1) Like "[A-Za-z0-9_.-]" Then
            If i > 55 Then
                Dim excess As Integer, word As String
                excess = (Len(FileName) - i)
                Select Case excess
                       Case 1: word = GetText("1char")
                       Case 2, 3, 4: word = GetText("2-4chars")
                Case Else
                        word = GetText(">4chars")
                End Select
                msg = GetText("TooLongFileName", excess, word)
                Exit For
            End If
        Else
            msg = GetText("WrongFileNameChar", i, Mid(FileName, i, 1), FileName)
            Exit For
        End If
    Next i
    If msg <> "" Then
         Dim answer As Integer
         If ForImport Then
            answer = MsgBox(GetText("CorrectThisImportFileName?", msg), vbExclamation Or vbOKCancel Or vbDefaultButton1, GetText("Warning"))
         Else
            answer = MsgBox(GetText("CorrectThisExportFileName?", msg), vbExclamation Or vbYesNoCancel Or vbDefaultButton1, GetText("Warning"))
         End If
         Select Case answer
            Case vbYes: IsValidFileName = False
            Case vbNo: IsValidFileName = True
            Case vbCancel: IsValidFileName = Null
         End Select
    Else
        IsValidFileName = True
    End If

End Function

'Pomocnicza funkcja: Zwraca True, gdy podana kom|fffd|rka jest wskazanym w argumentach obszarem nazwanym z podanego arkusza
'Argumenty:
'   UpdatedCell:    analizowana kom|fffd|rka (pojedyncza!)
'   WatchedArea:    nazwa obszaru, kt|fffd|rym mo|fffd|e byc kom|fffd|rka (UWAGA: r|fffd|wnie dobrze taki obszar mo|fffd|e nie istnie|fffd|)
'   Sheet:          arkusz, na kt|fffd|rym jest zdefiniowany obszar <WatchedArea> (mo|fffd|e go tam nie by|fffd|)
Private Function IsWatchedCell(ByVal UpdatedCell As Range, ByVal WatchedArea As String, ByVal Sheet As Worksheet) As Boolean
    Dim cell As Range
    IsWatchedCell = False
    Set cell = GetRangeFor(WatchedArea, Sheet) 'Ta nazwa mo|fffd|e nie istnie|fffd|
    If cell Is Nothing Then Exit Function 'Wtedy: to nie jest odpowiedni arkusz
    If Not IsNumeric(cell.value) Then Exit Function
    If UpdatedCell.Address <> cell.Address Then Exit Function 'Ta procedura ma by|fffd| wywo|fffd|ywana tylko po zmianie pozycji listy [WyborWariantu]
    IsWatchedCell = True
End Function
'Pomocnicza procedura, zabezpieczaj|fffd|ca przed przypadkowym zablokowaniem kom|fffd|rek Excela podczas wklejania
'Argumenty:
'   Target:   uaktualnione kom|fffd|rki
'Wywo|fffd|ywa|fffd| w zdarzeniu Worksheet_Change()
Sub PreventFieldProtetction(ByVal Target As Range)
    If Target.Worksheet.ProtectContents And Target.Locked Then
          Dim UndoExpr As String, PasteCmd As String
          Dim UndoBox As Object
          On Error Resume Next
          ' nazwy CommandBars s|fffd| niezale|fffd|ne od j|fffd|zyka:
          With Application.CommandBars("Standard") 'Odczytujemy zawarto|fffd||fffd| kontrolek (niezale|fffd|nie od wersji j|fffd|zykowej Excela)
            UndoExpr = .FindControl(Id:=UndoListCtrlId).list(1) 'Tekst z listy Undo to co|fffd| w rodzaju: "Wklej specjalnie"
            PasteCmd = Replace(.FindControl(Id:=PasteCtrlId).Caption, "&", "") 'Nazwa polecenia "Paste" w tej wersji j|fffd|zykowej
          End With
          'W przypadku b|fffd||fffd|du w odczycie kontrolek, poni|fffd|ej InStr("","") zwraca 0:
          If InStr(UndoExpr, PasteCmd) = 1 Then 'Je|fffd|eli ta zmiana to efekt polecenia "Wklej" (tekst ostatniego polecenia zaczyna si|fffd| od tego s|fffd|owa)
            Application.Undo
                Target.Worksheet.PasteSpecial Format:="HTML", NoHTMLFormatting:=True 'to dzia|fffd|a tak|fffd|e na Excel i tekst (OK)
            If Err.Number <> 0 Then
                MsgBox GetText("PastedProtectedContent")
            End If
          End If
          Err.Clear
    End If
End Sub
'Procedura do wywo|fffd|ywania w Worksheet.OnChange i w SectionVariantListClicked
'Argumenty:
'   UpdatedCells: adres zmodyfikowanych kom|fffd|rek (podawany,
'                 aby nie duplikowa|fffd| w ka|fffd|dym arkuszu logiki rozstrzygania "czy co|fffd| w og|fffd|le robi|fffd|")
Sub UpdateRowVisibility(ByVal UpdatedCells As Range)
    If UpdatedCells.row > 1 Then Exit Sub 'To nie nasza sprawa
    If InCriticalSection Then Exit Sub 'Wida|fffd| t|fffd| zmian|fffd| spowodowa|fffd|a inna procedura tego programu (kt|fffd|ra nie |fffd|yczy sobie domyslnej obs|fffd|ugi)
    Dim Sheet As Worksheet, cell As Range, SheetProtect
    Set Sheet = UpdatedCells.Worksheet

        Dim value As Long, Pos, spos, i As Integer, row As Range, result As Long
        Dim cursor
        
        If IsWatchedCell(UpdatedCells, ListPosName, Sheet) _
           Or IsWatchedCell(UpdatedCells, SubPosName, Sheet) Then
            Pos = GetValueOf(ListPosName, Sheet)
            spos = GetValueOf(SubPosName, Sheet)
        Else
            Exit Sub 'To nie nasza sprawa...
        End If
        
        If IsEmpty(spos) Then
            value = 2 ^ Pos
        Else
            If spos = 0 Then spos = 1 '0 si|fffd| zdarza np. w RZiS dla JednostkiOp
            value = (2 ^ spos) * &H10000 + (2 ^ Pos) 'maska podpozycji jest przesuni|fffd|ta o 16 bit|fffd|w w lewo
        End If
        
        SheetProtect = UnprotectSheet(Sheet)
        If IsEmpty(SheetProtect) Then Exit Sub  'Nie uda|fffd|o si|fffd| zdj|fffd||fffd| ochrony skoroszytu
                                                'nic (komunikat wy|fffd|wietli|fffd| UnprotectSheet())

        Application.StatusBar = GetText("FormUpdating")
        
        cursor = Application.cursor
        Application.cursor = xlWait
        DisableScreenUpdating DisableCalc:=True
        
    On Error GoTo ErrHandler
        For i = 2 To MaxRows
            Set row = Sheet.Rows(i)
            'Ustalenie warto|fffd|ci Show:
            Set cell = row.cells(1)
            If Not IsEmpty(cell) And IsNumeric(cell) Then
                result = CLng(cell.value) And value
                row.Hidden = (result <> value) Or row.cells(2) = "P" 'Liter|fffd| "P" w kolumnie B oznaczamy dodatkowe nag|fffd||fffd|wki stron, pokazywane tylko na czas wydruku
            End If
        Next i
        
        UpdateListButtons Sheet, MaxRows 'Aktualizacja ew. marker|fffd|w list jednostek zale|fffd|n
        UpdateSectionButtonsVisibility Sheet 'Aktualizacja ew. przycisk|fffd|w zwijaj|fffd|cych/rozwijaj|fffd|cych sekcje z podpozycjami
ErrHandler:
        If Err.Number <> 0 Then MsgBox Err.Description & vbCr & "(" & Hex(Err.Number) & ")", vbExclamation, GetText("UnexpectedError")
        EnableScreenUpdating
        Application.cursor = cursor
        RestoreStatusBar
        ProtectSheet Sheet, SheetProtect 'Je|fffd|eli arkusz by|fffd| chroniony - zabezpiecz go z powrotem
End Sub
'Gdy zawarto|fffd||fffd| kom|fffd|rki zmienia kontrolka, nie jest generowane zdarzenie Worksheet.Change
'Dlatego do klikni|fffd|cia w taka list|fffd| nale|fffd|y przypisa|fffd| poni|fffd|sz|fffd| procedur|fffd|:
Sub SectionVariantListClicked()
    Dim Target As Object
    Set Target = GetClickedObject()
    If TypeName(Target) = "Range" Then 'Po klikni|fffd|ciu w list|fffd| rozwijaln|fffd| dostajemy pole pod klikni|fffd|t|fffd| list|fffd|...
        Dim cell As Range
        Set cell = GetRangeFor(ListPosName, Target.Worksheet)
        If cell Is Nothing Then
            'nic
        Else
            UpdateRowVisibility cell
        End If
    End If
End Sub
'Uaktaulnia widoczno|fffd||fffd| wszystkich arkuszy skoroszytu odpowiednio do wariantu raportu wybranego w li|fffd|cie arkusza "nag|fffd||fffd|wek"
'(lub jej pozycji, przechowywanej w arkuszu "techniczne")
Sub ResetLayoutForCurrentReport()
    Dim def As New ReportDef
    def.Initialize 'wywo|fffd|anie konstruktora bez podania numeru wariantu raportu odczytuje ten numer z arkusza "techniczne"
    def.ApplyToLayout 'Dostosowanie wygl|fffd|du poszczeg|fffd|lnych arkuszy (w ka|fffd|dym z nich taka zmiana wywo|fffd|uje zdarzenia OnChange)
End Sub
'Metoda czy|fffd|ci wszystkie pola zwi|fffd|zane z SF
'Argumenty:
'   AllAreas: gdy False - zachowaj dane w polach odpowiednio oznaczonych na li|fffd|cie mapowania
'   WithDefaults: gdy True - wstawiaj w kom|fffd|rki domy|fffd|lne warto|fffd|ci i formu|fffd|y
'Informacyjnie: zwraca liczb|fffd| wzyerowanych p|fffd|l
Function ClearDataFields(Optional ByVal AllAreas As Boolean = True, Optional ByVal WithDefaults As Boolean = True)
    Dim list As Range, row As Range, item As MappedField
    Dim cleared As New Collection 'Kolekcja w kt|fffd|rej kluczami s|fffd| adresy p|fffd|l, kt|fffd|re ju|fffd| zostaly oczyszczone (aby si|fffd| nie dublowa|fffd|)
    
    Application.cursor = xlWait
    DisableScreenUpdating DisableCalc:=True
    On Error GoTo ErrHandler
        SetReconciliationStatus False 'Zerujemy ewentualne flagi niezgodno|fffd|ci
        Set list = Range(MapDefinitionsName)
        For Each row In list.Rows
            Set item = New MappedField
            item.Initialize row
            If item.DataType = "ErrorMark" Or Not item.IsValid Then
                'pomi|fffd| - ErrorMark to tylko pomocniczy znacznik do pokazywania b|fffd||fffd|d|fffd|w
            Else
                If Not KeyExists(Adr(item.cell), cleared) Then
                    item.ResetExcelField (Not AllAreas), WithDefaults
                    cleared.Add item, Adr(item.cell) 'Praktycznie zawarto|fffd||fffd| tej listy jest bez znaczenia: licz|fffd| si|fffd| same klucze!
                End If
            End If
        Next row

ErrHandler:
    If Err.Number <> 0 Then 'czy podczas przetwarzania wyst|fffd|pi|fffd| b|fffd||fffd|d?
        If Err.Number = vbObjectError Then 'B|fffd||fffd|d ju|fffd| zasygnalizowany (por. MarkXMLValueError())
            Application.StatusBar = GetText("OperationFailed")
            RestoreStatusBar StatusBarDelay
        Else
            MsgBox GetText("ExportFailed", Err.Description), vbCritical, GetText("UnexpectedError")
        End If
    End If
    
    'Odtwarzamy stan Excela i wychodzimy:
    EnableScreenUpdating
    Application.cursor = xlDefault
    ClearDataFields = cleared.count
End Function
'Czy|fffd|ci wszystkie pola raportu tego skoroszytu
Public Sub ClearFields()
    ClearDataFields AllAreas:=True
End Sub
'Czy|fffd|ci wybi|fffd|rczo (pozostawia nag|fffd||fffd|wek i opis polityk rachunkowo|fffd|ci bez zmian)
Public Sub ClearListsOnly()
    ClearDataFields AllAreas:=False
End Sub

'Funkcja pr|fffd|buje "odbezpieczy|fffd|" podany arkusz (zdj|fffd||fffd| ochron|fffd|). Zawsze wyst|fffd|puje w parze z ProtectSheet.
'Argumenty:
'   sheet:  arkusz, kt|fffd|ry nale|fffd|y odbezpieczy|fffd|
'   PreserveSelection: [opcjonalne] czy zachowa|fffd| wyb|fffd|r pola w momencie wywo|fffd|ania tej procedury? Domy|fffd|lnie: Tak
'Zwracane warto|fffd|ci:
'   1. gdy arkusz nie by|fffd| zabezpieczony: False
'   2. gdy uda|fffd|o si|fffd| odbezpieczy|fffd| bez has|fffd|a: ""
'   3. gdy uda|fffd|o si|fffd| odbezpieczy|fffd| ze standardowym has|fffd|em:  zwraca tekst has|fffd|a
'   4. gdy nie uda|fffd|o si|fffd| odbezpieczy|fffd| (zapewne zmieniono has|fffd|o): Empty
Function UnprotectSheet(ByVal Sheet As Worksheet, Optional ByVal PreserveSelection As Boolean = True)
    Dim csheet As Worksheet
    If Not (Sheet Is ActiveSheet) Then
        Set csheet = ActiveSheet
        DisableScreenUpdating 'Aby nie "mruga|fffd|" ekranem
        Sheet.Activate 'Okazuje si|fffd|, |fffd|e mo|fffd|emy tylko odbezpiecza|fffd| aktywny arkusz!
    Else
        Set csheet = Nothing
    End If
    
    If Sheet.ProtectContents = False Then
        UnprotectSheet = False
        GoTo EndSub 'arkusz nie jest zabezpieczony
    End If
    
    On Error Resume Next
    '2019-02-13: nigdy nie zdradzamy has|fffd|a: (poni|fffd|sze wykrywanie pustego powodowa|fffd|o w niekt|fffd|rych Excelach okna z pytaniem o has|fffd|o)
    'ActiveSheet.Unprotect ""
    'Err.Clear
    'If Sheet.ProtectContents = False Then
    '    UnprotectSheet = "" 'Ochrona nie mia|fffd|a has|fffd|a
    '    GoTo EndSub
    'End If
    
    ActiveSheet.Unprotect SheetProtectionPwd 'To zadzia|fffd|a tak|fffd|e dla pustego has|fffd|a (ale zwrotnie nadamy has|fffd|o domy|fffd|lne)
    If Sheet.ProtectContents = True Then
        If Err.Number = 1004 Then 'Z|fffd|e has|fffd|o sygnalizujemy w oknie dialogowym, aby uzytkownik dostrzeg|fffd|, |fffd|e co|fffd| jest nnie tak:
            MsgBox GetText("UnknownProtectionPwd"), vbCritical, GetText("UnexpectedError")
        Else
            MsgBox GetText("CannotUnprotect"), vbCritical, GetText("UnexpectedError")
        End If
        RestoreStatusBar StatusBarDelay
        UnprotectSheet = Empty
        Err.Clear
    Else
        UnprotectSheet = SheetProtectionPwd
    End If
    
EndSub:
    'Zapamietujemy aktualn|fffd| selecj|fffd| na stosie:
    If mySelectionStack Is Nothing Then Set mySelectionStack = New Collection
    If Not IsEmpty(UnprotectSheet) And PreserveSelection Then
        mySelectionStack.Add Selection, ActiveSheet.Name 'Dla porz|fffd|dku dodaj|fffd| nazw|fffd| arkusza jako klucz.
    End If
    'Czy|fffd|cimy po sobie:
    If Not (csheet Is Nothing) Then
        csheet.Activate
        EnableScreenUpdating
    End If
End Function
'Blokuje arkusz podanym has|fffd|em:
'Argumenty:
'   sheet:  arkusz, kt|fffd|ry nale|fffd|y zabezpieczy|fffd|
'   password: has|fffd|o zabezpieczaj|fffd|ce (je|fffd|eli "" - zabezpiecz bez has|fffd|a, je|fffd|eli Empty lub False - nie zabezpieczaj, gdy Empty - niczego nie zmieniaj)
'   SelectionIsPreserved: [opcjonalne] czy w UnprotectSheet zachowano stan selekcji? Domy|fffd|lnie: Tak
Sub ProtectSheet(ByVal Sheet As Worksheet, ByVal password, Optional ByVal SelectionIsPreserved As Boolean = True)
    If IsEmpty(password) Then Exit Sub

    'Pr|fffd|bujemy odtworzy|fffd| zachowan|fffd| selekcj|fffd|:
    If Not IsEmpty(password) And SelectionIsPreserved Then
        On Error Resume Next
            Dim sel As Object
            Set sel = mySelectionStack(mySelectionStack.count)
            mySelectionStack.Remove mySelectionStack.count
            If Not (sel Is Selection) And (ActiveSheet Is Sheet) Then
                sel.Select
            End If
            Err.Clear
        On Error GoTo 0
    End If
    If password = False Then Exit Sub 'Arkusz nie by|fffd| zabezpieczony: wi|fffd|c tego nie zmieniaj
    
    If password = "" Then
        Sheet.Protect DrawingObjects:=True, contents:=True, Scenarios:=True
    Else
        Sheet.Protect password:=password, DrawingObjects:=True, contents:=True, Scenarios:=True
    End If
End Sub
'Pomocnicza funkcja (dla wi|fffd|kszej czytelno|fffd|ci kodu)
'Zwraca nazw|fffd| pliku, wskazanego przez u|fffd|ytkownika, lub Empty gdy zrezygnowa|fffd|
Private Function SelectAttachementFile()
        Dim FileName, NameIsValid
        
        Do 'P|fffd|tla na ewentualn|fffd| poprawk|fffd| nazwy pliku, gdy nieodpowiednia z punktu widzenia MF.
            FileName = Application.GetOpenFilename(FileFilter:=GetText("AttFileFilter"), _
                                                        Title:=GetText("SelectAttachement"), Buttontext:=GetText("AttachFile"))
            If VarType(FileName) = vbString Then
                NameIsValid = IsValidFileName(FileName, ForImport:=True)  'Ostrze|fffd|enie przed nieprawid|fffd|ow|fffd| nazw|fffd| z punktu widzenia MF
                If IsNull(NameIsValid) Then FileName = False 'U|fffd|ytkownik zrezygnowa|fffd|
            Else
                NameIsValid = Null
            End If
        Loop While NameIsValid = False
        If Not NameIsValid Then
            SelectAttachementFile = Empty
        Else
            SelectAttachementFile = FileName
        End If
End Function
'Obs|fffd|uga przycisku za|fffd||fffd|cznika (arkusz "Informacje Dodatkowe")
Sub AttachementButtonClick()
    Dim Target As Object
    Set Target = GetClickedObject()
    If TypeName(Target) = "Rectangle" Then 'Po klikni|fffd|ciu w przycisk 'Uwaga! klin|fffd|ty jest Shape.DrawingObject, a nie sam Shape!
        Dim pwd
        pwd = UnprotectSheet(Target.TopLeftCell.Worksheet)
        If IsEmpty(pwd) Then Exit Sub 'ew. komunikaty pojawi|fffd| si|fffd| w UnprotectSheet
        
        On Error GoTo ErrHandler
        
        Dim att As New Attachement
        att.Initialize Button:=Target
        Select Case Target.Caption
            Case AttAssignedCaption:    'Prycisk ma przypisany za|fffd||fffd|cznik
                    att.Remove
            Case AttEmptyCaption:       'Przycisk nie ma przypisanego za|fffd||fffd|cznika
                    Dim Path
                    Path = SelectAttachementFile()
                    If VarType(Path) = vbString Then 'Jezeli uzytkownik nie zrezygnowa|fffd| z operacji:
                        att.Insert Path:=Path
                    End If
            Case Else
                'Nic
        End Select
        
        Err.Clear 'Gdy wykonanie dosz|fffd|o do tej linii - lepiej usun|fffd||fffd| ewentualne "echa": b|fffd||fffd|dy po przeliczaniu arkusza
ErrHandler:
        If Err.Number <> 0 Then MsgBox Err.Description & vbCr & "(" & Hex(Err.Number) & ")", vbExclamation, GetText("UnexpectedError")
        ProtectSheet Target.TopLeftCell.Worksheet, pwd
    End If
End Sub
'Obs|fffd|uga otwierania za|fffd||fffd|cznika (arkusz "Informacje Dodatkowe", "Import - uwagi")
Sub AttachementClick()
    On Error GoTo ErrHandler

    Dim Target As Object
    Set Target = GetClickedObject()
    If TypeName(Target) = "OLEObject" Then 'Po klikni|fffd|ciu w za|fffd||fffd|cznik

        Dim att As New Attachement
        att.Initialize Obj:=Target
        att.Show
    End If
ErrHandler:
    If Err.Number <> 0 Then MsgBox Err.Description & vbCr & "(" & Hex(Err.Number) & ")", vbExclamation, GetText("UnexpectedError")
End Sub
'Pomocnicza procedura, zwi|fffd|zana z ukrywaniem/odkrywaniem kotrolek w arkuszu "Wprowadzenie", dla JednostkaInna:P6
'Argumenty:
'   traget: zmieniony obszar na arkuszu
Sub UpdateP6Controls(ByVal Target As Range)
    Dim P6 As Range, Sheet As Worksheet
    If Target Is Nothing Then Exit Sub
    Set Sheet = Target.Worksheet
    Set P6 = GetRangeFor("JednostkaInna_P6", Sheet)
    If P6 Is Nothing Then Exit Sub 'Co|fffd| nie tak
    If P6.EntireRow.Hidden Then Exit Sub 'Nie zajmuj si|fffd| sekcj|fffd| ukryt|fffd|

    If P6.Address = Target.Address Then 'Zmieniono kom|fffd|rk|fffd| steruj|fffd|c|fffd|
        Dim P_6A As Range, Dropdown As shape
        Set Dropdown = GetShapeFor("JednostkaInna_P_6A", Sheet)
        Set P_6A = Range("JednostkaInna_P_6A")
        If Dropdown Is Nothing Then Exit Sub 'Co|fffd| nie tak
        If P6.value = 1 Then 'Z listy wybrano "Tak"
            Dropdown.Visible = msoTrue
            If IsEmpty(P_6A) Then P_6A.value = 2
        Else 'z listy P6 wybrano "Nie" lub jest pusta: ukrywamy dropdown
            Dropdown.Visible = msoFalse
            P_6A.value = Empty
        End If
    End If
End Sub
'Metoda, kt|fffd|r|fffd| nale|fffd|y przypisa|fffd| do listy zwi|fffd|zanej z polem "JednostkaInna_P6"
'(gdy|fffd| zmiany dokonane przez list|fffd| nie wywo|fffd|uj|fffd| zdarzenia Data_Changed, do kt|fffd|rego mamy przypisan|fffd| obs|fffd|ug|fffd|)
Sub P6ListClicked()
    Dim Target As Object
    Set Target = GetClickedObject()
    If TypeName(Target) = "Range" Then 'Po klikni|fffd|ciu w list|fffd| rozwijaln|fffd| dostajemy pole pod klikni|fffd|t|fffd| pozycj|fffd| na li|fffd|cie rozwijalnej...
        UpdateP6Controls GetRangeFor("JednostkaInna_P6") 'dlatego nie mo|fffd|emy skorzysta|fffd| z <target>, bo jest "przestrzelony" o 2-3 wiersze
    End If
End Sub
'Metoda uaktualnia formaty liczb w zale|fffd|no|fffd|ci od aktualnie wybranej bazy (w tys/w z|fffd|)
'Informacyjnie: zwraca liczb|fffd| wzyerowanych p|fffd|l
Sub UpdateAmountFormats()
    Dim def As New ReportDef, sec As Section
On Error GoTo ErrHandler
    Application.cursor = xlWait
    DisableScreenUpdating
    def.Initialize 'tego obiektu potrzebujemy tylko do sekcji:
    For Each sec In def.sections
        If sec.Id <> "Nag|fffd||fffd|wek" Then 'Nag|fffd||fffd|wek ma inne has|fffd|o, ale na szcz|fffd|cie nie ma p|fffd|l z kwotami
            sec.UpdateAmountFormats 'Obs|fffd|uga ew. b|fffd||fffd|d|fffd|w wewn|fffd|trz tych procedur
        End If
    Next sec
ErrHandler:
    If Err.Number <> 0 Then MsgBox Err.Description & vbCr & "(" & Hex(Err.Number) & ")", vbExclamation, GetText("UnexpectedError")
    EnableScreenUpdating
    Application.cursor = xlDefault
End Sub
'Wywo|fffd|ywa|fffd| w arkuszu "techniczne", gdy zmieni|fffd|o si|fffd| pole z baz|fffd| liczb:
'Argumenty:
'   target: kom|fffd|rki, ktore uleg|fffd|y zmianie
Sub OnChangeAmountBase(ByVal Target As Range)
    If IsWatchedCell(Target, AmountBaseName, Target.Worksheet) Then
        UpdateAmountFormats
    End If
End Sub
'Zwraca przycisk zwi|fffd|zany ze wskazan|fffd| kom|fffd|rk|fffd|, lub Nothing gdy nie istneje
'Argumenty:
'   Cell:         kom|fffd|rka, z kt|fffd|r|fffd| zwi|fffd|zany ma by|fffd| kszta|fffd|t
'   SoughtType:   typ szukanego Shape: "Rectangle", albo "Picture" (to przyciski) lub "OLEObject"
Function FindShapeFor(ByVal cell As Range, ByVal SoughtType As String) As shape
    Dim Shp As shape
    Set FindShapeFor = Nothing
    For Each Shp In cell.Worksheet.Shapes
        If Shp.TopLeftCell.Address = cell.Address And TypeName(Shp.DrawingObject) = SoughtType Then
            Set FindShapeFor = Shp
            Exit For 'Znale|fffd|li|fffd|my
        End If
    Next Shp
End Function
'***********************************
'Funkcja wydruku musi kompensowa|fffd| b|fffd||fffd|d wyst|fffd|puj|fffd|cy w Excelu 2010 (i wcze|fffd|niejszych?):
'otworzenie podlgl|fffd|du wydruku dla zestawu wielu arkuszy w Excelu 2010 przesuwa listy rozwijalne.
'Gdy przez przypadek tak "zeputy" plik zostanie zapisany - zmiany zostaj|fffd| utrwalone.
'St|fffd|d du|fffd|a cz|fffd||fffd| logiki w poni|fffd|szych 3 procedurach jest po|fffd|wi|fffd|cona na skompensowanie tego b|fffd||fffd|du
'***********************************
'*
'*
'Pomocnicza funkcja: zwraca miar|fffd| po|fffd|o|fffd|enia zespo|fffd|u list rozwijalnych na arkuszu "Wprowadzenie"
'Argumenty:
'   Sheet: arkusz, na kt|fffd|rym sprawdzamy listy rozwijalne
'(do por|fffd|wnania przed i po wydruku, by stwierdzi|fffd| czy arkusz zosta|fffd| zepsuty, czy nie)
Private Function DropDownMeasure(ByVal Sheet As Worksheet) As Double
    Dim Shp As shape, result As Double
    result = 0
    For Each Shp In Sheet.Shapes
        If Shp.Type = msoFormControl Then
            If Shp.FormControlType = xlDropDown Then
                Dim offsetX As Double, offsetY As Double
                offsetX = Shp.Left - Shp.TopLeftCell.Left
                offsetY = Shp.Top - Shp.TopLeftCell.Top
                result = result + Abs(offsetX) + Abs(offsetY) 'Sumujemy przesuni|fffd|cia kontrolek od przypisanych im kom|fffd|rek arkusza
            End If
        End If
    Next Shp
    DropDownMeasure = result
End Function
'Pomocnicza: otwiera modealne okno dialogowe wydruku
Private Sub ShowPrintDialog()
    'Application.CommandBars.ExecuteMso "PrintPreviewAndPrint"' uruchamia niemodalne polecenie (i na tym trzeba zako|fffd|czy|fffd|...)
    'W Excelu 2010 xlDialogPrintPreview powoduje przestawienie miejsca, w kt|fffd|rym otwieraj|fffd| si|fffd| listy rozwijalne:
    'a w Excelu 2016 nie pokazuje poprawnie list rozwijalnych w dolnej cz|fffd|ci arkusza "Wprowadzenie".
    'Dlatego zdecydowa|fffd|em sie pokazywa|fffd| ubo|fffd|sze okienko wydruku, a nie okno podgl|fffd|du.
    'Wywolanie tego okna spowalnia potem bardzo operacje w Excelu 2010:
    
    'Application.Dialogs(xlDialogPrint).Show 'Gdy u|fffd|ytkownik zechce, to mo|fffd|e w nim uruchomi|fffd| podgl|fffd|d wydruku
    'A potem okaza|fffd|o si|fffd|, |fffd|e u|fffd|ytkownikom i tak zale|fffd|y przede wszystkim na "wydruku" do PDF:
     Application.Dialogs(xlDialogSaveAs).Show Split(ActiveWorkbook.Name, ".")(0), FormatPDF
    'On Error Resume Next 'Nie wiem czy we wcze|fffd|niejszych wersjach poni|fffd|sza linia nie wywo|fffd|a to b|fffd||fffd|du...
    'Z niewiadomych przyczyn Dialogs(xlDialogPrintPreview) otwiera w Excel 2016 pasek boczny formatowania obiektu: trzeba go schowa|fffd|...
    'If Application.CommandBars("Format Object").Visible = True Then Application.CommandBars("Format Object").Visible = False
    'Err.Clear
    
End Sub

Sub PrintReportDlg()
    Dim def As New ReportDef, sections As Collection
    Dim WkbName As String, Backup As String, Temp As String, DropdownsBefore As Double 'Zmienne do kompensaty b|fffd||fffd|du w Excelu 2010
    If Val(Application.version) < 14 Then 'Excel 2007 to 13
        MsgBox GetText("OlderExcelNotSupported"), vbInformation
        Exit Sub
    End If
    On Error GoTo ErrHandler
    'Dodajemy w oznaczonych miejscach dodatkowe podzia|fffd|y stron:
    def.Initialize 'tego obiektu potrzebujemy tylko do sekcji:
    Set sections = def.sections
    If Val(Application.version) < 15 Then '(na wypadek, gdyby u|fffd|ytkownik wszed|fffd| do podgl|fffd|du wydruku i Excel poprzesuwa|fffd| listy rozwijalne)
        DropdownsBefore = DropDownMeasure(sections("Wprowadzenie").Sheet) 'Miara poprawnego po|fffd|o|fffd|enia list
        
        Backup = Environ("temp") & "\" & ActiveWorkbook.Name
        If FileExists(Backup) Then Kill Backup
        
        Temp = Environ("temp") & "\" & DamagedName 'Ewentualne sprz|fffd|datnie pozosta|fffd|o|fffd|ci po poprzedniej operacji
        If FileExists(Temp) Then Kill Temp
        
        ActiveWorkbook.SaveCopyAs Backup 'Zapisujemy "kopi|fffd| bezpiecze|fffd|stwa" tego pliku
    End If
    Dim CurSheet As Worksheet, sec As Section, SectionLabels As New Collection
    DisableScreenUpdating
        For Each sec In sections
            If sec.Sheet.Visible = xlSheetVisible Then
                sec.ShowAdditionalPageBreaks
                SectionLabels.Add sec.Label
            End If
        Next sec
    EnableScreenUpdating
    'Wybieramy wszystkie arkusze raportu:
    Set CurSheet = ActiveSheet
    Sheets(CollectionToArray(SectionLabels)).Select
    CurSheet.Activate
    'Otwieramy okno dialogowe podgl|fffd|du wydruku:
    ShowPrintDialog
    'Prze|fffd||fffd|czamy selekcj|fffd| arkuszy z powrotem na oryginalny
    CurSheet.Select
    'W Excelu 2010 i wcze|fffd|niejszych sprawdzamy, czy nie zosta|fffd|y przesuni|fffd|te listy:
    If Application.version < "15.0" Then '(na wypadek, gdyby u|fffd|ytkownik wszed|fffd| do podgl|fffd|du wydruku i Excel poprzesuwa|fffd| listy rozwijalne)
        If DropdownsBefore <> DropDownMeasure(sections("Wprowadzenie").Sheet) Then 'Listy zosta|fffd|y przesuni|fffd|te!
            Dim Damaged As Workbook, Restored As Workbook
            WkbName = ActiveWorkbook.Path & "\" & ActiveWorkbook.Name 'Zapami|fffd|tajmy nazw|fffd| pliku docelowego...
            Set Damaged = ActiveWorkbook
            Damaged.SaveAs Temp
            Set Restored = Workbooks.Open(Backup)
            Restored.Activate
            On Error Resume Next 'Je|fffd|eli linia poni|fffd|ej wywo|fffd|a b|fffd||fffd|d - trudno, jako|fffd| b|fffd|dzie trzeba z tym |fffd|y|fffd|...
            Application.DisplayAlerts = False 'Aby nie by|fffd|o pytania, czy nadpisa|fffd|
            Restored.SaveAs WkbName 'Podstawiamy kopi|fffd| bezpiecze|fffd|staw w miejsce dotychczasowego pliku
            Application.DisplayAlerts = True
            If Err.Number <> 0 Then
                 Dim answer
                 answer = MsgBox(GetText("Excel2010PrintPreviewBug", WkbName), vbQuestion Or vbDefaultButton1 Or vbYesNo, GetText("Warning"))
                 If answer = vbYes Then
                    Application.Dialogs(xlDialogSaveAs).Show
                 End If
                 Err.Clear
            Else
                Kill Backup
            End If
            Damaged.Close SaveChanges:=False
            Exit Sub
        Else 'B|fffd||fffd|d si|fffd| nie pojawi|fffd| (u|fffd|ytkownik nie otworzy|fffd| podgl|fffd|du wydruku)
            If FileExists(Backup) Then Kill Backup 'usuwamy w takim razie nasz|fffd| "kopi|fffd| bezpiecze|fffd|stwa"
        End If
    End If
    'Ukrywamy podzia|fffd| stron
    DisableScreenUpdating
        For Each sec In sections
            sec.HideAdditionalPageBreaks
        Next sec
ErrHandler:
    If Err.Number <> 0 Then MsgBox Err.Description & vbCr & "(" & Hex(Err.Number) & ")", vbExclamation, GetText("UnexpectedError")
    EnableScreenUpdating
End Sub

'***********************************
'Funkcje do obs|fffd|ugi list jednostek z arkusza "Wprowadzenie" (wyst|fffd|puj|fffd| w raporcie skonsolidowanym)
'Listy s|fffd| ograniczone z g|fffd|ry i z do|fffd|u szarym, w|fffd|skim wierszem, kt|fffd|ry w kt|fffd|ry w kolumnie "C" zawiera s|fffd|owo "break"
'Przycisk Up jest umieszczony w wierszu powy|fffd|ej tego ograniczenia, a Down - poni|fffd|ej.
'W kolumnie "C" wierszy listy oddzielaj|fffd|cych kolejne jednostki znajduj|fffd| sie informacje z ilo|fffd|ciami wierszy do ukrycia/pokazania
'w pierwszym wierszu segmentu jednostki jest informacja o wysoko|fffd|ci (w wierszach) tego segmentu. Ta informacja jest powt|fffd|rzona
'w ostatnim wierszu segmentu. Segmenty tworz|fffd| w ten spos|fffd|b ci|fffd|g kolejnych informacji, po kt|fffd|rych "poruszaj|fffd|" si|fffd| przyciski
'Up/Down, umieszczone przy zawsze widocznym ograniceniu listy
'***********************************
'Pomocnicza funkcja: usuwa zawarto|fffd||fffd| ew. odblokowanych p|fffd|l we wskazanym wierszu (aby wszystkie ukryte segmenty by|fffd|y puste)
'Argumenty:
'   Row: ukrywany wiersz
Private Sub ClearUserFields(ByVal row As Range)
    Dim cell As Range, i As Integer
    For i = HiddenColumn + 1 To ListButtonColumn
        Set cell = row.cells(i)
        If Not cell.Locked Then cell.formula = ""
    Next i
End Sub
'Zwraca przycisk Up/Down - przeciwleg|fffd|y do podanego przycisku
'Argumenty (jeden z nich musi by|fffd| podany):
'   UpButton: g|fffd|rny przycisk. Funkcja zwr|fffd|ci jego dolny
'   DownButton: dolny przycisk. Funkcja zwr|fffd|ci jego g|fffd|rny.
Private Function FindOppositeButton(Optional ByVal UpButton As shape = Nothing, Optional ByVal DownButton As shape = Nothing) As shape
    Dim ref As Range
    Set FindOppositeButton = Nothing
    If Not (UpButton Is Nothing) Then
        Set ref = UpButton.TopLeftCell.EntireRow.Offset(RowOffset:=1) 'wiersz poni|fffd|ej przycisku
        If ref.cells(HiddenColumn) = ListMarker Then
            Set ref = ref.Offset(RowOffset:=1) 'Nast|fffd|pny wiersz powinien zawiera|fffd| przycisk po przeciwnej stronie
            Set FindOppositeButton = FindShapeFor(ref.cells(ListButtonColumn), "Picture") 'Przyciski listy s|fffd| typu "Picture"
        End If
    End If
    If Not (DownButton Is Nothing) Then
        Set ref = DownButton.TopLeftCell.EntireRow.Offset(RowOffset:=-1) 'wiersz powy|fffd|ej przycisku
        If ref.cells(HiddenColumn) = ListMarker Then
            Set ref = ref.Offset(RowOffset:=-1) 'Poprzedni wiersz powinien zawiera|fffd| przycisk po przeciwnej stronie
            Set FindOppositeButton = FindShapeFor(ref.cells(ListButtonColumn), "Picture") 'Przyciski listy s|fffd| typu "Picture"
        End If
    End If
End Function
'Zwraca pole z liczb|fffd| wierszy, zwi|fffd|zane z ostatnim widocznym wierszem obszaru listy
'Argumenty:
'   UpButton: przycisk "Up", zwi|fffd|zany z list|fffd|
Private Function InfoFromLastVisibleRow(ByVal UpButton As shape) As Range
    Dim row As Range
    Set row = UpButton.TopLeftCell.EntireRow.Offset(RowOffset:=-1)  'Wiersz poprzedzaj|fffd|cy przycisk (w nierozwini|fffd|tych listach powinien by|fffd| ukryty)
    While row.row > 1 And row.Hidden And row.cells(HiddenColumn) <> ListMarker 'Szukamy pierwszego odkrytego wiersza lub ko|fffd|ca listy (ze s|fffd|owem "break")
        Set row = row.Offset(RowOffset:=-1)
    Wend
    If row.cells(HiddenColumn) = ListMarker Then Set row = row.Offset(RowOffset:=-1) 'Je|fffd|eli sko|fffd|czy|fffd|a si|fffd| lista - zwr|fffd||fffd| PUSTE pola ponad list|fffd|
    Set InfoFromLastVisibleRow = row.cells(HiddenColumn)
End Function
'Zwraca pole z liczb|fffd| wierszy, zwi|fffd|zane z pierwszym ukrytym wierszem obszaru listy
'Argumenty:
'   DownButton: przycisk "Down", zwi|fffd|zany z list|fffd|
Private Function InfoFromFirstHiddenRow(ByVal DownButton As shape) As Range
    Dim row As Range
    Set row = DownButton.TopLeftCell.EntireRow.Offset(RowOffset:=-3)  'Ostatni wiersz listy (w nierozwini|fffd|tych listach powinien by|fffd| ukryty)
    While row.row > 1 And row.Hidden And row.cells(HiddenColumn) <> ListMarker 'Szukamy pierwszego odkrytego wiersza lub ko|fffd|ca listy (ze s|fffd|owem "break")
        Set row = row.Offset(RowOffset:=-1)
    Wend
    Set row = row.Offset(RowOffset:=1) 'Row to pierwszy widoczny wiersz - przesu|fffd| si|fffd| o 1 wierz do do|fffd|u, by poda|fffd| pole z niewidocznego
    Set InfoFromFirstHiddenRow = row.cells(HiddenColumn)
End Function
'Uaktualnia widoczno|fffd||fffd| podanego przycisku Up / Down
'Argumenty (mog|fffd| by|fffd| tak|fffd|e podane obydwa naraz):
'   UpButton:   g|fffd|rny przycisk steruj|fffd|cy list|fffd|
'   DownButton: dolny przycisk steruj|fffd|cy list|fffd|
Private Sub UpdateListButtonVisibility(Optional ByVal UpButton As shape = Nothing, Optional ByVal DownButton As shape = Nothing)
    Dim Info As Range
    If Not (DownButton Is Nothing) Then
        Set Info = InfoFromFirstHiddenRow(DownButton)
        DownButton.Visible = Not IsEmpty(Info)
    End If
    If Not (UpButton Is Nothing) Then
        Dim UpRow As Range
        Set Info = InfoFromLastVisibleRow(UpButton)
        'Aby |fffd|adniej wygl|fffd|da|fffd|o, po ukryciu przycisku "Up" zmniejszamy wysoko|fffd||fffd| jego wiersza:
        Set UpRow = UpButton.TopLeftCell.EntireRow
        If Not UpRow.Hidden Then 'Mo|fffd|e by|fffd| ukryty, bo ta procedura jest wo|fffd|ana dla ka|fffd|dego wariantu raportu,
        'a przyciski s|fffd| tylko w wariancie skonsolidowanym:
            If IsEmpty(Info) Then
                UpButton.Visible = msoFalse
                UpRow.RowHeight = UpButtonMinHeight
            Else
                UpRow.RowHeight = UpButtonFullHeight
                UpButton.Visible = msoTrue
            End If
        End If
    End If
End Sub
'Procedura uaktualnia widoczno|fffd||fffd| przycisk|fffd|w list po od|fffd|wie|fffd|eniu stanu arkusza (widoczno|fffd|ci jego wierszy).
'(Niekt|fffd|re z wierszy list mog|fffd| by|fffd| ponownie ukryte) - wywo|fffd|ywana w UpdateRowVisibility
'Argumenty:
'   Sheet:      arkusz, kt|fffd|ry ma by|fffd| sprawdzany
'   MaxRows:    liczba wierszy do sprawdzania.
Private Sub UpdateListButtons(ByVal Sheet As Worksheet, MaxRows As Long)
    Dim i As Long, SheetProtect

'   Oryginalnie ta procedura mia|fffd|a by|fffd| wywo|fffd|ywana oddzielnie, st|fffd|d skomentowane linie Unprotect/Protect Sheet:

'    SheetProtect = UnprotectSheet(ActiveSheet, False)
'    If IsEmpty(SheetProtect) Then Exit Sub 'Nie uda|fffd|o si|fffd| zdj|fffd||fffd| ochrony skoroszytu
'        'nic (komunikat wy|fffd|wietli|fffd| UnprotectSheet())
'    On Error GoTo ErrHandler
    If Sheet.Pictures.count = 0 Then Exit Sub 'Przyciski list to elementy typu "Picture" - na tym arkuszu ich nie ma
    'A je|fffd|eli ju|fffd| wiemy, |fffd|e jest szansa, |fffd|e tu s|fffd|: spr|fffd|bujmy znale|fffd||fffd| markery ko|fffd|c|fffd|w list:
    For i = 2 To MaxRows
        If Sheet.cells(i, HiddenColumn) = ListMarker Then
            Dim UpBtn As shape, DownBtn As shape
            Set UpBtn = FindShapeFor(Sheet.cells(i - 1, ListButtonColumn), "Picture")
            Set DownBtn = FindShapeFor(Sheet.cells(i + 1, ListButtonColumn), "Picture")
            UpdateListButtonVisibility UpBtn, DownBtn
        End If
    Next i

'ErrHandler:
'    If Err.Number <> 0 Then MsgBox Err.Description & vbCr & "(" & Hex(Err.Number) & ")", vbExclamation, GetText("UnexpectedError")
    
'    ProtectSheet ActiveSheet, SheetProtect, False 'Je|fffd|eli arkusz by|fffd| chroniony - zabezpiecz go z powrotem
    
End Sub
'Klikni|fffd|to strza|fffd|k|fffd| w g|fffd|r|fffd|
Sub OnClickUp()
    Dim Pict As Picture, Btn As shape, Info As Range, RowCount, SheetProtect
    Set Pict = GetClickedObject
    Set Btn = FindShapeFor(Pict.TopLeftCell, "Picture") 'W ten spos|fffd|b znajdziemy Shape, kt|fffd|ry zawiera to Picture.
    If Btn Is Nothing Then Exit Sub
    
    SheetProtect = UnprotectSheet(ActiveSheet, False)
    If IsEmpty(SheetProtect) Then Exit Sub 'Nie uda|fffd|o si|fffd| zdj|fffd||fffd| ochrony skoroszytu
        'nic (komunikat wy|fffd|wietli|fffd| UnprotectSheet())
    On Error GoTo ErrHandler
    DisableScreenUpdating DisableCalc:=True
    
    Set Info = InfoFromLastVisibleRow(Btn)
    RowCount = Info.cells(1) 'Info to kom|fffd|rka z liczb|fffd| wierszy
    If IsEmpty(RowCount) Then
        Btn.Visible = False 'Przycisk powinien by|fffd| wy|fffd||fffd|czony wcze|fffd|niej
    Else
        Dim i As Integer, Rows As Range
        
        'Najpierw wyczy|fffd|cimy ukrywan|fffd| sekcj|fffd|:
        Set Rows = Info.EntireRow
        For i = 1 To RowCount
            ClearUserFields Rows
        Next i
        
        'Potem j|fffd| ukryjemy:
        Set Rows = Info.EntireRow.Offset(RowOffset:=-RowCount + 1).Resize(RowSize:=RowCount)
        Rows.Hidden = True
        
        'Sprawa widoczno|fffd|ci przeciwleg|fffd|ego przycisku:
        Dim OpBtn As shape
        Set OpBtn = FindOppositeButton(UpButton:=Btn)
        UpdateListButtonVisibility DownButton:=OpBtn
        UpdateListButtonVisibility UpButton:=Btn
    End If
    
    Err.Clear 'Gdy wykonanie dosz|fffd|o do tej linii - lepiej usun|fffd||fffd| ewentualne "echa": b|fffd||fffd|dy po przeliczaniu arkusza
ErrHandler:
    If Err.Number <> 0 Then MsgBox Err.Description & vbCr & "(" & Hex(Err.Number) & ")", vbExclamation, GetText("UnexpectedError")
    EnableScreenUpdating
    ProtectSheet ActiveSheet, SheetProtect, False 'Je|fffd|eli arkusz by|fffd| chroniony - zabezpiecz go z powrotem
    
End Sub

'Klikni|fffd|to strza|fffd|k|fffd| w d|fffd|
Sub OnClickDown()
    Dim Pict As Picture, Btn As shape, Info As Range, RowCount, SheetProtect
    Set Pict = GetClickedObject
    Set Btn = FindShapeFor(Pict.TopLeftCell, "Picture") 'W ten spos|fffd|b znajdziemy Shape, kt|fffd|ry zawiera to Picture.
    If Btn Is Nothing Then Exit Sub
    
    SheetProtect = UnprotectSheet(ActiveSheet, False)
    If IsEmpty(SheetProtect) Then Exit Sub 'Nie uda|fffd|o si|fffd| zdj|fffd||fffd| ochrony skoroszytu
        'nic (komunikat wy|fffd|wietli|fffd| UnprotectSheet())
    On Error GoTo ErrHandler
    DisableScreenUpdating
    
    Set Info = InfoFromFirstHiddenRow(Btn)
    RowCount = Info.cells(1) 'Info to kom|fffd|rka z liczb|fffd| wierszy
    If IsEmpty(RowCount) Then
        Btn.Visible = False 'Przycisk powinien by|fffd| wy|fffd||fffd|czony wcze|fffd|niej
    Else
        Dim i As Integer, Rows As Range
        'Odkrywamy sekcj|fffd| poni|fffd|ej:
        Set Rows = Info.EntireRow.Resize(RowSize:=RowCount)
        Rows.Hidden = False
        'Sprawa widoczno|fffd|ci przeciwleg|fffd|ego przycisku:
        Dim OpBtn As shape
        Set OpBtn = FindOppositeButton(DownButton:=Btn)
        UpdateListButtonVisibility UpButton:=OpBtn
        UpdateListButtonVisibility DownButton:=Btn
    End If
    
    Err.Clear 'Gdy wykonanie dosz|fffd|o do tej linii - lepiej usun|fffd||fffd| ewentualne "echa": b|fffd||fffd|dy po przeliczaniu arkusza
ErrHandler:
    If Err.Number <> 0 Then MsgBox Err.Description & vbCr & "(" & Hex(Err.Number) & ")", vbExclamation, GetText("UnexpectedError")
    EnableScreenUpdating
    ProtectSheet ActiveSheet, SheetProtect, False 'Je|fffd|eli arkusz by|fffd| chroniony - zabezpiecz go z powrotem
    
End Sub
'---------------- Przyciski subsekcji (arkusz "Dodatkowe", sekcje pozycji uszczeg|fffd|awaj|fffd|cych rozliczenie r|fffd|nic pomi|fffd|dzy wynikiem i podatkiem)
'Nazwy tych przycisk|fffd|w zaczynaj|fffd| si|fffd| od s|fffd|owa "Section", i znajduj|fffd| si|fffd| z prawej strony ukrytej kolumny z warto|fffd|ciami: kra|fffd|cowymi "0" i "1" po|fffd|rodku obszaru
'Procedura uaktualnia widoczno|fffd||fffd| przycisk|fffd|w zwi|fffd|/rozwin pozycji do aktualnej widoczno|fffd|ci wierszy.
'Argumenty:
'   Sheet: arkusz, w kt|fffd|rym nale|fffd|y uaktualni|fffd| widoczno|fffd||fffd| przycisk|fffd|w
'Pami|fffd|taj: ta procedura DOPASOWUJE si|fffd| do widoczno|fffd|ci zastanych wierszy (na pewno |fffd|adnego wiersza nie pokazuje ani nie ukrywa)
Private Sub UpdateSectionButtonsVisibility(ByVal Sheet As Worksheet)
    Dim Shp As shape
    For Each Shp In Sheet.Shapes
        If TypeName(Shp.DrawingObject) = "TextBox" And Shp.Name Like "Section*" Then 'To jeden z przycisk|fffd|w sekcji:
        'Sprawd|fffd| jego stan i popraw widoczno|fffd||fffd|, gdy jest to potrzebne:
            Dim cell As Range
            Set cell = Shp.TopLeftCell.Offset(ColumnOffset:=-1) 'W chwili pocz|fffd|tkowej: to kom|fffd|rka z lewej strony przycisku
            Select Case Shp.Name
                Case "SectionShow": 'przycisk rozwijaj|fffd|cy pocz|fffd|tkowy widok subsekcji
                        Set cell = cell.Offset(RowOffset:=1)  'Cell to kom|fffd|rka w wierszu poni|fffd|ej
                        Shp.Visible = cell.EntireRow.Hidden 'Przycisk jest tylko wtedy widoczny, gdy wiersz bezpo|fffd|rednio poni|fffd|ej jest ukryty
                Case "SectionShrink": 'Przycisk zmniejszaj|fffd|cy sekcj|fffd| o 1 pozycj|fffd|
                                      'Ten ma by|fffd| tak d|fffd|go widoczny, jak dlug widoczny jest jego wiersz - czyli tu nie manipulujemy
                Case "SectionExpand": 'Przycisk zwi|fffd|kszaj|fffd|cy sekcj|fffd| o 1 pozycj|fffd|
                        Set cell = cell.Offset(RowOffset:=-1)  'Cell to kom|fffd|rka w wierszu powy|fffd|ej
                        Shp.Visible = cell.EntireRow.Hidden 'Przycisk jest tylko wtedy widoczny, gdy wiersz bezpo|fffd|rednio powy|fffd|ej jest ukryty
                                                            '(czyli jest jeszcze co odkrywa|fffd|)
            End Select
        End If
    Next Shp
End Sub
'Funkcja zwraca kom|fffd|rk|fffd| z ostatniego widocznego wiersza, znajduj|fffd|cego si|fffd| powy|fffd|ej kom|fffd|rki Base
'Argumenty:
'   Base:   kom|fffd|rka, powy|fffd|ej kt|fffd|rej poszukujemy widocznego wiersza
'Funkcja zwraca kom|fffd|rk|fffd| widocznego wiersza, kt|fffd|ra znajduje si|fffd| w tej samej kolumnie, co <Base>
Private Function FindLastVisibleRowAbove(ByVal base As Range) As Range
  Dim cell As Range
  Set cell = base
  Do
    Set cell = cell.Offset(RowOffset:=-1)
  Loop While cell.EntireRow.Hidden And Not IsEmpty(cell)
  Set FindLastVisibleRowAbove = cell
End Function
'Procedura dla przycisk|fffd|w ods|fffd|aniaj|fffd|cych/zas|fffd|aniaj|fffd|cych kolejny wiersz sekcji
'pozycji opcjonalnych (dwie strza|fffd|ki po prawej najni|fffd|szego wiersza)
Sub OnClickExpandShrinkSection()
    Dim Target As TextBox 'Klikni|fffd|ty "przycisk"
    ' Odczytaj pozycje myszki w chwili klikni|fffd|cia:
    Set Target = GetClickedObject() 'Sprawd|fffd|, w co klikneli|fffd|my
    If TypeName(Target) = "TextBox" Then 'OK, zaczynaj dzia|fffd|anie
        Dim base As Range, cell As Range, SheetProtect
        Set base = Target.TopLeftCell.Offset(ColumnOffset:=-1) 'Base to kom|fffd|rka po lewej stronie klikni|fffd|tego przycisku
        SheetProtect = UnprotectSheet(ActiveSheet, False)
        If IsEmpty(SheetProtect) Then Exit Sub 'Nie uda|fffd|o si|fffd| zdj|fffd||fffd| ochrony skoroszytu
            'nic (komunikat wy|fffd|wietli|fffd| UnprotectSheet())
        
        On Error GoTo ErrHandler
        
        Select Case Target.Name
                Case "SectionShow": 'przycisk rozwijaj|fffd|cy pocz|fffd|tkowy widok subsekcji
                        Dim ExpandPositions As Integer
                        ExpandPositions = 1 'Poka|fffd| na pocz|fffd|tek co najwy|fffd|ej tyle pozycji
                        Set cell = base.Offset(RowOffset:=1) 'cell to pierwsza kom|fffd|rka obszaru:
                        Do 'Ods|fffd|o|fffd| wiersze zaznaczone jako "0" i pierwsze z wierszy oznaczonych jako "1"
                            If cell.value = 0 Then cell.EntireRow.Hidden = False
                            If cell.value = 1 And ExpandPositions > 0 Then
                               cell.EntireRow.Hidden = False
                               ExpandPositions = ExpandPositions - 1
                            End If
                            Set cell = cell.Offset(RowOffset:=1) 'i przejd|fffd| do kom|fffd|rki poni|fffd|ej
                        Loop While Not IsEmpty(cell.value)
                        
                Case "SectionShrink": 'Przycisk zmniejszaj|fffd|cy sekcj|fffd| o 1 pozycj|fffd|
                        Set cell = FindLastVisibleRowAbove(base) 'Znajd|fffd| pierwszy widoczny wiersz
                        If cell.value = 1 Then
                            cell.EntireRow.Hidden = True
                            Set cell = cell.Offset(RowOffset:=-1) 'cell to teraz pierwszy widoczny wiersz PO operacji
                        End If
                        If cell.value = 0 Then 'Dotarli|fffd|my do ko|fffd|ca: zwi|fffd| wiersze obramowania
                           cell.EntireRow.Hidden = True
                           base.EntireRow.Hidden = True
                        End If
                        
                Case "SectionExpand": 'Przycisk zwi|fffd|kszaj|fffd|cy sekcj|fffd| o 1 pozycj|fffd|
                        Set cell = FindLastVisibleRowAbove(base) 'Znajd|fffd| pierwszy widoczny wiersz
                        Set cell = cell.Offset(RowOffset:=1) 'cell to powinien by|fffd| teraz pierwszy ukryty wiersz
                        If cell.value = 1 Then cell.EntireRow.Hidden = False
        End Select
        
        UpdateSectionButtonsVisibility ActiveSheet
        
        Err.Clear 'Gdy wykonanie dosz|fffd|o do tej linii - lepiej usun|fffd||fffd| ewentualne "echa": b|fffd||fffd|dy po przeliczaniu arkusza
ErrHandler:
        If Err.Number <> 0 Then MsgBox Err.Description & vbCr & "(" & Hex(Err.Number) & ")", vbExclamation, GetText("UnexpectedError")
        ProtectSheet ActiveSheet, SheetProtect, False 'Je|fffd|eli arkusz by|fffd| chroniony - zabezpiecz go z powrotem
    End If
End Sub

'Okazuje si|fffd|, |fffd|e aby okno edycji powi|fffd|za|fffd| z plikami zewn|fffd|trznymi mia|fffd|o wszystkie opcje,
'musi by|fffd| wywo|fffd|ane wtedy, gdy aktywny arkusz nie jest zabezpieczony (protected)
Sub EditExternalLinks()
  Dim tmp As Worksheet, back As Worksheet
  If IsEmpty(ActiveWorkbook.LinkSources(XlLink.xlExcelLinks)) Then
     MsgBox GetText("NoExternalLinks"), vbInformation
     Exit Sub
  End If
  DisableScreenUpdating
On Error GoTo ErrHandler:
  Set tmp = ActiveWorkbook.Sheets("inne") 'Wy|fffd||fffd|czn|fffd| przyczyn|fffd| istnienia tego arkusza jest "bycie niezabezpieczonym arkuszem"
  Set back = ActiveSheet
  With tmp
    .Visible = xlSheetVisible
    .Select
    Application.Dialogs(xlDialogOpenLinks).Show
    .Visible = xlSheetVeryHidden
  End With
  back.Select
ErrHandler:
    EnableScreenUpdating
    If Err.Number <> 0 Then MsgBox Err.Description & vbCr & "(" & Hex(Err.Number) & ")", vbExclamation, GetText("UnexpectedError")
End Sub

'Pomocnicza metoda - ukrywa kszta|fffd|ty o podanych nazwach
'Argumenty
'   sheet: arkusz, na kt|fffd|rym mamy ukry|fffd| kszta|fffd|ty
'   names: nazwy kszta|fffd|t|fffd|w (rozdzielone przecinkiem)
Public Sub HideShapes(ByVal Sheet As Worksheet, ByVal names As String)
    Dim shape As shape
    For Each shape In Sheet.Shapes
        If Contains(names, shape.Name) Then shape.Visible = msoFalse
    Next shape
End Sub
'Dodaje do wskazanego nazwanego pola okre|fffd|lony interwa|fffd| czasu
'Argumenty:
'   FieldName:  nazwa pola (skoroszytu!)
'   Interval:   warto|fffd||fffd| jak w DateAdd()
'   Number:     warto|fffd||fffd| jak w DateAdd()
Private Sub FieldDateAdd(ByVal FieldName As String, ByVal Interval As String, ByVal Number As Double)
    Dim Fld As Range
    Set Fld = Range(FieldName)
    If IsDate(Fld) Then
        Fld.value = DateAdd(Interval, Number, Fld.value)
    End If
End Sub
'Pomocnicza funkcja: zwraca unikalny klucz (string), kt|fffd|ry jest wsp|fffd|lny dla pola z okresem poprzednim i obecnym
'Argument:
'   item: mapowanie, dla kt|fffd|rego ma by|fffd| wyznaczony klucz.
'UWAGA: gdy to nie jest pole nale|fffd||fffd|ce do p|fffd|l z kwotami okresu obecniego/poprzedniego - funkcja zwraca Empty
Private Function AssociatedKey(ByVal item As MappedField) As Variant
    Dim Key
    AssociatedKey = Empty
    If item.DataType = "ErrorMark" Or Not item.IsValid Then Exit Function
    
    If "Kwota" <> item.DataType Then Exit Function 'Tylko kwoty
    If Not (item.nodeName Like "*dtsf:R[BP]*") And IsEmpty(item.cell) Then Exit Function  'Poza arkuszami Dodatkowe, pustych p|fffd|l nie ma co przepisywa|fffd|,
                                                                                          '(W aruszach Dodatkowe kwoty NIE wyst|fffd|puja parami)
    Key = item.GetXPath()
    
    If Key Like "*:R[BP]/*" Or Key Like "*:R[BP]" Then ' Pola z rozliczenia podatku
        Key = Replace(Key, ":RP", ":RB")
    Else
        If Key Like "*:Kwota[AB]" Then
            Key = Replace(Key, ":KwotaB", ":KwotaA")
        Else
            Key = Empty
        End If
    End If
    
    AssociatedKey = Key
End Function
'Metoda przesuwa pola z kolumny "KwotaA" do kolumny "KwotaB"
'Argumenty:
'   WithDefaults: gdy True - wstawiaj w kom|fffd|rki domy|fffd|lne warto|fffd|ci i formu|fffd|y
'Informacyjnie: zwraca liczb|fffd| przeniesionych p|fffd|l
Function ShiftDataFields(Optional ByVal WithDefaults As Boolean = True)
    Dim list As Range, row As Range, item As MappedField, prv As MappedField, Key
    Dim cleared As New Collection 'Kolekcja w kt|fffd|rej kluczami s|fffd| adresy p|fffd|l, kt|fffd|re ju|fffd| zostaly oczyszczone (aby si|fffd| nie dublowa|fffd|)
    Dim FormulaCells As New Collection 'Kolekcja p|fffd|l, w kt|fffd|rych potem warto przeliczy|fffd| formu|fffd|y.
    Dim targets As New Collection 'Kolekcja kluczy - adres|fffd|w kom|fffd|rek docelowych (poprzedniego okresu), kt|fffd|re zosta|fffd|y ju|fffd| odnotowane (aby si|fffd| nie powtarza|fffd|)
    
    Application.cursor = xlWait
    DisableScreenUpdating DisableCalc:=True
    On Error GoTo ErrHandler
        Set list = Range(MapDefinitionsName)
        Set prv = Nothing
        For Each row In list.Rows
            Set item = New MappedField
            item.Initialize row
            If item.Hint = "ExportOnly" Then
              'nic
            Else
                If Not KeyExists(Adr(item.cell), targets) Then 'Je|fffd|eli tej kom|fffd|rki nie mamy jeszcze odnotowanej...
                    Key = AssociatedKey(item)
                    If IsEmpty(Key) Then 'Sprawd|fffd| jeszcze, czy nie jest to okres por|fffd|wnawczy (do wyczyszczenia)
                        If item.nodeName Like "*KwotaB1" Then
                            item.ResetExcelField True, True
                        End If
                    Else 'To albo pole |fffd|r|fffd|d|fffd|owe, albo docelowe
                        If KeyExists(Key, cleared) Then 'okres bie|fffd||fffd|cy ju|fffd| zosta|fffd| odnotowany? (*ZAK|fffd|ADAMY* |fffd|e w mapowaniach zawsze jest pierwszy)
                            Set prv = cleared(Key) 'Kom|fffd|rka z bie|fffd||fffd|cego okresu (item = okres poprzedni)
                            If (item.cell.row = prv.cell.row) Then 'sprawdzamy - tak na wszelki wypadek
                                If prv.cell.HasFormula Then FormulaCells.Add item, Key 'Jezeli to formu|fffd|a - zapami|fffd|taj do przeliczenia
                                item.cell.value = prv.cell.value 'przenie|fffd| zawarto|fffd||fffd|:
                                'Odnotuj, |fffd|e mamy te kom|fffd|rki (aby si|fffd| nie powtarza|fffd|):
                                targets.Add item, Adr(item.cell)
                                targets.Add prv, Adr(prv.cell)
                            Else 'Co|fffd| posz|fffd|o bardzo nie tak!
                                cleared.Remove Key
                                Debug.Print "Odrzucone skojarzenie: prv=" & Adr(prv.cell) & " z item=" & Adr(item.cell)
                            End If
                        Else
                            cleared.Add item, Key 'Odnotuj okres bie|fffd||fffd|cy (*ZAK|fffd|ADAMY* |fffd|e w mapowaniach zawsze jest pierwszy)
                        End If
                    End If
                End If
            End If
        Next row
        'Teraz: w polach |fffd|r|fffd|d|fffd|owych i docelowych mamy te same warto|fffd|ci, a listy cleared i FormulaCells s|fffd| indeksowane po adresie prv
        'Spr|fffd|bujmy podstawi|fffd| w odpowiednie pola docelowe domy|fffd|lne formu|fffd|y:
        For Each item In FormulaCells
          item.ResetExcelField PartialReset:=False, UseDefaults:=True 'Wstawiamy na miejsce warto|fffd|ci domy|fffd|ln|fffd| formu|fffd||fffd|
        Next item
        'nast|fffd|pnie przeliczmy ca|fffd|o|fffd||fffd|:
        Application.CalculateFull
        'A potem: sprawd|fffd|my, czy gdzie|fffd| w docelowych kom|fffd|rkach formu|fffd|a ma nie wyst|fffd|pi|fffd|, i na koniec wyzerujmy prv
        For Each prv In cleared
            If prv.cell.HasFormula Then
                Key = AssociatedKey(prv)
                If KeyExists(Key, FormulaCells) Then
                    Set item = FormulaCells(Key)
                    If prv.cell.value <> item.cell.value Then
                        Debug.Print "Wynik formu|fffd|y w polu " & item.Id & " ('" & item.cell.value; "') zosta|fffd| zastapiony oryginaln|fffd| warto|fffd|ci|fffd| ('" & prv.cell.value & "')"
                        item.cell.value = prv.cell.value
                    End If
                End If
            End If
            prv.ResetExcelField PartialReset:=True, UseDefaults:=WithDefaults
        Next prv
        
    'Na koniec - przestaw daty raportu na nast|fffd|pny rok i zerujemy dat|fffd| sporz|fffd|dzenia:
    FieldDateAdd "DataOd", "yyyy", 1
    FieldDateAdd "DataDo", "yyyy", 1
    Range("DataSporzadzenia") = Empty
    
ErrHandler:
    If Err.Number <> 0 Then 'czy podczas przetwarzania wyst|fffd|pi|fffd| b|fffd||fffd|d?
        If Err.Number = vbObjectError Then 'B|fffd||fffd|d ju|fffd| zasygnalizowany (por. MarkXMLValueError())
            Application.StatusBar = GetText("OperationFailed")
            RestoreStatusBar StatusBarDelay
        Else
            MsgBox GetText("ExportFailed", Err.Description), vbCritical, GetText("UnexpectedError")
        End If
    End If
    
    'Odtwarzamy stan Excela i wychodzimy:

    EnableScreenUpdating ForceCalculation:=True 'Przeliczaj nawet wtedy, gdy u|fffd|ytkownik ma wy|fffd||fffd|czone przeliczanie automatyczne.
    Application.cursor = xlDefault
    ShiftDataFields = cleared.count
End Function
'Przesuwa okresy (Bie|fffd||fffd|cy-->Poprzedni)
Public Sub ShiftPeriods()
    Dim result As VbMsgBoxResult
    result = MsgBox(GetText("PeriodShift?", Err.Description), vbQuestion Or vbYesNo Or vbDefaultButton2, GetText("Question"))
    If result = vbYes Then
        Dim count
        count = ShiftDataFields(WithDefaults:=True)
        MsgBox GetText("PeriodShift", count), vbInformation, GetText("Information")
    End If
End Sub
Attribute VB_Name = "Utils"
Option Explicit
'---------------------------------------------
'Modyfikacje:
'2018-09-01: Plik zaadoptowany z JPK
'---------------------------------------------
Public Const LastRow = 1048576 'Max. liczba wierszy w Excelu
Public Const InternalSheetName = "techniczne" 'Arkusz z r|fffd|nymi wewn|fffd|trznymi parametrami programu

Public Const CriticalError = vbObjectError + 1
'Sta|fffd|e MSXML 6.0
Public Const NODE_ELEMENT = 1
Public Const NODE_CDATA_SECTION = 4
Public Const NODE_TEXT = 3
Public Const NODE_COMMENT = 8
Public Const NODE_DOCUMENT = 9

Private Const TextResourcesName = "TekstyProgramu"
'Numery specjalnych kolumn uzywanych przy "etykietowanych" tabelach (w arkuszach Bilans, RZiS, itp)
Private Const CLevel = 3        'Symbole poziom|fffd|w agregacji s|fffd| w kolumnie "C"
Private Const CPageBreak = 2    'Symbole "mi|fffd|kkich" podzia|fffd||fffd|w stron s|fffd| w kolumnie "B"
Private Const CLabel = 10       'Pe|fffd|ne, hierarchiczne symbole p|fffd|l s|fffd| w kolumnie "J"
'Inna znaczniki:
Private Const NameMarker = "{Nazwa}" 'U|fffd|ywane w szablonach dla element|fffd|w o zmiennych nazwach (por. funkcja GetTemplate)
Private Const AdditionalTextListName = "AdditionalTextElements" 'Nazwa listy dodatkowych element|fffd|w tekstowych (do podstawienia w szablonach XML)
Private Const XPathSchemaVersion = "*[local-name()='Naglowek']/*[local-name()='KodSprawozdania']/@wersjaSchemy" 'Do odczytania aktualnej wersji schemy
'Zmienne modu|fffd|u:
Private myTexts As Collection 'Kolekcja zasob|fffd|w tekstowych (u|fffd|ywana przez GetText())
Private myCriticalSection As Integer 'Pomocnicza flaga, aby nie wywo|fffd|ywa|fffd| kaskadowo procedur obs|fffd|ugi zdarze|fffd|

'Funkcja zwraca poziom zagnie|fffd|d|fffd|enia sekcji krytycznych. 0 oznacza, |fffd|e nie ma |fffd|adnego
Function InCriticalSection() As Integer
    InCriticalSection = myCriticalSection
End Function
'Funkcja zwi|fffd|ksza poziom licznika sekcji krytycznej, i zwraca aktualn|fffd| warto|fffd||fffd|
Function BeginCriticalSection() As Integer
    myCriticalSection = myCriticalSection + 1
    BeginCriticalSection = myCriticalSection
End Function
'Funkcja zmniejsza poziom licznika sekcji krytycznej, i zwraca aktualn|fffd| warto|fffd||fffd|
Function EndCriticalSection() As Integer
    myCriticalSection = myCriticalSection - 1
    EndCriticalSection = myCriticalSection
End Function
'Funkcja dodana wy|fffd||fffd|cznie dla zwi|fffd|kszenia czytelno|fffd|ci kodu.
'Zwraca True, je|fffd|eli w tek|fffd|cie Values znajduje si|fffd| cho|fffd| raz tekst Value
'Argumenty:
'   Values: tekst do przeszukwania
'   Value:  poszukiwana warto|fffd||fffd|
Function Contains(ByVal Values As String, ByVal value As String) As Boolean
    Dim Pos As Integer
    Pos = InStr(Values, value)
    If Pos > 0 Then
        Dim ln As Integer
        ln = Len(value)
        If (Pos + ln) < Len(Values) Then 'To nie jest ostatni element
            Contains = (Mid(Values, Pos + ln, 1) Like "[, ;]")
        Else
            Contains = True
        End If
        If Contains Then
            If Pos > 1 Then
                Contains = (Mid(Values, Pos - 1, 1) Like "[, ;]")
            Else
                Contains = True
            End If
        End If
    Else
        Contains = False
    End If
End Function

'Funkcja dodana wy|fffd||fffd|cznie dla zwi|fffd|kszenia czytelno|fffd|ci kodu.
'Zwraca zakres arkusza odpowiadaj|fffd|cy podanej nazwie
'Argumenty:
'   Name:  nazwa obszaru lub adres
'   Sheet: [opcjonanlny]: nazwa arkusza, na kt|fffd|rym ten obszar wyst|fffd|puje (wa|fffd|na w przypadku obszar|fffd|w zwi|fffd|zanych z arkuszami, a nie ze skoroszytem)
'Funkcja zwraca obiekt reprezentuj|fffd|cy obszar lub Nothing, gdy element nie ma swojego odpowiednika w danych Excela
Function GetRangeFor(ByVal Name As String, Optional ByVal Sheet As Worksheet = Nothing) As Range
    On Error Resume Next
    If Sheet Is Nothing Or InStr(Name, "!") > 0 Then 'Gdy nie podano arkusza lub adres zawiera jego nazw|fffd|
        Set GetRangeFor = Range(Name)
    Else
        Set GetRangeFor = Sheet.Range(Name)
    End If
    Err.Clear
End Function

'Funkcja dodana wy|fffd||fffd|cznie dla zwi|fffd|kszenia czytelno|fffd|ci kodu.
'Zwraca obiekt Shape odpowiadaj|fffd|cy podanej nazwie
'Argumenty:
'   Name:  nazwa kszta|fffd|tu
'   Sheet: arkusz, na kt|fffd|rym ten kszta|fffd|t wyst|fffd|puje
'Funkcja zwraca obiekt reprezentuj|fffd|cy kszta|fffd|t lub Nothing, gdy element nie ma swojego odpowiednika w danych Excela
Function GetShapeFor(ByVal Name As String, ByVal Sheet As Worksheet) As shape
    On Error Resume Next
        Set GetShapeFor = Sheet.Shapes(Name)
        Err.Clear
End Function
'Funkcja dodana wy|fffd||fffd|cznie dla zwi|fffd|kszenia czytelno|fffd|ci kodu.
'Zwraca warto|fffd||fffd| pierwszej kom|fffd|rki obszaru odpowiadaj|fffd|cej podanej nazwie
'Argumenty:
'   Name:  nazwa obszaru lub adres
'   Sheet: [opcjonanlny]: nazwa arkusza, na kt|fffd|rym ten obszar wyst|fffd|puje (wa|fffd|na w przypadku obszar|fffd|w zwi|fffd|zanych z arkuszami, a nie ze skoroszytem)
'Gdy kom|fffd|rka jest pusta lub obszar w og|fffd|le nie istnieje - zwraca Empty
Function GetValueOf(ByVal Name As String, Optional ByVal Sheet As Worksheet = Nothing) As Variant
    Dim cell, result
    result = Empty
    Set cell = GetRangeFor(Name, Sheet)
    If Not (cell Is Nothing) Then result = cell.cells(1).value
    GetValueOf = result
End Function

'Funkcja zwraza True, gdy w|fffd|ze|fffd| XML na ELEMENTY potomne (a nie np. same komentarze)
'Argumenty:
'   node: sprawdzamy element (IXMLDOMElement)
'Funkcja dodana dla wi|fffd|kszej czytelno|fffd|ci kodu
Private Function HasElements(ByVal node As Object) As Boolean
    HasElements = (node.SelectNodes("*").Length > 0)
End Function
'Pomocnicza funkcja, pozwalaj|fffd|ca okre|fffd|li|fffd|, czy mamy do czynienia z wersj|fffd| demonstracyjn|fffd|
Function DemoVersion() As Boolean
    Dim rng As Range
    Set rng = Range("NumerSeryjny")
    DemoVersion = IsEmpty(rng.value) Or rng.value Like "DEMO*" 'bo s|fffd| dwie wersje demonstracyjne: DEMO.ifrom i DEMO
End Function
'Pomocnicza funkcja, pozwalaj|fffd|ca okre|fffd|li|fffd|, czy mamy do czynienia z wersj|fffd| dla iform
Function IFormVersion() As Boolean
    Dim rng As Range
    Set rng = Range("NumerSeryjny")
    IFormVersion = rng.value Like "*.iform" 'wersje dla iForm s|fffd| z ko|fffd|c|fffd|wk|fffd| iform
End Function
'Pomocnicza funkcja, pozwalaj|fffd|ca okre|fffd|li|fffd|, czy mamy do czynienia z wersj|fffd| do debugowania (dla mnie: dodatkowe informacje w komunikatach o b|fffd||fffd|dach)
Function DebugVersion() As Boolean
    Dim rng As Range
    Set rng = Range("NumerSeryjny")
    DebugVersion = rng.value = "TECH" 'Nigdy nie u|fffd|yj tego symbolu dla jakiego|fffd| klienta
End Function
'Pomocznicza funkcja, stosowana aby omin|fffd||fffd| konieczo|fffd||fffd| formatowania daty za pomoc|fffd| funkcji TEXT("rrrr-MM-dd")
Function DataWytworzenia()
    DataWytworzenia = Format(Now(), "yyyy-MM-dd")
End Function
'Pomocnicza funkcja (dla arkusza mapowania). Zwraca adres kom|fffd|rki jako tekst
'Argumenty:
'   Cell: kom|fffd|rka arkusza
'UWAGA: adres jest ZAWSZE w formacie A1, z nazw|fffd| arkusza, bez nazwy skoroszytu
Function Adr(ByVal cell) As String
    Adr = "" 'pusty, aby program omija|fffd| ewentualne wiersze mapowa|fffd| wskazuj|fffd|ce na uszkodzone elementy.
    If IsObject(cell) Then
        If cell Is Nothing Then
            'zwr|fffd|ci ""
        Else
            Dim SheetName As String
            SheetName = cell.Worksheet.Name
            If InStr(SheetName, " ") Then SheetName = "'" & SheetName & "'"
            Adr = SheetName & "!" & cell.Address 'Adres bezwzgl|fffd|dny
        End If
    End If
End Function
'Pomocnicza funkcja, zwraca True gdy kom|fffd|rka zawiera dat|fffd| (lub tekst, kt|fffd|ry wygl|fffd|da jak data)
'Argumenty:
'   Cell: kom|fffd|rka arkusza
Function CzyData(ByVal cell) As Boolean
    If TypeName(cell) = "Range" Then
        Set cell = cell.cells(1) 'Aby unikn|fffd|c problem|fffd|w z zawarto|fffd|ci|fffd| sacalonych kom|fffd|rek
    End If
    CzyData = IsDate(cell)
End Function
'Pomocnicza funkcja - zwraca daty w "natywnym" formatowaniu (sprawdza jednak format kom|fffd|rki docelowej, aby mie|fffd| poj|fffd|cie o typie danych)
'Argumenty:
'   Cell: kom|fffd|rka Excela
Function NaTekst(ByVal cell) As String
    NaTekst = CStr(cell.value)
End Function

'Funkcja zwraca rozszerzenie podanej nazwy pliku:
'Zak|fffd|adamy, |fffd|e taka nazwa raczej istnieje:
Public Function ExtensionOf(ByVal Path As String) As String
    Dim Pos As Integer
    ExtensionOf = ""
    Pos = InStrRev(Path, ".")
    If Pos > 0 Then
        Path = Mid(Path, Pos + 1)
        If InStr(Path, "\") Then Path = ""
        If InStr(Path, "/") Then Path = ""
        ExtensionOf = LCase(Path)
    End If
End Function
'Funkcja zwraca sam|fffd| nazw|fffd| pliku, wraz z rozszerzeniem (bez folderu):
Public Function FileNameOf(ByVal Path As String) As String
    Dim Pos As Integer
    FileNameOf = ""
    Path = Replace(Path, "/", "\") 'Na wszelki wypadek
    Pos = InStrRev(Path, "\")
    If Pos > 0 Then
        FileNameOf = Mid(Path, Pos + 1)
    End If
End Function
'Pomocnicza funkcja: zwraca True, gdy skoroszyt o podanej nazwie jest za|fffd|adowany do bie|fffd||fffd|cej sesji
Public Function IsWorkbookLoaded(ByVal WorkbookName As String) As Boolean
    Dim result As Workbook
    Set result = Nothing
    On Error Resume Next
        Set result = Workbooks(WorkbookName)
    Err.Clear
    IsWorkbookLoaded = Not (result Is Nothing)
End Function
'Funkcja zwraca True, gdy numer NIP jest poprawny, False w przeciwnym razie, Null gdy nie mo|fffd|e tego okre|fffd|li|fffd|
'Argumenty
'   NIP: numer NIP (jak wpisany przez u|fffd|ytkownika)
Function ValidNIP(ByVal NIP As String) As Variant
        
        If NIP Like "PL#*" Then 'Na potrzeby sprawdzania odcinamy przedrostek "PL" (teraz juz akceptowany przez wer. merytoryczn|fffd| w Kliencie JPK 2.0)
            NIP = Mid(NIP, 3)
        End If

        If NIP Like "[A-Z][A-Z]?#*" Or NIP Like "###############" Then
            ValidNIP = Null 'Najprawdopodobniej to NIP z zagranicy: nie mo|fffd|emy okre|fffd|li|fffd|, czy jest poprawny, czy nie
                            '15-cyfrowe numery s|fffd| z Chin
        Else
            If LCase(NIP) = "brak" Then
                ValidNIP = True 'Wygl|fffd|da na to, |fffd|e Klient JPK 2.0 przepuszcza s|fffd|owo "brak" (stosowa|fffd| dla detalist|fffd|w)
            Else
                If NIP Like "##########" Then
                    Dim i As Integer, Sum As Long, Digit(0 To 9) As Integer
                    For i = 0 To 9
                        Digit(i) = CInt(Mid(NIP, i + 1, 1))
                    Next i
                    Sum = 6 * Digit(0) + _
                          5 * Digit(1) + _
                          7 * Digit(2) + _
                          2 * Digit(3) + _
                          3 * Digit(4) + _
                          4 * Digit(5) + _
                          5 * Digit(6) + _
                          6 * Digit(7) + _
                          7 * Digit(8)
                    Sum = Sum Mod 11
                    ValidNIP = (Sum = Digit(9))
                Else
                    ValidNIP = False
                End If
            End If
        End If
End Function
'Pomocnicza funkcja: tworzy lub |fffd|aduje z dysku plik XML. Zawczasu pod|fffd||fffd|cza do niego odpowiedni|fffd| schem|fffd|
'Argumenty:
'   XML: tekst, reprezentuj|fffd|cy kod XML (pomi|fffd|, gdy |fffd|adujesz dane z pliku)
'   Path: |fffd|cie|fffd|ka do pliku XML (pomi|fffd|, gdy |fffd|adujesz dane z tekstu)
'   LoadSchema: Ustaw na False, gdy nie trzeba |fffd|adowa|fffd| schemy
'W przypadku |fffd|adowania z pliku mo|fffd|e zasygnalizowa|fffd| podstawowe problemy z plikiem XML (np. |fffd|e jest uszkodozny)
'W takim przypadku zwraca Nothing
Public Function LoadXML(Optional ByVal xml As String = "", Optional ByVal Path As String = "", Optional ByVal LoadSchema As Boolean = True) As Object 'DOMDocument60
    Dim doc As Object 'DOMDocument60
    Dim success As Boolean
    
    Set doc = CreateObject("MSXML2.DOMDocument.6.0")
    With doc
        '** If LoadSchema Then Set .Schemas = GetXSD()
        .validateOnParse = False 'Sprawdzac b|fffd|dziemy oddzielnie
        
        If Len(xml) > 0 Then '|fffd|adujemy z tekstu
            success = .LoadXML(xml)
        Else '|fffd|adujemy z pliku
            success = .Load(Path)
            
            If success Then
                Dim node As Object 'IXMLDOMNode
                If .DocumentElement.BaseName = "Signature" Or .DocumentElement.BaseName = "Signatures" Then 'To mo|fffd|e by|fffd| plik XML "enveloped" w podpisie: trzeba z niego wyj|fffd||fffd| dane....
                    Dim contents As String 'Zawarto|fffd||fffd| podpisanego pliku
                    Set node = .DocumentElement.SelectSingleNode("//*[local-name()='Object'][@MimeType='text/xml']")
                    'Je|fffd|eli nie ma elementu tekstowego ds:Object, to mo|fffd|e jest element enkodowany w Base64? (CERTUM zacz|fffd|o to robi|fffd|...)
                    If node Is Nothing Then
                       Set node = .DocumentElement.SelectSingleNode("//*[local-name()='Object'][@Encoding='http://www.w3.org/2000/09/xmldsig#base64'][@Id]")
                       If Not (node Is Nothing) Then contents = Decode(node.text) 'Decode it into the VB string (Base64->UTF-8->Unicode)
                    Else
                       If node.FirstChild.BaseName = "Signature" Then 'Enveloped w Enveloped (taki przypadek mia|fffd|em dla Merit-Aktiva)
                         Set node = node.FirstChild.SelectSingleNode("*[local-name()='Object'][@MimeType='text/xml']")
                       End If
                       
                       contents = node.FirstChild.xml 'Pierwszym w|fffd|z|fffd|em potomnym w|fffd|z|fffd|a <Object> jest dokument XML raportu
                       
                    End If
                    
                    If node Is Nothing Then
                        success = False
                        MsgBox GetText("ThisIsSignatureFile"), vbInformation, GetText("SignatureOnly")
                    Else
                        success = .LoadXML(contents)
                    End If
                Else
                    'Pliki *.xml podpisywane przez e-PUAP lub eSF mog|fffd| zawiera|fffd| podpisy wewn|fffd|trz elementu g|fffd||fffd|wnego: trzeba je usun|fffd||fffd|
                       Dim signatures As Object 'IXMLDOMNodeList
                       Set signatures = .DocumentElement.SelectNodes("*[local-name()='Signature']")
                       For Each node In signatures 'Usuwamy wszystkie znalezione podpisy - bo nie s|fffd| zgodne ze schematem raportu i wywo|fffd|a|fffd|yby fa|fffd|szywy komunikat o b|fffd||fffd|dach...
                        .DocumentElement.RemoveChild node
                       Next node
                End If
            End If
            
            If Not success Then MsgBox GetText("CannotLoadFile", Path), vbCritical, GetText("ErrOnOpen")

        End If
    End With
    
    If success Then
        Set LoadXML = doc
    Else
        Set LoadXML = Nothing
    End If
End Function
'Pomocnicza funkcja: zwraca True, plik o podanej |fffd|cie|fffd|ce istnieje
'Argumenty:
'   Path: |fffd|cie|fffd|ka do pliku
Function FileExists(ByVal Path As String) As Boolean
    On Error Resume Next
    FileExists = ((GetAttr(Path) And vbDirectory) <> vbDirectory)
    Err.Clear
End Function
'Pomocnicza procedura do obs|fffd|ugi list
'Argumenty:
'   Key: klucz (powinien by|fffd| u|fffd|yty w czasie dodawania element|fffd|w do kolekcji).
'   col: sprawdzania kolekcja .UWAGA: w Collection klucze nie moga byc obiektami!
'Zwraca False, gdy klucza <Key> nie ma w kolekcji <col>
Function KeyExists(ByVal Key As String, ByVal Col As Collection) As Boolean
    KeyExists = True 'b|fffd|d|fffd|my pesymistami...
    On Error Resume Next
    TypeName Col(Key) 'Cokolwiek, byleby tylko odczyta|fffd| zawarto|fffd||fffd| listy (to mo|fffd|e by|fffd| obiekt, wi|fffd|c nie mog|fffd| stosowa|fffd| "=" )
    If Err.Number <> 0 Then KeyExists = False
    Err.Clear
End Function
'Pomocnicza funkcja: pod|fffd|wietla kom|fffd|rk|fffd| arkusza bez ryzyka b|fffd||fffd|du
'Argumenty:
'   Cell: kom|fffd|rka, kt|fffd|ra nale|fffd|y pod|fffd|wietli|fffd|
'Zwraca True, gdy uda|fffd|o si|fffd| pod|fffd|wietli|fffd| kom|fffd|rk|fffd|
Function ShowCell(ByVal cell As Range)
    Dim Sheet As Worksheet
    Set Sheet = cell.Worksheet
    If cell.EntireRow.Hidden Or Sheet.Visible = xlSheetVeryHidden Then
        ShowCell = False
    Else
        If Not Sheet.Visible Then Sheet.Visible = xlSheetVisible 'gdyby ten arkusz by|fffd| omy|fffd|kowo ukryty: ods|fffd|o|fffd| go!
        Application.GoTo cell
        ShowCell = True
    End If
End Function
'Pomocnicza funkcja: zwraca kolekcj|fffd| zasob|fffd|w tekstowych
Private Function GetTextResources() As Collection
    Dim result As New Collection
    Dim src As Range, row As Range
    Set src = Range(TextResourcesName)
    For Each row In src.Rows
        If Not IsEmpty(row.cells(1)) Then
            result.Add row.cells(2).value, row.cells(1).value
        End If
    Next row
    Set GetTextResources = result
End Function

'Zwraca zas|fffd|b tekstowy
'Argumenty:
'   Id: tekst, taki jaki figuruje w tablicy [teksty!TekstyProgramu]
'   Args: opcjonalne argumenty, podstawiane w tekst ({0}, {1}, {2}, ...)
Function GetText(ByVal Id As String, ParamArray Args())
    If myTexts Is Nothing Then
        Set myTexts = GetTextResources()
        Debug.Print "informacja: za|fffd|adowano tablic|fffd| tekst|fffd|w programu"
    End If
    If KeyExists(Id, myTexts) Then
        Dim text As String, i As Integer
        text = myTexts(Id)
        For i = LBound(Args) To UBound(Args)
            text = Replace(text, "{" & i & "}", Args(i))
        Next i
        GetText = text
    Else 'Co|fffd| nie tak: brak takiego tekstu
        GetText = "*missing text resource*:'" & Id & "'"
    End If
End Function
'Pomocnicza procedura, dodana dla wi|fffd|kszej czytelno|fffd|ci kodu GetTemplate:
'w tek|fffd|cie szablon|fffd|w umie|fffd|ci|fffd|em miejsca w {..} na powtarzalne sekcje, kt|fffd|rych wzorce s|fffd|
'w oddzielnych ramkach tekstowych. Ta procedura wstawia w <text> te sekcje (o ile zawiera
'nazwy tych ramek, uj|fffd|te w nawiasy {}
'Argumenty:
'   text    :modyfikowany tekst (dlatego przekazywany przez referencj|fffd|)
'Takie podelementy s|fffd| dodane, aby nie "rozdmuchiwa|fffd|" niepotrzebnie rozmiaru szablon|fffd|w XML
Private Sub InsertAdditionalElements(ByRef text As String)
    Dim list As Range, row As Range, item, fragment As String
    Set list = Range(AdditionalTextListName)
    
    For Each row In list.Rows
        item = row.cells(1)
        If Not IsEmpty(item) Then
            fragment = ActiveWorkbook.Sheets(InternalSheetName).Shapes(item).DrawingObject.Caption
            text = Replace(text, "{" & item & "}", fragment)
        End If
    Next row
End Sub
'Pomocnicza funkcja: zwraca zawarto|fffd||fffd| wskazanego okna tekstowego z arkusza "techniczne"
'Argumenty:
'   Name:   nazwa pola tekstowego
'   VariantName: opcjonalny: nazwa aktualnego wariantu raportu ("JednostkaInna", "Skonsolidowany", "JednostkaOp", ...)
'                (wykorzystywana dla podstawienia w|fffd|a|fffd|ciwej nazwy elementu g|fffd||fffd|wnego w ewentualne pole <{Nazwa}>
'                i </{Nazwa}>
'                W takim przypadku w liniach przed elementem <{Nazwa}> powinny si|fffd| znajdowa|fffd|:
'                <Domy|fffd|lna nazwa elementu>
'                [Nazwa wariantu raportu1:nazwa elementu dla tego wariantu]
'                [Nazwa wariantu raportu2:nazwa elementu dla tego wariantu]
'                [...]
'                <{Nazwa}>
'Funkcja dodana dla wi|fffd|kszej czytelno|fffd|ci kodu
Function GetTemplate(ByVal Name As String, Optional ByVal VariantName As String = "") As String
    Dim text As String, Pos As Integer
    text = ActiveWorkbook.Sheets(InternalSheetName).Shapes(Name).DrawingObject.Caption
    'Wstawienie dodatkowych element|fffd|w:
    InsertAdditionalElements text
    Pos = InStr(text, "<" & NameMarker & ">")
    If Pos > 0 Then 'Prz|fffd|d tekstu zawiera nazw|fffd| domy|fffd|ln|fffd| i wyliczank|fffd| wyj|fffd|tk|fffd|w
        Dim items, except, ElementName As String, i As Integer
        items = Split(Trim(Left(text, Pos - 1)), vbLf) 'Element 0 - domy|fffd|lna nazwa, pozosta|fffd|e - pary wyj|fffd|tk|fffd|w
        ElementName = Trim(items(0))
        For i = 1 To UBound(items)
            If InStr(items(i), ":") Then
                except = Split(items(i), ":")
                If Trim(except(0)) = VariantName Then ElementName = Trim(except(1))
            End If
        Next i
        text = Replace(Mid(text, Pos), NameMarker, ElementName)
    End If
    
    GetTemplate = text
End Function

'Funkcja zwraca pozycj|fffd| wskazanego tekstu na li|fffd|cie:
'Argumenty:
'   value:      szukana warto|fffd||fffd|
'   List:       lista (pojedyncza kolumna) w kt|fffd|rej szukamy <value>
'   StartFrom:  pozycja, od kt|fffd|rej nale|fffd|y zacz|fffd||fffd| szuka|fffd|
'Funkcja zwraca jej pozycj|fffd| na li|fffd|cie (1, 2, 3, 4, ...) lub 0, gdy nie znalaz|fffd|a.
Function PosOnList(ByVal value As String, ByVal list As Range, Optional ByVal StartFrom As Integer = 1) As Integer
    Dim cell As Range, i As Integer
    PosOnList = 0
    i = (StartFrom - 1)
    For Each cell In list.cells
        i = i + 1
        If IsEmpty(cell.value) Then
            'nic
        Else
            If Contains(cell.value, value) Then
                PosOnList = i
                Exit Function
            End If
        End If
    Next cell
End Function

'Funkcja zwraca wiersz zwi|fffd|zany z podanym symbolem, lub Nothing:
'Argumenty:
'   value:          szukana warto|fffd||fffd|
'   List:           lista (pojedyncza kolumna) w kt|fffd|rej szukamy <value>
'   SearchInColumn: numer kolumny w <List>, w kt|fffd|rej mamy szuka|fffd| <value>
Function FindOnList(ByVal value As String, ByVal list As Range, ByVal SearchInColumn As Integer) As Range
    Dim Pos As Integer
    Pos = PosOnList(value, list.Columns(SearchInColumn))
    If Pos > 0 And Pos <= list.Rows.count Then
        Set FindOnList = list.Rows(Pos)
    Else
        Set FindOnList = Nothing
    End If
End Function
'Zwraca pozosta|fffd|e wpisy z podanej listy (pojedynczego wiersza lub kolumny), kt|fffd|re nie odpowiadaj|fffd| <ThisValue>
'Argumenty:
'   Pomin: warto|fffd|ci (ew. rozdzielane przecinkami, je|fffd|eli wi|fffd|cej ni|fffd| jedna), kt|fffd|re nale|fffd|y pomin|fffd||fffd|
'   Lista: lista, zawierajaca wszystkie warto|fffd|ci (w tym te z Pomin)
'Pomocnicza funkcja do u|fffd|ycia w formu|fffd|ach:
Function Pozostale(ByVal Pomin As String, ByVal Lista As Range) As String
    Dim cell As Range
    Dim result As String
    result = ""
    For Each cell In Lista.cells
        If Not Contains(Pomin, cell.value) Then
           If result <> "" Then result = result & ","
           result = result & cell.value
        End If
    Next cell
    Pozostale = result
End Function
'Pomocnicza funkcja: zamienia kolekcj|fffd|
'Argumenty:
'   c: kolekcja, kt|fffd|ra zmieniamy na tablic|fffd|.
Function CollectionToArray(c As Collection) As Variant()
    Dim a() As Variant: ReDim a(0 To c.count - 1)
    Dim i As Integer
    For i = 1 To c.count
        If IsObject(c.item(i)) Then
            Set a(i - 1) = c.item(i)
        Else
            a(i - 1) = c.item(i)
        End If
    Next
    CollectionToArray = a
End Function
'Funkcja na podstawie etykiety wiersza z arkusza (np. Bilansu) okre|fffd|la nazw|fffd| (bazow|fffd|) elementu XML
'Argumenty:
'   Etykieta: tekst w postaci <przedrostek>:<N>[.<N>[.<N>[.<N>[.<N>]]]], gdzie "N" to cyfra (|fffd|aci|fffd|ska lub arabska) lub liczba
'   - np. "Aktywa:A.II.1.d"
Function EtykietaNaNazwe(ByVal Etykieta)
    Dim result
    result = Empty
    If VarType(Etykieta) = vbString And Etykieta <> "" Then
        Dim colon As Integer 'Pozycja dwukropka
        colon = InStr(Etykieta, ":") 'mo|fffd|e by|fffd| =0, gdy etykieta nie ma przedrostka
        result = Replace(UCase(Mid(Etykieta, colon + 1)), ".", "_")
        If colon > 1 Then
            result = Left(Etykieta, colon - 1) & "_" & result 'Dodaj przedrostek
        End If
    End If
    EtykietaNaNazwe = result
End Function
'Pomocnicza: poziom agregacji (w kolumnie "C" [3] Bilansu, RZiS, i podobnych)
'Argumenty:
'   Cell: kom|fffd|rka (pole na kwot|fffd|) z jednego z arkuszy w kt|fffd|rych s|fffd| zapisane te poziomy
'Funkcja zwraca -1 dla kom|fffd|rek bez zawarto|fffd|ci, 999 dla wiersza z oznaczeniem "P"
Private Function LevelOf(ByVal cell As Range) As Integer
    Dim Sheet As Worksheet, Level As Range
    Set Sheet = cell.Worksheet
    Set Level = Sheet.cells(cell.row, CLevel)
    If IsEmpty(Level) Then
        LevelOf = -1
    Else
        If IsNumeric(Level) Then
            Dim PBreak As Range
            Set PBreak = Sheet.cells(cell.row, CPageBreak) 'Czy kom|fffd|rka obok nie zawiera znacznika podzia|fffd|u strony?
            If PBreak = "P" Then
                LevelOf = 999
            Else
                If Right(Sheet.cells(cell.row, CLabel), 1) = "j" Then 'To pozycja typu "w tym jednostek powi|fffd|zanych"
                    LevelOf = 999
                Else
                    LevelOf = Level.value
                End If
            End If
        Else
            LevelOf = -1
        End If
    End If
End Function
'Funkcja zwraca nast|fffd|pn|fffd|/poprzedni|fffd| kom|fffd|rk|fffd| do podanej
'Argumenty:
'   Cell:       kom|fffd|rka odniesienia
'   RowOffset:  liczba wierszy przesuni|fffd|cia (mo|fffd|e byc ujemne)
'Funkcja dodana wy|fffd||fffd|cznie dla wi|fffd|kzej czytelno|fffd|ci kodu
Private Function NextOf(ByVal cell As Range, ByVal RowOffset As Integer) As Range
    Set NextOf = cell.Offset(RowOffset:=RowOffset)
End Function
'Funkcja zwraca formu|fffd||fffd| dla podanej kom|fffd|rki, sumuj|fffd|c|fffd| pola o 1 poziom ni|fffd|ej
'Argumenty:
'   Cell:   kom|fffd|rka, dla kt|fffd|rej ma by|fffd| przeznaczona ta formu|fffd|a
'   Offset: -1, je|fffd|eli ma by|fffd| sumowany w g|fffd|r|fffd|
Function AggregateSumFormula(ByVal cell As Range, Optional ByVal Offset As Integer = 1) As String
    Dim BaseLevel As Integer, Level As Integer, formula As String
    formula = ""
    BaseLevel = LevelOf(cell)
    Do
        Set cell = NextOf(cell, Offset)
        Level = LevelOf(cell)
        If Level = (BaseLevel + 1) Then
            formula = formula & "+" & Replace(cell.Address, "$", "")
        End If
    Loop While Level > BaseLevel
    'Odcinamy ew. wiod|fffd|cy plus:
    If formula <> "" Then formula = "=" & Mid(formula, 2)
    AggregateSumFormula = formula
End Function
'Pomocnicza funkcja, formatuj|fffd|ca liczby tak, jak to wymaga raport
'Argumenty:
'   Number:         liczba (zapisana jako tekst - je|fffd|eli to nie liczba, wywo|fffd|a b|fffd||fffd|d)
'   WithFraction:   True, je|fffd|eli to ma by|fffd| liczba z 2 miejscami po przecinku, False je|fffd|eli ca|fffd|kowita
Function FormatNumber(ByVal Number As Double, ByVal WithFraction As Boolean) As String
    Dim Val As String
    If WithFraction Then
    'Aby wymusi|fffd| dwa zera po przecinku, bo inaczej program KAS traktuje liczby z jednym miejscem dziesi|fffd|tnym jako niepoprawne
        Val = Format(Number, "#0.00")
    Else
        Val = Format(Number, "#0")
    End If
    FormatNumber = Replace(Val, ",", ".") 'funkcja Format() w miejsce "." podstawia aktualny znak dzisi|fffd|tny
End Function
'Uaktualnia etykiety arkuszy i kontrolek, odpowiednio do wybranego j|fffd|zyka
Sub UpdateWorkbookLabels()
    Dim def As New ReportDef
    def.Initialize
    def.UpdateLabels
    Set myTexts = Nothing 'Wymuszamy ponowne za|fffd|adowanie wszelkich komunikat|fffd|w programu.
End Sub

'Pomocnicza funkcja: zwraca kod schematu dla podanego XML
'Argumenty:
'   xml:    dokument xml
'Je|fffd|eli plik ma nieprawid|fffd|owy format - zwraca ""
Function GetSchemaVersion(ByVal xml As Object) As String
        Dim node As Object 'IXMLDOMNode,
        Dim version As String
        GetSchemaVersion = ""
        Set node = xml.DocumentElement.SelectSingleNode(XPathSchemaVersion)
        If node Is Nothing Then Exit Function
        GetSchemaVersion = node.text
End Function

'Funkcja dodana wy|fffd||fffd|cznie w celu obs|fffd|u|fffd|enia importu przez program Daniela
'Dodaje za|fffd||fffd|cznik do wskazanego pola skoroszytu (nie sprawdza, czy jest to pole poprawne)
'Argumenty:
'   WorkbookName:   nazwa skoroszytu z kom|fffd|rk|fffd| docelow|fffd|
'   SheetName:      nazwa arkusza z kom|fffd|rk|fffd| docelow|fffd|
'   CellAddress:    adres kom|fffd|rki docelowej
'Funkcja zwraca True, gdy si|fffd| uda|fffd|o. (Zanim zwr|fffd|ci False - wy|fffd|wietli wcze|fffd|niej odp. komunikat o b|fffd||fffd|dzie)
'Adres kom|fffd|rki przekazuj|fffd| za pomoc|fffd| tekst|fffd|w: WorkbookName, SeetName i CellAddress, gdy|fffd| przy wywo|fffd|aniu za pomoc|fffd| "CallMacro"
'argumenty musz|fffd| by|fffd| jednym z typ|fffd|w "prostych": testem, liczb|fffd|, lub warto|fffd|ci|fffd| logiczn|fffd|
Public Function AddAttachement(ByVal WorkbookName As String, ByVal SheetName As String, ByVal CellAddress As String, ByVal SrcPath As String, Optional ByVal RemoveSrc As Boolean = False) As Boolean
    Dim TargetCell As Range
    Dim pwd
    AddAttachement = False 'zak|fffd|adamy, |fffd|e si|fffd| nie uda
    Set TargetCell = Workbooks(WorkbookName).Sheets(SheetName).Range(CellAddress)
    'Odbezpiecz ten skoroszyt:
    pwd = UnprotectSheet(TargetCell.Worksheet)
    If IsEmpty(pwd) Then Exit Function 'Nie uda|fffd|o si|fffd| zdj|fffd||fffd| ochrony skoroszytu
                                  'nic (komunikat wy|fffd|wietli|fffd| UnprotectSheet())
    On Error GoTo ErrHandler
    'Potem zainicjuj obiekt za|fffd||fffd|cznika:
    Dim att As New Attachement
    att.Initialize cell:=TargetCell
    'Potem wstaw ten plik jako za|fffd||fffd|cznik do arkusza:
    att.Insert SrcPath
    'Na koniec nie zostawiac po sobie |fffd|mieci:
    If RemoveSrc Then Kill SrcPath

ErrHandler:
        ProtectSheet TargetCell.Worksheet, pwd, False 'Je|fffd|eli arkusz by|fffd| chroniony - zabezpiecz go z powrotem
        If Err.Number = 0 Then
            AddAttachement = True 'OK, uda|fffd|o si|fffd|!
        Else
            MsgBox Err.Description & vbCr & "(" & Hex(Err.Number) & ")", vbExclamation, GetText("UnexpectedError")
        End If
End Function
'Funkcja odpowiadaj|fffd|ca wbudowanej w formu|fffd|y Excela 2019 funkcji SWITCH (PRZE|fffd||fffd|CZ)
'(wykorzystywana w formu|fffd||fffd|ch na niezgodno|fffd|ci kwot - potrzebna dla kompatybilno|fffd|ci z ni|fffd|szymi wersjami Excela)
Function SwitchX(ParamArray Args() As Variant) As Variant
    Dim Val As Variant, i As Integer
    Dim Max As Integer
    SwitchX = Empty 'Domy|fffd|lnie
    Max = UBound(Args)
    i = LBound(Args)
    If Max - i < 2 Then Exit Function 'Gdy funkcja zosta|fffd|a wywo|fffd|ana bez odpowiednich argument|fffd|w
    Val = Args(i) 'Pierwszy argument: warto|fffd||fffd| do por|fffd|wna|fffd|
    While (Max - i) > 1 'i: numer ostatniego wykorzystanego elementu
         If Val = Args(i + 1) Then
            SwitchX = Args(i + 2)
            Exit Function
         End If
         i = i + 2
    Wend
    If i < Max Then 'Je|fffd|li podano ostatni|fffd| warto|fffd||fffd| domy|fffd|ln|fffd|:
        SwitchX = Args(Max)
    End If
End Function

Attribute VB_Name = "Validation"
Option Explicit
'--------------
'Modyfikcje:
'2018-10-06: Adaptacja kodu z JPK

Private Const ImportChecksName = "AdditionalChecks" 'Nazwa obszaru listy z dodatkowymi testami, jakie nale|fffd|y wykona|fffd| podczas importu lub do|fffd||fffd|czania danych
Private Const LicenseTestBoxName = "Warunki" 'Nazwa obszaru tekstowego z warunkami licencyjnymi
Private Const ReconcFlagsName = "WeryfikacjaDanych" 'Nazwa obszaru (nieci|fffd|g|fffd|ego) z flagami wewn|fffd|trznych uzgodnie|fffd|
Const XPath_DataDo = "*[local-name()='Naglowek']/dtsf:OkresDo" 'Wyra|fffd|enie do odczytania daty ko|fffd|cowej
Const XPath_DataOd = "*[local-name()='Naglowek']/dtsf:OkresOd" 'Wyra|fffd|enie do odczytania daty pocz|fffd|tkowej
Const ErrTextNotAllowed = &HC00CE018 'B|fffd||fffd|d walidacji: "tekst jest niedozwolony w kontek|fffd|cie elementu (XPath wskazuje na w|fffd|ze|fffd| tekstowy, kt|fffd|rego rodzicem jest zazwyczaj element g|fffd||fffd|wny)
'Zmienne lokalne
Private myRestrictions As Object '(DOMDocument60) 'Ograniczenia arkusza (z obszaru techniczne:Warunki). U|fffd|ywana w ExpireDate (i w przysz|fffd|o|fffd|ci - innych)
Private myXSD_URL As String 'tu zapami|fffd|tujemy, jak|fffd| schem|fffd| mamy aktualnie zbuforowan|fffd| (aby po zmianie wariantu raportu za|fffd|adowa|fffd| powt|fffd|rnie w|fffd|a|fffd|ciw|fffd|)
                            'ustawiona, gdy pr|fffd|bowali|fffd|my ju|fffd| za|fffd|adowa|fffd| schem|fffd| (aby gdy MyXSD jest Nothing, nie powtarza|fffd| pr|fffd|b za ka|fffd|dym razem)
Private myXSD As Object '(XMLSchemaCache60) zbuforowana schema (aby przy pracy z b|fffd||fffd|dami nie |fffd|adowac jej za ka|fffd|dym razem)
'UWAGA! resetowa|fffd| przy zmianie wariantu raportu!
'Pomocnicza: |fffd|aduje ograniczenia licencji, przypisane do skoroszytu
Private Sub LoadLicenseRestrictions()
    Dim result As Boolean
    Set myRestrictions = LoadXML(GetTemplate(LicenseTestBoxName), LoadSchema:=False)
    result = Not (myRestrictions Is Nothing)
    If result Then result = myRestrictions.HasChildNodes
    If result = False Then
        MsgBox GetText("WkbookCorrupted"), GetText("WkbookProblem")
        ActiveWorkbook.Close False
    End If
End Sub
'Pomocznicza funkcja, pomagaj|fffd|ca okre|fffd|li|fffd| ewentualn|fffd| dat|fffd| przeterminowania (Empty je|fffd|li plik jest bezterminowy)
Public Function ExpireDate()
    Dim node As Object 'IXMLDOMElement
    If myRestrictions Is Nothing Then LoadLicenseRestrictions
    Set node = myRestrictions.DocumentElement.SelectSingleNode("exp")
    If node Is Nothing Then
        ExpireDate = Empty
    Else
        ExpireDate = CDate(node.text)
    End If
End Function

'Funkcja zwraca schemat XSD do walidacji dokumentu, lub Nothing gdy nie mog|fffd|a go za|fffd|adowa|fffd|
'Argumenty:
'   def:        Definicja wczytywanego raportu (do okre|fffd|lenia nazwy odpowiedniego pliku XSD)
'   DisplayDialogs: True, gdy komunikat ma by|fffd| wy|fffd|wietlony w oknie dialogowym. W przeciwnym razie pojawi si|fffd| w polu statusu
Private Function GetXSD(ByVal def As ReportDef, ByVal DisplayDialogs As Boolean) As Object 'XMLSchemaCache60
    Dim cxsd As String
    cxsd = def.XSD 'Plik XSD, w|fffd|a|fffd|ciwy dla aktualnej struktury
    
    If myXSD_URL <> cxsd Or (myXSD Is Nothing And DisplayDialogs) Then 'DisplayDialogs jest True tylko podczas zapisu
                                                                       'wtedy komunikat o problemach b|fffd|dzie za ka|fffd|dym razem.
        myXSD_URL = cxsd 'Podczas importu t|fffd| Schem|fffd| pr|fffd|bujemy za|fffd|adowa|fffd| tylko raz - to pole pe|fffd|ni rol|fffd| flagi.
        Set myXSD = Schema.GetLocalXSD '|fffd|adujemy schematy z osadzonych plik|fffd|w
    End If
    Set GetXSD = myXSD
    'W razie czego dodaj tutaj reakcja na brak powodzenia w |fffd|adowaniu schemat|fffd|w:
    If myXSD Is Nothing Then
        If DisplayDialogs Then
            MsgBox GetText("XSDFileNotFound(Export)"), vbExclamation, GetText("Warning")
        Else
            Application.StatusBar = GetText("XSDFileNotFound(Import)")
            Application.Wait Now() + TimeValue("00:00:05") 'Dajmy sobie co najmniej 5 sekund na zauwa|fffd|enie i przeczytanie tego komunikatu... 'Wy|fffd|wietlaj ten tekst przez chwil|fffd|
            RestoreStatusBar
        End If
    End If
End Function

'Funkcja zwraca pierwszy odnaleziony fragment tekstu pomi|fffd|dzy podanymi wyra|fffd|eniami
'Argumenty
'   text:       przeszukiwany tekst
'   FromExpr:   wyra|fffd|enie, ograniczaj|fffd|ce poszukiwany fragment z lewej
'   ToExpr:     wyra|fffd|enie, ograniczaj|fffd|ce poszukiwany fragment z prawej
'   Offset:     opcjonalny: na wej|fffd|ciu - miejsce, od kt|fffd|rego szuka|fffd| w tek|fffd|cie fragmentu, na wyj|fffd|ciu - pozycja po zako|fffd|czeniu odnalezionego ToExpr
'Gdy tekst nie zawiera |fffd||fffd|danego fragmentu - funkcja zwraca "", a Offset jest ustawiony na Len(text)
'Mo|fffd|e tak|fffd|e zwr|fffd|ci|fffd| "", gdy przeskakuje jaki|fffd| znaczek pocz|fffd|tku, ale bez ko|fffd|ca. Wtedy Offset jest < Len(text)
Private Function FragmentBetween(ByVal text As String, ByVal FromExpr As String, ByVal ToExpr As String, Optional ByRef Offset) As String
    Dim FromPos As Long, ToPos As Long, NextPos As Long
    FragmentBetween = ""
    If IsMissing(Offset) Then Offset = 1
    FromPos = InStr(Offset, text, FromExpr)
    If FromPos = 0 Then 'ko|fffd|czymy:
        Offset = Len(text)
        Exit Function
    Else
        FromPos = FromPos + Len(FromExpr) 'Przeskakujemy wiod|fffd|cy tekst
        Offset = FromPos
    End If
    
    'Trick: najpierw wyszukaj ewentualn|fffd| pozycj|fffd| nast|fffd|pnego pocz|fffd|tku:
    NextPos = InStr(Offset, text, FromExpr)
    If NextPos = 0 Then NextPos = Len(text)
    
    'a potem znajd|fffd| po|fffd|o|fffd|enie ko|fffd|ca:
    ToPos = InStr(Offset, text, ToExpr)
    If ToPos = 0 Then 'ko|fffd|czymy:
        Offset = Len(text)
        Exit Function
    Else
        If ToPos > NextPos Then 'To nie jejst szukamy fragment: pomi|fffd| go
            Offset = NextPos
            Exit Function
        Else
            Offset = ToPos + Len(ToExpr)
        End If
    End If
    'W tym miejscu mamy znalezione pozycje From i To:
    FragmentBetween = Mid(text, FromPos, ToPos - FromPos)
End Function
'Pomocnicza funkcja: poprawia nazwy element|fffd|w XML w komunikacie - w Windows 7 i wcze|fffd|niejszych s|fffd| cz|fffd|sto skracane i na ko|fffd|cu maj|fffd| "..."
'Argumenty:
'   msg:        wst|fffd|pnie skorygownay tekst, w kt|fffd|rym przed ka|fffd|d|fffd| nazw|fffd| elementu jest wstawiony "#":
'               np. "Element '#KwotyPoz...' jest nieoczekiwany w odniesieniu do modelu zawarto|fffd|ci elementu nadrz|fffd|dnego '#PozycjaUszczegolawiaj...'."
'   NodNames:   pe|fffd|ne nazwy element|fffd|w wylicoznych w msg, rozdzielone spacjami, np. "KwotyPozycji PozycjaUszczegolawiajaca2"
'Funkcja zwraca komunikat msg z pe|fffd|nymi nazwami. Nawet gdy nie znajdzie wyra|fffd|e|fffd| pomi|fffd|dzy  "..."
Private Function FixBrokenElementNames(ByVal msg As String, ByVal NodeNames As String) As String
    Dim Name, names, expr, Offset
    Dim result As String
    result = msg
    Offset = 1
    names = Split(NodeNames, " ")
    While Offset < Len(msg)
        expr = FragmentBetween(msg, "#", "...", Offset) 'Wywo|fffd|anie tej funkcji przesuwa Offset
        If expr <> "" Then 'expr to mo|fffd|e by|fffd| tu co|fffd| w rodzaju: "KwotyPoz" - fragment nazwy jednego z element|fffd|w
            For Each Name In names 'Spr|fffd|bujmy dopasowa|fffd| ten fragtment do nazwy elementu:
                If InStr(Name, expr) > 0 Then 'Znalezione!
                    result = Replace(result, "#" & expr & "...", Name)
                    Exit For
                End If
            Next Name
        End If
    Wend
    'Na koniec - usu|fffd| ewentualne znaczki "#"
    result = Replace(result, "#", "")
    FixBrokenElementNames = result
End Function
'Pokazuje na arkuszu pierwszy znaleziony w dokumencie Doc b|fffd||fffd|d (opisany przez obiekt Err)
'Argumenty:
'   Doc:    dokument JPK (DOMDocument60), kt|fffd|rego dotyczy sprawa;
'   Err:    obiekt (IXMLDOMParseError2) opisuj|fffd|cy b|fffd||fffd|d (podstaw tu Doc.parseError, to oddzielny argument po to, by zmieni|fffd| jego klas|fffd|)
'   map:    mapa element|fffd|w Excela na w|fffd|z|fffd|y <Doc>
'   Interactive: (opcjonalny) False, je|fffd|eli tylko wy|fffd|wietli|fffd| komunikat w konsoli.
Sub ShowError(ByVal doc As Object, ByVal Err As Object, ByVal map As Mapper, Optional ByVal Interactive As Boolean = True)
    Dim msg As String, Prompt As String, i As Integer, NodeNames As String, shortName As String, namespace As String
    NodeNames = ""
    'Najpierw usu|fffd|my z komunikatu ew. nazwy przestrzeni nazw (by u|fffd|ytkownik nie zg|fffd|upia|fffd|):
    msg = Err.reason
    Prompt = GetText("ErrorInDocument")
    For i = 0 To Err.errorParametersCount - 1
        Dim p As String, parts
        p = Err.errorParameters(i)
        If p Like "{*}*" Then
            parts = Split(p, "}")
            shortName = parts(1)
            namespace = parts(0) & "}"
            msg = Replace(msg, namespace, "#")  'Usuwamy z tekstu komunikatu wyra|fffd|enie w "{}", wstawiaj|fffd|c w to mijece "#" (na razie)
            Prompt = GetText("NodeValidationFailed", shortName)
            NodeNames = NodeNames & " " & shortName 'Zapami|fffd|tujemy nazwy element|fffd|w, kt|fffd|re wyst|fffd|pi|fffd|y w komunikacie (aby znale|fffd||fffd| ew. nazwy element|fffd|w brakuj|fffd|cych)
        End If
    Next i
    NodeNames = Trim(NodeNames)
    
    'Poni|fffd|sza funkcja naprawia b|fffd||fffd|d w Windows7 i wcze|fffd|niejszych, polegaj|fffd|cy na skracaniu nazw element|fffd|w z "...".
    '(W ka|fffd|dym razie usunie wstawione przed chwil|fffd| znaczki "#", kt|fffd|e by|fffd|y ptrzebne do ewentualnego parowania z "..."):
    msg = FixBrokenElementNames(msg, NodeNames)
    If Interactive Then
        'Potem spr|fffd|bujemy zaznaczy|fffd| ten b|fffd||fffd|d na arkuszu:
        Dim nodes As Object 'IXMLDOMNodeList
        Dim node As Object 'IXMLDOMElement
        Dim nodeName As String
        Set nodes = doc.SelectNodes(Err.errorXPath)
        If nodes.Length > 0 Then
            Dim cells As Range
            nodeName = nodes(0).BaseName
            map.MarkDocumentNodes 'Zawsze wywo|fffd|uj t|fffd| metod|fffd| przed funkcj|fffd| FindCell (Wywo|fffd|anie tej metody zmienia <doc>: dodaje atrybut "mapped" do ka|fffd|dego zamapowanego w|fffd|z|fffd|a)
            Set cells = map.FindCellFor(nodes(0), shortName) 'Szuka celi Excela "w pobli|fffd|u", najlepiej dla ostatniej nazwy spo|fffd|r|fffd|d podaych parametr|fffd|w
                                                             'Gdy shortName = "", zwracana jest najbli|fffd|sza znaleziona kom|fffd|rka, gdy zawiera nazw|fffd| lementu - probujemy poszuka|fffd| troch|fffd| "dooko|fffd|a" tego w|fffd|z|fffd|a.
            
            'Spr|fffd|bujmy okre|fffd|li|fffd|, czy nie chodzi przypadkiem o usuni|fffd|ty arkusz, po kt|fffd|rym zosta|fffd| "placeholder" w tek|fffd|cie elementu g|fffd||fffd|wnego:
            If Err.ErrorCode = ErrTextNotAllowed And nodes(0).text Like "{*}" Then 'Tak, to mo|fffd|e by|fffd| ten przypadek:
                msg = msg & vbCr & GetText("MissingStandardSheet", nodes(0).text)
            End If
            
            If cells Is Nothing Then
                '"winnych kom|fffd|rek Excela brak". No trudno, wy|fffd|wietlimy tylko komunikat...
            Else 'Ok, znale|fffd|li|fffd|my jak|fffd||fffd| "odpowiedzialn|fffd|" kom|fffd|rk|fffd| Excela:
                On Error Resume Next 'Ta linia zeruje globalny obiekt Err, ale mo|fffd|e nie ten przekazany jako parametr.
                                     'Dodana na wszelki wypadek, gdyby plecenie ShowCells() wywali|fffd|o b|fffd||fffd|d.
                ShowCell cells 'Przesu|fffd| u|fffd|ytkownika do tego pola
            End If
        End If
    End If
    'Dodatkowa diagnostyka
    If DebugVersion Then
        msg = msg & vbCr & IIf(nodeName <> "", "Wskazany w|fffd|ze|fffd| XML: " & nodeName & vbCr, "")
        msg = msg & "Nr b|fffd||fffd|du (hex): " & Hex(Err.ErrorCode) & vbCr & "Parametry: " & NodeNames
        doc.Save ActiveWorkbook.Path & "\err_doc.xml"
    End If
    
    'Komunikat dla u|fffd|ytkownika
    If Interactive Then
        MsgBox msg, vbCritical, Prompt
    Else
        Debug.Print "Po|fffd|o|fffd|enie |fffd|r|fffd|d|fffd|a b|fffd||fffd|du (XPath): " & Err.errorXPath
        Debug.Print "Komunikat o b|fffd||fffd|dzie: "
        Debug.Print msg
    End If
End Sub
'Pomocnicza funkcja, kt|fffd|ra wykonuje pojedynczy dodatkowy test importowanego dokumentu (wg. listy AdditionalChecks)
'Argumenty:
'   doc:            sprawdzamy dokument XML (DOMDocument60)
'   def:            obiekt ReportDef: do podstawiania odpowiednich warto|fffd|ci do p|fffd|l oczekiwanych podczas testu
'   XPath:          wyra|fffd|enie wybieraj|fffd|ce odp. w|fffd|ze|fffd| w sprawdzanym dokumencie
'   ExpectedVal:    oczekiwana warto|fffd||fffd|
'   ErrorMsg:       komunikat, kt|fffd|ry nale|fffd|y wy|fffd|wietli|fffd| u|fffd|ytkownikowi gdy warto|fffd||fffd| w|fffd|z|fffd|a jest inna od oczekiwanej
'   Operator:       operacja: "eq" = r|fffd|wne, "lt" - mniejsze R|fffd|WNE, "gt" - wi|fffd|ksze R|fffd|WNE, "in" - warto|fffd||fffd| node wyst|fffd|puje w ExpectedVal
Private Function DoAdditionalCheck(ByVal doc As Object, ByVal def As ReportDef, ByVal xpath As String, ByVal ExpectedVal As Variant, ByVal ErrorMsg As String, Optional ByVal operator As String = "eq") As Boolean
    Dim node As Object 'IXMLDOMNode
    Dim Val As String, test As Boolean
    Set node = doc.DocumentElement.SelectSingleNode(xpath)
    If node Is Nothing Then Val = "" Else Val = node.text
    
    If VarType(ExpectedVal) = vbString Then
        ExpectedVal = Replace(ExpectedVal, "{wersjaSchemy}", def.Info("wersjaSchemy", "extra")) 'Wersja oczekiwanej schemy mo|fffd|e si|fffd| r|fffd|ni|fffd| dla r|fffd|nych wariant|fffd|w raportu
    End If
    
    Select Case operator
        Case "eq":
                test = (Val = ExpectedVal) 'Wszystkie testy danych wej|fffd|ciowych: tu wymagamy istnienia w|fffd|z|fffd|a
        Case "lt":
                If IsNumeric(Val) Then
                    test = (CDbl(Val) <= CDbl(ExpectedVal))
                Else
                    If Val = "" Then
                        test = True
                    Else
                        test = (Val < ExpectedVal)
                    End If
                End If
        Case "gt":
                If IsNumeric(Val) Then
                    test = (CDbl(Val) >= CDbl(ExpectedVal))
                Else
                    If Val = "" Then
                        test = True
                    Else
                        test = (Val >= ExpectedVal)
                    End If
                End If
        Case "in":
                If ExpectedVal <> "" Then
                    test = Contains(ExpectedVal, Val) 'Gdy val jest puste, ten test zwr|fffd|ci False
                Else
                    test = True
                End If
    End Select
    If test = False Then
        MsgBox Replace(Replace(ErrorMsg, "{Val}", Val), "{Exp}", ExpectedVal), , GetText("WrongReportFile")
        DoAdditionalCheck = False
    Else
        DoAdditionalCheck = True
    End If
End Function
'Funkcja wykonuje dodatkowe testy podczas importu, wg listy techniczne!AdditionalChecks
'Argumenty:
'   doc:        sprawdzay dokument XML (DOMDocument60)
'   ImportMode: "" dla zapisu, "Import" lub "Append"
'   BevoreXSD:  True, je|fffd|eli wywo|fffd|ywany przed testem schemy, False gdy po (funkcja jest wo|fffd|ana 2 razy)
'   def:        obiekt ReportDef: do podstawiania ewentualnych zmiennych warto|fffd|ci oczekiwanych
'   Zwraca True, gdy si|fffd| uda|fffd|o, False w przeciwym razie.
Private Function DoInputChecks(ByVal doc As Object, ByVal ImportMode As String, ByVal BeforeXSD As Boolean, ByVal def As ReportDef) As Boolean
    Dim i As Integer, tests As Range, result As Boolean
    result = True
    'Sprawdzamy ew. ograniczenia licencji:
    'Sprawdzamy list|fffd| dodatkowych test|fffd|w (gdy wczytujemy plik)
    Set tests = Range(ImportChecksName)
    For i = 1 To tests.Rows.count
        If BeforeXSD = tests.cells(i, 3) Then
             Select Case ImportMode
                  Case "Import":
                        If tests.cells(i, 1) Then
                          result = DoAdditionalCheck(doc, def, tests.cells(i, 4), tests.cells(i, 5), tests.cells(i, 6), tests.cells(i, 2))
                        End If
             End Select
        End If
        If Not result Then Exit For
    Next i
    DoInputChecks = result
End Function

'Pomocznicza funkcja, pomagaj|fffd|ca okre|fffd|li|fffd| czy wczytywanie ma by|fffd| dost|fffd|pne
Function ImportAllowed()
    Dim rng As Range, flag As Long
    Set rng = Range("SF_XED")
    flag = Mid(rng.value, 2, 1) 'Drugi znak SF_XED
    ImportAllowed = (flag <> "0")
End Function
'Funkcja sprawdza ew. ograniczenia licencyjne
'Argumenty:
'   doc:        sprawdzay dokument XML (DOMDocument60)
'   def:        definicja raportu (dla podstawiania odp. p|fffd|l informacyjnych)
'   Zwraca True, gdy si|fffd| uda|fffd|o, False w przeciwym razie.
Private Function CheckLicenseConstraints(ByVal doc As Object, ByVal def As ReportDef) As Boolean
    Dim result As Boolean, tests As Object 'IXMLDOMNodeList
    Dim i As Integer
    If myRestrictions Is Nothing Then LoadLicenseRestrictions
    result = True
    Set tests = myRestrictions.DocumentElement.SelectNodes("test")
    For i = 0 To tests.Length - 1
        Dim xpath As Object 'IXMLDOMNode,
        Dim expected As Object 'IXMLDOMNode
        Dim operator As Object 'IXMLDOMNode
        Set xpath = tests(i).SelectSingleNode("@val")
        Set expected = tests(i).SelectSingleNode("@exp")
        Set operator = tests(i).SelectSingleNode("@op")
        If Not DoAdditionalCheck(doc, def, xpath.text, expected.text, tests(i).text, operator.text) Then
            result = False
            Exit For
        End If
    Next i

    CheckLicenseConstraints = result
End Function
'Funkcja wykonuje dodatkowe testy podczas importu, wg listy techniczne!AdditionalChecks
'Argumenty:
'   doc:        sprawdzay dokument XML (DOMDocument60)
'   ImportMode: "" dla zapisu, "Import" lub "Append"
'   BevoreXSDtest:  True, je|fffd|eli wywo|fffd|ywany przed testem schemy, False gdy po (funkcja jest wo|fffd|ana 2 razy)
'   def:        obiekt ReportDef (do podstawiania zmiennych warto|fffd|ci oczekiwanych)
'   Zwraca True, gdy si|fffd| uda|fffd|o, False w przeciwym razie.
Private Function AdditionalChecks(ByVal doc As Object, ByVal ImportMode As String, ByVal BeforeXSD As Boolean, ByVal def As ReportDef) As Boolean
    Dim result As Boolean
    result = True
    'Sprawdzamy ew. ograniczenia licencji:
    If BeforeXSD Then
        result = CheckLicenseConstraints(doc, def)
    End If
    'Sprawdzamy list|fffd| dodatkowych test|fffd|w (gdy wczytujemy plik)
    If result = True Then
       result = DoInputChecks(doc, ImportMode, BeforeXSD, def)
    End If
    AdditionalChecks = result
End Function
'Wy|fffd|wietla powiadomienie o niezgodno|fffd|ciw wybranych linii. (Wo|fffd|a|fffd| tylko przy eksporcie - dlatego nie ma <doc>)
'Argumenty:
'   def:        obiekt ReportDef
'Zwraca True, je|fffd|eli nale|fffd|y kontynuowa|fffd| zapisywanie, False je|fffd|eli ma byc przerwane
'Funkcja wy|fffd|wietla komunikat i zwraca False na pierwszej znalezionej niezgodno|fffd|ci
Private Function Reconciliation(ByVal def As ReportDef) As Boolean
    Dim sections As Collection, sec As Section
    Reconciliation = False  'Zak|fffd|adamy pesymistycznie:
    Set sections = def.sections
    For Each sec In sections
        Dim verf As Range
        Set verf = GetRangeFor(ReconcFlagsName, Sheet:=sec.Sheet)  'Nazwa tego obszaru jest lokalna dla ka|fffd|dego arkusza
        If verf Is Nothing Then
            'kontynuuj (na tym arkuszu nie ma niczego do sprawdzania)
        Else 'Arkusz zawiera obszar z kom|fffd|rkami uzgodnie|fffd|
            Dim count As Integer, cell As Range, FirstCell As Range
            'Policzny niezgodno|fffd|ci i zapami|fffd|tajmy pierwsz|fffd| z nich:
            count = 0
            For Each cell In verf 'Sprawdzamy ka|fffd|d|fffd| ze wskazanych kom|fffd|rek
                If IsError(cell) Then
                    'pomi|fffd| - aby|fffd|my nie mieli problem|fffd|w
                Else
                    If cell.EntireRow.Hidden = False And cell.value = "!" Then 'Ta kom|fffd|rka oznaczy|fffd|a wiersz jako niezgodny
                        If count = 0 Then Set FirstCell = cell 'Pierwsza znaleziona niezgodno|fffd||fffd|
                        count = count + 1
                    End If
                End If
            Next cell
            If count > 0 Then
                Dim result As VbMsgBoxResult, rec As Reconciliation
                Set rec = New Reconciliation
                rec.Initialize FirstCell
                rec.SelectFirstDifference 'Ustaw pod|fffd|wietlenie na pierwszym niezgodnym wierszu (aby u|fffd|ytkownik widzia|fffd|, co omija)
                Select Case PerformReconciliation()
                    Case 1: 'Jako ostrze|fffd|enie
                            result = MsgBox(GetText("ReconcSheet", sec.Sheet.Name, count, GetText("ReconcYesNo")), vbYesNoCancel Or vbDefaultButton1 Or vbInformation, GetText("Warning"))
                    Case 2: 'jako b|fffd||fffd|d
                            MsgBox GetText("ReconcSheet", sec.Sheet.Name, count, GetText("ReconcOK")), vbExclamation, GetText("InputDataError")
                            result = vbYes 'Zatrzymaj - bez opcji wyboru
                    Case Else
                        'nic nie wy|fffd|wietlaj, kontynuuj (doda|fffd|em na wszelki wypadek)
                            result = vbNo
                End Select
                If result = vbNo Then
                    'kontynuuj
                Else
                    rec.DisplayMessage 'Poka|fffd| komunikat o niezgodno|fffd|ci pierwszej ze znalezionych linii.
                    Exit Function 'Zwr|fffd||fffd| False (koniec przetwarzania)
                End If
            End If
        End If
    Next sec
    Reconciliation = True 'Jak doszli|fffd|my a|fffd| tutaj - to znaczy, |fffd|e jest OK.
End Function

'Funkcja dokonuje walidacji dokumentu XML
'Argumenty:
'   doc:         Dokument XML (DOMDocument60) do zwalidowania (musi byc utworzony za pomoc|fffd| funkcji LoadXML(), i miec ustawione odp. przedrostki namespaces)
'   map:         Mapowanie p|fffd|l Excela na dokument doc (potrzebne do lokalizacji ewentualnych b|fffd||fffd|d|fffd|w)
'   def:         Definicja wczytywanego raportu (do okre|fffd|lenia nazwy odpowiedniego pliku XSD)
'   Visualize:   opcjonalny: False, gdy nie pokazywac b|fffd||fffd|d|fffd|w na arkuszu (bo np. wyo|fffd|ali|fffd|my t|fffd| funkcj|fffd| podczas importu)
'   ImportMode:  opcjonalny: pozwala rozr|fffd|ni|fffd| wczytywanie ca|fffd|ego pliku od dopisywania
'   CurXSDVer:   opcjonalny: u|fffd|ywany przy imporcie pliku: podaje wariant schemy w aktualnych plikach XSD
'  Zwraca True gdy walidacja si|fffd| powiod|fffd|a, False gdy nie, Null gdy nie zosta|fffd|a wykonana
'(bo wyst|fffd|pi|fffd|y wcze|fffd|niej problemy z pobraniem pliku XSD).
'(W razie czego: aby sprawdzi|fffd| czy wyst|fffd|pi|fffd| b|fffd||fffd|d, u|fffd|yj warunku "ValidateXML(doc) = False")
'Komunikuje ewentualny b|fffd||fffd|d u|fffd|ytkownikowi, pokazuj|fffd|c w|fffd|a|fffd|ciwe pole na arkuszu
Function ValidateXML(ByVal doc As Object, ByVal map As Mapper, ByVal def As ReportDef, Optional ByVal Visualize As Boolean = True, _
                     Optional ByVal ImportMode As String = "", Optional ByVal CurXSDVer As String = "") As Variant

    If CurXSDVer = "" Then CurXSDVer = GetSchemaVersion(doc) 'CurXSDVer = "" przy eksporcie
   
    If GetSchemaVersion(doc) = CurXSDVer Then 'myXSD b|fffd|dzie Nothing, je|fffd|eli przy imporcie aktualny schemat XSD nie pasuje do wczytywanego pliku
        If AdditionalChecks(doc, ImportMode, True, def) = False Then
            ValidateXML = False
            Exit Function
        End If
    
        GetXSD def, Visualize 'Spr|fffd|buj za|fffd|adowa|fffd| schem|fffd|, (je|fffd|eli do tej pory tego nie robi|fffd|e|fffd|:)
    Else 'Je|fffd|eli wczytywany dokument ma inn|fffd| wersj|fffd| schematu - to musi by|fffd| to jedna z dopuszczalnych (sprawdzamy to w AdditionalChecks)
        If ImportMode = "Import" Then
            MsgBox GetText("PreviousFileFormat", GetSchemaVersion(doc)), vbInformation, Title:=GetText("Warning")
            Set myXSD = Nothing 'bo schemat mo|fffd|e juz by|fffd| wczytany przy okazji poprzedniego zapisu, i w efekcie wy|fffd|wietli si|fffd| komunikat |fffd|e "plik zawiera pewne b|fffd||fffd|dy"
        End If
    End If
    
    If myXSD Is Nothing Then
       ValidateXML = Null 'Nie sprawdzono.
    Else
        Dim Err As Object 'IXMLDOMParseError2
        
        If VarType(doc.Schemas) = vbNull Then
            Set doc.Schemas = myXSD
        End If
      
        Set Err = doc.Validate()
        
        If Err.ErrorCode <> 0 Then
            ValidateXML = False

            ShowError doc, Err, map, Visualize
        
            If ImportMode <> "" Then
                If vbNo = MsgBox(GetText("ContinueDespiteErrors?"), vbYesNo Or vbDefaultButton2 Or vbExclamation, GetText("Warning")) Then
                    Exit Function
                Else
                    ValidateXML = Null 'Nie powiemy |fffd|e plik jet OK, ale nie zablokujemy wczytania...
                End If
            End If
        Else
            ValidateXML = AdditionalChecks(doc, ImportMode, False, def)
            If ImportMode = "" Then 'Te dodatkowe elementy sprawdzamy tylko podczas zapisu:
                    '1. Czy data ko|fffd|cowa jest >= pocz|fffd|tkowej?
                    If DoAdditionalCheck(doc, def, XPath_DataDo, Format(Range("DataOd"), "yyyy-MM-dd"), GetText("WrongPeriod"), "gt") = False Then
                        ValidateXML = False
                        ShowCell Range("DataOd")
                        Exit Function
                    End If
                    '2. Czy data ko|fffd|cowa jest <= obecnej?
                    If DoAdditionalCheck(doc, def, XPath_DataDo, Format(Now, "yyyy-MM-dd"), GetText("PeriodInFuture"), "lt") = False Then
                        ValidateXML = False
                        ShowCell Range("DataDo")
                        Exit Function
                    End If
                    '3. Czy data ko|fffd|cowa jest < daty sporz|fffd|dzenia?
                    If DoAdditionalCheck(doc, def, XPath_DataDo, Format(Range("DataSporzadzenia"), "yyyy-MM-dd"), GetText("TooEarlyDocumentDate"), "lt") = False Then
                        ValidateXML = False
                        ShowCell Range("DataSporzadzenia")
                        Exit Function
                    End If
                    '4. Czy kwoty raportu zawieraj|fffd| wewn|fffd|trzne sprzeczno|fffd|ci?
                    If Reconciliation(def) = False Then
                        ValidateXML = False
                        'Odp. kom|fffd|rk|fffd| pod|fffd|wietlono ju|fffd| w Reconciliation()
                        Exit Function
                    End If
            End If
        End If
    End If
End Function



Attribute VB_Name = "ZMakraPrzydatnePodczasEdycji"
Option Explicit

Sub ZmienAdresNaBezwzgledny()
Attribute ZmienAdresNaBezwzgledny.VB_Description = "Zmienia adresy w zaznaczonych kom|fffd|rkach na bezwzgl|fffd|dne"
Attribute ZmienAdresNaBezwzgledny.VB_ProcData.VB_Invoke_Func = "g\n14"
'
' Zmienia adresy w zaznaczonych kom|fffd|rkach na bezwzgl|fffd|dne
'
' Klawisz skr|fffd|tu: Ctrl+L
'
    Dim cell As Range, WorkbookName As String
    WorkbookName = "[" & ActiveWorkbook.Name & "]"
    For Each cell In Selection.cells
        If cell.formula Like "=*" Then
            cell.FormulaR1C1 = Replace(Application.ConvertFormula(cell.FormulaR1C1, xlR1C1, ToAbsolute:=True), WorkbookName, "")
        End If
    Next cell
End Sub
'Procedura szuka w kolumnie B wiersza z zaznaczeniem adresu kom|fffd|rki, i kopiuje z niej formu|fffd||fffd| jako tekst
Sub PrzepiszFormuleDoMapowania()
Attribute PrzepiszFormuleDoMapowania.VB_Description = "Kopiuje formu|fffd||fffd| z kom|fffd|rki |fffd|r|fffd|d|fffd|owej do obszaru mapowania (jako tekst)"
Attribute PrzepiszFormuleDoMapowania.VB_ProcData.VB_Invoke_Func = "F\n14"
    Dim Mapowanie As Range
    Dim cell As Range, RefCell As Range, Source As Range
    Set Mapowanie = GetRangeFor("Mapowanie")
    Set cell = Selection.cells(1)
    If Application.Intersect(Mapowanie, cell) Is Nothing Then Exit Sub
    Set RefCell = Mapowanie.cells(cell.row - Mapowanie.row + 1, 1)
    If IsEmpty(RefCell) Then Exit Sub
    Set Source = Range(RefCell.value)
    cell.formula = "'" & Source.formula
End Sub

'Usuwa z aktywnego arkusza niepotrzebne kszta|fffd|ty
'Argumenty:
'   Names: lista nazw do usuni|fffd|cia (rozdzielanych przecinkami)
Sub UnhideShapes(Optional ByVal names)
    Dim Shp As shape
    For Each Shp In ActiveSheet.Shapes
        If IsMissing(names) Or Contains(names, Shp.Name) Then
                Shp.Visible = msoTrue
                Debug.Print Shp.Name, Shp.TopLeftCell.Address
        End If
    Next Shp
End Sub
'Listuje niewidoczne kszta|fffd|ty na aktywnym arkuszu
Sub ListHiddenShapes()
    Dim Shp As shape
    For Each Shp In ActiveSheet.Shapes
        If Shp.Visible <> msoTrue Then
                Debug.Print Shp.Name, Shp.TopLeftCell.Address
        End If
    Next Shp
End Sub

Function TestDoc() As Object 'As DOMDocument60
    Dim doc
    Set doc = CreateObject("MSXML2.DOMDocument.6.0")
    doc.Load "C:\Users\me\Documents\ZigZak\e-sprawozdania\Wzorce\sprawozdanie_ekrs.xml" 'test struktur.xml"

    Dim nspaces As String, list As Range, row As Range, text As String
    nspaces = ""
    Set list = Range("DetaleWeryfikacji")
    For Each row In list.Rows
        If IsEmpty(row.cells(2)) Then
            'Skip
        Else
            If Len(nspaces) > 0 Then nspaces = nspaces & " "
            text = row.cells(3)
            text = Replace(text, "{jednostka}", "JednostkaInna")
            text = Replace(text, "{baza}", "WTysiacach")
            nspaces = nspaces & "xmlns:" & row.cells(2) & "='" & text & "'"
        End If
    Next row
    
    doc.setProperty "SelectionNamespaces", nspaces
    Set TestDoc = doc
End Function
'Do testowania XPath
Function xpath(ByVal doc As Object, ByVal query As String) As Long
    Dim result As Object 'IXMLDOMNodeList
   With doc.DocumentElement
    Set result = .SelectNodes(query)
   End With
   xpath = result.Length
End Function
'Do czyszczenia niepotrzebnych formu|fffd| ze scalonych kom|fffd|rek:
'Argumenty:
'   DoRemove: gdy True, usuwa formu|fffd|y z niewidocznych cel scalonych kom|fffd|rek
Sub ClearMergedCells(ByVal DoRemove As Boolean)
    Dim cell As Range, count As Integer
    count = 0
    For Each cell In Selection.cells
        If cell.MergeCells Then
            Dim mCell As Range
            Set mCell = cell.MergeArea.cells(1)
            If Application.Intersect(mCell, cell) Is Nothing Then 'To nie jest kom|fffd|rka widoczna
                If cell.formula <> "" Then
                    Debug.Print cell.Address, cell.formula
                    If DoRemove Then cell.formula = ""
                    count = count + 1
                End If
            End If
        End If
    Next cell
    Debug.Print "Przejrzano " & Selection.cells.count & " kom|fffd|rek, znaleziono: " & count
End Sub
'Zwraca przycisk zwi|fffd|zany ze wskazan|fffd| kom|fffd|rk|fffd|, lub Nothing gdy nie istneje
'Argumenty:
'   Cell:         kom|fffd|rka, z kt|fffd|r|fffd| zwi|fffd|zany ma by|fffd| kszta|fffd|t
'   SoughtType:   typ szukanego Shape: "Rectangle", albo "Picture" (to przyciski) lub "OLEObject"
Function FindControlFor(ByVal cell As Range, ByVal SoughtType As String) As shape
    Dim Shp As shape
    Set FindControlFor = Nothing
    For Each Shp In cell.Worksheet.Shapes
        If TypeName(Shp.DrawingObject) = SoughtType Then
            If Shp.DrawingObject.LinkedCell = cell.Address Then
                Set FindControlFor = Shp
                Exit For 'Znale|fffd|li|fffd|my
            End If
        End If
    Next Shp
End Function
'Do testowania zmiennych ad-hoc w Watch Window:
'Normalne odleg|fffd|o|fffd|ci OffsetX dla list rozwijalnych to 1.5 - 2.25. Jednak W Excelu 10 (Application.Version = 14.0)
'po podgl|fffd|dzie wydruku listy si|fffd| "rozje|fffd|d|fffd|aj|fffd|", i OffsetX zwi|fffd|ksza si|fffd| w|fffd|wczas do 49.5 - 126.75
'Mo|fffd|na to wykorzysta|fffd| jako wskaz|fffd|wk|fffd|, |fffd|e wyst|fffd|pi|fffd| ten b|fffd||fffd|d (by zablokowa|fffd| nadpisanie pliku)
Sub JustTest()

End Sub

' InQuest injected base64 decoded content
' 'r)bj
' .+-if
' j{Qj
' *'jS
' *'jS
' V+"n)b
' L\zSh
' -V+"nW
' 'V+"n)b
' -V+"nW
' *'jT
' *'jT
' 	^v|

INQUEST-PP=macro
