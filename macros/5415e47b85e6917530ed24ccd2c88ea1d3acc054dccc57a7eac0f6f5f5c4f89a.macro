Attribute VB_Name = "Action"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False


Private mvarsSessionName As String
Private mvarsCatalogName As String
Private mvarsSchemaName As String
Private mvarsCubeName As String
Private mvarsActionName As String
Private mvarsCoordinate As String
Private mvarsActionCaption As String
Private mvarsDescription As String
Private mvarsContent As String
Private mvarsApplication As String
Private mvarsCoordinateType As Long
Private mvarsActionType As Long
Private mvarsInvocation As Long

Public Property Let SessionName(ByVal vData As String)
    mvarsSessionName = vData
End Property

Public Property Get SessionName() As String
    SessionName = mvarsSessionName
End Property

Public Property Let CatalogName(ByVal vData As String)
    mvarsCatalogName = vData
End Property

Public Property Get CatalogName() As String
    CatalogName = mvarsCatalogName
End Property

Public Property Let SchemaName(ByVal vData As String)
    mvarsSchemaName = vData
End Property

Public Property Get SchemaName() As String
    SchemaName = mvarsSchemaName
End Property

Public Property Let CubeName(ByVal vData As String)
    mvarsCubeName = vData
End Property

Public Property Get CubeName() As String
    CubeName = mvarsCubeName
End Property

Public Property Let ActionName(ByVal vData As String)
    mvarsActionName = vData
End Property

Public Property Get ActionName() As String
    ActionName = mvarsActionName
End Property

Public Property Let ActionType(ByVal vData As Long)
    mvarsActionType = vData
End Property

Public Property Get ActionType() As Long
    ActionType = mvarsActionType
End Property

Public Property Let Coordinate(ByVal vData As String)
    mvarsCoordinate = vData
End Property

Public Property Get Coordinate() As String
    Coordinate = mvarsCoordinate
End Property

Public Property Let CoordinateType(ByVal vData As Long)
    mvarsCoordinateType = vData
End Property

Public Property Get CoordinateType() As Long
    CoordinateType = mvarsCoordinateType
End Property

Public Property Let ActionCaption(ByVal vData As String)
    mvarsActionCaption = vData
End Property

Public Property Get ActionCaption() As String
    ActionCaption = mvarsActionCaption
End Property

Public Property Let Description(ByVal vData As String)
    mvarsDescription = vData
End Property

Public Property Get Description() As String
    Description = mvarsDescription
End Property

Public Property Let Content(ByVal vData As String)
    mvarsContent = vData
End Property

Public Property Get Content() As String
    Content = mvarsContent
End Property

Public Property Let Application(ByVal vData As String)
    mvarsApplication = vData
End Property

Public Property Get Application() As String
    Application = mvarsApplication
End Property

Public Property Let Invocation(ByVal vData As Long)
    mvarsInvocation = vData
End Property

Public Property Get Invocation() As Long
    Invocation = mvarsInvocation
End Property

Public Property Get Supported() As Boolean
    Select Case Me.ActionType
        Case 1, 2, 4, 8, 16, 32, 64, 256
            Supported = True
        Case Else
            Supported = False
    End Select
End Property

Public Sub Execute()
'=============================================================
' Action.Execute
'-------------------------------------------------------------
' Purpose: Select the execution-method for the action-type
' Author : Thomas Seidel, Dienstag, 7. Mai 2002
' Notes  : not all types implemented yet
'-------------------------------------------------------------
' Parameters
'-----------
'
'-------------------------------------------------------------
' Returns:
'-------------------------------------------------------------
' Revision History
'-------------------------------------------------------------
' Dienstag, 7. Mai 2002 TSL:
'=============================================================
' End Code Header block
    
    Select Case Me.ActionType
        Case 1: ExecuteURL
        Case 2: ExecuteHTML
        Case 4: ExecuteStatement
        Case 8: ExecuteDataSet
        Case 16, 256
            ExecuteRowset
        Case 32: ExecuteCommandLine
        Case 64: ExecuteProprietary
    End Select
    
End Sub

Private Sub ExecuteURL()
'=============================================================
' Action.ExecuteURL
'-------------------------------------------------------------
' Purpose: executes the action-type with action-content
'          in that case, an IE will be created+navigate to the
'          given url
' Author : Thomas Seidel, Dienstag, 7. Mai 2002
' Notes :
'-------------------------------------------------------------
' Parameters
'-----------
'
'-------------------------------------------------------------
' Returns:
'-------------------------------------------------------------
' Revision History
'-------------------------------------------------------------
' Dienstag, 7. Mai 2002 TSL:
'=============================================================

Dim IE As SHDocVw.InternetExplorer

On Error GoTo HandleErr

    'create a new Internet-Explorer-Object
    Set IE = New SHDocVw.InternetExplorer
    'navigate to tempfile in new browser internet exporer
    IE.Offline = True
    IE.Navigate Me.Content, vbNormalFocus

    Exit Sub

HandleErr:
    MsgBox "Error " & Err.Number & ": " & Err.Description, vbCritical, "Action.ExecuteURL"
  
End Sub

Private Sub ExecuteHTML()
'=============================================================
' Action.ExecuteURL
'-------------------------------------------------------------
' Purpose: executes the action-type with action-content
'          in that case, an new html-file will be created with
'          actions content and opened in a browser
' Author : Thomas Seidel, Dienstag, 7. Mai 2002
' Notes :
'-------------------------------------------------------------
' Parameters
'-----------
'
'-------------------------------------------------------------
' Returns:
'-------------------------------------------------------------
' Revision History
'-------------------------------------------------------------
' Dienstag, 7. Mai 2002 TSL:
'=============================================================

Dim fso As New FileSystemObject
Dim oStream As TextStream
Dim sTempPath As String
Dim sTempFile As String
Dim RetVal As Long
  
On Error GoTo HandleErr

    sTempPath = Space$(256)
    'get a temp-path through win-api-call
    RetVal = GetTempPath(Len(sTempPath), sTempPath)
    sTempFile = Space(256)
    'get a temp-file in temppath with actionname through win-api-call
    RetVal = GetTempFileName(sTempPath, Me.ActionName, 0&, sTempFile)
    sTempFile = Left(Trim(sTempFile), Len(Trim(sTempFile)) - 4) & "htm"
    Set oStream = fso.CreateTextFile(sTempFile, True)
    'write action-content to tempfile
    oStream.WriteLine Me.Content
    oStream.Close
    
    Dim IE As New SHDocVw.InternetExplorer
    'navigate to tempfile in new browser internet exporer
    IE.Offline = True
    IE.Navigate sTempFile, vbNormalFocus


    Exit Sub

HandleErr:
    MsgBox "Error " & Err.Number & ": " & Err.Description, vbCritical, "Action.ExecuteHTML"
    
End Sub

Private Sub ExecuteStatement()
'=============================================================
' Action.ExecuteStatement
'-------------------------------------------------------------
' Purpose: executes the action-type with action-content
'          in that case, an statement will be executed
' Author : Thomas Seidel, Dienstag, 7. Mai 2002
' Notes  : not implemented until now
'-------------------------------------------------------------
' Parameters
'-----------
'
'-------------------------------------------------------------
' Returns:
'-------------------------------------------------------------
' Revision History
'-------------------------------------------------------------
' Dienstag, 7. Mai 2002 TSL:
'=============================================================

On Error GoTo HandleErr
    MsgBox Me.Content, , "Statement"

    Exit Sub

HandleErr:
    MsgBox "Error " & Err.Number & ": " & Err.Description, vbCritical, "Action.ExecuteStatement"
End Sub

Private Sub ExecuteDataSet()
'=============================================================
' Action.ExecuteDataSet
'-------------------------------------------------------------
' Purpose: executes the action-type with action-content
'          in that case, ... mhm
' Author : Thomas Seidel, Dienstag, 7. Mai 2002
' Notes  : not implemented until now
'-------------------------------------------------------------
' Parameters
'-----------
'
'-------------------------------------------------------------
' Returns:
'-------------------------------------------------------------
' Revision History
'-------------------------------------------------------------
' Dienstag, 7. Mai 2002 TSL:
'=============================================================
    
Dim objWorkbook As Workbook
Dim objSheet As Worksheet
Dim sFormula As String
Dim sTemplate As String
    
On Error GoTo HandleErr
    
    If g_AppPlain Is Nothing Then
        Set g_AppPlain = New AXLCLib.Application
    End If
    
    sTemplate = GetPlainTemplatesPath
    
    If sTemplate = "" Then GoTo rsmExecute
    
    If Right(sTemplate, 1) <> "\" Then sTemplate = sTemplate & "\"
    
    sTemplate = sTemplate & C_TEMPLATE_DEFAULT
    
rsmExecute:
    
    If sTemplate <> "" Then
        g_AppPlain.ExecuteMdx Me.SessionName, Me.Content, , sTemplate
    Else
        g_AppPlain.ExecuteMdx Me.SessionName, Me.Content
    End If
    
    Exit Sub

HandleErr:
    MsgBox "Error " & Err.Number & ": " & Err.Description, vbCritical, "Action.ExecuteDataSet"

End Sub

Private Sub ExecuteRowset()
'=============================================================
' Action.ExecuteRowset
'-------------------------------------------------------------
' Purpose: executes the action-type with action-content
'          in that case, ... mhm
' Author : Thomas Seidel, Dienstag, 7. Mai 2002
' Notes  : not implemented until now
'-------------------------------------------------------------
' Parameters
'-----------
'
'-------------------------------------------------------------
' Returns:
'-------------------------------------------------------------
' Revision History
'-------------------------------------------------------------
' Dienstag, 7. Mai 2002 TSL:
'=============================================================
     
On Error GoTo HandleErr
    'MsgBox Me.Content, , "RowSet"
    ExecDrillDown Me.Content
    Exit Sub

HandleErr:
    MsgBox "Error " & Err.Number & ": " & Err.Description, vbCritical, "Action.ExecuteRowset"

End Sub

Private Sub ExecuteCommandLine()
'=============================================================
' Action.ExecuteCommandLine
'-------------------------------------------------------------
' Purpose: executes the action-type with action-content
'          in that case, ... mhm
' Author : Thomas Seidel, Dienstag, 7. Mai 2002
' Notes  : not implemented until now
'-------------------------------------------------------------
' Parameters
'-----------
'
'-------------------------------------------------------------
' Returns:
'-------------------------------------------------------------
' Revision History
'-------------------------------------------------------------
' Dienstag, 7. Mai 2002 TSL:
'=============================================================
On Error GoTo HandleErr

    Shell Me.Content, vbNormalFocus

    Exit Sub

HandleErr:
    MsgBox "Error " & Err.Number & ": " & Err.Description, vbCritical, "Action.ExecuteCommandLine"

End Sub

Private Sub ExecuteProprietary()
'=============================================================
' Action.ExecuteProprietary
'-------------------------------------------------------------
' Purpose: executes the action-type with action-content
'          in that case, no proprietary types will be supported
' Author : Thomas Seidel, Dienstag, 7. Mai 2002
' Notes  : not implemented
'-------------------------------------------------------------
' Parameters
'-----------
'
'-------------------------------------------------------------
' Returns:
'-------------------------------------------------------------
' Revision History
'-------------------------------------------------------------
' Dienstag, 7. Mai 2002 TSL:
'=============================================================
On Error GoTo HandleErr
    MsgBox Me.Content, , "Propietary"

    Exit Sub

HandleErr:
    MsgBox "Error " & Err.Number & ": " & Err.Description, vbCritical, "Action.ExecuteProprietary"

End Sub
Attribute VB_Name = "Actions"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Private mvarsCatalog As String
Private mCol As Collection

Private myConn As Connection
Private myCube As String

Public Sub Add(aAction As Action, Optional sKey As String)
    If Len(sKey) = 0 Then
        mCol.Add aAction
    Else
        mCol.Add aAction, sKey
    End If
End Sub

Public Property Get Item(vntIndexKey As Variant) As Action
  Set Item = mCol(vntIndexKey)
End Property

Public Property Get Count() As Long
    Count = mCol.Count
End Property

Public Sub Remove(vntIndexKey As Variant)
    mCol.Remove vntIndexKey
End Sub

Public Property Get NewEnum() As IUnknown
    Set NewEnum = mCol.[_NewEnum]
End Property

Public Sub Clear()
    Do While mCol.Count > 0
        mCol.Remove 1
    Loop
End Sub

Private Sub Class_Initialize()
    Set mCol = New Collection
End Sub

Private Sub Class_Terminate()
    Set mCol = Nothing
End Sub

Public Property Let Catalog(ByVal vData As String)
    mvarsCatalog = vData
End Property

Public Property Get Catalog() As String
    Catalog = mvarsCatalog
End Property

Public Sub GetActions(cnOlap As Connection, sCubeName As String, Coordinate As String, CoordinateType As Long)

'    Set myConn = cnOlap
'    myCube = sCubeName
'    myCube = Replace(myCube, "[", "")
'    myCube = Replace(myCube, "]", "")
'
'    GetActionsSep myCube, MDACTION_COORDINATE_CUBE
'    GetActionsSep Left(Coordinate, InStr(1, Coordinate, "]")), set
'    GetActionsSep Coordinate, MDACTION_COORDINATE_LEVEL
'    GetActionsSep Coordinate, MDACTION_COORDINATE_MEMBER
'    GetActionsSep Coordinate, MDACTION_COORDINATE_SET
'    GetActionsSep Coordinate, MDACTION_COORDINATE_CELL
    
End Sub

Public Sub GetActionsSep(session As AXLCLib.session, cnOlap As Connection, sCube As String, sCoordinate As String, myType As Long)
Dim rsActions As Recordset
Dim sAction As String
Dim myAction As New Action

  On Error GoTo errHandler

    Set myConn = cnOlap
    'Set rsActions = myConn.OpenSchema(41, Array(myConn.DefaultDatabase, Empty, myCube _
                , Empty, Empty, sCoordinate, myType, Empty))
    Set rsActions = myConn.OpenSchema(41, Array(myConn.DefaultDatabase, Empty, sCube _
                , Empty, Empty, sCoordinate, myType, Empty))
    Do Until rsActions.EOF
        Set myAction = New Action
        'cnOlap.Properties
        
        'myAction.SessionName = cnOlap.Properties("Data Source") & "/" & cnOlap.DefaultDatabase
        Dim alias As String
        alias = session.SessionString
        'Dim i
        'i = 0
        'Do
        '    sFind = Mid(alias, Len(alias) - i, 1)
        '    i = i + 1
        'Loop While sFind <> "/" And i < Len(alias)
        'If i <> Len(alias) Then
        '    alias = Right(alias, i - 1)
        'End If

        'MsgBox alias
        myAction.SessionName = alias
        
        myAction.CatalogName = rsActions.Fields(0).Value
        If Not IsNull(rsActions.Fields(1).Value) Then
            myAction.SchemaName = rsActions.Fields(1).Value
        End If
        myAction.CubeName = rsActions.Fields(2).Value
        myAction.ActionName = rsActions.Fields(3).Value
        myAction.ActionType = rsActions.Fields(4).Value
        myAction.Coordinate = rsActions.Fields(5).Value
        myAction.CoordinateType = rsActions.Fields(6).Value
        myAction.ActionCaption = rsActions.Fields(7).Value
        If Not IsNull(rsActions.Fields(8).Value) Then
            myAction.Description = rsActions.Fields(8).Value
        End If
        myAction.Content = rsActions.Fields(9).Value
        If Not IsNull(rsActions.Fields(10).Value) Then
            myAction.Application = rsActions.Fields(10).Value
        End If
        myAction.Invocation = rsActions.Fields(11).Value
        
        If myAction.Supported Then
            Me.Add myAction, myAction.ActionName
        End If
        
        rsActions.MoveNext
    Loop
    
    Exit Sub

errHandler:
    Err.Raise Err.Number
    
End Sub
Attribute VB_Name = "DieseArbeitsmappe"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True








Private Sub Workbook_BeforeClose(Cancel As Boolean)
    ModGlobal.ClearPopup
    ModGlobal.Terminate
End Sub

Private Sub Workbook_Open()
    'ModGlobal.Initialize
End Sub

Attribute VB_Name = "ModGlobal"
Option Explicit

'**************************global variables*******************************************

Public gobjHandler As clsViewHandler

Public g_ResLangAD As clsLanguage

Public g_AppPlain As AXLCLib.Application

'=============================================================
' ModGlobal.Initialize
'-------------------------------------------------------------
' Purpose: Init's the global Objects for multi-language-support,
'          the actionhandler and drillthroughhandler
' Author : Thomas Seidel, Dienstag, 7. Mai 2002
' Notes :
'-------------------------------------------------------------
' Parameters
'-----------
'
'-------------------------------------------------------------
' Returns:
'-------------------------------------------------------------
' Revision History
'-------------------------------------------------------------
' Dienstag, 7. Mai 2002 TSL:
'=============================================================
Public Sub Initialize()

  On Error GoTo errHandlerLang

    Application.EnableCancelKey = False

    'init the global language-object
    InitLanguage
    
  On Error GoTo errHandler

    'check for Mis Plain
    If Not PlainLoaded Then
        Exit Sub
    End If
    
    'init Action-Handler thats reacts on mouse-right-click
    'Set gobjActionHandler = New clsActionHandler
    'init Drillthrough-Handler thats reacts on mouse-double-click
    'Set gobjDrillHandler = New clsDrillThroughHandler
    'init new Handler thats reacts on mouse-right/double-click
    Set gobjHandler = New clsViewHandler
    
    Exit Sub

errHandler:
    'prompt user, if procedure fails
    MsgBox g_ResLangAD.GetResourceText(RES_MSG_PROMPT_INIT), vbOKOnly Or vbExclamation, g_ResLangAD.GetResourceText(RES_MSG_TITLE_INIT)
    'destroys global objects
    Terminate
    Exit Sub
    
errHandlerLang:
    MsgBox "An error occured while initializing ressources.", vbCritical, "MIS Plain ActionDrillThrough - Init"
    Terminate
    
End Sub

Public Sub InitLanguage()

On Error GoTo EH:

    Set g_ResLangAD = New clsLanguage
    
    g_ResLangAD.Init
    Exit Sub

EH:
    MsgBox g_ResLangAD.GetResourceText(RES_MSG_PROMPT_LANGUAGEDLLERROR), vbOKOnly Or vbExclamation, g_ResLangAD.GetResourceText(RES_MSG_TITLE_LANGUAGEDLLERROR)
    
End Sub


'=============================================================
' modGlobal.Terminate
'-------------------------------------------------------------
' Purpose: terminate global objects
' Author : Thomas Seidel, Donnerstag, 30. Mai 2002
' Notes :
'-------------------------------------------------------------
' Parameters
'-----------
'
'-------------------------------------------------------------
' Returns:
'-------------------------------------------------------------
' Donnerstag, 30. Mai 2002 TSL:
'=============================================================
Public Sub Terminate()
    
    Set gobjHandler = Nothing
    Set g_ResLangAD = Nothing
    
End Sub


'=============================================================
' ModGlobal.ClearPopup
'-------------------------------------------------------------
' Purpose: deletes menu-entries for actions
' Author : Thomas Seidel, Freitag, 31. Mai 2002
' Notes :
'-------------------------------------------------------------
' Parameters
'-----------
'
'-------------------------------------------------------------
' Returns:
'-------------------------------------------------------------
' Freitag, 31. Mai 2002 TSL:
'=============================================================
Public Sub ClearPopup()
    
    If Not gobjHandler Is Nothing Then
        'gobjHandler.ClearPopup
    End If
    
End Sub


'=============================================================
' ModGlobal.EvalPopUpActions
'-------------------------------------------------------------
' Purpose: calls the action-execution for selected menu-entry
' Author : Thomas Seidel, Freitag, 31. Mai 2002
' Notes :
'-------------------------------------------------------------
' Parameters
'-----------
'
'-------------------------------------------------------------
' Returns:
'-------------------------------------------------------------
' Freitag, 31. Mai 2002 TSL:
'=============================================================
Public Sub EvalPopUpActions()
    
    If Not gobjHandler Is Nothing Then
        ExecuteAction (CLng(Application.Caller(1)))
    End If
End Sub

Public Sub EvalPopUpActionsCategory()
    If Not gobjHandler Is Nothing Then
        gobjHandler.PopulatePopupActionsNew
    End If
End Sub

Public Sub ExecuteAction(lngAction As Long)
Dim objAction As Action

    Set objAction = gobjHandler.Actions.Item(lngAction)
    objAction.Execute
End Sub


'=============================================================
' ModGlobal.EvalPopUpDrill
'-------------------------------------------------------------
' Purpose: calls the drillthrough-execution
' Author : Thomas Seidel, Freitag, 31. Mai 2002
' Notes :
'-------------------------------------------------------------
' Parameters
'-----------
'
'-------------------------------------------------------------
' Returns:
'-------------------------------------------------------------
' Freitag, 31. Mai 2002 TSL:
'=============================================================
Public Sub EvalPopUpDrill()
Dim objForm As frmOptions

  On Error GoTo errHandler

    If g_ResLangAD Is Nothing Then Initialize
    
    Set objForm = New frmOptions
    'show option dialog for drillthrough
    objForm.Show
    If Not objForm.blCancel Then
        'execute drilldown, if optiondialog is not been canceled
        ExecDrillDown , objForm.lngMaxRows
    End If
    Unload objForm
    Set objForm = Nothing
    
    Exit Sub
    
errHandler:
    MsgBox Err.Description, vbCritical
    
End Sub

Public Sub ExecDrillDown(Optional sMDX$, Optional lngMax As Long)

Dim objDrillThrough As New clsDrillThrough
Dim objWorkbook As Workbook
Dim objSheet As Worksheet
Dim vntRes As Boolean
Dim lngConnType As Long
    
  On Error GoTo errHandler
    
        If gobjHandler.IsView Then
        If Not gobjHandler.GetConnFromView Then GoTo errHandler
    Else
        If Not gobjHandler.GetConnForFormula Then GoTo errHandler
    End If
    'add a new workbook for results from drillthrough
    Set objWorkbook = Workbooks.Add
    
    ' Begin of revision 03.06.02 FFS
    ' Adding a new workbook should throw two events to Plain
    ' Theese events are not thrown, as workaround the macros called for theese events
    ' are manually called
    Application.ExecuteExcel4Macro ("__OnWindow()")
    Application.ExecuteExcel4Macro ("__OnSheet()")
    ' End of revision 03.06.02
    
    'first sheet as target
    Set objSheet = objWorkbook.Sheets(1)
    
    'set properties for drillthrough-object
    With objDrillThrough
        .Rows = lngMax
        .Row = gobjHandler.RowSet
        .Column = gobjHandler.ColumnSet
        .Cube = gobjHandler.Cube
        .Filters = gobjHandler.Filters
        .MeasureDim = gobjHandler.MeasureDim
                
        'execute drillthrough
        
        If gobjHandler.Connection.State <> 1 Then gobjHandler.Connection.Open
        
        vntRes = .ExecDrillThrough(gobjHandler.Connection, objSheet, sMDX)
        If Not vntRes Then
            GoTo errHandler
        End If
    End With
    
    gobjHandler.Connection.Close
    Set objSheet = Nothing
    Set objWorkbook = Nothing
    
    Exit Sub
    
errLocalCube:
    MsgBox g_ResLangAD.GetResourceText(RES_MSG_PROMPT_ERRLOCAL), vbOKOnly Or vbExclamation, g_ResLangAD.GetResourceText(RES_MSG_TITLE_ERRLOCAL)
    GoTo errHandler

errHTTPConn:

    MsgBox g_ResLangAD.GetResourceText(RES_MSG_PROMPT_ERRHTTP), vbOKOnly Or vbExclamation, g_ResLangAD.GetResourceText(RES_MSG_TITLE_ERRHTTP)

errHandler:
    'maintenance
    If Not gobjHandler.Connection Is Nothing Then
        If gobjHandler.Connection.State = 1 Then
            gobjHandler.Connection.Close
        End If
    End If
    
    If Not objWorkbook Is Nothing Then
        objWorkbook.Close False
        ' Begin of revision 03.06.02 FFS
        ' Adding a new workbook should throw two events to Plain
        ' Theese events are not thrown, as workaround the macros called for theese events
        ' are manually called
        Application.ExecuteExcel4Macro ("__OnWindow()")
        Application.ExecuteExcel4Macro ("__OnSheet()")
        ' End of revision 03.06.02
        Set objWorkbook = Nothing
    End If

End Sub

Attribute VB_Name = "Tabelle1"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True












Attribute VB_Name = "Tabelle2"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True












Attribute VB_Name = "Tabelle3"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True












Attribute VB_Name = "clsDrillThrough"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Private mvariRows As Integer
Private mvarsCube As String
Private mvarsRow As String
Private mvarsCol As String
Private mvarsMeasureDim As String
Private mvarsFilters As Variant
Private mvaroWS As Worksheet

Public Property Set Worksheet(ByVal vData As Worksheet)
    Set mvaroWS = vData
End Property

Public Property Get Worksheet() As Worksheet
    Set Worksheet = mvaroWS
End Property

Public Property Let Rows(ByVal vData As Integer)
    mvariRows = vData
End Property

Public Property Get Rows() As Integer
    Rows = mvariRows
End Property

Public Property Let Cube(ByVal vData As String)
    mvarsCube = vData
End Property

Public Property Get Cube() As String
    mvarsCube = CheckCubeName(mvarsCube)
    Cube = mvarsCube
End Property

Public Property Let Row(ByVal vData As String)
    mvarsRow = vData
End Property

Public Property Get Row() As String
    Row = mvarsRow
End Property

Public Property Let Column(ByVal vData As String)
    mvarsCol = vData
End Property

Public Property Get Column() As String
    Column = mvarsCol
End Property

Public Property Let Filters(ByRef vData As Variant)
    mvarsFilters = vData
End Property

Public Property Get Filters() As Variant
    Filters = mvarsFilters
End Property

Public Property Get MeasureDim() As String
    MeasureDim = mvarsMeasureDim
End Property

Public Property Let MeasureDim(ByVal vData As String)
    mvarsMeasureDim = vData
End Property

Public Function ExecDrillThrough(cnOlap As Connection, Optional shActive As Worksheet, Optional sMDX$) As Boolean
Dim rsDrill As Recordset
'Dim sMDX As String
Dim iRow As Integer
Dim sErr As String

On Error GoTo errHandler

    If shActive Is Nothing Then
        sErr = "No worksheet is given!"
        GoTo errHandler
    Else
        Set mvaroWS = shActive
    End If
    
    'build drillthrough-query
    If Trim(sMDX) = "" Then sMDX = BuildDrillThroughMDX
    Debug.Print sMDX
    Application.EnableEvents = False
    Set rsDrill = cnOlap.Execute(sMDX)
    
    ' bEmpty is return value indicating whether the result is empty
    Dim bEmpty As Boolean
    If Not ShowInWorksheet(rsDrill, cnOlap, bEmpty) Then
        sErr = "result could not be shown."
        Application.EnableEvents = True
        GoTo errHandler
    End If
    Application.EnableEvents = True
    
    Set rsDrill = Nothing
    
    ' is the result empty?
    If bEmpty = True Then
        GoTo errEmpty
    End If
    
    ExecDrillThrough = True
    
    Exit Function
    
errEmpty:
    MsgBox g_ResLangAD.GetResourceText(RES_MSG_PROMPT_EMPTYRES), vbOKOnly Or vbExclamation, g_ResLangAD.GetResourceText(RES_MSG_TITLE_EMPTYRES)
    Exit Function
    
errHandler:
    MsgBox Err.Description
    MsgBox g_ResLangAD.GetResourceText(RES_MSG_PROMPT_ERRDRL), vbOKOnly Or vbExclamation, g_ResLangAD.GetResourceText(RES_MSG_TITLE_ERRDRL)

End Function

Private Function ShowInWorksheet(rsResult As Recordset, cnOlap As ADODB.Connection, ByRef bEmpty As Boolean) As Boolean
Dim iFields As Integer
Dim sDesc As String
Dim iSums As Integer
Dim asSums() As Integer
Dim sAdd As String
Dim sAdd2 As String
Dim x As Integer
Dim xlCalc As Long

On Error GoTo errorHandler

    With mvaroWS
        ' bFirst tells whether we are on the first non-empty record set and whether to write header
        Dim bFirst As Boolean
        bFirst = True
        ' go through all record sets
        Do While Not rsResult Is Nothing
            ' is this record set empty?
            If Not rsResult.EOF Then
                bEmpty = False
                rsResult.MoveFirst
                ' write header when on first non-empty recordset
                If bFirst = True Then
                    Application.ScreenUpdating = False
                    xlCalc = Application.Calculation
                    Application.Calculation = xlCalculationManual
                    
                    .Cells.Clear
                    iRow = 1
                    For i = 0 To rsResult.Fields.Count - 1
                        .Cells(1, i + 1).Value = rsResult.Fields(i).Name
                        'If MeasureTypIsNumeric(cnOlap, mvarsCube, rsResult.Fields(i).Name) Then
                        If rsResult.Fields(i).Type = adCurrency Or _
                            rsResult.Fields(i).Type = adDecimal Or _
                            rsResult.Fields(i).Type = adDouble Or _
                            rsResult.Fields(i).Type = adInteger Or _
                            rsResult.Fields(i).Type = adNumeric Then
                                ReDim Preserve asSums(0 To iSums)
                                asSums(iSums) = i
                                iSums = iSums + 1
                        End If
                    Next i
                    bFirst = False
                End If
                ' write values
                Do While Not rsResult.EOF And iRow < 65534
                    iRow = iRow + 1
                    For i = 0 To rsResult.Fields.Count - 1
                        If Not IsNull(rsResult.Fields(i).Value) Then
                            If IsNumeric(rsResult.Fields(i).Value) Then
                                .Cells(iRow, i + 1).Value = CDbl(rsResult.Fields(i).Value)
                            Else
                                .Cells(iRow, i + 1).Value = CStr(rsResult.Fields(i).Value)
                            End If
                        End If
                    Next i
                    rsResult.MoveNext
                Loop
            End If
            ' move to next record set
            Set rsResult = rsResult.NextRecordset
        Loop
        
        ' is the result empty?
        If bFirst = True Then
            GoTo errEmpty
        End If
        
        Dim fixRows As Integer
        fixRows = 1
        If iSums > 0 Then
            .Rows(1).Insert
            fixRows = fixRows + 1
        End If
        For x = 0 To iSums - 1
            sAdd = Range("A1").Offset(2, asSums(x)).Address
            sAdd2 = Range("A1").Offset(iRow + 1, asSums(x)).Address
            Range("A1").Offset(0, asSums(x)).Formula = "=SUM(" & sAdd & ":" & sAdd2 & ")"
        Next x
        .Rows("1:" & fixRows).Font.Bold = True
        .Range("A" & (fixRows + 1)).Select
        ActiveWindow.FreezePanes = True
        Columns.EntireColumn.AutoFit
    End With
    Application.ScreenUpdating = True
    Application.Calculation = xlCalc
    ShowInWorksheet = True
    Exit Function
    
errEmpty:
    ' set empty flag and return True
    bEmpty = True
    ShowInWorksheet = True
    Exit Function
    
errorHandler:
    MsgBox Err.Description, vbCritical, "an error occured"

End Function

Private Function BuildDrillThroughMDX() As String
Dim sMDX As String
Dim sFilter As String
Dim iFilter As Integer
Dim sDim As String
Dim vntRes As Variant

  On Error GoTo errHandler
  
    sMDX = "DRILLTHROUGH "
    
    If Me.Rows > 0 Then
        sMDX = sMDX & "MAXROWS " & Me.Rows & " "
    End If
    
    sMDX = sMDX & " SELECT {"
    If IsEmpty(Me.Column) Then
        GoTo errHandler
    End If
    sMDX = sMDX & Me.Column
    sMDX = sMDX & "} ON COLUMNS"
    
    If IsEmpty(Me.Row) Or Me.Row = "" Then
        GoTo noRows
    End If
    sMDX = sMDX & ", {" & Me.Row
    sMDX = sMDX & "} ON ROWS"
    
noRows:
    sMDX = sMDX & " FROM " & Me.Cube
    
    If Not IsArray(Me.Filters) Then
        GoTo nofilter
    End If
    On Error Resume Next
    If IsEmpty(Me.Filters) Or UBound(mvarsFilters) = 0 Then
        GoTo nofilter
    End If
    On Error GoTo 0
    

    For iRow = 0 To UBound(mvarsFilters)
        sFilter = mvarsFilters(iRow)
        sDim = Left(sFilter, InStr(1, sFilter, "]"))
        If (sDim <> mvarsMeasureDim) And sDim <> "" Then
            iFilter = iFilter + 1
            If iFilter > 1 Then
                sMDX = sMDX & ", " & mvarsFilters(iRow)
            Else
                sMDX = sMDX & " WHERE (" & mvarsFilters(iRow)
            End If
        End If
    Next iRow

    If iFilter > 0 Then sMDX = sMDX & ")"

nofilter:
    BuildDrillThroughMDX = sMDX
    Exit Function
    
errHandler:
    MsgBox g_ResLangAD.GetResourceText(RES_MSG_PROMPT_ERRDRL), vbOKOnly Or vbExclamation, g_ResLangAD.GetResourceText(RES_MSG_TITLE_ERRDRL)

End Function

Private Sub Class_Initialize()

    mvarblShowAll = False
    mvarblShowWS = True
    mvariRows = 1000

End Sub

Public Function MeasureTypIsNumeric(cnOlap As ADODB.Connection, sCube As String, sMeasure) As Boolean
Dim rsMeas As Recordset
Dim blClosed As Boolean
Dim sFirstMeasure As String
    
On Error GoTo errorHandler
    
    If cnOlap.State <> 1 Then
        cnOlap.Open
        blClosed = True
    End If
    
    Set rsMeas = cnOlap.OpenSchema(adSchemaMeasures, Array(cnOlap.DefaultDatabase, Empty, sCube, Empty, Empty))
    Do While Not rsMeas.EOF
        sFirstMeasure = rsMeas.Fields("MEASURE_NAME_SQL_COLUMN_NAME").Value
        sFirstMeasure = Left(sFirstMeasure, InStr(1, sFirstMeasure, "].["))
        rsMeas.MoveNext
    Loop
    rsMeas.Close
    Set rsMeas = Nothing
    
    If blClosed Then cnOlap.Close
    
    MeasureTypIsNumeric = True
    Exit Function
    
errorHandler:
    MeasureTypIsNumeric = False
    Err.Raise Err.Number, Err.Source, Err.Description, Err.HelpFile, Err.HelpContext

End Function
Attribute VB_Name = "clsLanguage"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

#If VBA7 Then
Private lngDllHandle As LongPtr
#Else
Private lngDllHandle As Long
#End If

' Initializes the Language dll.
' GetLanguage returns "EN", "DE" ......etc
' the AWizEN.dll and it's buddies must be in the root of the workbook
Public Sub Init()

    On Error GoTo Fail
    
        Dim addinName As String
#If Win64 Then
        addinName = Left(ThisWorkbook.Name, Len(ThisWorkbook.Name) - 4) & "64"
#Else
        addinName = Left(ThisWorkbook.Name, Len(ThisWorkbook.Name) - 4)
#End If
        lngDllHandle = LoadLibrary(ThisWorkbook.Path & "\" & GetLanguage & "\" & addinName & ".resources.dll")
    
        If lngDllHandle = 0 Then
            GoTo Fail
        End If
    
        Exit Sub

Fail:

    Err.Raise 1

End Sub

Private Sub Class_Terminate()
    If Not lngDllHandle = 0 Then
            FreeLibrary lngDllHandle
            lngDllHandle = 0
        End If
End Sub


' Returns a resource text given it's ID
' if any text for replacement is available then it will be replaced
' any "%" in the resource text means a replacement given by ParamArray
' any "^" in the resource text means a CarriageReturn
Public Function GetResourceText(ID As Long, ParamArray Items() As Variant) As String
    Dim i As Integer
    Dim nSize As Integer
    Dim intFirst As Integer
    Dim strTemp As String
    Dim strResource As String
    Dim strBuffer() As Byte
    
    strBuffer = Space$(1024)
    nSize = LoadString(lngDllHandle, ID, strBuffer(0), 1024)
    strResource = strBuffer
    strResource = Left(strResource, nSize)

    For i = LBound(Items) To UBound(Items)
        intFirst = InStr(1, strResource, "%", vbTextCompare)
        strTemp = Left(strResource, intFirst)
        strTemp = ReplaceTextInString(strTemp, "%", CStr(Items(i)))
        
        strResource = Right(strResource, Len(strResource) - intFirst)
        strResource = strTemp & strResource
    Next
    
    GetResourceText = strResource
End Function


' Trims the rubbish junk characters from the buffer where the LoadResource stores the resource text
Private Function FTrim(strValue As String) As String

    Dim strResult As String
    Dim i As Integer
    
    For i = 1 To Len(strValue)
    
        If Asc(Mid(strValue, i, 1)) <> 0 Then
            strResult = strResult & Mid(strValue, i, 1)
        End If
    
    Next

    FTrim = strResult

End Function


Public Function GetResourceBitmap(strKey As String) As IPictureDisp

    'Set GetResourceBitmap = LoadResPicture(strKey, 1)

End Function

Attribute VB_Name = "clsRegistery"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
 DefStr S
DefLng H-I, L, N
DefVar V
DefBool B

#If VBA7 Then
Private Type OSVERSIONINFO
        dwOSVersionInfoSize As Long
        dwMajorVersion As Long
        dwMinorVersion As Long
        dwBuildNumber As Long
        dwPlatformId As Long
        szCSDVersion(0 To 127) As Byte      '  Maintenance string for PSS usage
End Type
  
Private Type SECURITY_ATTRIBUTES
        nLength As Long
        lpSecurityDescriptor As LongPtr
        bInheritHandle As Long
End Type


  ' RegCreateKeyEx creates the specified key. If the key
' already exists, the function opens it. The phkResult
' parameter receives the key handle.
Private Declare PtrSafe Function RegCreateKeyEx Lib "advapi32.dll" Alias "RegCreateKeyExA" (ByVal hKey As LongPtr, ByVal lpSubKey As String, ByVal Reserved As Long, ByVal lpClass As String, ByVal dwOptions As Long, ByVal samDesired As Long, lpSecurityAttributes As SECURITY_ATTRIBUTES, phkResult As LongPtr, lpdwDisposition As Long) As Long
  'RegCloseKey releases a handle to the specified key.
'(Key handles should not be left open any longer than
'necessary.)
Private Declare PtrSafe Function RegCloseKey Lib "advapi32.dll" (ByVal hKey As LongPtr) As Long
 ' RegQueryInfoKey retrieves information about the specified
'key, such as the number of subkeys and values, the length
'of the longest value and key name, and the size of the
'longest data component among the key's values.
Private Declare PtrSafe Function RegQueryInfoKey Lib "advapi32.dll" Alias "RegQueryInfoKeyA" (ByVal hKey As LongPtr, ByVal lpClass As String, lpcbClass As Long, ByVal lpReserved As LongPtr, lpcSubKeys As Long, lpcbMaxSubKeyLen As Long, lpcbMaxClassLen As Long, lpcValues As Long, lpcbMaxValueNameLen As Long, lpcbMaxValueLen As Long, lpcbSecurityDescriptor As Long, lpftLastWriteTime As LongPtr) As Long
'RegEnumKeyEx enumerates subkeys of the specified open
'key. Retrieves the name (and its length) of each subkey.
Private Declare PtrSafe Function RegEnumKeyEx Lib "advapi32.dll" Alias "RegEnumKeyExA" (ByVal hKey As LongPtr, ByVal dwIndex As Long, ByVal lpName As String, lpcbName As Long, ByVal lpReserved As LongPtr, ByVal lpClass As String, lpcbClass As Long, lpftLastWriteTime As LongPtr) As Long
  'RegEnumValue enumerates the values for the specified open
  'key. Retrieves the name (and its length) of each value,
'and the type, content and size of the data.
Private Declare PtrSafe Function RegEnumValue Lib "advapi32.dll" Alias "RegEnumValueA" (ByVal hKey As LongPtr, ByVal dwIndex As Long, ByVal lpValueName As String, lpcbValueName As Long, ByVal lpReserved As LongPtr, lpType As Long, lpData As Any, lpcbData As Long) As Long
  'RegQueryValueEx retrieves the type, content and data for
' a specified value name. Note that if you declare the
' lpData parameter as String, you must pass it By Value.
Private Declare PtrSafe Function RegQueryValueEx Lib "advapi32.dll" Alias "RegQueryValueExA" (ByVal hKey As LongPtr, ByVal lpValueName As String, ByVal lpReserved As LongPtr, lpType As Long, lpData As Any, lpcbData As Long) As Long         ' Note that if you declare the lpData parameter as String, you must pass it By Value.
  'RegSetValueEx sets the data and type of a specified
' value under a key.
Private Declare PtrSafe Function RegSetValueEx Lib "advapi32.dll" Alias "RegSetValueExA" (ByVal hKey As LongPtr, ByVal lpValueName As String, ByVal Reserved As Long, ByVal dwType As Long, lpData As Any, ByVal cbData As Long) As Long         ' Note that if you declare the lpData parameter as String, you must pass it By Value.
  'RegDeleteValue removes a named value from specified key.
Private Declare PtrSafe Function RegDeleteValue Lib "advapi32.dll" Alias "RegDeleteValueA" (ByVal hKey As LongPtr, ByVal lpValueName As String) As Long
  'RegDeleteKey deletes a subkey. Under Win 95/98, also
'deletes all subkeys and values. Under Windows NT/2000,
'the subkey to be deleted must not have subkeys. The class
'attempts to use SHDeleteKey (see below) before using
'RegDeleteKey.
Private Declare PtrSafe Function RegDeleteKey Lib "advapi32.dll" Alias "RegDeleteKeyA" (ByVal hKey As LongPtr, ByVal lpSubKey As String) As Long
  'SHDeleteKey deletes a subkey and all its descendants.
'Under Windows NT 4.0, Internet Explorer 4.0 or later
'is required.
Private Declare PtrSafe Function SHDeleteKey Lib "Shlwapi" _
   Alias "SHDeleteKeyA" (ByVal hKey As LongPtr, _
   ByVal lpSubKey As String) As Long
Private Declare PtrSafe Function LoadLibrary Lib "Kernel32" Alias "LoadLibraryA" (ByVal lpLibFileName As String) As LongPtr
Private Declare PtrSafe Function FreeLibrary Lib "Kernel32" (ByVal hLibModule As LongPtr) As Long
 
Private Declare PtrSafe Function ExpandEnvStrings Lib "Kernel32" Alias "ExpandEnvironmentStringsA" (ByVal lpSrc As String, ByVal lpDst As String, ByVal nSize As Long) As Long

Private Declare PtrSafe Function GetVersionEx Lib "Kernel32" Alias "GetVersionExA" (lpVersionInformation As OSVERSIONINFO) As Long
  
#Else
 Private Type OSVERSIONINFO
  dwOSVersionInfoSize As Long
  dwMajorVersion As Long
  dwMinorVersion As Long
  dwBuildNumber As Long
  dwPlatformId As Long
  szCSDVersion As String * 128
End Type
  Private Type SECURITY_ATTRIBUTES
  nLength As Long
  lpSecurityDescriptor As Long
  bInheritHandle As Long
End Type
  ' RegCreateKeyEx creates the specified key. If the key
' already exists, the function opens it. The phkResult
' parameter receives the key handle.
Private Declare Function RegCreateKeyEx Lib "advapi32.dll" Alias "RegCreateKeyExA" ( _
   ByVal hKey As Long, ByVal lpSubKey As String, _
   ByVal Reserved As Long, ByVal lpClass As String, _
   ByVal dwOptions As Long, ByVal samDesired As Long, _
  lpSecurityAttributes As SECURITY_ATTRIBUTES, _
  phkResult As Long, lpdwDisposition As Long) As Long
  'RegCloseKey releases a handle to the specified key.
'(Key handles should not be left open any longer than
'necessary.)
Private Declare Function RegCloseKey Lib "advapi32.dll" ( _
   ByVal hCurKey As Long) As Long
 ' RegQueryInfoKey retrieves information about the specified
'key, such as the number of subkeys and values, the length
'of the longest value and key name, and the size of the
'longest data component among the key's values.
Private Declare Function RegQueryInfoKey _
   Lib "advapi32.dll" Alias "RegQueryInfoKeyA" ( _
   ByVal hCurKey As Long, ByVal lpClass As String, _
  lpcbClass As Long, ByVal lpReserved As Long, _
  lpcSubKeys As Long, lpcbMaxSubKeyLen As Long, _
  lpcbMaxClassLen As Long, lpcValues As Long, _
  lpcbMaxValueNameLen As Long, lpcbMaxValueLen As Long, _
  lpcbSecurityDescriptor As Long, _
  lpftLastWriteTime As Long) As Long
  'RegEnumKeyEx enumerates subkeys of the specified open
'key. Retrieves the name (and its length) of each subkey.
Private Declare Function RegEnumKeyEx Lib "advapi32.dll" _
   Alias "RegEnumKeyExA" (ByVal hCurKey As Long, _
   ByVal dwIndex As Long, ByVal lpName As String, _
  lpcbName As Long, ByVal lpReserved As Long, _
   ByVal lpClass As String, lpcbClass As Long, _
  lpftLastWriteTime As Long) As Long
  'RegEnumValue enumerates the values for the specified open
  'key. Retrieves the name (and its length) of each value,
'and the type, content and size of the data.
Private Declare Function RegEnumValue Lib "advapi32.dll" _
   Alias "RegEnumValueA" (ByVal hCurKey As Long, _
   ByVal dwIndex As Long, ByVal lpValueName As String, _
  lpcbValueName As Long, ByVal lpReserved As Long, _
  lpType As Long, lpData As Any, lpcbData As Long) As Long
  'RegQueryValueEx retrieves the type, content and data for
' a specified value name. Note that if you declare the
' lpData parameter as String, you must pass it By Value.
Private Declare Function RegQueryValueEx _
   Lib "advapi32.dll" Alias "RegQueryValueExA" ( _
   ByVal hCurKey As Long, ByVal lpValueName As String, _
   ByVal lpReserved As Long, lpType As Long, _
  lpData As Any, lpcbData As Long) As Long
  'RegSetValueEx sets the data and type of a specified
' value under a key.
Private Declare Function RegSetValueEx Lib "advapi32.dll" _
   Alias "RegSetValueExA" (ByVal hCurKey As Long, ByVal _
  lpValueName As String, ByVal Reserved As Long, _
   ByVal dwType As Long, lpData As Any, _
   ByVal cbData As Long) As Long
  'RegDeleteValue removes a named value from specified key.
Private Declare Function RegDeleteValue _
   Lib "advapi32.dll" Alias "RegDeleteValueA" ( _
   ByVal hCurKey As Long, ByVal lpValueName As String) _
   As Long
  'RegDeleteKey deletes a subkey. Under Win 95/98, also
'deletes all subkeys and values. Under Windows NT/2000,
'the subkey to be deleted must not have subkeys. The class
'attempts to use SHDeleteKey (see below) before using
'RegDeleteKey.
Private Declare Function RegDeleteKey Lib "advapi32.dll" _
   Alias "RegDeleteKeyA" (ByVal hKey As Long, _
   ByVal lpSubKey As String) As Long
  'SHDeleteKey deletes a subkey and all its descendants.
'Under Windows NT 4.0, Internet Explorer 4.0 or later
'is required.
Private Declare Function SHDeleteKey Lib "Shlwapi" _
   Alias "SHDeleteKeyA" (ByVal hKey As Long, _
   ByVal lpSubKey As String) As Long
 Private Declare Function LoadLibrary Lib "Kernel32" _
   Alias "LoadLibraryA" (ByVal lpLibFileName As String) _
   As Long
  Private Declare Function FreeLibrary Lib "Kernel32" ( _
   ByVal hLibModule As Long) As Long
  Private Declare Function ExpandEnvStrings Lib "Kernel32" _
   Alias "ExpandEnvironmentStringsA" ( _
   ByVal lpSrc As String, ByVal lpDst As String, _
   ByVal nSize As Long) As Long
  Private Declare Function GetVersionEx Lib "Kernel32" _
   Alias "GetVersionExA" ( _
  lpVersionInformation As OSVERSIONINFO) As Long
  
#End If
  Private Const REG_SZ = 1
Private Const REG_EXPAND_SZ = 2
Private Const REG_DWORD = 4
Private Const REG_DWORD_LITTLE_ENDIAN = REG_DWORD
Private Const REG_MULTI_SZ = 7
  
' The following values are only relevant under WinNT/2K,
' and are ignored by Win9x.
Private Const STANDARD_RIGHTS_READ = &H20000
Private Const STANDARD_RIGHTS_WRITE = &H20000
Private Const STANDARD_RIGHTS_ALL = &H1F0000
Private Const KEY_CREATE_LINK = &H20
Private Const KEY_QUERY_VALUE = &H1
Private Const KEY_ENUMERATE_SUB_KEYS = &H8
Private Const KEY_NOTIFY = &H10
Private Const KEY_SET_VALUE = &H2
Private Const KEY_CREATE_SUB_KEY = &H4
Private Const SYNCHRONIZE = &H100000
  ' Access right to query and enumerate values.
Private Const KEY_READ = ((STANDARD_RIGHTS_READ Or _
  KEY_QUERY_VALUE Or KEY_ENUMERATE_SUB_KEYS Or _
  KEY_NOTIFY) And (Not SYNCHRONIZE))
'Access right to create values and keys.
Private Const KEY_WRITE = ((STANDARD_RIGHTS_WRITE Or _
  KEY_SET_VALUE Or KEY_CREATE_SUB_KEY) And _
   (Not SYNCHRONIZE))
'Access right to create/delete values and keys.
Private Const KEY_ALL_ACCESS = ((STANDARD_RIGHTS_ALL Or _
  KEY_QUERY_VALUE Or KEY_SET_VALUE Or _
  KEY_CREATE_SUB_KEY Or KEY_ENUMERATE_SUB_KEYS Or _
  KEY_NOTIFY Or KEY_CREATE_LINK) And (Not SYNCHRONIZE))
  Private lRequiredAccess
  Private lPreviousAccess
 'Return values for all registry functions.
Private Const ERROR_SUCCESS = 0
  'Property variables.
Private lRoot 'default is HKEY_LOCAL_MACHINE
Private lOptions
Private strKeyName
Private strValueName
Private vData
  'Variables set in GetKeyHandle.
#If VBA7 Then
Private hCurKey As LongPtr
#Else
Private hCurKey
#End If
Private nSubKeys
Private nValues
Private lMaxSubKeyLen
Private lMaxValueNameLen
Private lMaxValueLen
Private bIsWinNT
  
'Public Enum RegOptions ' variable: lOptions
'  StoreNumbersAsStrings = 1
'  ReturnMultiStringsAsArrays = 2
'  ExpandEnvironmentStrings = 4
'  ShowErrorMessages = 8
'End Enum

'Public Enum RegRoot ' variable: lRoot
'  HKEY_CLASSES_ROOT = &H80000000
'  HKEY_CURRENT_USER = &H80000001   ' default
'  HKEY_LOCAL_MACHINE = &H80000002
'End Enum
  
'Message constants.
Private Const ERROR_NO_KEY As String = _
  "No Key name specified!"
Private Const ERROR_NO_HANDLE = _
  "Could not open Registry Key!"
Private Const ERR_MSG_NO_OVERWRITE As String = _
  "Existing value has unsupported data type " & _
  "and will not be overwritten"
Private Const RETURN_UNSUPPORTED As String = _
  "(unsupported data format)"
  Private ValueList As Object
  Property Let Root(lProp As Long)
  ' Don't accept an invalid Root value.
  Select Case lProp
    Case HKEY_CLASSES_ROOT, HKEY_CURRENT_USER, _
          HKEY_LOCAL_MACHINE
       ' All is well.
    Case Else
      lRoot = HKEY_CURRENT_USER
  End Select
  If lProp <> lRoot Then
    lRoot = lProp
     If Len(strKeyName) Then
      GetKeyHandle lRoot, strKeyName
     End If
  End If
  lRoot = lProp
End Property
  Property Let Key(strProp)
  ' Don't accept an empty key name.
  If Len(strProp) = 0 Then Exit Property
  If Len(strKeyName) = 0 Then ' first time
    strKeyName = strProp
  ElseIf StrComp(strProp, strKeyName, _
                 vbTextCompare) <> 0 Then
    strKeyName = strProp
    GetKeyHandle lRoot, strKeyName
  Else
  End If
End Property
  Property Let Options(lProp As Long)
  ' Don't accept an invalid Options value.
  Select Case lProp
    Case 0 To 15: lOptions = lProp
    Case Else:
   End Select
End Property
   Property Let Value(Optional ValueName As String, vValue)
  If IsEmpty(vValue) Then
     Exit Property
   Else
    vData = vValue
   End If
  If bIsWinNT Then lRequiredAccess = KEY_WRITE Or KEY_READ
  If PropertiesOK Then
     ' First see if this is an existing value, and,
     ' if so, what data type we have here.
     Dim strBuffer, lBuffer, lType
     If RegQueryValueEx(hCurKey, ValueName, 0, lType, _
        ByVal strBuffer, lBuffer) = ERROR_SUCCESS Then
       ' Make sure our new value is the same data type.
       Select Case lType
         Case REG_SZ, REG_EXPAND_SZ ' existing string
          vData = CStr(vData)
         Case REG_DWORD, REG_DWORD_LITTLE_ENDIAN
           ' existing long
          vData = CLng(vData)
         Case REG_MULTI_SZ ' existing array
          vData = CVar(vData)
         Case Else
          ShowErrMsg ERR_MSG_NO_OVERWRITE
           Exit Property
       End Select
     End If
     If (lOptions And StoreNumbersAsStrings) Then
       If IsNumeric(vData) Then vData = CStr(vData)
     End If
     ' If nameless "(default)" value:
     If Len(ValueName) = 0 Then vData = CStr(vData)
     ' Look at the data type of vData, and store it
     ' in the appropriate registry format.
     If VarType(vData) And vbArray Then   ' 8192
       Dim sTemp As String
       ' REG_MULTI_SZ values must end with 2 null characters.
      sTemp = JoinEx(vData, vbNullChar) & String$(2, 0)
       Call RegSetValueEx(hCurKey, ValueName, 0, _
        REG_MULTI_SZ, ByVal sTemp, Len(sTemp))
     Else
       Select Case VarType(vData)
         Case vbInteger, vbLong
           Call RegSetValueEx(hCurKey, ValueName, 0, _
            REG_DWORD, CLng(vData), 4)
         Case vbString
           If ContainsEnvString(CStr(vData)) Then
             Call RegSetValueEx(hCurKey, ValueName, 0, _
              REG_EXPAND_SZ, ByVal CStr(vData), _
              Len(vData) + 1)
           Else
             Call RegSetValueEx(hCurKey, ValueName, 0, _
              REG_SZ, ByVal CStr(vData), Len(vData) + 1)
           End If
         Case Else ' Store any other data type as string.
           Call RegSetValueEx(hCurKey, ValueName, 0, _
            REG_SZ, ByVal CStr(vData), Len(vData) + 1)
       End Select
     End If
     ' Update Value Count.
     Call RegQueryInfoKey(hCurKey, vbNullString, 0, 0, 0, _
       0, 0, nValues, 0, 0, 0, 0)
     ' Clear the values database.
    ValueList.removeAll
  End If
End Property
 
 Property Get Value(Optional ValueName As String) As Variant
  With ValueList
     If .Count = 0 Then FillDataList
     If .Exists(ValueName) Then Value = .Item(ValueName)
  End With
End Property
  Property Get AllValues() As Variant
  If bIsWinNT Then lRequiredAccess = KEY_READ
  If PropertiesOK Then
     If nValues = 0 Then Exit Property
     With ValueList
       If .Count = 0 Then FillDataList
       If .Count Then
         Dim i, vKeys, vItems
        vKeys = .Keys
        vItems = .Items
         ReDim vTemp(.Count - 1, 1)
         For i = 0 To .Count - 1
          vTemp(i, 0) = vKeys(i)
          vTemp(i, 1) = vItems(i)
         Next
        AllValues = vTemp
       End If
     End With
  End If
End Property
  Property Get AllKeys() As Variant
  If bIsWinNT Then lRequiredAccess = KEY_READ
  If PropertiesOK Then
     If nSubKeys = 0 Then Exit Property
     Dim i: ReDim vTemp(nSubKeys - 1)
     For i = 0 To nSubKeys - 1
      strKeyName = String$(lMaxSubKeyLen + 1, 0)
       If RegEnumKeyEx(hCurKey, i, strKeyName, _
         lMaxSubKeyLen + 1, 0, vbNullString, 0, 0) = _
         ERROR_SUCCESS Then
        vTemp(i) = TrimNull(strKeyName)
       End If
     Next
    AllKeys = vTemp
  End If
End Property
 Function DeleteValue(Optional ValueName As String) _
   As Boolean
   If bIsWinNT Then lRequiredAccess = KEY_ALL_ACCESS
  If PropertiesOK Then
    DeleteValue = (RegDeleteValue(hCurKey, ValueName) = _
      ERROR_SUCCESS)
     If DeleteValue Then
       Call RegQueryInfoKey(hCurKey, vbNullString, 0, 0, _
        0, 0, 0, nValues, 0, 0, 0, 0)
      ValueList.removeAll
     End If
  End If
End Function
  Function DeleteKey() As Boolean
  If Len(strKeyName) = 0 Then
    ShowErrMsg ERROR_NO_KEY
     Exit Function
  End If
  Dim n, strLastKey
  n = InStrRevEx(strKeyName, "\")
  If n > 0 And n < Len(strKeyName) Then
    strLastKey = Mid$(strKeyName, n + 1)
    strKeyName = Left$(strKeyName, n - 1)
     If bIsWinNT Then lRequiredAccess = KEY_ALL_ACCESS
     Call GetKeyHandle(lRoot, strKeyName)
     If hCurKey = 0 Then Exit Function
     If ShlwapiInstalled Then
       ' This should always work.
      DeleteKey = (SHDeleteKey(hCurKey, strLastKey) = _
        ERROR_SUCCESS)
     Else
       ' This will only work under Win95/98.
      DeleteKey = (RegDeleteKey(hCurKey, strLastKey) = _
        ERROR_SUCCESS)
     End If
     If DeleteKey Then
       Call RegQueryInfoKey(hCurKey, vbNullString, 0, 0, _
        nSubKeys, 0, 0, 0, 0, 0, 0, 0)
      ValueList.removeAll
     End If
  End If
End Function
  Property Get ValueCount() As Long
  If PropertiesOK Then ValueCount = nValues
End Property
 Property Get KeyCount() As Long
  If PropertiesOK Then KeyCount = nSubKeys
End Property
  
Private Function PropertiesOK() As Boolean
  If Len(strKeyName) = 0 Then
    ShowErrMsg ERROR_NO_KEY
     Exit Function
  End If
  If lPreviousAccess Then
     If lRequiredAccess <> lPreviousAccess Then _
      CloseCurrentKey
  End If
  If hCurKey = 0 Then Call GetKeyHandle(lRoot, strKeyName)
  If hCurKey = 0 Then
    ShowErrMsg ERROR_NO_HANDLE
     Exit Function
  End If
  PropertiesOK = True
End Function
  Private Sub Class_Initialize()
  lRoot = HKEY_CURRENT_USER
  bIsWinNT = IsWinNT
  If bIsWinNT Then lRequiredAccess = KEY_READ
  On Error Resume Next
  Set ValueList = CreateObject("Scripting.Dictionary")
  If IsObject(ValueList) Then
    ValueList.CompareMode = vbTextCompare
  Else
     End
  End If
End Sub
 Private Sub Class_Terminate()
  CloseCurrentKey
  Set ValueList = Nothing
End Sub
 Private Sub CloseCurrentKey()
  If hCurKey Then
     Call RegCloseKey(hCurKey)
    hCurKey = 0
  End If
End Sub
 Private Sub GetKeyHandle(lKey, strKey)
  CloseCurrentKey
  If lKey = 0 Then lKey = HKEY_CURRENT_USER
  Dim SA As SECURITY_ATTRIBUTES
  Call RegCreateKeyEx(lKey, strKey, 0, vbNull, 0, _
    lRequiredAccess, SA, hCurKey, 0)
   If hCurKey Then
     Call RegQueryInfoKey(hCurKey, vbNullString, 0, 0, _
      nSubKeys, lMaxSubKeyLen, 0, nValues, _
      lMaxValueNameLen, lMaxValueLen, 0, 0)
    ValueList.removeAll
    lPreviousAccess = lRequiredAccess
   End If
End Sub
 Private Function TrimNull(ByVal strIn) As String
  TrimNull = Left$(strIn, InStr(strIn, vbNullChar) - 1)
End Function
  Private Function TrimDoubleNull(ByVal strIn) As String
  If Len(strIn) Then _
    TrimDoubleNull = _
      Left$(strIn, InStr(strIn, String$(2, 0)) - 1)
End Function
  Private Function ExpandString(strIn) As String
  Dim nChars, strBuff, nBuffSize
  nBuffSize = 1024
  strBuff = String$(nBuffSize, 0)
  nChars = ExpandEnvStrings(strIn, strBuff, nBuffSize)
  If nChars Then ExpandString = Left$(strBuff, nChars - 1)
End Function
 Private Function ShlwapiInstalled() As Boolean
  Dim hLib As Long
  hLib = LoadLibrary("Shlwapi")
  If hLib Then
    ShlwapiInstalled = True
    FreeLibrary hLib
  End If
End Function
 Private Function ContainsEnvString(ByVal strTest) _
   As Boolean
   Const PCT As String = "%"
  ' See if there is a percent sign.
  Dim n As Long:
n = InStr(strTest, PCT)
  If n = 0 Then Exit Function
  ' See if there is a second percent sign.
  If n = InStrRevEx(strTest, PCT) Then Exit Function
  ' Now we have a potential environment string.
  Dim Env As String, EnvSplit() As String
  Dim i As Long
  For i = 1 To 100
    Env = Environ(i)
     If Len(Env) Then
        SplitEx EnvSplit, Env, "="
       If InStr(1, strTest, PCT & EnvSplit(0) & PCT, _
               vbTextCompare) Then
        ContainsEnvString = True
         Exit For
       End If
     Else
       Exit For
     End If
  Next
End Function
 Private Sub ShowErrMsg(strMsg)
  If (lOptions And ShowErrorMessages) Then
    MsgBox strMsg, vbExclamation, "Registry Error"
  Else
     Debug.Print strMsg
  End If
End Sub
  Private Function IsWinNT()
  ' Returns True if the OS is Windows NT/2000.
  Const VER_PLATFORM_WIN32_NT As Long = 2
  Dim osvi As OSVERSIONINFO
  osvi.dwOSVersionInfoSize = Len(osvi)
  GetVersionEx osvi
  IsWinNT = (osvi.dwPlatformId = VER_PLATFORM_WIN32_NT)
End Function
  Private Sub FillDataList(Optional Key As String)
  If Len(Key) Then strKeyName = Key
  If Len(strKeyName) = 0 Then _
    ShowErrMsg ERROR_NO_KEY: Exit Sub
  If bIsWinNT Then lRequiredAccess = KEY_READ
  If PropertiesOK Then
     If nValues = 0 Then Exit Sub
    ValueList.removeAll
     Dim i, lValuename, lType, lBuffer, strValue, strBuffer
     For i = 0 To nValues - 1
      lValuename = lMaxValueNameLen + 1
      strValue = String$(lValuename, 0)
      lBuffer = lMaxValueLen + 1
      strBuffer = String$(lBuffer, 0)
       If RegEnumValue(hCurKey, i, strValue, lValuename, _
         0, lType, ByVal strBuffer, lBuffer) = _
         ERROR_SUCCESS Then
        strValue = TrimNull(strValue)
         Select Case lType
           Case REG_SZ
            ValueList(strValue) = TrimNull(strBuffer)
           Case REG_EXPAND_SZ
             If (lOptions And ExpandEnvironmentStrings) Then
              ValueList(strValue) = _
                ExpandString(TrimNull(strBuffer))
             Else
              ValueList(strValue) = TrimNull(strBuffer)
             End If
           Case REG_MULTI_SZ
'             If (lOptions And _
'                ReturnMultiStringsAsArrays) Then
'              ValueList(strValue) = Split(TrimDoubleNull(strBuffer), vbNullChar)
'             Else
'              ValueList(strValue) = _
'                TrimDoubleNull(strBuffer)
'             End If
           Case REG_DWORD, REG_DWORD_LITTLE_ENDIAN
             Dim nBuffer As Byte
             If RegEnumValue(hCurKey, i, strValue, _
               Len(strValue) + 1, 0, REG_DWORD, nBuffer, _
               4) = ERROR_SUCCESS Then
              ValueList(strValue) = nBuffer
             End If
           Case Else
            ValueList(strValue) = RETURN_UNSUPPORTED
         End Select
       End If
     Next
  End If

End Sub

Private Function JoinEx(SourceArray As Variant, Delimiter As String) As String

    If StrComp(TypeName(SourceArray), "string()", vbTextCompare) <> 0 Then
    
        JoinEx = ""
        Exit Function
    
    End If

    Dim strResult As String
    Dim i As Integer
    
    strResult = ""
    
    For i = LBound(SourceArray) To UBound(SourceArray)
    
        strResult = strResult & SourceArray(i) & Delimiter
    
    Next

    ' remove the last attached Delimiter
    JoinEx = Left(strResult, Len(strResult) - Len(Delimiter))

End Function


Private Function InStrRevEx(strString As String, strSearch As String) As Long

    Dim intIndex As Integer
    Dim strCurrentCharacter As String

    For intIndex = Len(strString) To 1 Step -1
    
        strCurrentCharacter = Mid(strString, intIndex, 1)
        
        If StrComp(strCurrentCharacter, strSearch, vbTextCompare) = 0 Then
        
            InStrRevEx = intIndex
            Exit Function
        
        End If
    Next

    InStrRevEx = 0

End Function

Private Sub SplitEx(ByRef arrayString() As String, strString As String, Optional Delimiter As String = " ")

    Dim strDelimiter As String
    Dim arr() As String
    ReDim arr(0) As String

    If Delimiter = "" Then
    
        arr(0) = ""
        Exit Sub
    
    End If

    If strString = "" Then
    
        arr(0) = ""
        Exit Sub
    
    End If

    Dim strTemp As String
    Dim i As Integer
    strTemp = strString
    
    While True
    
        i = InStr(1, strTemp, Delimiter, vbTextCompare)
        If i <> 0 Then
            
            arr(UBound(arr)) = Left(strTemp, i - 1)
            ReDim Preserve arr(UBound(arr) + 1)
                    
            strTemp = Mid(strTemp, i + 1)
        
        Else
            arr(UBound(arr)) = strTemp
            GoTo EndLoop
        End If
    
    Wend

EndLoop:

    If arr(UBound(arr)) = "" Then
        ReDim Preserve arr(UBound(arr) - 1)
    End If

    arrayString = arr()

End Sub







Attribute VB_Name = "clsViewHandler"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

'excel
Private WithEvents mobjApplication As Excel.Application
Attribute mobjApplication.VB_VarHelpID = -1

'Plain
Private mobjPlain As AXLCLib.Application
Private mobjSession As AXLCLib.session
'ado
Private mobjConnection As ADODB.Connection
'lokal
Private mstrDimension As String
Private mstrMember As String
Private mstrMeasureDim As String
Private mstrMem1 As String
Private mstrMem2 As String
Private mlngAxisType As Long
'properties
Private mblIsView As Boolean
Private menmContext As Long
Private mobjView As MSXML2.DOMDocument60
Private mvarsServer As String
Private mvarsCatalog As String
Private mvarsSession As String
Private mvarsCube As String
Private mvarsRow As String
Private mvarsCol As String
Private mvarsFilters As Variant
Private mobjActions As Actions

'******************Properties****************************
Public Property Set PlainView(ByRef oView As MSXML2.DOMDocument60)
    If Not oView Is Nothing Then Set mobjView = oView
End Property
Public Property Get PlainView() As MSXML2.DOMDocument60
    Set PlainView = mobjView
End Property
Public Property Set Connection(ByRef cnADO As ADODB.Connection)
    If Not cnADO Is Nothing Then Set mobjConnection = cnADO
End Property
Public Property Get Connection() As ADODB.Connection
    Set Connection = mobjConnection
End Property
Public Property Set Actions(ByRef oActions As Actions)
    If Not oActions Is Nothing Then Set mobjActions = oActions
End Property
Public Property Get Actions() As Actions
    Set Actions = mobjActions
End Property
Public Property Let IsView(ByVal vData As Boolean)
    mblIsView = vData
End Property
Public Property Get IsView() As Boolean
    IsView = mblIsView
End Property
Public Property Let Context(ByVal vData As Long)
    menmContext = vData
End Property
Public Property Get Context() As Long
    Context = menmContext
End Property
Public Property Get MeasureDim() As String
    MeasureDim = mstrMeasureDim
End Property

Public Property Let session(ByVal vData As String)
    mvarsSession = vData
End Property
Public Property Get session() As String
    session = mvarsSession
End Property
Public Property Let Server(ByVal vData As String)
    mvarsServer = vData
End Property
Public Property Get Server() As String
    Server = mvarsServer
End Property
Public Property Let Cube(ByVal vData As String)
    mvarsCube = vData
End Property
Public Property Get Cube() As String
    mvarsCube = CheckCubeName(mvarsCube)
    Cube = mvarsCube
End Property
Public Property Let RowSet(ByVal vData As String)
    mvarsRow = vData
End Property
Public Property Get RowSet() As String
    RowSet = mvarsRow
End Property
Public Property Let ColumnSet(ByVal vData As String)
    mvarsCol = vData
End Property
Public Property Get ColumnSet() As String
    ColumnSet = mvarsCol
End Property
Public Property Let Filters(ByRef vData As Variant)
    mvarsFilters = vData
End Property
Public Property Get Filters() As Variant
    Filters = mvarsFilters
End Property

'***********************worksheet-handler*********************

Private Sub mobjApplication_SheetBeforeRightClick(ByVal Sh As Object, ByVal Target As Range, Cancel As Boolean)

On Error GoTo errHandler:

    Dim wb As Workbook
    Dim ws As Worksheet
    
    Set ws = Sh
    Set wb = ws.Parent
    If wb.Name = "Object" Or _
        InStr(wb.Name, "Workbook in") > 0 Or _
        InStr(wb.Name, "Worksheet in") > 0 Or _
        InStr(wb.Name, "Chart in") > 0 Or _
        wb.IsInplace Then Exit Sub
    
    InitLanguage
    ClearPopupDrillthrough
    ClearPopupActionsCategory

    Dim reportType As ActiveReportType
    reportType = mobjPlain.GetActiveReportType
    
    If reportType = axlcNoReport Then
        'do nothing here
    ElseIf reportType = axlcViewReport Then
        'do nothing here
    ElseIf reportType = axlcAdHocReport Then
        If SheetIsView And (Not GetViewContext = axlcInvalidAxis) And ProviderIsValid Then
            Select Case Me.Context
            Case axlcCellset
                PopulatePopupActionsCategory
                PopulatePopupDrillThrough
            Case axlcColumnAxis, axlcRowAxis, axlcFilterAxis
                PopulatePopupActionsCategory
            End Select
        End If
    Else
        If (Not GetXLSheetContext = axlcInvalidAxis) And ProviderIsValidFormula Then
            Select Case Me.Context
                Case axlcCellset
                    PopulatePopupDrillThrough
                    PopulatePopupActionsCategory
                Case axlcColumnAxis, axlcRowAxis
                    PopulatePopupActionsCategory
            End Select
        End If
    End If
    
    Exit Sub
    
errHandler:
    If Not mobjConnection Is Nothing Then
        If mobjConnection.State = 1 Then mobjConnection.Close
    End If

errResume:
    
End Sub



'*****************helpers********************************

'###############################################################
'Method: SheetIsView
'
'In:    Nothing
'Out:   Nothing
'
'Author: Thomas Seidel
'
'Last Change: 2002-25-10
'
'Description:
'Checks current sheet for plain-view
'###############################################################
Private Function SheetIsView() As Boolean
Dim objDocument As MSXML2.DOMDocument60

    On Error Resume Next
  
    Set objDocument = mobjPlain.GetCurrentDOM
  
    On Error GoTo errHandler

    If objDocument Is Nothing Then
        mblIsView = False
    Else
        Set mobjView = objDocument
        mblIsView = True
        SheetIsView = True
    End If
    Exit Function
    
errHandler:

End Function

'###############################################################
'Method: GetViewContext
'
'In:    Nothing
'Out:   Nothing
'
'Author: Thomas Seidel
'
'Last Change: 2002-25-10
'
'Description:
'Checks current sheet for plain-view
'###############################################################
Private Function GetViewContext() As Long
Dim nAxisID As Long

Dim asMember() As String
Dim strMember As String
Dim intColOffset As Integer
Dim intRowOffset As Integer
Dim asRow() As String
Dim asCol() As String
Dim asCell() As String
Dim asFilter() As String

    GetViewContext = axlcInvalidAxis
    menmContext = axlcInvalidAxis

    If Me.PlainView Is Nothing Then
        Exit Function
    End If
  
    With mobjPlain
        nAxisID = .GetCurrentAxisID
        Select Case nAxisID
        Case axlcCellset
            .GetCurrentCellTuple asCell
            If IsEmpty(asCell) Then GetViewContext = axlcInvalidAxis: Exit Function
            .GetCurrentRowsTuple asRow
            .GetCurrentColumnsTuple asCol
            .GetCurrentFilterTuple asFilter
            mstrMem1 = asRow(0)
            mstrMem2 = asCol(0)
            mvarsCol = "(" & Join(asCol, ",") & ")"
            mvarsRow = "(" & Join(asRow, ",") & ")"
            mvarsFilters = asFilter
            If (mvarsCol = "") Or (mvarsRow = "") Then
                GetViewContext = axlcInvalidAxis
            Else
                GetViewContext = axlcCellset
            End If
        Case axlcColumnAxis
            mstrDimension = .GetCurrentAxisField
            .GetCurrentColumnsTuple asMember
            mstrMember = GetMemFromTupel(asMember, mstrDimension)
            GetViewContext = axlcColumnAxis
        Case axlcRowAxis
            mstrDimension = .GetCurrentAxisField
            .GetCurrentRowsTuple asMember
            mstrMember = GetMemFromTupel(asMember, mstrDimension)
            GetViewContext = axlcRowAxis
        Case axlcFilterAxis
            mstrDimension = .GetCurrentAxisField
            .GetCurrentFilterTuple asMember
            mstrMember = GetMemFromTupel(asMember, mstrDimension)
            GetViewContext = axlcFilterAxis
        End Select
        menmContext = GetViewContext
    End With
    
    Exit Function
    
errHandler:

End Function

'###############################################################
'Method: GetViewContext
'
'In:    Nothing
'Out:   Nothing
'
'Author: Thomas Seidel
'
'Last Change: 2002-25-10
'
'Description:
'Checks current sheet for plain-view
'###############################################################
Private Function GetXLSheetContext() As Long
Dim sSrcFormula As String
Dim rngAct As Range
    
    GetXLSheetContext = axlcInvalidAxis
    menmContext = axlcInvalidAxis
    'get active Cell&formula
    Set rngAct = ActiveCell
    sSrcFormula = rngAct.Formula
    
    'Application.ScreenUpdating = False
    Select Case UCase(Left(sSrcFormula, 7))
        Case "=CELL.G"
            If GetKontextFormula(mvarsSession, mvarsCube, mvarsRow, mvarsCol, mvarsFilters) Then
                mstrMember = mvarsCol
                menmContext = axlcCellset
                GetXLSheetContext = axlcCellset
            End If
        Case "=MEMBER"
            If GetKontextFormulaMem(mvarsSession, mvarsCube, mstrDimension, mstrMember) Then
                menmContext = axlcColumnAxis
                GetXLSheetContext = axlcColumnAxis
            End If
'        Case "=MDX.SE"
'                menmContext = axlcColumnAxis
    End Select
    'Application.ScreenUpdating = True
    
    Exit Function
    
errHandler:

End Function

'=============================================================
' clsDrillThroughHandler.GetConnection
'-------------------------------------------------------------
' Purpose: get's the current view and extracts connection-information
'           to open an analog ado-connection for drillthrough
' Author : Thomas Seidel, Freitag, 31. Mai 2002
' Notes :
'-------------------------------------------------------------
' Parameters
'-----------
'
'-------------------------------------------------------------
' Returns:
'-------------------------------------------------------------
' Freitag, 31. Mai 2002 TSL:
'=============================================================
Public Function GetConnFromView() As Boolean
Dim objDocument As MSXML2.DOMDocument60
Dim objNode As MSXML2.IXMLDOMNode
Dim lngCount As Long
'Dim errPlain As AXLC_Errors

  On Error GoTo errHandler
    
    If mobjView Is Nothing Then GoTo errHandler
    
    'set Document-properties
    mobjView.setProperty "SelectionLanguage", "XPath"
    
    'get cube-node in View/ViewDefinition
    Set objNode = mobjView.selectSingleNode("//View/ViewDefinition/CubeUName")
    If objNode Is Nothing Then GoTo errHandler
    
    'get the cubename and truncate brackets
    mvarsCube = objNode.Text
    mvarsCube = ReplaceTextInString(mvarsCube, "[", "")
    mvarsCube = ReplaceTextInString(mvarsCube, "]", "")
    mvarsCube = "[" + mvarsCube + "]"
    If mvarsCube = "[]" Then GoTo errHandler
    
    'find alias name
    Set objNode = mobjView.selectSingleNode("//View/ViewDefinition/Alias")
    If objNode Is Nothing Then GoTo errHandler
    Dim alias
    alias = objNode.Text
    
    'use comapi to create session for this alias
    
    'check for plain-app
    If g_AppPlain Is Nothing Then
        Set g_AppPlain = New AXLCLib.Application
    End If
    
    
    Set mobjSession = g_AppPlain.Sessions(alias)
    
    'find connection-settings for this view in xml-definition
    'Set objNode = mobjView.selectSingleNode("//View/Parameters/DataSourceName")
    'If objNode Is Nothing Then GoTo errHandler
    'mvarsServer = objNode.Text
    
    mvarsServer = ""
    mvarsCatalog = mobjSession.CurrentDatabase
        
    Dim constr As String
    Dim prov As String
    constr = mobjSession.ConnectionString
    prov = GetProvider(constr)
    If UCase(prov) <> "MSOLAP" Then GoTo errResume
      
    'Set objNode = mobjView.selectSingleNode("//View/Parameters/ProviderName")
    'If objNode Is Nothing Then GoTo errHandler
    'If UCase(Left(objNode.Text, 6)) <> "MSOLAP" Then GoTo errResume
    
    'Set objNode = mobjView.selectSingleNode("//View/Parameters/Catalog")
    'If objNode Is Nothing Then GoTo errHandler
    
    'mvarsCatalog = objNode.Text
    'mvarsSession = mvarsServer & "/" & mvarsCatalog
    'If mvarsSession = "" Then GoTo errHandler
    
    'Set mobjSession = mobjPlain.Sessions(mvarsSession)
    'If mobjSession Is Nothing Then GoTo errHandler
    
    'get new ado-connection with plain-session-data
    Set mobjConnection = New ADODB.Connection
    mobjConnection.ConnectionString = mobjSession.ConnectionString & _
        ";Initial Catalog=" & mobjSession.CurrentDatabase
    mobjConnection.Open
    
    GetConnFromView = True
    
    mstrMeasureDim = GetMeasureDim(mobjConnection, mvarsCube)
    '= mobjConnection.Properties("Data Source Connection Type").Value
    
errResume:
    Exit Function

errHandler:
    
End Function

'=============================================================
' clsViewHandler.GetConnForFormula
'-------------------------------------------------------------
' Purpose: get's a connection for recieved formula settings
'
' Author : Thomas Seidel, Freitag, 25. Oktober 2002
' Notes :
'-------------------------------------------------------------
' Parameters
'-----------
'
'-------------------------------------------------------------
' Returns:
'-------------------------------------------------------------
' Freitag, 25. Oktober 2002 TSL:
'=============================================================
Public Function GetConnForFormula() As Boolean
Dim sConn As String
    Set mobjSession = mobjPlain.Sessions(mvarsSession)
    If mobjSession Is Nothing Then GoTo errHandler
    sConn = mobjSession.ConnectionString
    If UCase(GetProvider(sConn)) <> "MSOLAP" Then GoTo errResume
    
    'get new ado-connection with plain-session-data
    Set mobjConnection = New ADODB.Connection
    mobjConnection.ConnectionString = mobjSession.ConnectionString & _
        ";Initial Catalog=" & mobjSession.CurrentDatabase
    mobjConnection.Open
    
    GetConnForFormula = True
    '= mobjConnection.Properties("Data Source Connection Type").Value
    
errResume:
    Exit Function

errHandler:

End Function

Private Function GetProvider(sConn As String) As String
Dim sHelp$
Dim iStart%

    iStart = InStr(1, UCase(sConn), "PROVIDER=")
    
    sHelp = Right(UCase(sConn), Len(sConn) - iStart - 8)
    GetProvider = Left(sHelp, 6)

End Function

Private Function PopulateActions() As Boolean
Dim objActions As New Actions
Dim i As Integer
Dim sLevel1 As String
Dim sLevel2 As String
Dim blMember As Boolean
Dim sMessage As String
Dim myCube As String

On Error GoTo errHandler

    myCube = mvarsCube
    myCube = ReplaceTextInString(myCube, "[", "")
    myCube = ReplaceTextInString(myCube, "]", "")
    
    If mobjConnection Is Nothing Then Exit Function
    If mobjConnection.State = 0 Then mobjConnection.Open
    Set objActions = New Actions
    
    If Me.Context = axlcCellset Then
        blMember = IsMemberInCube(mobjConnection, myCube, mstrMem1) And IsMemberInCube(mobjConnection, myCube, mstrMem2)
        'get actions for whole cube-object
        objActions.GetActionsSep mobjSession, mobjConnection, myCube, myCube, MDACTION_COORDINATE_CUBE
        If Not blMember Then
            objActions.GetActionsSep mobjSession, mobjConnection, myCube, mstrMember, MDACTION_COORDINATE_CELL
        End If
    Else
        blMember = IsMemberInCube(mobjConnection, myCube, mstrMember)
    End If
    
    If Not blMember Then GoTo errResume
    
    Select Case Me.Context
    
    Case axlcRowAxis, axlcColumnAxis, axlcFilterAxis
        
        'get actions for current dimension-object
        objActions.GetActionsSep mobjSession, mobjConnection, myCube, mstrDimension, MDACTION_COORDINATE_DIMENSION
        
        'get actions for current level-object
        sLevel1 = GetMemberLevel(mobjConnection, myCube, mstrMember)
        objActions.GetActionsSep mobjSession, mobjConnection, myCube, sLevel1, MDACTION_COORDINATE_LEVEL
        
        'get actions for current dimension-members
        objActions.GetActionsSep mobjSession, mobjConnection, myCube, mstrMember, MDACTION_COORDINATE_DIMENSION
        
        'get actions for current level-members
        objActions.GetActionsSep mobjSession, mobjConnection, myCube, mstrMember, MDACTION_COORDINATE_LEVEL
        
        'get actions for Members in current dimension
        objActions.GetActionsSep mobjSession, mobjConnection, myCube, mstrMember, MDACTION_COORDINATE_MEMBER
    Case axlcCellset
        'sLevel1 = GetMemberLevel(mobjConnection, myCube, mstrMem1)
        'sLevel2 = GetMemberLevel(mobjConnection, myCube, mstrMem2)
        
        ' generate the tuple
        Dim sTuple As String
        sTuple = mstrMem1 & ", " & mstrMem2
        
        Dim el
        For Each el In Me.Filters
            sTuple = sTuple & ", " & el
        Next
        
        sTuple = "(" & sTuple & ")"
        
        objActions.GetActionsSep mobjSession, mobjConnection, myCube, sTuple, MDACTION_COORDINATE_CELL
    End Select
    
errResume:
    Set mobjActions = objActions
    On Error Resume Next
    If mobjConnection.State = 1 Then mobjConnection.Close
    On Error GoTo 0

    Exit Function
        
errHandler:

    sMessage = g_ResLangAD.GetResourceText(RES_MSG_PROMPT_GETACT)
    sMessage = Replace(sMessage, "%", mvarsCube)
    sMessage = sMessage + Err.Description
    
    On Error Resume Next
    If mobjConnection.State = 1 Then mobjConnection.Close
    On Error GoTo 0
    
    MsgBox sMessage, vbOKOnly Or vbExclamation, g_ResLangAD.GetResourceText(RES_MSG_TITLE_GETACT)
    Err.Clear
    
End Function

Private Function GetMemFromTupel(asMem As Variant, sDim As String) As String
Dim i As Integer
Dim sMem As String

    If InStr(1, sDim, "].[") Then
        sDim = Left(sDim, InStr(1, sDim, "].["))
    End If

    If Not IsArray(asMem) Then Exit Function
    
    For i = 0 To UBound(asMem)
        sMem = asMem(i)
        If Not InStr(1, sMem, "]") = 0 Then
            sMem = Left(sMem, InStr(1, sMem, "]"))
            If (sMem = sDim) Then
                GetMemFromTupel = asMem(i)
                Exit Function
            End If
        End If
    Next i

End Function

'********************popup-handler******************************

'###############################################################
'Method: ClearPopupActions
'
'In:    Nothing
'Out:   Nothing
'
'Author: Thomas Seidel
'
'Last Change: 2002-25-10
'
'Description:
'Clears the Popup-Menue from "Action"-Entries
'###############################################################
Private Sub ClearPopupActions()
Dim objCommandBar As CommandBar
Dim objAc As CommandBarPopup
Dim ctlAc As CommandBarButton
Dim ctlPop As CommandBarControl

    For Each objCommandBar In Application.CommandBars
        If UCase(objCommandBar.Name) = "CELL" Then
            For Each ctlPop In objCommandBar.Controls
                If ctlPop.Parameter = "Actions" Then
                    Set objAc = ctlPop
                    For Each ctlAc In objAc.Controls
                        ctlAc.Delete
                    Next
                End If
            Next
        End If
    Next
End Sub

Private Sub ClearPopupActionsCategory()
Dim objCommandBar As CommandBar
Dim objAc As CommandBarPopup
Dim ctlAc As CommandBarButton
Dim ctlPop As CommandBarControl

    For Each objCommandBar In Application.CommandBars
        If UCase(objCommandBar.Name) = "CELL" Then
            For Each ctlPop In objCommandBar.Controls
                If ctlPop.Parameter = "Actions" Then
                    Set objAc = ctlPop
                    For Each ctlAc In objAc.Controls
                        ctlAc.Delete
                    Next
                    ctlPop.Delete
                End If
            Next
        End If
    Next
    
End Sub

'###############################################################
'Method: PopulatePopupActions
'
'In:    Nothing
'Out:   Nothing
'
'Author: Thomas Seidel
'
'Last Change: 2002-25-10
'
'Description:
'Build Popup-Menue for "Action"-Entries
'###############################################################
Private Sub PopulatePopupActions()
Dim objCommandBar As CommandBar
Dim objActions As CommandBarPopup
Dim objAction As CommandBarButton
Dim ctlPop As CommandBarControl
Dim lngCount As Long

    If mobjActions Is Nothing Then
        Exit Sub
    End If
    
    For Each objCommandBar In Application.CommandBars
        If UCase(objCommandBar.Name) = "CELL" Then
            For Each ctlPop In objCommandBar.Controls
                If ctlPop.Parameter = "Actions" Then
                    Set objActions = ctlPop
                    Exit For
                End If
            Next
    
            If mobjActions.Count = 0 Then
                Set objAction = objActions.Controls.Add(Type:=msoControlButton, Temporary:=True)
                With objAction
                    .Caption = g_ResLangAD.GetResourceText(RES_MNU_POP_EMPTY)
                    .Enabled = True
                    .Width = 200
                    .Parameter = "Action" & lngCount
                End With
            Else
                For lngCount = 1 To mobjActions.Count
                    Set objAction = objActions.Controls.Add(Type:=msoControlButton, Temporary:=True)
                    With objAction
                        .Caption = mobjActions.Item(lngCount).ActionCaption
                        .Enabled = True
                        .Width = 200
                        .Parameter = "Action" & lngCount
                        .OnAction = "Mis.Plain.ActionsDrillThrough.xla!EvalPopUpActions"
                    End With
                Next lngCount
            End If
        End If
    Next
    
End Sub

Public Sub PopulatePopupActionsNew()
Dim objCommandBar As CommandBar
Dim objActions As CommandBarPopup
Dim objAction As CommandBarButton
Dim lngCount As Long
Dim myCube As String

    myCube = mvarsCube
    myCube = ReplaceTextInString(myCube, "[", "")
    myCube = ReplaceTextInString(myCube, "]", "")

    ClearPopupActions
    If SheetIsView Then
        If Not GetViewContext = axlcInvalidAxis Then
            If Not GetConnFromView Then GoTo errHandler
            If mobjConnection.State = 0 Then mobjConnection.Open
            Set mobjActions = New Actions
            Select Case Me.Context
            Case axlcCellset
                If IsMemberInCube(mobjConnection, myCube, mstrMem1) And IsMemberInCube(mobjConnection, myCube, mstrMem2) Then
                   PopulateActions
                   'PopulatePopupActions
                End If
            Case axlcColumnAxis, axlcRowAxis, axlcFilterAxis
                If IsMemberInCube(mobjConnection, myCube, mstrMember) Then
                   PopulateActions
                End If
            End Select
            PopulatePopupActions
            If mobjConnection.State = 1 Then mobjConnection.Close
        End If
    Else
        If Not mvarsSession = "" Then
            If Not GetConnForFormula Then GoTo errHandler
            Set mobjActions = New Actions
            Select Case Me.Context
                Case axlcCellset
                    'PopulatePopupDrillThrough
                    PopulateActions
                Case axlcColumnAxis, axlcRowAxis
                    PopulateActions
            End Select
            PopulatePopupActions
        End If
    End If
    
    Exit Sub
    
errHandler:
    
End Sub

Private Sub PopulatePopupActionsCategory()
Dim objCommandBar As CommandBar
Dim objActions As CommandBarPopup
Dim objAction As CommandBarButton
Dim lngCount As Long

    ClearPopupActionsCategory
    
    For Each objCommandBar In Application.CommandBars
        If UCase(objCommandBar.Name) = "CELL" Then
    
            Set objActions = objCommandBar.Controls.Add(Type:=msoControlPopup, Temporary:=True)
            If Not objCommandBar.Controls(objCommandBar.Controls.Count).BeginGroup Then
                objActions.BeginGroup = True
            End If
            With objActions
                .Caption = g_ResLangAD.GetResourceText(RES_MNU_POP)
                .Enabled = True
                .Width = 200
                .Parameter = "Actions"
                .OnAction = "Mis.Plain.ActionsDrillThrough.xla!EvalPopUpActionsCategory"
            End With
        End If
    Next
    
End Sub


'###############################################################
'Method: ClearPopupDrillthrough
'
'In:    Nothing
'Out:   Nothing
'
'Author: Thomas Seidel
'
'Last Change: 2002-25-10
'
'Description:
'Clears the Popup-Menue from "Drillthrough"-Entries
'###############################################################
Private Sub ClearPopupDrillthrough()
Dim objCommandBar As CommandBar
Dim ctlPop As CommandBarControl

    For Each objCommandBar In Application.CommandBars
        If UCase(objCommandBar.Name) = "CELL" Then
            For Each ctlPop In objCommandBar.Controls
                If ctlPop.Parameter = "Drillthrough" Then
                    ctlPop.Delete
                End If
            Next
        End If
    Next
    
End Sub

'###############################################################
'Method: PopulatePopupDrillThrough
'
'In:    Nothing
'Out:   Nothing
'
'Author: Thomas Seidel
'
'Last Change: 2002-25-10
'
'Description:
'Build Popup-Menue for "Drillthrough"-Entries
'###############################################################
Private Sub PopulatePopupDrillThrough()
Dim objCommandBar As CommandBar
Dim objDrillBtn As CommandBarButton
Dim lngCount As Long

    ClearPopupDrillthrough
    
    For Each objCommandBar In Application.CommandBars
        If UCase(objCommandBar.Name) = "CELL" Then
            Set objDrillBtn = objCommandBar.Controls.Add(Type:=msoControlButton, Temporary:=True)
            If Not objCommandBar.Controls(objCommandBar.Controls.Count).BeginGroup Then
                objDrillBtn.BeginGroup = True
            End If
            With objDrillBtn
                .Caption = "Drillthrough"
                .Enabled = True
                .Width = 200
                .Parameter = "Drillthrough"
                .OnAction = "Mis.Plain.ActionsDrillThrough.xla!EvalPopUpDrill"
            End With
        End If
    Next
    
End Sub


'***************class-handler***************************

Private Sub Class_Initialize()
    Set mobjApplication = Application
    Set mobjPlain = New AXLCLib.Application
End Sub

Public Function ProviderIsValid() As Boolean
Dim objDocument As MSXML2.DOMDocument60
Dim objNode As MSXML2.IXMLDOMNode
Dim lngCount As Long
'Dim errPlain As AXLC_Errors

  On Error GoTo errHandler
    
    ProviderIsValid = False
    
    If mobjView Is Nothing Then GoTo errHandler
    
    'set Document-properties
    mobjView.setProperty "SelectionLanguage", "XPath"
    
    'get cube-node in View/ViewDefinition
    Set objNode = mobjView.selectSingleNode("//View/ViewDefinition/CubeUName")
    If objNode Is Nothing Then GoTo errHandler
    
    'get the cubename and truncate brackets
    mvarsCube = objNode.Text
    mvarsCube = ReplaceTextInString(mvarsCube, "[", "")
    mvarsCube = ReplaceTextInString(mvarsCube, "]", "")
    mvarsCube = "[" + mvarsCube + "]"
    If mvarsCube = "[]" Then GoTo errHandler
    
    Set objNode = mobjView.selectSingleNode("//View/ViewDefinition/Alias")
    If objNode Is Nothing Then GoTo errHandler
    Dim alias
    alias = objNode.Text
    
    
    Dim s As AXLCLib.session
    
    
    Set s = g_AppPlain.Sessions(alias)
    If s Is Nothing Then GoTo errResume
    
    Dim sConn As String
    sConn = s.ConnectionString
    
    If UCase(GetProvider(sConn)) = "MSOLAP" Then
        ProviderIsValid = True
    Else
        ProviderIsValid = False
    End If
    
    
    'find connection-settings for this view in xml-definition
    'Set objNode = mobjView.selectSingleNode("//View/Parameters/DataSourceName")
    'If objNode Is Nothing Then GoTo errHandler
    'mvarsServer = objNode.Text
    
    'Set objNode = mobjView.selectSingleNode("//View/Parameters/ProviderName")
    'If objNode Is Nothing Then GoTo errHandler
    'If UCase(Left(objNode.Text, 6)) = "MSOLAP" Then
    '    ProviderIsValid = True
    'Else
    '    ProviderIsValid = False
    'End If
    
errResume:
    Exit Function

errHandler:
    
End Function

Public Function ProviderIsValidFormula() As Boolean
Dim sConn As String
    
    Set mobjSession = mobjPlain.Sessions(mvarsSession)
    If mobjSession Is Nothing Then GoTo errHandler
    sConn = mobjSession.ConnectionString
    
    If UCase(GetProvider(sConn)) = "MSOLAP" Then
        ProviderIsValidFormula = True
    Else
        ProviderIsValidFormula = False
    End If
    
errResume:
    Exit Function

errHandler:

End Function


Attribute VB_Name = "frmOptions"
Attribute VB_Base = "0{F225B260-FAAA-48AE-8162-2D2B38BCC3F9}{766C731D-F329-4DA6-AD25-ACB55F764545}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False





Option Explicit

Public blCancel As Boolean
Public lngMaxRows As Long

Private Sub cmdCancel_Click()
    blCancel = True
    Me.Hide
End Sub

Private Sub cmdFinish_Click()
    
  On Error GoTo errHandler
    
    If Not IsNumeric(txtFirstRows.Value) Then
        GoTo errNoValue
    End If
    
    If CLng(txtFirstRows.Value) > 65635 Then
        GoTo errNoValue
    End If
    
    blCancel = False
    If optAllRows Then
        lngMaxRows = -1 'True
    ElseIf CLng(txtFirstRows.Value) > 0 Then
        lngMaxRows = sbRows.Value
    Else
        lngMaxRows = -1
    End If
    Me.Hide
    
errResume:
  Exit Sub
  
errNoValue:
    MsgBox g_ResLangAD.GetResourceText(RES_MSG_PROMPT_INVALIDNUM), vbCritical, g_ResLangAD.GetResourceText(RES_MSG_TITLE_INVALIDNUM)
    GoTo errResume
    
errToMuchRows:
    MsgBox g_ResLangAD.GetResourceText(RES_MSG_PROMPT_TOMUCHROWS), vbCritical, g_ResLangAD.GetResourceText(RES_MSG_TITLE_TOMUCHROWS)
    GoTo errResume
  
errHandler:
    MsgBox Err.Description, vbCritical
    
End Sub

Private Sub sbRows_Change()
    
    txtFirstRows.Text = sbRows.Value
    
End Sub

Private Sub txtFirstRows_AfterUpdate()
    
  On Error GoTo errHandler
  
    If Not IsNumeric(txtFirstRows.Value) Then
        txtFirstRows.Value = 1000
    End If
    
    If CLng(txtFirstRows.Value) > 0 And CLng(txtFirstRows.Value) < 65535 Then
        sbRows.Value = CLng(txtFirstRows.Value)
    End If
    
    Exit Sub
    
errHandler:
    
End Sub

Private Sub UserForm_Initialize()
    LoadRes
    sbRows.Value = 1000
    sbRows.Min = 1
    sbRows.Max = 65535
    cmdFinish.SetFocus
End Sub

Private Sub UserForm_Terminate()
    blCancel = True
End Sub

Private Sub LoadRes()

    
    With g_ResLangAD
        Caption = .GetResourceText(RES_FORM_OPTION)
        cmdCancel.Caption = .GetResourceText(RES_CANCEL)
        cmdFinish.Caption = .GetResourceText(RES_COMPLETE)
        Label3.Caption = .GetResourceText(RES_OPT_MHEAD)
        Label4.Caption = .GetResourceText(RES_OPT_HEAD)
        framRows.Caption = .GetResourceText(RES_OPT_FRMCAP)
        optAllRows.Caption = .GetResourceText(RES_OPT_OPT1)
        optFirstRows.Caption = .GetResourceText(RES_OPT_OPT21)
        Label5.Caption = .GetResourceText(RES_OPT_OPT22)
    End With
End Sub

Attribute VB_Name = "modConst"
Option Explicit

Public Const MDACTION_TYPE_ALL = 0
Public Const MDACTION_TYPE_URL = 1
Public Const MDACTION_TYPE_HTML = 2
Public Const MDACTION_TYPE_STATEMENT = 4
Public Const MDACTION_TYPE_DATASET = 8
Public Const MDACTION_TYPE_ROWSET = 16
Public Const MDACTION_TYPE_COMMANDLINE = 32
Public Const MDACTION_TYPE_PROPRIETARY = 64

Public Const MDACTION_COORDINATE_ALL = 0
Public Const MDACTION_COORDINATE_CUBE = 1
Public Const MDACTION_COORDINATE_DIMENSION = 2
Public Const MDACTION_COORDINATE_LEVEL = 3
Public Const MDACTION_COORDINATE_MEMBER = 4
Public Const MDACTION_COORDINATE_SET = 5
Public Const MDACTION_COORDINATE_CELL = 6

Public Const MDACTION_INVOCATION_ALL = 0
Public Const MDACTION_INVOCATION_INTERACTIVE = 1
Public Const MDACTION_INVOCATION_ON_OPEN = 2
Public Const MDACTION_INVOCATION_BATCH = 4

Public Const C_CONNTYPE_SRV = 1
Public Const C_CONNTYPE_LOCALCUBE = 2
Public Const C_CONNTYPE_HTTPSRV = 4


'--------------------------------------------------------------------------------------------------------
'
'           1 -> 5000
'           captions
'
'--------------------------------------------------------------------------------------------------------
Public Const strFWConfFile = "actionsdrillthrough"

Public Const RES_OK = 1
Public Const RES_CANCEL = 2
Public Const RES_DESCRIPTION = 3
Public Const RES_NEXT = 6
Public Const RES_PREVIOUS = 7
Public Const RES_COMPLETE = 8

Public Const RES_FORM = 100

Public Const RES_FORM_OPTION = 201
Public Const RES_OPT_MHEAD = 202
Public Const RES_OPT_HEAD = 203
Public Const RES_OPT_FRMCAP = 204
Public Const RES_OPT_OPT1 = 205
Public Const RES_OPT_OPT21 = 206
Public Const RES_OPT_OPT22 = 207

Public Const RES_MNU_POP = 2000
Public Const RES_MNU_POP_EMPTY = 2001


'--------------------------------------------------------------------------------------------------------
'
'           5001 -> 10000
'           Messages
'
'--------------------------------------------------------------------------------------------------------

Public Const RES_MSG_PROMPT_LANGUAGEDLLERROR = 5000
Public Const RES_MSG_TITLE_LANGUAGEDLLERROR = 5001
Public Const RES_MSG_PROMPT_INIT = 5002
Public Const RES_MSG_TITLE_INIT = 5003
Public Const RES_MSG_PROMPT_GETVIEWCON = 5004
Public Const RES_MSG_TITLE_GETVIEWCON = 5005
Public Const RES_MSG_PROMPT_GETACT = 5006
Public Const RES_MSG_TITLE_GETACT = 5007
Public Const RES_MSG_PROMPT_EXECACT = 5008
Public Const RES_MSG_TITLE_EXECACT = 5009
Public Const RES_MSG_PROMPT_ERRACT = 5010
Public Const RES_MSG_TITLE_ERRACT = 5011
Public Const RES_MSG_PROMPT_ERRDRL = 5012
Public Const RES_MSG_TITLE_ERRDRL = 5013
Public Const RES_MSG_PROMPT_ERRLOCAL = 5014
Public Const RES_MSG_TITLE_ERRLOCAL = 5015
Public Const RES_MSG_PROMPT_ERRHTTP = 5016
Public Const RES_MSG_TITLE_ERRHTTP = 5017
Public Const RES_MSG_PROMPT_EMPTYRES = 5018
Public Const RES_MSG_TITLE_EMPTYRES = 5019
Public Const RES_MSG_PROMPT_TOMUCHROWS = 5020
Public Const RES_MSG_TITLE_TOMUCHROWS = 5021
Public Const RES_MSG_PROMPT_INVALIDNUM = 5022
Public Const RES_MSG_TITLE_INVALIDNUM = 5023
Public Const RES_MSG_PROMPT_LOADPLAIN = 5024
Public Const RES_MSG_TITLE_LOADPLAIN = 5025

Public Const REG_LANG_PRDATA = "PrimaryDataLanguage"
Public Const REG_PATH = "Software\MIS AG\PLAIN\"
Public Const REG_LANG_UI = "AddinsLanguage"
Public Const REG_LANG_KEY = "\axlc\General"
Public Const REG_COMMANDTIMEOUT_KEY = "DrillthroughCommandTimeout"
Public Const REG_PLAIN_GENERAL = "\axlc\General"

Public Const C_TEMPLATE_DEFAULT = "Standard.XLT"

Public Const StoreNumbersAsStrings = 1
Public Const ReturnMultiStringsAsArrays = 2
Public Const ExpandEnvironmentStrings = 4
Public Const ShowErrorMessages = 8

Public Const C_EXCEL_MENU = "Worksheet Menu Bar"
Public Const C_PLAIN_VBAWKB = "AXLC.XLA"
Public Const C_PLAIN_TOOLS = "112"

Attribute VB_Name = "modFunc"
Option Explicit


#If VBA7 Then
Public Declare PtrSafe Function GetTempFileName Lib "Kernel32" Alias "GetTempFileNameA" (ByVal lpszPath As String, ByVal lpPrefixString As String, ByVal wUnique As Long, ByVal lpTempFileName As String) As Long
Public Declare PtrSafe Function GetTempPath Lib "Kernel32" Alias "GetTempPathA" (ByVal nBufferLength As Long, ByVal lpBuffer As String) As Long

'functions for registry-access
Declare PtrSafe Function RegOpenKeyEx Lib "advapi32.dll" Alias "RegOpenKeyExA" (ByVal hKey As LongPtr, ByVal lpSubKey As String, ByVal ulOptions As Long, ByVal samDesired As Long, phkResult As LongPtr) As Long
Declare PtrSafe Function RegQueryValueEx Lib "advapi32.dll" Alias "RegQueryValueExA" (ByVal hKey As LongPtr, ByVal lpValueName As String, ByVal lpReserved As LongPtr, lpType As Long, lpData As Any, lpcbData As Long) As Long         ' Note that if you declare the lpData parameter as String, you must pass it By Value.

'functions for resource-dll loading
Public Declare PtrSafe Function LoadLibrary Lib "Kernel32" Alias "LoadLibraryA" (ByVal lpLibFileName As String) As LongPtr
'Public Declare Function LoadString Lib "user32" Alias "LoadStringW" (ByVal hInstance As Long, ByVal wID As Long, ByRef lpBuffer As Byte, ByVal nBufferMax As Long) As Long
Public Declare PtrSafe Function LoadString Lib "user32" Alias "LoadStringW" (ByVal hInstance As LongPtr, ByVal wID As Long, ByRef lpBuffer As Byte, ByVal nBufferMax As Long) As Long
Public Declare PtrSafe Function FreeLibrary Lib "Kernel32" (ByVal hLibModule As LongPtr) As Long

#Else
Public Declare Function GetTempFileName Lib "Kernel32" Alias "GetTempFileNameA" (ByVal lpszPath As String, ByVal lpPrefixString As String, ByVal wUnique As Long, ByVal lpTempFileName As String) As Long
Public Declare Function GetTempPath Lib "Kernel32" Alias "GetTempPathA" (ByVal nBufferLength As Long, ByVal lpBuffer As String) As Long

'functions for registry-access
Declare Function RegOpenKeyEx Lib "advapi32.dll" Alias "RegOpenKeyExA" (ByVal hKey As Long, ByVal lpSubKey As String, ByVal ulOptions As Long, ByVal samDesired As Long, phkResult As Long) As Long
Declare Function RegQueryValueEx Lib "advapi32.dll" Alias "RegQueryValueExA" (ByVal hKey As Long, ByVal lpValueName As String, ByVal lpReserved As Long, lpType As Long, lpData As Any, lpcbData As Long) As Long

'functions for ressource-dll loading
Public Declare Function LoadLibrary Lib "Kernel32" Alias "LoadLibraryA" (ByVal lpLibFileName As String) As Long
Public Declare Function LoadString Lib "user32" Alias "LoadStringW" (ByVal hInstance As Long, ByVal wID As Long, ByRef lpBuffer As Byte, ByVal nBufferMax As Long) As Long
Public Declare Function FreeLibrary Lib "Kernel32" ( _
   ByVal hLibModule As Long) As Long
  
#End If




Global Const HKEY_LOCAL_MACHINE = &H80000002
Global Const KEY_READ = &H20019
Global Const ERROR_SUCCESS = 0&
Global Const HKEY_CLASSES_ROOT = &H80000000
Global Const HKEY_CURRENT_USER = &H80000001
Attribute VB_Name = "modHelpADOMD"
Public Function CheckCubeName(sCube As String) As String
Dim sHelp As String

    If Trim(sCube) = "" Then Exit Function
    sHelp = sCube
    If (InStr(1, sHelp, " ") <> 0) And Left(sHelp, 1) <> "[" Then
        sHelp = "[" & sCube & "]"
    End If
    CheckCubeName = sHelp

End Function

Public Function IsMemberInCube(cnOlap As ADODB.Connection, sCube As String, sMember As String) As Boolean
Dim ctCatalog As ADOMD.Catalog
Dim cdCubeDef As ADOMD.CubeDef
Dim mbTest As ADOMD.Member
Dim blOpen As Boolean
    
On Error GoTo errorHandler
    
    If cnOlap.State <> 1 Then
        blOpen = False
        cnOlap.Open
    Else
        blOpen = True
    End If
    
    Set ctCatalog = New Catalog
    Set ctCatalog.ActiveConnection = cnOlap
    Set cdCubeDef = ctCatalog.CubeDefs(sCube)
    
    Set mbTest = cdCubeDef.GetSchemaObject(adObjectTypeMember, sMember)
    If Not mbTest Is Nothing Then
        IsMemberInCube = True
        If Not blOpen Then cnOlap.Close
        Exit Function
    End If
    
errorHandler:
    If Not blOpen Then cnOlap.Close
    IsMemberInCube = False

End Function


Public Function GetMemberLevel(cnOlap As ADODB.Connection, sCube As String, sMember As String) As String
Dim ctCatalog As ADOMD.Catalog
Dim cdCubeDef As ADOMD.CubeDef
Dim mbTest As ADOMD.Member
    
On Error GoTo errorHandler
    
    Set ctCatalog = New Catalog
    Set ctCatalog.ActiveConnection = cnOlap
    Set cdCubeDef = ctCatalog.CubeDefs(sCube)
    
    Set mbTest = cdCubeDef.GetSchemaObject(adObjectTypeMember, sMember)
    If Not mbTest Is Nothing Then
        GetMemberLevel = mbTest.LevelName
        Exit Function
    End If
    
errorHandler:
    GetMemberLevel = ""

End Function

Public Function GetMeasureDim(cnOlap As ADODB.Connection, sCube As String) As String
Dim rsMeas As Recordset
Dim blClosed As Boolean
Dim sFirstMeasure As String
Dim myCube As String
    
On Error GoTo errorHandler
    
    If cnOlap.State <> 1 Then
        cnOlap.Open
        blClosed = True
    End If
    
    myCube = sCube
    myCube = ReplaceTextInString(myCube, "[", "")
    myCube = ReplaceTextInString(myCube, "]", "")
    Set rsMeas = cnOlap.OpenSchema(adSchemaMeasures, Array(cnOlap.DefaultDatabase, Empty, myCube, Empty, Empty))
    sFirstMeasure = rsMeas.Fields("MEASURE_UNIQUE_NAME").Value
    sFirstMeasure = Left(sFirstMeasure, InStr(1, sFirstMeasure, "].["))
    rsMeas.Close
    Set rsMeas = Nothing
    
    If blClosed Then cnOlap.Close
    
    GetMeasureDim = sFirstMeasure
    Exit Function
    
errorHandler:
    GetMeasureDim = ""
    Err.Raise Err.Number, Err.Source, Err.Description, Err.HelpFile, Err.HelpContext

End Function
Attribute VB_Name = "modHelpMISCS"
'**********************************XL97 helper**************************************

'=============================================================
' modHelpers.Join
'-------------------------------------------------------------
' Purpose: Excel 97 do not support Join-Function
'           "Join" merges all members of an array to one string
' Author : Thomas Seidel, Donnerstag, 30. Mai 2002
' Notes :
'-------------------------------------------------------------
' Parameters
'-----------
' asArray (Variant) - array (of strings)
' cDel (String)     - delimiter to seperate members in target-string
'-------------------------------------------------------------
' Returns: - a merged string consisting of all array-members
'-------------------------------------------------------------
' Donnerstag, 30. Mai 2002 TSL:
'=============================================================
Public Function Join(asArray As Variant, cDel As String) As String
Dim sHelp As String
Dim i As Integer

  On Error GoTo errHandler
  
    'check, whether a array is given
    If IsArray(asArray) Then
        sHelp = asArray(0)
        For i = 1 To UBound(asArray)
            sHelp = sHelp & cDel & asArray(i)
        Next i
        'return the result-string
        Join = sHelp
    End If
    Exit Function
    
errHandler:
    Err.Raise 1

End Function

'=============================================================
' modHelpers.ReplaceTextInString
'-------------------------------------------------------------
' Purpose: In Excel 97 a replace function do not exist, that's the workarround
' Author : Thomas Seidel, Donnerstag, 30. Mai 2002
' Notes :
'-------------------------------------------------------------
' Parameters
'-----------
' SourceString (String) -   string where to look
' SearchString (String) -   string to look for
' ReplaceString (String)-   string to be inserted for searchstring
'-------------------------------------------------------------
' Returns: the new string
'-------------------------------------------------------------
' Donnerstag, 30. Mai 2002 TSL:
'=============================================================
Public Function ReplaceTextInString(SourceString As String, SearchString As String, ReplaceString As String) As String

Dim p As Integer, NewString As String

  On Error GoTo errHandler
    
    Do
        p = InStr(p + 1, UCase(SourceString), UCase(SearchString))
        If p > 0 Then ' replace SearchString with ReplaceString
            NewString = ""
            If p > 1 Then NewString = Mid(SourceString, 1, p - 1)
            NewString = NewString + ReplaceString
            NewString = NewString + Mid(SourceString, p + Len(SearchString), Len(SourceString))
            p = p + Len(ReplaceString) - 1
            SourceString = NewString
        End If
        If p >= Len(NewString) Then
            p = 0
            NewString = SourceString
        End If
    Loop Until p = 0
    ReplaceTextInString = NewString
    
    Exit Function

errHandler:
    Err.Raise 1
    
End Function

Public Function FTrim(strValue As String) As String

    Dim strResult As String
    Dim i As Integer
    
    For i = 1 To Len(strValue)
        If Asc(Mid(strValue, i, 1)) <> 0 Then
            strResult = strResult & Mid(strValue, i, 1)
        End If
    Next
    FTrim = strResult

End Function


Attribute VB_Name = "modHelpPlain"
Option Explicit


'*********************************helper for plain**********************************

'=============================================================
' modHelpPLAIN.PlainLoaded
'-------------------------------------------------------------
' Purpose: check whether MIS Plain is loaded
' Author : Thomas Seidel, Donnerstag, 30. Mai 2002
' Notes :
'-------------------------------------------------------------
' Parameters
'-----------
'
'-------------------------------------------------------------
' Returns:
'-------------------------------------------------------------
' Donnerstag, 30. Mai 2002 TSL:
'=============================================================
Function PlainLoaded() As Boolean
Dim vntTest As Variant

    On Error GoTo errHandler:
    
    vntTest = Application.RegisteredFunctions(Index2:="plxMDXExecute")(1, 1)
    PlainLoaded = True
    
    Exit Function
    
errHandler:
    MsgBox g_ResLangAD.GetResourceText(RES_MSG_PROMPT_LOADPLAIN), vbOKOnly Or vbExclamation, g_ResLangAD.GetResourceText(RES_MSG_TITLE_LOADPLAIN)

End Function

'*********************************helper for language**********************************

Public Function GetLanguage() As String
'=============================================================
' modHelpPLAIN.GetLanguage
'-------------------------------------------------------------
' Purpose: get the active Plain-language from windows-registry
' Author : Thomas Seidel, Donnerstag, 30. Mai 2002
' Notes :
'-------------------------------------------------------------
' Parameters
'-----------
'
'-------------------------------------------------------------
' Returns:
'-------------------------------------------------------------
' Donnerstag, 30. Mai 2002 TSL:
'=============================================================
Dim RegKeyHandle As Long
Dim strLanguage As String
Dim sProdVersion As String
Dim sKey As String
Dim vntKeys As Variant
Dim clsRegistry As clsRegistery

  On Error GoTo errHandler
        
        If g_AppPlain Is Nothing Then
            Set g_AppPlain = New AXLCLib.Application
        End If
        
        'sProdVersion = g_AppPlain.ProductVersion
        'sProdVersion = GetProVersKey(sProdVersion)
        'sKey = REG_PATH & sProdVersion & REG_LANG_KEY
        'Set clsRegistry = New clsRegistery
        'clsRegistry.Root = HKEY_CURRENT_USER
        'clsRegistry.Key = sKey
        'vntKeys = clsRegistry.Value(REG_LANG_UI)
        'GetLanguage = GetLangExt(CStr(vntKeys))
        
        GetLanguage = g_AppPlain.Language
        If GetLanguage = "" Then
            GetLanguage = "EN"
        End If
        
    Exit Function
        
errHandler:
    
    GetLanguage = "EN"

End Function

Private Function GetLangExt(sLangkey As String) As String
'=============================================================
' modHelpPLAIN.GetLangExt
'-------------------------------------------------------------
' Purpose: get the language extension from avaliable plain languages
' Author : Thomas Seidel, Donnerstag, 30. Mai 2002
' Notes :
'-------------------------------------------------------------
' Parameters
'-----------
' sLangkey : Applied Plain language
'-------------------------------------------------------------
' Returns:  Language Extension for instance "EN" for english
'-------------------------------------------------------------
' Donnerstag, 30. Mai 2002 TSL:
'=============================================================
    Dim languages(1 To 4) As String
    languages(1) = "en"
    languages(2) = "fr"
    languages(3) = "de"
    languages(4) = "cs"
    
    GetLangExt = ""
    
    Dim v
    For Each v In languages
      If UCase(sLangkey) = UCase(v) Then
        GetLangExt = sLangkey
      End If
    Next v
 End Function


Private Function GetProVersKey(sProdKey As String) As String
'=============================================================
' modHelpPLAIN.GetProVersKey
'-------------------------------------------------------------
' Purpose: get the product version key for registry entries
' Author : Thomas Seidel, Donnerstag, 30. Mai 2002
' Notes :
'-------------------------------------------------------------
' Parameters
'-----------
' sProdKey inputs the ProductKey for Plain given from the api
'-------------------------------------------------------------
' Returns: An updated Product-Version string
'-------------------------------------------------------------
' Donnerstag, 30. Mai 2002 TSL:
'=============================================================
Dim iF1 As Integer
Dim iF2 As Integer
Dim sMajor As String
Dim sMinor As String

    iF1 = InStr(1, sProdKey, ",")
    sMajor = Left(sProdKey, iF1 - 1)
    iF2 = InStr(iF1 + 1, sProdKey, ",")
    sMinor = Mid(sProdKey, iF1 + 1, iF2 - iF1 - 1)
    GetProVersKey = sMajor & "." & sMinor

End Function

'=============================================================
' modHelpPLAIN.GetPlainMenuID
'-------------------------------------------------------------
' Purpose: returns the language-specific Plain-Menu caption
' Author : Thomas Seidel, Freitag, 28. November 2002
' Notes :
'-------------------------------------------------------------
' Parameters
'-----------
'
'-------------------------------------------------------------
' Returns: Caption for the Plain-Menuentry
'-------------------------------------------------------------
' Donnerstag, 28. november 2002 TSL:
'=============================================================
Public Function GetPlainMenuID() As String
GetPlainMenuID = 1
'Dim lngDllHandle As Long
'Dim strBuffer As String * 1024

    'load plain ressource-file
    'lngDllHandle = LoadLibrary(GetPlainBinPath & "AOEM" & GetLanguage & ".dll")
    'If lngDllHandle = 0 Then
        'GoTo errorHandler
    'End If
    ''load ressource for plain-menu caption from language specific dll
    'LoadString lngDllHandle, 5, strBuffer, 1024
    'GetPlainMenuID = FTrim(strBuffer)
        
    Exit Function

errorHandler:

    Err.Raise 1

End Function

'=============================================================
' modHelpPLAIN.GetPlainBinPath
'-------------------------------------------------------------
' Purpose: returns the Pathname for the Plain binaries
' Author : Thomas Seidel, Freitag, 28. November 2002
' Notes :
'-------------------------------------------------------------
' Parameters
'-----------
'
'-------------------------------------------------------------
' Returns: Pathname for Plain binaries
'-------------------------------------------------------------
' Donnerstag, 28. November 2002 TSL:
'=============================================================
Private Function GetPlainBinPath() As String
Dim sPath As String
Dim sFind As String
Dim i As Integer

    'currently i only can go up once and take the bin-path
    'i found no key for plain-pathes
    sPath = ThisWorkbook.Path
    sFind = Right(sPath, 1)
    Do
        sPath = Left(sPath, Len(sPath) - 1)
        sFind = Right(sPath, 1)
    Loop While sFind <> "\"
    GetPlainBinPath = sPath & "bin\"

End Function


'=============================================================
' modHelpPLAIN.GetPlainTemplatesPath
'-------------------------------------------------------------
' Purpose: returns the template-path for the plain-user
' Author : Thomas Seidel, Donnerstag, 30. Mai 2002
' Notes :
'-------------------------------------------------------------
' Parameters
'-----------
'
'-------------------------------------------------------------
' Returns: Pathname where the plain-templates are located
'-------------------------------------------------------------
' Donnerstag, 30. Mai 2002 TSL:
'=============================================================
Public Function GetPlainTemplatesPath() As String

    Dim clsRegistry As clsRegistery
    Dim sProdVersion As String
    
    If g_AppPlain Is Nothing Then
        Set g_AppPlain = New AXLCLib.Application
    End If
    
    sProdVersion = g_AppPlain.ProductVersion
    
    sProdVersion = GetProVersKey(sProdVersion)
    
    Set clsRegistry = New clsRegistery
    
    clsRegistry.Root = HKEY_CURRENT_USER
    clsRegistry.Key = REG_PATH & sProdVersion & REG_PLAIN_GENERAL
    
    GetPlainTemplatesPath = clsRegistry.Value("PathViews")

    ' remove the last "\" character
    If StrComp(Right(GetPlainTemplatesPath, 1), "\", vbTextCompare) = 0 Then
    
        GetPlainTemplatesPath = Left(GetPlainTemplatesPath, Len(GetPlainTemplatesPath) - 1)
    
    End If

End Function
Attribute VB_Name = "modHelpXL"
Option Explicit

Dim msSession As String
Dim msCube As String
Dim msDimension As String
Dim msMember As String
Dim msRow As String
Dim msCol As String
Dim msaFiler As Variant


'******************helpers for Action/DrillThrough-Support on Formulas****************

Public Function IsCellGet() As Boolean
Dim rngActual As Range

    Set rngActual = ActiveCell
    If UCase(Left(rngActual.Formula, 9)) = "=CELL.GET" Then
        'MsgBox "Activiere f|fffd|r DrillThrough", vbOKOnly
        IsCellGet = True
    End If
    
End Function

Public Function IsMemGet() As Boolean
Dim rngActual As Range
Dim iBrack As Integer
Dim sForm As String

    Set rngActual = ActiveCell
    sForm = rngActual.Formula
    
    If UCase(Left(sForm, 8)) = "=MEMBER." Then
        iBrack = InStr(1, sForm, "(")
        If UCase(Right(Left(sForm, iBrack - 1), 4)) = "NAME" Then
            IsMemGet = True
        End If
    End If

End Function

Public Function IsPickGet() As Boolean
Dim rngActual As Range
Dim iBrack As Integer
Dim sForm As String

    Set rngActual = ActiveCell
    sForm = rngActual.Formula
    
    If UCase(Left(sForm, 9)) = "=MDX.SET." Then
        iBrack = InStr(1, sForm, "(")
        If UCase(Right(Left(sForm, iBrack - 1), 4)) = "PICK" Then
            IsPickGet = True
        End If
    End If

End Function

Public Function GetKontextFormulaMem(ByRef sSession As String, ByRef sCube As String _
                , ByRef sDimension As String, ByRef sMember As String) As Boolean

Dim rngAct As Range
Dim iStartF As Integer
Dim sSrcFormula As String
Dim sNewFormula As String
Dim sValue As String
Dim xlCalc As Long

  On Error GoTo errHandler
    'get active Cell&formula
    Set rngAct = ActiveCell
    sSrcFormula = rngAct.Formula
    sValue = rngAct.Value
    If Right(sValue, 1) <> "]" Then
        sValue = "[" & sValue & "]"
    End If
    
    'set new formula
    iStartF = InStr(1, sSrcFormula, "(", vbTextCompare)
    sNewFormula = "=MEMBERNAME__" & Right(sSrcFormula, Len(sSrcFormula) - iStartF + 1)
    
    'xlCalc = Application.Calculation
    'Application.Calculation = xlCalculationManual
    'rngAct.Formula = sNewFormula
    ActiveCell.Application.Evaluate (sNewFormula)
    
    If msCube <> "" And msDimension <> "" Then
        sSession = msSession
        sCube = msCube
        sDimension = msDimension
        If msMember = "" Then
            sMember = sValue
        Else
            sMember = msMember
        End If
        GetKontextFormulaMem = True
    End If
  
    'rngAct.Formula = sSrcFormula
    'Application.Calculation = xlCalc
  
errResume:
    Exit Function
    
errHandler:

End Function

Public Function GetKontextFormulaPick(ByRef sSession As String, ByRef sCube As String _
                , ByRef sDimension As String, ByRef sMember As String) As String

Dim rngAct As Range
Dim iStartF As Integer
Dim sSrcFormula As String
Dim sNewFormula As String
Dim sValue As String

  On Error GoTo errHandler
    'get active Cell&formula
    Set rngAct = ActiveCell
    sSrcFormula = rngAct.Formula
    sValue = rngAct.Value
    If Right(sValue, 1) <> "]" Then
        sValue = "[" & sValue & "]"
    End If
    'set new formula
    iStartF = InStr(1, sSrcFormula, "(", vbTextCompare)
    
    sNewFormula = "=SETPICK__" & Right(sSrcFormula, Len(sSrcFormula) - iStartF + 1)
    'rngAct.Formula = sNewFormula
    ActiveCell.Application.Evaluate (sNewFormula)
    
    If msCube <> "" And msDimension <> "" Then
        sSession = msSession
        sCube = msCube
        sDimension = msDimension
        If msMember = "" Then
            sMember = sValue
        Else
            sMember = msMember
        End If
        GetKontextFormulaPick = "Column"
    Else
        GetKontextFormulaPick = "Error"
    End If
  
    'rngAct.Formula = sSrcFormula
  
errResume:
    Exit Function
    
errHandler:

End Function


Public Function GetKontextFormula(ByRef sSession As String, ByRef sCube As String, _
                        ByRef sRow As String, ByRef sCol As String, ByRef asFilters As Variant) As Boolean
Dim rngAct As Range
Dim iStartF As Integer
Dim sSrcFormula As String
Dim sNewFormula As String
Dim xlCalc As Long

  On Error GoTo errHandler
    'get active Cell&formula
    Set rngAct = ActiveCell
    sSrcFormula = rngAct.Formula
    sNewFormula = sSrcFormula
    'set new formula
    Do
        sNewFormula = ReplaceTextInString(sNewFormula, ",,", ",")
    Loop While InStr(1, sNewFormula, ",,") <> 0
    iStartF = InStr(1, sNewFormula, "(", vbTextCompare)
    sNewFormula = "=CELLGET__" & Right(sNewFormula, Len(sNewFormula) - iStartF + 1)
    
    'xlCalc = Application.Calculation
    'Application.Calculation = xlCalculationManual
    'rngAct.Formula = sNewFormula
    ActiveCell.Application.Evaluate (sNewFormula)
    
    If msCol <> "" Then
        sSession = msSession
        sCube = msCube
        sCol = "(" & msCol & ")"
        If msRow <> "" Then sRow = "(" & msRow & ")"
        asFilters = msaFiler
        GetKontextFormula = True
    End If
    
    'rngAct.Formula = sSrcFormula
    'Application.Calculation = xlCalc
  
errResume:
    Exit Function
    
errHandler:


End Function


Public Function CELLGET__(ServerDatabase As String, Cube As String, Optional Mem1 As String, _
            Optional Mem2 As String, Optional Mem3 As String, Optional Mem4 As String, _
            Optional Mem5 As String, Optional Mem6 As String, Optional Mem7 As String, _
            Optional Mem8 As String, Optional Mem9 As String, Optional Mem10 As String, _
            Optional Mem11 As String, Optional Mem12 As String, Optional Mem13 As String, _
            Optional Mem14 As String, Optional Mem15 As String, Optional Mem16 As String, _
            Optional Mem17 As String, Optional Mem18 As String, Optional Mem19 As String, _
            Optional Mem20 As String, Optional Mem21 As String, Optional Mem22 As String, _
            Optional Mem23 As String, Optional Mem24 As String, Optional Mem25 As String, _
            Optional Mem26 As String, Optional Mem27 As String, Optional Mem28 As String, _
            Optional Mem29 As String, Optional Mem30 As String) As Variant
          
Dim saFilter() As String
Dim iSlic As Integer
          
  On Error GoTo errHandler

    msSession = ServerDatabase
    
    msCube = Cube
    msCube = ReplaceTextInString(msCube, "[", "")
    msCube = ReplaceTextInString(msCube, "]", "")
    msCube = "[" + msCube + "]"

    If Not IsMissing(Mem1) Then
        msCol = Mem1
    Else
        Exit Function
    End If
    If Not IsMissing(Mem2) Then
        msRow = Mem2
    Else
        Exit Function
    End If
    'get slicer-members
    If Not IsMissing(Mem3) And Mem3 <> "" Then
        iSlic = 0
        ReDim saFilter(0 To iSlic)
        saFilter(iSlic) = Mem3
    End If
    If Not IsMissing(Mem4) And Mem4 <> "" Then
        iSlic = iSlic + 1
        ReDim Preserve saFilter(0 To iSlic)
        saFilter(iSlic) = Mem4
    End If
    If Not IsMissing(Mem5) And Mem5 <> "" Then
        iSlic = iSlic + 1
        ReDim Preserve saFilter(0 To iSlic)
        saFilter(iSlic) = Mem5
    End If
    If Not IsMissing(Mem6) And Mem6 <> "" Then
        iSlic = iSlic + 1
        ReDim Preserve saFilter(0 To iSlic)
        saFilter(iSlic) = Mem6
    End If
    If Not IsMissing(Mem7) And Mem7 <> "" Then
        iSlic = iSlic + 1
        ReDim Preserve saFilter(0 To iSlic)
        saFilter(iSlic) = Mem7
    End If
    If Not IsMissing(Mem8) And Mem8 <> "" Then
        iSlic = iSlic + 1
        ReDim Preserve saFilter(0 To iSlic)
        saFilter(iSlic) = Mem8
    End If
    If Not IsMissing(Mem9) And Mem9 <> "" Then
        iSlic = iSlic + 1
        ReDim Preserve saFilter(0 To iSlic)
        saFilter(iSlic) = Mem9
    End If
    If Not IsMissing(Mem10) And Mem10 <> "" Then
        iSlic = iSlic + 1
        ReDim Preserve saFilter(0 To iSlic)
        saFilter(iSlic) = Mem10
    End If
    If Not IsMissing(Mem11) And Mem11 <> "" Then
        iSlic = iSlic + 1
        ReDim Preserve saFilter(0 To iSlic)
        saFilter(iSlic) = Mem11
    End If
    If Not IsMissing(Mem12) And Mem12 <> "" Then
        iSlic = iSlic + 1
        ReDim Preserve saFilter(0 To iSlic)
        saFilter(iSlic) = Mem12
    End If
    If Not IsMissing(Mem13) And Mem13 <> "" Then
        iSlic = iSlic + 1
        ReDim Preserve saFilter(0 To iSlic)
        saFilter(iSlic) = Mem13
    End If
    If Not IsMissing(Mem14) And Mem14 <> "" Then
        iSlic = iSlic + 1
        ReDim Preserve saFilter(0 To iSlic)
        saFilter(iSlic) = Mem14
    End If
    If Not IsMissing(Mem15) And Mem15 <> "" Then
        iSlic = iSlic + 1
        ReDim Preserve saFilter(0 To iSlic)
        saFilter(iSlic) = Mem15
    End If
    If Not IsMissing(Mem16) And Mem16 <> "" Then
        iSlic = iSlic + 1
        ReDim Preserve saFilter(0 To iSlic)
        saFilter(iSlic) = Mem16
    End If
    If Not IsMissing(Mem17) And Mem17 <> "" Then
        iSlic = iSlic + 1
        ReDim Preserve saFilter(0 To iSlic)
        saFilter(iSlic) = Mem17
    End If
    If Not IsMissing(Mem18) And Mem18 <> "" Then
        iSlic = iSlic + 1
        ReDim Preserve saFilter(0 To iSlic)
        saFilter(iSlic) = Mem18
    End If
    If Not IsMissing(Mem19) And Mem19 <> "" Then
        iSlic = iSlic + 1
        ReDim Preserve saFilter(0 To iSlic)
        saFilter(iSlic) = Mem19
    End If
    If Not IsMissing(Mem20) And Mem20 <> "" Then
        iSlic = iSlic + 1
        ReDim Preserve saFilter(0 To iSlic)
        saFilter(iSlic) = Mem20
    End If
        If Not IsMissing(Mem21) And Mem21 <> "" Then
        iSlic = iSlic + 1
        ReDim Preserve saFilter(0 To iSlic)
        saFilter(iSlic) = Mem21
    End If
    If Not IsMissing(Mem22) And Mem22 <> "" Then
        iSlic = iSlic + 1
        ReDim Preserve saFilter(0 To iSlic)
        saFilter(iSlic) = Mem22
    End If
    If Not IsMissing(Mem23) And Mem23 <> "" Then
        iSlic = iSlic + 1
        ReDim Preserve saFilter(0 To iSlic)
        saFilter(iSlic) = Mem23
    End If
    If Not IsMissing(Mem24) And Mem24 <> "" Then
        iSlic = iSlic + 1
        ReDim Preserve saFilter(0 To iSlic)
        saFilter(iSlic) = Mem24
    End If
    If Not IsMissing(Mem25) And Mem25 <> "" Then
        iSlic = iSlic + 1
        ReDim Preserve saFilter(0 To iSlic)
        saFilter(iSlic) = Mem25
    End If
    If Not IsMissing(Mem26) And Mem26 <> "" Then
        iSlic = iSlic + 1
        ReDim Preserve saFilter(0 To iSlic)
        saFilter(iSlic) = Mem26
    End If
    If Not IsMissing(Mem27) And Mem27 <> "" Then
        iSlic = iSlic + 1
        ReDim Preserve saFilter(0 To iSlic)
        saFilter(iSlic) = Mem27
    End If
    If Not IsMissing(Mem28) And Mem28 <> "" Then
        iSlic = iSlic + 1
        ReDim Preserve saFilter(0 To iSlic)
        saFilter(iSlic) = Mem28
    End If
    If Not IsMissing(Mem29) And Mem29 <> "" Then
        iSlic = iSlic + 1
        ReDim Preserve saFilter(0 To iSlic)
        saFilter(iSlic) = Mem29
    End If
    If Not IsMissing(Mem30) And Mem30 <> "" Then
        iSlic = iSlic + 1
        ReDim Preserve saFilter(0 To iSlic)
        saFilter(iSlic) = Mem30
    End If
    If iSlic > 0 Then msaFiler = saFilter
    
errResume:
    Exit Function
            
errHandler:
    MsgBox Err.Description, vbCritical, "error occured..."

End Function

Public Function MEMBERNAME__(ServerDatabase As String, Cube As String, _
                            Dimension As String, Member As Variant) As Variant
          
  On Error GoTo errHandler

    msSession = ServerDatabase
    
    msCube = Cube
    msCube = ReplaceTextInString(msCube, "[", "")
    msCube = ReplaceTextInString(msCube, "]", "")
    msCube = "[" + msCube + "]"
    
    msDimension = Dimension
    If Not IsNumeric(Member) Then
        msMember = Member
    End If
    
errResume:
    Exit Function
            
errHandler:
    MsgBox Err.Description, vbCritical, "error occured..."

End Function

Public Function SETPICK__(ServerDatabase As String, Cube As String, _
                            Query As String, Member As Variant) As Variant
          
  On Error GoTo errHandler

    msSession = ServerDatabase
    
    msCube = Cube
    msCube = ReplaceTextInString(msCube, "[", "")
    msCube = ReplaceTextInString(msCube, "]", "")
    msCube = "[" + msCube + "]"
    
    msDimension = Left(Query, InStr(1, Query, "]"))
    If Not IsNumeric(Member) Then
        msMember = Member
    End If
    
errResume:
    Exit Function
            
errHandler:
    MsgBox Err.Description, vbCritical, "error occured..."

End Function

Attribute VB_Name = "startup"
Public Sub Auto_Open()
    ModGlobal.Initialize
End Sub



' InQuest injected base64 decoded content
' Gjwez

INQUEST-PP=macro
