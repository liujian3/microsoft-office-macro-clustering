Attribute VB_Name = "ADStuff"
Option Explicit

Public G_MyUserGroups As String

Private Sub TestMyUserGroups()
  Debug.Print GetUserGroups(GetUserName)
  
End Sub

Public Function GetUserGroups(winUser As String) As String

    If G_MyUser = GetUserName And G_MyUser <> "" Then
      If G_MyUserGroups <> "" Then
        GetUserGroups = G_MyUserGroups
        Exit Function
      End If
    End If

    Dim conn As New ADODB.Connection
    Dim rs As ADODB.Recordset
    Dim oRoot ' As IADs
    Dim oDomain ' As IADs
    Dim sBase As String
    Dim sFilter As String
    Dim sDomain As String
    
    Dim sAttribs As String
    Dim sDepth As String
    Dim sQuery As String
    Dim sAns As String
    
    On Error GoTo ErrHandler:
    
    GetUserGroups = ""
    If G_cfgNoAD Then Exit Function
    
    'Get user Using LDAP/ADO.  There is an easier way
    'to bind to a user object using the WinNT provider,
    'but this way is a better for educational purposes
    Set oRoot = GetObject(G_cfgADString & "://rootDSE")
    'work in the default domain
    sDomain = oRoot.Get("defaultNamingContext")
    Set oDomain = GetObject(G_cfgADString & "://" & sDomain)
    sBase = "<" & oDomain.ADsPath & ">"
    
    'Only get user name requested
    ' sFilter = "(&(objectCategory=person)(objectClass=user)(name=" _
    '    & LoginName & "))"
    
'    sFilter = "(&(objectCategory=person)(objectClass=user)(sn=Neubert))"
    
    sAttribs = "adsPath"
    sDepth = "subTree"
'    sFilter = "(&(objectCategory=person)(objectClass=user)(sn=Neubert))"
    sFilter = "(&(objectCategory=person)(objectClass=user)(sAMAccountName=" & winUser & "))"
    
    
    sQuery = sBase & ";" & sFilter & ";" & sAttribs & ";" & sDepth
                       
    conn.Open "Data Source=Active Directory Provider;Provider=ADsDSOObject"
      
    Dim i As Long
    Dim user ' As IADsUser
    Set rs = conn.Execute(sQuery)
    Dim s As String
    Do While Not rs.EOF
        Set user = GetObject(rs("adsPath"))
        ' If Not IsErrorLastName(user) Then
            Dim objmemberOf
            Dim objGroup
            objmemberOf = user.GetEx("memberOf")
            For Each objGroup In objmemberOf
              Dim p1 As Long
              Dim p2 As Long
              p1 = InStr(objGroup, "CN=")
              p2 = InStr(objGroup, ",")
              If p1 > 0 And p2 > 0 Then
                If s <> "" Then
                  s = s & ","
                End If
                s = s & "'" & Mid(objGroup, p1 + 3, p2 - p1 - 3) & "'"
              End If
            Next
        ' End If
        rs.MoveNext
    Loop
    G_MyUserGroups = s
    GetUserGroups = s
ErrHandler:
    
    On Error Resume Next
    If Not rs Is Nothing Then
        If rs.state <> 0 Then rs.Close
        Set rs = Nothing
    End If
    
    If Not conn Is Nothing Then
        If conn.state <> 0 Then conn.Close
        Set conn = Nothing
    End If
    
    Set oRoot = Nothing
    Set oDomain = Nothing
End Function

Public Function GetDisplayName(winUser As String) As String

    Dim conn As New ADODB.Connection
    Dim rs As ADODB.Recordset
    Dim oRoot ' As IADs
    Dim oDomain ' As IADs
    Dim sBase As String
    Dim sFilter As String
    Dim sDomain As String
    
    Dim sAttribs As String
    Dim sDepth As String
    Dim sQuery As String
    Dim sAns As String
    
    GetDisplayName = ""
    
    On Error GoTo ErrHandler:
    
    If G_cfgNoAD Then Exit Function
    
    'Get user Using LDAP/ADO.  There is an easier way
    'to bind to a user object using the WinNT provider,
    'but this way is a better for educational purposes
    Set oRoot = GetObject(G_cfgADString & "://rootDSE")
    'work in the default domain
    sDomain = oRoot.Get("defaultNamingContext")
    Set oDomain = GetObject(G_cfgADString & "://" & sDomain)
    sBase = "<" & oDomain.ADsPath & ">"
    
    'Only get user name requested
    ' sFilter = "(&(objectCategory=person)(objectClass=user)(name=" _
    '    & LoginName & "))"
    
'    sFilter = "(&(objectCategory=person)(objectClass=user)(sn=Neubert))"
    
    sAttribs = "adsPath"
    sDepth = "subTree"
'    sFilter = "(&(objectCategory=person)(objectClass=user)(sn=Neubert))"
    sFilter = "(&(objectCategory=person)(objectClass=user)(sAMAccountName=" & winUser & "))"
    
    
    sQuery = sBase & ";" & sFilter & ";" & sAttribs & ";" & sDepth
                       
    conn.Open "Data Source=Active Directory Provider;Provider=ADsDSOObject"
      
    Dim i As Long
    Dim user ' As IADsUser
    Set rs = conn.Execute(sQuery)
    Dim s As String
    Do While Not rs.EOF
        Set user = GetObject(rs("adsPath"))
        ' If Not IsErrorLastName(user) Then
            GetDisplayName = user.DisplayName ' .GetEx("displayName")
        ' End If
        rs.MoveNext
    Loop
    
ErrHandler:
    
    On Error Resume Next
    If Not rs Is Nothing Then
        If rs.state <> 0 Then rs.Close
        Set rs = Nothing
    End If
    
    If Not conn Is Nothing Then
        If conn.state <> 0 Then conn.Close
        Set conn = Nothing
    End If
    
    Set oRoot = Nothing
    Set oDomain = Nothing
End Function

Function IsErrorLastNameOLD(v As Variant) As Boolean

  On Error GoTo nogo
  Dim s As String
  s = CStr(v.lastname)
  IsErrorLastNameOLD = False
  Exit Function
  
nogo:
  IsErrorLastNameOLD = True

End Function


Public Function ADGetUserInfo(LoginName As String, ByRef lastname As String, ByRef firstname As String, ByRef mailaddress As String) As Boolean
'PURPOSE: Display information that is available in
'the Active Directory about a given user

'PARAMETER: Login Name for user

'RETURNS: String with selected information about
'user, or empty string if there is no such
'login on the current domain

'REQUIRES: Windows 2000 ADSI, LDAP Provider
'Proper Security Credentials.

'EXAMPLE: msgbox ADGetUserMailAddress("Administrator")

Dim conn As Object
Dim rs As Object
Dim oRoot As Object
Dim oDomain As Object
Dim sBase As String
Dim sFilter As String
Dim sDomain As String

Dim sAttribs As String
Dim sDepth As String
Dim sQuery As String
Dim sAns As String

Dim user As Object

If G_cfgNoAD Then Exit Function

Set conn = CreateObject("ADODB.Connection")
On Error GoTo ErrHandler:

'Get user Using LDAP/ADO.  There is an easier way
'to bind to a user object using the WinNT provider,
'but this way is a better for educational purposes
Set oRoot = GetObject(G_cfgADString & "://rootDSE")
'work in the default domain
sDomain = oRoot.Get("defaultNamingContext")
Set oDomain = GetObject(G_cfgADString & "://" & sDomain)
sBase = "<" & oDomain.ADsPath & ">"
'Only get user name requested
sFilter = "(&(objectCategory=person)(objectClass=user)(SAMAccountName=" _
  & LoginName & "))"
sAttribs = "adsPath"
sDepth = "subTree"

sQuery = sBase & ";" & sFilter & ";" & sAttribs & ";" & sDepth
                   
conn.Open _
  "Data Source=Active Directory Provider;Provider=ADsDSOObject"
  
Set rs = conn.Execute(sQuery)

If Not rs.EOF Then
    Set user = GetObject(rs("adsPath"))
    With user
    
    'if the attribute is not stored in AD,
    'an error will occur.  Therefore, this
    'will return data only from populated attributes
    On Error Resume Next
    
      firstname = .firstname
      lastname = .lastname
'    sAns = sAns & "Employee ID: " & .EmployeeID & vbCrLf
'    sAns = sAns & "Title: " & .Title & vbCrLf
'    sAns = sAns & "Division: " & .Division & vbCrLf
'    sAns = sAns & "Department: " & .Department & vbCrLf
'    sAns = sAns & "Manager: " & .Manager & vbCrLf
'    sAns = sAns & "Phone Number: " & .TelephoneNumber & vbCrLf
'    sAns = sAns & "Fax Number: " & .FaxNumber & vbCrLf
'    sAns = sAns & "Email Address: " & .EmailAddress & vbCrLf
'    sAns = sAns & "Web Page: " & .HomePage & vbCrLf
'    sAns = sAns & "Last Login: " & .LastLogin & vbCrLf
'    sAns = sAns & "Last Logoff: " & .LastLogoff & vbCrLf
'    sAns = sAns & "Account Expiration Date: " & .AccountExpirationDate & vbCrLf
    
    'IN RC2, this returned 1/1/1970 when password
    'never expires option is set
'    sAns = sAns & "Password Expiration Date: " & .PasswordExpirationDate
      mailaddress = .EmailAddress
    End With
End If
  ADGetUserInfo = True
ErrHandler:

On Error Resume Next
If Not rs Is Nothing Then
    If rs.state <> 0 Then rs.Close
    Set rs = Nothing
End If

If Not conn Is Nothing Then
    If conn.state <> 0 Then conn.Close
    Set conn = Nothing
End If

Set oRoot = Nothing
Set oDomain = Nothing
End Function



Public Function ADUserAuthorized(ByVal LoginName As String, ByVal pwd As String) As Boolean

'PURPOSE: Check for second user

'PARAMETER: Login Name for user

'RETURNS: String with selected information about
'user, or empty string if there is no such
'login on the current domain

'REQUIRES: Windows 2000 ADSI, LDAP Provider
'Proper Security Credentials.

'EXAMPLE: msgbox ADGetUserMailAddress("Administrator")
  
  ADUserAuthorized = False
  If G_cfgNoAD Then Exit Function
  
  If LoginName = "" Or pwd = "" Then
    ADUserAuthorized = False
  End If

    Dim objRootDSE, dso, ou
    Dim strDNSDomain As String
    strDNSDomain = ""
    If strDNSDomain = "" Then
        Set objRootDSE = GetObject(G_cfgADString & "://RootDSE")
        strDNSDomain = objRootDSE.Get("defaultNamingContext")
        ' Set objRootDSE = Nothing
    End If
    
    Set dso = GetObject(G_cfgADString & ":")
    On Error Resume Next
    err.Clear
    Set ou = dso.OpenDSObject(G_cfgADString & "://" & strDNSDomain, LoginName, pwd, 1)
    ADUserAuthorized = (err.Number = 0)
    Set ou = Nothing
End Function

Attribute VB_Name = "AddinStuff"
Option Explicit


Sub LogSpeichern(ByRef rs As Object, ByRef wbInExcelCurrentProjectInAccess As Object, ByRef conn As Object)
  On Error GoTo nogo:
  If Not rs Is Nothing Then
    If GetSafeFieldPlus(rs, "Log", 0) <> 0 Then
      LogFile wbInExcelCurrentProjectInAccess, rs.Fields("idvDateiID").value, conn
    End If
  End If
  Exit Sub
nogo:

  DebugPrint DebType.tERROR, "LogSpeichern:" & err.Number & " - " & err.Description & " - " & err.Source

End Sub

Sub DoInternalSave(ByRef rs As Object, ByRef wbInExcelCurrentProjectInAccess As Object, ByRef conn As Object)

On Error GoTo nogo
    Dim logtrack As Long
    logtrack = 0
    Set G_DocInfo = Nothing
    SaveDocInfoStuff wbInExcelCurrentProjectInAccess
    logtrack = 1

    Dim sharefname As String
    sharefname = wbInExcelCurrentProjectInAccess.fullname

    Dim uncpathfname As String
    uncpathfname = GetUNCPath(wbInExcelCurrentProjectInAccess.fullname)
    logtrack = 2

#If PROJECT_ACCESSTRACKER = 0 Then
    bInternalSave = True
    logtrack = 3
'    wbInExcelCurrentProjectInAccess.Save
    Dim olddispalerts As Boolean
    olddispalerts = wbInExcelCurrentProjectInAccess.Application.DisplayAlerts
    wbInExcelCurrentProjectInAccess.Application.DisplayAlerts = False
    If G_cfgDatenschutzhinweisAus Then
      DatenschutzhinweisAus wbInExcelCurrentProjectInAccess
    End If
    
    If rs Is Nothing Then
      wbInExcelCurrentProjectInAccess.SaveAs wbInExcelCurrentProjectInAccess.fullname, Local:=True
    Else
      If rs.Fields("Dateiberechtigungen").value <> 0 Then
        wbInExcelCurrentProjectInAccess.SaveAs wbInExcelCurrentProjectInAccess.fullname, Local:=True, Password:=GetFileOpenPassword(conn, rs)
      Else
        wbInExcelCurrentProjectInAccess.SaveAs wbInExcelCurrentProjectInAccess.fullname, Local:=True
      End If
    End If
    
    wbInExcelCurrentProjectInAccess.Application.DisplayAlerts = olddispalerts
    logtrack = 4
    bInternalSave = False
#End If

    logtrack = 5
    If rs Is Nothing Then
      Set G_DocInfo = Nothing
      Exit Sub
    End If
    
    
    rs.Fields("SpeichernderUserLogonID").value = GetUserNameUCASE
        
    If IsNull(rs.Fields("VerantwortlicheOEID").value) Then
      rs.Fields("VerantwortlicheOEID").value = GetCurrentUserOEID(conn)
    ElseIf rs.Fields("VerantwortlicheOEID").value = 0 Then
      rs.Fields("VerantwortlicheOEID").value = GetCurrentUserOEID(conn)
    End If
    
    rs.Fields("Speicheranzahl").value = GetValueFromField(rs, "Speicheranzahl", 0) + 1
    
    If Mid(uncpathfname, 2, 1) = ":" Then
        logtrack = 6
        rs.Fields("Rechnerkennung").value = GetComputerName
'        rs.Fields("ServerpathLeft").Value = UCase(Left(uncpathfname, 255))
'        rs.Fields("ServerpathRight").Value = UCase(Right(uncpathfname, 16))
'    Else
'        logtrack = 61
'        Dim s As String
'        Dim servername As String
'        s = GetLocalPath(GetUNCPath(wbInExcelCurrentProjectInAccess.FullName), servername)
'        rs.Fields("Rechnerkennung").Value = Left(servername, 32)
'        rs.Fields("ServerpathLeft").Value = UCase(Left(s, 255))
'        rs.Fields("ServerpathRight").Value = UCase(Right(s, 16))
    End If
    logtrack = 7

    logtrack = 71

    rs.Fields("Dateigroesse").value = MyFileLen(sharefname)
    logtrack = 8
    rs.Fields("Speicherdatum").value = MyFileDateTime(sharefname)
    logtrack = 9
    rs.Fields("Dateidatum").value = MyFileDateTime(sharefname)
    logtrack = 10
    rs.Fields("Tabellenanzahl").value = G_DocInfo.m_Sheets
    logtrack = 11
    
#If PROJECT_ACCESSTRACKER = 0 Then
'    If Not G_DocInfo.m_NoFormulaCount Then
'      If G_DocInfo.m_HadProtectedSheets = True And G_PARAM_PasswortanalyseInSec <> -1 Then
'        CountProtectedFormulas wbInExcelCurrentProjectInAccess.Application, wbInExcelCurrentProjectInAccess.FullName
'        logtrack = 12
'      End If
'      rs.Fields("Formelanzahl").value = G_DocInfo.m_Formulas
'    End If
    logtrack = 13
    rs.Fields("TblaetterOhnBlattschutzMitFrml").value = G_DocInfo.m_UnprotectedWorksheetsWithFormulas
    logtrack = 14
    rs.Fields("TblaetterMitBlattschutz").value = G_DocInfo.m_Protectedsheets
    logtrack = 15
    If Not G_DocInfo.m_NoFormulaCount Then
      rs.Fields("AnzahlNichtAbgesicherteFormeln").value = G_DocInfo.m_Unprotectedformulas
      logtrack = 16
    End If
#End If
    
    
    rs.Fields("AnzahlMakros").value = G_DocInfo.m_Macros
    logtrack = 17
    rs.Fields("Anzahlexternereferenzen").value = G_DocInfo.m_ExtRefs
    logtrack = 18

    Set G_DocInfo = Nothing

    Exit Sub
nogo:

    DebugPrint DebType.tERROR, "DoInternalSave:" & logtrack & err.Number & " - " & err.Description & " - " & err.Source
    Set G_DocInfo = Nothing

End Sub



Attribute VB_Name = "Ampel"
Option Explicit

Public G_AmpelStatus As Long

Public Sub GetAmpelStatusFaceId(ByRef wbInExcelCurrentProjectInAccess As Object, ByRef faceId As Long, ByRef toolTipText As String)
  faceId = 926
  toolTipText = ""
  
  Select Case G_AmpelStatus ' GetAmpelStatus(wbInExcelCurrentProjectInAccess)
    ' noch nicht gespeichert - Fragezeichen
    Case 99
      faceId = 926
      'toolTipText = "Status unbekannt."
      toolTipText = FMT0("AMPEL_1")
    Case 0
      faceId = 926
      'toolTipText = "Datei noch nicht gespeichert."
      toolTipText = FMT0("AMPEL_2")
    
    ' Noch nicht risikobefragt, noch nicht freigegeben - Wei|fffd| mit Fragezeichen
    Case 1
      faceId = 345
      'toolTipText = "Noch nicht risikobefragt, noch nicht freigegeben"
      toolTipText = FMT0("AMPEL_3")
    
    ' Freigegeben aber Checksumme ver|fffd|ndert - rot
    Case 2
      faceId = 352
      'toolTipText = "Freigegebene Datei, deren Formeln ver|fffd|ndert wurden. Eine produktive Nutzung der Datei ist nicht gestattet."
      toolTipText = FMT0("AMPEL_9")
    
    ' Risikobefragt und |fffd|ber X Prozent - Gelb
    Case 3
      faceId = 343
      'toolTipText = "Risikobefragung durchgef|fffd|hrt, erh|fffd|htes Risiko - bitte Freigabeprozess initiieren."
      toolTipText = FMT0("AMPEL_5")
  
    ' Freigegeben und checksumme ok - gr|fffd|n
    Case 4
      faceId = 394
      'toolTipText = "Freigegebene Datei"
      toolTipText = FMT0("AMPEL_6")
  
    ' Geringes Risiko - Weiss
    Case 5
      faceId = 342
      'toolTipText = "Geringes Risiko"
      toolTipText = FMT0("AMPEL_7")
  
    ' Freigabe initiiert - Blitz
    Case 6
      faceId = 346
      'toolTipText = "Freigabe initiiert"
      toolTipText = FMT0("AMPEL_8")
  
    ' ??? - Gelb mit ausrufezeichen
'    Case 7
'      faceId = 341
'      toolTipText = "Freigabe initiiert"
  
  End Select

End Sub


Public Sub ShowAmpelStatus(ByRef wbInExcelCurrentProjectInAccess As Object)
  
  On Error GoTo nogo
  If Not G_PARAM_Ampel Then Exit Sub
  
  If wbInExcelCurrentProjectInAccess Is Nothing Then Exit Sub
  
  If G_PARAM_Ribbons Then
    InvalidateRibbon
  End If
  
  Dim faceId As Long
  Dim toolTipText As String
  
  GetAmpelStatusFaceId wbInExcelCurrentProjectInAccess, faceId, toolTipText
  
  Dim c As CommandBar
  With wbInExcelCurrentProjectInAccess.Application.CommandBars("ExcelTracker").Controls(1)
      .toolTipText = toolTipText
      .faceId = faceId
  End With
  
  Exit Sub
nogo:
  
End Sub


Public Sub SetzeAmpelStatusOhneConnection(ByRef wbInExcelCurrentProjectInAccess As Object)
    If Mid(wbInExcelCurrentProjectInAccess.fullname, 2, 1) <> ":" And Left(wbInExcelCurrentProjectInAccess.fullname, 2) <> "\\" And Left(wbInExcelCurrentProjectInAccess.fullname, 2) <> "//" And InStr(wbInExcelCurrentProjectInAccess.fullname, "://") <= 0 Then
      G_AmpelStatus = 1
      Exit Sub
    End If
    
    If WBGetValueLong(wbInExcelCurrentProjectInAccess, "_IDVTrackerID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix) < 0 Then
        ' Datei kennt ihre eigene ID nicht
        G_AmpelStatus = 1
        Exit Sub
    End If
    
    Dim conn As Object
    Set conn = GetConnection()
    If Not conn Is Nothing Then
        G_AmpelStatus = GetAmpelStatus(wbInExcelCurrentProjectInAccess, conn)
        conn.Close
        Set conn = Nothing
    Else
        G_AmpelStatus = 1
    End If
End Sub

Public Sub SetzeAmpelStatus(ByRef wbInExcelCurrentProjectInAccess As Object, ByRef conn As Connection)
    
    If wbInExcelCurrentProjectInAccess Is Nothing Then Exit Sub
    If Mid(wbInExcelCurrentProjectInAccess.fullname, 2, 1) <> ":" And Left(wbInExcelCurrentProjectInAccess.fullname, 2) <> "\\" And Left(wbInExcelCurrentProjectInAccess.fullname, 2) <> "//" And InStr(wbInExcelCurrentProjectInAccess.fullname, "://") <= 0 Then
      G_AmpelStatus = 1
      Exit Sub
    End If
    
    If WBGetValueLong(wbInExcelCurrentProjectInAccess, "_IDVTrackerID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix) < 0 Then Exit Sub
    
    G_AmpelStatus = GetAmpelStatus(wbInExcelCurrentProjectInAccess, conn)
End Sub


Function GetAmpelStatus(ByRef wbInExcelCurrentProjectInAccess As Object, ByRef conn As Connection) As Long

  Dim rs As Object
  
  ' noch nicht gespeichert - Fragezeichen
  GetAmpelStatus = 0
  
  If wbInExcelCurrentProjectInAccess Is Nothing Then Exit Function
  
  ' Noch nicht risikobefragt, noch nicht freigegeben - Wei|fffd| mit Fragezeichen
  If WBGetValueLong(wbInExcelCurrentProjectInAccess, "_IDVTrackerID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix) > 0 Then
    
    If WBGetValueLong(wbInExcelCurrentProjectInAccess, "_IDVTrackerFreigabeStatus" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix) = 1 Then
        ' Freigabe initiiert
        GetAmpelStatus = 6
    ElseIf WBGetValueLong(wbInExcelCurrentProjectInAccess, "_IDVTrackerFreigabeStatus" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix) = 2 Then
        ' Freigegeben und checksumme ok - gr|fffd|n
        GetAmpelStatus = 4
        
        ' Jetzt noch pr|fffd|fen, ob sich die Freigabechecksumme ge|fffd|ndert hat!!
         ' Set conn = GetConnection() ' True)
      
         If conn Is Nothing Then
             GetAmpelStatus = 99
             Exit Function
         End If
       
         Set rs = OpenRS("SELECT Checksumme, FreigabeChecksumme FROM idvDateien WHERE idvDateiID=" & WBGetValueLong(wbInExcelCurrentProjectInAccess, "_IDVTrackerID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix) & " AND Version=" & WBGetValueLong(wbInExcelCurrentProjectInAccess, "_IDVTrackerVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix), conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
         If rs Is Nothing Then
             ' Unknown
             GetAmpelStatus = 99
           '  conn.Close
           '  Set conn = Nothing
             Exit Function
         End If
        
         If Not rs.EOF Then
            If GetValueFromField(rs, "Checksumme", 0) <> GetValueFromField(rs, "FreigabeChecksumme", 0) Then
              ' Checksummen unterschiedlich
              GetAmpelStatus = 2
            End If
         Else
           ' Unknown
           GetAmpelStatus = 99
         End If
         rs.Close
         Set rs = Nothing
         'conn.Close
         'Set conn = Nothing
        
        
    Else
         'Set conn = GetConnection() ' True)
      
         If conn Is Nothing Then
             GetAmpelStatus = 99
             Exit Function
         End If
       
         Set rs = OpenRS("SELECT Risikowert FROM idvDateien WHERE idvDateiID=" & WBGetValueLong(wbInExcelCurrentProjectInAccess, "_IDVTrackerID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix) & " AND Version=" & WBGetValueLong(wbInExcelCurrentProjectInAccess, "_IDVTrackerVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix), conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
         If rs Is Nothing Then
             ' Unknown
             GetAmpelStatus = 99
          '   conn.Close
          '   Set conn = Nothing
             Exit Function
         End If
        
         If Not rs.EOF Then
            If GetValueFromField(rs, "Risikowert", 0) = -1 Then
              ' Noch nicht Risikobefragt
              GetAmpelStatus = 1
            ElseIf GetValueFromField(rs, "Risikowert", 0) >= G_PARAM_AmpelRisiko Then
              ' Risikowert erh|fffd|ht
              GetAmpelStatus = 3
            Else
              ' Risikowert gering
              GetAmpelStatus = 5
            End If
         Else
           ' Unknown
           GetAmpelStatus = 99
         End If
         rs.Close
         Set rs = Nothing
         'conn.Close
         'Set conn = Nothing
    End If
  End If
  
  ' Freigegeben aber Checksumme ver|fffd|ndert - rot
'  GetAmpelStatus = 2
    
  ' Risikobefragt und |fffd|ber X Prozent - Gelb
'  GetAmpelStatus = 3
  
  
End Function

Attribute VB_Name = "ArrayHelpers"
Option Compare Text
Option Explicit
Option Base 0

'Sorts the array using the MergeSort algorithm (follows the pseudocode on Wikipedia
'O(n*log(n)) time; O(n) space
Public Sub MergeSort(a() As Variant)
    Dim b() As Variant
    ReDim b(0 To UBound(a))
    TopDownSplitMerge a, 0, UBound(a), b
End Sub

'Used by MergeSortAlgorithm
Private Sub TopDownSplitMerge(a() As Variant, iBegin As Long, iEnd As Long, b() As Variant)

    If iEnd - iBegin < 2 Then ' if run size = 1
        Exit Sub ' consider it sorted
    End If

    ' recursively split runs into two halves until run size = 1
    ' then merge them and return back up the call chain
    Dim iMiddle As Long
    iMiddle = (iEnd + iBegin) / 2 ' iMiddle = mid point
    TopDownSplitMerge a, iBegin, iMiddle, b 'split-merge left half
    TopDownSplitMerge a, iMiddle, iEnd, b ' split-merge right half
    TopDownMerge a, iBegin, iMiddle, iEnd, b ' merge the two half runs
    Copy b, iBegin, a, iBegin, iEnd - iBegin 'copy the merged runs back to A
End Sub

'Used by MergeSort algirtm
Private Sub TopDownMerge(a() As Variant, iBegin As Long, iMiddle As Long, iEnd As Long, b() As Variant)
    'left half is A[iBegin:iMiddle-1]
    'right half is A[iMiddle:iEnd-1]
    Dim i As Long
    Dim j As Long
    Dim K As Long
    i = iBegin
    j = iMiddle

    'while there are elements in the left or right runs...
    For K = iBegin To iEnd Step 1
        'If left run head exists and is <= existing right run head.
        If i < iMiddle And (j >= iEnd Or a(i) <= a(j)) Then
            b(K) = a(i)
            i = i + 1
        Else
            b(K) = a(j)
            j = j + 1
        End If
    Next K
End Sub

'Used by MergeSort algorithm
Private Sub CopyRange(Source() As Variant, iBegin As Long, iEnd As Long, dest() As Variant)
    Dim K As Long
    For K = iBegin To iEnd Step 1
        dest(K) = Source(K)
    Next K
End Sub

'Copies an array from the specified source array, beginning at the specified position, to the specified position in the destination array
Public Sub Copy(ByRef src() As Variant, srcPos As Long, ByRef dst() As Variant, dstPos As Long, Length As Long)

    'Check if all offsets and lengths are non negative
    If srcPos < 0 Or dstPos < 0 Or Length < 0 Then
        err.Raise 9, , "negative value supplied"
    End If

    'Check if ranges are valid
    If Length + srcPos > UBound(src) Then
        err.Raise 9, , "Not enough elements to copy, src+length: " & srcPos + Length & ", UBound(src): " & UBound(src)
    End If
    If Length + dstPos > UBound(dst) Then
        err.Raise 9, , "Not enough room in destination array. dstPos+length: " & dstPos + Length & ", UBound(dst): " & UBound(dst)
    End If
    Dim i As Long
    i = 0
    'copy src elements to dst
    Do While Length > i
        dst(dstPos + i) = src(srcPos + i)
        i = i + 1
    Loop

End Sub

Attribute VB_Name = "BitteWarten"
Attribute VB_Base = "0{206F2C14-2947-402F-91B4-93AB53A267B9}{715C11F9-3B42-4FF2-A6D2-617E832A9705}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit


Public Sub Refresh()

End Sub

Private Sub UserForm_Initialize()
  gTranslation.TranslateForm Me
End Sub

Attribute VB_Name = "Blattschutz"
Option Explicit

Public G_BlattschutzSellist As Collection
Private Const L_PWStr As String = "abcdefghijklmnopqrstufwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!$%&/()=+#-.,;:_'*{[]}\~<>|"

Function BlattschutzAnbringen(ByRef conn As Object, ByRef rs As Object, ByRef xlapp As Object, ByRef curdoc As Object, ByVal userinitiiert As Boolean) As Boolean

' On Error GoTo nogo

    If curdoc Is Nothing Then Exit Function

#If Project_ExcelTracker = 1 Then
    If curdoc.readOnly = True Then
        ' "Die Datei ist schreibgesch|fffd|tzt"
        MsgBox FMT0("THISADDIN_111"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        Exit Function
    End If
#End If

    Dim logtrack As Long
    logtrack = 0
    
    Set G_BlattschutzSellist = New Collection
    If userinitiiert Then
      frmBlattschutzLock.Tabblaetter.Clear
      Dim s As Object
      For Each s In curdoc.Sheets
        If s.ProtectContents = False Then
          frmBlattschutzLock.Tabblaetter.AddItem s.name
        End If
      Next s
      
      ' Wenn es mindestens eine Version gibt
      If frmBlattschutzLock.Tabblaetter.ListCount > 0 Then
        frmBlattschutzLock.Auswahl = -1
        frmBlattschutzLock.Show vbModal
        
        ' Abbruch
        If frmBlattschutzLock.Auswahl = -1 Then
          Set G_BlattschutzSellist = Nothing
          Exit Function
        End If
      Else
        'MsgBox "Es gibt keine ungesch|fffd|tzten Tabellenbl|fffd|tter in dieser Datei.", vbInformation, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        MsgBox FMT0("BLATTSCHUTZ_6"), vbInformation, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        Exit Function
      End If
      
      If G_BlattschutzSellist.count <= 0 Then
        Set G_BlattschutzSellist = Nothing
        Exit Function
      End If
    Else
      ' Einfach alle rein!
      For Each s In curdoc.Sheets
        If s.ProtectContents = False Then
          G_BlattschutzSellist.add s.name
        End If
      Next s
    End If
    
    Dim i As Long
    G_Abbruch = False
    'BitteWarten.BitteWartenText.Caption = "Bitte warten, Bl|fffd|tter werden gesch|fffd|tzt."
    BitteWarten.BitteWartenText.Caption = FMT0("BLATTSCHUTZ_7")
    BitteWarten.Label1.Caption = ""
    
    BitteWarten.Show vbModeless
    
    Dim scount As Long
    scount = 0
    Dim protformulas As Long
    protformulas = 0
    Dim simpleformulas As Long
    simpleformulas = 0
    Dim nonanalyzables As Long
    nonanalyzables = 0
    Dim log As String
    
    Dim passwrd As New Collection
    
    For i = 1 To G_BlattschutzSellist.count
      'BitteWarten.Label1.Caption = "Tabelle " & i & " / " & G_BlattschutzSellist.count & ": " & G_BlattschutzSellist(i)
      BitteWarten.Label1.Caption = FMT3("BLATTSCHUTZ_8", i, G_BlattschutzSellist.count, G_BlattschutzSellist(i))
      DoEvents
      BitteWarten.Refresh
      Dim pw As String
      pw = GetStandardPasswordBlattschutz
      If ProtSheet(curdoc.Sheets(G_BlattschutzSellist(i)), log, protformulas, simpleformulas, nonanalyzables, pw) Then
        passwrd.add pw
      Else
        passwrd.add "-"
      End If
    Next i
    
    BitteWarten.Hide
    
    If G_Abbruch Then
      'MsgBox "ACHTUNG: Sie haben den Vorgang abgebrochen! Damit keine unerw|fffd|nschten Nebeneffekte entstehen wird die Datei geschlossen!", vbCritical, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
      MsgBox FMT0("BLATTSCHUTZ_9"), vbExclamation, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
      If userinitiiert Then
        curdoc.Close False
      End If
    Else
    
      ' Und die Passw|fffd|rter speichern
      Dim trs As Object
      Set trs = CreateObject("ADODB.Recordset")
      trs.Open "SELECT * FROM idvDateienPW WHERE idvDateiID = " & rs.Fields("idvDateiID").value & " AND PWTyp = 20", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockOptimistic
      Dim logSheets As String
      For i = 1 To G_BlattschutzSellist.count
        If passwrd(i) <> "-" Then
          If trs.BOF = False Or trs.EOF = False Then
            trs.MoveFirst
            trs.Find "Tabname='" & G_BlattschutzSellist(i) & "'"
          End If
          If trs.EOF Then
            trs.AddNew
            trs.Fields("idvDateiID").value = rs.Fields("idvDateiID").value
            trs.Fields("PWTyp").value = 20
            trs.Fields("Tabname").value = CStr(G_BlattschutzSellist(i))
          End If
          trs.Fields("LogonID").value = GetUserNameUCASE
          trs.Fields("Datum").value = Now
          trs.Fields("SystemPW").value = True
          trs.Fields("Passwort").value = Crypt(CStr(passwrd(i)), "T0)7/hJy+\1TrcpI?", True)
          logSheets = logSheets & IIf(logSheets <> "", ",", "") & G_BlattschutzSellist(i)
          trs.Update
        End If
      Next i
      trs.Close
      Set trs = Nothing
      DoInternalSave rs, curdoc, conn
      LogSpeichern rs, curdoc, conn
      
      If userinitiiert Then
        rs.Update
      End If
      
      If logSheets <> "" Then
        DebugPrint tSystem, "Blattschutz:" & logSheets, 0, 4, rs.Fields("idvDateiID").value
      End If
      
    
      Set G_BlattschutzSellist = Nothing
      'log = log & protformulas & " Zelle(n) auf gesch|fffd|tzt gesetzt." & vbCrLf
      log = log & FMT1("BLATTSCHUTZ_10", protformulas) & vbCrLf
      'log = log & simpleformulas & " 'einfache' Formelzelle(n) wurden nicht gesch|fffd|tzt." & vbCrLf
      log = log & FMT1("BLATTSCHUTZ_11", simpleformulas) & vbCrLf
      'log = log & nonanalyzables & " Formel-Zellen waren nicht analysierbar, wurden aber gesch|fffd|tzt." & vbCrLf
      log = log & FMT1("BLATTSCHUTZ_12", nonanalyzables) & vbCrLf
      MsgBox log, vbExclamation, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
      
    End If

    BlattschutzAnbringen = True
    Exit Function
nogo:
    On Error Resume Next
    If Not trs Is Nothing Then
      If trs.state <> 0 Then
        trs.Close
      End If
      Set trs = Nothing
    End If

End Function


Sub GetLastCell(ByRef oxlwsheet As Object, ByRef r As Range)
  On Error Resume Next
  Set r = Nothing
  Set r = oxlwsheet.Cells.SpecialCells(xlCellTypeLastCell)
End Sub

Function GetLastRow(ByRef oxlwsheet As Object) As Long
  On Error Resume Next
  
  GetLastRow = 0
  
  Dim r As Range
  Set r = Nothing
  Set r = oxlwsheet.Cells.SpecialCells(xlCellTypeLastCell)
  
  If r Is Nothing Then
    Set r = oxlwsheet.Range("A1")
  End If

  Dim r2 As Range
  Set r2 = Nothing
  Set r2 = oxlwsheet.Cells.SpecialCells(xlCellTypeLastCell)
  
  Set r2 = oxlwsheet.Cells.Find(What:="*", After:=oxlwsheet.Range("A1"), LookAt:=xlWhole, LookIn:=xlFormulas, SearchDirection:=xlPrevious)
  If r2 Is Nothing Then
    Set r2 = oxlwsheet.Range("A1")
  End If
  
  
  If r2.Row > 1 Then
    GetLastRow = r2.Row
  Else
    If r2.Row > r.Row Then
      GetLastRow = r2.Row
    Else
      GetLastRow = r.Row
    End If
  End If
  Set r = Nothing
  Set r2 = Nothing
End Function

Function GetFormulaRangeLine(oxlwsheet, l As Long)
  On Error Resume Next
  Dim olddisplayalerts As Boolean
  olddisplayalerts = oxlwsheet.Application.DisplayAlerts
  Set GetFormulaRangeLine = Nothing
  oxlwsheet.Application.DisplayAlerts = False
  Set GetFormulaRangeLine = oxlwsheet.Rows(l).SpecialCells(xlCellTypeFormulas)
  oxlwsheet.Application.DisplayAlerts = olddisplayalerts
End Function

Function SheetHasPassword(oxlwsheet)
    SheetHasPassword = True
    On Error GoTo password_notok
    ' Wir probieren das Ganze mit einem idiotischen Passwort
    oxlwsheet.Unprotect "12%%XXy<11!A"
    SheetHasPassword = False
password_notok:
End Function


Function ProtectCells(ByRef s As Object, ByRef log As String, ByRef cllcnt As Long, ByRef simpleformulas As Long, ByRef nonanalyzables As Long, ByRef erram As Long) As Boolean
  On Error GoTo nogo

  Dim tFormulaCount As Long
  Dim totalLineAmount As Long
  Dim lineCount As Long
  Dim formulaCells As Range
  Dim c As Range
  
  Dim statusText As String
  statusText = BitteWarten.Label1.Caption
  
  erram = 0

  If TypeName(s) = "Worksheet" Then
  
    Dim yend As Long
    yend = GetLastRow(s)
    
    If yend > 0 Then
      totalLineAmount = yend
      For lineCount = 1 To yend
      
                    Set formulaCells = GetFormulaRangeLine(s, lineCount)
                    
                    tFormulaCount = 0
                    If Not formulaCells Is Nothing Then
                      tFormulaCount = formulaCells.count
                      For Each c In formulaCells
                        If c.HasFormula Then
                          If FormulaAnalyzable(c) Then
                            If IsSimpleFormula(c.Formula) Then
                              simpleformulas = simpleformulas + 1
                            Else
                              If c.Formula <> "" Then
                                If Not c.MergeArea Is Nothing Then
                                  c.MergeArea.Locked = True
                                Else
                                  c.Locked = True
                                End If
                                cllcnt = cllcnt + 1
                              End If
                            End If
                          Else
                            If Not c.MergeArea Is Nothing Then
                              c.MergeArea.Locked = True
                            Else
                              c.Locked = True
                            End If
                            cllcnt = cllcnt + 1
                            nonanalyzables = nonanalyzables + 1
                          End If
                        End If
                      Next c
                    End If
        If lineCount Mod 10 = 0 Then
          BitteWarten.Label1.Caption = statusText & " (" & Format(CDbl(lineCount) / CDbl(yend), "PERCENT") & ")"
          DoEvents
          BitteWarten.Refresh
        End If
        If G_Abbruch Then Exit For
      Next lineCount
    End If
  End If
  
  ProtectCells = IIf(erram = 0, True, False)
  Exit Function
nogo:
  log = log & c.Address & " - " & err.Number & " - " & err.Description & vbCrLf
  err.Clear
  erram = erram + 1
  On Error GoTo nogo
  Resume Next

End Function

Function ProtectSheet(ByRef s As Object, ByVal pw As String) As Boolean

  On Error GoTo nogo
  ' Ausdruck.Protect(Password, DrawingObjects, Contents, Scenarios, UserInterfaceOnly,
  ' AllowFormattingCells,
  ' AllowFormattingColumns,
  ' AllowFormattingRows,
  ' AllowInsertingColumns, AllowInsertingRows,
  ' AllowInsertingHyperlinks,
  ' AllowDeletingColumns, AllowDeletingRows, AllowSorting,
  ' AllowFiltering,
  ' AllowUsingPivotTables)

  s.Protect pw, True, True, True, _
                      IIf(InStr(G_cfgWorksheetProtArgs, "FORMATZELLE") > 0, True, False), _
                      IIf(InStr(G_cfgWorksheetProtArgs, "FORMATZEILE") > 0, True, False), _
                      IIf(InStr(G_cfgWorksheetProtArgs, "FORMATSPALTE") > 0, True, False), _
                      False, False, _
                      IIf(InStr(G_cfgWorksheetProtArgs, "HYPER") > 0, True, False), _
                      False, False, False, _
                      IIf(InStr(G_cfgWorksheetProtArgs, "AUTOFILTER") > 0, True, False), _
                      IIf(InStr(G_cfgWorksheetProtArgs, "PIVOT") > 0, True, False)
  
  ProtectSheet = True
  Exit Function
nogo:
  
End Function

Function ProtSheet(ByRef s As Object, ByRef log As String, ByRef protformulas As Long, ByRef simpleformulas As Long, ByRef nonanalyzables As Long, ByVal passwrd As String) As Boolean
  Dim logsub As String
  Dim erram As Long
  
  ProtSheet = False
  
  On Error Resume Next
  If s.ProtectContents = True Then
    'log = log & "*** FEHLER *** Tabelle '" & s.name & "' ist bereits abgesichert!" & vbCrLf
    log = log & FMT1("BLATTSCHUTZ_13", s.name) & vbCrLf
  Else
  
    ' Tabellen mit Zellen
    If TypeName(s) = "Worksheet" Then
      If Not ProtectCells(s, logsub, protformulas, simpleformulas, nonanalyzables, erram) Then
        'log = log & "  *** FEHLER *** in Tabelle '" & s.name & "'" & vbCrLf & logsub
        log = log & FMT1("BLATTSCHUTZ_14", s.name) & vbCrLf & logsub
      Else
        If ProtectSheet(s, passwrd) Then
          'log = log & "Blattschutz auf '" & s.name & "' angebracht" & vbCrLf
          log = log & FMT1("BLATTSCHUTZ_15", s.name) & vbCrLf
          ProtSheet = True
        Else
          'log = log & " *** FEHLER *** Tabelle '" & s.name & "' konnte nicht abgesichert werden!" & vbCrLf
          log = log & FMT1("BLATTSCHUTZ_16", s.name) & vbCrLf
        End If
      End If
    ' Tabellen ohne Zellen
    Else
      If ProtectSheet(s, passwrd) Then
        'log = log & "Blattschutz auf '" & s.name & "' angebracht" & vbCrLf
        log = log & FMT1("BLATTSCHUTZ_15", s.name) & vbCrLf
        ProtSheet = True
      Else
        'log = log & " *** FEHLER *** Tabelle '" & s.name & "' konnte nicht abgesichert werden!" & vbCrLf
        log = log & FMT1("BLATTSCHUTZ_16", s.name) & vbCrLf
      End If
    End If
  End If
End Function


Function IsSimpleFormula(f As String) As Boolean
    
  Dim pos As Long
  Dim pos2 As Long
  Do
    pos = InStr(f, "N(" & Chr(34))
    If pos > 0 Then
    
' .NET START
      If pos > 1 Then
        If UCase(Mid(f, pos - 1, 1)) >= "A" And UCase(Mid(f, pos - 1, 1)) <= "Z" Then
          Exit Do
        End If
      End If
' .NET END
      pos2 = InStr(pos + 3, f, Chr(34))
      If pos2 <= 0 Then Exit Do
      If Mid(f, pos2 + 1, 1) = ")" Then
        f = Left(f, pos - 1) & Mid(f, pos2 + 2)
      Else
        Exit Do
      End If
    Else
      Exit Do
    End If
  Loop
  If Trim(StrRemove(f, "0123456789+-*/^(). " & vbCrLf & vbTab)) = "=" Then IsSimpleFormula = True
End Function

Function FormulaAnalyzable(c) As Boolean
  FormulaAnalyzable = True
  On Error GoTo notAnalyzable
  If c.Formula = "a" Then
  End If
  Exit Function
notAnalyzable:
  FormulaAnalyzable = False
End Function

Function StrRemove(srcstring As String, removechars As String) As String
  Dim res As String
  Dim x As Long
  Dim l As Long
  l = Len(removechars)
  
  res = srcstring
  If l > 0 Then
    For x = 1 To l
      res = Replace(res, Mid(removechars, x, 1), "")
    Next x
  End If
  StrRemove = res
End Function

Function GetRandomPassword() As String
  Dim pwchr As Long
  Dim news As String
  Dim sc As Long
  For sc = 1 To 15
    pwchr = CLng((Len(L_PWStr) * Rnd) + 1)
    news = news + Mid(L_PWStr, pwchr, 1)
  Next sc
  GetRandomPassword = news
End Function

Sub BlattschutzEntfernen(ByRef conn As Object, ByRef rs As Object, ByRef xlapp As Object, ByRef curdoc As Object, ByVal userinitiiert As Boolean)
    
    If curdoc Is Nothing Then Exit Sub
    
#If Project_ExcelTracker = 1 Then
    If curdoc.readOnly = True Then
        ' "Die Datei ist schreibgesch|fffd|tzt"
        MsgBox FMT0("THISADDIN_111"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        Exit Sub
    End If
#End If

    Dim logtrack As Long
    logtrack = 0

    Set G_BlattschutzSellist = New Collection
    
    Dim trs As Object
    Set trs = CreateObject("ADODB.Recordset")
    trs.Open "SELECT * FROM idvDateienPW WHERE idvDateiID = " & rs.Fields("idvDateiID").value & " AND PWTyp = 20 and SystemPW <> 0", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockOptimistic
    
    If userinitiiert Then
            frmBlattschutzUnlock.Tabblaetter.Clear
            
            Do While Not trs.EOF
              If WorksheetExists(curdoc, CStr(trs.Fields("Tabname").value)) Then
                If curdoc.Sheets(CStr(trs.Fields("Tabname").value)).ProtectContents = True Then
                  frmBlattschutzUnlock.Tabblaetter.AddItem CStr(trs.Fields("Tabname").value)
                End If
              End If
              trs.MoveNext
            Loop
            
            ' Wenn es mindestens eine Version gibt
            If frmBlattschutzUnlock.Tabblaetter.ListCount > 0 Then
              frmBlattschutzUnlock.Auswahl = -1
              frmBlattschutzUnlock.Show vbModal
              
              ' Abbruch
              If frmBlattschutzUnlock.Auswahl = -1 Then
                Set G_BlattschutzSellist = Nothing
                trs.Close
                Set trs = Nothing
                Exit Sub
              End If
              
            Else
              'MsgBox "Es gibt keine mit der IDV-Suite gesch|fffd|tzten Tabellenbl|fffd|tter in dieser Datei.", vbInformation, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
              MsgBox FMT0("BLATTSCHUTZ_17"), vbInformation, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
              trs.Close
              Set trs = Nothing
              Exit Sub
            End If
    Else
            ' Einfach alle rein!
            Dim s As Object
            For Each s In curdoc.Sheets
              If s.ProtectContents = True Then
                G_BlattschutzSellist.add s.name
              End If
            Next s
    End If
    
    If G_BlattschutzSellist.count <= 0 Then
      Set G_BlattschutzSellist = Nothing
      trs.Close
      Set trs = Nothing
      Exit Sub
    End If
    
    If userinitiiert Then
      If G_PARAM_BlattschutzEntf4AP Then
        'frmLogin.Cont.Text = "Dateiname: " & curDoc.fullname & vbCrLf & vbCrLf & "Blattschutz entfernen von folgenden Tabellen wurde angefordert:" & vbCrLf
        frmLogin.Cont.Text = FMT1("BLATTSCHUTZ_18", curdoc.fullname) & vbCrLf
        frmLogin.txtUserName = ""
        frmLogin.txtPassword = ""
        Dim i As Long
        For i = 1 To G_BlattschutzSellist.count
          frmLogin.Cont.Text = frmLogin.Cont.Text & CStr(G_BlattschutzSellist(i)) & vbCrLf
        Next i
        frmLogin.Show vbModal
        
        If Not frmLogin.LoginSucceeded Then
          Set G_BlattschutzSellist = Nothing
          trs.Close
          Set trs = Nothing
          Exit Sub
        End If
      End If
    End If
    
    Dim logSheets As String
    Dim errLogSheets As String
    
    For i = 1 To G_BlattschutzSellist.count
      Dim pw As String
      If trs.BOF = False Or trs.EOF = False Then
        trs.MoveFirst
        trs.Find "Tabname = '" & G_BlattschutzSellist(i) & "'"
      End If
      If Not trs.EOF Then
      
        If RemoveBlattschutz(curdoc.Sheets(G_BlattschutzSellist(i)), CStr(trs.Fields("Passwort").value)) Then
          logSheets = logSheets & IIf(logSheets <> "", ",", "") & G_BlattschutzSellist(i)
        Else
          errLogSheets = errLogSheets & IIf(errLogSheets <> "", ",", "") & G_BlattschutzSellist(i)
        End If
        trs.Delete
      End If
    Next i
    
    trs.Close
    Set trs = Nothing
    
    DoInternalSave rs, curdoc, conn
    LogSpeichern rs, curdoc, conn
    If logSheets <> "" Then
      DebugPrint tSystem, "Blattschutz entfernt von " & GetUserName & IIf(G_PARAM_BlattschutzEntf4AP, ", autorisiert durch: " & frmLogin.AuthorizingUser, "") & ":" & logSheets, 0, 6, rs.Fields("idvDateiID").value
    End If
    
    If userinitiiert Then
      rs.Update
    End If
    
    'MsgBox "Passw|fffd|rter von folgenden Tabellen entfernt: " & logSheets & IIf(errLogSheets <> "", vbCrLf & vbCrLf & "Auf folgenden Bl|fffd|ttern konnte der Blattsschutz NICHT entfernt werden: " & errLogSheets, ""), vbInformation, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
    MsgBox FMT1("BLATTSCHUTZ_19", logSheets) & IIf(errLogSheets <> "", vbCrLf & vbCrLf & FMT1("BLATTSCHUTZ_20", errLogSheets), ""), vbInformation, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"

    Exit Sub
nogo:
    On Error Resume Next
    If Not trs Is Nothing Then
      If trs.state <> 0 Then
        trs.Close
      End If
      Set trs = Nothing
    End If
    
End Sub

Function RemoveBlattschutz(ByRef s As Object, ByVal pw As String) As Boolean
On Error GoTo nogo

  s.Unprotect Crypt(pw, "T0)7/hJy+\1TrcpI?", False)
  RemoveBlattschutz = True
  Exit Function

nogo:
End Function

Attribute VB_Name = "Blobstuff"
Option Explicit

#If VBA7 And Win64 Then
Declare PtrSafe Sub SWCompressFile Lib "SWPacker64.dll" (ByVal a As String, ByVal Level As Integer)
Declare PtrSafe Sub SWDecompressFile Lib "SWPacker64.dll" (ByVal a As String)
Declare PtrSafe Sub SWTest Lib "SWPacker64.dll" ()
Private Declare PtrSafe Function FreeLibrary Lib "kernel32" (ByVal hLibModule As LongPtr) As Long
Private Declare PtrSafe Function LoadLibrary Lib "kernel32" Alias "LoadLibraryA" (ByVal lpLibFileName As String) As LongPtr
#Else
Declare Sub SWCompressFile Lib "SWPacker.dll" (ByVal a As String, ByVal Level As Integer)
Declare Sub SWDecompressFile Lib "SWPacker.dll" (ByVal a As String)
Declare Sub SWTest Lib "SWPacker.dll" ()
Private Declare Function FreeLibrary Lib "kernel32" (ByVal hLibModule As Long) As Long
Private Declare Function LoadLibrary Lib "kernel32" Alias "LoadLibraryA" (ByVal lpLibFileName As String) As Long
#End If

Public Sub TestPackDLL()
On Error GoTo fehler
    Dim a As String
    a = Space$(260)
    a = CurDir("c")
    a = "d:\IDV-SuiteCF\IDV-Suite\Exceladdin\ExcelTracker.xla"

#If VBA7 And Win64 Then
    Dim lb As LongPtr
#Else
    Dim lb As Long
#End If
    Dim pa As Long
#If VBA7 And Win64 Then
    lb = LoadLibrary(ThisWorkbook.path & "\..\BIN\SWPacker64.dll")
#Else
    lb = LoadLibrary(ThisWorkbook.path & "\..\BIN\SWPacker.dll")
#End If
    If lb <> 0 Then
      SWCompressFile a, 57
      FreeLibrary lb
    End If
    Exit Sub
    
fehler:
    MsgBox "CompressFile hat einen Fehler geliefert " & err.Description
    
End Sub


Public Sub TestDePackDLL()
On Error GoTo fehler
    Dim a As String
    a = Space$(260)
    a = "d:\Temp\ExcelTracker.xla.gz"

#If VBA7 And Win64 Then
    Dim lb As LongPtr
#Else
    Dim lb As Long
#End If
    Dim pa As Long
#If VBA7 And Win64 Then
    lb = LoadLibrary(ThisWorkbook.path & "\..\BIN\SWPacker64.dll")
#Else
    lb = LoadLibrary(ThisWorkbook.path & "\..\BIN\SWPacker.dll")
#End If
    If lb <> 0 Then
      SWDecompressFile a
      FreeLibrary lb
    End If
    Exit Sub
    
fehler:
    MsgBox "DeCompressFile hat einen Fehler geliefert " & err.Description

End Sub

Public Function PackFile(ByVal filename As String, ByVal copyToTemp As Boolean) As String
    On Error GoTo fehlerPackFile
    
    PackFile = ""
    Dim tempFilename As String
    If copyToTemp Then
        tempFilename = GetFileNameAndPath(CreateTempFile("Tmp")) & GetFileName(filename)
        CopyFile filename, tempFilename
    Else
        tempFilename = filename
    End If
    PackFile = tempFilename

    ' 57 = '0'+9, wird als Ziffer von SWCompressFile in einen String geschrieben
    If FileExists(tempFilename) Then

#If VBA7 And Win64 Then
      Dim lb As LongPtr
#Else
      Dim lb As Long
#End If
      Dim pa As Long
#If VBA7 And Win64 Then
      lb = LoadLibrary(G_cfgBinpfad & "\SWPacker64.dll")
#Else
      lb = LoadLibrary(G_cfgBinpfad & "\SWPacker.dll")
#End If
      If lb <> 0 Then
        SWCompressFile tempFilename, 50
        ' MsgBox "Datei gepackt!"
        PackFile = tempFilename + ".gz"
        FreeLibrary lb
      End If
    Else
        PackFile = ""
        Exit Function
    End If
    
    ' es wurde gepackt und die TempDatei wurde auch oben durch Kopieren erstellt
    ' dann m|fffd|ssen wir die hier wieder l|fffd|schen
    If PackFile <> tempFilename And copyToTemp = True Then
        MyKill tempFilename
    End If
    Exit Function
fehlerPackFile:
On Error GoTo rausAusFunktion
    If lb <> 0 Then
      FreeLibrary lb
    End If
    If PackFile <> tempFilename And copyToTemp = True Then
        MyKill tempFilename
    End If
rausAusFunktion:
End Function

Public Function UnpackFile(ByVal filename As String) As String
    UnpackFile = filename
    On Error GoTo fehlerPackFile
    
    ' ChDrive app.path
    ' ChDir app.path
#If VBA7 And Win64 Then
    Dim lb As LongPtr
#Else
    Dim lb As Long
#End If

    Dim pa As Long
#If VBA7 And Win64 Then
      lb = LoadLibrary(G_cfgBinpfad & "\SWPacker64.dll")
#Else
      lb = LoadLibrary(G_cfgBinpfad & "\SWPacker.dll")
#End If
    If lb <> 0 Then
      SWDecompressFile filename
      FreeLibrary lb
      UnpackFile = Left(filename, Len(filename) - 3)
    End If
    
    Exit Function
fehlerPackFile:
    If lb <> 0 Then
      FreeLibrary lb
    End If
End Function

    Public Function GetSplitSizeInMB() As Long
        GetSplitSizeInMB = CLng(32)
    End Function

    Public Function GetSplitSize() As Long
        ' ab welcher Gr|fffd||fffd|e legen wir mehrere Eintr|fffd|ge in der xlBin Blobs an,
        ' damit wir bei gro|fffd|en Dateien kein OutOfMemory bekommen
        GetSplitSize = CLng(1024) * CLng(1024) * CLng(32)
    End Function


    Public Function xlCheckInBinary(ByRef conn As Object, ByVal idvDateiID As Long, ByVal Version As Long, ByVal dat As Date, ByVal fname As String, ByRef errstr As String) As Boolean
        On Error GoTo fehler

        ' Erst mal eine eventuell bereits eingecheckte Datei rauswerfen!
        ' !!!! nicht mehr direkt |fffd|ber xlBin l|fffd|schen sondern |fffd|ber den xlBinUpdate View
        ' ansonsten geht das nicht mit dem Security Zeugs
        'conn.Execute "DELETE FROM xlBin WHERE idvDateiID = " & idvDateiID & " and Version = " & Version
        conn.Execute "DELETE FROM A_XLBINUPDATE WHERE idvDateiID = " & idvDateiID & " and Version = " & Version

        Dim rs As Object
        ' !!!! hier jetzt |fffd|ber den neuen View f|fffd|r die xlBins gehen
        ' ansonsten bekommt man keinen Recordset zur|fffd|ck
        If G_DBType <> G_SQL_Server Then
            Set rs = OpenRS("SELECT * FROM A_XLBININSERT", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockOptimistic)
            If rs Is Nothing Then
              xlCheckInBinary = False
              Exit Function
            End If
        End If
        
        If Not StatusForm.visible Then
          'ShowStatusForm "Lade Doku...", False
          ShowStatusForm gTranslation.GetSafeString("BitteWarten_1"), False
        End If
        
        Dim zippedFilename As String
        zippedFilename = PackFile(fname, False)
        
        Dim splitFilenames() As String
        Dim step As Long
        If (SplitFile(zippedFilename, GetSplitSize(), splitFilenames)) Then
        Else
            ReDim splitFilenames(0)
            splitFilenames(0) = zippedFilename
        End If
        
        For step = LBound(splitFilenames) To UBound(splitFilenames)
            DebugPrint tdebug, "xlCheckInBin-Einf|fffd|gen (ID " & idvDateiID & "  V" & Version & "): " & fname
            If StatusForm.visible Then
              'ShowStatusForm "Lade Doku...", False
              UpdateStatusForm gTranslation.GetSafeString("BitteWarten_1"), CDbl(step + 1) / CDbl(UBound(splitFilenames) - LBound(splitFilenames) + 1)
              DoEvents
            End If
            
            If G_DBType = G_SQL_Server Then
                If Not CheckInBinarySQLServer(conn, splitFilenames(step), idvDateiID, Version, dat, step, zippedFilename, errstr) Then
                  DebugPrint tdebug, "xlCheckInBin-Datei NICHT eingef|fffd|gt"
                  xlCheckInBinary = False
                  Exit For
                Else
                  DebugPrint tdebug, "xlCheckInBin-Datensatz gespeichert"
                  xlCheckInBinary = True
                End If
            Else
                rs.AddNew
                rs.Fields("idvDateiID").value = idvDateiID
                rs.Fields("Version").value = Version
                rs.Fields("Datum").value = dat
                rs.Fields("Compressed").value = IIf(Right(zippedFilename, 3) = ".gz", 1, 0)
                rs.Fields("Step").value = step
        
                If Not CheckInBinary("Binary", rs, splitFilenames(step), errstr) Then
                  DebugPrint tdebug, "xlCheckInBin-Datei NICHT eingef|fffd|gt"
                  rs.CancelUpdate
                  xlCheckInBinary = False
                  Exit For
                Else
                  DebugPrint tdebug, "xlCheckInBin-Datei eingef|fffd|gt"
                  rs.Update
                  DebugPrint tdebug, "xlCheckInBin-Datensatz gespeichert"
                  xlCheckInBinary = True
                End If
            End If
        Next
        If G_DBType <> G_SQL_Server Then
          rs.Close
          Set rs = Nothing
        End If
        
        If StatusForm.visible Then
          HideStatusForm
        End If
        DebugPrint tdebug, "xlCheckInBin-ENDE"
        
        On Error GoTo exitohnefehler
        If zippedFilename <> fname Then
            MyKill zippedFilename
        End If
        For step = LBound(splitFilenames) To UBound(splitFilenames)
            If splitFilenames(step) <> fname Then
                MyKill splitFilenames(step)
            End If
        Next
exitohnefehler:
        Exit Function
fehler:
        If StatusForm.visible Then
          HideStatusForm
        End If
'        If Not rs Is Nothing Then
'          rs.Close
          Set rs = Nothing
'        End If
        xlCheckInBinary = False
        errstr = err.Number & " - " & err.Description & " - " & err.Source
        DebugPrint tERROR, "xlCheckInBinary: " & err.Number & " - " & err.Description & " - " & err.Source & " - Datei: " & fname
    End Function

    Public Function CheckInBinary(ByVal fieldname As String, ByRef rs As Object, ByVal fname As String, ByRef errstr As String, Optional fieldFilenameExtension As String = "") As Boolean

        On Error GoTo fehler
        
        If Not FileExists(fname) Then
          'errstr = errstr & IIf(errstr <> "", vbCrLf, "") & "Die Datei '" & fname & "' existiert nicht."
          errstr = errstr & IIf(errstr <> "", vbCrLf, "") & FMT1("BLOBSTUFF_1", fname)
          Exit Function
        End If
        
        Dim Doc As Object
        Set Doc = CreateObject("ADODB.Stream")
        
        Dim SavedPointer As Long
        'SavedPointer = Screen.MousePointer  ' Save mouse pointer.
        'Screen.MousePointer = 11
               
        DebugPrint tdebug, "CheckInBinary-Start"
        With Doc
            .Type = adTypeBinary
            .Open
            .LoadFromFile fname
        End With
        rs.Fields(fieldname).value = Doc.Read
        If fieldFilenameExtension <> "" Then
          rs.Fields(fieldFilenameExtension).value = Left(GetFileExtension(fname), rs.Fields(fieldFilenameExtension).DefinedSize)
        End If
        
        DebugPrint tdebug, "CheckInBinary-Eingef|fffd|gt"
        'Screen.MousePointer = SavedPointer
        CheckInBinary = True
        DebugPrint tdebug, "CheckInBinary-Ende"
        
        Exit Function

fehler:
        errstr = err.Number & " - " & err.Description & " - " & err.Source
        DebugPrint tERROR, "CheckInBinary: " & err.Number & " - " & err.Description & " - " & err.Source & " - Datei: " & fname
'        If Err.Number = 32755 Then Exit Function
    End Function

    Public Function LastInsertedIDForName(ByRef cn As Object, ByVal fname As String) As Long
    
        LastInsertedIDForName = -1
        
        Dim rs As Object
        
        If G_DBType = G_Oracle Then
          Set rs = OpenRS("SELECT Dateiname, xlBinTrackerID FROM xlBinTracker ORDER BY xlBinTrackerID desc", cn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
        Else
          Set rs = OpenRS("SELECT TOP 20 Dateiname, xlBinTrackerID FROM xlBinTracker ORDER BY xlBinTrackerID desc", cn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
        End If
        If Not rs Is Nothing Then
          Do While Not rs.EOF
            If GetSafeFieldPlus(rs, "Dateiname", "") = fname Then
              LastInsertedIDForName = GetSafeFieldPlus(rs, "xlBinTrackerID", -1)
              Exit Do
            End If
            rs.MoveNext
          Loop
          rs.Close
          Set rs = Nothing
        End If
        
        Exit Function
        
         Dim objCmd As Object ' New ADODB.Command
         Dim objParm1 As Object ' New ADODB.Parameter
         Dim objRs As Object  ' new ADODB.Recordset
         
         On Error GoTo cleanup
         
         Set objCmd = CreateObject("ADODB.Command")
         Set objParm1 = CreateObject("ADODB.Parameter")
         Set objRs = CreateObject("ADODB.Recordset")
         
         ' Oracle
         If G_DBType = 5 Then
           objCmd.CommandText = "SELECT Dateiname, xlBinTrackerID FROM xlBinTracker WHERE Dateiname like '" & Replace(fname, "\", "_") & "'  ORDER BY xlBinTrackerID desc"
           objCmd.CommandType = adCmdText
  
           ' Prepare command because we will be executing it more than once.
           objCmd.Prepared = True
         Else

           ' Set the CommandText as a parameterized SQL query.
           objCmd.CommandText = "SELECT Dateiname, xlBinTrackerID FROM xlBinTracker WHERE Dateiname like ? ORDER BY xlBinTrackerID desc"
           objCmd.CommandType = adCmdText
  
           ' Prepare command because we will be executing it more than once.
           objCmd.Prepared = True
  
           ' Create new parameter
           Set objParm1 = objCmd.CreateParameter("CustId", adChar, adParamInput, Len(fname), fname)
           objCmd.Parameters.Append objParm1

         End If

         ' Connect to the data source.
         Set objCmd.ActiveConnection = cn
         
         ' Execute once and display.
         Set objRs = objCmd.Execute

         If objRs.EOF = False Then
             LastInsertedIDForName = objRs(1)
         End If
    
        If Not objRs Is Nothing Then
          objRs.Close
        End If
cleanup:
         Set objRs = Nothing
         Set objCmd = Nothing
         Set objParm1 = Nothing
    End Function


    Public Function xlCheckInAdditionalFiles(ByVal fname As String) As Long
        On Error GoTo fehler
        Dim cn As Object

        Set cn = GetConnection()

        If cn Is Nothing Then Exit Function

        Dim rs As Object
        If G_DBType <> G_SQL_Server Then
            Set rs = OpenRS("SELECT * FROM xlBinTracker WHERE xlBinTrackerID = -1", cn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockOptimistic)
            
            If rs Is Nothing Then
              cn.Close
              Set cn = Nothing
              xlCheckInAdditionalFiles = -1
              Exit Function
            End If
        End If
        
        ' fname = Replace(fname, "'", "?")
        Dim zippedFilename As String
        zippedFilename = PackFile(fname, True)
        If zippedFilename <> "" Then
       
            Dim splitFilenames() As String
            Dim step As Long
            If (SplitFile(zippedFilename, GetSplitSize(), splitFilenames)) Then
            Else
                ReDim splitFilenames(0)
                splitFilenames(0) = zippedFilename
            End If
            
            xlCheckInAdditionalFiles = -1
            For step = LBound(splitFilenames) To UBound(splitFilenames)
    
                Dim errstr As String
                If G_DBType = G_SQL_Server Then
                    If Not CheckInBinaryAdditionalFilesSQLServer(cn, splitFilenames(step), fname, step, zippedFilename, errstr) Then
                      DebugPrint tdebug, "xlCheckInAdditionalFiles-Datei NICHT eingef|fffd|gt"
                      xlCheckInAdditionalFiles = 0
                      Exit For
                    Else
                      xlCheckInAdditionalFiles = True
                    End If
                Else
                    rs.AddNew
                    rs.Fields("Dateiname").value = fname
                    rs.Fields("Laenge").value = MyFileLen(fname)
                    rs.Fields("Compressed").value = IIf(Right(zippedFilename, 3) = ".gz", 1, 0)
                    rs.Fields("Step") = step
            
                    If Not CheckInBinary("Daten", rs, splitFilenames(step), errstr) Then
                      DebugPrint tdebug, "xlCheckInAdditionalFiles-Datei NICHT eingef|fffd|gt"
                      rs.CancelUpdate
                      xlCheckInAdditionalFiles = 0
                      Exit For
                    Else
                      rs.Update
                    End If
                End If
            Next
            If G_DBType <> G_SQL_Server Then
              rs.Close
              Set rs = Nothing
            End If
            
            If xlCheckInAdditionalFiles = -1 Then
                xlCheckInAdditionalFiles = LastInsertedIDForName(cn, fname)
            End If
        Else
            If G_DBType <> G_SQL_Server Then
              rs.Close
              Set rs = Nothing
            End If
            xlCheckInAdditionalFiles = -1
        End If
    
        cn.Close
        Set cn = Nothing
        
        If zippedFilename <> fname Then
            MyKill zippedFilename
        End If
        For step = LBound(splitFilenames) To UBound(splitFilenames)
            If splitFilenames(step) <> fname Then
                MyKill splitFilenames(step)
            End If
        Next
        Exit Function
fehler:
        DebugPrint tERROR, "xlCheckAdditionalFiles: " & err.Number & " - " & err.Description & " - " & err.Source
        On Error Resume Next
        
        If Not rs Is Nothing Then
          If rs.state <> 0 Then
'            rs.Close
          End If
          Set rs = Nothing
        End If
        If Not cn Is Nothing Then
          cn.Close
          Set cn = Nothing
        End If
        xlCheckInAdditionalFiles = -1
End Function

Function xlCheckOutBinary(ByRef cn As Object, id As Long, Ver As Long, ByRef fname As String, addVersionAndFiledate As Boolean, Optional mmver As String = "") As Boolean

    If id <= 0 Or Ver <= 0 Then
        Exit Function
    End If
    
    Dim connPassed As Boolean
    
    Dim conn As Object
    If cn Is Nothing Then
      connPassed = False
      Set conn = GetConnection()
    Else
      connPassed = True
      Set conn = cn
    End If
    
    Dim rs As Object
    Set rs = Nothing

    On Error GoTo fehler
    Set rs = OpenRS("Select Datum, Binary, Compressed, Step from A_XLBINTMEINEOES where idvDateiID=" & id & " AND Version=" & Ver & " order by Step", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
    If rs Is Nothing Then
      'MsgBox "Die Datei kann nicht ausgecheckt werden, bitte versuchen Sie es sp|fffd|ter noch einmal!", vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
      MsgBox FMT0("BLOBSTUFF_2"), vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
      If Not connPassed Then
        conn.Close
      End If
      Set conn = Nothing
      Exit Function
    End If
    
    If rs.EOF = True Then
      MsgBox FMT0("BLOBSTUFF_5"), vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
      GoTo endOfFunc
    End If
    
    Dim ext As String
    ext = ""
    
    If addVersionAndFiledate Then
        ' GetPath(fname)
      fname = G_cfgTemppfad & "\" & DateinameMitVersionsnummer(fname, IIf(mmver = "", CStr(Ver), mmver), True, rs.Fields("Datum").value)
    End If
    ' fname = G_cfgTemppfad & "/tmp" & rs!xlBinTrackerID & "_" & GetFileNameAndExtension(rs.fields("fname").value)
    
    MyKill fname
    If FileExists(fname) Then
      'MsgBox "Die Datei '" & fname & "' kann nicht gel|fffd|scht werden, der Vorgang wird abgebrochen!", vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
      MsgBox FMT1("BLOBSTUFF_3", fname), vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
      If Not connPassed Then
        conn.Close
      End If
      Set conn = Nothing
      Exit Function
    End If
    
    
    ' ext bestimmt im weitere Verlauf, ob die Datei gepackt war
    If IsNull(rs.Fields("Compressed").value) Then
        ext = ""
    ElseIf rs.Fields("Compressed").value = 0 Then
    Else
        ext = ".gz"
    End If
       
    Dim Doc As Object

    On Error GoTo fehlerDoc
    Dim splitFilenames() As String
    ReDim splitFilenames(rs.RecordCount - 1)
    Dim step As Long
    step = 0
    
    While rs.EOF = False
        ' bei nur einem Recordset direkt in die richtige Datei schreiben, dann sparen wir uns einen Kopiervorgang
        If rs.RecordCount = 1 Then
            splitFilenames(step) = fname + ext
        Else
            splitFilenames(step) = fname + "_" & GetSafeFieldPlus(rs, "Step", 0)
        End If
        
        Set Doc = CreateObject("ADODB.Stream")
        With Doc
           .Type = adTypeBinary
           .Open
           .Write rs!Binary
           .SaveToFile splitFilenames(step), adSaveCreateOverWrite
        End With
        Doc.Close
        Set Doc = Nothing
        
        rs.MoveNext
        step = step + 1
    Wend
    
    If UBound(splitFilenames) - LBound(splitFilenames) > 0 Then
        JoinFile fname + ext, splitFilenames
    End If
    
    If ext = ".gz" Then
        UnpackFile fname + ext
        MyKill fname + ext
    End If
    If UBound(splitFilenames) - LBound(splitFilenames) > 0 Then
        For step = LBound(splitFilenames) To UBound(splitFilenames)
            MyKill splitFilenames(step)
        Next
    End If

    xlCheckOutBinary = True
    
endOfFunc:

    If Not rs Is Nothing Then
        rs.Close
        Set rs = Nothing
    End If
    If Not connPassed Then
      conn.Close
    End If
    Set conn = Nothing
    
    Exit Function

fehlerDoc:
    If Not Doc Is Nothing Then
        'MsgBox "Die Datei konnte nicht gespeichert werden! (" & err.Description & ")", vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        MsgBox FMT1("BLOBSTUFF_4", err.Description), vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        Doc.Close
        Set Doc = Nothing
    End If
    GoTo endOfFunc
    
    
fehler:
    MsgBox FMT1("BLOBSTUFF_6", err.Description), vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
    
    GoTo endOfFunc
    
End Function

    Public Function xlCheckOutBinaryRecordset(ByRef cn As Object, ByRef rs As Object, ByVal fname As String) As Boolean
        
        xlCheckOutBinaryRecordset = False
        Dim ext As String
        ' ext bestimmt im weitere Verlauf, ob die Datei gepackt war
        If IsNull(rs.Fields("Compressed").value) Then
            ext = ""
        ElseIf rs.Fields("Compressed").value = 0 Then
        Else
            ext = ".gz"
        End If
           
        Dim Doc As Object
    
        On Error GoTo fehlerDoc
        Dim splitFilenames() As String
        ReDim splitFilenames(rs.RecordCount - 1)
        Dim step As Long
        step = 0
        
        While rs.EOF = False
            ' bei nur einem Recordset direkt in die richtige Datei schreiben, dann sparen wir uns einen Kopiervorgang
            If rs.RecordCount = 1 Then
                splitFilenames(step) = fname + ext
            Else
                splitFilenames(step) = fname + "_" & GetSafeFieldPlus(rs, "Step", 0)
            End If
            
            Set Doc = CreateObject("ADODB.Stream")
            With Doc
               .Type = adTypeBinary
               .Open
               .Write rs!Binary
               .SaveToFile splitFilenames(step), adSaveCreateOverWrite
            End With
            Doc.Close
            Set Doc = Nothing
            
            rs.MoveNext
            step = step + 1
        Wend
        
        If UBound(splitFilenames) - LBound(splitFilenames) > 0 Then
            JoinFile fname + ext, splitFilenames
        End If
        
        If ext = ".gz" Then
            UnpackFile fname + ext
            MyKill fname + ext
        End If
    
        xlCheckOutBinaryRecordset = True
    
fehlerDoc:
        If UBound(splitFilenames) - LBound(splitFilenames) > 0 Then
            For step = LBound(splitFilenames) To UBound(splitFilenames)
                MyKill splitFilenames(step)
            Next
        End If
    
    End Function



    Public Function xlCheckInSignOff(ByVal idvDateiID As Long, ByVal Version As Long, ByVal laufendeNr As Long, ByVal dat As Date, ByVal userLogonId As String, ByVal fname As String, ByRef errstr As String, ByVal kommentar As String) As Boolean
        On Error GoTo fehler
        Dim cn As Object

        Set cn = GetConnection()

        If cn Is Nothing Then Exit Function

        Dim rs As Object
        ' id anstatt idvDateiID, damit wir |fffd|ber eine indizierte Spalte lesen
        If G_DBType <> G_SQL_Server Then
          Set rs = OpenRS("SELECT * FROM A_XLBINSIGNOFFINSERT", cn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockOptimistic)
          If rs Is Nothing Then
            cn.Close
            Set cn = Nothing
            xlCheckInSignOff = False
            Exit Function
          End If
        End If
        
        Dim dateiendung As String
        dateiendung = GetFileExtension(fname)
        
        Dim zippedFilename As String
        zippedFilename = PackFile(fname, True)
        
        Dim splitFilenames() As String
        Dim step As Long
        If (SplitFile(zippedFilename, GetSplitSize(), splitFilenames)) Then
        Else
            ReDim splitFilenames(0)
            splitFilenames(0) = zippedFilename
        End If
        
        For step = LBound(splitFilenames) To UBound(splitFilenames)
        
            DebugPrint tdebug, "xlCheckInSignOff-Einf|fffd|gen (ID " & idvDateiID & "  V" & Version & "): " & fname
            If G_DBType = G_SQL_Server Then
                If Not CheckInBinarySignOffSQLServer(cn, splitFilenames(step), idvDateiID, laufendeNr, dat, userLogonId, dateiendung, step, zippedFilename, errstr, kommentar) Then
                  DebugPrint tdebug, "xlCheckInSignOff-Datei NICHT eingef|fffd|gt"
                  xlCheckInSignOff = False
                  Exit For
                Else
                  xlCheckInSignOff = True
                End If
            Else
                rs.AddNew
                rs.Fields("idvDateiID").value = idvDateiID
                rs.Fields("Nr").value = laufendeNr
                rs.Fields("Version").value = Version
                rs.Fields("Datum").value = dat
                rs.Fields("UserLogonID").value = Left(UCase(userLogonId), 24)
                rs.Fields("Dateiendung").value = Left(dateiendung, 10)
                rs.Fields("Compressed").value = IIf(Right(zippedFilename, 3) = ".gz", 1, 0)
                rs.Fields("Step") = step
                If step = LBound(splitFilenames) Then
                    rs.Fields("Kommentar").value = kommentar
                Else
                    rs.Fields("Kommentar").value = ""
                End If

                If Not CheckInBinary("Binary", rs, splitFilenames(step), errstr) Then
                  DebugPrint tdebug, "xlCheckInSignOff-Datei NICHT eingef|fffd|gt"
                  rs.CancelUpdate
                  xlCheckInSignOff = False
                  Exit For
                Else
                  DebugPrint tdebug, "xlCheckInSignOff-Datei eingef|fffd|gt"
                  rs.Update
                  DebugPrint tdebug, "xlCheckInSignOff-Datensatz gespeichert"
                  xlCheckInSignOff = True
                End If
            End If
        Next
        If G_DBType <> G_SQL_Server Then
          rs.Close
          Set rs = Nothing
        End If
        
        cn.Close
        Set cn = Nothing
        DebugPrint tdebug, "xlCheckInSignOff-ENDE"
        
        On Error GoTo exitohnefehler
        If zippedFilename <> fname Then
            MyKill zippedFilename
        End If
        If UBound(splitFilenames) - LBound(splitFilenames) > 0 Then
            For step = LBound(splitFilenames) To UBound(splitFilenames)
                If splitFilenames(step) <> fname Then
                    MyKill splitFilenames(step)
                End If
            Next
        End If
exitohnefehler:
        Exit Function
fehler:
'        If Not rs Is Nothing Then
'          rs.Close
          Set rs = Nothing
'        End If
        If Not cn Is Nothing Then
          cn.Close
          Set cn = Nothing
        End If
        xlCheckInSignOff = False
        errstr = err.Number & " - " & err.Description & " - " & err.Source
        DebugPrint tERROR, "xlCheckInBinary: " & err.Number & " - " & err.Description & " - " & err.Source & " - Datei: " & fname
    End Function

    Public Function xlCheckInLogFiles(ByVal fname As String, ByVal idvDateiID As Long, ByRef conn As Object) As Long
        On Error GoTo fehler

        Dim rs As Object
        If G_DBType <> G_SQL_Server Then
          Set rs = OpenRS("SELECT * FROM A_XLBINLOGINSERT", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockOptimistic)
          If rs Is Nothing Then
            xlCheckInLogFiles = -1
            Exit Function
          End If
        End If
        
        fname = Replace(fname, "'", "?")
        Dim zippedFilename As String
        zippedFilename = PackFile(fname, True)
               
        Dim splitFilenames() As String
        Dim step As Long
        If (SplitFile(zippedFilename, GetSplitSize(), splitFilenames)) Then
        Else
            ReDim splitFilenames(0)
            splitFilenames(0) = zippedFilename
        End If
        
        Dim checkinTime As Date
        checkinTime = Now
        
        xlCheckInLogFiles = -1
        For step = LBound(splitFilenames) To UBound(splitFilenames)
            Dim errstr As String
            If G_DBType = G_SQL_Server Then
                If Not CheckInBinaryLogFilesSQLServer(conn, splitFilenames(step), fname, idvDateiID, checkinTime, GetUserNameUCASE, step, zippedFilename, errstr) Then
                  DebugPrint tdebug, "xlCheckInLogFiles-Datei NICHT eingef|fffd|gt"
                  xlCheckInLogFiles = False
                  Exit For
                Else
                  xlCheckInLogFiles = True
                End If
            Else
                rs.AddNew
                rs.Fields("idvDateiID").value = idvDateiID
                rs.Fields("Laenge").value = MyFileLen(fname)
                rs.Fields("Compressed").value = IIf(Right(zippedFilename, 3) = ".gz", 1, 0)
                rs.Fields("Datum").value = checkinTime
                rs.Fields("LogonID").value = Left(GetUserNameUCASE, 24)
                rs.Fields("Step").value = step
        
                If Not CheckInBinary("Daten", rs, splitFilenames(step), errstr) Then
                  DebugPrint tdebug, "xlCheckInLogFiles-Datei NICHT eingef|fffd|gt"
                  rs.CancelUpdate
                  xlCheckInLogFiles = 0
                  Exit For
                Else
                  rs.Update
                End If
            End If
        Next
        If G_DBType <> G_SQL_Server Then
          rs.Close
        End If
        If xlCheckInLogFiles = -1 Then
            Set rs = OpenRS("SELECT xlBinTrackerLogID FROM xlBinTrackerLog WHERE idvDateiID = '" & idvDateiID & "' order by xlBinTrackerLogID", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockOptimistic)
            If Not rs.EOF Then
              rs.MoveLast
              xlCheckInLogFiles = rs!xlBinTrackerLogID
            End If
            rs.Close
        End If
        Set rs = Nothing
        
        If zippedFilename <> fname Then
            MyKill zippedFilename
        End If
        If UBound(splitFilenames) - LBound(splitFilenames) > 0 Then
            For step = LBound(splitFilenames) To UBound(splitFilenames)
                If splitFilenames(step) <> fname Then
                    MyKill splitFilenames(step)
                End If
            Next
        End If
        Exit Function
fehler:
        DebugPrint tERROR, "xlCheckInLogFiles: " & err.Number & " - " & err.Description & " - " & err.Source
        On Error Resume Next
        
        If Not rs Is Nothing Then
          If rs.state <> 0 Then
'            rs.Close
          End If
          Set rs = Nothing
        End If
        xlCheckInLogFiles = -1
    End Function



' Rolf XLAM
Function Verify(ByVal filename As String, ByVal xlBinTrackerID As Integer) As Boolean
      
    Verify = False

    Dim conn As Object
    Set conn = GetConnection()
    If conn Is Nothing Then
        Verify = True
        Exit Function
    End If
    
    Dim rs As Object
    Set rs = Nothing

    On Error GoTo ErrorVerify
    Set rs = OpenRS("Select Daten, Compressed from xlBinTracker where xlBinTrackerID =" & xlBinTrackerID, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
    If rs Is Nothing Then
      conn.Close
      Set conn = Nothing
      Exit Function
    End If
    
    Dim ext As String
    ext = ""

On Error GoTo ErrorVerify

    Dim tmpFname As String
    tmpFname = GetStorePath(PathType.tTemp) + "tmpVerify"
    
    ' ext bestimmt im weitere Verlauf, ob die Datei gepackt war
    If IsNull(rs.Fields("Compressed").value) Then
        ext = ""
    ElseIf rs.Fields("Compressed").value = 0 Then
    Else
        ext = ".gz"
    End If
       
    Dim Doc As Object

    ' Datei holen als TempDatei
    On Error GoTo ErrorVerify
    Set Doc = CreateObject("ADODB.Stream")
    With Doc
       .Type = adTypeBinary
       .Open
       .Write rs!Daten
       .SaveToFile tmpFname + ext, adSaveCreateOverWrite
    End With
    Doc.Close
    Set Doc = Nothing
    
    If ext = ".gz" Then
        UnpackFile tmpFname + ext
        MyKill tmpFname + ext
    End If
    
    Verify = AreFilesTheSame(filename, tmpFname)
    MyKill tmpFname

ErrorVerify:
    If Not rs Is Nothing Then
        rs.Close
    End If
    Set rs = Nothing
    conn.Close
    Set conn = Nothing
    

    Exit Function
End Function

Private Function CheckInBinarySQLServer(ByRef conn As Object, ByVal datafile As String, ByVal idvDateiID As Long, ByVal Version As Long, ByVal dat As Date, ByVal step As Long, ByVal zippedFilename As String, ByRef fehler As String) As Boolean

On Error GoTo nogo
   Dim adoStream               As Object
   Dim adoCmd                  As Object
    
   Set adoStream = CreateObject("ADODB.Stream")
   Set adoCmd = CreateObject("ADODB.Command")
    
   adoStream.Type = 1 ' adTypeBinary
   adoStream.Open
   adoStream.LoadFromFile datafile 'It fails if file is open
        
   With adoCmd
        .CommandText = "INSERT INTO A_XLBININSERT (idvDateiID,Version,Datum,Compressed,Binary,Step) VALUES (?,?,?,?,?,?)" ' Query
        .CommandType = 1 ' adCmdText
        
        '---adding parameters
        ' 1 adParamInput
        
        ' 3 adInteger
        ' 20 adBigInt
        ' 7 adDate
        ' 2 adSmallInt
        ' 204 adVarBinary
        ' 205 adLongVarBinary
        ' 135 adDBTimeStamp A date/time stamp (yyyymmddhhmmss plus a fraction in billionths).
        
        .Parameters.Append .CreateParameter("@idvDateiID", 20, 1, 0, idvDateiID)
        .Parameters.Append .CreateParameter("@Version", 20, 1, 0, Version)
        .Parameters.Append .CreateParameter("@Datum", 135, 1, , CDate(dat))
        .Parameters.Append .CreateParameter("@Compressed", 3, 1, 0, IIf(Right(zippedFilename, 3) = ".gz", 1, 0))
        .Parameters.Append .CreateParameter("@Binary", 205, 1, adoStream.Size, adoStream.Read)
        .Parameters.Append .CreateParameter("@Step", 20, 1, 0, step)

        '---
   End With
    
   adoCmd.ActiveConnection = conn
   adoCmd.Execute
   CheckInBinarySQLServer = True
    
   ' hinter dem = true setzen, da das Schreiben in die DB ja geklappt hat,
   ' falls das hier jetzt schief geht, sollte das egal sein
   ' vielleicht sollte man ein resume next machen
   adoStream.Close
   Set adoStream = Nothing
   Exit Function
nogo:
   fehler = fehler & IIf(fehler <> "", vbCrLf, "") & "CheckInBinarySQLServer: " & err.Number & " - " & err.Description
End Function


Private Function CheckInBinaryAdditionalFilesSQLServer(ByRef conn As Object, ByVal datafile As String, ByVal fname As String, ByVal step As Long, ByVal zippedFilename As String, ByRef fehler As String) As Boolean

On Error GoTo nogo
   Dim adoStream               As Object
   Dim adoCmd                  As Object
    
   Set adoStream = CreateObject("ADODB.Stream")
   Set adoCmd = CreateObject("ADODB.Command")
    
   adoStream.Type = 1 ' adTypeBinary
   adoStream.Open
   adoStream.LoadFromFile datafile 'It fails if file is open
        
   With adoCmd
        .CommandText = "INSERT INTO xlBinTracker (Dateiname,Laenge,Compressed,Daten,Step) VALUES (?,?,?,?,?)" ' Query
        .CommandType = 1 ' adCmdText
        
        '---adding parameters
        ' 1 adParamInput
        
        ' 3 adInteger
        ' 20 adBigInt
        ' 7 adDate
        ' 2 adSmallInt
        ' 129 adChar
        ' 202 adVarWChar
        ' 204 adVarBinary
        ' 205 adLongVarBinary
        ' 135 adDBTimeStamp A date/time stamp (yyyymmddhhmmss plus a fraction in billionths).
        
        .Parameters.Append .CreateParameter("@Dateiname", 202, 1, Len(fname), fname)
        .Parameters.Append .CreateParameter("@Laenge", 20, 1, 0, MyFileLen(fname))
        .Parameters.Append .CreateParameter("@Compressed", 3, 1, 0, IIf(Right(zippedFilename, 3) = ".gz", 1, 0))
        .Parameters.Append .CreateParameter("@Daten", 205, 1, adoStream.Size, adoStream.Read)
        .Parameters.Append .CreateParameter("@Step", 20, 1, 0, step)

        '---
   End With
    
   adoCmd.ActiveConnection = conn
   adoCmd.Execute
   CheckInBinaryAdditionalFilesSQLServer = True
    
   ' hinter dem = true setzen, da das Schreiben in die DB ja geklappt hat,
   ' falls das hier jetzt schief geht, sollte das egal sein
   ' vielleicht sollte man ein resume next machen
   adoStream.Close
   Set adoStream = Nothing
   Exit Function
nogo:
   fehler = fehler & IIf(fehler <> "", vbCrLf, "") & "CheckInBinaryAdditionalFilesSQLServer: " & err.Number & " - " & err.Description
End Function


Private Function CheckInBinarySignOffSQLServer(ByRef conn As Object, ByVal datafile As String, ByVal idvDateiID As Long, ByVal laufendeNr As Long, ByVal dat As Date, ByVal userLogonId As String, ByVal dateiendung As String, ByVal step As Long, ByVal zippedFilename As String, ByRef fehler As String, ByVal kommentar As String) As Boolean

On Error GoTo nogo
   Dim adoStream               As Object
   Dim adoCmd                  As Object
    
   Set adoStream = CreateObject("ADODB.Stream")
   Set adoCmd = CreateObject("ADODB.Command")
    
   adoStream.Type = 1 ' adTypeBinary
   adoStream.Open
   adoStream.LoadFromFile datafile 'It fails if file is open
        
   With adoCmd
        .CommandText = "INSERT INTO xlBinSignOff (idvDateiID,Nr,Datum,UserLogonID,Dateiendung,Compressed,Binary,Step,Kommentar) VALUES (?,?,?,?,?,?,?,?,?)" ' Query
        .CommandType = 1 ' adCmdText
        
        '---adding parameters
        ' 1 adParamInput
        
        ' 3 adInteger
        ' 20 adBigInt
        ' 7 adDate
        ' 2 adSmallInt
        ' 204 adVarBinary
        ' 205 adLongVarBinary
        ' 135 adDBTimeStamp A date/time stamp (yyyymmddhhmmss plus a fraction in billionths).
        
        If kommentar = "" Then kommentar = " "

        .Parameters.Append .CreateParameter("@idvDateiID", 20, 1, 0, idvDateiID)
        .Parameters.Append .CreateParameter("@Nr", 20, 1, 0, laufendeNr)
        .Parameters.Append .CreateParameter("@Datum", 135, 1, , CDate(dat))
        .Parameters.Append .CreateParameter("@UserLogonID", 202, 1, Len(Left(userLogonId, 24)), Left(UCase(userLogonId), 24))
        .Parameters.Append .CreateParameter("@Dateiendung", 202, 1, Len(Left(dateiendung, 10)), Left(dateiendung, 10))
        .Parameters.Append .CreateParameter("@Compressed", 3, 1, 0, IIf(Right(zippedFilename, 3) = ".gz", 1, 0))
        .Parameters.Append .CreateParameter("@Binary", 205, 1, adoStream.Size, adoStream.Read)
        .Parameters.Append .CreateParameter("@Step", 20, 1, 0, step)
        .Parameters.Append .CreateParameter("@Comment", 202, 1, Len(Left(kommentar, 255)), Left(kommentar, 255))
        

        '---
   End With
    
   adoCmd.ActiveConnection = conn
   adoCmd.Execute
   CheckInBinarySignOffSQLServer = True
    
   ' hinter dem = true setzen, da das Schreiben in die DB ja geklappt hat,
   ' falls das hier jetzt schief geht, sollte das egal sein
   ' vielleicht sollte man ein resume next machen
   adoStream.Close
   Set adoStream = Nothing
   Exit Function
nogo:
   fehler = fehler & IIf(fehler <> "", vbCrLf, "") & "CheckInBinarySignOffSQLServer: " & err.Number & " - " & err.Description
End Function


Private Function CheckInBinaryLogFilesSQLServer(ByRef conn As Object, ByVal datafile As String, ByVal fname As String, ByVal idvDateiID As Long, ByVal dat As Date, ByVal userLogonId As String, ByVal step As Long, ByVal zippedFilename As String, ByRef fehler As String) As Boolean

On Error GoTo nogo
   Dim adoStream               As Object
   Dim adoCmd                  As Object
    
   Set adoStream = CreateObject("ADODB.Stream")
   Set adoCmd = CreateObject("ADODB.Command")
    
   adoStream.Type = 1 ' adTypeBinary
   adoStream.Open
   adoStream.LoadFromFile datafile 'It fails if file is open
        
   With adoCmd
        .CommandText = "INSERT INTO xlBinTrackerLog (idvDateiID,Laenge,Compressed,Datum,LogonID,Daten,Step) VALUES (?,?,?,?,?,?,?)" ' Query
        .CommandType = 1 ' adCmdText
        
        '---adding parameters
        ' 1 adParamInput
        
        ' 3 adInteger
        ' 20 adBigInt
        ' 7 adDate
        ' 2 adSmallInt
        ' 204 adVarBinary
        ' 205 adLongVarBinary
        ' 135 adDBTimeStamp A date/time stamp (yyyymmddhhmmss plus a fraction in billionths).
        
        .Parameters.Append .CreateParameter("@idvDateiID", 20, 1, 0, idvDateiID)
        .Parameters.Append .CreateParameter("@Laenge", 20, 1, 0, MyFileLen(fname))
        .Parameters.Append .CreateParameter("@Compressed", 3, 1, 0, IIf(Right(zippedFilename, 3) = ".gz", 1, 0))
        .Parameters.Append .CreateParameter("@Datum", 135, 1, , CDate(dat))
        .Parameters.Append .CreateParameter("@LogonID", 202, 1, Len(Left(userLogonId, 24)), Left(UCase(userLogonId), 24))
        .Parameters.Append .CreateParameter("@Daten", 205, 1, adoStream.Size, adoStream.Read)
        .Parameters.Append .CreateParameter("@Step", 20, 1, 0, step)

        '---
   End With
    
   adoCmd.ActiveConnection = conn
   adoCmd.Execute
   CheckInBinaryLogFilesSQLServer = True
    
   ' hinter dem = true setzen, da das Schreiben in die DB ja geklappt hat,
   ' falls das hier jetzt schief geht, sollte das egal sein
   ' vielleicht sollte man ein resume next machen
   adoStream.Close
   Set adoStream = Nothing
   Exit Function
nogo:
   fehler = fehler & IIf(fehler <> "", vbCrLf, "") & "CheckInBinaryLogFilesSQLServer: " & err.Number & " - " & err.Description
End Function

Attribute VB_Name = "CAntwort"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Public m_AntwortID As Long
Public m_Wert As Double
Public m_Absolut As Boolean
                                   

' Neu 1.2017
Public m_FrageID As Long
Public m_AntwortText As String
Public m_Sprung As Long
Public m_Position As Long
Public m_TextID As Long

Private m_AntwortFunk(3) As Long
Public m_KommentarTyp As Long


Public Property Get AntwortFunk(idx As Long) As Long
    AntwortFunk = m_AntwortFunk(idx)
End Property


Public Sub InitFromAntwortRecord(ByRef antwortrs As Object)
    m_FrageID = GetSafeFieldPlus(antwortrs, "FrageID", 0)
    m_AntwortID = GetSafeFieldPlus(antwortrs, "FrageAntwortID", 0)
    ' Der lokalisierte Antworttext ist im Field LocAntwort
    m_AntwortText = GetLocValueFromField(antwortrs, "Antwort", "LocAntwort", "")
    m_Wert = GetSafeFieldPlus(antwortrs, "Wert", 0#)
    m_Sprung = GetSafeFieldPlus(antwortrs, "Sprung", 0)
    m_Position = GetSafeFieldPlus(antwortrs, "Position", 0)
    m_Absolut = GetSafeFieldPlus(antwortrs, "AbsoluterWert", False)
    m_AntwortFunk(0) = GetSafeFieldPlus(antwortrs, "AntwortFunktion", 0)
    m_AntwortFunk(1) = GetSafeFieldPlus(antwortrs, "AntwortFunktion2", 0)
    m_AntwortFunk(2) = GetSafeFieldPlus(antwortrs, "AntwortFunktion3", 0)
    m_KommentarTyp = GetSafeFieldPlus(antwortrs, "KommentarTyp", 0)
End Sub

Attribute VB_Name = "CBefragung"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit


' Alle benoetigten Daten waehrend einer Befragung

Private m_DateiID As Long

Private m_FragenDlgCol As New Collection

Private m_FragenCache() As CFragenData
Private m_AntwortenCache() As CAntwort

' Die Schutzbedarfswerte die sich aus der Prozessauswahl ergeben haben
Private m_ProzessauswahlValues As New CFragenSchutzbedarf
' Die Schutzbedarfswerte der letzten Befragung (wenn es schon eine gab) - wird fuer die Vorauswahl benoetigt
Private m_PreviousFragenValues As New CFragenSchutzbedarf

Private m_PreviousAntwortIDs(15) As Long
Private m_NewAntwortIDs(15) As Long


' Die vom User eingegebenen Kommentare zur letzten Befragung
Private m_PreviousComments As New Collection
' Die vom User eingegebenen Kommentare der aktuellen Befragung
Private m_NewComments As New Collection

Public Property Get PreviousFragenValues() As CFragenSchutzbedarf
    Set PreviousFragenValues = m_PreviousFragenValues
End Property

Public Property Get ProzessauswahlValues() As CFragenSchutzbedarf
    Set ProzessauswahlValues = m_ProzessauswahlValues
End Property

Public Property Let ProzessauswahlValues(schutzbed As CFragenSchutzbedarf)
    Set m_ProzessauswahlValues = schutzbed
End Property

Public Property Get NewComments() As Collection
    Set NewComments = m_NewComments
End Property

Public Property Get FragenDlgCol() As Collection
    Set FragenDlgCol = m_FragenDlgCol
End Property

Private Sub Class_Terminate()
    Set m_FragenDlgCol = Nothing
    Set m_ProzessauswahlValues = Nothing
    Set m_PreviousFragenValues = Nothing
    Set m_PreviousComments = Nothing
    Set m_NewComments = Nothing
End Sub

Public Sub Init(ByRef dateiRS As Object, ByRef fragenrs As Object, ByRef conn As Object)
    If conn Is Nothing Or dateiRS Is Nothing Or fragenrs Is Nothing Then Exit Sub
    
    m_DateiID = GetSafeFieldPlus(dateiRS, "idvDateiID", 0)
    
    Dim i As Long
    
    ' Einmal alle Antworten holen und hier zusammen mit den Fragen und weiteren Befragungsdaten cachen
    Dim antwortenrs As Object
    Set antwortenrs = CreateObject("ADODB.Recordset")
    antwortenrs.Open "SELECT gFA.*, ua.LokalisierterText AS LocAntwort FROM gFragenAntworten gFA " & _
        "LEFT JOIN gTexteUebersetzungen ua ON (gFA.TextID = ua.TextID and ua.LanguageID = " & GetMyDBLanguage(conn) & ") ORDER BY Position", _
        conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly

    If Not antwortenrs Is Nothing Then
        ReDim m_AntwortenCache(antwortenrs.RecordCount)
        i = 0
        Do While Not antwortenrs.EOF
            Set m_AntwortenCache(i) = New CAntwort
            Call m_AntwortenCache(i).InitFromAntwortRecord(antwortenrs)
            i = i + 1
            antwortenrs.MoveNext
        Loop
        antwortenrs.Close
        Set antwortenrs = Nothing
    End If
    
    If Not fragenrs Is Nothing Then
        ReDim m_FragenCache(fragenrs.RecordCount)
        i = 0
        Do While Not fragenrs.EOF
            Set m_FragenCache(i) = New CFragenData
            Call m_FragenCache(i).InitFromRecord(fragenrs, m_AntwortenCache)
            i = i + 1
            fragenrs.MoveNext
        Loop
        fragenrs.MoveFirst
    End If


    For i = 0 To UBound(m_PreviousAntwortIDs)
        m_PreviousAntwortIDs(i) = 0
    Next i
    
    Dim letzteBefragung As Date
    letzteBefragung = GetSafeFieldPlus(dateiRS, "LetzteBefragung", #1/1/1900#)
    
    If letzteBefragung > #1/1/1900# Then
        ' Wenn die Datei schon einmal befragt wurde, die letzten Antworten checken und die Schutzbedarfswerte ermitteln
        m_PreviousAntwortIDs(0) = GetSafeFieldPlus(dateiRS, "AntwortID1", 0)
        m_PreviousAntwortIDs(1) = GetSafeFieldPlus(dateiRS, "AntwortID2", 0)
        m_PreviousAntwortIDs(2) = GetSafeFieldPlus(dateiRS, "AntwortID3", 0)
        m_PreviousAntwortIDs(3) = GetSafeFieldPlus(dateiRS, "AntwortID4", 0)
        m_PreviousAntwortIDs(4) = GetSafeFieldPlus(dateiRS, "AntwortID5", 0)
        m_PreviousAntwortIDs(5) = GetSafeFieldPlus(dateiRS, "AntwortID6", 0)
        m_PreviousAntwortIDs(6) = GetSafeFieldPlus(dateiRS, "AntwortID7", 0)
        m_PreviousAntwortIDs(7) = GetSafeFieldPlus(dateiRS, "AntwortID8", 0)
        m_PreviousAntwortIDs(8) = GetSafeFieldPlus(dateiRS, "AntwortID9", 0)
        m_PreviousAntwortIDs(9) = GetSafeFieldPlus(dateiRS, "AntwortID10", 0)
        m_PreviousAntwortIDs(10) = GetSafeFieldPlus(dateiRS, "AntwortID11", 0)
        m_PreviousAntwortIDs(11) = GetSafeFieldPlus(dateiRS, "AntwortID12", 0)
        m_PreviousAntwortIDs(12) = GetSafeFieldPlus(dateiRS, "AntwortID13", 0)
        m_PreviousAntwortIDs(13) = GetSafeFieldPlus(dateiRS, "AntwortID14", 0)
        m_PreviousAntwortIDs(14) = GetSafeFieldPlus(dateiRS, "AntwortID15", 0)
        Call CalcSchutzbedarfFromAnswers(m_PreviousAntwortIDs, m_PreviousFragenValues)
        
    
'        If m_PreviousFragenValues.HasValidValues() = True Then
            ' Wenn schon einmal befragt wurde, dann auch die existierenden Kommentare einlesen
            Dim commentrs As Object
            Set commentrs = CreateObject("ADODB.Recordset")
            commentrs.Open "SELECT * FROM idvDateienFragenKommentar WHERE idvDateiID = " & m_DateiID, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
            If Not commentrs.EOF Then
                commentrs.MoveFirst
                Do While Not commentrs.EOF
                    Dim commentFrageId As Long
                    Dim comment As String
                    commentFrageId = GetSafeFieldPlus(commentrs, "FragenID", 0)
                    comment = GetSafeField(commentrs, "UserText")
                    If comment <> "" Then
                        Call SetPreviousComment(commentFrageId, comment)
                    End If
                    commentrs.MoveNext
                Loop
                commentrs.Close
            End If
            Set commentrs = Nothing
'        End If
    End If
End Sub

Public Function InitDoku(ByRef dateiRS As Object, ByRef conn As Object) As Boolean
    Dim dateiid As Long
    dateiid = GetSafeFieldPlus(dateiRS, "idvDateiID", 0)

    Dim i As Long
    Dim letzteBefragung As Date
    letzteBefragung = GetSafeFieldPlus(dateiRS, "LetzteBefragung", #1/1/1900#)
    If letzteBefragung > #1/1/1900# Then
        Dim antwortenCount As Long
        ' Die Antworten speichern wie sie aus dem Dateienrekord kommen
        Dim antwortIDs As String
        For i = 0 To 14
            m_PreviousAntwortIDs(i) = GetSafeFieldPlus(dateiRS, "AntwortID" & (i + 1), 0)
            If m_PreviousAntwortIDs(i) <> 0 Then
                antwortenCount = antwortenCount + 1
                
                If m_PreviousAntwortIDs(i) <> PA_ANTWORT_SEL And m_PreviousAntwortIDs(i) <> PA_ANTWORT_NONE Then
                    If antwortIDs = "" Then
                        antwortIDs = "(" & m_PreviousAntwortIDs(i)
                    Else
                        antwortIDs = antwortIDs & "," & m_PreviousAntwortIDs(i)
                    End If
                End If
            End If
        Next i
        antwortIDs = antwortIDs & ")"
        
        ' Wenn antwortIDs = ")", dann wurde nur der Prozessdialog beim letzten Mal verwendet, es gibt also nur eine "Frage" mit [PROZESSAUSWAHL], sonst nix
        If antwortenCount <= 0 Or antwortIDs = ")" Then
            InitDoku = False
            Exit Function
        End If
        
        Dim rs As Object
        Set rs = CreateObject("ADODB.Recordset")
        
        Dim query As String
        query = "SELECT gFragenAntwortenHistorie.Antwort, gFragenAntwortenHistorie.FrageID, gFragenAntwortenHistorie.FrageAntwortID, gFragenAntwortenHistorie.Antwort, gFragenAntwortenHistorie.AntwortFunktion, gFragenAntwortenHistorie.AntwortFunktion2, gFragenAntwortenHistorie.AntwortFunktion3, " & _
            " gFragenHistorie.Nr, gFragenHistorie.Frage, uF.LokalisierterText as LocFrage, uA.LokalisierterText as LocAntwort, comment1.UserText " & _
            " from ((((gFragenAntwortenHistorie INNER JOIN gFragenHistorie ON gFragenAntwortenHistorie.FrageID = gFragenHistorie.FrageID) " & _
            " left join gTexteUebersetzungen uF on (uF.TextID = gFragenHistorie.TextID and uF.LanguageID = " & GetMyDBLanguage(conn) & ")) " & _
            " left join gTexteUebersetzungen uA on (uA.TextID = gFragenAntwortenHistorie.TextID and uA.LanguageID = " & GetMyDBLanguage(conn) & ")) " & _
            " left join idvDateienFragenKommentar comment1 on (comment1.FragenID = gFragenAntwortenHistorie.FrageID AND comment1.idvDateiID = " & dateiid & "))" & _
            " where gFragenAntwortenHistorie.FrageAntwortID in " & antwortIDs
        rs.Open query, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
        If rs.EOF Then
            Set rs = Nothing
            InitDoku = False
            Exit Function
        End If
        
        i = 0
        ReDim m_FragenCache(antwortenCount)
        ReDim m_AntwortenCache(antwortenCount)
        Do While Not rs.EOF
            If i < antwortenCount Then
                Set m_AntwortenCache(i) = New CAntwort
                Set m_FragenCache(i) = New CFragenData
                Call m_AntwortenCache(i).InitFromAntwortRecord(rs)
                Call m_FragenCache(i).InitFromRecord(rs, m_AntwortenCache)
                i = i + 1
            End If
            rs.MoveNext
        Loop
        rs.Close
        Set rs = Nothing
        
        Dim dlg As CFragenDlg
        Dim sb_bisher As New CFragenSchutzbedarf
        
        For i = 0 To antwortenCount
            Set dlg = New CFragenDlg
            Dim antwortID As Long
            antwortID = m_PreviousAntwortIDs(i)
            
            If m_PreviousAntwortIDs(i) = PA_ANTWORT_SEL Then
                dlg.m_IsPA = True
                ' Schutzbedarfswerte der Prozessauswahl ermitteln
                Dim sbpa As New CFragenSchutzbedarf
                Dim pars As Object
                Set pars = CreateObject("ADODB.Recordset")
                pars.Open "Select Idvdateienprozess.Prozessschluessel, Prozessname, Prozesslandkarte, Ebene3, Schutzbedarf, Vertraulichkeit, Integritaet, Verfuegbarkeit, Informationsklassifizierung, Authentizitaet " & _
                    "From (idvDateienProzess " & _
                    "Inner Join Gprozess On Idvdateienprozess.Prozessschluessel = Gprozess.Prozessschluessel) " & _
                    "Where idvDateienProzess.Idvdateiid = " & GetSafeFieldPlus(dateiRS, "idvDateiID", 0) & _
                    " AND Idvdateienprozess.Einfuegung >= Von And Idvdateienprozess.Einfuegung < Bis;", _
                    conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
                Do While Not pars.EOF
                    Dim schluessel As String
                    schluessel = GetSafeField(pars, "Prozessschluessel")
                    If schluessel <> "" Then
                        Call dlg.m_ProzesseSchluessel.add(schluessel)
                        Call dlg.m_ProzesseText.add(GetProzText(pars))
                        
                        Dim sb As New CFragenSchutzbedarf
                        sb.value(C_IDVDATFLD_SCHUTZBEDARF) = GetSafeFieldPlus(pars, "Schutzbedarf", 0)
                        sb.value(C_IDVDATFLD_VERTRAULICHKEIT) = GetSafeFieldPlus(pars, "Vertraulichkeit", 0)
                        sb.value(C_IDVDATFLD_INTEGRITAET) = GetSafeFieldPlus(pars, "Integritaet", 0)
                        sb.value(C_IDVDATFLD_VERFUEGBARKEIT) = GetSafeFieldPlus(pars, "Verfuegbarkeit", 0)
                        sb.value(C_IDVDATFLD_INFORMATIONSKLASSE) = GetSafeFieldPlus(pars, "Informationsklassifizierung", 0)
                        sb.value(C_IDVDATFLD_AUTHENTIZITAET) = GetSafeFieldPlus(pars, "Authentizitaet", 0)
                        Call sbpa.SetMaxValuesPA(sb)
                        Set sb = Nothing
                    End If
                    pars.MoveNext
                Loop
                pars.Close
                Set pars = Nothing
                
                Call sb_bisher.Assign(sbpa)
                Call dlg.AssignSchutzbedarf(sb_bisher)
                m_FragenDlgCol.add dlg, "O" & antwortID
                
            ElseIf m_PreviousAntwortIDs(i) = PA_ANTWORT_NONE Then
                dlg.m_IsPA = True
                Call dlg.m_ProzesseText.add(FMT0("PA_5")) ' Nicht bekannt / keiner der Prozesse
                Call dlg.AssignSchutzbedarf(sb_bisher)
                m_FragenDlgCol.add dlg, "O" & antwortID
            ElseIf antwortID > 0 Then
                Dim frageID As Long
                frageID = GetFrageIDFromAntwortID(antwortID)
                Dim Frage As CFragenData
                Set Frage = GetFrage(frageID)
                If Not Frage Is Nothing Then
                    dlg.m_FragenNr = Frage.m_Nr
                    dlg.m_IsPA = False
                    
                    Call dlg.m_Fragen.add(Frage.m_Nr)
                    Call dlg.m_Antworten.add(GetAntwort(antwortID))
                    
                    Call CheckantwortFunktion(antwortID, sb_bisher)
                    Call dlg.AssignSchutzbedarf(sb_bisher)
                    
                    m_FragenDlgCol.add dlg, "O" & antwortID
                End If
            End If
        Next i
        
        InitDoku = True
    Else
        ' Datei wurde noch nie befragt
        InitDoku = False
    End If
End Function

#If geht_so_nicht Then
Public Function InitHistory(ByRef dateiRS As Object, ByRef conn As Object) As Boolean
    ' Die Befragung fuer Doku/Freigabeformular initialisieren
    Dim dateiid As Long
    dateiid = GetSafeFieldPlus(dateiRS, "idvDateiID", 0)
    
    Dim i As Long
    Dim letzteBefragung As Date
    letzteBefragung = GetSafeFieldPlus(dateiRS, "LetzteBefragung", #1/1/1900#)
    If letzteBefragung > #1/1/1900# Then
        Dim antwortenCount As Long
        ' Die Antworten speichern wie sie aus dem Dateienrekord kommen
        For i = 0 To 14
            m_PreviousAntwortIDs(i) = GetSafeFieldPlus(dateiRS, "AntwortID" & (i + 1), 0)
            If m_PreviousAntwortIDs(i) > 0 Then
                antwortenCount = antwortenCount + 1
            End If
        Next i
        
        Const InvalidNr As Long = -999999
        Dim fragenrs As Object
        Set fragenrs = CreateObject("ADODB.Recordset")
        Dim query As String
        
        If G_DBType = G_Access Then
            query = "SELECT gFragenHistorie.FrageID, gFragenHistorie.Nr, gFragenHistorie.Frage, gFragenHistorie.Hinweistext, gFragenHistorie.Linksbuendig, gFragenHistorie.CLZuweisungsID," & _
                " gFragenHistorie.CLTyp, gFragenHistorie.NaechsteFragenGruppenNr, gFragenHistorie.Vorauswahl," & _
                " uf.LokalisierterText as LocFrage, uh.LokalisierterText as LocHinweistext, comment1.UserText" & _
                " FROM (((gFragenHistorie left join gTexteUebersetzungen uf on (gFragenHistorie.TextID = uf.TextID and uf.LanguageID = " & GetMyDBLanguage(conn) & ")) " & _
                " left join gTexteUebersetzungen uh on (uh.TextID = gFragenHistorie.HinweistextTextID and uh.LanguageID = " & GetMyDBLanguage(conn) & " )) " & _
                " left join idvDateienFragenKommentar comment on (comment.FragenID = gFragenHistorie.FrageID))" & _
                " WHERE Von <= cdate('" & MakeDBDate(letzteBefragung) & "') And Bis >= cdate('" & MakeDBDate(letzteBefragung) & "')" & _
                " ORDER BY Nr"
                '" AND (comment.idvDateiID = " & dateiID & " or comment.idvDateiID is null)"
        ElseIf G_DBType = G_SQL_Server Then
            query = "SELECT gFragenHistorie.FrageID, gFragenHistorie.Nr, gFragenHistorie.Frage, gFragenHistorie.Hinweistext, gFragenHistorie.Linksbuendig, gFragenHistorie.CLZuweisungsID," & _
                " gFragenHistorie.CLTyp, gFragenHistorie.NaechsteFragenGruppenNr, gFragenHistorie.Vorauswahl," & _
                " uf.LokalisierterText as LocFrage, uh.LokalisierterText as LocHinweistext, comment.UserText" & _
                " FROM (((gFragenHistorie left join gTexteUebersetzungen uf on (gFragenHistorie.TextID = uf.TextID and uf.LanguageID = " & GetMyDBLanguage(conn) & ")) " & _
                " left join gTexteUebersetzungen uh on (uh.TextID = gFragenHistorie.HinweistextTextID and uh.LanguageID = " & GetMyDBLanguage(conn) & " )) " & _
                " left join idvDateienFragenKommentar comment on (comment.FragenID = gFragenHistorie.FrageID))" & _
                " WHERE Von <= '" & MakeDBDate(letzteBefragung) & "' And Bis >= '" & MakeDBDate(letzteBefragung) & "'" & _
                " ORDER BY Nr"
            'WHERE Von <= '2017-02-20 10:31:40' And Bis >= '2017-02-20 10:31:40'
        ElseIf G_DBType = G_Oracle Then
            query = "SELECT gFragenHistorie.FrageID, gFragenHistorie.Nr, gFragenHistorie.Frage, gFragenHistorie.Hinweistext, gFragenHistorie.Linksbuendig, gFragenHistorie.CLZuweisungsID," & _
                " gFragenHistorie.CLTyp, gFragenHistorie.NaechsteFragenGruppenNr, gFragenHistorie.Vorauswahl," & _
                " uf.LokalisierterText as LocFrage, uh.LokalisierterText as LocHinweistext, comment.UserText" & _
                " FROM (((gFragenHistorie left join gTexteUebersetzungen uf on (gFragenHistorie.TextID = uf.TextID and uf.LanguageID = " & GetMyDBLanguage(conn) & ")) " & _
                " left join gTexteUebersetzungen uh on (uh.TextID = gFragenHistorie.HinweistextTextID and uh.LanguageID = " & GetMyDBLanguage(conn) & " )) " & _
                " left join idvDateienFragenKommentar comment on (comment.FragenID = gFragenHistorie.FrageID))" & _
                " where von <= timestamp " & MakeDBDate(letzteBefragung) & "' And Bis >= timestamp " & MakeDBDate(letzteBefragung) & "'" & _
                " ORDER BY Nr"
            'where von <= TimeStamp '2017-02-20 10:31:10' And Bis >= timestamp '2017-02-20 10:31:10'
        Else
            Debug.Print "TODO: Einbauen fuer G_DBType " & G_DBType
        End If
        fragenrs.Open query, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
        If Not fragenrs.EOF Then
            Dim frageIds As String
            i = 0
            Do While Not fragenrs.EOF
                If i = 0 Then
                    frageIds = GetSafeFieldPlus(fragenrs, "FrageID", 0)
                Else
                    frageIds = frageIds & "," & GetSafeFieldPlus(fragenrs, "FrageID", 0)
                End If
                fragenrs.MoveNext
                i = i + 1
            Loop
            fragenrs.MoveFirst
            
            Dim antwortenrs As Object
            Set antwortenrs = CreateObject("ADODB.Recordset")
            antwortenrs.Open "SELECT gFA.*, ua.LokalisierterText AS LocAntwort FROM gFragenAntwortenHistorie gFA " & _
                " LEFT JOIN gTexteUebersetzungen ua ON (gFA.TextID = ua.TextID and ua.LanguageID = " & GetMyDBLanguage(conn) & ") " & _
                " WHERE FrageID in (" & frageIds & ")" & _
                " ORDER BY Position", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
            If Not antwortenrs Is Nothing Then
                ReDim m_AntwortenCache(antwortenrs.RecordCount)
                i = 0
                Do While Not antwortenrs.EOF
                    Set m_AntwortenCache(i) = New CAntwort
                    Call m_AntwortenCache(i).InitFromAntwortRecord(antwortenrs)
                    i = i + 1
                    antwortenrs.MoveNext
                Loop
                antwortenrs.Close
                Set antwortenrs = Nothing
            End If
        
            Dim fragenCount As Long
            fragenCount = fragenrs.RecordCount
            ReDim m_FragenCache(fragenCount)
            i = 0
            Dim nr As Long
            Dim dlg As CFragenDlg
            nr = InvalidNr
            Dim Schutzbedarf As New CFragenSchutzbedarf
            Dim tempSchutzbed As New CFragenSchutzbedarf
            Do While Not fragenrs.EOF
                Set m_FragenCache(i) = New CFragenData
                Call m_FragenCache(i).InitFromRecord(fragenrs, m_AntwortenCache)
                i = i + 1
                fragenrs.MoveNext
            Loop
            fragenrs.Close
            Set fragenrs = Nothing
                
            If fragenCount <= 0 Then
                InitHistory = False
                Exit Function
            End If
            
            nr = m_FragenCache(0).m_Nr
            Dim idx As Long
            Dim antwortIdx As Long
            idx = 0
            Dim createNewDlg As Boolean
            createNewDlg = True
            
            Do While idx < fragenCount
                Dim Frage As CFragenData
                If nr > 0 Then
                    Set Frage = GetFrageByNr(nr, idx)
                    If Frage Is Nothing Then
                        InitHistory = False
                        Exit Function
                    End If
                End If
            
                If createNewDlg Then
                    ' Fragendialog Instanz erzeugen
                    Set dlg = New CFragenDlg
                    dlg.m_FragenNr = nr
                    dlg.m_IsPA = Frage.m_Frage = "[PROZESSAUSWAHL]"
                    m_FragenDlgCol.add dlg, "O" & nr
                    
                    Call tempSchutzbed.Assign(Schutzbedarf)
                    createNewDlg = False
                End If
                
                If dlg.m_IsPA = True Then
                    ' Schutzbedarfswerte der Prozessauswahl ermitteln
                    Dim sbpa As New CFragenSchutzbedarf
                    Dim pars As Object
                    Set pars = CreateObject("ADODB.Recordset")
                    pars.Open "Select Idvdateienprozess.Prozessschluessel, Prozessname, Prozesslandkarte, Ebene3, Schutzbedarf, Vertraulichkeit, Integritaet, Verfuegbarkeit, Informationsklassifizierung, Authentizitaet  " & _
                        "From (idvDateienProzess " & _
                        "Inner Join Gprozess On Idvdateienprozess.Prozessschluessel = Gprozess.Prozessschluessel) " & _
                        "Where idvDateienProzess.Idvdateiid = " & GetSafeFieldPlus(dateiRS, "idvDateiID", 0) & _
                        " AND Idvdateienprozess.Einfuegung >= Von And Idvdateienprozess.Einfuegung < Bis;", _
                        conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
                    Do While Not pars.EOF
                        Dim schluessel As String
                        schluessel = GetSafeField(pars, "Prozessschluessel")
                        If schluessel <> "" Then
                            Call dlg.m_ProzesseSchluessel.add(schluessel)
                            Call dlg.m_ProzesseText.add(GetProzText(pars))
                            
                            Dim sb As New CFragenSchutzbedarf
                            sb.value(C_IDVDATFLD_SCHUTZBEDARF) = GetSafeFieldPlus(pars, "Schutzbedarf", 0)
                            sb.value(C_IDVDATFLD_VERTRAULICHKEIT) = GetSafeFieldPlus(pars, "Vertraulichkeit", 0)
                            sb.value(C_IDVDATFLD_INTEGRITAET) = GetSafeFieldPlus(pars, "Integritaet", 0)
                            sb.value(C_IDVDATFLD_VERFUEGBARKEIT) = GetSafeFieldPlus(pars, "Verfuegbarkeit", 0)
                            sb.value(C_IDVDATFLD_INFORMATIONSKLASSE) = GetSafeFieldPlus(pars, "Informationsklassifizierung", 0)
                            sb.value(C_IDVDATFLD_AUTENTIZITAET) = GetSafeFieldPlus(pars, "Authentizitaet", 0)
                            Call sbpa.SetMaxValuesPA(sb)
                            Set sb = Nothing
                        End If
                        pars.MoveNext
                    Loop
                    pars.Close
                    Set pars = Nothing
                    
                    Call Schutzbedarf.Assign(sbpa)
                    Call dlg.AssignSchutzbedarf(sbpa)
                    
                    nr = Frage.antwort(0).m_Sprung
                    If nr = -1 Or nr = -2 Then Exit Do

                    createNewDlg = True
                Else
                    ' Aus allen Antworten diejenige finden, die der user ausgewaehlt hatte
                    Dim j As Long
                    Dim antwortID As Long
                    Dim sprung As Long
                    antwortID = -1
                    For j = 0 To 3
                        If GetPreviousAntwortIdx(m_FragenCache(idx).antwort(j).m_AntwortID) >= 0 Then
                            antwortID = m_FragenCache(idx).antwort(j).m_AntwortID
                            sprung = m_FragenCache(idx).antwort(j).m_Sprung
                            Exit For
                        End If
                    Next j
                    If antwortID < 0 Then
                        ' Die Antworten passen nicht mit denen im Dateienrekord zusammen.
                        InitHistory = False
                        Set fragenrs = Nothing
                        Exit Function
                    End If
                    
                    Call dlg.m_Fragen.add(m_FragenCache(idx).m_Nr)
                    Call dlg.m_Antworten.add(GetAntwort(antwortID))
                    
                    ' Den per Frage Schutzbedarf updaten
                    Call CheckantwortFunktion(antwortID, tempSchutzbed)
                    
                    Dim nextGroupNr As Long
                    nextGroupNr = m_FragenCache(idx).m_NaechsteFragenGruppenNr
                    If nextGroupNr = -1 Then
                        ' Den per Dialog Schutzbedarf updaten
                        Call Schutzbedarf.Assign(tempSchutzbed)
                        ' Bis hierhin ermittelte Schutzbedarfswerte in CFragenDlg speichern
                        Call dlg.AssignSchutzbedarf(Schutzbedarf)
                        
                    
                        If sprung = -1 Or sprung = -2 Then Exit Do
                        
                        nr = InvalidNr
                        If sprung > 0 Then
                            nr = sprung
                        End If
                        If nr = InvalidNr Then
                            ' Einfach mit dem Nachfolger der letzen Frage weitermachen
                            idx = idx + 1
                            If idx < UBound(m_FragenCache) - 1 Then
                                nr = m_FragenCache(idx).m_Nr
                            End If
                        End If
                        createNewDlg = True
                    End If
                    
                End If
                
                Set Frage = Nothing
            Loop
                
        End If
        InitHistory = True
    Else
        ' Datei wurde noch nie befragt
        InitHistory = False
    End If
End Function
#End If

Public Function GetFrageByNr(nr As Long, ByRef idx As Long) As CFragenData
    For idx = 0 To UBound(m_FragenCache)
        If Not m_FragenCache(idx) Is Nothing Then
            If m_FragenCache(idx).m_Nr = nr Then
                Set GetFrageByNr = m_FragenCache(idx)
                Exit Function
            End If
        End If
    Next idx
End Function

Public Function GetFrage(frageID As Long) As CFragenData
    Dim i As Long
    For i = 0 To UBound(m_FragenCache)
        If Not m_FragenCache(i) Is Nothing Then
            If m_FragenCache(i).m_FrageID = frageID Then
                Set GetFrage = m_FragenCache(i)
                Exit Function
            End If
        End If
    Next i
End Function

Private Function MakeDBDate(d As Date) As String
    MakeDBDate = Format(d, "yyyy-mm-dd hh:mm:ss")
End Function


Private Function GetPreviousAntwortIdx(antwortID As Long) As Long
    Dim i As Long
    For i = 0 To 14
        If m_PreviousAntwortIDs(i) = antwortID Then
            GetPreviousAntwortIdx = i
            Exit Function
        End If
    Next i
    GetPreviousAntwortIdx = -1
End Function

Public Function GetFrageIDFromAntwortID(antwortID As Long) As Long
    Dim i As Long
    For i = 0 To UBound(m_AntwortenCache)
        If Not m_AntwortenCache(i) Is Nothing Then
            If m_AntwortenCache(i).m_AntwortID = antwortID Then
                GetFrageIDFromAntwortID = m_AntwortenCache(i).m_FrageID
                Exit Function
            End If
        End If
    Next i
End Function

Public Function GetPreviousComment(frageID As Long) As String
    If CollectionStringExists(m_PreviousComments, "O" & frageID) Then
        GetPreviousComment = m_PreviousComments("O" & frageID)
    End If
End Function

Public Sub SetPreviousComment(frageID As Long, Text As String)
    ' Nix machen, wenn keine gueltige FrageID, kein Text, oder der Defaultttext
    If frageID <= 0 Or Text = "" Or Text = FMT0("QUESTIONS_10") Then Exit Sub
    
    Dim Key As String
    Key = "O" & frageID
    If CollectionStringExists(m_PreviousComments, Key) Then
        Call m_PreviousComments.Remove(Key)
    End If
    Call m_PreviousComments.add(Text, Key)
End Sub

Public Function HasNewComment(frageID As Long) As Boolean
    Dim Key As String
    Key = "O" & frageID
    If CollectionStringExists(m_NewComments, Key) Then
        ' Ignorieren wenn der Kommentar der Defaulttext oder "" ist!
        If m_NewComments(Key) <> FMT0("QUESTIONS_10") And m_NewComments(Key) <> "" Then
            HasNewComment = True
        End If
    End If
End Function

Public Function GetNewComment(frageID As Long) As String
    If CollectionStringExists(m_NewComments, "O" & frageID) Then
        GetNewComment = m_NewComments("O" & frageID)
    End If
End Function

' obsolete, nicht mehr benutzen, muss nur f|fffd|r binary compatibilit|fffd|t drin bleiben
Public Function SchutzbedarfIstReduziert(integ As Long, verfueg As Long, vertr As Long, infoklasse As Long) As Boolean
    SchutzbedarfIstReduziert = False
End Function

Public Function SchutzbedarfIstReduziertMitAuthen(integ As Long, verfueg As Long, vertr As Long, authen As Long, infoklasse As Long) As Boolean
    If m_ProzessauswahlValues Is Nothing Then Exit Function
    
    If (integ > 0 And integ < m_ProzessauswahlValues.value(C_IDVDATFLD_INTEGRITAET)) Or _
        (verfueg > 0 And verfueg < m_ProzessauswahlValues.value(C_IDVDATFLD_VERFUEGBARKEIT)) Or _
        (vertr > 0 And vertr < m_ProzessauswahlValues.value(C_IDVDATFLD_VERTRAULICHKEIT)) Or _
        (authen > 0 And authen < m_ProzessauswahlValues.value(C_IDVDATFLD_AUTHENTIZITAET)) Then
        
        SchutzbedarfIstReduziertMitAuthen = True
    End If
End Function

' obsolete, nicht mehr benutzen, muss nur f|fffd|r binary compatibilit|fffd|t drin bleiben
Public Function SchutzbedarfIstGeaendert(integ As Long, verfueg As Long, vertr As Long, infoklasse As Long) As Boolean
    SchutzbedarfIstGeaendert = False
End Function

Public Function SchutzbedarfIstGeaendertMitAuthen(integ As Long, verfueg As Long, vertr As Long, authen As Long, infoklasse As Long) As Boolean
    If m_ProzessauswahlValues Is Nothing Then Exit Function
    
    If (integ > 0 And integ <> m_ProzessauswahlValues.value(C_IDVDATFLD_INTEGRITAET)) Or _
        (verfueg > 0 And verfueg <> m_ProzessauswahlValues.value(C_IDVDATFLD_VERFUEGBARKEIT)) Or _
        (vertr > 0 And vertr <> m_ProzessauswahlValues.value(C_IDVDATFLD_VERTRAULICHKEIT)) Or _
        (authen > 0 And authen <> m_ProzessauswahlValues.value(C_IDVDATFLD_AUTHENTIZITAET)) Then
        
        SchutzbedarfIstGeaendertMitAuthen = True
    End If
End Function

Public Function SchutzbedarfReduziertMitAntwort(antwortID As Long) As Boolean
    If m_ProzessauswahlValues Is Nothing Then Exit Function
    If antwortID <= 0 Then Exit Function
    
    Dim sbtemp As New CFragenSchutzbedarf
    Call CheckantwortFunktion(antwortID, sbtemp)
    
    SchutzbedarfReduziertMitAntwort = SchutzbedarfIstReduziertMitAuthen(sbtemp.value(C_IDVDATFLD_INTEGRITAET), _
                                        sbtemp.value(C_IDVDATFLD_VERFUEGBARKEIT), _
                                        sbtemp.value(C_IDVDATFLD_VERTRAULICHKEIT), _
                                        sbtemp.value(C_IDVDATFLD_AUTHENTIZITAET), _
                                        sbtemp.value(C_IDVDATFLD_INFORMATIONSKLASSE))
End Function

Public Function SchutzbedarfGeaendertMitAntwort(antwortID As Long) As Boolean
    If m_ProzessauswahlValues Is Nothing Then Exit Function
    If antwortID <= 0 Then Exit Function
    
    Dim sbtemp As New CFragenSchutzbedarf
    Call CheckantwortFunktion(antwortID, sbtemp)
    
    SchutzbedarfGeaendertMitAntwort = SchutzbedarfIstGeaendertMitAuthen(sbtemp.value(C_IDVDATFLD_INTEGRITAET), _
                                        sbtemp.value(C_IDVDATFLD_VERFUEGBARKEIT), _
                                        sbtemp.value(C_IDVDATFLD_VERTRAULICHKEIT), _
                                        sbtemp.value(C_IDVDATFLD_AUTHENTIZITAET), _
                                        sbtemp.value(C_IDVDATFLD_INFORMATIONSKLASSE))
End Function

Private Sub CalcSchutzbedarfFromAnswers(ByRef answerIDs() As Long, ByRef sb As CFragenSchutzbedarf)
    Dim sbtemp As New CFragenSchutzbedarf
    Dim i As Long
    For i = 0 To UBound(answerIDs)
        If answerIDs(i) > 0 Then
            Call CheckantwortFunktion(answerIDs(i), sbtemp)
            Call sb.Assign(sbtemp)
        End If
    Next i
End Sub

Private Sub CheckantwortFunktion(antwortID As Long, ByRef sb As CFragenSchutzbedarf)
    If antwortID = 0 Then Exit Sub
    Dim i As Long
    For i = 0 To UBound(m_AntwortenCache)
        If Not m_AntwortenCache(i) Is Nothing Then
            If m_AntwortenCache(i).m_AntwortID = antwortID Then
                Exit For
            End If
        End If
    Next i
    If i > UBound(m_AntwortenCache) Then Exit Sub
  
    Dim j As Long
8    For j = 0 To 2
        Select Case m_AntwortenCache(i).AntwortFunk(j)
            Case 1 ' Integrit|fffd|t gering
                sb.value(C_IDVDATFLD_INTEGRITAET) = 1
            Case 2 ' Integrit|fffd|t mittel
                sb.value(C_IDVDATFLD_INTEGRITAET) = 2
            Case 3 ' Integrit|fffd|t hoch
                sb.value(C_IDVDATFLD_INTEGRITAET) = 3
            Case 4 ' Integrit|fffd|t sehr hoch
                sb.value(C_IDVDATFLD_INTEGRITAET) = 4
            Case 5 ' Verf|fffd|gbarkeit gering
                sb.value(C_IDVDATFLD_VERFUEGBARKEIT) = 1
            Case 6 ' Verf|fffd|gbarkeit mittel
                sb.value(C_IDVDATFLD_VERFUEGBARKEIT) = 2
            Case 7 ' Verf|fffd|gbarkeit hoch
                sb.value(C_IDVDATFLD_VERFUEGBARKEIT) = 3
            Case 8       ' Verf|fffd|gbarkeit sehr hoch
                sb.value(C_IDVDATFLD_VERFUEGBARKEIT) = 4
            Case 9       ' Vertraulichkeit gering
                sb.value(C_IDVDATFLD_VERTRAULICHKEIT) = 1
            Case 10        ' Vertraulichkeit mittel
                sb.value(C_IDVDATFLD_VERTRAULICHKEIT) = 2
            Case 11        ' Vertraulichkeit hoch
                sb.value(C_IDVDATFLD_VERTRAULICHKEIT) = 3
            Case 12        ' Vertraulichkeit sehr hoch
                sb.value(C_IDVDATFLD_VERTRAULICHKEIT) = 4
            Case 13        ' Informationsklasse S1
                sb.value(C_IDVDATFLD_INFORMATIONSKLASSE) = 1
            Case 14        ' Informationsklassifizierung s2
                sb.value(C_IDVDATFLD_INFORMATIONSKLASSE) = 2
            Case 15        ' Informationsklassifizierung s3
                sb.value(C_IDVDATFLD_INFORMATIONSKLASSE) = 3
            Case 16        ' Informationsklassifizierung S4
                sb.value(C_IDVDATFLD_INFORMATIONSKLASSE) = 4
            Case 17        ' Informationsklassifizierung S5
                sb.value(C_IDVDATFLD_INFORMATIONSKLASSE) = 5
            Case 18        ' Schutzbedarf gering
                sb.value(C_IDVDATFLD_SCHUTZBEDARF) = 1
            Case 19        ' Schutzbedarf mittel
                sb.value(C_IDVDATFLD_SCHUTZBEDARF) = 2
            Case 20        ' Schutzbedarf hoch
                sb.value(C_IDVDATFLD_SCHUTZBEDARF) = 3
            Case 21        ' Schutzbedarf sehr hoch
                sb.value(C_IDVDATFLD_SCHUTZBEDARF) = 4
            Case 22        ' Bankfachlich JA
                sb.value(C_IDVDATFLD_BANKFACHLICH) = 1
            Case 23        ' Bankfachlich NEIN
                sb.value(C_IDVDATFLD_BANKFACHLICH) = 0
            Case 24        ' GOBD JA
                sb.value(C_IDVDATFLD_GOBD) = 1
            Case 25        ' GOBD NEIN
                sb.value(C_IDVDATFLD_GOBD) = 0
            Case 26        ' Authentizitaet gering
                sb.value(C_IDVDATFLD_AUTHENTIZITAET) = 1
            Case 27        ' Authentizitaet mittel
                sb.value(C_IDVDATFLD_AUTHENTIZITAET) = 2
            Case 28        ' Authentizitaet hoch
                sb.value(C_IDVDATFLD_AUTHENTIZITAET) = 3
            Case 29        ' Authentizitaet sehr hoch
                sb.value(C_IDVDATFLD_AUTHENTIZITAET) = 4
            Case 30        ' FREMDENTWICKLUNG JA
                sb.value(C_IDVDATFLD_FREMDENTWICKLUNG) = 1
            Case 31        ' FREMDENTWICKLUNG NEIN
                sb.value(C_IDVDATFLD_FREMDENTWICKLUNG) = 0
        End Select
    Next j
End Sub

Public Function GetCommentTypeForAnswer(antwortID As Long) As Long
    If antwortID <= 0 Then Exit Function
    
    Dim i As Long
    For i = 0 To UBound(m_AntwortenCache)
        If Not m_AntwortenCache(i) Is Nothing Then
            If m_AntwortenCache(i).m_AntwortID = antwortID Then
                GetCommentTypeForAnswer = m_AntwortenCache(i).m_KommentarTyp
                Exit Function
            End If
        End If
    Next i
End Function

Public Function GetCommentText(antwortID As Long) As String
    Dim Key As String
    Key = "O" & CStr(antwortID)
    If CollectionStringExists(m_PreviousComments, Key) = True Then
        GetCommentText = m_PreviousComments(Key)
    End If
End Function

' NICHT SO MACHEN! Die Antworten sind im Cache in einer anderen Reihenfolge
'Public Function GetAnswerIDForQuestion(frageID As Long, antwortIdx As Long) As Long
'    Dim i As Long
'    For i = 0 To UBound(m_FragenCache)
'        If Not m_FragenCache(i) Is Nothing Then
'            If m_FragenCache(i).m_FrageID = frageID Then
'                GetAnswerIDForQuestion = m_FragenCache(i).Antwort(antwortIdx).m_AntwortID
'            End If
'        End If
'    Next i
'End Function

Public Function GetVorauswahlAntwortID(frageID As Long) As Long
    Dim vorauswahlToField(8) As Long
    vorauswahlToField(VORAUSWAHL_INTEGRITAET) = C_IDVDATFLD_INTEGRITAET
    vorauswahlToField(VORAUSWAHL_VERTRAULICHKEIT) = C_IDVDATFLD_VERTRAULICHKEIT
    vorauswahlToField(VORAUSWAHL_VERFUEGBARKEIT) = C_IDVDATFLD_VERFUEGBARKEIT
    vorauswahlToField(VORAUSWAHL_AUTHENTIZITAET) = C_IDVDATFLD_AUTHENTIZITAET
    vorauswahlToField(VORAUSWAHL_INFORMATIONSKLASSE) = C_IDVDATFLD_INFORMATIONSKLASSE
    
    Dim i, j As Long
    For i = 0 To UBound(m_FragenCache)
        If Not m_FragenCache(i) Is Nothing Then
            If m_FragenCache(i).m_FrageID = frageID Then
                Dim vorauswahlType As Long
                vorauswahlType = m_FragenCache(i).m_Vorauswahl
                If vorauswahlType = VORAUSWAHL_LETZTE_ANTWORT Then
                    ' Jetzt schauen, ob von den Antworten dieser Frage eine selektiert war
                    For j = 0 To 3
                        If Not m_FragenCache(i).antwort(j) Is Nothing Then
                            If AntwortWarLetzteBefragungSelektiert(m_FragenCache(i).antwort(j).m_AntwortID) Then
                                GetVorauswahlAntwortID = m_FragenCache(i).antwort(j).m_AntwortID
                                Exit Function
                            End If
                        End If
                    Next j
                ElseIf vorauswahlType >= VORAUSWAHL_INTEGRITAET Then
                    ' Eine Antwort finden, die den Wert aus der Prozessauswahl liefert
                    For j = 0 To 3
                        If Not m_FragenCache(i).antwort(j) Is Nothing Then
                            Dim id As Long
                            Dim sb As New CFragenSchutzbedarf
                            id = m_FragenCache(i).antwort(j).m_AntwortID
                            Call CheckantwortFunktion(id, sb)
                            If m_ProzessauswahlValues.MatchesOtherValue(vorauswahlToField(vorauswahlType), sb) = True Then
                                GetVorauswahlAntwortID = id
                                Exit Function
                            End If
                        End If
                    Next j
                End If
                Exit Function
            End If
        End If
    Next i
End Function

Public Function AntwortWarLetzteBefragungSelektiert(antwortID As Long) As Boolean
    If antwortID <= 0 Then Exit Function
    
    Dim i As Long
    For i = 0 To UBound(m_PreviousAntwortIDs)
        If m_PreviousAntwortIDs(i) = antwortID Then
            AntwortWarLetzteBefragungSelektiert = True
            Exit Function
        End If
    Next i
End Function

Public Function GetAntwort(antwortID As Long) As CAntwort
    Dim i As Long
    For i = 0 To UBound(m_AntwortenCache)
        If Not m_AntwortenCache(i) Is Nothing Then
            If m_AntwortenCache(i).m_AntwortID = antwortID Then
                Set GetAntwort = m_AntwortenCache(i)
                Exit Function
            End If
        End If
    Next i
End Function

Public Function CalcSchutzbedarfWurdeReduziert(frgdlgcol As Collection) As Boolean
    ' Checken ob nach der Prozessauswahl einer der Schutzbedarfswerte verringert wurde
    CalcSchutzbedarfWurdeReduziert = False
    Dim hadPA As Boolean
    Dim schutzbedPA As New CFragenSchutzbedarf
    Dim schutzbedFragen As New CFragenSchutzbedarf
    Dim dlg As CFragenDlg
    For Each dlg In frgdlgcol
        If dlg.m_IsPA Then
            hadPA = True
            Call schutzbedPA.Assign(dlg.m_Schutzbed)
        ElseIf hadPA Then
            ' Nach PA jeden Dlg checken
            Call schutzbedFragen.Assign(dlg.m_Schutzbed)
        End If
    Next
    If hadPA Then
        If schutzbedFragen.SchutzbedarfReduziert(schutzbedPA) = True Then
            CalcSchutzbedarfWurdeReduziert = True
        End If
    End If
    
    Set schutzbedPA = Nothing
    Set schutzbedFragen = Nothing
End Function

Public Function CalcSchutzbedarfWurdeVeraendert(frgdlgcol As Collection) As Boolean
    ' Checken ob nach der Prozessauswahl einer der Schutzbedarfswerte verringert wurde
    CalcSchutzbedarfWurdeVeraendert = False
    Dim hadPA As Boolean
    Dim schutzbedPA As New CFragenSchutzbedarf
    Dim schutzbedFragen As New CFragenSchutzbedarf
    Dim dlg As CFragenDlg
    For Each dlg In frgdlgcol
        If dlg.m_IsPA Then
            hadPA = True
            Call schutzbedPA.Assign(dlg.m_Schutzbed)
        ElseIf hadPA Then
            ' Nach PA jeden Dlg checken
            Call schutzbedFragen.Assign(dlg.m_Schutzbed)
        End If
    Next
    If hadPA Then
        If schutzbedFragen.SchutzbedarfVeraendert(schutzbedPA) = True Then
            CalcSchutzbedarfWurdeVeraendert = True
        End If
    End If
    
    Set schutzbedPA = Nothing
    Set schutzbedFragen = Nothing
End Function

Public Sub UpdateSchutzbedarf(dlg As CFragenDlg)
    If dlg Is Nothing Then Exit Sub
    If dlg.m_Antworten Is Nothing Then Exit Sub
    
    ' Schutzbedarf updaten
    Dim i As Long
    Dim sb As New CFragenSchutzbedarf
    Dim ant As CAntwort
    For Each ant In dlg.m_Antworten
        Dim antwortID As Long
        antwortID = val(ant.m_AntwortID)
        
        Call CheckantwortFunktion(antwortID, sb)
        Call dlg.m_Schutzbed.Assign(sb)
    Next
End Sub

Public Sub AddFragenDlg(dlg As CFragenDlg)
    If dlg Is Nothing Then Exit Sub
    ' Den Dialog hier speichern
    Dim Key As String
    Key = "O" & dlg.m_FragenNr
    Call m_FragenDlgCol.add(dlg, Key)
End Sub

Public Sub RemoveFragenDlg()
    If m_FragenDlgCol.count > 0 Then
        Call m_FragenDlgCol.Remove(m_FragenDlgCol.count)
    End If
End Sub


Attribute VB_Name = "CDataObject"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public m_Name As String
Public m_Text As String
Public m_Text2 As String
Public m_Type As Long
Public m_Long As Long
Public m_Double As Double
Public m_Object As Object

Sub Init(n As String, t As String, t2 As String)
  m_Name = n
  m_Text = t
  m_Text2 = t2
End Sub

Attribute VB_Name = "CFragenData"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

' Repraesentiert die Daten einer Frage und deren Antworten aus der gFragen und gFragenAntworten Tabelle
' Speichert auch schon existierende Antworten der Datei und deren Schutzbedarfswerte sowie existierende Kommentare

Public m_FrageID As Long
Public m_Nr As Long
Public m_Frage As String
Public m_Hinweis As String
Public m_CLZuweisungsID As Long
Public m_CLTyp As Long
Public m_NaechsteFragenGruppenNr As Long
Public m_Vorauswahl As Long


Private m_Antworten(4) As CAntwort

Private m_KommentarText As String

Public Property Get antwort(idx As Long) As CAntwort
    Set antwort = m_Antworten(idx)
End Property


Public Property Get kommentar() As String
    kommentar = m_KommentarText
End Property

Public Sub InitFromRecord(ByRef fragenrs As Object, ByRef antwortenCache() As CAntwort)
    If fragenrs Is Nothing Then Exit Sub
    
    m_FrageID = GetSafeFieldPlus(fragenrs, "FrageID", 0)
    m_Nr = GetSafeFieldPlus(fragenrs, "Nr", 0)
    m_Frage = GetLocValueFromField(fragenrs, "Frage", "LocFrage", "")
    m_Hinweis = GetSafeField(fragenrs, "LocHinweistext")
    m_CLZuweisungsID = GetSafeFieldPlus(fragenrs, "CLZuweisungsID", 0)
    m_CLTyp = GetSafeFieldPlus(fragenrs, "CLTyp", 0)
    m_NaechsteFragenGruppenNr = GetSafeFieldPlus(fragenrs, "NaechsteFragenGruppenNr", 0)
    m_Vorauswahl = GetSafeFieldPlus(fragenrs, "Vorauswahl", 0)
    m_KommentarText = GetSafeField(fragenrs, "UserText")
    
    Dim i As Long
    Dim antwortIdx As Long
    antwortIdx = 0
    For i = 0 To UBound(antwortenCache)
        If Not antwortenCache(i) Is Nothing Then
            If antwortenCache(i).m_FrageID = m_FrageID Then
                Set m_Antworten(antwortIdx) = antwortenCache(i)
                antwortIdx = antwortIdx + 1
            End If
        End If
    Next i
End Sub

Attribute VB_Name = "CFragenDlg"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Public m_Antworten As Collection
Public m_FragenNr As String
Public m_IsPA As Boolean
Public m_Schutzbed As New CFragenSchutzbedarf
'Public m_Fragen As New Collection   ' CFragenData, Nr

Public m_ProzesseSchluessel As New Collection
Public m_ProzesseText As New Collection
Public m_Fragen As New Collection

Private Sub Class_Initialize()
  Set m_Antworten = New Collection
End Sub

Private Sub Class_Terminate()
  Set m_Antworten = Nothing
  Set m_ProzesseSchluessel = Nothing
  Set m_ProzesseText = Nothing
  Set m_Fragen = Nothing
End Sub

Public Sub AddAntwort(antwortID As Long, wert As Double, absolut As Boolean)
  Dim a As CAntwort
  Set a = New CAntwort
  a.m_AntwortID = antwortID
  a.m_Wert = wert
  a.m_Absolut = absolut
  m_Antworten.add a
End Sub

Public Sub AssignSchutzbedarf(sb As CFragenSchutzbedarf)
    Call m_Schutzbed.Assign(sb)
End Sub
Attribute VB_Name = "CFragenSchutzbedarf"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

' Die Schutzbedarfswerte die sich waehrend einer Befragung ergeben

' Aus ThisAddin
'Private Const C_MAXANTWORTFUNCFELDER As Long = 7

'Private Const C_IDVDATFLD_INTEGRITAET As Long = 1
'Private Const C_IDVDATFLD_VERFUEGBARKEIT As Long = 2
'Private Const C_IDVDATFLD_VERTRAULICHKEIT As Long = 3
'Private Const C_IDVDATFLD_INFORMATIONSKLASSE As Long = 4
'Private Const C_IDVDATFLD_SCHUTZBEDARF As Long = 5
'Private Const C_IDVDATFLD_BANKFACHLICH As Long = 6
'Private Const C_IDVDATFLD_GOBD As Long = 7

Private m_Value(C_MAXANTWORTFUNCFELDER) As Long


Public Property Get value(idx As Long) As Long
    value = 0
    If idx >= C_IDVDATFLD_INTEGRITAET And idx <= UBound(m_Value) Then
        value = m_Value(idx)
    End If
End Property

Public Property Let value(idx As Long, v As Long)
    If idx >= C_IDVDATFLD_INTEGRITAET And idx <= UBound(m_Value) Then
        m_Value(idx) = v
    End If
End Property

Public Sub InitFromDatei(ByRef dateiRS As Object)
    m_Value(C_IDVDATFLD_INTEGRITAET) = GetSafeFieldPlus(dateiRS, "Integritaet", 0)
    m_Value(C_IDVDATFLD_VERTRAULICHKEIT) = GetSafeFieldPlus(dateiRS, "Vertraulichkeitt", 0)
    m_Value(C_IDVDATFLD_VERFUEGBARKEIT) = GetSafeFieldPlus(dateiRS, "Verfuegbarkeit", 0)
    m_Value(C_IDVDATFLD_AUTHENTIZITAET) = GetSafeFieldPlus(dateiRS, "Authentizitaet", 0)
    m_Value(C_IDVDATFLD_SCHUTZBEDARF) = GetSafeFieldPlus(dateiRS, "Schutzbedarf", 0)
    m_Value(C_IDVDATFLD_INFORMATIONSKLASSE) = GetSafeFieldPlus(dateiRS, "Informationsklassifizierung", 0)
    m_Value(C_IDVDATFLD_BANKFACHLICH) = GetSafeFieldPlus(dateiRS, "Bankfachlich", 0)
    m_Value(C_IDVDATFLD_GOBD) = GetSafeFieldPlus(dateiRS, "GOBD", 0)
    m_Value(C_IDVDATFLD_FREMDENTWICKLUNG) = GetSafeFieldPlus(dateiRS, "Fremdentwicklung", 0)
End Sub

Public Function HasValidValues() As Boolean
    HasValidValues = False
    
    Dim i As Long
    For i = C_IDVDATFLD_INTEGRITAET To UBound(m_Value)
        If m_Value(i) > 0 Then
            HasValidValues = True
            Exit Function
        End If
    Next i
End Function

Public Sub SetMaxValuesPA(other As CFragenSchutzbedarf)
    Dim i As Long
    For i = 1 To C_MAXANTWORTFUNCFELDER
        If other.value(i) > m_Value(i) Then
            m_Value(i) = other.value(i)
        End If
    Next i
End Sub

Public Sub SetMaxValuesPAByRS(ByRef pars As Object)
    If m_Value(C_IDVDATFLD_SCHUTZBEDARF) < GetSafeFieldPlus(pars, "Schutzbedarf", 0) Then m_Value(C_IDVDATFLD_SCHUTZBEDARF) = GetSafeFieldPlus(pars, "Schutzbedarf", 0)
    If m_Value(C_IDVDATFLD_VERTRAULICHKEIT) < GetSafeFieldPlus(pars, "Vertraulichkeit", 0) Then m_Value(C_IDVDATFLD_VERTRAULICHKEIT) = GetSafeFieldPlus(pars, "Vertraulichkeit", 0)
    If m_Value(C_IDVDATFLD_INTEGRITAET) < GetSafeFieldPlus(pars, "Integritaet", 0) Then m_Value(C_IDVDATFLD_INTEGRITAET) = GetSafeFieldPlus(pars, "Integritaet", 0)
    If m_Value(C_IDVDATFLD_VERFUEGBARKEIT) < GetSafeFieldPlus(pars, "Verfuegbarkeit", 0) Then m_Value(C_IDVDATFLD_VERFUEGBARKEIT) = GetSafeFieldPlus(pars, "Verfuegbarkeit", 0)
    If m_Value(C_IDVDATFLD_INFORMATIONSKLASSE) < GetSafeFieldPlus(pars, "Informationsklassifizierung", 0) Then m_Value(C_IDVDATFLD_INFORMATIONSKLASSE) = GetSafeFieldPlus(pars, "Informationsklassifizierung", 0)
    If m_Value(C_IDVDATFLD_AUTHENTIZITAET) < GetSafeFieldPlus(pars, "Authentizitaet", 0) Then m_Value(C_IDVDATFLD_AUTHENTIZITAET) = GetSafeFieldPlus(pars, "Authentizitaet", 0)
End Sub

' Alles groesser 0 wird zugewiesen
Public Sub Assign(other As CFragenSchutzbedarf)
    Dim i As Long
    For i = 1 To C_MAXANTWORTFUNCFELDER
        If other.value(i) > 0 Then
            m_Value(i) = other.value(i)
        End If
    Next i
End Sub

Public Function MatchesOtherValue(idvdatfld As Long, ByRef sb As CFragenSchutzbedarf) As Boolean
    If idvdatfld < C_IDVDATFLD_INTEGRITAET Or idvdatfld > C_MAXANTWORTFUNCFELDER Then Exit Function
    If m_Value(idvdatfld) = sb.value(idvdatfld) Then
        MatchesOtherValue = True
    End If
End Function

' testen ob in dieser Instanz sich einer der Schutzbedarfswerte im Vergleich zu other reduziert hat
Public Function SchutzbedarfReduziert(other As CFragenSchutzbedarf) As Boolean
    SchutzbedarfReduziert = False
    
    If (value(C_IDVDATFLD_VERTRAULICHKEIT) > 0 And value(C_IDVDATFLD_VERTRAULICHKEIT) < other.value(C_IDVDATFLD_VERTRAULICHKEIT)) Or _
        (value(C_IDVDATFLD_VERFUEGBARKEIT) > 0 And value(C_IDVDATFLD_VERFUEGBARKEIT) < other.value(C_IDVDATFLD_VERFUEGBARKEIT)) Or _
        (value(C_IDVDATFLD_INTEGRITAET) > 0 And value(C_IDVDATFLD_INTEGRITAET) < other.value(C_IDVDATFLD_INTEGRITAET)) Or _
        (value(C_IDVDATFLD_AUTHENTIZITAET) > 0 And value(C_IDVDATFLD_AUTHENTIZITAET) < other.value(C_IDVDATFLD_AUTHENTIZITAET)) Then
         
        SchutzbedarfReduziert = True
    End If
        
End Function

Public Function SchutzbedarfVeraendert(other As CFragenSchutzbedarf) As Boolean
    SchutzbedarfVeraendert = False
    
    If (value(C_IDVDATFLD_VERTRAULICHKEIT) > 0 And value(C_IDVDATFLD_VERTRAULICHKEIT) <> other.value(C_IDVDATFLD_VERTRAULICHKEIT)) Or _
        (value(C_IDVDATFLD_VERFUEGBARKEIT) > 0 And value(C_IDVDATFLD_VERFUEGBARKEIT) <> other.value(C_IDVDATFLD_VERFUEGBARKEIT)) Or _
        (value(C_IDVDATFLD_INTEGRITAET) > 0 And value(C_IDVDATFLD_INTEGRITAET) <> other.value(C_IDVDATFLD_INTEGRITAET)) Or _
        (value(C_IDVDATFLD_AUTHENTIZITAET) > 0 And value(C_IDVDATFLD_AUTHENTIZITAET) <> other.value(C_IDVDATFLD_AUTHENTIZITAET)) Then
        
        SchutzbedarfVeraendert = True
    End If
        
End Function

Public Function ReplaceText(ByVal s As String) As String
  s = Replace(s, "#SCHUTZBEDARF#", GetSchutzbedarfTextFromLong(m_Value(C_IDVDATFLD_SCHUTZBEDARF), "Schutzbedarf"))
  s = Replace(s, "#VERFUEGBARKEIT#", GetSchutzbedarfTextFromLong(m_Value(C_IDVDATFLD_VERFUEGBARKEIT), "Verfuegbarkeit"))
  s = Replace(s, "#INTEGRITAET#", GetSchutzbedarfTextFromLong(m_Value(C_IDVDATFLD_INTEGRITAET), "Integritaet"))
  s = Replace(s, "#VERTRAULICHKEIT#", GetSchutzbedarfTextFromLong(m_Value(C_IDVDATFLD_VERTRAULICHKEIT), "Vertraulichkeit"))
  s = Replace(s, "#INFORMATIONSKLASSIFIZIERUNG#", GetInfklasseTextFromLong(m_Value(C_IDVDATFLD_INFORMATIONSKLASSE), "Informationsklassifizierung"))
  If G_cfgAuthentizitaetAnzeigen Then
    s = Replace(s, "#AUTHENTIZITAET#", GetSchutzbedarfTextFromLong(m_Value(C_IDVDATFLD_AUTHENTIZITAET), "Authentizitaet"))
  Else
    s = Replace(s, "#AUTHENTIZITAET#", "")
  End If
  ReplaceText = s
End Function

Public Function CalcSchutzbedarf() As Long
    Dim sb As Long
    sb = 0
    Dim i As Long
    For i = C_IDVDATFLD_INTEGRITAET To C_IDVDATFLD_VERTRAULICHKEIT
        If m_Value(i) > sb Then
            sb = m_Value(i)
        End If
    Next i
    ' m_Value(C_IDVDATFLD_SCHUTZBEDARF) = sb
    CalcSchutzbedarf = sb
End Function

Attribute VB_Name = "CLogEntry"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public m_Datetime As Date
Public m_DebugType As Long
Public m_Str As String
Public m_Dur As Double
Public m_LogExp As Long
Public m_idvDateiID As Long

Attribute VB_Name = "CProzess"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public Prozessschluessel As String
Public Prozessname As String
Public Prozesslandkarte As String
Public ebene3 As String
Public Integritaet As Integer
Public Verfuegbarkeit As Integer
Public Vertraulichkeit As Integer
Public Schutzbedarf As Integer
Public Informationsklassifizierung As Integer
Public LBText As String
Public Authentizitaet As Integer


'"Prozesschl|fffd|ssel"     ' A
'"Prozessname"         ' B
'"Prozesslandkarte"    ' C
'"Ebene3"              ' D

Public Function IsVisible(order() As String, ebeneSel() As String) As Boolean
    Dim i As Long
    For i = 0 To 2
        If ebeneSel(i) <> "" Then
            Select Case order(i)
            Case "Prozessname"
                If UCase(Prozessname) <> UCase(ebeneSel(i)) Then
                    Exit Function
                End If
            Case "Prozesslandkarte"
                If UCase(Prozesslandkarte) <> UCase(ebeneSel(i)) Then
                    Exit Function
                End If
            Case "Ebene3"
                If UCase(ebene3) <> UCase(ebeneSel(i)) Then
                    Exit Function
                End If
            End Select
        End If
    Next i
    IsVisible = True
End Function

Private Function GetColumnText(column As Long, order() As String) As String
    Select Case order(column)
    Case "Prozessschluessel"
        GetColumnText = Prozessschluessel
    Case "Prozessname"
        GetColumnText = Prozessname
    Case "Prozesslandkarte"
        GetColumnText = Prozesslandkarte
    Case "Ebene3"
        GetColumnText = ebene3
    End Select
End Function

Public Function GetColumnFilterText(column As Long, order() As String, sel() As String) As String
    Dim Text As String
    Text = GetColumnText(column, order)
    
    Dim prevSel As String
    If column > 0 Then
        If sel(column - 1) <> "" Then
            ' Checken was in der vorhergehenden Combobox selektiert ist
            prevSel = GetColumnText(column - 1, order)
            If prevSel = sel(column - 1) Then
                GetColumnFilterText = Text
            End If
            Exit Function
        End If
    End If
    ' Wenn  nix gefiltert wird, einfach zurueckgeben
    GetColumnFilterText = Text
End Function

Public Function GetLBText(column As Long, order() As String) As String
  Dim i As Long
  Dim item As Long
  item = 0
  For i = 0 To 3
    If order(i) <> "" Then
      If item = column Then
        GetLBText = GetLBColumnText(item)
        Exit Function
      End If
      item = item + 1
    End If
  Next i
End Function

Private Function GetLBColumnText(column As Long) As String
  Dim s As String
  Dim pos As Long
  Dim i As Long
  Dim e As Long
  pos = 1
  s = LBText
  For i = 0 To column - 1
      pos = InStr(pos, s, vbTab) + 1
  Next i
  ' Entweder bis zum naechsten Tab oder Ende des strings
  e = InStr(pos, s, vbTab) - 1
  If e <= 0 Then
      e = Len(s)
  End If
  GetLBColumnText = Mid(s, pos, e - pos + 1)
End Function

Public Function GetSchutzbedarfValues() As CFragenSchutzbedarf
    Dim schutz As New CFragenSchutzbedarf
    schutz.value(C_IDVDATFLD_INTEGRITAET) = Integritaet
    schutz.value(C_IDVDATFLD_VERTRAULICHKEIT) = Vertraulichkeit
    schutz.value(C_IDVDATFLD_VERFUEGBARKEIT) = Verfuegbarkeit
    schutz.value(C_IDVDATFLD_AUTHENTIZITAET) = Authentizitaet
    schutz.value(C_IDVDATFLD_SCHUTZBEDARF) = Schutzbedarf
    schutz.value(C_IDVDATFLD_INFORMATIONSKLASSE) = Informationsklassifizierung
    schutz.value(C_IDVDATFLD_BANKFACHLICH) = 0
    schutz.value(C_IDVDATFLD_GOBD) = 0
    schutz.value(C_IDVDATFLD_FREMDENTWICKLUNG) = 0
    Set GetSchutzbedarfValues = schutz
End Function

Attribute VB_Name = "CScriptObject"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private m_oWnd As Object
Private m_Object As Object

Private Sub Class_Initialize()
On Error Resume Next
    #If Win64 Then
      Set m_oWnd = CreateWindow()
      m_oWnd.execScript "Function CreateObjectx86(sProgID): Set CreateObjectx86 = CreateObject(sProgID): End Function", "VBScript"
      Set m_Object = m_oWnd.CreateObjectx86("MSScriptControl.ScriptControl")
      SetData
      AppActivate Application.Caption
    #Else
      Set m_Object = CreateObject("MSScriptControl.ScriptControl")
      If Not SetData() Then
        Set m_Object = Nothing
      End If
      If m_Object Is Nothing Then
        Set m_oWnd = CreateWindow()
        m_oWnd.execScript "Function CreateObjectx86(sProgID): Set CreateObjectx86 = CreateObject(sProgID): End Function", "VBScript"
        Set m_Object = m_oWnd.CreateObjectx86("MSScriptControl.ScriptControl")
        SetData
        AppActivate Application.Caption
      End If
    #End If

End Sub

Private Function SetData() As Boolean
On Error GoTo nogo:
  If Not m_Object Is Nothing Then
    m_Object.Language = "VBScript"
'    m_Object.AllowUI = False
  End If
  SetData = True
  Exit Function
nogo:
End Function


Private Sub Class_Terminate()

    If Not m_oWnd Is Nothing Then
      If InStr(TypeName(m_oWnd), "HTMLWindow") > 0 Then
        m_oWnd.Close
      End If
      Set m_oWnd = Nothing
    End If
    Set m_Object = Nothing
End Sub

Public Function GetObject() As Object
  Set GetObject = m_Object
End Function
Attribute VB_Name = "CShareInfo"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

'This example was submitted by Lee Carpenter
'
'It needs a class module and a form, with a label (m_lblStatus) on the form

'In the class module (CprgNetShareGetInfo)

Option Explicit

'local variable(s) to hold property value(s)
Private mvarstrServer As Variant 'local copy
Private mvarstrNetName As Variant 'local copy
Private mvarnType As Long 'local copy
Private mvarstrRemark As Variant 'local copy
Private mvarnCurrent_uses As Long 'local copy
Private mvarnMax_uses As Long 'local copy
Private mvarstrPath As Variant 'local copy
Private mvarnLastError As Long 'local copy
Private mvarstrLastError As Variant 'local copy
Private mvarNET_API_STATUS As Long 'local copy

'local variable(s) to hold internal value(s)

' Private constants, types and declares to call
'

Const STYPE_DISKTREE            As Long = 0
Const STYPE_PRINTQ              As Long = 1
Const STYPE_DEVICE              As Long = 2
Const STYPE_IPC                 As Long = 3
Const STYPE_SPECIAL             As Long = &H80000000

Const ERROR_SUCCESS             As Long = 0&
Const NERR_Success              As Long = 0&
Const ERROR_ACCESS_DENIED       As Long = 5&
Const ERROR_INVALID_LEVEL       As Long = 124&
Const ERROR_INVALID_PARAMETER   As Long = 87&
Const ERROR_MORE_DATA           As Long = 234&
Const ERROR_NOT_ENOUGH_MEMORY   As Long = 8&
Const ERROR_INVALID_NAME        As Long = 123&

Const NERR_BASE                 As Long = 2100&
Const NERR_NetNameNotFound      As Long = (NERR_BASE + 210)


Private Type SHARE_INFO_502
  shi502_netname      As Long   ' LPWSTR shi502_netname;
  shi502_type         As Long   ' DWORD shi502_type;
  shi502_remark       As Long   ' LPWSTR shi502_remark;
  shi502_permissions  As Long   ' DWORD shi502_permissions;
  shi502_max_uses     As Long   ' DWORD shi502_max_uses;
  shi502_current_uses As Long   ' DWORD shi502_current_uses;
  shi502_path         As Long   ' LPWSTR shi502_path;
  shi502_passwd       As Long   ' LPWSTR shi502_passwd;
  shi502_reserved     As Long   ' DWORD shi502_reserved;
  shi502_security_descriptor As Long ' PSECURITY_DESCRIPTOR shi502_security_descriptor;
End Type

Public Property Get NET_API_STATUS() As Long
'used when retrieving value of a property, on the right side of an assignment.
    NET_API_STATUS = mvarNET_API_STATUS
End Property

' Dirk Localization - wird von nirgendwo aufgerufen - also brauchen die Zuweisungen an mvarstrLastError auch nicht uebersetzt werden
'Public Property Get strLastError() As Variant
''used when retrieving value of a property, on the right side of an assignment.
'    If IsObject(mvarstrLastError) Then
'        Set strLastError = mvarstrLastError
'    Else
'        strLastError = mvarstrLastError
'    End If
'End Property

Public Property Get nLastError() As Long
'used when retrieving value of a property, on the right side of an assignment.
    nLastError = mvarnLastError
End Property

Public Property Get strPath() As Variant
'used when retrieving value of a property, on the right side of an assignment.
    If IsObject(mvarstrPath) Then
        Set strPath = mvarstrPath
    Else
        strPath = mvarstrPath
    End If
End Property

Public Property Get nMax_uses() As Long
'used when retrieving value of a property, on the right side of an assignment.
  nMax_uses = mvarnMax_uses
End Property

Public Property Get nCurrent_uses() As Long
'used when retrieving value of a property, on the right side of an assignment.
  nCurrent_uses = mvarnCurrent_uses
End Property

Public Property Get strRemark() As Variant
'used when retrieving value of a property, on the right side of an assignment.
    If IsObject(mvarstrRemark) Then
        Set strRemark = mvarstrRemark
    Else
        strRemark = mvarstrRemark
    End If
End Property

Public Property Get nType() As Long
'used when retrieving value of a property, on the right side of an assignment.
  nType = mvarnType
End Property

Public Property Get strType() As Variant
'used when retrieving value of a property, on the right side of an assignment.
  Select Case mvarnType
    Case STYPE_DISKTREE
      strType = "Disk Drive"
    Case STYPE_PRINTQ
      strType = "Print Queue"
    Case STYPE_DEVICE
      strType = "Communication device"
    Case STYPE_IPC
      strType = "Interprocess communication (IPC)"
    Case STYPE_SPECIAL
      strType = "Special share"
    Case Else
      strType = "Error: Unknown"
  End Select
End Property

Public Property Get strNetName() As Variant
'used when retrieving value of a property, on the right side of an assignment.
    If IsObject(mvarstrNetName) Then
        Set strNetName = mvarstrNetName
    Else
        strNetName = mvarstrNetName
    End If
End Property

Public Property Get strServer() As Variant
'used when retrieving value of a property, on the right side of an assignment.
    If IsObject(mvarstrServer) Then
        Set strServer = mvarstrServer
    Else
        strServer = mvarstrServer
    End If
End Property
Public Sub Initialize()

  ' Reset the everything
  '
  mvarnLastError = 0
  mvarstrLastError = ""
  mvarstrServer = ""
  mvarstrNetName = ""
  mvarnType = 0
  mvarstrRemark = ""
  mvarnCurrent_uses = 0
  mvarnMax_uses = 0
  mvarstrPath = ""

End Sub
Public Sub GetInfo(strShareName As Variant)
  Dim pNetName()  As Byte
  Dim pServer()   As Byte

#If VBA7 And Win64 Then
  Dim ptmpBuffer  As LongPtr
#Else
  Dim ptmpBuffer  As Long
#End If
  Dim tmpBuffer   As SHARE_INFO_502
  Dim strNetName  As String
  Dim x As Integer

  Call Initialize

  ' copy the network share name without leading spaces.
  '
  strNetName = LTrim(strShareName)

  ' check for leading server in the name.
  '
  If Left(strNetName, 2) = "\\" Then

    ' find the end of the server in the name
    '
    x = InStr(3, strNetName, "\")

    ' only a server in the name
    '
    If x = 0 Then
      mvarnLastError = ERROR_INVALID_NAME
      mvarstrLastError = "Need share name not server name."
      Exit Sub
    Else
      mvarstrServer = IIf(Left(strNetName, 2) = "\\", Mid(Left(strNetName, x - 1), 3), Left(strNetName, x - 1)) ' Left(strNetName, x - 1)
      strNetName = Mid(strNetName, x + 1)
    End If
  End If

  ' strip off any remaining leading \
  '
  If Left(strNetName, 1) = "\" Then
    strNetName = Mid(strNetName, 2)
  End If

  ' Find the end of the share name.
  '
  x = InStr(strNetName, "\")
  If x > 0 Then
    strNetName = Left(strNetName, x - 1)
  End If

  ' Check for drive letter
  '
  x = InStr(strNetName, ":")
  If x > 0 Then
    mvarnLastError = ERROR_INVALID_NAME
    mvarstrLastError = "Drive letter specified for share name."
    Exit Sub
  End If

  ' Convert the string to a UNI string, happens automatically.
  '
  pNetName = strNetName & vbNullChar

  If Len(mvarstrServer) > 0 Then

    ' format the server name
    '
    If Left(mvarstrServer, 2) = "\\" Then
      pServer = mvarstrServer & vbNullChar
    Else
      pServer = "\\" & mvarstrServer & vbNullChar
    End If
    ' Get the network infomation on the share.
    '
    mvarNET_API_STATUS = NetShareGetInfo _
    ( _
      pServer(0), _
      pNetName(0), _
      502, _
      ptmpBuffer _
    )
  Else
    ' Get the network infomation on the share.
    ' NOTE: the first parameter is the server name, by sending a
    ' null you are only looking at the current machine.
    '
    mvarNET_API_STATUS = NetShareGetInfo _
    ( _
      vbEmpty, _
      pNetName(0), _
      502, _
      ptmpBuffer _
    )
  End If

  ' Check for errors.
  '
  If mvarNET_API_STATUS <> NERR_Success Then
    Select Case mvarNET_API_STATUS
      Case ERROR_ACCESS_DENIED
        mvarstrLastError = "NetShareGetInfo: ERROR_ACCESS_DENIED"
      Case ERROR_INVALID_LEVEL
        mvarstrLastError = "NetShareGetInfo: ERROR_INVALID_LEVEL"
      Case ERROR_INVALID_PARAMETER
        mvarstrLastError = "NetShareGetInfo: ERROR_INVALID_PARAMETER"
      Case ERROR_MORE_DATA
        mvarstrLastError = "NetShareGetInfo: ERROR_MORE_DATA"
      Case ERROR_NOT_ENOUGH_MEMORY
        mvarstrLastError = "NetShareGetInfo: ERROR_NOT_ENOUGH_MEMORY"
      Case ERROR_INVALID_NAME
        mvarstrLastError = "NetShareGetInfo: ERROR_INVALID_NAME"
      Case NERR_NetNameNotFound
        mvarstrLastError = "NetShareGetInfo: NERR_NetNameNotFound"
      Case Else
        mvarstrLastError = "NetShareGetInfo: Unknown " & mvarNET_API_STATUS
    End Select
    mvarnLastError = mvarNET_API_STATUS
    Exit Sub
  End If

  ' Copy the return buffer to a type definition for processing.
  '
  Call CopyMemory(tmpBuffer, ptmpBuffer, LenB(tmpBuffer))

  ' save the return buffer information.
  '
  mvarstrNetName = UtoA(tmpBuffer.shi502_netname)
  mvarnType = tmpBuffer.shi502_type
  mvarstrRemark = UtoA(tmpBuffer.shi502_remark)
  mvarnCurrent_uses = tmpBuffer.shi502_current_uses
  mvarnMax_uses = tmpBuffer.shi502_max_uses
  mvarstrPath = UtoA(tmpBuffer.shi502_path)

  ' Free the buffer.
  '
  mvarNET_API_STATUS = NetApiBufferFree(ptmpBuffer)

  ' Check for errors.
  '
  If mvarNET_API_STATUS <> ERROR_SUCCESS Then
    mvarnLastError = mvarNET_API_STATUS
    mvarstrLastError = "NetApiBufferFree: Unknown"
    Exit Sub
  End If
End Sub
Private Function UtoA(pUNIstring As Long) As String
  Dim wrkByte()   As Byte
  Dim wrkStr      As String

  ' Get space for string each character is two bytes
  ' and a null terminator.
  '
  ReDim wrkByte(lstrlenW(pUNIstring) * 2 + 2)

  ' Copy the string to a byte array
  '
  Call lstrcpyW(wrkByte(0), pUNIstring)

  ' Covert the string from a UNI string to a ASCII string.
  ' this happens automatically when a byte array is copied
  ' to a string.
  '
  wrkStr = wrkByte

  ' return everything upto the the null terminator.
  '
  UtoA = Left(wrkStr, InStr(wrkStr, Chr(0)) - 1)
End Function



Attribute VB_Name = "CStringLong"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public m_S As String
Public m_L As Long
Attribute VB_Name = "CStringTouple"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public m_Name As String
Public m_Text As String

Sub Init(n As String, t As String)
  m_Name = n
  m_Text = t
End Sub
Attribute VB_Name = "CfgReader"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Dim m_Lines As Collection
Dim m_Sec As Collection

Private Function GetNextLine(ByRef s As String) As String

    Dim rs As String
    Do
        rs = GetLine(s)
        If Len(Trim(rs)) > 0 Then
            GetNextLine = Trim(rs)
            Exit Function
        End If
        If Len(Trim(s)) <= 0 Then
            GetNextLine = ""
            s = ""
            Exit Function
        End If
    Loop
End Function


Public Sub GetCFGString(ByVal txt As String)
    If m_Lines Is Nothing Then
      Set m_Lines = New Collection
      Set m_Sec = New Collection
    End If
    If Len(txt) = 0 Then Exit Sub
    Dim s As String
    Do
        s = GetNextLine(txt)
        If Len(s) <= 0 Then Exit Do
        If UCase(Left(s, 9)) = "MERGECFG " Then
          GetCfgUniversal Mid(s, 10)
        Else
          If Len(Trim(s)) > 0 Then
            m_Lines.add s
          End If
          m_Sec.add s
        End If
    Loop
End Sub

Function GetCfgUTF8(fname As String) As Boolean
  On Error GoTo couldntOpenFile
    Dim adoStream As Object
    Set adoStream = CreateObject("ADODB.Stream")
    
    adoStream.Charset = "UTF-8"
    adoStream.Open
    adoStream.LoadFromFile fname
    GetCFGString adoStream.ReadText
    adoStream.Close
    Set adoStream = Nothing
    GetCfgUTF8 = True
    Exit Function

couldntOpenFile:
  GetCfgUTF8 = False

End Function

Private Function GetEncodingString(encoding As Long) As String
    Select Case encoding
    Case CP_ACP: GetEncodingString = "ANSI"
    Case CP_UTF8: GetEncodingString = "UTF8"
    Case CP_UTF16_LE: GetEncodingString = "UTF16 LE"
    Case CP_UTF16_BE: GetEncodingString = "UTF16 BE"
    Case CP_UTF32_LE: GetEncodingString = "UTF32 LE"
    Case CP_UTF32_BE: GetEncodingString = "UTF32 BE"
    Case Else: GetEncodingString = "Codepage " & CStr(encoding)
    End Select
End Function

Private Function GetCfgUniversal(fname As String) As Boolean
  On Error GoTo couldntOpenFile
    'Dim ff As Long
    'ff = FreeFile
    'Call OpenForInput(fname, ff, encoding)
    Dim encoding As Long
    Dim fileContents As String
    Dim bom As Boolean
    fileContents = GetContents(fname, encoding, -1, bom)
    DebugPrint tinfo, fname & " opened with encoding: " & GetEncodingString(encoding) & IIf(bom, " BOM", " no BOM")
    
    Call GetCFGString(fileContents)
    GetCfgUniversal = True
    
    Exit Function

couldntOpenFile:
  GetCfgUniversal = False
End Function

Function GetCfg(fname As String) As Boolean
  On Error GoTo couldntOpenFile
  
  If Not FileExists(fname) Then Exit Function
  
  Set m_Lines = New Collection
  Set m_Sec = New Collection
  Call GetCfgUniversal(fname)
  
  GetCfg = True
  Exit Function
couldntOpenFile:
  GetCfg = False
End Function

Function GetSection(sec As String) As Boolean
  Set m_Sec = New Collection
  GetSection = GetSectionValues(sec, m_Sec)
End Function

Function GetValue(s As String) As String
  Dim i As Long
  If m_Sec Is Nothing Then Exit Function
  For i = 1 To m_Sec.count
    If Left(m_Sec(i), Len(s) + 1) = s & "=" Then
      GetValue = Trim(Mid(m_Sec(i), Len(s) + 2))
      Exit Function
    ElseIf Left(m_Sec(i), Len(s) + 1) = s & " " Then
        Dim pos As Long
        pos = InStr(m_Sec(i), "=")
        If pos > 0 Then
            GetValue = Trim(Mid(m_Sec(i), pos + 1))
            Exit Function
        End If
    End If
  Next i
  GetValue = ""
End Function

Function GetSectionValues(sec As String, ByRef c As Collection) As Boolean
  Set c = New Collection
  Dim i As Long
  Dim found As Boolean
  found = False
  If Not m_Lines Is Nothing Then
    For i = 1 To m_Lines.count
      If m_Lines(i) = "[" & sec & "]" Then
        i = i + 1
        Do While i <= m_Lines.count
          If Left(m_Lines(i), 1) <> "[" Then
            c.add m_Lines(i)
            found = True
            i = i + 1
          Else
            Exit Do
          End If
        Loop
      End If
      If i > m_Lines.count Then Exit For
    Next i
  End If
  GetSectionValues = found
End Function

Attribute VB_Name = "CollectionHelpers"
Option Explicit

'Sorts the given collection using the Arrays.MergeSort algorithm.
' O(n log(n)) time
' O(n) space
Public Sub MergeSort(col As Collection)
    Dim a() As Variant
    Dim b() As Variant
    a = CollectionHelpers.ToArray(col)
    ArrayHelpers.MergeSort a()
    Set col = CollectionHelpers.FromArray(a())
End Sub


'Returns an array which exactly matches this collection.
' Note: This function is not safe for concurrent modification.
Public Function ToArray(col As Collection) As Variant
    Dim a() As Variant
    ReDim a(0 To col.count)
    Dim i As Long
    For i = 0 To col.count - 1
        a(i) = col(i + 1)
    Next i
    ToArray = a()
End Function

'Returns a Collection which exactly matches the given Array
' Note: This function is not safe for concurrent modification.
Public Function FromArray(a() As Variant) As Collection
    Dim col As Collection
    Set col = New Collection
    Dim element As Variant
    For Each element In a
        col.add element
    Next element
    Set FromArray = col
End Function

Attribute VB_Name = "CreationTimes"
Option Explicit

' Datei Datum/Zeit
Private Type FILETIME
  dwLowDateTime As Long
  dwHighDateTime As Long
End Type
 
Private Const MAX_PATH As Long = 259&
 
Public Type WIN32_FIND_DATA
    dwFileAttributes As Long
    ftCreationTime As FILETIME
    ftLastAccessTime As FILETIME
    ftLastWriteTime As FILETIME
    nFileSizeHigh As Long
    nFileSizeLow As Long
    dwReserved0 As Long
    dwReserved1 As Long
    cFileName As String * MAX_PATH
    cAlternate As String * 14
End Type
 
Private Type SYSTEMTIME
  wYear As Integer
  wMonth As Integer
  wDayOfWeek As Integer
  wDay As Integer
  wHour As Integer
  wMinute As Integer
  wSecond As Integer
  wMilliSeconds As Integer
End Type
 
#If VBA7 And Win64 Then
' Done
Public Declare PtrSafe Function CloseHandle Lib "kernel32" (ByVal hObject As LongPtr) As Long
Private Declare PtrSafe Function GetFileTime Lib "kernel32" (ByVal hFile As LongPtr, lpCreationTime As FILETIME, lpLastAccessTime As FILETIME, lpLastWriteTime As FILETIME) As Long

Private Declare PtrSafe Function FileTimeToLocalFileTime Lib "kernel32" ( _
  lpFileTime As FILETIME, _
  lpLocalFileTime As FILETIME) As Long
 
Private Declare PtrSafe Function FileTimeToSystemTime Lib "kernel32" ( _
  lpFileTime As FILETIME, _
  lpSystemTime As SYSTEMTIME) As Long
 
Private Declare PtrSafe Function SystemTimeToFileTime Lib "kernel32" ( _
  lpSystemTime As SYSTEMTIME, _
  lpFileTime As FILETIME) As Long
 
Private Declare PtrSafe Function LocalFileTimeToFileTime Lib "kernel32" ( _
  lpLocalFileTime As FILETIME, _
  lpFileTime As FILETIME) As Long
 
Private Declare PtrSafe Function FindFirstFile Lib "kernel32" _
        Alias "FindFirstFileA" (ByVal lpFilename As String, _
        lpFindFileData As WIN32_FIND_DATA) As LongPtr
        
Private Declare PtrSafe Function FindNextFile Lib "kernel32" _
        Alias "FindNextFileA" (ByVal hFindFile As Long, _
        lpFindFileData As WIN32_FIND_DATA) As Long
        
Private Declare PtrSafe Function FindClose Lib "kernel32" (ByVal _
        hFindFile As LongPtr) As Long
#Else
Public Declare Function CloseHandle Lib "kernel32" ( _
  ByVal hObject As Long) As Long
 
Private Declare Function GetFileTime Lib "kernel32" ( _
  ByVal hFile As Long, _
  lpCreationTime As FILETIME, _
  lpLastAccessTime As FILETIME, _
  lpLastWriteTime As FILETIME) As Long
 
Private Declare Function FileTimeToLocalFileTime Lib "kernel32" ( _
  lpFileTime As FILETIME, _
  lpLocalFileTime As FILETIME) As Long
 
Private Declare Function FileTimeToSystemTime Lib "kernel32" ( _
  lpFileTime As FILETIME, _
  lpSystemTime As SYSTEMTIME) As Long
 
Private Declare Function SystemTimeToFileTime Lib "kernel32" ( _
  lpSystemTime As SYSTEMTIME, _
  lpFileTime As FILETIME) As Long
 
Private Declare Function LocalFileTimeToFileTime Lib "kernel32" ( _
  lpLocalFileTime As FILETIME, _
  lpFileTime As FILETIME) As Long
 
Private Declare Function FindFirstFile Lib "kernel32" _
        Alias "FindFirstFileA" (ByVal lpFilename As String, _
        lpFindFileData As WIN32_FIND_DATA) As Long
        
Private Declare Function FindNextFile Lib "kernel32" _
        Alias "FindNextFileA" (ByVal hFindFile As Long, _
        lpFindFileData As WIN32_FIND_DATA) As Long
        
Private Declare Function FindClose Lib "kernel32" (ByVal _
        hFindFile As Long) As Long

#End If
 
Private Const GENERIC_READ = &H80000000
Private Const GENERIC_WRITE = &H40000000
Private Const OPEN_EXISTING = 3
Private Const FILE_SHARE_READ = &H1
 
 
Sub TestTimes()
  Dim tCreation As Date
  Dim tLastAccess As Date
  Dim tLastWrite As Date
  Dim sFileName As String
   
  sFileName = "S:\xltest\110803re2.xls"
   
  ReadFileTime sFileName, tCreation, _
    tLastAccess, tLastWrite
   
  Dim Msg As String
  Msg = "Erstellungsdatum: "
  MsgBox Msg & _
    Format$(tCreation, "dd.mm.yyyy hh:mm:ss") & _
    vbCrLf & "Letzter Zugriff am: " & _
    Format$(tLastAccess, "dd.mm.yyyy hh:mm:ss") & _
    vbCrLf & "Letzter Schreibvorgang: " & _
    Format$(tLastWrite, "dd.mm.yyyy hh:mm:ss")

End Sub

 
 
' Datum/Zeit einer Datei ermitteln
Public Function ReadFileTime(ByVal lpFilename As String, _
  tCreation As Date, tLastAccess As Date, _
  tLastWrite As Date) As Boolean
    
    Dim file As String
    #If VBA7 And Win64 Then
      Dim hFile As LongPtr
    #Else
      Dim hFile As Long
    #End If
    Dim FD As WIN32_FIND_DATA
    Dim LocalFileTime As FILETIME
    Dim LocalSystemTime As SYSTEMTIME
        
    ' Die erste Datei suchen
    hFile = FindFirstFile(lpFilename, FD)
    
    ' Es konnte nichts gefunden werden
    If hFile = 0 Then
        ReadFileTime = False
        Exit Function
    End If
    
      FileTimeToLocalFileTime FD.ftCreationTime, LocalFileTime
      FileTimeToSystemTime LocalFileTime, LocalSystemTime
      With LocalSystemTime
        tCreation = CDate(Format$(DateSerial(.wYear, _
          .wMonth, .wDay), "Short Date") & " " & _
          Format$(.wHour) & ":" & _
          Format$(.wMinute, "00") & ":" & _
          Format$(.wSecond, "00"))
      End With
 
      ' Letzter Zugriff
      FileTimeToLocalFileTime FD.ftLastAccessTime, LocalFileTime
      FileTimeToSystemTime LocalFileTime, LocalSystemTime
      With LocalSystemTime
        tLastAccess = CDate(Format$(DateSerial(.wYear, _
          .wMonth, .wDay), "Short Date") & " " & _
          Format$(.wHour) & ":" & _
          Format$(.wMinute, "00") & ":" & _
          Format$(.wSecond, "00"))
      End With
 
      ' Letzte |fffd|nderung
      FileTimeToLocalFileTime FD.ftLastWriteTime, LocalFileTime
      FileTimeToSystemTime LocalFileTime, LocalSystemTime
      With LocalSystemTime
        tLastWrite = CDate(Format$(DateSerial(.wYear, _
          .wMonth, .wDay), "Short Date") & " " & _
          Format$(.wHour) & ":" & _
          Format$(.wMinute, "00") & ":" & _
          Format$(.wSecond, "00"))
      End With
    
    Call FindClose(hFile)
    
    ReadFileTime = True
            
End Function

Attribute VB_Name = "Crypter"
Option Explicit


Function Crypt(Inp As String, Key As String, encrypt As Boolean) As String
    Dim z As String
    Dim i As Integer, Position As Integer
    Dim cptZahl As Long, orgZahl As Long
    Dim keyZahl As Long, cptString As String
    
    For i = 1 To Len(Inp)
            Position = Position + 1
            If Position > Len(Key) Then Position = 1
            keyZahl = Asc(Mid(Key, Position, 1))
            
            If encrypt Then
            
                'Verschl|fffd|sseln
                orgZahl = Asc(Mid(Inp, i, 1))
                cptZahl = orgZahl Xor keyZahl
                cptString = Hex(cptZahl)
                If Len(cptString) < 2 Then cptString = "0" & cptString
                z = z & cptString
            
            Else
            
                'Entschl|fffd|sseln
                If i > Len(Inp) \ 2 Then Exit For
                cptZahl = CByte("&H" & Mid$(Inp, i * 2 - 1, 2))
                orgZahl = cptZahl Xor keyZahl
                z = z & Chr$(orgZahl)
            
            End If
        Next i
     
        Crypt = z
End Function


Attribute VB_Name = "DBHandler"
Option Explicit


Const dhcHKeyClassesRoot = &H80000000
Const dhcHKeyCurrentUser = &H80000001
Const dhcHKeyLocalMachine = &H80000002

Public Enum ERegistryValueTypes
'Predefined Value Types
    REG_NONE = (0)                         'No value type
    REG_SZ = (1)                           'Unicode nul terminated string
    REG_EXPAND_SZ = (2)                    'Unicode nul terminated string w/enviornment var
    REG_BINARY = (3)                       'Free form binary
    REG_DWORD = (4)                        '32-bit number
    REG_DWORD_LITTLE_ENDIAN = (4)          '32-bit number (same as REG_DWORD)
    REG_DWORD_BIG_ENDIAN = (5)             '32-bit number
    REG_LINK = (6)                         'Symbolic Link (unicode)
    REG_MULTI_SZ = (7)                     'Multiple Unicode strings
    REG_RESOURCE_LIST = (8)                'Resource list in the resource map
    REG_FULL_RESOURCE_DESCRIPTOR = (9)     'Resource list in the hardware description
    REG_RESOURCE_REQUIREMENTS_LIST = (10)
End Enum

Private Const KEY_QUERY_VALUE = &H1
Private Const KEY_ENUMERATE_SUB_KEYS = &H8
Private Const KEY_NOTIFY = &H10

Private Const KEY_READ = KEY_QUERY_VALUE Or _
                         KEY_ENUMERATE_SUB_KEYS Or KEY_NOTIFY

Public Const ERROR_SUCCESS = 0&

#If VBA7 And Win64 Then
' Done
Public Declare PtrSafe Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)

Private Declare PtrSafe Function RegOpenKeyEx Lib "advapi32.dll" Alias "RegOpenKeyExA" (ByVal hKey As LongPtr, ByVal lpSubKey As String, ByVal ulOptions As Long, ByVal samDesired As Long, phkResult As LongPtr) As Long
Private Declare PtrSafe Function RegQueryValue Lib "advapi32.dll" Alias "RegQueryValueA" (ByVal hKey As LongPtr, ByVal lpSubKey As String, ByVal lpValue As String, lpcbValue As Long) As Long
Private Declare PtrSafe Function RegQueryValueEx Lib "advapi32.dll" Alias "RegQueryValueExA" (ByVal hKey As LongPtr, ByVal lpValueName As String, ByVal lpReserved As LongPtr, lpType As Long, lpData As Any, lpcbData As Long) As Long         ' Note that if you declare the lpData parameter as String, you must pass it By Value.
Private Declare PtrSafe Function RegCloseKey Lib "advapi32.dll" (ByVal hKey As LongPtr) As Long

#Else
Public Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)

Private Declare Function RegOpenKeyEx Lib "advapi32" Alias "RegOpenKeyExA" _
  (ByVal hKey As Long, ByVal lpSubKey As String, ByVal ulOptions As Long, _
  ByVal samDesired As Long, phkResult As Long) As Long

Private Declare Function RegQueryValue Lib "advapi32.dll" Alias "RegQueryValueA" _
    (ByVal hKey As Long, ByVal lpSubKey As String, ByVal lpValue As String, lpcbValue _
    As Long) As Long

Private Declare Function RegQueryValueEx Lib "advapi32.dll" Alias "RegQueryValueExA" _
    (ByVal hKey As Long, ByVal lpValueName As String, ByVal lpReserved As _
    Long, lpType As Long, lpData As Any, lpcbData As Any) As Long

Private Declare Function RegCloseKey Lib "advapi32.dll" (ByVal hKey As Long) As Long

#End If

' Test

Function OpenRS(ByVal sqlstring As String, ByRef conn As Object, ByVal cursorytype As ADODB.CursorTypeEnum, ByVal locktype As ADODB.LockTypeEnum) As Object
        
        Dim rs As Object
        Set rs = CreateObject("ADODB.Recordset")
        On Error Resume Next

        Set OpenRS = Nothing
        Dim cnt As Long
        cnt = 0

        Dim tabname As String
        Dim pos As Integer
        pos = InStr(UCase(sqlstring), " FROM ")
        If pos > 0 Then
            Dim pos2 As Integer
            pos2 = InStr(pos + 6, sqlstring, " ")
            If pos2 > 0 Then
                tabname = Mid(sqlstring, pos + 6, pos2 - pos - 6)
            Else
                tabname = Mid(sqlstring, pos + 6)
            End If
        End If

        DebugPrint DebType.tdebug, tabname & " |fffd|ffnen-" & locktype & "-" & sqlstring

'        rs.CursorLocation = adUseClient

checkAgain:
        rs.Open sqlstring, conn, cursorytype, locktype
'        Debug.Print IsError(rs.Status)
        
        If err.Number <> 0 Then
            Dim terrs As String
            terrs = err.Number & "-" & err.Description
            err.Clear
            Sleep C_RepeatRSOpenSleep
            cnt = cnt + 1
            If cnt >= G_PARAM_TimeoutTableOpen / C_RepeatRSOpenSleep Then
                rs.Close
                Set rs = Nothing
#If PROJECT_IDVSCHEDULER = 0 Then
                DebugPrint DebType.tERROR, tabname & " |fffd|ffnen fehlgeschlagen-" & terrs
                
#End If
                Set OpenRS = Nothing
                Exit Function
            End If
            GoTo checkAgain
        End If

#If PROJECT_IDVSCHEDULER = 0 Then
        DebugPrint DebType.tTime, tabname & " erfolgreich"
#End If
        Set OpenRS = rs
    End Function

Function GetConnection(Optional ByVal waitendless As Boolean = False) As Object

        err.Clear
        On Error Resume Next
        
        Dim firstTest As Boolean
        Dim wasError As String

        
        If G_UserDeaktiviert Then
          Exit Function
        End If
        
        DebugPrint DebType.tdebug, "Connect Start"
        
'        Dim conn As New ADODB.Connection
        Dim conn As Object
        Set conn = CreateObject("ADODB.Connection")
        If G_Cursorlocation <> ADODB.adUseClient And G_Cursorlocation <> ADODB.adUseServer Then
          G_Cursorlocation = ADODB.adUseClient
        End If
        conn.CursorLocation = G_Cursorlocation
        Set GetConnection = Nothing
        Dim cnt As Long
        cnt = 0

        Dim tim As Single
        tim = Timer
checkAgain:
        conn.ConnectionTimeout = CLng(G_PARAM_TimeoutConnection / 1000)
        
        conn.Open G_DBConnectionString, G_DBUser, G_DBUserPasswort

        If err.Number <> 0 Then
            If Not firstTest Then
              wasError = err.Number & " - " & err.Description
              firstTest = True
            End If
        
            err.Clear
            Sleep C_RepeatConnOpenSleep
            cnt = cnt + 1
            If Not waitendless Then
                If Timer >= tim + G_PARAM_TimeoutConnection / 1000 Then
'                If cnt >= G_PARAM_TimeoutConnection / C_RepeatConnOpenSleep Then
                    Set conn = Nothing
#If PROJECT_IDVSCHEDULER = 0 Then
                    DebugPrint DebType.tERROR, "Connect fehlgeschlagen: " & wasError
#End If

                    Exit Function
                End If
                GoTo checkAgain
            End If
        End If
#If PROJECT_IDVSCHEDULER = 0 Then
        DebugPrint DebType.tTime, "Connect erfolgreich"
#End If
        ' Debug.Print conn.Properties("Jet OLEDB:Lock Delay")
        ' Debug.Print conn.Properties("Jet OLEDB:Lock Retry")
        
        conn.Execute "SET LOCK_TIMEOUT 5000"
        conn.Properties("Jet OLEDB:Lock Delay") = 5000 ' 90 + Int(Rnd * 60)
'        conn.Properties("Jet OLEDB:Lock Retry") = 1 ' 90 + Int(Rnd * 60)
        
        ' Oracle auf Case Insensitive umstellen
        conn.Execute "alter session set nls_comp=linguistic;"
        conn.Execute "alter session set nls_sort=binary_ci"
        
        err.Clear
        Set GetConnection = conn


End Function

Function GetValueFromField(ByRef rs As Object, fieldname As String, defvalue) As Variant
  On Error GoTo nogo
    
  GetValueFromField = defvalue
  If Not IsNull(rs.Fields(fieldname).value) Then
    GetValueFromField = rs.Fields(fieldname).value
  End If
  
nogo:
  
End Function

Function GetLocValueFromField(ByRef rs As Object, fieldname As String, locFieldName As String, defvalue) As Variant
  On Error GoTo nogo
    
  GetLocValueFromField = defvalue
  If Not IsNull(rs.Fields(locFieldName).value) Then
    GetLocValueFromField = rs.Fields(locFieldName).value
  ElseIf Not IsNull(rs.Fields(fieldname).value) Then
    GetLocValueFromField = rs.Fields(fieldname).value
  End If
  
nogo:
  
  
End Function

Function Verf|fffd|gbar(ByRef conn As Object) As Boolean
  
  On Error GoTo notok
  
  If G_cfgTestuser Then
    Verf|fffd|gbar = True
    Exit Function
  End If
  
  If G_UserDeaktiviert Then
    Verf|fffd|gbar = False
    Exit Function
  End If
  
  Dim rs As Object
  Verf|fffd|gbar = False
  Set rs = OpenRS("SELECT * FROM gParameterSystem", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
  If rs Is Nothing Then
      Exit Function
  End If

  If Not rs.EOF Then
  
      If IsNull(rs.Fields("GlobalLock").value) Then
        DebugPrint DebType.tERROR, "GlobalLock in gParameterSystem ist NULL (1)"
      ElseIf IsNull(rs.Fields("Deaktiviert").value) Then
        DebugPrint DebType.tERROR, "Deaktiviert in gParameterSystem ist NULL (1)"
      Else
        If rs.Fields("GlobalLock").value = False And rs.Fields("Deaktiviert").value = False Then
            Verf|fffd|gbar = True
        End If
      End If
  End If

  rs.Close
  Set rs = Nothing
  Exit Function
notok:
    DebugPrint DebType.tERROR, "Verf|fffd|gbar() fehlgeschlagen" & err.Number & " - " & err.Description & " - " & err.Source
End Function


Function Deaktiviert(ByRef conn As Object) As Boolean

    On Error GoTo notok

    Deaktiviert = False

    If G_cfgTestuser Then Exit Function

    If G_UserDeaktiviert Then
      Deaktiviert = True
      Exit Function
    End If
    
    Dim rs As Object
    Set rs = OpenRS("SELECT * FROM gParameterSystem", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)

    If rs Is Nothing Then
        Deaktiviert = True
        Exit Function
    End If

    If rs.EOF Then
        Deaktiviert = True
    Else
        If Not IsNull(rs.Fields("Deaktiviert").value) Then
          Deaktiviert = rs.Fields("Deaktiviert").value
        Else
          DebugPrint DebType.tERROR, "Deaktiviert in gParameterSystem ist NULL (2)"
          Deaktiviert = True
        End If
    End If
    rs.Close
    Set rs = Nothing
    Exit Function
notok:
    DebugPrint DebType.tERROR, "Deaktiviert() fehlgeschlagen" & err.Number & " - " & err.Description & " - " & err.Source
    Deaktiviert = True
End Function



Function IsRecordLocked(ByRef conn As Object, ByRef rst As Object, table As String, fld As String, testvalue As String) As Boolean
    
    On Error GoTo RecordLockedError
    
    With rst
        ' If no record is found, display message, return False, and exit.
        If .EOF Then
          IsRecordLocked = False
          GoTo IsRecordLockedExit
        End If
        
        ' Attempt to edit a value in the record. If this succeeds,
        ' return False; otherwise an error will be triggered.
        .Field(fld) = testvalue
        IsRecordLocked = False
    End With
    
IsRecordLockedExit:
    rst.CancelUpdate
    Exit Function
    
RecordLockedError:
    Select Case conn.Errors(0).SQLState
    ' Record is locked.
    Case 3260
      IsRecordLocked = True
      GoTo IsRecordLockedExit
    Case Else
      Resume Next
    End Select
End Function


Public Sub SetLastProgramStart(ByRef conn As Object)
    On Error Resume Next
    Dim drs As Object
    Set drs = CreateObject("ADODB.Recordset")
    drs.Open "SELECT * FROM idvLastAccess WHERE LogonID = '" & UCase(GetUserName) & "' AND ProgramID=" & MyAppID, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockOptimistic
    If drs.EOF Then
      drs.AddNew
    End If
    drs.Fields("LogonID").value = UCase(GetUserName)
    drs.Fields("ProgramID").value = MyAppID
    drs.Fields("AccessDate").value = Now
    drs.Update
    drs.Close
    Set drs = Nothing
End Sub

Public Function DCount(ByVal fld As String, ByVal table As String, Optional ByVal where As String = "") As Long
  
  On Error Resume Next
  Dim conn As Object
  Dim rs As Object
  Set conn = GetConnection()
  
  DCount = 0

  Dim query As String
  query = "SELECT count(" & fld & ") as v from " & table & " "
  If where <> "" Then
      query = query & " where " & where
  End If
  Set rs = OpenRS(query, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
  If Not rs Is Nothing Then
    If Not rs.EOF Then
      DCount = CLng(rs.Fields("v").value)
    End If
    rs.Close
    Set rs = Nothing
  End If
  conn.Close
  Set conn = Nothing
  
End Function

#If PROJECT_IDVSCHEDULER <> 1 Then
Sub DateiAlsGeloeschtMarkieren(ByRef curdoc As Object, fname As String)
On Error GoTo nogo

    Dim conn As Object
    Set conn = GetConnection()
    
    If conn Is Nothing Then
        'MsgBox "Diese Funktion ist zur Zeit nicht ausf|fffd|hrbar, da das System nicht zur Verf|fffd|gung steht. Bitte versuchen Sie es sp|fffd|ter noch einmal.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        MsgBox FMT0("DOKUPWD_3"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        Exit Sub
    End If

    If Deaktiviert(conn) Then
        'MsgBox "Aktuell steht diese Funktion nicht zur Verf|fffd|gung, da das System deaktiviert wurde. Bitte versuchen Sie es sp|fffd|ter noch einmal.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        MsgBox FMT0("DOKUPWD_4"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        conn.Close
        Set conn = Nothing
        Exit Sub
    End If

    Dim rs As Object
    Dim curid As Long
    Dim hash As String

    ' Wenn Sie bereits gespeichert wurde...
    If GetTargetRSFromFilename(conn, GetUNCPath(fname), rs, curid) Then
      rs.Close ' Kommt immer nur read only
      
      Set rs = OpenRS("SELECT idvDateiID, Geloescht FROM idvDateien WHERE idvDateiID = " & curid, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockPessimistic)
      If Not rs Is Nothing Then
        If Not rs.EOF Then
            rs.Fields("Geloescht").value = True
            rs.Fields("GeloeschtDatum").value = Now
            rs.Update
        End If
        rs.Close
      End If
    End If
    Set rs = Nothing
    conn.Close
    Set conn = Nothing
    
    Exit Sub

nogo:
    On Error Resume Next
    If Not rs Is Nothing Then
      If rs.state <> 0 Then
        rs.Close
      End If
      Set rs = Nothing
    End If
    
    If Not conn Is Nothing Then
      conn.Close
      Set conn = Nothing
    End If

End Sub
#End If

Function GetSafeField(ByRef rs As Object, ByVal fieldname As String) As String
  On Error Resume Next
  GetSafeField = ""
  If Not IsNull(rs.Fields(fieldname).value) Then
    GetSafeField = rs.Fields(fieldname).value
  End If
End Function

Function GetSafeFieldPlus(ByRef rs As Object, ByVal fieldname As String, Optional defaultVal As Variant) As Variant
  On Error GoTo nogo
  If Not IsNull(rs.Fields(fieldname).value) Then
    GetSafeFieldPlus = rs.Fields(fieldname).value
  Else
    If Not IsMissing(defaultVal) Then
      GetSafeFieldPlus = defaultVal
    End If
  End If
  Exit Function
nogo:
  If Not IsMissing(defaultVal) Then
    GetSafeFieldPlus = defaultVal
  End If
End Function

Function FieldExists(ByRef rs As Recordset, fldName As String) As Boolean
  On Error GoTo nogo
  Dim s As String
  s = rs.Fields(fldName).name
  FieldExists = True
  Exit Function
nogo:
End Function

Function GetUserAddress(username As String, ByRef conn As Object) As String
    
    Dim rs As Object
    Set rs = OpenRS("SELECT eMail FROM gWindowsUserAktuell WHERE LogonID='" & UCase(username) & "'", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
    
    If Not rs Is Nothing Then
      If Not rs.EOF Then
        GetUserAddress = rs.Fields("eMail").value
      End If
      rs.Close
      Set rs = Nothing
    End If

End Function

Sub GetDBUser(ByRef srccfg As CfgReader)
    Dim s As String
    
    If srccfg.GetSection("DB") = True Then
        s = srccfg.GetValue("USER")
        If s <> "" Then
            G_DBUser = Crypt(s, "uIq2%7/=}pJIi39x?", False)
        End If
        s = srccfg.GetValue("PASSWORD")
        If s <> "" Then
            G_DBUserPasswort = Crypt(s, "uIq2%7/=}pJIi39x?", False)
        End If
        s = srccfg.GetValue("DBTYPE")
        If s <> "" Then
            G_DBType = CLng(s)
        End If
        s = srccfg.GetValue("DBVERSION")
        If s <> "" Then
            G_DBVersion = CLng(s)
        End If
    End If

    If G_DBVersion > C_DBVersion Then
      G_UserDeaktiviert = True
      DebugPrint DebType.tdebug, "DB-Version nicht kompatibel, Plugin deaktiviert!"
    End If
End Sub

Function GetADGruppe(ByRef cfg As CfgReader) As String

    GetADGruppe = ""
    
    If cfg.GetSection("ADGRUPPEN") = True Then
#If PROJECT_ACCESSTRACKER = 0 Then
        GetADGruppe = cfg.GetValue("ETAD")
#Else
        GetADGruppe = cfg.GetValue("ATAD")
#End If
    End If

End Function


Function GetODBCConnection(ByVal odbcdsn As String, ByVal odbcuser As String, ByVal odbcpwd As String, Optional ByVal waitendless As Boolean = False) As Object

        err.Clear
        On Error Resume Next
        
        DebugPrint DebType.tdebug, "Connect Start"
        
'        Dim conn As New ADODB.Connection
        Dim conn As Object
        Set conn = CreateObject("ADODB.Connection")
        If G_Cursorlocation <> ADODB.adUseClient And G_Cursorlocation <> ADODB.adUseServer Then
          G_Cursorlocation = ADODB.adUseClient
        End If
        conn.CursorLocation = G_Cursorlocation
        Set GetConnection = Nothing
        Dim cnt As Long
        cnt = 0

        Dim tim As Single
        tim = Timer
checkAgain:
        
        If odbcuser <> "" And odbcpwd <> "" Then
          conn.Open odbcdsn, odbcuser, odbcpwd
        ElseIf odbcuser <> "" Then
          conn.Open odbcdsn, odbcuser
        Else
          conn.Open odbcdsn
        End If
        
        If err.Number <> 0 Then
            err.Clear
            Sleep C_RepeatConnOpenSleep
            cnt = cnt + 1
            If Not waitendless Then
                If Timer >= tim + G_PARAM_TimeoutConnection / 1000 Then
'                If cnt >= G_PARAM_TimeoutConnection / C_RepeatConnOpenSleep Then
                    Set conn = Nothing
#If PROJECT_IDVSCHEDULER = 0 Then
                    DebugPrint DebType.tERROR, "Connect fehlgeschlagen"
#End If
                    Exit Function
                End If
                GoTo checkAgain
            End If
        End If
#If PROJECT_IDVSCHEDULER = 0 Then
        DebugPrint DebType.tTime, "Connect erfolgreich"
#End If
        
        err.Clear
        Set GetConnection = conn


End Function




Function CheckDSNConnection(ByVal constr As String) As Boolean

  CheckDSNConnection = False
  err.Clear
  On Error Resume Next
  
  If G_UserDeaktiviert Then
    Exit Function
  End If
  
  DebugPrint DebType.tdebug, "Pr|fffd|fe Verbindung |fffd|ber " & constr
  
  Dim conn As Object
  Set conn = CreateObject("ADODB.Connection")
  If G_Cursorlocation <> ADODB.adUseClient And G_Cursorlocation <> ADODB.adUseServer Then
    G_Cursorlocation = ADODB.adUseClient
  End If
  conn.CursorLocation = G_Cursorlocation

  conn.ConnectionTimeout = CLng(G_PARAM_TimeoutConnection / 1000)
  
  conn.Open constr, G_DBUser, G_DBUserPasswort

  If err.Number <> 0 Then
    DebugPrint tdebug, "CheckDSNConnection Err: " & err.Number & " - " & err.Description
    err.Clear
  Else
    conn.Close
    CheckDSNConnection = True
  End If
  
  Set conn = Nothing

End Function



Public Function RegValueRead(ByRef root As Long, ByRef path As String, _
    ByVal ValueName As String, ByRef value As Variant, ByRef regtype As Long) As Boolean
    
    Dim Result As Long
#If VBA7 And Win64 Then
    Dim hKey As LongPtr
#Else
    Dim hKey As Long
#End If

    Dim lngBuffer As Long, strBuffer As String, DataLength As Long
    
    If RegOpenKeyEx(CLng(root), path, 0&, CLng(KEY_READ), hKey) = ERROR_SUCCESS Then
        If hKey <> 0 Then
            DataLength = 512
            strBuffer = Space$(DataLength)
            
            If ValueName = "" Then
                Result = RegQueryValue(hKey, vbNullString, ByVal strBuffer, DataLength)
                value = Left$(strBuffer, DataLength - 1)
            Else
                Result = RegQueryValueEx(hKey, ValueName, 0&, regtype, ByVal 0&, DataLength)
            
                If Result = ERROR_SUCCESS Then
                    
                    Select Case regtype
                      Case REG_DWORD
                        Dim tLong As Long
                        Result = RegQueryValueEx(hKey, ValueName, 0&, regtype, _
                            tLong, DataLength)
                        If Result = ERROR_SUCCESS Then value = CStr(tLong)
                      Case REG_SZ
                        Result = RegQueryValueEx(hKey, ValueName, 0&, regtype, _
                            ByVal strBuffer, DataLength)
                        If Result = ERROR_SUCCESS Then value = Left$(strBuffer, DataLength - 1)
                      Case Else
                        'MsgBox "UNKNOWN REG TYPE", vbCritical, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                        MsgBox FMT0("DBHANDLER_1"), vbCritical, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                    End Select
                End If
            End If
        End If
        
        If Result = ERROR_SUCCESS Then RegValueRead = True
        Call RegCloseKey(hKey)
    End If
End Function

Public Function RecordChanged(rst As Object) As Boolean
  On Error GoTo nogo:
  Dim fld As Field
  
  For Each fld In rst.Fields
     If fld.OriginalValue <> fld.value Then
        RecordChanged = True
        Exit Function
     End If
  Next
  Exit Function
nogo:
End Function

Sub ConnExecute(ByVal funccaller As String, ByRef conn As Object, ByVal sql As String)
  On Error GoTo nogo
  conn.Execute sql
  Exit Sub
nogo:
  Debug.Print tERROR, funccaller & ": " & err.Number & " - " & err.Description & " - " & " SQL: " & sql

End Sub
Attribute VB_Name = "Dateiausschluss"
Option Explicit


Private L_idvDateiAusschluss As Collection
Private L_idvVerzeichnisAusschluss As Collection

Function DateiAusgeschlossenVariable(ByRef wbInExcelCurrentProjectInAccess As Object) As Boolean
  DateiAusgeschlossenVariable = False
  If WBGetValueLong(wbInExcelCurrentProjectInAccess, "_IDVTrackerEx" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix) = 1 Then
    DateiAusgeschlossenVariable = True
  End If
End Function

Sub LoadDateiausschluesse(ByRef conn As Object)
  DebugPrint DebType.tdebug, "Lade Datei- und Verzeichnisausschluss"
  
  Dim chktxt As String
  Set L_idvDateiAusschluss = New Collection
  Dim filers As Object
  Set filers = OpenRS("SELECT Dateiname FROM idvDateiAusschluss", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
  
  If Not filers Is Nothing Then
    Do While Not filers.EOF
      If Not IsNull(filers.Fields("Dateiname").value) Then
        If Trim(filers.Fields("Dateiname").value) <> "" Then
          chktxt = Replace(UCase(filers.Fields("Dateiname").value), "%USERNAME%", UCase(GetUserName))
          chktxt = Replace(chktxt, "%1%", UCase(GetUserName))
          If Not CollectionStringExists(L_idvDateiAusschluss, chktxt) Then
            L_idvDateiAusschluss.add chktxt, chktxt
          End If
        End If
      End If
      filers.MoveNext
    Loop
  End If
  
  filers.Close
  Set filers = Nothing
  
  Set L_idvVerzeichnisAusschluss = New Collection
  Dim pathrs As Object
  Set pathrs = OpenRS("SELECT Verzeichnis FROM idvVerzeichnisAusschluss", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
  
  If Not pathrs Is Nothing Then
    Do While Not pathrs.EOF
      If Not IsNull(pathrs.Fields("Verzeichnis").value) Then
        If Trim(pathrs.Fields("Verzeichnis").value) <> "" Then
          chktxt = Replace(UCase(pathrs.Fields("Verzeichnis").value), "%USERNAME%", UCase(GetUserName))
          chktxt = Replace(chktxt, "%1%", UCase(GetUserName))
          If Not CollectionStringExists(L_idvVerzeichnisAusschluss, chktxt) Then
            L_idvVerzeichnisAusschluss.add chktxt, chktxt
          End If
        End If
      End If
      pathrs.MoveNext
    Loop
  End If
  
  pathrs.Close
  Set pathrs = Nothing
  
  DebugPrint DebType.tdebug, "Lade Datei- und Verzeichnisausschluss fertig"
End Sub

Function DateiAusgeschlossen2(ByRef wbInExcelCurrentProjectInAccess As Object, ByRef conn As Object) As Boolean
      
      On Error Resume Next
      
      If Mid(wbInExcelCurrentProjectInAccess.fullname, 2, 1) <> ":" And Left(wbInExcelCurrentProjectInAccess.fullname, 2) <> "\\" And Left(wbInExcelCurrentProjectInAccess.fullname, 2) <> "//" And InStr(wbInExcelCurrentProjectInAccess.fullname, "://") <= 0 Then Exit Function
      
      If L_idvDateiAusschluss Is Nothing Then
        LoadDateiausschluesse conn
      End If
      
      Dim sReason As String
      Dim erg As Boolean
      erg = DateiAusgeschlossen(wbInExcelCurrentProjectInAccess.fullname, sReason)
      Dim saved As Boolean
      saved = wbInExcelCurrentProjectInAccess.saved
      WBSetValueLong wbInExcelCurrentProjectInAccess, "_IDVTrackerEx" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, IIf(erg = True, 1, 0)
      wbInExcelCurrentProjectInAccess.saved = saved
      
      DateiAusgeschlossen2 = erg
      
      DebugPrint DebType.tdebug, "DateiAusschluss2-Fertig"

End Function

Function DateiAusgeschlossen(fname As String, ByRef txtReason As String) As Boolean
      
      On Error Resume Next
      
      If Mid(fname, 2, 1) <> ":" And Left(fname, 2) <> "\\" And Left(fname, 2) <> "//" And InStr(fname, "://") <= 0 Then Exit Function
      
      Dim i As Long
      Dim chktxt As String
      DateiAusgeschlossen = False
          
      Dim pfadOK As Boolean
      pfadOK = True
      
      Dim tfnameUNC As String
      Dim tfnameNormal As String
      tfnameUNC = UCase(GetUNCPath(fname))
      tfnameNormal = UCase(fname)
      
      If G_cfgNurScanpfade = True Then
        If Not G_Scanpfade Is Nothing Then
          If G_Scanpfade.count > 0 Then
            pfadOK = False
            Dim s As String
            DebugPrint DebType.tdebug, "Pr|fffd|fe Verzeichnis erlaubt?: " & tfnameNormal
            For i = 1 To G_Scanpfade.count
              chktxt = Replace(UCase(G_Scanpfade(i)), "%USERNAME%", UCase(GetUserName))
              If PatternIsStartMatching(tfnameNormal, chktxt) = True Or PatternIsStartMatching(tfnameUNC, chktxt) = True Then
                  pfadOK = True
                  Exit For
              End If
            Next i
          End If
        End If
      End If
      
      If Not pfadOK Then
        DebugPrint DebType.tdebug, "  --> AUSSCHLUSS: " & chktxt
        txtReason = "Filepath not allowed: " & chktxt
        DateiAusgeschlossen = True
        Exit Function
      End If

      If Not L_idvDateiAusschluss Is Nothing Then
        If L_idvDateiAusschluss.count > 0 Then
            DebugPrint DebType.tdebug, "Pr|fffd|fe Datei-Ausschluss: " & tfnameNormal
            For i = 1 To L_idvDateiAusschluss.count
                DebugPrint DebType.tdebug, "  --> Teste gegen: " & L_idvDateiAusschluss(i)
                If tfnameUNC = L_idvDateiAusschluss(i) Or tfnameNormal = L_idvDateiAusschluss(i) Or GetFileNameAndExtension(tfnameNormal) Like L_idvDateiAusschluss(i) Then
                    DebugPrint DebType.tdebug, "  --> AUSSCHLUSS: " & chktxt
                    txtReason = "Filename exlclusion: " & chktxt
                    DateiAusgeschlossen = True
                    Exit Function
                End If
            Next i
        End If
      End If

      If Not L_idvVerzeichnisAusschluss Is Nothing Then
        If L_idvVerzeichnisAusschluss.count > 0 Then
            DebugPrint DebType.tdebug, "Pr|fffd|fe Verzeichnis-Ausschluss: " & tfnameNormal
            For i = 1 To L_idvVerzeichnisAusschluss.count
              DebugPrint DebType.tdebug, "  --> Teste gegen: " & L_idvVerzeichnisAusschluss(i)
              If PatternIsStartMatching(tfnameNormal, L_idvVerzeichnisAusschluss(i)) = True Or PatternIsStartMatching(tfnameUNC, L_idvVerzeichnisAusschluss(i)) = True Then
                DebugPrint DebType.tdebug, "  --> AUSSCHLUSS: " & chktxt
                txtReason = "Path exlclusion: " & chktxt
                DateiAusgeschlossen = True
                Exit Function
              End If
            Next i
        End If
      End If
      DebugPrint DebType.tdebug, "Datei nicht ausgeschl: " & fname

End Function




Attribute VB_Name = "DebugStuff"
Option Explicit


Public G_PARAM_DebugInfosLoggen As Boolean

Public G_LogThisUser As Boolean
Public G_PARAM_CollectDebug As Boolean

Public G_LogToWindow As Boolean
Public G_LogWriteIgnore As Boolean

Private L_InDebugPrint As Boolean
Private L_Log As Collection
Private L_InitLogPrinted As Boolean

Public G_Log As String

Public Const G_LOG_EXTERNE_KOPIE As Long = 1              ' Die Datei wurde durch eine andere Datei au|fffd|erhalb des IDV-Tracker-Systems |fffd|berschrieben. Wahrscheinlich hat der User eine Datei mit dem Explorer |fffd|ber die Originaldatei kopiert.
Public Const G_LOG_NEUE_FREIGABE_ENTFERNT As Long = 2     ' F|fffd|r die Datei wurde eine neue Version erzeugt. Dadurch wurde die Programmfreigabe aufgehoben.
Public Const G_LOG_NEUE_VERSION As Long = 3               ' F|fffd|r die Datei wurde eine neue Version erzeugt.
Public Const G_LOG_BLATSCHUTZ_ENTFERNEN_INIT As Long = 4  ' Blattschutz-Entfernung initiiert
Public Const G_LOG_BLATTSCHUTZ_ENTFERNT As Long = 5       ' Blattschutz entfernt
Public Const G_LOG_BLATTSCHUTZ_ANGEBRACHT As Long = 6     ' Blattschutz angebracht

Private Sub SetConnectTimeout(ByRef conn)
  On Error Resume Next
  conn.Execute "SET LOCK_TIMEOUT 5000"
  conn.Properties("Jet OLEDB:Lock Delay") = 5000 ' 90 + Int(Rnd * 60)
  err.Clear
End Sub

#If NOLOGTODB = 0 Then
Sub AddTextToLogDB(ByVal logdate As Date, ByVal md As DebType, ByVal str As String, dur As Double, ByVal logExp As Long, ByVal idvDateiID As Long)
    
    On Error GoTo nogo
    
    Dim conn As Object
    
    If G_UserDeaktiviert And md <> 6 Then
      Exit Sub
    End If
    
    Set conn = GetConnection()
    If conn Is Nothing Then Exit Sub
    SetConnectTimeout conn

    Dim rs As Object
    Set rs = CreateObject("ADODB.Recordset")

    rs.Open "SELECT * FROM idvDateienEventLog WHERE EventTyp = -1", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockOptimistic
    
    If rs Is Nothing Then
      conn.Close
      Set conn = Nothing
      Exit Sub
    End If
    
    Do While Len(str) > 0
      rs.AddNew
      rs.Fields("EventTyp").value = md
      rs.Fields("EventLogErlaeuterungID").value = logExp
      rs.Fields("Datum").value = logdate
      rs.Fields("Text").value = Left(str, 255)
      rs.Fields("Zeit").value = dur
      rs.Fields("AppID").value = MyAppID
      rs.Fields("idvDateiID").value = idvDateiID
      rs.Fields("userLogonId").value = Left(GetUserNameUCASE, 24)
      rs.Update
      str = Mid(str, 255, 10000)
    Loop

nogo:
'    If Not rs Is Nothing Then
'      rs.Close
      Set rs = Nothing
'    End If
    
    If Not conn Is Nothing Then
      conn.Close
      Set conn = Nothing
    End If


End Sub
#End If

Sub DebugPrint(ByVal md As DebType, ByVal str As String, Optional ByVal dur As Double = 0, Optional ByVal logExp As Long = 0, Optional ByVal idvDateiID As Long = 0)

    If L_InDebugPrint Then Exit Sub
    
    G_ShowTextIDs = IIf(GetSetting(appname:="Stromwerken", Section:="Tracker", Key:="ShowTextIDs", Default:=0) = 1, True, False)
    

    L_InDebugPrint = True
'    Dim memusg As Long
    
    CheckLogSpace
    Dim errprefix As String
    
    ' Ausgabe f|fffd|r Debug-Window
    If md = DebType.tERROR Then
      If G_cfgShowMSGBoxForAllErrors Then
        MsgBox str, vbCritical, ProgNameLong & " - *ERROR* " & myVersion & " (Build: " & app.Revision & ")"
      End If
      errprefix = "*** ERR: "
    Else
      errprefix = " "
    End If
    
    G_Log = G_Log & IIf(G_Log <> "", vbCrLf, "") & GetTime(Now()) & errprefix & str
    
    If IsFormLoaded("frmAppInfo") Then
      If frmAppInfo.visible Then
        frmAppInfo.LogText.Text = G_Log
      End If
    End If
    
    If GetSetting(appname:="Stromwerken", Section:="Tracker", Key:="ShowLogWindow", Default:=0) = 1 And G_LogToWindow = False Then
      ShowLogWindow
    End If
    
    If GetSetting(appname:="Stromwerken", Section:="Tracker", Key:="ShowLogWindow", Default:=0) = 0 And G_LogToWindow = True Then
      HideLogWindow
    End If
    
    If IsFormLoaded("frmLogWindow") Then
      If frmLogWindow.visible Then
        frmLogWindow.LogText.Text = G_Log
      End If
    End If
    
    ' Wenn schon in die DB / ins File geschrieben werden darf...
    Dim cle As CLogEntry
    If G_AllowLoggingToStorage Then
      If Not L_Log Is Nothing Then
        For Each cle In L_Log
          DebugPrintToStorage cle.m_Datetime, cle.m_DebugType, cle.m_Str, cle.m_Dur, cle.m_LogExp, cle.m_idvDateiID
        Next cle
        Set L_Log = Nothing
      End If
      DebugPrintToStorage Now, md, str, dur, logExp, idvDateiID
    Else
      ' Ansonsten muss das Log im Ram gehalten werden
      If L_Log Is Nothing Then
        Set L_Log = New Collection
      End If
      Set cle = New CLogEntry
      cle.m_Datetime = Now
      cle.m_DebugType = md
      cle.m_Str = str
      cle.m_Dur = dur
      cle.m_LogExp = logExp
      cle.m_idvDateiID = idvDateiID
      L_Log.add cle
    End If

    L_InDebugPrint = False
End Sub

Private Sub DebugPrintToStorage(ByVal logdate As Date, ByVal md As DebType, ByVal str As String, Optional ByVal dur As Double = 0, Optional ByVal logExp As Long = 0, Optional ByVal idvDateiID As Long = 0)
  
  If md = tERROR Or _
       md = tMail Or _
       md = tSystem Or _
      (md = tdebug And (G_cfgDebugInfosLoggen = True Or G_PARAM_DebugInfosLoggen = True Or G_LogThisUser = True)) Or _
      (md = tinfo And (G_cfgDebugInfosLoggen = True Or G_PARAM_DebugInfosLoggen = True Or G_LogThisUser = True)) Or _
      (md = tTime And (G_cfgDebugInfosLoggen = True Or G_PARAM_DebugInfosLoggen = True Or G_LogThisUser = True)) Or _
       md = tSystemToFile Then
      
      If md = DebType.tERROR Then
      
          ' ERrors werden immer geloggt, auch in der DB
          #If PROJECT_PLUGINCHECK <> 1 Then
          AddTextToLogDB logdate, md, "Err: " & str, dur, logExp, idvDateiID
          #End If
          
          #If PROJECT_IDVSCHEDULER = 1 Then
            AddTextToLogfile logdate & "," & dur & ", Typ: " & md & ", ID: " & idvDateiID & ", " & Chr(34) & "Err: " & str & Chr(34), G_cfgLogpfad & "\" & ProgNameLong & "-" & GetUserName & ".txt"
          #Else
            If G_cfgDebugInfosLoggen = True Or G_PARAM_DebugInfosLoggen = True Or G_LogThisUser = True Then
              AddTextToLogfile logdate & "," & dur & ", Typ: " & md & ", ID: " & idvDateiID & ", " & Chr(34) & "Err: " & str & Chr(34), G_cfgLogpfad & "\" & ProgNameLong & "-" & GetUserName & ".txt"
            End If
          #End If
      Else
          ' Mails und System werden immer geloggt, auch in der DB
          #If PROJECT_PLUGINCHECK <> 1 Then
          If md = tMail Or md = tSystem Then
            AddTextToLogDB logdate, md, str, dur, logExp, idvDateiID
          End If
          #End If
          #If PROJECT_IDVSCHEDULER = 1 Then
            AddTextToLogfile logdate & "," & dur & ", Typ: " & md & ", ID: " & idvDateiID & ", " & Chr(34) & str & Chr(34), G_cfgLogpfad & "\" & ProgNameLong & "-" & GetUserName & ".txt"
          #Else
            If G_cfgDebugInfosLoggen = True Or G_PARAM_DebugInfosLoggen = True Or G_LogThisUser = True Then
              AddTextToLogfile logdate & "," & dur & ", Typ: " & md & ", ID: " & idvDateiID & ", " & Chr(34) & str & Chr(34), G_cfgLogpfad & "\" & ProgNameLong & "-" & GetUserName & ".txt"
            End If
          #End If
      End If
  End If
End Sub


Public Function AddTextToLogfile(ByVal strData As String, _
     ByVal fullpath As String, _
       Optional ByVal ErrInfo As String = "") As Boolean

    On Error GoTo CatchEx

    If G_LogWriteIgnore = True Then Exit Function
    
    If Left(fullpath, 2) <> "\\" And Mid(fullpath, 2, 1) <> ":" Then Exit Function
    
    Dim fn As Long
    Dim cnt As Long
    cnt = 0
    
    fn = FreeFile
    Dim s As String

goAgain:

    If PathExists(GetPath(fullpath)) Then
      Do
        If FOpenAppend(fullpath, fn) Then
          Print #fn, strData
          Close fn
          AddTextToLogfile = True
          Exit Do
        Else
          Sleep 100
          cnt = cnt + 1
          If cnt >= 10 Then
            AddTextToLogfile = False
            G_LogWriteIgnore = True
'            If Not G_IgnoreFutureWriteWindows Then
'              'If MsgBox("ACHTUNG: Die Log-Datei kann nicht in '" & fullpath & "' gespeichert werden, vermutlich haben Sie keine Schreibrechte in diesem Ordner. Bitte informieren Sie die Administration. M|fffd|chten Sie, dass das Log in einem Fenster ausgegeben wird?", vbYesNo + vbCritical, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")") = vbYes Then
'              If MsgBox(FMT1("DEBUGSTUFF_1", fullpath), vbYesNo + vbCritical, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")") = vbYes Then
'                ShowLogWindow
'                G_IgnoreFutureWriteWindows = True
'              End If
'            End If
            Exit Function
          End If
        End If
      Loop
'    Else
'      G_LogWriteIgnore = True
'      'If MsgBox("ACHTUNG: Die Log-Datei kann nicht in '" & GetPath(fullpath) & "' gespeichert werden, der Pfad existiert nicht. Bitte informieren Sie die Administration. M|fffd|chten Sie, dass das Log in einem Fenster ausgegeben wird?", vbYesNo + vbCritical, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")") = vbYes Then
'      If MsgBox(FMT1("DEBUGSTUFF_3", GetPath(fullpath)), vbYesNo + vbCritical, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")") = vbYes Then
'        ShowLogWindow
'      End If
    End If
    Exit Function

CatchEx:

End Function


Public Function AddTextToFile(ByVal strData As String, _
    ByVal fullpath As String, _
       Optional ByVal ErrInfo As String = "") As Boolean

    On Error GoTo CatchEx

    Dim fn As Long
    Dim cnt As Long
    cnt = 0
    
    fn = FreeFile
    Dim s As String

goAgain:

    If PathExists(GetPath(fullpath)) Then
      Do
        If FOpenAppend(fullpath, fn) Then
          Print #fn, strData
          Close fn
          AddTextToFile = True
          Exit Do
        Else
          Sleep 100
          cnt = cnt + 1
          If cnt >= 10 Then
            AddTextToFile = False
            If Not G_IgnoreFutureWriteWindows Then
              'MsgBox "ACHTUNG: Die Datei '" & fullpath & "' kann nicht gespeichert werden, vermutlich haben Sie keine Schreibrechte in diesem Ordner. Bitte informieren Sie die Administration.", vbCritical, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
              MsgBox FMT1("DEBUGSTUFF_4", fullpath), vbCritical, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
              G_IgnoreFutureWriteWindows = True
            End If
            Exit Function
          End If
        End If
      Loop
'    Else
'      'MsgBox "ACHTUNG: Die Datei kann nicht in '" & GetPath(fullpath) & "' gespeichert werden, der Pfad existiert nicht. Bitte informieren Sie die Administration.", vbCritical, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
'      MsgBox FMT1("DEBUGSTUFF_5", GetPath(fullpath)), vbCritical, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
    End If
    Exit Function

CatchEx:

End Function


Private Function FOpenAppend(fname As String, ByRef fn As Long) As Boolean
  On Error GoTo nogo
  Open fname For Append As fn
  FOpenAppend = True
  Exit Function
nogo:
        
End Function


Sub ShowLogWindow()
  If G_LogToWindow = False Then
    G_LogToWindow = True
    'frmLogWindow.Caption = ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")" & " - Log..."
    frmLogWindow.Caption = ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
    If Not IsFormLoaded("frmLogWindow") Then Load frmLogWindow
    frmLogWindow.Show vbModeless
    If IsFormLoaded("frmLogWindow") Then
      If frmLogWindow.visible Then
        frmAppInfo.LogText = G_Log
      End If
    End If
  End If
End Sub

Sub HideLogWindow()
  If G_LogToWindow = True Then
    G_LogToWindow = False
    frmLogWindow.Hide
    Unload frmLogWindow
  End If
End Sub

Sub CheckLogSpace()
  If Len(G_Log) > 15500 Then
    Dim pos As Long
    pos = InStr(G_Log, vbCrLf)
    If pos > 0 Then
      G_Log = Mid(G_Log, pos)
    Else
      G_Log = Right(G_Log, 15500)
    End If
  End If
End Sub

Attribute VB_Name = "DieseArbeitsmappe"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Private Sub Workbook_Open()
    MyWorkbookOpen
    Exit Sub
    If G_UserDeaktiviert Then
      If G_LogToWindow = False Then
        If Not EmbeddedObjectOpened() Then
          ThisWorkbook.Close False
          Exit Sub
        End If
      End If
    End If
End Sub

Private Function EmbeddedObjectOpened() As Boolean

On Error Resume Next
  Dim wb As Workbook
  For Each wb In Workbooks
    If wb.IsInplace Then
      EmbeddedObjectOpened = True
      Exit Function
    End If
  Next wb
End Function


Private Sub Workbook_BeforeClose(Cancel As Boolean)
    app.Kill
    Set app = Nothing
    CleanUpTempFiles
    HideLogWindow
End Sub


Attribute VB_Name = "DocInfo"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit


    Public m_Ersteller As String
    Public m_Erstellungsdatum As Date
    Public m_Macros As Long
    Public m_ExtRefs As Long

    Public m_Sheets As Long   ' In Excel Tabellenbl|fffd|tter, in Access Tabellen

    Public m_FileSizeInKB As Long
    Public m_NoFormulaCount As Boolean

    
#If PROJECT_ACCESSTRACKER = 0 Then
    Public m_Formulas As Long
    Public m_UnprotectedWorksheetsWithFormulas As Long
    Public m_Protectedsheets As Long
    Public m_Unprotectedformulas As Long
    Public m_HadProtectedSheets As Boolean
#End If

Function CreateCopy() As DocInfo
  Dim di As New DocInfo
  
  di.m_Ersteller = m_Ersteller
  di.m_Erstellungsdatum = m_Erstellungsdatum
  di.m_Macros = m_Macros
  di.m_ExtRefs = m_ExtRefs
  di.m_Sheets = m_Sheets
  di.m_FileSizeInKB = m_FileSizeInKB
  di.m_NoFormulaCount = m_NoFormulaCount
  
#If PROJECT_ACCESSTRACKER = 0 Then
  di.m_Formulas = m_Formulas
  di.m_UnprotectedWorksheetsWithFormulas = m_UnprotectedWorksheetsWithFormulas
  di.m_Protectedsheets = m_Protectedsheets
  di.m_Unprotectedformulas = m_Unprotectedformulas
  di.m_HadProtectedSheets = m_HadProtectedSheets
#End If
  Set CreateCopy = di
End Function

Attribute VB_Name = "ExcelStuff"
Option Explicit

#If PROJECT_ACCESSTRACKER = 0 Then
Public G_XLSaver As XLSaver
#End If

Private LastPassword As String
Function GetProtFormulasCount(ByRef ws As Worksheet) As Long
  
  On Error Resume Next
  
  GetProtFormulasCount = 0
  Dim r As Range
  Set r = ws.Cells.SpecialCells(Excel.XlCellType.xlCellTypeLastCell)
  
  If r Is Nothing Then Exit Function
  
  Dim y As Long
  Dim x As Long
  For y = 1 To r.Row
    For x = 1 To r.column
      If ws.Cells(y, x).HasFormula Then
        GetProtFormulasCount = GetProtFormulasCount + 1
      End If
    Next x
  Next y
End Function

Sub CountProtectedFormulas(ByRef xlapp As Excel.Application, fname As String)
Exit Sub
  If G_DocInfo.m_NoFormulaCount Then Exit Sub

  G_NoStartup = True
  xlapp.EnableEvents = False
  xlapp.DisplayAlerts = False
  
  If G_PARAM_HinweisfensterBeiPasswortanalyse Then
    BitteWarten.Show
    DoEvents
    BitteWarten.Refresh
  End If
  
  Dim app As Excel.Application
  Set app = CreateObject("Excel.Application")
  
  app.EnableEvents = False
  app.visible = False
  
  Dim formelRange As Excel.Range
  Dim oxlwbook As Excel.Workbook
  If GetFile(app, fname, oxlwbook) = True Then
    Dim ws As Worksheet
    
    Dim tim As Single
    tim = Timer
  
    For Each ws In oxlwbook.Sheets
      If ws.ProtectContents Then
        If RemovePW(ws, tim) Then
          Set formelRange = GetFormulaRange(ws)
          Dim i As Long
          i = 0
          Dim dotcount As Long
          If Not formelRange Is Nothing Then
              G_DocInfo.m_Formulas = G_DocInfo.m_Formulas + formelRange.count
              Dim item As Range
              For Each item In formelRange
                If Not item.Locked Then
                  G_DocInfo.m_Unprotectedformulas = G_DocInfo.m_Unprotectedformulas + 1
                End If
                i = i + 1
                If i > 800 Then
                  i = 0
                  dotcount = dotcount + 1
                  If dotcount = 4 Then dotcount = 0
                  If G_PARAM_HinweisfensterBeiPasswortanalyse Then
                    'BitteWarten.BitteWartenText.Caption = "Bitte warten, Datei wird gespeichert" & IIf(dotcount = 3, "...", IIf(dotcount = 2, "..", IIf(dotcount = 1, ".", "")))
                    BitteWarten.BitteWartenText.Caption = FMT0("EXCELSTUFF_1") & IIf(dotcount = 3, "...", IIf(dotcount = 2, "..", IIf(dotcount = 1, ".", "")))
                  End If
                  DoEvents
                End If
              Next item
          End If
        Else
          Exit For
        End If
'      Else
'        Set formelRange = GetFormulaRange(ws)
'        If Not formelRange Is Nothing Then
'            retval = retval + formelRange.Count
'            unprot = unprot + formelRange.Count
'        End If
      End If
    Next ws
  End If
  
  If Not oxlwbook Is Nothing Then
    oxlwbook.Close False
  End If
  
  Set oxlwbook = Nothing
  
  G_OnDisconnectionCalled = False
  app.EnableEvents = True
  app.Quit
  Set app = Nothing
  
  If G_PARAM_HinweisfensterBeiPasswortanalyse Then
    BitteWarten.Hide
  End If
  xlapp.EnableEvents = True
  xlapp.DisplayAlerts = True
  
  
  Dim cnt As Long
  cnt = 0
  Do While Not G_OnDisconnectionCalled
    DoEvents
    Sleep 200
    cnt = cnt + 1
    If cnt = 20 Then
      G_OnDisconnectionCalled = True
      Exit Do
    End If
  Loop
  G_NoStartup = False
End Sub


Function GetFormulaRange(ByRef oxlwsheet As Excel.Worksheet) As Excel.Range
    Set GetFormulaRange = Nothing
    On Error GoTo nogo
    Dim sav As Boolean
    sav = oxlwsheet.parent.saved
    Set GetFormulaRange = oxlwsheet.Cells.SpecialCells(Excel.XlCellType.xlCellTypeFormulas)
    If GetFormulaRange.count = 16777216 Then
        Set GetFormulaRange = Nothing
    End If
    oxlwsheet.parent.saved = sav
    Exit Function
nogo:
    Set GetFormulaRange = Nothing
    oxlwsheet.parent.saved = sav
End Function

Function GetFilter(ByRef xlapp As Excel.Application) As String
    Dim filter As String
    Dim lngIndex As Long

    filter = ""
    With xlapp.FileDialog(Office.msoFileDialogSaveAs).Filters
        For lngIndex = 1 To .count
            If Len(filter) > 0 Then
                filter = filter & "," & .item(lngIndex).Description & " (" & .item(lngIndex).Extensions & ")" & _
                  "," & .item(lngIndex).Extensions
            Else
                filter = filter & .item(lngIndex).Description & " (" & .item(lngIndex).Extensions & ")" & _
                  "," & .item(lngIndex).Extensions
            End If

        Next
    End With

    GetFilter = filter
End Function



Function GetFile(ByRef xlapp As Excel.Application, filename As String, ByRef oxlwbook As Excel.Workbook) As Boolean
  Dim msgBoxText                As String
  
  GetFile = True
  ' |fffd|ffnen der Datei - Bei Error auf Passwort pr|fffd|fen
  On Error GoTo hatPasswort
  Dim oldenev As Boolean
  oldenev = xlapp.EnableEvents
  xlapp.EnableEvents = False
  
'  If UCase(right(Filename, 5)) = ".XLSX" Then
'    GetFile = False
'    Exit Function
'  End If
  
  Set oxlwbook = xlapp.Workbooks.Open(filename, False, True, , "Testpasswort", , True, , , True, False, , False)
  SaveSetting _
     appname:="Stromwerken", _
     Section:=progNameShort, _
     Key:="LiveStatusCaption", _
     Setting:=xlapp.Caption ' Application.Caption
  xlapp.EnableEvents = oldenev
  GoTo openOk
  
hatPasswort:

    ' Sollte die Datei ein Passwort haben, dann geben wir einen enstprechenden Text aus
'    If Len(MassenMappe) > 0 Then
        ' Ansonsten wird nur beim Status eingetragen, dass die Datei gesch|fffd|tzt ist
'        Workbooks(MassenMappe).Sheets(Texte(GSprache, TXT_ANS_MASSENANALYSE)).Cells(line, tabxM2).Value = Texte(GSprache, TXT_DATEVGESCH) & " (" & Err.Description & ")"
'    End If
    On Error GoTo 0
    
    GetFile = False
    Exit Function
openOk:
  ' On Error wieder zur|fffd|cksetzen
  On Error GoTo 0
      

End Function

Function RemovePW(oxlwsheet As Excel.Worksheet, tim As Single) As Boolean
  On Error Resume Next
  Dim Pwc As Long
  
  oxlwsheet.Activate
  
  If oxlwsheet.ProtectContents = False Then
    Exit Function
  End If
  
  If Len(LastPassword) > 0 Then
    oxlwsheet.Unprotect LastPassword
    If oxlwsheet.ProtectContents = False Then
        RemovePW = True
        Exit Function
    End If
  End If
  
  Dim MyIndex, FileNumber
  Dim tpw As String
  If FileExists(GetStorePath(tPassword) & "ECCPW.bin") Then
    FileNumber = FreeFile
    
    If Not MyOpenFile(FileNumber, GetStorePath(tPassword) & "ECCPW.bin", tInput) Then
        RemovePW = False
        Exit Function
    End If
    
    Do While Not EOF(FileNumber)
      Input #1, tpw
      tpw = DecodePassword(tpw)
      oxlwsheet.Unprotect tpw
      If oxlwsheet.ProtectContents = False Then
        Close #FileNumber
        RemovePW = True
        Exit Function
      End If
    Loop
    Close #FileNumber   ' Close file.
  End If

  Dim t As Long
  t = 0
  Dim dotcount As Long


  Dim tFnameColl As Collection
  Set tFnameColl = New Collection
  

  Dim tI As Long
  tI = 0
  
  Dim csl As CStringLong
  If FileExists(GetStorePath(tPassword) & "ECCPWPart" & GetUserName & ".bin") Then
    FileNumber = FreeFile
    If Not MyOpenFile(FileNumber, GetStorePath(tPassword) & "ECCPWPart" & GetUserName & ".bin", tInput) Then
        RemovePW = False
        Exit Function
    End If
    If err.Number = 0 Then
      Do While Not EOF(FileNumber)
        Input #1, tpw
        Set csl = New CStringLong
        csl.m_S = tpw
        Input #1, tI
        csl.m_L = tI
        tFnameColl.add csl, tpw
      Loop
      Close #FileNumber   ' Close file.
    End If
  End If

  Dim a(0 To 17) As Byte, i&, K%, b
  
  If CollectionObjectExists(tFnameColl, "F" & oxlwsheet.parent.fullname & "|" & oxlwsheet.name) Then
    tI = tFnameColl("F" & oxlwsheet.parent.fullname & "|" & oxlwsheet.name).m_L
  Else
    Set csl = New CStringLong
    csl.m_S = "F" & oxlwsheet.parent.fullname & "|" & oxlwsheet.name
    csl.m_L = 0
    tFnameColl.add csl, "F" & oxlwsheet.parent.fullname & "|" & oxlwsheet.name
  End If
  
  For i = tI To 2 ^ 17
      For K = 0 To 17
          a(17 - K) = Asc(CStr(Abs((i And 2 ^ K) = 0)))
      Next
      Pwc = Pwc + 1
      
      t = t + 1
      If t > 400 Then
        t = 0
        dotcount = dotcount + 1
        If dotcount = 4 Then dotcount = 0
        If G_PARAM_HinweisfensterBeiPasswortanalyse Then
          'BitteWarten.BitteWartenText.Caption = "Bitte warten, Datei wird gespeichert" & IIf(dotcount = 3, "...", IIf(dotcount = 2, "..", IIf(dotcount = 1, ".", "")))
          BitteWarten.BitteWartenText.Caption = FMT0("EXCELSTUFF_1") & IIf(dotcount = 3, "...", IIf(dotcount = 2, "..", IIf(dotcount = 1, ".", "")))
        End If
        DoEvents
      End If
      
      oxlwsheet.Unprotect StrConv(a, vbUnicode)
      If oxlwsheet.ProtectContents = False Then
        LastPassword = StrConv(a, vbUnicode)
        StorePasswordToFile LastPassword
        tFnameColl.Remove "F" & oxlwsheet.parent.fullname & "|" & oxlwsheet.name
        StoreParts tFnameColl
        Set tFnameColl = Nothing
        RemovePW = True
        Exit Function
      End If
      If i Mod 400 = 0 Then
        If Timer >= tim + G_PARAM_PasswortanalyseInSec Then
          
'          Debug.Print Timer, tim
          tFnameColl("F" & oxlwsheet.parent.fullname & "|" & oxlwsheet.name).m_L = i
          StoreParts tFnameColl
          Set tFnameColl = Nothing
          RemovePW = False
          Exit Function
        End If
      End If
  Next
  
  StoreParts tFnameColl
  Set tFnameColl = Nothing
  RemovePW = False
  
End Function

Function GetHeaderFooterText(ByRef conn As Object, ByVal txt As String, ByRef wb As Workbook, ByRef officeapp As Object) As String

  Dim riskTxt As String
  Dim freigabeTxt As String

  If InStr(txt, "#RISIKO#") > 0 Or InStr(txt, "#FREIGABESTATUS#") > 0 Then
    riskTxt = "Keine Verbindung zur DB"
    freigabeTxt = "Nicht freigegeben"
    Dim dateiRS As Object
    Set dateiRS = OpenRS("SELECT Risikowert, Freigabestatus, RisikoklasseIDBeiEinwertung FROM idvDateien WHERE idvDateiID=" & WBGetValueLong(officeapp, "_IDVTrackerID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix) & " AND Version=" & WBGetValueLong(officeapp, "_IDVTrackerVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix), conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
    If Not dateiRS Is Nothing Then
      If Not dateiRS.EOF Then
        If Not IsNull(dateiRS.Fields("RisikoklasseIDBeiEinwertung").value) Then
          riskTxt = Format(dateiRS.Fields("Risikowert").value * 100, "0") & "%"
          Dim riskrs As Object
          Set riskrs = CreateObject("ADODB.Recordset")
          
          Dim queryRisk As String
          queryRisk = "SELECT Risikoklassenkennzeichen, uKennzeichen.LokalisierterText as LocKennzeichen " & _
            " FROM (gRisikoklasseHistorie left join gTexteUebersetzungen uKennzeichen on (gRisikoklasseHistorie.TextID = uKennzeichen.TextID and uKennzeichen.LanguageID = " & GetMyDBLanguage(conn) & ")) " & _
            " WHERE RisikoklasseID = " & dateiRS.Fields("RisikoklasseIDBeiEinwertung").value
          
          riskrs.Open queryRisk, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
          If Not riskrs.EOF Then
              riskTxt = GetLocValueFromField(riskrs, "Risikoklassenkennzeichen", "LocKennzeichen", "")
          End If
          riskrs.Close
          Set riskrs = Nothing
        Else
          'riskTxt = "Unbewertet"
          riskTxt = FMT0("DOKUALG_60")
        End If
          
        'If dateiRS.Fields("Freigabestatus").value = 1 Then freigabeTxt = "Freigabe initiiert"
        If dateiRS.Fields("Freigabestatus").value = 1 Then freigabeTxt = FMT0("EXCELSTUFF_2")
        'If dateiRS.Fields("Freigabestatus").value = 2 Then freigabeTxt = "Freigegebene Datei"
        If dateiRS.Fields("Freigabestatus").value = 2 Then freigabeTxt = FMT0("EXCELSTUFF_3")

      Else
        'riskTxt = "Unbewertet"
          riskTxt = FMT0("DOKUALG_60")
      End If
      dateiRS.Close
      Set dateiRS = Nothing
    End If
  End If

  If InStr(txt, "#RISIKO#") > 0 Then
    txt = Replace(txt, "#RISIKO#", riskTxt)
  End If
  
  If InStr(txt, "#FREIGABESTATUS#") > 0 Then
    txt = Replace(txt, "#FREIGABESTATUS#", freigabeTxt)
  End If
  

  If InStr(txt, "#DATUMUHRZEIT#") > 0 Then
    txt = Replace(txt, "#DATUMUHRZEIT#", Now)
  End If

  If InStr(txt, "#DATEINAMEUNC#") > 0 Then
    txt = Replace(txt, "#DATEINAMEUNC#", GetUNCPath(wb.fullname))
  End If

  If InStr(txt, "#DATEINAME#") > 0 Then
    txt = Replace(txt, "#DATEINAME#", wb.fullname)
  End If

  If InStr(txt, "#USER#") > 0 Then
    txt = Replace(txt, "#USER#", GetUserName)
  End If

  If InStr(txt, "#USERNAME#") > 0 Then
    txt = Replace(txt, "#USERNAME#", GetCurrentUserFullName(conn))
  End If
  
  If InStr(txt, "#USERMAIL#") > 0 Then
    txt = Replace(txt, "#USERMAIL#", GetCurrentUserMail(conn))
  End If
  
  If InStr(txt, "#SEITE/SEITEN#") > 0 Then
    txt = Replace(txt, "#SEITE/SEITEN#", "&P/&N")
  End If
  
  If InStr(txt, "#NEUEZEILE#") > 0 Then
    txt = Replace(txt, "#NEUEZEILE#", Chr(10))
  End If
  
  
  Dim pos1 As Long
  Dim pos2 As Long
  
  
  pos1 = InStr(txt, "#FONT(")
  If pos1 > 0 Then
    pos2 = InStr(pos1, txt, ")#")
    If pos2 > 0 Then
      Dim v As Long
      v = val(Mid(txt, pos1 + 6, pos2 - pos1 - 6))
      If v > 0 Then
        If Mid(txt, pos2 + 2, 1) >= "0" And Mid(txt, pos2 + 2, 1) <= "9" Then
          txt = Left(txt, pos1 - 1) & "&" & v & " " & Mid(txt, pos2 + 2)
        Else
          txt = Left(txt, pos1 - 1) & "&" & v & Mid(txt, pos2 + 2)
        End If
      End If
    End If
  End If
  
  GetHeaderFooterText = txt

End Function
    
Sub SetHeaderFooterTexts(ByVal hl As String, ByVal hc As String, ByVal hr As String, ByVal fl As String, ByVal fc As String, ByVal fr As String, ByRef wb As Workbook)
  On Error Resume Next
  Dim ws As Worksheet
  For Each ws In wb.Worksheets
    If hl <> "" Then ws.PageSetup.LeftHeader = hl
    If hc <> "" Then ws.PageSetup.CenterHeader = hc
    If hr <> "" Then ws.PageSetup.RightHeader = hr
    If fl <> "" Then ws.PageSetup.LeftFooter = fl
    If fc <> "" Then ws.PageSetup.CenterFooter = fc
    If fr <> "" Then ws.PageSetup.RightFooter = fr
  Next ws
End Sub


Sub SetHeaderFooterText(ByVal pos As Long, ByVal s As String, ByRef wb As Workbook)
  If s = "" Then Exit Sub
  On Error Resume Next
  Dim ws As Worksheet
  For Each ws In wb.Worksheets
    Select Case pos
      Case 1
        ws.PageSetup.LeftHeader = s
      Case 2
        ws.PageSetup.CenterHeader = s
      Case 1
        ws.PageSetup.RightHeader = s
      Case 1
        ws.PageSetup.LeftFooter = s
      Case 1
        ws.PageSetup.CenterFooter = s
      Case 1
        ws.PageSetup.RightFooter = s
    End Select
  Next ws
End Sub
    


Sub ShowVeralteteVersion(ByRef wb As Workbook)
  On Error Resume Next
  Dim ws As Worksheet
  For Each ws In wb.Worksheets
    ws.PageSetup.LeftHeaderPicture.filename = app.path & "\OldVersion.bmp"
    If Left(ws.PageSetup.LeftHeader, 2) <> "&G" Then
      ws.PageSetup.LeftHeader = "&G" & ws.PageSetup.LeftHeader
    End If
    
    Dim pic
    
    Dim found As Boolean
    found = False
    For Each pic In ws.Pictures
      If pic.name = "ExcelTrackerOldVersionPic" Then
        found = True
        Exit For
      End If
    Next pic
    
    If Not found Then
      ws.Cells(1, 1).Select
      Set pic = ws.Pictures.Insert(app.path & "\OldVersion.bmp")
      pic.name = "ExcelTrackerOldVersionPic"
      With ws.Cells(1, 1).ShapeRange
          .Top = ws.Cells(1, 1).Top
          .Left = ws.Cells(1, 1).Left
      End With
      ws.Cells(1, 1).PrintObject = False
    End If
  Next ws
End Sub

Function WBHasProtectedSheets(ByRef wbInExcelCurrentProjectInAccess As Object) As Boolean
    On Error Resume Next
    Dim ws As Worksheet
    For Each ws In wbInExcelCurrentProjectInAccess.Sheets
        If ws.ProtectContents = True Then
          WBHasProtectedSheets = True
          Exit Function
        End If
    Next ws
End Function


Public Function DateiSchonGeoeffnet(ByRef xlapp As Object, ByVal fname As String) As Boolean
    DateiSchonGeoeffnet = False
    If fname = "" Then Exit Function
    
    ' wenn die Datei schon ge|fffd|ffnet ist, dann nichts machen
    Dim filenameU As String
    ' nur einmal den Filename nach UNC und Uppercase konvertieren
    filenameU = UCase(GetUNCPath(fname))
    Dim intCount As Long
    For intCount = 1 To xlapp.Workbooks.count
      If UCase(GetUNCPath(xlapp.Workbooks(intCount).fullname)) = filenameU Then
        DateiSchonGeoeffnet = True
        Exit Function
      End If
    Next intCount
    DateiSchonGeoeffnet = False
End Function

Public Function DateiSchonGeoeffnetMitWB(ByRef xlapp As Object, ByVal fname As String, ByRef wb As Object) As Boolean
    DateiSchonGeoeffnetMitWB = False
    If fname = "" Then Exit Function
    
    ' wenn die Datei schon ge|fffd|ffnet ist, dann nichts machen
    Dim filenameU As String
    ' nur einmal den Filename nach UNC und Uppercase konvertieren
    filenameU = GetUNCPath(fname)
    Dim intCount As Long
    For intCount = 1 To xlapp.Workbooks.count
      If GetUNCPath(xlapp.Workbooks(intCount).fullname) = filenameU Then
        Set wb = xlapp.Workbooks(intCount)
        DateiSchonGeoeffnetMitWB = True
        Exit Function
      End If
    Next intCount
End Function

Public Function GetDateiOeffnenPasswort(ByRef xlapp As Object, ByRef conn As Object, ByVal fname As String) As String
    GetDateiOeffnenPasswort = ""
    
    Dim rs
    Set rs = CreateObject("ADODB.recordset")
  
    Dim hsh As String
    Dim uncfname As String
    uncfname = GetUNCPath(fname)
    Dim uncpathfnameDB As String
    uncpathfnameDB = GetDateinameInDatenbank(uncfname)
    hsh = GetFileHash(xlapp, uncpathfnameDB)
    
    Dim pwtyp As Long
    pwtyp = 1
    Dim q As String
    q = "SELECT idvDateien.idvDateiID, Dateiname FROM idvDateien inner join idvDateienBerechtigungen b on b.idvDateiID = idvDateien.idvDateiID WHERE Hash = '" & hsh & "' and b.Berechtigungstraeger = '" & GetUserNameUCASE() & "'"
    rs.Open q, conn, 2, 1
    If Not rs Is Nothing Then
        Do While rs.EOF = False
          If rs.Fields("Dateiname").value = uncfname Then
            GetDateiOeffnenPasswort = GetStandardPassword()
            Exit Do
          End If
          rs.MoveNext
        Loop
        rs.Close
    End If
    Set rs = Nothing

End Function

Public Function ExcelDateiMitPWOeffnen(ByRef xlapp As Object, ByVal fname As String, ByVal pw As String) As Boolean
    ExcelDateiMitPWOeffnen = False
    If DateiOeffnenMitPW(xlapp, fname, pw) = True Then
        ExcelDateiMitPWOeffnen = True
    End If
End Function

Public Function DateiOeffnenMitPW(ByRef xlapp As Object, ByVal fname As String, ByVal pw As String) As Boolean
    Dim wb As Excel.Workbook
    On Error GoTo a
    If FileInUse(fname) Then
      MsgBox FMT0("EXCELSTUFF_4"), vbExclamation, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
      Set wb = xlapp.Workbooks.Open(fname, , True, , pw, , , , , True)
    Else
      Set wb = xlapp.Workbooks.Open(fname, , , , pw, , , , , True)
    End If
    DateiOeffnenMitPW = True
    Exit Function
a:

    If err.Number = 1 Then
    Else
      DateiOeffnenMitPW = False
    End If

End Function

Public Function FileInUse(sFileName) As Boolean
    ' XXX HTTPS und HTTP sind immer NOT IN USE. Richtig Sinn macht das nicht, geht aber aktuell nicht anders.Wie will man das auch rausinden...
    If Left(UCase(sFileName), 6) = "HTTPS:" Or Left(UCase(sFileName), 5) = "HTTP:" Then
      Exit Function
    End If
    
    On Error Resume Next
    Dim ff As Long
    ff = FreeFile
    Open sFileName For Binary Access Read Lock Read As #ff
    Close #ff
    FileInUse = IIf(err.Number > 0, True, False)
    On Error GoTo 0
End Function

Public Function DateiOeffnenOhnePW(ByRef xlapp As Object, ByVal fname As String) As Boolean
    Dim wb As Excel.Workbook
    On Error GoTo a
'    If UCase(Right(fname, 4)) = "XLTX" Or UCase(Right(fname, 4)) = "XLTM" Or UCase(Right(fname, 3)) = "XLT" Then
      Set wb = xlapp.Workbooks.Open(fname, False, , , , , , , , True)
'    Else
'      Set wb = xlapp.Workbooks.Open(fname)
'    End If
    DateiOeffnenOhnePW = True
    Exit Function
a:
    DateiOeffnenOhnePW = False

End Function

Function ExcelDateiOeffnenMitConn(ByRef conn As Object, ByRef xlapp As Object, ByVal fname As String, ByRef wb As Object, ByVal id As Long) As Object
    
    Set wb = Nothing
    
    Set ExcelDateiOeffnenMitConn = Nothing
    If DateiSchonGeoeffnet(xlapp, fname) = True Then
        Exit Function
    End If
    
' Kann bis auf weiteres nicht genutzt werden, da sonst beim Freigeben  externe Referenze nicht sauber bei allen Formeln wieder "hergestellt" werden.
' In dot net ist das dann kein Problem mehr.

'    Dim oldenev As Boolean
'    oldenev = xlapp.EnableEvents
'    xlapp.EnableEvents = False
'    Dim oldalert As Boolean
'    oldalert = xlapp.DisplayAlerts
'    xlapp.DisplayAlerts = False
'    xlapp.AskToUpdateLinks = False
'    Dim oldAutomation As Long
'    oldAutomation = xlapp.AutomationSecurity
'    xlapp.AutomationSecurity = msoAutomationSecurityLow
    
    Dim dateiGeoeffnet As Boolean
    Dim pw As String
    If HatDateiFileOpenPasswordConn(conn, fname, id, pw) = True Then
        dateiGeoeffnet = ExcelDateiMitPWOeffnen(xlapp, fname, pw)
    Else
        DateiOeffnenOhnePW xlapp, fname
    End If
    
'    xlapp.AutomationSecurity = oldAutomation
'    xlapp.Application.AskToUpdateLinks = True
'    xlapp.DisplayAlerts = oldalert
'    xlapp.EnableEvents = oldenev
    
    DateiSchonGeoeffnetMitWB xlapp, fname, wb
    
End Function

Function WBHasError(ByRef wb As Object) As Boolean
  On Error GoTo nogo
  WBHasError = True
  Dim s As String
  s = wb.fullname
  WBHasError = False
  Exit Function
nogo:
End Function

Sub DatenschutzhinweisAus(ByRef wb As Object)
On Error Resume Next
  Dim s As Boolean
  s = wb.saved
  wb.RemovePersonalInformation = False
  wb.saved = s
End Sub


Attribute VB_Name = "ExcelTrackerDLLConnection"
Option Explicit

Public L_ShowSaveAsDialog As Boolean
Public G_DateiberechtigungenSave As Boolean

Public Sub WorkbookOpen(ByRef xlapp As Object, ByRef wb As Excel.Workbook)
    
 On Error GoTo nogo
    
    WBCleanNames wb

    Dim conn As Object
    Set conn = GetConnection()

    If conn Is Nothing Then
        ' Kann eigentlich nicht vorkommen, aber sicher ist sicher!
        G_IgnoreThisOneWarnungManuelleBerechnung = False
        If G_CheckDateiberechtigungBeimOeffnen Then
          G_CheckDateiberechtigungBeimOeffnen = False
          wb.Close False
          Set wb = Nothing
        End If
        Exit Sub
    End If

    If Deaktiviert(conn) Then
        G_IgnoreThisOneWarnungManuelleBerechnung = False
        If G_CheckDateiberechtigungBeimOeffnen Then
          conn.Close
          Set conn = Nothing
          G_CheckDateiberechtigungBeimOeffnen = False
          wb.Close False
          Set wb = Nothing
        End If
        Exit Sub
    End If
    
    If FreigabeCheck(xlapp, wb, conn) = 0 Then
        G_IgnoreThisOneWarnungManuelleBerechnung = False
        conn.Close
        Set conn = Nothing
        
        wb.Close False
        Set wb = Nothing
        Exit Sub
    End If

    If Not G_IgnoreThisOneWarnungManuelleBerechnung Then
      If GetSetting(appname:="Stromwerken", Section:="ExcelTracker", Key:="PluginDisabled", Default:="False") <> "True" Then
        If G_PARAM_WarnungManuelleBerechnung Then
          CheckCalculationManual wb
        End If
      End If
    End If
    
    ' In jedem Fall dann wieder ausschalten
    G_IgnoreThisOneWarnungManuelleBerechnung = False

    conn.Close
    Set conn = Nothing

    InvalidateRibbon
    
    Dim s As String
    s = GetUNCPathFromDoc(wb)
    
    If s <> wb.fullname And G_cfgPathMapSrcCol Is Nothing = False Then
      DebugPrint tinfo, "Dateiname wird gemappt: '" & wb.fullname & "' --> '" & s & "'"
    End If
    Exit Sub
    
nogo:

  If err.Number <> -2147319784 Then
    DebugPrint DebType.tERROR, "WBOpen: " & err.Description
  End If
  err.Clear

  If Not conn Is Nothing Then
    conn.Close
    Set conn = Nothing
  End If
    
  InvalidateRibbon

End Sub
Private Sub CheckCalculationManual(ByRef wb As Excel.Workbook)
On Error GoTo nogo:
      If wb.Application.Calculation <> xlCalculationAutomatic Then
        'If MsgBox("ACHTUNG: Der Berechnungsmodus f|fffd|r diese Datei ist auf manuell gestellt oder deaktiviert, die Ergebnisse von Formeln werden nicht automatisch berechnet! Sollt die automatische Berechnung aktiviert werden?", vbYesNo + vbExclamation, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")") = vbYes Then
        If MsgBox(FMT0("ETDLL_1"), vbYesNo + vbExclamation, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")") = vbYes Then
          wb.Application.Calculation = xlCalculationAutomatic
        End If
      End If
      Exit Sub
nogo:
End Sub

Public Sub WorkbookActivate(ByRef xlapp As Object, ByVal wb As Excel.Workbook)
'    Debug.Print "Activate " & wb.name
' XLAM
  SetzeAmpelStatusOhneConnection wb
  WBCleanNames wb
  
  If G_PARAM_Ampel Then
    ShowAmpelStatus wb
  End If
  On Error Resume Next
  G_InClose = False
    
End Sub

Public Sub WorkbookBeforeClose(ByRef xlapp As Object, ByVal wb As Excel.Workbook, ByRef Cancel As Boolean)
    G_InClose = True
End Sub

Function ShowWorkbookSave(ByRef wb As Object) As Boolean
On Error GoTo nogo

    Dim olddisplayalerts As Boolean
    olddisplayalerts = wb.Application.DisplayAlerts
    wb.Application.DisplayAlerts = True
    wb.Application.Dialogs(xlDialogSaveAs).Show
    wb.Application.DisplayAlerts = olddisplayalerts
    ShowWorkbookSave = True
    Exit Function
nogo:
    wb.Application.DisplayAlerts = olddisplayalerts
    ' MsgBox "Die Datei konnte nicht gespeichert werden!" & vbCrLf & vbCrLf & "Fehlermeldung: '" & err.Description & "'", vbCritical, ProgNameLong & " " & myVersion & " (Build: " & App.Revision & ")"
    
    ShowWorkbookSave = False
End Function

Public Sub WorkbookBeforePrint(ByRef xlapp As Object, ByVal wb As Excel.Workbook, Cancel As Boolean)
    
    If BeforePrint(xlapp, xlapp.ActiveWorkbook) = False Then
        Cancel = True
    End If
    
End Sub
    

Public Sub WorkbookBeforeSave(ByRef xlapp As Object, ByVal wb As Excel.Workbook, ByVal SaveAsUI As Boolean, Cancel As Boolean)

    On Error GoTo nogo
    
    Dim forceSaveAs As Boolean
    forceSaveAs = False
    Dim EPSaveAs As Boolean
    EPSaveAs = False
    
    If Cancel = True Then Exit Sub
    
    If GetSetting(appname:="Stromwerken", Section:="ExcelTracker", Key:="PluginDisabled", Default:="False") = "True" Then
       DebugPrint tdebug, "Plugin per RegKey PluginDisabled deaktiviert"
       Cancel = False
       Exit Sub
    End If
    
    If GetSetting(appname:="Stromwerken", Section:="ExcelTracker", Key:="IgnoreThisOne", Default:="False") = "True" Then
       SaveSetting appname:="Stromwerken", Section:="ExcelTracker", Key:="IgnoreThisOne", Setting:="False"
       DebugPrint tdebug, "Plugin per RegKey IgnoreThisOne deaktiviert"
       Cancel = False
       Exit Sub
    End If
    
    If GetSetting(appname:="Stromwerken", Section:="ExcelTracker", Key:="ForceSaveAs", Default:="False") = "True" Then
       SaveSetting appname:="Stromwerken", Section:="ExcelTracker", Key:="ForceSaveAs", Setting:="False"
       forceSaveAs = True
    End If
    
    If GetSetting(appname:="Stromwerken", Section:="ExcelTracker", Key:="EPSaveAs", Default:="False") = "True" Then
       SaveSetting appname:="Stromwerken", Section:="ExcelTracker", Key:="EPSaveAs", Setting:="False"
       EPSaveAs = True
    End If
    
    
    If WBGetValueLongPart(wb, "_ExcelProtectP_") >= 0 Then
      If GetSetting(appname:="Stromwerken", Section:="EP", Key:="PSave", Default:="0") = 0 Then
        Cancel = True
        Exit Sub
      Else
        SaveSetting appname:="Stromwerken", Section:="EP", Key:="PSave", Setting:="0"
        Cancel = False
        Exit Sub
      End If
    End If

    SaveSetting appname:="Stromwerken", Section:="EP", Key:="PSave", Setting:="0"

    If L_ShowSaveAsDialog Then
      Cancel = False
      L_ShowSaveAsDialog = False
      Exit Sub
    End If

    Dim genabev As Boolean
    Dim trackpos As Long
    trackpos = 0
    
    ' Wenn wir aus VBA kommen ist mir der Rest egal!
'    Dim booUserSave As Boolean
'    If LCase(wb.Application.CommandBars("Document").Controls(1).Caption) <> "&speichern" Then
'      wb.Application.CommandBars("Document").Controls(1).Caption = "speichern"
'      Exit Sub
'    End If
    DebugPrint tdebug, "XLBS Start"
'    If WorksheetExists(wb, "ECCFiles") Then
'      DebugPrint tdebug, "XLBSExit ECCFiles"
'      Exit Sub
'    End If
    
    If bInternalSave Then
        '            bInternalSave = False
        DebugPrint tdebug, "XLBSExit InternalSave"
        Exit Sub
    End If
    
    If G_InClose = True Then
        ' wenn noch nie gespeichert wurde, dann machen wir auch nichts mit der Datei
        If Mid(wb.fullname, 2, 1) <> ":" And Left(GetUNCPath(wb.fullname), 2) <> "\\" And Left(GetUNCPath(wb.fullname), 2) <> "//" And InStr(wb.fullname, "://") <= 0 Then
            DebugPrint tdebug, "XLBSExit noch nie gespeichert und X gedr|fffd|ckt"
            Cancel = False
            Exit Sub
        End If
    End If

    Dim conn As Object
    Set conn = GetConnection()

    If conn Is Nothing Then
'        DebugPrint DebType.tERROR, "WBBefore save - DBConnect fehlgeschlagen"
        Exit Sub
    End If

    If Not Verf|fffd|gbar(conn) Then
        conn.Close
        Set conn = Nothing
        DebugPrint tdebug, "XLBSExit NichtVerf|fffd|gbar"
        Exit Sub
    End If

    ' Nach speziellen Dateien suchen!
    If CheckAusschluss(wb, conn) Then
        If WBGetValueLong(wb, "_IDVTrackerFreigabeStatus" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix) = 1 Then
            'MsgBox "Die Datei kann nicht gespeichert werden, da sie sich in Freigabe befindet und in diesem Ordner / f|fffd|r diese Datei die Funktionen des Plugins nicht zur Verf|fffd|gung stehen.", vbCritical, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
            MsgBox FMT0("ETDLL_3"), vbCritical, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
            Cancel = True
        End If
        
        conn.Close
        Set conn = Nothing
        Exit Sub
    End If
    
    If WBGetValueLong(wb, "_IDVTrackerFreigabeStatus" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix) = 1 And G_cfgSaveNachInit = False Then
        conn.Close
        Set conn = Nothing
        
        'MsgBox "Die Datei befindet sich aktuell im Freigabeprozess und kann daher nicht gespeichert werden! Der Vorgang wird abgebrochen! Wenn Sie die Datei speichern wollen, m|fffd|ssen Sie eine neue Version erzeugen (Dies f|fffd|hrt dann automatisch zu einem Abbruch des Freigabeverfahrens).", vbCritical, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        MsgBox FMT0("ETDLL_4"), vbCritical, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        Cancel = True
        DebugPrint tdebug, "XLBSExit Freigabeprozess"
        Exit Sub
    End If

    ' Erst mal raus bis ich eine L|fffd|sung habe
'    If G_InClose = True Then
'        '            Wb.Application.DisplayAlerts = False
'        '            Cancel = True '-- cancel original save
'        '           Wb.Application.DisplayAlerts = True
'        G_InClose = False
'        conn.Close
'        Set conn = Nothing
'        DebugPrint tdebug, "XLBSExit InClose"
'        Exit Sub
'    End If
    

    trackpos = 10
    
    DebugPrint tdebug, "XLBS2"
    
    If G_DocInfo Is Nothing Then
      SaveDocInfoStuff wb
    End If
    
    WBCleanNames wb
    
    trackpos = 20

    wb.Application.DisplayAlerts = False
'    Cancel = True '-- cancel original save
    Cancel = False ' egal wie wird gespeichert, au|fffd|er das Speichern konnte hier vorgenommen werden
    MyFullName = wb.fullname
    DebugPrint tdebug, "XLBS Name:" & MyFullName
    
    trackpos = 30

    Dim oldid As Long
    Dim oldversion As Long
    
    Dim rs As Object
    If SaveAsUI = True Or EPSaveAs = True Then
        trackpos = 40
        DebugPrint tdebug, "XLBS SaveAsUI:" & MyFullName

'        newFullName = Datei_Waehlen(wb.Application, IIf(Mid(wb.FullName, 2, 1) = ":", wb.FullName, IIf(Left(wb.FullName, 1) = "\", wb.FullName, wb.name)), ftype, ext)

        Dim oldSavetime As Date
        Dim oldSaveNameUNC As String
        
        oldSaveNameUNC = GetUNCPath(MyFullName)
        
' XXX kann schiefgehen
        oldSavetime = MyFileDateTime(MyFullName)

        Dim wasSaved As Boolean
        wasSaved = False
'        wb.Application.Dialogs(xlDialogSaveAs).Show

        If EPSaveAs = True Then
          wasSaved = True
        Else

#If Project_ExcelTracker = 1 Then
          If CriticalAddinExists(xlapp) Then
            conn.Close
            Set conn = Nothing
            wb.Application.DisplayAlerts = True
            Exit Sub
          End If
#End If
          L_ShowSaveAsDialog = True
          If ShowWorkbookSave(wb) Then
#If Project_ExcelTracker = 1 Then
              If WBHasError(wb) Then
                conn.Close
                Set conn = Nothing
                err.Clear
                Cancel = False
                ' Eigentlich WB!!!
                Application.DisplayAlerts = True
                Exit Sub
              End If
#End If
              If oldSavetime <> MyFileDateTime(wb.fullname) Then
                If UCase(GetFileExtension(wb.fullname)) = "CSV" Then
                  bInternalSave = True
                  wb.SaveAs wb.fullname, Local:=True
                  bInternalSave = False
                End If
                wasSaved = True
              End If
          End If
        End If
        
        
        ' Bei HTML-Dateien muss anders vorgegangen werden
        trackpos = 50
        If wb.fullname = "False" Or wb.fullname = "" Or wasSaved = False Then
          DebugPrint tdebug, "XLBSCancel1"
          Cancel = True
        Else
              trackpos = 60
              
              ' wb.CustomDocumentProperties.add(Name:="_IDVTrackerID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, LinkToContent:=False, Type:=Microsoft.Office.Core.MsoDocProperties.msoPropertyTypeNumber, Value:=rs.Fields("id").Value)
              DebugPrint tdebug, "* SAVED 1 * " & wb.fullname
              Cancel = True
              
'              On Error GoTo nogo
              If UCase(Left(GetFileExtension(wb.fullname), 2)) = "XL" Then
                ' Dateiname oder Verzeichnis darf nicht auf der "Ausgeschlossen" Liste stehen
                If CheckAusschluss(wb, conn) = False Then
                ' Super, wenn gespeichert werden konnte, dann wird gepr|fffd|ft, ob es sich um eine lokale Datei handelt und lokale Dateien ber|fffd|cksichtigt werden bzw. eine Netzwerkdatei angegeben wurde...
                    If (G_PARAM_LokaleDateienBer|fffd|cksichtigen = True Or Mid(GetUNCPath(wb.fullname), 2, 1) <> ":") Then
                        ' ... ansonsten legen wir den neuen Datensatz an
                        oldid = WBGetValueLong(wb, "_IDVTrackerID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix)
                        oldversion = WBGetValueLong(wb, "_IDVTrackerVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix)
                        
                        trackpos = 61
                        BeforeSave GetUNCPath(wb.fullname), wb.fullname, wb, rs, conn, oldid, oldversion, IIf(EPSaveAs = True, True, oldSaveNameUNC <> GetUNCPath(wb.fullname))
                        trackpos = 62
                        If Not rs Is Nothing Then
                          If rs.EOF = False Then
                            
                            WBSetValueLong wb, "_IDVTrackerID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, rs.Fields("idvDateiID").value
                            WBSetValueLong wb, "_IDVTrackerVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, rs.Fields("Version").value
                            trackpos = 63
                            bInternalSave = True
                            xlapp.EnableEvents = False
                            trackpos = 64
                            
                            If G_cfgDatenschutzhinweisAus Then
                              DatenschutzhinweisAus wb
                            End If
                            If rs.Fields("Dateiberechtigungen").value <> 0 Then
                              wb.Application.DisplayAlerts = False
                              wb.SaveAs wb.fullname, , GetFileOpenPassword(conn, rs), , , , , , True, , , True
                            Else
                              wb.Application.DisplayAlerts = False
                              wb.SaveAs wb.fullname, , , , , , , , True, , , True
                            End If
                            trackpos = 65
                            DebugPrint tdebug, "* SAVED 2 * " & wb.fullname
                            xlapp.EnableEvents = True
                            trackpos = 66
                            AfterSave GetUNCPath(wb.fullname), wb.fullname, wb, rs, oldid, oldversion, conn, False, False
                            trackpos = 67
                          Else
                            DebugPrint tdebug, "NoRSWarning1-" & wb.fullname
                            If G_cfgShowMSGBoxForAllErrors Then
                              'MsgBox "NoRSWarning1-" & wb.fullname, vbCritical, ProgNameLong & " " & myVersion & " (" & app.Major & "." & app.Minor & "." & app.Revision & ") - *WARNUNG*"
                              MsgBox FMT0("ETDLL_5") & wb.fullname, vbCritical, ProgNameLong & " " & myVersion & " (" & app.Major & "." & app.Minor & "." & app.Revision & ") - " & FMT0("ETDLL_6")
                            End If
                          End If
                        End If
                    Else
                        DebugPrint tdebug, "XLBS Keine lokalen Dateien!"
                    End If
                Else
                    DebugPrint tdebug, "Datei/Verzeichnis ausgeschlossen"
                End If
              End If
        End If
    Else
        trackpos = 69
        Dim ww As String
        ww = wb.name
'        On Error GoTo nogo
        
        ' Wenn die Datei noch keinen Laufwerksbuchstaben oder UNC-Pfad hat UND SaveAsUI = false ist, dann ist das ein Aufruf |fffd|ber VBA
        If Mid(wb.fullname, 2, 1) <> ":" And Left(GetUNCPath(wb.fullname), 2) <> "\\" And Left(GetUNCPath(wb.fullname), 2) <> "//" And InStr(wb.fullname, "://") <= 0 Or forceSaveAs = True Then
          trackpos = 70
          ' Dann lassen wir den Dingen ihren "normalen" Lauf
          DebugPrint tdebug, "XLBSCancel3"
          Cancel = False
        Else
          trackpos = 80
          ' Dateiname oder Verzeichnis darf nicht auf der "Ausgeschlossen" Liste stehen
          If CheckAusschluss(wb, conn) = False Then
            If (G_PARAM_LokaleDateienBer|fffd|cksichtigen = True Or Left(GetUNCPath(wb.fullname), 2) = "\\" Or Left(GetUNCPath(wb.fullname), 2) = "//" Or InStr(wb.fullname, "://") > 0) And LCase(Left(GetFileExtension(wb.fullname), 2)) = "xl" Then
                trackpos = 90
                bInternalSave = True
                DebugPrint tdebug, "XLBS Timer1"
                
                oldid = WBGetValueLong(wb, "_IDVTrackerID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix)
                oldversion = WBGetValueLong(wb, "_IDVTrackerVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix)
                
                BeforeSave GetUNCPath(wb.fullname), wb.fullname, wb, rs, conn, oldid, oldversion, False
                DebugPrint tdebug, "XLBS Timer2"
                If Not rs Is Nothing Then
                    If rs.EOF = False Then
                        trackpos = 100
                        
                        WBSetValueLong wb, "_IDVTrackerID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, rs.Fields("idvDateiID").value
                        WBSetValueLong wb, "_IDVTrackerVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, rs.Fields("Version").value
                        
                        ' Damit ist die ID in der Datei drin
                        ' Jetzt gibt es 3 M|fffd|glichkeiten:
                        ' Entweder der User hat Save gedr|fffd|ckt, dann ist diese Datei gemeint und die ID bleibt wie sie ist.
                        ' Oder der User hat Save in VBA gecodet, dann ist diese Datei gemeint und die ID bleibt wie sie ist.
                        ' Oder der User hat SaveAs |fffd|ber VBA mit einem neuen Dateinamen angegeben, was bedeutet, dass hier noch der alte Dateiname in
                        ' FullName steht, da mir Excel den neuen Dateinamen leider nicht gibt. Wenn ich jetzt aftersave f|fffd|r diese Datei aufrufe
                        ' mache ich das AfterSave f|fffd|r die falsche Datei, denn die neue hat ja einen neuen Dateinamen.
                        
                        ' Also soll folgendes passieren.
                        ' der ge|fffd|ffnete Recordset wird geschlossen, vorher aber alles relevante in einer kleinen zwischenklasse gespeichert.
                        ' Dann wird saved auf false gesetzt und ein timer gestartet, der wartet, bis saved = true ist.
                        DebugPrint tdebug, "XLBS Timer2.1"
                        If rs.Fields("Dateiberechtigungen").value <> 0 Then
                          If G_cfgDatenschutzhinweisAus Then
                            DatenschutzhinweisAus wb
                          End If
                          wb.Application.DisplayAlerts = False
                          G_DateiberechtigungenSave = True
                          wb.SaveAs wb.fullname, , GetFileOpenPassword(conn, rs), , , , , , True, , , True
                          G_DateiberechtigungenSave = False
                          Cancel = False
                          wb.saved = True
                        Else
                          wb.saved = False
                          If G_cfgDatenschutzhinweisAus Then
                            DatenschutzhinweisAus wb
                          End If
                        End If
                        
                        If GetSafeFieldPlus(rs, "Log", 0) <> 0 Then
                          ' nicht eventuell noch einmal speichern, da schon 3 Zeilen weiter oben gespeichert wurde
                          If rs.Fields("Dateiberechtigungen").value = 0 Then
                              If G_cfgDatenschutzhinweisAus Then
                                DatenschutzhinweisAus wb
                              End If
                              wb.SaveAs wb.fullname, , GetFileOpenPassword(conn, rs), , , , , , True, , , True
                              Cancel = True
                          End If
                          LogFile wb, rs.Fields("idvDateiID").value, conn
                        End If
                        
                        ' Wenn eine XLA / M gespeichert wird muss Save explizit aufgerufen werden
                        If Cancel = False And (UCase(Right(wb.fullname, 5)) = ".XLAM" Or UCase(Right(wb.fullname, 4)) = ".XLA") Then
                          wb.Save
                        End If
                        
                        ' Vorsichtshalber mal warten falls noch ein xlsaver am laufen ist
                        Dim cnt As Long
                        cnt = 0
                        Do While Not G_XLSaver Is Nothing
                          Sleep 100
                          DoEvents
                          If cnt = 10 Then
                            Exit Do
                          End If
                          cnt = cnt + 1
                        Loop
                        DebugPrint tdebug, "XLBS Timer3"
                        
                        If cnt < 6 Then
                          Set G_XLSaver = New XLSaver
                          G_XLSaver.m_Filename = wb.fullname
                          G_XLSaver.m_idvDateiID = oldid
                          G_XLSaver.m_Version = oldversion
                          Set G_XLSaver.m_DocInfo = Nothing
                          Set G_XLSaver.m_WB = wb
                          Set G_XLSaver.m_xlApp = xlapp
                          
                          AfterSave GetUNCPath(wb.fullname), wb.fullname, wb, rs, oldid, oldversion, conn, False, True
                          Set G_XLSaver = Nothing
                          
                          DebugPrint tdebug, "XLBS Timer4"
                        End If
                    Else
                      DebugPrint tdebug, "NoRSWarning2-" & wb.fullname
                      If G_cfgShowMSGBoxForAllErrors Then
                        'MsgBox "NoRSWarning2-" & wb.fullname, vbCritical, ProgNameLong & " " & myVersion & " (" & app.Major & "." & app.Minor & "." & app.Revision & ") - *WARNUNG*"
                        MsgBox FMT0("ETDLL_7") & wb.fullname, vbCritical, ProgNameLong & " " & myVersion & " (" & app.Major & "." & app.Minor & "." & app.Revision & ") - " & FMT0("ETDLL_6")
                      End If
                    End If
                Else
                  DebugPrint tdebug, "XLBS Kein Datensatz"
                End If
              Else
                 DebugPrint tdebug, "XLBS Keine lokalen Dateien oder Dateitypen <> XL!"
              End If
          Else
            DebugPrint tdebug, "Datei/Verzeichnis ausgeschlossen"
          End If
        End If
    End If
    
'    If Not rs Is Nothing Then
'      rs.Close
'      Set rs = Nothing
'    End If

finishThis:
    
    bInternalSave = False
    wb.Application.DisplayAlerts = True
    Set G_DocInfo = Nothing
    xlapp.EnableEvents = True

    conn.Close
    
    ' ShowAmpelStatus wb
    
    Exit Sub
nogo:
    DebugPrint tERROR, "Interner Fehler in xlApp_WorkbookBeforeSave (" & wb.fullname & ") POS:" & trackpos & " - " & err.Number & " - " & err.Description
    GoTo finishThis

End Sub

Public Sub DokuButton_C(ByRef xlapp As Object, ByVal ctrl As Office.CommandBarButton, CancelDefault As Boolean)

    Dim tWb As Workbook
    
    Set tWb = xlapp.ActiveWorkbook

    If Not xlapp.ActiveWorkbook Is Nothing Then
      If UCase(xlapp.ActiveWorkbook.name) = "EXCELTRACKER.XLS" Or UCase(xlapp.ActiveWorkbook.name) = "EXCELTRACKER.XLSM" Then
'        Set tWb = Nothing
      End If
    End If
    
    ' Jetzt schauen wir nach XLAMs
    If Not tWb Is Nothing Then
    End If
    
    
    ' Warum ist das hier anders als in der DLL?
    If Not tWb Is Nothing Then
      SaveDocInfoStuff tWb
      DoShowDoku xlapp, tWb
      Set G_DocInfo = Nothing
    End If


End Sub

Public Sub RisikoFragenButton_C(ByRef xlapp As Object, ByVal ctrl As Office.CommandBarButton, CancelDefault As Boolean)

    If xlapp.ActiveWorkbook Is Nothing Then Exit Sub
    
    ' Eine vom User initiierte Befragung ist freiwillig
    Dim freiwillig As Boolean
    freiwillig = True
    DoRisikobefragung xlapp, xlapp.ActiveWorkbook, freiwillig
    
    ShowAmpelStatus xlapp.ActiveWorkbook
    
End Sub


Public Sub NewVersionButton_C(ByRef xlapp As Object, ByVal ctrl As Office.CommandBarButton, CancelDefault As Boolean)

    If xlapp.ActiveWorkbook Is Nothing Then Exit Sub
    
    DoNewVersion xlapp, xlapp.ActiveWorkbook
    
    ShowAmpelStatus xlapp.ActiveWorkbook

End Sub

Public Sub FreigabeButton_C(ByRef xlapp As Object, ByVal ctrl As Office.CommandBarButton, CancelDefault As Boolean)

    If xlapp.ActiveWorkbook Is Nothing Then Exit Sub
    
    DoFreigabeInit xlapp, xlapp.ActiveWorkbook
    
    ShowAmpelStatus xlapp.ActiveWorkbook
      
End Sub


Public Sub MeineDateienListeButton_C(ByRef xlapp As Object, ByVal ctrl As Office.CommandBarButton, CancelDefault As Boolean)
    ZeigeMeineDateienListe xlapp, xlapp.ActiveWorkbook, 1
End Sub

Public Sub ECCButton_C(ByRef xlapp As Object, ByVal ctrl As Office.CommandBarButton, CancelDefault As Boolean)
  
'  If xlapp.ActiveWorkbook Is Nothing Then Exit Sub
  
'  If Mid(GetCurrentDocUNCPathFromApp(xlapp), 2, 1) <> ":" And Left(GetCurrentDocUNCPathFromApp(xlapp), 2) <> "\\" And Left(GetCurrentDocUNCPathFromApp(xlapp), 2) <> "//" And InStr(GetCurrentDocUNCPathFromApp(xlapp), "://") <= 0 Then
'    MsgBox "Bevor Sie diese Funktion nutzen k|fffd|nnen muss die Datei von Ihnen gespeichert werden.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
'    Exit Sub
'  End If
  
  Dim eccfile As String
  eccfile = GetECC()
  If eccfile = "" Then
     'MsgBox "Der Excel-Sheet-Checker wurde nicht gefunden!", vbCritical, ProgNameLong & " - *FEHLER*" & " " & myVersion & " (Build: " & app.Revision & ")"
     MsgBox FMT0("ETDLL_8"), vbCritical, ProgNameLong & " - " & FMT0("FREIGABEMM_16") & " " & myVersion & " (Build: " & app.Revision & ")"
  Else
  
    If xlapp.ActiveWorkbook Is Nothing Then
      G_NoStartup = True
      SaveSetting appname:="Stromwerken", Section:="ECC", Key:="COMMAND", Setting:=""
      If G_cfgLoadETInResults Then
        SaveSetting appname:="Stromwerken", Section:="ET", Key:="LoadET", Setting:=ThisWorkbook.fullname
      End If
      StartDatei eccfile, vbNormalFocus
      G_NoStartup = False
      Exit Sub
    End If
    
    Dim uncPath As String
    uncPath = GetUNCPath(xlapp.ActiveWorkbook.fullname)
    
    If Mid(uncPath, 2, 1) <> ":" And Left(uncPath, 2) <> "\\" And Left(uncPath, 2) <> "//" And InStr(uncPath, "://") <= 0 Then
      G_NoStartup = True
      SaveSetting appname:="Stromwerken", Section:="ECC", Key:="COMMAND", Setting:=""
      If G_cfgLoadETInResults Then
        SaveSetting appname:="Stromwerken", Section:="ET", Key:="LoadET", Setting:=ThisWorkbook.fullname
      End If
      StartDatei eccfile, vbNormalFocus
      G_NoStartup = False
      Exit Sub
    End If
    
    Dim idvDateiID As Long
    idvDateiID = WBGetValueLong(ActiveWorkbook, "_IDVTrackerID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix)
    
    Dim useScheduler As Boolean
    
    Dim conn As Object
    Set conn = GetConnection()
 
    If idvDateiID > 0 Then
      If G_PARAM_ReihenfolgeAppInfo > 0 Then
        If G_CfgAppinfoAnalysis = True Then
          If Not conn Is Nothing Then
            If SchedulerRunning(conn) Then
              If Not UserHasCommandInScheduler(conn) Then
                If FMT0("ETDLL_34") = "" Then
                  useScheduler = True
                Else
                  If MsgBox(FMT0("ETDLL_34"), vbQuestion + vbYesNo, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")") = vbYes Then
                    useScheduler = True
                  End If
                End If
              End If
            End If
          End If
        End If
      End If
    End If
  
    If useScheduler Then
      If xlapp.ActiveWorkbook.saved = False Then
        ' "Die Datei weist Ver|fffd|nderungen auf, die Analyse wird mit der letzten gespeicherten Version vorgenommen."
        MsgBox FMT0("ETDLL_35"), vbExclamation + vbOK, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
      End If
    Else
      If xlapp.ActiveWorkbook.saved = False Then
          'If MsgBox("Die Datei weist |fffd|nderungen auf! ACHTUNG: Die Datei wird nach der Analyse geschlossen! Alle |fffd|nderungen an der Datei gehen dann verloren! Wollen Sie wirklich die Analyse durchf|fffd|hren?", vbQuestion + vbYesNo) = vbNo Then Exit Sub
          If MsgBox(FMT0("ETDLL_32"), vbExclamation + vbYesNo, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")") = vbNo Then
            If Not conn Is Nothing Then
              conn.Close
              Set conn = Nothing
            End If
            Exit Sub
          End If
      Else
        ' Die Datei wird nach der Analyse geschlossen! Wollen Sie die Analyse wirklich durchf|fffd|hren?
        If MsgBox(FMT0("ETDLL_33"), vbQuestion + vbYesNo, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")") = vbNo Then Exit Sub
      End If
    End If
    
    If useScheduler Then
      AddSchedulerCommand conn, "ECCSCAN" & _
        " /ID:" & idvDateiID & _
        " /RES:" & 1  ' Store Resultfile in Scheduler Command
      
      If Not conn Is Nothing Then
        conn.Close
        Set conn = Nothing
      End If
    Else
      If Not conn Is Nothing Then
        conn.Close
        Set conn = Nothing
      End If
      
        SaveSetting appname:="Stromwerken", Section:="ECC", Key:="COMMAND", Setting:="SCANID" & _
              " /IDCALLER:" & SWAPPID_ExcelTracker & _
              " /ID:" & idvDateiID & _
              " /RES:2" & _
              " /FNAME:" & Chr(34) & GetCurrentDocNormalPath(xlapp) & Chr(34)
              ' RES = 2 =  Just open Result File
              
        G_NoStartup = True
        If G_cfgLoadETInResults Then
          SaveSetting appname:="Stromwerken", Section:="ET", Key:="LoadET", Setting:=ThisWorkbook.fullname
        End If
        ' StartDatei eccfile
        Dim wb As Excel.Workbook
        Set wb = xlapp.Workbooks.Open(eccfile)
        
        On Error Resume Next
        ' SaveSetting appname:="Stromwerken", Section:="ECC", Key:="ECCStartedByXLAM", Setting:=ThisWorkbook.fullname
        xlapp.Run "'" & eccfile & "'!StartECCAnalyse"
        G_NoStartup = False
        If err.Number <> 0 Then
          MsgBox err.Description, vbOKOnly, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        End If
        wb.Close False
        Set wb = Nothing
    End If
    
    xlapp.EnableEvents = True
  End If

End Sub

Public Sub ForceErrorButton_C(ByRef xlapp As Object, ByVal ctrl As Office.CommandBarButton, CancelDefault As Boolean)
  Dim o As Object
  o.dothis
End Sub

' XLAM
Public Sub KonvertierenButton_C(ByRef xlapp As Object, ByVal ctrl As Office.CommandBarButton, CancelDefault As Boolean)
  SaveSetting _
         appname:="Stromwerken", _
         Section:="ExcelTracker", _
         Key:="IgnoreThisOne", _
         Setting:="True"

  SendKeys "%DIK"
End Sub


Public Sub ESQAButton_C(ByRef xlapp As Object, ByVal ctrl As Office.CommandBarButton, CancelDefault As Boolean)
  
'  If IsSharedWorkbook(xlapp.ActiveWorkbook) Then
'    MsgBox "Die Funktion kann nicht genutzt werden, da die Microsoft-Freigabe verwendet wurde (""Arbeitsmappe freigeben""). Bitte entfernen Sie die Freigabe, um die Funktion auszuf|fffd|hren."
'    Exit Sub
'  End If
      
  Dim esqafile As String
  esqafile = GetESQA()
  If esqafile = "" Then
     'MsgBox "Excel-Sheet-QA wurde nicht gefunden!", vbCritical, ProgNameLong & " - *FEHLER*" & " " & myVersion & " (Build: " & app.Revision & ")"
     MsgBox FMT0("ETDLL_10"), vbCritical, ProgNameLong & " - " & FMT0("FREIGABEMM_16") & " " & myVersion & " (Build: " & app.Revision & ")"
  Else
    G_NoStartup = True
    If Not WorkbookExists(xlapp, "Excel-Sheet-QA.xla") And Not WorkbookExists(xlapp, "Excel-Sheet-QA.xls") Then
      xlapp.Workbooks.Open esqafile, False, True, , , , , , , , , , False
'      MsgBox "ESQA wurde gestartet, Sie k|fffd|nnen die Funktionen jetzt |fffd|ber die Men|fffd|leister von Excel (bis Excel 2003) bzw. |fffd|ber 'AddIns' (ab Excel 2007) nutzen", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
    End If
    G_NoStartup = False
  End If

End Sub


Public Sub EFCButton_C(ByRef xlapp As Object, ByVal ctrl As Office.CommandBarButton, CancelDefault As Boolean)
  
  Dim efcfile As String
  efcfile = GetEFC()
  If efcfile = "" Then
     'MsgBox "Excel-File-Compare wurde nicht gefunden!", vbCritical, ProgNameLong & " - *FEHLER*" & " " & myVersion & " (Build: " & app.Revision & ")"
     MsgBox FMT0("ETDLL_11"), vbCritical, ProgNameLong & " - " & FMT0("FREIGABEMM_16") & " " & myVersion & " (Build: " & app.Revision & ")"
     Exit Sub
  End If
  
  
    If xlapp.ActiveWorkbook Is Nothing Then
      G_NoStartup = True
      If G_cfgLoadETInResults Then
        SaveSetting appname:="Stromwerken", Section:="ET", Key:="LoadET", Setting:=ThisWorkbook.fullname
      End If
      StartDatei efcfile, vbNormalFocus
      G_NoStartup = False
      Exit Sub
    End If
    
    Dim uncPath As String
    uncPath = GetUNCPath(xlapp.ActiveWorkbook.fullname)
    
    If Mid(uncPath, 2, 1) <> ":" And Left(uncPath, 2) <> "\\" And Left(uncPath, 2) <> "//" And InStr(uncPath, "://") <= 0 Then
      G_NoStartup = True
      If G_cfgLoadETInResults Then
        SaveSetting appname:="Stromwerken", Section:="ET", Key:="LoadET", Setting:=ThisWorkbook.fullname
      End If
      StartDatei efcfile, vbNormalFocus
      G_NoStartup = False
      Exit Sub
    End If
    
    
    Dim conn As Object
    Set conn = GetConnection()

    If conn Is Nothing Then
        'MsgBox "Diese Funktion ist zur Zeit nicht ausf|fffd|hrbar, da das System nicht zur Verf|fffd|gung steht. Bitte versuchen Sie es sp|fffd|ter noch einmal.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        MsgBox FMT0("DOKUPWD_3"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        Exit Sub
    End If

    If Deaktiviert(conn) Then
        'MsgBox "Aktuell steht diese Funktion nicht zur Verf|fffd|gung, da das System deaktiviert wurde. Bitte versuchen Sie es sp|fffd|ter noch einmal.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        MsgBox FMT0("DOKUPWD_4"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        conn.Close
        Set conn = Nothing
        Exit Sub
    End If
  
    Dim rs As Object
    Set rs = CreateObject("ADODB.Recordset")
    Dim curid As Long
    Dim hash As String

    ' Wenn Sie bereits gespeichert wurde...
    Dim wasLocked As Boolean
    If Not GetTargetRS(conn, GetUNCPath(xlapp.ActiveWorkbook.fullname), xlapp.ActiveWorkbook, rs, curid, hash, ADODB.LockTypeEnum.adLockPessimistic, wasLocked) Then
      conn.Close
      Set conn = Nothing
      G_NoStartup = True
      If G_cfgLoadETInResults Then
        SaveSetting appname:="Stromwerken", Section:="ET", Key:="LoadET", Setting:=ThisWorkbook.fullname
      End If
      StartDatei efcfile, vbNormalFocus
      G_NoStartup = False
      Exit Sub
    End If
    
    rs.Close
    
'    Dim col As New Collection
'    rs.Open "SELECT idvDateiID, ReferenzidvDateiID FROM idvDateien WHERE hash in (Select i.hash from idvDateien i where i.idvDateiID = " & curId & ")", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
'    Do While rs.EOF = False
'        ' Reihenfolge der Parameter ist Item, Key
'        col.add CStr(GetSafeFieldPlus(rs, "ReferenzidvDateiID", 0)), CStr(GetSafeField(rs, "idvDateiID"))
'        rs.MoveNext
'    Loop
'    rs.Close
'
'    Dim dateiIds As String
'    dateiIds = CStr(curId)
'    Dim refId As Long
'    refId = curId
'    Dim refIdOld As Long
'
'    Do While refId <> 0
'        If CollectionItemExists(col, CStr(refId)) Then
'           dateiIds = dateiIds & "," & refId
'           refIdOld = refId
'           refId = val(col(CStr(refId)))
'           If refIdOld = refId Then
'                refId = 0
'           End If
'        Else
'            refId = 0
'        End If
'    Loop
    
    ' Hash doch nicht beruecksichtigen und alle Referenz Dateien sammeln.
    Dim dateiIds As String
    dateiIds = CStr(curid)
    Dim refId As Long
    refId = curid
    Dim refIdOld As Long
    
    Do While refId <> 0
        rs.Open "SELECT * FROM idvDateien WHERE idvDateiID = " & refId, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
        If Not rs.EOF Then
            dateiIds = dateiIds & "," & refId
            refIdOld = refId
            refId = GetSafeFieldPlus(rs, "ReferenzidvDateiID", 0)
            If refIdOld = refId Then
                refId = 0
            End If
        Else
            refId = 0
        End If
        rs.Close
    Loop
    
    frmVersionsauswahl.VersionList.Clear
'    rs.Open "SELECT x.idvDateiID, x.Version, i.MajorVersion, i.MinorVersion FROM xlBin x inner join idvDateien i on x.idvDateiID = i.idvDateiID WHERE i.idvDateiID=" & curId & " or " & gCHR & "HASH" & gCHR & " = '" & hash & "'", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
    rs.Open "SELECT distinct x.idvDateiID, x.Version, x.Datum, i.MajorVersion, i.MinorVersion FROM A_XLBINTMEINEOES x inner join idvDateien i on x.idvDateiID = i.idvDateiID WHERE i.idvDateiID in (" & dateiIds & ") ORDER BY MajorVersion DESC, MinorVersion DESC", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
    If rs.EOF Then
      rs.Close
      Set rs = Nothing
      conn.Close
      Set conn = Nothing
      G_NoStartup = True
      If G_cfgLoadETInResults Then
        SaveSetting appname:="Stromwerken", Section:="ET", Key:="LoadET", Setting:=ThisWorkbook.fullname
      End If
      StartDatei efcfile, vbNormalFocus
      G_NoStartup = False
      Exit Sub
    End If
      
    Dim c As New Collection
      
      ' Vorsicht, DateiID und Version genau umgekehrt als in der DLL Version reinschreiben
    Do While Not rs.EOF
      frmVersionsauswahl.VersionList.AddItem rs.Fields("MajorVersion").value & "." & rs.Fields("MinorVersion").value
      frmVersionsauswahl.VersionList.List(frmVersionsauswahl.VersionList.ListCount - 1, 1) = rs.Fields("Version").value
      frmVersionsauswahl.VersionList.List(frmVersionsauswahl.VersionList.ListCount - 1, 2) = rs.Fields("idvDateiID").value
      Dim st As CStringTouple
      Set st = New CStringTouple
      st.m_Name = rs.Fields("MajorVersion").value & "." & rs.Fields("MinorVersion").value
      st.m_Text = rs.Fields("Datum").value
      c.add st, "O" & rs.Fields("idvDateiID").value
      rs.MoveNext
    Loop
    rs.Close
    
    
    ' Wenn es mindestens eine Version gibt
    If frmVersionsauswahl.VersionList.ListCount > 0 Then
      frmVersionsauswahl.Show vbModal
      
      If frmVersionsauswahl.Auswahl = -1 Then
        Set rs = Nothing
        conn.Close
        Set conn = Nothing
        Exit Sub
      ElseIf frmVersionsauswahl.Auswahl = 0 Then
        Set rs = Nothing
        conn.Close
        Set conn = Nothing
        G_NoStartup = True
        If G_cfgLoadETInResults Then
          SaveSetting appname:="Stromwerken", Section:="ET", Key:="LoadET", Setting:=ThisWorkbook.fullname
        End If
        StartDatei efcfile, vbNormalFocus
        G_NoStartup = False
        Exit Sub
      
      End If
    End If
    
    Dim fname As String
'    fname = GetTempPath & GetFileNameAndExtension(xlapp.ActiveWorkbook.FullName)
    fname = xlapp.ActiveWorkbook.fullname

    If xlCheckOutBinary(conn, frmVersionsauswahl.idvDateiID, frmVersionsauswahl.Version, fname, True) Then
      
        Dim pw1 As String
        Dim pw2 As String
        Dim typ1 As Long
        Dim typ2 As Long
        
        pw1 = GetFilePasswordFromIDWithTyp(conn, typ1, frmVersionsauswahl.idvDateiID)
        pw2 = GetFilePasswordFromIDWithTyp(conn, typ2, WBGetValueLong(xlapp.ActiveWorkbook, "_IDVTrackerID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix))
        
        conn.Close
        Set conn = Nothing
        
        If typ1 = 0 Then
          pw1 = GetStandardPassword()
        End If
        If typ2 = 0 Then
          pw2 = GetStandardPassword()
        End If
        
        SaveSetting appname:="Stromwerken", Section:="EFC", Key:="COMMAND", _
          Setting:="COMPQUICK /IDCALLER:" & SWAPPID_ExcelSheetChecker & _
          " /FILE1:" & Chr(34) & fname & Chr(34) & _
          " /FILE2:" & Chr(34) & xlapp.ActiveWorkbook.fullname & Chr(34) & _
          " /PW1:" & Chr(34) & pw1 & Chr(34) & _
          " /PW2:" & Chr(34) & pw2 & Chr(34) & _
          " /DISPLAYNAME1:" & Chr(34) & GetFileNameAndExtension(fname) & Chr(34) & _
          " /DISPLAYNAME2:" & Chr(34) & xlapp.ActiveWorkbook.fullname & Chr(34) & _
          " /VERSION1:" & Chr(34) & c("O" & frmVersionsauswahl.idvDateiID).m_Name & Chr(34) & _
          " /VERSION2:" & Chr(34) & WBGetValueLong(xlapp.ActiveWorkbook, "_IDVTrackerMajorVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix) & "." & WBGetValueLong(xlapp.ActiveWorkbook, "_IDVTrackerMinorVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix) & Chr(34) & _
          " /FILEDATE1:" & Chr(34) & c("O" & frmVersionsauswahl.idvDateiID).m_Text & Chr(34)
        
        G_NoStartup = True
        If G_cfgLoadETInResults Then
          SaveSetting appname:="Stromwerken", Section:="ET", Key:="LoadET", Setting:=ThisWorkbook.fullname
        End If
        StartDatei efcfile, vbNormalFocus
        G_NoStartup = False
    Else
      conn.Close
      Set conn = Nothing
    End If
    

End Sub


Public Sub FreigabeAbschliessenButton_C(ByRef xlapp As Object, ByVal ctrl As Office.CommandBarButton, CancelDefault As Boolean)
  
  If xlapp.ActiveWorkbook Is Nothing Then Exit Sub
  
  Dim eccfile As String
  eccfile = GetECC()
  If eccfile = "" Then
     'MsgBox "Der Excel-Sheet-Checker wurde nicht gefunden!", vbCritical, ProgNameLong & " - *FEHLER*" & " " & myVersion & " (Build: " & app.Revision & ")"
     MsgBox FMT0("ETDLL_8"), vbCritical, ProgNameLong & " - " & FMT0("FREIGABEMM_16") & " " & myVersion & " (Build: " & app.Revision & ")"
  Else
    DoFreigabe "ECC", xlapp, xlapp.ActiveWorkbook
    ShowAmpelStatus xlapp.ActiveWorkbook
  End If
End Sub

Public Sub EPButton_C(ByRef xlapp As Object, ByVal ctrl As Office.CommandBarButton, CancelDefault As Boolean)
  
  If xlapp.ActiveWorkbook Is Nothing Then Exit Sub

  Dim uncPath As String
  uncPath = GetUNCPath(xlapp.ActiveWorkbook.fullname)
    
  If Mid(uncPath, 2, 1) <> ":" And Left(uncPath, 2) <> "\\" And Left(uncPath, 2) <> "//" And InStr(uncPath, "://") <= 0 Then
    'MsgBox "Bevor Sie diese Funktion nutzen k|fffd|nnen, muss die Datei von Ihnen gespeichert werden.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
    MsgBox FMT0("BLATTSCHUTZ_4"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
    Exit Sub
  End If
  
  If Not xlapp.ActiveWorkbook.saved Then
    'MsgBox "Bevor Sie diese Funktion nutzen k|fffd|nnen, muss die Datei von Ihnen gespeichert werden.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
    MsgBox FMT0("BLATTSCHUTZ_4"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
    Exit Sub
  End If
  
  Dim epfile As String
  epfile = GetEP()
  If epfile = "" Then
     'MsgBox "ExcelProtect wurde nicht gefunden!", vbCritical, ProgNameLong & " - *FEHLER*" & " " & myVersion & " (Build: " & app.Revision & ")"
     MsgBox FMT0("ETDLL_13"), vbCritical, ProgNameLong & " - " & FMT0("FREIGABEMM_16") & " " & myVersion & " (Build: " & app.Revision & ")"
     Exit Sub
  Else
  
    Dim conn As Object
    Set conn = GetConnection()

    If conn Is Nothing Then
        'MsgBox "Diese Funktion ist zur Zeit nicht ausf|fffd|hrbar, da das System nicht zur Verf|fffd|gung steht. Bitte versuchen Sie es sp|fffd|ter noch einmal.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        MsgBox FMT0("DOKUPWD_3"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        Exit Sub
    End If

    If Deaktiviert(conn) Then
        'MsgBox "Aktuell steht diese Funktion nicht zur Verf|fffd|gung, da das System deaktiviert wurde. Bitte versuchen Sie es sp|fffd|ter noch einmal.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        MsgBox FMT0("DOKUPWD_4"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        conn.Close
        Set conn = Nothing
        Exit Sub
    End If
  
    Dim rs As Object
    Set rs = OpenRS("SELECT * FROM EPSchablone", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
    If rs Is Nothing Then
        'MsgBox "Es wurden bisher keine Schablonen f|fffd|r die Absicherung von Dateien angelegt. Bitte informieren Sie Ihre Administration.", vbCritical, ProgNameLong & " - *FEHLER*" & " " & myVersion & " (Build: " & app.Revision & ")"
        MsgBox FMT0("ETDLL_14"), vbCritical, ProgNameLong & " - " & FMT0("FREIGABEMM_16") & " " & myVersion & " (Build: " & app.Revision & ")"
        Set rs = Nothing
        conn.Close
        Set conn = Nothing
        Exit Sub
    End If
    
    If rs.EOF Then
        'MsgBox "Es wurden bisher keine Schablonen f|fffd|r die Absicherung von Dateien angelegt. Bitte informieren Sie Ihre Administration.", vbCritical, ProgNameLong & " - *FEHLER*" & " " & myVersion & " (Build: " & app.Revision & ")"
        MsgBox FMT0("ETDLL_14"), vbCritical, ProgNameLong & " - " & FMT0("FREIGABEMM_16") & " " & myVersion & " (Build: " & app.Revision & ")"
        rs.Close
        Set rs = Nothing
        conn.Close
        Set conn = Nothing
        Exit Sub
    End If
    
    Dim selektierteSchablone As Long
    Dim selektierteSchabloneName As String
    Dim rscnt As Long
    
    frmSchablonenwahl.Schablone.Clear
    Do While Not rs.EOF
        frmSchablonenwahl.Schablone.AddItem rs.Fields("SchablonenID").value
        frmSchablonenwahl.Schablone.List(frmSchablonenwahl.Schablone.ListCount - 1, 1) = GetValueFromField(rs, "Schablonenname", "???")
        If GetSetting(appname:="Stromwerken", Section:=progNameShort, Key:="EPSchablone", Default:="---") = GetValueFromField(rs, "Schablonenname", "???") Then
            frmSchablonenwahl.Schablone.ListIndex = frmSchablonenwahl.Schablone.ListCount - 1
        End If
        rs.MoveNext
    Loop
    rs.Close
    Set rs = Nothing
    conn.Close
    Set conn = Nothing
    
    ' Wenn es mehr als eine Schablone gibt, dann anzeigen, ansonsten nicht...
    If frmSchablonenwahl.Schablone.ListCount > 1 Then
      frmSchablonenwahl.Show vbModal
      
      If frmSchablonenwahl.Auswahl = -1 Then
        Exit Sub
      End If
      
      selektierteSchablone = frmSchablonenwahl.Auswahl
      selektierteSchabloneName = frmSchablonenwahl.AuswahlName
    Else
      selektierteSchablone = val(frmSchablonenwahl.Schablone.List(0, 0))
      selektierteSchabloneName = frmSchablonenwahl.Schablone.List(0, 1)
    End If
    
    
  
    Dim destFName As String
    Dim tFile As String
    Dim tpath As String
    Dim tExten As String

    fileSplit xlapp.ActiveWorkbook.fullname, tpath, tFile, tExten
    'destFName = EinfachesSaveAs("Excel-Dateien", "xl*", xlapp.ActiveWorkbook.path, tFile & "_PROT_" & selektierteSchabloneName & "." & tExten, OFS_FILE_SAVE_FLAGS_NO_PROMPT)
    destFName = EinfachesSaveAs(FMT0("ETDLL_15"), "xl*", xlapp.ActiveWorkbook.path, tFile & "_PROT_" & selektierteSchabloneName & "." & tExten, OFS_FILE_SAVE_FLAGS_NO_PROMPT)
    
    If destFName = "" Then Exit Sub
    
    If GetFileExtension(destFName) = "" Then destFName = destFName & "." & tExten
    
    If UCase(xlapp.ActiveWorkbook.fullname) = UCase(destFName) Then
      'MsgBox "Der Zieldateiname muss vom aktuellen Dateinamen abweichen", vbCritical, ProgNameLong & " - *FEHLER*" & " " & myVersion & " (Build: " & app.Revision & ")"
      MsgBox FMT0("ETDLL_16"), vbCritical, ProgNameLong & " - " & FMT0("FREIGABEMM_16") & " " & myVersion & " (Build: " & app.Revision & ")"
      Exit Sub
    End If
    
    If FileExists(destFName) Then
      'If MsgBox("Die Datei " & destFName & " existiert bereits. Soll die Datei |fffd|berschrieben werden?", vbYesNo + vbQuestion, ProgNameLong & " " & " " & myVersion & " (Build: " & app.Revision & ")") = vbNo Then
      If MsgBox(FMT1("ETDLL_17", destFName), vbYesNo + vbQuestion, ProgNameLong & " " & " " & myVersion & " (Build: " & app.Revision & ")") = vbNo Then
        Exit Sub
      End If
      MyKill destFName
    End If
    
    If FileExists(destFName) Then
      'MsgBox "Die Zieldatei " & destFName & " konnte nicht gel|fffd|scht werden. Bitte pr|fffd|fen Sie, ob die Datei schreibgesch|fffd|tzt oder ge|fffd|ffnet ist!", vbCritical, ProgNameLong & " - *FEHLER*" & " " & myVersion & " (Build: " & app.Revision & ")"
      MsgBox FMT1("ETDLL_18", destFName), vbCritical, ProgNameLong & " - " & FMT0("FREIGABEMM_16") & " " & myVersion & " (Build: " & app.Revision & ")"
      Exit Sub
    End If
  
    SaveSetting _
           appname:="Stromwerken", _
           Section:="EP", _
           Key:="COMMAND", _
           Setting:="ETPROT " & selektierteSchablone & " " & Chr(34) & xlapp.ActiveWorkbook.fullname & Chr(34) & " " & Chr(34) & destFName & Chr(34)

    StartDatei epfile, vbNormalFocus
  End If


End Sub



Public Sub SignOffButton_C(ByRef xlapp As Object, ByVal ctrl As Office.CommandBarButton, CancelDefault As Boolean)
 
    If xlapp.ActiveWorkbook Is Nothing Then Exit Sub
    
    Dim conn As Object
    Set conn = GetConnection()

    If conn Is Nothing Then
'        DebugPrint DebType.tERROR, "WBOpen - DBConnect fehlgeschlagen"
        Exit Sub
    End If

On Error GoTo raus
    
    SignOffButton xlapp, conn
    
raus:
    conn.Close
    Set conn = Nothing
    
End Sub

Private Sub SignOffButton(ByRef xlapp As Object, ByRef conn As Object)
       
    Dim curid As Long
    Dim hash As String
    Dim Version As Long
    
    Dim wasLocked As Boolean
    Dim dbAvailable As Boolean

    Dim checkInOk As Boolean
    checkInOk = False
    
    Dim rs As Object
    ' Online-Status holen und ggf. freigebender User
    '
    Dim pwd As Boolean
    pwd = False
    If GetTargetRS(conn, GetUNCPath(xlapp.ActiveWorkbook.fullname), xlapp.ActiveWorkbook, rs, curid, hash, ADODB.LockTypeEnum.adLockPessimistic, wasLocked) Then
      If rs.EOF Then
        'MsgBox "Aktuell steht diese Funktion f|fffd|r diese Datei nicht zur Verf|fffd|gung. Bitte versuchen Sie es sp|fffd|ter noch einmal.", vbInformation + vbSystemModal, GetTitleText
        MsgBox FMT0("ETDLL_19"), vbInformation + vbSystemModal, GetTitleText
        rs.Close
        Set rs = Nothing
        
        Exit Sub
      Else
        curid = rs.Fields("idvDateiID").value
        Version = rs.Fields("Version").value
        pwd = rs.Fields("Dateiberechtigungen").value
      End If
      
      If xlapp.ActiveWorkbook.saved = False Then
        'If MsgBox("Achtung: Die Datei wurde noch nicht gespeichert. Soll sie gespeichert werden? (Hinweis: Bei Nein wird der Sign-Off abgebrochen)", vbYesNo + vbQuestion + vbSystemModal, GetTitleText) = vbNo Then
        If MsgBox(FMT0("ETDLL_20"), vbYesNo + vbQuestion + vbSystemModal, GetTitleText) = vbNo Then
            rs.Close
            Set rs = Nothing
            Exit Sub
        End If
        DoInternalSave rs, xlapp.ActiveWorkbook, conn
        rs.CancelUpdate
      End If
      
      rs.Close
      Set rs = Nothing
    
      Load frmHinweiseZumSignOff
      frmHinweiseZumSignOff.Show vbModal
      If frmHinweiseZumSignOff.signOff = True Then
          If SaveExternalReference(xlapp, xlapp.ActiveWorkbook, pwd, curid, Version, GetUserName(), frmHinweiseZumSignOff.TextKommentar.Text) = True Then
              'MsgBox "Die Datei wurde im Datenbanksystem abgelegt", vbInformation + vbSystemModal, GetTitleText
              MsgBox FMT0("ETDLL_21"), vbInformation + vbSystemModal, GetTitleText
              checkInOk = True
          End If
          
          If checkInOk = False Then
              'MsgBox "Die Datei konnte nicht im Datenbanksystem abgelegt werden.", vbInformation + vbSystemModal, GetTitleText
              MsgBox FMT0("ETDLL_22"), vbInformation + vbSystemModal, GetTitleText
          End If
          
      End If
      Unload frmHinweiseZumSignOff

    Else
      If wasLocked Then
        'MsgBox "Ein anderer User greift gerade auf die Daten der Datei zu, bitte versuchen Sie es sp|fffd|ter noch einmal.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        MsgBox FMT0("ETDLL_23"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
      Else
        'MsgBox "Bevor Sie einen 'Sign-Off' f|fffd|r die Datei durchf|fffd|hren k|fffd|nnen, muss die Datei von Ihnen gespeichert werden.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        MsgBox FMT0("ETDLL_24"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
      End If
    End If

End Sub

Public Sub Dateiberechtigung_C(ByRef xlapp As Object, CancelDefault As Boolean)
    Dim conn As Object
    
    If xlapp.ActiveWorkbook Is Nothing Then Exit Sub
    
    If xlapp.ActiveWorkbook.readOnly Then
      'MsgBox "Achtung! Die Datei ist schreibgesch|fffd|tzt! Bitte |fffd|ffnen Sie die Datei ohne Schreibschutz, um die Dateiberechtigungen anzubringen!", vbExclamation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
      MsgBox FMT0("ETDLL_25"), vbExclamation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
      Exit Sub
    End If
    
    If WBGetValueLong(xlapp.ActiveWorkbook, "_IDVTrackerFreigabeStatus" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix) = 1 Then
        'MsgBox "Die Datei befindet sich aktuell im Freigabeprozess, es k|fffd|nnen keine Berechtigungen modifiziert werden! Der Vorgang wird abgebrochen!", vbCritical, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        MsgBox FMT0("ETDLL_26"), vbCritical, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        Exit Sub
    End If
    
    Set conn = GetConnection()

    If conn Is Nothing Then
        Exit Sub
    End If
    
    If Deaktiviert(conn) Then
        'MsgBox "Aktuell steht diese Funktion nicht zur Verf|fffd|gung, da das System deaktiviert wurde. Bitte versuchen Sie es sp|fffd|ter noch einmal.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        MsgBox FMT0("DOKUPWD_4"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        conn.Close
        Set conn = Nothing
        Exit Sub
    End If
    
    If DateiAusgeschlossen2(xlapp.ActiveWorkbook, conn) = True Then
    ' If DateiAusgeschlossenVariable(xlapp.ActiveWorkbook) = True Then
        'MsgBox "Diese Funktion steht f|fffd|r diese Datei/f|fffd|r Dateien in diesem Verzeichnis nicht zur Verf|fffd|gung.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        MsgBox FMT0("BLATTSCHUTZ_2"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        conn.Close
        Set conn = Nothing
        Exit Sub
    End If
    
    Dim curid As Long
    Dim hash As String
    Dim Version As Long
    
    Dim wasLocked As Boolean
    Dim dbAvailable As Boolean

    Dim checkInOk As Boolean
    checkInOk = False
    
    Dim rs As Object
    ' Online-Status holen und ggf. freigebender User
    '
    If GetTargetRS(conn, GetUNCPath(xlapp.ActiveWorkbook.fullname), xlapp.ActiveWorkbook, rs, curid, hash, ADODB.LockTypeEnum.adLockPessimistic, wasLocked) Then
        Load frmDokuBerechtigungen
        
        frmDokuBerechtigungen.Init xlapp, conn, rs, rs.Fields("idvDateiID").value, rs.Fields("Version").value, False
        frmDokuBerechtigungen.Show vbModal
        If frmDokuBerechtigungen.mOKGeklickt = True Then
            If frmDokuBerechtigungen.Speichern(conn) = True Then
                
                Dim olddispalerts As Boolean
                olddispalerts = xlapp.DisplayAlerts
                xlapp.DisplayAlerts = False
                
                ' wenn die Berechtigung jetzt angeschaltet wurde, dann m|fffd|ssen wir speichern
                If frmDokuBerechtigungen.BerechtigungWurdeAngeschaltet() = True Then
                    rs.Fields("Dateiberechtigungen").value = True
                    StoreRandomPasswordFuerDatei conn, rs.Fields("idvDateiID").value
                    If G_cfgDatenschutzhinweisAus Then
                      DatenschutzhinweisAus xlapp.ActiveWorkbook
                    End If
'                    DoInternalSave rs, xlapp.ActiveWorkbook, conn
                    bInternalSave = True
                    xlapp.ActiveWorkbook.SaveAs xlapp.ActiveWorkbook.fullname, Password:=GetFileOpenPassword(conn, rs), Local:=True
                    bInternalSave = False
                    rs.Update
                    rs.Close
                    Set rs = Nothing
                    conn.Close
                    Set conn = Nothing
                    xlapp.DisplayAlerts = olddispalerts
                    Unload frmDokuBerechtigungen
                    Exit Sub
                
                ElseIf frmDokuBerechtigungen.BerechtigungWurdeAusgeschaltet() = True Then
                    rs.Fields("Dateiberechtigungen").value = False
                    RemoveFileOpenPasswordFuerDatei conn, rs.Fields("idvDateiID").value
                    ' Passwort hier auch angeben, ansonsten wird es nicht gel|fffd|scht
                    If G_cfgDatenschutzhinweisAus Then
                      DatenschutzhinweisAus xlapp.ActiveWorkbook
                    End If
'                    DoInternalSave rs, xlapp.ActiveWorkbook, conn
                    bInternalSave = True
                    xlapp.ActiveWorkbook.SaveAs xlapp.ActiveWorkbook.fullname, Password:="", Local:=True
                    bInternalSave = False
                    rs.Update
                    rs.Close
                    Set rs = Nothing
                    conn.Close
                    Set conn = Nothing
                    xlapp.DisplayAlerts = olddispalerts
                    Unload frmDokuBerechtigungen
                    Exit Sub
                End If
                xlapp.DisplayAlerts = olddispalerts
            Else
                rs.Fields("Dateiberechtigungen").value = False
            End If
            rs.Update
        End If
        Unload frmDokuBerechtigungen
        rs.Close
    Else
        If wasLocked Then
          'MsgBox "Ein anderer User greift gerade auf die Daten der Datei zu, bitte versuchen Sie es sp|fffd|ter noch einmal.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
          MsgBox FMT0("BLATTSCHUTZ_3"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        Else
          'MsgBox "Bevor Sie Berechtigungen f|fffd|r die Datei vergeben k|fffd|nnen, muss die Datei von Ihnen gespeichert werden.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
          MsgBox FMT0("ETDLL_27"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        End If
    End If
    Set rs = Nothing

    conn.Close
    Set conn = Nothing

End Sub

Public Sub DateiOeffnen_C(ByRef xlapp As Object, CancelDefault As Boolean)
    Dim conn As Object
    Set conn = GetConnection()

    If conn Is Nothing Then
        Exit Sub
    End If
    
    If Deaktiviert(conn) Then
        'MsgBox "Aktuell steht diese Funktion nicht zur Verf|fffd|gung, da das System deaktiviert wurde. Bitte versuchen Sie es sp|fffd|ter noch einmal.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        MsgBox FMT0("DOKUPWD_4"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        conn.Close
        Set conn = Nothing
        Exit Sub
    End If

On Error GoTo raus
    Dim filename As String
    filename = EinfacheDateiauswahl
    
    If filename = "" Then Exit Sub
    Dim filenameU As String
    filenameU = GetUNCPath(filename)
    Dim intCount As Long
    
    For intCount = 1 To xlapp.Workbooks.count
       If GetUNCPath(xlapp.Workbooks(intCount).fullname) = filenameU Then
          'MsgBox "Die Datei ist bereits ge|fffd|ffnet.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
          MsgBox FMT0("ETDLL_28"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
          conn.Close
          Set conn = Nothing
          Exit Sub
       End If
    Next intCount
    
    Dim oldenev As Boolean
    oldenev = xlapp.EnableEvents
    xlapp.EnableEvents = True
    Dim oldalert As Boolean
    oldalert = xlapp.DisplayAlerts
    xlapp.DisplayAlerts = True
    xlapp.AskToUpdateLinks = True
    Dim oldAutomation As Long
    oldAutomation = xlapp.AutomationSecurity
    'xlapp.AutomationSecurity = msoAutomationSecurityLow
    
    Dim dateiGeoeffnet As Boolean
    dateiGeoeffnet = False
    
    Dim wb As Excel.Workbook
    Dim uncfname As String
    uncfname = GetUNCPath(filename)
     
    ' Datei einfach mal |fffd|ffnen
    G_CheckDateiberechtigungBeimOeffnen = True
    'BitteWarten.BitteWartenText.Caption = "Bitte warten, Datei wird geladen"
    BitteWarten.BitteWartenText.Caption = FMT0("ETDLL_29")
    BitteWarten.Label1.Caption = ""
    BitteWarten.Show vbModeless
    DoEvents
    Application.visible = False
    If DateiOeffnenMitPW(xlapp, filename, GetStandardPassword()) = True Then
        Set wb = GetExcelWorkbook(xlapp, uncfname)
        If Not wb Is Nothing Then
          dateiGeoeffnet = True
        End If
    End If
    BitteWarten.Hide
    Application.visible = True
    
    xlapp.EnableEvents = oldenev
    xlapp.DisplayAlerts = oldalert
    xlapp.AutomationSecurity = oldAutomation
    
    conn.Close
    Set conn = Nothing
    
    If dateiGeoeffnet = False Then
        'MsgBox "Die Datei konnte nicht ge|fffd|ffnet werden. Entweder haben Sie keine ausreichenden Berechtigungen oder die Datei wurde nicht mit dem ExcelTracker gesch|fffd|tzt. Bitte versuchen Sie die Datei |fffd|ber die Standard-Funktionen von Excel zu |fffd|ffnen!", vbCritical, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        MsgBox FMT0("ETDLL_30"), vbCritical, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
    End If
    Exit Sub
raus:
    If Not conn Is Nothing Then
        conn.Close
        Set conn = Nothing
    End If
    
End Sub

Private Function GetExcelWorkbook(ByRef xlapp As Object, ByVal filenameU As String) As Object
    Set GetExcelWorkbook = Nothing

    On Error GoTo raus
    Dim wb As Excel.Workbook
    Dim intCount As Long
    For intCount = 1 To xlapp.Workbooks.count
       If GetUNCPath(xlapp.Workbooks(intCount).fullname) = filenameU Then
          Set GetExcelWorkbook = xlapp.Workbooks(intCount)
          Exit Function
       End If
    Next intCount
raus:
End Function


' 2 Datenbank weg
' 1 ausschlie|fffd|en
' 0 ok

Function CheckAusschluss(ByRef wb As Excel.Workbook, ByRef conn As Object) As Boolean

  CheckAusschluss = DateiAusgeschlossen2(wb, conn)
          
End Function

Function GetData() As String
  GetData = ""
End Function


#If Project_ExcelTracker = 1 Then
Public Sub Lock_C(ByRef xlapp As Object, CancelDefault As Boolean)
    Dim conn As Object
    Set conn = GetConnection()
    
    If conn Is Nothing Then
        'MsgBox "Diese Funktion ist zur Zeit nicht ausf|fffd|hrbar, da das System nicht zur Verf|fffd|gung steht. Bitte versuchen Sie es sp|fffd|ter noch einmal.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        MsgBox FMT0("DOKUPWD_3"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        Exit Sub
    End If
    
    If conn Is Nothing Then
        'MsgBox "Diese Funktion ist zur Zeit nicht ausf|fffd|hrbar, da das System nicht zur Verf|fffd|gung steht. Bitte versuchen Sie es sp|fffd|ter noch einmal.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        MsgBox FMT0("DOKUPWD_3"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        Exit Sub
    End If

    If Deaktiviert(conn) Then
        'MsgBox "Aktuell steht diese Funktion nicht zur Verf|fffd|gung, da das System deaktiviert wurde. Bitte versuchen Sie es sp|fffd|ter noch einmal.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        MsgBox FMT0("DOKUPWD_4"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        conn.Close
        Set conn = Nothing
        Exit Sub
    End If


    If G_PARAM_LokaleDateienBer|fffd|cksichtigen = False And Left(GetUNCPath(xlapp.ActiveWorkbook.fullname), 2) <> "//" And Left(GetUNCPath(xlapp.ActiveWorkbook.fullname), 2) <> "\\" And InStr(xlapp.ActiveWorkbook.fullname, "://") <= 0 Then
      'MsgBox "Es k|fffd|nnen nur Excel-Dateien freigegeben werden, die auf einem Netzlaufwerk gespeichert wurden. Nutzen Sie Datei / Speichern unter, legen das Programm auf einem Netzwerkpfad ab und rufen diese Funktion erneut auf.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
      MsgBox FMT0("BLATTSCHUTZ_1"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
      conn.Close
      Set conn = Nothing
      Exit Sub
    End If

    If DateiAusgeschlossen2(xlapp.ActiveWorkbook, conn) = True Then
    ' If DateiAusgeschlossenVariable(GetCurrentProjectObject(xlapp)) = True Then
        'MsgBox "Diese Funktion steht f|fffd|r diese Datei/f|fffd|r Dateien in diesem Verzeichnis nicht zur Verf|fffd|gung.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        MsgBox FMT0("BLATTSCHUTZ_2"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        conn.Close
        Set conn = Nothing
        Exit Sub
    End If
    
    Dim rs As Object
    Set rs = CreateObject("ADODB.Recordset")
    Dim curid As Long
    Dim hash As String

    ' Wenn Sie bereits gespeichert wurde...
    Dim wasLocked As Boolean
    If Not GetTargetRS(conn, GetUNCPath(xlapp.ActiveWorkbook.fullname), xlapp.ActiveWorkbook, rs, curid, hash, ADODB.LockTypeEnum.adLockPessimistic, wasLocked) Then
        If wasLocked Then
          'MsgBox "Ein anderer User greift gerade auf die Daten der Datei zu, bitte versuchen Sie es sp|fffd|ter noch einmal.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
          MsgBox FMT0("BLATTSCHUTZ_3"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        Else
          'MsgBox "Bevor Sie diese Funktion verwenden k|fffd|nnen, muss die Datei von Ihnen gespeichert werden.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
          MsgBox FMT0("BLATTSCHUTZ_4"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        End If
        Set rs = Nothing
        conn.Close
        Set conn = Nothing
        Exit Sub
    End If
    
    If Not UserKannFreigeben(G_CfgBSSetzen, rs) Then
      ' Sie sind nicht dazu berechtigt, diese Funktion auszuf|fffd|hren. Bitte wenden Sie sich an die Programmverantwortlichen.\n\n%1
      MsgBox FMT1("FREIGABE_1", GetVerantwortlicheUser(conn, rs, G_CfgBSSetzen)), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
      rs.Close
      Set rs = Nothing
      conn.Close
      Set conn = Nothing
      Exit Sub
    End If

    If Not xlapp.ActiveWorkbook.saved Then
      'If MsgBox("ACHTUNG: Sollte der Blattschutz nicht erfolgreich angebracht werden k|fffd|nnen, wird die Datei ohne Speicherung geschlossen, um unerw|fffd|nschte Nebeneffekte zu vermeiden. Falls Sie |fffd|nderungen an der Datei vorgenommen haben, gehen diese dann verloren! Sind Sie sicher, dass Sie Tabellenbl|fffd|tter sch|fffd|tzen wollen? ", vbQuestion + vbYesNo, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")") = vbNo Then
      If MsgBox(FMT0("BLATTSCHUTZ_5"), vbQuestion + vbYesNo, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")") = vbNo Then
        rs.Close
        Set rs = Nothing
        conn.Close
        Set conn = Nothing
        Exit Sub
      End If
    End If
    
    BlattschutzAnbringen conn, rs, xlapp, xlapp.ActiveWorkbook, True
    
    rs.Close
    Set rs = Nothing
    conn.Close
    Set conn = Nothing
End Sub
Public Sub Unlock_C(ByRef xlapp As Object, CancelDefault As Boolean)
  
  Dim conn As Object
  Set conn = GetConnection()
  
  If conn Is Nothing Then
      'MsgBox "Diese Funktion ist zur Zeit nicht ausf|fffd|hrbar, da das System nicht zur Verf|fffd|gung steht. Bitte versuchen Sie es sp|fffd|ter noch einmal.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
      MsgBox FMT0("DOKUPWD_3"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
      Exit Sub
  End If

  If Deaktiviert(conn) Then
      'MsgBox "Aktuell steht diese Funktion nicht zur Verf|fffd|gung, da das System deaktiviert wurde. Bitte versuchen Sie es sp|fffd|ter noch einmal.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
      MsgBox FMT0("DOKUPWD_4"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
      conn.Close
      Set conn = Nothing
      Exit Sub
  End If

  If G_PARAM_LokaleDateienBer|fffd|cksichtigen = False And Left(GetUNCPath(xlapp.ActiveWorkbook.fullname), 2) <> "//" And Left(GetUNCPath(xlapp.ActiveWorkbook.fullname), 2) <> "\\" And InStr(xlapp.ActiveWorkbook.fullname, "://") <= 0 Then
    'MsgBox "Es k|fffd|nnen nur Excel-Dateien freigegeben werden, die auf einem Netzlaufwerk gespeichert wurden. Nutzen Sie Datei / Speichern unter, legen das Programm auf einem Netzwerkpfad ab und rufen diese Funktion erneut auf.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
    MsgBox FMT0("BLATTSCHUTZ_1"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
    conn.Close
    Set conn = Nothing
    Exit Sub
  End If

  If DateiAusgeschlossen2(xlapp.ActiveWorkbook, conn) = True Then
  ' If DateiAusgeschlossenVariable(GetCurrentProjectObject(xlapp)) = True Then
      'MsgBox "Diese Funktion steht f|fffd|r diese Datei/f|fffd|r Dateien in diesem Verzeichnis nicht zur Verf|fffd|gung.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
      MsgBox FMT0("BLATTSCHUTZ_2"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
      conn.Close
      Set conn = Nothing
      Exit Sub
  End If
  
  Dim rs As Object
  Set rs = CreateObject("ADODB.Recordset")
  Dim curid As Long
  Dim hash As String

  ' Wenn Sie bereits gespeichert wurde...
  Dim wasLocked As Boolean
  If Not GetTargetRS(conn, GetUNCPath(xlapp.ActiveWorkbook.fullname), xlapp.ActiveWorkbook, rs, curid, hash, ADODB.LockTypeEnum.adLockPessimistic, wasLocked) Then
      If wasLocked Then
        'MsgBox "Ein anderer User greift gerade auf die Daten der Datei zu, bitte versuchen Sie es sp|fffd|ter noch einmal.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        MsgBox FMT0("BLATTSCHUTZ_3"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
      Else
        'MsgBox "Bevor Sie diese Funktion verwenden k|fffd|nnen, muss die Datei von Ihnen gespeichert werden.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        MsgBox FMT0("BLATTSCHUTZ_4"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
      End If
      Set rs = Nothing
      conn.Close
      Set conn = Nothing
      Exit Sub
  End If
  
  If Not UserKannFreigeben(G_CfgBSEntf, rs) Then
    ' Sie sind nicht dazu berechtigt, diese Funktion auszuf|fffd|hren. Bitte wenden Sie sich an die Programmverantwortlichen.\n\n%1
    MsgBox FMT1("FREIGABE_1", GetVerantwortlicheUser(conn, rs, G_CfgBSEntf)), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
    rs.Close
    Set rs = Nothing
    conn.Close
    Set conn = Nothing
    Exit Sub
  End If
  
  BlattschutzEntfernen conn, rs, xlapp, xlapp.ActiveWorkbook, True

  rs.Close
  Set rs = Nothing
  conn.Close
  Set conn = Nothing


End Sub
#End If

Public Sub DokuInWord_C(ByRef xlapp As Object, CancelDefault As Boolean)
  
  If xlapp.ActiveWorkbook Is Nothing Then Exit Sub
  
  Dim curdoc As Object
  Set curdoc = xlapp.ActiveWorkbook
    
  If FileExists(G_Dokuformular) Then
    Dim fNameFreigabeformular As String
    
    Dim conn As Object
    Set conn = GetConnection()
    If conn Is Nothing Then
        'MsgBox "Diese Funktion ist zur Zeit nicht ausf|fffd|hrbar, da das System nicht zur Verf|fffd|gung steht. Bitte versuchen Sie es sp|fffd|ter noch einmal.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        MsgBox FMT0("DOKUPWD_3"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        Exit Sub
    End If
    If Deaktiviert(conn) Then
        'MsgBox "Aktuell steht diese Funktion nicht zur Verfugung, da das System deaktiviert wurde. Bitte versuchen Sie es spater noch einmal.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        MsgBox FMT0("DOKUPWD_4"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        conn.Close
        Set conn = Nothing
        Exit Sub
    End If

    Dim rs As Object
    Set rs = CreateObject("ADODB.Recordset")

    Dim curid As Long
    Dim hash As String
    
    Dim wasLocked As Boolean
    If GetTargetRS(conn, GetUNCPathFromDoc(curdoc), curdoc, rs, curid, hash, ADODB.LockTypeEnum.adLockReadOnly, wasLocked, True) Then ' .adLockOptimistic) Then
      
      Dim userFreigabe As String
      If GetSafeFieldPlus(rs, "Freigabestatus", 0) = 2 Then
        Dim trs As Object
        Set trs = OpenRS("SELECT FreigebenderUser from idvDateienFreigaben where idvDateiID = " & rs.Fields("FreigabeidvDateiID") & " and Status = 0", conn, ADODB.CursorTypeEnum.adOpenForwardOnly, ADODB.LockTypeEnum.adLockReadOnly)
        If Not trs Is Nothing Then
          If Not trs.EOF Then
            userFreigabe = trs.Fields("FreigebenderUser").value
            trs.Close
          End If
          Set trs = Nothing
        End If
        
      End If
      
      CreateFreigabeformular curdoc, G_Dokuformular, "", xlapp, rs, conn, fNameFreigabeformular, 0, False, "", "", "", "", _
        IIf(GetSafeFieldPlus(rs, "Freigabestatus", 0) >= 1, GetSafeFieldPlus(rs, "FreigabeInitUserLogonID", ""), ""), _
        userFreigabe
    End If
    rs.Close
    Set rs = Nothing
  Else
    'MsgBox "Die Datei " & G_Dokuformular & " ist nicht vorhanden.", vbInformation, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
    MsgBox FMT1("ETDLL_31", G_Dokuformular), vbInformation, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
  End If

End Sub

Public Sub Info_C(ByRef xlapp As Object, CancelDefault As Boolean)
    If FileExists(G_cfgInfoPfad) Then
        Dim s2 As String
        s2 = AnwendungFuerDatei(G_cfgInfoPfad)
        If "" <> s2 Then
            Shell Chr(34) & s2 & Chr(34) & " " & Chr(34) & G_cfgInfoPfad & Chr(34), vbNormalFocus
        End If
    End If
End Sub

Public Sub AppInfo_C(ByRef xlapp As Object, CancelDefault As Boolean)
    frmAppInfo.Caption = ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
    If Not IsFormLoaded("frmAppInfo") Then Load frmAppInfo
    
    If G_CfgAppinfoLog Then
      frmAppInfo.LogText = G_Log
    End If
    
    If G_CfgAppinfoInfo Then
      frmAppInfo.VersionInfo.Text = GetProgramInfo()
      frmAppInfo.VersionInfo.SelStart = 1
    End If
    
    If G_CfgAppinfoAnalysis Then
      frmAppInfo.GetAnalysis
    End If
    
    frmAppInfo.MultiPageCtrl.Pages(0).visible = G_CfgAppinfoInfo
    frmAppInfo.MultiPageCtrl.Pages(1).visible = G_CfgAppinfoAnalysis
    frmAppInfo.MultiPageCtrl.Pages(2).visible = G_CfgAppinfoLog
          
    frmAppInfo.Show vbModeless
End Sub

Function GetProgramInfo() As String
  Dim s As String
  Const L_StringLen As Long = 25
  Dim oAddin As AddIn
  Dim oCOMAddin As COMAddIn
  
  Dim is64bit As Boolean
#If VBA7 And Win64 Then
  is64bit = True
#Else
  is64bit = False
#End If
  
  ' Programmversion
  s = ExtendSystemString(FMT0("APPINFO_1") & ": ", L_StringLen) & ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")" & vbCrLf
  s = s & ExtendSystemString(FMT0("APPINFO_9") & ": ", L_StringLen) & Application.Version & IIf(is64bit, " (64 Bit)", " (32 Bit)") & vbCrLf
'  s = s & FMT0("APPINFO_10") & ": " & Application.OperatingSystem & vbCrLf
  
  ' Datenbank Connection-String
  s = s & "-----------------------------------------------------------------------" & vbCrLf
  s = s & FMT0("APPINFO_2") & ": " & vbCrLf & G_DBConnectionString & vbCrLf
  s = s & "-----------------------------------------------------------------------" & vbCrLf
  ' Standard Addins
  s = s & FMT0("APPINFO_3") & vbCrLf
  s = s & "-----------------------------------------------------------------------" & vbCrLf
  For Each oAddin In Application.AddIns
      s = s & oAddin.name & vbCrLf & _
        "  " & "Full-Name: " & oAddin.fullname & vbCrLf & _
        "  " & "CLSID:     " & oAddin.CLSID & vbCrLf & _
        "  " & "Creator:   " & oAddin.Creator & vbCrLf & _
        "  " & "Installed: " & oAddin.Installed & vbCrLf & _
        "  " & "IsOpen:    " & oAddin.IsOpen & vbCrLf & _
        "  " & "Path:      " & oAddin.path & vbCrLf & _
        "  " & "ProgID:    " & oAddin.progID & vbCrLf
  Next oAddin

  s = s & "-----------------------------------------------------------------------" & vbCrLf
  ' Com Addins
  s = s & FMT0("APPINFO_4") & vbCrLf
  s = s & "-----------------------------------------------------------------------" & vbCrLf
  For Each oCOMAddin In Application.COMAddIns
      s = s & oCOMAddin.progID & vbCrLf & _
        "  " & "Connected:   " & oCOMAddin.connect & vbCrLf & _
        "  " & "Description: " & oCOMAddin.Description & vbCrLf & _
        "  " & "GUID:        " & oCOMAddin.guid & vbCrLf
  Next oCOMAddin
  GetProgramInfo = s
End Function
Attribute VB_Name = "ExternalReference"
Option Explicit

' alle externen Referenzen dieser Datei ins Temp Verzeichnis |fffd|ffnen
' inkl dieser Datei und dann alle in die Tabelle xlBinSignOff aufnehmen
' unter der DateiID und Versionsnummer dieser Datei + aktuelles Datum
Function SaveExternalReference(ByRef xlapp As Excel.Application, ByRef oxlw As Excel.Workbook, ByVal pwd As Boolean, ByVal idvDateiID As Long, ByVal Version As Long, ByVal userLogonId As String, ByVal kommentar As String) As Boolean

    Dim outputsheet As String
    Dim subWBs As New Collection
    Dim errText As String
    
    Dim colFilenames As New Collection
    
    If OpenExternalReferences(xlapp, oxlw, outputsheet, subWBs, errText) Then
   
        SaveExternalReferencesToTemp subWBs, colFilenames
        
        Dim tempFilename As String
        
        ' und das aktuelle Workbook auch in den Tempordner packen
        SaveSetting _
            appname:="Stromwerken", _
            Section:="ExcelTracker", _
            Key:="IgnoreThisOne", _
            Setting:="True"
        
        tempFilename = GetFileNameAndPath(CreateTempFile("Tmp")) & "0" & GetFileNameAndExtension(oxlw.fullname)
        If G_cfgDatenschutzhinweisAus Then
          DatenschutzhinweisAus oxlw
        End If
        If pwd <> False Then
            oxlw.SaveAs tempFilename, Local:=True, Password:=""
        Else
            oxlw.SaveAs tempFilename, Local:=True
        End If
        
        Dim xlSaved As Boolean
        xlSaved = True
        
        
        Dim dat As Date
        dat = Now
        Dim errstr As String
        errstr = ""
        
        Dim i As Long
        For i = 0 To colFilenames.count
            Dim saveFilename As String
            If i > 0 Then
                saveFilename = colFilenames(i)
            Else
                saveFilename = tempFilename
            End If
            
            If xlCheckInSignOff(idvDateiID, Version, i, dat, userLogonId, saveFilename, errstr, kommentar) = False Then
                GoTo errMsg
            End If
        Next i
        
        oxlw.Close
        SaveExternalReference = True
        
cleanup:
        SaveExternalReferencesCleanUp colFilenames
        MyKill tempFilename
        
        Exit Function
    End If
    
    Exit Function

errMsg:
    ' sollte ich hier die DB wieder aufr|fffd|umen?
    SaveExternalReference = False
    If xlSaved Then
      oxlw.Close False
    End If
    
    SaveExternalReferencesCleanUp colFilenames
    
End Function

Private Function SaveExternalReferencesCleanUp(ByRef colFilenames As Collection) As Boolean
    On Error Resume Next
    ' TempFiles l|fffd|schen
    Dim i As Long
    For i = 0 To colFilenames.count
        MyKill colFilenames(i)
    Next i
    SaveExternalReferencesCleanUp = True
End Function

Private Function SaveExternalReferencesToTemp(ByRef subWBs As Collection, ByRef colFilenames As Collection) As Boolean
    Dim i As Long
    Dim tempFilename As String
    
    Set colFilenames = New Collection
    
    On Error GoTo err
    
    For i = subWBs.count To 1 Step -1
        
        Dim oWorkb As Excel.Workbook
        Set oWorkb = subWBs(i)
                    
        SaveSetting _
               appname:="Stromwerken", _
               Section:="ExcelTracker", _
               Key:="IgnoreThisOne", _
               Setting:="True"
        tempFilename = GetFileNameAndPath(CreateTempFile("Tmp")) & CStr(i) & GetFileNameAndExtension(oWorkb.fullname)
        If G_cfgDatenschutzhinweisAus Then
          DatenschutzhinweisAus oWorkb
        End If
        oWorkb.SaveAs tempFilename, Local:=True
        oWorkb.Close
        colFilenames.add tempFilename
    Next i

err:
    SaveExternalReferencesToTemp = True
End Function


Function OpenExternalReferences(ByRef xlapp As Excel.Application, ByRef wb As Workbook, outputsheet As String, ByRef subWBs As Collection, ByRef errTxt As String) As Boolean
  On Error GoTo nogo
  Dim aLinks
  Dim i As Long
  Dim Result As Boolean
  Result = True

#If EXTERNAL_REIN = 1 Then
  aLinks = wb.LinkSources(xlExcelLinks)
  If Not IsEmpty(aLinks) Then
      For i = 1 To UBound(aLinks)
        If FileExists(CStr(aLinks(i))) Then
          Dim wbsub As Workbook
          If GetFile(xlapp, CStr(aLinks(i)), wbsub, outputsheet) Then
            subWBs.add wbsub
            If Not OpenExternalReferences(xlapp, wbsub, outputsheet, subWBs, errTxt) Then
              Result = False
            End If
          Else
            errTxt = errTxt & IIf(errTxt <> "", vbLf, "") & FMT1("EXTERNALR_1", CStr(aLinks(i)))
            Result = False
          End If
        Else
          errTxt = errTxt & IIf(errTxt <> "", vbLf, "") & FMT1("EXTERNALR_2", CStr(aLinks(i)))
          Result = False
        End If
      Next i
  End If
#End If
  OpenExternalReferences = Result
  
  Exit Function
nogo:
  
End Function

Function GetFile(ByRef conn As Object, ByRef xlapp As Application, filename As String, ByRef oxlwbook As Excel.Workbook, outputsheet As String) As Boolean
  Dim msgBoxText As String
  
  GetFile = True
  ' |fffd|ffnen der Datei - Bei Error auf Passwort pr|fffd|fen
  On Error GoTo hatPasswort
  Dim oldenev As Boolean
  oldenev = xlapp.EnableEvents
  xlapp.EnableEvents = False
  Dim oldalert As Boolean
  oldalert = xlapp.DisplayAlerts
  xlapp.DisplayAlerts = False
  xlapp.AskToUpdateLinks = False
  Dim oldAutomation As Long
  oldAutomation = xlapp.AutomationSecurity
  xlapp.AutomationSecurity = msoAutomationSecurityLow

'  If UCase(right(Filename, 5)) = ".XLSX" Then
'    GetFile = False
'    Exit Function
'  End If
  
  'SetLiveStatusFunc "WorkbooksOpen", True
  'AddStatus "|fffd|ffne " & Filename
'  If (outputsheet <> "m" And StartedByTracker = False) Or G_UserStartedProgram = True Then
'        If Application.Version = "12.0" Or Application.Version = "13.0" Then
    Dim pw As String
    pw = GetFilePassword(conn, filename)
    If pw <> "" Then
          Set oxlwbook = xlapp.Workbooks.Open(ShortFileName(filename), False, True, , pw, , True, , , IIf(UCase(Right(filename, 5)) = ".XLTM", True, IIf(UCase(Right(filename, 5)) = ".XLTX", True, IIf(UCase(Right(filename, 4)) = ".XLT", True, False))), False, , False)
    Else
          Set oxlwbook = xlapp.Workbooks.Open(ShortFileName(filename), False, True, , , , True, , , IIf(UCase(Right(filename, 5)) = ".XLTM", True, IIf(UCase(Right(filename, 5)) = ".XLTX", True, IIf(UCase(Right(filename, 4)) = ".XLT", True, False))), False, , False)
    End If
'        Else
'          Set oxlwbook = ThisWorkbook.Application.Workbooks.Open(ShortFileName(Filename), False, True, , , , True, , , IIf(UCase(Right(Filename, 4)) = ".XLT", True, False), False, , False)
'        End If
'  Else
'        If Application.Version = "12.0" Or Application.Version = "13.0" Then
'          Set oxlwbook = ThisWorkbook.Application.Workbooks.Open(ShortFileName(Filename), False, True, , "Testpasswort", , True, , , IIf(UCase(Right(Filename, 5)) = ".XLTX", True, IIf(UCase(Right(Filename, 4)) = ".XLT", True, False)), False, , False)
'        Else
'          Set oxlwbook = ThisWorkbook.Application.Workbooks.Open(ShortFileName(Filename), False, True, , "Testpasswort", , True, , , IIf(UCase(Right(Filename, 4)) = ".XLT", True, False), False, , False)
'        End If
'  End If
  xlapp.AutomationSecurity = oldAutomation
 ' SetLiveStatusFunc "WorkbooksOpen", False
  'SetLiveStatus
    
  xlapp.AskToUpdateLinks = True
  xlapp.DisplayAlerts = oldalert
  xlapp.EnableEvents = oldenev
  GoTo openOk
  
hatPasswort:

    On Error GoTo 0
    
    GetFile = False
    Exit Function
openOk:
  ' On Error wieder zur|fffd|cksetzen
  On Error GoTo 0
      
  ' 3.4.03 - Nt
  ' Wenn das Projekt gesch|fffd|tzt ist, muss ein gesonderter Warnvermerk ausgegeben werden!
 ' VBAFailure = 0
  On Error GoTo CheckNewerVersion
  
'  If Not CheckVBAAccessAllowed() Then
'  End If
  
  
  'If oxlwbook.VBProject.Protection = 1 Then ' vbext_pp_locked
   '   VBAFailure = 1
    
    
Debug.Print "XXX Hier muss noch der VBA-Test rein"
'    If Len(EinzelMappe) > 0 Then
'      msgBoxText = "Das VBA-Projekt ist gesch|fffd|tzt, bitte entfernen Sie den Schutz zuerst."
'      MsgBox msgBoxText
'    Else
        ' Ansonsten wird nur beim Status eingetragen, dass die Datei gesch|fffd|tzt ist
'        Workbooks(massenmappe).Sheets(Texte(GSprache, TXT_ANS_MASSENANALYSE)).Cells(line, 2).Value = "Das VBA-Projekt ist gesch|fffd|tzt, bitte entfernen Sie den Schutz zuerst."
'    End If
'    oXLWBook.Close False
'    Exit Sub
  'End If
  GoTo continueCheck

CheckNewerVersion:
Debug.Print "XXX Hier muss noch der VBA-Test raus"
  On Error GoTo 0
'  If Len(EinzelMappe) > 0 And Len(MassenMappe) = 0 Then
'    msgBoxText = Texte(GSprache, TXT_VBAPR|fffd|FUNG)
'    MsgBox msgBoxText
'  End If
'  If Len(MassenMappe) > 0 Then
    ' Ansonsten wird nur beim Status eingetragen, dass die Datei gesch|fffd|tzt ist
'    Workbooks(MassenMappe).Sheets(Texte(GSprache, TXT_ANS_MASSENANALYSE)).Cells(line, tabxM2).Value = Texte(GSprache, TXT_VBAPR|fffd|FUNG)
'  End If
  'VBAFailure = 2
  
continueCheck:

End Function




Attribute VB_Name = "Freigabeformular"
Option Explicit


#If Project_ExcelTracker = 1 Then
Function GetExternalReferences(ByRef curdoc As Object) As String
  On Error GoTo nogo
  Dim aLinks
  Dim i As Long
  Dim res As String
  
  aLinks = curdoc.LinkSources(xlExcelLinks)
  If Not IsEmpty(aLinks) Then
      For i = 1 To UBound(aLinks)
        ' missingexternalFiles.AddValue "", LongFileName(GetUNCPath(CStr(aLinks(i))))
        res = res & CStr(aLinks(i)) & vbCrLf
      Next i
  End If
  GetExternalReferences = res
  Exit Function
nogo:
  
End Function
#End If

Function GetWord() As Object
    On Error Resume Next
    Set GetWord = GetObject(, "Word.Application")
    If err.Number = 429 Then Set GetWord = CreateObject("Word.Application")
End Function


' storeFileType: 0 = kein Store, 1 in formularstorepath, 2 in Temp-Ordner, 3 in User-Temp-Ordner mit TmpID-username.EXT

' Function CreateFreigabeformular(ByRef curDoc As Object, formularfile As String, formularstorepath As String, ByRef officeapp As Object, ByRef dateiRS As Object, ByRef conn As Object, ByRef fNameFreigabeformular As String, storeFileType As Long, ByVal closeResultForm As Boolean) As Boolean
Function CreateFreigabeformular(ByRef curdoc As Object, formularfile As String, formularstorepath As String, ByRef officeapp As Object, _
ByRef dateiRS As Object, ByRef conn As Object, ByRef fNameFreigabeformular As String, storeFileType As Long, ByVal closeResultForm As Boolean, _
ByVal fname As String, ByVal fdate As String, ByVal fnamecompare As String, ByVal fdatecompare As String, _
Optional initiierenderUser As String = "", Optional freigenderUser As String = "") As Boolean

  On Error GoTo nogo

  CreateFreigabeformular = False
  
  If formularfile = "" Then Exit Function
  
  ' Die Word, Excel oder nothing
  Dim oOfficeApp As Object
  Dim officeType As Long ' 1 = word, 2 = Excel, 3 = txt
  Dim freigtxtfile As String
  Dim errstr As String
  
  If Not FileExists(formularfile) Then
    DebugPrint tERROR, "Formulardatei '" & formularfile & "' nicht vorhanden!"
    Exit Function
  End If
  
  If UCase(Right(formularfile, 5)) = ".XLTX" Or UCase(Right(formularfile, 4)) = ".XLT" Or UCase(Right(formularfile, 5)) = ".XLSX" Or UCase(Right(formularfile, 4)) = ".XLS" Then
    Set oOfficeApp = New Excel.Application
    If UCase(Right(formularfile, 5)) = ".XLTX" Or UCase(Right(formularfile, 4)) = ".XLT" Then
      oOfficeApp.Workbooks.add formularfile
    Else
      oOfficeApp.Workbooks.Open formularfile, , True
    End If
    officeType = 2
  
  ElseIf UCase(Right(formularfile, 5)) = ".DOTX" Or UCase(Right(formularfile, 5)) = ".DOCX" Or UCase(Right(formularfile, 4)) = ".DOT" Or UCase(Right(formularfile, 4)) = ".DOC" Then
      ' Word |fffd|ffnen
    Set oOfficeApp = GetWord()
    If oOfficeApp Is Nothing Then Exit Function
    oOfficeApp.DOCUMENTS.add Template:=formularfile, NewTemplate:=False
    officeType = 1
  ElseIf UCase(Right(formularfile, 4)) = ".TXT" Then
    If Not LoadFile(formularfile, freigtxtfile, errstr) Then Exit Function
    officeType = 3
  Else
    Exit Function
  End If

  If officeType <= 2 Then
    oOfficeApp.visible = True
  End If

  #If Project_ExcelTracker = 1 Then
    ReplaceText freigtxtfile, officeType, oOfficeApp, "#ISEXCEL#", "X"
    ReplaceText freigtxtfile, officeType, oOfficeApp, "#ISACCESS#", ""
    ReplaceText freigtxtfile, officeType, oOfficeApp, "#ISINDIV#", ""
  #ElseIf PROJECT_ACCESSTRACKER = 1 Then
    ReplaceText freigtxtfile, officeType, oOfficeApp, "#ISEXCEL#", ""
    ReplaceText freigtxtfile, officeType, oOfficeApp, "#ISACCESS#", "X"
    ReplaceText freigtxtfile, officeType, oOfficeApp, "#ISINDIV#", ""
  #Else
    ReplaceText freigtxtfile, officeType, oOfficeApp, "#ISEXCEL#", ""
    ReplaceText freigtxtfile, officeType, oOfficeApp, "#ISACCESS#", ""
    ReplaceText freigtxtfile, officeType, oOfficeApp, "#ISINDIV#", "X"
  #End If
  
  
  ' XXX FIX Value = NULL

  G_Version = dateiRS.Fields("Version").value
  G_DateiID = dateiRS.Fields("idvDateiID").value

  Dim locVersion As Long
  Dim locDateiID As Long
  locVersion = G_Version
  locDateiID = G_DateiID

  G_DokuOKClicked = False

  G_FreigegebenesProgramm = 0
  ' If dateiRS.Fields("FreigabeStatus").value > 0 Then
  If IstDateiFreigabeStatusInitiiertOderFreigegeben(dateiRS) = True Then
      G_FreigegebenesProgramm = dateiRS.Fields("FreigabeStatus").value
  End If

  ReplaceText freigtxtfile, officeType, oOfficeApp, "#DATEINAME#", fname
  ReplaceText freigtxtfile, officeType, oOfficeApp, "#DATEIDATUM#", fdate
  ReplaceText freigtxtfile, officeType, oOfficeApp, "#DATEINAMEVORVERSION#", fnamecompare
  ReplaceText freigtxtfile, officeType, oOfficeApp, "#DATEIDATUMVORVERSION#", fdatecompare
  ReplaceText freigtxtfile, officeType, oOfficeApp, "#VERANTWORTLICHERAUTOR#", CStr(GetValueFromField(dateiRS, "VerantwortlicherAutor", "?"))
  ReplaceText freigtxtfile, officeType, oOfficeApp, "#FACHLICHVERANTWORTLICHER#", CStr(GetValueFromField(dateiRS, "FachlichVerantwortlicher", "?"))
  ReplaceText freigtxtfile, officeType, oOfficeApp, "#TV#", CStr(GetValueFromField(dateiRS, "VerantwortlicherAutor", "?"))
  ReplaceText freigtxtfile, officeType, oOfficeApp, "#FV#", CStr(GetValueFromField(dateiRS, "FachlichVerantwortlicher", "?"))
  
  ReplaceText freigtxtfile, officeType, oOfficeApp, "#AKTDATUM#", CStr(DateSerial(year(Now), month(Now), day(Now)))
  ReplaceText freigtxtfile, officeType, oOfficeApp, "#VERSION#", CStr(GetValueFromField(dateiRS, "Version", "?"))
  ReplaceText freigtxtfile, officeType, oOfficeApp, "#MAJORVERSION#", CStr(GetValueFromField(dateiRS, "MajorVersion", "?"))
  ReplaceText freigtxtfile, officeType, oOfficeApp, "#MINORVERSION#", CStr(GetValueFromField(dateiRS, "MinorVersion", "?"))
  ReplaceText freigtxtfile, officeType, oOfficeApp, "#LASTSAVE#", GetValueFromField(dateiRS, "Speicherdatum", "?")
  ReplaceText freigtxtfile, officeType, oOfficeApp, "#ID#", GetValueFromField(dateiRS, "idvDateiID", "?")
  ReplaceText freigtxtfile, officeType, oOfficeApp, "#FULLPATH#", curdoc.fullname ' dateiRs.Fields("Dateiname").Value

  ReplaceText freigtxtfile, officeType, oOfficeApp, "#SCHUTZBEDARF#", GetSchutzbedarfText(dateiRS.Fields("Schutzbedarf"), "Schutzbedarf")
  ReplaceText freigtxtfile, officeType, oOfficeApp, "#VERFUEGBARKEIT#", GetSchutzbedarfText(dateiRS.Fields("Verfuegbarkeit"), "Verfuegbarkeit")
  ReplaceText freigtxtfile, officeType, oOfficeApp, "#INTEGRITAET#", GetSchutzbedarfText(dateiRS.Fields("Integritaet"), "Integritaet")
  ReplaceText freigtxtfile, officeType, oOfficeApp, "#VERTRAULICHKEIT#", GetSchutzbedarfText(dateiRS.Fields("Vertraulichkeit"), "Vertraulichkeit")
  If G_cfgAuthentizitaetAnzeigen Then
    ReplaceText freigtxtfile, officeType, oOfficeApp, "#AUTHENTIZITAET#", GetSchutzbedarfText(dateiRS.Fields("Authentizitaet"), "Authentizitaet")
  Else
    ReplaceText freigtxtfile, officeType, oOfficeApp, "#AUTHENTIZITAET#", ""
  End If
  ReplaceText freigtxtfile, officeType, oOfficeApp, "#FREMDENTWICKLUNG#", IIf(GetValueFromField(dateiRS, "FREMDENTWICKLUNG", 0) <> 0, FMT0("FREIGABEF_2"), FMT0("FREIGABEF_3"))
  ReplaceText freigtxtfile, officeType, oOfficeApp, "#INFORMATIONSKLASSIFIZIERUNG#", GetInfklasseText(dateiRS.Fields("Informationsklassifizierung"), "Informationsklassifizierung")
  'ReplaceText freigtxtfile, officeType, oOfficeApp, "#GOBD#", IIf(GetValueFromField(dateiRS, "GOBD", 0) = 1, "Ja", "Nein")
  ReplaceText freigtxtfile, officeType, oOfficeApp, "#GOBD#", IIf(GetValueFromField(dateiRS, "GOBD", 0) <> 0, FMT0("FREIGABEF_2"), FMT0("FREIGABEF_3"))
  'ReplaceText freigtxtfile, officeType, oOfficeApp, "#BANKFACHLICH#", IIf(GetValueFromField(dateiRS, "Bankfachlich", 0) = 1, "Ja", "Nein")
  ReplaceText freigtxtfile, officeType, oOfficeApp, "#BANKFACHLICH#", IIf(GetValueFromField(dateiRS, "Bankfachlich", 0) <> 0, FMT0("FREIGABEF_2"), FMT0("FREIGABEF_3"))
  ReplaceText freigtxtfile, officeType, oOfficeApp, "#INDIV1#", GetValueFromField(dateiRS, "Indiv1", "-/-")
  ReplaceText freigtxtfile, officeType, oOfficeApp, "#INDIV2#", GetValueFromField(dateiRS, "Indiv2", "-/-")

  ReplaceText freigtxtfile, officeType, oOfficeApp, "#SCHUTZBEDARFPROZESSE#", GetSchutzbedarfTextFromLong(GetSafeFieldPlus(dateiRS, "SchutzbedarfProzesse", 0), "Schutzbedarf")
  ReplaceText freigtxtfile, officeType, oOfficeApp, "#VERFUEGBARKEITPROZESSE#", GetSchutzbedarfTextFromLong(GetSafeFieldPlus(dateiRS, "VerfuegbarkeitProzesse", 0), "Verfuegbarkeit")
  ReplaceText freigtxtfile, officeType, oOfficeApp, "#INTEGRITAETPROZESSE#", GetSchutzbedarfTextFromLong(GetSafeFieldPlus(dateiRS, "IntegritaetProzesse", 0), "Integritaet")
  ReplaceText freigtxtfile, officeType, oOfficeApp, "#VERTRAULICHKEITPROZESSE#", GetSchutzbedarfTextFromLong(GetSafeFieldPlus(dateiRS, "VertraulichkeitProzesse", 0), "Vertraulichkeit")
  ReplaceText freigtxtfile, officeType, oOfficeApp, "#INFORMATIONSKLASSIFIZIERUNGPROZESSE#", GetInfklasseTextFromLong(GetSafeFieldPlus(dateiRS, "InformationsklassifizierungPr", 0), "Informationsklassifizierung")
  ReplaceText freigtxtfile, officeType, oOfficeApp, "#AUTHENTIZITAETPROZESSE#", GetSchutzbedarfTextFromLong(GetSafeFieldPlus(dateiRS, "AuthentizitaetProzesse", 0), "Authentizitaet")

#If Project_ExcelTracker = 1 Then
  ReplaceText freigtxtfile, officeType, oOfficeApp, "#LINKSOURCES#", GetExternalReferences(curdoc)
#End If

  Dim userID As String
  Dim userExt As String
  userID = GetValueFromField(dateiRS, "SpeichernderUserLogonID", "N/A")
  If userID <> "N/A" Then
    userExt = GetUserFullNameAndMail(conn, userID)
    If userExt <> "" Then
      userID = userID & " (" & userExt & ")"
    End If
  End If
  ReplaceText freigtxtfile, officeType, oOfficeApp, "#SAVINGUSER#", userID
  
  If initiierenderUser <> "" Then
    userID = initiierenderUser
  Else
    userID = GetValueFromField(dateiRS, "FreigabeInitUserLogonID", "N/A")
  End If
  If userID <> "N/A" Then
    userExt = GetUserFullNameAndMail(conn, userID)
    If userExt <> "" Then
      userID = userID & " (" & userExt & ")"
    End If
  End If
  ReplaceText freigtxtfile, officeType, oOfficeApp, "#INITIIERENDERUSER#", userID
  
  If freigenderUser <> "" Then
    userID = freigenderUser
  Else
    userID = "N/A"
  End If
  If userID <> "N/A" Then
    userExt = GetUserFullNameAndMail(conn, userID)
    If userExt <> "" Then
      userID = userID & " (" & userExt & ")"
    End If
  End If
  ReplaceText freigtxtfile, officeType, oOfficeApp, "#FREIGEBENDERUSER#", userID
  
  ReplaceText freigtxtfile, officeType, oOfficeApp, "#TABLEAMOUNT#", GetValueFromField(dateiRS, "Tabellenanzahl", "?")
  ' ReplaceText freigtxtfile, officeType, oOfficeApp, "#PROTECTEDSHEETS#", GetValueFromField(dateiRs, "TblaetterMitBlattschutz", "?")
  ' ReplaceText freigtxtfile, officeType, oOfficeApp, "#UNPROTECTEDSHEETSWITHFORMULAS#", GetValueFromField(dateiRs, "TblaetterOhnBlattschutzMitFrml", "?")
  ' ReplaceText freigtxtfile, officeType, oOfficeApp, "#UNPROTECTEDFORMULAS#", GetValueFromField(dateiRs, "Anzahlnichtabgesicherteformeln", "?")
  ' ReplaceText freigtxtfile, officeType, oOfficeApp, "#EXTERNALREFERENCES#", GetValueFromField(dateiRs, "Anzahlexternereferenzen", "?")
  ReplaceText freigtxtfile, officeType, oOfficeApp, "#NEEDEDHOURSFORDOCUMENTATION#", IIf(Not IsNull(dateiRS.Fields("ZeitaufwandFuerDokuInStunden").value), dateiRS.Fields("ZeitaufwandFuerDokuInStunden").value, 0)
  
  If dateiRS.Fields("Risikowert").value <> -1 Then
    ReplaceText freigtxtfile, officeType, oOfficeApp, "#RISKVALUE#", Format(dateiRS.Fields("Risikowert").value * 100, "#") & "%"
  Else
    'ReplaceText freigtxtfile, officeType, oOfficeApp, "#RISKVALUE#", "Nicht bewertet"
    ReplaceText freigtxtfile, officeType, oOfficeApp, "#RISKVALUE#", FMT0("FREIGABEF_1")
  End If
  
  Dim riskrs As Object
  Set riskrs = CreateObject("ADODB.Recordset")
  Dim Risikoklasse As String
  Risikoklasse = "-/-"
  If Not IsNull(dateiRS.Fields("RisikoklasseIDBeiEinwertung").value) Then
      riskrs.Open "SELECT Risikoklassenkennzeichen, u.LokalisierterText as LocKennzeichen FROM gRisikoklasseHistorie left join gTexteUebersetzungen u on (u.TextID = gRisikoklasseHistorie.TextID and u.LanguageID = " & GetMyDBLanguage(conn) & ") where RisikoklasseID = " & dateiRS.Fields("RisikoklasseIDBeiEinwertung").value, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
      If Not riskrs.EOF Then
          Risikoklasse = GetLocValueFromField(riskrs, "Risikoklassenkennzeichen", "LocKennzeichen", "")
      End If
      riskrs.Close
  End If
  
  ReplaceText freigtxtfile, officeType, oOfficeApp, "#RISKCLASS#", Risikoklasse

  If Not IsNull(dateiRS.Fields("LetzterScan").value) Then
      ReplaceText freigtxtfile, officeType, oOfficeApp, "#LASTSCAN#", dateiRS.Fields("LetzterScan").value
  Else
      ReplaceText freigtxtfile, officeType, oOfficeApp, "#LASTSCAN#", "-/-"
  End If

  If IsNull(dateiRS.Fields("LetzterScan").value) = False And IsNull(dateiRS.Fields("EccFormelnIndividuell").value) = False Then
      ReplaceText freigtxtfile, officeType, oOfficeApp, "#INDIVIDUALFORMULAAMOUNT#", dateiRS.Fields("EccFormelnIndividuell").value
  Else
      ReplaceText freigtxtfile, officeType, oOfficeApp, "#INDIVIDUALFORMULAAMOUNT#", "-/-"
  End If
  
  If IsNull(dateiRS.Fields("LetzterScan").value) = False And IsNull(dateiRS.Fields("ECCFormelnGesamt").value) = False Then
      ReplaceText freigtxtfile, officeType, oOfficeApp, "#FORMULAAMOUNT#", dateiRS.Fields("ECCFormelnGesamt").value
  Else
      ReplaceText freigtxtfile, officeType, oOfficeApp, "#FORMULAAMOUNT#", "-/-"
  End If
  
  Dim dokuID As Long
  dokuID = -1
  Dim drs As Object
  Set drs = CreateObject("ADODB.Recordset")

  Dim selitem As Long
  Dim oeitem As Long
  oeitem = -1

  ' ---------------------------------------------------------------------
  ' Erst mal aus der Dateiendoku die relevanten Felder holen und anzeigen
  ' ---------------------------------------------------------------------


  Dim refrs As Object

  ' If GetValueFromField(dateiRS, "FreigabeStatus", 0) > 0 Then
  If IstDateiFreigabeStatusInitiiertOderFreigegeben(dateiRS) = True Then
      
      ' Hier kann es sein, dass FreigabeidvDateiID noch nicht gesetzt ist! Dann einfach nur mit ID holen!
      If GetValueFromField(dateiRS, "FreigabeidvDateiID", 0) > 0 Then
        drs.Open "SELECT * FROM idvDateienDoku WHERE idvDateiID=" & GetValueFromField(dateiRS, "FreigabeidvDateiID", 0) & " AND Version=" & GetValueFromField(dateiRS, "FreigabeVersion", 0), conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
      Else
        drs.Open "SELECT * FROM idvDateienDoku WHERE idvDateiID=" & locDateiID & " AND Version=" & locVersion, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
      End If
  Else
      drs.Open "SELECT * FROM idvDateienDoku WHERE idvDateiID=" & locDateiID & " AND Version=" & locVersion, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
  End If

  
  ' Wenn es hier was gibt dann holen wir die doku und den Einsatz sowie die ID
  If Not drs.EOF Then
      locVersion = drs.Fields("Version").value
      dokuID = drs.Fields("idvDateiDokuID").value
      selitem = drs.Fields("EinsatzID").value
      If Not IsNull(drs.Fields("VerantwortlicheOEID").value) Then
        oeitem = drs.Fields("VerantwortlicheOEID").value
      End If
      ReplaceText freigtxtfile, officeType, oOfficeApp, "#OWNER#", UCase(GetValueFromField(drs, "VerantwortlicherAutor", "?"))
      ReplaceText freigtxtfile, officeType, oOfficeApp, "#TV#", UCase(GetValueFromField(drs, "VerantwortlicherAutor", "?"))
      ReplaceText freigtxtfile, officeType, oOfficeApp, "#FV#", UCase(GetValueFromField(drs, "FachlichVerantwortlicher", "?"))
      drs.Close
  
  ' Haben wir nix, dann holen wir, falls m|fffd|glich, die Vorg|fffd|ngerversion
  ElseIf drs.EOF And G_Version > 1 Then
      
      drs.Close
'        locVersion = locVersion - 1
'        drs.Open "SELECT * FROM idvDateienDoku WHERE idvDateiID=" & locDateiID & " AND Version=" & locVersion, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
      drs.Open "SELECT * FROM idvDateienDoku WHERE idvDateiID=" & locDateiID & " ORDER BY Version DESC", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
      If Not drs.EOF Then
          locVersion = drs.Fields("Version").value
          dokuID = drs.Fields("idvDateiDokuID").value
          selitem = drs.Fields("EinsatzID").value
          If Not IsNull(drs.Fields("VerantwortlicheOEID").value) Then
            oeitem = drs.Fields("VerantwortlicheOEID").value
          End If
          ReplaceText freigtxtfile, officeType, oOfficeApp, "#OWNER#", UCase(GetValueFromField(drs, "VerantwortlicherAutor", "?"))
          ReplaceText freigtxtfile, officeType, oOfficeApp, "#TV#", UCase(GetValueFromField(drs, "VerantwortlicherAutor", "?"))
          ReplaceText freigtxtfile, officeType, oOfficeApp, "#FV#", UCase(GetValueFromField(drs, "FachlichVerantwortlicher", "?"))
          drs.Close
      Else
      
          ' Wenn es von der Vorg|fffd|ngerversion keine Doku gibt wird versucht die Doku von der Referenz zu holen
          drs.Close
          
          If dateiRS.Fields("ReferenzidvDateiID").value > 0 Then
              ' If MsgBox("Zu dieser Datei liegt keine Dokumentation vor. Soll die Doku des Originals (soweit vorhanden) geladen werden?", vbYesNo + vbQuestion + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")") = vbYes Then

                  Set refrs = CreateObject("ADODB.Recordset")
                  refrs.Open "SELECT * FROM idvDateien WHERE idvDateiID=" & dateiRS.Fields("ReferenzidvDateiID").value, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
                  If refrs.EOF = False Then
'                      locVersion = refrs.Fields("Version").Value
                    locDateiID = refrs.Fields("idvDateiID").value
                    
                    ' niemals eine h|fffd|here Version holen, als die, die zum Zeitpunkt der Kopie existiert hat
                    Dim referenzVersion As Long
                    referenzVersion = GetValueFromField(dateiRS, "ReferenzVersion", -1)
                    
                    ' wenn ReferenzVersion nicht eingetragen (referenzVersion = -1),
                    ' dann nehmen wir die h|fffd|chste vorhandene Version, in dem wir nicht auf Version testen
                    drs.Open "SELECT * FROM idvDateienDoku WHERE idvDateiID=" & locDateiID & IIf(referenzVersion > 0, " and Version <=" & referenzVersion, "") & " ORDER BY Version DESC", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
                    If Not drs.EOF Then
                        locVersion = drs.Fields("Version").value
                        dokuID = drs.Fields("idvDateiDokuID").value
                        selitem = drs.Fields("EinsatzID").value
                        If Not IsNull(drs.Fields("VerantwortlicheOEID").value) Then
                          oeitem = drs.Fields("VerantwortlicheOEID").value
                        End If
                        ReplaceText freigtxtfile, officeType, oOfficeApp, "#OWNER#", UCase(GetValueFromField(drs, "VerantwortlicherAutor", "?"))
                        ReplaceText freigtxtfile, officeType, oOfficeApp, "#TV#", UCase(GetValueFromField(drs, "VerantwortlicherAutor", "?"))
                        ReplaceText freigtxtfile, officeType, oOfficeApp, "#FV#", UCase(GetValueFromField(drs, "FachlichVerantwortlicher", "?"))
                    End If
                    drs.Close
                  End If
                  refrs.Close
                  Set refrs = Nothing

              'End If
          End If
      End If
  Else
      drs.Close
      ' Das ist version 1, also wird die refrenz gesucht
      If dateiRS.Fields("ReferenzidvDateiID").value > 0 Then
          Set refrs = CreateObject("ADODB.Recordset")
          refrs.Open "SELECT * FROM idvDateien WHERE idvDateiID=" & dateiRS.Fields("ReferenzidvDateiID").value, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
          If Not refrs.EOF Then
'              locVersion = refrs.Fields("Version").Value
            locDateiID = refrs.Fields("idvDateiID").value
                    
            ' niemals eine h|fffd|here Version holen, als die, die zum Zeitpunkt der Kopie existiert hat
            referenzVersion = GetValueFromField(dateiRS, "ReferenzVersion", -1)
                    
            ' wenn ReferenzVersion nicht eingetragen (referenzVersion = -1),
            ' dann nehmen wir die h|fffd|chste vorhandene Version, in dem wir nicht auf Version testen
'              drs.Open "SELECT * FROM idvDateienDoku WHERE idvDateiID=" & locDateiID & " AND Version=" & locVersion, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
            drs.Open "SELECT * FROM idvDateienDoku WHERE idvDateiID=" & locDateiID & IIf(referenzVersion > 0, " and Version <= " & referenzVersion, "") & " ORDER BY Version DESC", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
            If Not drs.EOF Then
                locVersion = drs.Fields("Version").value
                dokuID = drs.Fields("idvDateiDokuID").value
                selitem = drs.Fields("EinsatzID").value
                If Not IsNull(drs.Fields("VerantwortlicheOEID").value) Then
                  oeitem = drs.Fields("VerantwortlicheOEID").value
                End If
                ReplaceText freigtxtfile, officeType, oOfficeApp, "#OWNER#", UCase(GetValueFromField(drs, "VerantwortlicherAutor", "?"))
                ReplaceText freigtxtfile, officeType, oOfficeApp, "#TV#", UCase(GetValueFromField(drs, "VerantwortlicherAutor", "?"))
                ReplaceText freigtxtfile, officeType, oOfficeApp, "#FV#", UCase(GetValueFromField(drs, "FachlichVerantwortlicher", "?"))
            End If
            drs.Close
          End If
          refrs.Close
          Set refrs = Nothing
      End If
  End If

  ' Falls hier noch nix ersetzt wurde kommt jetzt der Current User rein
  ReplaceText freigtxtfile, officeType, oOfficeApp, "#OWNER#", UCase(GetUserName)

  ' ---------------------------------------------------------------------
  ' Die Einsatzarten holen
  ' ---------------------------------------------------------------------
  drs.Open "SELECT * FROM gEinsatz", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
  
  Dim einsatzbereich As String
  einsatzbereich = "-/-"
  If Not drs.EOF Then
      If Not GetValueFromField(drs, "Inaktiv", False) <> False Then
          Do While Not drs.EOF
              If selitem = val(drs.Fields("EinsatzID").value) Then
                'einsatzbereich = drs.Fields("Einsatztext").value
                einsatzbereich = FMT0("Einsatz_" & drs.Fields("EinsatzID").value) ' FMT0(drs.Fields("Einsatztext").value)
              End If
              drs.MoveNext
          Loop
      End If
  End If
  drs.Close
  ReplaceText freigtxtfile, officeType, oOfficeApp, "#AREA#", einsatzbereich

  Dim owneroe As String
  owneroe = "-/-"
  If G_PARAM_VerantwortlicheOE Then
          
' XXX FORMATIERUNG
            If oeitem > 0 Then
                Dim tOErs As Object
            
                Set tOErs = OpenRS("SELECT * FROM gOE WHERE OEID = " & oeitem, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
                If Not tOErs Is Nothing Then
                  If Not tOErs.EOF Then
                      owneroe = GetValueFromField(tOErs, "OEKennzeichen", "???") & " - " & GetValueFromField(tOErs, "OEBeschreibung", "???")
                  End If
                  tOErs.Close
                  Set tOErs = Nothing
                End If
            End If

  End If
  ReplaceText freigtxtfile, officeType, oOfficeApp, "#OWNEROU#", owneroe
  
  Dim duptextcnt As Long
  Dim duptextmlcnt As Long
  Dim duplabelcnt As Long



  ' ---------------------------------------------------------------------
  ' Und jetzt existente Dokufelder holen, erzeugen und anzeigen
  ' ---------------------------------------------------------------------
  Dim rs As Object
  Set rs = CreateObject("ADODB.Recordset")
  rs.Open "SELECT gDokufelder.*, ur.LokalisierterText as LocSeitentitel, ud.LokalisierterText as LocDokuname " & _
  " from (((gDokufelder inner join gDokufelderReiter r on gDokufelder.ReiterID = r.DokufeldReiterID) " & _
  " left join gTexteUebersetzungen ur on (r.DokufeldReiterTextID = ur.TextID and ur.LanguageID = " & GetMyDBLanguage(conn) & ")) " & _
  " left join gTexteUebersetzungen ud on (gDokufelder.DokunameTextID = ud.TextID and ud.LanguageID = " & GetMyDBLanguage(conn) & ")) " & _
  " where gDokufelder.DokufeldTypID <> 8 " & _
  " ORDER BY r.TabOrder", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly

  Dim alltxt As String
  alltxt = "-/-"
  
  Dim allfilledtxt As String
  allfilledtxt = "-/-"
  
  Dim colScriptValues As Collection
  Set colScriptValues = New Collection
  Dim colScriptValuesWithKey As Collection
  Set colScriptValuesWithKey = New Collection
  If Not PrepareScriptVars(dateiRS, colScriptValues, colScriptValuesWithKey) Then
    Set colScriptValues = Nothing
    Set colScriptValuesWithKey = Nothing
    Exit Function
  End If
  
  If IsNull(dateiRS.Fields("SBSAssetID").value) = False Then
    PrepareScriptVarsSBSWithConnection conn, dateiRS.Fields("SBSASSETID").value, "", colScriptValues, colScriptValuesWithKey
  End If
  
  ' Als erstes wird versucht alle SBS-Werte zu setzen:
  Dim css As CStringTouple
  For Each css In colScriptValuesWithKey
    ' Debug.Print css.m_Name & "=" & css.m_Text
    If css.m_Name = "SBS_FAV OE NAME" Then
      Debug.Print css.m_Name & "=" & css.m_Text
    End If
    ReplaceText freigtxtfile, officeType, oOfficeApp, "#" & css.m_Name & "#", css.m_Text
  Next css
  
  If Not rs.EOF Then
        Dim objScript As Object
        Dim cso As Object
        Set cso = New CScriptObject
        Set objScript = cso.GetObject
        ' objScript.Language = "VBScript"
        ' objScript.AllowUI = False
        
        Do While Not rs.EOF
            
            If rs.Fields("Deaktiviert").value = False Then
                Dim valid As Boolean
                Dim Risikowert As Double
                Dim von As Double
                Dim bis As Double
                Dim script As String
                Dim mussfeld As Boolean
                Risikowert = GetSafeFieldPlus(dateiRS, "Risikowert", 0#)
                von = GetSafeFieldPlus(rs, "RisikowertVon", 0#)
                bis = GetSafeFieldPlus(rs, "RisikowertBis", 0#)
                valid = von <= Risikowert And Risikowert <= bis
                ' Checken, ob es hier ein script gibt
                script = GetSafeField(rs, "Script")
                If script <> "" Then
                    valid = DokufeldAnzeigenFromScript(objScript, rs.Fields("Dokuname").value, Nothing, GetValueFromField(rs, "DokuFeldtypID", 3), False, script, dateiRS, mussfeld, colScriptValues)
                End If
                If valid Then
      
                  Dim dokutext As String
                  dokutext = "-/-"
                  
'                  If rs.Fields("Dokuname").value = "Veraenderungen_zur_Vorversion" Then
'                    Debug.Print "Gaga"
'                  End If
                  
      
                  Select Case GetValueFromField(rs, "DokuFeldtypID", 3)
                      Case 1
                          drs.Open "SELECT * FROM idvDateienDokuTextfelder WHERE idvDateiDokuID=" & dokuID & " AND Version=" & locVersion & " AND Feldnummer=" & rs.Fields("Feldnummer").value & " AND DokuFeldTypID=" & rs.Fields("DokuFeldtypID").value, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockOptimistic
                          If Not drs.EOF Then
                             dokutext = GetValueFromField(drs, "Text", "")
                          End If
                          drs.Close
                      
                      Case 2
                          drs.Open "SELECT * FROM idvDateienDokuTextfelder WHERE idvDateiDokuID=" & dokuID & " AND Version=" & locVersion & " AND Feldnummer=" & rs.Fields("Feldnummer").value & " AND DokuFeldTypID=" & rs.Fields("DokuFeldtypID").value, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockOptimistic
                          If Not drs.EOF Then
                             dokutext = GetValueFromField(drs, "Text", "")
                          End If
                          drs.Close
                      Case 3
                          drs.Open "SELECT * FROM idvDateienDokuTextfelder WHERE idvDateiDokuID=" & dokuID & " AND Version=" & locVersion & " AND Feldnummer=" & rs.Fields("Feldnummer").value & " AND DokuFeldTypID=" & rs.Fields("DokuFeldtypID").value, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockOptimistic
                          If Not drs.EOF Then
                              dokutext = GetValueFromField(drs, "Text", "")
                          End If
                          drs.Close
                       Case 4
                        ' ListBox
                          drs.Open "SELECT * FROM idvDateienDokuTextfelder WHERE idvDateiDokuID=" & dokuID & " AND Version=" & locVersion & " AND Feldnummer=" & rs.Fields("Feldnummer").value & " AND DokuFeldTypID=" & rs.Fields("DokuFeldtypID").value, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockOptimistic
                          If Not drs.EOF Then
                              dokutext = GetValueFromField(drs, "Text", "")
                          End If
                          drs.Close
                          dokutext = GetWerteFuerDokufeld(conn, rs.Fields("Feldnummer").value, dokutext)
                        Case 5
                          ' ComboBox
                          drs.Open "SELECT * FROM idvDateienDokuTextfelder WHERE idvDateiDokuID=" & dokuID & " AND Version=" & locVersion & " AND Feldnummer=" & rs.Fields("Feldnummer").value & " AND DokuFeldTypID=" & rs.Fields("DokuFeldtypID").value, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockOptimistic
                          If Not drs.EOF Then
                              dokutext = GetValueFromField(drs, "Text", "")
                          End If
                          drs.Close
                          dokutext = GetWerteFuerDokufeld(conn, rs.Fields("Feldnummer").value, dokutext)
                        Case 6
                        ' Checkbox
                          drs.Open "SELECT * FROM idvDateienDokuTextfelder WHERE idvDateiDokuID=" & dokuID & " AND Version=" & locVersion & " AND Feldnummer=" & rs.Fields("Feldnummer").value & " AND DokuFeldTypID=" & rs.Fields("DokuFeldtypID").value, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockOptimistic
                          If Not drs.EOF Then
                              dokutext = GetValueFromField(drs, "Text", "")
                              If dokutext <> "0" Then
                                'dokutext = "Ja"
                                dokutext = FMT0("FREIGABEF_2")
                              Else
                                'dokutext = "Nein"
                                dokutext = FMT0("FREIGABEF_3")
                              End If
                          End If
                          drs.Close
                        Case 7
                          ' Link
                          drs.Open "SELECT * FROM idvDateienDokuTextfelder WHERE idvDateiDokuID=" & dokuID & " AND Version=" & locVersion & " AND Feldnummer=" & rs.Fields("Feldnummer").value & " AND DokuFeldTypID=" & rs.Fields("DokuFeldtypID").value, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockOptimistic
                          If Not drs.EOF Then
                              dokutext = GetValueFromField(drs, "Text", "")
                          End If
                          drs.Close
                  
                  
                  End Select
      
                  If alltxt <> "-/-" Then
                    alltxt = alltxt & vbCrLf & vbCrLf & GetLocValueFromField(rs, "Dokuname", "LocDokuname", FMT0("FREIGABEF_5") & duplabelcnt) & ": " & dokutext
                  Else
                    alltxt = GetLocValueFromField(rs, "Dokuname", "LocDokuname", FMT0("FREIGABEF_5") & duplabelcnt) & ": " & dokutext
                  End If
                  
                  If dokutext <> "-/-" Then
                    If allfilledtxt <> "-/-" Then
                      allfilledtxt = allfilledtxt & vbCrLf & vbCrLf & GetLocValueFromField(rs, "Dokuname", "LocDokuname", FMT0("FREIGABEF_5") & duplabelcnt) & ": " & dokutext
                    Else
                      allfilledtxt = GetLocValueFromField(rs, "Dokuname", "LocDokuname", FMT0("FREIGABEF_5") & duplabelcnt) & ": " & dokutext
                    End If
                  End If
                  
                  Dim standard As String
                  standard = FMT0("FREIGABEF_4")
                  ReplaceText freigtxtfile, officeType, oOfficeApp, "#" & GetLocValueFromField(rs, "Dokuname", "LocDokuname", standard) & ".TEXT#", dokutext
                  ' Debug.Print "#" & GetLocValueFromField(rs, "Dokuname", "LocDokuname", standard) & ".TEXT#=" & dokutext
      
              End If
            End If
            
            rs.MoveNext
        Loop
        
        Set objScript = Nothing
        Set cso = Nothing
        
        ReplaceText freigtxtfile, officeType, oOfficeApp, "#ALLDOKUFIELDS#", alltxt
        ReplaceText freigtxtfile, officeType, oOfficeApp, "#ALLFILLEDDOKUFIELDS#", allfilledtxt
  End If
  rs.Close

  Dim addFiles As String
  addFiles = ""
  Set rs = CreateObject("ADODB.Recordset")
  rs.Open "SELECT xlBinTracker.Dateiname from xlBinTracker inner join xlBinTrackerRef on xlBinTracker.xlBinTrackerID = xlBinTrackerRef.xlBinTrackerID where xlBinTrackerRef.DokuID = " & dokuID, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
  If Not rs.EOF Then
     Do While Not rs.EOF
        addFiles = addFiles & GetValueFromField(rs, "Dateiname", "") & vbCrLf
        rs.MoveNext
     Loop
  End If
  rs.Close
  ReplaceText freigtxtfile, officeType, oOfficeApp, "#ADDITIONALFILES#", addFiles
  
  Dim paramrs As Object
  Set paramrs = GetParamRS(conn)   ' CreateObject("ADODB.Recordset")
  'paramrs.Open "SELECT * FROM gParameter", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly


  If dateiRS.Fields("Risikowert").value >= GetValueFromField(paramrs, "OEAuswahlInDokuAbRisikowert", 1) And GetValueFromField(paramrs, "OEAuswahlInDokuAbRisikowert", 0) >= 0 Then
      ReplaceText freigtxtfile, officeType, oOfficeApp, "#IN#", GetInOutString("I", dokuID, conn)
      ReplaceText freigtxtfile, officeType, oOfficeApp, "#OUT#", GetInOutString("O", dokuID, conn)
  Else
      ReplaceText freigtxtfile, officeType, oOfficeApp, "#IN#", "-/-"
      ReplaceText freigtxtfile, officeType, oOfficeApp, "#OUT#", "-/-"
  End If
  
  If Not IsNull(paramrs.Fields("EinsatzbereicheInDokuAbRisiko").value) Then
    If dateiRS.Fields("Risikowert").value >= paramrs.Fields("EinsatzbereicheInDokuAbRisiko").value And paramrs.Fields("EinsatzbereicheInDokuAbRisiko").value >= 0 Then
        ReplaceText freigtxtfile, officeType, oOfficeApp, "#AREA#", GetInOutEBString("I", dokuID, conn)
    End If
  End If
  
  
  
  paramrs.Close
  Set paramrs = Nothing


  ' Wollen wir doch mal schauen, ob ich eine Kopie bin
  Dim copyof As String
  copyof = "-/-"
  If dateiRS.Fields("ReferenzidvDateiID").value Then
      rs.Open "SELECT * FROM idvDateien WHERE idvDateiID=" & dateiRS.Fields("ReferenzidvDateiID").value, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
      If Not rs.EOF Then
          copyof = rs.Fields("Dateiname").value
      End If
      rs.Close
  End If
  ReplaceText freigtxtfile, officeType, oOfficeApp, "#COPYOF#", copyof

  ' Antworten noch zur Verf|fffd|gung stellen
  Dim qunds As String
  If GetDateiFragenUndAntworten(dateiRS, conn, qunds) Then
    ReplaceText freigtxtfile, officeType, oOfficeApp, "#QUESTIONSANDANSWERS#", qunds
  Else
    ReplaceText freigtxtfile, officeType, oOfficeApp, "#QUESTIONSANDANSWERS#", " "
  End If
  
  ' Alle verbliebenen Antworten noch aus dem Formular entfernen!
  rs.Open "SELECT nr FROM gFragen", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
  Do While Not rs.EOF
    ReplaceText freigtxtfile, officeType, oOfficeApp, "#ANSWER." & rs.Fields("Nr").value & "#", "-/-"
    rs.MoveNext
  Loop
  rs.Close
  
  Set rs = Nothing
  If storeFileType > 0 Then
  
    Dim newExtension As String
    Select Case UCase(GetFileExtension(formularfile))
      Case "XLTX"
        newExtension = "XLSX"
      Case "XLT"
        newExtension = "XLS"
      Case "XLSX"
        newExtension = "XLSX"
      Case "XLS"
        newExtension = "XLS"
      Case "DOC"
        newExtension = "DOC"
      Case "DOT"
        newExtension = "DOC"
      Case "DOCX"
        newExtension = "DOCX"
      Case "DOTX"
        newExtension = "DOCX"
      Case "TXT"
        newExtension = "TXT"
      Case Else
        newExtension = ""
    End Select
    
    Dim tFname As String
    If newExtension <> "" Then
      If storeFileType = 1 Then
        If formularstorepath <> "" Then
          If PathExists(formularstorepath) Then
            ' In Zielordner
              'tFname = formularstorepath & "\" & Format(Now, "yyyy-mm-dd-hh-mm-ss") & "-ETFreigabeformular ID " & dateiRS.Fields("idvDateiID").value & " " & GetUserName & ".doc"
              tFname = formularstorepath & "\" & ReplaceFileTags(dateiRS, FMT0("FREIGABEFORMDATEINAME")) & "." & newExtension
          End If
        End If
      ElseIf storeFileType = 2 Then
        tFname = GetTempPath & ReplaceFileTags(dateiRS, FMT0("FREIGABEFORMDATEINAME")) & "." & newExtension
      ElseIf storeFileType = 3 Then
        tFname = GetTempPath & "Tmp" & dateiRS.Fields("idvDateiID").value & "-" & GetUserName & "." & newExtension
      End If
    End If
      
      
    If tFname <> "" Then
      If FileExists(tFname) Then
        MyKill tFname
      End If
      If FileExists(tFname) Then
         'MsgBox "Achtung, das Freigabeformular konnte nicht unter '" & tFname & "' gespeichert werden. Bitte speichern Sie das Formular selbst und senden es den relevanten Stellen im Haus zu.", vbCritical, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
         MsgBox FMT1("FREIGABEF_6", tFname), vbCritical, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
      Else
        If officeType = 2 Then
          oOfficeApp.ActiveWorkbook.SaveAs tFname
          If closeResultForm Then
            oOfficeApp.ActiveWorkbook.Close False
          End If
        ElseIf officeType = 1 Then
          oOfficeApp.activedocument.SaveAs tFname
        ElseIf officeType = 3 Then
          StoreFile tFname, freigtxtfile, errstr
        End If
        fNameFreigabeformular = tFname
      End If
    End If
    CreateFreigabeformular = True
  Else
    CreateFreigabeformular = False
  End If
  

  Set colScriptValues = Nothing

  Exit Function

nogo:
  DebugPrint tERROR, "Interner Fehler in CreateFreigabeformular - " & err.Number & " - " & err.Description

End Function


' officeType: 1 = Word, 2 = Excel, 3 = nur Text
Private Sub ReplaceText(ByRef txt As String, ByVal officeType As Long, ByRef oOfficeApp As Object, ByVal tag As String, ByVal reptag As String)
  On Error GoTo nogo:
  If officeType = 1 Then
    While FindWordText(oOfficeApp, tag)
      oOfficeApp.Selection.TypeText Text:=IIf(reptag = "", " ", reptag)
    Wend
  ElseIf officeType = 2 Then
    oOfficeApp.DisplayAlerts = False
'    oOfficeApp.Cells.Replace What:=tag, Replacement:=IIf(reptag = "", " ", reptag), LookAt:=xlPart, SearchOrder:=xlByRows, MatchCase:=False, SearchFormat:=False, ReplaceFormat:=False
    Dim x As Long
    Dim y As Long
    Dim sht As String
    Dim cnt As Long
    cnt = 0
    Do
      x = oOfficeApp.ActiveCell.column
      y = oOfficeApp.ActiveCell.Row
      sht = oOfficeApp.ActiveSheet.name
      If InStr(oOfficeApp.ActiveCell.value, tag) > 0 Then
        oOfficeApp.ActiveCell.value = IIf(reptag = "", " ", reptag)
      End If
      Dim rng As Range
      Set rng = oOfficeApp.Cells.Find(What:=tag, After:=oOfficeApp.ActiveCell, LookIn:=xlValues, LookAt:= _
          xlPart, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=False _
          , SearchFormat:=False)
      If rng Is Nothing Then Exit Do
      cnt = cnt + 1
      If cnt > 20 Then Exit Do
      rng.Activate
      If x = oOfficeApp.ActiveCell.column And y = oOfficeApp.ActiveCell.Row And sht = oOfficeApp.ActiveSheet.name Then Exit Do
    Loop
    oOfficeApp.DisplayAlerts = True
  ElseIf officeType = 3 Then
    txt = Replace(txt, tag, ConvertToOneLineString(reptag))
  End If
  Exit Sub
nogo:
Debug.Print "nogo"
  
End Sub

Function RemoveLeadingAndTrailing(ByVal s As String, ByVal removestr As String) As String
  If Left(s, 1) = removestr And Right(s, 1) = removestr Then
    RemoveLeadingAndTrailing = Mid(s, 2, Len(s) - 2)
  Else
    RemoveLeadingAndTrailing = s
  End If
End Function
Function ConvertToOneLineString(ByVal s As String) As String
  s = Replace(s, "\", "\\")
  s = Replace(s, vbCrLf, "\n")
  s = Replace(s, Chr(34), Chr(34) & Chr(34))
  ConvertToOneLineString = Chr(34) & s & Chr(34)
End Function

Function FindWordText(oWDApp As Object, sTxt As String) As Boolean
  'Immer vom Anfang des Dokuments!
'  oWDApp.Selection.HomeKey Unit:=wdStory
  
  ' einfach einen Schritt nach links, damit eventuelle Selektionen deselektiert werden.
  oWDApp.Selection.MoveLeft Unit:=1, count:=1
  
  FindWordText = True
  oWDApp.Selection.Find.ClearFormatting
  With oWDApp.Selection.Find
    .Text = sTxt
'    .Replacement.Text = "#Std#"
    .Forward = True
    .Wrap = 1
    .Format = False
    .MatchCase = False
    .MatchWholeWord = False
    .MatchWildcards = False
    .MatchSoundsLike = False
    .MatchAllWordForms = False
  End With
  oWDApp.Selection.Find.Execute
  If Len(oWDApp.Selection) <> Len(sTxt) Then
    FindWordText = False
  End If
  
End Function

Function GetProzText(ByRef prozrs As Object) As String
    
    ' Reihenfolge die der User definiert hat
    
    Dim res As String
    Dim i As Long
    For i = 0 To Len(G_CfgPAReihenfolgeDoku) - 1
        Select Case Mid(G_CfgPAReihenfolgeDoku, i + 1, 1)
        Case "A"
            res = res & IIf(res <> "", " / ", "") & GetSafeFieldPlus(prozrs, "Prozessschluessel", "")
        Case "B"
            res = res & IIf(res <> "", " / ", "") & GetSafeFieldPlus(prozrs, "Prozessname", "")
        Case "C"
            res = res & IIf(res <> "", " / ", "") & GetSafeFieldPlus(prozrs, "Prozesslandkarte", "")
        Case "D"
            res = res & IIf(res <> "", " / ", "") & GetSafeFieldPlus(prozrs, "Ebene3", "")
        End Select
    Next i
    
    GetProzText = res

End Function

Function SindFragenProzesseGeaendert(ByRef dateiRS As Object, ByRef conn As Object) As Long
    SindFragenProzesseGeaendert = 0

    Dim gibtEsAntworten As Boolean
    gibtEsAntworten = False
    Dim rs As Object
    Set rs = CreateObject("ADODB.Recordset")
    ' gibt es |fffd|berhaupt Antworten?
    rs.Open "select i.idvDateiID from idvDateien i where (i.AntwortID1 > 0 or i.AntwortID2 > 0) and i.idvDateiID = " & dateiRS("idvDateiID"), conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
    If rs.EOF = False Then
        gibtEsAntworten = True
    End If
    rs.Close
    
    If gibtEsAntworten Then
        ' gibt es die AntwortIDs noch? Wenn die Fragen neu aktiviert wurden, dann existieren die IDs nicht mehr
        rs.Open "select i.idvDateiID from idvDateien i inner join gFragenAntworten g on (i.AntwortID1 = g.FrageAntwortID or i.AntwortID2 = g.FrageAntwortID) where i.idvDateiID = " & dateiRS("idvDateiID"), conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
        If rs.EOF Then
           SindFragenProzesseGeaendert = 1
        End If
        rs.Close
    End If
        
    If SindFragenProzesseGeaendert = 0 Then
        ' gibt es gesetzte Prozesse, die jetzt nicht mehr existieren?
        rs.Open "select p.idvDateiID from idvDateienProzess p left join gProzessAktuell pa on p.Prozessschluessel = pa.Prozessschluessel where pa.ProzessID Is Null and p.idvDateiID = " & dateiRS("idvDateiID"), conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
        If rs.EOF = False Then
            SindFragenProzesseGeaendert = SindFragenProzesseGeaendert + 2
        End If
        rs.Close
    End If
End Function

Function GetProzesseText(ByRef dateiRS As Object, ByRef conn As Object) As String

    GetProzesseText = ""
    
    ' Und noch die Prozesse mit ausgeben wenn vorhanden
    Dim prozrs As Object
    Set prozrs = CreateObject("ADODB.Recordset")
    
    Dim sbpa As CFragenSchutzbedarf
    Set sbpa = New CFragenSchutzbedarf
    
    prozrs.Open "Select Idvdateienprozess.Prozessschluessel, Prozessname, Prozesslandkarte, Ebene3, schutzbedarf, integritaet, vertraulichkeit, verfuegbarkeit, authentizitaet, Informationsklassifizierung From (idvDateienProzess " & _
              "Inner Join Gprozess On Idvdateienprozess.Prozessschluessel = Gprozess.Prozessschluessel) " & _
              "Where idvDateienProzess.Idvdateiid = " & GetSafeFieldPlus(dateiRS, "idvDateiID", 0) & _
              " AND Idvdateienprozess.Einfuegung >= Von And Idvdateienprozess.Einfuegung < Bis;", _
              conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
    If Not prozrs.EOF Then
      GetProzesseText = FMT0("FREIGABEF_7") & vbCrLf
      
      Do While Not prozrs.EOF
        GetProzesseText = GetProzesseText & GetProzText(prozrs) & vbCrLf
        sbpa.SetMaxValuesPAByRS prozrs
        prozrs.MoveNext
      Loop
    
      If GetProzesseText <> "" Then
        If FMT0("ST_43") <> "" Then
          GetProzesseText = GetProzesseText & sbpa.ReplaceText(FMT0("ST_43")) & vbCrLf
        Else
          GetProzesseText = GetProzesseText & vbCrLf
        End If
      End If
    End If
    prozrs.Close
    Set prozrs = Nothing
    Set sbpa = Nothing

End Function

Function GetDateiFragenUndAntworten(ByRef dateiRS As Object, ByRef conn As Object, ByRef ergebnis As String) As Boolean
  Dim foundProcessAnswer As Boolean
  foundProcessAnswer = False
  Dim prozrs As Object
  Dim sbpa As CFragenSchutzbedarf

  Dim dateiid As Long
  dateiid = GetSafeFieldPlus(dateiRS, "idvDateiID", 0)
  Dim i As Long
  Dim fragentext As String
  Dim kommentar As String
  
  Dim befragung As New CBefragung
  If befragung.InitDoku(dateiRS, conn) = True Then
    ' Jetzt durch jeden FragenDlg durchgehen
    Dim sb As New CFragenSchutzbedarf
    Dim dlg As CFragenDlg
    For Each dlg In befragung.FragenDlgCol
        If dlg.m_IsPA Then
            foundProcessAnswer = True
            ergebnis = ergebnis & FMT0("FREIGABEF_7") & vbCrLf
            Dim pText As Variant
            For Each pText In dlg.m_ProzesseText
                ergebnis = ergebnis & pText & vbCrLf
            Next
            If ergebnis <> "" Then
              If FMT0("ST_43") <> "" Then
                ergebnis = ergebnis & dlg.m_Schutzbed.ReplaceText(FMT0("ST_43")) & vbCrLf
              Else
                ergebnis = ergebnis & vbCrLf
              End If
            End If
        Else
            Dim idx As Long
            For i = 1 To dlg.m_Fragen.count
                Dim nr As Long
                Dim antwortID As Long
                nr = CLng(dlg.m_Fragen(i))
                antwortID = CLng(dlg.m_Antworten(i).m_AntwortID)

                Dim Frage As CFragenData
                Set Frage = befragung.GetFrageByNr(nr, idx)
                fragentext = PrepareLiveQuestionText(Frage.m_Frage, sb)
                kommentar = Frage.kommentar

                Dim antwort As CAntwort
                Set antwort = befragung.GetAntwort(antwortID)
                If Not antwort Is Nothing Then
                    If kommentar <> "" Then
                        If gTranslation.StringExists("QANDAWCOMMENT") Then
                          ergebnis = ergebnis & FMT3("QANDAWCOMMENT", fragentext, antwort.m_AntwortText, kommentar) & vbCrLf
                        Else
                          ergebnis = ergebnis & fragentext & vbCrLf & "     " & antwort.m_AntwortText & vbCrLf & "     " & kommentar & vbCrLf & vbCrLf
                        End If
                    Else
                        If gTranslation.StringExists("QANDA") Then
                          ergebnis = ergebnis & FMT2("QANDA", fragentext, antwort.m_AntwortText) & vbCrLf
                        Else
                          ergebnis = ergebnis & fragentext & vbCrLf & "     " & antwort.m_AntwortText & vbCrLf & vbCrLf
                        End If
                    End If
                End If
                Set antwort = Nothing
                Set Frage = Nothing
            Next i
        End If
        Set sb = dlg.m_Schutzbed
        Set dlg = Nothing
    Next
    Set sb = Nothing
  
    If foundProcessAnswer = False Then
        ergebnis = ergebnis & GetProzesseText(dateiRS, conn)
    End If
  
  Else
    Dim rs As Object
    Set rs = CreateObject("ADODB.Recordset")
    For i = 1 To 15
      If Not IsNull(dateiRS.Fields("AntwortID" & i).value) Then
        If dateiRS.Fields("AntwortID" & i).value > 0 Then
          Dim query As String
          query = "SELECT gFragenAntwortenHistorie.Antwort, gFragenHistorie.Nr, gFragenHistorie.Frage, uF.LokalisierterText as LocFrage, uA.LokalisierterText as LocAntwort, comment1.UserText " & _
          " from ((((gFragenAntwortenHistorie INNER JOIN gFragenHistorie ON gFragenAntwortenHistorie.FrageID = gFragenHistorie.FrageID) " & _
          " left join gTexteUebersetzungen uF on (uF.TextID = gFragenHistorie.TextID and uF.LanguageID = " & GetMyDBLanguage(conn) & ")) " & _
          " left join gTexteUebersetzungen uA on (uA.TextID = gFragenAntwortenHistorie.TextID and uA.LanguageID = " & GetMyDBLanguage(conn) & ")) " & _
          " left join idvDateienFragenKommentar comment1 on (comment1.FragenID = gFragenAntwortenHistorie.FrageID AND comment1.idvDateiID = " & dateiid & "))" & _
          " where " & dateiRS.Fields("AntwortID" & i).value & " = gFragenAntwortenHistorie.FrageAntwortID"
          rs.Open query, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
          If Not rs.EOF Then
            fragentext = GetLocValueFromField(rs, "Frage", "LocFrage", "") ' PrepareQuestionText(dateiRS, GetLocValueFromField(rs, "Frage", "LocFrage", ""))
            kommentar = GetSafeField(rs, "UserText")
            If kommentar <> "" Then
              ergebnis = ergebnis & fragentext & vbCrLf & "     " & GetLocValueFromField(rs, "Antwort", "LocAntwort", "") & vbCrLf & "     " & kommentar & vbCrLf & vbCrLf
            Else
              ergebnis = ergebnis & fragentext & vbCrLf & "     " & GetLocValueFromField(rs, "Antwort", "LocAntwort", "") & vbCrLf & vbCrLf
            End If
          End If
          rs.Close
        End If
      End If
    Next i
    Set rs = Nothing
    
    ergebnis = ergebnis & GetProzesseText(dateiRS, conn)
  End If
      
  If ergebnis = "" Then
    'ergebnis = "Es wurde bisher noch keine Risikobefragung durchgef|fffd|hrt."
    ergebnis = FMT0("FREIGABEF_8")
    GetDateiFragenUndAntworten = False
  Else
    GetDateiFragenUndAntworten = True
  End If
  
  Set befragung = Nothing
End Function


Private Function GetWerteFuerDokufeld(ByRef conn As Object, ByVal feldnummer As Long, ByVal dokufeldids As String)
    If dokufeldids = "" Then
        GetWerteFuerDokufeld = ""
        Exit Function
    End If
    
  GetWerteFuerDokufeld = ""
  Dim treffer As Long
  treffer = 0

  On Error Resume Next
  Dim drs As Object
  Set drs = CreateObject("ADODB.Recordset")
    drs.Open "Select gDokufelderWerte.*, u.LokalisierterText from gDokufelderWerte left join gTexteUebersetzungen u on (u.TextID = gDokufelderWerte.Textid and u.LanguageID = " & GetMyDBLanguage(conn) & ") " & _
    " where Feldnummer =" & feldnummer, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
    While Not drs.EOF
        Dim v As String
        v = GetValueFromField(drs, "Nummer", "")
        If v <> "" Then
            If InStr(dokufeldids, v & "|") > 0 Then
                If GetWerteFuerDokufeld <> "" Then
                    GetWerteFuerDokufeld = GetWerteFuerDokufeld & vbCrLf
                End If
                GetWerteFuerDokufeld = GetWerteFuerDokufeld & GetLocValueFromField(drs, "Wert", "LokalisierterText", "")
                treffer = treffer + 1
            End If
        End If
        drs.MoveNext
    Wend
    drs.Close
    Set drs = Nothing
    
    If treffer = 0 Then
        GetWerteFuerDokufeld = dokufeldids
    End If

End Function

Attribute VB_Name = "Freigaben"
Option Explicit

' Typ G_CfgFreigabeInit, G_CfgFreigabeErteilen, G_CfgFreigabeMM, G_CfgFreigabeEntf, G_CfgBSSetzen, G_CfgBSEntfernen
Function UserKannFreigeben(ByVal typ As String, ByRef rs As Object) As Boolean
  If typ = "" Then
    UserKannFreigeben = True
    Exit Function
  End If
  
  If InStr(typ, "T") > 0 Then
    If UserInCommaSeparatedList(GetUserName, GetSafeFieldPlus(rs, "VerantwortlicherAutor", "")) Then
      UserKannFreigeben = True
      Exit Function
    End If
  End If
  If InStr(typ, "F") > 0 Then
    If UserInCommaSeparatedList(GetUserName, GetSafeFieldPlus(rs, "FachlichVerantwortlicher", "")) Then
      UserKannFreigeben = True
      Exit Function
    End If
  End If
  
  UserKannFreigeben = False
End Function

' typ kann F oder T sein
Function GetVerantwortlicheUser(ByRef conn As Object, ByRef rs As Object, ByVal typ As String) As String

  Dim s As String
  Dim s1 As String
  Dim s2 As String
  If InStr(typ, "T") > 0 Then
    s1 = GetSafeFieldPlus(rs, "VerantwortlicherAutor", "")
  End If
  If InStr(typ, "F") > 0 Then
    s2 = GetSafeFieldPlus(rs, "FachlichVerantwortlicher", "")
  End If
  
  If s1 <> "" And s2 <> "" Then
    s = s1 & "," & s2
  ElseIf s1 <> "" Then
    s = s1
  Else
    s = s2
  End If
  
  If s <> "" Then
    Dim trs As Object
    s = UCase(s)
    Set trs = OpenRS("SELECT * FROM gWindowsUserAktuell where LogonID in (" & "'" & Replace(s, ",", "','") & "'" & ")", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
    If Not trs Is Nothing Then
      ' Die Windows-Kennungen in jedem Fall mit ausgeben.
      s = Replace(s, ",", ", ") & vbCrLf
      Do While Not trs.EOF
        If GetSafeFieldPlus(trs, "Nachname", "") & GetSafeFieldPlus(trs, "Vorname", "") <> "" Then
          s = s & GetSafeFieldPlus(trs, "Nachname", "") & ", " & GetSafeFieldPlus(trs, "Vorname", "") & vbCrLf
        End If
        trs.MoveNext
      Loop
      trs.Close
      Set trs = Nothing
    End If
    
  End If

  GetVerantwortlicheUser = s

End Function


Attribute VB_Name = "GlobalStuff"
Option Explicit

Public Const progNameShort As String = "ET"
Public Const ProgNameLong As String = "ExcelTracker"
Public Const MyProgramLicenseVersion As Long = 1
Public Const MyAppID = 12

Public Const C_AllowLocalSaves As Boolean = True
Public Const Project_ExcelTracker As Long = 1

Attribute VB_Name = "GlobalStuff2"
Option Explicit

Public Const myVersion As String = "V4.0 FP5a"
Public Const MyProgramReleaseDate As Date = #11/15/2019#     ' m/d/yyyy
Public Const MyInternalVersion As Long = 106

' Dieses Plugin l|fffd|uft maximal mit der Version C_DBVersionAllowed der Datenbank. Wenn die Version der DB gr|fffd||fffd|er ist, ist das Plugin inaktiv
' Muss nat|fffd|rlich vor jedem Release gesetzt werden, sonst l|fffd|uft kein Update.
Public Const C_DBVersion = 311

Public G_PARAM_TimeoutConnection As Long
Public G_PARAM_TimeoutTableOpen As Long
Public G_PARAM_SWLCAktivieren As Boolean

Public G_cfgDebugInfosLoggen As Boolean
Public G_cfgTestEntwProd As Boolean

Public G_UserImportType As Long
Public G_cfgOEUserDeaktivert As Boolean

Public G_IgnoreFutureWriteWindows As Boolean

Public G_CfgPath As String ' Inklusive Backslash am Ende!!!! Nur im Scheduler gesetzt, ACHTUNG!!!
Public G_cfgBinpfad As String
Public G_cfgLogpfad As String
Public G_cfgTemppfad As String
Public G_cfgPasswortpfad As String
Public G_cfgKeypfad As String
Public G_cfgECCPfad As String
Public G_cfgACCPfad As String
Public G_cfgEPPfad As String
Public G_cfgESQAPfad As String
Public G_cfgEFCPfad As String
Public G_cfgShowMSGBoxForAllErrors As Boolean
Public G_cfgFreigabeformspeicherpfad As String
' Das ist jetzt eine Funktion
'Public G_Freigabeformular As String
' Private G_MyFreigabeformular As String   ' OBSOLET, l|fffd|uft |fffd|ber G_FreigabeformularScanner
Public G_cfgFreigegebeneBefragen As Boolean
Public G_cfgVerlustFreigabeBeiBefragung As Boolean

Public G_Dokuformular As String
Public G_cfgKonvertierenAktiv As Boolean
Public G_cfgTestarea As Boolean
Public G_cfgNoAD As Boolean
Public G_cfgInfoPfad As String
Public G_cfgADString As String
Public G_cfgTestuser As Boolean
Public G_cfgSBSNoID As Boolean
Public G_cfgFreigabeAbRisiko As Double
Public G_cfgNurScanpfade As Boolean
Public G_Scanpfade As Collection
' Wenn das True ist, wird die txt file Optimierung (kein Lesen aus der DB) fuer die Prozesse Form nicht benutzt
Public G_CfgPANoTextfile As Boolean
Public G_cfgIgnoreWarningPaths As Collection
Public G_cfgIgnoreBlockPaths As Collection

Public G_DOKU_Dateiberechtigungen As Boolean ' Nur im Doku-Screen gesetzt

Public G_StartupPath As String
Public G_Firmenlogo As String

Public G_Lizenznehmer As String
Public G_LizenznehmerAdresse As String
Public G_Lizenzen As Long
Public G_FullDemoBis As Date
Public G_MyLicencseVersion As Long
Public G_Wartung As Boolean
Public G_WartungBis As Date
Public G_FullVersion As Boolean

Public G_frmDoku_Cancel As Boolean

Public G_PARAM_FormelnNichtZaehlenAbKB As Long
Public G_PARAM_WarnungManuelleBerechnung As Boolean
Public G_IgnoreThisOneWarnungManuelleBerechnung As Boolean

Public G_PARAM_OEAusADGruppeLesen As Boolean
Public G_PARAM_ToDoListe As Boolean

Public G_PARAM_DokuInWord As Boolean
Public G_PARAM_FragenAntworten As Boolean
Public G_PARAM_XMinutenNichtBefragen As Long
Public G_PARAM_FragenAntwortenScreen As Boolean
Public G_PARAM_Ampel As Boolean
Public G_PARAM_AmpelRisiko As Double
Public G_PARAM_FreigabenAusVorversionDeaktivieren As Boolean
Public G_PARAM_ChecklisteFreigabeInitiierung As Boolean
Public G_PARAM_ChecklisteFreigabe As Boolean

Public G_PARAM_BlattschutzEntf4AP As Boolean

Public G_UserDeaktiviert As Boolean
Public G_AllowLoggingToStorage As Boolean
Public G_PARAM_StoreMailsToTable As Boolean

Public G_cfgToolbarRechtsOben As Boolean

Public G_DBUser As String
Public G_DBUserPasswort As String

Public G_Cursorlocation As Long

Public G_IDVSuitePath As String


Public Const C_RepeatRSOpenSleep As Long = 50
Public Const C_RepeatRSOpenCount As Long = 10
Public Const C_RepeatConnOpenSleep As Long = 50
Public Const C_RepeatConnOpenCount As Long = 10

Public gCHR As String
Public gCursorLocation As Long

Public G_MyOEGelesen As Boolean
Public G_MyOE As String
Public G_MyOEID As Long

' Derzeit nur gesetzt, wenn MeineDateien aufgerufen wurde, kommt wahrscheinlich irgend wann ins init
Public G_MeineOEsGelesen As Boolean
Public G_MeineOEs As String
Public G_MeineOEsVertretung As String
Public G_OEHierarchie As Boolean
Public G_Freigabeordner As String
Public G_PDFDruckordner As String


Public G_CfgHeaderLeft As String
Public G_CfgHeaderCenter As String
Public G_CfgHeaderRight As String
Public G_CfgFooterLeft As String
Public G_CfgFooterCenter As String
Public G_CfgFooterRight As String
Public G_CfgFG_HeaderLeft As String
Public G_CfgFG_HeaderCenter As String
Public G_CfgFG_HeaderRight As String
Public G_CfgFG_FooterLeft As String
Public G_CfgFG_FooterCenter As String
Public G_CfgFG_FooterRight As String
Public G_cfgNoHeaderFooter As String
Public G_CfgLogoFarbe As Long

Public G_CfgInformationsklasseAnzeigen As Boolean
Public G_CfgBankfachlichAnzeigen As Boolean
Public G_CfgGOBDAnzeigen As Boolean
Public G_cfgDatenschutzhinweisAus As Boolean
Public G_CfgSchutzbedarfsfensterAnzeigen As Boolean
Public G_CfgZeitaufwandZurDokuAnzeigen As Boolean

Public G_CfgAppinfoInfo As Boolean
Public G_CfgAppinfoAnalysis As Boolean
Public G_CfgAppinfoLog As Boolean


Public G_CfgPASchluesselPx As Long
Public G_CfgPAProzEbene1Px As Long
Public G_CfgPAProzEbene2Px As Long
Public G_CfgPAProzEbene3Px As Long
Public G_CfgPAReihenfolge As String
Public G_CfgPAReihenfolgeDoku As String
Public G_cfgLnkApp As String
Public G_CfgProzessUnbekanntSichtbar As Boolean

Public G_cfgExcel As String
Public G_cfgScriptdebug As String
Public G_cfgMinorChanges4APComplex As Boolean ' nur true, wenn nicht die einfache MM authentifizierung an ist.

Public G_CfgFreigabeInit As String      ' leer = alle (die das Icon haben), F = Fachverantwortlicher, T = technisch verantwortlicher, F und T kann auch zusammen agegeben werden
Public G_CfgFreigabeErteilen As String  ' leer = alle (die das Icon haben), F = Fachverantwortlicher, T = technisch verantwortlicher, F und T kann auch zusammen agegeben werden
Public G_CfgFreigabeMM As String        ' leer = alle, F = Fachverantwortlicher, T = technisch verantwortlicher, F und T kann auch zusammen agegeben werden
Public G_CfgFreigabeEntf As String      ' leer = alle, F = Fachverantwortlicher, T = technisch verantwortlicher, F und T kann auch zusammen agegeben werden
Public G_CfgBSSetzen As String          ' leer = alle, F = Fachverantwortlicher, T = technisch verantwortlicher, F und T kann auch zusammen agegeben werden
Public G_CfgBSEntf As String            ' leer = alle, F = Fachverantwortlicher, T = technisch verantwortlicher, F und T kann auch zusammen agegeben werden
Public G_CfgTVAnzeigen As Long          ' 0 = anzeigen und editieren (Standard), 1 = nicht anzeigen, 2 = anzeigen locked (Feld: VerantwortlicherAutor)
Public G_CfgFVAnzeigen As Long          ' 0 = anzeigen und editieren (Standard), 1 = nicht anzeigen, 2 = anzeigen locked (Feld: FachlichVerantwortlicher)


' Juni 2017: Parameter fuer den TCP DB Connection Test
Public G_CfgDoDBConnectTest As Boolean
Public G_CfgDBConnectTestTimeout As Long

Public G_cfgSaveNachInit As Boolean
Public G_cfgAutoProtectBeiInit As Long
Public G_cfgWorksheetProtArgs As String
Public G_cfgIgnoreProtectedWorksheets As Boolean


Public G_DBConnectionString As String

Public G_cfgLoadETInResults As Boolean

Public G_AntwortenNeuGeben As Boolean
Public G_SelectedProzesse As Collection


' nur f|fffd|r xlam
Public G_Auswahl As Long
Public G_AuswahlName As String

Public G_CriticalAddins As String
Public G_UserOnOff As Boolean
Public G_NoSave As Boolean

Public Const G_SQL_Anywhere As Integer = 1
Public Const G_SQL_Server As Integer = 2
Public Const G_MySQL As Integer = 3
Public Const G_Access As Integer = 4
Public Const G_Oracle As Integer = 5

Public G_DBType As Long
Public G_DBVersion As Long

Public G_SchutzbedarfMussVerfuegbarkeit As Boolean
Public G_SchutzbedarfMussIntegritaet As Boolean
Public G_SchutzbedarfMussVertraulichkeit As Boolean
Public G_SchutzbedarfMussAuthentizitaet As Boolean
Public G_cfgAuthentizitaetAnzeigen As Boolean
Public G_cfgFremdentwicklungAnzeigen As Boolean

Public G_Form_InTerminate As Boolean
Public G_Form_InInitialize As Boolean

Public G_ZusaetzlicheDateienTemplate As String
Public G_ZusaetzlicheDateienButton As String

Public G_FreigabeformularScanner As String
Public G_FreigabeformularUpdateScanner As String
Public G_EFCVorversion As Boolean
Public G_FreigabeformularUpload As Boolean
Public G_CfgSBSObjektMussGesetztSein As Boolean

Public G_ShowTextIDs As Boolean

Public G_cfgPathMapSrcCol As Collection
Public G_cfgPathMapDstCol As Collection

Enum DebType
    tERROR = 1
    tinfo = 2
    tTime = 3
    tdebug = 4
    tMail = 5
    tSystem = 6
    tSystemToFile = 7 ' wie tSystem, schreibt aber nur in die Datei
End Enum

Enum PathType
    tLog = 1
    tTemp = 2
    tPassword = 3
    tKey = 4
    tEcc = 5
    tFreigabeform = 6
    tEP = 7
    tAcc = 8
    tEFC = 9
    tESQA = 10
End Enum


#If VBA7 And Win64 Then
' Done
Public Declare PtrSafe Sub Sleep Lib "kernel32" (ByVal _
          dwMilliseconds As Long)

#Else
Public Declare Sub Sleep Lib "kernel32" (ByVal _
          dwMilliseconds As Long)

#End If


Sub StartupInit(appname As String)
    
    DebugPrint tdebug, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ") - " & MyProgramReleaseDate
    DebugPrint tdebug, "Station: " & GetComputerName
    Dim i As Long
    Dim cfg As New CfgReader
    Dim s As String
    Dim tss As String
    Dim pos As Long
    Dim pluginDeaktiviert As Boolean
    
    Set G_cfgIgnoreWarningPaths = Nothing
    Set G_cfgIgnoreBlockPaths = Nothing
    
    G_PARAM_TimeoutConnection = 5000
    G_PARAM_TimeoutTableOpen = 2000
    G_cfgADString = "LDAP"
    
    G_CfgAppinfoInfo = True
    G_CfgAppinfoAnalysis = True
    G_CfgAppinfoLog = True
    
    G_CfgLogoFarbe = -1
    G_CfgInformationsklasseAnzeigen = True
    G_CfgBankfachlichAnzeigen = True
    G_CfgGOBDAnzeigen = True
    G_cfgFremdentwicklungAnzeigen = False
    G_CfgSchutzbedarfsfensterAnzeigen = True
    G_CfgZeitaufwandZurDokuAnzeigen = True
    G_cfgFreigabeAbRisiko = -10000#
    G_cfgDatenschutzhinweisAus = True
  
    G_CfgProzessUnbekanntSichtbar = True
    G_cfgAuthentizitaetAnzeigen = False
     
    G_Dokuformular = ""
    G_cfgBinpfad = app.path & "\"
    G_StartupPath = app.path & "\"
    
    G_PARAM_TimeoutConnection = 5000
    G_PARAM_TimeoutTableOpen = 2000
    G_PARAM_FormelnNichtZaehlenAbKB = 1000

    G_cfgDebugInfosLoggen = False
    
    G_cfgTestEntwProd = True
    
    G_cfgLogpfad = ""
    G_cfgTemppfad = ""
    G_cfgPasswortpfad = ""
    G_cfgKeypfad = ""
    G_cfgFreigabeformspeicherpfad = ""
    G_cfgInfoPfad = ""
    
    ' Die Pfade stimmen nicht, es soll aber schon mal was drin stehen
    G_cfgECCPfad = app.path & "\..\ECC"
    G_cfgACCPfad = app.path & "\..\ACC"
    G_cfgEPPfad = app.path & "\..\EP"
    G_cfgEFCPfad = app.path & "\..\EFC"
    G_cfgESQAPfad = app.path & "\..\ESQA"
    
'    app.OleServerBusyRaiseError = True
'    OLEServerBusyTimeout
    
    G_DBUser = "IDVTTECHUSER"
    G_DBUserPasswort = "12SD3Ax$!d7%fd/"
    G_DBType = 0
    G_DBVersion = 0
    
    G_ZusaetzlicheDateienTemplate = ""
    G_ZusaetzlicheDateienButton = ""
    
    Set cfg = New CfgReader
    
    Dim tFORCELOGUSERS As Boolean
    Dim tLOGWINDOWVISIBLEUSERS As Boolean

    tLOGWINDOWVISIBLEUSERS = IIf(GetSetting(appname:="Stromwerken", Section:="Tracker", Key:="ShowLogWindow", Default:=0) = 1, True, False)
    tFORCELOGUSERS = IIf(GetSetting(appname:="Stromwerken", Section:="Tracker", Key:="ForceLog", Default:=0) = 1, True, False)
    If tFORCELOGUSERS Then
      G_cfgDebugInfosLoggen = True
      G_LogThisUser = True
    End If

    If FileExists(G_StartupPath & "cfg\" & ProgNameLong & ".cfg") = True Or FileExists(G_StartupPath & ProgNameLong & ".cfg") = True Or FileExists(G_StartupPath & "..\cfg\IDV-Suite.cfg") = True Or _
        FileExists(G_StartupPath & "..\..\IDV-Suite-Plugins\cfg\IDV-Suite.cfg") = True Or _
        FileExists(G_StartupPath & "IDV-Suite.cfg") = True Then
        
        Dim cfgFile As String
        If FileExists(G_StartupPath & "cfg\" & ProgNameLong & ".cfg") = True Then
          cfgFile = G_StartupPath & "cfg\" & ProgNameLong & ".cfg"
        ElseIf FileExists(G_StartupPath & ProgNameLong & ".cfg") = True Then
          cfgFile = G_StartupPath & ProgNameLong & ".cfg"
        ElseIf FileExists(G_StartupPath & "..\cfg\IDV-Suite.cfg") = True Then
          cfgFile = G_StartupPath & "..\cfg\IDV-Suite.cfg"
        ElseIf FileExists(G_StartupPath & "..\..\IDV-Suite-Plugins\cfg\IDV-Suite.cfg") = True Then
          cfgFile = G_StartupPath & "..\..\IDV-Suite-Plugins\cfg\IDV-Suite.cfg"
        ElseIf FileExists(G_StartupPath & "idv-suite.cfg") = True Then
          cfgFile = G_StartupPath & "idv-suite.cfg"
        End If
        
        If cfgFile = "" Then
          DebugPrint DebType.tERROR, "Keine CFG gefunden! "
          DebugPrint DebType.tinfo, "*** Plugin |fffd|ber CFG deaktivert!"
          pluginDeaktiviert = True
          G_UserDeaktiviert = True
          Exit Sub
        Else
          cfg.GetCfg cfgFile
          DebugPrint DebType.tinfo, "Cfg geladen: " & cfgFile
        End If
        
        GetDBUser cfg
        
        If cfg.GetSection("DB") = True Then
          G_DBConnectionString = cfg.GetValue("CONNECTIONSTRING")
        End If
        
        If cfg.GetSection("DBCONNECTEXT") = True Then
          Dim connnectCount As Long
          Dim drv As String
          For connnectCount = 1 To 10
            drv = cfg.GetValue("DRIVER" & connnectCount)
            If drv <> "" Then
              If FileExists(drv) Then
                G_DBConnectionString = cfg.GetValue("CONNECTIONSTRING" & connnectCount)
                Exit For
              End If
            End If
          Next connnectCount
        End If
                
        If cfg.GetSection("GLOBALS") = True Then
        
          ' Was muss gesetzt sein, damit der Schutzbedarf tats|fffd|chlich gerechnet wird?
          s = cfg.GetValue("SBMUSS")
          If s <> "" Then
            If InStr(UCase(s), "VF") > 0 Then
              G_SchutzbedarfMussVerfuegbarkeit = True
              s = Replace(s, "VF", "")
            End If
            If InStr(UCase(s), "I") > 0 Then
              G_SchutzbedarfMussIntegritaet = True
              s = Replace(s, "I", "")
            End If
            If InStr(UCase(s), "V") > 0 Then
              G_SchutzbedarfMussVertraulichkeit = True
              s = Replace(s, "V", "")
            End If
            If InStr(UCase(s), "A") > 0 Then
              G_SchutzbedarfMussAuthentizitaet = True
              s = Replace(s, "A", "")
            End If
          End If
          
          s = cfg.GetValue("TESTUSER")
          If s <> "" Then
            If InStr(UCase(s), UCase(GetUserName)) > 0 Then
              G_cfgTestuser = True
            End If
          End If
        
          s = cfg.GetValue("NURSCANPFADE")
          If s <> "" Then
            If InStr(UCase(s), "JA") > 0 Then
              G_cfgNurScanpfade = True
            End If
          End If
          
          s = cfg.GetValue("IGNOREWARNING")
          If s <> "" Then
            pos = 1
            Set G_cfgIgnoreWarningPaths = New Collection
            Do
              tss = GetNextText(s, pos)
              If tss <> "" Then
                If Right(tss, 1) <> "*" Then
                  tss = tss & "*"
                End If
                G_cfgIgnoreWarningPaths.add tss
              End If
            Loop While tss <> ""
          End If
          
          s = cfg.GetValue("IGNOREBLOCK")
          If s <> "" Then
            pos = 1
            Set G_cfgIgnoreBlockPaths = New Collection
            Do
              tss = GetNextText(s, pos)
              If tss <> "" Then
                If Right(tss, 1) <> "*" Then
                  tss = tss & "*"
                End If
                G_cfgIgnoreBlockPaths.add tss
              End If
            Loop While tss <> ""
          End If
          
          If Not G_cfgTestuser Then
            If UCase(cfg.GetValue("AKTIV")) = "NEIN" Or UCase(cfg.GetValue("ACTIVE")) = "NO" Then
              pluginDeaktiviert = True
              G_UserDeaktiviert = True
            End If
          End If
          
          For i = 1 To 5
            s = cfg.GetValue("LNKAPP" & i)
            If s <> "" Then
              If Left(s, 2) = "\\" Or Mid(s, 2, 1) = ":" Then
                If FileExists(s) Then
                  G_cfgLnkApp = s
                  Exit For
                End If
              Else
                G_cfgLnkApp = s
                Exit For
              End If
            End If
          
          Next i
          
          'If UCase(cfg.GetValue("INFORMATIONSKLASSEANZEIGEN")) = "NEIN" Then
          If IsNo(cfg.GetValue("INFORMATIONSKLASSEANZEIGEN")) Then
            G_CfgInformationsklasseAnzeigen = False
          End If
          'If UCase(cfg.GetValue("BANKFACHLICHANZEIGEN")) = "NEIN" Then
          If IsNo(cfg.GetValue("BANKFACHLICHANZEIGEN")) Then
            G_CfgBankfachlichAnzeigen = False
          End If
          'If UCase(cfg.GetValue("GOBDANZEIGEN")) = "NEIN" Then
          If IsNo(cfg.GetValue("GOBDANZEIGEN")) Then
            G_CfgGOBDAnzeigen = False
          End If
          'If UCase(cfg.GetValue("GOBDANZEIGEN")) = "NEIN" Then
          If IsYes(cfg.GetValue("FREMDENTWICKLUNGANZEIGEN")) Then
            G_cfgFremdentwicklungAnzeigen = True
          End If
          'If UCase(cfg.GetValue("SCHUTZBEDARFSFENSTERANZEIGEN")) = "NEIN" Then
          If IsNo(cfg.GetValue("SCHUTZBEDARFSFENSTERANZEIGEN")) Then
            G_CfgSchutzbedarfsfensterAnzeigen = False
          End If
          'If UCase(cfg.GetValue("ZEITAUFWANDZURDOKUANZEIGEN")) = "NEIN" Then
          If IsNo(cfg.GetValue("ZEITAUFWANDZURDOKUANZEIGEN")) Then
            G_CfgZeitaufwandZurDokuAnzeigen = False
          End If
          If UCase(cfg.GetValue("AUTHENTIZITAETANZEIGEN")) = "JA" Then
             G_cfgAuthentizitaetAnzeigen = True
          End If

          If IsNo(cfg.GetValue("TESTENTWPROD")) Then
            G_cfgTestEntwProd = False
          End If
          
          G_cfgKeypfad = GetRelativePath(G_cfgKeypfad, cfg.GetValue("KEYPFAD"))
          G_cfgPasswortpfad = GetRelativePath(G_cfgPasswortpfad, cfg.GetValue("PASSWORTPFAD"))
          G_cfgLogpfad = GetRelativePath(G_cfgLogpfad, cfg.GetValue("LOGPFAD"))
          G_cfgTemppfad = GetRelativePath(G_cfgTemppfad, cfg.GetValue("TEMPPFAD"))
          
          If cfg.GetValue("BINPFAD") <> "" Then
            G_cfgBinpfad = GetRelativePath(G_cfgBinpfad, cfg.GetValue("BINPFAD"))
            app.path = G_cfgBinpfad
          End If
          
          If cfg.GetValue("ECCPFAD") <> "" Then
            G_cfgECCPfad = GetRelativePath(G_cfgECCPfad, cfg.GetValue("ECCPFAD"))
          End If
          If cfg.GetValue("ACCPFAD") <> "" Then
            G_cfgACCPfad = GetRelativePath(G_cfgACCPfad, cfg.GetValue("ACCPFAD"))
          End If
          If cfg.GetValue("EPPFAD") <> "" Then
            G_cfgEPPfad = GetRelativePath(G_cfgEPPfad, cfg.GetValue("EPPFAD"))
          End If
          If cfg.GetValue("EFCPFAD") <> "" Then
            G_cfgEFCPfad = GetRelativePath(G_cfgEFCPfad, cfg.GetValue("EFCPFAD"))
          End If
          If cfg.GetValue("ESQAPFAD") <> "" Then
            G_cfgESQAPfad = GetRelativePath(G_cfgESQAPfad, cfg.GetValue("ESQAPFAD"))
          End If
          If cfg.GetValue("FREIGABEFORMSPEICHERPFAD") <> "" Then
            G_cfgFreigabeformspeicherpfad = GetRelativePath(G_cfgFreigabeformspeicherpfad, cfg.GetValue("FREIGABEFORMSPEICHERPFAD"))
          End If
        
          If InStr(UCase(cfg.GetValue("FORCELOGUSERS")), UCase(GetUserName())) > 0 Then
            tFORCELOGUSERS = True
            G_cfgDebugInfosLoggen = True
            G_LogThisUser = True
          End If
          If InStr(UCase(cfg.GetValue("LOGWINDOWVISIBLEUSERS")), UCase(GetUserName())) > 0 Then
            tLOGWINDOWVISIBLEUSERS = True
          End If
          
          s = cfg.GetValue("SBSNOID")
          If IsYes(s) Then
            G_cfgSBSNoID = True
          End If
          
          G_Dokuformular = cfg.GetValue("DOKUFORMULAR")
          If G_Dokuformular <> "" Then
            G_Dokuformular = GetFullPath(G_Dokuformular)
          Else
            G_Dokuformular = G_cfgBinpfad & "\Filedoku.dot"
          End If
          
          'G_Freigabeformular = cfg.GetValue("FREIGABEFORMULAR")
          If cfg.GetValue("FREIGABEFORMULAR") <> "" Then
            G_FreigabeformularScanner = GetFullPath(cfg.GetValue("FREIGABEFORMULAR"))
          End If
          If cfg.GetValue("FREIGABEFORMULARUPDATE") <> "" Then
            G_FreigabeformularUpdateScanner = GetFullPath(cfg.GetValue("FREIGABEFORMULARUPDATE"))
          End If
          
          G_ZusaetzlicheDateienTemplate = cfg.GetValue("ZUSDATEIENTEMPLATE")
          If G_ZusaetzlicheDateienTemplate <> "" Then
            G_ZusaetzlicheDateienTemplate = GetFullPath(G_ZusaetzlicheDateienTemplate)
          End If
          
          G_ZusaetzlicheDateienButton = cfg.GetValue("ZUSDATEIENBUTTON")
          
          s = cfg.GetValue("CURSORLOCATION")
          If UCase(s) = "SERVER" Then
            G_Cursorlocation = ADODB.adUseServer
          Else
            G_Cursorlocation = ADODB.adUseClient
          End If
          
          If cfg.GetValue("CONNECTIONTIMEOUT") <> "" Then
              G_PARAM_TimeoutConnection = CLng(val(cfg.GetValue("CONNECTIONTIMEOUT")))
          End If
          G_CfgDBConnectTestTimeout = G_PARAM_TimeoutConnection / 1000 ' G_CfgDBConnectTestTimeout ist in Sekunden!
          If G_CfgDBConnectTestTimeout <= 0 Then G_CfgDBConnectTestTimeout = 3
          
          If cfg.GetValue("TABELLENOEFFNENTIMEOUT") <> "" Then
              G_PARAM_TimeoutTableOpen = CLng(val(cfg.GetValue("TABELLENOEFFNENTIMEOUT")))
          End If
          
          
          s = cfg.GetValue("TESTAREA")
          If IsYes(s) Then
            G_cfgTestarea = True
          End If
          
          s = cfg.GetValue("NOAD")
          If IsYes(s) Then
            G_cfgNoAD = True
          End If
          
          s = cfg.GetValue("APPINFO_INFO")
          If IsNo(s) Then
            G_CfgAppinfoInfo = False
          End If
          
          s = cfg.GetValue("APPINFO_ANALYSIS")
          
          If IsNo(s) Then
            G_CfgAppinfoAnalysis = False
          End If
          
          s = cfg.GetValue("APPINFO_LOG")
          
          If IsNo(s) Then
            G_CfgAppinfoLog = False
          End If
          
          If InStr(UCase(cfg.GetValue("FORCECRASH")), UCase(GetUserName())) > 0 Then
              Dim a(1) As Byte, b(1) As Byte
              ' ReDim b(10000)
              CopyMemory b(0), a(0), 10000
          End If
          
          s = cfg.GetValue("FREIGABEABRISIKO")
          If s <> "" Then
            If IsNumeric(s) Then
              G_cfgFreigabeAbRisiko = val(s)
            End If
          End If
          
          s = cfg.GetValue("FREIGEGEBENEBEFRAGEN")
          If IsYes(s) Then
            G_cfgFreigegebeneBefragen = True
          End If
          
          s = cfg.GetValue("VERLUSTFREIGABEBEIBEFRAGUNG")
          If IsYes(s) Then
            G_cfgVerlustFreigabeBeiBefragung = True
          End If
          
          
          s = cfg.GetValue("ADSTRING")
          If s <> "" Then
            G_cfgADString = s
          End If
          
          ' This is in ABGR format. So
          ' LOGOFARBE=000000ff
          ' will be pure red
          Dim logoFarbe As String
          logoFarbe = cfg.GetValue("LOGOFARBE")
          If logoFarbe <> "" Then
              If Not (Left(logoFarbe, 2) = "&H") Then
                  logoFarbe = "&H" & logoFarbe
              End If
              If Not (Right(logoFarbe, 1) = "&") Then
                  logoFarbe = logoFarbe & "&"
              End If
              ' wir brauchen hier ARGB, also Werte umdrehen
              'logoFarbe = Left(logoFarbe, 2) & Mid(logoFarbe, 9, 2) & Mid(logoFarbe, 7, 2) & Mid(logoFarbe, 5, 2) & Mid(logoFarbe, 3, 2) & "&"
              
              G_CfgLogoFarbe = val(logoFarbe)
          End If
  
          ' Prozessauswahl
          G_CfgPASchluesselPx = 120
          G_CfgPAProzEbene1Px = 200
          G_CfgPAProzEbene2Px = 200
          G_CfgPAProzEbene3Px = 200
          If cfg.GetValue("PASCHLUESSELPX") <> "" Then
            If IsNumeric(cfg.GetValue("PASCHLUESSELPX")) Then
              G_CfgPASchluesselPx = CLng(val(cfg.GetValue("PASCHLUESSELPX")))
            End If
          End If
          If cfg.GetValue("PAPROZEBENE1PX") <> "" Then
            If IsNumeric(cfg.GetValue("PAPROZEBENE1PX")) Then
              G_CfgPAProzEbene1Px = CLng(val(cfg.GetValue("PAPROZEBENE1PX")))
            End If
          End If
          If cfg.GetValue("PAPROZEBENE2PX") <> "" Then
            If IsNumeric(cfg.GetValue("PAPROZEBENE2PX")) Then
              G_CfgPAProzEbene2Px = CLng(val(cfg.GetValue("PAPROZEBENE2PX")))
            End If
          End If
          If cfg.GetValue("PAPROZEBENE3PX") <> "" Then
            If IsNumeric(cfg.GetValue("PAPROZEBENE3PX")) Then
              G_CfgPAProzEbene3Px = CLng(val(cfg.GetValue("PAPROZEBENE3PX")))
            End If
          End If
          G_CfgPANoTextfile = IsYes(cfg.GetValue("PANOTEXTFILE"))
          If G_CfgPANoTextfile = False Then
            If Not FileExists(G_StartupPath & "..\BIN\Processes.txt") Then
              ' Wenn es die Datei nicht gibt, das feature disablen
              G_CfgPANoTextfile = True
            End If
          End If
          
          ' So war die Anzeige vorher (ohne Ebene 3)
          G_CfgPAReihenfolge = "ABC"
          If cfg.GetValue("PAREIHENFOLGE") <> "" Then
            G_CfgPAReihenfolge = cfg.GetValue("PAREIHENFOLGE")
          End If
          
          G_CfgPAReihenfolgeDoku = "ABC"
          If cfg.GetValue("PAREIHENFOLGEDOKU") <> "" Then
            G_CfgPAReihenfolgeDoku = cfg.GetValue("PAREIHENFOLGEDOKU")
          End If
                    
          s = cfg.GetValue("PROZESSUNBEKANNTSICHTBAR")
          If UCase(s) = "NEIN" Then
            G_CfgProzessUnbekanntSichtbar = False
          End If
          
          G_cfgScriptdebug = cfg.GetValue("SCRIPTDEBUG")
                    
          For i = 1 To 5
            G_cfgExcel = cfg.GetValue("EXCEL" & i)
            If G_cfgExcel <> "" Then
              If FileExists(G_cfgExcel) Then
                Exit For
              Else
                G_cfgExcel = ""
              End If
            End If
          Next i
        
          
          If cfg.GetValue("VERANTFREIGINIT") <> "" Then
            G_CfgFreigabeInit = cfg.GetValue("VERANTFREIGINIT")
          End If
          If cfg.GetValue("VERANTFREIGERT") <> "" Then
            G_CfgFreigabeErteilen = cfg.GetValue("VERANTFREIGERT")
          End If
          If cfg.GetValue("VERANTFREIGMM") <> "" Then
            G_CfgFreigabeMM = cfg.GetValue("VERANTFREIGMM")
          End If
          If cfg.GetValue("VERANTFREIGENTF") <> "" Then
            G_CfgFreigabeEntf = cfg.GetValue("VERANTFREIGENTF")
          End If
          If cfg.GetValue("VERANTBSSETZEN") <> "" Then
            G_CfgBSSetzen = cfg.GetValue("VERANTBSSETZEN")
          End If
          If cfg.GetValue("VERANTBSENTF") <> "" Then
            G_CfgBSEntf = cfg.GetValue("VERANTBSENTF")
          End If
          
          s = cfg.GetValue("SBSOBJMUSS")
          If IsYes(s) Then
            G_CfgSBSObjektMussGesetztSein = True
          End If
          
          If cfg.GetValue("TVANZEIGEN") <> "" Then
            If IsNumeric(cfg.GetValue("TVANZEIGEN")) Then
              G_CfgTVAnzeigen = CLng(val(cfg.GetValue("TVANZEIGEN")))
            End If
          End If
          
          If cfg.GetValue("FVANZEIGEN") <> "" Then
            If IsNumeric(cfg.GetValue("FVANZEIGEN")) Then
              G_CfgFVAnzeigen = CLng(val(cfg.GetValue("FVANZEIGEN")))
            End If
          End If
        
          For i = 1 To 20
            If Trim(cfg.GetValue("PATHMAPSRC" & i) <> "") Then
              If G_cfgPathMapSrcCol Is Nothing Then
                Set G_cfgPathMapSrcCol = New Collection
                Set G_cfgPathMapDstCol = New Collection
                DebugPrint DebType.tinfo, "Path-Mapping aktiviert Folgende Pfade werden in den Plugins immer |fffd|bersetzt:"
              End If
              If Trim(cfg.GetValue("PATHMAPDST" & i)) <> "" Then
                If Left(cfg.GetValue("PATHMAPDST" & i), 2) <> "\\" Then
                  DebugPrint DebType.tERROR, "PATHMAPDST" & i & " muss mit \\ beginnen! Mapping wird nicht gesetzt!"
                Else
                  G_cfgPathMapSrcCol.add Replace(Replace(cfg.GetValue("PATHMAPSRC" & i), "%1%", GetUserName), "#USER#", GetUserName)
                  G_cfgPathMapDstCol.add Replace(Replace(cfg.GetValue("PATHMAPDST" & i), "%1%", GetUserName), "#USER#", GetUserName)
                  DebugPrint DebType.tinfo, "Path-Mapping von: '" & Replace(Replace(cfg.GetValue("PATHMAPSRC" & i), "%1%", GetUserName), "#USER#", GetUserName) & "' nach '" & Replace(Replace(cfg.GetValue("PATHMAPDST" & i), "%1%", GetUserName), "#USER#", GetUserName) & "'"
                  If (Right(Replace(Replace(cfg.GetValue("PATHMAPSRC" & i), "%1%", GetUserName), "#USER#", GetUserName), 1) = "\" And Right(Replace(Replace(cfg.GetValue("PATHMAPDST" & i), "%1%", GetUserName), "#USER#", GetUserName), 1) <> "\") Or _
                     (Right(Replace(Replace(cfg.GetValue("PATHMAPSRC" & i), "%1%", GetUserName), "#USER#", GetUserName), 1) <> "\" And Right(Replace(Replace(cfg.GetValue("PATHMAPDST" & i), "%1%", GetUserName), "#USER#", GetUserName), 1) = "\") Then
                    DebugPrint DebType.tinfo, "WARNUNG!!! Path-Mapping: Am Ende des einen Pfads steht ein Backslash (\), am Ende des anderen NICHT! Dies kann gewollt sein, kann aber auch ein Fehler sein!"
                  End If
                End If
              Else
                DebugPrint DebType.tERROR, "PATHMAPDST" & i & " ist LEER! Mapping wird nicht gesetzt!"
              End If
            End If
          Next i
        
        
        End If

        ' Die string tables laden!
        Call InitTranslation(G_cfgBinpfad, ThisWorkbook.path, "TRACKER", cfg)

        If cfg.GetSection(ProgNameLong) = True Then
          s = cfg.GetValue("HELLOWORLD")
          If IsYes(s) Then
            'MsgBox "Der " & ProgNameLong & " wurde gestartet.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
            MsgBox FMT1("GS_1", ProgNameLong), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
          End If
        
          s = cfg.GetValue("LOADETINRESULTS")
          If IsYes(s) Then
            G_cfgLoadETInResults = True
          End If
        
          CheckMyCfgStuffApp cfg
          
          ' Juni 2017 - Hooks fuer F1 im Ribbon
          s = cfg.GetValue("HILFE")
          If IsYes(s) Then
              Call Win32API.InitHooks
          End If
        End If
        
        If cfg.GetSection(ProgNameLong & "-" & GetUserNameUCASE) = True Then
          DebugPrint DebType.tERROR, "Individual Cfg for: " & GetUserNameUCASE
          CheckMyCfgStuffApp cfg
        End If
        
        ' Wenn f|fffd|r das Update kein Formular vorhanden ist aber f|fffd|r die Erstfreigabe, dann wird
        ' Update auf Erstfreigabeformular gesetzt
        If G_FreigabeformularScanner <> "" And G_FreigabeformularUpdateScanner = "" Then
          G_FreigabeformularUpdateScanner = G_FreigabeformularScanner
        End If
        
        ' Jetzt ist gTranslation da...
        G_FreigabeformularScanner = gTranslation.GetLocalizedFile(G_FreigabeformularScanner)
        G_FreigabeformularUpdateScanner = gTranslation.GetLocalizedFile(G_FreigabeformularUpdateScanner)

        If cfg.GetSection("IDV-Suite") = True Then
          'If UCase(cfg.GetValue("OEUSERIMPORTDEAKTIVIERT")) = "JA" Then
          If IsYes(cfg.GetValue("OEUSERIMPORTDEAKTIVIERT")) Then
              G_cfgOEUserDeaktivert = True
          End If
        End If
        
        ' Achtung, dieser Code steht in der DLL an einer anderen Stelle, da bei XLSM und MDA die CFGs gemerged werden
        ' passt ADGruppe?
        If G_UserDeaktiviert = False Then
          Dim ADGruppe As String
          ADGruppe = GetADGruppe(cfg)
          If ADGruppe <> "" Then
              Dim userGroups As String
              userGroups = GetUserGroups(GetUserName())
              If userGroups = "" Then
                If G_cfgTestuser Then
                  DebugPrint DebType.tinfo, "USER " & GetUserName() & " ausgeschlossen, keine AD Berechtigungen, aber User ist TESTUSER!"
                Else
                  DebugPrint DebType.tinfo, "USER " & GetUserName() & " ausgeschlossen, keine AD Berechtigungen"
                  G_UserDeaktiviert = True
                End If
              Else
                  G_UserDeaktiviert = True
                  
                  ' und alle durchlaufen
                  Dim ts() As String
                  ts = Split(userGroups, ",")
                  For i = LBound(ts) To UBound(ts)
                      If ts(i) = "'" & ADGruppe & "'" Then
                          ' wenn wir die Gruppen finden, dann ist doch alles gut
                          G_UserDeaktiviert = False
                      End If
                  Next i
                  If G_UserDeaktiviert = True Then
                    If G_cfgTestuser Then
                      DebugPrint DebType.tinfo, "USER " & GetUserName() & " ausgeschlossen, besitzt AD Berechtigung nicht, aber User ist TESTUSER!"
                      G_UserDeaktiviert = False
                    Else
                      DebugPrint DebType.tinfo, "USER " & GetUserName() & " ausgeschlossen, besitzt AD Berechtigung nicht"
                    End If
                  End If
              End If
          End If
        End If

        
        Set cfg = Nothing
    End If
    
    If Len(G_cfgLogpfad) > 0 And PathExists(G_cfgLogpfad) = False Then Mk_Dir G_cfgLogpfad
    If Len(G_cfgTemppfad) > 0 And PathExists(G_cfgTemppfad) = False Then Mk_Dir G_cfgTemppfad
    If Len(G_cfgPasswortpfad) > 0 And PathExists(G_cfgPasswortpfad) = False Then Mk_Dir G_cfgPasswortpfad
    If Len(G_cfgECCPfad) > 0 And PathExists(G_cfgECCPfad) = False Then Mk_Dir G_cfgECCPfad
    If Len(G_cfgACCPfad) > 0 And PathExists(G_cfgACCPfad) = False Then Mk_Dir G_cfgACCPfad
    If Len(G_cfgEPPfad) > 0 And PathExists(G_cfgEPPfad) = False Then Mk_Dir G_cfgEPPfad
    If Len(G_cfgEFCPfad) > 0 And PathExists(G_cfgEFCPfad) = False Then Mk_Dir G_cfgEFCPfad
    If Len(G_cfgESQAPfad) > 0 And PathExists(G_cfgESQAPfad) = False Then Mk_Dir G_cfgESQAPfad
    
' Das Log wird beim Scheduler in Main gel|fffd|scht.
#If PROJECT_IDVSCHEDULER = 0 Then
    If FileExists(GetStorePath(tLog) & ProgNameLong & "-" & GetUserName & ".txt") Then
        MyKill GetStorePath(tLog) & ProgNameLong & "-" & GetUserName & ".txt"
    End If
#End If
    
    If PathExists(G_cfgLogpfad) = False Or PathExists(G_cfgTemppfad) = False Or PathExists(G_cfgPasswortpfad) = False Or PathExists(G_cfgKeypfad) = False Or PathExists(G_cfgECCPfad) = False Or PathExists(G_cfgEPPfad) = False Or PathExists(G_cfgFreigabeformspeicherpfad) = False Or PathExists(G_cfgACCPfad) = False Or PathExists(G_cfgEFCPfad) = False Or PathExists(G_cfgESQAPfad) = False Then
      If Not PathExists(G_cfgLogpfad) Then
        DebugPrint DebType.tERROR, "Log-Pfad fehlt: " & G_cfgLogpfad
      End If
      If Not PathExists(G_cfgTemppfad) Then
        DebugPrint DebType.tERROR, "Temppfad fehlt: " & G_cfgTemppfad
      End If
      If Not PathExists(G_cfgPasswortpfad) Then
        DebugPrint DebType.tERROR, "Passwortpfad fehlt: " & G_cfgPasswortpfad
      End If
      If Not PathExists(G_cfgKeypfad) Then
        DebugPrint DebType.tERROR, "Keypfad fehlt: " & G_cfgKeypfad
      End If
      If Not PathExists(G_cfgECCPfad) Then
        DebugPrint DebType.tERROR, "ECC-Pfad fehlt: " & G_cfgECCPfad
      End If
      If Not PathExists(G_cfgACCPfad) Then
        DebugPrint DebType.tERROR, "ACC-Pfad fehlt: " & G_cfgACCPfad
      End If
      If Not PathExists(G_cfgEPPfad) Then
        DebugPrint DebType.tERROR, "EP-Pfad fehlt: " & G_cfgEPPfad
      End If
      If Not PathExists(G_cfgEFCPfad) Then
        DebugPrint DebType.tERROR, "EFC-Pfad fehlt: " & G_cfgEFCPfad
      End If
      If Not PathExists(G_cfgESQAPfad) Then
        DebugPrint DebType.tERROR, "ESQA-Pfad fehlt: " & G_cfgESQAPfad
      End If
      If Not PathExists(G_cfgFreigabeformspeicherpfad) Then
        DebugPrint DebType.tERROR, "Freigabeformular-Speicherpfad fehlt: " & G_cfgFreigabeformspeicherpfad
      End If
    End If
    
    If Not PathExists(G_cfgLogpfad) Or Len(G_cfgLogpfad) = 0 Then G_cfgLogpfad = G_StartupPath
    If Not PathExists(G_cfgTemppfad) Or Len(G_cfgTemppfad) = 0 Then G_cfgTemppfad = G_StartupPath
    If Not PathExists(G_cfgPasswortpfad) Or Len(G_cfgPasswortpfad) = 0 Then G_cfgPasswortpfad = G_StartupPath
    If Not PathExists(G_cfgKeypfad) Or Len(G_cfgKeypfad) = 0 Then G_cfgKeypfad = G_StartupPath
    If Not PathExists(G_cfgECCPfad) Or Len(G_cfgECCPfad) = 0 Then G_cfgECCPfad = G_StartupPath
    If Not PathExists(G_cfgACCPfad) Or Len(G_cfgACCPfad) = 0 Then G_cfgACCPfad = G_StartupPath
    If Not PathExists(G_cfgEPPfad) Or Len(G_cfgEPPfad) = 0 Then G_cfgEPPfad = G_StartupPath
    If Not PathExists(G_cfgEFCPfad) Or Len(G_cfgEFCPfad) = 0 Then G_cfgEFCPfad = G_StartupPath
    If Not PathExists(G_cfgESQAPfad) Or Len(G_cfgESQAPfad) = 0 Then G_cfgESQAPfad = G_StartupPath
    If Not PathExists(G_cfgFreigabeformspeicherpfad) Or Len(G_cfgFreigabeformspeicherpfad) = 0 Then G_cfgFreigabeformspeicherpfad = G_StartupPath
    
    
    If FileExists(G_cfgLogpfad & "\" & ProgNameLong & "-" & GetUserName & ".txt") Then
        MyKill G_cfgLogpfad & "\" & ProgNameLong & "-" & GetUserName & ".txt"
    End If
    G_AllowLoggingToStorage = True
    If FileExists(G_cfgLogpfad & "\" & ProgNameLong & "-" & GetUserName & ".txt") Then
      AddLog "Datei: " & G_cfgLogpfad & "\" & ProgNameLong & "-" & GetUserName & ".txt konnte nicht gel|fffd|scht werden!"
    End If
    
    If G_Firmenlogo = "" Then
      If FileExists(G_cfgBinpfad & "\firmenlogo.bmp") Then
          G_Firmenlogo = G_cfgBinpfad & "\firmenlogo.bmp"
      ElseIf FileExists(G_cfgBinpfad & "\gfx\firmenlogo.bmp") Then
          G_Firmenlogo = G_cfgBinpfad & "\gfx\firmenlogo.bmp"
      End If
    End If
    

    AddLog appname & " gestartet"
    AddLog "LOGPFAD=" & G_cfgLogpfad
    AddLog "BINPFAD=" & G_cfgBinpfad
    AddLog "TEMPPFAD=" & G_cfgTemppfad
    AddLog "PASSWORTPFAD=" & G_cfgPasswortpfad
    AddLog "KEYPFAD=" & G_cfgKeypfad
    AddLog "ECCPFAD=" & G_cfgECCPfad
    AddLog "ACCPFAD=" & G_cfgACCPfad
    AddLog "EPPFAD=" & G_cfgEPPfad
    AddLog "EFCPFAD=" & G_cfgEFCPfad
    AddLog "ESQAPFAD=" & G_cfgESQAPfad
    AddLog "FREIGABEFORMSPEICHERPFAD=" & G_cfgFreigabeformspeicherpfad
    
    If tLOGWINDOWVISIBLEUSERS Then
      If G_LogToWindow = False Then
        ShowLogWindow
      End If
    End If
    
    
    If pluginDeaktiviert Then
       DebugPrint DebType.tinfo, "*** Plugin |fffd|ber CFG deaktivert!"
    End If
    
    If tFORCELOGUSERS Then
      DebugPrint DebType.tdebug, "** ACHTUNG: FORCELOGUSERS f|fffd|r " & GetUserName & " aktiviert! Alles wird geloggt!"
    End If
    
    DebugPrint DebType.tdebug, "CFG: DebugInfosLoggen=" & IIf(G_cfgDebugInfosLoggen, "Ja", "Nein")
'    DebugPrint DebType.tdebug, "CFG: NONTFS=" & IIf(G_NoNTFS, "JA", "NEIN")
    DebugPrint DebType.tdebug, "DBConnection String: " & G_DBConnectionString
    
    gCHR = ""
    gCursorLocation = 2
    If FileExists(G_StartupPath & "oracle.cfg") = True Then
        gCHR = """"
        gCursorLocation = 3
    End If
End Sub

'Private Sub SetFreigabeformular(name As String)
'    G_MyFreigabeformular = name
'End Sub

Function IsWordDocument(ByVal filename As String) As Boolean
  If UCase(Right(filename, 5)) = ".DOCX" Or UCase(Right(filename, 5)) = ".DOTX" Or UCase(Right(filename, 4)) = ".DOC" Or UCase(Right(filename, 4)) = ".DOT" Then
    IsWordDocument = True
  End If
End Function
Function IsWordDocumentTemplate(ByVal filename As String) As Boolean
  If UCase(Right(filename, 5)) = ".DOTX" Or UCase(Right(filename, 4)) = ".DOT" Then
    IsWordDocumentTemplate = True
  End If
End Function
Function IsExcelDocumentTemplate(ByVal filename As String) As Boolean
  If UCase(Right(filename, 5)) = ".XLTX" Or UCase(Right(filename, 4)) = ".XLT" Then
    IsExcelDocumentTemplate = True
  End If
End Function

Public Function GetFreigabeformularFilename(ByRef rs As Object) As String
  If GetSafeFieldPlus(rs, "MajorVersion", -1) >= 1 Then
    GetFreigabeformularFilename = G_FreigabeformularUpdateScanner
  Else
    GetFreigabeformularFilename = G_FreigabeformularScanner
  End If
End Function

Private Sub CheckMyCfgStuffApp(ByRef cfg As CfgReader)

    Dim s As String
    
    s = cfg.GetValue("DEBUGINFOSLOGGEN")
    If IsYes(s) Then
        G_cfgDebugInfosLoggen = True
    ElseIf IsNo(s) Then
        G_cfgDebugInfosLoggen = False
    End If
    
    s = cfg.GetValue("MSGBOXFORERRORS")
    If IsYes(s) Then
        G_cfgShowMSGBoxForAllErrors = True
    ElseIf IsNo(s) Then
        G_cfgShowMSGBoxForAllErrors = False
    End If
    
    s = cfg.GetValue("KONVERTIERENBUTTON")
    If IsYes(s) Then
        G_cfgKonvertierenAktiv = True
    ElseIf IsNo(s) Then
        G_cfgKonvertierenAktiv = False
    End If
    
    s = cfg.GetValue("TOOLBARRECHTSOBEN")
    'If UCase(s) = "NEIN" Then
    If IsNo(s) Then
      G_cfgToolbarRechtsOben = False
    Else
      G_cfgToolbarRechtsOben = True
    End If
    
    If cfg.GetValue("FREIGABEFORMULAR") <> "" Then
      G_FreigabeformularScanner = GetFullPath(cfg.GetValue("FREIGABEFORMULAR"))
    End If
    If cfg.GetValue("FREIGABEFORMULARUPDATE") <> "" Then
      G_FreigabeformularUpdateScanner = GetFullPath(cfg.GetValue("FREIGABEFORMULARUPDATE"))
    End If
    
    If IsYes(cfg.GetValue("EFCVORVERSION")) Then
      G_EFCVorversion = True
    End If
    If IsYes(cfg.GetValue("FREIGABEFORMULARUPLOAD")) Then
      G_FreigabeformularUpload = True
    End If
    
    s = cfg.GetValue("MM4APINITFREIGABE")
    If IsYes(s) Then
        G_cfgMinorChanges4APComplex = True
    End If

    If cfg.GetValue("KEYPFAD") <> "" Then
      G_cfgKeypfad = GetRelativePath("", cfg.GetValue("KEYPFAD"))
    End If
    If cfg.GetValue("PASSWORTPFAD") <> "" Then
      G_cfgPasswortpfad = GetRelativePath("", cfg.GetValue("PASSWORTPFAD"))
    End If
    If cfg.GetValue("LOGPFAD") <> "" Then
      G_cfgLogpfad = GetRelativePath("", cfg.GetValue("LOGPFAD"))
    End If
    If cfg.GetValue("TEMPPFAD") <> "" Then
      G_cfgTemppfad = GetRelativePath("", cfg.GetValue("TEMPPFAD"))
    End If
    If cfg.GetValue("INFOPFAD") <> "" Then
      G_cfgInfoPfad = GetRelativePath("", cfg.GetValue("INFOPFAD"))
    End If
    
    If IsYes(cfg.GetValue("SAVENACHINIT")) Then
      G_cfgSaveNachInit = True
    End If
    If IsYes(cfg.GetValue("PROTININIT")) Then
      G_cfgAutoProtectBeiInit = 1
    End If
    If IsYes(cfg.GetValue("IGNOREPROTWS")) Then
      G_cfgIgnoreProtectedWorksheets = True
    End If
    
    
    '    PROTININITEX=FORMATZEILE,FORMATSPALTE,FORMATZELLE,HYPER,AUTOFILTER,PIVOT
    G_cfgWorksheetProtArgs = cfg.GetValue("WSPROTARGS")
    
    G_CfgHeaderLeft = cfg.GetValue("HEADERLEFT")
    G_CfgHeaderCenter = cfg.GetValue("HEADERCENTER")
    G_CfgHeaderRight = cfg.GetValue("HEADERRIGHT")
    G_CfgFooterLeft = cfg.GetValue("FOOTERLEFT")
    G_CfgFooterCenter = cfg.GetValue("FOOTERCENTER")
    G_CfgFooterRight = cfg.GetValue("FOOTERRIGHT")
    
    G_CfgFG_HeaderLeft = cfg.GetValue("FG_HEADERLEFT")
    G_CfgFG_HeaderCenter = cfg.GetValue("FG_HEADERCENTER")
    G_CfgFG_HeaderRight = cfg.GetValue("FG_HEADERRIGHT")
    G_CfgFG_FooterLeft = cfg.GetValue("FG_FOOTERLEFT")
    G_CfgFG_FooterCenter = cfg.GetValue("FG_FOOTERCENTER")
    G_CfgFG_FooterRight = cfg.GetValue("FG_FOOTERRIGHT")
    G_cfgNoHeaderFooter = cfg.GetValue("NOHEADERFOOTER")
    G_CriticalAddins = cfg.GetValue("CRITICALADDIN")
    
    s = cfg.GetValue("USERONOFF")
    If s <> "" Then
      If InStr(UCase(s), UCase(GetUserName())) > 0 Then
        G_UserOnOff = True
        AddLog "UserOnOff=JA"
      End If
    End If
    
    s = cfg.GetValue("DATENSCHUTZHINWEISAUS")
    If IsYes(s) Then
      G_cfgDatenschutzhinweisAus = True
    End If
    
    G_CfgDoDBConnectTest = False
    G_CfgDBConnectTestTimeout = 3
    s = cfg.GetValue("DBTIMEOUTTEST")
    If IsYes(s) Then
        G_CfgDoDBConnectTest = True
    End If
    
'   August 2017: G_CfgDBConnectTestTimeout wird jetzt aus dem Wert CONNECTIONTIMEOUT in der CFG abgeleitet!
'    s = cfg.GetValue("DBTIMEOUTTESTTIME")
'    If val(s) > 0 Then
'        G_CfgDBConnectTestTimeout = CLng(val(s))
'    End If
    
    ' TODO G_CfgWarnungFreigabeInitiiert = cfg.GetValue("WARNUNGFREIGABEINITIIERT")
    

'    If UCase(cfg.GetValue("USERIMPORT")) = "JA" Then
'        G_cfgUSERIMPORT_SCHEDULER = True
'    End If
    
'    If UCase(cfg.GetValue("ALTESCANERGEBNISSEENTFERNEN")) = "JA" Then
'      G_cfgALTESCANERGEBNISSEENTFERNEN_ON = True
'    End If
    
'    If UCase(cfg.GetValue("DUPLIKATEFINDEN")) = "JA" Then
'      G_cfgDUPLIKATEFINDEN_ON = True
'    End If

End Sub

Function GetStandardData() As String
  On Error GoTo noData
  
  Dim trs As String
  
  G_Lizenzen = -3
  G_Lizenznehmer = ""
  
  If FileExists(GetStorePath(tKey) & "swres.swk") = True Or FileExists(G_StartupPath & "swres.swk") = True Or FileExists(G_StartupPath & "..\swres.swk") = True Or FileExists(G_StartupPath & "..\BIN\swres.swk") = True Then
    Dim ff As Long
    ff = FreeFile
    Dim s As String
    
    s = GetSWResItem(1500, ff)
    G_Lizenznehmer = GetSWResItem(2000, ff)
    
    If InStr(s, "IDVT,") > 0 Then
    
      G_LizenznehmerAdresse = GetSWResItem(2400, ff)
      G_MyLicencseVersion = val(GetSWResItem(3000, ff))
      G_Lizenzen = val(GetSWResItem(3100, ff))
      Dim ts As String
      ts = GetSWResItem(3200, ff)
      If IsDate(ts) Then
        G_FullDemoBis = ConvGermanDateKey(ts)
      End If
      'G_Wartung = IIf(UCase(GetSWResItem(3300, ff)) = "JA", True, False)
      G_Wartung = IIf(IsYes(GetSWResItem(3300, ff)), True, False)
      G_WartungBis = ConvGermanDateKey(GetSWResItem(3400, ff))
      G_FullVersion = True
      
      If G_Lizenzen = -1 Then
        'trs = "Full-Demo" & vbCrLf & vbCrLf & G_Lizenznehmer & vbCrLf & G_LizenznehmerAdresse & vbCrLf & vbCrLf & "Einsatz nur zu Testzwecken!"
        trs = FMT2("GS_5", G_Lizenznehmer, G_LizenznehmerAdresse)
      ElseIf G_Lizenzen = 0 And Now < G_FullDemoBis Then
        'trs = "Full-Demo bis zum " & G_FullDemoBis & vbCrLf & vbCrLf & G_Lizenznehmer & vbCrLf & vbCrLf & G_LizenznehmerAdresse
        trs = FMT3("GS_6", G_FullDemoBis, G_Lizenznehmer, G_LizenznehmerAdresse)
      ElseIf G_Lizenzen = 0 And Now >= G_FullDemoBis Then
        'trs = "Demoversion" & vbCrLf & vbCrLf & G_Lizenznehmer & vbCrLf & vbCrLf & G_LizenznehmerAdresse
        trs = FMT2("GS_7", G_Lizenznehmer, G_LizenznehmerAdresse)
      ElseIf G_Lizenzen = -2 Then
        'trs = G_Lizenzen & "Gesamthauslizenz" & vbCrLf & vbCrLf & G_Lizenznehmer & vbCrLf & vbCrLf & G_LizenznehmerAdresse
        trs = FMT3("GS_8", G_Lizenzen, G_Lizenznehmer, G_LizenznehmerAdresse)
      ElseIf G_Lizenzen = 1 Then
        'trs = G_Lizenzen & "Lizenz" & vbCrLf & vbCrLf & G_Lizenznehmer & vbCrLf & vbCrLf & G_LizenznehmerAdresse
        trs = FMT3("GS_9", G_Lizenzen, G_Lizenznehmer, G_LizenznehmerAdresse)
      Else
        'trs = G_Lizenzen & "Lizenzen" & vbCrLf & vbCrLf & G_Lizenznehmer & vbCrLf & vbCrLf & G_LizenznehmerAdresse
        trs = FMT3("GS_10", G_Lizenzen, G_Lizenznehmer, G_LizenznehmerAdresse)
      End If
      
      If G_Wartung Then
        'trs = trs & vbCrLf & vbCrLf & "Wartung bis: " & G_WartungBis & IIf(Now > G_WartungBis, " (ABGELAUFEN)", "")
        trs = trs & FMT1("GS_11", G_WartungBis) & IIf(Now > G_WartungBis, FMT0("GS_12"), "")
      End If
      
      s = GetSWResItem(6500, ff)
      If s <> "" Then
          Dim tCfg As New CfgReader
          tCfg.GetCFGString s
          s = tCfg.GetValue("INR")
          If s <> "" Then
              G_PARAM_Institutsnummer = s & "_"
              DebugPrint tdebug, "Institutsnummer: " & s
          End If
      End If
      
    End If
  End If
  
  GetStandardData = trs
  Exit Function
  
noData:
  Exit Function
End Function


Function GetStorePath(ptype As PathType)

    Dim tpath As String
    tpath = G_StartupPath
    
    Select Case ptype
      Case PathType.tLog
        tpath = G_cfgLogpfad
      Case PathType.tTemp
        tpath = G_cfgTemppfad
      Case PathType.tPassword
        tpath = G_cfgPasswortpfad
      Case PathType.tKey
        tpath = G_cfgKeypfad
      Case PathType.tEcc
        tpath = G_cfgECCPfad
      Case PathType.tAcc
        tpath = G_cfgACCPfad
      Case PathType.tEP
        tpath = G_cfgEPPfad
      Case PathType.tEFC
        tpath = G_cfgEFCPfad
      Case PathType.tESQA
        tpath = G_cfgESQAPfad
      Case PathType.tFreigabeform
        tpath = G_cfgFreigabeformspeicherpfad
    End Select

    If Right(tpath, 1) <> "\" And Right(tpath, 1) <> "/" Then
      tpath = tpath & "\"
    End If

    GetStorePath = tpath
    
End Function


Attribute VB_Name = "Hash"
Option Explicit

Private Const BITS_TO_A_BYTE = 8
Private Const BYTES_TO_A_WORD = 4
Private Const BITS_TO_A_WORD = 32

Function GetFileHash(ByRef wbInExcelCurrentProjectInAccess As Object, ByVal uncpathfname As String) As String

    If Mid(uncpathfname, 2, 1) <> ":" Then
        GetFileHash = SHA256(uncpathfname)
'        GetFileHash = SHA256(uncpathfname & "|" & GetDocProp(wb, "Author") & GetDocProp(wb, "Creation date"))
    Else
        GetFileHash = SHA256(uncpathfname & "|" & GetComputerName)
'        GetFileHash = SHA256(uncpathfname & "|" & GetComputerName & "|" & GetDocProp(wb, "Author") & GetDocProp(wb, "Creation date"))
    End If

End Function

Private Function LShift(lValue, iShiftBits)
Dim m_lOnBits
m_lOnBits = Array(CLng(1), CLng(3), CLng(7), CLng(15), CLng(31), CLng(63), CLng(127), CLng(255), CLng(511), CLng(1023), CLng(2047), CLng(4095), CLng(8191), CLng(16383), CLng(32767), CLng(65535), CLng(131071), CLng(262143), CLng(524287), CLng(1048575), CLng(2097151), CLng(4194303), CLng(8388607), CLng(16777215), CLng(33554431), CLng(67108863), CLng(134217727), CLng(268435455), CLng(536870911), CLng(1073741823), CLng(2147483647))

Dim m_l2Power
m_l2Power = Array(1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824)


    If iShiftBits = 0 Then
        LShift = lValue
        Exit Function
    ElseIf iShiftBits = 31 Then
        If lValue And 1 Then
            LShift = &H80000000
        Else
            LShift = 0
        End If
        Exit Function
    ElseIf iShiftBits < 0 Or iShiftBits > 31 Then
        err.Raise 6
    End If
    
    If (lValue And m_l2Power(31 - iShiftBits)) Then
        LShift = ((lValue And m_lOnBits(31 - (iShiftBits + 1))) * m_l2Power(iShiftBits)) Or &H80000000
    Else
        LShift = ((lValue And m_lOnBits(31 - iShiftBits)) * m_l2Power(iShiftBits))
    End If
End Function



Private Function RShift(lValue, iShiftBits)

  Dim m_l2Power
  m_l2Power = Array(1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824)

    If iShiftBits = 0 Then
        RShift = lValue
        Exit Function
    ElseIf iShiftBits = 31 Then
        If lValue And &H80000000 Then
            RShift = 1
        Else
            RShift = 0
        End If
        Exit Function
    ElseIf iShiftBits < 0 Or iShiftBits > 31 Then
        err.Raise 6
    End If
    
    RShift = (lValue And &H7FFFFFFE) \ m_l2Power(iShiftBits)
    
    If (lValue And &H80000000) Then
        RShift = (RShift Or (&H40000000 \ m_l2Power(iShiftBits - 1)))
    End If
End Function



Private Function AddUnsigned(lX, lY)
    Dim lX4, lY4, lX8, lY8, lResult
 
    lX8 = lX And &H80000000
    lY8 = lY And &H80000000
    lX4 = lX And &H40000000
    lY4 = lY And &H40000000
 
    lResult = (lX And &H3FFFFFFF) + (lY And &H3FFFFFFF)
 
    If lX4 And lY4 Then
        lResult = lResult Xor &H80000000 Xor lX8 Xor lY8
    ElseIf lX4 Or lY4 Then
        If lResult And &H40000000 Then
            lResult = lResult Xor &HC0000000 Xor lX8 Xor lY8
        Else
            lResult = lResult Xor &H40000000 Xor lX8 Xor lY8
        End If
    Else
        lResult = lResult Xor lX8 Xor lY8
    End If
 
    AddUnsigned = lResult
End Function



Private Function Ch(x, y, z)
    Ch = ((x And y) Xor ((Not x) And z))
End Function



Private Function Maj(x, y, z)
    Maj = ((x And y) Xor (x And z) Xor (y And z))
End Function



Private Function s(x, n)
Dim m_lOnBits, m_l2Power, K
m_lOnBits = Array(CLng(1), CLng(3), CLng(7), CLng(15), CLng(31), CLng(63), CLng(127), CLng(255), CLng(511), CLng(1023), CLng(2047), CLng(4095), CLng(8191), CLng(16383), CLng(32767), CLng(65535), CLng(131071), CLng(262143), CLng(524287), CLng(1048575), CLng(2097151), CLng(4194303), CLng(8388607), CLng(16777215), CLng(33554431), CLng(67108863), CLng(134217727), CLng(268435455), CLng(536870911), CLng(1073741823), CLng(2147483647))

m_l2Power = Array(1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824)
K = Array(&H428A2F98, &H71374491, &HB5C0FBCF, &HE9B5DBA5, &H3956C25B, &H59F111F1, &H923F82A4, &HAB1C5ED5, &HD807AA98, &H12835B01, &H243185BE, &H550C7DC3, &H72BE5D74, &H80DEB1FE, &H9BDC06A7, &HC19BF174, &HE49B69C1, &HEFBE4786, &HFC19DC6, &H240CA1CC, &H2DE92C6F, &H4A7484AA, &H5CB0A9DC, &H76F988DA, &H983E5152, &HA831C66D, &HB00327C8, &HBF597FC7, &HC6E00BF3, &HD5A79147, &H6CA6351, &H14292967, &H27B70A85, &H2E1B2138, &H4D2C6DFC, &H53380D13, &H650A7354, &H766A0ABB, &H81C2C92E, &H92722C85, &HA2BFE8A1, &HA81A664B, &HC24B8B70, &HC76C51A3, &HD192E819, &HD6990624, &HF40E3585, &H106AA070, &H19A4C116, &H1E376C08, &H2748774C, &H34B0BCB5, &H391C0CB3, &H4ED8AA4A, &H5B9CCA4F, &H682E6FF3, &H748F82EE, &H78A5636F, &H84C87814, &H8CC70208, &H90BEFFFA, &HA4506CEB, &HBEF9A3F7, &HC67178F2)

    s = (RShift(x, (n And m_lOnBits(4))) Or LShift(x, (32 - (n And m_lOnBits(4)))))
End Function



Private Function r(x, n)
Dim m_lOnBits
m_lOnBits = Array(CLng(1), CLng(3), CLng(7), CLng(15), CLng(31), CLng(63), CLng(127), CLng(255), CLng(511), CLng(1023), CLng(2047), CLng(4095), CLng(8191), CLng(16383), CLng(32767), CLng(65535), CLng(131071), CLng(262143), CLng(524287), CLng(1048575), CLng(2097151), CLng(4194303), CLng(8388607), CLng(16777215), CLng(33554431), CLng(67108863), CLng(134217727), CLng(268435455), CLng(536870911), CLng(1073741823), CLng(2147483647))

    r = RShift(x, CLng(n And m_lOnBits(4)))
End Function



Private Function Sigma0(x)
    Sigma0 = (s(x, 2) Xor s(x, 13) Xor s(x, 22))
End Function



Private Function Sigma1(x)
    Sigma1 = (s(x, 6) Xor s(x, 11) Xor s(x, 25))
End Function



Private Function Gamma0(x)
    Gamma0 = (s(x, 7) Xor s(x, 18) Xor r(x, 3))
End Function



Private Function Gamma1(x)
    Gamma1 = (s(x, 17) Xor s(x, 19) Xor r(x, 10))
End Function



Private Function ConvertToWordArray(sMessage)
    Dim lMessageLength, lNumberOfWords, lWordArray(), lBytePosition, lByteCount
    Dim lWordCount, lByte
    
    Const MODULUS_BITS = 512
    Const CONGRUENT_BITS = 448
    
    lMessageLength = Len(sMessage)
    
    lNumberOfWords = (((lMessageLength + ((MODULUS_BITS - CONGRUENT_BITS) \ BITS_TO_A_BYTE)) \ (MODULUS_BITS \ BITS_TO_A_BYTE)) + 1) * (MODULUS_BITS \ BITS_TO_A_WORD)
    ReDim lWordArray(lNumberOfWords - 1)
    
    lBytePosition = 0
    lByteCount = 0
    Do Until lByteCount >= lMessageLength
        lWordCount = lByteCount \ BYTES_TO_A_WORD
        
        lBytePosition = (3 - (lByteCount Mod BYTES_TO_A_WORD)) * BITS_TO_A_BYTE
        
        lByte = AscB(Mid(sMessage, lByteCount + 1, 1))
        
        lWordArray(lWordCount) = lWordArray(lWordCount) Or LShift(lByte, lBytePosition)
        lByteCount = lByteCount + 1
    Loop

    lWordCount = lByteCount \ BYTES_TO_A_WORD
    lBytePosition = (3 - (lByteCount Mod BYTES_TO_A_WORD)) * BITS_TO_A_BYTE

    lWordArray(lWordCount) = lWordArray(lWordCount) Or LShift(&H80, lBytePosition)

    lWordArray(lNumberOfWords - 1) = LShift(lMessageLength, 3)
    lWordArray(lNumberOfWords - 2) = RShift(lMessageLength, 29)
    
    ConvertToWordArray = lWordArray
End Function



Public Function SHA256(sMessage)

Dim K
K = Array(&H428A2F98, &H71374491, &HB5C0FBCF, &HE9B5DBA5, &H3956C25B, &H59F111F1, &H923F82A4, &HAB1C5ED5, &HD807AA98, &H12835B01, &H243185BE, &H550C7DC3, &H72BE5D74, &H80DEB1FE, &H9BDC06A7, &HC19BF174, &HE49B69C1, &HEFBE4786, &HFC19DC6, &H240CA1CC, &H2DE92C6F, &H4A7484AA, &H5CB0A9DC, &H76F988DA, &H983E5152, &HA831C66D, &HB00327C8, &HBF597FC7, &HC6E00BF3, &HD5A79147, &H6CA6351, &H14292967, &H27B70A85, &H2E1B2138, &H4D2C6DFC, &H53380D13, &H650A7354, &H766A0ABB, &H81C2C92E, &H92722C85, &HA2BFE8A1, &HA81A664B, &HC24B8B70, &HC76C51A3, &HD192E819, &HD6990624, &HF40E3585, &H106AA070, &H19A4C116, &H1E376C08, &H2748774C, &H34B0BCB5, &H391C0CB3, &H4ED8AA4A, &H5B9CCA4F, &H682E6FF3, &H748F82EE, &H78A5636F, &H84C87814, &H8CC70208, &H90BEFFFA, &HA4506CEB, &HBEF9A3F7, &HC67178F2)
    Dim hash, m, w(63), a, b, c, d, e, f, g, h, i, j, T1, t2
    
    hash = Array(&H6A09E667, &HBB67AE85, &H3C6EF372, &HA54FF53A, &H510E527F, &H9B05688C, &H1F83D9AB, &H5BE0CD19)
    
    m = ConvertToWordArray(sMessage)
    
    For i = 0 To UBound(m) Step 16
        a = hash(0)
        b = hash(1)
        c = hash(2)
        d = hash(3)
        e = hash(4)
        f = hash(5)
        g = hash(6)
        h = hash(7)
        
        For j = 0 To 63
            If j < 16 Then
                w(j) = m(j + i)
            Else
                w(j) = AddUnsigned(AddUnsigned(AddUnsigned(Gamma1(w(j - 2)), w(j - 7)), Gamma0(w(j - 15))), w(j - 16))
            End If
                
            T1 = AddUnsigned(AddUnsigned(AddUnsigned(AddUnsigned(h, Sigma1(e)), Ch(e, f, g)), K(j)), w(j))
            t2 = AddUnsigned(Sigma0(a), Maj(a, b, c))
            
            h = g
            g = f
            f = e
            e = AddUnsigned(d, T1)
            d = c
            c = b
            b = a
            a = AddUnsigned(T1, t2)
        Next
        
        hash(0) = AddUnsigned(a, hash(0))
        hash(1) = AddUnsigned(b, hash(1))
        hash(2) = AddUnsigned(c, hash(2))
        hash(3) = AddUnsigned(d, hash(3))
        hash(4) = AddUnsigned(e, hash(4))
        hash(5) = AddUnsigned(f, hash(5))
        hash(6) = AddUnsigned(g, hash(6))
        hash(7) = AddUnsigned(h, hash(7))
    Next
    
    SHA256 = LCase(Right("00000000" & Hex(hash(0)), 8) & Right("00000000" & Hex(hash(1)), 8) & Right("00000000" & Hex(hash(2)), 8) & Right("00000000" & Hex(hash(3)), 8) & Right("00000000" & Hex(hash(4)), 8) & Right("00000000" & Hex(hash(5)), 8) & Right("00000000" & Hex(hash(6)), 8) & Right("00000000" & Hex(hash(7)), 8))
End Function



Public Function Hash32Bit(ByVal s As String) As Long

    Dim h As Long
    h = 0
    
    Dim i As Long
    For i = 1 To Len(s)
      h = 31 * h + Asc(Mid(s, i, 1))
      h = h And &HFFFFF
    Next i
    Hash32Bit = h
End Function



Attribute VB_Name = "HelperfrmLogin"
Option Explicit


Function GetWindowsAuthorization(ByVal txt As String, ByRef usrname As String, ByRef usrpwd As String) As Boolean

      'frmLogin.Cont.Text = "Dateiname: " & xlapp.ActiveWorkbook.fullname & vbCrLf & vbCrLf & "Blattschutz entfernen von folgenden Tabellen wurde angefordert:" & vbCrLf
      frmLogin.Cont.Text = txt
      frmLogin.txtUserName = ""
      frmLogin.txtPassword = ""
      frmLogin.Show vbModal
      
      If Not frmLogin.LoginSucceeded Then
        GetWindowsAuthorization = False
        Exit Function
      End If
      
      usrname = frmLogin.txtUserName
      usrpwd = frmLogin.txtPassword
      GetWindowsAuthorization = True
      

End Function

Attribute VB_Name = "Helpers"
Option Explicit

Public Const GENERIC_READ As Long = &H80000000


#If VBA7 And Win64 Then
' Done
Public Declare PtrSafe Function apiGetTempPath Lib "kernel32" Alias "GetTempPathA" (ByVal nBufferLength As Long, ByVal lpBuffer As String) As Long
Public Declare PtrSafe Function GetCurrentProcessId Lib "kernel32" () As Long

#Else
Public Declare Function apiGetTempPath Lib "kernel32" Alias "GetTempPathA" (ByVal nBufferLength As Long, ByVal lpBuffer As String) As Long

Public Declare Function GetCurrentProcessId Lib "kernel32" () As Long
#End If

Private Type FILETIME
  dwLowDateTime As Long
  dwHighDateTime As Long
End Type

Private Type BY_HANDLE_FILE_INFORMATION
  dwFileAttributes As Long
  ftCreationTime As FILETIME
  ftLastAccessTime As FILETIME
  ftLastWriteTime As FILETIME
  dwVolumeSerialNumber As Long
  nFileSizeHigh As Long
  nFileSizeLow As Long
  nNumberOfLinks As Long
  nFileIndexHigh As Long
  nFileIndexLow As Long
End Type

Private Type OFSTRUCT
  cBytes As Byte
  fFixedDisk As Byte
  nErrCode As Integer
  Reserved1 As Integer
  Reserved2 As Integer
  szPathName(1024) As Byte
End Type

#If VBA7 And Win64 Then
' Done
Private Declare PtrSafe Function GetFileInformationByHandle Lib "kernel32" (ByVal hFile As LongPtr, lpFileInformation As BY_HANDLE_FILE_INFORMATION) As Long
Private Declare PtrSafe Function OpenFile Lib "kernel32" (ByVal lpFilename As String, lpReOpenBuff As OFSTRUCT, ByVal wStyle As Long) As Long
#Else
Private Declare Function GetFileInformationByHandle Lib "kernel32" (ByVal hFile As Long, lpFileInformation As BY_HANDLE_FILE_INFORMATION) As Long
Private Declare Function OpenFile Lib "kernel32" (ByVal lpFilename As String, lpReOpenBuff As OFSTRUCT, ByVal wStyle As Long) As Long
#End If

Private Type STARTUPINFO
   cb As Long
   lpReserved As String
   lpDesktop As String
   lpTitle As String
   dwX As Long
   dwY As Long
   dwXSize As Long
   dwYSize As Long
   dwXCountChars As Long
   dwYCountChars As Long
   dwFillAttribute As Long
   dwFlags As Long
   wShowWindow As Integer
   cbReserved2 As Integer
   lpReserved2 As Long
   hStdInput As Long
   hStdOutput As Long
   hStdError As Long
End Type

#If VBA7 And Win64 Then
' Done
Type PROCESS_INFORMATION
        hProcess As LongPtr
        hThread As LongPtr
        dwProcessId As Long
        dwThreadId As Long
End Type
Type SECURITY_ATTRIBUTES
        nLength As Long
        lpSecurityDescriptor As LongPtr
        bInheritHandle As Long
End Type

Private Declare PtrSafe Function WaitForSingleObject Lib "kernel32" (ByVal hHandle As LongPtr, ByVal dwMilliseconds As Long) As Long
Private Declare PtrSafe Function CreateProcessA Lib "kernel32" (ByVal lpApplicationName As String, ByVal lpCommandLine As String, lpProcessAttributes As LongPtr, lpThreadAttributes As LongPtr, ByVal bInheritHandles As Long, ByVal dwCreationFlags As Long, lpEnvironment As Any, ByVal lpCurrentDriectory As String, lpStartupInfo As STARTUPINFO, lpProcessInformation As PROCESS_INFORMATION) As Long
'Private Declare PtrSafe Function CreateProcessA Lib "kernel32" (ByVal lpApplicationName As String, ByVal lpCommandLine As String, lpProcessAttributes As SECURITY_ATTRIBUTES, lpThreadAttributes As SECURITY_ATTRIBUTES, ByVal bInheritHandles As Long, ByVal dwCreationFlags As Long, lpEnvironment As Any, ByVal lpCurrentDriectory As String, lpStartupInfo As STARTUPINFO, lpProcessInformation As PROCESS_INFORMATION) As Long
Private Declare PtrSafe Function GetShortPathName Lib "kernel32" Alias "GetShortPathNameA" (ByVal lpszLongPath As String, ByVal lpszShortPath As String, ByVal cchBuffer As Long) As Long
Public Declare PtrSafe Function GetExitCodeProcess Lib "kernel32" (ByVal hProcess As LongPtr, lpExitCode As Long) As Long
Public Declare PtrSafe Function OpenProcess Lib "kernel32" (ByVal dwDesiredAccess As Long, ByVal bInheritHandle As Long, ByVal dwProcessId As Long) As LongPtr

#Else
Private Type PROCESS_INFORMATION
   hProcess As Long
   hThread As Long
   dwProcessId As Long
   dwThreadId As Long
End Type
Type SECURITY_ATTRIBUTES
        nLength As Long
        lpSecurityDescriptor As LongPtr
        bInheritHandle As Long
End Type

Private Declare Function WaitForSingleObject Lib "kernel32" (ByVal hHandle As Long, ByVal dwMilliseconds As Long) As Long
Private Declare Function CreateProcessA Lib "kernel32" (ByVal lpApplicationName As Long, ByVal lpCommandLine As String, ByVal lpProcessAttributes As Long, ByVal lpThreadAttributes As Long, ByVal bInheritHandles As Long, ByVal dwCreationFlags As Long, ByVal lpEnvironment As Long, ByVal lpCurrentDirectory As Long, lpStartupInfo As STARTUPINFO, lpProcessInformation As PROCESS_INFORMATION) As Long
Private Declare Function GetShortPathName Lib "Kernel32.dll" Alias _
    "GetShortPathNameA" (ByVal lpszLongPath As String, _
                         ByVal lpszShortPath As String, _
                         ByVal cchBuffer As Long) As Long

Public Declare Function GetExitCodeProcess Lib "kernel32" _
 (ByVal hProcess As Long, exitCode As Long) As Long

Public Declare Function OpenProcess Lib "kernel32" _
 (ByVal DesiredAccess As Long, ByVal InheritHandle As Long, _
 ByVal ProcessId As Long) As Long

#End If

Private Const INFINITE = -1&
Private Const NORMAL_PRIORITY_CLASS = &H20&


Const OFS_MAXPATHNAME = 128
Const OF_CREATE = &H1000
Const OF_READ = &H0
Const OF_WRITE = &H1

' Public G_NoNTFS As Boolean

Private Const PROCESS_ALL_ACCESS = &H1F0FFF
Private Const STILL_ACTIVE = &H103


Private Const SC_CLOSE As Long = &HF060&
Private Const MIIM_STATE As Long = &H1&
Private Const MIIM_ID As Long = &H2&
Private Const MFS_GRAYED As Long = &H3&
Private Const WM_NCACTIVATE As Long = &H86

Private Type MENUITEMINFO
  cbSize As Long
  fMask As Long
  ftype As Long
  fState As Long
  wID As Long
  hSubMenu As Long
  hbmpChecked As Long
  hbmpUnchecked As Long
  dwItemData As Long
  dwTypeData As String
  cch As Long
End Type

#If VBA7 And Win64 Then
' Done
Public Declare PtrSafe Function GetSystemMenu Lib "user32" (ByVal hwnd As LongPtr, ByVal bRevert As Long) As LongPtr
Public Declare PtrSafe Function GetMenuItemInfo Lib "user32" Alias "GetMenuItemInfoA" (ByVal hMenu As LongPtr, ByVal un As Long, ByVal b As Long, lpMenuItemInfo As MENUITEMINFO) As Long
Public Declare PtrSafe Function SetMenuItemInfo Lib "user32" Alias "SetMenuItemInfoA" (ByVal hMenu As LongPtr, ByVal un As Long, ByVal bool As Long, lpcMenuItemInfo As MENUITEMINFO) As Long
Public Declare PtrSafe Function SendMessage Lib "user32" Alias "SendMessageA" (ByVal hwnd As LongPtr, ByVal wMsg As Long, ByVal wParam As LongPtr, lParam As Any) As LongPtr
Public Declare PtrSafe Function IsWindow Lib "user32" (ByVal hwnd As LongPtr) As Long
Public Declare PtrSafe Function GetTempFileName Lib "kernel32" Alias "GetTempFileNameA" (ByVal lpszPath As String, ByVal lpPrefixString As String, ByVal wUnique As Long, ByVal lpTempFileName As String) As Long
#Else
Public Declare Function GetSystemMenu Lib "user32" (ByVal hwnd As Long, ByVal bRevert As Long) As Long
Public Declare Function GetMenuItemInfo Lib "user32" Alias "GetMenuItemInfoA" (ByVal hMenu As Long, ByVal un As Long, ByVal b As Boolean, lpMenuItemInfo As MENUITEMINFO) As Long
Public Declare Function SetMenuItemInfo Lib "user32" Alias "SetMenuItemInfoA" (ByVal hMenu As Long, ByVal un As Long, ByVal bool As Boolean, lpcMenuItemInfo As MENUITEMINFO) As Long
Public Declare Function SendMessage Lib "user32" Alias "SendMessageA" (ByVal hwnd As Long, ByVal wMsg As Long, ByVal wParam As Long, lParam As Any) As Long
Public Declare Function IsWindow Lib "user32" (ByVal hwnd As Long) As Long
Public Declare Function GetTempFileName Lib "kernel32" _
         Alias "GetTempFileNameA" (ByVal lpszPath As String, _
         ByVal lpPrefixString As String, ByVal wUnique As Long, _
         ByVal lpTempFileName As String) As Long
#End If

Dim gMsgTitle As String

#If VBA7 And Win64 Then
' Done
    Public Declare PtrSafe Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As LongPtr
    Public Declare PtrSafe Function FindWindowEx Lib "user32" Alias "FindWindowExA" (ByVal hWnd1 As LongPtr, ByVal hWnd2 As LongPtr, ByVal lpsz1 As String, ByVal lpsz2 As String) As LongPtr
    Public Declare PtrSafe Function SetTimer Lib "user32" (ByVal hwnd As LongPtr, ByVal nIDEvent As LongPtr, ByVal uElapse As Long, ByVal lpTimerFunc As LongPtr) As LongPtr
'    Private Declare PtrSafe Function SetTimer Lib "user32" (ByVal hWnd As LongPtr, ByVal nIDEvent As LongPtr, ByVal uElapse As LongLong, ByVal lpTimerFunc As LongPtr) As LongLong
    Public Declare PtrSafe Function KillTimer Lib "user32" (ByVal hwnd As LongPtr, ByVal nIDEvent As LongPtr) As Long
'    Public Declare PtrSafe Function KillTimer Lib "user32" (ByVal hWnd As LongPtr, ByVal nIDEvent As LongPtr) As LongLong
    Public Declare PtrSafe Function DrawText Lib "user32" Alias "DrawTextA" (ByVal hdc As LongPtr, ByVal lpStr As String, ByVal nCount As Long, lpRect As RECT, ByVal wFormat As Long) As Long
#Else
    Public Declare Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
    Public Declare Function FindWindowEx Lib "user32" Alias "FindWindowExA" (ByVal hWnd1 As Long, ByVal hWnd2 As Long, ByVal lpsz1 As String, ByVal lpsz2 As String) As Long
    Public Declare Function SetTimer& Lib "user32" (ByVal hwnd&, ByVal nIDEvent&, ByVal uElapse&, ByVal lpTimerFunc&)
    Public Declare Function KillTimer& Lib "user32" (ByVal hwnd&, ByVal nIDEvent&)
    Public Declare Function DrawText Lib "user32" Alias "DrawTextA" (ByVal hdc As Long, ByVal lpStr As String, ByVal nCount As Long, lpRect As RECT, ByVal wFormat As Long) As Long
#End If

' Constants for API set A
Const EM_SETPASSWORDCHAR = &HCC
Public Const NV_INPUTBOX As Long = &H5000&


Enum OpenType
    tInput = 1
    tOutput = 2
    tAppend = 3
End Enum

Public Type RECT
   Left As Long
   Top As Long
   Right As Long
   Bottom As Long
End Type

Private Const DT_CALCRECT = &H400 'Calculate bounding rectangle
Private Const DT_WORDBREAK = &H10


Public Function GetMyTextExtents(ByVal hdc As Long, ByVal mytext As String, ByVal width As Long) As Helpers.RECT

Dim prevMode As Integer
Dim lRect As Helpers.RECT

'Save map mode and set map mode to Pixels
'prevMode = ScaleMode
'ScaleMode = vbPixels

'Get height of line.
lRect.Right = width
lRect.Bottom = 2000
DrawText hdc, mytext, Len(mytext), lRect, DT_CALCRECT + DT_WORDBREAK

'Return bounding rectangle
GetMyTextExtents = lRect

'ScaleMode = prevMode

End Function

Function GetLine(ByRef txt As String) As String
    Dim pos As Long
    Dim res As String
    pos = InStr(txt, vbCr)
    If pos > 0 Then
        res = Left(txt, pos - 1)
    Else
        res = txt
    End If
    If pos > 0 Then
        txt = Mid(txt, 2 + pos)
    Else
        txt = ""
    End If

    GetLine = res

End Function

Function FileExists(ByVal Dateiname$) As Boolean
    'Die Funktion pr|fffd|ft, ob eine Datei vorhanden ist
On Error GoTo fehler:
  Dim res As Boolean
  If UCase(Left(Dateiname, 5)) = "HTTP:" Or UCase(Left(Dateiname, 6)) = "HTTPS:" Then
    Dim sz As Long
    Dim modDate As Date
    FileExists = URLExists(Dateiname, sz, modDate)
  Else
    res = Dir$(Dateiname) <> ""
    If res = False Then
      res = Dir$(GetDriveAndPathFromUNC(Dateiname)) <> ""
    End If
    FileExists = res
  End If
    Exit Function
fehler:
    FileExists = False
    If Len(Dateiname) > 260 Then
        FileExists = MyFileExistsLongName(Dateiname)
    End If
End Function

Function MyFileExistsLongName(ByVal fname As String) As Boolean
On Error GoTo nogo
    If Len(fname) > 260 Then
        fname = "\\?\UNC\" & Mid$(fname, 3)
    End If
    
    Dim fs
    Set fs = CreateObject("Scripting.FileSystemObject")
    MyFileExistsLongName = fs.FileExists(fname)
    Exit Function
nogo:
    MyFileExistsLongName = False
End Function

Function URLExists(url As String, ByRef sz As Long, ByRef modDate As Date) As Boolean
    Dim Request As Object
    Dim ff As Integer
    Dim rc As Variant
    On Error GoTo EndNow
    sz = 0
    modDate = 0
    URLExists = False
    Set Request = CreateObject("MSXML2.XMLHTTP")
    With Request
      .Open "HEAD", url, False
      Request.SetRequestHeader "Cache-Control", "no-store, no-cache"
      Request.SetRequestHeader "Pragma", "no-cache"
      .send
      If .readyState = 4 Then
        URLExists = True
        sz = .getResponseHeader("Content-Length")
        Dim s As String
        s = Mid(Request.getResponseHeader("Last-Modified"), 6, 1000)
        s = Left(s, Len(s) - 4)
        modDate = CDate(s)
      Else
        .abort
      End If
    End With
    Set Request = Nothing
    Exit Function
EndNow:
    Debug.Print err.Description
    Set Request = Nothing
End Function

Function Mk_Dir(ByVal bez1$) As Boolean
    'Die Funktion erzeugt einen kompletten Unterverzeichnisbaum : z.B.  c:\test\backup\access\nr1
    On Error Resume Next
    Dim verz$, Bez$
    Mk_Dir = True

    If Len(bez1) < 3 And Mid(bez1, 2, 1) = ":" Then Exit Function

    Bez = bez1
    verz = Left(Bez, 3)
    Bez = Right(Bez, Len(Bez) - 3)
    If Right(Bez, 1) <> "\" Then Bez = Bez & "\"
    verz = verz & Mid(Bez, 1, InStr(Bez, "\") - 1)
    Bez = Right(Bez, Len(Bez) - InStr(Bez, "\"))
    While Right(verz, 1) <> "\"
        err.Number = 0
        MkDir verz
        '    If Err.Number <> 0 Then
        '        MsgBox "Das Verzeichnis '" & verz & "' konnte nicht angelegt werden! (" & Err.Description & ") Setup wird abgebrochen!", vbCritical
        '        Mk_Dir = False
        '        Exit Function
        '    End If
        If Bez <> "" Then
            verz = verz & "\" + Mid(Bez, 1, InStr(Bez, "\") - 1)
        Else
            verz = verz & "\"
        End If
        Bez = Right(Bez, Len(Bez) - InStr(Bez, "\"))
    Wend

    err.Number = 0
    
'    FileDateTime bez1
    
    If err.Number <> 0 Then
        '      MsgBox "Das Verzeichnis '" & bez1 & "' konnte nicht angelegt werden! (" & Err.Description & ") Setup wird abgebrochen!", vbCritical
        Mk_Dir = False
    End If

End Function



Function GetFilePath(ByVal fn As String) As String
    Dim file As String
    Dim path As String
    Dim ext As String

    fileSplit fn, path, file, ext
    GetFilePath = Left(path, Len(path) - 1)
End Function

Function GetFileNameAndPath(ByVal fn As String) As String
    Dim file As String
    Dim path As String
    Dim ext As String

    fileSplit fn, path, file, ext
    GetFileNameAndPath = path & file
End Function

Function GetFileName(ByVal fn As String) As String
    Dim file As String
    Dim path As String
    Dim ext As String

    fileSplit fn, path, file, ext
    GetFileName = file
End Function

Function GetFileExtension(ByVal fn As String) As String
    Dim file As String
    Dim path As String
    Dim ext As String

    fileSplit fn, path, file, ext
    GetFileExtension = ext
End Function

Function GetFileNameAndExtension(ByVal fn As String) As String
    Dim file As String
    Dim path As String
    Dim ext As String

    fileSplit fn, path, file, ext
    GetFileNameAndExtension = file & "." & ext
End Function

Sub fileSplit(ByVal s$, ByRef path$, ByRef file$, ByRef ext$)
    ' die Prozedur zerlegt den Dateinamen S in Path, Name, Extension
    Dim i%
    For i = Len(s) To 1 Step -1
        If Mid(s, i, 1) = "\" Or Mid(s, i, 1) = "/" Then   ' keine Extension vorhanden
            ext = ""
            Exit For
        End If
        If Mid(s, i, 1) = "." Then
            ext = Right(s, Len(s) - i)
            s = Left(s, i - 1)
            Exit For
        End If
    Next i
    i = Len(s)
    If InStr(s, "\") <> 0 Then
        While Mid(s, i, 1) <> "\"
            i = i - 1
        Wend
    ElseIf InStr(s, "/") <> 0 Then
        While Mid(s, i, 1) <> "/"
            i = i - 1
        Wend
    End If
    path = Left(s, i)
    file = Right(s, Len(s) - i)

End Sub

Function Encode(ByVal s As String) As String
    Dim i As Long
    Dim s2 As String
    For i = 1 To Len(s)
        If Mid(s, i, 2) = "\n" Then
            s2 = s2 + "@"
            i = i + 1
        Else
            If Mid(s, i, 1) = vbLf Then
                s2 = s2 + "@"
            ElseIf Mid(s, i, 1) = " " Then
                s2 = s2 + "^"
            ElseIf Mid(s, i, 1) >= "0" And Mid(s, i, 1) <= "9" Then
                s2 = s2 + Chr(Asc("9") + Asc("0") - Asc(Mid(s, i, 1)))
            ElseIf Mid(s, i, 1) >= "a" And Mid(s, i, 1) <= "z" Then
                s2 = s2 + Chr(Asc("a") + Asc("z") - Asc(Mid(s, i, 1)))
            ElseIf Mid(s, i, 1) >= "A" And Mid(s, i, 1) <= "Z" Then
                s2 = s2 + Chr(Asc("A") + Asc("Z") - Asc(Mid(s, i, 1)))
            Else
                s2 = s2 + Mid(s, i, 1)
            End If
        End If
    Next i
    Encode = s2
End Function

Function MyReplace(ByVal txt As String, ByVal searchtxt As String, ByVal replacetxt As String, Optional ByVal checkStartAndEnd As Boolean = False, Optional ByVal ignoreIn As String = "") As String
    Dim txtPos As Long
    Dim tStringRep As String
    Dim res As String
    Dim ok As Boolean
    MyReplace = txt
    If InStr(txt, searchtxt) = 0 Then Exit Function
    Dim inIgnore As Boolean

    inIgnore = False

    For txtPos = 1 To Len(txt)
        If Len(ignoreIn) > 0 Then
            If Mid(txt, txtPos, Len(ignoreIn)) = ignoreIn Then
                If Not inIgnore Then
                    inIgnore = True
                Else
                    inIgnore = False
                End If
            End If
        End If

        If Not inIgnore Then
            If Mid(txt, txtPos, Len(searchtxt)) = searchtxt Then
                ok = True
                Dim tval As String
                If checkStartAndEnd Then
                    If txtPos > 1 Then
                        tval = Mid(txt, txtPos - 1, 1)
                        If (tval >= "a" And tval <= "z") Or _
                           (tval >= "A" And tval <= "Z") Or _
                           (tval >= "0" And tval <= "9") Or _
                           tval = "_" Then
                            ok = False
                        End If
                    End If
                    If txtPos + Len(searchtxt) <= Len(txt) Then
                        tval = Mid(txt, txtPos + Len(searchtxt), 1)
                        If (tval >= "a" And tval <= "z") Or _
                           (tval >= "A" And tval <= "Z") Or _
                           (tval >= "0" And tval <= "9") Or _
                           tval = "_" Then
                            ok = False
                        End If
                    End If
                End If
                If ok Then
                    res = res + replacetxt
                    txtPos = txtPos + Len(searchtxt) - 1
                Else
                    res = res + Mid(txt, txtPos, 1)
                End If
            Else
                res = res + Mid(txt, txtPos, 1)
            End If
        Else
            res = res + Mid(txt, txtPos, 1)
        End If
    Next txtPos
    MyReplace = res
End Function

Function GetValuePart(ByVal s As String, ByRef p As Long, Optional ByVal separator As String = ",") As String
    Dim rets As String
    p = OverreadBlanks(s, p)
    If Mid(s, p, 1) = Chr(34) Then
        p = p + 1
        While p <= Len(s) And Mid(s, p, 1) <> Chr(34)
            rets = rets & Mid(s, p, 1)
            p = p + 1
        Wend
        p = p + 1
    Else
        While p <= Len(s) And Mid(s, p, 1) <> separator
            rets = rets & Mid(s, p, 1)
            p = p + 1
        Wend
    End If
    p = OverreadBlanks(s, p)
    If p <= Len(s) And Mid(s, p, 1) = separator Then
        p = p + 1
    End If
    GetValuePart = rets
End Function

Function OverreadBlanks(ByVal s As String, ByVal p As Long) As Long
    While p <= Len(s) And Mid(s, p, 1) = " "
        p = p + 1
    Wend
    OverreadBlanks = p
End Function


Function RemoveCommentsAndLineFeeds(ByVal txt As String) As String

    If Left(txt, Len("Option Explicit")) = "Option Explicit" Then
        txt = Mid(txt, Len("Option Explicit") + 1)
    End If

    Dim i As Long
    Dim nutxt As String
    For i = 1 To Len(txt)
        If Mid(txt, i, 1) = Chr(34) Then
            nutxt = nutxt + Mid(txt, i, 1)
            i = i + 1
            While Mid(txt, i, 1) <> Chr(34) And i < Len(txt)
                nutxt = nutxt + Mid(txt, i, 1)
                i = i + 1
            Wend

            nutxt = nutxt + Mid(txt, i, 1)
        ElseIf Mid(txt, i, 1) = "'" Then
            While Mid(txt, i, 1) <> Chr(10) And Mid(txt, i, 1) <> Chr(13) And i < Len(txt)
                i = i + 1
            Wend
            nutxt = nutxt + Mid(txt, i, 1)
        ElseIf Mid(txt, i, 1) <> Chr(10) And Mid(txt, i, 1) <> Chr(13) Then
            nutxt = nutxt + Mid(txt, i, 1)
        End If
    Next i
    RemoveCommentsAndLineFeeds = nutxt
End Function

Function GetDocProp(ByRef wbInExcelCurrentProjectInAccess As Object, ByVal txt As String) As String

#If PROJECT_ACCESSTRACKER = 0 Then
    On Error Resume Next
    GetDocProp = ""
    GetDocProp = wbInExcelCurrentProjectInAccess.BuiltinDocumentProperties(txt).value()
#Else

    On Error Resume Next
'    GetDocProp = ""
'    GetDocProp = accapp.BuiltinDocumentProperties(txt).Value()

    Dim dbs As DAO.Database, prp As DAO.Property
    Const conPropNotFoundError = 3270
 
    ' Datenbank holen
    Set dbs = wbInExcelCurrentProjectInAccess.Application.CurrentDb
    On Error GoTo Change_Bye
    If txt = "Creation date" Then
      GetDocProp = dbs.Containers("Databases").DOCUMENTS("SummaryInfo").Properties("DateCreated")
    Else
      GetDocProp = dbs.Containers("Databases").DOCUMENTS("SummaryInfo").Properties(txt)
    End If
    
    ' dbs.Properties(txt)
 
Change_Bye:
    Set dbs = Nothing
    Exit Function

#End If
End Function

    
Public Function ReadAllText(fname As String) As String
  Dim fn As Long
  fn = FreeFile
  Dim s As String
  Dim ress As String
  Open fname For Input As fn
  Do While Not EOF(fn)
    Line Input #fn, s
    ress = ress & vbCrLf & s
  Loop
  Close fn
  ReadAllText = ress
End Function

Function GetTempPath() As String
  Dim RetVal As Long
  Dim pathbuffer As String * 512
  
  Dim l As Long
  l = apiGetTempPath(512, pathbuffer)
  If l > 0 Then
    GetTempPath = Trim(Left(pathbuffer, l))
  End If
End Function


' Function TwipsToPixelsX(Twips As Long) As Long
'    TwipsToPixelsX = Twips / Screen.TwipsPerPixelX
' End Function

'Pixel in Twips X
Function PixelsToTwipsX(Pixels As Long) As Long
    PixelsToTwipsX = Pixels
    Exit Function

'   PixelsToTwipsX = Pixels * Screen.TwipsPerPixelX
End Function

'Twips in Pixel Y
' Function TwipsToPixelsY(Twips As Long) As Long
'    TwipsToPixelsY = Twips / Screen.TwipsPerPixelY
' End Function

'Pixel in Twips Y
Function PixelsToTwipsY(Pixels As Long) As Long
  PixelsToTwipsY = Pixels / 1.33
  Exit Function

'   PixelsToTwipsY = Pixels * Screen.TwipsPerPixelY
End Function


Function GetSWResItem(ByVal pos As Long, ff As Long) As String
  Dim res As String
  
  If FileExists(GetStorePath(tKey) & "swres.swk") Then
    If UCase(Right(ThisWorkbook.name, 1)) = "S" Then
      Debug.Print "KEY: " & GetStorePath(tKey) & "swres.swk"
    End If
    Open GetStorePath(tKey) & "swres.swk" For Binary Access Read As #ff  ' Len = 4
  ElseIf FileExists(G_StartupPath & "swres.swk") Then
    If UCase(Right(ThisWorkbook.name, 1)) = "S" Then
      Debug.Print "KEY: " & G_StartupPath & "swres.swk"
    End If
    Open G_StartupPath & "swres.swk" For Binary Access Read As #ff  ' Len = 4
  ElseIf FileExists(G_StartupPath & "..\swres.swk") Then
    If UCase(Right(ThisWorkbook.name, 1)) = "S" Then
      Debug.Print "KEY: " & G_StartupPath & "..\swres.swk"
    End If
    Open G_StartupPath & "..\swres.swk" For Binary Access Read As #ff  ' Len = 4
  ElseIf FileExists(G_StartupPath & "..\BIN\swres.swk") Then
    If UCase(Right(ThisWorkbook.name, 1)) = "S" Then
      Debug.Print "KEY: " & G_StartupPath & "..\BIN\swres.swk"
    End If
    Open G_StartupPath & "..\BIN\swres.swk" For Binary Access Read As #ff  ' Len = 4
  End If
  
  
  Dim l As Long
  Get #ff, pos, l

  Dim charc As Long

  ' ENC2
  If l = 1 Then
    Get #ff, pos + 4, l
  
  '  Close ff
  '  Open AktVerz & "\swres.swk" For Binary Access Read As #ff ' Len = 1
    For charc = 1 To l
      Dim tchar As Byte
      Get #ff, pos + 7 + charc, tchar
      tchar = tchar Xor (1 + 2 + 4 + 16 + 64)
      res = res & Chr(tchar)
    Next charc
    Close ff
    Do
      pos = InStr(res, "\n")
      If pos <= 0 Then Exit Do
      res = Left(res, pos - 1) & vbCrLf & Mid(res, pos + 2)
    Loop
    GetSWResItem = res
  
  ' ENC4 - Crypt+bit
  ElseIf l = 3 Then
    
    Get #ff, pos + 4, l
  
    Dim it As Long
    it = 1
    Dim cryptarray(8) As Long
    cryptarray(1) = 123
    cryptarray(2) = 23
    cryptarray(3) = 7
    cryptarray(4) = 73
    cryptarray(5) = 91
    cryptarray(6) = 213
    cryptarray(7) = 45
    cryptarray(8) = 187
  
    If l > 0 Then
      For charc = 1 To l
        Get #ff, pos + 7 + charc, tchar
        tchar = tchar Xor cryptarray(it)
        res = res & Chr(tchar)
        it = it + 1
        If it = 9 Then it = 1
      Next charc
    End If
    
    Close ff
    
    If Len(res) > 0 Then
      res = Crypt(res, "|fffd|34w2=%$3xxfAF%341$&LK|fffd|,m.|fffd||fffd|p[", False)
    End If
    
    Do
      pos = InStr(res, "\n")
      If pos <= 0 Then Exit Do
      res = Left(res, pos - 1) & vbCrLf & Mid(res, pos + 2)
    Loop
    GetSWResItem = res
  End If
End Function

Function GetNextText(s As String, ByRef pos As Long) As String
  If Len(s) > 0 And pos > 0 Then
    Dim lastpos As Long
    lastpos = pos
      
    pos = InStr(pos, s, ",")
    If pos > 0 Then
      
      GetNextText = Trim(Mid(s, lastpos, pos - lastpos))
      pos = pos + 1
      Exit Function
    ElseIf lastpos < Len(s) Then
      GetNextText = Trim(Mid(s, lastpos))
      pos = -1
      Exit Function
    Else
      pos = -1
      GetNextText = ""
      Exit Function
    End If
  Else
    pos = -1
    GetNextText = ""
    Exit Function
  End If

End Function

Function GetVariableName(s As String, ByRef pos As Long) As String
  If Len(s) > 0 And pos > 0 Then
    Dim lastpos As Long
    lastpos = pos
    Dim res As String
    Do While pos <= Len(s)
      If InStr("ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_|fffd||fffd||fffd||fffd|", UCase(Mid(s, pos, 1))) <= 0 Then Exit Do
      res = res & Mid(s, pos, 1)
      pos = pos + 1
    Loop
    GetVariableName = res
  End If
End Function

Function ConvertToUcaseVarName(s As String) As String
  Dim pos As Long
  Dim res As String
  pos = 1
  
  s = UCase(s)
  If Len(s) > 0 And pos > 0 Then
    
    If IsNumeric(Left(s, 1)) Then
      res = "_"
      pos = 2
    End If
    
    Dim lastpos As Long
    lastpos = pos
    Do While pos <= Len(s)
      If InStr("ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_|fffd||fffd||fffd||fffd|", UCase(Mid(s, pos, 1))) <= 0 Then
        res = res & "_"
      Else
        res = res & Mid(s, pos, 1)
      End If
      pos = pos + 1
    Loop
    ConvertToUcaseVarName = res
  End If
End Function


Public Function CollectionItemExists(ByRef c As Collection, name As String) As Boolean
  On Error GoTo notReadable
  Dim s As String
  s = CStr(c(name))
  CollectionItemExists = True
  Exit Function
  
notReadable:
  CollectionItemExists = False
End Function


Public Function CollectionStringExists(ByRef c As Collection, name As String) As Boolean
  On Error GoTo notReadable
  Dim s As String
  s = c(name)
  CollectionStringExists = True
  Exit Function
  
notReadable:
  CollectionStringExists = False
End Function

Public Function CollectionObjectExists(ByRef c As Collection, name As String) As Boolean
  On Error GoTo notReadable
  Dim s
  Set s = c(name)
  Set s = Nothing
  CollectionObjectExists = True
  Exit Function
  
notReadable:
  CollectionObjectExists = False
End Function



Function GetSQLTimestamp(d As Date) As String
  GetSQLTimestamp = Format(d, "yyyy-mm-dd-hh-mm-ss")
End Function

Function PathExists(Dateiname$) As Boolean
  On Error GoTo fehler:
  Dim b As Boolean
  
  b = Dir$(Dateiname, vbDirectory) <> ""
  If Not b Then
    b = Dir$(Dateiname & "\", vbDirectory) <> ""
  End If
  PathExists = b
  Exit Function
fehler:
    PathExists = False
    Resume Next
End Function

Function MyOpenFile(ByRef fnumber, fname As String, oType As OpenType) As Boolean
  On Error Resume Next

  Dim cnt As Long
  cnt = 0
  
  
  Do
    
    err.Clear
    
    Select Case oType
      Case OpenType.tOutput
            Open fname For Output As #fnumber
      Case OpenType.tInput
            Open fname For Input As #fnumber
      Case OpenType.tAppend
            Open fname For Append As #fnumber
    End Select
    
    If err.Number = 0 Then Exit Do
    Sleep 50
    cnt = cnt + 1
    If cnt = 10 Then
      MyOpenFile = False
      Exit Function
    End If
  
  Loop
  
  MyOpenFile = True

End Function


Function ConvGermanDateKey(d As String) As String
    Dim sp() As String
    sp = Split(d, ".")
    If UBound(sp) - LBound(sp) + 1 = 3 Then
        ConvGermanDateKey = DateSerial(CInt(sp(2)), CInt(sp(1)), CInt(sp(0)))
    Else
        ConvGermanDateKey = d
    End If
End Function

Function ConvGermanDate(d As String) As Date
    Dim td As Date
    
    On Error GoTo errorEnd
    td = DateSerial(1900, 1, 1)
    
    If IsDate(d) Then
        td = CDate(d)
    Else
      Dim dots As Long
      Dim pos1 As Long
      Dim pos2 As Long
      Dim EndPos As Long
      
      dots = 0
      
      pos1 = InStr(d, ".")
      If pos1 > 0 Then
          dots = dots + 1
          
          pos2 = InStr(pos1 + 1, d, ".")
          If pos2 > 0 Then
              dots = dots + 1
              EndPos = InStr(pos2 + 1, d, " ")
              If EndPos <= 0 Then EndPos = Len(d) + 1
          End If
      End If
      
      If dots = 2 Then
          Dim day As String
          Dim month As String
          Dim year As String
          day = Mid(d, 1, pos1 - 1)
          month = Mid(d, pos1 + 1, pos2 - pos1 - 1)
          year = Mid(d, pos2 + 1, EndPos - pos2 - 1)
          td = DateSerial(year, month, day) & IIf(CDate(d) <> DateSerial(year, month, day), " " & Hour(d) & ":" & Minute(d) & ":" & Second(d), "")
      End If
    End If
    
    If td < DateSerial(1900, 1, 1) Then
      td = DateSerial(1900, 1, 1) & " " & Hour(d) & ":" & Minute(d) & ":" & Second(d)
    End If
    
errorEnd:
    ConvGermanDate = td
End Function

Sub MyKill(fname As String)
  On Error Resume Next
  Kill fname
End Sub

Sub MyRename(sFnameFrom As String, sFnameTo As String)
  On Error Resume Next
  Name sFnameFrom As sFnameTo
End Sub

Function GetFullPath(ByVal filename As String) As String
  Dim s As String
  If Left(filename, 2) = "\\" Or Left(filename, 2) = "//" Or Mid(filename, 2, 1) = ":" Or InStr(filename, "://") > 0 Then
    s = filename
  Else
    s = G_cfgBinpfad & "\" & filename
  End If
  
  GetFullPath = s
End Function


Function GetRelativePath(ByVal stdpath As String, ByVal cfgpath As String) As String
  Dim s As String
  If cfgpath = "" Then cfgpath = stdpath
  
  If cfgpath = "USERTEMP" Then
    cfgpath = GetTempPath
    If Right(cfgpath, 1) = "\" Then
      cfgpath = Left(cfgpath, Len(cfgpath) - 1)
    End If
  End If
  
  If Left(cfgpath, 2) = "\\" Or Left(cfgpath, 2) = "//" Or Mid(cfgpath, 2, 1) = ":" Or InStr(cfgpath, "://") > 0 Then
    s = cfgpath
  Else
  
    If G_CfgPath <> "" Then
      s = G_CfgPath & cfgpath
    Else
      s = G_StartupPath & cfgpath
    End If
  End If
  
  If Not PathExists(s) Then
    MkFullDir s
    If Not PathExists(s) Then
      ' MsgBox "ACHTUNG: Der Pfad '" & s & "' konnte nicht erzeugt werden. Das Programm wird voraussichtlich nicht korrekt funktionieren. Bitte gew|fffd|hrleisten Sie, dass der Pfad existiert!", vbCritical, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
      DebugPrint tinfo, "Der Pfad '" & s & "' konnte nicht erzeugt werden."
    End If
  End If
  
  GetRelativePath = s
End Function

Sub MkFullDir(ByVal p As String)
  On Error Resume Next
  Dim pos As Long
  pos = 4
  Do
    pos = InStr(pos, p, "\")
    If pos > 0 Then
      MkDir Left(p, pos - 1)
    Else
      MkDir p
      Exit Sub
    End If
    pos = pos + 1
  Loop While pos > 0
End Sub


Function GetPath(ByVal p As String) As String
  If InStrRev(p, "\") > 0 Then
    GetPath = Left(p, InStrRev(p, "\") - 1)
    Exit Function
  End If
  GetPath = p
End Function


Function GetServerNameFromUNC(s As String) As String
  If Left(s, 2) = "\\" Or Left(s, 2) = "//" Then
    Dim pos As Long
    pos = InStr(Mid(s, 3), "\")
    If pos > 0 Then
      GetServerNameFromUNC = Mid(s, 3, pos - 1)
    End If
  End If
End Function




Function FilesAreEqual(fname1 As String, fname2 As String) As Boolean

  Dim lHigh1 As Long
  Dim lLow1 As Long
  Dim lHigh2 As Long
  Dim lLow2 As Long
  
  FilesAreEqual = False
  If GetFileIndex(fname1, lHigh1, lLow1) = True Then
    If GetFileIndex(fname2, lHigh2, lLow2) = True Then
      If lHigh1 <> 0 And lHigh1 = lHigh2 Then
        If lLow1 <> 0 And lLow1 = lLow2 Then
          FilesAreEqual = True
        End If
      End If
    End If
  End If
       
End Function

Function GetFileIndex(sFile As String, ByRef lHigh As Long, ByRef lLow As Long) As Boolean

  On Error GoTo nogo
  
  Dim handleOpen As Boolean
  lHigh = 0
  lLow = 0

  Dim hFile As Long, FileInfo As BY_HANDLE_FILE_INFORMATION
  Dim OF As OFSTRUCT
  
  hFile = OpenFile(sFile, OF, OF_READ)
  handleOpen = True
  GetFileInformationByHandle hFile, FileInfo
  CloseHandle hFile ' close the handle to the file
  
  lHigh = FileInfo.nFileIndexHigh
  lLow = FileInfo.nFileIndexLow
  
  GetFileIndex = True
  Exit Function
  
nogo:
  If handleOpen Then
    CloseHandle hFile
  End If
  GetFileIndex = False
End Function

Public Function ShellAndWait(Exec As String, _
 Optional WindowStyle As VbAppWinStyle = vbMinimizedFocus) _
 As Long

  Dim nTaskId As Long
#If VBA7 And Win64 Then
  Dim nHProcess As LongPtr
#Else
  Dim nHProcess As Long
#End If
  Dim nExitCode As Long
  
  Const STILL_ACTIVE = &H103
  Const PROCESS_QUERY_INFORMATION = &H400
    
  nTaskId = Shell(Exec, WindowStyle)
  nHProcess = OpenProcess(PROCESS_QUERY_INFORMATION, False, nTaskId)
  Do
'    Sleep 10
    DoEvents
    GetExitCodeProcess nHProcess, nExitCode
  Loop While nExitCode = STILL_ACTIVE
  CloseHandle nHProcess
  ShellAndWait = nExitCode
End Function

Public Function IDVSuiteShellAndWait(func As String, Exec As String, _
 Optional WindowStyle As VbAppWinStyle = vbMinimizedFocus) _
 As Long

  Dim nTaskId As Long
#If VBA7 And Win64 Then
  Dim nHProcess As LongPtr
#Else
  Dim nHProcess As Long
#End If
  Dim nExitCode As Long
  
  Const STILL_ACTIVE = &H103
  Const PROCESS_QUERY_INFORMATION = &H400
  
  SaveSetting appname:="Stromwerken", Section:="IDV-Suite", Key:="AliveText", Setting:=func
    
  nTaskId = Shell(Chr(34) & G_IDVSuitePath & "\idv-suite.exe" & Chr(34) & " " & Exec, WindowStyle)
  nHProcess = OpenProcess(PROCESS_QUERY_INFORMATION, False, nTaskId)
  
  Dim lastcheck As Date
  lastcheck = Now
  
  Dim laststatusinfo As Date
  laststatusinfo = Now
  
  Do
'    Sleep 10
    DoEvents
    
    ' Hier wird mal gecheckt, wann die letzte R|fffd|ckmeldung der Suite kam, damit sie nicht "rumidelt"
    Dim s As String
    s = GetSetting( _
           appname:="Stromwerken", _
           Section:="IDV-Suite", _
           Key:="Alive", _
           Default:="")
    
    If s <> "" Then
      If IsDate(s) Then
        lastcheck = CDate(s)
      End If
    End If
    
#If PROJECT_IDVSCHEDULER <> 0 Then
'    Form1.StatusLabel.Caption = GetSetting( _
'           appname:="Stromwerken", _
'           Section:="IDV-Suite", _
'           Key:="AliveText", _
'           Default:="") & " - Letzte R|fffd|ckmeldung vor " & DateDiff("s", lastcheck, Now) & " Sekunden"
    Form1.StatusLabel.Caption = GetSetting( _
           appname:="Stromwerken", _
           Section:="IDV-Suite", _
           Key:="AliveText", _
           Default:="") & FMT1("HELPERS_1", DateDiff("s", lastcheck, Now))
#End If

#If PROJECT_PLUGINCHECK = 0 Then
    If DateDiff("s", laststatusinfo, Now) > 5 Then
          laststatusinfo = Now
          StoreComm "SchedStatus", Now
    End If
#End If

    If DateDiff("s", lastcheck, Now) > 500 Then
      ' 5 Minuten kein Feedback? Wie zur H|fffd|lle kann das sein? Task killen und weiter...
      Shell "TASKKILL /PID " & nTaskId & " /F /FI " & Chr(34) & "USERNAME eq " & GetUserName() & Chr(34) & " /T", vbHide
      Exit Do
    End If
    
    GetExitCodeProcess nHProcess, nExitCode
    
  Loop While nExitCode = STILL_ACTIVE
  
#If PROJECT_IDVSCHEDULER <> 0 Then
  Form1.StatusLabel.Caption = ""
#End If

  CloseHandle nHProcess
  IDVSuiteShellAndWait = nExitCode
End Function


Sub ShellAndWaitOLD(ByVal filename As String)
   Dim RetVal As Long
   Dim proc As PROCESS_INFORMATION
   Dim StartInf As STARTUPINFO
   
   StartInf.cb = Len(StartInf)
   
   'Angegebenes Programm starten
#If VBA7 And Win64 Then
   RetVal = CreateProcessA(0&, filename, 1, 0&, 1&, NORMAL_PRIORITY_CLASS, 0&, 0&, StartInf, proc)
#Else
   RetVal = CreateProcessA(0&, filename, 0&, 0&, 1&, NORMAL_PRIORITY_CLASS, 0&, 0&, StartInf, proc)
#End If
   'Das eigene Programm anhalten, bis das fremde beendet wurde
   RetVal = WaitForSingleObject(proc.hProcess, INFINITE)
   RetVal = CloseHandle(proc.hProcess)
End Sub

Function MyFileLen(fname As String) As Long
  On Error GoTo nogo:
  MyFileLen = 0
  If UCase(Left(fname, 5)) = "HTTP:" Or UCase(Left(fname, 6)) = "HTTPS:" Then
    Dim sz As Long
    Dim modDate As Date
    If URLExists(fname, sz, modDate) Then
      MyFileLen = sz
    End If
  Else
    MyFileLen = fileLen(fname)
  End If
  Exit Function
nogo:
End Function

Sub TestMFDT()
  Debug.Print MyFileDateTime("\\DHB.Local\DHBDFS\Pool\Pool-DHB\anonymisierterDateiname.xlsx")
End Sub

Function MyFileDateTime(ByVal fname As String) As Date
  MyFileDateTime = 0
  On Error GoTo nogo
  If UCase(Left(fname, 5)) = "HTTP:" Or UCase(Left(fname, 6)) = "HTTPS:" Then
    Dim sz As Long
    Dim modDate As Date
    If URLExists(fname, sz, modDate) Then
      MyFileDateTime = modDate
    End If
  Else
    MyFileDateTime = FileDateTime(fname)
  End If
  Exit Function
nogo:
  If Len(fname) > 260 Then
     MyFileDateTime = MyFileDateTimeLongName(fname)
'  Else
    ' Entfernt, da bei einer nicht vorhandenen Datei immer ein (unplausibler) Error geworfen wird:
    ' Da kommt immer: 5 - Ung|fffd|ltiger Prozeduraufruf oder ung|fffd|ltiges Argument
'    DebugPrint tdebug, "MyFileDateTime failed for: '" & fname & "' - " & err.Number & " - " & err.Description
  End If
End Function

Function MyFileDateTimeLongName(fname As String) As Date
On Error GoTo nogo
    If Len(fname) > 260 Then
        fname = "\\?\UNC\" & Mid$(fname, 3)
    End If
    
    Dim fs
    Dim f
    Set fs = CreateObject("Scripting.FileSystemObject")
    Set f = fs.GetFile(fname)
    
    MyFileDateTimeLongName = f.DateLastModified
    Exit Function
nogo:
'    DebugPrint tdebug, "MyFileDateTimeLongName failed for: '" & fname & "' - " & err.Number & " - " & err.Description
    MyFileDateTimeLongName = 0
End Function

Public Function ShortFileName(ByVal long_name As String) As String
    If UCase(Left(long_name, 5)) = "HTTP:" Or UCase(Left(long_name, 6)) = "HTTPS:" Then
      ShortFileName = long_name
      Exit Function
    End If
    
    'Returns the short filename associated w
    '     ith sLongFilename
    Dim lRet As Long
    Dim sShortFilename As String
    'First attempt using 1024 character buff
    '     er.
    sShortFilename = String$(1024, " ")
    lRet = GetShortPathName(long_name, sShortFilename, Len(sShortFilename))
    
    'If buffer is too small lRet contains bu
    '     ffer size needed.


    If lRet > Len(sShortFilename) Then
        'Increase buffer size...
        sShortFilename = String$(lRet + 1, " ")
        'and try again.
        lRet = GetShortPathName(long_name, sShortFilename, Len(sShortFilename))
    End If
    
    'lRet contains the number of characters
    '     returned.


    If lRet > 0 Then
        ShortFileName = Left$(sShortFilename, lRet)
    End If
    
    
End Function
 
 

Function UserIsInAdministratorenGroup() As Boolean
  If WinNTCurrentUserIsInGroup("Administratoren") = True Or WinNTCurrentUserIsInGroup("Administrators") = True Then
    UserIsInAdministratorenGroup = True
  End If
  
End Function

Function WinNTCurrentUserIsInGroup(strGroup As String) As Boolean
On Error GoTo nogo
    Dim objShell As Object
    Set objShell = CreateObject("WScript.Shell")
    Dim strDomain As String
    Dim strUser As String
    Dim objUser As Object
    Dim objGroup As Object
    Dim strgroups
    strDomain = objShell.ExpandEnvironmentStrings("%USERDOMAIN%")
    strUser = objShell.ExpandEnvironmentStrings("%USERNAME%")
    Set objUser = GetObject("WinNT://" & strDomain & "/" & strUser)
    strgroups = "|"
    For Each objGroup In objUser.Groups
        strgroups = strgroups & objGroup.name & "|"
'        Debug.Print objGroup.Name
    Next
    If InStr(1, strgroups, "|" & strGroup & "|", vbTextCompare) > 0 Then  ' The user is in the group so we can do thingsEnd If
      WinNTCurrentUserIsInGroup = True
    End If
    Exit Function
nogo:
End Function

' Dirk Localization: Geht nicht mit "12:10am"
' Aber diese Funktion wird nirgendwo benutzt
Function IsTime(s As String) As Boolean
  If Len(s) = 5 Then
    If IsNumeric(Mid(s, 1, 1)) And IsNumeric(Mid(s, 2, 1)) And IsNumeric(Mid(s, 4, 1)) And IsNumeric(Mid(s, 5, 1)) _
       And Mid(s, 3, 1) = ":" Then
       IsTime = True
    End If
  ElseIf Len(s) = 8 Then
    If IsNumeric(Mid(s, 1, 1)) And IsNumeric(Mid(s, 2, 1)) And IsNumeric(Mid(s, 4, 1)) And IsNumeric(Mid(s, 5, 1)) And IsNumeric(Mid(s, 7, 1)) And IsNumeric(Mid(s, 8, 1)) _
       And Mid(s, 3, 1) = ":" And Mid(s, 6, 1) = ":" Then
       IsTime = True
    End If
  End If
End Function

Function GetTime(d As Date) As Date
  On Error Resume Next
  GetTime = CDate("00:00:00")
  GetTime = TimeValue(d)
End Function

Public Function ADGetUserMailAddress(LoginName As String) As String
'PURPOSE: Display information that is available in
'the Active Directory about a given user

'PARAMETER: Login Name for user

'RETURNS: String with selected information about
'user, or empty string if there is no such
'login on the current domain

'REQUIRES: Windows 2000 ADSI, LDAP Provider
'Proper Security Credentials.

'EXAMPLE: msgbox ADGetUserMailAddress("Administrator")

On Error GoTo ErrHandler:
    
    Dim conn As Object
    Dim rs As Object
    Dim oRoot As Object
    Dim oDomain As Object
    Dim sBase As String
    Dim sFilter As String
    Dim sDomain As String
    
    Dim sAttribs As String
    Dim sDepth As String
    Dim sQuery As String
    Dim sAns As String
    
    If G_cfgNoAD Then Exit Function
    
    Set conn = CreateObject("ADODB.Connection")
    
    Dim user As Object

    'Get user Using LDAP/ADO.  There is an easier way
    'to bind to a user object using the WinNT provider,
    'but this way is a better for educational purposes
    Set oRoot = GetObject(G_cfgADString & "://rootDSE")
    'work in the default domain
    sDomain = oRoot.Get("defaultNamingContext")
    Set oDomain = GetObject(G_cfgADString & "://" & sDomain)
    sBase = "<" & oDomain.ADsPath & ">"
    'Only get user name requested
    sFilter = "(&(objectCategory=person)(objectClass=user)(SAMAccountName=" _
      & LoginName & "))"
    sAttribs = "adsPath"
    sDepth = "subTree"
    
    sQuery = sBase & ";" & sFilter & ";" & sAttribs & ";" & sDepth
                       
    conn.Open _
      "Data Source=Active Directory Provider;Provider=ADsDSOObject"
      
    Set rs = conn.Execute(sQuery)
    
    If Not rs.EOF Then
        Set user = GetObject(rs("adsPath"))
        With user
        
        'if the attribute is not stored in AD,
        'an error will occur.  Therefore, this
        'will return data only from populated attributes
           On Error Resume Next
           sAns = .EmailAddress
        End With
    End If
    
    ADGetUserMailAddress = sAns

ErrHandler:

    On Error Resume Next
    If Not rs Is Nothing Then
        If rs.state <> 0 Then rs.Close
        Set rs = Nothing
    End If
    
    If Not conn Is Nothing Then
        If conn.state <> 0 Then conn.Close
        Set conn = Nothing
    End If
    
    Set oRoot = Nothing
    Set oDomain = Nothing
End Function



' Enables / Disables the close button on the titlebar and in the system menu
' of the form window passed.
' Return Values:
'
'    0  Close button state changed succesfully / nothing to do.
'   -1  Invalid Window Handle (hWnd argument) Passed to the function
'   -2  Failed to switch command ID of Close menu item in system menu
'   -3  Failed to switch enabled state of Close menu item in system menu

#If VBA7 And Win64 Then
  Public Function EnableCloseButton(ByVal hwnd As LongPtr, enable As Boolean) As Integer
#Else
  Public Function EnableCloseButton(ByVal hwnd As Long, enable As Boolean) As Integer
#End If
Const xSC_CLOSE As Long = -1051#    ' Check that the window handle passed is valid
EnableCloseButton = -1


  If IsWindow(hwnd) = 0 Then Exit Function
    ' Retrieve a handle to the window's system menu
#If VBA7 And Win64 Then
    Dim hMenu As LongPtr
#Else
    Dim hMenu As Long
#End If
    hMenu = GetSystemMenu(hwnd, 0)
    
    ' Retrieve the menu item information for the close menu item/button
    Dim MII As MENUITEMINFO
    MII.cbSize = Len(MII)
    MII.dwTypeData = String(80, 0)
    MII.cch = Len(MII.dwTypeData)
    MII.fMask = MIIM_STATE
       
    If enable Then
       MII.wID = xSC_CLOSE
    Else
       MII.wID = SC_CLOSE
    End If
       
    EnableCloseButton = 0
    
    If GetMenuItemInfo(hMenu, MII.wID, False, MII) = 0 Then Exit Function
    
    ' Switch the ID of the menu item so that VB can not undo the action itself
    Dim lngMenuID As Long
    lngMenuID = MII.wID
        
    If enable Then
        MII.wID = SC_CLOSE
    Else
        MII.wID = xSC_CLOSE
    End If
        
    MII.fMask = MIIM_ID
    EnableCloseButton = -2
        
    If SetMenuItemInfo(hMenu, lngMenuID, False, MII) = 0 Then Exit Function
    
    ' Set the enabled / disabled state of the menu item
    If enable Then
       MII.fState = (MII.fState Or MFS_GRAYED)
       MII.fState = MII.fState - MFS_GRAYED
    Else
       MII.fState = (MII.fState Or MFS_GRAYED)
     End If
     MII.fMask = MIIM_STATE
     EnableCloseButton = -3
        
     If SetMenuItemInfo(hMenu, MII.wID, False, MII) = 0 Then Exit Function
     SendMessage hwnd, WM_NCACTIVATE, True, 0
     EnableCloseButton = 0
End Function


Public Sub DeleteFiles(mypath As String, templ As String)
  On Error Resume Next
  If templ = "" Then templ = "*.*"
  Dim MyFile As String
  MyFile = Dir$(mypath & templ)
  Do While MyFile <> ""
      Kill mypath & MyFile
      MyFile = Dir
  Loop
End Sub


Public Function CreateTempFile(sPrefix As String) As String
   Dim sTmpPath As String * 512
   Dim sTmpName As String * 576
   Dim nRet As Long

   nRet = apiGetTempPath(512, sTmpPath)
   If (nRet > 0 And nRet < 512) Then
      nRet = GetTempFileName(sTmpPath, sPrefix, 0, sTmpName)
      If nRet <> 0 Then
         CreateTempFile = Left$(sTmpName, _
            InStr(sTmpName, vbNullChar) - 1)
         MyKill CreateTempFile
      End If
   End If
End Function


Private Function PatternMatching(ByVal s As String, ByVal pat As String) As Boolean
    Dim i, l As Integer

    If pat = "" And s = "" Then
        PatternMatching = True
        Exit Function
    End If
    If pat = "" Then
        PatternMatching = False
        Exit Function
    End If
    If Left(pat, 1) = "*" Then
        If Len(pat) = 1 Then
            PatternMatching = True
            Exit Function
        End If

        l = Len(s)
        For i = 1 To l
            If Mid(s, i, 1) = Mid(pat, 2, 1) Or Mid(pat, 2, 1) = "?" Then
            ' 2 Zeichen (* und ?) vom Pattern |fffd|berspringen
                If PatternMatching(Mid(s, i + 1), Mid(pat, 3)) = True Then
                    PatternMatching = True
                    Exit Function
                End If
            End If
        Next
    End If

    If Len(s) = 0 Then
        PatternMatching = False
        Exit Function
    End If
    If Left(pat, 1) = "?" Or Left(pat, 1) = Left(s, 1) Then
        If PatternMatching(Mid(s, 2), Mid(pat, 2)) = True Then
            PatternMatching = True
            Exit Function
        End If
    End If

    PatternMatching = False
End Function


Public Function PatternIsStartMatching(ByVal s As String, ByVal wildcard As String) As Boolean

    ' einfach ein * anh|fffd|ngen, dann passt das Ende einfach durch den Wildcard *
    If Right(wildcard, 1) <> "*" Then
        wildcard = wildcard + "*"
    End If

    PatternIsStartMatching = s Like wildcard ' PatternMatching(s, wildcard)

End Function

Function WorksheetExists(ByRef wb, wsname As String) As Boolean
  On Error GoTo nogo
  Dim ws
  Set ws = wb.Worksheets(wsname)
  Set ws = Nothing
  WorksheetExists = True
  Exit Function
nogo:
End Function


Public Function DateinameMitVersionsnummer(name As String, Version As String, mitDatum As Boolean, ByVal dat As Date)

    ' nur den Dateinamen nehmen
    Dim slash As Long
    slash = InStrRev(name, "\")
    If slash > 0 Then
        name = Mid(name, slash + 1)
    Else
      slash = InStrRev(name, "/")
      If slash > 0 Then
          name = Mid(name, slash + 1)
      End If
    End If
    Version = Trim(Version)

    ' und vor der Extension noch die Versionsnummer eintragen
    Dim dot As Long
    dot = InStrRev(name, ".")
    If dot > 0 Then
        Dim ext As String
        ext = Mid(name, dot)

        name = Left(name, dot - 1) & "_V" & Version
        If mitDatum Then
            name = name & "_" & Format(year(dat), "0000") & "_" & Format(month(dat), "00") & "_" & Format(day(dat), "00")
        End If
        name = name & ext
    Else
        name = name & "_V" & Version
        If mitDatum Then
            name = name & "_" & Format(year(dat), "0000") & "_" & Format(month(dat), "00") & "_" & Format(day(dat), "00")
        End If
    End If

    DateinameMitVersionsnummer = name

End Function


'#If VBA7 And Win64 Then
'    Private Declare PtrSafe Function GetCursorPos Lib "user32.dll" (lpPoint As POINTAPI) As Long
'    #If Win64 Then
'        Private Declare PtrSafe Function AccessibleObjectFromPoint Lib "Oleacc" (ByVal arg1 As LongPtr, ppacc As IAccessible, pvarChild As Variant) As Long
'        Private Declare PtrSafe Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (Destination As Any, Source As Any, ByVal Length As LongPtr)
'    #Else
'        Private Declare PtrSafe Function AccessibleObjectFromPoint Lib "Oleacc" (ByVal lX As Long, ByVal lY As Long, ppacc As IAccessible, pvarChild As Variant) As Long
'    #End If
'#Else
'    Private Declare Function GetCursorPos Lib "user32" (lpPoint As POINTAPI) As Long
'    Private Declare Function AccessibleObjectFromPoint Lib "Oleacc" (ByVal lX As Long, ByVal lY As Long, ppacc As IAccessible, pvarChild As Variant) As Long
'#End If

#If VBA7 And Win64 Then
  Public Function TimerProc(ByVal lHwnd As LongPtr, ByVal uMsg As Long, ByVal lIDEvent As Long, ByVal lDWTime As Long) As Long
      Dim lEditHwnd As LongPtr
      lEditHwnd = FindWindowEx(FindWindow("#32770", gMsgTitle), 0, "Edit", "")
      Call SendMessage(lEditHwnd, EM_SETPASSWORDCHAR, Asc("*"), 0)
      KillTimer lHwnd, lIDEvent
  End Function
#Else
  Public Function TimerProc(ByVal lHwnd&, ByVal uMsg&, ByVal lIDEvent&, ByVal lDWTime&) As Long
      Dim lEditHwnd As Long
      lEditHwnd = FindWindowEx(FindWindow("#32770", gMsgTitle), 0, "Edit", "")
      Call SendMessage(lEditHwnd, EM_SETPASSWORDCHAR, Asc("*"), 0)
      KillTimer lHwnd, lIDEvent
  End Function
#End If



Function InputBoxPW(title As String, txt As String) As String

  gMsgTitle = title
  Beep
 
  SetTimer 0, NV_INPUTBOX, 1, AddressOf TimerProc
  
  InputBoxPW = InputBox(txt, title)

End Function

Public Function GetTitleText() As String
    GetTitleText = ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
End Function

#If VBA7 And Win64 Then
Public Function FARPROC(pfn As LongPtr) As LongPtr
    'A dummy procedure that receives and returns
    'the value of the AddressOf operator.
    
    FARPROC = pfn
End Function
#End If

' Rolf XLAM
Public Function AreFilesTheSame(ByVal File1 As String, _
  ByVal File2 As String) As Boolean
'**********************************************************
'PURPOSE: Check to see if two files are identical
'File1 and File2 = FullPaths of files to compare
'byte by byte comparison is conducted if file lengths are
'equal
'**********************************************************
AreFilesTheSame = False

On Error GoTo ErrorHandler

If Dir(File1) = "" Then Exit Function
If Dir(File2) = "" Then Exit Function

Dim lLen1 As Long, lLen2 As Long
Dim iFileNum1 As Integer
Dim iFileNum2 As Integer
Dim bytArr1() As Byte, bytArr2() As Byte
Dim lCtr As Long, lStart As Long
Dim bAns As Boolean

lLen1 = MyFileLen(File1)
lLen2 = MyFileLen(File2)
If lLen1 <> lLen2 Then
    Exit Function
Else
    iFileNum1 = FreeFile
    Open File1 For Binary Access Read As #iFileNum1
    iFileNum2 = FreeFile
    Open File2 For Binary Access Read As #iFileNum2

    'put contents of both into byte Array
    bytArr1() = InputB(LOF(iFileNum1), #iFileNum1)
    bytArr2() = InputB(LOF(iFileNum2), #iFileNum2)
    lLen1 = UBound(bytArr1)
    lStart = LBound(bytArr1)
    
    bAns = True
    For lCtr = lStart To lLen1
        If bytArr1(lCtr) <> bytArr2(lCtr) Then
            bAns = False
            Exit For
        End If
            
    Next
    AreFilesTheSame = bAns
       
End If
 
ErrorHandler:
If iFileNum1 > 0 Then Close #iFileNum1
If iFileNum2 > 0 Then Close #iFileNum2
End Function


Sub ShowStatusForm(ByVal capt As String, Optional abbruchvisible As Boolean = True)
  G_StatusFormAbbruch = False
  If StatusForm.visible = False Then
    Load StatusForm
  End If
  StatusForm.cmdAbbruch.visible = abbruchvisible
  StatusForm.CurrentStatus = capt
  StatusForm.LabelProgress.width = 0
  StatusForm.FrameProgress.Caption = Format(0, "0%")
  StatusForm.Show False
  DoEvents
End Sub

Sub HideStatusForm()
  If StatusForm.visible Then
    UpdateStatusForm "", -1
    StatusForm.Hide
    VBA.Global.Unload StatusForm
  End If
End Sub


Sub UpdateStatusForm(txt As String, percentDone As Double)
  If StatusForm.visible Then
    StatusForm.CurrentStatus = txt
    If percentDone >= 0 Then
      StatusForm.FrameProgress.Caption = Format(percentDone, "0%")
      StatusForm.LabelProgress.width = percentDone * (StatusForm.FrameProgress.width - 10)
    End If
  End If
  DoEvents
End Sub

Sub ShowStatusFormLocal(ByRef frm As UserForm)
  frm.LabelProgress.width = 0
  frm.FrameProgressText.Caption = Format(0, "0%")
  frm.FrameProgressText.visible = True
  frm.FrameProgress.visible = True
  frm.LabelProgress.visible = True
  DoEvents
End Sub

Sub HideStatusFormLocal(ByRef frm As UserForm)
  frm.FrameProgressText.visible = False
  frm.FrameProgress.visible = False
  frm.LabelProgress.visible = False
End Sub

Sub UpdateStatusFormLocal(ByRef frm As UserForm, percentDone As Double)
  If percentDone >= 0 Then
    frm.FrameProgressText.Caption = Format(percentDone, "0%")
    frm.LabelProgress.width = percentDone * (frm.FrameProgress.width - 10)
  End If
  DoEvents
End Sub


Public Function GetMinDbl(ByVal a As Double, ByVal b As Double) As Double
    If a < b Then
        GetMinDbl = a
    Else
        GetMinDbl = b
    End If
End Function

Public Function GetMaxDbl(ByVal a As Double, ByVal b As Double) As Double
    If a >= b Then
        GetMaxDbl = a
    Else
        GetMaxDbl = b
    End If
End Function

Function GetMax(ByVal a As Integer, ByVal b As Integer) As Integer
    If a >= b Then
        GetMax = a
    Else
        GetMax = b
    End If
End Function

Function GetMin(ByVal a As Integer, ByVal b As Integer) As Integer
    If a >= b Then
        GetMin = b
    Else
        GetMin = a
    End If
End Function


Public Function ClampDbl(val As Double, min As Double, max As Double) As Double
    ClampDbl = GetMinDbl(GetMaxDbl(val, min), max)
End Function

Public Sub CleanUpTempFiles()
On Error GoTo nogo
  Dim tDir As String
  tDir = GetTempPath()
  
  If FileExists(tDir & "\IDVS-Tfls-" & GetUserName() & ".tmp") Then
    MyKill tDir & "\IDVS-Tfls-" & GetUserName() & ".tmp2"
    Name tDir & "\IDVS-Tfls-" & GetUserName() & ".tmp" As tDir & "\IDVS-Tfls-" & GetUserName() & ".tmp2"
    
    Dim ff As Long
    ff = FreeFile
    Dim s As String
    
    Open tDir & "\IDVS-Tfls-" & GetUserName() & ".tmp2" For Input As #ff
    On Error GoTo fileAccessError
    Do While Not EOF(ff)
      Line Input #ff, s
      If Len(Trim(s)) > 0 Then
        MyKill Trim(s)
        If FileExists(Trim(s)) Then
          AddTextToFile Trim(s), tDir & "\IDVS-Tfls-" & GetUserName() & ".tmp"
        End If
      End If
    Loop
fileAccessError:
    Close #ff
    MyKill tDir & "\IDVS-Tfls-" & GetUserName() & ".tmp2"
  End If
  Exit Sub

nogo:
End Sub

Function IsFileReadOnly(wbInExcelCurrentProjectInAccess As Object) As Boolean
  On Error GoTo CantDetermineReadOnly
  IsFileReadOnly = wbInExcelCurrentProjectInAccess.readOnly
  Exit Function
CantDetermineReadOnly:
  IsFileReadOnly = True
End Function


Private Function FOpen(fname As String, ByRef fn As Long) As Boolean
  On Error GoTo nogo
  Open fname For Binary Access Read As fn
  FOpen = True
  Exit Function
nogo:
        
End Function

Private Function FOpenWrite(fname As String, ByRef fn As Long) As Boolean
  On Error GoTo nogo
  Open fname For Binary Access Write As fn
  FOpenWrite = True
  Exit Function
nogo:
        
End Function

Private Function FClose(ByRef fn As Long) As Boolean
  On Error GoTo nogo
  Close fn
  FClose = True
  Exit Function
nogo:
        
End Function
Function SplitFile(ByVal filename As String, ByVal splitSize As Long, ByRef splitFilenames() As String) As Boolean

    SplitFile = False

On Error GoTo nogo
    
    Dim fileLen As Long
    fileLen = MyFileLen(filename)
    
    ' wenn wir kleiner sind als 1 Split, dann wird nicht gesplitted
    If fileLen <= splitSize Then
        Exit Function
    End If

    Dim steps As Long
    steps = (fileLen / splitSize)
    Dim remainingSize As Long
    remainingSize = fileLen Mod splitSize
    ' wenn es genau ein Vielfaches der SplitSize ist, dann m|fffd|ssen wir einen Split weniger machen
    If remainingSize = 0 Then
        steps = steps - 1
    End If
        
    Dim fn As Long
    fn = FreeFile
    
    Dim einMB As Long
    einMB = CLng(1024) * CLng(1024)

    SplitFile = True
    
    ReDim Preserve splitFilenames(steps)

    Dim buffer(CLng(1024) * CLng(1024) - CLng(1)) As Byte
    Dim BufferRemaining() As Byte
    If FOpen(filename, fn) Then
        Dim step
        For step = 0 To steps
            Dim fnOut As Long
            fnOut = FreeFile
            
            Dim fileNameOutput As String
            fileNameOutput = filename & "_" & step
            If FOpenWrite(fileNameOutput, fnOut) Then
                
                splitFilenames(step) = fileNameOutput
                
                Dim internalSteps As Long
                internalSteps = splitSize / einMB
                
                Dim intStep
                For intStep = 0 To internalSteps - 1
                    Dim strData As String
                    
                    If fileLen <= einMB Then
                        ReDim BufferRemaining(fileLen - 1)
                        Get #fn, , BufferRemaining
                        Put #fnOut, , BufferRemaining
                        Exit For
                    Else
                        Get #fn, , buffer
                        Put #fnOut, , buffer
                    End If
                    fileLen = fileLen - einMB
                Next
                Close #fnOut
            Else
                ' nicht geklappt, alles wieder l|fffd|schen
                SplitFile = False
                ' auf jeden Fall aufh|fffd|ren
                step = steps + 1
                Exit For
            End If
        Next
        Close #fn
    End If

    Exit Function
nogo:
    SplitFile = False
End Function


Function JoinFile(ByVal filename As String, ByRef splitFilenames() As String) As Boolean

    JoinFile = False

On Error GoTo nogo
    
    Dim fnOut As Long
    fnOut = FreeFile
    
    Dim einMB As Long
    einMB = CLng(1024) * CLng(1024)

    Dim buffer(CLng(1024) * CLng(1024) - CLng(1)) As Byte
    Dim BufferRemaining() As Byte
    If FOpenWrite(filename, fnOut) Then
        Dim step
        For step = LBound(splitFilenames) To UBound(splitFilenames)
            Dim fn As Long
            fn = FreeFile
            
            If FOpen(splitFilenames(step), fn) Then
                
                Dim fileLen As Long
                fileLen = MyFileLen(splitFilenames(step))
                
                Dim internalSteps As Long
                internalSteps = (fileLen + einMB - 1) / einMB
                
                Dim intStep
                For intStep = 0 To internalSteps - 1
                    Dim strData As String
                    
                    If fileLen <= einMB Then
                        ReDim BufferRemaining(fileLen - 1)
                        Get #fn, , BufferRemaining
                        Put #fnOut, , BufferRemaining
                        Exit For
                    Else
                        Get #fn, , buffer
                        Put #fnOut, , buffer
                    End If
                    fileLen = fileLen - einMB
                Next
                Close #fn
            Else
                ' nicht geklappt, alles wieder l|fffd|schen
                JoinFile = False
                ' auf jeden Fall aufh|fffd|ren
                step = UBound(splitFilenames) + 1
                Exit For
            End If
        Next
        Close #fnOut
    End If

    Exit Function
nogo:
    JoinFile = False
End Function

Sub AddStringToCollection(ByRef c As Collection, v As String, K As String)
  On Error GoTo nogo
  c.add v, K
nogo:
End Sub

Sub AddObjectToCollection(ByRef c As Collection, ByRef v, K As String)
  On Error GoTo nogo
  c.add v, K
nogo:
End Sub

Sub ReplaceObjectInCollection(ByRef col As Collection, ByRef obj As Object, ByVal s As String)
  Dim t As Object
  On Error GoTo nogo
  Set t = col(s)
  col.Remove s
nogo:
  col.add obj, s
End Sub


Sub ReplaceStringInToupleCollections(ByRef col As Collection, ByRef colTouple As Collection, ByVal t As String, ByVal s As String)
  ReplaceStringInCollection col, t, s
  If Not colTouple Is Nothing Then
    Dim css As CStringTouple
    Set css = New CStringTouple
    css.m_Name = s
    css.m_Text = t
    ReplaceObjectInCollection colTouple, css, s
  End If
End Sub


Sub ReplaceStringInCollection(ByRef col As Collection, ByVal t As String, ByVal s As String)
  Dim ts As String
  On Error GoTo nogo
  ts = col(s)
  col.Remove s
nogo:
  col.add t, s
End Sub


Public Function IsTestUser() As Boolean
  Dim curUser As String
  curUser = GetUserName
    If curUser = "dirk" Or _
        curUser = "dwinter" Or _
        curUser = "norman" Or _
        curUser = "nneubert" Or _
        curUser = "rolf" Or _
        curUser = "rlangenberg" Then
        
        IsTestUser = True
    End If
End Function

Public Function GetNextValue(ByVal sbsValue As String, ByRef startIndex As Long) As String

    Dim l As Long
    l = Len(sbsValue)
    Dim startAnfuehrungsstriche As Long
    Dim anfuehrungsstriche As Long
    Dim laenge As Long
    
    Dim nextValue As String
    nextValue = ""
    
    If startIndex <= l Then
        laenge = 0
        If Mid(sbsValue, startIndex, 1) = Chr$(34) Then
            startAnfuehrungsstriche = 1
            anfuehrungsstriche = 1
            startIndex = startIndex + 1
        End If
        
        While startIndex + laenge <= l
            Dim c As String
            c = Mid(sbsValue, startIndex + laenge, 1)
            If c = Chr$(34) Then
                ' 3 Anf|fffd|hrungszeichen sind dann
                If Mid(sbsValue, startIndex + laenge, 2) = Chr$(34) & Chr$(34) Then
                    laenge = laenge + 2
                Else
                    anfuehrungsstriche = 1 - anfuehrungsstriche
                    laenge = laenge + 1
                End If
            ElseIf c = ";" Then
                If anfuehrungsstriche = 0 Then
                    GoTo raus
                Else
                    laenge = laenge + 1
                End If
            Else
                laenge = laenge + 1
            End If
        Wend
raus:
        nextValue = Mid(sbsValue, startIndex, laenge - startAnfuehrungsstriche)
        ' nextValue = Replace(nextValue, Chr$(34) & Chr$(34), Chr$(34))
        startIndex = startIndex + laenge + 1
    End If
    GetNextValue = nextValue

End Function

Function IsFormLoaded(ByVal fname As String) As Boolean
'Pr|fffd|fen, ob Formular geladen

  Dim i As Integer

  IsFormLoaded = False
  For i = 0 To UserForms.count - 1
    If LCase$(UserForms(i).name) = LCase$(fname) Then
      IsFormLoaded = True
      Exit For
    End If
  Next i
  
End Function

Function ExtendSystemString(ByVal s As String, ByVal l As Long) As String
  ExtendSystemString = s & IIf(Len(s) < l, Space(l - Len(s)), "")
End Function

Sub CopyTextToClipboard(txt As String)
    'VBA Macro using late binding to copy text to clipboard.
    'By Justin Kay, 8/15/2014
    'Thanks to http://akihitoyamashiro.com/en/VBA/LateBindingDataObject.htm
    On Error Resume Next
    Dim MSForms_DataObject As Object
    Set MSForms_DataObject = CreateObject("new:{1C3B4210-F441-11CE-B9EA-00AA006B1A69}")
    MSForms_DataObject.SetText txt
    MSForms_DataObject.PutInClipboard
    Set MSForms_DataObject = Nothing
End Sub

Function CorrectErrorCharactersInFilename(ByVal filename As String) As String
  filename = Replace(filename, "/", "_")
  filename = Replace(filename, "\", "_")
  filename = Replace(filename, "|", "_")
  filename = Replace(filename, "*", "_")
  filename = Replace(filename, "<", "_")
  filename = Replace(filename, ">", "_")
  filename = Replace(filename, "?", "_")
  filename = Replace(filename, ":", "_")
  CorrectErrorCharactersInFilename = filename
End Function

Function UserInCommaSeparatedList(ByVal username As String, ByVal csvtext As String) As Boolean
  Dim s() As String
  s = Split(csvtext, ",")
  Dim i As Long
  Dim a
  username = Trim(UCase(username))
  For i = LBound(s) To UBound(s)
      If username = Trim(UCase(s(i))) Then
        UserInCommaSeparatedList = True
        Exit Function
      End If
  Next i

End Function

Function StoreFile(ByVal fname As String, ByVal txt As String, ByRef errstr As String) As Boolean
On Error GoTo nogo
'  If Not FileExists(fname) Then Exit Function
  Dim FileNumber
  FileNumber = FreeFile
  
  If Not MyOpenFile(FileNumber, fname, tOutput) Then
      Exit Function
  End If
  Print #FileNumber, txt
  Close #FileNumber
  StoreFile = True
  Exit Function
nogo:
  errstr = err.Number & " - " & err.Description
End Function

Function LoadFile(ByVal fname As String, ByRef txt As String, ByRef errstr As String) As Boolean
On Error GoTo nogo
  If Not FileExists(fname) Then
    errstr = "Datei '" & fname & "' nicht gefunden."
    Exit Function
  End If
  Dim FileNumber
  FileNumber = FreeFile
  
  If Not MyOpenFile(FileNumber, fname, tInput) Then
      Exit Function
  End If
  Dim s As String
  txt = ""
  Do While Not EOF(FileNumber)
    Line Input #FileNumber, s
    txt = txt & vbCrLf & s
  Loop
  Close #FileNumber
  LoadFile = True
  Exit Function
nogo:
  errstr = err.Number & " - " & err.Description
End Function

Function MyMsgBox(ByVal txt As String, Optional ByVal buttons As VbMsgBoxStyle = vbOKOnly, Optional ByVal title As String = "") As Long
  If Len(txt) < 1024 Then
    MyMsgBox = MsgBox(txt, buttons, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")" & IIf(title <> "", " - " & FMT0("THISADDIN_48"), ""))
  Else
    With CreateObject("wscript.shell")
        Dim en As Boolean
        en = Application.EnableEvents
        If buttons Or vbSystemModal = vbSystemModal Then
          Application.ScreenUpdating = False
        End If
        MyMsgBox = .Popup(txt, 0, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")" & IIf(title <> "", " - " & FMT0("THISADDIN_48"), ""), buttons)
        If buttons Or vbSystemModal = vbSystemModal Then
          Application.ScreenUpdating = en
        End If
    End With
  End If
End Function
Attribute VB_Name = "IDHandler"
Option Explicit

    Function GetNewID(ByVal tabname As String, ByRef conn As Object) As Long
        Dim rs As Object
        On Error Resume Next

        Set rs = OpenRS("SELECT * FROM gIDs WHERE Tabelle='" & tabname & "'", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockPessimistic)
        If rs Is Nothing Then
            GetNewID = -1
            Exit Function
        End If

        If rs.EOF Then
            rs.AddNew
            rs.Fields("Tabelle").value = tabname
            rs.Fields("ID").value = 1
            rs.Update
            GetNewID = 1
            Exit Function
        Else
            rs.Fields("ID").value = rs.Fields("ID").value + 1
            GetNewID = rs.Fields("ID").value
            rs.Update
        End If

        rs.Close
        Set rs = Nothing
    End Function

Attribute VB_Name = "INetStuff"
Option Explicit

#If VBA7 And Win64 Then
Declare PtrSafe Function URLDownloadToFile Lib "urlmon" Alias "URLDownloadToFileA" _
(ByVal pCaller As Long, ByVal szURL As String, ByVal szFileName As String, _
ByVal dwReserved As Long, ByVal lpfnCB As Long) As Long
#Else
Declare Function URLDownloadToFile Lib "urlmon" Alias "URLDownloadToFileA" _
(ByVal pCaller As Long, ByVal szURL As String, ByVal szFileName As String, _
ByVal dwReserved As Long, ByVal lpfnCB As Long) As Long
#End If


Public Function URLEncode(StringVal As String) As String

  ' ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~:/?#[]@!$&'()*+,;=
  Dim i As Long
  Dim r As String
  For i = 1 To Len(StringVal)
    If InStr("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~:/?#[]@!$&'()*+,;=", Mid(StringVal, i, 1)) > 0 Then
      r = r & Mid(StringVal, i, 1)
    Else
      r = r & "%" & Hex(Asc(Mid(StringVal, i, 1)))
    End If
  Next i
  
  URLEncode = r

End Function
Public Function DownloadFile(fname As String, destFName As String, Optional fsize As Long = 0) As Boolean
'    DownloadFile = IIf(URLDownloadToFile(0, fname, destFName, 0, 0) = 0, True, False)
  On Error GoTo nogo
  DownloadFile = False
  
  Dim WinHttpReq As Object
  Set WinHttpReq = CreateObject("Microsoft.XMLHTTP")
  WinHttpReq.Open "GET", URLEncode(fname), False ' , "username", "password"
  WinHttpReq.send
  
  ' myURL = WinHttpReq.responseBody
  Dim oStream
  If WinHttpReq.status = 200 Then
      Set oStream = CreateObject("ADODB.Stream")
      oStream.Open
      oStream.Type = 1
      oStream.Write WinHttpReq.responseBody
      oStream.SaveToFile destFName, 2 ' 1 = no overwrite, 2 = overwrite
      oStream.Close
  End If
  DownloadFile = True
  
  Exit Function
nogo:
  
End Function






Attribute VB_Name = "ListHandler"
Option Explicit

Attribute VB_Name = "Localisation"
Option Explicit

' Diese beiden arrays bilden die alten gStandardtexte.textbezeichnung auf die neuen string table IDs ab
Private mStdTextIDs() As String
Private mStringTableIDs() As String


Public Sub InitLoc()
    mStdTextIDs = Split("SMTPMAILFREIGABE,SMTPMAILFREIGABEABBRUCH,SMTPFREIGABEBETREFF,SMTPFREIGABEABBRUCHBETREFF," & _
                  "SMTPFREIGABEERTEILENBETREFF,SMTPMAILFREIGABEERTEILEN,SIGNOFFTEXT,SMTPMAILINFORISIKOKLASSE," & _
                  "SMTPMAILINFORISIKOKLASSEBTRFF,FREIGABECHECKSUMMEGEAENDERT,WARNMELDUNGBEIABGELAUFENEMDATUM,SPERRMELDUNGBEIABGELAUFENEMDATUM," & _
                  "HINWEISTEXTBEISIGNOFF,TITELINDIVIDUELLESTEXTFELD1,TITELINDIVIDUELLESTEXTFELD2,INTEGRITAET_GERING," & _
                  "INTEGRITAET_MITTEL,INTEGRITAET_HOCH,INTEGRITAET_SEHR_HOCH,VERFUEGBARKEIT_GERING,VERFUEGBARKEIT_MITTEL," & _
                  "VERFUEGBARKEIT_HOCH,VERFUEGBARKEIT_SEHR_HOCH,VERTRAULICHKEIT_GERING,VERTRAULICHKEIT_MITTEL,VERTRAULICHKEIT_HOCH," & _
                  "VERTRAULICHKEIT_SEHR_HOCH,INFORMATIONSKLASSE_S1,INFORMATIONSKLASSE_S2,INFORMATIONSKLASSE_S3,INFORMATIONSKLASSE_S4," & _
                  "INFORMATIONSKLASSE_S5,SCHUTZBEDARF_GERING,SCHUTZBEDARF_MITTEL,SCHUTZBEDARF_HOCH,SCHUTZBEDARF_SEHR_HOCH,PROZESS_EBENE_1," & _
                  "PROZESS_EBENE_2,PROZESS_EBENE_3,FRAGENDIALOGKOMMENTAR,UEBERSCHRIFTPROZESSAUSWAHL,AUTHENTIZITAET_GERING,AUTHENTIZITAET_MITTEL,AUTHENTIZITAET_HOCH,AUTHENTIZITAET_SEHR_HOCH", ",")
    mStringTableIDs() = Split("ST_1,ST_2,ST_3,ST_4,ST_5,ST_6,ST_7,ST_8,ST_9,ST_10,ST_11,ST_13,ST_14,ST_15,ST_16,ST_17,ST_18," & _
                        "ST_19,ST_20,ST_21,ST_22,ST_23,ST_24,ST_25,ST_26,ST_27,ST_28,ST_29,ST_30,ST_31,ST_32,ST_33,ST_34,ST_35," & _
                        "ST_36,ST_37,ST_38,ST_39,ST_40,ST_41,ST_42,ST_45,ST_46,ST_47,ST_48", ",")
End Sub

Public Function STDTEXT(id As String) As String
  STDTEXT = ""
  Dim i As Long
  Dim cmp As String
  cmp = UCase(id)
  For i = 0 To UBound(mStdTextIDs)
    If mStdTextIDs(i) = cmp Then
      Exit For
    End If
  Next i
  If i <= UBound(mStringTableIDs) Then
    STDTEXT = FMT0(mStringTableIDs(i))
  End If
End Function


#If raus Then

Public Sub LoadLocStringGroup(ByRef conn As Connection, ByRef col As Collection, ParamArray var() As Variant)

 '   On Error Resume Next
    Dim rs As Object
    Dim q As String
    Dim s As String
    Dim i As Long
    
    
    If UBound(var) > 0 Then
      For i = LBound(var) To UBound(var)
        s = s & IIf(s <> "", ",", "") & "'" & var(i) & "'"
      Next
    
      q = "Select s.textbezeichnung, u.wert from gUebersetzungen u inner join gStandardtexte s on s.textid = u.textid where u.sprachid = " & "0" & " and s.textbezeichnung in (" & s & ")"
      Set rs = OpenRS(q, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
      If Not rs Is Nothing Then
          Do While rs.EOF = False
            col.add rs.Fields("wert").value, rs.Fields("textbezeichnung").value
            rs.MoveNext
          Loop
          rs.Close
      End If
      Set rs = Nothing
    End If

End Sub


Public Function GetLocString(ByRef conn As Connection, ByVal textID As String)

    ' holt derzeit nur den deutschen Text ab
    GetLocString = ""
    
 '   On Error Resume Next
    Dim rs As Object
    Dim q As String
    q = "Select u.wert from gUebersetzungen u inner join gStandardtexte s on s.textid = u.textid where u.sprachid = " & "0" & " and s.textbezeichnung LIKE '" & textID & "'"
    Set rs = OpenRS(q, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
    If Not rs Is Nothing Then
        If rs.EOF = False Then
            GetLocString = rs.Fields("wert").value
        End If
        rs.Close
    End If
    Set rs = Nothing

End Function

Public Function GetLocStringConn(ByVal textID As String)
    GetLocStringConn = ""
    
    On Error Resume Next
    Dim conn As Object
    Set conn = GetConnection()
    If Not conn Is Nothing Then
        GetLocStringConn = GetLocString(conn, textID)
        conn.Close
    End If
    Set conn = Nothing

End Function


Sub TestGetText()
    Dim conn As Object
    Set conn = GetConnection
    Set G_HighResTimer = New HighResTimer
    G_HighResTimer.DoStart
    G_HighResTimer.StartCounting "GetText"
    
    Dim rs As Object
    Dim q As String
    q = "Select u.wert from gUebersetzungen u inner join gStandardtexte s on s.textid = u.textid where u.sprachid = " & "0"
    Set rs = OpenRS(q, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
    If Not rs Is Nothing Then
        If rs.EOF = False Then
          Do While Not rs.EOF
            Debug.Print rs.Fields("wert").value
            rs.MoveNext
          Loop
        End If
        rs.Close
    End If
    Set rs = Nothing
    
    DebugPrint DebType.tTime, "!T Texttime", G_HighResTimer.GetCount("GetText")
    G_HighResTimer.StopCounting "GetText"
    conn.Close
    Set conn = Nothing
    G_HighResTimer.DoStop
    Set G_HighResTimer = Nothing

End Sub
#End If
Attribute VB_Name = "MailSenden"
Option Explicit

    Public G_PARAM_SMTPMailVersandAktiv As Boolean
    Public G_PARAM_SMTPSender As String
    Public G_PARAM_SMTPServer As String
    Public G_PARAM_SMTPFreigabeAbbruchBetreff As String
    Public G_PARAM_SMTPMailFreigabeAbbruch As String
    Public G_PARAM_SMTPEmpfaenger_ProgrammfreigabenA As String
    Public G_PARAM_SMTPEmpfaenger_ProgrammfreigabenB As String
    Public G_PARAM_SMTPFreigabeBetreff As String
    Public G_PARAM_SMTPMailFreigabe As String
    Public G_PARAM_SMTPFreigabeErteilenBetreff As String
    Public G_PARAM_SMTPMailFreigabeErteilen As String
    Public G_PARAM_SMTPMailInfoRisikoklasseBetreff As String
    Public G_PARAM_SMTPMailInfoRisikoklasse As String
    Public G_PARAM_EMailListe As Boolean



    Private Const cdoSendUsingMethod As String = "http://schemas.microsoft.com/cdo/configuration/sendusing"
    Private Const cdoSMTPServer As String = "http://schemas.microsoft.com/cdo/configuration/smtpserver"
    Private Const cdoSMTPServerPort As String = "http://schemas.microsoft.com/cdo/configuration/smtpserverport"

    Private Const INTERNET_CONNECTION_CONFIGURED As Integer = &H40
    Private Const INTERNET_CONNECTION_LAN As Integer = &H2
    Private Const INTERNET_CONNECTION_MODEM As Integer = &H1
    Private Const INTERNET_CONNECTION_OFFLINE As Integer = &H20
    Private Const INTERNET_CONNECTION_PROXY As Integer = &H4
    Private Const INTERNET_RAS_INSTALLED As Integer = &H10

#If VBA7 And Win64 Then
    ' Done
    Private Declare PtrSafe Function InternetGetConnectedState Lib "wininet.dll" (lpdwFlags As LongPtr, ByVal dwReserved As Long) As Boolean
#Else
    Private Declare Function InternetGetConnectedState Lib "wininet.dll" (ByRef lpdwFlags As Long, _
        ByVal dwReserved As Long) As Long
#End If

    Private L_UserName As String
    Private L_UserFullName As String
    Private L_UserMail As String

    Public ret As Long

    ' Begin Neu 15.1.2016
    Public Const ME_FreigabeInitiiert = 1&
    Public Const ME_FreigabeErteilt = 2&
    Public Const ME_FreigabeAbgebrochen = 3&
    Public Const ME_RisikoklasseGeaendert = 4&
    
    ' Access Data type enum
    ' https://msdn.microsoft.com/en-us/library/office/ff194420.aspx
    Public Const dbAttachment = 101&
    Public Const dbBigInt = 16&
    Public Const dbBinary = 9&
    Public Const dbBoolean = 1&
    Public Const dbByte = 2&
    Public Const dbChar = 18&
    Public Const dbComplexByte = 102&
    Public Const dbComplexDecimal = 108&
    Public Const dbComplexDouble = 106&
    Public Const dbComplexGUID = 107&
    Public Const dbComplexInteger = 103&
    Public Const dbComplexLong = 104&
    Public Const dbComplexSingle = 105&
    Public Const dbComplexText = 109&
    Public Const dbCurrency = 5&
    Public Const dbDate = 8&
    Public Const dbDecimal = 20& 'ODBCDirect only
    Public Const dbDouble = 7&
    Public Const dbFloat = 21& 'ODBCDirect only
    Public Const dbGUID = 15&
    Public Const dbInteger = 3&
    Public Const dbLong = 4&
    Public Const dbLongBinary = 11&
    Public Const dbMemo = 12&
    Public Const dbNumeric = 19& 'ODBCDirect only
    Public Const dbSingle = 6&
    Public Const dbText = 10&
    Public Const dbTime = 22& 'ODBCDirect only
    Public Const dbTimeStamp = 23& 'ODBCDirect only
    Public Const dbVarBinary = 17& 'ODBCDirect only
    
    ' ADO Data Type enum - ist natuerlich anderes als die von Access
    Public Const adEmpty = 0&               ' No value
    Public Const adSmallInt = 2&            ' A 2-byte signed integer.
    Public Const adInteger = 3&             ' A 4-byte signed integer.
    Public Const adSingle = 4&              ' A single-precision floating-point value.
    Public Const adDouble = 5&              ' A double-precision floating-point value.
    Public Const adCurrency = 6&            ' A currency value
    Public Const adDate = 7&                ' The number of days since December 30, 1899 + the fraction of a day.
    Public Const adBSTR = 8&                ' A null-terminated character string.
    Public Const adIDispatch = 9&           ' A pointer to an IDispatch interface on a COM object. Note: Currently not supported by Public Const adO.
    Public Const adError = 10&              ' A 32-bit error code
    Public Const adBoolean = 11&            ' A boolean value.
    Public Const adVariant = 12&            ' An Automation Variant. Note: Currently not supported by Public Const adO.
    Public Const adIUnknown = 13&           ' A pointer to an IUnknown interface on a COM object. Note: Currently not supported by Public Const adO.
    Public Const adDecimal = 14&            ' An exact numeric value with a fixed precision and scale.
    Public Const adTinyInt = 16&            ' A 1-byte signed integer.
    Public Const adUnsignedTinyInt = 17&    ' A 1-byte unsigned integer.
    Public Const adUnsignedSmallInt = 18&   ' A 2-byte unsigned integer.
    Public Const adUnsignedInt = 19&        ' A 4-byte unsigned integer.
    Public Const adBigInt = 20&             ' An 8-byte signed integer.
    Public Const adUnsignedBigInt = 21&     ' An 8-byte unsigned integer.
    Public Const adFileTime = 64&           ' The number of 100-nanosecond intervals since January 1,1601
    Public Const adGUID = 72&               ' A globally unique identifier (GUID)
    Public Const adBinary = 128&            ' A binary value.
    Public Const adChar = 129&              ' A string value.
    Public Const adWChar = 130&             ' A null-terminated Unicode character string.
    Public Const adNumeric = 131&           ' An exact numeric value with a fixed precision and scale.
    Public Const adUserDefined = 132&       ' A user-defined variable.
    Public Const adDBDate = 133&            ' A date value (yyyymmdd).
    Public Const adDBTime = 134&            ' A time value (hhmmss).
    Public Const adDBTimeStamp = 135&       ' A date/time stamp (yyyymmddhhmmss plus a fraction in billionths).
    Public Const adChapter = 136&           ' A 4-byte chapter value that identifies rows in a child rowset
    Public Const adPropVariant = 138&       ' An Automation PROPVARIANT.
    Public Const adVarNumeric = 139&        ' A numeric value (Parameter object only).
    Public Const adVarChar = 200&           ' A string value (Parameter object only).
    Public Const adLongVarChar = 201&       ' A long string value.
    Public Const adVarWChar = 202&          ' A null-terminated Unicode character string.
    Public Const adLongVarWChar = 203&      ' A long null-terminated Unicode string value.
    Public Const adVarBinary = 204&         ' A binary value (Parameter object only).
    Public Const adLongVarBinary = 205&     ' A long binary value.
    Public Const adArray = &H2000&          ' A flag value combined with another data type constant. Indicates an array of that other data type.
    ' End Neu 15.1.2016
    
Sub SetCurrentUserFullNameAndMail(ByRef conn As Object, userID As String)
    
    If L_UserName <> "" Then Exit Sub
    
    L_UserName = GetUserName
    
    Dim trs As Object
    
    Dim lastname As String, firstname As String, mailaddress As String
    ADGetUserInfo userID, lastname, firstname, mailaddress
    
    If lastname <> "" Then
      L_UserFullName = firstname & " " & lastname
      L_UserMail = mailaddress
    Else
      Set trs = OpenRS("SELECT Nachname, Vorname, eMail FROM gWindowsUserAktuell WHERE LogonID='" & UCase(userID) & "'", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
      If Not trs Is Nothing Then
          If Not trs.EOF Then
            L_UserFullName = GetSafeField(trs, "Vorname") & " " & GetSafeField(trs, "Nachname") & " " & lastname
            L_UserMail = GetSafeField(trs, "eMail")
          End If
          trs.Close
          Set trs = Nothing
      End If
    End If
    
End Sub


Function GetCurrentUserFullNameAndMail(ByRef conn As Object) As String
  
  SetCurrentUserFullNameAndMail conn, GetUserName

  GetCurrentUserFullNameAndMail = L_UserFullName & " - " & L_UserMail
    
End Function


Public Function GetCurrentUserMail(ByRef conn As Object) As String
    
  SetCurrentUserFullNameAndMail conn, GetUserName
    
  GetCurrentUserMail = L_UserMail
    
End Function

Public Function GetCurrentUserFullName(ByRef conn As Object) As String

  SetCurrentUserFullNameAndMail conn, GetUserName

  GetCurrentUserFullName = L_UserFullName

End Function


Public Function GetUserFullNameAndMail(ByRef conn As Object, userID As String) As String
    Dim trs As Object
    
    Dim lastname As String, firstname As String, mailaddress As String
    ADGetUserInfo userID, lastname, firstname, mailaddress
    
    If lastname <> "" Then
      GetUserFullNameAndMail = firstname & " " & lastname & " - " & mailaddress
    Else
      Set trs = OpenRS("SELECT Nachname, Vorname, eMail FROM gWindowsUserAktuell WHERE LogonID='" & UCase(userID) & "'", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
      If Not trs Is Nothing Then
          If Not trs.EOF Then
              GetUserFullNameAndMail = GetSafeField(trs, "Vorname") & " " & GetSafeField(trs, "Nachname") & " - " & GetSafeField(trs, "eMail")
          End If
          trs.Close
          Set trs = Nothing
      End If
    End If
    
End Function

Function GetUserMail(ByRef conn As Object, userID As String) As String
    Dim trs As Object
    
    Dim lastname As String, firstname As String, mailaddress As String
    ADGetUserInfo userID, lastname, firstname, mailaddress
    
    If lastname <> "" Then
      GetUserMail = mailaddress
    Else
      Set trs = OpenRS("SELECT eMail FROM gWindowsUserAktuell WHERE LogonID='" & UCase(userID) & "'", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
      If Not trs Is Nothing Then
          If Not trs.EOF Then
              GetUserMail = GetSafeField(trs, "eMail")
          End If
          trs.Close
          Set trs = Nothing
      End If
    End If
    
End Function

Function GetUserFullName(ByRef conn As Object, userID As String) As String
    Dim trs As Object
    
    Dim lastname As String, firstname As String, mailaddress As String
    ADGetUserInfo userID, lastname, firstname, mailaddress
    
    If lastname <> "" Then
      GetUserFullName = firstname & " " & lastname
    Else
      Set trs = OpenRS("SELECT Nachname, Vorname, eMail FROM gWindowsUserAktuell WHERE LogonID='" & UCase(userID) & "'", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
      If Not trs Is Nothing Then
          If Not trs.EOF Then
              GetUserFullName = GetSafeField(trs, "Vorname") & " " & GetSafeField(trs, "Nachname")
          End If
          trs.Close
          Set trs = Nothing
      End If
    End If
    
End Function

    Public Sub SMTPtest()
        '        Exit Sub

        Dim ipaddressserver As String
        Dim mailaddress As String

        '        ipaddressServer = "IP-Adresse SMTP-Server"
        '        mailaddress = "empf|fffd|nger@sparkasse-musterstadt.de"

        ipaddressserver = "localhost"
        mailaddress = "battroid@web.de"


        'Mail_senden Empf|fffd|nger, Absender, Betreff, Nachricht, SMTP-Server, Kopie-Empf|fffd|nger, Dateianhang
        Mail_senden Nothing, False, mailaddress, _
                    "ExcelTracker@idvtracker.de", _
                    "Testmail", _
                    "Dies ist eine Testmail!" & Chr(13) & Chr(10) & Chr(13) & Chr(10) & _
                    "... die per SMTP kommt" & Chr(13) & Chr(10) & _
                    "Diese Nachricht wurde aus der Anwendung ExcelTracker durch " & GetUserName & " erzeugt.", _
                    ipaddressserver, _
                    "", ""
    End Sub


Function SendSMTPMail(ByRef conn As Object, storeToTable As Boolean, ByVal mailfrom As String, ByVal mailto As String, ByVal mailCC As String, ByVal ipaddressserver As String, ByVal header As String, ByVal txt As String, ByVal logTxt As String, Optional attachmentFile As String = "") As Boolean
 
    '        ipaddressServer = "IP-Adresse SMTP-Server"
    '        mailaddress = "empf|fffd|nger@sparkasse-musterstadt.de"

    'Mail_senden Empf|fffd|nger, Absender, Betreff, Nachricht, SMTP-Server, Kopie-Empf|fffd|nger, Dateianhang
    
    If attachmentFile = "" Then
'      SendSMTPMail = Mail_senden(conn, storeToTable, mailto, _
'                  mailfrom, _
'                  header, _
'                  txt & vbCrLf & vbCrLf & _
'                  "Diese Nachricht wurde aus der Anwendung " & ProgNameLong & " durch " & GetUserName & " erzeugt.", _
'                  ipaddressserver, _
'                  mailCC, logTxt)
      SendSMTPMail = Mail_senden(conn, storeToTable, mailto, _
                  mailfrom, _
                  header, _
                  txt & vbCrLf & vbCrLf & _
                  FMT2("MAILSENDEN_1", ProgNameLong, GetUserName), _
                  ipaddressserver, _
                  mailCC, logTxt)
    Else
'      SendSMTPMail = Mail_senden(conn, storeToTable, mailto, _
'                  mailfrom, _
'                  header, _
'                  txt & vbCrLf & vbCrLf & _
'                  "Diese Nachricht wurde aus der Anwendung " & ProgNameLong & " durch " & GetUserName & " erzeugt.", _
'                  ipaddressserver, _
'                  mailCC, logTxt, attachmentFile)
      SendSMTPMail = Mail_senden(conn, storeToTable, mailto, _
                  mailfrom, _
                  header, _
                  txt & vbCrLf & vbCrLf & _
                  FMT2("MAILSENDEN_1", ProgNameLong, GetUserName), _
                  ipaddressserver, _
                  mailCC, logTxt, attachmentFile)
    End If
End Function

' Dirk Localization: Wird nicht benutzt
Function INetConnect() As String
#If VBA7 And Win64 Then
Dim l_dwflags As LongPtr
#Else
Dim l_dwflags As Long
#End If
 
    ret = InternetGetConnectedState(l_dwflags, 0&)
    If ret = 0 Then INetConnect = "No Internet connection!": Exit Function
    If (l_dwflags And INTERNET_CONNECTION_CONFIGURED) Then INetConnect = INetConnect & _
        "Local system has a valid connection to the Internet, but it may or may not be currently connected."
    If (l_dwflags And INTERNET_CONNECTION_LAN) Then INetConnect = INetConnect & _
        "Local system uses a local area network to connect to the Internet."
    If (l_dwflags And INTERNET_CONNECTION_MODEM) Then INetConnect = INetConnect & _
        "Local system uses a modem to connect to the Internet."
    If (l_dwflags And INTERNET_CONNECTION_OFFLINE) Then INetConnect = INetConnect & _
        "Local system is in offline mode."
    If (l_dwflags And INTERNET_CONNECTION_PROXY) Then INetConnect = INetConnect & _
        "Local system uses a proxy server to connect to the Internet."
    If (l_dwflags And INTERNET_RAS_INSTALLED) Then INetConnect = INetConnect & _
        "Local system has RAS installed."
 
End Function

' s_to hat dieses Format bei mehreren Empfaengern: "emailaddress1; emailaddress2; emailaddress3"
Function Mail_senden(ByRef conn As Object, storeToTable As Boolean, s_To As String, s_From As String, s_Subject As String, s_TextBody As String, s_mailserver As String, s_CC As String, logTxt As String, Optional s_Attachment As String) As Boolean
'Diese Prozedur versendet ein E-Mail, optional mit Attachment. Bei storeToMail gibts keine Attachments
    On Error Resume Next
    Mail_senden = False
    err.Clear
    If storeToTable Then
      
      Dim rs As Object
      Set rs = OpenRS("SELECT * FROM gMails", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockOptimistic)
      If Not rs Is Nothing Then
        rs.AddNew
        rs.Fields("Sender").value = Left(s_From, 255)
        rs.Fields("Empfaenger").value = Left(s_To, 255)
        rs.Fields("Betreff").value = Left(s_Subject, 255)
        rs.Fields("Text").value = s_TextBody
        rs.Fields("CCEmpfaenger").value = s_CC
        rs.Update
        rs.Close
        Set rs = Nothing
        DebugPrint DebType.tMail, " Mail an Scheduler |fffd|berstellt: " & s_To & " - " & logTxt

'        DebugPrint DebType.tMail, "Mail an Scheduler gesandt (" & s_To & ": '" & s_Subject & "') "
      End If
      Mail_senden = True
      Exit Function
    End If


    Dim eMail
    Dim s_attachment_array
    Dim i As Integer
     
    Set eMail = CreateObject("CDO.Message")
    With eMail
            
            With .Configuration.Fields
                .item(cdoSendUsingMethod) = 2   '=cdoSendUsingPort
                .item(cdoSMTPServer) = s_mailserver   'eigenen SMTP-Server eintragen
                .item(cdoSMTPServerPort) = 25   '=Standard, k|fffd|nnte aber auch abweichen
                .Update
            End With
    
       .To = s_To
       
       If s_CC <> "" Then
                .cc = s_CC
            End If
            
       .FROM = s_From
       .subject = s_Subject
       .TextBody = s_TextBody
        
        If s_Attachment <> "" Then
            '|fffd|berpr|fffd|fen, ob es mehrere Anlagen gibt (separiert durch ein Semikolon)
            If InStr(1, s_Attachment, ";") > 0 Then
                'Zerlegen der Dateinamen in ein Array
                s_attachment_array = Split(s_Attachment, ";")
                    'Durchlaufe das array...
                    For i = LBound(s_attachment_array) To UBound(s_attachment_array)
                            '...und wenn die Datei existiert
                            If Len(Dir(Trim(s_attachment_array(i)))) > 0 Then
                            'F|fffd|ge sie als Anlage bei
                            .AddAttachment Trim(s_attachment_array(i))
                            End If
                    'und zum n|fffd|chsten Element in dem Array...
                    Next i
            Else
            'Nur eine Anlage vorhanden
            .AddAttachment s_Attachment
            End If
       End If
    
       .send
    End With
    
    If err.Number <> 0 Then
'       DebugPrint DebType.tMail, "Versand fehlgeschlagen (" & s_mailserver & "): " & s_To & " - " & logTxt & " - " & Err.Number & " - " & Err.Description & " - " & Err.Source
       DebugPrint DebType.tERROR, "Mailversand fehlgeschlagen (" & s_mailserver & "): " & s_To & " - " & logTxt & " - " & err.Number & " - " & err.Description & " - " & err.Source
       err.Clear
       Mail_senden = False
    Else
'       DebugPrint DebType.tMail, " Versendet: " & s_To & " - " & logTxt
       DebugPrint DebType.tMail, "Mail versendet: " & s_To & " - " & logTxt
       Mail_senden = True
    End If
    Set eMail = Nothing
End Function

Public Function IsValidEmailAddress(AddressString As String) As Boolean
  Dim sHost    As String
  Dim iPos     As Integer
  Dim sInvalidChars As String
  If Len(Trim(AddressString)) = 0 Then
    IsValidEmailAddress = False
    Exit Function
  End If
  sInvalidChars = "!#$%^&*()=+{}[]|\;:'/?>,< "
  For iPos = 1 To Len(AddressString)
    If InStr(sInvalidChars, Mid(AddressString, iPos, 1)) > 0 Then
      IsValidEmailAddress = False
      Exit Function
    End If
  Next
  iPos = InStr(AddressString, "@")
  If iPos = 0 Or Left(AddressString, 1) = "@" Then
    IsValidEmailAddress = False
    Exit Function
  End If
  sHost = Mid(AddressString, iPos + 1)
  'can't have multiple "@" chars in the string
  If InStr(sHost, "@") > 0 Then
    IsValidEmailAddress = False
    Exit Function
  End If
  IsValidEmailAddress = IsValidIPHost(UCase(sHost))
End Function

Private Function IsValidIPHost(HostString As String) As Boolean
  Dim sHost    As String
  Dim bDottedQuad As Boolean
  Dim sSplit As Variant
  Dim ictr     As Integer
  Dim bAns     As Boolean
  Dim sTopLevelDomains() As String

  sHost = HostString

  If InStr(sHost, ".") = 0 Then
    IsValidIPHost = False
    Exit Function
  End If

  sSplit = Split(sHost, ".")

  If UBound(sSplit) = 3 Then
    bDottedQuad = True
    For ictr = 0 To 3
      If Not IsNumeric(sSplit(ictr)) Then
        bDottedQuad = False
        Exit For
      End If
    Next

    If bDottedQuad Then
      bAns = True
      For ictr = 0 To 3
        If ictr = 0 Then
          bAns = val(sSplit(ictr)) <= 239
          If bAns = False Then Exit For
        Else
          bAns = val(sSplit(ictr)) <= 255
          If bAns = False Then Exit For
        End If
      Next
      IsValidIPHost = bAns
      Exit Function
    End If
  End If                                         'ubound(ssplit) = 3
  IsValidIPHost = isTopLevelDomain(sSplit(UBound(sSplit)))
End Function

Private Function isTopLevelDomain(DomainString) As Boolean
  Dim asTopLevels() As String
  Dim ictr     As Integer
  Dim iNumDomains As Integer
  Dim bAns     As Boolean
  iNumDomains = 251
  ReDim asTopLevels(iNumDomains - 1) As String
  'Obtained from www.IANA.com.  Can and will change
  asTopLevels(0) = "COM"
  asTopLevels(1) = "ORG"
  asTopLevels(2) = "NET"
  asTopLevels(3) = "EDU"
  asTopLevels(4) = "GOV"
  asTopLevels(5) = "MIL"
  asTopLevels(6) = "INT"
  asTopLevels(7) = "AF"
  asTopLevels(8) = "AL"
  asTopLevels(9) = "DZ"
  asTopLevels(10) = "AS"
  asTopLevels(11) = "AD"
  asTopLevels(12) = "AO"
  asTopLevels(13) = "AI"
  asTopLevels(14) = "AQ"
  asTopLevels(15) = "AG"
  asTopLevels(16) = "AR"
  asTopLevels(17) = "AM"
  asTopLevels(18) = "AW"
  asTopLevels(19) = "AC"
  asTopLevels(20) = "AU"
  asTopLevels(21) = "AT"
  asTopLevels(22) = "AZ"
  asTopLevels(23) = "BS"
  asTopLevels(24) = "BH"
  asTopLevels(25) = "BD"
  asTopLevels(26) = "BB"
  asTopLevels(27) = "BY"
  asTopLevels(28) = "BZ"
  asTopLevels(29) = "BT"
  asTopLevels(30) = "BJ"
  asTopLevels(31) = "BE"
  asTopLevels(32) = "BM"
  asTopLevels(33) = "BO"
  asTopLevels(34) = "BA"
  asTopLevels(35) = "BW"
  asTopLevels(36) = "BV"
  asTopLevels(37) = "BR"
  asTopLevels(38) = "IO"
  asTopLevels(39) = "BN"
  asTopLevels(40) = "BG"
  asTopLevels(41) = "BF"
  asTopLevels(42) = "BI"
  asTopLevels(43) = "KH"
  asTopLevels(44) = "CM"
  asTopLevels(45) = "CA"
  asTopLevels(46) = "CV"
  asTopLevels(47) = "KY"
  asTopLevels(48) = "CF"
  asTopLevels(49) = "TD"
  asTopLevels(50) = "CL"
  asTopLevels(51) = "CN"
  asTopLevels(52) = "CX"
  asTopLevels(53) = "CC"
  asTopLevels(54) = "CO"
  asTopLevels(55) = "KM"
  asTopLevels(56) = "CD"
  asTopLevels(57) = "CG"
  asTopLevels(58) = "CK"
  asTopLevels(59) = "CR"
  asTopLevels(60) = "CI"
  asTopLevels(61) = "HR"
  asTopLevels(62) = "CU"
  asTopLevels(63) = "CY"
  asTopLevels(64) = "CZ"
  asTopLevels(65) = "DK"
  asTopLevels(66) = "DJ"
  asTopLevels(67) = "DM"
  asTopLevels(68) = "DO"
  asTopLevels(69) = "TP"
  asTopLevels(70) = "EC"
  asTopLevels(71) = "EG"
  asTopLevels(72) = "SV"
  asTopLevels(73) = "GQ"
  asTopLevels(74) = "ER"
  asTopLevels(75) = "EE"
  asTopLevels(76) = "ET"
  asTopLevels(77) = "FK"
  asTopLevels(78) = "FO"
  asTopLevels(79) = "FJ"
  asTopLevels(80) = "FI"
  asTopLevels(81) = "FR"
  asTopLevels(82) = "GF"
  asTopLevels(83) = "PF"
  asTopLevels(84) = "TF"
  asTopLevels(85) = "GA"
  asTopLevels(86) = "GM"
  asTopLevels(87) = "GE"
  asTopLevels(88) = "DE"
  asTopLevels(89) = "GH"
  asTopLevels(90) = "GI"
  asTopLevels(91) = "GR"
  asTopLevels(92) = "GL"
  asTopLevels(93) = "GD"
  asTopLevels(94) = "GP"
  asTopLevels(95) = "GU"
  asTopLevels(96) = "GT"
  asTopLevels(97) = "GG"
  asTopLevels(98) = "GN"
  asTopLevels(99) = "GW"
  asTopLevels(100) = "GY"
  asTopLevels(101) = "HT"
  asTopLevels(102) = "HM"
  asTopLevels(103) = "VA"
  asTopLevels(104) = "HN"
  asTopLevels(105) = "HK"
  asTopLevels(106) = "HU"
  asTopLevels(107) = "IS"
  asTopLevels(108) = "IN"
  asTopLevels(109) = "ID"
  asTopLevels(110) = "IR"
  asTopLevels(111) = "IQ"
  asTopLevels(112) = "IE"
  asTopLevels(113) = "IM"
  asTopLevels(114) = "IL"
  asTopLevels(115) = "IT"
  asTopLevels(116) = "JM"
  asTopLevels(117) = "JP"
  asTopLevels(118) = "JE"
  asTopLevels(119) = "JO"
  asTopLevels(120) = "KZ"
  asTopLevels(121) = "KE"
  asTopLevels(122) = "KI"
  asTopLevels(123) = "KP"
  asTopLevels(124) = "KR"
  asTopLevels(125) = "KW"
  asTopLevels(126) = "KG"
  asTopLevels(127) = "LA"
  asTopLevels(128) = "LV"
  asTopLevels(129) = "LB"
  asTopLevels(130) = "LS"
  asTopLevels(131) = "LR"
  asTopLevels(132) = "LY"
  asTopLevels(133) = "LI"
  asTopLevels(134) = "LT"
  asTopLevels(135) = "LU"
  asTopLevels(136) = "MO"
  asTopLevels(137) = "MK"
  asTopLevels(138) = "MG"
  asTopLevels(139) = "MW"
  asTopLevels(140) = "MY"
  asTopLevels(141) = "MV"
  asTopLevels(142) = "ML"
  asTopLevels(143) = "MT"
  asTopLevels(144) = "MH"
  asTopLevels(145) = "MQ"
  asTopLevels(146) = "MR"
  asTopLevels(147) = "MU"
  asTopLevels(148) = "YT"
  asTopLevels(149) = "MX"
  asTopLevels(150) = "FM"
  asTopLevels(151) = "MD"
  asTopLevels(152) = "MC"
  asTopLevels(153) = "MN"
  asTopLevels(154) = "MS"
  asTopLevels(155) = "MA"
  asTopLevels(156) = "MZ"
  asTopLevels(157) = "MM"
  asTopLevels(158) = "NA"
  asTopLevels(159) = "NR"
  asTopLevels(160) = "NP"
  asTopLevels(161) = "NL"
  asTopLevels(162) = "AN"
  asTopLevels(163) = "NC"
  asTopLevels(164) = "NZ"
  asTopLevels(165) = "NI"
  asTopLevels(166) = "NE"
  asTopLevels(167) = "NG"
  asTopLevels(168) = "NU"
  asTopLevels(169) = "NF"
  asTopLevels(170) = "MP"
  asTopLevels(171) = "NO"
  asTopLevels(172) = "OM"
  asTopLevels(173) = "PK"
  asTopLevels(174) = "PW"
  asTopLevels(175) = "PA"
  asTopLevels(176) = "PG"
  asTopLevels(177) = "PY"
  asTopLevels(178) = "PE"
  asTopLevels(179) = "PH"
  asTopLevels(180) = "PN"
  asTopLevels(181) = "PL"
  asTopLevels(182) = "PT"
  asTopLevels(183) = "PR"
  asTopLevels(184) = "QA"
  asTopLevels(185) = "RE"
  asTopLevels(186) = "RO"
  asTopLevels(187) = "RU"
  asTopLevels(188) = "RW"
  asTopLevels(189) = "KN"
  asTopLevels(190) = "LC"
  asTopLevels(191) = "VC"
  asTopLevels(192) = "WS"
  asTopLevels(193) = "SM"
  asTopLevels(194) = "ST"
  asTopLevels(195) = "SA"
  asTopLevels(196) = "SN"
  asTopLevels(197) = "SC"
  asTopLevels(198) = "SL"
  asTopLevels(199) = "SG"
  asTopLevels(200) = "SK"
  asTopLevels(201) = "SI"
  asTopLevels(202) = "SB"
  asTopLevels(203) = "SO"
  asTopLevels(204) = "ZA"
  asTopLevels(205) = "GS"
  asTopLevels(206) = "ES"
  asTopLevels(207) = "LK"
  asTopLevels(208) = "SH"
  asTopLevels(209) = "PM"
  asTopLevels(210) = "SD"
  asTopLevels(211) = "SR"
  asTopLevels(212) = "SJ"
  asTopLevels(213) = "SZ"
  asTopLevels(214) = "SE"
  asTopLevels(215) = "CH"
  asTopLevels(216) = "SY"
  asTopLevels(217) = "TW"
  asTopLevels(218) = "TJ"
  asTopLevels(219) = "TZ"
  asTopLevels(220) = "TH"
  asTopLevels(221) = "TG"
  asTopLevels(222) = "TK"
  asTopLevels(223) = "TO"
  asTopLevels(224) = "TT"
  asTopLevels(225) = "TN"
  asTopLevels(226) = "TR"
  asTopLevels(227) = "TM"
  asTopLevels(228) = "TC"
  asTopLevels(229) = "TV"
  asTopLevels(230) = "UG"
  asTopLevels(231) = "UA"
  asTopLevels(232) = "AE"
  asTopLevels(233) = "GB"
  asTopLevels(234) = "US"
  asTopLevels(235) = "UM"
  asTopLevels(236) = "UY"
  asTopLevels(237) = "UZ"
  asTopLevels(238) = "VU"
  asTopLevels(239) = "VE"
  asTopLevels(240) = "VN"
  asTopLevels(241) = "VG"
  asTopLevels(242) = "VI"
  asTopLevels(243) = "WF"
  asTopLevels(244) = "EH"
  asTopLevels(245) = "YE"
  asTopLevels(246) = "YU"
  asTopLevels(247) = "ZR"
  asTopLevels(248) = "ZM"
  asTopLevels(249) = "ZW"
  asTopLevels(250) = "UK"
  For ictr = 0 To iNumDomains - 1
    If asTopLevels(ictr) = DomainString Then
      bAns = True
      Exit For
    End If
  Next
  isTopLevelDomain = bAns
End Function


'Aufruf:
'IsValidEmailAddress ("MeineEmail@adresse.de")

' ---------------------------------------------------------------------------------------------------------

Public Function Join(Source() As String, Optional _
    sDelim As String = " ") As String
Dim sOut As String, iC As Long
On Error GoTo errh
  For iC = LBound(Source) To UBound(Source) - 1
    sOut = sOut & Source(iC) & sDelim
  Next
  sOut = sOut & Source(iC)
  Join = sOut
  Exit Function
errh:
  err.Raise err.Number
End Function

Public Function Split(ByVal sIn As String, Optional sDelim As _
  String, Optional nLimit As Long = -1, Optional bCompare As _
   Long = vbBinaryCompare) As Variant
  Dim sRead As String, sOut() As String, nC As Long
  If sDelim = "" Or Len(sDelim) > Len(sIn) Then
    ReDim Preserve sOut(0)
    sOut(0) = sIn
  Else
    sIn = sIn & sDelim
    Do While sIn <> "" And Len(sDelim) < Len(sIn)
      sRead = ReadUntil(sIn, sDelim, bCompare)
      ReDim Preserve sOut(nC)
      sOut(nC) = sRead
      nC = nC + 1
      If nLimit <> -1 And nC >= nLimit Then Exit Do
    Loop
  End If
  Split = sOut
End Function

Private Function ReadUntil(ByRef sIn As String, _
    sDelim As String, Optional bCompare As Long = vbBinaryCompare) As String
  Dim nPos As Long
  nPos = InStr(1, sIn, sDelim, bCompare)
  If nPos > 0 Then
    ReadUntil = Left(sIn, nPos - 1)
    sIn = Mid(sIn, nPos + Len(sDelim))
  End If
End Function

Public Function StrReverse(ByVal sIn As String) As String
  Dim nC As Long, sOut As String
  sOut = ""
  For nC = Len(sIn) To 1 Step -1
    sOut = sOut & Mid(sIn, nC, 1)
  Next
  StrReverse = sOut
End Function

Public Function InStrRev(ByVal sIn As String, sFind As String, _
Optional nStart As Long = 1, Optional bCompare As _
    Long = vbBinaryCompare) As Long
  Dim nPos As Long
  sIn = StrReverse(sIn)
  sFind = StrReverse(sFind)
  nPos = InStr(nStart, sIn, sFind, bCompare)
  If nPos = 0 Then
    InStrRev = 0
  Else
    InStrRev = Len(sIn) - nPos - Len(sFind) + 2
  End If
End Function

Public Function Replace(sIn As String, sFind As String, _
    sReplace As String, Optional nStart As Long = 1, _
    Optional nCount As Long = -1, Optional bCompare As _
    Long = vbBinaryCompare) As String

  If sFind = "" Then
    Replace = sIn
    Exit Function
  End If

  Dim nC As Long, nPos As Long, sOut As String
  sOut = sIn
  nPos = InStr(nStart, sOut, sFind, bCompare)
  If nPos <> 0 Then
    Do
      nC = nC + 1
      sOut = Left(sOut, nPos - 1) & sReplace & _
         Mid(sOut, nPos + Len(sFind))
      If nCount <> -1 And nC >= nCount Then Exit Do
      nStart = nPos + Len(sReplace)
      nPos = InStr(nStart, sOut, sFind, bCompare)
    Loop While nPos > 0
  End If
  Replace = sOut
End Function


Public Function GetToken(sText As String, _
  iPos As Integer, _
  Optional sDelimiter As String = " ") As String
  
  Dim iTotal As Integer
  Dim iCurPos As Integer
  Dim iLastPos As Integer
  Dim sAttach As String

  ' Erstes Trennungszeichen suchen
  iLastPos = Len(sDelimiter) * -1 + 1
  iCurPos = InStr(1, sText, sDelimiter)

  Do Until iCurPos = 0
    iTotal = iTotal + 1

    ' Trennungszeichen gefunden
    If iTotal >= iPos Then ' Gew|fffd|nschte Position erreicht?
      Exit Do
    End If

    iLastPos = iCurPos
    iCurPos = InStr(iCurPos + 1, sText, sDelimiter)
  Loop

  ' Wenn kein Trennungszeichen gefunden wurde,
  ' kompletten Text zur|fffd|ckgeben
  If iCurPos = 0 And iPos = 1 Then
    sAttach = sText

  ' Falls gefunden, richtigen Parameter zur|fffd|ckgeben
  ElseIf iTotal = iPos Then
    sAttach = Mid$(sText, iLastPos + Len(sDelimiter), _
      iCurPos - iLastPos - Len(sDelimiter))

  ElseIf iTotal = iPos - 1 Then
    sAttach = Mid$(sText, iLastPos + Len(sDelimiter))
  End If

  GetToken = sAttach
End Function

Function GetArg(Text As Variant, Position As Integer, Trennzeichen As String) As Variant
'*******************************************
'Name:      GetArg (Function)
'Purpose:   Zerst|fffd|ckelt einen String, in dem mehrere - durch TRENNZEICHEN getrennte Argumente
'Author:
'Date:
'Inputs:    Text = Text der zerlegt werden soll, POSITION = Pos des Vorkommens des Trennzeichens, Trennzeichen = der String des Trennzeichens
'           POSITION = 0 gibt die Anzahl der Argumente zur|fffd|ck
'Output:
'Example:
'*******************************************

Dim pos As Integer

    If IsNull(Text) And Position = 0 Then GetArg = 0: Exit Function
    If IsNull(Text) And Position > 0 Then GetArg = Null: Exit Function
    
    If Right$(Text, Len(Trennzeichen)) <> Trennzeichen Then
        Text = Text & Trennzeichen
    End If


    If Left(Text, Len(Trennzeichen)) <> Trennzeichen Then
        Text = Trennzeichen & Text
    End If
    
    If Position = 0 Then

        Dim Anzahl As Integer

        Anzahl = 0
        pos = InStr(1, Text, Trennzeichen)
        While pos <> 0
            Anzahl = Anzahl + 1
            pos = InStr(pos + 1, Text, Trennzeichen)
        Wend

        GetArg = Anzahl - 1

    Else

        Dim i As Integer
        Dim EndPos As Integer

        pos = 0

        For i = 1 To Position

            pos = InStr(pos + 1, Text, Trennzeichen)
            If pos = 0 Then GetArg = Null: Exit Function

        Next i

        EndPos = InStr(pos + 1, Text, Trennzeichen)

        If EndPos = 0 Then GetArg = Null: Exit Function

        GetArg = Mid(Text, pos + Len(Trennzeichen), EndPos - pos - Len(Trennzeichen))

    End If

End Function


Sub ReplaceStuff(ByRef curdoc As Object, ByRef s As String, ByRef rs As Object, Optional Risikoklasse As String = "", Optional risikoklassealt As String = "")
On Error Resume Next
    Dim urlencodedString As String
    urlencodedString = GetCurrentDocUNCPathURL(curdoc)
    If urlencodedString <> "" And IsHttpFilename(urlencodedString) = True Then
        s = Replace(s, "#DATEINAME#", "<" & urlencodedString & ">")
    End If
    s = Replace(s, "#DATEINAME#", "<file://" & rs.Fields("Dateiname").value & ">")
    s = Replace(s, "#DATEIID#", rs.Fields("idvDateiID").value)
    s = Replace(s, "#USER#", GetUserName)
    ' s = Replace(s, "#USERNAME#", GetCurrentUserFullName(conn))
    ' s = Replace(s, "#USERMAIL#", GetCurrentUserMail(conn))
    s = Replace(s, "#SPEICHERNDERUSER#", GetSafeField(rs, "SpeichernderUserLogonID"))
    s = Replace(s, "#RISIKOKLASSE#", Risikoklasse)
    s = Replace(s, "#RISIKOKLASSEALT#", risikoklassealt)
End Sub


Sub ReplaceStuffInitiator(ByRef s As String, ByRef conn As Object, ByRef username As String)

    Dim fullname As String
    fullname = GetUserFullName(conn, username)
    If fullname = "" Then
        fullname = username
    End If
    
    s = Replace(s, "#FREIGABEINITIATOR#", fullname)
    s = Replace(s, "#FREIGEBER#", fullname)
    
End Sub



Sub InformAdmins(storeMailsToTable As Boolean, ByRef conn As Object, ByVal betreff As String, ByVal mailtext As String, ByVal logTxt As String, fNameFreigabeformular As String, ccList As String)

    If G_PARAM_SMTPMailVersandAktiv = False Then Exit Sub

    If Len(G_PARAM_SMTPEmpfaenger_ProgrammfreigabenA) > 0 Then
        SendSMTPMail _
                conn, _
                storeMailsToTable, _
                G_PARAM_SMTPSender, _
                G_PARAM_SMTPEmpfaenger_ProgrammfreigabenA, _
                ccList, _
                G_PARAM_SMTPServer, _
                betreff, _
                mailtext, logTxt, fNameFreigabeformular
    End If
    
    ' Nur die erste Mail wird auch CC gesendet!
    If Len(G_PARAM_SMTPEmpfaenger_ProgrammfreigabenB) > 0 Then
        SendSMTPMail _
                conn, _
                storeMailsToTable, _
                G_PARAM_SMTPSender, _
                G_PARAM_SMTPEmpfaenger_ProgrammfreigabenB, _
                "", _
                G_PARAM_SMTPServer, _
                betreff, _
                mailtext, logTxt, fNameFreigabeformular
    End If
    
    ' Wenn kein Admin eingestellt ist, dann gehts nur an die CC Liste!
    If Len(G_PARAM_SMTPEmpfaenger_ProgrammfreigabenA) <= 0 And Len(G_PARAM_SMTPEmpfaenger_ProgrammfreigabenB) <= 0 And Len(ccList) > 0 Then
        SendSMTPMail _
                conn, _
                storeMailsToTable, _
                G_PARAM_SMTPSender, _
                ccList, _
                "", _
                G_PARAM_SMTPServer, _
                betreff, _
                mailtext, logTxt, fNameFreigabeformular
    End If
    

End Sub

' Begin Neu 15.1.2016
Function GetNeutralDate(ByRef rs As Object, ByVal fieldname As String) As String
  On Error Resume Next
  GetNeutralDate = ""
  Dim d As Date
  d = CDate(GetSafeField(rs, fieldname))
  GetNeutralDate = Format(d, "yyyy.mm.dd hh:mm:ss")
End Function

Function GetSafeUSDouble(ByRef rs As Object, fieldname As String) As String
  On Error Resume Next
  GetSafeUSDouble = "0"
  Dim d As Double
  d = 0#
  If Not IsNull(rs.Fields(fieldname).value) Then
    d = rs.Fields(fieldname).value
  End If
  ' Laut dem hier: http://stackoverflow.com/questions/8924803/cstr-str-tostring
  ' konvertiert str "Culture invariant" - also immer mit Dezimalpunkt.
  GetSafeUSDouble = str(d)
End Function

' Fuellt die Werte des idvDateien records mit field namen als key und den Werten als value in die collection
Public Function PrepareScriptVars(ByRef idvDateienRs As Object, ByRef col As Collection, ByRef colTouple As Collection) As Boolean
    On Error GoTo nogo
    PrepareScriptVars = False
    Dim fld As Variant
    For Each fld In idvDateienRs.Fields
        Dim Key As String
        Key = "idvDateien." & fld.name
        Dim value As String
        Dim bool As String
        bool = "FALSE"
        Select Case fld.Type
            Case adBoolean: value = IIf(GetSafeFieldPlus(idvDateienRs, fld.name, False) = True, "TRUE", "FALSE") ' UCase(GetSafeFieldPlus(idvDateienRs, fld.name, bool))
            
            Case adSmallInt: value = GetSafeFieldPlus(idvDateienRs, fld.name, "0")
            Case adBigInt: value = GetSafeFieldPlus(idvDateienRs, fld.name, "0")
            Case adInteger: value = GetSafeFieldPlus(idvDateienRs, fld.name, "0")
            Case adNumeric: value = GetSafeFieldPlus(idvDateienRs, fld.name, "0")
            Case adSingle: value = GetSafeUSDouble(idvDateienRs, fld.name)
            Case adDouble: value = GetSafeUSDouble(idvDateienRs, fld.name)
            
            ' Short Text
            Case adVarWChar: value = Chr(34) & GetSafeField(idvDateienRs, fld.name) & Chr(34)
            ' Long Text
            Case adLongVarWChar: value = Chr(34) & GetSafeField(idvDateienRs, fld.name) & Chr(34)
            ' Date/Time
            ' Hier muss das Datum so formatiert werden: "yyyy.mm.dd", sonst geht das mit string compare nicht richtig!
            Case adDBTimeStamp: value = Chr(34) & GetNeutralDate(idvDateienRs, fld.name) & Chr(34)
            Case adDate: value = Chr(34) & GetNeutralDate(idvDateienRs, fld.name) & Chr(34)
        
            ' Alle anderen field types werden hier nicht unterstuetzt
            Case Else: value = "N/A"
        End Select
        ' Debug.Print "Name: " & fld.Name & ", Type: " & fld.Type & ", Value: " & value
        
        ReplaceStringInToupleCollections col, colTouple, value, UCase(Key)
'        col.add value, UCase(Key)
    Next
    
    ' Weitere constants hinzufuegen
    ' col.add "0", "SCHUTZBEDARFSWERT.UNBEWERTET"
    ' col.add "1", "SCHUTZBEDARFSWERT.GERING"
    ' col.add "2", "SCHUTZBEDARFSWERT.MITTEL"
    ' col.add "3", "SCHUTZBEDARFSWERT.HOCH"
    ' col.add "4", "SCHUTZBEDARFSWERT.SEHRHOCH"
    ' col.add "5", "SCHUTZBEDARFSWERT.GEHEIM"
    ReplaceStringInToupleCollections col, colTouple, "0", "SCHUTZBEDARFSWERT.UNBEWERTET"
    ReplaceStringInToupleCollections col, colTouple, "1", "SCHUTZBEDARFSWERT.GERING"
    ReplaceStringInToupleCollections col, colTouple, "1", "SCHUTZBEDARFSWERT.NIEDRIG"
    ReplaceStringInToupleCollections col, colTouple, "2", "SCHUTZBEDARFSWERT.MITTEL"
    ReplaceStringInToupleCollections col, colTouple, "3", "SCHUTZBEDARFSWERT.HOCH"
    ReplaceStringInToupleCollections col, colTouple, "4", "SCHUTZBEDARFSWERT.SEHRHOCH"
    ReplaceStringInToupleCollections col, colTouple, "5", "SCHUTZBEDARFSWERT.GEHEIM"
    
    PrepareScriptVars = True
nogo:
    
End Function

' eventid ist eine von den ME_* constants oben
'    Public Const ME_FreigabeInitiiert = 1
'    Public Const ME_FreigabeErteilt = 2
'    Public Const ME_FreigabeAbgebrochen = 3
'    Public Const ME_RisikoklasseGeaendert = 4
Sub CheckMailEvent(ByRef curdoc As Object, eventid As Long, ByRef idvDateienRs As Object, ByRef conn As Object, Optional Risikoklasse As String = "", Optional risikoklassealt As String = "")
    Dim sprachId As Long
    sprachId = 0 ' Deutsch
    
    Dim mailEventsRs As Object
    Set mailEventsRs = OpenRS("SELECT * FROM gMailEvents WHERE MailEventType = " & eventid, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
    If Not mailEventsRs Is Nothing Then
        If Not mailEventsRs.EOF Then
            ' Jedes zu eventid passende Eventscript aus gMailEvents mit dem idvDateien record ausfuehren
            Dim recipient As String
            recipient = mailEventsRs.Fields("MailEmpfaenger").value
            
            Dim script As String
            script = mailEventsRs.Fields("Script").value
            
            If recipient <> "" And script <> "" Then
                Dim scriptResult As Boolean
                scriptResult = False
                
                Dim col As New Collection
                
                If PrepareScriptVars(idvDateienRs, col, Nothing) Then
                    
                    Dim errTxt As String
                    errTxt = ""
                    Dim erram As Long
                    erram = 0
                    Dim objScript As Object
                    Dim cso As Object
                    Set cso = New CScriptObject
                    Set objScript = cso.GetObject
                    'objScript.Language = "VBScript"
                    'objScript.AllowUI = False
                    
                    Dim resultscript As String
                    ' Die Scriptvariablen ersetzen
                    resultscript = PlausitestScriptinterpreter(objScript, script, errTxt, erram, col)
                    If erram = 0 Then
                        scriptResult = EvalScriptTrueFalse(objScript, resultscript)
                    End If
                    
                    ' Wenn der result true war, wird eine email verschickt
                    If scriptResult = True Then
                        Dim id As Long
                        id = mailEventsRs.Fields("MailEventID").value
                        
                        Dim mailEventTexteRs As Object
                        Set mailEventTexteRs = OpenRS("SELECT * FROM gMailEventTexte WHERE MailEventID = " & id & " AND SprachID = " & sprachId, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
                        If Not mailEventTexteRs Is Nothing Then
                            If Not mailEventTexteRs.EOF Then
                                Dim subject As String
                                subject = mailEventTexteRs.Fields("BetreffText").value
                                Dim body As String
                                body = mailEventTexteRs.Fields("BodyText").value
                                
                                ' Platzhalter ersetzen
                                ReplaceStuff curdoc, subject, idvDateienRs, Risikoklasse, risikoklassealt
                                ReplaceStuff curdoc, body, idvDateienRs, Risikoklasse, risikoklassealt
                                ReplaceStuffInitiator subject, conn, GetUserName()
                                ReplaceStuffInitiator body, conn, GetUserName()
                                
                                SendSMTPMail _
                                        conn, _
                                        G_PARAM_StoreMailsToTable, _
                                        IIf(G_PARAM_SMTPSender = "", "ExcelTracker@idvtracker.de", G_PARAM_SMTPSender), _
                                        recipient, _
                                        "", _
                                        G_PARAM_SMTPServer, _
                                        subject, _
                                        body, ""
                            End If
                            mailEventTexteRs.Close
                        End If
                        Set mailEventTexteRs = Nothing
                    End If
                    Set objScript = Nothing
                    Set cso = Nothing
'                    CloseMyObject Empty
                End If
            End If
            
            ' Naechster event record
            mailEventsRs.MoveNext
        End If
        mailEventsRs.Close
    End If
    Set mailEventsRs = Nothing
End Sub

Private Function GetLine(ByRef txt As String) As String
  Dim pos As Long
  Dim res As String
  Dim onlylf As Boolean
  onlylf = False
  pos = InStr(txt, vbCrLf)
  
  If pos = 0 Then
    pos = InStr(txt, vbLf)
    onlylf = True
  End If
  
  If pos > 0 Then
    If pos > 1 Then
      res = Left(txt, pos - 1)
    Else
      res = ""
    End If
  Else
    res = txt
  End If
  If pos > 0 Then
    If onlylf Then
      txt = Mid(txt, 1 + pos)
    Else
      txt = Mid(txt, 2 + pos)
    End If
  Else
    txt = ""
  End If
  
  GetLine = res

End Function

Function GetNextLine(ByRef s As String) As String
  
  Dim rs As String
  Do
    rs = GetLine(s)
    If Len(Trim(rs)) > 0 Then
      GetNextLine = Trim(rs)
      Exit Function
    End If
    If Len(Trim(s)) <= 0 Then
      GetNextLine = ""
      s = ""
      Exit Function
    End If
  Loop
End Function


Function RemoveComments(ByVal s As String) As String
  Do
    Dim pos As Long
    Dim pos2 As Long
    Dim replacedOne As Boolean
    replacedOne = False
    
    pos = InStr(s, "'")
    If pos > 0 Then
      pos2 = InStr(pos + 1, s, vbCr)
      If pos2 > 0 Then
        s = Left(s, pos - 1) & Mid(s, pos2)
        replacedOne = True
      Else
        s = Left(s, pos - 1)
        replacedOne = True
      End If
    End If
    
    pos = InStr(s, "/*")
    If pos > 0 Then
      pos2 = InStr(pos + 2, s, "*/")
      If pos2 > 0 Then
        s = Left(s, pos - 1) & Mid(s, pos2 + 2)
        replacedOne = True
      Else
        Exit Do
      End If
    End If
    
    pos = InStr(s, "<!--")
    If pos > 0 Then
      pos2 = InStr(pos + 4, s, "-->")
      If pos2 > 0 Then
        s = Left(s, pos - 1) & Mid(s, pos2 + 3)
        replacedOne = True
      Else
        Exit Do
      End If
    End If
    
    
    If Not replacedOne Then Exit Do
  Loop
  RemoveComments = s
End Function

Function EvalScriptTrueFalse(ByRef objScript As Object, ByVal s As String) As Boolean
  On Error GoTo nogo
  
  Dim res As String
  res = UCase(objScript.Eval(Trim(Replace(s, vbCrLf, " "))))
  
  'If res = "WAHR" Or res = "TRUE" Then
  If IsTrue(res) Then
    EvalScriptTrueFalse = True
  End If
  Exit Function
nogo:
End Function


Function ScriptHasError(ByRef objScript As Object, ByVal s As String, ByRef errTxt As String) As Boolean
  errTxt = ""
  On Error GoTo nogo
  objScript.Eval Trim(Replace(s, vbCrLf, " "))
  Exit Function
nogo:
  errTxt = err.Number & " - " & err.Description
  ScriptHasError = True
End Function

Private Function CollectionStringExists(c As Collection, name As String) As Boolean
    On Error GoTo doesntExist
    Dim s As String
    s = c(name)
    CollectionStringExists = True
    Exit Function
doesntExist:
    CollectionStringExists = False
End Function

'Die Funktion liefert das um alle Variablen ersetzte Script!
Function PlausitestScriptinterpreter(ByRef objScript As Object, ByVal scripttext As String, ByRef errTxt As String, ByRef erram As Long, ByRef cFields As Collection) As String
  Dim terram  As Long
  terram = 0
  
  Dim s As String
  Dim flds As String
  
  s = RemoveComments(scripttext)
  
  Dim pos As Long
  Dim pos2 As Long
  
  
  Dim firstError As Boolean
  firstError = True
  
  pos = 1
  Do
    pos = InStr(pos, s, "#")
    If pos <= 0 Then Exit Do
    pos2 = InStr(pos + 1, s, "#")
    If pos2 <= 0 Then Exit Do
    flds = Mid(s, pos + 1, pos2 - pos - 1)
    
    If CollectionStringExists(cFields, UCase(flds)) Then
      s = Left(s, pos - 1) & cFields(flds) & Mid(s, pos2 + 1, 100000)
      pos = pos + Len(cFields(flds))
    Else
      errTxt = errTxt & "*** FEHLER: Bezeichner #" & flds & "# unbekannt!" & vbCrLf
      terram = terram + 1
      s = Replace(s, "#" & flds & "#", "")
    End If
  Loop
        
'  Dim suberr As String
'  If terram = 0 Then
'    If ScriptHasError(objScript, s, suberr) Then
'        errTxt = errTxt & "*** FEHLER: Script weist Fehler auf: " & suberr & vbCrLf
'        terram = terram + 1
'    End If
'  End If
  
  errTxt = errTxt & "  Ergebnis: " & IIf(terram > 0, "Script weist " & terram & " Fehler auf!!!", "Script ok") & vbCrLf
  erram = erram + terram
  
  PlausitestScriptinterpreter = s
End Function
' End Neu 15.1.2016


Attribute VB_Name = "MeineDateien"
Option Explicit

Public G_LoadFile As String
Public G_MeineDateienTyp As Long

Sub ZeigeMeineDateienListe(ByRef officeapp As Object, ByRef curdoc As Object, typ As Long)
  
    G_LoadFile = ""
    G_MeineDateienTyp = typ
    G_Form_InTerminate = False
    G_Form_InInitialize = False
    
    'ShowStatusForm "Bitte warten..."
    ShowStatusForm FMT0("STATUS_2")
    Load frmMeineDateien
    HideStatusForm
    
    'frmMeineDateien.Caption = ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")" & " - 'Meine' Dateien"
    frmMeineDateien.Caption = ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")" & " - " & FMT0("MD_1")
    frmMeineDateien.Show vbModal
    Unload frmMeineDateien
    
    On Error Resume Next
    If G_LoadFile <> "" Then
'      StartDatei G_LoadFile, vbNormalFocus, False

      If Not FileExists(G_LoadFile) Then
'        MsgBox "Die Datei '" & G_LoadFile & "' existiert nicht mehr oder wurde verschoben.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        'If MsgBox("Die Datei '" & G_LoadFile & "' existiert nicht mehr oder wurde verschoben. Soll die Datei als gel|fffd|scht markiert werden?", vbQuestion + vbYesNo + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")") = vbYes Then
        If MsgBox(FMT1("MEINEDATEIEN_1", G_LoadFile), vbQuestion + vbYesNo + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")") = vbYes Then
          DateiAlsGeloeschtMarkieren curdoc, G_LoadFile
        End If
      Else

#If PROJECT_ACCESSTRACKER = 0 Then
      DateiOeffnen officeapp
#Else
      officeapp.CloseCurrentDatabase
      officeapp.OpenCurrentDatabase G_LoadFile
#End If
      End If
    End If

End Sub

Private Sub DateiOeffnen(ByRef xlapp As Object)

    Dim appname As String
    appname = AnwendungFuerDatei(G_LoadFile)
    
    If appname = "" Then
        'MsgBox "Anwendungsprogramm f|fffd|r " & G_LoadFile & " nicht gefunden/installiert!", vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Major & "-" & app.Minor & "-" & MyInternalVersion & ")"
        MsgBox FMT1("DOKULIST_11", G_LoadFile), vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Major & "-" & app.Minor & "-" & MyInternalVersion & ")"
        Exit Sub
    End If
   
    Dim Result As Long
    If Right(UCase(appname), 9) = "EXCEL.EXE" Then
        G_NoStartup = True
        ExcelDateiOeffnen xlapp, G_LoadFile
        Exit Sub
    ElseIf Right(UCase(appname), 12) = "MSACCESS.EXE" Then
    End If
    
    If "" <> appname Then
        MyShell Chr(34) & appname & Chr(34) & " " & Chr(34) & G_LoadFile & Chr(34), G_LoadFile, vbNormalFocus
    End If
        
End Sub

Private Function MyShell(Exec As String, fname As String, _
 Optional WindowStyle As VbAppWinStyle = vbMinimizedFocus) _
 As Long

  Dim nTaskId As Long
 ' Dim nHProcess As Long
 ' Dim nExitCode As Long
  
'  Const STILL_ACTIVE = &H103
'  Const PROCESS_QUERY_INFORMATION = &H400
    
  nTaskId = Shell(Exec, WindowStyle)
End Function

Private Sub ExcelDateiOeffnen(ByRef xlapp As Object, ByVal fname As String)
    If DateiSchonGeoeffnet(xlapp, fname) = True Then
        Exit Sub
    End If
    
    Dim conn As Object
    Set conn = GetConnection()

    If conn Is Nothing Then
        Exit Sub
    End If
    
    Dim oldenev As Boolean
    oldenev = xlapp.EnableEvents
    xlapp.EnableEvents = True
    Dim oldalert As Boolean
    oldalert = xlapp.DisplayAlerts
    xlapp.DisplayAlerts = True
    xlapp.AskToUpdateLinks = True
    Dim oldAutomation As Long
    oldAutomation = xlapp.AutomationSecurity
    'xlapp.AutomationSecurity = msoAutomationSecurityLow
    
    Dim dateiGeoeffnet As Boolean
    Dim pw As String
    If HatDateiFileOpenPasswordConn(conn, fname, -1, pw) = True Then
        dateiGeoeffnet = ExcelDateiMitPWOeffnen(xlapp, fname, pw)
    Else
        DateiOeffnenOhnePW xlapp, fname
    End If
    xlapp.EnableEvents = oldenev
    xlapp.DisplayAlerts = oldalert
    xlapp.AutomationSecurity = oldAutomation
    
    conn.Close
    Set conn = Nothing
End Sub



Attribute VB_Name = "MinorMajorFreigabe"
Option Explicit

' -1 hei|fffd|t, es gibt keine Checksumme|fffd|nderung oder aber die Datei wird einfach ge|fffd|ffnet (und die Flagge ist dann rot)
' 0 hei|fffd|t, Datei wird geschlossen bzw Abbruch-Gedr|fffd|ckt, wenn der Screen bei FreigabeInit sich |fffd|ffnet
' 1 hei|fffd|t, MinorChange bzw MajorChange wurde durchgef|fffd|hrt, Datei bleibt ge|fffd|ffnet

Public Function MMFreigabe(ByRef officeapp As Object, ByRef wbInExcelCurrentProjectInAccess As Object, ByRef conn As Object, ByVal curid As Long, ByVal LoadFile As Boolean, ByVal mm4ap As Boolean) As Long

  Dim majorMinorAktiviert As Boolean
  majorMinorAktiviert = G_PARAM_AnzahlErlaubterVeraenderungenModule >= 0 Or G_PARAM_AnzahlErlaubterVeraenderungenNamen >= 0 Or G_PARAM_AnzahlErlaubterVeraenderungen >= 0 Or G_PARAM_AnzahlErlaubterVeraenderungenKlone >= 0 Or G_PARAM_AnzahlErlaubterVeraenderungenMutterzellen >= 0

  ' ----------------------------------------------------------------------------------------
  ' Checksummen vergleichen
  Dim rs As Object
  Dim tVersion As Long
  Dim tMinorVersion As Long
  Dim SpeichernderUser As String
  Dim kannFreigeben As Boolean
  kannFreigeben = True
  Dim verantwortlicheUser As String
    
  Dim checksummeHatSichGeaendert As Boolean
  tMinorVersion = 0
  
  Set rs = OpenRS("SELECT Checksumme, FreigabeChecksumme, MinorVersion, SpeichernderUserLogonID, VerantwortlicherAutor, FachlichVerantwortlicher FROM idvDateien WHERE idvDateiID = " & curid, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
  If Not rs Is Nothing Then
    If Not rs.EOF Then
       If rs.Fields("Checksumme").value <> rs.Fields("FreigabeChecksumme").value Then
          checksummeHatSichGeaendert = True
       End If
       tMinorVersion = GetSafeFieldPlus(rs, "MinorVersion", 0)
       SpeichernderUser = GetSafeFieldPlus(rs, "SpeichernderUserLogonID", "")
       kannFreigeben = UserKannFreigeben(G_CfgFreigabeMM, rs)
       verantwortlicheUser = GetVerantwortlicheUser(conn, rs, G_CfgFreigabeMM)
    End If
  End If
  rs.Close
  Set rs = Nothing
 
  
  ' ----------------------------------------------------------------------------------------
  ' Checksumme nicht anders? Dann raus hier
  If checksummeHatSichGeaendert = False Then
    MMFreigabe = -1 ' es gibt keine Checksumme|fffd|nderung oder aber die Datei wird einfach ge|fffd|ffnet (und die Flagge ist dann rot)
    Exit Function
  End If
 
 
  ' ----------------------------------------------------------------------------------------
  ' Wenn die kein MM und kein Entfernen von Freigaben, dann einfach aufmachen.
  If G_PARAM_FreigabeEntfernenBeiVeraenderterChecksummeExcel = False And majorMinorAktiviert = False Then
  
    ' Wenn wir im Ladescreen sind, dann geben wir eine Meldung aus, dass die Freigabe Korrumpiert ist.
    If LoadFile Then
      If Trim(FMT0(CStr("ST_52"))) <> "" Then
        MsgBox FMT0(CStr("ST_52")), vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
      End If
    End If
  
    MMFreigabe = -1 ' es gibt keine Checksumme|fffd|nderung oder aber die Datei wird einfach ge|fffd|ffnet (und die Flagge ist dann rot)
    Exit Function
  End If
 
 
  ' ----------------------------------------------------------------------------------------
  ' Beim Flag "Freigabe entfernen" wird die Freigabe einfach rausgeworfen
  ' Gleiches gilt, wenn Major Minor verwendet wird und die Anzahl der erlaubten Minor Changes |fffd|berschritten wurde
  If G_PARAM_FreigabeEntfernenBeiVeraenderterChecksummeExcel = True Or _
    G_PARAM_NumAllowedMinorChanges <= tMinorVersion Then
  
    FreigabeEntfernenMitID officeapp, curid, conn, wbInExcelCurrentProjectInAccess, FMT1("TRACKERSTUFF_20", curid), False
    DebugPrint tSystem, "Freigabe automatisiert wg. Checksumme / MajorMinor-|fffd|berschreitung entfernt", 0, 0, curid
  
    MMFreigabe = 1 ' MinorChange bzw MajorChange wurde durchgef|fffd|hrt, Datei bleibt ge|fffd|ffnet
    Exit Function
  End If
    
  ' ----------------------------------------------------------------------------------------
   ' Der folgende Block errechnet, ob es in einer der "Erlaubten Ver|fffd|nderungen" die Schwelle |fffd|berschritten wurde
   Dim letzteMajorFreigabeDateiID As Long
   Dim letzteMajorFreigabeVersion As Long
   Dim letzteMajorFreigabeDatum As Date
   Dim letzteMajorFreigabeVersionMM As String
   GetLetzteMajorFreigabeDateiID conn, curid, letzteMajorFreigabeDateiID, letzteMajorFreigabeVersion, letzteMajorFreigabeDatum, letzteMajorFreigabeVersionMM
   
   Dim rsECCLetzteAnalyse As Object
   Set rsECCLetzteAnalyse = OpenRS("select * from ECCAnalyse where idvDateiID = " & curid & " order by DATUM DESC", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockPessimistic)
   Dim rsECCLetzteFreigabeAnalyse As Object
   Set rsECCLetzteFreigabeAnalyse = OpenRS("select * from ECCAnalyse inner join idvDateienFreigaben on ECCAnalyse.idvDateiID = idvDateienFreigaben.idvDateiID and ECCAnalyse.Datum = idvDateienFreigaben.Datum where idvDateienFreigaben.idvDateiID = " & letzteMajorFreigabeDateiID & " and idvDateienFreigaben.Version = " & letzteMajorFreigabeVersion & " order by idvDateienFreigaben.DATUM DESC", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockPessimistic)
   
   Dim anzahlSchwellwertUeberschritten As Long
   anzahlSchwellwertUeberschritten = 0
   
   If Not rsECCLetzteAnalyse Is Nothing And Not rsECCLetzteFreigabeAnalyse Is Nothing Then
       If rsECCLetzteAnalyse.EOF = False And rsECCLetzteFreigabeAnalyse.EOF = False Then
       
          ' Module
           anzahlSchwellwertUeberschritten = IIf(G_PARAM_AnzahlErlaubterVeraenderungenModule >= 0 And Abs(DifferenceValues(rsECCLetzteFreigabeAnalyse.Fields("ModuleAmount").value, rsECCLetzteAnalyse.Fields("ModuleAmount").value)) > G_PARAM_AnzahlErlaubterVeraenderungenModule, 1, 0)
           
           ' Namen
           anzahlSchwellwertUeberschritten = anzahlSchwellwertUeberschritten + IIf(G_PARAM_AnzahlErlaubterVeraenderungenNamen >= 0 And Abs(DifferenceValues(rsECCLetzteFreigabeAnalyse.Fields("NameAmount").value, rsECCLetzteAnalyse.Fields("NameAmount").value)) > G_PARAM_AnzahlErlaubterVeraenderungenNamen, 1, 0)
           
           ' Pivots, SQLs, Diagramme
           If G_PARAM_AnzahlErlaubterVeraenderungen >= 0 Then
              ' Pivot
              anzahlSchwellwertUeberschritten = anzahlSchwellwertUeberschritten + IIf(Abs(DifferenceValues(rsECCLetzteFreigabeAnalyse.Fields("PivotAmount").value, rsECCLetzteAnalyse.Fields("PivotAmount").value)) > G_PARAM_AnzahlErlaubterVeraenderungen, 1, 0)
              ' Diagramm
              anzahlSchwellwertUeberschritten = anzahlSchwellwertUeberschritten + IIf(Abs(DifferenceValues(rsECCLetzteFreigabeAnalyse.Fields("DIAGRAMAMOUNT").value, rsECCLetzteAnalyse.Fields("DIAGRAMAMOUNT").value)) > G_PARAM_AnzahlErlaubterVeraenderungen, 1, 0)
              ' SQLs
              anzahlSchwellwertUeberschritten = anzahlSchwellwertUeberschritten + IIf(Abs(DifferenceValues(rsECCLetzteFreigabeAnalyse.Fields("QueryAmount").value, rsECCLetzteAnalyse.Fields("QueryAmount").value)) > G_PARAM_AnzahlErlaubterVeraenderungen, 1, 0)
           End If
           
           ' Klone
           anzahlSchwellwertUeberschritten = anzahlSchwellwertUeberschritten + IIf(G_PARAM_AnzahlErlaubterVeraenderungenKlone >= 0 And Abs(DifferenceValues(rsECCLetzteFreigabeAnalyse.Fields("FORMULADUPAMOUNT").value, rsECCLetzteAnalyse.Fields("FORMULADUPAMOUNT").value)) > G_PARAM_AnzahlErlaubterVeraenderungenKlone, 1, 0)
           
           ' Mutterzellen
           anzahlSchwellwertUeberschritten = anzahlSchwellwertUeberschritten + IIf(G_PARAM_AnzahlErlaubterVeraenderungenMutterzellen >= 0 And Abs(DifferenceValues2( _
             rsECCLetzteFreigabeAnalyse.Fields("FormulaAmount").value, _
             rsECCLetzteFreigabeAnalyse.Fields("FORMULADUPAMOUNT").value, _
             rsECCLetzteAnalyse.Fields("FormulaAmount").value, _
             rsECCLetzteAnalyse.Fields("FORMULADUPAMOUNT").value) _
             ) > G_PARAM_AnzahlErlaubterVeraenderungenMutterzellen, 1, 0)
       End If
   End If
   
  ' ----------------------------------------------------------------------------------------
  ' Schwellenwerte |fffd|berschritten? Das wars....
  
  If anzahlSchwellwertUeberschritten > 0 And LoadFile = True Then
    FreigabeEntfernenMitID officeapp, curid, conn, wbInExcelCurrentProjectInAccess, FMT1("TRACKERSTUFF_20", curid), False
    DebugPrint tSystem, "Freigabe automatisiert wg. Checksumme / MajorMinor-|fffd|berschreitung entfernt", 0, 0, curid
    MMFreigabe = 1 ' MinorChange bzw MajorChange wurde durchgef|fffd|hrt, Datei bleibt ge|fffd|ffnet
    
    If Not rsECCLetzteAnalyse Is Nothing Then
        rsECCLetzteAnalyse.Close
        Set rsECCLetzteAnalyse = Nothing
    End If
    If Not rsECCLetzteFreigabeAnalyse Is Nothing Then
        rsECCLetzteFreigabeAnalyse.Close
        Set rsECCLetzteFreigabeAnalyse = Nothing
    End If
    
    Exit Function
  End If
  
    ' ----------------------------------------------------------------------------------------
  ' So, jetzt kann nur noch der Major Minor Change kommen, alles andere ist behandelt
  ' Es wird gepr|fffd|ft, ob das 4-AP f|fffd|r den MajorMinor UND das Komplexere Verfahren Init/Freigabe an ist.
  ' Wenn ja wird beim |fffd|ffnen (und nur da) eine Meldung ausgegben und hier rausgesprungen.
  
  If G_PARAM_MinorChanges4AP = True And G_cfgMinorChanges4APComplex = True And LoadFile = True Then
    If Trim(FMT0(CStr("ST_44"))) <> "" Then
      MsgBox FMT0(CStr("ST_44")), vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
    End If
    ' alles ignorieren
    MMFreigabe = -1
    
    If Not rsECCLetzteAnalyse Is Nothing Then
        rsECCLetzteAnalyse.Close
        Set rsECCLetzteAnalyse = Nothing
    End If
    If Not rsECCLetzteFreigabeAnalyse Is Nothing Then
        rsECCLetzteFreigabeAnalyse.Close
        Set rsECCLetzteFreigabeAnalyse = Nothing
    End If
    
    Exit Function
  End If
  

  ' ----------------------------------------------------------------------------------------
  ' Dann rufen wir mal das Major Minor Men|fffd| auf
  If Not kannFreigeben Then
    ' Sie sind kein Programmverantwortlicher f|fffd|r diese Datei und k|fffd|nnen deshalb keine 'Programmfreigabe f|fffd|r geringf|fffd|gige |fffd|nderungen' durchf|fffd|hren. Sie k|fffd|nnen lediglich die Datei schlie|fffd|en oder die Programmfreigabe entfernen! Setzen Sie sich ggf. mit den Programmveratwortlichen in Verbindung.\n\n%1
    MsgBox FMT1("FREIGABE_2", verantwortlicheUser), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
  End If
   

   
  ' ----------------------------------------------------------------------------------------
  ' Dann rufen wir mal das Major Minor Men|fffd| auf
   
   
   Dim majorMinor As Long
  
   Load frmFreigabeMajorMinor
   frmFreigabeMajorMinor.m_idvDateiIDLetzteFreigabe = letzteMajorFreigabeDateiID
   frmFreigabeMajorMinor.m_idvDateiVersionLetzteFreigabe = letzteMajorFreigabeVersion
   frmFreigabeMajorMinor.m_idvDateiVersionLetzteFreigabeMM = letzteMajorFreigabeVersionMM
   frmFreigabeMajorMinor.m_idvDateiIDAktuelleDatei = WBGetValueLong(wbInExcelCurrentProjectInAccess, "_IDVTrackerID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix)
   frmFreigabeMajorMinor.m_idvDateiVersionAktuelleDatei = WBGetValueLong(wbInExcelCurrentProjectInAccess, "_IDVTrackerVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix)
   frmFreigabeMajorMinor.m_idvDateiMajorMinorVersionAktuelleDatei = WBGetValueLong(wbInExcelCurrentProjectInAccess, "_IDVTrackerMajorVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix) & "." & WBGetValueLong(wbInExcelCurrentProjectInAccess, "_IDVTrackerMinorVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix)
   frmFreigabeMajorMinor.m_Dateiname = wbInExcelCurrentProjectInAccess.fullname
   frmFreigabeMajorMinor.m_idvDateiDatumLetzteFreigabe = letzteMajorFreigabeDatum
   'frmFreigabeMajorMinor.TextFreigabeMajorMinorText = GetLocString(conn, "FreigabeChecksummeGeaendert")
   
   frmFreigabeMajorMinor.LabelLetzterSpeichernderUser = SpeichernderUser
   Dim rsS As Object
   Set rsS = OpenRS("Select Vorname, Nachname from gWindowsUser inner join idvDateien on gWindowsUser.LogonID = idvDateien.SpeichernderUserLogonID and gWindowsUser.Von <= idvDateien.Speicherdatum and idvDateien.Speicherdatum < gWindowsUser.Bis where idvDateien.idvDateiID = " & curid, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
   If Not rsS Is Nothing Then
    If rsS.EOF = False Then
        If GetSafeFieldPlus(rsS, "Nachname", "") <> "" Then
          frmFreigabeMajorMinor.LabelLetzterSpeichernderUser = SpeichernderUser & " - " & GetSafeFieldPlus(rsS, "Nachname", "") & IIf(GetSafeFieldPlus(rsS, "Vorname", "") <> "", ", " & GetSafeFieldPlus(rsS, "Vorname", ""), "")
        End If
    End If
    rsS.Close
    Set rsS = Nothing
   End If
   
   If mm4ap Then
     ' ACHTUNG: Die Datei wurde seit ihrer Freigabe in wesentlichen Teilen ver|fffd|ndert! Sollte es sich um geringf|fffd|gige Ver|fffd|nderungen handeln, die keine oder nur geringf|fffd|gige Auswirkung auf die wesentlichen Ergebnisse des Programms haben, k|fffd|nnen Sie diese Ver|fffd|nderungen als "Geringf|fffd|gige |fffd|nderung" deklarieren. Die Freigabe wird dann entfernt und ein vereinfachter Freigabeprozesse kann |fffd|ber "Freigabeinitiierung" gestartet werden.
     ' Bitte bedenken Sie, dass eine wesentliche Ver|fffd|nderung auch als solche deklariert werden muss. Geringf|fffd|gige Ver|fffd|nderungen unterliegen einem periodischen Kontrollprozess.
     frmFreigabeMajorMinor.TextFreigabeMajorMinorText = FMT0("ST_51")
   Else
     ' ACHTUNG: Die Datei wurde seit ihrer Freigabe in wesentlichen Teilen ver|fffd|ndert! Sollte es sich um geringf|fffd|gige Ver|fffd|nderungen handeln, die keine oder nur geringf|fffd|gige Auswirkung auf die wesentlichen Ergebnisse des Programms haben, k|fffd|nnen Sie diese Ver|fffd|nderungen als "Geringf|fffd|gige |fffd|nderung" deklarieren. Es wird dann eine Ad-Hoc-Freigabe durchgef|fffd|hrt, die keinerlei zus|fffd|tzlicher Dokumentation bedarf. Sollte es sich um eine wesentliche Ver|fffd|nderung handeln, geben Sie bitte "Wesentliche |fffd|nderung" an. Die Freigabe wird dann aufgehoben und ist neu durchzuf|fffd|hren.
     ' Bitte bedenken Sie, dass eine wesentliche Ver|fffd|nderung auch als solche deklariert werden muss. Geringf|fffd|gige Ver|fffd|nderungen unterliegen einem periodischen Kontrollprozess.
     frmFreigabeMajorMinor.TextFreigabeMajorMinorText = FMT0("ST_10")
   End If
   'frmFreigabeMajorMinor.Caption = ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")" & " - Checksumme ge|fffd|ndert"
   frmFreigabeMajorMinor.Caption = ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")" & " - " & FMT0("TRACKERSTUFF_28")
    
   frmFreigabeMajorMinor.ModuleAnzahl.Caption = "0"
   frmFreigabeMajorMinor.NameAnzahl.Caption = "0"
   frmFreigabeMajorMinor.PivotAnzahl.Caption = "0"
   frmFreigabeMajorMinor.DiagrammAnzahl.Caption = "0"
   frmFreigabeMajorMinor.QueryAnzahl.Caption = "0"
   frmFreigabeMajorMinor.CloneAnzahl.Caption = "0"
   frmFreigabeMajorMinor.FormelAnzahl.Caption = "0"
   If Not rsECCLetzteAnalyse Is Nothing And Not rsECCLetzteFreigabeAnalyse Is Nothing Then
       If rsECCLetzteAnalyse.EOF = False And rsECCLetzteFreigabeAnalyse.EOF = False Then
            frmFreigabeMajorMinor.ModuleAnzahl.Caption = DifferenceValues(rsECCLetzteFreigabeAnalyse.Fields("ModuleAmount").value, rsECCLetzteAnalyse.Fields("ModuleAmount").value)
            frmFreigabeMajorMinor.NameAnzahl.Caption = DifferenceValues(rsECCLetzteFreigabeAnalyse.Fields("NameAmount").value, rsECCLetzteAnalyse.Fields("NameAmount").value)
            frmFreigabeMajorMinor.PivotAnzahl.Caption = DifferenceValues(rsECCLetzteFreigabeAnalyse.Fields("PivotAmount").value, rsECCLetzteAnalyse.Fields("PivotAmount").value)
            frmFreigabeMajorMinor.DiagrammAnzahl.Caption = DifferenceValues(rsECCLetzteFreigabeAnalyse.Fields("DIAGRAMAMOUNT").value, rsECCLetzteAnalyse.Fields("DIAGRAMAMOUNT").value)
            frmFreigabeMajorMinor.QueryAnzahl.Caption = DifferenceValues(rsECCLetzteFreigabeAnalyse.Fields("QueryAmount").value, rsECCLetzteAnalyse.Fields("QueryAmount").value)
            frmFreigabeMajorMinor.CloneAnzahl.Caption = DifferenceValues(rsECCLetzteFreigabeAnalyse.Fields("FORMULADUPAMOUNT").value, rsECCLetzteAnalyse.Fields("FORMULADUPAMOUNT").value)
            frmFreigabeMajorMinor.FormelAnzahl.Caption = DifferenceValues2( _
              rsECCLetzteFreigabeAnalyse.Fields("FormulaAmount").value, rsECCLetzteFreigabeAnalyse.Fields("FORMULADUPAMOUNT").value, _
              rsECCLetzteAnalyse.Fields("FormulaAmount").value, rsECCLetzteAnalyse.Fields("FORMULADUPAMOUNT").value)
       End If
   End If
   If mm4ap Then
      ' Nicht bekannt / Abbruch
      frmFreigabeMajorMinor.DateiSchliessen.Caption = FMT0("ST_49")
   End If
   
   If Not kannFreigeben Then
    frmFreigabeMajorMinor.MinorChange.Enabled = False
   End If
   
   
   frmFreigabeMajorMinor.Show vbModal
   majorMinor = frmFreigabeMajorMinor.Result
   
   Dim approvingUser As String
   approvingUser = ""
   
   ' Wenn das einfache 4AP verwendet wird muss der Approving User gespeichert werden. Er ist auch gleichzeitig der Freigeber!!!!
   If G_PARAM_MinorChanges4AP = True And G_cfgMinorChanges4APComplex = False Then
     approvingUser = frmFreigabeMajorMinor.m_ApprovingUser
   End If
   
   ' XXX* Unload frmFreigabeMajorMinor
   If Not rsECCLetzteAnalyse Is Nothing Then
       rsECCLetzteAnalyse.Close
       Set rsECCLetzteAnalyse = Nothing
   End If
   If Not rsECCLetzteFreigabeAnalyse Is Nothing Then
       rsECCLetzteFreigabeAnalyse.Close
       Set rsECCLetzteFreigabeAnalyse = Nothing
   End If
   
   Select Case majorMinor
          Case -1
              ' Datei schliessen
              MMFreigabe = 0
              Exit Function
          Case 0
              ' Major Change, Freigabe wird aufgehoben
              FreigabeEntfernenMitID officeapp, curid, conn, wbInExcelCurrentProjectInAccess, FMT1("TRACKERSTUFF_20", curid), False
              DebugPrint tSystem, "Freigabe durch User aufgehoben (Major-Minor)", 0, 0, curid
          
          Case 1
              ' Minor Change, Freigabe erteilen wenn kein 4AP, ansonsten nur den Minor-Wert hochsetzen
              
              Set rs = OpenRS("SELECT * FROM idvDateien WHERE idvDateiID = " & curid, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockPessimistic)
              If Not rs Is Nothing Then
                If Not rs.EOF Then
                  ' Risikowert brauchen wir f|fffd|r die Freigabe
                  Dim Risikowert As Double
                  Risikowert = rs.Fields("Risikowert").value
                  
                  CreateNewRecordset GetUNCPathFromDoc(wbInExcelCurrentProjectInAccess), wbInExcelCurrentProjectInAccess.fullname, wbInExcelCurrentProjectInAccess, rs, conn
                  rs.Fields("MinorVersion").value = IIf(IsNull(rs.Fields("MinorVersion").value), 1, rs.Fields("MinorVersion").value + 1)
                  
                  WBSetValueLong wbInExcelCurrentProjectInAccess, "_IDVTrackerID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, rs.Fields("idvDateiID").value
                  WBSetValueLong wbInExcelCurrentProjectInAccess, "_IDVTrackerVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, rs.Fields("Version").value
                  WBSetValueLong wbInExcelCurrentProjectInAccess, "_IDVTrackerFreigabeStatus" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, 0
                  WBSetValueLong wbInExcelCurrentProjectInAccess, "_IDVTrackerFreigabeDateiID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, 0
                  WBSetValueLong wbInExcelCurrentProjectInAccess, "_IDVTrackerFreigabeVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, 0
                  WBSetValueLong wbInExcelCurrentProjectInAccess, "_IDVTrackerMinorVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, rs.Fields("MinorVersion").value
                  
                  Dim majorVersion As Long
                  Dim minorVersion As Long
                  
                  curid = rs.Fields("idvDateiID").value
                  tVersion = rs.Fields("Version").value
                  majorVersion = rs.Fields("MajorVersion").value
                  minorVersion = rs.Fields("MinorVersion").value
                  
                  rs.Update
                  rs.Close
                  
                  ' darf ich das hier aufrufen?
                  DoInternalSave Nothing, wbInExcelCurrentProjectInAccess, conn
                  
                  If mm4ap Then
                     ' Die Freigabe wurde entfernt und die Minor-Version erh|fffd|ht. Bitte f|fffd|hren Sie das Programm zeitnahe der Freigabe zu.
                     MsgBox FMT0("ST_50"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                  Else
                        Dim checkertyp As String
           #If Project_ExcelTracker = 1 Then
                        checkertyp = "ECC"
           #ElseIf PROJECT_ACCESSTRACKER <> 0 Then
                        checkertyp = "ACC"
           #Else
                        checkertyp = "FT"
           #End If
                        Dim errTxt As String
                        Dim comm As String
                        If G_PARAM_KommentarBeiFreigabe = True Then
                            'comm = InputBox("Freigabekommentar:", ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")")
                            comm = InputBox(FMT0("TRACKERSTUFF_21"), ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")")
                        End If
                        If comm = "" Then
                            'comm = "Geringf|fffd|hgige |fffd|nderung"
                            comm = FMT0("TRACKERSTUFF_22")
                        End If
                        
                        If Dateifreigabe(officeapp, wbInExcelCurrentProjectInAccess, checkertyp, conn, wbInExcelCurrentProjectInAccess.fullname, curid, tVersion, errTxt, comm, Risikowert, approvingUser) Then
                          
                          WBSetValueLong wbInExcelCurrentProjectInAccess, "_IDVTrackerFreigabeStatus" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, 2
                          WBSetValueLong wbInExcelCurrentProjectInAccess, "_IDVTrackerFreigabeDateiID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, WBGetValueLong(wbInExcelCurrentProjectInAccess, "_IDVTrackerID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix)
                          WBSetValueLong wbInExcelCurrentProjectInAccess, "_IDVTrackerFreigabeVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, WBGetValueLong(wbInExcelCurrentProjectInAccess, "_IDVTrackerVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix)
                          DoInternalSave Nothing, wbInExcelCurrentProjectInAccess, conn
                          
                          ErstelleKopieDerDatei wbInExcelCurrentProjectInAccess.fullname, tVersion, majorVersion, minorVersion, conn
                          'MsgBox "Freigabe f|fffd|r geringf|fffd|gige |fffd|nderung erstellt.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                          MsgBox FMT0("TRACKERSTUFF_23"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                          
                        Else
                          'MsgBox "Die Freigabe war nicht erfolgreich." & IIf(errTxt <> "", " (" & errTxt & ")", "") & IIf(GetSetting(appname:="Stromwerken", Section:=checkertyp, Key:="ProcResult", Default:="") <> "", vbCrLf & vbCrLf & GetSetting(appname:="Stromwerken", Section:=checkertyp, Key:="ProcResult", Default:=""), ""), vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                          MsgBox FMT2("TRACKERSTUFF_24", IIf(errTxt <> "", " (" & errTxt & ")", ""), IIf(GetSetting(appname:="Stromwerken", Section:=checkertyp, Key:="ProcResult", Default:="") <> "", vbCrLf & vbCrLf & GetSetting(appname:="Stromwerken", Section:=checkertyp, Key:="ProcResult", Default:=""), "")), vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                        End If
                   End If
               End If
            End If
          Case 2
            ' Einfach |fffd|ffnen
   End Select
   MMFreigabe = 1

End Function



Attribute VB_Name = "Module_LoadPictureGDI"
Option Explicit

'Declare a UDT to store a GUID for the IPicture OLE Interface
Private Type guid
    Data1 As Long
    Data2 As Integer
    Data3 As Integer
    Data4(0 To 7) As Byte
End Type

'Windows API calls into the GDI+ library
#If VBA7 And Win64 Then
Private Type GdiplusStartupInput
     GdiplusVersion As Long
     DebugEventCallback As LongPtr
     SuppressBackgroundThread As Long
     SuppressExternalCodecs As Long
End Type
Private Type PICTDESC
     Size As Long
     Type As Long
     hPic As LongPtr
     hPal As LongPtr
End Type
Private Declare PtrSafe Function GdiplusStartup Lib "GDIPlus" (token As LongPtr, inputbuf As GdiplusStartupInput, Optional ByVal outputbuf As LongPtr = 0) As Long
Private Declare PtrSafe Function GdipCreateBitmapFromFile Lib "GDIPlus" (ByVal filename As LongPtr, bitmap As LongPtr) As Long
Private Declare PtrSafe Function GdipCreateHBITMAPFromBitmap Lib "GDIPlus" (ByVal bitmap As LongPtr, hbmReturn As LongPtr, ByVal background As Long) As Long
Private Declare PtrSafe Function GdipDisposeImage Lib "GDIPlus" (ByVal image As LongPtr) As Long
Private Declare PtrSafe Function GdiplusShutdown Lib "GDIPlus" (ByVal token As LongPtr) As Long
Private Declare PtrSafe Function OleCreatePictureIndirect Lib "oleaut32.dll" (PicDesc As PICTDESC, RefIID As guid, ByVal fPictureOwnsHandle As LongPtr, IPic As IPicture) As Long
#Else
Private Type GdiplusStartupInput
    GdiplusVersion As Long
    DebugEventCallback As Long
    SuppressBackgroundThread As Long
    SuppressExternalCodecs As Long
End Type
Private Type PICTDESC
    Size As Long
    Type As Long
    hPic As Long
    hPal As Long
End Type
Private Declare Function GdiplusStartup Lib "GDIPlus" (token As Long, inputbuf As GdiplusStartupInput, Optional ByVal outputbuf As Long = 0) As Long
Private Declare Function GdipCreateBitmapFromFile Lib "GDIPlus" (ByVal filename As Long, bitmap As Long) As Long
Private Declare Function GdipCreateHBITMAPFromBitmap Lib "GDIPlus" (ByVal bitmap As Long, hbmReturn As Long, ByVal background As Long) As Long
Private Declare Function GdipDisposeImage Lib "GDIPlus" (ByVal image As Long) As Long
Private Declare Function GdiplusShutdown Lib "GDIPlus" (ByVal token As Long) As Long
Private Declare Function OleCreatePictureIndirect Lib "olepro32.dll" (PicDesc As PICTDESC, RefIID As guid, ByVal fPictureOwnsHandle As Long, IPic As IPicture) As Long
#End If



' Procedure:    LoadPictureGDI
' Purpose:      Loads an image using GDI+
' Returns:      The image as an IPicture Object
Public Function LoadPictureGDI(ByVal sFileName As String) As IPicture

    Dim uGdiInput As GdiplusStartupInput
#If Win64 Then
    Dim hGdiPlus As LongPtr
    Dim hGdiImage As LongPtr
    Dim hBitmap As LongPtr
#Else
    Dim hGdiPlus As Long
    Dim hGdiImage As Long
    Dim hBitmap As Long
#End If
    Dim lResult As Long

    'Initialize GDI+
    uGdiInput.GdiplusVersion = 1
    lResult = GdiplusStartup(hGdiPlus, uGdiInput)

    If lResult = 0 Then

        'Load the image
        lResult = GdipCreateBitmapFromFile(StrPtr(sFileName), hGdiImage)

        If lResult = 0 Then

            'Create a bitmap handle from the GDI image
            lResult = GdipCreateHBITMAPFromBitmap(hGdiImage, hBitmap, 0)

            'Create the IPicture object from the bitmap handle
            Set LoadPictureGDI = CreateIPicture(hBitmap)

            'Tidy up
            GdipDisposeImage hGdiImage
        End If

        'Shutdown GDI+
        GdiplusShutdown hGdiPlus
    End If

End Function


' Procedure:    CreateIPicture
' Purpose:      Converts a image handle into an IPicture object.
' Returns:      The IPicture object
#If Win64 Then
Private Function CreateIPicture(ByVal hPic As LongPtr) As IPicture
#Else
Private Function CreateIPicture(ByVal hPic As Long) As IPicture
#End If
    Dim lResult As Long, uPicInfo As PICTDESC, IID_IDispatch As guid, IPic As IPicture

    'OLE Picture types
    Const PICTYPE_BITMAP = 1

    ' Create the Interface GUID (for the IPicture interface)
    With IID_IDispatch
        .Data1 = &H7BF80980
        .Data2 = &HBF32
        .Data3 = &H101A
        .Data4(0) = &H8B
        .Data4(1) = &HBB
        .Data4(2) = &H0
        .Data4(3) = &HAA
        .Data4(4) = &H0
        .Data4(5) = &H30
        .Data4(6) = &HC
        .Data4(7) = &HAB
    End With

    ' Fill uPicInfo with necessary parts.
    With uPicInfo
        .Size = Len(uPicInfo)
        .Type = PICTYPE_BITMAP
        .hPic = hPic
        .hPal = 0
    End With

    ' Create the Picture object.
    lResult = OleCreatePictureIndirect(uPicInfo, IID_IDispatch, True, IPic)

    ' Return the new Picture object.
    Set CreateIPicture = IPic

End Function

Attribute VB_Name = "MsgBoxStuff"
Option Explicit

Function MsgBox3(prompt As String, title As String, buttxt1 As String, buttxt2 As String, buttxt3 As String, defaultvalue As Long) As Long
  frmMsgBox3.m_Sel = defaultvalue
  frmMsgBox3.Caption = title
  frmMsgBox3.Label1.Caption = prompt
  frmMsgBox3.But1.Caption = buttxt1
  frmMsgBox3.But2.Caption = buttxt2
  frmMsgBox3.But3.Caption = buttxt3
  frmMsgBox3.Show vbModal
  
  MsgBox3 = frmMsgBox3.m_Sel
  
End Function
Attribute VB_Name = "MyComboBox"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public WithEvents ComboBoxEvents As MSForms.ComboBox
Attribute ComboBoxEvents.VB_VarHelpID = -1
Private m_Form As Object
Private m_Index As Integer

Public Sub Init(frm As Object, ByVal index As Integer)
    Set m_Form = frm
    m_Index = index
End Sub


Private Sub ComboBoxEvents_Change()
    ' m_Form.Click CommandButtonEvents, m_Index
    On Error Resume Next
    If Not m_Form Is Nothing Then
        m_Form.PropertyChangedWithSender ComboBoxEvents
    End If
End Sub

Private Sub Class_Terminate()
    Set ComboBoxEvents = Nothing
    Set m_Form = Nothing
End Sub

Attribute VB_Name = "MyCommandButton"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public WithEvents CommandButtonEvents As MSForms.CommandButton
Attribute CommandButtonEvents.VB_VarHelpID = -1
Private m_Form As Object
Private m_Index As Integer

Public Sub Init(frm As Object, ByVal index As Integer)
    Set m_Form = frm
    m_Index = index
End Sub


Private Sub CommandButtonEvents_Click()
    m_Form.Click CommandButtonEvents, m_Index
End Sub

Private Sub Class_Terminate()
    Set CommandButtonEvents = Nothing
    Set m_Form = Nothing
End Sub

Attribute VB_Name = "MyFrame"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Public WithEvents FrameEvents As MSForms.Frame
Attribute FrameEvents.VB_VarHelpID = -1
Attribute VB_Name = "MyInputBox"
Attribute VB_Base = "0{A47E0387-B302-46B9-B180-7402A0D1B2F6}{5A41EE25-24E0-4D79-B8B1-845A0357D87C}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public mMinTextLength As Long

Public Function Display(titleText As String, captionText As String, minTextLength As Long, maxTextLength As Long, allowCancel As Boolean) As String
    Display = ""
    
    Dim frm As New MyInputBox
    frm.mMinTextLength = minTextLength
    
    frm.Caption = captionText
    frm.LabelTitle.Caption = titleText
    frm.DoLayout
    frm.TbText.MaxLength = maxTextLength
    frm.CancelButton.visible = allowCancel
    frm.CheckText
    
    frm.Show vbModal
    Display = frm.TbText.Text
    
    Set frm = Nothing
End Function

Private Sub OkButton_Click()
    Me.Hide
End Sub

Private Sub CancelButton_Click()
    TbText.Text = ""
    Me.Hide
End Sub

Public Sub DoLayout()
    Dim clientHeight As Long
    clientHeight = (OkButton.Top + OkButton.Height) - LabelTitle.Top + 4
    Dim ncHeight As Long
    ncHeight = Height - clientHeight
    
    TbText.Top = LabelTitle.Top + LabelTitle.Height + 4
    OkButton.Top = TbText.Top + TbText.Height + 8
    CancelButton.Top = OkButton.Top
    
    Height = OkButton.Top + OkButton.Height + ncHeight
End Sub

Public Sub CheckText()
    If mMinTextLength > Len(TbText.Text) Then
        OkButton.Enabled = False
    Else
        OkButton.Enabled = True
    End If
End Sub

Private Sub TbText_Change()
    CheckText
End Sub

Private Sub UserForm_Initialize()
    gTranslation.TranslateForm Me
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    Cancel = 1
End Sub

Attribute VB_Name = "MyLabel"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public WithEvents LabelEvents As MSForms.Label
Attribute LabelEvents.VB_VarHelpID = -1
Private m_Form As Object
Private m_Index As Integer

Public Sub Init(frm As Object, ByVal index As Integer)
    Set m_Form = frm
    m_Index = index
End Sub


Private Sub LabelEvents_Click()
    m_Form.Click LabelEvents, m_Index
End Sub

Private Sub Class_Terminate()
    Set LabelEvents = Nothing
    Set m_Form = Nothing
End Sub
Attribute VB_Name = "MyOpenDlg"
Option Explicit

'  Shell File Operations

Private Const FO_MOVE = &H1
Private Const FO_COPY = &H2
Private Const FO_DELETE = &H3
Private Const FO_RENAME = &H4
Private Const FOF_MULTIDESTFILES = &H1
Private Const FOF_CONFIRMMOUSE = &H2
Private Const FOF_SILENT = &H4                      '  don't create progress/report
Private Const FOF_RENAMEONCOLLISION = &H8
Private Const FOF_NOCONFIRMATION = &H10             '  Don't prompt the user.
Private Const FOF_WANTMAPPINGHANDLE = &H20          '  Fill in SHFILEOPSTRUCT.hNameMappings
                                      '  Must be freed using SHFreeNameMappings
Private Const FOF_ALLOWUNDO = &H40
Private Const FOF_FILESONLY = &H80                  '  on *.*, do only files
Private Const FOF_SIMPLEPROGRESS = &H100            '  means don't show names of files
Private Const FOF_NOCONFIRMMKDIR = &H200            '  don't confirm making any needed dirs


#If VBA7 And Win64 Then
  ' Done
     Type SHFILEOPSTRUCT
         hwnd As LongPtr
         wFunc As Long
         pFrom As String
         pTo As String
         fFlags As Integer
         fAborted As Boolean
         hNameMaps As LongPtr
         sProgress As String
     End Type
     Declare PtrSafe Function SHFileOperation Lib "shell32.dll" Alias "SHFileOperationA" _
                                      (lpFileOp As SHFILEOPSTRUCT) As LongPtr
 #Else
     Type SHFILEOPSTRUCT
         hwnd As Long
         wFunc As Long
         pFrom As String
         pTo As String
         fFlags As Integer
         fAborted As Boolean
         hNameMaps As Long
         sProgress As String
     End Type
     Declare Function SHFileOperation Lib "shell32.dll" Alias "SHFileOperationA" _
                                      (lpFileOp As SHFILEOPSTRUCT) As Long
 #End If

Const OFN_READONLY           As Long = &H1
Const OFN_EXPLORER           As Long = &H80000
Const OFN_LONGNAMES          As Long = &H200000
Const OFN_CREATEPROMPT       As Long = &H2000
Const OFN_NODEREFERENCELINKS As Long = &H100000
Const OFN_OVERWRITEPROMPT    As Long = &H2
Const OFN_HIDEREADONLY       As Long = &H4
Const OFN_NOCHANGEDIR        As Long = &H8
Const OFN_PATHMUSTEXIST      As Long = &H800
Const OFN_ENABLEHOOK As Long = &H20
Const OFN_ENABLESIZING As Long = &H800000

Public Const OFS_FILE_OPEN_FLAGS    As Long = OFN_EXPLORER _
                                    Or OFN_LONGNAMES _
                                    Or OFN_CREATEPROMPT _
                                    Or OFN_NODEREFERENCELINKS _
                                    Or OFN_NOCHANGEDIR
                                    
Public Const OFS_FILE_SAVE_FLAGS    As Long = OFN_EXPLORER _
                                    Or OFN_LONGNAMES _
                                    Or OFN_OVERWRITEPROMPT _
                                    Or OFN_HIDEREADONLY
Public Const OFS_FILE_SAVE_FLAGS_NO_PROMPT    As Long = OFN_EXPLORER _
                                    Or OFN_LONGNAMES _
                                    Or OFN_HIDEREADONLY

Public Const WM_INITDIALOG As Long = &H110
Private Const SW_SHOWNORMAL As Long = 1


Private Const BIF_RETURNONLYFSDIRS = 1

Private Const MAX_PATH = 260

#If VBA7 And Win64 Then

Public Declare PtrSafe Function GetOpenFileName Lib "comdlg32.dll" Alias _
             "GetOpenFileNameA" (pOpenfilename As OPENFILENAME) As Long
        
     Public Type OPENFILENAME
         lStructSize As Long
         hwndOwner As LongPtr
         hInstance As LongPtr
         lpstrFilter As String
         lpstrCustomFilter As String
         nMaxCustFilter As Long
         nFilterIndex  As Long
         lpstrFile As String
         nMaxFile As Long
         lpstrFileTitle As String
         nMaxFileTitle  As Long
         lpstrInitialDir As String
         lpstrTitle As String
         flags As Long
         nFileOffset As Integer
         nFileExtension As Integer
         lpstrDefExt As String
         lCustData As LongPtr
         lpfnHook As LongPtr
         lpTemplateName As String
     End Type
    

  ' Done
Private Declare PtrSafe Function GetParent Lib "user32" (ByVal hwnd As LongPtr) As LongPtr
' Private Declare PtrSafe Function SetWindowText Lib "user32" Alias "SetWindowTextA" (ByVal hwnd As LongPtr, ByVal lpString As String) As Long
' Private Declare PtrSafe Function MoveWindow Lib "user32" (ByVal hwnd As LongPtr, ByVal x As Long, ByVal y As Long, ByVal nWidth As Long, ByVal nHeight As Long, ByVal bRepaint As Long) As Long
Private Declare PtrSafe Function GetWindowRect Lib "user32" (ByVal hwnd As LongPtr, lpRect As RECT) As Long
  

Declare PtrSafe Function GetSaveFileName Lib "comdlg32.dll" Alias _
    "GetSaveFileNameA" (pOpenfilename As OPENFILENAME) As Long
Declare PtrSafe Function GetShortPathName Lib "Kernel32.dll" Alias _
    "GetShortPathNameA" (ByVal lpszLongPath As String, _
                         ByVal lpszShortPath As String, _
                         ByVal cchBuffer As Long) As Long


Private Declare PtrSafe Sub CoTaskMemFree Lib "ole32.dll" _
     (ByVal hMem As LongPtr)

Private Declare PtrSafe Function lstrcat Lib "kernel32" Alias "lstrcatA" (ByVal lpString1 As String, ByVal lpString2 As String) As LongPtr

Private Declare PtrSafe Function SHGetPathFromIDList Lib "shell32" _
   (ByVal pidList As LongPtr, ByVal lpBuffer As String) As Long


     Public Type BROWSEINFO
         lngHWnd As LongPtr
         pidlRoot As LongPtr
         pszDisplayName As String
         lpszTitle As String
         ulFlags As Long
         lpfn As LongPtr
         lParam As LongPtr
         iImage As Long
     End Type
                         
     Private Declare PtrSafe Function SHBrowseForFolder Lib "shell32.dll" Alias "SHBrowseForFolderA" _
         (lpBrowseInfo As BROWSEINFO) As Long

#Else

    Public Declare Function GetOpenFileName Lib "comdlg32.dll" Alias _
             "GetOpenFileNameA" (pOpenfilename As OPENFILENAME) As Long
        
     Public Type OPENFILENAME
         lStructSize As Long
         hwndOwner As Long
         hInstance As Long
         lpstrFilter As String
         lpstrCustomFilter As String
         nMaxCustFilter As Long
         nFilterIndex  As Long
         lpstrFile As String
         nMaxFile As Long
         lpstrFileTitle As String
         nMaxFileTitle  As Long
         lpstrInitialDir As String
         lpstrTitle As String
         flags As Long
         nFileOffset As Integer
         nFileExtension As Integer
         lpstrDefExt As String
         lCustData As Long
         lpfnHook As Long
         lpTemplateName As String
     End Type

Private Declare Function GetParent Lib "user32" (ByVal hwnd As Long) As Long
' Private Declare Function SetWindowText Lib "user32" Alias "SetWindowTextA" (ByVal hwnd As Long, ByVal lpString As String) As Long
' Private Declare Function MoveWindow Lib "user32" (ByVal hwnd As Long, ByVal x As Long, ByVal y As Long, ByVal nWidth As Long, ByVal nHeight As Long, ByVal bRepaint As Long) As Long
   
Private Declare Function GetWindowRect Lib "user32" (ByVal hwnd As Long, lpRect As RECT) As Long
   
Declare Function GetSaveFileName Lib "comdlg32.dll" Alias _
    "GetSaveFileNameA" (pOpenfilename As OPENFILENAME) As Long
Declare Function GetShortPathName Lib "Kernel32.dll" Alias _
    "GetShortPathNameA" (ByVal lpszLongPath As String, _
                         ByVal lpszShortPath As String, _
                         ByVal cchBuffer As Long) As Long


Private Declare Sub CoTaskMemFree Lib "ole32.dll" _
     (ByVal hMem As Long)

Private Declare Function lstrcat Lib "kernel32" _
    Alias "lstrcatA" (ByVal lpString1 As String, _
    ByVal lpString2 As String) As Long

Private Declare Function SHGetPathFromIDList Lib "shell32" _
   (ByVal pidList As Long, ByVal lpBuffer As String) As Long


     Public Type BROWSEINFO
         lngHWnd As Long
         pidlRoot As Long
         pszDisplayName As String
         lpszTitle As String
         ulFlags As Long
         lpfn As Long
         lParam As Long
         iImage As Long
     End Type
                         
     Private Declare Function SHBrowseForFolder Lib "shell32.dll" Alias "SHBrowseForFolderA" _
         (lpBrowseInfo As BROWSEINFO) As Long

#End If

Public Function BrowseForFolder(ByVal lngHWnd As Long, ByVal strPrompt As String) As String
    On Error GoTo ehBrowseForFolder 'Trap for errors
    BrowseForFolder = ""
    Dim intNull As Integer
#If VBA7 And Win64 Then
    Dim lngIDList As LongPtr
#Else
    Dim lngIDList As Long
#End If
    Dim lngResult As Long
    Dim strPath As String
    Dim udtBI As BROWSEINFO

    'Set API properties (housed in a UDT)

    With udtBI
        .lngHWnd = lngHWnd
        .lpszTitle = lstrcat(strPrompt, "")
        .ulFlags = BIF_RETURNONLYFSDIRS
    End With

    'Display the browse folder...
    lngIDList = SHBrowseForFolder(udtBI)
    If lngIDList <> 0 Then
        'Create string of nulls so it will fill in with the path
        strPath = String(MAX_PATH, 0)

       'Retrieves the path selected, places in the null
       'character filled string
        lngResult = SHGetPathFromIDList(lngIDList, strPath)

       'Frees memory
       Call CoTaskMemFree(lngIDList)

       'Find the first instance of a null character,
         'so we can get just the path
        intNull = InStr(strPath, vbNullChar)
        'Greater than 0 means the path exists...
        If intNull > 0 Then
            'Set the value
            strPath = Left(strPath, intNull - 1)
        End If
    End If

   'Return the path name
   If Len(strPath) > 0 Then
     If Right(strPath, 1) = "\" Then
       strPath = Left(strPath, Len(strPath) - 1)
     End If
   End If
   BrowseForFolder = strPath
   Exit Function 'Abort

ehBrowseForFolder:

End Function

Public Sub SyncCopy(Dateiname$, zielverzeichnis$)

Dim filenames$
Dim i As Integer
Dim shellinfo As SHFILEOPSTRUCT

filenames = Dateiname + Chr(0)

With shellinfo
        .hwnd = 0 ' Screen.ActiveForm.Hwnd
        .wFunc = FO_COPY
        .pFrom = filenames
        .pTo = zielverzeichnis
        .fFlags = FOF_FILESONLY + FOF_NOCONFIRMATION + FOF_NOCONFIRMMKDIR + FOF_SILENT
End With

SHFileOperation shellinfo

End Sub

' Dateioperationen

Public Sub CopyFile(Dateiname$, zielverzeichnis$, Optional inklusiveUnterverzeichnisse)

On Error Resume Next
  Dim arr(1) As String
  arr(0) = Dateiname
  
  If UCase(Left(Dateiname, 7)) = "HTTP://" Or UCase(Left(Dateiname, 8)) = "HTTPS://" Then
    DownloadFile Dateiname, zielverzeichnis ' & "\" & GetFileNameAndExtension(Dateiname)
  Else
    CopyPlus arr, zielverzeichnis, inklusiveUnterverzeichnisse
  End If

End Sub

Public Sub CopyPlus(dateinamen$(), zielverzeichnis$, Optional inklusiveUnterverzeichnisse)

Dim filenames$
Dim i As Integer
Dim shellinfo As SHFILEOPSTRUCT

For i = 0 To UBound(dateinamen)
    filenames = filenames & dateinamen(i) + Chr(0)
Next i
filenames = filenames + Chr(0)

With shellinfo
        .hwnd = 0 ' Screen.ActiveForm.Hwnd
        .wFunc = FO_COPY
        .pFrom = filenames
        .pTo = zielverzeichnis
        If Not IsMissing(inklusiveUnterverzeichnisse) Then
            If Not inklusiveUnterverzeichnisse Then .fFlags = FOF_FILESONLY
        End If
End With

SHFileOperation shellinfo

End Sub

Public Function Move(dateinamen$(), zielverzeichnis$, Optional inklusiveUnterverzeichnisse)

Dim filenames$
Dim i As Integer
Dim shellinfo As SHFILEOPSTRUCT

For i = 0 To UBound(dateinamen)
    filenames = filenames & dateinamen(i) + Chr(0)
Next i
filenames = filenames + Chr(0)

With shellinfo
        .hwnd = 0 ' Screen.ActiveForm.Hwnd
        .wFunc = FO_COPY
        .pFrom = filenames
        .pTo = zielverzeichnis
        If Not IsMissing(inklusiveUnterverzeichnisse) Then
            If Not inklusiveUnterverzeichnisse Then .fFlags = FOF_FILESONLY
        End If
End With

SHFileOperation shellinfo

End Function

Public Function Delete(dateinamen$(), Optional inklusiveUnterverzeichnisse)
Dim filenames$
Dim i As Integer
Dim shellinfo As SHFILEOPSTRUCT

For i = 0 To UBound(dateinamen)
    filenames = filenames & dateinamen(i) + Chr(0)
Next i
filenames = filenames + Chr(0)

With shellinfo
        .hwnd = 0 ' Screen.ActiveForm.Hwnd
        .wFunc = FO_DELETE
        .pFrom = filenames
        .pTo = "" + Chr(0)
        If Not IsMissing(inklusiveUnterverzeichnisse) Then
            If Not inklusiveUnterverzeichnisse Then .fFlags = FOF_FILESONLY
        End If
End With

SHFileOperation shellinfo

End Function


'Function EinfacheDateiauswahl(Optional flgs As Long = OFS_FILE_OPEN_FLAGS, Optional title As String = "Bitte w|fffd|hlen Sie eine Datei aus:") As String
Function EinfacheDateiauswahl(Optional flgs As Long = OFS_FILE_OPEN_FLAGS, Optional title As String = vbNullString) As String
  
    If title = vbNullString Then
      'title = "Bitte w|fffd|hlen Sie eine Datei aus:"
      title = FMT0("OPENDLG_1")
    End If

    Dim OpenFile    As OPENFILENAME
    Dim lReturn     As Long


'// --------------------------------------------------------------------------
'// Filter setzen und Index auf 2 (Datenbanken) setzen
'// Format: "Name" \n "Ext." \n "Name" \n "Ext." ... \n\n
'// --------------------------------------------------------------------------
    Dim sFilter As String
    'sFilter = "Alle Dateien (*.*)" & vbNullChar & "*.*" & vbNullChar & "Textdateien (*.txt)" & vbNullChar & "*.txt"
    sFilter = FMT0("OPENDLG_2") & vbNullChar & "*.*" & vbNullChar & FMT0("OPENDLG_3") & vbNullChar & "*.txt"
    sFilter = sFilter & vbNullChar & vbNullChar
    OpenFile.lpstrFilter = sFilter
    OpenFile.nFilterIndex = 0
    
    OpenFile.hwndOwner = 0
    OpenFile.lpstrFile = String(257, 0)
    #If VBA7 And Win64 Then
        OpenFile.nMaxFile = LenB(OpenFile.lpstrFile) - 1
        OpenFile.lStructSize = LenB(OpenFile)
    #Else
        OpenFile.nMaxFile = Len(OpenFile.lpstrFile) - 1
        OpenFile.lStructSize = Len(OpenFile)
    #End If
    OpenFile.lpstrFileTitle = OpenFile.lpstrFile
    OpenFile.nMaxFileTitle = OpenFile.nMaxFile
    OpenFile.lpstrInitialDir = "C:\"
    OpenFile.lpstrTitle = title
    #If VBA7 And Win64 Then
      OpenFile.flags = flgs Or OFN_ENABLESIZING
      ' XXX64
      ' OpenFile.lpfnHook = FARPROC(AddressOf OFNHookProc)
    #Else
      OpenFile.flags = flgs Or OFN_ENABLESIZING Or OFN_ENABLEHOOK
      OpenFile.lpfnHook = FARPROC(AddressOf OFNHookProc)
    #End If
'    uOFN.flags = flgs Or OFN_ENABLESIZING Or OFN_ENABLEHOOK


     lReturn = GetOpenFileName(OpenFile)
    
     If lReturn = 0 Then
         EinfacheDateiauswahl = ""
     Else
         EinfacheDateiauswahl = Trim(Left(OpenFile.lpstrFile, InStr(1, OpenFile.lpstrFile, vbNullChar) - 1))
     End If

End Function

'Function EinfachesSaveAs(dateibezeichnung As String, extn As String, strInitDir As String, oldfname As String, Optional flgs As Long = OFS_FILE_SAVE_FLAGS, _
'  Optional title As String = "Datei speichern unter...") As String
Function EinfachesSaveAs(dateibezeichnung As String, extn As String, strInitDir As String, oldfname As String, Optional flgs As Long = OFS_FILE_SAVE_FLAGS, _
  Optional title As String = vbNullString) As String
  
  If title = vbNullString Then
    'title = "Datei speichern unter..."
    title = FMT0("OPENDLG_4")
  End If

    Dim OpenFile    As OPENFILENAME
    Dim lReturn     As Long


'// --------------------------------------------------------------------------
'// Filter setzen und Index auf 2 (Datenbanken) setzen
'// Format: "Name" \n "Ext." \n "Name" \n "Ext." ... \n\n
'// --------------------------------------------------------------------------
    Dim sFilter As String
    sFilter = dateibezeichnung & " (*." & extn & ")" & vbNullChar & "*." & extn
    sFilter = sFilter & vbNullChar & vbNullChar
    OpenFile.lpstrFilter = sFilter
    OpenFile.nFilterIndex = 0
    
    OpenFile.hwndOwner = 0
    OpenFile.lpstrFile = String(257, 0)
    #If VBA7 And Win64 Then
        OpenFile.nMaxFile = LenB(OpenFile.lpstrFile) - 1
        OpenFile.lStructSize = LenB(OpenFile)
    #Else
        OpenFile.nMaxFile = Len(OpenFile.lpstrFile) - 1
        OpenFile.lStructSize = Len(OpenFile)
    #End If
    OpenFile.lpstrFileTitle = OpenFile.lpstrFile
    OpenFile.nMaxFileTitle = OpenFile.nMaxFile
    OpenFile.lpstrInitialDir = "C:\"
    OpenFile.lpstrTitle = title
    #If VBA7 And Win64 Then
      OpenFile.flags = flgs Or OFN_ENABLESIZING
      ' XXX64
      ' OpenFile.lpfnHook = FARPROC(AddressOf OFNHookProc)
    #Else
      OpenFile.flags = flgs Or OFN_ENABLESIZING Or OFN_ENABLEHOOK
      OpenFile.lpfnHook = FARPROC(AddressOf OFNHookProc)
    #End If
'    uOFN.flags = flgs Or OFN_ENABLESIZING Or OFN_ENABLEHOOK


     lReturn = GetSaveFileName(OpenFile)
    
     If lReturn = 0 Then
         EinfachesSaveAs = ""
     Else
         EinfachesSaveAs = Trim(Left(OpenFile.lpstrFile, InStr(1, OpenFile.lpstrFile, vbNullChar) - 1))
     End If

End Function

Sub TestEinfachesSaveAs()
    Debug.Print EinfachesSaveAs(FMT0("ETDLL_15"), "xl*", Application.ActiveWorkbook.path, "ABC_PROT_.xlsx", OFS_FILE_SAVE_FLAGS_NO_PROMPT)
End Sub


Public Function FARPROC(ByVal pfn As Long) As Long
  
  'Dummy procedure that receives and returns
  'the return value of the AddressOf operator.
 
  'Obtain and set the address of the callback
  'This workaround is needed as you can't assign
  'AddressOf directly to a member of a user-
  'defined type, but you can assign it to another
  'long and use that (as returned here)
   FARPROC = pfn

End Function

#If VBA7 And Win64 Then
Public Function OFNHookProc(ByVal hwnd As LongPtr, _
                            ByVal uMsg As Long, _
                            ByVal wParam As Long, _
                            ByVal lParam As Long) As Long

#Else
Public Function OFNHookProc(ByVal hwnd As Long, _
                            ByVal uMsg As Long, _
                            ByVal wParam As Long, _
                            ByVal lParam As Long) As Long
#End If

  'On initialization, set aspects of the
  'dialog that are not obtainable through
  'manipulating the OPENFILENAME structure members.
  
#If VBA7 And Win64 Then
   Dim hwndParent As LongPtr
#Else
   Dim hwndParent As Long
#End If
   Dim rc As RECT
   
  'temporary vars for demo
   Dim newLeft As Long
   Dim newTop As Long
   Dim dlgWidth As Long
   Dim dlgHeight As Long
   Dim scrWidth As Long
   Dim scrHeight As Long
            
   Select Case uMsg
      Case WM_INITDIALOG
      
        'obtain the handle to the parent dialog
         hwndParent = GetParent(hwnd)
         
         If hwndParent <> 0 Then
         
           'Just to prove the handle was obtained,
           'change the dialog's caption.
'            Call SetWindowText(hwndParent, "I'm Hooked on Hooked Dialogs!")
            
           'Position the dialog in the centre of
           'the screen. First get the current dialog size.
            Call GetWindowRect(hwndParent, rc)
            
           '(To show the calculations involved, I've
           'used variables instead of creating a
           'one-line MoveWindow call)
            dlgWidth = rc.Right - rc.Left
            dlgHeight = rc.Bottom - rc.Top
            
            'scrWidth = Screen.Width \ Screen.TwipsPerPixelX
            'scrHeight = Screen.Height \ Screen.TwipsPerPixelY
            
            'newLeft = (scrWidth - dlgWidth) \ 2
            'newTop = (scrHeight - dlgHeight) \ 2
            
           '..and set the new dialog position.
            'Call MoveWindow(hwndParent, newLeft, newTop, dlgWidth, dlgHeight, True)
            
            OFNHookProc = 1
            
         End If
         
         Case Else
         
   End Select

End Function


Attribute VB_Name = "MyOptionButton"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public WithEvents OptionButtonEvents As MSForms.OptionButton
Attribute OptionButtonEvents.VB_VarHelpID = -1
Private m_Form As Object
Private m_Index As Integer

Public Sub Init(frm As Object, ByVal index As Integer)
    Set m_Form = frm
    m_Index = index
End Sub


Private Sub OptionButtonEvents_Click()
  On Error Resume Next
  If Not m_Form Is Nothing Then
    m_Form.ClickOption OptionButtonEvents, m_Index
    m_Form.PropertyChanged
  End If
End Sub

Private Sub Class_Terminate()
    Set OptionButtonEvents = Nothing
    Set m_Form = Nothing
End Sub
Attribute VB_Name = "MyTextBox"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public WithEvents TextBoxEvents As MSForms.TextBox
Attribute TextBoxEvents.VB_VarHelpID = -1
Private m_Form As Object
Private m_Index As Integer

Public Sub Init(frm As Object, ByVal index As Integer)
    Set m_Form = frm
    m_Index = index
End Sub
Public Sub TextBoxEvents_Change()
    
    On Error Resume Next
    If Len(Me.TextBoxEvents.Text) > Me.TextBoxEvents.MaxLength And Me.TextBoxEvents.MaxLength > 0 Then
        Me.TextBoxEvents.Text = Left(Me.TextBoxEvents.Text, Me.TextBoxEvents.MaxLength)
    End If
    If Not m_Form Is Nothing Then
      ' Muss nicht implementiert sein, on error next |fffd|bergeht fehlende Funktionen
      m_Form.TextBox_Change m_Index
      m_Form.PropertyChanged
    End If
End Sub

Private Sub Class_Terminate()
    Set TextBoxEvents = Nothing
    Set m_Form = Nothing
End Sub


Attribute VB_Name = "OEStruct"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit


Public m_OEID As Long
Public m_Kuerzel As String
Public m_Subs As Collection
Public m_Parent As String

Private Sub Class_Initialize()
    Set m_Subs = New Collection
    m_OEID = -1
End Sub


Function FindMyOE(ByVal myOE As Long) As OEStruct
    If m_OEID = myOE Then
        Set FindMyOE = Me
        Exit Function
    End If

    Dim oes As OEStruct
    For Each oes In m_Subs
        Dim toes As OEStruct
        Set toes = oes.FindMyOE(myOE)
        If Not toes Is Nothing Then
            Set FindMyOE = toes
            Exit Function
        End If
    Next oes

    Set FindMyOE = Nothing

End Function


Function PrintMyOEs() As String
  On Error Resume Next
  
  Dim s As String
  
  s = m_OEID

  Dim oes As OEStruct
  For Each oes In m_Subs
    s = s & "," & oes.PrintMyOEs()
  Next oes
  PrintMyOEs = s
End Function

Attribute VB_Name = "OfficeStuff"
Option Explicit


Function GetCurrentProjectObject(officeapp As Object) As Object
' Funktion wird nicht mehr aufgerufen
#If PROJECT_ACCESSTRACKER <> 0 Then
  Set GetCurrentProjectObject = officeapp.CurrentProject
#ElseIf PROJECT_FILETRACKER <> 0 Then
  Set GetCurrentProjectObject = officeapp
#Else
  Set GetCurrentProjectObject = officeapp.ActiveWorkbook
#End If
End Function

Function GetCurrentProjectDoc(officeapp As Object) As Object
' Funktion wird nicht aufgerufen
#If PROJECT_ACCESSTRACKER <> 0 Then
  Set GetCurrentProjectDoc = officeapp.CurrentProject
#Else
  Set GetCurrentProjectDoc = officeapp.ActiveWorkbook
#End If
End Function

Function GetCurrentDocUNCPathFromApp(officeapp As Object) As String
    GetCurrentDocUNCPathFromApp = ""
#If PROJECT_ACCESSTRACKER <> 0 Then
  GetCurrentDocUNCPathFromApp = GetUNCPath(officeapp.CurrentProject.fullname)
#Else
  If Not officeapp.ActiveWorkbook Is Nothing Then
    GetCurrentDocUNCPathFromApp = GetUNCPath(officeapp.ActiveWorkbook.fullname)
  End If
#End If
End Function

Function GetUNCPathFromDoc(curdoc As Object) As String
  GetUNCPathFromDoc = GetUNCPath(curdoc.fullname)
End Function

Function GetCurrentDocNormalPath(officeapp As Object) As String
' Funktion wird nicht mehr genutzt
#If PROJECT_ACCESSTRACKER <> 0 Then
  GetCurrentDocNormalPath = officeapp.CurrentProject.fullname
#Else
  GetCurrentDocNormalPath = officeapp.ActiveWorkbook.fullname
#End If
End Function

Function GetCurrentDocUNCPathURL(curdoc As Object) As String
  GetCurrentDocUNCPathURL = ""
  If Not curdoc Is Nothing Then
#If PROJECT_ACCESSTRACKER <> 0 Then
      GetCurrentDocUNCPathURL = GetUNCPath(curdoc.fullname)
#Else
    On Error GoTo raus
    If curdoc.FullNameURLEncoded <> curdoc.fullname Then
        GetCurrentDocUNCPathURL = curdoc.FullNameURLEncoded
    End If
#End If
  End If
raus:
End Function

' Function GetCurrentDocInExcelProjectInAccess(officeapp As Object) As Object
' #If PROJECT_ACCESSTRACKER <> 0 Then
'   Set GetCurrentDocInExcelProjectInAccess = G_Connect.accapp
' #Else
'   Set GetCurrentDocInExcelProjectInAccess = officeapp.ActiveWorkbook
' #End If
'End Function

Sub OfficeAppDisplayAlerts(officeapp As Object, b As Boolean)
On Error Resume Next
#If PROJECT_ACCESSTRACKER = 0 Then
    officeapp.DisplayAlerts = b
#Else
    officeapp.docmd.setwarnings b
#End If
End Sub


Attribute VB_Name = "Passwoerter"
Option Explicit

Public G_CheckDateiberechtigungBeimOeffnen As Boolean

Public Function CryptPasswort(ByVal s As String) As String
    CryptPasswort = Crypt(s, "T0)7/hJy+\1TrcpI?", True)
End Function

Public Function DecryptPasswort(ByVal s As String) As String
    DecryptPasswort = Crypt(s, "T0)7/hJy+\1TrcpI?", False)
End Function

Public Function CreateRandomPasswort() As String
    CreateRandomPasswort = GetStandardPassword() ' Format$(Now, "dd.mm.yyyy")
End Function

Public Function GetStandardPassword() As String
    GetStandardPassword = FirmenPasswort(G_LizenznehmerAdresse)   ' "NDR9)oio0(rrl5/mfk677&" & Left(G_Lizenznehmer & "        ", 8)
End Function
Public Function GetStandardPasswordBlattschutz() As String
    GetStandardPasswordBlattschutz = Left(FirmenPasswort(Right(G_Lizenznehmer, 8) & G_LizenznehmerAdresse), 16)  ' "NDR9)oio0(rrl5/mfk677&" & Left(G_Lizenznehmer & "        ", 8)
End Function

    Public Sub SortiereIndex(ByVal zeile As String, ByRef zIndex() As Long)
        Dim i As Long
        Dim l As Long

        For i = 1 To 8
            Dim kl As String
            kl = Mid(zeile, i, 1)
            Dim klindex As Integer
            klindex = 1
            For l = 2 To 8
                If kl = " " Or Mid(zeile, l, 1) < kl Then
                    If Mid(zeile, l, 1) <> " " Then
                        kl = Mid(zeile, l, 1)
                        klindex = l
                    End If
                End If
            Next
            zIndex(i) = klindex
            Mid(zeile, klindex, 1) = " "
        Next
    End Sub

    Public Function FirmenPasswort(ByVal firmenname As String) As String
        Dim zeichen(8) As String
        
        firmenname = Replace(firmenname, vbCr, "")
        firmenname = Replace(firmenname, vbLf, "")
        firmenname = Replace(firmenname, vbTab, "")

        zeichen(3) = "mnbvcxy&"
        zeichen(4) = "ASDFGHJK"
        zeichen(5) = "12345678"
        zeichen(6) = "QWER?\{}"
        zeichen(7) = "&[]*+-/|fffd|"
        zeichen(8) = "!(/&abcd"

        Dim zeile As String
        Dim spalte As String

        zeile = ""
        spalte = ""

        Dim i As Long
        Dim l As Long
        Dim m As Long
        If Len(firmenname) < 16 Then
            firmenname = firmenname & Left("Ein16stellenText", 16 - Len(firmenname))
        End If
        m = Len(firmenname) / 2
        For i = 0 To 3
            zeile = zeile & Mid(firmenname, m - i, 1)
            zeile = zeile & Mid(firmenname, m + i + 1, 1)
            spalte = spalte & Mid(firmenname, m - i - 4, 1)
            spalte = spalte & Mid(firmenname, m + i + 5, 1)
        Next i
        zeile = Replace(zeile, " ", "A")
        spalte = Replace(spalte, " ", "B")
        zeichen(1) = zeile
        zeichen(2) = spalte

        ' Sortieren und Indizes merken
        Dim zIndex(8) As Long
        Dim sindex(8) As Long
        SortiereIndex zeile, zIndex
        SortiereIndex spalte, sindex

        For i = 1 To 8
            Dim z As String
            z = ""
            For l = 1 To 8
                z = z & Mid(zeichen(i), zIndex(l), 1)
            Next
            zeichen(i) = z
        Next

        Dim Result(8) As String

        For i = 1 To 8
            Result(i) = "00000000"
        Next

        Dim s As Long
        For s = 1 To 8
            For l = 1 To 8
                Mid(Result(l), s, 1) = Mid(zeichen(sindex(l)), s, 1)
            Next
        Next

        FirmenPasswort = Result(1) & Result(2) & Result(3) & Result(4) & Result(7) & Result(8)

    End Function



Public Function StoreRandomPasswordFuerDatei(ByRef conn As Object, ByVal idvDateiID As String)

    Dim rs As Object
    ' wenn es noch kein Passwort gibt, dann erstellen wir ein neues
On Error GoTo fehler
    Set rs = CreateObject("ADODB.Recordset")
    
    rs.Open "SELECT * from idvDateienPW WHERE idvDateiID = " & idvDateiID & " and PWTyp = 1", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockOptimistic
    If rs Is Nothing Then
        StoreRandomPasswordFuerDatei = False
        Exit Function
    End If
    
    If rs.EOF = True Then
        rs.AddNew
        rs.Fields("idvDateiID").value = idvDateiID
        rs.Fields("LogonID").value = Left(GetUserNameUCASE(), 20)
        rs.Fields("Datum").value = Now
    End If
    Dim pw As String
    pw = CryptPasswort(CreateRandomPasswort())
    rs.Fields("Passwort").value = pw
    rs.Fields("PWTyp").value = 1
    rs.Update
        
    ' zur Sicherheit noch in die Log Tabelle schreiben
    'Dim rsAllePW As Object
    'Set rsAllePW = CreateObject("ADODB.Recordset")
    'If Not rsAllePW Is Nothing Then
    '    rsAllePW.Open "SELECT * from idvDateienPWLog", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockOptimistic
    '    rsAllePW.AddNew
    '    rsAllePW.Fields("idvDateiID").Value = idvDateiID
    '    rsAllePW.Fields("Passwort").Value = pws
    '    rsAllePW.Update
    '    rsAllePW.Close
    'End If
    'Set rsAllePW = Nothing
    
    Set rs = Nothing
    StoreRandomPasswordFuerDatei = True
    Exit Function
    
fehler:
    StoreRandomPasswordFuerDatei = False
End Function


Public Function RemoveFileOpenPasswordFuerDatei(ByRef conn As Object, ByVal idvDateiID As String)

    Dim rs As Object
    ' wenn es noch kein Passwort gibt, dann erstellen wir ein neues
On Error GoTo fehler
    Set rs = CreateObject("ADODB.Recordset")
    
    rs.Open "SELECT * from idvDateienPW WHERE idvDateiID = " & idvDateiID & " and PWTyp = 1", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockOptimistic
    If rs Is Nothing Then
        RemoveFileOpenPasswordFuerDatei = False
        Exit Function
    End If
    
    If rs.EOF = False Then
        rs.Delete
        rs.Update
        rs.Close
    End If
    RemoveFileOpenPasswordFuerDatei = True
fehler:
    Set rs = Nothing
End Function


Public Function GetFileOpenPassword(ByRef conn As Object, ByRef rs As Object) As String
    GetFileOpenPassword = ""
    
    ' wenn es noch kein Passwort gibt, dann erstellen wir ein neues
On Error GoTo fehler
    If Not rs Is Nothing Then
        Dim berechtigungAn As Boolean
        berechtigungAn = False
        If rs.Fields("Dateiberechtigungen").value <> 0 Then
            berechtigungAn = True
        End If
        If berechtigungAn = True Then
            GetFileOpenPassword = GetStandardPassword()
        Else
          Dim rsPW As Object
          Set rsPW = CreateObject("ADODB.Recordset")
          rsPW.Open "Select Passwort from idvDateienPW where idvDateiID = " & rs.Fields("idvDateiID") & " and PWTyp = 1", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
          If Not rsPW Is Nothing Then
              If rsPW.EOF = False Then
                  GetFileOpenPassword = DecryptPasswort(rsPW.Fields("Passwort").value)
              End If
              rsPW.Close
          End If
          Set rsPW = Nothing
        End If
    End If
    Exit Function
    
fehler:
    GetFileOpenPassword = ""
    
End Function

Public Function HatDateiFileOpenPasswordConn(ByRef conn As Object, ByVal fname As String, ByVal id As Long, ByRef pw As String) As Boolean
    HatDateiFileOpenPasswordConn = False

On Error Resume Next
    
    Dim rs As Object
    Dim curid As Long
    Dim hash As String

    Dim wasLocked As Boolean
    
    If id > 0 Then
      Set rs = OpenRS("SELECT * FROM idvDateien WHERE idvDateiID = " & id, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
      curid = id
    Else
      GetTargetRSFromFilename conn, GetUNCPath(fname), rs, curid
    End If
    
    If Not rs Is Nothing Then
        If rs.Fields("Dateiberechtigungen").value <> 0 Then
            Dim rsBerechtigung As Object
            Set rsBerechtigung = CreateObject("ADODB.Recordset")
            rsBerechtigung.Open "Select * from idvDateienBerechtigungen where idvDateiID = " & curid & " and typ = 1 and Berechtigungstraeger = '" & GetUserNameUCASE() & "'", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
            If Not rsBerechtigung Is Nothing Then
                If rsBerechtigung.EOF = False Then
                    pw = GetStandardPassword
                    HatDateiFileOpenPasswordConn = True
                End If
                rsBerechtigung.Close
            End If
            Set rsBerechtigung = Nothing
        Else
            Dim rsPW As Object
            Set rsPW = CreateObject("ADODB.Recordset")
            rsPW.Open "Select Passwort from idvDateienPW where idvDateiID = " & id & " and PWTyp = 1", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
            If Not rsPW Is Nothing Then
                If rsPW.EOF = False Then
                    pw = DecryptPasswort(rsPW.Fields("Passwort").value)
                    HatDateiFileOpenPasswordConn = True
                End If
                rsPW.Close
            End If
            Set rsPW = Nothing
        End If
        rs.Close
    End If
    Set rs = Nothing
End Function


Public Function HatDateiFileOpenPassword(ByVal fname As String, ByRef pw As String) As Boolean
    HatDateiFileOpenPassword = False

On Error Resume Next
    Dim conn As Object
    Set conn = GetConnection
    
    HatDateiFileOpenPassword = HatDateiFileOpenPasswordConn(conn, fname, -1, pw)
    
    conn.Close
    Set conn = Nothing
End Function


Public Function GetFilePasswordFromID(ByRef conn As Object, ByVal id As Long) As String
  Dim typ As Long
  GetFilePasswordFromID = GetFilePasswordFromIDWithTyp(conn, typ, id)

End Function

' typ:
' -1 = Locked, kann nicht ermittelt werden
' 0 = Kein Passwort
' 1 = Systempasswort
' 2 = Hinterlegtes Passwort

Public Function GetFilePasswordFromIDWithTyp(ByRef conn As Object, ByRef typ As Long, ByVal id As Long) As String
    GetFilePasswordFromIDWithTyp = ""
    
    Dim rs As Object
    Dim hash As String

    ' Wenn Sie bereits gespeichert wurde...
    Dim wasLocked As Boolean
    typ = -1
    
    Set rs = OpenRS("SELECT Dateiberechtigungen FROM idvDateien WHERE idvDateiID = " & id, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
    
    If wasLocked Then Exit Function
    
    typ = 0
    
    If Not rs Is Nothing Then
        If rs.Fields("Dateiberechtigungen").value <> 0 Then
            ' Berechtigung des aktuellen Users pr|fffd|fen
            
            Dim rsBerechtigung As Object
            Set rsBerechtigung = CreateObject("ADODB.Recordset")
            rsBerechtigung.Open "Select * from idvDateienBerechtigungen where idvDateiID = " & id & " and typ = 1 and Berechtigungstraeger = '" & GetUserNameUCASE() & "'", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
            If Not rsBerechtigung Is Nothing Then
                If rsBerechtigung.EOF = False Then
                    GetFilePasswordFromIDWithTyp = GetStandardPassword()
                    typ = 1
                End If
                rsBerechtigung.Close
            End If
            Set rsBerechtigung = Nothing
        
            rs.Close
            Set rs = Nothing
            Exit Function
        Else
            Dim rsPW As Object
            Set rsPW = CreateObject("ADODB.Recordset")
            rsPW.Open "Select Passwort from idvDateienPW where idvDateiID = " & id & " and PWTyp = 1", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
            If Not rsPW Is Nothing Then
                If rsPW.EOF = False Then
                    GetFilePasswordFromIDWithTyp = DecryptPasswort(rsPW.Fields("Passwort").value)
                    typ = 2
                End If
                rsPW.Close
            End If
            Set rsPW = Nothing
        End If
        rs.Close
        Set rs = Nothing
    End If
    Exit Function
    
fehler:
    GetFilePasswordFromIDWithTyp = ""
    

End Function

Public Function GetFilePassword(ByRef conn As Object, ByVal fname As String) As String
    GetFilePassword = ""
    
    Dim rs As Object
    Dim curid As Long
    Dim hash As String

    ' Wenn Sie bereits gespeichert wurde...
    Dim wasLocked As Boolean
    If GetTargetRSFromFilename(conn, GetUNCPath(fname), rs, curid) Then
        If Not rs Is Nothing Then
            If rs.Fields("Dateiberechtigungen").value <> 0 Then
                ' Berechtigung des aktuellen Users pr|fffd|fen
                
                Dim rsBerechtigung As Object
                Set rsBerechtigung = CreateObject("ADODB.Recordset")
                rsBerechtigung.Open "Select * from idvDateienBerechtigungen where idvDateiID = " & curid & " and typ = 1 and Berechtigungstraeger = '" & GetUserNameUCASE() & "'", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
                If Not rsBerechtigung Is Nothing Then
                    If rsBerechtigung.EOF = False Then
                        GetFilePassword = GetStandardPassword()
                    End If
                    rsBerechtigung.Close
                End If
                Set rsBerechtigung = Nothing
            
                rs.Close
                Set rs = Nothing
                Exit Function
            Else
                Dim rsPW As Object
                Set rsPW = CreateObject("ADODB.Recordset")
                rsPW.Open "Select Passwort from idvDateienPW where idvDateiID = " & curid & " and PWTyp = 1", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
                If Not rsPW Is Nothing Then
                    If rsPW.EOF = False Then
                        GetFilePassword = DecryptPasswort(rsPW.Fields("Passwort").value)
                    End If
                    rsPW.Close
                End If
                Set rsPW = Nothing
            End If
            rs.Close
            Set rs = Nothing
        End If
    End If
    Exit Function
    
fehler:
    GetFilePassword = ""
    
End Function


' Achtung, pr|fffd|ft und schlie|fffd|t die Datei, wenn nicht ok!
' Setzt auch Application.WindowState = G_ActiveWindowStatus, WIRD AUSSCHLIESSLICH BEI gecrypteten Dateien genutzt!!!
Function DateiOeffnenStandardPasswordOK(ByRef xlapp As Object, ByRef wb As Object, ByRef conn As Object, ByRef rs As Recordset) As Boolean

    If Not G_CheckDateiberechtigungBeimOeffnen Then
      DateiOeffnenStandardPasswordOK = True
      Exit Function
    End If
    
    G_CheckDateiberechtigungBeimOeffnen = False

    DateiOeffnenStandardPasswordOK = False
     
    If Not wb Is Nothing Then
        ' Nur wenn das Workbook auch ein Passwort hat UND auch keine Dateiberechtigungen wird das hier gepr|fffd|ft. Ansonsten kann es eh jeder |fffd|ffnen.
        If wb.HasPassword = False And GetSafeFieldPlus(rs, "Dateiberechtigungen", False) = False Then
          DateiOeffnenStandardPasswordOK = True
          Exit Function
        Else

           ' Ok, Passwort war drauf und Dateiberechtigungen an
           Dim q As String
           ' Hat der User eine Berechtigung f|fffd|r diese Datei?
           Dim idvDateiID As Long
           idvDateiID = WBGetValueLong(wb, "_IDVTrackerID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix)
           
           q = "SELECT b.idvDateiID from idvDateienBerechtigungen b WHERE idvDateiID = " & idvDateiID & " and b.Berechtigungstraeger = '" & GetUserNameUCASE() & "'"
           Dim rsBerechtigung As New Recordset
           rsBerechtigung.Open q, conn, 2, 1
           If Not rsBerechtigung Is Nothing Then
               If rsBerechtigung.EOF = False Then
                  ' alles gut, dann Datei offen lassen
                  rsBerechtigung.Close
                  Set rsBerechtigung = Nothing
                  DateiOeffnenStandardPasswordOK = True
                  Exit Function
               End If
               rsBerechtigung.Close
           End If
           ' Berechtigung gibt es nicht, also Workbook wieder schlie|fffd|en
           Set rsBerechtigung = Nothing
        End If
    End If
    wb.Close False
    Set wb = Nothing

End Function

Attribute VB_Name = "QuestionsDialog"
Attribute VB_Base = "0{B267E04C-4B63-4C8F-8B54-A00048204C9B}{70DEDF45-0A1B-4976-9674-ABC178BDEE14}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

' Set the questions with 'SetQuestions'
' There must always be 4 answers per questions (answers array is
' 4 times the size of questions array)
'
' The Arrays must be 0 based!
'
' Leave unused answers as empty string - those won't show up
'

Private Const MinWidth As Integer = 600

' Gelber Textbox-Hintergrund fuer Muss-Kommentare
Private Const MUSS_KOMMENTAR_FARBE = &H11FFFF

Private mConn As Object
Private mFrageID As Long        ' The original FrageID in case this is opened as Checklist Dialog
Private mIsSingleSelect As Boolean
Private mQuestions() As String
Private mQuestionIDs() As Long  ' These are the FrageIDs in case we open this as Group Question Dialog (not the Checklist Dialog)
Private mHinweis() As String
Private mAnswers() As String    ' Four per question
Private mAnswersPreSelection() As Long ' Fuer jede Frage: Welche Antwort soll markiert werden. One per question
Private mChecklistIDs() As Long ' One per question
Private mChecklistType() As Long
Private mWerte() As Double
Private mCLPreSelection() As Boolean    ' Wenn wir als Checkliste aufgerufen werden: enthaelt welche antworten vorselektiert werden sollen
Private mCLSelection() As Variant       ' Speichert die aktuell selektierten Checklistenantworten fuer alle Checklisten in diesem Fragendialog
Private mTitle As String
Private mDateiname As String
Private mTwoColumnAnswers As Boolean
Private mShowBack As Boolean
Private mSingleQuestionMode As Boolean
Private mShowCancel As Boolean
Private mNumDelaysAllowed As Long

Private mInQuestions As Boolean
Private mKommentartext() As String
Private mAnswerIDs() As Long
Private mQuestionActiveAnswerID() As Long

Private mFragendialogKommentar As String

'Private ctrlQuestion As VB.Label
Private CheckBoxWidth As Integer
Private CheckBoxHeight As Integer
Private Cancelled As Boolean
Private BackSelected As Boolean
Private mDate As Date

'Private Declare Function SafeArrayGetDim Lib "oleaut32.dll" (ByRef saArray() As Any) As Long

' Private MainFrame As MyFrame
Private Frame() As MyFrame
Private TbQuestion() As MyTextBox
Private TbComment() As MyTextBox
Private BtChecklist() As MyCommandButton
Private BtHinweis() As MyCommandButton
Private CheckAnswer() As MyOptionButton
Private mNumQuestions As Long
Private mTop As Long
Private m_InInit As Boolean



Private Const DT_TOP = &H0
Private Const DT_LEFT = &H0
Private Const DT_CENTER = &H1
Private Const DT_RIGHT = &H2
Private Const DT_VCENTER = &H4
Private Const DT_BOTTOM = &H8
Private Const DT_WORDBREAK = &H10
Private Const DT_SINGLELINE = &H20
Private Const DT_EXPANDTABS = &H40
Private Const DT_TABSTOP = &H80
Private Const DT_NOCLIP = &H100
Private Const DT_EXTERNALLEADING = &H200
Private Const DT_CALCRECT = &H400
Private Const DT_NOPREFIX = &H800
Private Const DT_INTERNAL = &H1000
Private Const DT_EDITCONTROL = &H2000
Private Const DT_PATH_ELLIPSIS = &H4000
Private Const DT_END_ELLIPSIS = &H8000
Private Const DT_MODIFYSTRING = &H10000
Private Const DT_RTLREADING = &H20000
Private Const DT_WORD_ELLIPSIS = &H40000
   
Private Const LEFT_OFFSET As Long = 14
   
#If VBA7 And Win64 Then
' Done
Private Declare PtrSafe Function GetDeviceCaps Lib "gdi32" _
        (ByVal hdc As LongPtr, ByVal nIndex As Long) As Long
#Else
Private Declare Function GetDeviceCaps Lib "gdi32" _
        (ByVal hdc As Long, ByVal nIndex As Long) As Long
#End If

Private Sub UserForm_Initialize()
    gTranslation.TranslateForm Me
'    subRemoveCloseButton Me
End Sub

Private Sub QueryClose(Cancel As Integer, CloseMode As Integer)
    If CloseMode = vbFormControlMenu Then
        Cancel = True
    End If
End Sub

Private Function DesktopHeight() As Long
    Dim screenRect As RECT
    Dim ret As Long
    ret = GetClientRect(CLng(GetDesktopWindow()), screenRect)
    DesktopHeight = screenRect.Bottom - screenRect.Top
End Function

Public Property Get SingleSelect() As Boolean
    SingleSelect = mIsSingleSelect
End Property

Public Property Let SingleSelect(ByVal val As Boolean)
    mIsSingleSelect = val
End Property

Public Property Get SingleQuestionMode() As Boolean
    SingleQuestionMode = mSingleQuestionMode 'UBound(mQuestionIDs) > 0
End Property

Public Property Get BackWasSelected() As Boolean
    BackWasSelected = BackSelected
End Property

' Return if the answer for the specified question was checked
Public Function GetResult(ByVal questionIndex As Integer, ByVal answerIndex As Integer) As Boolean
    GetResult = False
    If questionIndex * 4 + answerIndex < mNumQuestions * 4 Then
        GetResult = CheckAnswer(questionIndex * 4 + answerIndex).OptionButtonEvents.value = True
    End If
End Function

' Returns which answer for the specified question was checked
' Returns -1 if none was checked!
Public Function GetResultIndex(ByVal questionIndex As Integer) As Integer
    GetResultIndex = -1
    Dim i As Integer
    i = questionIndex * 4
    Do While ((i <= UBound(CheckAnswer)) And (i < (questionIndex * 4 + 4)))
        If Not IsNull(CheckAnswer(i).OptionButtonEvents) Then
            If CheckAnswer(i).OptionButtonEvents.value = True Then
                GetResultIndex = i Mod 4
                Exit Function
            End If
        End If
        i = i + 1
    Loop
End Function

Public Function GetWert(questionIndex As Integer, answerIndex As Integer) As Double
    GetWert = 0
    If questionIndex * 4 + answerIndex <= UBound(mWerte) Then
        GetWert = mWerte(questionIndex * 4 + answerIndex)
    End If
End Function

Public Function ShowDialog(parent As UserForm) As Long ' VbMsgBoxResult
    Cancelled = False
    Me.Show vbModal
    ShowDialog = IIf(Cancelled, vbCancel, vbOK)
End Function

Private Function PixelsToTwips(Pixels As Integer)
    PixelsToTwips = Pixels '* Screen.TwipsPerPixelX
    
    'PixelsToTwips = Pixels / 1.33333333333333
End Function

Private Function TwipsToPixels(Twips As Integer)
    TwipsToPixels = Twips ' Twips / Screen.TwipsPerPixelX
    
    ' Die Funktion ist fehlerhaft laut einem Beitrag im MSDN Forum
    'TwipsToPixels = ActiveWindow.PointsToScreenPixelsX(Twips)
    ' Die gibt's nicht in Excel nur in Word
    'Application.PixelsToPoints(
    ' Twips per inch 1440
    
    ' Das ist selbst ausgerechnet
    'TwipsToPixels = Twips * 1.33333333333333
End Function

Public Function ConvertPixelsToTwips(lPixel As Long, Optional lDirection As Long = 0) As Long
#If VBA7 And Win64 Then
    Dim hdc As LongPtr
    Dim hwnd As LongPtr
#Else
    Dim hdc As Long
    Dim hwnd As Long
#End If
    Dim RetVal As Long
    Dim PIXELSPERINCH
    hdc = GetWindowDC(0)
    ' Horizontal
    If (lDirection = 0) Then
        PIXELSPERINCH = GetDeviceCaps(hdc, WU_LOGPIXELSX)
    ' Vertical
    Else
        PIXELSPERINCH = GetDeviceCaps(hdc, WU_LOGPIXELSY)
    End If
    RetVal = ReleaseDC(0, hdc)
    ConvertPixelsToTwips = (lPixel / PIXELSPERINCH) * TWIPSPERINCH
End Function
 
Function ConvertTwipsToPixels(lTwips As Long, Optional lDirection As Long = 0) As Long
#If VBA7 And Win64 Then
    Dim lDC As LongPtr
#Else
    Dim lDC As Long
#End If
    Dim lPixelsPerInch As Long
    lDC = GetWindowDC(0)
    ' Horizontal
    If (lDirection = 0) Then
        lPixelsPerInch = GetDeviceCaps(lDC, WU_LOGPIXELSX)
    ' Vertical
    Else
        lPixelsPerInch = GetDeviceCaps(lDC, WU_LOGPIXELSY)
    End If
    lDC = ReleaseDC(0, lDC)
    ConvertTwipsToPixels = (lTwips / TWIPSPERINCH) * lPixelsPerInch
End Function

Public Function IsArrayInitialized(arr) As Boolean
  Dim rv As Long
  On Error Resume Next
  rv = UBound(arr)
  IsArrayInitialized = (err.Number = 0)
End Function

' Init dialog as Checklist
Public Sub SetQuestionsCL(ByRef conn As Object, frageID As Long, title As String, _
                          ByRef questions() As String, _
                          ByRef hinweis() As String, _
                          ByRef answers() As String, ByRef werte() As Double, _
                          ByRef checklistIDs() As Long, ByRef checklistType() As Long, ByRef clPreSelection() As Boolean, _
                          Dateiname As String, answerIDs() As Long)
    mInQuestions = False
    Set mConn = conn
    mFrageID = frageID
    mTitle = title
    mQuestions = questions
    mHinweis = hinweis
    mAnswers = answers
    mWerte = werte
    mChecklistIDs = checklistIDs
    mChecklistType = checklistType

    mAnswerIDs = answerIDs
    Dim numQuestions As Long
    numQuestions = UBound(questions)
    ReDim mQuestionActiveAnswerID(numQuestions)
    
    ' Wenn wir als Checkliste aufgerufen werden, einfach die pre-selection uebernehmen
    mCLPreSelection = clPreSelection
    mDateiname = Dateiname
    mShowBack = False
    mSingleQuestionMode = False
    mShowCancel = False
    mNumDelaysAllowed = -1
    mDate = Now
End Sub

' Init dialog as question group
Public Sub SetQuestionsGroup(ByRef conn As Object, title As String, _
                             ByRef questions() As String, ByRef questionIDs() As Long, _
                             ByRef hinweis() As String, _
                             ByRef answers() As String, ByRef werte() As Double, _
                             ByRef checklistIDs() As Long, ByRef checklistType() As Long, Dateiname As String, _
                             showBack As Boolean, _
                             numDelaysAllowed As Long, answerIDs() As Long, _
                             ByVal fragendialogKommentar As String)
    mInQuestions = True
    Set mConn = conn
    mFrageID = -1
    mTitle = title
    mQuestions = questions
    mQuestionIDs() = questionIDs
    mHinweis = hinweis
    mAnswers = answers
    mAnswerIDs = answerIDs
    mWerte = werte
    mChecklistIDs = checklistIDs
    mChecklistType = checklistType
    mDateiname = Dateiname
    mShowBack = showBack
    mSingleQuestionMode = False
    mFragendialogKommentar = fragendialogKommentar
    
    ' Platz fuer die selektierten Checklistenantworten bereitstellen
    Dim numQuestions As Long
    numQuestions = UBound(questions)
    ReDim mCLSelection(numQuestions)
    ReDim mKommentartext(numQuestions)
    ReDim mQuestionActiveAnswerID(numQuestions)
    'mCLSelection = Empty
    Dim i As Long
    For i = 0 To numQuestions
        mCLSelection(i) = Array(False)
        mQuestionActiveAnswerID(i) = -1
    Next
    mShowCancel = IIf(numDelaysAllowed = 0, False, True)
    mNumDelaysAllowed = numDelaysAllowed
    mDate = Now
End Sub

' Init dialog for a single question
Public Sub SetSingleQuestion(ByRef conn As Object, title As String, _
                             ByRef questions() As String, ByRef questionIDs() As Long, _
                             ByRef hinweis() As String, _
                             ByRef answers() As String, ByRef werte() As Double, _
                             ByRef checklistIDs() As Long, ByRef checklistType() As Long, Dateiname As String, _
                             showBack As Boolean, numDelaysAllowed As Long, answerIDs() As Long, _
                             ByVal fragendialogKommentar As String)
    mInQuestions = True
    Set mConn = conn
    mFrageID = -1
    mTitle = title
    mQuestions = questions
    mQuestionIDs() = questionIDs
    mHinweis = hinweis
    mAnswers = answers
    mAnswerIDs = answerIDs
    mWerte = werte
    mChecklistIDs = checklistIDs
    mChecklistType = checklistType
    mDateiname = Dateiname
    mShowBack = showBack
    mSingleQuestionMode = True
    mFragendialogKommentar = fragendialogKommentar
    
    ' Platz fuer die selektierten Checklisten antworten bereitstellen
    Dim numQuestions As Long
    numQuestions = 1
    ReDim mCLSelection(numQuestions - 1)
    ReDim mKommentartext(numQuestions)
    ReDim mQuestionActiveAnswerID(numQuestions - 1)
    Dim sel() As Boolean
    Dim i As Long
    For i = 0 To numQuestions - 1
        mCLSelection(i) = Array(False)
        mQuestionActiveAnswerID(i) = -1
    Next
    mShowCancel = IIf(numDelaysAllowed = 0, False, True)
    mNumDelaysAllowed = numDelaysAllowed
    mDate = Now
End Sub

Private Sub ShowChecklist(idx As Integer)
    If UBound(mChecklistIDs) >= idx And UBound(mQuestionIDs) >= idx And UBound(mCLSelection) >= idx Then
        ' Get the checklist for this question
        Dim CLZuweisungsID As Long
        Dim frageID As Long
        CLZuweisungsID = mChecklistIDs(idx)
        frageID = mQuestionIDs(idx)
        
        Dim i As Integer
        Dim theValue As Double
        Dim sel() As Boolean
        ReDim sel(UBound(mCLSelection(idx)))
        For i = 0 To UBound(mCLSelection(idx))
            sel(i) = mCLSelection(idx)(i)
        Next
        theValue = DoChecklistModal(frageID, CLZuweisungsID, mConn, mDateiname, sel)
        mCLSelection(idx) = sel
        
        ' Find proper answer to check based on theValue
        ' Rule: Select the one with wert closest to theValue
        Dim delta As Double
        Dim closestAnswer As Integer
        closestAnswer = -1
        delta = 10000000000#
        For i = 0 To 3
            If Len(mAnswers(idx * 4 + i)) > 0 Then
                If Abs(theValue - mWerte(idx * 4 + i)) < delta Then
                    delta = Abs(theValue - mWerte(idx * 4 + i))
                    closestAnswer = i
                End If
            End If
        Next
        If closestAnswer >= 0 Then
            CheckAnswer(idx * 4 + closestAnswer).OptionButtonEvents.value = True
        End If
    End If
End Sub

Private Sub BtChecklist_Click(index As Integer)
    ShowChecklist index
End Sub

Private Sub BtHinweis_Click(index As Integer)
    ' Display hint text
    If UBound(mHinweis) >= index Then
        If Len(mHinweis(index)) > 0 Then
            frmHinweise.Hinweistext = mHinweis(index)
            frmHinweise.Caption = ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")" & " - Hinweis"
            frmHinweise.Show vbModal
        End If
    End If
End Sub

Public Sub Initialize()
    ' ZOrder 0

    m_InInit = True
    mTwoColumnAnswers = False
    
    Cancelled = True
    Dim numQuestions As Integer, numAnswers As Integer
    numQuestions = UBound(mQuestions) + 1
    numAnswers = UBound(mAnswers) + 1
    
    ' Verify input
    ' Debug.Assert (numAnswers = numQuestions * 4)
    
    Dim i As Integer
    For i = 0 To numQuestions - 1
        If IsNull(mQuestions(i)) Then
            mQuestions(i) = ""
        End If
    Next
    For i = 0 To numAnswers - 1
        If IsNull(mAnswers(i)) Then
            mAnswers(i) = ""
        End If
    Next
    
    Dim logoPath As String
    
    logoPath = G_Firmenlogo
    If FileExists(logoPath) Then
        Logo.Picture = LoadPicture(logoPath)
        If G_CfgLogoFarbe >= 0 Then
          LogoColor.BackColor = G_CfgLogoFarbe
          Logo.BackColor = G_CfgLogoFarbe
          LogoColor.Height = Logo.Height
        Else
          LogoColor.visible = False
        End If
    End If
    

    CancelButton.visible = mShowCancel
    ' Ok button starts out disabled
'    OkButton.Enabled = False
    ' TODO BtBack.Visible = False

    ' Set MainFrame = New MyFrame
    ' Set MainFrame.FrameEvents = Controls.Add("Forms.Frame.1")
    ' MoveCtl MainFrame.FrameEvents, PictureScroll, 0, 0
    ' PictureScroll.Visible = False
    
    ' Create all controls
    ReDim TbQuestion(numQuestions - 1)
    ReDim TbComment(numQuestions - 1)
    ReDim BtChecklist(numQuestions - 1)
    ReDim BtHinweis(numQuestions - 1)
    ReDim Frame(numQuestions - 1)
    ReDim CheckAnswer(numQuestions * 4 - 1)
    mNumQuestions = numQuestions
    
    Dim j As Integer
    For i = 0 To numQuestions - 1
        Set Frame(i) = New MyFrame
        Set Frame(i).FrameEvents = MainFrame.add("Forms.Frame.1", "Frame" & i, True)
        
        Set TbQuestion(i) = New MyTextBox
        Set TbQuestion(i).TextBoxEvents = Frame(i).FrameEvents.Controls.add("Forms.Textbox.1", "TbQuestion" & i, True)
        TbQuestion(i).TextBoxEvents.WordWrap = True
        TbQuestion(i).TextBoxEvents.MultiLine = True
        
        Set TbComment(i) = New MyTextBox
        Set TbComment(i).TextBoxEvents = Frame(i).FrameEvents.Controls.add("Forms.Textbox.1", "TbComment" & i, True)
        TbComment(i).Init Me, i
        TbComment(i).TextBoxEvents.WordWrap = True
        TbComment(i).TextBoxEvents.MultiLine = True
        TbComment(i).TextBoxEvents.Text = FMT0("QUESTIONS_10")
        TbComment(i).TextBoxEvents.Locked = True
        
        Set BtChecklist(i) = New MyCommandButton
        Set BtChecklist(i).CommandButtonEvents = Frame(i).FrameEvents.Controls.add("forms.commandbutton.1", "BtChecklist" & i, True)
        BtChecklist(i).CommandButtonEvents.Caption = ""
        BtChecklist(i).Init Me, i
        BtChecklist(i).CommandButtonEvents.Picture = CommandButtonCheckboxBitmap.Picture
        MoveCtlSize BtChecklist(i).CommandButtonEvents, Frame(i).FrameEvents, 0, 0, 24, 24
        ' wird nicht unters|fffd|tzt
        ' Set c.parent = PictureScroll
        
        Set BtHinweis(i) = New MyCommandButton
        Set BtHinweis(i).CommandButtonEvents = Frame(i).FrameEvents.Controls.add("forms.commandbutton.1", "BtHinweis" & i, True)
        BtHinweis(i).CommandButtonEvents.Caption = ""
        BtHinweis(i).Init Me, i
        BtHinweis(i).CommandButtonEvents.Picture = CommandButtonQuestionMark.Picture
        MoveCtlSize BtHinweis(i).CommandButtonEvents, Frame(i).FrameEvents, 0, 0, 24, 24
    
        BtChecklist(i).CommandButtonEvents.visible = False
        BtHinweis(i).CommandButtonEvents.visible = False
        
        ' Create 4 answer controls per question
        For j = 0 To 3
            ' Load CheckAnswer(i * 4 + j)
            Set CheckAnswer(i * 4 + j) = New MyOptionButton
            Set CheckAnswer(i * 4 + j).OptionButtonEvents = Frame(i).FrameEvents.Controls.add("forms.optionbutton.1", "OpBut" & i, True)
            CheckAnswer(i * 4 + j).Init Me, i * 4 + j
            ' The radio buttons must be child of the frame controls for the selection to work properly.
            'Set CheckAnswer(i * 4 + j).OptionButtonEvents.Container = Frame(i)
skip:
        Next
    Next
    For i = 0 To numQuestions * 4 - 1
        If IsArrayInitialized(mCLPreSelection) Then
            If UBound(mCLPreSelection) >= i Then
                ' Antwort vorselektieren. Falls diese Checkliste vorher schon einmal aufgerfuen wurde,
                ' sind die selektierten Antworten aus dem letzten Aufruf in mCLPreSelection gespeichert.
                CheckAnswer(i).OptionButtonEvents.value = mCLPreSelection(i)
            End If
        End If
    Next
    
    Me.Caption = mTitle
    

    ' Set the text color to the dialog background color. That way we can do the
    ' DrawText measurement right in the picturebox' HDC
    ' tODO PictureScroll.ForeColor = vb3DFace 'vbButtonFace
    
    ' CheckBox dimensions
    ' http://stackoverflow.com/questions/1164868/how-to-get-size-of-check-and-gap-in-check-box
    ' https://msdn.microsoft.com/en-us/library/windows/desktop/ms724385(v=vs.85).aspx
    'int WID = 13 * dc.GetDeviceCaps(LOGPIXELSX) / 96;
    'int HEI = 13 * dc.GetDeviceCaps(LOGPIXELSY) / 96;
    CheckBoxWidth = 27
    CheckBoxHeight = 30
    
    ' Do one initial layout to determine how much vertical space we need
    Dim screenHeight As Long
    Dim nonClientHeight As Integer
    ' TODO
    nonClientHeight = Me.Height - Me.InsideHeight + 2 ' 25 ' TwipsToPixels(Me.Height - Me.ScaleHeight)
    screenHeight = DesktopHeight() - (nonClientHeight + 5)
    'screenHeight = GetDeviceCaps(Me.hDC, VERTRES) * 0.75
    mTop = 0
    'Me.height = PixelsToTwips(GetMin(FrameTotal.Top + MainFrame.Top + DoLayout + nonClientHeight + 5, screenHeight * 3 / 4))
    Dim hl As Long
    hl = DoLayout()
    Me.Height = PXtoPT(GetMin(PTtoPX(FrameTotal.Top + MainFrame.Top) + hl, screenHeight * 3 / 4))
    Form_Resize
    
    subRemoveCloseButton Me
    
    Call DoVorauswahl
    m_InInit = False
End Sub

Private Sub DoVorauswahl()
    If mInQuestions = False Or G_Befragung Is Nothing Then Exit Sub
    ' Die Antworten vorselektieren
    
    Dim numQuestions As Integer
    numQuestions = UBound(mQuestions) + 1
    Dim i, j As Long
    For i = 0 To numQuestions - 1
        Dim vorauswahlAntwortId As Long
        vorauswahlAntwortId = G_Befragung.GetVorauswahlAntwortID(mQuestionIDs(i))
        If vorauswahlAntwortId > 0 Then
            For j = 0 To 3
                If mAnswerIDs(i * 4 + j) = vorauswahlAntwortId Then
                    CheckAnswer(i * 4 + j).OptionButtonEvents.BackColor = &HFFF68F
                End If
            Next j
        End If
    Next i
End Sub

Function GetWidth(ByVal c As control) As Long
    GetWidth = c.width
End Function

Sub MoveCtl(ByRef c As control, ByRef p As control, ByVal x As Long, ByVal y As Long)
    c.Left = x
    c.Top = y
End Sub

Sub MoveCtlSize(ByRef c As control, ByRef p As control, ByVal x As Long, ByVal y As Long, ByVal w As Long, ByVal h As Long)
'    c.Left = x / 1.333
'    c.Top = y / 1.333
'    c.width = GetMax(w / 1.333, 1)
'    c.height = GetMax(h / 1.333, 1)
    c.Left = x
    c.Top = y
    c.width = GetMax(w, 1)
    c.Height = GetMax(h, 1)
End Sub

Private Function CalcText(ByVal txt As String, ByVal width As Long) As Long
    ' DrawText will Logical Coordinates keine Physikalischen
    Dim myRect As RECT
    myRect.Left = 0
    myRect.Right = width
    myRect.Top = 0
    myRect.Bottom = 20000
        
    Dim drawTextFormat As Long
    drawTextFormat = DT_LEFT Or DT_TOP Or DT_NOPREFIX Or DT_WORDBREAK Or DT_EDITCONTROL Or DT_CALCRECT
    
    CalcText = DrawText(GetHDC(FrameTotal), txt, Len(txt), myRect, drawTextFormat)
End Function

Function GetTextHeightInPT(ByVal txt As String, ByVal widthInPT As Long, ByVal minheightInPT As Long) As Long
    Dim drawTextFormat As Long
    drawTextFormat = DT_LEFT Or DT_TOP Or DT_NOPREFIX Or DT_WORDBREAK Or DT_EDITCONTROL Or DT_CALCRECT
    
    Dim myRect As RECT
    myRect.Left = 0
    myRect.Right = widthInPT - 10
    myRect.Top = 0
    myRect.Bottom = 20000
    Dim h As Long
    h = DrawText(GetHDC(FrameTotal), txt, Len(txt), myRect, drawTextFormat)
    h = PXtoPT(h) * 11 / 10
    If h < minheightInPT Then h = minheightInPT
    
    GetTextHeightInPT = h
End Function


Function DoLayout() As Integer
    Dim numQuestions As Integer
    numQuestions = UBound(mQuestions) + 1
    
    Dim pictureScrollBorders As Integer
    pictureScrollBorders = 10
    
    Dim formWidth As Integer
    Dim myFormWidth As Integer
    Dim questionWidth As Integer
    Dim answerWidth As Integer
    'Dim numActiveQuestions As Integer
    Dim totalHeight As Long
    Dim hoeheDateiname As Long
    Dim hoeheKommentar As Long
    Dim hoeheKommentarOffset As Long
    
    'Dim drawTextFormat As Long
    'drawTextFormat = DT_LEFT Or DT_TOP Or DT_NOPREFIX Or DT_WORDBREAK Or DT_EDITCONTROL Or DT_CALCRECT
    
    ' 20 pixels for gaps between control, another 20 for the vertical scroll bar
    formWidth = PTtoPX(Me.width) - pictureScrollBorders - 20 - 20 + LEFT_OFFSET
    
    questionWidth = (formWidth / 1.5) - (2 * CheckBoxWidth)
    Dim answerAreaWidth As Integer
    answerAreaWidth = (formWidth - (formWidth / 1.5)) - CheckBoxWidth - PTtoPX(GetWidth(BtChecklist(0).CommandButtonEvents)) - 10
    
    Dim answerX As Integer
    
    Dim y As Integer
    y = 5
    
    ' Erstmal das Logo platzieren
    Dim logoWidth As Integer
    Dim logoHeight As Integer
    logoWidth = PTtoPX(Logo.width)
    logoHeight = PTtoPX(Logo.Height)
    LogoColor.Move PXtoPT(LEFT_OFFSET), PXtoPT(y), PXtoPT(formWidth - logoWidth - pictureScrollBorders), PXtoPT(logoHeight)
    Logo.Move PXtoPT(LEFT_OFFSET) + LogoColor.width, PXtoPT(y)
    
    ' Dateiname f|fffd|ngt im Frame wieder ganz oben an
    y = 5
    myFormWidth = PXtoPT(formWidth)
    
    ' Dateiname anzeigen, falls wir einen haben
    If mDateiname <> vbNullString Then
        LbDatei.Move LbDatei.Left, PixelsToTwips(y)
        LbDateiname.Move LbDateiname.Left, PXtoPT(y), myFormWidth - VScroll1.width - LbDateiname.Left
        
        LbDateiname.Caption = mDateiname
        LbDatei.visible = True
        LbDateiname.visible = True
        hoeheDateiname = PTtoPX(LbDateiname.Height)
    Else
        LbDatei.visible = False
        LbDateiname.visible = False
        hoeheDateiname = 0
    End If
    
    ' Kommentarfeld
    If mFragendialogKommentar <> "" Then
        lbKommentar.Move lbKommentar.Left, PXtoPT(y + hoeheDateiname), myFormWidth - VScroll1.width - lbKommentar.Left, _
          GetTextHeightInPT(mFragendialogKommentar, PTtoPX(width - VScroll1.width - lbKommentar.Left), PTtoPX(24))
        
        lbKommentar.Caption = mFragendialogKommentar
        lbKommentar.visible = True
        hoeheKommentar = PTtoPX(lbKommentar.Height)
        hoeheKommentarOffset = 10
    Else
        lbKommentar.visible = False
        hoeheKommentar = 0
        hoeheKommentarOffset = 0
    End If
  
    
    ' die Frames fangen dann in ihrem Subframe auch wieder ganz oben an
    ' mTop gibt an, wie die Scrollbar sich auswirkt
    y = PTtoPX(mTop)
    Dim i As Long
    For i = 0 To numQuestions - 1
        ' skip if there is no question
        If Len(mQuestions(i)) < 1 Then
            TbQuestion(i).TextBoxEvents.visible = False
            TbComment(i).TextBoxEvents.visible = False
            Frame(i).FrameEvents.visible = False
            GoTo skip
        End If
        
        ' How many answers do we have?
        Dim answersUsed(0 To 3) As Integer
        Dim numAnswers As Integer
        numAnswers = 0
        Dim j As Integer
        For j = 0 To 3
            If Len(mAnswers(i * 4 + j)) > 0 Then
                answersUsed(numAnswers) = j
                numAnswers = numAnswers + 1
            Else
                CheckAnswer(i * 4 + j).OptionButtonEvents.visible = False
            End If
        Next
        ' Skip if there are no answers to this question
        If numAnswers < 1 Then
            TbQuestion(i).TextBoxEvents.visible = False
            TbComment(i).TextBoxEvents.visible = False
            Frame(i).FrameEvents.visible = False
            CheckAnswer(i * 4 + 0).OptionButtonEvents.visible = False
            CheckAnswer(i * 4 + 1).OptionButtonEvents.visible = False
            CheckAnswer(i * 4 + 2).OptionButtonEvents.visible = False
            CheckAnswer(i * 4 + 3).OptionButtonEvents.visible = False
            GoTo skip
        End If
        answerWidth = IIf(numAnswers > 1, answerAreaWidth / 2, answerAreaWidth)
        
        TbQuestion(i).TextBoxEvents.visible = True
    
        ' Measure Question Height
        Dim questionHeight As Long
        Dim myRect As RECT
        myRect.Left = 0
        myRect.Right = questionWidth - 16
        myRect.Top = 0
        myRect.Bottom = 20000
        ' 16 Pixel f|fffd|r den Rand des Controls abziehen (scheint zu passen, habe ich allerdings nur auf einem Screenshot nachgemessen)
        questionHeight = CalcText(mQuestions(i), questionWidth) + 16
        
        answerX = 5 + questionWidth + 5
        
        Dim buttonX As Integer
        Dim buttonY As Integer
        buttonX = answerX + 6
        'buttonY = y
        buttonY = 2
        ' Enable the Hint button, if we have a Hinweis string
        BtHinweis(i).CommandButtonEvents.visible = IIf(Len(mHinweis(i)) > 0, True, False)
        MoveCtl BtHinweis(i).CommandButtonEvents, Frame(i).FrameEvents, PXtoPT(buttonX), PXtoPT(buttonY + 5)
        BtHinweis(i).CommandButtonEvents.PicturePosition = fmPicturePositionCenter
        
        buttonY = buttonY + PTtoPX(BtHinweis(i).CommandButtonEvents.Height + 2)
        
        ' Enable Checklist button if we have any assigned to this question
        BtChecklist(i).CommandButtonEvents.visible = False
        BtChecklist(i).CommandButtonEvents.PicturePosition = fmPicturePositionCenter
        
        If IsArrayInitialized(mChecklistIDs) And IsArrayInitialized(mChecklistType) Then
            If i <= UBound(mChecklistIDs) And i <= UBound(mChecklistType) Then
                If mChecklistIDs(i) > 0 And mChecklistType(i) > Checkliste_NichtAnwenden Then
                    BtChecklist(i).CommandButtonEvents.visible = True
                    BtChecklist(i).CommandButtonEvents.Enabled = True
                    'MoveCtl BtChecklist(i).CommandButtonEvents, Frame(i).FrameEvents, PixelsToTwips(buttonX), PixelsToTwips(buttonY + 5)
                    MoveCtl BtChecklist(i).CommandButtonEvents, Frame(i).FrameEvents, PXtoPT(buttonX), PXtoPT(buttonY + 5)
                    ' Bei Muss-Checkliste die Radiobuttons disablen
                    If mChecklistType(i) = Checkliste_Muss Then
                        For j = 0 To 3
                            CheckAnswer(i * 4 + j).OptionButtonEvents.Enabled = False
                        Next
                    End If
                End If
            End If
        End If
        
        answerX = answerX + PTtoPX(GetWidth(BtChecklist(0).CommandButtonEvents)) + 10
        
        ' Measure answer heights
        Dim answerHeight(0 To 3) As Long
        Dim idx As Integer
        myRect.Right = answerWidth ' - CheckBoxWidth
        For j = 0 To numAnswers - 1
            idx = answersUsed(j)
            answerHeight(j) = CalcText(mAnswers(i * 4 + idx), myRect.Right)
            answerHeight(j) = GetMax(answerHeight(j), CheckBoxHeight)
        Next
        ' Store height of each answer pair
        Dim answerPairHeight(0 To 1) As Long
        answerPairHeight(0) = GetMax(answerHeight(0), answerHeight(1))
        answerPairHeight(1) = GetMax(answerHeight(2), answerHeight(3))
        
        ' Place answer checkboxes
        ' 1. if we have only one answer -> height is the height of that one answer
        ' 2. if we have two answers -> height is the larger one of the two
        ' 3. if we have more than two answers -> height is #2 + the larger one of the next two answers
        Dim Height As Integer
        For j = 0 To numAnswers - 1
            Dim x As Integer
            Dim answerY As Integer
            idx = answersUsed(j)
            x = IIf((j Mod 2) = 0, answerX, answerX + CheckBoxWidth + answerWidth)
            'answerY = IIf(j < 2, Y, Y + 5 + answerPairHeight(0))
            answerY = IIf(j < 2, 5, 5 + 5 + answerPairHeight(0))
            Height = IIf(j < 2, answerPairHeight(0), answerPairHeight(1))
            MoveCtlSize CheckAnswer(i * 4 + idx).OptionButtonEvents, Frame(i).FrameEvents, PXtoPT(x), PXtoPT(answerY), PXtoPT(answerWidth + CheckBoxWidth), PXtoPT(Height)
            CheckAnswer(i * 4 + idx).OptionButtonEvents.Caption = mAnswers(i * 4 + idx)
            CheckAnswer(i * 4 + idx).OptionButtonEvents.visible = True
        Next
        
       
        ' Place question textbox
        ' Height is either the question height or the combined height of the answer area
        Height = GetMax(GetMax(answerPairHeight(0) + answerPairHeight(1) + 5, questionHeight), 2 * CheckBoxHeight)
        TbQuestion(i).TextBoxEvents.Text = mQuestions(i)
        TbQuestion(i).TextBoxEvents.SelStart = 0
        TbQuestion(i).TextBoxEvents.SelLength = 0
        MoveCtlSize TbQuestion(i).TextBoxEvents, Frame(i).FrameEvents, PXtoPT(LEFT_OFFSET), PXtoPT(5), PXtoPT(questionWidth), PXtoPT(Height)
        TbQuestion(i).TextBoxEvents.Locked = True
        
        Dim frameWidth As Long
        frameWidth = myFormWidth - VScroll1.width - PXtoPT(0)

        TbComment(i).TextBoxEvents.visible = False
        If mInQuestions And QuestionRequiresComment(i) Then
            mKommentartext(i) = G_Befragung.GetCommentText(mQuestionIDs(i))
            
            TbComment(i).TextBoxEvents.visible = True
            MoveCtlSize TbComment(i).TextBoxEvents, Frame(i).FrameEvents, PXtoPT(LEFT_OFFSET), PXtoPT(Height + 10), frameWidth - PXtoPT(3 + LEFT_OFFSET * 2), PXtoPT(54)
            
            Height = Height + 54 + 10
        End If
                
        ' To accomodate the frame
        Height = Height + 16
        
        MoveCtlSize Frame(i).FrameEvents, Frame(i).FrameEvents, PXtoPT(0), PXtoPT(y), frameWidth, PXtoPT(Height)
        Frame(i).FrameEvents.visible = True

        y = y + Height + 4
skip:
    Next i
    
    ' das ist der Bereich zum scrollen
    MoveCtlSize MainFrame, MainFrame, MainFrame.Left, PXtoPT(hoeheDateiname + hoeheKommentar + hoeheKommentarOffset), myFormWidth - VScroll1.width - PXtoPT(6), PXtoPT(y + 2)
    y = y + 20
    
    ' Add ok and cancel buttons
    If CancelButton.visible = True Then
        CancelButton.Move MainFrame.Left + MainFrame.width - CancelButton.width - PXtoPT(10), PXtoPT(y + hoeheDateiname + hoeheKommentar + hoeheKommentarOffset)
        OkButton.Move CancelButton.Left - PXtoPT(20) - OkButton.width, PXtoPT(y + hoeheDateiname + hoeheKommentar + hoeheKommentarOffset)
    Else
        OkButton.Move MainFrame.Left + MainFrame.width - OkButton.width - PXtoPT(10), PXtoPT(y + hoeheDateiname + hoeheKommentar + hoeheKommentarOffset)
    End If
    BtBack.Move PXtoPT(LEFT_OFFSET - 3), PXtoPT(y + hoeheDateiname + hoeheKommentar + hoeheKommentarOffset)
    BtBack.visible = mShowBack
    
    LabelVerschiebungen.Caption = GetVerschiebungenText
    
    Dim labelx As Long
    If mShowBack Then
        labelx = BtBack.Left + BtBack.width + 20
    Else
        labelx = BtBack.Left
    End If
    LabelVerschiebungen.Move labelx, PXtoPT(y + hoeheDateiname + hoeheKommentar + hoeheKommentarOffset)
    ' Das Label fuer die Anzahl der moeglichen Verschiebungen nicht anzeigen, wenn das eine freiwillige Befragung (mNumDelaysAllowed = -1) ist oder die Befragung
    ' nicht mehr verschoben werden kann (mNumDelaysAllowed = 0). Bei (mNumDelaysAllowed = -2) kann unendlich oft verschoben werden, da wird das Label angezeigt.
    If mNumDelaysAllowed = 0 Or mNumDelaysAllowed = -1 Or LabelVerschiebungen.Caption = "" Then
        LabelVerschiebungen.visible = False
    End If
    
    ' No Ok in Single Question Mode.
    If SingleQuestionMode And Not HasAnswerWithComments() Then
        OkButton.visible = False
    End If
    
    
    y = y + PTtoPX(OkButton.Height) + 12
    MoveCtlSize FrameTotal, FrameTotal, PXtoPT(LEFT_OFFSET), Logo.Top + PXtoPT(logoHeight + 5), LogoColor.width + Logo.width, Me.InsideHeight - PXtoPT(logoHeight + 15)
    
    DoLayout = y + hoeheDateiname + hoeheKommentar + hoeheKommentarOffset
End Function

Private Function QuestionRequiresComment(idx As Long) As Boolean
    If Not G_Befragung Is Nothing And mInQuestions = True Then
        Dim i As Long
        For i = 0 To 3
            If G_Befragung.GetCommentTypeForAnswer(mAnswerIDs(idx * 4 + i)) > 0 Then
                QuestionRequiresComment = True
                Exit Function
            End If
        Next i
    End If
End Function

Private Function CanContinue() As Boolean
    ' True, wenn es:
    ' 1: Keine Kommentare gibt - oder bei Kommentaren mit Muss-Schutzbedarf-Reduziert-Kommentar der Schutzbedarf nicht reduziert ist
    ' 2: Es gibt Kommentare und es wurden genug Zeichen eingegeben bei Muss-Kommentaren
    CanContinue = True
    If Not G_Befragung Is Nothing And mInQuestions = True Then
        Dim numQuestions As Integer
        numQuestions = UBound(mQuestions) + 1
        Dim i As Long
        For i = 0 To numQuestions - 1
            Dim answerIdx As Long
            answerIdx = GetResultIndex(i)
            If answerIdx < 0 Then
                ' Noch gar nix selektiert - raus mit False
                CanContinue = False
                Exit Function
            End If
            Dim answerID As Long
            answerID = mAnswerIDs(i * 4 + answerIdx)
            Dim commentType As Long
            commentType = G_Befragung.GetCommentTypeForAnswer(answerID)
            
            If commentType = MUSS_KOMMENTAR Or _
                (G_Befragung.SchutzbedarfGeaendertMitAntwort(answerID) = True And commentType = MUSS_KOMMENTAR_SCHUTZB_REDUZIERT) Then
                
                If Len(TbComment(i).TextBoxEvents.Text) < KOMMENTAR_MIN_ZEICHEN Or TbComment(i).TextBoxEvents.Text = FMT0("QUESTIONS_10") Then
                    CanContinue = False
                    Exit Function
                End If
            End If
        Next i
    End If
End Function

Private Function CanAutoContinue() As Boolean
    ' True: Wenn es automatisch zur naechsten Frage weitergehen kann, nachdem alle Antworten selektiert wurden.
    ' False: Falls es bei einigen selektierten Antworten Kann/Muss-Kommentare gibt
    CanAutoContinue = SingleQuestionMode
    If Not G_Befragung Is Nothing And mInQuestions = True Then
        Dim numQuestions As Integer
        numQuestions = UBound(mQuestions) + 1
        Dim i As Long
        For i = 0 To numQuestions - 1
            Dim answerIdx As Long
            answerIdx = GetResultIndex(i)
            If answerIdx < 0 Then
                ' Noch gar nix selektiert - raus mit False
                CanAutoContinue = False
                Exit Function
            End If
            Dim answerID As Long
            answerID = mAnswerIDs(i * 4 + answerIdx)
            Dim commentType As Long
            commentType = G_Befragung.GetCommentTypeForAnswer(answerID)
            If G_Befragung.GetCommentTypeForAnswer(answerID) > 0 Then
                CanAutoContinue = False
                Exit Function
            End If
        Next i
    End If
End Function

Private Function HasAnswerWithComments() As Boolean
    If Not G_Befragung Is Nothing And mInQuestions Then
        Dim i As Long
        For i = 0 To UBound(mAnswerIDs)
            If G_Befragung.GetCommentTypeForAnswer(mAnswerIDs(i)) > 0 Then
                HasAnswerWithComments = True
                Exit Function
            End If
        Next i
    End If
End Function

Function GetVerschiebungenText() As String
    ' Das ist ungueltig, damit wuerde im Text -1 Tage stehen
    If G_PARAM_VerschiebungsdauerInTagen < 0 Then Exit Function
    
    If mNumDelaysAllowed = -2 Then
        GetVerschiebungenText = "" ' Anzahl der Verschiebungen wird bei -2 nicht angezeigt
    ElseIf mNumDelaysAllowed = 1 Then
        'GetVerschiebungenText = "Noch eine Verschiebung m|fffd|glich." & " "
        GetVerschiebungenText = FMT0("QUESTIONS_7") & " "
    Else
        'GetVerschiebungenText = "Noch " & mNumDelaysAllowed & " Verschiebungen m|fffd|glich." & " "
        GetVerschiebungenText = FMT1("QUESTIONS_8", mNumDelaysAllowed) & " "
    End If
    'GetVerschiebungenText = GetVerschiebungenText & "Bei Abbruch wird die Befragung um " & G_PARAM_VerschiebungsdauerInTagen & " Tag(e) verschoben (" & _
    '    DateSerial(year(mDate), month(mDate), day(mDate) + G_PARAM_VerschiebungsdauerInTagen) & ")."
    GetVerschiebungenText = GetVerschiebungenText & FMT2("QUESTIONS_9", G_PARAM_VerschiebungsdauerInTagen, DateSerial(year(mDate), month(mDate), day(mDate) + G_PARAM_VerschiebungsdauerInTagen))
End Function

Sub Form_Resize()

    ' Limit form min size (using the cheap VB way)
    ' This is the way to do this properly (using window subclassing):
    ' https://support.microsoft.com/en-us/kb/185733
    If Me.width < PXtoPT(600) Then
        Me.width = PXtoPT(600)
    End If
    If Me.Height < PXtoPT(200) Then
        Me.Height = PXtoPT(200)
    End If
    
    Dim hl As Long
    hl = DoLayout
    
    HScroll1.visible = False
    HScroll1.Left = 0
    VScroll1.Top = 0
    HScroll1.Top = InsideHeight
    ' FrameTotal.Height
    If FrameTotal.Top + PXtoPT(hl) > HScroll1.Top + 2 Then
       VScroll1.Left = Me.InsideWidth - VScroll1.width
       VScroll1.Enabled = True
    Else
       VScroll1.Left = width
    End If
    VScroll1.Height = InsideHeight
    ' Set the scroll bar ranges
    VScroll1.min = 0
    ' FrameTotal.Top + hl - HScroll1.Top + 16
    Dim maxScroll As Long
    maxScroll = PXtoPT(hl) - FrameTotal.Height
    
    VScroll1.max = GetMax(0, maxScroll)
    VScroll1.SmallChange = Abs(VScroll1.max \ 16) + 1
    VScroll1.LargeChange = VScroll1.SmallChange * 8 ' MainFrame.Height - VScroll1.Max 'Abs(VScroll1.Max \ 4) + 1
    HScroll1.ZOrder 0
    VScroll1.ZOrder 0
End Sub

Sub HScroll1_Change()
   MainFrame.Left = -HScroll1.value
End Sub

Sub VScroll1_Change()
    mTop = -VScroll1.value
    DoLayout
End Sub

Public Sub Click(ByVal ctrl As Object, ByVal index As Integer)

    If ctrl.name Like "BtHinweis*" Then
        If UBound(mHinweis) >= index Then
            If Len(mHinweis(index)) > 0 Then
                frmHinweise.Hinweistext = mHinweis(index)
                frmHinweise.Caption = ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")" & " - Hinweis"
                frmHinweise.Show vbModal
            End If
        End If
    ElseIf ctrl.name Like "BtChecklist*" Then
        ShowChecklist index
    End If

End Sub

Public Sub TextBox_Change(index As Integer)
    If m_InInit Then Exit Sub
    Dim answerIdx As Long
    answerIdx = GetResultIndex(index)
    If answerIdx < 0 Then Exit Sub
    Call CheckAnswer_Click(index * 4 + answerIdx)
End Sub

Public Sub ClickOption(ByVal ctrl As Object, ByVal index As Integer)
    Dim questionIndex As Integer
    questionIndex = index \ 4
    
    If TypeOf ctrl Is MSForms.OptionButton Then
        Dim i As Integer
        Dim idx As Integer
        
        If SingleSelect Then
            If CheckAnswer(index).OptionButtonEvents.value = 1 Then
                ' De-select all others in this group
                For i = 0 To 3
                    idx = questionIndex * 4 + i
                    If idx <> index Then
                        CheckAnswer(idx).OptionButtonEvents.value = 0
                    End If
                Next
            End If
        End If
    End If
    CheckAnswers questionIndex, index Mod 4
End Sub

Private Sub CheckAnswer_Click(index As Integer)
    Dim i As Integer
    Dim idx As Integer
    
    Dim questionIndex As Integer
    questionIndex = index \ 4
    
    If SingleSelect Then
        If CheckAnswer(index).OptionButtonEvents.value = 1 Then
            ' De-select all others in this group
            For i = 0 To 3
                idx = questionIndex * 4 + i
                If idx <> index Then
                    CheckAnswer(idx).OptionButtonEvents.value = 0
                End If
            Next
        End If
    End If
    
    
    CheckAnswers questionIndex, index Mod 4
End Sub
    
    
Private Function GetSelectedAnswerAmount() As Integer
    Dim nSelected As Integer
    nSelected = 0
    Dim q As Long
    q = 0
    Dim i As Long
    Dim idx As Long
    
    For q = 0 To mNumQuestions - 1
        Dim checked As Boolean
        checked = False
        For i = 0 To 3
            idx = q * 4 + i
            If CheckAnswer(idx).OptionButtonEvents.value = True Then
                checked = True
                Exit For
            End If
        Next
        If checked Then
            nSelected = nSelected + 1
        End If
    Next
    GetSelectedAnswerAmount = nSelected
End Function

    
Private Sub CheckAnswers(questionIndex As Integer, index As Integer)
    Dim answerForQuestionChanged As Boolean
    Dim answerID As Long
    Dim oldAnswerID As Long
    answerID = mAnswerIDs(questionIndex * 4 + index)
    oldAnswerID = mQuestionActiveAnswerID(questionIndex)
    If answerID <> oldAnswerID Then
        answerForQuestionChanged = True
        mQuestionActiveAnswerID(questionIndex) = answerID
    End If
    
    Dim autoContinue As Boolean
    autoContinue = CanAutoContinue()
    

    ' Check if we have a selected answer for all questions
    Dim nSelected As Integer
    nSelected = GetSelectedAnswerAmount
    
    If mInQuestions And Not G_Befragung Is Nothing And TbComment(questionIndex).TextBoxEvents.visible = True And answerForQuestionChanged Then
        If answerID > 0 Then
            
            If oldAnswerID > 0 And TbComment(questionIndex).TextBoxEvents.Text <> FMT0("QUESTIONS_10") Then
                mKommentartext(questionIndex) = TbComment(questionIndex).TextBoxEvents.Text
            End If
            Dim commentType As Long
            commentType = G_Befragung.GetCommentTypeForAnswer(answerID)
            ' TbComment enablen/disablen, falls fuer diese Antwort ein Kommentar eingegeben werden kann
            If commentType > 0 Then
                ' Dann auch den zwischengespeicherten Kommentartext wieder zuweisen
                Dim enableTextbox As Boolean
                autoContinue = False
                Dim isMussKommentar As Boolean
                If commentType = MUSS_KOMMENTAR Then
                    enableTextbox = True
                    isMussKommentar = True
                ElseIf commentType = MUSS_KOMMENTAR_SCHUTZB_REDUZIERT Then
                    If G_Befragung.SchutzbedarfGeaendertMitAntwort(answerID) = True Then
                        enableTextbox = True
                        isMussKommentar = True
                    Else
                        ' So behandeln wie "Kein Kommentar"
                        TbComment(questionIndex).TextBoxEvents.Text = FMT0("QUESTIONS_10") ' Defaulttext wieder anzeigen
                        TbComment(questionIndex).TextBoxEvents.Locked = True
                        TbComment(questionIndex).TextBoxEvents.BackColor = &H80000005
                    End If
                Else
                    enableTextbox = True
                End If
                
                If enableTextbox = True Then
                    TbComment(questionIndex).TextBoxEvents.Text = mKommentartext(questionIndex)
                    TbComment(questionIndex).TextBoxEvents.Locked = False
                End If
                
                ' Gelb einfaerben, wenn es sich um einen Muss-Kommentar handelt
                TbComment(questionIndex).TextBoxEvents.BackColor = IIf(isMussKommentar, MUSS_KOMMENTAR_FARBE, &H80000005)
            Else
                TbComment(questionIndex).TextBoxEvents.Text = FMT0("QUESTIONS_10") ' Defaulttext wieder anzeigen
                TbComment(questionIndex).TextBoxEvents.Locked = True
                TbComment(questionIndex).TextBoxEvents.BackColor = &H80000005
            End If
            

        End If
    End If
    
'    If CanContinue() = True Then
'        OkButton.Enabled = IIf(nSelected >= numQuestions, True, False)
'    Else
'        OkButton.Enabled = False
'    End If
    
    ' Exit if we have an answer selected in Single Question Mode
    If nSelected >= mNumQuestions And autoContinue = True And CanContinue() Then
        OkButton_Click
    End If
End Sub

Private Sub OkButton_Click()

    If GetSelectedAnswerAmount < mNumQuestions Then
      MsgBox FMT0("QUESTIONS_12"), vbExclamation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Major & "-" & app.Minor & "-" & MyInternalVersion & ")"
      Exit Sub
    Else
      If Not CanContinue() Then
        MsgBox FMT0("QUESTIONS_11"), vbExclamation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Major & "-" & app.Minor & "-" & MyInternalVersion & ")"
        Exit Sub
      End If
    End If


    If Not G_Befragung Is Nothing And mInQuestions Then
        ' Die Kommentare speichern (nur bei Fragen - nicht bei Checklisten!)
        Dim numQuestions As Integer
        numQuestions = UBound(TbQuestion) + 1
        
        Dim comments As Collection
        Set comments = G_Befragung.NewComments
        
        Dim q As Long
        q = 0
        For q = 0 To numQuestions - 1
            Dim frageID As Long
            frageID = mQuestionIDs(q)
            Dim oldComment As String
            oldComment = G_Befragung.GetPreviousComment(frageID)
            ' Wenn was anderes eingegeben wurde als der Standardtext oder sich der Kommentar im Vergleich zum alten geaendert hat.
            ' Bei einem Kann-Kommentar kann das auch ein Leerstring sein!
            If Len(TbComment(q).TextBoxEvents.Text) > 0 Or TbComment(q).TextBoxEvents.Text <> oldComment Then
              If TbComment(q).TextBoxEvents.Text <> FMT0("QUESTIONS_10") Then
                Dim Key As String
                Key = "O" & CStr(frageID)
                If CollectionStringExists(comments, Key) Then
                  Call comments.Remove(Key)
                End If
                Call comments.add(TbComment(q).TextBoxEvents.Text, Key)
              End If
            End If
        Next
        Set comments = Nothing
    End If
     
    Cancelled = False
    Me.Hide
    'Unload Me
End Sub

Private Sub CancelButton_Click()
    Cancelled = True
    Me.Hide
    'Unload Me
End Sub

Private Sub BtBack_Click()
    If Not G_Befragung Is Nothing And mInQuestions Then
        ' Die bisher eingegeben Kommentare in den "Previous Comments" speichern
        Call StoreComments
        Dim i As Long
        For i = 0 To UBound(mQuestionIDs)
            If mKommentartext(i) <> "" Then
                Call G_Befragung.SetPreviousComment(mQuestionIDs(i), mKommentartext(i))
            End If
        Next i
    End If
    
    Cancelled = False
    BackSelected = True
    Me.Hide
End Sub

Private Sub StoreComments()
    ' Alle aktuellen Kommentare zu selektierten Antworten aus TbComments in mKommentarText uebernehmen
    Dim numQuestions As Long
    numQuestions = UBound(mQuestions) + 1
    Dim q As Long
    For q = 0 To numQuestions - 1
        If Not TbComment(q) Is Nothing Then
            ' Wenn da was eingegeben wurde und es nicht der Defaulttext ist.
            If TbComment(q).TextBoxEvents.Text <> "" And TbComment(q).TextBoxEvents.Text <> FMT0("QUESTIONS_10") Then
                mKommentartext(q) = TbComment(q).TextBoxEvents.Text
            End If
        End If
    Next q
End Sub

Private Sub Form_QueryUnload(Cancel As Integer, unloadmode As Integer)
    Set mConn = Nothing
    Dim i As Integer
    For i = 1 To UBound(mQuestions)
        Unload TbQuestion(i)
        Unload TbComment(i)
    Next
End Sub



Attribute VB_Name = "RemoveCloseButton"
Option Explicit

Private Const mcGWL_STYLE = (-16)
Private Const mcWS_SYSMENU = &H80000

'Windows API calls to handle windows
#If VBA7 And Win64 Then
  Private Declare PtrSafe Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As LongPtr
  Private Declare PtrSafe Function GetWindowLong Lib "user32" Alias "GetWindowLongPtrA" (ByVal hwnd As LongPtr, ByVal nIndex As Long) As LongPtr
  Private Declare PtrSafe Function SetWindowLong Lib "user32" Alias "SetWindowLongPtrA" (ByVal hwnd As LongPtr, ByVal nIndex As Long, ByVal dwNewLong As LongPtr) As LongPtr
  Private Declare PtrSafe Function DrawMenuBar Lib "user32" (ByVal hwnd As LongPtr) As Long
#Else
  Private Declare Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
  Private Declare Function GetWindowLong Lib "user32" Alias "GetWindowLongA" (ByVal hwnd As Long, ByVal nIndex As Long) As Long
  Private Declare Function SetWindowLong Lib "user32" Alias "SetWindowLongA" (ByVal hwnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
  Private Declare Function DrawMenuBar Lib "user32" (ByVal hwnd As Long) As Long
#End If


Public Sub subRemoveCloseButton(frm As Object)

#If VBA7 And Win64 Then
    Dim lngHWnd As LongPtr
    Dim lngStyle As LongPtr
#Else
    Dim lngHWnd As Long
    Dim lngStyle As Long
#End If

    If val(Application.Version) > 9 Then
        lngHWnd = FindWindow("ThunderDFrame", frm.Caption)
    Else
        lngHWnd = FindWindow("ThunderXFrame", frm.Caption)
    End If
    
    lngStyle = GetWindowLong(lngHWnd, mcGWL_STYLE)

    If (lngStyle And mcWS_SYSMENU) > 0 Then
        Call SetWindowLong(lngHWnd, mcGWL_STYLE, (lngStyle And Not mcWS_SYSMENU))
    End If
    Call DrawMenuBar(lngHWnd)

End Sub
Attribute VB_Name = "SWAppIDs"
Option Explicit

Public Enum StromwerkenAppID
SWAPPID_IDVSuite = 1
SWAPPID_ExcelTracker = 2
SWAPPID_AccessTracker = 3
SWAPPID_ExcelSheetChecker = 4
SWAPPID_IDVSuiteScheduler = 5
SWAPPID_PluginCheck = 6
SWAPPID_ECCDaemon = 7
SWAPPID_ExcelFileCompare = 8
SWAPPID_ExcelSheetQA = 9
SWAPPID_ExcelProtect = 10
SWAPPID_ACCDaemon = 11
SWAPPID_SWKeyManager = 12
SWAPPID_AccessChecker = 13
SWAPPID_FileTracker = 14
End Enum


Attribute VB_Name = "SchedulerStuff"
Option Explicit

Function ScanFileViaSched(ByRef conn As Object, ByVal idvDateiID As Long, ByVal storeResult As Boolean) As Boolean
    If idvDateiID > 0 Then
      If G_PARAM_ReihenfolgeAppInfo > 0 Then
        If G_CfgAppinfoAnalysis = True Or storeResult = False Then
          If Not conn Is Nothing Then
            If SchedulerRunning(conn) Then
              If Not UserHasCommandInScheduler(conn) Then
                AddSchedulerCommand conn, "ECCSCAN" & _
                  " /ID:" & idvDateiID & IIf(storeResult = True, _
                  " /RES:" & 1, "")  ' Store Resultfile in Scheduler Command
                ScanFileViaSched = True
              End If
            End If
          End If
        End If
      End If
    End If
End Function

Function UserHasCommandInScheduler(ByRef conn As Object, Optional ByVal idvDateiID As Long = 0) As Boolean
  Dim rs As Object
  
  ' Liefert faulse, wenn gerade ein Scheduler Command l|fffd|uft.
  Set rs = OpenRS("select * FROM gCommunicate WHERE ((Interface = 'SchedTaskUser' and LogonID = '" & GetUserName & "' and idvDateiID=" & idvDateiID & ") or Interface = 'SchedTask') and CommStatus=0", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
  ' Geht auch, wenn ein Commando l|fffd|uft.
'  Set rs = OpenRS("select * FROM gCommunicate WHERE ((Interface = 'SchedTaskUser' and LogonID = '" & GetUserName & "' and idvDateiID=" & idvDateiID & ") ) and CommStatus=0", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
  If Not rs Is Nothing Then
    If Not rs.EOF Then
      UserHasCommandInScheduler = True
    End If
    rs.Close
    Set rs = Nothing
  End If
End Function

Function SchedulerRunning(ByRef conn As Object) As Boolean
  
  Dim rs As Object
  Set rs = OpenRS("select * FROM gCommunicate WHERE Interface = 'SchedScreen' and Prio = 0", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
  If Not rs Is Nothing Then
    If Not rs.EOF Then
      Dim d As Date
      d = GetSafeFieldPlus(rs, "StartTime", #1/1/1900#)
      If DateAdd("s", 60, d) > Now Then
          SchedulerRunning = True
      End If
    End If
    rs.Close
    Set rs = Nothing
  End If
  
'    Dim s As String
'    s = GetComm(conn, "SchedStatus")
'    If IsDate(s) Then
'        If DateAdd("s", 60, CDate(s)) > Now Then
'            SchedulerRunning = True
'            Exit Function
'        End If
'    End If
End Function

Function GetComm(ByRef conn As Object, ByVal interface As String) As String
  Dim s As String
  s = ""

  Dim rs As Object
  Set rs = OpenRS("select * FROM gCommunicate WHERE Interface = '" & interface & "'", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
  If Not rs Is Nothing Then
    If Not rs.EOF Then
      s = rs.Fields("COMM").value
    End If
    rs.Close
    Set rs = Nothing
  End If

  GetComm = s
End Function


Sub StoreComm(ByVal interface As String, ByVal v As String)
  
  On Error Resume Next
  Dim conn As Object
  Dim rs As Object
  
  Dim allowLoggingToStorage As Boolean
  allowLoggingToStorage = G_AllowLoggingToStorage
  G_AllowLoggingToStorage = False
  
  Set conn = GetConnection()
  
  If conn Is Nothing Then
      G_AllowLoggingToStorage = allowLoggingToStorage
      Exit Sub
  End If
  
  Set rs = OpenRS("select * FROM gCommunicate WHERE Interface = '" & interface & "'", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockOptimistic)
  If Not rs Is Nothing Then
    If rs.EOF Then
      rs.AddNew
      rs.Fields("Interface").value = interface
    End If
    rs.Fields("COMM").value = v
    rs.Update
    rs.Close
    Set rs = Nothing
  End If
  conn.Close
  Set conn = Nothing

  G_AllowLoggingToStorage = allowLoggingToStorage

End Sub


Function AddSchedulerCommand(ByRef conn As Object, ByVal com As String, Optional ByVal idvDateiID As Boolean = 0) As Boolean
    Dim rs As Object
    Set rs = OpenRS("SELECT * FROM gCommunicate where Prio = -1", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockPessimistic)
    If Not rs Is Nothing Then
      rs.AddNew
      rs.Fields("Interface").value = "SchedTaskUser"
      rs.Fields("Comm").value = com
      rs.Fields("Prio").value = 100
      rs.Fields("LogonID").value = GetUserName
      rs.Fields("ReceiverMail").value = GetUserMail(conn, GetUserName)
      rs.Fields("StartTime").value = Now
      rs.Fields("idvDateiID").value = idvDateiID
      rs.Update
      DebugPrint tinfo, "Kommando '" & com & "' an Scheduler geschickt!"
      rs.Close
      Set rs = Nothing
    End If
End Function

Attribute VB_Name = "ShareStuff"
Option Explicit

Private Type MungeLong
    x As Long
    Dummy As Integer
End Type

Private Type MungeInt
    XLo As Integer
    XHi As Integer
    Dummy As Integer
End Type

#If VBA7 And Win64 Then
'Done
Public Declare PtrSafe Function NetShareGetInfo Lib "Netapi32.dll" (strServerName As Any, strNetName As Any, ByVal nLevel As Long, pBuffer As LongPtr) As Long
Public Declare PtrSafe Function NetApiBufferFree Lib "Netapi32.dll" (ByVal lpBuffer As LongPtr) As Long
Public Declare PtrSafe Function PtrToInt Lib "Kernel32.dll" Alias "lstrcpynW" (ByVal pwsDest As LongPtr, ByVal pwsSource As LongPtr, ByVal cchCount As Long) As LongPtr
Public Declare PtrSafe Function PtrToStr Lib "Kernel32.dll" Alias "lstrcpyW" (ByVal lpString1 As LongPtr, ByVal lpString2 As LongPtr) As LongPtr
Public Declare PtrSafe Function lstrcpyW Lib "Kernel32.dll" (ByVal lpString1 As LongPtr, ByVal lpString2 As LongPtr) As LongPtr
Public Declare PtrSafe Function StrLen Lib "kernel32" Alias "lstrlenW" (ByVal ptr As LongPtr) As Long
Public Declare PtrSafe Function lstrlenW Lib "kernel32" (ByVal ptr As LongPtr) As Long
#Else
Public Declare Function NetShareGetInfo Lib "NETAPI32" (ByRef servername As Byte, ByRef NetName As Byte, ByVal Level As Long, ByRef buffer As Long) As Long
Public Declare Function NetApiBufferFree Lib "Netapi32.dll" (bufptr As Any) As Long
Public Declare Function PtrToInt Lib "kernel32" Alias "lstrcpynW" (RetVal As Any, ByVal ptr As Long, ByVal nCharCount As Long) As Long
Public Declare Function PtrToStr Lib "kernel32" Alias "lstrcpyW" (RetVal As Byte, ByVal ptr As Long) As Long
Public Declare Function lstrcpyW Lib "kernel32" (RetVal As Byte, ByVal ptr As Long) As Long
Public Declare Function StrLen Lib "kernel32" Alias "lstrlenW" (ByVal ptr As Long) As Long
Public Declare Function lstrlenW Lib "kernel32" (ByVal ptr As Long) As Long
#End If

Public Function GetLocalPath(sUNCPath As String, ByRef servername As String) As String

  Dim x As New CShareInfo

  x.GetInfo sUNCPath
  If x.nLastError = 0 Then
    servername = IIf(Left(x.strServer, 2) = "\\", Mid(x.strServer, 3), x.strServer)
    GetLocalPath = x.strPath
  Else
    servername = ""
    GetLocalPath = sUNCPath
  End If
  Exit Function
    
    
    Dim sTemp As String
    Dim sServer As String
    Dim sShare As String
    Dim baServer() As Byte
    Dim baShare() As Byte
    Dim Result As Long
#If VBA7 And Win64 Then
    Dim buf As LongPtr
#Else
    Dim buf As Long
#End If
    Dim TempStr As MungeInt
    Dim TempPtr As MungeLong
    Dim STRArray(0 To 1024) As Byte
    Dim sBasePath As String
    
    On Error GoTo nogo
    If InStr(1, sUNCPath, "\") <= 0 Then
        DebugPrint tdebug, "GetLocalPathFail:" & sUNCPath
        GetLocalPath = sUNCPath
        Exit Function
    End If

    DebugPrint tdebug, "GetLocalPath:" & sUNCPath
    sTemp = Mid(sUNCPath, 3)
    sServer = Left(sTemp, InStr(1, sTemp, "\") - 1)
    sTemp = Mid(sTemp, InStr(1, sTemp, "\") + 1)
    If InStr(1, sTemp, "\") > 0 Then
        sShare = Left(sTemp, InStr(1, sTemp, "\") - 1)
        sTemp = Mid(sTemp, InStr(1, sTemp, "\"))
    Else
        sShare = sTemp
        sTemp = ""
    End If

    baServer = "\\" & sServer & Chr(0)
    baShare = UCase(sShare) & Chr(0)

    DebugPrint tdebug, "GetLocalPath-1"
    Result = NetShareGetInfo(baServer(0), baShare(0), 2, buf)
    DebugPrint tdebug, "GetLocalPath-2"
    
    Dim mvarLastError
    Dim server As String
    mvarLastError = Result

    If Result = 0 Then
        PtrToInt TempStr.XLo, buf + 24, 2
        PtrToInt TempStr.XHi, buf + 26, 2
        LSet TempPtr = TempStr
        PtrToStr STRArray(0), TempPtr.x
        sBasePath = Left(STRArray, StrLen(TempPtr.x))
        DebugPrint tdebug, "GetLocalPath-3"

        NetApiBufferFree buf
        DebugPrint tdebug, "GetLocalPath-4"

        server = sServer
        If Right(sBasePath, 1) = "\" And Left(sTemp, 1) = "\" Then
          GetLocalPath = sBasePath & Mid(sTemp, 2)
        Else
          GetLocalPath = sBasePath & sTemp
        End If
    End If
    Exit Function
nogo:
    GetLocalPath = sUNCPath
End Function


Attribute VB_Name = "SocketConnect"
Option Explicit

' Sockets in VBA
' http://binaryworld.net/main/CodeDetail.aspx?CodeId=3591

' Variable addresses in VB
' https://support.microsoft.com/en-us/kb/199824
'VarPtr - Returns the address of a variable.
'VarPtrArray - Returns the address of an array.
'StrPtr - Returns the address of the UNICODE string buffer.
'VarPtrStringArray - Returns the address of an array of strings.
'ObjPtr - Returns the pointer to the interface referenced by an object variable.

' http://www.codeguru.com/vb/gen/vb_misc/algorithms/article.php/c7495/How-Visual-Basic-6-Stores-Data.htm
' sizeof(x) 32bit  64bit
'vbDate     8       8
'vbDecimal  12      12
'vbVariant  16      24

Private Const INADDR_NONE As Long = &HFFFFFFFF
Private Const WSA_SUCCESS = 0
Private Const WSAEWOULDBLOCK = 10035

'Public Const GWL_STYLE = -16
'Public Const WS_SYSMENU = &H80000
Private Const ICMP_SUCCESS As Long = 0

Private Const WSA_VERSION As Long = &H202

Private Const MAX_WSADescription As Long = 256
Private Const MAX_WSASYSStatus As Long = 128

Private Const AF_INET = 2    'internetwork: UDP, TCP, etc.

Private Const SOCK_STREAM = 1       'Stream socket
Private Const SOCK_DGRAM = 2        'Datagram socket
Private Const SOCK_RAW = 3          'Raw data socket
Private Const SOCK_RDM = 4          'Reliable Delivery socket
Private Const SOCK_SEQPACKET = 5    'Sequenced Packet socket


'Public Const INVALID_SOCKET = &HFFFF
Private Const SOCKET_ERROR = -1

' ioctlsocket flags
'#define FIONBIO     _IOW('f', 126, u_long) /* set/clear non-blocking i/o */
Private Const FIONBIO = &H8004667E


Private Type WSAData
    wVersion As Integer
    wHighVersion As Integer
    szDescription(0 To MAX_WSADescription) As Byte
    szSystemStatus(0 To MAX_WSASYSStatus) As Byte
    wMaxSockets As Long
    wMaxUDPDG As Long
    dwVendorInfo As Long
End Type

' For select function
Private Type timeval
  tv_sec As Long    'seconds
  tv_usec As Long   'microseconds
End Type

Private Const FD_SETSIZE = 63
Private Type fd_set
  fd_count As Long                      ' how many are SET?
#If VBA7 And Win64 Then
  fd_array(0 To FD_SETSIZE) As LongPtr  ' an array of SOCKETs
#Else
  fd_array(0 To FD_SETSIZE) As Long     'As LongPtr  ' an array of SOCKETs
#End If
End Type

'A note to those familiar with the C header file for Winsock
'Visual Basic does not permit a user-defined variable type
'to be used as a return structure. In the case of the
'variable definition below, sin_addr must
'be declared as a long integer rather than the user-defined
'variable type of in_addr.
Private Type sockaddr_in
  sin_family As Integer
  sin_port As Integer
  sin_addr As Long  ' Die IP - 4 bytes
  sin_zero As String * 8
End Type


'Declare Socket functions
#If VBA7 And Win64 Then
' XXX64
    Private Declare PtrSafe Function closesocket Lib "ws2_32" (ByVal s As LongPtr) As Long
    Private Declare PtrSafe Function bind Lib "ws2_32" (ByVal s As Long, addr As sockaddr_in, ByVal namelen As Long) As Long
    ' If no error occurs, connect returns zero. Otherwise, it returns SOCKET_ERROR, and a specific error code can be retrieved by calling WSAGetLastError.
    Private Declare PtrSafe Function connect Lib "ws2_32" (ByVal s As LongPtr, addr As sockaddr_in, ByVal namelen As Long) As Long
    Private Declare PtrSafe Function htons Lib "ws2_32" (ByVal hostshort As Long) As Integer
    Private Declare PtrSafe Function inet_addr Lib "ws2_32" (ByVal cp As String) As Long
    Private Declare PtrSafe Function recv Lib "ws2_32" (ByVal s As Long, ByVal buf As Any, ByVal buflen As Long, ByVal flags As Long) As Long
    Private Declare PtrSafe Function send Lib "ws2_32" (ByVal s As Long, buf As Any, ByVal buflen As Long, ByVal flags As Long) As Long
    Private Declare PtrSafe Function socket Lib "ws2_32" (ByVal af As Long, ByVal socktype As Long, ByVal protocol As Long) As LongPtr
    Private Declare PtrSafe Function gethostbyname Lib "ws2_32.dll" (ByVal hostname As String) As LongPtr
    ' Retuns 0 on success
    Private Declare PtrSafe Function WSAStartup Lib "ws2_32" (ByVal wVersionRequired As Long, lpWSAData As WSAData) As Long
    Private Declare PtrSafe Function WSACleanup Lib "ws2_32" () As Long
    Private Declare PtrSafe Function WSAGetLastError Lib "ws2_32" () As Long
    
'    int
'WSAAPI
'ioctlsocket(
'    IN SOCKET s,
'    IN long cmd,
'    __inout u_long FAR * argp
'    );
    Private Declare PtrSafe Function ioctlsocket Lib "ws2_32" (ByVal socket As LongPtr, ByVal cmd As Long, ByVal argp As LongPtr) As Long
    
    Private Declare PtrSafe Function vbselect Lib "ws2_32" Alias "select" (ByVal nfds As Long, _
                                                        ByVal readfds As Any, _
                                                        ByVal writefds As Any, _
                                                        ByVal exceptfds As Any, _
                                                        ByVal timeout As Any) As Long
                                                        
    
#Else
    Private Declare Function closesocket Lib "ws2_32" (ByVal s As Long) As Long
    Private Declare Function bind Lib "ws2_32" (ByVal s As Long, addr As sockaddr_in, ByVal namelen As Long) As Long
    ' If no error occurs, connect returns zero. Otherwise, it returns SOCKET_ERROR, and a specific error code can be retrieved by calling WSAGetLastError.
    Private Declare Function connect Lib "ws2_32" (ByVal s As Long, addr As sockaddr_in, ByVal namelen As Long) As Long
    Private Declare Function htons Lib "ws2_32" (ByVal hostshort As Long) As Integer
    Private Declare Function inet_addr Lib "ws2_32" (ByVal cp As String) As Long
    Private Declare Function recv Lib "ws2_32" (ByVal s As Long, ByVal buf As Any, ByVal buflen As Long, ByVal flags As Long) As Long
    Private Declare Function send Lib "ws2_32" (ByVal s As Long, buf As Any, ByVal buflen As Long, ByVal flags As Long) As Long
    Private Declare Function socket Lib "ws2_32" (ByVal af As Long, ByVal socktype As Long, ByVal protocol As Long) As Long
    Private Declare Function gethostbyname Lib "ws2_32.dll" (ByVal hostname As String) As Long
    ' Retuns 0 on success
    Private Declare Function WSAStartup Lib "ws2_32" (ByVal wVersionRequired As Long, lpWSAData As WSAData) As Long
    Private Declare Function WSACleanup Lib "ws2_32" () As Long
    Private Declare Function WSAGetLastError Lib "ws2_32" () As Long
    'Private Declare Function WSAUnhookBlockingHook Lib "ws2_32" () As Long
    
    Private Declare Function ioctlsocket Lib "ws2_32" (ByVal socket As Long, ByVal cmd As Long, ByVal argp As Long) As Long
    Private Declare Function vbselect Lib "ws2_32" Alias "select" (ByVal nfds As Long, _
                                                        ByVal readfds As Any, _
                                                        ByVal writefds As Any, _
                                                        ByVal exceptfds As Any, _
                                                        ByVal timeout As Any) As Long
   
#End If

#If VBA7 And Win64 Then
Private Function GetIPFromHostName(ByVal sHostName As String) As String
    'converts a host name to an IP address.
    Dim ptrHostent As LongPtr   'address of hostent structure
    Dim ptrName As LongPtr      'address of name pointer
    Dim ptrAddress As LongPtr   'address of address pointer
    Dim ptrIPAddress As LongPtr
    Dim sAddress As String
    sAddress = Space$(4)
    ptrHostent = gethostbyname(sHostName & vbNullChar)
    If ptrHostent <> 0 Then
        ptrName = ptrHostent
        ' +24 wegen alignment
        ptrAddress = ptrHostent + 24
'        struct  hostent {
'            char    FAR * h_name;           /* official name of host */
'            char    FAR * FAR * h_aliases;  /* alias list */
'            short   h_addrtype;             /* host address type */
'            short   h_length;               /* length of address */
'            char    FAR * FAR * h_addr_list; /* list of addresses */
'            #define h_addr  h_addr_list[0]          /* address, for backward compat */
'        };
        'get the IP address
        'CopyMemory ptrName, ByVal ptrName, 4
        CopyMemory ptrAddress, ByVal ptrAddress, Len(ptrAddress)
        CopyMemory ptrIPAddress, ByVal ptrAddress, Len(ptrAddress)
        CopyMemory ByVal sAddress, ByVal ptrIPAddress, Len(ptrAddress)
        GetIPFromHostName = IPToText(sAddress)
    End If
End Function
#Else
Private Function GetIPFromHostName(ByVal sHostName As String) As String
    'converts a host name to an IP address.
    Dim ptrHostent As Long  'As LongPtr   'address of hostent structure
    Dim ptrName As Long 'As LongPtr      'address of name pointer
    Dim ptrAddress As Long 'As LongPtr   'address of address pointer
    Dim ptrIPAddress As Long 'As LongPtr
    Dim sAddress As String
    sAddress = Space$(4)
    ptrHostent = gethostbyname(sHostName & vbNullChar)
    If ptrHostent <> 0 Then
        ptrName = ptrHostent
        ptrAddress = ptrHostent + 12
        'get the IP address
        CopyMemory ptrName, ByVal ptrName, 4
        CopyMemory ptrAddress, ByVal ptrAddress, 4
        CopyMemory ptrIPAddress, ByVal ptrAddress, 4
        CopyMemory ByVal sAddress, ByVal ptrIPAddress, 4
        GetIPFromHostName = IPToText(sAddress)
    End If
End Function
#End If

Private Function IPToText(ByVal ipAddress As String) As String
    IPToText = CStr(Asc(ipAddress)) & "." & _
               CStr(Asc(Mid$(ipAddress, 2, 1))) & "." & _
               CStr(Asc(Mid$(ipAddress, 3, 1))) & "." & _
               CStr(Asc(Mid$(ipAddress, 4, 1)))
End Function

Public Function GetServernameAndPort(connectionString As String, ByRef servername As String, ByRef port As Long) As Boolean
    ' Beispiel connection strings
    ' Access:   "Driver={Microsoft Access Driver (*.mdb)};DBQ=d:\IDV-SuiteCF\idv-suite\BackendMDB\IDV-TrackerData.mdb;"
    ' MSSQL:    "Driver={SQL Server};Server=localhost,1434;Database=IDV-Tracker;"
    '           "Driver={SQL Server};Server=winxp-office-dv;Database=IDV-Tracker;"
    ' Oracle:   "Driver={Oracle in XE};dbq=localhost:1521;"
    '           "Driver={Oracle in XE};dbq=localhost:1522/oracle12;"
    connectionString = LCase(connectionString)
    Dim pos1 As Long
    Dim pos2 As Long
    Dim pos3 As Long
    Dim s As String
    Select Case G_DBType
    Case G_Oracle:
        port = 1521
        pos1 = InStr(connectionString, "dbq=")
        If pos1 > 0 Then
            pos1 = pos1 + Len("dbq=")
            pos2 = InStr(pos1, connectionString, "/")
            If pos2 <= 0 Then
                pos2 = InStr(pos1, connectionString, ";")
            End If
            If pos2 = 0 Then Exit Function
            pos3 = InStr(pos1, connectionString, ":")
            If pos3 > 0 Then
                ' Port aus dem connection string lesen
                s = Mid(connectionString, pos3 + 1, pos2 - pos3 - 1)
                port = val(s)
                pos2 = pos3
            Else
                ' Default port verwenden
            End If
            servername = Mid(connectionString, pos1, pos2 - pos1)
            GetServernameAndPort = Len(servername) > 0 And port > 0
        End If
        
    Case G_SQL_Server
        port = 1433
        pos1 = InStr(connectionString, "server=")
        If pos1 > 0 Then
            pos1 = pos1 + Len("server=")
            pos2 = InStr(pos1, connectionString, ";")
            If pos2 = 0 Then Exit Function
            pos3 = InStr(pos1, connectionString, ",")
            If pos3 > 0 Then
                ' Port aus dem connection string lesen
                s = Mid(connectionString, pos3 + 1, pos2 - pos3 - 1)
                port = val(s)
                pos2 = pos3
            Else
                ' Default port verwenden
            End If
            servername = Mid(connectionString, pos1, pos2 - pos1)
            GetServernameAndPort = Len(servername) > 0 And port > 0
        End If
    End Select
End Function

Public Function ConnectTest(hostname As String, port As Long, connectTimeout As Long, ByRef errMsg As String) As Boolean
    On Error GoTo nogo
    
    ConnectTest = False
    
    Dim wsad As WSAData
    If WSAStartup(WSA_VERSION, wsad) <> WSA_SUCCESS Then
        errMsg = "Error in WSAStartup!"
        Exit Function
    End If
    
    Dim ip As String
    ip = GetIPFromHostName(hostname)
    If ip = "" Then
        errMsg = "Error failed to get IP for host: " & hostname
        GoTo nogo
    End If
    
    Dim socketAddress As sockaddr_in
    socketAddress.sin_family = AF_INET
    socketAddress.sin_port = htons(port)
    socketAddress.sin_addr = inet_addr(ip)
    socketAddress.sin_zero = String$(8, 0)
    
#If VBA7 And Win64 Then
    Dim socketId As LongPtr 'As LongPtr
#Else
    Dim socketId As Long
#End If
    socketId = socket(AF_INET, SOCK_STREAM, 0)
    If socketId = SOCKET_ERROR Then
        ' Error
        GoTo nogo
    End If

    Dim lastErr As Long
    Dim ret As Long
    
    ' Switch to non-blocking socket
    Dim opt As Long
    opt = 1
#If VBA7 And Win64 Then
    Dim ptr As LongPtr
#Else
    Dim ptr As Long 'As LongPtr
#End If
    ptr = VarPtr(opt)
    ret = ioctlsocket(socketId, FIONBIO, ptr)
    If ret = SOCKET_ERROR Then
        lastErr = WSAGetLastError()
        If lastErr = 0 Then
          lastErr = err.LastDllError
        End If
        If lastErr <> 0 Then
          'errMsg = GetSystemErrorMessageText(lastErr)
        End If
        errMsg = "Error in ioctlsocket call = " & str$(ret) & " WSAGetLastError: " & errMsg
        Exit Function
    End If

    ret = connect(socketId, socketAddress, Len(socketAddress))
    If ret <> 0 Then
      If WSAGetLastError() <> WSAEWOULDBLOCK Then
        lastErr = WSAGetLastError()
        If lastErr = 0 Then
          lastErr = err.LastDllError
        End If
        If lastErr <> 0 Then
          'errMsg = GetSystemErrorMessageText(lastErr)
        End If
        errMsg = "Error in connect call = " & str$(ret) & " WSAGetLastError: " & errMsg
        Exit Function
      End If
    End If
    
    Dim fdsWrite As fd_set
    Dim timeout As timeval
'    FD_ZERO(&fds);
'    FD_SET(s, &fds);
    fdsWrite.fd_count = 1
    fdsWrite.fd_array(0) = socketId
    ptr = VarPtr(fdsWrite)

    timeout.tv_sec = connectTimeout
    timeout.tv_usec = 0

    ret = vbselect(0&, 0&, ByVal ptr, 0&, VarPtr(timeout))
    'ret = vbselect(0&, 0&, ptr, 0&, 0&)
    If ret = SOCKET_ERROR Then
        If lastErr = 0 Then
          lastErr = err.LastDllError
        End If
        If lastErr <> 0 Then
          'errMsg = GetSystemErrorMessageText(lastErr)
        End If
        errMsg = "Error in select call = " & str$(ret) & " WSAGetLastError: " & errMsg
        GoTo nogo
    ElseIf ret = 0 Then
      errMsg = "No connection after " & connectTimeout & " seconds!"
      GoTo nogo
    End If
    
    ConnectTest = True
    
    ' Enable blocking socket again
    opt = 0
    ptr = VarPtr(opt)
    ioctlsocket socketId, FIONBIO, ptr
    
    
    If closesocket(socketId) <> 0 Then
        ' Error
        GoTo nogo
    End If
    
    WSACleanup

    Exit Function
    
nogo:
    WSACleanup
    ConnectTest = False
End Function

Attribute VB_Name = "StatusForm"
Attribute VB_Base = "0{8F05607D-828E-4F78-839B-343C07B29495}{D6F78E72-316E-4223-A4C8-6EA162B13CBA}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Private Sub cmdAbbruch_Click()
  G_StatusFormAbbruch = True
End Sub

Private Sub UserForm_Initialize()
    gTranslation.TranslateForm Me
End Sub
Attribute VB_Name = "StoreUnit"
Option Explicit

Const Y_Fragen As Double = 6.75
Const X_Fragen As Double = 4.5
Const W_Fragen As Double = 288
Const H_Fragen As Double = 27
Const YAdd_Fragen As Double = 36

Const X_Frame As Double = 301.5
Const Y_Frame As Double = 55
Const H_Frame As Double = 24.75
Const L_Frame As Double = 4.5

Const Y_Antwort As Double = 2.25
Const X_Antwort As Double = 4.5
Const W_Antwort As Double = 108
Const H_Antwort As Double = 18

Const X_AntwortOff As Double = 117

    
    
Const C_Fragen_Mit_Datei|fffd|berschrift As Long = 60 + 20
Const C_Fragen_Hoehe_Header = 24

Const C_Fragen_Zeilenh|fffd|he As Long = 20 ' Debug.Print TwipsToPixelsX(frmFragen2.Frage.Height)  = 24
Const C_Fragen_HoeheFragen As Long = 24
Const C_Fragen_Antwort_Y As Long = C_Fragen_Hoehe_Header + C_Fragen_Mit_Datei|fffd|berschrift + C_Fragen_HoeheFragen ' Debug.Print TwipsToPixelsX(frmFragen2.Antwort1.Top)  = 128

Const C_Fragen_H|fffd|heNoBack As Long = C_Fragen_Hoehe_Header + C_Fragen_Mit_Datei|fffd|berschrift + C_Fragen_HoeheFragen + 24 + 36 + 8 ' 10 = Padding zwischen den Fragen und Antworten, 8 = Rahmen unten Debug.Print TwipsToPixelsX(frmFragen2.Height)        = 211
Const C_Fragen_H|fffd|he As Long = C_Fragen_H|fffd|heNoBack + 30 ' 30 = eine zus|fffd|tzliche Zeile f|fffd|r den Zur|fffd|ckbutton

Const C_Fragen_Max_Zeichen_pro_Zeile As Long = 64

Const EncodeString As String = "AbC37cGh!%9sdfP'#N'S'|fffd||fffd|PI|fffd|ip|fffd|ff034(=4324f"

Public Const Checkliste_NichtAnwenden As Long = 0
Public Const Checkliste_Muss As Long = 1
Public Const Checkliste_Kann As Long = 2

Public Const KEIN_KOMMENTAR = 0
Public Const KANN_KOMMENTAR = 1
Public Const MUSS_KOMMENTAR = 2
Public Const MUSS_KOMMENTAR_SCHUTZB_REDUZIERT = 3
Public Const KOMMENTAR_MIN_ZEICHEN = 16

Public Const VORAUSWAHL_KEINE = 0
Public Const VORAUSWAHL_LETZTE_ANTWORT = 1
Public Const VORAUSWAHL_INTEGRITAET = 2
Public Const VORAUSWAHL_VERTRAULICHKEIT = 3
Public Const VORAUSWAHL_VERFUEGBARKEIT = 4
Public Const VORAUSWAHL_AUTHENTIZITAET = 6
Public Const VORAUSWAHL_INFORMATIONSKLASSE = 5

Private ChecklistenFragenAntworten As Collection

Public G_DocInfo As DocInfo

Public Sub SetChecklistenFrageAntwort(frageID As Long, CLQuestionID As Long, antwortID As Long)
    On Error GoTo notReadable
    Dim Key As String
    Dim value As String
    Key = CStr("I" & frageID & "_" & CLQuestionID)
    value = CStr(frageID) & "_" & CStr(CLQuestionID) & "_" & CStr(antwortID)
    If CollectionItemExists(ChecklistenFragenAntworten, Key) Then
        'ChecklistenFragenAntworten(CStr("I" & frageID)) = value
        ChecklistenFragenAntworten.Remove Key
    End If
    ChecklistenFragenAntworten.add value, Key
notReadable:
End Sub

Function CollectFragenGroup(ByRef frageRs As Object, ByRef gruppe As Collection) As Integer
    Dim startNr As Integer
    startNr = frageRs!nr
      
    If Not IsNull(frageRs!NaechsteFragenGruppenNr) And frageRs!NaechsteFragenGruppenNr > 0 Then
      Dim nr As Integer
      nr = frageRs!nr
      
      Do
          If CollectionItemExists(gruppe, CStr("I" & nr)) Then
              CollectFragenGroup = -1
              Exit Function
          End If
          gruppe.add CStr(nr), CStr("I" & nr)
          
          nr = IIf(IsNull(frageRs!NaechsteFragenGruppenNr), -1, frageRs!NaechsteFragenGruppenNr)
          If nr <= 0 Then
            ' Wir sind fertig
            Exit Do
          End If
          frageRs.MoveFirst
          frageRs.Find "nr = " & nr
          If frageRs.EOF Then
            ' Linkt zu einer Frage die es nicht gibt!
            CollectFragenGroup = -1
            Exit Function
          End If
      Loop
    End If
    CollectFragenGroup = gruppe.count
End Function

' Returns the result value calculated from the checklist answers (this is always >= 0)
' or -1 for error
Public Function DoChecklistModal(frageID As Long, CLZuweisungsID As Long, ByRef conn As Object, Dateiname As String, _
                                ByRef clPreSelection() As Boolean) As Double
    DoChecklistModal = -1
    
    Dim clrs As Object
    Set clrs = CreateObject("ADODB.Recordset")
    clrs.Open "SELECT * FROM gCL WHERE CLZuweisungsID = " & CLZuweisungsID, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
    If Not clrs.EOF Then
        Dim questions() As String
        Dim questionIDs() As Long
        Dim hinweis() As String
        Dim answers() As String
        Dim answerIDs() As Long
        Dim werte() As Double
        Dim checklistIDs() As Long  ' Die bleiben hier immer leer
        Dim checklistType() As Long
        Dim i As Integer
        
        Dim fragenrs As Object
        Set fragenrs = CreateObject("ADODB.Recordset")
        fragenrs.Open "SELECT gCLFragen.CLFrageID, uf.LokalisierterText as LocFrage, uh.LokalisierterText as LocHinweis, gCLFragen.Frage, gCLFragen.Hinweistext " & _
        " FROM ((gCLFragen left join gTexteUebersetzungen uf on (gCLFragen.TextID = uf.TextID and uf.LanguageID = " & GetMyDBLanguage(conn) & ")) " & _
        " left join gTexteUebersetzungen uh on (uh.TextID = gCLFragen.HinweistextTextID and uh.LanguageID = " & GetMyDBLanguage(conn) & ")) " & _
        " WHERE CLID = " & clrs!clid, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
        If Not fragenrs.EOF Then
            fragenrs.MoveLast
            Dim numQuestions As Integer
            numQuestions = fragenrs.RecordCount
            fragenrs.MoveFirst
            
            ReDim questions(numQuestions - 1)
            ReDim questionIDs(numQuestions - 1)
            ReDim hinweis(numQuestions - 1)
            ReDim answers(numQuestions * 4 - 1)
            ReDim answerIDs(numQuestions * 4 - 1)
            ReDim werte(numQuestions * 4 - 1)
            If UBound(clPreSelection) < numQuestions * 4 - 1 Then
                ReDim clPreSelection(numQuestions * 4 - 1) As Boolean
                For i = 0 To numQuestions * 4 - 1
                    clPreSelection(i) = False
                Next
            End If
            
            For i = 0 To numQuestions - 1
                questions(i) = GetLocValueFromField(fragenrs, "Frage", "LocFrage", "")
                questionIDs(i) = fragenrs!CLFrageID
                hinweis(i) = GetLocValueFromField(fragenrs, "Hinweistext", "LocHinweis", "")
                
                Dim answersrs As Object
                Set answersrs = CreateObject("ADODB.Recordset")
                answersrs.Open "SELECT gCLFragenAntworten.CLFrageAntwortID, gCLFragenAntworten.Wert, gClFragenAntworten.Antwort, ua.LokalisierterText as LocAntwort FROM " & _
                " (gCLFragenAntworten left join gTexteUebersetzungen ua on (ua.TextID = gCLFragenAntworten.TextID and ua.LanguageID = " & GetMyDBLanguage(conn) & ")) " & _
                " WHERE CLFrageID = " & fragenrs!CLFrageID, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
                
                Dim numAnswers As Integer
                numAnswers = 0
                Do While Not answersrs.EOF
                    answers(i * 4 + numAnswers) = GetLocValueFromField(answersrs, "Antwort", "LocAntwort", "")
                    answerIDs(i * 4 + numAnswers) = answersrs!CLFrageAntwortID
                    werte(i * 4 + numAnswers) = answersrs!wert
                    answersrs.MoveNext
                    numAnswers = numAnswers + 1
                Loop
                answersrs.Close
                
                fragenrs.MoveNext
            Next
        End If
        fragenrs.Close
        
        If numQuestions > 0 Then
            Dim checklistenTitel As String
            checklistenTitel = clrs!CLName
            Dim risikomethode As Integer
            risikomethode = clrs!Risikoberechnungsmethode
                    
            Dim frmChecklist As QuestionsDialog
            Set frmChecklist = New QuestionsDialog
            frmChecklist.SetQuestionsCL conn, frageID, checklistenTitel, questions, hinweis, answers, werte, checklistIDs, checklistType, clPreSelection, Dateiname, answerIDs
            frmChecklist.Initialize
            subRemoveCloseButton frmChecklist
            If frmChecklist.ShowDialog(Nothing) = vbOK Then
                ' Determine vals
                DoChecklistModal = 0
                For i = 0 To UBound(clPreSelection)
                    clPreSelection(i) = False
                Next
                For i = 0 To numQuestions - 1
                    Dim answerIdx As Integer
                    Dim val As Double
                    answerIdx = frmChecklist.GetResultIndex(i)
                    ' Also store selected answer
                    clPreSelection(i * 4 + answerIdx) = True
                    
                    If answerIdx >= 0 Then
                        val = werte(i * 4 + answerIdx)
                        If risikomethode = 0 Then
                            ' Additiv
                            DoChecklistModal = DoChecklistModal + val
                        Else
                            ' Maximum
                            DoChecklistModal = IIf(DoChecklistModal >= val, DoChecklistModal, val)
                        End If
                        ' Die gewaehlte Antwort zur Checklistenfrage temporaer speichern
                        SetChecklistenFrageAntwort frageID, questionIDs(i), answerIDs(i * 4 + answerIdx)
                    End If
                Next
                Unload frmChecklist
                Set frmChecklist = Nothing
            End If
        End If
    End If
    clrs.Close
End Function

Function DoFrageModal(dateiRS As Object, Dateiname As String, ByRef officeapp As Object, objtyp As Long, ByVal rs As Object, ByRef NextNr As Long, _
                    ByRef antwortID As Long, ByRef conn As Object, showBack As Boolean, ByRef AbsoluterWert As Boolean, _
                    anzahlVerschiebungen As Long, sb_bisher As CFragenSchutzbedarf) As Double
    Dim ok As Boolean
    ok = False
    Dim canCancel As Boolean
    canCancel = IIf(anzahlVerschiebungen = 0, False, True)
    
    Do While ok = False
        Dim questions() As String
        Dim questionIDs() As Long
        Dim hinweis() As String
        Dim answers() As String
        Dim answerIDs() As Long
        Dim werte() As Double
        Dim absoluteWerte() As Boolean
        Dim sprung() As Long
        Dim checklistIDs() As Long  ' Die bleiben hier immer leer
        Dim checklistType() As Long
        Dim i As Integer
        
        Dim numQuestions As Integer
        numQuestions = 1
        
        ReDim questions(numQuestions - 1)
        ReDim questionIDs(numQuestions - 1)
        ReDim hinweis(numQuestions - 1)
        ReDim answers(numQuestions * 4 - 1)
        ReDim answerIDs(numQuestions * 4 - 1)
        ReDim werte(numQuestions * 4 - 1)
        ReDim absoluteWerte(numQuestions * 4 - 1)
        ReDim sprung(numQuestions * 4 - 1)
        ReDim checklistIDs(numQuestions - 1)
        ReDim checklistType(numQuestions - 1)
        
        questions(0) = PrepareLiveQuestionText(GetLocValueFromField(rs, "Frage", "LocFrage", FMT0("STOREUNIT_1")), sb_bisher)
        questionIDs(0) = rs.Fields("FrageID").value
        hinweis(0) = PrepareLiveQuestionText(GetLocValueFromField(rs, "Hinweistext", "LocHinweistext", ""), sb_bisher)
        checklistIDs(0) = GetValueFromField(rs, "CLZuweisungsID", 0)
        checklistType(0) = GetValueFromField(rs, "CLTyp", 0)
        
'        If rs.Fields("Linksbuendig").value = False Then
'            frgmen.Frage.Alignment = vbCenter
'        Else
'            frgmen.Frage.Alignment = vbLeftJustify
'        End If

        Dim ars As Object
        Set ars = CreateObject("ADODB.Recordset")
        ars.Open "SELECT gFragenAntworten.FrageAntwortID, gFragenAntworten.Wert, gFragenAntworten.Sprung, gFragenAntworten.AbsoluterWert, gFragenAntworten.Antwort, ua.LokalisierterText as LocAntwort " & _
        " FROM (gFragenAntworten left join gTexteUebersetzungen ua on (gFragenAntworten.TextID = ua.TextID and ua.LanguageID = " & GetMyDBLanguage(conn) & "))" & _
        " WHERE FrageID = " & rs.Fields("FrageID").value & " ORDER BY Position", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
        i = 0
        Do While Not ars.EOF
            'answers(i) = GetValueFromField(ars, "Antwort", "FEHLENDE ANTWORT!")
            answers(i) = GetLocValueFromField(ars, "Antwort", "LocAntwort", FMT0("STOREUNIT_2"))
            answerIDs(i) = CLng(GetValueFromField(ars, "FrageAntwortID", 0))
            werte(i) = CDbl(GetValueFromField(ars, "Wert", 0))
            sprung(i) = CLng(GetValueFromField(ars, "Sprung", 0))
            absoluteWerte(i) = GetValueFromField(ars, "AbsoluterWert", False)
        
            ars.MoveNext
            i = i + 1
            If i >= 4 Then Exit Do
        Loop
        ars.Close
        Set ars = Nothing
        
        Dim title As String
        'title = ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")" & " - Bitte beantworten Sie die Frage f|fffd|r die Datei..."
        title = ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")" & " - " & FMT0("STOREUNIT_3")
        
        Dim frmFragen As QuestionsDialog
        Set frmFragen = New QuestionsDialog
        frmFragen.SetSingleQuestion conn, title, _
                                    questions, questionIDs, hinweis, answers, werte, _
                                    checklistIDs, checklistType, Dateiname, showBack, anzahlVerschiebungen, answerIDs, PrepareLiveQuestionText(G_PARAM_FragendialogKommentar, sb_bisher)
        frmFragen.Initialize
        If frmFragen.ShowDialog(Nothing) = vbOK Then
        
            If frmFragen.BackWasSelected Then
                NextNr = -100
                DoFrageModal = 0
                antwortID = 0
                AbsoluterWert = False
            Else
                i = frmFragen.GetResultIndex(0)
                
                If i >= 0 And i < 4 Then
                    NextNr = sprung(i)
                    DoFrageModal = werte(i)
                    antwortID = answerIDs(i)
                    AbsoluterWert = absoluteWerte(i)
                End If
            End If
            ok = True
        Else
            ' Die Befragung wurde vom User abgebrochen
            If Not canCancel Then
                'MsgBox "Bitte beantworten Sie die Frage!", vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                MsgBox FMT0("STOREUNIT_4"), vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
            Else
                DoFrageModal = -200#
                ok = True
            End If
        End If
        Unload frmFragen
        Set frmFragen = Nothing
    Loop

End Function

Function AddNewFragenDlg(ByRef frgdlgcol As Collection, nr As String, ByRef sb_bisher As CFragenSchutzbedarf) As CFragenDlg
  ' Wenn es vorher schon einen Dialog gab, die Schutzbedarfswerte von dort holen
  If frgdlgcol.count > 0 Then
    Dim lastDlg As CFragenDlg
    Set lastDlg = frgdlgcol(frgdlgcol.count)
    Call sb_bisher.Assign(lastDlg.m_Schutzbed)
    Set lastDlg = Nothing
  End If
  
  Dim frgDlg As CFragenDlg
  Set frgDlg = New CFragenDlg
  frgDlg.m_FragenNr = nr
  Call frgDlg.m_Schutzbed.Assign(sb_bisher)
  frgdlgcol.add frgDlg, nr
  Set AddNewFragenDlg = frgDlg
End Function

Function CreateFragen2(sharename As String, ByRef officeapp As Object, ByRef frgdlgcol As Collection, ByRef conn As Object, _
                        ByRef dateiRS As Object, anzahlVerschiebungen As Long) As Double
    Dim dateiid As Long
    dateiid = GetSafeFieldPlus(dateiRS, "idvDateiID", 0)
    
    Dim frgDlg As CFragenDlg
    Dim rs As Object
    Dim answerrs As Object
    Set G_SelectedProzesse = New Collection
    Set rs = CreateObject("ADODB.Recordset")
    rs.Open "SELECT gFragen.FrageID, gFragen.Nr, gFragen.Frage, gFragen.Hinweistext, gFragen.Linksbuendig, gFragen.CLZuweisungsID," & _
    " gFragen.CLTyp, gFragen.NaechsteFragenGruppenNr, gFragen.Vorauswahl," & _
    " uf.LokalisierterText as LocFrage, uh.LokalisierterText as LocHinweistext " & _
    " FROM ((gFragen left join gTexteUebersetzungen uf on (gFragen.TextID = uf.TextID and uf.LanguageID = " & GetMyDBLanguage(conn) & ")) " & _
    " left join gTexteUebersetzungen uh on (uh.TextID = gFragen.HinweistextTextID and uh.LanguageID = " & GetMyDBLanguage(conn) & " )) " & _
    " ORDER BY Nr", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly

    DebugPrint DebType.tdebug, "CreateFragen 1"

    Dim nr As Long
    nr = 0
    Dim ergebnis As Double
    ergebnis = 0
    
    Dim vals(15) As Double
    Dim valsAbsolut(15) As Boolean
    Dim nrs(15) As Long
    
    Dim showBack As Boolean
    Dim backcnt As Long
    backcnt = 0
    
    DebugPrint DebType.tdebug, "CreateFragen 2"
    
    Set ChecklistenFragenAntworten = New Collection
    
    ' Neu 1.2017:
    ' Bereits existierende Werte global speichern, falls die Datei schon einmal befragt wurde
    Set G_Befragung = New CBefragung
    Call G_Befragung.Init(dateiRS, rs, conn)

lastQuestion:
    
    Do While Not rs.EOF
        If nr > 0 Then
            rs.MoveFirst
            rs.Find "nr = " & nr
            If rs.EOF Then
                'MsgBox "Fehler: Es wird in den Fragen auf Nummer " & nr & " verwiesen. Diese Nummer existiert nicht! Bitte informieren Sie den " & ProgNameLong & "-Administrator.", vbCritical + vbSystemModal, , ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                MsgBox FMT2("STOREUNIT_5", nr, ProgNameLong), vbCritical + vbSystemModal, , ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                CreateFragen2 = -1
                rs.Close
                Exit Function
            End If
        End If
        
        ' Wenn es den Fragendialog schon gibt, dann raus
        If CollectionObjectExists(frgdlgcol, GetValueFromField(rs, "Nr", 0)) Then
          rs.Close
          Exit Function
        End If

        ' Der Schutzbedarf bis jetzt (also das was im Dialog vorher rauskam)
        Dim sb_bisher As New CFragenSchutzbedarf
        Set frgDlg = AddNewFragenDlg(frgdlgcol, GetValueFromField(rs, "Nr", 0), sb_bisher)
        
        If backcnt < G_PARAM_FragenZurueck And frgdlgcol.count > 1 Then
          showBack = True
        Else
          showBack = False
        End If

        If GetValueFromField(rs, "Frage", "") = "[PROZESSAUSWAHL]" Then
          If frmProzessauswahl.Init(conn, dateiid, showBack) Then
              frmProzessauswahl.Show vbModal
              frgDlg.m_IsPA = True
              
              ' Wenn Prozesse selektiert wurden muss gerechnet werden UND die n|fffd|chste Frage ermittelt werden
              If frmProzessauswahl.m_Auswahl = 1 Then
                Call frgDlg.AddAntwort(PA_ANTWORT_SEL, 0, False)
                Call frgDlg.m_Schutzbed.Assign(G_Befragung.ProzessauswahlValues)
              
                Set answerrs = CreateObject("ADODB.Recordset")
                answerrs.Open "SELECT * FROM gFragenAntworten WHERE FrageID = " & rs!frageID & " ORDER BY Position", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
                If Not answerrs.EOF Then
                  nr = GetValueFromField(answerrs, "Sprung", 0)
                  If nr = -1 Or nr = -2 Then
                    Exit Do
                  Else
                    rs.MoveNext
                    ' nr = 0
                  End If
                Else
                  rs.MoveNext
                  nr = 0
                End If
                answerrs.Close
                Set answerrs = Nothing
                
                If backcnt > 0 Then backcnt = backcnt - 1
              ElseIf frmProzessauswahl.m_Auswahl = -1 Then
                ' Frage zurueck Button
                If frgdlgcol.count > 1 Then
                  frgdlgcol.Remove frgdlgcol.count
                  nr = frgdlgcol(frgdlgcol.count).m_FragenNr
                  frgdlgcol.Remove frgdlgcol.count
                  backcnt = backcnt + 1
                End If
              Else
                Call frgDlg.AddAntwort(PA_ANTWORT_NONE, 0, False)
                
                ' So behandeln als waere die zweite Antwort gewaehlt worden
                Set answerrs = CreateObject("ADODB.Recordset")
                answerrs.Open "SELECT * FROM gFragenAntworten WHERE FrageID = " & rs!frageID & " ORDER BY Position", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
                If Not answerrs.EOF Then
                  answerrs.MoveNext
                  If Not answerrs.EOF Then
                    nr = GetValueFromField(answerrs, "Sprung", 0)
                    If nr = -1 Or nr = -2 Then
                      Exit Do
                    Else
                      rs.MoveNext
                      ' nr = 0
                    End If
                  Else
                    rs.MoveNext
                    nr = 0
                  End If
                Else
                  rs.MoveNext
                  nr = 0
                End If
                answerrs.Close
                Set answerrs = Nothing
                
                If backcnt > 0 Then backcnt = backcnt - 1
              End If
          Else
            rs.MoveNext
            nr = 0
          End If
        Else

                    Dim antwortID As Long
                    Dim AbsoluterWert As Boolean
                    
                    Dim shname As String
                    shname = sharename
                    If Len(shname) > 160 Then
                        shname = Left(shname, 50) + "[...]" + Right(shname, 105)
                    End If
                    
                    ' Check if we have a group of questions
                    Dim fragenGruppe As Collection
                    Set fragenGruppe = New Collection
                    If CollectFragenGroup(rs, fragenGruppe) > 0 Then
                        ' Collect all questions and answers for this group
                        Dim questions() As String
                        Dim questionIDs() As Long
                        Dim hinweis() As String
                        Dim answers() As String
                        Dim checklistIDs() As Long
                        Dim checklistType() As Long
                        Dim answerIDs() As Long
                        Dim werte() As Double
                        Dim numQuestions As Integer
                        numQuestions = fragenGruppe.count
                        ReDim questions(numQuestions - 1)
                        ReDim questionIDs(numQuestions - 1)
                        ReDim hinweis(numQuestions - 1)
                        ReDim checklistIDs(numQuestions - 1)
                        ReDim checklistType(numQuestions - 1)
                        ReDim answers(numQuestions * 4 - 1)
                        ReDim answerIDs(numQuestions * 4 - 1)
                        ReDim werte(numQuestions * 4 - 1)
                        Dim v As String
                        
                        Dim idx As Integer
                        For idx = 0 To fragenGruppe.count - 1
                          v = fragenGruppe(idx + 1)
                          rs.MoveFirst
                          rs.Find "nr = " & v
                          questions(idx) = PrepareLiveQuestionText(GetLocValueFromField(rs, "Frage", "LocFrage", FMT0("STOREUNIT_1")), sb_bisher)
                          questionIDs(idx) = GetSafeFieldPlus(rs, "FrageID", 0)
                          checklistType(idx) = GetSafeFieldPlus(rs, "CLTyp", 0)
                          hinweis(idx) = PrepareLiveQuestionText(GetLocValueFromField(rs, "Hinweistext", "LocHinweistext", ""), sb_bisher)
                          checklistIDs(idx) = -1
                          If Not IsNull(rs!CLZuweisungsID) Then
                            checklistIDs(idx) = rs!CLZuweisungsID
                          End If
                          
                          Set answerrs = CreateObject("ADODB.Recordset")
                          answerrs.Open "SELECT gFA.wert, gFA.FrageAntwortID, ua.LokalisierterText as LocAntwort FROM gFragenAntworten gFA left join gTexteUebersetzungen ua on (gFA.TextID = ua.TextID and ua.LanguageID = " & GetMyDBLanguage(conn) & ") " & _
                          " WHERE FrageID = " & rs!frageID & " ORDER BY Position", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
                          answerrs.MoveLast
                          Dim numAnswers As Integer
                          numAnswers = IIf(answerrs.RecordCount < 4, answerrs.RecordCount, 4)
                          answerrs.MoveFirst
                          Dim i As Integer
                          For i = 0 To numAnswers - 1
                            answers(idx * 4 + i) = GetLocValueFromField(answerrs, "Antwort", "LocAntwort", "")
                            werte(idx * 4 + i) = answerrs!wert
                            answerIDs(idx * 4 + i) = answerrs!FrageAntwortID
                            answerrs.MoveNext
                          Next
                          answerrs.Close
                          Set answerrs = Nothing
                        Next
                        ' Show the group questions dialog
                        Dim wasBack As Boolean
                        wasBack = False
                        
                        Dim frmQuestions As QuestionsDialog
                        Set frmQuestions = New QuestionsDialog
                        frmQuestions.SingleSelect = True
                        'frmQuestions.SetQuestionsGroup conn, "Befragung", questions, questionIDs, hinweis, answers, werte, checklistIDs, checklistType, shname, showBack, anzahlVerschiebungen
                        frmQuestions.SetQuestionsGroup conn, FMT0("STOREUNIT_6"), questions, questionIDs, hinweis, answers, werte, checklistIDs, checklistType, shname, showBack, anzahlVerschiebungen, answerIDs, PrepareLiveQuestionText(G_PARAM_FragendialogKommentar, sb_bisher)
                        frmQuestions.Initialize
                        If (frmQuestions.ShowDialog(Nothing)) = vbOK Then
                            ' Jetzt die vals zuweisen
                            wasBack = frmQuestions.BackWasSelected
                            If Not wasBack Then
                                For i = 0 To fragenGruppe.count - 1
                                    Dim answerID As Long
                                    idx = frmQuestions.GetResultIndex(i)
                                    If idx >= 0 Then
                                        v = fragenGruppe(i + 1)
                                        rs.MoveFirst
                                        rs.Find "nr = " & v
                                        answerID = answerIDs(i * 4 + idx)
                                        Set answerrs = CreateObject("ADODB.Recordset")
                                        answerrs.Open "SELECT * FROM gFragenAntworten WHERE FrageID = " & rs!frageID & " ORDER BY Position", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
                                        answerrs.Find "FrageAntwortID = " & answerID
                                        frgDlg.AddAntwort answerID, answerrs!wert, answerrs!AbsoluterWert
                                        answerrs.Close
                                        Set answerrs = Nothing
                                    Else
                                        ' Der Dialog darf nicht mit einer unbeantworteten Frage beendet werden -> alles abbrechen
                                        Unload frmQuestions
                                        'CreateFragen2 = -1
                                        ' Ab jetzt darf der Dialog bei einer freiwillig initiierten Befragung beendet werden, dann gehen wir mit -200 raus,
                                        ' was den Abbruch im caller signalisiert.
                                        CreateFragen2 = -200
                                        rs.Close
                                        Exit Function
                                    End If
                                Next
                                ' Schutzbedarfswerte updaten
                                Call G_Befragung.UpdateSchutzbedarf(frgDlg)
                            End If
                        Else
                            ' So duerfen wir nicht raus aus dem Gruppenfragendialog -> alles abbrechen
                            Unload frmQuestions
                            CreateFragen2 = -200
                            rs.Close
                            Exit Function
                        End If
                        Unload frmQuestions
                        If wasBack Then
                            If frgdlgcol.count > 0 Then
                              frgdlgcol.Remove frgdlgcol.count
                              nr = frgdlgcol(frgdlgcol.count).m_FragenNr
                              frgdlgcol.Remove frgdlgcol.count
                              backcnt = backcnt + 1
                            End If
                        Else
                            ' Einfach mit dem Nachfolger der letzen Gruppenfrage weitermachen
                            rs.MoveNext
                            If Not rs.EOF Then
                                nr = GetSafeFieldPlus(rs, "Nr", -1)
                            End If
                            
                            If backcnt > 0 Then backcnt = backcnt - 1
                            If nr = -1 Or nr = -2 Then Exit Do
                            If GetTotalErgebnis(frgdlgcol) >= 1 And G_PARAM_Bei100ProzentFragenFortsetzen = False Then Exit Do
                        End If
                    Else
                        ' Einzelfrage
            
                        ergebnis = DoFrageModal(dateiRS, shname, officeapp, 0, rs, nr, antwortID, conn, showBack, AbsoluterWert, anzahlVerschiebungen, sb_bisher)
                        
                        ' Test wenn Abbrechen gedrueckt wurde
                        If ergebnis <= -200# Then
                            CreateFragen2 = -200
                            rs.Close
                            Exit Function
                        End If
                        
                        If nr = -100 Then
                            ' fragencnt = fragencnt - 1
                            ' nr = nrs(fragencnt)
                            If frgdlgcol.count > 0 Then
                              frgdlgcol.Remove frgdlgcol.count
                              nr = frgdlgcol(frgdlgcol.count).m_FragenNr
                              frgdlgcol.Remove frgdlgcol.count
                              backcnt = backcnt + 1
                            End If
                        Else
                            frgDlg.AddAntwort antwortID, ergebnis, AbsoluterWert
                            Call G_Befragung.UpdateSchutzbedarf(frgDlg)
                            
                            If backcnt > 0 Then backcnt = backcnt - 1
                            If nr = -1 Or nr = -2 Then Exit Do
                            If GetTotalErgebnis(frgdlgcol) >= 1 And G_PARAM_Bei100ProzentFragenFortsetzen = False Then Exit Do
                            rs.MoveNext
                        End If
                    End If
        End If
    Loop
    
    CreateFragen2 = IIf(GetTotalErgebnis(frgdlgcol) > 1#, 1#, GetTotalErgebnis(frgdlgcol))
    
    If G_PARAM_FragenAbschlussInfo Then
        Load frmFragenEnde
      If backcnt < G_PARAM_FragenZurueck Then
        frmFragenEnde.cmdBack.visible = True
      Else
        frmFragenEnde.cmdBack.visible = False
      End If
      ' TODO frmFragenEnde.AdjustControls risikoklassentext, IIf(backcnt < G_PARAM_FragenZurueck, True, False)
      
      'frmFragenEnde.Caption = ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")" & " - Vielen Dank f|fffd|r die Beantwortung der Fragen."
      frmFragenEnde.Caption = ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")" & " - " & FMT0("STOREUNIT_7")
      frmFragenEnde.Show vbModal
      
      Dim goAgain As Boolean
      goAgain = frmFragenEnde.goAgain
      Unload frmFragenEnde
      
      If goAgain = True Then
          rs.MoveFirst
          
          If frgdlgcol.count > 0 Then
            nr = frgdlgcol(frgdlgcol.count).m_FragenNr
            frgdlgcol.Remove frgdlgcol.count
            backcnt = backcnt + 1
          End If
          GoTo lastQuestion
      End If
      
    End If
    
    DebugPrint DebType.tdebug, "CreateFragen 3"

    rs.Close
    Set rs = Nothing
    
    ' Checklistenantworten speichern
    ' Sicherstellen, dass wir hier nicht rausspringen, sonst ist die Datei nicht richtig in der DB
    On Error GoTo skip
    ' Erstmal alle CL-Antworten fuer diese Datei loeschen
    conn.Execute "DELETE FROM idvDateienCLAntworten WHERE idvdateiid = " & dateiid
    ' Nun jede Antwort neu hinzufuegen
    If ChecklistenFragenAntworten.count > 0 Then
      For i = 0 To ChecklistenFragenAntworten.count - 1
          Dim item As String
          Dim kv() As String
          item = ChecklistenFragenAntworten(i + 1)
          kv = Split(item, "_", 3)
          If UBound(kv) >= 2 Then
              conn.Execute "INSERT INTO idvDateienCLAntworten (idvdateiid, fragenid, clantwortid) VALUES (" & dateiid & ", " & kv(0) & ", " & kv(2) & ")"
          End If
      Next
    End If
    
skip:
    On Error GoTo 0
    Set ChecklistenFragenAntworten = Nothing
    
    DebugPrint DebType.tdebug, "CreateFragen 4"
    CreateFragen2 = IIf(GetTotalErgebnis(frgdlgcol) > 1#, 1#, GetTotalErgebnis(frgdlgcol))
    ' wenn nr -2 ist, dann das Ergebnis auch auf -20000% setzen (kam von Rolf, weil ich den Issue falsch beschrieben habe, ist aber hier auch ok :), nutze nur -200
    CreateFragen2 = IIf(nr = -2, -200#, CreateFragen2)
    DebugPrint DebType.tdebug, "CreateFragen 5"

End Function

Public Function PrepareQuestionText(ByRef dateiRS As Object, ByVal dbText As String) As String
  Dim mytext As String
  mytext = dbText
  
  Dim schutz As Long
  Dim verfueg As Long
  Dim integ As Long
  Dim vertr As Long
  Dim infok As Long
  Dim authen As Long
  schutz = GetSafeFieldPlus(dateiRS, "Schutzbedarf", 0)
  verfueg = GetSafeFieldPlus(dateiRS, "Verfuegbarkeit", 0)
  integ = GetSafeFieldPlus(dateiRS, "Integritaet", 0)
  vertr = GetSafeFieldPlus(dateiRS, "Vertraulichkeit", 0)
  infok = GetSafeFieldPlus(dateiRS, "Informationsklassifizierung", 0)
  authen = GetSafeFieldPlus(dateiRS, "Authentizitaet", 0)
  
  If Not G_Befragung Is Nothing Then
    ' Wenn es Werte > 0 aus der Prozessauswahl gibt, dann die nehmen!
    verfueg = IIf(G_Befragung.ProzessauswahlValues.value(C_IDVDATFLD_VERFUEGBARKEIT) > 0, G_Befragung.ProzessauswahlValues.value(C_IDVDATFLD_VERFUEGBARKEIT), verfueg)
    integ = IIf(G_Befragung.ProzessauswahlValues.value(C_IDVDATFLD_INTEGRITAET) > 0, G_Befragung.ProzessauswahlValues.value(C_IDVDATFLD_INTEGRITAET), integ)
    vertr = IIf(G_Befragung.ProzessauswahlValues.value(C_IDVDATFLD_VERTRAULICHKEIT) > 0, G_Befragung.ProzessauswahlValues.value(C_IDVDATFLD_VERTRAULICHKEIT), vertr)
     authen = IIf(G_Befragung.ProzessauswahlValues.value(C_IDVDATFLD_AUTHENTIZITAET) > 0, G_Befragung.ProzessauswahlValues.value(C_IDVDATFLD_AUTHENTIZITAET), authen)
  End If
  
  mytext = Replace(mytext, "#SCHUTZBEDARF#", GetSchutzbedarfTextFromLong(schutz, "Schutzbedarf"))
  mytext = Replace(mytext, "#VERFUEGBARKEIT#", GetSchutzbedarfTextFromLong(verfueg, "Verfuegbarkeit"))
  mytext = Replace(mytext, "#INTEGRITAET#", GetSchutzbedarfTextFromLong(integ, "Integritaet"))
  mytext = Replace(mytext, "#VERTRAULICHKEIT#", GetSchutzbedarfTextFromLong(vertr, "Vertraulichkeit"))
  mytext = Replace(mytext, "#AUTHENTIZITAET#", GetSchutzbedarfTextFromLong(authen, "Authentizitaet"))
  mytext = Replace(mytext, "#INFORMATIONSKLASSIFIZIERUNG#", GetInfklasseTextFromLong(infok, "Informationsklassifizierung"))
  
  mytext = Replace(mytext, "#SCHUTZBEDARFPROZESSE#", GetSchutzbedarfTextFromLong(GetSafeFieldPlus(dateiRS, "SchutzbedarfProzesse", 0), "Schutzbedarf"))
  mytext = Replace(mytext, "#VERFUEGBARKEITPROZESSE#", GetSchutzbedarfTextFromLong(GetSafeFieldPlus(dateiRS, "VerfuegbarkeitProzesse", 0), "Verfuegbarkeit"))
  mytext = Replace(mytext, "#INTEGRITAETPROZESSE#", GetSchutzbedarfTextFromLong(GetSafeFieldPlus(dateiRS, "IntegritaetProzesse", 0), "Integritaet"))
  mytext = Replace(mytext, "#VERTRAULICHKEITPROZESSE#", GetSchutzbedarfTextFromLong(GetSafeFieldPlus(dateiRS, "VertraulichkeitProzesse", 0), "Vertraulichkeit"))
  mytext = Replace(mytext, "#AUTHENTIZITAETPROZESSE#", GetSchutzbedarfTextFromLong(GetSafeFieldPlus(dateiRS, "AuthentizitaetProzesse", 0), "Authentizitaet"))
  mytext = Replace(mytext, "#INFORMATIONSKLASSIFIZIERUNGPROZESSE#", GetInfklasseTextFromLong(GetSafeFieldPlus(dateiRS, "InformationsklassifizierungPr", 0), "Informationsklassifizierung"))
  
  PrepareQuestionText = mytext
End Function

Public Function PrepareLiveQuestionText(ByVal dbText As String, schutzbed As CFragenSchutzbedarf) As String
  Dim schutz As Long
  Dim verfueg As Long
  Dim integ As Long
  Dim vertr As Long
  Dim infok As Long
  Dim authen As Long
  schutz = schutzbed.value(C_IDVDATFLD_SCHUTZBEDARF)
  verfueg = schutzbed.value(C_IDVDATFLD_VERFUEGBARKEIT)
  integ = schutzbed.value(C_IDVDATFLD_INTEGRITAET)
  vertr = schutzbed.value(C_IDVDATFLD_VERTRAULICHKEIT)
  infok = schutzbed.value(C_IDVDATFLD_INFORMATIONSKLASSE)
  authen = schutzbed.value(C_IDVDATFLD_AUTHENTIZITAET)
  
  dbText = Replace(dbText, "#SCHUTZBEDARF#", GetSchutzbedarfTextFromLong(schutz, "Schutzbedarf"))
  dbText = Replace(dbText, "#VERFUEGBARKEIT#", GetSchutzbedarfTextFromLong(verfueg, "Verfuegbarkeit"))
  dbText = Replace(dbText, "#INTEGRITAET#", GetSchutzbedarfTextFromLong(integ, "Integritaet"))
  dbText = Replace(dbText, "#VERTRAULICHKEIT#", GetSchutzbedarfTextFromLong(vertr, "Vertraulichkeit"))
  dbText = Replace(dbText, "#INFORMATIONSKLASSIFIZIERUNG#", GetInfklasseTextFromLong(infok, "Informationsklassifizierung"))
  dbText = Replace(dbText, "#AUTHENTIZITAET#", GetSchutzbedarfTextFromLong(authen, "Authentizitaet"))
    
  PrepareLiveQuestionText = dbText
End Function

Function GetTotalErgebnis(ByRef frgdlgcol As Collection)
  GetTotalErgebnis = 0
  Dim i As Long
  Dim frgDlg As CFragenDlg
  Dim ant As CAntwort
  
  For Each frgDlg In frgdlgcol
    For Each ant In frgDlg.m_Antworten
      If G_PARAM_Risikoberechnungsmethode = "1" Then
        If GetTotalErgebnis < ant.m_Wert Then
          GetTotalErgebnis = ant.m_Wert
        End If
      ElseIf G_PARAM_Risikoberechnungsmethode = "0" Then
        GetTotalErgebnis = GetTotalErgebnis + ant.m_Wert
      Else
        If ant.m_Absolut Then
          GetTotalErgebnis = ant.m_Wert
        Else
          GetTotalErgebnis = GetTotalErgebnis + ant.m_Wert
        End If
      End If
    Next ant
  Next frgDlg
End Function

Function FrageAnzeigen(ByRef officeapp As Object, ByRef frgmen As Object, objtyp As Long, ByVal rs As Object, ByRef NextNr As Long, ByRef antwortID As Long, ByRef conn As Object, showBack As Boolean, ByRef AbsoluterWert As Boolean) As Double

'    Dim fragen As New frmFragen2
'    Load fragen

'     Debug.Print TwipsToPixelsX(frmFragen2.Frage.Height)
'     Debug.Print TwipsToPixelsX(frmFragen2.Antwort1.Top)
'     Debug.Print TwipsToPixelsX(frmFragen2.Height)
    Dim Dateiname As String
    Dateiname = frgmen.Dateiname.Caption

    Do
        ' Eine gesetzte Muss-Checklisten wird alle Antwortbuttons disablen. Estmal alle enablen
        frgmen.Antwort1.Enabled = True
        frgmen.Antwort2.Enabled = True
        frgmen.Antwort3.Enabled = True
        frgmen.Antwort4.Enabled = True
        frgmen.Antwort5.Enabled = True
        frgmen.Antwort6.Enabled = True
        frgmen.Antwort7.Enabled = True
        
        'frgmen.Caption = ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")" & " - Bitte beantworten Sie die Frage f|fffd|r die Datei..."
        frgmen.Caption = ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")" & " - " & FMT0("STOREUNIT_3")
        frgmen.Dateiname.Caption = Dateiname
        
        If LCase(Left(rs!Frage, 5)) = "{\rtf" Then
          'frgmen.Frage.defTextRTF = GetValueFromField(rs, "Frage", "FEHLENDE FRAGE!!!")
          frgmen.Frage.defTextRTF = GetValueFromField(rs, "Frage", FMT0("STOREUNIT_1"))
          ' rs.Fields("Frage").Value
        
        Else
          'frgmen.Frage.Caption = GetValueFromField(rs, "Frage", "FEHLENDE FRAGE!!!")
          frgmen.Frage.Caption = GetValueFromField(rs, "Frage", FMT0("STOREUNIT_1"))
          
'          frgmen.Frage.Caption = "Langer Text" & vbCrLf & "Langer Text" & vbCrLf & "Langer Text" & vbCrLf & "1234567890123456789012345678901234567890123456789012345678901234" & vbCrLf & "Langer Text" & vbCrLf & "Langer Text" & vbCrLf & "Langer Text" & vbCrLf & "Langer Text"
          
          
          If rs.Fields("Linksbuendig").value = False Then
            'frgmen.Frage.Alignment = vbCenter
            frgmen.Frage.TextAlign = fmTextAlignCenter
          Else
            'frgmen.Frage.Alignment = vbLeftJustify
            frgmen.Frage.TextAlign = fmTextAlignLeft
          End If
        
            ' Und die H|fffd|hen anpassen
    ' Const C_Fragen_Zeilenh|fffd|he As Long = 24
    ' Const C_Fragen_Max_Zeichen_pro_Zeile As Long = 84
    ' Const C_Fragen_Antwort_Y As Long = 128
    ' Const C_Fragen_H|fffd|he As Long = 211
            
            Dim rc As Long
            rc = 1
            Dim x As Long
            Dim i As Long
            If Len(frgmen.Frage.Caption) > 0 Then
              For i = 1 To Len(frgmen.Frage.Caption)
                If Mid(frgmen.Frage.Caption, i, 1) = vbCr Then
                  rc = rc + 1
                  x = 1
                Else
                  x = x + 1
                  If x > C_Fragen_Max_Zeichen_pro_Zeile Then
                    rc = rc + 1
                    x = 1
                  End If
                End If
              Next i
            End If
            
            Dim hasChecklist As Boolean
            hasChecklist = (GetValueFromField(rs, "CLZuweisungsID", 0) > 0) And (GetValueFromField(rs, "CLTyp", 0) > 0)
            
            Dim yfragen As Long
            Dim h|fffd|he As Long
            If rc * C_Fragen_Zeilenh|fffd|he < C_Fragen_HoeheFragen Then
              yfragen = PixelsToTwipsY(C_Fragen_Antwort_Y)
              h|fffd|he = IIf(showBack = True Or frgmen.Hinweistext <> "" Or hasChecklist = True, PixelsToTwipsY(C_Fragen_H|fffd|he), PixelsToTwipsY(C_Fragen_H|fffd|heNoBack))
            Else
                Dim addHoehe As Long
                addHoehe = rc * C_Fragen_Zeilenh|fffd|he - C_Fragen_HoeheFragen
              yfragen = PixelsToTwipsY(C_Fragen_Antwort_Y + addHoehe)
              h|fffd|he = PixelsToTwipsY(IIf(showBack = True Or frgmen.Hinweistext <> "" Or hasChecklist = True, C_Fragen_H|fffd|he, C_Fragen_H|fffd|heNoBack) + addHoehe)
            End If
            
            frgmen.Frage.Height = PixelsToTwipsY(rc * C_Fragen_Zeilenh|fffd|he)
            frgmen.Height = h|fffd|he
            frgmen.cmdBack.Top = yfragen + PixelsToTwipsY(C_Fragen_Zeilenh|fffd|he + 12)
            frgmen.hinweis.Top = yfragen + PixelsToTwipsY(C_Fragen_Zeilenh|fffd|he + 12)
            frgmen.BtCheckliste.Top = yfragen + PixelsToTwipsY(C_Fragen_Zeilenh|fffd|he + 12)

            frgmen.Antwort1.Top = yfragen
            frgmen.Antwort2.Top = yfragen
            frgmen.Antwort3.Top = yfragen
            frgmen.Antwort4.Top = yfragen
            frgmen.Antwort5.Top = yfragen
            frgmen.Antwort6.Top = yfragen
            frgmen.Antwort7.Top = yfragen
        End If

        ' So, jetzt f|fffd|r jede Antwort etwas erzeugen
        Dim answercnt As Long
        answercnt = 0
        Dim s As String
        Dim v As String
        Dim tval As Long
        tval = 0

        Dim ans(4) As String
        Dim anstag(4) As String

        Dim ars As Object
        Set ars = CreateObject("ADODB.Recordset")
        ars.Open "SELECT *, u.LokalisierterText as LocAntwort FROM (gFragenAntworten left join gTexteUebersetzungen u on (u.TextID = gFragenAntworten.TextID and u.LanguageID = " & GetMyDBLanguage(conn) & " )) " & _
        " WHERE FrageID = " & rs.Fields("FrageID").value & " ORDER BY Position", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
        Do While Not ars.EOF
            'ans(answercnt + 1) = GetValueFromField(ars, "Antwort", "FEHLENDE ANTWORT!")
            ans(answercnt + 1) = GetLocValueFromField(ars, "Antwort", "LocAntwort", FMT0("STOREUNIT_2"))
            anstag(answercnt + 1) = CStr(GetValueFromField(ars, "Wert", 0))
            anstag(answercnt + 1) = anstag(answercnt + 1) & ";" & CLng(GetValueFromField(ars, "Sprung", 0))
            anstag(answercnt + 1) = anstag(answercnt + 1) & ";" & CLng(ars.Fields("FrageAntwortID").value)
            anstag(answercnt + 1) = anstag(answercnt + 1) & ";" & CLng(ars.Fields("AbsoluterWert").value)
            answercnt = answercnt + 1
            If answercnt = 4 Then Exit Do
            ars.MoveNext
        Loop
        ars.Close
        Set ars = Nothing

        If answercnt = 2 Then
            frgmen.Antwort1.visible = False

            frgmen.Antwort2.Caption = ans(1)
            frgmen.Antwort2.tag = anstag(1)
            frgmen.Antwort2.visible = True

            frgmen.Antwort3.Caption = ans(2)
            frgmen.Antwort3.tag = anstag(2)
            frgmen.Antwort3.visible = True

            frgmen.Antwort4.visible = False
            frgmen.Antwort5.visible = False
            frgmen.Antwort6.visible = False
            frgmen.Antwort7.visible = False

        ElseIf answercnt = 3 Then

            frgmen.Antwort1.visible = False
            frgmen.Antwort2.visible = False
            frgmen.Antwort3.visible = False
            frgmen.Antwort4.visible = False

            frgmen.Antwort5.Caption = ans(1)
            frgmen.Antwort5.tag = anstag(1)
            frgmen.Antwort5.visible = True

            frgmen.Antwort6.Caption = ans(2)
            frgmen.Antwort6.tag = anstag(2)
            frgmen.Antwort6.visible = True

            frgmen.Antwort7.Caption = ans(3)
            frgmen.Antwort7.tag = anstag(3)
            frgmen.Antwort7.visible = True

        Else

            frgmen.Antwort1.Caption = ans(1)
            frgmen.Antwort1.tag = anstag(1)
            frgmen.Antwort1.visible = True

            frgmen.Antwort2.Caption = ans(2)
            frgmen.Antwort2.tag = anstag(2)
            frgmen.Antwort2.visible = True

            frgmen.Antwort3.Caption = ans(3)
            frgmen.Antwort3.tag = anstag(3)
            frgmen.Antwort3.visible = True

            frgmen.Antwort4.Caption = ans(4)
            frgmen.Antwort4.tag = anstag(4)
            frgmen.Antwort4.visible = True

            frgmen.Antwort5.visible = False
            frgmen.Antwort6.visible = False
            frgmen.Antwort7.visible = False

        End If
        ' Eine eventuell vorhandene Checkliste zuweisen
        frgmen.SetChecklist rs.Fields("FrageID").value, GetValueFromField(rs, "CLZuweisungsID", 0), GetValueFromField(rs, "CLTyp", 0), conn

        frgmen.SpeichernGeclickt = False
        
        ' gibt es nicht in Excel
        ' frgmen.ZOrder 0
        
        frgmen.cmdBack.visible = showBack
        
        OfficeAppDisplayAlerts officeapp, False
        frgmen.Show vbModal
        OfficeAppDisplayAlerts officeapp, True

        If frgmen.SpeichernGeclickt Then
            NextNr = frgmen.NextNr
            FrageAnzeigen = frgmen.answerVal
            antwortID = frgmen.answerID
            AbsoluterWert = frgmen.AbsoluterWert
            Exit Do
        Else
            'MsgBox "Bitte beantworten Sie die Frage!", vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
            MsgBox FMT0("STOREUNIT_4"), vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        End If


    Loop

'    Unload fragen
'    Set fragen = Nothing

End Function


Function CheckVBAAccessAllowed(ByVal wbInExcelCurrentProjectInAccess As Object) As Boolean

#If PROJECT_ACCESSTRACKER = 0 Then
    CheckVBAAccessAllowed = True
    On Error GoTo noVBA
    If wbInExcelCurrentProjectInAccess.VBProject.Protection = 1 Then ' vbext_pp_locked
    End If
    Exit Function
noVBA:
    CheckVBAAccessAllowed = False
#Else
    CheckVBAAccessAllowed = False
    On Error GoTo noVBA
    Dim vbp
    For Each vbp In vbe.VBProjects
      If UCase(vbp.filename) = UCase(wbInExcelCurrentProjectInAccess.fullname) Then
        If vbp.Protection = 0 Then
          CheckVBAAccessAllowed = True
          Exit Function
        End If
      End If
    Next vbp
    Exit Function
noVBA:
#End If
End Function


Sub SaveDocInfoStuff(ByVal wbInExcelCurrentProjectInAccess As Object)

    Set G_DocInfo = New DocInfo
    
    If FileExists(wbInExcelCurrentProjectInAccess.fullname) Then
      G_DocInfo.m_FileSizeInKB = MyFileLen(wbInExcelCurrentProjectInAccess.fullname) / 1024
      If G_PARAM_FormelnNichtZaehlenAbKB = -1 Then
        G_DocInfo.m_NoFormulaCount = False
      Else
        G_DocInfo.m_NoFormulaCount = IIf(G_DocInfo.m_FileSizeInKB >= G_PARAM_FormelnNichtZaehlenAbKB, True, False)
      End If
    Else
      G_DocInfo.m_FileSizeInKB = 0
      G_DocInfo.m_NoFormulaCount = False
    End If

#If PROJECT_ACCESSTRACKER = 0 Then
    ' Und jetzt die Fragen aus der Config holen
    '  Dim fragen As Collection
    '  If Not cfgr.GetSectionValues("Risikofragen", fragen) Then
    '    MsgBox "In der Konfig Datei '" & ThisWorkbook.path & "\accesstracker.cfg' fehlt die Sektion [Risikofragen]!", vbCritical
    '    Exit Sub
    '  End If

    G_DocInfo.m_Sheets = wbInExcelCurrentProjectInAccess.Sheets.count

    Dim ws As Excel.Worksheet
    Dim formam As Long
    formam = 0
    Dim protectedsheets As Long
    protectedsheets = 0
    Dim unprotectedsheetswithformulas As Long
    unprotectedsheetswithformulas = 0
    Dim unprotectedformulas As Long
    unprotectedformulas = 0
    
    Dim hadProtectedSheets As Boolean
    hadProtectedSheets = False
    
    
    ' XXX nur bei Datei 040598v.xls
    On Error Resume Next
    For Each ws In wbInExcelCurrentProjectInAccess.Sheets
        
        Dim tformam As Long

        If ws.ProtectContents = False Then
          If Not G_DocInfo.m_NoFormulaCount Then
            Dim formelRange As Excel.Range
            Set formelRange = GetFormulaRange(ws)
            If Not formelRange Is Nothing Then
                tformam = formelRange.count
                Set formelRange = Nothing
            Else
                tformam = 0
            End If
          End If
        Else
          tformam = 0
          hadProtectedSheets = True
'          tformam = GetProtFormulasCount(ws)
        End If
        formam = formam + tformam
        If ws.ProtectContents = True Then
            protectedsheets = protectedsheets + 1
        Else
            If tformam > 0 Then
                unprotectedsheetswithformulas = unprotectedsheetswithformulas + 1
                unprotectedformulas = unprotectedformulas + tformam
            End If
        End If
        
    Next ws
    
    If hadProtectedSheets Then
      G_DocInfo.m_HadProtectedSheets = True
    End If

    G_DocInfo.m_Formulas = formam
    G_DocInfo.m_UnprotectedWorksheetsWithFormulas = unprotectedsheetswithformulas
    G_DocInfo.m_Protectedsheets = protectedsheets
    G_DocInfo.m_Unprotectedformulas = unprotectedformulas

    If Not CheckVBAAccessAllowed(wbInExcelCurrentProjectInAccess) Then
        G_DocInfo.m_Macros = -1
    Else
        If wbInExcelCurrentProjectInAccess.VBProject.Protection = 1 Then
            G_DocInfo.m_Macros = -2
        Else
            Dim cm
            Dim makroanzahl As Long
            makroanzahl = 0
            For Each cm In wbInExcelCurrentProjectInAccess.VBProject.VBComponents
                If Not cm Is Nothing Then
                    If cm.CodeModule.CountOfLines > 0 Then
                        Dim tLine As String
                        tLine = cm.CodeModule.Lines(1, cm.CodeModule.CountOfLines)
                        If Len(Trim(RemoveCommentsAndLineFeeds(tLine))) > 0 Then
                            makroanzahl = makroanzahl + 1
                        End If
                    End If
                End If
            Next


            G_DocInfo.m_Macros = makroanzahl
        End If
    End If

#End If


    G_DocInfo.m_Ersteller = Left(GetDocProp(wbInExcelCurrentProjectInAccess, "Author"), 24)
'     G_DocInfo.m_Bearbeitungszeit = GetDocProp(wb, "Total Editing Time")
    G_DocInfo.m_Erstellungsdatum = ConvGermanDate(GetDocProp(wbInExcelCurrentProjectInAccess, "Creation date"))
    G_DocInfo.m_ExtRefs = GetLinkedSourcesCount(wbInExcelCurrentProjectInAccess)

End Sub

Function GetLinkedSourcesCount(ByVal wbInExcelCurrentProjectInAccess As Object) As Long
  GetLinkedSourcesCount = 0
  
#If PROJECT_ACCESSTRACKER = 0 Then
  On Error Resume Next
  GetLinkedSourcesCount = UBound(wbInExcelCurrentProjectInAccess.LinkSources(xlExcelLinks))
#Else
  ' TODO XXX
#End If
End Function



Sub StoreParts(c As Collection)
  On Error Resume Next
  
  If c.count = 0 Then
    If FileExists(GetStorePath(tPassword) & "ECCPWPart" & GetUserName & ".bin") Then
      MyKill GetStorePath(tPassword) & "ECCPWPart" & GetUserName & ".bin"
      Exit Sub
    End If
  End If
  
  Dim FileNumber
  FileNumber = FreeFile
  
  If Not MyOpenFile(FileNumber, GetStorePath(tPassword) & "ECCPWPart" & GetUserName & ".bin", tOutput) Then
      Exit Sub
  End If
  
  Dim item As CStringLong
  
  For Each item In c
    Write #FileNumber, item.m_S
    Write #FileNumber, item.m_L
  Next item
  
  Close #FileNumber

End Sub

Function DecodePassword(s As String)
  Dim i As Long
  Dim ret As String
  Dim t As String
  Dim pos As Long
  pos = 1
  i = 1
  Do While pos > 0
    t = GetNextText(s, pos)
    If Len(t) > 0 Then
      ret = ret & Chr(val(t) Xor Asc(Mid(EncodeString, i, 1)))
    End If
    i = i + 1
  Loop
  
  DecodePassword = ret
  
End Function

Sub StorePasswordToFile(s As String)
  
  Dim FileNumber

'  FileNumber = FreeFile
'  Do
'    Err.Clear
'    Open G_ECCStartupPath & "\ECCPW.bin" For Append As #FileNumber   ' Create file name.
'  Loop While Err.Number <> 0
'  Write #FileNumber, LastPassword
'  Close #FileNumber

  FileNumber = FreeFile
  
  If Not MyOpenFile(FileNumber, GetStorePath(tPassword) & "ECCPW.bin", tAppend) Then
      Exit Sub
  End If
  
  Dim enc As String
  Dim i As Long
  For i = 1 To Len(s)
    If Len(enc) > 0 Then
      enc = enc & "," & CStr(Asc(Mid(s, i, 1)) Xor Asc(Mid(EncodeString, i, 1)))
    Else
      enc = CStr(Asc(Mid(s, i, 1)) Xor Asc(Mid(EncodeString, i, 1)))
    End If
  Next i
  
  Write #FileNumber, enc
  Close #FileNumber

End Sub

Sub StoreidvDateienValue(ByRef rsidvDateien As Recordset, ByRef rsidvDateienDoku As Recordset, ByRef cst As CDataObject)

On Error GoTo nogo
  If Not FieldExists(rsidvDateien, cst.m_Name) Then
    DebugPrint DebType.tERROR, "Dokufeld-Script " & IIf(cst.m_Text2 <> "", "in Dokufeld '" & cst.m_Text2 & "'", "") & " nutzt eine unbekannte Variable: '" & cst.m_Name & "'"
  Else
    If rsidvDateien.Fields(cst.m_Name).Type = adTypeText Or rsidvDateien.Fields(cst.m_Name).Type = adVarWChar Then
      rsidvDateien.Fields(cst.m_Name).value = Left(cst.m_Text, CLng(rsidvDateien(cst.m_Name).DefinedSize))
    Else
      If rsidvDateien.Fields(cst.m_Name).Type = adDouble Then
        rsidvDateien.Fields(cst.m_Name).value = cst.m_Double
      Else
        rsidvDateien.Fields(cst.m_Name).value = cst.m_Long
      End If
    End If
  End If
  If FieldExists(rsidvDateienDoku, cst.m_Name) Then
    If rsidvDateienDoku.Fields(cst.m_Name).Type = adTypeText Or rsidvDateienDoku.Fields(cst.m_Name).Type = adVarWChar Then
      rsidvDateienDoku.Fields(cst.m_Name).value = Left(cst.m_Text, CLng(rsidvDateienDoku(cst.m_Name).DefinedSize))
    Else
      If rsidvDateienDoku.Fields(cst.m_Name).Type = adDouble Then
        rsidvDateienDoku.Fields(cst.m_Name).value = cst.m_Double
      Else
        rsidvDateienDoku.Fields(cst.m_Name).value = cst.m_Long
      End If
    End If
  End If
  Exit Sub
nogo:
  DebugPrint DebType.tERROR, "FEHLER beim Speichern in idvDateien aus Dokufeld-Script " & IIf(cst.m_Text2 <> "", "'" & cst.m_Text2 & "'", "") & ": " & err.Number & " - " & err.Description
End Sub


Attribute VB_Name = "Tabelle1"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "ThisAddin"
Option Explicit

Public Const C_MAXANTWORTFUNCFELDER As Long = 9

Public Const C_IDVDATFLD_INTEGRITAET As Long = 1
Public Const C_IDVDATFLD_VERFUEGBARKEIT As Long = 2
Public Const C_IDVDATFLD_VERTRAULICHKEIT As Long = 3
Public Const C_IDVDATFLD_AUTHENTIZITAET As Long = 4
Public Const C_IDVDATFLD_INFORMATIONSKLASSE As Long = 5
Public Const C_IDVDATFLD_SCHUTZBEDARF As Long = 6
Public Const C_IDVDATFLD_BANKFACHLICH As Long = 7
Public Const C_IDVDATFLD_GOBD As Long = 8
Public Const C_IDVDATFLD_FREMDENTWICKLUNG As Long = 9

' AntwortID fuer: Es gab Prozessauswahl und Prozesse wurden ausgewaehlt
Public Const PA_ANTWORT_SEL As Long = -1000
' AntwortID fuer: Es gab Prozessauswahl und es wurden keine Prozesse ausgewaehlt
Public Const PA_ANTWORT_NONE As Long = -1001

Public G_Befragung As CBefragung

#If VBA7 And Win64 Then
' Done
Private Declare PtrSafe Function DeleteFile Lib "Kernel32.dll" _
  Alias "DeleteFileA" ( _
  ByVal lpFilename As String) As Long

Public Declare PtrSafe Function FindExecutable Lib "shell32.dll" Alias "FindExecutableA" (ByVal lpFile As String, ByVal lpDirectory As String, ByVal lpResult As String) As LongPtr

#Else
Private Declare Function DeleteFile Lib "Kernel32.dll" _
  Alias "DeleteFileA" ( _
  ByVal lpFilename As String) As Long

Public Declare Function FindExecutable Lib "shell32.dll" Alias _
    "FindExecutableA" (ByVal lpFile As String, ByVal lpDirectory As String, ByVal lpResult As String) As Long
#End If

Public MyFullName As String
Public bInternalSave As Boolean
Public G_MyDBLanguage As Long
Private L_InCLeanNames As Boolean

Const C_TabOffset As Long = 20
Const XLA_TABCTRL_YOFF As Long = 20

Public Function IsHttpFilename(ByVal uncpathfname As String) As Boolean
    IsHttpFilename = False
    If UCase(Left(uncpathfname, 6)) = "HTTPS:" Or UCase(Left(uncpathfname, 5)) = "HTTP:" Then
        IsHttpFilename = True
    End If
'    If UCase(Left(uncpathfname, 16)) = "\\VBOXSRV\MYWORK" Then
'        IsHttpFilename = True
'    End If
End Function

Public Function GetDateinameInDatenbank(ByVal uncpathfname As String) As String

    Dim s As String
    uncpathfname = GetPathMapping(uncpathfname)
    s = UCase(uncpathfname)
    If IsHttpFilename(uncpathfname) Then
        If True = True Then
            s = uncpathfname
        End If
    End If
    
    GetDateinameInDatenbank = s

End Function

Function GetTargetRSFromFilename(ByRef conn As Object, ByVal uncpathfname, ByRef rs As Object, ByRef curid As Long) As Boolean
    GetTargetRSFromFilename = False
    
    Dim uncpathfnameDB As String
    uncpathfnameDB = GetDateinameInDatenbank(uncpathfname)
    
    Dim hash As String
    hash = GetFileHash(Nothing, uncpathfnameDB)

    Set rs = OpenRS("SELECT * FROM idvDateien WHERE " & _
      gCHR & "HASH" & gCHR & " = '" & hash & "'" & _
      " and geloescht = 0 ORDER BY idvDateiID DESC ", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)

    If Not rs Is Nothing Then
        If rs.EOF = False Then
            curid = rs.Fields("idvDateiID").value
            GetTargetRSFromFilename = True
            Exit Function
        End If
        rs.Close
    End If
    Set rs = Nothing

End Function

Function GetTargetRS(ByRef conn As Object, ByVal uncpathfname As String, ByRef wbInExcelCurrentProjectInAccess As Object, ByRef rs As Object, ByRef curid As Long, ByRef hash As String, openMode As Integer, ByRef wasLocked As Boolean, Optional allowMotherFile As Boolean = False) As Boolean

    On Error GoTo nogo
    
    DebugPrint tdebug, "GetTargetRS: " & uncpathfname

    GetTargetRS = False
    hash = ""
    curid = 0
    
    Dim uncpathfnameDB As String
    uncpathfnameDB = GetDateinameInDatenbank(uncpathfname)
    
    hash = GetFileHash(wbInExcelCurrentProjectInAccess, uncpathfnameDB)
    
    Dim fileid As Long
    Dim Version As Long
    fileid = WBGetValueLong(wbInExcelCurrentProjectInAccess, "_IDVTrackerID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix)
    Version = WBGetValueLong(wbInExcelCurrentProjectInAccess, "_IDVTrackerVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix)
    
    Dim machineName As String
    machineName = GetComputerName

    Dim ersteller As String
    Dim erstellungsdatum As Date
    
    ersteller = Left(GetDocProp(wbInExcelCurrentProjectInAccess, "Author"), 24)
    erstellungsdatum = ConvGermanDate(GetDocProp(wbInExcelCurrentProjectInAccess, "Creation date"))
    
    
    ' Wenn wir eine ID und eine Version haben, dann schauen wir zuerst nach, ob die Datei evtl. gel|fffd|scht ist!
    If fileid > 0 Then
      Dim lLow As Long
      Dim lHigh As Long
      
      Set rs = OpenRS("SELECT * FROM idvDateien WHERE " & _
        gCHR & "HASH" & gCHR & " = '" & hash & "'" & _
        "and IDVDATEIID=" & fileid & " AND Version=" & Version & " and geloescht = 0", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockPessimistic)
      
      If Not rs Is Nothing And allowMotherFile = True Then
        If rs.EOF = True Then
          rs.Close
          Set rs = OpenRS("SELECT * FROM idvDateien WHERE " & _
            "IDVDATEIID=" & fileid, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockPessimistic)
        End If
      End If
      
      If Not rs Is Nothing Then
        If Not rs.EOF Then
            
            ' Da immer erst pessimistic ge|fffd|ffet wird, um eventuelle Locks zu finden, muss danach
            ' neu ge|fffd|ffnet werden.
            
            If openMode <> ADODB.LockTypeEnum.adLockPessimistic And openMode <> ADODB.LockTypeEnum.adLockReadOnly Then
              rs.Close
              Set rs = Nothing
            
              Set rs = OpenRS("SELECT * FROM idvDateien WHERE idvDateiID=" & fileid & " AND Version = " & Version & " and geloescht = 0", conn, ADODB.CursorTypeEnum.adOpenDynamic, openMode)
            End If
              
            curid = fileid
            GetTargetRS = True
            DebugPrint tdebug, "GetTargetRS END" & curid
            Exit Function
          End If
          rs.Close
          Set rs = Nothing
      End If
    
    End If
    
    ' GetTargetRSFromHash BUG
    ' GetTargetRS = GetTargetRSFromHash(ersteller, erstellungsdatum, conn, uncpathfname, wbInExcelCurrentProjectInAccess.FullName, rs, curId, hash, openMode, wasLocked)
    ' Alternative!
    Set rs = OpenRS("SELECT * FROM idvDateien WHERE idvDateiID=-1", conn, ADODB.CursorTypeEnum.adOpenDynamic, openMode)
    
    Exit Function

nogo:
    
    If err.Number = -2147467259 Then
      DebugPrint DebType.tdebug, "GetTargetRS - Timeout " & err.Number & " - " & err.Description & " - " & err.Source
      wasLocked = True
    Else
      DebugPrint DebType.tERROR, "Fehler in: GetTargetRS - " & err.Number & " - " & err.Description & " - " & err.Source
    End If
    
    On Error Resume Next
    If Not rs Is Nothing Then
      If rs.state <> 0 Then
'        rs.Close
      End If
      Set rs = Nothing
    End If
    
End Function

Function GetNewlyAddedRS(ersteller As String, erstellungsdatum As Date, ByRef conn As Object, ByVal uncpathfname As String, ByVal sharefname As String, ByRef rs As Object, ByRef curid As Long, hash As String, openMode As Integer, ByRef wasLocked As Boolean) As Boolean

    On Error GoTo nogo
    
    curid = 0
    wasLocked = False
    GetNewlyAddedRS = False

    Set rs = OpenRS("SELECT * FROM idvDateien WHERE " & gCHR & "HASH" & gCHR + " ='" & hash & "' AND GELOESCHT=0 ORDER BY idvDateiID", conn, ADODB.CursorTypeEnum.adOpenDynamic, openMode)
    
    DebugPrint tdebug, "GetNewlyAddedRS-1"
    If rs Is Nothing Then
      DebugPrint tdebug, "GetNewlyAddedRS Missing1"
      Exit Function
    End If
    
    If rs.EOF Then
      DebugPrint tdebug, "GetNewlyAddedRS Missing2"
      Exit Function
    End If
    
    rs.MoveLast
    
    Dim uncpathfnameDB As String
    uncpathfnameDB = GetDateinameInDatenbank(uncpathfname)
    
    ' Erst mal den ersten finden, der hier passt
    Do While Not rs.BOF
        If GetDateinameInDatenbank(rs.Fields("Dateiname").value) = uncpathfnameDB Then
            Dim tErsteller As String
            Dim tErstellungsdatum As Date
            tErsteller = ""
            tErstellungsdatum = 0
            
            If IsNull(rs.Fields("Erstellungsdatum").value) = False Then
              tErstellungsdatum = DateAdd("h", -Hour(rs.Fields("Erstellungsdatum").value), rs.Fields("Erstellungsdatum").value)
            End If
            If IsNull(rs.Fields("Ersteller").value) = False Then
              tErsteller = Left(rs.Fields("Ersteller").value, 24)
            End If
            
            If CStr(tErstellungsdatum) = CStr(DateAdd("h", -Hour(erstellungsdatum), erstellungsdatum)) _
                And _
               tErsteller = Left(ersteller, 24) Then
                
                curid = rs.Fields("idvDateiID").value
                rs.MovePrevious
                Exit Do
            End If
        End If
        rs.MovePrevious
    Loop
        
        
    If curid > 0 Then
        
      ' Jetzt alle auf gel|fffd|scht setzen, die nicht passen!
      Do While Not rs.BOF
          If GetDateinameInDatenbank(rs.Fields("Dateiname").value) = uncpathfnameDB Then
              If G_cfgShowMSGBoxForAllErrors Then
                'MsgBox "Die Datei '" & rs.Fields("Dateiname").value & "' ID " & rs.Fields("idvDateiID").value & " wird als gel|fffd|scht markiert!", vbCritical, ProgNameLong & " " & myVersion & " (" & app.Major & "." & app.Minor & "." & app.Revision & ") - *WARNUNG*"
                MsgBox FMT2("THISADDIN_1", rs.Fields("Dateiname").value, rs.Fields("idvDateiID").value), vbCritical, ProgNameLong & " " & myVersion & " (" & app.Major & "." & app.Minor & "." & app.Revision & ") - " & FMT0("ETDLL_6")
              End If
              DebugPrint tdebug, "GetNewlyAddedRS DEL:" & rs.Fields("idvDateiID").value & "-" & uncpathfname
              rs.Fields("Geloescht").value = True
              rs.Fields("GeloeschtDatum").value = Now
              rs.Update
          End If
          rs.MovePrevious
      Loop
    
      ' Dann wieder zum letzten gehen
      rs.MoveLast
      Do While Not rs.BOF
          If rs.Fields("idvDateiID").value = curid Then
             GetNewlyAddedRS = True
             Exit Do
          End If
          rs.MovePrevious
      Loop
    End If
    
    DebugPrint tdebug, "GetNewlyAddedRS END: " & curid & "-" & uncpathfname

    Exit Function

nogo:
    On Error Resume Next
    If Not rs Is Nothing Then
      If rs.state <> 0 Then
'        rs.Close
      End If
      Set rs = Nothing
    End If
    
    If err.Number = -2147467259 Then
      DebugPrint DebType.tdebug, "GetNewlyAddedRS - Timeout " & err.Number & " - " & err.Description & " - " & err.Source
      wasLocked = True
    Else
      DebugPrint DebType.tERROR, "Fehler in: GetNewlyAddedRS - " & err.Number & " - " & err.Description & " - " & err.Source
    End If
End Function

' die richtigen Daten in Abh|fffd|ngigkeit des angemeldeten Users holen
Function GetParamRS_User(ByRef conn As Object) As Object

    Set GetParamRS_User = Nothing
On Error GoTo nogo
    
    ' AD Gruppen auslesen
    Dim userGroups As String
    userGroups = GetUserGroups(GetUserName())
    If userGroups = "" Then
        Exit Function
    End If
    
    Dim rs As Object
    Set rs = CreateObject("ADODB.Recordset")
    ' User Groups haben schon ein Hochkomma vor- und nachgestellt
    rs.Open "SELECT p.* FROM gParameter p inner join gProfile g on p.ProfilID = g.ProfilID where g.Profilname IN (" & userGroups & ")", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
    If Not rs Is Nothing Then
        If Not rs.EOF Then
            Set GetParamRS_User = rs
            Exit Function
        End If
        rs.Close
        Set rs = Nothing
    End If
    Exit Function

nogo:
    DebugPrint tERROR, "Fehler in: GetParamRS_User - " & err.Number & " - " & err.Description & " - " & err.Source

End Function


Function GetParamRS(ByRef conn As Object) As Object
On Error GoTo nogo

    Dim rs As Object
    DebugPrint tdebug, "GetParamRS"
    
    Set rs = GetParamRS_User(conn)
    If rs Is Nothing Then
        Set rs = CreateObject("ADODB.Recordset")
        rs.Open "SELECT * FROM gParameter ORDER BY ParameterID", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
    End If

    Set GetParamRS = rs
    Exit Function
nogo:
    If err.Number = -2147467259 Then
      DebugPrint DebType.tdebug, "GetParamRS - Timeout " & err.Number & " - " & err.Description & " - " & err.Source
    Else
      DebugPrint DebType.tERROR, "Fehler in: GetParamRS - " & err.Number & " - " & err.Description & " - " & err.Source
    End If
    
    On Error Resume Next
    If Not rs Is Nothing Then
        If rs.state <> 0 Then
        End If
        Set rs = Nothing
    End If
    
    Set GetParamRS = Nothing
    
End Function

Sub CopyRecordsetData(ByRef rs As Object, ByVal oldid As Long, ByVal oldversion As Long, ByRef conn As Object)

    On Error Resume Next

    Dim trs As Object
    Set trs = OpenRS("SELECT * FROM idvDateien WHERE idvDateiID=" & oldid & " and Version = " & oldversion, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
    DebugPrint tdebug, "BS4-Werte kopieren"
    If Not trs Is Nothing Then
        If Not trs.EOF Then
            Dim f As Long
            For f = 0 To trs.Fields.count - 1
                Dim na As String
                na = trs.Fields(f).name
                If UCase(na) <> "IDVDATEIID" And UCase(na) <> "LIST1" Then
                    rs.Fields(na).value = trs.Fields(na).value
                End If
            Next
        End If
    End If

End Sub

Sub CopyRecordsetVerantwortlicherUser(ByRef rs As Object, ByVal oldid As Long, ByVal oldversion As Long, ByRef conn As Object)
     ' Verantwortlichen Autor aus Doku holen
     Dim trs As Object
     Set trs = OpenRS("SELECT VerantwortlicherAutor FROM idvDateienDoku WHERE idvDateiID = " & oldid & " and Version = " & oldversion, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
     If Not trs Is Nothing Then
       rs.Fields("VerantwortlicherAutor").value = GetSafeFieldPlus(trs, "VerantwortlicherAutor", "")
       trs.Close
       Set trs = Nothing
     End If
End Sub

Sub CopyRecordsetFachlichVerantwortlicher(ByRef rs As Object, ByVal oldid As Long, ByVal oldversion As Long, ByRef conn As Object)
     ' Verantwortlichen Autor aus Doku holen
     Dim trs As Object
     Set trs = OpenRS("SELECT FachlichVerantwortlicher FROM idvDateienDoku WHERE idvDateiID = " & oldid & " and Version = " & oldversion, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
     If Not trs Is Nothing Then
       rs.Fields("FachlichVerantwortlicher").value = GetSafeFieldPlus(trs, "FachlichVerantwortlicher", "")
       trs.Close
       Set trs = Nothing
     End If
End Sub

Sub CopyRecordsetKommentare(ByRef rs As Object, oldid As Long, ByRef conn As Object)
    Dim newid As Long
    newid = GetSafeFieldPlus(rs, "idvDateiID", 0)
    If newid <= 0 Then Exit Sub
    
    Call CopyDataIDVDateien(oldid, newid, conn, "idvDateienFragenKommentar", False)
End Sub

Sub CreateNewRecordset(ByVal uncpathfname As String, ByVal sharefname As String, ByRef wbInExcelCurrentProjectInAccess As Object, ByRef rsOld As Object, ByRef conn As Object)
    DebugPrint tdebug, "CNR1"
    
    Dim uncpathfnameDB As String
    uncpathfnameDB = GetDateinameInDatenbank(uncpathfname)
    
    Dim hash As String
    hash = GetFileHash(wbInExcelCurrentProjectInAccess, uncpathfnameDB)
    DebugPrint tdebug, "CNR2"
    
    Dim fnd As Boolean
    Dim curid As Long
    
    Dim oldid As Long
    Dim oldversion As Long
    
    oldid = rsOld.Fields("idvDateiID").value
    oldversion = rsOld.Fields("Version").value
    
    Dim rs As Recordset
    Set rs = OpenRS("SELECT * FROM idvDateien WHERE idvDateiID=" & oldid & " and Version = -1", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockPessimistic)
    If rs Is Nothing Then
        Exit Sub
    End If

    rs.AddNew
    DebugPrint tdebug, "CNR3"
    ' alle Daten des alten Recordsets r|fffd|berkopieren
    CopyRecordsetData rs, oldid, oldversion, conn
    
    ' Version wird bei jedem Kopieren erh|fffd|ht
    If Not IsNull(rsOld.Fields("MaxVersion").value) Then
        rs.Fields("Version").value = rsOld.Fields("MaxVersion").value + 1
    Else
        rs.Fields("Version").value = 1
    End If
    rs.Fields("MaxVersion").value = rs.Fields("Version").value
    ' Referenz ist immer die alte VERsion
    rs.Fields("ReferenzidvDateiID").value = oldid
    rs.Fields("ReferenzVersion").value = oldversion
    If IsNull(rsOld.Fields("ReferenzAnzahl").value) Then
        rs.Fields("ReferenzAnzahl").value = 1
    Else
        rs.Fields("ReferenzAnzahl").value = rsOld.Fields("ReferenzAnzahl").value + 1
    End If
    
    rs.Fields("Speicheranzahl").value = 0
    rs.Fields("Dateiname").value = uncpathfname
    DebugPrint tdebug, "CNR3.2 Name:" & uncpathfname
    
    ' Freigaben existieren in diesem Fall niemals
    rs.Fields("FreigabeStatus").value = 0
    rs.Fields("FreigabeidvDateiID").value = 0
    rs.Fields("FreigabeVersion").value = 0
    rs.Fields("FreigabeChecksumme").value = 0
    rs.Fields("Geloescht").value = 0
    rs.Fields("GeloeschtDatum").value = Empty
    DebugPrint tdebug, "CNR3.3"

    CopyRecordsetVerantwortlicherUser rs, oldid, oldversion, conn

    If IsNull(rs.Fields("VerantwortlicherAutor").value) Then
      rs.Fields("VerantwortlicherAutor").value = UCase(Left(GetUserName, CLng(rs.Fields("VerantwortlicherAutor").DefinedSize)))
      DebugPrint tdebug, "CNR12.1-Verantw.Autor:" & GetUserName
    ElseIf rs.Fields("VerantwortlicherAutor") = "" Then
      rs.Fields("VerantwortlicherAutor").value = UCase(Left(GetUserName, CLng(rs.Fields("VerantwortlicherAutor").DefinedSize)))
      DebugPrint tdebug, "CNR12.2-Verantw.Autor:" & GetUserName
    End If
    
    If IsNull(rs.Fields("FachlichVerantwortlicher").value) Then
      rs.Fields("FachlichVerantwortlicher").value = UCase(Left(GetUserName, CLng(rs.Fields("FachlichVerantwortlicher").DefinedSize)))
      DebugPrint tdebug, "CNR12.3-FachVerantw.Autor:" & GetUserName
    ElseIf rs.Fields("FachlichVerantwortlicher") = "" Then
      rs.Fields("FachlichVerantwortlicher").value = UCase(Left(GetUserName, CLng(rs.Fields("FachlichVerantwortlicher").DefinedSize)))
      DebugPrint tdebug, "CNR12.4-FachVerantw.Autor:" & GetUserName
    End If
    
    rs.Update
    DebugPrint tdebug, "CNR6"
    rs.Close
    
    Dim ersteller As String
    Dim erstellungsdatum As Date
    
    ersteller = GetSafeFieldPlus(rsOld, "Ersteller", "")
    erstellungsdatum = GetSafeFieldPlus(rsOld, "Erstellungsdatum", 0)
    
    ' alten Recordset schliessen
    rsOld.Close
        
    Dim wasLocked As Boolean
    fnd = GetNewlyAddedRS(ersteller, erstellungsdatum, conn, uncpathfname, sharefname, rsOld, curid, hash, ADODB.LockTypeEnum.adLockPessimistic, wasLocked)
    If Not fnd Then
      Set rsOld = Nothing
    Else
      If oldversion > 0 And oldid > 0 Then
        CopyidvDateienFileStuff oldid, curid, conn
      End If
    End If
    DebugPrint tdebug, "CNR7"

    rsOld.Fields("Speicheranzahl").value = GetValueFromField(rs, "Speicheranzahl", 0) + 1
    rsOld.Fields("SpeichernderUserLogonID").value = GetUserNameUCASE
    
   DebugPrint tdebug, "Ende CreateNewRecordset"

End Sub



Sub BeforeSave(ByVal uncpathfname As String, ByVal sharefname As String, ByRef wbInExcelCurrentProjectInAccess As Object, ByRef rs As Object, ByRef conn As Object, ByVal oldid As Long, ByVal oldversion As Long, ByVal nameHasChanged As Boolean)

On Error GoTo nogo
    Dim trackpos As Long

    DebugPrint tdebug, "BS1"
    trackpos = 0
    
    Dim hash As String
    hash = ""

    Dim uncpathfnameDB As String
    uncpathfnameDB = GetDateinameInDatenbank(uncpathfname)
    DebugPrint tdebug, "BS2"
    trackpos = 10
    
    Dim ersteller As String
    Dim erstellungsdatum As Date
    
    ersteller = Left(GetDocProp(wbInExcelCurrentProjectInAccess, "Author"), 24)
    erstellungsdatum = ConvGermanDate(GetDocProp(wbInExcelCurrentProjectInAccess, "Creation date"))
    DebugPrint tdebug, "BS3"
    trackpos = 20
    
    Dim fnd As Boolean
    Dim curid As Long
    Dim wasLocked As Boolean

    '
    
' GetTargetRSFromHash BUG
' #If PROJECT_ACCESSTRACKER = 0 Then
'     fnd = GetTargetRSFromHash(ersteller, erstellungsdatum, conn, uncpathfname, wbInExcelCurrentProjectInAccess.FullName, rs, curId, s, ADODB.LockTypeEnum.adLockPessimistic, wasLocked)
' #Else
    ' Bei Access ist das erforderlich, damit er das Verschieben von Dateien schnallt.
    fnd = GetTargetRS(conn, uncpathfname, wbInExcelCurrentProjectInAccess, rs, curid, hash, ADODB.LockTypeEnum.adLockPessimistic, wasLocked)
' #End If
    DebugPrint tdebug, "BS4"
    trackpos = 30
    
    If rs Is Nothing Then
        If wasLocked Then
          DebugPrint tdebug, "BeforeSave: Locked"
        End If
        Exit Sub
    End If

    trackpos = 40
'    If oldid > 0 And oldid <> rs.Fields("idvDateiID").Value Then


    If fnd = False Or nameHasChanged = True Then
        rs.AddNew
        DebugPrint tdebug, "BS5"
        trackpos = 50
        
        rs.Fields("DokuID").value = 0
        rs.Fields("Risikowert").value = -1
        rs.Fields("FreigabeStatus").value = 0
        rs.Fields("MajorVersion").value = 1
        rs.Fields("MinorVersion").value = 0
        
        If oldversion > 0 And oldid > 0 Then
            ' -------------------------------------
            ' ACHTUNG *****************************
            ' Alle Werte, die ABH|fffd|NGIG von dem
            ' Referenzeintrag in idvDateien gesetzt werden
            ' M|fffd|SSEN!!!
            ' -------------------------------------
            trackpos = 60
            CopyRecordsetData rs, oldid, oldversion, conn
        End If
        
        trackpos = 70
        ' Dateiname k|fffd|nnte sich ge|fffd|ndert haben, damit auch der Hash
        hash = GetFileHash(wbInExcelCurrentProjectInAccess, uncpathfnameDB)
        rs.Fields("Hash").value = hash
        DebugPrint tdebug, "BS5.1 HASH:" & hash
        trackpos = 80
        rs.Fields("Ersteller").value = Left(GetDocProp(wbInExcelCurrentProjectInAccess, "Author"), 24)
        rs.Fields("Erstellungsdatum").value = ConvGermanDate(GetDocProp(wbInExcelCurrentProjectInAccess, "Creation date"))
        trackpos = 90
        rs.Fields("AufnahmeInDB").value = Now()
        rs.Fields("VerantwortlicheOEID").value = GetCurrentUserOEID(conn)
        rs.Fields("Version").value = 1
        
        trackpos = 120
        
#If PROJECT_ACCESSTRACKER = 0 Then
        rs.Fields("idvTypID").value = 1
#Else
        rs.Fields("idvTypID").value = 2
#End If
        trackpos = 130
        rs.Fields("Speicheranzahl").value = 0
        rs.Fields("MaxVersion").value = IIf(oldversion > 0, oldversion + 1, 1)
        rs.Fields("Dateiname").value = uncpathfname
        trackpos = 140
        DebugPrint tdebug, "BS5.2 Name:" & uncpathfname
        rs.Fields("Geloescht").value = 0
        rs.Fields("GeloeschtDatum").value = Empty
        trackpos = 150
        
        rs.Fields("AufChecksummenVerndrngnUbrwchn").value = False
        DebugPrint tdebug, "BS5.3"
        trackpos = 160
        
        ' Hier werden die Werte der alten Datei kopiert!
        If oldversion > 0 And oldid > 0 Then
            ' -------------------------------------
            ' ACHTUNG
            ' Alle Werte, die auch unabh|fffd|ngig von dem
            ' Referenzeintrag in idvDateien gesetzt werden
            ' k|fffd|nnen!!!
            ' -------------------------------------
           
            trackpos = 170
            rs.Fields("ReferenzidvDateiID").value = oldid
            rs.Fields("ReferenzVersion").value = oldversion
            rs.Fields("ReferenzAnzahl").value = 1
            rs.Fields("Version").value = rs.Fields("MaxVersion").value
            trackpos = 180
            If WBGetValueLong(wbInExcelCurrentProjectInAccess, "_IDVTrackerMajorVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix) > 0 Then
                rs.Fields("MajorVersion").value = WBGetValueLong(wbInExcelCurrentProjectInAccess, "_IDVTrackerMajorVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix)
                rs.Fields("MinorVersion").value = WBGetValueLong(wbInExcelCurrentProjectInAccess, "_IDVTrackerMinorVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix)
            End If
            
            Dim trs As Object
            ' Freigaberelvante Werte holen
            trackpos = 190
            If WBGetValueLong(wbInExcelCurrentProjectInAccess, "_IDVTrackerFreigabeStatus" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix) = 2 Then
                trackpos = 200
                Set trs = OpenRS("SELECT FreigabeChecksumme FROM idvDateienFreigaben WHERE Status = 0 and idvDateiID = " & WBGetValueLong(wbInExcelCurrentProjectInAccess, "_IDVTrackerFreigabeDateiID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix) & " AND Version = " & WBGetValueLong(wbInExcelCurrentProjectInAccess, "_IDVTrackerFreigabeVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix) & " order by DATUM Desc", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
                trackpos = 210
                If Not trs Is Nothing Then
                  trackpos = 220
                  If trs.EOF = False Then
                    rs.Fields("FreigabeStatus").value = 2
                    rs.Fields("FreigabeidvDateiID").value = WBGetValueLong(wbInExcelCurrentProjectInAccess, "_IDVTrackerFreigabeDateiID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix)
                    rs.Fields("FreigabeVersion").value = WBGetValueLong(wbInExcelCurrentProjectInAccess, "_IDVTrackerFreigabeVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix)
                    trackpos = 230
                     
                    ' Checksumme kommt aus idvDateienFreigabe
                    rs.Fields("FreigabeChecksumme").value = GetSafeFieldPlus(trs, "FreigabeChecksumme", "")
                    rs.Fields("Checksumme").value = rs.Fields("FreigabeChecksumme").value
                    trackpos = 240
                  End If
                  trs.Close
                  trackpos = 250
                  Set trs = Nothing
                End If
            End If
    
            ' Verantwortlichen Autor aus Doku holen
            trackpos = 260
            CopyRecordsetVerantwortlicherUser rs, oldid, oldversion, conn
            trackpos = 270
  
        ElseIf oldid <= 0 Then
            DebugPrint tdebug, "BS8-Freigabe Werte init"
            trackpos = 280
            rs.Fields("FreigabeStatus").value = 0
            rs.Fields("FreigabeidvDateiID").value = 0
            rs.Fields("FreigabeVersion").value = 0
            rs.Fields("FreigabeChecksumme").value = ""
            trackpos = 290
            SetStandardStuff rs
            trackpos = 300
            DebugPrint tdebug, "BS11-StandardStuff fertig"
        End If
        
        trackpos = 310
        If IsNull(rs.Fields("VerantwortlicherAutor").value) Then
          trackpos = 320
          rs.Fields("VerantwortlicherAutor").value = UCase(Left(GetUserName, rs.Fields("VerantwortlicherAutor").DefinedSize))
          DebugPrint tdebug, "BS12.1-Verantw.Autor:" & GetUserName
        ElseIf rs.Fields("VerantwortlicherAutor") = "" Then
          trackpos = 330
          rs.Fields("VerantwortlicherAutor").value = UCase(Left(GetUserName, rs.Fields("VerantwortlicherAutor").DefinedSize))
          DebugPrint tdebug, "BS12.2-Verantw.Autor:" & GetUserName
        End If
        If IsNull(rs.Fields("FachlichVerantwortlicher").value) Then
          trackpos = 320
          rs.Fields("FachlichVerantwortlicher").value = UCase(Left(GetUserName, rs.Fields("FachlichVerantwortlicher").DefinedSize))
          DebugPrint tdebug, "BS12.3-FachVerantw.Autor:" & GetUserName
        ElseIf rs.Fields("FachlichVerantwortlicher") = "" Then
          trackpos = 330
          rs.Fields("FachlichVerantwortlicher").value = UCase(Left(GetUserName, rs.Fields("FachlichVerantwortlicher").DefinedSize))
          DebugPrint tdebug, "BS12.4-FachVerantw.Autor:" & GetUserName
        End If
        
        trackpos = 340
        rs.Update
        trackpos = 350
        DebugPrint tdebug, "BS6"
        rs.Close
        trackpos = 360
        
        ' fnd = GetTargetRSFromHash(ersteller, erstellungsdatum, conn, uncpathfname, sharefname, rs, curId, s, ADODB.LockTypeEnum.adLockPessimistic, wasLocked)
        fnd = GetNewlyAddedRS(ersteller, erstellungsdatum, conn, uncpathfname, sharefname, rs, curid, hash, ADODB.LockTypeEnum.adLockPessimistic, wasLocked)
        trackpos = 370
        If Not fnd Then
          MsgBox FMT0("THISADDIN_142"), vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
          DebugPrint tERROR, "BeforeSave: GetNewlyAddedRS failed."
          Set rs = Nothing
        Else
          If oldversion > 0 And oldid > 0 Then
            CopyidvDateienFileStuff oldid, curid, conn
          End If
        End If
        DebugPrint tdebug, "BS7"

    Else
        trackpos = 410
        rs.Fields("Ersteller").value = Left(GetDocProp(wbInExcelCurrentProjectInAccess, "Author"), 24) ' GetUserName 'Environ("USERNAME") ' GetUserName 'Environ("USERNAME")
        rs.Fields("Erstellungsdatum").value = ConvGermanDate(GetDocProp(wbInExcelCurrentProjectInAccess, "Creation date"))
        trackpos = 420
        DebugPrint tdebug, "BS8"
    End If

    trackpos = 430
    If Not rs Is Nothing Then
      If IsNull(rs.Fields("ErsteSpeicherung").value) Then
        trackpos = 440
        rs.Fields("ErsteSpeicherung").value = Now
      End If
      
      trackpos = 450
      rs.Fields("Speicheranzahl").value = GetValueFromField(rs, "Speicheranzahl", 0) + 1
      trackpos = 460
      rs.Fields("SpeichernderUserLogonID").value = GetUserNameUCASE
      trackpos = 470
    End If
    
   DebugPrint tdebug, "BeforeSaveEnde"

   Exit Sub

nogo:
    ' POS:340 - -2147217900 - [Microsoft][ODBC-Treiber f|fffd|r Microsoft Access] Null-Wert in Index oder Prim|fffd|rschl|fffd|ssel nicht m|fffd|glich.
    If err.Number = -2147217900 Then
      Dim fldcnt As Long
      For fldcnt = 0 To rs.Fields.count - 1
        If IsNull(rs.Fields(fldcnt)) Then
          Debug.Print "Field NULL: " & rs.Fields(fldcnt).name
        End If
      Next fldcnt
    End If
    DebugPrint tERROR, "Interner Fehler in BeforeSave (" & uncpathfname & ") POS:" & trackpos & " - " & err.Number & " - " & err.Description

End Sub

Private Sub CopyDataIDVDateien(ByVal oldid As Long, ByVal newid As Long, ByRef conn As Object, ByVal tabname As String, ByVal ignoreFields As String)
On Error Resume Next
  
  Dim rs As Object
  Set rs = OpenRS("SELECT * FROM " & tabname & " WHERE idvDateiID=" & oldid, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
  Dim drs As Object
  Set drs = OpenRS("SELECT * FROM " & tabname & " WHERE idvDateiID=" & newid, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockOptimistic)
  If Not rs Is Nothing Then
  
    Dim arr() As String
    If ignoreFields <> "" Then
        arr = Split(UCase(ignoreFields), ";")
    End If
    
    Do While Not rs.EOF
      drs.AddNew
      
        Dim f As Long
        For f = 0 To rs.Fields.count - 1
            Dim na As String
            na = rs.Fields(f).name
            
            Dim i As Long
            If ignoreFields <> "" Then
                For i = 0 To UBound(arr)
                    If UCase(na) = arr(i) Then
                        Exit For
                    End If
                Next i
                
                If i = UBound(arr) + 1 Then
                    drs.Fields(na).value = rs.Fields(na).value
                End If
            Else
                drs.Fields(na).value = rs.Fields(na).value
            End If
        Next
      drs.Fields("idvDateiID").value = newid
      
      drs.Update
      rs.MoveNext
    Loop
    rs.Close
  End If
  Set rs = Nothing
  drs.Close
  Set drs = Nothing

End Sub

Private Sub CopyPasswordsToNewID(ByVal oldid As Long, ByVal newid As Long, ByRef conn As Object)
    CopyDataIDVDateien oldid, newid, conn, "idvDateienPW", "idvDateienPWID;idvDateiID"
  
'  Dim rs As Object
'  Set rs = OpenRS("SELECT * FROM idvDateienPW WHERE idvDateiID=" & oldid, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
'  Dim drs As Object
'  Set drs = OpenRS("SELECT * FROM idvDateienPW WHERE idvDateiID=" & newid, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockOptimistic)
'  If Not rs Is Nothing Then
'    Do While Not rs.EOF
'      drs.AddNew
'      drs.Fields("idvDateiID").Value = newid
'      drs.Fields("Datum").Value = rs.Fields("Datum").Value
'      drs.Fields("Passwort").Value = rs.Fields("Passwort").Value
'      drs.Fields("LogonID").Value = rs.Fields("LogonID").Value
'      drs.Fields("PWTyp").Value = rs.Fields("PWTyp").Value
'      drs.Fields("Tabname").Value = rs.Fields("Tabname").Value
'      drs.Update
'      rs.MoveNext
'    Loop
'    rs.Close
'  End If
'  Set rs = Nothing
'  drs.Close
'  Set drs = Nothing
End Sub

Private Sub CopyBerechtigungenToNewID(ByVal oldid As Long, ByVal newid As Long, ByRef conn As Object)
    
    CopyDataIDVDateien oldid, newid, conn, "idvDateienBerechtigungen", "id;idvDateiID"

End Sub

Function WBGetValueLong(ByRef wbInExcelCurrentProjectInAccess As Object, ByVal vname As String) As Long

    WBGetValueLong = -100
    
#If PROJECT_ACCESSTRACKER <> 0 Then
    Dim l
    Dim foundProp As Boolean
    l = GetStartUpProperty(wbInExcelCurrentProjectInAccess, vname, foundProp)
    If foundProp Then
      WBGetValueLong = CLng(l)
    End If
#Else
    Dim nameItem As Excel.name

    For Each nameItem In wbInExcelCurrentProjectInAccess.names
        If nameItem.visible = False Then
            If nameItem.name = vname Then
                WBGetValueLong = val(Mid(nameItem.RefersTo, 2))
                Exit Function
            End If
        End If
    Next nameItem
#End If
End Function

Function WBValueSet(ByRef wbInExcelCurrentProjectInAccess As Object, ByVal vname As String) As Boolean

    WBValueSet = False
    
#If PROJECT_ACCESSTRACKER <> 0 Then
    Dim l
    Dim foundProp As Boolean
    l = GetStartUpProperty(wbInExcelCurrentProjectInAccess, vname, foundProp)
    If foundProp Then
      WBValueSet = True
    End If
#Else
    Dim nameItem As Excel.name

    For Each nameItem In wbInExcelCurrentProjectInAccess.names
        If nameItem.visible = False Then
            If nameItem.name = vname Then
                WBValueSet = True
                Exit Function
            End If
        End If
    Next nameItem
#End If
End Function


' _ExcelProtectSP_

#If Project_ExcelTracker = 1 Then
Function WBGetValueLongPart(ByRef wbInExcelCurrentProjectInAccess As Object, ByVal vname As String) As Long

    WBGetValueLongPart = -100
    
    Dim nameItem As Excel.name

    For Each nameItem In wbInExcelCurrentProjectInAccess.names
        If nameItem.visible = False Then
            If Left(nameItem.name, Len(vname)) = vname Then
                WBGetValueLongPart = val(Mid(nameItem.RefersTo, 2))
                Exit Function
            End If
        End If
    Next nameItem
End Function
#End If

Public Sub WBCleanNames(ByRef wbInExcelCurrentProjectInAccess As Object)
    
    If L_InCLeanNames Then Exit Sub
    L_InCLeanNames = True
    
    Dim nameItem As Excel.name
goAgain:
    For Each nameItem In wbInExcelCurrentProjectInAccess.names
        If InStr(nameItem.name, "!_IDVTracker") > 0 Then
            nameItem.Delete
            GoTo goAgain
        End If
    Next nameItem



    ' Das wird nur gemacht, wenn es eine Institutsnummer gibt UND noch keine ID nach neuem Schema eingetragen ist!!!
    If G_PARAM_Institutsnummer <> "" And WBValueSet(wbInExcelCurrentProjectInAccess, "_IDVTrackerID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix) = False Then
GoAgain2:
        For Each nameItem In wbInExcelCurrentProjectInAccess.names
            ' Noch alte IDs vorhanden?
            If Left(nameItem.name, Len("_IDVTracker")) = "_IDVTracker" Then
              If nameItem.name = "_IDVTrackerFreigabeStatus" & G_PARAM_Datenbankprefix Then
                WBSetValueLong wbInExcelCurrentProjectInAccess, "_IDVTrackerFreigabeStatus" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, Mid(nameItem.RefersTo, 2)
                nameItem.Delete
                GoTo GoAgain2
              ElseIf nameItem.name = "_IDVTrackerFreigabeDateiID" & G_PARAM_Datenbankprefix Then
                WBSetValueLong wbInExcelCurrentProjectInAccess, "_IDVTrackerFreigabeDateiID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, Mid(nameItem.RefersTo, 2)
                nameItem.Delete
                GoTo GoAgain2
              ElseIf nameItem.name = "_IDVTrackerFreigabeVersion" & G_PARAM_Datenbankprefix Then
                WBSetValueLong wbInExcelCurrentProjectInAccess, "_IDVTrackerFreigabeVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, Mid(nameItem.RefersTo, 2)
                nameItem.Delete
                GoTo GoAgain2
              ElseIf nameItem.name = "_IDVTrackerID" & G_PARAM_Datenbankprefix Then
                WBSetValueLong wbInExcelCurrentProjectInAccess, "_IDVTrackerID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, Mid(nameItem.RefersTo, 2)
                nameItem.Delete
                GoTo GoAgain2
              ElseIf nameItem.name = "_IDVTrackerVersion" & G_PARAM_Datenbankprefix Then
                WBSetValueLong wbInExcelCurrentProjectInAccess, "_IDVTrackerVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, Mid(nameItem.RefersTo, 2)
                nameItem.Delete
                GoTo GoAgain2
              ElseIf nameItem.name = "_IDVTrackerMajorVersion" & G_PARAM_Datenbankprefix Then
                WBSetValueLong wbInExcelCurrentProjectInAccess, "_IDVTrackerMajorVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, Mid(nameItem.RefersTo, 2)
                nameItem.Delete
                GoTo GoAgain2
              ElseIf nameItem.name = "_IDVTrackerMinorVersion" & G_PARAM_Datenbankprefix Then
                WBSetValueLong wbInExcelCurrentProjectInAccess, "_IDVTrackerMinorVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, Mid(nameItem.RefersTo, 2)
                nameItem.Delete
                GoTo GoAgain2
              End If
    
            End If
        Next nameItem
    End If
    
    L_InCLeanNames = False

End Sub

Sub WBSetValueLong(ByRef wbInExcelCurrentProjectInAccess As Object, ByVal vname As String, ByVal id As Long)

'    Dim olddisplayalerts As Boolean
'    olddisplayalerts = wbInExcelCurrentProjectInAccess.Application.DisplayAlerts
    
    Dim nameItem As Excel.name

    For Each nameItem In wbInExcelCurrentProjectInAccess.names
        If nameItem.visible = False Then
            If nameItem.name = vname Then
                If nameItem.RefersTo = "=" & id Then
'                    wbInExcelCurrentProjectInAccess.Application.DisplayAlerts = olddisplayalerts
                    Exit Sub
                End If
            End If
        End If
    Next nameItem

    WBCleanNames wbInExcelCurrentProjectInAccess
    
    For Each nameItem In wbInExcelCurrentProjectInAccess.names
        If nameItem.visible = False Then
            If nameItem.name = vname Then
                If nameItem.RefersTo <> "=" & id Then
                    nameItem.RefersTo = "=" & id
                End If
'                wbInExcelCurrentProjectInAccess.Application.DisplayAlerts = olddisplayalerts
                Exit Sub
            End If
        End If
    Next nameItem

    On Error GoTo nogo
    wbInExcelCurrentProjectInAccess.names.add vname, CStr(id), False
'    wbInExcelCurrentProjectInAccess.Application.DisplayAlerts = olddisplayalerts
    Exit Sub

nogo:

    'MsgBox "Error: " & err.Number & " - " & err.Description & " - " & err.Source, vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
    'MsgBox FMT3("THISADDIN_2", err.Number, err.Description, err.source), vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
    MsgBox "Error WBSetValueLong (" & vname & " - " & id & "):" & err.Number & " - " & err.Description & " - " & err.Source, vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"

End Sub

Function IsSharedWorkbook(ByRef wb As Object) As Boolean
    IsSharedWorkbook = False
    On Error GoTo nogo
    
#If PROJECT_ACCESSTRACKER = 0 Then
    ' Nur fuer ExcelTracker
    If wb.MultiUserEditing Then
        IsSharedWorkbook = True
    End If
#End If
nogo:
End Function

Sub AfterSave(ByVal uncpathfname As String, ByVal sharefname As String, ByRef wbInExcelCurrentProjectInAccess As Object, ByRef rs As Object, ByVal oldid As Long, ByVal oldversion As Long, ByRef conn As Object, warVBASaveAs As Boolean, ByVal inClose As Boolean)

    Dim trackpos As Long
    trackpos = 0
    Dim i As Long
    Dim fileid As Long
    Dim didRisikobefragung As Boolean

    On Error GoTo nogo
    
    If rs Is Nothing Then Exit Sub
    
    Dim isSharedWb As Boolean
    isSharedWb = IsSharedWorkbook(wbInExcelCurrentProjectInAccess)
    
    trackpos = 10
    DebugPrint tinfo, "Datei gespeichert: " & uncpathfname
    
    Dim dateiIstAusgeschlossen As Boolean
    
    dateiIstAusgeschlossen = DateiAusgeschlossen2(wbInExcelCurrentProjectInAccess, conn)
    trackpos = 20
    DebugPrint tdebug, "AS1"
    
'    rs.Fields("Speicheranzahl").Value = GetValueFromField(rs, "Speicheranzahl", 0) + 1
'    rs.Fields("SpeichernderUserLogonID").Value = GetUserName ' Environ("USERNAME")
    
    DebugPrint tdebug, "AS2"
    trackpos = 30
    If Mid(uncpathfname, 2, 1) = ":" Then
        trackpos = 40
        rs.Fields("Rechnerkennung").value = Left(GetComputerName, 32)
        DebugPrint tdebug, "AS2.1-Lokale Speicherung: " & Left(GetComputerName, 32)
'        rs.Fields("ServerpathLeft").Value = UCase(Left(uncpathfname, 255))
'        rs.Fields("ServerpathRight").Value = UCase(Right(uncpathfname, 16))
'    Else
'        Dim s As String
'        Dim servername As String
'        s = GetLocalPath(uncpathfname, servername)
'        rs.Fields("Rechnerkennung").Value = Left(servername, 32)
'        rs.Fields("ServerpathLeft").Value = UCase(Left(s, 255))
'        rs.Fields("ServerpathRight").Value = UCase(Right(s, 16))
    Else
        trackpos = 50
        rs.Fields("Rechnerkennung").value = Empty
        DebugPrint tdebug, "AS2.2-Serverspeicherung"
    End If
    
    rs.Fields("OEID").value = GetUserOEID(GetUserName, conn)
    trackpos = 60
    
    DebugPrint tdebug, "AS3"

    fileid = rs.Fields("idvDateiID").value
    trackpos = 70
    
    Dim trs As Object

    trackpos = 80
    If inClose = False Then
        trackpos = 90
        rs.Fields("Speicherdatum").value = MyFileDateTime(uncpathfname)
    Else
        trackpos = 100
        rs.Fields("Speicherdatum").value = Now
    End If
    trackpos = 110
    rs.Fields("Dateidatum").value = rs.Fields("Speicherdatum").value
    DebugPrint tdebug, "AS12.3"

    trackpos = 120

#If PROJECT_ACCESSTRACKER = 0 Then
'    If Not dateiIstAusgeschlossen Then
'      If G_DocInfo.m_HadProtectedSheets = True Then
'        If G_DocInfo.m_HadProtectedSheets = True And G_PARAM_PasswortanalyseInSec <> -1 Then
'          DebugPrint tdebug, "AS13-CountProtectedFormulas"
'          CountProtectedFormulas wbInExcelCurrentProjectInAccess.Application, wbInExcelCurrentProjectInAccess.FullName
'          DebugPrint tdebug, "AS14-CountProtectedFormulas fertig"
'        End If
'      End If
'    End If
#End If

    ' ------------------------------------------------------
    ' Relevante Werte in idvDateien f|fffd|r diese Datei setzen! ENDE
    ' ------------------------------------------------------




    Dim paramrs As Object
    Set paramrs = GetParamRS(conn)
    ' CreateObject("ADODB.Recordset")
    'paramrs.Open "SELECT * FROM gParameter", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
    DebugPrint tdebug, "AS15"

    trackpos = 160

    ' ------------------------------------------------------
    ' Risiko|fffd|berwachung - Muss schon geantwortet werden?
    ' ------------------------------------------------------


    Dim ok As Boolean
    ok = False

    Dim logRisikoklassen|fffd|nderung As Boolean
    logRisikoklassen|fffd|nderung = paramrs.Fields("LogRisikoklassenaenderung").value
    Dim paramrsid As Long
    paramrsid = paramrs.Fields("ParameterID").value
    DebugPrint tdebug, "Pr|fffd|fung Parameter zur Risikobefragung"
    trackpos = 170

    ' Freigegebene Programme werden befragt, wenn ein FreigebeneAlleXTage befragen eingestellt ist
    Dim freigegebenBefragen As Boolean
    freigegebenBefragen = False
    If CLng(GetSafeFieldPlus(paramrs, "FreigegebeneAlleXTage", "0")) > 0 Then
        ' Welchen Wert nehmen wir zum rechnen, letzte Befragung oder Aufnahme in DB?
        trackpos = 180
        Dim compDatFrei As Date
        compDatFrei = #1/1/1900#
        If Not IsNull(rs.Fields("LetzteBefragung").value) Then
          trackpos = 190
          compDatFrei = rs.Fields("LetzteBefragung").value
          DebugPrint tdebug, "FreigegebeneAlleXTage Vergl. mit LetzteBefragung: " & compDatFrei
        End If
        
        trackpos = 200
        If DateAdd("d", CLng(GetSafeFieldPlus(paramrs, "FreigegebeneAlleXTage", "0")), compDatFrei) <= Now Then
            freigegebenBefragen = True
            DebugPrint tdebug, "FreigegebeneAlleXTage: Treffer"
        Else
            DebugPrint tdebug, "FreigegebeneAlleXTage: Kein Treffer"
        End If
    End If
    
    trackpos = 210
    
    ' Nur Fragen stellen, wenn keine FreigabeID gesetzt ist (=> freigegebenes Programm)
    ' oder wenn freigegebenBefragen = true ist
    If WBGetValueLong(wbInExcelCurrentProjectInAccess, "_IDVTrackerFreigabeStatus" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix) <= 0 _
        Or freigegebenBefragen = True _
        Or G_cfgFreigegebeneBefragen = True Then
        trackpos = 220
        DebugPrint tdebug, "KO-Checks L.Befragung: " & rs.Fields("LetzteBefragung").value & " vor " & DateDiff("d", rs.Fields("LetzteBefragung").value, Now()) & " Tag(en)"

        ' Alle X-Mal
'        If paramrs.Fields("AlleXMal").Value > 0 Then
'            If rs.Fields("Speicheranzahl").Value Mod CLng(paramrs.Fields("AlleXMal").Value) = 0 Then
'                ok = True
'            End If
'        End If

        ' Speicherdatum
'        If Not ok Then
'            If Not IsNull(rs.Fields("LetzteBefragung").Value) Then
'                If paramrs.Fields("NachMindestensXTagen").Value > 0 Then
'                    If DateAdd("d", CLng(paramrs.Fields("NachMindestensXTagen").Value), rs.Fields("LetzteBefragung").Value) <= Now Then
'                        ok = True
'                    End If
'                End If
'            End If
'        End If

        ok = True
        Dim tCreation As Date
        Dim tLastAccess As Date
        Dim tLastWrite As Date

        If Not IsNull(rs.Fields("LetzteBefragung").value) Then
            If paramrs.Fields("FruehestensAlleXTageFragen").value > 0 Then
                If DateAdd("d", CLng(paramrs.Fields("FruehestensAlleXTageFragen").value), rs.Fields("LetzteBefragung").value) > Now Then
                    DebugPrint DebType.tdebug, "KO: Fr.AlleXTage(" & paramrs.Fields("FruehestensAlleXTageFragen").value & "):" & rs.Fields("LetzteBefragung").value
                    ok = False
                End If
            End If
        End If
        
        trackpos = 230
        
        If Not IsNull(paramrs.Fields("OhneProgrammierungNichtBefrgn").value) Then
           If paramrs.Fields("OhneProgrammierungNichtBefrgn").value <> 0 Then
               If HasFormulaOrProgramming(conn, fileid) <= 0 Then
                   DebugPrint DebType.tdebug, "KO: OhneProgrammierungNichtBefragen"
                   ok = False
              End If
           End If
        End If
                      
        trackpos = 240
        
        If GetValueFromField(paramrs, "NichtVorXTagen", 0) > 0 Then
          ' Erst mal schauen, ob erste Speicherung |fffd|berhaupt gesetzt ist.
          If Not IsNull(rs.Fields("ErsteSpeicherung").value) Then
            If DateAdd("d", CLng(paramrs.Fields("NichtVorXTagen").value), rs.Fields("ErsteSpeicherung").value) > Now Then
                DebugPrint DebType.tdebug, "KO: NichtVXTagenES(" & paramrs.Fields("NichtVorXTagen").value & "):" & rs.Fields("ErsteSpeicherung").value
                ok = False
            End If
          ' Falls erste Speicherung nicht gesetzt ist wird versucht mit AufnahmeInDB zu checken
          ElseIf Not IsNull(rs.Fields("AufnahmeInDB").value) Then
            If DateAdd("d", CLng(paramrs.Fields("NichtVorXTagen").value), rs.Fields("AufnahmeInDB").value) > Now Then
            ' wenn KeinDruckenVorRisikobefragung gesetzt ist, muss sofort eine Risikobefragung kommen
'            If G_PARAM_KeinDruckenVorRisikobefragung = False Or UCase(Right(wbInExcelCurrentProjectInAccess.FullName, 4)) <> ".CSV" Then
                DebugPrint DebType.tdebug, "KO: NichtVXTagenAIDB(" & paramrs.Fields("NichtVorXTagen").value & "):" & rs.Fields("AufnahmeInDB").value
                ok = False
'            End If
            End If
          End If
        End If

        trackpos = 250

        ' Wenn keins der KO-Kriterien zutrifft, dann machen wir das hier
        If ok = True Then
              
              DebugPrint tdebug, "Kein KO-Kriterium zugetroffen, pr|fffd|fe ODER-Bedigungen"

              ok = False

              trackpos = 260

              ' wenn noch nie befragt worden, dann sofort fragen, wenn dieses Flag gesetzt ist
              If IsNull(rs.Fields("LetzteBefragung").value) Then
                  If Not IsNull(paramrs.Fields("ImmerBeimErstenMalFragen").value) Then
                      If paramrs.Fields("ImmerBeimErstenMalFragen").value <> 0 Then
                          DebugPrint tdebug, "ImmerBeimErstenMalFragen: Treffer"
                          ok = True
                        Else
                          DebugPrint tdebug, "ImmerBeimErstenMalFragen: Kein Treffer"
                       End If
                   End If
              End If
      
              trackpos = 270
              ' Alle X-Mal
              If Not ok Then
                If GetValueFromField(paramrs, "AlleXMal", 0) > 0 Then
                    If GetValueFromField(rs, "Speicheranzahl", 0) Mod CLng(paramrs.Fields("AlleXMal").value) = 0 Then
                        ok = True
                        DebugPrint tdebug, "AlleXMal: Treffer"
                    Else
                        DebugPrint tdebug, "AlleXMal: Kein Treffer"
                    End If
                End If
              End If
      
              trackpos = 280
              ' Speicherdatum
              If Not ok Then
                  If paramrs.Fields("NachMindestensXTagen").value > 0 Then
                      ' Welchen Wert nehmen wir zum rechnen, letzte Befragung oder Aufnahme in DB?
                      Dim compDat As Date
                      compDat = #1/1/1900#
                      trackpos = 290
                      If Not IsNull(rs.Fields("LetzteBefragung").value) Then
                        trackpos = 300
                        compDat = rs.Fields("LetzteBefragung").value
                        DebugPrint tdebug, "NachMindestensXTagen Vergl. mit LetzteBefragung: " & compDat
                      ElseIf Not IsNull(rs.Fields("AufnahmeInDB").value) Then
                        trackpos = 310
                        compDat = rs.Fields("AufnahmeInDB").value
                        If GetValueFromField(paramrs, "NichtVorXTagen", 0) > 0 Then
                          compDat = DateAdd("d", CLng(paramrs.Fields("NichtVorXTagen").value), compDat)
                        End If
                        DebugPrint tdebug, "NachMindestensXTagen Vergl. mit AufnInDB+NichVorXTagen: " & compDat
                      End If
                      
                      trackpos = 320
                      If DateAdd("d", CLng(paramrs.Fields("NachMindestensXTagen").value), compDat) <= Now Then
                          ok = True
                          DebugPrint tdebug, "NachMindestensXTagen: Treffer"
                      Else
                          DebugPrint tdebug, "NachMindestensXTagen: Kein Treffer"
                      End If
                  End If
              End If
      
              trackpos = 330
              ' Tabellen hinzugef|fffd|gt
              If Not ok Then
                  If paramrs.Fields("AnzahlNeueTabellen").value > 0 Then
                      If GetValueFromField(rs, "Tabellenanzahl", 0) > 0 Then
                        If G_DocInfo.m_Sheets - GetValueFromField(rs, "Tabellenanzahl", 0) >= GetValueFromField(paramrs, "AnzahlNeueTabellen", 0) Then
                          ok = True
                          DebugPrint tdebug, "AnzahlNeueTabellen: Treffer"
                        Else
                          DebugPrint tdebug, "AnzahlNeueTabellen: Kein Treffer"
                        End If
                      End If
                  End If
              End If
      
              trackpos = 340
              ' ab technischem Risiko
              If Not ok Then
                  If GetValueFromField(paramrs, "TechnischesRisikoAb", 0) > 0 Then
                    If Not IsNull(rs.Fields("LetzterScan").value) Then
                      If rs.Fields("ScanRisiko").value >= 0 Then
                        If IsNull(rs.Fields("LetztesTechRisk").value) = True And rs.Fields("ScanRisiko").value >= GetValueFromField(paramrs, "TechnischesRisikoAb", 0) Then
                          ok = True
                          DebugPrint tdebug, "TechnischesRisikoAb:LetztesTechRisk ist null"
                        ElseIf rs.Fields("LetztesTechRisk").value < GetValueFromField(paramrs, "TechnischesRisikoAb", 0) And rs.Fields("ScanRisiko").value >= GetValueFromField(paramrs, "TechnischesRisikoAb", 0) Then
                          ok = True
                          DebugPrint tdebug, "TechnischesRisikoAb: Treffer"
                        Else
                          DebugPrint tdebug, "TechnischesRisikoAb: Kein Treffer"
                        End If
                      End If
                    End If
                  End If
              End If
              
              trackpos = 350
              If Not ok Then
                  If GetValueFromField(paramrs, "ErhoehungTechRiskUmX", 0) > 0 Then
                    If Not IsNull(rs.Fields("LetzterScan").value) Then
                      If GetValueFromField(paramrs, "TechnischesRisikoAb", 0) <= rs.Fields("ScanRisiko").value And _
                        rs.Fields("ScanRisiko").value > 0 And GetValueFromField(rs, "LetztesTechRisk", 0) >= 0 Then
                        If GetValueFromField(rs, "LetztesTechRisk", 0) + GetValueFromField(paramrs, "ErhoehungTechRiskUmX", 0) < (rs.Fields("ScanRisiko").value + 0.001) Then
                          ok = True
                          DebugPrint tdebug, "ErhoehungTechRiskUmX: Treffer"
                        Else
                          DebugPrint tdebug, "ErhoehungTechRiskUmX: Kein Treffer"
                        End If
                      End If
                    End If
                  End If
              End If
' -----------
' EXCEL ZEUGS
' -----------
#If PROJECT_ACCESSTRACKER = 0 Then
              trackpos = 360
             ' Wenn ein Blattschutz drauf ist und noch nicht befragt wurde
              If Not ok Then
                If GetSafeFieldPlus(paramrs, "BlattschutzBefragen", False) = True Then
                  If IsNull(rs.Fields("LetzteBefragung").value) Then
                    If WBHasProtectedSheets(wbInExcelCurrentProjectInAccess) Then
                      ok = True
                      DebugPrint tdebug, "BlattschutzBefragen: Treffer"
                    Else
                      DebugPrint tdebug, "BlattschutzBefragen: Kein Treffer"
                    End If
                  End If
                End If
              End If

              
' Eh kein guter Parameter, ist rausgeflogen
              ' Dateigroessenveraenderung
'              If Not Ok Then
'                  If GetValueFromField(paramrs, "Dateigroessenveraenderung", 0) > 0 Then
'                      If rs.Fields("Dateigroesse").Value > 0 Then
'                        If MyFileLen(sharefname) >= rs.Fields("Dateigroesse").Value * (1 + paramrs.Fields("Dateigroessenveraenderung").Value) Then
'                          Ok = True
'                          DebugPrint tdebug, "Dateigroessenveraenderung: Treffer"
'                        Else
'                          DebugPrint tdebug, "Dateigroessenveraenderung: Kein Treffer"
'                        End If
'                      End If
'                  End If
'              End If
              
              ' XXX ist anders als in der DLL!
              trackpos = 370
              ' G_Docinfo.m_Formulas muss angepasst werden, da vielleicht der ECC was anderes ermittelt hat
'              If GetValueFromField(rs, "ECCFormelnGesamt", 0) > 0 And GetValueFromField(rs, "ECCFormelnGesamt", 0) <> G_DocInfo.m_Formulas Then
'                G_DocInfo.m_Formulas = GetValueFromField(rs, "ECCFormelnGesamt", 0)
'              End If
      
      
              trackpos = 380
              ' Mindestformelanzahl
              If Not ok Then
                  If GetValueFromField(paramrs, "Mindestformelanzahl", 0) > 0 Then
                      ' Wenn die Formelanzahl >= der Mindestformelanzahl und (die letzte Formelanzahl kleiner als die Mindestformelanzahl war
                      ' oder zum ersten mal gespeichert wurde)
                      ' Die Pr|fffd|fung auf die vorherige Anzahl ist deshalb wichtig, damit nicht jedes mal gefragt wird, wenn der Wert einmal
                      ' |fffd|berschritten wird
                      If G_DocInfo.m_Formulas >= 0 Then
                        If G_DocInfo.m_Formulas >= paramrs.Fields("Mindestformelanzahl").value And _
                          (rs.Fields("Formelanzahl").value < paramrs.Fields("Mindestformelanzahl").value Or GetValueFromField(rs, "Speicheranzahl", 0) = 1 Or IsNull(rs.Fields("LetzteBefragung").value)) Then
                          ok = True
                          DebugPrint tdebug, "Mindestformelanzahl: Treffer"
                        Else
                          DebugPrint tdebug, "Mindestformelanzahl: Kein Treffer"
                        End If
                      End If
                  End If
              End If
              
              trackpos = 390
              ' Formelanzahlveraenderung
              If Not ok Then
                  ' Dieser Parameter wird schon mal nur dann gepr|fffd|ft, wenn |fffd|berhaupt schon mal gespeichert wurde!
                  If GetValueFromField(rs, "Speicheranzahl", 0) > 1 Then
                    If GetValueFromField(paramrs, "Formelanzahlveraenderung", 0) > 0 Then
                    
                        ' Wenn es Formeln gibt (die (leider) nicht abgesichert sind)
                        If G_DocInfo.m_Formulas >= 0 Then
                          If G_DocInfo.m_Formulas - GetValueFromField(rs, "Formelanzahl", 0) >= GetValueFromField(paramrs, "Formelanzahlveraenderung", 0) Then
                            ok = True
                            DebugPrint tdebug, "Formelanzahlveraenderung: Treffer"
                          Else
                            DebugPrint tdebug, "Formelanzahlveraenderung: Kein Treffer"
                          End If
                        End If
                        
                        ' Alternativ wird das noch mal mit den ECC-Formeln gecheckt, denn da sind auch die abgesicherten mit drin
'                        If IsNull(dateiRs.Fields("LetzterScan").Value) = False And IsNull(dateiRs.Fields("ECCFormelnGesamt").Value) = False Then
'                          Dim eccFormelnAlt As Long
'                          eccFormelnAlt = -1
'                          Dim eccrs As Object
'                          Set eccrs = CreateObject("ADODB.Recordset")
'                          eccrs.Open "SELECT FORMULAAMOUNT FROM ECCAnalyse where idvDateiID = " & dateiRs.Fields("idvDateiID").Value & " ORDER BY Datum DESC", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
'                          Do While Not eccrs.EOF
'                            If eccrs.Fields("Datum").Value < dateiRs.Fields("LetzterScan").Value Then
'                              eccFormelnAlt = eccrs.Fields("FORMULAAMOUNT").Value
'                              Exit Do
'                            End If
'                            eccrs.MoveNext
'                          Loop
'                          eccrs.Close
'                          Set eccrs = Nothing
'
'                          If eccFormelnAlt > -1 Then
'                            If dateiRs.Fields("ECCFormelnGesamt").Value - eccFormelnAlt >= GetValueFromField(paramrs, "Formelanzahlveraenderung", 0) Then
'                              ok = True
'                              DebugPrint tdebug, "Formelanzahlveraenderung(ECC): Treffer"
'                            Else
'                              DebugPrint tdebug, "Formelanzahlveraenderung(ECC): Kein Treffer"
'                            End If
'                          End If
'                        End If
                        
                    End If
                  End If
              End If
#End If
      
              trackpos = 400
              ' AnzahlNeuerScripte
              If Not ok Then
                  If GetValueFromField(paramrs, "AnzahlNeuerScripte", 0) > 0 Then
                      If G_DocInfo.m_Macros - GetValueFromField(rs, "AnzahlMakros", 0) >= GetValueFromField(paramrs, "AnzahlNeuerScripte", 0) Then
                          ok = True
                          DebugPrint tdebug, "AnzahlNeuerScripte: Treffer"
                       Else
                          DebugPrint tdebug, "AnzahlNeuerScripte: Kein Treffer"
                      End If
                  End If
              End If
      
              trackpos = 410
              ' AnzahlNeuerVerknuepfungen
              If Not ok Then
                  If GetValueFromField(paramrs, "AnzahlNeuerVerknuepfungen", 0) > 0 Then
                      If G_DocInfo.m_ExtRefs - rs.Fields("AnzahlExterneReferenzen").value >= paramrs.Fields("AnzahlNeuerVerknuepfungen").value Then
                          ok = True
                          DebugPrint tdebug, "AnzahlNeuerVerknuepfungen: Treffer"
                       Else
                          DebugPrint tdebug, "AnzahlNeuerVerknuepfungen: Kein Treffer"
                      End If
                  End If
              End If
              
              trackpos = 420
              DebugPrint tdebug, "AS19"
              If dateiIstAusgeschlossen = True Or warVBASaveAs = True Then
                If dateiIstAusgeschlossen = True Then
                  DebugPrint tdebug, "AS19.1-Datei ausgeschlossen"
                Else
                  DebugPrint tdebug, "AS19.2-warVBASaveAs"
                End If
                ok = False
              End If
              
      
              trackpos = 430
              If ok Then
                  DebugPrint tdebug, "AS20-Risikowert checken"
                  Dim newrisk As Double
                  
                  Dim Hinweistext As String
                  trackpos = 440
                  If GetSetting(appname:="Stromwerken", Section:=progNameShort, Key:="Ersthinweis", Default:=-1) = -1 Then
                    DebugPrint tdebug, "AS20.1-1. Hinweistext"
                    SaveSetting _
                           appname:="Stromwerken", _
                           Section:=progNameShort, _
                           Key:="Ersthinweis", _
                           Setting:=0
                    'Hinweistext = GetValueFromField(paramrs, "DokuErklaerungstext", "")
                    trackpos = 450
                    Hinweistext = gTranslation.GetSafeStringReplace("DokuErklaerungstext")
                    If Hinweistext <> "" Then
                      trackpos = 460
                      frmHinweise.Hinweistext = Hinweistext
                      'frmHinweise.Caption = ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")" & " - Hinweis"
                      frmHinweise.Caption = ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")" & " - " & FMT0("THISADDIN_3")
                      trackpos = 470
                      frmHinweise.Show vbModal
                      trackpos = 480
                    End If
                  End If
                  
                  
                  trackpos = 490
                  ' Wenn das Verschieben von Fragen erlaubt ist, dann kann es sein, dass wir doch nicht befragen
                  If G_PARAM_MaximaleAnzahlVerschiebungenDerBefragung > 0 Or G_PARAM_MaximaleAnzahlVerschiebungenDerBefragung = -1 Then
                    DebugPrint tdebug, "AS20.1-Risikofragen verschiebbar?"
                    trackpos = 500
                    ' Ok, ist erlaubt, dann wollen wir doch mal schauen, ob schon verschoben wurde
                    If Not IsNull(rs.Fields("FruehestensWiederFragenAm").value) Then
                      ' Ja, es gibt einen Termin, dann pr|fffd|fen ob dieser bereits |fffd|berschritten wurden
                      If Now < rs.Fields("FruehestensWiederFragenAm").value Then
                        ' Nein, noch nicht, dann nicht befragen
                        DebugPrint tdebug, "AS20.2-Risikobefragung noch verschoben"
                        ok = False
                      End If
                    End If
                    
                    trackpos = 510
                    DebugPrint tdebug, "AS20.2"
                    If ok Then
                      ' Wenn ok, dann erst mal pr|fffd|fen, ob |fffd|berhaupt noch eine Verschiebung der Befragung erlaubt ist! Wenn keine mehr erlaubt ist, dann wird befragt
                      If IsNull(rs.Fields("AnzahlVerschiebungenBefragung").value) = True Or rs.Fields("AnzahlVerschiebungenBefragung").value <= G_PARAM_MaximaleAnzahlVerschiebungenDerBefragung Or G_PARAM_MaximaleAnzahlVerschiebungenDerBefragung = -1 Then
                        If IsNull(rs.Fields("AnzahlVerschiebungenBefragung").value) Then
                          rs.Fields("AnzahlVerschiebungenBefragung").value = 1
                        Else
                          rs.Fields("AnzahlVerschiebungenBefragung").value = rs.Fields("AnzahlVerschiebungenBefragung").value + 1
                        End If
                        ' Im Fall, dass eine Befragung noch verschoben werden kann, wird jetzt immer befragt. Aber der User kann die Befragung abbrechen.
                        'If MsgBox("Eine Risikobefragung der Datei ist erforderlich. M|fffd|chten Sie die Fragen beantworten? (Bei NEIN wird die Befragung um " & G_PARAM_VerschiebungsdauerInTagen & " Tag(e) verschoben. Sie k|fffd|nnen die Befragung aber auch jederzeit |fffd|ber die Men|fffd|leiste ansto|fffd|en)", vbYesNo + vbQuestion + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")") = vbNo Then
                        '  Ok = False
                        '  rs.Fields("FruehestensWiederFragenAm").value = DateSerial(year(Now), month(Now), day(Now) + G_PARAM_VerschiebungsdauerInTagen)
                        'End If
                      End If
                    End If
                    DebugPrint tdebug, "AS20.3"
                    
                  End If
                  
                  trackpos = 520
                  
                  ' War in den letzten X Minuten eine Risikobefragung? Wenn ja, dann machen wir nix!
                  If G_PARAM_XMinutenNichtBefragen > 0 Then
                  
                    Dim letzteBefragung As Date
                    letzteBefragung = LetztesBefragungsdatum
                  
                    trackpos = 530
                    If DateAdd("n", G_PARAM_XMinutenNichtBefragen, letzteBefragung) >= Now Then
                      DebugPrint tdebug, "AS21.1-XMinutenNichtBefragen:JA"
                      ok = False
                    Else
                      DebugPrint tdebug, "AS21.1-XMinutenNichtBefragen:NEIN"
                    End If
                    
                  End If
                      
                  trackpos = 540
                  
                  If Not ok Then
                      trackpos = 550
                      DebugPrint tdebug, "KEINE Risikobefragung, kein Paramter hat getroffen"
                  Else
                      DebugPrint tdebug, "Risikobefragung durchf|fffd|hren"
                      SaveSetting _
                             appname:="Stromwerken", _
                             Section:=progNameShort, _
                             Key:="LetzteBefragung", _
                             Setting:=Now
                      
                      Dim resRisikoFragen As Boolean
                      
                      trackpos = 560
                      didRisikobefragung = True
                      resRisikoFragen = DoRisikoFragen(GetDriveAndPathFromUNC(wbInExcelCurrentProjectInAccess.fullname), wbInExcelCurrentProjectInAccess.Application, wbInExcelCurrentProjectInAccess, rs, uncpathfname, logRisikoklassen|fffd|nderung, newrisk, conn, paramrsid)
                      If newrisk = -200# Then
                        ' Die Befragung wurde vom User abgebrochen (geht nur wenn noch Verschiebungen erlaubt waren)
                        trackpos = 570
                        rs.Fields("FruehestensWiederFragenAm").value = DateSerial(year(Now), month(Now), day(Now) + G_PARAM_VerschiebungsdauerInTagen)
                      Else
                        trackpos = 580
                        rs.Fields("BefragungDurchfuehren").value = 0
                        
                        DebugPrint DebType.tTime, "Doku 4"
                        
                        If ok Then
                          trackpos = 590
                          StoreStandardStuff rs, True, uncpathfname, sharefname
                        End If
                        
                        trackpos = 600
                        If resRisikoFragen Then
                          DebugPrint tdebug, "AS21.3-Newrisk:" & newrisk
                          DebugPrint tdebug, "AS21.4-Schwelle f|fffd|r Doku:" & G_PARAM_DokuAbRisikowert
                          trackpos = 610
                          If newrisk >= G_PARAM_DokuAbRisikowert And G_PARAM_DokuAbRisikowert >= 0 And Not isSharedWb Then
                              trackpos = 620
                              rs.Update
                              trackpos = 640
                              Set rs = Nothing
                              Set rs = OpenRS("SELECT * FROM idvDateien WHERE IDVDATEIID=" & fileid, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockPessimistic)
                              
                              DebugPrint tdebug, "AS21.5-Dokufenster"
                              trackpos = 641
                              ShowDoku wbInExcelCurrentProjectInAccess.Application, rs, conn, wbInExcelCurrentProjectInAccess
                              trackpos = 650
                              DebugPrint tdebug, "AS21.6-Dokufenster fertig"
                          Else
                              DebugPrint tdebug, "AS21.6-KEIN Dokufenster"
                          End If
                        End If
                      End If
                  End If
              End If
        End If
    
        trackpos = 660
        DebugPrint tdebug, "AS23"
    Else
        trackpos = 670
        DebugPrint DebType.tdebug, "AS25-Datei freigeg. oder in Freigabe"
    End If
    
    trackpos = 680
    StoreStandardStuff rs, IIf(GetValueFromField(rs, "Speicheranzahl", 0) = 1, True, False), uncpathfname, sharefname
    
    trackpos = 690
    If GetSafeFieldPlus(rs, "idvDateiID", 0) > 0 And GetSafeFieldPlus(rs, "FreigabeStatus", 0) = 2 Then
      trackpos = 700
      ScanFileViaSched conn, GetSafeFieldPlus(rs, "idvDateiID", 0), False
    End If
    
    trackpos = 710
    
    rs.Update
    If didRisikobefragung = True And G_cfgVerlustFreigabeBeiBefragung = True And WBGetValueLong(wbInExcelCurrentProjectInAccess, "_IDVTrackerFreigabeStatus" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix) = 2 Then
      ' Risikobefragung durchgef|fffd|hrt
      FreigabeEntfernen wbInExcelCurrentProjectInAccess.Application, rs, conn, wbInExcelCurrentProjectInAccess, FMT1("THISADDIN_143", rs.Fields("idvDateiID").value), True
    End If
    trackpos = 720
    rs.Close
    Set rs = Nothing

    trackpos = 730
    paramrs.Close
    Set paramrs = Nothing

    Set G_DocInfo = Nothing
    DebugPrint tdebug, "AS Ende"
    
    
    
    trackpos = 740
    SetzeAmpelStatus wbInExcelCurrentProjectInAccess, conn
    trackpos = 750
    ShowAmpelStatus wbInExcelCurrentProjectInAccess
    trackpos = 760
    Exit Sub

nogo:
    Set G_DocInfo = Nothing
    DebugPrint DebType.tERROR, "AfterSave - Pos: " & trackpos & " Err: " & err.Number & " - " & err.Description & " - " & err.Source
End Sub

Function LetztesBefragungsdatum() As Date
On Error GoTo fehler
    LetztesBefragungsdatum = GetSetting( _
             appname:="Stromwerken", _
             Section:=progNameShort, _
             Key:="LetzteBefragung", _
             Default:=#1/1/1900#)
    Exit Function
fehler:
LetztesBefragungsdatum = #1/1/1900#
End Function

Sub ShowFragen(ByVal uncpathfname As String, ByRef wbInExcelCurrentProjectInAccess As Object, ByRef rs As Object, ByVal oldid As Long, ByVal oldversion As Long, ByRef conn As Object, warVBASaveAs As Boolean)
    
    Dim paramrs As Object
    ' Set paramrs = CreateObject("ADODB.Recordset")
    DebugPrint tdebug, "AS15"

On Error GoTo errorShowFragen

    DebugPrint DebType.tTime, "!ShowFragen"
    Set paramrs = GetParamRS(conn)   ' .Open "SELECT * FROM gParameter", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
    
    Dim ok As Boolean
    ok = True
    Dim logRisikoklassen|fffd|nderung As Boolean
    logRisikoklassen|fffd|nderung = paramrs.Fields("LogRisikoklassenaenderung").value
    Dim paramrsid As Long
    paramrsid = paramrs.Fields("ParameterID").value
    Dim newrisk As Double
    
    
    Dim Hinweistext As String
    If GetSetting(appname:="Stromwerken", Section:=progNameShort, Key:="Ersthinweis", Default:=-1) = -1 Then
      DebugPrint tdebug, "ShowFragen Hinweistext"
      SaveSetting _
             appname:="Stromwerken", _
             Section:=progNameShort, _
             Key:="Ersthinweis", _
             Setting:=0
      'Hinweistext = GetValueFromField(paramrs, "DokuErklaerungstext", "")
      Hinweistext = gTranslation.GetSafeStringReplace("DokuErklaerungstext")
      If Hinweistext <> "" Then
        frmHinweise.Hinweistext = Hinweistext
        'frmHinweise.Caption = ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")" & " - Hinweis"
        frmHinweise.Caption = ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")" & " - " & FMT0("THISADDIN_3")
        frmHinweise.Show vbModal
      End If
    End If

    ' check ob verschoben werden kann und soll
    If IsNull(rs.Fields("AnzahlVerschiebungenBefragung").value) = True Or rs.Fields("AnzahlVerschiebungenBefragung").value < G_PARAM_MaximaleAnzahlVerschiebungenDerBefragung Or G_PARAM_MaximaleAnzahlVerschiebungenDerBefragung = -1 Then
        If IsNull(rs.Fields("AnzahlVerschiebungenBefragung").value) Then
          rs.Fields("AnzahlVerschiebungenBefragung").value = 1
        Else
          rs.Fields("AnzahlVerschiebungenBefragung").value = rs.Fields("AnzahlVerschiebungenBefragung").value + 1
        End If
        ' Im Fall, dass eine Befragung noch verschoben werden kann, wird jetzt immer befragt. Aber der User kann die Befragung abbrechen.
        ' FruehestensWiederFragenAm wird dann nach der Befragung gesetzt falls abgebrochen wurde
        'If MsgBox("Eine Risikobefragung der Datei ist erforderlich. M|fffd|chten Sie die Fragen beantworten? (Bei NEIN wird die Befragung um " & G_PARAM_VerschiebungsdauerInTagen & " Tag(e) verschoben. Sie k|fffd|nnen die Befragung aber auch jederzeit |fffd|ber die Men|fffd|leiste ansto|fffd|en)", vbYesNo + vbQuestion + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")") = vbNo Then
        '    Ok = False
        '    rs.Fields("FruehestensWiederFragenAm").value = DateSerial(year(Now), month(Now), day(Now) + G_PARAM_VerschiebungsdauerInTagen)
        'End If
    End If

    If ok = True Then
        ' Befragung durchf|fffd|hren
        DebugPrint tdebug, "ShowFragen Befragung durchf|fffd|hren"
        
        DoRisikoFragen GetDriveAndPathFromUNC(wbInExcelCurrentProjectInAccess.fullname), wbInExcelCurrentProjectInAccess.Application, wbInExcelCurrentProjectInAccess, rs, uncpathfname, logRisikoklassen|fffd|nderung, newrisk, conn, paramrsid
        If newrisk = -200# Then
            ' Die Befragung wurde vom User abgebrochen (geht nur wenn noch Verschiebungen erlaubt waren)
            rs.Fields("FruehestensWiederFragenAm").value = DateSerial(year(Now), month(Now), day(Now) + G_PARAM_VerschiebungsdauerInTagen)
        Else
          rs.Fields("BefragungDurchfuehren").value = 0
      
          ' DebugPrint DebType.tTime, "Doku 4"
  
          ' wenn es nen Fehler bei der Doku gibt, will ich trotzdem das BefragungDurchfuehren Flag zur|fffd|cksetzen
          ' sonst kommt der Fehler eventuell immer wieder beim |fffd|ffnen
On Error GoTo errorShowFragenMitUpdate
          
          DebugPrint tdebug, "ShowFragen-Newrisk:" & newrisk
          DebugPrint tdebug, "ShowFragen-Schwelle f|fffd|r Doku:" & G_PARAM_DokuAbRisikowert
          ' eventuell die Doku anzeigen
          If newrisk >= G_PARAM_DokuAbRisikowert And G_PARAM_DokuAbRisikowert >= 0 Then
              DebugPrint tdebug, "ShowFragen-Dokufenster"
              ShowDoku wbInExcelCurrentProjectInAccess.Application, rs, conn, wbInExcelCurrentProjectInAccess
              DebugPrint tdebug, "ShowFragen-Dokufenster fertig"
          Else
              DebugPrint tdebug, "ShowFragen-KEIN Dokufenster"
          End If
        End If
    End If
    
errorShowFragenMitUpdate:
    rs.Update

errorShowFragen:
    rs.Close
    Set rs = Nothing

    paramrs.Close
    Set paramrs = Nothing

    ShowAmpelStatus wbInExcelCurrentProjectInAccess

End Sub

Sub SetStandardStuff(ByRef rs As Object)

  rs.Fields("Tabellenanzahl").value = 0
  rs.Fields("Formelanzahl").value = 0
  
  rs.Fields("TblaetterOhnBlattschutzMitFrml").value = 0
  rs.Fields("TblaetterMitBlattschutz").value = 0
  rs.Fields("AnzahlNichtAbgesicherteFormeln").value = 0
  
  rs.Fields("AnzahlMakros").value = 0
  rs.Fields("Anzahlexternereferenzen").value = 0
  
  rs.Fields("CheckerVersion").value = -1

  ' VORSICHT, auch unten einf|fffd|gen in StoreStandardStuff
End Sub

Sub StoreStandardStuff(ByRef rs As Object, forceStore As Boolean, uncpathfname As String, sharefname As String)
  On Error Resume Next

  DebugPrint tdebug, "StoreStandardStuff Start"

  If IsNull(rs.Fields("Dateigroesse").value) Or rs.Fields("Dateigroesse").value = 0 Or forceStore = True Then
    If FileExists(uncpathfname) Then
      rs.Fields("Dateigroesse").value = MyFileLen(sharefname)
    Else
      rs.Fields("Dateigroesse").value = 0
    End If
  End If

  If Not G_DocInfo Is Nothing Then
          rs.Fields("Tabellenanzahl").value = G_DocInfo.m_Sheets
          
        #If PROJECT_ACCESSTRACKER = 0 Then
          
          If IsNull(rs.Fields("Formelanzahl").value) = True Or forceStore = True Then
            rs.Fields("Formelanzahl").value = IIf(G_DocInfo.m_Formulas >= 0, G_DocInfo.m_Formulas, 0)
          End If
        
          If IsNull(rs.Fields("TblaetterOhnBlattschutzMitFrml").value) = True Or forceStore = True Then
            rs.Fields("TblaetterOhnBlattschutzMitFrml").value = G_DocInfo.m_UnprotectedWorksheetsWithFormulas
          End If
          
          If IsNull(rs.Fields("TblaetterMitBlattschutz").value) = True Or forceStore = True Then
            rs.Fields("TblaetterMitBlattschutz").value = G_DocInfo.m_Protectedsheets
          End If
          
          If IsNull(rs.Fields("AnzahlNichtAbgesicherteFormeln").value) = True Or forceStore = True Then
            rs.Fields("AnzahlNichtAbgesicherteFormeln").value = G_DocInfo.m_Unprotectedformulas
          End If
        
        #End If
          
          If IsNull(rs.Fields("AnzahlMakros").value) = True Or forceStore = True Then
            rs.Fields("AnzahlMakros").value = G_DocInfo.m_Macros
          End If
          
          If IsNull(rs.Fields("AnzahlExterneReferenzen").value) = True Or forceStore = True Then
            rs.Fields("AnzahlExterneReferenzen").value = G_DocInfo.m_ExtRefs
          End If
  End If

  DebugPrint tdebug, "StoreStandardStuff End"

  ' VORSICHT, auch oben einf|fffd|gen in SetStandardStuff
End Sub

Function EvalScriptResult(ByRef objScript As Object, ByVal funcName As String, ByVal s As String) As Variant
    On Error GoTo nogo
    EvalScriptResult = Empty
    
    objScript.Reset
'    objScript.Language = "VBScript"
    objScript.AddCode Trim(s)
    EvalScriptResult = objScript.Run(funcName)
nogo:
End Function

Function CalcRiskFromScript(fachlicherRisikowert As Double, ByRef rs As Object, ByRef conn As Object, ByRef Schutzbedarf As Long, _
  ByRef vertr As Long, ByRef verfueg As Long, ByRef integ As Long, ByRef ik As Long, ByRef authent As Long) As Double
    CalcRiskFromScript = fachlicherRisikowert
    On Error GoTo nogo
    
    Dim paramrs As Object
    Set paramrs = GetParamRS(conn)
    Dim script As String
    script = GetSafeField(paramrs, "Risikoscript")
    
    ' Wenn wir ein Script haben, das Script mit dem Eingaberisikowert ausfuehren
    If script <> "" Then
        ' Script in den Funktionsblock packen
        script = "Dim Schutzbedarf, Vertraulichkeit, Verfuegbarkeit, Integritaet, Informationsklassifizierung, Authentizitaet" & vbCrLf & _
            "Function Risikowert()" & vbCrLf & _
            "Schutzbedarf = #idvDateien.Schutzbedarf#" & vbCrLf & _
            "Vertraulichkeit = #idvDateien.Vertraulichkeit#" & vbCrLf & _
            "Verfuegbarkeit = #idvDateien.Verfuegbarkeit#" & vbCrLf & _
            "Integritaet = #idvDateien.Integritaet#" & vbCrLf & _
            "Informationsklassifizierung = #idvDateien.Informationsklassifizierung#" & vbCrLf & _
            "Authentizitaet = #idvDateien.Authentizitaet#" & vbCrLf & _
            "Risikowert = #FachlicherRisikowert#" & vbCrLf & _
            script & vbCrLf & _
            "End Function"
            
        Dim col As New Collection
        If PrepareScriptVars(rs, col, Nothing) Then
            ' Der Eingaberisikowert wird eine extra Konstante: #FachlicherRisikowert#
            col.add str(fachlicherRisikowert), UCase("FachlicherRisikowert")
            
            Dim errTxt As String
            errTxt = ""
            Dim erram As Long
            erram = 0
            Dim objScript As Object
            Dim cso As Object
            Set cso = New CScriptObject
            Set objScript = cso.GetObject
            'objScript.Language = "VBScript"
            Dim resultscript As String
            ' Die Scriptvariablen ersetzen
            resultscript = PlausitestScriptinterpreter(objScript, script, errTxt, erram, col)
            If erram = 0 Then
                Dim res As Variant
                res = EvalScriptResult(objScript, "Risikowert", resultscript)
                If Not IsEmpty(res) Then
                    Dim d As Double
                    d = res
                    CalcRiskFromScript = ClampDbl(d, 0#, 1#)
                    Schutzbedarf = objScript.Eval("Schutzbedarf")
                    vertr = objScript.Eval("Vertraulichkeit")
                    verfueg = objScript.Eval("Verfuegbarkeit")
                    integ = objScript.Eval("Integritaet")
                    authent = objScript.Eval("Authentizitaet")
                    ik = objScript.Eval("Informationsklassifizierung")
                End If
            End If
            Set objScript = Nothing
            Set cso = Nothing
        End If
    End If
nogo:
End Function

' -1, wenn noch nicht gescannt
' 0, wenn weder Formeln noch VBA Zeugs
' 1, wenn Formeln oder VBA Zeugs
Function HasFormulaOrProgramming(ByRef conn As Object, ByVal fileid As Long) As Long

    HasFormulaOrProgramming = -1
    On Error GoTo raus
    
#If PROJECT_FILETRACKER = 0 Then
    
    Dim rs As Object
#If PROJECT_ACCESSTRACKER = 0 Then
    ' ECC
    Set rs = OpenRS("Select * from A_ECC_FORMELNPROGRAMMIERUNG where idvDateiID = " & fileid, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockOptimistic)
#Else
    ' ACC
    Set rs = OpenRS("Select * from A_ACC_FORMELNPROGRAMMIERUNG where idvDateiID = " & fileid, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockOptimistic)
#End If
    If Not rs Is Nothing Then
        If rs.EOF = False Then
            If GetSafeFieldPlus(rs, "Anzahl", 0) = 0 Then
                HasFormulaOrProgramming = 0
            Else
                HasFormulaOrProgramming = 1
            End If
        End If
        rs.Close
        Set rs = Nothing
    End If

#End If ' PROJECT_FILETRACKER
    
raus:
End Function

Function DoRisikoFragen(sharename As String, ByRef officeapp As Object, ByRef curdoc As Object, ByRef rs As Object, ByVal uncpathfname As String, _
                        ByVal logRisikoklassen|fffd|nderung As Boolean, ByRef newrisk As Double, ByRef conn As Object, _
                        paramrsid As Long, Optional freiwillig As Boolean = False) As Boolean

    DoRisikoFragen = True
    ' Alte Fragen anzeigen
    
    Dim ergebnis As String
    If G_PARAM_FragenAntwortenScreen Then
      If SindFragenProzesseGeaendert(rs, conn) = 0 Then
        If GetDateiFragenUndAntworten(rs, conn, ergebnis) Then
          frmLetzteAntworten.Hinweistext = ergebnis
          frmLetzteAntworten.LetzteBeantwortungVon = GetSafeField(rs, "LetzteBefragungUserID")
          frmLetzteAntworten.LetzteBeantwortungAm = GetSafeField(rs, "LetzteBefragung")
          frmLetzteAntworten.Caption = ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")" & " - Letzte Antworten"
          G_AntwortenNeuGeben = False
          frmLetzteAntworten.Show vbModal
          If G_AntwortenNeuGeben = False Then
            DoRisikoFragen = False
            rs.Fields("LetzteBefragung").value = Now
            rs.Fields("LetzteBefragungUserID").value = GetUserNameUCASE()
            rs.Fields("LetztesTechRisk").value = rs.Fields("ScanRisiko").value
            Exit Function
          End If
        End If
      End If
    End If

    
    Dim i As Long
   
    Dim anzahlVerschiebungen As Long
    ' Wenn freiwillig, dann wird der Text wieviele Verschiebungen noch verfuegbar sind nicht angezeigt (anzahlVerschiebungen = -1)
    ' Wenn anzahlVerschiebungen = 0, dann wird der Abbruch Button nicht angezeigt
    ' Wenn anzahlVerschiebungen = 2, dann kann der User unendlich verschieben. Die Anzahl der Verschiebungen wird nicht angezeigt, nur bis wann wieder verschoben wurde
    anzahlVerschiebungen = IIf(freiwillig, -1, 0)
    If Not freiwillig Then
        If G_PARAM_MaximaleAnzahlVerschiebungenDerBefragung = -1 Then
          anzahlVerschiebungen = -2
        Else
          If IsNull(rs.Fields("AnzahlVerschiebungenBefragung").value) Then
              anzahlVerschiebungen = G_PARAM_MaximaleAnzahlVerschiebungenDerBefragung - 0
          Else
              ' rs.Fields("AnzahlVerschiebungenBefragung") wurde hier vom caller schon erhoeht -> also +1
              anzahlVerschiebungen = G_PARAM_MaximaleAnzahlVerschiebungenDerBefragung - rs.Fields("AnzahlVerschiebungenBefragung").value + 1
              If anzahlVerschiebungen < 0 Then
                  ' Das waere ein Fehlerfall. Aber sicherstellen, dass wir dann die Befragung nicht Abbrechbar machen!
                  anzahlVerschiebungen = 0
              End If
              If anzahlVerschiebungen > G_PARAM_MaximaleAnzahlVerschiebungenDerBefragung Then
                   anzahlVerschiebungen = G_PARAM_MaximaleAnzahlVerschiebungenDerBefragung
              End If
          End If
        End If
    End If
    
    Dim frgdlgcol As Collection
    Set frgdlgcol = New Collection
    newrisk = CreateFragen2(sharename, officeapp, frgdlgcol, conn, rs, anzahlVerschiebungen)

    ' bei -2000% Antwort einfach rausspringen
    If newrisk = -200 Then
        DebugPrint DebType.tdebug, "Abbruch der Befragung (Sprung -2)"
        Set G_Befragung = Nothing
        Exit Function
    End If
    
    ' Hier auch die eingegebenen Kommentare in idvDateienFragenKommentar speichern
    ' Erstmal bereits existierende loeschen!
    conn.Execute "DELETE FROM idvDateienFragenKommentar WHERE idvDateiID = " & rs.Fields("idvDateiID").value
    
    ' Kennzeichen l|fffd|schen
    conn.Execute "delete from idvDateienAntwortKennzeichen where idvDateien = " & rs.Fields("idvDateiID").value
    
    Dim antworten As String
    antworten = ""
    Dim a As Long
    
    Dim antwortFunkRs As Object
    Set antwortFunkRs = CreateObject("ADODB.Recordset")
    
    rs.Fields("Schutzbedarf").value = 0
    antwortFunkRs.Open "SELECT FrageAntwortID, AntwortFunktion, AntwortFunktion2, AntwortFunktion3 FROM gFragenAntworten", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
    
    Dim awf(C_MAXANTWORTFUNCFELDER)
    For a = 1 To C_MAXANTWORTFUNCFELDER
      awf(a) = 0
    Next a
    
    Dim frgDlg As CFragenDlg
    Dim ant As CAntwort
    Dim drs As Object
    Set drs = OpenRS("SELECT * FROM idvDateienFragenKommentar WHERE idvDateiID = 0", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockOptimistic)
    For Each frgDlg In frgdlgcol
      For Each ant In frgDlg.m_Antworten
            If ant.m_AntwortID <> PA_ANTWORT_NONE And ant.m_AntwortID <> PA_ANTWORT_SEL Then
                If antworten <> "" Then
                    antworten = antworten & ","
                End If
                antworten = antworten & CStr(ant.m_AntwortID)
                
                If Not G_Befragung Is Nothing Then
                    ' Kommentar in idvDateienFragenKommentar speichern
                    Dim frageID As Long
                    frageID = G_Befragung.GetFrageIDFromAntwortID(ant.m_AntwortID)
                    If G_Befragung.HasNewComment(frageID) Then
                        If Not drs Is Nothing Then
                            drs.AddNew
                            drs.Fields("idvDateiID") = rs.Fields("idvDateiID").value
                            drs.Fields("FragenID") = frageID
                            drs.Fields("UserText") = G_Befragung.GetNewComment(frageID)
                        End If
                    End If
                End If
                
                If antwortFunkRs.EOF <> True Or antwortFunkRs.BOF <> True Then
                  antwortFunkRs.MoveFirst
                  antwortFunkRs.Find "FrageAntwortID=" & ant.m_AntwortID
                  If Not antwortFunkRs.EOF Then
                    CheckantwortFunktionArr antwortFunkRs, awf, "AntwortFunktion"
                    CheckantwortFunktionArr antwortFunkRs, awf, "AntwortFunktion2"
                    CheckantwortFunktionArr antwortFunkRs, awf, "AntwortFunktion3"
                  End If
                End If
            End If
      Next ant
    Next frgDlg
    If Not drs Is Nothing Then
        If drs.RecordCount > 0 Then
            drs.Update
        End If
        drs.Close
        Set drs = Nothing
    End If
    
    Dim fragenVertr As Long
    Dim fragenVerfueg As Long
    Dim fragenInteg As Long
    Dim fragenAuthen As Long
    fragenVertr = -1
    fragenVerfueg = -1
    fragenInteg = -1
    fragenAuthen = -1
    
    Dim sb As Long
    sb = -1
    For a = 1 To C_MAXANTWORTFUNCFELDER
      Select Case a
          Case C_IDVDATFLD_INTEGRITAET
            rs.Fields("Integritaet").value = awf(a)
            fragenInteg = awf(a)
            If awf(a) > sb Then sb = awf(a)
          Case C_IDVDATFLD_VERFUEGBARKEIT
            rs.Fields("Verfuegbarkeit").value = awf(a)
            fragenVerfueg = awf(a)
            If awf(a) > sb Then sb = awf(a)
          Case C_IDVDATFLD_VERTRAULICHKEIT
            rs.Fields("Vertraulichkeit").value = awf(a)
            fragenVertr = awf(a)
            If awf(a) > sb Then sb = awf(a)
          Case C_IDVDATFLD_INFORMATIONSKLASSE
            rs.Fields("Informationsklassifizierung").value = awf(a)
          Case C_IDVDATFLD_SCHUTZBEDARF
            rs.Fields("Schutzbedarf").value = awf(a)
          Case C_IDVDATFLD_BANKFACHLICH
            rs.Fields("Bankfachlich").value = awf(a)
          Case C_IDVDATFLD_GOBD
            rs.Fields("GOBD").value = awf(a)
          Case C_IDVDATFLD_AUTHENTIZITAET
            rs.Fields("Authentizitaet").value = awf(a)
            fragenAuthen = awf(a)
            If awf(a) > sb Then sb = awf(a)
          Case C_IDVDATFLD_FREMDENTWICKLUNG
            rs.Fields("Fremdentwicklung").value = awf(a)
        End Select
    Next a
    
    antwortFunkRs.Close
    Set antwortFunkRs = Nothing
    
    If antworten <> "" Then
        conn.Execute "insert into idvDateienAntwortKennzeichen (idvDateien, AntwortKennzeichenID) Select distinct " & rs.Fields("idvDateiID").value & ", gAK.AntwortKennzeichenID from gAntwortKennzeichen gAK inner join gFragenKennzeichen gFK on GAK.AntwortKennzeichenID = gFK.AntwortKennzeichenID where gFK.FrageAntwortID in (" & antworten & ")"
    End If
    
    ' Wenn jemand explizit den Schutzbedarf gesetzt hat, dann wurde er bereits |fffd|bernommen. Ansonsten muss er noch errechnet werden!
    If awf(C_IDVDATFLD_SCHUTZBEDARF) <= 0 Then
      ' Ok, nur wenn SB |fffd|berhaupt berechnet wurde wird der Wert auch gesetzt
      If sb >= 0 Then
        rs.Fields("Schutzbedarf").value = sb
      End If
    End If
    
    ' Kann nur True werden, wenn es Prozessauswahl gab und der User explizit so geantwortet hat,
    ' dass Integritaet, Verfuegbarkeit, Vertraulichkeit oder Authentizitaet kleiner wurden als die Werte aus den Prozessen!
     Dim SchutzbedarfIstReduziert As Boolean
    SchutzbedarfIstReduziert = False
    Dim SchutzbedarfIstVeraendert As Boolean
    SchutzbedarfIstVeraendert = False
    
    ' Prozesse speichern
    conn.Execute "DELETE FROM idvDateienProzess WHERE idvdateiid = " & rs.Fields("idvDateiID").value
    If G_SelectedProzesse.count > 0 Then
        Dim integ As Long
        Dim vertr As Long
        Dim verfueg As Long
        Dim ik As Long
        Dim authen As Long
        integ = 0
        vertr = 0
        verfueg = 0
        ik = 0
        sb = 0
        authen = 0
        
        Dim prozrs As Object
        Set prozrs = CreateObject("ADODB.Recordset")
        prozrs.Open "SELECT * FROM idvDateienProzess WHERE idvDateiID = " & rs.Fields("idvDateiID").value, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockOptimistic
    
        If G_CfgPANoTextfile Then
            
          Dim prozAktuellRs As Object
          Set prozAktuellRs = CreateObject("ADODB.Recordset")
          prozAktuellRs.Open "SELECT * FROM gProzessAktuell", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
        
          For i = 1 To G_SelectedProzesse.count
            prozrs.AddNew
            prozrs.Fields("idvDateiID").value = rs.Fields("idvDateiID").value
            prozrs.Fields("Prozessschluessel").value = CStr(G_SelectedProzesse(i))
            prozrs.Fields("Einfuegung").value = Now
            prozrs.Update
          
'              If prozAktuellRs.EOF <> True Or prozAktuellRs.BOF <> True Then
'                prozAktuellRs.MoveFirst
'                prozAktuellRs.Find "Prozessschluessel='" & CStr(G_SelectedProzesse(i)) & "'"
'                If Not prozAktuellRs.EOF Then
'                  If prozAktuellRs.Fields("Vertraulichkeit").value > vertr Then
'                    vertr = prozAktuellRs.Fields("Vertraulichkeit").value
'                  End If
'                  If prozAktuellRs.Fields("Integritaet").value > integ Then
'                    integ = prozAktuellRs.Fields("Integritaet").value
'                  End If
'                  If prozAktuellRs.Fields("Verfuegbarkeit").value > verfueg Then
'                    verfueg = prozAktuellRs.Fields("Verfuegbarkeit").value
'                  End If
'                  If prozAktuellRs.Fields("Informationsklassifizierung").value > ik Then
'                    ik = prozAktuellRs.Fields("Informationsklassifizierung").value
'                  End If
'                End If
'              End If
          Next i
        
          prozAktuellRs.Close
          Set prozAktuellRs = Nothing
        Else
          Dim prozCol As Collection
          Set prozCol = frmProzessauswahl.AllProcesses
          
          For i = 1 To G_SelectedProzesse.count
              Dim Key As String
              Key = "O" & CStr(G_SelectedProzesse(i))
              If CollectionObjectExists(prozCol, Key) Then
                  prozrs.AddNew
                  prozrs.Fields("idvDateiID").value = rs.Fields("idvDateiID").value
                  prozrs.Fields("Prozessschluessel").value = CStr(G_SelectedProzesse(i))
                  prozrs.Fields("Einfuegung").value = Now
                  prozrs.Update
                  
'                    Dim prozess As CProzess
'                    Set prozess = prozCol(Key)
'                    If prozess.Vertraulichkeit > vertr Then
'                        vertr = prozess.Vertraulichkeit
'                    End If
'                    If prozess.Integritaet > integ Then
'                        integ = prozess.Integritaet
'                    End If
'                    If prozess.Verfuegbarkeit > verfueg Then
'                        verfueg = prozess.Verfuegbarkeit
'                    End If
'                    If prozess.Informationsklassifizierung > ik Then
'                        ik = prozess.Informationsklassifizierung
'                    End If
'                    Set prozess = Nothing
              End If
          Next i
          Set prozCol = Nothing
        End If
        
        prozrs.Close
        Set prozrs = Nothing
        
        Call frmProzessauswahl.FinalCleanup
        
        If Not G_Befragung Is Nothing Then
            If G_Befragung.CalcSchutzbedarfWurdeReduziert(frgdlgcol) = True Then
                ' Wenn einer der Schutzbedarfswerte im Vergleich zu den Werten aus der Prozessauswahl waehrend der Befragung vom User reduziert wurde, setzen wir das Flag!
                SchutzbedarfIstReduziert = True
            End If
            If G_Befragung.CalcSchutzbedarfWurdeVeraendert(frgdlgcol) = True Then
                ' Wenn einer der Schutzbedarfswerte im Vergleich zu den Werten aus der Prozessauswahl waehrend der Befragung vom User ver|fffd|ndert wurde, setzen wir das Flag!
                SchutzbedarfIstVeraendert = True
            End If
        End If
        
        ' Es gelten die Schutzbedarfswerte die sich biz zum letzten Fragendialog ergeben haben (Prozessauswahl ist auch ein FragenDlg)
        If frgdlgcol.count > 0 Then
            Dim lastDlg As CFragenDlg
            Set lastDlg = frgdlgcol(frgdlgcol.count)
            vertr = lastDlg.m_Schutzbed.value(C_IDVDATFLD_VERTRAULICHKEIT)
            verfueg = lastDlg.m_Schutzbed.value(C_IDVDATFLD_VERFUEGBARKEIT)
            integ = lastDlg.m_Schutzbed.value(C_IDVDATFLD_INTEGRITAET)
            ik = lastDlg.m_Schutzbed.value(C_IDVDATFLD_INFORMATIONSKLASSE)
            authen = lastDlg.m_Schutzbed.value(C_IDVDATFLD_AUTHENTIZITAET)
            Set lastDlg = Nothing
        End If
        
        If integ > sb Then sb = integ
        If vertr > sb Then sb = vertr
        If verfueg > sb Then sb = verfueg
        If authen > sb Then sb = authen
        
        rs.Fields("Vertraulichkeit").value = vertr
        rs.Fields("Verfuegbarkeit").value = verfueg
        rs.Fields("Integritaet").value = integ
        rs.Fields("Informationsklassifizierung").value = ik
        rs.Fields("Authentizitaet").value = authen
        
        ' SB wird nur gesetzt, wenn die erforderlichen Kriterien erf|fffd|llt sind!!! Diese kommen aus SBMUSS in der CFG!
        If (G_SchutzbedarfMussIntegritaet = True And integ <= 0) Or _
           (G_SchutzbedarfMussVerfuegbarkeit = True And verfueg <= 0) Or _
           (G_SchutzbedarfMussVertraulichkeit = True And vertr <= 0) Or _
           (G_SchutzbedarfMussAuthentizitaet = True And authen <= 0) Then
            sb = 0
           DebugPrint DebType.tdebug, "Schutzbedarf auf 0 gesetzt, da einer der MUSS-Werte Schutzbedarf nicht gesetzt war!"
        End If
        rs.Fields("Schutzbedarf").value = sb
    End If
    
    vertr = GetSafeFieldPlus(rs, "Vertraulichkeit", 0)
    verfueg = GetSafeFieldPlus(rs, "Verfuegbarkeit", 0)
    integ = GetSafeFieldPlus(rs, "Integritaet", 0)
    authen = GetSafeFieldPlus(rs, "Authentizitaet", 0)
    ik = GetSafeFieldPlus(rs, "Informationsklassifizierung", 0)
    sb = GetSafeFieldPlus(rs, "Schutzbedarf", 0)
    
    ' Jetzt wird gepr|fffd|ft, ob der Schutzbedarf den Risikowert bestimmt
    Dim riskrs As Object
    If sb > 0 Then
      Set riskrs = CreateObject("ADODB.Recordset")
      riskrs.Open "SELECT RisikowertBis, Schutzbedarf FROM gRisikoklasse WHERE Schutzbedarf > 0 ORDER BY RisikowertBis DESC", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
      Do While Not riskrs.EOF
        If GetSafeFieldPlus(riskrs, "Schutzbedarf", 0) = sb Then
          newrisk = GetValueFromField(riskrs, "RisikowertBis", "")
        End If
        riskrs.MoveNext
      Loop
      riskrs.Close
      Set riskrs = Nothing
    End If
    
    newrisk = CalcRiskFromScript(newrisk, rs, conn, sb, vertr, verfueg, integ, ik, authen)
    
    rs.Fields("Vertraulichkeit").value = vertr
    rs.Fields("Verfuegbarkeit").value = verfueg
    rs.Fields("Integritaet").value = integ
    rs.Fields("Informationsklassifizierung").value = ik
    rs.Fields("Schutzbedarf").value = sb
    rs.Fields("Authentizitaet").value = authen
    
    rs.Fields("VertraulichkeitProzesse").value = G_Befragung.ProzessauswahlValues.value(C_IDVDATFLD_VERTRAULICHKEIT)
    rs.Fields("VerfuegbarkeitProzesse").value = G_Befragung.ProzessauswahlValues.value(C_IDVDATFLD_VERFUEGBARKEIT)
    rs.Fields("IntegritaetProzesse").value = G_Befragung.ProzessauswahlValues.value(C_IDVDATFLD_INTEGRITAET)
    rs.Fields("InformationsklassifizierungPr").value = G_Befragung.ProzessauswahlValues.value(C_IDVDATFLD_INFORMATIONSKLASSE)
    rs.Fields("AuthentizitaetProzesse").value = G_Befragung.ProzessauswahlValues.value(C_IDVDATFLD_AUTHENTIZITAET)
    rs.Fields("SchutzbedarfProzesse").value = G_Befragung.ProzessauswahlValues.CalcSchutzbedarf
    
    rs.Fields("LetztesTechRisk").value = rs.Fields("ScanRisiko").value
    
    rs.Fields("SchutzbedarfReduziert").value = SchutzbedarfIstReduziert
    rs.Fields("SchutzbedarfVeraendert").value = SchutzbedarfIstVeraendert
    
    ' Risikoklasse anpassen

    Set riskrs = CreateObject("ADODB.Recordset")
    Dim newrisikoklasse As String
    Dim oldrisikowert As Double
    Dim oldrisikoklasse As String
    Dim doMailInfo As Boolean
    Dim risikoklassentext As String
    doMailInfo = False
    
    oldrisikowert = 0#
    If Not IsNull(rs.Fields("Risikowert").value) Then
        oldrisikowert = GetValueFromField(rs, "Risikowert", 0#)
    End If
    
    oldrisikoklasse = ""
    If Not IsNull(rs.Fields("RisikoklasseIDBeiEinwertung").value) Then
        riskrs.Open "SELECT Risikoklassenkennzeichen, u.LokalisierterText as LocKennzeichen FROM gRisikoklasseHistorie left join gTexteUebersetzungen u on (gRisikoklasseHistorie.TextID = u.TextID and u.LanguageID = " & GetMyDBLanguage(conn) & ") where RisikoklasseID = " & rs.Fields("RisikoklasseIDBeiEinwertung").value, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
        If Not riskrs.EOF Then
            oldrisikoklasse = GetLocValueFromField(riskrs, "Risikoklassenkennzeichen", "LocKennzeichen", "")
        End If
        riskrs.Close
    End If


    newrisikoklasse = ""
    Dim queryRisk As String
    queryRisk = "SELECT Risikoklassenkennzeichen, RisikoklasseID, InfoAnAdmin, ErlaeuterungNachAbschluss, uKennzeichen.LokalisierterText as LocKennzeichen, uErlaeuterung.LokalisierterText as LocErlaeuterung, gRisikoklasse.SperrungNachXTagen " & _
    " FROM ((gRisikoklasse left join gTexteUebersetzungen uKennzeichen on (gRisikoklasse.TextID = uKennzeichen.TextID and uKennzeichen.LanguageID = " & GetMyDBLanguage(conn) & ")) " & _
    " left join gTexteUebersetzungen uErlaeuterung on (gRisikoklasse.ErlNachAbschlussTextID = uErlaeuterung.TextID and uErlaeuterung.LanguageID = " & GetMyDBLanguage(conn) & ")) " & _
    " WHERE RisikowertVon * 100 <= " & CInt(newrisk * 100) & " AND RisikowertBis * 100 >= " & CInt(newrisk * 100)
    riskrs.Open queryRisk, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
    If Not riskrs.EOF Then
        newrisikoklasse = GetLocValueFromField(riskrs, "Risikoklassenkennzeichen", "LocKennzeichen", "")
        rs.Fields("RisikoklasseIDBeiEinwertung").value = riskrs.Fields("RisikoklasseID").value
        doMailInfo = riskrs.Fields("InfoAnAdmin").value
        risikoklassentext = GetLocValueFromField(riskrs, "ErlaeuterungNachAbschluss", "LocErlaeuterung", "")
        
        Dim tgSperre As Long
        tgSperre = GetValueFromField(riskrs, "SperrungNachXTagen", -1)
        If tgSperre >= 0 Then
          risikoklassentext = Replace(risikoklassentext, "#SPERRDATUM#", Format(DateAdd("d", tgSperre, Now), "Short Date"))
        End If
        's = Replace(s, "#SPERRDATUM#", "unbekannt")
        risikoklassentext = Replace(risikoklassentext, "#SPERRDATUM#", FMT0("TRACKERSTUFF_29"))
    End If
    riskrs.Close
    Set riskrs = Nothing
    
    DebugPrint DebType.tTime, "Doku 1"
    Dim risikofragenZeitpunkt As Date
    risikofragenZeitpunkt = Now
    
    If oldrisikoklasse <> newrisikoklasse Then
        
       If (oldrisikoklasse <> "" And newrisikoklasse <> "" And GetValueFromField(rs, "LetzteBefragung", #1/1/1900#) <> #1/1/1900#) Or oldrisikoklasse = "" Or oldrisikoklasse = "Unb." Then
            
            If doMailInfo Then
                    Dim sBetreff As String
                    Dim sText As String
        
                    sBetreff = G_PARAM_SMTPMailInfoRisikoklasseBetreff
                    sText = G_PARAM_SMTPMailInfoRisikoklasse
        
                    ReplaceStuff curdoc, sBetreff, rs, newrisikoklasse, oldrisikoklasse
                    ReplaceStuff curdoc, sText, rs, newrisikoklasse, oldrisikoklasse
                    ReplaceStuffInitiator sBetreff, conn, GetUserName()
                    ReplaceStuffInitiator sText, conn, GetUserName()
        
                    InformAdmins G_PARAM_StoreMailsToTable, conn, sBetreff, sText, "Risikoklassenver|fffd|nderung ID " & rs.Fields("idvDateiID").value & " " & oldrisikoklasse & " -> " & newrisikoklasse, "", ""
            End If
            
            If logRisikoklassen|fffd|nderung Then
                Dim kommentar As String
                kommentar = ""
                If oldrisikowert > newrisk Then
                  If G_PARAM_BegruendungReduziertesRisiko Then
nochmal:
                      'kommentar = InputBox("Bitte begr|fffd|nden Sie, warum sich das Risiko dieser Datei im Verh|fffd|ltnis zur letzten Befragung reduziert hat:", ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")")
'                      kommentar = MyInputBox.Display("Bitte begr|fffd|nden Sie, warum sich das Risiko dieser Datei im Verh|fffd|ltnis zur letzten Befragung reduziert hat:", _
'                                                    ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")", _
'                                                    8, 120, False)
                      kommentar = MyInputBox.Display(FMT0("THISADDIN_4"), ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")", 8, 120, False)
                      If Len(Trim(kommentar)) < 8 Then
                        GoTo nochmal:
                      End If
                  Else
                    kommentar = "-/-"
                  End If
                End If
                
                Dim ahrs As Object
                Set ahrs = CreateObject("ADODB.Recordset")
                
                ' XXXX
                ahrs.Open "SELECT * FROM idvAntwortenHistorie WHERE idvDateiID = " & rs.Fields("idvDateiID").value, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockOptimistic
                
                Do While Not ahrs.EOF
                    ' BUGFIX - Wenn der 1.1.1900 drin ist, dann ist das ein BUG! Raus damit!!!
                    If ahrs.Fields("DatumAlt").value = #1/1/1900# Then
                      ahrs.Delete
                    ElseIf ahrs.Fields("DatumAlt").value = rs.Fields("LetzteBefragung").value Then
                        Exit Do
                    End If
                    ahrs.MoveNext
                Loop
                
                If ahrs.EOF Then
                  ahrs.AddNew
                End If
                
                ahrs.Fields("idvDateiID").value = rs.Fields("idvDateiID").value
                ahrs.Fields("RisikowertAlt").value = rs.Fields("Risikowert").value
                'ahrs.Fields("UserLogonIDAlt").value = GetValueFromField(rs, "LetzteBefragungUserID", "UNBEK. USER")
                ahrs.Fields("UserLogonIDAlt").value = GetValueFromField(rs, "LetzteBefragungUserID", FMT0("THISADDIN_94"))
                ahrs.Fields("DatumAlt").value = GetValueFromField(rs, "LetzteBefragung", #1/1/1900#)
                For i = 1 To 15
                    '                                    If rs.Fields("AntwortID" & i).Value Is System.nothing Then Exit For
                    ahrs.Fields("AntwortIDA" & i).value = rs.Fields("AntwortID" & i).value
                Next
                
                ahrs.Fields("RisikowertNeu").value = newrisk
                ahrs.Fields("DatumNeu").value = risikofragenZeitpunkt
                ahrs.Fields("UserLogonIDNeu").value = GetUserNameUCASE
                
                i = 1
                For Each frgDlg In frgdlgcol
                  For Each ant In frgDlg.m_Antworten
                    ahrs.Fields("AntwortIDN" & i).value = val(ant.m_AntwortID)
                    i = i + 1
                  Next ant
                Next frgDlg
                
                ahrs.Fields("Kommentar").value = Left(kommentar, 120)
                
                ahrs.Update
                ahrs.Close
                Set ahrs = Nothing
            End If
            
            ' 15.01.2015 Mailevents testen
            CheckMailEvent curdoc, ME_RisikoklasseGeaendert, rs, conn, newrisikoklasse, oldrisikoklasse
        End If
    End If
    DebugPrint DebType.tTime, "Doku 2"
    
    i = 1
    For Each frgDlg In frgdlgcol
      For Each ant In frgDlg.m_Antworten
        rs.Fields("AntwortID" & i).value = val(ant.m_AntwortID)
        i = i + 1
      Next ant
    Next frgDlg
    
    If i <= 15 Then
      For i = i To 15
          rs.Fields("AntwortID" & i).value = 0
      Next
    End If
    
    rs.Fields("Risikowert").value = newrisk ' CreateFragen(fragen, cfgr)
    rs.Fields("LetzteBefragung").value = risikofragenZeitpunkt
    rs.Fields("LetzteBefragungUserID").value = GetUserNameUCASE()
    rs.Fields("ParameterID").value = paramrsid
    rs.Fields("FruehestensWiederFragenAm").value = 0
    rs.Fields("AnzahlVerschiebungenBefragung").value = 0
    
    ' Risikoklassentext ausgeben
    If risikoklassentext <> "" Then
        DebugPrint DebType.tdebug, "CreateFragen 3a"
        frmHinweise.Hinweistext = risikoklassentext
        'frmHinweise.Caption = ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")" & " - Hinweis"
        frmHinweise.Caption = ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")" & " - " & FMT0("THISADDIN_3")
        frmHinweise.Show vbModal
    End If
    
    Set G_Befragung = Nothing
    
    DebugPrint DebType.tTime, "Doku 3"
End Function

Private Sub CheckantwortFunktionArr(ByRef antwortFunkRs As Object, ByRef awf, ByVal fldName As String)

  If IsNull(antwortFunkRs.Fields(fldName).value) Then Exit Sub
  If antwortFunkRs.Fields(fldName).value = 0 Then Exit Sub
  
  Select Case antwortFunkRs.Fields(fldName).value
      Case 1 ' Integrit|fffd|t gering
        If awf(C_IDVDATFLD_INTEGRITAET) < 1 Then
          awf(C_IDVDATFLD_INTEGRITAET) = 1
        End If
      Case 2 ' Integrit|fffd|t mittel
        If awf(C_IDVDATFLD_INTEGRITAET) < 2 Then
          awf(C_IDVDATFLD_INTEGRITAET) = 2
        End If
      Case 3 ' Integrit|fffd|t hoch
        If awf(C_IDVDATFLD_INTEGRITAET) < 3 Then
          awf(C_IDVDATFLD_INTEGRITAET) = 3
        End If
      Case 4 ' Integrit|fffd|t sehr hoch
        If awf(C_IDVDATFLD_INTEGRITAET) < 4 Then
          awf(C_IDVDATFLD_INTEGRITAET) = 4
        End If
      Case 5 ' Verf|fffd|gbarkeit gering
        If awf(C_IDVDATFLD_VERFUEGBARKEIT) < 1 Then
          awf(C_IDVDATFLD_VERFUEGBARKEIT) = 1
        End If
      Case 6 ' Verf|fffd|gbarkeit mittel
        If awf(C_IDVDATFLD_VERFUEGBARKEIT) < 2 Then
          awf(C_IDVDATFLD_VERFUEGBARKEIT) = 2
        End If
      Case 7 ' Verf|fffd|gbarkeit hoch
        If awf(C_IDVDATFLD_VERFUEGBARKEIT) < 3 Then
          awf(C_IDVDATFLD_VERFUEGBARKEIT) = 3
        End If
      Case 8       ' Verf|fffd|gbarkeit sehr hoch
        If awf(C_IDVDATFLD_VERFUEGBARKEIT) < 4 Then
          awf(C_IDVDATFLD_VERFUEGBARKEIT) = 4
        End If
      Case 9       ' Vertraulichkeit gering
        If awf(C_IDVDATFLD_VERTRAULICHKEIT) < 1 Then
          awf(C_IDVDATFLD_VERTRAULICHKEIT) = 1
        End If
      Case 10        ' Vertraulichkeit mittel
        If awf(C_IDVDATFLD_VERTRAULICHKEIT) < 2 Then
          awf(C_IDVDATFLD_VERTRAULICHKEIT) = 2
        End If
      Case 11        ' Vertraulichkeit hoch
        If awf(C_IDVDATFLD_VERTRAULICHKEIT) < 3 Then
          awf(C_IDVDATFLD_VERTRAULICHKEIT) = 3
        End If
      Case 12        ' Vertraulichkeit sehr hoch
        If awf(C_IDVDATFLD_VERTRAULICHKEIT) < 4 Then
          awf(C_IDVDATFLD_VERTRAULICHKEIT) = 4
        End If
      Case 13        ' Informationsklasse S1
        If awf(C_IDVDATFLD_INFORMATIONSKLASSE) < 1 Then
          awf(C_IDVDATFLD_INFORMATIONSKLASSE) = 1
        End If
      Case 14        ' Informationsklassifizierung s2
        If awf(C_IDVDATFLD_INFORMATIONSKLASSE) < 2 Then
          awf(C_IDVDATFLD_INFORMATIONSKLASSE) = 2
        End If
      Case 15        ' Informationsklassifizierung s3
        If awf(C_IDVDATFLD_INFORMATIONSKLASSE) < 3 Then
          awf(C_IDVDATFLD_INFORMATIONSKLASSE) = 3
        End If
      Case 16        ' Informationsklassifizierung S4
        If awf(C_IDVDATFLD_INFORMATIONSKLASSE) < 4 Then
          awf(C_IDVDATFLD_INFORMATIONSKLASSE) = 4
        End If
      Case 17        ' Informationsklassifizierung S5
        If awf(C_IDVDATFLD_INFORMATIONSKLASSE) < 5 Then
          awf(C_IDVDATFLD_INFORMATIONSKLASSE) = 5
        End If
      Case 18        ' Schutzbedarf gering
        If awf(C_IDVDATFLD_SCHUTZBEDARF) < 1 Then
          awf(C_IDVDATFLD_SCHUTZBEDARF) = 1
        End If
      Case 19        ' Schutzbedarf mittel
        If awf(C_IDVDATFLD_SCHUTZBEDARF) < 2 Then
          awf(C_IDVDATFLD_SCHUTZBEDARF) = 2
        End If
      Case 20        ' Schutzbedarf hoch
        If awf(C_IDVDATFLD_SCHUTZBEDARF) < 3 Then
          awf(C_IDVDATFLD_SCHUTZBEDARF) = 3
        End If
      Case 21        ' Schutzbedarf sehr hoch
        If awf(C_IDVDATFLD_SCHUTZBEDARF) < 4 Then
          awf(C_IDVDATFLD_SCHUTZBEDARF) = 4
        End If
      Case 22        ' Bankfachlich JA
        awf(C_IDVDATFLD_BANKFACHLICH) = 1
      Case 23        ' Bankfachlich NEIN
        awf(C_IDVDATFLD_BANKFACHLICH) = 0
      Case 24        ' GOBD JA
        awf(C_IDVDATFLD_GOBD) = 1
      Case 25        ' GOBD NEIN
        awf(C_IDVDATFLD_GOBD) = 0
      Case 26 ' Authentizitaet gering
        If awf(C_IDVDATFLD_AUTHENTIZITAET) < 1 Then
          awf(C_IDVDATFLD_AUTHENTIZITAET) = 1
        End If
      Case 27 ' Authentizitaet mittel
        If awf(C_IDVDATFLD_AUTHENTIZITAET) < 2 Then
          awf(C_IDVDATFLD_AUTHENTIZITAET) = 2
        End If
      Case 28 ' Authentizitaet hoch
        If awf(C_IDVDATFLD_AUTHENTIZITAET) < 3 Then
          awf(C_IDVDATFLD_AUTHENTIZITAET) = 3
        End If
      Case 29 ' Authentizitaet sehr hoch
        If awf(C_IDVDATFLD_AUTHENTIZITAET) < 4 Then
          awf(C_IDVDATFLD_AUTHENTIZITAET) = 4
        End If
      Case 30        ' FREMDENTWICKLUNG JA
        awf(C_IDVDATFLD_FREMDENTWICKLUNG) = 1
      Case 31        ' FREMDENTWICKLUNG NEIN
        awf(C_IDVDATFLD_FREMDENTWICKLUNG) = 0
  End Select
End Sub

Sub CheckantwortFunktion(ByRef antwortFunkRs As Object, ByVal fldName As String, ByRef rs As Object)

  If IsNull(antwortFunkRs.Fields(fldName).value) Then Exit Sub
  If antwortFunkRs.Fields(fldName).value = 0 Then Exit Sub
  
  Select Case antwortFunkRs.Fields(fldName).value
      Case 1 ' Integrit|fffd|t gering
        rs.Fields("Integritaet").value = 1
      Case 2 ' Integrit|fffd|t mittel
        rs.Fields("Integritaet").value = 2
      Case 3 ' Integrit|fffd|t hoch
        rs.Fields("Integritaet").value = 3
      Case 4 ' Integrit|fffd|t sehr hoch
        rs.Fields("Integritaet").value = 4
      Case 5 ' Verf|fffd|gbarkeit gering
        rs.Fields("Verfuegbarkeit").value = 1
      Case 6 ' Verf|fffd|gbarkeit mittel
        rs.Fields("Verfuegbarkeit").value = 2
      Case 7 ' Verf|fffd|gbarkeit hoch
        rs.Fields("Verfuegbarkeit").value = 3
      Case 8       ' Verf|fffd|gbarkeit sehr hoch
        rs.Fields("Verfuegbarkeit").value = 4
      Case 9       ' Vertraulichkeit gering
        rs.Fields("Vertraulichkeit").value = 1
      Case 10        ' Vertraulichkeit mittel
        rs.Fields("Vertraulichkeit").value = 2
      Case 11        ' Vertraulichkeit hoch
        rs.Fields("Vertraulichkeit").value = 3
      Case 12        ' Vertraulichkeit sehr hoch
        rs.Fields("Vertraulichkeit").value = 4
      Case 13        ' Informationsklasse S1
        rs.Fields("Informationsklassifizierung").value = 1
      Case 14        ' Informationsklassifizierung s2
        rs.Fields("Informationsklassifizierung").value = 2
      Case 15        ' Informationsklassifizierung s3
        rs.Fields("Informationsklassifizierung").value = 3
      Case 16        ' Informationsklassifizierung S4
        rs.Fields("Informationsklassifizierung").value = 4
      Case 17        ' Informationsklassifizierung S5
        rs.Fields("Informationsklassifizierung").value = 5
      Case 18        ' Schutzbedarf gering
        rs.Fields("Schutzbedarf").value = 1
      Case 19        ' Schutzbedarf mittel
        rs.Fields("Schutzbedarf").value = 2
      Case 20        ' Schutzbedarf hoch
        rs.Fields("Schutzbedarf").value = 3
      Case 21        ' Schutzbedarf sehr hoch
        rs.Fields("Schutzbedarf").value = 4
      Case 22        ' Bankfachlich JA
        rs.Fields("Bankfachlich").value = 1
      Case 23        ' Bankfachlich NEIN
        rs.Fields("Bankfachlich").value = 0
      Case 24        ' GOBD JA
        rs.Fields("GOBD").value = 1
      Case 25        ' GOBD NEIN
        rs.Fields("GOBD").value = 0
     Case 26        ' Authentizitaet gering
        rs.Fields("Authentizitaet").value = 1
      Case 27        ' Authentizitaet mittel
        rs.Fields("Authentizitaet").value = 2
      Case 28        ' Authentizitaet hoch
        rs.Fields("Authentizitaet").value = 3
      Case 29        ' Authentizitaet sehr hoch
        rs.Fields("Authentizitaet").value = 4
      Case 30        ' FREMDENTWICKLUNG JA
        rs.Fields("Fremdentwicklung").value = 1
      Case 31        ' FREMDENTWICKLUNG NEIN
        rs.Fields("Fremdentwicklung").value = 0
    End Select
End Sub


Public Function AnwendungFuerDatei(ByVal a_Datei As String) As String
    'Datei: Pfad + Dateinamen einer existierenden Datei
    
    If a_Datei Like "*.xl*" Then
      If FileExists(Application.path & "\Excel.exe") Then
        AnwendungFuerDatei = Application.path & "\Excel.exe"
        Exit Function
      End If
    End If
    
    Dim Pfad As String
'    Dim Pfad As String * 255
    Pfad = Space(256)
    Call FindExecutable(a_Datei, vbNullString, Pfad)

    If "" <> Pfad Then
        Pfad = Trim(Left(Pfad, InStr(Pfad, vbNullChar) - 1))
    End If
    AnwendungFuerDatei = Trim(Pfad)

End Function

Sub StartDatei(ByVal filename As String, Optional focus As Long = vbHide, Optional schreibgeschuetzt As Boolean = True)
    Dim s2 As String, s3 As String, n As Long

    s2 = AnwendungFuerDatei(filename)
    If "" <> s2 Then
        s3 = Chr(34) & s2 & Chr(34) & IIf(schreibgeschuetzt, " /e /automation /r ", " ") & Chr(34) & filename & Chr(34)
        n = Shell(s3, focus) 'vbNormalFocus)
    Else
        'MsgBox "Anwendungprogramm f|fffd|r " & fileName & " nicht gefunden/installiert!", vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        MsgBox FMT1("DOKULIST_11", filename), vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
    End If
End Sub


Sub StartDateiUndWarten(ByVal filename As String, Optional focus As Long = vbHide, Optional schreibgeschuetzt As Boolean = True)
    Dim s2 As String, s3 As String, n As Long

    s2 = AnwendungFuerDatei(filename)
    If "" <> s2 Then
        
        If Right(UCase(s2), 9) = "EXCEL.EXE" Then
            SaveSetting _
                   appname:="Stromwerken", _
                   Section:="ExcelTracker", _
                   Key:="IgnoreThisOne", _
                   Setting:="True"
            G_NoStartup = True
        ElseIf Right(UCase(s2), 12) = "MSACCESS.EXE" Then
            SaveSetting _
                   appname:="Stromwerken", _
                   Section:="AccessTracker", _
                   Key:="IgnoreThisOne", _
                   Setting:="True"
        End If
        
        s3 = Chr(34) & s2 & Chr(34) & IIf(schreibgeschuetzt, " /e /automation /r ", " ") & Chr(34) & filename & Chr(34)
        ShellAndWait s3, focus   'vbNormalFocus)
    Else
        'MsgBox "Anwendungprogramm f|fffd|r " & fileName & " nicht gefunden/installiert!", vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        MsgBox FMT1("DOKULIST_11", filename), vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
    End If
End Sub

' Liefert
' -2: Aktion nicht m|fffd|glich, kein Zugriff auf Datensatz
' -1: Keine Doku vorhanden
' 0: Datei hat eigene Doku
' 1: Datei hat Doku einer anderen Datei

' Achtung: locVersion sollte aufgef|fffd|llt sein, und zwar mit den Werten aus der Excel- / Access-Datei, nicht aus dem Datensatz, da sich die Version
' dort von der im Datensatz unterscheiden kann.
Function GetFileDoku(ByRef dateiRS As Object, ByRef conn As Object, ByRef dokuID As Long, ByRef locDateiID As Long, ByRef locVersion As Long, ByRef selitem As Long, ByRef oeitem As Long, _
    ByRef VerantwortlicherAutor As String, ByRef FachlichVerantwortlicher As String) As Long
    
    On Error Resume Next
    
    Dim referenzID As Long
    Dim referenzVersion As Long
    Dim jumpCout As Long
    
    Dim jumpcount  As Long
    
    jumpcount = 0
    dokuID = -1
    
    Dim refrs As Object
    
    referenzID = GetValueFromField(dateiRS, "ReferenzidvDateiID", -1)
    referenzVersion = GetValueFromField(dateiRS, "ReferenzVersion", -1)

    If Not IsNull(dateiRS.Fields("VerantwortlicheOEID").value) Then
      oeitem = dateiRS.Fields("VerantwortlicheOEID").value
    Else
      oeitem = GetCurrentUserOEID(conn)
    End If
    VerantwortlicherAutor = UCase(GetValueFromField(dateiRS, "VerantwortlicherAutor", ""))
    FachlichVerantwortlicher = UCase(GetValueFromField(dateiRS, "FachlichVerantwortlicher", ""))
    
    Dim drs As Object
    
    'If GetValueFromField(dateiRS, "FreigabeStatus", 0) > 1 And GetValueFromField(dateiRS, "FreigabeidvDateiID", 0) > 0 And GetValueFromField(dateiRS, "FreigabeVersion", 0) > 0 Then
    If IstDateiFreigabeStatusFreigegeben(dateiRS) = True And GetValueFromField(dateiRS, "FreigabeidvDateiID", 0) > 0 And GetValueFromField(dateiRS, "FreigabeVersion", 0) > 0 Then
        locDateiID = GetValueFromField(dateiRS, "FreigabeidvDateiID", 0)
        locVersion = GetValueFromField(dateiRS, "FreigabeVersion", 0)
    Else
        If locDateiID = 0 Then
          locDateiID = GetValueFromField(dateiRS, "idvDateiID", 0) ' dateiRs.Fields("idvDateiID").Value
        End If
        If locVersion = 0 Then
          locVersion = GetValueFromField(dateiRS, "Version", 0) ' dateiRs.Fields("Version").Value
        End If
    End If
    Set drs = OpenRS("SELECT * FROM idvDateienDoku WHERE idvDateiID=" & locDateiID & " AND Version=" & locVersion, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
    
    
chekNextFile:
    If drs Is Nothing Then
      GetFileDoku = -2
      Exit Function
    End If
    
    
    ' Wenn es hier was gibt dann holen wir die doku und den Einsatz sowie die ID
    If Not drs.EOF Then
        locDateiID = drs.Fields("idvDateiID").value
        locVersion = drs.Fields("Version").value
        dokuID = drs.Fields("idvDateiDokuID").value
        selitem = drs.Fields("EinsatzID").value
        If Not IsNull(drs.Fields("VerantwortlicheOEID").value) Then
          oeitem = drs.Fields("VerantwortlicheOEID").value
        Else
          oeitem = GetCurrentUserOEID(conn)
        End If
        VerantwortlicherAutor = UCase(GetValueFromField(drs, "VerantwortlicherAutor", ""))
        FachlichVerantwortlicher = UCase(GetValueFromField(drs, "FachlichVerantwortlicher", ""))
        drs.Close
        Set drs = Nothing
    
    ' Haben wir nix, dann holen wir, falls m|fffd|glich, die Vorg|fffd|ngerversion
    Else
        
        drs.Close
        Set drs = Nothing
        Set drs = OpenRS("SELECT * FROM idvDateienDoku WHERE idvDateiID=" & locDateiID & IIf(locVersion > 0, " AND Version<=" & locVersion, "") & " ORDER BY Version DESC", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
        If drs Is Nothing Then
          GetFileDoku = -2
          Exit Function
        End If
        
        If Not drs.EOF Then
            locVersion = drs.Fields("Version").value
            dokuID = drs.Fields("idvDateiDokuID").value
            selitem = drs.Fields("EinsatzID").value
            If Not IsNull(drs.Fields("VerantwortlicheOEID").value) Then
              oeitem = drs.Fields("VerantwortlicheOEID").value
            End If
            VerantwortlicherAutor = UCase(GetValueFromField(drs, "VerantwortlicherAutor", ""))
            FachlichVerantwortlicher = UCase(GetValueFromField(drs, "FachlichVerantwortlicher", ""))
            drs.Close
            Set drs = Nothing
        Else
        
            ' Wenn es von der Vorg|fffd|ngerversion keine Doku gibt wird versucht die Doku von der Referenz zu holen
            drs.Close
            Set drs = Nothing
            
            If referenzID > 0 Then

                Set refrs = OpenRS("SELECT * FROM idvDateien WHERE idvDateiID=" & referenzID, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
                If refrs Is Nothing Then
                  GetFileDoku = -2
                  Exit Function
                End If
                
                If Not refrs.EOF Then

                  locDateiID = referenzID ' ist gleich refrs.Fields("idvDateiID").Value
                  locVersion = referenzVersion ' ist nicht unbedingt gleich refrs.Fields("Version").Value
                  ' Referenzen der neuen Datei merken
                  referenzID = GetValueFromField(refrs, "ReferenzidvDateiID", -1)
                  referenzVersion = GetValueFromField(refrs, "ReferenzVersion", -1)
              
                  ' das hier ist nicht richtig
                  ' egal, ob die ReferenzVersion mittlerweile freigegeben wurde, m|fffd|ssen wir nach der h|fffd|chsten Doku suchen, die Version <= ReferenzVersion hat
                  ' Problemfall, wenn referenzVersion = -1 ist
                  ' daher w|fffd|rde ich das if mit FreigabeStatus auskommentieren, nutze das jetzt hier nur wenn ich keine ReferenzVersion habe
                  'If referenzVersion < 0 And GetValueFromField(refrs, "FreigabeStatus", 0) > 1 And GetValueFromField(refrs, "FreigabeidvDateiID", 0) > 0 And GetValueFromField(refrs, "FreigabeVersion", 0) > 0 Then
                  If referenzVersion < 0 And IstDateiFreigabeStatusFreigegeben(refrs) = True And GetValueFromField(refrs, "FreigabeidvDateiID", 0) > 0 And GetValueFromField(refrs, "FreigabeVersion", 0) > 0 Then
                      Set drs = OpenRS("SELECT * FROM idvDateienDoku WHERE idvDateiID=" & GetValueFromField(refrs, "FreigabeidvDateiID", 0) & " AND Version=" & GetValueFromField(refrs, "FreigabeVersion", 0), conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
                  Else
                    Set drs = OpenRS("SELECT * FROM idvDateienDoku WHERE idvDateiID=" & locDateiID & IIf(locVersion > 0, " AND Version=" & locVersion, ""), conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
                  End If
                  refrs.Close
                  Set refrs = Nothing
                  jumpcount = jumpcount + 1
                  If jumpcount < 1000 Then GoTo chekNextFile
                End If
                ' jumpcount k|fffd|nnte 30 sein, dann w|fffd|rde er hier refrs 2x freigeben wollen
                ' also vorher abfangen, ob schon gel|fffd|scht
                If Not refrs Is Nothing Then
                    refrs.Close
                    Set refrs = Nothing
                End If
            End If
        End If
    End If
    
    If dokuID = -1 Then
      GetFileDoku = -1
    ElseIf locDateiID = dateiRS.Fields("idvDateiID").value And locVersion = dateiRS.Fields("Version").value Then
      GetFileDoku = 0
    Else
      GetFileDoku = 1
    End If

End Function


Function CheckForCurrentDoku(ByRef dateiRS As Object, ByRef conn As Object) As Boolean
    On Error Resume Next
    Dim locVersion As Long
    Dim locDateiID As Long
    Dim dokuID As Long
    Dim newdokuid As Long
    Dim selitem As Long
    Dim oeitem As Long
    Dim VerantwortlicherAutor As String
    Dim FachlichVerantwortlicher As String
    
    CheckForCurrentDoku = False
    
    Dim gfd As Long
    locDateiID = 0
    locVersion = 0
    gfd = GetFileDoku(dateiRS, conn, dokuID, locDateiID, locVersion, selitem, oeitem, VerantwortlicherAutor, FachlichVerantwortlicher)
    
    ' Ging irgend etwas schief?
    If gfd = -2 Then
      Exit Function
    End If
    
    ' So, jetzt wissen wir, welche Doku eigentlich genommen werden sollte. Mal schauen, ob das auch die aktuelle ist...
    If gfd = 1 Then
      
      Dim drs As Object
      Set drs = CreateObject("ADODB.Recordset")
      Dim trs As Object
      Set trs = CreateObject("ADODB.Recordset")
      
      
      ' Hoppala! Dann wollen wir mal eine Kopie aller relevanten Werte erzeugen!!!!
      conn.Execute "INSERT INTO idvDateienDoku ( idvDateiID, Version, Datum, Anwendungsname, EinsatzID, LogonID, VerantwortlicheOEID, VerantwortlicherAutor, FachlichVerantwortlicher ) " & _
        "SELECT " & dateiRS.Fields("idvDateiID").value & ", " & dateiRS.Fields("Version").value & ", idvDateienDoku.Datum, idvDateienDoku.Anwendungsname, idvDateienDoku.EinsatzID, idvDateienDoku.LogonID, idvDateienDoku.VerantwortlicheOEID, idvDateienDoku.VerantwortlicherAutor, idvDateienDoku.FachlichVerantwortlicher " & _
        "From idvDateienDoku " & _
        "WHERE idvDateienDoku.idvDateiDokuID=" & dokuID

      ' Dann mal die neue Doku-ID besorgen
      drs.Open "SELECT idvDateiDokuID FROM idvDateienDoku WHERE idvDateiID=" & dateiRS.Fields("idvDateiID").value & " AND Version = " & dateiRS.Fields("Version").value, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
      
      newdokuid = -1
      If Not drs.EOF Then
        newdokuid = drs.Fields("idvDateiDokuID").value
      Else
        'MsgBox "Fehler beim Erzeugen der neuen Doku (1)"
        MsgBox FMT0("THISADDIN_5")
      End If
      drs.Close
      
      If newdokuid > 0 Then
      
        ' Textfelder aktualisieren
        If G_DBType = 4 Then ' Access SOnderl|fffd|sung wegen bescheuertem Feldnamen TEXT
          conn.Execute "INSERT INTO idvDateienDokuTextfelder ( idvDateiDokuID, VERSION, DokuFeldID, DokufeldTypID, [TEXT], Feldnummer ) " & _
            "SELECT " & newdokuid & ", " & dateiRS.Fields("Version").value & ", idvDateienDokuTextfelder.DokufeldID, idvDateienDokuTextfelder.DokufeldTypID, idvDateienDokuTextfelder.Text, idvDateienDokuTextfelder.Feldnummer " & _
            "From idvDateienDokuTextfelder " & _
            "WHERE idvDateiDokuID=" & dokuID & " AND Version=" & locVersion
        Else
          conn.Execute "INSERT INTO idvDateienDokuTextfelder ( idvDateiDokuID, VERSION, DokuFeldID, DokufeldTypID, TEXT, Feldnummer ) " & _
            "SELECT " & newdokuid & ", " & dateiRS.Fields("Version").value & ", idvDateienDokuTextfelder.DokufeldID, idvDateienDokuTextfelder.DokufeldTypID, idvDateienDokuTextfelder.Text, idvDateienDokuTextfelder.Feldnummer " & _
            "From idvDateienDokuTextfelder " & _
            "WHERE idvDateiDokuID=" & dokuID & " AND Version=" & locVersion
        End If
          
        ' idvDateienDokuInOut aktualisieren
        conn.Execute "INSERT INTO idvDateienDokuInOut ( idvDateiDokuID, InOut, Typ, ID ) " & _
          "SELECT " & newdokuid & ", idvDateienDokuInOut.InOut, idvDateienDokuInOut.Typ, idvDateienDokuInOut.ID " & _
          "From idvDateienDokuInOut " & _
          "WHERE idvDateiDokuID=" & dokuID
          
        ' idvDateienEinsatzbereiche aktualisieren
        conn.Execute "INSERT INTO idvDateienEinsatzbereiche ( idvDateiDokuID, EinsatzbereichID ) " & _
          "SELECT " & newdokuid & ", idvDateienEinsatzbereiche.EinsatzbereichID " & _
          "From idvDateienEinsatzbereiche " & _
          "WHERE idvDateiDokuID=" & dokuID
          
          conn.Execute "INSERT INTO xlBinTrackerRef ( DokuID, xlBinTrackerID, FreigabeStatus ) Select " & newdokuid & ", xlBinTrackerID, 0 from xlBinTrackerRef where DokuID = " & dokuID
      
      End If

      Set drs = Nothing
      Set trs = Nothing
    
      dateiRS.Fields("VerantwortlicheOEID").value = oeitem
      dateiRS.Fields("VerantwortlicherAutor").value = VerantwortlicherAutor
      dateiRS.Fields("FachlichVerantwortlicher").value = FachlichVerantwortlicher
      dateiRS.Fields("DokuID").value = newdokuid
    End If
    
    CheckForCurrentDoku = True

End Function

Sub GetLayoutCoords(ByVal conn As Connection, ByVal rs As Recordset, ByRef layoutX As Long, ByRef layoutY As Long, _
                ByRef layoutW As Long, ByRef layoutH As Long, ByRef FontSize As Long, ByRef color As Long, ByRef bgColor As Long, ByVal controlTyp As Long)

    layoutX = rs.Fields("X").value
    layoutY = rs.Fields("Y").value
    layoutW = rs.Fields("W").value
    layoutH = rs.Fields("H").value
    FontSize = rs.Fields("Textgroesse").value
    color = rs.Fields("Textfarbe").value
    bgColor = GetValueFromField(rs, "Hintergrundfarbe", 0)
   

    ' in VB6 wird in BGR gerechnet, nicht in RGB
    color = ((color And &HFF0000) / 65536) Or (color And &HFF00&) Or ((color And &HFF&) * 65536)
    bgColor = ((bgColor And &HFF0000) / 65536) Or (bgColor And &HFF00&) Or ((bgColor And &HFF&) * 65536)

End Sub

Private Function IsUnderlinedText(ByRef rs As Object) As Boolean
    IsUnderlinedText = IIf((GetSafeFieldPlus(rs, "Textgroesse", 8) And 512) <> 0, True, False)
End Function

Private Function IsItalicText(ByRef rs As Object) As Boolean
    IsItalicText = IIf((GetSafeFieldPlus(rs, "Textgroesse", 8) And 1024) <> 0, True, False)
End Function

Private Function IsBoldText(ByRef rs As Object) As Boolean
    IsBoldText = IIf((GetSafeFieldPlus(rs, "Textgroesse", 8) And 256) <> 0, True, False)
End Function

Sub ShowDoku(ByRef officeapp As Object, ByRef dateiRS As Object, ByRef conn As Object, ByRef curdoc As Object, Optional readOnly As Boolean = False, Optional notSavedYet As Boolean = False, Optional fragenAntwortenAnzeigen As Boolean = False)

    On Error GoTo nogo

    Dim trackpos As Long
    
    Dim cdo As CDataObject

'    Dim doku As New frmDoku


'   CheckForCurrentDoku dateiRs, conn

    ' sieht man das ding schon?
    Application.Cursor = xlWait
    
    G_ReadOnly = readOnly
#If Project_ExcelTracker = 1 Then
    If G_ReadOnly = False Then
      G_ReadOnly = curdoc.readOnly
    End If
#End If

    ' If frmDoku.visible Then
    If IsFormLoaded("frmDoku") Then
      ' If StatusForm.visible Then
      If IsFormLoaded("StatusForm") Then
        HideStatusForm
      End If
      Application.Cursor = xlDefault
      'MsgBox "Das Dokufenster wurde bereits f|fffd|r eine andere Datei ge|fffd|ffnet. Bitte schlie|fffd|en Sie erst dieses Doku-Fenster!", vbInformation, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
      MsgBox FMT0("THISADDIN_7"), vbInformation, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
      Exit Sub
    End If

    trackpos = 10
    
    If G_ReadOnly = False And IsSharedWorkbook(curdoc) Then
        If StatusForm.visible Then
          HideStatusForm
        End If
        'MsgBox "Die Dokumentation kann nicht ge|fffd|ndert werden, da die Microsoft-Freigabe verwendet wurde (""Arbeitsmappe freigeben""). Bitte entfernen Sie die Freigabe, um |fffd|nderungen an der Dokumentation vorzunehmen."
        MsgBox FMT0("THISADDIN_6"), vbInformation, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        readOnly = True
        G_ReadOnly = readOnly
    End If

    trackpos = 20

    If Not StatusForm.visible Then
      'ShowStatusForm "Lade Doku...", False
      ShowStatusForm FMT0("THISADDIN_9"), False
    End If

    DebugPrint DebType.tTime, "Doku 4.1"
    Load frmDoku
    frmDoku.m_InInit = True
    Set frmDoku.colScripts = New Collection
    Set frmDoku.colControls = New Collection
    Set frmDoku.colNewRSValues = New Collection
    
    trackpos = 30
    
    frmDoku.Initialize
    DebugPrint DebType.tTime, "Doku 4.2"

    ' XXX FIX Value = NULL

    G_DateiID = dateiRS.Fields("idvDateiID").value
    G_Version = WBGetValueLong(curdoc, "_IDVTrackerVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix) ' dateiRs.Fields("Version").Value

    trackpos = 40

    Dim locVersion As Long
    Dim locDateiID As Long
    locVersion = G_Version
    locDateiID = G_DateiID

    G_DokuOKClicked = False

    G_FreigegebenesProgramm = 0
    ' If dateiRS.Fields("FreigabeStatus").value > 0 Then
    If IstDateiFreigabeStatusInitiiertOderFreigegeben(dateiRS) = True Then
        G_FreigegebenesProgramm = dateiRS.Fields("FreigabeStatus").value
    ElseIf IstDateiFreigabeStatusDeaktiviert(dateiRS) = True Then
        G_FreigegebenesProgramm = 2
        G_ReadOnly = True
    End If

    DebugPrint DebType.tTime, "Doku 4.3"

    Dim rs As Object
    Set rs = CreateObject("ADODB.Recordset")

    frmDoku.m_SBSID = CStr(GetSafeFieldPlus(dateiRS, "SBSAssetID", 0))
    frmDoku.m_SBSLastActiveID = frmDoku.m_SBSID
    frmDoku.m_SBSOE = ""
    frmDoku.m_SBSGroupHash = GetSafeFieldPlus(dateiRS, "SBSGroupHash", 0)
    frmDoku.DokuAllgemein_Init curdoc, conn, dateiRS, locDateiID, locVersion, notSavedYet

    DebugPrint DebType.tTime, "Doku 5"

    Dim dokuID As Long
    dokuID = -1

    Dim selitem As Long
    Dim oeitem As Long
    oeitem = -1

    ' ---------------------------------------------------------------------
    ' Erst mal aus der Dateiendoku die relevanten Felder holen und anzeigen
    ' ---------------------------------------------------------------------
    Dim VerantwortlicherAutor As String
    Dim FachlichVerantwortlicher As String
    If GetFileDoku(dateiRS, conn, dokuID, locDateiID, locVersion, selitem, oeitem, VerantwortlicherAutor, FachlichVerantwortlicher) = -2 Then
        HideStatusForm
        Application.Cursor = xlDefault
        'MsgBox "Diese Dokumentation ist derzeit nicht aufrufbar, bitte versuchen Sie es sp|fffd|ter noch einmal.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        MsgBox FMT0("THISADDIN_8"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        Exit Sub
    End If
    
    frmDoku.DokuAllgemein_VerantwortlicherAutorSetzen conn, dateiRS, VerantwortlicherAutor, oeitem, FachlichVerantwortlicher
    frmDoku.DokuAllgemein_EinsatzartenSetzen conn, selitem
    
    G_EigeneDokuID = -1
    If locVersion = G_Version And locDateiID = G_DateiID Then
      G_EigeneDokuID = dokuID
    End If


    DebugPrint DebType.tTime, "Doku 6"

    Dim drs As Object
    Set drs = CreateObject("ADODB.Recordset")

    frmDoku.DokuAllgemein_InitFreigabeStatus
    If G_FreigegebenesProgramm > 0 Or G_ReadOnly = True Then
        frmDoku.InAdd.Enabled = False
        frmDoku.InDelete.Enabled = False
        frmDoku.OutAdd.Enabled = False
        frmDoku.OutDelete.Enabled = False
        frmDoku.EBAdd.Enabled = False
        frmDoku.EBDelete.Enabled = False
    End If
    
    If G_ReadOnly = True Then
        frmDoku.DateiHinzufuegen.Enabled = False
        frmDoku.DateiEntfernen.Enabled = False
        frmDoku.cmdGeoeffneteDatei.Enabled = False
        frmDoku.PasswordList.Enabled = False
    End If
    If G_PARAM_DateianhaengeNichtVeraenderbar = True Then
        frmDoku.DateiEntfernen.Enabled = False
    End If

    Dim duptextcnt As Long
    Dim duptextmlcnt As Long
    Dim duplabelcnt As Long
    Dim duplistcnt As Long
    Dim dupcmbcnt As Long
    Dim duplinkcnt As Long
    Dim dupcheckcnt As Long
    Dim edText As String
    Dim schonEditiert As String
    Dim colNochNichtEditiert As New Collection
    Set frmDoku.colMussFelder = New Collection
    Set frmDoku.colLinks = New Collection
    Dim coSL As CStringLong
    
    Dim myTextColl As Collection
    Set myTextColl = New Collection
    Dim tMyTextBox As MyTextBox
    Dim myComboColl As Collection
    Set myComboColl = New Collection
    Dim tMyComboBox As MyComboBox
    Dim myLabelColl As Collection
    Set myLabelColl = New Collection
    Dim tMyLabel As MyLabel
    Dim ctrl As Object

    ' ---------------------------------------------------------------------
    ' Und jetzt existente Dokufelder holen, erzeugen und anzeigen
    ' ---------------------------------------------------------------------
    ' rs.Open "SELECT * FROM gDokufelder WHERE Deaktiviert = 0 ORDER BY Position", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
    
    
    
'    rs.Open "SELECT gDokufelder.*, a.Text FROM gDokufelder LEFT JOIN (SELECT idvDateienDokuTextfelder.idvDateiDokuID, idvDateienDokuTextfelder.Version, idvDateienDokuTextfelder.DokuFeldID, idvDateienDokuTextfelder.Text " & _
'      "FROM idvDateienDokuTextfelder where idvDateienDokuTextfelder.idvDateiDokuID = " & dokuId & " And idvDateienDokuTextfelder.Version = " & locVersion & ") a " & _
'      "ON gDokufelder.DokuFeldID = a.DokuFeldID where gDokufelder.Deaktiviert = 0 ORDER BY gDokufelder.Position", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
    
    ' Access
'    If G_DBType = 4 Then
      rs.Open "SELECT a.Text, gDokufelder.Mussfeld, gDokufelder.Seitentitel, ur.LokalisierterText as LocSeitentitel, gDokufelder.DokuName, gDokufelder.DokufeldID, " & _
      " gDokufelder.DokuFeldtypID, gDokufelder.Feldnummer, gDokufelder.StandardText, u.LokalisierterText as LocStandardText, " & _
      " gDokufelder.x, gDokufelder.y, gDokufelder.w, gDokufelder.h, gDokufelder.Position, gDokufelder.RisikowertVon, gDokufelder.RisikowertBis, gDokufelder.Deaktiviert, " & _
      " gDokufelder.VorFreigabe, gDokufelder.InFreigabe, gDokufelder.NachFreigabe, gDokufelder.Script, gDokufelder.StandardtextReicht, gDokufelder.TextId, gDokufelder.Textgroesse, gDokufelder.Textfarbe, gDokufelder.HintergrundFarbe " & _
      " FROM " & _
      " (((gDokufelder inner join gDokufelderReiter r on gDokufelder.ReiterID = r.DokufeldReiterID) " & _
      " left join gTexteUebersetzungen ur on (r.DokufeldReiterTextID = ur.TextID and ur.LanguageID = " & GetMyDBLanguage(conn) & ")) " & _
      " left join gTexteUebersetzungen u on (gDokufelder.TextID = u.TextID and u.LanguageID = " & GetMyDBLanguage(conn) & ")) " & _
      " LEFT JOIN (SELECT idvDateienDokuTextfelder.idvDateiDokuID, idvDateienDokuTextfelder.Version, idvDateienDokuTextfelder.DokuFeldID, idvDateienDokuTextfelder.Text, idvDateienDokuTextfelder.Feldnummer FROM idvDateienDokuTextfelder where idvDateienDokuTextfelder.idvDateiDokuID = " & dokuID & " And idvDateienDokuTextfelder.Version = " & locVersion & ") a ON gDokufelder.Feldnummer = a.Feldnummer " & _
      " where gDokufelder.Deaktiviert = 0 ORDER BY r.TabOrder", conn, ADODB.CursorTypeEnum.adOpenForwardOnly, ADODB.LockTypeEnum.adLockReadOnly
'    End If
    
    ' TODO - hier soll wohl das rein (aus dem VB6 Tracker)
'    rs.Open "SELECT a.Text, gDokufelder.Seitentitel, ur.LokalisierterText as LocSeitentitel, gDokufelder.DokuName, gDokufelder.DokufeldID, " & _
'    " gDokufelder.DokuFeldtypID, gDokufelder.Feldnummer, gDokufelder.StandardText, u.LokalisierterText as LocStandardText, " & _
'    " gDokufelder.x, gDokufelder.y, gDokufelder.w, gDokufelder.h, gDokufelder.Position, gDokufelder.RisikowertVon, gDokufelder.RisikowertBis, gDokufelder.Deaktiviert, " & _
'    " gDokufelder.VorFreigabe, gDokufelder.InFreigabe, gDokufelder.NachFreigabe, gDokufelder.Script, gDokufelder.StandardtextReicht, gDokufelder.TextId, gDokufelder.Textgroesse, gDokufelder.Textfarbe " & _
'    " FROM " & _
'    " (((gDokufelder inner join gDokufelderReiter r on gDokufelder.ReiterID = r.DokufeldReiterID) " & _
'    " left join gTexteUebersetzungen ur on (r.DokufeldReiterTextID = ur.TextID and ur.LanguageID = " & GetMyDBLanguage(conn) & ")) " & _
'    " left join gTexteUebersetzungen u on (gDokufelder.TextID = u.TextID and u.LanguageID = " & GetMyDBLanguage(conn) & ")) " & _
'    " LEFT JOIN (SELECT idvDateienDokuTextfelder.idvDateiDokuID, idvDateienDokuTextfelder.Version, idvDateienDokuTextfelder.DokuFeldID, idvDateienDokuTextfelder.Text, idvDateienDokuTextfelder.Feldnummer FROM idvDateienDokuTextfelder where idvDateienDokuTextfelder.idvDateiDokuID = " & dokuId & " And idvDateienDokuTextfelder.Version = " & locVersion & ") a ON gDokufelder.Feldnummer = a.Feldnummer " & _
'    " where gDokufelder.Deaktiviert = 0 ORDER BY gDokufelder.Position", conn, ADODB.CursorTypeEnum.adOpenForwardOnly, ADODB.LockTypeEnum.adLockReadOnly
    
    frmDoku.m_EditableFeldnummern = ""
    
    Dim anzuzeigendeControlsCol As Collection
    Set anzuzeigendeControlsCol = New Collection
    
    ' Fuer die Dokufelder controls
    Set frmDoku.m_colScriptValues = New Collection
    PrepareScriptVars dateiRS, frmDoku.m_colScriptValues, Nothing
    If IsNull(dateiRS.Fields("SBSAssetID").value) = False Then
        PrepareScriptVarsSBSWithConnection conn, dateiRS.Fields("SBSAssetID").value, "", frmDoku.m_colScriptValues
    End If
          
    If Not rs.EOF Then
          Dim anzeigen As Boolean
          Dim script As String
          Dim mussfeld As Boolean
          
          rs.MoveLast
          Dim totalamProgress As Double
          totalamProgress = rs.RecordCount * 2
          Dim cntProgress As Double
          cntProgress = 0
          rs.MoveFirst
          
          Do While Not rs.EOF
              ' REMOVEDEBUG
              ' DebugPrint DebType.tTime, "Doku Seite " & rs.Fields("Seitentitel").value
              Dim i As Integer
              Dim found As Boolean
              found = False
      
              If rs.Fields("Deaktiviert").value = False Then
                anzeigen = GetValueFromField(rs, "RisikowertVon", 0) <= CDbl(GetValueFromField(dateiRS, "Risikowert", 0)) And GetValueFromField(dateiRS, "Risikowert", 0) <= CDbl(GetValueFromField(rs, "RisikowertBis", 1))
                ' Falls es ein Script gibt das Script nehmen
                script = GetSafeField(rs, "Script")
                mussfeld = False
                If script <> "" Then
                    'If InStr(script, "#SBS_") > 0 Then
                    '    anzeigen = True
                    'Else
                        anzeigen = DokufeldAnzeigenFromScript(frmDoku.m_ObjScript, rs.Fields("Dokuname").value, Nothing, GetValueFromField(rs, "DokuFeldtypID", 3), False, script, dateiRS, mussfeld, frmDoku.m_colScriptValues)
                    'End If
                End If
                
                If anzeigen Then
                
                    anzuzeigendeControlsCol.add rs.Fields("Dokuname").value, rs.Fields("Dokuname").value
                
                    If frmDoku.TabControl.Pages.count >= C_DokuTabPageStart Then
                        For i = C_DokuTabPageStart To frmDoku.TabControl.Pages.count - 1
                            If frmDoku.TabControl.Pages(i).Caption = GetLocValueFromField(rs, "Seitentitel", "LocSeitentitel", FMT0("FREIGABEF_4")) Then
                                found = True
                                Exit For
                            End If
                        Next
                    End If
                    If Not found Then
                        frmDoku.TabControl.Pages.add "page", GetLocValueFromField(rs, "Seitentitel", "LocSeitentitel", FMT0("FREIGABEF_4"))
                        i = frmDoku.TabControl.Pages.count - 1
                    End If
                End If
              End If
              cntProgress = cntProgress + 1
              'UpdateStatusForm "Lade Doku...", cntProgress / totalamProgress
              UpdateStatusForm FMT0("THISADDIN_9"), cntProgress / totalamProgress
              rs.MoveNext
          Loop
          DebugPrint DebType.tTime, "Doku 7 - DokuReiter erzeugt"
          
          rs.MoveFirst
          frmDoku.m_Dokufeldcount = 0
          
          Do While Not rs.EOF
      '        Dim i As Integer
      '        Dim found As Boolean
              found = False
      
              ' REMOVEDEBUG
              ' DebugPrint DebType.tTime, "Doku Feld " & rs.Fields("Dokuname").value
              If rs.Fields("Deaktiviert").value = False Then
                anzeigen = GetValueFromField(rs, "RisikowertVon", 0) <= CDbl(GetValueFromField(dateiRS, "Risikowert", 0)) And GetValueFromField(dateiRS, "Risikowert", 0) <= CDbl(GetValueFromField(rs, "RisikowertBis", 1))
                ' Falls es ein Script gibt das Script nehmen
                script = GetSafeField(rs, "Script")
                mussfeld = GetSafeFieldPlus(rs, "Mussfeld", False)
                If script <> "" Then
                    'If InStr(script, "#SBS_") > 0 Then
                    '    anzeigen = True
                    'Else
                        If CollectionStringExists(anzuzeigendeControlsCol, rs.Fields("Dokuname").value) Then
                          anzeigen = True
                        Else
                          anzeigen = False
                        End If
                    'End If
                End If
              
                ' REMOVEDEBUG
                ' DebugPrint DebType.tTime, "Doku Feld 1 - " & rs.Fields("Dokuname").value
                If anzeigen Then
                    frmDoku.m_Dokufeldcount = frmDoku.m_Dokufeldcount + 1
                    If frmDoku.TabControl.Pages.count >= C_DokuTabPageStart Then
                        For i = C_DokuTabPageStart To frmDoku.TabControl.Pages.count - 1
                            If frmDoku.TabControl.Pages(i).Caption = GetLocValueFromField(rs, "Seitentitel", "LocSeitentitel", FMT0("FREIGABEF_4")) Then
                                found = True
                                Exit For
                            End If
                        Next
                    End If
                    If Not found Then
                        frmDoku.TabControl.Pages.add GetLocValueFromField(rs, "Seitentitel", "LocSeitentitel", FMT0("FREIGABEF_4"))
                        i = frmDoku.TabControl.Pages.count - 1
                    End If
        
                    ' REMOVEDEBUG
                    ' DebugPrint DebType.tTime, "Doku Feld 2 - " & rs.Fields("Dokuname").value
                    Dim feldAktiv As Boolean
                    feldAktiv = False
                    If Not readOnly Then
                      If G_FreigegebenesProgramm = 0 And GetValueFromField(rs, "VorFreigabe", 0) <> 0 Then
                        feldAktiv = True
                      ElseIf G_FreigegebenesProgramm = 1 And GetValueFromField(rs, "InFreigabe", 0) <> 0 Then
                        feldAktiv = True
                      ElseIf G_FreigegebenesProgramm = 2 And GetValueFromField(rs, "NachFreigabe", 0) <> 0 Then
                        feldAktiv = True
                      ElseIf G_FreigegebenesProgramm = 0 And GetValueFromField(rs, "VorFreigabe", 0) = 0 And GetValueFromField(rs, "InFreigabe", 0) = 0 And GetValueFromField(rs, "NachFreigabe", 0) = 0 Then
                        feldAktiv = True
                      End If
                    End If
                    
                    ' mussfeld kann nur true sein, wenn das Feld selber editierbar ist
                    If feldAktiv = False Then
                       mussfeld = False
                    End If
                    
                    Dim standardtextReicht As Long
                    standardtextReicht = 0
                    ' REMOVEDEBUG
                    ' DebugPrint DebType.tTime, "Doku Feld 3 - " & rs.Fields("Dokuname").value
                    If Not IsNull(rs.Fields("StandardtextReicht").value) Then
                      If rs.Fields("StandardtextReicht").value <> 0 Then
                        standardtextReicht = 10000000
                      End If
                    End If
                    
                    Dim layoutX As Long, layoutY As Long, layoutW As Long, layoutH As Long
                    Dim color As Long, fntsize As Long
                    Dim bgColor As Long
                    GetLayoutCoords conn, rs, layoutX, layoutY, layoutW, layoutH, fntsize, color, bgColor, 0
        
                    If feldAktiv Then
                        frmDoku.m_EditableFeldnummern = frmDoku.m_EditableFeldnummern & IIf(frmDoku.m_EditableFeldnummern <> "", ",", "") & rs.Fields("Feldnummer").value
                    End If
                    
                    ' REMOVEDEBUG
                    ' DebugPrint DebType.tTime, "Doku Feld 4 - " & rs.Fields("Dokuname").value
                    Dim ctrlName As String
                    ctrlName = rs.Fields("Dokuname").value
'                    ctrlName = Replace(ctrlName, " ", "_")
                    
                    schonEditiert = False
                    Dim standardText As String
                    standardText = GetLocValueFromField(rs, "Standardtext", "LocStandardtext", "")
                    
                    Select Case GetValueFromField(rs, "DokuFeldtypID", 3)
                        Case 1, 2, 3
                            duptextmlcnt = duptextmlcnt + 1
                            Set tMyTextBox = New MyTextBox
                            tMyTextBox.Init frmDoku, -1
                            
                            Set ctrl = frmDoku.TabControl.Pages(i).add("Forms.Textbox.1")
                            Set tMyTextBox.TextBoxEvents = ctrl
                            
                            ' Control f|fffd|r einfachen Zugriff speichern
                            frmDoku.colControls.add ctrl, ConvertToUcaseVarName(rs.Fields("Dokuname").value)
                            
                            With tMyTextBox.TextBoxEvents
                                .name = "Ctrl" & (duptextmlcnt + 10000 + 100000 * i)
                                .Enabled = feldAktiv
                                .tag = rs.Fields("DokuFeldID").value & "," & rs.Fields("DokuFeldtypID").value & "," & CStr(rs.Fields("Feldnummer").value) & "," & IIf(feldAktiv = True, 1, 0) & "," & ctrlName
                                .Left = PixelsToTwipsX(layoutX)
                                .Top = PixelsToTwipsY(XLA_TABCTRL_YOFF + layoutY) ' PixelsToTwipsY(22 + rs.Fields("Y").Value + 22 + Int((frmDoku.TabControl.Pages.Count - i) / 4) * C_TabOffset)
                                .width = PixelsToTwipsX(layoutW)
                                .Height = PixelsToTwipsY(layoutH)
                                .ForeColor = color
                                .FontBold = IsBoldText(rs)
                                .FontItalic = IsItalicText(rs)
                                .FontUnderline = IsUnderlinedText(rs)
                                .FontSize = GetMax(8, GetSafeFieldPlus(rs, "Textgroesse", 8) And 255)
                                Select Case GetValueFromField(rs, "DokuFeldtypID", 3)
                                  Case 1
                                    .MultiLine = True
                                    .ScrollBars = 2
                                    .EnterKeyBehavior = True
                                    .MaxLength = IIf(rs.Fields("Standardtext").DefinedSize > 32000, 32000, IIf(rs.Fields("Standardtext").DefinedSize <= 0, 32000, rs.Fields("Standardtext").DefinedSize))
                                  Case 2
                                    .MaxLength = 50
                                  Case 3
                                    .MaxLength = 255
                                End Select
                                .Text = standardText
                                .visible = True
                                                       
                                If bgColor <> 0 Then
                                    .BackColor = bgColor And &HFFFFFF
                                End If
                            
                                schonEditiert = False
                                If mussfeld = True Then
                                   Set coSL = New CStringLong
                                   coSL.m_S = Trim(.Text)
                                   coSL.m_L = duptextmlcnt + 10000 + 100000 * i + standardtextReicht
                                   frmDoku.colMussFelder.add coSL
                                End If
                                
                                edText = ""
                                If Not IsNull(rs.Fields("Text").value) Then
                                  edText = GetValueFromField(rs, "Text", "")
                                  If edText <> .Text Then
                                      .Text = edText ' GetValueFromField(drs, "Text", "")
                                      schonEditiert = True
                                  End If
                                End If
                            
                            End With
                            myTextColl.add tMyTextBox
                    
                        
                        Case 4
                           duplistcnt = duplistcnt + 1
                           Set ctrl = frmDoku.TabControl.Pages(i).add("Forms.ListBox.1")
                           
                           ' Control f|fffd|r einfachen Zugriff speichern
                           frmDoku.colControls.add ctrl, ConvertToUcaseVarName(rs.Fields("Dokuname").value)
                           
                           With ctrl
                                .name = "Ctrl" & (duplistcnt + 10000 + 100000 * i)
                                .Enabled = feldAktiv
                                .tag = rs.Fields("DokuFeldID").value & "," & rs.Fields("DokuFeldtypID").value & "," & CStr(rs.Fields("Feldnummer").value) & "," & IIf(feldAktiv = True, 1, 0) & "," & ctrlName
                                .Left = PixelsToTwipsX(layoutX)
                                .Top = PixelsToTwipsY(XLA_TABCTRL_YOFF + layoutY) ' PixelsToTwipsY(22 + rs.Fields("Y").Value + 22 + Int((frmDoku.TabControl.Pages.Count - i) / 4) * C_TabOffset)
                                .width = PixelsToTwipsX(layoutW)
                                .Height = PixelsToTwipsY(layoutH)
                                .visible = True
                                .MultiSelect = 1
                                .ForeColor = color
                                .FontBold = IsBoldText(rs)
                                .FontItalic = IsItalicText(rs)
                                .FontUnderline = IsUnderlinedText(rs)
                                .FontSize = GetMax(8, GetSafeFieldPlus(rs, "Textgroesse", 8) And 255)
                                If bgColor <> 0 Then
                                    .BackColor = bgColor And &HFFFFFF
                                End If
                    
                                edText = GetValueFromField(rs, "Text", "")
                        
                                drs.Open "Select Wert, Nummer, u.LokalisierterText as Loc from gDokufelderWerte left join gTexteUebersetzungen u on (u.TextID = gDokufelderWerte.TextID and u.LanguageID = " & GetMyDBLanguage(conn) & ") where Feldnummer =" & rs.Fields("Feldnummer").value, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
                                While Not drs.EOF
                                    .AddItem GetLocValueFromField(drs, "Wert", "Loc", "")
                                    Dim v As String
                                    v = GetValueFromField(drs, "Nummer", "")
                                    If v <> "" Then
                                        .List(.ListCount - 1, 1) = CLng(v)
                                        If InStr(edText, v & "|") > 0 Then
                                            .Selected(.ListCount - 1) = True
                                        End If
                                    End If
                                    drs.MoveNext
                                Wend
                                drs.Close
                            End With
                        
                        Case 5
                            dupcmbcnt = dupcmbcnt + 1
                            Set tMyComboBox = New MyComboBox
                            tMyComboBox.Init frmDoku, dupcmbcnt
                            Set ctrl = frmDoku.TabControl.Pages(i).add("Forms.ComboBox.1")
                            Set tMyComboBox.ComboBoxEvents = ctrl
                            
                            ' Control f|fffd|r einfachen Zugriff speichern
                            frmDoku.colControls.add ctrl, ConvertToUcaseVarName(rs.Fields("Dokuname").value)
                            
                            With tMyComboBox.ComboBoxEvents
                                .name = "Ctrl" & (duplistcnt + 10000 + 100000 * i)
                                .Enabled = feldAktiv
                                .tag = rs.Fields("DokuFeldID").value & "," & rs.Fields("DokuFeldtypID").value & "," & CStr(rs.Fields("Feldnummer").value) & "," & IIf(feldAktiv = True, 1, 0) & "," & ctrlName
                                .Left = PixelsToTwipsX(layoutX)
                                .Top = PixelsToTwipsY(XLA_TABCTRL_YOFF + layoutY) ' PixelsToTwipsY(22 + rs.Fields("Y").Value + 22 + Int((frmDoku.TabControl.Pages.Count - i) / 4) * C_TabOffset)
                                .width = PixelsToTwipsX(layoutW)
                                .Height = PixelsToTwipsY(layoutH)
                                .visible = True
                                .Style = 2
                                .ForeColor = color
                                .FontBold = IsBoldText(rs)
                                .FontItalic = IsItalicText(rs)
                                .FontUnderline = IsUnderlinedText(rs)
                                .FontSize = GetMax(8, GetSafeFieldPlus(rs, "Textgroesse", 8) And 255)
                                If bgColor <> 0 Then
                                    .BackColor = bgColor And &HFFFFFF
                                End If
                        
                                edText = GetValueFromField(rs, "Text", "")
                        
                                If UCase(ctrlName) = "SBSOE" Then
                                    If IsNull(frmDoku.m_SBSID) = False Then
                                        If frmDoku.m_SBSID <> "" And frmDoku.m_SBSID <> "0" Then
                                            schonEditiert = True
                                        End If
                                    End If
                                ElseIf UCase(ctrlName) = "SBSID" Then
                                    If IsNull(frmDoku.m_SBSID) = False Then
                                        If frmDoku.m_SBSID <> "" And frmDoku.m_SBSID <> "0" Then
                                            schonEditiert = True
                                        End If
                                    End If
                                Else
                                    drs.Open "Select Wert, Nummer, u.LokalisierterText as Loc from gDokufelderWerte left join gTexteUebersetzungen u on (u.TextID = gDokufelderWerte.TextID and u.LanguageID = " & GetMyDBLanguage(conn) & ") where Feldnummer =" & rs.Fields("Feldnummer").value, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
                                    While Not drs.EOF
                                        .AddItem GetLocValueFromField(drs, "Wert", "Loc", "")
                                        Dim vr As String
                                        vr = GetValueFromField(drs, "Nummer", "")
                                        If vr <> "" Then
                                            .List(.ListCount - 1, 1) = CLng(vr)
                                            If InStr(edText, vr & "|") > 0 Then
                                                .Text = GetValueFromField(drs, "Wert", "")
                                            End If
                                        End If
                                        drs.MoveNext
                                    Wend
                                    drs.Close
                                End If
                           End With
                           myComboColl.add tMyComboBox
                    
                    Case 6
                            dupcheckcnt = dupcheckcnt + 1
                            Set ctrl = frmDoku.TabControl.Pages(i).add("Forms.checkbox.1")
                            ' Control f|fffd|r einfachen Zugriff speichern
                            frmDoku.colControls.add ctrl, ConvertToUcaseVarName(rs.Fields("Dokuname").value)
                            
                            With ctrl
                                .name = "Ctrl" & (duplistcnt + 10000 + 100000 * i)
                                .Enabled = feldAktiv
                                .tag = rs.Fields("DokuFeldID").value & "," & rs.Fields("DokuFeldtypID").value & "," & CStr(rs.Fields("Feldnummer").value) & "," & IIf(feldAktiv = True, 1, 0) & "," & ctrlName
                                .Left = PixelsToTwipsX(layoutX)
                                .Top = PixelsToTwipsY(XLA_TABCTRL_YOFF + layoutY) ' PixelsToTwipsY(22 + rs.Fields("Y").Value + 22 + Int((frmDoku.TabControl.Pages.Count - i) / 4) * C_TabOffset)
                                .width = PixelsToTwipsX(layoutW)
                                .Height = PixelsToTwipsY(layoutH)
                                .visible = True
                                .Caption = standardText
                                .ForeColor = color
                                .FontBold = IsBoldText(rs)
                                .FontItalic = IsItalicText(rs)
                                .FontUnderline = IsUnderlinedText(rs)
                                .FontSize = GetMax(8, GetSafeFieldPlus(rs, "Textgroesse", 8) And 255)
                                If bgColor <> 0 Then
                                    .BackColor = bgColor And &HFFFFFF
                                End If
                                
                                edText = GetValueFromField(rs, "Text", "")
                                If edText <> "" Then
                                    .value = 1
                                End If
                            End With
                        Case 7
                            ' Link
                            duptextcnt = duptextcnt + 1
                            Set ctrl = frmDoku.TabControl.Pages(i).add("Forms.TextBox.1")
                            
                            ' Control f|fffd|r einfachen Zugriff speichern
                            frmDoku.colControls.add ctrl, ConvertToUcaseVarName(rs.Fields("Dokuname").value)
                            
                            With ctrl
                                .Enabled = feldAktiv
                                .MaxLength = 250
                                .tag = rs.Fields("DokuFeldID").value & "," & rs.Fields("DokuFeldtypID").value & "," & CStr(rs.Fields("Feldnummer").value) & "," & IIf(feldAktiv = True, 1, 0) & "," & ctrlName
                                .Left = PixelsToTwipsX(layoutX)
                                .Top = PixelsToTwipsY(XLA_TABCTRL_YOFF + layoutY) ' PixelsToTwipsY(22 + rs.Fields("Y").Value + 22 + Int(i / 4) * C_TabOffset)
                                .width = PixelsToTwipsX(layoutW)
                                .Height = PixelsToTwipsY(layoutH)
                                .visible = True
                                .Text = standardText
                                .ForeColor = color
                                .FontBold = IsBoldText(rs)
                                .FontItalic = IsItalicText(rs)
                                .FontUnderline = IsUnderlinedText(rs)
                                .FontSize = GetMax(8, GetSafeFieldPlus(rs, "Textgroesse", 8) And 255)
                                If bgColor <> 0 Then
                                    .BackColor = bgColor And &HFFFFFF
                                End If
                            End With
                            
                            ' Link Button hinzuf|fffd|gen
                            duplinkcnt = duplinkcnt + 1
                            Dim cmd
                            Set cmd = frmDoku.TabControl.Pages(i).add("Forms.CommandButton.1")
                            With cmd
                                .Enabled = True
                                .Left = PixelsToTwipsX(layoutX + layoutW)
                                .Top = PixelsToTwipsY(XLA_TABCTRL_YOFF + layoutY) ' PixelsToTwipsY(22 + rs.Fields("Y").Value + 22 + Int(i / 4) * C_TabOffset)
                                .width = PixelsToTwipsX(24)
                                .Height = PixelsToTwipsY(24)
                                .visible = True
                                .Picture = LoadPicture(G_StartupPath & "gfx\earth_result.bmp")
                                .name = "BtLink" & duplinkcnt
                            End With
                            
                            schonEditiert = False
                            If mussfeld = True Then
                               Set coSL = New CStringLong
                               coSL.m_S = Trim(ctrl.Text)
                               coSL.m_L = duptextcnt + 100000 * i + standardtextReicht
                               frmDoku.colMussFelder.add coSL
                            End If
                            
                            If Not IsNull(rs.Fields("Text").value) Then
                              edText = GetValueFromField(rs, "Text", "")
                              If edText <> ctrl.Text Then
                                   ctrl.Text = edText ' GetValueFromField(drs, "Text", "")
                                   schonEditiert = True
                              End If
                            End If
                            

                            frmDoku.AddLnkObj cmd, duplinkcnt
                            frmDoku.colLinks.add ctrl.Text, CStr(duplinkcnt)
                         
                         Case 8
                            
                            Dim processedStandardtext As String
                            processedStandardtext = ""
                            If standardText <> "" Then
                                Dim erram As Long
                                Dim errTxt As String
                                erram = 0
                                processedStandardtext = PlausitestScriptinterpreter(Nothing, standardText, errTxt, erram, frmDoku.m_colScriptValues)
                                If erram > 0 Then
                                    Call DebugPrint(tinfo, "Error while replacing Dokufelder placeholders!")
                                End If
                            End If
                            
                            Set tMyLabel = New MyLabel
                            tMyLabel.Init frmDoku, duplabelcnt
                            
                            Set ctrl = frmDoku.TabControl.Pages(i).add("Forms.Label.1")
                            Set tMyLabel.LabelEvents = ctrl
                            
                            ' Control f|fffd|r einfachen Zugriff speichern
                            frmDoku.colControls.add ctrl, ConvertToUcaseVarName(rs.Fields("Dokuname").value)
                            
                            With tMyLabel.LabelEvents
                                .tag = rs.Fields("DokuFeldID").value & "," & rs.Fields("DokuFeldtypID").value & "," & CStr(rs.Fields("Feldnummer").value) & "," & IIf(feldAktiv = True, 1, 0) & "," & ctrlName
                                .Left = PixelsToTwipsX(layoutX)
                                .Top = PixelsToTwipsY(XLA_TABCTRL_YOFF + layoutY)
                                .width = PixelsToTwipsX(layoutW)
                                .Height = PixelsToTwipsY(layoutH)
                                .visible = True
                                .Caption = processedStandardtext
                                .FontBold = IsBoldText(rs)
                                .FontItalic = IsItalicText(rs)
                                .FontUnderline = IsUnderlinedText(rs)
                                .FontSize = GetMax(8, GetSafeFieldPlus(rs, "Textgroesse", 8) And 255)
                                .name = "BtLabel" & frmDoku.TabControl.Pages(i).count
                                If bgColor <> 0 Then
                                    .BackColor = bgColor And &HFFFFFF
                                End If
                            End With
                            myLabelColl.add tMyLabel
                            
                            
                    End Select
                    
                    ' Scripte speichern
                    If script <> "" Then
                        DokufeldAnzeigenFromScript frmDoku.m_ObjScript, rs.Fields("Dokuname").value, ctrl, GetValueFromField(rs, "DokuFeldtypID", 3), True, script, dateiRS, mussfeld, frmDoku.m_colScriptValues
                        
                        'teststring = "if #D_BEREICHE_ROLF_VALUE#>1 then Anzeigen = 1 else Anzeigen = 0 end if"
                        If InStr(script, "#D_") > 0 Or InStr(UCase(script), "'<VOLATILE>") > 0 Or InStr(script, "#SBS_") > 0 Or _
                            rs.Fields("Dokuname").value = "SBSID" Or rs.Fields("Dokuname").value = "SBSOE" Or UCase(Left(rs.Fields("Dokuname").value, 4)) = "SBS_" Then
                            Set cdo = New CDataObject
                            cdo.m_Name = CStr(rs.Fields("Dokuname").value)
                            cdo.m_Long = GetValueFromField(rs, "DokuFeldtypID", 3)
                            Set cdo.m_Object = ctrl
                            cdo.m_Text = script
                            frmDoku.colScripts.add cdo, rs.Fields("Dokuname")
                        End If
                    ' Wenn das SBS ist und kein Script dran h|fffd|ngt, dann wird es zu den m_colSimpleSBS gepackt
                    ElseIf UCase(Left(rs.Fields("Dokuname").value, 4)) = "SBS_" Then
                      frmDoku.m_colSimpleSBS.add ctrl, UCase(Mid(rs.Fields("Dokuname").value, 5))
                      If GetValueFromField(rs, "DokuFeldtypID", 3) <> 8 Then
                        ctrl.Enabled = False
                      End If
                    End If
                    
                    ' REMOVEDEBUG
                    ' DebugPrint DebType.tTime, "Doku Feld 5 - " & rs.Fields("Dokuname").value
                    
                    ' noch kein editierter Text vorhanden, also rein in meine Collection
                    If mussfeld = True And schonEditiert = False Then
                       colNochNichtEditiert.add frmDoku.TabControl.Pages(i).Caption, CStr(rs.Fields("dokuFeldID").value) & "," & CStr(rs.Fields("Feldnummer").value)
                    End If
                    ' REMOVEDEBUG
                    ' DebugPrint DebType.tTime, "Doku Feld 5.1 - " & rs.Fields("Dokuname").value
                    
                    If mussfeld = True Then
                      ' wenn ich nur &HFFFF schreibe, wirft das hier eine Exception, also packe ich etwas rot mit in die Farbe
                      ' dann ist es immer noch Gelb, aber wirft keine Exception mehr
                      ctrl.BackColor = &H10FFFF
                    End If
                    
                    Set ctrl = Nothing
                    
                End If
              End If
      '        If frmDoku.DupTextML.UBound >= 2 Then Exit Do
              
              cntProgress = cntProgress + 1
              'UpdateStatusForm "Lade Doku...", cntProgress / totalamProgress
              UpdateStatusForm FMT0("THISADDIN_10"), cntProgress / totalamProgress
              rs.MoveNext
          Loop
    End If
    
    Set ctrl = Nothing
    DebugPrint DebType.tTime, "Doku 9 - Dokufelder erzeugt"
                        
    ' alles was jetzt in meiner Collection ist, hat mindestens einen Text, der nicht editiert wurde
    ' und bekommt deshalb ein Sternchen am Beginn
    For i = C_DokuTabPageStart To frmDoku.TabControl.Pages.count - 1
        Dim cc As Long

        For cc = 1 To colNochNichtEditiert.count
            If colNochNichtEditiert(cc) = frmDoku.TabControl.Pages(i).Caption Then
                frmDoku.TabControl.Pages(i).Caption = "> " & frmDoku.TabControl.Pages(i).Caption
            End If
        Next cc
    Next i
    
    rs.Close
    DebugPrint DebType.tTime, "Doku 9.1"


    Dim paramrs As Object
    Set paramrs = GetParamRS(conn)
    DebugPrint DebType.tTime, "Doku 10"

    If dateiRS.Fields("Risikowert").value >= GetValueFromField(paramrs, "OEAuswahlInDokuAbRisikowert", 1) And GetValueFromField(paramrs, "OEAuswahlInDokuAbRisikowert", 0) >= 0 Then
        ' Also gut, dann wollen wir den Tab mal f|fffd|llen
        ' Erst alle bereits verkn|fffd|pften OEs holen
        SetInOut frmDoku.InSelList, frmDoku.InList, "I", dokuID, conn
        DebugPrint DebType.tTime, "Doku 10.1"
        SetInOut frmDoku.OutSelList, frmDoku.OutList, "O", dokuID, conn
        DebugPrint DebType.tTime, "Doku 10.2"
        G_StoreOEs = True

    Else
        G_StoreOEs = False
        frmDoku.TabControl.Pages(1).visible = False
    End If
    
    G_StoreEinsatzbereiche = False
    frmDoku.TabControl.Pages(2).visible = False
    
    If FieldExists(paramrs, "EinsatzbereicheInDokuAbRisiko") Then
      If Not IsNull(paramrs.Fields("EinsatzbereicheInDokuAbRisiko").value) Then
        If dateiRS.Fields("Risikowert").value >= paramrs.Fields("EinsatzbereicheInDokuAbRisiko").value And paramrs.Fields("EinsatzbereicheInDokuAbRisiko").value >= 0 Then
            ' Also gut, dann wollen wir den Tab mal f|fffd|llen
            ' Erst alle bereits verkn|fffd|pften OEs holen
    
            SetInOutEB frmDoku.EBSelList, frmDoku.EBList, "I", dokuID, conn
            G_StoreEinsatzbereiche = True
            frmDoku.TabControl.Pages(2).visible = True
        End If
      End If
    End If
    
' #If PROJECT_EXCELTRACKER = 1 Then
    ' Die Einatzbereiche gibts nur bei Excel
    frmDoku.TabControl.Pages("TodosInExceldatei").visible = True
' #Else
'    frmDoku.TabControl.Pages(4).Visible = False
' #End If
    
    DebugPrint DebType.tTime, "Doku 11"
    
    ' Zus|fffd|tzliche Dateien Tab f|fffd|llen
    Set frmDoku.colZusaetzlicheDateien = New Collection
    Set frmDoku.colGeloeschteDateien = New Collection
    frmDoku.minValueZusaetzlicheDateien = 0
    frmDoku.zusaetzlicheDateien = False
    frmDoku.EnableButtonsZusaetzlicheDateien
    If Not IsNull(paramrs.Fields("ZusDateienAbRisikowert").value) Then
      If dateiRS.Fields("Risikowert").value >= paramrs.Fields("ZusDateienAbRisikowert").value And paramrs.Fields("ZusDateienAbRisikowert").value >= 0 Then
        frmDoku.zusaetzlicheDateien = True
        If dokuID >= 0 Then
            drs.Open "SELECT x.Dateiname, x.xlBinTrackerID, r.FreigabeStatus FROM xlBinTracker x inner join xlBinTrackerRef r on x.xlBinTrackerID = r.xlBinTrackerID where r.DokuID = " & dokuID, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
            
            Dim co As ZusaetzlicheDatei
            Do While Not drs.EOF
                Set co = New ZusaetzlicheDatei
                co.m_S = drs.Fields("Dateiname").value
                co.m_L = drs.Fields("xlBinTrackerID").value
                co.m_FreigabeStatus = GetSafeFieldPlus(drs, "FreigabeStatus", 0)
                frmDoku.colZusaetzlicheDateien.add co
                frmDoku.AddListItem frmDoku.ListZusaetzlicheDateien, co
                drs.MoveNext
            Loop
            drs.Close
            
            frmDoku.BisherGespeicherteGroesse conn
            frmDoku.UpdateAktuelleGroesse
            frmDoku.EnableButtonsZusaetzlicheDateien
        End If
      Else
          frmDoku.TabControl.Pages(3).visible = False
      End If
    Else
        frmDoku.TabControl.Pages(3).visible = False
    End If
    DebugPrint DebType.tTime, "Doku 12"
    
    paramrs.Close
    Set paramrs = Nothing

    frmDoku.TabControl.Pages(5).visible = False
    If G_PARAM_FragenAntworten Then
      frmDoku.TabControl.Pages(5).visible = True
    End If

    DebugPrint DebType.tTime, "Doku 13"

    Set rs = Nothing

    frmDoku.TabControl.Pages(7).visible = frmDoku.SignOff_Init(conn, dateiRS)
    
    OfficeAppDisplayAlerts officeapp, False
    'frmDoku.Caption = ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")" & " - Dokumentation"
    frmDoku.Caption = ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")" & " - " & FMT0("THISADDIN_11")
    DebugPrint DebType.tTime, "Doku ENDE"
    
#If PROJECT_ACCESSTRACKER <> 0 Then
    frmDoku.TabellenanzahlText.visible = False
    frmDoku.Tabellenanzahl.visible = False
    frmDoku.Tabellenbl|fffd|ttermitblattschutzText.visible = False
    frmDoku.Tabellenbl|fffd|ttermitblattschutz.visible = False
    frmDoku.Tabellenbl|fffd|tterohneblattschutzmitformelnText.visible = False
    frmDoku.Tabellenbl|fffd|tterohneblattschutzmitformeln.visible = False
    frmDoku.FormelnGesamtText.visible = False
    frmDoku.FormelnGesamt.visible = False
    frmDoku.AnzahlnichtabgesicherteformelnText.visible = False
    frmDoku.Anzahlnichtabgesicherteformeln.visible = False
    frmDoku.AnzahlexternereferenzenText.visible = False
    frmDoku.Anzahlexternereferenzen.visible = False
    frmDoku.EccFormelnIndividuellText.visible = False
    frmDoku.EccFormelnIndividuell.visible = False
#End If

    frmDoku.TabControl.value = 0
    
    G_frmDoku_Cancel = True
    Set frmDoku.m_OfficeApp = officeapp
    Set frmDoku.m_CurDoc = curdoc
    frmDoku.m_TodosGathered = False
    frmDoku.m_AbortReadingTodos = False
    frmDoku.cmdDokuInWord.visible = False
    If FileExists(G_Dokuformular) Then
      If G_PARAM_DokuInWord Then
        frmDoku.cmdDokuInWord.visible = True
      End If
    End If
    
    If G_PARAM_ToDoListe = False Then frmDoku.TabControl.Pages(4).visible = False
    Application.Cursor = xlDefault
    subRemoveCloseButton frmDoku
    frmDoku.PropertyChangedFirstCall conn
    frmDoku.m_InInit = False
    frmDoku.PropertyChanged
    HideStatusForm
    frmDoku.Show vbModal

'    Set frmDoku.m_OfficeApp = Nothing
'    Set frmDoku.m_CurDoc = Nothing
'    Set frmDoku.m_colScriptValues = Nothing
'    frmDoku.ReleaseVBScript
'    Set frmDoku.m_colSimpleSBS = Nothing
'    Set frmDoku.m_SBSIDCtrl = Nothing
'    Set frmDoku.m_SBSOECtrl = Nothing
    
    For Each tMyLabel In myLabelColl
        Set tMyLabel.LabelEvents = Nothing
    Next tMyLabel
    
    For Each tMyComboBox In myComboColl
        Set tMyComboBox.ComboBoxEvents = Nothing
    Next tMyComboBox
    
    For Each tMyTextBox In myTextColl
      Set tMyTextBox.TextBoxEvents = Nothing
    Next tMyTextBox
    
    OfficeAppDisplayAlerts officeapp, True

'!    Unload frmDoku
'  Set doku = Nothing

  Exit Sub
  
nogo:

' "Doku Seite " & rs.Fields("Seitentitel").value & "-" & rs.Fields("Dokuname").value

  If Not rs Is Nothing Then
    If rs.EOF = False Then
      DebugPrint DebType.tERROR, "ShowDoku - Pos: " & trackpos & " Err: " & err.Number & " - " & err.Description & " - " & err.Source & vbCrLf & "Doku Seite " & rs.Fields("Seitentitel").value & "-" & rs.Fields("Dokuname").value
    Else
      DebugPrint DebType.tERROR, "ShowDoku - Pos: " & trackpos & " Err: " & err.Number & " - " & err.Description & " - " & err.Source
    End If
  Else
    DebugPrint DebType.tERROR, "ShowDoku - Pos: " & trackpos & " Err: " & err.Number & " - " & err.Description & " - " & err.Source
  End If
End Sub


Sub SetInOut(ByRef sellist As MSForms.ListBox, ByRef destlist As MSForms.ListBox, ByVal typ As String, ByVal dokuID As Long, ByRef conn As Object)
    Dim rs As Object
    Set rs = CreateObject("ADODB.Recordset")

    rs.Open "SELECT * FROM gOEAktuell ORDER BY OEKennzeichen", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
    DebugPrint DebType.tTime, "Doku SetInOut 1"
    Do While Not rs.EOF
        If rs.Fields("OEID").value > 0 Then
'          sellist.AddItem rs.Fields("OEKennzeichen").Value & " - " & rs.Fields("OEBeschreibung").Value
'          sellist.ItemData(sellist.NewIndex) = rs.Fields("OEID").Value
          sellist.AddItem rs.Fields("OEID").value
          sellist.List(sellist.ListCount - 1, 1) = rs.Fields("OEKennzeichen").value & " - " & rs.Fields("OEBeschreibung").value
        End If
        rs.MoveNext
    Loop
    rs.Close
    DebugPrint DebType.tTime, "Doku SetInOut 2"

    If dokuID > 0 Then

        rs.Open "SELECT gOEAktuell.OEID, gOEAktuell.OEKennzeichen, gOEAktuell.OEBeschreibung FROM idvDateienDokuInOut INNER JOIN gOEAktuell ON idvDateienDokuInOut.ID = gOEAktuell.OEID WHERE idvDateienDokuInOut.InOut='" & typ & "' AND idvDateienDokuInOut.Typ=1 AND idvDateienDokuInOut.idvDateiDokuID=" & dokuID & " ORDER BY OEKennzeichen", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
        Do While Not rs.EOF
'            destlist.Items.Add(New ComboboxItem(rs.Fields("OEKennzeichen").Value, rs.Fields("OEKennzeichen").Value & " - " & rs.Fields("OEBeschreibung").Value))

            If rs.Fields("OEID").value > 0 Then
              destlist.AddItem rs.Fields("OEID").value
'              destlist.ItemData(destlist.NewIndex) = rs.Fields("OEID").Value
              destlist.List(destlist.ListCount - 1, 1) = rs.Fields("OEKennzeichen").value & " - " & rs.Fields("OEBeschreibung").value
  
              Dim i As Long
              For i = 0 To sellist.ListCount - 1
'                  If sellist.ItemData(i) = rs.Fields("OEID").Value Then
                  If val(sellist.List(i, 0)) = rs.Fields("OEID").value Then
                      sellist.RemoveItem i
                      Exit For
                  End If
              Next
            End If
            rs.MoveNext
        Loop
        rs.Close

    End If
    DebugPrint DebType.tTime, "Doku SetInOut 3"


    Set rs = Nothing

End Sub

Sub SetInOutEB(ByRef sellist As MSForms.ListBox, ByRef destlist As MSForms.ListBox, ByVal typ As String, ByVal dokuID As Long, ByRef conn As Object)
    Dim rs As Object
    Set rs = CreateObject("ADODB.Recordset")

    rs.Open "SELECT EinsatzbereichID, Einsatzbereich, u.LokalisierterText FROM (gEinsatzbereiche left join gTexteUebersetzungen u on (gEinsatzbereiche.TextID = u.TextID and u.LanguageID = " & GetMyDBLanguage(conn) & ")) ORDER BY Einsatzbereich", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
    Do While Not rs.EOF
        If Not IsNull(rs.Fields("Einsatzbereich").value) Then
'          If Not CollectionObjectExists(sellist, rs.Fields("Einsatzbereich").Value) Then
            sellist.AddItem rs.Fields("EinsatzbereichID").value
'            sellist.ItemData(sellist.NewIndex) = rs.Fields("EinsatzbereichID").Value
            sellist.List(sellist.ListCount - 1, 1) = GetLocValueFromField(rs, "Einsatzbereich", "LokalisierterText", "")
'          End If
        End If
        rs.MoveNext
    Loop
    rs.Close

    If dokuID > 0 Then
        
'        rs.Open "SELECT gOEAktuell.OEID, gOEAktuell.OEKennzeichen, gOEAktuell.OEBeschreibung FROM idvDateienDokuInOut INNER JOIN gOEAktuell ON idvDateienDokuInOut.ID = gOEAktuell.OEID WHERE idvDateienDokuInOut.InOut='" & typ & "' AND idvDateienDokuInOut.Typ=1 AND idvDateienDokuInOut.idvDateiDokuID=" & dokuid & " ORDER BY OEKennzeichen", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly

        rs.Open "SELECT gEinsatzbereicheHistorie.EinsatzbereichID, gEinsatzbereicheHistorie.Einsatzbereich, u.LokalisierterText FROM ((idvDateienEinsatzbereiche INNER JOIN gEinsatzbereicheHistorie ON idvDateienEinsatzbereiche.EinsatzbereichID = gEinsatzbereicheHistorie.EinsatzbereichID) left join gTexteUebersetzungen u on (gEinsatzbereicheHistorie.TextID = u.TextID and u.LanguageID = " & GetMyDBLanguage(conn) & ")) WHERE idvDateienEinsatzbereiche.idvDateiDokuID=" & dokuID & " ORDER BY Einsatzbereich", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
        Do While Not rs.EOF
'            destlist.Items.Add(New ComboboxItem(rs.Fields("OEKennzeichen").Value, rs.Fields("OEKennzeichen").Value & " - " & rs.Fields("OEBeschreibung").Value))

            If Not IsNull(rs.Fields("Einsatzbereich").value) Then
'              If Not CollectionObjectExists(destlist, rs.Fields("Einsatzbereich").Value) Then
                destlist.AddItem rs.Fields("EinsatzbereichID").value
'                destlist.ItemData(destlist.NewIndex) = rs.Fields("EinsatzbereichID").Value
                destlist.List(destlist.ListCount - 1, 1) = GetLocValueFromField(rs, "Einsatzbereich", "LokalisierterText", "")
'              End If
            End If

            Dim i As Long
            For i = 0 To sellist.ListCount - 1
'                If sellist.ItemData(i) = rs.Fields("EinsatzbereichID").Value Then
                If val(sellist.List(i, 0)) = rs.Fields("EinsatzbereichID").value Then
                    sellist.RemoveItem i
                    Exit For
                End If
            Next
            rs.MoveNext
        Loop
        rs.Close

    End If


    Set rs = Nothing

End Sub

Sub ScriptExtractGlobals(ByRef rsidvDateien As Recordset, ByVal dokufeldname As String, ByVal script As String, ByRef globals As Collection, _
    ByRef colNewRSValues As Collection, ByRef colControls As Collection, _
    ByRef globalsTxt As String, ByRef globalsInitTxt As String)

  Dim pos As Long
  Dim ts As String
  Dim tsAssign As String
  pos = 1
  
  script = RemoveComments(script)
  Do
    pos = InStr(pos, script, "RS_")
    If pos <= 0 Then Exit Do
    ts = GetVariableName(script, pos)
    
    ts = UCase(ts)
    
    If Not CollectionStringExists(globals, ts) Then
      
      tsAssign = ""
      
      Dim cst As CDataObject
      If CollectionObjectExists(colNewRSValues, Mid(ts, 4)) Then
          
          Set cst = colNewRSValues(Mid(ts, 4))
          Select Case cst.m_Type
            Case adTypeText, adVarWChar, adLongVarWChar
              tsAssign = Chr(34) & Replace(Replace(cst.m_Text, Chr(34), Chr(34) & " & chr(34) & " & Chr(34)), vbCrLf, Chr(34) & " & vbcrlf & " & Chr(34)) & Chr(34)
            Case adDouble
              tsAssign = str(cst.m_Double)
            Case Else
              tsAssign = cst.m_Long
          End Select
          
      Else
        If Not rsidvDateien Is Nothing Then
          If FieldExists(rsidvDateien, Mid(ts, 4)) = False Then
            DebugPrint DebType.tERROR, "Dokufeld-Script " & IIf(dokufeldname <> "", "in Dokufeld '" & dokufeldname & "'", "") & " nutzt eine unbekannte Variable: '" & ts & "'"
          
            If InStr(G_cfgScriptdebug, GetUserName()) > 0 Or IsTestUser = True Then
              MsgBox "Das Feld " & Mid(ts, 4) & " existiert nicht in idvDateien! Genutzte Variable: " & ts
            End If
          
          Else
            
            Set cst = New CDataObject
            cst.Init Mid(ts, 4), "", ""
            
            cst.m_Type = rsidvDateien.Fields(Mid(ts, 4)).Type
            Select Case rsidvDateien.Fields(Mid(ts, 4)).Type
              Case adTypeText, adVarWChar, adLongVarWChar
                cst.m_Text = GetSafeFieldPlus(rsidvDateien, Mid(ts, 4), "")
                tsAssign = Chr(34) & Replace(Replace(cst.m_Text, Chr(34), Chr(34) & " & chr(34) & " & Chr(34)), vbCrLf, Chr(34) & " & vbcrlf & " & Chr(34)) & Chr(34)
              Case adDouble
                cst.m_Double = GetSafeFieldPlus(rsidvDateien, Mid(ts, 4), 0)
                tsAssign = cst.m_Double
              Case Else
                cst.m_Long = GetSafeFieldPlus(rsidvDateien, Mid(ts, 4), 0)
                tsAssign = cst.m_Long
            End Select
            cst.m_Type = rsidvDateien.Fields(Mid(ts, 4)).Type
            colNewRSValues.add cst, Mid(ts, 4)
          End If
        End If
      End If
      
      globalsTxt = IIf(globalsTxt <> "", globalsTxt & vbCrLf & "Dim ", "Dim ") & ts
      If tsAssign <> "" Then globalsInitTxt = IIf(globalsInitTxt <> "", globalsInitTxt & vbCrLf, "") & ts & "=" & tsAssign
      globals.add ts, ts
    End If
  Loop
  pos = 1
  Do
    pos = InStr(pos, script, "DF_")
    If pos <= 0 Then Exit Do
    ts = GetVariableName(script, pos)
    If Not CollectionStringExists(globals, ts) Then
      tsAssign = ""
      If CollectionItemExists(colControls, ConvertToUcaseVarName(Mid(ts, 4))) Then
        Dim titem As Object
        Set titem = colControls(ConvertToUcaseVarName(Mid(ts, 4)))
        Dim tpos As Long
        tpos = 1
        Dim s As String
        s = GetValuePart(titem.tag, tpos)
        If Len(s) > 0 Then
            Dim vp As Long
            vp = val(GetValuePart(titem.tag, tpos))
            If vp = 8 Then  ' Label
              tsAssign = Chr(34) & Replace(Replace(titem.Caption, Chr(34), Chr(34) & " & chr(34) & " & Chr(34)), vbCrLf, Chr(34) & " & vbcrlf & " & Chr(34)) & Chr(34)
            ElseIf vp = 6 Then
              tsAssign = IIf(titem.value <> 0, "True", "False")
            Else
              tsAssign = Chr(34) & Replace(Replace(titem.value, Chr(34), Chr(34) & " & chr(34) & " & Chr(34)), vbCrLf, Chr(34) & " & vbcrlf & " & Chr(34)) & Chr(34)
            End If
        End If
      End If
      
      globalsTxt = IIf(globalsTxt <> "", globalsTxt & vbCrLf & "Dim ", "Dim ") & ts
      If tsAssign <> "" Then globalsInitTxt = IIf(globalsInitTxt <> "", globalsInitTxt & vbCrLf, "") & ts & "=" & tsAssign
      globals.add ts, ts
    End If
  Loop
  

End Sub

Function PrepareScriptVarsSBS(ByVal sbsid As Long, ByVal sbsoe As String, ByRef colScriptValues As Collection)

    Dim conn As Object
    Set conn = GetConnection()

    PrepareScriptVarsSBSWithConnection conn, sbsid, sbsoe, colScriptValues

    conn.Close
    Set conn = Nothing
    
End Function

Function PrepareScriptVarsSBSWithConnection(ByRef conn As Object, ByVal sbsid As Long, ByVal sbsoe As String, ByRef colScriptValues As Collection, Optional ByRef colScriptValuesWithKey As Collection = Nothing)

    Dim sbsValue As String
    sbsValue = ""
    Dim sbsHeader As String
    sbsHeader = ""
    
    Dim rs As Object
    Set rs = OpenRS("Select SBSValue from SBSValue where SBSID='" & sbsid & "'", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockPessimistic)
    If Not rs Is Nothing Then
        If rs.EOF = False Then
            sbsValue = GetSafeFieldPlus(rs, "SBSValue", "")
        End If
    End If
    rs.Close
    
    Set rs = OpenRS("Select * from SBSValue where SBSGroup = '__HEADER__'", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockPessimistic)
    If Not rs Is Nothing Then
        If rs.EOF = False Then
            sbsHeader = GetSafeFieldPlus(rs, "SBSValue", "")
        End If
    End If
    rs.Close
    Set rs = Nothing
    
    Dim startIndex As Long
    startIndex = 1
    Dim startIndexHeader As Long
    startIndexHeader = 1
    
    While startIndex <= Len(sbsValue) And startIndexHeader <= Len(sbsHeader)
        Dim header As String
        header = GetNextValue(sbsHeader, startIndexHeader)
        
        Dim v As String
        v = GetNextValue(sbsValue, startIndex)
        If header <> "" Then
'          ReplaceStringInToupleCollections colScriptValues, colScriptValuesWithKey, v, "SBS_" & UCase(header)
          ReplaceStringInToupleCollections colScriptValues, colScriptValuesWithKey, v, "SBS_" & header
        End If
    Wend
    
    ReplaceStringInToupleCollections colScriptValues, colScriptValuesWithKey, sbsid, "SBS_ASSETID"
    ReplaceStringInToupleCollections colScriptValues, colScriptValuesWithKey, sbsid, "SBSID"
    ReplaceStringInToupleCollections colScriptValues, colScriptValuesWithKey, sbsoe, "SBSOE"

End Function

Function DokufeldAnzeigenFromScript(ByRef objScript As Object, ByVal dokufeldname As String, ByRef item As control, ByVal typ As Long, ByVal calledFromDoku As Boolean, ByVal script As String, ByRef dateiRS As Object, ByRef mussfeld As Boolean, ByRef prepScriptVars As Collection) As Boolean
    On Error GoTo nogo
    
    DokufeldAnzeigenFromScript = False
    mussfeld = False
    
'Debug.Print "1 - " & G_HighResTimer.GetCount("Change")
    If script <> "" Then
'          "Dim Mussfeld" & vbCrLf &
        
        Dim globals As Collection
        Set globals = New Collection
        Dim globalsTxt As String
        Dim globalsInitTxt As String
       
        If calledFromDoku Then
            ' frmDoku ist hier initialisiert
            ScriptExtractGlobals dateiRS, dokufeldname, script, globals, frmDoku.colNewRSValues, frmDoku.colControls, globalsTxt, globalsInitTxt
        Else
            Dim colRSValues As Collection
            Set colRSValues = New Collection
            Dim colControls As Collection
            Set colControls = New Collection
        
            ScriptExtractGlobals dateiRS, dokufeldname, script, globals, colRSValues, colControls, globalsTxt, globalsInitTxt
            Set colRSValues = Nothing
            Set colControls = Nothing
        End If
        
        Dim col As Collection
'Debug.Print "2 - " & G_HighResTimer.GetCount("Change")
        If Not prepScriptVars Is Nothing Then
          Set col = prepScriptVars
        Else
          Set col = New Collection
          If Not PrepareScriptVars(dateiRS, col, Nothing) Then
            Set col = Nothing
            Set globals = Nothing
            Exit Function
          End If
        End If
        
        script = _
          "Dim Mussfeld, AnzeigeText, TextFarbe, BeschrFett, TextFett, HintergrundFarbe, Gesperrt" & vbCrLf & _
          globalsTxt & vbCrLf & _
          "Function Anzeigen()" & vbCrLf & _
          "Anzeigen=True" & vbCrLf & _
          "Mussfeld=" & IIf(mussfeld, "true", "false") & vbCrLf & _
          globalsInitTxt & vbCrLf & _
          script & vbCrLf & _
          "End Function"

        ' Der Eingaberisikowert wird eine extra Konstante: #FachlicherRisikowert#
        If CollectionStringExists(col, UCase("FachlicherRisikowert")) Then
          col.Remove UCase("FachlicherRisikowert")
        End If
        col.add str(CDbl(GetValueFromField(dateiRS, "Risikowert", 0))), UCase("FachlicherRisikowert")
        Dim s As String
        If CollectionStringExists(col, UCase("DokufeldMussfeld")) Then
          col.Remove UCase("DokufeldMussfeld")
        End If
        ' s = str(mussfeld)
        col.add str(mussfeld), UCase("DokufeldMussfeld")
'Debug.Print "3 - " & G_HighResTimer.GetCount("Change")
    
        Dim errTxt As String
        errTxt = ""
        Dim erram As Long
        erram = 0
        Dim resultscript As String
        ' Die Scriptvariablen ersetzen
'Debug.Print "4 - " & G_HighResTimer.GetCount("Change")
        resultscript = PlausitestScriptinterpreter(objScript, script, errTxt, erram, col)
'Debug.Print "5 - " & G_HighResTimer.GetCount("Change")
        If erram <> 0 Then
'          DebugPrint tERROR, "SCRIPT ERRORS: " & errTxt
        Else
            Dim res As Variant
            res = EvalScriptResult(objScript, "Anzeigen", resultscript)
'Debug.Print "6 - " & G_HighResTimer.GetCount("Change")
            If Not IsEmpty(res) Then
                DokufeldAnzeigenFromScript = res
            End If
            
            If Not IsEmpty(objScript.Eval("Gesperrt")) Then
              If Not item Is Nothing Then
                item.Locked = objScript.Eval("Gesperrt")
              End If
            End If
            
            
            If Not IsEmpty(objScript.Eval("Mussfeld")) Then
              mussfeld = objScript.Eval("Mussfeld")
            End If
            
            If Not item Is Nothing Then
              Dim textFarbe As Variant
              textFarbe = objScript.Eval("TextFarbe")
              If Not IsEmpty(textFarbe) Then
                If IsNumeric(textFarbe) Then
                  textFarbe = CLng(textFarbe)
                  item.ForeColor = textFarbe
                End If
              End If
              Dim hintergrundFarbe As Variant
              hintergrundFarbe = objScript.Eval("HintergrundFarbe")
              If Not IsEmpty(hintergrundFarbe) Then
                If IsNumeric(textFarbe) Then
                  hintergrundFarbe = CLng(hintergrundFarbe)
                  item.BackColor = hintergrundFarbe
                End If
              End If
              Dim txtFett As Variant
              txtFett = objScript.Eval("TextFett")
              If Not IsEmpty(txtFett) Then
                item.FontBold = CBool(txtFett)
              End If
              
              If typ <> -1 Then
                  Dim anzeigeText As Variant
                  anzeigeText = objScript.Eval("AnzeigeText")
                  If Not IsEmpty(anzeigeText) Then
                    If typ = 8 Then
                      item.Caption = anzeigeText
                    Else
                      item.value = anzeigeText
                    End If
                  End If
              End If
              
'Debug.Print "7 - " & G_HighResTimer.GetCount("Change")
              If calledFromDoku Then
                If Not globals Is Nothing Then
                  If globals.count > 0 Then
                    Dim i As Long
                    For i = 1 To globals.count
                      If Not IsEmpty(objScript.Eval(globals(i))) Then
                        If Left(globals(i), 3) = "DF_" Then
                          If CollectionItemExists(frmDoku.colControls, ConvertToUcaseVarName(Mid(globals(i), 4))) Then
                            Dim titem As Object
                            Set titem = frmDoku.colControls(ConvertToUcaseVarName(Mid(globals(i), 4)))
                            Dim pos As Long
                            pos = 1
                            s = GetValuePart(titem.tag, pos)
                            If Len(s) > 0 Then
                                If val(GetValuePart(titem.tag, pos)) = 8 Then
                                  titem.Caption = objScript.Eval(globals(i))
                                Else
                                  titem.value = objScript.Eval(globals(i))
                                End If
                            End If
                          End If
                        ElseIf Left(globals(i), 3) = "RS_" Then
                          If CollectionObjectExists(frmDoku.colNewRSValues, UCase(Mid(globals(i), 4))) Then
                            Select Case frmDoku.colNewRSValues(UCase(Mid(globals(i), 4))).m_Type
                              Case adTypeText, adVarWChar, adLongVarWChar
                                frmDoku.colNewRSValues(UCase(Mid(globals(i), 4))).m_Text = objScript.Eval(globals(i))
                              Case adDouble
                                frmDoku.colNewRSValues(UCase(Mid(globals(i), 4))).m_Double = objScript.Eval(globals(i))
                              Case Else
                                frmDoku.colNewRSValues(UCase(Mid(globals(i), 4))).m_Long = objScript.Eval(globals(i))
                            End Select
                            ' Hier die Logik f|fffd|r Schutzbedarf Indiv1 etc.
                            Select Case UCase(Mid(globals(i), 4))
                              Case "SCHUTZBEDARF"
                                frmDoku.Schutzbedarf.Caption = GetSchutzbedarfTextFromLong(objScript.Eval(globals(i)), "Schutzbedarf")
                              Case "INTEGRITAET"
                                frmDoku.Integritaet.Caption = GetSchutzbedarfTextFromLong(objScript.Eval(globals(i)), "Integritaet")
                              Case "VERTRAULICHKEIT"
                                frmDoku.Vertraulichkeit.Caption = GetSchutzbedarfTextFromLong(objScript.Eval(globals(i)), "Vertraulichkeit")
                              Case "VERFUEGBARKEIT"
                                frmDoku.Verfuegbarkeit.Caption = GetSchutzbedarfTextFromLong(objScript.Eval(globals(i)), "Verfuegbarkeit")
                              Case "AUTHENTIZITAET"
                                frmDoku.Authentizitaet.Caption = GetSchutzbedarfTextFromLong(objScript.Eval(globals(i)), "Authentizitaet")
                              Case "INDIV1"
                                frmDoku.TbIndiv1 = objScript.Eval(globals(i))
                              Case "INDIV2"
                                frmDoku.TbIndiv2 = objScript.Eval(globals(i))
                              Case "VERANTWORTLICHERAUTOR"
                                frmDoku.VerantwortlicherAutor = objScript.Eval(globals(i))
                              Case "FACHLICHVERANTWORTLICHER"
                                frmDoku.FachlichVerantwortlicher = objScript.Eval(globals(i))
                              
                            End Select
                          Else
'                            If InStr(G_cfgScriptdebug, GetUserName()) > 0 Then
'                              MsgBox "Script-Variable nicht definiert: " & Mid(globals(i), 4)
'                            End If
                          End If
                        End If
                      End If
                    Next i
'Debug.Print "8 - " & G_HighResTimer.GetCount("Change")
                  End If
                End If
              End If
            End If
            
        End If
        Set col = Nothing
    End If
'Debug.Print "9 - " & G_HighResTimer.GetCount("Change")
nogo:
End Function

Function GetInOutString(ByVal typ As String, ByVal dokuID As Long, ByRef conn As Object) As String
    
    Dim s As String
    Dim rs As Object
    Set rs = CreateObject("ADODB.Recordset")

    If dokuID > 0 Then

        rs.Open "SELECT gOEAktuell.OEID, gOEAktuell.OEKennzeichen, gOEAktuell.OEBeschreibung FROM idvDateienDokuInOut INNER JOIN gOEAktuell ON idvDateienDokuInOut.ID = gOEAktuell.OEID WHERE idvDateienDokuInOut.InOut='" & typ & "' AND idvDateienDokuInOut.Typ=1 AND idvDateienDokuInOut.idvDateiDokuID=" & dokuID & " ORDER BY OEKennzeichen", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
        Do While Not rs.EOF
'            destlist.Items.Add(New ComboboxItem(rs.Fields("OEKennzeichen").Value, rs.Fields("OEKennzeichen").Value & " - " & rs.Fields("OEBeschreibung").Value))

            If rs.Fields("OEID").value > 0 Then
              If s <> "" Then
                s = s & vbCrLf & rs.Fields("OEKennzeichen").value & " - " & rs.Fields("OEBeschreibung").value
              Else
                s = rs.Fields("OEKennzeichen").value & " - " & rs.Fields("OEBeschreibung").value
              End If
  
            End If
            rs.MoveNext
        Loop
        rs.Close

    End If


    Set rs = Nothing
    
    If s <> "" Then
      GetInOutString = s
    Else
      GetInOutString = "-/-"
    End If

End Function

Function GetInOutEBString(ByVal typ As String, ByVal dokuID As Long, ByRef conn As Object) As String
    Dim rs As Object
    Set rs = CreateObject("ADODB.Recordset")
    Dim s As String

    If dokuID > 0 Then
        
        rs.Open "SELECT gEinsatzbereicheHistorie.EinsatzbereichID, gEinsatzbereicheHistorie.Einsatzbereich, u.LokalisierterText FROM " & _
        " ((idvDateienEinsatzbereiche INNER JOIN gEinsatzbereicheHistorie ON idvDateienEinsatzbereiche.EinsatzbereichID = gEinsatzbereicheHistorie.EinsatzbereichID) " & _
        " left join gTexteUebersetzungen u on (u.TextID = gEinsatzbereicheHistorie.TextID and u.LanguageID = " & GetMyDBLanguage(conn) & " )) " & _
        " WHERE idvDateienEinsatzbereiche.idvDateiDokuID=" & dokuID & " ORDER BY Einsatzbereich", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
        Do While Not rs.EOF
            If Not IsNull(rs.Fields("Einsatzbereich").value) Then
                If s <> "" Then
                  s = s & ", " & GetLocValueFromField(rs, "Einsatzbereich", "LokalisierterText", "")
                Else
                  s = GetLocValueFromField(rs, "Einsatzbereich", "LokalisierterText", "")
                End If
            End If
            rs.MoveNext
        Loop
        rs.Close

    End If


    Set rs = Nothing
    If s <> "" Then
      GetInOutEBString = s
    Else
      GetInOutEBString = "-/-"
    End If

End Function


Sub DoRisikobefragung(ByRef officeapp As Object, ByRef curdoc As Object, Optional freiwillig As Boolean = False)

  On Error GoTo nogo
    
#If Project_ExcelTracker = 1 Then
    If curdoc.readOnly = True Then
        ' "Die Datei ist schreibgesch|fffd|tzt"
        MsgBox FMT0("THISADDIN_111"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        Exit Sub
    End If
#End If

    Dim conn As Object
    Set conn = GetConnection()

    If conn Is Nothing Then
        'MsgBox "Diese Funktion ist zur Zeit nicht ausf|fffd|hrbar, da das System nicht zur Verf|fffd|gung steht. Bitte versuchen Sie es sp|fffd|ter noch einmal.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        MsgBox FMT0("DOKUPWD_3"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        Exit Sub
    End If

    If Deaktiviert(conn) Then
        'MsgBox "Aktuell steht diese Funktion nicht zur Verf|fffd|gung, da das System deaktiviert wurde. Bitte versuchen Sie es sp|fffd|ter noch einmal.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        MsgBox FMT0("DOKUPWD_4"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        conn.Close
        Set conn = Nothing
        Exit Sub
    End If

    If WBGetValueLong(officeapp, "_IDVTrackerFreigabeStatus" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix) = 1 Then
'        If freiwillig Then
          'Die Datei befindet sich aktuell im Freigabeprozess und kann daher nicht risikobefragt werden!
          MsgBox FMT0("ETDLL_38"), vbCritical, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
'        Else
          'MsgBox "Die Datei befindet sich aktuell im Freigabeprozess und kann daher nicht gespeichert werden! Der Vorgang wird abgebrochen! Wenn Sie die Datei speichern wollen, m|fffd|ssen Sie eine neue Version erzeugen (Dies f|fffd|hrt dann automatisch zu einem Abbruch des Freigabeverfahrens).", vbCritical, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
'          MsgBox FMT0("ETDLL_4"), vbCritical, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
'        End If
        DebugPrint tinfo, "Keine Risikobewertung in Freigabe"
        conn.Close
        Set conn = Nothing
        Exit Sub
    End If

    If G_PARAM_LokaleDateienBer|fffd|cksichtigen = False And Left(GetUNCPathFromDoc(curdoc), 2) <> "\\" And Left(GetUNCPathFromDoc(curdoc), 2) <> "//" And InStr(GetUNCPathFromDoc(curdoc), "://") <= 0 Then
        'MsgBox "Dateien auf lokalen Laufwerken k|fffd|nnen nicht risikobewertet werden. Speichern Sie die Datei in einem Netzlaufwerk, um diese Funktion nutzen zu k|fffd|nnen.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        MsgBox FMT0("THISADDIN_12"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        conn.Close
        Set conn = Nothing
        Exit Sub
    End If

    If DateiAusgeschlossen2(curdoc, conn) = True Then
    ' If DateiAusgeschlossenVariable(curdoc) = True Then
        'MsgBox "Diese Funktion steht f|fffd|r diese Datei/f|fffd|r Dateien in diesem Verzeichnis nicht zur Verf|fffd|gung.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        MsgBox FMT0("THISADDIN_13"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        conn.Close
        Set conn = Nothing
        Exit Sub
    End If
    
    Dim rs As Object

    Dim curid As Long
    Dim hash As String

    DebugPrint DebType.tdebug, "Risikobefragung: Ermittlung Datei ID"
    Dim wasLocked As Boolean
    If Not GetTargetRS(conn, GetUNCPathFromDoc(curdoc), curdoc, rs, curid, hash, ADODB.LockTypeEnum.adLockPessimistic, wasLocked) Then
        If wasLocked Then
          'MsgBox "Ein anderer User greift gerade auf die Daten der Datei zu, bitte versuchen Sie es sp|fffd|ter noch einmal.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
          MsgBox FMT0("BLATTSCHUTZ_3"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        Else
          DebugPrint DebType.tdebug, "Risikobefragung: Keine Datei gefunden - HASH:" & hash & " - Name:" & GetUNCPathFromDoc(curdoc) & " - CurID:" & curid
'          If (Left(GetCurrentDocUNCPathFromApp(officeapp), 1) = "\" Or Left(GetCurrentDocUNCPathFromApp(officeapp), 1) = "/" Or Mid(GetCurrentDocUNCPathFromApp(officeapp), 2, 1) = ":") And _
'            WBGetValueLong(officeapp, "_IDVTrackerID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix) > 0 Then
'            MsgBox "Aktuell kann Risikobefragung durchgef|fffd|hrt werden, da die Datenbank oder der Datensatz gesperrt ist. Sollte dies l|fffd|nger der Fall sein informieren Sie bitte Ihre Administration.", vbInformation + vbSystemModal, ProgNameLong & " " & MyVersion & " (Build: " & app.Revision & ")"
'          Else
            'MsgBox "Bevor Sie die Risikofragen beantworten k|fffd|nnen, muss die Datei von Ihnen gespeichert werden.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
            MsgBox FMT0("THISADDIN_14"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
'          End If
        End If
        Set rs = Nothing
        conn.Close
        Set conn = Nothing
        Exit Sub
    Else
    
        DebugPrint DebType.tdebug, "Risikobefragung: Datei gefunden: ID " & rs.Fields("idvDateiID").value
        
        ' wurde schon mal gespeichert oder nur |fffd|ber die Suite aufgenommen
        ' in dem Fall ist Speicheranzahl = 0
        Dim ok As Boolean
        ok = True
        
        DebugPrint DebType.tdebug, "Risikobefragung: Speicheranzahl pr|fffd|fen"
        If Not IsNull(rs.Fields("Speicheranzahl").value) Then
            If rs.Fields("Speicheranzahl").value = 0 Then
                DebugPrint tdebug, "Speicheranzahl = 0"
                'MsgBox "Bevor Sie die Risikofragen beantworten k|fffd|nnen, muss die Datei von Ihnen gespeichert werden.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                MsgBox FMT0("THISADDIN_14"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                ok = False
            End If
        End If
        
        
        If IstDateiFreigabeStatusDeaktiviert(rs) = True Then
           DebugPrint tinfo, "DoRisikobefragung - Dateifreigabe deaktiviert"
       
           DoNewVersionWhenDeaktiviert conn, officeapp, curdoc, rs
           
           rs.Close
           Set rs = Nothing
           conn.Close
           Set conn = Nothing
           Exit Sub
        End If

        
        
        
        Dim paramrs As Object
        Set paramrs = GetParamRS(conn)   ' OpenRS("SELECT * FROM gParameter", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
        If paramrs Is Nothing Then
          'MsgBox "Aktuell ist keine Risikobefragung m|fffd|glich, bitte wiederholen Sie den Vorgang sp|fffd|ter erneut.", vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
          MsgBox FMT0("THISADDIN_16"), vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
          rs.Close
          Set rs = Nothing
          Exit Sub
        End If
        Dim paramrsid As Long
        paramrsid = paramrs.Fields("ParameterID").value
        Dim freigegebeneAlleXTage As Long
        freigegebeneAlleXTage = CLng(GetSafeFieldPlus(paramrs, "FreigegebeneAlleXTage", "0"))
        paramrs.Close
        Set paramrs = Nothing
        
        If ok = True Then
            DebugPrint DebType.tdebug, "Risikobefragung: Freigabestatus pr|fffd|fen"
            If Not IsNull(rs.Fields("FreigabeStatus").value) Then
                'If rs.Fields("FreigabeStatus").value >= 2 And freigegebeneAlleXTage > 0 Then
                If IstDateiFreigabeStatusFreigegeben(rs) = True Then
                    Dim tdateFreigabe As Date
                    tdateFreigabe = #1/1/1900#
                    GetFreigabeStatusAusDBShort conn, rs.Fields("idvDateiID").value, _
                        rs.Fields("Version").value, tdateFreigabe
                    
                    If freigegebeneAlleXTage > 0 Then
                    
                      If DateAdd("d", freigegebeneAlleXTage, tdateFreigabe) > Now Then
                        ' Die Frist f|fffd|r eine erneute Risikobefragung nach einer Programmfreigabe ist noch nicht abgelaufen. Wenn Sie die Risikobefragung durchf|fffd|hren m|fffd|chten, m|fffd|ssen Sie die Programmfreigabe aufheben. Die Befragung ist fr|fffd|hestens nach folgendem Datum m|fffd|glich: %1
                        MsgBox FMT1("THISADDIN_144", DateAdd("d", freigegebeneAlleXTage, tdateFreigabe)), vbSystemModal + vbInformation, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                        ok = False
                                    ' Achtung! %1 M|fffd|chten Sie eine Risikobefragung durchf|fffd|hren?
                      ElseIf MsgBox(FMT1("THISADDIN_95", GetFreigabeStatusText(rs.Fields("FreigabeStatus").value)), vbQuestion + vbSystemModal + vbYesNo, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")") = vbNo Then
                         ok = False
                      Else
                         DebugPrint DebType.tdebug, "Risikobefragung: Freigegebene befragen"
                      End If
                    Else
                       DebugPrint DebType.tdebug, "Risikobefragung: Freigegebene befragen"
                    End If
                'ElseIf rs.Fields("FreigabeStatus").value >= 1 Then
                ElseIf IstDateiFreigabeStatusInitiiertOderFreigegeben(rs) = True Then
                     DebugPrint DebType.tdebug, "Risikobefragung: Freigabe l|fffd|uft"
                     'MsgBox "Achtung! " & GetFreigabeStatusText(rs.Fields("FreigabeStatus").value) & " Eine erneute Risikobefragung ist nicht notwendig.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                     MsgBox FMT1("THISADDIN_15", GetFreigabeStatusText(rs.Fields("FreigabeStatus").value)), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                     ok = False
                End If
            End If
        End If

        If Not ok Then
          DebugPrint DebType.tdebug, "Risikobefragung: Keine Befragung"
        Else
          Dim newrisk As Double
          DebugPrint DebType.tdebug, "Risikobefragung: Fragen anzeigen"
          
          If DoRisikoFragen(GetDriveAndPathFromUNC(curdoc.fullname), officeapp, curdoc, rs, GetUNCPathFromDoc(curdoc), G_PARAM_LogRisikoklassen|fffd|nderung, newrisk, conn, paramrsid, freiwillig) Then
            DebugPrint DebType.tdebug, "Risikobefragung: Fragen anzeigen fertig"
            
            DebugPrint tdebug, "Risikobefragung Newrisk:" & newrisk
            DebugPrint tdebug, "Risikobefragung Schwelle f|fffd|r Doku:" & G_PARAM_DokuAbRisikowert
            If newrisk >= G_PARAM_DokuAbRisikowert And G_PARAM_DokuAbRisikowert >= 0 Then
                rs.Update
                Set rs = Nothing
                Set rs = OpenRS("SELECT * FROM idvDateien WHERE IDVDATEIID=" & curid, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockPessimistic)
                
                DebugPrint tdebug, "Risikobefragung Dokufenster"
                ShowDoku officeapp, rs, conn, curdoc
                DebugPrint tdebug, "Risikobefragung Dokufenster fertig"
            Else
                DebugPrint tdebug, "Risikobefragung KEIN Dokufenster"
            End If
          End If
          
          rs.Update
          
          DebugPrint DebType.tdebug, "Risikobefragung: Datensatz gespeichert"
        End If
    End If
    rs.Close
    Set rs = Nothing
    
    SetzeAmpelStatus curdoc, conn
    
    conn.Close
    Set conn = Nothing
    DebugPrint DebType.tdebug, "Risikobefragung: Fertig!"
    Exit Sub
    
nogo:
    DebugPrint DebType.tERROR, "DoRisikobefragung - Err: " & err.Number & " - " & err.Description & " - " & err.Source
    On Error Resume Next
    If Not rs Is Nothing Then
      If rs.state <> 0 Then
'        rs.Close
      End If
      Set rs = Nothing
    End If
    If Not conn Is Nothing Then
      conn.Close
      Set conn = Nothing
    End If

End Sub

Function GetDokuDate(dokuID As Long) As Date
    GetDokuDate = DateSerial(1970, 1, 1)
    
    Dim conn As Object
    Set conn = GetConnection()
    If conn Is Nothing Then
        Exit Function
    End If

    Dim rs As Object
    Set rs = OpenRS("SELECT * FROM idvDateienDoku WHERE idvDateiDokuID=" & dokuID, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockOptimistic)
    If Not rs Is Nothing Then
        If Not rs.EOF Then
            GetDokuDate = GetSafeFieldPlus(rs, "Datum", DateSerial(1970, 1, 1))
        End If
        rs.Close
    End If
    Set rs = Nothing
    conn.Close
    Set conn = Nothing
End Function

Sub DoShowDoku(ByRef officeapp As Object, ByRef curdoc As Object)

    On Error GoTo nogo

    
    Dim trackpos As Long
    

    Dim conn As Object
    trackpos = 10
    
    'ShowStatusForm "Lade Dateiinfo...", False
    ShowStatusForm FMT0("THISADDIN_17"), False
    
    Set conn = GetConnection()

    'UpdateStatusForm "Lade Dateiinfo...", 0.25
    UpdateStatusForm FMT0("THISADDIN_17"), 0.25
    
    If conn Is Nothing Then
        HideStatusForm
        'MsgBox "Diese Funktion ist zur Zeit nicht ausf|fffd|hrbar, da das System nicht zur Verf|fffd|gung steht. Bitte versuchen Sie es sp|fffd|ter noch einmal.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        MsgBox FMT0("DOKUPWD_3"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        Exit Sub
    End If


    trackpos = 20
    If Deaktiviert(conn) Then
        HideStatusForm
        'MsgBox "Aktuell steht diese Funktion nicht zur Verf|fffd|gung, da das System deaktiviert wurde. Bitte versuchen Sie es sp|fffd|ter noch einmal.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        MsgBox FMT0("DOKUPWD_4"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        conn.Close
        Set conn = Nothing
        Exit Sub
    End If
    
    'UpdateStatusForm "Lade Dateiinfo...", 0.5
    UpdateStatusForm FMT0("THISADDIN_17"), 0.5
    
    trackpos = 30

    Dim rs As Object
    Set rs = CreateObject("ADODB.Recordset")

    Dim curid As Long
    Dim hash As String
    
    trackpos = 40
    
    Dim lokaleDateienReadOnly As Boolean
    lokaleDateienReadOnly = False
    If G_PARAM_LokaleDateienBer|fffd|cksichtigen = False And curdoc.readOnly = False And Left(GetUNCPathFromDoc(curdoc), 2) <> "\\" And Left(GetUNCPathFromDoc(curdoc), 2) <> "//" And InStr(GetUNCPathFromDoc(curdoc), "://") <= 0 Then
        lokaleDateienReadOnly = True
          ' HideStatusForm
          'MsgBox "Dateien auf lokalen Laufwerken k|fffd|nnen nicht dokumentiert werden. Speichern Sie die Datei in einem Netzlaufwerk, um diese Funktion nutzen zu k|fffd|nnen.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
          ' MsgBox FMT0("THISADDIN_18"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
          ' Set rs = Nothing
          ' conn.Close
          ' Set conn = Nothing
          ' Exit Sub
    End If
      
      
    If lokaleDateienReadOnly = False Then
      If DateiAusgeschlossen2(curdoc, conn) = True Then
      ' If DateiAusgeschlossenVariable(curdoc) = True Then
          HideStatusForm
          'MsgBox "Diese Funktion steht f|fffd|r diese Datei/f|fffd|r Dateien in diesem Verzeichnis nicht zur Verf|fffd|gung.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
          MsgBox FMT0("THISADDIN_13"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
          Set rs = Nothing
          conn.Close
          Set conn = Nothing
          Exit Sub
      End If
    End If
    
    'UpdateStatusForm "Lade Dateiinfo...", 0.75
    UpdateStatusForm FMT0("THISADDIN_17"), 0.75
    
    trackpos = 50
    Dim wasLocked As Boolean
    If Not GetTargetRS(conn, GetUNCPathFromDoc(curdoc), curdoc, rs, curid, hash, ADODB.LockTypeEnum.adLockPessimistic, wasLocked) Then ' .adLockOptimistic) Then
        trackpos = 60
        If wasLocked Then
            HideStatusForm
            'MsgBox "Ein anderer User bearbeitet derzeit die Dokumentation, bitte versuchen Sie es sp|fffd|ter noch einmal.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
            MsgBox FMT0("THISADDIN_19"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        ' Verschobene, in Freigabe befindliche Datei?
        ElseIf WBGetValueLong(officeapp, "_IDVTrackerFreigabeStatus" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix) = 1 Then
            trackpos = 70
            Dim fileid As Long
            fileid = WBGetValueLong(officeapp, "_IDVTrackerID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix)
            trackpos = 80
            If fileid > 0 Then
                  DebugPrint tdebug, "DoShowDoku: " & GetUNCPathFromDoc(curdoc)
                  Set rs = OpenRS("SELECT * FROM idvDateien WHERE idvDateiID=" & fileid, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockOptimistic)
                  'UpdateStatusForm "Lade Dateiinfo...", 0.9
                  UpdateStatusForm FMT0("THISADDIN_17"), 0.9
                  trackpos = 90
                  If Not rs Is Nothing Then
                    trackpos = 100
                    If Not rs.EOF Then
                      trackpos = 110
                      'MsgBox "Diese Datei ist eine Kopie der Datei '" & rs.Fields("Dateiname").value & "', die sich gerade im Freigabeprozess befindet. Die Dokumentation wird angezeigt, kann aber nicht ge|fffd|ndert werden.", vbCritical, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                      MsgBox FMT1("THISADDIN_20", rs.Fields("Dateiname").value), vbCritical, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                      trackpos = 120
                      ShowDoku officeapp, rs, conn, curdoc, False, False, True
                      trackpos = 130
                      rs.Update
                    Else
                      HideStatusForm
                      'MsgBox "F|fffd|r diese Datei kann keine Dokumentation angezeigt werden!", vbCritical, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                      MsgBox FMT0("THISADDIN_21"), vbCritical, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                    End If
                    trackpos = 140
                    rs.Close
                  Else
                    HideStatusForm
                    'MsgBox "F|fffd|r diese Datei kann keine Dokumentation angezeigt werden!", vbCritical, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                    MsgBox FMT0("THISADDIN_21"), vbCritical, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                  End If
            Else
                  HideStatusForm
                  'MsgBox "F|fffd|r diese Datei kann keine Dokumentation angezeigt werden!", vbCritical, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                  MsgBox FMT0("THISADDIN_21"), vbCritical, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
            End If
            trackpos = 150
            Set rs = Nothing
            trackpos = 1600
            conn.Close
            Set conn = Nothing
            Exit Sub
        ElseIf GetTargetRS(conn, GetUNCPathFromDoc(curdoc), curdoc, rs, curid, hash, ADODB.LockTypeEnum.adLockReadOnly, wasLocked, True) Then ' .adLockOptimistic) Then
'            If Not IsCopy(curdoc, rs) Then
'              #If PROJECT_EXCELTRACKER = 1 Then
'                MsgBox "Bevor Sie eine Dokumentation der Datei vornehmen k|fffd|nnen, muss die Datei von Ihnen gespeichert werden. (1) ID: " & WBGetValueLong(officeapp, "_IDVTrackerID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
'              #Else
'                MsgBox "Ein anderer User bearbeitet derzeit die Dokumentation, bitte versuchen Sie es sp|fffd|ter noch einmal.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
'              #End If
'            Else
              If wasLocked Then
                  HideStatusForm
                  'MsgBox "Ein anderer User bearbeitet derzeit die Dokumentation, bitte versuchen Sie es sp|fffd|ter noch einmal.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                  MsgBox FMT0("THISADDIN_19"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
              Else
                  'MsgBox "Diese Datei wurde noch nicht gespeichert. Die Dokumentation wird angezeigt, kann aber nicht ge|fffd|ndert werden.", vbCritical, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                  MsgBox FMT0("THISADDIN_22"), vbCritical, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                  ShowDoku officeapp, rs, conn, curdoc, True, True, True
              End If
'            End If
        Else
'            If (Left(GetCurrentDocUNCPathFromApp(officeapp), 1) = "\" Or Left(GetCurrentDocUNCPathFromApp(officeapp), 1) = "/" Or Mid(GetCurrentDocUNCPathFromApp(officeapp), 2, 1) = ":") And _
'              WBGetValueLong(officeapp, "_IDVTrackerID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix) > 0 Then
'              MsgBox "Aktuell kann nicht auf die Dokumentation zugegriffen werden, da die Datenbank oder der Datensatz gesperrt ist. Sollte dies l|fffd|nger der Fall sein informieren Sie bitte Ihre Administration.", vbInformation + vbSystemModal, ProgNameLong & " " & MyVersion & " (Build: " & app.Revision & ")"
'            Else
              HideStatusForm

              If lokaleDateienReadOnly = True Then
                'MsgBox "Diese Funktion steht f|fffd|r diese Datei/f|fffd|r Dateien in diesem Verzeichnis nicht zur Verf|fffd|gung.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                MsgBox FMT0("THISADDIN_13"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
              Else

#If Project_ExcelTracker = 1 Then
                'MsgBox "Bevor Sie eine Dokumentation der Datei vornehmen k|fffd|nnen, muss die Datei von Ihnen gespeichert werden. (2) ID: " & WBGetValueLong(officeapp, "_IDVTrackerID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                MsgBox FMT1("THISADDIN_23", WBGetValueLong(officeapp, "_IDVTrackerID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix)), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
#Else
                'MsgBox "Ein anderer User bearbeitet derzeit die Dokumentation, bitte versuchen Sie es sp|fffd|ter noch einmal.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                MsgBox FMT0("THISADDIN_19"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
#End If
              End If
        End If
        trackpos = 170
        Set rs = Nothing
        conn.Close
        trackpos = 180
        Set conn = Nothing
        Exit Sub
    Else
'        rs.beforeedit
        trackpos = 190
        
        
        
        If rs.EOF Then
#If Project_ExcelTracker = 1 Then
              'MsgBox "Bevor Sie eine Dokumentation der Datei vornehmen k|fffd|nnen, muss die Datei von Ihnen gespeichert werden. (3) ID: " & WBGetValueLong(officeapp, "_IDVTrackerID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
              MsgBox FMT1("THISADDIN_24", WBGetValueLong(officeapp, "_IDVTrackerID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix)), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
#Else
              'MsgBox "Ein anderer User bearbeitet derzeit die Dokumentation, bitte versuchen Sie es sp|fffd|ter noch einmal.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
              MsgBox FMT0("THISADDIN_19"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
#End If
        Else
        
              Dim doReadOnly As Boolean
              doReadOnly = False
#If Project_ExcelTracker = 1 Then
              If curdoc.readOnly Then
                 'MsgBox "Achtung! Die Datei ist schreibgesch|fffd|tzt! Die Doku wird angezeigt, Ver|fffd|nderungen an der Doku werden aber NICHT abgespeichert!", vbExclamation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                 MsgBox FMT0("THISADDIN_25"), vbExclamation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                 doReadOnly = True
'                ElseIf rs.Fields("FreigabeStatus").value >= 1 Then
'                    MsgBox "Achtung! " & GetFreigabeStatusText(rs.Fields("FreigabeStatus").value) & " Damit die Doku kopiert werden kann, sind die Felder nicht gesperrt, Ver|fffd|nderungen an der Doku werden aber NICHT abgespeichert!", vbExclamation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                End If
#End If
            Dim gespeichert As Boolean
            gespeichert = True
                          
            If Not IsNull(rs.Fields("Speicheranzahl").value) Then
                If rs.Fields("Speicheranzahl").value = 0 Then
                    DebugPrint tdebug, "ShowDoku - Speicheranzahl = 0"
                       'MsgBox "Achtung! Die Datei wurde bisher noch nicht gespeichert, die Doku kann nicht ver|fffd|ndert werden!", vbExclamation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                       MsgBox FMT0("THISADDIN_26"), vbExclamation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                    gespeichert = False
                End If
            End If

              trackpos = 200
              If gespeichert = True Then
                  ShowDoku officeapp, rs, conn, curdoc
              Else
                ShowDoku officeapp, rs, conn, curdoc, True, True
              End If
        End If
        trackpos = 210
    End If
'    On Error Resume Next
    trackpos = 220
    If Not rs.EOF Then
      rs.Update
    End If
    trackpos = 230
    rs.Close
    Set rs = Nothing
    conn.Close
    trackpos = 240
    Set conn = Nothing
    Exit Sub
    
nogo:
  DebugPrint DebType.tERROR, "DoShowDoku, POS:" & trackpos & " - Err: " & err.Number & " - " & err.Description & " - " & err.Source
    On Error Resume Next
    If Not rs Is Nothing Then
      If rs.state <> 0 Then
'        rs.Close
      End If
      Set rs = Nothing
    End If
    If Not conn Is Nothing Then
      conn.Close
      Set conn = Nothing
    End If
End Sub

Sub DoNewVersionWhenDeaktiviert(ByRef conn As Object, ByRef officeapp As Object, ByRef curdoc As Object, ByRef rs As Object)

    Dim onlineFreigabeStatus As Long
    Dim freigabeDatum As Date
    Dim strFreigabeKommentar As String
    Dim strUser As String
    Dim strDeaktivierenderUser As String
    Dim datumDeaktivierung As Date
    Dim strDeaktivierungKommentar As String
    GetFreigabeStatusAusDB conn, _
                        rs.Fields("idvDateiID").value, _
                        rs.Fields("Version").value, _
                        strFreigabeKommentar, _
                        strUser, freigabeDatum, _
                        strDeaktivierenderUser, datumDeaktivierung, strDeaktivierungKommentar

    Dim res
    res = MsgBox(FMT3("TRACKERSTUFF_36", datumDeaktivierung, strDeaktivierenderUser, strDeaktivierungKommentar), vbYesNo, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")")
    If res = vbYes Then
         DoNewVersionWithConnection conn, officeapp, curdoc, rs, rs.Fields("idvDateiID").value
    End If

End Sub



Sub DoNewVersion(ByRef officeapp As Object, ByRef curdoc As Object)
    
' #If PROJECT_ACCESSTRACKER <> 0 Then
'     If Not AppHasDB(c.m_Connect.accapp) Then
'       MsgBox "Bitte |fffd|ffnen Sie erst eine Datenbank", vbInformation, ProgNameLong & " " & MyVersion & " (" & App.Major & "." & App.Minor & "."  & App.Revision & ")"
'       Exit Sub
'     End If
' #End If
    
#If Project_ExcelTracker = 1 Then
    If curdoc.readOnly = True Then
        ' "Die Datei ist schreibgesch|fffd|tzt"
        MsgBox FMT0("THISADDIN_111"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        Exit Sub
    End If
#End If
    
On Error GoTo nogo

    If IsSharedWorkbook(curdoc) Then
        'MsgBox "Die Funktion kann nicht genutzt werden, da die Microsoft-Freigabe verwendet wurde (""Arbeitsmappe freigeben""). Bitte entfernen Sie die Freigabe, um die Funktion auszuf|fffd|hren."
        MsgBox FMT0("THISADDIN_27"), vbInformation, ProgNameLong & " " & myVersion & " (" & app.Major & "." & app.Minor & "." & app.Revision & ")"
        Exit Sub
    End If
    
    Dim conn As Object
    Set conn = GetConnection()

    If conn Is Nothing Then
        'MsgBox "Diese Funktion ist zur Zeit nicht ausf|fffd|hrbar, da das System nicht zur Verf|fffd|gung steht. Bitte versuchen Sie es sp|fffd|ter noch einmal.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        MsgBox FMT0("DOKUPWD_3"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        Exit Sub
    End If
    
    If Deaktiviert(conn) Then
        'MsgBox "Aktuell steht diese Funktion nicht zur Verf|fffd|gung, da das System deaktiviert wurde. Bitte versuchen Sie es sp|fffd|ter noch einmal.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        conn.Close
        Set conn = Nothing
        MsgBox FMT0("DOKUPWD_4"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        Exit Sub
    End If

    If G_PARAM_LokaleDateienBer|fffd|cksichtigen = False And Left(GetUNCPathFromDoc(curdoc), 2) <> "\\" And Left(GetUNCPathFromDoc(curdoc), 2) <> "//" And InStr(GetUNCPathFromDoc(curdoc), "://") <= 0 Then
        'MsgBox "Dateien auf lokalen Laufwerken k|fffd|nnen nicht versioniert werden. Speichern Sie die Datei in einem Netzlaufwerk, um diese Funktion nutzen zu k|fffd|nnen.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        conn.Close
        Set conn = Nothing
        MsgBox FMT0("THISADDIN_28"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        Exit Sub
    End If

    If DateiAusgeschlossen2(curdoc, conn) = True Then
    ' If DateiAusgeschlossenVariable(curdoc) = True Then
        'MsgBox "Diese Funktion steht f|fffd|r diese Datei/f|fffd|r Dateien in diesem Verzeichnis nicht zur Verf|fffd|gung.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        conn.Close
        Set conn = Nothing
        MsgBox FMT0("BLATTSCHUTZ_2"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        Exit Sub
    End If
    
    Dim rs As Object
    Set rs = CreateObject("ADODB.Recordset")

    Dim curid As Long
    Dim hash As String

    ' Wenn Sie bereits gespeichert wurde...
    Dim wasLocked As Boolean
    If Not GetTargetRS(conn, GetUNCPathFromDoc(curdoc), curdoc, rs, curid, hash, ADODB.LockTypeEnum.adLockPessimistic, wasLocked) Then
        If wasLocked Then
          'MsgBox "Ein anderer User greift gerade auf die Daten der Datei zu, bitte versuchen Sie es sp|fffd|ter noch einmal.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
          MsgBox FMT0("BLATTSCHUTZ_3"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        Else
'          If (Left(GetCurrentDocUNCPathFromApp(officeapp), 1) = "\" Or Left(GetCurrentDocUNCPathFromApp(officeapp), 1) = "/" Or Mid(GetCurrentDocUNCPathFromApp(officeapp), 2, 1) = ":") And _
'            WBGetValueLong(officeapp, "_IDVTrackerID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix) > 0 Then
'            MsgBox "Aktuell kann keine neue Version erzeugt werden, da die Datenbank oder der Datensatz gesperrt ist. Sollte dies l|fffd|nger der Fall sein informieren Sie bitte Ihre Administration.", vbInformation + vbSystemModal, ProgNameLong & " " & MyVersion & " (Build: " & app.Revision & ")"
'          Else
            'MsgBox "Bevor Sie eine neue Version erzeugen k|fffd|nnen, muss die Datei zuerst von Ihnen gespeichert werden.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
            MsgBox FMT0("THISADDIN_29"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
'          End If
        End If
        Set rs = Nothing
        conn.Close
        Set conn = Nothing
        Exit Sub
    Else
        DoNewVersionWithConnection conn, officeapp, curdoc, rs, curid
    End If
    If Not rs Is Nothing Then
        rs.Close
    End If
    Set rs = Nothing
    SetzeAmpelStatus curdoc, conn
    Set conn = Nothing
    Exit Sub
    Exit Sub

nogo:
  DebugPrint DebType.tERROR, "DoNewVersion - Err: " & err.Number & " - " & err.Description & " - " & err.Source
  
  On Error Resume Next
  If Not rs Is Nothing Then
    If rs.state <> 0 Then
'      rs.Close
    End If
    Set rs = Nothing
  End If
    
    If Not conn Is Nothing Then
        conn.Close
        Set conn = Nothing
    End If
End Sub

Sub DoNewVersionWithConnection(ByRef conn As Object, ByRef officeapp As Object, ByRef curdoc As Object, ByRef rs As Object, ByVal curid As Long)
    
On Error GoTo nogo
    
    Dim sBetreff As String
    Dim sText As String

    If GetSafeFieldPlus(rs, "Speicheranzahl", 0) <= 0 Then
        'MsgBox "Bevor Sie eine neue Version erzeugen k|fffd|nnen, muss die Datei von Ihnen gespeichert werden.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        MsgBox FMT0("THISADDIN_30"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
    Else
        ' ... und sie sich nicht in der Freigabe befindet oder freigegeben wurde
        If IsNull(rs.Fields("FreigabeStatus").value) Or rs.Fields("FreigabeStatus").value = 0 Or rs.Fields("FreigabeStatus").value = 3 Then
            
            Dim warBeendeteFreigabe As Boolean
            If rs.Fields("FreigabeStatus").value = 3 Then
              warBeendeteFreigabe = True
            End If
            
            ' ... dann wird eine neue Version erzeugt und die Doku angezeigt
#If PROJECT_ACCESSTRACKER = 0 Then
            'If MsgBox("Achtung! Sind Sie sicher, dass Sie eine neue Version erzeugen wollen (Die Datei wird hierbei auch gespeichert)?", vbYesNo + vbQuestion + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")") = vbYes Then
            If MsgBox(FMT0("THISADDIN_31"), vbYesNo + vbQuestion + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")") = vbYes Then
#Else
            'If MsgBox("Achtung! Sind Sie sicher, dass Sie eine neue Version erzeugen wollen?", vbYesNo + vbQuestion + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")") = vbYes Then
            If MsgBox(FMT0("THISADDIN_32"), vbYesNo + vbQuestion + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")") = vbYes Then
#End If
                
                ' Wenn die Dateiversionierung ausgeschaltet ist machen wir gar nichts!
                If G_PARAM_DateienVersionierenAbRisikowert <> -1 Then
                  If rs.Fields("Risikowert").value < G_PARAM_DateienVersionierenAbRisikowert Then
                    'MsgBox "Hinweis: Die Dokumentation wird historisiert, die Datei selbst wird nicht im Datenbanksystem abgelegt, da sie einen zu geringen Risikogehalt aufweist. Bitte erzeugen Sie, falls erforderlich, eine eigene Sicherheitskopie f|fffd|r die aktuelle Version.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                    If FMT0("THISADDIN_33") <> "" Then
                      MsgBox FMT0("THISADDIN_33"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                    End If
                  Else
                    DoInternalSave rs, curdoc, conn
                    LogSpeichern rs, curdoc, conn
                    CheckInFile curdoc.fullname, rs, officeapp, conn
                    rs.Update
                    Dim id As Long
                    id = rs.Fields("idvDateiID").value
                    rs.Close
                    Set rs = OpenRS("select * from idvDateien where idvDateiID = " & id, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockPessimistic)
                  End If
                End If
                
                ' MaxVersion bestimmt die neue Versionsnummer, wenn es denn schon gesetzt ist
                ' AktuelleVersionErhoehen conn, rs
                If G_PARAM_IncVersBeiInitAbbruch = True Or warBeendeteFreigabe = True Then
                    CreateNewRecordset GetUNCPathFromDoc(curdoc), curdoc.fullname, officeapp, rs, conn
                    MajorVersionErhoehen rs
                End If
                
                FreigabeEntfernenAlleVariablen officeapp, rs, conn, curdoc
                
'                WBSetValueLong curdoc, "_IDVTrackerID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, rs.Fields("idvDateiID").value
'                WBSetValueLong curdoc, "_IDVTrackerVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, rs.Fields("Version").value
'                WBSetValueLong curdoc, "_IDVTrackerFreigabeStatus" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, 0
'                WBSetValueLong curdoc, "_IDVTrackerMajorVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, rs.Fields("MajorVersion").value
'                WBSetValueLong curdoc, "_IDVTrackerMinorVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, rs.Fields("MinorVersion").value

                DoInternalSave rs, curdoc, conn
                
                rs.Update
            End If
        Else
            ' ansonsten war das Programm freigegeben oder in der Initiierung! Mal abfragen, ob er das wirklich will!
            If IstDateiFreigabeStatusDeaktiviert(rs) = True Then
                
                CreateNewRecordset GetUNCPathFromDoc(curdoc), curdoc.fullname, curdoc, rs, conn
                MajorVersionErhoehen rs
                ' auf jeden Fall den FreigabeStatus zur|fffd|cksetzen
                rs.Fields("FreigabeStatus").value = 0
                rs.Fields("FreigabeidvDateiID").value = 0
                rs.Fields("FreigabeVersion").value = 0
                rs.Fields("FreigabeChecksumme").value = ""

                rs.Fields("FreigabeInitiierung").value = Empty
                rs.Fields("FreigabeInitUserLogonID").value = ""
                
                WBSetValueLong curdoc, "_IDVTrackerID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, rs.Fields("idvDateiID").value
                WBSetValueLong curdoc, "_IDVTrackerVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, rs.Fields("Version").value
                WBSetValueLong curdoc, "_IDVTrackerFreigabeStatus" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, 0
                WBSetValueLong curdoc, "_IDVTrackerFreigabeDateiID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, -1
                WBSetValueLong curdoc, "_IDVTrackerFreigabeVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, -1
                WBSetValueLong curdoc, "_IDVTrackerMajorVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, rs.Fields("MajorVersion").value
                WBSetValueLong curdoc, "_IDVTrackerMinorVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, rs.Fields("MinorVersion").value

                DoInternalSave rs, curdoc, conn
                
                rs.Update
            'If rs.Fields("FreigabeStatus").value = 1 Then
            ElseIf IstDateiFreigabeStatusInitiiert(rs) = True Then
                'If MsgBox("Achtung! Das Programm befindet sich aktuell im Freigabeprozess. Wenn Sie eine neue Version erzeugen, wird der Freigabeprozess abgebrochen." & IIf(G_PARAM_SMTPMailVersandAktiv, " und die Administration informiert", "") & "! Sind Sie sicher, dass Sie die Freigabe abbrechen wollen (Die Datei wird hierbei auch gespeichert)?", vbYesNo + vbQuestion + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")") = vbYes Then
                If MsgBox(FMT1("THISADDIN_34", IIf(G_PARAM_SMTPMailVersandAktiv, FMT0("THISADDIN_35"), "")), vbYesNo + vbQuestion + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")") = vbYes Then
                    FreigabeAbbrechen rs, officeapp, curdoc, conn, G_PARAM_IncVersBeiInitAbbruch, True, True
                    DebugPrint tSystem, "Freigabe Initiierung durch User aufgehoben", 0, 0, rs.Fields("idvDateiID").value
                End If
            ' ElseIf rs.Fields("FreigabeStatus").value = 2 Then
            ElseIf IstDateiFreigabeStatusFreigegeben(rs) = True Then
                'If MsgBox("Achtung! Das Programm wurde freigegeben. Wenn Sie eine neue Version erzeugen, wird die Freigabe entfernt! Bereits existente Kopien der aktuellen Version bleiben nach wie vor freigegeben und k|fffd|nnen entsprechend weiter verwendet werden. Sind Sie sicher, dass Sie die Freigabe durch eine neue Version aufheben wollen (Die Datei wird hierbei auch gespeichert)?", vbYesNo + vbQuestion + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")") = vbYes Then
                If MsgBox(FMT0("THISADDIN_36"), vbYesNo + vbQuestion + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")") = vbYes Then
                    ' TODO Major/Minor?
                    'FreigabeEntfernen pluginapp, rs, conn, curdoc, "Freigabe entfernt wg. neuer Version ID " & rs.Fields("idvDateiID").value, True
                    FreigabeEntfernen officeapp, rs, conn, curdoc, FMT1("THISADDIN_37", rs.Fields("idvDateiID").value), True
                    DebugPrint tSystem, "Freigabe durch User aufgehoben", 0, 0, rs.Fields("idvDateiID").value
                End If
            Else
                'MsgBox "Interner Fehler: Unbekannter FreigabeStatus: " & rs.Fields("FreigabeStatus").value, vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                MsgBox FMT1("THISADDIN_38", rs.Fields("FreigabeStatus").value), vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
            End If

        End If
    End If
    Exit Sub
    
nogo:
  DebugPrint DebType.tERROR, "DoNewVersionWithConnection - Err: " & err.Number & " - " & err.Description & " - " & err.Source
End Sub

Function GetRisikoklassenCheckliste(ByRef conn As Object, ByVal Risikowert As Double, ByVal freigabetyp As Long) As String

    Dim rs As Object
    GetRisikoklassenCheckliste = ""
On Error GoTo raus
    Set rs = CreateObject("ADODB.Recordset")
    Dim q As String
    q = "Select " & IIf(freigabetyp = 1, "ChecklisteInitiierung", "ChecklisteFreigabe") & " as t, uCheckliste.LokalisierterText as Loc " & _
    " from gRisikoklasse left join gTexteUebersetzungen uCheckliste on (gRisikoklasse." & IIf(freigabetyp = 1, "ChecklisteInitiierungTextID", "ChecklisteFreigabeTextID") & " = uCheckliste.TextID and uCheckliste.LanguageID = " & GetMyDBLanguage(conn) & ")" & _
    " where RisikowertVon <= " & Replace(CStr(Risikowert), ",", ".") & " and " & Replace(CStr(Risikowert), ",", ".") & " <= RisikowertBis"
    
    rs.Open q, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
    If Not rs Is Nothing Then
        If rs.EOF = False Then
            If Not IsNull(rs.Fields("t").value) Then
                GetRisikoklassenCheckliste = GetLocValueFromField(rs, "t", "Loc", "")
            End If
        End If
        rs.Close
    End If

raus:
    Set rs = Nothing

End Function

' freigabetyp = 1 ist FreigabeInitiierung
' freigabetyp = 2 ist Freigabe
' Wenn minorVersion <> 0 dann wird die Checkliste aus den Texten ausgegeben
Function ChecklisteOk(ByRef conn As Object, ByVal Risikowert As Double, ByVal freigabetyp As Long, ByVal minorVersion As Long) As Boolean

    Dim s As String
    If minorVersion <> 0 Then
      If freigabetyp = 1 Then
        If FMT0("ST_53") <> "" Then
          s = FMT0("ST_53")
        End If
      Else
        If FMT0("ST_54") <> "" Then
          s = FMT0("ST_54")
        End If
      End If
    Else
      s = GetRisikoklassenCheckliste(conn, Risikowert, freigabetyp)
    End If
    
    If s = "" Then
      ChecklisteOk = True
      Exit Function
    End If
    
    ChecklisteOk = False
    Load frmFreigabeCheckliste
    frmFreigabeCheckliste.TextCheckliste.SetFocus
    frmFreigabeCheckliste.TextCheckliste.CurLine = 0
    frmFreigabeCheckliste.TextCheckliste.Text = s
    If Trim(frmFreigabeCheckliste.TextCheckliste.Text) <> "" Then
        frmFreigabeCheckliste.Show vbModal
        ChecklisteOk = frmFreigabeCheckliste.OkGeklickt
    Else
        ChecklisteOk = True
    End If
    Unload frmFreigabeCheckliste

End Function

Sub DoFreigabeInit(ByRef officeapp As Object, ByRef curdoc As Object)

On Error GoTo nogo

#If Project_ExcelTracker = 1 Then
  If curdoc.readOnly = True Then
    'MsgBox "Die Datei ist schreibgesch|fffd|tzt und kann deshalb aktuell nicht zur Freigabe initiiert werden.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
    MsgBox FMT0("THISADDIN_39"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
    Exit Sub
  End If
#End If

    If IsSharedWorkbook(curdoc) Then
        'MsgBox "Die Funktion kann nicht genutzt werden, da die Microsoft-Freigabe verwendet wurde (""Arbeitsmappe freigeben""). Bitte entfernen Sie die Freigabe, um die Funktion auszuf|fffd|hren."
        MsgBox FMT0("THISADDIN_27"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        Exit Sub
    End If
    
    Dim wurdeFreigegeben As Boolean
    wurdeFreigegeben = False
    Dim logtrack As Long
    logtrack = 0
    
    Dim conn As Object
    Set conn = GetConnection()
    
    logtrack = 1

    If conn Is Nothing Then
        'MsgBox "Diese Funktion ist zur Zeit nicht ausf|fffd|hrbar, da das System nicht zur Verf|fffd|gung steht. Bitte versuchen Sie es sp|fffd|ter noch einmal.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        MsgBox FMT0("DOKUPWD_3"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        Exit Sub
    End If

    logtrack = 2

    If Deaktiviert(conn) Then
        'MsgBox "Aktuell steht diese Funktion nicht zur Verf|fffd|gung, da das System deaktiviert wurde. Bitte versuchen Sie es sp|fffd|ter noch einmal.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        MsgBox FMT0("DOKUPWD_4"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        conn.Close
        Set conn = Nothing
        Exit Sub
    End If

    logtrack = 3

    If G_PARAM_LokaleDateienBer|fffd|cksichtigen = False And Left(GetUNCPath(curdoc.fullname), 2) <> "//" And Left(GetUNCPath(curdoc.fullname), 2) <> "\\" And InStr(curdoc.fullname, "://") <= 0 Then
      'MsgBox "Es k|fffd|nnen nur Excel-Dateien freigegeben werden, die auf einem Netzlaufwerk gespeichert wurden. Nutzen Sie Datei / Speichern unter, legen das Programm auf einem Netzwerkpfad ab und rufen diese Funktion erneut auf.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
      MsgBox FMT0("THISADDIN_40"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
      conn.Close
      Set conn = Nothing
      Exit Sub
    End If

    If DateiAusgeschlossen2(curdoc, conn) = True Then
        'MsgBox "Diese Funktion steht f|fffd|r diese Datei/f|fffd|r Dateien in diesem Verzeichnis nicht zur Verf|fffd|gung.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        MsgBox FMT0("BLATTSCHUTZ_2"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        conn.Close
        Set conn = Nothing
        Exit Sub
    End If
    
   
    logtrack = 4

    Dim rs As Object
    Set rs = CreateObject("ADODB.Recordset")
    Dim curid As Long
    Dim hash As String

    ' Wenn Sie bereits gespeichert wurde...
    Dim wasLocked As Boolean
    If Not GetTargetRS(conn, GetUNCPath(curdoc.fullname), curdoc, rs, curid, hash, ADODB.LockTypeEnum.adLockPessimistic, wasLocked) Then
        logtrack = 5
        If wasLocked Then
          'MsgBox "Ein anderer User greift gerade auf die Daten der Datei zu, bitte versuchen Sie es sp|fffd|ter noch einmal.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
          MsgBox FMT0("BLATTSCHUTZ_3"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        Else
'          If (Left(GetCurrentDocUNCPathFromApp(officeapp), 1) = "\" Or Left(GetCurrentDocUNCPathFromApp(officeapp), 1) = "/" Or Mid(GetCurrentDocUNCPathFromApp(officeapp), 2, 1) = ":") And _
'            WBGetValueLong(officeapp, "_IDVTrackerID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix) > 0 Then
'            MsgBox "Aktuell kann keine Programmfreigabe initiiert werden, da die Datenbank oder der Datensatz gesperrt ist. Sollte dies l|fffd|nger der Fall sein informieren Sie bitte Ihre Administration.", vbInformation + vbSystemModal, ProgNameLong & " " & MyVersion & " (Build: " & app.Revision & ")"
'          Else
            'MsgBox "Bevor Sie die Programmfreigabe initiieren k|fffd|nnen, muss die Datei von Ihnen gespeichert werden.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
            MsgBox FMT0("THISADDIN_41"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
'          End If
        End If
        Set rs = Nothing
        conn.Close
        Set conn = Nothing
        Exit Sub
    Else
        If GetSafeFieldPlus(rs, "Risikowert", 0#) < G_cfgFreigabeAbRisiko Then
          'MsgBox "Eine Freigabe der Datei ist erst ab einem Risikowert von " & Format(G_cfgFreigabeAbRisiko * 100, "#;-#;0") & "% m|fffd|glich.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
          MsgBox FMT1("THISADDIN_42", Format(G_cfgFreigabeAbRisiko * 100, "#;-#;0")), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
          rs.Close
          Set rs = Nothing
          conn.Close
          Set conn = Nothing
          Exit Sub
        End If
        
        logtrack = 6
        
#If PROJECT_ACCESSTRACKER = 1 Then
#Else

        If IstDateiFreigabeStatusDeaktiviert(rs) = True Then
           DebugPrint tinfo, "DoFreigabeInit - Dateifreigabe deaktiviert"
       
           DoNewVersionWhenDeaktiviert conn, officeapp, curdoc, rs
           
           rs.Close
           Set rs = Nothing
           conn.Close
           Set conn = Nothing
           Exit Sub
        End If
        
        logtrack = 62
        
        'If rs.Fields("FreigabeStatus").value = 2 Then
        If IstDateiFreigabeStatusFreigegeben(rs) = True Then
            If G_PARAM_NumAllowedMinorChanges >= 1 And G_PARAM_MinorChanges4AP = True And G_cfgMinorChanges4APComplex = True And G_AmpelStatus = 2 Then
                logtrack = 61
                If MMFreigabe(officeapp, curdoc, conn, curid, False, True) >= 0 Then
                    ' Minor oder Major Change durchgef|fffd|hrt
                    rs.Close
                    Set rs = Nothing
   
                    SetzeAmpelStatus curdoc, conn
                    
                    conn.Close
                    Set conn = Nothing
                    Exit Sub
                End If
            End If
       End If
#End If
        
        ' ... und sie sich nicht in der Freigabe befindet oder freigegeben wurde
        'If rs.Fields("FreigabeStatus").value = 1 Then
        If IstDateiFreigabeStatusInitiiert(rs) = True Then
            logtrack = 7
'            MsgBox "Das Programm befindet sich bereits in der Freigabe oder wurde schon freigegeben!", vbInformation + vbSystemModal, ProgNameLong & " " & MyVersion & " (" & App.Major & "." & App.Minor & "."  & App.Revision & ")"
            'If MsgBox("Achtung! " & GetFreigabeStatusText(rs.Fields("FreigabeStatus").value) & " Sind Sie sicher, dass Sie die Freigabe aufheben und dadurch eine neue Version erzeugen wollen (Die Datei wird hierbei auch gespeichert)?", vbYesNo + vbQuestion + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")") = vbYes Then
            If MsgBox(FMT0("THISADDIN_105"), vbYesNo + vbQuestion + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")") = vbYes Then
                FreigabeAbbrechen rs, officeapp, curdoc, conn, G_PARAM_IncVersBeiInitAbbruch, True, True
            End If
        ' ElseIf rs.Fields("FreigabeStatus").value = 2 Then
        ElseIf IstDateiFreigabeStatusFreigegeben(rs) = True Then
            If Not UserKannFreigeben(G_CfgFreigabeEntf, rs) Then
              ' Sie sind nicht dazu berechtigt, diese Funktion auszuf|fffd|hren. Bitte wenden Sie sich an die Programmverantwortlichen.\n\n%1
              MsgBox FMT1("FREIGABE_1", GetVerantwortlicheUser(conn, rs, G_CfgFreigabeEntf)), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
              rs.Close
              Set rs = Nothing
              conn.Close
              Set conn = Nothing
              Exit Sub
            End If
            logtrack = 7
'            MsgBox "Das Programm befindet sich bereits in der Freigabe oder wurde schon freigegeben!", vbInformation + vbSystemModal, ProgNameLong & " " & MyVersion & " (" & App.Major & "." & App.Minor & "."  & App.Revision & ")"
            'If MsgBox("Achtung! " & GetFreigabeStatusText(rs.Fields("FreigabeStatus").value) & " Sind Sie sicher, dass Sie die Freigabe aufheben und dadurch eine neue Version erzeugen wollen (Die Datei wird hierbei auch gespeichert)?", vbYesNo + vbQuestion + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")") = vbYes Then
            If MsgBox(FMT1("THISADDIN_43", GetFreigabeStatusText(rs.Fields("FreigabeStatus").value)), vbYesNo + vbQuestion + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")") = vbYes Then
                'FreigabeEntfernen pluginapp, rs, conn, curdoc, "Freigabe entfernt wg. neuer Version ID " & rs.Fields("idvDateiID").value, True
                FreigabeEntfernen officeapp, rs, conn, curdoc, FMT1("THISADDIN_37", rs.Fields("idvDateiID").value), True
                If GetSafeFieldPlus(rs, "FreigabeStatus", 0) = 2 Then
                  DebugPrint tSystem, "Freigabe durch User aufgehoben", 0, 0, rs.Fields("idvDateiID").value
                Else
                  DebugPrint tSystem, "Freigabe Initiierung durch User aufgehoben", 0, 0, rs.Fields("idvDateiID").value
                End If
            End If
        Else
        
          If G_cfgAutoProtectBeiInit > 0 Then
            If WBHasProtectedSheets(curdoc) Then
              If G_cfgIgnoreProtectedWorksheets Then
                ' ACHTUNG: Es sind bereits gesch|fffd|tzte Bl|fffd|tter in der Arbeitsmappe vorhanden. Diese Bl|fffd|tter werden NICHT gesch|fffd|tzt. Sie k|fffd|nnen auch nicht entsch|fffd|tzt werden, wenn die Freigabe wieder entfernt wird. Bitte pr|fffd|fen Sie selbst|fffd|ndig mit dem ECC, ob alle relevanten Formelzellen auf diesen Bl|fffd|ttern gesch|fffd|tzt sind.
                MsgBox FMT0("THISADDIN_134"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
              Else
                ' Diese Funktion kann nicht durchgef|fffd|hrt werden, das die Datei gesch|fffd|tzte Tabellenbl|fffd|tter hat. Bitte entfernen Sie den Blattschutz und rufen die Funktion erneut auf.
                MsgBox FMT0("THISADDIN_123"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                rs.Close
                Set rs = Nothing
                conn.Close
                Set conn = Nothing
                Exit Sub
              End If
            End If
          End If
        
          If G_CfgSBSObjektMussGesetztSein = True And GetSafeFieldPlus(rs, "SBSAssetID", 0) = 0 Then
            ' Sie m|fffd|ssen ein Schutzbedarfsobjekt zuweisen, um die Programmfreigabe zu initiieren. |fffd|ffnen Sie daf|fffd|r die Dokumentation und w|fffd|hlen ein Schutzbedarfsobjekt aus.
            MsgBox FMT0("FREIGABE_3"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
            rs.Close
            Set rs = Nothing
            conn.Close
            Set conn = Nothing
            Exit Sub
          End If
          
          If Not UserKannFreigeben(G_CfgFreigabeInit, rs) Then
            ' Sie sind nicht dazu berechtigt, diese Funktion auszuf|fffd|hren. Bitte wenden Sie sich an die Programmverantwortlichen.\n\n%1
            MsgBox FMT1("FREIGABE_1", GetVerantwortlicheUser(conn, rs, G_CfgFreigabeInit)), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
            rs.Close
            Set rs = Nothing
            conn.Close
            Set conn = Nothing
            Exit Sub
          End If
          
            
            
            Dim objScript As Object
            Dim cso As Object
            Set cso = New CScriptObject
            Set objScript = cso.GetObject
            'objScript.Language = "VBScript"
            ' objScript.AllowUI = False
    
            If G_PARAM_KeineFreigabeOhneRisikobefragung = True And rs.Fields("Risikowert").value < 0 Then
                'MsgBox "Achtung! Die Datei wurde noch nicht risikobefragt und kann daher nicht freigegeben werden!", vbOKOnly + vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                MsgBox FMT0("THISADDIN_44"), vbOKOnly + vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
            ElseIf GetSafeFieldPlus(rs, "Speicheranzahl", 0) <= 0 Then
                'MsgBox "Bevor Sie die Programmfreigabe initiieren k|fffd|nnen, muss die Datei von Ihnen gespeichert werden.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                MsgBox FMT0("THISADDIN_41"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
            Else
                Dim fragenGeaendert As Long
                fragenGeaendert = SindFragenProzesseGeaendert(rs, conn)
                If fragenGeaendert > 0 Then
                    If fragenGeaendert = 1 Or fragenGeaendert = 3 Then
                        MsgBox FMT0("THISADDIN_101"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                    Else
                        MsgBox FMT0("THISADDIN_108"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                    End If
                ElseIf DokuPflichtfelderGefuellt(objScript, rs, conn, True, False) = False Then
                    'MsgBox "Nicht alle Pflichtfelder sind in der Doku gef|fffd|llt. Bitte vervollst|fffd|ndigen Sie die, damit Sie die Freigabe initiieren k|fffd|nnen.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                    MsgBox FMT0("THISADDIN_45"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                Else
            
                    logtrack = 8
                    
                    If ChecklisteOk(conn, GetSafeFieldPlus(rs, "Risikowert", 0), 1, GetSafeFieldPlus(rs, "MinorVersion", 0)) = True Then
                    
    #If Project_ExcelTracker = 1 Then
                    Dim msgboxtxt As String
                    
                    If G_cfgSaveNachInit Then
                      ' Wenn Sie die Programmfreigabe initiieren, wird die Datei jetzt gespeichert. Wollen Sie wirklich die Programmfreigabe initiieren?
                      msgboxtxt = FMT0("THISADDIN_122")
                    Else
                      '"Achtung: Wenn Sie die Programmfreigabe initiieren, wird die Datei jetzt gespeichert. Danach sind keine Speicherungen dieser Datei bis zur Programmfreigabe mehr m|fffd|glich, au|fffd|er Sie erzeugen eine neue Version und brechen dadurch den Freigabeprozess ab! Wollen Sie wirklich die Programmfreigabe initiieren?"
                      msgboxtxt = FMT0("THISADDIN_46")
                    End If
                    
                    If G_cfgAutoProtectBeiInit > 0 Then
                      ' Bitte beachten Sie, dass zus|fffd|tzlich alle Formelzellen gesch|fffd|tzt werden und auf jedem Blatt ein Blattschutz angebracht wird. Zellen ohne Formel werden NICHT "entsch|fffd|tzt"! Bedenken Sie hierbei, dass Zellen ohne Formel, bei denen der Zellschutz nicht von Ihnen entfernt wurde, automatisch nach der Absicherung gesch|fffd|tzt sind und nicht mehr beschrieben werden k|fffd|nnen! D.h. in einer leeren Zelle bzw. einer Zelle ohne Formel mit aktivem Zellschutz ist keine Erfassung mehr m|fffd|gich! Zum "entsch|fffd|tzen" von Zellen k|fffd|nnen Sie in Excel die Funktion STRG+1, dann Reiter "Schutz" und dann den Haken bei "Gesperrt" entfernen nutzen. Nur Zellen "ohne Haken" k|fffd|nnen beschrieben werden. Bitte bedenken Sie auch, dass Sie bei aktivem Blattschutz keine Zeilen oder Spalten einf|fffd|gen k|fffd|nnen!
                      msgboxtxt = msgboxtxt & vbCrLf & vbCrLf & FMT0("THISADDIN_124")
                      Dim addmsgboxtxt As String
                      
                      If InStr(G_cfgWorksheetProtArgs, "FORMATZEILE") > 0 Then
                        ' - Zeilen formatieren
                        addmsgboxtxt = addmsgboxtxt & IIf(addmsgboxtxt <> "", vbCrLf, "") & FMT0("THISADDIN_126")
                      End If
                      If InStr(G_cfgWorksheetProtArgs, "FORMATSPALTE") > 0 Then
                        ' - Spalten formatieren
                        addmsgboxtxt = addmsgboxtxt & IIf(addmsgboxtxt <> "", vbCrLf, "") & FMT0("THISADDIN_127")
                      End If
                      If InStr(G_cfgWorksheetProtArgs, "FORMATZELLE") > 0 Then
                        ' - Zellen formatieren
                        addmsgboxtxt = addmsgboxtxt & IIf(addmsgboxtxt <> "", vbCrLf, "") & FMT0("THISADDIN_128")
                      End If
                      If InStr(G_cfgWorksheetProtArgs, "HYPER") > 0 Then
                        ' - Hyperlinks einf|fffd|gen
                        addmsgboxtxt = addmsgboxtxt & IIf(addmsgboxtxt <> "", vbCrLf, "") & FMT0("THISADDIN_129")
                      End If
                      If InStr(G_cfgWorksheetProtArgs, "AUTOFILTER") > 0 Then
                        ' - Autofilter verwenden (muss vor der Absicherung bereits angebracht worden sein!)
                        addmsgboxtxt = addmsgboxtxt & IIf(addmsgboxtxt <> "", vbCrLf, "") & FMT0("THISADDIN_130")
                      End If
                      If InStr(G_cfgWorksheetProtArgs, "PIVOT") > 0 Then
                        ' - Pivots verwenden (muss vor der Absicherung bereits eingef|fffd|gt worden sein!)
                        addmsgboxtxt = addmsgboxtxt & IIf(addmsgboxtxt <> "", vbCrLf, "") & FMT0("THISADDIN_131")
                      End If
                    End If
                    
                    If addmsgboxtxt <> "" Then
                      msgboxtxt = msgboxtxt & vbCrLf & vbCrLf & FMT0("THISADDIN_125") & vbCrLf & addmsgboxtxt
                    End If
                    
                    
                    If MyMsgBox(msgboxtxt, vbYesNo + vbQuestion + vbSystemModal, FMT0("THISADDIN_48")) = vbYes Then
    #Else
                    'If MsgBox("Achtung: Wenn Sie die Programmfreigabe initiieren, k|fffd|nnen Sie bis zur Freigabe des Programms nicht mehr mit der Datenbank arbeiten! Sollten Sie die Datenbank nochmals |fffd|ffnen, werden Sie auf den laufenden Freigabeprozess hingewiesen und k|fffd|nnen dann, falls erforderlich, die Freigabe auch abbrechen! Wollen Sie wirklich die Programmfreigabe initiieren?", vbYesNo + vbQuestion + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")" & " - Initiierung einer Programmfreigabe") = vbYes Then
                    If MsgBox(FMT0("THISADDIN_47"), vbYesNo + vbQuestion + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")" & " - " & FMT0("THISADDIN_48")) = vbYes Then
    #End If
                        logtrack = 9
                        
                        Dim ok2 As Boolean
                        ok2 = True
                        ' Hier wird die Doku geholt, damit jede Datei, die freigegeben werden soll, ihre eigene Doku hat!
                        If Not CheckForCurrentDoku(rs, conn) Then
                              'MsgBox "Derzeit kann nicht auf die Dokumentation zugegriffen werden. Der Vorgang wird abgebrochen. Bitte versuchen Sie es sp|fffd|ter noch einmal.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                              MsgBox FMT0("THISADDIN_49"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                              ok2 = False
                        End If
                  
                        If G_cfgAutoProtectBeiInit > 0 Then
                          If Not BlattschutzAnbringen(conn, rs, officeapp, curdoc, False) Then
                            'Die Freigabeinitiierung konnte nicht durchgef|fffd|hrt werden, es sind Fehler aufgetreten. Bitte versuchen Sie es sp|fffd|ter noch einmal.
                            MsgBox FMT1("THISADDIN_112", FMT0("XLAAPP_22")), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                            curdoc.Close False
                            ok2 = False
                          End If
                        End If
                              
                        If ok2 Then
                              DoInternalSave rs, curdoc, conn
                              LogSpeichern rs, curdoc, conn
                              logtrack = 80
                              
                              Dim ok As Boolean
                              ok = True
              
                              ' Erst mal muss die Datei kopiert werden, denn sonst ist sie "in Benutzung"
                              If (G_PARAM_DateienVersionierenAbRisikowert >= 0 And rs!Risikowert >= G_PARAM_DateienVersionierenAbRisikowert) Or G_PARAM_EincheckenBeiFreigabeInit = True Then
                                logtrack = 82
                                ok = CheckInFile(curdoc.fullname, rs, officeapp, conn)
                              Else
                                logtrack = 81
                                'MsgBox "Hinweis: Die Dokumentation wird historisiert, die Datei selbst wird nicht im Datenbanksystem abgelegt. Bitte erzeugen Sie, falls erforderlich, eine eigene Sicherheitskopie f|fffd|r die aktuelle Version.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                                If FMT0("THISADDIN_50") <> "" Then
                                  MsgBox FMT0("THISADDIN_50"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                                End If
                              End If
                              logtrack = 83
                              
                              If Not ok Then
                                rs.CancelUpdate
                              Else
                              
                              
                                      Dim sBetreff As String
                                      Dim sText As String
                      
                                      sBetreff = G_PARAM_SMTPFreigabeBetreff
                                      sText = G_PARAM_SMTPMailFreigabe
                                      logtrack = 10
                      
                                      ReplaceStuff curdoc, sBetreff, rs
                                      ReplaceStuff curdoc, sText, rs
                                      ReplaceStuffInitiator sBetreff, conn, GetUserName()
                                      ReplaceStuffInitiator sText, conn, GetUserName()
                                      
                                      logtrack = 11
                                      
                                      ' Hier war vorher der Code f|fffd|r das Freigabeformular.
                                      ' Bei Word ist er auch hier geblieben, f|fffd|r Excel (ECC / FCC / ACC) ist er weiter
                                      ' runter gewandert, da das die Datei gespeichert sein, muss, damit der ECC sie nicht ver|fffd|ndert.
                                      
                                      Dim freigabeformularErzeugt As Boolean
                                      Dim fNameFreigabeformularSaved As String
                                      Dim fNameFreigabeformularVordruck As String
                                      fNameFreigabeformularVordruck = GetFreigabeformularFilename(rs)
                                      
                                      logtrack = 1101
                                      ' Wir machen nur ein Freigabeformular bei MajorVersionen
                                      If GetSafeFieldPlus(rs, "MinorVersion", -1) = 0 Then
                                        logtrack = 1102
                                        ' Wenn das Freigabeformular Word ist
                                        If IsWordDocument(fNameFreigabeformularVordruck) Then
                                          logtrack = 1103
                                          If CreateFreigabeformular(curdoc, fNameFreigabeformularVordruck, G_cfgFreigabeformspeicherpfad, _
                                            officeapp, rs, conn, fNameFreigabeformularSaved, 1, False, _
                                            curdoc.fullname & " V" & GetSafeFieldPlus(rs, "MajorVersion", 0) & "." & GetSafeFieldPlus(rs, "MinorVersion", 0), MyFileDateTime(curdoc.fullname), "", "") Then
                                            logtrack = 1104
                                            freigabeformularErzeugt = True
                                          End If
                                        End If
                                      End If
                                      
                                      logtrack = 1105
                                      Dim delQuery As String
                                      delQuery = "DELETE FROM idvFreigabenInformUser WHERE idvDateiID = " & rs.Fields("idvDateiID").value & " and Version = " & rs.Fields("Version").value
                                      conn.Execute delQuery
                                      logtrack = 1106
                                      If G_PARAM_SMTPMailVersandAktiv = True Then
                                        logtrack = 1107
                                        If G_PARAM_EMailListe = True Then
                                                logtrack = 1108
                                                If DCount("WindowsUserID", "gWindowsUserAktuell") > 0 Then
                                                  logtrack = 1109
                                                  Load frmEMailliste
                                                  logtrack = 1110
                                                  frmEMailliste.PrgFreigabe1 = IIf(G_PARAM_SMTPEmpfaenger_ProgrammfreigabenA <> "", G_PARAM_SMTPEmpfaenger_ProgrammfreigabenA, "-\-")
                                                  frmEMailliste.PrgFreigabe2 = IIf(G_PARAM_SMTPEmpfaenger_ProgrammfreigabenB <> "", G_PARAM_SMTPEmpfaenger_ProgrammfreigabenB, "-\-")
                                                  logtrack = 1111
                                                  frmEMailliste.Show vbModal
                                                  logtrack = 1112
                                                  
                                                  If Not frmEMailliste.m_OK Then
                                                    logtrack = 1113
                                                    rs.CancelUpdate
                                                    rs.Close
                                                    Set rs = Nothing
                                                    conn.Close
                                                    Set conn = Nothing
                                                    logtrack = 1114
                                                    Unload frmEMailliste
                                                    logtrack = 1115
                                                    Exit Sub
                                                  Else
                                                    logtrack = 1115
                                                    ' Der Parameter nach sText landet in Mail_Senden in DebugPrint - nicht ueber FMT0() aus den String tables holen!
                                                    InformAdmins G_PARAM_StoreMailsToTable, conn, sBetreff, sText, "Freigabeinitialisierung ID " & rs.Fields("idvDateiID").value, fNameFreigabeformularSaved, frmEMailliste.ccList
                                                
                                                    logtrack = 1117
                                                    If frmEMailliste.ccList <> "" Then
                                                        logtrack = 1118
                                                        Dim rsFreigabe As Object
                                                        Set rsFreigabe = OpenRS("SELECT * FROM idvFreigabenInformUser", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockOptimistic)
                                                        logtrack = 1119
                                                        If Not rsFreigabe Is Nothing Then
                                                            logtrack = 1120
                                                            rsFreigabe.AddNew
                                                            logtrack = 1121
                                                            rsFreigabe!idvDateiID = rs.Fields("idvDateiID").value
                                                            logtrack = 1122
                                                            rsFreigabe!Version = rs.Fields("Version").value
                                                            logtrack = 1123
                                                            rsFreigabe!ccEmpfaenger = frmEMailliste.ccList
                                                            logtrack = 1124
                                                            rsFreigabe.Update
                                                            logtrack = 1125
                                                            rsFreigabe.Close
                                                        End If
                                                        Set rsFreigabe = Nothing
                                                    End If
                                                    logtrack = 1126
                                                    Unload frmEMailliste
                                                    logtrack = 1127
                                                  End If
                                                Else
                                                  logtrack = 1128
                                                  InformAdmins G_PARAM_StoreMailsToTable, conn, sBetreff, sText, "Freigabeinitialisierung ID " & rs.Fields("idvDateiID").value, fNameFreigabeformularSaved, ""
                                                  logtrack = 1129
                                                End If
                                        Else
                                          logtrack = 1130
                                          InformAdmins G_PARAM_StoreMailsToTable, conn, sBetreff, sText, "Freigabeinitialisierung ID " & rs.Fields("idvDateiID").value, fNameFreigabeformularSaved, ""
                                          logtrack = 1131
                                        End If
                                      End If
                                      
                                      logtrack = 12
                      
                                      DebugPrint tSystem, "Freigabe initialisiert", 0, 0, rs.Fields("idvDateiID").value
                                      rs.Fields("FreigabeStatus").value = 1
                      '                rs.Fields("Version").Value = rs.Fields("Version").Value + 1
                      
                                      logtrack = 13
                                      WBSetValueLong curdoc, "_IDVTrackerFreigabeDateiID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, rs.Fields("idvDateiID").value
                                      logtrack = 14
                                      WBSetValueLong curdoc, "_IDVTrackerFreigabeVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, rs.Fields("Version").value
                                      logtrack = 15
                                      WBSetValueLong curdoc, "_IDVTrackerFreigabeStatus" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, 1
                                      logtrack = 16
                      
                                      DoInternalSave rs, curdoc, conn
                                      logtrack = 17
                      
                                      rs.Fields("FreigabeInitUserLogonID").value = GetUserNameUCASE
                                      rs.Fields("FreigabeInitiierung").value = rs.Fields("Speicherdatum").value
                                      logtrack = 18
                      
                                      rs.Update
                                      
                                      logtrack = 22
                                      
                                      G_Version = rs.Fields("Version").value
                                      G_DateiID = rs.Fields("idvDateiID").value
                                      
                                      
                                      If FileExists(G_cfgBinpfad & "\FreigabeInfo_indiv.txt") Then
                                        Dim fnameFreigabeInfo As String
                                        CreateFreigabeformular curdoc, G_cfgBinpfad & "\FreigabeInfo_indiv.txt", G_cfgTemppfad, _
                                            Nothing, rs, conn, fnameFreigabeInfo, 3, False, _
                                          curdoc.fullname, MyFileDateTime(curdoc.fullname), "", ""
                                      End If

                                      Dim freigabeformularErzeugtChecker As Boolean
                                      Dim fNameFreigabeformularChecker As String
                                      
                                      ' Wir machen nur ein Freigabeformular bei MajorVersionen
                                      If rs.Fields("MinorVersion").value = 0 Then
                                        If IsExcelDocumentTemplate(fNameFreigabeformularVordruck) Then
                                          Dim checkertyp As String
                                          #If PROJECT_ACCESSTRACKER = 1 Then
                                            checkertyp = "ACC"
                                          #Else
                                            checkertyp = "ECC"
                                          #End If
                                          freigabeformularErzeugt = CreateFreigabeformularWithChecker(checkertyp, curdoc, curid, _
                                            G_cfgFreigabeformspeicherpfad, officeapp, rs, conn, fNameFreigabeformularSaved, fnameFreigabeInfo)
                                        End If
                                      End If
                                      
                                      conn.Execute "DELETE FROM idvDateienFreigaben WHERE idvDateiID = " & G_DateiID & " AND Version = " & G_Version
                                      If freigabeformularErzeugt = True Or freigabeformularErzeugtChecker = True Then
                                        'MsgBox "Die Freigabe wurde initiiert und das Freigabeformular erzeugt." & vbCrLf & vbCrLf & "Die Datei wird jetzt geschlossen!", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                                        MsgBox FMT0("THISADDIN_51"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                                      Else
                                        'MsgBox "Die Freigabe wurde initiiert. " & IIf(G_PARAM_SMTPMailVersandAktiv, "Sobald die Freigabe durchgef|fffd|hrt wurde, werden Sie vom freigebenden User informiert!", "Bitte informieren Sie die f|fffd|r den Programmfreigabeprozess verantwortliche Stelle.") & vbCrLf & vbCrLf & "Die Datei wird jetzt geschlossen!", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                                        MsgBox FMT1("THISADDIN_52", IIf(G_PARAM_SMTPMailVersandAktiv, FMT0("THISADDIN_53"), FMT0("THISADDIN_54"))), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                                      End If
                                      wurdeFreigegeben = True
                                      
                                      ' 15.01.2015 Mailevents testen
                                      CheckMailEvent curdoc, ME_FreigabeInitiiert, rs, conn
                                      
                                      logtrack = 23
                                  End If
                          End If
                    End If
                End If
            End If
            Set objScript = Nothing
            Set cso = Nothing
        End If
    End If
   End If
   logtrack = 24
   rs.Close
   Set rs = Nothing
   logtrack = 25
   
   SetzeAmpelStatus curdoc, conn
  
   conn.Close
   Set conn = Nothing
   
   If fnameFreigabeInfo <> "" Then
     MyKill fnameFreigabeInfo
   End If
  
    If Not curdoc Is Nothing Then
      If wurdeFreigegeben Then
#If PROJECT_ACCESSTRACKER = 1 Then
        Dim accapp
        Set accapp = curdoc.Application
        accapp.CloseCurrentDatabase
#Else
        curdoc.Close False
#End If
      End If
    End If
    Exit Sub
nogo:

    Dim errres As String
    errres = "Trackpos: " & logtrack & " - Err: " & err.Number & " - " & err.Description & " - " & err.Source
    DebugPrint DebType.tERROR, "DoFreigabeInit:" & errres
    'MsgBox "Die Freigabe konnte nicht durchgef|fffd|hrt werden, da ein anderer Prozess auf die Datei zugreift. Bitte versuchen Sie es sp|fffd|ter noch einmal.", vbInformation, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
    'MsgBox "Die Freigabeinitiierung konnte nicht durchgef|fffd|hrt werden, es sind Fehler aufgetreten. Bitte versuchen Sie es sp|fffd|ter noch einmal.", vbInformation, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
    MsgBox FMT1("THISADDIN_55", errres), vbInformation, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
    
    Set rs = Nothing
    If Not conn Is Nothing Then
      conn.Close
      Set conn = Nothing
    End If
    
    If Not curdoc Is Nothing Then
      curdoc.Close False
    End If
End Sub


Private Function FreigabeEintragen(ByRef conn As Object, ByVal dateiid As Long, ByVal Version As Long, ByVal freigebenderUser As String, ByVal comm As String, ByVal stat As Long, ByVal chksum As String, ByVal ccEmpfaenger As String, ByVal dat As Date) As Boolean
On Error GoTo nogo:
  Dim rs As Object
  Set rs = OpenRS("SELECT * FROM idvDateienFreigaben WHERE idvDateiID = " & dateiid & " AND Version = " & Version, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockOptimistic)
  If Not rs Is Nothing Then
  
    If rs.EOF Then
      rs.AddNew
      rs.Fields("idvDateiID").value = dateiid
      rs.Fields("Version").value = Version
    End If
    
    rs.Fields("Datum").value = dat
    rs.Fields("FreigebenderUser").value = freigebenderUser
    rs.Fields("Kommentar").value = comm
    rs.Fields("Status").value = stat
    rs.Fields("FreigabeChecksumme").value = chksum
    rs.Fields("ccEmpfaenger").value = ccEmpfaenger
    
    rs.Update
  
    rs.Close
    Set rs = Nothing
    FreigabeEintragen = True
  End If
  Exit Function
nogo:
  On Error Resume Next
  If Not rs Is Nothing Then
    If rs.status <> 0 Then
      rs.Cancel
      rs.Close
    End If
  End If
  Set rs = Nothing

End Function

Public Function GetFilePrecedents(ByRef conn As Object, ByRef rs As Object, ByVal curid As Long) As Boolean
On Error GoTo nogo
    Dim dateiIds As String
    dateiIds = "" ' CStr(curid)
    Dim refId As Long
    refId = curid
    Dim refIdOld As Long
    Dim firstDataset As Boolean
    firstDataset = True
    
    Do While refId <> 0
        Set rs = OpenRS("SELECT * FROM idvDateien WHERE idvDateiID = " & refId, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
        If Not rs Is Nothing Then
          If Not rs.EOF Then
              If Not firstDataset Then
                dateiIds = IIf(dateiIds <> "", dateiIds & "," & refId, refId)
              End If
              firstDataset = False
              refIdOld = refId
              refId = GetSafeFieldPlus(rs, "ReferenzidvDateiID", 0)
              If refIdOld = refId Then
                  refId = 0
              End If
          Else
              refId = 0
          End If
          rs.Close
        End If
    Loop
    
    If dateiIds = "" Then Exit Function

'    rs.Open "SELECT x.idvDateiID, x.Version, i.MajorVersion, i.MinorVersion FROM xlBin x inner join idvDateien i on x.idvDateiID = i.idvDateiID WHERE i.idvDateiID=" & curId & " or " & gCHR & "HASH" & gCHR & " = '" & hash & "'", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
    Set rs = OpenRS("SELECT distinct i.Dateiname, x.idvDateiID, x.Version, x.Datum, i.MajorVersion, i.MinorVersion FROM A_XLBINTMEINEOES x inner join idvDateien i on x.idvDateiID = i.idvDateiID WHERE i.idvDateiID in (" & dateiIds & ") ORDER BY MajorVersion DESC, MinorVersion DESC", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
    If Not rs Is Nothing Then
      If rs.EOF Then
        rs.Close
        Set rs = Nothing
        Exit Function
      End If
    Else
      Exit Function
    End If
      
    GetFilePrecedents = True
    Exit Function
nogo:
  If Not rs Is Nothing Then
    If rs.status <> 0 Then
      rs.Cancel
      rs.Close
    End If
  End If
  Set rs = Nothing
End Function


Public Function Dateifreigabe(ByRef officeapp As Object, ByRef curdoc As Object, checkertyp As String, ByRef conn As Object, fname As String, dateiid As Long, dateiversion As Long, ByRef errTxt As String, comm As String, Risikowert As Double, Optional approvingUser As String = "") As Boolean

On Error GoTo nogo
    ' Erst mal pr|fffd|fen, ob die Datei |fffd|berhaupt zur Freigabe initiiert wurde.
    Dim ok As Boolean
    ok = True
    Dim freigabeDatum As Date
    freigabeDatum = Now
    
    conn.Execute "Update idvDateien Set FreigabeidvDateiID = 0, FreigabeChecksumme = '-' where idvDateiID = " & dateiid

    If ok Then
        
        StoreFreigabeInfo curdoc, conn, dateiid
        
        Dim checkerfile As String
        
        checkerfile = GetECC()
        SaveSetting appname:="Stromwerken", Section:=checkertyp, Key:="COMMAND", Setting:="APPROVAL" & _
          " /IDCALLER:" & SWAPPID_ExcelTracker & _
          " /ID:" & dateiid & _
          " /DATE:" & Chr(34) & freigabeDatum & Chr(34) & _
          " /COMMENT:" & Chr(34) & Replace(Replace(comm, Chr(34), "-"), "'", "-") & Chr(34) & _
          " /USER:" & Chr(34) & IIf(approvingUser <> "", approvingUser, GetUserName) & Chr(34)
        StartDateiUndWarten checkerfile
      
        Dim tCnt As Long
        For tCnt = 1 To 10
          Sleep 100
          DoEvents
        Next tCnt
        
        Dim resrs As Object
'        Set resrs = CreateObject("ADODB.Recordset")
'        resrs.Open "Select Dateiname,FreigabeChecksumme from idvDateien where idvDateiId = " & dateiID, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
        
        Set resrs = OpenRS("Select * from idvDateien where idvDateiId = " & dateiid, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
        
        If Not resrs Is Nothing Then
          If Not resrs.EOF Then
            ' Macht der Checker nun
'            If resrs.Fields("FreigabeChecksumme").Value <> "-" Then
'                conn.Execute "Update idvDateien Set FreigabeStatus = 2, FreigabeidvDateiID = '" & dateiID & "', FreigabeVersion = '" & dateiversion & "' where idvDateiID = " & dateiID
'                FreigabeEintragen conn, dateiID, dateiversion, GetUserName, comm, 0, resrs.Fields("FreigabeChecksumme").Value, "", freigabedatum
'            Else
            If resrs.Fields("FreigabeChecksumme").value = "-" Then
              errTxt = ""
              ok = False
            Else
              ' Es hat geklappt!!! Dann Datei wieder |fffd|ffnen!
              
              FinalizeFreigabeInfo conn, dateiid
              
#If PROJECT_ACCESSTRACKER = 1 Then
              If Not officeapp Is Nothing Then
                OpenDBExclusive officeapp, curdoc, currentfname, False
              End If
#End If
            End If
          Else
            errTxt = ""
            ok = False
          End If
          resrs.Close
          Set resrs = Nothing
        Else
          errTxt = ""
          ok = False
        End If
    End If
    
    Dateifreigabe = ok
    Exit Function
nogo:
    On Error Resume Next
    If Not resrs Is Nothing Then
      If resrs.state <> 0 Then
'        resrs.Close
      End If
      Set resrs = Nothing
    End If

End Function

Sub ErstelleKopieDerDatei(ByVal Dateiname As String, ByVal dateiversion As Long, ByVal majorVersion As Long, ByVal minorVersion As Long, ByRef conn As ADODB.Connection)

    Dim paramrs As Object
    Set paramrs = GetParamRS(conn)   ' OpenRS("SELECT * FROM gParameter", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
    If paramrs Is Nothing Then
        Exit Sub
    End If
                
    Dim ZielpfadFreigabe As String
    Dim Zielformat As String
    Zielformat = ""
    ZielpfadFreigabe = IIf(IsNull(paramrs.Fields("ZielpfadFreigabe").value), "", paramrs.Fields("ZielpfadFreigabe").value)
    Zielformat = IIf(IsNull(paramrs.Fields("FreigabeDateinameFormat").value), "", paramrs.Fields("FreigabeDateinameFormat").value)
    
    paramrs.Close
    Set paramrs = Nothing
    
    If ZielpfadFreigabe <> "" Then
        Dim dateinameC As String

        dateinameC = Dateiname

        Dim Speicherdateiname As String
        Speicherdateiname = ZielpfadFreigabe

        MkFullDir Speicherdateiname

        If Right(Speicherdateiname, 1) <> "\" Then
            Speicherdateiname = Speicherdateiname & "\"
        End If
       
        Dim fname As String
        fname = GetFileName(dateinameC)
        Dim fext As String
        fext = GetFileExtension(dateinameC)
        Dim fpath As String
        fpath = GetFilePath(dateinameC)
        
        ' Extension muss auch noch weg
        If Right(UCase(fname), Len(fext)) = UCase(fext) Then
            fname = Left(fname, Len(fname) - Len(fext))
        End If

        Zielformat = Replace(Zielformat, "#NAME#", fname)
        Zielformat = Replace(Zielformat, "#DATUM#", Format$(Now, "yyyy-mm-dd"))
        Zielformat = Replace(Zielformat, "#MAJORVERSION#", CStr(majorVersion))
        Zielformat = Replace(Zielformat, "#MINORVERSION#", CStr(minorVersion))
        Zielformat = Replace(Zielformat, "#VERSION#", CStr(dateiversion))
        If Zielformat = "" Then
            Zielformat = fname & "." & fext
        Else
            Zielformat = Zielformat & "." & fext
        End If

        Speicherdateiname = Speicherdateiname & Zielformat

        If FileExists(Speicherdateiname) Then
            'If MsgBox("Achtung, die Datei '" & Speicherdateiname & "' existiert bereits. Soll die Datei |fffd|berschrieben werden?", vbQuestion + vbYesNo, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")") = vbYes Then
            If MsgBox(FMT1("THISADDIN_57", Speicherdateiname), vbQuestion + vbYesNo, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")") = vbYes Then
                MyKill Speicherdateiname
                If FileExists(Speicherdateiname) Then
                    'MsgBox "Achtung, die vorhandene Datei konnte nicht gel|fffd|scht werden", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                    MsgBox FMT0("THISADDIN_58"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                End If
            Else
                GoTo KeineKopie
                Exit Sub
            End If
        End If

On Error GoTo KeineKopie

        CopyFile Dateiname, Speicherdateiname
    
        ' MsgBox "Kopie der freigegebenen Datei erzeugt: " & Speicherdateiname, vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        Exit Sub
        
KeineKopie:
        'MsgBox "KEINE Kopie der freigegebenen Datei erzeugt, Datei '" & Speicherdateiname & "' existiert bereits!", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        MsgBox FMT1("THISADDIN_59", Speicherdateiname), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
    End If

End Sub

' alle Pflichtfelder m|fffd|ssen gef|fffd|llt sein, bevor eine Datei freigegeben werden kann
Function DokuPflichtfelderGefuellt(ByRef objScript As Object, ByRef rs As Object, ByRef conn As Object, ByVal vorFreigabe As Boolean, ByVal inFreigabe As Boolean) As Boolean

    Dim trs As Object
    Dim pflichtDokufelder As Long
    pflichtDokufelder = 0
    Dim feldnummer As String
    feldnummer = ""
    ' Ein script kann nun bestimmen ob ein Dokufeld sichtbar und ein Mussfeld ist.
    Dim script As String
    Dim mussfeld As Boolean
    
    Dim colScriptValues As New Collection
    PrepareScriptVars rs, colScriptValues, Nothing
    If IsNull(rs.Fields("SBSASSETID").value) = False Then
      PrepareScriptVarsSBSWithConnection conn, rs.Fields("SBSASSETID").value, "", colScriptValues
    End If
    
    Dim query As String
    query = "Select g.Feldnummer, g.Dokuname, g.Script, g.RisikowertVon, g.RisikowertBis, g.Mussfeld from gDokuFelder g WHERE g.deaktiviert = 0 "
    ' If rs.Fields("FreigabeStatus").value = 0 Then
    If IstDateiFreigabeStatus0oder3(rs) = True Then
        query = query & " and (g.VorFreigabe <> 0 or (g.VorFreigabe = 0 and g.InFreigabe = 0 and g.NachFreigabe = 0) ) "
    ' ElseIf rs.Fields("FreigabeStatus").value = 1 Then
    ElseIf IstDateiFreigabeStatusInitiiert(rs) = True Then
        query = query & " and g.InFreigabe <> 0 "
    End If
    
    Set trs = OpenRS(query, conn, ADODB.CursorTypeEnum.adOpenForwardOnly, ADODB.LockTypeEnum.adLockReadOnly)
    If Not trs Is Nothing Then
        While trs.EOF = False
            mussfeld = trs.Fields("Mussfeld").value <> 0
            Dim valid As Boolean
            Dim Risikowert As Double
            Dim von As Double
            Dim bis As Double
            Risikowert = GetSafeFieldPlus(rs, "Risikowert", 0#)
            von = GetSafeFieldPlus(trs, "RisikowertVon", 0#)
            bis = GetSafeFieldPlus(trs, "RisikowertBis", 0#)
            valid = von <= Risikowert And Risikowert <= bis
            ' Checken, ob es hier ein script gibt
            script = GetSafeField(trs, "Script")
            If script <> "" Then
                valid = DokufeldAnzeigenFromScript(objScript, trs.Fields("Dokuname").value, Nothing, -1, False, script, rs, mussfeld, colScriptValues)
            End If
            
            If valid And mussfeld Then
              pflichtDokufelder = pflichtDokufelder + 1
              If feldnummer <> "" Then
                  feldnummer = feldnummer & ","
              End If
              feldnummer = feldnummer & CStr(trs.Fields("feldnummer").value)
            End If
            trs.MoveNext
        Wend
        trs.Close
    End If
    Set trs = Nothing
    
    ' Ab hier ist alles gleich wie in der alten Funktion
    If pflichtDokufelder = 0 Then
        DokuPflichtfelderGefuellt = True
        Exit Function
    End If

    Dim dokuID As Long
    Dim locDateiID As Long
    Dim locVersion As Long
    Dim selitem As Long
    Dim oeitem As Long
    Dim VerantwortlicherAutor As String
    Dim FachlichVerantwortlicher As String

    GetFileDoku rs, conn, dokuID, locDateiID, locVersion, selitem, oeitem, VerantwortlicherAutor, FachlichVerantwortlicher
    
    DokuPflichtfelderGefuellt = False
    query = "select count(1) as cnt from idvDateienDokuTextfelder t inner join idvDateienDoku d on t.idvDateiDokuID = d.idvDateiDokuID where t.feldnummer in (" & feldnummer & ") And d.idvDateiDokuID = " & dokuID
    Set trs = OpenRS(query, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockOptimistic)
    If Not trs Is Nothing Then
        If trs.EOF = False Then
            If pflichtDokufelder = trs.Fields("cnt").value Then
                DokuPflichtfelderGefuellt = True
            End If
        End If
        trs.Close
    End If
    Set trs = Nothing

End Function

Sub DoFreigabe(checkertyp As String, ByRef officeapp As Object, ByRef curdoc As Object)

  On Error GoTo nogo

#If Project_ExcelTracker = 1 Then
  If curdoc.readOnly = True Then
    'MsgBox "Die Datei ist schreibgesch|fffd|tzt und kann deshalb aktuell nicht zur Freigabe initiiert werden.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
    MsgBox FMT0("THISADDIN_110"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
    Exit Sub
  End If
#End If

    If IsSharedWorkbook(curdoc) Then
        'MsgBox "Die Funktion kann nicht genutzt werden, da die Microsoft-Freigabe verwendet wurde (""Arbeitsmappe freigeben""). Bitte entfernen Sie die Freigabe, um die Funktion auszuf|fffd|hren."
        MsgBox FMT0("THISADDIN_27"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        Exit Sub
    End If

    Dim wurdeFreigegeben As Boolean
    wurdeFreigegeben = False
    Dim logtrack As Long
    logtrack = 0
    
    Dim conn As Object
    Set conn = GetConnection()
    
    logtrack = 1

    If conn Is Nothing Then
        'MsgBox "Diese Funktion ist zur Zeit nicht ausf|fffd|hrbar, da das System nicht zur Verf|fffd|gung steht. Bitte versuchen Sie es sp|fffd|ter noch einmal.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        MsgBox FMT0("DOKUPWD_3"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        Exit Sub
    End If

    logtrack = 2

    If Deaktiviert(conn) Then
        'MsgBox "Aktuell steht diese Funktion nicht zur Verf|fffd|gung, da das System deaktiviert wurde. Bitte versuchen Sie es sp|fffd|ter noch einmal.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        MsgBox FMT0("DOKUPWD_4"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        conn.Close
        Set conn = Nothing
        Exit Sub
    End If

    logtrack = 3

    If G_PARAM_LokaleDateienBer|fffd|cksichtigen = False And Left(GetUNCPath(curdoc.fullname), 2) <> "//" And Left(GetUNCPath(curdoc.fullname), 2) <> "\\" And InStr(curdoc.fullname, "://") <= 0 Then
      'MsgBox "Es k|fffd|nnen nur Excel-Dateien freigegeben werden, die auf einem Netzlaufwerk gespeichert wurden. Nutzen Sie Datei / Speichern unter, legen das Programm auf einem Netzwerkpfad ab und rufen diese Funktion erneut auf.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
      MsgBox FMT0("THISADDIN_40"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
      conn.Close
      Set conn = Nothing
      Exit Sub
    End If

    If DateiAusgeschlossen2(curdoc, conn) = True Then
        'MsgBox "Diese Funktion steht f|fffd|r diese Datei/f|fffd|r Dateien in diesem Verzeichnis nicht zur Verf|fffd|gung.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        MsgBox FMT0("BLATTSCHUTZ_2"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        conn.Close
        Set conn = Nothing
        Exit Sub
    End If
        
    logtrack = 4

    Dim rs As Object
    Dim curid As Long
    Dim hash As String

    ' Wenn Sie bereits gespeichert wurde...
    Dim wasLocked As Boolean
    If Not GetTargetRS(conn, GetUNCPath(curdoc.fullname), curdoc, rs, curid, hash, ADODB.LockTypeEnum.adLockPessimistic, wasLocked) Then
        logtrack = 5
        If wasLocked Then
          'MsgBox "Ein anderer User greift gerade auf die Daten der Datei zu, bitte versuchen Sie es sp|fffd|ter noch einmal.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
          MsgBox FMT0("BLATTSCHUTZ_3"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        Else
'          If (Left(GetCurrentDocUNCPathFromApp(officeapp), 1) = "\" Or Left(GetCurrentDocUNCPathFromApp(officeapp), 1) = "/" Or Mid(GetCurrentDocUNCPathFromApp(officeapp), 2, 1) = ":") And _
'            WBGetValueLong(officeapp, "_IDVTrackerID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix) > 0 Then
'            MsgBox "Aktuell kann keine Programmfreigabe initiiert werden, da die Datenbank oder der Datensatz gesperrt ist. Sollte dies l|fffd|nger der Fall sein informieren Sie bitte Ihre Administration.", vbInformation + vbSystemModal, ProgNameLong & " " & MyVersion & " (Build: " & app.Revision & ")"
'          Else
            'MsgBox "Bevor Sie die Programmfreigabe durchf|fffd|hren k|fffd|nnen, muss die Datei von Ihnen gespeichert werden.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
            MsgBox FMT0("THISADDIN_60"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
'          End If
        End If
        Set rs = Nothing
        conn.Close
        Set conn = Nothing
        Exit Sub
    Else
    
        If Not UserKannFreigeben(G_CfgFreigabeErteilen, rs) Then
          ' Sie sind nicht dazu berechtigt, diese Funktion auszuf|fffd|hren. Bitte wenden Sie sich an die Programmverantwortlichen.\n\n%1
          MsgBox FMT1("FREIGABE_1", GetVerantwortlicheUser(conn, rs, G_CfgFreigabeErteilen)), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
          rs.Close
          Set rs = Nothing
          conn.Close
          Set conn = Nothing
          Exit Sub
        End If
    
        If IstDateiFreigabeStatusDeaktiviert(rs) = True Then
            DebugPrint tinfo, "Dateifreigabe deaktiviert"
            
            DoNewVersionWhenDeaktiviert conn, officeapp, curdoc, rs
            
            rs.Close
            Set rs = Nothing
            conn.Close
            Set conn = Nothing
            
            Exit Sub
        End If

        If GetSafeFieldPlus(rs, "Risikowert", 0#) < G_cfgFreigabeAbRisiko Then
          'MsgBox "Eine Freigabe der Datei ist erst ab einem Risikowert von " & Format(G_cfgFreigabeAbRisiko * 100, "#;-#;0") & "% m|fffd|glich.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
          MsgBox FMT1("THISADDIN_42", Format(G_cfgFreigabeAbRisiko * 100, "#;-#;0")), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
          rs.Close
          Set rs = Nothing
          conn.Close
          Set conn = Nothing
          Exit Sub
        End If
        
        Dim freigebenderUser As String
        freigebenderUser = IIf(IsNull(rs.Fields("SpeichernderUserLogonID").value), "", rs.Fields("SpeichernderUserLogonID").value)
        
        Dim objScript As Object
        Dim cso As Object
        Set cso = New CScriptObject
        Set objScript = cso.GetObject
        'objScript.Language = "VBScript"
        ' objScript.AllowUI = False
        
        logtrack = 6
        ' ... Freigabe darf eventuell nur zentral gemacht werden
        If rs.Fields("Risikowert").value >= G_PARAM_ZentraleFreigabeAbRisikowert And G_PARAM_ZentraleFreigabeAbRisikowert >= 0 Then
            rs.Close
            Set rs = Nothing
            logtrack = 61
            'MsgBox "Achtung! Die Datei kann nur von zentraler Stelle freigegeben werden, bitte informieren Sie die daf|fffd|r verantwortliche Abteilung.", vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
            MsgBox FMT0("THISADDIN_61"), vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        ' ... noch nicht risikobefragt ist und Parameter aktiv
        ElseIf rs.Fields("Risikowert").value < 0 And G_PARAM_KeineFreigabeOhneRisikobefragung = True Then
            rs.Close
            Set rs = Nothing
            logtrack = 66
            'MsgBox "Achtung! Die Datei wurde noch nicht risikobefragt und kann daher nicht freigegeben werden.", vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
            MsgBox FMT0("THISADDIN_44"), vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        ' ... und sie sich nicht in der Freigabe befindet oder freigegeben wurde
        ElseIf rs.Fields("FreigabeStatus").value <= 0 And G_PARAM_VierAp = True Then
            rs.Close
            Set rs = Nothing
            logtrack = 7
'            MsgBox "Das Programm befindet sich bereits in der Freigabe oder wurde schon freigegeben!", vbInformation + vbSystemModal, ProgNameLong & " " & MyVersion & " (" & App.Major & "." & App.Minor & "."  & App.Revision & ")"
            'MsgBox "Achtung! Da das Vier-Augen-Prinzip f|fffd|r Freigaben aktiviert ist, muss die Freigabe erst von einer zweiten Person initiiert worden sein.", vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
            MsgBox FMT0("THISADDIN_62"), vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        ' ElseIf rs.Fields("FreigabeStatus").value >= 2 Then
        ElseIf IstDateiFreigabeStatusFreigegeben(rs) = True Then
            rs.Close
            Set rs = Nothing
            logtrack = 77
            'MsgBox "Die Programmfreigabe wurde bereits erteilt.", vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
            MsgBox FMT0("THISADDIN_63"), vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        ElseIf IstDateiFreigabeStatusDeaktiviert(rs) = True Then
            rs.Close
            Set rs = Nothing
            logtrack = 79
            MsgBox FMT0("THISADDIN_109"), vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        ElseIf G_PARAM_VierAp = True And UCase(GetUserName) = UCase(freigebenderUser) Then
            rs.Close
            Set rs = Nothing
            logtrack = 78
            'MsgBox "Achtung: Sie haben bereits die Freigabe initiiert. Da das Vier-Augen-Prinzip aktiv ist, muss die Freigabe durch eine zweite Person erfolgen.", vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")" & " - Programmfreigabe"
            MsgBox FMT0("THISADDIN_64"), vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")" & " - " & FMT0("THISADDIN_65")
        ElseIf GetSafeFieldPlus(rs, "Speicheranzahl", 0) <= 0 Then
            rs.Close
            Set rs = Nothing
            logtrack = 781
            'MsgBox "Bevor Sie die Programmfreigabe erteilen k|fffd|nnen, muss die Datei von Ihnen gespeichert werden.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
            MsgBox FMT0("THISADDIN_66"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        Else
            Dim fragenGeaendert As Long
            fragenGeaendert = SindFragenProzesseGeaendert(rs, conn)
            If fragenGeaendert > 0 Then
               rs.Close
               Set rs = Nothing
               logtrack = 783
               If fragenGeaendert = 1 Or fragenGeaendert = 3 Then
                  MsgBox FMT0("THISADDIN_101"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
               Else
                  MsgBox FMT0("THISADDIN_108"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
               End If
            ElseIf DokuPflichtfelderGefuellt(objScript, rs, conn, True, True) = False And rs.Fields("MinorVersion").value = 0 Then
                rs.Close
                Set rs = Nothing
                logtrack = 782
                'MsgBox "Nicht alle Pflichtfelder der Doku wurden bisher ausgef|fffd|llt.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                MsgBox FMT0("THISADDIN_67"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
            Else
            
                'If MsgBox("Sind Sie sicher, dass Sie die Freigabe durchf|fffd|hren m|fffd|chten?", vbYesNo + vbQuestion + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")") = vbYes Then
                If MsgBox(FMT0("THISADDIN_68"), vbYesNo + vbQuestion + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")") = vbYes Then
            
                   If ChecklisteOk(conn, GetSafeFieldPlus(rs, "Risikowert", 0), 2, GetSafeFieldPlus(rs, "MinorVersion", 0)) = True Then
    
                        logtrack = 8
                        If Not CheckForCurrentDoku(rs, conn) Then
                                'MsgBox "Derzeit kann nicht auf die Dokmumentation zugegriffen werden. Bitte versuchen Sie es sp|fffd|ter noch einmal.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                                MsgBox FMT0("THISADDIN_69"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                        Else
                                
                                Dim comm As String
                                comm = ""
                                If G_PARAM_KommentarBeiFreigabe = True Then
                                    'comm = InputBox("Freigabekommentar:", ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")")
                                    comm = InputBox(FMT0("THISADDIN_70"), ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")")
                                End If
                                
                                If G_PARAM_KommentarBeiFreigabe = True And comm = "" Then
                                  'MsgBox "Achtung: Sie haben keinen Freigabekommentar eingegeben, die Freigabe wird nicht durchgef|fffd|hrt.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")" & " - Programmfreigabe"
                                  MsgBox FMT0("THISADDIN_71"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")" & " - " & FMT0("THISADDIN_65")
                                  
                                Else
                                
                                    Dim ok As Boolean
                                    ok = True
                                    
                                      Dim fname As String
                                      fname = curdoc.fullname
                                      curdoc.Close False
                                      
                                      Dim idvDateiID As Long
                                      idvDateiID = GetSafeFieldPlus(rs, "idvDateiID", -1)
                                    
                                      ' das Problem ist hier, dass der REcordset offen ist und die Datei eventuell beim |fffd|ffnen neu gespeichert wird
                                      ' (Gibts leider in einer Anwendung). Also Recordset schie|fffd|en und danach neu |fffd|ffnen
                                      rs.Update
                                      rs.Close
                                      Set rs = Nothing
                                      
                                      SaveSetting appname:="Stromwerken", Section:=ProgNameLong, Key:="IgnoreThisOneWarning", Setting:="True"
                                      ExcelDateiOeffnenMitConn conn, officeapp, fname, curdoc, idvDateiID
                                      SaveSetting appname:="Stromwerken", Section:=ProgNameLong, Key:="IgnoreThisOneWarning", Setting:="False"
                                      If curdoc Is Nothing Then
                                        ok = False
                                        ' Die Datei konnte nicht neu geladen werden, der Vorgang wird abgebrochen.
                                        MsgBox FMT0("THISADDIN_96"), vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                                      ElseIf Not GetTargetRS(conn, GetUNCPath(fname), curdoc, rs, curid, hash, ADODB.LockTypeEnum.adLockPessimistic, wasLocked) Then
                                          'MsgBox "Ein anderer User greift gerade auf die Daten der Datei zu, bitte versuchen Sie es sp|fffd|ter noch einmal.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                                          MsgBox FMT0("BLATTSCHUTZ_3"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                                          Set rs = Nothing
                                          conn.Close
                                          Set conn = Nothing
                                          Set objScript = Nothing
                                          Set cso = Nothing
                                          Exit Sub
                                      End If
                                      
                                    If ok Then
                                      logtrack = 810
                                      ' Hier war die |fffd|berlegung zu pr|fffd|fen, ob bereits etwas eingecheckt ist. Wird aber nicht gemacht, es wird einfach |fffd|berschrieben.
                                      If (G_PARAM_DateienVersionierenAbRisikowert >= 0 And rs!Risikowert >= G_PARAM_DateienVersionierenAbRisikowert) Or G_PARAM_DateienEincheckenBeiProgrammfreigabe = True Then
                                        logtrack = 820
                                        ' der Checker checkt die Datei ein
                                        ok = True ' CheckInFile(curdoc.fullname, rs, officeapp, conn)
                                      Else
                                        If FMT0("THISADDIN_72") <> "" Then
                                        MsgBox FMT0("THISADDIN_72"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                                        End If
                                      End If
                                      logtrack = 830
                                    End If
                                        
                                    If ok Then
                                                                
                                          ' If rs.Fields("FreigabeStatus").value <> 1 Then
                                          If IstDateiFreigabeStatusInitiiert(rs) = False Then
                                            DoInternalSave rs, curdoc, conn
                                          End If
                              
                                          logtrack = 9
                              
                                          Dim sBetreff As String
                                          Dim sText As String
                              
                                          sBetreff = G_PARAM_SMTPFreigabeErteilenBetreff
                                          sText = G_PARAM_SMTPMailFreigabeErteilen
                                          logtrack = 10
                              
                                          ReplaceStuff curdoc, sBetreff, rs
                                          ReplaceStuff curdoc, sText, rs
                                          ReplaceStuffInitiator sBetreff, conn, GetUserName()
                                          ReplaceStuffInitiator sText, conn, GetUserName()
                                          
                                          logtrack = 11
                                          
                                          Dim Dateiname As String
                                          Dateiname = curdoc.fullname ' rs.Fields("Dateiname").Value
                                          Dim Version As Long
                                          Version = rs.Fields("Version").value
                                          Dim Risikowert As Double
                                          Risikowert = rs.Fields("Risikowert").value
                                          
                                          Dim majorVersion As Long
                                          Dim minorVersion As Long
                                          majorVersion = rs.Fields("MajorVersion").value
                                          minorVersion = rs.Fields("MinorVersion").value
                                          
                                          rs.Update
                                          rs.Close
                                          Set rs = Nothing
                                          
                                          Dim errTxt As String
                                          If Dateifreigabe(officeapp, curdoc, checkertyp, conn, curdoc.fullname, curid, Version, errTxt, comm, Risikowert) Then
                                            
                                            WBSetValueLong curdoc, "_IDVTrackerFreigabeStatus" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, 2
                                            WBSetValueLong curdoc, "_IDVTrackerFreigabeDateiID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, WBGetValueLong(curdoc, "_IDVTrackerID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix)
                                            WBSetValueLong curdoc, "_IDVTrackerFreigabeVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, WBGetValueLong(curdoc, "_IDVTrackerVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix)
                                            DoInternalSave Nothing, curdoc, conn
                                            
                                            ErstelleKopieDerDatei Dateiname, Version, majorVersion, minorVersion, conn
                                            
                                            If G_PARAM_SMTPMailVersandAktiv Then
                                              If UCase(freigebenderUser) <> GetUserNameUCASE() Then
                                                    Dim receiver As String
                                                    receiver = ADGetUserMailAddress(freigebenderUser)
                                                    If receiver = "" Then receiver = GetUserAddress(freigebenderUser, conn)
                                                    'receiver = InputBox("Freigabemail senden an:", ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")", receiver)
                                                    receiver = InputBox(FMT0("THISADDIN_73"), ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")", receiver)
                                                  
                                                    If Len(receiver) > 0 Then
                                                        
                                                        SendSMTPMail _
                                                                conn, _
                                                                G_PARAM_StoreMailsToTable, _
                                                                G_PARAM_SMTPSender, _
                                                                receiver, _
                                                                "", _
                                                                G_PARAM_SMTPServer, _
                                                                sBetreff, _
                                                                sText, "Freigabe erteilt", ""
                                                    End If
                                              End If
                                            End If
                                            
                                            ' 15.01.2015 Mailevents testen
                                            Set rs = OpenRS("select * from idvDateien WHERE idvDateiID = " & curid, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
                                            If Not rs Is Nothing Then
                                                If rs.EOF = False Then
                                                    CheckMailEvent curdoc, ME_FreigabeErteilt, rs, conn
                                                End If
                                                rs.Close
                                                Set rs = Nothing
                                            End If
                                            
                                            DebugPrint tSystem, "Freigabe erteilt", 0, 0, curid
                                            wurdeFreigegeben = True
                                          Else
                                            'MsgBox "Die Freigabe war nicht erfolgreich." & IIf(errTxt <> "", " (" & errTxt & ")", "") & IIf(GetSetting(appname:="Stromwerken", Section:=checkertyp, Key:="ProcResult", Default:="") <> "", vbCrLf & vbCrLf & GetSetting(appname:="Stromwerken", Section:=checkertyp, Key:="ProcResult", Default:=""), ""), vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                                            MsgBox FMT2("THISADDIN_74", IIf(errTxt <> "", " (" & errTxt & ")", ""), IIf(GetSetting(appname:="Stromwerken", Section:=checkertyp, Key:="ProcResult", Default:="") <> "", vbCrLf & vbCrLf & GetSetting(appname:="Stromwerken", Section:=checkertyp, Key:="ProcResult", Default:=""), "")), vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                                            SaveSetting appname:="Stromwerken", Section:="ExcelTracker", Key:="IgnoreThisOne", Setting:="False"
                                          End If
                                    End If
                                End If
                        End If
                    End If
                    logtrack = 23
                End If
            End If
        End If
        Set objScript = Nothing
        Set cso = Nothing
    End If
    logtrack = 25
    If Not rs Is Nothing Then
        ' da hinter jedem rs.Close ein Set rs = nothing steht, m|fffd|ssten wir hier Close aufrufen d|fffd|rfen
        rs.Close
        Set rs = Nothing
    End If
    
    SetzeAmpelStatus curdoc, conn
    
    conn.Close
    Set conn = Nothing
    
    If wurdeFreigegeben Then
      'MsgBox "Die Freigabe war erfolgreich, die Datei wird geschlossen.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
      MsgBox FMT0("THISADDIN_75"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
#If PROJECT_ACCESSTRACKER = 1 Then
      Dim accapp
      Set accapp = curdoc.Application
      accapp.CloseCurrentDatabase
#Else
      curdoc.Close
#End If
    End If
    Exit Sub
nogo:

    Dim errres As String
    errres = "Trackpos: " & logtrack & " - Err: " & err.Number & " - " & err.Description & " - " & err.Source
    DebugPrint DebType.tERROR, "DoFreigabe:" & errres
    'MsgBox "Die Freigabe konnte nicht durchgef|fffd|hrt werden, da ein anderer Prozess auf die Datei zugreift. Bitte versuchen Sie es sp|fffd|ter noch einmal.", vbInformation, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
    'MsgBox "Die Freigabe konnte nicht durchgef|fffd|hrt werden, es sind Fehler aufgetreten. Bitte versuchen Sie es sp|fffd|ter noch einmal.", vbInformation, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
    MsgBox FMT1("THISADDIN_55", errres), vbInformation, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
    
    Set rs = Nothing
    If Not conn Is Nothing Then
      conn.Close
      Set conn = Nothing
    End If
End Sub


Function CheckInFile(filename As String, ByRef rs As Object, ByRef officeapp As Object, ByRef conn As Object) As Boolean

On Error GoTo nogo

  Dim logtrack As Long
  logtrack = 0

  CheckInFile = False
  
  If Len(GetStorePath(tTemp)) > 0 Then
      logtrack = 1
      
      'erst mal alte killen falls vorhanden
      If FileExists(GetStorePath(tTemp) & rs.Fields("Hash").value) Then
          logtrack = 2
          MyKill GetStorePath(tTemp) & rs.Fields("Hash").value
          logtrack = 3
          If FileExists(GetStorePath(tTemp) & rs.Fields("Hash").value) Then
            logtrack = 4
            DebugPrint DebType.tERROR, "Tempor|fffd|re Datei f|fffd|r '" & filename & "' nicht gel|fffd|scht(1)"
            'MsgBox "FEHLER: Die tempor|fffd|re Datei '" & GetStorePath(tTemp) & rs.Fields("Hash").value & "' konnte nicht gel|fffd|scht werden. Bitte informieren Sie Ihre Administration!", vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
            MsgBox FMT1("THISADDIN_76", GetStorePath(tTemp) & rs.Fields("Hash").value), vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
            Exit Function
          End If
          logtrack = 5
      End If
      
      logtrack = 6
      If Not PathExists(GetStorePath(tTemp)) Then
        DebugPrint DebType.tERROR, "CheckInFile: TempPathMissing '" & filename & "'"
        Exit Function
      End If
      
#If PROJECT_ACCESSTRACKER = 1 Then
      Dim fname As String
      Dim taccapp
      Dim isOpenedExclusively As Boolean
      If Not officeapp Is Nothing Then
        isOpenedExclusively = DateiExklusivGe|fffd|ffnet(filename)
        If isOpenedExclusively Then
'          MsgBox "ACHTUNG: Die Datenbank wird jetzt kurz geschlossen und dann wieder im nicht-exklusiven-Modus ge|fffd|ffnet!", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
          fname = officeapp.CurrentProject.fullname
          Set taccapp = officeapp
          taccapp.CloseCurrentDatabase
          Set taccapp = Nothing
        End If
      End If
#End If
      
      CopyFile filename, GetStorePath(tTemp) & rs.Fields("Hash").value
      
#If PROJECT_ACCESSTRACKER = 1 Then
      Dim curdoc As Object
      If Not officeapp Is Nothing Then
        If isOpenedExclusively Then
          OpenDBExclusive officeapp, curdoc, fname, False
        End If
      End If
#End If
      
      logtrack = 7

      If FileExists(GetStorePath(tTemp) & rs.Fields("Hash").value) Then
          logtrack = 8
          Dim errstr As String
          If Not xlCheckInBinary(conn, rs.Fields("idvDateiID").value, rs.Fields("Version").value, rs.Fields("Speicherdatum").value, GetStorePath(tTemp) & rs.Fields("Hash").value, errstr) Then
            DebugPrint DebType.tdebug, "Die Datei '" & filename & "' konnte nicht eingecheckt werden"
            'MsgBox "Die Datei konnte nicht auf dem Datenbankserver abgelegt werden! Bitte versuchen Sie es sp|fffd|ter noch einmal!" & vbCrLf & vbCrLf & "Hinweis: " & errstr, vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
            MsgBox FMT1("THISADDIN_77", errstr), vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
            CheckInFile = False
          Else
            DebugPrint DebType.tdebug, "Die Datei '" & filename & "' wurde eingecheckt"
            CheckInFile = True
          End If
          logtrack = 9
          MyKill GetStorePath(tTemp) & rs.Fields("Hash").value
          
          If FileExists(GetStorePath(tTemp) & rs.Fields("Hash").value) Then
            DebugPrint DebType.tdebug, "Tempor|fffd|re Datei f|fffd|r '" & filename & "' nicht gel|fffd|scht(2)"
            'MsgBox "FEHLER: Die tempor|fffd|re Datei '" & GetStorePath(tTemp) & rs.Fields("Hash").value & "' konnte nicht gel|fffd|scht werden. Bitte informieren Sie Ihre Administration!", vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
            MsgBox FMT1("THISADDIN_76", GetStorePath(tTemp) & rs.Fields("Hash").value), vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
          End If

          logtrack = 19
          Exit Function
      Else
        DebugPrint DebType.tERROR, "CheckInFile Fehler: Dateiname zu lang (" & logtrack & "): " & filename
        'MsgBox "FEHLER: Die Datei konnte nicht in den tempor|fffd|ren Pfad kopiert werden! " & IIf(ShortFileName(fileName) = "", "(Pfad + Dateiname zu lang) ", "") & "Die Datei kann nicht eingecheckt werden! Bitte speichern Sie die Datei in einem nicht so langen Pfad + Dateinamen.", vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        MsgBox FMT1("THISADDIN_78", IIf(ShortFileName(filename) = "", FMT0("THISADDIN_79"), "")), vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
      End If
  Else
    DebugPrint DebType.tERROR, "CheckInFile: No checkin (" & logtrack & "): " & filename
    'MsgBox "FEHLER: Es ist kein tempor|fffd|rer Pfad konfiguriert! Die Datei kann nicht auf dem Datenbankserver abgelegt werden! Bitte informieren Sie die Administration!", vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
    MsgBox FMT0("THISADDIN_80"), vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
  End If
  
  Exit Function
nogo:
  DebugPrint DebType.tERROR, "CheckInFile:" & logtrack
  'MsgBox "FEHLER: Die Datei '" & fileName & "' kann nicht eingecheckt werden!" & err.Number & " - " & err.Description & " - " & err.Source, vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
  MsgBox FMT4("THISADDIN_81", filename, err.Number, err.Description, err.Source), vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
End Function

Sub FreigabeAbbrechen(ByRef rs As Object, ByRef officeapp As Object, ByRef curdoc As Object, ByRef conn As Object, versionErhoehen As Boolean, ByVal giveInfo As Boolean, ByVal showMessageBox As Boolean)

    Dim sBetreff As String
    Dim sText As String
    
    If giveInfo Then
      sBetreff = G_PARAM_SMTPFreigabeAbbruchBetreff
      sText = G_PARAM_SMTPMailFreigabeAbbruch
  
      ReplaceStuff curdoc, sBetreff, rs
      ReplaceStuff curdoc, sText, rs
      ReplaceStuffInitiator sBetreff, conn, GetUserName()
      ReplaceStuffInitiator sText, conn, GetUserName()
  
      InformAdmins G_PARAM_StoreMailsToTable, conn, sBetreff, sText, "Freigabeabbruch ID " & rs.Fields("idvDateiID").value, "", ""
    End If
    
    If versionErhoehen Then
      ' hier durch wird rs auf den neuen Recordset ge|fffd|ndert
      CreateNewRecordset GetUNCPathFromDoc(curdoc), curdoc.fullname, curdoc, rs, conn
      
      ' DateiID und Version haben sich ge|fffd|ndert
      WBSetValueLong curdoc, "_IDVTrackerID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, rs.Fields("idvDateiID").value
      WBSetValueLong curdoc, "_IDVTrackerVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, rs.Fields("Version").value
  
      MajorVersionErhoehen rs
      WBSetValueLong curdoc, "_IDVTrackerMajorVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, rs.Fields("MajorVersion").value
      WBSetValueLong curdoc, "_IDVTrackerMinorVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, rs.Fields("MinorVersion").value
    End If
    rs.Fields("FreigabeStatus").value = 0
    rs.Fields("FreigabeidvDateiID").value = 0
    rs.Fields("FreigabeVersion").value = 0
    rs.Fields("FreigabeChecksumme").value = ""
    
    rs.Fields("FreigabeInitiierung").value = Empty
    rs.Fields("FreigabeInitUserLogonID").value = ""
    WBSetValueLong curdoc, "_IDVTrackerFreigabeStatus" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, 0
    WBSetValueLong curdoc, "_IDVTrackerFreigabeDateiID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, -1
    WBSetValueLong curdoc, "_IDVTrackerFreigabeVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, -1

    If G_cfgAutoProtectBeiInit > 0 Then
      BlattschutzEntfernen conn, rs, officeapp, curdoc, False
    End If

    DoInternalSave rs, curdoc, conn
    LogSpeichern rs, curdoc, conn

    rs.Update
    
    ' 15.01.2015 Mailevents testen
    CheckMailEvent curdoc, ME_FreigabeAbgebrochen, rs, conn
    
    'MsgBox "Die Programmfreigabe wurde abgebrochen" & IIf(G_PARAM_SMTPMailVersandAktiv, " und die Administration informiert", "") & ".", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
    If showMessageBox Then
      MsgBox FMT1("THISADDIN_82", IIf(G_PARAM_SMTPMailVersandAktiv, FMT0("THISADDIN_83"), "")), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
    End If

End Sub

Public Sub AktuelleVersionErhoehen(ByRef conn As Object, ByRef rs As Recordset)

    ' MaxVersion bestimmt die neue Versionsnummer, wenn es denn schon gesetzt ist
    If Not IsNull(rs.Fields("MaxVersion").value) Then
        If rs.Fields("Version").value > rs.Fields("MaxVersion").value Then
            rs.Fields("Version").value = rs.Fields("Version").value + 1
            rs.Fields("MaxVersion").value = rs.Fields("Version").value
        Else
            rs.Fields("Version").value = rs.Fields("MaxVersion").value + 1
            rs.Fields("MaxVersion").value = rs.Fields("Version").value
        End If
    Else
        ' h|fffd|chste Doku und Freigabeversion suchen
        ' wenn die h|fffd|her ist, als die aktuelle Version, dann wird das unsere aktuelle MaxVersion
        Dim maxV As Long
        maxV = GetMaxVersion(conn, rs.Fields("idvDateiID").value)
        If maxV > rs.Fields("Version").value Then
            rs.Fields("MaxVersion").value = maxV
        Else
            rs.Fields("MaxVersion").value = rs.Fields("Version").value
        End If
        rs.Fields("Version").value = rs.Fields("MaxVersion").value + 1
        rs.Fields("MaxVersion").value = rs.Fields("Version").value
    End If

End Sub

Public Sub MajorVersionErhoehen(ByRef rs As Recordset)

    ' wenn noch nie was gesetzt war, dann nehmen wir die aktuelle Version als MajorVersion
    If Not IsNull(rs.Fields("MajorVersion").value) Then
        rs.Fields("MajorVersion").value = rs.Fields("MajorVersion").value + 1
    Else
        rs.Fields("MajorVersion").value = rs.Fields("Version").value
    End If
    ' Minor muss in dem Fall dann immer 0 werden
    rs.Fields("MinorVersion").value = 0

End Sub

Private Function GetMaxVersion(ByRef conn As Object, ByVal idvDateiID As Long) As Long

    GetMaxVersion = -1
    
On Error GoTo nogo:
    Dim rs As Object
    Set rs = OpenRS("select max(Version) as V from idvDateienFreigaben WHERE idvDateiID = " & idvDateiID, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockOptimistic)
    If Not rs Is Nothing Then
        If rs.EOF Then
            GetMaxVersion = rs.Fields("v").value
        End If
        rs.Close
    End If
    Set rs = Nothing
    
    Set rs = OpenRS("select max(Version) as V from idvDateienDoku WHERE idvDateiID = " & idvDateiID, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockOptimistic)
    If Not rs Is Nothing Then
        If rs.EOF Then
            If rs.Fields("V").value > GetMaxVersion Then
                GetMaxVersion = rs.Fields("version").value
            End If
        End If
        rs.Close
    End If
    Set rs = Nothing
nogo:

End Function


Private Function GetFreigabeStatusText(stat As Long) As String
  If stat = 1 Then
    'GetFreigabeStatusText = "Das Programm befindet sich aktuell im Freigabeprozess."
    GetFreigabeStatusText = FMT0("THISADDIN_84")
  ElseIf stat = 2 Then
    'GetFreigabeStatusText = "Das Programm wurde bereits freigegeben."
    GetFreigabeStatusText = FMT0("THISADDIN_85")
  Else
    'GetFreigabeStatusText = "Das Programm befindet sich aktuell im Freigabeprozess oder wurde bereits freigegeben."
    GetFreigabeStatusText = FMT0("THISADDIN_86")
  End If
    
End Function


Function GetMyOE(ByRef conn As Object) As String
  Dim oekz As String
  GetMyOE = GetUserOEIDandOEKennzeichen(GetUserName, conn, oekz)
End Function

Function GetCurrentUserOEID(ByRef conn As Object) As Long
    GetCurrentUserOEID = GetUserOEID(GetUserName, conn)
End Function

Function GetUserOEID(username As String, ByRef conn As Object) As Long
  Dim oekz As String
  GetUserOEID = GetUserOEIDandOEKennzeichen(username, conn, oekz)
End Function

Function GetUserOEIDandOEKennzeichen(username As String, ByRef conn As Object, ByRef oekz As String) As Long
    If G_MyOEGelesen = True And UCase(username) = UCase(GetUserName) Then
      GetUserOEIDandOEKennzeichen = G_MyOEID
      oekz = G_MyOE
      Exit Function
    End If
    
    GetUserOEIDandOEKennzeichen = 0
    Dim trs As Object
    
    If G_PARAM_OEAusADGruppeLesen Then
      Dim s As String
      s = GetUserGroups(username)
      If s <> "" Then
        Set trs = OpenRS("SELECT OEID, OEKennzeichen FROM gOEAktuell WHERE ADGruppe in(" & s & ") or ADGruppe2 in(" & s & ") or ADGruppe3 in(" & s & ")", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
        If Not trs Is Nothing Then
            If Not trs.EOF Then
              ' Nur wenn das mein User ist!
              If UCase(username) = UCase(GetUserName) Then
                G_MyOEID = trs.Fields("OEID").value
                G_MyOE = GetSafeField(trs, "OEKennzeichen")
                GetUserOEIDandOEKennzeichen = G_MyOEID
                oekz = G_MyOE
                G_MyOEGelesen = True
              Else
                GetUserOEIDandOEKennzeichen = trs.Fields("OEID").value
                oekz = GetSafeField(trs, "OEKennzeichen")
              End If
            End If
            trs.Close
            Set trs = Nothing
        End If
      End If
    Else
      Set trs = OpenRS("SELECT * FROM gWindowsUserAktuell WHERE LogonID='" & UCase(username) & "'", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
      Dim id As Long
      id = 0
      If Not trs Is Nothing Then
          If Not trs.EOF Then
              If Not IsNull(trs.Fields("OEID").value) Then
                ' Nur wenn das mein User ist!
                If UCase(username) = UCase(GetUserName) Then
                  G_MyOEID = trs.Fields("OEID").value
                  id = G_MyOEID
                  G_MyOEGelesen = True
                Else
                  id = trs.Fields("OEID").value
                End If
              End If
          End If
          trs.Close
          Set trs = Nothing
      End If
      
      Set trs = OpenRS("SELECT OEKennzeichen FROM gOEAktuell WHERE OEID = " & id, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
      If Not trs Is Nothing Then
          If Not trs.EOF Then
            G_MyOE = GetSafeField(trs, "OEKennzeichen")
            oekz = G_MyOE
            G_MyOEGelesen = True
          Else
            oekz = GetSafeField(trs, "OEKennzeichen")
          End If
          trs.Close
          Set trs = Nothing
      End If
      GetUserOEIDandOEKennzeichen = id
    End If
End Function

' XLAM

Function GetOEHierarchy(ByRef conn As Object, ByRef res As String) As Collection
On Error GoTo nogo
    Set GetOEHierarchy = Nothing
    Dim oes As New Collection

    Dim rs As Object
    Set rs = CreateObject("ADODB.Recordset")

    Set rs = OpenRS("SELECT gOEStrukturAktuell.UebergeordneteOEID, gOEStrukturAktuell.UntergeordneteOEID, gOE.OEKennzeichen AS |fffd|OEKennzeichen, gOE1.OEKennzeichen AS UOEKennzeichen FROM (gOE INNER JOIN gOEStrukturAktuell ON gOE.OEID = gOEStrukturAktuell.UebergeordneteOEID) INNER JOIN gOE gOE1 ON gOEStrukturAktuell.UntergeordneteOEID = gOE1.OEID", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockOptimistic)
    If rs Is Nothing Then
      Exit Function
    End If
  
    If rs.EOF Then
      rs.Close
      Set rs = Nothing
      Exit Function
    End If

    Dim oestr As OEStruct
    Dim oestrkid As OEStruct

    Do While Not rs.EOF
        
        ' Bin ich schon drin????
        If CollectionObjectExists(oes, "s" & GetSafeField(rs, "UebergeordneteOEID")) Then
            Set oestr = oes("s" & GetSafeField(rs, "UebergeordneteOEID"))
        Else
            Set oestr = New OEStruct
            oestr.m_Kuerzel = GetSafeField(rs, "|fffd|oekennzeichen")
            oestr.m_OEID = GetSafeField(rs, "UebergeordneteOEID")
            oes.add oestr, "s" & GetSafeField(rs, "UebergeordneteOEID")
        End If

        ' Und jetzt meine Kinder!!!! Aber nur, wenn die Kinder noch keinen Parent haben
        If CollectionObjectExists(oes, "s" & GetSafeField(rs, "untergeordneteoeid")) Then
            Set oestrkid = oes("s" & GetSafeField(rs, "untergeordneteoeid"))
        Else
            Set oestrkid = New OEStruct
            oestrkid.m_Kuerzel = GetSafeField(rs, "uoekennzeichen")
            oestrkid.m_OEID = GetSafeField(rs, "untergeordneteoeid")
            oes.add oestrkid, "s" & GetSafeField(rs, "untergeordneteoeid")
        End If

        If oestrkid.m_Parent = "" Then
            oestrkid.m_Parent = oestr.m_Kuerzel
            oestr.m_Subs.add oestrkid
        Else
            'res = res & "Die OE " & oestrkid.m_Kuerzel & " wurde bereits der OE " & oestrkid.m_Parent & " untergeordnet und kann deshalb nicht auch noch (oder erneut) der OE " & oestr.m_Kuerzel & " zugewiesen werden."
            res = res & FMT3("THISADDIN_93", oestrkid.m_Kuerzel, oestrkid.m_Parent, oestr.m_Kuerzel)
        End If

        rs.MoveNext
    Loop
    
    
    rs.Close
    Set rs = Nothing
    
    
    ' Und jetzt kommen noch alle rein, die nich nicht enthalten sind
    Set rs = OpenRS("Select * from gOEAktuell", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockOptimistic)
    If rs Is Nothing Then
      Exit Function
    End If
  
    If rs.EOF Then
      rs.Close
      Set rs = Nothing
      Exit Function
    End If
    
    Do While Not rs.EOF

        ' Bin ich schon drin????
        If Not CollectionObjectExists(oes, "s" & GetSafeField(rs, "OEID")) Then
            Set oestr = New OEStruct
            oestr.m_Kuerzel = GetSafeField(rs, "OEKennzeichen")
            oestr.m_OEID = GetSafeField(rs, "OEID")
            oes.add oestr, "s" & GetSafeField(rs, "OEID")
        End If

        rs.MoveNext
    Loop

    rs.Close
    Set rs = Nothing

    Set GetOEHierarchy = oes
    Exit Function
    
nogo:

End Function


Private Function FindMyOE(ByRef oes As Collection, ByVal myOE As Long) As OEStruct
    Dim toes As OEStruct
    For Each toes In oes
        Dim roes As OEStruct
        Set roes = toes.FindMyOE(myOE)
        If Not roes Is Nothing Then
            Set FindMyOE = roes
            Exit Function
        End If
    Next toes
    Set FindMyOE = Nothing

End Function


Sub CreateMyOEHierarch(ByRef conn As Object)
On Error GoTo nogo
    If G_MeineOEsGelesen = True Then Exit Sub

    G_MeineOEsGelesen = True
    
    G_MeineOEs = ""
    G_MeineOEsVertretung = ""
    
    ' Erst mal meine OE ermitteln!
    Dim myOE As Long

    myOE = GetCurrentUserOEID(conn)
    
    If myOE = 0 Then Exit Sub

    Dim res As String
    Dim oes As New Collection

    Set oes = GetOEHierarchy(conn, res)

    Dim toes As OEStruct
    Set toes = Nothing

    If myOE <> 0 And Not oes Is Nothing Then
      Set toes = FindMyOE(oes, myOE)
    End If

    ' Ok, jetzt alle OEs meiner Kinder rein
    If Not toes Is Nothing Then
       G_MeineOEs = toes.PrintMyOEs
    End If

    ' Und noch meine Vertretungen mit rein
    If Not oes Is Nothing Then
        
        Dim rs As Object
        Set rs = CreateObject("ADODB.Recordset")
    
        Set rs = OpenRS("SELECT * FROM gWindowsUserVertretungAktuell WHERE WirdVertretenVonLogonID = '" & GetUserNameUCASE & "'", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockOptimistic)
        If Not rs Is Nothing Then
          Do While Not rs.EOF
            Set toes = Nothing
            If GetSafeField(rs, "logonid") <> "" Then
                myOE = GetUserOEID(GetSafeField(rs, "logonid"), conn)
                Set toes = FindMyOE(oes, myOE)
                If Not toes Is Nothing Then
                    Dim ts As String
                    ts = toes.PrintMyOEs()
                    If ts <> "" Then
                      If G_MeineOEsVertretung <> "" Then
                        G_MeineOEsVertretung = G_MeineOEsVertretung & ","
                      End If
                      G_MeineOEsVertretung = G_MeineOEsVertretung & ts
                    End If
                End If
            End If
            rs.MoveNext
          Loop
          rs.Close
          Set rs = Nothing
        End If
        
    End If

    Set toes = Nothing
    Set oes = Nothing
    Exit Sub
nogo:
End Sub


Sub GetCfg(ByVal txt As String)
    Dim cfg As New CfgReader
    Dim s As String
    cfg.GetCFGString txt
    s = cfg.GetValue("OEHIERARCHIE")
    If IsYes(s) Then
      G_OEHierarchie = True
    Else
      G_OEHierarchie = False
    End If

    G_Freigabeordner = cfg.GetValue("FREIGABEORDNER")
    G_PDFDruckordner = cfg.GetValue("PDFDRUCKORDNER")

    Set cfg = Nothing
End Sub


Sub GetMySettings(ByRef conn As Object)

    On Error GoTo nogo
    Dim errHint As String
    errHint = "GetMyOE"
    
    Dim myOE As String
    myOE = GetMyOE(conn)

    errHint = "Open SecConfig"

    ' Erst mal INSTITUTE holen
    DebugPrint tdebug, "GetMySettings.1"
    
    Dim rs As Object
    Set rs = OpenRS("SELECT * FROM SecConfig WHERE SecConfigName = 'INSTITUTE' or SecConfigName = 'INSTITUT'", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockOptimistic)
    If Not rs Is Nothing Then
      If Not rs.EOF Then
        GetCfg GetSafeField(rs, "SecConfigInhalt")
      End If
      rs.Close
    End If

    errHint = "Open SecObjectConfig"
    DebugPrint tdebug, "GetMySettings.2"

'    Set rs = OpenRS("SELECT * FROM SecConfig WHERE SecConfigName = 'INSTITUTE' or SecConfigName = 'INSTITUT'", conn, adodb.CursorTypeEnum.adOpenDynamic, adodb.LockTypeEnum.adLockOptimistic)
'    If Not rs Is Nothing Then
'      Do While Not rs.EOF
    
    
    ' Und jetzt die OE-Parameter meiner OE holen!
    Set rs = OpenRS("SELECT SecConfigInhalt FROM SecObjectConfig INNER JOIN SecConfig ON SecObjectConfig.SecConfigID = SecConfig.SecConfigID WHERE Objektname = '" & myOE & "' AND Objekttyp=3", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockOptimistic)
    If Not rs Is Nothing Then
      If Not rs.EOF Then
        GetCfg GetSafeField(rs, "SecConfigInhalt")
      End If
      rs.Close
    End If

    DebugPrint tdebug, "GetMySettings.3"
    errHint = "Open SecObjectJoin"

    ' meine Gruppen im AD suchen
'    If sec.G_SecurityAD Then

'      Dim meineGruppen As String = ActiveDirectory.AD_HoleUserProfile(GetUserName)

      ' Und die Profil-Parameter meiner Profile holen!
'      dt = DBStuff.GetTable("SELECT SecConfigInhalt FROM ((SecObjectConfig INNER JOIN SecConfig ON SecObjectConfig.SecConfigID = SecConfig.SecConfigID) INNER JOIN SecProfile ON SecObjectConfig.Objektname = SecProfile.SecProfile) WHERE (SecObjectConfig.Objekttyp = 2) and SecProfile.SecProfile in (" & meineGruppen & ") ORDER BY SecProfile.SecProfilnummer")
      'rs = CurrentDb.OpenRecordset("SELECT SecConfigInhalt FROM (((SecObjectConfig INNER JOIN SecConfig ON SecObjectConfig.SecConfigID = SecConfig.SecConfigID) INNER JOIN SecProfile ON SecObjectConfig.Objektname = SecProfile.SecProfile) INNER JOIN SecUserProfile ON SecProfile.SecProfileID = SecUserProfile.SecProfile) INNER JOIN SecUser ON SecUserProfile.SecUser = SecUser.SecUserID WHERE (((SecObjectConfig.Objekttyp) = 2) And ((SecUser.WindowsUserID) = '" & GetUserName() & "')) ORDER BY SecProfile.SecProfilnummer", RecordsetTypeEnum.dbOpenSnapshot, RecordsetOptionEnum.dbSeeChanges)
'      If Not dt Is Nothing Then
'        For Each dr As DataRow In dt.Rows
'          GetCfg dr.item("SecConfigInhalt").ToString()
'        Next
'      End If

      ' Und noch mal nach den OEs pr|fc|fen, falls diese an sind. Dort werden dann
      If G_PARAM_OEAusADGruppeLesen Then
        Dim meineGruppen As String
        meineGruppen = GetUserGroups(GetUserName)
        
        If meineGruppen <> "" Then
          Set rs = OpenRS("SELECT * FROM SecConfig WHERE SecConfigName in (" & meineGruppen & ")", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockOptimistic)
          If Not rs Is Nothing Then
            Do While Not rs.EOF
              GetCfg GetSafeField(rs, "SecConfigInhalt")
              rs.MoveNext
            Loop
            rs.Close
          End If
        End If
      End If

'    End If

    DebugPrint tdebug, "GetMySettings.4"

    errHint = "Open SecObjectConfig"
    ' Und zum Schluss noch ne Config, die eventuell an mir haengt!!!
    Set rs = OpenRS("SELECT SecConfigInhalt FROM SecObjectConfig INNER JOIN SecConfig ON SecObjectConfig.SecConfigID = SecConfig.SecConfigID WHERE Objektname = '" & GetUserNameUCASE() & "' AND Objekttyp=1", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockOptimistic)
    If Not rs Is Nothing Then
      Do While Not rs.EOF
        GetCfg GetSafeField(rs, "SecConfigInhalt")
        rs.MoveNext
      Loop
      rs.Close
    End If
    
    Set rs = Nothing

    Exit Sub
nogo:

    DebugPrint tERROR, "GetMySettings." & errHint & ": " & err.Number & "-" & err.Description

End Sub


' XLAM


Public Function BeforePrint(ByRef officeapp As Object, ByRef curdoc As Object) As Boolean
    BeforePrint = True
    
    Dim conn As Object
    Set conn = GetConnection()

    If conn Is Nothing Then
        Exit Function
    End If

    If Not Verf|fffd|gbar(conn) Then
        conn.Close
        Set conn = Nothing
        DebugPrint tdebug, "BeforePrint NichtVerf|fffd|gbar"
        Exit Function
    End If
       
    ' ----------------------------
    ' Veraltete Programmversion???
    ' ----------------------------
    
    Dim FreigabeStatus As Long
    FreigabeStatus = WBGetValueLong(officeapp, "_IDVTrackerFreigabeStatus" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix)
    If FreigabeStatus = 2 Then
        ' ---------------------------------------------------------------
        ' wenn keine "alten" Versionen einer Freigabe erlaubt sind, wird (erst mal) eine Warnmeldung ausgegeben
        ' ---------------------------------------------------------------
        ' ACHTUNG: ERST NUTZEN, WENN AUCH DIE VERSION MIT KOPIERT WIRD!!!! (also z.B. Datei A Version 5 wird auf B kopiert, dann muss B auch die Version 5 haben. Version 1-4 von B gab es nie)
        If G_PARAM_FreigabenAusVorversionDeaktivieren = True Then
          Dim filePath As String
          Dim aktVersion As Long
          If Not AktuellsteFreigabeVersion(conn, _
                WBGetValueLong(officeapp, "_IDVTrackerFreigabeDateiID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix), _
                WBGetValueLong(officeapp, "_IDVTrackerFreigabeVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix), _
                filePath, aktVersion) Then
                
                #If PROJECT_ACCESSTRACKER <> 0 Or PROJECT_FILETRACKER <> 0 Then
                #Else
                  ShowVeralteteVersion curdoc
                #End If
          End If
        End If
    End If
    
    ' ----------------------------
    ' Header / Footer Texte?
    ' ----------------------------
    
#If PROJECT_ACCESSTRACKER = 0 Then

    Dim tSaved As Boolean
    tSaved = curdoc.saved
    
    Dim hl As String
    Dim hc As String
    Dim hr As String
    Dim fl As String
    Dim fc As String
    Dim fr As String
    
    If Len(G_cfgNoHeaderFooter) > 0 And UCase(Right(GetFileName(curdoc.fullname), Len(G_cfgNoHeaderFooter))) = UCase(G_cfgNoHeaderFooter) Then
    Else
        ' Wenn es eine freigegebene und irgendwas mit FG_ gesetzt ist, dann wird das ohne FG_ gecleart und dann FG_gesetzt.
        If FreigabeStatus = 2 And (G_CfgFG_HeaderLeft <> "" Or G_CfgFG_HeaderCenter <> "" Or G_CfgFG_HeaderRight <> "" Or _
          G_CfgFG_FooterLeft <> "" Or G_CfgFG_FooterCenter <> "" Or G_CfgFG_FooterRight <> "") Then
          If G_CfgHeaderLeft <> "" Then hl = " "
          If G_CfgHeaderCenter <> "" Then hc = " "
          If G_CfgHeaderRight <> "" Then hr = " "
          If G_CfgFooterLeft <> "" Then fl = " "
          If G_CfgFooterCenter <> "" Then fc = " "
          If G_CfgFooterRight <> "" Then fr = " "
          If G_CfgFG_HeaderLeft <> "" Then
            hl = GetHeaderFooterText(conn, G_CfgFG_HeaderLeft, curdoc, officeapp)
          End If
          If G_CfgFG_HeaderCenter <> "" Then
            hc = GetHeaderFooterText(conn, G_CfgFG_HeaderCenter, curdoc, officeapp)
          End If
          If G_CfgFG_HeaderRight <> "" Then
            hr = GetHeaderFooterText(conn, G_CfgFG_HeaderRight, curdoc, officeapp)
          End If
          If G_CfgFG_FooterLeft <> "" Then
            fl = GetHeaderFooterText(conn, G_CfgFG_FooterLeft, curdoc, officeapp)
          End If
          If G_CfgFG_FooterCenter <> "" Then
            fc = GetHeaderFooterText(conn, G_CfgFG_FooterCenter, curdoc, officeapp)
          End If
          If G_CfgFG_FooterRight <> "" Then
            fr = GetHeaderFooterText(conn, G_CfgFG_FooterRight, curdoc, officeapp)
          End If
        Else
    hl = GetHeaderFooterText(conn, G_CfgHeaderLeft, curdoc, officeapp)
    hc = GetHeaderFooterText(conn, G_CfgHeaderCenter, curdoc, officeapp)
    hr = GetHeaderFooterText(conn, G_CfgHeaderRight, curdoc, officeapp)
    fl = GetHeaderFooterText(conn, G_CfgFooterLeft, curdoc, officeapp)
    fc = GetHeaderFooterText(conn, G_CfgFooterCenter, curdoc, officeapp)
    fr = GetHeaderFooterText(conn, G_CfgFooterRight, curdoc, officeapp)
        End If
    SetHeaderFooterTexts hl, hc, hr, fl, fc, fr, curdoc
    End If
    curdoc.saved = tSaved

#End If
    
    
    If UCase(Right(curdoc.fullname, 4)) = ".CSV" Then
        If Not conn Is Nothing Then
            conn.Close
            Set conn = Nothing
        End If
        Exit Function
    End If
    
    ' wenn lokale Dateien nicht ber|fffd|cksichtigt werden und dieses eine ist
    If G_PARAM_LokaleDateienBer|fffd|cksichtigen = False And Left(GetUNCPathFromDoc(curdoc), 2) <> "\\" And Left(GetUNCPathFromDoc(curdoc), 2) <> "//" And InStr(GetUNCPathFromDoc(curdoc), "://") <= 0 Then
        ' dann darf gedruckt werden
        If Not conn Is Nothing Then
            conn.Close
            Set conn = Nothing
        End If
        Exit Function
    End If
    
    If DateiAusgeschlossen2(curdoc, conn) Then
        ' dann darf gedruckt werden
        If Not conn Is Nothing Then
            conn.Close
            Set conn = Nothing
        End If
        Exit Function
    End If
    

    Dim rs As Object
    Dim curid As Long
    Dim hash As String
    Dim wasLocked As Boolean
    
    If G_PARAM_KeinDruckenVorRisikobefragung = True Then
      If WBGetValueLong(officeapp, "_IDVTrackerFreigabeStatus" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix) <> 2 Then
        If Not GetTargetRS(conn, GetUNCPathFromDoc(curdoc), curdoc, rs, curid, hash, ADODB.LockTypeEnum.adLockPessimistic, wasLocked) Then
            ' nicht gefunden, also erst mal speichern
            DebugPrint DebType.tdebug, "BeforePrint: Keine Datei gefunden - HASH:" & hash & " - Name:" & GetUNCPathFromDoc(curdoc) & " - CurID:" & curid
            'MsgBox "Vor dem Drucken muss die Datei gespeichert und die Risikobefragung durchgef|fffd|hrt werden. Der Druckvorgang wird abgebrochen.", vbOKOnly + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
            MsgBox FMT0("THISADDIN_87"), vbOKOnly + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
          BeforePrint = False
        Else
            ' schon Risikobewertet?
            If IsNull(rs.Fields("LetzteBefragung").value) Then
                ' alles freigeben, wird in der Riskobefragung alles wieder neu geholt
                Set rs = Nothing
                conn.Close
                Set conn = Nothing
                'If MsgBox("F|fffd|r die Datei wurde noch keine Risikobefragung durchgef|fffd|hrt, dies ist erforderlich, damit gedruckt werden kann. M|fffd|chten Sie die Risikobefragung jetzt durchf|fffd|hren?", vbYesNo + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")") = vbYes Then
                If MsgBox(FMT0("THISADDIN_88"), vbYesNo + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")") = vbYes Then
                    DoRisikobefragung officeapp, curdoc
                Else
                    BeforePrint = False
                End If
            End If
          End If
          If Not rs Is Nothing Then
              Set rs = Nothing
          End If
      End If
    End If
    
    ' wenn BeforePrint schon false ist, dann wird es hier auch nicht mehr besser (auf true gesetzt), daher k|fffd|nnen wir uns den Teil dann auch sparen
    If BeforePrint Then
        If conn Is Nothing Then
            Set conn = GetConnection()
            If conn Is Nothing Then
                Exit Function
            End If
        End If
    
        If GetTargetRS(conn, GetUNCPathFromDoc(curdoc), curdoc, rs, curid, hash, ADODB.LockTypeEnum.adLockPessimistic, wasLocked) Then
          If GetSafeFieldPlus(rs, "Log", 0) <> 0 Then
                If curdoc.saved = False Then
                   'If MsgBox("Vor dem Drucken muss die Datei gespeichert werden. Soll die Datei gespeichert werden?", vbYesNo + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")") = vbYes Then
                   If MsgBox(FMT0("THISADDIN_89"), vbYesNo + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")") = vbYes Then
                     DoInternalSave rs, curdoc, conn
                     rs.Update
                   Else
                     BeforePrint = False
                   End If
                End If
                rs.Close
            
                LogFile curdoc, curid, conn
          End If
          If Not rs Is Nothing Then
            Set rs = Nothing
          End If
        End If
    End If
    
    If Not conn Is Nothing Then
        conn.Close
        Set conn = Nothing
    End If
    Exit Function
    
nogo:
    BeforePrint = False
    
    If Not rs Is Nothing Then
        Set rs = Nothing
    End If
    If Not conn Is Nothing Then
        conn.Close
        Set conn = Nothing
    End If
End Function

Public Sub LogFile(ByRef curdoc As Object, ByVal idvDateiID As Long, ByRef conn As Object)
    xlCheckInLogFiles curdoc.fullname, idvDateiID, conn
End Sub

Public Function GetMyDBLanguage(ByRef conn As Object) As Integer
    If G_MyDBLanguage <> -1 Then
        GetMyDBLanguage = G_MyDBLanguage
        Exit Function
    End If
    
    ' deutsch (=0) ist immer da
    G_MyDBLanguage = 0
    Dim trs As Object
    Set trs = OpenRS("SELECT LanguageID FROM gLanguages WHERE Language='" & gTranslation.CurrentLanguage() & "' and Active <> 0", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
    If Not trs Is Nothing Then
        If Not trs.EOF Then
          G_MyDBLanguage = GetSafeFieldPlus(trs, "LanguageID", 0)
        End If
        trs.Close
        Set trs = Nothing
    End If
    GetMyDBLanguage = G_MyDBLanguage
End Function

Sub AddListItem(ByRef ListZusaetzlicheDateien, ByRef co As ZusaetzlicheDatei)

    Dim i As Long
    i = -1
    Dim s As String
    s = GetFileNameAndExtension(co.m_S) & " (" & GetFreigabeTextKurz(co.m_FreigabeStatus) & ")"
    If ListZusaetzlicheDateien.ListCount > 0 Then
      For i = 0 To ListZusaetzlicheDateien.ListCount - 1
        If UCase(ListZusaetzlicheDateien.List(i, 0)) > UCase(s) Then
          Exit For
        End If
      Next i
    End If
  
' frmDoku.ListZusaetzlicheDateien.AddItem drs.Fields("xlBinTrackerID").value
' frmDoku.ListZusaetzlicheDateien.List(frmDoku.ListZusaetzlicheDateien.ListCount - 1, 1) = GetFileNameAndExtension(drs.Fields("Dateiname").value)

  If i = -1 Then
    ListZusaetzlicheDateien.AddItem s 'xyz
    ListZusaetzlicheDateien.List(ListZusaetzlicheDateien.ListCount - 1, 1) = co.m_L
  Else
    ListZusaetzlicheDateien.AddItem s, i 'xyz
    ListZusaetzlicheDateien.List(i, 1) = co.m_L
  End If
End Sub

Private Sub CopyidvDateienFileStuff(ByVal oldid As Long, ByVal curid As Long, ByRef conn As Object)
  CopyPasswordsToNewID oldid, curid, conn
  CopyBerechtigungenToNewID oldid, curid, conn
  CopyDataIDVDateien oldid, curid, conn, "idvDateienProzess", ""
  CopyDataIDVDateien oldid, curid, conn, "idvDateienFragenKommentar", ""
End Sub

Public Sub MyWorkbookOpen()
  app.Init
End Sub


Public Function CreateFreigabeformularWithChecker(ByVal checkertyp As String, ByRef curdoc As Object, ByVal dateiid As Long, _
  ByVal formularstorepath As String, ByRef officeapp As Object, ByRef dateiRS As Object, ByRef conn As Object, _
  ByRef fNameFreigabeformular As String, ByVal fnameFreigabeInfo As String) As Boolean
        
On Error GoTo nogo
  Dim checkerfile As String
  Dim Ver As String
  Dim dat As String
  Dim id As Long
  Dim intver As Long
  Dim fnamecomp As String
  id = 0
  
  ' Bitte warten, das Formular wird vorbereitet.
  BitteWarten.BitteWartenText.Caption = FMT0("BITTEWARTEN_1")
  BitteWarten.Label1.Caption = FMT0("THISADDIN_115")
  BitteWarten.Show vbModeless
  
  ' Wenns ein eigenes Freigabeformular f|fffd|r Updates gibt
  If G_FreigabeformularUpdateScanner <> G_FreigabeformularScanner And GetSafeFieldPlus(dateiRS, "MAJORVERSION", 0) > 1 Then
    Dim rs As Object
    If GetFilePrecedents(conn, rs, dateiid) Then
      ' Gibts denn ne Vorversion?
      If Not rs Is Nothing Then
        If Not rs.EOF Then
          fnamecomp = rs.Fields("Dateiname").value
          Ver = rs.Fields("MajorVersion").value & "." & rs.Fields("MinorVersion").value
          dat = rs.Fields("Datum").value
          id = rs.Fields("idvDateiID").value
          intver = rs.Fields("Version").value
        End If
        rs.Close
        Set rs = Nothing
      End If
    End If
  End If
    
  Dim formular As String
'       G_FreigabeformularUpload = True
  If id > 0 Or GetSafeFieldPlus(dateiRS, "MajorVersion", 0) > 1 Then
    formular = G_FreigabeformularUpdateScanner
  ElseIf G_FreigabeformularScanner <> "" Then
    formular = G_FreigabeformularScanner
  Else
    BitteWarten.Hide
    Exit Function
  End If
    
  ' Jetzt muss das Freigabeformular geladen werden, in den Temp-Ordner gespeichert und bef|fffd|llt werden,
  ' damit danach dann der EFC (eventuell) und der ECC das Formular bef|fffd|llen k|fffd|nnen
  
  If formular <> "" Then
    If Not CreateFreigabeformular(curdoc, formular, "", officeapp, dateiRS, conn, fNameFreigabeformular, 2, True, _
      curdoc.fullname & " V" & GetSafeFieldPlus(dateiRS, "MajorVersion", 0) & "." & GetSafeFieldPlus(dateiRS, "MinorVersion", 0), MyFileDateTime(curdoc.fullname), _
      fnamecomp & " V" & Ver, CStr(dat)) Then
      BitteWarten.Hide
      Exit Function
    End If
  Else
    BitteWarten.Hide
    Exit Function
  End If
    
  If checkertyp = "ACC" Then
    ' Bitte warten, Access-Checker wird ausgef|fffd|hrt.
    BitteWarten.Label1.Caption = FMT0("THISADDIN_118")
  
    SaveSetting appname:="Stromwerken", Section:="ACC", Key:="COMMAND", Setting:="SCANID" & _
          " /IDCALLER:" & SWAPPID_AccessTracker & _
          " /ID:" & dateiid & _
          " /RES:" & 4 & _
          " /RESFILE:" & Chr(34) & fNameFreigabeformular & Chr(34)

    checkerfile = GetACC()
    
    G_NoStartup = True
    StartDateiUndWarten checkerfile, vbMinimizedFocus
    G_NoStartup = False
  
    If Not GetSetting(appname:="Stromwerken", Section:="IDVSS", Key:="ACCScanFinished", Default:="0") = 1 Then
      MyKill fNameFreigabeformular
      BitteWarten.Hide
      Exit Function
    End If
  
  Else
  
    If id > 0 Then
        ' Bitte warten, Excel-File-Compare wird ausgef|fffd|hrt.
        BitteWarten.Label1.Caption = FMT0("THISADDIN_116")
        checkerfile = GetEFC()
      
        Dim compFname As String
        compFname = officeapp.ActiveWorkbook.fullname
    
        #If PROJECT_ACCESSTRACKER = 0 Then
            If xlCheckOutBinary(conn, id, intver, compFname, True) Then
              
                Dim pw1 As String
                Dim pw2 As String
                Dim typ1 As Long
                Dim typ2 As Long
                
                pw1 = GetFilePasswordFromIDWithTyp(conn, typ2, id)
                pw2 = GetFilePasswordFromIDWithTyp(conn, typ1, WBGetValueLong(curdoc, "_IDVTrackerID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix))
                
                If typ1 = 0 Then
                  pw1 = GetStandardPassword()
                End If
                If typ2 = 0 Then
                  pw2 = GetStandardPassword()
                End If
                
                SaveSetting appname:="Stromwerken", Section:="EFC", Key:="COMMAND", _
                  Setting:="COMP /IDCALLER:" & SWAPPID_ExcelTracker & _
                  " /FILE1:" & Chr(34) & compFname & Chr(34) & _
                  " /FILE2:" & Chr(34) & curdoc.fullname & Chr(34) & _
                  " /PW1:" & Chr(34) & pw1 & Chr(34) & _
                  " /PW2:" & Chr(34) & pw2 & Chr(34) & _
                  " /DISPLAYNAME1:" & Chr(34) & GetFileNameAndExtension(compFname) & Chr(34) & _
                  " /DISPLAYNAME2:" & Chr(34) & curdoc.fullname & Chr(34) & _
                  " /VERSION1:" & Chr(34) & Ver & Chr(34) & _
                  " /VERSION2:" & Chr(34) & WBGetValueLong(curdoc, "_IDVTrackerMajorVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix) & "." & WBGetValueLong(curdoc, "_IDVTrackerMinorVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix) & Chr(34) & _
                  " /FILEDATE1:" & Chr(34) & dat & Chr(34) & _
                  " /RES:" & 4 & _
                  " /RESFILE:" & Chr(34) & fNameFreigabeformular & Chr(34)
        
                G_NoStartup = True
                StartDateiUndWarten checkerfile, vbMinimizedFocus
                G_NoStartup = False
                
                If Not GetSetting(appname:="Stromwerken", Section:="IDVSS", Key:="EFCScanFinished", Default:="0") = 1 Then
                  MyKill fNameFreigabeformular
                  If compFname <> "" Then
                    MyKill compFname
                  End If
                  BitteWarten.Hide
                  Exit Function
                End If
            Else
              compFname = ""
            End If
        #Else
            compFname = ""
        #End If
    End If
  
    ' Bitte warten, Excel-Sheet-Checker wird ausgef|fffd|hrt.
    BitteWarten.Label1.Caption = FMT0("THISADDIN_117")
    SaveSetting appname:="Stromwerken", Section:="ECC", Key:="COMMAND", Setting:="SCANID" & _
          " /IDCALLER:" & SWAPPID_ExcelTracker & _
          " /ID:" & dateiid & _
          " /RES:" & 4 & _
          " /RESFILE:" & Chr(34) & fNameFreigabeformular & Chr(34)

    G_NoStartup = True
    checkerfile = GetECC()
    
    Dim wb As Excel.Workbook
    Set wb = officeapp.Workbooks.Open(checkerfile)
    
    On Error Resume Next
    ' SaveSetting appname:="Stromwerken", Section:="ECC", Key:="ECCStartedByXLAM", Setting:=ThisWorkbook.fullname
    officeapp.Run "'" & checkerfile & "'!StartECCAnalyse"
    Set curdoc = Nothing
    G_NoStartup = False
    If err.Number <> 0 Then
      MsgBox err.Description, vbOKOnly, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
    End If
    wb.Close False
    Set wb = Nothing
  
    If Not GetSetting(appname:="Stromwerken", Section:="IDVSS", Key:="ECCScanFinished", Default:="0") = 1 Then
      MyKill fNameFreigabeformular
      If compFname <> "" Then
        MyKill compFname
      End If
      BitteWarten.Hide
      Exit Function
    End If
  
  End If
  
  ' Alles klar, dann wird mal das Freigabeformular ge|fffd|ffnet
  ' Da kanns auch mehrere Verianten, speichern in Zus|fffd|tzliche Dateien und einfach nur |fffd|ffnen usw.
  If formularstorepath <> "" Then
    CopyFile fNameFreigabeformular, formularstorepath
  End If
  
  StoreFreigabeInitInfo conn, dateiid, fnameFreigabeInfo, fNameFreigabeformular
  
  If checkertyp = "ACC" Then
    Dim xlapp As Excel.Application
    Set xlapp = New Excel.Application
    xlapp.Workbooks.Open fNameFreigabeformular, , True
    xlapp.visible = True
  Else
    officeapp.Workbooks.Open fNameFreigabeformular, , True
  End If
  
  If compFname <> "" Then
    MyKill compFname
  End If
  MyKill fNameFreigabeformular
          
  CreateFreigabeformularWithChecker = True
  BitteWarten.Hide
  Exit Function
nogo:

  DebugPrint DebType.tERROR, "CreateFreigabeformularWithChecker: Err - " & err.Number & " - " & err.Description & " - " & err.Source
End Function

Sub FinalizeFreigabeInfo(ByRef conn As Connection, ByVal idvDateiID As Long)
On Error GoTo fehler
  Dim infors As Object
  Set infors = CreateObject("ADODB.Recordset")
  
  infors.Open "SELECT * from idvDateienFreigabeInfo WHERE idvDateiID = " & idvDateiID, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockOptimistic
  If infors Is Nothing Then
    Exit Sub
  End If
  
  If infors.EOF Then
    infors.AddNew
    infors.Fields("idvDateiID").value = idvDateiID
  End If
  infors.Fields("FreigabeErteilt").value = True
  infors.Update
  infors.Close
  Set infors = Nothing

  Exit Sub
    
fehler:
    DebugPrint tERROR, "FinalizeFreigabeInfo: " & err.Number & " - " & err.Description
End Sub

Sub StoreFreigabeInfo(ByRef curdoc As Object, ByRef conn As Connection, ByVal idvDateiID As Long)
On Error GoTo fehler

  If FileExists(G_cfgBinpfad & "\FreigabeInfo_indiv.txt") Then
    Dim fnameFreigabeInfo As String
    
    Dim rs As Object
    Set rs = OpenRS("Select * from idvDateien where idvDateiId = " & idvDateiID, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
    
    If Not rs Is Nothing Then
      If Not rs.EOF Then
      
          If CreateFreigabeformular(curdoc, G_cfgBinpfad & "\FreigabeInfo_indiv.txt", G_cfgTemppfad, _
              Nothing, rs, conn, fnameFreigabeInfo, 3, False, _
            curdoc.fullname, MyFileDateTime(curdoc.fullname), "", "", "", GetUserName) Then
            
                  Dim infors As Object
                  Set infors = CreateObject("ADODB.Recordset")
                  
                  infors.Open "SELECT * from idvDateienFreigabeInfo WHERE idvDateiID = " & idvDateiID, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockOptimistic
                  If infors Is Nothing Then
                    MyKill fnameFreigabeInfo
                    Exit Sub
                  End If
                  
                  If infors.EOF Then
                    infors.AddNew
                    infors.Fields("idvDateiID").value = idvDateiID
                  End If
                  Dim errstr As String
                  CheckInBinary "Freigabeinformationen", infors, fnameFreigabeInfo, errstr
                  infors.Update
                  infors.Close
                  Set infors = Nothing
                  MyKill fnameFreigabeInfo
            
            End If
      
      End If
      rs.Close
      Set rs = Nothing
    End If
  End If

  
  Exit Sub
    
fehler:
    DebugPrint tERROR, "StoreFreigabeInfo: " & err.Number & " - " & err.Description

End Sub

Sub StoreFreigabeInitInfo(ByRef conn As Connection, ByVal idvDateiID As Long, ByVal fnameFreigabeInfo As String, ByVal fNameFreigabeformular As String)

On Error GoTo fehler
  conn.Execute "DELETE FROM idvDateienFreigabeInfo WHERE idvDateiID = " & idvDateiID
  
  Dim rs As Object
  Set rs = CreateObject("ADODB.Recordset")
  
  rs.Open "SELECT * from idvDateienFreigabeInfo WHERE idvDateiID = " & idvDateiID, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockOptimistic
  If rs Is Nothing Then
    DebugPrint tERROR, "idvDateienFreigabeInfo konnte nicht ge|fffd|ffnet werden!"
    Exit Sub
  End If
  
  rs.AddNew
  rs.Fields("idvDateiID").value = idvDateiID
  Dim errstr As String
  CheckInBinary "Freigabeinformationen", rs, fnameFreigabeInfo, errstr
  CheckInBinary "Freigabeformular", rs, fNameFreigabeformular, errstr, "FreigabeformularExtension"
  rs.Update
  rs.Close
  Set rs = Nothing
  Exit Sub
    
fehler:
    DebugPrint tERROR, "StoreFreigabeInitInfo: " & err.Number & " - " & err.Description

End Sub


Function ReplaceFileTags(ByRef rs As Object, ByVal s As String) As String
On Error Resume Next
  s = Replace(s, "#NAME#", GetFileNameAndExtension(GetSafeFieldPlus(rs, "Dateiname", "")))
  s = Replace(s, "#ID#", GetValueFromField(rs, "idvDateiID", ""))
  s = Replace(s, "#SBSID#", GetSafeFieldPlus(rs, "SBSAssetID"))
  s = Replace(s, "#DATUM#", Format$(Now, "yyyy-mm-dd"))
  s = Replace(s, "#UHRZEIT#", Format$(Now, "hh:mm:ss"))
  s = Replace(s, "#MAJORVERSION#", GetSafeFieldPlus(rs, "MajorVersion"))
  s = Replace(s, "#MINORVERSION#", GetSafeFieldPlus(rs, "MinorVersion"))
  s = Replace(s, "#VERSION#", GetSafeFieldPlus(rs, "Version"))
  s = Replace(s, "#USERNAME#", GetUserName)
  
  ReplaceFileTags = CorrectErrorCharactersInFilename(s)
End Function
Attribute VB_Name = "TrackerStuff"
Option Explicit

Public G_NoStartup As Boolean
Public G_OnDisconnectionCalled As Boolean
Public G_DateiFilter As String
Public G_Abbruch As Boolean
Public G_StatusFormAbbruch As Boolean
Public G_Connections As Collection

Public G_ZeitaufwandZurDoku As Double
Public G_VerantwortlicherAutor As String
Public G_VerantwortlicheOEID As Long
Public G_FachlichVerantwortlicher As String

Public Const C_AllowLocalStuff As Boolean = False

Public G_InClose As Boolean
Public G_InCloseCounter As Long

Public G_DateiID As Long
Public G_Version As Long
Public G_EigeneDokuID As Long
Public G_StoreOEs As Boolean
Public G_StoreEinsatzbereiche As Boolean
Public G_FreigegebenesProgramm As Long
Public G_ReadOnly As Boolean
Public G_DokuOKClicked As Boolean

' XLAM
Public Const C_DokuTabPageStart As Long = 8

Public G_HTMLParamInteraktivit|fffd|t As Boolean
Public G_HTMLParamGesamteArbeitsmappe  As Boolean
Public G_HTMLParamTitel As String


Public G_PARAM_VerantwortlicheOE As Boolean

Public G_PARAM_Menueleiste As Boolean
Public G_PARAM_Ribbons As Boolean

Public G_PARAM_LokaleDateienBer|fffd|cksichtigen As Boolean

Public G_PARAM_PasswortanalyseInSec As Long
Public G_PARAM_HinweisfensterBeiPasswortanalyse As Boolean
Public G_PARAM_LogRisikoklassen|fffd|nderung As Boolean
Public G_PARAM_DokuAbRisikowert As Double
Public G_PARAM_DateienVersionierenAbRisikowert As Double
Public G_PARAM_RisikoklasseAnzeigen As Boolean
Public G_PARAM_TechnischesRisikoAnzeigen As Boolean
Public G_PARAM_VierAp As Boolean
Public G_PARAM_ZentraleFreigabeAbRisikowert As Double

Public G_PARAM_DateienEincheckenBeiProgrammfreigabe As Boolean
Public G_PARAM_EincheckenBeiFreigabeInit As Boolean
Public G_PARAM_IncVersBeiInitAbbruch As Boolean

Public G_PARAM_FragenZurueck As Long
Public G_PARAM_FragenAbschlussInfo As Long
Public G_PARAM_Datenbankprefix As String
Public G_PARAM_Institutsnummer As String
Public G_PARAM_Risikoberechnungsmethode As String
Public G_PARAM_Bei100ProzentFragenFortsetzen As Boolean
Public G_PARAM_BegruendungReduziertesRisiko As Boolean

Public G_PARAM_MaximaleAnzahlVerschiebungenDerBefragung As Long
Public G_PARAM_VerschiebungsdauerInTagen As Long

Public G_PARAM_ReihenfolgeRisikobewertung As Long
Public G_PARAM_ReihenfolgeDokumentation As Long
Public G_PARAM_ReihenfolgeVersionierung As Long
Public G_PARAM_ReihenfolgeFreigabeInit As Long
Public G_PARAM_ReihenfolgeDateiliste As Long
Public G_PARAM_ReihenfolgeProtect As Long
Public G_PARAM_ReihenfolgeScanner As Long
Public G_PARAM_ReihenfolgeFreigabeAbschliessen As Long
Public G_PARAM_ReihenfolgeEFC As Long
Public G_PARAM_ReihenfolgeESQA As Long
Public G_PARAM_ReihenfolgeSignOff As Long
Public G_PARAM_ReihenfolgeAppInfo As Long

Public G_PARAM_ReihenfolgeBerechtigungen   As Long
Public G_PARAM_ReihenfolgeDateiOeffnen  As Long
Public G_PARAM_ReihenfolgeLock  As Long
Public G_PARAM_ReihenfolgeUnLock  As Long
Public G_PARAM_ReihenfolgeDokuInWordIcon  As Long

Public G_PARAM_MaximaleGroesseZusaetzlicheDateien As Long
Public G_PARAM_DateianhaengeNichtVeraenderbar As Boolean
Public G_PARAM_KommentarBeiFreigabe As Boolean

Public G_PARAM_KeinDruckenVorRisikobefragung As Boolean
Public G_PARAM_FreigabeEntfernenBeiVeraenderterChecksummeExcel As Boolean
Public G_PARAM_KeineFreigabeOhneRisikobefragung As Boolean
Public G_PARAM_AnzahlErlaubterVeraenderungen As Long
Public G_PARAM_AnzahlErlaubterVeraenderungenMutterzellen As Long
Public G_PARAM_AnzahlErlaubterVeraenderungenKlone As Long
Public G_PARAM_AnzahlErlaubterVeraenderungenNamen As Long
Public G_PARAM_AnzahlErlaubterVeraenderungenModule As Long


Public G_PARAM_Schutzbedarf_Gering As String
Public G_PARAM_Schutzbedarf_Mittel As String
Public G_PARAM_Schutzbedarf_Hoch As String
Public G_PARAM_Schutzbedarf_Sehr_hoch As String
Public G_PARAM_Vertraulichkeit_Gering As String
Public G_PARAM_Vertraulichkeit_Mittel As String
Public G_PARAM_Vertraulichkeit_Hoch As String
Public G_PARAM_Vertraulichkeit_Sehr_hoch As String
Public G_PARAM_Integritaet_Gering As String
Public G_PARAM_Integritaet_Mittel As String
Public G_PARAM_Integritaet_Hoch As String
Public G_PARAM_Integritaet_Sehr_hoch As String
Public G_PARAM_Verfuegbarkeit_Gering As String
Public G_PARAM_Verfuegbarkeit_Mittel As String
Public G_PARAM_Verfuegbarkeit_Hoch As String
Public G_PARAM_Verfuegbarkeit_Sehr_hoch As String
Public G_PARAM_Informationsklasse_S1 As String
Public G_PARAM_Informationsklasse_S2 As String
Public G_PARAM_Informationsklasse_S3 As String
Public G_PARAM_Informationsklasse_S4 As String
Public G_PARAM_Informationsklasse_S5 As String
Public G_PARAM_TitelIndividuellesTextfeld1 As String
Public G_PARAM_TitelIndividuellesTextfeld2 As String
Public G_PARAM_Authentizitaet_Gering As String
Public G_PARAM_Authentizitaet_Mittel As String
Public G_PARAM_Authentizitaet_Hoch As String
Public G_PARAM_Authentizitaet_Sehr_hoch As String
Public G_PARAM_FragendialogKommentar As String
Public G_PARAM_UeberschriftProzessauswahl As String

Public G_PARAM_NumAllowedMinorChanges As Long
Public G_PARAM_MinorChanges4AP As Boolean

' Achtung: Die Funktion liefert CONN
Function StartupStuff(parameterPrefix As String, ByRef conn As Object) As Boolean
    
    StartupStuff = False
    ' erst mal Deutsch vorausw|fffd|hlen
    G_MyDBLanguage = 0
    
    Dim trs As String
    trs = GetStandardData

    If G_Lizenzen = 0 And Now > G_FullDemoBis Then
      'MsgBox "Die Full-Demo f|fffd|r dieses Programm ist abgelaufen. Wenden Sie sich bitte an info@stromwerken.de. Das Programm wird jetzt als Demoversion ausgef|fffd|hrt.", vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
      MsgBox FMT0("TRACKERSTUFF_1"), vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
      G_FullVersion = False
    End If
    
    ' Juni 2017 - Hier wird die DB zum ersten mal nach dem Start geoeffnet
    ' Hier machen wir den Connection Test mit Timeout
    If Not G_UserDeaktiviert And G_DBConnectionString <> "" And G_CfgDoDBConnectTest And (G_DBType = G_SQL_Server Or G_DBType = G_Oracle) Then
        DebugPrint DebType.tinfo, "Pr|fffd|fe DB-System Erreichbarkeit"
        Dim servername As String
        Dim port As Long
        If SocketConnect.GetServernameAndPort(G_DBConnectionString, servername, port) Then
            DebugPrint DebType.tinfo, "Pr|fffd|fe DB connection zu " & servername & " Port: " & port & ". Timeout: " & G_CfgDBConnectTestTimeout & "s"
            Dim errMsg As String
            If Not SocketConnect.ConnectTest(servername, port, G_CfgDBConnectTestTimeout, errMsg) Then
                ' Connection Failed - user ist fuer diese Session deaktiviert
                DebugPrint DebType.tinfo, " DB Connection Failed!"
                G_UserDeaktiviert = True
                Exit Function
            End If
            DebugPrint DebType.tinfo, " DB Connection Success!"
        End If
    End If
    
    DebugPrint DebType.tinfo, "1. Connect Test"
    DebugPrint DebType.tinfo, G_DBConnectionString
    Set conn = GetConnection()

    If conn Is Nothing Then
        If G_DBVersion > C_DBVersion Then
          DebugPrint DebType.tdebug, "DB-Version nicht kompatibel, Plugin deaktiviert!"
        ElseIf G_UserDeaktiviert Then
          DebugPrint DebType.tERROR, "User deaktiviert"
        Else
          DebugPrint DebType.tERROR, "1. Connect fehlgeschlagen"
        End If
        G_UserDeaktiviert = True
        Exit Function
    End If
    
    G_AllowLoggingToStorage = True
    DebugPrint DebType.tinfo, "1. Connect erfolgreich"

    If Deaktiviert(conn) Then
        DebugPrint DebType.tinfo, progNameShort & " deaktiviert"
        conn.Close
        Set conn = Nothing
        G_UserDeaktiviert = True
        Exit Function
    End If
    
    
    ' User ausgeschlossen?
    Dim userrs As Object
    Set userrs = OpenRS("SELECT * FROM idvUserAusschluss", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
    If userrs Is Nothing Then
        conn.Close
        Set conn = Nothing
        Exit Function
    End If
    
    Do While Not userrs.EOF
      If UCase(userrs.Fields("UserLogonID").value) = UCase(GetUserName()) Then
          G_UserDeaktiviert = True
          DebugPrint DebType.tinfo, "USER " & GetUserName() & " ausgeschlossen"
          conn.Close
          Set conn = Nothing
          Exit Function
      End If
      userrs.MoveNext
    Loop
    userrs.Close
    Set userrs = Nothing
    
    If G_UserDeaktiviert = True Then
      DebugPrint DebType.tinfo, "USER " & GetUserName() & " nicht zugelassen"
      conn.Close
      Set conn = Nothing
      Exit Function
    End If

    Call InitLoc
    G_PARAM_SMTPFreigabeAbbruchBetreff = STDTEXT("SMTPFreigabeAbbruchBetreff")
    G_PARAM_SMTPMailFreigabeAbbruch = STDTEXT("SMTPMailFreigabeAbbruch")
    G_PARAM_SMTPFreigabeBetreff = STDTEXT("SMTPFreigabeBetreff")
    G_PARAM_SMTPMailFreigabe = STDTEXT("SMTPMailFreigabe")
    G_PARAM_SMTPFreigabeErteilenBetreff = STDTEXT("SMTPFreigabeErteilenBetreff")
    G_PARAM_SMTPMailFreigabeErteilen = STDTEXT("SMTPMailFreigabeErteilen")
    G_PARAM_SMTPMailInfoRisikoklasseBetreff = STDTEXT("SMTPMailInfoRisikoklasseBtrff")
    G_PARAM_SMTPMailInfoRisikoklasse = STDTEXT("SMTPMailInfoRisikoklasse")

    G_PARAM_Schutzbedarf_Gering = STDTEXT("Schutzbedarf_Gering")
    G_PARAM_Schutzbedarf_Mittel = STDTEXT("Schutzbedarf_Mittel")
    G_PARAM_Schutzbedarf_Hoch = STDTEXT("Schutzbedarf_Hoch")
    G_PARAM_Schutzbedarf_Sehr_hoch = STDTEXT("Schutzbedarf_Sehr_hoch")
    G_PARAM_Vertraulichkeit_Gering = STDTEXT("Vertraulichkeit_Gering")
    G_PARAM_Vertraulichkeit_Mittel = STDTEXT("Vertraulichkeit_Mittel")
    G_PARAM_Vertraulichkeit_Hoch = STDTEXT("Vertraulichkeit_Hoch")
    G_PARAM_Vertraulichkeit_Sehr_hoch = STDTEXT("Vertraulichkeit_Sehr_hoch")
    G_PARAM_Integritaet_Gering = STDTEXT("Integritaet_Gering")
    G_PARAM_Integritaet_Mittel = STDTEXT("Integritaet_Mittel")
    G_PARAM_Integritaet_Hoch = STDTEXT("Integritaet_Hoch")
    G_PARAM_Integritaet_Sehr_hoch = STDTEXT("Integritaet_Sehr_hoch")
    G_PARAM_Verfuegbarkeit_Gering = STDTEXT("Verfuegbarkeit_Gering")
    G_PARAM_Verfuegbarkeit_Mittel = STDTEXT("Verfuegbarkeit_Mittel")
    G_PARAM_Verfuegbarkeit_Hoch = STDTEXT("Verfuegbarkeit_Hoch")
    G_PARAM_Verfuegbarkeit_Sehr_hoch = STDTEXT("Verfuegbarkeit_Sehr_hoch")
    G_PARAM_Informationsklasse_S1 = STDTEXT("Informationsklasse_S1")
    G_PARAM_Informationsklasse_S2 = STDTEXT("Informationsklasse_S2")
    G_PARAM_Informationsklasse_S3 = STDTEXT("Informationsklasse_S3")
    G_PARAM_Informationsklasse_S4 = STDTEXT("Informationsklasse_S4")
    G_PARAM_Informationsklasse_S5 = STDTEXT("Informationsklasse_S5")
    G_PARAM_Authentizitaet_Gering = STDTEXT("Authentizitaet_Gering")
    G_PARAM_Authentizitaet_Mittel = STDTEXT("Authentizitaet_Mittel")
    G_PARAM_Authentizitaet_Hoch = STDTEXT("Authentizitaet_Hoch")
    G_PARAM_Authentizitaet_Sehr_hoch = STDTEXT("Authentizitaet_Sehr_hoch")
    G_PARAM_TitelIndividuellesTextfeld1 = STDTEXT("TitelIndividuellesTextfeld1")
    G_PARAM_TitelIndividuellesTextfeld2 = STDTEXT("TitelIndividuellesTextfeld2")

    G_PARAM_FragendialogKommentar = STDTEXT("FragendialogKommentar")
    G_PARAM_UeberschriftProzessauswahl = STDTEXT("UeberschriftProzessauswahl")
    
    Dim paramrs As Object
    Set paramrs = GetParamRS(conn)
    ' OpenRS("SELECT * FROM gParameter", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
    If paramrs Is Nothing Then
        conn.Close
        Set conn = Nothing
        Exit Function
    End If

    
    
'    G_PARAM_PasswortanalyseInSec = GetValueFromField(paramrs, "PasswortanalyseInSec", 3)
    G_PARAM_PasswortanalyseInSec = -1
'    G_PARAM_HinweisfensterBeiPasswortanalyse = GetValueFromField(paramrs, "HinweisfensterBeiPwdanalyse", False)
    
    G_PARAM_LokaleDateienBer|fffd|cksichtigen = GetValueFromField(paramrs, "LokaleDateienBeruecksichtigen", False)
    G_PARAM_LogRisikoklassen|fffd|nderung = GetValueFromField(paramrs, "LogRisikoklassenaenderung", True)
    G_PARAM_DateienEincheckenBeiProgrammfreigabe = GetValueFromField(paramrs, "EincheckenBeiPrgfreigabe", False)
    G_PARAM_EincheckenBeiFreigabeInit = GetValueFromField(paramrs, "EincheckenBeiFreigabeInit", False)
    G_PARAM_IncVersBeiInitAbbruch = GetValueFromField(paramrs, "IncVersBeiInitAbbruch", False)
    
    G_PARAM_SMTPMailVersandAktiv = GetValueFromField(paramrs, "SMTPMailversandAktiv", False)
    G_PARAM_DokuAbRisikowert = GetValueFromField(paramrs, "DokuAbRisikowert", -1)
    G_PARAM_StoreMailsToTable = GetValueFromField(paramrs, "ZentralerMailVersand", False)

    G_PARAM_DebugInfosLoggen = GetValueFromField(paramrs, "LogDebug", False)
    G_PARAM_DateienVersionierenAbRisikowert = GetValueFromField(paramrs, "DateienVersionierenAbRisk", 1)
    G_PARAM_RisikoklasseAnzeigen = GetValueFromField(paramrs, "RisikoklasseAnzeigen", False)
    G_PARAM_TechnischesRisikoAnzeigen = GetValueFromField(paramrs, "TechnischesRisikoAnzeigen", False)
    G_PARAM_VierAp = GetValueFromField(paramrs, "VierAP", False)
    G_PARAM_EMailListe = GetValueFromField(paramrs, "Mailliste", False)
    G_PARAM_ZentraleFreigabeAbRisikowert = GetValueFromField(paramrs, "ZentraleFreigabeAbRisikowert", -1)
    
    G_PARAM_MaximaleGroesseZusaetzlicheDateien = GetValueFromField(paramrs, "ZUSDOKUQUOTA", 0)
    G_PARAM_DateianhaengeNichtVeraenderbar = GetValueFromField(paramrs, "KEINEZUSDATEIENAENDERUNG", False)
    G_PARAM_KommentarBeiFreigabe = GetValueFromField(paramrs, "KOMMENTARBEIFREIGABE", True)
    G_PARAM_KeinDruckenVorRisikobefragung = GetValueFromField(paramrs, "KEINDRUCKENVORFRAGEN", False)
    G_PARAM_FreigabeEntfernenBeiVeraenderterChecksummeExcel = GetValueFromField(paramrs, "HINWEISBEIMODFREIGABE", False) ' ACHTUNG: Das ist "Freigabe bei ver|fffd|nderter Checksumme entfernen"
    G_PARAM_KeineFreigabeOhneRisikobefragung = GetValueFromField(paramrs, "KEINEFREIGABEOHNERISIKOBEFRGNG", False)
    
    G_PARAM_WarnungManuelleBerechnung = GetValueFromField(paramrs, "WarnungManuelleBerechnung", False)
    G_PARAM_OEAusADGruppeLesen = GetValueFromField(paramrs, "OEAusADGruppeLesen", False)
    G_PARAM_ToDoListe = GetValueFromField(paramrs, "ToDoListeInDoku", False)
    
    G_PARAM_DokuInWord = GetValueFromField(paramrs, "DokuInWord", False)
    G_PARAM_FragenAntworten = GetValueFromField(paramrs, "FragenAntworten", True)
    G_PARAM_XMinutenNichtBefragen = GetValueFromField(paramrs, "XMinutenNichtBefragen", 0)
    G_PARAM_FragenAntwortenScreen = GetValueFromField(paramrs, "FragenAntwortenScreen", False)
    G_PARAM_ChecklisteFreigabeInitiierung = GetValueFromField(paramrs, "ChecklisteFreigabeinitiierung", False)
    G_PARAM_ChecklisteFreigabe = GetValueFromField(paramrs, "ChecklisteFreigabe", False)
    G_PARAM_Ampel = GetValueFromField(paramrs, "Ampel", False)
    G_PARAM_AmpelRisiko = GetValueFromField(paramrs, "AmpelRisiko", 0.6)
    
    G_PARAM_BlattschutzEntf4AP = GetValueFromField(paramrs, "BlattschutzEntf4AP", False)
    
    G_PARAM_AnzahlErlaubterVeraenderungen = GetValueFromField(paramrs, "AnzahlErlaubterVeraenderungen", -1)
    G_PARAM_AnzahlErlaubterVeraenderungenMutterzellen = GetValueFromField(paramrs, "AnzahlErlaubterVMutterzellen", -1)
    G_PARAM_AnzahlErlaubterVeraenderungenKlone = GetValueFromField(paramrs, "AnzahlErlaubterVKlone", -1)
    G_PARAM_AnzahlErlaubterVeraenderungenNamen = GetValueFromField(paramrs, "AnzahlErlaubterVNamen", -1)
    G_PARAM_AnzahlErlaubterVeraenderungenModule = GetValueFromField(paramrs, "AnzahlErlaubterVModule", -1)
    G_PARAM_NumAllowedMinorChanges = GetValueFromField(paramrs, "AnzahlMinorChanges", 30)
    If G_PARAM_NumAllowedMinorChanges < 0 Then G_PARAM_NumAllowedMinorChanges = 30
    G_PARAM_MinorChanges4AP = GetValueFromField(paramrs, "MinorChange4AP", False)

'    G_LogThisUser = False
        
'    Set userrs = OpenRS("SELECT * FROM idvUserLogging", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
'    If userrs Is Nothing Then
'        conn.Close
'        Set conn = Nothing
'        Exit Function
'    End If

'    If Not userrs.EOF Then
'      Do While Not userrs.EOF
'        If UCase(userrs.Fields("LogonID").value) = UCase(GetUserName()) Then
'            G_LogThisUser = True
'            Exit Do
'        End If
'        userrs.MoveNext
'      Loop
'    End If
    
'    userrs.Close
'    Set userrs = Nothing

'    If Not G_LogThisUser Then
'      DebugPrint DebType.tdebug, "User von Logging ausgeschlossen!"
'    End If
    
    
    DebugPrint DebType.tinfo, progNameShort & " gestartet"
    
    DebugPrint DebType.tdebug, "DB-Param: DebugInfosLoggen=" & IIf(G_PARAM_DebugInfosLoggen, "Ja", "Nein")
    
    G_PARAM_VerantwortlicheOE = GetValueFromField(paramrs, "VerantwortlicheOE", False)
    
    G_PARAM_Menueleiste = GetValueFromField(paramrs, "Menueleiste", False)
    
    G_PARAM_Ribbons = GetValueFromField(paramrs, "Ribbons", False)
    Call DebugPrint(DebType.tdebug, "Ribbons: " & G_PARAM_Ribbons)
    
    G_PARAM_FragenZurueck = GetValueFromField(paramrs, "FragenZurueck", 0)
    G_PARAM_FragenAbschlussInfo = GetValueFromField(paramrs, "FragenAbschlussInfo", False)
    
                    
    If Not IsNull(paramrs.Fields("SMTPSender").value) Then
        G_PARAM_SMTPSender = paramrs.Fields("SMTPSender").value
    End If
    If Not IsNull(paramrs.Fields("SMTPServer").value) Then
        G_PARAM_SMTPServer = paramrs.Fields("SMTPServer").value
    End If
    If Not IsNull(paramrs.Fields("SMTPEmpfaengerPrgFreigabenA").value) Then
        G_PARAM_SMTPEmpfaenger_ProgrammfreigabenA = paramrs.Fields("SMTPEmpfaengerPrgFreigabenA").value
    End If
    If Not IsNull(paramrs.Fields("SMTPEmpfaengerPrgFreigabenB").value) Then
        G_PARAM_SMTPEmpfaenger_ProgrammfreigabenB = paramrs.Fields("SMTPEmpfaengerPrgFreigabenB").value
    End If
    
    G_PARAM_FormelnNichtZaehlenAbKB = GetSafeFieldPlus(paramrs, "ASYNCHRONEANALYSE", 1000)
    
    If Not IsNull(paramrs.Fields("Datenbankprefix").value) Then
        G_PARAM_Datenbankprefix = paramrs.Fields("Datenbankprefix").value
    End If
    
    If Not IsNull(paramrs.Fields("Risikoberechnungsmethode").value) Then
        G_PARAM_Risikoberechnungsmethode = paramrs.Fields("Risikoberechnungsmethode").value
    End If
    
    If Not IsNull(paramrs.Fields("Bei100ProzentFragenFortsetzen").value) Then
        G_PARAM_Bei100ProzentFragenFortsetzen = paramrs.Fields("Bei100ProzentFragenFortsetzen").value
    End If
    
    If Not IsNull(paramrs.Fields("BegruendungReduziertesRisiko").value) Then
        G_PARAM_BegruendungReduziertesRisiko = paramrs.Fields("BegruendungReduziertesRisiko").value
    End If
    
    If Not IsNull(paramrs.Fields("MaxAnzlVerschiebungenBefragung").value) Then
        G_PARAM_MaximaleAnzahlVerschiebungenDerBefragung = paramrs.Fields("MaxAnzlVerschiebungenBefragung").value
    End If
    
    If Not IsNull(paramrs.Fields("VerschiebungsdauerInTagen").value) Then
        G_PARAM_VerschiebungsdauerInTagen = paramrs.Fields("VerschiebungsdauerInTagen").value
    Else
        G_PARAM_VerschiebungsdauerInTagen = 5
    End If
    
    If Not IsNull(paramrs.Fields("ReihenfolgeRisikobewertung").value) Then
        G_PARAM_ReihenfolgeRisikobewertung = paramrs.Fields("ReihenfolgeRisikobewertung").value
    Else
        G_PARAM_ReihenfolgeRisikobewertung = 1
    End If
    
    If Not IsNull(paramrs.Fields("ReihenfolgeDokumentation").value) Then
        G_PARAM_ReihenfolgeDokumentation = paramrs.Fields("ReihenfolgeDokumentation").value
    Else
        G_PARAM_ReihenfolgeDokumentation = 2
    End If
    
    If Not IsNull(paramrs.Fields("ReihenfolgeVersionierung").value) Then
        G_PARAM_ReihenfolgeVersionierung = paramrs.Fields("ReihenfolgeVersionierung").value
    Else
        G_PARAM_ReihenfolgeVersionierung = 3
    End If
    
    If Not IsNull(paramrs.Fields("ReihenfolgeProgrammfreigabe").value) Then
        G_PARAM_ReihenfolgeFreigabeInit = paramrs.Fields("ReihenfolgeProgrammfreigabe").value
    Else
        G_PARAM_ReihenfolgeFreigabeInit = 4
    End If
    
    If Not IsNull(paramrs.Fields("ReihenfolgeDateiliste").value) Then
        G_PARAM_ReihenfolgeDateiliste = paramrs.Fields("ReihenfolgeDateiliste").value
    Else
        G_PARAM_ReihenfolgeDateiliste = 5
    End If
    
    If Not IsNull(paramrs.Fields("ReihenfolgeProtect").value) Then
        G_PARAM_ReihenfolgeProtect = paramrs.Fields("ReihenfolgeProtect").value
    Else
        G_PARAM_ReihenfolgeProtect = 6
    End If
    
    If Not IsNull(paramrs.Fields("ReihenfolgeScanner").value) Then
        G_PARAM_ReihenfolgeScanner = paramrs.Fields("ReihenfolgeScanner").value
    Else
        G_PARAM_ReihenfolgeScanner = 7
    End If
    
    If Not IsNull(paramrs.Fields("ReihenfolgeFreigabe").value) Then
        G_PARAM_ReihenfolgeFreigabeAbschliessen = paramrs.Fields("ReihenfolgeFreigabe").value
    Else
        G_PARAM_ReihenfolgeFreigabeAbschliessen = 10
    End If
    
    If Not IsNull(paramrs.Fields("ReihenfolgeEFC").value) Then
        G_PARAM_ReihenfolgeEFC = paramrs.Fields("ReihenfolgeEFC").value
    Else
        G_PARAM_ReihenfolgeEFC = 8
    End If
    
    If Not IsNull(paramrs.Fields("ReihenfolgeESQA").value) Then
        G_PARAM_ReihenfolgeESQA = paramrs.Fields("ReihenfolgeESQA").value
    Else
        G_PARAM_ReihenfolgeESQA = 9
    End If
    
    If Not IsNull(paramrs.Fields("ReihenfolgeFreigabe").value) Then
        G_PARAM_ReihenfolgeFreigabeAbschliessen = paramrs.Fields("ReihenfolgeFreigabe").value
    Else
        G_PARAM_ReihenfolgeFreigabeAbschliessen = 10
    End If
   
    If Not IsNull(paramrs.Fields("ReihenfolgeDateiberecht").value) Then
        G_PARAM_ReihenfolgeBerechtigungen = paramrs.Fields("ReihenfolgeDateiberecht").value
    Else
        G_PARAM_ReihenfolgeBerechtigungen = 11
    End If
    
    If Not IsNull(paramrs.Fields("ReihenfolgeDateiOeffnen").value) Then
        G_PARAM_ReihenfolgeDateiOeffnen = paramrs.Fields("ReihenfolgeDateiOeffnen").value
    Else
        G_PARAM_ReihenfolgeDateiOeffnen = 12
    End If
    
    If Not IsNull(paramrs.Fields("ReihenfolgeSchutzAnbringen").value) Then
        G_PARAM_ReihenfolgeLock = paramrs.Fields("ReihenfolgeSchutzAnbringen").value
    Else
        G_PARAM_ReihenfolgeLock = 13
    End If
    If Not IsNull(paramrs.Fields("ReihenfolgeSchutzAufheben").value) Then
        G_PARAM_ReihenfolgeUnLock = paramrs.Fields("ReihenfolgeSchutzAufheben").value
    Else
        G_PARAM_ReihenfolgeUnLock = 14
    End If
    If Not IsNull(paramrs.Fields("ReihenfolgeWordDoku").value) Then
        G_PARAM_ReihenfolgeDokuInWordIcon = paramrs.Fields("ReihenfolgeWordDoku").value
    Else
        G_PARAM_ReihenfolgeDokuInWordIcon = 15
    End If
    
    If Not IsNull(paramrs.Fields("ReihenfolgeSignOffProzess").value) Then
        G_PARAM_ReihenfolgeSignOff = paramrs.Fields("ReihenfolgeSignOffProzess").value
    Else
        G_PARAM_ReihenfolgeSignOff = 16
    End If
    
    If Not IsNull(paramrs.Fields("ReihenfolgeAppInfo").value) Then
        G_PARAM_ReihenfolgeAppInfo = paramrs.Fields("ReihenfolgeAppInfo").value
    Else
        G_PARAM_ReihenfolgeAppInfo = 17
    End If
    
    paramrs.Close
    Set paramrs = Nothing
    
    GetMyOE conn
    G_MyDBLanguage = -1
    GetMyDBLanguage conn

    StartupStuff = True

End Function

Function GetEP()
On Error GoTo nogo
  GetEP = ""

  If FileExists(G_cfgEPPfad & "\ExcelProtect.xls") Then
      GetEP = G_cfgEPPfad & "\ExcelProtect.xls"
  ElseIf FileExists(G_cfgEPPfad & "\ExcelProtect.xla") Then
      GetEP = G_cfgEPPfad & "\ExcelProtect.xla"
  End If
  
  DebugPrint tdebug, "GetEP - Finished"
  Exit Function
  
nogo:
  DebugPrint DebType.tERROR, "GetEP: Err - " & err.Number & " - " & err.Description & " - " & err.Source


End Function

Function GetEFC()
On Error GoTo nogo
  GetEFC = ""

  If FileExists(G_cfgEFCPfad & "\Excel-File-Compare.xls") Then
      GetEFC = G_cfgEFCPfad & "\Excel-File-Compare.xls"
  ElseIf FileExists(G_cfgEFCPfad & "\Excel-File-Compare.xla") Then
      GetEFC = G_cfgEFCPfad & "\Excel-File-Compare.xla"
  End If
  
  DebugPrint tdebug, "GetEFC - Finished"
  Exit Function
  
nogo:
  DebugPrint DebType.tERROR, "GetEFC: Err - " & err.Number & " - " & err.Description & " - " & err.Source


End Function


Function GetESQA()
On Error GoTo nogo
  GetESQA = ""

  If FileExists(G_cfgESQAPfad & "\Excel-Sheet-QA.xls") Then
      GetESQA = G_cfgESQAPfad & "\Excel-Sheet-QA.xls"
  ElseIf FileExists(G_cfgESQAPfad & "\Excel-Sheet-QA.xla") Then
      GetESQA = G_cfgESQAPfad & "\Excel-Sheet-QA.xla"
  End If
  
  DebugPrint tdebug, "GetESQA - Finished"
  Exit Function
  
nogo:
  DebugPrint DebType.tERROR, "GetESQA: Err - " & err.Number & " - " & err.Description & " - " & err.Source


End Function



Function GetECC()

On Error GoTo nogo
  GetECC = ""

  If FileExists(G_cfgECCPfad & "\Excel-Sheet-Checker.xls") Then
      GetECC = G_cfgECCPfad & "\Excel-Sheet-Checker.xls"
  ElseIf FileExists(G_cfgECCPfad & "\Excel-Sheet-Checker.xla") Then
      GetECC = G_cfgECCPfad & "\Excel-Sheet-Checker.xla"
  End If
  
  Exit Function
  
nogo:
  DebugPrint DebType.tERROR, "GetECC: Err - " & err.Number & " - " & err.Description & " - " & err.Source

End Function

Function GetACC()

On Error GoTo nogo
  GetACC = ""

  If FileExists(G_cfgACCPfad & "\Access-Checker.xls") Then
      GetACC = G_cfgACCPfad & "\Access-Checker.xls"
  ElseIf FileExists(G_cfgACCPfad & "\Access-Checker.xla") Then
      GetACC = G_cfgACCPfad & "\Access-Checker.xla"
  End If
  
  Exit Function
  
nogo:
  DebugPrint DebType.tERROR, "GetACC: Err - " & err.Number & " - " & err.Description & " - " & err.Source

End Function

Sub AddLog(txt As String, Optional dt As DebType = tinfo)
  DebugPrint dt, txt
End Sub

Sub SetSaved(ByRef wbInExcelCurrentProjectInAccess As Object, Optional isSaved As Boolean = True)
#If PROJECT_ACCESSTRACKER = 0 Then
  wbInExcelCurrentProjectInAccess.saved = True
#End If
End Sub

Sub CloseActiveDocument(ByRef officeapp As Object)
#If PROJECT_ACCESSTRACKER = 0 Then
  officeapp.ActiveWorkbook.Close
#Else
  officeapp.CloseCurrentDatabase
#End If
End Sub

' Return:
' 2 = Freigabe deaktiviert
' 1 = Freigabe abgelehnt
' 0 = Freigegeben
' -1 = Freigabe nicht initiiert
' -2 = Freigabe initiiert
Function GetFreigabeStatus(ByRef conn As Object, ByRef wbInExcelCurrentProjectInAccess As Object, ByRef strFreigabeKommentar As String, _
            ByRef strUser As String, ByRef datFreigabeDatum As Date, ByRef freigabeDateiID As Long, ByRef freigabeVersion As Long, _
            ByRef strDeaktivierenderUser As String, ByRef datumDeaktivierung As Date, ByRef strDeaktivierungKommentar As String) As Long

  GetFreigabeStatus = -1
  Dim rs As Object
  Set rs = OpenRS("SELECT FreigabeidvDateiID,FreigabeVersion,Dateiname FROM idvDateien WHERE idvDateiID = " & WBGetValueLong(wbInExcelCurrentProjectInAccess, "_IDVTrackerID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix) & " and Version = " & WBGetValueLong(wbInExcelCurrentProjectInAccess, "_IDVTrackerVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix), conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
  If Not rs Is Nothing Then
      GetFreigabeStatus = GetFreigabeStatusFromRS(conn, rs, wbInExcelCurrentProjectInAccess, strFreigabeKommentar, strUser, datFreigabeDatum, freigabeDateiID, freigabeVersion, strDeaktivierenderUser, datumDeaktivierung, strDeaktivierungKommentar)
      rs.Close
      Set rs = Nothing
  End If

End Function
    
' 2 = Freigabe deaktiviert
' 1 = Freigabe abgelehnt
' 0 = Freigegeben
' -1 = Freigabe nicht initiiert
' -2 = Freigabe initiiert
Function GetFreigabeStatusFromRS(ByRef conn As Object, rs As Object, ByRef wbInExcelCurrentProjectInAccess As Object, _
                ByRef strFreigabeKommentar As String, ByRef strUser As String, ByRef datFreigabeDatum As Date, ByRef freigabeDateiID As Long, ByRef freigabeVersion As Long, _
                ByRef strDeaktivierenderUser As String, ByRef datumDeaktivierung As Date, ByRef strDeaktivierungKommentar As String) As Long

  GetFreigabeStatusFromRS = -1
  
  ' Jetzt schauen wir als erstes Mal, ob die Datei initiiert wurde, und zwar in idvDateien
  If GetSafeFieldPlus(rs, "Freigabestatus", 0) = 1 Then
    GetFreigabeStatusFromRS = -2
  End If
  
  
  Dim tFreigabeStatus As Long
  ' Dann wird idvDateienFreigabe gepr|fffd|ft
  If Not rs Is Nothing Then
    If Not rs.EOF Then
      Dim uncpathfname As String
      uncpathfname = GetUNCPath(wbInExcelCurrentProjectInAccess.fullname)
    
      If uncpathfname = GetSafeFieldPlus(rs, "Dateiname", "") Then
        tFreigabeStatus = GetFreigabeStatusAusDB(conn, GetSafeFieldPlus(rs, "FreigabeidvDateiID", 0), GetSafeFieldPlus(rs, "FreigabeVersion", 0), strFreigabeKommentar, strUser, datFreigabeDatum, strDeaktivierenderUser, datumDeaktivierung, strDeaktivierungKommentar)
        If tFreigabeStatus <> -1 Then
          GetFreigabeStatusFromRS = tFreigabeStatus
        End If
        If tFreigabeStatus = 0 Then
            freigabeDateiID = GetSafeFieldPlus(rs, "FreigabeidvDateiID", 0)
            freigabeVersion = GetSafeFieldPlus(rs, "FreigabeVersion", 0)
        End If
      End If
    End If
  End If
  
  If GetFreigabeStatusFromRS = -1 Then
      Dim idvDateiID As Long
      Dim Version As Long
      idvDateiID = WBGetValueLong(wbInExcelCurrentProjectInAccess, "_IDVTrackerFreigabeDateiID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix)
      Version = WBGetValueLong(wbInExcelCurrentProjectInAccess, "_IDVTrackerFreigabeVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix)
      If idvDateiID > 0 And Version > 0 Then
          tFreigabeStatus = GetFreigabeStatusAusDB(conn, idvDateiID, Version, strFreigabeKommentar, strUser, datFreigabeDatum, strDeaktivierenderUser, datumDeaktivierung, strDeaktivierungKommentar)
          If tFreigabeStatus <> -1 Then
            GetFreigabeStatusFromRS = tFreigabeStatus
          End If
          If tFreigabeStatus = 0 Then
              freigabeDateiID = idvDateiID
              freigabeVersion = Version
          End If
      End If
  End If

End Function
    
' 2 = Freigabe deaktiviert
' 1 = Freigabe abgelehnt
' 0 = Freigegeben
' -1 = Freigabe initiiert oder noch nicht initiiert, das kann die Funktion hier nicht ermitteln, da sie nur idvDateienFreigaben testet
Function GetFreigabeStatusAusDBShort(ByRef conn As Object, ByVal idvDateiID As Long, ByVal Version As Long, ByRef datFreigabeDatum As Date) As Long

    Dim onlineFreigabeStatus As Long
    Dim strFreigabeKommentar As String
    Dim strUser As String
    Dim strDeaktivierenderUser As String
    Dim datumDeaktivierung As Date
    Dim strDeaktivierungKommentar As String
    GetFreigabeStatusAusDBShort = GetFreigabeStatusAusDB(conn, _
                        idvDateiID, _
                        Version, _
                        strFreigabeKommentar, _
                        strUser, datFreigabeDatum, _
                        strDeaktivierenderUser, datumDeaktivierung, strDeaktivierungKommentar)
End Function
    
    
' 2 = Freigabe deaktiviert
' 1 = Freigabe abgelehnt
' 0 = Freigegeben
' -1 = Freigabe initiiert oder noch nicht initiiert, das kann die Funktion hier nicht ermitteln, da sie nur idvDateienFreigaben testet
Function GetFreigabeStatusAusDB(ByRef conn As Object, ByVal idvDateiID As Long, ByVal Version As Long, ByRef strFreigabeKommentar As String, _
                    ByRef strUser As String, ByRef datFreigabeDatum As Date, _
                    ByRef strDeaktivierenderUser As String, ByRef datumDeaktivierung As Date, ByRef strDeaktivierungKommentar As String) As Long
  GetFreigabeStatusAusDB = -1
  
  If idvDateiID > 0 And Version > 0 Then
  
    Dim rsFreigabe As Object
    Set rsFreigabe = OpenRS("SELECT * FROM idvDateienFreigaben WHERE idvDateiID=" & idvDateiID & " AND Version=" & Version & " order by Datum desc", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
      
    If Not rsFreigabe Is Nothing Then
      If Not rsFreigabe.EOF Then
        strFreigabeKommentar = IIf(Not IsNull(rsFreigabe.Fields("Kommentar").value), rsFreigabe.Fields("Kommentar").value, "")
        strUser = IIf(Not IsNull(rsFreigabe.Fields("FreigebenderUser").value), rsFreigabe.Fields("FreigebenderUser").value, "")
        datFreigabeDatum = IIf(Not IsNull(rsFreigabe.Fields("Datum").value), rsFreigabe.Fields("Datum").value, "")
        GetFreigabeStatusAusDB = rsFreigabe.Fields("Status").value
        datumDeaktivierung = IIf(Not IsNull(rsFreigabe.Fields("Deaktivierungsdatum").value), rsFreigabe.Fields("Deaktivierungsdatum").value, #1/1/2000#)
        strDeaktivierenderUser = IIf(Not IsNull(rsFreigabe.Fields("DeaktivierenderUser").value), rsFreigabe.Fields("DeaktivierenderUser").value, "")
        strDeaktivierungKommentar = IIf(Not IsNull(rsFreigabe.Fields("KommentarDeaktivierung").value), rsFreigabe.Fields("KommentarDeaktivierung").value, "")
      End If
      rsFreigabe.Close
      Set rsFreigabe = Nothing
    End If
  End If
  
End Function

Function AktuellsteFreigabeVersion(ByRef conn As Object, idvDateiID As Long, Version As Long, ByRef filePath As String, ByRef aktVersion As Long) As Boolean

  AktuellsteFreigabeVersion = True
  aktVersion = -1
  filePath = ""
  
  Dim maxversion As Long
  Dim rsFreigabe As Object
  Set rsFreigabe = OpenRS("SELECT MAX(Version) AS MVersion FROM idvDateienFreigaben WHERE idvDateiID=" & idvDateiID & " and Status = 0", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
  If Not rsFreigabe Is Nothing Then
    If Not rsFreigabe.EOF Then
      maxversion = GetSafeFieldPlus(rsFreigabe, "MVersion", -1)
      If maxversion > Version Then
        AktuellsteFreigabeVersion = False
        aktVersion = maxversion
        Dim rs As Object
        Set rs = OpenRS("SELECT Dateiname FROM idvDateien WHERE idvDateiID=" & idvDateiID & " AND Version=" & aktVersion, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
        If Not rs Is Nothing Then
          If Not rs.EOF Then
            filePath = GetSafeField(rs, "Dateiname")
          End If
          rs.Close
          Set rs = Nothing
        End If
      End If
    End If
    rsFreigabe.Close
    Set rsFreigabe = Nothing
  End If
End Function


Function FreigabeIDGueltig(ByRef conn As Object, ByVal idvDateiID As Long, ByVal sucheFreigabeDateiID As Long) As Boolean

    FreigabeIDGueltig = False
    
    If sucheFreigabeDateiID = -100 Then
      Exit Function
    End If
    
    If idvDateiID = sucheFreigabeDateiID Then
        FreigabeIDGueltig = True
    Else
   
        Dim refId As Long
        refId = 0
        
        Dim rs As Object
        Set rs = OpenRS("SELECT ReferenzidvDateiID FROM idvDateien WHERE idvDateiID=" & idvDateiID, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
        If Not rs Is Nothing Then
          If Not rs.EOF Then
            refId = GetValueFromField(rs, "ReferenzidvDateiID", 0)
          End If
          rs.Close
        End If
        Set rs = Nothing
            
        If refId > 0 And refId <> idvDateiID Then
            FreigabeIDGueltig = FreigabeIDGueltig(conn, refId, sucheFreigabeDateiID)
        End If
    End If

End Function

'Function HatDateiAufgehobeneFreigabe(ByRef conn As Object, ByRef wbInExcelCurrentProjectInAccess As Object, ByVal idvDateiID As Long, ByVal Version As Long) As Boolean
'    Dim onlineFreigabeStatus As Long
'    Dim datFreigabeDatum As Date
'    Dim strFreigabeKommentar As String
'    Dim strUser As String
'    Dim freigabeDateiID As Long
'    Dim freigabeVersion As Long
    
'    Dim GetFreigabeStatus As Long
'    GetFreigabeStatus = -1
'    Dim rs As Object
'    Set rs = OpenRS("SELECT FreigabeidvDateiID,FreigabeVersion,Dateiname FROM idvDateien WHERE idvDateiID = " & idvDateiID & " and Version = " & Version, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockPessimistic)
'    If Not rs Is Nothing Then
'      GetFreigabeStatus = GetFreigabeStatusFromRS(conn, rs, wbInExcelCurrentProjectInAccess, strFreigabeKommentar, strUser, datFreigabeDatum, freigabeDateiID, freigabeVersion)
'      rs.Close
'      Set rs = Nothing
'    End If
    
'    HatDateiAufgehobeneFreigabe = IIf(GetFreigabeStatus = 2 Or GetFreigabeStatus = 3, True, False)
'End Function


Function DifferenceValues(ByVal valAlt, ByVal valNeu) As Long

    Dim vAlt As Long
    Dim vNeu As Long
    
    vAlt = 0
    vNeu = 0
    If IsNull(valAlt) Then
      vAlt = 0
    ElseIf IsNumeric(valAlt) Then
      vAlt = val(valAlt)
    End If
    If IsNull(valNeu) Then
      vNeu = 0
    ElseIf IsNumeric(valNeu) Then
      vNeu = val(valNeu)
    End If
    
    DifferenceValues = Abs(vNeu - vAlt)
    
End Function

Function DifferenceValues2(ByVal valAlt1, ByVal valAlt2, ByVal valNeu1, ByVal valNeu2) As Long

    Dim vAlt1 As Long
    Dim vNeu1 As Long
    Dim vAlt2 As Long
    Dim vNeu2 As Long
    
    vAlt1 = 0
    vNeu1 = 0
    vAlt2 = 0
    vNeu2 = 0
    If IsNull(valAlt1) Then
      vAlt1 = 0
    ElseIf IsNumeric(valAlt1) Then
      vAlt1 = val(valAlt1)
    End If
    If IsNull(valNeu1) Then
      vNeu1 = 0
    ElseIf IsNumeric(valNeu1) Then
      vNeu1 = val(valNeu1)
    End If
    If IsNull(valAlt2) Then
      vAlt2 = 0
    ElseIf IsNumeric(valAlt2) Then
      vAlt2 = val(valAlt2)
    End If
    If IsNull(valNeu2) Then
      vNeu2 = 0
    ElseIf IsNumeric(valNeu2) Then
      vNeu2 = val(valNeu2)
    End If
    
    DifferenceValues2 = (vNeu1 - vNeu2) - (vAlt1 - vAlt2)
    
End Function


Function CheckAblaufdatum(ByRef conn As Object, ByRef rs As Object, ByRef ablaufdatumStatus As Long, ByRef ablaufdatumText As String) As Boolean
  Dim s As String
  
  ablaufdatumStatus = 0
  CheckAblaufdatum = True
  
  Dim individuelleSperre As Boolean
  individuelleSperre = False
  
  If IsNull(rs.Fields("ErsteSpeicherung").value) Then Exit Function
  
  ' Als erstes wird das feste Endedatum gepr|fffd|ft, das pro Datei greift
  
  ' SperrungAb
  If Not IsNull(rs.Fields("SperrungAb").value) Then
    If rs.Fields("SperrungAb").value > #1/1/2000# Then
        individuelleSperre = True
        If rs.Fields("SperrungAb").value < Now Then
            'ablaufdatumText = GetLocString(conn, "SperrmeldungBeiAbgelaufenemDatum")
            ablaufdatumText = STDTEXT("SperrmeldungBeiAbgelaufenemDatum")
            CheckAblaufdatum = False
            ablaufdatumStatus = 2
            Exit Function
      End If
    End If
  End If
    
  ' WarnungAb
  If Not IsNull(rs.Fields("WarnungAb").value) Then
    If rs.Fields("WarnungAb").value > #1/1/2000# Then
        individuelleSperre = True
        If rs.Fields("WarnungAb").value < Now Then
          's = GetLocString(conn, "WarnmeldungBeiAbgelaufenemDatum")
            s = STDTEXT("WarnmeldungBeiAbgelaufenemDatum")
            If Not IsNull(rs.Fields("SperrungAb").value) Then
              If rs.Fields("SperrungAb").value > #1/1/2000# Then
                s = Replace(s, "#SPERRDATUM#", Format(rs.Fields("SperrungAb").value, "Short Date"))
              End If
              's = Replace(s, "#SPERRDATUM#", "unbekannt")
              s = Replace(s, "#SPERRDATUM#", FMT0("TRACKERSTUFF_29"))
            End If
            ablaufdatumText = s
            ablaufdatumStatus = 1
            Exit Function
        End If
    End If
  End If
  
  ' Wenn eine individuelle Sperre gesetzt war braucht der Rest nicht mehr gepr|fffd|ft zu werden!
  If individuelleSperre Then
    Exit Function
  End If
  
    
  
  ' Risikoklasse ermitteln und daraus evtl. Ablauftage errechnen.
  Dim riskrs As Object
  Set riskrs = CreateObject("ADODB.Recordset")
  Dim queryRisk As String
  queryRisk = "SELECT WarnungNachXTagen, Warnungstext, SperrungNachXTagen, Sperrentext, uWarnung.LokalisierterText as LocWarnung, uSperren.LokalisierterText as LocSperren " & _
  " FROM ((gRisikoklasse left join gTexteUebersetzungen uWarnung on (gRisikoklasse.WarnungstextTextID = uWarnung.TextID and uWarnung.LanguageID = " & GetMyDBLanguage(conn) & ")) " & _
  " left join gTexteUebersetzungen uSperren on (gRisikoklasse.SperrentextTextID = uSperren.TextID and uSperren.LanguageID = " & GetMyDBLanguage(conn) & ")) " & _
  " where gRisikoklasse.RisikowertVon <= " & str(rs.Fields("Risikowert").value) & " and " & str(rs.Fields("Risikowert").value) & " <= gRisikoklasse.RisikowertBis "

  riskrs.Open queryRisk, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
  If Not riskrs.EOF Then
      Dim tgSperre As Long
      Dim tgWarnung As Long
      
      Dim pruefDatum As Date
      ' ErsteSpeicherung wird oben gepr|fffd|ft, ob das NULL ist
      pruefDatum = GetSafeFieldPlus(rs, "WarnSperrPruefdatum", rs.Fields("ErsteSpeicherung").value)
      
      
      Dim ok As Boolean
      Dim i As Long
      ok = True
      If Not G_cfgIgnoreBlockPaths Is Nothing Then
        For i = 1 To G_cfgIgnoreBlockPaths.count
          If UCase(rs.Fields("Dateiname").value) Like UCase(G_cfgIgnoreBlockPaths(i)) Then
            ok = False
            Exit For
          End If
        Next i
      End If
      
      ' Erst mal die Sperrung checken
      tgSperre = GetValueFromField(riskrs, "SperrungNachXTagen", -1)
      If tgSperre >= 0 Then
        If DateAdd("d", tgSperre, pruefDatum) < Now Then
          If ok Then
              'ablaufdatumText = GetValueFromField(riskrs, "Sperrentext", "Die Datei ist gesperrt, die Datei wird geschlossen. Wenden Sie sich an Ihre Verantwortlichen f|fffd|r das Programmeinsatzverfahren")
              ablaufdatumText = GetLocValueFromField(riskrs, "Sperrentext", "LocSperren", FMT0("TRACKERSTUFF_3"))
              ablaufdatumStatus = 2
              CheckAblaufdatum = False
              riskrs.Close
              Set riskrs = Nothing
              Exit Function
          Else
            DebugPrint tdebug, "No block, path excluded with IGNOREBLOCK!"
          End If
        End If
      End If
      
      ' Und jetzt die Warnung
      ok = True
      If Not G_cfgIgnoreWarningPaths Is Nothing Then
        For i = 1 To G_cfgIgnoreWarningPaths.count
          If UCase(rs.Fields("Dateiname").value) Like UCase(G_cfgIgnoreWarningPaths(i)) Then
            ok = False
            Exit For
          End If
        Next i
      End If
      
      tgWarnung = GetValueFromField(riskrs, "WarnungNachXTagen", -1)
      If tgWarnung >= 0 Then
        If DateAdd("d", tgWarnung, pruefDatum) < Now Then
          If ok Then
              's = GetValueFromField(riskrs, "Warnungstext", "Achtung, die Datei wird demn|fffd|chst gesperrt, bitte f|fffd|hren Sie eine Programmfreigabe f|fffd|r die Datei durch.")
              s = GetLocValueFromField(riskrs, "Warnungstext", "LocWarnung", FMT0("TRACKERSTUFF_4"))
              If tgSperre >= 0 Then
                s = Replace(s, "#SPERRDATUM#", Format(DateAdd("d", tgSperre, pruefDatum), "Short Date"))
              End If
              's = Replace(s, "#SPERRDATUM#", "unbekannt")
              s = Replace(s, "#SPERRDATUM#", FMT0("TRACKERSTUFF_29"))
              
              ablaufdatumStatus = 1
              ablaufdatumText = s
          Else
            DebugPrint tdebug, "No warning, path excluded with IGNOREWARNING!"
          End If
        End If
      End If
      
  End If
  riskrs.Close
  Set riskrs = Nothing
  
End Function


Private Function SharedWorkbookUserCount(ByRef wbInExcelCurrentProjectInAccess As Object) As Long

On Error GoTo raus
  
    Dim users
    users = wbInExcelCurrentProjectInAccess.UserStatus
    
    SharedWorkbookUserCount = UBound(users)
    Exit Function
    
raus:
    SharedWorkbookUserCount = 0
End Function

' -1 - Schlie|fffd|en, das Workbook ist bereits zu!
' 0 - Schlie|fffd|en
' 1 - |fffd|ffnen
' 2 - |fffd|ffnen ohne SAVE AS

Function FreigabeCheck(ByRef officeapp As Object, ByRef wbInExcelCurrentProjectInAccess As Object, ByRef conn As Object) As Long

    Dim onlineFreigabeStatus As Long
    Dim freigabeDatum As Date
    Dim strFreigabeKommentar As String
    Dim strUser As String
    Dim freigabeDateiID As Long
    Dim freigabeVersion As Long
    Dim strDeaktivierenderUser As String
    Dim datumDeaktivierung As Date
    Dim strDeaktivierungKommentar As String
    strDeaktivierenderUser = ""
    strDeaktivierungKommentar = ""
    onlineFreigabeStatus = -1

    If DateiAusgeschlossen2(wbInExcelCurrentProjectInAccess, conn) Then
      FreigabeCheck = 1
      Exit Function
    End If
    
    DebugPrint tdebug, "idvDateiID: " & WBGetValueLong(wbInExcelCurrentProjectInAccess, "_IDVTrackerID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix)
    DebugPrint tdebug, "Version: " & WBGetValueLong(wbInExcelCurrentProjectInAccess, "_IDVTrackerVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix)

    FreigabeCheck = 0
    
    Dim curid As Long
    Dim hash As String
'    Dim onlineStatus As Long
    Dim tVersion As Long
    tVersion = -100
    
    Dim freigabeInitUser As String
'    onlineStatus = -1000
'    If G_PARAM_VierAp = True Then
'      freigabeInitUser = GetUserName
'    End If

    Dim wasLocked As Boolean
    Dim dbAvailable As Boolean

    Dim ablaufdatumStatus As Long
    Dim ablaufdatumText As String
    Dim befragungDurchfuehren As Boolean
    Dim dateiOeffnenPWOK As Boolean
    Dim keineID As Boolean
    Dim resultMsgBox
    
    ' Grunds|fffd|etzlich ists TRUE, da die Datei bereits ge|fffd|ffnet werden konnte, sonst w|fffd|ren wir nicht hier
    dateiOeffnenPWOK = True
    
    befragungDurchfuehren = False
    ablaufdatumStatus = 0 ' 1 = Warnung, 2 = Sperre
    
    Dim uncpathfname As String
    uncpathfname = GetUNCPath(wbInExcelCurrentProjectInAccess.fullname)
    
    keineID = False
    
    Dim rs As Object
    
    ' Online-Status holen und ggf. freigebender User
    If GetTargetRS(conn, uncpathfname, wbInExcelCurrentProjectInAccess, rs, curid, hash, ADODB.LockTypeEnum.adLockPessimistic, wasLocked) Then

foundTheFileUppercase:

      If curid = 0 Then
        keineID = True
      End If

      dbAvailable = True
      Dim changedFilename As Boolean
      changedFilename = False
      If Not rs.EOF Then
        If rs.Fields("Dateiname").value <> uncpathfname Then
            rs.Fields("Dateiname").value = uncpathfname
            rs.Fields("Hash").value = GetFileHash(officeapp, GetDateinameInDatenbank(uncpathfname))
            changedFilename = True
        End If
        tVersion = rs.Fields("Version").value
'        freigabeInitUser = GetValueFromField(rs, "SpeichernderUserLogonID", "")
        
        CheckAblaufdatum conn, rs, ablaufdatumStatus, ablaufdatumText

        If WBValueSet(wbInExcelCurrentProjectInAccess, "_IDVTrackerMajorVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix) = False Then
          WBSetValueLong wbInExcelCurrentProjectInAccess, "_IDVTrackerMajorVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, tVersion
          WBSetValueLong wbInExcelCurrentProjectInAccess, "_IDVTrackerMinorVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, 0
          SetSaved wbInExcelCurrentProjectInAccess
        End If
        
        If rs.Fields("BefragungDurchfuehren").value <> 0 Then
          befragungDurchfuehren = True
        End If
      End If
      
      ' 2 = Freigabe deaktiviert
      ' 1 = Freigabe abgelehnt
      ' 0 = Freigegeben
      ' -1 = Freigabe nicht initiiert
      ' -2 = Freigabe initiiert
      onlineFreigabeStatus = GetFreigabeStatusFromRS(conn, rs, _
                  wbInExcelCurrentProjectInAccess, _
                  strFreigabeKommentar, _
                  strUser, freigabeDatum, freigabeDateiID, freigabeVersion, strDeaktivierenderUser, datumDeaktivierung, strDeaktivierungKommentar)
                  
      dateiOeffnenPWOK = DateiOeffnenStandardPasswordOK(officeapp, wbInExcelCurrentProjectInAccess, conn, rs)
      
      If changedFilename Then
        rs.Update
      End If
      rs.Close
    Else
      If Not rs Is Nothing Then
        dbAvailable = True
      Else
        dbAvailable = False
      End If
    
      If Not rs Is Nothing Then
          rs.Close
          Set rs = Nothing
      End If
      
      ' kein Recordset gefunden
      ' finden wir einen |fffd|ber den UpperCase-Dateinamen?
      ' ACHTUNG NEU: Wir lassen hier auch M|fffd|tter zu wegen der Pr|fffd|fung des Zugriffs!!
      If GetTargetRS(conn, UCase(uncpathfname), wbInExcelCurrentProjectInAccess, rs, curid, hash, ADODB.LockTypeEnum.adLockPessimistic, wasLocked) Then
          If Not rs Is Nothing Then
            If rs.Fields("idvDateiID").value = WBGetValueLong(wbInExcelCurrentProjectInAccess, "_IDVTrackerID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix) And _
               rs.Fields("Version").value = WBGetValueLong(wbInExcelCurrentProjectInAccess, "_IDVTrackerVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix) And _
               UCase(rs.Fields("Dateiname").value) = UCase(uncpathfname) Then
              GoTo foundTheFileUppercase:
            Else
              dateiOeffnenPWOK = DateiOeffnenStandardPasswordOK(officeapp, wbInExcelCurrentProjectInAccess, conn, rs)
            End If
          End If
      End If
      
      onlineFreigabeStatus = GetFreigabeStatus(conn, _
            wbInExcelCurrentProjectInAccess, _
            strFreigabeKommentar, strUser, _
            freigabeDatum, freigabeDateiID, freigabeVersion, strDeaktivierenderUser, datumDeaktivierung, strDeaktivierungKommentar)
    
      ' hier unten hinschreiben, damit der Uppercase Dateinamen Test vorher l|fffd|uft
      keineID = True
    
    End If
    Set rs = Nothing
    
    
    ' Wenn dateiOeffnenPWOK nicht ok war ist hier Schluss!
    If dateiOeffnenPWOK = False Then
      FreigabeCheck = -1
      Exit Function
    End If
    
    
    
    
    If WBValueSet(wbInExcelCurrentProjectInAccess, "_IDVTrackerMajorVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix) = False Then
      WBSetValueLong wbInExcelCurrentProjectInAccess, "_IDVTrackerMajorVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, 1
      WBSetValueLong wbInExcelCurrentProjectInAccess, "_IDVTrackerMinorVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, 0
      SetSaved wbInExcelCurrentProjectInAccess
    End If
            
    If WBValueSet(wbInExcelCurrentProjectInAccess, "_IDVTrackerID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix) = False Then
        WBSetValueLong wbInExcelCurrentProjectInAccess, "_IDVTrackerID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, -100
        WBSetValueLong wbInExcelCurrentProjectInAccess, "_IDVTrackerVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, -1
        WBSetValueLong wbInExcelCurrentProjectInAccess, "_IDVTrackerMajorVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, 1
        WBSetValueLong wbInExcelCurrentProjectInAccess, "_IDVTrackerMinorVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, 0
        WBSetValueLong wbInExcelCurrentProjectInAccess, "_IDVTrackerFreigabeStatus" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, 0
        WBSetValueLong wbInExcelCurrentProjectInAccess, "_IDVTrackerFreigabeDateiID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, -1
        WBSetValueLong wbInExcelCurrentProjectInAccess, "_IDVTrackerFreigabeVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, -1
        #If PROJECT_ACCESSTRACKER = 0 Then
          wbInExcelCurrentProjectInAccess.saved = True
        #End If
    ElseIf WBGetValueLong(wbInExcelCurrentProjectInAccess, "_IDVTrackerFreigabeDateiID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix) > 0 Then
        If FreigabeIDGueltig(conn, _
        WBGetValueLong(wbInExcelCurrentProjectInAccess, "_IDVTrackerID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix), _
        WBGetValueLong(wbInExcelCurrentProjectInAccess, "_IDVTrackerFreigabeDateiID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix)) = False Then
        
        WBSetValueLong wbInExcelCurrentProjectInAccess, "_IDVTrackerFreigabeStatus" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, 0
        WBSetValueLong wbInExcelCurrentProjectInAccess, "_IDVTrackerFreigabeDateiID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, -1
        WBSetValueLong wbInExcelCurrentProjectInAccess, "_IDVTrackerFreigabeVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, -1
    
        Set rs = OpenRS("SELECT * FROM idvDateien WHERE idvDateiID = " & WBGetValueLong(wbInExcelCurrentProjectInAccess, "_IDVTrackerID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix), conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockPessimistic)
        If Not rs Is Nothing Then
          If Not rs.EOF Then
'            If IsCopy(wbInExcelCurrentProjectInAccess, rs) Then ' And rs.Fields("Erstellungsdatum").Value = ConvGermanDate(GetDocProp(wbInExcelCurrentProjectInAccess, "Creation date")) Then
              If _
                  GetSafeFieldPlus(rs, "FreigabeStatus", 0) <> 0 Or _
                  GetSafeFieldPlus(rs, "FreigabeidvDateiID", 0) <> 0 Or _
                  GetSafeFieldPlus(rs, "FreigabeVersion", 0) <> 0 Or _
                  GetSafeFieldPlus(rs, "FreigabeChecksumme", "") <> "" Then
                      rs.Fields("FreigabeStatus").value = 0
                      rs.Fields("FreigabeidvDateiID").value = 0
                      rs.Fields("FreigabeVersion").value = 0
                      rs.Fields("FreigabeChecksumme").value = ""
                      rs.Update
              End If
'            End If
          End If
          rs.Close
          Set rs = Nothing
        End If
        #If PROJECT_ACCESSTRACKER = 0 Then
          wbInExcelCurrentProjectInAccess.saved = True
        #End If
        End If
    End If
      
    ' muss die Datei risikobefragt werden?
    If IsFileReadOnly(wbInExcelCurrentProjectInAccess) = False And befragungDurchfuehren = True Then
        If GetTargetRS(conn, GetUNCPath(wbInExcelCurrentProjectInAccess.fullname), wbInExcelCurrentProjectInAccess, rs, curid, hash, ADODB.LockTypeEnum.adLockPessimistic, wasLocked) Then
          If Not rs.EOF Then
            ShowFragen GetUNCPath(wbInExcelCurrentProjectInAccess.fullname), wbInExcelCurrentProjectInAccess, rs, curid, tVersion, conn, False
          End If
        End If
        Set rs = Nothing
    End If
      
    ' SharedWorkbook und Kopie und nicht schreibgesch|fffd|tzt ge|fffd|ffnet!
    If WBGetValueLong(wbInExcelCurrentProjectInAccess, "_IDVTrackerID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix) > 0 And IsFileReadOnly(wbInExcelCurrentProjectInAccess) = False Then
        If IsSharedWorkbook(wbInExcelCurrentProjectInAccess) Then
            If keineID Then
            
                Select Case SharedWorkbookUserCount(wbInExcelCurrentProjectInAccess)
                Case 0
                    'MsgBox "ACHTUNG: Es handelt sich um eine Kopie einer Datei, f|fffd|r die die Excelfunktion 'Arbeitsmappe freigeben' aktiviert wurde. Die Anzahl der aktuell zugreifenden User kann nicht ermittelt werden, die Datei wird geschlossen.", vbExclamation, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                    MsgBox FMT0("TRACKERSTUFF_5"), vbExclamation, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                    FreigabeCheck = 0
                    Exit Function
                Case 1
                    'MsgBox "ACHTUNG: Es handelt sich um eine Kopie einer Datei, fur die die Excelfunktion 'Arbeitsmappe freigeben' aktiviert wurde. Bis Sie die Datei speichern, kann kein weiterer Benutzer auf diese Datei zugreifen.", vbExclamation, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                    ' MsgBox FMT0("TRACKERSTUFF_6"), vbExclamation, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                    ' Einfach mal speichern, damit die neue ID auch in die Datei geschrieben wird.
                    wbInExcelCurrentProjectInAccess.Save
                Case Else
                    
                    ' Komisch, das ist eine Kopie und sie hat noch keine ID! Der Erste der |fffd|ffnet m|fffd|sste der
                    ' Datei eigentlich eine gegeben haben! Also kann das nur bedeuten, dass Excel es mal wieder nicht
                    ' hinbekommen hat zu erkennen, dass es eine Kopie ist und damit gar kein User mehr auf der Datei h|fffd|ngt!
                    ' Dann einfach speichern und weiter!
                    wbInExcelCurrentProjectInAccess.Save
                    
'                    Dim userList As String
'                    userList = SharedWorkbookUserList(wbInExcelCurrentProjectInAccess)
'
'                    Dim res
'                    'res = MsgBox("ACHTUNG: Es handelt sich um eine Kopie einer Datei, f|fffd|r die die Excelfunktion 'Arbeitsmappe freigeben' aktiviert wurde. Die Datei wird bereits verwendet. Sollen die anderen Benutzer getrennt (JA) oder die Datei geschlossen werden (NEIN)?", vbYesNo + vbQuestion, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")")
'                    res = MsgBox(FMT0("TRACKERSTUFF_7"), vbYesNo + vbQuestion, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")")
'                    If res = vbYes Then
'                       ClearSharedWorkbookUsers wbInExcelCurrentProjectInAccess
'                        If SharedWorkbookUserCount(wbInExcelCurrentProjectInAccess) > 1 Then
'                            userList = SharedWorkbookUserList(wbInExcelCurrentProjectInAccess)
'
'                            'MsgBox "ACHTUNG: Nicht alle Benutzer konnten getrennt werden. Die Datei wird geschlossen.", vbExclamation, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
'                            If userList <> "" Then
'                                MsgBox FMT1("TRACKERSTUFF_34", userList), vbExclamation, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
'                            Else
'                                MsgBox FMT0("TRACKERSTUFF_8"), vbExclamation, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
'                            End If
'                            FreigabeCheck = 0
'                            Exit Function
'                        End If
'                    Else
'                        FreigabeCheck = 0
'                        Exit Function
'                    End If
                End Select
            End If
        End If
    End If
      
    ' ---------------------------------------------------------------
    ' Datei hat Status "Freigabe Deaktiviert"
    ' ---------------------------------------------------------------
    If WBGetValueLong(wbInExcelCurrentProjectInAccess, "_IDVTrackerFreigabeStatus" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix) = 3 Then
        If onlineFreigabeStatus <> 2 Then
            ' was soll hier passieren, darf eigentlich nicht vorkommen
        
        ' ---------------------------------------------------------------
        ' wenn die Dateifreigabe aufgehoben wurde
        ' ---------------------------------------------------------------
        ElseIf onlineFreigabeStatus = 2 Then
           ' Die Freigabe dieser Datei wurde am %1 von %2 beendet! Sie d|fffd|rfen diese Datei nicht mehr produktiv verwenden!\n\nHinweis: %3\n\nWenn Sie diese Datei weiter dokumentieren oder auch erneut freigeben m|fffd|chten, m|fffd|ssen Sie eine neue Version der Datei erzeugen. Soll eine neue Version angelegt werden?
           resultMsgBox = MsgBox(FMT3("TRACKERSTUFF_36", datumDeaktivierung, strDeaktivierenderUser, strDeaktivierungKommentar), vbYesNo, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")")
           If resultMsgBox = vbYes Then
            DoNewVersion officeapp, wbInExcelCurrentProjectInAccess
           End If
        End If
        
    ' ---------------------------------------------------------------
    ' Datei noch im FREIGABE INITIIERT Status = 1 ??
    ' ---------------------------------------------------------------
    ' Initiiert steht in der Datei, der Online Freigabestatus ist aber -1 (und nicht -2, das ist der neue Status f|fffd|r initiiert beim OnlineStatus
    ElseIf WBGetValueLong(wbInExcelCurrentProjectInAccess, "_IDVTrackerFreigabeStatus" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix) = 1 _
      And onlineFreigabeStatus = -1 And dbAvailable = True _
      And ( _
                  WBGetValueLong(wbInExcelCurrentProjectInAccess, "_IDVTrackerID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix) = curid Or _
                  WBGetValueLong(wbInExcelCurrentProjectInAccess, "_IDVTrackerVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix) = tVersion _
              ) Then
      ' Dann nehmen wir die Initiierung weg
      If GetTargetRS(conn, GetUNCPathFromDoc(wbInExcelCurrentProjectInAccess), wbInExcelCurrentProjectInAccess, rs, curid, hash, ADODB.LockTypeEnum.adLockPessimistic, wasLocked) Then
        FreigabeAbbrechen rs, officeapp, wbInExcelCurrentProjectInAccess, conn, G_PARAM_IncVersBeiInitAbbruch, False, False
        rs.Close
        Set rs = Nothing
      Else
        WBSetValueLong wbInExcelCurrentProjectInAccess, "_IDVTrackerFreigabeStatus" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, 0
        WBSetValueLong wbInExcelCurrentProjectInAccess, "_IDVTrackerFreigabeDateiID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, -1
        WBSetValueLong wbInExcelCurrentProjectInAccess, "_IDVTrackerFreigabeVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, -1
      End If
      MsgBox FMT1("TRACKERSTUFF_18", ""), vbExclamation, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
      
    ElseIf WBGetValueLong(wbInExcelCurrentProjectInAccess, "_IDVTrackerFreigabeStatus" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix) = 1 Then
      
      
          ' ---------------------------------------------------------------
          ' Kein Connect?
          ' ---------------------------------------------------------------
          If Not dbAvailable Then
              onlineFreigabeStatus = -1
          End If
          
          
          
          ' ---------------------------------------------------------------
          ' Connect war da, aber den Dateieintrag gibt es nicht in der Tabelle idvDateien?
          ' Dann ist das die Kopie einer Datei, die im Freigabeprozess wartet. Das ist nicht erlaubt!
          ' ---------------------------------------------------------------
          ' Initiiert oder nicht initiiert
          If (onlineFreigabeStatus = -1 Or onlineFreigabeStatus = -2) And ( _
                  WBGetValueLong(wbInExcelCurrentProjectInAccess, "_IDVTrackerID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix) <> curid Or _
                  WBGetValueLong(wbInExcelCurrentProjectInAccess, "_IDVTrackerVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix) <> tVersion _
              ) Then
                  DebugPrint tdebug, "WBOpen1: " & GetUNCPath(wbInExcelCurrentProjectInAccess.fullname)
                  Set rs = OpenRS("SELECT * FROM idvDateien WHERE idvDateiID=" & WBGetValueLong(wbInExcelCurrentProjectInAccess, "_IDVTrackerID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix), conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
                  Dim kopieIdvDateiID As Long
                  kopieIdvDateiID = WBGetValueLong(wbInExcelCurrentProjectInAccess, "_IDVTrackerID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix)
                  
                  ' Wenn es sich um eine Tempdatei handelt, dann wird eine eventuelle Freigabeinitiierung einfach entfernt und basta
                  If GetSetting(appname:="Stromwerken", Section:=progNameShort, Key:="DokuOK", Default:="") = UCase(GetFileNameAndExtension(wbInExcelCurrentProjectInAccess.fullname)) Then
                      WBSetValueLong wbInExcelCurrentProjectInAccess, "_IDVTrackerFreigabeStatus" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, 0
                  Else
                      Dim Result
                      If Not rs Is Nothing Then
                        If Not rs.EOF Then
                          'result = MsgBox("ACHTUNG: Es handelt sich um ein Duplikat der Datei '" & rs.Fields("Dateiname").value & "', die nach der Freigabeinitiierung umbenannt, kopiert oder verschoben wurde." & vbCrLf & vbCrLf & "Sie k|fffd|nnen die Datei schlie|fffd|en (JA) oder die Freigabeinitiierung f|fffd|r die aktuelle Datei verwerfen und bei Bedarf neu starten (NEIN)." & vbCrLf & vbCrLf & "M|fffd|chten Sie die Datei schlie|fffd|en?", vbYesNo, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")")
                          Result = MsgBox(FMT1("TRACKERSTUFF_9", rs.Fields("Dateiname").value), vbYesNo, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")")
                        Else
                          'result = MsgBox("ACHTUNG: Es handelt sich um ein Duplikat einer Datei, die nach der Freigabeinitiierung umbenannt, kopiert oder verschoben wurde." & vbCrLf & vbCrLf & "Sie k|fffd|nnen die Datei schlie|fffd|en (JA) oder die Freigabeinitiierung f|fffd|r die aktuelle Datei verwerfen und bei Bedarf neu starten (NEIN)." & vbCrLf & vbCrLf & "M|fffd|chten Sie die Datei schlie|fffd|en?", vbYesNo, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")")
                          Result = MsgBox(FMT0("TRACKERSTUFF_10"), vbYesNo, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")")
                        End If
                        rs.Close
                      Else
                        'result = MsgBox("ACHTUNG: Es handelt sich um ein Duplikat einer Datei, die nach der Freigabeinitiierung umbenannt, kopiert oder verschoben wurde." & vbCrLf & vbCrLf & "Sie k|fffd|nnen die Datei schlie|fffd|en (JA) oder die Freigabeinitiierung f|fffd|r die aktuelle Datei verwerfen und bei Bedarf neu starten (NEIN)." & vbCrLf & vbCrLf & "M|fffd|chten Sie die Datei schlie|fffd|en?", vbYesNo, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")")
                        Result = MsgBox(FMT0("TRACKERSTUFF_10"), vbYesNo, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")")
                      End If
                      Set rs = Nothing
                      
                      If Result = vbYes Then
                        FreigabeCheck = 0
                        Exit Function
                      End If
                      
                      ' Wert hier schon zur|fffd|cksetzen, sonst merkert das BeforeSave wegen FreigabeInitiierung kann nicht gespeichert werden
                      WBSetValueLong wbInExcelCurrentProjectInAccess, "_IDVTrackerFreigabeStatus" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, 0
                      wbInExcelCurrentProjectInAccess.Save
                      Set rs = OpenRS("SELECT * FROM idvDateien WHERE idvDateiID=" & WBGetValueLong(wbInExcelCurrentProjectInAccess, "_IDVTrackerID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix), conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockPessimistic)
                      If Not rs Is Nothing Then
                        If rs.EOF = False Then
                            ' nur die Freigabe Entfernen, wenn das mit dem kopieren auch geklappt hat
                            If rs.Fields("idvDateiID").value <> kopieIdvDateiID Then
                                'FreigabeEntfernenBeimOeffnen officeapp, rs, conn, wbInExcelCurrentProjectInAccess, "Freigabe entfernt wg. Kopie von Datei ID " & rs.Fields("idvDateiID").value, True
                                FreigabeEntfernenBeimOeffnen officeapp, rs, conn, wbInExcelCurrentProjectInAccess, FMT1("TRACKERSTUFF_11", rs.Fields("idvDateiID").value), True
                            End If
                        End If
                        rs.Close
                        Set rs = Nothing
                      End If
                  End If
                  
                  SetSaved wbInExcelCurrentProjectInAccess
          
          ' ---------------------------------------------------------------
          ' Immer noch nicht freigegeben?
          ' ---------------------------------------------------------------
          ElseIf onlineFreigabeStatus = -1 Or onlineFreigabeStatus = -2 Then
                      Dim msgboxtxt As String
                      If G_cfgSaveNachInit Then
                        ' Achtung, diese Datei befindet sich aktuell im Freigabeprozess.
                        msgboxtxt = FMT0("TRACKERSTUFF_37")
                      Else
                        'MsgBox "Achtung, diese Datei befindet sich aktuell im Freigabeprozess und kann nicht gespeichert werden! Wenn Sie die Datei speichern wollen, m|fffd|ssen Sie eine neue Version erzeugen (Dies f|fffd|hrt dann automatisch zu einem Abbruch des Freigabeverfahrens).", vbCritical, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                        msgboxtxt = FMT0("TRACKERSTUFF_12")
                      End If
                      
                      If GetSetting(appname:="Stromwerken", Section:="ExcelTracker", Key:="IgnoreThisOneWarning", Default:="False") <> "True" Then
                        MsgBox msgboxtxt, vbExclamation, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                      End If
                      SaveSetting appname:="Stromwerken", Section:=ProgNameLong, Key:="IgnoreThisOneWarning", Setting:="False"
      
          ' ---------------------------------------------------------------
          ' Inzwischen freigegeben?
          ' ---------------------------------------------------------------
          ElseIf onlineFreigabeStatus = 0 Then
              
'              If strUser <> GetUserName() And _
'                  WBGetValueLong(wbInExcelCurrentProjectInAccess, "_IDVTrackerID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix) = curId And _
'                  WBGetValueLong(wbInExcelCurrentProjectInAccess, "_IDVTrackerVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix) = myVersion Then
'                  MsgBox "Achtung, die Freigabe zu dieser Datei wurde inzwischen erteilt!" & IIf(strFreigabeKommentar <> "", vbCrLf & vbCrLf & "Kommentar von " & strUser & ": " & strFreigabeKommentar, ""), vbCritical, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
'              End If
              WBSetValueLong wbInExcelCurrentProjectInAccess, "_IDVTrackerFreigabeStatus" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, 2
              WBSetValueLong wbInExcelCurrentProjectInAccess, "_IDVTrackerFreigabeDateiID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, freigabeDateiID
              WBSetValueLong wbInExcelCurrentProjectInAccess, "_IDVTrackerFreigabeVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, freigabeVersion
              SetSaved wbInExcelCurrentProjectInAccess
            
          ' ---------------------------------------------------------------
          ' Freigabe abgelehnt?
          ' ---------------------------------------------------------------
          ElseIf onlineFreigabeStatus = 1 Then
              
'              If strUser <> GetUserName() And _
'                  WBGetValueLong(wbInExcelCurrentProjectInAccess, "_IDVTrackerID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix) = curId And _
'                  WBGetValueLong(wbInExcelCurrentProjectInAccess, "_IDVTrackerVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix) = myVersion Then
'                  MsgBox "Achtung, die Freigabe zu dieser Datei wurde nicht erteilt! Der Freigabestatus wird zur|fffd|ck gesetzt!" & IIf(strFreigabeKommentar <> "", vbCrLf & vbCrLf & "Kommentar von " & strUser & ": " & strFreigabeKommentar, ""), vbCritical, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
'              End If
              If GetTargetRS(conn, GetUNCPathFromDoc(wbInExcelCurrentProjectInAccess), wbInExcelCurrentProjectInAccess, rs, curid, hash, ADODB.LockTypeEnum.adLockPessimistic, wasLocked) Then
                FreigabeAbbrechen rs, officeapp, wbInExcelCurrentProjectInAccess, conn, G_PARAM_IncVersBeiInitAbbruch, False, False
                rs.Close
                Set rs = Nothing
              Else
                WBSetValueLong wbInExcelCurrentProjectInAccess, "_IDVTrackerFreigabeStatus" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, 0
                WBSetValueLong wbInExcelCurrentProjectInAccess, "_IDVTrackerFreigabeDateiID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, -1
                WBSetValueLong wbInExcelCurrentProjectInAccess, "_IDVTrackerFreigabeVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, -1
              End If
              'MsgBox "Achtung, die Freigabe zu dieser Datei wurde nicht erteilt! Der Freigabestatus wird zur|fffd|ck gesetzt!" & IIf(strFreigabeKommentar <> "", vbCrLf & vbCrLf & "Kommentar von " & strUser & ": " & strFreigabeKommentar, ""), vbCritical, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
              MsgBox FMT1("TRACKERSTUFF_18", IIf(strFreigabeKommentar <> "", FMT2("TRACKERSTUFF_19", strUser, strFreigabeKommentar), "")), vbExclamation, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
          
        ' ---------------------------------------------------------------
        ' wenn die Dateifreigabe aufgehoben wurde
        ' ---------------------------------------------------------------
        ElseIf onlineFreigabeStatus = 2 Then
            WBSetValueLong wbInExcelCurrentProjectInAccess, "_IDVTrackerFreigabeStatus" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, 3
           
           resultMsgBox = MsgBox(FMT3("TRACKERSTUFF_36", datumDeaktivierung, strDeaktivierenderUser, strDeaktivierungKommentar), vbYesNo, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")")
           If resultMsgBox = vbYes Then
            DoNewVersion officeapp, wbInExcelCurrentProjectInAccess
           End If
        End If
      
    ' ---------------------------------------------------------------
    ' Datei noch im Ursprungszustand?
    ' ---------------------------------------------------------------
    ElseIf WBGetValueLong(wbInExcelCurrentProjectInAccess, "_IDVTrackerFreigabeStatus" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix) <= 0 Then
        
        ' ---------------------------------------------------------------
        ' Wenn die Datei keinen DateiID und keine Version hat, dann k|fffd|nnte sie aber trotzdem freigegeben sein...
        ' ---------------------------------------------------------------
        If WBGetValueLong(wbInExcelCurrentProjectInAccess, "_IDVTrackerID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix) = -100 And WBGetValueLong(wbInExcelCurrentProjectInAccess, "_IDVTrackerVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix) = -100 Then
            ' Dann mal schauen, ob es den Dateinamen schon gibt
            DebugPrint tdebug, "WBOpen2: " & GetUNCPath(wbInExcelCurrentProjectInAccess.fullname)
            Set rs = OpenRS("SELECT idvDateiID, Version, Dateiname FROM idvDateien WHERE Dateiname LIKE '" & Replace(GetUNCPath(wbInExcelCurrentProjectInAccess.fullname), "'", "_") & "' AND FreigabeStatus = 2 and Geloescht = 0 and Checksumme = FreigabeChecksumme", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
            If Not rs Is Nothing Then
            
              uncpathfname = GetUNCPath(wbInExcelCurrentProjectInAccess.fullname)
              
              Do While Not rs.EOF
                If rs.Fields("Dateiname").value = uncpathfname Then
                  ' Cool, hier gibt es eine Freigabe!!!
                  WBSetValueLong wbInExcelCurrentProjectInAccess, "_IDVTrackerFreigabeStatus" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, 2
                  WBSetValueLong wbInExcelCurrentProjectInAccess, "_IDVTrackerID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, rs.Fields("idvDateiID").value
                  WBSetValueLong wbInExcelCurrentProjectInAccess, "_IDVTrackerVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, rs.Fields("Version").value
                  WBSetValueLong wbInExcelCurrentProjectInAccess, "_IDVTrackerFreigabeDateiID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, rs.Fields("idvDateiID").value
                  WBSetValueLong wbInExcelCurrentProjectInAccess, "_IDVTrackerFreigabeVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, rs.Fields("Version").value
                  Exit Do
                End If
                rs.MoveNext
              Loop
              rs.Close
            End If
            Set rs = Nothing
        ' ---------------------------------------------------------------
        ' Inzwischen freigegeben?
        ' ---------------------------------------------------------------
        ElseIf onlineFreigabeStatus = 0 Then
            WBSetValueLong wbInExcelCurrentProjectInAccess, "_IDVTrackerFreigabeStatus" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, 2
            WBSetValueLong wbInExcelCurrentProjectInAccess, "_IDVTrackerFreigabeDateiID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, freigabeDateiID
            WBSetValueLong wbInExcelCurrentProjectInAccess, "_IDVTrackerFreigabeVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, freigabeVersion
        ' ---------------------------------------------------------------
        ' wenn die Dateifreigabe aufgehoben wurde
        ' ---------------------------------------------------------------
        ElseIf onlineFreigabeStatus = 2 Then
            WBSetValueLong wbInExcelCurrentProjectInAccess, "_IDVTrackerFreigabeStatus" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, 3
           
           resultMsgBox = MsgBox(FMT3("TRACKERSTUFF_36", datumDeaktivierung, strDeaktivierenderUser, strDeaktivierungKommentar), vbYesNo, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")")
           If resultMsgBox = vbYes Then
            DoNewVersion officeapp, wbInExcelCurrentProjectInAccess
           End If
        ' ---------------------------------------------------------------
        ' Nicht freigegeben und nix, dann mal nach Warnmeldungen schauen.
        ' ---------------------------------------------------------------
        Else
            ' Jetzt wird gecheckt, ob der Warning-Termin oder der Sperre-Termin bereits abgelaufen ist
            ' Sperrung?
            
            If keineID Then
              Set rs = OpenRS("SELECT ErsteSpeicherung, SperrungAb, WarnungAb, Risikowert, Dateiname, WarnSperrPruefdatum FROM idvDateien WHERE idvDateiID = " & WBGetValueLong(wbInExcelCurrentProjectInAccess, "_IDVTrackerID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix), conn, ADODB.CursorTypeEnum.adOpenForwardOnly, ADODB.LockTypeEnum.adLockReadOnly)
              If Not rs Is Nothing Then
                If Not rs.EOF Then
                  CheckAblaufdatum conn, rs, ablaufdatumStatus, ablaufdatumText
                End If
                rs.Close
              End If
              Set rs = Nothing
            End If
            
            If ablaufdatumStatus = 2 Then
              MsgBox ablaufdatumText, vbExclamation, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
              ' Datei schlie|fffd|en
              FreigabeCheck = 0
              Exit Function
            ElseIf ablaufdatumStatus = 1 Then
               MsgBox ablaufdatumText, vbInformation, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
            End If
        End If
    End If
    ' ---------------------------------------------------------------
    ' Datei freigegeben
    ' ---------------------------------------------------------------
    If WBGetValueLong(wbInExcelCurrentProjectInAccess, "_IDVTrackerFreigabeStatus" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix) = 2 Then
        ' ---------------------------------------------------------------
        ' wenn die Dateifreigabe aufgehoben wurde
        ' ---------------------------------------------------------------
        If onlineFreigabeStatus = 2 Then
            WBSetValueLong wbInExcelCurrentProjectInAccess, "_IDVTrackerFreigabeStatus" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, 3
           
           resultMsgBox = MsgBox(FMT3("TRACKERSTUFF_36", datumDeaktivierung, strDeaktivierenderUser, strDeaktivierungKommentar), vbYesNo, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")")
           If resultMsgBox = vbYes Then
            DoNewVersion officeapp, wbInExcelCurrentProjectInAccess
           End If
           
        ElseIf MMFreigabe(officeapp, wbInExcelCurrentProjectInAccess, conn, curid, True, False) = 0 Then
            FreigabeCheck = 0 ' Datei Schlie|fffd|en!
            Exit Function
        End If
                                
        SetzeAmpelStatus wbInExcelCurrentProjectInAccess, conn

    End If

    FreigabeCheck = 1
End Function

Public Sub GetLetzteMajorFreigabeDateiID(ByRef conn As Object, ByVal curid As Long, ByRef letzteMajorFreigabeDateiID As Long, _
  ByRef letzteMajorFreigabeVersion As Long, ByRef letzteMajorFreigabeDatum As Date, ByRef letzteMajorFreigabeVersionMM As String)

    Dim aktID As Long
    aktID = curid
    
    letzteMajorFreigabeDateiID = -1
    letzteMajorFreigabeVersion = -1
    
    Do While True = True
        Dim rs As Object
        Set rs = CreateObject("ADODB.Recordset")
        rs.Open "Select idvdateien.idvDateiID, idvdateien.Version, idvdateien.ReferenzidvDateiID, idvdateien.MajorVersion, idvdateien.MinorVersion, idvdateien.FreigabeIDVDateiID, idvdateien.FreigabeVersion, idvdateienfreigaben.Datum from idvDateien join idvdateienfreigaben on idvDateien.idvDateiID = idvdateienfreigaben.idvDateiID and idvdateien.Version = idvdateienfreigaben.Version and idvdateienfreigaben.Status = 0  where idvdateien.idvDateiID = " & curid, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
        If rs Is Nothing Then
            Exit Sub
        ElseIf rs.EOF = False Then
            If rs.Fields("FreigabeIDVDateiID").value <> 0 And rs.Fields("FreigabeIDVDateiID").value <> curid Then
                curid = rs.Fields("FreigabeIDVDateiID").value
            Else
                If rs.Fields("MinorVersion").value = 0 Or rs.Fields("MinorVersion").value = -100 Then
                    letzteMajorFreigabeDateiID = rs.Fields("idvDateiID").value
                    letzteMajorFreigabeVersion = rs.Fields("Version").value
                    letzteMajorFreigabeDatum = GetSafeFieldPlus(rs, "Datum", Now)
                    letzteMajorFreigabeVersionMM = GetSafeFieldPlus(rs, "MajorVersion", "") & "." & GetSafeFieldPlus(rs, "MinorVersion", "")
                    rs.Close
                    Set rs = Nothing
                    Exit Sub
                End If
                
                Dim newid As Long
                newid = rs.Fields("ReferenzidvDateiID").value
                If newid = 0 Or newid >= curid Then
                    rs.Close
                    Set rs = Nothing
                    Exit Sub
                End If
                curid = newid
            End If
        Else
            letzteMajorFreigabeDateiID = aktID
            letzteMajorFreigabeVersion = 1
            rs.Close
            Set rs = Nothing
            Exit Sub
        End If
        rs.Close
        Set rs = Nothing
  
    
    Loop
    



End Sub

Sub FreigabeEntfernenBeimOeffnen(ByRef officeapp As Object, ByRef rs As Object, ByRef conn As Object, ByRef curdoc As Object, grund As String, majorErhoehen As Boolean)

  FreigabeEntfernenAlleVariablen officeapp, rs, conn, curdoc
  
  If G_cfgAutoProtectBeiInit > 0 Then
      BlattschutzEntfernen conn, rs, officeapp, curdoc, False
  End If

  DoInternalSave rs, curdoc, conn
  
  rs.Update
  
End Sub

Sub FreigabeEntfernenMitID(ByRef pluginapp As Object, ByVal curid As Long, ByRef conn As Object, ByRef curdoc As Object, grund As String, giveInfo As Boolean)
  ' Major Change, Freigabe wird aufgehoben
  Dim rs As Object
  Set rs = OpenRS("SELECT * FROM idvDateien WHERE idvDateiID = " & curid, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockPessimistic)
  If Not rs Is Nothing Then
    If Not rs.EOF Then
      FreigabeEntfernen pluginapp, rs, conn, curdoc, grund, giveInfo
    End If
    rs.Close
    Set rs = Nothing
  End If
End Sub

Sub FreigabeEntfernenAlleVariablen(ByRef pluginapp As Object, ByRef rs As Object, ByRef conn As Object, ByRef curdoc As Object)
  
  WBSetValueLong curdoc, "_IDVTrackerFreigabeDateiID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, -1
  WBSetValueLong curdoc, "_IDVTrackerFreigabeVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, -1
  WBSetValueLong curdoc, "_IDVTrackerID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, rs.Fields("idvDateiID").value
  WBSetValueLong curdoc, "_IDVTrackerVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, rs.Fields("Version").value
  rs.Fields("FreigabeStatus").value = 0
  rs.Fields("FreigabeidvDateiID").value = 0
  rs.Fields("FreigabeVersion").value = 0
  rs.Fields("FreigabeChecksumme").value = ""
  rs.Fields("FreigabeInitiierung").value = Empty
  rs.Fields("FreigabeInitUserLogonID").value = ""
  WBSetValueLong curdoc, "_IDVTrackerFreigabeStatus" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, 0
  rs.Fields("WarnSperrPruefdatum").value = Now

End Sub

Sub FreigabeEntfernen(ByRef pluginapp As Object, ByRef rs As Object, ByRef conn As Object, ByRef curdoc As Object, grund As String, giveInfo As Boolean)

  Dim sBetreff As String
  Dim sText As String

  sBetreff = G_PARAM_SMTPFreigabeAbbruchBetreff
  sText = G_PARAM_SMTPMailFreigabeAbbruch

  ReplaceStuff curdoc, sBetreff, rs
  ReplaceStuff curdoc, sText, rs
  ReplaceStuffInitiator sBetreff, conn, GetUserName()
  ReplaceStuffInitiator sText, conn, GetUserName()

  InformAdmins G_PARAM_StoreMailsToTable, conn, sBetreff, sText, grund, "", ""

  WBSetValueLong curdoc, "_IDVTrackerFreigabeDateiID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, -1
  WBSetValueLong curdoc, "_IDVTrackerFreigabeVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, -1
  
  CreateNewRecordset GetUNCPathFromDoc(curdoc), curdoc.fullname, curdoc, rs, conn
  
  ' Datei-ID und Version haben sich ge|fffd|ndert
  WBSetValueLong curdoc, "_IDVTrackerID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, rs.Fields("idvDateiID").value
  WBSetValueLong curdoc, "_IDVTrackerVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, rs.Fields("Version").value
  rs.Fields("FreigabeStatus").value = 0
  rs.Fields("FreigabeidvDateiID").value = 0
  rs.Fields("FreigabeVersion").value = 0
  rs.Fields("FreigabeChecksumme").value = ""
  rs.Fields("FreigabeInitiierung").value = Empty
  rs.Fields("FreigabeInitUserLogonID").value = ""
  WBSetValueLong curdoc, "_IDVTrackerFreigabeStatus" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, 0
  rs.Fields("WarnSperrPruefdatum").value = Now
  
  MajorVersionErhoehen rs
  WBSetValueLong curdoc, "_IDVTrackerMajorVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, rs.Fields("MajorVersion").value
  WBSetValueLong curdoc, "_IDVTrackerMinorVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, rs.Fields("MinorVersion").value
  
  If G_cfgAutoProtectBeiInit > 0 Then
      BlattschutzEntfernen conn, rs, pluginapp, curdoc, False
  End If
  
  DoInternalSave rs, curdoc, conn
  LogSpeichern rs, curdoc, conn
  
  rs.Update
  
  ' FreigabeStatus ist hier immer 2
  If giveInfo = True Then
    CheckMailEvent curdoc, ME_FreigabeAbgebrochen, rs, conn
  End If

  'MsgBox "Die Programmfreigabe f|fffd|r diese Datei wurde aufgehoben" & IIf(G_PARAM_SMTPMailVersandAktiv, ", die Administration informiert", "") & " und die Version erh|fffd|ht.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
  MsgBox FMT1("TRACKERSTUFF_25", IIf(G_PARAM_SMTPMailVersandAktiv, FMT0("TRACKERSTUFF_26"), "")), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"

  ShowAmpelStatus curdoc
End Sub

Function GetStringValueFromToupleCollection(ByRef col As Collection, ByVal textID As String) As String
  On Error GoTo nogo
  GetStringValueFromToupleCollection = col(textID)
nogo:
End Function

Function GetSchutzbedarfTextFromLong(val As Long, bezeichner As String) As String
  GetSchutzbedarfTextFromLong = FMT0("DOKUALG_60")
  
  Select Case bezeichner
    Case "Schutzbedarf"
          Select Case val
            Case 1
              GetSchutzbedarfTextFromLong = G_PARAM_Schutzbedarf_Gering
            Case 2
              GetSchutzbedarfTextFromLong = G_PARAM_Schutzbedarf_Mittel
            Case 3
              GetSchutzbedarfTextFromLong = G_PARAM_Schutzbedarf_Hoch
            Case 4
              GetSchutzbedarfTextFromLong = G_PARAM_Schutzbedarf_Sehr_hoch
            Case Else
              'GetSchutzbedarfTextFromLong = "Unbewertet"
              GetSchutzbedarfTextFromLong = FMT0("DOKUALG_60")
          End Select
    Case "Vertraulichkeit"
          Select Case val
            Case 1
              GetSchutzbedarfTextFromLong = G_PARAM_Vertraulichkeit_Gering
            Case 2
              GetSchutzbedarfTextFromLong = G_PARAM_Vertraulichkeit_Mittel
            Case 3
              GetSchutzbedarfTextFromLong = G_PARAM_Vertraulichkeit_Hoch
            Case 4
              GetSchutzbedarfTextFromLong = G_PARAM_Vertraulichkeit_Sehr_hoch
            Case Else
              'GetSchutzbedarfTextFromLong = "Unbewertet"
              GetSchutzbedarfTextFromLong = FMT0("DOKUALG_60")
          End Select
    Case "Integritaet"
          Select Case val
            Case 1
              GetSchutzbedarfTextFromLong = G_PARAM_Integritaet_Gering
            Case 2
              GetSchutzbedarfTextFromLong = G_PARAM_Integritaet_Mittel
            Case 3
              GetSchutzbedarfTextFromLong = G_PARAM_Integritaet_Hoch
            Case 4
              GetSchutzbedarfTextFromLong = G_PARAM_Integritaet_Sehr_hoch
            Case Else
              'GetSchutzbedarfTextFromLong = "Unbewertet"
              GetSchutzbedarfTextFromLong = FMT0("DOKUALG_60")
          End Select
    Case "Verfuegbarkeit"
          Select Case val
            Case 1
              GetSchutzbedarfTextFromLong = G_PARAM_Verfuegbarkeit_Gering
            Case 2
              GetSchutzbedarfTextFromLong = G_PARAM_Verfuegbarkeit_Mittel
            Case 3
              GetSchutzbedarfTextFromLong = G_PARAM_Verfuegbarkeit_Hoch
            Case 4
              GetSchutzbedarfTextFromLong = G_PARAM_Verfuegbarkeit_Sehr_hoch
            Case Else
              'GetSchutzbedarfTextFromLong = "Unbewertet"
              GetSchutzbedarfTextFromLong = FMT0("DOKUALG_60")
          End Select
    Case "Authentizitaet"
          Select Case val
            Case 1
              GetSchutzbedarfTextFromLong = G_PARAM_Authentizitaet_Gering
            Case 2
              GetSchutzbedarfTextFromLong = G_PARAM_Authentizitaet_Mittel
            Case 3
              GetSchutzbedarfTextFromLong = G_PARAM_Authentizitaet_Hoch
            Case 4
              GetSchutzbedarfTextFromLong = G_PARAM_Authentizitaet_Sehr_hoch
            Case Else
              'GetSchutzbedarfTextFromLong = "Unbewertet"
              GetSchutzbedarfTextFromLong = FMT0("DOKUALG_60")
          End Select
    End Select
End Function

Function GetSchutzbedarfText(ByRef fld As Object, ByVal bezeichner As String) As String
  If IsNull(fld.value) Then
    GetSchutzbedarfText = FMT0("DOKUALG_60")
    Exit Function
  End If
  GetSchutzbedarfText = GetSchutzbedarfTextFromLong(fld.value, bezeichner)

End Function

Function GetInfklasseTextFromLong(val As Long, bezeichner As String) As String
  Select Case val
    Case 1
      GetInfklasseTextFromLong = G_PARAM_Informationsklasse_S1
    Case 2
      GetInfklasseTextFromLong = G_PARAM_Informationsklasse_S2
    Case 3
      GetInfklasseTextFromLong = G_PARAM_Informationsklasse_S3
    Case 4
      GetInfklasseTextFromLong = G_PARAM_Informationsklasse_S4
    Case 5
      GetInfklasseTextFromLong = G_PARAM_Informationsklasse_S5
    Case Else
      'GetInfklasseText = "Unbewertet"
      GetInfklasseTextFromLong = FMT0("DOKUALG_60")
  End Select
End Function

Function GetInfklasseText(ByRef fld As Object, ByVal bezeichner As String) As String
  If IsNull(fld.value) Then
    'GetInfklasseText = "Unbewertet"
    GetInfklasseText = FMT0("DOKUALG_60")
    Exit Function
  End If
  
  GetInfklasseText = GetInfklasseTextFromLong(fld.value, bezeichner)

End Function

Function GetFreigabeTextKurz(ByVal FreigabeStatus As Long) As String
  Select Case FreigabeStatus
    Case 0
      GetFreigabeTextKurz = FMT0("TRACKERSTUFF_30")
    Case 1
      GetFreigabeTextKurz = FMT0("TRACKERSTUFF_31")
    Case 2
      GetFreigabeTextKurz = FMT0("TRACKERSTUFF_32")
    Case Else
      GetFreigabeTextKurz = FMT0("TRACKERSTUFF_33")
  End Select
End Function

Public Function IstDateiFreigabeStatusFreigegeben(ByRef rs As Object) As Boolean
    
    IstDateiFreigabeStatusFreigegeben = False
    
    Dim fs As Long
    fs = GetSafeFieldPlus(rs, "FreigabeStatus", -1)
    If fs = 2 Then
        IstDateiFreigabeStatusFreigegeben = True
    End If

End Function

Public Function IstDateiFreigabeStatusInitiiert(ByRef rs As Object) As Boolean
    
    IstDateiFreigabeStatusInitiiert = False
    
    Dim fs As Long
    fs = GetSafeFieldPlus(rs, "FreigabeStatus", -1)
    If fs = 1 Then
        IstDateiFreigabeStatusInitiiert = True
    End If

End Function

Public Function IstDateiFreigabeStatusDeaktiviert(ByRef rs As Object) As Boolean
    
    IstDateiFreigabeStatusDeaktiviert = False
    
    Dim fs As Long
    fs = GetSafeFieldPlus(rs, "FreigabeStatus", -1)
    If fs = 3 Then
        IstDateiFreigabeStatusDeaktiviert = True
    End If

End Function

Public Function IstDateiFreigabeStatusInitiiertOderFreigegeben(ByRef rs As Object) As Boolean
    
    IstDateiFreigabeStatusInitiiertOderFreigegeben = False
    
    Dim fs As Long
    fs = GetSafeFieldPlus(rs, "FreigabeStatus", -1)
    If fs = 1 Or fs = 2 Then
        IstDateiFreigabeStatusInitiiertOderFreigegeben = True
    End If

End Function

Public Function IstDateiFreigabeStatus0oder3(ByRef rs As Object) As Boolean
    
    IstDateiFreigabeStatus0oder3 = False
    
    Dim fs As Long
    fs = GetSafeFieldPlus(rs, "FreigabeStatus", -1)
    If fs = 0 Or fs = 3 Then
        IstDateiFreigabeStatus0oder3 = True
    End If

End Function

Attribute VB_Name = "Translation"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

' ------------------------------------------------------------------
Private Const NoError = 0       'The Function call was successful

Private Const LOCALE_USER_DEFAULT = &H400
Private Const LOCALE_SISO639LANGNAME = &H59
Private Const LOCALE_SISO3166CTRYNAME = &H5A

#If VBA7 And Win64 Then
    Private Declare PtrSafe Function WNetGetUser Lib "mpr.dll" _
          Alias "WNetGetUserA" (ByVal lpName As String, _
          ByVal lpUserName As String, lpnLength As Long) As Long
          
    ' Caution:  If the user default locale is a custom locale, an application cannot accurately tag data
    ' with the value or exchange it. In this case, the application should use GetUserDefaultLocaleName
    ' (available starting with Windows Vista) in preference to GetUserDefaultLCID.
    Private Declare PtrSafe Function GetUserDefaultLCID Lib "kernel32" () As Long
    
    ' List of Language Identifier Constants and Strings:
    ' https://msdn.microsoft.com/library/dd318693.aspx
    Private Declare PtrSafe Function GetLocaleInfo Lib "kernel32" Alias "GetLocaleInfoA" ( _
        ByVal Locale As Long, _
        ByVal LCType As Long, _
        ByVal lpLCData As String, _
        ByVal cchData As Long) As Long

    ' Available since Vista
    'GetUserDefaultUILanguage
    
#Else
    Private Declare Function WNetGetUser Lib "mpr.dll" _
          Alias "WNetGetUserA" (ByVal lpName As String, _
          ByVal lpUserName As String, lpnLength As Long) As Long
    
    Private Declare Function GetUserDefaultLCID Lib "kernel32" () As Long
    
    Private Declare Function GetLocaleInfo Lib "kernel32" Alias "GetLocaleInfoA" ( _
        ByVal Locale As Long, _
        ByVal LCType As Long, _
        ByVal lpLCData As String, _
        ByVal cchData As Long) As Long
    
#End If

' ------------------------------------------------------------------


' 0 = fallback language
Private mStringTables(2) As Collection
Private mLangIDs(2) As String
Private mCurrentUser As String
Private mCurrentLanguage As String


Public Property Get CurrentUser() As String
    CurrentUser = mCurrentUser
End Property

Public Property Get CurrentLanguage() As String
    CurrentLanguage = mCurrentLanguage
End Property

Private Sub Class_Initialize()
    mCurrentUser = GetTranslationUserName
End Sub

' installRoot - das aus der cfg
' startuppath - ThisWorkbook.path
Public Function StartupInit(installRoot As String, startuppath As String, app As String, Optional overrideLang As String = "") As Boolean
    On Error GoTo nogo
    ' User Language ermitteln (xy-uv)
    Dim lang As String
    If overrideLang <> "" Then
        lang = overrideLang
    Else
        'lang = GetUserLanguage
        ' Direkt das nehmen was Windows reportet
        lang = GetWindowsLanguageString
    End If
    
    
    Dim path As String
    Dim paths(2) As String
    Dim userPaths(2) As String
    
    Dim tries As Long
    For tries = 0 To 1
    
      paths(0) = startuppath & "\Translate\" & app & "_" & lang & ".txt"
      userPaths(0) = startuppath & "\Translate\" & app & "_" & lang & "_indiv.txt"
      
      paths(1) = installRoot & "\..\Translate\" & app & "_" & lang & ".txt"
      userPaths(1) = installRoot & "\..\Translate\" & app & "_" & lang & "_indiv.txt"
      
      Dim i As Long
      For i = 0 To UBound(paths)
          If Init(0, paths(i), lang) = True Then
              ' Und auch versuchen die user strings zu laden (falls es die gibt)
              Init 1, userPaths(i), lang
              ' Languagek|fffd|rzel merken, damit ich die DB Language bestimmen kann
              mCurrentLanguage = lang
              StartupInit = True
              Exit Function
          End If
      Next i
      
      ' Nix gefunden -> Fallback language setzen
      lang = GetFallbackLanguage(lang)
    Next tries
    
nogo:
    StartupInit = False
End Function

Public Function Init(index As Long, path As String, langId As String) As Boolean
    Init = False
    If index >= UBound(mLangIDs) Then
        Exit Function
    End If
    
    mLangIDs(index) = UCase(langId)
    Dim c As Collection
    Set c = LoadStringTable(path)
    If c Is Nothing Then
        Exit Function
    End If
    Set mStringTables(index) = c
    Init = True
End Function

Public Sub Clear()
    Set mStringTables(0) = New Collection
    Set mStringTables(1) = New Collection
End Sub


Public Function GetLocalizedFile(path As String) As String
    Dim lang As String
    If UBound(mLangIDs) > 0 Then
        If mLangIDs(0) <> "" Then
            lang = mLangIDs(0)
        End If
    End If
    If lang = "" Then
        lang = GetWindowsLanguageString
    End If
    
    GetLocalizedFile = LocalizedFileExists(path, lang)
End Function

' Splitted path\filename.ext aus path
' Und sucht dann nach
' path\filename_lang.ext
' Wenn nix gefunden, wird lang mit einem fallback replaced.
' de-de fuer alles was de-xy
' en-gb fuer alles andere
' Oder halt den original path wenn es nichts davon gibt.
' Der gefundene pfad wird returned oder "" wenn es gar nix gibt.
Public Function LocalizedFileExists(path As String, lang As String) As String
    On Error GoTo nogo
    
    LocalizedFileExists = path
    Dim newPath As String
    
    If lang <> "" Then
        ' Direkt nach der uebergebenen Sprache in lang suchen
        newPath = InternalLocalizedFileExists(path, lang)
        If newPath <> "" Then
            LocalizedFileExists = newPath
            Exit Function
        End If
        
        ' Nix gefunden -> fallback Sprache nehmen
        If Len(lang) > 2 Then
            ' Wenn es was deutsches ist, dann nach de-de suchen
            If UCase(lang) <> "DE-DEB" And InStr(UCase(lang), "DE") > 0 Then
                newPath = InternalLocalizedFileExists(path, "de-de")
                If newPath <> "" Then
                    LocalizedFileExists = newPath
                    Exit Function
                End If
            End If
        End If
        
        ' Bis hier hin nix gefunden -> nach "en-gb" suchen
        If UCase(lang) <> "DE-DE" Then
            newPath = InternalLocalizedFileExists(path, "en-gb")
            If newPath <> "" Then
                LocalizedFileExists = newPath
                Exit Function
            End If
        End If
    End If
    
nogo:
    If Not FileExists(LocalizedFileExists) Then
        LocalizedFileExists = ""
    End If
End Function

Private Function InternalLocalizedFileExists(path As String, lang As String) As String
    On Error GoTo nogo
    
    Dim newPath As String
    Dim p As String
    Dim filename As String
    Dim ext As String
    fileSplit path, p, filename, ext

    newPath = FmtInternal("%1%2_%3.%4", p, filename, lang, ext)
    If newPath <> "" And FileExists(newPath) Then
        InternalLocalizedFileExists = newPath
        Exit Function
    End If
nogo:
End Function

Public Sub AddString(tableIdx As Long, id As String, s As String)
    mStringTables(tableIdx).add s, id
End Sub

Public Function StringExists(id As String) As Boolean
    If id = "" Then
        StringExists = True
        Exit Function
    End If
    On Error GoTo nogo
    Dim s As String
    If CollectionStringExists(mStringTables(1), UCase(id)) Then
        StringExists = True
    ElseIf CollectionStringExists(mStringTables(0), UCase(id)) Then
        StringExists = True
    End If
    Exit Function
nogo:
    StringExists = False
End Function

Public Function GetString(id As String) As String
    On Error GoTo nogo
    If id = "" Then
        Exit Function
    End If
    
    If mStringTables(1) Is Nothing Then
        GetString = GetFallbackString(id)
        Exit Function
    End If
    GetString = IIf(G_ShowTextIDs, id & ":", "") & mStringTables(1).item(UCase(id))
    Exit Function
nogo:
    GetString = GetFallbackString(id)
End Function

Public Function GetSafeString(ByVal id As String, Optional defaultVal As String = "") As String
    If StringExists(id) Then
        GetSafeString = GetString(id)
        Exit Function
    End If
    GetSafeString = defaultVal
End Function

Public Function GetSafeStringReplace(ByVal id As String, Optional defaultVal As String = "") As String
    If StringExists(id) Then
        GetSafeStringReplace = FMT0(id)
        Exit Function
    End If
    GetSafeStringReplace = defaultVal
End Function

Public Function GetFallbackString(id As String) As String
    On Error GoTo nogo
    If mStringTables(0) Is Nothing Then
        GetFallbackString = id & ": ***MISSING***"
        Exit Function
    End If
    
    GetFallbackString = IIf(G_ShowTextIDs, id & ":", "") & mStringTables(0).item(UCase(id))
    Exit Function
nogo:
    GetFallbackString = id & ": ***MISSING***"
End Function

Public Function FormatString(FMT As String, _
                             Optional arg1 As String = vbNullChar, _
                             Optional arg2 As String = vbNullChar, _
                             Optional arg3 As String = vbNullChar, _
                             Optional arg4 As String = vbNullChar, _
                             Optional arg5 As String = vbNullChar, _
                             Optional arg6 As String = vbNullChar, _
                             Optional arg7 As String = vbNullChar, _
                             Optional arg8 As String = vbNullChar, _
                             Optional arg9 As String = vbNullChar _
                             ) As String
                             
    On Error GoTo nogo
    
    Dim argarray(8) As String
    If IsTestUser Then
        argarray(0) = arg1
        argarray(1) = arg2
        argarray(2) = arg3
        argarray(3) = arg4
        argarray(4) = arg5
        argarray(5) = arg6
        argarray(6) = arg7
        argarray(7) = arg8
        argarray(8) = arg9
        
        Dim i As Long
        ' Erstmal checken ob wir fuer jeden Placeholder einen Parameter uebergeben bekommen haben
        ' Hier koennte man auch IsMissing nehmen - aber dann muessen alle args vom Type Variant sein.
        For i = 1 To 9
            If InStr(FMT, "%" & i) > 0 Then
                If argarray(i - 1) = vbNullChar Then
                    MsgBox FMT & vbCrLf & vbCrLf & "ERROR in FormatString: No arg for %" & i, vbCritical
                    Exit Function
                End If
            End If
        Next i
    Else
        argarray(0) = IIf(arg1 = vbNullChar, "", arg1)
        argarray(1) = IIf(arg2 = vbNullChar, "", arg2)
        argarray(2) = IIf(arg3 = vbNullChar, "", arg3)
        argarray(3) = IIf(arg4 = vbNullChar, "", arg4)
        argarray(4) = IIf(arg5 = vbNullChar, "", arg5)
        argarray(5) = IIf(arg6 = vbNullChar, "", arg6)
        argarray(6) = IIf(arg7 = vbNullChar, "", arg7)
        argarray(7) = IIf(arg8 = vbNullChar, "", arg8)
        argarray(8) = IIf(arg9 = vbNullChar, "", arg9)
    End If
    
    Dim r As String
    r = FMT
    
    r = Replace(r, "%%", "%")
    r = Replace(r, "\n", vbCrLf)
    r = Replace(r, "\t", vbTab)
    
    For i = 1 To 9
        r = Replace(r, "%" & i, argarray(i - 1))
    Next i
    
    FormatString = r
    Exit Function

nogo:
    FormatString = "ERROR " & FMT
End Function

#If TEST_BUILD = 1 Then
#Else
#End If

'Public Function FormatString(fmt As String, _
'                             Optional arg1 As String, _
'                             Optional arg2 As String, _
'                             Optional arg3 As String, _
'                             Optional arg4 As String, _
'                             Optional arg5 As String, _
'                             Optional arg6 As String, _
'                             Optional arg7 As String, _
'                             Optional arg8 As String, _
'                             Optional arg9 As String _
'                             ) As String
'    On Error GoTo nogo
'
'    Dim argarray(8) As String
'    argarray(0) = arg1
'    argarray(1) = arg2
'    argarray(2) = arg3
'    argarray(3) = arg4
'    argarray(4) = arg5
'    argarray(5) = arg6
'    argarray(6) = arg7
'    argarray(7) = arg8
'    argarray(8) = arg9
'    Dim i As Long
'    Dim r As String
'    r = fmt
'    For i = 1 To 9
'        r = Replace(r, "%" & i, argarray(i - 1))
'    Next i
'    r = Replace(r, "%%", "%")
'    r = Replace(r, "\n", vbCrLf)
'    r = Replace(r, "\t", vbTab)
'
'    FormatString = r
'    Exit Function
'
'nogo:
'    FormatString = "ERROR " & fmt
'End Function

Private Function GetTranslationTags(controlTag As String) As String()
    Dim tags() As String
    ' Argh.  Die Split Funktion in VBA gibt ein Element zurueck bei Split("test", ",")
    ' In VB6 aber nicht.
    ' Dann haben wir eine eigene implementierung fuer Split in MailSenden.bas. Die ist wie die VB6 version
    ' Also immer stur ein ',' dranhaengen
    tags = Split(controlTag & ",", ",")
    
    Dim invalidTags() As String
    invalidTags = Split("FIXLEFT,FIXTOP,NORESIZE", ",")
    
    Dim Result As String
    
    Dim t As Variant
    For Each t In tags
        t = Trim(t)
        If t <> "" And Not IsOneOf(UCase(t), invalidTags) Then
            If Len(Result) > 0 Then
                Result = Result & "," & t
            Else
                Result = t
            End If
        End If
    Next t
    GetTranslationTags = Split(Result & ",", ",")
End Function

Private Function IsOneOf(s As String, arr() As String) As Boolean
    IsOneOf = False
    If Len(s) = 0 Then
        Exit Function
    End If
    
    Dim e As Variant
    For Each e In arr
        If s = e Then
            IsOneOf = True
            Exit Function
        End If
    Next e
End Function

Private Sub TranslateControl(ctl As Object)
    On Error GoTo nogo
    Dim tag As String
    tag = ctl.tag
    If tag <> "" Then
        Dim tags() As String
        tags = GetTranslationTags(tag)
    
        ' Caption
        Dim s As String
        s = FMT0(tags(0))
        If s <> "" Then
#If IS_VBA = 1 Then
            If TypeOf ctl Is MSForms.TextBox Then
#Else
            If TypeOf ctl Is TextBox Then
#End If
                ctl.Text = s
            'ElseIf TypeOf ctl Is MSForms.UserForm Then
            Else
                ctl.Caption = s
            End If
        End If
        
        ' ControlTipText
        If UBound(tags) > 0 Then
            s = FMT0(tags(1))
            If s <> "" Then
#If IS_VBA = 1 Then
                If TypeOf ctl Is MSForms.MultiPage Then
                    ' MultiPage hat keinen tooltip
                Else
                    ctl.ControlTipText = s
                End If
#Else
                ctl.toolTipText = s
#End If
            End If
        End If
    End If

    Exit Sub
nogo:
    Debug.Print err.Description
End Sub

Public Sub TranslateForm(frm As Object)
    TranslateControl frm
    
    
    Dim ctl As Object
    For Each ctl In frm.Controls
        
        'If ctl.ControlType = acTextBox Then
#If IS_VBA = 1 Then
        If TypeOf ctl Is MSForms.MultiPage Then
#Else
        If False Then
#End If
            TranslateControl ctl
            Dim page As Object
            For Each page In ctl.Pages
                TranslateControl page
            Next page
#If IS_VBA = 1 Then
        ElseIf TypeOf ctl Is MSForms.Frame Then
            TranslateForm ctl
#Else
        'ElseIf TypeOf ctl Is Frame Then
#End If
        Else
            TranslateControl ctl
        'ElseIf ctl.ControlType = acSubform Then
        '    TranslateForm frm(ctl.name).Form
        End If
    Next ctl
    
End Sub

' Die Sprache die der user in Windows eingestellt hat
' Rueckgabewert: Eine unserer supporteten languages
Public Function GetUserLanguage() As String
    Dim lcid As Long
    lcid = GetUserDefaultLCID()
    GetUserLanguage = MapLCIDToInternalLanguage(lcid)
End Function

' Die Sprache des installierten Ms Office
' Rueckgabewert: Eine unserer supporteten languages
Public Function GetMsOfficeLanguage() As String
    Dim lcid As Long
    lcid = Application.LanguageSettings.LanguageID(msoLanguageIDUI)
    GetMsOfficeLanguage = MapLCIDToInternalLanguage(lcid)
End Function



' -------------------------------------------------------------------
'
' -------------------------------------------------------------------

Function LoadStringTable(path As String) As Collection
    On Error GoTo nogo
    Set LoadStringTable = Nothing
    
    Const ForReading = 1
    Const TristateUseDefault = -2, TristateTrue = -1, TristateFalse = 0
    
    Dim fs, f, ts
    Set ts = Nothing
    Set fs = CreateObject("Scripting.FileSystemObject")
    Set ts = fs.OpenTextFile(path, ForReading, False, TristateTrue)
    
    'Dim sheet As Worksheet
    'Set sheet = ThisWorkbook.Sheets("Test")
    'Dim y As Long
    'y = 1
    
    Dim c As New Collection
    Dim s As String
    Do While ts.AtEndOfStream <> True
        ' This really is a Unicode string, although the debugger and MsgBox show ??
        s = ts.ReadLine
        'sheet.Cells(y, 1) = s
        'y = y + 1
        If ExtractString(s, c) Then
        End If
    Loop
    Set LoadStringTable = c
nogo:
    If Not ts Is Nothing Then
        ts.Close
        Set ts = Nothing
    End If
    If Not fs Is Nothing Then
        Set fs = Nothing
    End If
End Function

Function ExtractString(line As String, c As Collection) As Boolean
    On Error GoTo nogo
    
    ExtractString = False
    If line = "" Then
        Exit Function
    End If
    If Left(line, 1) = "'" Then
        Exit Function
    End If
    
    Dim pos As Long
    pos = InStr(line, " ")
    
    Dim id As String
    Dim value As String
    If pos <= 0 Then
      id = line
      value = ""
    Else
      id = Left(line, pos - 1)
      value = Mid(line, pos + 1, Len(line) - pos)
    End If
    If Not CollectionStringExists(c, id) Then
        c.add value, id
    End If
    
    ExtractString = True
    Exit Function
nogo:
    MsgBox err.Description, vbOKOnly, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
End Function

Private Function GetTranslationUserName() As String
   ' Buffer size for the return string.
   Const lpnLength As Integer = 255

   ' Get return buffer space.
   Dim status As Integer

   ' For getting user information.
   Dim lpName, lpUserName As String

   ' Assign the buffer size constant to lpUserName.
   lpUserName = Space$(lpnLength + 1)

   ' Get the log-on name of the person using product.
   status = WNetGetUser(lpName, lpUserName, lpnLength)

   ' See whether error occurred.
   If status = NoError Then
      ' This line removes the null character. Strings in C are null-
      ' terminated. Strings in Visual Basic are not null-terminated.
      ' The null character must be removed from the C strings to be used
      ' cleanly in Visual Basic.
      lpUserName = Left$(lpUserName, InStr(lpUserName, Chr(0)) - 1)
   Else
      lpUserName = "Unbekannt"
   End If

    GetTranslationUserName = lpUserName
End Function

Private Function CollectionStringExists(c As Collection, name As String) As Boolean
  On Error GoTo notReadable
  Dim s As String
  s = c(name)
  CollectionStringExists = True
  Exit Function
  
notReadable:
  CollectionStringExists = False
End Function

Private Function LCIDToLanguageCode(lcid As Long) As String

    ' Locale IDs
    ' https://msdn.microsoft.com/en-us/goglobal/bb964664
    'Arabic (Saudi Arabia)                1025
    'Arabic (Iraq)                        2049
    'Arabic (Egypt)                       3073
    'Arabic (Libya)                       4097
    'Arabic (Algeria)                     5121
    'Arabic (Morocco)                     6145
    'Arabic (Tunisia)                     7169
    'Arabic (Oman)                        8193
    'Arabic (Yemen)                       9217
    'Arabic (Syria)                      10241
    'Arabic (Jordan)                     11265
    'Arabic (Lebanon)                    12289
    'Arabic (Kuwait)                     13313
    'Arabic (U.A.E.)                     14337
    'Arabic (Bahrain)                    15361
    'Arabic (Qatar)                      16385
    'Bulgarian                            1026
    'Catalan                              1027
    'Chinese (Taiwan)                     1028
    'Chinese (PRC)                        2052
    'Chinese (Hong Kong SAR               3076
    'Chinese (Singapore)                  4100
    'Czech                                1029
    'Danish                               1030
    'German (Germany)                     1031
    'German (Swiss)                       2055
    'German (Austrian)                    3079
    'German (Luxembourg)                  4103
    'German (Liechtenstein)               5127
    'Greek                                1032
    'English (United States)              1033
    'English (United Kingdom)             2057
    'English (Australian)                 3081
    'English (Canadian)                   4105
    'English (New Zealand)                5129
    'English (Ireland)                    6153
    'English (South Africa)               7177
    'English (Jamaica)                    8201
    'English (Caribbean)                  9225
    'English (Belize)                    10249
    'English (Trinidad)                  11273
    'Spanish (Traditional Sort)           1034
    'Spanish (Mexican)                    2058
    'Spanish (Modern Sort)                3082
    'Spanish (Guatemala)                  4106
    'Spanish (Costa Rica)                 5130
    'Spanish (Panama)                     6154
    'Spanish (Dominican Republic)         7178
    'Spanish (Venezuela)                  8202
    'Spanish (Colombia)                   9226
    'Spanish (Peru)                      10250
    'Spanish (Argentina)                 11274
    'Spanish (Ecuador)                   12298
    'Spanish (Chile)                     13322
    'Spanish (Uruguay)                   14346
    'Spanish (Paraguay)                  15370
    'Spanish (Bolivia)                   16394
    'Spanish (El Salvador)               17418
    'Spanish (Honduras)                  18442
    'Spanish (Nicaragua)                 19466
    'Spanish (Puerto Rico)               20490
    'Finnish                              1035
    'French (Standard)                    1036
    'French (Belgian)                     2060
    'French (Canadian)                    3084
    'French (Swiss)                       4108
    'French (Luxembourg)                  5132
    'Hebrew                               1037
    'Hungarian                            1038
    'Icelandic                            1039
    'Italian (Standard)                   1040
    'Italian (Swiss)                      2064
    'Japanese                             1041
    'Korean                               1042
    'Korean (Johab)                       2066
    'Dutch (Standard)                     1043
    'Dutch (Belgian)                      2067
    'Norwegian (Bokmal)                   1044
    'Norwegian (Nynorsk)                  2068
    'Polish                               1045
    'Portuguese (Brazil)                  1046
    'Portuguese (Portugal)                2070
    'Romanian                             1048
    'Russian                              1049
    'Croatian                             1050
    'Serbian (Latin)                      2074
    'Serbian (Cyrillic)                   3098
    'Slovak                               1051
    'Albanian                             1052
    'Swedish                              1053
    'Swedish (Finland)                    2077
    'Thai                                 1054
    'Turkish                              1055
    'Indonesian                           1057
    'Ukrainian                            1058
    'Belarusian                           1059
    'Slovenian                            1060
    'Estonian                             1061
    'Latvian                              1062
    'Lithuanian                           1063
    'Farsi                                1065
    'Vietnamese                           1066
    'Basque                               1069
    'Afrikaans                            1078
    'Faeroese                             1080

    'Dim langs As Variant
    'langs = [{1031, "de-de"; 2055, "de-ch"}]
    'langs = Array( _
    '        1031, "de-de" _
    '    )
    
    ' Default ist Englisch
    LCIDToLanguageCode = "en-gb"

    ' https://msdn.microsoft.com/en-us/library/ee825488(v=cs.20).aspx
    Select Case lcid
    Case 1031
        'German (Germany)
        LCIDToLanguageCode = "de-de"
    Case 2055
        'German (Swiss)
        LCIDToLanguageCode = "de-ch"
    Case 3079
        'German (Austrian)
        LCIDToLanguageCode = "de-at"
    Case 4103
        'German (Luxembourg)
        LCIDToLanguageCode = "de-lu"
    Case 5127
        'German (Liechtenstein)
        LCIDToLanguageCode = "de-li"
        
    Case 1033
        'English (United States)
        LCIDToLanguageCode = "en-us"
    Case 2057
        'English (United Kingdom)
        LCIDToLanguageCode = "en-gb"
    Case 3081
        'English (Australian)
        LCIDToLanguageCode = "en-au"
    Case 4105
        'English (Canadian)
        LCIDToLanguageCode = "en-ca"
    Case 5129
        'English (New Zealand)
        LCIDToLanguageCode = "en-nz"
    Case 6153
        'English (Ireland)
        LCIDToLanguageCode = "en-ie"
    Case 7177
        'English (South Africa)
        LCIDToLanguageCode = "en-za"
    Case 8201
        'English (Jamaica)
        LCIDToLanguageCode = "en-jm"
    Case 9225
        'English (Caribbean)
        LCIDToLanguageCode = "en-cb"
    Case 10249
        'English (Belize)
        LCIDToLanguageCode = "en-bz"
    Case 11273
        'English (Trinidad and Tobago)
        LCIDToLanguageCode = "en-tt"
    End Select
End Function

Private Function MapLCIDToInternalLanguage(lcid As Long) As String
    Dim langCulture As String
    langCulture = LCIDToLanguageCode(lcid)
    
    ' Alles was de-xy hat wird auf de-de abgebildet
    If Left(langCulture, 2) = "de" Then
        MapLCIDToInternalLanguage = LANG_DE_DE
    Else
        ' Alles andere wird en-gb
        MapLCIDToInternalLanguage = LANG_EN_GB
    End If
    
End Function

Public Function GetWindowsLanguageString() As String
    On Error GoTo nogo
    
    Dim ret As Long
    Dim loc As String
    Dim windowsLang As String
    
    loc = Space$(255)
    ret = GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SISO639LANGNAME, loc, 9)
    loc = Left$(loc, InStr(loc, Chr(0)) - 1)
    windowsLang = loc & "-"
    
    loc = Space$(255)
    ret = GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SISO3166CTRYNAME, loc, 9)
    loc = Left$(loc, InStr(loc, Chr(0)) - 1)
    windowsLang = windowsLang & loc
    
    GetWindowsLanguageString = LCase(windowsLang)
    Exit Function
nogo:
    GetWindowsLanguageString = "en-gb"
End Function

Private Function GetFallbackLanguage(lang As String) As String
    ' Alles was de-xy hat wird auf de-de abgebildet
    If Left(lang, 2) = "de" Then
        GetFallbackLanguage = LANG_DE_DE
    Else
        ' Alles andere wird en-gb
        GetFallbackLanguage = LANG_EN_GB
    End If
End Function


Attribute VB_Name = "TranslationHelpers"
Option Explicit

' Fallbacksprachen
' Regeln:
 '  File APP_en-xy.txt nicht da -> APP_en-gb.txt benutzen
 '  File APP_de-xy.txt nicht da -> APP_de-de.txt benutzen
 '  File APP_xy-uv.txt nicht da -> APP_en-gb.txt benutzen
Public Const LANG_EN_GB As String = "en-gb"
Public Const LANG_DE_DE As String = "de-de"


Public gTranslation As New Translation

Public Function InitTranslation(path As String, startuppath As String, langFile As String, cfg As CfgReader) As Boolean
    InitTranslation = False
    Dim overrideLanguage As String
    If Not cfg Is Nothing Then
        If cfg.GetSection("GLOBALS") = True Then
            overrideLanguage = cfg.GetValue("LANGUAGE")
        End If
    End If
    If Not gTranslation.StartupInit(path, startuppath, langFile, overrideLanguage) Then
        ' Sprachdateien wurden nicht geladen
        MsgBox FmtInternal("Missing language files ('%1_en-gb.txt')!" & vbCrLf & vbCrLf & "Die Sprachdateien wurden nicht gefunden ('%1_de-de.txt')!", langFile), vbCritical
        Exit Function
    End If
    InitTranslation = True
End Function

Public Function FMT0(f As String) As String
    FMT0 = FmtInternal(TR(f))
End Function

Public Function FMT1(f As String, _
                     ByVal arg1 As String) As String
    FMT1 = FmtInternal(TR(f), arg1)
End Function

Public Function FMT2(f As String, _
                     ByVal arg1 As String, _
                     ByVal arg2 As String) As String
    FMT2 = FmtInternal(TR(f), arg1, arg2)
End Function

Public Function FMT3(f As String, _
                     ByVal arg1 As String, _
                     ByVal arg2 As String, _
                     ByVal arg3 As String) As String
    FMT3 = FmtInternal(TR(f), arg1, arg2, arg3)
End Function

Public Function FMT4(f As String, _
                     ByVal arg1 As String, _
                     ByVal arg2 As String, _
                     ByVal arg3 As String, _
                     ByVal arg4 As String) As String
    FMT4 = FmtInternal(TR(f), arg1, arg2, arg3, arg4)
End Function

Public Function FMT5(f As String, _
                     ByVal arg1 As String, _
                     ByVal arg2 As String, _
                     ByVal arg3 As String, _
                     ByVal arg4 As String, _
                     ByVal arg5 As String) As String
    FMT5 = FmtInternal(TR(f), arg1, arg2, arg3, arg4, arg5)
End Function

Public Function GetTranslationString(id As String, fallback As String) As String
    If gTranslation.StringExists(id) Then
        GetTranslationString = gTranslation.GetString(id)
        Exit Function
    End If
    GetTranslationString = fallback
End Function

Public Function TR(id As String) As String
'    If gTranslation Is Nothing Then
'        TR = "gTranslation Not Initialized"
'        Exit Function
'    End If
    TR = gTranslation.GetString(id)
End Function

Public Function FmtInternal(f As String, _
                    Optional arg1 As String = vbNullChar, _
                    Optional arg2 As String = vbNullChar, _
                    Optional arg3 As String = vbNullChar, _
                    Optional arg4 As String = vbNullChar, _
                    Optional arg5 As String = vbNullChar, _
                    Optional arg6 As String = vbNullChar, _
                    Optional arg7 As String = vbNullChar, _
                    Optional arg8 As String = vbNullChar, _
                    Optional arg9 As String = vbNullChar _
                    ) As String
    FmtInternal = gTranslation.FormatString(f, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)
End Function

Public Function IsYes(s As String) As Boolean
  If UCase(s) = "JA" Or UCase(s) = "YES" Then
    IsYes = True
  End If
End Function

Public Function IsNo(s As String) As Boolean
  If UCase(s) = "NEIN" Or UCase(s) = "NO" Then
    IsNo = True
  End If
End Function

Public Function IsTrue(s As String) As Boolean
    If UCase(s) = "WAHR" Or UCase(s) = "TRUE" Then
        IsTrue = True
    End If
End Function

Public Function IsFalse(s As String) As Boolean
    If UCase(s) = "FALSCH" Or UCase(s) = "FALSE" Then
        IsFalse = True
    End If
End Function

Public Function TranslationSheetExists(ByRef wb As Workbook, names As Variant) As String
    On Error GoTo nogo
    Dim name As String
    If IsArray(names) Then
        Dim n As Variant
        For Each n In names
            name = CStr(n)
            If WorksheetExists(wb, name) Then
                TranslationSheetExists = name
                Exit Function
            End If
        Next n
        If UBound(names) >= 0 Then
            TranslationSheetExists = CStr(names(0))
            Exit Function
        End If
    Else
        name = CStr(names)
        If WorksheetExists(wb, name) Then
            TranslationSheetExists = name
            Exit Function
        End If
    End If
nogo:
    
End Function

' Das gleiche wie Cells.Find - aber probiert mehrere Strings zu finden (fuer mehrere Sprachen)
Public Function TranslationFindCells(ws As Worksheet, What As Variant, LookIn As Excel.XlFindLookIn, _
                                     LookAt As Excel.XlLookAt, SearchOrder As Excel.XlSearchOrder, _
                                     SearchDirection As Excel.XlSearchDirection, MatchCase As Boolean) As Range
  Set TranslationFindCells = Nothing
  Dim s As Variant
  For Each s In What
    Dim r As Range
    Set r = ws.Cells.Find(CStr(s), LookIn:=LookIn, LookAt:=LookAt, SearchOrder:=SearchOrder, SearchDirection:=SearchDirection, MatchCase:=MatchCase)
    If Not r Is Nothing Then
      Set TranslationFindCells = r
      Exit Function
    End If
  Next s
End Function

' This works because Debug.Print is omitted in the compiled code
Public Function InIDE() As Boolean
  On Error Resume Next
  Debug.Print 0 / 0
  InIDE = err.Number <> 0
End Function



Attribute VB_Name = "TxtSize"
Option Explicit

Attribute VB_Name = "UICallback"
Option Explicit

Private ribbon As Object

Public Function Ribbon_Load(ribbonUI As Object)  ' Office.IRibbonUI
       Set ribbon = ribbonUI
End Function

Public Sub getVisible(ByVal control As Object, ByRef visible)
  If control.tag = "ExcelTracker" Then
      If G_PARAM_Menueleiste = False Then
        visible = False
      Else
        visible = G_PARAM_Ribbons
      End If
  End If
End Sub


'Callback for buttonRisikobewertung onAction
Public Function OnAction(ByVal control As Object)
    
    Dim CancelDefault As Boolean
    
    Select Case control.id
        Case "buttonRisikobewertung"
            RisikoFragenButton_C Application, Nothing, CancelDefault
        Case "buttonDoku"
            DokuButton_C Application, Nothing, CancelDefault
        Case "buttonNeueVersion"
            NewVersionButton_C Application, Nothing, CancelDefault
        Case "buttonFreigabe"
            FreigabeButton_C Application, Nothing, CancelDefault
        Case "buttonMeineDateien"
            ZeigeMeineDateienListe Application, Application.ActiveWorkbook, 1
        Case "buttonECC"
          ECCButton_C Application, Nothing, CancelDefault
        Case "buttonESQA"
          ESQAButton_C Application, Nothing, CancelDefault
        Case "buttonEFC"
          EFCButton_C Application, Nothing, CancelDefault
        Case "buttonFreigabeAbschliessen"
          FreigabeAbschliessenButton_C Application, Nothing, CancelDefault
        Case "buttonEP"
          EPButton_C Application, Nothing, CancelDefault
        Case "buttonSignOff"
          SignOffButton_C Application, Nothing, CancelDefault
        Case "buttonDateiberechtigung"
          Dateiberechtigung_C Application, CancelDefault
        Case "buttonDateiOeffnen"
          DateiOeffnen_C Application, CancelDefault
        Case "buttonLock"
          Lock_C Application, CancelDefault
        Case "buttonUnlock"
          Unlock_C Application, CancelDefault
        Case "buttonDokuInWord"
          DokuInWord_C Application, CancelDefault
        Case "buttonInfo"
          Info_C Application, CancelDefault
        Case "buttonAppInfo"
          AppInfo_C Application, CancelDefault
    End Select
    InvalidateRibbon
End Function

Public Sub InvalidateRibbon()
    If Not ribbon Is Nothing Then
        ribbon.Invalidate
    End If
End Sub

Public Sub OnEnabled(ByVal control As Object, ByRef enable)
    enable = True
End Sub

Public Sub OnVisible(ByVal control As Object, ByRef visible)
    visible = True
    Select Case control.id
        Case "buttonAmpel"
            visible = G_PARAM_Ampel
        Case "buttonRisikobewertung"
            visible = G_PARAM_ReihenfolgeRisikobewertung >= 0
        Case "buttonDoku"
            visible = G_PARAM_ReihenfolgeDokumentation >= 0
        Case "buttonNeueVersion"
            visible = G_PARAM_ReihenfolgeVersionierung >= 0
        Case "buttonFreigabe"
            visible = G_PARAM_ReihenfolgeFreigabeInit >= 0
        Case "buttonMeineDateien"
            visible = G_PARAM_ReihenfolgeDateiliste >= 0
        Case "buttonECC"
            visible = G_PARAM_ReihenfolgeScanner >= 0
        Case "buttonESQA"
          visible = G_PARAM_ReihenfolgeESQA >= 0
        Case "buttonEFC"
          visible = G_PARAM_ReihenfolgeEFC >= 0
        Case "buttonFreigabeAbschliessen"
          visible = G_PARAM_ReihenfolgeFreigabeAbschliessen >= 0
        Case "buttonEP"
          visible = G_PARAM_ReihenfolgeProtect >= 0
        Case "buttonDateiberechtigung"
          visible = G_PARAM_ReihenfolgeBerechtigungen >= 0
        Case "buttonDateiOeffnen"
          visible = G_PARAM_ReihenfolgeDateiOeffnen >= 0
        Case "buttonLock"
          visible = G_PARAM_ReihenfolgeLock >= 0
        Case "buttonUnlock"
          visible = G_PARAM_ReihenfolgeUnLock >= 0
        Case "buttonDokuInWord"
          visible = G_PARAM_ReihenfolgeDokuInWordIcon >= 0
        Case "buttonSignOff"
            visible = G_PARAM_ReihenfolgeSignOff >= 0
        Case "buttonAppInfo"
            visible = G_PARAM_ReihenfolgeAppInfo >= 0
        Case "buttonInfo"
            visible = IIf(G_cfgInfoPfad <> "", True, False)
    End Select
End Sub

' buttonFreigabe handler
Public Sub GetLabel(ByVal control As Object, ByRef toolTipText)
    Dim faceId As Long
    Dim t As String
On Error GoTo fehler
    Dim value As Long
    
    toolTipText = ""
    t = ""
    Select Case control.id
    Case "buttonFreigabe"
        't = "Freigabe initiieren"
        t = FMT0("UICALLB_1")
        value = G_AmpelStatus ' GetAmpelStatus(xlapp.ActiveWorkbook)
        If value = 2 Then
            't = "Freigabe aufheben"
            t = FMT0("UICALLB_2")
        ElseIf value = 4 Then
            't = "Freigabe aufheben"
            t = FMT0("UICALLB_2")
        ElseIf value = 6 Then
            't = "Freigabe abbrechen"
            t = FMT0("UICALLB_3")
        End If
    End Select
    
    toolTipText = t

fehler:
End Sub

' Tooltip text handler fuer alle buttons
Public Sub GetScreentip(ByVal control As Object, ByRef toolTipText)
    Dim faceId As Long
    Dim t As String
On Error GoTo fehler
    Dim value As Long
    
    toolTipText = ""
    t = ""
    Select Case control.id
    Case "buttonAmpel"
        GetAmpelStatusFaceId Application.ActiveWorkbook, faceId, t
    Case "buttonFreigabe"
        't = "Freigabe initiieren"
        t = FMT0("UICALLB_4")
        value = G_AmpelStatus ' GetAmpelStatus(xlapp.ActiveWorkbook)
        If value = 2 Then
            't = "Freigabe aufheben"
            t = FMT0("UICALLB_5")
        ElseIf value = 4 Then
            't = "Freigabe aufheben"
            t = FMT0("UICALLB_5")
        ElseIf value = 6 Then
            't = "Freigabe abbrechen"
            t = FMT0("UICALLB_6")
        End If
    Case "buttonRisikobewertung"
        'ScreenTip = "Risikobefragung durchf|fffd|hren."
        t = FMT0("XLAAPP_5")
    Case "buttonDoku"
        'ScreenTip = "Dokumentation der Datei"
        t = FMT0("XLAAPP_8")
    Case "buttonNeueVersion"
        'ScreenTip = "Neue Version"
        t = FMT0("XLAAPP_9")
    Case "buttonMeineDateien"
        'ScreenTip = "Liste 'meiner' Dateien"
        t = FMT0("XLAAPP_15")
    Case "buttonECC"
        'ScreenTip = "Excel-Sheet-Checker f|fffd|r diese Datei aufrufen"
        t = FMT0("XLAAPP_16")
    Case "buttonEP"
        'ScreenTip = "ExcelProtect f|fffd|r diese Datei aufrufen"
        t = FMT0("XLAAPP_17")
    Case "buttonESQA"
        'ScreenTip = "Excel-Sheet-QA aufrufen"
        t = FMT0("XLAAPP_19")
    Case "buttonFreigabeAbschliessen"
        'ScreenTip = "Programmfreigabe erteilen"
        t = FMT0("XLAAPP_12")
    Case "buttonEFC"
        'ScreenTip = "Excel-File-Compare aufrufen"
        t = FMT0("XLAAPP_18")
    Case "buttonDateiberechtigung"
        'ScreenTip = "Dateiberechtigung anbringen / entfernen"
        t = FMT0("XLAAPP_33")
    Case "buttonDateiOeffnen"
        'ScreenTip = "|fffd|ffnet Dateien mit Berechtigungen"
        t = FMT0("XLAAPP_34")
    Case "buttonLock"
        'ScreenTip = "Blattschutz anbringen"
        t = FMT0("XLAAPP_22")
    Case "buttonUnlock"
        'ScreenTip = "Blattschutz entfernen"
        t = FMT0("XLAAPP_23")
    Case "buttonDokuInWord"
        'ScreenTip = "Doku in Word anzeigen"
        t = FMT0("XLAAPP_13")
    Case "buttonSignOff"
        'ScreenTip = "Sign-Off"
        t = FMT0("XLAAPP_24")
    Case "buttonInfo"
        'ScreenTip = "Info"
        t = FMT0("XLAAPP_14")
    End Select
    
    toolTipText = t
fehler:
End Sub

' handler fuer button caption fuer alle buttons aussser Ampel und Freigabe
Public Sub getStatus(ByVal control As Object, ByRef status)
'    If control.id = "buttonAmpel" Then
'        Dim faceId As Long
'        Dim t As String
'        status = ""
'     GetAmpelStatusFaceId Application.ActiveWorkbook, faceId, t
        'status = "Status"
        'status = FMT0("UICALLB_7")
'    End If

    Select Case control.id
    Case "buttonAmpel"
      status = FMT0("UICALLB_7")
    Case "buttonRisikobewertung"
      'Label = "Risikobefragung"
      status = FMT0("XLAAPP_4")
    Case "buttonDoku"
      'Label = "Doku"
      status = FMT0("XLAAPP_26")
    Case "buttonNeueVersion"
      'Label = "Neue Version"
      status = FMT0("XLAAPP_9")
    Case "buttonMeineDateien"
      'Label = "Meine Dateien"
      status = FMT0("MD_1")
    Case "buttonECC"
      'Label = "ECC"
      status = FMT0("XLAAPP_28")
    Case "buttonEP"
      'Label = "ExcelProtect"
      status = FMT0("XLAAPP_27")
    Case "buttonESQA"
      'Label = "Excel-Sheet-QA"
      status = FMT0("XLAAPP_30")
    Case "buttonFreigabeAbschliessen"
      'Label = "Freigabe erteilen"
      status = FMT0("XLAAPP_31")
    Case "buttonEFC"
      'Label = "Excel File Compare"
      status = FMT0("XLAAPP_29")
    Case "buttonDateiberechtigung"
      'Label = "Datei- Berechtigung"
      status = FMT0("XLAAPP_20")
    Case "buttonDateiOeffnen"
      'Label = "Datei |fffd|ffnen"
      status = FMT0("XLAAPP_21")
    Case "buttonLock"
      'Label = "Blattschutz anbringen"
      status = FMT0("XLAAPP_22")
    Case "buttonUnlock"
      'Label = "Blattschutz entfernen"
      status = FMT0("XLAAPP_23")
    Case "buttonDokuInWord"
      'Label = "Doku in Word"
      status = FMT0("DOKULIST_4")
    Case "buttonSignOff"
      'Label = "Sign-Off"
      status = FMT0("XLAAPP_24")
    Case "buttonInfo"
      'Label = "Info"
      status = FMT0("XLAAPP_14")
    Case "buttonAppInfo"
      'Label = "Info"
      status = FMT0("XLAAPP_37")
    End Select
End Sub

Public Sub getImage(ByVal control As Object, ByRef img)
    If control.id = "buttonAmpel" Then
        Dim faceId As Long
        Dim t As String
On Error GoTo fehler
        GetAmpelStatusFaceId Application, faceId, t
    
        Dim Pfad As String
        Pfad = G_StartupPath & "gfx\"
    
        If faceId = 946 Then
            Set img = LoadPictureGDI(Pfad & "symbol_questionmark.png")
        ElseIf faceId = 345 Then
            Set img = LoadPictureGDI(Pfad & "question.png")
        ElseIf faceId = 352 Then
            Set img = LoadPictureGDI(Pfad & "signal_flag_red.png")
        ElseIf faceId = 343 Then
            Set img = LoadPictureGDI(Pfad & "signal_flag_yellow.png")
        ElseIf faceId = 394 Then
            Set img = LoadPictureGDI(Pfad & "signal_flag_green.png")
        ElseIf faceId = 342 Then
            Set img = LoadPictureGDI(Pfad & "signal_flag_white.png")
        ElseIf faceId = 346 Then
            Set img = LoadPictureGDI(Pfad & "flash_yellow.png")
        Else
            Set img = LoadPictureGDI(Pfad & "symbol_questionmark.png")
        End If
        ribbon.InvalidateControl "buttonAmpel"
    End If
    Exit Sub
fehler:
End Sub

Attribute VB_Name = "UNC"
Option Explicit
    
' Fuer CacheMappedDrives()
Dim mMappedDrives(0 To 25) As String
Dim mUsedDriveLetters(0 To 25) As String
Dim mNumUsedDrives As Integer
    
#If VBA7 And Win64 Then
' Done
Private Declare PtrSafe Function WNetGetConnectionA Lib "mpr.dll" ( _
  ByVal lpszLocalName As String, _
  ByVal lpszRemoteName As String, _
  cbRemoteName As Long) As Long
#Else
Private Declare Function WNetGetConnectionA Lib "mpr.dll" ( _
  ByVal lpszLocalName As String, _
  ByVal lpszRemoteName As String, _
  cbRemoteName As Long) As Long
#End If

Public Function GetUNCPath(ByVal sLocalPath As String) As String
    '// -----------------------------------------------------------------
    '// Methode:   | Konvertiert einen Pfad in UNC-Pfad (\\SERVER\...)
    '// -----------------------------------------------------------------
    '// Parameter: | sLocalPath = g|fffd|ltiger, lokaler Pfad (X:\..)
    '// -----------------------------------------------------------------
    '// R|fffd|ckgabe:  | bei Erfolg = UNC-Pfad
    '//            | bei Fehler = sLocalPath
    '// -----------------------------------------------------------------
    Const NO_ERROR As Long = 0
    Dim sUNCPath As String
    Dim sResult As String
    Dim sDrive As String
    Dim s As String

    On Error Resume Next
    s = sLocalPath
    If Mid$(sLocalPath, 2, 1) <> ":" Then
      GetUNCPath = GetPathMapping(s)
      Exit Function
    End If
    '// Die API-Funktion ben|fffd|tigt nur das Laufwerk!
    sDrive = Left$(sLocalPath, 2)
    sUNCPath = Space$(260)
    If WNetGetConnectionA(sDrive, sUNCPath, Len(sUNCPath)) = NO_ERROR Then
        sResult = Left$(sUNCPath, InStr(sUNCPath, vbNullChar) - 1)
        If Len(sResult) > 0 Then
            s = sResult & Mid$(sLocalPath, 3)
        End If
    End If
    
    GetUNCPath = GetPathMapping(s)

End Function

' ACHTUNG: Liefert kein UCASE!
' ACHTUNG2: Pr|fffd|fung wird mit Ucase durchgef|fffd|hrt, weil ZIEL immer nur UNC sein kann (HTTP/S ist als Ziel nicht erlaubt)
Function GetPathMapping(ByVal s As String) As String

    If Not G_cfgPathMapSrcCol Is Nothing Then
      Dim i As Long
      For i = 1 To G_cfgPathMapSrcCol.count
        If Left(UCase(s), Len(G_cfgPathMapSrcCol(i))) = UCase(G_cfgPathMapSrcCol(i)) Then
          s = G_cfgPathMapDstCol(i) & Mid(s, Len(G_cfgPathMapSrcCol(i)) + 1)
          s = Replace(s, "/", "\")
          Exit For
        End If
      Next i
    End If
    GetPathMapping = s
End Function
    


Public Sub CacheMappedDrives()
    mNumUsedDrives = 0
    Dim i As Integer
    For i = 65 To 90
        Dim strUNCPath As String
        strUNCPath = ""
        If GetUNCPathShort(Chr(i) & ":", strUNCPath) = 0 Then
            mMappedDrives(mNumUsedDrives) = UCase(strUNCPath)
            mUsedDriveLetters(mNumUsedDrives) = Chr(i)
            mNumUsedDrives = mNumUsedDrives + 1
        Else
        
        End If
    Next i
End Sub

' Wir nehmen an uncPath ist all upper case
Public Function GetCachedMappedDrive(uncPath As String) As String
    GetCachedMappedDrive = uncPath
    Dim i As Integer
    For i = 0 To mNumUsedDrives - 1
        If mMappedDrives(i) = Left$(uncPath, Len(mMappedDrives(i))) Then
            GetCachedMappedDrive = mUsedDriveLetters(i) & ":" & Mid$(uncPath, Len(mMappedDrives(i)) + 1)
            Exit For
        End If
    Next i
End Function

Function GetDriveAndPathFromUNC(ByVal strFullPath As String) As String

    If Mid(strFullPath, 2, 1) = ":" Then
      GetDriveAndPathFromUNC = strFullPath
      Exit Function
    End If

    Dim strUNC As String
    Dim i As Integer
    Dim s As String

    s = strFullPath

    For i = 65 To 90
        If GetUNCPathShort(Chr(i) & ":", strUNC) = 0 Then
            If UCase(strUNC) = UCase(Left(strFullPath, Len(strUNC))) Then
              If Len(Chr(i) & ":" & Mid(strFullPath, Len(strUNC) + 1, Len(strFullPath) - (Len(strUNC)))) < Len(s) Then
                s = Chr(i) & ":" & Mid(strFullPath, Len(strUNC) + 1, Len(strFullPath) - (Len(strUNC)))
              End If
            End If
        End If
    Next i
    
    GetDriveAndPathFromUNC = s
    
End Function


Function GetUNCPathShort(ByVal strDriveLetter As String, _
    ByRef strUNCPath As String) As Long
    On Local Error GoTo GetUNCPath_Err
    Dim strMsg As String
    Dim lngReturn As Long
    Dim strLocalName As String
    Dim strRemoteName As String
    Dim lngRemoteName As Long
    strLocalName = strDriveLetter
    strRemoteName = String$(255, Chr$(32))
    
    lngRemoteName = Len(strRemoteName)
    'Attempt to grab UNC
    lngReturn = WNetGetConnectionA(strLocalName, _
    strRemoteName, _
    lngRemoteName)


    If lngReturn = 0 Then
        
        'No problems - return the UNC
        'to the passed ByRef string
        GetUNCPathShort = 0
        
        
        ' only works for omni 2 build
        ' strUNCPath = LTrim(strRemoteName)
        ' strUNCPath = Left$(strUNCPath, Len(str
        '     UNCPath) - 1)
        
        
        ' less acurate potential for error if se
        '     rver or share contains spaces.
        
        If InStr(strRemoteName, Chr(0)) > 0 Then
          strUNCPath = Left(strRemoteName, InStr(strRemoteName, Chr(0)) - 1)
        Else
          strUNCPath = Mid(strRemoteName, 1, (InStr(1, strRemoteName, " ", 1)) - 2)
        End If
        
        
    Else
        'Problems - so return original
        'drive letter and error number
        GetUNCPathShort = lngReturn
        strUNCPath = strDriveLetter & "\"
    End If
GetUNCPath_End:
    Exit Function
GetUNCPath_Err:
    GetUNCPathShort = 1
    strUNCPath = strDriveLetter
    Resume GetUNCPath_End
End Function






Attribute VB_Name = "UnicodeFile"
Option Explicit

#If VBA7 And Win64 Then
' Done
  Private Declare PtrSafe Function MultiByteToWideChar Lib "Kernel32.dll" ( _
      ByVal codePage As Long, _
      ByVal dwFlags As Long, _
      ByVal lpMultiByteStr As LongPtr, _
      ByVal cbMultiByte As LongPtr, _
      ByVal lpWideCharStr As LongPtr, _
      ByVal cchWideChar As Long _
  ) As Long

  Private Declare PtrSafe Function WideCharToMultiByte Lib "kernel32" ( _
      ByVal codePage As Long, ByVal dwFlags As Long, _
      ByVal lpWideCharStr As LongPtr, ByVal cchWideChar As LongPtr, _
      ByVal lpMultiByteStr As LongPtr, ByVal cchMultiByte As LongPtr, _
      ByVal lpDefaultChar As LongPtr, ByVal lpUsedDefaultChar As LongPtr) As Long
        
#Else
  Private Declare Function MultiByteToWideChar Lib "Kernel32.dll" ( _
      ByVal codePage As Long, _
      ByVal dwFlags As Long, _
      ByVal lpMultiByteStr As Long, _
      ByVal cbMultiByte As Long, _
      ByVal lpWideCharStr As Long, _
      ByVal cchWideChar As Long _
  ) As Long
  
  Private Declare Function WideCharToMultiByte Lib "Kernel32.dll" ( _
      ByVal codePage As Long, _
      ByVal dwFlags As Long, _
      ByVal lpWideCharStr As Long, _
      ByVal cchWideChar As Long, _
      ByVal lpMultiByteStr As Long, _
      ByVal cbMultiByte As Long, _
      ByVal lpDefaultChar As Long, _
      ByVal lpUsedDefaultChar As Long _
  ) As Long
#End If


Public Const CP_ACP        As Long = 0          ' Default ANSI code page.
Public Const CP_UTF8       As Long = 65001      ' UTF8.
Public Const CP_UTF16_LE   As Long = 1200       ' UTF16 - little endian.
Public Const CP_UTF16_BE   As Long = 1201       ' UTF16 - big endian.
Public Const CP_UTF32_LE   As Long = 12000      ' UTF32 - little endian.
Public Const CP_UTF32_BE   As Long = 12001      ' UTF32 - big endian.

' Purpose:  Heuristic to determine whether bytes in a file are UTF-8.
Private Function FileBytesAreUTF8(ByVal the_iFileNo As Integer) As Boolean

    Const knSampleByteSize          As Long = 2048
    Dim nLof                        As Long
    Dim nByteCount                  As Long
    Dim nByteIndex                  As Long
    Dim nCharExtraByteCount         As Long
    Dim bytValue                    As Byte

    ' We look at the first <knSampleByteSize> bytes of the file. However, if the file is smaller, we will have to
    ' use the smaller size.
    nLof = LOF(the_iFileNo)
    If nLof < knSampleByteSize Then
        nByteCount = nLof
    Else
        nByteCount = knSampleByteSize
    End If

    ' Go to the start of the file.
    Seek #the_iFileNo, 1

    For nByteIndex = 1 To nByteCount

        Get #the_iFileNo, , bytValue

        ' If the character we are processing has bytes beyond 1, then we are onto the next character.
        If nCharExtraByteCount = 0 Then
            '
            ' The UTF-8 specification says that the first byte of a character has masking bits which indicate how many bytes follow.
            '
            ' See: http://en.wikipedia.org/wiki/UTF-8#Description
            '
            ' Bytes in
            ' sequence   Byte 1   Byte 2   Byte 3   Byte 4
            ' 1          0xxxxxxx
            ' 2          110xxxxx 10xxxxxx
            ' 3          1110xxxx 10xxxxxx 10xxxxxx
            ' 4          11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
            '
            If (bytValue And &H80) = &H0 Then
                nCharExtraByteCount = 0
            ElseIf (bytValue And &HE0) = &HC0 Then
                nCharExtraByteCount = 1
            ElseIf (bytValue And &HF0) = &HE0 Then
                nCharExtraByteCount = 2
            ElseIf (bytValue And &HF8) = &HF0 Then
                nCharExtraByteCount = 3
            Else
                ' If none of these masks were matched, then this can't be a UTF-8 character.
                FileBytesAreUTF8 = False
                Exit Function
            End If
        Else
            ' All following bytes must be masked as in the table above.
            If (bytValue And &HC0) = &H80 Then
                nCharExtraByteCount = nCharExtraByteCount - 1
                If nCharExtraByteCount = 0 Then
                    FileBytesAreUTF8 = True
                End If
            Else
                ' Not a UTF8 character.
                FileBytesAreUTF8 = False
                Exit Function
            End If
        End If

    Next nByteIndex

End Function

' Purpose:  Take a string whose bytes are in the byte array <the_abytCPString>, with code page <the_nCodePage>, convert to a VB string.
Private Function FromCPString(ByRef the_abytCPString() As Byte, ByVal the_nCodePage As Long) As String

    Dim sOutput                     As String
    Dim nValueLen                   As Long
    Dim nOutputCharLen              As Long

    ' If the code page says this is already compatible with the VB string, then just copy it into the string. No messing.
    If the_nCodePage = CP_UTF16_LE Then
        FromCPString = the_abytCPString()
    Else

        ' Cache the input length.
        nValueLen = UBound(the_abytCPString) - LBound(the_abytCPString) + 1

        ' See how big the output buffer will be.
        nOutputCharLen = MultiByteToWideChar(the_nCodePage, 0&, VarPtr(the_abytCPString(LBound(the_abytCPString))), nValueLen, 0&, 0&)

        ' Resize output byte array to the size of the UTF-8 string.
        sOutput = Space$(nOutputCharLen)

        ' Make this API call again, this time giving a pointer to the output byte array.
        MultiByteToWideChar the_nCodePage, 0&, VarPtr(the_abytCPString(LBound(the_abytCPString))), nValueLen, StrPtr(sOutput), nOutputCharLen

        ' Return the array.
        FromCPString = sOutput

    End If

End Function

Public Function GetContents(ByVal the_sTextFile As String, ByRef out_nCodePage As Long, Optional ByVal the_nDesiredCodePage As Long = -1, Optional ByRef out_bContainedBOM As Boolean) As String

    Dim iFileNo                     As Integer
    Dim abytFileContents()          As Byte
    Dim nDataSize                   As Long

    iFileNo = FreeFile

    OpenForInput the_sTextFile, iFileNo, out_nCodePage, the_nDesiredCodePage, out_bContainedBOM

    ' We want to read the entire contents of the file (not including any BOM value).
    ' After calling OpenForInput(), the file pointer should be positioned after any BOM.
    ' So size file contents buffer to <file size> - <current position> + 1.
    nDataSize = LOF(iFileNo) - Seek(iFileNo) + 1
    ReDim abytFileContents(1 To nDataSize)
    Get #iFileNo, , abytFileContents()

    Close iFileNo

    ' Now we must convert this to UTF-8. But we have to first convert to the Windows NT standard UTF-16 LE.
    GetContents = FromCPString(abytFileContents(), out_nCodePage)

End Function


' Diese Funktion ist langsam!!!!!!!!!!!!!

' Purpose:  Reads up to the end of the current line of the file, repositions to the beginning of the next line, if any, and
'           outputs all characters found.
' Inputs:   the_nFileNo     The number of the file.
' Outputs:  out_sLine       The line from the current position in the file.
' Return:   True if there is more data.
Public Function LineInputUTF8(ByVal the_nFileNo As Integer, ByRef out_sLine As String) As Boolean

    Dim bytValue            As Byte
    Dim abytLine()          As Byte
    Dim nStartOfLinePos     As Long
    Dim nEndOfLinePos       As Long
    Dim nStartOfNextLine    As Long
    Dim nLineLen            As Long

    ' Save the current file position as the beginning of the line, and cache this value.
    nStartOfLinePos = Seek(the_nFileNo)

    ' Retrieves the first byte from the current position.
    Get #the_nFileNo, , bytValue

    ' Loop until the end of file is encountered.
    Do Until EOF(the_nFileNo)

        ' Check whether this byte represents a carriage return or line feed character (indicating new line).
        If bytValue = 13 Or bytValue = 10 Then
            ' By this point, the current position is *after* the CR or LF character, so to get the position of the
            ' last byte in the line, we must go back two bytes.
            nEndOfLinePos = Seek(the_nFileNo) - 2

            ' If this is a carriage return, then we must check the next character.
            If bytValue = 13 Then
                Get #the_nFileNo, , bytValue
                ' Is this a line feed?
                If bytValue = 10 Then
                ' Yes. Assume that CR-LF counts as a single NewLine. So the start of the next line should skip over the line feed.
                    nStartOfNextLine = nEndOfLinePos + 3
                Else
                ' No. The start of the next line is the current position.
                    nStartOfNextLine = nEndOfLinePos + 2
                End If
            ElseIf bytValue = 10 Then
            ' If this is a line feed, then the start of the next line is the current position.
                nStartOfNextLine = nEndOfLinePos + 2
            End If

            ' Since we have processed all the bytes in the line, exit the loop.
            Exit Do
        End If

        ' Get the next byte.
        Get #the_nFileNo, , bytValue
    Loop

    ' Check to see if there was an end of line.
    If nEndOfLinePos = 0 Then
    ' No, this is the end of the file - so use all the remaining characters.
        nLineLen = Seek(the_nFileNo) - nStartOfLinePos - 1
    Else
    ' Yes - so use all the characters up to the end of line position.
        nLineLen = nEndOfLinePos - nStartOfLinePos + 1
    End If

    ' Is this line empty?
    If nLineLen = 0 Then
    ' Yes - just return an empty string.
        out_sLine = vbNullString
    Else
    ' No - pull all the bytes from the beginning to the end of the line into a byte array, and then convert that from UTF-8 to a VB string.
        ReDim abytLine(1 To nLineLen)
        Get #the_nFileNo, nStartOfLinePos, abytLine()
        out_sLine = FromCPString(abytLine(), CP_UTF8)
    End If

    ' If there is a line afterwards, then move to the beginning of the line, and return True.
    If nStartOfNextLine > 0 Then
        Seek #the_nFileNo, nStartOfNextLine
        LineInputUTF8 = True
    End If

End Function

' Purpose:  Analogue of 'Open "fileName" For Input As #fileNo' - but also return what type of text this is via a Code Page value.
' Inputs:   the_sFileName
'           the_iFileNo
'           (the_nDesiredCodePage)  The code page that you want to use with this file.
'                                   If this value is set to the default, -1, this indicates that the code page will be ascertained from the file.
' Outputs:  out_nCodePage           There are only six valid values that are returned if <the_nDesiredCodePage> was set to -1.
'               CP_ACP        ANSI code page
'               CP_UTF8       UTF-8
'               CP_UTF16LE    UTF-16 Little Endian (VB and NT default string encoding)
'               CP_UTF16BE    UTF-16 Big Endian
'               CP_UTF32LE    UTF-32 Little Endian
'               CP_UTF32BE    UTF-32 Big Endian
'           (out_bContainedBOM)     If this was set to True, then the file started with a BOM (Byte Order Marker).
Public Sub OpenForInput(ByRef the_sFilename As String, ByVal the_iFileNo As Integer, ByRef out_nCodePage As Long, Optional ByVal the_nDesiredCodePage As Long = -1, Optional ByRef out_bContainedBOM As Boolean)

    ' Note if we want to take account of every case, we should read in the first four bytes, and check for UTF-32 low and high endian BOMs, check
    ' the first three bytes for the UTF-8 BOM, and finally check the first two bytes for UTF-16 low and hight endian BOMs.
    Dim abytBOM(1 To 4)             As Byte
    Dim nCodePage                   As Long

    ' By default, there is no BOM.
    out_bContainedBOM = False

    Open the_sFilename For Binary Access Read As #the_iFileNo

    ' We are interested in -1 (ascertain code page), and then various UTF encodings.
    Select Case the_nDesiredCodePage
    Case -1, CP_UTF8, CP_UTF16_BE, CP_UTF16_LE, CP_UTF32_BE, CP_UTF32_LE

        ' Default code page.
        nCodePage = CP_ACP

        ' Pull in the first four bytes to determine the BOM (byte order marker).
        Get #the_iFileNo, , abytBOM()

        ' The following are the BOMs for text files:
        '
        ' FF FE         UTF-16, little endian
        ' FE FF         UTF-16, big endian
        ' EF BB BF      UTF-8
        ' FF FE 00 00   UTF-32, little endian
        ' 00 00 FE FF   UTF-32, big-endian
        '
        ' Work out the code page from this information.

        Select Case abytBOM(1)
        Case &HFF
            If abytBOM(2) = &HFE Then
                If abytBOM(3) = 0 And abytBOM(4) = 0 Then
                    nCodePage = CP_UTF32_LE
                Else
                    nCodePage = CP_UTF16_LE
                End If
            End If
        Case &HFE
            If abytBOM(2) = &HFF Then
                nCodePage = CP_UTF16_BE
            End If
        Case &HEF
            If abytBOM(2) = &HBB And abytBOM(3) = &HBF Then
                nCodePage = CP_UTF8
            End If
        Case &H0
            If abytBOM(2) = &H0 And abytBOM(3) = &HFE And abytBOM(4) = &HFF Then
                nCodePage = CP_UTF32_BE
            End If
        End Select

        ' Did we match any BOMs?
        If nCodePage = CP_ACP Then
        ' No - we are still defaulting to the ANSI code page.
            ' Special check for UTF-8. The BOM is not specified in the standard for UTF-8, but according to Wikipedia (which is always right :-) ),
            ' only Microsoft includes this marker at the beginning of files.
            If FileBytesAreUTF8(the_iFileNo) Then
                out_nCodePage = CP_UTF8
            Else
                out_nCodePage = CP_ACP
            End If
        Else
        ' Yes - we have worked out the code page from the BOM.
            ' If no code page was suggested, we now return the code page we found.
            If the_nDesiredCodePage = -1 Then
                out_nCodePage = nCodePage
            End If

            ' Inform the caller that a BOM was found.
            out_bContainedBOM = True
        End If

        ' Reset the file pointer to the beginning of the file data.
        If out_bContainedBOM Then
            ' Note that if the code page found was one of the two UTF-32 values, then we are already in the correct position.
            ' Otherwise, we have to move to just after the end of the BOM.
            Select Case nCodePage
            Case CP_UTF16_BE, CP_UTF16_LE
                Seek #the_iFileNo, 3
            Case CP_UTF8
                Seek #the_iFileNo, 4
            End Select
        Else
            ' There is no BOM, so simply go the beginning of the file.
            Seek #the_iFileNo, 1
        End If

    Case Else
        out_nCodePage = the_nDesiredCodePage
    End Select

End Sub

' Purpose:  Analogue of 'Open "fileName" For Append As #fileNo'
Public Sub OpenForAppend(ByRef the_sFilename As String, ByVal the_iFileNo As Integer, Optional ByVal the_nCodePage As Long = CP_ACP, Optional ByVal the_bPrefixWithBOM As Boolean = True)

    ' Open the file and move to the end of the file.
    Open the_sFilename For Binary Access Write As #the_iFileNo
    Seek the_iFileNo, LOF(the_iFileNo) + 1

    If the_bPrefixWithBOM Then
        WriteBOM the_iFileNo, the_nCodePage
    End If

End Sub

' Purpose:  Analogue of 'Open "fileName" For Output As #fileNo'
Public Sub OpenForOutput(ByRef the_sFilename As String, ByVal the_iFileNo As Integer, Optional ByVal the_nCodePage As Long = CP_ACP, Optional ByVal the_bPrefixWithBOM As Boolean = True)

    ' Ensure we overwrite the file by deleting it ...
    On Error Resume Next
    Kill the_sFilename
    On Error GoTo 0

    ' ... before creating it.
    Open the_sFilename For Binary Access Write As #the_iFileNo

    If the_bPrefixWithBOM Then
        WriteBOM the_iFileNo, the_nCodePage
    End If

End Sub

' Purpose:  Analogue of the 'Print #fileNo, value' statement. But only one value allowed.
'           Setting <the_bAppendNewLine> = False is analagous to 'Print #fileNo, value;'.
Public Sub Print_(ByVal the_iFileNo As Integer, ByRef the_sValue As String, Optional ByVal the_nCodePage As Long = CP_ACP, Optional ByVal the_bAppendNewLine As Boolean = True)

    Const kbytNull                  As Byte = 0
    Const kbytCarriageReturn        As Byte = 13
    Const kbytNewLine               As Byte = 10

    Put #the_iFileNo, , ToCPString(the_sValue, the_nCodePage)

    If the_bAppendNewLine Then
        Select Case the_nCodePage
        Case CP_UTF16_BE
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytCarriageReturn
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNewLine
        Case CP_UTF16_LE
            Put #the_iFileNo, , kbytCarriageReturn
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNewLine
            Put #the_iFileNo, , kbytNull
        Case CP_UTF32_BE
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytCarriageReturn
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNewLine
        Case CP_UTF32_LE
            Put #the_iFileNo, , kbytCarriageReturn
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNewLine
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNull
        Case Else
            Put #the_iFileNo, , kbytCarriageReturn
            Put #the_iFileNo, , kbytNewLine
        End Select
    End If

End Sub

Public Sub PutContents(ByRef the_sFilename As String, ByRef the_sFileContents As String, Optional ByVal the_nCodePage As Long = CP_ACP, Optional the_bPrefixWithBOM As Boolean)

    Dim iFileNo                     As Integer

    iFileNo = FreeFile
    OpenForOutput the_sFilename, iFileNo, the_nCodePage, the_bPrefixWithBOM
    Print_ iFileNo, the_sFileContents, the_nCodePage, False
    Close iFileNo

End Sub

' Purpose:  Converts a VB string (UTF-16) to UTF8 - as a binary array.
Private Function ToCPString(ByRef the_sValue As String, ByVal the_nCodePage As Long) As Byte()

    Dim abytOutput()                As Byte
    Dim nValueLen                   As Long
    Dim nOutputByteLen              As Long

    If the_nCodePage = CP_UTF16_LE Then
        ToCPString = the_sValue
    Else

        ' Cache the input length.
        nValueLen = Len(the_sValue)

        ' See how big the output buffer will be.
        nOutputByteLen = WideCharToMultiByte(the_nCodePage, 0&, StrPtr(the_sValue), nValueLen, 0&, 0&, 0&, 0&)

        If nOutputByteLen > 0 Then
            ' Resize output byte array to the size of the UTF-8 string.
            ReDim abytOutput(1 To nOutputByteLen)

            ' Make this API call again, this time giving a pointer to the output byte array.
            WideCharToMultiByte the_nCodePage, 0&, StrPtr(the_sValue), nValueLen, VarPtr(abytOutput(1)), nOutputByteLen, 0&, 0&
        End If

        ' Return the array.
        ToCPString = abytOutput()

    End If

End Function

Private Sub WriteBOM(ByVal the_iFileNo As Integer, ByVal the_nCodePage As Long)

    ' FF FE         UTF-16, little endian
    ' FE FF         UTF-16, big endian
    ' EF BB BF      UTF-8
    ' FF FE 00 00   UTF-32, little endian
    ' 00 00 FE FF   UTF-32, big-endian

    Select Case the_nCodePage
    Case CP_UTF8
        Put #the_iFileNo, , CByte(&HEF)
        Put #the_iFileNo, , CByte(&HBB)
        Put #the_iFileNo, , CByte(&HBF)
    Case CP_UTF16_LE
        Put #the_iFileNo, , CByte(&HFF)
        Put #the_iFileNo, , CByte(&HFE)
    Case CP_UTF16_BE
        Put #the_iFileNo, , CByte(&HFE)
        Put #the_iFileNo, , CByte(&HFF)
    Case CP_UTF32_LE
        Put #the_iFileNo, , CByte(&HFF)
        Put #the_iFileNo, , CByte(&HFE)
        Put #the_iFileNo, , CByte(&H0)
        Put #the_iFileNo, , CByte(&H0)
    Case CP_UTF32_BE
        Put #the_iFileNo, , CByte(&H0)
        Put #the_iFileNo, , CByte(&H0)
        Put #the_iFileNo, , CByte(&HFE)
        Put #the_iFileNo, , CByte(&HFF)
    End Select

End Sub



Attribute VB_Name = "Win32API"
Option Explicit

Private Const WH_KEYBOARD As Long = &H2&
Private Const WH_KEYBOARD_LL As Long = 13&

Private Const VK_F1 As Long = &H70&

Private Const EVENT_OBJECT_SHOW As Long = &H8002&
Private Const EVENT_OBJECT_HIDE As Long = &H8003&
Private Const WINEVENT_OUTOFCONTEXT As Long = 0

Private Const GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS As Long = &H4&
Private Const GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT As Long = &H2&
 
Private Const HC_ACTION As Long = 0
Private Const HC_NOREMOVE As Long = 3
Private Const WM_KEYDOWN = &H100

Private Const S_OK As Long = 0

Private Const PathDelimiter = "@#$"
 
Private Type Win32Point
   x As Long
   y As Long
End Type

Private Type KBDLLHOOKSTRUCT
  vkCode As Long
  scanCode As Long
  flags As Long
  time As Long
  dwExtraInfo As Long
End Type

'HMODULE WINAPI GetModuleHandle(
'  _In_opt_ LPCTSTR lpModuleName
');
#If VBA7 And Win64 Then
Public Declare PtrSafe Function GetModuleHandleW Lib "kernel32" (ByVal lpModuleName As Long) As Long
'BOOL WINAPI GetModuleHandleEx(
'  _In_     DWORD   dwFlags,
'  _In_opt_ LPCTSTR lpModuleName,
'  _Out_    HMODULE *phModule
');
Public Declare PtrSafe Function GetModuleHandleExW Lib "kernel32" (ByVal dwFlags As Long, ByVal lpModuleName As Long, ByRef phModule As Long) As Long


'HHOOK WINAPI SetWindowsHookEx(
'  _In_ int       idHook,
'  _In_ HOOKPROC  lpfn,
'  _In_ HINSTANCE hMod,
'  _In_ DWORD     dwThreadId
');
Public Declare PtrSafe Function SetWindowsHookEx Lib "user32.dll" Alias "SetWindowsHookExW" (ByVal idHook As Long, ByVal lpfn As Long, ByVal hMod As Long, ByVal dwThreadId As Long) As Long
Private Declare PtrSafe Function CallNextHookEx Lib "user32" ( _
    ByVal hHook As Long, _
    ByVal ncode As Long, _
    ByVal wParam As Long, _
    lParam As Any _
) As Long
'BOOL WINAPI UnhookWindowsHookEx(
'  _In_ HHOOK hhk
');
Public Declare PtrSafe Function UnhookWindowsHookEx Lib "user32.dll" (hhk As Long) As Long

Public Declare PtrSafe Function GetActiveWindow Lib "user32" () As Long

Public Declare PtrSafe Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (pDest As Any, pSource As Any, ByVal cb As LongPtr)

' Hooks fuer IAccessible
Public Declare PtrSafe Function SetWinEventHook Lib "user32.dll" (ByVal eventMin As Long, ByVal eventMax As Long, _
    ByVal hmodWinEventProc As Long, ByVal pfnWinEventProc As Long, ByVal idProcess As Long, _
    ByVal idThread As Long, ByVal dwFlags As Long) As Long
Public Declare PtrSafe Function UnhookWinEvent Lib "user32.dll" (ByVal hWinEventHook As Long) As Long
    
Public Declare PtrSafe Function GetCurrentProcessId Lib "kernel32" () As Long
Public Declare PtrSafe Function GetCurrentThreadId Lib "kernel32" () As Long
Public Declare PtrSafe Function GetWindowThreadProcessId Lib "user32" (ByVal hwnd As LongPtr, lpdwProcessId As Long) As Long

Private Declare PtrSafe Function GetAsyncKeyState Lib "user32" (ByVal vKey As Long) As Integer

'STDAPI AccessibleObjectFromPoint(
'  _In_  POINT       ptScreen,
'  _Out_ IAccessible **ppacc,
'  _Out_ VARIANT     *pvarChild
');
'Public Declare Function AccessibleObjectFromPoint Lib "oleacc.dll" (ByVal ptScreen As Win32Point, ByRef ppacc As IAccessible, ByRef pvarChild As Variant) As Long
Public Declare PtrSafe Function AccessibleObjectFromPoint Lib "oleacc.dll" (ByVal lX As Long, ByVal lY As Long, ppacc As IAccessible, pvarChild As Variant) As Long

Public Declare PtrSafe Function GetCursorPos Lib "user32.dll" (ByRef lpPoint As Win32Point) As Long

Public Declare PtrSafe Function apiGetFocus Lib "user32" Alias "GetFocus" () As LongPtr
#Else

Public Declare Function GetModuleHandleW Lib "kernel32" (ByVal lpModuleName As Long) As Long
'BOOL WINAPI GetModuleHandleEx(
'  _In_     DWORD   dwFlags,
'  _In_opt_ LPCTSTR lpModuleName,
'  _Out_    HMODULE *phModule
');
Public Declare Function GetModuleHandleExW Lib "kernel32" (ByVal dwFlags As Long, ByVal lpModuleName As Long, ByRef phModule As Long) As Long


'HHOOK WINAPI SetWindowsHookEx(
'  _In_ int       idHook,
'  _In_ HOOKPROC  lpfn,
'  _In_ HINSTANCE hMod,
'  _In_ DWORD     dwThreadId
');
Public Declare Function SetWindowsHookEx Lib "user32.dll" Alias "SetWindowsHookExW" (ByVal idHook As Long, ByVal lpfn As Long, ByVal hMod As Long, ByVal dwThreadId As Long) As Long
Private Declare Function CallNextHookEx Lib "user32" ( _
    ByVal hHook As Long, _
    ByVal ncode As Long, _
    ByVal wParam As Long, _
    lParam As Any _
) As Long
'BOOL WINAPI UnhookWindowsHookEx(
'  _In_ HHOOK hhk
');
Public Declare Function UnhookWindowsHookEx Lib "user32.dll" (hhk As Long) As Long

Public Declare Function GetActiveWindow Lib "user32" () As Long

Public Declare Sub CopyMemory Lib "kernel32" _
   Alias "RtlMoveMemory" _
  (pDest As Any, _
   pSource As Any, _
   ByVal cb As Long)

' Hooks fuer IAccessible
Public Declare Function SetWinEventHook Lib "user32.dll" (ByVal eventMin As Long, ByVal eventMax As Long, _
    ByVal hmodWinEventProc As Long, ByVal pfnWinEventProc As Long, ByVal idProcess As Long, _
    ByVal idThread As Long, ByVal dwFlags As Long) As Long
Public Declare Function UnhookWinEvent Lib "user32.dll" (ByVal hWinEventHook As Long) As Long
    
Public Declare Function GetCurrentProcessId Lib "kernel32" () As Long
Public Declare Function GetCurrentThreadId Lib "kernel32" () As Long
Public Declare Function GetWindowThreadProcessId Lib "user32" (ByVal hwnd As Long, lpdwProcessId As Long) As Long

Private Declare Function GetAsyncKeyState Lib "user32" (ByVal vKey As Long) As Integer

'STDAPI AccessibleObjectFromPoint(
'  _In_  POINT       ptScreen,
'  _Out_ IAccessible **ppacc,
'  _Out_ VARIANT     *pvarChild
');
'Public Declare Function AccessibleObjectFromPoint Lib "oleacc.dll" (ByVal ptScreen As Win32Point, ByRef ppacc As IAccessible, ByRef pvarChild As Variant) As Long
Public Declare Function AccessibleObjectFromPoint Lib "oleacc.dll" (ByVal lX As Long, ByVal lY As Long, ppacc As IAccessible, pvarChild As Variant) As Long

Public Declare Function GetCursorPos Lib "user32.dll" (ByRef lpPoint As Win32Point) As Long
Public Declare Function apiGetFocus Lib "user32" Alias "GetFocus" () As Long
#End If


#If VBA7 And Win64 Then
  Public MyHWND As LongPtr
#Else
  Public MyHWND As Long
#End If

Private MyWindowHook As Long
'Private MyEventHook As Long
'Private MyCurrentAccessibleObjectName As String


' Das geht aber es gibt keine Moeglichkeit den original Handler aufzurufen. Dann kann man nicht mehr die Excelhilfe mit F1 aufrufen.
' https://msdn.microsoft.com/VBA/Excel-VBA/articles/application-onkey-method-excel
' Wir benutzen das im VBA addin um zu verhindern, dass Excel seine Hilfe aufmacht, wenn wir unsere aufmachen.
'
' Excel 2016: Wir rufen einfach Application.Help mit nem Help file, dass es nicht gibt auf. Dann geht die normale Excel Hilfe auf.
' Allerdings ist die dann nicht mehr Kontextsensitiv!
Private Sub MyOnKeyHandler()
  ' Auskomemntiert, da dies bei Excel in Word (Embedded Objekt) zu abst|fffd|rzen f|fffd|hrtn, wenn die Plugins inaktiv sind. M|fffd|ssen wir mal suchen...
    ' Vor Excel 2016: Den handler sofort wieder entfernen und raus hier
    If val(Application.Version) < 16 Then
        Call Application.OnKey("{F1}")
        Exit Sub
    End If
    
    ' Ab Excel 2016: checken ob die Maus ueber einem der ExcelTracker Ribbon Icons ist. Wenn ja, unsere Hilfe aufmachen
    ' Wenn nicht, einfach Application.Help("?") aufrufen. Das macht den Main Index der Excel-Hilfe auf.
    Dim pt As Win32Point
    If GetCursorPos(pt) = 0 Then
        Exit Sub
    End If
    Dim accessibleObj As IAccessible
    Dim childObj As Variant
    If AccessibleObjectFromPoint(pt.x, pt.y, accessibleObj, childObj) = S_OK Then
        Dim path As String
        path = GetAccessiblePathName(accessibleObj)
        If Not ShowIconHelp(path) Then
            Dim parts() As String
            parts = Split(path, PathDelimiter)
            Dim n As Long
            n = UBound(parts)
            If n > 0 Then
                Dim topic As String
                topic = parts(n)
                Call Application.Help(topic)
            End If
            'Call Application.Help("?")
        End If
    End If
End Sub

'Private Sub MyTimerCheck()
'    Dim state As Integer
'    state = GetAsyncKeyState(VK_F1)
'    ' F1 gedrueckt und vorher nicht gedrueckt
'    If (state And &H8000) <> 0 Then
'        Dim pt As Win32Point
'        If GetCursorPos(pt) = 0 Then
'            Exit Function
'        End If
'        Dim accessibleObj As IAccessible
'        Dim childObj As Variant
'        If AccessibleObjectFromPoint(pt.x, pt.y, accessibleObj, childObj) = S_OK Then
'            Dim path As String
'            path = GetAccessiblePathName(accessibleObj)
'            Call ShowIconHelp(path)
'        End If
'    End If
'    Application.OnTime Now + TimeValue("00:00:01", "MyTimerCheck")
'End Sub

Public Sub InitHooks()
  ' Auskomemntiert, da dies bei Excel in Word (Embedded Objekt) zu abst|fffd|rzen f|fffd|hrtn, wenn die Plugins inaktiv sind. M|fffd|ssen wir mal suchen...
    On Error GoTo nogo
    
    ' Fuer Access nichts machen!
    #If PROJECT_ACCESSTRACKER = 1 Then
        Exit Sub
    #End If
    
    ' Ab Excel 2016: Das ist die wesentlich angenehmere Variante mit dem Excel-Internen OnKey handler.
    ' Nachteil: Kontextsensitive Hilfe geht nicht mehr.
    If val(Application.Version) >= 16 Then
        Call Application.OnKey("{F1}", "MyOnKeyHandler")
        Exit Sub
    End If
    
    If MyWindowHook <> 0 Then Exit Sub
    
    ' In VB6 nix hooken, wenn wir im Debugger laufen. Dort macht SetWindowsHookEx Probleme, da wir dann in der IDE events abfangen und es crasht ueberall.
    'If Not RunningInIDE() Then
    'If Not InIDE() Then
    ' In VBA nix machen, wenn ein xlsm geoeffnet wird (also z.B. unser eigenes ExcelTracker.xlsm). Das haengt dann ueberall.
    ' In Workbook_Activate releasen wir hooks auch sofort sobald jemand zu einem Macro-Enabled-Workbook wechselt.
    If Not LCase(Right(ThisWorkbook.name, 5)) = ".xlsm" Then
        Dim threadid As Long
        Dim pid As Long
        threadid = GetWindowThreadProcessId(MyHWND, pid)
'MsgBox "HWND: " & CStr(MyHWND) & " ProcessID: " & CStr(pid) & " ThreadID: " & CStr(threadid) & " Module: " & MyHInstance
'Debug.Print "HWND: " & CStr(MyHWND) & " ProcessID: " & CStr(pid) & " ThreadID: " & CStr(threadid) & " Module: " & MyHInstance
        
        ' Geht nicht
        'MyWindowHook = SetWindowsHookExW(WH_KEYBOARD, AddressOf Win32API.WindowHookProc, 0&, threadid)
        ' Geht nicht
        'MyWindowHook = SetWindowsHookExW(WH_KEYBOARD, AddressOf Win32API.WindowHookProc, MyHInstance, 0&)
        ' Geht in VB6 - aber hooked die IDE im Debugger. Geht nicht in VBA (2010 und 2016) - Excel haengt dann nach einem Tastendruck!
        'MyWindowHook = SetWindowsHookEx(WH_KEYBOARD, AddressOf Win32API.WindowHookProc, 0&, GetCurrentThreadId())
        ' Geht in VBA mit Excel 2010, geht nicht mit Excel 2016
' XXX64
#If VBA7 And Win64 Then
#Else
        MyWindowHook = SetWindowsHookEx(WH_KEYBOARD_LL, AddressOf Win32API.WindowHookProcLL, Application.HinstancePtr, 0&)
#End If

        'MyWindowHook = SetWindowsHookEx(WH_KEYBOARD_LL, AddressOf Win32API.WindowHookProcLL, MyHInstance, 0&)
        'MyWindowHook = SetWindowsHookEx(WH_KEYBOARD_LL, AddressOf Win32API.WindowHookProcLL, 0&, GetCurrentThreadId())
'MsgBox "Hook CB: " & MyWindowHook
'Debug.Print "Windows hook initialized. MyWindowHook: " & MyWindowHook
        
        ' Die Events abfangen wenn z.B. Tooltips im Office Window angezeigt werden
        ' Im Debugger wird das die ProcessId der VB IDE!
        'MyEventHook = SetWinEventHook(EVENT_OBJECT_SHOW, EVENT_OBJECT_HIDE, 0&, AddressOf Win32API.WinEventProc, GetCurrentProcessId(), 0, WINEVENT_OUTOFCONTEXT)
        ' Das Gleiche!
        'MyEventHook = SetWinEventHook(EVENT_OBJECT_SHOW, EVENT_OBJECT_HIDE, 0&, AddressOf Win32API.WinEventProc, 0, GetCurrentThreadId(), 0)
        ' Das hookt alle Prozesse!
        'MyEventHook = SetWinEventHook(EVENT_OBJECT_SHOW, EVENT_OBJECT_HIDE, 0&, AddressOf Win32API.WinEventProc, 0, 0, WINEVENT_OUTOFCONTEXT)
        ' Das geht - brauchen wir so aber gar nicht. Wir checken was unter der Maus ist direkt im WindowsHook Key Handler.
        'MyEventHook = SetWinEventHook(EVENT_OBJECT_SHOW, EVENT_OBJECT_HIDE, 0&, AddressOf Win32API.WinEventProc, pid, 0, WINEVENT_OUTOFCONTEXT)
    End If
nogo:
End Sub

Public Sub ReleaseHooks()
  ' Auskomemntiert, da dies bei Excel in Word (Embedded Objekt) zu abst|fffd|rzen f|fffd|hrtn, wenn die Plugins inaktiv sind. M|fffd|ssen wir mal suchen...
'    If MyEventHook <> 0 Then
'        Call UnhookWinEvent(MyEventHook)
'        MyEventHook = 0
'        Debug.Print "Event hook unhooked!"
'    End If
    If MyWindowHook <> 0 Then
        Call UnhookWindowsHookEx(MyWindowHook)
        MyWindowHook = 0
        DebugPrint tinfo, "Windows hook unhooked"
        'MsgBox ThisWorkbook.name & " hooks released!"
    End If
End Sub

Private Function ShowIconHelp(accessiblePath As String) As Boolean
    Dim parts() As String
    parts = Split(accessiblePath, PathDelimiter)
    
    Dim file As String
    Dim n As Long
    n = UBound(parts)
    If n > 0 Then
        file = parts(n)
        file = Replace(file, " ", "_")
        file = CorrectErrorCharactersInFilename(file)
    End If
    
    If file = "" Then Exit Function
    
    ' Path Beispiel bei aktivierten Ribbon Icons mit Maus ueber dem "Doku" Icon
    ' .../ExcelTracker/ExcelTracker Toolset/Doku
    
    ' Path bei den alten Icons (ist immer so), die Maus ist im Bereich der Icons
    ' .../Add-Ins/Benutzerdefinierte Symbolleisten/Benutzdefienierte Symbolleiste/
    Dim helpFile As String
    
    If InStr(accessiblePath, "ExcelTracker") > 0 Then
        ' Ribbon
        helpFile = G_cfgTemppfad & "\..\Help\" & file & ".mht"
'MsgBox helpFile
    ElseIf InStr(accessiblePath, "Add-Ins/Benutzerdefinierte Symbolleisten") > 0 Then
        ' Alte Icons
        ' Das funktioniert so nur mit deutschem Excel und wuerde unsere Hilfe fuer alle Add-ins anzeigen!
        'helpFile = G_cfgTemppfad & "\..\Help\ExcelTracker.mht"
        ' Nix machen!
        ShowIconHelp = False
        Exit Function
    Else
        ' Was anderes -> nix machen
        ShowIconHelp = False
        Exit Function
    End If
    
    If helpFile <> "" Then
        If FileExists(helpFile) Then
            Dim wshShell
            Set wshShell = CreateObject("WScript.Shell")
            wshShell.Run "iexplore " & helpFile
            Set wshShell = Nothing
            ShowIconHelp = True
            Exit Function
        End If
    End If
End Function

' http://www.vbforums.com/showthread.php?231468-VB-Detect-if-you-are-running-in-the-IDE
Public Function RunningInIDE() As Boolean
    Static counter As Variant
    If IsEmpty(counter) Then
        counter = 1
        Debug.Assert RunningInIDE() Or True
        counter = counter - 1
    ElseIf counter = 1 Then
        counter = 0
    End If
    RunningInIDE = counter
End Function

Private Function InIDE() As Boolean
    On Error Resume Next
    Debug.Print 1 / 0
    InIDE = err.Number
End Function


'Public Function GetCurrentModule() As Long
'    Dim hModule As Long
'    If GetModuleHandleExW(GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT, AddressOf Win32API.WindowHookProcLL, hModule) <> 0 Then
'        GetCurrentModule = hModule
'    End If
'End Function

' Regulaerer KeyboardHook callback
' https://msdn.microsoft.com/en-us/library/windows/desktop/ms644984(v=vs.85).aspx
'
' In Excel VBA genau das Problem wie im Link von 2004! Es kommen kontinuierlich Events, dann haengt Excel.
' http://www.xtremevbtalk.com/archive/index.php/t-164214.html
' Deshalb hooken wir Low Level Keyboard Events in VBA.
' http://www.codeguru.com/vb/gen/vb_system/keyboard/article.php/c4829/Managing-LowLevel-Keyboard-Hooks-with-the-Windows-API.htm
'
' Low-Level-Keyboard Hook Callback
' https://msdn.microsoft.com/en-us/library/windows/desktop/ms644985(v=vs.85).aspx
'
' Achtung: Low Level Events haben einen Timeout enforced by Windows (wenige ms). Wenn man laenger braucht, wird man nie wieder aufgerufen.
' https://msdn.microsoft.com/en-us/library/windows/desktop/ms644985(v=vs.85).aspx
' The hook procedure should process a message in less time than the data entry specified in the LowLevelHooksTimeout value in the following registry key:
' HKEY_CURRENT_USER\Control Panel\Desktop
' The value is in milliseconds. If the hook procedure times out, the system passes the message to the next hook. However, on Windows 7 and later, the hook
' is silently removed without being called. There is no way for the application to know whether the hook is removed.
' Defaultwert ist wohl 5000ms
'
' Update: Das wird in Excel 2016 nie aufgerufen - geht also nicht
#If VBA7 And Win64 Then
Private Function WindowHookProcLL(ByVal ncode As Long, ByVal wParam As Long, ByVal lParam As LongPtr) As Long
#Else
Private Function WindowHookProcLL(ByVal ncode As Long, ByVal wParam As Long, ByVal lParam As Long) As Long
#End If
    On Error GoTo nogo
    If ncode < 0 Then
      WindowHookProcLL = CallNextHookEx(MyWindowHook, ncode, wParam, lParam)
    End If
    If MyWindowHook = 0 Then
      Exit Function
    End If
    
    If ncode = HC_ACTION Or ncode = HC_NOREMOVE Then
        If wParam = WM_KEYDOWN Then
            Static hookstruct As KBDLLHOOKSTRUCT
            Call CopyMemory(hookstruct, ByVal lParam, Len(hookstruct))
            If hookstruct.vkCode = VK_F1 Then
                Dim pt As Win32Point
                If GetCursorPos(pt) = 0 Then
                    Exit Function
                End If
                Dim accessibleObj As IAccessible
                Dim childObj As Variant
                If AccessibleObjectFromPoint(pt.x, pt.y, accessibleObj, childObj) = S_OK Then
                    Dim path As String
                    path = GetAccessiblePathName(accessibleObj)
                    If ShowIconHelp(path) Then
                        ' Signalisieren, dass wir die Message gehandelt haben.
                        ' Problem hier: Da das hier Low Level Keyboard Events sind, bekommt Excel trotzdem nochmal einen F1 Event.
                        WindowHookProcLL = 1
                        ' Deshalb hier F1 ueber die Excel Funktionen hooken und in MyOnKeyHandler direkt wieder unhooken.
                        'Call Application.OnKey("{F1}", "MyOnKeyHandler")
                        Exit Function
                    End If
                End If
            End If
        End If
    End If
    WindowHookProcLL = CallNextHookEx(MyWindowHook, ncode, wParam, lParam)
    'WindowHookProc = 1
nogo:
End Function

Private Function WindowHookProc(ByVal ncode As Long, ByVal wParam As Long, ByVal lParam As Long) As Long
    On Error GoTo nogo
    If ncode < 0 Then
      WindowHookProc = CallNextHookEx(MyWindowHook, ncode, wParam, lParam)
    End If
    
    If ncode = HC_ACTION Or ncode = HC_NOREMOVE Then
        ' Ist es F1 und die Taste ist gedrueckt und war vorher nicht gedrueckt?
        If wParam = VK_F1 And ((lParam And &H80000000) = 0) And ((lParam And &H40000000) = 0) Then
            Dim pt As Win32Point
            If GetCursorPos(pt) = 0 Then
                Exit Function
            End If
            Dim accessibleObj As IAccessible
            Dim childObj As Variant
            If AccessibleObjectFromPoint(pt.x, pt.y, accessibleObj, childObj) = S_OK Then
                Dim path As String
                path = GetAccessiblePathName(accessibleObj)
                If ShowIconHelp(path) Then
                    ' Signalisieren, dass wir die Message gehandelt haben. Dann macht Excel nicht nochmal seine eigene Hilfe auf.
                    WindowHookProc = 1
                    Exit Function
                End If
            End If
        End If
    End If
    WindowHookProc = CallNextHookEx(MyWindowHook, ncode, wParam, lParam)
    'WindowHookProc = 1
nogo:
End Function



'void CALLBACK WinEventProc(
'   HWINEVENTHOOK hWinEventHook,
'   DWORD         event,
'   HWND          hwnd,
'   LONG          idObject,
'   LONG          idChild,
'   DWORD         dwEventThread,
'   DWORD dwmsEventTime
');
'Private Sub WinEventProc(ByVal hWinEventHook As Long, ByVal eventType As Long, ByVal idObject As Long, ByVal idChild As Long, ByVal dwEventThread As Long, ByVal dwmsEventTime As Long)
'    On Error GoTo nogo
'
'    If hWinEventHook <> MyEventHook Then
'        Exit Sub
'    End If
'    If eventType = EVENT_OBJECT_HIDE Then
'        MyCurrentAccessibleObjectName = ""
'        Exit Sub
'    End If
'    If eventType <> EVENT_OBJECT_SHOW Then
'       Exit Sub
'    End If
'
'    Dim pt As Win32Point
'    If GetCursorPos(pt) = 0 Then
'        Exit Sub
'    End If
'
'    Dim accessibleObj As IAccessible
'    Dim childObj As Variant
'    '0 = S_OK
'    If AccessibleObjectFromPoint(pt.x, pt.y, accessibleObj, childObj) = 0 Then
'        MyCurrentAccessibleObjectName = GetAccessiblePathContext(accessibleObj)
'        Debug.Print MyCurrentAccessibleObjectName
'    End If
'nogo:
'End Sub

Private Function GetAccessiblePathName(accessibleObj As IAccessible) As String
    On Error GoTo nogo
    
    Dim names(100) As String
    Dim obj As IAccessible
    Set obj = accessibleObj
    Dim n As Long
    Do While Not (obj Is Nothing) And (n < 99)
        names(n) = obj.accName(0&)
        n = n + 1
        Set obj = obj.accParent
    Loop
    
    Dim path As String
    Dim i As Long
    For i = n - 1 To 0 Step -1
        If path = "" Then
            path = names(i)
        Else
            path = path & PathDelimiter & names(i)
        End If
    Next i
    
    GetAccessiblePathName = path
nogo:
    Set obj = Nothing
End Function

'Private Function GetAccessiblePathContext(accessibleObj As IAccessible) As String
'    On Error GoTo nogo
'
'    Dim parent As IAccessible
'    Set parent = accessibleObj.accParent
'    If parent Is Nothing Then Exit Function
'
'
'    Dim name As String
'    name = parent.accName(0&)
'    ' Nur im "ExcelTracker" Ribbon beruecksichtigen!
'    If InStr(name, "ExcelTracker") Then
'        ' Muss 0& sein! Mit 0 kommt nix!
'        GetAccessiblePathContext = accessibleObj.accName(0&)
'    End If
'nogo:
'    Set parent = Nothing
'End Function

Public Function GetScreenDPI(bVert As Boolean) As Long
  'in most cases this simply returns 96
#If VBA7 And Win64 Then
  Dim lDC^
#Else
  Dim lDC&
#End If

  Static lngDPI&(1)
  If lngDPI(0) = 0 Then
    lDC = GetWindowDC(0)
    lngDPI(0) = GetDeviceCaps(lDC, WU_LOGPIXELSX)    'horz
    lngDPI(1) = GetDeviceCaps(lDC, WU_LOGPIXELSY)    'vert
    lDC = ReleaseDC(0, lDC)
  End If
  GetScreenDPI = lngDPI(Abs(bVert))
End Function

Public Function PTtoPX(ByVal Points As Single, Optional bVert As Boolean = False) As Long
  PTtoPX = Points * GetScreenDPI(bVert) / 72
End Function

Public Function PXtoPT(ByVal Pixels As Single, Optional bVert As Boolean = False) As Long
  PXtoPT = Pixels / GetScreenDPI(bVert) * 72
End Function

#If VBA7 And Win64 Then
Public Function GetHDC(ByRef ctl As control) As LongPtr
#Else
Public Function GetHDC(ByRef ctl As control) As Long
#End If
    ' Acquire the Handle (hWnd) of the passed
    ' MS -Access Control.
    On Error Resume Next
    ' Make sure the passed Control has Focus.
    ctl.SetFocus
    GetHDC = GetWindowDC(apiGetFocus)
    On Error GoTo 0
End Function


Attribute VB_Name = "WinStuff"
Option Explicit

Private Type GUID_TYPE
Data1 As Long
Data2 As Integer
Data3 As Integer
Data4(7) As Byte
End Type

' Access the GetUserNameA function in advapi32.dll and
' call the function GetUserName.
#If VBA7 Then
' Done
  #If Win64 Then
    Public Declare PtrSafe Function GetTickCount Lib "kernel32" () As LongLong
  #Else
    Public Declare PtrSafe Function GetTickCount Lib "kernel32" () As Long
  #End If
#Else
  Public Declare Function GetTickCount Lib "kernel32" () As Long
#End If


#If VBA7 And Win64 Then
' Done
Public Declare PtrSafe Function apiGetUserName Lib "advapi32.dll" Alias "GetUserNameA" (ByVal lpBuffer As String, nSize As Long) As Long
Public Declare PtrSafe Function apiGetComputerName Lib "kernel32" Alias "GetComputerNameA" (ByVal lpBuffer As String, nSize As Long) As Long
Public Declare PtrSafe Function GetWindowText Lib "user32" Alias "GetWindowTextA" (ByVal hwnd As LongPtr, ByVal lpString As String, ByVal cch As Long) As Long
Public Declare PtrSafe Function GetForegroundWindow Lib "user32" () As LongPtr
Public Declare PtrSafe Function GetWindow Lib "user32" (ByVal hwnd As LongPtr, ByVal wCmd As Long) As LongPtr
Public Declare PtrSafe Function GetWindowDC Lib "user32" (ByVal hwnd As LongPtr) As LongPtr
Public Declare PtrSafe Function ReleaseDC Lib "user32" (ByVal hwnd As LongPtr, ByVal hdc As LongPtr) As Long
Public Declare PtrSafe Function GetDeviceCaps Lib "gdi32" (ByVal hdc As LongPtr, ByVal nIndex As Long) As Long
Public Declare PtrSafe Function GetFocus Lib "user32" () As LongPtr
Public Declare PtrSafe Function GetClientRect Lib "user32" (ByVal hwnd As LongPtr, lpRect As RECT) As Long
Public Declare PtrSafe Function GetDesktopWindow Lib "user32" () As LongPtr
Private Declare PtrSafe Function CoCreateGuid Lib "ole32.dll" (guid As GUID_TYPE) As LongPtr
Private Declare PtrSafe Function StringFromGUID2 Lib "ole32.dll" (guid As GUID_TYPE, ByVal lpStrGuid As LongPtr, ByVal cbMax As Long) As LongPtr
 
#Else
Private Declare Function CoCreateGuid Lib "ole32.dll" (guid As GUID_TYPE) As Long
Private Declare Function StringFromGUID2 Lib "ole32.dll" (guid As GUID_TYPE, ByVal lpStrGuid As Long, ByVal cbMax As Long) As Long
 
Declare Function apiGetUserName Lib "advapi32.dll" Alias "GetUserNameA" _
(ByVal lpBuffer As String, nSize As Long) As Long

Private Declare Function apiGetComputerName Lib "kernel32" Alias _
    "GetComputerNameA" (ByVal lpBuffer As String, nSize As Long) As Long

Declare Function GetWindowText Lib "user32" Alias "GetWindowTextA" (ByVal hwnd As Long, ByVal lpString As String, ByVal cch As Long) As Long
Declare Function GetForegroundWindow Lib "user32.dll" () As Long
Declare Function GetWindow Lib "user32" (ByVal hwnd As Long, ByVal wCmd As Long) As Long

' The API function used to acquire the Device Context
' (DC) of a Window (or Control).
Public Declare Function GetWindowDC Lib "user32" (ByVal hwnd As Long) As Long
Public Declare Function GetDeviceCaps Lib "gdi32" (ByVal hdc As Long, ByVal nIndex As Long) As Long
Public Declare Function ReleaseDC Lib "user32" (ByVal hwnd As Long, ByVal hdc As Long) As Long
Public Declare Function GetClientRect Lib "user32" (ByVal hwnd As Long, lpRect As RECT) As Long
Public Declare Function GetDesktopWindow Lib "user32" () As Long
#End If


Public Const HORZRES = 8
Public Const VERTRES = 10
Public Const WU_LOGPIXELSX = 88
Public Const WU_LOGPIXELSY = 90
Public Const TWIPSPERINCH = 1440

 Public G_MyUser As String
 Public Const GW_HWNDNEXT = 2
 Public Const GW_CHILD = 5


 
Function CreateGuidString()
Dim guid As GUID_TYPE
Dim strGuid As String
#If VBA7 And Win64 Then
Dim retValue As LongPtr
#Else
Dim retValue As LongPtr
#End If
Const guidLength As Long = 39 'registry GUID format with null terminator {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}
retValue = CoCreateGuid(guid)
If retValue = 0 Then
strGuid = String$(guidLength, vbNullChar)
retValue = StringFromGUID2(guid, StrPtr(strGuid), guidLength)
If retValue = guidLength Then
' valid GUID as a string
CreateGuidString = strGuid
End If
End If
End Function
 
' Main routine to Dimension variables, retrieve user name
' and display answer.
Public Function GetUserName() As String

    If G_MyUser <> "" Then
      GetUserName = G_MyUser
      Exit Function
    End If
    
    ' Dimension variables
    Dim lpBuff As String * 25
    Dim ret As Long
    
    ' Get the user name minus any trailing spaces found in the name.
    ret = apiGetUserName(lpBuff, 25)
    G_MyUser = Left(lpBuff, InStr(lpBuff, Chr(0)) - 1)
    GetUserName = G_MyUser
    
End Function

Public Function GetUserNameUCASE() As String
    GetUserNameUCASE = UCase(GetUserName)
End Function

Public Function GetComputerName() As String
'Returns the computername
    Dim lngLen As Long, lngX As Long
    Dim strCompName As String
    lngLen = 16
    strCompName = String$(lngLen, 0)
    lngX = apiGetComputerName(strCompName, lngLen)
    If lngX <> 0 Then
        GetComputerName = Left$(strCompName, lngLen)
    Else
        GetComputerName = ""
    End If
End Function

Public Function GetDesktopExtent(bVert As Boolean) As Long
    Static lngDesktopExtent&(1)
    If lngDesktopExtent(0) = 0 Then
        Dim ret As Long
        Dim screenRect As RECT
        ret = GetClientRect(CLng(GetDesktopWindow()), screenRect)
        lngDesktopExtent(0) = screenRect.Right - screenRect.Left
        lngDesktopExtent(1) = screenRect.Bottom - screenRect.Top
    End If
    GetDesktopExtent = lngDesktopExtent(Abs(bVert))
        
End Function




''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' modWaitForFileClose
' By Chip Pearson, www.cpearson.com chip@cpearson.com
'
' This module contains the WaitForFileClose and IsFileOpen functions.
' See http://www.cpearson.com/excel/WaitForFileClose.htm for more documentation.
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Public Function WaitForFileClose(filename As String, ByVal TestIntervalMilliseconds As Long, _
    ByVal TimeOutMilliseconds As Long) As Boolean
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' WaitForFileClose
' This function tests to see if a specified file is open. If the file is not
' open, it returns a value of True and exists immediately. If FileName is
' open, the code goes into a wait loop, testing whether the is still open
' every TestIntervalMilliSeconds. If the is closed while the function is
' waiting, the function exists with a result of True. If TimeOutMilliSeconds
' is reached and file remains open, the function exits with a result of
' False. The function will return True is FileName does not exist.
' If TimeOutMilliSeconds is reached and the file remains open, the function
' returns False.
' If FileName refers to a workbook that is open Shared, the function returns
' True and exits immediately.
' This function requires the IsFileOpen function and the Sleep and GetTickCount
' API functions.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

#If VBA7 And Win64 Then
Dim StartTickCount As LongLong
Dim EndTickCount As LongLong
Dim TickCountNow As LongLong
#Else
Dim StartTickCount As Long
Dim EndTickCount As Long
Dim TickCountNow As Long
#End If
Dim FileIsOpen As Boolean
Dim Done As Boolean
' Dim CancelKeyState As Long

'''''''''''''''''''''''''''''''''''''''''''''''
' Before we do anything, first test if the file
' is open. If it is not, get out immediately.
'''''''''''''''''''''''''''''''''''''''''''''''
FileIsOpen = IsFileOpen(filename:=filename)
If FileIsOpen = False Then
    WaitForFileClose = True
    Exit Function
End If

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' If TestIntervalMilliseconds <= 0, use a default value of 500.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
If TestIntervalMilliseconds <= 0 Then
    TestIntervalMilliseconds = 500
End If


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Here, we save the state of EnableCancelKey, and set it to
' xlErrorHandler. This will cause an error 18 to raised if the
' user press CTLR+BREAK. In this case, we'll abort the wait
' procedure and return False.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' CancelKeyState = Application.EnableCancelKey
' Application.EnableCancelKey = xlErrorHandler
On Error GoTo ErrHandler:

'''''''''''''''''''''''''''''''
' Get the current tick count.
'''''''''''''''''''''''''''''''
StartTickCount = GetTickCount()
If TimeOutMilliseconds <= 0 Then
    ''''''''''''''''''''''''''''''''''''''''
    ' If TimeOutMilliSeconds is negative,
    ' we'll wait forever.
    ''''''''''''''''''''''''''''''''''''''''
    EndTickCount = -1
Else
    ''''''''''''''''''''''''''''''''''''''''
    ' If TimeOutMilliseconds > 0, get the
    ' tick count value at which we will
    ' give up on the wait and return
    ' false.
    ''''''''''''''''''''''''''''''''''''''''
    EndTickCount = StartTickCount + TimeOutMilliseconds
End If

Done = False
Do Until Done
    ''''''''''''''''''''''''''''''''''''''''''''''''
    ' Test if the file is open. If it is closed,
    ' exit with a result of True.
    ''''''''''''''''''''''''''''''''''''''''''''''''
    If IsFileOpen(filename:=filename) = False Then
        WaitForFileClose = True
        ' Application.EnableCancelKey = CancelKeyState
        Exit Function
    End If
    ''''''''''''''''''''''''''''''''''''''''''
    ' Go to sleep for TestIntervalMilliSeconds
    ' milliseconds.
    '''''''''''''''''''''''''''''''''''''''''
    Sleep dwMilliseconds:=TestIntervalMilliseconds
    TickCountNow = GetTickCount()
    If EndTickCount > 0 Then
        '''''''''''''''''''''''''''''''''''''''''''''
        ' If EndTickCount > 0, a specified timeout
        ' value was provided. Test if we have
        ' exceeded the time. Do one last test for
        ' FileOpen, and exit.
        '''''''''''''''''''''''''''''''''''''''''''
        If TickCountNow >= EndTickCount Then
            WaitForFileClose = Not (IsFileOpen(filename))
            ' Application.EnableCancelKey = CancelKeyState
            Exit Function
        Else
            '''''''''''''''''''''''''''''''''''''''''
            ' TickCountNow is less than EndTickCount,
            ' so continue to wait.
            '''''''''''''''''''''''''''''''''''''''''
        End If
    Else
        ''''''''''''''''''''''''''''''''
        ' EndTickCount < 0, meaning wait
        ' forever. Test if the file
        ' is open. If the file is not
        ' open, exit with a TRUE result.
        ''''''''''''''''''''''''''''''''
        If IsFileOpen(filename:=filename) = False Then
            WaitForFileClose = True
            ' Application.EnableCancelKey = CancelKeyState
            Exit Function
        End If
        
    End If
    DoEvents
Loop

'''''''''''''''''''''''''''''''''''''''''''''''''''
' The following Exit Function line will never be
' executed, but it included for logical consistency.
' The return code is set and the function is
' terminated within the Loop above.
'''''''''''''''''''''''''''''''''''''''''''''''''''
Exit Function

ErrHandler:
'''''''''''''''''''''''''''''''''''
' This is the error handler block.
' For any error, return False.
'''''''''''''''''''''''''''''''''''
' Application.EnableCancelKey = CancelKeyState
WaitForFileClose = False

End Function


Private Function IsFileOpen(filename As String) As Boolean
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' IsFileOpen
' By Chip Pearson www.cpearson.com/excel chip@cpearson.com
' This function determines whether a file is open by any program. Returns TRUE or FALSE
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Dim FileNum As Integer
Dim ErrNum As Integer

On Error Resume Next   ' Turn error checking off.

'''''''''''''''''''''''''''''''''''''''''''
' If we were passed in an empty string,
' there is no file to test so return FALSE.
'''''''''''''''''''''''''''''''''''''''''''
If filename = vbNullString Then
    IsFileOpen = False
    Exit Function
End If

'''''''''''''''''''''''''''''''
' If the file doesn't exist,
' it isn't open so get out now.
'''''''''''''''''''''''''''''''
If Dir(filename) = vbNullString Then
    IsFileOpen = False
    Exit Function
End If
''''''''''''''''''''''''''
' Get a free file number.
''''''''''''''''''''''''''
FileNum = FreeFile()
'''''''''''''''''''''''''''
' Attempt to open the file
' and lock it.
'''''''''''''''''''''''''''
err.Clear
Open filename For Input Lock Read As #FileNum
''''''''''''''''''''''''''''''''''''''
' Save the error number that occurred.
''''''''''''''''''''''''''''''''''''''
ErrNum = err.Number
On Error GoTo 0        ' Turn error checking back on.
Close #FileNum       ' Close the file.
''''''''''''''''''''''''''''''''''''
' Check to see which error occurred.
''''''''''''''''''''''''''''''''''''
Select Case ErrNum
    Case 0
    '''''''''''''''''''''''''''''''''''''''''''
    ' No error occurred.
    ' File is NOT already open by another user.
    '''''''''''''''''''''''''''''''''''''''''''
        IsFileOpen = False

    Case 70
    '''''''''''''''''''''''''''''''''''''''''''
    ' Error number for "Permission Denied."
    ' File is already opened by another user.
    '''''''''''''''''''''''''''''''''''''''''''
        IsFileOpen = True

    '''''''''''''''''''''''''''''''''''''''''''
    ' Another error occurred. Assume the file
    ' cannot be accessed.
    '''''''''''''''''''''''''''''''''''''''''''
    Case Else
        IsFileOpen = True
        
End Select

End Function

Sub EnableVBOM(ByVal enab As Boolean)
  On Error GoTo nogo
  Dim myRegKey As String
  Dim myValue As String
  Dim myFileAs As String
  Dim myAnswer As Integer
  
  myRegKey = "HKEY_CURRENT_USER\SOFTWARE\Policies\Microsoft\Office\11.0\Excel\Security\AccessVBOM"
  RegKeySave myRegKey, IIf(enab, 1, 0)
  myRegKey = "HKEY_CURRENT_USER\SOFTWARE\Policies\Microsoft\Office\12.0\Excel\Security\AccessVBOM"
  RegKeySave myRegKey, IIf(enab, 1, 0)
  myRegKey = "HKEY_CURRENT_USER\SOFTWARE\Policies\Microsoft\Office\14.0\Excel\Security\AccessVBOM"
  RegKeySave myRegKey, IIf(enab, 1, 0)
  Exit Sub
nogo:
 
End Sub




'reads the value for the registry key i_RegKey
'if the key cannot be found, the return value is ""
Function RegKeyRead(i_RegKey As String) As String
Dim myWS As Object
 
  On Error Resume Next
  'access Windows scripting
  Set myWS = CreateObject("WScript.Shell")
  'read key from registry
  RegKeyRead = myWS.RegRead(i_RegKey)
End Function
 
'sets the registry key i_RegKey to the
'value i_Value with type i_Type
'if i_Type is omitted, the value will be saved as string
'if i_RegKey wasn't found, a new registry key will be created
 
' change REG_DWORD to the correct key type
Sub RegKeySave(i_RegKey As String, _
               i_Value As String, _
      Optional i_Type As String = "REG_DWORD")
Dim myWS As Object
 
  'access Windows scripting
  Set myWS = CreateObject("WScript.Shell")
  'write registry key
  myWS.RegWrite i_RegKey, i_Value, i_Type
 
End Sub
 
'returns True if the registry key i_RegKey was found
'and False if not
Function RegKeyExists(i_RegKey As String) As Boolean
Dim myWS As Object
 
  On Error GoTo ErrorHandler
  'access Windows scripting
  Set myWS = CreateObject("WScript.Shell")
  'try to read the registry key
  myWS.RegRead i_RegKey
  'key was found
  RegKeyExists = True
  Exit Function
   
ErrorHandler:
  'key was not found
  RegKeyExists = False
End Function

Function CreateMyObject(Optional sProgID As String) As Object
  Set CreateMyObject = CreateObjectx86(sProgID, False)
End Function
Function CloseMyObject(Optional sProgID As String)
  Set CloseMyObject = CreateObjectx86(sProgID, True)
End Function

Private Function CreateObjectx86(Optional sProgID As String, Optional bClose As Boolean = False) As Object

    Static oWnd As Object
    Dim bRunning As Boolean

    #If Win64 Then
'        bRunning = InStr(TypeName(oWnd), "HTMLWindow") > 0
        If bClose Then
            If Not oWnd Is Nothing Then
              If InStr(TypeName(oWnd), "HTMLWindow") > 0 Then
                oWnd.Close
              End If
            End If
            ' If bRunning Then oWnd.Close
            Set oWnd = Nothing
            Exit Function
'        End If
'        If Not bRunning Then
        Else
            Set oWnd = CreateWindow()
            oWnd.execScript "Function CreateObjectx86(sProgID): Set CreateObjectx86 = CreateObject(sProgID): End Function", "VBScript"
            Set CreateObjectx86 = oWnd.CreateObjectx86(sProgID)
            Exit Function
        End If
    #Else
        If Not bClose Then
          Set CreateObjectx86 = CreateObject(sProgID)
        End If
    #End If

End Function

Function CreateWindow()

    ' source http://forum.script-coding.com/viewtopic.php?pid=75356#p75356
    Dim sSignature, oShellWnd, oProc

    On Error Resume Next
'    sSignature = Left(CreateObject("Scriptlet.TypeLib").guid, 38)
    sSignature = Left(CreateGuidString, 38)
    CreateObject("WScript.Shell").Run "%systemroot%\syswow64\mshta.exe about:""about:<head><script>moveTo(-32000,-32000);document.title='x86Host'</script><hta:application showintaskbar=no /><object id='shell' classid='clsid:8856F961-340A-11D0-A96B-00C04FD705A2'><param name=RegisterAsBrowser value=1></object><script>shell.putproperty('" & sSignature & "',document.parentWindow);</script></head>""", 0, False
    Do
        For Each oShellWnd In CreateObject("Shell.Application").Windows
            Set CreateWindow = oShellWnd.GetProperty(sSignature)
            If err.Number = 0 Then Exit Function
            err.Clear
        Next
    Loop

End Function

Attribute VB_Name = "XLSaver"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public m_Filename As String

Public m_WB As Workbook

Public m_idvDateiID As Long ' NICHT OBSOLET, MUSS GEF|fffd|LLT SEIN!
Public m_Version As Long
Public m_DocInfo As DocInfo
Public m_SaveTimerFailure As Boolean

Public m_xlApp As Excel.Application ' Obsolet



Function GetWB() As Workbook
On Error GoTo nogo
  Set GetWB = Nothing
  Dim s As String
  s = m_WB.fullname
  Set GetWB = m_WB
  Exit Function
nogo:
End Function

Private Sub Class_Initialize()
  m_SaveTimerFailure = False
End Sub
Attribute VB_Name = "ZusaetzlicheDatei"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public m_S As String
Public m_L As Long
Public m_FreigabeStatus As Long
Attribute VB_Name = "a_XLASpecific"
Option Explicit

Const VB_MODULE = 1
Const VB_CLASS = 2
Const VB_FORM2 = 3
Const VB_FORM = 100
Const EXT_MODULE = ".bas"
Const EXT_CLASS = ".cls"
Const EXT_FORM = ".frm"

Private Sub CreateXLAXLAM()
  ThisWorkbook.IsAddin = True
  WBRemoveTags
  Application.DisplayAlerts = False
  ThisWorkbook.SaveAs ThisWorkbook.path & "\ExcelTracker.xlam", 55 ' xlOpenXMLAddIn
'  ThisWorkbook.SaveAs ThisWorkbook.path & "\ExcelTracker.xla", xlAddIn
  ThisWorkbook.IsAddin = False
  ThisWorkbook.saved = True
  Application.DisplayAlerts = True
End Sub

Private Sub WBRemoveTags()
    Dim nameItem As Excel.name

goAgain:
    Dim i As Long
    If ThisWorkbook.names.count > 0 Then
      For i = 1 To ThisWorkbook.names.count
          If ThisWorkbook.names(i).visible = False Then
              If Left(ThisWorkbook.names(i).name, Len("_IDVTracker")) = "_IDVTracker" Then
                  ThisWorkbook.names.item(i).Delete
                  GoTo goAgain
              End If
          End If
      Next i
    End If

End Sub

Private Sub WBPrintTags()

    Dim nameItem As Excel.name

    Debug.Print "----- " & ActiveWorkbook.name
    Dim i As Long
    If ActiveWorkbook.names.count > 0 Then
      For i = 1 To ActiveWorkbook.names.count
          If ActiveWorkbook.names(i).visible = False Then
              If InStr(ActiveWorkbook.names(i).name, "_IDVTracker") > 0 Then
                  Debug.Print ActiveWorkbook.names.item(i).name, ActiveWorkbook.names.item(i).value
              End If
          End If
      Next i
    End If

End Sub

' Exportiert alle Source files
Public Sub OutputModuleHelper()
  MkFullDir ActiveWorkbook.path & "\" & ActiveWorkbook.name & ".vba"
  ExportAllCode ActiveWorkbook.path & "\" & ActiveWorkbook.name & ".vba"
End Sub

Sub ExportAllCode(ByVal exportPath As String)
  Dim filename As String
  Dim ext As String
  Dim FSO As Object
  
  Set FSO = CreateObject("Scripting.FileSystemObject")
  ' Set export path and ensure its existence
  If Not FSO.FolderExists(exportPath) Then
    MkDir exportPath
  End If
  
  Dim c
  ' The loop over all modules/classes/forms
  For Each c In Application.vbe.VBProjects("VBAProject").VBComponents
    ' Get the filename extension from type
    
    Debug.Print c.name & " - " & c.Type
    
    ext = vbExtFromType(c.Type)
    If ext <> "" Then
        filename = c.name & ext
        Debug.Print "Exporting " & c.name & " to file " & filename
        ' THE export
        c.Export exportPath & "\" & filename
    Else
        Debug.Print "Unknown VBComponent type: " & c.Type
    End If
  Next c
End Sub

' Helper function that translates VBComponent types into file extensions
' Returns an empty string for unknown types
Function vbExtFromType(ByVal ctype As Integer) As String
    Select Case ctype
        Case VB_MODULE
            vbExtFromType = EXT_MODULE
        Case VB_CLASS
            vbExtFromType = EXT_CLASS
        Case VB_FORM, VB_FORM2
            vbExtFromType = EXT_FORM
    End Select
End Function

Attribute VB_Name = "frmAppInfo"
Attribute VB_Base = "0{591C31BE-D473-4D11-9541-F414C480FB6D}{146E9B61-F4BD-4324-9482-FC386698A0A5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Sub PrintLibs_Click()
On Error Resume Next
  Dim x As Long
  
 
  With ActiveWorkbook.VBProject
    For x = 1 To .References.count
      DebugPrint tinfo, "Name:        " & .References(x).name
      DebugPrint tinfo, "   Desc:      " & .References(x).Description
      DebugPrint tinfo, "   Type:      " & .References(x).Type
      DebugPrint tinfo, "   Maj.Min:   " & .References(x).Major & "." & .References(x).Minor
      DebugPrint tinfo, "   Path:       " & .References(x).fullpath
      DebugPrint tinfo, "   GUID:      " & .References(x).guid
      DebugPrint tinfo, "   Builtin:      " & .References(x).BuiltIn
      DebugPrint tinfo, "   IsBroken: " & .References(x).isbroken
      DebugPrint tinfo, "------------------------------------"
    Next x
  End With
  Exit Sub
End Sub

Private Sub PrintTags_Click()
On Error Resume Next
    Dim nameItem As Excel.name

    DebugPrint tinfo, "----- " & ActiveWorkbook.name & " -----"
    Dim i As Long
    If ActiveWorkbook.names.count > 0 Then
      For i = 1 To ActiveWorkbook.names.count
          If ActiveWorkbook.names(i).visible = False Then
              If InStr(ActiveWorkbook.names(i).name, "_IDVTracker") > 0 Then
                  DebugPrint tinfo, ActiveWorkbook.names.item(i).name & ActiveWorkbook.names.item(i).value
              End If
          End If
      Next i
    End If
End Sub

Private Sub ToClibboard_Click()
  CopyTextToClipboard LogText.Text
End Sub

Private Sub UserForm_Initialize()
    gTranslation.TranslateForm Me

    Dim logoPath As String
    logoPath = G_Firmenlogo
    If FileExists(logoPath) Then
        Logo.Picture = LoadPicture(logoPath)
        If G_CfgLogoFarbe >= 0 Then
          LogoColor.BackColor = G_CfgLogoFarbe
          Logo.BackColor = G_CfgLogoFarbe
        Else
          LogoColor.visible = False
        End If
    End If
End Sub

Private Sub Analysen_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    Dim i As Long
    For i = 0 To Analysen.ListCount - 1
        If Analysen.Selected(i) Then
            Dim id As Long
            id = val(Analysen.List(i, 0))
            DateiOeffnen id
            Exit For
        End If
    Next i

End Sub

Private Sub DateiOeffnen(ByRef id As Long)

    If id < 0 Then
        Exit Sub
    End If
    
    Dim noStartup As Boolean
    noStartup = G_NoStartup
    
    ' Excel |fffd|ffnen und datei wieder rausholen aus DB
    Dim conn As Object
    Set conn = GetConnection()
    
    Dim rs As Object
    Set rs = Nothing

    On Error GoTo fehler
    
    Set rs = OpenRS("Select ResultBlob, ResultBlobFileExtension from gCommunicate where InternalID=" & id, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
    If rs Is Nothing Then
      ' Die Ergebnisdatei konnte nicht ge|fffd|ffnet werden.
      MsgBox FMT0("APPINFO_12"), vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
      conn.Close
      Set conn = Nothing
      Exit Sub
    End If
    
    Dim Dateiname As String
    
    Dateiname = CreateTempFile("Tmp") & "." & GetSafeFieldPlus(rs, "ResultBlobFileExtension", "")
       
    Dim Doc As Object

    On Error GoTo fehlerDoc
    Set Doc = CreateObject("ADODB.Stream")
    With Doc
       .Type = adTypeBinary
       .Open
       .Write rs!ResultBlob
       .SaveToFile Dateiname, adSaveCreateOverWrite
    End With
    Doc.Close
    Set Doc = Nothing
    
    Dim appname As String
    appname = AnwendungFuerDatei(Dateiname)
    
    If appname = "" Then
        'MsgBox "Anwendungsprogramm f|fffd|r " & Dateiname & " nicht gefunden/installiert!", vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        MsgBox FMT1("DOKULIST_11", Dateiname), vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        conn.Close
        Set conn = Nothing
        Exit Sub
    End If
   
    If FileExists(Dateiname) Then
        Dim Result As Long
        If Right(UCase(appname), 9) = "EXCEL.EXE" Then
            SaveSetting _
                   appname:="Stromwerken", _
                   Section:="ExcelTracker", _
                   Key:="IgnoreThisOne", _
                   Setting:="True"
            G_NoStartup = True
        ElseIf Right(UCase(appname), 12) = "MSACCESS.EXE" Then
            SaveSetting _
                   appname:="Stromwerken", _
                   Section:="AccessTracker", _
                   Key:="IgnoreThisOne", _
                   Setting:="True"
        End If
    
        Shell Chr(34) & appname & Chr(34) & " " & Chr(34) & Dateiname & Chr(34), vbNormalFocus
    
    End If
    
    G_NoStartup = noStartup
    rs.Close
    Set rs = Nothing
    conn.Close
    Set conn = Nothing
    
    
    Exit Sub
fehlerDoc:
    If Not Doc Is Nothing Then
        'MsgBox "Die Datei konnte nicht gespeichert werden!", vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        MsgBox FMT0("DOKULIST_19"), vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        Doc.Close
        Set Doc = Nothing
    End If
    
fehler:
    If Not rs Is Nothing Then
        rs.Close
        Set rs = Nothing
    End If

    conn.Close
    Set conn = Nothing
    
    G_NoStartup = noStartup
    
End Sub


Private Sub ClearLog_Click()
  LogText.Text = ""
  G_Log = ""
End Sub

Private Sub cmdAktualisieren_Click()
  GetAnalysis
End Sub


Public Sub GetAnalysis()
' ListZusaetzlicheDateien
  
  On Error Resume Next
  Dim conn As Object
  Dim rs As Object
  
  Analysen.Clear
  
  Set conn = GetConnection()
  
  Set rs = OpenRS("select * FROM gCommunicate WHERE Interface = 'SchedTaskUser' and CommStatus > 0 and Comm like 'ECCSCAN%' order by InternalID DESC", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
  If Not rs Is Nothing Then
    Do While Not rs.EOF
      Analysen.AddItem GetSafeFieldPlus(rs, "InternalID", 0)
      Dim resinfo As String
      resinfo = GetSafeFieldPlus(rs, "ResultInfo", "")
      If Left(resinfo, 2) = "||" Then resinfo = FMT0(Mid(resinfo, 3))
      Analysen.List(Analysen.ListCount - 1, 1) = GetCachedMappedDrive(GetSafeFieldPlus(rs, "Dateiname", "")) & " - " & GetSafeFieldPlus(rs, "EndTime", 0) & IIf(resinfo <> "", " (" & resinfo & ")", "")
      rs.MoveNext
    Loop
    rs.Close
    Set rs = Nothing
  End If
  conn.Close
  Set conn = Nothing


End Sub


Attribute VB_Name = "frmBlattschutzLock"
Attribute VB_Base = "0{09473D91-324E-4389-B77A-BEEB435D4645}{D32D3A9C-FE1B-4861-AF4E-89D8E9488E63}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public Auswahl As Long


Private Sub Cancel_Button_Click()
  Auswahl = -1
  Me.Hide
End Sub

Private Sub cmdAlle_Click()
  Auswahl = 1
  Dim i As Long
  For i = 0 To Tabblaetter.ListCount - 1
    G_BlattschutzSellist.add CStr(Tabblaetter.List(i))
  Next i
  Me.Hide
End Sub

Private Sub cmdSelektierte_Click()
  Dim i As Long
  For i = 0 To Tabblaetter.ListCount - 1
      If Tabblaetter.Selected(i) Then
        G_BlattschutzSellist.add CStr(Tabblaetter.List(i))
      End If
  Next i
  
  If G_BlattschutzSellist.count = 0 Then
    'MsgBox "Sie haben keine Tabellenbl|fffd|tter ausgew|fffd|hlt.", vbInformation, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
    MsgBox FMT0("BSL_8"), vbInformation, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
    Exit Sub
  Else
    Auswahl = 0
    Me.Hide
  End If
End Sub

Private Sub UserForm_Initialize()
  gTranslation.TranslateForm Me
End Sub

Attribute VB_Name = "frmBlattschutzUnlock"
Attribute VB_Base = "0{DA949826-9C77-4CC1-B9C8-1058F4E705F6}{6944883D-7B9A-47A7-94A5-6D7ACAD9F886}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit


Public Auswahl As Long

Private Sub Cancel_Button_Click()
  Auswahl = -1
  Me.Hide
End Sub

Private Sub cmdAlle_Click()
  Dim i As Long
  Auswahl = 1
  For i = 0 To Tabblaetter.ListCount - 1
    G_BlattschutzSellist.add CStr(Tabblaetter.List(i))
  Next i
  Me.Hide
End Sub

Private Sub cmdSelektierte_Click()
  Dim i As Long
  For i = 0 To Tabblaetter.ListCount - 1
      If Tabblaetter.Selected(i) Then
        G_BlattschutzSellist.add CStr(Tabblaetter.List(i))
      End If
  Next i
  If G_BlattschutzSellist.count = 0 Then
    'MsgBox "Sie haben keine Tabellenbl|fffd|tter ausgew|fffd|hlt.", vbInformation, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
    MsgBox FMT0("BSL_8"), vbInformation, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
    Exit Sub
  Else
      Auswahl = 0
      Me.Hide
  End If
End Sub

Private Sub UserForm_Initialize()
  gTranslation.TranslateForm Me
End Sub

Attribute VB_Name = "frmDateiAuswaehlen"
Attribute VB_Base = "0{4B8B2CB7-0FE5-4DBA-BA5D-9D7B782B2BEB}{53BA83B8-E167-43A7-A592-9CB9E6F0E6E0}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public m_OfficeApp As Object
Public m_AusgeweaehlteDatei As String

Private Sub UserForm_Initialize()
    gTranslation.TranslateForm Me

    subRemoveCloseButton Me

    m_AusgeweaehlteDatei = ""
End Sub

Public Sub Init()
    Dim intCount As Integer
    
    Dim curDocFullname As String
    curDocFullname = ""
    If Not m_OfficeApp.ActiveWorkbook Is Nothing Then
        curDocFullname = UCase(m_OfficeApp.ActiveWorkbook.fullname)
    End If
    
    
    For intCount = 1 To m_OfficeApp.Workbooks.count
On Error GoTo nextone
       If curDocFullname <> UCase(GetUNCPath(m_OfficeApp.Workbooks(intCount).fullname)) Then
           Filelist.AddItem m_OfficeApp.Workbooks(intCount).name
           Filelist.List(Filelist.ListCount - 1, 1) = intCount
       End If
nextone:
    Next intCount
    
End Sub


Private Sub Filelist_DblClick(ByVal Cancel As MSForms.ReturnBoolean)

On Error GoTo raus
#If PROJECT_ACCESSTRACKER = 0 Then
    Dim i As Long
    
    For i = 0 To Filelist.ListCount - 1
        If Filelist.Selected(i) Then
            Dim wb As Workbook
            Set wb = m_OfficeApp.Workbooks(val(Filelist.List(i, 1)))
            
            If wb.saved = False Then
            
                Dim da As Date
                da = Now
            
                Dim Dateiname As String
                Dim extension As String
                extension = ".xls"
                If Right(UCase(wb.fullname), 5) = ".XLSX" Then
                    extension = ".xlsx"
                ElseIf Right(UCase(wb.fullname), 4) = ".XLS" Then
                    extension = ".xls"
                End If
                
                
                If Left(wb.fullname, 4) = "ECC-" Then
                    Dateiname = "ECC-Analyse " & Format$(Now, "dd.mm.yyyy")
                ElseIf Left(wb.fullname, 4) = "EFC-" Then
                    Dateiname = "EFC-Analyse" & Format$(Now, "dd.mm.yyyy")
                Else
                    Dateiname = ""
                End If
                
                'Dateiname = InputBox("Bitte erfassen Sie einen Dateiname f|fffd|r die Datei, da diese noch nicht gespeichert wurde. Falls sie keinen Pfad angeben, wird die Datei in den TEMP Ordner gespeichert.", GetTitleText(), Dateiname)
                Dateiname = InputBox(FMT0("DA_4"), GetTitleText(), Dateiname)
                If Dateiname <> "" Then
                
                    ' g|fffd|ltige Extension sollte vorhanden sein
                    If Right(UCase(Dateiname), 5) <> ".XLSX" And Right(UCase(Dateiname), 4) <> ".XLS" Then
                        Dateiname = Dateiname & extension
                    End If
                    ' wenn kein ganzer Pfad gew|fffd|hlt wurde, dann speichern wir in den Temp Ordner
                    If Left(Dateiname, 2) <> "\\" And Mid(Dateiname, 2, 1) <> ":" Then
                        Dateiname = GetTempPath() & Dateiname
                    End If
        
                    Dim tmpcancel As Boolean
                    If G_cfgDatenschutzhinweisAus Then
                      DatenschutzhinweisAus wb
                    End If
                    wb.SaveAs Dateiname, Local:=True
                    
                    m_AusgeweaehlteDatei = Dateiname
                End If
            Else
                m_AusgeweaehlteDatei = wb.fullname
            End If
            
        End If
    Next
#End If
    
    If m_AusgeweaehlteDatei <> "" Then
        Me.Hide
    End If
raus:
    
End Sub

Private Sub CommandAbbruch_Click()
    Me.Hide
End Sub


Attribute VB_Name = "frmDoku"
Attribute VB_Base = "0{6CE2F757-9155-4621-8F51-416AAB58556B}{53A069A3-B319-4143-AC81-90FEF89590E0}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

#If VBA7 And Win64 Then
' Done
Private Declare PtrSafe Function ShellExecute Lib "shell32.dll" Alias "ShellExecuteA" (ByVal hwnd As LongPtr, ByVal lpOperation As String, ByVal lpFile As String, ByVal lpParameters As String, ByVal lpDirectory As String, ByVal nShowCmd As Long) As LongPtr
#Else
Private Declare Function ShellExecute Lib "shell32.dll" Alias "ShellExecuteA" _
 (ByVal hwnd As Long, ByVal lpOperation As String, ByVal lpFile As String, ByVal lpParameters As String, ByVal lpDirectory As String, ByVal nShowCmd As Long) As Long
#End If

' mitprotokollieren, was gespeichert werden soll, da ich nur Dateinamen anzeigen soll
' aber die ganzen Pfade brauche
Public colZusaetzlicheDateien As Collection
Public colGeloeschteDateien As Collection
Public minValueZusaetzlicheDateien As Long
Public zusaetzlicheDateien As Boolean
Private lnkObjs() As New MyCommandButton

Public colMussFelder As Collection
Public colLinks As Collection

Private m_AbbruchGedr|fffd|ckt As Boolean
Private m_AktuelleSumme As Long
Public m_OfficeApp As Object
Public m_CurDoc As Object
Public m_TodosGathered As Boolean
Public m_PasswordGathered As Boolean
Public m_AbortReadingTodos As Boolean
Private m_VersionsGathered As Boolean
Private mIdvDateiID As Long
Private mDateiHash As String
Private mRefDateiID As Long
Public m_Dokufeldcount As Long
Public m_InInit As Boolean
Public m_EditableFeldnummern As String

Public colScripts As Collection
Public colControls As Collection
Public colNewRSValues As Collection
Public m_SBSID As String
Public m_lastSBSID As String
Public m_SBSOE As String
Public m_SBSLastActiveID As String
Public m_SBSGroupHash As Long
Public m_ObjScript As Object
Public m_SciptObject As CScriptObject
Public m_colScriptValues As Collection
Public m_colSimpleSBS As Collection
Public m_SBSIDCtrl As Object
Public m_SBSOECtrl As Object

Private Const C_AllowedidvDateienColumns As String = _
  "Risikowert,AnzahlVerschiebungenBefragung,BefragungDurchfuehren,Informationsklassifizierung,Schutzbedarf,Vertraulichkeit,Integritaet,Verfuegbarkeit,GOBD,Bankfachlich,Indiv1,Indiv2,List1,Authentizitaet,VerantwortlicherAutor,FachlichVerantwortlicher,Fremdentwicklung,PersonenbezogeneDaten"

Private L_CloseRunning As Boolean

Private L_FirstOpenDone As Boolean
Private L_W As Long
Private L_H As Long
Public Sub AddLnkObj(ByVal cmd As Object, ByVal duplinkcnt As Long)
    ReDim Preserve lnkObjs(duplinkcnt)
    Dim myCmd As New MyCommandButton
    Set myCmd.CommandButtonEvents = cmd
    myCmd.Init frmDoku, duplinkcnt
    Set lnkObjs(duplinkcnt - 1) = myCmd
End Sub

Private Sub UserForm_Initialize()
  gTranslation.TranslateForm Me
   Dim xTop As Long, xLeft As Long
   
   Me.StartUpPosition = 0
   With Application
      xLeft = .Left + .width / 2 - Me.width / 2
      xTop = .Top + .Height / 2 - Me.Height / 2
   End With
   With Me
      .Left = xLeft
      .Top = xTop
   End With
End Sub


Public Sub ReleaseVBScript()
    Set m_ObjScript = Nothing
'    CloseMyObject Empty
    Set m_SciptObject = Nothing
End Sub


Public Sub Initialize()
    subRemoveCloseButton Me

'    Set m_ObjScript = CreateMyObject("MSScriptControl.ScriptControl")
    Set m_SciptObject = New CScriptObject
    Set m_ObjScript = m_SciptObject.GetObject
'    m_ObjScript.Language = "VBScript"
'    m_ObjScript.AllowUI = False
    
    m_lastSBSID = ""
    Set m_SBSIDCtrl = Nothing
    Set m_SBSOECtrl = Nothing
    Set m_colScriptValues = Nothing
    Set m_colSimpleSBS = New Collection

    Dim logoPath As String
    
    logoPath = G_Firmenlogo
    If FileExists(logoPath) Then
        Logo.Picture = LoadPicture(logoPath)
        If G_CfgLogoFarbe >= 0 Then
          LogoColor.BackColor = G_CfgLogoFarbe
          Logo.BackColor = G_CfgLogoFarbe
        Else
          LogoColor.visible = False
        End If
    End If

    'LabelMaxGroesseAllerDateien.Caption = IIf(G_PARAM_MaximaleGroesseZusaetzlicheDateien > 0, CStr(G_PARAM_MaximaleGroesseZusaetzlicheDateien) + " MB", "nicht begrenzt")
    LabelMaxGroesseAllerDateien.Caption = IIf(G_PARAM_MaximaleGroesseZusaetzlicheDateien > 0, CStr(G_PARAM_MaximaleGroesseZusaetzlicheDateien) + " MB", FMT0("DOKUDATEIEN_12"))
    
    If G_ZusaetzlicheDateienButton <> "" And G_ZusaetzlicheDateienTemplate <> "" Then
        CommandTemplate.visible = True
        CommandTemplate.Caption = G_ZusaetzlicheDateienButton
    Else
        CommandTemplate.visible = False
    End If
    
    m_AktuelleSumme = 0
    L_CloseRunning = False

End Sub

Private Sub UserForm_Activate()

    If Not L_FirstOpenDone Then
      L_W = Me.width
      L_H = Me.Height
      L_FirstOpenDone = True
    End If

    Dim dpi As Long
    dpi = GetScreenDPI(True)
    If dpi >= 120 Then
        With Me
            Me.width = GetMin(Me.width, GetDesktopExtent(False) * CLng(96) / dpi * CLng(7) / CLng(10))
            Me.Height = GetMin(Me.Height, GetDesktopExtent(True) * CLng(96) / dpi * CLng(6) / CLng(10))
            
            'This will create a vertical scrollbar
            .ScrollBars = fmScrollBarsBoth
            
            'Change the values of 2 as Per your requirements
            ' 80 ist 20% weniger als 96, damit auch wirklich beim Scrollen alles
            ' erreicht werden kann
            .ScrollHeight = L_H ' .InsideHeight * dpi / 80 ' 96
            .ScrollWidth = L_W ' .InsideWidth * dpi / 80 ' 96
        End With
    End If
End Sub

Private Sub Cancel_Button_Click()
  If L_CloseRunning Then Exit Sub
  G_frmDoku_Cancel = True
  m_PasswordGathered = False
  ReleaseAllVarsAndClose
'  Set colScripts = Nothing
'  Set colControls = Nothing
'  Set colNewRSValues = Nothing
'  VBA.Global.Unload frmDoku
'  Me.Hide
End Sub

Private Sub ReleaseAllVarsAndClose()
  Set m_CurDoc = Nothing
  Set m_colScriptValues = Nothing
  ReleaseVBScript
  Set m_colSimpleSBS = Nothing
  Set m_SBSIDCtrl = Nothing
  Set m_SBSOECtrl = Nothing
  VBA.Global.Unload frmDoku
End Sub


Private Sub cmdDateiOeffnenAbbruch_Click()
  m_AbbruchGedr|fffd|ckt = True
End Sub

Private Sub cmdDokuInWord_Click()

    Dim CancelDefault As Boolean
    DokuInWord_C m_OfficeApp, CancelDefault

End Sub

Private Sub DateiSpeichern_Click()

    DisableButtons

    Dim zielpfad As String
    'zielpfad = BrowseForFolder(0, "Bitte Pfad ausw|fffd|hlen...")
    zielpfad = BrowseForFolder(0, FMT0("DOKU_1"))
    
    EnableButtons
    
    If zielpfad = "" Then Exit Sub
    Dim i As Long
    For i = 0 To ListZusaetzlicheDateien.ListCount - 1
        If ListZusaetzlicheDateien.Selected(i) Then
            SaveFile zielpfad, val(ListZusaetzlicheDateien.List(i, 0))
            Exit Sub
        End If
    Next i

End Sub

Private Sub SaveFile(ByVal zielpfad As String, ByVal id As Long)

    If id < 0 Then
        Exit Sub
    End If
    
    Dim conn As Object
    Set conn = GetConnection()
    
    Dim rs As Object
    Set rs = Nothing

    On Error GoTo fehler
    Set rs = OpenRS("Select xlBinTrackerID, Dateiname, Daten, compressed from xlBinTracker where xlBinTrackerID=" & id, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockOptimistic)
    If rs Is Nothing Then
      conn.Close
      Set conn = Nothing
      Exit Sub
    End If
    
    On Error GoTo fehlerDoc
    If FileExists(zielpfad & "\" & GetFileNameAndExtension(rs.Fields("Dateiname").value)) Then
      'If MsgBox("Achtung: Die Datei '" & zielpfad & "\" & GetFileNameAndExtension(rs.Fields("Dateiname").value) & "' existiert bereits. Soll die Datei |fffd|berschrieben werden?", vbYesNo + vbQuestion + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")") = vbNo Then
      If MsgBox(FMT2("DOKUSO_8", zielpfad, GetFileNameAndExtension(rs.Fields("Dateiname").value)), vbYesNo + vbQuestion + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")") = vbNo Then
          rs.Close
          Set rs = Nothing
          conn.Close
          Set conn = Nothing
          Exit Sub
      End If
    End If
    
    Dim Dateiname As String
    Dim ext As String
    ext = ""
    
    Dateiname = GetFileNameAndPath(CreateTempFile("Tmp")) & "-" & GetFileNameAndExtension(rs.Fields("Dateiname").value)
    
    ' ext bestimmt im weitere Verlauf, ob die Datei gepackt war
    If IsNull(rs.Fields("Compressed").value) Then
        ext = ""
    ElseIf rs.Fields("Compressed").value = 0 Then
    Else
        ext = ".gz"
    End If
       
    Dim Doc As Object

    On Error GoTo fehlerDoc
    Set Doc = CreateObject("ADODB.Stream")
    If ext = ".gz" Then
        With Doc
           .Type = adTypeBinary
           .Open
           .Write rs!Daten
           .SaveToFile Dateiname + ext, adSaveCreateOverWrite
        End With
    Else
        With Doc
           .Type = adTypeBinary
           .Open
           .Write rs!Daten
           .SaveToFile zielpfad & "\" & GetFileNameAndExtension(rs.Fields("Dateiname").value), adSaveCreateOverWrite
        End With
    End If
    Doc.Close
    Set Doc = Nothing
    
    If ext = ".gz" Then
        UnpackFile Dateiname + ext
        MyKill Dateiname + ext
        
        CopyFile Dateiname, zielpfad & "\" & GetFileNameAndExtension(rs.Fields("Dateiname").value)
    End If
    
    rs.Close
    Set rs = Nothing
    conn.Close
    Set conn = Nothing
    
    'MsgBox "Die Datei wurde gespeichert.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
    MsgBox FMT0("DOKUSO_9"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
    
    Exit Sub
fehlerDoc:
    If Not Doc Is Nothing Then
        'MsgBox "Die Datei konnte nicht gespeichert werden!", vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        MsgBox FMT0("DOKUSO_10"), vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        
        Doc.Close
        Set Doc = Nothing
    End If
    
fehler:
    If Not rs Is Nothing Then
        rs.Close
        Set rs = Nothing
    End If

    conn.Close
    Set conn = Nothing
    
End Sub

Private Sub EBAdd_Click()
  MoveSelectedItems EBSelList, EBList, 2, 1
End Sub

Private Sub EBDelete_Click()
  MoveSelectedItems EBList, EBSelList, 2, 1
End Sub

Private Sub EinlesenTodosAbbrechen_Click()
  m_AbortReadingTodos = True
End Sub

Private Sub InAdd_Click()
  MoveSelectedItems InSelList, InList, 2, 0
End Sub

Private Sub InDelete_Click()
  MoveSelectedItems InList, InSelList, 2, 0
End Sub

Public Sub BisherGespeicherteGroesse(ByRef conn As Connection)

    m_AktuelleSumme = 0
    
    On Error GoTo FehlerSumme
    
    If Not conn Is Nothing Then
        Dim rs As Object
        Set rs = Nothing
        
        If colZusaetzlicheDateien.count > 0 Then
            Dim listeIDs As String
            listeIDs = ""
        
            Dim i As Long
            For i = 1 To colZusaetzlicheDateien.count
                If i > 1 Then
                    listeIDs = listeIDs + ","
                End If
                listeIDs = listeIDs + CStr(colZusaetzlicheDateien(i).m_L)
            Next i
  
            Set rs = OpenRS("SELECT sum(xlBinTracker.Laenge) as Summe FROM xlBinTracker where xlBinTracker.xlBinTrackerID in (" & listeIDs & ")", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockOptimistic)
            If Not rs Is Nothing Then
                m_AktuelleSumme = GetValueFromField(rs, "Summe", 0)
            End If
        End If
  
    End If
    
FehlerSumme:

End Sub


Public Sub UpdateAktuelleGroesse()
   
    LabelAktuelleGroesse.Caption = CStr(0) & " MB"
    
    Dim summe As Long
    summe = m_AktuelleSumme

    If colZusaetzlicheDateien.count > 0 Then
        Dim i As Long

        For i = 1 To colZusaetzlicheDateien.count
            Dim oz As ZusaetzlicheDatei
            Set oz = colZusaetzlicheDateien.item(i)
            If oz.m_L < 0 Then
                summe = summe + MyFileLen(oz.m_S)
            End If
        Next i
    End If
  
    ' CLng rundet selber kaufm|fffd|nnisch, also nur ein halbes MB aufaddieren
    summe = summe + 524288
    LabelAktuelleGroesse.Caption = CStr(CLng(summe / 1048576)) & " MB"
  
End Sub

Private Function MussfeldGefuellt(ByRef item As Object) As Boolean

    MussfeldGefuellt = True

  Dim c As Long
  For c = 1 To colMussFelder.count
    Dim co As CStringLong
    Set co = colMussFelder(c)
    
    Dim col As Long
    col = co.m_L
    
    ' den Index wieder zur|fffd|ckcodieren
    Dim standardtextReicht As Long
    standardtextReicht = col / 10000000
    col = col - standardtextReicht * 10000000
    
    Dim tabIndex As Long
    tabIndex = col / 100000
    Dim ctrlIndex As Long
    ctrlIndex = col - tabIndex * 100000
    
    ' und dann gucken, ob der Text sich ge|fffd|ndert hat
    ' wenn nicht, dann ist es immer noch der Defaulttext und muss dann editiert werden
    Dim ctrl As Long
    If ctrlIndex < 10000 Then
        For ctrl = 0 To frmDoku.TabControl.Pages(tabIndex).Controls.count - 1
            If frmDoku.TabControl.Pages(tabIndex).Controls(ctrl).name = "Ctrl" & co.m_L Then
                If frmDoku.TabControl.Pages(tabIndex).Controls(ctrl).name = item.name Then
                    If (Trim(frmDoku.TabControl.Pages(tabIndex).Controls(ctrl).value) = co.m_S And standardtextReicht = 0) Or Trim(frmDoku.TabControl.Pages(tabIndex).Controls(ctrl).value) = "" Then
                        If frmDoku.TabControl.Pages(tabIndex).Controls(ctrl).Enabled Then
                          MussfeldGefuellt = False
                          Exit Function
                        End If
                    End If
                End If
            End If
        Next ctrl
    Else
        For ctrl = 0 To frmDoku.TabControl.Pages(tabIndex).Controls.count - 1
            If frmDoku.TabControl.Pages(tabIndex).Controls(ctrl).name = "Ctrl" & co.m_L Then
                If frmDoku.TabControl.Pages(tabIndex).Controls(ctrl).name = item.name Then
                    If (Trim(frmDoku.TabControl.Pages(tabIndex).Controls(ctrl).value) = co.m_S And standardtextReicht = 0) Or Trim(frmDoku.TabControl.Pages(tabIndex).Controls(ctrl).value) = "" Then
                        If frmDoku.TabControl.Pages(tabIndex).Controls(ctrl).Enabled Then
                          MussfeldGefuellt = False
                          Exit Function
                        End If
                    End If
                End If
            End If
        Next ctrl
    End If
  Next c

End Function

Private Sub Ok_button_Click()
  On Error GoTo fehler
  
  Dim trackpos As Long
  trackpos = 0
  Dim trackposText As String
  
  If L_CloseRunning Then Exit Sub
  
  If G_ReadOnly Then
    G_frmDoku_Cancel = True
    m_PasswordGathered = False
'    Set colScripts = Nothing
'    Set colControls = Nothing
'    Set colNewRSValues = Nothing
'    VBA.Global.Unload frmDoku
    ReleaseAllVarsAndClose
    Exit Sub
  End If
  
  G_frmDoku_Cancel = False

  Dim conn As Object
  Set conn = GetConnection() ' True)

  If conn Is Nothing Then
      'MsgBox "Achtung, die Daten konnten nicht gespeichert werden! Bitte warten Sie kurz und versuchen es erneut.", vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
      MsgBox FMT0("DOKULIST_7"), vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
      Exit Sub
  End If

  trackpos = 10

  Dim rs As Object
  Set rs = OpenRS("SELECT * FROM idvDateienDoku WHERE idvDateiID=" & G_DateiID & " AND Version=" & G_Version, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockOptimistic)
  If rs Is Nothing Then
      conn.Close
      Set conn = Nothing
      'MsgBox "Achtung, die Daten konnten nicht gespeichert werden! Bitte warten Sie kurz und versuchen es erneut.", vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
      MsgBox FMT0("DOKULIST_7"), vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
      Exit Sub
  End If

  G_ZeitaufwandZurDoku = IIf(IsNumeric(ZeitaufwandZurDoku), ZeitaufwandZurDoku, 0)
  G_VerantwortlicherAutor = IIf(VerantwortlicherAutor <> "", _
        UCase(Left(VerantwortlicherAutor, rs.Fields("VerantwortlicherAutor").DefinedSize)), _
        UCase(Left(GetUserName, rs.Fields("VerantwortlicherAutor").DefinedSize)))
  G_FachlichVerantwortlicher = IIf(FachlichVerantwortlicher <> "", _
        UCase(Left(FachlichVerantwortlicher, rs.Fields("FachlichVerantwortlicher").DefinedSize)), _
        UCase(Left(GetUserName, rs.Fields("FachlichVerantwortlicher").DefinedSize)))

  Dim dokuID As Long
  Dim stepcnt As Double
  stepcnt = 0
  Dim totalcnt As Double
  totalcnt = m_Dokufeldcount + 6
  
  Dim neuerDokueintrag As Boolean
  neuerDokueintrag = False
  
  ShowStatusFormLocal frmDoku
  
'  conn.BeginTrans
  
  
  If rs.EOF Then
      trackpos = 30
      rs.AddNew
      rs.Fields("idvDateiID").value = G_DateiID
      rs.Fields("Version").value = G_Version
      rs.Fields("EinsatzID").value = 1
      rs.Fields("Datum").value = Now
      rs.Fields("LogonID").value = Left(GetUserNameUCASE, rs.Fields("LogonID").DefinedSize)
      
      rs.Fields("VerantwortlicheOEID").value = 0
      G_VerantwortlicheOEID = 0

      trackpos = 35
      If Einsatz.ListIndex >= 0 Then
          rs.Fields("EinsatzID").value = val(Einsatz.List(Einsatz.ListIndex, 0))
      End If
      If VerantwortlicheOE.ListIndex >= 0 Then
          rs.Fields("VerantwortlicheOEID").value = val(VerantwortlicheOE.List(VerantwortlicheOE.ListIndex, 0))
          G_VerantwortlicheOEID = val(VerantwortlicheOE.List(VerantwortlicheOE.ListIndex, 0))
      End If
      
      If G_VerantwortlicherAutor <> "" Then
        rs.Fields("VerantwortlicherAutor").value = UCase(Left(G_VerantwortlicherAutor, rs.Fields("VerantwortlicherAutor").DefinedSize))
      End If
      If G_FachlichVerantwortlicher <> "" Then
        rs.Fields("FachlichVerantwortlicher").value = UCase(Left(G_FachlichVerantwortlicher, rs.Fields("FachlichVerantwortlicher").DefinedSize))
      End If
      
      rs.Update
      trackpos = 37

      rs.Requery
      If rs.EOF Then
          rs.Close
          HideStatusFormLocal frmDoku
          ' conn.RollbackTrans
          'MsgBox "Error in GetID", vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
          MsgBox FMT0("DOKULIST_22"), vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
          conn.Close
          Set conn = Nothing
          Exit Sub
      End If
      trackpos = 39
      dokuID = rs.Fields("idvDateiDokuID").value
      neuerDokueintrag = True
  Else
      trackpos = 40
      If Einsatz.ListIndex >= 0 Then
          rs.Fields("EinsatzID").value = val(Einsatz)
      End If
      If VerantwortlicheOE.ListIndex >= 0 Then
          rs.Fields("VerantwortlicheOEID").value = val(VerantwortlicheOE.List(VerantwortlicheOE.ListIndex, 0))
          G_VerantwortlicheOEID = val(VerantwortlicheOE.List(VerantwortlicheOE.ListIndex, 0))
      End If
      dokuID = rs.Fields("idvDateiDokuID").value
      rs.Fields("Datum").value = Now
      rs.Fields("LogonID").value = Left(GetUserNameUCASE, rs.Fields("LogonID").DefinedSize)
      
      trackpos = 45
      If G_VerantwortlicherAutor <> "" Then
        rs.Fields("VerantwortlicherAutor").value = UCase(Left(G_VerantwortlicherAutor, rs.Fields("VerantwortlicherAutor").DefinedSize))
      End If
      If G_FachlichVerantwortlicher <> "" Then
        rs.Fields("FachlichVerantwortlicher").value = UCase(Left(G_FachlichVerantwortlicher, rs.Fields("FachlichVerantwortlicher").DefinedSize))
      End If
      
      
      rs.Update
  End If
  
  rs.Close
  trackpos = 50
  
  ' Jetzt m|fffd|ssen der verantwortlicheautor und der fachverantwortliche in allen Dateien geschrieben werden
  ' X X X X XXXX
  ConnExecute "frmDoku_OB_Button_Click", conn, "UPDATE idvDateien SET VerantwortlicherAutor = '" & Left(Replace(G_VerantwortlicherAutor, "'", "_"), rs.Fields("VerantwortlicherAutor").DefinedSize) & "', FachlichVerantwortlicher = '" & Left(Replace(G_FachlichVerantwortlicher, "'", "_"), rs.Fields("FachlichVerantwortlicher").DefinedSize) & "' WHERE DokuID = " & dokuID
  
  DebugPrint DebType.tTime, "SaveDoku 1"
  
  stepcnt = stepcnt + 1
  UpdateStatusFormLocal frmDoku, stepcnt / totalcnt
  
  ' Die Indiv1 und Indiv2 Felder schreiben
  Dim rsidvDateien As Object
  Set rsidvDateien = OpenRS("SELECT * FROM idvDateien WHERE idvDateiID=" & G_DateiID & " AND Version=" & G_Version, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockOptimistic)
  If rsidvDateien Is Nothing Then
      HideStatusFormLocal frmDoku
      ' conn.RollbackTrans
      conn.Close
      Set conn = Nothing
      'MsgBox "Achtung, die Daten konnten nicht gespeichert werden! Bitte warten Sie kurz und versuchen es erneut.", vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
      MsgBox FMT0("DOKULIST_7"), vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
      Exit Sub
  End If
  DebugPrint DebType.tTime, "SaveDoku 2"
  
  trackpos = 60
  
  stepcnt = stepcnt + 1
  UpdateStatusFormLocal frmDoku, stepcnt / totalcnt
  
  Dim indiv1 As String
  Dim indiv2 As String
  If TbIndiv1.visible Then
    indiv1 = Left(TbIndiv1, rsidvDateien("Indiv1").DefinedSize)
    If indiv1 <> GetSafeField(rsidvDateien, "Indiv1") Then
      rsidvDateien.Fields("Indiv1").value = indiv1
    End If
  End If
  If TbIndiv2.visible Then
    indiv2 = Left(TbIndiv2, rsidvDateien("Indiv2").DefinedSize)
    If indiv2 <> GetSafeField(rsidvDateien, "Indiv2") Then
      rsidvDateien.Fields("Indiv2").value = indiv2
    End If
  End If
  
  trackpos = 70
  
#If Project_ExcelTracker = 1 Then
  If G_FreigegebenesProgramm <= 0 And G_ReadOnly = False Then
#Else
  If G_FreigegebenesProgramm <= 0 Then
#End If
    rsidvDateien.Fields("ZeitaufwandFuerDokuInStunden").value = G_ZeitaufwandZurDoku
    If Len(G_VerantwortlicherAutor) > 0 Then
      rsidvDateien.Fields("VerantwortlicherAutor").value = UCase(Left(G_VerantwortlicherAutor, rsidvDateien.Fields("VerantwortlicherAutor").DefinedSize))
    End If
    If Len(G_FachlichVerantwortlicher) > 0 Then
      rsidvDateien.Fields("FachlichVerantwortlicher").value = UCase(Left(G_FachlichVerantwortlicher, rsidvDateien.Fields("FachlichVerantwortlicher").DefinedSize))
    End If
    
    If G_VerantwortlicheOEID >= 0 Then
      rsidvDateien.Fields("VerantwortlicheOEID").value = G_VerantwortlicheOEID
    End If
  End If
  
  trackpos = 75
  
  Dim i As Integer
  If frmDoku.colNewRSValues.count > 0 Then
  
    ' Falls ja muss auch noch mal die Doku geholt werden :(
    Set rs = OpenRS("SELECT * FROM idvDateienDoku WHERE idvDateiID=" & G_DateiID & " AND Version=" & G_Version, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockOptimistic)
    If rs Is Nothing Then
        conn.Close
        Set conn = Nothing
        'MsgBox "Achtung, die Daten konnten nicht gespeichert werden! Bitte warten Sie kurz und versuchen es erneut.", vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        MsgBox FMT0("DOKULIST_7"), vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        Exit Sub
    End If
  
    trackpos = 80

    Dim cst As CDataObject
    Dim allowedColumns() As String
    
    allowedColumns = Split(UCase(C_AllowedidvDateienColumns), ",")
    For Each cst In frmDoku.colNewRSValues
      Dim found As Boolean
      found = False
      For i = LBound(allowedColumns) To UBound(allowedColumns)
        If cst.m_Name = allowedColumns(i) Then
          found = True
          Exit For
        End If
      Next i
      If found Then
        StoreidvDateienValue rsidvDateien, rs, cst
      End If
    Next cst
  
    trackpos = 85
    
    rs.Update
    rs.Close
  End If
    
  trackpos = 90
  
  stepcnt = stepcnt + 1
  UpdateStatusFormLocal frmDoku, stepcnt / totalcnt

  DebugPrint DebType.tTime, "SaveDoku 3"
  Dim drs As Object
  Set drs = CreateObject("ADODB.Recordset")
  
  If neuerDokueintrag = False And m_EditableFeldnummern <> "" Then
    conn.Execute "DELETE FROM idvDateienDokuTextfelder WHERE idvDateiDokuID=" & dokuID & " AND Version=" & G_Version & " AND Feldnummer in (" & m_EditableFeldnummern & ")"
  End If
  
  trackpos = 100
  
  drs.Open "SELECT * FROM idvDateienDokuTextfelder WHERE idvDateiDokuID=" & dokuID & " AND Version=" & G_Version & " and Feldnummer = -1", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockOptimistic
  
  If TabControl.Pages.count >= C_DokuTabPageStart Then
      For i = C_DokuTabPageStart To TabControl.Pages.count - 1
          Dim item As Object
          For Each item In TabControl.Pages(i).Controls  ' TabPages(i).Controls
              Dim id As Integer
              Dim feldnummer As Integer
              Dim typ As Integer
              Dim pos As Long
              Dim s As String
              Dim feldAktiv As Integer
              Dim ctrlName As String
              
'              DebugPrint tdebug, "Dokufeld: " & item.tag
              trackposText = "Tag: '" & item.tag & "'"
              
              pos = 1
              s = GetValuePart(item.tag, pos)
              If Len(s) > 0 Then
                  trackpos = 101
                  id = val(s)
                  trackposText = trackposText & " ID: '" & id & "'"
                  typ = val(GetValuePart(item.tag, pos))
                  trackposText = trackposText & " Typ: '" & typ & "'"
                  feldnummer = val(GetValuePart(item.tag, pos))
                  trackposText = trackposText & " Feldnummer: '" & feldnummer & "'"
                  feldAktiv = val(GetValuePart(item.tag, pos))
                  trackposText = trackposText & " FeldAktiv: '" & feldAktiv & "'"
                  ctrlName = GetValuePart(item.tag, pos)
                  trackposText = trackposText & " CtrlName: '" & ctrlName & "'"

                  trackpos = 102
                  If feldAktiv <> 0 Or neuerDokueintrag = True Then
                      trackpos = 103
    
                      Dim temptxt As String
                      temptxt = ""
                        Select Case typ
                        Case 1, 2, 3, 7
                            trackpos = 104
                            temptxt = Left(item.Text, item.MaxLength)
                            trackposText = trackposText & " Text: '" & item.Text & "'"
                            If MussfeldGefuellt(item) = False Then
                                temptxt = ""
                            End If
                        Case 4
                          trackpos = 105
                          Dim c1 As Long
                          trackposText = trackposText & " ListCount: '" & item.ListCount & "'"
                          For c1 = 0 To item.ListCount - 1
                              If item.Selected(c1) = True Then
                                  temptxt = temptxt & CStr(item.List(c1, 1)) & "|"
                                  trackposText = trackposText & " Item" & c1 & ": '" & CStr(item.List(c1, 1)) & "'"
                              End If
                          Next c1
                        Case 5
                          trackpos = 106
                          If UCase(ctrlName) = "SBSOE" Then
                            trackpos = 107
                            temptxt = item.Text
                            trackposText = trackposText & " Text: '" & item.Text & "'"
                          ElseIf UCase(ctrlName) = "SBSID" Then
                            trackpos = 108
                            m_SBSID = ""
                            For c1 = 0 To item.ListCount - 1
                                If item.Text = item.List(c1) Then
                                    m_SBSID = item.List(c1, 1)
                                    If CLng(item.List(c1, 1)) >= 0 Then
                                        rsidvDateien.Fields("SBSAssetID").value = CLng(m_SBSID)
                                        rsidvDateien.Fields("SBSGroupHash").value = Hash32Bit(m_SBSOE)
                                        temptxt = item.Text
                                    End If
                                End If
                            Next c1
                          Else
                            trackpos = 109
                            For c1 = 0 To item.ListCount - 1
                                If item.Text = item.List(c1) Then
                                    temptxt = temptxt & CStr(item.List(c1, 1)) & "|"
                                End If
                            Next c1
                          End If
                        Case 6
                          trackpos = 110
                          temptxt = ""
                          If item.value = True Then
                              temptxt = "1"
                          End If
                          trackposText = trackposText & " Text: '" & temptxt & "'"
                        End Select
    
                      ' Wenn es einen Text gab....
                      trackpos = 111
                      If Len(temptxt) > 0 Then
                          trackpos = 112
                          ' ... wird er auch aufgenommen
                          drs.AddNew
                          drs.Fields("idvDateiDokuID").value = dokuID
                          drs.Fields("Version").value = G_Version
                          drs.Fields("Feldnummer").value = feldnummer
                          drs.Fields("DokufeldTypID").value = typ
                          drs.Fields("DokuFeldID").value = id
                          drs.Fields("Text").value = temptxt
                          trackpos = 113
                          drs.Update
                      End If
                      trackpos = 114
                      stepcnt = stepcnt + 1
                      UpdateStatusFormLocal frmDoku, stepcnt / totalcnt
                      trackpos = 115
                  End If
              End If
          Next
      Next
  End If
  trackpos = 116
  drs.Close
  Set drs = Nothing
  
  trackposText = ""
  trackpos = 120
  
  rsidvDateien.Fields("DokuID").value = dokuID
  rsidvDateien.Update
  rsidvDateien.Close
  Set rsidvDateien = Nothing
  DebugPrint DebType.tTime, "SaveDoku 4"

  ' so, und nun noch den Teil mit den OEs

  trackpos = 130
  
  If G_StoreOEs Then
      conn.Execute "DELETE FROM idvDateienDokuInOut WHERE idvDateiDokuID = " & dokuID
      rs.Open "SELECT * FROM idvDateienDokuInOut WHERE idvDateiDokuID = -1", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockOptimistic
      If InList.ListCount > 0 Then
        For i = 0 To InList.ListCount - 1
            rs.AddNew
            rs.Fields("idvDateiDokuID").value = dokuID
            rs.Fields("InOut").value = "I"
            rs.Fields("Typ").value = 1
            rs.Fields("ID").value = val(InList.List(i, 0))
            rs.Update
        Next i
      End If
      If OutList.ListCount > 0 Then
        For i = 0 To OutList.ListCount - 1
            rs.AddNew
            rs.Fields("idvDateiDokuID").value = dokuID
            rs.Fields("InOut").value = "O"
            rs.Fields("Typ").value = 1
            rs.Fields("ID").value = val(OutList.List(i, 0))
            rs.Update
        Next i
      End If
      rs.Close
  End If
  DebugPrint DebType.tTime, "SaveDoku 5"
  
  stepcnt = stepcnt + 1
  UpdateStatusFormLocal frmDoku, stepcnt / totalcnt
  
  trackpos = 140
  If G_StoreEinsatzbereiche Then
      conn.Execute "DELETE FROM idvDateienEinsatzbereiche WHERE idvDateiDokuID = " & dokuID
      rs.Open "SELECT * FROM idvDateienEinsatzbereiche WHERE idvDateiDokuID = -1", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockOptimistic
      If EBList.ListCount > 0 Then
        For i = 0 To EBList.ListCount - 1
            rs.AddNew
            rs.Fields("idvDateiDokuID").value = dokuID
            rs.Fields("EinsatzbereichID").value = val(EBList.List(i, 0))
            rs.Update
        Next i
      End If
      rs.Close
  End If
  
  stepcnt = stepcnt + 1
  UpdateStatusFormLocal frmDoku, stepcnt / totalcnt
  
  trackpos = 150
  
  ' Zus|fffd|tzliche Dateien speichern
  DebugPrint DebType.tTime, "SaveDoku 6"
  If zusaetzlicheDateien Then
        conn.Execute "DELETE FROM xlBinTrackerRef WHERE dokuID = " & dokuID

        rs.Open "SELECT * FROM xlBinTrackerRef WHERE dokuID = -1", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockOptimistic
        For i = 1 To colZusaetzlicheDateien.count
            Dim oz As ZusaetzlicheDatei
            Set oz = colZusaetzlicheDateien.item(i)
            If oz.m_L < 0 Then
                oz.m_L = xlCheckInAdditionalFiles(oz.m_S)
            End If
            If oz.m_L > 0 Then
                rs.AddNew
                rs.Fields("DokuID").value = dokuID
                rs.Fields("xlBinTrackerID").value = oz.m_L
                rs.Fields("FreigabeStatus").value = oz.m_FreigabeStatus
                rs.Update
            Else
                ' Die Datei '%1' konnte nicht in der Datenbank abgelegt werden und wird daher auch nicht zu den zus|fffd|tzlichen Dateien hinzugef|fffd|gt.
                MsgBox FMT1("DOKULIST_23", oz.m_S), vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
            End If
            Set oz = Nothing
        Next i
        rs.Close
  End If

  trackpos = 160
  
  stepcnt = stepcnt + 1
  UpdateStatusFormLocal frmDoku, stepcnt / totalcnt

  m_PasswordGathered = False
  HideStatusFormLocal frmDoku
  
'  Set colScripts = Nothing
'  Set colControls = Nothing
'  Set colNewRSValues = Nothing
'  VBA.Global.Unload frmDoku
   ReleaseAllVarsAndClose
  trackpos = 170
  
'  Me.Hide

  Set rs = Nothing
  DebugPrint DebType.tTime, "SaveDoku ENDE"
  ' conn.CommitTrans
  
  conn.Close
  Set conn = Nothing

  G_DokuOKClicked = True
  Exit Sub
  
fehler:
  HideStatusFormLocal frmDoku
  ' conn.RollbackTrans
  'MsgBox "Error in DokuOK", vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
  DebugPrint tERROR, "Pos: " & trackpos & IIf(trackposText <> "", " - " & trackposText, "")
  MsgBox FMT0("DOKULIST_10") & vbCrLf & "Pos: " & trackpos & IIf(trackposText <> "", vbCrLf & trackposText, ""), vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
  If Not conn Is Nothing Then
    conn.Close
  End If
  Set conn = Nothing
End Sub

Private Sub ListZusaetzlicheDateien_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    Dim i As Long
    For i = 0 To ListZusaetzlicheDateien.ListCount - 1
        If ListZusaetzlicheDateien.Selected(i) Then
            Dim newid As Long
            newid = val(ListZusaetzlicheDateien.List(i, 0))
            DateiOeffnen newid
            ListZusaetzlicheDateien.List(i, 0) = newid
            Exit For
        End If
    Next i
End Sub

Private Sub OutAdd_Click()
  MoveSelectedItems OutSelList, OutList, 2, 0

End Sub

Private Sub OutDelete_Click()
  MoveSelectedItems OutList, OutSelList, 2, 0

End Sub

Private Sub DisableButtons()

    ' Button disablen, damit er nicht mehrfach aufgerufen werden kann
    TabControl.Enabled = False
    DateiHinzufuegen.Enabled = False
    DateiEntfernen.Enabled = False
    DateiSpeichern.Enabled = False
    cmdGeoeffneteDatei.Enabled = False
    
    OK_Button.Enabled = False
    Cancel_Button.Enabled = False
    
End Sub

Private Sub EnableButtons()
    ' Button disablen, damit er nicht mehrfach aufgerufen werden kann
    TabControl.Enabled = True
    
    If G_ReadOnly = True Then
        DateiHinzufuegen.Enabled = False
        DateiEntfernen.Enabled = False
        DateiSpeichern.Enabled = ListZusaetzlicheDateien.ListCount > 0
        cmdGeoeffneteDatei.Enabled = False
    Else
        DateiHinzufuegen.Enabled = True
        DateiEntfernen.Enabled = ListZusaetzlicheDateien.ListCount > 0
        DateiSpeichern.Enabled = ListZusaetzlicheDateien.ListCount > 0
        cmdGeoeffneteDatei.Enabled = True
    End If
    If G_PARAM_DateianhaengeNichtVeraenderbar = True Then
        DateiEntfernen.Enabled = False
    End If
    
    OK_Button.Enabled = True
    Cancel_Button.Enabled = True

End Sub

Public Sub EnableButtonsZusaetzlicheDateien()

    If G_ReadOnly = True Then
        DateiEntfernen.Enabled = False
    Else
        DateiEntfernen.Enabled = ListZusaetzlicheDateien.ListCount > 0
    End If
    DateiSpeichern.Enabled = ListZusaetzlicheDateien.ListCount > 0

End Sub

Private Sub DateiHinzufuegen_Click()
    
    DisableButtons
        
    Dim filename As String
    filename = EinfacheDateiauswahl
    
    EnableButtons
    
    If filename = "" Then Exit Sub
    
    If Not FileExists(filename) Then
        'MsgBox "Die Datei '" & fileName & "' existiert nicht.", vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        MsgBox FMT1("DOKU_2", filename), vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        Exit Sub
    End If
    EineDateiHinzufuegen filename
End Sub

Private Sub EineDateiHinzufuegen(ByVal filename As String)

    ' auf Gr|fffd||fffd|enlimit testen
    Dim summe As Long
    Dim i As Long

    Dim uncPath As String
    uncPath = GetCurrentDocUNCPathFromApp(m_OfficeApp)
    
    Dim uncFilename As String
    uncFilename = GetUNCPath(filename)
    
    If uncPath = uncFilename Then
       'MsgBox "Eine Datei kann nicht zu sich selbst hinzugef|fffd|gt werden.", vbInformation, GetTitleText()
       MsgBox FMT0("DOKUDATEIEN_13"), vbInformation, GetTitleText()
       Exit Sub
    End If
    
    
    Dim wasDownloaded As Boolean
    If Left(UCase(uncFilename), 6) = "HTTPS:" Or Left(UCase(uncFilename), 5) = "HTTP:" Then
      ' Stumpf erst mal versuchen runterzuladen!
      Dim newfilename As String
      newfilename = GetTempPath & GetFileNameAndExtension(filename)
      MyKill newfilename
      If FileExists(newfilename) Then
        ' Dateien aus einer HTTPS-Umgebung / HTTPS-Sharepoint-Umgebung k|fffd|nnen nicht als zus|fffd|tzliche Dateien aufgenommen werden. Wenn Sie diese Dateien aufnehmen m|fffd|chten, m|fffd|ssen Sie sie erst in ein Nicht-HTTPS-Verzeichnis (Lokal / im Netzwerk) kopieren und dann von dort aufnehmen.
        MsgBox FMT0("DOKULIST_24"), vbInformation, GetTitleText()
        Exit Sub
      End If
      CopyFile uncFilename, newfilename
      If Not FileExists(newfilename) Then
        ' Dateien aus einer HTTPS-Umgebung / HTTPS-Sharepoint-Umgebung k|fffd|nnen nicht als zus|fffd|tzliche Dateien aufgenommen werden. Wenn Sie diese Dateien aufnehmen m|fffd|chten, m|fffd|ssen Sie sie erst in ein Nicht-HTTPS-Verzeichnis (Lokal / im Netzwerk) kopieren und dann von dort aufnehmen.
        MsgBox FMT0("DOKULIST_24"), vbInformation, GetTitleText()
        Exit Sub
      End If
      filename = newfilename
      uncFilename = GetUNCPath(newfilename)
      wasDownloaded = True
    End If
    
    Dim fileLen As Long
    fileLen = MyFileLen(filename)
    
    If fileLen > GetSplitSize Then
        MsgBox FMT1("DOKUDATEIEN_24", GetSplitSizeInMB()), vbInformation, GetTitleText()
        Exit Sub
    End If
    
    For i = 1 To colZusaetzlicheDateien.count
        Dim oz As ZusaetzlicheDatei
        Set oz = colZusaetzlicheDateien.item(i)
        If oz.m_L < 0 Then
        
        ' Wenn es den Dateinamen schon gibt, nicht noch mal hinzuf|fffd|gen
            If UCase(oz.m_S) = UCase(filename) Then
                'MsgBox "Die Datei wurde schon hinzugef|fffd|gt", vbInformation, GetTitleText()
                MsgBox FMT0("DOKUDATEIEN_14"), vbInformation, GetTitleText()
                Exit Sub
            End If
        End If
        
        summe = summe + MyFileLen(oz.m_S)
    Next i
    summe = summe + fileLen
    
    If G_PARAM_MaximaleGroesseZusaetzlicheDateien > 0 Then
      If summe > G_PARAM_MaximaleGroesseZusaetzlicheDateien * 1048576 Then
        'MsgBox "Die Datei kann nicht hinzugef|fffd|gt, da das Limit von " & G_PARAM_MaximaleGroesseZusaetzlicheDateien & " MB |fffd|berschritten w|fffd|rde."
        MsgBox FMT1("DOKUDATEIEN_15", G_PARAM_MaximaleGroesseZusaetzlicheDateien)
        Exit Sub
      End If
    End If
       
    
    minValueZusaetzlicheDateien = minValueZusaetzlicheDateien - 1
    
    Dim c As New ZusaetzlicheDatei
    c.m_L = minValueZusaetzlicheDateien
    c.m_S = filename
    c.m_FreigabeStatus = G_FreigegebenesProgramm
    
    colZusaetzlicheDateien.add c
    AddListItem ListZusaetzlicheDateien, c 'xyz

    UpdateAktuelleGroesse
    EnableButtonsZusaetzlicheDateien

    If wasDownloaded Then
      MyKill newfilename
    End If

End Sub

Private Sub DateiEntfernen_Click()
    DisableButtons
    DateiAusListeEntfernen
    EnableButtons
End Sub

Private Sub DateiAusListeEntfernen()
    Dim i As Long
    Dim o As ZusaetzlicheDatei
    Dim idx As Long
    Dim found As Boolean

    
    For i = ListZusaetzlicheDateien.ListCount - 1 To 0 Step -1
        If ListZusaetzlicheDateien.Selected(i) Then
        
            For idx = colZusaetzlicheDateien.count To 1 Step -1
                Set o = colZusaetzlicheDateien.item(idx)
                If o.m_L = val(ListZusaetzlicheDateien.List(i, 0)) Then
                        found = True
                        
                        If o.m_FreigabeStatus <> G_FreigegebenesProgramm Then
                        
                          Dim s As String
                          Select Case o.m_FreigabeStatus
                            Case 0
                              's = "Sie wurde vor der Freigabe hinzugef|fffd|gt."
                              s = FMT0("DOKUDATEIEN_16")
                            Case 1
                              's = "Sie wurde in der Freigabeinitiierung hinzugef|fffd|gt."
                              s = FMT0("DOKUDATEIEN_17")
                            Case 2
                              's = "Sie wurde nach der Freigabe hinzugef|fffd|gt."
                              s = FMT0("DOKUDATEIEN_18")
                            Case Else
                              s = ""
                              
                          End Select
                        
                          'MsgBox "Die Datei kann nicht entfernt werden. " & s, vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                          MsgBox FMT1("DOKUDATEIEN_19", s), vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                          Exit Sub
                        End If
                        Exit For
                        
                End If
            Next
        End If
        If found Then Exit For
    Next i


    'If MsgBox("Sind Sie sicher?", vbYesNo + vbQuestion + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")") = vbNo Then Exit Sub
    If MsgBox(FMT0("DOKUDATEIEN_20"), vbYesNo + vbQuestion + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")") = vbNo Then Exit Sub

    For i = ListZusaetzlicheDateien.ListCount - 1 To 0 Step -1
        If ListZusaetzlicheDateien.Selected(i) Then
        
            For idx = colZusaetzlicheDateien.count To 1 Step -1
                Set o = colZusaetzlicheDateien.item(idx)
                If o.m_L = val(ListZusaetzlicheDateien.List(i, 0)) Then
                    
                    colGeloeschteDateien.add colZusaetzlicheDateien.item(idx)

                    colZusaetzlicheDateien.Remove idx
                    ' Zeile deselektieren, sonst wird nach dem L|fffd|schen von 2 Zeilen die 1. Zeile automatisch wieder selektiert
                    ListZusaetzlicheDateien.Selected(i) = False
                    ListZusaetzlicheDateien.RemoveItem i
                    
                    
                    Exit For
                End If
            
            Next
        End If
    Next i
    
    
    Dim conn As Object
    Set conn = GetConnection()
    
    BisherGespeicherteGroesse conn
    UpdateAktuelleGroesse
    
    conn.Close
    Set conn = Nothing
    
    EnableButtonsZusaetzlicheDateien
End Sub

Private Function MyShellAndWait(Exec As String, fname As String, _
 Optional WindowStyle As VbAppWinStyle = vbMinimizedFocus) _
 As Long

  Dim nTaskId As Long
  #If VBA7 And Win64 Then
    Dim nHProcess As LongPtr
  #Else
    Dim nHProcess As Long
  #End If
  Dim nExitCode As Long
  
  Const STILL_ACTIVE = &H103
  Const PROCESS_QUERY_INFORMATION = &H400
    
  nTaskId = Shell(Exec, WindowStyle)
  Dim i As Long
  For i = 1 To 10
    Sleep 100
  Next i
  
  
  ' Bei Word m|fffd|ssen wir das etwas anders machen, da Word, wenn schon eine Instanz von Word ge|fffd|ffnet ist (oder auch Outlook, falls man dort Word als Editor benutzt, die neue Instanz einfach
  ' schlie|fffd|t und dann die Datei in der "alten" Instanz |fffd|ffnet. Dadurch klappt leider GetExitCodeProecess nicht mehr...
  
  
  If InStr(Exec, "WINWORD.EXE") > 0 Then
    MyWaitForFileClose fname, 300, 0
    MyShellAndWait = 0
  Else
  nHProcess = OpenProcess(PROCESS_QUERY_INFORMATION, False, nTaskId)
  Do
    If m_AbbruchGedr|fffd|ckt Then Exit Do
    DoEvents
    GetExitCodeProcess nHProcess, nExitCode
    
  Loop While nExitCode = STILL_ACTIVE
  CloseHandle nHProcess
  MyShellAndWait = nExitCode
  End If
End Function

Private Sub DateiOeffnenUndWarten(ByVal filename As String, Optional focus As Long = vbNormalFocus)
    Dim s2 As String, n As Long

    s2 = AnwendungFuerDatei(filename)
    If "" <> s2 Then
        MyShellAndWait Chr(34) & s2 & Chr(34) & " " & Chr(34) & filename & Chr(34), filename, focus   'vbNormalFocus)
    Else
        'MsgBox "Anwendungsprogramm f|fffd|r " & fileName & " nicht gefunden/installiert!", vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        MsgBox FMT1("DOKULIST_11", filename), vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
    End If
End Sub



Private Sub DateiOeffnen(ByRef id As Long)

    If id < 0 Then
        Exit Sub
    End If
    
    
    Dim noStartup As Boolean
    noStartup = G_NoStartup
    
    ' Excel |fffd|ffnen und datei wieder rausholen aus DB
    Dim conn As Object
    Set conn = GetConnection()
    
    Dim rs As Object
    Set rs = Nothing

    Dim fileFreigabeStatus As Long
    fileFreigabeStatus = 0

    On Error GoTo fehler
    
    Dim zu As ZusaetzlicheDatei
    Dim idx1 As Long
    For idx1 = colZusaetzlicheDateien.count To 1 Step -1
        Set zu = colZusaetzlicheDateien.item(idx1)
        If zu.m_L = id Then
            fileFreigabeStatus = zu.m_FreigabeStatus
            Exit For
        End If
    Next
      
    Set rs = OpenRS("Select x.xlBinTrackerID, x.Dateiname, x.Daten, x.Laenge, x.Compressed from xlBinTracker x where x.xlBinTrackerID=" & id, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockPessimistic)
    If rs Is Nothing Then
      'MsgBox "Die Datei ist bereits ge|fffd|ffnet, bitte versuchen Sie es sp|fffd|ter noch einmal!", vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
      MsgBox FMT0("DOKULIST_15"), vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
      conn.Close
      Set conn = Nothing
      Exit Sub
    End If
    
    Dim Dateiname As String
    Dim ext As String
    ext = ""
    
    Dateiname = GetFileNameAndPath(CreateTempFile("Tmp")) & "-" & GetFileNameAndExtension(rs.Fields("Dateiname").value)
    
    ' ext bestimmt im weitere Verlauf, ob die Datei gepackt war
    If IsNull(rs.Fields("Compressed").value) Then
        ext = ""
    ElseIf rs.Fields("Compressed").value = 0 Then
    Else
        ext = ".gz"
    End If
       
    Dim Doc As Object

    On Error GoTo fehlerDoc
    Set Doc = CreateObject("ADODB.Stream")
    With Doc
       .Type = adTypeBinary
       .Open
       .Write rs!Daten
       .SaveToFile Dateiname + ext, adSaveCreateOverWrite
    End With
    Doc.Close
    Set Doc = Nothing
    
    If ext = ".gz" Then
        UnpackFile Dateiname + ext
        MyKill Dateiname + ext
    End If
    
    Dim dontDeleteFile As Boolean
    dontDeleteFile = False
    
    Dim appname As String
    appname = AnwendungFuerDatei(Dateiname)
    
    If appname = "" Then
        'MsgBox "Anwendungsprogramm f|fffd|r " & Dateiname & " nicht gefunden/installiert!", vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        MsgBox FMT1("DOKULIST_11", Dateiname), vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        conn.Close
        Set conn = Nothing
        Exit Sub
    End If
   
    
    ' schon mal hier definieren, damit wir ganz am Ende das File wieder killen k|fffd|nnen
    Dim zippedFilename As String
    zippedFilename = ""
    
    If FileExists(Dateiname) Then
        Dim Result As Long
        If Right(UCase(appname), 9) = "EXCEL.EXE" Then
            SaveSetting _
                   appname:="Stromwerken", _
                   Section:="ExcelTracker", _
                   Key:="IgnoreThisOne", _
                   Setting:="True"
            G_NoStartup = True
        ElseIf Right(UCase(appname), 12) = "MSACCESS.EXE" Then
            SaveSetting _
                   appname:="Stromwerken", _
                   Section:="AccessTracker", _
                   Key:="IgnoreThisOne", _
                   Setting:="True"
        End If
    
    
        ' Datei so |fffd|ffnen, dass sie auch wieder aufgenommen werden kann.
        Dim speicherbar As Boolean
        speicherbar = False
        If G_FreigegebenesProgramm = fileFreigabeStatus And G_ReadOnly = False And G_PARAM_DateianhaengeNichtVeraenderbar = False Then
          speicherbar = True
        Else
          'MsgBox "Bitte beachten Sie, dass Ver|fffd|nderungen an der Datei NICHT gespeichert werden.", vbInformation, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
          MsgBox FMT0("DOKULIST_16"), vbInformation, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        End If
        
        LockDateiOeffnen True, speicherbar
        
        Dim c As New Collection
        Dim i As Long
        Dim cnt As Long
        For i = 0 To frmDoku.TabControl.Pages.count - 1
          If i <> 3 Then ' Nicht beim eigentlichen Dateidialog
            If TabControl.Pages(i).Enabled = True Then
              c.add i, "T" & cnt
              cnt = cnt + 1
              TabControl.Pages(i).Enabled = False
            End If
          End If
        Next i
        
        m_AbbruchGedr|fffd|ckt = False
        
        Dim oldSavetime As Date
        oldSavetime = MyFileDateTime(Dateiname)
        
        DateiOeffnenUndWarten Dateiname
        
        If c.count > 0 Then
          For cnt = 0 To c.count - 1
             TabControl.Pages(c("T" & cnt)).Enabled = True
          Next cnt
        End If
        LockDateiOeffnen False, speicherbar
        
        If Not m_AbbruchGedr|fffd|ckt Then
          If speicherbar Then
            If oldSavetime <> MyFileDateTime(Dateiname) Then
              'If MsgBox("Die Datei wurde ge|fffd|ndert. Soll die ge|fffd|nderte Datei |fffd|bernommen werden?" & vbCrLf & vbCrLf & "ACHTUNG: Die aktuelle Datei in dieser Doku wird dann sofort ersetzt, dies kann danach nicht mehr durch Klick auf den Button 'Abbruch' im Dokufenster r|fffd|ckg|fffd|ngig gemacht werden!", vbYesNo + vbQuestion + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")") = vbYes Then
              If MsgBox(FMT0("DOKULIST_17"), vbYesNo + vbQuestion + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")") = vbYes Then
                  ' Jetzt wird erst mal geschaut, ob es auf diese Datei mehrere Referenzen gibt. Falls ja, dann wird eine neue Version der Datei erzeugt, damit es da keinen
                  ' Murx gibt
                  Dim refcount As Long
                  refcount = 0
                  Dim trs As Object
                  Set trs = OpenRS("SELECT count(id) as countid FROM xlBinTrackerRef WHERE xlBinTrackerID = " & id & " AND DokuID <> " & G_EigeneDokuID, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
                  If Not trs Is Nothing Then
                    refcount = trs.Fields("countid").value
                    trs.Close
                    Set trs = Nothing
                  End If
                  
                  ' Wenn es mehrere Referenzen gibt, dann wird der neue Datensatz mit Daten = NULL angelegt, dann wieder ge|fffd|ffnet, die ID ausgelesene und dann
                  ' erst die Daten hinzugef|fffd|gt.
                  If refcount > 0 Then
                    Dim oldfilename As String
                    oldfilename = rs.Fields("Dateiname").value
                    rs.AddNew
                    rs.Fields("Dateiname").value = oldfilename
                    rs.Update
                    rs.Close
'                    Set rs = OpenRS("Select xlBinTrackerID, Dateiname, Daten, Laenge, Compressed from xlBinTracker where Dateiname LIKE '" & Replace(oldfilename, "'", "_") & "' AND Daten is null", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockPessimistic)
                    
                    If G_DBType = G_Oracle Then
                      Set rs = OpenRS("Select xlBinTrackerID, Dateiname, Daten, Laenge, Compressed from xlBinTracker where Daten is null ORDER BY xlBinTrackerID desc", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockPessimistic)
                    Else
                      Set rs = OpenRS("Select TOP 20 xlBinTrackerID, Dateiname, Daten, Laenge, Compressed from xlBinTracker where Daten is null ORDER BY xlBinTrackerID desc", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockPessimistic)
                    End If
                    
                    If Not rs Is Nothing Then
                    
                      Do While Not rs.EOF
                        If GetSafeFieldPlus(rs, "Dateiname", "") = oldfilename Then
                          Exit Do
                        End If
                        rs.MoveNext
                      Loop
                      
                      ' Die ID hat sich ge|fffd|ndert und muss somit auch in colZusaetzlicheDateien aktualisiert werden. In der Liste des Forms muss es dann die aufrufende
                      ' Funktion machen!
                    
                      If Not rs.EOF Then
                        Dim o As ZusaetzlicheDatei
                        Dim idx As Long
                        For idx = colZusaetzlicheDateien.count To 1 Step -1
                            Set o = colZusaetzlicheDateien.item(idx)
                            If o.m_L = id Then
                                o.m_L = rs.Fields("xlBinTrackerID").value
                                o.m_FreigabeStatus = G_FreigegebenesProgramm
                                Exit For
                            End If
                        Next
                      Else
                        ' waaas, das kann eigentlich garn nicht sein, aber dann wird halt unten in den Error Teil gesprungen
                        rs.Close
                        Set rs = Nothing
                      End If
                    
                      ' Und die neue ID zwischenspeichern
                      id = rs.Fields("xlBinTrackerID").value
                    End If
                  End If
                  
                  If rs Is Nothing Then
                    'MsgBox "Die Datei konnte nicht aktualisiert werden! Sie finden die Datei unter '" & Dateiname & "'.", vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                    MsgBox FMT1("DOKULIST_18", Dateiname), vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
                    dontDeleteFile = True
                    conn.Execute "DELETE from xlBinTracker where Dateiname LIKE '" & Replace(oldfilename, "'", "_") & "' AND Daten is null"
                  Else
                    Dim errstr As String
                    
                    ' Datei wieder packen
                    zippedFilename = PackFile(Dateiname, True)

                    If Not CheckInBinary("Daten", rs, zippedFilename, errstr) Then
                      rs.CancelUpdate
                    Else
                      rs.Fields("Laenge").value = MyFileLen(Dateiname)
                      rs.Fields("Compressed").value = IIf(Right(zippedFilename, 3) = ".gz", 1, 0)
                      rs.Update
                    End If
                  End If
              End If
            End If
          End If
          If dontDeleteFile = False Then
            MyKill Dateiname
          End If
        End If
        
    End If
    
    If zippedFilename <> "" And zippedFilename <> Dateiname Then
        MyKill zippedFilename
    End If
    
    G_NoStartup = noStartup
    rs.Close
    Set rs = Nothing
    conn.Close
    Set conn = Nothing
    
    
    Exit Sub
fehlerDoc:
    If Not Doc Is Nothing Then
        'MsgBox "Die Datei konnte nicht gespeichert werden!", vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        MsgBox FMT0("DOKULIST_19"), vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        Doc.Close
        Set Doc = Nothing
    End If
    
fehler:
    If Not rs Is Nothing Then
        rs.Close
        Set rs = Nothing
    End If

    conn.Close
    Set conn = Nothing
    
    G_NoStartup = noStartup
    
End Sub

Private Sub cmdGeoeffneteDatei_Click()
    DisableButtons
    
    Dim frm As New frmDateiAuswaehlen
    Set frm.m_OfficeApp = m_OfficeApp
    frm.Init
    frm.Show vbModal
    
    EnableButtons
    
    If frm.m_AusgeweaehlteDatei <> "" Then
        EineDateiHinzufuegen frm.m_AusgeweaehlteDatei
    End If
    Set frm = Nothing

End Sub



Private Sub LockDateiOeffnen(doLock As Boolean, speicherbar As Boolean)
  If doLock = False Then
    labelDateiOeffnen.visible = False
    labelDateiOeffnenNichtSpeichern.visible = False
  Else
    labelDateiOeffnen.visible = CBool(speicherbar = True)
    labelDateiOeffnenNichtSpeichern.visible = CBool(speicherbar = False)
  End If

  ListSignOff.Enabled = Not doLock

  If doLock Then
    DisableButtons
  Else
    EnableButtons
  End If
  
  cmdDateiOeffnenAbbruch.visible = doLock
  OK_Button.Enabled = Not doLock
  Cancel_Button.Enabled = Not doLock
  
End Sub




Private Sub TabControl_Change()

    If m_InInit = True Then Exit Sub

'! #If PROJECT_EXCELTRACKER = 1 Then
   If UCase(frmDoku.TabControl(frmDoku.TabControl.value).name) = "TODOSINEXCELDATEI" And m_TodosGathered = False Then
    
     If m_CurDoc Is Nothing Then
       Exit Sub
     End If
    
     m_TodosGathered = True
     TodoList.Clear
   
    Dim comCells As Range
    Dim i As Long
    i = 0
    Dim ws As Worksheet
    Dim c As Range
    For Each ws In m_CurDoc.Worksheets
          Set comCells = GetCommentRange(ws)
          If Not comCells Is Nothing Then
            ' Erst mal nach den Todos suchen...
            For Each c In comCells
              If CommentExists(c) Then
                Dim pos As Long
                pos = InStr(UCase(c.comment.Text), "TODO:")
                If pos > 0 Then
                  TodoList.AddItem i
                  TodoList.List(TodoList.ListCount - 1, 1) = ws.name & "!" & Replace(c.Address, "$", "") & vbTab & Trim(Mid(c.comment.Text, pos + 5)) ' vbTab & Left(c.Comment.Text, 40) & IIf(Len(c.Comment.Text) > 40, "...", "")
                End If
              End If
              i = i + 1
              If i Mod 10 = 0 Then DoEvents
              If m_AbortReadingTodos Then Exit For
            Next c
          End If
    Next ws
    EinlesenTodosAbbrechen.visible = False
  ElseIf UCase(frmDoku.TabControl(frmDoku.TabControl.value).name) = "PASSWOERTER" And m_PasswordGathered = False Then
    ShowPasswordList
  ElseIf UCase(frmDoku.TabControl(frmDoku.TabControl.value).name) = "PAGESIGNOFF" And m_VersionsGathered = False Then
    UpdateVersions
  ElseIf UCase(frmDoku.TabControl(frmDoku.TabControl.value).name) = "TABFRAGENANTWORTEN" And FragenAntworten.value = "" Then
    ShowFragenAntworten
  End If
'! #End If
End Sub

Sub ShowFragenAntworten()
  Dim conn As Object
  Set conn = GetConnection()
  
  If conn Is Nothing Then Exit Sub
  
  ' Gibts Passw|fffd|rter?
  Dim rs As Object
  
  Set rs = OpenRS("SELECT * FROM idvDateien WHERE idvDateiID=" & G_DateiID, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
  If Not rs Is Nothing Then
    Dim ergebnis As String
    If GetDateiFragenUndAntworten(rs, conn, ergebnis) Then
      frmDoku.FragenAntworten = ergebnis
      frmDoku.BeantwortungVon = GetSafeField(rs, "LetzteBefragungUserID")
      frmDoku.BeantwortungAm = GetSafeField(rs, "LetzteBefragung")
    End If
    rs.Close
  End If
  Set rs = Nothing
  
  conn.Close
  Set conn = Nothing

End Sub

Private Sub TodoList_Click()
  If TodoList.ListIndex >= 0 Then
    Dim pos As Long
    pos = InStr(TodoList.Text, vbTab)
    If pos > 0 Then
      TodoText.Text = Replace(Mid(TodoList.Text, pos + 1), vbLf, vbCrLf)
    End If
  End If

End Sub



Private Sub TodoList_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
  If TodoList.ListIndex >= 0 Then
  
    Dim tabAndCells As String
    Dim pos As Long
    
    pos = InStr(TodoList.List(TodoList.ListIndex, 1), vbTab)
    If pos > 1 Then
      tabAndCells = Left(TodoList.List(TodoList.ListIndex, 1), pos - 1)
    Else
      Exit Sub
    End If
  
    pos = InStr(tabAndCells, "!")
    If pos > 1 Then
      If Not WorksheetExists(m_CurDoc, Left(tabAndCells, pos - 1)) Then
        MsgBox FMT1("DOKUTODO_3", Left(tabAndCells, pos - 1)), vbCritical, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
      Else
        m_CurDoc.Sheets(Left(tabAndCells, pos - 1)).Activate
        m_CurDoc.Sheets(Left(tabAndCells, pos - 1)).Range(Mid(tabAndCells, pos + 1)).Select
        G_frmDoku_Cancel = True
'        Set colScripts = Nothing
'        Set colControls = Nothing
'        Set colNewRSValues = Nothing
'        VBA.Global.Unload frmDoku
'        Me.Hide
        ReleaseAllVarsAndClose
      End If
    End If
  End If

End Sub

Private Function MyWaitForFileClose(filename As String, ByVal TestIntervalMilliseconds As Long, _
    ByVal TimeOutMilliseconds As Long) As Boolean

#If VBA7 And Win64 Then
  Dim StartTickCount As LongLong
  Dim EndTickCount As LongLong
  Dim TickCountNow As LongLong
#Else
  Dim StartTickCount As Long
  Dim EndTickCount As Long
  Dim TickCountNow As Long
#End If
Dim FileIsOpen As Boolean
Dim Done As Boolean

' Before we do anything, first test if the file
' is open. If it is not, get out immediately.
FileIsOpen = IsFileOpen(filename:=filename)
If FileIsOpen = False Then
    MyWaitForFileClose = True
    Exit Function
End If

' If TestIntervalMilliseconds <= 0, use a default value of 500.
If TestIntervalMilliseconds <= 0 Then
    TestIntervalMilliseconds = 500
End If


On Error GoTo ErrHandler:

' Get the current tick count.
StartTickCount = GetTickCount()
If TimeOutMilliseconds <= 0 Then
    ' If TimeOutMilliSeconds is negative,
    ' we'll wait forever.
    EndTickCount = -1
Else
    ' If TimeOutMilliseconds > 0, get the
    ' tick count value at which we will
    ' give up on the wait and return
    ' false.
    EndTickCount = StartTickCount + TimeOutMilliseconds
End If

Done = False
Do Until Done
    
    
    If m_AbbruchGedr|fffd|ckt Then
        MyWaitForFileClose = True
        Exit Function
    End If
      
    ' Test if the file is open. If it is closed,
    ' exit with a result of True.
    If IsFileOpen(filename:=filename) = False Then
        MyWaitForFileClose = True
        Exit Function
    End If
    ' Go to sleep for TestIntervalMilliSeconds
    ' milliseconds.
    Sleep dwMilliseconds:=TestIntervalMilliseconds
    TickCountNow = GetTickCount()
    If EndTickCount > 0 Then
        ' If EndTickCount > 0, a specified timeout
        ' value was provided. Test if we have
        ' exceeded the time. Do one last test for
        ' FileOpen, and exit.
        If TickCountNow >= EndTickCount Then
            MyWaitForFileClose = Not (IsFileOpen(filename))
            Exit Function
        Else
            ' TickCountNow is less than EndTickCount,
            ' so continue to wait.
        End If
    Else
        ' EndTickCount < 0, meaning wait
        ' forever. Test if the file
        ' is open. If the file is not
        ' open, exit with a TRUE result.
        If IsFileOpen(filename:=filename) = False Then
            MyWaitForFileClose = True
            ' Application.EnableCancelKey = CancelKeyState
            Exit Function
        End If
        
    End If
    DoEvents
Loop

Exit Function

ErrHandler:
MyWaitForFileClose = False

End Function


Private Function IsFileOpen(filename As String) As Boolean
Dim FileNum As Integer
Dim ErrNum As Integer

On Error Resume Next   ' Turn error checking off.

If filename = vbNullString Then
    IsFileOpen = False
    Exit Function
End If

If Dir(filename) = vbNullString Then
    IsFileOpen = False
    Exit Function
End If
FileNum = FreeFile()
err.Clear
Open filename For Input Lock Read As #FileNum
ErrNum = err.Number
On Error GoTo 0        ' Turn error checking back on.
Close #FileNum       ' Close the file.
Select Case ErrNum
    Case 0
    ' No error occurred.
    ' File is NOT already open by another user.
        IsFileOpen = False

    Case 70
    ' Error number for "Permission Denied."
    ' File is already opened by another user.
        IsFileOpen = True

    ' Another error occurred. Assume the file
    ' cannot be accessed.
    Case Else
        IsFileOpen = True
        
End Select

End Function

Private Sub ShowPasswordList()
  m_PasswordGathered = True
  PasswordList.Clear

  Dim conn As Object
  Set conn = GetConnection()
  If conn Is Nothing Then
      'MsgBox "Diese Funktion ist zur Zeit nicht ausf|fffd|hrbar, da das System nicht zur Verf|fffd|gung steht. Bitte versuchen Sie es sp|fffd|ter noch einmal.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
      MsgBox FMT0("DOKUPWD_3"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
      Exit Sub
  End If
  If Deaktiviert(conn) Then
      'MsgBox "Aktuell steht diese Funktion nicht zur Verf|fffd|gung, da das System deaktiviert wurde. Bitte versuchen Sie es sp|fffd|ter noch einmal.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
      MsgBox FMT0("DOKUPWD_4"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
      conn.Close
      Set conn = Nothing
      Exit Sub
  End If
  
  ' Passworttyp: 1 = Datei |fffd|ffnen, 2 = VBA, 3 = Arbeitsmapp, 20 = Blattschutz
  PasswordList.AddItem "Datei-|fffd|ffnen Passwort"
  'PasswordList.List(PasswordList.ListCount - 1, 2) = "Nein"
  PasswordList.List(PasswordList.ListCount - 1, 2) = FMT0("DOKUALG_49")
  PasswordList.List(PasswordList.ListCount - 1, 3) = -1
  PasswordList.AddItem "VBA Passwort"
  'PasswordList.List(PasswordList.ListCount - 1, 2) = "Nein"
  PasswordList.List(PasswordList.ListCount - 1, 2) = FMT0("DOKUALG_49")
  PasswordList.List(PasswordList.ListCount - 1, 3) = -1
  PasswordList.AddItem "Arbeitsmappen-Passwort"
  'PasswordList.List(PasswordList.ListCount - 1, 2) = "Nein"
  PasswordList.List(PasswordList.ListCount - 1, 2) = FMT0("DOKUALG_49")
  PasswordList.List(PasswordList.ListCount - 1, 3) = -1
  
  ' Gibts Passw|fffd|rter?
  Dim rs As Object
  
  Set rs = OpenRS("SELECT * FROM idvDateienPW WHERE idvDateiID=" & G_DateiID & " ORDER BY PWTyp", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
  If Not rs Is Nothing Then
    Do While Not rs.EOF
      Select Case rs.Fields("PWTyp").value
        Case 1
          'PasswordList.List(0, 2) = "Ja"
          PasswordList.List(0, 2) = FMT0("DOKUALG_48")
          PasswordList.List(0, 3) = rs.Fields("idvDateienPWID").value
        Case 2
          'PasswordList.List(1, 2) = "Ja"
          PasswordList.List(1, 2) = FMT0("DOKUALG_48")
          PasswordList.List(1, 3) = rs.Fields("idvDateienPWID").value
        Case 3
          'PasswordList.List(2, 2) = "Ja"
          PasswordList.List(2, 2) = FMT0("DOKUALG_48")
          PasswordList.List(2, 3) = rs.Fields("idvDateienPWID").value
        Case 20
          ' PasswordList.AddItem "Datei-|fffd|ffnen Passwort" & vbTab & vbTab & "Nein"
      End Select
      rs.MoveNext
    Loop
    rs.Close
  End If
  Set rs = Nothing
  
  conn.Close
  Set conn = Nothing

End Sub


Private Sub PasswordList_DblClick(ByVal Cancel As MSForms.ReturnBoolean)

  If PasswordList.ListIndex < 0 Then Exit Sub

  Dim s As String
  Dim s2 As String
  Dim idx As Long
  's = InputBoxPW("Passwort", "Bitte Passwort eingeben. Maximal 24 Zeichen. >Leer<, um das Passwort zu l|fffd|schen.")
  s = InputBoxPW(FMT0("DOKUPWD_10"), FMT0("DOKUPWD_11"))
  If s = "" Then
    'If MsgBox("Soll ein eventuell hinterlegtes Passwort wirklich entfernt werden?", vbQuestion + vbYesNo) = vbYes Then
    If MsgBox(FMT0("DOKUPWD_12"), vbQuestion + vbYesNo) = vbYes Then
      idx = PasswordList.List(PasswordList.ListIndex, 3) ' ItemData(PasswordList.ListIndex)
      If idx > 0 Then
        
        Dim conn As Object
        Set conn = GetConnection()
        If conn Is Nothing Then
            'MsgBox "Diese Funktion ist zur Zeit nicht ausf|fffd|hrbar, da das System nicht zur Verf|fffd|gung steht. Bitte versuchen Sie es sp|fffd|ter noch einmal.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
            MsgBox FMT0("DOKUPWD_3"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
            Exit Sub
        End If
        If Deaktiviert(conn) Then
            'MsgBox "Aktuell steht diese Funktion nicht zur Verf|fffd|gung, da das System deaktiviert wurde. Bitte versuchen Sie es sp|fffd|ter noch einmal.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
            MsgBox FMT0("DOKUPWD_4"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
            conn.Close
            Set conn = Nothing
            Exit Sub
        End If
        
        conn.Execute "DELETE FROM idvDateienPW WHERE idvDateienPWID = " & idx
      
        conn.Close
        Set conn = Nothing
      
        ShowPasswordList
      
      End If
      
    End If
  Else
    If Len(s) > 24 Then
      'MsgBox "Das Passwort ist zu lang, es sind maximal 24 Zeichen erlaubt.", vbCritical, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
      MsgBox FMT0("DOKUPWD_13"), vbCritical, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
      Exit Sub
    End If
  
    's2 = InputBoxPW("Passwort", "Bitte Passwort erneut eingeben. >Leer<, um abzubrechen.")
    s2 = InputBoxPW(FMT0("DOKUPWD_10"), FMT0("DOKUPWD_14"))
    If s <> s2 Then
      'MsgBox "Die Passw|fffd|rter unterscheiden sich!", vbCritical, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
      MsgBox FMT0("DOKUPWD_15"), vbCritical, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
    Else
      
        Set conn = GetConnection()
        If conn Is Nothing Then
            'MsgBox "Diese Funktion ist zur Zeit nicht ausf|fffd|hrbar, da das System nicht zur Verf|fffd|gung steht. Bitte versuchen Sie es sp|fffd|ter noch einmal.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
            MsgBox FMT0("DOKUPWD_3"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
            Exit Sub
        End If
        If Deaktiviert(conn) Then
            'MsgBox "Aktuell steht diese Funktion nicht zur Verf|fffd|gung, da das System deaktiviert wurde. Bitte versuchen Sie es sp|fffd|ter noch einmal.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
            MsgBox FMT0("DOKUPWD_4"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
            conn.Close
            Set conn = Nothing
            Exit Sub
        End If
        
        Dim rs As Object
        idx = PasswordList.List(PasswordList.ListIndex, 3)
        Set rs = OpenRS("SELECT * FROM idvDateienPW WHERE idvDateienPWID=" & idx, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockOptimistic)
        If Not rs Is Nothing Then
          If rs.EOF Then
            rs.AddNew
            rs.Fields("idvDateiID").value = G_DateiID
          End If
          rs.Fields("LogonID").value = Left(GetUserNameUCASE(), 20)
          rs.Fields("Datum").value = Now
          rs.Fields("Passwort").value = Crypt(s, "T0)7/hJy+\1TrcpI?", True)
          If PasswordList.ListIndex >= 3 Then
            rs.Fields("PWTyp").value = 20
          Else
            rs.Fields("PWTyp").value = PasswordList.ListIndex + 1
          End If
          rs.Update
          rs.Close
        End If
        
        Set rs = Nothing
      
        conn.Close
        Set conn = Nothing
        
        ShowPasswordList
      
    End If
  End If
End Sub

Public Sub DokuAllgemein_Init(ByRef curdoc As Object, ByRef conn As Object, ByRef dateiRS As Object, ByVal locDateiID As Long, ByVal locVersion As Long, ByVal notSavedYet As Boolean)
    Dim rs As Object
    Set rs = CreateObject("ADODB.Recordset")
    
    Dateiname.Caption = GetDriveAndPathFromUNC(curdoc.fullname)
    
    If notSavedYet Then
      Version.Caption = "?"
      LetzteSpeicherung.Caption = "?"
      idvDateiID.Caption = "?"
      If locDateiID > 0 Then
          rs.Open "SELECT * FROM idvDateien WHERE idvDateiID=" & locDateiID, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
          If Not rs.EOF Then
              'DateinameKopie.Caption = GetDriveAndPathFromUNC(rs.Fields("Dateiname").value) & " - Version " & rs.Fields("MajorVersion").value & "." & rs.Fields("MinorVersion").value ' locVersion
              DateinameKopie.Caption = FMT3("DOKUALG_56", GetDriveAndPathFromUNC(rs.Fields("Dateiname").value), rs.Fields("MajorVersion").value, rs.Fields("MinorVersion").value) & " (ID: " & rs.Fields("idvDateiID").value & ")"
          End If
          rs.Close
      Else
        DateinameKopie.Caption = "-/-"
      End If
      SpeichernderUser.Caption = "?"
    Else
      Version.Caption = CStr(GetValueFromField(dateiRS, "MajorVersion", "?")) & "." & CStr(GetValueFromField(dateiRS, "MinorVersion", "?")) ' & " (" & CStr(GetValueFromField(dateiRS, "idvDateiID", "?")) & "/" & CStr(GetValueFromField(dateiRS, "Version", "?")) & ")"
      LetzteSpeicherung.Caption = GetValueFromField(dateiRS, "Speicherdatum", "?")
      idvDateiID.Caption = GetValueFromField(dateiRS, "idvDateiID", "?")
      SpeichernderUser.Caption = GetValueFromField(dateiRS, "SpeichernderUserLogonID", "?")
    
      ' Wollen wir doch mal schauen, ob ich eine Kopie bin
      DateinameKopie.Caption = "-/-"
      If dateiRS.Fields("ReferenzidvDateiID").value Then
          rs.Open "SELECT * FROM idvDateien WHERE idvDateiID=" & dateiRS.Fields("ReferenzidvDateiID").value, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
          If Not rs.EOF Then
              'DateinameKopie.Caption = GetDriveAndPathFromUNC(rs.Fields("Dateiname").value) & " - Version " & rs.Fields("MajorVersion").value & "." & rs.Fields("MinorVersion").value ' dateiRS.Fields("ReferenzVersion").value
              DateinameKopie.Caption = FMT3("DOKUALG_56", GetDriveAndPathFromUNC(rs.Fields("Dateiname").value), rs.Fields("MajorVersion").value, rs.Fields("MinorVersion").value) & " (ID: " & rs.Fields("idvDateiID").value & ")"
          End If
          rs.Close
      End If
  
    
    End If
    
    If G_DocInfo Is Nothing Then
      Tabellenanzahl.Caption = GetValueFromField(dateiRS, "Tabellenanzahl", "?")
      Tabellenbl|fffd|ttermitblattschutz.Caption = GetValueFromField(dateiRS, "TblaetterMitBlattschutz", "?")
      Tabellenbl|fffd|tterohneblattschutzmitformeln.Caption = GetValueFromField(dateiRS, "TblaetterOhnBlattschutzMitFrml", "?")
      Anzahlnichtabgesicherteformeln.Caption = GetValueFromField(dateiRS, "Anzahlnichtabgesicherteformeln", "?")
      Anzahlexternereferenzen.Caption = GetValueFromField(dateiRS, "Anzahlexternereferenzen", "?")
    Else
      Tabellenanzahl.Caption = G_DocInfo.m_Sheets
#If PROJECT_ACCESSTRACKER = 0 Then
      Tabellenbl|fffd|ttermitblattschutz.Caption = G_DocInfo.m_Protectedsheets
      Tabellenbl|fffd|tterohneblattschutzmitformeln.Caption = G_DocInfo.m_UnprotectedWorksheetsWithFormulas
      If G_DocInfo.m_NoFormulaCount Then
        'Anzahlnichtabgesicherteformeln.Caption = "NA"
        Anzahlnichtabgesicherteformeln.Caption = FMT0("DOKUALG_40")
      Else
        If G_DocInfo.m_HadProtectedSheets = True Then
          'Anzahlnichtabgesicherteformeln.Caption = "NA (wg. Schutz)"
          Anzahlnichtabgesicherteformeln.Caption = FMT0("DOKUALG_41")
        Else
          Anzahlnichtabgesicherteformeln.Caption = G_DocInfo.m_Unprotectedformulas
        End If
      End If
#End If
      Anzahlexternereferenzen.Caption = G_DocInfo.m_ExtRefs
    End If
    
    If G_PARAM_TechnischesRisikoAnzeigen Then
        TechnischesRisiko.Caption = "?"
        If Not IsNull(dateiRS.Fields("LetzterScan").value) Then
            TechnischesRisiko.Caption = Format(dateiRS.Fields("ScanRisiko").value * 100, "#;-#;0") & "%"  ' GetValueFromField(dateiRs, "ScanRisiko", "?")
            If TechnischesRisiko.Caption = "%" Then
                TechnischesRisiko.Caption = "?"
            End If
        End If
    End If
    TechnischesRisiko.visible = G_PARAM_TechnischesRisikoAnzeigen
    LabelTechnischesRisiko.visible = G_PARAM_TechnischesRisikoAnzeigen
    
    ZeitaufwandZurDoku = GetSafeFieldPlus(dateiRS, "ZeitaufwandFuerDokuInStunden", 0)

    DebugPrint DebType.tTime, "Doku 4.4"
    If G_PARAM_RisikoklasseAnzeigen Then
      'Risikowert.Caption = IIf(dateiRS.Fields("Risikowert").value = -1, "Unbew.", Format(dateiRS.Fields("Risikowert").value * 100, "#;-#;0") & "%")
      Risikowert.Caption = IIf(dateiRS.Fields("Risikowert").value = -1, FMT0("DOKUALG_42"), Format(dateiRS.Fields("Risikowert").value * 100, "#;-#;0") & "%")
      Dim riskrs As Object
      Set riskrs = CreateObject("ADODB.Recordset")
      Risikokategorie.Caption = ""
        Dim qu As String
        qu = "SELECT Risikoklassenkennzeichen, u.LokalisierterText as LocKennzeichen FROM gRisikoklasse left join gTexteUebersetzungen u on (gRisikoklasse.TextID = u.TextID and u.LanguageID = " & GetMyDBLanguage(conn) & ") where gRisikoklasse.RisikowertVon <= " & str(dateiRS.Fields("Risikowert").value) & " and " & str(dateiRS.Fields("Risikowert").value) & " <= gRisikoklasse.RisikowertBis "
        riskrs.Open qu, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
        If Not riskrs.EOF Then
            Risikokategorie.Caption = GetLocValueFromField(riskrs, "Risikoklassenkennzeichen", "LocKennzeichen", "")
        End If
        riskrs.Close
        Set riskrs = Nothing
      Risikowert.visible = True
      Risikokategorie.visible = True
      LabelRisikoklasse.visible = True
      LabelRisikoklasse2.visible = True
    End If

    Dim scanDone As Boolean
    scanDone = False
    If Not IsNull(dateiRS.Fields("LetzterScan").value) Then
        If dateiRS.Fields("LetzterScan").value <> 0 And dateiRS.Fields("LetzterScan").value <> #1/1/1900# Then
          scanDone = True
          ECCLetzterScan.Caption = dateiRS.Fields("LetzterScan").value
        End If
    End If
    
    If Not scanDone Then
        ECCLetzterScan.Caption = "-/-"
    End If

    If scanDone = True And IsNull(dateiRS.Fields("EccFormelnIndividuell").value) = False Then
        EccFormelnIndividuell.Caption = dateiRS.Fields("EccFormelnIndividuell").value
    Else
        EccFormelnIndividuell.Caption = "-/-"
    End If
    If scanDone = True And IsNull(dateiRS.Fields("ECCFormelnGesamt").value) = False Then
        FormelnGesamt.Caption = dateiRS.Fields("ECCFormelnGesamt").value
    Else
        FormelnGesamt.Caption = "-/-"
    End If

    DebugPrint DebType.tTime, "Doku 4.4.1"

    Schutzbedarf.Caption = GetSchutzbedarfText(dateiRS.Fields("Schutzbedarf"), "Schutzbedarf")
    Vertraulichkeit.Caption = GetSchutzbedarfText(dateiRS.Fields("Vertraulichkeit"), "Vertraulichkeit")
    Integritaet.Caption = GetSchutzbedarfText(dateiRS.Fields("Integritaet"), "Integritaet")
    Verfuegbarkeit.Caption = GetSchutzbedarfText(dateiRS.Fields("Verfuegbarkeit"), "Verfuegbarkeit")
    Authentizitaet.Caption = GetSchutzbedarfText(dateiRS.Fields("Authentizitaet"), "Authentizitaet")
    
    If Not G_CfgZeitaufwandZurDokuAnzeigen Then
      ZeitaufwandZurDoku.visible = False
      ZeitaufwandZurDokuText.visible = False
    End If
    
    If G_CfgSchutzbedarfsfensterAnzeigen = False Then
        Schutzbedarfsfenster.visible = False
    Else
      If G_CfgInformationsklasseAnzeigen Then
        Informationsklassifizierung.Caption = GetInfklasseText(dateiRS.Fields("Informationsklassifizierung"), "Informationsklasse")
      Else
        Informationsklassifizierung.visible = False
        InformationsklassifizierungText.visible = False
      End If
      If G_CfgGOBDAnzeigen Then
        'GOBD.Caption = IIf(GetSafeFieldPlus(dateiRS, "GOBD", 0) <> 0, "Ja", "Nein")
        GOBD.Caption = IIf(GetSafeFieldPlus(dateiRS, "GOBD", 0) <> 0, FMT0("DOKUALG_48"), FMT0("DOKUALG_49"))
      Else
        GOBD.visible = False
        GOBDText.visible = False
      End If
        
      If G_CfgBankfachlichAnzeigen Then
        'Bankfachlich.Caption = IIf(GetSafeFieldPlus(dateiRS, "Bankfachlich", 0) <> 0, "Ja", "Nein")
        Bankfachlich.Caption = IIf(GetSafeFieldPlus(dateiRS, "Bankfachlich", 0) <> 0, FMT0("DOKUALG_48"), FMT0("DOKUALG_49"))
      Else
        BankfachlichText.visible = False
        Bankfachlich.visible = False
      End If
    
      If G_cfgFremdentwicklungAnzeigen Then
        'Bankfachlich.Caption = IIf(GetSafeFieldPlus(dateiRS, "Bankfachlich", 0) <> 0, "Ja", "Nein")
        Fremdentwicklung.Caption = IIf(GetSafeFieldPlus(dateiRS, "Fremdentwicklung", 0) <> 0, FMT0("DOKUALG_48"), FMT0("DOKUALG_49"))
      Else
        FremdentwicklungText.visible = False
        Fremdentwicklung.visible = False
      End If
    
      If G_cfgAuthentizitaetAnzeigen Then
        'Bankfachlich.Caption = IIf(GetSafeFieldPlus(dateiRS, "Bankfachlich", 0) <> 0, "Ja", "Nein")
        Authentizitaet.Caption = GetSchutzbedarfText(dateiRS.Fields("Authentizitaet"), "Authentizitaet")
      Else
        AuthentizitaetText.visible = False
        Authentizitaet.visible = False
      End If
    End If
    
    Set rs = Nothing




    ModuleAnzahl.Caption = "0"
    NameAnzahl.Caption = "0"
    PivotAnzahl.Caption = "0"
    DiagrammAnzahl.Caption = "0"
    QueryAnzahl.Caption = "0"
    CloneAnzahl.Caption = "0"
    FormelAnzahl.Caption = "0"
    
    Dim rsECCLetzteAnalyse As Object
    Dim rsECCLetzteFreigabeAnalyse As Object
    Dim letzteMajorFreigabeDateiID As Long
    Dim letzteMajorFreigabeVersion As Long
    Dim letzteMajorFreigabeDatum As Date
    Dim letzteMajorFreigabeVersionMM As String
    
    ' Die INDIV1 und INDIV2 Felder anzeigen, wenn in gUebersetzungen Werte fuer
    ' 'TitelIndividuellesTextfeld1' und 'TitelIndividuellesTextfeld2' eingegeben sind
    LabelIndiv1.visible = False
    TbIndiv1.visible = False
    LabelIndiv2.visible = False
    TbIndiv2.visible = False
    Dim sprachId As Long
    sprachId = 0  ' Deutsch
    
    If G_PARAM_TitelIndividuellesTextfeld1 <> "" Then
        LabelIndiv1.visible = True
        TbIndiv1.visible = True
        LabelIndiv1.Caption = G_PARAM_TitelIndividuellesTextfeld1
        TbIndiv1.Text = GetSafeField(dateiRS, "Indiv1")
        If notSavedYet Then
          TbIndiv1.Enabled = False
        End If
    End If
    
    If G_PARAM_TitelIndividuellesTextfeld2 <> "" Then
        LabelIndiv2.visible = True
        TbIndiv2.visible = True
        LabelIndiv2.Caption = G_PARAM_TitelIndividuellesTextfeld2
        TbIndiv2.Text = GetSafeField(dateiRS, "Indiv2")
        If notSavedYet Then
          TbIndiv2.Enabled = False
        End If
    End If
    
    DebugPrint DebType.tTime, "Doku 4.4.2"
    
    On Error GoTo fehler:
    GetLetzteMajorFreigabeDateiID conn, dateiRS.Fields("idvDateiID").value, letzteMajorFreigabeDateiID, letzteMajorFreigabeVersion, letzteMajorFreigabeDatum, letzteMajorFreigabeVersionMM
                
    Set rsECCLetzteAnalyse = OpenRS("select * from ECCAnalyse where idvDateiID = " & dateiRS.Fields("idvDateiID").value & " order by DATUM DESC", conn, ADODB.CursorTypeEnum.adOpenForwardOnly, ADODB.LockTypeEnum.adLockReadOnly)
    Set rsECCLetzteFreigabeAnalyse = OpenRS("select * from ECCAnalyse inner join idvDateienFreigaben on ECCAnalyse.idvDateiID = idvDateienFreigaben.idvDateiID and ECCAnalyse.Datum = idvDateienFreigaben.Datum where idvDateienFreigaben.idvDateiID = " & letzteMajorFreigabeDateiID & " and idvDateienFreigaben.Version = " & letzteMajorFreigabeVersion & " order by idvDateienFreigaben.DATUM DESC", conn, ADODB.CursorTypeEnum.adOpenForwardOnly, ADODB.LockTypeEnum.adLockReadOnly)
                
    If Not rsECCLetzteAnalyse Is Nothing And Not rsECCLetzteFreigabeAnalyse Is Nothing Then
        If rsECCLetzteAnalyse.EOF = False And rsECCLetzteFreigabeAnalyse.EOF = False Then
            ModuleAnzahl.Caption = DifferenceValues(rsECCLetzteFreigabeAnalyse.Fields("ModuleAmount").value, rsECCLetzteAnalyse.Fields("ModuleAmount").value)
            NameAnzahl.Caption = DifferenceValues(rsECCLetzteFreigabeAnalyse.Fields("NameAmount").value, rsECCLetzteAnalyse.Fields("NameAmount").value)
            PivotAnzahl.Caption = DifferenceValues(rsECCLetzteFreigabeAnalyse.Fields("PivotAmount").value, rsECCLetzteAnalyse.Fields("PivotAmount").value)
            DiagrammAnzahl.Caption = DifferenceValues(rsECCLetzteFreigabeAnalyse.Fields("DIAGRAMAMOUNT").value, rsECCLetzteAnalyse.Fields("DIAGRAMAMOUNT").value)
            QueryAnzahl.Caption = DifferenceValues(rsECCLetzteFreigabeAnalyse.Fields("QueryAmount").value, rsECCLetzteAnalyse.Fields("QueryAmount").value)
            CloneAnzahl.Caption = DifferenceValues(rsECCLetzteFreigabeAnalyse.Fields("FORMULADUPAMOUNT").value, rsECCLetzteAnalyse.Fields("FORMULADUPAMOUNT").value)
            FormelAnzahl.Caption = DifferenceValues2( _
              rsECCLetzteFreigabeAnalyse.Fields("FormulaAmount").value, rsECCLetzteFreigabeAnalyse.Fields("FORMULADUPAMOUNT").value, _
              rsECCLetzteAnalyse.Fields("FormulaAmount").value, rsECCLetzteAnalyse.Fields("FORMULADUPAMOUNT").value)
        End If
    End If
    
fehler:
    If Not rsECCLetzteAnalyse Is Nothing Then
        rsECCLetzteAnalyse.Close
    End If
    Set rsECCLetzteAnalyse = Nothing
    
    If Not rsECCLetzteFreigabeAnalyse Is Nothing Then
        rsECCLetzteFreigabeAnalyse.Close
    End If
    Set rsECCLetzteFreigabeAnalyse = Nothing

    DebugPrint DebType.tTime, "Doku 4.4.3"

    If Not G_cfgTestEntwProd Then
      Label16.visible = False
      Einsatz.visible = False
    End If
End Sub




Public Sub DokuAllgemein_VerantwortlicherAutorSetzen(ByRef conn As Object, ByRef dateiRS As Object, ByVal autor As String, ByVal oeitem As Long, ByVal fv As String)
    VerantwortlicherAutor = autor
    If VerantwortlicherAutor = "" Then
      VerantwortlicherAutor = UCase(GetUserName)
    End If

    ' Wenn es noch keine verantwortliche OE gibt UND ich der verantwortliche Autor bin, dann nehmen wir meine OE, sonst nicht!
    If oeitem <= 0 And VerantwortlicherAutor = UCase(GetUserName) Then
      oeitem = GetUserOEID(VerantwortlicherAutor, conn)
    End If

    FachlichVerantwortlicher = fv
    If FachlichVerantwortlicher = "" Then
      FachlichVerantwortlicher = UCase(GetUserName)
    End If

    Dim drs As Object
    If G_PARAM_VerantwortlicheOE Then
          
      Set drs = OpenRS("SELECT * FROM gOEAktuell ORDER BY OEKennzeichen", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
      If Not drs.EOF Then
          Do While Not drs.EOF
              VerantwortlicheOE.AddItem GetValueFromField(drs, "OEID", 0)
              VerantwortlicheOE.List(VerantwortlicheOE.ListCount - 1, 1) = GetValueFromField(drs, "OEKennzeichen", "???") & " - " & GetValueFromField(drs, "OEBeschreibung", "???")
              If oeitem = val(drs.Fields("OEID").value) Then
                  VerantwortlicheOE.ListIndex = VerantwortlicheOE.ListCount - 1
              End If
              drs.MoveNext
          Loop
          
          VerantwortlicheOE.visible = True
          VerantwortlicheOEText.visible = True
      End If
      drs.Close

      ' Achtung: Wenn keine OE gefunden wurde, dann ist das eine historische OE. Diese wird dann auch eingestellt und der Hinweistext ausgegeben, dass diese OE nicht
      ' mehr aktuell ist
      If VerantwortlicheOE.ListIndex < 0 Then
          OeNichtMehrAktuell.visible = True
        
          If oeitem > 0 Then
              Dim tOErs As Object
          
              Set tOErs = OpenRS("SELECT * FROM gOE WHERE OEID = " & oeitem, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
              If Not tOErs Is Nothing Then
                If Not tOErs.EOF Then
                    'OeNichtMehrAktuell.Caption = "Die bisher eingestellte OE '" & GetValueFromField(tOErs, "OEKennzeichen", "???") & " - " & GetValueFromField(tOErs, "OEBeschreibung", "???") & "' ist nicht mehr aktuell!"
                    OeNichtMehrAktuell.Caption = FMT2("DOKUALG_51", GetValueFromField(tOErs, "OEKennzeichen", "???"), GetValueFromField(tOErs, "OEBeschreibung", "???"))
                Else
                    'OeNichtMehrAktuell.Caption = "Die bisher eingestellte OE ist nicht mehr aktuell!"
                    OeNichtMehrAktuell.Caption = FMT0("DOKUALG_52")
                End If
                tOErs.Close
                Set tOErs = Nothing
              End If
          End If
          
          If VerantwortlicheOE.ListCount = 0 Then
              VerantwortlicheOE.visible = False
              VerantwortlicheOEText.visible = False
          End If
      End If

    End If
    
    If G_CfgTVAnzeigen = 1 Then ' Ausblenden
      VerantwortlicherAutor.visible = False
      LabelTV.visible = False
    ElseIf G_CfgTVAnzeigen = 2 Then ' Locked
      VerantwortlicherAutor.Locked = True
    End If
    
    If G_CfgFVAnzeigen = 1 Then ' Ausblenden
      FachlichVerantwortlicher.visible = False
      LabelFV.visible = False
    ElseIf G_CfgFVAnzeigen = 2 Then ' Locked
      FachlichVerantwortlicher.Locked = True
    End If

    DebugPrint DebType.tTime, "Doku 8"
    If G_FreigegebenesProgramm > 0 Then
        Freigegeben.visible = True
        If G_FreigegebenesProgramm = 1 Then
            Freigegeben.Caption = FMT0("DOKUALG_53")
            'Freigabeinfo.Caption = "Freigabe initiiert am " & GetValueFromField(dateiRS, "FreigabeInitiierung", "?") & " von " & GetValueFromField(dateiRS, "FreigabeInitUserLogonID", "?")
            Freigabeinfo.Caption = FMT2("DOKUALG_54", GetValueFromField(dateiRS, "FreigabeInitiierung", "?"), GetValueFromField(dateiRS, "FreigabeInitUserLogonID", "?"))
        Else
            Dim onlineFreigabeStatus As Long
            Dim freigabeDatum As Date
            Dim strFreigabeKommentar As String
            Dim strUser As String
            Dim strDeaktivierenderUser As String
            Dim datumDeaktivierung As Date
            Dim strDeaktivierungKommentar As String
            onlineFreigabeStatus = GetFreigabeStatusAusDB(conn, _
                        dateiRS.Fields("FreigabeidvDateiID").value, _
                        dateiRS.Fields("FreigabeVersion").value, _
                        strFreigabeKommentar, _
                        strUser, freigabeDatum, _
                        strDeaktivierenderUser, datumDeaktivierung, strDeaktivierungKommentar)
            If onlineFreigabeStatus = 2 Then
                Freigegeben.Caption = FMT3("DOKUALG_63", strDeaktivierenderUser, datumDeaktivierung, strDeaktivierungKommentar)
                Freigabeinfo.Caption = Freigegeben.Caption
            Else
                Freigegeben.Caption = FMT0("DOKUALG_61")
                'Freigabeinfo.Caption = "Freigabe erteilt am " & freigabeDatum & " von " & strUser & IIf(Len(strFreigabeKommentar) > 0, " (" & strFreigabeKommentar & ")", "")
                Freigabeinfo.Caption = FMT2("DOKUALG_55", freigabeDatum, strUser) & IIf(Len(strFreigabeKommentar) > 0, " (" & strFreigabeKommentar & ")", "")
            End If
        End If
        Freigabeinfo.visible = True
        Einsatz.visible = False
    ElseIf G_ReadOnly Then
        Einsatz.Enabled = False
    End If
    Set drs = Nothing
    
End Sub

Public Sub DokuAllgemein_EinsatzartenSetzen(ByRef conn As Object, ByVal selitem As Long)
    ' Die Einsatzarten holen
    Dim drs As Object
    Set drs = CreateObject("ADODB.Recordset")
    drs.Open "SELECT * FROM gEinsatz", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
    If Not drs.EOF Then
        If Not GetValueFromField(drs, "Inaktiv", False) <> False Then
            Do While Not drs.EOF
                Einsatz.AddItem drs.Fields("EinsatzID").value
                'Einsatz.List(Einsatz.ListCount - 1, 1) = drs.Fields("Einsatztext").value
                Einsatz.List(Einsatz.ListCount - 1, 1) = FMT0("Einsatz_" & drs.Fields("EinsatzID").value) ' FMT0(drs.Fields("Einsatztext").value)
                If selitem = val(drs.Fields("EinsatzID").value) Then
                    Einsatz.ListIndex = Einsatz.ListCount - 1
                End If
                drs.MoveNext
            Loop
        End If
    Else
        Einsatz.visible = False
    End If
    drs.Close
    Set drs = Nothing

    If Einsatz.ListIndex < 0 Then
        If Einsatz.ListCount = 0 Then
            Einsatz.visible = False
        Else
            Einsatz.ListIndex = 0
        End If
    End If

End Sub


Public Sub DokuAllgemein_InitFreigabeStatus()

    If G_FreigegebenesProgramm > 0 Or G_ReadOnly = True Then
        VerantwortlicheOE.Enabled = False
        VerantwortlicherAutor.Enabled = False
        FachlichVerantwortlicher.Enabled = False
        ZeitaufwandZurDoku.Enabled = False
        If G_FreigegebenesProgramm > 1 Then
          TbIndiv1.Enabled = False
          TbIndiv2.Enabled = False
        End If
    End If
    
End Sub

Public Function SignOff_Init(ByRef conn As Object, ByRef dateiRS As Object) As Boolean
    SignOff_Init = False
    
    mIdvDateiID = dateiRS.Fields("idvDateiID").value
    mDateiHash = GetSafeField(dateiRS, "Hash")
    mRefDateiID = GetSafeFieldPlus(dateiRS, "ReferenzidvDateiID", 0)
    
    ListSignOff.columnCount = 6
    ' Datum,Art,User,Version
    ListSignOff.columnWidths = "0;90;60;100;60;200"
 
    SignOff_Init = True

End Function

Private Sub UpdateVersions()
  PopulateFileList
  m_VersionsGathered = True
End Sub

Private Function PopulateFileList() As Boolean
    PopulateFileList = False
    
    ListSignOff.Clear
    
    Dim conn As Object
    Set conn = GetConnection()
    On Error GoTo raus
    Dim rs As Object
    Set rs = CreateObject("ADODB.Recordset")

    Dim query As String
    
    Dim dateiIds As String
    dateiIds = CStr(mIdvDateiID)
    Dim refId As Long
    refId = mRefDateiID
    Dim refIdOld As Long
    Do While refId <> 0
        rs.Open "SELECT * FROM idvDateien WHERE idvDateiID = " & refId, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
        If Not rs.EOF Then
            dateiIds = dateiIds & "," & refId
            refIdOld = refId
            refId = GetSafeFieldPlus(rs, "ReferenzidvDateiID", 0)
            If refIdOld = refId Then
                refId = 0
            End If
        Else
            refId = 0
        End If
        rs.Close
    Loop
    
    query = "Select distinct Xlbinid As Id, Xlb.Idvdateiid, Xlb.Version, I.Dateiname, I.Majorversion, I.Minorversion, Xlb.Datum " & _
            ", F.Kommentar as Kommentar,Null As Logonid " & _
            ",0 As T " & _
            "FROM (( A_XLBINTMEINEOES Xlb Inner Join Idvdateien I On Xlb.Idvdateiid = I.Idvdateiid ) " & _
            "Left Join Idvdateienfreigaben F On (F.Idvdateiid = Xlb.Idvdateiid And F.Version = Xlb.Version) ) " & _
            "Where F.Idvdateiid Is Null And Xlb.Idvdateiid In (" & dateiIds & ") and (xlb.step is null or xlb.step = 0 ) " & _
            "UNION ALL " & _
            "SELECT distinct Xlbinid As Id2, Xlb.Idvdateiid, Xlb.Version, I.Dateiname, I.Majorversion, I.Minorversion, Xlb.Datum" & _
            ", F.Kommentar, F.FreigebenderUser As Logonid " & _
            ", 1 AS T " & _
            "FROM (( A_XLBINTMEINEOES Xlb INNER JOIN Idvdateien I ON Xlb.Idvdateiid = I.Idvdateiid ) " & _
            "LEFT JOIN Idvdateienfreigaben F ON (F.Idvdateiid = Xlb.Idvdateiid AND F.Version = Xlb.Version) ) " & _
            "WHERE f.Idvdateiid In (" & dateiIds & ") and (xlb.step is null or xlb.step = 0 ) " & _
            "UNION ALL " & _
            "SELECT distinct id as Id3, xlb.idvDateiID, xlb.Version, i.Dateiname, i.MajorVersion, i.MinorVersion, xlb.Datum" & _
            ", xlb.Kommentar, Xlb.Userlogonid As Logonid" & _
            ", 2 as T " & _
            "FROM A_XLBINSIGNOFFTMEINEOES Xlb INNER JOIN Idvdateien I ON Xlb.Idvdateiid = I.Idvdateiid " & _
            "WHERE I.Hash In ( Select T.Hash FROM Idvdateien T WHERE T.Idvdateiid = " & mIdvDateiID & ") AND xlb.idvDateiID IN (" & dateiIds & ") and (xlb.step is null or xlb.step = 0 ) ORDER BY Datum;"
    
    rs.Open query, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
    If Not rs.EOF Then
        Dim cnt As Long
        cnt = 0
        Do While Not rs.EOF
        
            Dim add As Boolean
            add = True
            Dim art As String
            art = ""
            If rs.Fields("T").value = 0 Then
                If CheckVersionierung.value = False Then
                    add = False
                Else
                    art = "Version"
                End If
            ElseIf rs.Fields("T").value = 1 Then
                If CheckFreigabe.value = False Then
                    add = False
                Else
                    art = "Freigabe"
                End If
            ElseIf rs.Fields("T").value = 2 Then
                If CheckSignOff.value = False Then
                    add = False
                Else
                    art = "Sign-Off"
                End If
            End If
                
            
            
            If add = True Then
              ListSignOff.AddItem rs.Fields("id").value
              ListSignOff.List(ListSignOff.ListCount - 1, 1) = FormatDateTime(rs.Fields("Datum").value, VbDateTimeFormat.vbGeneralDate)
              ListSignOff.List(ListSignOff.ListCount - 1, 2) = art
              ListSignOff.List(ListSignOff.ListCount - 1, 3) = GetSafeFieldPlus(rs, "LogonId", "")
              ListSignOff.List(ListSignOff.ListCount - 1, 4) = rs.Fields("MajorVersion").value & "." & rs.Fields("MinorVersion").value
              ListSignOff.List(ListSignOff.ListCount - 1, 5) = GetSafeFieldPlus(rs, "Kommentar", "")
            End If
            rs.MoveNext
            cnt = cnt + 1
        Loop
        If cnt > 0 Then
            PopulateFileList = True
        End If

        rs.Close
    End If
    Set rs = Nothing
raus:
End Function

Private Sub CheckFreigabe_Click()
    PopulateFileList
End Sub

Private Sub CheckSignOff_Click()
    PopulateFileList
End Sub

Private Sub CheckVersionierung_Click()
    PopulateFileList
End Sub

Private Sub ListSignOff_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    SignOffAnzeigen
End Sub

Private Sub SignOffAnzeigen()
On Error GoTo raus
    Dim i As Long
    Dim dat As Date
    For i = 0 To ListSignOff.ListCount - 1
        If ListSignOff.Selected(i) Then
            If InStr(UCase(ListSignOff.List(i, 2)), "SIGN-OFF") Then
                ZeigeSignOffDatei ListSignOff.List(i, 0)
            Else
                ZeigeXLBinDatei ListSignOff.List(i, 0)
            End If
        End If
    Next i
raus:
End Sub

Private Sub ZeigeSignOffDatei(ByVal id As Long)
    ' distinct geht nicht, weil binary nicht vergleichbar ist
    ZeigeDatei "Select xl.idvDateiID, xl.Nr, xl2.Step, xl2.binary, xl2.Compressed, xl.Dateiendung, i.Dateiname from A_XLBINSIGNOFFTMEINEOES xl inner join idvDateien i on xl.idvDateiID = i.idvDateiID inner join A_XLBINSIGNOFFTMEINEOES xl2 on xl.idvDateiID = xl2.idvDateiID and xl.Version = xl2.Version and xl.Datum = xl2.datum where xl.id = " & id & " order by xl2.Step, xl2.id"
End Sub

Private Sub ZeigeXLBinDatei(ByVal id As Long)
    ' distinct geht nicht, weil binary nicht vergleichbar ist
    ZeigeDatei "Select xl.idvDateiID, 0 as Nr, xl2.Step, xl2.binary, xl2.Compressed, '' as Dateiendung, i.Dateiname from A_XLBINTMEINEOES xl inner join idvDateien i on xl.idvDateiID = i.idvDateiID inner join A_XLBINTMEINEOES xl2 on xl.idvDateiID = xl2.idvDateiID and xl.Version = xl2.Version and xl.Datum = xl2.datum where xl.xlbinid = " & id & " order by xl2.Step, xl2.xlBinID "
End Sub

Private Sub ZeigeDatei(ByVal query As String)
    Dim conn As Object
    Set conn = GetConnection()
    
    If Not conn Is Nothing Then
        ZeigeDateiMitConnection query, conn
        conn.Close
        Set conn = Nothing
    End If
    
End Sub

Private Sub ZeigeDateiMitConnection(ByVal query As String, ByRef conn As Object)

    ' Excel |fffd|ffnen und datei wieder rausholen aus DB
    
    Dim i As Long
    Dim rs As Object
    Set rs = Nothing
    
    On Error GoTo fehlerDoc
    Set rs = OpenRS(query, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockPessimistic)
    If rs Is Nothing Then
      'MsgBox "Die Datei ist bereits ge|fffd|ffnet, bitte versuchen Sie es sp|fffd|ter noch einmal!", vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
      MsgBox FMT0("DOKULIST_15"), vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
      
      Exit Sub
    End If
    
    Dim alleDateien As New Collection
    
    ' nur den ersten Eintrag nehmen, daher hier keine while Schleife
    If rs.EOF = False Then
   
        Dim Dateiname As String
        Dim ext As String
        ext = ""
    
        Dim tmpFile As String
        tmpFile = CreateTempFile("Tmp")
        
        Dateiname = rs.Fields("Dateiname").value
        ext = ""
        If IsNull(rs.Fields("DateiEndung").value) = False Then
            ext = rs.Fields("DateiEndung").value
        End If
        
        If ext <> "" Then
            Dateiname = GetFileNameAndPath(tmpFile) & "-" & rs.Fields("Nr").value & "." & rs.Fields("DateiEndung").value
        Else
            Dateiname = GetFileNameAndPath(tmpFile) & "-" & rs.Fields("Nr").value & "." & GetFileExtension(Dateiname)
        End If
        
        MyKill tmpFile
        
        If xlCheckOutBinaryRecordset(conn, rs, Dateiname) = True Then
            alleDateien.add Dateiname
        End If
    End If
    rs.Close
    Set rs = Nothing
    
    If alleDateien.count > 0 Then
      If FileExists(alleDateien(1)) Then
          Dim xl As Excel.Application
          Set xl = New Excel.Application
          xl.visible = True
          SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="DokuOK", Setting:=UCase(GetFileNameAndExtension(alleDateien(1)))
          
          xl.Workbooks.Open ThisWorkbook.fullname, , True
          
          Dim pw As String
          pw = GetDateiOeffnenPasswort(xl, conn, ActiveWorkbook.fullname)
          If pw = "" Then
            xl.Workbooks.Open alleDateien(1), , True
          Else
            xl.Workbooks.Open alleDateien(1), , True, , pw
          End If
          Set xl = Nothing
          AddTextToFile alleDateien(1), GetTempPath() & "IDVS-Tfls-" & GetUserName() & ".tmp"
      End If
    End If
fehlerDoc:

End Sub


Private Sub SignOffAbbruch_Click()
    m_AbbruchGedr|fffd|ckt = True
End Sub


Sub LinkClicked(ByVal Dateiname As String)
        On Error Resume Next
        
        Dim appname As String
        appname = AnwendungFuerDatei(Dateiname)
        
        ' Dim app As Object ' Excel.Application
        If FileExists(Dateiname) = True And appname <> "" Then
            Dim Result As Long
            If Right(UCase(appname), 9) = "EXCEL.EXE" Then
                SaveSetting _
                       appname:="Stromwerken", _
                       Section:="ExcelTracker", _
                       Key:="IgnoreThisOne", _
                       Setting:="True"
                G_NoStartup = True
            ElseIf Right(UCase(appname), 12) = "MSACCESS.EXE" Then
                SaveSetting _
                       appname:="Stromwerken", _
                       Section:="AccessTracker", _
                       Key:="IgnoreThisOne", _
                       Setting:="True"
            End If
    
            DateiOeffnenUndWarten Dateiname
        Else
          If G_cfgLnkApp <> "" Then
            Shell Chr(34) & G_cfgLnkApp & Chr(34) & " " & Chr(34) & Dateiname & Chr(34), vbNormalFocus
          Else
            ShellExecute 0, "open", Dateiname, "", "", 4
          End If
        End If

End Sub


Public Sub Click(ByVal ctrl As Object, ByVal index As Integer)
    On Error Resume Next
    If ctrl.name Like "BtLink*" Then
      LinkClicked colLinks(index)
    ElseIf ctrl.name Like "BtLabel*" Then
      If Left(UCase(ctrl.Caption), 7) = "HTTP://" Or _
        Left(UCase(ctrl.Caption), 8) = "HTTPS://" Then
        LinkClicked ctrl.Caption
      End If
    End If
End Sub

Public Sub PrepareScriptValuesFromDokufeldern()
    
    Dim i As Long
    
    If Not m_SBSIDCtrl Is Nothing Then
      Dim c1 As Long
      For c1 = 0 To m_SBSIDCtrl.ListCount - 1
        If m_SBSIDCtrl.Text = m_SBSIDCtrl.List(c1) Then
            m_SBSID = m_SBSIDCtrl.List(c1, 1)
            Exit For
         End If
      Next c1
    End If
    If Not m_SBSOECtrl Is Nothing Then
      m_SBSOE = m_SBSOECtrl.Text
    End If
    
    If m_colScriptValues Is Nothing Then
      Set m_colScriptValues = New Collection
    ElseIf m_SBSID = m_lastSBSID Then
      Exit Sub
    End If
    
    m_lastSBSID = m_SBSID
    
    PrepareScriptVarsSBS m_SBSID, m_SBSOE, m_colScriptValues
    
End Sub


Public Sub PopulateSBSAssetIDList(ByRef conn As Object, ByRef item As Object, ByRef sbsOEHit As Boolean)

    sbsOEHit = False

    If TypeOf item Is ComboBox Then
        Dim drs As Object
        Set drs = CreateObject("ADODB.Recordset")
        
        ' Letzte gesetzte Asset ID setzen
        Dim c1 As Long
        For c1 = 0 To item.ListCount - 1
            If item.Text = item.List(c1) Then
                If val(item.List(c1, 1)) >= 0 Then
                    m_SBSLastActiveID = val(item.List(c1, 1))
                End If
                Exit For
            End If
        Next
        
        ' ComboBox l|fffd|schen und mit Werten f|fffd|r neue OE f|fffd|llen
        item.Clear
        Dim q As String
        If m_SBSOE = "" Then
            q = "Select min(abs(SBSGroupHash-" & m_SBSGroupHash & ")) as minHashDiff, SBSID, SBSAssetName from SBSValue where SBSID = '" & m_SBSLastActiveID & "' and SBSGroup <> '__HEADER__' and SBSGroup <> '__INTERN__' group by SBSID, SBSAssetName"
        Else
            q = "Select min(abs(SBSGroupHash-" & m_SBSGroupHash & ")) as minHashDiff, SBSID, SBSAssetName from SBSValue where SBSGroupHash = " & m_SBSGroupHash & " and SBSGroup <> '__HEADER__' and SBSGroup <> '__INTERN__' group by SBSID, SBSAssetName"
        End If
        drs.Open q, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
        item.AddItem ""
        item.List(item.ListCount - 1, 1) = 0
        While drs.EOF = False
            If GetValueFromField(drs, "minHashDiff", 0) = 0 Then
                sbsOEHit = True
            End If
            item.AddItem GetValueFromField(drs, "SBSAssetName", "") & IIf(G_cfgSBSNoID = False, IIf(GetSafeFieldPlus(drs, "SBSID", 0) > 0, " (" & CStr(GetSafeFieldPlus(drs, "SBSID", 0)) & ")", ""), "")
            item.List(item.ListCount - 1, 1) = CLng(GetValueFromField(drs, "SBSID", "-1"))
            If GetValueFromField(drs, "SBSID", "-1") = m_SBSLastActiveID Then
                item.Text = GetValueFromField(drs, "SBSAssetName", "") & IIf(G_cfgSBSNoID = False, IIf(GetSafeFieldPlus(drs, "SBSID", 0) > 0, " (" & CStr(GetSafeFieldPlus(drs, "SBSID", 0)) & ")", ""), "")
                m_SBSID = GetValueFromField(drs, "SBSID", "-1")
            End If
            drs.MoveNext
        Wend
        drs.Close
        
        ' wenn es keinen Treffer gab, dann den -1 Eintrag lesen und anzeigen
        If item.Text = "" And m_SBSID <> "0" Then
            drs.Open "Select distinct SBSValueID, SBSGroup, SBSID, SBSAssetName from SBSValue where SBSID = '-1'", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
            If drs.EOF = False Then
                item.AddItem GetValueFromField(drs, "SBSAssetName", "") & IIf(G_cfgSBSNoID = False, IIf(GetSafeFieldPlus(drs, "SBSID", 0) > 0, " (" & CStr(GetSafeFieldPlus(drs, "SBSID", 0)) & ")", ""), "")
                item.List(item.ListCount - 1, 1) = CLng(GetValueFromField(drs, "SBSID", "-1"))
                item.Text = GetValueFromField(drs, "SBSAssetName", "") & IIf(G_cfgSBSNoID = False, IIf(GetSafeFieldPlus(drs, "SBSID", 0) > 0, " (" & CStr(GetSafeFieldPlus(drs, "SBSID", 0)) & ")", ""), "")
                m_SBSID = "-1"
            End If
            drs.Close
        End If
        
        Set drs = Nothing
    End If

End Sub

Public Sub PopulateSBSOE(ByRef conn As Object, ByRef item As Object)

    Dim drs As Object
    Set drs = CreateObject("ADODB.Recordset")
    
    drs.Open "Select distinct SBSGroup from SBSValue where SBSGroup <> '__HEADER__' and SBSGroup <> '__INTERN__'", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockOptimistic
    While drs.EOF = False
        item.AddItem GetValueFromField(drs, "SBSGroup", "")
        item.List(item.ListCount - 1, 1) = Hash32Bit(GetValueFromField(drs, "SBSGroup", ""))
        drs.MoveNext
    Wend
    drs.Close
    Set drs = Nothing
    
End Sub

Public Sub PopulateSBSOEText(ByRef item As Object, ByVal h As Long)

    Dim c1 As Long
    For c1 = 0 To item.ListCount - 1
        If Hash32Bit(item.List(c1)) = h Then
            item.Text = item.List(c1)
            Exit For
        End If
    Next

End Sub


Public Sub PropertyChangedFirstCall(ByRef conn As Object)
    
    Dim id As Integer
    Dim feldnummer As Integer
    Dim typ As Integer
    Dim pos As Long
    Dim s As String
    Dim feldAktiv As Integer
    Dim ctrlName As String
    Dim c As Object
    
    On Error Resume Next
    
    ' SBS Combobox finden und den Rest des Screens initialisieren
    Dim i As Long
    For i = C_DokuTabPageStart To TabControl.Pages.count - 1
        Dim item As Object
        For Each item In TabControl.Pages(i).Controls  ' TabPages(i).Controls
            pos = 1
            s = GetValuePart(item.tag, pos)
            typ = val(GetValuePart(item.tag, pos))
            feldnummer = val(GetValuePart(item.tag, pos))
            feldAktiv = val(GetValuePart(item.tag, pos))
            ctrlName = GetValuePart(item.tag, pos)
            ' nur die richtigen Comboboxen finden
            If typ <> -1 Then
                If UCase(ctrlName) = "SBSOE" Then
                    Set m_SBSOECtrl = item
                ElseIf UCase(ctrlName) = "SBSID" Then
                    Set m_SBSIDCtrl = item
                End If
            End If
        Next
    Next
    
    Dim hitOE As Boolean
    hitOE = False
    If Not m_SBSOECtrl Is Nothing Then
        PopulateSBSOE conn, m_SBSOECtrl
        If Not m_SBSIDCtrl Is Nothing Then
            PopulateSBSAssetIDList conn, m_SBSIDCtrl, hitOE
        End If
        If hitOE Then
            PopulateSBSOEText m_SBSOECtrl, m_SBSGroupHash
        End If
        m_SBSOE = m_SBSOECtrl.Text
        m_SBSGroupHash = Hash32Bit(m_SBSOE)
        PopulateSBSAssetIDList conn, m_SBSIDCtrl, hitOE
    End If
    ' PropertyChanged
End Sub

Public Sub PropertyChangedWithSender(ByRef sender As Object)

    If m_InInit = True Then
        Exit Sub
    End If
    
    Dim id As Integer
    Dim feldnummer As Integer
    Dim typ As Integer
    Dim pos As Long
    Dim s As String
    Dim feldAktiv As Integer
    Dim ctrlName As String
    Dim senderCtrlName As String
            
    pos = 1
    s = GetValuePart(sender.tag, pos)
    typ = val(GetValuePart(sender.tag, pos))
    feldnummer = val(GetValuePart(sender.tag, pos))
    feldAktiv = val(GetValuePart(sender.tag, pos))
    senderCtrlName = GetValuePart(sender.tag, pos)
    
On Error Resume Next
    ' solange Dokufelder nicht auf andere reagieren k|fffd|nnen
    ' hier wird die 2te ComboBox aufgef|fffd|llt
    If UCase(senderCtrlName) = "SBSOE" Then
    
        ' OE auslesen
        m_SBSOE = sender.Text
        m_SBSGroupHash = Hash32Bit(m_SBSOE)
    
        ' die andere ComboBox finden
        Dim i As Long
        For i = C_DokuTabPageStart To TabControl.Pages.count - 1
            Dim item As Object
            For Each item In TabControl.Pages(i).Controls  ' TabPages(i).Controls
                pos = 1
                s = GetValuePart(item.tag, pos)
                If Len(s) > 0 Then
                    id = val(s)
                    typ = val(GetValuePart(item.tag, pos))
                    feldnummer = val(GetValuePart(item.tag, pos))
                    feldAktiv = val(GetValuePart(item.tag, pos))
                    ctrlName = GetValuePart(item.tag, pos)
                    
                    If UCase(ctrlName) = "SBSID" Then
                        Dim conn As Object
                        Set conn = GetConnection
                        
                        Dim hitOE As Boolean
                        PopulateSBSAssetIDList conn, item, hitOE
                        
                        conn.Close
                        Set conn = Nothing
                    End If
                End If
            Next
        Next
    End If
    
    PropertyChanged
End Sub

Public Sub PropertyChanged()

    Dim feldnummer As Integer
    Dim typ As Integer
    Dim pos As Long
    Dim feldAktiv As Integer
    Dim ctrlName As String
    Dim item As Object
    Dim id As Long
    Dim s As String
    Static inChange As Boolean


On Error Resume Next
    Dim i As Long
    
    If m_InInit Then Exit Sub
    
    If inChange Then Exit Sub
    inChange = True
    
    ' ohne Skripte passiert auch sp|fffd|ter nix, also erst |fffd|berhaupt nix machen
    If colScripts.count = 0 And m_colSimpleSBS.count = 0 Then
        inChange = False
        Exit Sub
    End If
    
    PrepareScriptValuesFromDokufeldern
    
    For Each item In m_colSimpleSBS
      pos = 1
      s = GetValuePart(item.tag, pos)
      If Len(s) > 0 Then
          id = val(s)
          typ = val(GetValuePart(item.tag, pos))
          feldnummer = val(GetValuePart(item.tag, pos))
          feldAktiv = val(GetValuePart(item.tag, pos))
          ctrlName = GetValuePart(item.tag, pos)
          If CollectionItemExists(m_colScriptValues, ctrlName) Then
            If typ = 8 Then
              item.Caption = m_colScriptValues(ctrlName)
            Else
              item.value = m_colScriptValues(ctrlName)
            End If
          End If
      End If
    Next item
    
    Dim mussfeld As Boolean
    
    Dim cdo As CDataObject
    
'    G_HighResTimer.StartCounting "Change"
    For Each cdo In colScripts
      DokufeldAnzeigenFromScript m_ObjScript, cdo.m_Name, cdo.m_Object, cdo.m_Long, True, cdo.m_Text, Nothing, mussfeld, m_colScriptValues
    Next cdo
'    Debug.Print i & " - " & G_HighResTimer.GetCount("Change")
'    G_HighResTimer.StopCounting "Change"
    
    inChange = False
End Sub


Sub AddListItem(ByRef ListZusaetzlicheDateien, ByRef co As ZusaetzlicheDatei)

    Dim i As Long
    i = -1
    Dim s As String
    s = GetFileNameAndExtension(co.m_S) & " (" & GetFreigabeTextKurz(co.m_FreigabeStatus) & ")"
    If ListZusaetzlicheDateien.ListCount > 0 Then
      For i = 0 To ListZusaetzlicheDateien.ListCount - 1
        If UCase(ListZusaetzlicheDateien.List(i, 1)) > UCase(s) Then
          Exit For
        End If
      Next i
    End If
  
' frmDoku.ListZusaetzlicheDateien.AddItem drs.Fields("xlBinTrackerID").value
' frmDoku.ListZusaetzlicheDateien.List(frmDoku.ListZusaetzlicheDateien.ListCount - 1, 1) = GetFileNameAndExtension(drs.Fields("Dateiname").value)

  If i = -1 Then
    ListZusaetzlicheDateien.AddItem co.m_L
    ListZusaetzlicheDateien.List(ListZusaetzlicheDateien.ListCount - 1, 1) = s
  Else
    ListZusaetzlicheDateien.AddItem co.m_L, i 'xyz
    ListZusaetzlicheDateien.List(i, 1) = s
  End If
End Sub

Private Sub CommandTemplate_Click()
    
    If G_ZusaetzlicheDateienTemplate = "" Then
        Exit Sub
    End If
    If FileExists(G_ZusaetzlicheDateienTemplate) = False Then
        Exit Sub
    End If

    Dim appname As String
    appname = AnwendungFuerDatei(G_ZusaetzlicheDateienTemplate)
    
    If appname = "" Then
        'MsgBox "Anwendungsprogramm f|fffd|r " & Dateiname & " nicht gefunden/installiert!", vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        MsgBox FMT1("DOKULIST_11", G_ZusaetzlicheDateienTemplate), vbCritical + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        Exit Sub
    End If
    
    Dim Result As Long
    If Right(UCase(appname), 9) = "EXCEL.EXE" Then
        SaveSetting _
               appname:="Stromwerken", _
               Section:="ExcelTracker", _
               Key:="IgnoreThisOne", _
               Setting:="True"
        G_NoStartup = True
    ElseIf Right(UCase(appname), 12) = "MSACCESS.EXE" Then
        SaveSetting _
               appname:="Stromwerken", _
               Section:="AccessTracker", _
               Key:="IgnoreThisOne", _
               Setting:="True"
    ElseIf Right(UCase(appname), 8) = "WORD.EXE" Then
       ' Die Word-Applikation
        Dim oWDApp As Object ' Word.Application
        ' Word |fffd|ffnen
        Set oWDApp = GetWord()
        If oWDApp Is Nothing Then Exit Sub
  
        ' Word sichtbar machen
        oWDApp.visible = True
        oWDApp.DOCUMENTS.add Template:=G_ZusaetzlicheDateienTemplate, NewTemplate:=False
        Exit Sub
    End If
    
    If "" <> appname Then
        Shell Chr(34) & appname & Chr(34) & " " & Chr(34) & G_ZusaetzlicheDateienTemplate & Chr(34), vbNormalFocus
    End If

End Sub


Attribute VB_Name = "frmDokuBerechtigungen"
Attribute VB_Base = "0{740BEB32-B3FF-4351-B275-7099C9409E19}{0D8ADB98-181B-4CAD-9223-2FF6ABAEA11E}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private mAnzahlBerechtigungen As Long
Public mOKGeklickt As Boolean
Private mIdvDateiID As Long
Private mBerechtigungWarAn As Boolean

Public Sub Init(ByRef officeapp As Object, ByRef conn As Object, ByRef dateiRS As Object, ByVal locDateiID As Long, ByVal locVersion As Long, ByVal notSavedYet As Boolean)
   
   mOKGeklickt = False
   mAnzahlBerechtigungen = 0
   mIdvDateiID = locDateiID
   
    ListBerechtigungen.Clear
    
    TextUserkennung.Text = ""
    
    mBerechtigungWarAn = False
    If IsNull(dateiRS.Fields("Dateiberechtigungen").value) = False Then
        If dateiRS.Fields("Dateiberechtigungen").value <> 0 Then
            mBerechtigungWarAn = True
        End If
    End If
    
    Dim rsB As Object
    Set rsB = CreateObject("ADODB.Recordset")
    rsB.Open "SELECT Typ, Berechtigungstraeger FROM idvDateienBerechtigungen WHERE idvDateiID=" & locDateiID, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
    If Not rsB Is Nothing Then
        While rsB.EOF = False
            Dim typString As String
            typString = " "
            If rsB.Fields("Typ").value = 1 Then
                'typString = "User"
                typString = FMT0("DOKUBER_9")
            ElseIf rsB.Fields("Typ").value = 2 Then
                'typString = "Gruppe"
                typString = FMT0("DOKUBER_10")
            End If
        
            ListBerechtigungen.AddItem typString & vbTab & rsB.Fields("Berechtigungstraeger").value ' CStr(rsB.Fields("Typ").value) & vbTab & typString & vbTab & rsB.Fields("Berechtigungstraeger").value
            rsB.MoveNext
        Wend
        rsB.Close
    End If
    Set rsB = Nothing
   
    ' dieses erst nach dem F|fffd|llen der Listbox machen, da das Setzen des Checkbox.Values auch den Click-Event Handler aufruft,
    ' der dann den aktuellen User direkt mal in die ListBox
    ' mit aufnimmt
    If mBerechtigungWarAn = True Then
        'CommandOK.Caption = "Speichern und Aktivieren"
        CommandOK.Caption = FMT0("DOKUBER_11")
        CheckDateiberechtigungen.value = 1
    Else
        'CommandOK.Caption = "Speichern"
        CommandOK.Caption = FMT0("DOKUBER_6")
        CheckDateiberechtigungen.value = 0
    End If
        
    'Me.Caption = ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")" & " - Dateiberechtigung"
    Me.Caption = ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")" & " - " & FMT0("DOKUBER_12")
End Sub

Public Function Speichern(ByRef conn As Object) As Boolean

    Speichern = False
    mAnzahlBerechtigungen = 0
    On Error GoTo fehler
    
    conn.Execute "Delete from idvDateienBerechtigungen where idvDateiID = " & mIdvDateiID
    Dim rs As Object
    Set rs = CreateObject("ADODB.Recordset")
    rs.Open "Select * from idvDateienBerechtigungen where idvDateiID = " & mIdvDateiID, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockOptimistic

    If Not rs Is Nothing Then
        Dim i As Long
        For i = 0 To ListBerechtigungen.ListCount - 1
            Dim typ As Long
            
            Dim arr
            arr = Split(ListBerechtigungen.List(i), vbTab)
            
            rs.AddNew
            rs.Fields("idvDateiID").value = mIdvDateiID
            rs.Fields("Typ").value = 1 ' val(arr(0))
            rs.Fields("Berechtigungstraeger").value = arr(1) ' arr(2)
            rs.Update
            mAnzahlBerechtigungen = mAnzahlBerechtigungen + 1
        Next i
        Speichern = True ' IIf(mAnzahlBerechtigungen > 0, True, False)
        rs.Close
    End If
    Set rs = Nothing
    Exit Function
    
fehler:
    Speichern = False
    mAnzahlBerechtigungen = 0
End Function

Public Function GetAnzahlBerechtigungen() As Long
    GetAnzahlBerechtigungen = mAnzahlBerechtigungen
End Function

Public Function BerechtigungWurdeAngeschaltet() As Boolean
    If mBerechtigungWarAn = True Then
        ' war schon an, also ist es jetzt nicht angeschaltet worden
        BerechtigungWurdeAngeschaltet = False
        Exit Function
    End If
    If CheckDateiberechtigungen.value = True Then
        BerechtigungWurdeAngeschaltet = True
    Else
        BerechtigungWurdeAngeschaltet = False
    End If
End Function

Public Function BerechtigungWurdeAusgeschaltet() As Boolean
    If mBerechtigungWarAn = False Then
        BerechtigungWurdeAusgeschaltet = False
        Exit Function
    End If
    If CheckDateiberechtigungen.value = 0 Then
        BerechtigungWurdeAusgeschaltet = True
    Else
        BerechtigungWurdeAusgeschaltet = False
    End If
End Function

Private Sub GruppeHinzufuegen_Click()
End Sub

Private Sub CheckDateiberechtigungen_Click()
    If CheckDateiberechtigungen.value <> 0 Then
        Dim username As String
        username = UCase(GetUserName())
        UserNameHinzufuegen username
        'CommandOK.Caption = "Speichern und Aktivieren"
        CommandOK.Caption = FMT0("DOKUBER_11")
    Else
        'CommandOK.Caption = "Speichern"
        CommandOK.Caption = FMT0("DOKUBER_6")
    End If

End Sub

Private Sub UserNameHinzufuegen(ByVal username As String)
    Dim vorhanden As Boolean
    vorhanden = False
    
    Dim i As Long
    For i = 0 To ListBerechtigungen.ListCount - 1
        If UCase(Right(ListBerechtigungen.List(i), Len(username) + 1)) = vbTab & username Then
            vorhanden = True
            Exit For
        End If
    Next
    If vorhanden = False Then
        ListBerechtigungen.AddItem "User" & vbTab & username
    End If

End Sub

Private Sub UserForm_Initialize()
    gTranslation.TranslateForm Me

    Dim logoPath As String
    
    logoPath = G_Firmenlogo
    If FileExists(logoPath) Then
        Logo.Picture = LoadPicture(logoPath)
        If G_CfgLogoFarbe >= 0 Then
          LogoColor.BackColor = G_CfgLogoFarbe
          Logo.BackColor = G_CfgLogoFarbe
        Else
          LogoColor.visible = False
        End If
    End If

End Sub

Private Sub UserHinzufuegen_Click()

    subRemoveCloseButton Me

    If Len(TextUserkennung) > 0 Then
        UserNameHinzufuegen UCase(TextUserkennung.Text)
    End If

End Sub

Private Sub Entfernen_Click()

    Dim i As Long
    Dim cnt As Long
    cnt = 0
    Dim coll As Collection
    Set coll = New Collection
    For i = ListBerechtigungen.ListCount - 1 To 0 Step -1
        If ListBerechtigungen.Selected(i) Then
          If coll.count = 0 Then
            coll.add i
          Else
            coll.add i, , 1
          End If
          cnt = cnt + 1
        End If
    Next i
    
    If cnt = 0 Then
        Exit Sub
    End If
    
    If cnt = ListBerechtigungen.ListCount Then
        'If MsgBox("Sie beabsichtigen alle Berechtigungen zu entfernen. Der Dateischutz wird dann aufgehoben. Sind Sie sicher?", vbQuestion + vbYesNo) <> vbYes Then
        If MsgBox(FMT0("DOKUBER_13"), vbQuestion + vbYesNo) <> vbYes Then
            Set coll = Nothing
            Exit Sub
        End If
    Else
        'If MsgBox("Sollen die ausgew|fffd|hlten Berechtigungstr|fffd|ger wirklich gel|fffd|scht werden?", vbQuestion + vbYesNo) <> vbYes Then
        If MsgBox(FMT0("DOKUBER_14"), vbQuestion + vbYesNo) <> vbYes Then
            Set coll = Nothing
            Exit Sub
        End If
    End If
    
    For i = 1 To coll.count
        ListBerechtigungen.RemoveItem coll(i)
    Next i
    
    If ListBerechtigungen.ListCount = 0 Then
        CheckDateiberechtigungen.value = 0
    End If

End Sub


Private Sub CommandAbbruch_Click()
    Me.Hide
End Sub

Private Sub CommandOK_Click()
    mOKGeklickt = True
    Me.Hide
End Sub



Attribute VB_Name = "frmEMailliste"
Attribute VB_Base = "0{15265155-DD49-4557-B4AD-A215458965C2}{720FC660-8D09-452A-A443-F9743810C404}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public ccList As String
Public m_OK As Boolean

Private Sub UserForm_Initialize()
  On Error Resume Next
  
  gTranslation.TranslateForm Me
  
  m_OK = False
  Dim conn As Object
  Set conn = GetConnection() ' True)
  
    ccList = GetSetting( _
           appname:="Stromwerken", _
           Section:="ECC", _
           Key:="CCEmpfaenger", _
           Default:="")
  
  Dim drs As New Recordset
  drs.Open "SELECT * FROM gWindowsUserAktuell", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
  
  Do While Not drs.EOF
    If Not IsNull(drs.Fields("EMail").value) Then
      If drs.Fields("EMail").value <> "" Then
         If InStr(ccList, drs.Fields("EMail").value) > 0 Then
            InList.AddItem drs.Fields("Nachname").value & ", " & drs.Fields("Vorname").value & " (" & drs.Fields("EMail").value & ")"
         Else
            InSelList.AddItem drs.Fields("Nachname").value & ", " & drs.Fields("Vorname").value & " (" & drs.Fields("EMail").value & ")"
        End If
      End If
    End If
    drs.MoveNext
  Loop
  drs.Close

  conn.Close
  Set conn = Nothing

  SortListBox InSelList, 1, 0

End Sub

Private Sub InAdd_Click()
  MoveSelectedItems InSelList, InList, 1, 1
End Sub

Private Sub InDelete_Click()
  MoveSelectedItems InList, InSelList, 1, 1
End Sub

Private Sub Ok_button_Click()
    ccList = ""
    
    Dim i As Long
    For i = 0 To InList.ListCount - 1
        If Len(ccList) > 0 Then
            ccList = ccList & ";"
        End If
        
        Dim s As String
        s = InList.List(i)
        Dim klammerAuf As Long
        klammerAuf = InStrRev(s, "(")
        
        ccList = ccList & Mid(s, klammerAuf + 1, Len(s) - klammerAuf - 1)
    Next i

    SaveSetting _
           appname:="Stromwerken", _
           Section:="ECC", _
           Key:="CCEmpfaenger", _
           Setting:=ccList

    m_OK = True
    Me.Hide
'  VBA.Global.Unload frmEMailliste
End Sub

Private Sub Cancel_Button_Click()
    m_OK = False
    Me.Hide
'  VBA.Global.Unload frmEMailliste
End Sub
Attribute VB_Name = "frmFragen2"
Attribute VB_Base = "0{9BDBEE43-CE95-4ED8-BA8E-4689EC728F2E}{6AC5BE23-97AA-45C4-BA82-F59863A94D17}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public answerVal As Double
Public answerID As Long
Public NextNr As Long
Public SpeichernGeclickt As Boolean
Public AbsoluterWert As Boolean



Private Sub Antwort1_Click()
    Dim pos As Long
    pos = 1
    answerVal = GetValuePart(Antwort1.tag, pos, ";")
    NextNr = GetValuePart(Antwort1.tag, pos, ";")
    answerID = GetValuePart(Antwort1.tag, pos, ";")
    AbsoluterWert = GetValuePart(Antwort1.tag, pos, ";")
    SpeichernGeclickt = True
    Me.Hide

End Sub

Private Sub Antwort2_Click()
    Dim pos As Long
    pos = 1
    answerVal = GetValuePart(Antwort2.tag, pos, ";")
    NextNr = GetValuePart(Antwort2.tag, pos, ";")
    answerID = GetValuePart(Antwort2.tag, pos, ";")
    AbsoluterWert = GetValuePart(Antwort2.tag, pos, ";")
    SpeichernGeclickt = True
    Me.Hide


End Sub

Private Sub Antwort3_Click()
    Dim pos As Long
    pos = 1
    answerVal = GetValuePart(Antwort3.tag, pos, ";")
    NextNr = GetValuePart(Antwort3.tag, pos, ";")
    answerID = GetValuePart(Antwort3.tag, pos, ";")
    AbsoluterWert = GetValuePart(Antwort3.tag, pos, ";")
    SpeichernGeclickt = True
    Me.Hide

End Sub

Private Sub Antwort4_Click()
    Dim pos As Long
    pos = 1
    answerVal = GetValuePart(Antwort4.tag, pos, ";")
    NextNr = GetValuePart(Antwort4.tag, pos, ";")
    answerID = GetValuePart(Antwort4.tag, pos, ";")
    AbsoluterWert = GetValuePart(Antwort4.tag, pos, ";")
    SpeichernGeclickt = True
    Me.Hide

End Sub

Private Sub Antwort5_Click()
    Dim pos As Long
    pos = 1
    answerVal = GetValuePart(Antwort5.tag, pos, ";")
    NextNr = GetValuePart(Antwort5.tag, pos, ";")
    answerID = GetValuePart(Antwort5.tag, pos, ";")
    AbsoluterWert = GetValuePart(Antwort5.tag, pos, ";")
    SpeichernGeclickt = True
    Me.Hide

End Sub

Private Sub Antwort6_Click()
    Dim pos As Long
    pos = 1
    answerVal = GetValuePart(Antwort6.tag, pos, ";")
    NextNr = GetValuePart(Antwort6.tag, pos, ";")
    answerID = GetValuePart(Antwort6.tag, pos, ";")
    AbsoluterWert = GetValuePart(Antwort6.tag, pos, ";")
    SpeichernGeclickt = True
    Me.Hide

End Sub

Private Sub Antwort7_Click()
    Dim pos As Long
    pos = 1
    answerVal = GetValuePart(Antwort7.tag, pos, ";")
    NextNr = GetValuePart(Antwort7.tag, pos, ";")
    answerID = GetValuePart(Antwort7.tag, pos, ";")
    AbsoluterWert = GetValuePart(Antwort7.tag, pos, ";")
    SpeichernGeclickt = True
    Me.Hide

End Sub

Private Sub cmdBack_Click()
    NextNr = -100
    SpeichernGeclickt = True
    Me.Hide
'    VBA.Global.Unload frmFragen2
    
End Sub

Private Sub Form_Activate()
'    Me.SetFocus
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    Cancel = 1
End Sub

Private Sub UserForm_Initialize()
  gTranslation.TranslateForm Me
End Sub

Attribute VB_Name = "frmFragenEnde"
Attribute VB_Base = "0{9D7999D4-4B17-4157-9319-6F0AF4023C96}{80FE9AFB-D00B-45E7-9226-68B69A6D5F0E}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit


Public goAgain As Boolean

Private Sub cmdBack_Click()
  goAgain = True
  Me.Hide
'  VBA.Global.Unload frmFragenEnde
End Sub

Private Sub cmdOK_Click()
  goAgain = False
  Me.Hide
'  VBA.Global.Unload frmFragenEnde
End Sub

Private Sub UserForm_Initialize()
  gTranslation.TranslateForm Me
End Sub

Attribute VB_Name = "frmFreigabeCheckliste"
Attribute VB_Base = "0{6322F47F-DC21-4938-B777-F00241A50897}{E4085D09-0803-44F1-88E0-CDBDF7179814}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public OkGeklickt As Boolean

Public Sub Initialize()
    'Me.Caption = ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")" & " - Freigabe Checkliste"
    Me.Caption = ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")" & " - " & FMT0("FREIGABECL_3")
End Sub

Public Sub SetCaptionAndButton()
    'Me.Caption = ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")" & " - Fragen - Risikoklasse"
    Me.Caption = ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")" & " - " & FMT0("FREIGABECL_4")
    Me.ButtonOK2.visible = True
    Me.ButtonOk.visible = False
    Me.ButtonAbbruch.visible = False
End Sub

Private Sub ButtonAbbruch_Click()
    OkGeklickt = False
    Me.Hide
End Sub

Private Sub ButtonOk_Click()
    OkGeklickt = True
    Me.Hide
End Sub

Private Sub ButtonOk2_Click()
    OkGeklickt = True
    Me.Hide
End Sub

Private Sub UserForm_Initialize()
  gTranslation.TranslateForm Me
End Sub

Attribute VB_Name = "frmFreigabeMajorMinor"
Attribute VB_Base = "0{B69E49CF-9046-40C5-BF47-2B2CBE61AE52}{95F21BBC-B861-46D1-BBD5-F38C4287D955}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public Result As Long
Public m_idvDateiIDLetzteFreigabe As Long
Public m_idvDateiVersionLetzteFreigabe As Long
Public m_idvDateiVersionLetzteFreigabeMM As String
Public m_idvDateiDatumLetzteFreigabe As Date
Public m_idvDateiIDAktuelleDatei As Long
Public m_idvDateiVersionAktuelleDatei As Long
Public m_idvDateiMajorMinorVersionAktuelleDatei As String
Public m_Dateiname As String
Public m_ApprovingUser As String

Private Sub UserForm_Initialize()
    Result = -1
    gTranslation.TranslateForm Me

    subRemoveCloseButton Me
    
    Dim logoPath As String
    
    logoPath = G_Firmenlogo
    If FileExists(logoPath) Then
        Logo.Picture = LoadPicture(logoPath)
        If G_CfgLogoFarbe >= 0 Then
          LogoColor.BackColor = G_CfgLogoFarbe
          Logo.BackColor = G_CfgLogoFarbe
        Else
          LogoColor.visible = False
        End If
    End If

End Sub

Private Sub cmdEFC_Click()
  ' Letzte Freigabe suchen:
    Dim fname As String
    fname = m_Dateiname
    
    
    Dim conn As Object
    Set conn = GetConnection()
    If Not conn Is Nothing Then
      If xlCheckOutBinary(conn, m_idvDateiIDLetzteFreigabe, m_idvDateiVersionLetzteFreigabe, fname, True, m_idvDateiVersionLetzteFreigabeMM) Then
        
'          SaveSetting appname:="Stromwerken", Section:="EFC", Key:="Datei1", Setting:=fname
'          SaveSetting appname:="Stromwerken", Section:="EFC", Key:="Datei2", Setting:=m_Dateiname
'          SaveSetting appname:="Stromwerken", Section:="EFC", Key:="StartedByTracker", Setting:="True"
          
          ' Das aktive Passwort wird geholt, falls es eins gibt
          Dim pw1 As String
          Dim pw2 As String
          Dim typ1 As Long
          Dim typ2 As Long
          
          pw1 = GetFilePasswordFromIDWithTyp(conn, typ1, m_idvDateiIDLetzteFreigabe)
          pw2 = GetFilePasswordFromIDWithTyp(conn, typ2, m_idvDateiIDAktuelleDatei)
          conn.Close
          Set conn = Nothing
          
          If typ1 = 0 Then
            pw1 = GetStandardPassword()
          End If
          If typ2 = 0 Then
            pw2 = GetStandardPassword()
          End If
          
'          SaveSetting appname:="Stromwerken", Section:="EFC", Key:="PW1", Setting:=pw1
'          SaveSetting appname:="Stromwerken", Section:="EFC", Key:="PW2", Setting:=pw2
'          Dim tTime As String
'          tTime = Replace(Replace(CStr(Now), ":", "_"), " ", "_")
'          SaveSetting appname:="Stromwerken", Section:="EFC", Key:="ResultFileDate", Setting:=tTime
          
          
          SaveSetting appname:="Stromwerken", Section:="EFC", Key:="COMMAND", _
            Setting:="COMPQUICK /IDCALLER:" & SWAPPID_ExcelTracker & _
            " /FILE1:" & Chr(34) & fname & Chr(34) & _
            " /FILE2:" & Chr(34) & m_Dateiname & Chr(34) & _
            " /PW1:" & Chr(34) & pw1 & Chr(34) & _
            " /PW2:" & Chr(34) & pw2 & Chr(34) & _
            " /DISPLAYNAME1:" & Chr(34) & GetFileNameAndExtension(fname) & Chr(34) & _
            " /DISPLAYNAME2:" & Chr(34) & GetFileNameAndExtension(m_Dateiname) & Chr(34) & _
            " /VERSION1:" & Chr(34) & m_idvDateiVersionLetzteFreigabeMM & Chr(34) & _
            " /VERSION2:" & Chr(34) & m_idvDateiMajorMinorVersionAktuelleDatei & Chr(34) & _
            " /FILEDATE1:" & Chr(34) & m_idvDateiDatumLetzteFreigabe & Chr(34)
          
          
          G_NoStartup = True
          Dim efcfile As String
          efcfile = GetEFC()
          If G_cfgLoadETInResults Then
            SaveSetting appname:="Stromwerken", Section:="ET", Key:="LoadET", Setting:=ThisWorkbook.fullname
          End If
          StartDatei efcfile, vbNormalFocus
          G_NoStartup = False
  '        Result = -1
  '        Hide
  '    Else
        'MsgBox "Die tempor|fffd|re Datei '" & fname & "' konnte nicht f|fffd|r einen Vergleich erzeugt werden!", vbCritical, ProgNameLong & " - *FEHLER*" & " " & myVersion & " (Build: " & app.Revision & ")"
  '      MsgBox FMT1("FREIGABEMM_15", fname), vbCritical, ProgNameLong & " - " & FMT0("FREIGABEMM_16") & " " & myVersion & " (Build: " & app.Revision & ")"
      Else
        conn.Close
        Set conn = Nothing
      End If
    Else
      MsgBox FMT0("ERR_1"), vbInformation, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
    End If
End Sub

Private Sub DateiSchliessen_Click()
    Result = -1
    Hide
End Sub

Private Sub Initialize()

#If PROJECT_ACCESSTRACKER <> 0 Then
  cmdEFC.visible = False
#End If
End Sub

Private Sub MajorChange_Click()
    Result = 0
    Hide
End Sub

Private Sub MinorChange_Click()

    ' Pr|fffd|fen auf zweiten User!
    If G_PARAM_MinorChanges4AP = True And G_cfgMinorChanges4APComplex = False Then
      Dim usrname As String
      Dim usrpwd As String
      If Not GetWindowsAuthorization(FMT0("FREIGABEMM_18"), usrname, usrpwd) Then
        Exit Sub
      End If
      m_ApprovingUser = usrname
    End If

    Result = 1
    Hide
End Sub

Attribute VB_Name = "frmHinweise"
Attribute VB_Base = "0{94A4D607-A15D-468A-BDA0-BA3AA5347DEE}{7548E599-0FB8-406D-981F-24FF779D1317}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit


' Die textBox muss sein:
' - AutoSize = True
' - MultiLine = True
' - WordWrap = True
' - Ueber die volle Dialogbreite aufgezogen sein!

' Den Text hier nur ueber diese Property zuweisen, so dass diese Form eine Chance hat
' ihre Groesse passend zur Textlaenge neu zu berechnen.
Public Property Let Hinweistext(t As String)
    TbHinweistext.AutoSize = False
    TbHinweistext.width = 423
    TbHinweistext.Height = 366
    TbHinweistext.Caption = t
    TbHinweistext.AutoSize = True
    'TbHinweistext.AutoSize = True
    DoLayout
End Property

Private Sub DoLayout()
    Dim Height As Integer
    Dim y As Integer
    Height = TbHinweistext.Height
    y = TbHinweistext.Top + Height + 10
    OK_Button.Move OK_Button.Left, y
    
    Height = y + OK_Button.Height + 10
    'Move Me.Left, Me.Top, Me.Width, height
    Dim nonClientHeight As Integer
    'nonClientHeight = Me.Height - Me.ScaleHeight
    nonClientHeight = 20
    Me.Height = Height + nonClientHeight
End Sub

Private Sub Ok_button_Click()
  Me.Hide
'  VBA.Global.Unload frmHinweise
End Sub

Private Sub UserForm_Initialize()
  gTranslation.TranslateForm Me
End Sub

Attribute VB_Name = "frmHinweiseZumSignOff"
Attribute VB_Base = "0{E16C155B-C070-4A88-A692-C7925FAE4948}{643A3231-A9DA-4745-AB30-0660BF907981}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public signOff As Boolean

Private Sub CommandAbbruch_Click()
    signOff = False

    Hide
End Sub

Private Sub CommandOK_Click()
    signOff = True
    Hide
End Sub

Private Sub UserForm_Initialize()
    gTranslation.TranslateForm Me

    Dim conn As Object
    Set conn = GetConnection()
    If Not conn Is Nothing Then
        'Text1.Text = GetLocString(conn, "HinweistextBeiSignOff")
        Text1.Text = STDTEXT("HinweistextBeiSignOff")
        conn.Close
    End If
    Set conn = Nothing
End Sub

Attribute VB_Name = "frmLetzteAntworten"
Attribute VB_Base = "0{89299897-07FD-4662-87D9-EDECE31C0F0D}{192B3C85-C3A3-47A8-BC42-5D66BB58F851}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private L_FirstOpenDone As Boolean
Private L_W As Long
Private L_H As Long

Private Sub Neu_Click()
  G_AntwortenNeuGeben = True
  Me.Hide

End Sub

Private Sub NochGueltig_Click()
  G_AntwortenNeuGeben = False
  Me.Hide

End Sub


Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    Cancel = 1
End Sub

Private Sub UserForm_Initialize()
  gTranslation.TranslateForm Me
End Sub

Private Sub UserForm_Activate()

    If Not L_FirstOpenDone Then
      L_W = Me.width
      L_H = Me.Height
      L_FirstOpenDone = True
    End If

    Dim dpi As Long
    dpi = GetScreenDPI(True)
    If dpi >= 120 Then
        With Me
            Me.width = GetMin(Me.width, GetDesktopExtent(False) * CLng(96) / dpi * CLng(7) / CLng(10))
            Me.Height = GetMin(Me.Height, GetDesktopExtent(True) * CLng(96) / dpi * CLng(6) / CLng(10))
            
            'This will create a vertical scrollbar
            .ScrollBars = fmScrollBarsBoth
            
            'Change the values of 2 as Per your requirements
            ' 80 ist 20% weniger als 96, damit auch wirklich beim Scrollen alles
            ' erreicht werden kann
            .ScrollHeight = L_H ' .InsideHeight * dpi / 80 ' 96
            .ScrollWidth = L_W ' .InsideWidth * dpi / 80 ' 96
        End With
    End If
End Sub

Attribute VB_Name = "frmLogWindow"
Attribute VB_Base = "0{A80C938B-F1EB-485D-B727-423A806E3A6B}{4336DA16-FA52-4AB7-9FFA-1B468A392BFA}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Sub ClearLog_Click()
  LogText.Text = ""
  G_Log = ""
End Sub

Private Sub PrintTags_Click()

    Dim nameItem As Excel.name

    DebugPrint tinfo, "----- " & ActiveWorkbook.name & " -----"
    Dim i As Long
    If ActiveWorkbook.names.count > 0 Then
      For i = 1 To ActiveWorkbook.names.count
          If ActiveWorkbook.names(i).visible = False Then
              If InStr(ActiveWorkbook.names(i).name, "_IDVTracker") > 0 Then
                  DebugPrint tinfo, ActiveWorkbook.names.item(i).name & " = " & ActiveWorkbook.names.item(i).value
              End If
          End If
      Next i
    End If

End Sub

Private Sub ToClibboard_Click()
  CopyTextToClipboard LogText.Text
End Sub

Private Sub UserForm_Initialize()
  gTranslation.TranslateForm Me
End Sub
Attribute VB_Name = "frmLogin"
Attribute VB_Base = "0{E575F5D5-0386-4281-B707-569601D730A8}{3CAAD4AF-01D7-4F19-BA60-F4B29B4378EF}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public LoginSucceeded As Boolean
Public AuthorizingUser As String

Private Sub cmdCancel_Click()
    'set the global var to false
    'to denote a failed login
    LoginSucceeded = False
    Me.Hide
End Sub

Private Sub cmdOK_Click()
    'check for correct password
    
    If txtUserName = "" Then
      If txtPassword = Left(CStr(SHA256(CStr(day(Now) & month(Now)) & Format(Now, "HH"))), 8) Then
        AuthorizingUser = "Temp-Passwort"
        LoginSucceeded = True
        Me.Hide
      Else
          'MsgBox "Autorisierung nicht erfolgreich!", vbCritical, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
          MsgBox FMT0("LOGIN_9"), vbCritical, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
          txtPassword.SetFocus
          ' SendKeys "{Home}+{End}"
      End If
    Else
      If UCase(GetUserName) = Trim(UCase(txtUserName)) Then
        'MsgBox "Der angemeldete User und der autorisierende User d|fffd|rfen nicht identisch sein!", vbCritical, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        MsgBox FMT0("LOGIN_10"), vbCritical, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        Exit Sub
      End If
    
      If ADUserAuthorized(txtUserName, txtPassword) Then
          'place code to here to pass the
          'success to the calling sub
          'setting a global var is the easiest
          AuthorizingUser = txtUserName
          LoginSucceeded = True
          Me.Hide
      Else
          'MsgBox "Autorisierung nicht erfolgreich!", vbCritical, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
          MsgBox FMT0("LOGIN_9"), vbCritical, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
          txtPassword.SetFocus
          ' SendKeys "{Home}+{End}"
      End If
    End If
End Sub

Private Sub UserForm_Initialize()
  gTranslation.TranslateForm Me
End Sub

Attribute VB_Name = "frmMeineDateien"
Attribute VB_Base = "0{62C325A7-6C92-40D1-9986-5BF3B5070EA7}{ED2FE2CB-CD56-4E4D-9972-7D36557B4AD2}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Type ControlPositionType
    Left As Single
    Top As Single
    width As Single
    Height As Single
    FontSize As Single
End Type

Private m_ControlPositions() As ControlPositionType
Private m_FormWid As Single
Private m_FormHgt As Single
Private isInitializing As Boolean

Private Const LB_SETHORIZONTALEXTENT = &H194


Private m_LongestTextWidth As Long

Private Sub RisikoklasseCmb_Change()
  If G_Form_InInitialize Then Exit Sub
  Dim conn As Object
  Set conn = GetConnection()
  If Not conn Is Nothing Then
    GetCurrentData conn
    conn.Close
    Set conn = Nothing
  End If
  SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="MD_RK", Setting:=RisikoklasseCmb.Text

End Sub

' Save the form's and controls' dimensions.
    
Private Sub UserForm_Terminate()
  G_Form_InTerminate = True
End Sub
    
Private Sub UserForm_Initialize()
  gTranslation.TranslateForm Me
  
  If G_Form_InTerminate = True Then Exit Sub
  
  G_Form_InInitialize = True
  
'    ListBoxTabStopsSet Filelist, "0,30,100,180,260"
'    ListBoxHeaderSet Filelist, "0,30,100,180,260", FilelistHeader, "Risiko,Freigabe,Letzte Speicherung,Verantw. OE,Datei"

    Filelist.columnCount = 7
    'Filelist.ColumnWidths = "30;90;100;80;1800"
    Filelist.columnWidths = "30;90;100;80;50;150;1300"

    Dim conn As Object
    Set conn = GetConnection()
    'UpdateStatusForm "Initialisiere...", 0.05
    UpdateStatusForm FMT0("MD_11"), 0.05

    If conn Is Nothing Then
        'MsgBox "Diese Funktion ist zur Zeit nicht ausf|fffd|hrbar, da das System nicht zur Verf|fffd|gung steht. Bitte versuchen Sie es sp|fffd|ter noch einmal.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        MsgBox FMT0("DOKUPWD_3"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        Exit Sub
    End If

    If Deaktiviert(conn) Then
        'MsgBox "Aktuell steht diese Funktion nicht zur Verf|fffd|gung, da das System deaktiviert wurde. Bitte versuchen Sie es sp|fffd|ter noch einmal.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        MsgBox FMT0("DOKUPWD_4"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        conn.Close
        Set conn = Nothing
        Exit Sub
    End If

    isInitializing = True
    
    ' Und noch die Hierarchie holen!
    GetMySettings conn
    'UpdateStatusForm "Initialisiere...", 0.1
    UpdateStatusForm FMT0("MD_11"), 0.1
    CreateMyOEHierarch conn
    'UpdateStatusForm "Initialisiere...", 0.15
    UpdateStatusForm FMT0("MD_11"), 0.15
    
'    rs.Open "SELECT * FROM gOEAktuell WHERE DATE_FORMAT(VON, '%Y-%m-%d-%H-%i-%S') <= " & GetSQLTimestamp(Now()) & "') AND DATE_FORMAT(BIS, '%Y-%m-%d-%H-%i-%S') >= #" & GetSQLTimestamp(Now()) & "') ORDER BY OEKennzeichen", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
'    rs.Open "SELECT Dateiname FROM idvDateien INNER JOIN idvDateienDoku ON (idvDateien.Version = idvDateienDoku.Version) AND (idvDateien.idvDateiID = idvDateienDoku.idvDateiID) WHERE idvDateienDoku.VerantwortlicherAutor='" & UCase(GetUserName) & "' AND Geloescht=0", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
'    rs.Open "SELECT Dateiname FROM idvDateien WHERE VerantwortlicherAutor='" & UCase(GetUserName) & "' AND Geloescht=0 AND idvTypID=" & G_MeineDateienTyp, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
   
    Dim selString As String
    Dim foundSelString As Boolean
   
    'Listtype.AddItem "Meine Dateien"
    Listtype.AddItem FMT0("MD_12")
    Listtype.List(Listtype.ListCount - 1, 1) = 1
    
'    Listtype.AddItem "Freigegebene Dateien"
'    Listtype.ItemData(Listtype.NewIndex) = 5
    
    selString = GetSetting(appname:="Stromwerken", Section:=progNameShort, Key:="MD_SQL", Default:="")
    foundSelString = False
    
    If G_MeineOEsGelesen = True Then
      If G_MyOE <> "???" Then
        'Listtype.AddItem "Dateien meiner OE"
        Listtype.AddItem FMT0("MD_13")
        Listtype.List(Listtype.ListCount - 1, 1) = 2
        If FMT0("MD_13") = selString Then
          foundSelString = True
        End If
      End If
      If G_MeineOEs <> "" Then
        'Listtype.AddItem "Dateien meiner OE und untergeordneter OEs"
        Listtype.AddItem FMT0("MD_14")
        Listtype.List(Listtype.ListCount - 1, 1) = 3
        If FMT0("MD_14") = selString Then
          foundSelString = True
        End If
      End If
      If G_MeineOEsVertretung <> "" Then
        'Listtype.AddItem "Dateien der OEs, die ich vertrete"
        Listtype.AddItem FMT0("MD_15")
        Listtype.List(Listtype.ListCount - 1, 1) = 4
        If FMT0("MD_15") = selString Then
          foundSelString = True
        End If
      End If
      If G_MyOE <> "???" Then
        'Listtype.AddItem "Freigegebene Dateien meiner OE"
        Listtype.AddItem FMT0("MD_16")
        Listtype.List(Listtype.ListCount - 1, 1) = 6
        If FMT0("MD_16") = selString Then
          foundSelString = True
        End If
      End If
    End If
    
    If foundSelString Then
      Listtype.Text = selString
    Else
      'Listtype = "Meine Dateien"
      Listtype.Text = FMT0("MD_12")
    End If
    
    Dim rs As Object
    Dim queryRisk As String
    queryRisk = "SELECT RisikoklasseID, Risikoklassenkennzeichen, uKennzeichen.LokalisierterText as LocKennzeichen FROM (gRisikoklasse left join gTexteUebersetzungen uKennzeichen on (gRisikoklasse.TextID = uKennzeichen.TextID and uKennzeichen.LanguageID = " & GetMyDBLanguage(conn) & ")) " & _
    " ORDER BY Risikoklassenkennzeichen"
    Set rs = OpenRS(queryRisk, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
    'UpdateStatusForm "Initialisiere...", 0.2
    UpdateStatusForm FMT0("MD_11"), 0.2
    
    'RisikoklasseCmb.AddItem "Alle"
    RisikoklasseCmb.AddItem FMT0("MD_17")
    RisikoklasseCmb.List(RisikoklasseCmb.ListCount - 1, 1) = -10011
    
    selString = GetSetting(appname:="Stromwerken", Section:=progNameShort, Key:="MD_RK", Default:="")
    foundSelString = False
    
    If Not rs Is Nothing Then
      Do While Not rs.EOF
          RisikoklasseCmb.AddItem GetLocValueFromField(rs, "Risikoklassenkennzeichen", "LocKennzeichen", "")
          RisikoklasseCmb.List(RisikoklasseCmb.ListCount - 1, 1) = rs.Fields("RisikoklasseID").value
          If GetLocValueFromField(rs, "Risikoklassenkennzeichen", "LocKennzeichen", "-") = selString Then
            foundSelString = True
          End If
          rs.MoveNext
      Loop
      rs.Close
      Set rs = Nothing
    End If
    
    If foundSelString Then
      RisikoklasseCmb.Text = selString
    Else
      RisikoklasseCmb.Text = FMT0("MD_17")
    End If
    
    'UpdateStatusForm "Initialisiere...", 0.25
    UpdateStatusForm FMT0("MD_11"), 0.25
    
    
    'FreigabeStatus.AddItem "Alle"
    FreigabeStatus.AddItem FMT0("MD_17")
    FreigabeStatus.List(FreigabeStatus.ListCount - 1, 1) = -1
    'FreigabeStatus.AddItem "Nicht freigegeben"
    FreigabeStatus.AddItem FMT0("MD_18")
    FreigabeStatus.List(FreigabeStatus.ListCount - 1, 1) = 0
    'FreigabeStatus.AddItem "Freigabe initiiert"
    FreigabeStatus.AddItem FMT0("MD_19")
    FreigabeStatus.List(FreigabeStatus.ListCount - 1, 1) = 1
    'FreigabeStatus.AddItem "Freigegeben"
    FreigabeStatus.AddItem FMT0("MD_20")
    FreigabeStatus.List(FreigabeStatus.ListCount - 1, 1) = 2
    selString = GetSetting(appname:="Stromwerken", Section:=progNameShort, Key:="MD_FS", Default:="")
    
    If selString <> FMT0("MD_17") And selString <> FMT0("MD_18") And selString <> FMT0("MD_19") And selString <> FMT0("MD_20") Then
      selString = ""
    End If
    
    If selString <> "" Then
      FreigabeStatus.Text = selString
    Else
      FreigabeStatus.Text = FMT0("MD_17")
    End If
    
    isInitializing = False
    
    'UpdateStatusForm "Initialisiere...", 0.3
    UpdateStatusForm FMT0("MD_11"), 0.3
    GetCurrentData conn, True
    
    conn.Close
    Set conn = Nothing
  
  G_Form_InInitialize = False
  
 ' SendMessageByNum Filelist.hWnd, LB_SETHORIZONTALEXTENT, m_LongestTextWidth / Screen.TwipsPerPixelX, 0
End Sub

Private Function GetRisikoklassenSQL() As String
  GetRisikoklassenSQL = ""
  If RisikoklasseCmb.ListIndex >= 0 Then
    Dim id As Long
    id = val(RisikoklasseCmb.List(RisikoklasseCmb.ListIndex, 1))
    If id <> -10011 Then
      'GetRisikoklassenSQL = " AND gRisikoklasse.Risikoklassenkennzeichen = '" & RisikoklasseCmb.Text & "' "
      GetRisikoklassenSQL = " AND ((u.LokalisierterText is null and gRisikoklasse.Risikoklassenkennzeichen = '" & RisikoklasseCmb.Text & "') or u.LokalisierterText = '" & RisikoklasseCmb.Text & "') "
    End If
  End If
End Function


Private Function GetFreigabestatusSQL() As String
  GetFreigabestatusSQL = ""
  If FreigabeStatus.ListIndex >= 0 Then
    Dim id As Long
    id = val(FreigabeStatus.List(FreigabeStatus.ListIndex, 1))
    If id >= 0 Then
      GetFreigabestatusSQL = " AND idvDateien.FreigabeStatus = " & id & " "
    End If
  End If
End Function

Private Function GetOrderBySQL() As String
  GetOrderBySQL = " order by gRisikoklasse.RisikowertVon "
End Function

Private Sub SplitPath(fullpath As String, ByRef path As String, ByRef filename As String)
    Dim xlobj As Object
    Set xlobj = CreateObject("Scripting.FileSystemObject")
    path = xlobj.GetParentFolderName(fullpath)
    filename = xlobj.GetFileName(fullpath)
    Set xlobj = Nothing
End Sub


Private Sub GetCurrentData(ByRef conn As Object, Optional ByVal firsttime As Boolean = False)
 
    If isInitializing = True Then
        Exit Sub
    End If
    
On Error GoTo nogo
    G_Abbruch = False
    If Not firsttime Then
      LadenAbbrechen.visible = True
    End If
    Dim rs As Object

    Filelist.Clear
    
    Dim it As Long
    If Listtype.ListIndex = -1 Then
      it = 1
    Else
      it = Listtype.List(Listtype.ListIndex, 1)
    End If
    
    
    Dim selectFields As String
    'selectFields = "idvDateien.Dateiname, FreigabeStatus.Freigabetext, idvDateien.Speicherdatum, idvDateien.VerantwortlicherAutor, gOE.OEID, gOE.OEKennzeichen"
    selectFields = "idvDateien.Dateiname, FreigabeStatus.FreigabeStatusID, idvDateien.Speicherdatum, idvDateien.VerantwortlicherAutor, gOE.OEID, gOE.OEKennzeichen, FreigabeChecksumme, Checksumme, gRisikoklasse.RisikowertVon "
    Select Case it
      Case 1 ' Meine Dateien
        Set rs = OpenRS("SELECT " & selectFields & ", gRisikoklasse.Risikoklassenkennzeichen, u.LokalisierterText as LocKennzeichen FROM " & _
        " ((((idvDateien INNER JOIN FreigabeStatus ON idvDateien.FreigabeStatus = FreigabeStatus.FreigabeStatusID) " & _
        " INNER JOIN gOE ON idvDateien.VerantwortlicheOEID = gOE.OEID ) " & _
        " inner join gRisikoklasse on (idvDateien.Risikowert>=gRisikoklasse.RisikowertVon And idvDateien.Risikowert<=gRisikoklasse.RisikowertBis)) " & _
        " left join gTexteUebersetzungen u on (u.TextID = gRisikoklasse.TextID and u.LanguageID = " & GetMyDBLanguage(conn) & ")) " & _
        "  WHERE (idvDateien.VerantwortlicherAutor='" & UCase(GetUserName) & "') " & _
        "  AND idvDateien.Geloescht=0 AND (idvDateien.idvTypID=" & G_MeineDateienTyp & ") " & _
        GetRisikoklassenSQL & GetFreigabestatusSQL & GetOrderBySQL, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
        FreigabeStatus.Enabled = True
        
      Case 2 ' Dateien meiner OE
        'Set rs = OpenRS("SELECT idvDateien.Dateiname, FreigabeStatus.Freigabetext, idvDateien.Speicherdatum, idvDateien.VerantwortlicherAutor, gOE.OEID, gOE.OEKennzeichen, gRisikoklasse.Risikoklassenkennzeichen FROM gRisikoklasse, (idvDateien INNER JOIN FreigabeStatus ON idvDateien.FreigabeStatus = FreigabeStatus.FreigabeStatusID) INNER JOIN gOE ON idvDateien.VerantwortlicheOEID = gOE.OEID WHERE (((gOE.OEID)=" & G_MyOEID & ") AND ((idvDateien.Geloescht)=0) AND (idvDateien.idvTypID=" & G_MeineDateienTyp & ") " & GetRisikoklassenSQL & GetFreigabestatusSQL & " AND ((idvDateien.Risikowert)>=gRisikoklasse.RisikowertVon And (idvDateien.Risikowert)<=gRisikoklasse.RisikowertBis))", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
        Set rs = OpenRS("SELECT " & selectFields & ", gRisikoklasse.Risikoklassenkennzeichen, u.LokalisierterText as LocKennzeichen FROM " & _
        " ((((idvDateien INNER JOIN FreigabeStatus ON idvDateien.FreigabeStatus = FreigabeStatus.FreigabeStatusID) " & _
        " INNER JOIN gOE ON idvDateien.VerantwortlicheOEID = gOE.OEID ) " & _
        " inner join gRisikoklasse on (idvDateien.Risikowert>=gRisikoklasse.RisikowertVon And idvDateien.Risikowert<=gRisikoklasse.RisikowertBis)) " & _
        " left join gTexteUebersetzungen u on (u.TextID = gRisikoklasse.TextID and u.LanguageID = " & GetMyDBLanguage(conn) & ")) " & _
        "  WHERE (gOE.OEID=" & G_MyOEID & ") " & _
        " and (idvDateien.Geloescht=0) AND (idvDateien.idvTypID=" & G_MeineDateienTyp & ") " & _
        GetRisikoklassenSQL & GetFreigabestatusSQL & GetOrderBySQL, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
        FreigabeStatus.Enabled = True
    
      Case 3 ' Dateien meiner OE und untergeordneter OEs
        'Set rs = OpenRS("SELECT idvDateien.Dateiname, FreigabeStatus.Freigabetext, idvDateien.Speicherdatum, idvDateien.VerantwortlicherAutor, gOE.OEID, gOE.OEKennzeichen, gRisikoklasse.Risikoklassenkennzeichen FROM gRisikoklasse, (idvDateien INNER JOIN FreigabeStatus ON idvDateien.FreigabeStatus = FreigabeStatus.FreigabeStatusID) INNER JOIN gOE ON idvDateien.VerantwortlicheOEID = gOE.OEID WHERE (((gOE.OEID) IN (" & G_MeineOEs & ")) AND ((idvDateien.Geloescht)=0) AND (idvDateien.idvTypID=" & G_MeineDateienTyp & ") " & GetRisikoklassenSQL & GetFreigabestatusSQL & " AND ((idvDateien.Risikowert)>=gRisikoklasse.RisikowertVon And (idvDateien.Risikowert)<=gRisikoklasse.RisikowertBis))", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
        Set rs = OpenRS("SELECT " & selectFields & ", gRisikoklasse.Risikoklassenkennzeichen, u.LokalisierterText as LocKennzeichen FROM " & _
        " ((((idvDateien INNER JOIN FreigabeStatus ON idvDateien.FreigabeStatus = FreigabeStatus.FreigabeStatusID) " & _
        " INNER JOIN gOE ON idvDateien.VerantwortlicheOEID = gOE.OEID ) " & _
        " inner join gRisikoklasse on (idvDateien.Risikowert>=gRisikoklasse.RisikowertVon And idvDateien.Risikowert<=gRisikoklasse.RisikowertBis)) " & _
        " left join gTexteUebersetzungen u on (u.TextID = gRisikoklasse.TextID and u.LanguageID = " & GetMyDBLanguage(conn) & ")) " & _
        "  WHERE (gOE.OEID IN (" & G_MeineOEs & ")) " & _
        " and idvDateien.Geloescht=0 AND (idvDateien.idvTypID=" & G_MeineDateienTyp & ") " & _
        GetRisikoklassenSQL & GetFreigabestatusSQL & GetOrderBySQL, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
        FreigabeStatus.Enabled = True
    
      Case 4 ' Dateien der OEs, die ich vertrete
        ' Set rs = OpenRS("SELECT idvDateien.Dateiname, FreigabeStatus.Freigabetext, idvDateien.Speicherdatum, idvDateien.VerantwortlicherAutor, gOE.OEID, gOE.OEKennzeichen, gRisikoklasse.Risikoklassenkennzeichen FROM gRisikoklasse, (idvDateien INNER JOIN FreigabeStatus ON idvDateien.FreigabeStatus = FreigabeStatus.FreigabeStatusID) INNER JOIN gOE ON idvDateien.VerantwortlicheOEID = gOE.OEID WHERE (((gOE.OEID) IN (" & G_MeineOEsVertretung & ")) AND ((idvDateien.Geloescht)=0) AND (idvDateien.idvTypID=" & G_MeineDateienTyp & ") " & GetRisikoklassenSQL & GetFreigabestatusSQL & " AND ((idvDateien.Risikowert)>=gRisikoklasse.RisikowertVon And (idvDateien.Risikowert)<=gRisikoklasse.RisikowertBis))", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
        Set rs = OpenRS("SELECT " & selectFields & ", gRisikoklasse.Risikoklassenkennzeichen, u.LokalisierterText as LocKennzeichen FROM " & _
        " ((((idvDateien INNER JOIN FreigabeStatus ON idvDateien.FreigabeStatus = FreigabeStatus.FreigabeStatusID) " & _
        " INNER JOIN gOE ON idvDateien.VerantwortlicheOEID = gOE.OEID ) " & _
        " inner join gRisikoklasse on (idvDateien.Risikowert>=gRisikoklasse.RisikowertVon And idvDateien.Risikowert<=gRisikoklasse.RisikowertBis)) " & _
        " left join gTexteUebersetzungen u on (u.TextID = gRisikoklasse.TextID and u.LanguageID = " & GetMyDBLanguage(conn) & ")) " & _
        "  WHERE (gOE.OEID IN (" & G_MeineOEsVertretung & ")) " & _
        " and (idvDateien.Geloescht=0) AND (idvDateien.idvTypID=" & G_MeineDateienTyp & ") " & _
        GetRisikoklassenSQL & GetFreigabestatusSQL & GetOrderBySQL, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
        FreigabeStatus.Enabled = True
         
      Case 5 ' Freigegebene Dateien - Aktuell ungenutzt
        'Set rs = OpenRS("SELECT idvDateien.Dateiname, FreigabeStatus.Freigabetext, idvDateien.Speicherdatum, idvDateien.VerantwortlicherAutor, gOE.OEID, gOE.OEKennzeichen, gRisikoklasseHistorie.Risikoklassenkennzeichen FROM ((idvDateien INNER JOIN FreigabeStatus ON idvDateien.FreigabeStatus = FreigabeStatus.FreigabeStatusID) LEFT JOIN gRisikoklasseHistorie ON idvDateien.RisikoklasseIDBeiEinwertung = gRisikoklasseHistorie.RisikoklasseID) INNER JOIN gOE ON idvDateien.VerantwortlicheOEID = gOE.OEID WHERE (((idvDateien.Geloescht)=0) " & GetRisikoklassenSQL & ") AND idvDateien.FreigabeStatus = 2) AND (idvDateien.idvTypID=" & G_MeineDateienTyp & ")", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
        Set rs = OpenRS("SELECT " & selectFields & ", gRisikoklasse.Risikoklassenkennzeichen, u.LokalisierterText as LocKennzeichen FROM " & _
        " ((((idvDateien INNER JOIN FreigabeStatus ON idvDateien.FreigabeStatus = FreigabeStatus.FreigabeStatusID) " & _
        " INNER JOIN gOE ON idvDateien.VerantwortlicheOEID = gOE.OEID ) " & _
        " inner join gRisikoklasse on (idvDateien.Risikowert>=gRisikoklasse.RisikowertVon And idvDateien.Risikowert<=gRisikoklasse.RisikowertBis)) " & _
        " left join gTexteUebersetzungen u on (u.TextID = gRisikoklasse.TextID and u.LanguageID = " & GetMyDBLanguage(conn) & ")) " & _
        "  WHERE (idvDateien.Geloescht=0) " & GetRisikoklassenSQL & " AND idvDateien.FreigabeStatus = 2 AND (idvDateien.idvTypID=" & G_MeineDateienTyp & ")" & GetOrderBySQL, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
        FreigabeStatus.Enabled = False
    
      Case 6 ' Freigegebene Dateien meiner OE
        'Set rs = OpenRS("SELECT idvDateien.Dateiname, FreigabeStatus.Freigabetext, idvDateien.Speicherdatum, idvDateien.VerantwortlicherAutor, gOE.OEID, gOE.OEKennzeichen, gRisikoklasse.Risikoklassenkennzeichen FROM gRisikoklasse, (idvDateien INNER JOIN FreigabeStatus ON idvDateien.FreigabeStatus = FreigabeStatus.FreigabeStatusID) INNER JOIN gOE ON idvDateien.VerantwortlicheOEID = gOE.OEID WHERE (((gOE.OEID)=" & G_MyOEID & ") AND ((idvDateien.Geloescht)=0) AND (idvDateien.idvTypID=" & G_MeineDateienTyp & ") " & GetRisikoklassenSQL & GetFreigabestatusSQL & " AND idvDateien.FreigabeStatus = 2 AND ((idvDateien.Risikowert)>=gRisikoklasse.RisikowertVon And (idvDateien.Risikowert)<=gRisikoklasse.RisikowertBis))", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
        Set rs = OpenRS("SELECT " & selectFields & ", gRisikoklasse.Risikoklassenkennzeichen, u.LokalisierterText as LocKennzeichen FROM " & _
        " ((((idvDateien INNER JOIN FreigabeStatus ON idvDateien.FreigabeStatus = FreigabeStatus.FreigabeStatusID) " & _
        " INNER JOIN gOE ON idvDateien.VerantwortlicheOEID = gOE.OEID ) " & _
        " inner join gRisikoklasse on (idvDateien.Risikowert>=gRisikoklasse.RisikowertVon And idvDateien.Risikowert<=gRisikoklasse.RisikowertBis)) " & _
        " left join gTexteUebersetzungen u on (u.TextID = gRisikoklasse.TextID and u.LanguageID = " & GetMyDBLanguage(conn) & ")) " & _
        "  WHERE (gOE.OEID=" & G_MyOEID & ") " & _
        " AND idvDateien.Geloescht=0 AND (idvDateien.idvTypID=" & G_MeineDateienTyp & ") " & _
        GetRisikoklassenSQL & GetFreigabestatusSQL & " AND idvDateien.FreigabeStatus = 2" & GetOrderBySQL, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
        FreigabeStatus.Enabled = False
    
    End Select

    Call CacheMappedDrives

    Dim i As Long
    If Not rs Is Nothing Then
      If Not rs.EOF Then
        rs.MoveLast
        Dim totFiles As Double
        totFiles = rs.RecordCount
        Dim cnt As Double
        rs.MoveFirst
        Do While Not rs.EOF
            'Dim uncF As String
            'uncF = GetDriveAndPathFromUNC(rs.Fields("Dateiname").value)
            
            Dim fullname As String
            fullname = rs.Fields("Dateiname").value
            Dim filePath As String
            Dim filename As String
            Call SplitPath(fullname, filePath, filename)
          
            Dim mappedPath As String
            mappedPath = GetCachedMappedDrive(fullname)
            ' Jetzt den filenamen entfernen
            mappedPath = Left$(mappedPath, Len(mappedPath) - Len(filename))

            Dim freigabe As Long
            freigabe = GetSafeFieldPlus(rs, "FreigabeStatusID", 0)
          
            Dim checksumme As String
            Dim checksummeFreigabe As String
            checksumme = ""
            checksummeFreigabe = ""
            If freigabe = 2 Then
              checksumme = GetSafeFieldPlus(rs, "Checksumme", "")
              checksummeFreigabe = GetSafeFieldPlus(rs, "FreigabeChecksumme", "")
            End If

  '          If FileExists(uncF) Then
              Filelist.AddItem GetLocValueFromField(rs, "Risikoklassenkennzeichen", "LocKennzeichen", "")
              Filelist.List(Filelist.ListCount - 1, 1) = GetFreigabetext(freigabe)
              Filelist.List(Filelist.ListCount - 1, 2) = GetSafeFieldPlus(rs, "Speicherdatum", "")
              Filelist.List(Filelist.ListCount - 1, 3) = rs.Fields("OEKennzeichen").value
              Filelist.List(Filelist.ListCount - 1, 4) = IIf(checksumme <> checksummeFreigabe, "X", " ")
              Filelist.List(Filelist.ListCount - 1, 5) = filename
              Filelist.List(Filelist.ListCount - 1, 6) = mappedPath
            ' TODO
            ' If Me.TextWidth(rs.Fields("Dateiname").Value & "  ") > m_LongestTextWidth Then m_LongestTextWidth = Me.TextWidth(rs.Fields("Dateiname").Value & "  ")
  '          End If
            
            rs.MoveNext
            i = i + 1
            If i = 10 Then DoEvents
            cnt = cnt + 1
            If firsttime Then
              If G_StatusFormAbbruch = True Then Exit Do
              If totFiles > 0 Then
                'UpdateStatusForm "F|fffd|lle Liste...", 0.35 + (cnt / totFiles) * 0.65
                UpdateStatusForm FMT0("MD_28"), 0.35 + (cnt / totFiles) * 0.65
              End If
            Else
              If G_Abbruch = True Then Exit Do
            End If
        Loop
      End If
      rs.Close
      Set rs = Nothing
    End If
    
    If Not firsttime Then
      LadenAbbrechen.visible = False
    End If
    Exit Sub
nogo:
    
    On Error Resume Next
    LadenAbbrechen.visible = False
    If Not rs Is Nothing Then
      If rs.state <> 0 Then
        rs.Close
      End If
      Set rs = Nothing
    End If
   

End Sub

Private Function GetFreigabetext(freigabeStatusID As Long) As String
    ' ID    Freigabetext        StringID in TRACKER table
    ' 0     "Nicht Freigegeben" MD_18
    ' 1     "In Freigabe"       MD_19
    ' 2     "Freigegeben"       MD_20
    GetFreigabetext = ""
    Select Case freigabeStatusID
    Case 0
        GetFreigabetext = FMT0("MD_18")
    Case 1
        GetFreigabetext = FMT0("MD_19")
    Case 2
        GetFreigabetext = FMT0("MD_20")
    End Select
End Function

Private Sub cmdClose_Click()
   ' Me.Hide
   VBA.Global.Unload frmMeineDateien
End Sub

Private Sub SelectFileAndHide()

  G_LoadFile = GetDriveAndPathFromUNC(Filelist.List(Filelist.ListIndex, 6) & Filelist.List(Filelist.ListIndex, 5))
  VBA.Global.Unload frmMeineDateien

End Sub
Private Sub Filelist_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    SelectFileAndHide
 End Sub

Private Sub Freigabestatus_Change()
  If G_Form_InInitialize Then Exit Sub
  Dim conn As Object
  Set conn = GetConnection()
  If Not conn Is Nothing Then
    GetCurrentData conn
    conn.Close
    Set conn = Nothing
  End If
  SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="MD_FS", Setting:=FreigabeStatus.Text
  
End Sub

Private Sub LadenAbbrechen_Click()
  G_Abbruch = True
End Sub

Private Sub Listtype_Change()
    If G_Form_InInitialize Then Exit Sub
    Dim conn As Object
    Set conn = GetConnection()

    If conn Is Nothing Then
        'MsgBox "Diese Funktion ist zur Zeit nicht ausf|fffd|hrbar, da das System nicht zur Verf|fffd|gung steht. Bitte versuchen Sie es sp|fffd|ter noch einmal.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        MsgBox FMT0("DOKUPWD_3"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        Exit Sub
    End If

    If Deaktiviert(conn) Then
        'MsgBox "Aktuell steht diese Funktion nicht zur Verf|fffd|gung, da das System deaktiviert wurde. Bitte versuchen Sie es sp|fffd|ter noch einmal.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        MsgBox FMT0("DOKUPWD_4"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
        conn.Close
        Set conn = Nothing
        Exit Sub
    End If

    GetCurrentData conn
    
    
    conn.Close
    Set conn = Nothing

    SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="MD_SQL", Setting:=Listtype.Text
End Sub

Private Sub SearchText_Change()
  FindNextText 0
End Sub

Private Sub FindNextText(addpos As Long)
On Error Resume Next
  
  If Filelist.ListCount <= 0 Then Exit Sub
  
  Dim i As Long
  i = 0
  If Filelist.ListIndex >= 0 Then
    i = Filelist.ListIndex
  End If
  
  i = i + addpos
  
  If i < 0 Then
    Exit Sub
  End If
  If i >= Filelist.ListCount Then
    Exit Sub
  End If
  
  If Filelist.ListCount > 0 And i <= Filelist.ListCount - 1 Then
    If addpos >= 0 Then
      For i = i To Filelist.ListCount - 1
        If UCase(Filelist.List(i, 5)) Like "*" & UCase(SearchText.Text) & "*" Then
          Filelist.Selected(i) = True
          Exit For
        End If
      Next i
    Else
      For i = i To 0 Step -1
        If UCase(Filelist.List(i, 5)) Like "*" & UCase(SearchText.Text) & "*" Then
          Filelist.Selected(i) = True
          Exit For
        End If
      Next i
    End If
  End If

End Sub
Private Sub Form_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
    SelectFileAndHide
End Sub
Private Sub Filelist_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
  Select Case KeyCode
    Case vbKeyPageDown
      FindNextText 1
    Case vbKeyPageUp
      FindNextText -1
    Case vbKeyReturn
      SelectFileAndHide
  End Select
End Sub

Private Sub SearchText_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
  Dim s() As String
  On Error Resume Next
  Select Case KeyCode
    Case vbKeyPageDown
      FindNextText 1
    Case vbKeyPageUp
      FindNextText -1
    Case vbKeyReturn
        SelectFileAndHide
        ' anstatt dieser Zeilen
      'G_LoadFile = GetDriveAndPathFromUNC(Filelist.List(Filelist.ListIndex, 5) & Filelist.List(Filelist.ListIndex, 4))
      'VBA.Global.Unload frmMeineDateien
  End Select
End Sub




Attribute VB_Name = "frmMsgBox3"
Attribute VB_Base = "0{0BE888AF-DFAB-4765-BD7B-1B79AC66DC93}{540E6E37-3B3B-48B4-83A1-FB989DB7FF94}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public m_Sel As Long

Private Sub But1_Click()
  m_Sel = 1
  Me.Hide
'  VBA.Global.Unload frmMsgBox3
End Sub

Private Sub But2_Click()
  m_Sel = 2
  Me.Hide
'  VBA.Global.Unload frmMsgBox3
End Sub

Private Sub But3_Click()
  m_Sel = 3
  Me.Hide
'  VBA.Global.Unload frmMsgBox3
End Sub

Private Sub UserForm_Initialize()
    gTranslation.TranslateForm Me
End Sub
Attribute VB_Name = "frmProzessauswahl"
Attribute VB_Base = "0{B139E9DA-FA84-4B27-9D24-11DA77EA1F83}{57C7A5DD-DD94-4029-89EC-B50A6824F529}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public m_Auswahl As Long
Public m_DateiID As Long
Public m_SchluesselColumn As Long
Public m_Conn As Object

Private m_EbeneColumn(2) As String
Private m_EbeneSel(2) As String
' Die Spaltennamen in gProzessAktuell
Private m_ColumnOrder(3) As String
Private m_DontUpdateComboBoxes As Boolean
Private m_ColumnWidth(3) As Integer
Private m_AvgCharacterWidth As Long

Private m_Processes As Collection
Private m_ProcessesSorted As Collection

Private m_NumProcessesTotal As Long
Private m_NumProcessesVisible As Long

Private Const TWIPSPERINCH = 1440

Private LabelHeader(3) As Variant
Private LabelFilter(2) As Variant
Private ComboEbene(2) As Variant


Public Property Get AllProcesses() As Collection
    Set AllProcesses = m_Processes
End Property

Public Function FinalCleanup()
  Set m_Processes = Nothing
End Function

Private Sub PreCloseCleanUp()
  Set m_ProcessesSorted = Nothing
  Set m_Conn = Nothing
End Sub

Private Sub GetProcesses(fname As String)
  If G_CfgPANoTextfile = True Then
    m_NumProcessesTotal = DCount("Prozessschluessel", "gProzessAktuell")
    Exit Sub
  End If
  If G_CfgPANoTextfile = True Then Exit Sub
  If Not FileExists(fname) Then Exit Sub
  
  m_NumProcessesTotal = 0
  m_NumProcessesVisible = 0
  
  'Dim fn As Long
  'fn = FreeFile
  Dim s As String
  'Open fname For Input As fn
  
  Dim ebene1 As String
  Dim ebene2 As String
  Dim ebene3 As String
  Dim prozid As String
  Dim Integritaet As Integer
  Dim Verfuegbarkeit As Integer
  Dim Vertraulichkeit As Integer
  Dim Authentizitaet As Integer
  Dim Schutzbedarf As Integer
  Dim Informationsklassifizierung As Integer
  
  Set m_Processes = New Collection
  Set m_ProcessesSorted = New Collection
  Dim i As Long
  Dim sortText As String
  
  ' FileSystemObject kann nur UTF-16
  Dim fs, stream As Object
  Set fs = CreateObject("Scripting.FileSystemObject")
  Const ForReading = 1
  Set stream = fs.OpenTextFile(fname, ForReading, False, -1)
   
  ' UTF-8 - aber ADODB.Stream kann nur lokale files oeffnen (keine Access-Rights auf network shares)
  ' https://www.experts-exchange.com/questions/23440764/ASP-ADODB-Stream-LoadFromFile-function-does-not-work-with-network-path.html
  ' http://stackoverflow.com/questions/35000785/errors-loading-a-network-file-into-a-stream-in-classic-asp
  ' Set fs = CreateObject("ADODB.Stream")
        
  ' Zu lahm
  'Dim codePage As Long
  'UnicodeFile.OpenForInput fname, fn, codePage
  
  Dim tempCol1 As New Collection
  Dim tempCol2 As New Collection
    
  Dim ts As String
  'Do While UnicodeFile.LineInputUTF8(fn, s)
  Do While stream.AtEndOfStream <> True
    s = stream.ReadLine
    
    Dim pos As Long
    pos = 1
    ts = GetValuePart(s, pos)
    Dim addme As Boolean
    addme = False
    If IsNumeric(ts) Then
      Select Case ts
        Case "1"
          ebene1 = GetValuePart(s, pos)
          prozid = GetValuePart(s, pos)
          Integritaet = val(GetValuePart(s, pos))
          Verfuegbarkeit = val(GetValuePart(s, pos))
          Vertraulichkeit = val(GetValuePart(s, pos))
          Schutzbedarf = val(GetValuePart(s, pos))
          Informationsklassifizierung = val(GetValuePart(s, pos))
          Authentizitaet = val(GetValuePart(s, pos))
          addme = True
        Case "2"
          ebene2 = GetValuePart(s, pos)
        Case "3"
          ebene3 = GetValuePart(s, pos)
      End Select
    End If
    
    If addme Then
      Dim cp As CProzess
      Set cp = New CProzess
      cp.Prozessschluessel = prozid
      cp.Prozessname = ebene1
      cp.Prozesslandkarte = ebene2
      cp.ebene3 = ebene3
      cp.Integritaet = Integritaet
      cp.Verfuegbarkeit = Verfuegbarkeit
      cp.Vertraulichkeit = Vertraulichkeit
      cp.Schutzbedarf = Schutzbedarf
      cp.Informationsklassifizierung = Informationsklassifizierung
      cp.Authentizitaet = Authentizitaet
      
      s = ""
      sortText = ""
      
      For i = 0 To Len(G_CfgPAReihenfolge) - 1
        Dim Key As String
        Key = "O" & prozid
        Select Case m_ColumnOrder(i)
            Case "Prozessschluessel"
              s = s & prozid & vbTab
              sortText = sortText & prozid
            Case "Prozessname"
              s = s & ebene1 & vbTab
              sortText = sortText & ebene1
            Case "Prozesslandkarte"
              s = s & ebene2 & vbTab
              sortText = sortText & ebene2
            Case "Ebene3"
              s = s & ebene3 & vbTab
              sortText = sortText & ebene3
        End Select
      Next i
      
      ' Sicherheitshalber den Prozesschluessel nochmal anhaengen, so dass der sortText auch unique ist!
      sortText = sortText & prozid
      
      cp.Prozessschluessel = prozid
      cp.LBText = s
      AddObjectToCollection m_Processes, cp, Key
      AddObjectToCollection tempCol1, sortText, Key
      AddObjectToCollection tempCol2, Key, sortText
      
      m_NumProcessesTotal = m_NumProcessesTotal + 1
    End If
  Loop
  
  Call CollectionHelpers.MergeSort(tempCol1)
  
  Dim sortval As Variant
  For Each sortval In tempCol1
    If Not IsEmpty(sortval) Then
      If CollectionStringExists(tempCol2, CStr(sortval)) Then
        ' Hier kommen jetzt die Prozessschluessel sortiert rein
        AddObjectToCollection m_ProcessesSorted, tempCol2(CStr(sortval)), CStr(sortval)
      End If
    End If
  Next
  
  Set tempCol1 = Nothing
  Set tempCol2 = Nothing
  
  'Close fn
  
  If Not stream Is Nothing Then
      stream.Close
      Set stream = Nothing
  End If
  If Not fs Is Nothing Then
      Set fs = Nothing
  End If
End Sub

Public Function Init(ByRef cn As Object, ByVal dateiid As Long, showBack As Boolean) As Boolean
    Init = False
    m_DontUpdateComboBoxes = False
    
    m_Auswahl = -100
    BtBack.visible = showBack
    
    m_DateiID = dateiid
    Set m_Conn = cn
    
    Set G_SelectedProzesse = New Collection
    
    ' Die Spaltenueberschriften in der Listbox
    Dim columnHeader(3) As String
    
    Dim columnWidth(3) As Integer
    columnWidth(0) = G_CfgPASchluesselPx
    columnWidth(1) = G_CfgPAProzEbene1Px
    columnWidth(2) = G_CfgPAProzEbene2Px
    columnWidth(3) = G_CfgPAProzEbene3Px
    
    Dim ebenen(2) As String
    ' Die Spalten in gProzessAktuell
    ' "Prozessschluessel"
    ' "Prozessname"
    ' "Prozesslandkarte"
    ' "Ebene3"
    
    m_EbeneColumn(0) = ""
    m_EbeneColumn(1) = ""
    m_EbeneColumn(2) = ""
    m_EbeneSel(0) = ""
    m_EbeneSel(1) = ""
    m_EbeneSel(2) = ""
    
    Dim order(3) As Long
    order(0) = 0
    order(1) = 1
    order(2) = 2
    order(3) = 3
    
    'G_CfgPAReihenfolge
    'PAREIHENFOLGE = ABCD
    'A = Prozessschl|fffd|ssel
    'B = Ebene 1
    'C = Ebene 2
    'D = Ebene 3
    Dim i As Long
    
    ' Prozess_Ebene1,2,3 sind jetzt ST_38, ST_39, ST_40
    columnHeader(0) = FMT0(CStr("PA_6"))
    columnHeader(1) = FMT0(CStr("ST_38"))
    columnHeader(2) = FMT0(CStr("ST_39"))
    columnHeader(3) = FMT0(CStr("ST_40"))
    
    ' Ohne Prozessschluessel geht nix
    If InStr(G_CfgPAReihenfolge, "A") <= 0 Then
        G_CfgPAReihenfolge = G_CfgPAReihenfolge & "A"
    End If
    
    ' Reihenfolge die der User definiert hat
    Dim count As Long
    count = 0
    Dim nEbene As Long
    nEbene = 0
    For i = 0 To Len(G_CfgPAReihenfolge) - 1
        Select Case Mid(G_CfgPAReihenfolge, i + 1, 1)
        Case "A"
            order(count) = 0
            m_ColumnOrder(count) = "Prozessschluessel"
            m_SchluesselColumn = count
            count = count + 1
        Case "B"
            ' Haben wir hierfuer einen header?
            If columnHeader(1) <> "" Then
                order(count) = 1
                m_ColumnOrder(count) = "Prozessname"
                count = count + 1
                m_EbeneColumn(nEbene) = "Prozessname"
                nEbene = nEbene + 1
            End If
        Case "C"
            ' Haben wir hierfuer einen header?
            If columnHeader(2) <> "" Then
                order(count) = 2
                m_ColumnOrder(count) = "Prozesslandkarte"
                count = count + 1
                m_EbeneColumn(nEbene) = "Prozesslandkarte"
                nEbene = nEbene + 1
            End If
        Case "D"
            ' Haben wir hierfuer einen header?
            If columnHeader(3) <> "" Then
                order(count) = 3
                m_ColumnOrder(count) = "Ebene3"
                count = count + 1
                m_EbeneColumn(nEbene) = "Ebene3"
                nEbene = nEbene + 1
            End If
        End Select
    Next i
    
    Dim columnCount As Long
    columnCount = 0
    Dim columnWidths As String
    columnWidths = ""
    Dim ebeneIdx As Long
    ebeneIdx = 0
    'Dim x As Long
    'x = 0
    ' Die header Labels manuell positionieren
    Dim headerx As Long
    headerx = LabelHeader1.Left
    
    Dim lab As Label
    
    For i = 0 To count - 1
        'x = x + PXtoPT(columnWidth(order(i)))
        If i > 0 Then
          columnWidths = columnWidths & ";"
        End If
        ' 1.333333333 ermittelt aus der Breite die der Dialog editor anzeigt und wir breit der Dialog in Pixeln wirklich war
        columnWidths = columnWidths & columnWidth(order(i)) / 1.3333333333 'PXtoPT(columnWidth(order(i)))
        columnCount = columnCount + 1
        LabelHeader(i).Left = headerx
        LabelHeader(i).Caption = columnHeader(order(i))
        headerx = headerx + PXtoPT(columnWidth(order(i)))
        m_ColumnWidth(i) = columnWidth(order(i))
        
        If order(i) > 0 And ebeneIdx < nEbene Then
            Dim idx As Long
            idx = order(i) - 1
            If m_EbeneColumn(idx) = "" Then
                LabelFilter(idx).visible = False
                ComboEbene(idx).visible = False
            Else
                LabelFilter(idx).visible = True
                Dim filterIdx As Long
                If m_EbeneColumn(idx) = "Prozessname" Then filterIdx = 1
                If m_EbeneColumn(idx) = "Prozesslandkarte" Then filterIdx = 2
                If m_EbeneColumn(idx) = "Ebene3" Then filterIdx = 3
                LabelFilter(idx).Caption = columnHeader(filterIdx)
                ComboEbene(idx).visible = True
            End If
            ebeneIdx = ebeneIdx + 1
        End If
    Next i
    For i = ebeneIdx To 2
        LabelFilter(i).visible = False
        ComboEbene(i).visible = False
    Next i
    For i = count To 3
        LabelHeader(i).visible = False
    Next i
    
    ' Liefert 8 - zu breit
    'Dim hdc As Long
    'hdc = GetHDC(Prozesse)
    'Dim rc As Helpers.RECT
    'rc = GetMyTextExtents(hdc, "0", 10000)
    'm_AvgCharacterWidth = rc.Right - rc.Left
    
    ' Das funktioniert besser
    m_AvgCharacterWidth = 7
    If m_AvgCharacterWidth <= 0 Then
      m_AvgCharacterWidth = 1
    End If
    
    GetProcesses G_StartupPath & "..\BIN\Processes.txt"
    
    UpdateFilters -1
    
    If G_CfgProzessUnbekanntSichtbar = False Then
      cmdProzessUnbekannt.visible = False
    End If
    
    Prozesse.columnCount = columnCount
    Prozesse.columnWidths = columnWidths '"95;292;200"

    Init = UpdateList
    
    subRemoveCloseButton Me
    
End Function

Private Sub UpdateFilters(idx As Integer)
    If idx > 2 Then
        Exit Sub
    End If
    If idx >= 0 Then
        If ComboEbene(idx).visible = False Then
            Exit Sub
        End If
    End If

    m_DontUpdateComboBoxes = True
    
    Dim sel As String
    sel = ""
    If idx >= 0 Then
        sel = m_EbeneSel(idx)
    End If
        
    Dim i As Long
    
    ' Die Filter-Comboboxen fuellen
    If G_CfgPANoTextfile = True Then
      Dim query As String
      
      Dim rs As Object
      Set rs = CreateObject("ADODB.Recordset")
      Dim filter As String
      For i = 0 To 2
          If m_EbeneColumn(i) <> "" And i > idx Then
              ComboEbene(i).Clear
              'ComboEbene(i).AddItem "Alle"
              ComboEbene(i).AddItem FMT0("MD_17")
              query = "SELECT DISTINCT " & m_EbeneColumn(i) & " FROM gProzessAktuell "
              If i > 0 Then
                  If m_EbeneSel(i - 1) <> "" Then
                      query = query & "WHERE " & m_EbeneColumn(i - 1) & " = '" & m_EbeneSel(i - 1) & "' "
                  End If
              End If
              query = query & "ORDER BY " & m_EbeneColumn(i) & " ASC"
              rs.Open query, m_Conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
              If Not rs Is Nothing Then
                  Do While Not rs.EOF
                      filter = GetSafeFieldPlus(rs, m_EbeneColumn(i), "")
                      If filter <> "" Then
                          ComboEbene(i).AddItem filter
                      End If
                      rs.MoveNext
                  Loop
                  rs.Close
              End If
              
              ' "Alle" vorselektieren
              m_EbeneSel(i) = ""
              ComboEbene(i).ListIndex = 0
              ' Wenn was anderes als "Alle" gewaehlt ist, dann die naechste combobox enablen
              If i = idx + 1 And sel <> "" Then
                  ComboEbene(i).Enabled = True
              ' Die erste aber nie disablen
              ElseIf i > 0 Then
                  ComboEbene(i).Enabled = False
              End If
          End If
      Next i
      Set rs = Nothing
    Else
        For i = 0 To 2
            If m_EbeneColumn(i) <> "" And i > idx Then
                ComboEbene(i).Clear
                'ComboEbene(i).AddItem "Alle"
                ComboEbene(i).AddItem FMT0("MD_17")
                
                Dim c As New Collection
                Dim proz As Variant
                
                For Each proz In m_Processes
                    If Not IsEmpty(proz) Then
                        If Not proz Is Nothing Then
                            Dim Text As String
                            Text = proz.GetColumnFilterText(i, m_EbeneColumn, m_EbeneSel)
                            If Text <> "" Then
                                If Not CollectionStringExists(c, Text) Then
                                    c.add Text, Text
                                End If
                            End If
                        End If
                    End If
                Next
                Call CollectionHelpers.MergeSort(c)
                Dim s As Variant
                For Each s In c
                    If Not IsEmpty(s) Then
                        ComboEbene(i).AddItem s
                    End If
                Next
                Set c = Nothing
                
                ' "Alle" vorselektieren
                m_EbeneSel(i) = ""
                ComboEbene(i).ListIndex = 0
                ' Wenn was anderes als "Alle" gewaehlt ist, dann die naechste combobox enablen
                If i = idx + 1 And sel <> "" Then
                    ComboEbene(i).Enabled = True
                ' Die erste aber nie disablen
                ElseIf i > 0 Then
                    ComboEbene(i).Enabled = False
                End If
            End If
        Next i
    End If
    
    m_DontUpdateComboBoxes = False
End Sub

Function UpdateList() As Boolean
    UpdateList = False
    Prozesse.Clear
    
    m_NumProcessesVisible = 0
    Dim numProcessesSelected As Long
    
    Dim i As Long
    Dim query As String
    Dim prozrs As Object
    Set prozrs = CreateObject("ADODB.Recordset")
    Dim prozcoll As New Collection
    prozrs.Open "SELECT * FROM idvDateienProzess WHERE idvDateiID = " & m_DateiID, m_Conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
    Do While Not prozrs.EOF
        AddStringToCollection prozcoll, GetSafeField(prozrs, "Prozessschluessel"), "O" & GetSafeField(prozrs, "Prozessschluessel")
        prozrs.MoveNext
    Loop
    prozrs.Close
    Set prozrs = Nothing
    
    Dim id As String
    
    If G_CfgPANoTextfile = True Then
      ' Filter beruecksichtigen
      query = "SELECT * FROM gProzessAktuell"
      
      Dim cond As Long
      cond = 0
      For i = 0 To 2
          If m_EbeneSel(i) <> "" Then
              If cond = 0 Then
                  query = query & " WHERE " & m_EbeneColumn(i) & " = '" & m_EbeneSel(i) & "'"
              Else
                  query = query & " AND " & m_EbeneColumn(i) & " = '" & m_EbeneSel(i) & "'"
              End If
              cond = cond + 1
          End If
      Next i
      
      query = query & " ORDER BY "
      For i = 0 To 3
          If m_ColumnOrder(i) <> "" Then
              If i > 0 Then
                  query = query & ", "
              End If
              query = query & m_ColumnOrder(i)
          End If
      Next i
              
      Dim s As String
      Dim w As Long
      Dim textWidth As Long
      Dim n As Long
      Dim item As Long
    
      Dim rs As Object
      Set rs = OpenRS(query, m_Conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
      If Not rs Is Nothing Then
        Do While Not rs.EOF
          UpdateList = True
          Prozesse.AddItem "" 'GetSafeField(rs, m_ColumnOrder(i))
          item = 0
          For i = 0 To 3
              If m_ColumnOrder(i) <> "" Then
                If i = 0 Then
                    id = "O" & GetSafeField(rs, m_ColumnOrder(i))
                End If
                ' Textlaenge gegen die Columnwidth checken, wenn zu lang abschneiden und "..." anhaengen
                w = m_ColumnWidth(i)
                s = GetSafeField(rs, m_ColumnOrder(i))
                If m_ColumnOrder(i) = "Prozessschluessel" Then
                  ' Auf keinen Fall den Key abschneiden, sonst geht das Zuweisen zu idvDateienProzess spaeter nicht!
                Else
                  textWidth = Len(s) * m_AvgCharacterWidth
                  If textWidth > w Then
                    n = (w / m_AvgCharacterWidth) - 2
                    If n < 0 Then n = 0
                    s = Left(s, n) & "|fffd|" ' "..."
                  End If
                End If
              
                Prozesse.List(Prozesse.ListCount - 1, item) = s
                item = item + 1
              End If
          Next i
          m_NumProcessesVisible = m_NumProcessesVisible + 1
          
          If CollectionItemExists(prozcoll, id) Then
            Prozesse.Selected(Prozesse.ListCount - 1) = True
            numProcessesSelected = numProcessesSelected + 1
          End If
'          If prozrs.EOF <> True Or prozrs.BOF <> True Then
'            prozrs.MoveFirst
'            prozrs.Find "Prozessschluessel='" & GetSafeField(rs, "Prozessschluessel") & "'"
'            If Not prozrs.EOF Then
'              Prozesse.Selected(Prozesse.ListCount - 1) = True
'            End If
'          End If
          rs.MoveNext
        Loop
        rs.Close
        Set rs = Nothing
        'prozrs.Close
        'Set prozrs = Nothing
      End If
    Else
        Dim p As Long
        For p = 1 To m_ProcessesSorted.count
            id = CStr(m_ProcessesSorted(p))
            ' Nur anzeigen, wenn nicht ausgefiltert
            If CollectionObjectExists(m_Processes, id) Then
                If m_Processes(id).IsVisible(m_EbeneColumn, m_EbeneSel) Then
                    Prozesse.AddItem "" 'CStr(m_Processes(id).LBText)
                    m_NumProcessesVisible = m_NumProcessesVisible + 1
                    
                    item = 0
                    For i = 0 To 3
                      If m_ColumnOrder(i) <> "" Then
                        w = m_ColumnWidth(i)
                        s = m_Processes(id).GetLBText(i, m_ColumnOrder)
                        If m_ColumnOrder(i) = "Prozessschluessel" Then
                          ' Auf keinen Fall den Key abschneiden, sonst geht das Zuweisen zu idvDateienProzess spaeter nicht!
                        Else
                          textWidth = Len(s) * m_AvgCharacterWidth
                          If textWidth > w Then
                            n = (w / m_AvgCharacterWidth) - 2
                            If n < 0 Then n = 0
                            s = Left(s, n) & "|fffd|" ' "..."
                          End If
                        End If
                        Prozesse.List(Prozesse.ListCount - 1, item) = s
                        item = item + 1
                      End If
                    Next i
                    
                    If CollectionItemExists(prozcoll, id) Then
                        Prozesse.Selected(Prozesse.ListCount - 1) = True
                        numProcessesSelected = numProcessesSelected + 1
                    End If
                End If
            End If
        Next p
        UpdateList = True
    End If
    
    'LabelNumProz.Caption = gTranslation.FormatString("%1 total, %2 sichtbar, %3 selektiert", CStr(m_NumProcessesTotal), CStr(m_NumProcessesVisible), CStr(numProcessesSelected))
    LabelNumProz.Caption = FMT3("PA_11", CStr(m_NumProcessesTotal), CStr(m_NumProcessesVisible), CStr(numProcessesSelected))
End Function

Private Sub BtBack_Click()
  m_Auswahl = -1
  Call PreCloseCleanUp
  Me.Hide
End Sub

Private Sub cmdProzessUnbekannt_Click()
  m_Auswahl = 0
  Call PreCloseCleanUp
  Me.Hide
End Sub

Function GetProzessschluessel(idx As Long) As String
    GetProzessschluessel = Prozesse.List(idx, m_SchluesselColumn)
End Function

Private Sub CalcSchutzbedarfValues()
    If G_Befragung Is Nothing Then Exit Sub
    
    ' Bei Mehrfachselektion, immer das Maximum
    Dim schutzbedValues As New CFragenSchutzbedarf
    
    Dim id As Variant
    
    If G_CfgPANoTextfile = True Then
        ' Aus DB lesen
        Dim keys As String
        For Each id In G_SelectedProzesse
            If Not IsEmpty(id) Then
                If Len(keys) <= 0 Then
                    keys = keys & "'" & CStr(id) & "'"
                Else
                    keys = keys & ",'" & CStr(id) & "'"
                End If
            End If
        Next id
        Dim query As String
        query = "SELECT * from gProzessAktuell WHERE Prozessschluessel in (" & keys & ");"
        
        Dim prozAktuellRs As Object
        Set prozAktuellRs = CreateObject("ADODB.Recordset")
        prozAktuellRs.Open query, m_Conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
        If prozAktuellRs.EOF <> True Or prozAktuellRs.BOF <> True Then
            prozAktuellRs.MoveFirst
            Do While prozAktuellRs.EOF <> True
                Dim temp As New CFragenSchutzbedarf
                temp.value(C_IDVDATFLD_VERTRAULICHKEIT) = GetSafeFieldPlus(prozAktuellRs, "Vertraulichkeit", 0)
                temp.value(C_IDVDATFLD_INTEGRITAET) = GetSafeFieldPlus(prozAktuellRs, "Integritaet", 0)
                temp.value(C_IDVDATFLD_VERFUEGBARKEIT) = GetSafeFieldPlus(prozAktuellRs, "Verfuegbarkeit", 0)
                temp.value(C_IDVDATFLD_INFORMATIONSKLASSE) = GetSafeFieldPlus(prozAktuellRs, "Informationsklassifizierung", 0)
                temp.value(C_IDVDATFLD_AUTHENTIZITAET) = GetSafeFieldPlus(prozAktuellRs, "Authentizitaet", 0)
                Call schutzbedValues.SetMaxValuesPA(temp)
                prozAktuellRs.MoveNext
            Loop
        End If
        prozAktuellRs.Close
        Set prozAktuellRs = Nothing
    Else
        ' Direkt aus dem cache
        Dim Key As String
        For Each id In G_SelectedProzesse
            If Not IsEmpty(id) Then
                Key = "O" & CStr(id)
                If CollectionObjectExists(m_Processes, Key) Then
                    Call schutzbedValues.SetMaxValuesPA(m_Processes(Key).GetSchutzbedarfValues())
                End If
            End If
        Next id
    End If
    
    G_Befragung.ProzessauswahlValues = schutzbedValues
End Sub

Private Sub cmdSelProzesse_Click()
  
  Dim i As Long
  For i = 0 To Prozesse.ListCount - 1
      If Prozesse.Selected(i) Then
        'G_SelectedProzesse.add CStr(Prozesse.List(i, 0))
        G_SelectedProzesse.add GetProzessschluessel(i)
      End If
  Next i
  If G_SelectedProzesse.count <= 0 Then
    'MsgBox "Sie haben keine Prozesse ausgew|fffd|hlt.", vbInformation, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
    MsgBox FMT0("PA_10"), vbInformation, ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")"
    Exit Sub
  Else
    m_Auswahl = 1
    
    ' Die Werte global speichern
    Call CalcSchutzbedarfValues
    Call PreCloseCleanUp
    Me.Hide
  End If
End Sub

Private Sub ComboEbene1_Click()
  If m_DontUpdateComboBoxes Then
      Exit Sub
  End If
  
  If ComboEbene(0).ListIndex <= 0 Then
    m_EbeneSel(0) = ""
  Else
    m_EbeneSel(0) = ComboEbene(0).List(ComboEbene(0).ListIndex)
  End If
  
  UpdateFilters 0
  
  UpdateList
End Sub

Private Sub ComboEbene2_Click()
  If m_DontUpdateComboBoxes Then
      Exit Sub
  End If
  
  If ComboEbene(1).ListIndex <= 0 Then
    m_EbeneSel(1) = ""
  Else
    m_EbeneSel(1) = ComboEbene(1).List(ComboEbene(1).ListIndex)
  End If
  
  UpdateFilters 1
  
  UpdateList
End Sub

Private Sub ComboEbene3_Click()
  If m_DontUpdateComboBoxes Then
      Exit Sub
  End If

  If ComboEbene(2).ListIndex <= 0 Then
    m_EbeneSel(2) = ""
  Else
    m_EbeneSel(2) = ComboEbene(2).List(ComboEbene(2).ListIndex)
  End If
  
  UpdateFilters 2
  
  UpdateList
End Sub

Private Sub UserForm_Initialize()
    gTranslation.TranslateForm Me
    
    Set LabelHeader(0) = LabelHeader1
    Set LabelHeader(1) = LabelHeader2
    Set LabelHeader(2) = LabelHeader3
    Set LabelHeader(3) = LabelHeader4
    Set LabelFilter(0) = LabelFilter1
    Set LabelFilter(1) = LabelFilter2
    Set LabelFilter(2) = LabelFilter3
    Set ComboEbene(0) = ComboEbene1
    Set ComboEbene(1) = ComboEbene2
    Set ComboEbene(2) = ComboEbene3

    Dim logoPath As String
    logoPath = G_Firmenlogo
    If FileExists(logoPath) Then
        Logo.Picture = LoadPicture(logoPath)
        If G_CfgLogoFarbe >= 0 Then
          LogoColor.BackColor = G_CfgLogoFarbe
          Logo.BackColor = G_CfgLogoFarbe
        Else
          LogoColor.visible = False
        End If
    End If
End Sub

Private Sub Prozesse_Change()
  Dim i As Long
  Dim numProcessesSelected As Long
  numProcessesSelected = 0
  For i = 0 To Prozesse.ListCount - 1
    If Prozesse.Selected(i) Then
      numProcessesSelected = numProcessesSelected + 1
    End If
  Next i
  
  'LabelNumProz.Caption = gTranslation.FormatString("%1 total, %2 sichtbar, %3 selektiert", CStr(m_NumProcessesTotal), CStr(m_NumProcessesVisible), CStr(numProcessesSelected))
  LabelNumProz.Caption = FMT3("PA_11", CStr(m_NumProcessesTotal), CStr(m_NumProcessesVisible), CStr(numProcessesSelected))
End Sub

Attribute VB_Name = "frmSchablonenwahl"
Attribute VB_Base = "0{91896E91-2116-49A1-9A41-FD1A9E78D08E}{A83DFE92-C74D-475B-BEA2-0C89680110D3}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public Auswahl As Long
Public AuswahlName As String

Private Sub UserForm_Initialize()
    gTranslation.TranslateForm Me
    Schablone.columnCount = 2
    Schablone.columnWidths = "0;200"
    
End Sub


Private Sub CancelButton_Click()
  Auswahl = -1
  AuswahlName = ""
  Me.Hide
End Sub

Private Sub OkButton_Click()
  Auswahl = -1
  
  If Schablone.ListIndex >= 0 Then
    Auswahl = val(Schablone.List(Schablone.ListIndex, 0))
    AuswahlName = Schablone.List(Schablone.ListIndex, 1)
    SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="EPSchablone", Setting:=G_AuswahlName
  End If
  
  Me.Hide
End Sub

Attribute VB_Name = "frmVersionsauswahl"
Attribute VB_Base = "0{1044A24F-B85B-4CE8-A65F-15493475AA9B}{9260DF9E-7926-44F8-A9BE-F483ED3FA353}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public Auswahl As Long
Public Version As Long
Public idvDateiID As Long

Private Sub UserForm_Initialize()
    gTranslation.TranslateForm Me

    ' IDVDateiID soll nicht mit angezeigt werden
    VersionList.columnCount = 3
    VersionList.columnWidths = "100;0;0"

End Sub

Private Sub cmdAbbruch_Click()
  Auswahl = -1
  Me.Hide
End Sub

Private Sub cmdEFC_Click()
  Auswahl = 0
  Me.Hide
End Sub

Private Sub cmdIOK_Click()
  If VersionList.ListIndex < 0 Then
    'MsgBox "Bitte w|fffd|hlen Sie eine Version aus.", vbInformation
    MsgBox FMT0("VERSIONSAUSW_1"), vbInformation
    Exit Sub
  End If
  
  SetzeVersionAndId
  Me.Hide
End Sub

Private Sub SetzeVersionAndId()
    Dim s() As String
    
    idvDateiID = VersionList.List(VersionList.ListIndex, 2)
    Version = VersionList.List(VersionList.ListIndex, 1)
    
    Auswahl = 1

End Sub


Private Sub VersionList_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
  If VersionList.ListIndex < 0 Then
    'MsgBox "Bitte w|fffd|hlen Sie eine Version aus.", vbInformation
    MsgBox FMT0("VERSIONSAUSW_1"), vbInformation
    Exit Sub
  End If
  
    SetzeVersionAndId
  Me.Hide

End Sub
Attribute VB_Name = "xlHelpers"
Option Explicit

#If VBA7 And Win64 Then
' Done
Declare PtrSafe Function GetCurrentProcessId Lib "kernel32" () As Long
#Else
Declare Function GetCurrentProcessId Lib "kernel32" () As Long
#End If


Function GetCommentRange(oxlwsheet)
  Set GetCommentRange = Nothing
'  Application.DisplayAlerts = False
  On Error Resume Next
  Set GetCommentRange = oxlwsheet.Cells.SpecialCells(xlCellTypeComments)
'  Application.DisplayAlerts = CurrentDisplayAlerts
End Function


Function CommentExists(ByRef c As Range) As Boolean
  Dim s As String
  On Error GoTo doesntExist
  s = c.comment.Text
  CommentExists = True
  Exit Function
doesntExist:
End Function

Function WorkbookExists(ByRef xlapp, wbname As String) As Boolean
  On Error GoTo nogo
  Dim wb As Workbook
'  Set wb = Workbooks(wbname)
  
  For Each wb In xlapp.Workbooks
    If UCase(wb.name) = UCase(wbname) Then
      WorkbookExists = True
      Exit Function
    End If
  Next wb
  Set wb = Nothing
  Exit Function
nogo:
End Function

Function WorkbookExistsByFilename(ByRef xlapp, wbname As String) As Boolean
  Dim wb As Workbook
  For Each wb In xlapp.Workbooks
    If UCase(wb.fullname) = UCase(wbname) Then
      WorkbookExistsByFilename = True
      Exit Function
    End If
  Next wb
  Exit Function
End Function

Function CriticalAddinExists(ByRef xlapp As Excel.Application) As Boolean
    If CriticalAddinExistsXLA(xlapp) Then
      CriticalAddinExists = True
    End If
    If CriticalAddinExistsDLL(xlapp) Then
      CriticalAddinExists = True
    End If
    Exit Function
End Function


Private Function GetVBAProjectFilename(v) As String
  On Error Resume Next
  GetVBAProjectFilename = ""
  GetVBAProjectFilename = GetFileNameAndExtension(v.filename)
End Function
Private Function GetVBAProjectName(v) As String
  On Error Resume Next
  GetVBAProjectName = ""
  GetVBAProjectName = v.name
End Function
Private Function GetVBAProjectDescription(v) As String
  On Error Resume Next
  GetVBAProjectDescription = ""
  GetVBAProjectDescription = v.Description
End Function

' F|fffd|r XLAM und CO
Function CriticalAddinExistsXLA(ByRef xlapp As Excel.Application) As Boolean
    On Error GoTo nogo
    CriticalAddinExistsXLA = False
    
    If G_CriticalAddins = "" Then Exit Function
    
    Dim v
    For Each v In xlapp.vbe.VBProjects
      If GetVBAProjectFilename(v) <> "" Then
        If InStr(UCase(G_CriticalAddins), UCase(GetVBAProjectFilename(v))) > 0 Then
          CriticalAddinExistsXLA = True
          Exit Function
        End If
      End If
      If GetVBAProjectName(v) <> "" Then
        If InStr(UCase(G_CriticalAddins), UCase(GetVBAProjectName(v))) > 0 Then
          CriticalAddinExistsXLA = True
          Exit Function
        End If
      End If
      If GetVBAProjectDescription(v) <> "" Then
        If InStr(UCase(G_CriticalAddins), UCase(GetVBAProjectDescription(v))) > 0 Then
          CriticalAddinExistsXLA = True
          Exit Function
        End If
      End If
      Dim a
    Next v
    Exit Function
nogo:
End Function

' f|fffd|r DLL
Function CriticalAddinExistsDLL(ByRef xlapp As Excel.Application) As Boolean
    On Error GoTo nogo
    CriticalAddinExistsDLL = False
    
    If G_CriticalAddins = "" Then Exit Function
    
    Dim s() As String
    s = Split(G_CriticalAddins, ",")
    Dim i As Long
    Dim a
    For i = LBound(s) To UBound(s)
        Dim oCOMAddin As COMAddIn
        For Each oCOMAddin In Application.COMAddIns
            If UCase(oCOMAddin.progID) = UCase(s(i)) Or UCase(oCOMAddin.Description) = UCase(s(i)) Then
              CriticalAddinExistsDLL = True
              Exit Function
            End If
        Next oCOMAddin
    Next i
    
    Exit Function
nogo:
End Function



Function GetMemUsage()
  
  ' Returns the current Excel.Application
  ' memory usage in MB
  Dim objSWbemServices
  Set objSWbemServices = GetObject("winmgmts:")
  GetMemUsage = objSWbemServices.Get( _
    "Win32_Process.Handle='" & _
    GetCurrentProcessId & "'").WorkingSetSize / 1024
    
  Set objSWbemServices = Nothing
  
End Function

Attribute VB_Name = "xlaApp"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public WithEvents xlapp As Excel.Application
Attribute xlapp.VB_VarHelpID = -1

Private WithEvents DokuButton As Office.CommandBarButton
Attribute DokuButton.VB_VarHelpID = -1
Private WithEvents DokuButtonAcc As Office.CommandBarButton
Attribute DokuButtonAcc.VB_VarHelpID = -1
Private WithEvents RisikoFragenButton As Office.CommandBarButton
Attribute RisikoFragenButton.VB_VarHelpID = -1
Private WithEvents AmpelButton As Office.CommandBarButton
Attribute AmpelButton.VB_VarHelpID = -1
Private WithEvents NewVersionButton As Office.CommandBarButton
Attribute NewVersionButton.VB_VarHelpID = -1
Private WithEvents FreigabeButton As Office.CommandBarButton
Attribute FreigabeButton.VB_VarHelpID = -1
Private WithEvents MeineDateienListeButton As Office.CommandBarButton
Attribute MeineDateienListeButton.VB_VarHelpID = -1
Private WithEvents ECCButton As Office.CommandBarButton
Attribute ECCButton.VB_VarHelpID = -1
Private WithEvents EPButton As Office.CommandBarButton
Attribute EPButton.VB_VarHelpID = -1
Private WithEvents EFCButton As Office.CommandBarButton
Attribute EFCButton.VB_VarHelpID = -1
Private WithEvents ESQAButton As Office.CommandBarButton
Attribute ESQAButton.VB_VarHelpID = -1
Private WithEvents FreigabeAbschliessenButton As Office.CommandBarButton
Attribute FreigabeAbschliessenButton.VB_VarHelpID = -1
Private WithEvents SignOffButton As Office.CommandBarButton
Attribute SignOffButton.VB_VarHelpID = -1
Private WithEvents DateiberechtigungButton As Office.CommandBarButton
Attribute DateiberechtigungButton.VB_VarHelpID = -1
Private WithEvents DateiOeffnenButton As Office.CommandBarButton
Attribute DateiOeffnenButton.VB_VarHelpID = -1
Private WithEvents LockButton As Office.CommandBarButton
Attribute LockButton.VB_VarHelpID = -1
Private WithEvents UnlockButton As Office.CommandBarButton
Attribute UnlockButton.VB_VarHelpID = -1
Private WithEvents DokuInWordButton As Office.CommandBarButton
Attribute DokuInWordButton.VB_VarHelpID = -1
Private WithEvents TestareaButton As Office.CommandBarButton
Attribute TestareaButton.VB_VarHelpID = -1
Private WithEvents InfoButton As Office.CommandBarButton
Attribute InfoButton.VB_VarHelpID = -1
Private WithEvents AppInfoButton As Office.CommandBarButton
Attribute AppInfoButton.VB_VarHelpID = -1

Private AddInMenuBar As Office.CommandBar


Private L_ShowSaveAsDialog As Boolean

Public Major As Long
Public Minor As Long
Public Revision As Long
Public path As String

Private Sub Class_Initialize()
  path = ThisWorkbook.path
  Major = 3
  Minor = 0
  Revision = MyInternalVersion
End Sub

Function ActiveWorkbook() As Workbook
  Set ActiveWorkbook = Application.ActiveWorkbook
End Function

Private Sub xlApp_WorkbookOpen(ByVal wb As Excel.Workbook)
    If UCase(wb.name) = "EXCELTRACKER.XLA" Or UCase(wb.name) = "EXCELTRACKER.XLS" Or UCase(wb.name) = "EXCELTRACKER.XLSM" Or UCase(wb.name) = "EXCELTRACKER.XLAM" Then
       Exit Sub
    End If
    WorkbookOpen xlapp, wb
    If Not wb Is Nothing Then
        'SetzeAmpelStatusOhneConnection wb
        'InvalidateRibbon
        'SetFreigabeButtonTooltip wb
    End If
End Sub

Private Sub xlApp_WorkbookActivate(ByVal wb As Excel.Workbook)
    
    If Not wb Is Nothing Then
      ' Wenn wir zu einem Macro-Enabled-Workbook wechseln, sofort alle Hooks disablen!
      If wb.IsAddin = True Then
          ReleaseHooks
      End If
      If wb.FileFormat = xlAddIn Or wb.FileFormat = xlAddIn8 Or wb.FileFormat = xlIntlAddIn Or _
          wb.FileFormat = xlOpenXMLAddIn Or wb.FileFormat = xlIntlMacro Or _
          wb.FileFormat = xlOpenXMLTemplateMacroEnabled Or wb.FileFormat = xlOpenXMLWorkbookMacroEnabled Then
          ReleaseHooks
      End If
    End If
    
    WorkbookActivate xlapp, wb
    ' SetzeAmpelStatusOhneConnection wb
    InvalidateRibbon
    SetFreigabeButtonTooltip wb
End Sub

Private Sub xlApp_WorkbookBeforeClose(ByVal wb As Excel.Workbook, ByRef Cancel As Boolean)
    WorkbookBeforeClose xlapp, wb, Cancel
End Sub

Private Sub xlApp_WorkbookBeforePrint(ByVal wb As Excel.Workbook, Cancel As Boolean)
    WorkbookBeforePrint xlapp, wb, Cancel
End Sub
    
Private Sub xlapp_NewWorkbook(ByVal wb As Excel.Workbook)

  If WBValueSet(wb, "_IDVTrackerID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix) = False Then
      WBSetValueLong wb, "_IDVTrackerID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, -100
      WBSetValueLong wb, "_IDVTrackerVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, -1
      WBSetValueLong wb, "_IDVTrackerMajorVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, 1
      WBSetValueLong wb, "_IDVTrackerMinorVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, 0
      WBSetValueLong wb, "_IDVTrackerFreigabeStatus" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, 0
      WBSetValueLong wb, "_IDVTrackerFreigabeDateiID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, -1
      WBSetValueLong wb, "_IDVTrackerFreigabeVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, -1
      wb.saved = True
  End If
  InvalidateRibbon
End Sub

Private Sub xlApp_WorkbookBeforeSave(ByVal wb As Excel.Workbook, ByVal SaveAsUI As Boolean, Cancel As Boolean)
    If G_DateiberechtigungenSave Then
      Cancel = False
      Exit Sub
    End If
    If UCase(wb.name) = "EXCELTRACKER.XLA" Or UCase(wb.name) = "EXCELTRACKER.XLS" Or UCase(wb.name) = "EXCELTRACKER.XLSM" Or UCase(wb.name) = "EXCELTRACKER.XLAM" Then
       Exit Sub
    End If
    
    If G_NoSave Then Exit Sub
    
    WorkbookBeforeSave xlapp, wb, SaveAsUI, Cancel
    
    If G_cfgDatenschutzhinweisAus Then
      On Error Resume Next
      DatenschutzhinweisAus wb
    End If
End Sub


Private Sub AmpelButton_Click(ByVal ctrl As Office.CommandBarButton, CancelDefault As Boolean)
  If G_UserOnOff Then
    If G_NoSave Then
      'MsgBox "Das Plugin ist w|fffd|hrend des Speichervorgangs aktiviert!", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Major & "-" & app.Minor & "-" & MyInternalVersion & ")"
      MsgBox FMT0("XLAAPP_1"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Major & "-" & app.Minor & "-" & MyInternalVersion & ")"
      G_NoSave = False
    Else
      'MsgBox "Das Plugin ist w|fffd|hrend des Speichervorgangs deaktiviert", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Major & "-" & app.Minor & "-" & MyInternalVersion & ")"
      MsgBox FMT0("XLAAPP_2"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Major & "-" & app.Minor & "-" & MyInternalVersion & ")"
      G_NoSave = True
    End If
  End If
End Sub

Private Sub DokuButton_Click(ByVal ctrl As Office.CommandBarButton, CancelDefault As Boolean)
    DokuButton_C xlapp, ctrl, CancelDefault
End Sub

Private Sub RisikoFragenButton_Click(ByVal ctrl As Office.CommandBarButton, CancelDefault As Boolean)
    RisikoFragenButton_C xlapp, ctrl, CancelDefault
    SetFreigabeButtonTooltip xlapp.ActiveWorkbook
End Sub


Private Sub NewVersionButton_Click(ByVal ctrl As Office.CommandBarButton, CancelDefault As Boolean)
    NewVersionButton_C xlapp, ctrl, CancelDefault
    SetFreigabeButtonTooltip xlapp.ActiveWorkbook
End Sub

Private Sub FreigabeButton_Click(ByVal ctrl As Office.CommandBarButton, CancelDefault As Boolean)
    FreigabeButton_C xlapp, ctrl, CancelDefault
    SetFreigabeButtonTooltip xlapp.ActiveWorkbook
End Sub


Private Sub MeineDateienListeButton_Click(ByVal ctrl As Office.CommandBarButton, CancelDefault As Boolean)
    MeineDateienListeButton_C xlapp, ctrl, CancelDefault
End Sub

Private Sub ECCButton_Click(ByVal ctrl As Office.CommandBarButton, CancelDefault As Boolean)
    ECCButton_C xlapp, ctrl, CancelDefault
End Sub

Private Sub ESQAButton_Click(ByVal ctrl As Office.CommandBarButton, CancelDefault As Boolean)
  ESQAButton_C xlapp, ctrl, CancelDefault
End Sub


Private Sub EFCButton_Click(ByVal ctrl As Office.CommandBarButton, CancelDefault As Boolean)
    EFCButton_C xlapp, ctrl, CancelDefault
End Sub


Private Sub FreigabeAbschliessenButton_Click(ByVal ctrl As Office.CommandBarButton, CancelDefault As Boolean)
  FreigabeAbschliessenButton_C xlapp, ctrl, CancelDefault
  SetFreigabeButtonTooltip xlapp.ActiveWorkbook
End Sub

Private Sub EPButton_Click(ByVal ctrl As Office.CommandBarButton, CancelDefault As Boolean)
    EPButton_C xlapp, ctrl, CancelDefault
End Sub

Public Sub SignOffButton_Click(ByVal ctrl As Office.CommandBarButton, CancelDefault As Boolean)

    SignOffButton_C xlapp, ctrl, CancelDefault

End Sub

Public Sub DateiberechtigungButton_Click(ByVal ctrl As Office.CommandBarButton, CancelDefault As Boolean)

    Dateiberechtigung_C xlapp, CancelDefault

End Sub

Public Sub DateiOeffnenButton_Click(ByVal ctrl As Office.CommandBarButton, CancelDefault As Boolean)

    DateiOeffnen_C xlapp, CancelDefault

End Sub

Public Sub LockButton_Click(ByVal ctrl As Office.CommandBarButton, CancelDefault As Boolean)
    Lock_C xlapp, CancelDefault

End Sub
Public Sub UnlockButton_Click(ByVal ctrl As Office.CommandBarButton, CancelDefault As Boolean)

    Unlock_C xlapp, CancelDefault

End Sub
Public Sub DokuInWordButton_Click(ByVal ctrl As Office.CommandBarButton, CancelDefault As Boolean)

    DokuInWord_C xlapp, CancelDefault

End Sub

Public Sub InfoButton_Click(ByVal ctrl As Office.CommandBarButton, CancelDefault As Boolean)

    Info_C xlapp, CancelDefault

End Sub

Public Sub AppInfoButton_Click(ByVal ctrl As Office.CommandBarButton, CancelDefault As Boolean)

    AppInfo_C xlapp, CancelDefault

End Sub


#If Ribbons = 1 Then
Public Function Ribbon_Load(ribbonUI As Object)  ' Office.IRibbonUI
       Set ribbon = ribbonUI
End Function

Public Function OnAction(ByVal control As Object)

    Dim CancelDefault As Boolean
    
    Select Case control.id
        Case "buttonAmpel"
#If Project_ExcelTracker = 1 Then
          If G_UserOnOff Then
            If G_NoSave Then
              'MsgBox "Das Plugin ist w|fffd|hrend des Speichervorgangs aktiviert!", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Major & "-" & app.Minor & "-" & MyInternalVersion & ")"
              MsgBox FMT0("XLAAPP_1"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Major & "-" & app.Minor & "-" & MyInternalVersion & ")"
              G_NoSave = False
            Else
              'MsgBox "Das Plugin ist w|fffd|hrend des Speichervorgangs deaktiviert!", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Major & "-" & app.Minor & "-" & MyInternalVersion & ")"
              MsgBox FMT0("XLAAPP_2"), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion & " (Build: " & app.Major & "-" & app.Minor & "-" & MyInternalVersion & ")"
              G_NoSave = True
            End If
          End If
#End If
        Case "buttonRisikobewertung"
            RisikoFragenButton_C xlapp, Nothing, CancelDefault
        Case "buttonDoku"
            DokuButton_C xlapp, Nothing, CancelDefault
        Case "buttonNeueVersion"
            NewVersionButton_C xlapp, Nothing, CancelDefault
        Case "buttonFreigabe"
            FreigabeButton_C xlapp, Nothing, CancelDefault
        Case "buttonMeineDateien"
            ZeigeMeineDateienListe xlapp, xlapp.ActiveWorkbook, 1
        Case "buttonECC"
          ECCButton_C xlapp, Nothing, CancelDefault
        Case "buttonESQA"
          ESQAButton_C xlapp, Nothing, CancelDefault
        Case "buttonEFC"
          EFCButton_C xlapp, Nothing, CancelDefault
        Case "buttonFreigabeAbschliessen"
          FreigabeAbschliessenButton_C xlapp, Nothing, CancelDefault
        Case "buttonEP"
          EPButton_C xlapp, Nothing, CancelDefault
        Case "buttonSignOff"
          SignOffButton_C xlapp, Nothing, CancelDefault
        Case "buttonDateiberechtigung"
          Dateiberechtigung_C xlapp, CancelDefault
        Case "buttonDateiOeffnen"
          DateiOeffnen_C xlapp, CancelDefault
        Case "buttonLock"
          Lock_C xlapp, CancelDefault
        Case "buttonUnlock"
          Unlock_C xlapp, CancelDefault
        Case "buttonDokuInWord"
          DokuInWord_C xlapp, CancelDefault
        Case "buttonInfo"
          Info_C xlapp, CancelDefault
        Case "buttonAppInfo"
          AppInfo_C xlapp, CancelDefault

    End Select
    InvalidateRibbon
End Function

Public Sub InvalidateRibbon()
    If Not ribbon Is Nothing Then
        ribbon.Invalidate
    End If
End Sub

Public Function OnEnabled(ByVal control As Object)
    OnEnabled = True
End Function

Public Function OnVisible(ByVal control As Object)
    OnVisible = True
End Function


Public Function IRibbonExtensibility_GetCustomUI(ByVal RibbonID As String) As String

  If G_PARAM_Ribbons = False Or G_PARAM_Menueleiste = False Then Exit Function

 'Parse the XML to the Ribbon.
 On Error GoTo rolf
 IRibbonExtensibility_GetCustomUI = CreateXML ' GetRibbonXML("C:\mywork\norman\ExcelTracker.VB6\gui.xml")  ' App.path & "\gui.xml")
    Exit Function
rolf:
    Debug.Print err.Description

End Function


Public Function GetScreentip(ByVal control As Object) As String
    Dim faceId As Long
    Dim toolTipText As String

'    MsgBox control.id
    GetAmpelStatusFaceId xlapp.ActiveWorkbook, faceId, toolTipText
    
    GetScreentip = toolTipText
End Function



Public Function getImage(ByVal control As Object) As IPictureDisp

 'The bmp files are added to a resource file.
 'In general it's not recommended to use the default value references for the bitmaps
 'in the resource file.
 
    Dim faceId As Long
    Dim toolTipText As String
    On Error GoTo errorF

    Select Case control.id
    Case "buttonAmpel"
    
        GetAmpelStatusFaceId xlapp.ActiveWorkbook, faceId, toolTipText

        If faceId = 926 Then
           Set getImage = LoadResPicture("AMPELNICHTGESPEICHERT", vbResBitmap)
        ElseIf faceId = 345 Then
           Set getImage = LoadResPicture("AMPELNICHTRISIKOBEFRAGT", vbResBitmap)
        ElseIf faceId = 352 Then
           Set getImage = LoadResPicture("AMPELFREIGABECHECKSUMME", vbResBitmap)
        ElseIf faceId = 343 Then
           Set getImage = LoadResPicture("AMPELERHOEHT", vbResBitmap)
        ElseIf faceId = 394 Then
           Set getImage = LoadResPicture("AMPELFREIGEGEBEN", vbResBitmap)
        ElseIf faceId = 342 Then
           Set getImage = LoadResPicture("AMPELGERING", vbResBitmap)
        ElseIf faceId = 346 Then
           Set getImage = LoadResPicture("FREIGABEINITIIERUNG", vbResBitmap)
        End If
    
    Case "buttonRisikobewertung"
       Set getImage = LoadResPicture("RISIKOBEFRAGUNG", vbResBitmap)
    Case "buttonDoku"
       Set getImage = LoadResPicture("DOKU", vbResBitmap)
    Case "buttonNeueVersion"
      Set getImage = LoadResPicture("NEUEVERSION", vbResBitmap)
    Case "buttonFreigabe"
      Set getImage = LoadResPicture("FREIGABEINITIIERUNG", vbResBitmap)
    Case "buttonMeineDateien"
      Set getImage = LoadResPicture("MEINEDATEIEN", vbResBitmap)
    Case "buttonECC"
      Set getImage = LoadResPicture("ECC", vbResBitmap)
    Case "buttonEP"
      Set getImage = LoadResPicture("PROTECT", vbResBitmap)
    Case "buttonFreigabeAbschliessen"
      Set getImage = LoadResPicture("FREIGABEERTEILEN", vbResBitmap)
    Case "buttonEFC"
      Set getImage = LoadResPicture("EFC", vbResBitmap)
    Case "buttonESQA"
      Set getImage = LoadResPicture("ESQA", vbResBitmap)
    Case "buttonSignOff"
      Set getImage = LoadResPicture("SIGNOFF", vbResBitmap)
    Case "buttonDateiberechtigung"
      Set getImage = LoadResPicture("BERECHTIGUNG", vbResBitmap)
    Case "buttonDateiOeffnen"
      Set getImage = LoadResPicture("DATEIOEFFNEN", vbResBitmap)
    Case "buttonLock"
      Set getImage = LoadResPicture("LOCK", vbResBitmap)
    Case "buttonUnlock"
      Set getImage = LoadResPicture("LOCKOPEN", vbResBitmap)
    Case "buttonDokuInWord"
      Set getImage = LoadResPicture("DOKUINWORD", vbResBitmap)
    Case "buttonInfo"
      Set getImage = LoadResPicture("INFO", vbResBitmap)
    
   End Select
   Exit Function

errorF:
    'MsgBox "Error " & err.Description
'    MsgBox FMT1("XLAAPP_3", err.Description)

End Function

Private Function CreateXMLButton(ByVal butName As String, ByVal butText As String, ByVal tooltip As String, ByVal iconid As String) As String

     CreateXMLButton = "   <button id=" & Chr$(34) & "button" & butName & Chr$(34) & Chr$(13) & Chr$(10) _
     & " label = " & Chr$(34) & butText & Chr$(34) & Chr$(13) & Chr$(10) _
     & IIf(tooltip <> "", " screentip = " & Chr$(34) & tooltip, " getScreentip = " & Chr$(34) & "GetScreentip") & Chr$(34) & Chr$(13) & Chr$(10) _
     & " getImage = " & Chr$(34) & "GetImage" & Chr$(34) & Chr$(13) & Chr$(10) _
     & " size = " & Chr$(34) & "large" & Chr$(34) & Chr$(13) & Chr$(10) _
     & " onAction = " & Chr$(34) & "OnAction" & Chr$(34) & Chr$(13) & Chr$(10) _
     & " getEnabled = " & Chr$(34) & "OnEnabled" & Chr$(34) & "/>" & Chr$(13) & Chr$(10)

End Function

Public Function CreateXML() As String
  
    Dim xml As String
    xml = ""
    
        If G_PARAM_Ampel Then
            'xml = CreateXMLButton("Ampel", "Status", "", "GetImage")
            xml = CreateXMLButton("Ampel", FMT0("UICALLB_7"), "", "GetImage")
        End If
        
        Dim reihenfolge(17) As Integer
        reihenfolge(1) = G_PARAM_ReihenfolgeRisikobewertung
        reihenfolge(2) = G_PARAM_ReihenfolgeDokumentation
        reihenfolge(3) = G_PARAM_ReihenfolgeVersionierung
        reihenfolge(4) = G_PARAM_ReihenfolgeFreigabeInit
        reihenfolge(5) = G_PARAM_ReihenfolgeDateiliste
        reihenfolge(6) = G_PARAM_ReihenfolgeProtect
        reihenfolge(7) = G_PARAM_ReihenfolgeScanner
        reihenfolge(8) = G_PARAM_ReihenfolgeFreigabeAbschliessen
        reihenfolge(9) = G_PARAM_ReihenfolgeEFC
        reihenfolge(10) = G_PARAM_ReihenfolgeESQA
        reihenfolge(11) = G_PARAM_ReihenfolgeBerechtigungen
        reihenfolge(12) = G_PARAM_ReihenfolgeDateiOeffnen
        reihenfolge(13) = G_PARAM_ReihenfolgeLock
        reihenfolge(14) = G_PARAM_ReihenfolgeUnLock
        reihenfolge(15) = G_PARAM_ReihenfolgeDokuInWordIcon
        reihenfolge(16) = G_PARAM_ReihenfolgeSignOff
        reihenfolge(17) = G_PARAM_ReihenfolgeAppInfo
        ' jetzt laufen wir 5 mal durch und suchen immer den naechsten Button,
        ' der hinzugefuegt werden muss. Bestimmt wird es duch den Wert, der
        ' in der Datenbank angegeben wird (Sortierung von klein nach gross)
        Dim bu As Integer
        For bu = 1 To 17
        
           ' mit kleinstem Wert beginnen
           Dim minWert As Integer
           Dim minR As Integer
           minWert = reihenfolge(1)
           minR = 1
           Dim r As Integer
           For r = 2 To 17
               If reihenfolge(r) < minWert Then
                   minWert = reihenfolge(r)
                   minR = r
               End If
           Next
           
           reihenfolge(minR) = 1001
           
           Dim buttonString As String
           buttonString = ""
           
           Select Case minR
            Case 1
                If G_PARAM_ReihenfolgeRisikobewertung >= 0 Then
                  'buttonString = CreateXMLButton("Risikobewertung", "Risiko- befragung", "Risikobefragung durchf|fffd|hren.", "GetImage")
                  buttonString = CreateXMLButton("Risikobewertung", FMT0("XLAAPP_4"), FMT0("XLAAPP_5"), "GetImage")
                End If
            Case 2
                If G_PARAM_ReihenfolgeDokumentation >= 0 Then
                  'buttonString = CreateXMLButton("Doku", "Doku", "Dokumentation der Datei", "GetImage")
                  buttonString = CreateXMLButton("Doku", FMT0("XLAAPP_26"), FMT0("XLAAPP_8"), "GetImage")
                End If
            Case 3
                If G_PARAM_ReihenfolgeVersionierung >= 0 Then
                  'buttonString = CreateXMLButton("NeueVersion", "Neue Version", "Neue Version", "GetImage")
                  buttonString = CreateXMLButton("NeueVersion", FMT0("XLAAPP_9"), FMT0("XLAAPP_9"), "GetImage")
                End If
            Case 4
                If G_PARAM_ReihenfolgeFreigabeInit >= 0 Then
                  'buttonString = CreateXMLButton("Freigabe", "Freigabe initiieren", "Freigabe initiieren / Freigabe aufheben + Version erh|fffd|hen", "GetImage")
                  buttonString = CreateXMLButton("Freigabe", FMT0("STARTUPTIMER_9"), FMT0("XLAAPP_10"), "GetImage")
                End If
            Case 5
                If G_PARAM_ReihenfolgeDateiliste >= 0 Then
                  'buttonString = CreateXMLButton("MeineDateien", "Meine Dateien", "Liste 'meiner' Dateien", "GetImage")
                  buttonString = CreateXMLButton("MeineDateien", FMT0("MD_12"), FMT0("XLAAPP_15"), "GetImage")
                End If
            Case 6
                If G_PARAM_ReihenfolgeProtect >= 0 Then
                  If GetEP() <> "" Then
                      'buttonString = CreateXMLButton("EP", "ExcelProtect", "ExcelProtect f|fffd|r diese Datei aufrufen", "GetImage")
                      buttonString = CreateXMLButton("EP", FMT0("XLAAPP_27"), FMT0("XLAAPP_17"), "GetImage")
                  End If
                End If
            Case 7
                If G_PARAM_ReihenfolgeScanner >= 0 Then
                  If GetECC() <> "" Then
                      'buttonString = CreateXMLButton("ECC", "ECC", "Excel-Sheet-Checker f|fffd|r diese Datei aufrufen", "GetImage")
                      buttonString = CreateXMLButton("ECC", FMT0("XLAAPP_28"), FMT0("XLAAPP_16"), "GetImage")
                  End If
                End If
            Case 8
                If G_PARAM_ReihenfolgeEFC >= 0 Then
                  If GetEFC() <> "" Then
                      'buttonString = CreateXMLButton("EFC", "Excel File Compare", "Excel-File-Compare aufrufen", "GetImage")
                      buttonString = CreateXMLButton("EFC", FMT0("XLAAPP_29"), FMT0("XLAAPP_18"), "GetImage")
                  End If
                End If
            Case 9
                If G_PARAM_ReihenfolgeESQA >= 0 Then
                  If GetESQA() <> "" Then
                    'buttonString = CreateXMLButton("ESQA", "Excel-Sheet-QA", "Excel-Sheet-QA aufrufen", "GetImage")
                    buttonString = CreateXMLButton("ESQA", FMT0("XLAAPP_30"), FMT0("XLAAPP_19"), "GetImage")
                  End If
                End If
            Case 10
                If G_PARAM_ReihenfolgeFreigabeAbschliessen >= 0 Then
                  If GetECC() <> "" Then
                      'buttonString = CreateXMLButton("FreigabeAbschliessen", "Freigabe erteilen", "Programmfreigabe erteilen", "GetImage")
                      buttonString = CreateXMLButton("FreigabeAbschliessen", FMT0("XLAAPP_31"), FMT0("XLAAPP_12"), "GetImage")
                  End If
                End If
            Case 11
                If G_PARAM_ReihenfolgeBerechtigungen >= 0 Then
                  'buttonString = CreateXMLButton("Dateiberechtigung", "Datei- Berechtigung", "Dateiberechtigung anbringen / entfernen", "GetImage")
                  buttonString = CreateXMLButton("Dateiberechtigung", FMT0("XLAAPP_32"), FMT0("XLAAPP_33"), "GetImage")
                End If
            Case 12
                If G_PARAM_ReihenfolgeDateiOeffnen >= 0 Then
                  'buttonString = CreateXMLButton("DateiOeffnen", "Datei |fffd|ffnen", "|fffd|ffnet Dateien mit Berechtigungen", "GetImage")
                  buttonString = CreateXMLButton("DateiOeffnen", FMT0("XLAAPP_21"), FMT0("XLAAPP_34"), "GetImage")
                End If
            Case 13
                If G_PARAM_ReihenfolgeLock >= 0 Then
                  'buttonString = CreateXMLButton("Lock", "Blattschutz anbringen", "Blattschutz anbringen", "GetImage")
                  buttonString = CreateXMLButton("Lock", FMT0("XLAAPP_22"), FMT0("XLAAPP_22"), "GetImage")
                End If
            Case 14
                If G_PARAM_ReihenfolgeUnLock >= 0 Then
                  'buttonString = CreateXMLButton("Unlock", "Blattschutz entfernen", "Blattschutz entfernen", "GetImage")
                  buttonString = CreateXMLButton("Unlock", FMT0("XLAAPP_23"), FMT0("XLAAPP_23"), "GetImage")
                  
                End If
            Case 15
                If G_PARAM_ReihenfolgeDokuInWordIcon >= 0 Then
                  'buttonString = CreateXMLButton("DokuInWord", "Doku in Word", "Doku in Word anzeigen", "GetImage")
                  buttonString = CreateXMLButton("DokuInWord", FMT0("DOKULIST_4"), FMT0("XLAAPP_13"), "GetImage")
                End If
            Case 16
                If G_PARAM_ReihenfolgeSignOff >= 0 Then
                    'buttonString = CreateXMLButton("SignOff", "Excel Sign-Off", "Sign-Off", "GetImage")
                    buttonString = CreateXMLButton("SignOff", FMT0("XLAAPP_35"), FMT0("XLAAPP_24"), "GetImage")
                End If
            Case 17
                If G_PARAM_ReihenfolgeAppInfo >= 0 Then
                    'buttonString = CreateXMLButton("SignOff", "Excel Sign-Off", "Sign-Off", "GetImage")
                    buttonString = CreateXMLButton("AppInfo", FMT0("XLAAPP_37"), FMT0("XLAAPP_37"), "GetImage")
                End If
            End Select
                
            xml = xml & buttonString

          Next bu


'          If G_PARAM_ReihenfolgeBerechtigungen >= 0 Then
'            buttonString = CreateXMLButton("Dateiberechtigung", "Datei- berechtigung", "Dateiberechtigung vergeben", "GetImage")
'            xml = xml & buttonString
'            buttonString = CreateXMLButton("DateiOeffnen", "Datei |fffd|ffnen", "Datei |fffd|ffnen", "GetImage")
'            xml = xml & buttonString
'          End If

    CreateXML = "<customUI xmlns=" & Chr$(34) & "http://schemas.microsoft.com/office/2006/01/customui" & Chr$(34) & " onLoad=" & Chr$(34) & "Ribbon_Load" & Chr$(34) & "> " & Chr$(13) & Chr$(10) _
                & " <ribbon startFromScratch=" & Chr$(34) & "false" & Chr$(34) & " >" & Chr$(13) & Chr$(10) _
                & " <tabs> " & Chr$(13) & Chr$(10) _
                & " <tab id=" & Chr$(34) & "ExcelTracker.Tab" & Chr$(34) & " label=" & Chr$(34) & "ExcelTracker" & Chr$(34) & " visible=" & Chr$(34) & "1" & Chr$(34) & "> " & Chr$(13) & Chr$(10) _
                & " <group id=" & Chr$(34) & "ExcelTracker.Group" & Chr$(34) & " label=" & Chr$(34) & "ExcelTracker Toolset" & Chr$(34) & " visible=" & Chr$(34) & "1" & Chr$(34) & "> " & Chr$(13) & Chr$(10) _
                & xml _
                & "  </group> " & Chr$(13) & Chr$(10) & " </tab> " & Chr$(13) & Chr$(10) & "  </tabs>" & Chr$(13) & Chr$(10) & " </ribbon> " & Chr$(13) & Chr$(10) & " </customUI>"
                
                

End Function
#End If

Function CheckAusschluss(ByRef wb As Excel.Workbook, ByRef conn As Object) As Boolean
  CheckAusschluss = DateiAusgeschlossen2(wb, conn)
End Function

Sub Init()
    Set app.xlapp = Excel.Application
    
    MyHWND = app.xlapp.hwnd
    
'    If UCase(ThisWorkbook.name) = "EXCELTRACKER.XLA" Or UCase(ThisWorkbook.name) = "EXCELTRACKER.XLS" Then
'       Exit Sub
'    End If
    
    On Error GoTo error_handler
    
    Dim wb As Workbook
    
    G_UserDeaktiviert = False
    
    If GetSetting(appname:="Stromwerken", Section:="ExcelTracker", Key:="IgnoreThisOne", Default:="False") = "True" Then
       SaveSetting appname:="Stromwerken", Section:="ExcelTracker", Key:="IgnoreThisOne", Setting:="False"
       Exit Sub
    End If
    
    If G_NoStartup Then Exit Sub
    
    Dim c
    For Each c In Application.CommandBars
        If c.name = "ExcelTracker" Then
            Application.CommandBars("ExcelTracker").Delete
            Exit For
        End If
    Next c

    StartupInit progNameShort

    Dim conn As Object
    Set conn = Nothing
    If Not StartupStuff("", conn) Then
      If Not conn Is Nothing Then
        conn.Close
        Set conn = Nothing
      End If
      Exit Sub
    End If
    
    For Each wb In Application.Workbooks
      If UCase(wb.name) <> "EXCELTRACKER.XLA" And UCase(wb.name) <> "EXCELTRACKER.XLS" And UCase(wb.name) <> "EXCELTRACKER.XLSM" And UCase(wb.name) <> "EXCELTRACKER.XLAM" Then
        If WBValueSet(wb, "_IDVTrackerID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix) = False Then
            WBSetValueLong wb, "_IDVTrackerID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, -100
            WBSetValueLong wb, "_IDVTrackerVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, -1
            WBSetValueLong wb, "_IDVTrackerFreigabeStatus" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, 0
            WBSetValueLong wb, "_IDVTrackerFreigabeDateiID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, -1
            WBSetValueLong wb, "_IDVTrackerFreigabeVersion" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix, -1
            wb.saved = True
        End If
      End If
    Next wb

    DebugPrint DebType.tdebug, "Men|fffd|leiste erzeugen"

    If Not G_PARAM_Menueleiste Then
        DebugPrint DebType.tinfo, "Men|fffd|leiste deaktiviert"
    ElseIf G_PARAM_Ribbons = False Or val(xlapp.Version) <= 13 Or UCase(GetFileExtension(ThisWorkbook.fullname)) = "XLSM" Then
        G_PARAM_Ribbons = False
        DebugPrint DebType.tdebug, "Men|fffd|leiste kleine Icons aktiviert"
        Set AddInMenuBar = _
            Application.CommandBars.add("ExcelTracker", Temporary:=False)
    
        If GetSetting(appname:="Stromwerken", Section:=progNameShort, Key:="AddInMenuBarTop", Default:=-1) <> -1 Then
          AddInMenuBar.Position = GetSetting(appname:="Stromwerken", Section:=progNameShort, Key:="AddInMenuBarPosition")
          AddInMenuBar.Top = GetSetting(appname:="Stromwerken", Section:=progNameShort, Key:="AddInMenuBarTop")
          AddInMenuBar.Left = GetSetting(appname:="Stromwerken", Section:=progNameShort, Key:="AddInMenuBarLeft")
          AddInMenuBar.RowIndex = GetSetting(appname:="Stromwerken", Section:=progNameShort, Key:="AddInMenuBarRowIndex", Default:=-1)
        End If
            
        If G_PARAM_Ampel Then
            Set AmpelButton = AddInMenuBar.Controls.add( _
                Office.MsoControlType.msoControlButton, Temporary:=True)
            With AmpelButton
                '.toolTipText = "Datei noch nicht gespeichert."
                .toolTipText = FMT0("AMPEL_2")
                .Style = Office.MsoButtonStyle.msoButtonIconAndCaption
                .faceId = 926
            End With
        End If
            
        Dim reihenfolge(17) As Integer
        
        reihenfolge(1) = G_PARAM_ReihenfolgeRisikobewertung
        reihenfolge(2) = G_PARAM_ReihenfolgeDokumentation
        reihenfolge(3) = G_PARAM_ReihenfolgeVersionierung
        reihenfolge(4) = G_PARAM_ReihenfolgeFreigabeInit
        reihenfolge(5) = G_PARAM_ReihenfolgeDateiliste
        reihenfolge(6) = G_PARAM_ReihenfolgeProtect
        reihenfolge(7) = G_PARAM_ReihenfolgeScanner
        reihenfolge(8) = G_PARAM_ReihenfolgeFreigabeAbschliessen
        reihenfolge(9) = G_PARAM_ReihenfolgeEFC
        reihenfolge(10) = G_PARAM_ReihenfolgeESQA
        reihenfolge(11) = G_PARAM_ReihenfolgeBerechtigungen
        reihenfolge(12) = G_PARAM_ReihenfolgeDateiOeffnen
        reihenfolge(13) = G_PARAM_ReihenfolgeLock
        reihenfolge(14) = G_PARAM_ReihenfolgeUnLock
        reihenfolge(15) = G_PARAM_ReihenfolgeDokuInWordIcon
        reihenfolge(16) = G_PARAM_ReihenfolgeSignOff
        reihenfolge(17) = G_PARAM_ReihenfolgeAppInfo
        
        ' jetzt laufen wir 5 mal durch und suchen immer den naechsten Button,
        ' der hinzugefuegt werden muss. Bestimmt wird es duch den Wert, der
        ' in der Datenbank angegeben wird (Sortierung von klein nach gross)
        Dim bu As Integer
        For bu = 1 To 17
        
           ' mit kleinstem Wert beginnen
           Dim minWert As Integer
           Dim minR As Integer
           minWert = reihenfolge(1)
           minR = 1
           Dim r As Integer
           For r = 2 To 17
               If reihenfolge(r) < minWert Then
                   minWert = reihenfolge(r)
                   minR = r
               End If
           Next
           
           reihenfolge(minR) = 1001
           
           Select Case minR
            Case 1
                If G_PARAM_ReihenfolgeRisikobewertung >= 0 Then
                  Set RisikoFragenButton = AddInMenuBar.Controls.add( _
                      Office.MsoControlType.msoControlButton, Temporary:=True)
                  With RisikoFragenButton
                      '.toolTipText = "Risikofragen beantworten"
                      .toolTipText = FMT0("XLAAPP_7")
                      .Style = Office.MsoButtonStyle.msoButtonIconAndCaption
                      .faceId = 537
                  End With
                End If
            Case 2
                If G_PARAM_ReihenfolgeDokumentation >= 0 Then
                    Set DokuButton = AddInMenuBar.Controls.add( _
                        Office.MsoControlType.msoControlButton, Temporary:=True)
                    With DokuButton
                        '                .Caption = "Dokumentation der Datei"
                        .Style = Office.MsoButtonStyle.msoButtonIcon
                        '.toolTipText = "Dokumentation der Datei"
                        .toolTipText = FMT0("XLAAPP_8")
                        .faceId = 44
                    End With
                End If
            Case 3
                If G_PARAM_ReihenfolgeVersionierung >= 0 Then
                    Set NewVersionButton = AddInMenuBar.Controls.add( _
                        Office.MsoControlType.msoControlButton, Temporary:=True)
                    With NewVersionButton
                        '.toolTipText = "Neue Version"
                        .toolTipText = FMT0("XLAAPP_9")
                        .Style = Office.MsoButtonStyle.msoButtonIconAndCaption
                        .faceId = 43
                    End With
                End If
            Case 4
                If G_PARAM_ReihenfolgeFreigabeInit >= 0 Then
                    Set FreigabeButton = AddInMenuBar.Controls.add( _
                        Office.MsoControlType.msoControlButton, Temporary:=True)
                    With FreigabeButton
                        '.toolTipText = "Freigabe initiieren / Freigabe aufheben + Version erh|fffd|hen"
                        .toolTipText = FMT0("XLAAPP_10")
                        .Style = Office.MsoButtonStyle.msoButtonIconAndCaption
                        .faceId = 107
                    End With
                End If
            Case 5
                If G_PARAM_ReihenfolgeDateiliste >= 0 Then
                    Set MeineDateienListeButton = AddInMenuBar.Controls.add( _
                        Office.MsoControlType.msoControlButton, Temporary:=True)
                    With MeineDateienListeButton
                        '.toolTipText = "Liste 'meiner' Dateien"
                        .toolTipText = FMT0("XLAAPP_15")
                        .Style = Office.MsoButtonStyle.msoButtonIconAndCaption
                        .faceId = 448
                    End With
                End If
            Case 7
                If G_PARAM_ReihenfolgeScanner >= 0 Then
                  If GetECC() <> "" Then
                    Set ECCButton = AddInMenuBar.Controls.add( _
                        Office.MsoControlType.msoControlButton, Temporary:=True)
                    With ECCButton
                        '.toolTipText = "Excel-Sheet-Checker f|fffd|r diese Datei aufrufen"
                        .toolTipText = FMT0("XLAAPP_16")
                        .Style = Office.MsoButtonStyle.msoButtonIconAndCaption
                        .faceId = 172
                    End With
                  Else
                    G_PARAM_ReihenfolgeScanner = -1
                  End If
                End If
            Case 6
                If G_PARAM_ReihenfolgeProtect >= 0 Then
                  If GetEP() <> "" Then
                    Set EPButton = AddInMenuBar.Controls.add( _
                        Office.MsoControlType.msoControlButton, Temporary:=True)
                    With EPButton
                        '.toolTipText = "ExcelProtect f|fffd|r diese Datei aufrufen"
                        .toolTipText = FMT0("XLAAPP_17")
                        .Style = Office.MsoButtonStyle.msoButtonIconAndCaption
                        .faceId = 894 ' 236
                    End With
                  Else
                    G_PARAM_ReihenfolgeProtect = -1
                  End If
                End If
            Case 8
                If G_PARAM_ReihenfolgeFreigabeAbschliessen >= 0 Then
                  If GetECC() <> "" Then
                    Set FreigabeAbschliessenButton = AddInMenuBar.Controls.add( _
                        Office.MsoControlType.msoControlButton, Temporary:=True)
                    With FreigabeAbschliessenButton
                        '.toolTipText = "Programmfreigabe erteilen"
                        .toolTipText = FMT0("XLAAPP_12")
                        .Style = Office.MsoButtonStyle.msoButtonIconAndCaption
                        .faceId = 1976
                    End With
                  Else
                    G_PARAM_ReihenfolgeFreigabeAbschliessen = -1
                  End If
                End If
            Case 9
                If G_PARAM_ReihenfolgeEFC >= 0 Then
                  If GetEFC() <> "" Then
                    Set EFCButton = AddInMenuBar.Controls.add( _
                        Office.MsoControlType.msoControlButton, Temporary:=True)
                    With EFCButton
                        '.toolTipText = "Excel-File-Compare aufrufen"
                        .toolTipText = FMT0("XLAAPP_18")
                        .Style = Office.MsoButtonStyle.msoButtonIconAndCaption
                        .faceId = 585
                    End With
                  Else
                    G_PARAM_ReihenfolgeEFC = -1
                  End If
                End If
            Case 10
                If G_PARAM_ReihenfolgeESQA >= 0 Then
                  If GetESQA() <> "" Then
                    Set ESQAButton = AddInMenuBar.Controls.add( _
                        Office.MsoControlType.msoControlButton, Temporary:=True)
                    With ESQAButton
                        '.toolTipText = "Excel-Sheet-QA aufrufen"
                        .toolTipText = FMT0("XLAAPP_19")
                        .Style = Office.MsoButtonStyle.msoButtonIconAndCaption
                        .faceId = 642
                    End With
                  Else
                    G_PARAM_ReihenfolgeESQA = -1
                  End If
                End If
            Case 11
                If G_PARAM_ReihenfolgeBerechtigungen >= 0 Then
                  Set DateiberechtigungButton = AddInMenuBar.Controls.add( _
                      Office.MsoControlType.msoControlButton, Temporary:=True)
                  With DateiberechtigungButton
                      '.toolTipText = "Dateiberechtigung"
                      .toolTipText = FMT0("XLAAPP_20")
                      .Style = Office.MsoButtonStyle.msoButtonIconAndCaption
                      .faceId = 3205
                  End With
                End If
            Case 12
                If G_PARAM_ReihenfolgeDateiOeffnen >= 0 Then
                    Set DateiOeffnenButton = AddInMenuBar.Controls.add( _
                        Office.MsoControlType.msoControlButton, Temporary:=True)
                    With DateiOeffnenButton
                        '.toolTipText = "Datei |fffd|ffnen"
                        .toolTipText = FMT0("XLAAPP_21")
                        .Style = Office.MsoButtonStyle.msoButtonIconAndCaption
                        .faceId = 23
                    End With
                End If
            Case 13
                If G_PARAM_ReihenfolgeLock >= 0 Then
                    Set LockButton = AddInMenuBar.Controls.add( _
                        Office.MsoControlType.msoControlButton, Temporary:=True)
                    With LockButton
                        '.toolTipText = "Blattschutz anbringen"
                        .toolTipText = FMT0("XLAAPP_22")
                        .Style = Office.MsoButtonStyle.msoButtonIconAndCaption
                        .faceId = 6973 ' 2073 ' 519
                    End With
                End If
            Case 14
                If G_PARAM_ReihenfolgeUnLock >= 0 Then
                    Set UnlockButton = AddInMenuBar.Controls.add( _
                        Office.MsoControlType.msoControlButton, Temporary:=True)
                    With UnlockButton
                        '.toolTipText = "Blattschutz entfernen"
                        .toolTipText = FMT0("XLAAPP_23")
                        .Style = Office.MsoButtonStyle.msoButtonIconAndCaption
                        .faceId = 6972 ' 540
                    End With
                End If
            Case 15
                If G_PARAM_ReihenfolgeDokuInWordIcon >= 0 Then
                    Set DokuInWordButton = AddInMenuBar.Controls.add( _
                        Office.MsoControlType.msoControlButton, Temporary:=True)
                    With DokuInWordButton
                        '.toolTipText = "Doku in Word anzeigen"
                        .toolTipText = FMT0("XLAAPP_13")
                        .Style = Office.MsoButtonStyle.msoButtonIconAndCaption
                        .faceId = 9895
                    End With
                End If
            Case 16
                If G_PARAM_ReihenfolgeSignOff >= 0 Then
                    Set SignOffButton = AddInMenuBar.Controls.add( _
                        Office.MsoControlType.msoControlButton, Temporary:=True)
                    With SignOffButton
                        '.toolTipText = "Sign-Off"
                        .toolTipText = FMT0("XLAAPP_24")
                        .Style = Office.MsoButtonStyle.msoButtonIconAndCaption
                        .faceId = 2042
                    End With
                End If
            Case 17
                If G_PARAM_ReihenfolgeAppInfo >= 0 Then
                    Set AppInfoButton = AddInMenuBar.Controls.add( _
                        Office.MsoControlType.msoControlButton, Temporary:=True)
                    With AppInfoButton
                        '.toolTipText = "App-Info / Extras"
                        .toolTipText = FMT0("XLAAPP_37")
                        .Style = Office.MsoButtonStyle.msoButtonIconAndCaption
                        .faceId = 472
                    End With
                End If
            End Select
          Next bu
              
          If G_cfgInfoPfad <> "" Then
            Set InfoButton = AddInMenuBar.Controls.add( _
                Office.MsoControlType.msoControlButton, Temporary:=True)
            With InfoButton
                '.toolTipText = "Info"
                .toolTipText = FMT0("XLAAPP_14")
                .Style = Office.MsoButtonStyle.msoButtonIconAndCaption
                .faceId = 49
            End With
          End If

          If G_cfgTestarea Then
              Set TestareaButton = AddInMenuBar.Controls.add( _
                  Office.MsoControlType.msoControlButton, Temporary:=True)
              With TestareaButton
                  '.toolTipText = "Testumgebung!"
                  .toolTipText = FMT0("STARTUPTIMER_14")
                  .Style = Office.MsoButtonStyle.msoButtonIconAndCaption
                  .faceId = 99
              End With
          End If

        AddInMenuBar.visible = True
    End If
  
    DebugPrint DebType.tdebug, "ET Startup beendet."
    
    SetLastProgramStart conn
    
    If Not G_Connections Is Nothing Then
      G_Connections.add Me
      If Not conn Is Nothing Then
        conn.Close
        Set conn = Nothing
      End If
      Exit Sub
    End If
    
    Set G_Connections = New Collection
    G_Connections.add Me
    
    ' Scanpfade lesen, falls nur Scanpfade erlaubt sind
    If G_cfgNurScanpfade Then
      Set G_Scanpfade = New Collection
      Dim filers As Object
      Set filers = OpenRS("SELECT Verzeichnis FROM ECCVerzeichnisse", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
      If Not filers Is Nothing Then
        Do While Not filers.EOF
          Dim s As String
          s = Trim(GetSafeFieldPlus(filers, "Verzeichnis", ""))
          If s <> "" Then
            If Not CollectionItemExists(G_Scanpfade, s) Then
              G_Scanpfade.add s
            End If
          End If
          filers.MoveNext
        Loop
        filers.Close
        Set filers = Nothing
      End If
    End If
    
    Set G_XLSaver = Nothing
    Set G_DocInfo = Nothing
    
    If Not conn Is Nothing Then
      conn.Close
      Set conn = Nothing
    End If
    Exit Sub
    
error_handler:
    
    ' MsgBox Err.Description
    
    DebugPrint DebType.tERROR, "Startup Error!" & err.Number & " - " & err.Description & " - " & err.Source

End Sub

Public Sub SetFreigabeButtonTooltip(ByVal wbInExcelCurrentProjectInAccess As Excel.Workbook)
  On Error GoTo nogo
  
  If wbInExcelCurrentProjectInAccess Is Nothing Then Exit Sub
  
  Dim faceId As Long
  Dim toolTipText As String
  
  'FreigabeButton.toolTipText = "Freigabe initiieren"
  FreigabeButton.toolTipText = FMT0("UICALLB_1")
  
  Select Case G_AmpelStatus ' GetAmpelStatus(wbInExcelCurrentProjectInAccess)
    ' Freigegeben aber Checksumme ver|fffd|ndert - rot
    Case 2
        'FreigabeButton.toolTipText = "Freigabe aufheben"
        FreigabeButton.toolTipText = FMT0("UICALLB_2")
      ' freigabeInitText = "Freigabe entfernen"
  
    ' Freigegeben und checksumme ok - gr|fffd|n
    Case 4
        'FreigabeButton.toolTipText = "Freigabe aufheben"
        FreigabeButton.toolTipText = FMT0("UICALLB_2")
      ' freigabeInitText = "Freigabe entfernen"
  
    ' Freigabe initiiert - Blitz
    Case 6
        'FreigabeButton.toolTipText = "Freigabe abbrechen"
        FreigabeButton.toolTipText = FMT0("UICALLB_6")
      ' freigabeInitText = "Initiierung abbrechen"
 
  End Select
nogo:
End Sub



Sub Kill()
    ' Juni 2017 - keyboard hook wieder freigeben!
    ReleaseHooks
    
    G_OnDisconnectionCalled = True
    
    If G_NoStartup Then Exit Sub
    
    On Error Resume Next

    SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="AddInMenuBarPosition", Setting:=AddInMenuBar.Position
    SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="AddInMenuBarTop", Setting:=AddInMenuBar.Top
    SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="AddInMenuBarLeft", Setting:=AddInMenuBar.Left
    SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="AddInMenuBarRowIndex", Setting:=AddInMenuBar.RowIndex
    
    AddInMenuBar.Delete
  
    
'!    Dim i As Long
'!    i = 1
'!    Dim c As Connect
'!    For Each c In G_Connections
'!      If c Is Me Then
'!        G_Connections.Remove i
'!        Exit For
'!      End If
'!      i = i + 1
'!    Next c
    
'!    If G_Connections.Count > 0 Then
'!      Exit Sub
'!    End If
'!    Set G_Connections = Nothing
    
End Sub


Attribute VB_Name = "xlaStuff"
Option Explicit


Public app As New xlaApp



Attribute VB_Name = "xlsHelpers"
Sub SortListBox(lst As MSForms.ListBox, colcnt As Long, sortcol As Long)
    Dim arrItems            As Variant
    Dim arrTemp             As Variant
    Dim intOuter            As Long
    Dim intInner            As Long
    Dim t As Long
    
    If IsNull(lst.List) Then Exit Sub
 
    arrItems = lst.List
 
    For intOuter = LBound(arrItems, 1) To UBound(arrItems, 1)
        For intInner = intOuter + 1 To UBound(arrItems, 1)
            If arrItems(intOuter, sortcol) > arrItems(intInner, sortcol) Then
                For t = 0 To colcnt - 1
                  arrTemp = arrItems(intOuter, t)
                  arrItems(intOuter, t) = arrItems(intInner, t)
                  arrItems(intInner, t) = arrTemp
                Next t
            End If
        Next intInner
    Next intOuter
 
    'Clear the listbox
    lst.Clear
    'Add the sorted array back to the listbox
    
    lst.List = arrItems
    
End Sub


Sub MoveSelectedItems(ByRef l1 As MSForms.ListBox, ByRef l2 As MSForms.ListBox, colcnt As Long, sortcol As Long)
    Dim item As Long
    If l1.ListCount <= 0 Then Exit Sub
    Dim i As Long

    For i = 0 To l1.ListCount - 1
        If l1.Selected(i) Then
          l2.AddItem l1.List(i)
          ' l2.ItemData(l2.NewIndex) = l1.ItemData(i)
          If colcnt > 1 Then
            Dim c As Long
            For c = 1 To colcnt - 1
              l2.List(l2.ListCount - 1, c) = l1.List(i, c)
            Next c
          End If
        End If
    Next i
    SortListBox l2, colcnt, sortcol

    For i = l1.ListCount - 1 To 0 Step -1
        If l1.Selected(i) Then
          l1.RemoveItem i
        End If
    Next i

End Sub



' InQuest injected base64 decoded content
' xLmz{"
' zKbz
' )^N)
' z{-z
' .+-x
' qCB=
' TD@55
' TDEPA
' TDSD
' dz+O
' az{b
' YMjg
'  RZ+a
' zu't	
' ,"{^
' az{b
' zjej
' ;Rz)
' C9eHH
' 8AE4CS 
' TDKQ$
' z{Szjej
' ex*%
' AD4C
' ]1D,=
' P@DE 
' qCB=
' (^rF
' j{0z
' +-zqkj
' jQkj
' Z+]6
' '!x6
' .+-f
' *'Z+a
' KnzY^U
' 	eyV
' (^rG
' zqkz(
' z{-z
' $zp^
' TD `
' qkz(
' L\zT
' +-zo
' -"{^
' -"{^
' 't)h
' rgCj
' .+-xI
' z'!z
' ,TD `

INQUEST-PP=macro
