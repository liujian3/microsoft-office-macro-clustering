Attribute VB_Name = "Bar"
Option Explicit

Public Const IDS_TOOLBAR_NAME1 = "For Eve"
Public Const IDS_TOOLBAR_NAME2 = "For Ian"

'****************************************************************************
'*** |fffd||fffd||fffd||fffd||fffd|XLA |fffd||13c||fffd||fffd||fffd|VBA|fffd||fffd||fffd||3aa| Workbook_AddinInstall/Workbook_AddinUninstall
'****************************************************************************

Sub cmdBar()
   
    Call subShowSplash
   
    On Error Resume Next
    Application.ScreenUpdating = False
    
    If (Application.CommandBars(IDS_TOOLBAR_NAME1).Name = IDS_TOOLBAR_NAME1) Then
        Application.CommandBars(IDS_TOOLBAR_NAME1).Delete
        Call AddOurToolbar1
    Else
        Call AddOurToolbar1
    End If
    
    If (Application.CommandBars(IDS_TOOLBAR_NAME2).Name = IDS_TOOLBAR_NAME2) Then
        Application.CommandBars(IDS_TOOLBAR_NAME2).Delete
        Call AddOurToolbar2
    Else
        Call AddOurToolbar2
    End If
    Application.ScreenUpdating = True
       
End Sub

Private Sub Workbook_AddinUninstall()

    On Error Resume Next
    Application.CommandBars(IDS_TOOLBAR_NAME1).Delete
    Application.CommandBars(IDS_TOOLBAR_NAME2).Delete
 
End Sub

'***************************************
'***|fffd||fffd||fffd||723||fffd| |fffd||fffd||fffd||4f8||fffd||fffd||fffd||fffd||2f5||fffd||fffd||fffd|
'***************************************
    
Public Sub AddOurToolbar1()
    
    Dim ourToolBar As CommandBar
    Dim cell As Range
    Dim i As Integer
    Dim ws As Worksheet
    
    Set ourToolBar = Application.CommandBars.Add(Name:=IDS_TOOLBAR_NAME1, Position:=msoBarTop)
    ourToolBar.Visible = True
    ourToolBar.Enabled = True
    
    '***************************************
    '***|fffd||fffd||fffd||723||fffd| |fffd||fffd||fffd||4f0||fffd||165||fffd||63c||fffd|
    '***************************************
    
    Set ws = ThisWorkbook.Worksheets(1)
    i = 1
    For Each cell In Range(ws.Cells(1, 1), ws.Cells(33, 1))
        If cell.Value = "I Do" Then
        ourToolBar.Controls.Add Type:=msoControlButton
        With ourToolBar.Controls(i)
            .Style = msoButtonIcon
            .OnAction = cell.Offset(0, 1)
            .TooltipText = cell.Offset(0, 2)
            .Caption = cell.Offset(0, 3)
            .FaceId = cell.Offset(0, 4)
            .Visible = True
        End With
        i = i + 1
        End If
    Next
    If Application.WorksheetFunction.CountA(ws.Range("a1:a33")) = 0 Then
        Application.CommandBars(IDS_TOOLBAR_NAME1).Delete
    End If
End Sub
Public Sub AddOurToolbar2()
    
    Dim ourToolBar As CommandBar
    Dim cell As Range
    Dim i As Integer
    Dim ws As Worksheet
    
    Set ourToolBar = Application.CommandBars.Add(Name:=IDS_TOOLBAR_NAME2, Position:=msoBarTop)
    ourToolBar.Visible = True
    ourToolBar.Enabled = True
    
    '***************************************
    '***|fffd||fffd||fffd||723||fffd| |fffd||fffd||fffd||4f0||fffd||165||fffd||63c||fffd|
    '***************************************
    
    Set ws = ThisWorkbook.Worksheets(1)
    i = 1
    For Each cell In Range(ws.Cells(34, 1), ws.Cells(56, 1))
        If cell.Value = "I Do" Then
        ourToolBar.Controls.Add Type:=msoControlButton, ID:=cell.Offset(0, 4)
        End If
    Next
    If Application.WorksheetFunction.CountA(ws.Range("a34:a56")) = 0 Then
        Application.CommandBars(IDS_TOOLBAR_NAME2).Delete
    End If
End Sub

'***************************************
'***|fffd||fffd||fffd||723||fffd| Splash |fffd||fffd||2be|2|fffd||fffd|
'***************************************

Sub subShowSplash()
    Dim frmX As New Splash
    Static bFlag As Boolean
 
    If bFlag Then
        Exit Sub
    End If
 
    bFlag = True
 
    frmX.Show
 
    Application.Wait (Now + TimeValue("0:00:2"))

    Unload frmX

End Sub
Attribute VB_Name = "Menu"
Option Explicit

Sub ShowDialog()
    Selector.Show
End Sub

Sub CreateMenu()
    Dim HelpMenu As CommandBarControl
    Dim NewMenu As CommandBarPopup
    Dim MenuItem As CommandBarControl

'   Delete the menu if it already exists
    Call DeleteMenu
    
'   Find the Help Menu
    Set HelpMenu = CommandBars(1).FindControl(ID:=30010)
    
    If HelpMenu Is Nothing Then
'       Add the menu to the end
        Set NewMenu = CommandBars(1).Controls.Add _
          (Type:=msoControlPopup, _
           temporary:=True)
    Else
'      Add the menu before Help
        Set NewMenu = CommandBars(1).Controls.Add _
          (Type:=msoControlPopup, _
           before:=HelpMenu.Index, _
           temporary:=True)
    End If

'   Add a caption for the menu
    NewMenu.Caption = "&Auditing"
    
'   FIRST MENU ITEM
    Set MenuItem = NewMenu.Controls.Add _
      (Type:=msoControlButton)
    With MenuItem
        .Caption = "&Selector"
        .FaceId = 481
        .OnAction = "ShowDialog"
    End With
    
'   SECOND MENU ITEM
    Set MenuItem = NewMenu.Controls.Add _
      (Type:=msoControlButton)
    With MenuItem
        .Caption = "&Unload"
        .FaceId = 9002
        .OnAction = "DeleteBar"
    End With
        
End Sub

Sub DeleteMenu()
    On Error Resume Next
    CommandBars(1).Controls("Auditing").Delete
End Sub
Sub DeleteBar()
    On Error Resume Next
    Application.CommandBars(IDS_TOOLBAR_NAME1).Delete
    Application.CommandBars(IDS_TOOLBAR_NAME2).Delete
End Sub

Attribute VB_Name = "Procedure"
'=============================================================
'=                          EQIXU                            =
'=                                                           =
'=  Author:IanXu                                             =
'=  E-Mail: Ian.Xu@KPMG.com.cn, xuangcn@sohu.com             =
'=  Date: 2007-03-28                                         =
'=  Happy Birthday!                                          =
'=============================================================

Sub HideRow()
    Dim cell As Range
    For Each cell In Selection
        cell.EntireRow.Hidden = True
    Next
End Sub

Sub UnHideRow()
    ActiveSheet.Rows.Hidden = False
End Sub

Sub Consol_KX()
Dim cell As Range
    For Each cell In Selection
        If Len(cell) = 5 Then
        cell = "K" & cell & "X"
        Else
            If Len(cell) = 3 Then
            cell = "K" & cell & "00X"
            Else
            End If
        End If
    Next
End Sub

Sub ClearAllButFormulas()
    On Error Resume Next
    ActiveSheet.Cells.SpecialCells(xlCellTypeConstants, 23).ClearContents
End Sub

Sub Dr_Cr()
       
    invert_sign_formula
    invert_sign_figure
        
End Sub

Private Sub invert_sign_formula()

    On Error GoTo ErrorHandler
    Dim my_cell As Range, s As String, r As Range
    
    Set r = Application.Intersect(ActiveSheet.Cells.SpecialCells(xlCellTypeFormulas), Selection)
    If Not r Is Nothing Then
        For Each my_cell In r
            If IsNumeric(my_cell.Value) Then
                s = Trim(my_cell.Formula)
                If Left(s, 1) = "=" Then                    'Formula
                    s = "=" & Trim(Mid(s, 2))
                    If Mid(s, 2, 1) = "-" Then
                        s = "=-" & LTrim(Mid(s, 3))
                        If Mid(s, 3, 1) = "(" And Right(s, 1) = ")" Then
                            s = "=" & Trim(Mid(s, 4, Len(s) - 4))
                        Else
                            s = "=-(" & Trim(Mid(s, 2)) & ")"
                        End If
                    Else
                        s = "=-(" & Trim(Mid(s, 2)) & ")"
                    End If
                    my_cell.Formula = s
                Else                                        'Figure
                    my_cell.Value = -my_cell.Value
                End If
            End If
        Next my_cell
    End If

ErrorHandler:
End Sub

Private Sub invert_sign_figure()

    On Error GoTo ErrorHandler
    Dim my_cell As Range, s As String, r As Range
    
    Set r = Application.Intersect(ActiveSheet.Cells.SpecialCells(xlCellTypeConstants), Selection)
    If Not r Is Nothing Then
        For Each my_cell In r
            If IsNumeric(my_cell.Value) Then my_cell.Value = -my_cell.Value
        Next my_cell
    End If
    
ErrorHandler:
End Sub

Sub SortSheets()
'   This routine sorts the sheets of the
'   active workbook in ascending order.
      
    Dim sheetnames() As String
    Dim i As Integer
    Dim SheetCount As Integer
    Dim Item As Object
    Dim OldActive As Object
    
    If ActiveWorkbook Is Nothing Then Exit Sub ' No active workbook
    SheetCount = ActiveWorkbook.Sheets.Count
    
'   Check for protected workbook structure
    If ActiveWorkbook.ProtectStructure Then
        MsgBox ActiveWorkbook.Name & " is protected.", _
           vbCritical, "Cannot Sort Sheets."
        Exit Sub
    End If

'   Disable Ctrl+Break
    Application.EnableCancelKey = xlDisabled
       
'   Get the number of sheets
    SheetCount = ActiveWorkbook.Sheets.Count
    
'   Redimension the array
    ReDim sheetnames(1 To SheetCount)

'   Store a reference to the active sheet
    Set OldActive = ActiveSheet
   
'   Fill array with sheet names
    For i = 1 To SheetCount
        sheetnames(i) = ActiveWorkbook.Sheets(i).Name
    Next i
   
'   Sort the array in ascending order
    Call BubbleSort(sheetnames)
   
'   Turn off screen updating
    Application.ScreenUpdating = False
    
'   Move the sheets
    For i = 1 To SheetCount
        ActiveWorkbook.Sheets(sheetnames(i)).Move _
            before:=ActiveWorkbook.Sheets(i)
    Next i

'   Reactivate the original active sheet
    OldActive.Activate
End Sub


Sub BubbleSort(List() As String)
    Dim First As Integer, Last As Integer
    Dim i As Integer, j As Integer
    Dim Temp As String
    First = LBound(List)
    Last = UBound(List)
    For i = First To Last - 1
        For j = i + 1 To Last
            If List(i) > List(j) Then
                Temp = List(j)
                List(j) = List(i)
                List(i) = Temp
            End If
        Next j
    Next i
End Sub

Function ExtractElement(Txt, n, Separator) As String
'   Returns the nth element of a text string, where the
'   elements
'    are separated by a specified separator character

    Dim Txt1 As String, temperament As String
    Dim ElementCount As Integer, i As Integer
    Dim TempElement As String
    
    Txt1 = Txt
'   If space separator, remove excess spaces
    If Separator = Chr(32) Then Txt1 = Application.Trim(Txt1)
    
'   Add a separator to the end of the string
    If Right(Txt1, Len(Txt1)) <> Separator Then _
        Txt1 = Txt1 & Separator
    
'   Initialize
    ElementCount = 0
    TempElement = ""
    
'   Extract each element
    For i = 1 To Len(Txt1)
        If Mid(Txt1, i, 1) = Separator Then
            ElementCount = ElementCount + 1
            If ElementCount = n Then
'               Found it, so exit
                ExtractElement = TempElement
                Exit Function
            Else
                TempElement = ""
            End If
        Else
            TempElement = TempElement & Mid(Txt1, i, 1)
        End If
    Next i
    ExtractElement = ""
End Function


Sub ShowFaceIDs()
    Dim ButtonGroup As Long
    Dim NewToolbar As CommandBar
    Dim NewButton As CommandBarButton
    Dim SetNum As CommandBarComboBox
    Dim i As Integer
    
'   Delete existing FaceIds toolbar if it exists
    On Error Resume Next
    Application.CommandBars("FaceIds").Delete
    On Error GoTo 0
    ButtonGroup = 1

'   Add an empty toolbar
    Set NewToolbar = Application.CommandBars.Add _
        (Name:="FaceIds", temporary:=True)
    NewToolbar.Visible = True
    
'   Add 200 buttons
    For i = 1 To 200
        Set NewButton = NewToolbar.Controls.Add _
            (Type:=msoControlButton, ID:=2950)
    Next i
    
'   Add a drop-down
    Set SetNum = NewToolbar.Controls.Add(Type:=msoControlDropdown)
    For i = 1 To 51
        SetNum.AddItem "Set " & i
    Next i
    With SetNum
        .ListIndex = ButtonGroup
        .Caption = "Button Set Number"
        .OnAction = "NewButtons"
    End With
    NewToolbar.Width = 400

'   Set up the buttons
    Call NewButtons
End Sub

Sub NewButtons()
'   Adjusts the buttons, based on the selected set in the drop-down
    Dim i As Long
    Dim ButtonGroup As Long
    ButtonGroup = CommandBars("FaceIds").Controls("Button Set Number").ListIndex
    For i = 1 To 200
        With CommandBars("FaceIds").Controls(i)
            .FaceId = (ButtonGroup - 1) * 200 + i
            .Caption = "FaceID = " & (ButtonGroup - 1) * 200 + i
            .OnAction = "EmptySub"
        End With
    Next i
End Sub

Sub EmptySub()
End Sub

Sub DeleteEmptyRows()
    Dim LastRow As Long
    Dim r As Long
    LastRow = ActiveSheet.UsedRange.Row - 1 + ActiveSheet.UsedRange.Rows.Count
    Application.ScreenUpdating = False
    For r = LastRow To 1 Step -1
        If Application.WorksheetFunction.CountA(Rows(r)) = 0 _
          Then Rows(r).Delete
    Next r
End Sub

Sub ToggleGridlines()
    ActiveWindow.DisplayGridlines = Not _
    ActiveWindow.DisplayGridlines
End Sub

Sub ToggleWrapText()
'   Toggles text wrap alignment for selected cells
    If TypeName(Selection) = "Range" Then
      Selection.WrapText = Not ActiveCell.WrapText
    End If
End Sub

Sub SetPntArea()
    
    On Error Resume Next

    If Selection.Rows.Count = 1 And Selection.Columns.Count = 1 Then
        ActiveSheet.PageSetup.PrintArea = Range("a1", Selection).Address
    Else
        ActiveSheet.PageSetup.PrintArea = Selection.Address
    End If
    ActiveWindow.SelectedSheets.PrintPreview

    err.Clear

End Sub

Sub ColHeading()

    Dim mm As String
    mm = Selection.EntireColumn.Address
    ActiveSheet.PageSetup.PrintTitleColumns = mm

End Sub

Sub RowHeading()

    Dim mm As String
    mm = Selection.EntireRow.Address
    ActiveSheet.PageSetup.PrintTitleRows = mm

End Sub

Sub FormatNumber()
    On Error GoTo errHandler
        Selection.NumberFormat = "_(* #,##0_);[red]_(* (#,##0);_(* ""-""_)"
errHandler:
End Sub

Sub Get_sheets()

    On Error Resume Next

    Dim rStart As Long, cStart As Long, rEnd As Long, cEnd As Long, sSheet As String, fName As String
    Dim X As Long, Y As Long, mm As String, sCount As Long, sColor As Byte, sLink As Boolean, TFile
    Dim FolderName As String, c, fs, f1, fc As Long, sSort As String, TmpName As String
    Dim sFN As String, sFNt As String, nTmp1 As Integer, nTmp2 As Integer, mName As String, DirX As Byte, DirY As Byte
    Dim Ti As Long, sStr As String

    Static ShName As String, sStart As String, sEnd As String, TargetFile As String, logic As Byte

    sFN = "temp_temp__"
    sFNt = ActiveSheet.Name
    If err.Number > 0 Then
        err.Clear
        MsgBox ("There needs to be an open workbook to properly run this application.")
        Exit Sub
    End If

InpFolder:
    TFile = Application _
            .GetOpenFilename("Excel Workbooks (*.xls), *.xls", , "Select a file / files", , True)
    If TFile = False Then
        If err.Number = 13 Then err.Clear
    Else
        Exit Sub
    End If

    Do While True
        sStr = TFile(Ti + 1)
        If err.Number > 0 Then err.Clear: Exit Do
        Ti = Ti + 1
    Loop
    sStr = TFile(Ti)

    Set fs = CreateObject("Scripting.FileSystemObject")
    Set f1 = fs.getfile(sStr)
    FolderName = f1.parentfolder
    If InStr(1, FolderName, "[") > 0 Or InStr(1, FolderName, "]") > 0 Then
        MsgBox ("Folder name < " & FolderName & " > - Name irregular, cannot contain [ or ]")
        GoTo InpFolder
    End If
    FolderName = Replace(FolderName, "'", "''")

InpShName:
    Application.ScreenUpdating = False
    Sheets(sFN).Activate
    If err.Number > 0 Then
        err.Clear
        Sheets.Add
        If err.Number > 0 Then
            err.Clear
            MsgBox ("The application cannot be run on an active workbook which is structure-protected.")
            Exit Sub
        End If
        ActiveSheet.Name = sFN
        ActiveSheet.Visible = 2
    End If
    mm = ""
    For fc = 1 To Ti
        sStr = TFile(fc)
        Set f1 = fs.getfile(sStr)
        TmpName = f1.Name
        Windows(f1.Name).Activate
        If err.Number = 0 Then GoTo FNext
        err.Clear
        If InStr(1, TmpName, "[") > 0 Or InStr(1, TmpName, "]") > 0 Then
        Else
            TmpName = Replace(TmpName, "'", "''")
            mm = "='" & FolderName & "\[" & TmpName & "]" & "" & "'!a2"
            Sheets(sFN).Activate
            Cells(1, 1).Formula = mm
            If err.Number > 0 Then
                err.Clear
                If MsgBox("Warning!" & vbCrLf & "The list of sheet names is extracted from Workbook < " & f1.Name & " >." & vbCrLf & " Are you sure you want to input sheet names by yourself?", 4) <> 6 Then
                    Exit Sub
                Else
                    ShName = Application.InputBox _
                             (prompt:="Input your own sheet name(e.g. BalanceSheet)", _
                              Default:=ShName, Type:=2)
                    If ShName = "False" Then ShName = "": Exit Sub
                End If
            Else
                mm = Cells(1, 1).Formula
                X = InStr(1, mm, "]")
                mm = Mid(mm, X + 1, Len(mm) - X - 4)
                If mm <> "" Then ShName = mm
            End If
            Exit For
        End If
FNext:
    Next
    If mm = "" Then
        MsgBox ("All workbooks are open or have irregular names containing [ or ].")
        Exit Sub
    End If

    If InStr(1, ShName, "[") > 0 Or InStr(1, ShName, "]") > 0 Then
        MsgBox ("Worksheet < " & ShName & " > - Name irregular, cannot contain [ or ]")
        GoTo InpShName
    End If
    ShName = Replace(ShName, "'", "''")
    Cells(1, 1).Clear
    Sheets(sFNt).Select

    Application.ScreenUpdating = True

InpRange:
    If sStart = "" Or sStart = "False" Or logic = 1 Then sStart = "*"
    sStart = Application.InputBox _
             (prompt:="Input start cell here(e.g. a1, or "" * "" to ask computer to calculate the max. range)", _
              Default:=sStart, Type:=2)
    If sStart = "False" Then Exit Sub
    logic = 0
    If sStart = "*" Then
        logic = 1
        sStart = "a1"
        sEnd = "r30"
        GoTo Work
    End If

    If sEnd = "" Or sEnd = "False" Then sEnd = "b1"
    sEnd = Application.InputBox _
           (prompt:="Input end cell here (e.g. g3)", _
            Default:=sEnd, Type:=2)
    If sEnd = "False" Then Exit Sub

Work:
    rStart = Range(sStart).Row
    rEnd = Range(sEnd).Row
    cStart = Range(sStart).Column
    cEnd = Range(sEnd).Column
    If rStart > rEnd Or cStart > cEnd Then
        MsgBox ("start cell has exceeded end cell.")
        GoTo InpRange
    End If

    X = 1

    sCount = Ti - 1

    sLink = False
    sStr = Application.InputBox(prompt:="Use linkage? (Y-linkage, n-paste value only)", Default:="N", Type:=2)
    If sStr = "false" Then Exit Sub
    If sStr = "y" Then sLink = True
    If 3 * (sCount + 1) * (cEnd - cStart + 1) * (rEnd - rStart + 1) > 700000 And sLink = True Then
        sLink = False
        MsgBox ("The file may be too big.  Links won't be used.")
    End If

    Workbooks.Add (xlWBATWorksheet)
    For fc = 1 To Ti
        sStr = TFile(fc)
        Set f1 = fs.getfile(sStr)
        TmpName = f1.Name
        If InStr(1, TmpName, "[") > 0 Or InStr(1, TmpName, "]") > 0 Then
            MsgBox ("File < " & TmpName & " >'s name is irregular, containing [ or ].  I cannot continue.")
            Exit Sub
        End If
        TmpName = Replace(TmpName, "'", "''")
        sSheet = Left(Left(TmpName, Len(TmpName) - 4), 30)
        Sheets.Add after:=Sheets(Sheets.Count)

        ActiveSheet.Name = sSheet
        mm = "='" & FolderName & "\[" & TmpName & "]" & ShName & "'!" & sStart
        Cells(rStart, cStart).Formula = mm
        If err.Number > 0 Then
            err.Clear
            Sheets("sheet1").Select
            Cells(X, 1) = TmpName
            Cells(X, 2) = "Cancelled by user when selecting different sheet names."
            Cells(X, 2).Interior.ColorIndex = 3
            X = X + 1
        Else
            Cells(rStart, cStart).Copy
            Range(Cells(rStart, cStart), Cells(rEnd, cEnd)).Select
            ActiveSheet.Paste
            mm = Cells(rStart, cStart).Formula
            If Cells(rEnd, cEnd).Text <> "#REF!" Then
                Cells(rStart, cStart).Formula = mm
            End If
            If rEnd = rStart And cEnd = cStart Then
                Cells(rStart, cStart).Formula = mm
            End If
            nTmp1 = InStr(1, mm, "]")
            nTmp2 = Len(mm) - Len(sStart) - 2 - nTmp1
            mName = Mid(mm, nTmp1 + 1, nTmp2)
            Application.ScreenUpdating = False
            sColor = 3
            For Each c In Selection
                If c.Text <> "#REF!" Then
                    sColor = 0
                    Exit For
                End If
            Next c
            If logic = 1 And sColor = 0 Then GoSub sDetect
            If sLink = False Then
                Selection.Copy
                Selection.PasteSpecial Paste:=xlPasteValues
            End If
            For Each c In Selection
                If c.Value = 0 Then c.NumberFormatLocal = "_ * #,##0.00_ ;_ * -#,##0.00_ ;_ * ""-""??_ ;_ @_ "
            Next c
            err.Clear
            Selection.EntireColumn.AutoFit
            Sheets("sheet1").Select
            Cells(X, 1) = TmpName
            Cells(X, 3) = mName
            Cells(X, 2) = "Linked to / value-copied from sheet: "
            If sColor = 3 Then
                Cells(X, 3).Interior.ColorIndex = 3
            End If
            X = X + 1
            Application.ScreenUpdating = True
        End If
        Sheets(sSheet).Activate
        Call clear_zero(True, True)
    Next
    Sheets("sheet1").Select
    Range("a1", "c1").EntireColumn.AutoFit
    Range("a1").Select
    Application.CutCopyMode = False

    If sLink Then ShName = ShName & ".linked" Else ShName = ShName & ".NoLink"

    fName = Application.GetSaveAsFilename(InitialFileName:=ShName, FileFilter:="Excel Files (*.xls), *.xls")
    If fName = "False" Then Exit Sub

    ActiveWorkbook.SaveAs Filename:=fName

    err.Clear

    Exit Sub

sDetect:
    DirX = 30
    DirY = 18
    Do While (DirX > 0 Or DirY > 0)
        If DirY > 0 Then
            cStart = cStart + DirY
            cEnd = cEnd + DirY
            Cells(1, 1).Copy
            Range(Cells(1, cStart), Cells(rEnd, cEnd)).Select
            ActiveSheet.Paste
            For Each c In Selection
                If c.Value <> 0 Then logic = 0: Exit For
            Next c
            If logic = 1 Then DirY = 0
            logic = 1
        End If
        If DirX > 0 Then
            rStart = rStart + DirX
            rEnd = rEnd + DirX
            Cells(1, 1).Copy
            Range(Cells(rStart, 1), Cells(rEnd, cEnd)).Select
            ActiveSheet.Paste
            For Each c In Selection
                If c.Value <> 0 Then logic = 0: Exit For
            Next c
            If logic = 1 Then DirX = 0
            logic = 1
        End If
    Loop
    Range(Cells(1, 1), Cells(rEnd, cEnd)).Select
    rStart = 1: cStart = 1
    rEnd = 30: cEnd = 18
    Return

End Sub
Sub Display_formula()

    On Error Resume Next

    Dim c

    If MsgBox("This action may change your contents of the cells.  Are you sure you want to proceed?", 1) <> 1 Then Exit Sub

    Selection.NumberFormatLocal = "@"
    For Each c In Selection

        c.Value = c.Formula
        c.Style = "normal"
        c.Style = "|fffd||fffd||fffd||fffd|"

    Next
    Selection.EntireColumn.AutoFit


End Sub
Sub sheetnames()

    On Error Resume Next
    Dim myCell As Range, X As Long, Y As Long, ws, sCount As Long, sSort As String

    Static xp As Long, yp As Long, ShName As String, xyRC As String

    Sheets(ShName).Select
    If err.Number > 0 Then
        err.Clear
        ShName = ActiveSheet.Name
        If err.Number > 0 Then
            err.Clear
            MsgBox ("There needs to be an open workbook to properly run this application.")
            Exit Sub
        End If

    End If
    Cells(xp, yp).Select
    If err.Number > 0 Then
        err.Clear
        xp = Selection.Row
        yp = Selection.Column
    End If
    xyRC = ShName & "!" & Selection.Address

    Set myCell = Application.InputBox( _
                                      prompt:="Select a cell to place the result", Default:=xyRC, Type:=8)

    If err.Number > 0 Then
        If err.Number <> 424 Then
            MsgBox err.Number & err.Description
        End If
        err.Clear
        Exit Sub
    End If

    ShName = myCell.Parent.Name
    X = myCell.Row: xp = X
    Y = myCell.Column: yp = Y

    For Each ws In Worksheets
        If Sheets(ws.Name).Visible = -1 Then
            sCount = sCount + 1
        End If
    Next
    Sheets(ShName).Select
    Range(Cells(X, Y), Cells(X + sCount - 1, Y)).Select
    If MsgBox("This range may be covered?", 1) <> 1 Then
        Exit Sub
    End If

    err.Clear

    Application.ScreenUpdating = False

    Selection.Clear

    For Each ws In Worksheets
        If Sheets(ws.Name).Visible = -1 Then
            Cells(X, Y).Value = ws.Name
            Sheets(ShName).Hyperlinks.Add Anchor:=Cells(X, Y), Address:="", SubAddress:= _
                                                                                        "'" & ws.Name & "'!A1"

            If err.Number > 0 Then
                MsgBox "Pls select an appropriate range and then try again."
                err.Clear
                Exit Sub
            End If
            X = X + 1
        End If
    Next

    Range(Cells(X - sCount, Y), Cells(X - 1, Y)).Select
    Selection.EntireColumn.AutoFit

    Application.ScreenUpdating = True
    sSort = Application.InputBox _
            (prompt:="Sorting order (a-ascending, d-descending, n-no sorting)", _
             Default:="a", Type:=2)
    If sSort = "a" Then
        Selection.Sort key1:=Cells(X - sCount, Y), order1:=xlAscending, header:=xlNo
    End If
    If sSort = "d" Then
        Selection.Sort key1:=Cells(X - sCount, Y), order1:=xlDescending, header:=xlNo
    End If

    err.Clear

End Sub
Sub dotted()

    On Error Resume Next
    Selection.Borders(xlBottom).LineStyle = xlDash

End Sub
Sub Sglact()

    On Error Resume Next
    Selection.Font.Underline = xlSingleAccounting

End Sub
Sub dblact()

    On Error Resume Next
    Selection.Font.Underline = xlDoubleAccounting

End Sub
Sub center()

    On Error Resume Next
    With Selection
        .MergeCells = False
        .HorizontalAlignment = xlCenterAcrossSelection
    End With

End Sub
Sub remove()

    On Error Resume Next
    With Selection
        .MergeCells = False
        .HorizontalAlignment = xlGeneral
    End With

End Sub
Sub DateConvertor()

'v1.1 on 2004-3-16

    On Error Resume Next

    Dim myRange As Range, myCell As Range, c, dStr As String, dDec As Integer
    Dim ma As Integer, mb As Integer, mc As Integer, dYear As String, dMonth As String, dDate As String
    Dim z(3) As String, md As Integer, dDoubt As Boolean, mf As Integer, sa As String, sb As String, sc As String
    Dim dYear1 As String, dMonth1 As String, dDate1 As String, dDoubt1 As Boolean, mm As Long

    Set myRange = Application.InputBox( _
                                       prompt:="Select the date range to be converted", Title:="DateConvertor", Type:=8)

    If err.Number > 0 Then
        If err.Number <> 424 Then
            MsgBox err.Number & err.Description
        End If
        err.Clear
        Exit Sub
    End If

    If myRange.Columns.Count > 1 Then MsgBox ("The date range must be single-column."): err.Clear: Exit Sub

InpPos:
    Set myCell = Application.InputBox( _
                                      prompt:="Select a cell to place the result", Title:="DateConvertor", Type:=8)

    If err.Number > 0 Then
        If err.Number <> 424 Then
            MsgBox err.Number & err.Description
        End If
        err.Clear
        Exit Sub
    End If

    ma = myRange.Rows.Count
    mc = myCell.Row
    md = myCell.Column

    Range(Cells(mc, md), Cells(mc + ma - 1, md + 3)).Select

    If MsgBox("May this area be covered?", vbOKCancel, "DateCovertor") <> vbOK Then GoTo InpPos

    Selection.Clear

    myRange.Copy
    myCell.Select
    ActiveSheet.Paste
    Selection.EntireColumn.AutoFit

    For Each c In Selection

        dStr = LTrim(RTrim(c.Text))
        If Trim(c.Text) = "" Then GoTo JumpToNext
        mm = 0
        mm = c.Value
        err.Clear
        GoSub Check

        dYear1 = dYear
        dMonth1 = dMonth
        dDate1 = dDate
        dDoubt1 = dDoubt

        'First check - use the TEXT (what is displayed) of the cell to check the actual date format.

        c.NumberFormatLocal = "dd-mm-yyyy"
        c.EntireColumn.AutoFit
        c.Value = c.Text
        c.Value = c.Text

        dStr = LTrim(RTrim(c.Text))

        GoSub Check

        'second check - use the Value of the cell to check the actual date format.

        'among above two checks, if one checking is "no doubt", the result will be that one.

        If Len(str(mm)) = 6 And mm > 18263 And mm < 54789 Then dDoubt = False: dDoubt1 = True    'this is specifically _
                                                                                                 for "33629" type input. Both checking will give result, but the 2nd one will be correct._
        'the range is from 1950-1-1 to 2049-12-31.
        If Len(str(mm)) = 5 And mm > 1949 And mm < 2050 Then dDoubt = True: dDoubt1 = False
        If Len(str(mm)) = 3 Then dDoubt = True: dDoubt1 = False

        ' Above two are for type "1959" "2033" or "67".

        If dDoubt And dDoubt1 Then
            GoSub Hilit
        Else
            If dDoubt1 Then
                dYear1 = dYear
                dMonth1 = dMonth
                dDate1 = dDate
                dDoubt1 = dDoubt
            End If
        End If

        If Val(dYear1) > 1949 And Val(dYear1) < 2050 And Val(dMonth1) > 0 And Val(dMonth1) < 13 And Val(dDate1) > 0 And Val(dDate1) < 32 Then
        Else
            GoSub Hilit
            GoTo JumpToNext
        End If

        dStr = "=date(" & Val(dYear1) & "," & Val(dMonth1) & "," & Val(dDate1) & ")"
        c.Formula = dStr
        c.NumberFormatLocal = "dd-mmm-yyyy"
        ma = Year(c.Value)
        mb = Month(c.Value)
        mc = Day(c.Value)

        If ma <> Val(dYear1) Or mb <> Val(dMonth1) Or mc <> Val(dDate1) Then GoSub Hilit

        dStr = "=year(" & c.Address & ")"
        Cells(c.Row, c.Column + 1).Formula = dStr

        dStr = "=month(" & c.Address & ")"
        Cells(c.Row, c.Column + 2).Formula = dStr

        dStr = "=day(" & c.Address & ")"
        Cells(c.Row, c.Column + 3).Formula = dStr

        Range(Cells(c.Row, c.Column + 1), Cells(c.Row, c.Column + 3)).NumberFormat = "0"


JumpToNext:
    Next

    With Selection
        .HorizontalAlignment = xlRight
        .VerticalAlignment = xlBottom
        .EntireColumn.AutoFit
    End With

    err.Clear
    Exit Sub

Check:

    dDoubt = False
    dYear = ""
    dMonth = ""
    dDate = ""
    z(1) = "": z(2) = "": z(3) = ""

    ' above is data initiation.

    ' the standard format should be "xxx-xx-xxx".  Below is the trimming process to make the string become standard

    If InStr(1, dStr, "january") > 0 Or InStr(1, dStr, "jan") > 0 Then dStr = Replace(dStr, "january", "01"): dStr = Replace(dStr, "jan", "01"): dMonth = "01"
    If InStr(1, dStr, "february") > 0 Or InStr(1, dStr, "feb") > 0 Then dStr = Replace(dStr, "february", "02"): dStr = Replace(dStr, "feb", "02"): dMonth = "02"
    If InStr(1, dStr, "march") > 0 Or InStr(1, dStr, "mar") > 0 Then dStr = Replace(dStr, "march", "03"): dStr = Replace(dStr, "mar", "03"): dMonth = "03"
    If InStr(1, dStr, "april") > 0 Or InStr(1, dStr, "apr") > 0 Then dStr = Replace(dStr, "april", "04"): dStr = Replace(dStr, "apr", "04"): dMonth = "04"
    If InStr(1, dStr, "may") > 0 Or InStr(1, dStr, "may") > 0 Then dStr = Replace(dStr, "may", "05"): dStr = Replace(dStr, "may", "05"): dMonth = "05"
    If InStr(1, dStr, "june") > 0 Or InStr(1, dStr, "jun") > 0 Then dStr = Replace(dStr, "june", "06"): dStr = Replace(dStr, "jun", "06"): dMonth = "06"
    If InStr(1, dStr, "july") > 0 Or InStr(1, dStr, "jul") > 0 Then dStr = Replace(dStr, "july", "07"): dStr = Replace(dStr, "jul", "07"): dMonth = "07"
    If InStr(1, dStr, "august") > 0 Or InStr(1, dStr, "aug") > 0 Then dStr = Replace(dStr, "august", "08"): dStr = Replace(dStr, "aug", "08"): dMonth = "08"
    If InStr(1, dStr, "september") > 0 Or InStr(1, dStr, "sep") > 0 Then dStr = Replace(dStr, "september", "09"): dStr = Replace(dStr, "sep", "09"): dMonth = "09"
    If InStr(1, dStr, "october") > 0 Or InStr(1, dStr, "oct") > 0 Then dStr = Replace(dStr, "october", "10"): dStr = Replace(dStr, "oct", "10"): dMonth = "10"
    If InStr(1, dStr, "november") > 0 Or InStr(1, dStr, "nov") > 0 Then dStr = Replace(dStr, "november", "11"): dStr = Replace(dStr, "nov", "11"): dMonth = "11"
    If InStr(1, dStr, "december") > 0 Or InStr(1, dStr, "dec") > 0 Then dStr = Replace(dStr, "december", "12"): dStr = Replace(dStr, "dec", "12"): dMonth = "12"

    'if at early stage of trimming the string, we can identify the key words, such as "|fffd||fffd|" or "december", we will note down this as dYear or dMonth immeidately.

    dStr = Replace(dStr, "|fffd||fffd|", "0")
    dStr = Replace(dStr, "|fffd||fffd|", "0")
    dStr = Replace(dStr, "|fffd||fffd|", "0")
    dStr = Replace(dStr, "|4bb|", "1")
    dStr = Replace(dStr, "|4bc|", "1")
    dStr = Replace(dStr, "|fffd||fffd|", "2")
    dStr = Replace(dStr, "|fffd||fffd|", "2")
    dStr = Replace(dStr, "|fffd||fffd|", "3")
    dStr = Replace(dStr, "|fffd||fffd|", "3")
    dStr = Replace(dStr, "|fffd||fffd|", "4")
    dStr = Replace(dStr, "|fffd||fffd|", "4")
    dStr = Replace(dStr, "|fffd||fffd|", "5")
    dStr = Replace(dStr, "|fffd||fffd|", "5")
    dStr = Replace(dStr, "|fffd||fffd|", "6")
    dStr = Replace(dStr, "|bd|", "6")
    dStr = Replace(dStr, "|fffd||fffd|", "7")
    dStr = Replace(dStr, "|fffd||fffd|", "7")
    dStr = Replace(dStr, "|fffd||fffd|", "8")
    dStr = Replace(dStr, "|fffd||fffd|", "8")
    dStr = Replace(dStr, "|fffd||fffd|", "9")
    dStr = Replace(dStr, "|fffd||fffd|", "9")
    dStr = Replace(dStr, "|2b0|", "|2ae|")

    'below procedure is to handle |fffd||fffd||2ae||fffd||fffd|in Chn language logic

    Do While True
        dDec = InStr(1, dStr, "|2ae|")
        If dDec > 0 Then
            If dDec = 1 Then
                sa = " "
            Else
                sa = Mid(dStr, dDec - 1, 1)  'sa is the letter before "|2ae|"
            End If
            If dDec < Len(dStr) Then
                sb = Mid(dStr, dDec + 1, 1)
            Else
                sb = " "  'sb is the letter after "|2ae|"
            End If
        Else
            Exit Do
        End If

        If dDec = 1 Then sc = "" Else sc = Left(dStr, dDec - 1)

        If Asc(sb) > 47 And Asc(sb) < 58 Then
            If Asc(sa) > 47 And Asc(sa) < 58 Then
                dStr = sc & Replace(dStr, "|2ae|", "", dDec, 1)    'both sa & sb are numbers, "|2ae|" is omittable.
            Else
                dStr = sc & Replace(dStr, "|2ae|", "1", dDec, 1)    'only sb is number, "|2ae|" is "1" before another number
            End If
        Else
            If Asc(sa) > 47 And Asc(sa) < 58 Then
                dStr = sc & Replace(dStr, "|2ae|", "0", dDec, 1)    'only sa is number, "|2ae|" means "0"
            Else
                dStr = sc & Replace(dStr, "|2ae|", "10", dDec, 1)    'both sa and sb are NOT numbers, "|2ae|" menas "10".
            End If
        End If
    Loop

    'below part is to identify |fffd||fffd||fffd||fffd||fffd||fffd|, and early-decision on dYear, dMonth and dDate.
    ma = InStr(1, dStr, "|fffd||fffd|")
    mb = InStr(1, dStr, "|fffd||fffd|")
    mc = InStr(1, dStr, "|fffd||fffd|")

    If ma > 0 Then
        md = Application.WorksheetFunction.Min(ma, mb)
        mf = Application.WorksheetFunction.Min(ma, mc)
        If md = ma Then md = md - 5
        If mf = ma Then mf = mf - 5
        md = Application.WorksheetFunction.Max(0, md, mf, ma - 5)
        dYear = Mid(dStr, md + 1, ma - 1 - md)
        If Len(dYear) = 4 Then
            If Val(dYear) < 1950 Or Val(dYear) > 2049 Then dYear = Right(dYear, 2)
        End If
    End If

    If mb > 0 Then
        md = Application.WorksheetFunction.Min(mc, mb)
        mf = Application.WorksheetFunction.Min(ma, mb)
        If md = mb Then md = md - 3
        If mf = mb Then mf = mf - 3
        md = Application.WorksheetFunction.Max(0, md, mf, mb - 3)
        dMonth = Mid(dStr, md + 1, mb - md - 1)
        If Val(dMonth) < 1 Or Val(dMonth) > 12 Then dMonth = Right(dMonth, 1)
        If Val(dMonth) < 1 Or Val(dMonth) > 12 Then dMonth = ""
    End If

    If mc > 0 Then
        md = Application.WorksheetFunction.Min(mc, mb)
        mf = Application.WorksheetFunction.Min(mc, ma)
        If md = mc Then md = md - 3
        If mf = mc Then mf = mf - 3
        md = Application.WorksheetFunction.Max(0, md, mf, mc - 3)
        dDate = Mid(dStr, md + 1, mc - md - 1)
        If Val(dDate) < 1 Or Val(dDate) > 31 Then dDate = Right(dDate, 1)
        If Val(dDate) < 1 Or Val(dDate) > 31 Then dDate = ""
    End If

    'this is triming process again.

    dStr = Replace(dStr, "|fffd||fffd|", "-")
    dStr = Replace(dStr, "|fffd||fffd|", "-")
    dStr = Replace(dStr, "|fffd||fffd|", "-")
    dStr = Replace(dStr, "/", "-")
    dStr = Replace(dStr, ".", "-")
    dStr = Replace(dStr, " ", "-")
    dStr = Replace(dStr, ",", "-")
    dStr = Replace(dStr, "|fffd||fffd|", "-")
    dStr = Replace(dStr, "'", "-")
    dStr = Replace(dStr, """", "-")
    dStr = Replace(dStr, "_", "-")
    dStr = Replace(dStr, "|fffd||fffd|", "-")
    dStr = Replace(dStr, "|fffd||fffd|", "-")
    dStr = Replace(dStr, "|fffd||fffd|", "-")
    dStr = Replace(dStr, "|fffd||fffd|", "-")
    dStr = Replace(dStr, "|fffd||fffd|", "-")
    dStr = Replace(dStr, "|fffd||fffd||fffd||fffd|", "-")

    dStr = Replace(dStr, "--", "-")
    dStr = Replace(dStr, "--", "-")
    dStr = Replace(dStr, "--", "-")
    dStr = Replace(dStr, "--", "-")


    'this part is to trim other CHN characters -- i.e. asc()<0
    ma = 0
    Do While True
        ma = ma + 1
        If ma > Len(dStr) Then Exit Do
        If Asc(Mid(dStr, ma, 1)) < 0 Then dDoubt = True: dStr = Replace(dStr, Mid(dStr, ma, 1), "")
        If Asc(Mid(dStr, ma, 1)) > 64 And Asc(Mid(dStr, ma, 1)) < 123 Then dStr = Replace(dStr, Mid(dStr, ma, 1), "")
    Loop

    Do While True
        If Left(dStr, 1) <> "-" Then Exit Do
        dStr = Right(dStr, Len(dStr) - 1)
    Loop

    Do While True
        If Right(dStr, 1) <> "-" Then Exit Do
        dStr = Left(dStr, Len(dStr) - 1)
    Loop

    If Len(dStr) = 0 Then dDoubt = True: Return

    'from this part, trimming process is completed.
    'the below part is to get z(1), z(2) and z(3) by identifying the separator "-"

    mb = 0
    mb = InStr(1, dStr, "-")
    If mb = 0 Then GoSub Split
    mb = InStr(1, dStr, "-")
    If mb = 0 Then
        z(1) = dStr: z(2) = "01": z(3) = "00"
    Else
        z(1) = Left(dStr, mb - 1)
        mc = 0
        mc = InStr(mb + 1, dStr, "-")
        If mc = 0 Then
            err.Clear
            z(2) = "00"
            z(3) = Mid(dStr, mb + 1, Len(dStr) - mb)
        Else
            z(2) = Mid(dStr, mb + 1, mc - mb - 1)
            z(3) = Right(dStr, Len(dStr) - mc)
        End If
    End If

    For ma = 1 To 3
        z(ma) = Replace(z(ma), "-", "")
        z(ma) = str(Val(z(ma)))
        z(ma) = Right(z(ma), Len(z(ma)) - 1)
    Next


    'to match z(1), z(2) and z(3) with dYear, dMonth and dDate
    If dYear = "" Then
        For ma = 1 To 3
            If Val(z(ma)) > 49 And Len(z(ma)) = 2 Then z(ma) = "19" & z(ma)
        Next

        mb = 0: mc = 0
        For ma = 1 To 3
            If Val(z(ma)) > 1949 And Val(z(ma)) < 2050 Then mb = ma: mc = mc + 1
        Next
        If mc > 1 Then dDoubt = True  ' two Zs qualify for year, a problem.
        If mc = 0 Then mb = 3  'no one qualifies for year, then assume the last one is.
        dYear = z(mb)
        If Val(dYear) < 50 Then dYear = "20" & dYear
    Else
        For ma = 1 To 3
            mb = ma
            If Val(z(ma)) = Val(dYear) Then ma = 5: Exit For
        Next
        If ma <> 5 Then dDoubt = True
    End If

    If dMonth = "" Then
        mc = 0: md = 0
        For ma = 1 To 3
            If ma <> mb Then
                If Val(z(ma)) > 0 And Val(z(ma)) < 13 Then mc = ma: md = md + 1
            End If
        Next
        If md = 2 Then
            If mb <> 1 And Val(z(mc)) <> Val(z(6 - mc - mb)) Then dDoubt = True
            If mb = 1 Then
                If z(2) <> "00" Then mc = 2 Else mc = 3
            End If
        End If
        If md = 0 Then
            dDoubt = True: mc = Application.WorksheetFunction.Max(mb - 1, 3 - mb)
        End If
        dMonth = z(mc)
    Else
        For ma = 1 To 3
            mc = ma
            If Val(z(ma)) = Val(dMonth) Then ma = 5: Exit For
        Next
        If ma <> 5 Then dDoubt = True
    End If

    If dDate = "" Or Val(dDate) = Val(z(6 - mb - mc)) Then
        dDate = z(6 - mb - mc)
    Else
        dDoubt = True
        If Val(dDate) = Val(dMonth) Then dMonth = z(6 - mb - mc) Else dDate = Right(dYear, 2): dYear = z(6 - mb - mc)
    End If

    If Val(dYear) < 1950 And Len(dYear) = 4 Then dYear = "20" & Right(dYear, 2)
    If Val(dYear) < 50 And Len(dYear) = 2 Then dYear = "20" & dYear
    If Len(dYear) = 2 Then dYear = "19" & dYear
    If Len(dYear) = 3 Then dYear = "20" & Right(dYear, 2)
    If Len(dYear) = 1 Then dYear = "200" & dYear

    If Val(dMonth) = 0 Then dMonth = "01"
    If Val(dDate) = 0 Then dDate = "01"


    Return

Split:
    'split is to handle type "199706" or "19970612" or "970612". assumption is that the year normally should be the first part.
    'split can also handle "06122003" type

    ma = Len(dStr)
    If ma = 6 Then
        If Val(Left(dStr, 4)) > 1949 And Val(Left(dStr, 4)) < 2050 Then dStr = Left(dStr, 4) & "-" & Right(dStr, 2): Return
        dStr = Left(dStr, 2) & "-" & Mid(dStr, 3, 2) & "-" & Right(dStr, 2)
        Return
    End If
    If ma = 8 Then
        If Val(Left(dStr, 4)) > 1949 And Val(Left(dStr, 4)) < 2050 Then
            dStr = Left(dStr, 4) & "-" & Mid(dStr, 5, 2) & "-" & Right(dStr, 2)
        Else
            dStr = Left(dStr, 2) & "-" & Mid(dStr, 3, 2) & "-" & Right(dStr, 4)
        End If
        Return
    End If
    dDoubt = True
    Return

Hilit:
    With c.Font
        .Bold = True
        .Size = 14
        .Underline = xlUnderlineStyleSingleAccounting
        .ColorIndex = 3
    End With
    c.Interior.ColorIndex = 6

    Return

End Sub
Sub extract()

    On Error Resume Next

    Dim ws, rStart As Long, cStart As Long, rEnd As Long, cEnd As Long, sLink As Boolean, sStr As String
    Dim mm As String, x1 As Byte, y1 As Byte, sCount As Integer, x2 As Long, y2 As Long, TmpName As String
    Dim X As Long, Y As Long, sSort As String, c As Range, logic As Byte, myCell As Range, xyRC As String

    Static sStart As String, sEnd As String, xp As Long, yp As Long, sSheet As String, sFree As Byte

InpRange:
    If sStart = "" Or sStart = "False" Then sStart = "a1"
    If sFree = 1 Then sStart = "*"
    sStart = Application.InputBox _
             (prompt:="Input start cell here(e.g. a1, or "" * "" to ask computer to calculate the max. range)", _
              Default:=sStart, Type:=2)
    If sStart = "False" Then Exit Sub
    sFree = 0
    If sStart = "*" Then
        sFree = 1
        sStart = "a1"
        sEnd = "b1"
        GoTo InpPos
    End If

    If sEnd = "" Or sEnd = "False" Then sEnd = "b1"
    If sFree = 2 Then sEnd = "*"
    sEnd = Application.InputBox _
           (prompt:="Input end cell here (e.g. g3, or "" * "" to ask computer to calculate the max. range)", _
            Default:=sEnd, Type:=2)
    If sEnd = "False" Then Exit Sub
    If sEnd = "*" Then
        sFree = 2
        sEnd = Cells(Range(sStart).Row, Range(sStart).Column + 1).Address
        GoTo InpPos
    End If

    logic = Application.InputBox _
            (prompt:="Input your preferred layout (1<as columns>, 2<as rows>, or any number>0)", _
             Default:=9, Type:=1)
    If logic = 0 Then Exit Sub

InpPos:

    rStart = Range(sStart).Row
    If err.Number > 0 Then
        err.Clear
        MsgBox ("There needs to be an open workbook to properly run this application.")
        Exit Sub
    End If
    rEnd = Range(sEnd).Row
    cStart = Range(sStart).Column
    cEnd = Range(sEnd).Column
    If rStart > rEnd Or cStart > cEnd Then
        MsgBox ("start cell has exceeded end cell.")
        GoTo InpRange
    End If

    Sheets(sSheet).Select
    If err.Number > 0 Then
        err.Clear
        sSheet = ActiveSheet.Name
    End If
    Cells(xp, yp).Select
    If err.Number > 0 Then
        err.Clear
        xp = Selection.Row
        yp = Selection.Column
    End If

    xyRC = sSheet & "!" & Selection.Address

    Set myCell = Application.InputBox( _
                                      prompt:="Select a cell to place the result", Default:=xyRC, Type:=8)

    If err.Number > 0 Then
        If err.Number <> 424 Then
            MsgBox err.Number & err.Description
        End If
        err.Clear
        Exit Sub
    End If

    sSheet = myCell.Parent.Name
    X = myCell.Row: xp = X
    Y = myCell.Column: yp = Y

    Sheets(sSheet).Select
    x1 = 1     ' meaning in rows
    If rEnd - rStart > cEnd - cStart Then x1 = 0
    y1 = 1 - x1

    sCount = -1

    For Each ws In Worksheets
        If Sheets(ws.Name).Visible = -1 Then
            If ws.Name <> sSheet Then
                sCount = sCount + 1
            End If
        End If
    Next

    If sFree = 0 Then
        If Y + (cEnd - cStart + 1) * y1 * sCount + x1 + cEnd - cStart > 16 Then
            x1 = 1: y1 = 0
        End If
        If logic = 1 Then
            x1 = 0
        End If
        If logic = 2 Then
            x1 = 1
        End If
        y1 = 1 - x1

        Range(Cells(X, Y), Cells(X + (rEnd - rStart + 1) * x1 * sCount + y1 + rEnd - rStart, Y + (cEnd - cStart + 1) * y1 * sCount + x1 + cEnd - cStart)).Select
        If err.Number > 0 Then
            err.Clear
            MsgBox ("Too many rows or columns.  Exceeding EXCEL's limits.  Cannot continue.")
            Exit Sub
        End If
        If MsgBox("This range may be covered?", 1) <> 1 Then
            GoTo InpPos
        End If
        Selection.Clear
    Else
        If MsgBox("The whole worksheet may be covered?", 1) <> 1 Then
            GoTo InpPos
        End If
        Cells.Clear
    End If

    sLink = False
    sStr = Application.InputBox(prompt:="Use linkage? (Y-linkage, n-paste value only)", Default:="N", Type:=2)
    If sStr = "false" Then Exit Sub
    If sStr = "y" Then sLink = True

    If 3 * (sCount + 1) * (cEnd - cStart + 1) * (rEnd - rStart + 1) > 700000 And sLink = True Then
        sLink = False
        MsgBox ("The file may be too big.  Links won't be used.")
    End If

    Application.ScreenUpdating = False

    For Each ws In Worksheets
        If Sheets(ws.Name).Visible = -1 Then
            If ws.Name <> sSheet Then
                TmpName = ws.Name
                If InStr(1, TmpName, "[") > 0 Or InStr(1, TmpName, "]") > 0 Then
                    TmpName = Replace(TmpName, "[", "((")
                    TmpName = Replace(TmpName, "]", "))")
                    ws.Name = TmpName
                    If err.Number > 0 Then
                        err.Clear
                        MsgBox ("Worksheet< " & ws.Name & " > - Name irregular, cannot contain [ or ]")
                        Exit Sub
                    End If
                End If
                TmpName = Replace(TmpName, "'", "''")
                mm = "='" & TmpName & "'!" & sStart
                If sFree > 0 Then
                    Sheets(ws.Name).Select
                    Call clear_zero(False, False)
                    rEnd = Application.WorksheetFunction.Max(clendR, 1, rStart): cEnd = Application.WorksheetFunction.Max(1, clendC, cStart)
                End If
                Sheets(sSheet).Select
                Cells(X, Y) = ws.Name
                Cells(X, Y).Select
                With Selection.Interior
                    .ColorIndex = 6
                End With
                Selection.Font.Bold = True
                Cells(X + y1, Y + x1).Formula = mm
                Cells(X + y1, Y + x1).Copy
                Range(Cells(X + y1, Y + x1), Cells(X + y1 + rEnd - rStart, Y + x1 + cEnd - cStart)).Select
                ActiveSheet.Paste
                If sLink = False Then
                    Selection.Copy
                    Selection.PasteSpecial Paste:=xlPasteValues
                End If

                Sheets(ws.Name).Select
                Range(Cells(rStart, cStart), Cells(rEnd, cEnd)).Copy
                Sheets(sSheet).Select
                Range(Cells(X + y1, Y + x1), Cells(X + y1 + rEnd - rStart, Y + x1 + cEnd - cStart)).PasteSpecial Paste:=xlFormats
                x2 = X + (rEnd - rStart + 1) * x1
                y2 = Y + (cEnd - cStart + 1) * y1
                Range(Cells(X, Y), Cells(x2 - x1, y2 - y1)) = ws.Name
                X = x2
                Y = y2
            End If
        End If
    Next
    X = xp: Y = yp

    Range(Cells(X + y1, Y + x1), Cells(X + (rEnd - rStart + 1) * x1 * sCount + y1 + rEnd - rStart, Y + (cEnd - cStart + 1) * y1 * sCount + x1 + cEnd - cStart)).Select
    If sFree > 0 Then ActiveSheet.UsedRange.Select
    For Each c In Selection
        If c.Value = 0 Then c.NumberFormatLocal = "_ * #,##0.00_ ;_ * -#,##0.00_ ;_ * ""-""??_ ;_ @_ "
    Next c
    err.Clear

    Range(Cells(X, Y), Cells(X + (rEnd - rStart + 1) * x1 * sCount + y1 + rEnd - rStart, Y + (cEnd - cStart + 1) * y1 * sCount + x1 + cEnd - cStart)).Select
    If sFree = 1 Then ActiveSheet.UsedRange.Select
    Selection.EntireColumn.AutoFit
    Application.ScreenUpdating = True

    sSort = Application.InputBox _
            (prompt:="Sorting order (a-ascending, d-descending, n-no sorting)", _
             Default:="a", Type:=2)

    On Error GoTo 0
    On Error GoTo ErrorHandler

    If sSort = "a" Then
        If x1 = 0 Then
            Selection.Sort key1:=Cells(X, Y), order1:=xlAscending, header:=xlNo, Orientation:=xlSortRows
        Else
            Selection.Sort key1:=Cells(X, Y), order1:=xlAscending, header:=xlNo, Orientation:=xlSortColumns
        End If
    End If
    If sSort = "d" Then
        If x1 = 0 Then
            Selection.Sort key1:=Cells(X, Y), order1:=xlDescending, header:=xlNo, Orientation:=xlSortRows
        Else
            Selection.Sort key1:=Cells(X, Y), order1:=xlDescending, header:=xlNo, Orientation:=xlSortColumns
        End If
    End If

    Application.CutCopyMode = False

    Exit Sub

ErrorHandler:
    MsgBox err.Description
    err.Clear

End Sub
Sub extract_Global()

    On Error Resume Next

    Dim rStart As Long, cStart As Long, rEnd As Long, cEnd As Long, lLl As Boolean, sLink As Boolean, TargetFile, sStr As String
    Dim X As Long, Y As Long, mm As String, x1 As Byte, y1 As Byte, sCount As Long, x2 As Long, y2 As Long, myCell As Range
    Dim FolderName As String, c, fs, f1, fc As Long, Ti As Long, sSort As String, logic As Byte, TmpName As String
    'Dim ADOX As Object, TableName As String, dbFile As String, strProvider As String, i As Long, NoMatch As Integer
    Dim sFN As String, sFNt As String, nTmp1 As Integer, nTmp2 As Integer, mName As String

    Static ShName As String, sStart As String, sEnd As String, sSheet As String, xp As Long, yp As Long, xyRC As String

    sFN = "temp_temp__"
    sFNt = ActiveSheet.Name
    If err.Number > 0 Then
        err.Clear
        MsgBox ("There needs to be an open workbook to properly run this application.")
        Exit Sub
    End If

    Set fs = CreateObject("Scripting.FileSystemObject")

InpFolder:
    TargetFile = Application _
                 .GetOpenFilename("Excel Workbooks (*.xls), *.xls", , "Select file(s)", , True)
    Do While True
        sStr = TargetFile(Ti + 1)
        If err.Number = 13 Then Exit Sub   ' type mismatch, TFile=false, cancelled.
        If err.Number = 9 Then Exit Do  ' out of range.  Reach the end of TFile
        Ti = Ti + 1
    Loop
    err.Clear
    sStr = TargetFile(Ti)

    Set f1 = fs.getfile(sStr)
    FolderName = f1.parentfolder
    If InStr(1, FolderName, "[") > 0 Or InStr(1, FolderName, "]") > 0 Then
        MsgBox ("Folder name < " & FolderName & " > - Name irregular, cannot contain [ or ]")
        GoTo InpFolder
    End If
    FolderName = Replace(FolderName, "'", "''")


InpShName:
    Application.ScreenUpdating = False
    Sheets(sFN).Activate
    If err.Number > 0 Then
        err.Clear
        Sheets.Add
        If err.Number > 0 Then
            err.Clear
            MsgBox ("The application cannot be run on an active workbook which is structure-protected.")
            Exit Sub
        End If
        ActiveSheet.Name = sFN
        ActiveSheet.Visible = 2
    End If
    mm = ""
    For fc = 1 To Ti
        sStr = TargetFile(fc)
        Set f1 = fs.getfile(sStr)
        TmpName = f1.Name
        Windows(f1.Name).Activate
        If err.Number = 0 Then GoTo FNext
        err.Clear
        If InStr(1, TmpName, "[") > 0 Or InStr(1, TmpName, "]") > 0 Then
        Else
            TmpName = Replace(TmpName, "'", "''")
            mm = "='" & FolderName & "\[" & TmpName & "]" & "" & "'!a1"
            Cells(1, 1).Formula = mm
            If err.Number > 0 Then
                err.Clear
                If MsgBox("Warning!" & vbCrLf & "The list of sheet names is extracted from Workbook < " & f1.Name & " >." & vbCrLf & " Are you sure you want to input sheet names by yourself?", 4) <> 6 Then
                    Exit Sub
                Else
                    ShName = Application.InputBox _
                             (prompt:="Input your own sheet name(e.g. BalanceSheet)", _
                              Default:=ShName, Type:=2)
                    If ShName = "False" Then Exit Sub
                End If
            Else
                mm = Cells(1, 1).Formula
                X = InStr(1, mm, "]")
                mm = Mid(mm, X + 1, Len(mm) - X - 4)
                If mm <> "" Then ShName = mm
            End If
            Exit For
        End If
FNext:
    Next
    If mm = "" Then
        MsgBox ("All workbooks are open or have irregular names containing [ or ].")
        Exit Sub
    End If


    If InStr(1, ShName, "[") > 0 Or InStr(1, ShName, "]") > 0 Then
        MsgBox ("Worksheet < " & ShName & " > - Name irregular, cannot contain [ or ]")
        GoTo InpShName
    End If
    ShName = Replace(ShName, "'", "''")
    Cells(1, 1).Clear
    Sheets(sFNt).Select

    Application.ScreenUpdating = True

InpRange:
    If sStart = "" Or sStart = "False" Then sStart = "a1"
    sStart = Application.InputBox _
             (prompt:="Input start cell here(e.g. a1)", _
              Default:=sStart, Type:=2)
    If sStart = "False" Then Exit Sub

    If sEnd = "" Or sEnd = "False" Then sEnd = "b1"
    sEnd = Application.InputBox _
           (prompt:="Input end cell here (e.g. g3)", _
            Default:=sEnd, Type:=2)
    If sEnd = "False" Then Exit Sub

    rStart = Range(sStart).Row
    rEnd = Range(sEnd).Row
    cStart = Range(sStart).Column
    cEnd = Range(sEnd).Column
    If rStart > rEnd Or cStart > cEnd Then
        MsgBox ("start cell has exceeded end cell.")
        GoTo InpRange
    End If

    logic = Application.InputBox _
            (prompt:="Input your preferred layout (1<as columns>, 2<as rows>, or any number>0)", _
             Default:=9, Type:=1)
    If logic = 0 Then Exit Sub

InpPos:
    Sheets(sSheet).Select
    If err.Number > 0 Then
        err.Clear
        sSheet = ActiveSheet.Name
    End If
    Cells(xp, yp).Select
    If err.Number > 0 Then
        err.Clear
        xp = Selection.Row
        yp = Selection.Column
    End If
    xyRC = sSheet & "!" & Selection.Address

    Set myCell = Application.InputBox( _
                                      prompt:="Select a cell to place the result", Default:=xyRC, Type:=8)
    If err.Number > 0 Then
        If err.Number <> 424 Then
            MsgBox err.Number & err.Description
        End If
        err.Clear
        Exit Sub
    End If

    sSheet = myCell.Parent.Name
    X = myCell.Row: xp = X
    Y = myCell.Column: yp = Y

    Sheets(sSheet).Select
    x1 = 1   ' meaning in rows
    If rEnd - rStart > cEnd - cStart Then x1 = 0
    y1 = 1 - x1

    sCount = Ti - 1

    If Y + (cEnd - cStart + 1) * y1 * sCount + x1 + cEnd - cStart > 16 Then
        x1 = 1: y1 = 0
    End If
    If logic = 1 Then
        x1 = 0
    End If
    If logic = 2 Then
        x1 = 1
    End If
    y1 = 1 - x1
    Range(Cells(X, Y), Cells(X + (rEnd - rStart + 1) * x1 * sCount + y1 + rEnd - rStart, Y + (cEnd - cStart + 1) * y1 * sCount + x1 + cEnd - cStart)).Select
    If err.Number > 0 Then
        err.Clear
        MsgBox ("Too many rows or columns.  Exceeding EXCEL's limits.  Cannot continue.")
        Exit Sub
    End If
    If MsgBox("This range may be covered?", 1) <> 1 Then
        GoTo InpPos
    End If

    Selection.Clear
    lLl = True

    sLink = False
    sStr = Application.InputBox(prompt:="Use linkage? (Y-linkage, n-paste value only)", Default:="N", Type:=2)
    If sStr = "false" Then Exit Sub
    If sStr = "y" Then sLink = True
    If (sCount + 1) * (cEnd - cStart + 1) * (rEnd - rStart + 1) > 800000 And sLink = True Then
        sLink = False
        MsgBox ("The file may be too big.  Links won't be used.")
    End If

    For fc = 1 To Ti
        sStr = TargetFile(fc)
        Set f1 = fs.getfile(sStr)
        TmpName = f1.Name
        If lLl Then
            If InStr(1, TmpName, "[") > 0 Or InStr(1, TmpName, "]") > 0 Then
                lLl = False
                If MsgBox("File < " & TmpName & " >'s name is irregular, containing [ or ].  I can continue, but later may need you to press <cancel> many times." & vbCrLf & "I suggest that you cancel this operation and rename those irregular files.  Cancel?", 4) = 6 Then
                    Exit Sub
                End If
            End If
        End If
        TmpName = Replace(TmpName, "[", "(")
        TmpName = Replace(TmpName, "]", ")")
        TmpName = Replace(TmpName, "'", "''")
        mm = "='" & FolderName & "\[" & TmpName & "]" & ShName & "'!" & sStart
        Sheets(sSheet).Select
        x2 = X + (rEnd - rStart + 1) * x1
        y2 = Y + (cEnd - cStart + 1) * y1
        Cells(X, Y) = "[" & f1.Name & "]" & ShName
        Cells(X, Y).Select
        Cells(X, Y).Interior.ColorIndex = 6
        Cells(X, Y).Font.Bold = True
        Cells(X + y1, Y + x1).Formula = mm
        If err.Number > 0 Then
            err.Clear
            Cells(X, Y).Interior.ColorIndex = 3
            mName = ShName
        Else
            Cells(X + y1, Y + x1).Copy
            Range(Cells(X + y1, Y + x1), Cells(X + y1 + rEnd - rStart, Y + x1 + cEnd - cStart)).Select
            ActiveSheet.Paste
            mm = Cells(X + y1, Y + x1).Formula
            If Cells(X + y1 + rEnd - rStart, Y + x1 + cEnd - cStart).Text <> "#REF!" Then
                Cells(X + y1, Y + x1).Formula = mm
            End If
            If rEnd = rStart And cEnd = cStart Then
                Cells(X + y1, Y + x1).Formula = mm
            End If
            nTmp1 = InStr(1, mm, "]")
            nTmp2 = Len(mm) - Len(sStart) - 2 - nTmp1
            mName = Mid(mm, nTmp1 + 1, nTmp2)
            If sLink = False Then
                Selection.Copy
                Selection.PasteSpecial Paste:=xlPasteValues
            End If
            For Each c In Selection
                If c.Value = 0 Then c.NumberFormatLocal = "_ * #,##0.00_ ;_ * -#,##0.00_ ;_ * ""-""??_ ;_ @_ "
            Next c
            err.Clear
        End If
        Range(Cells(X, Y), Cells(x2 - x1, y2 - y1)) = "[" & f1.Name & "]" & mName
        X = x2
        Y = y2
    Next
    X = xp: Y = yp

    Range(Cells(X, Y), Cells(X + (rEnd - rStart + 1) * x1 * sCount + y1 + rEnd - rStart, Y + (cEnd - cStart + 1) * y1 * sCount + x1 + cEnd - cStart)).Select
    Selection.EntireColumn.AutoFit

    sSort = Application.InputBox _
            (prompt:="Sorting order (a-ascending, d-descending, n-no sorting)", _
             Default:="a", Type:=2)
    If sSort = "a" Then
        If x1 = 0 Then
            Selection.Sort key1:=Cells(X, Y), order1:=xlAscending, header:=xlNo, Orientation:=xlSortRows
        Else
            Selection.Sort key1:=Cells(X, Y), order1:=xlAscending, header:=xlNo, Orientation:=xlSortColumns
        End If
    End If
    If sSort = "d" Then
        If x1 = 0 Then
            Selection.Sort key1:=Cells(X, Y), order1:=xlDescending, header:=xlNo, Orientation:=xlSortRows
        Else
            Selection.Sort key1:=Cells(X, Y), order1:=xlDescending, header:=xlNo, Orientation:=xlSortColumns
        End If
    End If

    Application.CutCopyMode = False

    err.Clear
End Sub

Sub format_cell()

    With Selection
        .HorizontalAlignment = xlLeft
        .VerticalAlignment = xlTop
        .WrapText = True
        .Orientation = 0
        .AddIndent = False
        .IndentLevel = 0
        .ShrinkToFit = False
        .ReadingOrder = xlContext
        .MergeCells = True
    End With

End Sub
Sub HideAllToolbars()
    Dim TB As CommandBar
    Dim TBNum As Integer
    Dim TBSheet As Worksheet
    Dim HelpMenu As CommandBarControl
    Dim NewMenu As CommandBarPopup
    Dim MenuItem As CommandBarControl
    
    Set TBSheet = ThisWorkbook.Sheets("Ian")
    Application.ScreenUpdating = False

'   Clear the cells
    TBSheet.Range("h:h").Clear
    
'   Hide all visible toolbars and store
'   their names
    TBNum = 0
    For Each TB In CommandBars
        If TB.Type = msoBarTypeNormal Then
            If TB.Visible Then
                TBNum = TBNum + 1
                TB.Visible = False
                TBSheet.Cells(TBNum, 8) = TB.Name
            End If
        End If
    Next TB
    
'   Find the Help Menu
    Set HelpMenu = CommandBars(1).FindControl(ID:=30010)
    
    If HelpMenu Is Nothing Then
'       Add the menu to the end
        Set NewMenu = CommandBars(1).Controls.Add _
          (Type:=msoControlPopup, _
           temporary:=True)
    Else
'      Add the menu before Help
        Set NewMenu = CommandBars(1).Controls.Add _
          (Type:=msoControlPopup, _
           before:=HelpMenu.Index, _
           temporary:=True)
    End If

'   Add a caption for the menu
    NewMenu.Caption = "&RestoreBars"
    
'   FIRST MENU ITEM
    Set MenuItem = NewMenu.Controls.Add _
      (Type:=msoControlButton)
    With MenuItem
        .Caption = "&Restore"
        .FaceId = 213
        .OnAction = "RestoreToolbars"
    End With
            
    Application.ScreenUpdating = True
End Sub

Sub RestoreToolbars()
    Dim TBSheet As Worksheet
    Dim cell As Range
    
    Set TBSheet = ThisWorkbook.Sheets("Ian")
    Application.ScreenUpdating = False

'   Unhide the previously displayed the toolbars
    On Error Resume Next
    For Each cell In TBSheet.Range("h:h") _
      .SpecialCells(xlCellTypeConstants)
        CommandBars(cell.Value).Visible = True
    Next cell
    
    On Error Resume Next
    CommandBars(1).Controls("RestoreBars").Delete

    Application.ScreenUpdating = True
End Sub

Sub Insert_sheet()
    Sheets.Add Type:="Worksheet"
End Sub
Private Sub round()
    Dim d As Integer
    Dim i As String
    
    d = Application.InputBox(prompt:="Please input the decimal places to round", _
        Title:="Decimal places", Type:=1)
    
    round_formula (d)
    round_figure (d)
        
End Sub

Private Sub round_formula(d As Integer)
    
    On Error GoTo ErrorHandler
    Dim my_cell As Range, s As String, r As Range
    Dim pos As Integer, dec_s As String, dec_i As Long
    
    'Find range containing formulas within selection
    Set r = Application.Intersect(Selection, ActiveSheet.Cells.SpecialCells(xlCellTypeFormulas))
    
    If Not r Is Nothing Then
        For Each my_cell In r
            If IsNumeric(my_cell.Value) Then
                s = Trim(my_cell.Formula)
                If Left(s, 1) = "=" Then
                    s = "=" & Trim(Mid(s, 2))
                    
                    'If, Already rounded
                    If UCase(Left(s, 6)) = "=ROUND" And Right(s, 1) = ")" Then
                        s = Trim(Left(s, Len(s) - 1)) & ")"
                        pos = my_instrrev(s, ",")                       'Find last comma
                        s = Left(s, pos) & Trim(Mid(s, pos + 1, Len(s) - pos - 1)) & ")"
                        pos = my_instrrev(s, ",")                       'Find last comma
                        dec_s = Mid(s, pos + 1, Len(s) - pos - 1)
                        dec_i = Int(Val(dec_s))                         'Get old rounding decimal
                        my_cell.Formula = Left(s, pos) & LTrim(str(d)) & ")"
                    'Else, Not rounded yet
                    Else
                        my_cell.Formula = "=ROUND(" & Mid(my_cell.Formula, 2) & "," & _
                            LTrim(str(d)) & ")"
                    End If
                Else
                    my_cell.Formula = "=ROUND(" & my_cell.Formula & LTrim(str(d)) & ")"
                End If
            End If
        Next my_cell
    End If
    
    Exit Sub
    
ErrorHandler:
End Sub

Private Sub round_figure(d As Integer)

    On Error GoTo ErrorHandler
    Dim my_cell As Range, s As String, r As Range
    Dim pos As Integer, dec_s As String, dec_i As Long
    
    'Find range containing figures within selection
    Set r = Application.Intersect(Selection, ActiveSheet.Cells.SpecialCells(xlCellTypeConstants))
    
    If Not r Is Nothing Then
        For Each my_cell In r
            If IsNumeric(my_cell.Value) Then
                my_cell.Formula = "=ROUND(" & my_cell.Formula & "," & LTrim(str(d)) & ")"
            End If
        Next my_cell
    End If

    Exit Sub

ErrorHandler:
End Sub
Function my_instrrev(s1 As String, s2 As String) As Integer
'Same as Excel2000's application.InStrRev(), for Excel97
    
    Dim pos As Integer, i As Integer
    
    For i = 1 To Len(s1)
        pos = InStr(Right(s1, i), s2)
        If pos <> 0 Then Exit For
    Next i
    
    my_instrrev = Len(s1) + 1 - i

End Function

Sub value_only()

' cannot be run on a structure-protected workbook.  If not using "temp_temp__" sheet as buffer, but using a new workbook, then it can.
' above can be next project for <valueonly>, <formulaonly> and <paste_ind>.
' K-Paste has been revised as it should have such function.  Others can use a new workbook to do the pasting, then use K-paste to re-paste.
' if sheets are multiple-selected, this procedure CAN process multiple sheets.

    Dim z(2), zy(2), m As String, mf As String, s As String, nc As Long, nr As Long, w As Integer
    Dim l As Integer, kmax As Integer, base As Integer, ss As Integer, lockcheck As Boolean, p As Long, q As Long
    Dim ymax As Long, cf As String, cg As String, X As Long, Y As Long, baseR As Long, baseC As Long, TargetR As Long, TargetC As Long, ssc As Long, ssr As Long
    Dim lla As Boolean, llb As Boolean, sR As Long, sc As Long, cc As Long, cr As Long, minRa As Long, minRb As Long, minCa As Long, minCb As Long
    Dim ccMode As Long, ma As String, sh, ShSelected
    On Error Resume Next
    Application.ScreenUpdating = False
    ccMode = Application.CutCopyMode
    m = ActiveSheet.Name
    mf = ActiveWorkbook.Name
    Set ShSelected = ActiveWindow.SelectedSheets
    s = "temp_temp__"
    nc = Selection.Column
    nr = Selection.Row
    w = 1
    l = 0
    kmax = 30
    base = 0
    ss = 0
    GoTo cont
    Exit Sub
cont:
    Windows(mf).Activate
    Sheets(s).Activate
    If err.Number = 9 Then
        GoTo addsheet
    Else
        If err.Number > 0 Then GoTo ErrorHandler
    End If
    Cells(nr, nc).Select
    ActiveSheet.Paste
    If err.Number > 0 Then GoTo ErrorHandler
    z(1) = Selection.Rows.Count
    z(2) = Selection.Columns.Count
    If z(2) > z(1) Then w = 2
    ymax = z(w)
    For X = 1 To z(3 - w)
        For Y = 1 To ymax
            zy(w) = Y: zy(3 - w) = X
            If X > kmax Or Y > kmax Then
                If l = 0 Or Y = 1 Then
                    GoSub mycheck
                End If
            End If
            If l > 0 And ss = 0 Then
                If base = 1 Then GoSub mypaste1
                Exit For
            End If
            Sheets(s).Activate
            Cells(zy(1) + nr - 1, zy(2) + nc - 1).Select
            lockcheck = True
            cf = Selection.FormulaR1C1
            cg = Selection.FormulaLocal
            If cf = cg Then
                If IsError(Selection) = False Then
                    err.Clear
                    lockcheck = False
                End If
            End If
            err.Clear
            If base = 0 And lockcheck = False Then
                base = 1: baseR = zy(1): baseC = zy(2)
            End If
            If base = 1 And lockcheck = False Then
                TargetR = zy(1): TargetC = zy(2)
            End If
            If base = 1 And lockcheck = True Then
                GoSub mypaste1
            End If
        Next Y
        If l = 2 Then Exit For
        If ymax <> z(w) Then ss = 1
    Next X
    If l > 0 Then
        If lla = False Then
            sR = minRa: sc = minCa: cr = z(1): cc = z(2)
            GoSub mypaste2
        End If
        If l = 2 And llb = False Then
            sR = minRb: sc = minCb: cr = p: cc = q
            GoSub mypaste2
        End If
    End If
    If base = 1 Then GoSub mypaste1
    Sheets(s).Activate
    Cells.Clear
    Sheets(m).Activate
    Range(Cells(nr, nc), Cells(z(1) - 1 + nr, z(2) - 1 + nc)).Select
    Selection.Copy
    For Each sh In ShSelected
        ma = sh.Name
        If ma <> m Then
            Sheets(ma).Activate
            Cells(nr, nc).Select
            ActiveSheet.Paste
            err.Clear
        End If
    Next sh
    If ccMode = 1 Then
        Sheets(s).Activate
        Cells(nr, nc).Select
        ActiveSheet.Paste
        Range(Cells(nr, nc), Cells(z(1) - 1 + nr, z(2) - 1 + nc)).Copy
    End If

    ShSelected.Select
    Sheets(m).Activate
    Range(Cells(nr, nc), Cells(z(1) - 1 + nr, z(2) - 1 + nc)).Select

    Application.ScreenUpdating = True
    Exit Sub
mypaste1:
    If w = 1 Then
        If baseC = TargetC Then
            sR = baseR: sc = baseC: cr = TargetR: cc = TargetC
            GoSub mypaste2
        End If
        If baseC = TargetC - 1 Then
            sR = baseR: sc = baseC: cr = ymax: cc = baseC
            GoSub mypaste2
            sR = 1: sc = TargetC: cr = TargetR: cc = TargetC
            GoSub mypaste2
        End If
        If baseC < TargetC - 1 Then
            sR = baseR: sc = baseC: cr = ymax: cc = baseC
            GoSub mypaste2
            sR = 1: sc = baseC + 1: cr = ymax: cc = TargetC - 1
            GoSub mypaste2
            sR = 1: sc = TargetC: cr = TargetR: cc = TargetC
            GoSub mypaste2
        End If
    Else
        If baseR = TargetR Then
            sR = baseR: sc = baseC: cr = TargetR: cc = TargetC
            GoSub mypaste2
        End If
        If baseR = TargetR - 1 Then
            sR = baseR: sc = baseC: cr = baseR: cc = ymax
            GoSub mypaste2
            sR = TargetR: sc = 1: cr = TargetR: cc = TargetC
            GoSub mypaste2
        End If
        If baseR < TargetR - 1 Then
            sR = baseR: sc = baseC: cr = baseR: cc = ymax
            GoSub mypaste2
            sR = baseR + 1: sc = 1: cr = TargetR - 1: cc = ymax
            GoSub mypaste2
            sR = TargetR: sc = 1: cr = TargetR: cc = TargetC
            GoSub mypaste2
        End If
    End If
    base = 0
    Return
mypaste2:
    Sheets(s).Activate
    Range(Cells(sR + nr - 1, sc + nc - 1), Cells(cr + nr - 1, cc + nc - 1)).Copy
    Sheets(m).Activate
    Cells(nr + sR - 1, nc + sc - 1).Select
    Selection.PasteSpecial Paste:=xlValues
    Return
mycheck:
    lockcheck = True
    If l = 0 Then
        Sheets(s).Activate
        Range(Cells(zy(1) + nr - 1, zy(2) + nc - 1), Cells(z(1) + nr - 1, z(2) + nc - 1)).Select
        If Selection.HasFormula = False Then
            err.Clear
            lockcheck = False
        End If
        err.Clear
        If lockcheck = False Then
            l = 1: lla = False: minRa = zy(1): minCa = zy(2): ymax = Y - 1
            If w = 1 Then
                p = minRa - 1: q = z(2)
            Else
                p = z(1): q = minCa - 1
            End If
        End If
    Else
        Sheets(s).Activate
        Range(Cells(zy(1) + nr - 1, zy(2) + nc - 1), Cells(p + nr - 1, q + nc - 1)).Select
        If Selection.HasFormula = False Then
            err.Clear
            lockcheck = False
        End If
        err.Clear
        If lockcheck = False Then
            l = 2: llb = False: minRb = zy(1): minCb = zy(2): ss = 0
        End If
    End If
    Return
addsheet:
    err.Clear
    Sheets.Add Count:=1
    If err.Number > 0 Then
        err.Clear
        MsgBox ("The application cannot be run on an active workbook which is structure-protected.")
        Exit Sub
    End If
    ActiveSheet.Name = s
    Sheets(s).Visible = 2
    GoTo cont
ErrorHandler:
    If err.Number = 1004 And InStr(1, err.Description, "The information cannot be pasted") = 1 Then
        MsgBox err.Description
        Sheets(m).Activate
        Exit Sub
    End If
    If err.Number = 1004 Then
        MsgBox "Please copy the contents to clipboard first." & vbCrLf & vbCrLf & "|fffd||fffd||fffd||23d||fffd||4aa||573||fffd||fffd||fffd||fffd||fffd||fffd||fffd||778||fffd||fffd||1b5||fffd||573||fffd||fffd||fffd||fffd||fffd||fffd|."
    Else
        MsgBox err.Number & " " & err.Description
    End If
    Sheets(s).Activate
    Cells.Clear
    Sheets(m).Activate
    Application.ScreenUpdating = True
    Exit Sub

End Sub
Sub formular_only()

' cannot be run on a structure-protected workbook.  If not using "temp_temp__" sheet as buffer, but using a new workbook, then it can.
' above can be next project for <valueonly>, <formulaonly> and <paste_ind>.
' K-Paste has been revised as it should have such function.  Others can use a new workbook to do the pasting, then use K-paste to re-paste.
' if sheets are multiple-selected, this procedure CAN process multiple sheets.

    Dim z(2), zy(2)
    Dim m As String, mf As String, s As String, nc As Long, nr As Long, w As Integer
    Dim l As Integer, kmax As Integer, base As Integer, ss As Integer, lockcheck As Boolean, p As Long, q As Long
    Dim ymax As Long, cf As String, cg As String, X As Long, Y As Long, baseR As Long, baseC As Long, TargetR As Long, TargetC As Long
    Dim lla As Boolean, llb As Boolean, sR As Long, sc As Long, cc As Long, cr As Long, minRa As Long, minRb As Long, minCa As Long, minCb As Long
    Dim ccMode As Long, ma As String, sh, ShSelected
    On Error Resume Next
    Application.ScreenUpdating = False
    ccMode = Application.CutCopyMode
    m = ActiveSheet.Name
    mf = ActiveWorkbook.Name
    Set ShSelected = ActiveWindow.SelectedSheets
    s = "temp_temp__"
    nc = Selection.Column
    nr = Selection.Row
    w = 1
    l = 0
    kmax = 30
    base = 0
    ss = 0
    GoTo cont
    Exit Sub
cont:
    Windows(mf).Activate
    Sheets(s).Activate
    If err.Number = 9 Then
        GoTo addsheet
    Else
        If err.Number > 0 Then GoTo ErrorHandler
    End If
    Cells(nr, nc).Select
    ActiveSheet.Paste
    If err.Number > 0 Then GoTo ErrorHandler
    z(1) = Selection.Rows.Count
    z(2) = Selection.Columns.Count
    If z(2) > z(1) Then w = 2
    ymax = z(w)
    For X = 1 To z(3 - w)        ' x is the shorter axis, y is the longer
        For Y = 1 To ymax
            zy(w) = Y: zy(3 - w) = X  ' zy(1) must be row no, zy(2) must be col. no.
            If X > kmax Or Y > kmax Then
                If l = 0 Or Y = 1 Then  ' why?
                    GoSub mycheck
                End If
            End If
            If l > 0 And ss = 0 Then   ' why?
                If base = 1 Then GoSub mypaste1
                Exit For
            End If
            Sheets(s).Activate
            Cells(zy(1) + nr - 1, zy(2) + nc - 1).Select
            lockcheck = False    ' lockcheck=false means formula is there, OK to paste.
            cf = Selection.FormulaR1C1
            cg = Selection.FormulaLocal
            If cf = cg Then           ' cf=cg means no formula
                If IsError(Selection) = False Then
                    err.Clear
                    lockcheck = True
                End If
            End If
            err.Clear
            If base = 0 And lockcheck = False Then    ' base=0 means no copy area yet
                base = 1: baseR = zy(1): baseC = zy(2)
            End If
            If base = 1 And lockcheck = False Then
                TargetR = zy(1): TargetC = zy(2)
            End If
            If base = 1 And lockcheck = True Then
                GoSub mypaste1
            End If
        Next Y
        If l = 2 Then Exit For
        If ymax <> z(w) Then ss = 1
    Next X
    If l > 0 Then
        If lla = False Then
            sR = minRa: sc = minCa: cr = z(1): cc = z(2)
            GoSub mypaste2
        End If
        If l = 2 And llb = False Then
            sR = minRb: sc = minCb: cr = p: cc = q
            GoSub mypaste2
        End If
    End If
    If base = 1 Then GoSub mypaste1
    Sheets(s).Activate
    Cells.Clear
    Sheets(m).Activate
    Range(Cells(nr, nc), Cells(z(1) - 1 + nr, z(2) - 1 + nc)).Select
    Selection.Copy
    For Each sh In ShSelected
        ma = sh.Name
        If ma <> m Then
            Sheets(ma).Activate
            Cells(nr, nc).Select
            ActiveSheet.Paste
            err.Clear
        End If
    Next sh
    If ccMode = 1 Then
        Sheets(s).Activate
        Cells(nr, nc).Select
        ActiveSheet.Paste
        Range(Cells(nr, nc), Cells(z(1) - 1 + nr, z(2) - 1 + nc)).Copy
    End If

    ShSelected.Select
    Sheets(m).Activate
    Range(Cells(nr, nc), Cells(z(1) - 1 + nr, z(2) - 1 + nc)).Select

    Application.ScreenUpdating = True
    Exit Sub
mypaste1:
    If w = 1 Then
        If baseC = TargetC Then
            sR = baseR: sc = baseC: cr = TargetR: cc = TargetC
            GoSub mypaste2
        End If
        If baseC = TargetC - 1 Then
            sR = baseR: sc = baseC: cr = ymax: cc = baseC
            GoSub mypaste2
            sR = 1: sc = TargetC: cr = TargetR: cc = TargetC
            GoSub mypaste2
        End If
        If baseC < TargetC - 1 Then
            sR = baseR: sc = baseC: cr = ymax: cc = baseC
            GoSub mypaste2
            sR = 1: sc = baseC + 1: cr = ymax: cc = TargetC - 1
            GoSub mypaste2
            sR = 1: sc = TargetC: cr = TargetR: cc = TargetC
            GoSub mypaste2
        End If
    Else
        If baseR = TargetR Then
            sR = baseR: sc = baseC: cr = TargetR: cc = TargetC
            GoSub mypaste2
        End If
        If baseR = TargetR - 1 Then
            sR = baseR: sc = baseC: cr = baseR: cc = ymax
            GoSub mypaste2
            sR = TargetR: sc = 1: cr = TargetR: cc = TargetC
            GoSub mypaste2
        End If
        If baseR < TargetR - 1 Then
            sR = baseR: sc = baseC: cr = baseR: cc = ymax
            GoSub mypaste2
            sR = baseR + 1: sc = 1: cr = TargetR - 1: cc = ymax
            GoSub mypaste2
            sR = TargetR: sc = 1: cr = TargetR: cc = TargetC
            GoSub mypaste2
        End If
    End If
    base = 0
    Return
mypaste2:
    Sheets(s).Activate
    Range(Cells(sR + nr - 1, sc + nc - 1), Cells(cr + nr - 1, cc + nc - 1)).Copy
    Sheets(m).Activate
    Cells(nr + sR - 1, nc + sc - 1).Select
    Selection.PasteSpecial Paste:=xlFormulas
    Return
mycheck:
    lockcheck = False  ' lockcheck=false means formula is there, OK to paste.
    If l = 0 Then
        Sheets(s).Activate
        Range(Cells(zy(1) + nr - 1, zy(2) + nc - 1), Cells(z(1) + nr - 1, z(2) + nc - 1)).Select
        If Selection.HasFormula = False Then   'no formula to copy.
            err.Clear
            lockcheck = True
        End If
        err.Clear
        If lockcheck = True Then
            l = 1: lla = True: minRa = zy(1): minCa = zy(2): ymax = Y - 1  'l=1 means first area resolved.
            If w = 1 Then
                p = minRa - 1: q = z(2)
            Else
                p = z(1): q = minCa - 1
            End If
        End If
    Else
        Sheets(s).Activate
        Range(Cells(zy(1) + nr - 1, zy(2) + nc - 1), Cells(p + nr - 1, q + nc - 1)).Select
        If Selection.HasFormula = False Then
            err.Clear
            lockcheck = True
        End If
        err.Clear
        If lockcheck = True Then
            l = 2: llb = True: minRb = zy(1): minCb = zy(2): ss = 0
        End If
    End If
    Return
addsheet:
    err.Clear
    Sheets.Add Count:=1
    If err.Number > 0 Then
        err.Clear
        MsgBox ("The application cannot be run on an active workbook which is structure-protected.")
        Exit Sub
    End If
    ActiveSheet.Name = s
    Sheets(s).Visible = 2
    GoTo cont
ErrorHandler:
    If err.Number = 1004 And InStr(1, err.Description, "The information cannot be pasted") = 1 Then
        MsgBox err.Description
        Sheets(m).Activate
        Exit Sub
    End If
    If err.Number = 1004 Then
        MsgBox "Please copy the contents to clipboard first." & vbCrLf & vbCrLf & "|fffd||fffd||fffd||23d||fffd||4aa||573||fffd||fffd||fffd||fffd||fffd||fffd||fffd||778||fffd||fffd||1b5||fffd||573||fffd||fffd||fffd||fffd||fffd||fffd|."
    Else
        MsgBox err.Number & " " & err.Description
    End If
    Sheets(s).Activate
    Cells.Clear
    Sheets(m).Activate
    Application.ScreenUpdating = True
    Exit Sub

End Sub
Sub Insert_cell()
    Application.SendKeys ("{%}ie")
End Sub
Sub TNR()
    With Selection.Font
        .Name = "Times New Roman"
    End With
End Sub
Sub clear_zero(clClear As Boolean, fClear As Boolean, Optional UseRan As Range)

    Dim clTmp1 As Long, clTmp2 As Long, clTmp3 As Long, clX As Long, clY As Long, clDisp As Byte

    On Error GoTo errHandler

    clDisp = 0
    clendC = -3
    clendC = UseRan.Columns.Count

    If clClear = True Or clendC = -3 Then Set UseRan = ActiveSheet.UsedRange

    With UseRan
        clendR = .Row
        clendC = .Column
        clX = .Rows.Count
        clY = .Columns.Count
        If clX = 0 Or clY <= 0 Then
            clendR = 0
            clendC = 0
            Exit Sub
        End If
        If .Cells(clX, clY).Value = "" Then clDisp = 1: .Cells(clX, clY).Value = 0: .Cells(clX, clY).Clear: clDisp = 0
        For clTmp1 = clX To 1 Step -1
            clTmp2 = Application.WorksheetFunction.CountIf(Range(.Cells(clTmp1, 1), .Cells(clTmp1, clY)), "") + Application.WorksheetFunction.CountIf(Range(.Cells(clTmp1, 1), .Cells(clTmp1, clY)), 0)
            clTmp3 = Application.WorksheetFunction.CountIf(Range(.Cells(clTmp1, 1), .Cells(clTmp1, clY)), "#REF!")
            If Not (clTmp2 + clTmp3 = clY And clTmp2 * clTmp3 = 0) Then Exit For

            If Not fClear Then
                If Range(.Cells(clTmp1, 1), .Cells(clTmp1, clY)).HasFormula = False Then
                Else
                    Exit For
                End If
            End If

        Next
        If clClear Then
            If clTmp1 = 0 Then
                If clX > 1 Then Range(.Cells(2, 1), .Cells(clX, 1)).EntireRow.Clear
                If clY > 1 Then Range(.Cells(1, 2), .Cells(1, clY)).EntireColumn.Clear
            Else
                If clTmp1 < clX Then Range(.Cells(clTmp1 + 1, 1), .Cells(clX, clY)).EntireRow.Clear
            End If
        End If
        clX = clTmp1
        If clX = 0 Then
            clendR = 0: clendC = 0
            Exit Sub
        End If
        For clTmp1 = clY To 1 Step -1
            clTmp2 = Application.WorksheetFunction.CountIf(Range(.Cells(1, clTmp1), .Cells(clX, clTmp1)), "") + Application.WorksheetFunction.CountIf(Range(.Cells(1, clTmp1), .Cells(clX, clTmp1)), 0)
            clTmp3 = Application.WorksheetFunction.CountIf(Range(.Cells(1, clTmp1), .Cells(clX, clTmp1)), "#REF!")
            If Not (clTmp2 + clTmp3 = clX And clTmp2 * clTmp3 = 0) Then Exit For

            If Not fClear Then
                If Range(.Cells(1, clTmp1), .Cells(clX, clTmp1)).HasFormula = False Then
                Else
                    Exit For
                End If
            End If

        Next

        If clTmp1 < clY And clClear Then Range(.Cells(1, clTmp1 + 1), .Cells(clX, clY)).EntireColumn.Clear
    End With

    clendR = clX + clendR - 1: clendC = clTmp1 + clendC - 1
    Exit Sub

errHandler:
    If err.Number = 91 And clendC = -3 Then err.Clear: Resume Next
    If clDisp = 0 Then
        MsgBox ("Certain worksheets are protected and maynot be changed.  --" & ActiveSheet.Name & vbCrLf & err.Number & "  " & err.Description)
        clDisp = 1
    End If
    err.Clear
    Resume Next

End Sub
Sub CommentsRe()
    Dim cell As Range
    Dim s As String
    
    On Error Resume Next
    For Each cell In ActiveSheet.Cells.SpecialCells(xlCellTypeComments)
        s = cell.Comment.Text
        cell.ClearComments
        cell.AddComment
        cell.Comment.Visible = True
        cell.Comment.Text Text:=s
    Next
End Sub
Sub SumSelection()
    Dim cell As Range
    Dim i As Double
    
    For Each cell In Selection
        i = cell.Value + i
    Next
    
    ActiveSheet.Range("iv65536").Value = i
    ActiveSheet.Range("iv65536").Copy
End Sub
Sub LinkCellList()
    Dim LinkCell
    Dim i As Integer
    Dim l As Integer
    Dim m As Integer
    l = 3
    m = ActiveWorkbook.Sheets.Count
    Sheets.Add before:=ActiveWorkbook.Sheets(1)
    For i = 1 To m
    Set LinkCell = ActiveWorkbook.Worksheets(i).UsedRange.Find("[", LookIn:=xlFormulas)
        If LinkCell Is Nothing Then GoTo err
            With ActiveWorkbook.Sheets(1)
                With .Cells(1, 1)
                    .Value = "CELLS WITH LINK TO OTHER FILES"
                    .Font.Size = 15
                    .Font.Underline = xlUnderlineStyleSingle
                    .Font.Bold = True
                End With
                .Cells(l, 1) = LinkCell.Parent.Name
                .Cells(l, 2) = LinkCell.Address
            End With
        l = l + 1
err: Next
    If ActiveWorkbook.Sheets(1).Cells(1, 1) = "" Then ActiveWorkbook.Sheets(1).Cells(1, 1) = "No cells with link to other files found in this workbook."
End Sub
Attribute VB_Name = "Selector"
Attribute VB_Base = "0{88719E0A-D53A-4F86-81C1-FE014CF04E50}{FC4CB47F-D3CE-4888-B7E7-6818B41EA273}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

Private Sub SelectAllButton_Click()
    Dim r As Integer
    For r = 0 To ListBox1.ListCount - 1
        ListBox1.Selected(r) = True
    Next r
End Sub

Private Sub SelectNoneButton_Click()
    Dim r As Integer
    For r = 0 To ListBox1.ListCount - 1
        ListBox1.Selected(r) = False
    Next r
End Sub

Private Sub UserForm_Initialize()
    Dim Data(1 To 56, 1 To 2)
    Dim cell As Range
    
    Application.EnableEvents = False
        Data(1, 1) = "+/-"
        Data(1, 2) = "Convert figures or formulas from positive to negtive, or vice versa"
        Data(2, 1) = "ROUND"
        Data(2, 2) = "Round figures or formulas"
        Data(3, 1) = "SUM THE COPIED"
        Data(3, 2) = "The sum result of the field copied will be paste"
        Data(4, 1) = "FORMAT NUMBER"
        Data(4, 2) = "Format figures for wp"
        Data(5, 1) = "WRAP TEXT"
        Data(5, 2) = "Wrap/Unwrap Text for wp"
        Data(6, 1) = "FORMAT CELL"
        Data(6, 2) = "Format cells - Wrap & Merge - for Notes"
        Data(7, 1) = "CENTER"
        Data(7, 2) = "Center without merge"
        Data(8, 1) = "REMOVE CENTER"
        Data(8, 2) = "Remove center and make the cell format to general"
        Data(9, 1) = "SINGLE UNDERLINE"
        Data(9, 2) = "Accounting underline for wp"
        Data(10, 1) = "DOUBLE UNDERLINE"
        Data(10, 2) = "Accounting double underline for wp"
        Data(11, 1) = "DOTTING LINE"
        Data(11, 2) = "Bottom dotting line for wp"
        Data(12, 1) = "COMMENTS RESTORE"
        Data(12, 2) = "Drag the comments to the right corner of the cell"
        Data(13, 1) = "TEXT UTILITY"
        Data(13, 2) = "Text related tools"
        Data(14, 1) = "TIMES NEW ROMAN"
        Data(14, 2) = "Change the fonts to TNR for wp"
        Data(15, 1) = "HIDE ROW"
        Data(15, 2) = "Hide the selected rows"
        Data(16, 1) = "UNHIDE ROW"
        Data(16, 2) = "Unhide all the rows"
        Data(17, 1) = "CLEAR ALL BUT FORMULAS"
        Data(17, 2) = "Clear All But Formulas - Be cautious"
        Data(18, 1) = "DELETE EMPTY ROWS"
        Data(18, 2) = "Delete the empty rows"
        Data(19, 1) = "COLUMN HEADING"
        Data(19, 2) = "To set up the repeated columns as print title"
        Data(20, 1) = "ROW HEADING"
        Data(20, 2) = "To set up the repeated rows as print title"
        Data(21, 1) = "DATE CONVERTER"
        Data(21, 2) = "Convert to Date Format"
        Data(22, 1) = "SORT SHEETS"
        Data(22, 2) = "Sort ascending the sheets"
        Data(23, 1) = "GET SHEETS"
        Data(23, 2) = "Get sheets from workbooks"
        Data(24, 1) = "EXTRACT"
        Data(24, 2) = "Extract same position value from this workbook"
        Data(25, 1) = "GLOBAL EXTRACT"
        Data(25, 2) = "Extract same position value from other open workbook"
        Data(26, 1) = "DISPLAY FORMULAS"
        Data(26, 2) = "Display all the formulas"
        Data(27, 1) = "SHEETS NAMES"
        Data(27, 2) = "Get sheets names of this workbook"
        Data(28, 1) = "VALUE ONLY"
        Data(28, 2) = "Only paste value"
        Data(29, 1) = "FORMULA ONLY"
        Data(29, 2) = "Only paste formula"
        Data(30, 1) = "LINKED CELL"
        Data(30, 2) = "List all the cells linked to other workbooks"
        Data(31, 1) = "HIDE TOOLBARS"
        Data(31, 2) = "Hide All Tool Bars"
        Data(32, 1) = "SHOW FACE ID"
        Data(32, 2) = "Show Face ID - for programer"
        Data(33, 1) = "KX - CNCB"
        Data(33, 2) = "Add KX to account code - For CNCB"
        Data(34, 1) = "INSERT SHEET"
        Data(34, 2) = "Insert Sheet"
        Data(35, 1) = "TOGGLE GRIDLINES"
        Data(35, 2) = "Toggle Gridlines"
        Data(36, 1) = "LOCK CELL"
        Data(36, 2) = "Lock Cell"
        Data(37, 1) = "SET PRINT AREA"
        Data(37, 2) = "Set Print Area"
        Data(38, 1) = "MERGE AND CENTER"
        Data(38, 2) = "Merge and center"
        Data(39, 1) = "VBA"
        Data(39, 2) = "VBA"
        Data(40, 1) = "CALCULATOR"
        Data(40, 2) = "Calculator"
        Data(41, 1) = "FILTER"
        Data(41, 2) = "Filter"
        Data(42, 1) = "PIVOT TALBE"
        Data(42, 2) = "Pivot table"
        Data(43, 1) = "SELECT VISIBLE CELLS"
        Data(43, 2) = "Select visible cells"
        Data(44, 1) = "FREEZE PANEL"
        Data(44, 2) = "Freeze Panel"
        Data(45, 1) = "GROUP"
        Data(45, 2) = "Group"
        Data(46, 1) = "UNGROUP"
        Data(46, 2) = "UnGroup"
        Data(47, 1) = "INSERT CELL"
        Data(47, 2) = "Insert Cell"
        Data(48, 1) = "INSERT ROWS"
        Data(48, 2) = "Insert Rows"
        Data(49, 1) = "INSERT COLUMNS"
        Data(49, 2) = "Insert Columns"
        Data(50, 1) = "DELETE CELLS"
        Data(50, 2) = "Delete Cells"
        Data(51, 1) = "DELETE ROWS"
        Data(51, 2) = "Delete Rows"
        Data(52, 1) = "DELETE COLUMNS"
        Data(52, 2) = "Delete Columns"
        Data(53, 1) = "PASTE VALUE"
        Data(53, 2) = "Paste value"
        Data(54, 1) = "PASTE FORMATING"
        Data(54, 2) = "Paste formating"
        Data(55, 1) = "CLEAR CONTENT"
        Data(55, 2) = "Clear Content"
        Data(56, 1) = "CLEAR FORMATING"
        Data(56, 2) = "Clear formating"
    ListBox1.ColumnCount = 2
    ListBox1.List = Data
    
    For Each cell In ThisWorkbook.Worksheets(1).Range("a1:a56")
        If cell.Value = "I Do" Then ListBox1.Selected(cell.Row - 1) = True
    Next
    
    Application.EnableEvents = True
End Sub

Private Sub OKButton_Click()
    Dim RowRange As Range
    Dim RowCnt As Integer
    Dim r As Integer
    Dim ws As Worksheet
    
    Set ws = ThisWorkbook.Worksheets(1)
    RowCnt = 0
    For r = 0 To ListBox1.ListCount - 1
        If ListBox1.Selected(r) Then
            RowCnt = RowCnt + 1
            If RowCnt = 1 Then
                Set RowRange = ws.Cells(r + 1, 1)
                'Set RowRange = ActiveSheet.Rows(r + 1)
            Else
                Set RowRange = Union(RowRange, ws.Cells(r + 1, 1))
                'Set RowRange = Union(RowRange, ActiveSheet.Rows(r + 1))
            End If
        End If
    Next r
    ws.Columns(1).Clear
    If Not RowRange Is Nothing Then RowRange.Value = "I Do"
    Unload Me
    cmdBar
End Sub

Private Sub CancelButton_Click()
    Unload Me
End Sub
Attribute VB_Name = "Sheet6"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet7"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Splash"
Attribute VB_Base = "0{7F7F8FF3-953B-4AEF-AC51-44B21BEB04AC}{6AADCC73-F586-4602-8D0F-2D8C9E32C1B3}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Private Sub Label1_Click()

End Sub
Attribute VB_Name = "Text"
Option Explicit
Public Const APPNAME As String = "Text Tools Utility"
Public Const PROGRESSTHRESHHOLD = 2000
Public UserChoices(1 To 8) As Variant 'stores user's last choices
Public UndoRange As Range ' For undoing
Public UserSelection As Range 'For Udoing

Sub Text_utility()
    Dim InvalidContext As Boolean
    If ActiveSheet Is Nothing Then InvalidContext = True
    If TypeName(ActiveSheet) <> "Worksheet" Then InvalidContext = True
    If InvalidContext Then
        MsgBox "Select some cells in a range.", vbCritical, APPNAME
    Else
        Text_tool.Show 0
    End If
End Sub


Private Sub UndoTextTools()
'   Undoes the last operation
    Dim a As Range
'    On Error GoTo ErrHandler
    Application.ScreenUpdating = False
    With UserSelection
        .Parent.Parent.Activate
        .Parent.Activate
        .Select
    End With
    For Each a In UndoRange.Areas
        a.Formula = ThisWorkbook.Sheets(2).Range(a.Address).Formula
    Next a
    Application.ScreenUpdating = True
    On Error GoTo 0
    Exit Sub
errHandler:
    Application.ScreenUpdating = True
    MsgBox "Can't undo", vbInformation, APPNAME
    On Error GoTo 0
End Sub



Attribute VB_Name = "Text_tool"
Attribute VB_Base = "0{32F91B47-3381-4EE6-8081-42BDCF46A045}{8B7BD687-D012-4020-9E49-E30C78851E81}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit
Option Compare Text

Dim ShowProgress As Boolean
Dim WorkRange As Range
Dim UndoError As Boolean, HaltOperation As Boolean

Private Sub UserForm_Initialize()
    With Me
        .Caption = APPNAME
        .Width = 285
        .Height = 100
    End With
    TextBoxProc1.Left = ComboProc1.Left
    TextBoxProc1.Top = ComboProc1.Top
    TextBoxProc1.Visible = False
    
'   Get previous settings
    UserChoices(1) = GetSetting(APPNAME, "Settings", "OperationIndex", 0)
    UserChoices(2) = GetSetting(APPNAME, "Settings", "ChangeCaseIndex", 0)
    UserChoices(3) = GetSetting(APPNAME, "Settings", "TextToAdd", "")
    UserChoices(4) = GetSetting(APPNAME, "Settings", "AddTextIndex", 0)
    UserChoices(5) = GetSetting(APPNAME, "Settings", "CharsToRemoveIndex", 0)
    UserChoices(6) = GetSetting(APPNAME, "Settings", "RemovePositionIndex", 0)
    UserChoices(7) = GetSetting(APPNAME, "Settings", "RemoveSpacesIndex", 0)
    UserChoices(8) = GetSetting(APPNAME, "Settings", "RemoveCharactersIndex", 0)
    cbSkipNonText.Value = GetSetting(APPNAME, "cbSkipNonText", 0)
    
    With ComboBoxOperation
        .List = Array("Change case", "Add text", "Remove by position", "Remove spaces", "Delete characters")
        .ListIndex = UserChoices(1)
    End With

End Sub

Private Sub ApplyButton_Click()
    If TypeName(Selection) <> "Range" Then
        MsgBox "Selection type: " & TypeName(Selection) & vbCrLf & vbCrLf & "This utility works only with cells and ranges.", vbInformation, APPNAME
        Exit Sub
    End If
    
    If ActiveSheet.ProtectContents = True Then
        MsgBox "The active sheet is protected.", vbCritical, APPNAME
        Exit Sub
    End If
    
    Set WorkRange = Selection
    
'   Warn if first area of multiple selection is a merged cell
    If WorkRange.Areas.Count > 1 Then
        If WorkRange.Areas(1).MergeCells = True Then
            MsgBox "The first cell of your multiple selection is a merged cell." & vbCrLf & vbCrLf & "Because of a bug in Excel, this type of selection will not work with this utility.", vbInformation, APPNAME
            Exit Sub
        End If
    End If
    
    UserChoices(1) = ComboBoxOperation.ListIndex
    Select Case ComboBoxOperation.ListIndex
        Case 0 ' Change Case
            UserChoices(2) = ComboProc1.ListIndex
            Set WorkRange = CreateWorkRange(WorkRange, True)
            If Not WorkRange Is Nothing Then
                Call SaveForUndo
                If HaltOperation Then Exit Sub Else Call ChangeCase
            End If
        
        Case 1 ' Add Text
            UserChoices(3) = TextBoxProc1.Text
            UserChoices(4) = ComboProc2.ListIndex
            Set WorkRange = CreateWorkRange(WorkRange, cbSkipNonText)
            If Not WorkRange Is Nothing Then
                Call SaveForUndo
                If UndoError Then Exit Sub
                Call AddText
            End If
        
        Case 2 ' Remove Text
            UserChoices(5) = ComboProc1.ListIndex
            UserChoices(6) = ComboProc2.ListIndex
            Set WorkRange = CreateWorkRange(WorkRange, cbSkipNonText)
            If Not WorkRange Is Nothing Then
                Call SaveForUndo
                If UndoError Then Exit Sub
                Call RemoveText
            End If
        
        Case 3 ' Remove Spaces
            UserChoices(7) = ComboProc1.ListIndex
            Set WorkRange = CreateWorkRange(WorkRange, cbSkipNonText)
            If Not WorkRange Is Nothing Then
                Call SaveForUndo
                If UndoError Then Exit Sub
                Call RemoveSpaces
            End If
        
        Case 4 ' Remove Characters
            UserChoices(8) = ComboProc1.ListIndex
            Set WorkRange = CreateWorkRange(WorkRange, True)
            If Not WorkRange Is Nothing Then
                Call SaveForUndo
                If UndoError Then Exit Sub
                Call RemoveCharacters
            End If
    End Select
    Me.Height = 100
End Sub


Private Sub ComboBoxOperation_Change()
    Dim i As Long
    Select Case ComboBoxOperation.ListIndex
        Case 0 ' Change Case
            cbSkipNonText.Enabled = False
            TextBoxProc1.Visible = False
            With LabelProc1
                .Caption = "Change to:"
                .Accelerator = "C"
            End With
            
            With ComboProc1
                .Clear
                .Visible = True
                .List = Array("UPPER CASE", "lower case", "Proper Case", "Sentence case.", "tOGGLE cASE")
                .ListIndex = UserChoices(2)
            End With
            LabelProc2.Visible = False
            ComboProc2.Visible = False
         
         Case 1 ' Add Text
            cbSkipNonText.Enabled = True
            With LabelProc1
                .Caption = "Text to add:"
                .Accelerator = "T"
            End With
            
            With TextBoxProc1
                .Visible = True
                .Text = UserChoices(3)
            End With
            
            With ComboProc1
                .Visible = False
            End With
            
            With LabelProc2
                .Visible = True
                .Caption = "Character position:"
                .Accelerator = "C"
            End With
            
            With ComboProc2
                .Clear
                .Visible = True
                .AddItem "Before first character"
                .AddItem "After last character"
                For i = 1 To 64
                    .AddItem "After character " & i
                Next i
                .ListIndex = UserChoices(4)
            End With
            
        Case 2 ' Remove by Position
            cbSkipNonText.Enabled = True
            TextBoxProc1.Visible = False
            
            With LabelProc1
                .Caption = "Characters to remove:"
                .Accelerator = "C"
            End With
            
            With ComboProc1
                .Clear
                .Visible = True
                .AddItem "1 character"
                For i = 2 To 64
                    .AddItem i & " characters"
                Next i
                .ListIndex = UserChoices(5)
            End With
            
            With LabelProc2
                .Visible = True
                .Caption = "Character position:"
                .Accelerator = "p"
            End With
            
            With ComboProc2
                .Clear
                .Visible = True
                .AddItem "From the left"
                .AddItem "From the right"
                For i = 2 To 64
                    .AddItem "Character position " & i
                Next i
                .ListIndex = UserChoices(6)
            End With
        
        Case 3 ' Remove Spaces
            cbSkipNonText.Enabled = False
            With LabelProc1
                .Caption = "Remove:"
                .Accelerator = "R"
            End With
            
            TextBoxProc1.Visible = False
            
            With ComboProc1
                .Clear
                .Visible = True
                .List = Array("All excess spaces", "All spaces")
                .ListIndex = UserChoices(7)
            End With
            
            LabelProc2.Visible = False
            ComboProc2.Visible = False
        
        Case 4 ' Delete Characters
            cbSkipNonText.Enabled = False
            TextBoxProc1.Visible = False
            
            With LabelProc1
                .Caption = "Delete all:"
                .Accelerator = "D"
            End With
            
            With ComboProc1
                .Clear
                .Visible = True
                .List = Array("Non-printing characters", "Alpha characters", "Non-numeric characters", "Non-numeric & non-alpha", "Numeric characters")
                .ListIndex = UserChoices(8)
            End With
            LabelProc2.Visible = False
            ComboProc2.Visible = False
    End Select
End Sub

Private Sub ChangeCase()
    Dim CellCount As Long
    Dim Item As Range
    Dim TotalCells As Long
    Dim ShowProgressIndicator As Boolean
    
    CellCount = 0
    TotalCells = WorkRange.Count
    ShowProgressIndicator = TotalCells >= PROGRESSTHRESHHOLD
    If ShowProgressIndicator = True Then
        Me.Height = 120
        LabelProgress.Width = 0
    End If
    
    Application.ScreenUpdating = False
    For Each Item In WorkRange
        CellCount = CellCount + 1
        If ShowProgressIndicator = True Then
            If CellCount Mod 100 = 0 Then
                LabelProgress.Width = FrameProgress.Width * (CellCount / TotalCells)
                DoEvents
            End If
        End If
        Select Case ComboProc1.ListIndex
            Case 0: Item.Value = UCase(Item.Value)
            Case 1: Item.Value = LCase(Item.Value)
            Case 2: Item.Value = Application.Proper(Item.Value)
            Case 3: Item.Value = SentenceCase(Item.Value)
            Case 4: Item.Value = ToggleCase(Item.Value)
        End Select
    Next Item
    Application.ScreenUpdating = True
    If Not UndoError Then Application.OnUndo "Undo Change Case", "UndoTextTools"
End Sub

Private Sub AddText()
    Dim a As Range
    Dim Template As String
    Dim NewText As String
    Dim Ans As Long
    Dim InsPos As Long
    
    NewText = TextBoxProc1.Text
    If NewText = "" Then
        MsgBox "You need to specify the text to add.", vbInformation, APPNAME
        TextBoxProc1.SetFocus
        Exit Sub
    End If
    
    Application.ScreenUpdating = False
    Select Case ComboProc2.ListIndex
        Case 0: 'add to left
            For Each a In WorkRange.Areas
                a.Formula = Application.Replace(a.Formula, 1, 0, NewText)
            Next a
        Case 1: 'add to right
            Template = "tttt" & Chr(38) & Chr(34) & NewText & Chr(34)
            'Generates a string like: tttt&"newtext"
            For Each a In WorkRange.Areas
                a.Formula = Evaluate(Replace(Template, "tttt", a.Address))
            Next a
        Case Else
            InsPos = ComboProc2.ListIndex
            For Each a In WorkRange.Areas
                a.Formula = Application.Replace(a.Formula, InsPos, 0, NewText)
            Next a
    End Select
    Application.ScreenUpdating = True
    Application.OnUndo "Undo Add Text", "UndoTextTools"
End Sub

Private Sub RemoveText()
    Dim a As Range
    Dim CellCount As Long
    Dim TotalCells As Long
    Dim Item As Range
    Dim NumToDelete As Long
    Dim BeginPosition As Long
    Dim ShowProgressIndicator As Boolean
    
    Application.ScreenUpdating = False
    NumToDelete = ComboProc1.ListIndex + 1
    Select Case ComboProc2.ListIndex
        Case 0 'from left
            For Each a In WorkRange
                a.Formula = Application.Replace(a.Formula, 1, NumToDelete, "")
            Next a
        Case 1 'from right (loop through the cells, slower)
            CellCount = 0
            TotalCells = WorkRange.Count
            ShowProgressIndicator = TotalCells >= PROGRESSTHRESHHOLD
            If ShowProgressIndicator = True Then
                Me.Height = 120
                LabelProgress.Width = 0
            End If
        
            For Each Item In WorkRange
                CellCount = CellCount + 1
                If ShowProgressIndicator = True Then
                    If CellCount Mod 100 = 0 Then
                        LabelProgress.Width = FrameProgress.Width * (CellCount / TotalCells)
                        DoEvents
                    End If
                End If
                If NumToDelete > Len(Item.Value) Then
                    Item.Value = ""
                Else
                    Item.Value = Left(Item.Value, Len(Item.Value) - NumToDelete)
                End If
            Next Item
        
        Case Else 'from a character position
            BeginPosition = ComboProc2.ListIndex
            For Each a In WorkRange
                a.Formula = Application.Replace(a.Formula, BeginPosition, NumToDelete, "")
            Next a
    End Select
    
    Application.ScreenUpdating = True
    Application.OnUndo "Undo Remove Text", "UndoTextTools"
End Sub

Private Sub RemoveSpaces()
    Dim a As Range
    If ComboProc1.ListIndex = 0 Then ' Excess spaces
        For Each a In WorkRange.Areas
            a.Formula = Application.Trim(a.Formula)
        Next a
    Else ' All Spaces
        For Each a In WorkRange.Areas
            a.Formula = Application.Substitute(a.Formula, " ", "")
        Next
    End If
    Application.ScreenUpdating = True
    Application.OnUndo "Undo Remove Text", "UndoTextTools"
End Sub

Private Sub RemoveCharacters()
    Dim a As Range
    Dim CellCount As Long
    Dim TotalCells As Long
    Dim Item As Range
    Dim NumToDelete As Long
    Dim BeginPosition As Long
    Dim ShowProgressIndicator As Boolean
    
    Application.ScreenUpdating = False
    
    If ComboProc1.ListIndex = 0 Then 'non-printing characters
        For Each a In WorkRange
            a.Formula = Application.Clean(a.Formula)
        Next a
    Else
        CellCount = 0
        TotalCells = WorkRange.Count
        ShowProgressIndicator = TotalCells >= PROGRESSTHRESHHOLD
        If ShowProgressIndicator = True Then
            Me.Height = 120
            LabelProgress.Width = 0
        End If
        For Each Item In WorkRange
            CellCount = CellCount + 1
            If ShowProgressIndicator = True Then
                If CellCount Mod 100 = 0 Then
                    LabelProgress.Width = FrameProgress.Width * (CellCount / TotalCells)
                    DoEvents
                End If
            End If
            Select Case ComboProc1.ListIndex
                Case 1 'Alpha
                        Item.Value = RemoveAlpha(Item.Value)
                Case 2 'Non-Numeric
                        Item.Value = RemoveNonNumeric(Item.Value)
                Case 3 ' non-numeric and non-alpha
                        Item.Value = RemoveNonNumericNonAlpha(Item.Value)
                Case 4 'numeric
                    Item.Value = RemoveNumeric(Item.Value)
            End Select
        Next Item
    End If
    Application.ScreenUpdating = True
    Application.OnUndo "Undo Remove Characters", "UndoTextTools"
End Sub

Private Function CreateWorkRange(Rng, TextOnly)
'   Creates and returns a Range object
    Set CreateWorkRange = Nothing
   
'   Single cell, has a formula
    If Rng.Count = 1 And Rng.HasFormula Then
        Set CreateWorkRange = Nothing
        Exit Function
    End If
    
'   Single cell, or single merged cell
    If Rng.Count = 1 Or Rng.MergeCells = True Then
        If TextOnly = True Then
            If Not IsNumeric(Rng(1).Value) Then
                Set CreateWorkRange = Rng
                Exit Function
            Else
                Set CreateWorkRange = Nothing
                Exit Function
            End If
        Else
            If Not IsEmpty(Rng(1)) Then
                Set CreateWorkRange = Rng
                Exit Function
            End If
        End If
    End If
    On Error Resume Next
    Set Rng = Intersect(Rng, Rng.Parent.UsedRange)
    If TextOnly = True Then
        Set CreateWorkRange = Rng.SpecialCells(xlConstants, xlTextValues)
        If err <> 0 Then
            Set CreateWorkRange = Nothing
            On Error GoTo 0
            Exit Function
        End If
    Else
        Set CreateWorkRange = Rng.SpecialCells(xlConstants, xlTextValues + xlNumbers)
        If err <> 0 Then
            Set CreateWorkRange = Nothing
            On Error GoTo 0
            Exit Function
        End If
    End If
End Function

Private Function ToggleCase(s)
'   Toggles the case of a string
    Dim StringLength As Long, i As Long
    Dim TempString As String
    Dim c As Long
    TempString = ""
    StringLength = Len(s)
    For i = 1 To StringLength
        c = Asc(Mid(s, i, 1))
        If c >= 97 And c <= 122 Then
            TempString = TempString & Chr(c - 32)
        Else
            If c >= 65 And c <= 95 Then
                TempString = TempString & Chr(c + 32)
            Else
                TempString = TempString & Chr(c)
            End If
        End If
    Next i
    ToggleCase = TempString
End Function

Private Function SentenceCase(s)
'   Returns a string with uppercase character following each end-sentence punctuation
    Dim StringLength As Long, i As Long
    Dim TempString As String
    Dim c As String * 1
    Dim PunctuationFound As Boolean
    
    TempString = ""
    StringLength = Len(s)
    TempString = UCase(Left(s, 1))
    PunctuationFound = False
    For i = 2 To StringLength
        c = Mid(s, i, 1)
        If PunctuationFound = True Then
            If c Like "[A-Z,a-z]" Then
                TempString = TempString & UCase(c)
                PunctuationFound = False
            Else
                TempString = TempString & LCase(c)
            End If
        Else
            If c = "." Or c = "?" Or c = "!" Then
                PunctuationFound = True
                TempString = TempString & c
            Else
                TempString = TempString & LCase(c)
            End If
        End If
    Next i
    SentenceCase = TempString
End Function

Private Function RemoveAlpha(str)
    Dim i As Long
    Dim StrLen As Long
    Dim c As String * 1
    
    StrLen = Len(str)
    RemoveAlpha = ""
    For i = 1 To StrLen
        c = Mid(str, i, 1)
        If Not c Like "[A-Z]" Then RemoveAlpha = RemoveAlpha & c
    Next i
End Function

Private Function RemoveNonNumeric(str)
    Dim i As Long
    Dim StrLen As Long
    Dim c As String * 1
    
    StrLen = Len(str)
    RemoveNonNumeric = ""
    For i = 1 To StrLen
        c = Mid(str, i, 1)
        If c Like "#" Then RemoveNonNumeric = RemoveNonNumeric & c
    Next i
End Function

Private Function RemoveNonNumericNonAlpha(str)
    Dim i As Long
    Dim StrLen As Long
    Dim c As String * 1
    
    StrLen = Len(str)
    RemoveNonNumericNonAlpha = ""
    For i = 1 To StrLen
        c = Mid(str, i, 1)
        If c Like "#" Or c Like "[A-Z]" Then RemoveNonNumericNonAlpha = RemoveNonNumericNonAlpha & c
    Next i
End Function


Private Function RemoveNumeric(str)
    Dim i As Long
    Dim StrLen As Long
    Dim c As String * 1
    
    StrLen = Len(str)
    RemoveNumeric = ""
    For i = 1 To StrLen
        c = Mid(str, i, 1)
        If Not c Like "#" Then RemoveNumeric = RemoveNumeric & c
    Next i
End Function

Private Sub CloseButton_Click()
'   Store settings
    On Error Resume Next
    SaveSetting APPNAME, "Settings", "OperationIndex", UserChoices(1)
    SaveSetting APPNAME, "Settings", "ChangeCaseIndex", UserChoices(2)
    SaveSetting APPNAME, "Settings", "TextToAdd", UserChoices(3)
    SaveSetting APPNAME, "Settings", "AddTextIndex", UserChoices(4)
    SaveSetting APPNAME, "Settings", "CharsToRemoveIndex", UserChoices(5)
    SaveSetting APPNAME, "Settings", "RemovePositionIndex", UserChoices(6)
    SaveSetting APPNAME, "Settings", "RemoveSpacesIndex", UserChoices(7)
    SaveSetting APPNAME, "Settings", "RemoveCharactersIndex", UserChoices(8)
    SaveSetting APPNAME, "Settings", "cbSkipNonText", cbSkipNonText.Value * -1
    Unload Me
End Sub

Private Sub SaveForUndo()
    Dim RngArea As Range
    Dim Ans As Long
    
    UndoError = False
    Set UserSelection = Selection
    Set UndoRange = WorkRange
    ThisWorkbook.Sheets(2).UsedRange.Clear
    On Error Resume Next
    For Each RngArea In WorkRange.Areas
        ThisWorkbook.Sheets(2).Range(RngArea.Address).Formula = RngArea.Formula
    Next RngArea
    If err.Number <> 0 Then
        UndoError = True
        If ComboBoxOperation.ListIndex = 0 Then
            HaltOperation = False
            Ans = MsgBox("One or more cells in the selection contains text that exceeds 1,024 characters." & vbCrLf & vbCrLf & "The operation will be performed, but Undo will not be available." & "Continue anyway?", vbQuestion + vbYesNo, APPNAME)
            If Ans = vbNo Then HaltOperation = True
        Else
            MsgBox "The operation cannot be performed." & vbCrLf & vbCrLf & "One or more cells in the selection contains text that exceeds 1,024 characters.", vbCritical, APPNAME
        End If
    End If
End Sub

Private Sub HelpButton_Click()
    Application.Help (ThisWorkbook.Path & "\" & "texttools.chm")
End Sub


Attribute VB_Name = "ThisWorkbook"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Private Sub Workbook_Open()
    CreateMenu
End Sub

' InQuest injected base64 decoded content
' )^J)
' )^J)

INQUEST-PP=macro
