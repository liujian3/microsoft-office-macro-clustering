Attribute VB_Name = "DieseArbeitsmappe"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Sub Workbook_Open()
Tabelle3.Unprotect
Tabelle3.ComboBox1.Clear
For i = 1 To 25 '#### ...25... Sprachen eingestellt
  If Tabelle4.Cells(1, 1 + i).Value <> 0 Then 'Pr|fffd|fen Sprache existiert Zeile 1
    Tabelle3.ComboBox1.AddItem (Tabelle4.Cells(1, 1 + i).Value) 'Werte f|fffd|llen Zeile 1
  End If
Next i

Tabelle3.ComboBox1.Text = Tabelle4.Range("A1").Value

Tabelle3.Protect
End Sub

Attribute VB_Name = "Modul1"
Sub test()
Attribute test.VB_Description = "Makro am 28.01.2011 von Michael Urmann aufgezeichnet"
Attribute test.VB_ProcData.VB_Invoke_Func = " \n14"


Load_8D_from_XML ("H:\My Documents\SAP\0000312754_000200517103.xml")
End Sub
Attribute VB_Name = "Modul2"
'Add new line for additional team member
Sub AddTeamMember()
Attribute AddTeamMember.VB_Description = "Makro am 22.06.2010 von Oliver Litzen aufgezeichnet"
Attribute AddTeamMember.VB_ProcData.VB_Invoke_Func = " \n14"
Tabelle3.Unprotect
If Tabelle3.Range("AE26").Value < 18 Then
  Rows(Str(Tabelle3.Range("AE26").Value + 38) & ":" & Trim(Str(Tabelle3.Range("AE26").Value + 39))).Select 'Zeile Sichtbar machen
  Selection.EntireRow.Hidden = False
  Tabelle3.Range("AE26").Value = Tabelle3.Range("AE26").Value + 2
  Tabelle3.Cells(36 + Tabelle3.Range("AE26").Value, 19).Select
End If
Tabelle3.Protect
End Sub

Sub AddCorrAct()
Tabelle3.Unprotect
If Tabelle3.Range("AE113").Value < 20 Then
  Rows(Str(Tabelle3.Range("AE113").Value + 127) & ":" & Trim(Str(Tabelle3.Range("AE113").Value + 128))).Select 'Zeile Sichtbar machen
  Selection.EntireRow.Hidden = False
  Tabelle3.Range("AE113").Value = Tabelle3.Range("AE113").Value + 2
  Tabelle3.Cells(125 + Tabelle3.Range("AE113").Value, 19).Select
End If
Tabelle3.Protect
End Sub
Sub AddImplAct()
Tabelle3.Unprotect
If Tabelle3.Range("AE155").Value < 20 Then
  Rows(Str(Tabelle3.Range("AE155").Value + 170) & ":" & Trim(Str(Tabelle3.Range("AE155").Value + 171))).Select 'Zeile Sichtbar machen
  Selection.EntireRow.Hidden = False
  Tabelle3.Range("AE155").Value = Tabelle3.Range("AE155").Value + 2
  Tabelle3.Cells(168 + Tabelle3.Range("AE155").Value, 2).Select
End If
Tabelle3.Protect
End Sub
Attribute VB_Name = "Modul4"
Sub DeleteTeamMember()
Attribute DeleteTeamMember.VB_Description = "Makro am 22.06.2010 von Oliver Litzen aufgezeichnet"
Attribute DeleteTeamMember.VB_ProcData.VB_Invoke_Func = " \n14"
Tabelle3.Unprotect
If Tabelle3.Range("AE26").Value > 0 Then
  Rows(Str(Tabelle3.Range("AE26").Value + 36) & ":" & Trim(Str(Tabelle3.Range("AE26").Value + 37))).Select 'Zeile Sichtbar machen
  Selection.EntireRow.Hidden = True
  Tabelle3.Range("AE26").Value = Tabelle3.Range("AE26").Value - 2
  Tabelle3.Cells(36 + Tabelle3.Range("AE26").Value, 19).Select
End If
Tabelle3.Protect
End Sub
Sub DeleteCorrAct()
Tabelle3.Unprotect
If Tabelle3.Range("AE113").Value > 0 Then
  Rows(Str(Tabelle3.Range("AE113").Value + 126) & ":" & Trim(Str(Tabelle3.Range("AE113").Value + 127))).Select 'Zeile Sichtbar machen
  Selection.EntireRow.Hidden = True
  Tabelle3.Range("AE113").Value = Tabelle3.Range("AE113").Value - 2
  Tabelle3.Cells(126 + Tabelle3.Range("AE113").Value, 19).Select
End If
Tabelle3.Protect
End Sub
Sub DeleteImplAct()
Tabelle3.Unprotect
If Tabelle3.Range("AE155").Value > 0 Then
  Rows(Str(Tabelle3.Range("AE155").Value + 168) & ":" & Trim(Str(Tabelle3.Range("AE155").Value + 169))).Select 'Zeile Sichtbar machen
  Selection.EntireRow.Hidden = True
  Tabelle3.Range("AE155").Value = Tabelle3.Range("AE155").Value - 2
  Tabelle3.Cells(168 + Tabelle3.Range("AE155").Value, 2).Select
End If
Tabelle3.Protect
End Sub
Attribute VB_Name = "Sheet1"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Tabelle1"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Tabelle2"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Tabelle3"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Control = "ComboBox1, 123, 1, MSForms, ComboBox2"
Attribute VB_Control = "CommandButton1, 181, 2, MSForms, CommandButton2"

Private Sub ComboBox1_Change()
Tabelle3.Unprotect
Tabelle4.Unprotect
Dim C As Comment

If Tabelle3.ComboBox1.Text <> "" Then
  Tabelle4.Range("A1").Value = Tabelle3.ComboBox1.Text
  Tabelle4.Range("A2").Value = Tabelle3.ComboBox1.ListIndex + 1
  
     
    '#####translate comments
    i = 102
    For Z = 1 To 24
            With Tabelle3 '8D
              .Comments(Z).Text Text:=Tabelle4.Cells(i, Tabelle4.Range("A2").Value + 1).Value
              i = i + 1
            End With
    Next Z
    
End If
   
                For Each C In Tabelle3.Comments
                With C.Shape.DrawingObject.Font
                    .Size = 6
                    .Name = "Arial"
                    .FontStyle = standard
                End With
                C.Shape.OLEFormat.Object.AutoSize = True
                Next C
                
                For Each C In Tabelle2.Comments
                With C.Shape.DrawingObject.Font
                    .Size = 6
                    .Name = "Arial"
                    .FontStyle = standard
                End With
                C.Shape.OLEFormat.Object.AutoSize = True
                Next C
Tabelle3.Protect
Tabelle4.Protect
End Sub

Private Sub CommandButton1_Click()
Dim array_cells()
array_cells = Array(60, 62, 76, 78, 80, 82, 84, 86, 88, 94, 112, 117, 119, 121, 123, 125, 156, 158, 160, 162, 164, 166, 193, 195, 197, 199, 201, 203, 205, 207, 213, 217, 220)

Tabelle3.Unprotect
Application.ScreenUpdating = False
Application.Calculation = xlCalculationManual

        For j = 0 To UBound(array_cells)
          Select Case array_cells(j)
            Case 60 To 88
              Tabelle3.Cells(array_cells(j), 7).Select
            Case 94
              Tabelle3.Cells(array_cells(j), 2).Select
            Case 112
              Tabelle3.Cells(array_cells(j), 18).Select
            Case 117 To 163
              Tabelle3.Cells(array_cells(j), 2).Select
            Case 190 To 204
              Tabelle3.Cells(array_cells(j), 7).Select
            Case 210
              Tabelle3.Cells(array_cells(j), 2).Select
            Case 214 To 217
              Tabelle3.Cells(array_cells(j), 7).Select
          End Select
          autofitXLMergedCells
          Selection.Locked = False
        Next j

Application.ScreenUpdating = True
Application.Calculation = xlCalculationAutomatic
Tabelle3.Protect
End Sub

Sub autofitXLMergedCells()

'Passt Zeilenh|fffd|he an den Text innerhalb von verbundenen Zellen im selektierten Bereich an
'(Die Autofit-Methode des Excel-Range-Objektes funktioniert f|fffd|r verbundene Zellen nicht)
On Error GoTo Err_autofitXLMergedCells

Dim lo_CurRange As Excel.Range

Dim lsg_SumCellWidths As Single
Dim lsg_OriginalWidthFirstCol As Single
Dim lsg_NewRowHeight As Single
Dim li_MergedCellsCount As Integer


With Selection
    If .MergeCells Then
        'If .Rows.Count = 2 And .WrapText = True Then
            lsg_OriginalWidthFirstCol = .Cells(, 1).ColumnWidth
            
            'Einzelzellbreiten und Breiten der Gitterlinien summieren
            For Each lo_CurRange In Selection
                lsg_SumCellWidths = lo_CurRange.ColumnWidth + lsg_SumCellWidths
                li_MergedCellsCount = li_MergedCellsCount + 1
            Next
                        
            lsg_SumCellWidths = lsg_SumCellWidths + (li_MergedCellsCount - 1) * 0.71

            'Verbindung der Zellen aufheben, erste (datentragende) Zelle auf Gesamtbreite ausdehnen und
            'H|fffd|he anpassen |fffd|ber Standardmethode
            .MergeCells = False
            .Cells(1).ColumnWidth = lsg_SumCellWidths
            .EntireRow.AutoFit
            If .EntireRow.RowHeight = 12.75 Then .EntireRow.RowHeight = 7.5
            
            'Resultierende Zeilenh|fffd|he merken, erste Zelle zur|fffd|cksetzen, Verbindung wiederherstellen, H|fffd|he anpassen
            lsg_NewRowHeight = .RowHeight
            .Cells(1).ColumnWidth = lsg_OriginalWidthFirstCol
            .MergeCells = True
            .RowHeight = lsg_NewRowHeight
        'End If
    End If
End With

Exit Sub
'Nur f|fffd|r's Debuggen
Resume

Err_autofitXLMergedCells:
MsgBox Err.Number & ": " & Err.Description

End Sub

Private Sub OptionButton7_Click()
Tabelle3.Unprotect
    Range("W6").Value = "X" 'yes
    Range("W8").Value = "" 'no
Tabelle3.Protect
End Sub
Private Sub OptionButton8_Click()
Tabelle3.Unprotect
    Range("W6").Value = "" 'yes
    Range("W8").Value = "X" 'no
Tabelle3.Protect
End Sub
Private Sub OptionButton1_Click()
Tabelle3.Unprotect
    Range("G111").Value = "X" 'yes
    Range("I111").Value = "" 'no
Tabelle3.Protect
End Sub
Private Sub OptionButton2_Click()
Tabelle3.Unprotect
    Range("G111").Value = "" 'yes
    Range("I111").Value = "X" 'no
Tabelle3.Protect
End Sub

Private Sub Worksheet_SelectionChange(ByVal Target As Range)

End Sub
Attribute VB_Name = "Tabelle4"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Private Sub Worksheet_Activate()

End Sub

Private Sub Worksheet_SelectionChange(ByVal Target As Range)

End Sub
Attribute VB_Name = "Tabelle5"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True

Private Sub Worksheet_BeforeDoubleClick(ByVal Target As Range, Cancel As Boolean)

If Not Intersect(Target, Range("M14:M24,Y14:Y24,AK14:AK24")) Is Nothing Then

    If Len(Target.Cells(1)) = 0 Then                 ' Len = l|fffd|nger der Zelle = 0
        Target.Cells(1) = "X"

    Cancel = True
    Range("A1").Activate
    
    Else
        Target.Cells(1) = ""

    End If

Cancel = True
Range("A1").Activate

End If

End Sub


Private Sub Worksheet_Change(ByVal Target As Range)

Dim Zeile As Byte
Dim spalte As Byte

Zeile = ActiveCell.Row
spalte = ActiveCell.Column

Application.ScreenUpdating = False

If ActiveCell.Column = 25 Then                      'AK = 37 andere ist 13
    Cells(Target.Row, Target.Column - 12).Select
    Selection.ClearContents
    Target.Select
End If

If ActiveCell.Column = 37 Then                      'AK = 37 andere ist 13
    Cells(Target.Row, Target.Column - 24).Select
    Selection.ClearContents
    Target.Select
End If

Application.ScreenUpdating = True

End Sub
        
        
Attribute VB_Name = "clsActionbox"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

'=== Globale Datendeklaration
Private gi_commandbar As CommandBar
Private gv_width      As Long

Public Function Create_Commandbar(ByRef po_commandbars As CommandBars, ByVal pv_name As String) As Boolean
'=== Hinzuf|fffd|gen einer neuen Commandbar
  Create_Commandbar = Add_Commandbar(po_commandbars, pv_name)
End Function

Private Function Check_Commandbar_Exist(ByRef po_commandbars As CommandBars, ByVal pv_name As String) As Boolean
'=== Registrierung des Errorhandlers (Actionbox Exist)
On Error GoTo err_commandbar_not_exist

'=== |fffd|berpr|fffd|fung ob die anzulegende Commandbar existiert
  po_commandbars(pv_name).Visible = True

'=== R|fffd|ckgabewert setzen
  Check_Commandbar_Exist = True
  Exit Function

'=== Errorhandler-Definition: Fehler Commandbar existiert nicht
err_commandbar_not_exist:
  Check_Commandbar_Exist = False
End Function

Private Function Delete_Commandbar(ByRef po_commandbars As CommandBars, ByVal pv_name As String) As Boolean
'=== Registrierung des Errorhandlers (delete Actionbox)
On Error GoTo err_delete_commandbar

'=== L|fffd|schen der |fffd|bergebenen Commandbar
  po_commandbars(pv_name).Delete
  
'=== R|fffd|ckgabewert setzen
  Delete_Commandbar = True
  Exit Function

'=== Errorhandler-Definition: Fehler beim L|fffd|schen einer Commandbar
err_delete_commandbar:
  Delete_Commandbar = False
End Function

Private Function Add_Commandbar(ByRef po_commandbars As CommandBars, ByVal pv_name As String) As Boolean
'=== Registrierung des Errorhandlers (add Actionbox)
On Error GoTo err_add_commandbar

'=== |fffd|berpr|fffd|fung: Existiert die anzulegende Commandbar falls ja, l|fffd|schen
  If Check_Commandbar_Exist(po_commandbars, pv_name) Then
    If Delete_Commandbar(po_commandbars, pv_name) = False Then Exit Function
  End If

'=== Hinzuf|fffd|gen der neuen Commandbar
  Set gi_commandbar = po_commandbars.Add(Name:=pv_name, temporary:=True)
  gi_commandbar.Visible = True
  gi_commandbar.Width = 250
  
'=== R|fffd|ckgabewert setzen
  Add_Commandbar = True
  Exit Function

'=== Errorhandler-Definition: Fehler beim Hinzuf|fffd|gen einer Commandbar
err_add_commandbar:
  Add_Commandbar = False
End Function

Public Function Add_Commandbutton(ByVal pv_caption As String, ByVal pv_action As String, Optional ByVal pv_parameter As String, Optional ByVal pv_icon As Long) As Boolean
'=== Lokale Datendeklaration
Dim lo_commandbutton As CommandBarButton

'=== Registrierung des Errorhandlers (add Actionbox-Function)
On Error GoTo err_add_Button

'=== Hinzuf|fffd|gen eines neuen Commandbarbuttons zu einer bestehenden Commandbar
  Set lo_commandbutton = gi_commandbar.Controls.Add(Type:=msoControlButton)
  lo_commandbutton.Caption = pv_caption               'setzen der Buttonbeschreibung
  lo_commandbutton.BeginGroup = True                  'setzen einer neuen Gruppe
  lo_commandbutton.Style = msoButtonIconAndCaption    'setzen des Buttonstyles
  lo_commandbutton.Parameter = pv_parameter           'setzen des Parameters
  lo_commandbutton.OnAction = pv_action               'setzen des auszuf|fffd|hrenden Makros
  lo_commandbutton.FaceId = pv_icon                   'setzen des Buttonicons
  
'=== merken der l|fffd|ngsten Buttonbreite f|fffd|r evtl. sp|fffd|tere Optimierung
  If lo_commandbutton.Width > gv_width Then
    gv_width = lo_commandbutton.Width
  End If

'=== R|fffd|ckgabewert setzen
  Add_Commandbutton = True
  Exit Function

'=== Errorhandler-Definition: Fehler beim Hinzuf|fffd|gen eines Commandbarbuttons
err_add_Button:
  Add_Commandbutton = False
End Function

Public Function optimize_commandbar() As Boolean
'=== Lokale Datendeklaration
Dim lo_commandbutton As CommandBarButton

'=== Registrierung des Errorhandlers (add Actionbox-Function)
On Error GoTo err_optimize_commandbar

'=== Optimierung der Commandbarbreite (l|fffd|ngste Buttonbreite + 10)
 gi_commandbar.Width = gv_width + 10

'=== Optimierung der Commandbuttonbreite
  For Each lo_commandbutton In gi_commandbar.Controls
    lo_commandbutton.Width = gv_width
  Next lo_commandbutton

'=== R|fffd|ckgabewert setzen
  optimize_commandbar = True
  Exit Function

'=== Errorhandler-Definition: Fehler beim Optimieren der Commandbar
err_optimize_commandbar:
  optimize_commandbar = False
End Function

Private Sub Class_Terminate()
'=== Globale Variablen initialisieren
  Set gi_commandbar = Nothing
  gv_width = 0
End Sub
Attribute VB_Name = "clsAttribute"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

'=== Globale Datendeklaration
Public gv_row_id    As Long    'Zeilen ID
Public gv_column_id As Long    'Spalten ID
Public gv_name      As String  'Excel Name
Public gv_xml_tag   As String  'XML Tag
Public gv_value     As Variant 'Wert

Private Sub Class_Terminate()
'=== Globale Daten initialisieren
  gv_row_id = 0
  gv_column_id = 0
  gv_name = vbNullString
  gv_xml_tag = vbNullString
End Sub

Attribute VB_Name = "clsDxStep"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

'=== Globale Datendeklaration
Public gv_stid               As String
Public gv_name               As String
Public gt_range              As Range
Public gv_new                As Boolean
Private gi_application_names As clsNames
Private gt_attributes()      As clsAttribute

Public Function initialize(ByRef pi_application_names As clsNames)
'=== |fffd|bernahme der Namens-Instanz
  Set gi_application_names = pi_application_names
End Function

Public Function Add_Dx_Step(ByRef pv_tpl_name, ByVal pv_stid As String, ByVal pv_dx_step_name As String, ByVal pv_new_step As Boolean) As Boolean
'=== Registrierung des Errorhandlers (Add Attributes)
On Error GoTo err_add_dx_step

'=== |fffd|bernahme der |fffd|bergebenen Parameter als globale Daten
  gv_stid = pv_stid
  gv_name = pv_dx_step_name
  gv_new = pv_new_step

'=== Template Block |fffd|bernehmen
  If gi_application_names.Check_Name_Refers_to_Range(pv_tpl_name) Then
    Set gt_range = gi_application_names.get_range_by_name(pv_tpl_name)
  Else
    GoTo err_add_dx_step
  End If
  
'=== Hinzuf|fffd|gen der Blockattribute und verlassen der Funktion
  Add_Dx_Step = Add_Attributes(gt_range, gi_application_names.get_name_data(pv_tpl_name))
  Exit Function

'=== Errorhandler-Definition: Fehler beim Hinzuf|fffd|gen des DX-Schritt
err_add_dx_step:
  Add_Dx_Step = False
End Function

Private Function Add_Attributes(ByRef pr_range As Range, ByRef pi_tpl_name_data As clsNameData) As Boolean
'=== Lokale Datendeklaration
Dim lv_attribute_name As String
Dim lv_att_value      As String
Dim lv_current_column As Long
Dim lv_current_row    As Long
Dim li_name_data      As clsNameData
Dim li_name As Name

'=== Registrierung des Errorhandlers (Add Attributes)
On Error GoTo err_add_attributes
 
 For Each li_name In gi_application_names.gi_excel_names
'=== Zusammenstellung der ben|fffd|tigten Attributsinformationen
   Set li_name_data = gi_application_names.get_name_data(li_name.Name)
   If Not li_name_data Is Nothing Then
     
     If li_name_data.gv_stid = pi_tpl_name_data.gv_stid And li_name_data.gv_kind = pi_tpl_name_data.gv_kind And li_name_data.gv_indx = pi_tpl_name_data.gv_indx And (li_name_data.gv_fnam <> vbNullString And li_name_data.gv_fnam <> "TI") Then
       
       If gi_application_names.Check_Name_is_in_Range(li_name.Name, pr_range) Then
          lv_attribute_name = gi_application_names.build_dx_attribute_name(gv_name, li_name_data.gv_fnam)

'=== Ermittlung der Attributs-Position
          lv_current_row = gi_application_names.get_range_by_name(li_name.Name).Row - pr_range.Row + 1
          lv_current_column = gi_application_names.get_range_by_name(li_name.Name).Column - pr_range.Column + 1
          
'=== Hinzuf|fffd|gen des gefundenen Attributs
          If gv_new = False Then lv_att_value = pr_range(lv_current_row, lv_current_column)
          Add_Attribute lv_current_row, lv_current_column, lv_attribute_name, li_name_data.gv_fnam
          If gv_new = False Then Add_Attribute_Value li_name_data.gv_fnam, pr_range(lv_current_row, lv_current_column).Value
       End If
       lv_attribute_name = vbNullString
       lv_current_row = 0
       lv_current_column = 0
       lv_att_value = vbNullString
     End If
   
   End If
 
 Next li_name
 
'=== R|fffd|ckgabewert setzen
  Add_Attributes = True
  Exit Function

'=== Errorhandler-Definition: Fehler beim Hinzuf|fffd|gen von Attributen
err_add_attributes:
  Add_Attributes = False
End Function

Public Function Add_Attribute_Value(ByVal pv_xml_name As String, ByVal pv_att_value As Variant) As Boolean
'=== Lokale Datendeklaration
Dim lv_att_counter As Long

'=== Registrierung des Errorhandlers (add Attribute value)
On Error GoTo err_add_attribute_value

'=== Hinzuf|fffd|gen des |fffd|bergebenen Werts zun |fffd|bergebenen Attribute
  For lv_att_counter = 1 To UBound(gt_attributes())
    If gt_attributes(lv_att_counter).gv_xml_tag = pv_xml_name Then
      gt_attributes(lv_att_counter).gv_value = pv_att_value
    End If
  Next lv_att_counter

'=== R|fffd|ckgabewert setzen
  Add_Attribute_Value = True
  Exit Function

'=== Errorhandler-Definition: Fehler beim Hinzuf|fffd|gen eines Attributwerts
err_add_attribute_value:
  Add_Attribute_Value = False
End Function

Private Function Add_Attribute(ByVal pv_row_id As Long, ByVal pv_column_id As Long, ByVal pv_name As String, ByVal pv_xml_tag As String) As Boolean
'=== Lokale Datendeklaration
Dim li_attribute As New clsAttribute

'=== Registrierung des Errorhandlers (add Attribute)
On Error GoTo err_add_attribute

'=== Redimensionierung des Attributarrays (Untergrenze + 1)
  ReDim Preserve gt_attributes(UBound(gt_attributes()) + 1)

'=== setzen der neuen Attributswerte
  li_attribute.gv_column_id = pv_column_id
  li_attribute.gv_name = pv_name
  li_attribute.gv_row_id = pv_row_id
  li_attribute.gv_xml_tag = pv_xml_tag

'=== Hinzuf|fffd|gen der neuen Attributsklasse
  Set gt_attributes(UBound(gt_attributes())) = li_attribute

'=== setzen des R|fffd|ckgabewerts
  Add_Attribute = True
  Exit Function

'=== Errorhandler-Definition: Fehler beim Hinzuf|fffd|gen eines Attributs
err_add_attribute:
  Add_Attribute = False
End Function

Public Function Get_Attributes() As clsAttribute()
'=== |fffd|bergabe aller DX-Attribute
  Get_Attributes = gt_attributes()
End Function

Private Sub Class_Initialize()
'=== Globale Daten initialisieren
  ReDim Preserve gt_attributes(0)
  gv_new = False
End Sub

Private Sub Class_Terminate()
'=== Objektinstanzen l|fffd|schen
  Kill_Objects
  
'=== Globale Daten initialisieren
  ReDim Preserve gt_attributes(0)
  gv_new = False
  Set gt_range = Nothing
End Sub

Private Function Kill_Objects()
'=== Lokale Datendeklaration
  Dim lv_att_count As Long
  
'=== L|fffd|schen der Attributinstanzen
  For lv_att_count = 1 To UBound(gt_attributes())
    Set gt_attributes(lv_att_count) = Nothing
  Next lv_att_count
End Function


Attribute VB_Name = "clsNameData"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'=== Globale Datendeklaration
Public gv_stid As String
Public gv_kind As Long
Public gv_indx As Long
Public gv_fnam As String
Attribute VB_Name = "clsNames"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

'=== Globale Datendeklaration
Public gi_excel_names As Names

Public Function get_name_data(ByVal pv_excel_name As String) As clsNameData
'=== Lokale Datendeklaration
Dim lt_name_data() As String
Dim li_name_data   As New clsNameData

'=== Registrierung des Errorhandlers (resume next)
  On Error Resume Next

'=== Aufsplittung des |fffd|bergebnen Excel-Namens
  If InStr(1, pv_excel_name, "_") = 0 Then Exit Function
  lt_name_data() = Split(pv_excel_name, "_")
 
'=== Zusammenstellung der Namedaten
  li_name_data.gv_stid = lt_name_data(0)
  li_name_data.gv_kind = lt_name_data(1)
  li_name_data.gv_indx = lt_name_data(2)
  li_name_data.gv_fnam = lt_name_data(3)

'=== R|fffd|ckgabewert setzen
  Set get_name_data = li_name_data
End Function

Public Function build_name_from_name_data(ByRef pi_name_data As clsNameData) As String
'=== Registrierung des Errorhandlers (build name)
  On Error GoTo err_build_name

'=== |fffd|berpr|fffd|fung der |fffd|bergebenen Instanz
  If pi_name_data Is Nothing Then GoTo err_build_name

'=== Erzeugen eines neuen Namens an Hand der |fffd|bergebenen Namedaten
  build_name_from_name_data = pi_name_data.gv_stid & "_" & pi_name_data.gv_kind & "_" & pi_name_data.gv_indx
  If pi_name_data.gv_fnam <> vbNullString Then build_name_from_name_data = build_name_from_name_data & "_" & pi_name_data.gv_fnam
  Exit Function

'=== Errorhandler-Definition: Fehler bei der Generierung eines neuen Namens
err_build_name:
  build_name_from_name_data = vbNullString
End Function

Public Function get_range_by_name(ByVal pv_excel_name As String) As Range
'=== Registrierung des Errorhandlers (get range by name)
  On Error GoTo err_get_range_by_name

'=== Existenzpr|fffd|fung des |fffd|bergebenen Excel-Namen
  If check_name_exist(pv_excel_name) = False Then GoTo err_get_range_by_name

'=== Ermittlung der zum Namen geh|fffd|renden Range
  Set get_range_by_name = gi_excel_names(pv_excel_name).RefersToRange
  Exit Function

'=== Errorhandler-Definition: Fehler bei der Ermittlung der zum Namen geh|fffd|renden Range
err_get_range_by_name:
  Set get_range_by_name = Nothing
End Function

Public Function build_new_dx_name(ByVal pv_template_name As String) As String
'=== Lokale Datendeklaration
Dim lv_new_name   As String
Dim li_name_data  As clsNameData
Dim lv_index      As Long

'=== Registrierung des Errorhandlers (build new dx name)
  On Error GoTo err_build_new_dx_name

'=== Existenzpr|fffd|fung des |fffd|bergebenen Excel-Namen
  If check_name_exist(pv_template_name) = False Then GoTo err_build_new_dx_name

'=== Ermittlung der Namensdaten f|fffd|r den |fffd|bergebnen Templatenamen
  Set li_name_data = get_name_data(pv_template_name)
  If li_name_data Is Nothing Then GoTo err_build_new_dx_name
  lv_new_name = pv_template_name

'=== Ermittlung eines neuen Rangenamens unter Verwendung der Namensdaten des Templates
  While check_name_exist(lv_new_name) = True
    li_name_data.gv_indx = li_name_data.gv_indx + 1
    lv_new_name = build_name_from_name_data(li_name_data)
  Wend

'=== R|fffd|ckgabewert setzen
  build_new_dx_name = lv_new_name
  Exit Function

'=== Errorhandler-Definition: Fehler bei der Generierung eines neuen DX-Namens
err_build_new_dx_name:
  build_new_dx_name = vbNullString
End Function

Public Function build_dx_attribute_name(ByVal pv_range_name As String, ByVal pv_field_name As String) As String
'=== Lokale Datendeklaration
Dim lv_new_name   As String
Dim li_name_data  As clsNameData

'=== Registrierung des Errorhandlers (build dx attribute name)
  On Error GoTo err_build_dx_attribute_name

'=== Ermittlung der Range-Namensdaten
  Set li_name_data = get_name_data(pv_range_name)
  If li_name_data Is Nothing Then GoTo err_build_dx_attribute_name
  
'=== Generierung eines neuen Namens
  li_name_data.gv_fnam = pv_field_name
  lv_new_name = build_name_from_name_data(li_name_data)

'=== R|fffd|ckgabewert setzen
  build_dx_attribute_name = lv_new_name
  Exit Function
  
'=== Errorhandler-Definition: Fehler bei der Generierung eines neuen DX-Attributsnamens
err_build_dx_attribute_name:
  build_dx_attribute_name = vbNullString
End Function

Private Function check_name_exist(ByVal pv_excel_name As String) As Boolean
'=== Lokale Datendeklaration
Dim li_name As Name

'=== Registrierung des Errorhandlers (name not exist)
  On Error GoTo err_name_not_exist

'=== |fffd|berpr|fffd|fung ob der |fffd|bergeben Name bereits existiert
  Set li_name = gi_excel_names(pv_excel_name)
  
'=== R|fffd|ckgabewert setzen
  check_name_exist = True
  Exit Function

'=== Errorhandler-Definition: Name existiert nicht
err_name_not_exist:
  check_name_exist = False
End Function

Public Function add_name_to_Range(ByRef pr_range As Range, ByVal pv_excel_name As String) As Boolean
'=== Lokale Datendeklaration
Dim li_name As Name

'=== Registrierung des Errorhandlers (add name to range)
  On Error GoTo err_add_name_to_range
  
'=== Hinzuf|fffd|gen des neuen Namens
  Set li_name = gi_excel_names.Add(pv_excel_name, pr_range)
  If li_name Is Nothing Then GoTo err_add_name_to_range
  
'=== R|fffd|ckgabewert setzen
  add_name_to_Range = True
  Exit Function

'=== Errorhandler-Definition: Fehler beim Hinzuf|fffd|gen des |fffd|bergebenen Namens
err_add_name_to_range:
  add_name_to_Range = False
End Function

Public Function get_Template_Block_Name(ByVal pv_stid As String) As String
'=== Lokale Datendeklaration
Dim li_name      As Name
Dim lv_tpl_name  As String
Dim li_name_data As clsNameData

'=== Registrierung des Errorhandlers (resume next)
  On Error Resume Next

'=== Ermittlung des zum |fffd|bergebenen DX-Schritts geh|fffd|renden Templatenamens
  For Each li_name In gi_excel_names
    If li_name.Name <> "'8D Form'!Print_Area" And li_name.Name <> "'8D Form'!_FilterDatabase" Then
    
    Set li_name_data = get_name_data(li_name.Name)
    If Not li_name_data Is Nothing Then
      If li_name_data.gv_stid = pv_stid And li_name_data.gv_indx = 1 And li_name_data.gv_fnam = vbNullString Then
        lv_tpl_name = li_name.Name
        Exit For
      End If
    End If
    End If
  Next li_name

'=== R|fffd|clgabewert setzen
  get_Template_Block_Name = lv_tpl_name
End Function

Public Function Check_Name_Refers_to_Range(ByVal pv_excel_name As String) As Boolean
'=== Lokale Datendeklaration
Dim lr_range As Range

'=== Registrierung des Errorhandlers (name has no reference)
  On Error GoTo err_name_has_no_reference

'=== |fffd|berpr|fffd|fung ob der |fffd|bergebene Name eine g|fffd|ltige Referenz besitzt
  Set lr_range = gi_excel_names(pv_excel_name).RefersToRange
  If lr_range Is Nothing Then GoTo err_name_has_no_reference

'=== R|fffd|ckgabewert setzen
  Check_Name_Refers_to_Range = True
  Exit Function

'=== Errorhandler-Definition: der |fffd|bergeben Name besitzt keine g|fffd|ltige Referenz
err_name_has_no_reference:
  Check_Name_Refers_to_Range = False
End Function

Public Function Set_Name_Visibility(ByVal pv_excel_name As String, ByVal pv_visible As Boolean) As Boolean
'=== Registrierung des Errorhandlers (cannot change visibility)
  On Error GoTo err_by_setting_name_visibility

'=== |fffd|berpr|fffd|fung ob der |fffd|berg. Wert existiert
  If check_name_exist(pv_excel_name) = False Then GoTo err_by_setting_name_visibility
  
'=== |fffd|berpr|fffd|fung ob der |fffd|bergebene Name eine g|fffd|ltige Referenz besitzt
  gi_excel_names(pv_excel_name).Visible = pv_visible
  Exit Function

'=== Errorhandler-Definition: die Visible Eigenschaft des |fffd|berg. Namen konnte nicht umgesetzt werden
err_by_setting_name_visibility:
  Exit Function
End Function

Public Function Set_Names_Visibility(ByVal pv_visible As Boolean)
'=== Lokale Datendeklaration
Dim li_name      As Name
Dim li_name_data As New clsNameData

'=== Registrierung des Errorhandlers (resume next)
  On Error Resume Next

'=== |fffd|ndern der Eigenschaft Visible f|fffd|r alle Excel-Namen auf den |fffd|berg. Parameter
  For Each li_name In gi_excel_names
    Set li_name_data = get_name_data(li_name.Name)
    If li_name_data.gv_stid <> vbNullString And li_name_data.gv_kind <> 0 And li_name_data.gv_indx <> 0 Then
      Set_Name_Visibility (li_name.Name), pv_visible
    End If
  Next li_name
End Function

Public Function Check_Name_is_in_Range(ByVal pv_name As String, ByRef pr_range As Range) As Boolean
'=== Lokale Datendeklaration
Dim lr_name_range      As Range
Dim lv_area_row_end    As Integer
Dim lv_area_row_start  As Integer
Dim lv_area_col_end    As Integer
Dim lv_area_col_start  As Integer
Dim lv_range_row_end   As Integer
Dim lv_range_row_start As Integer
Dim lv_range_col_end   As Integer
Dim lv_range_col_start As Integer

'=== Registrierung des Errorhandlers (check name in range)
  On Error GoTo err_check_name_in_range

'=== Ermittlung der zum Namen geh|fffd|renden Range
  Set lr_name_range = get_range_by_name(pv_name)
  If lr_name_range Is Nothing Then GoTo err_check_name_in_range

'=== Ermittlung der Area Start und End Informationen
  lv_area_col_start = pr_range.Column
  lv_area_col_end = lv_area_col_start + pr_range.Columns.Count - 1
  lv_area_row_start = pr_range.Row
  lv_area_row_end = lv_area_row_start + pr_range.Rows.Count - 1

'=== Ermittlung der Range Start und End Informationen
  lv_range_col_start = lr_name_range.Column
  lv_range_col_end = lv_range_col_start + lr_name_range.Columns.Count - 1
  lv_range_row_start = lr_name_range.Row
  lv_range_row_end = lv_range_row_start + lr_name_range.Rows.Count - 1

'=== |fffd|berpr|fffd|fung ob die NamensRange in der |fffd|bergebenen Range liegt
  If lv_range_col_start >= lv_area_col_start And lv_range_col_start <= lv_area_col_end And lv_range_col_end <= lv_area_col_end Then
    If lv_range_row_start >= lv_area_row_start And lv_range_row_start <= lv_area_row_end And lv_range_row_end <= lv_area_row_end Then
      Check_Name_is_in_Range = True
    End If
  End If

'=== Funktion verlassen
  Exit Function

'=== Errorhandler-Definition: Fehler w|fffd|hrend der |fffd|berpr|fffd|fung
err_check_name_in_range:
  Exit Function
End Function
Attribute VB_Name = "clsPasteInfo"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Public gv_ins_sheet As Worksheet
Public gv_ins_adrs  As String
Public gv_ins_range As Range
Attribute VB_Name = "clsSupplier8D"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

'=== Globale Datendeklaration
Public gi_application_names As New clsNames

'=== Globale Konstantendeklaration
Const gc_supplier_8d_txt = "REPORT_8D"

Public Function Create_Actionbox(ByVal pv_title As String, ByRef pi_commandbars As CommandBars, ByRef pi_names As Names) As clsActionbox
'=== Lokale Datendeklaration
Dim li_actionbox As New clsActionbox
Dim lv_subrc     As Boolean

'=== Erzeugung der neuen 8D Aktionbox
  lv_subrc = li_actionbox.Create_Commandbar(pi_commandbars, pv_title)
  If lv_subrc = False Then Exit Function

'=== Hinzuf|fffd|gen der 8D Funktionen
  lv_subrc = Add_Actionbox_Functions(li_actionbox, pi_names)
  If lv_subrc = False Then Exit Function

'=== Optimierung der Aktionbox
  li_actionbox.optimize_commandbar

'=== |fffd|bergabe der erzeugten Aktionboxinstanz
  Set Create_Actionbox = li_actionbox
End Function

Private Function Add_Actionbox_Functions(ByRef pi_actionbox As clsActionbox, ByRef pi_names As Names) As Boolean
'=== Lokale Datendeklaration
Dim li_name      As Name
Dim lr_range     As Range
Dim lv_action    As String
Dim li_name_data As clsNameData

'=== Registrierung des Errorhandlers (Add Actionbox functions)
  On Error GoTo err_add_functions

'=== Ermittlung der Lieferanten 8D Funktionen
  For Each li_name In gi_application_names.gi_excel_names
    Set li_name_data = gi_application_names.get_name_data(li_name.Name)
    If Not li_name_data Is Nothing Then
      If li_name_data.gv_kind = 2 And li_name_data.gv_fnam = "TI" Then lv_action = "Goto_DX_Step"
      If li_name_data.gv_kind = 3 And li_name_data.gv_fnam = "TI" Then lv_action = "Generate_new_DX_Step"

      If lv_action <> vbNullString Then
'=== Hinzuf|fffd|gen der Standardfunktionen
        Set lr_range = li_name.RefersToRange
        If Not lr_range Is Nothing Then
          pi_actionbox.Add_Commandbutton lr_range.Cells(1, 1).Value, lv_action, li_name_data.gv_stid, 39
        End If
      End If
    End If
    Set lr_range = Nothing
    lv_action = vbNullString
  Next li_name

'===  Returncode setzen
  Add_Actionbox_Functions = True
  Exit Function
  
'=== Errorhandler-Definition: Fehler beim Hinzuf|fffd|gen der Aktionboxfunktionen
err_add_functions:
  Add_Actionbox_Functions = False
End Function

Public Function Load_from_XML(ByVal pv_file As String) As Boolean
'=== Lokale Datendeklaration
Dim li_xml As New clsXML

'=== Registrierung des Errorhandlers (Load XML 8D)
  On Error GoTo err_load_from_xml

'=== Laden der Lieferanten 8D XML-Datei
  Load_from_XML = li_xml.Load_XML_File(pv_file)
  If Load_from_XML = False Then Exit Function

'=== Hinzuf|fffd|gen von Administrativen Daten
  If Add_Admin_Data_From_XML(li_xml) <> 0 Then GoTo err_load_from_xml


'=== Hinzuf|fffd|gen der DX-Schritte aus dem XML ins Excel
  'If Add_DX_Steps_From_XML(li_xml.gi_document.SelectSingleNode(gc_supplier_8d_txt).childNodes) <> 0 Then GoTo err_load_from_xml

'=== R|fffd|ckgabewert setzen
  Load_from_XML = True
  Exit Function

'=== Errorhandler-Definition: Fehler beim Laden des Lieferanten 8D's aus einem XML
err_load_from_xml:
  Load_from_XML = False
End Function

Private Function Add_Admin_Data_From_XML(ByRef pi_xml As clsXML) As Long
'=== Lokale Datendeklaration
Dim lv_tpl_code As String
Dim li_root_node As MSXML2.IXMLDOMNode
Dim li_node As MSXML2.IXMLDOMNode
Dim li_sub_node As MSXML2.IXMLDOMNode
Dim s_text_s9 As String
Dim s_text_s9_2 As String
Dim s_sprache As String
Dim s_text_werk As String
Dim s_text_werk_ort As String


'=== Registrierung des Errorhandlers (Add Data From XML Root)
  On Error GoTo err_add_admin_data

'=== Ermittlung des Root-Knotens
  Set li_root_node = pi_xml.gi_document.selectSingleNode(gc_supplier_8d_txt)
  If li_root_node Is Nothing Then GoTo err_add_admin_data
  
'=== Ermittlung des Template-Codes
  lv_tpl_code = pi_xml.get_Attribute_Value(li_root_node, "code")
  If lv_tpl_code = vbNullString Then GoTo err_add_admin_data

'=== |fffd|bernahme des Template-Codes und der Sprache
 ' gi_application_names.get_range_by_name("ADI_1_1_S1").Value = lv_tpl_code
 
'=== Kopffelder |fffd|bernehmen
'=== Knoten HE0
  Set li_node = li_root_node.selectSingleNode("HE0")
  Set li_sub_node = li_node.selectSingleNode("S7")
  If Not li_sub_node Is Nothing Then
    gi_application_names.get_range_by_name("HE0_1_1_S7").Value = li_sub_node.Text
  End If
  Set li_sub_node = li_node.selectSingleNode("S9")
  If Not li_sub_node Is Nothing Then
    If InStr(1, li_sub_node.Text, "/") > 0 Then
      s_text_s9 = Left(li_sub_node.Text, InStr(1, li_sub_node.Text, "/") - 1)
      s_text_s9_2 = Mid(li_sub_node.Text, InStr(1, li_sub_node.Text, "/") + 2, Len(li_sub_node.Text) - InStr(1, li_sub_node.Text, "/"))
      s_text_s9_2 = Right(s_text_s9_2, Len(s_text_s9_2) - InStr(1, s_text_s9_2, "/") - 1)
    Else:
      s_text_s9 = li_sub_node.Text
    End If
  End If
  gi_application_names.get_range_by_name("HE0_1_1_S9").Value = s_text_s9
  gi_application_names.get_range_by_name("HE0_1_1_S9_2").Value = s_text_s9_2
  
  Set li_sub_node = li_node.selectSingleNode("S4")
  If Not li_sub_node Is Nothing Then
    gi_application_names.get_range_by_name("HE0_1_1_S4").Value = li_sub_node.Text
  End If

  
  'Set li_sub_node = li_node.selectSingleNode("S12")
  'If li_sub_node <> vbNullString Then
  '  gi_application_names.get_range_by_name("HE0_1_1_S12").Value = li_sub_node.Text
  'End If
  
  
  Set li_sub_node = li_node.selectSingleNode("S13")
  If Not li_sub_node Is Nothing Then
      If InStr(1, li_sub_node.Text, "/") > 0 Then
      s_text_werk = Mid(li_sub_node.Text, 1, InStr(1, li_sub_node.Text, "/") - 1) ' - 1 - (InStr(1, li_sub_node.Text, "-") + 2))
      s_text_werk_ort = Mid(li_sub_node.Text, InStr(1, li_sub_node.Text, "/") + 2, Len(li_sub_node.Text) - InStr(1, li_sub_node.Text, "/"))
      s_text_werk_ort = Right(s_text_werk_ort, Len(s_text_werk_ort) - InStr(1, s_text_werk_ort, "/") - 1)
      While InStr(1, s_text_werk_ort, "/") > 0
        s_text_werk_ort = Right(s_text_werk_ort, Len(s_text_werk_ort) - InStr(1, s_text_werk_ort, "/") - 1)
      Wend
    Else:
      s_text_werk = li_sub_node.Text
    End If
    gi_application_names.get_range_by_name("HE0_1_1_S12").Value = s_text_werk
    gi_application_names.get_range_by_name("HE0_1_1_S13").Value = s_text_werk_ort
  End If
  
  
  Set li_sub_node = li_node.selectSingleNode("S2")
  If Not li_sub_node Is Nothing Then
    gi_application_names.get_range_by_name("HE0_1_1_S2").Value = li_sub_node.Text
  End If
  
  
  Set li_sub_node = li_node.selectSingleNode("S4")
  If Not li_sub_node Is Nothing Then
    gi_application_names.get_range_by_name("HE0_1_1_S4").Value = li_sub_node.Text
  End If
  
  Set li_sub_node = li_node.selectSingleNode("S8")
  If Not li_sub_node Is Nothing Then
    gi_application_names.get_range_by_name("HE0_1_1_S8").Value = li_sub_node.Text
  End If
  
  Set li_sub_node = li_node.selectSingleNode("S11")
  If Not li_sub_node Is Nothing Then
    gi_application_names.get_range_by_name("HE0_1_1_S11").Value = li_sub_node.Text
  End If
  
  Set li_sub_node = li_node.selectSingleNode("S1")
  If Not li_sub_node Is Nothing Then
    gi_application_names.get_range_by_name("HE0_1_1_S1").Value = li_sub_node.Text
  End If
  
  Set li_sub_node = li_node.selectSingleNode("S16")
  If Not li_sub_node Is Nothing Then
    gi_application_names.get_range_by_name("HE0_1_1_S16").Value = li_sub_node.Text
  End If
  
  Set li_sub_node = li_node.selectSingleNode("S17")
  If Not li_sub_node Is Nothing Then
    gi_application_names.get_range_by_name("HE0_1_1_S17").Value = li_sub_node.Text
  End If
  
  Set li_sub_node = li_node.selectSingleNode("S18")
  If Not li_sub_node Is Nothing Then
    gi_application_names.get_range_by_name("HE0_1_1_S18").Value = li_sub_node.Text
  End If
  
    Set li_sub_node = li_node.selectSingleNode("S20")
  If Not li_sub_node Is Nothing Then
    gi_application_names.get_range_by_name("HE0_1_1_S20").Value = li_sub_node.Text
  End If
  
  Set li_sub_node = li_node.selectSingleNode("S21")
  If Not li_sub_node Is Nothing Then
    gi_application_names.get_range_by_name("HE0_1_1_S21").Value = li_sub_node.Text
  End If
  
  Set li_sub_node = li_node.selectSingleNode("S23")
  If Not li_sub_node Is Nothing Then
    If li_sub_node.Text <> "0.000" And li_sub_node.Text <> " " Then
      gi_application_names.get_range_by_name("HE0_1_1_S23").Value = "Yes"
    Else
      gi_application_names.get_range_by_name("HE0_1_1_S23").Value = "No"
    End If
  Else
      gi_application_names.get_range_by_name("HE0_1_1_S23").Value = "No"
  End If
  
  Set li_sub_node = li_node.selectSingleNode("S22")
  If Not li_sub_node Is Nothing Then
    If li_sub_node.Text = "035" Then
      gi_application_names.get_range_by_name("HE0_1_1_S22").Value = "Field"
    Else
      gi_application_names.get_range_by_name("HE0_1_1_S22").Value = "0 km/miles"
    End If
  Else
      gi_application_names.get_range_by_name("HE0_1_1_S22").Value = "0 km/miles"
  End If
  
'=== Knoten HE1
  Set li_node = li_root_node.selectSingleNode("HE1")
  Set li_sub_node = li_node.selectSingleNode("S1")
  If Not li_sub_node Is Nothing Then
    gi_application_names.get_range_by_name("HE1_1_1_S1").Value = li_sub_node.Text
  End If
  Set li_sub_node = li_node.selectSingleNode("S3")
  If Not li_sub_node Is Nothing Then
    gi_application_names.get_range_by_name("HE1_1_1_S3").Value = li_sub_node.Text
  End If
  Set li_sub_node = li_node.selectSingleNode("S4")
  If Not li_sub_node Is Nothing Then
    gi_application_names.get_range_by_name("HE1_1_1_S4").Value = li_sub_node.Text
  End If
  
'=== Knoten D20
  Set li_node = li_root_node.selectSingleNode("D20")
  Set li_sub_node = li_node.selectSingleNode("S1")
  If Not li_sub_node Is Nothing Then
    gi_application_names.get_range_by_name("D20_1_1_S1").Value = li_sub_node.Text
  End If
  Set li_sub_node = li_node.selectSingleNode("S2")
  If Not li_sub_node Is Nothing Then
    gi_application_names.get_range_by_name("D20_1_1_S2").Value = li_sub_node.Text
  End If
  Set li_sub_node = li_node.selectSingleNode("S8")
  If Not li_sub_node Is Nothing Then
    gi_application_names.get_range_by_name("D20_1_1_S8").Value = li_sub_node.Text
  End If
  Set li_sub_node = li_node.selectSingleNode("S11")
  If Not li_sub_node Is Nothing Then
    gi_application_names.get_range_by_name("D20_1_1_S11").Value = li_sub_node.Text
  End If
'=== Sprache setzen
'  Set li_node = li_root_node.selectSingleNode("HE0")
'  Set li_sub_node = li_node.selectSingleNode("S19")
'  'gi_application_names.get_range_by_name("HE0_1_1_S19").Value = li_sub_node.Text
'  Select Case li_sub_node.Text
'    Case "D"
'      s_sprache = "German"
'    Case "E"
'      s_sprache = "English"
'    Case Else
'      s_sprache = "English"
'  End Select
'  Tabelle3.ComboBox1.Text = s_sprache
'  Tabelle3.ComboBox1_Change
  
  '=== R|fffd|ckgabewerts setzen und Funktion verlassen
  Add_Admin_Data_From_XML = 0
  Exit Function
  
'=== Errorhandler-Definition: Fehler beim Hinzuf|fffd|gen von XML Root Daten
err_add_admin_data:
  Add_Admin_Data_From_XML = 1
End Function

Private Function Add_DX_Steps_From_XML(ByRef pi_xml_nodes As MSXML2.IXMLDOMNodeList) As Long
'=== Lokale Datendeklaration
Dim li_dx_node      As MSXML2.IXMLDOMNode
Dim li_dx_subnode   As MSXML2.IXMLDOMNode
Dim li_dx_step      As clsDxStep
Dim lv_name         As String
Dim lv_new          As Boolean
Dim lv_template     As String
Dim lv_old_basename As String

'=== Registrierung des Errorhandlers (Add DX Steps from XML)
  On Error GoTo err_add_dx_steps

'=== Wenn keine Elemente vorhanden sind Exit ohne Fehlercode
  If pi_xml_nodes.Length = 0 Then Exit Function

'=== Erzeugung neuer SX-Schritte pro relevantem Segment
  For Each li_dx_node In pi_xml_nodes

'=== Ermittlung des zum DX-Schritt geh|fffd|renden Templates (sofern notwendig)
    If lv_old_basename <> li_dx_node.baseName Then
      lv_template = gi_application_names.get_Template_Block_Name(li_dx_node.baseName)
      If lv_template = vbNullString Then GoTo err_add_dx_steps
    
'=== Lokale Variablen initialisieren
      lv_new = False
    End If

'=== Erzeugung einer neuen DX-Schrittinstanz
    Set li_dx_step = Generate_DX_Step(li_dx_node.baseName, lv_template, lv_new)
    If li_dx_step Is Nothing Then GoTo err_add_dx_steps

'=== Hinzuf|fffd|gen der zugeh|fffd|rigen DX-Attribute (Untersegmente)
    For Each li_dx_subnode In li_dx_node.childNodes
      lv_name = li_dx_step.gv_name & "_" & li_dx_subnode.baseName
      li_dx_step.Add_Attribute_Value li_dx_subnode.baseName, li_dx_subnode.Text
    Next li_dx_subnode
  
'=== Abh|fffd|ngig des Kennzeichens GV_NEW wird ein bestehender Schritt modifiziert oder hinzugef|fffd|gt
    If li_dx_step.gv_new = False Then
      Add_DX_Steps_From_XML = modify_dx_step(li_dx_step)
    ElseIf li_dx_step.gv_new = True Then
      Add_DX_Steps_From_XML = insert_dx_step(li_dx_step)
    End If
    lv_new = True

'=== Aktuellen Basename merken
    lv_old_basename = li_dx_node.baseName
  Next li_dx_node

'=== Funktion verlassen
  Exit Function

'=== Errorhandler-Definition: Fehler beim Hinzuf|fffd|gen von XML DX-Schritten
err_add_dx_steps:
  Add_DX_Steps_From_XML = 1
End Function

Public Function insert_dx_step(ByRef pi_dx_step As clsDxStep) As Long
'=== Lokale Datendeklaration
Dim lv_new_range_name As String
Dim lv_subrc          As Boolean
Dim li_paste_info     As clsPasteInfo

'=== Registrierung des Errorhandlers (insert DX Step)
On Error GoTo err_insert_dx_step

'=== Kopieren des Templateblocks
  pi_dx_step.gt_range.copy

'=== Einf|fffd|gen des neuen DX-Schritts
  Set li_paste_info = paste_new_data(pi_dx_step)
  If li_paste_info Is Nothing Then GoTo err_insert_dx_step

'=== Einf|fffd|gen des neuen DX-Schritt-Namens
  lv_subrc = add_new_block_name(li_paste_info, pi_dx_step)
  If lv_subrc = False Then GoTo err_insert_dx_step

'=== Einf|fffd|gen der neuen DX-Schritt-Attributsnamen
  lv_subrc = add_new_field_names(li_paste_info, pi_dx_step)
  If lv_subrc = False Then GoTo err_insert_dx_step
 
'=== Hinzuf|fffd|gen der neuen Feldwerte
  lv_subrc = add_new_field_values(pi_dx_step)
  If lv_subrc = False Then GoTo err_insert_dx_step
  
'=== R|fffd|ckgabewert setzen
  insert_dx_step = 0
  Exit Function

'=== Errorhandler-Definition: Fehler beim Hinzuf|fffd|gen eines DX-Schritts
err_insert_dx_step:
  insert_dx_step = 1
End Function

Private Function add_new_field_values(ByRef pi_dx_step As clsDxStep) As Boolean
'=== Lokale Datendeklaration
Dim lt_attributes() As New clsAttribute
Dim li_attribute    As clsAttribute
Dim lv_att_count    As Long
Dim lr_range        As Range

'=== Registrierung des Errorhandlers (add new field values)
On Error GoTo err_add_field_values

'=== l|fffd|schen der bisherigen Attributswerte
' clear_field_values pi_dx_step.gv_name
  
'=== Ermittlung der zum DX-Schritt geh|fffd|renden Attribute aus der DX-Instanz
  lt_attributes() = pi_dx_step.Get_Attributes

'=== Hinzuf|fffd|gen der neuen Attributeswerte in Excel
  For lv_att_count = 1 To UBound(lt_attributes())
    Set li_attribute = lt_attributes(lv_att_count)
    If li_attribute Is Nothing Then GoTo err_add_field_values
    
    Set lr_range = gi_application_names.get_range_by_name(li_attribute.gv_name)
    If lr_range Is Nothing Then GoTo err_add_field_values
    
    If li_attribute.gv_xml_tag <> "IPI" Then
      lr_range.Value = vbNullString
      lr_range.Value = li_attribute.gv_value
    Else
       modAttachment.insert_attachment lr_range, li_attribute.gv_value
    End If
  Next lv_att_count

'=== R|fffd|ckgabewert setzen
  add_new_field_values = True
  Exit Function

'=== Errorhandler-Definition: Fehler beim Hinzuf|fffd|gen der neuen Attributswerte
err_add_field_values:
  add_new_field_values = False
End Function

Private Function clear_field_values(ByVal pv_dx_name As String)
'=== Lokale Datendeklaration
Dim lr_range As Range

'=== Registrierung des Errorhandlers (clear field values)
  On Error GoTo err_clear_field_values

  '=== Ermittlung der eingef|fffd|gten Range
  Set lr_range = gi_application_names.get_range_by_name(pv_dx_name)
  If lr_range Is Nothing Then GoTo err_clear_field_values

'=== Zelleninhalte l|fffd|schen
  lr_range.ClearContents
  Exit Function

'=== Errorhandler-Definition: Fehler beim L|fffd|schen der Feldinhalte
err_clear_field_values:
  Exit Function
End Function

Private Function add_new_field_names(ByRef pi_paste_info As clsPasteInfo, ByRef pi_dx_step As clsDxStep) As Boolean
'=== Lokale Datendeklaration
Dim lt_attributes() As New clsAttribute
Dim li_attribute    As clsAttribute
Dim lv_att_count    As Long
Dim lv_subrc        As Boolean
Dim lr_range        As Range

'=== Registrierung des Errorhandlers (add new field names)
On Error GoTo err_add_new_field_names

'=== Ermittlung des eingef|fffd|gten Blocks
  Set lr_range = gi_application_names.get_range_by_name(pi_dx_step.gv_name)
  If lr_range Is Nothing Then GoTo err_add_new_field_names
  
'=== Ermittlung der zum DX-Schritt geh|fffd|renden Attribute aus der DX-Instanz
  lt_attributes() = pi_dx_step.Get_Attributes

'=== Hinzuf|fffd|gen der neuen Attributsnamen
  For lv_att_count = 1 To UBound(lt_attributes())
    Set li_attribute = lt_attributes(lv_att_count)
    If li_attribute Is Nothing Then GoTo err_add_new_field_names
    
    lv_subrc = gi_application_names.add_name_to_Range(lr_range.Cells(li_attribute.gv_row_id, li_attribute.gv_column_id), li_attribute.gv_name)
    If lv_subrc = False Then GoTo err_add_new_field_names
    gi_application_names.Set_Name_Visibility li_attribute.gv_name, False
  Next lv_att_count

'=== R|fffd|ckgabewerts setzen
  add_new_field_names = True
  Exit Function

'=== Errorhandler-Definition: Fehler beim Hinzuf|fffd|gen der neuen Attributsnamen
err_add_new_field_names:
  add_new_field_names = False
End Function

Private Function add_new_block_name(ByRef pi_paste_info As clsPasteInfo, ByRef pi_dx_step As clsDxStep) As Boolean
'=== Lokale Datendeklaration
Dim lr_range As Range
Dim lv_subrc As Boolean

'=== Registrierung des Errorhandlers (add new block name)
On Error GoTo err_add_new_block_name
  
'=== Hinzuf|fffd|gen des neuen Blocknamens
  lv_subrc = gi_application_names.add_name_to_Range(pi_paste_info.gv_ins_range, pi_dx_step.gv_name)
  If lv_subrc = False Then GoTo err_add_new_block_name
   gi_application_names.Set_Name_Visibility pi_dx_step.gv_name, False

'=== R|fffd|ckgabewert setzen
  add_new_block_name = True
  Exit Function

'=== Errorhandler-Definition: Fehler beim Hinzuf|fffd|gen des neuen Blocknamens
err_add_new_block_name:
  add_new_block_name = False
End Function

Private Function get_insert_range(ByRef pi_paste_info As clsPasteInfo, ByRef pr_paste_range As Range) As Range
'=== Lokale Datendeklaration
Dim lv_start_adrs As String
Dim lv_end_adrs   As String
Dim lv_start_row  As Long
Dim lv_end_row    As Long

'=== Registrierung des Errorhandlers (get insert range)
  On Error GoTo err_get_insert_range

'=== Ermittlung des eingef|fffd|gten Blocks (Anfang)
  lv_start_row = pi_paste_info.gv_ins_sheet.Rows.Range(pi_paste_info.gv_ins_adrs).Row
  lv_start_adrs = pi_paste_info.gv_ins_sheet.Rows.Cells(lv_start_row, 1).Address
  
'=== Ermittlung des eingef|fffd|gten Blocks (Ende)
  lv_end_row = lv_start_row + pr_paste_range.Rows.Count - 1
  lv_end_adrs = pi_paste_info.gv_ins_sheet.Rows.Cells(lv_end_row, pr_paste_range.Columns.Count).Address
  
'=== R|fffd|ckgabewert setzen
  Set get_insert_range = pi_paste_info.gv_ins_sheet.Rows.Range(lv_start_adrs, lv_end_adrs)
  Exit Function

'=== Errorhandler-Definition: Fehler bei der Ermittlung der neu eingef|fffd|gten Range
err_get_insert_range:
  Set get_insert_range = Nothing
End Function

Private Function paste_new_data(ByRef pi_dx_step As clsDxStep) As clsPasteInfo
'=== Lokale Datendeklaration
Dim li_paste_info As clsPasteInfo

'=== Registrierung des Errorhandlers (paste new data)
  On Error GoTo err_paste_new_data

'=== Ermittlung der Zeilenadresse f|fffd|r den Insert
  Set li_paste_info = get_insert_adrs(pi_dx_step.gv_stid)
  If li_paste_info Is Nothing Then GoTo err_paste_new_data
  
'=== Einf|fffd|gen der kopierten Zeilen an der ermittelten Stelle
  li_paste_info.gv_ins_sheet.Rows(li_paste_info.gv_ins_adrs).Insert pi_dx_step.gt_range.Rows.Count

'=== Ermittlung des eingef|fffd|gten Zeilenblocks (Anfang und Ende)
  Set li_paste_info.gv_ins_range = get_insert_range(li_paste_info, pi_dx_step.gt_range)
  If li_paste_info Is Nothing Then GoTo err_paste_new_data

'=== R|fffd|ckgabewert setzen
  Set paste_new_data = li_paste_info
  Exit Function

'=== Errorhandler-Definition: Fehler beim Einf|fffd|gen der neuen Range
err_paste_new_data:
  Set paste_new_data = Nothing
End Function

Private Function get_insert_adrs(ByVal pv_stid As String) As clsPasteInfo
'=== Lokale Datendeklaration
Dim li_name        As Name
Dim li_name_data   As clsNameData
Dim lr_range       As Range
Dim lv_row         As Long
Dim lv_current_row As Long
Dim lr_name_range  As Range
Dim li_paste_info  As New clsPasteInfo

'=== Registrierung des Errorhandlers (paste new data)
On Error GoTo err_get_insert_adrs

'=== Ermittlung der zuletzt eingef|fffd|gten Range f|fffd|r den aktuellen Step
  For Each li_name In gi_application_names.gi_excel_names
    Set li_name_data = gi_application_names.get_name_data(li_name.Name)
    If Not li_name_data Is Nothing Then
      If li_name_data.gv_stid = pv_stid And li_name_data.gv_kind = 3 And li_name_data.gv_fnam = vbNullString Then
        Set lr_range = gi_application_names.get_range_by_name(li_name.Name)
        If Not lr_range Is Nothing Then
          lv_current_row = lr_range.Row + lr_range.Rows.Count
          If lv_current_row > lv_row Then
            lv_row = lv_current_row
            Set lr_name_range = lr_range
          End If
        End If
      End If
    End If
    Set lr_range = Nothing
  Next li_name
  
'=== R|fffd|ckgabewert setzen
  Set li_paste_info.gv_ins_sheet = lr_name_range.Worksheet
  li_paste_info.gv_ins_adrs = li_paste_info.gv_ins_sheet.Rows(lv_row).AddressLocal
  Set get_insert_adrs = li_paste_info
  Exit Function

'=== Errorhandler-Definition: Fehler bei der Ermittlung der Insert-Adresse
err_get_insert_adrs:
  Set get_insert_adrs = Nothing
End Function

Public Function modify_dx_step(ByRef pi_dx_step As clsDxStep) As Long
'=== Lokale Datendeklaration
Dim lt_attributes() As clsAttribute
Dim lr_range        As Range
Dim lv_att_count    As Long

'=== Registrierung des Errorhandlers (modify dx step)
On Error GoTo err_modify_dx_step

'=== Ermittlung der zum DX-Schritt geh|fffd|renden Attribute aus der DX-Instanz
  lt_attributes() = pi_dx_step.Get_Attributes
  
'=== Modifizieren der DX-Attribute in Excel
  For lv_att_count = 1 To UBound(lt_attributes())
    If Not IsEmpty(lt_attributes(lv_att_count).gv_value) Then
      Set lr_range = gi_application_names.get_range_by_name(lt_attributes(lv_att_count).gv_name)
      If lr_range Is Nothing Then GoTo err_modify_dx_step
      
      If lt_attributes(lv_att_count).gv_xml_tag <> "IPI" Then
        lr_range.Value = lt_attributes(lv_att_count).gv_value
      Else
        modAttachment.insert_attachment lr_range, lt_attributes(lv_att_count).gv_value
      End If
    End If
  Next lv_att_count

'=== R|fffd|ckgabewert setzen
  modify_dx_step = 0
  Exit Function

'=== Errorhandler-Definition: Fehler bei der Modifizierung des DX-Schritts
err_modify_dx_step:
  modify_dx_step = 1
End Function

Public Function Generate_DX_Step(ByVal pv_stid As String, ByVal pv_tpl_name As String, ByVal pv_new As Boolean) As clsDxStep
'=== Lokale Datendeklaration
' Dim lr_tpl_block As Range
Dim li_dx_step   As New clsDxStep
Dim lv_subrc     As Boolean
Dim lv_name      As String
Dim li_name_data As clsNameData

'=== Registrierung des Errorhandlers (generate dx step)
On Error GoTo err_generate_dx_step

'=== Ermittlung bzw. Generierung eines DX-Schritt Namens
  If pv_new = False Then lv_name = pv_tpl_name
  If pv_new = True Then lv_name = gi_application_names.build_new_dx_name(pv_tpl_name)

'=== Ermittlung des Templateblocks
'  Set lr_tpl_block = gi_application_names.get_range_by_name(pv_tpl_name)
'  If lr_tpl_block Is Nothing Then GoTo err_generate_dx_step
  
'=== Erzeugung einer neuen Instanz f|fffd|r den aktuellen DX-Schritt
  li_dx_step.initialize gi_application_names
  lv_subrc = li_dx_step.Add_Dx_Step(pv_tpl_name, pv_stid, lv_name, pv_new)
  If lv_subrc = False Then GoTo err_generate_dx_step
  
'=== R|fffd|ckgabewert setzen
  Set Generate_DX_Step = li_dx_step
  Exit Function

'=== Errorhandler-Definition: Fehler bei der Generierung eines DX-Schritts
err_generate_dx_step:
  Set Generate_DX_Step = Nothing
End Function

Public Function export_to_xml(ByVal pv_filename As String) As Boolean
'=== Lokale Datendeklaration
Dim li_xml       As New clsXML
Dim li_root_node As MSXML2.IXMLDOMElement
Dim lv_subrc     As Boolean

'=== Registrierung des Errorhandlers (export to xml)
  On Error GoTo err_export_to_xml

'=== Hinzuf|fffd|gen von Generierungsinformationen
  lv_subrc = li_xml.Add_Processing_Informations("xml", "version=""1.0""")
  If lv_subrc = False Then GoTo err_export_to_xml

'=== Hinzuf|fffd|gen des Root-Knotens
  Set li_root_node = li_xml.gi_document.createElement(gc_supplier_8d_txt)
  If li_root_node Is Nothing Then GoTo err_export_to_xml
  li_xml.gi_document.appendChild li_root_node

'=== Hinzuf|fffd|gen der Rootattribute
  li_root_node.setAttribute "date", Format(Date, "DD.MM.YYYY")
  li_root_node.setAttribute "time", Format(Time, "hh:mm:ss")
  li_root_node.setAttribute "code", gi_application_names.get_range_by_name("ADI_1_1_S1").Value
  
'=== Ermittlung und Mapping der Excel-DX-Schritte ins XML-Format
  If get_and_mapp_dx_steps_for_xml(li_xml, li_root_node, "HE0") = False Then GoTo err_export_to_xml
  If get_and_mapp_dx_steps_for_xml(li_xml, li_root_node, "HE1") = False Then GoTo err_export_to_xml
  If get_and_mapp_dx_steps_for_xml(li_xml, li_root_node, "HE2") = False Then GoTo err_export_to_xml
  If get_and_mapp_dx_steps_for_xml(li_xml, li_root_node, "D10") = False Then GoTo err_export_to_xml
  If get_and_mapp_dx_steps_for_xml(li_xml, li_root_node, "D11") = False Then GoTo err_export_to_xml
  If get_and_mapp_dx_steps_for_xml(li_xml, li_root_node, "D12") = False Then GoTo err_export_to_xml
  If get_and_mapp_dx_steps_for_xml(li_xml, li_root_node, "D13") = False Then GoTo err_export_to_xml
  If get_and_mapp_dx_steps_for_xml(li_xml, li_root_node, "D14") = False Then GoTo err_export_to_xml
  If get_and_mapp_dx_steps_for_xml(li_xml, li_root_node, "D20") = False Then GoTo err_export_to_xml
  If get_and_mapp_dx_steps_for_xml(li_xml, li_root_node, "D30") = False Then GoTo err_export_to_xml
  If get_and_mapp_dx_steps_for_xml(li_xml, li_root_node, "D40") = False Then GoTo err_export_to_xml
  If get_and_mapp_dx_steps_for_xml(li_xml, li_root_node, "D41") = False Then GoTo err_export_to_xml
  If get_and_mapp_dx_steps_for_xml(li_xml, li_root_node, "D42") = False Then GoTo err_export_to_xml
  If get_and_mapp_dx_steps_for_xml(li_xml, li_root_node, "D43") = False Then GoTo err_export_to_xml
  If get_and_mapp_dx_steps_for_xml(li_xml, li_root_node, "D50") = False Then GoTo err_export_to_xml
  If get_and_mapp_dx_steps_for_xml(li_xml, li_root_node, "D60") = False Then GoTo err_export_to_xml
  If get_and_mapp_dx_steps_for_xml(li_xml, li_root_node, "D61") = False Then GoTo err_export_to_xml
  If get_and_mapp_dx_steps_for_xml(li_xml, li_root_node, "D62") = False Then GoTo err_export_to_xml
  If get_and_mapp_dx_steps_for_xml(li_xml, li_root_node, "D70") = False Then GoTo err_export_to_xml
  If get_and_mapp_dx_steps_for_xml(li_xml, li_root_node, "D71") = False Then GoTo err_export_to_xml
  If get_and_mapp_dx_steps_for_xml(li_xml, li_root_node, "D80") = False Then GoTo err_export_to_xml
  If get_and_mapp_dx_steps_for_xml(li_xml, li_root_node, "D81") = False Then GoTo err_export_to_xml

'=== Sichern des Erstellten XML-Files
  export_to_xml = li_xml.Save_XML_File(pv_filename)
  Exit Function
  
'=== Errorhandler-Definition: Fehler bei der Exportierung der XML-Datei
err_export_to_xml:
  export_to_xml = False
End Function

Private Function get_and_mapp_dx_steps_for_xml(ByRef pi_xml As clsXML, ByRef pi_root_node As MSXML2.IXMLDOMElement, ByVal pv_stid As String) As Boolean
'=== Lokale Datendeklaration
Dim li_dx_steps() As clsDxStep
Dim li_dx_node    As MSXML2.IXMLDOMElement
Dim lv_dx_count   As Long

'=== Registrierung des Errorhandlers (get and mapp dx step)
  On Error GoTo err_get_and_mapp_dx_steps

'=== Ermittlung aller Excel DX-Schritte
  li_dx_steps() = get_dx_steps_from_excel(pv_stid)

'=== Umwandlung der DX-Schritte in Segmente
  For lv_dx_count = 1 To UBound(li_dx_steps())
    Set li_dx_node = mapp_dx_step_to_node(pi_xml.gi_document, li_dx_steps(lv_dx_count))
    If li_dx_node Is Nothing Then GoTo err_get_and_mapp_dx_steps
      
'=== Hinzuf|fffd|gen des gemappten DX-Schritts zum XML-Rootknoten
    pi_root_node.appendChild li_dx_node
    Set li_dx_node = Nothing
  Next lv_dx_count

'=== R|fffd|ckgabewert setzen
  get_and_mapp_dx_steps_for_xml = True
  Exit Function

'=== Errorhandler-Definition: Fehler beim Mapping der DX-Schritte in Segmente
err_get_and_mapp_dx_steps:
  get_and_mapp_dx_steps_for_xml = False
End Function

Private Function mapp_dx_step_to_node(ByRef pi_xml_document As MSXML2.DOMDocument, ByRef pi_dx_step As clsDxStep) As MSXML2.IXMLDOMElement
'=== Lokale Datendeklaration
Dim li_dx_attributes() As New clsAttribute
Dim li_dx_attribute    As clsAttribute
Dim lv_att_count       As Long
Dim li_att_node        As MSXML2.IXMLDOMElement
Dim li_dx_node         As MSXML2.IXMLDOMElement

'=== Registrierung des Errorhandlers (mapp dx step to node)
  On Error GoTo err_mapp_dx_step_to_node

'=== Erzeugung eines neuen DX-Knotens
  Set li_dx_node = pi_xml_document.createElement(pi_dx_step.gv_stid)
  If li_dx_node Is Nothing Then GoTo err_mapp_dx_step_to_node

'=== Erzeugung der DX-Unterknoten(Felder (Excel-Attribute))
  li_dx_attributes() = pi_dx_step.Get_Attributes
  For lv_att_count = 1 To UBound(li_dx_attributes())
    Set li_dx_attribute = li_dx_attributes(lv_att_count)
    If li_dx_attribute.gv_xml_tag <> vbNullString Then
      Set li_att_node = pi_xml_document.createElement(li_dx_attribute.gv_xml_tag)
      If Not li_att_node Is Nothing Then
        li_att_node.Text = li_dx_attribute.gv_value
        li_dx_node.appendChild li_att_node
        Set li_att_node = Nothing
      End If
    End If
  Next lv_att_count

'=== R|fffd|ckgabewert setzen
  Set mapp_dx_step_to_node = li_dx_node
  Exit Function

'=== Errorhandler-Definition: Fehler beim Mapping eines DX-Schritts zu einem Knoten
err_mapp_dx_step_to_node:
  Exit Function
End Function

Private Function get_dx_steps_from_excel(ByVal pv_stid As String) As clsDxStep()
'=== Lokale Datendeklaration
Dim li_name       As Name
Dim lr_range      As Range
Dim li_name_data  As clsNameData
Dim li_dx_steps() As clsDxStep
Dim li_dx_step    As clsDxStep

'=== Registrierung des Errorhandlers (get dx steps)
  On Error GoTo err_get_dx_steps
  
'=== Lokale Daten initialisieren
  ReDim li_dx_steps(0)

'=== Ermittlung aller DX-Schritte aus Excel
  For Each li_name In gi_application_names.gi_excel_names
    Set li_name_data = gi_application_names.get_name_data(li_name.Name)
    If gi_application_names.Check_Name_Refers_to_Range(li_name.Name) Then
      If Not li_name_data Is Nothing Then
        If li_name_data.gv_stid = pv_stid And li_name_data.gv_fnam = vbNullString Then
          ReDim Preserve li_dx_steps(UBound(li_dx_steps()) + 1)
          'Set li_dx_step = Generate_DX_Step(ls_name.stid, li_name.name, False)
          Set li_dx_steps(UBound(li_dx_steps())) = Generate_DX_Step(li_name_data.gv_stid, li_name.Name, False)
        End If
      End If
    End If
    Set li_dx_step = Nothing
  Next li_name

'=== R|fffd|ckgabewert setzen
  get_dx_steps_from_excel = li_dx_steps()
  Exit Function

'=== Errorhandler-Definition: Fehler bei der Ermittlung der Excel DX-Schritte
err_get_dx_steps:
  Set li_dx_step = Nothing
End Function

Public Function Goto_Step(ByVal pv_tpl_name As String) As Boolean
'=== Lokale Datendeklaration
Dim lr_range As Range

'=== Registrierung des Errorhandlers (goto step)
  On Error GoTo err_goto_step

'=== Ermittlung der zu markierenden Range
  Set lr_range = gi_application_names.get_range_by_name(pv_tpl_name)
  If lr_range Is Nothing Then GoTo err_goto_step
  
'==== Markierung der Range
  lr_range.Worksheet.Select
  lr_range.Select

'=== R|fffd|ckgabewert setzen
  Goto_Step = True
  Exit Function

'=== Errorhandler-Definition: Fehler beim Markieren des DX-Schritts
err_goto_step:
  Goto_Step = False
End Function

Private Sub Class_Initialize()
'=== |fffd|bernahme der Apllikationsnamen
  Set gi_application_names.gi_excel_names = Application.Names
End Sub
Attribute VB_Name = "clsXML"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

'=== Globale Datendeklaration
Public WithEvents gi_document As MSXML2.DOMDocument
Attribute gi_document.VB_VarHelpID = -1

Public Function Load_XML_File(ByVal pv_filename As String) As Boolean
'=== Registrierung des Errorhandlers (load xml file)
  On Error GoTo err_load_xml_file

'=== Existenzpr|fffd|fung des angegebenen XML-Files
  If Check_File_Exist(pv_filename) = False Then GoTo err_load_xml_file

'=== Erzeugung einer neuen DOM - Instanz und Laden des XML-Files
  gi_document.async = False
  gi_document.Load pv_filename
 
'=== |fffd|berpr|fffd|fung des Parsevorgangs
  If gi_document.parseError.errorCode <> 0 Then GoTo err_load_xml_file
  
'=== R|fffd|ckgabewert setzen
  Load_XML_File = True
  Exit Function

'=== Errorhandler-Definition: Fehler beim Laden der XML-Datei
err_load_xml_file:
  Load_XML_File = False
End Function

Public Function Save_XML_File(ByVal pv_filename As String) As Boolean
'=== Registrierung des Errorhandlers (save xml file)
  On Error GoTo err_save_xml_file

'=== Sicherung der XML-Datei
  gi_document.Save pv_filename

'=== setzen des R|fffd|ckgabewerts
  Save_XML_File = True
  Exit Function

'=== Errorhandler-Definition: Fehler beim Sichern der XML-Datei
err_save_xml_file:
  Save_XML_File = False
End Function

Public Function get_Attribute_Value(ByRef po_node As MSXML2.IXMLDOMNode, ByVal pv_attribute As String) As String
'=== Lokale Datendekalration
  Dim li_attribute As MSXML2.IXMLDOMNode

'=== Registrierung des Errorhandlers (get attribute value)
  On Error GoTo err_get_attribute_value

'=== Ermittlung des |fffd|bergebenen Attributwerts
  For Each li_attribute In po_node.Attributes
    If li_attribute.baseName = pv_attribute Then
      get_Attribute_Value = li_attribute.nodeValue
      Exit For
    End If
  Next

'=== Verlassen der Funktion
  Exit Function

'=== Errorhandler-Definition: Fehler bei der Ermittlung eines XML-Attributwerts
err_get_attribute_value:
  get_Attribute_Value = vbNullString
End Function

Private Function Check_File_Exist(ByVal pv_filename As String) As Boolean
'=== Existenzpr|fffd|fung des angegebenen XML-Files
  If Dir$(pv_filename) <> vbNullString Then
    Check_File_Exist = True
  Else
    Check_File_Exist = False
  End If
End Function

Public Function Add_Processing_Informations(ByVal pv_target As String, ByVal pv_data As String) As Boolean
'=== Lokale Datendeklaration
Dim li_instructions As MSXML2.IXMLDOMProcessingInstruction

'=== Registrierung des Errorhandlers (add processing informations)
  On Error GoTo err_add_processing_informations

'=== Hinzuf|fffd|gen von Generierungsinformationen
  Set li_instructions = gi_document.createProcessingInstruction(pv_target, pv_data)
  If li_instructions Is Nothing Then GoTo err_add_processing_informations
  gi_document.insertBefore li_instructions, gi_document.childNodes.Item(0)
  
'=== R|fffd|ckgabewert setzen
  Add_Processing_Informations = True
  Exit Function

'=== Errorhandler-Definition: Fehler bei der Generierung der Processing-Informations
err_add_processing_informations:
  Add_Processing_Informations = False
End Function

Private Sub Class_Initialize()
'=== Erzeugen der XML-Dokument Instanz
  Set gi_document = New MSXML2.DOMDocument
End Sub
Attribute VB_Name = "modAttachment"
'Option Explicit

Public Function insert_attachment(ByRef pr_range As Range, ByVal pv_filename As String) As Long
'=== Registrierung des Errorhandlers (err_Insert_Attachment)
On Error GoTo err_Insert_Attachment

'=== |fffd|berpr|fffd|fung ob das |fffd|berg. Attachment exisitert
  If Check_Attachment_Exist(pv_filename) = False Then Exit Function

'=== |fffd|berpr|fffd|fung des |fffd|berg. Dateinamen (Bild oder OLE-Objekt)
  If check_att_is_picture(pv_filename) = 0 Then
'=== Wenn es sich beim |fffd|berg. Dateinamen um ein Bild handelt --> Bild einf|fffd|gen
    If insert_picture_in_range(pr_range, pv_filename) <> 0 Then GoTo err_Insert_Attachment
  Else
'=== Wenn es sich beim |fffd|berg. Dateinamen nicht um ein Bild handelt --> OLE-Objekt einf|fffd|gen
    If insert_ole_obj_in_range(pr_range, pv_filename) <> 0 Then GoTo err_Insert_Attachment
  End If

'=== R|fffd|ckgabewert setzen und Funktion verlassen
  insert_attachment = 0
  Exit Function

'=== Errorhandler-Definition: Fehler beim Einf|fffd|gen des Attachments
err_Insert_Attachment:
  insert_attachment = 1
End Function

Private Function Check_Attachment_Exist(ByVal pv_filename As String) As Boolean
'=== Existenzpr|fffd|fung des angegebenen Attachment-Files
  If Dir$(pv_filename) <> vbNullString Then
    Check_Attachment_Exist = True
  Else
    Check_Attachment_Exist = False
  End If
End Function

Private Function check_att_is_picture(ByVal pv_filename As String) As Long
'=== Lokale Datendeklaration
Dim lv_file_ext As String

'=== Ermittlung der Dateiendung
  lv_file_ext = get_file_extension(pv_filename)
  If lv_file_ext = vbNullString Then GoTo err_no_picture
  
'=== |fffd|berpr|fffd|fung der Dateiendung auf Bild
  If lv_file_ext <> "JPG" And lv_file_ext <> "BMP" And lv_file_ext <> "GIF" Then GoTo err_no_picture
  
'=== R|fffd|ckgabewert setzen und Funktion verlassen
  check_att_is_picture = 0
  Exit Function
  
'=== Errorhandler-Definition: Datei ist kein Bild
err_no_picture:
  check_att_is_picture = 1
End Function

Private Function get_file_extension(ByVal pv_filename As String) As String
'=== Lokale Datendeklaration
Dim lv_pos      As Integer
Dim lv_filename As String

'=== Registrierung des Errorhandlers (err_get_file_ext)
On Error GoTo err_get_file_ext

'=== Initialisierung der lokalen Variablen / Daten|fffd|bernahme
  lv_pos = 1
  lv_filename = pv_filename

'=== Ermittlung der Dateiendung
  Do
   lv_pos = InStr(1, lv_filename, ".")
   If lv_pos = 0 Then Exit Do
   lv_filename = Mid$(lv_filename, lv_pos + 1)
  Loop Until lv_pos = 0

'=== R|fffd|ckgabewert setzen und Funktion verlassen
  get_file_extension = UCase(lv_filename)
  Exit Function
  
'=== Errorhandler-Definition: Fehler bei der Ermittlung der Dateiendung
err_get_file_ext:
  get_file_extension = vbNullString
End Function

Private Function insert_ole_obj_in_range(ByRef pr_range As Range, ByVal pv_filename As String) As Long
'=== Lokale Datendeklaration
Dim li_ole_object As OLEObject

'=== Registrierung des Errorhandlers (err_Insert_OLE_Object)
On Error GoTo err_Insert_OLE_Object

'=== Einf|fffd|gen der |fffd|berg. Datei (OLE-Objekt) in den |fffd|berg. Bereich
  Set li_ole_object = pr_range.Worksheet.OLEObjects.Add(Filename:=pv_filename, Link:=False, DisplayAsIcon:=True, IconFileName:="PDF", IconIndex:=0, IconLabel:=pv_filename)
  If li_ole_object Is Nothing Then GoTo err_Insert_OLE_Object

'=== Positionierung des OLE-Objekts
  li_ole_object.Left = pr_range.Left + 1
  li_ole_object.Top = pr_range.Top + 1

'=== Konfiguration des neuen OLE-Objekts
  li_ole_object.Locked = False
  li_ole_object.Placement = xlFreeFloating
  
'=== R|fffd|ckgabewert setzen und Funktion verlassen
  insert_ole_obj_in_range = 0
  Exit Function
  
'=== Errorhandler-Definition: Fehler beim Einf|fffd|gen des OLE-Objects
err_Insert_OLE_Object:
  insert_ole_obj_in_range = 1
End Function

Private Function insert_picture_in_range(ByRef pr_range As Range, ByVal pv_filename As String) As Long
'=== Lokale Datendeklaration
Dim li_shape As Shape

'=== Registrierung des Errorhandlers (err_Insert_Picture)
On Error GoTo err_Insert_Picture

'=== Einf|fffd|gen des |fffd|berg. Bild in den |fffd|berg. Bereich
  Set li_shape = pr_range.Worksheet.Shapes.AddPicture(pv_filename, msoTrue, msoTrue, pr_range.Left + 1, pr_range.Top + 1, pr_range.MergeArea.Width - 2, pr_range.MergeArea.Height - 2)
  If li_shape Is Nothing Then GoTo err_Insert_Picture

'=== Default Bildeigenschaften setzen
  li_shape.LockAspectRatio = msoTrue
  li_shape.ScaleWidth 1, msoTrue
  li_shape.Placement = xlFreeFloating

'=== Ausrichtung des Bilds auf die Koordinaten des ermittelten Bereichs
  li_shape.Left = pr_range.Left + 1
  li_shape.Top = pr_range.Top + 1

'=== Anpassung der Bildgr|fffd||fffd|e auf die Gr|fffd||fffd|e des |fffd|berg. Bereichs
  If li_shape.Width - 2 > pr_range.MergeArea.Width Then
    li_shape.Width = pr_range.MergeArea.Width - 2
  End If
    
  If li_shape.Height - 2 > pr_range.MergeArea.Height Then
    li_shape.Height = pr_range.MergeArea.Height - 2
  End If

'=== Ausrichtung des Bilds
'  li_shape.Top = li_shape.Top + ((lr_range.MergeArea.Height - li_shape.Height) / 2) - 1
'  li_shape.Left = li_shape.Left + ((lr_range.MergeArea.Width - li_shape.Width) / 2) - 1
  
'=== R|fffd|ckgabewert setzen und Funktion verlassen
  insert_picture_in_range = 0
  Exit Function

'=== Errorhandler-Definition: Fehler beim Einf|fffd|gen des Complaint Bild
err_Insert_Picture:
  insert_picture_in_range = 1
End Function
Attribute VB_Name = "modOptimize"
Option Explicit

Public Function optimize_row_height()
'=== Lokale Datendeklaration
Dim li_name      As Name
Dim li_names     As New clsNames
Dim li_name_data As clsNameData

'=== Registrierung des Errorhandlers (Resume Next)
  On Error Resume Next

'=== aktuellen Worksheet entsperren
  modWorkbook.unprotect_all_sheets

'=== setzen der Screenupdateing-Eigenschaft
  Application.ScreenUpdating = False

'=== setzen der optimalen Zeilenh|fffd|he f|fffd|r alle verbundenen und gewrappten Zellen
  For Each li_name In Application.Names
    Set li_name_data = li_names.get_name_data(li_name.Name)
    If Not li_name_data Is Nothing Then
      set_optimal_row_height li_name.RefersToRange
    End If
  Next li_name

'=== setzen der Screenupdateing-Eigenschaft
  Application.ScreenUpdating = True

'=== aktuellen Worksheet sperren und Funktion verlassen
  modWorkbook.protect_all_sheets
End Function

Private Function set_optimal_row_height(ByRef pi_range As Range) As Boolean
'=== Lokale Datendeklaration
Dim lv_cur_row_height As Single  'H|fffd|he der Merge Area
Dim lv_cur_col_width  As Single  'Breite der 1. Zelle in der Merge Area
Dim lv_mga_width      As Single  'Merge Area Breite
Dim lr_cur_mga_col    As Range   'Aktuelle Spalte der Merge Area
Dim lv_new_row_height As Single  'neue H|fffd|he der Merge Area

'=== Registrierung des Errorhandlers (set optimal row height)
  On Error GoTo err_set_optimal_row_height

'=== Durchf|fffd|hrung von Ausf|fffd|hrbarkeitspr|fffd|fungen
  If Not pi_range.MergeCells Then Exit Function
  If Not pi_range.MergeArea.WrapText Then Exit Function
  If pi_range.MergeArea.Rows.Count <> 1 Then Exit Function

  With pi_range.MergeArea

'=== Ermittlung der aktuellen Zeilenh|fffd|he
    lv_cur_row_height = .RowHeight

'=== Ermittlung der aktuellen Spaltenbreite
    lv_cur_col_width = pi_range(1, 1).ColumnWidth

'=== Ermittlung der Mergearea-Breite
    For Each lr_cur_mga_col In .Columns
      lv_mga_width = lr_cur_mga_col.ColumnWidth + lv_mga_width
    Next
    lv_mga_width = lv_mga_width + (.Columns.Count - 1) * 0.71

'=== Aufhebung der Merge-Eigenschaft
    .MergeCells = False

'=== setzen der 1 Spalte in der Merge-Area auf die Merge-Area L|fffd|nge
    .Cells(1).ColumnWidth = lv_mga_width

'=== Ausf|fffd|hrung der Auto-Fit Eigenschaft
    .EntireRow.AutoFit

'=== Merken der neuen Zeilenh|fffd|he
    lv_new_row_height = .RowHeight
  
'=== Zur|fffd|cksetzen der Spaltenbreite und wiederherstellung der Merge-Area
    .Cells(1).ColumnWidth = lv_cur_col_width
    .MergeCells = True

'=== setzen der neuen Zeilenh|fffd|he wenn diese > ist als die urspr|fffd|ngliche H|fffd|he
   If lv_cur_row_height < lv_new_row_height Then
     .RowHeight = lv_new_row_height + 4
   Else
     .RowHeight = lv_cur_row_height
   End If
 End With
 
'=== R|fffd|ckgabewert setzen und Funktion verlassen
  set_optimal_row_height = True
  Exit Function

'=== Errorhandler-Definition: Fehler beim Setzen der optimalen Row Height
err_set_optimal_row_height:
  set_optimal_row_height = False
  Exit Function
End Function
Attribute VB_Name = "modSupplier8D"
'Option Explicit

'=== Globale Datendeklaration
Public gv_posnr As Long

Public Function Create_Actionbox() As Boolean
'=== Lokale Datendeklaration
Dim li_supplier_8d As New clsSupplier8D
Dim li_actionbox   As clsActionbox

'=== Registrierung des Errorhandlers (Actionbox)
  On Error GoTo err_Create_Actionbox

'=== Erzeugung der Lieferanten 8D Aktionbox
  Set li_actionbox = li_supplier_8d.Create_Actionbox(Get_Text(modWorkbook.gc_spras, "T07"), Application.CommandBars, Application.Names)
  If li_actionbox Is Nothing Then GoTo err_Create_Actionbox
  
'=== R|fffd|ckgabewert setzen
  Create_Actionbox = True
  Exit Function

'=== Errorhandler-Definition: Fehler bei der Erstellung der Aktionbox
err_Create_Actionbox:
  MsgBox Get_Text(modWorkbook.gc_spras, "T02"), vbOKOnly Or vbCritical, Get_Text(modWorkbook.gc_spras, "T01")
  Create_Actionbox = False
End Function

Public Function Generate_new_DX_Step()
'=== Lokale Datendeklaration
Dim lv_subrc       As Long
Dim lv_parameter   As String
Dim lv_tpl_name    As String
Dim li_supplier_8d As New clsSupplier8D
Dim li_dx_step     As clsDxStep

'=== Registrierung des Errorhandlers (generate new dx step)
  On Error GoTo err_generate_new_dx_step

'=== Screen Update ausschalten
  Application.ScreenUpdating = False

'=== aktuellen Worksheet entsperren
  modWorkbook.unprotect_all_sheets

'=== Ermittlung des ausgew|fffd|hlten Aktionboxfunktionsparameters
  lv_parameter = CommandBars.ActionControl.Parameter
  If lv_parameter = vbNullString Then GoTo err_generate_new_dx_step

'=== Ermittlung des Templateblocknamens
  lv_tpl_name = li_supplier_8d.gi_application_names.get_Template_Block_Name(lv_parameter)
  If lv_tpl_name = vbNullString Then GoTo err_generate_new_dx_step

'=== Generierung des neuen DX-Schritts
  Set li_dx_step = li_supplier_8d.Generate_DX_Step(lv_parameter, lv_tpl_name, True)
  If li_dx_step Is Nothing Then GoTo err_generate_new_dx_step
  
'=== Hinzuf|fffd|gen einer neuen Sortiernummer
' li_dx_step.Add_Attribute_Value "EKEY", Generate_new_EKey(li_supplier_8d.gi_application_names)

'=== Hinzuf|fffd|gen des neuen DX-Schritts
  lv_subrc = li_supplier_8d.insert_dx_step(li_dx_step)
  If lv_subrc <> 0 Then GoTo err_generate_new_dx_step

'=== Screen Update einschalten
  Application.ScreenUpdating = True

'=== Markierung des neu angelegten DX-Schritts und Funktion verlassen
  li_supplier_8d.Goto_Step li_dx_step.gv_name
  
'=== aktuellen Worksheet sperren und Funktion verlassen
  modWorkbook.protect_all_sheets
  Exit Function

'=== Errorhandler-Definition: Fehler bei der Generierung eines neuen DX-Schritts
err_generate_new_dx_step:
  modWorkbook.protect_all_sheets
  Application.ScreenUpdating = True
  MsgBox Get_Text(modWorkbook.gc_spras, "T03", lv_parameter), vbOKOnly Or vbCritical, Get_Text(modWorkbook.gc_spras, "T01")
  Exit Function
End Function

Public Function Goto_DX_Step()
'=== Lokale Datendeklaration
Dim lv_subrc       As Boolean
Dim lv_parameter   As String
Dim lv_tpl_name    As String
Dim li_supplier_8d As New clsSupplier8D

'=== Registrierung des Errorhandlers (goto dx step)
  On Error GoTo err_goto_dx_step

'=== Ermittlung des ausgew|fffd|hlten Aktionboxfunktionsparameters
  lv_parameter = CommandBars.ActionControl.Parameter
  If lv_parameter = vbNullString Then GoTo err_goto_dx_step

'=== Ermittlung des Templateblocknamens
  lv_tpl_name = li_supplier_8d.gi_application_names.get_Template_Block_Name(lv_parameter)
  If lv_tpl_name = vbNullString Then GoTo err_goto_dx_step

'=== Markierung des relevanten DX-Schritts
  lv_subrc = li_supplier_8d.Goto_Step(lv_tpl_name)
  If lv_subrc = False Then GoTo err_goto_dx_step
  
'=== Funktion verlassen
  Exit Function
  
'=== Errorhandler-Definition: Fehler bei der Markierung des ausgew|fffd|hlten DX-Schritts
err_goto_dx_step:
  MsgBox Get_Text(modWorkbook.gc_spras, "T04", lv_parameter), vbOKOnly Or vbCritical, Get_Text(modWorkbook.gc_spras, "T01")
  Exit Function
End Function

Public Function Load_8D_from_XML(Optional ByVal pv_filename As String, Optional ByVal pv_sap_call As String) As String
'=== Lokale Datendeklaration
Dim lv_filename    As String
Dim lv_subrc       As Boolean
Dim li_supplier_8d As New clsSupplier8D

'=== Registrierung des Errorhandlers (load 8D from xml)
  On Error GoTo err_load_8D_from_xml

'=== Screen Update setzen
  If pv_sap_call = vbNullString Then Application.ScreenUpdating = False

'=== Initialisierung der lokalen Variablen
  lv_filename = pv_filename
  
'=== |fffd|berpr|fffd|fung ob ein Filename |fffd|bergeben wurde
  If lv_filename = vbNullString Then Exit Function
  
'=== aktuellen Worksheet entsperren
  modWorkbook.unprotect_all_sheets

'=== Importieren eines Lieferanten 8D's aus einem XML-File
  lv_subrc = li_supplier_8d.Load_from_XML(lv_filename)
  If lv_subrc = False Then GoTo err_load_8D_from_xml

'=== aktuellen Worksheet sperren und Funktion verlassen
  'modWorkbook.protect_all_sheets
  
'=== setzen der Optimalen Zeilenh|fffd|he f|fffd|r verbundene Zellen
  modOptimize.optimize_row_height

'=== Speichern des aktuellen Dokuments
  'ActiveWorkbook.Save

'=== R|fffd|ckgabewert setzen und Erfolgsmeldung ausgeben
  If pv_sap_call = vbNullString Then MsgBox Get_Text(modWorkbook.gc_spras, "T11"), vbOKOnly Or vbInformation, Get_Text(modWorkbook.gc_spras, "T10")
  If pv_sap_call <> vbNullString Then Load_8D_from_XML = Get_Text(modWorkbook.gc_spras, "T11")
  Exit Function

'=== Errorhandler-Definition: Fehler beim Laden des Lieferanten 8D's aus einem XML-File
err_load_8D_from_xml:
  'modWorkbook.protect_all_sheets
  If pv_sap_call = vbNullString Then MsgBox Get_Text(modWorkbook.gc_spras, "T05", lv_filename), vbOKOnly Or vbCritical, Get_Text(modWorkbook.gc_spras, "T01")
  If pv_sap_call <> vbNullString Then Load_8D_from_XML = Get_Text(modWorkbook.gc_spras, "T05", lv_filename)
End Function

Public Function Save_8D_as_XML(Optional ByVal pv_filename As String, Optional ByVal pv_sap_call As String) As Integer
'=== Lokale Datendeklaration
Dim lv_filename    As String
Dim lv_subrc       As Boolean
Dim li_supplier_8d As New clsSupplier8D

'=== Registrierung des Errorhandlers (save 8D as xml)
  On Error GoTo err_save_8D_as_xml

'=== |fffd|bernahme des Dateinamens
  lv_filename = pv_filename

'=== |fffd|berpr|fffd|fung ob ein Filename |fffd|bergeben wurde
  If lv_filename = vbNullString Then Exit Function

'=== Exportieren eines Liefernaten 8D's in ein XML-File
  lv_subrc = li_supplier_8d.export_to_xml(lv_filename)
  If lv_subrc = False Then GoTo err_save_8D_as_xml

'=== R|fffd|ckgabewert setzen und Erfolgsmeldung ausgeben
  If pv_sap_call = vbNullString Then MsgBox Get_Text(modWorkbook.gc_spras, "T09"), vbOKOnly Or vbInformation, Get_Text(modWorkbook.gc_spras, "T10")
  If pv_sap_call <> vbNullString Then Save_8D_as_XML = 0
  Exit Function

'=== Errorhandler-Definition: Fehler beim Laden des Lieferanten 8D's aus einem XML-File
err_save_8D_as_xml:
  If pv_sap_call = vbNullString Then MsgBox Get_Text(modWorkbook.gc_spras, "T06"), vbOKOnly Or vbCritical, Get_Text(modWorkbook.gc_spras, "T01")
  If pv_sap_call <> vbNullString Then Save_8D_as_XML = 1
End Function

Public Function Get_Text(ByVal pv_spras, ByVal pv_id As String, Optional ByVal pv_parm1 As String, Optional ByVal pv_parm2 As String, Optional ByVal pv_parm3 As String) As String
'=== Lokale Datendeklaration
Dim li_sheet       As Worksheet
Dim lv_current_row As Long

'=== Registrierung des Errorhandlers (by getting text)
  On Error GoTo err_by_getting_text
  
'=== setzen des Worksheets mit den Texten
  Set li_sheet = Worksheets("Texte")

'=== Ermittlung des Textes zur |fffd|bergebenen Sprache und ID
  For lv_current_row = 2 To 100
    If li_sheet.Cells(lv_current_row, 2) = pv_spras And li_sheet.Cells(lv_current_row, 1) = pv_id Then
      Get_Text = li_sheet.Cells(lv_current_row, 3).Value
    End If
  Next lv_current_row

'=== Einf|fffd|gen der Parameter in die Fehlermeldung
  Get_Text = Replace(Get_Text, "&1", pv_parm1)
  Get_Text = Replace(Get_Text, "&2", pv_parm2)
  Get_Text = Replace(Get_Text, "&3", pv_parm3)
  
'=== Sollte keine Fehlermeldung gefunden werden, wird eine alternative Meldung ausgegeben
  If Get_Text = vbNullString Then GoTo err_by_getting_text
  Exit Function

'=== Errorhandler-Definition: Fehler bei der Textermittlung
err_by_getting_text:
  Get_Text = "Error: message id " & pv_id & " for language " & pv_spras & " not found"
End Function

Private Function Generate_new_EKey(ByRef pi_excel_names As clsNames, Optional ByVal pv_dx_step As String) As Double
'=== Lokale Datendeklaration
Dim lr_ekeys    As Range
Dim lv_new_ekey As Double

'=== Registrierung des Errorhandlers (save 8D as xml)
  On Error GoTo err_by_generating_ekey

'=== Ermittlung der Externen-Sortiernummernrange
  Set lr_ekeys = pi_excel_names.get_range_by_name("EKEYS")
  If lr_ekeys Is Nothing Then Exit Function

'=== Ermittlung der n|fffd|chst h|fffd|heren externen Sortiernummer
  lv_new_ekey = Application.WorksheetFunction.Max(lr_ekeys) + 1
  If lv_new_ekey = 0 Or Left$(lv_new_ekey, 1) <> 9 Then lv_new_ekey = 9000
  
'=== |fffd|bergabe der neuen Sortiernummer
  Generate_new_EKey = lv_new_ekey
  Exit Function

'=== Errorhandler-Definition: Fehler bei der Generierung einer neuen externen Sortiernummer
err_by_generating_ekey:
  Exit Function
End Function
Attribute VB_Name = "modWorkbook"
Option Explicit

'=== Globale Datendeklaration
Public Const gc_spras = "DE"


Sub Activate()
'=== Lokale Datendeklaration
Dim lv_subrc As Boolean

'=== Registrierung des Errorhandlers (Actionbox)
On Error GoTo err_Create_Actionbox

'=== Markierung der 1. Zeile
  Cells(1, 1).Select

'=== Erstellung der Commandbar
  lv_subrc = modSupplier8D.Create_Actionbox
  If lv_subrc = False Then GoTo err_Create_Actionbox
  Exit Sub

'=== Errorhandler-Definition: Fehler bei der Erstellung der Aktionbox
err_Create_Actionbox:
  MsgBox Get_Text(modWorkbook.gc_spras, "T14"), vbOKOnly Or vbExclamation, Get_Text(modWorkbook.gc_spras, "T01")
End Sub

Public Function create_save_copy(ByVal pv_name As String)
'=== Lokale Datendeklaration
Dim lv_save_sheet_name As String

'=== Generierung des Sicherungsnamens
  lv_save_sheet_name = pv_name & "__" & "COPY_SAVE"
  
'=== Sicherungskopie erzeugen
  Worksheets(pv_name).copy After:=Sheets(Worksheets.Count)
  Worksheets(Worksheets.Count).Name = lv_save_sheet_name
  Worksheets(pv_name).Select

End Function

Public Function delete_save_copy(ByVal pv_name As String)
'=== Lokale Datendeklaration
Dim lv_save_sheet_name As String

'=== Generierung des Sicherungsnamens
  lv_save_sheet_name = pv_name & "__" & "COPY_SAVE"
  
'=== l|fffd|schen der Sicherungskopie
  delete_worksheet lv_save_sheet_name

End Function

Private Function delete_worksheet(ByVal pv_name As String)
'=== l|fffd|schen eines Worksheets
  Worksheets(pv_name).Delete
End Function

Public Function get_save_copy(ByVal pv_name As String)
'=== Lokale Datendeklaration
Dim lv_save_sheet_name As String

'=== Generierung des Sicherungsnamens
  lv_save_sheet_name = pv_name & "__" & "COPY_SAVE"

'=== l|fffd|schen des Original
  delete_worksheet pv_name

'=== Sicherung an den Anfang stellen und umbenennen
  Sheets(lv_save_sheet_name).Name = pv_name
  Sheets(pv_name).Move Before:=Sheets(1)
End Function

Public Function protect_all_sheets()
'=== Lokale Datendeklaration
Dim li_worksheet As Worksheet

  For Each li_worksheet In ActiveWorkbook.Sheets
'=== Sperren des |fffd|bergebenen Worksheets
    protect_sheet li_worksheet
  Next li_worksheet
End Function

Public Function protect_sheet(ByRef pi_sheet As Worksheet)
'=== Sperren des |fffd|bergebenen Worksheets
  pi_sheet.Protect DrawingObjects:=True, Contents:=True, Scenarios:=True
End Function

Public Function unprotect_all_sheets()
'=== Lokale Datendeklaration
Dim li_worksheet As Worksheet

  For Each li_worksheet In ActiveWorkbook.Sheets
'=== Sperren des |fffd|bergebenen Worksheets
    unprotect_sheet li_worksheet
  Next li_worksheet
End Function

Public Function unprotect_sheet(ByRef pi_sheet As Worksheet)
'=== Entsperren des |fffd|bergebenen Worksheets
  pi_sheet.Unprotect
End Function

Public Function Set_Names_InVisible()
'=== Lokale Datendeklaration
Dim li_application_names As New clsNames

 '=== |fffd|bernahme der Apllikationsnamen
 Set li_application_names.gi_excel_names = Application.Names
 li_application_names.Set_Names_Visibility False

End Function


INQUEST-PP=macro
