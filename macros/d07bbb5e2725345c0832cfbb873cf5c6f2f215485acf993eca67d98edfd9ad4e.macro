Attribute VB_Name = "ACC"
Option Explicit

Function GetCurDBProperty(prop As String) As String
On Error Resume Next
  GetCurDBProperty = ""
  GetCurDBProperty = m_App.CurrentDb.Properties(prop)
End Function

Function GetValueFromField(ByRef rs As Object, fieldName As String, defvalue) As Variant
  On Error GoTo nogo
    
  GetValueFromField = defvalue
  If Not IsNull(rs.Fields(fieldName).value) Then
    GetValueFromField = rs.Fields(fieldName).value
  End If
  
nogo:
  
End Function


Sub XLACCStoreValsToDB(ByVal analyseWarErfolgreich As Boolean)
  
On Error GoTo nogo
  
  If theidvDateiID <= 0 Then Exit Sub
  
  AddStatus FMT0("CHECK_53")
  
  Dim rs As Object
  Dim rsecc As Object
'  Dim rslinks As Object
  Dim riskrs As Object
  Dim rsParam As Object

  Set riskrs = OpenRS("SELECT * FROM ACCDateienRisiko where idvDateiID = -1", G_Conn, MYadOpenDynamic, MYadLockOptimistic)
  Set rs = OpenRS("SELECT * FROM ACCAnalyse where idvDateiID = -1", G_Conn, MYadOpenDynamic, MYadLockOptimistic)
  Set rsecc = OpenRS("SELECT * FROM idvDateien WHERE idvDateiID = " & theidvDateiID, G_Conn, MYadOpenDynamic, MYadLockOptimistic)
  Set rsParam = OpenRS("SELECT * FROM gParameter", G_Conn, MYadOpenDynamic, MYadLockReadOnly)
'  Set rslinks = GetRS("SELECT * FROM ECCVerknuepfungen")
  
'  If riskrs Is Nothing Or rs Is Nothing Or rsecc Is Nothing Then
  If riskrs Is Nothing Or rs Is Nothing Or rsecc Is Nothing Or rsParam Is Nothing Then
    If Not riskrs Is Nothing Then
      riskrs.Close
      Set riskrs = Nothing
    End If
    If Not rs Is Nothing Then
      rs.Close
      Set rs = Nothing
    End If
    If Not rsecc Is Nothing Then
      rsecc.Close
      Set rsecc = Nothing
    End If
    If Not rsParam Is Nothing Then
      rsParam.Close
      Set rsParam = Nothing
    End If
'    If Not rslinks Is Nothing Then
'      rslinks.Close
'      Set rslinks = Nothing
'    End If
    
    Exit Sub
  End If
  
  rs.AddNew
  rs.Fields("idvDateiID").value = theidvDateiID
  Dim nowdate As Date
  If theTrackerFreigabe Then
    nowdate = theTrackerFreigabeDatum
  Else
    nowdate = Now
  End If
  rs.Fields("Datum").value = nowdate
  rs.Fields("Dateigroesse").value = MyFileLen(theFilename)
  
  rs.Fields("StatusID").value = XLScriptGetSimpleVar("STATUSID").m_Value
  rsecc.Fields("ScanstatusID").value = XLScriptGetSimpleVar("STATUSID").m_Value
  
  If analyseWarErfolgreich Then
    If Not XLScriptGetSimpleVar("CREATIONDATE") Is Nothing Then
      Dim d As Date
      d = IIf(IsDate(XLScriptGetSimpleVar("CREATIONDATE").m_Value) = True, XLScriptGetSimpleVar("CREATIONDATE").m_Value, DateSerial(1900, 1, 1))
      If d < #1/1/1900# Then d = #1/1/1900#
      rs.Fields("Erstellungsdatum").value = d
    Else
      rs.Fields("Erstellungsdatum").value = DateSerial(1900, 1, 1)
    End If
    
    If Not XLScriptGetSimpleVar("AUTHOR") Is Nothing Then
      rs.Fields("Ersteller").value = Left(XLScriptGetSimpleVar("AUTHOR").m_Value, 24)
    Else
      rs.Fields("Ersteller").value = ""
    End If
  
    On Error Resume Next
    
    Dim i As Long
    
  '  If Not XLScriptGetArray("EXTERNALFILES") Is Nothing Then
  '    If XLScriptGetArray("EXTERNALFILES").items.count > 0 Then
  '      For i = 1 To XLScriptGetArray("EXTERNALFILES").items.count
  '        rslinks.AddNew
          
  '        rslinks.Fields("idvDateiID").Value = theIdvDateiID
  '        rslinks.Fields("Datum").Value = nowdate
  '        rslinks.Fields("Dateiname").Value = XLScriptGetArray("EXTERNALFILES").items(i).m_SortName
  '        rslinks.Update
  '      Next i
  '    End If
  '  End If
  '  rslinks.Close
  '  Set rslinks = Nothing
    
    i = 1
    Dim item
    For Each item In m_AllVars
      Select Case TypeName(item)
        Case "XLScriptArray"
          Debug.Print TypeName(item), item.m_SortName
        Case "XLScriptArray2D"
          Debug.Print TypeName(item), item.m_SortName
  
          If item.m_SortName = "RiskItems" Then
            Dim litem
            For Each litem In item.items
              riskrs.AddNew
              riskrs.Fields("idvDateiID").value = theidvDateiID
              riskrs.Fields("Datum").value = nowdate
              riskrs.Fields("Name").value = Left(litem(1), 20)
              riskrs.Fields("Wert").value = litem(2)
              riskrs.Fields("Farbe").value = litem(3)
              riskrs.Update
            Next litem
          End If
        Case "XLScriptSimpleVar"
  '        Debug.Print TypeName(item), item.m_Txt, item.m_Value
   
          Debug.Print "SimpleVar: " & item.m_Txt & " = " & item.m_Value
          If item.m_Txt = "ALLOWBREAKINTOCODE" Then
            Debug.Print "gaga"
          End If
          If DBFieldItemExists(rs, item.m_Txt) Then
            'If UCase(item.m_Value) = "WAHR" Or UCase(item.m_Value) = "TRUE" Then
            If IsTrue(item.m_Value) Then
              rs.Fields(item.m_Txt).value = 1
            'ElseIf UCase(item.m_Value) = "FALSCH" Or UCase(item.m_Value) = "FALSE" Then
            ElseIf IsFalse(item.m_Value) Then
              rs.Fields(item.m_Txt).value = 0
            ElseIf rs.Fields(item.m_Txt).Type = 131 Then
              rs.Fields(item.m_Txt).value = IIf(item.m_Value = "", 0, item.m_Value)
            Else
              rs.Fields(item.m_Txt).value = item.m_Value
            End If
          End If
        Case "XLScriptVar"
          Debug.Print TypeName(item), item.m_SortName
      End Select
      i = i + 1
    Next item
  End If
  
  rs.Update
  rs.Close
  Set rs = Nothing
  
  riskrs.Close
  Set riskrs = Nothing
  
  rsecc.Fields("LetzterScan").value = nowdate
  
  If analyseWarErfolgreich Then
    rsecc.Fields("CheckerVersion").value = MyACCVersion
    rsecc.Fields("ScanRisiko").value = CDbl(XLScriptGetSimpleVar("TotalRisk").m_Value)
    rsecc.Fields("ECCFormelnGesamt").value = XLScriptGetSimpleVar("FORMULAAMOUNT").m_Value
    rsecc.Fields("ECCFormelnIndividuell").value = XLScriptGetSimpleVar("FORMULAINDIVAMOUNT").m_Value
    rsecc.Fields("Checksumme").value = Mid(XLScriptGetSimpleVar("CHECKSUM").m_Value, 2)
    
    If Not XLScriptGetSimpleVar("AUTHOR") Is Nothing Then
      rsecc.Fields("Ersteller").value = Left(XLScriptGetSimpleVar("AUTHOR").m_Value, 24)
    Else
      rsecc.Fields("Ersteller").value = ""
    End If
    If Not XLScriptGetSimpleVar("CREATIONDATE") Is Nothing Then
      d = IIf(IsDate(XLScriptGetSimpleVar("CREATIONDATE").m_Value) = True, XLScriptGetSimpleVar("CREATIONDATE").m_Value, DateSerial(1900, 1, 1))
      If d < #1/1/1900# Then d = #1/1/1900#
      rsecc.Fields("Erstellungsdatum").value = d
    Else
      rsecc.Fields("Erstellungsdatum").value = DateSerial(1900, 1, 1)
    End If
    
    If FileExists(theFilename) Then
      rsecc.Fields("Dateidatum").value = MyFileDateTime(theFilename)
    End If
  
    If theTrackerFreigabe Then
      Dim ok As Boolean
      ok = True
      If (rsecc.Fields("Risikowert").value >= GetValueFromField(rsParam, "DateienVersionierenAbRisk", 1) And GetValueFromField(rsParam, "DateienVersionierenAbRisk", 1) <> -1) Or _
        GetValueFromField(rsParam, "EincheckenBeiPrgfreigabe", False) <> False Then
          ok = CheckInFile(rsecc, theTrackerFreigabeDatum)
      End If
      
      If ok Then
        ' Neu, der Checker setzt auch die Freigaben!
        G_Conn.Execute "DELETE FROM idvDateienFreigaben WHERE idvDateiID=" & theidvDateiID & " AND Version = " & rsecc.Fields("Version")
  '      G_Conn.Execute "Insert into idvDateienFreigaben (idvDateiID,Version,Datum,FreigebenderUser,Kommentar,Status,FreigabeChecksumme,CCEmpfaenger) Values( " & theidvDateiID & _
  '        ", '" & rsecc.Fields("Version") & "', '" & theTrackerFreigabeDatum & "', '" & theFreigabeuser & "', '" & theFreigabekommentar & "', '0', '" & XLScriptGetSimpleVar("CHECKSUM").m_Value & "', '" & theFreigabeCCListe & "')"
        
  '      G_Conn.Execute "Insert into idvDateienFreigaben (idvDateiID,Version,Datum,FreigebenderUser,Kommentar,Status,FreigabeChecksumme,CCEmpfaenger) Values( '" & theidvDateiID & _
  '        "', '" & rsecc.Fields("Version") & "', '" & Format(theTrackerFreigabeDatum, "YYYY-MM-DD hh:mm:ss") & "', '" & theFreigabeuser & "', '" & theFreigabekommentar & "', '0', '" & Mid(XLScriptGetSimpleVar("CHECKSUM").m_Value, 2) & "', '" & theFreigabeCCListe & "')"
        
        Dim trs As Object
        Set trs = OpenRS("SELECT * FROM idvDateienFreigaben WHERE idvDateiID=" & theidvDateiID & " AND Version = " & rsecc.Fields("Version").value, G_Conn, MYadOpenDynamic, MYadLockOptimistic)
        If trs Is Nothing Then
          ok = False
        Else
          If trs.EOF Then
            trs.AddNew
            trs.Fields("idvDateiID").value = theidvDateiID
            trs.Fields("Version").value = rsecc.Fields("Version").value
          End If
          trs.Fields("Datum").value = theTrackerFreigabeDatum
          trs.Fields("FreigebenderUser").value = Left(theFreigabeuser, 50)
          trs.Fields("Kommentar").value = theFreigabekommentar
          trs.Fields("Status").value = 0
          trs.Fields("FreigabeChecksumme").value = Mid(XLScriptGetSimpleVar("CHECKSUM").m_Value, 2)
          trs.Fields("CCEmpfaenger").value = ""
          trs.Update
          trs.Close
        End If
        Set trs = Nothing
        
        If ok Then
            rsecc.Fields("FreigabeChecksumme").value = Mid(XLScriptGetSimpleVar("CHECKSUM").m_Value, 2)
            rsecc.Fields("FreigabeStatus").value = 2
            rsecc.Fields("FreigabeidvDateiID").value = theidvDateiID
            rsecc.Fields("FreigabeVersion").value = rsecc.Fields("Version")
            
            SaveSetting _
               appname:="Stromwerken", _
               Section:=ProgNameShort, _
               Key:="FreigabeErteilt", _
               setting:=1
            'AddStatus "Freigabe erfolgreich durchgef|fffd|hrt!"
            AddStatus FMT0("ACC_1")
            StoreUserCommunicateValue "FG", "1"
        Else
            'AddStatus "Freigabe nicht erfolgreich!"
            AddStatus FMT0("ACC_2")
            StoreUserCommunicateValue "FG", "0"
        End If
      Else
        'AddStatus "Freigabe nicht erfolgreich!"
        AddStatus FMT0("ACC_2")
        StoreUserCommunicateValue "FG", "0"
      End If
    End If
  End If
  
  rsecc.Update
  
nogo:
On Error Resume Next

  CloseRs rsecc
  CloseRs rsParam
  
End Sub

Sub CloseRs(ByRef rs)
On Error Resume Next
  If rs.EditMode <> 0 Then
    rs.CancelUpdate
  End If
  rs.Close
  Set rs = Nothing
End Sub



Attribute VB_Name = "AboutDlg"
Attribute VB_Base = "0{2C47B51F-2504-46CF-8063-13F33C6ED58C}{BD0C14B5-6238-49C9-BE1C-A3CF02AC83A7}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Private Sub CommandButton1_Click()
    AboutDlg.Hide
End Sub

Private Sub Label3_Click()
  On Error Resume Next
  'Call Shell("explorer.exe http://www.stromwerken.de", 1)
  Call Shell("explorer.exe " & FMT0("INETLINK_1"), 1)
End Sub

Private Sub UserForm_Initialize()
  gTranslation.TranslateForm Me
End Sub
Attribute VB_Name = "BitteWarten"
Attribute VB_Base = "0{61565574-9234-4456-BDD7-04D6266F05EB}{D664CB1A-EC77-43EF-94AF-D54F40FABBBD}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit


Private Sub UserForm_Activate()
  'Me.Hinweistext = "Suche nach Access 97..."
  Me.Hinweistext = FMT0("BW_3")
  DoEvents
  MainMenu.V8.Enabled = CheckAccessVersion(8)
  'Me.Hinweistext = "Suche nach Access 2000..."
  Me.Hinweistext = FMT0("BW_4")
  DoEvents
  MainMenu.V9.Enabled = CheckAccessVersion(9)
  'Me.Hinweistext = "Suche nach Access 2002/XP..."
  Me.Hinweistext = FMT0("BW_5")
  DoEvents
  MainMenu.V10.Enabled = CheckAccessVersion(10)
  'Me.Hinweistext = "Suche nach Access 2003..."
  Me.Hinweistext = FMT0("BW_6")
  DoEvents
  MainMenu.V11.Enabled = CheckAccessVersion(11)
  DoEvents
  MainMenu.V12.Enabled = CheckAccessVersion(12)
  DoEvents
  MainMenu.V14.Enabled = CheckAccessVersion(14)
  DoEvents
  MainMenu.V15.Enabled = CheckAccessVersion(15)
  DoEvents
  MainMenu.V16.Enabled = CheckAccessVersion(16)
  DoEvents
  Me.Hide
End Sub

Private Sub UserForm_Initialize()
  gTranslation.TranslateForm Me
End Sub
Attribute VB_Name = "CfgReader"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

Dim m_Lines As Collection
Dim m_Sec As Collection

Private Function GetNextLine(ByRef s As String) As String

    Dim rs As String
    Do
        rs = GetLine(s)
        If Len(Trim(rs)) > 0 Then
            GetNextLine = Trim(rs)
            Exit Function
        End If
        If Len(Trim(s)) <= 0 Then
            GetNextLine = ""
            s = ""
            Exit Function
        End If
    Loop
End Function


Public Sub GetCFGString(ByVal txt As String)
    Set m_Lines = New Collection
    Set m_Sec = New Collection

    If Len(txt) = 0 Then Exit Sub
    Dim s As String
    Do
        s = GetNextLine(txt)
        If Len(s) <= 0 Then Exit Do
        m_Lines.Add (s)
        m_Sec.Add (s)
    Loop
End Sub


Function GetCfgUTF8(fname As String) As Boolean
  On Error GoTo couldntOpenFile
    Dim adoStream As Object
    Set adoStream = CreateObject("ADODB.Stream")
    
    adoStream.Charset = "UTF-8"
    adoStream.Open
    adoStream.LoadFromFile fname
    GetCFGString adoStream.ReadText
    adoStream.Close
    Set adoStream = Nothing
    GetCfgUTF8 = True
    Exit Function

couldntOpenFile:
  GetCfgUTF8 = False

End Function


Function GetCFG(fname As String) As Boolean
  On Error GoTo couldntOpenFile
  
  Dim ff As Long
  ff = FreeFile
  Dim s As String
  
  ' check for UTF8!
  Open fname For Binary Access Read As #ff
  Dim l As Byte
  Get #ff, 1, l
  Close ff
  
  If l = 239 Then
    GetCFG = GetCfgUTF8(fname)
    Exit Function
  End If
  
  Open fname For Input As #ff
  Set m_Lines = New Collection
  Set m_Sec = New Collection
  
  Do While Not EOF(ff)
    Line Input #ff, s
    If Len(Trim(s)) > 0 Then
      m_Lines.Add s
    End If
    m_Sec.Add s
  Loop
  Close #ff
  GetCFG = True
  Exit Function
couldntOpenFile:
  GetCFG = False
End Function

Function GetSection(sec As String) As Boolean
  Set m_Sec = New Collection
  GetSection = GetSectionValues(sec, m_Sec)
End Function

Function GetValue(s As String) As String
  Dim i As Long
  For i = 1 To m_Sec.count
    If Left(m_Sec(i), Len(s) + 1) = s & "=" Then
      GetValue = Trim(Mid(m_Sec(i), Len(s) + 2))
      Exit Function
    ElseIf Left(m_Sec(i), Len(s) + 1) = s & " " Then
        Dim pos As Long
        pos = InStr(m_Sec(i), "=")
        If pos > 0 Then
            GetValue = Trim(Mid(m_Sec(i), pos + 1))
            Exit Function
        End If
    End If
  Next i
  GetValue = ""
End Function

Function GetSectionValues(sec As String, ByRef c As Collection) As Boolean
  Set c = New Collection
  Dim i As Long
  Dim found As Boolean
  found = False
  For i = 1 To m_Lines.count
    If m_Lines(i) = "[" & sec & "]" Then
      i = i + 1
      Do While i <= m_Lines.count
        If Left(m_Lines(i), 1) <> "[" Then
          c.Add m_Lines(i)
          found = True
          i = i + 1
        Else
          Exit Do
        End If
      Loop
    End If
    If i > m_Lines.count Then Exit For
  Next i
  GetSectionValues = found
End Function





Attribute VB_Name = "Check"
Option Explicit

Public UseDefinedDesc As Boolean

Dim EmptyList As Variant
Dim QueryDefFields As Variant
Dim RelationFields As Variant
Dim TableElementProperties As Variant
Dim FormControlNegProperties As Variant
'Dim FormProperties As Variant
Dim FormNegProperties As Variant

Dim ExtrudeModules As Integer
Dim ExtrudeTables As Integer
Dim ExtrudeRelations As Integer
Dim ExtrudeQueries As Integer
Dim ExtrudeFormModules As Integer
Dim ExtrudeForms As Integer
Dim ExtrudeScripts As Integer

Dim LogFilename As String
Dim CurrentObject As String
Dim ErrorFileOpen As Boolean
Dim temppath As String


Dim StartTime
Dim StartDate
Dim ProgStartTime
Dim LastTime

Dim TotalTicks As Double
Dim Ticks As Double
Dim LastTicks As Double

Dim count As Long
Dim Totalamount As Long

Const ModuleTicks = 500
Const FormModuleTicks = 645.1
Const TableIndexesTicks = 28
Const TablePropertiesTicks = 0.28
Const TableFieldTicks = 0.28

' Const FormPropertiesTicks = 13
Const FormNegPropertiesTicks = 70.58
Const FormControlPropertiesTicks = 47.18

Const QueryPropertyTicks = 110
Const QueryFieldTicks = 110
Const QueryParameterTicks = 40
Const ScriptTicks = 2

Const QueryDefFieldsSize = 2
Const RelationFieldsSize = 3
Const TableElementPropertiesSize = 9
Const FormControlNegPropertiesSize = 17
Const FormNegPropertiesSize = 36
' Const FormPropertiesSize = 86

Const RelationMul = 1

Global Const ChecksumMod As Long = &H100000


Dim MyEventCount As Integer


Public m_ResultWorkbookName As String
Dim m_Status As String

Dim m_VarGroups As Collection
Dim m_FN As Collection
Dim m_WS As Worksheet

Dim m_ConnectedDBs As Collection

#If VBA7 Then
Private Declare PtrSafe Function SetKeyboardState _
    Lib "user32" _
    (lppbKeyState As Any) _
    As Long
    
Private Declare PtrSafe Function GetKeyboardState _
    Lib "user32" (pbKeyState As Any) _
    As Long

Private Declare PtrSafe Function GetWindowThreadProcessId _
    Lib "user32" _
    (ByVal hWnd As LongPtr, _
    lpdwProcessId As Long) _
    As Long

Private Declare PtrSafe Function AttachThreadInput _
    Lib "user32" _
    (ByVal idAttach As Long, _
    ByVal idAttachTo As Long, _
    ByVal fAttach As Long) _
    As Long

Private Declare PtrSafe Function SetForegroundWindow _
    Lib "user32" _
    (ByVal hWnd As LongPtr) _
    As Long

Private Declare PtrSafe Function SetFocusAPI _
    Lib "user32" Alias "SetFocus" _
    (ByVal hWnd As LongPtr) _
    As Long
#Else
Private Declare Function SetKeyboardState _
    Lib "user32" _
    (lppbKeyState As Any) _
    As Long
    
Private Declare Function GetKeyboardState _
    Lib "user32" (pbKeyState As Any) _
    As Long

Private Declare Function GetWindowThreadProcessId _
    Lib "user32" _
    (ByVal hWnd As Long, _
    lpdwProcessId As Long) _
    As Long

Private Declare Function AttachThreadInput _
    Lib "user32" _
    (ByVal idAttach As Long, _
    ByVal idAttachTo As Long, _
    ByVal fAttach As Long) _
    As Long

Private Declare Function SetForegroundWindow _
    Lib "user32" _
    (ByVal hWnd As Long) _
    As Long

Private Declare Function SetFocusAPI _
    Lib "user32" Alias "SetFocus" _
    (ByVal hWnd As Long) _
    As Long
#End If

Private Const VK_SHIFT = &H10
Private Const VK_LSHIFT = &HA0
Private Const VK_RSHIFT = &HA1


Function AddChecksumCollectionRelation(ff As Integer, ByRef checksum As Long, ByRef col As Variant, ByRef xlsarr As XLScriptArray2D, txtExtension As String) As Long
  On Error Resume Next
  Dim tChecksum As Long
  tChecksum = 0
  Dim item
  For Each item In col
'    Debug.Print item.name, CStr(item)
     tChecksum = (tChecksum + AddChecksumRelation(ff, checksum, item, xlsarr, txtExtension)) Mod ChecksumMod
  Next item
  AddChecksumCollectionRelation = tChecksum
  Exit Function
nogo:
  Resume Next
End Function


Function AddChecksumRelation(ff As Integer, ByRef checksum As Long, ByRef ctrl As Variant, Optional ByRef xlsarr As XLScriptArray2D = Nothing, Optional txtExtension As String = "", Optional alternativerName As String = "") As Long
  On Error Resume Next
  
  Dim item
  Dim tChecksum As Long
  tChecksum = 0
  
  If alternativerName = "" Then
    alternativerName = ctrl.name
  End If
  
  For Each item In ctrl.Properties
'    Debug.Print item.name, CStr(item)
    tChecksum = (tChecksum + AddChecksum(checksum, CStr(item), txtExtension & alternativerName & "." & item.name, ff)) Mod ChecksumMod
  Next item
  
  If Not xlsarr Is Nothing Then
    xlsarr.AddLine alternativerName
    xlsarr.AddVar "NAME", alternativerName
    xlsarr.AddVar "FULLNAME", txtExtension & alternativerName
    xlsarr.AddVar "CHECKSUM", CStr("h" & Hex(tChecksum))
  End If
  
  AddChecksumRelation = tChecksum
  
  Exit Function
nogo:
  Resume Next
End Function


Function AddChecksumCollection(ff As Integer, ByRef checksum As Long, ByRef col As Variant, ByRef xlsarr As XLScriptArray2D, txtExtension As String) As Long
  On Error Resume Next
  Dim item
  Dim tChecksum As Long
  tChecksum = 0

'Debug.Print "AddChecksumCollection 0 - " & Time
  For Each item In col
    tChecksum = (tChecksum + AddChecksumControl(ff, checksum, item, xlsarr, txtExtension)) Mod ChecksumMod
  Next item
  
  AddChecksumCollection = tChecksum
  
'Debug.Print "AddChecksumCollection 1 - " & Time
  Exit Function
nogo:
  Resume Next
End Function


Function AddChecksumControl(ff As Integer, ByRef checksum As Long, ByRef ctrl As Variant, Optional ByRef xlsarr As XLScriptArray2D = Nothing, Optional txtExtension As String = "", Optional alternativerName As String = "") As Long
  On Error Resume Next
  
  Dim item
  Dim tChecksum As Long
  tChecksum = 0
  
  If alternativerName = "" Then
    alternativerName = ctrl.name
  End If
  
  
'  Dim ff
'  ff = FreeFile
'  Open "D:\Temp\" & ctrl.name & ".prop.txt" For Output As #ff
  
' Debug.Print "AddChecksumControl 0 - " & Time
' Dim t
' t = Time
  For Each item In ctrl.Properties
  
'    Print #ff, item.name
'    Print #ff, "     " & CStr(item)
  
    Select Case item.name
      Case "LastUpdated"
      Case "Hwnd"
      Case "LogicalPageWidth"
      Case "PrtMip"
      Case "PrtDevMode"
      Case "PrtDevNames"
      Case "PrtDevModeW"
      Case "Properties"
      Case "NameMap"
      Case "GUID"
      Case "Attributes"
      Case "RecordCount"
      Case "ListWidth"
      Case "ColumnWidths"
      Case "ColumnWidth"
      Case "WindowWidth"
      Case "WindowHeight"
      Case "InsideWidth"
      Case "InsideHeight"
      Case "WindowTop"
      Case "WindowLeft"
      Case "Width"
      Case "Height"
      Case "Top"
      Case "Left"

      Case "ConflictTable"
      Case "ReplicaFilter"
      Case "PartialReplica"

      Case Else
'        Debug.Print item.name, CStr(item)
' Debug.Print "AddChecksumControl 0.1 - " & Time & " (" & item.name & ")"
        tChecksum = (tChecksum + AddChecksum(checksum, CStr(item), txtExtension & alternativerName & "." & item.name, ff)) Mod ChecksumMod
' Debug.Print "AddChecksumControl 0.2 - " & Time
    End Select
  Next item
'   If t - Time > 0 Then
'     Debug.Print "AddChecksumControl (" & ctrl.name & ") 1 - " & Time & " - " & t - Time
'   End If
  
  

   If Not xlsarr Is Nothing Then
     xlsarr.AddLine alternativerName
     xlsarr.AddVar "NAME", alternativerName
     xlsarr.AddVar "FULLNAME", txtExtension & alternativerName
     xlsarr.AddVar "CHECKSUM", CStr("h" & Hex(tChecksum))
   End If
  
    AddChecksumControl = tChecksum
  
  Exit Function
nogo:
  Resume Next
End Function

Function AddChecksumAndVar(ff As Integer, n As String, ByRef checksum As Long, txt As String, ByRef xlsarr As XLScriptArray2D, txtExtension As String) As Long
  On Error Resume Next
  
  Dim item
  Dim tChecksum As Long
  tChecksum = AddChecksum(checksum, txt, txtExtension & "." & n, ff)

  xlsarr.AddLine n
  xlsarr.AddVar "NAME", n
  xlsarr.AddVar "FULLNAME", txtExtension & n
  xlsarr.AddVar "CHECKSUM", CStr("h" & Hex(tChecksum))
  
  AddChecksumAndVar = tChecksum
  
  Exit Function
nogo:
  Resume Next
End Function


Function AddChecksum(ByRef checksum As Long, txt As String, vName As String, ff As Integer) As Long
  Dim tChecksum As Long
  Dim counter As Long
  Dim l As Long
  
  l = Len(vName)
  If l > 0 Then
    For counter = 1 To l
      tChecksum = (tChecksum + CLng(Asc(Mid(vName, counter, 1))) * counter) Mod ChecksumMod
    Next counter
  End If
  
  l = Len(txt)
  If l > 0 Then
    For counter = 1 To l
      tChecksum = (tChecksum + CLng(Asc(Mid(txt, counter, 1))) * counter) Mod ChecksumMod
    Next counter
  End If

  checksum = (checksum + tChecksum) Mod ChecksumMod
  AddChecksum = tChecksum

  If ff <> -1 Then Print #ff, vName & "," & CStr("h" & Hex(tChecksum)) & "," & "|\_" & txt & "_/|"

End Function

Function AddToChecksum(hexstr As String, l As Long) As String

  Dim tChecksum As String
  tChecksum = CLng("&H" & hexstr)
  AddToChecksum = Hex((tChecksum + l) Mod ChecksumMod)

End Function



Public Sub Analyze(Filename As String, orifilename As String)
  
  ' XXX
  On Error GoTo handleError
  
  Dim checksum As Long
  checksum = 0
  
  Dim hadError As Boolean
  hadError = False
  
  StartTime = Time
  StartDate = Now
  StatusFormUpdate

  Set m_FN = New Collection
  
  If Not ReadGroups Then Exit Sub
  
  'LogPrintECCSCanLog theFilename & " (ID: " & theidvDateiID & ") - Starte Analyse", True
  LogPrintECCSCanLog 0, 0, FMT2("CHECK_1", theFilename, theidvDateiID), True
  'AddStatus "Analysiere: " & orifilename
  AddStatus FMT1("CHECK_2", orifilename)
  'AddStatus "Initialisierung"
  AddStatus FMT0("CHECK_3")
    
  If StartedByTracker = False And G_Command <> "" Then
    m_ResultWorkbookName = GenerateSheet("Log")
    
    If CheckAccessVersion(16) Then
      CreateAccessApp 16
      theAccessScannerVersion = 16
    ElseIf CheckAccessVersion(15) Then
      CreateAccessApp 15
      theAccessScannerVersion = 15
    ElseIf CheckAccessVersion(14) Then
      CreateAccessApp 14
      theAccessScannerVersion = 14
    ElseIf CheckAccessVersion(12) Then
      CreateAccessApp 12
      theAccessScannerVersion = 12
    ElseIf CheckAccessVersion(11) Then
      CreateAccessApp 11
      theAccessScannerVersion = 11
    ElseIf CheckAccessVersion(10) Then
      CreateAccessApp 10
      theAccessScannerVersion = 10
    ElseIf CheckAccessVersion(9) Then
      CreateAccessApp 9
      theAccessScannerVersion = 9
    ElseIf CheckAccessVersion(8) Then
      CreateAccessApp 8
      theAccessScannerVersion = 8
    Else
      Exit Sub
    End If
  
  ElseIf StartedByTracker = False Then
    m_ResultWorkbookName = GenerateSheet("Log")
  
    If MainMenu.V8.value = True Then
      CreateAccessApp 8
      theAccessScannerVersion = 8
    ElseIf MainMenu.V9.value = True Then
      CreateAccessApp 9
      theAccessScannerVersion = 9
    ElseIf MainMenu.V10.value = True Then
      CreateAccessApp 10
      theAccessScannerVersion = 10
    ElseIf MainMenu.V11.value = True Then
      CreateAccessApp 11
      theAccessScannerVersion = 11
    ElseIf MainMenu.V12.value = True Then
      CreateAccessApp 12
      theAccessScannerVersion = 12
    ElseIf MainMenu.V14.value = True Then
      CreateAccessApp 14
      theAccessScannerVersion = 14
    ElseIf MainMenu.V15.value = True Then
      CreateAccessApp 15
      theAccessScannerVersion = 15
    ElseIf MainMenu.V16.value = True Then
      CreateAccessApp 16
      theAccessScannerVersion = 16
    End If
  Else
  
    If CheckAccessVersion(16) Then
      CreateAccessApp 16
      theAccessScannerVersion = 16
    ElseIf CheckAccessVersion(15) Then
      CreateAccessApp 15
      theAccessScannerVersion = 15
    ElseIf CheckAccessVersion(14) Then
      CreateAccessApp 14
      theAccessScannerVersion = 14
    ElseIf CheckAccessVersion(12) Then
      CreateAccessApp 12
      theAccessScannerVersion = 12
    ElseIf CheckAccessVersion(11) Then
      CreateAccessApp 11
      theAccessScannerVersion = 11
    ElseIf CheckAccessVersion(10) Then
      CreateAccessApp 10
      theAccessScannerVersion = 10
    ElseIf CheckAccessVersion(9) Then
      CreateAccessApp 9
      theAccessScannerVersion = 9
    ElseIf CheckAccessVersion(8) Then
      CreateAccessApp 8
      theAccessScannerVersion = 8
    Else
      Exit Sub
    End If
  End If
  
'  Dim m_App As Object
'  Set m_App = CreateObject("Access.Application, 10")
  
  SetLiveStatus
  DoEvents
  
'  Dim adminPW As String
'  adminPW = InputBox("Bitte geben Sie, falls notwendig, das Administratorpasswort an:")


  ' Scriptengine initialisieren
  Dim tWB As Excel.Workbook
  
  If StartedByTracker Then
    Set tWB = Nothing
  Else
    If m_ResultWorkbookName = "" Then
      Set tWB = Nothing
    Else
      Set tWB = Workbooks(m_ResultWorkbookName)
    End If
  End If
  
  If StartedByTracker Then
    StoreComm True
  End If

  SetLiveStatus
  
  XLScriptInitGlobals Application, tWB

  
  'AddStatus "|fffd|ffne DB"
  AddStatus FMT0("CHECK_4")
  If Not OpenAnalyzeDB(Filename, orifilename) Then
    m_App.Quit
    Set m_App = Nothing
    hadError = True
    'LogPrintECCSCanLog theFilename & " (ID: " & theidvDateiID & ") - Ergebnis: Datei konnte nicht ge|fffd|ffnet werden", True
    LogPrintECCSCanLog theidvDateiID, 5, FMT2("CHECK_5", theFilename, theidvDateiID), True
    GoTo closeStuff
  End If
  SetLiveStatus
  
  'AddStatus "Pr|fffd|fe Bypass"
  AddStatus FMT0("CHECK_6")
  If AccAppHasProperty(m_App, "AllowBypassKey") Then
    If m_App.CurrentDb.Properties("AllowBypassKey") = False Then
      m_App.CurrentDb.Properties("AllowBypassKey") = True
      m_App.CloseCurrentDatabase
      If Not OpenAnalyzeDB(Filename, orifilename) Then
        m_App.Quit
        Set m_App = Nothing
        hadError = True
        'LogPrintECCSCanLog theFilename & " (ID: " & theidvDateiID & ") - Ergebnis: Datei konnte nicht ge|fffd|ffnet werden", True
        LogPrintECCSCanLog theidvDateiID, 5, FMT2("CHECK_5", theFilename, theidvDateiID), True
        GoTo closeStuff
      End If
    End If
  End If
  SetLiveStatus
  
  ' XXX
  m_App.Visible = True
  m_App.DoCmd.RunCommand 11 ' acCmdAppMinimize
  
  Set m_Workspace = m_App.DBEngine.Workspaces(0)
  
  Set m_ConnectedDBs = New Collection
    
  'AddStatus "Start"
  AddStatus FMT0("START_1")
  DoEvents
  
  ' -------------------------------------------
  ' Z|fffd|hler
  ' -------------------------------------------
  ' Anzahl Tabellen
  Dim totalTableAmount As Long
  totalTableAmount = 0
  
  Dim totalQueryAmount As Long
  totalQueryAmount = 0
  
  Dim totalFormAmount As Long
  totalFormAmount = 0
  
  Dim totalReportAmount As Long
  totalReportAmount = 0
  
  Dim totalScriptAmount As Long
  totalScriptAmount = 0
  
  Dim totalModuleAmount As Long
  totalModuleAmount = 0
  
  Dim totalRestModuleAmount As Long
  totalRestModuleAmount = 0
  
  Dim totalClassModuleAmount As Long
  totalClassModuleAmount = 0
  
  Dim totalFormModuleAmount As Long
  totalFormModuleAmount = 0
  
  Dim totalReportModuleAmount As Long
  totalReportModuleAmount = 0
  
  Dim totalTableFieldAmount As Long
  totalTableFieldAmount = 0
  
  Dim totalReferencedTablesAmount As Long
  totalReferencedTablesAmount = 0
  
  Dim totalDatasetAmount As Long
  totalDatasetAmount = 0
  
  Dim totalIndicesAmount As Long
  totalIndicesAmount = 0
  
  Dim totalDatafieldAmount As Long
  totalDatafieldAmount = 0
  
  Dim totalControlsOnFormsAmount As Long
  totalControlsOnFormsAmount = 0
  
  Dim totalEditControlsOnFormsAmount As Long
  totalEditControlsOnFormsAmount = 0
  
  Dim totalProgramEditControlsOnFormsAmount As Long
  totalProgramEditControlsOnFormsAmount = 0
  
  Dim totalSubFormAmount As Long
  totalSubFormAmount = 0
  
  Dim totalVBALineAmount As Long
  totalVBALineAmount = 0
  
  Dim totalVBACommentsAmount As Long
  totalVBACommentsAmount = 0
  
  Dim totalTabelCommentAmount As Long
  totalTabelCommentAmount = 0
  
  Dim totalSQLCommentAmount As Long
  totalSQLCommentAmount = 0
  
  Dim totalFormCommentAmount As Long
  totalFormCommentAmount = 0
  
  Dim totalReportCommentAmount As Long
  totalReportCommentAmount = 0
  
  Dim totalScriptCommentAmount As Long
  totalScriptCommentAmount = 0
  
  Dim totalVBAModuleCommentAmount As Long
  totalVBAModuleCommentAmount = 0
  
  Dim totalScriptLineAmount As Long
  totalScriptLineAmount = 0
  
  Dim totalScriptCommentLinesAmount As Long
  totalScriptCommentLinesAmount = 0
  
  Dim totalReferencedDBAmount As Long
  totalReferencedDBAmount = 0
  
  Dim totalRelationFieldAmount As Long
  totalRelationFieldAmount = 0
  Dim totalActiveXAmount As Long
  totalActiveXAmount = 0
  
  Dim xlsarr As XLScriptArray
  Dim xlsv As XLScriptVar
  
  
  Dim xlsarrChecksum As XLScriptArray2D ' Tabellen, Formulare
  Dim xlsarrChecksumObjekt As XLScriptArray2D ' Objekte
  Dim xlsarrChecksumFld As XLScriptArray2D ' Felder
  
  ' -------------------------------------------
  ' -------------------------------------------
  
  
  ' Alle Namen besorgen
'  Set m_DB = OpenDatabase(m_AccFilename, , , "Access; pwd=" & adminPW)
  Set m_DB = m_App.DBEngine.Workspaces(0).Databases(0)
  
  ' Tabellen
  ' Abfragen
  ' VBA
  ' Formulare
  ' Reports
  ' Gruppenberechtigungen
  ' Personenberechtigungen
  ' Scripte
  ' Ergebnistabellen * 2
  
  TotalTicks = 10
  
' DATABASE=database;
  Dim element
  Dim subelement
  Dim sub2element
  
  'AddStatus "Tiefenanalyse"
  AddStatus FMT0("CHECK_7")


'  Dim titem
'  For Each titem In m_DB.Containers!Tables.Documents
'    titem.UserName = "norman"
'    Debug.Print titem.name & " - " & titem.UserName & " - " & titem.Permissions
'    titem.UserName = "admin"
'    Debug.Print titem.name & " - " & titem.UserName & " - " & titem.Permissions
'  Next titem



  SetLiveStatus
  
  
  XLScriptAddSimpleVar "SAVEDATE", Format(MyFileDateTime(theFilename), "Short Date") & " - " & Format(MyFileDateTime(theFilename), "Short Time")
  XLScriptAddSimpleVar "FILESIZEKB", CLng(MyFileLen(theFilename) / 1024)
  XLScriptAddSimpleVar "FILESIZE", MyFileLen(theFilename)
  
  
  SetLiveStatus
  Dim ff As Integer
  ff = -1
  Dim tnow
  tnow = Now
  
  If G_LogPrintChecksum Then
    ff = FreeFile
    Open G_cfgLogpfad & "\" & GetFileNameAndExtension(orifilename) & "." & Format(year(tnow), "0000") & "-" & Format(month(tnow), "00") & "-" & Format(day(tnow), "00") & " " & Format(Hour(tnow), "00") & "_" & Format(Minute(tnow), "00") & "_" & Format(Second(tnow), "00") & ".chk.txt" For Output As #ff
  End If
  
  Set xlsarrChecksum = XLScriptAddArray2D("CHECKSUMARR")
  
  Set xlsarr = XLScriptAddArray("CONNECTEDDBS")
    
  ' ANALYSE
  
  LastTime = Time
  Ticks = 0
  LastTicks = 0
  
  ' -------------------------------------------
  
  ' -------------------------------------------
  ' Die Tabellen
  ' -------------------------------------------
  
  Dim i As Long
  Dim tableY As Long
  tableY = 2
'  GenerateSheet "Tabellen", m_ResultWorkbook
  
  StatusFormUpdate
  GetDefsAndResultsheets
  StatusFormUpdate
  
  Dim tChecksum As Long
  Dim item
  Dim x As Long
  Dim varGroupIdx As Long
  varGroupIdx = GetVarGroup("Tabellen")
  
  'AddStatus "Tabellen..."
  AddStatus FMT0("CHECK_8")
  If varGroupIdx > 0 Then
    '----------------------------------------------------------
    'SetStatus "Tabellen"
    SetStatus FMT0("CHECK_9")
    '----------------------------------------------------------
    Set xlsarrChecksumObjekt = xlsarrChecksum.AddXLScriptArray2D("Tabellen")
    
    x = 1
    For Each item In m_VarGroups(varGroupIdx).m_Vars
      SetLiveStatus
'      Workbooks(m_ResultWorkbook).Sheets("Tabellen").Cells(1, x) = item.m_Name
      If item.m_Type = "d" Then
'        Workbooks(m_ResultWorkbook).Sheets("Tabellen").Columns(x).NumberFormat = "d/m/yy;@"
      End If
      x = x + 1
    Next item
    ' ProgressForm.Status.Refresh
    For i = 0 To m_DB.TableDefs.count - 1
      StatusFormUpdate
      If m_DB.TableDefs(i).Attributes = 0 Then
        'UpdateStatus "Tabelle: " & m_DB.TableDefs(i).name
        UpdateStatus FMT1("CHECK_10", m_DB.TableDefs(i).name)
        AddChecksumControl ff, checksum, m_DB.TableDefs(i), xlsarrChecksumObjekt, "Tabelle."
        Set xlsarrChecksumFld = xlsarrChecksumObjekt.AddXLScriptArray2DToCurrentLine("OBJFIELDS")
'        AddChecksumCollection ff, checksum, m_DB.TableDefs(I).Fields, xlsarrChecksumFld, "Tabelle." & m_DB.TableDefs(I).name & "."
        tChecksum = AddChecksumCollection(ff, checksum, m_DB.TableDefs(i).Fields, Nothing, "Tabelle." & m_DB.TableDefs(i).name & ".")
        xlsarrChecksumObjekt.items(xlsarrChecksumObjekt.items.count)("CHECKSUM").SetValue "CHECKSUM", "h" & AddToChecksum(Mid(xlsarrChecksumObjekt.items(xlsarrChecksumObjekt.items.count)("CHECKSUM").Properties(1), 2), tChecksum)
        
        StatusFormUpdate
        
        totalTableAmount = totalTableAmount + 1
        totalTableFieldAmount = totalTableFieldAmount + m_DB.TableDefs(i).Fields.count
        
        Dim tCount As Long
        tCount = 0
        If m_DB.TableDefs(i).Fields.count > 0 Then
          Dim countRs As Recordset
          Set countRs = m_DB.OpenRecordset( _
            "SELECT Count([" & m_DB.TableDefs(i).Fields(0).name & "]) AS [CNT] FROM [" & _
            m_DB.TableDefs(i).name & "]" _
            )
          tCount = countRs("CNT")
          countRs.Close
          Set countRs = Nothing
        End If
        
        totalDatasetAmount = totalDatasetAmount + tCount
        totalIndicesAmount = totalIndicesAmount + m_DB.TableDefs(i).Indexes.count
        totalDatafieldAmount = totalDatafieldAmount + m_DB.TableDefs(i).Fields.count * tCount
      ElseIf (m_DB.TableDefs(i).Attributes And &H80000003) = 0 Then
'        If m_DB.TableDefs(i).name = "MSysAccounts" Or _
'           m_DB.TableDefs(i).name = "MSysGroups" Then
'          ShowSysTable m_DB.TableDefs(i), m_DB
'        End If
'      Else
        
        'UpdateStatus "Tabelle: " & m_DB.TableDefs(i).name
        UpdateStatus FMT1("CHECK_10", m_DB.TableDefs(i).name)
        AddChecksumControl ff, checksum, m_DB.TableDefs(i), xlsarrChecksumObjekt, "Tabelle."
      
        totalTableAmount = totalTableAmount + 1
        totalTableFieldAmount = totalTableFieldAmount + m_DB.TableDefs(i).Fields.count
        
        ' dbAttachedTable + dbAttachedExclusive + dbAttachedODBC + dbAttachSavePWD
        
        If (m_DB.TableDefs(i).Attributes And (&H40000000 + &H10000 + &H20000000 + &H20000)) <> 0 Then
          totalReferencedTablesAmount = totalReferencedTablesAmount + 1
          ' If Not ConnectExists(m_DB.TableDefs(I).Connect) Then
          '   totalReferencedDBAmount = totalReferencedDBAmount + 1
          ' End If
        End If
      End If
    Next
    Ticks = Ticks + 1 / m_DB.TableDefs.count
    UpdateStatusOLD
  Else
    Ticks = Ticks + 1
    UpdateStatusOLD
  End If
  TickDebug ("Tables")
  
'  Workbooks(m_ResultWorkbook).Sheets("Tabellen").Cells(1, 1).Select
'  Workbooks(m_ResultWorkbook).Sheets("Tabellen").Cells.EntireColumn.AutoFit
'  Workbooks(m_ResultWorkbook).Sheets("Tabellen").Cells.EntireRow.AutoFit
  
  '----------------------------------------------------------
  'SetStatus "Abfragen"
  SetStatus FMT0("CHECK_11")
  '----------------------------------------------------------
  ' ProgressForm.Status.Refresh
  If m_DB.QueryDefs.count > 0 Then
    Set xlsarrChecksumObjekt = xlsarrChecksum.AddXLScriptArray2D("SQLs")
    For i = 0 To m_DB.QueryDefs.count - 1
        If Left(m_DB.QueryDefs(i).name, 1) <> "~" Then
          AddChecksumAndVar ff, m_DB.QueryDefs(i).name, checksum, m_DB.QueryDefs(i).Sql, xlsarrChecksumObjekt, "SQL."
          totalQueryAmount = totalQueryAmount + 1
        End If
        Ticks = Ticks + 1 / m_DB.QueryDefs.count
      UpdateStatusOLD
    Next
  Else
    Ticks = Ticks + 1
    UpdateStatusOLD
  End If
  
  TickDebug ("Queries")
  
  '----------------------------------------------------------
  'SetStatus "VBA-Code"
  SetStatus FMT0("CHECK_12")
  '----------------------------------------------------------
  ' ProgressForm.Status.Refresh
  Dim mdl
  
  Set xlsarr = XLScriptAddArray("MODULES")
  
  Set xlsarrChecksumObjekt = Nothing
  If m_DB.Containers.count > 0 Then
    For Each element In m_DB.Containers
        Select Case element.name
          Case "Modules"
            If xlsarrChecksumObjekt Is Nothing Then
              Set xlsarrChecksumObjekt = xlsarrChecksum.AddXLScriptArray2D("VBA-Module")
            End If
            
            For Each subelement In element.Documents
              
              CurrentObject = subelement.name
              
  '            m_App.Application.SaveAsText acModule, subelement.name, G_cfgTemppfad & "\ACCExt-" & GetUserName & ".txt"
              
  '            Set xlsv = New XLScriptVar
  '            xlsv.Init
  '            Extract G_cfgTemppfad & "\ACCExt-" & GetUserName & ".txt", acModule, xlsv
              
  
              
  '            xlsarr.
              
              If PropertyNameExists(m_DB.Containers("Modules").Documents(subelement.name), "Description") Then
                If Len(Trim(m_DB.Containers("Modules").Documents(subelement.name).Properties("Description"))) >= 20 Then
                  totalVBAModuleCommentAmount = totalVBAModuleCommentAmount + 1
                End If
              End If
              
              m_App.DoCmd.OpenModule subelement.name
              Set mdl = m_App.Modules(subelement.name)
              mdl.Application.Visible = False
              Select Case mdl.Type
                Case 0 ' acStandardModule
                  totalModuleAmount = totalModuleAmount + 1
                Case 1 ' acClassModule
                  totalClassModuleAmount = totalClassModuleAmount + 1
                Case Else
                  totalRestModuleAmount = totalRestModuleAmount + 1
              End Select
              
              CountLOC ff, mdl, totalVBALineAmount, totalVBACommentsAmount, checksum, subelement.name, xlsarrChecksumObjekt, "VBA-Modul.", tChecksum
'          AddChecksumAndVar m_DB.QueryDefs(I).name, checksum, m_DB.QueryDefs(I).Sql, xlsarrChecksumObjekt, "SQLs."
              
              ExtractModule mdl, True, subelement, "MDB"
              
              count = count + 1
              UpdateStatusOLD
              StatusFormUpdate
              Set mdl = Nothing
            Next
        End Select
      Ticks = Ticks + 1 / m_DB.Containers.count
      UpdateStatusOLD
    Next
  Else
    Ticks = Ticks + 1
    UpdateStatusOLD
  End If
  
  
  
  '----------------------------------------------------------
  'SetStatus "Formulare und Formular-VBA-Module"
  SetStatus FMT0("CHECK_48")
  '----------------------------------------------------------
  ' ProgressForm.Status.Refresh
  'AddStatus "Formulare..."
  AddStatus FMT0("CHECK_13")
  Set xlsarrChecksumObjekt = Nothing
  If m_DB.Containers.count > 0 Then
    For Each element In m_DB.Containers
      Select Case element.name
        Case "Forms"
          If xlsarrChecksumObjekt Is Nothing Then
            Set xlsarrChecksumObjekt = xlsarrChecksum.AddXLScriptArray2D("Formulare")
          End If
          For Each subelement In element.Documents
            'UpdateStatus "Formular: " & subelement.name
            UpdateStatus FMT1("CHECK_47", subelement.name)
          
            totalFormAmount = totalFormAmount + 1
            
            If PropertyNameExists(m_DB.Containers("Forms").Documents(subelement.name), "Description") Then
              If Len(Trim(m_DB.Containers("Forms").Documents(subelement.name).Properties("Description"))) >= 20 Then
                totalFormCommentAmount = totalFormCommentAmount + 1
              End If
            End If
            
            CurrentObject = subelement.name
            m_App.DoCmd.OpenForm CurrentObject, 1 ' acDesign
            totalControlsOnFormsAmount = totalControlsOnFormsAmount + m_App.FORMS(subelement.name).Controls.count
            
            AddChecksumControl ff, checksum, m_App.FORMS(subelement.name), xlsarrChecksumObjekt, "Formular."
            Set xlsarrChecksumFld = xlsarrChecksumObjekt.AddXLScriptArray2DToCurrentLine("OBJFIELDS")
'            AddChecksumCollection ff, checksum, m_App.FORMS(subelement.name).Controls, xlsarrChecksumFld, "Formular." & subelement.name & "."
            tChecksum = AddChecksumCollection(ff, checksum, m_App.FORMS(subelement.name).Controls, Nothing, "Formular." & subelement.name & ".")
            xlsarrChecksumObjekt.items(xlsarrChecksumObjekt.items.count)("CHECKSUM").SetValue "CHECKSUM", "h" & AddToChecksum(Mid(xlsarrChecksumObjekt.items(xlsarrChecksumObjekt.items.count)("CHECKSUM").Properties(1), 2), tChecksum)
            
            
            Dim controlItem ' As Control
            For Each controlItem In m_App.FORMS(subelement.name).Controls
              
'              AddChecksumControl checksum, controlItem
              
              Select Case controlItem.controltype
                Case 112 ' acSubform
                  totalSubFormAmount = totalSubFormAmount + 1
                
                ' acOptionButton, acCheckBox, acOptionGroup, acTextBox, acListBox, acComboBox, acToggleButton
                Case 105, 106, 107, 109, 110, 111, 122
                  If Len(controlItem.ControlSource) > 0 And Left(controlItem.ControlSource, 1) <> "=" Then
                    totalEditControlsOnFormsAmount = totalEditControlsOnFormsAmount + 1
                  Else
                    totalProgramEditControlsOnFormsAmount = totalProgramEditControlsOnFormsAmount + 1
                  End If
                Case 119
                  totalActiveXAmount = totalActiveXAmount + 1
              End Select
            Next controlItem
            Set mdl = m_App.FORMS(CurrentObject).Module
            mdl.Application.Visible = False
'            ExtractModule mdl, True, subelement, "MDB"
            If CountLOC(ff, mdl, totalVBALineAmount, totalVBACommentsAmount, checksum, "*VBA-Modul", xlsarrChecksumFld, "Formular." & subelement.name & ".", tChecksum) > 0 Then
              totalFormModuleAmount = totalFormModuleAmount + 1
            End If
            xlsarrChecksumObjekt.items(xlsarrChecksumObjekt.items.count)("CHECKSUM").SetValue "CHECKSUM", "h" & AddToChecksum(Mid(xlsarrChecksumObjekt.items(xlsarrChecksumObjekt.items.count)("CHECKSUM").Properties(1), 2), tChecksum)
            count = count + 1
            UpdateStatusOLD
            Set mdl = Nothing
                  
            ' Das Formular selbst
'            ExtractProperties m_App.Forms(subelement.name).Properties, _
'              m_App.Forms(subelement.name).name, _
'              FormNegProperties, "FORM", True
            
            
            UpdateStatusOLD
            
            ' und die controls
            Dim frm
            Set frm = m_App.FORMS(CurrentObject)
'            ExtractFormControls (frm)
            m_App.DoCmd.Close 2, CurrentObject ' acForm
            Set frm = Nothing
            UpdateStatusOLD
          Next
      End Select
      Ticks = Ticks + 1 / m_DB.Containers.count
      UpdateStatusOLD
    Next
  Else
    Ticks = Ticks + 1
    UpdateStatusOLD
  End If

  TickDebug ("Modules")
  '----------------------------------------------------------
  'SetStatus "Reports und Report-VBA-Module"
  SetStatus FMT0("CHECK_49")
  '----------------------------------------------------------
  ' ProgressForm.Status.Refresh
  'AddStatus "Reports und VBA-Module..."
  AddStatus FMT0("CHECK_14")
  Set xlsarrChecksumObjekt = Nothing
  If m_DB.Containers.count > 0 Then
    For Each element In m_DB.Containers
      Select Case element.name
        Case "Reports"
          If xlsarrChecksumObjekt Is Nothing Then
            Set xlsarrChecksumObjekt = xlsarrChecksum.AddXLScriptArray2D("Reports")
          End If
          For Each subelement In element.Documents
            'UpdateStatus "Report: " & subelement.name
            UpdateStatus FMT1("CHECK_15", subelement.name)
            totalReportAmount = totalReportAmount + 1
            
            If PropertyNameExists(m_DB.Containers("Reports").Documents(subelement.name), "Description") Then
              If Len(Trim(m_DB.Containers("Reports").Documents(subelement.name).Properties("Description"))) >= 20 Then
                totalReportCommentAmount = totalReportCommentAmount + 1
              End If
            End If
            
            CurrentObject = subelement.name
            m_App.DoCmd.OpenReport CurrentObject, 1 'acDesign
            
            AddChecksumControl ff, checksum, m_App.Reports(CurrentObject), xlsarrChecksumObjekt, "Report."
            Set xlsarrChecksumFld = xlsarrChecksumObjekt.AddXLScriptArray2DToCurrentLine("OBJFIELDS")
'            AddChecksumCollection ff, checksum, m_App.Reports(CurrentObject).Controls, xlsarrChecksumFld, "Report." & subelement.name & "."
            tChecksum = AddChecksumCollection(ff, checksum, m_App.Reports(CurrentObject).Controls, Nothing, "Report." & subelement.name & ".")
            xlsarrChecksumObjekt.items(xlsarrChecksumObjekt.items.count)("CHECKSUM").SetValue "CHECKSUM", "h" & AddToChecksum(Mid(xlsarrChecksumObjekt.items(xlsarrChecksumObjekt.items.count)("CHECKSUM").Properties(1), 2), tChecksum)
            
'            For Each controlItem In m_App.Reports(CurrentObject).Controls
'              AddChecksumControl checksum, controlItem
'            Next controlItem
            
            If m_App.Reports(CurrentObject).hasmodule Then
              Set mdl = m_App.Reports(CurrentObject).Module
              mdl.Application.Visible = False
              If CountLOC(ff, mdl, totalVBALineAmount, totalVBACommentsAmount, checksum, "*VBA-Modul", xlsarrChecksumFld, "Report." & subelement.name & ".", tChecksum) > 0 Then
                totalReportModuleAmount = totalReportModuleAmount + 1
              End If
              xlsarrChecksumObjekt.items(xlsarrChecksumObjekt.items.count)("CHECKSUM").SetValue "CHECKSUM", "h" & AddToChecksum(Mid(xlsarrChecksumObjekt.items(xlsarrChecksumObjekt.items.count)("CHECKSUM").Properties(1), 2), tChecksum)
              ExtractModule mdl, True, subelement, "MDB"
            End If
'            ExtractModule mdl, True, subelement, "MDB"
            count = count + 1
            UpdateStatusOLD
            Set mdl = Nothing
                  
            ' Das Formular selbst
'            ExtractProperties m_App.Forms(subelement.name).Properties, _
'              m_App.Forms(subelement.name).name, _
'              FormNegProperties, "FORM", True
            
            UpdateStatusOLD
            
            ' und die controls
            Dim rpt
            Set rpt = m_App.Reports(CurrentObject)
'            ExtractFormControls (frm)
            m_App.DoCmd.Close 3, CurrentObject ' acReport
            Set rpt = Nothing
            UpdateStatusOLD
          Next
      End Select
      Ticks = Ticks + 1 / m_DB.Containers.count
      UpdateStatusOLD
    Next
  Else
    Ticks = Ticks + 1
    UpdateStatusOLD
  End If


  TickDebug ("Permissions")
  Dim lngExecute As Long, lngReadDef As Long, _
   lngWritedef As Long, lngReadData As Long, lngUpdateData As Long, lngDeleteData As Long, _
   lngInsertData As Long, lngDBAdmin As Long, lngDBExclusive As Long
  Dim perm As Long
  
  '----------------------------------------------------------
  'SetStatus "Extracting group permissions"
  SetStatus FMT0("CHECK_16")
  '----------------------------------------------------------
  Set xlsarr = XLScriptAddArray("GROUPPERMISSIONS")

  If m_Workspace.Groups.count > 0 Then
    For Each element In m_Workspace.Groups
      For Each subelement In m_DB.Containers
        For Each sub2element In subelement.Documents
          If Left(sub2element.name, 1) <> "~" Then
            perm = GetPermission(element.name, CStr(subelement.name), sub2element.name)
            Set xlsv = New XLScriptVar
            xlsv.Init "PermissionGroupObject: " & sub2element.name
            xlsv.Properties.Add element.name, "GROUP"
            xlsv.Properties.Add subelement.name, "OBJECTTYPE"
            xlsv.Properties.Add sub2element.name, "OBJECTNAME"
            
            GetFlags subelement.name, _
              lngExecute, _
              lngReadDef, _
              lngWritedef, _
              lngReadData, _
              lngUpdateData, _
              lngDeleteData, _
              lngInsertData, _
              lngDBAdmin, _
              lngDBExclusive
            
            ' dbSecFullAccess
            xlsv.Properties.Add IIf((perm And 1048575) = 1048575, "X", "'-"), "FULLACCESS"
            
            xlsv.Properties.Add IIf(lngExecute > 0, IIf((perm And lngExecute) = lngExecute, "X", "'-"), " "), "EXECUTEOPEN"
            xlsv.Properties.Add IIf(lngReadDef > 0, IIf((perm And lngReadDef) = lngReadDef, "X", "'-"), " "), "READDEF"
            xlsv.Properties.Add IIf(lngWritedef > 0, IIf((perm And lngWritedef) = lngWritedef, "X", "'-"), " "), "WRITEDEF"
            xlsv.Properties.Add IIf(lngReadData > 0, IIf((perm And lngReadData) = lngReadData, "X", "'-"), " "), "READDATA"
            If FullVersion = False Then
              xlsv.Properties.Add "Demo", "UPDATEDATA"
              xlsv.Properties.Add "Demo", "DELETEDATA"
            Else
              xlsv.Properties.Add IIf(lngUpdateData > 0, IIf((perm And lngUpdateData) = lngUpdateData, "X", "'-"), " "), "UPDATEDATA"
              xlsv.Properties.Add IIf(lngDeleteData > 0, IIf((perm And lngDeleteData) = lngDeleteData, "X", "'-"), " "), "DELETEDATA"
            End If
            xlsv.Properties.Add IIf(lngInsertData > 0, IIf((perm And lngInsertData) = lngInsertData, "X", "'-"), " "), "INSERTDATA"
            xlsv.Properties.Add IIf(lngDBAdmin > 0, IIf((perm And lngDBAdmin) = lngDBAdmin, "X", "'-"), " "), "DBADMIN"
            xlsv.Properties.Add IIf(lngDBExclusive > 0, IIf((perm And lngDBExclusive) = lngInsertData, "X", "'-"), " "), "DBEXCLUSIVE"
            
            xlsarr.AddXLScriptVar xlsv
          End If
        Next sub2element
        Ticks = Ticks + 1 / (m_Workspace.Groups.count * m_DB.Containers.count)
        UpdateStatusOLD
      Next subelement
    Next element
  Else
    Ticks = Ticks + 1
    UpdateStatusOLD
  End If


  '----------------------------------------------------------
  'SetStatus "Extracting user permissions"
  SetStatus FMT0("CHECK_17")
  '----------------------------------------------------------
  Set xlsarr = XLScriptAddArray("USERPERMISSIONS")

  If m_Workspace.Users.count > 0 Then
    For Each element In m_Workspace.Users
      For Each subelement In m_DB.Containers
        For Each sub2element In subelement.Documents
          If Left(sub2element.name, 1) <> "~" Then
            perm = GetPermission(element.name, CStr(subelement.name), sub2element.name)
            Set xlsv = New XLScriptVar
            xlsv.Init "PermissionGroupObject: " & sub2element.name
            xlsv.Properties.Add element.name, "GROUP"
            xlsv.Properties.Add subelement.name, "OBJECTTYPE"
            xlsv.Properties.Add sub2element.name, "OBJECTNAME"
            
            GetFlags subelement.name, _
              lngExecute, _
              lngReadDef, _
              lngWritedef, _
              lngReadData, _
              lngUpdateData, _
              lngDeleteData, _
              lngInsertData, _
              lngDBAdmin, _
              lngDBExclusive
            
            ' dbSecFullAccess
            xlsv.Properties.Add IIf((perm And 1048575) = 1048575, "X", "'-"), "FULLACCESS"
            
            xlsv.Properties.Add IIf(lngExecute > 0, IIf((perm And lngExecute) = lngExecute, "X", "'-"), " "), "EXECUTEOPEN"
            xlsv.Properties.Add IIf(lngReadDef > 0, IIf((perm And lngReadDef) = lngReadDef, "X", "'-"), " "), "READDEF"
            xlsv.Properties.Add IIf(lngWritedef > 0, IIf((perm And lngWritedef) = lngWritedef, "X", "'-"), " "), "WRITEDEF"
            xlsv.Properties.Add IIf(lngReadData > 0, IIf((perm And lngReadData) = lngReadData, "X", "'-"), " "), "READDATA"
            If FullVersion = False Then
              xlsv.Properties.Add "Demo", "UPDATEDATA"
              xlsv.Properties.Add "Demo", "DELETEDATA"
            Else
              xlsv.Properties.Add IIf(lngUpdateData > 0, IIf((perm And lngUpdateData) = lngUpdateData, "X", "'-"), " "), "UPDATEDATA"
              xlsv.Properties.Add IIf(lngDeleteData > 0, IIf((perm And lngDeleteData) = lngDeleteData, "X", "'-"), " "), "DELETEDATA"
            End If
            xlsv.Properties.Add IIf(lngInsertData > 0, IIf((perm And lngInsertData) = lngInsertData, "X", "'-"), " "), "INSERTDATA"
            xlsv.Properties.Add IIf(lngDBAdmin > 0, IIf((perm And lngDBAdmin) = lngDBAdmin, "X", "'-"), " "), "DBADMIN"
            xlsv.Properties.Add IIf(lngDBExclusive > 0, IIf((perm And lngDBExclusive) = lngInsertData, "X", "'-"), " "), "DBEXCLUSIVE"
            
            xlsarr.AddXLScriptVar xlsv
          End If
        Next sub2element
        Ticks = Ticks + 1 / (m_Workspace.Users.count * m_DB.Containers.count)
        UpdateStatusOLD
      Next subelement
    Next element
  Else
    Ticks = Ticks + 1
    UpdateStatusOLD
  End If


  TickDebug ("Modules")
  
  '----------------------------------------------------------
  'SetStatus "Extracting scripts"
  SetStatus FMT0("CHECK_18")
  '----------------------------------------------------------
  ' ProgressForm.Status.Refresh
  
  Set xlsarr = XLScriptAddArray("MACROS")
  Set xlsarrChecksumObjekt = Nothing
  If m_DB.Containers.count > 0 Then
    For Each element In m_DB.Containers
      Select Case element.name
        Case "Scripts"
          If xlsarrChecksumObjekt Is Nothing Then
            Set xlsarrChecksumObjekt = xlsarrChecksum.AddXLScriptArray2D("Makros")
          End If
          tChecksum = 0
          
          For Each subelement In element.Documents
            CurrentObject = subelement.name
            totalScriptAmount = totalScriptAmount + 1
            
            If PropertyNameExists(m_DB.Containers("Scripts").Documents(subelement.name), "Description") Then
              If Len(Trim(m_DB.Containers("Scripts").Documents(subelement.name).Properties("Description"))) >= 20 Then
                totalScriptCommentAmount = totalScriptCommentAmount + 1
              End If
            End If
            
            m_App.Application.SaveAsText 4, subelement.name, G_cfgTemppfad & "\ACCExt-" & GetUserName & ".txt"  ' acMacro
            
            Set xlsv = New XLScriptVar
            xlsv.Init "Macro: " & subelement.name
            xlsv.Properties.Add subelement.name, "NAME"
            xlsv.Properties.Add "MACRO", "TYPE"
            xlsarr.AddXLScriptVar xlsv
            Extract ff, G_cfgTemppfad & "\ACCExt-" & GetUserName & ".txt", 4, xlsv, totalScriptLineAmount, totalScriptCommentLinesAmount, checksum, subelement.name, xlsarrChecksumObjekt, "Makro."  ' acMacro
'            xlsarrChecksumObjekt.items(xlsarrChecksumObjekt.items.count)("CHECKSUM").SetValue "CHECKSUM", "h" & AddToChecksum(Mid(xlsarrChecksumObjekt.items(xlsarrChecksumObjekt.items.count)("CHECKSUM").Properties(1), 2), tChecksum)
            
            count = count + 1
            UpdateStatusOLD
            Set mdl = Nothing
          Next
      End Select
      Ticks = Ticks + 1 / m_DB.Containers.count
      UpdateStatusOLD
    Next
  Else
    Ticks = Ticks + 1
    UpdateStatusOLD
  End If
    
  TickDebug ("Scripts")
  
  
  ' ----------------------------------
  ' Relationsfelder Z|fffd|hlen
  ' ----------------------------------
  Set xlsarrChecksumObjekt = xlsarrChecksum.AddXLScriptArray2D("Beziehungen")
  'AddStatus "Beziehungen..."
  AddStatus FMT0("CHECK_19")
  If m_DB.Relations.count > 0 Then
    For Each element In m_DB.Relations
      'UpdateStatus "Beziehung: " & element.Table & "->" & element.ForeignTable
      UpdateStatus FMT2("CHECK_20", element.Table, element.ForeignTable)
      totalRelationFieldAmount = totalRelationFieldAmount + element.Fields.count
      Ticks = Ticks + 1 / m_DB.Relations.count
'      AddChecksumControl checksum, element
      
      AddChecksumControl ff, checksum, element, xlsarrChecksumObjekt, "Beziehung.", element.Table & "->" & element.ForeignTable & "." & IIf(InStrRev(element.name, ".") > 0, Mid(element.name, InStrRev(element.name, ".") + 1), element.name)
      Set xlsarrChecksumFld = xlsarrChecksumObjekt.AddXLScriptArray2DToCurrentLine("OBJFIELDS")
'      AddChecksumCollectionRelation ff, checksum, element.Fields, xlsarrChecksumFld, "Beziehung." & element.Table & "->" & element.ForeignTable & "."
      tChecksum = AddChecksumCollectionRelation(ff, checksum, element.Fields, Nothing, "Beziehung." & element.Table & "->" & element.ForeignTable & "." & IIf(InStrRev(element.name, ".") > 0, Mid(element.name, InStrRev(element.name, ".") + 1), element.name) & ".")
      xlsarrChecksumObjekt.items(xlsarrChecksumObjekt.items.count)("CHECKSUM").SetValue "CHECKSUM", "h" & AddToChecksum(Mid(xlsarrChecksumObjekt.items(xlsarrChecksumObjekt.items.count)("CHECKSUM").Properties(1), 2), tChecksum)
      
'      AddChecksumCollection checksum, element.Fields, Nothing, ""
      UpdateStatusOLD
    Next element
  Else
    Ticks = Ticks + 1
    UpdateStatusOLD
  End If
      
      ' Die Relations
    '  If ExtrudeRelations Then
    '    Print #1, "!DEX_BEGIN_RELATIONS"
    '    For i = 0 To m_DB.Relations.Count - 1
    '      ExtractRelation m_DB.Relations(i)
    '      Count = Count + 1
    '      UpdateStatusOLD
    '    Next
    '    Print #1, "!DEX_END_RELATIONS"
    '  End If
      
    '  TickDebug ("Relations")
  
  
'  Debug.Print "Ticks: " & Ticks & " Totalticks: " & TotalTicks
      
  ' ProgressForm.Hide
'  Unload ProgressForm
'  Set ProgressForm = Nothing


    XLScriptAddSimpleVar "AUTHOR", GetDocProp(m_DB, "Author")
    XLScriptAddSimpleVar "CREATIONDATE", GetDocProp(m_DB, "Creation date")
    XLScriptAddSimpleVar "STATUS", "Analysiert"
    XLScriptAddSimpleVar "STATUSID", "4"


    XLScriptAddSimpleVar "DATE", StartDate
    XLScriptAddSimpleVar "TIMEELAPSED", Format(Time - StartTime, "hh:mm:ss")
    XLScriptAddSimpleVar "TABLES", totalTableAmount
    XLScriptAddSimpleVar "SQLS", IIf(FullVersion = False, "Demo", totalQueryAmount)
    XLScriptAddSimpleVar "VBAMODULES", totalModuleAmount
    XLScriptAddSimpleVar "VBACLASSMODULES", totalClassModuleAmount
    XLScriptAddSimpleVar "VBARESTMODULES", IIf(FullVersion = False, "Demo", totalRestModuleAmount)
    XLScriptAddSimpleVar "FORMS", totalFormAmount
    XLScriptAddSimpleVar "FORMMODULES", totalFormModuleAmount
    XLScriptAddSimpleVar "SCRIPTS", totalScriptAmount
    XLScriptAddSimpleVar "REPORTS", IIf(FullVersion = False, "Demo", totalReportAmount)
    XLScriptAddSimpleVar "REPORTMODULES", totalReportModuleAmount
    XLScriptAddSimpleVar "FILE", orifilename

    XLScriptAddSimpleVar "TABLEFIELDS", totalTableFieldAmount
    XLScriptAddSimpleVar "SUBFORMS", IIf(FullVersion = False, "Demo", totalSubFormAmount)
    XLScriptAddSimpleVar "DATASETS", totalDatasetAmount
    XLScriptAddSimpleVar "DATAFIELDS", totalDatafieldAmount
    XLScriptAddSimpleVar "CONTROLSONFORMS", totalControlsOnFormsAmount
    XLScriptAddSimpleVar "EDITCONTROLSONFORMS", totalEditControlsOnFormsAmount
    XLScriptAddSimpleVar "PROGRAMEDITCONTROLSONFORMS", totalProgramEditControlsOnFormsAmount
    
    XLScriptAddSimpleVar "ACTIVEXONFORMS", IIf(FullVersion = False, "Demo", totalActiveXAmount)
    XLScriptAddSimpleVar "VBALINES", totalVBALineAmount
    XLScriptAddSimpleVar "VBACOMMENTLINES", totalVBACommentsAmount
    XLScriptAddSimpleVar "SCRIPTLINES", totalScriptLineAmount
    XLScriptAddSimpleVar "SCRIPTCOMMENTLINES", totalScriptCommentLinesAmount
    XLScriptAddSimpleVar "INDICES", totalIndicesAmount
    XLScriptAddSimpleVar "REFERENCEDDBS", IIf(FullVersion = False, "Demo", totalReferencedDBAmount)
    XLScriptAddSimpleVar "REFERENCEDTABLES", totalReferencedTablesAmount
    XLScriptAddSimpleVar "RELATIONFIELDS", totalRelationFieldAmount

    XLScriptAddSimpleVar "TABLECOMMENTS", totalTabelCommentAmount
    XLScriptAddSimpleVar "SQLCOMMENTS", totalSQLCommentAmount
    XLScriptAddSimpleVar "FORMCOMMENTS", totalFormCommentAmount
    XLScriptAddSimpleVar "REPORTCOMMENTS", IIf(FullVersion = False, "Demo", totalReportCommentAmount)
    XLScriptAddSimpleVar "SCRIPTCOMMENTS", IIf(FullVersion = False, "Demo", totalScriptCommentAmount)
    XLScriptAddSimpleVar "VBAMODULECOMMENTS", totalVBAModuleCommentAmount
  
    XLScriptAddSimpleVar "RELATIONS", m_App.CurrentDb.Relations.count
    XLScriptAddSimpleVar "REFERENCEAM", m_App.References.count
    XLScriptAddSimpleVar "ISCOMP", m_App.IsCompiled
    XLScriptAddSimpleVar "PRODUCTCODE", Left(m_App.ProductCode, 50)
    XLScriptAddSimpleVar "CONNECT", Left(m_App.CurrentDb.Connect, 120)
    XLScriptAddSimpleVar "QUERYTIMEOUT", m_App.CurrentDb.QueryTimeout
    XLScriptAddSimpleVar "UPDATABLE", m_App.CurrentDb.Updatable
    XLScriptAddSimpleVar "VERSION", Left(m_App.CurrentDb.Version, 8)
    XLScriptAddSimpleVar "REPLICAID", m_App.CurrentDb.ReplicaID
    XLScriptAddSimpleVar "APPTITLE", Left(GetCurDBProperty("APP TITLE"), 120)
    XLScriptAddSimpleVar "STARTUPSHOWDBWINDOW", GetCurDBProperty("STARTUPSHOWDBWINDOW")
    XLScriptAddSimpleVar "ALLOWSHORTCUTMENUS", GetCurDBProperty("ALLOWSHORTCUTMENUS")
    XLScriptAddSimpleVar "ALLOWFULLMENUS", GetCurDBProperty("ALLOWFULLMENUS")
    XLScriptAddSimpleVar "ALLOWBUILTINTOOLBARS", GetCurDBProperty("ALLOWBUILTINTOOLBARS")
    XLScriptAddSimpleVar "ALLOWTOOLBARCHANGES", GetCurDBProperty("ALLOWTOOLBARCHANGES")
    XLScriptAddSimpleVar "ALLOWBREAKINTOCODE", GetCurDBProperty("ALLOWBREAKINTOCODE")
    XLScriptAddSimpleVar "ALLOWSPECIALKEYS", GetCurDBProperty("ALLOWSPECIALKEYS")
  
    XLScriptAddSimpleVar "CHECKSUM", "h" & Hex(checksum)
  
printResults:

  If GetRiskValues() Then
    CreateRisk
  End If
  
  If Not StartedByTracker Then
            Dim ws As Worksheet
            
            Application.Calculation = xlCalculationManual
            Application.ScreenUpdating = False
            Application.EnableEvents = False
          '  AddStatus "Generiere Ergebnisbl|fffd|tter"
            For Each ws In Workbooks(m_ResultWorkbookName).Sheets
              If ws.name <> "Log" Then
                'AddStatus "Generiere Ergenbisblatt " & ws.name
                AddStatus FMT1("CHECK_21", ws.name)
                Helpers.ACCreateHeaderAndFooter ws, orifilename
                XLScriptInit ws, 1
'                XLScriptSetValues TheResults, ws.Cells
                XLScriptExecCode ws.Cells, 0, 0
                XLScriptExit
              End If
              Ticks = Ticks + 1 / Workbooks(m_ResultWorkbookName).Sheets.count
              UpdateStatusOLD
            Next ws
            For Each ws In Workbooks(m_ResultWorkbookName).Sheets
              If ws.name <> "Log" Then
                XLScriptInit ws, 2
                XLScriptExecCode ws.Cells, 0, 0
                XLScriptExit
              
                If ws.name <> "Log" Then
                  ws.Cells.EntireColumn.AutoFit
                  ws.Cells.EntireRow.AutoFit
                End If
                ws.Cells(3, 1).Activate
              End If
              Ticks = Ticks + 1 / Workbooks(m_ResultWorkbookName).Sheets.count
              UpdateStatusOLD
            Next ws
            'AddStatus "Generiere Ergenbisbl|fffd|tter - Fertig"
            AddStatus FMT0("CHECK_22")
            Workbooks(m_ResultWorkbookName).Sheets(1).Activate
            Application.EnableEvents = False
            Application.ScreenUpdating = True
            Application.Calculation = xlCalculationAutomatic
            Application.Visible = True
            
  End If
  
  MyKill G_cfgTemppfad & "\ACCExt-" & GetUserName & ".txt"
  AddStatus "----------------------------------------------------------------"
  
  
  m_App.CloseCurrentDatabase
  m_App.Quit

closeStuff:
  Set m_WS = Nothing
  
  Set m_FN = Nothing
  Set m_Workspace = Nothing
  
  Set m_DB = Nothing
  Set m_App = Nothing
  
  If Not hadError Then
  
    If StartedByTracker Then
      If Not Beenden Then
        SetStatus "Speichere Daten"
        'LogPrintECCSCanLog theFilename & " (ID: " & theidvDateiID & ") - Ergebnis: Analyse erfolgreich beendet, Checksumme: " & XLScriptGetSimpleVar("CHECKSUM").m_Value, True
        LogPrintECCSCanLog theidvDateiID, 4, FMT3("CHECK_23", theFilename, theidvDateiID, XLScriptGetSimpleVar("CHECKSUM").m_Value), True
        XLACCStoreValsToDB True
        ResetRisks
      End If
    End If
  End If
  
  If StartedByTracker Then
    SaveSetting appname:="Stromwerken", Section:=ProgNameShort, Key:="ProcResult", setting:=Right(StatusForm.ProgText, 2048)
  End If
  
  XLScriptExitGlobals
  
  If ff <> -1 Then Close #ff
  SaveSetting appname:="Stromwerken", Section:="AccessTracker", Key:="IgnoreThisOne", setting:="False"
  
  Dim tCnt As Long
  For tCnt = 1 To 20
    Sleep 100
    DoEvents
  Next tCnt
  
  Exit Sub
'-----------------------------------------------------
handleError:
    Dim errstr As String
'    errstr = "Error (" & ProgressForm.Status & ") Object: " & CurrentObject & " - " & Err.Description & "(ErrNr: " & Err.Number & ")"
    errstr = FMT4("CHECK_24", m_Status, CurrentObject, Err.Description, Err.Number)
    XLScriptAddLogEntry errstr
    Resume Next
End Sub


Sub CreateRisk()
  Dim rt As RiskTab
  
  Dim ri As XLScriptArray2D
  Set ri = XLScriptAddArray2D("RiskItems")
  
  Dim totalrisk As Double
  
  
  totalrisk = 0
  
  For Each rt In G_RiskTabs
    ri.AddLine UCase(rt.m_TabName)
    
    ri.AddValue "Tabname", rt.m_TabName ' TranslateText(rt.m_TabName)
    
    Dim risk As Double
    risk = 0
    
    
    Dim rv As RiskVal
    For Each rv In rt.m_Vals
    
      Select Case rv.m_Type
      
        Case C_RISK_TYPE_ECC
      
'              Dim xlssv As XLScriptSimpleVar
'              Set xlssv = XLScriptGetSimpleVar(rv.m_Parameter)
              
              Dim v As String
              v = XLScriptGetVarValue(rv.m_Parameter, Nothing)
              
              If v = "" Then
                Debug.Print "Unknown risk var: " & rv.m_Parameter
                'MsgBox "Unknown risk var: " & rv.m_Parameter, vbCritical, "Access-Checker"
                MsgBox FMT1("CHECK_25", rv.m_Parameter), vbCritical, FMT0("MAIN_1")
              Else
                  
                  If Len(v) > 0 Then
                      
                        Dim rr As RiskRange
                        For Each rr In rv.m_Vals
                            
                            Select Case rr.m_Comparison
                              Case C_RISK_COMP_TYPE_LESS
                                If Val(v) < rr.m_Value Then
                                  risk = risk + rr.m_Risk
                                  XLScriptAddSimpleVar rv.m_Parameter & "BC", IIf(rr.m_Risk < rt.m_Low, rt.m_LowColour, IIf(rr.m_Risk < rt.m_Med, rt.m_MedColour, rt.m_HighColour))
                                  Exit For
                                End If
                              Case C_RISK_COMP_TYPE_LESSEQUAL
                                If Val(v) <= rr.m_Value Then
                                  risk = risk + rr.m_Risk
                                  XLScriptAddSimpleVar rv.m_Parameter & "BC", IIf(rr.m_Risk < rt.m_Low, rt.m_LowColour, IIf(rr.m_Risk < rt.m_Med, rt.m_MedColour, rt.m_HighColour))
                                  Exit For
                                End If
                              Case C_RISK_COMP_TYPE_EQUAL
                                If Val(v) = rr.m_Value Then
                                  risk = risk + rr.m_Risk
                                  XLScriptAddSimpleVar rv.m_Parameter & "BC", IIf(rr.m_Risk < rt.m_Low, rt.m_LowColour, IIf(rr.m_Risk < rt.m_Med, rt.m_MedColour, rt.m_HighColour))
                                  Exit For
                                End If
                              Case C_RISK_COMP_TYPE_LARGER
                                If Val(v) > rr.m_Value Then
                                  risk = risk + rr.m_Risk
                                  XLScriptAddSimpleVar rv.m_Parameter & "BC", IIf(rr.m_Risk < rt.m_Low, rt.m_LowColour, IIf(rr.m_Risk < rt.m_Med, rt.m_MedColour, rt.m_HighColour))
                                  Exit For
                                End If
                              Case C_RISK_COMP_TYPE_LARGEREQUAL
                                If Val(v) >= rr.m_Value Then
                                  risk = risk + rr.m_Risk
                                  XLScriptAddSimpleVar rv.m_Parameter & "BC", IIf(rr.m_Risk < rt.m_Low, rt.m_LowColour, IIf(rr.m_Risk < rt.m_Med, rt.m_MedColour, rt.m_HighColour))
                                  Exit For
                                End If
                            End Select
                            
                        Next rr
                  
                  
                  End If
              End If
        Case C_RISK_TYPE_FORMULA_CONTAINS, C_RISK_TYPE_WHITE_LIST, C_RISK_TYPE_NOT_IN_WHITE_LIST
        
              For Each rr In rv.m_Vals
                  
                  Select Case rr.m_Comparison
                    Case C_RISK_COMP_TYPE_LESS
                      If rv.m_Matches < rr.m_Value Then
                        risk = risk + rr.m_Risk
                        Exit For
                      End If
                    Case C_RISK_COMP_TYPE_LESSEQUAL
                      If rv.m_Matches <= rr.m_Value Then
                        risk = risk + rr.m_Risk
                        Exit For
                      End If
                    Case C_RISK_COMP_TYPE_EQUAL
                      If rv.m_Matches = rr.m_Value Then
                        risk = risk + rr.m_Risk
                        Exit For
                      End If
                    Case C_RISK_COMP_TYPE_LARGER
                      If rv.m_Matches > rr.m_Value Then
                        risk = risk + rr.m_Risk
                        Exit For
                      End If
                    Case C_RISK_COMP_TYPE_LARGEREQUAL
                      If rv.m_Matches >= rr.m_Value Then
                        risk = risk + rr.m_Risk
                        Exit For
                      End If
                  End Select
                  
              Next rr
        
      End Select
    Next rv
    
    
    ri.AddValue "Risk", CStr(IIf(risk > 1, 1, risk * 1))
    
    Dim multi As Double
    
    If risk < rt.m_Low Then
      ri.AddValue "Col", rt.m_LowColour
      multi = rt.m_LowMulti
    ElseIf risk < rt.m_Med Then
      ri.AddValue "Col", rt.m_MedColour
      multi = rt.m_MedMulti
    Else
      ri.AddValue "Col", rt.m_HighColour
      multi = rt.m_HighMulti
    End If
    
    totalrisk = totalrisk + multi * risk * rt.m_Weight
    
  Next rt
  
  XLScriptAddSimpleVar "TotalRisk", CStr(IIf(totalrisk > 1, 1, totalrisk))
  
  If totalrisk <= G_RiskLow Then
    XLScriptAddSimpleVar "TotalRiskCol", CStr(G_RiskLowCol)
  ElseIf totalrisk <= G_RiskMed Then
    XLScriptAddSimpleVar "TotalRiskCol", CStr(G_RiskMedCol)
  Else
    XLScriptAddSimpleVar "TotalRiskCol", CStr(G_RiskHighCol)
  End If
  
  
  ' Und das Gesamtrisiko ermitteln
  
End Sub

Function GetExcelFile(Filename As String, ByRef oxlwbook As Excel.Workbook) As Boolean
  Dim msgBoxText                As String
  
  GetExcelFile = True
  On Error GoTo fehler
  Set oxlwbook = Workbooks.Open(ShortFileName(Filename))
  SaveSetting _
     appname:="Stromwerken", _
     Section:=ProgNameShort, _
     Key:="LiveStatusCaption", _
     setting:=Application.Caption
  Exit Function
  
fehler:
  GetExcelFile = False
End Function


Function GetRiskValues() As Boolean
  GetRiskValues = False
  Dim wb As Excel.Workbook
  Dim rs
  
  Dim riskFilePath As String
  riskFilePath = gTranslation.GetLocalizedFile(ThisWorkbook.path & "\Access-Checker Risk.xls")
  
  Dim regeln As String
  Dim risiken As String
  Dim gesamtrisiko As String
  
  If Not StartedByTracker Then
    If Not GetExcelFile(riskFilePath, wb) Then
      'MsgBox "Die Risikodatei '" & ThisWorkbook.path & "\Access-Checker Risk.xls' fehlt. Es kann keine Risikoanalyse vorgenommen werden!", vbCritical, "Access-Checker"
      MsgBox FMT1("CHECK_26", ThisWorkbook.path), vbCritical, FMT0("MAIN_1")
      Exit Function
    End If
    
    ' Die Sheet-Namen sind hier hard-coded fuer alle unterstuetzten Sprachen.
    ' Begruendung: Wenn Kunden diese Dateien zwischen Instituten in verschiedenen Laendern austauschen/deployen, muss das mit allen Sprachvarianten der files funktionieren.
    ' Also eine englische Version muss das deutsche File lesen koennen. Deshalb werden die Namen nicht aus der Translation gelesen.
    regeln = TranslationSheetExists(wb, Array("Regeln", "Rules"))
    risiken = TranslationSheetExists(wb, Array("Risiken", "Risks"))
    gesamtrisiko = TranslationSheetExists(wb, Array("Gesamtrisiko", "Total Risk"))
    
    If Not WorksheetExists(wb, regeln) Then
      'MsgBox "Es existiert keine Tabelle mit dem Namen 'Regeln' in der Datei '" & ThisWorkbook.path & "\Access-Checker Risk.xls' fehlt. Es kann keine Risikoanalyse vorgenommen werden!", vbCritical, "Access-Checker"
      MsgBox FMT1("CHECK_27", ThisWorkbook.path), vbCritical, FMT0("MAIN_1")
      Exit Function
    End If
    
    If Not WorksheetExists(wb, risiken) Then
      'MsgBox "Es existiert keine Tabelle mit dem Namen 'Risiken' in der Datei '" & ThisWorkbook.path & "\Access-Checker Risk.xls' fehlt. Es kann keine Risikoanalyse vorgenommen werden!", vbCritical, "Access-Checker"
      MsgBox FMT1("CHECK_28", ThisWorkbook.path), vbCritical, FMT0("MAIN_1")
      Exit Function
    End If
    
    If Not WorksheetExists(wb, gesamtrisiko) Then
      'MsgBox "Es existiert keine Tabelle mit dem Namen 'Gesamtrisiko' in der Datei '" & ThisWorkbook.path & "\Access-Checker Risk.xls' fehlt. Es kann keine Gesamtrisikoanalyse vorgenommen werden!", vbCritical, "Access-Checker"
      MsgBox FMT1("CHECK_29", ThisWorkbook.path), vbCritical, FMT0("MAIN_1")
      Exit Function
    End If
    
    
    With wb.Sheets(gesamtrisiko)
      
      G_RiskLow = .Cells(2, 2)
      G_RiskMed = .Cells(3, 2)
      G_RiskLowCol = .Cells(2, 3).Interior.Color
      G_RiskMedCol = .Cells(3, 3).Interior.Color
      G_RiskHighCol = .Cells(4, 3).Interior.Color
    
    End With
  Else
      
      Set rs = CreateObject("ADODB.recordset")
      rs.Open "SELECT * FROM ACCRisikoGesamt", G_Conn, 2, 1
      If rs.EOF Then
        If Not StartedByTracker Then
          'MsgBox "Es sind keine GesamtRisikodaten in der Datenbank des IDV-Trackers enthalten. Es kann keine Gesamtrisikoanalyse vorgenommen werden!", vbCritical, "Access-Checker"
          MsgBox FMT0("CHECK_30"), vbCritical, FMT0("MAIN_1")
        Else
          'AddStatus "Es sind keine GesamtRisikodaten in der Datenbank des IDV-Trackers enthalten. Es kann keine Gesamtrisikoanalyse vorgenommen werden!"
          AddStatus FMT0("CHECK_30")
        End If
        rs.Close
        Set rs = Nothing
        Exit Function
      End If
      
      G_RiskLow = rs.Fields("Gering").value
      G_RiskMed = rs.Fields("Mittel").value
      G_RiskLowCol = rs.Fields("GeringFarbe").value
      G_RiskMedCol = rs.Fields("MittelFarbe").value
      G_RiskHighCol = rs.Fields("HochFarbe").value
      
      rs.Close
      Set rs = Nothing
  End If
  
  Set G_RiskTabs = New Collection
  Set G_RiskContains = New Collection
  Set G_WhiteList = New Collection
  
  
  If Not StartedByTracker Then
    Dim y As Long
    y = 2
    Dim rt As RiskTab
    With wb.Worksheets(risiken)
      Do While Not IsEmpty(.Cells(y, 1))
      
        Set rt = New RiskTab
        If Not rt.Init(wb, y, regeln, risiken) Then Exit Function
        G_RiskTabs.Add rt, .Cells(y, 1)
        y = y + 1
      Loop
    End With
    wb.Close False
    Set wb = Nothing
  
  
  Else
      
      Set rs = CreateObject("ADODB.recordset")
      rs.Open "SELECT * FROM ACCRisiken", G_Conn, 2, 1
      If rs.EOF Then
        If Not StartedByTracker Then
          'MsgBox "Es sind keine Risikodaten in der Datenbank des IDV-Trackers enthalten. Es kann keine Gesamtrisikoanalyse vorgenommen werden!", vbCritical, "Access-Checker"
          MsgBox FMT0("CHECK_31"), vbCritical, FMT0("MAIN_1")
        Else
          'AddStatus "Es sind keine Risikodaten in der Datenbank des IDV-Trackers enthalten. Es kann keine Gesamtrisikoanalyse vorgenommen werden!"
          AddStatus FMT0("CHECK_31")
        End If
        rs.Close
        Set rs = Nothing
        Exit Function
      End If
      
      
      Do While Not rs.EOF
      
        Set rt = New RiskTab
        If Not rt.InitDB(G_Conn, rs) Then Exit Function
        G_RiskTabs.Add rt, rs.Fields("Risiko").value
        rs.MoveNext
      Loop
      
      rs.Close
      Set rs = Nothing
  End If
  
  GetRiskValues = True
End Function

Public Sub ResetRisks()
    Dim rtitem As RiskTab
    Dim rvitem As RiskVal
    For Each rtitem In G_RiskTabs
        For Each rvitem In rtitem.m_Vals
            rvitem.m_Hit = False
            rvitem.m_Matches = 0
            rvitem.m_FirstMatch = ""
            rvitem.m_FirstMatchAddress = ""
        Next rvitem
    Next rtitem
    
    For Each rvitem In G_RiskContains
        rvitem.m_Hit = False
        rvitem.m_Matches = 0
        rvitem.m_FirstMatch = ""
        rvitem.m_FirstMatchAddress = ""
    Next rvitem
    
    For Each rvitem In G_WhiteList
        rvitem.m_Hit = False
        rvitem.m_Matches = 0
        rvitem.m_FirstMatch = ""
        rvitem.m_FirstMatchAddress = ""
    Next rvitem
    

End Sub

Function BuildCacheName(F As String, typ As String, name As String) As String
    BuildCacheName = F & "." & typ & "." & name & ".cache"
End Function
Function NeedsUpdate(t As Date, F As String, typ As String, name As String) As Boolean
    NeedsUpdate = True
    Dim fname As String
    fname = BuildCacheName(F, typ, name)
    On Error GoTo errorHandler
    If t < MyFileDateTime(fname) Then
        NeedsUpdate = False
    End If
    Exit Function
errorHandler:
End Function


Public Sub DoMyEvents()
  MyEventCount = MyEventCount + 1
  If MyEventCount > 10 Then
    DoEvents
    MyEventCount = 0
  End If
End Sub
Private Sub TickDebug(name As String)
  StatusFormUpdate
  If Ticks > LastTicks Then
    Debug.Print name & ": " & Format((Time - LastTime), "Long Time") & _
      "  Ticks: " & Ticks - LastTicks & _
      "  Ticktime: " & ((Time - LastTime) * 100000) / (Ticks - LastTicks)
  Else
    Debug.Print "None: " & name
  End If
  LastTicks = Ticks
  LastTime = Time
End Sub

Private Sub UpdateStatusOLD()
  StatusFormUpdate
  DoEvents
  If Ticks > TotalTicks Then
    Ticks = TotalTicks
  End If
  If TotalTicks > 0 Then
      StatusForm.ProgressTxt = Format(Ticks / TotalTicks, "Percent")
      ' ProgressForm.ProgressText.Refresh
      StatusForm.ProgressB.Width = StatusForm.ProgressTxt.Width * Ticks / TotalTicks
      
      Dim spentTime, remainingTime
      spentTime = Time - StartTime
      
      If Ticks > 0 Then
        remainingTime = (spentTime * (TotalTicks - Ticks)) / Ticks
        ' ProgressForm.ProgressTime = Format(remainingTime, "hh:mm:ss")
        ' ProgressForm.ProgressTime.Refresh
        ' ProgressForm.EstimatedEnd = Format(Time + remainingTime, "hh:mm:ss")
        ' ProgressForm.EstimatedEnd.Refresh
    '    ' ProgressForm.Refresh
      End If
      DoEvents
  End If
  SetLiveStatus
End Sub


Sub MyMain()

  ErrorFileOpen = False
  
  Dim cacheName As String
  Dim cache(1024) As String
  Dim cacheCnt As Integer
  cacheCnt = 0
  
  CurrentObject = "Startup"
  
  On Error GoTo handleError
  
  MyEventCount = 0
  ProgStartTime = Time
   
  TotalTicks = 0
  ' ProgressForm.ProgBar.Max = 100
  ' ProgressForm.Show vbModeless
  
  'Parameter festlegen
  EmptyList = Array("-")
  QueryDefFields = Array("SourceField", "SourceTable", "-")
  RelationFields = Array("Name", "ForeignName", "AllowZeroLength", "-")
  TableElementProperties = Array("Type", "Attributes", "Size", "DataUpdatable", _
    "DefaultValue", "ValidationRule", "ValidationText", "Required", "AllowZeroLength", _
    "Description", "-")
  
 FormControlNegProperties = Array( _
    "TabStop", "TabIndex", "Left", "Top", "Width", _
    "Height", "ForeColor", "FontName", "FontSize", "FontWeight", _
    "FontItalic", "FontUnderline", "TextFontCharSet", "FontBold", "ColumnWidth", _
    "ColumnOrder", "ColumnHidden", "Name", "ObjectPalette", "PictureData", "PrtDevModeW", _
    "-")
  
' FormControlProperties = Array( _
'    "Type", "Name", "Size", "SourceField", "SourceTable", "DataUpdatable", "DefaultValue", "ValidationRule", "ValidationText", "Required", _
'    "AllowZeroLength", "AppendOnly", "Expression", "ColumnHidden", "DisplayControl", "RowSourceType", "BoundColumn", "ColumnCount", _
'    "ColumnHeads", "AllowMultipleValues", "AllowValueListEdits", "ShowOnlyRowSourceValues", "Description", "", "", "", "", "", _
'    "", "", "", "", "", "", "", "", "", "", _
'    "", "", "", "", "", "", "", "", "", "", _
'    "-")
  
  
'  FormProperties = Array("RecordSource", "Filter", "FilterOn", "OrderBy", "OrderByOn", _
'    "AllowFilters", "Caption", "DefaultView", "ViewsAllowed", "AllowEditing", _
'    "DefaultEditing", "AllowEdits", "AllowDeletions", "AllowAdditions", "DataEntry", _
'    "AllowUpdating", "RecordsetType", "RecordLocks", "ScrollBars", "RecordSelectors", _
'    "NavigationButtons", "DividingLines", "AutoResize", "AutoCenter", "PopUp", "Modal", _
'    "BorderStyle", "ControlBox", "MinButton", "MaxButton", "MinMaxButtons", _
'    "CloseButton", "WhatsThisButton", "Picture", "PictureType", "PictureSizeMode", _
'    "PictureAlignment", "PictureTiling", "Cycle", "MenuBar", "Toolbar", "ShortcutMenu", _
'    "ShortcutMenuBar", "LayoutForPrint", "FastLaserPrinting", "HelpFile", _
'    "HelpContextID", "RowHeight", "Visible", "Painting", "PaletteSource", _
'    "Tag", "PaintPalette", "OpenArgs", "OnCurrent", "BeforeInsert", "AfterInsert", _
'    "BeforeUpdate", "AfterUpdate", "OnDelete", "BeforeDelConfirm", "AfterDelConfirm", _
'    "OnOpen", "OnLoad", "OnResize", "OnUnload", "OnClose", "OnActivate", _
'    "OnDeactivate", "OnGotFocus", "OnLostFocus", "OnClick", "OnDblClick", "OnMouseDown", _
'    "OnMouseMove", "OnMouseUp", "OnKeyDown", "OnKeyUp", "OnKeyPress", "KeyPreview", _
'    "OnError", "OnFilter", "OnApplyFilter", "OnTimer", "TimerInterval", "HasModule", _
'    "RowSourceType", "RowSource", "ColumnHeads", "ColumnCount", " - ")
  
  FormNegProperties = Array("Width", "GridX", "GridY", "DatasheetFontName", _
    "DatasheetFontHeight", "DatasheetFontWeight", "DatasheetFontItalic", _
    "DatasheetFontUnderline", "DatasheetGridlinesBehavior", "DatasheetGridlinesColor", _
    "DatasheetCellsEffect", "DatasheetForeColor", "ShowGrid", "DatasheetBackColor", _
    "hWnd", "Count", "LogicalPageWidth", "PrtMip", "PrtDevMode", "PrtDevNames", _
    "FrozenColumns", "Name", "PaletteSource", "WindowWidth", "WindowHeight", _
    "CurrentView", "CurrentSectionTop", "CurrentSectionLeft", "SelLeft", _
    "SelTop", "SelWidth", "SelHeight", "PictureData", "InsideHeight", "InsideWidth", _
    "PicturePalette", "-")
 
  
  
  
  
  Dim i As Integer
  
  ' Parameter einlesen
    
  Dim Filename As String
  Dim destfile As String
  Dim Command As String
  
  UseDefinedDesc = False
  
'  filename = Application.GetOpenFilename("Access-Dateien,*.mdb", 1)
'  If filename = False Then Exit Sub
  
  DoEvents
  

  Dim dummyString As String
  
  
'  If Not FileExists(App.Path & "\DexMsA.cfg") Then
'    MsgBox "Couldn't open " & App.Path & "\DexMsA.cfg!", vbCritical
'    Unload ProgressForm
'    Set ProgressForm = Nothing
'    Exit Sub
'  End If
  
  
'  Open App.Path & "\DexMsA.cfg" For Input As #1
  
  
'  If Err.Number <> 0 Then
'    MsgBox "Couldn't open " & App.Path & "\DexMsA.cfg!", vbCritical
'    Unload ProgressForm
'    Set ProgressForm = Nothing
'    Exit Sub
'  End If
  Input #1, dummyString
  Input #1, LogFilename
  
  Err.Number = 0
  Open LogFilename For Append As #2
  If Err.Number <> 0 Then
    'MsgBox "Couldn't open logfile!", vbCritical
    MsgBox FMT0("CHECK_32"), vbCritical
    ' ProgressForm.Hide
'    Unload ProgressForm
'    Set ProgressForm = Nothing
    
    Exit Sub
  End If
  ErrorFileOpen = True
  
  Input #1, dummyString
  Input #1, Command
  
      Input #1, dummyString
      Input #1, Filename
      Input #1, dummyString
      Input #1, destfile
      Input #1, dummyString
      Input #1, ExtrudeModules
      Input #1, dummyString
      Input #1, ExtrudeTables
      Input #1, dummyString
      Input #1, ExtrudeRelations
      Input #1, dummyString
      Input #1, ExtrudeQueries
      Input #1, dummyString
      Input #1, ExtrudeFormModules
      Input #1, dummyString
      Input #1, ExtrudeScripts
      Input #1, dummyString
      Input #1, ExtrudeForms
      Close #1
      
      DoEvents
      
      If Not FileExists(Filename) Then
        ' Debug.Print "Error (" & ProgressForm.Status & ") Object: " & CurrentObject & " - File " & Filename & " not found!"
'        If ErrorFileOpen Then
'            Print #2, "Error (" & ProgressForm.Status & ") Object: " & CurrentObject & " - File " & Filename & " not found!"
'        End If
'        ProgressForm.Hide
'        Unload ProgressForm
        Exit Sub
      End If
      
      ' ProgressForm.Filename = Filename
      
      Dim appAccess As Object
      Set appAccess = CreateObject("Access.Application.8")
      
      DoEvents
      
      SaveSetting appname:="Stromwerken", Section:="AccessTracker", Key:="IgnoreThisOne", setting:="True"
      appAccess.OpenCurrentDatabase Filename
      
      appAccess.DoCmd.RunCommand 11 ' acCmdAppMinimize
        
      DoEvents
      
      ' Alle Namen besorgen
      Dim db As Database
      Set db = OpenDatabase(Filename)
      Dim element
      Dim subelement
      
      count = 0
      Totalamount = 0
      ' Erst wird gez|fffd|hlt
      
      DoEvents
      
      ' *********************************************************************
      ' Erst z|fffd|hlen z|fffd|hlen
      ' *********************************************************************
      
      'Dann die Tabellen
      If ExtrudeTables Then
        'SetStatus "Counting tables"
        SetStatus FMT0("CHECK_33")
        ' ProgressForm.Status.Refresh
        For Each element In db.TableDefs
          If (element.Attributes And &H80000002) = 0 Then
            If element.Updatable = True Then
                CurrentObject = element.name
                If NeedsUpdate(element.LastUpdated, destfile, "TBL", CurrentObject) Then
                    DoEvents
                    Totalamount = Totalamount + 1
                    TotalTicks = TotalTicks + element.Indexes.count * TableIndexesTicks
                    TotalTicks = TotalTicks + element.Properties.count * TablePropertiesTicks
                    TotalTicks = TotalTicks + element.Fields.count * TableElementPropertiesSize * TableFieldTicks
                End If
            End If
          End If
        Next
      End If
      
      DoEvents
      
      ' Die Abfragen
      If ExtrudeQueries Then
        'SetStatus "Counting queries"
        SetStatus FMT0("CHECK_34")
        ' ProgressForm.Status.Refresh
        For Each element In db.QueryDefs
            If Left(element.name, 1) <> "~" Then
                CurrentObject = element.name
                If NeedsUpdate(element.LastUpdated, destfile, "QRY", CurrentObject) Then
                    DoEvents
                    Totalamount = Totalamount + 1
                    TotalTicks = TotalTicks + element.Properties.count * QueryPropertyTicks
                    TotalTicks = TotalTicks + element.Fields.count * QueryDefFieldsSize * QueryFieldTicks
                    TotalTicks = TotalTicks + element.Parameters.count * QueryParameterTicks
                End If
            End If
        Next
      End If
      
      DoEvents
      
      
      ' Die Module
      If ExtrudeModules Then
        'SetStatus "Counting modules"
        SetStatus FMT0("CHECK_35")
        ' ProgressForm.Status.Refresh
        
        For Each element In db.Containers
          Select Case element.name
            Case "Modules"
                For Each subelement In element.Documents
                  CurrentObject = subelement.name
                  If NeedsUpdate(subelement.LastUpdated, destfile, "MOD", CurrentObject) Then
                    Totalamount = Totalamount + 1
                    TotalTicks = TotalTicks + ModuleTicks
                  End If
                Next
          End Select
        Next
      End If
      
      DoEvents
      
      
      ' Formularmodule und Formulare
      If ExtrudeFormModules Or ExtrudeForms Then
        SetStatus "Counting forms and form-modules"
        ' ProgressForm.Status.Refresh
        
        For Each element In db.Containers
          Select Case element.name
            Case "Forms"
                For Each subelement In element.Documents
                  CurrentObject = subelement.name
                  If NeedsUpdate(subelement.LastUpdated, destfile, "FRM", CurrentObject) Then
                      appAccess.DoCmd.OpenForm subelement.name, 1 ' acDesign
                      If ExtrudeFormModules Then
                        Totalamount = Totalamount + 1
                        TotalTicks = TotalTicks + FormModuleTicks
                      End If
                      If ExtrudeForms Then
                        ' erst die Formulare selbst
                        Totalamount = Totalamount + 1
    '                    TotalTicks = TotalTicks + FormPropertiesSize * FormPropertiesTicks
                        TotalTicks = TotalTicks + (appAccess.FORMS(subelement.name).Properties.count - FormNegPropertiesSize) * FormNegPropertiesTicks
                        ' Dann die Controls
                        Dim telement
                        For Each telement In appAccess.FORMS(subelement.name)
                          TotalTicks = TotalTicks + (telement.Properties.count - FormControlNegPropertiesSize) * FormControlPropertiesTicks
                        Next
                      End If
                   End If
                Next
          End Select
        Next
      End If
      
      DoEvents
      
      If ExtrudeScripts Then
        'SetStatus "Counting scripts"
        SetStatus FMT0("CHECK_36")
        ' ProgressForm.Status.Refresh
        
        For Each element In db.Containers
          Select Case element.name
            Case "Scripts"
                For Each subelement In element.Documents
                  CurrentObject = subelement.name
                  If NeedsUpdate(subelement.LastUpdated, destfile, "SCR", CurrentObject) Then
                    Totalamount = Totalamount + 1
                    TotalTicks = TotalTicks + ScriptTicks
                  End If
                Next
          End Select
        Next
      End If
      
      DoEvents
      
      ' Die Relations
    '  If ExtrudeRelations Then
    '    For Each element In db.Relations
    '      Totalamount = Totalamount + 1
    '      TotalTicks = TotalTicks + element.Properties.Count
    '      TotalTicks = TotalTicks + element.Fields.Count * RelationFieldsSize
    '    Next
    '  End If
      
      '-------------------------------------------
      ' Jetzt gehts looooos
      '-------------------------------------------
      StartTime = Time
      LastTime = Time
      Ticks = 0
      LastTicks = 0
      
      'Dann die Tabellen
      If ExtrudeTables Then
        'SetStatus "Extracting tables"
        SetStatus FMT0("CHECK_37")
        ' ProgressForm.Status.Refresh
        For i = 0 To db.TableDefs.count - 1
          If (db.TableDefs(i).Attributes And &H80000002) = 0 Then
            If db.TableDefs(i).Updatable = True Then
                CurrentObject = db.TableDefs(i).name
'                Print #3, "!DEX_INCLUDE "; cacheName
                cacheName = BuildCacheName(destfile, "TBL", CurrentObject)
                cache(cacheCnt) = cacheName
                cacheCnt = cacheCnt + 1
                If NeedsUpdate(db.TableDefs(i).LastUpdated, destfile, "TBL", CurrentObject) Then
                  Open cacheName For Output As #1
                    ExtractTable db.TableDefs(i)
                    count = count + 1
                  Close #1
                End If
            End If
          End If
          UpdateStatusOLD
        Next
      End If
      
      TickDebug ("Tables")
      
      ' Und die Abfragen
      If ExtrudeQueries Then
        'SetStatus "Extracting queries"
        SetStatus FMT0("CHECK_38")
        ' ProgressForm.Status.Refresh
        For i = 0 To db.QueryDefs.count - 1
            If Left(db.QueryDefs(i).name, 1) <> "~" Then
                CurrentObject = db.QueryDefs(i).name
'                Print #3, "!DEX_INCLUDE "; cacheName
                cacheName = BuildCacheName(destfile, "QRY", CurrentObject)
                cache(cacheCnt) = cacheName
                cacheCnt = cacheCnt + 1
                If NeedsUpdate(db.QueryDefs(i).LastUpdated, destfile, "QRY", CurrentObject) Then
                  Open cacheName For Output As #1
                    ExtractQuery db.QueryDefs(i)
                    count = count + 1
                    UpdateStatusOLD
                  Close #1
                End If
            End If
        Next
      End If
      
      TickDebug ("Queries")
      
      
      ' Und jetzt die Code-Module extrahieren
      If ExtrudeModules Then
        'SetStatus "Extracting modules"
        SetStatus FMT0("CHECK_39")
        ' ProgressForm.Status.Refresh
        For Each element In db.Containers
            Select Case element.name
              Case "Modules"
                For Each subelement In element.Documents
                  CurrentObject = subelement.name
    '              Debug.Print "Found Module " & subelement.name
                  cacheName = BuildCacheName(destfile, "MOD", CurrentObject)
                  cache(cacheCnt) = cacheName
                  cacheCnt = cacheCnt + 1
                  If NeedsUpdate(subelement.LastUpdated, destfile, "MOD", CurrentObject) Then
                    Open cacheName For Output As #1
                        appAccess.DoCmd.OpenModule subelement.name
                        Dim mdl
                        Set mdl = appAccess.Modules(subelement.name)
                        mdl.Application.Visible = False
                        ExtractModule mdl, False, subelement, "MDB"
                        count = count + 1
                        Ticks = Ticks + ModuleTicks
                        UpdateStatusOLD
                        Set mdl = Nothing
                    Close #1
                  End If
                Next
            End Select
        Next
      End If
      
      ' Formular-Code-Module extrahieren
      If ExtrudeFormModules Or ExtrudeForms Then
        'SetStatus "Extracting forms and form-modules"
        SetStatus FMT0("CHECK_40")
        ' ProgressForm.Status.Refresh
        For Each element In db.Containers
            Select Case element.name
              Case "Forms"
                For Each subelement In element.Documents
                  CurrentObject = subelement.name
    '              Debug.Print "Found Form " & subelement.name
'                  appAccess.DoCmd.OpenForm subelement.name, acDesign
'                  Print #3, "!DEX_INCLUDE "; cacheName
                  cacheName = BuildCacheName(destfile, "FRM", CurrentObject)
                  cache(cacheCnt) = cacheName
                  cacheCnt = cacheCnt + 1
                  If NeedsUpdate(subelement.LastUpdated, destfile, "FRM", CurrentObject) Then
                    Open cacheName For Output As #1
                      If ExtrudeFormModules Then
                        If appAccess.FORMS(subelement.name).hasmodule Then
                          Set mdl = appAccess.FORMS(subelement.name).Module
                          mdl.Application.Visible = False
                          ExtractModule mdl, True, subelement, "MDB"
                        End If
                        count = count + 1
                        Ticks = Ticks + FormModuleTicks
                        UpdateStatusOLD
                        Set mdl = Nothing
                      End If
                      If ExtrudeForms Then
                        Print #1, "!DEX_BEGIN_BLOCK "; subelement.name
                        Print #1, "!DEX_TYPE FORM"
                        
                        ' Das Formular selbst
                        Call ExtractProperties(appAccess.FORMS(subelement.name).Properties, _
                          appAccess.FORMS(subelement.name).name, _
                          FormNegProperties, "FORM", True)
    '                    Ticks = Ticks + FormPropertiesSize * FormPropertiesTicks
                        Ticks = Ticks + (appAccess.FORMS(subelement.name).Properties.count - FormNegPropertiesSize) * FormNegPropertiesTicks
                        
                        UpdateStatusOLD
                        
                        ' und die controls
                        Dim frm
                        Set frm = appAccess.FORMS(subelement.name)
                        ExtractFormControls (frm)
                        Set frm = Nothing
                        UpdateStatusOLD
                        Print #1, "!DEX_END_BLOCK"
                      End If
                    Close #1
                  End If
                Next
            End Select
        Next
      End If
      
      TickDebug ("Modules")
      
      ' Scripte extrahieren
      If ExtrudeScripts Then
        'SetStatus "Extracting scripts"
        SetStatus FMT0("CHECK_41")
        ' ProgressForm.Status.Refresh
        For Each element In db.Containers
            Select Case element.name
              Case "Scripts"
'                Print #3, "!DEX_INCLUDE "; cacheName
                For Each subelement In element.Documents
                    CurrentObject = subelement.name
                    cacheName = BuildCacheName(destfile, "SCR", CurrentObject)
                    cache(cacheCnt) = cacheName
                    cacheCnt = cacheCnt + 1
                    If NeedsUpdate(subelement.LastUpdated, destfile, "SCR", CurrentObject) Then
                      Open cacheName For Output As #1
        '              Debug.Print "Found Script " & subelement.name
'                      Set mdl = appAccess.Modules(subelement.name).Module
        '              ExtractModule mdl
                      Print #1, "!DEX_BEGIN_BLOCK "; subelement.name
                      Print #1, "!DEX_TYPE SCRIPT"
                      Print #1, "!DEX_END_BLOCK"
                      count = count + 1
                      Ticks = Ticks + ScriptTicks
                      UpdateStatusOLD
                      Set mdl = Nothing
                      Close #1
                    End If
                Next
            End Select
        Next
      End If
      
      TickDebug ("Scripts")
      
      
      ' Die Relations
    '  If ExtrudeRelations Then
    '    Print #1, "!DEX_BEGIN_RELATIONS"
    '    For i = 0 To db.Relations.Count - 1
    '      ExtractRelation db.Relations(i)
    '      Count = Count + 1
    '      UpdateStatusOLD
    '    Next
    '    Print #1, "!DEX_END_RELATIONS"
    '  End If
      
    '  TickDebug ("Relations")
      
      'SetStatus "Shutting down DB"
      SetStatus FMT0("CHECK_42")
      ' ProgressForm.Status.Refresh
      
      db.Close
      
      appAccess.CloseCurrentDatabase
      Set appAccess = Nothing
      
      If cacheCnt > 0 Then
        'SetStatus "Building file"
        SetStatus FMT0("CHECK_43")
        ' ProgressForm.Status.Refresh
        
        Open destfile For Output As #1
        Dim cnt As Integer
        For cnt = 0 To cacheCnt - 1
            Debug.Print cache(cnt)
            Open cache(cnt) For Binary Access Read As #3
              Print #1, Input(MyFileLen(cache(cnt)), #3)
            Close #3
        Next cnt
        
        Close #1
      End If
      Debug.Print "Ticks: " & Ticks & " Totalticks: " & TotalTicks
      
  ' ProgressForm.Hide
'  Unload ProgressForm
'  Set ProgressForm = Nothing
  
  Close #2
  
  Exit Sub
'-----------------------------------------------------
handleError:
    Dim errstr As String
'    errstr = "Error (" & ProgressForm.Status & ") Object: " & CurrentObject & " - " & Err.Description & "(ErrNr: " & Err.Number & ")"
    Debug.Print errstr
    If ErrorFileOpen Then
        Print #2, errstr
    End If
    Resume Next
'-----------------------------------------------------

End Sub

Function ExtractTableFields(fld As Fields, name As String)
  On Error Resume Next

  Dim element
  Dim dummy As Integer
  ' Felder ausgeben
  Print #1, "!DEX_BEGIN_TABLE_FIELDS "; name
  For Each element In fld
    With element
      Call ExtractProperties(.Properties, .name, TableElementProperties, "TABLE_FIELD")
    End With
  Next element
  Ticks = Ticks + fld.count * TableElementPropertiesSize * TableFieldTicks
  UpdateStatusOLD
  Print #1, "!DEX_END_TABLE_FIELDS "; name

End Function
  
  
Private Sub ExtractQueryFields(fld As Fields, name As String)
  On Error Resume Next

  Dim element
  ' Felder ausgeben
  Print #1, "!DEX_BEGIN_QUERY_FIELDS "; name
  For Each element In fld
    With element
      DoMyEvents
      Print #1, "!DEX_BEGIN_QUERY_FIELD "; .name
      Dim i
      i = 0
      While QueryDefFields(i) <> "-"
        Print #1, "!DEX_FN "; QueryDefFields(i)
'        Print #1, "!DEX_FT "; GetVartypeText(.Properties(QueryDefFields(i)).Type)
        Print #1, "!DEX_FV "; .Properties(QueryDefFields(i)).value
        i = i + 1
      Wend
      Print #1, "!DEX_END_QUERY_FIELD"
    End With
  Next element
  Ticks = Ticks + fld.count * QueryDefFieldsSize * QueryFieldTicks
  UpdateStatusOLD
  Print #1, "!DEX_END_QUERY_FIELDS"

End Sub
  
Sub ExtractRelationFields(fld As Fields, name As String)
  On Error Resume Next

  Dim element
  ' Felder ausgeben
  Print #1, "!DEX_BEGIN_RELATION_FIELDS "; name
  For Each element In fld
    DoMyEvents
    With element
      Print #1, "!DEX_BEGIN_RELATION_FIELD "; .name
      Dim i
      While RelationFields(i) <> "-"
        Print #1, "!DEX_RN "; RelationFields(i)
'        Print #1, "!DEX_RT "; GetVartypeText(.Properties(RelationFields(i)).Type)
        Print #1, "!DEX_RV "; .Properties(RelationFields(i)).value
        i = i + 1
      Wend
      Print #1, "!DEX_END_RELATION_FIELD"
    End With
  Next element
  Ticks = Ticks + fld.count * RelationFieldsSize
  UpdateStatusOLD
  Print #1, "!DEX_END_RELATION_FIELDS"
End Sub


Private Sub ExtractTable(element As TableDef)
    On Error Resume Next
    Dim i As Integer
    Dim subelement
  
    Print #1, "!DEX_BEGIN_BLOCK "; element.name
    Print #1, "!DEX_TYPE TABLE"
    
    ' Properties ausgeben
    Call ExtractProperties(element.Properties, element.name, EmptyList, "TABLE")
    Ticks = Ticks + element.Properties.count * TablePropertiesTicks
    UpdateStatusOLD
    
    ' Indizes der Tabelle schreiben
    Print #1, "!DEX_BEGIN_TABLE_INDEXES "; element.name
    For Each subelement In element.Indexes
      With subelement
        Print #1, "!DEX_INDEX " & .name
        Print #1, "!DEX_INDEX_TYPE " & .Fields
      End With
    Next subelement
    Print #1, "!DEX_END_TABLE_INDEXES"
    Ticks = Ticks + element.Indexes.count * TableIndexesTicks
    UpdateStatusOLD
    
    ' Felder ausgeben
    ExtractTableFields element.Fields, element.name
    
    Print #1, "!DEX_END_BLOCK "

End Sub

Sub ExtractQuery(element As QueryDef)
  On Error Resume Next
  Dim i As Integer
  
  With element
  
    Print #1, "!DEX_BEGIN_BLOCK "; .name
    Print #1, "!DEX_TYPE SQL_QUERY"
  
    If UseDefinedDesc Then
      Print #1, "!DEX_QUERY_DESC " & .Properties("Description")
      Print #1, "!DEX_CHANGES " & .LastUpdated
      Print #1, "!DEX_QUERY_CONNECT " & .Connect
      Print #1, "!DEX_QUERY_SQL " & .Sql
    End If
  
    ' Properties ausgeben
    Call ExtractProperties(.Properties, .name, EmptyList, "QUERY")
    Ticks = Ticks + .Properties.count * QueryPropertyTicks
    UpdateStatusOLD
  
    ' Felder ausgeben
    ExtractQueryFields .Fields, .name
    
    ' Parameter schreiben
    Print #1, "!DEX_BEGIN_PARAMETERS "; .name
      Dim subelement
      For Each subelement In element.Parameters
        DoMyEvents
        With subelement
          Print #1, "!DEX_BEGIN_PARAMETER " & .name
'          Print #1, "!DEX_PARAMETER_TYPE "; GetVartypeText(.Type)
          Print #1, "!DEX_END_PARAMETER"
        End With
      Next subelement
    Print #1, "!DEX_END_PARAMETERS"
    Ticks = Ticks + element.Parameters.count * QueryParameterTicks
  
  End With
  Print #1, "!DEX_END_BLOCK "
End Sub



Sub ExtractRelation(element As Relation)
  On Error Resume Next
  Dim i As Integer
  
  With element
  
    Print #1, "!DEX_BEGIN_BLOCK "; .name
    Print #1, "!DEX_TYPE RELATION"
  
    If UseDefinedDesc Then
      Print #1, "!DEX_RELATION_DESC " & .Properties("Description")
      Print #1, "!DEX_RELATION_TABLE " & .Table
      Print #1, "!DEX_RELATION_FOREIGN_TABLE " & .ForeignTable
    End If
    
    ' Properties ausgeben
    Call ExtractProperties(.Properties, element.name, EmptyList, "RELATION")
    Ticks = Ticks + .Properties.count
    UpdateStatusOLD
  
    ' Felder ausgeben
    ExtractRelationFields element.Fields, element.name
  
  End With
  Print #1, "!DEX_END_BLOCK "
End Sub


Function GetControlTypeText(controltype As Integer) As String
  GetControlTypeText = "Unknown"
'  Select Case controltype
'    Case acLabel
'      GetControlTypeText = "Label"
'    Case acRectangle
'      GetControlTypeText = "Rectangle"
'    Case acLine
'      GetControlTypeText = "Line"
'    Case acImage
'      GetControlTypeText = "Image"
'    Case acCommandButton
'      GetControlTypeText = "CommandButton"
'    Case acOptionButton
'      GetControlTypeText = "OptionButton"
'    Case acCheckBox
'      GetControlTypeText = "CheckBox"
'    Case acOptionGroup
'      GetControlTypeText = "OptionGroup"
'    Case acBoundObjectFrame
'      GetControlTypeText = "BoundObjectFrame"
'    Case acTextBox
'      GetControlTypeText = "TextBox"
'    Case acListBox
'      GetControlTypeText = "ListBox"
'    Case acComboBox
'      GetControlTypeText = "ComboBox"
'    Case acSubform
'      GetControlTypeText = "SubForm"
'    Case acObjectFrame
'      GetControlTypeText = "ObjectFrame"
'    Case acPageBreak
'      GetControlTypeText = "PageBreak"
'    Case acPage
'      GetControlTypeText = "Page"
'    Case acCustomControl
'      GetControlTypeText = "CustomControl"
'    Case acToggleButton
'      GetControlTypeText = "ToggleButton"
'    Case acTabCtl
'      GetControlTypeText = "TabControl"
'  End Select
End Function

Function GetVartypeText(vartype As Integer) As String
  GetVartypeText = "Unknown"
  Select Case vartype
    Case vbEmpty
      GetVartypeText = "vbEmpty"
    Case vbNull
      GetVartypeText = "vbNull"
    Case vbInteger
      GetVartypeText = "vbInteger"
    Case vbLong
      GetVartypeText = "vbLong"
    Case vbSingle
      GetVartypeText = "vbSingle"
    Case vbDouble
      GetVartypeText = "vbDouble"
    Case vbCurrency
      GetVartypeText = "vbCurrency"
    Case vbDate
      GetVartypeText = "vbDate"
    Case vbString
      GetVartypeText = "vbString"
    Case vbObject
      GetVartypeText = "vbObject"
    Case vbError
      GetVartypeText = "vbError"
    Case vbBoolean
      GetVartypeText = "vbBoolean"
    Case vbVariant
      GetVartypeText = "vbVariant"
    Case vbDataObject
      GetVartypeText = "vbDataObject"
    Case vbDecimal
      GetVartypeText = "vbDecimal"
    Case vbByte
      GetVartypeText = "vbByte"
    Case vbArray
      GetVartypeText = "vbArray"
  End Select
End Function

Function CountLOC(ff As Integer, mdl, ByRef totalVBALineAmount As Long, ByRef totalVBACommentsAmount As Long, ByRef checksum As Long, modName As String, ByRef xlsarr As XLScriptArray2D, txtExtension As String, ByRef partChecksum As Long) As Long
  partChecksum = 0
  Dim i As Integer
  Dim loc As Integer
  Dim filledLines As Long
  
  loc = mdl.CountOfLines
  
  Dim tSource As String
  
  For i = 1 To loc
    Dim pos As Long
          
    Dim tstr As String
    pos = InStr(RemoveStrings(mdl.Lines(i, 1)), "'")
    
    If pos > 0 Then
      If Len(Mid(mdl.Lines(i, 1), pos + 1)) >= 8 Then
        totalVBACommentsAmount = totalVBACommentsAmount + 1
      End If
      If pos > 1 Then
        tstr = Trim(Left(RemoveStrings(mdl.Lines(i, 1)), pos - 1))
      End If
    Else
      tstr = Trim(mdl.Lines(i, 1))
    End If
    
    If Len(tstr) > 0 Then
      totalVBALineAmount = totalVBALineAmount + 1
      filledLines = filledLines + 1
    End If
    
    tSource = tSource & Trim(mdl.Lines(i, 1)) & vbCrLf
  
  Next
  
  partChecksum = AddChecksumAndVar(ff, modName, checksum, tSource, xlsarr, txtExtension)
  
  If filledLines = 2 And mdl.Lines(1, 1) = "Option Compare Database" And mdl.Lines(2, 1) = "Option Explicit" Then
      totalVBALineAmount = totalVBALineAmount - 2
      filledLines = filledLines - 2
  End If
  CountLOC = filledLines
End Function

Function RemoveStrings(ByVal txt As String) As String
  Dim pos As Long
  Dim pos2 As Long
  Do
    pos = InStr(txt, Chr(34))
    If pos <= 0 Then Exit Do
    pos2 = InStr(pos + 1, txt, Chr(34))
    If pos2 <= 0 Then Exit Do
    Dim tstr As String
    tstr = ""
    If pos > 1 Then tstr = Left(txt, pos - 1)
    If pos2 < Len(txt) Then tstr = tstr & Mid(txt, pos2 + 1)
    txt = tstr
  Loop
  RemoveStrings = txt
End Function

Sub ExtractModule(mdl, isForm As Boolean, obj, extType As String, Optional modtype As Long = -1)

  Exit Sub
  
  
  Print #1, "!DEX_BEGIN_BLOCK "; mdl.name
  If isForm Then
'    Debug.Print "Extracting Form " & mdl.name
    Print #1, "!DEX_TYPE FORM_CODE"
  Else
    If extType = "MDB" Then
      Select Case mdl.Type
        Case 0 ' acStandardModule
  '        Debug.Print "Extracting Module " & mdl.name
          Print #1, "!DEX_TYPE MODULE"
        Case 1 ' acClassModule
  '        Debug.Print "Extracting Class " & mdl.name
          Print #1, "!DEX_TYPE CLASS"
        Case Else
          Exit Sub
      End Select
    ElseIf extType = "XLS" Then
      If modtype = 2 Then
        Print #1, "!DEX_TYPE CLASS"
      ElseIf modtype = 3 Then
        Print #1, "!DEX_TYPE FORM_CODE"
      Else
        Print #1, "!DEX_TYPE MODULE"
      End If
    End If
  End If
  
  If extType = "MDB" Then
    Print #1, "!DEX_PN DateCreated"
    Print #1, "!DEX_PV " & obj.Properties("DateCreated")
    Print #1, "!DEX_PN LastUpdated"
    Print #1, "!DEX_PV " & obj.Properties("LastUpdated")
  End If
  
  Dim i As Integer
  Dim loc As Integer
  Dim code As String
  Dim tstr As String
  
  loc = mdl.CountOfLines
  For i = 1 To loc
    DoMyEvents
    Dim pos As Long
    
    ' Formulare holen
    If extType = "MDB" Then
      pos = InStr(mdl.Lines(i, 1), "DoCmd.OpenForm ")
      ' Dann holen wir auch die DoCmd.OpenForm
      If pos > 0 Then
          pos = pos + Len("DoCmd.OpenForm ")
          tstr = Mid(mdl.Lines(i, 1), pos)
          If Left(tstr, 1) = Chr(&H22) Then
              pos = InStr(2, tstr, Chr(&H22))
              If pos > 0 Then
                  Print #1, "!DEX_USES |FORM "; Mid(tstr, 2, pos - 2)
              End If
          End If
      End If
      
      ' Macros holen
      pos = InStr(mdl.Lines(i, 1), "DoCmd.RunMacro ")
      ' Dann holen wir auch die DoCmd.OpenForm
      If pos > 0 Then
          pos = pos + Len("DoCmd.RunMacro ")
          tstr = Mid(mdl.Lines(i, 1), pos)
          If Left(tstr, 1) = Chr(&H22) Then
              pos = InStr(2, tstr, Chr(&H22))
              If pos > 0 Then
                  Print #1, "!DEX_USES |MACRO "; Mid(tstr, 2, pos - 2)
              End If
          End If
      End If
      
      ' Reports holen
      pos = InStr(mdl.Lines(i, 1), "DoCmd.OpenReport ")
      ' Dann holen wir auch die DoCmd.OpenForm
      If pos > 0 Then
          pos = pos + Len("DoCmd.OpenReport ")
          tstr = Mid(mdl.Lines(i, 1), pos)
          If Left(tstr, 1) = Chr(&H22) Then
              pos = InStr(2, tstr, Chr(&H22))
              If pos > 0 Then
                  Print #1, "!DEX_USES |REPORT "; Mid(tstr, 2, pos - 2)
              End If
          End If
      End If
    End If
    
    ' Snipits bearbeiten
    If InStr(mdl.Lines(i, 1), "'// SNIPIT") > 0 Then
      Print #1, "!DEX_LINE "; i
      Print #1, "!DEX_SNIPIT"
      i = i + 1
      While InStr(mdl.Lines(i, 1), "'// SNIPIT") = 0
        Print #1, mdl.Lines(i, 1)
        i = i + 1
      Wend
      Print #1, "!DEX_SNIPIT"
    End If
    
    Dim tpos As Long
    If InStr(mdl.Lines(i, 1), "'// TODO") > 0 Or _
      InStr(mdl.Lines(i, 1), "'// TBD") > 0 Or _
      InStr(mdl.Lines(i, 1), "'// IDEA") > 0 Or _
      InStr(mdl.Lines(i, 1), "'// REMINDER") > 0 Or _
      InStr(mdl.Lines(i, 1), "'// KNOWN BUG") > 0 Or _
      InStr(mdl.Lines(i, 1), "'// NOTE") > 0 _
      Then
      Print #1, "!DEX_LINE "; i
      tpos = InStr(mdl.Lines(i, 1), "'// ")
      Print #1, Mid(mdl.Lines(i, 1), tpos + 1)
      i = i + 1
      While InStr(mdl.Lines(i, 1), "'// ") <> 0
        tpos = InStr(mdl.Lines(i, 1), "'// ")
        Print #1, Mid(mdl.Lines(i, 1), tpos + 1)
        i = i + 1
      Wend
    End If
    
    
    If InStr(mdl.Lines(i, 1), "'/*|") > 0 Then
      Print #1, "!DEX_LINE "; i
      Print #1, Mid(mdl.Lines(i, 1), 2)
      Do
        i = i + 1
        Print #1, Mid(mdl.Lines(i, 1), 2)
      Loop While InStr(mdl.Lines(i, 1), "*/") = 0
      ' Und jetzt noch den Funktionskopf besorgen!
      If i < loc Then
          If (InStr(mdl.Lines(i + 1, 1), "Sub") <> 0) Or _
             (InStr(mdl.Lines(i + 1, 1), "Function") <> 0) Then
            Do
              i = i + 1
              Print #1, mdl.Lines(i, 1)
            Loop While InStr(mdl.Lines(i, 1), ")") = 0
          End If
      End If
'    ElseIf (InStr(mdl.Lines(i, 1), "Sub") <> 0) Or _
'           (InStr(mdl.Lines(i, 1), "Function") <> 0) Then
'        Print #1, "!DEX_FUNC " & mdl.Lines(i, 1)
    End If
  Next
  
  Print #1, "!DEX_END_BLOCK"

End Sub

Public Sub ExtractProperties(element As Variant, name As String, propNames As Variant, _
  propNameDex As String, Optional useAsNegList As Boolean = False)
  On Error Resume Next
  If Not UseDefinedDesc Then
    
    Print #1, "!DEX_BEGIN_" & propNameDex & "_PROPERTIES "; name
    ' Properties ausgeben
    Dim i
    If propNames(0) = "-" Then
      For i = 0 To element.count - 1
        With element(i)
            DoMyEvents
            Print #1, "!DEX_PN "; .name
'            Print #1, "!DEX_PT "; GetVartypeText(.Type)
            If .name = "Type" Then
                Print #1, "!DEX_PV "; GetVartypeText(.value)
            ElseIf .name = "ControlType" Then
                Print #1, "!DEX_PV "; GetControlTypeText(.value)
            Else
                Print #1, "!DEX_PV "; .value
            End If
        End With
      Next i
    Else
      If useAsNegList Then
          For i = 0 To element.count - 1
            With element(i)
                DoMyEvents
                
                Dim found As Boolean
                Dim q As Integer
                found = False
                q = 0
                While (propNames(q) <> "-")
                  If .name = propNames(q) Then
                    found = True
                  End If
                  q = q + 1
                Wend
                If Not found Then
                    Print #1, "!DEX_PN "; .name
        '            Print #1, "!DEX_PT "; GetVartypeText(.Type)
                    If .name = "Type" Then
                        Print #1, "!DEX_PV "; GetVartypeText(.value)
                    ElseIf .name = "ControlType" Then
                        Print #1, "!DEX_PV "; GetControlTypeText(.value)
                    Else
                        Print #1, "!DEX_PV "; .value
                    End If
                End If
            End With
          Next i
      Else
          While (propNames(i) <> "-")
            DoMyEvents
            Print #1, "!DEX_PN "; propNames(i)
    '        Print #1, "!DEX_PT "; GetVartypeText(element(propNames(i)).Type)
            If propNames(i) = "Type" Then
                Print #1, "!DEX_PV "; GetVartypeText(element(propNames(i)).value)
            ElseIf propNames(i) = "ControlType" Then
                Print #1, "!DEX_PV "; GetControlTypeText(propNames(i).value)
            Else
                Print #1, "!DEX_PV "; element(propNames(i)).value
            End If
            i = i + 1
          Wend
        End If
    End If
      Print #1, "!DEX_END_" & propNameDex & "_PROPERTIES "
  End If
End Sub


Sub ExtractFormControls(frm As Object)
  Dim element
  Dim subelement
  
  For Each element In frm
      DoMyEvents
'      Print #1, "!DEX_BEGIN_QUERY_FIELD "; .name
'      Print #1, "!DEX_END_QUERY_FIELD"
    Call ExtractProperties(element.Properties, _
        element.name, _
        FormControlNegProperties, "FORM_CONTROLS", True)
      
    Ticks = Ticks + (element.Properties.count - FormControlNegPropertiesSize) * FormControlPropertiesTicks
    UpdateStatusOLD
  
  Next element

End Sub


Function GenerateSheet(outputSheetName As String, Optional oldWorkbookName As String = "", Optional fromRes As Boolean = False) As String
    
    Dim oxlwbook As Excel.Workbook
    Dim myFilename As String
    Dim i As Long
    If Len(oldWorkbookName) = 0 Then
        Workbooks.Add
        myFilename = ActiveWorkbook.name
    Else
        myFilename = oldWorkbookName
    End If
    
    Dim resFile As String
    resFile = gTranslation.GetLocalizedFile(ThisWorkbook.path & "\ACC-Res.xls")
    
    Application.DisplayAlerts = False
    If Len(oldWorkbookName) = 0 Then
        For i = ActiveWorkbook.Sheets.count To 2 Step -1
          ActiveWorkbook.Sheets(i).Delete
        Next i
        ActiveWorkbook.Sheets(i).name = "LeeresBlatt"
        If fromRes Then
          'Set oxlwbook = Workbooks.Open(ThisWorkbook.path & "\ACC-Res.xls", False, True, , "13d4a!Psw(7dd)=", , True)
          Set oxlwbook = Workbooks.Open(resFile, False, True, , "13d4a!Psw(7dd)=", , True)
          oxlwbook.Sheets(outputSheetName).Activate
          oxlwbook.Sheets(outputSheetName).Copy Workbooks(myFilename).Sheets(1)
          oxlwbook.Close False
          Set oxlwbook = Nothing
        Else
          ThisWorkbook.Sheets(outputSheetName & "Leer").Activate
          ThisWorkbook.Sheets(outputSheetName & "Leer").Copy Workbooks(myFilename).Sheets(1)
        End If
        ActiveWorkbook.Sheets(outputSheetName & "Leer").name = outputSheetName
        ActiveWorkbook.Sheets("LeeresBlatt").Delete
    Else
'        ActiveWorkbook.Sheets.Add after:=ActiveWorkbook.Sheets(ActiveWorkbook.Sheets.Count)
        If fromRes Then
          'Set oxlwbook = Workbooks.Open(ThisWorkbook.path & "\ACC-Res.xls", False, True, , "13d4a!Psw(7dd)=", , True)
          Set oxlwbook = Workbooks.Open(resFile, False, True, , "13d4a!Psw(7dd)=", , True)
          oxlwbook.Sheets(outputSheetName).Copy After:=Workbooks(myFilename).Sheets(Workbooks(myFilename).Sheets.count)
          oxlwbook.Close False
          Set oxlwbook = Nothing
        Else
          ThisWorkbook.Sheets(outputSheetName & "Leer").Copy After:=Workbooks(myFilename).Sheets(Workbooks(myFilename).Sheets.count)
        End If
        Workbooks(myFilename).Sheets(outputSheetName & "Leer").name = outputSheetName
    End If
    
    Application.DisplayAlerts = True

    Helpers.ACCreateHeaderAndFooter ActiveSheet
    GenerateSheet = myFilename
End Function

Sub GenerateEmptySheet(outputSheetName As String, Optional oldWorkbookName As String = "")
    
    Dim myFilename As String
    Dim i As Long
    If Len(oldWorkbookName) = 0 Then
        Workbooks.Add
        myFilename = ActiveWorkbook.name
    Else
        myFilename = oldWorkbookName
    End If
    Application.DisplayAlerts = False
    If Len(oldWorkbookName) = 0 Then
        For i = ActiveWorkbook.Sheets.count To 2 Step -1
          ActiveWorkbook.Sheets(i).Delete
        Next i
        ActiveWorkbook.Sheets(i).name = outputSheetName
    Else
        Dim oXLWsheet As Excel.Worksheet
        Set oXLWsheet = Workbooks(myFilename).Sheets.Add(Workbooks(myFilename).Sheets(1))
        oXLWsheet.name = outputSheetName
    End If
    
    Application.DisplayAlerts = True

    Helpers.ACCreateHeaderAndFooter ActiveSheet
End Sub

Sub SetStatus(st As String)
  m_Status = st
  ' ProgressForm.Status = "Building file"
  ' ProgressForm.Status.Refresh
End Sub

Function ReadGroups() As Boolean

  Set m_VarGroups = Nothing
  Set m_VarGroups = New Collection
  ReadGroups = False
  On Error GoTo errReadGroups
  
  Dim resFile As String
  resFile = gTranslation.GetLocalizedFile(ThisWorkbook.path & "\ACC-Res.xls")
  Dim oxlwbook As Excel.Workbook
  'Set oxlwbook = Workbooks.Open(ThisWorkbook.path & "\ACC-Res.xls", False, True, , "13d4a!Psw(7dd)=", , True)
  Set oxlwbook = Workbooks.Open(resFile, False, True, , "13d4a!Psw(7dd)=", , True)
  
  Dim y As Long
  y = 2
  Dim lastVarGroup As VarGroup
  
  Do While Not IsEmpty(oxlwbook.Sheets("Groups").Cells(y, 3)) Or _
           Not IsEmpty(oxlwbook.Sheets("Groups").Cells(y + 1, 3)) Or _
           Not IsEmpty(oxlwbook.Sheets("Groups").Cells(y + 2, 3))
    
    ' Neue Gruppe
    If Not IsEmpty(oxlwbook.Sheets("Groups").Cells(y, 1)) Then
      Set lastVarGroup = New VarGroup
      lastVarGroup.Init
      lastVarGroup.m_Name = oxlwbook.Sheets("Groups").Cells(y, 1)
      lastVarGroup.m_Type = oxlwbook.Sheets("Groups").Cells(y, 2)
      m_VarGroups.Add lastVarGroup
    End If
    
    If Not IsEmpty(oxlwbook.Sheets("Groups").Cells(y, 3)) Then
      Dim v As Var
      Set v = New Var
      v.m_Name = oxlwbook.Sheets("Groups").Cells(y, 3)
      v.m_Type = oxlwbook.Sheets("Groups").Cells(y, 4)
      v.m_Translation = oxlwbook.Sheets("Groups").Cells(y, 5)
      lastVarGroup.m_Vars.Add v
    End If
    
    y = y + 1
  Loop
  
  oxlwbook.Close False
  Set oxlwbook = Nothing
  ReadGroups = True
  Exit Function
errReadGroups:
End Function

Function GetVarGroup(name As String) As Long
  GetVarGroup = 0
  Dim item As VarGroup
  For Each item In m_VarGroups
    GetVarGroup = GetVarGroup + 1
    If item.m_Name = name Then Exit Function
  Next item
End Function

Sub ShowSysTable(td As TableDef, db As Database)

  If td.RecordCount = 0 Or td.Fields.count = 0 Then Exit Sub
  
  Dim i As Long
  Dim tableY As Long
  tableY = 2
  
  Dim item
  Dim x As Long
  On Error Resume Next
  ' ProgressForm.Status.Refresh
  If td.Updatable = True Then
    Dim rs As Recordset
    Set rs = db.OpenRecordset(td.name, dbOpenSnapshot)
    If Not rs.EOF Then
      GenerateEmptySheet td.name, m_ResultWorkbookName
      x = 1
      For Each item In td.Fields
        Workbooks(m_ResultWorkbookName).Sheets(td.name).Cells(1, x) = item.name
        x = x + 1
      Next item
      
      Dim cnt As Long
      cnt = 0
      Do While Not rs.EOF
        x = 1
        For Each item In rs.Fields
          Workbooks(m_ResultWorkbookName).Sheets(td.name).Cells(tableY, x).value = item.value
          x = x + 1
        Next item
        rs.MoveNext
        tableY = tableY + 1
        cnt = cnt + 1
        If cnt = 100 Then
          Workbooks(m_ResultWorkbookName).Sheets(td.name).Cells(tableY, 1).value = "..."
          Exit Do
        End If
      Loop
    End If
    rs.Close
    Set rs = Nothing
  End If
  
End Sub


Sub GetDefsAndResultsheets()
  On Error GoTo 0
  
  Dim oxlwbook As Excel.Workbook
  
  Dim resFile As String
  resFile = gTranslation.GetLocalizedFile(ThisWorkbook.path & "\ACC-Res.xls")
  'Set oxlwbook = Workbooks.Open(ThisWorkbook.path & "\ACC-Res.xls", False, True, , "13d4a!Psw(7dd)=", , True)
  Set oxlwbook = Workbooks.Open(resFile, False, True, , "13d4a!Psw(7dd)=", , True)
  Dim y As Long
  y = 2
  
  If Not StartedByTracker Then
    Application.DisplayAlerts = False
    Do While Not IsEmpty(oxlwbook.Sheets("Defs").Cells(y, 2))
      oxlwbook.Sheets(oxlwbook.Sheets("Defs").Cells(y, 2).value).Activate
      oxlwbook.Sheets(oxlwbook.Sheets("Defs").Cells(y, 2).value).Copy before:=Workbooks(m_ResultWorkbookName).Sheets(1)   ' After:=Workbooks(m_ResultWorkbookName).Sheets(Workbooks(m_ResultWorkbookName).Sheets.count)
      y = y + 1
    Loop
    Application.DisplayAlerts = True
  End If
  
  Dim c As Range
  'Set c = oxlwbook.Sheets("Defs").Cells.Find(What:="Definitionen", LookIn:=xlValues, LookAt:= _
  '      xlWhole, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=True)
  Set c = TranslationFindCells(oxlwbook.Sheets("Defs"), Array("Definitionen", "Definitions"), LookIn:=xlValues, LookAt:= _
        xlWhole, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=True)
  If Not c Is Nothing Then
    y = c.Row + 1
    Dim F As XLFld
    Do While Not IsEmpty(oxlwbook.Sheets("Defs").Cells(y, 1))
    
      Select Case oxlwbook.Sheets("Defs").Cells(y, 2)
        Case "Field"
          Set F = New XLFld
          F.Init oxlwbook.Sheets("Defs").Cells(y, 1)
          y = y + 1
          Do While Not IsEmpty(oxlwbook.Sheets("Defs").Cells(y, 3))
            Dim fv As XLFldVal
            Set fv = New XLFldVal
            fv.m_Value = CLng(oxlwbook.Sheets("Defs").Cells(y, 2).value)
            fv.m_Txt = oxlwbook.Sheets("Defs").Cells(y, 3).value
            F.m_Col.Add fv
            y = y + 1
          Loop
          m_Flds.Add F
      End Select
      y = y + 1
    Loop
  End If
  
  oxlwbook.Close False
  Set oxlwbook = Nothing
End Sub


Function CountReadable(ref) As Boolean
  On Error GoTo notReadable
  Dim i As Long
  i = ref.count
  CountReadable = True
  Exit Function
  
notReadable:
  CountReadable = False
End Function

Public Function AccessDBHasPassword(path As String) As Boolean
  Dim db As dao.Database
  
  If Dir(path) = "" Then
  'Return 0 if file does not exist
     AccessDBHasPassword = False
     Exit Function
  End If
  
  On Error GoTo errorline
  SaveSetting _
         appname:="Stromwerken", _
         Section:="AccessTracker", _
         Key:="IgnoreThisOne", _
         setting:="True"
  
'  Dim ws As Workspace
'  Set ws = DBEngine.Workspaces(0)
'  Set db = ws.OpenDatabase(Path)
'  ado.opendatanbase
'  db.Close
'  Set ws = Nothing




   Dim cn As Object
  
   
   ' Set the provider, open the database,
   'and create a new table called tblSequential.
   'Change "findseek.mdb" to "findseek.accdb" for Access 2007.
   'Change the Provider to "Microsoft.ACE.OLEDB.12.0" for
   'Access 2007 ACCDB databases.
   
  Set cn = CreateObject("ADODB.Connection")
  If theAccessScannerVersion >= 12 Then
    cn.Provider = "Microsoft.ACE.OLEDB.12.0"
  Else
    cn.Provider = "Microsoft.Jet.OLEDB.4.0"
  End If
  cn.Open "Data Source=" & path
'  cn.Open "Data Source=d:\development\Temp\ACCAnalyse.accdb"
  
  AccessDBHasPassword = False
  cn.Close
  Set cn = Nothing
  
  SaveSetting appname:="Stromwerken", Section:="AccessTracker", Key:="IgnoreThisOne", setting:="False"
  
  Exit Function

errorline:
      
  AccessDBHasPassword = True
  Set cn = Nothing
'  Set ws = Nothing
  SaveSetting appname:="Stromwerken", Section:="AccessTracker", Key:="IgnoreThisOne", setting:="False"
  Exit Function
End Function

Function GetAccessDBNoAutoexec(ByVal strMDBPath As String, pw As String) As Boolean


    On Error GoTo ErrHandler
    
    Dim TIdSrc As Long, TIdDest As Long
    Dim abytCodesSrc(0 To 255) As Byte
    Dim abytCodesDest(0 To 255) As Byte

    If (Len(Dir$(strMDBPath, vbNormal)) = 0) Then
        Err.Raise 53
    End If

    With m_App
        .Visible = True

        ' attach to process
        TIdSrc = GetWindowThreadProcessId( _
                            Application.hWnd, ByVal 0)
        TIdDest = GetWindowThreadProcessId( _
                            .hWndAccessApp, ByVal 0)
                
        If CBool(AttachThreadInput(TIdSrc, TIdDest, True)) Then
            Call SetForegroundWindow(.hWndAccessApp)
            Call SetFocusAPI(.hWndAccessApp)
            
            ' Set Shift state
            Call GetKeyboardState(abytCodesSrc(0))
            Call GetKeyboardState(abytCodesDest(0))
            abytCodesDest(VK_SHIFT) = 128
            Call SetKeyboardState(abytCodesDest(0))
        
            ' Open a mdb with Autoexec
            SaveSetting appname:="Stromwerken", Section:="AccessTracker", Key:="IgnoreThisOne", setting:="True"
            Call .OpenCurrentDatabase(strMDBPath, True, pw)
            
            ' Revert back keyboard state
            Call SetKeyboardState(abytCodesSrc(0))
        End If
        ' release
        Call AttachThreadInput(TIdSrc, TIdDest, False)
        Call SetForegroundWindow(Application.hWnd)
        Call SetFocusAPI(Application.hWnd)
        
    End With
    GetAccessDBNoAutoexec = True

    Exit Function
ErrHandler:
    If Not StartedByTracker Then
      'MsgBox "Err: " & Err.Description
      MsgBox FMT1("CHECK_50", Err.Description)
      If (TIdDest) Then Call AttachThreadInput(TIdSrc, TIdDest, False)
      Call SetForegroundWindow(Application.hWndAccessApp)
      With Err
          .Raise .Number, .Source, .Description, .HelpFile, .HelpContext
      End With
    Else
      'AddStatus "FEHLER: " & Err.Description
      AddStatus FMT1("CHECK_51", Err.Description)
    End If
    
End Function


Function OpenAnalyzeDB(ByVal fname As String, ByVal oriname As String) As Boolean
    On Error GoTo noOpen

    Dim pw As String
    If AccessDBHasPassword(fname) Then
      XLScriptAddSimpleVar "STATUS", "Datei Passwortgesch|fffd|tzt"
      XLScriptAddSimpleVar "STATUSID", "5"
      If StartedByTracker Then
        'AddStatus "*** Die Datenbank ist mit einem Datei-|fffd|ffnen-Passwort gesch|fffd|tzt und kann deshalb nicht analysiert werden!"
        'AddStatus FMT0("CHECK_44")
        'Exit Function
        pw = GetFilePassword(oriname, 1)
      
      Else
        'pw = InputBox("Die Datenbank ist mit einem Datei-|fffd|ffnen-Passwort gesch|fffd|tzt. Bitte geben Sie das Passwort ein", "Access-Checker")
        pw = InputBox(FMT0("CHECK_45"), FMT0("MAIN_1"))
      End If
    End If

    OpenAnalyzeDB = GetAccessDBNoAutoexec(fname, pw)
    Exit Function
    
noOpen:
  XLScriptAddSimpleVar "STATUS", "Datei Passwortgesch|fffd|tzt"
  XLScriptAddSimpleVar "STATUSID", "1"
  Dim errstr As String
'    errstr = "Error (" & ProgressForm.Status & ") Object: " & CurrentObject & " - " & Err.Description & "(ErrNr: " & Err.Number & ")"
  'errstr = "Error: (" & m_Status & ") Object: " & CurrentObject & " - " & Err.Description & "(ErrNr: " & Err.Number & ")"
  errstr = FMT4("CHECK_24", m_Status, CurrentObject, Err.Description, Err.Number)
  XLScriptAddLogEntry errstr
  OpenAnalyzeDB = False

End Function



' Function OpenAnalyzeDBOLD() As Boolean
'   On Error GoTo noOpen
'   m_App.OpenCurrentDatabase m_AccFilename ', False, adminPW
'  OpenAnalyzeDBOLD = True
'  Exit Function
'noOpen:
'  Dim errstr As String
'  errstr = "Error: (" & m_Status & ") Object: " & CurrentObject & " - " & Err.Description & "(ErrNr: " & Err.Number & ")"
'  XLScriptAddLogEntry errstr
'  OpenAnalyzeDBOLD = False
'End Function

Function ConnectExists(connectstring As String) As Boolean
  On Error GoTo doesntExist
  Dim tcs As String
  
  tcs = GetConnectDB(connectstring)
  Dim s As String
  s = m_ConnectedDBs(tcs)
  ConnectExists = True
  Exit Function
doesntExist:
  ConnectExists = False
  m_ConnectedDBs.Add tcs, tcs
  Dim xlsarr As XLScriptArray
  Set xlsarr = XLScriptGetArray("CONNECTEDDBS")
  xlsarr.AddValue "", tcs
End Function

Function GetConnectDB(txt As String)
  Dim pos As Long
  GetConnectDB = txt
  pos = InStr(txt, ";DATABASE=")
  If pos <= 0 Then Exit Function
  GetConnectDB = Mid(txt, pos + 10)
End Function

Sub GetFlags(n As String, _
            ByRef lngExecute As Long, _
            ByRef lngReadDef As Long, _
            ByRef lngWritedef As Long, _
            ByRef lngReadData As Long, _
            ByRef lngUpdateData As Long, _
            ByRef lngDeleteData As Long, _
            ByRef lngInsertData As Long, _
            ByRef lngDBAdmin As Long, _
            ByRef lngDBExclusive As Long)
  
          lngExecute = -1
          lngReadDef = -1
          lngWritedef = -1
          lngReadData = -1
          lngUpdateData = -1
          lngDeleteData = -1
          lngInsertData = -1
          lngDBAdmin = -1
          lngDBExclusive = -1
          
          Select Case n
            Case "Databases"
              lngExecute = 2 'dbSecDBOpen
              lngDBAdmin = 8 'dbSecDBAdmin
              lngDBExclusive = 4 ' dbSecDBExclusive

            Case "Forms", "Reports"
              lngExecute = 256 ' acSecFrmRptExecute
              lngReadDef = 4 ' acSecFrmRptReadDef
              lngWritedef = 65548 ' acSecFrmRptWriteDef

            Case "Tables", "Queries"
              lngReadDef = 4 ' dbSecReadDef
              lngWritedef = 65548 'dbSecWriteDef
              lngReadData = 20 ' dbSecRetrieveData
              lngUpdateData = 64 ' dbSecReplaceData
              lngInsertData = 32 ' dbSecInsertData
              lngDeleteData = 128 ' dbSecDeleteData 'DbSecDeleteData

            Case "Modules"
              lngReadDef = 2 ' acSecModReadDef
              lngWritedef = 65542 ' acSecModWriteDef

            Case "Macros", "Scripts"
              lngReadDef = 10 ' acSecMacReadDef
              lngWritedef = 65542 ' acSecMacWriteDef
              lngExecute = 8 ' acSecMacExecute

          End Select
End Sub

Sub StatusFormUpdate()
  StatusForm.VergangeneZeit.Caption = Format(Now() - StartTime, "hh:ss")
  SetLiveStatus
End Sub

Function AccAppHasProperty(ByRef app As Object, ByVal keyname As String)
    Dim s As String
    On Error GoTo nogo
    s = CStr(app.CurrentDb.Properties(keyname).value)
    AccAppHasProperty = True
    Exit Function
nogo:
    AccAppHasProperty = False
End Function

Function GetDocProp(ByRef dbs As Object, ByVal txt As String) As String

    Dim prp As dao.Property
    Const conPropNotFoundError = 3270
 
    ' Datenbank holen
    On Error GoTo Change_Bye
    If txt = "Creation date" Then
      GetDocProp = dbs.Containers("Databases").Documents("SummaryInfo").Properties("DateCreated")
    Else
      GetDocProp = dbs.Containers("Databases").Documents("SummaryInfo").Properties(txt)
    End If
    
    ' dbs.Properties(txt)
 
Change_Bye:
    Exit Function

End Function


Sub LogPrint(ByVal str As String, Optional ByVal dur As Double = 0)
  If G_LogEnabled Then
    If G_cfgLogpfad = "" Then
      AddTextToFile Now() & "; " & Chr(34) & str & Chr(34), ThisWorkbook.path & "\ACC-Log-" & GetUserName & ".txt"
    Else
      AddTextToFile Now() & "; " & Chr(34) & str & Chr(34), G_cfgLogpfad & "\ACC-Log-" & GetUserName & ".txt"
    End If
  End If

  If Not StartedByTracker Then
    If m_ResultWorkbookName <> "" Then
      Workbooks(m_ResultWorkbookName).Sheets("Log").Cells(m_LogY, 1) = str
      m_LogY = m_LogY + 1
    End If
  End If
End Sub


Public Sub PrintTabellen(ByRef ws As Worksheet, y As Long, x As Long)
  Dim cnt As Long
  Dim td As TableDef
  Dim MyLastTime As Date
  With ws
      MyLastTime = Now
      cnt = 0
      For Each td In m_DB.TableDefs
      
        If MyLastTime + TimeValue("0:00:02") < Now Then
          'UpdateStatus "Generiere Ergebnisbatt " & ws.name & " - " & cnt & " / " & m_DB.TableDefs.count
          UpdateStatus FMT3("CHECK_46", ws.name, cnt, m_DB.TableDefs.count)
          MyLastTime = Now
        End If
        If Beenden Then Exit Sub
        If (td.Attributes And &H80000002) = 0 Then
              
      '        if td.Attributes
              
              .Cells(y, x) = CStr(td.name)
              
              If PropertyNameExists(td.Properties, "DESCRIPTION") Then
                .Cells(y, x + 1) = "'" & td.Properties("DESCRIPTION")
              Else
                .Cells(y, x + 1) = "'-/-"
              End If
              
              With ws.Range(.Cells(y, x + 1), .Cells(y, x + 5))
          '      .HorizontalAlignment = xlCenterAcrossSelection
          '      .VerticalAlignment = xlTop
          '      .WrapText = True
              End With
              y = y + 1
              Dim fld As Field
              For Each fld In td.Fields
                .Cells(y, x + 3) = fld.name
                
                With .Cells(y, x + 3).Font
                    .FontStyle = "Bold"
                    .ColorIndex = 3
                End With
                
                
                If PropertyNameExists(fld.Properties, "DESCRIPTION") Then
                  .Cells(y, x + 4) = "'" & fld.Properties("DESCRIPTION")
                Else
                  .Cells(y, x + 4) = "'-/-"
                End If
                
                
          '      With ws.Range(.Cells(y, x + 4), .Cells(y, x + 9))
          '        .HorizontalAlignment = xlCenterAcrossSelection
          '        .VerticalAlignment = xlTop
          '        .WrapText = True
          '      End With
                y = y + 1
                .Cells(y, x + 3) = "Attribute"
                With .Cells(y, x + 3).Font
                    .FontStyle = "Bold"
                End With
          
                DoPrintBitfieldExt CStr(fld.Attributes), "AttributesField", ", ", .Cells(y, x + 5)
                y = y + 1
                
                Dim prop As Property
                Dim tx As Long
                tx = 0
                For Each prop In fld.Properties
                  .Cells(y, x + 3 + tx) = prop.name
                  .Cells(y, x + 4 + tx).WrapText = True
                  .Cells(y, x + 4 + tx) = "'" & GetPropertyValue(prop)
                  tx = tx + 2
                  If tx = 6 Then
                    tx = 0
                    y = y + 1
                  End If
                Next prop
                If tx = 6 Then
                  y = y + 1
'                  Rows("42:42").EntireRow.AutoFit
                Else
                  y = y + 2
                End If
              
              Next fld
        End If
        cnt = cnt + 1
      Next td
  End With
  'UpdateStatus "Generiere Ergebnisbatt " & ws.name & " - " & cnt & " / " & m_DB.TableDefs.count
  UpdateStatus FMT3("CHECK_46", ws.name, cnt, m_DB.TableDefs.count)
End Sub

Function GetPropertyValue(ByRef p As Property)
  On Error Resume Next
  GetPropertyValue = "-/-"
  GetPropertyValue = p.value
End Function

Attribute VB_Name = "CheckinStuff"
Option Explicit

#If VBA7 Then
Declare PtrSafe Sub SWCompressFile Lib "SWPacker.dll" (ByVal a As String, ByVal Level As Integer)
Declare PtrSafe Sub SWDecompressFile Lib "SWPacker.dll" (ByVal a As String)
Declare PtrSafe Sub SWTest Lib "SWPacker.dll" ()
Private Declare PtrSafe Function FreeLibrary Lib "kernel32" (ByVal hLibModule As Long) As Long
Private Declare PtrSafe Function LoadLibrary Lib "kernel32" Alias "LoadLibraryA" (ByVal lpLibFileName As String) As Long
#Else
Declare Sub SWCompressFile Lib "SWPacker.dll" (ByVal a As String, ByVal Level As Integer)
Declare Sub SWDecompressFile Lib "SWPacker.dll" (ByVal a As String)
Declare Sub SWTest Lib "SWPacker.dll" ()
Private Declare Function FreeLibrary Lib "kernel32" (ByVal hLibModule As Long) As Long
Private Declare Function LoadLibrary Lib "kernel32" Alias "LoadLibraryA" (ByVal lpLibFileName As String) As Long
#End If

Function CheckInFile(ByRef rs As Object, checkindat As Date) As Boolean

On Error GoTo nogo

  Dim logtrack As Long
  logtrack = 0

  CheckInFile = False
  
  If Len(G_cfgTemppfad) > 0 Then
      logtrack = 1
      
      'erst mal alte killen falls vorhanden
      If FileExists(G_cfgTemppfad & "\" & rs.Fields("Hash").value) Then
          logtrack = 2
          MyKill G_cfgTemppfad & "\" & rs.Fields("Hash").value
          logtrack = 3
          If FileExists(G_cfgTemppfad & "\" & rs.Fields("Hash").value) Then
            logtrack = 4
            ' DebugPrint DebType.tERROR, "Tempor|fffd|re Datei f|fffd|r '" & rs.Fields("Dateiname").Value & "' nicht gel|fffd|scht(1)"
            ' MsgBox "FEHLER: Die tempor|fffd|re Datei '" & G_cfgTemppfad & "\" & rs.Fields("Hash").Value & "' konnte nicht gel|fffd|scht werden. Bitte informieren Sie Ihre Administration!", vbCritical + vbSystemModal, ProgNameLong & " " & MyVersion
            'AddStatus "FEHLER: Die tempor|fffd|re Datei '" & G_cfgTemppfad & "\" & rs.Fields("Hash").value & "' konnte nicht gel|fffd|scht werden. Bitte informieren Sie Ihre Administration!"
            AddStatus FMT2("CHECKIN_1", G_cfgTemppfad, rs.Fields("Hash").value)
            Exit Function
          End If
          logtrack = 5
      End If
      
      logtrack = 6
      If Not PathExists(G_cfgTemppfad) Then
        ' DebugPrint DebType.tERROR, "CheckInFile: TempPathMissing '" & rs.Fields("Dateiname").Value & "'"
        'AddStatus "FEHLER: Der tempor|fffd|re Pfad existiert nicht '" & rs.Fields("Dateiname").value & "'"
        AddStatus FMT1("CHECKIN_2", rs.Fields("Dateiname").value)
        Exit Function
      End If
      CopyFile rs.Fields("Dateiname").value, G_cfgTemppfad & "\" & rs.Fields("Hash").value, 0
      logtrack = 7

      If FileExists(G_cfgTemppfad & "\" & rs.Fields("Hash").value) Then
          logtrack = 8
          If Not xlCheckInBinary(rs.Fields("idvDateiID").value, rs.Fields("Version").value, checkindat, G_cfgTemppfad & "\" & rs.Fields("Hash").value) Then
            ' DebugPrint DebType.tdebug, "Die Datei '" & rs.Fields("Dateiname").Value & "' konnte nicht eingecheckt werden"
            ' MsgBox "Die Datei konnte nicht auf dem Datenbankserver eingecheckt werden! Bitte versuchen Sie es sp|fffd|ter noch einmal!", vbCritical + vbSystemModal, ProgNameLong & " " & MyVersion
            'AddStatus "FEHLER: Die Datei '" & rs.Fields("Dateiname").value & "' konnte nicht eingecheckt werden"
            AddStatus FMT1("CHECKIN_3", rs.Fields("Dateiname").value)
          End If
          logtrack = 9
          MyKill G_cfgTemppfad & "\" & rs.Fields("Hash").value
          
          If FileExists(G_cfgTemppfad & "\" & rs.Fields("Hash").value) Then
            ' DebugPrint DebType.tdebug, "Tempor|fffd|re Datei f|fffd|r '" & rs.Fields("Dateiname").Value & "' nicht gel|fffd|scht(2)"
            ' MsgBox "FEHLER: Die tempor|fffd|re Datei '" & G_cfgTemppfad & "\" & rs.Fields("Hash").Value & "' konnte nicht gel|fffd|scht werden. Bitte informieren Sie Ihre Administration!", vbCritical + vbSystemModal, ProgNameLong & " " & MyVersion & " (Build: " & app.Major & "-" & app.Minor & "-" & app.Revision & ")"
          End If

          logtrack = 19
          CheckInFile = True
          Exit Function
      Else
        ' DebugPrint DebType.tERROR, "CheckInFile: No checkin (" & logtrack & "): " & rs.Fields("Dateiname").Value
        ' MsgBox "FEHLER: Die Datei konnte nicht in den tempor|fffd|ren Pfad kopiert werden! Die Datei kann nicht eingecheck werden! Bitte informieren Sie die Administration!", vbCritical + vbSystemModal, ProgNameLong & " " & MyVersion & " (Build: " & app.Major & "-" & app.Minor & "-" & app.Revision & ")"
        'AddStatus "FEHLER: Die Datei konnte nicht in den tempor|fffd|ren Pfad kopiert werden! Die Datei kann nicht eingecheck werden! Bitte informieren Sie die Administration!"
        AddStatus FMT0("CHECKIN_4")
      End If
  Else
    ' DebugPrint DebType.tERROR, "CheckInFile: No checkin (" & logtrack & "): " & rs.Fields("Dateiname").Value
    ' MsgBox "FEHLER: Es ist kein tempor|fffd|rer Pfad konfiguriert! Die Datei kann nicht eingecheck werden! Bitte informieren Sie die Administration!", vbCritical + vbSystemModal, ProgNameLong & " " & MyVersion & " (Build: " & app.Major & "-" & app.Minor & "-" & app.Revision & ")"
    'AddStatus "FEHLER: Es ist kein tempor|fffd|rer Pfad konfiguriert! Die Datei kann nicht eingecheck werden! Bitte informieren Sie die Administration!"
    AddStatus FMT0("CHECKIN_5")
  End If
  
  Exit Function
nogo:
  ' DebugPrint DebType.tERROR, "CheckInFile:" & logtrack
  ' MsgBox "FEHLER: Die Datei '" & rs.Fields("Dateiname").Value & "' kann nicht eingecheck werden!" & Err.Number & " - " & Err.Description & " - " & Err.Source, vbCritical + vbSystemModal, ProgNameLong & " " & MyVersion & " (Build: " & app.Major & "-" & app.Minor & "-" & app.Revision & ")"
  'AddStatus "FEHLER: Die Datei '" & rs.Fields("Dateiname").value & "' kann nicht eingecheck werden!" & Err.Number & " - " & Err.Description & " - " & Err.Source
  AddStatus FMT4("CHECKIN_6", rs.Fields("Dateiname").value, Err.Number, Err.Description, Err.Source)
End Function

Public Function PackFile(ByVal Filename As String, ByVal copyToTemp As Boolean) As String
    On Error GoTo fehlerPackFile
    
    PackFile = ""
    Dim tempFilename As String
    If copyToTemp Then
        tempFilename = GetFileNameAndPath(CreateTempFile("Tmp")) & GetFileName(Filename)
        CopyFile Filename, tempFilename
    Else
        tempFilename = Filename
    End If
    PackFile = tempFilename

    ' 57 = '0'+9, wird als Ziffer von SWCompressFile in einen String geschrieben
    If FileExists(tempFilename) Then
      Dim lb As Long, pa As Long
      lb = LoadLibrary(ThisWorkbook.path & "\..\bin\SWPacker.dll")
      If lb <> 0 Then
        SWCompressFile tempFilename, 50
        ' MsgBox "Datei gepackt!"
        PackFile = tempFilename + ".gz"
        FreeLibrary lb
      End If
    End If
    
    ' es wurde gepackt und die TempDatei wurde auch oben durch Kopieren erstellt
    ' dann m|fffd|ssen wir die hier wieder l|fffd|schen
    If PackFile <> tempFilename And copyToTemp = True Then
        MyKill tempFilename
    End If
    Exit Function
fehlerPackFile:
On Error GoTo rausAusFunktion
    If lb <> 0 Then
      FreeLibrary lb
    End If
    If PackFile <> tempFilename And copyToTemp = True Then
        MyKill tempFilename
    End If
rausAusFunktion:
End Function

Public Function GetSplitSize() As Long
    ' ab welcher Gr|fffd||fffd|e legen wir mehrere Eintr|fffd|ge in der xlBin Blobs an,
    ' damit wir bei gro|fffd|en Dateien kein OutOfMemory bekommen
    GetSplitSize = CLng(1024) * CLng(1024) * CLng(16)
End Function


Public Function xlCheckInBinary(ByVal idvDateiID As Long, ByVal Version As Long, ByVal dat As Date, ByVal fname As String) As Boolean
        On Error GoTo fehler
        
        Dim cn As Object

        Set cn = GetConnection()

        If cn Is Nothing Then Exit Function
        
        ' Erst mal eine eventuell bereits eingecheckte Datei rauswerfen!
        ' !!!! nicht mehr direkt |fffd|ber xlBin l|fffd|schen sondern |fffd|ber den xlBinUpdate View
        ' ansonsten geht das nicht mit dem Security Zeugs
        ' cn.Execute "DELETE FROM xlBin WHERE idvDateiID = " & idvDateiID & " and Version = " & Version
        cn.Execute "DELETE FROM A_XLBINUPDATE WHERE idvDateiID = " & idvDateiID & " and Version = " & Version

        Dim rs As Object
        ' !!!! hier jetzt |fffd|ber den neuen View f|fffd|r die xlBins gehen
        ' ansonsten bekommt man keinen Recordset zur|fffd|ck
        ' Set rs = OpenRS("SELECT * FROM xlBin where xlBinID = -1", cn, MYadOpenDynamic, MYadLockOptimistic)
        Set rs = OpenRS("SELECT * FROM A_XLBINTMEINEOES WHERE xlBinID = -1", cn, MYadOpenDynamic, MYadLockOptimistic)
        
        If rs Is Nothing Then
            cn.Close
            Set cn = Nothing
          xlCheckInBinary = False
          Exit Function
        End If
        
        Dim zippedFilename As String
        zippedFilename = PackFile(fname, True)

        Dim splitFilenames() As String
        Dim step As Long
        If (SplitFile(zippedFilename, GetSplitSize(), splitFilenames)) Then
        Else
            ReDim splitFilenames(0)
            splitFilenames(0) = zippedFilename
        End If
        
        For step = LBound(splitFilenames) To UBound(splitFilenames)
            rs.AddNew
            rs.Fields("idvDateiID").value = idvDateiID
            rs.Fields("Version").value = Version
            rs.Fields("Datum").value = dat
            rs.Fields("Compressed").value = IIf(Right(zippedFilename, 3) = ".gz", 1, 0)
            rs.Fields("Step").value = step
    
            If Not CheckInBinary("Binary", rs, splitFilenames(step)) Then
              rs.CancelUpdate
              xlCheckInBinary = False
              Exit For
            Else
              rs.Update
              
              xlCheckInBinary = True
            End If
        Next
        rs.Close
        Set rs = Nothing
        LogPrint "xlCheckInBinary-3"
        
        If zippedFilename <> fname Then
            MyKill zippedFilename
        End If
        For step = LBound(splitFilenames) To UBound(splitFilenames)
            If splitFilenames(step) <> fname Then
                MyKill splitFilenames(step)
            End If
        Next
        LogPrint "xlCheckInBinary-Finished"
        Exit Function
fehler:
'        If Not rs Is Nothing Then
'          rs.Close
          Set rs = Nothing
'        End If
        If Not cn Is Nothing Then
          cn.Close
          Set cn = Nothing
        End If
        xlCheckInBinary = False
End Function

Private Function CheckInBinary(ByVal fieldName As String, ByRef rs As Object, ByVal fname As String) As Boolean

        On Error GoTo fehler
        Dim Doc As Object
        Set Doc = CreateObject("ADODB.Stream")
        With Doc
            .Type = 1
            .Open
            .LoadFromFile fname
        End With
        rs.Fields(fieldName).value = Doc.Read
        CheckInBinary = True
        Exit Function

fehler:
End Function
Attribute VB_Name = "CommStuff"
Option Explicit

Sub StoreComm(ison As Boolean)
  On Error Resume Next
  
  If G_Conn Is Nothing Then Exit Sub
  
  Dim rsACCScan As Object
  Dim count As Long
  
  Set rsACCScan = OpenRS("select Count(idvDateiId) as count from ACCScan", G_Conn, MYadOpenDynamic, MYadLockReadOnly)
  count = rsACCScan.Fields("count").value
  rsACCScan.Close
  
  Set rsACCScan = OpenRS("select * FROM gCommunicate WHERE Interface = 'ACC'", G_Conn, MYadOpenDynamic, MYadLockOptimistic)
  If Not rsACCScan Is Nothing Then
    If rsACCScan.EOF Then
      rsACCScan.AddNew
      rsACCScan.Fields("Interface").value = "ACC"
    End If
    rsACCScan.Fields("COMM").value = "SCAN=" & IIf(ison, "ON", "OFF") & vbCrLf & "RESTSCAN=" & count & vbCrLf & "DATE=" & Now & vbCrLf & "FILENAME=" & theFilename
    rsACCScan.Update
    rsACCScan.Close
    Set rsACCScan = Nothing
  End If

End Sub

Sub StoreUserCommunicateValue(prefix As String, s As String)

  On Error Resume Next
  
  If G_Conn Is Nothing Then Exit Sub
  
  Dim rsACCScan As Object
  Dim count As Long
  
  Set rsACCScan = OpenRS("select * FROM gCommunicate WHERE Interface = '" & prefix & "-" & GetUserName & "'", G_Conn, MYadOpenDynamic, MYadLockOptimistic)
  If Not rsACCScan Is Nothing Then
    If rsACCScan.EOF Then
      rsACCScan.AddNew
      rsACCScan.Fields("Interface").value = prefix & "-" & GetUserName
    End If
    rsACCScan.Fields("COMM").value = s
    rsACCScan.Update
    rsACCScan.Close
    Set rsACCScan = Nothing
  End If

End Sub


Attribute VB_Name = "DBStuff"
Option Explicit

Public G_DBUser As String
Public G_DBUserPasswort As String
Public G_cfgConnectVia As String


Function GetConnection(Optional ByVal waitendless As Boolean = False) As Object

    Dim conn
    Set conn = CreateObject("ADODB.Connection")
    If G_Cursorlocation <> 2 And G_Cursorlocation <> 3 Then
      G_Cursorlocation = 3
    End If
    conn.CursorLocation = G_Cursorlocation
    On Error Resume Next

    Set GetConnection = Nothing
    Dim cnt As Long
    cnt = 0
checkAgain:
    If G_cfgConnectVia = "ODBCDSN" Or G_DBConnectionString = "" Then
      conn.Open "IDV-Tracker", G_DBUser, G_DBUserPasswort
    Else
      conn.Open G_DBConnectionString, G_DBUser, G_DBUserPasswort
    End If
    If Err.Number <> 0 Then
        Debug.Print Err.Description
        Err.Clear
        Sleep 50
        cnt = cnt + 1
        If Not waitendless Then
            If cnt >= 100 Then
                conn = Nothing
                Exit Function
            End If
            GoTo checkAgain
        End If
    End If

    Set GetConnection = conn

End Function


Sub GetDBUser()
    
    G_DBUser = "IDVTTECHUSER"
    G_DBUserPasswort = "12SD3Ax$!d7%fd/"
    
    Dim cfg As CfgReader
    Set cfg = New CfgReader
    
    If FileExists(ThisWorkbook.path & "\IDV-Suite.cfg") = True Or FileExists(ThisWorkbook.path & "\..\cfg\IDV-Suite.cfg") = True Or _
        FileExists(ThisWorkbook.path & "\..\..\IDV-Suite-Plugins\cfg\IDV-Suite.cfg") = True Or _
        FileExists(ThisWorkbook.path & "\IDV-Suite.cfg") = True Then
        
        If FileExists(ThisWorkbook.path & "\IDV-Suite.cfg") = True Then
          cfg.GetCFG (ThisWorkbook.path & "\IDV-Suite.cfg")
        ElseIf FileExists(ThisWorkbook.path & "\..\cfg\IDV-Suite.cfg") = True Then
          cfg.GetCFG (ThisWorkbook.path & "\..\cfg\IDV-Suite.cfg")
        ElseIf FileExists(ThisWorkbook.path & "\..\..\IDV-Suite-Plugins\cfg\IDV-Suite.cfg") = True Then
          cfg.GetCFG (ThisWorkbook.path & "\..\..\IDV-Suite-Plugins\cfg\IDV-Suite.cfg")
        ElseIf FileExists(ThisWorkbook.path & "\IDV-Suite.cfg") = True Then
          cfg.GetCFG (ThisWorkbook.path & "\IDV-Suite.cfg")
        End If

        Dim s As String
        If cfg.GetSection("DB") = True Then
            s = cfg.GetValue("USER")
            If s <> "" Then
                G_DBUser = Crypt(s, "uIq2%7/=}pJIi39x?", False)
            End If
            s = cfg.GetValue("PASSWORD")
            If s <> "" Then
                G_DBUserPasswort = Crypt(s, "uIq2%7/=}pJIi39x?", False)
            End If
        End If

    End If
End Sub


Function Crypt(Inp As String, Key As String, Mode As Boolean) As String
    Dim z As String
    Dim i As Integer, Position As Integer
    Dim cptZahl As Long, orgZahl As Long
    Dim keyZahl As Long, cptString As String
    
    For i = 1 To Len(Inp)
            Position = Position + 1
            If Position > Len(Key) Then Position = 1
            keyZahl = Asc(Mid(Key, Position, 1))
            
            If Mode Then
            
                'Verschl|fffd|sseln
                orgZahl = Asc(Mid(Inp, i, 1))
                cptZahl = orgZahl Xor keyZahl
                cptString = Hex(cptZahl)
                If Len(cptString) < 2 Then cptString = "0" & cptString
                z = z & cptString
            
            Else
            
                'Entschl|fffd|sseln
                If i > Len(Inp) \ 2 Then Exit For
                cptZahl = CByte("&H" & Mid$(Inp, i * 2 - 1, 2))
                orgZahl = cptZahl Xor keyZahl
                z = z & Chr$(orgZahl)
            
            End If
        Next i
     
        Crypt = z
End Function




Sub WBRemoveTags()

    Dim nameItem As Excel.name

GoAgain:
    Dim i As Long
    If ThisWorkbook.names.count > 0 Then
      For i = 1 To ThisWorkbook.names.count
          If ThisWorkbook.names(i).Visible = False Then
              If Left(ThisWorkbook.names(i).name, Len("_IDVTracker")) = "_IDVTracker" Then
                  ThisWorkbook.names.item(i).Delete
                  GoTo GoAgain
              End If
          End If
      Next i
    End If

End Sub


Function DBFieldItemExists(ByRef rs As Object, fieldName As String) As Boolean
  On Error GoTo nogo
  Dim s As String
  s = rs.Fields(fieldName).name
  DBFieldItemExists = True
  Exit Function
nogo:
End Function
Attribute VB_Name = "DebugStuff"
Option Explicit

Enum DebType
    tERROR = 1
    tInfo = 2
    tTime = 3
    tdebug = 4
    tMail = 5
    tSystem = 6
    tToFile = 7
End Enum

Public G_PARAM_DebugInfosLoggen As Boolean
Public G_IgnoreFutureWriteWindows As Boolean

Public G_LogThisUser As Boolean
Public G_PARAM_CollectDebug As Boolean

Public G_LogToWindow As Boolean
Public G_LogWriteIgnore As Boolean

Private L_InDebugPrint As Boolean


Public Const G_LOG_EXTERNE_KOPIE As Long = 1              ' Die Datei wurde durch eine andere Datei au|fffd|erhalb des IDV-Tracker-Systems |fffd|berschrieben. Wahrscheinlich hat der User eine Datei mit dem Explorer |fffd|ber die Originaldatei kopiert.
Public Const G_LOG_NEUE_FREIGABE_ENTFERNT As Long = 2     ' F|fffd|r die Datei wurde eine neue Version erzeugt. Dadurch wurde die Programmfreigabe aufgehoben.
Public Const G_LOG_NEUE_VERSION As Long = 3               ' F|fffd|r die Datei wurde eine neue Version erzeugt.
Public Const G_LOG_BLATSCHUTZ_ENTFERNEN_INIT As Long = 4  ' Blattschutz-Entfernung initiiert
Public Const G_LOG_BLATTSCHUTZ_ENTFERNT As Long = 5       ' Blattschutz entfernt
Public Const G_LOG_BLATTSCHUTZ_ANGEBRACHT As Long = 6     ' Blattschutz angebracht

Private Sub SetConnectTimeout(ByRef conn)
  On Error Resume Next
  conn.Execute "SET LOCK_TIMEOUT 5000"
  conn.Properties("Jet OLEDB:Lock Delay") = 5000 ' 90 + Int(Rnd * 60)
  Err.Clear
End Sub

#If NOLOGTODB = 0 Then
Sub AddTextToLogDB(ByVal md As DebType, ByVal str As String, dur As Double, ByVal logExp As Long, ByVal idvDateiID As Long)
    
    On Error GoTo nogo
    
    Dim rs As Object
    Set rs = CreateObject("ADODB.Recordset")

    rs.Open "SELECT * FROM idvDateienEventLog WHERE EventTyp = -1", G_Conn, MYadOpenDynamic, MYadLockOptimistic
    
    If rs Is Nothing Then
      Exit Sub
    End If
    
    Do While Len(str) > 0
      rs.AddNew
      rs.Fields("EventTyp").value = md
      rs.Fields("EventLogErlaeuterungID").value = logExp
      rs.Fields("Datum").value = Now
      rs.Fields("Text").value = Left(str, 255)
      rs.Fields("Zeit").value = dur
      rs.Fields("AppID").value = MyAppID
      rs.Fields("idvDateiID").value = idvDateiID
      rs.Fields("userLogonId").value = Left(GetUserName, 24)
      rs.Update
      str = Mid(str, 255, 10000)
    Loop

nogo:
'    If Not rs Is Nothing Then
'      rs.Close
      Set rs = Nothing
'    End If
    


End Sub
#End If

Sub DebugPrint(ByVal md As DebType, ByVal str As String, Optional ByVal dur As Double = 0, Optional ByVal logExp As Long = 0, Optional ByVal idvDateiID As Long = 0, Optional logToECCSCanLog As Boolean = False)

    If L_InDebugPrint Then Exit Sub

    L_InDebugPrint = True
    
    ' Ausgabe f|fffd|r Debug-Window
    If md = DebType.tERROR Then
      If UCase(Right(ThisWorkbook.name, 1)) = "S" Then
        Debug.Print "ND: " & Now() & "; " & Chr(34) & "Err: " & str & Chr(34) & "; " & dur
      End If
'      If G_LogToWindow = True Then
'        frmLogWindow.LogText.Text = Right(frmLogWindow.LogText.Text & vbCrLf & "*** " & Now() & "; " & Chr(34) & "Err: " & str & Chr(34) & "; " & dur, 16000)
'        If Len(frmLogWindow.LogText.Text) > 0 Then
'          frmLogWindow.LogText.SelStart = Len(frmLogWindow.LogText.Text)
'        End If
'      End If
    Else
      If UCase(Right(ThisWorkbook.name, 1)) = "S" Then
        Debug.Print "ND: " & Now() & "; " & Chr(34) & str & Chr(34) & "; " & dur
      End If
'      If G_LogToWindow = True Then
'        frmLogWindow.LogText.Text = Right(frmLogWindow.LogText.Text & vbCrLf & Now() & "; " & Chr(34) & str & Chr(34) & "; " & dur, 16000)
'        If Len(frmLogWindow.LogText.Text) > 0 Then
'          frmLogWindow.LogText.SelStart = Len(frmLogWindow.LogText.Text)
'        End If
'      End If
    End If
    
'    If G_LogEnabled Then
'      If G_cfgLogpfad = "" Then
'        AddTextToFile Now() & "; " & Chr(34) & str & Chr(34), ThisWorkbook.path & "\ECC-Log-" & GetUserName & ".txt"
'      Else
'        AddTextToFile Now() & "; " & Chr(34) & str & Chr(34), G_cfgLogpfad & "\ECC-Log-" & GetUserName & ".txt"
'      End If
'    End If
    
    If StartedByTracker = True And UserAutomation = False Then
      If logToECCSCanLog Then
        If G_cfgLogpfad <> "" Then
          If FileExists(G_cfgLogpfad & "\IDV-Suite Scheduler-" & GetUserName & ".txt") Then
            AddTextToFile Now() & ",0, Typ: 7, ID: " & idvDateiID & "," & Chr(34) & str & Chr(34), G_cfgLogpfad & "\IDV-Suite Scheduler-" & GetUserName & ".txt"
          End If
        End If
      End If
    End If
    
'    If G_AllowLoggingToStorage Then
'        If md = 1 Or _
'            (md = 2 And (G_cfgDebugInfosLoggen = True Or (G_PARAM_DebugInfosLoggen = True And G_LogThisUser = True))) Or _
'            (md = 3 And (G_cfgDebugInfosLoggen = True Or (G_PARAM_DebugInfosLoggen = True And G_LogThisUser = True))) Or _
'            (md = 4 And (G_cfgDebugInfosLoggen = True Or (G_PARAM_DebugInfosLoggen = True And G_LogThisUser = True))) Or _
'             md = 5 Or _
'             md = 6 Then
'
'            If md = DebType.tError Then
'                AddTextToLogDB md, "Err: " & str, dur, logExp, idvDateiID
'            Else
'                AddTextToLogDB md, str, dur, logExp, idvDateiID
'            End If
'        End If
'    End If
    

    L_InDebugPrint = False

End Sub


Public Function AddTextToLogfile(ByVal strData As String, _
     ByVal fullpath As String, _
       Optional ByVal ErrInfo As String = "") As Boolean

    On Error GoTo CatchEx

    If G_LogWriteIgnore = True Then Exit Function
    
    Dim fn As Long
    Dim cnt As Long
    cnt = 0
    
    fn = FreeFile
    Dim s As String

GoAgain:

    If PathExists(GetPath(fullpath)) Then
      Do
        If FOpenAppend(fullpath, fn) Then
          Print #fn, strData
          Close fn
          AddTextToLogfile = True
          Exit Do
        Else
          Sleep 100
          cnt = cnt + 1
          If cnt >= 10 Then
            AddTextToLogfile = False
            G_LogWriteIgnore = True
            If Not G_IgnoreFutureWriteWindows Then
              'If MsgBox("ACHTUNG: Die Log-Datei kann nicht in '" & fullpath & "' gespeichert werden, vermutlich haben Sie keine Schreibrechte in diesem Ordner. Bitte informieren Sie die Administration. M|fffd|chten Sie, dass das Log in einem Fenster ausgegeben wird?", vbYesNo + vbCritical, ProgNameLong & " " & MyVersion) = vbYes Then
              If MsgBox(FMT1("DEBUGSTUFF_1", fullpath), vbYesNo + vbCritical, ProgNameLong & " " & MyVersion) = vbYes Then
                G_LogToWindow = True
                ' frmLogWindow.Caption = ProgNameLong & " " & MyVersion & " - Log..."
                ' frmLogWindow.Show vbModeless
                G_IgnoreFutureWriteWindows = True
              End If
            End If
            Exit Function
          End If
        End If
      Loop
    Else
      G_LogWriteIgnore = True
      'If MsgBox("ACHTUNG: Die Log-Datei kann nicht in '" & GetPath(fullpath) & "' gespeichert werden, der Pfad existiert nicht. Bitte informieren Sie die Administration. M|fffd|chten Sie, dass das Log in einem Fenster ausgegeben wird?", vbYesNo + vbCritical, ProgNameLong & " " & MyVersion) = vbYes Then
      If MsgBox(FMT1("DEBUGSTUFF_2", GetPath(fullpath)), vbYesNo + vbCritical, ProgNameLong & " " & MyVersion) = vbYes Then
        G_LogToWindow = True
        'frmLogWindow.Caption = ProgNameLong & " " & MyVersion & " - Log..."
'        frmLogWindow.Caption = ProgNameLong & " " & MyVersion & " - " & FMT0("DEBUGSTUFF_3")
'        frmLogWindow.Show vbModeless
      End If
    End If
    Exit Function

CatchEx:

End Function




Private Function FOpenAppend(fname As String, ByRef fn As Long) As Boolean
  On Error GoTo nogo
  Open fname For Append As fn
  FOpenAppend = True
  Exit Function
nogo:
        
End Function





Attribute VB_Name = "DieseArbeitsmappe"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Extractor"
Option Explicit

Private m_FName As String
Private m_Type As Long
Private m_Xlsv As XLScriptVar
Private m_Txt As String

Private Sub OverreadLine(ByRef codeValRet As String)
  On Error GoTo 0
  Dim i As Long
  i = 1
  Do While i < Len(codeValRet) And Mid(codeValRet, i, 1) <> vbCr And Mid(codeValRet, i, 1) <> vbLf
    i = i + 1
  Loop
  Do While i < Len(codeValRet) And (Mid(codeValRet, i, 1) = vbCr Or Mid(codeValRet, i, 1) = vbLf)
    i = i + 1
  Loop
  If i > 1 Then
    codeValRet = Mid(codeValRet, i)
  End If
End Sub

Private Function GetNextChar(ByRef codeValRet As String) As String
  On Error GoTo 0
  OverreadBlanks codeValRet
  If Len(codeValRet) > 0 Then
    GetNextChar = Left(codeValRet, 1)
    codeValRet = Mid(codeValRet, 2)
  End If
End Function

Private Sub OverreadBlanks(ByRef codeValRet As String)
  On Error GoTo 0
  Dim i As Long
  i = 1
  Do While Mid(codeValRet, i, 1) = " " Or Mid(codeValRet, i, 1) = vbCr Or Mid(codeValRet, i, 1) = vbLf
    i = i + 1
  Loop
  If i > 1 Then
    codeValRet = Mid(codeValRet, i)
  End If
End Sub

Private Function GetToken(ByRef codeValRet As String) As String
  On Error GoTo 0
  Dim token As String
  Dim i As Long
  i = 0
  OverreadBlanks codeValRet
  If Left(codeValRet, 1) = Chr(34) Then
    codeValRet = Mid(codeValRet, 2)
    Do While Mid(codeValRet, i + 1, 1) <> Chr(34) And i < Len(codeValRet)
      i = i + 1
    Loop
    If i > 0 Then
      token = Left(codeValRet, i)
      codeValRet = Mid(codeValRet, i + 1)
      If Left(codeValRet, 1) = Chr(34) Then
        codeValRet = Mid(codeValRet, 2)
      End If
      OverreadBlanks codeValRet
    End If
  Else
    If ((Mid(codeValRet, i + 1, 1) >= "a" And Mid(codeValRet, i + 1, 1) <= "z") Or _
      (Mid(codeValRet, i + 1, 1) >= "A" And Mid(codeValRet, i + 1, 1) <= "Z")) And i < Len(codeValRet) Then
      Do While ((Mid(codeValRet, i + 1, 1) >= "a" And Mid(codeValRet, i + 1, 1) <= "z") Or _
        (Mid(codeValRet, i + 1, 1) >= "A" And Mid(codeValRet, i + 1, 1) <= "Z") Or _
        (Mid(codeValRet, i + 1, 1) >= "0" And Mid(codeValRet, i + 1, 1) <= "9") Or _
         Mid(codeValRet, i + 1, 1) = "_" Or _
         Mid(codeValRet, i + 1, 1) = "|fffd|" Or _
         Mid(codeValRet, i + 1, 1) = "|fffd|" Or _
         Mid(codeValRet, i + 1, 1) = "|fffd|" Or _
         Mid(codeValRet, i + 1, 1) = "|fffd|" Or _
         Mid(codeValRet, i + 1, 1) = "|fffd|" Or _
         Mid(codeValRet, i + 1, 1) = "|fffd|" Or _
         Mid(codeValRet, i + 1, 1) = "|fffd|" _
         ) And i < Len(codeValRet)
        i = i + 1
      Loop
      If i > 0 Then
        token = Left(codeValRet, i)
        codeValRet = Mid(codeValRet, i + 1)
        OverreadBlanks codeValRet
      End If
    Else
      token = GetNextChar(codeValRet)
    End If
  End If
  
  GetToken = token
End Function


Sub TestFRead()
  Dim ttext As String
  ttext = pvReadFile("D:\development\Access-Checker\..\Temp\ACCExt-" & GetUserName & ".txt")
  
  Debug.Print ttext
End Sub

Sub Extract(ff As Integer, fname As String, typ As Long, ByRef xlsv As XLScriptVar, ByRef loc As Long, ByRef locomm As Long, ByRef checksum As Long, modName As String, ByRef xlsarr As XLScriptArray2D, txtExtension As String)
  
  m_FName = fname
  m_Type = typ
  Set m_Xlsv = xlsv
  
  If Not FileExists(fname) Then Exit Sub
  
'  Dim ff
'  ff = FreeFile
'  Open fname For Input As #ff
'  m_Txt = Input(MyFileLen(fname), #ff)
'  Close #ff
    
  m_Txt = pvReadFile(fname)
  
'  AddChecksum checksum, m_Txt
    
  m_Xlsv.Properties.Add m_Txt, "CODE"
  m_Txt = RemoveComments(m_Txt)
'  Debug.Print txt

  If m_Type = 4 Then ' acMacro
    ExtractMacro ff, loc, locomm, checksum, modName, xlsarr, txtExtension
  Else
    AddChecksum checksum, m_Txt, txtExtension & ".CODE", ff
  End If
  
End Sub

Sub ExtractMacro(ff As Integer, ByRef loc As Long, ByRef locomm As Long, ByRef checksum As Long, modName As String, ByRef xlsarr As XLScriptArray2D, txtExtension As String)
  Dim tok As String
  Dim tok2 As String
  Dim tTxt As String
  Do
    If Left(Trim(m_Txt), 5) = "Begin" Then Exit Do
    GetLine m_Txt
  Loop While Len(m_Txt) > 0
    
  Do While Len(m_Txt) > 0
        tok2 = Trim(GetLine(m_Txt))
        tTxt = tTxt & tok2 & vbCrLf
        
'        tChecksum = AddChecksum(checksum, tok2, txtExtension & ".CODE", ff)
        
        If tok2 = "Action =""OpenTable""" Then
          Dim txlsv As XLScriptVar
          Set txlsv = m_Xlsv.GetScriptVar("USES")
          Dim ref As XLScriptArray
          Set ref = txlsv.GetScriptArray("TABLES")
          Do While GetToken(m_Txt) <> "Argument"
          Loop
          If GetNextChar(m_Txt) = "=" Then
            Dim tstr As String
            tstr = GetString(m_Txt)
          End If
          ref.items.Add tstr
        End If
        If Left(tok2, 9) = "Comment =" Then
          If Len(Trim(Mid(tok2, 10))) >= 8 Then
            locomm = locomm + 1
          End If
        End If
  Loop
  AddChecksumAndVar ff, modName, checksum, tTxt, xlsarr, txtExtension & "*CODE"
      
End Sub


Function RemoveComments(ByVal txt As String) As String
  Dim i As Long
  Dim nutxt As String
  For i = 1 To Len(txt)
    If Mid(txt, i, 1) = Chr(34) Then
      nutxt = nutxt + Mid(txt, i, 1)
      i = i + 1
      While Mid(txt, i, 1) <> Chr(34)
        nutxt = nutxt + Mid(txt, i, 1)
        i = i + 1
      Wend
      nutxt = nutxt + Mid(txt, i, 1)
    ElseIf Mid(txt, i, 1) = "'" Then
      While Mid(txt, i, 1) <> Chr(10) And Mid(txt, i, 1) <> Chr(13)
        i = i + 1
      Wend
      nutxt = nutxt + Mid(txt, i, 1)
    Else
      nutxt = nutxt + Mid(txt, i, 1)
    End If
  Next i
  RemoveComments = nutxt
End Function

Attribute VB_Name = "FileFuncs"
Option Explicit

'  Shell File Operations

Private Const FO_MOVE = &H1
Private Const FO_COPY = &H2
Private Const FO_DELETE = &H3
Private Const FO_RENAME = &H4
Private Const FOF_MULTIDESTFILES = &H1
Private Const FOF_CONFIRMMOUSE = &H2
Private Const FOF_SILENT = &H4                      '  don't create progress/report
Private Const FOF_RENAMEONCOLLISION = &H8
Private Const FOF_NOCONFIRMATION = &H10             '  Don't prompt the user.
Private Const FOF_WANTMAPPINGHANDLE = &H20          '  Fill in SHFILEOPSTRUCT.hNameMappings
                                      '  Must be freed using SHFreeNameMappings
Private Const FOF_ALLOWUNDO = &H40
Private Const FOF_FILESONLY = &H80                  '  on *.*, do only files
Private Const FOF_SIMPLEPROGRESS = &H100            '  means don't show names of files
Private Const FOF_NOCONFIRMMKDIR = &H200            '  don't confirm making any needed dirs

Private Type SHFILEOPSTRUCT
        hWnd As Long
        wFunc As Long
        pFrom As String
        pTo As String
        fFlags As Integer
        fAnyOperationsAborted As Boolean
        hNameMappings As Long
        lpszProgressTitle As String '  only used if FOF_SIMPLEPROGRESS
End Type

#If VBA7 Then
Private Declare PtrSafe Function SHFileOperation Lib "shell32.dll" Alias "SHFileOperationA" (lpFileOp As SHFILEOPSTRUCT) As Long
#Else
Private Declare Function SHFileOperation Lib "shell32.dll" Alias "SHFileOperationA" (lpFileOp As SHFILEOPSTRUCT) As Long
#End If

Const OFN_READONLY           As Long = &H1
Const OFN_EXPLORER           As Long = &H80000
Const OFN_LONGNAMES          As Long = &H200000
Const OFN_CREATEPROMPT       As Long = &H2000
Const OFN_NODEREFERENCELINKS As Long = &H100000
Const OFN_OVERWRITEPROMPT    As Long = &H2
Const OFN_HIDEREADONLY       As Long = &H4
Const OFS_FILE_OPEN_FLAGS    As Long = OFN_EXPLORER _
                                    Or OFN_LONGNAMES _
                                    Or OFN_CREATEPROMPT _
                                    Or OFN_NODEREFERENCELINKS
Const OFS_FILE_SAVE_FLAGS    As Long = OFN_EXPLORER _
                                    Or OFN_LONGNAMES _
                                    Or OFN_OVERWRITEPROMPT _
                                    Or OFN_HIDEREADONLY
Type OpenFilename
    nStructSize     As Long
    hwndOwner       As Long
    hInstance       As Long
    sFilter         As String
    sCustomFilter   As String
    nCustFilterSize As Long
    nFilterIndex    As Long
    sFile           As String
    nFileSize       As Long
    sFileTitle      As String
    nTitleSize      As Long
    sInitDir        As String
    sDlgTitle       As String
    Flags           As Long
    nFileOffset     As Integer
    nFileExt        As Integer
    sDefFileExt     As String
    nCustData       As Long
    fnHook          As Long
    sTemplateName   As String
End Type
  
#If VBA7 Then
Declare PtrSafe Function GetActiveWindow Lib "user32.dll" () As LongPtr
Declare PtrSafe Function GetOpenFileName Lib "comdlg32.dll" Alias _
    "GetOpenFileNameA" (pOpenfilename As OpenFilename) As Long
Declare PtrSafe Function GetSaveFileName Lib "comdlg32.dll" Alias _
    "GetSaveFileNameA" (pOpenfilename As OpenFilename) As Long
Declare PtrSafe Function GetShortPathName Lib "kernel32.dll" Alias _
    "GetShortPathNameA" (ByVal lpszLongPath As String, _
                         ByVal lpszShortPath As String, _
                         ByVal cchBuffer As Long) As Long
#Else
Declare Function GetActiveWindow Lib "user32.dll" () As Long
Declare Function GetOpenFileName Lib "comdlg32.dll" Alias _
    "GetOpenFileNameA" (pOpenfilename As OpenFilename) As Long
Declare Function GetSaveFileName Lib "comdlg32.dll" Alias _
    "GetSaveFileNameA" (pOpenfilename As OpenFilename) As Long
Declare Function GetShortPathName Lib "kernel32.dll" Alias _
    "GetShortPathNameA" (ByVal lpszLongPath As String, _
                         ByVal lpszShortPath As String, _
                         ByVal cchBuffer As Long) As Long
#End If



Public Sub SyncCopy(Dateiname$, zielverzeichnis$)

Dim filenames$
Dim i As Integer
Dim shellinfo As SHFILEOPSTRUCT

filenames = Dateiname + Chr(0)

With shellinfo
        .hWnd = 0 ' Screen.ActiveForm.Hwnd
        .wFunc = FO_COPY
        .pFrom = filenames
        .pTo = zielverzeichnis
        .fFlags = FOF_FILESONLY + FOF_NOCONFIRMATION + FOF_NOCONFIRMMKDIR + FOF_SILENT
End With

SHFileOperation shellinfo

End Sub

' Dateioperationen

Public Sub CopyFile(Dateiname$, zielverzeichnis$, Optional inklusiveUnterverzeichnisse)

  Dim arr(1) As String
  arr(0) = Dateiname
  
  CopyPlus arr, zielverzeichnis, inklusiveUnterverzeichnisse

End Sub

Public Sub CopyPlus(dateinamen$(), zielverzeichnis$, Optional inklusiveUnterverzeichnisse)

Dim filenames$
Dim i As Integer
Dim shellinfo As SHFILEOPSTRUCT

For i = 0 To UBound(dateinamen)
    filenames = filenames & dateinamen(i) + Chr(0)
Next i
filenames = filenames + Chr(0)

With shellinfo
        .hWnd = 0 ' Screen.ActiveForm.Hwnd
        .wFunc = FO_COPY
        .pFrom = filenames
        .pTo = zielverzeichnis
        If Not IsMissing(inklusiveUnterverzeichnisse) Then
            If Not inklusiveUnterverzeichnisse Then .fFlags = FOF_FILESONLY
        End If
End With

SHFileOperation shellinfo

End Sub

Public Function Move(dateinamen$(), zielverzeichnis$, Optional inklusiveUnterverzeichnisse)

Dim filenames$
Dim i As Integer
Dim shellinfo As SHFILEOPSTRUCT

For i = 0 To UBound(dateinamen)
    filenames = filenames & dateinamen(i) + Chr(0)
Next i
filenames = filenames + Chr(0)

With shellinfo
        .hWnd = 0 ' Screen.ActiveForm.Hwnd
        .wFunc = FO_COPY
        .pFrom = filenames
        .pTo = zielverzeichnis
        If Not IsMissing(inklusiveUnterverzeichnisse) Then
            If Not inklusiveUnterverzeichnisse Then .fFlags = FOF_FILESONLY
        End If
End With

SHFileOperation shellinfo

End Function

Public Function Delete(dateinamen$(), Optional inklusiveUnterverzeichnisse)
Dim filenames$
Dim i As Integer
Dim shellinfo As SHFILEOPSTRUCT

For i = 0 To UBound(dateinamen)
    filenames = filenames & dateinamen(i) + Chr(0)
Next i
filenames = filenames + Chr(0)

With shellinfo
        .hWnd = 0 ' Screen.ActiveForm.Hwnd
        .wFunc = FO_DELETE
        .pFrom = filenames
        .pTo = "" + Chr(0)
        If Not IsMissing(inklusiveUnterverzeichnisse) Then
            If Not inklusiveUnterverzeichnisse Then .fFlags = FOF_FILESONLY
        End If
End With

SHFileOperation shellinfo

End Function


Function GetPath(ByVal p As String) As String
  If InStrRev(p, "\") > 0 Then
    GetPath = Left(p, InStrRev(p, "\") - 1)
    Exit Function
  End If
  GetPath = p
End Function

Function GetExtension(ByVal p As String) As String
    Dim slash As Long
    slash = InStrRev(p, "\")
    Dim dot As Long
    dot = InStrRev(p, ".")
    
    If dot > slash Then
        GetExtension = Mid(p, dot + 1)
        Exit Function
    End If
    GetExtension = ""
End Function


'API - Dateiauswahl-Dialog

  
'Function Dateiauswahl(strInitDir As String, sFilter As String, Optional Headline As String = "Bitte w|fffd|hlen Sie eine Datei aus:") As String
Function Dateiauswahl(strInitDir As String, sFilter As String, Optional Headline As String = "") As String
    If Headline = "" Then
      Headline = FMT0("FILEFUNCS_1")
    End If
    
'    Dim sFilter As String
'// --------------------------------------------------------------------------
'// Strukturvariable vom Typ OPENFILENAME erzeugen
'// --------------------------------------------------------------------------
    Dim uOFN As OpenFilename

'// --------------------------------------------------------------------------
'// Strukturgr|fffd||fffd|e und Elternfenster setzen
'// --------------------------------------------------------------------------
    uOFN.nStructSize = Len(uOFN)
    uOFN.hwndOwner = GetActiveWindow()
'// --------------------------------------------------------------------------
'// Filter setzen und Index auf 2 (Datenbanken) setzen
'// Format: "Name" \n "Ext." \n "Name" \n "Ext." ... \n\n
'// --------------------------------------------------------------------------
'    sFilter = "Alle Dateien (*.*)" & vbNullChar & "*.*" & vbNullChar & _
'              "Textdateien (*.txt)" & vbNullChar & "*.txt"
    sFilter = sFilter & vbNullChar & vbNullChar
    uOFN.sFilter = sFilter
    uOFN.nFilterIndex = 2
'// --------------------------------------------------------------------------
'// Dialogtitel setzen
'// --------------------------------------------------------------------------
    uOFN.sDlgTitle = Headline
'// --------------------------------------------------------------------------
'// Flags setzen
'// --------------------------------------------------------------------------
    uOFN.Flags = OFS_FILE_OPEN_FLAGS
'// --------------------------------------------------------------------------
'// Speicher f|fffd|r sFile und sFileTitle reservieren
'// --------------------------------------------------------------------------
    uOFN.sFile = Space$(256) & vbNullChar
    uOFN.sInitDir = strInitDir
    uOFN.nFileSize = Len(uOFN.sFile)
    uOFN.sFileTitle = Space$(256) & vbNullChar
    uOFN.nTitleSize = Len(uOFN.sFileTitle)
'// --------------------------------------------------------------------------
'// Funktion aufrufen und auswerten
'// --------------------------------------------------------------------------
    If GetOpenFileName(uOFN) Then
        Dateiauswahl = Left(uOFN.sFile, InStr(uOFN.sFile, vbNullChar) - 1)
'      Else
'        MsgBox "Es wurde Abbruch gew|fffd|hlt!", vbInformation
    End If
End Function

'Function DateiauswahlSpeichern(strInitDir As String, sFilter As String, Optional Headline As String = "Bitte w|fffd|hlen Sie einen Dateinamen aus:", Optional name As String = "") As String
Function DateiauswahlSpeichern(strInitDir As String, sFilter As String, Optional Headline As String = "", Optional name As String = "") As String
    If Headline = "" Then
      Headline = FMT0("FILEFUNCS_2")
    End If
'    Dim sFilter As String
'// --------------------------------------------------------------------------
'// Strukturvariable vom Typ OPENFILENAME erzeugen
'// --------------------------------------------------------------------------
    Dim uOFN As OpenFilename

'// --------------------------------------------------------------------------
'// Strukturgr|fffd||fffd|e und Elternfenster setzen
'// --------------------------------------------------------------------------
    uOFN.nStructSize = Len(uOFN)
    uOFN.hwndOwner = GetActiveWindow()
'// --------------------------------------------------------------------------
'// Filter setzen und Index auf 2 (Datenbanken) setzen
'// Format: "Name" \n "Ext." \n "Name" \n "Ext." ... \n\n
'// --------------------------------------------------------------------------
'    sFilter = "Alle Dateien (*.*)" & vbNullChar & "*.*" & vbNullChar & _
'              "Textdateien (*.txt)" & vbNullChar & "*.txt"
    sFilter = sFilter & vbNullChar & vbNullChar
    uOFN.sFilter = sFilter
    uOFN.nFilterIndex = 2
'// --------------------------------------------------------------------------
'// Dialogtitel setzen
'// --------------------------------------------------------------------------
    uOFN.sDlgTitle = Headline
'// --------------------------------------------------------------------------
'// Flags setzen
'// --------------------------------------------------------------------------
    uOFN.Flags = OFS_FILE_SAVE_FLAGS
'// --------------------------------------------------------------------------
'// Speicher f|fffd|r sFile und sFileTitle reservieren
'// --------------------------------------------------------------------------
    uOFN.sFile = name & Space$(256 - Len(name)) & vbNullChar
    uOFN.sInitDir = strInitDir
    uOFN.nFileSize = Len(uOFN.sFile)
    uOFN.sFileTitle = Space$(256) & vbNullChar
    uOFN.nTitleSize = Len(uOFN.sFileTitle)
'// --------------------------------------------------------------------------
'// Funktion aufrufen und auswerten
'// --------------------------------------------------------------------------
    If GetOpenFileName(uOFN) Then
        DateiauswahlSpeichern = Left(uOFN.sFile, InStr(uOFN.sFile, vbNullChar) - 1)
'      Else
'        MsgBox "Es wurde Abbruch gew|fffd|hlt!", vbInformation
    End If
End Function


Public Function DateinameMitVersionsnummer(name As String, Version As String, mitDatum As Boolean)
    
    ' nur den Dateinamen nehmen
    Dim slash As Long
    slash = InStrRev(name, "\")
    If slash > 0 Then
        name = Mid(name, slash + 1)
    End If
    Version = Trim(Version)
    
    ' und vor der Extension noch die Versionsnummer eintragen
    Dim dot As Long
    dot = InStrRev(name, ".")
    If dot > 0 Then
        Dim ext As String
        ext = Mid(name, dot)
        
        name = Left(name, dot - 1) & "_V" & Version
        If mitDatum Then
' NN - 7.8.2011
            name = name & "_" & year(Now) & "_" & month(Now) & "_" & day(Now)
' NN - 7.8.2011 - ENDE
        End If
        name = name & ext
    Else
        name = name & "_V" & Version
        If mitDatum Then
' NN - 7.8.2011
            name = name & "_" & year(Now) & "_" & month(Now) & "_" & day(Now)
' NN - 7.8.2011 - ENDE
        End If
    End If
    
    DateinameMitVersionsnummer = name

End Function

Function GetFileNameAndExtension(ByVal fn As String)
    Dim File As String
    Dim path As String
    Dim ext As String
    
    fileSplit fn, path, File, ext
    GetFileNameAndExtension = File & "." & ext
End Function

Sub fileSplit(ByVal s$, ByRef path$, ByRef File$, ByRef ext$)
    ' die Prozedur zerlegt den Dateinamen S in Path, Name, Extension
    Dim i%
    For i = Len(s) To 1 Step -1
        If Mid(s, i, 1) = "\" Or Mid(s, i, 1) = "/" Then   ' keine Extension vorhanden
            ext = ""
            Exit For
        End If
        If Mid(s, i, 1) = "." Then
            ext = Right(s, Len(s) - i)
            s = Left(s, i - 1)
            Exit For
        End If
    Next i
    i = Len(s)
    If InStr(s, "\") <> 0 Then
        While Mid(s, i, 1) <> "\"
            i = i - 1
        Wend
    ElseIf InStr(s, "/") <> 0 Then
        While Mid(s, i, 1) <> "/"
            i = i - 1
        Wend
    End If
    path = Left(s, i)
    File = Right(s, Len(s) - i)

End Sub

Function ShowFileDialog(sInitDir As String, s|fffd|berschrift As String, sFilter As String, Optional saveDlg = False, Optional fname As String = "") As String
    ' Calls the API File Save Dialog Window
    ' Returns full path to new File
    
    On Error GoTo Err_fFileDialog
    
    ' Call the File Common Dialog Window
    Dim clsDialog As Object
    Dim strTemp As String
    Dim strFname As String
    
    Set clsDialog = New clsCommonDialog
    
    ' Fill in our structure
    ' I'll leave in how to select Gif and Jpeg to
    ' show you how to build the Filter in case you want
    ' to use this code in another project.
    clsDialog.Filter = sFilter ' "PDF (*.PDF)" & Chr$(0) & "*.PDF" & Chr$(0)
    'clsDialog.Filter = clsDialog.Filter & "Gif (*.GIF)" & Chr$(0) & "*.GIF" & Chr$(0)
    'clsDialog.Filter = "ALL (*.*)" & Chr$(0) & "*.*" & Chr$(0)
    clsDialog.hDC = 0
    clsDialog.MaxFileSize = 256
    clsDialog.Max = 256
    clsDialog.FileTitle = vbNullString
    clsDialog.DialogTitle = s|fffd|berschrift
    clsDialog.InitDir = sInitDir & vbNullString
    clsDialog.DefaultExt = vbNullString
    clsDialog.Filename = fname
    
    ' Display the File Dialog
    If saveDlg Then
      clsDialog.ShowSave
    Else
      clsDialog.ShowOpen
    End If
    
    ' See if user clicked Cancel or even selected
    ' the very same file already selected
    If clsDialog.APIReturn = 1 Then
      strFname = clsDialog.Filename
    Else
      strFname = ""
    End If
    'If Len(strFname & vbNullString) = 0 Then
    ' Raise the exception
     ' Err.Raise vbObjectError + 513, "clsPrintToFit.fFileDialog", _
      '"Please type in a Name for a New File"
    'End If
    
    ' Return File Path and Name
    ShowFileDialog = strFname
    
Exit_fFileDialog:
    
    Err.Clear
    Set clsDialog = Nothing
    Exit Function
    
Err_fFileDialog:
    ShowFileDialog = ""
    MsgBox Err.Description, vbOKOnly, Err.Source & ":" & Err.Number
    Resume Exit_fFileDialog

End Function





Attribute VB_Name = "Globals"
Option Explicit

Global GSprache As Long
'Public Const MyVersion As String = "Version 2.1"
Public Const MyVersionString As String = "2.2c"
Public Const MyInternalVersion As Long = 8
Public Const ProgNameShort As String = "ACC"
Public Const ProgNameLong As String = "Access-Checker"
Public Const MyAppID = 13

Public Const MyACCVersion As Long = 0

Public G_StartScan As Date
Public G_EndScan As Date
Public G_SchedulerTimeCheckIgnore As Boolean

Public G_ACCPro As Boolean

Public trs As String
Public trsShrt As String
Public FullVersion As Boolean

Public trsLngSelect As String

Public theAccessScannerVersion As Long

Public xlsDateien As Collection
Public inaccessablePaths As Collection
Public Funcs As Collection
Public TotalUsedBytes As Long
Public TotalUsedFiles As Long
Public TotalUnusedBytes As Long
Public TotalUnusedFiles As Long
Public TotalUnusedBytesOlder As Long
Public TotalUnusedFilesOlder As Long
Public TotalUnusedBytesSmaller As Long
Public TotalUnusedFilesSmaller As Long
Public TotalUnusedBytesDouble As Long
Public TotalUnusedFilesDouble As Long

Public LastProgText As String
Public ProgText As String
Public theFilename As String

Public Trans

Public Const MYadOpenDynamic As Long = 2
Public Const MYadLockPessimistic As Long = 2
Public Const MYadLockOptimistic As Long = 3
Public Const MYadLockReadOnly As Long = 1

Public G_cfgLogpfad As String
Public G_cfgTemppfad As String
Public G_cfgKeypfad As String
Public G_cfgPasswortpfad As String


Public G_RiskTabs As Collection ' RiskTab
Public G_RiskContains As Collection ' RiskVal
Public G_WhiteList As Collection ' RiskVal

Public Const C_RISK_TYPE_ECC As Long = 1
Public Const C_RISK_TYPE_FORMULA_CONTAINS As Long = 2
Public Const C_RISK_TYPE_NOT_IN_WHITE_LIST As Long = 3
Public Const C_RISK_TYPE_WHITE_LIST As Long = 4

Public Const C_RISK_COMP_TYPE_LESS As Long = 1
Public Const C_RISK_COMP_TYPE_LESSEQUAL As Long = 2
Public Const C_RISK_COMP_TYPE_EQUAL As Long = 3
Public Const C_RISK_COMP_TYPE_LARGEREQUAL As Long = 4
Public Const C_RISK_COMP_TYPE_LARGER As Long = 5


Public G_RiskLow As Double
Public G_RiskMed As Double
Public G_RiskLowCol As Long
Public G_RiskMedCol As Long
Public G_RiskHighCol As Long
Public G_ColorCells As Boolean

Public G_Cursorlocation As Long

Public G_DBConnectionString As String
Public G_AnalyseFile As String

Public Function MyVersion() As String
  MyVersion = FMT1("GLOBALS_1", MyVersionString)
End Function

Function FormulaAnalyzable(c) As Boolean
  FormulaAnalyzable = True
  On Error GoTo notAnalyzable
  If c.Formula = "a" Then
  End If
  Exit Function
notAnalyzable:
  FormulaAnalyzable = False
End Function

Function TranslateFunc(s As String) As String
  On Error GoTo noTrans
  TranslateFunc = Trans(s)
  Exit Function
noTrans:
  TranslateFunc = s
End Function


Sub FreeAllMem()
'  ActiveSheet.UsedRange
  Set Trans = Nothing
  Set xlsDateien = Nothing
  Set inaccessablePaths = Nothing
  Set Funcs = Nothing
End Sub


Sub ScanDirs(Pfad As String, nichtaelterals As Long, nichtkleinerals As Long, gleichenamenignorieren As Boolean, unterverzeichnisseIgnorieren As Boolean)

'   .MousePointer = fmMousePointerHourGlass
'  Me.MousePointer = fmMousePointerDefault

    Dim name As String
    Dim Verzeichnisse As New Collection
    ' Erst mal alle Verzeichnisse holen!
    On Error GoTo inaccessablePath
    name = Dir(Pfad & "\*.*", vbDirectory) ' Ersten Eintrag abrufen.
'    On Error GoTo 0
  On Error Resume Next
    Do While name <> ""    ' Schleife beginnen.
        ' Aktuelles und |fffd|bergeordnetes Verzeichnis ignorieren.
        If name <> "." And name <> ".." Then
            ' Mit bit-weisem Vergleich sicherstellen, da|fffd| name ein
            ' Verzeichnis ist.
            Err.Number = 0
            If (GetAttr(Pfad & "\" & name) And vbDirectory) = vbDirectory Then
                If Err.Number = 0 Then Verzeichnisse.Add Pfad & "\" & name  ' Eintrag nur anzeigen, wenn es sich
            Else
                ' Ansonsten ist es eine Datei! Wenn es ein Excel-Sheet ist, dann wird
                ' es in die xlsDateien - Collection mitaufgenommen
                If UCase(Right(name, 4)) = ".XLS" Or UCase(Right(name, 4)) = ".XLT" Or UCase(Right(name, 4)) = ".XLA" Then
                    ' Nicht die eigene Datei!!!!!
                    If ThisWorkbook.FullName <> Pfad & "\" & name Then
                      Dim used As Boolean
                      used = False
                      ' Wenn die Dateikriterien passen
                      If MyFileLen(Pfad & "\" & name) >= nichtkleinerals * 1024 Then
                        Dim fd As Date
                        fd = Format(MyFileDateTime(Pfad & "\" & name), "Short Date")
                        If Format(DateAdd("m", -nichtaelterals, Now()), "Short Date") <= fd Then
                          If gleichenamenignorieren = True Then
                            If FilenameDoesntExistAbove(Pfad, name) Then
                              xlsDateien.Add Pfad & "\" & name
                              used = True
                            Else
                              TotalUnusedBytesDouble = TotalUnusedBytesDouble + MyFileLen(Pfad & "\" & name)
                              TotalUnusedFilesDouble = TotalUnusedFilesDouble + 1
                            End If
                          Else
                            xlsDateien.Add Pfad & "\" & name
                            used = True
                          End If
                        Else
                          TotalUnusedBytesOlder = TotalUnusedBytesOlder + MyFileLen(Pfad & "\" & name)
                          TotalUnusedFilesOlder = TotalUnusedFilesOlder + 1
                        End If
                      Else
                        TotalUnusedBytesSmaller = TotalUnusedBytesSmaller + MyFileLen(Pfad & "\" & name)
                        TotalUnusedFilesSmaller = TotalUnusedFilesSmaller + 1
                      End If
                      If Not used Then
                        TotalUnusedBytes = TotalUnusedBytes + MyFileLen(Pfad & "\" & name)
                        TotalUnusedFiles = TotalUnusedFiles + 1
                      Else
                        TotalUsedBytes = TotalUsedBytes + MyFileLen(Pfad & "\" & name)
                        TotalUsedFiles = TotalUsedFiles + 1
                      End If
                    End If
                End If
            End If
        End If
        name = Dir ' N|fffd|chsten Eintrag abrufen.
    Loop
    
    Dim item
    Dim tstring As String
    If Not unterverzeichnisseIgnorieren Then
      For Each item In Verzeichnisse
          tstring = item
          ScanDirs tstring, nichtaelterals, nichtkleinerals, gleichenamenignorieren, unterverzeichnisseIgnorieren
      Next item
    End If
    
    Set Verzeichnisse = Nothing

    Exit Sub
    
inaccessablePath:
    inaccessablePaths.Add Pfad

End Sub



Function GetPermission(usrGrp As String, objclass As String, objname As String) As Long
  Dim d As Document
  Set d = m_DB.Containers(objclass).Documents(objname)
  d.UserName = usrGrp
  GetPermission = d.Permissions
End Function

Function DoThat(t As String) As String

    Dim i As Long
    Dim s2 As String
    For i = 1 To Len(t)
        If Mid(t, i, 1) = "@" Then
            s2 = s2 + vbLf
        ElseIf Mid(t, i, 1) = "^" Then
            s2 = s2 + " "
        ElseIf Mid(t, i, 1) >= "0" And Mid(t, i, 1) <= "9" Then
          s2 = s2 + Chr(Asc("0") + Asc("9") - Asc(Mid(t, i, 1)))
        ElseIf Mid(t, i, 1) >= "a" And Mid(t, i, 1) <= "z" Then
          s2 = s2 + Chr(Asc("a") + Asc("z") - Asc(Mid(t, i, 1)))
        ElseIf Mid(t, i, 1) >= "A" And Mid(t, i, 1) <= "Z" Then
          s2 = s2 + Chr(Asc("A") + Asc("Z") - Asc(Mid(t, i, 1)))
        Else
            s2 = s2 + Mid(t, i, 1)
        End If
    Next i
    
    DoThat = s2
End Function


Sub GetDataOld()
  On Error GoTo noData
  Dim app As Excel.Application
  Dim wb As Excel.Workbook
  Set app = New Excel.Application
  Set wb = app.Workbooks.Open(ThisWorkbook.path & "\" & DoThat("HDIvh.coz"), False, True, , "k$a5iUTe4hf2!/{", , True, , , False, False, , False)
    If wb.Sheets(1).Cells(1, 1) = "1fdd34/lkMTzdfZZQ12()//|fffd|245mNGNndflRltdaf''++.,LpiUGF" Then
      If Len(wb.Sheets(1).Cells(5, 1)) > 0 Then
        FullVersion = True
        trs = DoThat(wb.Sheets(1).Cells(5, 1))
        trsShrt = DoThat(wb.Sheets(1).Cells(5, 2))
        trsLngSelect = wb.Sheets(1).Cells(5, 3)
      End If
    End If
  wb.Close False
  Set wb = Nothing
  app.Quit
  Set app = Nothing
  Exit Sub
noData:
  Exit Sub
End Sub

Sub InitApp()
  Dim cfg As New CfgReader
  Dim s As String
  
  G_cfgConnectVia = "ODBCDSN"
  
  Set cfg = New CfgReader
  
  G_cfgKeypfad = ThisWorkbook.path
  G_cfgLogpfad = ThisWorkbook.path
  G_cfgTemppfad = ThisWorkbook.path
  G_cfgPasswortpfad = ThisWorkbook.path
  
  If FileExists(ThisWorkbook.path & "\ACC.cfg") = True Or FileExists(ThisWorkbook.path & "\..\cfg\IDV-Suite.cfg") = True Or FileExists(ThisWorkbook.path & "\..\..\cfg\IDV-Suite.cfg") = True Then

      If FileExists(ThisWorkbook.path & "\ACC.cfg") = True Then
        cfg.GetCFG ThisWorkbook.path & "\ACC.cfg"
      ElseIf FileExists(ThisWorkbook.path & "\..\cfg\IDV-Suite.cfg") Then
        cfg.GetCFG ThisWorkbook.path & "\..\cfg\IDV-Suite.cfg"
      ElseIf FileExists(ThisWorkbook.path & "\..\..\cfg\IDV-Suite.cfg") Then
        cfg.GetCFG ThisWorkbook.path & "\..\..\cfg\IDV-Suite.cfg"
      End If
      
      If cfg.GetSection("DBCONNECT") = True Then
        G_DBConnectionString = cfg.GetValue("CONNECTIONSTRING")
      End If
      
      Call InitTranslation(ThisWorkbook.path, "ACC", cfg)
      
      If cfg.GetSection("ACC") = True Then
          s = cfg.GetValue("HELLOWORLD")
          'If UCase(s) = "JA" Then
          If IsYes(s) Then
            'MsgBox "Hinweis: Der AccessChecker wurde gestartet. Sie k|fffd|nnen diesen Hinweis in der Datei ACC.cfg (oder IDV-Suite.cfg)) deaktivieren. Stellen Sie dort bitte den Parameter HELLOWORLD auf Nein", vbInformation
            MsgBox FMT0("GLOBALS_2"), vbInformation
          End If
          s = cfg.GetValue("LOG")
          'If UCase(s) = "JA" Then
          If IsYes(s) Then
            G_LogEnabled = True
          End If
          s = cfg.GetValue("LOGPRINTCHECKSUM")
          'If UCase(s) = "JA" Then
          If IsYes(s) Then
            G_LogPrintChecksum = True
          End If
      
      End If
      If cfg.GetSection("GLOBALS") = True Then
          G_cfgKeypfad = GetRelativePath(G_cfgKeypfad, cfg.GetValue("KEYPFAD"))
          G_cfgLogpfad = GetRelativePath(G_cfgLogpfad, cfg.GetValue("LOGPFAD"))
          G_cfgTemppfad = GetRelativePath(G_cfgTemppfad, cfg.GetValue("TEMPPFAD"))
          G_cfgPasswortpfad = GetRelativePath(G_cfgPasswortpfad, cfg.GetValue("PASSWORTPFAD"))
          
          If StartedByTracker = False Or UserAutomation = True Then
            If UCase(cfg.GetValue("CONNECTVIA")) = "DBCONNECT.CFG" Then
              G_cfgConnectVia = "DBCONNECT.CFG"
            End If
          End If
          
          s = cfg.GetValue("CURSORLOCATION")
          If UCase(s) = "SERVER" Then
            G_Cursorlocation = 2 ' ADODB.adUseServer
          Else
            G_Cursorlocation = 3 ' ADODB.adUseClient
          End If
      End If
      
      If cfg.GetSection("DBCONNECTEXT") = True Then
        Dim connnectCount As Long
        Dim drv As String
        For connnectCount = 1 To 10
          drv = cfg.GetValue("DRIVER" & connnectCount)
          If drv <> "" Then
            If FileExists(drv) Then
              G_DBConnectionString = cfg.GetValue("CONNECTIONSTRING" & connnectCount)
              Exit For
            End If
          End If
        Next connnectCount
      End If
      
      
      If StartedByTracker Then
        If cfg.GetSection("IDV-Suite Scheduler") = True Then
            If cfg.GetValue("KEYPFAD") <> "" Then
              G_cfgKeypfad = GetRelativePath(G_cfgKeypfad, cfg.GetValue("KEYPFAD"))
            End If
            If cfg.GetValue("LOGPFAD") <> "" Then
              G_cfgLogpfad = GetRelativePath(G_cfgLogpfad, cfg.GetValue("LOGPFAD"))
            End If
            If cfg.GetValue("TEMPPFAD") <> "" Then
              G_cfgTemppfad = GetRelativePath(G_cfgTemppfad, cfg.GetValue("TEMPPFAD"))
            End If
            If cfg.GetValue("PASSWORTPFAD") <> "" Then
              G_cfgPasswortpfad = GetRelativePath(G_cfgPasswortpfad, cfg.GetValue("PASSWORTPFAD"))
            End If
        End If
      End If
      
  End If
  
  LogPrint "ACC Start"

  LogPrint "Programmteilpr|fffd|fung"
  Dim tmpfname As String
  'tmpfname = ThisWorkbook.path & "\ACC-Res.xls"
  tmpfname = gTranslation.GetLocalizedFile(ThisWorkbook.path & "\ACC-Res.xls")
  If Not FileExists(tmpfname) Then
    If Not StartedByTracker Then
      'MsgBox "Die Datei '" & tmpfname & "' existiert nicht, der Access-Checker kann nicht ausgef|fffd|hrt werden!"
      MsgBox FMT1("GLOBALS_3", tmpfname)
    Else
      'AddStatus "Die Datei '" & tmpfname & "' existiert nicht, der Access-Checker kann nicht ausgef|fffd|hrt werden!"
      AddStatus FMT1("GLOBALS_3", tmpfname)
    End If
    Exit Sub
  End If
  
  LogPrint "Caption setzen"
  'Application.Caption = "Access-Checker"
  Application.Caption = ProgNameLong
  
  GetData
End Sub
Attribute VB_Name = "Hash"
Option Explicit

Private Const BITS_TO_A_BYTE = 8
Private Const BYTES_TO_A_WORD = 4
Private Const BITS_TO_A_WORD = 32

#If VBA7 Then
Private Declare PtrSafe Function apiGetComputerName Lib "kernel32" Alias _
    "GetComputerNameA" (ByVal lpBuffer As String, nSize As Long) As Long
#Else
Private Declare Function apiGetComputerName Lib "kernel32" Alias _
    "GetComputerNameA" (ByVal lpBuffer As String, nSize As Long) As Long
#End If

Public Function GetComputerName() As String
'Returns the computername
    Dim lngLen As Long, lngX As Long
    Dim strCompName As String
    lngLen = 16
    strCompName = String$(lngLen, 0)
    lngX = apiGetComputerName(strCompName, lngLen)
    If lngX <> 0 Then
        GetComputerName = Left$(strCompName, lngLen)
    Else
        GetComputerName = ""
    End If
End Function

Function GetDocProp(wb As Excel.Workbook, txt As String) As String
  On Error Resume Next
  GetDocProp = ""
  GetDocProp = wb.BuiltinDocumentProperties(txt)
End Function

Function GetFileHash(ByVal uncpathfname As String) As String

    If Left(uncpathfname, 1) = "\" Or Left(uncpathfname, 1) = "/" Then
        GetFileHash = SHA256(uncpathfname)
'        GetFileHash = SHA256(uncpathfname & "|" & GetDocProp(wb, "Author") & GetDocProp(wb, "Creation date"))
    Else
        GetFileHash = SHA256(uncpathfname & "|" & GetComputerName)
'        GetFileHash = SHA256(uncpathfname & "|" & GetComputerName & "|" & GetDocProp(wb, "Author") & GetDocProp(wb, "Creation date"))
    End If

End Function


Private Function LShift(lValue, iShiftBits)
Dim m_lOnBits
m_lOnBits = Array(CLng(1), CLng(3), CLng(7), CLng(15), CLng(31), CLng(63), CLng(127), CLng(255), CLng(511), CLng(1023), CLng(2047), CLng(4095), CLng(8191), CLng(16383), CLng(32767), CLng(65535), CLng(131071), CLng(262143), CLng(524287), CLng(1048575), CLng(2097151), CLng(4194303), CLng(8388607), CLng(16777215), CLng(33554431), CLng(67108863), CLng(134217727), CLng(268435455), CLng(536870911), CLng(1073741823), CLng(2147483647))

Dim m_l2Power
m_l2Power = Array(1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824)


    If iShiftBits = 0 Then
        LShift = lValue
        Exit Function
    ElseIf iShiftBits = 31 Then
        If lValue And 1 Then
            LShift = &H80000000
        Else
            LShift = 0
        End If
        Exit Function
    ElseIf iShiftBits < 0 Or iShiftBits > 31 Then
        Err.Raise 6
    End If
    
    If (lValue And m_l2Power(31 - iShiftBits)) Then
        LShift = ((lValue And m_lOnBits(31 - (iShiftBits + 1))) * m_l2Power(iShiftBits)) Or &H80000000
    Else
        LShift = ((lValue And m_lOnBits(31 - iShiftBits)) * m_l2Power(iShiftBits))
    End If
End Function



Private Function RShift(lValue, iShiftBits)

  Dim m_l2Power
  m_l2Power = Array(1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824)

    If iShiftBits = 0 Then
        RShift = lValue
        Exit Function
    ElseIf iShiftBits = 31 Then
        If lValue And &H80000000 Then
            RShift = 1
        Else
            RShift = 0
        End If
        Exit Function
    ElseIf iShiftBits < 0 Or iShiftBits > 31 Then
        Err.Raise 6
    End If
    
    RShift = (lValue And &H7FFFFFFE) \ m_l2Power(iShiftBits)
    
    If (lValue And &H80000000) Then
        RShift = (RShift Or (&H40000000 \ m_l2Power(iShiftBits - 1)))
    End If
End Function



Private Function AddUnsigned(lX, lY)
    Dim lX4, lY4, lX8, lY8, lResult
 
    lX8 = lX And &H80000000
    lY8 = lY And &H80000000
    lX4 = lX And &H40000000
    lY4 = lY And &H40000000
 
    lResult = (lX And &H3FFFFFFF) + (lY And &H3FFFFFFF)
 
    If lX4 And lY4 Then
        lResult = lResult Xor &H80000000 Xor lX8 Xor lY8
    ElseIf lX4 Or lY4 Then
        If lResult And &H40000000 Then
            lResult = lResult Xor &HC0000000 Xor lX8 Xor lY8
        Else
            lResult = lResult Xor &H40000000 Xor lX8 Xor lY8
        End If
    Else
        lResult = lResult Xor lX8 Xor lY8
    End If
 
    AddUnsigned = lResult
End Function



Private Function Ch(x, y, z)
    Ch = ((x And y) Xor ((Not x) And z))
End Function



Private Function Maj(x, y, z)
    Maj = ((x And y) Xor (x And z) Xor (y And z))
End Function



Private Function s(x, n)
Dim m_lOnBits, m_l2Power, K
m_lOnBits = Array(CLng(1), CLng(3), CLng(7), CLng(15), CLng(31), CLng(63), CLng(127), CLng(255), CLng(511), CLng(1023), CLng(2047), CLng(4095), CLng(8191), CLng(16383), CLng(32767), CLng(65535), CLng(131071), CLng(262143), CLng(524287), CLng(1048575), CLng(2097151), CLng(4194303), CLng(8388607), CLng(16777215), CLng(33554431), CLng(67108863), CLng(134217727), CLng(268435455), CLng(536870911), CLng(1073741823), CLng(2147483647))

m_l2Power = Array(1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824)
K = Array(&H428A2F98, &H71374491, &HB5C0FBCF, &HE9B5DBA5, &H3956C25B, &H59F111F1, &H923F82A4, &HAB1C5ED5, &HD807AA98, &H12835B01, &H243185BE, &H550C7DC3, &H72BE5D74, &H80DEB1FE, &H9BDC06A7, &HC19BF174, &HE49B69C1, &HEFBE4786, &HFC19DC6, &H240CA1CC, &H2DE92C6F, &H4A7484AA, &H5CB0A9DC, &H76F988DA, &H983E5152, &HA831C66D, &HB00327C8, &HBF597FC7, &HC6E00BF3, &HD5A79147, &H6CA6351, &H14292967, &H27B70A85, &H2E1B2138, &H4D2C6DFC, &H53380D13, &H650A7354, &H766A0ABB, &H81C2C92E, &H92722C85, &HA2BFE8A1, &HA81A664B, &HC24B8B70, &HC76C51A3, &HD192E819, &HD6990624, &HF40E3585, &H106AA070, &H19A4C116, &H1E376C08, &H2748774C, &H34B0BCB5, &H391C0CB3, &H4ED8AA4A, &H5B9CCA4F, &H682E6FF3, &H748F82EE, &H78A5636F, &H84C87814, &H8CC70208, &H90BEFFFA, &HA4506CEB, &HBEF9A3F7, &HC67178F2)

    s = (RShift(x, (n And m_lOnBits(4))) Or LShift(x, (32 - (n And m_lOnBits(4)))))
End Function



Private Function r(x, n)
Dim m_lOnBits
m_lOnBits = Array(CLng(1), CLng(3), CLng(7), CLng(15), CLng(31), CLng(63), CLng(127), CLng(255), CLng(511), CLng(1023), CLng(2047), CLng(4095), CLng(8191), CLng(16383), CLng(32767), CLng(65535), CLng(131071), CLng(262143), CLng(524287), CLng(1048575), CLng(2097151), CLng(4194303), CLng(8388607), CLng(16777215), CLng(33554431), CLng(67108863), CLng(134217727), CLng(268435455), CLng(536870911), CLng(1073741823), CLng(2147483647))

    r = RShift(x, CLng(n And m_lOnBits(4)))
End Function



Private Function Sigma0(x)
    Sigma0 = (s(x, 2) Xor s(x, 13) Xor s(x, 22))
End Function



Private Function Sigma1(x)
    Sigma1 = (s(x, 6) Xor s(x, 11) Xor s(x, 25))
End Function



Private Function Gamma0(x)
    Gamma0 = (s(x, 7) Xor s(x, 18) Xor r(x, 3))
End Function



Private Function Gamma1(x)
    Gamma1 = (s(x, 17) Xor s(x, 19) Xor r(x, 10))
End Function



Private Function ConvertToWordArray(sMessage)
    Dim lMessageLength, lNumberOfWords, lWordArray(), lBytePosition, lByteCount
    Dim lWordCount, lByte
    
    Const MODULUS_BITS = 512
    Const CONGRUENT_BITS = 448
    
    lMessageLength = Len(sMessage)
    
    lNumberOfWords = (((lMessageLength + ((MODULUS_BITS - CONGRUENT_BITS) \ BITS_TO_A_BYTE)) \ (MODULUS_BITS \ BITS_TO_A_BYTE)) + 1) * (MODULUS_BITS \ BITS_TO_A_WORD)
    ReDim lWordArray(lNumberOfWords - 1)
    
    lBytePosition = 0
    lByteCount = 0
    Do Until lByteCount >= lMessageLength
        lWordCount = lByteCount \ BYTES_TO_A_WORD
        
        lBytePosition = (3 - (lByteCount Mod BYTES_TO_A_WORD)) * BITS_TO_A_BYTE
        
        lByte = AscB(Mid(sMessage, lByteCount + 1, 1))
        
        lWordArray(lWordCount) = lWordArray(lWordCount) Or LShift(lByte, lBytePosition)
        lByteCount = lByteCount + 1
    Loop

    lWordCount = lByteCount \ BYTES_TO_A_WORD
    lBytePosition = (3 - (lByteCount Mod BYTES_TO_A_WORD)) * BITS_TO_A_BYTE

    lWordArray(lWordCount) = lWordArray(lWordCount) Or LShift(&H80, lBytePosition)

    lWordArray(lNumberOfWords - 1) = LShift(lMessageLength, 3)
    lWordArray(lNumberOfWords - 2) = RShift(lMessageLength, 29)
    
    ConvertToWordArray = lWordArray
End Function



Public Function SHA256(sMessage)

Dim K
K = Array(&H428A2F98, &H71374491, &HB5C0FBCF, &HE9B5DBA5, &H3956C25B, &H59F111F1, &H923F82A4, &HAB1C5ED5, &HD807AA98, &H12835B01, &H243185BE, &H550C7DC3, &H72BE5D74, &H80DEB1FE, &H9BDC06A7, &HC19BF174, &HE49B69C1, &HEFBE4786, &HFC19DC6, &H240CA1CC, &H2DE92C6F, &H4A7484AA, &H5CB0A9DC, &H76F988DA, &H983E5152, &HA831C66D, &HB00327C8, &HBF597FC7, &HC6E00BF3, &HD5A79147, &H6CA6351, &H14292967, &H27B70A85, &H2E1B2138, &H4D2C6DFC, &H53380D13, &H650A7354, &H766A0ABB, &H81C2C92E, &H92722C85, &HA2BFE8A1, &HA81A664B, &HC24B8B70, &HC76C51A3, &HD192E819, &HD6990624, &HF40E3585, &H106AA070, &H19A4C116, &H1E376C08, &H2748774C, &H34B0BCB5, &H391C0CB3, &H4ED8AA4A, &H5B9CCA4F, &H682E6FF3, &H748F82EE, &H78A5636F, &H84C87814, &H8CC70208, &H90BEFFFA, &HA4506CEB, &HBEF9A3F7, &HC67178F2)
    Dim Hash, m, w(63), a, b, c, d, e, F, g, h, i, j, t1, t2
    
    Hash = Array(&H6A09E667, &HBB67AE85, &H3C6EF372, &HA54FF53A, &H510E527F, &H9B05688C, &H1F83D9AB, &H5BE0CD19)
    
    m = ConvertToWordArray(sMessage)
    
    For i = 0 To UBound(m) Step 16
        a = Hash(0)
        b = Hash(1)
        c = Hash(2)
        d = Hash(3)
        e = Hash(4)
        F = Hash(5)
        g = Hash(6)
        h = Hash(7)
        
        For j = 0 To 63
            If j < 16 Then
                w(j) = m(j + i)
            Else
                w(j) = AddUnsigned(AddUnsigned(AddUnsigned(Gamma1(w(j - 2)), w(j - 7)), Gamma0(w(j - 15))), w(j - 16))
            End If
                
            t1 = AddUnsigned(AddUnsigned(AddUnsigned(AddUnsigned(h, Sigma1(e)), Ch(e, F, g)), K(j)), w(j))
            t2 = AddUnsigned(Sigma0(a), Maj(a, b, c))
            
            h = g
            g = F
            F = e
            e = AddUnsigned(d, t1)
            d = c
            c = b
            b = a
            a = AddUnsigned(t1, t2)
        Next
        
        Hash(0) = AddUnsigned(a, Hash(0))
        Hash(1) = AddUnsigned(b, Hash(1))
        Hash(2) = AddUnsigned(c, Hash(2))
        Hash(3) = AddUnsigned(d, Hash(3))
        Hash(4) = AddUnsigned(e, Hash(4))
        Hash(5) = AddUnsigned(F, Hash(5))
        Hash(6) = AddUnsigned(g, Hash(6))
        Hash(7) = AddUnsigned(h, Hash(7))
    Next
    
    SHA256 = LCase(Right("00000000" & Hex(Hash(0)), 8) & Right("00000000" & Hex(Hash(1)), 8) & Right("00000000" & Hex(Hash(2)), 8) & Right("00000000" & Hex(Hash(3)), 8) & Right("00000000" & Hex(Hash(4)), 8) & Right("00000000" & Hex(Hash(5)), 8) & Right("00000000" & Hex(Hash(6)), 8) & Right("00000000" & Hex(Hash(7)), 8))
End Function



Attribute VB_Name = "Helpers"
Option Explicit

Public G_LogEnabled As Boolean
Public G_LogPrintChecksum As Boolean

Const NoError = 0       'The Function call was successful

#If VBA7 Then
Public Declare PtrSafe Sub Sleep Lib "kernel32" (ByVal _
  dwMilliseconds As Long)

Declare PtrSafe Function WNetGetUser Lib "mpr.dll" _
   Alias "WNetGetUserA" (ByVal lpName As String, _
   ByVal lpUserName As String, lpnLength As Long) As Long


Private Declare PtrSafe Function apiGetComputerName Lib "kernel32" Alias _
    "GetComputerNameA" (ByVal lpBuffer As String, nSize As Long) As Long
Public Declare PtrSafe Function FindExecutable Lib "shell32.dll" Alias _
    "FindExecutableA" (ByVal lpFile As String, ByVal lpDirectory As String, ByVal lpResult As String) As Long

Public Declare PtrSafe Function apiGetTempPath Lib "kernel32" Alias "GetTempPathA" (ByVal nBufferLength As Long, ByVal lpBuffer As String) As Long

Private Declare PtrSafe Function GetTempFileName Lib "kernel32" _
         Alias "GetTempFileNameA" (ByVal lpszPath As String, _
         ByVal lpPrefixString As String, ByVal wUnique As Long, _
         ByVal lpTempFileName As String) As Long

#Else
Public Declare Sub Sleep Lib "kernel32" (ByVal _
  dwMilliseconds As Long)

Declare Function WNetGetUser Lib "mpr.dll" _
   Alias "WNetGetUserA" (ByVal lpName As String, _
   ByVal lpUserName As String, lpnLength As Long) As Long


Private Declare Function apiGetComputerName Lib "kernel32" Alias _
    "GetComputerNameA" (ByVal lpBuffer As String, nSize As Long) As Long
Public Declare Function FindExecutable Lib "shell32.dll" Alias _
    "FindExecutableA" (ByVal lpFile As String, ByVal lpDirectory As String, ByVal lpResult As String) As Long

Public Declare Function apiGetTempPath Lib "kernel32" Alias "GetTempPathA" (ByVal nBufferLength As Long, ByVal lpBuffer As String) As Long

Private Declare Function GetTempFileName Lib "kernel32" _
         Alias "GetTempFileNameA" (ByVal lpszPath As String, _
         ByVal lpPrefixString As String, ByVal wUnique As Long, _
         ByVal lpTempFileName As String) As Long


#End If

Function pvReadFile(sFile) As String
    Const ForReading = 1
    Dim sPrefix
 
    With CreateObject("Scripting.FileSystemObject")
        sPrefix = .OpenTextFile(sFile, ForReading, False, False).Read(3)
    End With
    If Left(sPrefix, 3) <> Chr(&HEF) & Chr(&HBB) & Chr(&HBF) Then
        With CreateObject("Scripting.FileSystemObject")
            pvReadFile = .OpenTextFile(sFile, ForReading, False, Left(sPrefix, 2) = Chr(&HFF) & Chr(&HFE)).ReadAll()
        End With
    Else
        With CreateObject("ADODB.Stream")
            .Open
            If Left(sPrefix, 2) = Chr(&HFF) & Chr(&HFE) Then
                .Charset = "Unicode"
            ElseIf Left(sPrefix, 3) = Chr(&HEF) & Chr(&HBB) & Chr(&HBF) Then
                .Charset = "UTF-8"
            Else
                .Charset = "_autodetect"
            End If
            .LoadFromFile sFile
            pvReadFile = .ReadText
        End With
    End If
End Function


Public Sub ACCreateHeaderAndFooter(ws As Worksheet, Optional Filename As String = "")
    On Error Resume Next
    ' Datum der Generierung in die Fu|fffd|zeile eintragen
    With ws.PageSetup
        Dim usr As String
        usr = Environ("USERNAME")
        If Len(usr) Then
            '.LeftFooter = "Generiert am: " & Now() & " von " & usr
            .LeftFooter = FMT2("HELPERS_1", Now(), usr)
        Else
            '.LeftFooter = "Generiert am: " & Now()
            .LeftFooter = FMT1("HELPERS_2", Now())
        End If
        .CenterHeader = "&16" & ws.name
        .RightHeader = "&7 Access-Checker " & MainMenu.Vers & vbLf & MainMenu.Cop
        '.LeftHeader = "&7 " & trsShrt & IIf(Len(Filename) > 0, vbLf & "Datei: '" & Filename & "'", "")
        .LeftHeader = "&7 " & trsShrt & IIf(Len(Filename) > 0, vbLf & FMT1("HELPERS_3", Filename), "")
    End With

End Sub


Function SheetHasPassword(oXLWsheet)
    SheetHasPassword = True
    On Error GoTo password_notok
    ' Wir probieren das Ganze mit einem idiotischen Passwort
    oXLWsheet.Unprotect "12%%XXy<11!A"
    SheetHasPassword = False
password_notok:
End Function

Function WorkbookHasPassword(oxlwbook)
    WorkbookHasPassword = True
    On Error GoTo password_notok
    ' Wir probieren das Ganze mit einem idiotischen Passwort
    oxlwbook.Unprotect "12%%XXy<11!A"
    WorkbookHasPassword = False
password_notok:
End Function

Public Function StringAdd(stringlist, txt As String) As Boolean
    StringAdd = False
    Dim item
    For Each item In stringlist
        If item = txt Then Exit Function
    Next item
    StringAdd = True
    stringlist.Add txt
End Function

Function CheckVBAAccessAllowed() As Boolean
  CheckVBAAccessAllowed = True
  On Error GoTo noVBA
  If ThisWorkbook.VBProject.Protection = 1 Then ' vbext_pp_locked
  End If
  Exit Function
noVBA:
  CheckVBAAccessAllowed = False
End Function

Function FilenameDoesntExistAbove(Pfad As String, name As String) As Boolean
  Dim item
  Dim pos As Long
  FilenameDoesntExistAbove = True
  If Len(Pfad) <= 1 Then Exit Function
  pos = Len(Pfad)
  pos = pos - 1
  Do
    pos = InStrMyRev(Pfad, "\", pos)
    If pos < 0 Then Exit Do
    For Each item In xlsDateien
      If Left(Pfad, pos) & name = item Then
        FilenameDoesntExistAbove = False
        Exit Function
      End If
    Next item
    pos = pos - 1
  Loop While pos > 0
End Function

Function InStrMyRev(str As String, v As String, Optional pos As Long = 0) As Long
  Dim i As Long
  If Not IsMissing(pos) And pos > 0 Then
    i = pos
  Else
    i = Len(str)
  End If
  Do While i > 0
    If Mid(str, i, Len(v)) = v Then
      InStrMyRev = i
      Exit Function
    End If
    i = i - 1
  Loop
  InStrMyRev = 0
End Function


Sub AddStatus(txt As String, Optional col As Long = 196)
  LastProgText = ProgText
  If Len(ProgText) > 0 Then
    ProgText = ProgText & vbCrLf & txt
  Else
    ProgText = txt
  End If
  
  StatusForm.ProgText = Right(ProgText, 16000)
  StatusForm.Repaint
  StatusForm.ProgText.SelStart = Len(ProgText)
  
  If theTrackerFreigabe Then
    StoreUserCommunicateValue "TU", ProgText
  End If
  
  StatusFormUpdate
  
  SetLiveStatus
  
'    StatusForm.ProgText.CurLine = 10000
'  WriteTimeStamp
'  WriteToSheet cfgMappenname, Texte(GSprache, TXT_ANS_MASSENANALYSE), TheMassAnalysisY, 2, txt, col
'  WriteToSheet cfgMappenname, Texte(GSprache, TXT_ANS_MASSENANALYSE), TheMassAnalysisY, 3, CStr(CurrentStatus), col
End Sub
Sub UpdateStatus(txt As String)
  If Len(LastProgText) > 0 Then
    ProgText = LastProgText & vbCrLf & txt
  Else
    ProgText = txt
  End If
  
  StatusForm.ProgText = Right(ProgText, 16000)
  StatusForm.Repaint
  StatusForm.ProgText.SelStart = Len(ProgText)
  
  If theTrackerFreigabe Then
    StoreUserCommunicateValue "TU", ProgText
  End If
'    StatusForm.ProgText.CurLine = 10000
'  WriteTimeStamp
'  WriteToSheet cfgMappenname, Texte(GSprache, TXT_ANS_MASSENANALYSE), TheMassAnalysisY, 2, txt
'  WriteToSheet cfgMappenname, Texte(GSprache, TXT_ANS_MASSENANALYSE), TheMassAnalysisY, 3, CStr(CurrentStatus)
End Sub

Function MyOpenFile(ByVal fullpath As String, ByVal fn As Long)
    On Error GoTo nogo:
    
    Open fullpath For Append As fn
    MyOpenFile = True
    Exit Function
nogo:
    MyOpenFile = False

End Function

Public Function AddTextToFile(ByVal strData As String, _
     ByVal fullpath As String, _
       Optional ByVal ErrInfo As String = "") As Boolean

    Dim fn As Long
    fn = FreeFile
    Dim s As String
    
    Dim i As Long
    i = 0

    While i < 5
      If MyOpenFile(fullpath, fn) Then
        Print #fn, strData
        Close fn
        AddTextToFile = True
        Exit Function
      End If
      i = i + 1
      Sleep 10
    Wend

    AddTextToFile = False
    Exit Function

End Function

Sub ClearLog()
  On Error Resume Next
  Kill ThisWorkbook.path & "\ACC-Log" & GetUserName & ".txt"
End Sub

Function GetRelativePath(ByVal stdpath As String, ByVal cfgpath As String) As String
  Dim s As String
  If cfgpath = "" Then s = stdpath
  
  If cfgpath = "USERTEMP" Then
    cfgpath = GetTempPath
    If Right(cfgpath, 1) = "\" Then
      cfgpath = Left(cfgpath, Len(cfgpath) - 1)
    End If
  End If
  
  If Left(cfgpath, 2) = "\\" Or Left(cfgpath, 2) = "//" Or Mid(cfgpath, 2, 1) = ":" Then
    s = cfgpath
  Else
    s = ThisWorkbook.path & "\" & cfgpath
  End If
  
  If Not PathExists(s) Then
    MkFullDir s
    If Not PathExists(s) Then
'      If Not StartedByTracker Then
'        MsgBox "ACHTUNG: Der Pfad '" & s & "' konnte nicht erzeugt werden. Das Programm wird voraussichtlich nicht korrekt funktionieren. Bitte gew|fffd|hrleisten Sie, dass der Pfad existiert!", vbCritical
'      Else
        'AddStatus "ACHTUNG: Der Pfad '" & s & "' konnte nicht erzeugt werden."
        AddStatus FMT1("HELPERS_4", s)
'      End If
    End If
  End If
  
  GetRelativePath = s
End Function

Function GetUserName() As String

   ' Buffer size for the return string.
   Const lpnLength As Integer = 255

   ' Get return buffer space.
   Dim status As Integer

   ' For getting user information.
   Dim lpName, lpUserName As String

   ' Assign the buffer size constant to lpUserName.
   lpUserName = Space$(lpnLength + 1)

   ' Get the log-on name of the person using product.
   status = WNetGetUser(lpName, lpUserName, lpnLength)

   ' See whether error occurred.
   If status = NoError Then
      ' This line removes the null character. Strings in C are null-
      ' terminated. Strings in Visual Basic are not null-terminated.
      ' The null character must be removed from the C strings to be used
      ' cleanly in Visual Basic.
      lpUserName = Left$(lpUserName, InStr(lpUserName, Chr(0)) - 1)
   Else

      ' An error occurred.
'         MsgBox "Unable to get the name."
      'lpUserName = "Unbekannt"
      lpUserName = FMT0("HELPERS_5")
   End If

   ' Display the name of the person logged on to the machine.
'      MsgBox "The person logged on this machine is: " & lpUserName

    GetUserName = lpUserName

End Function

Sub MkFullDir(ByVal p As String)
  On Error Resume Next
  Dim pos As Long
  pos = 4
  Do
    pos = InStr(pos, p, "\")
    If pos > 0 Then
      MkDir Left(p, pos - 1)
    Else
      MkDir p
      Exit Sub
    End If
    pos = pos + 1
  Loop While pos > 0
End Sub

Function GetRangeCount(ByRef rng) As Double
  On Error Resume Next
  
  GetRangeCount = CDbl(rng.count)
  If Err.Number <> 0 Then
    Err.Clear
    GetRangeCount = CDbl(rng.Countlarge)
  End If
  
End Function

Function ConvGermanDate(d As String) As Date
    Dim td As Date
    
    On Error GoTo errorEnd
    td = DateSerial(1900, 1, 1)
    
    If IsDate(d) Then
        td = CDate(d)
    Else
      Dim dots As Long
      Dim pos1 As Long
      Dim pos2 As Long
      Dim endPos As Long
      
      dots = 0
      
      pos1 = InStr(d, ".")
      If pos1 > 0 Then
          dots = dots + 1
          
          pos2 = InStr(pos1 + 1, d, ".")
          If pos2 > 0 Then
              dots = dots + 1
              endPos = InStr(pos2 + 1, d, " ")
              If endPos <= 0 Then endPos = Len(d) + 1
          End If
      End If
      
      If dots = 2 Then
          Dim day As String
          Dim month As String
          Dim year As String
          day = Mid(d, 1, pos1 - 1)
          month = Mid(d, pos1 + 1, pos2 - pos1 - 1)
          year = Mid(d, pos2 + 1, endPos - pos2 - 1)
          td = DateSerial(year, month, day) & IIf(CDate(d) <> DateSerial(year, month, day), " " & Hour(d) & ":" & Minute(d) & ":" & Second(d), "")
      End If
    End If
    
    If td < DateSerial(1900, 1, 1) Then
      td = DateSerial(1900, 1, 1) & " " & Hour(d) & ":" & Minute(d) & ":" & Second(d)
    End If
    
errorEnd:
    ConvGermanDate = td
End Function

Function WorksheetExists(wb As Workbook, wsname As String)
  On Error GoTo doesntExist
  WorksheetExists = False
  
  Dim s As String
  s = wb.Sheets(wsname).name
  WorksheetExists = True
  Exit Function
doesntExist:
End Function


Function IsFullyNumeric(v As String) As Boolean
  Dim l As Long
  l = Len(v)
  If l = 0 Then Exit Function
  Dim i As Long
  For i = 1 To l
    If (Mid(v, i, 1) < "0" Or Mid(v, i, 1) > "9") And Mid(v, i, 1) <> "." Then Exit For
  Next i
  If i = l Then IsFullyNumeric = True
End Function


Function MyFileLen(ByVal fname As String) As Long
  On Error GoTo nogo:
  MyFileLen = 0
  If UCase(Left(fname, 5)) = "HTTP:" Or UCase(Left(fname, 6)) = "HTTPS:" Then
    Dim sz As Long
    Dim modDate As Date
    If URLExists(fname, sz, modDate) Then
      MyFileLen = sz
    End If
  Else
    MyFileLen = fileLen(fname)
  End If
  Exit Function
nogo:
End Function

Function MyFileDateTime(ByVal fname As String) As Date
  MyFileDateTime = 0
  On Error GoTo nogo
  If UCase(Left(fname, 5)) = "HTTP:" Or UCase(Left(fname, 6)) = "HTTPS:" Then
    Dim sz As Long
    Dim modDate As Date
    If URLExists(fname, sz, modDate) Then
      MyFileDateTime = modDate
    End If
  Else
    MyFileDateTime = FileDateTime(fname)
  End If
  Exit Function
nogo:
'  DebugPrint tdebug, "MyFileDateTime failed for: '" & fname & "' - " & Err.Number & " - " & Err.Description
End Function



Public Function ShortFileName(ByVal long_name As String) As String
    If UCase(Left(long_name, 5)) = "HTTP:" Or UCase(Left(long_name, 6)) = "HTTPS:" Then
      ShortFileName = long_name
      Exit Function
    End If
    
    'Returns the short filename associated w
    '     ith sLongFilename
    Dim lRet As Long
    Dim sShortFilename As String
    'First attempt using 1024 character buff
    '     er.
    sShortFilename = String$(1024, " ")
    lRet = GetShortPathName(long_name, sShortFilename, Len(sShortFilename))
    
    'If buffer is too small lRet contains bu
    '     ffer size needed.


    If lRet > Len(sShortFilename) Then
        'Increase buffer size...
        sShortFilename = String$(lRet + 1, " ")
        'and try again.
        lRet = GetShortPathName(long_name, sShortFilename, Len(sShortFilename))
    End If
    
    'lRet contains the number of characters
    '     returned.


    If lRet > 0 Then
        ShortFileName = Left$(sShortFilename, lRet)
    End If
    
    If Trim(ShortFileName) = "" Then
      ShortFileName = long_name
    End If
    
End Function

Function FileExists(ByVal Dateiname$) As Boolean
    'Die Funktion pr|fffd|ft, ob eine Datei vorhanden ist
On Error GoTo fehler:
  Dim res As Boolean
  If UCase(Left(Dateiname, 5)) = "HTTP:" Or UCase(Left(Dateiname, 6)) = "HTTPS:" Then
    Dim sz As Long
    Dim modDate As Date
    FileExists = URLExists(Dateiname, sz, modDate)
  Else
    res = Dir$(Dateiname) <> ""
    If res = False Then
      res = Dir$(GetDriveAndPathFromUNC(Dateiname)) <> ""
    End If
    FileExists = res
  End If
    Exit Function
fehler:
    FileExists = False
    Resume Next
End Function
Function URLExists(url As String, ByRef sz As Long, ByRef modDate As Date) As Boolean
    Dim Request As Object
    Dim ff As Integer
    Dim rc As Variant
    On Error GoTo EndNow
    sz = 0
    modDate = 0
    URLExists = False
    Set Request = CreateObject("MSXML2.XMLHTTP")
    With Request
      .Open "HEAD", url, False
      Request.SetRequestHeader "Cache-Control", "no-store, no-cache"
      Request.SetRequestHeader "Pragma", "no-cache"
      .Send
      If .readyState = 4 Then
        URLExists = True
        sz = .getResponseHeader("Content-Length")
        Dim s As String
        s = Mid(Request.getResponseHeader("Last-Modified"), 6, 1000)
        s = Left(s, Len(s) - 4)
        modDate = CDate(s)
      Else
        .abort
      End If
    End With
    Set Request = Nothing
    Exit Function
EndNow:
    Debug.Print Err.Description
    Set Request = Nothing
End Function


Sub LogPrintECCSCanLog(ByVal id As Long, ByVal status As Long, ByVal str As String, Optional writeFileStatusInfoForScheduler As Boolean = False)
  If StartedByTracker Then
    DebugPrint tToFile, "ACC" & MyACCVersion & " - " & str, status, 0, id, True
'    If writeFileStatusInfoForScheduler Then
      SetFileStatusInfo str
'    End If
    If status > 0 Then
      SaveSetting appname:="Stromwerken", Section:="IDVSS", Key:="ACCScanResult" & status, setting:=GetSetting(appname:="Stromwerken", Section:="IDVSS", Key:="ACCScanResult" & status, Default:=0) + 1
    End If
  End If
  
End Sub

Function GetTempPath() As String
  Dim RetVal As Long
  Dim pathbuffer As String * 512
  
  Dim l As Long
  l = apiGetTempPath(512, pathbuffer)
  If l > 0 Then
    GetTempPath = Trim(Left(pathbuffer, l))
  End If
End Function


Private Function FOpen(fname As String, ByRef fn As Long) As Boolean
  On Error GoTo nogo
  Open fname For Binary Access Read As fn
  FOpen = True
  Exit Function
nogo:
        
End Function

Private Function FOpenWrite(fname As String, ByRef fn As Long) As Boolean
  On Error GoTo nogo
  Open fname For Binary Access Write As fn
  FOpenWrite = True
  Exit Function
nogo:
        
End Function

Private Function FClose(ByRef fn As Long) As Boolean
  On Error GoTo nogo
  Close fn
  FClose = True
  Exit Function
nogo:
        
End Function
Function SplitFile(ByVal Filename As String, ByVal splitSize As Long, ByRef splitFilenames() As String) As Boolean

    SplitFile = False

On Error GoTo nogo
    
    Dim fileLen As Long
    fileLen = MyFileLen(Filename)
    
    ' wenn wir kleiner sind als 1 Split, dann wird nicht gesplitted
    If fileLen <= splitSize Then
        Exit Function
    End If

    Dim steps As Long
    ' Integer Division, da muss man ein \ nehmen
    steps = (fileLen \ splitSize)
    Dim remainingSize As Long
    remainingSize = fileLen Mod splitSize
    ' wenn es genau ein Vielfaches der SplitSize ist, dann m|fffd|ssen wir einen Split weniger machen
    If remainingSize = 0 Then
        steps = steps - 1
    End If
        
    Dim fn As Long
    fn = FreeFile
    
    Dim einMB As Long
    einMB = CLng(1024) * CLng(1024)

    SplitFile = True
    
    ReDim Preserve splitFilenames(steps)

    Dim buffer(CLng(1024) * CLng(1024) - CLng(1)) As Byte
    Dim BufferRemaining() As Byte
    If FOpen(Filename, fn) Then
        Dim step
        For step = 0 To steps
            Dim fnOut As Long
            fnOut = FreeFile
            
            Dim fileNameOutput As String
            fileNameOutput = Filename & "_" & step
            If FOpenWrite(fileNameOutput, fnOut) Then
                
                splitFilenames(step) = fileNameOutput
                
                Dim internalSteps As Long
                internalSteps = splitSize / einMB
                
                Dim intStep
                For intStep = 0 To internalSteps - 1
                    Dim strData As String
                    
                    If fileLen <= einMB Then
                        ReDim BufferRemaining(fileLen - 1)
                        Get #fn, , BufferRemaining
                        Put #fnOut, , BufferRemaining
                        fileLen = 0
                        Exit For
                    Else
                        Get #fn, , buffer
                        Put #fnOut, , buffer
                    End If
                    fileLen = fileLen - einMB
                Next
                Close #fnOut
            Else
                ' nicht geklappt, alles wieder l|fffd|schen
                SplitFile = False
                ' auf jeden Fall aufh|fffd|ren
                step = steps + 1
                Exit For
            End If
        Next
        Close #fn
    End If

    Exit Function
nogo:
    SplitFile = False
End Function

Public Function CreateTempFile(sPrefix As String) As String
   Dim sTmpPath As String * 512
   Dim sTmpName As String * 576
   Dim nRet As Long

   nRet = apiGetTempPath(512, sTmpPath)
   If (nRet > 0 And nRet < 512) Then
      nRet = GetTempFileName(sTmpPath, sPrefix, 0, sTmpName)
      If nRet <> 0 Then
         CreateTempFile = Left$(sTmpName, _
            InStr(sTmpName, vbNullChar) - 1)
         MyKill CreateTempFile
      End If
   End If
End Function

Function GetFileName(ByVal fn As String) As String
    Dim File As String
    Dim path As String
    Dim ext As String

    fileSplit fn, path, File, ext
    GetFileName = File
End Function


Function GetFilePath(ByVal fn As String)
    Dim File As String
    Dim path As String
    Dim ext As String
    
    fileSplit fn, path, File, ext
    GetFilePath = Left(path, Len(path) - 1)
End Function

Function GetFileNameAndPath(ByVal fn As String)
    Dim File As String
    Dim path As String
    Dim ext As String
    
    fileSplit fn, path, File, ext
    GetFileNameAndPath = path & File
End Function

Function GetFileExtension(ByVal fn As String)
    Dim File As String
    Dim path As String
    Dim ext As String
    
    fileSplit fn, path, File, ext
    GetFileExtension = ext
End Function

Public Function MyGetTempFilename(ByVal temppath As String, ByVal sPrefix As String) As String
   Dim sTmpName As String * 576
   Dim nRet As Long

   nRet = GetTempFileName(temppath, "TMP", 0, sTmpName)
   If nRet <> 0 Then
     MyGetTempFilename = Left$(sTmpName, InStr(sTmpName, vbNullChar) - 1)
     MyKill MyGetTempFilename
     MyGetTempFilename = temppath & "\" & sPrefix & GetFileNameAndExtension(MyGetTempFilename)
   End If
End Function

' Wenn d zwischen t1 und t2 liegt true, ansonsten false
' t1 und t2 sind immer die Stunden eines Tages. Wenn t2 kleiner t1 ist, dann wird |fffd|ber Mitternacht gerechnet
Function TimeInScope(d As Date, t1 As Date, t2 As Date) As Boolean
  ' Erst mal die Tagesiformationen loswerden
  t1 = GetTime(t1)
  t2 = GetTime(t2)
  d = GetTime(d)

  TimeInScope = False

  ' Z.B. zwischen 08:00:00 und 09:00:00
  If t1 < t2 Then
      If t1 <= d And d <= t2 Then
          TimeInScope = True
      End If
  Else
      If d >= t1 Or d <= t2 Then
          TimeInScope = True
      End If
  End If
End Function

Function GetTime(d As Date) As Date
  On Error Resume Next
  GetTime = CDate("00:00:00")
  GetTime = CDate(Right(CStr(d), 8))
End Function

Attribute VB_Name = "INetCheckVersion"
Option Explicit


Public G_InternetVersion As String
Public G_InternetAvailable As Boolean
Public G_InternetInternalVersion As Long
Public G_InternetLicenseVersion As Long
Public G_UpdateAvailable As Boolean
Public G_UpdateString As String
Public G_MyLicencseVersion As Long
Public G_Wartung As Boolean
Public G_WartungBis As Date

Public G_UpdateText As String
Public G_Lizenzen As Long
Public G_FullDemoBis As Date

Public G_Lizenznehmer As String
Public G_LizenznehmerAdresse As String


'Declares for direct ping
#If VBA7 Then
Private Declare PtrSafe Function InternetOpen Lib "wininet.dll" Alias "InternetOpenA" (ByVal lpszAgent As String, ByVal dwAccessType As Long, ByVal lpszProxyName As String, ByVal lpszProxyBypass As String, ByVal dwFlags As Long) As Long
Private Declare PtrSafe Function InternetOpenUrl Lib "wininet.dll" Alias "InternetOpenUrlA" (ByVal hInet As LongPtr, ByVal lpszUrl As String, ByVal lpszHeaders As String, ByVal dwHeadersLength As Long, ByVal dwFlags As Long, ByVal dwContext As Long) As Long
Private Declare PtrSafe Function InternetCloseHandle Lib "wininet.dll" (ByVal hInet As LongPtr) As Long
Private Declare PtrSafe Function InternetReadFile Lib "wininet.dll" _
    (ByVal hFile As LongPtr, ByVal sBuffer As String, ByVal lNumBytesToRead As Long, _
    lNumberOfBytesRead As LongPtr) As Integer
Private Declare PtrSafe Function InternetGetLastResponseInfo Lib "wininet.dll" Alias "InternetGetLastResponseInfoA" _
    (lpdwError As Long, ByVal lpszBuffer As String, ByVal lpdwBufferLength As Long) As Integer
#Else
Private Declare Function InternetOpen Lib "wininet.dll" Alias "InternetOpenA" (ByVal lpszAgent As String, ByVal dwAccessType As Long, ByVal lpszProxyName As String, ByVal lpszProxyBypass As String, ByVal dwFlags As Long) As Long
Private Declare Function InternetOpenUrl Lib "wininet.dll" Alias "InternetOpenUrlA" (ByVal hInet As Long, ByVal lpszUrl As String, ByVal lpszHeaders As String, ByVal dwHeadersLength As Long, ByVal dwFlags As Long, ByVal dwContext As Long) As Long
Private Declare Function InternetCloseHandle Lib "wininet.dll" (ByVal hInet As Long) As Long
Private Declare Function InternetReadFile Lib "wininet.dll" _
    (ByVal hFile As Long, ByVal sBuffer As String, ByVal lNumBytesToRead As Long, _
    lNumberOfBytesRead As Long) As Integer
Private Declare Function InternetGetLastResponseInfo Lib "wininet.dll" Alias "InternetGetLastResponseInfoA" _
    (lpdwError As Long, ByVal lpszBuffer As String, ByVal lpdwBufferLength As Long) As Integer
#End If

Private Const INTERNET_OPEN_TYPE_PRECONFIG = 0
Private Const INTERNET_FLAG_RELOAD = &H80000000
Private Const INTERNET_FLAG_KEEP_CONNECTION = &H400000
Private Const INTERNET_FLAG_NO_CACHE_WRITE = &H4000000

Dim hInet As Long
Dim hUrl As Long
Dim Flags As Long
Dim url As Variant

Function GetLine(ByRef txt As String) As String
  Dim pos As Long
  Dim res As String
  pos = InStr(txt, vbCr)
  If pos > 0 Then
    res = Left(txt, pos - 1)
  Else
    res = txt
  End If
  If pos > 0 Then
    txt = Mid(txt, 2 + pos)
  Else
    txt = ""
  End If
  
  GetLine = res

End Function


Public Function CheckINetConnection() As Boolean
  hInet = InternetOpen(" ", INTERNET_OPEN_TYPE_PRECONFIG, vbNullString, vbNullString, 0&)
  If hInet Then
    Flags = INTERNET_FLAG_KEEP_CONNECTION Or INTERNET_FLAG_NO_CACHE_WRITE Or INTERNET_FLAG_RELOAD
    hUrl = InternetOpenUrl(hInet, "http://www.stromwerke.de", vbNullString, 0, Flags, 0)
    If hUrl Then
        CheckINetConnection = True
        Call InternetCloseHandle(hUrl)
      Else
        CheckINetConnection = False
      End If
   End If
   Call InternetCloseHandle(hInet)
End Function

Public Sub CheckVersion(checkEveryDays As Long, sec As String, fname As String, fname2 As String, currentVersion As String, internalCurrentVersion As Long)

On Error GoTo exitfunc

  G_InternetVersion = "Nicht verbunden"
  G_InternetAvailable = False
  G_UpdateAvailable = False

  Dim d As Date
 
  SaveSetting _
     appname:="Stromwerken", _
     Section:=sec, _
     Key:="VersionDate", _
     setting:=Now
     
     
  Dim ret As String
  Dim ret2 As String
  
     
  If LoadInetFile(fname, ret) = True And LoadInetFile(fname2, G_UpdateText) = True Then
  
        G_InternetVersion = GetLine(ret)
        If Left(G_InternetVersion, 2) = "<!" Then
          G_InternetAvailable = False
          G_InternetVersion = "Nicht verf|fffd|gbar"
          Exit Sub
        Else
        
          G_InternetInternalVersion = CLng(GetLine(ret))
          G_UpdateString = GetLine(ret)
          G_InternetLicenseVersion = CLng(GetLine(ret))
          
          G_InternetAvailable = True
            
          If internalCurrentVersion < G_InternetInternalVersion Then
          
            G_UpdateAvailable = True
            
            d = GetSetting( _
               appname:="Stromwerken", _
               Section:=sec, _
               Key:="VersionDate", Default:=DateSerial(2000, 1, 1))
            
            If DateAdd("d", checkEveryDays, d) <= Now Then
              CheckInternetUpdateMenu
            End If
            
          End If
        End If
  End If
  Exit Sub

exitfunc:
  Exit Sub
  
End Sub

Function DoThat(t As String) As String

    Dim i As Long
    Dim s2 As String
    For i = 1 To Len(t)
        If Mid(t, i, 1) = "@" Then
            s2 = s2 + vbLf
        ElseIf Mid(t, i, 1) = "^" Then
            s2 = s2 + " "
        ElseIf Mid(t, i, 1) >= "0" And Mid(t, i, 1) <= "9" Then
          s2 = s2 + Chr(Asc("0") + Asc("9") - Asc(Mid(t, i, 1)))
        ElseIf Mid(t, i, 1) >= "a" And Mid(t, i, 1) <= "z" Then
          s2 = s2 + Chr(Asc("a") + Asc("z") - Asc(Mid(t, i, 1)))
        ElseIf Mid(t, i, 1) >= "A" And Mid(t, i, 1) <= "Z" Then
          s2 = s2 + Chr(Asc("A") + Asc("Z") - Asc(Mid(t, i, 1)))
        Else
            s2 = s2 + Mid(t, i, 1)
        End If
    Next i
    
    DoThat = s2
End Function



Function GetSWResItem(ByVal pos As Long, ff As Long) As String
  Dim res As String
  
  If FileExists(G_cfgKeypfad & "\swres.swk") Then
    Open G_cfgKeypfad & "\swres.swk" For Binary Access Read As #ff ' Len = 4
  ElseIf FileExists(ThisWorkbook.path & "\swres.swk") Then
    Open ThisWorkbook.path & "\swres.swk" For Binary Access Read As #ff ' Len = 4
  Else
    Exit Function
  End If
  
  Dim l As Long
  Get #ff, pos, l

  Dim charc As Long

  ' ENC2
  If l = 1 Then
    Get #ff, pos + 4, l
  
  
  '  Close ff
  '  Open AktVerz & "\swres.swk" For Binary Access Read As #ff ' Len = 1
    For charc = 1 To l
      Dim tchar As Byte
      Get #ff, pos + 7 + charc, tchar
      tchar = tchar Xor (1 + 2 + 4 + 16 + 64)
      res = res & Chr(tchar)
    Next charc
    Close ff
    Do
      pos = InStr(res, "\n")
      If pos <= 0 Then Exit Do
      res = Left(res, pos - 1) & vbCrLf & Mid(res, pos + 2)
    Loop
    GetSWResItem = res
  
  ' ENC3 - LZW
  ElseIf l = 2 Then
    Get #ff, pos + 4, l
  
  '  Close ff
  '  Open AktVerz & "\swres.swk" For Binary Access Read As #ff ' Len = 1
    Dim lval As Long
    Dim arr() As Long
    ReDim arr(l)
    
    For charc = 1 To l
      Get #ff, pos + 4 + charc * 4, lval
      arr(charc - 1) = lval
    Next charc
    Close ff
    
    Dim LZW As New LZW
    res = LZW.DecompressArray(l, arr)
    Set LZW = Nothing
    
    Do
      pos = InStr(res, "\n")
      If pos <= 0 Then Exit Do
      res = Left(res, pos - 1) & vbCrLf & Mid(res, pos + 2)
    Loop
    GetSWResItem = res
  End If
End Function

Sub GetData()
  On Error GoTo noData
  
  G_Lizenzen = -3
  G_ACCPro = False
  
  If FileExists(G_cfgKeypfad & "\swres.swk") Or FileExists(ThisWorkbook.path & "\swres.swk") Then
    Dim ff As Long
    ff = FreeFile
    Dim s As String
    
    s = GetSWResItem(1000, ff)
    If InStr(s, "ACC,") > 0 Or InStr(s, "ACCPRO,") > 0 Then
    
      If InStr(s, "ACCPRO,") > 0 Then
        G_ACCPro = True
      End If
    
      G_Lizenznehmer = GetSWResItem(2000, ff)
      G_LizenznehmerAdresse = GetSWResItem(2400, ff)
      G_MyLicencseVersion = Val(GetSWResItem(4200, ff))
      G_Lizenzen = Val(GetSWResItem(4300, ff))
      
      
'      s = GetSWResItem(3200, ff)
      s = ConvGermanDate(GetSWResItem(4400, ff))
      If Len(s) > 0 Then
        If IsDate(s) Then
          G_FullDemoBis = CDate(s)
        End If
      End If
      G_Wartung = IIf(UCase(GetSWResItem(4500, ff)) = "JA", True, False)
      
      If G_Wartung Then
        ' s = GetSWResItem(3400, ff)
        s = ConvGermanDate(GetSWResItem(4600, ff))
        If Len(s) > 0 Then
          If IsDate(s) Then
            G_WartungBis = CDate(s)
          End If
        End If
      End If
      
      FullVersion = True
      
      If G_Lizenzen = -1 Then
        'trs = "Full-Demo" & vbCrLf & vbCrLf & G_Lizenznehmer & vbCrLf & G_LizenznehmerAdresse & vbCrLf & vbCrLf & "Einsatz nur zu Testzwecken!"
        trs = FMT2("INETCHKV_1", G_Lizenznehmer, G_LizenznehmerAdresse)
        'trsShrt = "Full-Demo " & G_Lizenznehmer & " - Einsatz nur zu Testzwecken!"
        trsShrt = FMT1("INETCHKV_2", G_Lizenznehmer)
      ElseIf G_Lizenzen = 0 And Now < G_FullDemoBis Then
        'trs = "Full-Demo bis zum " & G_FullDemoBis & vbCrLf & vbCrLf & G_Lizenznehmer & vbCrLf & vbCrLf & G_LizenznehmerAdresse
        trs = FMT3("INETCHKV_3", G_FullDemoBis, G_Lizenznehmer, G_LizenznehmerAdresse)
        'trsShrt = "Full-Demo bis zum " & G_FullDemoBis & " - " & G_Lizenznehmer
        trsShrt = FMT2("INETCHKV_4", G_FullDemoBis, G_Lizenznehmer)
      ElseIf G_Lizenzen = 0 And Now >= G_FullDemoBis Then
        'trs = "Demoversion" & vbCrLf & vbCrLf & G_Lizenznehmer & vbCrLf & vbCrLf & G_LizenznehmerAdresse
        trs = FMT2("INETCHKV_5", G_Lizenznehmer, G_LizenznehmerAdresse)
        'trsShrt = "Demoversion " & G_Lizenznehmer
        trsShrt = FMT1("INETCHKV_6", G_Lizenznehmer)
      ElseIf G_Lizenzen = -2 Then
        'trs = "Gesamthauslizenz" & vbCrLf & vbCrLf & G_Lizenznehmer & vbCrLf & vbCrLf & G_LizenznehmerAdresse
        trs = FMT2("INETCHKV_7", G_Lizenznehmer, G_LizenznehmerAdresse)
        'trsShrt = "Gesamthauslizenz " & G_Lizenznehmer
        trsShrt = FMT1("INETCHKV_8", G_Lizenznehmer)
      ElseIf G_Lizenzen = 1 Then
        'trs = G_Lizenzen & " Lizenz" & vbCrLf & vbCrLf & G_Lizenznehmer & vbCrLf & vbCrLf & G_LizenznehmerAdresse
        trs = FMT3("INETCHKV_9", G_Lizenzen, G_Lizenznehmer, G_LizenznehmerAdresse)
        'trsShrt = G_Lizenzen & "Lizenz " & G_Lizenznehmer
        trsShrt = FMT2("INETCHKV_10", G_Lizenzen, G_Lizenznehmer)
      Else
        'trs = G_Lizenzen & " Lizenzen" & vbCrLf & vbCrLf & G_Lizenznehmer & vbCrLf & vbCrLf & G_LizenznehmerAdresse
        trs = FMT3("INETCHKV_11", G_Lizenzen, G_Lizenznehmer, G_LizenznehmerAdresse)
        'trsShrt = G_Lizenzen & "Lizenzen " & G_Lizenznehmer
        trsShrt = FMT2("INETCHKV_12", G_Lizenzen, G_Lizenznehmer)
      End If
      
      If G_Wartung Then
        'trs = trs & vbCrLf & vbCrLf & IIf(G_WartungBis <> 0, "Wartung bis: " & G_WartungBis & IIf(Now > G_WartungBis, " (ABGELAUFEN)", ""), "")
        trs = trs & vbCrLf & vbCrLf & IIf(G_WartungBis <> 0, FMT1("INETCHKV_13", G_WartungBis) & IIf(Now > G_WartungBis, FMT0("INETCHKV_14"), ""), "")
      End If
      
    End If
  Else
    GetDataOld
  End If
  
  
noData:
  Exit Sub
End Sub


Sub CheckInternetUpdateMenu()


  If G_MyLicencseVersion < G_InternetLicenseVersion And FullVersion = True Then
    'INetUpdate.Headline.Caption = "Im Internet liegt eine neue Version des Programms vor."
    INetUpdate.Headline.Caption = FMT0("INETCHKV_15")
    'INetUpdate.Kostenpflichtig.Caption = "Die neue Version ist kostenpflichtig. Bitte wenden Sie sich an info@stromwerken.de, um eine Update-Lizenz zu erwerben. Ohne neuen Lizenz-Key l|fffd|uft das Programm als DEMO!"
    INetUpdate.Kostenpflichtig.Caption = FMT0("INETCHKV_16")
  Else
    'INetUpdate.Headline.Caption = "Im Internet liegt eine neue Version des Programms vor."
    INetUpdate.Headline.Caption = FMT0("INETCHKV_15")
    INetUpdate.Kostenpflichtig.Caption = ""
  End If
  
  INetUpdate.UpdateText = G_UpdateText
  
  INetUpdate.Show
End Sub



Public Function LoadInetFile(fname As String, ByRef ret As String, Optional fsize As Long = 0) As Boolean
  Dim hInet As Long
  Dim hUrl As Long
  Dim Flags As Long
  Dim url As Variant
  
  LoadInetFile = False
  
  hInet = InternetOpen(" ", INTERNET_OPEN_TYPE_PRECONFIG, vbNullString, vbNullString, 0&)
  If hInet Then
    Flags = INTERNET_FLAG_KEEP_CONNECTION Or INTERNET_FLAG_NO_CACHE_WRITE Or INTERNET_FLAG_RELOAD
    hUrl = InternetOpenUrl(hInet, "http://www.stromwerken.de/" & fname, vbNullString, 0, Flags, 0)
    If hUrl Then
        
        Dim sReadBuf As String * 1024
        Dim flagMoreData As Boolean
        Dim bytesRead As Long
        Dim wRet As Integer
        Dim lastErr As Long
        Dim s As String
        
        flagMoreData = True
        Do While flagMoreData
            sReadBuf = vbNullString
            wRet = InternetReadFile(hUrl, sReadBuf, Len(sReadBuf), bytesRead)
            If Err.LastDllError <> 0 Then
                lastErr = Err.LastDllError
                ret = "Error (wininet.dll," & lastErr & ")"
                GoTo exitfunc
            End If
            If wRet <> 1 Then
                ret = "Error"
                GoTo exitfunc
            End If
            s = s & Left$(sReadBuf, bytesRead)
            If Not CBool(bytesRead) Then flagMoreData = False
        Loop
        ret = s
        
        Call InternetCloseHandle(hUrl)
        Call InternetCloseHandle(hInet)
        LoadInetFile = True
        Exit Function
    Else
      Call InternetCloseHandle(hInet)
    End If
  End If
  Exit Function

exitfunc:
    If hUrl <> 0 Then InternetCloseHandle (hUrl)
    If hInet <> 0 Then InternetCloseHandle (hInet)
End Function






Attribute VB_Name = "INetUpdate"
Attribute VB_Base = "0{9982B8F7-2F0B-47CE-B0A0-1E917F2732E4}{F0E5BCCB-983C-4E7D-89CB-DC0A3B60CB02}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Sub cmdAbbrechen_Click()
  Me.Hide
End Sub

Private Sub cmdDownload_Click()
  Me.Hide
  On Error Resume Next
  Call Shell("explorer.exe " & G_UpdateString, 1)
  ThisWorkbook.Close False
End Sub

Private Sub UserForm_Initialize()
  gTranslation.TranslateForm Me
End Sub
Attribute VB_Name = "LForItem"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public m_Prefix As String
Public m_Val As String
Public m_X As Long
Public m_Y As Long

Attribute VB_Name = "LZW"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

'Private Data Members
Private flgFirstTime As Boolean
Private arr() As String
Private m_CharacterBytesCount As Integer


'Properties
Public Property Get CharacterBytesCount() As Integer
    CharacterBytesCount = m_CharacterBytesCount
End Property

Public Property Let CharacterBytesCount(ByVal vNewValue As Integer)
    m_CharacterBytesCount = vNewValue
End Property

'Private Methods
Private Function Add(ByVal Entry As String) As Long

   If flgFirstTime Then
        flgFirstTime = False
    Else
        ReDim Preserve arr(UBound(arr) + 1)
    End If
    
    arr(UBound(arr)) = Entry
    'Arr(UBound(Arr)).Code = ubund(
    
    Add = UBound(arr)
    
End Function

Private Function IsExists(ByVal Entry As String) As Boolean
    Dim i As Long
    Dim flg As Boolean
    flg = False
    
    For i = LBound(arr) To UBound(arr)
        If arr(i) = Entry Then
            flg = True
            Exit For
        End If
    Next i
    
    IsExists = flg
    
End Function

Private Function IsIndexExists(ByVal index As Long) As Boolean
    
    Dim flg As Boolean
    flg = False
    
    If index <= UBound(arr) Then
        flg = True
    Else
        flg = False
    End If
    
    IsIndexExists = flg
    
End Function

Private Function GetValue(ByVal index As Long) As String
    If IsIndexExists(index) Then
        GetValue = arr(index)
    Else
        GetValue = ""
    End If
End Function

Private Function GetIndexOf(ByVal Entry As String) As Long
    
    Dim i As Long
    Dim ReturnCode As Long
    ReturnCode = -1
    
    For i = LBound(arr) To UBound(arr)
        If arr(i) = Entry Then
            ReturnCode = i
            Exit For
        End If
    Next i
    
    GetIndexOf = ReturnCode
    
End Function

Private Sub Class_Initialize()
    ReDim arr(0) As String
    flgFirstTime = True
    m_CharacterBytesCount = 2
End Sub

Private Function mrtLeft(ByVal InputString As String, ByVal Length As Long) As String
    If Len(InputString) >= Length Then
        mrtLeft = Left(InputString, Length)
    Else
        mrtLeft = InputString
    End If
End Function

Private Sub InitializeDictionary()
    Dim i As Long
    For i = 0 To (2 ^ (m_CharacterBytesCount * 8)) - 1
        Add (ChrW(i))
    Next
End Sub

Private Function Length() As Long
    Length = UBound(arr)
End Function

'Public methods
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Public Function Compress(ByVal UncompressedData As String, ByRef valam As Long, ByRef arr() As Long) As String

    Dim w As String
    Dim c As String
    Dim wc As String
    'Dim dic As New Dictionary
    Dim Output As String
    Dim code As Long
    
    Dim i As Long
    InitializeDictionary
    valam = 0
    
    ReDim arr(1024)
    Dim curarrsize As Long
    curarrsize = 1024
     
    w = ""
    For i = 1 To Len(UncompressedData)
        
        c = Mid(UncompressedData, i, 1)
        wc = w + c
        If IsExists(wc) Then
            w = wc
        Else
            code = Add(wc)
            code = GetIndexOf(w)
            Output = Output & IIf(Output = "", "", ",") & code
            arr(valam) = code
            valam = valam + 1
            If valam > curarrsize Then
              curarrsize = curarrsize + 1024
              ReDim Preserve arr(curarrsize)
            End If
            w = c
        End If
        
        '?
    
    Next i
    
    Output = Output & IIf(Output = "", "", ",") & GetIndexOf(w)
    arr(valam) = GetIndexOf(w)
    valam = valam + 1
    
    Compress = Output

End Function


Public Function DecompressArray(valam As Long, arr() As Long) As String
  Dim compresseddata As String
  Dim i As Long
  For i = 0 To valam - 1
    compresseddata = compresseddata & IIf(compresseddata = "", "", ",") & arr(i)
  Next i
  DecompressArray = Decompress(compresseddata)
End Function

Public Function Decompress(ByVal compresseddata As String) As String
    
    If compresseddata = "" Then Exit Function
    
    'Dim dic As New Dictionary
    
    InitializeDictionary

    Dim Output As String
    Dim Entry As String

    Dim K As String
    Dim w As String
    Dim i As Long
    
    Dim arrCompressedData() As String
    ListSplit arrCompressedData, compresseddata, "," '  arrCompressedData = Split(compresseddata, ",")
    
    K = arrCompressedData(0)
    Output = Output & GetValue(K)
    w = K
    
    For i = 1 To UBound(arrCompressedData)
    
        K = arrCompressedData(i)
        
        If IsIndexExists(K) Then
        
            Entry = GetValue(K)
            
        ElseIf IsIndexExists(K) = False And K = Length + 1 Then
            
            Entry = GetValue(w) + mrtLeft(GetValue(w), 1)
            
        Else
        
            'MsgBox "Bad compressed."
            Dim errMsg As String
            errMsg = "Bad compressed."
            MsgBox errMsg
            
        End If
        
        Output = Output + Entry
        
        Add (GetValue(w) + mrtLeft(Entry, 1))
        
        w = GetIndexOf(Entry)
        
    Next
    
    Decompress = Output
    
End Function


 Function ListSplit(ArrayReturn() As String, ByVal StringToSplit As String, _
 SplitAt As String) As Integer
   Dim intInstr As Integer
   Dim intCount As Integer
   Dim strTemp As String

   intCount = -1
   intInstr = InStr(StringToSplit, SplitAt)
   Do While intInstr > 0
     intCount = intCount + 1
     ReDim Preserve ArrayReturn(0 To intCount)
     ArrayReturn(intCount) = Left(StringToSplit, intInstr - 1)
     StringToSplit = Mid(StringToSplit, intInstr + 1)
     intInstr = InStr(StringToSplit, SplitAt)
   Loop
   If Len(StringToSplit) > 0 Then
     intCount = intCount + 1
     ReDim Preserve ArrayReturn(0 To intCount)
     ArrayReturn(intCount) = StringToSplit
   End If
   ListSplit = intCount
 End Function







Attribute VB_Name = "MainMenu"
Attribute VB_Base = "0{A2659175-40F9-48F3-B836-73A637F62361}{5BE01FC3-A23D-48FE-B94E-9D62D3B8182D}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public Function AnyAccessVersionEnabled() As Boolean
  If V8.Enabled = False And V9.Enabled = False And V10.Enabled = False And V11.Enabled = False And V12.Enabled = False And _
      V14.Enabled = False And V15.Enabled = False And V16.Enabled = False Then
    AnyAccessVersionEnabled = False
  Else
    AnyAccessVersionEnabled = True
  End If
End Function

Private Sub AktualisierungenSuchen_Click()
  SaveSetting _
     appname:="Stromwerken", _
     Section:=ProgNameShort, _
     Key:="NoAutoUpdate", _
     setting:=0

  CheckVersion 1, "ACC", "ACCVersionN.txt", "ACCVersionN2.txt", MyVersion, MyInternalVersion

End Sub

Private Sub Analyse_Click()
  Dim tFname
  'tFname = Application.GetOpenFileName("Access-Dateien,*.md*;*.acc*", 1, "Datei ausw|fffd|hlen")
  tFname = Application.GetOpenFileName(FMT0("MAIN_7") & ",*.md*;*.acc*", 1, FMT0("MAIN_8"))
  If tFname = False Then Exit Sub
  theFilename = tFname
  
  Me.Hide
  StatusForm.Filename = ""
  StatusForm.ProgText = ""
  StatusForm.ProgressB.Width = 0
  ProgText = ""
  LastProgText = ""
  
  theTrackerShowStatusform = True
  Application.OnTime Now + TimeValue("00:00:03"), "DoEinzelanalyse"
  StatusForm.Show
End Sub

Private Sub Label16_Click()
  On Error Resume Next
  'Call Shell("explorer.exe http://www.stromwerken.de", 1)
  Call Shell("explorer.exe " & FMT0("INETLINK_1"), 1)
End Sub

Private Sub ProgrammBeenden_Click()
  Me.Hide
End Sub

Private Sub UserForm_Initialize()
  gTranslation.TranslateForm Me
End Sub
Attribute VB_Name = "PW"
Option Explicit

    Public Sub SortiereIndex(ByVal zeile As String, ByRef zIndex() As Long)
        Dim i As Long
        Dim l As Long

        For i = 1 To 8
            Dim kl As String
            kl = Mid(zeile, i, 1)
            Dim klindex As Integer
            klindex = 1
            For l = 2 To 8
                If kl = " " Or Mid(zeile, l, 1) < kl Then
                    If Mid(zeile, l, 1) <> " " Then
                        kl = Mid(zeile, l, 1)
                        klindex = l
                    End If
                End If
            Next
            zIndex(i) = klindex
            Mid(zeile, klindex, 1) = " "
        Next
    End Sub

    Public Function FirmenPasswort(ByVal firmenname As String) As String
        Dim zeichen(8) As String
        
        firmenname = Replace(firmenname, vbCr, "")
        firmenname = Replace(firmenname, vbLf, "")
        firmenname = Replace(firmenname, vbTab, "")

        zeichen(3) = "mnbvcxy&"
        zeichen(4) = "ASDFGHJK"
        zeichen(5) = "12345678"
        zeichen(6) = "QWER?\{}"
        zeichen(7) = "&[]*+-/|fffd|"
        zeichen(8) = "!(/&abcd"

        Dim zeile As String
        Dim spalte As String

        zeile = ""
        spalte = ""

        Dim i As Long
        Dim l As Long
        Dim m As Long
        If Len(firmenname) < 16 Then
            firmenname = firmenname & Left("Ein16stellenText", 16 - Len(firmenname))
        End If
        m = Len(firmenname) / 2
        For i = 0 To 3
            zeile = zeile & Mid(firmenname, m - i, 1)
            zeile = zeile & Mid(firmenname, m + i + 1, 1)
            spalte = spalte & Mid(firmenname, m - i - 4, 1)
            spalte = spalte & Mid(firmenname, m + i + 5, 1)
        Next i
        zeile = Replace(zeile, " ", "A")
        spalte = Replace(spalte, " ", "B")
        zeichen(1) = zeile
        zeichen(2) = spalte

        ' Sortieren und Indizes merken
        Dim zIndex(8) As Long
        Dim sindex(8) As Long
        SortiereIndex zeile, zIndex
        SortiereIndex spalte, sindex

        For i = 1 To 8
            Dim z As String
            z = ""
            For l = 1 To 8
                z = z & Mid(zeichen(i), zIndex(l), 1)
            Next
            zeichen(i) = z
        Next

        Dim result(8) As String

        For i = 1 To 8
            result(i) = "00000000"
        Next

        Dim s As Long
        For s = 1 To 8
            For l = 1 To 8
                Mid(result(l), s, 1) = Mid(zeichen(sindex(l)), s, 1)
            Next
        Next

        FirmenPasswort = result(1) & result(2) & result(3) & result(4) & result(7) & result(8)

    End Function

Public Function GetStandardPassword() As String
    GetStandardPassword = FirmenPasswort(G_LizenznehmerAdresse)  ' "NDR9)oio0(rrl5/mfk677&" & Left(G_Lizenznehmer & "        ", 8)
End Function

Public Function GetFileOpenPassword(ByRef rs As Object) As String
    GetFileOpenPassword = ""
On Error GoTo fehler
    If Not rs Is Nothing Then
        Dim berechtigungAn As Boolean
        berechtigungAn = False
        If rs.Fields("Dateiberechtigungen").value <> 0 Then
            berechtigungAn = True
        End If
        If berechtigungAn = True Then
            GetFileOpenPassword = GetStandardPassword()
        End If
    End If
    Exit Function
    
fehler:
    GetFileOpenPassword = ""
    
End Function


Function GetFilePassword(ByVal fname As String, ByVal pwtyp As Long) As String
  
  Dim rs As Object
  Set rs = CreateObject("ADODB.recordset")
  
  Dim hsh As String
  Dim uncfname As String
  uncfname = UCase(GetUNCPath(fname))
  hsh = GetFileHash(uncfname)
  
  Dim pw As String
  pw = ""
  
  rs.Open "SELECT Hash, Dateiname, Passwort, Tabname FROM idvDateien INNER JOIN idvDateienPW ON idvDateien.idvDateiID = idvDateienPW.idvDateiID WHERE Hash = '" & hsh & "' AND PWTyp =" & pwtyp, G_Conn, 2, 1
  Do While rs.EOF = False
    If UCase(rs.Fields("Dateiname").value) = uncfname Then
      pw = Crypt(rs.Fields("Passwort").value, "T0)7/hJy+\1TrcpI?", False)
      Exit Do
    End If
  Loop
  rs.Close
  
  If pwtyp = 1 Then
      rs.Open "SELECT Dateiname, Dateiberechtigungen FROM idvDateien WHERE Hash = '" & hsh & "' and Dateiberechtigungen <> 0", G_Conn, 2, 1
      Do While rs.EOF = False
        If UCase(rs.Fields("Dateiname").value) = uncfname Then
          pw = GetFileOpenPassword(rs)
          Exit Do
        End If
      Loop
      rs.Close
  
  End If
  
  Set rs = Nothing
  
  GetFilePassword = pw

End Function




Attribute VB_Name = "RiskRange"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public m_Comparison As Long
Public m_Value As Long
Public m_Risk As Double


Attribute VB_Name = "RiskTab"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public m_TabName As String
Public m_Vals As Collection

Public m_Weight As Double
Public m_Low As Double
Public m_LowColour As Long
Public m_LowMulti As Double
Public m_Med As Double
Public m_MedColour As Long
Public m_MedMulti As Double
Public m_HighColour As Long
Public m_HighMulti As Double

Private Sub Class_Initialize()
  Set m_Vals = New Collection
End Sub

Public Function Init(wb As Workbook, y As Long, regeln As String, risiken As String)
  Init = False
  
  m_TabName = wb.Worksheets(risiken).Cells(y, 1)
  
  If Not WorksheetExists(wb, regeln) Then
    'MsgBox "Es existiert keine Tabelle mit dem Namen 'Regeln' in der Datei '" & ThisWorkbook.path & "\Access-Checker Risk.xls' fehlt. F|fffd|r den Bereich '" & m_TabName & "' kann keine Risikoanalyse vorgenommen werden!", vbCritical, "Access-Checker"
    MsgBox FMT2("RISKTAB_1", ThisWorkbook.path, m_TabName), vbCritical, "Access-Checker"
    Exit Function
  End If
  
  Dim y2 As Long
  y2 = 2
  Dim rv As RiskVal
  Do While Not IsEmpty(wb.Sheets(regeln).Cells(y2, 1)) Or Not IsEmpty(wb.Sheets(regeln).Cells(y2 + 1, 1)) Or Not IsEmpty(wb.Sheets(regeln).Cells(y2 + 2, 1))
    If Not IsEmpty(wb.Sheets(regeln).Cells(y2, 1)) Then
      If wb.Sheets(regeln).Cells(y2, 1) = m_TabName Then
        Set rv = New RiskVal
        If Not rv.Init(wb.Sheets(regeln), y2) Then
          Exit Function
        End If
        m_Vals.Add rv
      End If
    End If
    y2 = y2 + 1
  Loop
  
  With wb.Worksheets(risiken)
    m_Weight = .Cells(y, 2)
    m_Low = .Cells(y, 3)
    m_LowColour = .Cells(y, 4).Interior.Color
    m_LowMulti = .Cells(y, 5)
    m_Med = .Cells(y, 6)
    m_MedColour = .Cells(y, 7).Interior.Color
    m_MedMulti = .Cells(y, 8)
    m_HighColour = .Cells(y, 9).Interior.Color
    m_HighMulti = .Cells(y, 10)
  End With
  
  ' Und dann noch die Einzelwerte besorgen
  
  
  
  Init = True
End Function


Public Function InitDB(conn, riskrs)
  InitDB = False
  
  m_TabName = riskrs.Fields("Risiko").value
  
  Dim rs
  Set rs = CreateObject("ADODB.recordset")
  rs.Open "SELECT * FROM ACCRegeln WHERE ACCRisikoID = " & riskrs.Fields("ACCRisikoID").value, conn, 2, 1
  If rs.EOF Then
    'MsgBox "Es sind keine Regeln f|fffd|r das Risiko '" & riskrs.Fields("ACCRisikoID").value & "' in der Datenbank des IDV-Trackers enthalten. Es kann keine Gesamtrisikoanalyse vorgenommen werden!", vbCritical, "Access-Checker"
    MsgBox FMT1("RISKTAB_2", riskrs.Fields("ACCRisikoID").value), vbCritical, "Access-Checker"
    rs.Close
    Set rs = Nothing
    Exit Function
  End If
  
  Dim rv As RiskVal
  Do While Not rs.EOF
    Set rv = New RiskVal
    If Not rv.InitDB(conn, rs) Then
      Exit Function
    End If
    m_Vals.Add rv
    rs.MoveNext
  Loop
  
  rs.Close
  Set rs = Nothing
  
  With riskrs
    m_Weight = .Fields("Gewichtung").value
    m_Low = .Fields("Gering").value
    m_LowColour = .Fields("GeringFarbe").value
    m_LowMulti = .Fields("GeringMultiplikator").value
    m_Med = .Fields("Mittel").value
    m_MedColour = .Fields("MittelFarbe").value
    m_MedMulti = .Fields("MittelMultiplikator").value
    m_HighColour = .Fields("HochFarbe").value
    m_HighMulti = .Fields("HochMultiplikator").value
  End With
  
  ' Und dann noch die Einzelwerte besorgen
  
  
  
  InitDB = True
End Function


Attribute VB_Name = "RiskVal"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public m_Type As Long
Public m_Parameter As String
Public m_Vals As Collection
Public m_ParameterList As Collection
Public m_IdenticalAm As Long
Public m_Matches As Long
Public m_FirstMatch As String
Public m_FirstMatchAddress As String
Public m_Hit As Boolean

Private Sub Class_Initialize()
  Set m_Vals = New Collection
End Sub


Public Function Init(ws As Worksheet, line As Long) As Boolean
  
  Dim pos As Long
  Dim param As String
  
  ' Die Sprachen sind hier hard-codiert
  ' Das ist die Spalte Typ in 'Access-Checker Risk.xls'
  ' Momentan geht nur Englisch und Deutsch
  
  Init = False
  Select Case ws.Cells(line, 2)
    Case "ACC"
          m_Type = C_RISK_TYPE_ECC
    Case "Formula contains", "Formel enth|fffd|lt"
          m_Type = C_RISK_TYPE_FORMULA_CONTAINS
          
          Set m_ParameterList = New Collection
          
          m_Matches = 0
          m_FirstMatch = ""
          
          param = ws.Cells(line, 3)
    
          pos = InStr(param, ",")
          If pos <= 0 Then
            'MsgBox "ERROR: 'Formel enth|fffd|lt' muss als ersten Wert in 'Parameter / Schl|fffd|ssewort' einen numerischen Wert aufweisen! Datei 'Access-Checker Risk.xls' Tabelle '" & ws.name & " Zeile " & line, vbCritical, "Access-Checker"
            MsgBox FMT2("RISKVAL_1", ws.name, line), vbCritical, "Access-Checker"
            Exit Function
          End If
          If Not IsNumeric(Trim(Left(param, pos - 1))) Then
            'MsgBox "ERROR: 'Formel enth|fffd|lt' muss als ersten Wert in 'Parameter / Schl|fffd|ssewort' einen numerischen Wert aufweisen! Datei 'Access-Checker Risk.xls' Tabelle '" & ws.name & " Zeile " & line, vbCritical, "Access-Checker"
            MsgBox FMT2("RISKVAL_1", ws.name, line), vbCritical, "Access-Checker"
            Exit Function
          End If
          
          m_IdenticalAm = CLng(Trim(Left(param, pos - 1)))
          param = Mid(param, pos + 1)
          
          Do
            pos = InStr(param, ",")
            If pos <= 0 Then Exit Do
            If Left(Trim(Left(param, pos - 1)), 1) = "$" Or Left(Trim(Left(param, pos - 1)), 1) = "|" Then
              m_ParameterList.Add UCase(Trim(Left(param, pos - 1)))
            Else
'              m_ParameterList.Add UCase(TranslateFuncToE(Trim(Left(param, pos - 1))))
              m_ParameterList.Add UCase(Trim(Left(param, pos - 1)))
            End If
            param = Mid(param, pos + 1)
          Loop
                
          If Len(param) > 0 Then
            m_ParameterList.Add Trim(param)
          End If
          
          G_RiskContains.Add Me
      
    Case "In list", "Not in list", "Nicht in Liste"
          
          Set m_ParameterList = New Collection
          
          m_Matches = 0
          m_FirstMatch = ""
          
          If ws.Cells(line, 2) = "Whitelist" Then
            m_Type = C_RISK_TYPE_WHITE_LIST
          Else
            m_Type = C_RISK_TYPE_NOT_IN_WHITE_LIST
          End If
          
          param = ws.Cells(line, 3)
    
          Do
            pos = InStr(param, ",")
            If pos <= 0 Then Exit Do
            If Left(Trim(Left(param, pos - 1)), 1) = "$" Or Left(Trim(Left(param, pos - 1)), 1) = "|" Then
              m_ParameterList.Add UCase(Trim(Left(param, pos - 1)))
            Else
'              m_ParameterList.Add UCase(TranslateFuncToE(Trim(Left(param, pos - 1))))
              m_ParameterList.Add UCase(Trim(Left(param, pos - 1)))
            End If
            param = Mid(param, pos + 1)
          Loop
                
          If Len(param) > 0 Then
            m_ParameterList.Add Trim(param)
          End If
          
          
          G_WhiteList.Add Me
      
    Case Else
      'MsgBox "ERROR: Unbekannter Typ '" & ws.Cells(line, 2) & "' in 'Access-Checker Risk.xls' Tabelle '" & ws.name & " Zeile " & line, vbCritical, "Access-Checker"
      MsgBox FMT3("RISKVAL_2", ws.Cells(line, 2), ws.name, line), vbCritical, "Access-Checker"
      Exit Function
  End Select
  
  m_Parameter = ws.Cells(line, 3)
  Dim x As Long
  x = 4
  With ws
    Do While Not IsEmpty(.Cells(line, x))
      If Not AddVal(ws, x, .Cells(line, x), .Cells(line, x + 1), .Cells(line, x + 2), ws.name, line) Then Exit Function
      x = x + 3
    Loop
  End With
  Init = True
  
End Function

Public Function AddVal(ws As Worksheet, x As Long, comp As String, v As String, risk As Double, sheetname As String, line As Long) As Boolean
  AddVal = False
  Dim rr As New RiskRange
  Select Case comp
    Case "<"
      rr.m_Comparison = C_RISK_COMP_TYPE_LESS
    Case "<="
      rr.m_Comparison = C_RISK_COMP_TYPE_LESSEQUAL
    Case "="
      rr.m_Comparison = C_RISK_COMP_TYPE_EQUAL
    Case ">="
      rr.m_Comparison = C_RISK_COMP_TYPE_LARGEREQUAL
    Case ">"
      rr.m_Comparison = C_RISK_COMP_TYPE_LARGER
    Case Else
      'MsgBox "ERROR: Unbekannter Vergleichsoperator '" & comp & "' in 'Access-Checker Risk.xls' Tabelle '" & sheetname & " Zelle " & ws.Cells(line, x).Address, vbCritical, "Access-Checker"
      MsgBox FMT3("RISKVAL_3", comp, sheetname, ws.Cells(line, x).Address), vbCritical, "Access-Checker"
      Exit Function
  End Select
  
  If Not IsNumeric(v) Then
    'MsgBox "ERROR: Nicht numerischer Wert in 'Access-Checker Risk.xls' Tabelle '" & sheetname & " Zelle " & ws.Cells(line, x + 1).Address, vbCritical, "Access-Checker"
    MsgBox FMT2("RISKVAL_4", sheetname, ws.Cells(line, x + 1).Address), vbCritical, "Access-Checker"
    Exit Function
  End If
  
  If Not IsNumeric(risk) Then
    'MsgBox "ERROR: Nicht numerischer Wert in 'Access-Checker Risk.xls' Tabelle '" & sheetname & " Zelle " & ws.Cells(line, x + 2).Address, vbCritical, "Access-Checker"
    MsgBox FMT2("RISKVAL_4", sheetname, ws.Cells(line, x + 2).Address), vbCritical, "Access-Checker"
    Exit Function
  End If
  
  If Val(risk) < 0 Or Val(risk) > 1 Then
    'MsgBox "ERROR: Risiko muss zwischen 0% und 100% liegen in 'Access-Checker Risk.xls' Tabelle '" & sheetname & " Zelle " & ws.Cells(line, x + 1).Address, vbCritical, "Access-Checker"
    MsgBox FMT2("RISKVAL_5", sheetname, ws.Cells(line, x + 1).Address), vbCritical, "Access-Checker"
    Exit Function
  End If
  
  
  rr.m_Value = v
  rr.m_Risk = risk
  
  m_Vals.Add rr
  
  AddVal = True
End Function




Sub CheckFunc(s As String)
  Dim i As Long
  If m_ParameterList.count <= 0 Then Exit Sub
  Dim foundone As Boolean
  For i = 1 To m_ParameterList.count
    If m_ParameterList(i) = s Then
      foundone = True
      Exit For
    End If
  Next i

  If foundone Then
    If m_Type = C_RISK_TYPE_WHITE_LIST Then
      m_Hit = True
      m_Matches = m_Matches + 1
    End If
  Else
    If m_Type = C_RISK_TYPE_NOT_IN_WHITE_LIST Then
      m_Hit = True
      m_Matches = m_Matches + 1
    End If
  End If

End Sub


Public Function InitDB(conn, rs) As Boolean
  
  Dim pos As Long
  Dim param As String
  
  InitDB = False
  
  Select Case rs.Fields("ACCTypID").value
    Case C_RISK_TYPE_ECC
          m_Type = C_RISK_TYPE_ECC
    Case C_RISK_TYPE_FORMULA_CONTAINS
          m_Type = C_RISK_TYPE_FORMULA_CONTAINS
          
          Set m_ParameterList = New Collection
          
          m_Matches = 0
          m_FirstMatch = ""
          
          param = rs.Fields("Parameter").value
    
          pos = InStr(param, ",")
          If pos <= 0 Then
            'MsgBox "ERROR: 'Formul enth|fffd|lt' muss als ersten Wert in 'Parameter / Schl|fffd|ssewort' einen numerischen Wert aufweisen! Tabelle 'ACCRegeln'", vbCritical, "Access-Checker"
            MsgBox FMT0("RISKVAL_6"), vbCritical, "Access-Checker"
            Exit Function
          End If
          If Not IsNumeric(Trim(Left(param, pos - 1))) Then
            'MsgBox "ERROR: 'Formul enth|fffd|lt' muss als ersten Wert in 'Parameter / Schl|fffd|ssewort' einen numerischen Wert aufweisen! Tabelle 'ACCRegeln'", vbCritical, "Access-Checker"
            MsgBox FMT0("RISKVAL_6"), vbCritical, "Access-Checker"
            Exit Function
          End If
          
          m_IdenticalAm = CLng(Trim(Left(param, pos - 1)))
          param = Mid(param, pos + 1)
          
          Do
            pos = InStr(param, ",")
            If pos <= 0 Then Exit Do
            If Left(Trim(Left(param, pos - 1)), 1) = "$" Or Left(Trim(Left(param, pos - 1)), 1) = "|" Then
              m_ParameterList.Add UCase(Trim(Left(param, pos - 1)))
            Else
'              m_ParameterList.Add UCase(TranslateFuncToE(Trim(Left(param, pos - 1))))
              m_ParameterList.Add UCase(Trim(Left(param, pos - 1)))
            End If
            param = Mid(param, pos + 1)
          Loop
                
          If Len(param) > 0 Then
            m_ParameterList.Add Trim(param)
          End If
          
          G_RiskContains.Add Me
      
    Case C_RISK_TYPE_WHITE_LIST, C_RISK_TYPE_NOT_IN_WHITE_LIST
          
          m_Type = rs.Fields("ACCTypID").value
          
          Set m_ParameterList = New Collection
          
          m_Matches = 0
          m_FirstMatch = ""
          
          m_Type = rs.Fields("ACCTypID").value
          
          param = rs.Fields("Parameter").value
    
          Do
            pos = InStr(param, ",")
            If pos <= 0 Then Exit Do
            If Left(Trim(Left(param, pos - 1)), 1) = "$" Or Left(Trim(Left(param, pos - 1)), 1) = "|" Then
              m_ParameterList.Add UCase(Trim(Left(param, pos - 1)))
            Else
'              m_ParameterList.Add UCase(TranslateFuncToE(Trim(Left(param, pos - 1))))
              m_ParameterList.Add UCase(Trim(Left(param, pos - 1)))
            End If
            param = Mid(param, pos + 1)
          Loop
                
          If Len(param) > 0 Then
            m_ParameterList.Add Trim(param)
          End If
          
          
          G_WhiteList.Add Me
      
    Case Else
      'MsgBox "ERROR: Unbekannter Typ in Tabelle 'ACCRegeln'", vbCritical, "Access-Checker"
      MsgBox FMT0("RISKVAL_7"), vbCritical, "Access-Checker"
      Exit Function
  End Select
  
  m_Parameter = rs.Fields("Parameter").value
  
  
  Dim errs
  Set errs = CreateObject("ADODB.recordset")
  errs.Open "SELECT * FROM ACCEinzelregeln WHERE ACCRegelID = " & rs.Fields("ACCRegelID").value & " ORDER BY id", conn, 2, 1
  If errs.EOF Then
    'MsgBox "Es sind keine Einzelregeln f|fffd|r die Regel '" & rs.Fields("ACCRegelID").value & "' in der Datenbank des IDV-Trackers enthalten. Es kann keine Gesamtrisikoanalyse vorgenommen werden!", vbCritical, "Access-Checker"
    MsgBox FMT1("RISKVAL_8", rs.Fields("ACCRegelID").value), vbCritical, "Access-Checker"
    errs.Close
    Set errs = Nothing
    Exit Function
  End If
  
  
  Do While Not errs.EOF
    If Not AddValDB(errs.Fields("OperatorID").value, errs.Fields("GefundeneZellen").value, errs.Fields("Risiko").value) Then Exit Function
    errs.MoveNext
  Loop
  InitDB = True
  
End Function


Public Function AddValDB(comp As String, v As String, risk As Double) As Boolean
  AddValDB = False
  Dim rr As New RiskRange
  
  rr.m_Comparison = comp
  
  If Val(risk) < 0 Or Val(risk) > 1 Then
    'MsgBox "ERROR: Risiko muss zwischen 0% und 100% liegen in Tabelle 'ACCEinzelregeln', Spalte 'Risiko'", vbCritical, "Access-Checker"
    MsgBox FMT0("RISKVAL_9"), vbCritical, "Access-Checker"
    Exit Function
  End If
  
  rr.m_Value = v
  rr.m_Risk = risk
  
  m_Vals.Add rr
  
  AddValDB = True
End Function


Attribute VB_Name = "SWFuncs"
Option Explicit

'Declares for direct ping
#If VBA7 Then
Private Declare PtrSafe Function InternetOpen Lib "wininet.dll" Alias "InternetOpenA" (ByVal lpszAgent As String, ByVal dwAccessType As Long, ByVal lpszProxyName As String, ByVal lpszProxyBypass As String, ByVal dwFlags As Long) As Long
Private Declare PtrSafe Function InternetOpenUrl Lib "wininet.dll" Alias "InternetOpenUrlA" (ByVal hInet As LongPtr, ByVal lpszUrl As String, ByVal lpszHeaders As String, ByVal dwHeadersLength As Long, ByVal dwFlags As Long, ByVal dwContext As Long) As Long
Private Declare PtrSafe Function InternetCloseHandle Lib "wininet.dll" (ByVal hInet As LongPtr) As Long
Private Declare PtrSafe Function InternetReadFile Lib "wininet.dll" _
    (ByVal hFile As LongPtr, ByVal sBuffer As String, ByVal lNumBytesToRead As Long, _
    lNumberOfBytesRead As LongPtr) As Integer
Private Declare PtrSafe Function InternetGetLastResponseInfo Lib "wininet.dll" Alias "InternetGetLastResponseInfoA" _
    (lpdwError As Long, ByVal lpszBuffer As String, ByVal lpdwBufferLength As Long) As Integer
#Else
Private Declare Function InternetOpen Lib "wininet.dll" Alias "InternetOpenA" (ByVal lpszAgent As String, ByVal dwAccessType As Long, ByVal lpszProxyName As String, ByVal lpszProxyBypass As String, ByVal dwFlags As Long) As Long
Private Declare Function InternetOpenUrl Lib "wininet.dll" Alias "InternetOpenUrlA" (ByVal hInet As Long, ByVal lpszUrl As String, ByVal lpszHeaders As String, ByVal dwHeadersLength As Long, ByVal dwFlags As Long, ByVal dwContext As Long) As Long
Private Declare Function InternetCloseHandle Lib "wininet.dll" (ByVal hInet As Long) As Long
Private Declare Function InternetReadFile Lib "wininet.dll" _
    (ByVal hFile As Long, ByVal sBuffer As String, ByVal lNumBytesToRead As Long, _
    lNumberOfBytesRead As Long) As Integer
Private Declare Function InternetGetLastResponseInfo Lib "wininet.dll" Alias "InternetGetLastResponseInfoA" _
    (lpdwError As Long, ByVal lpszBuffer As String, ByVal lpdwBufferLength As Long) As Integer
#End If

Private Const INTERNET_OPEN_TYPE_PRECONFIG = 0
Private Const INTERNET_FLAG_RELOAD = &H80000000
Private Const INTERNET_FLAG_KEEP_CONNECTION = &H400000
Private Const INTERNET_FLAG_NO_CACHE_WRITE = &H4000000


Public Function CheckINetConnection() As Boolean
  Dim hInet As Long
  Dim hUrl As Long
  Dim Flags As Long
  Dim url As Variant
  
  hInet = InternetOpen(" ", INTERNET_OPEN_TYPE_PRECONFIG, vbNullString, vbNullString, 0&)
  If hInet Then
    Flags = INTERNET_FLAG_KEEP_CONNECTION Or INTERNET_FLAG_NO_CACHE_WRITE Or INTERNET_FLAG_RELOAD
    hUrl = InternetOpenUrl(hInet, "http://www.stromwerken.de", vbNullString, 0, Flags, 0)
    If hUrl Then
        CheckINetConnection = True
        Call InternetCloseHandle(hUrl)
      Else
        CheckINetConnection = False
      End If
   End If
   Call InternetCloseHandle(hInet)
End Function

Public Sub CheckVersionOLD(checkEveryDays As Long, sec As String, fname As String, currentInternalVersion As Long, Optional msgboxIfNoUpdate As Boolean = False)

  Dim d As Date
  d = GetSetting( _
    appname:="Stromwerken", _
    Section:=sec, _
    Key:="VersionDate", Default:=DateSerial(2000, 1, 1))

  If DateAdd("d", checkEveryDays, d) > Now Then Exit Sub
 
  SaveSetting _
     appname:="Stromwerken", _
     Section:=sec, _
     Key:="VersionDate", _
     setting:=Now
 
  Dim fTxt As String
  If LoadInetFile(fname, fTxt) Then
  
    Dim regName As String
    Dim internetInternalVersion As Long
    Dim internetVersion As String
    Dim programName As String
    
    regName = GetLine(fTxt)
    internetInternalVersion = Val(GetLine(fTxt))
    internetVersion = GetLine(fTxt)
    programName = GetLine(fTxt)
    
    Dim intver As Long
    If Len(internetVersion) > 0 Then
      intver = Val(GetSetting( _
        appname:="Stromwerken", _
        Section:=sec, _
        Key:="InternalVersion", Default:=-1))
        
      If intver < 0 Or internetInternalVersion <= intver Then
        If msgboxIfNoUpdate Then
          'MsgBox "Es ist kein Update f|fffd|r die Software vorhanden."
          MsgBox FMT0("SWFUNCS_1")
        End If
        Exit Sub
      End If
      
      Dim tWB As Workbook
      For Each tWB In Workbooks
        If tWB.Saved = False Then
          If Not tWB Is ThisWorkbook Then
'            MsgBox "Im Internet liegt die " & internetVersion & " des Programms '" & programName & "' vor (Sie haben " & GetSetting( _
'              AppName:="Stromwerken", _
'              Section:=regName, _
'              Key:="Version", Default:="") & "). Das Update kann erst ausgef|fffd|hrt werden, wenn Sie alle ge|fffd|ffneten und modifzierten Dateien gespeichert und geschlossen haben. Bitte rufen Sie dann im Hauptmen|fffd| den Punkt 'Nach Aktualisierungen suchen' auf.", vbCritical
            MsgBox FMT3("SWFUNCS_2", internetVersion, programName, GetSetting( _
              appname:="Stromwerken", _
              Section:=regName, _
              Key:="Version", Default:="")), vbCritical
            Exit Sub
          End If
        End If
      Next tWB
      
'      If MsgBox("Im Internet liegt die " & internetVersion & " des Programms '" & programName & "' vor (Sie haben " & GetSetting( _
'          AppName:="Stromwerken", _
'          Section:=regName, _
'          Key:="Version", Default:="") & "). M|fffd|chten Sie die Aktualisierung herunterladen?", vbYesNo) = vbYes Then
      If MsgBox(FMT3("SWFUNCS_3", internetVersion, programName, GetSetting( _
          appname:="Stromwerken", _
          Section:=regName, _
          Key:="Version", Default:="")), vbYesNo) = vbYes Then
      
        SaveSetting _
           appname:="Stromwerken", _
           Section:="General", _
           Key:="UpdateCaller", _
           setting:=ProgNameShort
      
        On Error Resume Next
        If FileExists(ThisWorkbook.path & "\SWUpdater.xla") Then
          Call Shell(Application.path & "\Excel.exe " & ThisWorkbook.path & "\SWUpdater.xla")
        Else
          Call Shell("explorer.exe " & "http://www.stromwerken.de/html/downloads.html", 1)
        End If
        
        ThisWorkbook.Close False
        SaveSetting appname:="Stromwerken", Section:=ProgNameShort, Key:="ProcessID", setting:=""
        SaveSetting appname:="Stromwerken", Section:=ProgNameShort, Key:="LiveStatusTime", setting:=#1/1/1900#
        Application.Quit
        Exit Sub
      Else
        'If MsgBox("Falls Sie auch zuk|fffd|nftig NICHT mehr |fffd|ber Updates informiert werden wollen, klicken Sie einfach auf JA? (Um die automatische Pr|fffd|fung beim Start des Programmes wieder einzuschalten, brauchen Sie lediglich im Hauptmen|fffd| den 'Nach Updates suchen'-Button anzuklicken.)", vbYesNo) = vbYes Then
        If MsgBox(FMT0("SWFUNCS_4"), vbYesNo) = vbYes Then
          SaveSetting _
             appname:="Stromwerken", _
             Section:=sec, _
             Key:="NoAutoUpdate", _
             setting:=1
        End If
        Exit Sub
      End If
    End If
  Else
    If msgboxIfNoUpdate Then
      'MsgBox "Es konnte keine Internetverbindung hergestellt werden."
      MsgBox FMT0("SWFUNCS_5")
      Exit Sub
    End If
  End If

End Sub

Public Function LoadInetFile(fname As String, ByRef ret As String, Optional fsize As Long = 0) As Boolean
  Dim hInet As Long
  Dim hUrl As Long
  Dim Flags As Long
  Dim url As Variant
  
  LoadInetFile = False
  
  hInet = InternetOpen(" ", INTERNET_OPEN_TYPE_PRECONFIG, vbNullString, vbNullString, 0&)
  If hInet Then
    Flags = INTERNET_FLAG_KEEP_CONNECTION Or INTERNET_FLAG_NO_CACHE_WRITE Or INTERNET_FLAG_RELOAD
    hUrl = InternetOpenUrl(hInet, "http://www.stromwerken.de/" & fname, vbNullString, 0, Flags, 0)
    If hUrl Then
        
        Dim sReadBuf As String * 1024
        Dim flagMoreData As Boolean
        Dim bytesRead As Long
        Dim wRet As Integer
        Dim lastErr As Long
        Dim s As String
        
        flagMoreData = True
        Do While flagMoreData
            sReadBuf = vbNullString
            wRet = InternetReadFile(hUrl, sReadBuf, Len(sReadBuf), bytesRead)
            If Err.LastDllError <> 0 Then
                lastErr = Err.LastDllError
                ret = "Error (wininet.dll," & lastErr & ")"
                GoTo exitfunc
            End If
            If wRet <> 1 Then
                ret = "Error"
                GoTo exitfunc
            End If
            s = s & Left$(sReadBuf, bytesRead)
            If Not CBool(bytesRead) Then flagMoreData = False
        Loop
        ret = s
        
        Call InternetCloseHandle(hUrl)
        Call InternetCloseHandle(hInet)
        LoadInetFile = True
        Exit Function
    Else
      Call InternetCloseHandle(hInet)
    End If
  End If
  Exit Function

exitfunc:
    If hUrl <> 0 Then InternetCloseHandle (hUrl)
    If hInet <> 0 Then InternetCloseHandle (hInet)
End Function

Private Function GetLine(ByRef txt As String) As String
  Dim pos As Long
  Dim res As String
  pos = InStr(txt, vbCr)
  If pos > 0 Then
    res = Left(txt, pos - 1)
  Else
    res = txt
  End If
  If pos > 0 Then
    txt = Mid(txt, 2 + pos)
  Else
    txt = ""
  End If
  
  GetLine = res

End Function

Function MySpc(l As Long) As String
  If l > 0 Then
    Dim i As Long
    For i = 1 To l
      MySpc = MySpc + " "
    Next i
  End If
End Function

Function MakeFileName(n As String)
  Dim newn As String
  Dim i As Long
  If Len(i) > 0 Then
    For i = 1 To Len(n)
      Select Case Mid(n, i, 1)
        Case ":"
          newn = newn & "-"
        Case "\", "/", "*", "?", Chr(34), "<", ">", "|"
          newn = newn & "_"
        Case Else
          newn = newn + Mid(n, i, 1)
      End Select
    Next i
  End If
  MakeFileName = newn
End Function

Function InStrMyRev(str As String, v As String, Optional pos As Long = 0) As Long
  Dim i As Long
  If Not IsMissing(pos) And pos > 0 Then
    i = pos
  Else
    i = Len(str)
  End If
  Do While i > 0
    If Mid(str, i, Len(v)) = v Then
      InStrMyRev = i
      Exit Function
    End If
    i = i - 1
  Loop
  InStrMyRev = 0
End Function

Function FileUpToDate(dst As String, src As String)
  FileUpToDate = True
'  If Not FileExists(dst) Then
'    FileUpToDate = False
'    Exit Function
'  ElseIf FileDateTime(dst) < FileDateTime(src) Then
  On Error GoTo dstFileMissing
  
  If MyFileDateTime(dst) < MyFileDateTime(src) Then
    FileUpToDate = False
    Exit Function
  End If
  
  Exit Function
dstFileMissing:
  FileUpToDate = False
  
End Function

Function PathExists(Dateiname$) As Boolean
  On Error GoTo fehler:
  Dim b As Boolean
  
  b = Dir$(Dateiname, vbDirectory) <> ""
  If Not b Then
    b = Dir$(Dateiname & "\", vbDirectory) <> ""
  End If
  PathExists = b
  Exit Function
fehler:
    PathExists = False
    Resume Next
End Function

Attribute VB_Name = "Scan"
Option Explicit

Public theidvDateiID As Long
Public theOEID As Long
Public theFreigabekommentar As String
Public theFreigabeCCListe  As String
Public theFreigabeuser As String

Sub ShowStatusForm(ByVal Headline As String)
  StatusForm.ProgressB.Width = 0
'  StatusForm.ProgressBT.Width = 0
  StatusForm.Filename = Headline
  StatusForm.VergangeneZeit = ""
  StatusForm.Restdauer = ""
  StatusForm.ProgText = ""
  LastProgText = ""
  ProgText = ""
'  StatusForm.BitteWarten.Visible = False
  DoEvents
  
'  If StartedByTracker Then
'    StatusForm.cmdAbbrechen.Visible = False
'    StatusForm.BitteWarten.Visible = True
'  Else
'    StatusForm.cmdAbbrechen.Visible = True
'  End If
  
  If StartedByTracker = True Then
    If theTrackerShowStatusform = True Then
      StatusForm.Show vbModeless
    End If
  Else
    StatusForm.Show vbModeless
  End If
 
End Sub

Sub SetFileStatusInfo(nfo As String)
    Dim s As String
    s = GetSetting(appname:="Stromwerken", Section:="IDVSS", Key:="FileStatusInfo")
    SaveSetting appname:="Stromwerken", Section:="IDVSS", Key:="FileStatusInfo", setting:= _
      IIf(s <> "", s & vbCrLf, "") & nfo
End Sub

Function TrackerTimeInScope() As Boolean
  
  TrackerTimeInScope = True
  
  If Not StartedByTracker Then Exit Function
  
  If theTrackerFreigabe Then Exit Function
  
  If G_SchedulerTimeCheckIgnore Then Exit Function
    
  If TimeInScope(Now, G_StartScan, G_EndScan) Then Exit Function
    
  TrackerTimeInScope = False
  
End Function

Attribute VB_Name = "Start"
Option Explicit

Dim Startpath As String
Public ResName As String
Public StartedByTracker As Boolean
Public UserAutomation As Boolean
Public StartedByDaemon  As Boolean

Public theTrackerPasswordLog As Boolean
Public theTrackerShowStatusform  As Boolean
Public theTrackerFreigabe As Boolean
Public theTrackerFreigabeDatum As Date
Public theTrackerFormelnExtrahieren  As Double
Public theTrackerFachrisiko As Double

Public m_LogY As Long

Public G_Conn As Object

Public G_Command As String

#If VBA7 Then
    Private Declare PtrSafe Function SetForegroundWindow Lib "user32" _
               (ByVal hWnd As LongPtr) As LongPtr
    Private Declare PtrSafe Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (Destination As Any, Source As Any, ByVal Length As Long)
    Private Declare PtrSafe Function GetCurrentProcessId Lib "kernel32" () As Long
#Else
    Private Declare Function GetCurrentProcessId Lib "kernel32" () As Long
    Private Declare Function SetForegroundWindow Lib "user32" _
               (ByVal hWnd As Long) As Long
    Private Declare Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (Destination As Any, Source As Any, ByVal Length As Long)
#End If


Sub GetTempPathFast()

  If Not StartedByTracker Then Exit Sub
  
  Dim cfg As New CfgReader
  Dim s As String
  
  Set cfg = New CfgReader
  G_cfgTemppfad = ThisWorkbook.path
  
  If FileExists(ThisWorkbook.path & "\ACC.cfg") = True Or FileExists(ThisWorkbook.path & "\..\cfg\IDV-Suite.cfg") = True Or FileExists(ThisWorkbook.path & "\..\..\cfg\IDV-Suite.cfg") = True Then

      If FileExists(ThisWorkbook.path & "\ACC.cfg") = True Then
        cfg.GetCFG ThisWorkbook.path & "\ACC.cfg"
      ElseIf FileExists(ThisWorkbook.path & "\..\cfg\IDV-Suite.cfg") Then
        cfg.GetCFG ThisWorkbook.path & "\..\cfg\IDV-Suite.cfg"
      ElseIf FileExists(ThisWorkbook.path & "\..\..\cfg\IDV-Suite.cfg") Then
        cfg.GetCFG ThisWorkbook.path & "\..\..\cfg\IDV-Suite.cfg"
      End If
      
      If cfg.GetSection("GLOBALS") = True Then
          G_cfgLogpfad = GetRelativePath(G_cfgLogpfad, cfg.GetValue("LOGPFAD"))
      End If
      
      If StartedByTracker Then
        If cfg.GetSection("IDV-Suite Scheduler") = True Then
            If cfg.GetValue("LOGPFAD") <> "" Then
              G_cfgLogpfad = GetRelativePath(G_cfgLogpfad, cfg.GetValue("LOGPFAD"))
            End If
        End If
      End If
      
  End If
  
  LogPrintECCSCanLog 0, 0, "V" & MyVersionString & " (Rel: " & MyACCVersion & ") Start!"

End Sub



Sub Auto_Open()
  
  SaveSetting appname:="Stromwerken", Section:=ProgNameShort, Key:="ProcessID", setting:=GetCurrentProcessId
  SaveSetting appname:="Stromwerken", Section:=ProgNameShort, Key:="ProcessIDTime", setting:=Now
  
  If GetSetting(appname:="Stromwerken", Section:=ProgNameShort, Key:="StartedByTracker", Default:="False") = "True" Then
    StartedByTracker = True
    GetTempPathFast
  End If
  
'  If GetSetting(appname:="Stromwerken", Section:="ACC", Key:="UserAutomation", Default:="False") = "True" Then
'    SaveSetting appname:="Stromwerken", Section:="ACC", Key:="UserAutomation", setting:="False"
'    UserAutomation = True
'  End If
  
  SaveSetting appname:="Stromwerken", Section:=ProgNameShort, Key:="ProcResult", setting:=""
  G_Command = ""

  GetDBUser

  m_LogY = 2
  m_ResultWorkbookName = ""

  Startpath = ThisWorkbook.path
  SaveSetting _
     appname:="Stromwerken", _
     Section:=ProgNameShort, _
     Key:="Path", _
     setting:=ThisWorkbook.path
  
  SaveSetting _
     appname:="Stromwerken", _
     Section:=ProgNameShort, _
     Key:="Version", _
     setting:=MyVersion
  
  SaveSetting _
     appname:="Stromwerken", _
     Section:=ProgNameShort, _
     Key:="InternalVersion", _
     setting:=MyInternalVersion

  SetLiveStatus
  SaveSetting appname:="Stromwerken", Section:=ProgNameShort, Key:="Restart", setting:=""
  InitApp
  
  ' ---------------------------------------------------------
  ' Daemon
  ' ---------------------------------------------------------
  If GetSetting( _
      appname:="Stromwerken", _
      Section:=ProgNameShort, _
      Key:="StartedByDaemon", _
      Default:="False") = "True" Then

          SaveSetting _
             appname:="Stromwerken", _
             Section:=ProgNameShort, _
             Key:="StartedByDaemon", _
             setting:="False"
          
          StartedByDaemon = True

          LogPrint "StartedByDaemon"
          If GetSetting( _
              appname:="Stromwerken", _
              Section:=ProgNameShort, _
              Key:="StartedByTracker", _
              Default:="False") = "True" Then
          
              LogPrint "StartedByTracker"
              SaveSetting _
                 appname:="Stromwerken", _
                 Section:=ProgNameShort, _
                 Key:="StartedByTrackerFirstTime", _
                 setting:="True"
          Else
              StartedByTracker = False
              
              ' Application.OnTime Now + TimeValue("00:00:04"), "DoMassenanalyse"
              ShowStatusForm ""
              LogPrint "Start Done 1"
              DoMassenanalyse
              Exit Sub
          End If
  End If


  ' ---------------------------------------------------------
  ' Tracker
  ' ---------------------------------------------------------
  If GetSetting( _
            appname:="Stromwerken", _
            Section:=ProgNameShort, _
            Key:="StartedByTracker", _
            Default:="False") = "True" And _
 _
            GetSetting( _
            appname:="Stromwerken", _
            Section:=ProgNameShort, _
            Key:="StartedByTrackerFirstTime", _
            Default:="False") = "True" _
 _
            Then
            
            LogPrint "StartedByTrackerFirstTime"
            SaveSetting _
                   appname:="Stromwerken", _
                   Section:=ProgNameShort, _
                   Key:="StartedByTrackerFirstTime", _
                   setting:="False"
            
            GetTrackerSettings
            
            If Len(theFilename) = 0 Then
              LogPrint "Filename korrupt"
              Exit Sub
            End If
            
            ' Wenn es mit der aktuellen Dateizeit schon einen Eintrag gibt, dann ist hier schluss
'            Set G_conn = CreateObject("ADODB.Connection")
'            G_conn.Open "IDV-Tracker", "IDVTTechUser", "12SD3Ax$!d7%fd/"
            
            LogPrint "TrackerDo 1"
            Set G_Conn = GetConnection()
            
            If G_Conn Is Nothing Then
              LogPrint "No conn"
              Exit Sub
            End If
            
            StoreUserCommunicateValue "TU", ""
            StoreUserCommunicateValue "FG", ""
            
            StartedByTracker = True
            
            ' Einzelanalyse?
            If theFilename <> "@" Then
            
                  LogPrint "TrackerDo Einzel"
                  XLScriptInitDebug
                  
                  Application.OnTime Now + TimeValue("00:00:04"), "DoEinzelanalyse"
                  ShowStatusForm theFilename
            Else
            
                  ' N|fffd|, massen!
                  LogPrint "TrackerDo Massen"
                  ' Application.OnTime Now + TimeValue("00:00:04"), "DoMassenanalyse"
                  ShowStatusForm ""
                  DoMassenanalyse
            End If
            
            LogPrint "Start Done 2"
            Exit Sub
   
  
  Else
      ' ---------------------------------------------------------
      ' Standard
      ' ---------------------------------------------------------
    
        LogPrint "StandardStart"
  
        SaveSetting _
               appname:="Stromwerken", _
               Section:=ProgNameShort, _
               Key:="StartedByTracker", _
               setting:="False"
    
    
        StartedByTracker = False
        StartedByDaemon = False
      
        ClearLog
    
  
  
'        If Not StartedByTracker Then
'          If GetSetting( _
'            appname:="Stromwerken", _
'            Section:=ProgNameShort, _
'            Key:="NoAutoUpdate", Default:=0) = 0 Then
'              CheckVersion 1, ProgNameShort, "ACCVersionN.txt", "ACCVersionN2.txt", MyVersion, MyInternalVersion
'          End If
'        End If
  
  
  
    
      Dim found As Boolean
      Dim c
      For Each c In Application.CommandBars("Worksheet Menu Bar").Controls
          If c.Caption = "ACC" Then
              Application.CommandBars("Worksheet Menu Bar").Controls("ACC").Delete
              Exit For
          End If
      Next c
      
      
      Dim cbb As CommandBarPopup
      Dim scbb As CommandBarButton
      
      Set cbb = Application.CommandBars("Worksheet Menu Bar").Controls.Add(Type:=msoControlPopup)
      
      'cbb.Caption = "ACC"
      cbb.Caption = ProgNameShort
      Set scbb = cbb.Controls.Add
      scbb.BeginGroup = False
      scbb.Style = msoButtonCaption
      'scbb.Caption = "Start"
      scbb.Caption = FMT0("START_1")
      scbb.OnAction = "auto_open"
      'scbb.TooltipText = "Startet den Access-Checker"
      scbb.TooltipText = FMT0("START_2")
      
      Set scbb = cbb.Controls.Add
      scbb.BeginGroup = False
      scbb.Style = msoButtonCaption
      'scbb.Caption = "Aus Men|fffd| entfernen"
      scbb.Caption = FMT0("START_3")
      scbb.OnAction = "AccessSheetCheckRemoveMenu"
      'scbb.TooltipText = "Entfernt den Access-Checker"
      scbb.TooltipText = FMT0("START_4")
      
      If UCase(ThisWorkbook.name) = "ACCESS-CHECKER.XLS" Or UCase(ThisWorkbook.name) = "ACCESS-CHECKER.XLA" Then
          AccessSheetCheckShowMainMenu
      End If
  
  End If
End Sub

Sub DoEinzelanalyse()
  
  On Error Resume Next
  If Not FileExists(theFilename) Then
    'AddStatus "Datei '" & theFilename & "nicht mehr vorhanden."
    AddStatus FMT1("START_5", theFilename)
  ElseIf CreateTempAnalyseFile(theFilename) Then
     Analyze G_AnalyseFile, theFilename
     SetAttr G_AnalyseFile, vbNormal
     Kill G_AnalyseFile
  Else
    Sleep 10000
  End If
  
  StatusForm.Hide
  m_LogY = 2
  m_ResultWorkbookName = ""

  If StartedByTracker Then
    
    If Not G_Conn Is Nothing Then
      G_Conn.Close
      Set G_Conn = Nothing
    End If
    
    LogPrint "StartedByTracker=False"
    SaveSetting _
       appname:="Stromwerken", _
       Section:=ProgNameShort, _
       Key:="StartedByTracker", _
       setting:="False"
    SaveSetting _
       appname:="Stromwerken", _
       Section:=ProgNameShort, _
       Key:="TrackerFreigabe", _
       setting:="False"
    
    SaveSetting appname:="Stromwerken", Section:=ProgNameShort, Key:="ProcessID", setting:=""
    SaveSetting appname:="Stromwerken", Section:=ProgNameShort, Key:="LiveStatusTime", setting:=#1/1/1900#
    Application.Quit
  End If
  
End Sub

Function CreateTempAnalyseFile(ByVal fname As String) As Boolean


  CreateTempAnalyseFile = False
  
  MkFullDir G_cfgTemppfad
  G_AnalyseFile = MyGetTempFilename(G_cfgTemppfad, "ACCAnalyse-") & "." & GetExtension(fname)
  If FileExists(G_AnalyseFile) Then
    SetAttr G_AnalyseFile, vbNormal
    MyKill G_AnalyseFile
  End If
  If Not FileExists(G_AnalyseFile) Then
    CopyFile theFilename, G_AnalyseFile
    If FileExists(G_AnalyseFile) Then
      'AddStatus "Tempor|fffd|re Kopie der Datei erzeugt, starte Analyse..."
      AddStatus FMT0("START_6")
      CreateTempAnalyseFile = True
      Exit Function
    Else
      If StartedByTracker Then
        'AddStatus "Datei '" & theFilename & " konnte nicht kopiert werden (zum Scan wird eine tempor|fffd|re Kopie ben|fffd|tigt)."
        AddStatus FMT1("START_7", theFilename)
        'LogPrintECCSCanLog theFilename & " (ID: " & theidvDateiID & ") - Datei konnte nicht kopiert werden (zum Scan wird eine tempor|fffd|re Kopie ben|fffd|tigt).", True
        LogPrintECCSCanLog theidvDateiID, 7, FMT2("START_8", theFilename, theidvDateiID), True
      Else
        'AddStatus "Tempor|fffd|re Kopie '" & G_cfgTemppfad & "\ACCAnalyse.mdb konnte nicht erzeugt werden! Bitte warten, Anaylse wird in 10 Sekunden beendet."
        AddStatus FMT1("START_9", G_cfgTemppfad)
      End If
    End If
  Else
    If StartedByTracker Then
      'AddStatus "Tempor|fffd|re Datei '" & G_cfgTemppfad & "\ACCAnalyse.mdb konnte nicht gel|fffd|scht werden!"
      AddStatus FMT1("START_10", G_cfgTemppfad)
      'LogPrintECCSCanLog theFilename & " (ID: " & theidvDateiID & ") - Tempor|fffd|re Datei '" & G_cfgTemppfad & "\ACCAnalyse.mdb konnte nicht gel|fffd|scht werden!", True
      LogPrintECCSCanLog theidvDateiID, 8, FMT3("START_11", theFilename, theidvDateiID, G_cfgTemppfad), True
    Else
      'AddStatus "Tempor|fffd|re Datei '" & G_cfgTemppfad & "\ACCAnalyse.mdb konnte nicht gel|fffd|scht werden! Die Datei ist vermutlich durch einen anderen User gelockt. Bitte warten, Anaylse wird in 10 Sekunden beendet."
      AddStatus FMT1("START_12", G_cfgTemppfad)
    End If
  End If

End Function


Sub DoMassenanalyse()
  
  Dim rs As Object
  Set G_Conn = GetConnection()
  If G_Conn Is Nothing Then Exit Sub
  
  GetStartEndTime
  
  G_SchedulerTimeCheckIgnore = IIf(GetSetting( _
               appname:="Stromwerken", _
               Section:="ECC", _
               Key:="SchedulerTimeCheckIgnore", Default:=0) = 0, False, True)

  Set rs = CreateObject("ADODB.recordset")
  rs.Open "SELECT * FROM ACCScan", G_Conn, MYadOpenDynamic, MYadLockOptimistic
  
  If Not rs.EOF Then
  
      DoEvents
      StartDaemon
  
      Do While Not rs.EOF
      
        theFilename = rs.Fields("Dateiname").value
        theidvDateiID = rs.Fields("idvDateiID").value
        
        If rs.Fields("ScanStatus").value >= 1 Then
          rs.Delete
          
          AddStatus FMT1("CHECK_2", theFilename)
          AddStatus FMT0("SCANERG_1")
          XLScriptInitGlobals Application, Nothing
          XLScriptAddSimpleVar "FILE", theFilename
          XLScriptAddSimpleVar "NAME", theFilename
          XLScriptAddSimpleVar "SAVEDATE", Format(MyFileDateTime(theFilename), "Short Date") & " - " & Format(MyFileDateTime(theFilename), "Short Time")
          XLScriptAddSimpleVar "FILESIZEKB", CLng(MyFileLen(theFilename) / 1024)
          XLScriptAddSimpleVar "FILESIZE", MyFileLen(theFilename)
          XLScriptAddSimpleVar "STATUS", FMT0("SCANERG_1") ' "Datei/Analyse fehlerhaft"
          XLScriptAddSimpleVar "STATUSID", "1"
          XLACCStoreValsToDB False
          XLScriptExitGlobals
          LogPrintECCSCanLog theidvDateiID, 1, theFilename & " (ID: " & theidvDateiID & ") - Ergebnis: Analyse mehrfach fehlerhaft, Analyse wird abgebrochen", True
          
        Else
          rs.Fields("ScanStatus").value = rs.Fields("ScanStatus").value + 1
          rs.Update
        
          
          StatusForm.Filename = theFilename
          DoEvents
          
          If Not FileExists(theFilename) Then
            'AddStatus "Datei '" & theFilename & "nicht mehr vorhanden."
            AddStatus FMT1("START_5", theFilename)
          Else
            If CreateTempAnalyseFile(theFilename) Then
              Analyze G_AnalyseFile, theFilename
              SetAttr G_AnalyseFile, vbNormal
              MyKill G_cfgTemppfad & "\ACCAnalyse-*.*"  ' G_AnalyseFile
            End If
            If Not rs.EOF Then
              rs.Delete
            End If
          End If
          
        End If
        
        If Not TrackerTimeInScope() Then Exit Do
        
        rs.MoveNext
      Loop
  
      EndDaemon
      
  End If
  
  If StartedByTracker Then
    
    StoreComm False
    LogPrintECCSCanLog 0, 0, "Schlie|fffd|e ACC, alle Analysen beendet", True
    SaveSetting appname:="Stromwerken", Section:="IDVSS", Key:="ACCScanFinished", setting:="1"
    
  End If
  
  G_Conn.Close
  Set G_Conn = Nothing
  
  StatusForm.Hide
  SaveSetting appname:="Stromwerken", Section:=ProgNameShort, Key:="ProcessID", setting:=""
  SaveSetting appname:="Stromwerken", Section:=ProgNameShort, Key:="LiveStatusTime", setting:=#1/1/1900#
  Application.Quit

End Sub

Function MyKill(fname As String) As Boolean
  On Error GoTo nogo
  Kill fname
  MyKill = True
  Exit Function
nogo:
End Function

Sub Auto_Close()
    On Error Resume Next
'    Application.CommandBars("Worksheet Menu Bar").Controls("Access-Checker").Delete
End Sub

Public Sub AccessSheetCheckShowMainMenu()

  Dim accResFile As String
  accResFile = "ACC-Res.xls"
  
  Dim resFilePath As String
  resFilePath = gTranslation.GetLocalizedFile(ThisWorkbook.path & "\ACC-Res.xls")
  accResFile = GetFileNameAndExtension(resFilePath)
  
  Dim resDemoFilePath As String
  resDemoFilePath = gTranslation.GetLocalizedFile(ThisWorkbook.path & "\ACC-ResDemo.xls")
  Dim accDemoResFile As String
  accDemoResFile = GetFileNameAndExtension(resDemoFilePath)
  
  'If FileExists(ThisWorkbook.path & "\ACC-Res.xls") Then
  If FileExists(resFilePath) Then
    'ResName = ThisWorkbook.path & "\ACC-Res.xls"
    ResName = resFilePath
  'ElseIf FileExists(ThisWorkbook.path & "\ACC-ResDemo.xls") Then
  ElseIf FileExists(resDemoFilePath) Then
    'accResFile = "ACC-ResDemo.xls"
    accResFile = accDemoResFile
    'ResName = ThisWorkbook.path & "\ACC-ResDemo.xls"
    ResName = resDemoFilePath
    'MainMenu.Headline = "Access-Checker Demo"
    MainMenu.Headline = FMT0("START_18")
  Else
    If Not StartedByTracker Then
      'MsgBox "Datei '" & ThisWorkbook.path & "\ACC-Res.xls' nicht gefunden!", vbCritical
      MsgBox FMT2("START_13", ThisWorkbook.path, accResFile), vbCritical
    Else
      'AddStatus "Datei '" & ThisWorkbook.path & "\ACC-Res.xls' nicht gefunden!", vbCritical
      AddStatus FMT2("START_13", ThisWorkbook.path, accResFile), vbCritical
    End If
    Exit Sub
  End If

  FullVersion = False
  GetData
  
    If GSprache = 0 Then
      GSprache = 1
      SaveSetting _
         appname:="Stromwerken", _
         Section:=ProgNameShort, _
         Key:="Sprache", _
         setting:=GSprache
    End If
    
    ' GSprache = 2 ' English Version
    
    
    If Len(Startpath) = 0 Then
        Startpath = ThisWorkbook.path
    End If
    MainMenu.Vers.Caption = MyVersion
    MainMenu.Label1.Caption = trs
    
    BitteWarten.Show
    
    If MainMenu.AnyAccessVersionEnabled() = False Then
      'MsgBox "Error: Es wurde keine installierte Version von Access97, 2000, 2002, 2003 oder 2007 gefunden. Das Programm wird abgebrochen!", vbCritical
      MsgBox FMT0("START_14"), vbCritical
      Application.CommandBars("Worksheet Menu Bar").Controls("ACC").Delete
      ThisWorkbook.Close False
    End If
    If MainMenu.V16.Enabled = True Then
      MainMenu.V16.value = True
    ElseIf MainMenu.V15.Enabled = True Then
      MainMenu.V15.value = True
    ElseIf MainMenu.V14.Enabled = True Then
      MainMenu.V14.value = True
    ElseIf MainMenu.V12.Enabled = True Then
      MainMenu.V12.value = True
    ElseIf MainMenu.V11.Enabled = True Then
      MainMenu.V11.value = True
    ElseIf MainMenu.V10.Enabled = True Then
      MainMenu.V10.value = True
    ElseIf MainMenu.V9.Enabled = True Then
      MainMenu.V9.value = True
    ElseIf MainMenu.V8.Enabled = True Then
      MainMenu.V8.value = True
    End If
    If FullVersion = False Then
      trs = ThisWorkbook.Sheets("Hinweis").Cells(1, 3)
      trsShrt = ThisWorkbook.Sheets("Hinweis").Cells(1, 4)
    End If
    
    MainMenu.Cop = "|fffd|2005 - " & year(Now)
    MainMenu.Show
End Sub

Sub AccessSheetCheckRemoveMenu()
    On Error Resume Next
    'If MsgBox("Sind Sie sicher, dass Sie den Access-Checker aus dem Men|fffd| entfernen m|fffd|chten?", vbYesNo) = vbYes Then
    If MsgBox(FMT0("START_15"), vbYesNo) = vbYes Then
        Application.CommandBars("Worksheet Menu Bar").Controls("ACC").Delete
        ThisWorkbook.Close False
    End If
End Sub



Sub GetTrackerSettings()
            
            ' Wenn der Tracker mich aufgerufen hat...
            theFilename = GetSetting( _
                appname:="Stromwerken", _
                Section:=ProgNameShort, _
                Key:="TrackerFile", _
                Default:="")
            
            theTrackerPasswordLog = IIf(GetSetting( _
                appname:="Stromwerken", _
                Section:=ProgNameShort, _
                Key:="TrackerLogPassword", _
                Default:="False") = "True", True, False)
                
            theTrackerShowStatusform = IIf(GetSetting( _
                appname:="Stromwerken", _
                Section:=ProgNameShort, _
                Key:="TrackerShowStatusform", _
                Default:="False") = "True", True, False)

            theTrackerFreigabe = IIf(GetSetting( _
                appname:="Stromwerken", _
                Section:=ProgNameShort, _
                Key:="TrackerFreigabe", _
                Default:="False") = "True", True, False)
                
            theTrackerFreigabeDatum = GetSetting( _
                appname:="Stromwerken", _
                Section:=ProgNameShort, _
                Key:="TrackerFreigabedatum", _
                Default:=#1/1/1900#)
                
            theidvDateiID = GetSetting( _
                appname:="Stromwerken", _
                Section:=ProgNameShort, _
                Key:="DateiID", _
                Default:=0)
                
            theFreigabekommentar = GetSetting( _
                appname:="Stromwerken", _
                Section:="ACC", _
                Key:="Freigabekommentar", _
                Default:="")
            
            theFreigabeCCListe = GetSetting( _
                appname:="Stromwerken", _
                Section:="ACC", _
                Key:="FreigabeCCListe", _
                Default:="")
                
            theFreigabeuser = GetSetting( _
                appname:="Stromwerken", _
                Section:="ACC", _
                Key:="Freigabeuser", _
                Default:="")
                
            theTrackerFormelnExtrahieren = GetSetting( _
                appname:="Stromwerken", _
                Section:=ProgNameShort, _
                Key:="TrackerFormelnExtrahieren", _
                Default:=-1)
                
            theTrackerFachrisiko = GetSetting( _
                appname:="Stromwerken", _
                Section:=ProgNameShort, _
                Key:="TrackerFachrisiko", _
                Default:=-1)
                
            ' theOEID = xlsDateien(i).m_OEID


End Sub




Function OpenRS(ByVal sqlstring As String, ByRef conn As Object, ByVal cursorytype As Long, ByVal locktype As Long) As Object
        Dim rs As Object
        Set rs = CreateObject("ADODB.Recordset")
        On Error Resume Next

        Set OpenRS = Nothing
        Dim cnt As Long
        cnt = 0
checkAgain:
        rs.Open sqlstring, conn, cursorytype, locktype
        If Err.Number <> 0 Then
            Debug.Print Err.Description
            Err.Clear
            Sleep 50
            cnt = cnt + 1
            If cnt >= 100 Then
                rs = Nothing
                Exit Function
            End If
            GoTo checkAgain
        End If

        Set OpenRS = rs
End Function


Sub StartDaemon()

  LogPrint "StartDaemon 1"
  
  'Application.Caption = "Access-Checker"
  Application.Caption = ProgNameLong
  'AddStatus "Starte ACCDaemon"
  AddStatus FMT0("START_16")
'  SaveECCDaemon
  SetLiveStatus
  LogPrint "StartDaemon 2"
  
  SaveSetting _
     appname:="Stromwerken", _
     Section:=ProgNameShort, _
     Key:="LiveStatusCaption", _
     setting:=Application.Caption
  SaveSetting _
     appname:="Stromwerken", _
     Section:=ProgNameShort, _
     Key:="LiveStatusExec", _
     setting:=ThisWorkbook.name
  
  LogPrint "StartDaemon 3"
  
'  Debug.Print "APPHWND: " & Application.Hwnd
'  Debug.Print "PROCESS: " & GetCurrentProcess
  
'  Dim L_HWND As Long
  
  'Microsoft Excel - Mappe1.xls = Caption der Excelanwendung
'  L_HWND = FindWindow("XLMain", Application.Caption)
'  Debug.Print "PROCESS: " & L_HWND

'  Debug.Print ThisWorkbook.Path & "\ECCDaemon.exe "
  
  SetLiveStatus
  
  
  LogPrint "StartDaemon 4"
'  Call Shell(ThisWorkbook.Path & "\ECCDaemon.exe " & Chr(34) & Application.Caption & Chr(34) & " " & ThisWorkbook.name & " 1", vbMinimizedNoFocus)
  If Not FileExists(ThisWorkbook.path & "\ACCDaemonV0.exe") Then
    'AddStatus "Datei '" & ThisWorkbook.path & "\ACCDaemonV0.exe' nicht vorhanden, der ACCDaemon kann nicht gestartet werden!"
    AddStatus FMT1("START_17", ThisWorkbook.path)
  Else
    Call Shell(ThisWorkbook.path & "\ACCDaemonV0.exe " & Chr(34) & Application.Caption & Chr(34) & " " & ThisWorkbook.name, vbMinimizedNoFocus)
  End If
'  Call Shell(ThisWorkbook.Path & "\ECCDaemon.exe " & GetCurrentProcess & " " & ThisWorkbook.name, vbMinimizedNoFocus)
  LogPrint "StartDaemon End"
End Sub

Sub EndDaemon()
  
  SaveSetting _
     appname:="Stromwerken", _
     Section:=ProgNameShort, _
     Key:="LiveStatus", _
     setting:="Finished"
  
  On Error Resume Next
'  Application.OnTime NextTime, "SetLiveStatus", , False
End Sub

Sub SetLiveStatus()

  SaveSetting _
     appname:="Stromwerken", _
     Section:=ProgNameShort, _
     Key:="LiveStatusTime", _
     setting:=Now
  
  SaveSetting _
     appname:="Stromwerken", _
     Section:=ProgNameShort, _
     Key:="LiveStatus", _
     setting:="Alive"

'  NextTime = Now + TimeValue("00:01:00")
'  Application.OnTime NextTime, "SetLiveStatus"
  
End Sub


Sub GetStartEndTime()
  G_StartScan = "00:00:00"
  G_EndScan = "00:00:00"
  
  If IsDate(GetSetting(appname:="Stromwerken", Section:="ECC", Key:="StartScan", Default:="00:00:00")) Then
    G_StartScan = GetSetting(appname:="Stromwerken", Section:="ECC", Key:="StartScan", Default:="00:00:00")
  End If
  If IsDate(GetSetting(appname:="Stromwerken", Section:="ECC", Key:="EndScan", Default:="00:00:00")) Then
    G_EndScan = GetSetting(appname:="Stromwerken", Section:="ECC", Key:="EndScan", Default:="00:00:00")
  End If
  
  If Not StartedByTracker Then Exit Sub
  
  LogPrint "ECCScan: " & G_StartScan & " - " & G_EndScan
  
End Sub

Attribute VB_Name = "StatusForm"
Attribute VB_Base = "0{FCF4A53E-E43D-4501-8EA6-D251DE181703}{A8619181-E2B5-48C5-B211-6B5AF201AEDC}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Sub UserForm_Initialize()
  gTranslation.TranslateForm Me
End Sub
Attribute VB_Name = "Tabelle1"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Tabelle2"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Translation"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

#If VBA6 Or VBA7 Then
    Const IS_VBA = True
#Else
    Const IS_VBA = False
#End If

' ------------------------------------------------------------------
Private Const NoError = 0       'The Function call was successful

Private Const LOCALE_USER_DEFAULT = &H400
Private Const LOCALE_SISO639LANGNAME = &H59
Private Const LOCALE_SISO3166CTRYNAME = &H5A

#If VBA7 Then
    Private Declare PtrSafe Function WNetGetUser Lib "mpr.dll" _
          Alias "WNetGetUserA" (ByVal lpName As String, _
          ByVal lpUserName As String, lpnLength As Long) As Long
          
    ' Caution:  If the user default locale is a custom locale, an application cannot accurately tag data
    ' with the value or exchange it. In this case, the application should use GetUserDefaultLocaleName
    ' (available starting with Windows Vista) in preference to GetUserDefaultLCID.
    Private Declare PtrSafe Function GetUserDefaultLCID Lib "kernel32" () As Long
    
    ' List of Language Identifier Constants and Strings:
    ' https://msdn.microsoft.com/library/dd318693.aspx
    Private Declare PtrSafe Function GetLocaleInfo Lib "kernel32" Alias "GetLocaleInfoA" ( _
        ByVal Locale As Long, _
        ByVal LCType As Long, _
        ByVal lpLCData As String, _
        ByVal cchData As Long) As Long

    ' Available since Vista
    'GetUserDefaultUILanguage
    
#Else
    Private Declare Function WNetGetUser Lib "mpr.dll" _
          Alias "WNetGetUserA" (ByVal lpName As String, _
          ByVal lpUserName As String, lpnLength As Long) As Long
    
    Private Declare Function GetUserDefaultLCID Lib "kernel32" () As Long
    
    Private Declare Function GetLocaleInfo Lib "kernel32" Alias "GetLocaleInfoA" ( _
        ByVal Locale As Long, _
        ByVal LCType As Long, _
        ByVal lpLCData As String, _
        ByVal cchData As Long) As Long
    
#End If

' ------------------------------------------------------------------


' 0 = fallback language
Private mStringTables(2) As Collection
Private mLangIDs(2) As String
Private mCurrentUser As String

Public Property Get CurrentUser() As String
    CurrentUser = mCurrentUser
End Property


Private Sub Class_Initialize()
    mCurrentUser = GetTranslationUserName
End Sub

Public Function StartupInit(installRoot As String, app As String, Optional overrideLang As String = "") As Boolean
    On Error GoTo nogo
    ' User Language ermitteln (xy-uv)
    Dim lang As String
    If overrideLang <> "" Then
        lang = overrideLang
    Else
        'lang = GetUserLanguage
        ' Direkt das nehmen was Windows reportet
        lang = GetWindowsLanguageString
    End If
    
    Dim path As String
    Dim paths(1) As String
    Dim userPaths(1) As String
    
    Dim tries As Long
    For tries = 0 To 1
    
      paths(0) = installRoot & "\Translate\" & app & "_" & lang & ".txt"
      userPaths(0) = installRoot & "\Translate\" & app & "_" & lang & "_indiv.txt"
      
      paths(1) = installRoot & "\..\Translate\" & app & "_" & lang & ".txt"
      userPaths(1) = installRoot & "\..\Translate\" & app & "_" & lang & "_indiv.txt"
      
      Dim i As Long
      For i = 0 To UBound(paths)
          If Init(0, paths(i), lang) = True Then
              ' Und auch versuchen die user strings zu laden (falls es die gibt)
              Init 1, userPaths(i), lang
              StartupInit = True
              Exit Function
          End If
      Next i
      
      ' Nix gefunden -> Fallback language setzen
      lang = GetFallbackLanguage(lang)
    
    Next tries
    
nogo:
    StartupInit = False
End Function

Public Function Init(index As Long, path As String, langId As String) As Boolean
    Init = False
    If index >= UBound(mLangIDs) Then
        Exit Function
    End If
    
    mLangIDs(index) = UCase(langId)
    Dim c As Collection
    Set c = LoadStringTable(path)
    If c Is Nothing Then
        Exit Function
    End If
    Set mStringTables(index) = c
    Init = True
End Function

Public Sub Clear()
    Set mStringTables(0) = New Collection
    Set mStringTables(1) = New Collection
End Sub

Public Function GetLocalizedFile(path As String) As String
    Dim lang As String
    If UBound(mLangIDs) > 0 Then
        If mLangIDs(0) <> "" Then
            lang = mLangIDs(0)
        End If
    End If
    If lang = "" Then
        lang = GetWindowsLanguageString
    End If
    
    GetLocalizedFile = LocalizedFileExists(path, lang)
End Function

' Splitted path\filename.ext aus path
' Und sucht dann nach
' path\filename_lang.ext
' Wenn nix gefunden, wird lang mit einem fallback replaced.
' de-de fuer alles was de-xy
' en-gb fuer alles andere
' Oder halt den original path wenn es nichts davon gibt.
' Der gefundene pfad wird returned oder "" wenn es gar nix gibt.
Public Function LocalizedFileExists(path As String, lang As String) As String
    On Error GoTo nogo
    
    LocalizedFileExists = path
    Dim newPath As String
    
    If lang <> "" Then
        ' Direkt nach der uebergebenen Sprache in lang suchen
        newPath = InternalLocalizedFileExists(path, lang)
        If newPath <> "" Then
            LocalizedFileExists = newPath
            Exit Function
        End If
        
        ' Nix gefunden -> fallback Sprache nehmen
        If Len(lang) > 2 Then
            ' Wenn es was deutsches ist, dann nach de-de suchen
            If UCase(lang) <> "DE-DEB" And InStr(UCase(lang), "DE") > 0 Then
                newPath = InternalLocalizedFileExists(path, "de-de")
                If newPath <> "" Then
                    LocalizedFileExists = newPath
                    Exit Function
                End If
            End If
        End If
        
        ' Bis hier hin nix gefunden -> nach "en-gb" suchen
        If UCase(lang) <> "DE-DE" Then
            newPath = InternalLocalizedFileExists(path, "en-gb")
            If newPath <> "" Then
                LocalizedFileExists = newPath
                Exit Function
            End If
        End If
    End If
    
nogo:
    If Not FileExists(LocalizedFileExists) Then
        LocalizedFileExists = ""
    End If
End Function

Private Function InternalLocalizedFileExists(path As String, lang As String) As String
    On Error GoTo nogo
    
    Dim newPath As String
    Dim p As String
    Dim Filename As String
    Dim ext As String
    fileSplit path, p, Filename, ext

    newPath = FmtInternal("%1%2_%3.%4", p, Filename, lang, ext)
    If newPath <> "" And FileExists(newPath) Then
        InternalLocalizedFileExists = newPath
        Exit Function
    End If
nogo:
End Function

Public Sub AddString(tableIdx As Long, id As String, s As String)
    mStringTables(tableIdx).Add s, id
End Sub

Public Function StringExists(id As String) As Boolean
    If id = "" Then
        StringExists = True
        Exit Function
    End If
    On Error GoTo nogo
    Dim s As String
    s = mStringTables(0).item(UCase(id))
    StringExists = True
    Exit Function
nogo:
    StringExists = False
End Function

Public Function GetString(id As String) As String
    On Error GoTo nogo
    If id = "" Then
        Exit Function
    End If
    
    If mStringTables(1) Is Nothing Then
        GetString = GetFallbackString(id)
        Exit Function
    End If
    GetString = mStringTables(1).item(UCase(id))
    Exit Function
nogo:
    GetString = GetFallbackString(id)
End Function

Public Function GetFallbackString(id As String) As String
    On Error GoTo nogo
    If mStringTables(0) Is Nothing Then
        GetFallbackString = id & ": ***MISSING***"
        Exit Function
    End If
    
    GetFallbackString = mStringTables(0).item(UCase(id))
    Exit Function
nogo:
    GetFallbackString = id & ": ***MISSING***"
End Function

Public Function FormatString(FMT As String, _
                             Optional arg1 As String = vbNullChar, _
                             Optional arg2 As String = vbNullChar, _
                             Optional arg3 As String = vbNullChar, _
                             Optional arg4 As String = vbNullChar, _
                             Optional arg5 As String = vbNullChar, _
                             Optional arg6 As String = vbNullChar, _
                             Optional arg7 As String = vbNullChar, _
                             Optional arg8 As String = vbNullChar, _
                             Optional arg9 As String = vbNullChar _
                             ) As String
                             
    On Error GoTo nogo
    
    Dim argarray(8) As String
    If IsTestUser Then
        argarray(0) = arg1
        argarray(1) = arg2
        argarray(2) = arg3
        argarray(3) = arg4
        argarray(4) = arg5
        argarray(5) = arg6
        argarray(6) = arg7
        argarray(7) = arg8
        argarray(8) = arg9
        
        Dim i As Long
        ' Erstmal checken ob wir fuer jeden Placeholder einen Parameter uebergeben bekommen haben
        ' Hier koennte man auch IsMissing nehmen - aber dann muessen alle args vom Type Variant sein.
        For i = 1 To 9
            If InStr(FMT, "%" & i) > 0 Then
                If argarray(i - 1) = vbNullChar Then
                    MsgBox FMT & vbCrLf & vbCrLf & "ERROR in FormatString: No arg for %" & i, vbCritical
                    Exit Function
                End If
            End If
        Next i
    Else
        argarray(0) = IIf(arg1 = vbNullChar, "", arg1)
        argarray(1) = IIf(arg2 = vbNullChar, "", arg2)
        argarray(2) = IIf(arg3 = vbNullChar, "", arg3)
        argarray(3) = IIf(arg4 = vbNullChar, "", arg4)
        argarray(4) = IIf(arg5 = vbNullChar, "", arg5)
        argarray(5) = IIf(arg6 = vbNullChar, "", arg6)
        argarray(6) = IIf(arg7 = vbNullChar, "", arg7)
        argarray(7) = IIf(arg8 = vbNullChar, "", arg8)
        argarray(8) = IIf(arg9 = vbNullChar, "", arg9)
    End If
    
    Dim r As String
    r = FMT
    
    r = Replace(r, "%%", "%")
    r = Replace(r, "\n", vbCrLf)
    r = Replace(r, "\t", vbTab)
    
    For i = 1 To 9
        r = Replace(r, "%" & i, argarray(i - 1))
    Next i
    
    FormatString = r
    Exit Function

nogo:
    FormatString = "ERROR " & FMT
End Function

#If TEST_BUILD = 1 Then
#Else
#End If

'Public Function FormatString(fmt As String, _
'                             Optional arg1 As String, _
'                             Optional arg2 As String, _
'                             Optional arg3 As String, _
'                             Optional arg4 As String, _
'                             Optional arg5 As String, _
'                             Optional arg6 As String, _
'                             Optional arg7 As String, _
'                             Optional arg8 As String, _
'                             Optional arg9 As String _
'                             ) As String
'    On Error GoTo nogo
'
'    Dim argarray(8) As String
'    argarray(0) = arg1
'    argarray(1) = arg2
'    argarray(2) = arg3
'    argarray(3) = arg4
'    argarray(4) = arg5
'    argarray(5) = arg6
'    argarray(6) = arg7
'    argarray(7) = arg8
'    argarray(8) = arg9
'    Dim i As Long
'    Dim r As String
'    r = fmt
'    For i = 1 To 9
'        r = Replace(r, "%" & i, argarray(i - 1))
'    Next i
'    r = Replace(r, "%%", "%")
'    r = Replace(r, "\n", vbCrLf)
'    r = Replace(r, "\t", vbTab)
'
'    FormatString = r
'    Exit Function
'
'nogo:
'    FormatString = "ERROR " & fmt
'End Function

Private Function GetTranslationTags(controlTag As String) As String()
    Dim tags() As String
    ' Argh.  Die Split Funktion in VBA gibt ein Element zurueck bei Split("test", ",")
    ' In VB6 aber nicht.
    ' Dann haben wir eine eigene implementierung fuer Split in MailSenden.bas. Die ist wie die VB6 version
    ' Also immer stur ein ',' dranhaengen
    tags = Split(controlTag & ",", ",")
    
    Dim invalidTags() As String
    invalidTags = Split("FIXLEFT,FIXTOP,NORESIZE", ",")
    
    Dim result As String
    
    Dim t As Variant
    For Each t In tags
        t = Trim(t)
        If t <> "" And Not IsOneOf(UCase(t), invalidTags) Then
            If Len(result) > 0 Then
                result = result & "," & t
            Else
                result = t
            End If
        End If
    Next t
    GetTranslationTags = Split(result & ",", ",")
End Function

Private Function IsOneOf(s As String, arr() As String) As Boolean
    IsOneOf = False
    If Len(s) = 0 Then
        Exit Function
    End If
    
    Dim e As Variant
    For Each e In arr
        If s = e Then
            IsOneOf = True
            Exit Function
        End If
    Next e
End Function

Private Sub TranslateControl(ctl As Object)
    On Error GoTo nogo
    Dim tag As String
    tag = ctl.tag
    If tag <> "" Then
        Dim tags() As String
        tags = GetTranslationTags(tag)
    
        ' Caption
        Dim s As String
        s = FMT0(tags(0))
        If s <> "" Then
#If IS_VBA Then
            If TypeOf ctl Is MSForms.TextBox Then
#Else
            If TypeOf ctl Is TextBox Then
#End If
                ctl.Text = s
            'ElseIf TypeOf ctl Is MSForms.UserForm Then
            Else
                ctl.Caption = s
            End If
        End If
        
        ' ControlTipText
        If UBound(tags) > 0 Then
            s = FMT0(tags(1))
            If s <> "" Then
#If IS_VBA Then
                If TypeOf ctl Is MSForms.MultiPage Then
                    ' MultiPage hat keinen tooltip
                Else
                    ctl.ControlTipText = s
                End If
#Else
                ctl.TooltipText = s
#End If
            End If
        End If
    End If

    Exit Sub
nogo:
    Debug.Print Err.Description
End Sub

Public Sub TranslateForm(frm As Object)
    TranslateControl frm
    
    
    Dim ctl As Object
    For Each ctl In frm.Controls
        
        'If ctl.ControlType = acTextBox Then
#If IS_VBA Then
        If TypeOf ctl Is MSForms.MultiPage Then
#Else
        If False Then
#End If
            TranslateControl ctl
            Dim page As Object
            For Each page In ctl.Pages
                TranslateControl page
            Next page
#If IS_VBA Then
        ElseIf TypeOf ctl Is MSForms.Frame Then
            TranslateForm ctl
#Else
        'ElseIf TypeOf ctl Is Frame Then
#End If
        Else
            TranslateControl ctl
        'ElseIf ctl.ControlType = acSubform Then
        '    TranslateForm frm(ctl.name).Form
        End If
    Next ctl
    
End Sub

' Die Sprache die der user in Windows eingestellt hat
' Rueckgabewert: Eine unserer supporteten languages
Public Function GetUserLanguage() As String
    Dim lcid As Long
    lcid = GetUserDefaultLCID()
    GetUserLanguage = MapLCIDToInternalLanguage(lcid)
End Function

' Die Sprache des installierten Ms Office
' Rueckgabewert: Eine unserer supporteten languages
Public Function GetMsOfficeLanguage() As String
    Dim lcid As Long
    lcid = Application.LanguageSettings.LanguageID(msoLanguageIDUI)
    GetMsOfficeLanguage = MapLCIDToInternalLanguage(lcid)
End Function



' -------------------------------------------------------------------
'
' -------------------------------------------------------------------

Function LoadStringTable(path As String) As Collection
    On Error GoTo nogo
    Set LoadStringTable = Nothing
    
    Const ForReading = 1
    Const TristateUseDefault = -2, TristateTrue = -1, TristateFalse = 0
    
    Dim fs, F, ts
    Set ts = Nothing
    Set fs = CreateObject("Scripting.FileSystemObject")
    Set ts = fs.OpenTextFile(path, ForReading, False, TristateTrue)
    
    'Dim sheet As Worksheet
    'Set sheet = ThisWorkbook.Sheets("Test")
    'Dim y As Long
    'y = 1
    
    Dim c As New Collection
    Dim s As String
    Do While ts.AtEndOfStream <> True
        ' This really is a Unicode string, although the debugger and MsgBox show ??
        s = ts.ReadLine
        'sheet.Cells(y, 1) = s
        'y = y + 1
        
        If ExtractString(s, c) Then
        End If
    Loop
    Set LoadStringTable = c
nogo:
    If Not ts Is Nothing Then
        ts.Close
        Set ts = Nothing
    End If
    If Not fs Is Nothing Then
        Set fs = Nothing
    End If
End Function

Function ExtractString(line As String, c As Collection) As Boolean
    On Error GoTo nogo
    
    ExtractString = False
    If line = "" Then
        Exit Function
    End If
    If Left(line, 1) = "'" Then
        Exit Function
    End If
    
    Dim pos As Long
    pos = InStr(line, " ")
    If pos <= 0 Then
        Exit Function
    End If
    
    Dim id As String
    Dim value As String
    id = Left(line, pos - 1)
    value = Mid(line, pos + 1, Len(line) - pos)
    If Not CollectionStringExists(c, id) Then
        c.Add value, id
    End If
    
    ExtractString = True
    Exit Function
nogo:
    MsgBox Err.Description
End Function

Private Function IsTestUser() As Boolean
    If mCurrentUser = "dirk" Or _
        mCurrentUser = "dwinter" Or _
        mCurrentUser = "norman" Or _
        mCurrentUser = "nneubert" Or _
        mCurrentUser = "rolf" Or _
        mCurrentUser = "rlangenberg" Then
        
        IsTestUser = True
    End If
End Function

Private Function GetTranslationUserName() As String
   ' Buffer size for the return string.
   Const lpnLength As Integer = 255

   ' Get return buffer space.
   Dim status As Integer

   ' For getting user information.
   Dim lpName, lpUserName As String

   ' Assign the buffer size constant to lpUserName.
   lpUserName = Space$(lpnLength + 1)

   ' Get the log-on name of the person using product.
   status = WNetGetUser(lpName, lpUserName, lpnLength)

   ' See whether error occurred.
   If status = NoError Then
      ' This line removes the null character. Strings in C are null-
      ' terminated. Strings in Visual Basic are not null-terminated.
      ' The null character must be removed from the C strings to be used
      ' cleanly in Visual Basic.
      lpUserName = Left$(lpUserName, InStr(lpUserName, Chr(0)) - 1)
   Else
      lpUserName = "Unbekannt"
   End If

    GetTranslationUserName = lpUserName
End Function

Private Function CollectionStringExists(c As Collection, name As String) As Boolean
  On Error GoTo notReadable
  Dim s As String
  s = c(name)
  CollectionStringExists = True
  Exit Function
  
notReadable:
  CollectionStringExists = False
End Function

Private Function LCIDToLanguageCode(lcid As Long) As String

    ' Locale IDs
    ' https://msdn.microsoft.com/en-us/goglobal/bb964664
    'Arabic (Saudi Arabia)                1025
    'Arabic (Iraq)                        2049
    'Arabic (Egypt)                       3073
    'Arabic (Libya)                       4097
    'Arabic (Algeria)                     5121
    'Arabic (Morocco)                     6145
    'Arabic (Tunisia)                     7169
    'Arabic (Oman)                        8193
    'Arabic (Yemen)                       9217
    'Arabic (Syria)                      10241
    'Arabic (Jordan)                     11265
    'Arabic (Lebanon)                    12289
    'Arabic (Kuwait)                     13313
    'Arabic (U.A.E.)                     14337
    'Arabic (Bahrain)                    15361
    'Arabic (Qatar)                      16385
    'Bulgarian                            1026
    'Catalan                              1027
    'Chinese (Taiwan)                     1028
    'Chinese (PRC)                        2052
    'Chinese (Hong Kong SAR               3076
    'Chinese (Singapore)                  4100
    'Czech                                1029
    'Danish                               1030
    'German (Germany)                     1031
    'German (Swiss)                       2055
    'German (Austrian)                    3079
    'German (Luxembourg)                  4103
    'German (Liechtenstein)               5127
    'Greek                                1032
    'English (United States)              1033
    'English (United Kingdom)             2057
    'English (Australian)                 3081
    'English (Canadian)                   4105
    'English (New Zealand)                5129
    'English (Ireland)                    6153
    'English (South Africa)               7177
    'English (Jamaica)                    8201
    'English (Caribbean)                  9225
    'English (Belize)                    10249
    'English (Trinidad)                  11273
    'Spanish (Traditional Sort)           1034
    'Spanish (Mexican)                    2058
    'Spanish (Modern Sort)                3082
    'Spanish (Guatemala)                  4106
    'Spanish (Costa Rica)                 5130
    'Spanish (Panama)                     6154
    'Spanish (Dominican Republic)         7178
    'Spanish (Venezuela)                  8202
    'Spanish (Colombia)                   9226
    'Spanish (Peru)                      10250
    'Spanish (Argentina)                 11274
    'Spanish (Ecuador)                   12298
    'Spanish (Chile)                     13322
    'Spanish (Uruguay)                   14346
    'Spanish (Paraguay)                  15370
    'Spanish (Bolivia)                   16394
    'Spanish (El Salvador)               17418
    'Spanish (Honduras)                  18442
    'Spanish (Nicaragua)                 19466
    'Spanish (Puerto Rico)               20490
    'Finnish                              1035
    'French (Standard)                    1036
    'French (Belgian)                     2060
    'French (Canadian)                    3084
    'French (Swiss)                       4108
    'French (Luxembourg)                  5132
    'Hebrew                               1037
    'Hungarian                            1038
    'Icelandic                            1039
    'Italian (Standard)                   1040
    'Italian (Swiss)                      2064
    'Japanese                             1041
    'Korean                               1042
    'Korean (Johab)                       2066
    'Dutch (Standard)                     1043
    'Dutch (Belgian)                      2067
    'Norwegian (Bokmal)                   1044
    'Norwegian (Nynorsk)                  2068
    'Polish                               1045
    'Portuguese (Brazil)                  1046
    'Portuguese (Portugal)                2070
    'Romanian                             1048
    'Russian                              1049
    'Croatian                             1050
    'Serbian (Latin)                      2074
    'Serbian (Cyrillic)                   3098
    'Slovak                               1051
    'Albanian                             1052
    'Swedish                              1053
    'Swedish (Finland)                    2077
    'Thai                                 1054
    'Turkish                              1055
    'Indonesian                           1057
    'Ukrainian                            1058
    'Belarusian                           1059
    'Slovenian                            1060
    'Estonian                             1061
    'Latvian                              1062
    'Lithuanian                           1063
    'Farsi                                1065
    'Vietnamese                           1066
    'Basque                               1069
    'Afrikaans                            1078
    'Faeroese                             1080

    'Dim langs As Variant
    'langs = [{1031, "de-de"; 2055, "de-ch"}]
    'langs = Array( _
    '        1031, "de-de" _
    '    )
    
    ' Default ist Englisch
    LCIDToLanguageCode = "en-gb"

    ' https://msdn.microsoft.com/en-us/library/ee825488(v=cs.20).aspx
    Select Case lcid
    Case 1031
        'German (Germany)
        LCIDToLanguageCode = "de-de"
    Case 2055
        'German (Swiss)
        LCIDToLanguageCode = "de-ch"
    Case 3079
        'German (Austrian)
        LCIDToLanguageCode = "de-at"
    Case 4103
        'German (Luxembourg)
        LCIDToLanguageCode = "de-lu"
    Case 5127
        'German (Liechtenstein)
        LCIDToLanguageCode = "de-li"
        
    Case 1033
        'English (United States)
        LCIDToLanguageCode = "en-us"
    Case 2057
        'English (United Kingdom)
        LCIDToLanguageCode = "en-gb"
    Case 3081
        'English (Australian)
        LCIDToLanguageCode = "en-au"
    Case 4105
        'English (Canadian)
        LCIDToLanguageCode = "en-ca"
    Case 5129
        'English (New Zealand)
        LCIDToLanguageCode = "en-nz"
    Case 6153
        'English (Ireland)
        LCIDToLanguageCode = "en-ie"
    Case 7177
        'English (South Africa)
        LCIDToLanguageCode = "en-za"
    Case 8201
        'English (Jamaica)
        LCIDToLanguageCode = "en-jm"
    Case 9225
        'English (Caribbean)
        LCIDToLanguageCode = "en-cb"
    Case 10249
        'English (Belize)
        LCIDToLanguageCode = "en-bz"
    Case 11273
        'English (Trinidad and Tobago)
        LCIDToLanguageCode = "en-tt"
    End Select
End Function

Private Function MapLCIDToInternalLanguage(lcid As Long) As String
    Dim langCulture As String
    langCulture = LCIDToLanguageCode(lcid)
    
    ' Alles was de-xy hat wird auf de-de abgebildet
    If Left(langCulture, 2) = "de" Then
        MapLCIDToInternalLanguage = LANG_DE_DE
    Else
        ' Alles andere wird en-gb
        MapLCIDToInternalLanguage = LANG_EN_GB
    End If
    
End Function

Public Function GetWindowsLanguageString() As String
    On Error GoTo nogo
    
    Dim ret As Long
    Dim loc As String
    Dim windowsLang As String
    
    loc = Space$(255)
    ret = GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SISO639LANGNAME, loc, 9)
    loc = Left$(loc, InStr(loc, Chr(0)) - 1)
    windowsLang = loc & "-"
    
    loc = Space$(255)
    ret = GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SISO3166CTRYNAME, loc, 9)
    loc = Left$(loc, InStr(loc, Chr(0)) - 1)
    windowsLang = windowsLang & loc
    
    GetWindowsLanguageString = LCase(windowsLang)
    Exit Function
nogo:
    GetWindowsLanguageString = "en-gb"
End Function

Private Function GetFallbackLanguage(lang As String) As String
    ' Alles was de-xy hat wird auf de-de abgebildet
    If Left(lang, 2) = "de" Then
        GetFallbackLanguage = LANG_DE_DE
    Else
        ' Alles andere wird en-gb
        GetFallbackLanguage = LANG_EN_GB
    End If
End Function







Attribute VB_Name = "TranslationHelpers"
Option Explicit

' Fallbacksprachen
' Regeln:
 '  File APP_en-xy.txt nicht da -> APP_en-gb.txt benutzen
 '  File APP_de-xy.txt nicht da -> APP_de-de.txt benutzen
 '  File APP_xy-uv.txt nicht da -> APP_en-gb.txt benutzen
Public Const LANG_EN_GB As String = "en-gb"
Public Const LANG_DE_DE As String = "de-de"

Public gTranslation As New Translation

Public Function InitTranslation(path As String, langFile As String, cfg As CfgReader) As Boolean
    InitTranslation = False
    Dim overrideLanguage As String
    If Not cfg Is Nothing Then
        If cfg.GetSection("GLOBALS") = True Then
            overrideLanguage = cfg.GetValue("LANGUAGE")
        End If
    End If
    If Not gTranslation.StartupInit(path, langFile, overrideLanguage) Then
        ' Sprachdateien wurden nicht geladen
        MsgBox FmtInternal("Missing language files ('%1_en-gb.txt')!" & vbCrLf & vbCrLf & "Die Sprachdateien wurden nicht gefunden ('%1_de-de.txt')!", langFile), vbCritical
        Exit Function
    End If
    InitTranslation = True
End Function

Public Function FMT0(F As String) As String
    FMT0 = FmtInternal(TR(F))
End Function

Public Function FMT1(F As String, _
                     ByVal arg1 As String) As String
    FMT1 = FmtInternal(TR(F), arg1)
End Function

Public Function FMT2(F As String, _
                     ByVal arg1 As String, _
                     ByVal arg2 As String) As String
    FMT2 = FmtInternal(TR(F), arg1, arg2)
End Function

Public Function FMT3(F As String, _
                     ByVal arg1 As String, _
                     ByVal arg2 As String, _
                     ByVal arg3 As String) As String
    FMT3 = FmtInternal(TR(F), arg1, arg2, arg3)
End Function

Public Function FMT4(F As String, _
                     ByVal arg1 As String, _
                     ByVal arg2 As String, _
                     ByVal arg3 As String, _
                     ByVal arg4 As String) As String
    FMT4 = FmtInternal(TR(F), arg1, arg2, arg3, arg4)
End Function

Public Function FMT5(F As String, _
                     ByVal arg1 As String, _
                     ByVal arg2 As String, _
                     ByVal arg3 As String, _
                     ByVal arg4 As String, _
                     ByVal arg5 As String) As String
    FMT5 = FmtInternal(TR(F), arg1, arg2, arg3, arg4, arg5)
End Function

Public Function GetTranslationString(id As String, fallback As String) As String
    If gTranslation.StringExists(id) Then
        GetTranslationString = gTranslation.GetString(id)
        Exit Function
    End If
    GetTranslationString = fallback
End Function

Public Function TR(id As String) As String
'    If gTranslation Is Nothing Then
'        TR = "gTranslation Not Initialized"
'        Exit Function
'    End If
    TR = gTranslation.GetString(id)
End Function

Public Function FmtInternal(F As String, _
                    Optional arg1 As String = vbNullChar, _
                    Optional arg2 As String = vbNullChar, _
                    Optional arg3 As String = vbNullChar, _
                    Optional arg4 As String = vbNullChar, _
                    Optional arg5 As String = vbNullChar, _
                    Optional arg6 As String = vbNullChar, _
                    Optional arg7 As String = vbNullChar, _
                    Optional arg8 As String = vbNullChar, _
                    Optional arg9 As String = vbNullChar _
                    ) As String
    FmtInternal = gTranslation.FormatString(F, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)
End Function

Public Function IsYes(s As String) As Boolean
  If UCase(s) = "JA" Or UCase(s) = "YES" Then
    IsYes = True
  End If
End Function

Public Function IsNo(s As String) As Boolean
  If UCase(s) = "NEIN" Or UCase(s) = "NO" Then
    IsNo = True
  End If
End Function

Public Function IsTrue(s As String) As Boolean
    If UCase(s) = "WAHR" Or UCase(s) = "TRUE" Then
        IsTrue = True
    End If
End Function

Public Function IsFalse(s As String) As Boolean
    If UCase(s) = "FALSCH" Or UCase(s) = "FALSE" Then
        IsFalse = True
    End If
End Function

Private Function MyWorksheetExists(ByRef wb, wsname As String) As Boolean
    On Error GoTo nogo
    Dim ws
    Set ws = wb.Worksheets(wsname)
    Set ws = Nothing
    MyWorksheetExists = True
    Exit Function
nogo:
End Function

Public Function TranslationSheetExists(ByRef wb As Workbook, names As Variant) As String
    On Error GoTo nogo
    Dim name As String
    If IsArray(names) Then
        Dim n As Variant
        For Each n In names
            name = CStr(n)
            If MyWorksheetExists(wb, name) Then
                TranslationSheetExists = name
                Exit Function
            End If
        Next n
        If UBound(names) >= 0 Then
            TranslationSheetExists = CStr(names(0))
            Exit Function
        End If
    Else
        name = CStr(names)
        If MyWorksheetExists(wb, name) Then
            TranslationSheetExists = name
            Exit Function
        End If
    End If
nogo:
    
End Function

' Das gleiche wie Cells.Find - aber probiert mehrere Strings zu finden (fuer mehrere Sprachen)
Public Function TranslationFindCells(ws As Worksheet, What As Variant, LookIn As Excel.XlFindLookIn, _
                                     LookAt As Excel.XlLookAt, SearchOrder As Excel.XlSearchOrder, _
                                     SearchDirection As Excel.XlSearchDirection, MatchCase As Boolean) As Range
  Set TranslationFindCells = Nothing
  Dim s As Variant
  For Each s In What
    Dim r As Range
    Set r = ws.Cells.Find(CStr(s), LookIn:=LookIn, LookAt:=LookAt, SearchOrder:=SearchOrder, SearchDirection:=SearchDirection, MatchCase:=MatchCase)
    If Not r Is Nothing Then
      Set TranslationFindCells = r
      Exit Function
    End If
  Next s
End Function

' This works because Debug.Print is omitted in the compiled code
Public Function InIDE() As Boolean
  On Error Resume Next
  Debug.Print 0 / 0
  InIDE = Err.Number <> 0
End Function



Attribute VB_Name = "UNC"
Option Explicit
    

' Fuer CacheMappedDrives()
'Dim mMappedDrives As Collection
Dim mMappedDrives(0 To 25) As String
Dim mUsedDriveLetters(0 To 25) As String
Dim mNumUsedDrives As Integer
    
#If VBA7 Then
Private Declare PtrSafe Function WNetGetConnectionA Lib "mpr.dll" ( _
  ByVal lpszLocalName As String, _
  ByVal lpszRemoteName As String, _
  cbRemoteName As Long) As Long
#Else
Private Declare Function WNetGetConnectionA Lib "mpr.dll" ( _
  ByVal lpszLocalName As String, _
  ByVal lpszRemoteName As String, _
  cbRemoteName As Long) As Long
#End If

Public Function GetUNCPath(ByVal sLocalPath As String) As String
    '// -----------------------------------------------------------------
    '// Methode:   | Konvertiert einen Pfad in UNC-Pfad (\\SERVER\...)
    '// -----------------------------------------------------------------
    '// Parameter: | sLocalPath = g|fffd|ltiger, lokaler Pfad (X:\..)
    '// -----------------------------------------------------------------
    '// R|fffd|ckgabe:  | bei Erfolg = UNC-Pfad
    '//            | bei Fehler = sLocalPath
    '// -----------------------------------------------------------------
    Const NO_ERROR As Long = 0
    Dim sUNCPath As String
    Dim sResult As String
    Dim sDrive As String

    On Error Resume Next
    GetUNCPath = sLocalPath
    If Mid$(sLocalPath, 2, 1) <> ":" Then Exit Function
    '// Die API-Funktion ben|fffd|tigt nur das Laufwerk!
    sDrive = Left$(sLocalPath, 2)
    sUNCPath = Space$(260)
    If WNetGetConnectionA(sDrive, sUNCPath, Len(sUNCPath)) = NO_ERROR Then
        sResult = Left$(sUNCPath, InStr(sUNCPath, vbNullChar) - 1)
        If Len(sResult) > 0 Then
            GetUNCPath = sResult & Mid$(sLocalPath, 3)
        End If
    End If

End Function

Public Sub CacheMappedDrives()
    mNumUsedDrives = 0
    Dim i As Integer
    For i = 65 To 90
        Dim strUNCPath As String
        strUNCPath = ""
        If GetUNCPathShort(Chr(i) & ":", strUNCPath) = 0 Then
            mMappedDrives(mNumUsedDrives) = UCase(strUNCPath)
            mUsedDriveLetters(mNumUsedDrives) = Chr(i)
            mNumUsedDrives = mNumUsedDrives + 1
        Else
        
        End If
    Next i
End Sub

' Wir nehmen an uncPath ist all upper case
Public Function GetCachedMappedDrive(uncPath As String) As String
    GetCachedMappedDrive = uncPath
    Dim i As Integer
    For i = 0 To mNumUsedDrives - 1
        If mMappedDrives(i) = Left$(uncPath, Len(mMappedDrives(i))) Then
            GetCachedMappedDrive = mUsedDriveLetters(i) & ":" & Mid$(uncPath, Len(mMappedDrives(i)) + 1)
            Exit For
        End If
    Next i
End Function

Function GetDriveAndPathFromUNC(ByVal strFullPath As String) As String

    If Mid(strFullPath, 2, 1) = ":" Then
      GetDriveAndPathFromUNC = strFullPath
      Exit Function
    End If

    Dim strUNC As String
    Dim i As Integer
    Dim s As String

    s = strFullPath

    For i = 65 To 90
        If GetUNCPathShort(Chr(i) & ":", strUNC) = 0 Then
            If UCase(strUNC) = UCase(Left(strFullPath, Len(strUNC))) Then
              If Len(Chr(i) & ":" & Mid(strFullPath, Len(strUNC) + 1, Len(strFullPath) - (Len(strUNC)))) < Len(s) Then
                s = Chr(i) & ":" & Mid(strFullPath, Len(strUNC) + 1, Len(strFullPath) - (Len(strUNC)))
              End If
            End If
        End If
    Next i
    
    GetDriveAndPathFromUNC = s
    
End Function


Function GetUNCPathShort(ByVal strDriveLetter As String, _
    ByRef strUNCPath As String) As Long
    On Local Error GoTo GetUNCPath_Err
    Dim strMsg As String
    Dim lngReturn As Long
    Dim strLocalName As String
    Dim strRemoteName As String
    Dim lngRemoteName As Long
    strLocalName = strDriveLetter
    strRemoteName = String$(255, Chr$(32))
    
    lngRemoteName = Len(strRemoteName)
    'Attempt to grab UNC
    lngReturn = WNetGetConnectionA(strLocalName, _
    strRemoteName, _
    lngRemoteName)


    If lngReturn = 0 Then
        
        'No problems - return the UNC
        'to the passed ByRef string
        GetUNCPathShort = 0
        
        
        ' only works for omni 2 build
        ' strUNCPath = LTrim(strRemoteName)
        ' strUNCPath = Left$(strUNCPath, Len(str
        '     UNCPath) - 1)
        
        
        ' less acurate potential for error if se
        '     rver or share contains spaces.
        
        If InStr(strRemoteName, Chr(0)) > 0 Then
          strUNCPath = Left(strRemoteName, InStr(strRemoteName, Chr(0)) - 1)
        Else
          strUNCPath = Mid(strRemoteName, 1, (InStr(1, strRemoteName, " ", 1)) - 2)
        End If
        
        
    Else
        'Problems - so return original
        'drive letter and error number
        GetUNCPathShort = lngReturn
        strUNCPath = strDriveLetter & "\"
    End If
GetUNCPath_End:
    Exit Function
GetUNCPath_Err:
    GetUNCPathShort = 1
    strUNCPath = strDriveLetter
    Resume GetUNCPath_End
End Function



Attribute VB_Name = "Var"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False



Public m_Name As String
Public m_Type As String
Public m_Translation As String

Attribute VB_Name = "VarGroup"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False



Public m_Name As String
Public m_Vars As Collection
Public m_Type As String

Sub Init()
  Set m_Vars = New Collection
End Sub

Attribute VB_Name = "XLFld"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Public m_Name As String
Public m_Col As Collection

Public Sub Init(n As String)
  m_Name = n
  Set m_Col = New Collection
End Sub

Attribute VB_Name = "XLFldVal"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Public m_Value As Long
Public m_Txt As String


Attribute VB_Name = "XLForNext"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False



Public m_Name As String
Public m_Ref
Public m_Current As Long
Public m_Width As Long
Public m_WidthCurrent As Long
Attribute VB_Name = "XLScript"
Option Explicit

Public Beenden As Boolean

' Public m_LogY As Long
Private m_WS As Excel.Worksheet
Public m_Flds As Collection
Private m_FN As Collection
Private m_CodeStart As String
Private m_Log As Collection

Private m_SimpleVars As Collection
Private m_Vars As Collection
Private m_VarArray As Collection
Private m_VarArray2D As Collection
Private m_GlobalObjects As Collection

#Const USE_MDB = True
' #Const USE_XLS = True


#Const USE_LATE_BINDING_MDB = True
#Const USE_LATE_BINDING_XLS = False

#If USE_MDB = True Then
  Private m_ResultWorkbook As Excel.Workbook
#End If


#If USE_LATE_BINDING_MDB = True Then
  Public m_App As Object
  Public m_DB As Object
  Public m_Workspace As Object
#Else
  Public m_App As Access.Application
  Public m_DB As Database
  Public m_Workspace As Workspace
#End If

#If USE_LATE_BINDING_XLS = True Then
  Global m_Workbook As Object
  Global m_Excel As Object
#Else
  Global m_Workbook As Excel.Workbook
  Global m_Excel As Excel.Application
#End If

Public Const XLSCript_Debug As Boolean = False
Private m_InPrint As Boolean

Public m_AllVars As Collection

Private MyLastTime As Date

Public Function XLScriptCreateAccessApp(v As Long) As Object
  Set XLScriptCreateAccessApp = CreateObject("Access.Application." & v)
End Function

Public Function XLScriptCheckAccessVersion(v As Long) As Boolean
XLScriptCheckAccessVersion = False
On Error Resume Next
  Dim o As Object
  SaveSetting appname:="Stromwerken", Section:="AccessTracker", Key:="IgnoreThisOne", setting:="True"
  Set o = CreateObject("Access.Application." & v)
  If Not o Is Nothing Then
    XLScriptCheckAccessVersion = True
    o.CloseCurrentDatabase
    o.Quit
    Set o = Nothing
  End If
  SaveSetting appname:="Stromwerken", Section:="AccessTracker", Key:="IgnoreThisOne", setting:="False"
End Function

Public Sub XLScriptStore(fn As String)
  Dim ff As Integer
  ff = FreeFile
  Open fn For Output As #ff
    Dim item
    If m_VarArray2D.count > 0 Then
      For Each item In m_VarArray2D
        item.Store ff
      Next item
    End If
    If m_VarArray.count > 0 Then
      For Each item In m_VarArray
        item.Store ff
      Next item
    End If
    If m_Vars.count > 0 Then
      For Each item In m_Vars
        item.Store ff
      Next item
    End If
  Close #ff
End Sub

Public Sub XLScriptRegisterGlobalObject(n As String, o As Variant)
  
  On Error Resume Next
  m_GlobalObjects.Remove n
  
  Dim gob As XLScriptGlobalObject
  Set gob = New XLScriptGlobalObject
  gob.m_Name = n
  gob.m_Object = o
  m_GlobalObjects.Add gob, CStr(n)

End Sub

Public Function XLScriptGetGlobalObject(n As String) As Variant
  On Error GoTo NoObject
  Set XLScriptGetGlobalObject = Nothing
  Set XLScriptGetGlobalObject = m_GlobalObjects(n)
  
  Exit Function
NoObject:
  'If Not StartedByTracker Then MsgBox "ERROR: XLScriptGetGlobalObject: Object '" & n & "' not found!", vbCritical, "XLScript"
  If Not StartedByTracker Then MsgBox FMT1("XLSCRIPT_1", n), vbCritical, "XLScript"
End Function

Public Sub XLScriptInitDebug()
  If XLSCript_Debug = True Or StartedByTracker = True Then
    Set m_AllVars = New Collection
  End If
End Sub

Public Sub XLDumpNonprinted()
  If XLSCript_Debug Then
    Dim item
    For Each item In m_AllVars
      If Not item.m_WasPrinted Then
        Select Case TypeName(item)
          Case "XLScriptArray"
            Debug.Print TypeName(item), item.m_SortName
          Case "XLScriptArray2D"
            Debug.Print TypeName(item), item.m_SortName
          Case "XLScriptSimpleVar"
            Debug.Print TypeName(item), item.m_Txt, item.m_Value
          Case "XLScriptVar"
            Debug.Print TypeName(item), item.m_SortName
          Case Else
            Debug.Print "Unknown Type: " & TypeName(item)
        End Select
      End If
    Next item
  End If
End Sub

#If USE_MDB = True Then
Public Sub XLScriptInitGlobals(ByRef ex As Excel.Application, wb As Excel.Workbook)
  Set m_GlobalObjects = New Collection
  Set m_FN = New Collection
  Set m_Flds = New Collection
  Set m_VarArray2D = New Collection
  Set m_VarArray = New Collection
  Set m_Vars = New Collection
  Set m_SimpleVars = New Collection
  Set m_AllVars = New Collection
  Set m_ResultWorkbook = wb
  Set m_Excel = ex
End Sub
Public Sub XLScriptExitGlobals()
  Set m_FN = Nothing
  Set m_Flds = Nothing
  Set m_VarArray2D = Nothing
  Set m_VarArray = Nothing
  Set m_Vars = Nothing
  Set m_SimpleVars = Nothing
  Set m_GlobalObjects = Nothing
  Set m_Excel = Nothing
  Set m_ResultWorkbook = Nothing
End Sub

#Else
Public Sub XLScriptInitGlobals()
'  If m_LogY <= 0 Then m_LogY = 1
  Set m_GlobalObjects = New Collection
  Set m_FN = New Collection
  Set m_Flds = New Collection
  Set m_VarArray2D = New Collection
  Set m_VarArray = New Collection
  Set m_Vars = New Collection
  Set m_SimpleVars = New Collection
  Set m_Log = New Collection
End Sub

Public Sub XLScriptExitGlobals()
  Set m_FN = Nothing
  Set m_Flds = Nothing
  Set m_VarArray2D = Nothing
  Set m_VarArray = Nothing
  Set m_Vars = Nothing
  Set m_SimpleVars = Nothing
  Set m_Log = Nothing
  Set m_GlobalObjects = Nothing
End Sub
#End If
Public Sub XLScriptInit(ByRef ws As Excel.Worksheet, passstring As String)
  Set m_WS = ws
  m_WS.Activate
  m_CodeStart = "<!" & passstring & " "
End Sub
Public Sub XLScriptExit()
  Set m_WS = Nothing
End Sub

Public Function XLScriptCreateArray2D(n As String) As XLScriptArray2D
  Dim da As XLScriptArray2D
  Set da = New XLScriptArray2D
  da.Init n
  Set XLScriptCreateArray2D = da
  
End Function

Public Function XLScriptAddArray2D(n As String) As XLScriptArray2D
  Dim da As XLScriptArray2D
  Set da = XLScriptCreateArray2D(n)
  m_VarArray2D.Add da, CStr(n)
  Set XLScriptAddArray2D = da

  If XLSCript_Debug = True Or StartedByTracker = True Then
    If Not m_AllVars Is Nothing Then m_AllVars.Add da
  End If
End Function

Public Function XLScriptAddArray(n As String) As XLScriptArray
  Dim da As XLScriptArray
  Set da = New XLScriptArray
  da.Init n
  m_VarArray.Add da, CStr(n)
  Set XLScriptAddArray = da

  If XLSCript_Debug = True Or StartedByTracker = True Then
    If Not m_AllVars Is Nothing Then m_AllVars.Add da
  End If
End Function

Public Function XLScriptGetArray(n As String) As XLScriptArray
On Error GoTo notFound
  Set XLScriptGetArray = Nothing
  Set XLScriptGetArray = m_VarArray(CStr(n))
  Exit Function
notFound:
  'If Not StartedByTracker Then MsgBox "ERROR: XLScriptGetArray: Array '" & n & "' not found!", vbCritical, "XLScript"
  If Not StartedByTracker Then MsgBox FMT1("XLSCRIPT_2", n), vbCritical, "XLScript"
End Function

Public Function XLScriptGetArray2D(n As String) As XLScriptArray2D
On Error GoTo notFound
  Set XLScriptGetArray2D = Nothing
  Set XLScriptGetArray2D = m_VarArray2D(CStr(n))
  Exit Function
notFound:
  'If Not StartedByTracker Then MsgBox "ERROR: XLScriptGetArray2D: Array '" & n & "' not found!", vbCritical, "XLScript"
  If Not StartedByTracker Then MsgBox FMT1("XLSCRIPT_3", n), vbCritical, "XLScript"
End Function


Public Function XLScriptAddVar(n As String) As XLScriptVar
  Dim da As XLScriptVar
  Set da = New XLScriptVar
  da.Init n
  m_Vars.Add da, CStr(n)
  Set XLScriptAddVar = da
  
  If XLSCript_Debug = True Or StartedByTracker = True Then
    If Not m_AllVars Is Nothing Then m_AllVars.Add da
  End If
End Function

Public Function XLScriptAddSimpleVar(n As String, v) As XLScriptSimpleVar
  Dim da As XLScriptSimpleVar
  
  If ObjectNameExists(m_SimpleVars, n) Then
    m_SimpleVars.Remove n
  End If
  
  Set da = New XLScriptSimpleVar
  da.m_Txt = n
  da.m_Value = CStr(v)
  m_SimpleVars.Add da, CStr(n)
  Set XLScriptAddSimpleVar = da

  If XLSCript_Debug = True Or StartedByTracker = True Then
    If Not m_AllVars Is Nothing Then m_AllVars.Add da
  End If
End Function

Public Function XLScriptGetSimpleVar(n As String) As XLScriptSimpleVar
  Set XLScriptGetSimpleVar = Nothing
  On Error Resume Next
  Set XLScriptGetSimpleVar = m_SimpleVars(n)
End Function

' Public Sub XLScriptSetValues(c As Collection, ByRef rng As Range)
'   Dim item
'   For Each item In c
'     SetValue rng, item.m_Txt, CStr(item.m_Value)
'   Next item
' End Sub

' Private Sub SetValue(ByRef rng As Range, varTag As String, cellVal As String)
'   On Error GoTo 0
'   Dim c
'   Do
'     Set c = rng.Find(What:="<<" & varTag & ">>", LookIn:=xlValues, LookAt:= _
'           xlPart, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=True)
'     If Not c Is Nothing Then
'       c.Value = MyReplace(c.Value, "<<" & varTag & ">>", cellVal)
'     End If
'   Loop While Not c Is Nothing
'   Do
'     Set c = rng.Find(What:="__" & varTag & "__", LookIn:=xlFormulas, LookAt:= _
'           xlPart, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=True)
'     If Not c Is Nothing Then
'       c.Formula = MyReplace(c.Formula, "__" & varTag & "__", cellVal)
'     End If
'   Loop While Not c Is Nothing
' End Sub

Private Function MyReplace(txt As String, searchtxt As String, replacetxt As String, Optional checkStartAndEnd As Boolean = False, Optional ignoreIn As String = "") As String
  Dim txtPos As Long
  Dim tStringRep As String
  Dim res As String
  Dim ok As Boolean
  MyReplace = txt
  If InStr(txt, searchtxt) = 0 Then Exit Function
  Dim inIgnore As Boolean
  
  inIgnore = False
  
  For txtPos = 1 To Len(txt)
    If Len(ignoreIn) > 0 Then
      If Mid(txt, txtPos, Len(ignoreIn)) = ignoreIn Then
        If Not inIgnore Then
          inIgnore = True
        Else
          inIgnore = False
        End If
      End If
    End If
    
    If Not inIgnore Then
      If Mid(txt, txtPos, Len(searchtxt)) = searchtxt Then
        ok = True
        Dim tval As String
        If checkStartAndEnd Then
          If txtPos > 1 Then
            tval = Mid(txt, txtPos - 1, 1)
            If (tval >= "a" And tval <= "z") Or _
               (tval >= "A" And tval <= "Z") Or _
               (tval >= "0" And tval <= "9") Or _
               tval = "_" Then
                ok = False
            End If
          End If
          If txtPos + Len(searchtxt) <= Len(txt) Then
            tval = Mid(txt, txtPos + Len(searchtxt), 1)
            If (tval >= "a" And tval <= "z") Or _
               (tval >= "A" And tval <= "Z") Or _
               (tval >= "0" And tval <= "9") Or _
               tval = "_" Then
                ok = False
            End If
          End If
        End If
        If ok Then
          res = res + replacetxt
          txtPos = txtPos + Len(searchtxt) - 1
        Else
          res = res + Mid(txt, txtPos, 1)
        End If
      Else
        res = res + Mid(txt, txtPos, 1)
      End If
    Else
      res = res + Mid(txt, txtPos, 1)
    End If
  Next txtPos
  MyReplace = res
End Function

Sub XLScriptCleanUpTags(rng As Range)
'  On Error GoTo 0
  
  Dim c As Range
  Do
    Set c = rng.Find(What:="<!? INSERTLINEABOVE", LookIn:=xlValues, LookAt:= _
      xlPart, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=False)
    If c Is Nothing Then Exit Do
    c.Parent.Rows(c.Row).Delete Shift:=xlUp
  Loop
  
  Do
    Set c = rng.Find(What:="<!? PB", LookIn:=xlValues, LookAt:= _
      xlPart, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=False)
    If c Is Nothing Then Exit Do
    c.Delete Shift:=xlUp
  Loop
End Sub


Function XLScriptExecCode(rng As Range, reclevel As Long, rightoffset As Long) As Long
  Dim addedLines As Long
  addedLines = 0
  
  On Error GoTo 0
  Dim c As Range
  Dim tstring As String
  Dim tleft As String
  Dim tRight As String
  Set c = Nothing
  
  Dim firstC As Range
  Set firstC = Nothing
  Dim nextC As Range
  
  Do
    
'    Cells.Find(What:=m_CodeStart, After:=ActiveCell, LookIn:=xlValues, LookAt:= _
'        xlPart, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=True, _
'        SearchFormat:=False).Activate
    
    If GetRangeCount(rng) = 1 Then
      If InStr(rng.value, m_CodeStart) > 0 Then
        Set c = rng
      Else
        Set c = Nothing
      End If
    Else
      
      ' Erste gefundene Zelle abfragen
      If Not c Is Nothing And IsValid(c) And Not firstC Is Nothing And IsValid(firstC) = True Then
        If firstC.Row = c.Row And firstC.Column = c.Column Then
          Set c = Nothing
        End If
      ElseIf c Is Nothing Or Not IsValid(c) Then
        Set c = rng.Find(What:=m_CodeStart, LookIn:=xlValues, LookAt:= _
              xlPart, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=True)
        ' Erste gefundene Zelle speichern
        If Not c Is Nothing And firstC Is Nothing Then
          Set firstC = c
        End If
      Else
        Exit Do
      End If
    End If
    
    If Not c Is Nothing And IsValid(c) Then
    
      Set nextC = rng.FindNext(c)
        
      Dim pos As Long
      Dim pos2 As Long
      pos = 0
      ' ---------------------------------------------------
      
      Do
        
        If c Is Nothing Then Exit Do
        If Not IsValid(c) Then Exit Do
        
        pos = InStr(pos + 1, c.value, m_CodeStart)
        If pos = 0 Then Exit Do
        
        pos2 = InStr(pos, c.value, "!>")
        
        Dim codeVal As String
        Dim code As String
        If pos2 > 0 Then
          code = Mid(c.value, pos + Len(m_CodeStart), pos2 - pos - Len(m_CodeStart))
        Else
          code = Mid(c.value, pos + Len(m_CodeStart))
        End If
        
        codeVal = code
        
        Dim newcellval As String
        newcellval = ""
        
        Dim dontdeleteentry As Boolean
        dontdeleteentry = False
        
        Do
          Dim tok As String
          tok = GetToken(codeVal)
          If Len(tok) > 0 Then
            Select Case UCase(tok)
              Case "ADDRIGHT"
                tstring = GetExpression(codeVal, c)
                c.Parent.Cells(c.Row, c.Column + 1).value = _
                  c.Parent.Cells(c.Row, c.Column + 1).value + _
                  Val(MyReplace(tstring, ",", "."))
                  
              Case "INSERTLINEABOVE"
                If firstC.Row = c.Row Then
                  Set firstC = c.Parent.Cells(c.Row + 1, c.Column)
                End If
                m_WS.Rows(c.Row).Insert
                c.value = ""
                Set c = c.Parent.Cells(c.Row + 1, c.Column)
                dontdeleteentry = True
              Case "BACKCOL"
                tstring = GetExpression(codeVal, c)
                
                If IsNumeric(tstring) Then
                  c.Interior.Color = Val(tstring)
                End If
                
              Case "P"
                newcellval = DoPrint(codeVal, c, rightoffset)
              
              Case "PB"
                DoPrintBelow codeVal, c, rightoffset
                dontdeleteentry = True
              
              Case "PRINTBITFIELD"
                DoPrintBitfield codeVal, c
                dontdeleteentry = True
              
              Case "FOR"
                addedLines = addedLines + DoFor(codeVal, c, rng, reclevel + 1)
                If Beenden Then Exit Function
              
              Case "LFOR"
                addedLines = addedLines + DoLFor(codeVal, c, rng, reclevel + 1)
                If Beenden Then Exit Function
              
              Case "ROWAUTOFIT"
                c.Parent.Cells.EntireRow.AutoFit
              
              Case "COLUMNAUTOFIT"
                c.Parent.Cells.EntireColumn.AutoFit
              
              Case "DEBUG"
                Err.Raise vbObjectError + 1, "XLScript", "DEBUG forced by XLScript"
                Debug.Print "Debug forced"
              
              Case "DIAGDATA"
                addedLines = addedLines - 2
                DoDiagData codeVal, c, rng
                
              Case "PRINTTABELLEN"
                PrintTabellen m_WS, c.Row, c.Column
                dontdeleteentry = True
              
              Case Else
                'XLScriptAddLogEntry "Error: Unknown command '" & tok & "' in '" & code & "'! " & m_WS.name & "!" & c.Address & " Value: " & c.value
                XLScriptAddLogEntry FMT5("XLSCRIPT_4", tok, code, m_WS.name, c.Address, c.value)
                'MsgBox "Error: Unknown command '" & tok & "' in '" & code & "'! " & m_WS.name & "!" & c.Address & " Value: " & c.value, vbCritical, "XLScript"
                MsgBox FMT5("XLSCRIPT_4", tok, code, m_WS.name, c.Address, c.value), vbCritical, "XLScript"
                Beenden = True
                Exit Function
            
            End Select
          End If
        Loop While tok <> ""
        
        ' Und jetzt den neuen Zellwert in die Zelle schreiben
        Dim l As String
        Dim r As String
        
        l = ""
        If pos > 1 Then
          l = Left(c.value, pos - 1)
        End If
        
        r = ""
        If pos2 > 0 Then
          If pos + 2 < Len(c.value) Then
            r = Mid(c.value, pos2 + 2)
          End If
        End If
        
        If dontdeleteentry = False Then
          If Not c Is Nothing Then
            If IsValid(c) Then
          
              If IsNumeric(MyReplace(l & newcellval & r, ",", ".")) Then
                c.value = Val(MyReplace(l & newcellval & r, ",", "."))
              ElseIf IsDate(l & newcellval & r) Then
                c.value = CDate(l & newcellval & r)
              Else
                c.value = l & newcellval & r
              End If
              pos = Len(l & newcellval) - 1
              If pos < 0 Then pos = 0
            End If
          End If
        End If
      Loop
      
    End If
  
    If Not GetRangeCount(rng) = 1 And Not c Is Nothing Then
      Set c = nextC
    End If
  
  Loop While Not c Is Nothing
  
  XLScriptExecCode = addedLines
End Function

Private Sub OverreadLine(ByRef codeValRet As String)
  On Error GoTo 0
  Dim i As Long
  i = 1
  Do While i < Len(codeValRet) And Mid(codeValRet, i, 1) <> vbCr And Mid(codeValRet, i, 1) <> vbLf
    i = i + 1
  Loop
  Do While i < Len(codeValRet) And (Mid(codeValRet, i, 1) = vbCr Or Mid(codeValRet, i, 1) = vbLf)
    i = i + 1
  Loop
  If i > 1 Then
    codeValRet = Mid(codeValRet, i)
  End If
End Sub

Private Sub OverreadBlanks(ByRef codeValRet As String)
  On Error GoTo 0
  Dim i As Long
  i = 1
  Do While Mid(codeValRet, i, 1) = " " Or Mid(codeValRet, i, 1) = vbCr Or Mid(codeValRet, i, 1) = vbLf
    i = i + 1
  Loop
  If i > 1 Then
    codeValRet = Mid(codeValRet, i)
  End If
End Sub

Private Sub GetComma(ByRef codeValRet As String, ByRef c As Range)
  On Error GoTo 0
  OverreadBlanks codeValRet
  If Left(codeValRet, 1) <> "," Then
    'XLScriptAddLogEntry "Error: Missing comma! " & m_WS.name & "!" & c.Address & " Value: " & c.value
    XLScriptAddLogEntry FMT3("XLSCRIPT_5", m_WS.name, c.Address, c.value)
  End If
  codeValRet = Mid(codeValRet, 2)
End Sub

Private Function GetDef(ByRef codeValRet As String, ByRef c As Range) As XLFld
  On Error GoTo 0
  OverreadBlanks codeValRet
  
  Dim tok As String
  tok = GetToken(codeValRet)
  
  Dim item As XLFld
  If m_Flds.count > 0 Then
    For Each item In m_Flds
      If item.m_Name = tok Then
        Set GetDef = item
        Exit Function
      End If
    Next item
  End If
  
  'XLScriptAddLogEntry "Error: Undefined Def '" & tok & "'! " & m_WS.name & "!" & c.Address & " Value: " & c.value
  XLScriptAddLogEntry FMT4("XLSCRIPT_6", tok, m_WS.name, c.Address, c.value)
End Function

Private Function GetNumber(ByRef codeValRet As String) As String
  On Error GoTo 0
  Dim token As String
  Dim i As Long
  i = 0
  OverreadBlanks codeValRet
  
  Do While ((Mid(codeValRet, i + 1, 1) >= "0" And Mid(codeValRet, i + 1, 1) <= "9") Or _
    (Mid(codeValRet, i + 1, 1) = ".")) And i < Len(codeValRet)
    i = i + 1
  Loop
  If i > 0 Then
    token = Left(codeValRet, i)
    codeValRet = Mid(codeValRet, i + 1)
    OverreadBlanks codeValRet
  End If
  
  GetNumber = token
End Function

Private Function GetLine(ByRef codeValRet As String) As String
  On Error GoTo 0
  OverreadBlanks codeValRet
  Dim i As Long
  i = 0
  Do While i < Len(codeValRet) - 1 And Mid(codeValRet, i + 1, 1) <> vbCr And Mid(codeValRet, i + 1, 1) <> vbLf
    i = i + 1
  Loop
  If i > 0 Then
    GetLine = Left(codeValRet, i)
    codeValRet = Mid(codeValRet, i + 1)
  End If
End Function

Private Function GetNextChar(ByRef codeValRet As String) As String
  On Error GoTo 0
  OverreadBlanks codeValRet
  If Len(codeValRet) > 0 Then
    GetNextChar = Left(codeValRet, 1)
    codeValRet = Mid(codeValRet, 2)
  End If
End Function

Function GetString(ByRef codeValRet As String) As String
  On Error GoTo 0
  Dim token As String
  Dim i As Long
  i = 0
  OverreadBlanks codeValRet
  If Left(codeValRet, 1) = Chr(34) Then
    codeValRet = Mid(codeValRet, 2)
    Do While Mid(codeValRet, i + 1, 1) <> Chr(34) And i < Len(codeValRet)
      i = i + 1
    Loop
    If i > 0 Then
      token = Left(codeValRet, i)
      codeValRet = Mid(codeValRet, i + 1)
      If Left(codeValRet, 1) = Chr(34) Then
        codeValRet = Mid(codeValRet, 2)
      End If
      OverreadBlanks codeValRet
    End If
  End If
  
  GetString = token
End Function


Private Function GetToken(ByRef codeValRet As String) As String
  On Error GoTo 0
  Dim token As String
  Dim i As Long
  i = 0
  OverreadBlanks codeValRet
  If Left(codeValRet, 1) = Chr(34) Then
    codeValRet = Mid(codeValRet, 2)
    Do While Mid(codeValRet, i + 1, 1) <> Chr(34) And i < Len(codeValRet)
      i = i + 1
    Loop
    If i > 0 Then
      token = Left(codeValRet, i)
      codeValRet = Mid(codeValRet, i + 1)
      If Left(codeValRet, 1) = Chr(34) Then
        codeValRet = Mid(codeValRet, 2)
      End If
      OverreadBlanks codeValRet
    End If
  Else
    If ((Mid(codeValRet, i + 1, 1) >= "a" And Mid(codeValRet, i + 1, 1) <= "z") Or _
      (Mid(codeValRet, i + 1, 1) >= "A" And Mid(codeValRet, i + 1, 1) <= "Z")) And i < Len(codeValRet) Then
      Do While ((Mid(codeValRet, i + 1, 1) >= "a" And Mid(codeValRet, i + 1, 1) <= "z") Or _
        (Mid(codeValRet, i + 1, 1) >= "A" And Mid(codeValRet, i + 1, 1) <= "Z") Or _
        (Mid(codeValRet, i + 1, 1) >= "0" And Mid(codeValRet, i + 1, 1) <= "9") Or _
         Mid(codeValRet, i + 1, 1) = "_" Or _
         Mid(codeValRet, i + 1, 1) = "|fffd|" Or _
         Mid(codeValRet, i + 1, 1) = "|fffd|" Or _
         Mid(codeValRet, i + 1, 1) = "|fffd|" Or _
         Mid(codeValRet, i + 1, 1) = "|fffd|" Or _
         Mid(codeValRet, i + 1, 1) = "|fffd|" Or _
         Mid(codeValRet, i + 1, 1) = "|fffd|" Or _
         Mid(codeValRet, i + 1, 1) = "|fffd|" _
         ) And i < Len(codeValRet)
        i = i + 1
      Loop
      If i > 0 Then
        token = Left(codeValRet, i)
        codeValRet = Mid(codeValRet, i + 1)
        OverreadBlanks codeValRet
      End If
    Else
      token = GetNextChar(codeValRet)
    End If
  End If
  
  GetToken = token
End Function

Private Function DoPrint(ByRef codeValRet As String, ByRef c As Range, Optional rightoffset As Long = 0) As String
  On Error GoTo 0
  Dim res As String
  m_InPrint = True
  
  CheckSubParams codeValRet, c
  
  res = GetExpression(codeValRet, c)
  m_InPrint = False
  If res = "" Then
    DoPrint = "'-/-"
'    c.Parent.Cells(c.Row, c.Column + rightoffset).Value = "'-/-"
'    XLScriptAddLogEntry "Error: PRINT missing expression! " & m_WS.name & "!" & c.Address & " Value: " & c.Value
    Exit Function
  End If
  
  DoPrint = res
'  c.Parent.Cells(c.Row, c.Column + rightoffset).Value = res
End Function

Private Sub DoPrintBelow(ByRef codeValRet As String, ByRef c As Range, Optional rightoffset As Long = 0)
  On Error GoTo 0
  Dim res As String
  
  Dim y As Long
  y = c.Row + 1
  Do While Not IsEmpty(m_WS.Cells(y, c.Column))
    y = y + 50
  Loop
  
  If y > 1 Then
    Do While IsEmpty(m_WS.Cells(y, c.Column))
      y = y - 1
    Loop
    y = y + 1
  End If
  
'  Debug.Print codeValRet
  CheckSubParams codeValRet, m_WS.Cells(y, c.Column)
  
  res = GetExpression(codeValRet, c)
  
  If res = "" Then
    m_WS.Cells(y, c.Column).value = "'-/-"
    Exit Sub
  End If
  
  If IsFullyNumeric(MyReplace(res, ",", ".")) Then
    m_WS.Cells(y, c.Column).value = Val(MyReplace(res, ",", "."))
  Else
    m_WS.Cells(y, c.Column).value = res
  End If
'  m_WS.Cells(y, c.Column).NumberFormat = c.NumberFormat
'  m_WS.Cells(y, c.Column).Interior.Color = c.Interior.Color
'  m_WS.Cells(y, c.Column).Font.Color = c.Font.Color
End Sub

Sub CheckSubParams(ByRef codeValRet As String, ByRef c As Range)
  Dim s As String
  If Left(codeValRet, 1) <> "(" Then Exit Sub
  codeValRet = Mid(codeValRet, 2)
  s = GetToken(codeValRet)
  Select Case s
    Case "BC"
      If Left(codeValRet, 1) <> ":" Then
        'XLScriptAddLogEntry "BC must be followed by ':' in " & m_WS.name & "!" & c.Address & " Value: " & c.value
        XLScriptAddLogEntry FMT3("XLSCRIPT_7", m_WS.name, c.Address, c.value)
        Exit Sub
      End If
      codeValRet = Mid(codeValRet, 2)
      s = GetExpression(codeValRet, c)
      If IsNumeric(s) Then
        c.Interior.Color = Val(s)
      Else
        c.Interior.Color = RGB(255, 255, 255)
      End If
      If Left(codeValRet, 1) <> ")" Then
        'XLScriptAddLogEntry "Sub param must be followed by ')' or ';' in " & m_WS.name & "!" & c.Address & " Value: " & c.value
        XLScriptAddLogEntry FMT3("XLSCRIPT_8", m_WS.name, c.Address, c.value)
        Exit Sub
      End If
      codeValRet = Mid(codeValRet, 2)
      OverreadBlanks codeValRet
  End Select
End Sub


Public Sub DoPrintBitfield(ByRef codeValRet As String, ByRef c As Range)
  On Error GoTo 0
  Dim res As String
  Dim tCodeValRet As String
  tCodeValRet = codeValRet
  res = GetExpression(codeValRet, c)
  
  If res = "" Then
    'XLScriptAddLogEntry "Error: Expression not found (" & tCodeValRet & ")! " & m_WS.name & "!" & c.Address & " Value: " & c.value
    XLScriptAddLogEntry FMT4("XLSCRIPT_9", tCodeValRet, m_WS.name, c.Address, c.value)
  End If
  GetComma codeValRet, c
  
  Dim F As XLFld
  Set F = GetDef(codeValRet, c)
  GetComma codeValRet, c
  
  Dim sep As String
  sep = GetExpression(codeValRet, c)
  
  Dim onlyExistant As Boolean
  onlyExistant = True
  
  Dim foundone As Boolean
  foundone = False
  c.value = ""
  Dim item As XLFldVal
  
  Dim cnt As Long
  Dim x As Long
  Dim rv As String
  Dim first As Boolean
  first = False
  x = &H80000000
  
  If Not onlyExistant Then
    c.value = "0x" & Hex(CLng(res)) & " (" & res & ")"
  End If
  
  Dim i As Long
  
  For cnt = 1 To 32
    If (res And x) <> 0 Then
    
      foundone = False
      For Each item In F.m_Col
        If x = item.m_Value Then
          foundone = True
          If Len(c.value) > 0 Then
            For i = 1 To Len(sep)
              If Mid(sep, i, 1) = "n" Then
                c.value = c.value & vbLf
              Else
                c.value = c.value & Mid(sep, i, 1)
              End If
            Next i
          End If
          
          If onlyExistant Then
            c.value = c.value & item.m_Txt
          Else
            c.value = c.value & "0x" & Hex(item.m_Value) & " - " & item.m_Txt
          End If
          
        End If
      Next item
      
      If Not onlyExistant Then
        If Not foundone Then
          If Len(c.value) > 0 Then
            For i = 1 To Len(sep)
              If Mid(sep, i, 1) = "n" Then
                c.value = c.value & vbLf
              Else
                c.value = c.value & Mid(sep, i, 1)
              End If
            Next i
          End If
          
          c.value = c.value & "0x" & Hex(x) & " - ???"
        End If
      End If
    End If
    x = x / 2
    If x < 0 Then x = x * (-1)
  Next cnt
  If Len(c.value) = 0 Then
   c.value = "'-"
  End If
'  If Not foundOne Then c.Value = res
End Sub

Public Sub DoPrintBitfieldExt(att As String, bitfieldname As String, sep As String, ByRef c As Range)
  On Error GoTo 0
  Dim res As String
  res = att
  
  Dim F As XLFld
  Set F = GetDef(bitfieldname, c)
  
  Dim onlyExistant As Boolean
  onlyExistant = True
  
  Dim foundone As Boolean
  foundone = False
  c.value = ""
  Dim item As XLFldVal
  
  Dim cnt As Long
  Dim x As Long
  Dim rv As String
  Dim first As Boolean
  first = False
  x = &H80000000
  
  If Not onlyExistant Then
    c.value = "0x" & Hex(CLng(res)) & " (" & res & ")"
  End If
  
  Dim i As Long
  
  For cnt = 1 To 32
    If (res And x) <> 0 Then
    
      foundone = False
      For Each item In F.m_Col
        If x = item.m_Value Then
          foundone = True
          If Len(c.value) > 0 Then
            For i = 1 To Len(sep)
              If Mid(sep, i, 1) = "n" Then
                c.value = c.value & vbLf
              Else
                c.value = c.value & Mid(sep, i, 1)
              End If
            Next i
          End If
          
          If onlyExistant Then
            c.value = c.value & item.m_Txt
          Else
            c.value = c.value & "0x" & Hex(item.m_Value) & " - " & item.m_Txt
          End If
          
        End If
      Next item
      
      If Not onlyExistant Then
        If Not foundone Then
          If Len(c.value) > 0 Then
            For i = 1 To Len(sep)
              If Mid(sep, i, 1) = "n" Then
                c.value = c.value & vbLf
              Else
                c.value = c.value & Mid(sep, i, 1)
              End If
            Next i
          End If
          
          c.value = c.value & "0x" & Hex(x) & " - ???"
        End If
      End If
    End If
    x = x / 2
    If x < 0 Then x = x * (-1)
  Next cnt
  If Len(c.value) = 0 Then
   c.value = "'-"
  End If
'  If Not foundOne Then c.Value = res
End Sub


Private Function ValToBin(v As Long) As String
  Dim i As Long
  Dim x As Long
  Dim rv As String
  Dim first As Boolean
  first = True
  x = &H80000000
  rv = "b"
  For i = 1 To 32
    If (v And x) <> 0 Then
      first = False
      rv = rv & "1"
    Else
      If Not first Then
        rv = rv & "0"
      End If
    End If
    x = x / 2
    If x < 0 Then x = x * (-1)
  Next i
  If first Then
    rv = "b0"
  End If
  ValToBin = rv
End Function

Private Function DoFor(ByRef codeValRet As String, ByRef c As Range, rng As Range, reclevel As Long) As Long
  
  DoFor = 0
  On Error GoTo 0
  Dim tok As String
  tok = GetToken(codeValRet)
  
'  If c.Value = "<! FOR EACH item IN FuncAm" Then
'    Debug.Print "gaga"
'  End If
  

'  If c.Value = "<! FOR EACH subitem IN item.items WIDTH 4" Then
'    Debug.Print "gaga"
'  End If
  
  If UCase(tok) <> "EACH" Then
    'XLScriptAddLogEntry "Error: EACH expected! " & m_WS.name & "!" & c.Address & " Value: " & c.value
    XLScriptAddLogEntry FMT3("XLSCRIPT_10", m_WS.name, c.Address, c.value)
    Exit Function
  End If
  
  Dim res As String
  res = GetVarName(codeValRet, c)
  If res = "" Then
    c.value = "'-/-"
'    XLScriptAddLogEntry "Error: PRINT missing expression! " & m_WS.name & "!" & c.Address & " Value: " & c.Value
    Exit Function
  End If
  
  tok = GetToken(codeValRet)
  If UCase(tok) <> "IN" Then
    'XLScriptAddLogEntry "Error: IN expected! " & m_WS.name & "!" & c.Address & " Value: " & c.value
    XLScriptAddLogEntry FMT3("XLSCRIPT_11", m_WS.name, c.Address, c.value)
    Exit Function
  End If
  
  Dim ref
  m_InPrint = True
  Set ref = GetRef(codeValRet, c)
  m_InPrint = False
  
  Dim widthAm As Long
  widthAm = 1
  tok = GetToken(codeValRet)
  If UCase(tok) = "WIDTH" Then
    tok = GetNumber(codeValRet)
    If Not IsNumeric(tok) Then
      'XLScriptAddLogEntry "Error: WIDTH must be followed by numeric value! " & m_WS.name & "!" & c.Address & " Value: " & c.value
      XLScriptAddLogEntry FMT3("XLSCRIPT_12", m_WS.name, c.Address, c.value)
    Else
      widthAm = CLng(tok)
    End If
  End If
  
  
  ' OK, jetzt das Ende des FOR Befehls suchen
  Dim cEnd As Range
  Set cEnd = rng.Find(What:=m_CodeStart & "NEXT " & res, LookIn:=xlValues, LookAt:= _
        xlWhole, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=False)
  
  If cEnd Is Nothing Then
    'XLScriptAddLogEntry "Error: FOR EACH missing NEXT! " & m_WS.name & "!" & c.Address & " Value: " & c.value
    XLScriptAddLogEntry FMT3("XLSCRIPT_13", m_WS.name, c.Address, c.value)
  End If
  
  Dim forwidth As Long
  forwidth = cEnd.Column - c.Column + 1
  Dim forheight As Long
  forheight = cEnd.Row - c.Row + 1 - 2
  If CountReadable(ref) Then
  
    Dim fn As XLForNext
    Set fn = New XLForNext
    fn.m_Name = res
    Set fn.m_Ref = ref
    fn.m_Current = 1
    fn.m_Width = widthAm
    fn.m_WidthCurrent = 0
    m_FN.Add fn
    
    ' Ok, kopieren, dann exec
    
    Dim cnt As Long
    
    Dim addedLines As Long
    addedLines = 0
    Dim maxAddLines As Long
    maxAddLines = -10000
    
    If reclevel = 1 Then MyLastTime = Now
    
    If ref.count > 0 Then
      For cnt = 1 To ref.count
      
        fn.m_Current = cnt - 1 + GetCollectionStart(fn.m_Ref)
        
        If reclevel = 1 Then
          If MyLastTime + TimeValue("0:00:02") < Now Then
            'UpdateStatus "Generiere Ergebnisbatt " & m_WS.name & " - " & cnt & " / " & ref.count
            UpdateStatus FMT3("XLSCRIPT_14", m_WS.name, cnt, ref.count)
            MyLastTime = Now
          End If
          If Beenden Then Exit Function
        End If
        
        If fn.m_WidthCurrent = 0 Then
          m_WS.Range(m_WS.Cells(cEnd.Row + 1 + addedLines, c.Column), _
                m_WS.Cells(cEnd.Row + 1 + addedLines + forheight - 1, c.Column + forwidth * widthAm - 1)).Insert Shift:=xlDown
          maxAddLines = -10000
        End If
        
        m_WS.Range(m_WS.Cells(c.Row + 1, c.Column), m_WS.Cells(cEnd.Row - 1, cEnd.Column)).Copy
        m_WS.Cells(cEnd.Row + 1 + addedLines, c.Column + fn.m_WidthCurrent * forwidth).PasteSpecial xlPasteAll
        
        Dim newlines As Long
        newlines = XLScriptExecCode(m_WS.Range(m_WS.Cells(cEnd.Row + 1 + addedLines, c.Column + fn.m_WidthCurrent * forwidth), m_WS.Cells(cEnd.Row + 1 + addedLines + cEnd.Row - c.Row - 2, cEnd.Column + fn.m_WidthCurrent * forwidth)), reclevel + 1, fn.m_WidthCurrent)
        If newlines > maxAddLines Then
          maxAddLines = newlines
        End If
        
        fn.m_WidthCurrent = fn.m_WidthCurrent + 1
        
        If fn.m_WidthCurrent = fn.m_Width Then
          addedLines = addedLines + maxAddLines
          addedLines = addedLines + cEnd.Row - c.Row - 1
          fn.m_WidthCurrent = 0
        End If
      Next cnt
      If reclevel = 1 Then
        'UpdateStatus "Generiere Ergebnisbatt " & m_WS.name & " - " & cnt - 1 & " / " & ref.count
        UpdateStatus FMT3("XLSCRIPT_14", m_WS.name, cnt - 1, ref.count)
        MyLastTime = Now
      End If
    
      If fn.m_WidthCurrent > 0 Then
        addedLines = addedLines + maxAddLines
        addedLines = addedLines + cEnd.Row - c.Row - 1
      End If
    Else
    
      m_WS.Range(m_WS.Cells(cEnd.Row + 1, c.Column), _
            m_WS.Cells(cEnd.Row + 1 + forheight - 1, c.Column + forwidth * widthAm - 1)).Insert Shift:=xlDown
      m_WS.Cells(cEnd.Row + 1, c.Column) = "'-/-"
      addedLines = 1
    End If
    
    cnt = 1
    Dim item As XLForNext
    For Each item In m_FN
      If item.m_Name = fn.m_Name Then
        m_FN.Remove cnt
        Exit For
      End If
      cnt = cnt + 1
    Next item
  
  Else
  
    m_WS.Range(m_WS.Cells(cEnd.Row + 1, c.Column), _
          m_WS.Cells(cEnd.Row + 1 + forheight - 1, c.Column + forwidth * widthAm - 1)).Insert Shift:=xlDown
    m_WS.Cells(cEnd.Row + 1, c.Column) = "'-/-"
    addedLines = 1
  End If
  
  addedLines = addedLines - (cEnd.Row - c.Row + 1)
  m_WS.Range(m_WS.Cells(c.Row, c.Column), m_WS.Cells(cEnd.Row, c.Column + forwidth * widthAm - 1)).Delete Shift:=xlUp
  
  
  DoFor = addedLines
End Function

Private Function DoLFor(ByRef codeValRet As String, ByRef c As Range, rng As Range, reclevel As Long) As Long
  
  DoLFor = 0
  On Error GoTo 0
  Dim tok As String
  tok = GetToken(codeValRet)
  
'  If c.Value = "<! FOR EACH item IN FuncAm" Then
'    Debug.Print "gaga"
'  End If
  

'  If c.Value = "<! FOR EACH subitem IN item.items WIDTH 4" Then
'    Debug.Print "gaga"
'  End If
  
  If UCase(tok) <> "EACH" Then
    'XLScriptAddLogEntry "Error: EACH expected! " & m_WS.name & "!" & c.Address & " Value: " & c.value
    XLScriptAddLogEntry FMT3("XLSCRIPT_10", m_WS.name, c.Address, c.value)
    Exit Function
  End If
  
  Dim res As String
  res = GetVarName(codeValRet, c)
  If res = "" Then
    c.value = "'-/-"
'    XLScriptAddLogEntry "Error: PRINT missing expression! " & m_WS.name & "!" & c.Address & " Value: " & c.Value
    Exit Function
  End If
  
  tok = GetToken(codeValRet)
  If UCase(tok) <> "IN" Then
    'XLScriptAddLogEntry "Error: IN expected! " & m_WS.name & "!" & c.Address & " Value: " & c.value
    XLScriptAddLogEntry FMT3("XLSCRIPT_11", m_WS.name, c.Address, c.value)
    Exit Function
  End If
  
  Dim ref
  m_InPrint = True
  Set ref = GetRef(codeValRet, c)
  m_InPrint = False
  
  Dim widthAm As Long
  widthAm = 1
  tok = GetToken(codeValRet)
  If UCase(tok) = "WIDTH" Then
    tok = GetNumber(codeValRet)
    If Not IsNumeric(tok) Then
      'XLScriptAddLogEntry "Error: WIDTH must be followed by numeric value! " & m_WS.name & "!" & c.Address & " Value: " & c.value
      XLScriptAddLogEntry FMT3("XLSCRIPT_12", m_WS.name, c.Address, c.value)
    Else
      widthAm = CLng(tok)
    End If
  End If
  
  
  ' OK, jetzt das Ende des FOR Befehls suchen
  Dim cEnd As Range
  Set cEnd = rng.Find(What:=m_CodeStart & "LNEXT " & res, LookIn:=xlValues, LookAt:= _
        xlWhole, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=False)
  
  If cEnd Is Nothing Then
    'XLScriptAddLogEntry "Error: FOR EACH missing NEXT! " & m_WS.name & "!" & c.Address & " Value: " & c.value
    XLScriptAddLogEntry FMT3("XLSCRIPT_13", m_WS.name, c.Address, c.value)
  End If
  
  Dim forwidth As Long
  forwidth = cEnd.Column - c.Column + 1
  Dim forheight As Long
  forheight = cEnd.Row - c.Row + 1 - 2
  
  
  If CountReadable(ref) Then
  
    Dim fn As XLForNext
    Set fn = New XLForNext
    fn.m_Name = res
    Set fn.m_Ref = ref
    fn.m_Current = 1
    fn.m_Width = widthAm
    fn.m_WidthCurrent = 0
    m_FN.Add fn
    
    ' Ok, kopieren, dann exec
    
    Dim cnt As Long
    
    Dim addedLines As Long
    addedLines = 0
    Dim maxAddLines As Long
    maxAddLines = -10000
    
    If reclevel = 1 Then MyLastTime = Now
    
    
    If ref.count > 0 Then
    
      Dim lforlines As Long
      lforlines = CLng(ref.count / widthAm) + IIf(ref.count Mod widthAm = 0, 0, 1)
      
      m_WS.Range(m_WS.Cells(cEnd.Row + 1, c.Column), _
            m_WS.Cells(cEnd.Row + 1 + lforlines - 1, c.Column + forwidth * widthAm - 1)).Insert Shift:=xlDown
      m_WS.Range(m_WS.Cells(c.Row + 1, c.Column), m_WS.Cells(cEnd.Row - 1, cEnd.Column)).Copy
      m_WS.Range(m_WS.Cells(cEnd.Row + 1, c.Column), m_WS.Cells(cEnd.Row + 1 + lforlines - 1, c.Column + forwidth * widthAm - 1)).PasteSpecial xlPasteAll
      
      cnt = 1
      Dim lforam As Long
      lforam = lforlines * widthAm
      
      Dim printvals As New Collection
      Dim tC As Range
      Dim xlf As LForItem
      For Each tC In m_WS.Range(m_WS.Cells(c.Row + 1, c.Column), m_WS.Cells(cEnd.Row - 1, cEnd.Column))
        ' F<!1 P item.FNCOUNT
        Dim tpos As Long
        Dim tleft As String
        tpos = InStr(tC.value, m_CodeStart & "P " & res)
        If tpos > 0 Then
          Set xlf = New LForItem
          xlf.m_Prefix = ""
          If tpos > 1 Then
            xlf.m_Prefix = Left(tC.value, tpos - 1)
          End If
          xlf.m_Val = Mid(tC.value, tpos + Len(m_CodeStart & "P " & res & "."))
          xlf.m_X = tC.Column - c.Column
          xlf.m_Y = tC.Row - c.Row - 1
          printvals.Add xlf
          
        End If
      Next tC
      
      
      
      For cnt = 1 To lforam
      
        fn.m_Current = cnt - 1 + GetCollectionStart(fn.m_Ref)
        
        If reclevel = 1 Then
          If MyLastTime + TimeValue("0:00:02") < Now Then
            'UpdateStatus "Generiere Ergebnisblatt " & m_WS.name & " - " & cnt & " / " & ref.count
            UpdateStatus FMT3("XLSCRIPT_14", m_WS.name, cnt, ref.count)
            MyLastTime = Now
          End If
          If Beenden Then Exit Function
        End If
        
        Dim newlines As Long
        
        maxAddLines = 0
        If cnt > ref.count Then
          For Each xlf In printvals
            m_WS.Cells(cEnd.Row + 1 + addedLines + xlf.m_Y, c.Column + fn.m_WidthCurrent * forwidth + xlf.m_X).value = ""
          Next xlf
        Else
'          newlines = XLScriptExecCode(m_WS.Range(m_WS.Cells(cEnd.Row + 1 + addedLines, c.Column + fn.m_WidthCurrent * forwidth), m_WS.Cells(cEnd.Row + 1 + addedLines + cEnd.Row - c.Row - 2, cEnd.Column + fn.m_WidthCurrent * forwidth)), reclevel + 1, fn.m_WidthCurrent)
          For Each xlf In printvals
          
            Dim tstring As String
            tstring = xlf.m_Val
            Set tC = m_WS.Cells(cEnd.Row + 1 + addedLines + xlf.m_Y, c.Column + fn.m_WidthCurrent * forwidth + xlf.m_X)
            If tstring = "" Then
              tC.value = xlf.m_Prefix & ref(cnt)
            ElseIf tstring = "FNCOUNT" Then
              tC.value = xlf.m_Prefix & cnt
            Else
              If VarValueExists(ref(cnt), tstring) Then
                tC.value = xlf.m_Prefix & ref(cnt)(tstring)
              End If
            End If
          Next xlf
        End If
        
        fn.m_WidthCurrent = fn.m_WidthCurrent + 1
        
        If fn.m_WidthCurrent = fn.m_Width Then
          addedLines = addedLines + maxAddLines
          addedLines = addedLines + cEnd.Row - c.Row - 1
          fn.m_WidthCurrent = 0
        End If
      Next cnt
      If reclevel = 1 Then
        'UpdateStatus "Generiere Ergebnisblatt " & m_WS.name & " - " & cnt - 1 & " / " & ref.count
        UpdateStatus FMT3("XLSCRIPT_14", m_WS.name, cnt - 1, ref.count)
        MyLastTime = Now
      End If
      If fn.m_WidthCurrent > 0 Then
        addedLines = addedLines + maxAddLines
        addedLines = addedLines + cEnd.Row - c.Row - 1
      End If
    Else
    
      m_WS.Range(m_WS.Cells(cEnd.Row + 1, c.Column), _
            m_WS.Cells(cEnd.Row + 1 + forheight - 1, c.Column + forwidth * widthAm - 1)).Insert Shift:=xlDown
      m_WS.Cells(cEnd.Row + 1, c.Column) = "'-/-"
      addedLines = 1
    End If
    
    cnt = 1
    Dim item As XLForNext
    For Each item In m_FN
      If item.m_Name = fn.m_Name Then
        m_FN.Remove cnt
        Exit For
      End If
      cnt = cnt + 1
    Next item
  
  Else
  
    m_WS.Range(m_WS.Cells(cEnd.Row + 1, c.Column), _
          m_WS.Cells(cEnd.Row + 1 + forheight - 1, c.Column + forwidth * widthAm - 1)).Insert Shift:=xlDown
    m_WS.Cells(cEnd.Row + 1, c.Column) = "'-/-"
    addedLines = 1
  End If
  
  addedLines = addedLines - (cEnd.Row - c.Row + 1)
  m_WS.Range(m_WS.Cells(c.Row, c.Column), m_WS.Cells(cEnd.Row, c.Column + forwidth * widthAm - 1)).Delete Shift:=xlUp
  
  
  DoLFor = addedLines
End Function


Private Sub DoDiagData(ByRef codeValRet As String, ByRef c As Range, rng As Range)
  
  On Error GoTo 0
  
  Dim endofline As String
  endofline = codeValRet
  Dim tok As String
  tok = GetToken(codeValRet)
  
  ' OK, jetzt das Ende des DIAGDATA Befehls suchen
  Dim cEnd As Range
  Set cEnd = rng.Find(What:=m_CodeStart & "DIAGDATAEND " & endofline, LookIn:=xlValues, LookAt:= _
        xlPart, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=False)
  
  If cEnd Is Nothing Then
    'XLScriptAddLogEntry "Error: DIAGDATA " & tok & " missing DIAGDATAEND " & tok & "! " & m_WS.name & "!" & c.Address & " Value: " & c.value
    XLScriptAddLogEntry FMT5("XLSCRIPT_15", tok, tok, m_WS.name, c.Address, c.value)
    c.EntireRow.Delete
    Exit Sub
  End If
  
  Dim coitem As ChartObject
  Dim cgitem As ChartGroup
  Dim scitem As Series
  If m_WS.ChartObjects.count > 0 Then
    For Each coitem In m_WS.ChartObjects
      If UCase(coitem.name) = UCase(tok) Then
        For Each cgitem In coitem.Chart.ChartGroups
          Set scitem = cgitem.SeriesCollection(1)
'          If IsReadableFormula(scitem) Then
            scitem.Formula = "=SERIES(," & m_WS.name & "!" & m_WS.Cells(c.Row + 1, c.Column).Address & _
              ":" & m_WS.Cells(cEnd.Row - 1, c.Column).Address & _
              "," & m_WS.name & "!" & m_WS.Cells(c.Row + 1, cEnd.Column).Address & ":" & _
              m_WS.Cells(cEnd.Row - 1, cEnd.Column).Address & ",1)"
'          End If
        Next cgitem
      End If
    Next coitem
  End If
  
  cEnd.EntireRow.Delete
  c.EntireRow.Delete
  
End Sub


Private Function GetCollectionStart(c)
  On Error GoTo start1
  If IsObject(c(0)) Then
  End If
  GetCollectionStart = 0
  Exit Function
start1:
  GetCollectionStart = 1
End Function

Private Function GetExpression(ByRef codeValRet As String, c As Range) As String
  Dim pos As Long
  On Error GoTo 0
  OverreadBlanks codeValRet
  ' Summe auf eine Variable eines Arrays bilden
  If UCase(Left(codeValRet, 4)) = "SUM " Then
    codeValRet = Mid(codeValRet, 4)
    Dim ref
    Set ref = GetRef(codeValRet, c)
    If Not ref Is Nothing Then
      GetComma codeValRet, c
      Dim tok As String
      tok = GetToken(codeValRet)
      Dim item
      Dim s As Long
      s = 0
      For Each item In ref
        If PropertyNameExists(item, tok) Then
          s = s + CLng(item.Properties(UCase(tok)))
        Else
          If GetUserName = "norman" Then XLScriptAddLogEntry "Warning: Variable '" & tok & "' not existant! " & m_WS.name & "!" & c.Address & " Value: " & c.value
        End If
      Next item
      GetExpression = s
      Exit Function
    End If
'  ElseIf Left(codeValRet, 1) >= "0" And Left(codeValRet, 1) <= "9" Then
  ElseIf (Left(codeValRet, 1) >= "a" And Left(codeValRet, 1) <= "z") Or (Left(codeValRet, 1) >= "A" And Left(codeValRet, 1) <= "Z") Then
    GetExpression = XLScriptGetVarValue(codeValRet, c)
    Exit Function
  ElseIf (Left(codeValRet, 1) = "*") Then
    pos = InStr(codeValRet, ")")
    If pos > 0 Then
      Dim endstr As String
      endstr = Mid(codeValRet, 2, pos - 2)
      Dim tp As String
      tp = Mid(codeValRet, pos + 1) & endstr
      GetExpression = GetExpression(tp, c)
      codeValRet = Mid(codeValRet, pos)
    End If
    Exit Function
  ElseIf Left(codeValRet, 1) = Chr(34) Then
    pos = InStr(2, codeValRet, Chr(34))
    If pos > 0 Then
      GetExpression = Mid(codeValRet, 2, pos - 2)
      codeValRet = Mid(codeValRet, pos + 1)
      Exit Function
    Else
      'XLScriptAddLogEntry "Error: " & Chr(22) & " missing! " & m_WS.name & "!" & c.Address & " Value: " & c.value
      XLScriptAddLogEntry FMT3("XLSCRIPT_16", m_WS.name, c.Address, c.value)
    End If
  End If
End Function

Private Function GetVarName(ByRef codeValRet As String, ByRef c As Range) As String
  On Error GoTo 0
  Dim tok As String
  Dim res As String
  tok = GetToken(codeValRet)
  If Len(tok) > 0 Then
    If Left(tok, 1) >= "a" Or Left(tok, 1) <= "z" Or Left(tok, 1) >= "A" Or Left(tok, 1) <= "Z" Then
      GetVarName = tok
      Exit Function
    End If
  End If
  'XLScriptAddLogEntry "Error: '" & tok & "' is not a variable name! " & m_WS.name & "!" & c.Address & " Value: " & c.value
  XLScriptAddLogEntry FMT4("XLSCRIPT_17", tok, m_WS.name, c.Address, c.value)
End Function

Function XLScriptGetVarValue(ByRef codeValRet As String, c As Range) As String
  On Error GoTo 0
  Dim tok As String
  Dim res As String
  Dim wasdot As Boolean
  wasdot = False
  
  Dim goitem As XLScriptGlobalObject
  
  tok = GetToken(codeValRet)
  If Len(tok) > 0 Then
  
    If Left(codeValRet, 1) = "." Then
      codeValRet = Mid(codeValRet, 2)
      wasdot = True
    End If
    
    Select Case UCase(tok)
   
#If USE_MDB = True Then
      Case "DB"
        res = XLScriptGetDBVarValue(codeValRet, m_DB, c)
      Case "WS"
        res = XLScriptGetDBVarValue(codeValRet, m_Workspace, c)
      Case "APP"
        res = XLScriptGetDBVarValue(codeValRet, m_App, c)
#End If
      Case "XL"
        res = XLScriptGetDBVarValue(codeValRet, m_Excel, c)
#If USE_XLS = True Then
      Case "XLWB"
        res = XLScriptGetDBVarValue(codeValRet, m_Workbook, c)
#End If
      Case Else
    
        Dim found As Boolean
        found = False
        
        For Each goitem In m_GlobalObjects
          If UCase(goitem.m_Name) = UCase(tok) Then
            res = XLScriptGetDBVarValue(codeValRet, goitem.m_Object, c)
            found = True
            Exit For
          End If
        Next goitem
        
        If Not found Then
          Dim item As XLForNext
          For Each item In m_FN
            If UCase(item.m_Name) = UCase(tok) Then
              res = XLScriptGetDBVarValue(codeValRet, item.m_Ref(item.m_Current), c, item)
'              If m_InPrint = True And XLSCript_Debug = True Then
'                item.m_Ref(item.m_Current).m_WasPrinted = True
'              End If
              found = True
              Exit For
            End If
          Next item
        End If
        
        ' Dann wollen wir doch mal nach "normalen" VariablenArrays schauen, die das Programm ermittelt hat
        If Not found Then
          Dim vaitem2d As XLScriptArray2D
          For Each vaitem2d In m_VarArray2D
            If UCase(vaitem2d.Properties("NAME")) = UCase(tok) Then
              
              res = XLScriptGetDBVarValue(codeValRet, vaitem2d.items, c, vaitem2d)
              
              If m_InPrint = True And XLSCript_Debug = True Then
                vaitem2d.m_WasPrinted = True
              End If
'              If wasdot Then
'                Set res = vaitem2d.items(codeValRet).items
'              End If
              found = True
              Exit For
            End If
          Next vaitem2d
        End If
        
            
        If Not found Then
          Dim svitem As XLScriptSimpleVar
          For Each svitem In m_SimpleVars
            If UCase(svitem.m_Txt) = UCase(tok) Then
              res = svitem.m_Value
              If m_InPrint = True And XLSCript_Debug = True Then
                svitem.m_WasPrinted = True
              End If
              found = True
              Exit For
            End If
          Next svitem
        End If
        
        
        If Not found Then
          Dim vaitem As XLScriptArray
          For Each vaitem In m_VarArray
            If UCase(vaitem.Properties("NAME")) = UCase(tok) Then
              res = XLScriptGetDBVarValue(codeValRet, vaitem.items, c, vaitem)
              If m_InPrint = True And XLSCript_Debug = True Then
                vaitem.m_WasPrinted = True
              End If
              found = True
              Exit For
            End If
          Next vaitem
        End If
        
        
        If Not found Then
          
          If IsValid(c) Then
            'XLScriptAddLogEntry "Error: '" & tok & "' is not a variable name! " & m_WS.name & "!" & c.Address & " Value: " & c.value
            XLScriptAddLogEntry FMT4("XLSCRIPT_17", tok, m_WS.name, c.Address, c.value)
          Else
            'XLScriptAddLogEntry "Error: '" & tok & "' is not a variable name!"
            XLScriptAddLogEntry FMT1("XLSCRIPT_18", tok)
          End If
        
          Do While wasdot
            wasdot = False
            tok = GetToken(codeValRet)
            If Len(tok) > 0 Then
              If Left(codeValRet, 1) = "." Then
                codeValRet = Mid(codeValRet, 2)
                wasdot = True
              End If
            
            End If
            
          Loop
        End If
    End Select
  End If
  XLScriptGetVarValue = res
End Function

Function XLScriptGetDBVarValue(ByRef codeValRet As String, par, c As Range, Optional obj = Nothing) As String
  On Error GoTo getError
  
  If Len(codeValRet) = 0 Or _
    (Left(codeValRet, 1) <> "." And _
    Not ((Left(codeValRet, 1) >= "a" And Left(codeValRet, 1) <= "z") Or (Left(codeValRet, 1) >= "A" And Left(codeValRet, 1) <= "Z"))) Then
    XLScriptGetDBVarValue = par
    Exit Function
  End If
  
  Dim tok As String
  Dim res As String
  
'  If Left(codeValRet, 1) = "(" Then
'    codeValRet = Mid(codeValRet, 2)
'    res = GetExpression(codeValRet, c)
  
'    If Not Left(codeValRet, 1) = ")" Then
'      XLScriptAddLogEntry "Error: '" & tok & "(' is missing ')'! " & m_WS.name & "!" & c.Address & " Value: " & c.Value
'    End If
    
  
  tok = GetToken(codeValRet)
  Dim wasdot As Long
  wasdot = False
  If Len(tok) > 0 Then
    If Left(codeValRet, 1) = "." Then
      codeValRet = Mid(codeValRet, 2)
      wasdot = True
    End If
    
    If VarValueExists(par, tok) Then
      res = par(tok)
    ElseIf XLScriptVarInCollectionExists(par, tok) Then
      res = par(tok).Properties(tok)
    ElseIf wasdot = True And ObjectNameExists(par, tok) = True Then
      res = XLScriptGetDBVarValue(codeValRet, par(tok), c)
    ElseIf PropertyNameExists(par, tok) = True Then
      res = par.Properties(tok)
    Else
      Select Case UCase(tok)
        Case "FNCOUNT"
          If Not obj Is Nothing Then
            res = obj.m_Current
          Else
            'XLScriptAddLogEntry "Error: '" & tok & "' is not initialized! " & m_WS.name & "!" & c.Address & " Value: " & c.value
            XLScriptAddLogEntry FMT4("XLSCRIPT_19", tok, m_WS.name, c.Address, c.value)
          End If
        Case "ADAPTIVEMENUS"
          res = par.AdaptiveMenus
        Case "ADAPTIVEMENU"
          res = par.AdaptiveMenu
        Case "BUILD"
          res = par.Build
        Case "BUILTIN"
          res = par.BuiltIn
        Case "COMADDINS"
          res = XLScriptGetDBVarValue(codeValRet, par.COMAddIns, c)
        Case "COMMANDBARS"
          res = XLScriptGetDBVarValue(codeValRet, par.CommandBars, c)
        Case "CONNECT"
          res = par.Connect
        Case "CONTEXT"
          res = par.Context
        Case "COUNT"
          res = par.count
        Case "CREATOR"
          res = par.Creator
        Case "DBENGINE"
          res = XLScriptGetDBVarValue(codeValRet, par.DBEngine, c)
        Case "DESCRIPTION"
          If PropertyNameExists(par, "DESCRIPTION") Then
            res = par.Properties("DESCRIPTION")
          Else
            res = par.Description
          End If
        Case "DISABLEASKAQUESTIONDROPDOWN"
          res = par.DisableAskAQuestionDropdown
        Case "DISABLECUSTOMIZE"
          res = par.DisableCustomize
        Case "DISPLAYFONTS"
          res = par.DisplayFonts
        Case "DISPLAYKEYSINTOOLTIPS"
          res = par.DisplayKeysInTooltips
        Case "DISPLAYTOOLTIPS"
          res = par.DisplayTooltips
        Case "ENABLED"
          res = par.Enabled
        Case "FIELDS"
          res = XLScriptGetDBVarValue(codeValRet, par.Fields, c)
        Case "FULLPATH"
          res = par.fullpath
        Case "GUID"
          res = par.Guid
        Case "INDEXES"
          res = XLScriptGetDBVarValue(codeValRet, par.Indexesm, c)
        Case "ISBROKEN"
          res = par.isbroken
        Case "ISCOMPILED"
          res = par.IsCompiled
        Case "ITEMS"
          res = par.items
        Case "NAME"
          res = par.name
        Case "VALUE"
          res = par.value
        Case "ATTRIBUTES"
          res = par.Attributes
        Case "NAMELOCAL"
          res = par.NameLocal
        Case "PRINTERS"
          res = XLScriptGetDBVarValue(codeValRet, par.Printers, c)
        Case "PRODUCTCODE"
          res = par.ProductCode
        Case "PROGID"
          res = par.ProgId
        Case "REFERENCES"
          res = XLScriptGetDBVarValue(codeValRet, par.References, c)
        Case "REFERSTO"
          res = par.RefersToLocal
        Case "RELATIONS"
          res = XLScriptGetDBVarValue(codeValRet, par.Relations, c)
        Case "SHEETS"
          res = par.Worksheets
        Case "VERSION"
          res = par.Version
        Case "VISIBLE"
          res = par.Visible

        Case Else
          res = XLScriptGetDBVarValue(codeValRet, par.Properties(UCase(tok)), c)
      End Select
    End If
  End If
  XLScriptGetDBVarValue = res
  Exit Function
getError:
  If Len(tok) > 0 Then
    If GetUserName = "norman" Then XLScriptAddLogEntry "Warning: " & Err.Description & "  - Token: '" & tok & "' - " & m_WS.name & "!" & c.Address & " Value: " & c.value
  Else
    If GetUserName = "norman" Then XLScriptAddLogEntry "Warning: " & Err.Description & " - " & m_WS.name & "!" & c.Address & " Value: " & c.value
  End If
  
End Function

Private Function GetRef(ByRef codeValRet As String, c As Range)
  On Error GoTo 0
  Dim tok As String
  Dim res
  Dim wasdot As Boolean
  wasdot = False
  tok = GetToken(codeValRet)
  If Len(tok) > 0 Then
    If Left(codeValRet, 1) = "." Then
      codeValRet = Trim(Mid(codeValRet, 2))
      wasdot = True
    End If
    Select Case UCase(tok)

#If USE_MDB = True Then
      Case "DB"
        Set res = GetDBRef(codeValRet, m_DB, c)
      Case "WS"
        Set res = GetDBRef(codeValRet, m_Workspace, c)
      Case "APP"
        Set res = GetDBRef(codeValRet, m_App, c)
#End If
      Case "XL"
        Set res = GetDBRef(codeValRet, m_Excel, c)
#If USE_XLS = True Then
      Case "XLWB"
        Set res = GetDBRef(codeValRet, m_Workbook, c)
#End If
      Case Else
        Dim found As Boolean
        found = False
        
        Dim goitem As XLScriptGlobalObject
        For Each goitem In m_GlobalObjects
          If UCase(goitem.m_Name) = UCase(tok) Then
            res = GetDBRef(codeValRet, goitem.m_Object, c)
            found = True
            Exit For
          End If
        Next goitem
            
            
        ' Ansonsten muss es eigentlich eine Variable sein...
        Dim item As XLForNext
        For Each item In m_FN
          If UCase(item.m_Name) = UCase(tok) Then
            Set res = GetDBRef(codeValRet, item.m_Ref(item.m_Current), c, item)
            found = True
            Exit For
          End If
        Next item
        
        ' Dann wollen wir doch mal nach "normalen" VariablenArrays schauen, die das Programm ermittelt hat
        If Not found Then
          Dim vaitem As XLScriptArray2D
          For Each vaitem In m_VarArray2D
            If UCase(vaitem.Properties("NAME")) = UCase(tok) Then
              Set res = vaitem.items
              If m_InPrint = True And XLSCript_Debug = True Then
                vaitem.m_WasPrinted = True
              End If
              If wasdot Then
                If ObjectNameExists(vaitem.items, codeValRet) Then
                  Set res = vaitem.items(codeValRet).items
                Else
                  Set res = Nothing
                End If
              End If
              If Not res Is Nothing Then
                found = True
              End If
              Exit For
            End If
          Next vaitem
        End If
        
        If Not found Then
          Dim vasitem As XLScriptArray
          For Each vasitem In m_VarArray
            If UCase(vasitem.Properties("NAME")) = UCase(tok) Then
              Set res = vasitem.items
              If m_InPrint = True And XLSCript_Debug = True Then
                vasitem.m_WasPrinted = True
              End If
              found = True
              Exit For
            End If
          Next vasitem
        End If
        
        If Not found Then
          'XLScriptAddLogEntry "Error: '" & tok & "' is not a variable name! " & m_WS.name & "!" & c.Address & " Value: " & c.value
          XLScriptAddLogEntry FMT4("XLSCRIPT_17", tok, m_WS.name, c.Address, c.value)
        End If
    End Select
  End If
  If Not IsEmpty(res) Then
    Set GetRef = res
  Else
    Set GetRef = Nothing
  End If
End Function

Private Function GetDBRef(ByRef codeValRet As String, par, c As Range, Optional obj = Nothing)
  On Error GoTo getError
  
  If Len(codeValRet) = 0 Or _
    (Left(codeValRet, 1) <> "." And _
    Not ((Left(codeValRet, 1) >= "a" And Left(codeValRet, 1) <= "z") Or (Left(codeValRet, 1) >= "A" And Left(codeValRet, 1) <= "Z")) Or UCase(Left(codeValRet, 6)) = "WIDTH ") Then
    Set GetDBRef = par
    Exit Function
  End If
  
  Dim tok As String
  Dim res
  tok = GetToken(codeValRet)
  If Len(tok) > 0 Then
  
    If Left(codeValRet, 1) = "." Then
      codeValRet = Mid(codeValRet, 2)
    End If
    
    
'    If PropertyNameExists(par, tok) Then
'      Set res = GetDBRef(codeValRet, par.Properties(UCase(tok)), c)
'    Else
      Select Case UCase(tok)
        Case "FNCOUNT"
          If Not obj Is Nothing Then
            res = obj.m_Current
          Else
            'XLScriptAddLogEntry "Error: '" & tok & "' is not initialized! " & m_WS.name & "!" & c.Address & " Value: " & c.value
            XLScriptAddLogEntry FMT4("XLSCRIPT_19", tok, m_WS.name, c.Address, c.value)
          End If
        Case "CONTAINERS"
          Set res = GetDBRef(codeValRet, par.Containers, c)
        Case "DBENGINE"
          Set res = GetDBRef(codeValRet, par.DBEngine, c)
        Case "REFERENCES"
          Set res = GetDBRef(codeValRet, par.References, c)
        Case "RELATIONS"
          Set res = GetDBRef(codeValRet, par.Relations, c)
        Case "DOCUMENTS"
          Set res = GetDBRef(codeValRet, par.Documents, c)
        Case "FIELDS"
          Set res = GetDBRef(codeValRet, par.Fields, c)
        Case "INDEXES"
          Set res = GetDBRef(codeValRet, par.Indexes, c)
        Case "PRINTERS"
          Set res = GetDBRef(codeValRet, par.Printers, c)
        Case "COMADDINS"
          Set res = GetDBRef(codeValRet, par.COMAddIns, c)
        Case "COMMANDBARS"
          Set res = GetDBRef(codeValRet, par.CommandBars, c)
        Case "PROPERTIES"
          Set res = GetDBRef(codeValRet, par.Properties, c)
        Case "COUNT"
          Set res = par.count
        Case "BUILD"
          Set res = par.Build
        Case "ISCOMPILED"
          Set res = par.IsCompiled
        Case "PRODUCTCODE"
          Set res = par.ProductCode
        Case "VERSION"
          Set res = par.Version
        Case "TABLEDEFS"
          Set res = GetDBRef(codeValRet, par.TableDefs, c)
        Case "GROUPS"
          Set res = GetDBRef(codeValRet, par.Groups, c)
        Case "USERS"
          Set res = GetDBRef(codeValRet, par.Users, c)
        Case "NAMES"
          Set res = GetDBRef(codeValRet, par.names, c)
        Case "ITEMS"
          Set res = par.items
        Case "QUERYDEFS"
          Set res = GetDBRef(codeValRet, par.QueryDefs, c)
          
        Case Else
          If PropertyNameExists(par, UCase(tok)) Then
            Set res = GetDBRef(codeValRet, par.Properties(UCase(tok)), c)
          ElseIf ObjectNameExists(par, UCase(tok)) Then
            Set res = GetDBRef(codeValRet, par(UCase(tok)), c)
          End If
      End Select
'    End If
  End If
  Set GetDBRef = res
  Exit Function
getError:
  
  If Len(tok) > 0 Then
    If GetUserName = "norman" Then XLScriptAddLogEntry "Warning: " & Err.Description & "  - Token: '" & tok & "' - " & m_WS.name & "!" & c.Address & " Value: " & c.value
  Else
    If GetUserName = "norman" Then XLScriptAddLogEntry "Warning: " & Err.Description & " - " & m_WS.name & "!" & c.Address & " Value: " & c.value
  End If
  Set GetDBRef = Nothing
End Function


Public Sub XLScriptAddLogEntry(s As String)
'  If Not m_ResultWorkbook Is Nothing Then
'    m_ResultWorkbook.Sheets("Log").Cells(m_LogY, 1) = s
'    m_LogY = m_LogY + 1
'  End If
  AddStatus s
'  m_Log.Add s
End Sub


Private Function CountReadable(ref) As Boolean
  On Error GoTo notReadable
  Dim i As Long
  i = ref.count
  CountReadable = True
  Exit Function
  
notReadable:
  CountReadable = False
End Function


Public Function IsReadableFormula(anything) As Boolean
  On Error GoTo nopeNotReadable
  Debug.Print anything.Formula
  IsReadableFormula = True
  Exit Function
nopeNotReadable:
  IsReadableFormula = False
End Function

Function XLScriptGetNewObject(s As String) As Object
  Select Case s
    Case "XLScriptVar"
      Set XLScriptGetNewObject = New XLScriptVar
      Exit Function
    Case "XLScriptSimpleVar"
      Set XLScriptGetNewObject = New XLScriptSimpleVar
      Exit Function
    Case Else
      Err.Raise vbObjectError + 27, "XLScript.XLScript", "Unknown XLScriptGetNewObject type '" & s & "'"
  End Select
End Function


Function IsValid(c As Range) As Boolean
  IsValid = False
  On Error GoTo notValid
  Dim tstr
  tstr = c.value
  IsValid = True
  Exit Function
notValid:
End Function

Public Function XLScriptVarInCollectionExists(par, name As String) As Boolean
  On Error GoTo notReadable
  Dim s As String
  If TypeName(par) = "Collection" Then
    If TypeName(par(name)) = "XLScriptVar" Then
      XLScriptVarInCollectionExists = True
      Exit Function
    End If
  End If
  
notReadable:
  XLScriptVarInCollectionExists = False
End Function

Public Function VarValueExists(par, name As String) As Boolean
  On Error GoTo notReadable
  Dim s As String
  s = CStr(par(UCase(name)))
  VarValueExists = True
  Exit Function
  
notReadable:
  VarValueExists = False
End Function

Public Function ObjectNameExists(par, name As String) As Variant
  On Error GoTo notReadable
  Dim s As Variant
  Set s = par(name)
  ObjectNameExists = True
  Exit Function
  
notReadable:
  ObjectNameExists = False
End Function

Public Function PropertyNameExists(par, name As String) As Boolean
  On Error Resume Next
  PropertyNameExists = True
  Dim s As String
  s = CStr(par.Properties(UCase(name)))
  If Err.Number = 0 Then Exit Function
'XXX
  Err.Clear
  Dim t
  Set t = par.Properties(UCase(name))
  If Err.Number = 0 Then Exit Function
  
  PropertyNameExists = False
End Function





#If USE_MDB = True Then
Public Sub CreateAccessApp(v As Long)
  #If USE_LATE_BINDING_MDB Then
'    Set m_App = CreateObject("Access.Application")
    Set m_App = CreateObject("Access.Application." & v)
  #Else
    Set m_App = New Access.Application
  #End If
End Sub
#End If

#If USE_MDB = True Then
' http://www.fmsinc.com/microsoftaccess/history/versions.htm
' 2016  16
' 2013  15
' 2010  14
' 2007  12
' 2003  11
' 2002  10
' 2000  9
' 97    8
Public Function CheckAccessVersion(v As Long) As Boolean
CheckAccessVersion = False
On Error Resume Next
'  #If USE_LATE_BINDING_MDB Then
'    Set m_App = CreateObject("Access.Application")
    Dim o As Object
    SaveSetting appname:="Stromwerken", Section:="AccessTracker", Key:="IgnoreThisOne", setting:="True"
    Set o = CreateObject("Access.Application." & v)
    If Not o Is Nothing Then
      CheckAccessVersion = True
      o.CloseCurrentDatabase
      o.Quit
      Set o = Nothing
    End If
    SaveSetting appname:="Stromwerken", Section:="AccessTracker", Key:="IgnoreThisOne", setting:="False"
'  #Else
'    Set m_App = New Access.Application
'  #End If
End Function
#End If



Attribute VB_Name = "XLScriptArray"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

Public m_SortName As String
Public items As Collection
Public Properties As Collection
Public m_WasPrinted As Boolean


Public Sub Init(Optional n As String = "", Optional v As String = "")
  Set Properties = New Collection
  m_SortName = n
  Properties.Add n, "NAME"
  Properties.Add v, "VAL"
  Set items = New Collection
End Sub

Public Sub AddValue(n As String, v As String)
  If Len(n) > 0 Then
    items.Add v, UCase(n)
  Else
    items.Add v
  End If
End Sub

Function AddNameAndValue(n As String, v As String) As XLScriptVar
  Dim dv As XLScriptVar
  Set dv = New XLScriptVar
  dv.Init n
  dv.Properties.Add n, "NAME"
  dv.Properties.Add v, "VAL"
  items.Add dv, CStr(n)
  Set AddNameAndValue = dv
End Function

Sub AddXLScriptVar(ByRef xlsv As XLScriptVar)
  items.Add xlsv
End Sub

Public Sub AddToValue(propertyName As String, v)
  On Error Resume Next
  If Len(propertyName) > 0 Then
    Dim nv
    nv = Properties(propertyName)
    nv = nv + v
    Properties.Remove UCase(propertyName)
    Properties.Add nv, UCase(propertyName)
  End If
  Exit Sub
'wasMissing:
'    Properties.Add nv, v
End Sub



Attribute VB_Name = "XLScriptArray2D"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public m_SortName As String
Public items As Collection
Public itemKeys As Collection
Public Properties As Collection
Public PropertyKeys As Collection
Public m_WasPrinted As Boolean

Public Sub Store(nr As Integer)
'  assert 0
'  Close #1
  Write #nr, "XLScriptArray2D"
  Write #nr, m_SortName
  Dim item
  Write #nr, items.count
  Dim i As Long
  If items.count > 0 Then
    For i = 1 To items.count
      Select Case TypeName(items(i))
        Case "Collection"
          Dim tcoll As Collection
          Set tcoll = items(i)
          Dim tcollkeys As Collection
          Set tcollkeys = itemKeys(i)
          Dim ti As Long
          If tcoll.count > 0 Then
            For ti = 1 To tcoll.count
              Select Case TypeName(tcoll(ti))
                Case "String"
                  Write #nr, tcollkeys(ti), tcoll(ti)
                Case Else
                  Debug.Print "Unknown type: " & TypeName(tcoll(ti))
              End Select
            Next ti
          End If
          Set tcoll = Nothing
          Set tcollkeys = Nothing
        Case "XLScriptArray"
          items(i).Store nr
        Case Else
          Debug.Print "Unknown type: " & TypeName(items(i))
      End Select
  '    Write #nr, itemKeys(i)
  '    Write #nr, items(i)
    Next i
  End If
  Write #nr, Properties.count
  If Properties.count > 0 Then
    For i = 1 To Properties.count
      Write #nr, PropertyKeys(i), Properties(i)
    Next i
  End If
End Sub
Public Sub ReStore(nr As Integer)
  Dim am As Long
  Input #nr, am
  Dim i As Long
  Set Properties = New Collection
  For i = 1 To am
    Dim otype As String
    Input #nr, otype
    Dim sortname As String
    Input #nr, sortname
    Dim tObject
    Set tObject = XLScriptGetNewObject(otype)
    tObject.m_SortName = sortname
    Properties.Add tObject, sortname
    tObject.ReStore nr
  Next i
End Sub


Public Sub Init(Optional name As String = "")
  m_SortName = name
  Set items = New Collection
  Set itemKeys = New Collection
  Set Properties = New Collection
  Set PropertyKeys = New Collection
  Properties.Add name, "NAME"
  PropertyKeys.Add "NAME", "NAME"
End Sub

Public Sub AddLine(Optional linename As String = "")
  Dim al As Collection
  Set al = New Collection
  If Len(linename) = 0 Then
    items.Add al
  Else
    items.Add al, linename
  End If
  Set al = New Collection
  itemKeys.Add al
End Sub

Public Function CurrentLine() As Variant
  Set CurrentLine = items(items.count)
End Function

Public Sub AddValue(n As String, v As String)
  If Len(n) > 0 Then
    items(items.count).Add v, UCase(n)
    itemKeys(items.count).Add UCase(n), UCase(n)
  Else
    items(items.count).Add v
    itemKeys(items.count).Add ""
  End If
End Sub

Public Sub AddToValue(n As String, v)
  On Error Resume Next
  If Len(n) > 0 Then
    Dim nv
    nv = items(items.count).item(UCase(n))
    nv = nv + v
    items(items.count).Remove UCase(n)
    items(items.count).Add nv, UCase(n)
  End If
End Sub

Public Sub SetValue(n As String, v)
  On Error Resume Next
  If Len(n) > 0 Then
    items(items.count).Remove UCase(n)
    items(items.count).Add v, UCase(n)
  End If
End Sub


Public Sub AddVar(n As String, v As String)
'  items(items.count).AddNameAndValue n, v
  Dim dv As XLScriptVar
  Set dv = New XLScriptVar
  dv.Init n
  dv.Properties.Add v, n
  items(items.count).Add dv, CStr(n)
End Sub


Public Sub AddNameAndValue(n As String, v As String)
'  items(items.count).AddNameAndValue n, v
  Dim dv As XLScriptVar
  Set dv = New XLScriptVar
  dv.Init n
  dv.Properties.Add n, "NAME"
  dv.Properties.Add v, "VAL"
  items.Add dv, CStr(n)

End Sub

Public Function AddXLScriptArray(n As String, Optional v As String = "") As XLScriptArray
  
  Dim dsa As XLScriptArray
  Set dsa = New XLScriptArray
  dsa.Init n, v
  items.Add dsa, UCase(n)
  itemKeys.Add UCase(n), UCase(n)
  
  Set AddXLScriptArray = dsa

End Function

Public Function AddXLScriptArray2D(n As String) As XLScriptArray2D
  Dim da As XLScriptArray2D
  Set da = New XLScriptArray2D
  da.Init n
  items.Add da, UCase(n)
  itemKeys.Add UCase(n), UCase(n)
  
  Set AddXLScriptArray2D = da

End Function

Public Function AddXLScriptArray2DToCurrentLine(n As String) As XLScriptArray2D
  Dim da As XLScriptArray2D
  Set da = New XLScriptArray2D
  da.Init
  items(items.count).Add da, UCase(n)
  itemKeys(items.count).Add UCase(n), UCase(n)
  
  Set AddXLScriptArray2DToCurrentLine = da

End Function

Public Function AddXLScriptArrayToCurrentLine(n As String, Optional v As String = "") As XLScriptArray
  
  Dim dsa As XLScriptArray
  Set dsa = New XLScriptArray
  dsa.Init n, v
  items(items.count).Add dsa, UCase(n)
  itemKeys(items.count).Add UCase(n), UCase(n)
  
  Set AddXLScriptArrayToCurrentLine = dsa

End Function


Attribute VB_Name = "XLScriptForNext"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

    Public m_Name As String
    Public m_Ref
    Public m_Current As Integer
    Public m_Width As Integer
    Public m_WidthCurrent As Integer
Attribute VB_Name = "XLScriptGlobalObject"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public m_Object As Variant
Public m_Name As String



Attribute VB_Name = "XLScriptSimpleVar"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

Public m_Value As String
Public m_Txt As String
Public m_WasPrinted As Boolean

Attribute VB_Name = "XLScriptVar"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

Public m_SortName As String
Public Properties As Collection
Public PropertyKeys As Collection
Public m_WasPrinted As Boolean

Public Sub Store(nr As Integer)
  Write #nr, "XLScriptVar"
  Write #nr, m_SortName
  Write #nr, Properties.count
  Dim i As Long
  If Properties.count > 0 Then
    For i = 1 To Properties.count
      Write #nr, PropertyKeys(i), Properties(i)
    Next i
  End If
End Sub
Public Sub ReStore(nr As Integer)
  Dim am As Long
  Input #nr, am
  Dim i As Long
  Set Properties = New Collection
  For i = 1 To am
    Dim otype As String
    Input #nr, otype
    Dim sortname As String
    Input #nr, sortname
    Dim tObject
    Set tObject = XLScriptGetNewObject(otype)
    tObject.m_SortName = sortname
    Properties.Add tObject, sortname
    PropertyKeys.Add sortname, sortname
    tObject.ReStore nr
  Next i
End Sub
Public Sub Init(ByVal n As String)
  Set Properties = New Collection
  Set PropertyKeys = New Collection
  m_SortName = n
End Sub



Function GetScriptVar(n As String) As XLScriptVar
  If Not ScriptVarExists(n) Then
    Dim tsv As XLScriptVar
    Set tsv = New XLScriptVar
    tsv.Init n
    tsv.m_SortName = UCase(n)
    Properties.Add tsv, UCase(n)
    PropertyKeys.Add UCase(n), UCase(n)
  End If
  Set GetScriptVar = Properties(UCase(n))
End Function

Function GetScriptArray(n As String) As XLScriptArray
  If Not ScriptVarExists(n) Then
    Dim tsv As XLScriptArray
    Set tsv = New XLScriptArray
    tsv.Init n
    tsv.m_SortName = UCase(n)
    Properties.Add tsv, UCase(n)
    PropertyKeys.Add UCase(n), UCase(n)
  End If
  Set GetScriptArray = Properties(UCase(n))
End Function

Function ScriptVarExists(n As String) As Boolean
  On Error GoTo doesntExist
  ScriptVarExists = True
  Dim tobj
  Set tobj = Properties(UCase(n))
doesntExist:
  ScriptVarExists = False
End Function

Public Sub AddToValue(propertyName As String, v)
  On Error Resume Next
  If Len(propertyName) > 0 Then
    Dim nv
    nv = Properties(propertyName)
    nv = nv + v
    Properties.Remove UCase(propertyName)
    Properties.Add nv, UCase(propertyName)
  End If
End Sub

Public Sub SetValue(propertyName As String, v)
  On Error Resume Next
  If Len(propertyName) > 0 Then
    Properties.Remove UCase(propertyName)
    Properties.Add v, UCase(propertyName)
  End If
End Sub



Attribute VB_Name = "aaa_XLStuff"

Option Explicit

Private Sub CreateXLAXLAM()
  Application.DisplayAlerts = False
  WBRemoveTags
  ThisWorkbook.IsAddin = True
  ThisWorkbook.SaveAs ThisWorkbook.path & "\ACCV0.xla", xlAddIn
  ThisWorkbook.IsAddin = False
  ThisWorkbook.Saved = True
  Application.DisplayAlerts = True

End Sub


Private Sub WBRemoveTags()

    Dim nameItem As Excel.name

GoAgain:
    Dim i As Long
    If ThisWorkbook.names.count > 0 Then
      For i = 1 To ThisWorkbook.names.count
          If ThisWorkbook.names(i).Visible = False Then
              If Left(ThisWorkbook.names(i).name, Len("_IDVTracker")) = "_IDVTracker" Then
                  ThisWorkbook.names.item(i).Delete
                  GoTo GoAgain
              End If
          End If
      Next i
    End If

End Sub
Attribute VB_Name = "clsCommonDialog"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'|fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd|
'|fffd|VERSION 1.0 CLASS
'|fffd|BEGIN
'|fffd|  MultiUse = -1  'True
'|fffd|  Persistable = 0  'NotPersistable
'|fffd|  DataBindingBehavior = 0  'vbNone
'|fffd|  DataSourceBehavior = 0   'vbNone
'|fffd|  MTSTransactionMode = 0   'NotAnMTSObject
'|fffd|End
'|fffd|Attribute VB_Name = "clsCommonDialog"
'|fffd|Attribute VB_GlobalNameSpace = False
'|fffd|Attribute VB_Creatable = True
'|fffd|Attribute VB_PredeclaredId = False
'|fffd|Attribute VB_Exposed = True
'|fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd|
 
Option Explicit
' This code is from the Microsoft Knowledge Base.

#If VBA7 Then
'API function called by ChooseColor method
Private Declare PtrSafe Function ChooseColor Lib "comdlg32.dll" Alias "ChooseColorA" (pChoosecolor As ChooseColor) As Long

'API function called by ShowOpen method
Private Declare PtrSafe Function GetOpenFileName Lib "comdlg32.dll" Alias "GetOpenFileNameA" (pOpenfilename As OpenFilename) As Long

'API function called by ShowSave method
Private Declare PtrSafe Function GetSaveFileName Lib "comdlg32.dll" Alias "GetSaveFileNameA" (pOpenfilename As OpenFilename) As Long

'API function to retrieve extended error information
Private Declare PtrSafe Function CommDlgExtendedError Lib "comdlg32.dll" () As Long

'API memory functions
Private Declare PtrSafe Function GlobalAlloc Lib "kernel32" (ByVal wFlags As Long, ByVal dwBytes As Long) As LongPtr
Private Declare PtrSafe Function GlobalFree Lib "kernel32" (ByVal hMem As LongPtr) As LongPtr
Private Declare PtrSafe Function GlobalLock Lib "kernel32" (ByVal hMem As LongPtr) As LongPtr
Private Declare PtrSafe Function GlobalUnlock Lib "kernel32" (ByVal hMem As LongPtr) As LongPtr

Private Declare PtrSafe Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" ( _
         hpvDest As Any, hpvSource As Any, ByVal cbCopy As LongPtr)
#Else
'API function called by ChooseColor method
Private Declare Function ChooseColor Lib "comdlg32.dll" Alias "ChooseColorA" (pChoosecolor As ChooseColor) As Long

'API function called by ShowOpen method
Private Declare Function GetOpenFileName Lib "comdlg32.dll" Alias "GetOpenFileNameA" (pOpenfilename As OpenFilename) As Long

'API function called by ShowSave method
Private Declare Function GetSaveFileName Lib "comdlg32.dll" Alias "GetSaveFileNameA" (pOpenfilename As OpenFilename) As Long

'API function to retrieve extended error information
Private Declare Function CommDlgExtendedError Lib "comdlg32.dll" () As Long

'API memory functions
Private Declare Function GlobalAlloc Lib "kernel32" (ByVal wFlags As Long, ByVal dwBytes As Long) As Long
Private Declare Function GlobalFree Lib "kernel32" (ByVal hMem As Long) As Long
Private Declare Function GlobalLock Lib "kernel32" (ByVal hMem As Long) As Long
Private Declare Function GlobalUnlock Lib "kernel32" (ByVal hMem As Long) As Long

Private Declare Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" ( _
         hpvDest As Any, hpvSource As Any, ByVal cbCopy As Long)
 #End If

'constants for API memory functions
Private Const GMEM_MOVEABLE = &H2
Private Const GMEM_ZEROINIT = &H40
Private Const GHND = (GMEM_MOVEABLE Or GMEM_ZEROINIT)
 
 
'data buffer for the ChooseColor function
Private Type ChooseColor
        lStructSize As Long
        hwndOwner As Long
        hInstance As Long
        rgbResult As Long
        lpCustColors As Long
        Flags As Long
        lCustData As Long
        lpfnHook As Long
        lpTemplateName As String
End Type

'data buffer for the GetOpenFileName and GetSaveFileName functions
Private Type OpenFilename
        lStructSize As Long
        hwndOwner As Long
        hInstance As Long
        lpstrFilter As String
        lpstrCustomFilter As String
        nMaxCustFilter As Long
        iFilterIndex As Long
        lpstrFile As String
        nMaxFile As Long
        lpstrFileTitle As String
        nMaxFileTitle As Long
        lpstrInitialDir As String
        lpstrTitle As String
        Flags As Long
        nFileOffset As Integer
        nFileExtension As Integer
        lpstrDefExt As String
        lCustData As Long
        lpfnHook As Long
        lpTemplateName As String
End Type


'internal property buffers

Private iAction As Integer         'internal buffer for Action property
Private bCancelError As Boolean    'internal buffer for CancelError property
Private lColor As Long             'internal buffer for Color property
Private lCopies As Long            'internal buffer for lCopies property
Private sDefaultExt As String      'internal buffer for sDefaultExt property
Private sDialogTitle As String     'internal buffer for DialogTitle property
Private sFilename As String        'internal buffer for FileName property
Private sFileTitle As String       'internal buffer for FileTitle property
Private sFilter As String          'internal buffer for Filter property
Private iFilterIndex As Integer    'internal buffer for FilterIndex property
Private lFlags As Long             'internal buffer for Flags property
Private lhdc As Long               'internal buffer for hdc property
Private sInitDir As String         'internal buffer for InitDir property
Private lMax As Long               'internal buffer for Max property
Private lMaxFileSize As Long       'internal buffer for MaxFileSize property
Private lMin As Long               'internal buffer for Min property
Private objObject As Object        'internal buffer for Object property

Private lApiReturn As Long          'internal buffer for APIReturn property
Private lExtendedError As Long      'internal buffer for ExtendedError property



'constants for color dialog

Private Const CDERR_DIALOGFAILURE = &HFFFF
Private Const CDERR_FINDRESFAILURE = &H6
Private Const CDERR_GENERALCODES = &H0
Private Const CDERR_INITIALIZATION = &H2
Private Const CDERR_LOADRESFAILURE = &H7
Private Const CDERR_LOADSTRFAILURE = &H5
Private Const CDERR_LOCKRESFAILURE = &H8
Private Const CDERR_MEMALLOCFAILURE = &H9
Private Const CDERR_MEMLOCKFAILURE = &HA
Private Const CDERR_NOHINSTANCE = &H4
Private Const CDERR_NOHOOK = &HB
Private Const CDERR_NOTEMPLATE = &H3
Private Const CDERR_REGISTERMSGFAIL = &HC
Private Const CDERR_STRUCTSIZE = &H1


'constants for file dialog

Private Const FNERR_BUFFERTOOSMALL = &H3003
Private Const FNERR_FILENAMECODES = &H3000
Private Const FNERR_INVALIDFILENAME = &H3002
Private Const FNERR_SUBCLASSFAILURE = &H3001

Public Property Get Filter() As String
    'return object's Filter property
    Filter = sFilter
End Property

Public Sub ShowColor()
    'display the color dialog box
    
    Dim tChooseColor As ChooseColor
    Dim alCustomColors(15) As Long
    Dim lCustomColorSize As Long
    Dim lCustomColorAddress As Long
    Dim lMemHandle As Long
    
    Dim n As Integer
        
    On Error GoTo ShowColorError
    
    
    '***    init property buffers
    
    iAction = 3  'Action property - ShowColor
    lApiReturn = 0  'APIReturn property
    lExtendedError = 0  'ExtendedError property
    
    
    '***    prepare tChooseColor data
    
    'lStructSize As Long
    tChooseColor.lStructSize = Len(tChooseColor)
    
    'hwndOwner As Long
    tChooseColor.hwndOwner = 0& 'lhdc

    'hInstance As Long
    
    'rgbResult As Long
    tChooseColor.rgbResult = lColor
    
    'lpCustColors As Long
    ' Fill custom colors array with all white
    For n = 0 To UBound(alCustomColors)
        alCustomColors(n) = &HFFFFFF
    Next
    ' Get size of memory needed for custom colors
    lCustomColorSize = Len(alCustomColors(0)) * 16
    ' Get a global memory block to hold a copy of the custom colors
    lMemHandle = GlobalAlloc(GHND, lCustomColorSize)
    
    If lMemHandle = 0 Then
        Exit Sub
    End If
    ' Lock the custom color's global memory block
    lCustomColorAddress = GlobalLock(lMemHandle)
    If lCustomColorAddress = 0 Then
        Exit Sub
    End If
    ' Copy custom colors to the global memory block
    Call CopyMemory(ByVal lCustomColorAddress, alCustomColors(0), lCustomColorSize)
 
    tChooseColor.lpCustColors = lCustomColorAddress
    
    'flags As Long
    tChooseColor.Flags = lFlags
        
    'lCustData As Long
    'lpfnHook As Long
    'lpTemplateName As String
    
    
    '***    call the ChooseColor API function
    lApiReturn = ChooseColor(tChooseColor)
    
    
    '***    handle return from ChooseColor API function
    Select Case lApiReturn
        
        Case 0  'user canceled
        If bCancelError = True Then
            'generate an error
            On Error GoTo 0
            Err.Raise Number:=vbObjectError + 894, _
                Description:="Cancel Pressed"
            Exit Sub
        End If
        
        Case 1  'user selected a color
            'update property buffer
            lColor = tChooseColor.rgbResult
        
        Case Else   'an error occured
            'call CommDlgExtendedError
            lExtendedError = CommDlgExtendedError
        
    End Select

Exit Sub

ShowColorError:
    Exit Sub
End Sub

Public Sub ShowOpen()
    'display the file open dialog box
    ShowFileDialog (1)  'Action property - ShowOpen
End Sub

Public Sub ShowSave()
    'display the file save dialog box
    ShowFileDialog (2)  'Action property - ShowSave
End Sub

Public Property Get Filename() As String
    'return object's FileName property
    Filename = sFilename
End Property

Public Property Let Filename(vNewValue As String)
    'assign object's FileName property
    sFilename = vNewValue
End Property

Public Property Let Filter(vNewValue As String)
    'assign object's Filter property
    sFilter = vNewValue
End Property

Private Function sLeftOfNull(ByVal sIn As String)
    'returns the part of sIn preceding Chr$(0)
    Dim lNullPos As Long
    
    'init output
    sLeftOfNull = sIn
    
    'get position of first Chr$(0) in sIn
    lNullPos = InStr(sIn, Chr$(0))
    
    'return part of sIn to left of first Chr$(0) if found
    If lNullPos > 0 Then
        sLeftOfNull = Mid$(sIn, 1, lNullPos - 1)
    End If
    
End Function


Public Property Get Action() As Integer
    'Return object's Action property
    Action = iAction
End Property

Private Function sAPIFilter(sIn)
    'prepares sIn for use as a filter string in API common dialog functions
    Dim lChrNdx As Long
    Dim sOneChr As String
    Dim sOutStr As String
    
    'convert any | characters to nulls
    For lChrNdx = 1 To Len(sIn)
        sOneChr = Mid$(sIn, lChrNdx, 1)
        If sOneChr = "|" Then
            sOutStr = sOutStr & Chr$(0)
        Else
            sOutStr = sOutStr & sOneChr
        End If
    Next
    
    'add a null to the end
    sOutStr = sOutStr & Chr$(0)
    
    'return sOutStr
    sAPIFilter = sOutStr
    
End Function

Public Property Get FilterIndex() As Integer
    'return object's FilterIndex property
    FilterIndex = iFilterIndex
End Property

Public Property Let FilterIndex(vNewValue As Integer)
    iFilterIndex = vNewValue
End Property

Public Property Get CancelError() As Boolean
    'Return object's CancelError property
    CancelError = bCancelError
End Property

Public Property Let CancelError(vNewValue As Boolean)
    'Assign object's CancelError property
    bCancelError = vNewValue
End Property

Public Property Get Color() As Long
    'return object's Color property
    Color = lColor
End Property

Public Property Let Color(vNewValue As Long)
    'assign object's Color property
    lColor = vNewValue
End Property

Public Property Get DefaultExt() As String
    'return object's DefaultExt property
    DefaultExt = sDefaultExt
End Property

Public Property Let DefaultExt(vNewValue As String)
    'assign object's DefaultExt property
    sDefaultExt = vNewValue
End Property

Public Property Get DialogTitle() As String
    'return object's FileName property
    DialogTitle = sDialogTitle
End Property

Public Property Let DialogTitle(vNewValue As String)
    'assign object's DialogTitle property
    sDialogTitle = vNewValue
End Property

Public Property Get Flags() As Long
    'return object's Flags property
    Flags = lFlags
End Property

Public Property Let Flags(vNewValue As Long)
    'assign object's Flags property
    lFlags = vNewValue
End Property

Public Property Get hDC() As Long
    'Return object's hDC property
    hDC = lhdc
End Property

Public Property Let hDC(vNewValue As Long)
    'Assign object's hDC property
    lhdc = vNewValue
End Property

Public Property Get InitDir() As String
    'Return object's InitDir property
    InitDir = sInitDir
End Property

Public Property Let InitDir(vNewValue As String)
    'Assign object's InitDir property
    sInitDir = vNewValue
End Property

Public Property Get Max() As Long
    'Return object's Max property
    Max = lMax
End Property

Public Property Let Max(vNewValue As Long)
    'Assign object's - property
    lMax = vNewValue
End Property

Public Property Get MaxFileSize() As Long
    'Return object's MaxFileSize property
    MaxFileSize = lMaxFileSize
End Property

Public Property Let MaxFileSize(vNewValue As Long)
    'Assign object's MaxFileSize property
    lMaxFileSize = vNewValue
End Property

Public Property Get Min() As Long
    'Return object's Min property
    Min = lMin
End Property

Public Property Let Min(vNewValue As Long)
    'Assign object's Min property
    lMin = vNewValue
End Property

Public Property Get Object() As Object
    'Return object's Object property
    Object = objObject
End Property

Public Property Let Object(vNewValue As Object)
    'Assign object's Object property
    objObject = vNewValue
End Property

Public Property Get FileTitle() As String
    'return object's FileTitle property
    FileTitle = sFileTitle
End Property

Public Property Let FileTitle(vNewValue As String)
    'assign object's FileTitle property
    sFileTitle = vNewValue
End Property

Public Property Get APIReturn() As Long
    'return object's APIReturn property
    APIReturn = lApiReturn
End Property

Public Property Get ExtendedError() As Long
    'return object's ExtendedError property
    ExtendedError = lExtendedError
End Property


Private Function sByteArrayToString(abBytes() As Byte) As String
    'return a string from a byte array
    Dim lBytePoint As Long
    Dim lByteVal As Long
    Dim sOut As String
    
    'init array pointer
    lBytePoint = LBound(abBytes)
    
    'fill sOut with characters in array
    While lBytePoint <= UBound(abBytes)
        
        lByteVal = abBytes(lBytePoint)
        
        'return sOut and stop if Chr$(0) is encountered
        If lByteVal = 0 Then
            sByteArrayToString = sOut
            Exit Function
        Else
            sOut = sOut & Chr$(lByteVal)
        End If
        
        lBytePoint = lBytePoint + 1
    
    Wend
    
    'return sOut if Chr$(0) wasn't encountered
    sByteArrayToString = sOut
    
End Function
Private Sub ShowFileDialog(ByVal iAction As Integer)
    
    'display the file dialog for ShowOpen or ShowSave
    
    Dim tOpenFile As OpenFilename
    Dim lMaxSize As Long
    Dim sFileNameBuff As String
    Dim sFileTitleBuff As String
    
    On Error GoTo ShowFileDialogError
    
    
    '***    init property buffers
    
    iAction = iAction  'Action property
    lApiReturn = 0  'APIReturn property
    lExtendedError = 0  'ExtendedError property
        
    
    '***    prepare tOpenFile data
    
    'tOpenFile.lStructSize As Long
    tOpenFile.lStructSize = Len(tOpenFile)
    
    'tOpenFile.hWndOwner As Long - init from hdc property
    tOpenFile.hwndOwner = 0& ' Just use 0 !
    
    'tOpenFile.lpstrFilter As String - init from Filter property
    tOpenFile.lpstrFilter = sAPIFilter(sFilter)
        
    'tOpenFile.iFilterIndex As Long - init from FilterIndex property
    tOpenFile.iFilterIndex = iFilterIndex
    
    'tOpenFile.lpstrFile As String
        'determine size of buffer from MaxFileSize property
        If lMaxFileSize > 0 Then
            lMaxSize = lMaxFileSize
        Else
            lMaxSize = 256
        End If
    
    'tOpenFile.lpstrFile As Long - init from FileName property
        'prepare sFileNameBuff
        sFileNameBuff = sFilename
        'pad with spaces
        While Len(sFileNameBuff) < lMaxSize - 1
            sFileNameBuff = sFileNameBuff & " "
        Wend
        'trim to length of lMaxFileSize - 1
       sFileNameBuff = Mid$(sFileNameBuff, 1, lMaxFileSize - 1)
        'null terminate
        sFileNameBuff = sFileNameBuff & Chr$(0)
    tOpenFile.lpstrFile = sFileNameBuff
    
    'nMaxFile As Long - init from MaxFileSize property
    If lMaxFileSize <> 255 Then  'default is 255
        tOpenFile.nMaxFile = lMaxFileSize
    End If
            
    'lpstrFileTitle As String - init from FileTitle property
        'prepare sFileTitleBuff
        sFileTitleBuff = sFileTitle
        'pad with spaces
        While Len(sFileTitleBuff) < lMaxSize - 1
            sFileTitleBuff = sFileTitleBuff & " "
        Wend
        'trim to length of lMaxFileSize - 1
        sFileTitleBuff = Mid$(sFileTitleBuff, 1, lMaxFileSize - 1)
        'null terminate
        sFileTitleBuff = sFileTitleBuff & Chr$(0)
    tOpenFile.lpstrFileTitle = sFileTitleBuff
        
    'tOpenFile.lpstrInitialDir As String - init from InitDir property
    tOpenFile.lpstrInitialDir = sInitDir
    
    'tOpenFile.lpstrTitle As String - init from DialogTitle property
    tOpenFile.lpstrTitle = sDialogTitle
    
    'tOpenFile.flags As Long - init from Flags property
    tOpenFile.Flags = lFlags
        
    'tOpenFile.lpstrDefExt As String - init from DefaultExt property
    tOpenFile.lpstrDefExt = sDefaultExt
    
    
    '***    call the GetOpenFileName API function
    Select Case iAction
        Case 1  'ShowOpen
            lApiReturn = GetOpenFileName(tOpenFile)
        Case 2  'ShowSave
            lApiReturn = GetSaveFileName(tOpenFile)
        Case Else   'unknown action
            Exit Sub
    End Select
    
    
    '***    handle return from GetOpenFileName API function
    Select Case lApiReturn
        
        Case 0  'user canceled
        If bCancelError = True Then
            'generate an error
            Err.Raise (2001)
            Exit Sub
        End If
        
        Case 1  'user selected or entered a file
            'sFileName gets part of tOpenFile.lpstrFile to the left of first Chr$(0)
            sFilename = sLeftOfNull(tOpenFile.lpstrFile)
            sFileTitle = sLeftOfNull(tOpenFile.lpstrFileTitle)
        
        Case Else   'an error occured
            'call CommDlgExtendedError
            lExtendedError = CommDlgExtendedError
        
    End Select
    

Exit Sub

ShowFileDialogError:
    
    Exit Sub

End Sub










' InQuest injected base64 decoded content
' $zp^
' W-'+
' 'tZ(
' 0:yrF
' x(^rB 
' z{Uz
' KnjX

INQUEST-PP=macro
