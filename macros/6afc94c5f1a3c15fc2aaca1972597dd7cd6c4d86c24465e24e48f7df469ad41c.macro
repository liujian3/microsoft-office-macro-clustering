Attribute VB_Name = "CRijndael"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
' Added for MWS Integration
' Abhijit Tambe, July 2010

'*******************************************************************************
' MODULE:       CRijndael
' FILENAME:     CRijndael.cls
' AUTHOR:       Phil Fresle
' CREATED:      16-Feb-2001
' COPYRIGHT:    Copyright 2001 Phil Fresle
' EMAIL:        phil@frez.co.uk
' WEB:          http://www.frez.co.uk
'
' DESCRIPTION:
' Implementation of the AES Rijndael Block Cipher. Inspired by Mike Scott's
' implementation in C. Permission for free direct or derivative use is granted
' subject to compliance with any conditions that the originators of the
' algorithm place on its exploitation.
'
' MODIFICATION HISTORY:
' 16-Feb-2001   Phil Fresle     Initial Version
' 03-Apr-2001   Phil Fresle     Added EncryptData and DecryptData functions to
'                               make it easier to use by VB developers for
'                               encrypting and decrypting strings. These procs
'                               take large byte arrays, the resultant encoded
'                               data includes the message length inserted on
'                               the front four bytes prior to encryption.
' 19-Apr-2001   Phil Fresle     Thanks to Paolo Migliaccio for finding a bug
'                               with 256 bit key. Problem was in the gkey
'                               function. Now properly matches NIST values.
'*******************************************************************************
Option Explicit

Private m_lOnBits(30)   As Long
Private m_l2Power(30)   As Long
Private m_bytOnBits(7)  As Byte
Private m_byt2Power(7)  As Byte

Private m_InCo(3) As Byte

Private m_fbsub(255)    As Byte
Private m_rbsub(255)    As Byte
Private m_ptab(255)     As Byte
Private m_ltab(255)     As Byte
Private m_ftable(255)   As Long
Private m_rtable(255)   As Long
Private m_rco(29)       As Long

Private m_Nk        As Long
Private m_Nb        As Long
Private m_Nr        As Long
Private m_fi(23)    As Byte
Private m_ri(23)    As Byte
Private m_fkey(119) As Long
Private m_rkey(119) As Long

'==========================================================================================
'For 64-bit compatibility.

'MSDN: Compatibility Between the 32-bit and 64-bit Versions of Office 2010:
    'http://msdn.microsoft.com/en-us/library/ee691831.aspx
'Technet: Microsoft Office Code Compatibility Inspector:
    'http://technet.microsoft.com/en-us/library/ee833946.aspx
'Samples:
    'The Microsoft file Win32_PtrSafe.txt contains 64-bit Windows API Declarations and Constants for VBA:
        'http://support.microsoft.com/kb/2030490
        'http://www.microsoft.com/downloads/en/details.aspx?FamilyID=035b72a5-eef9-4baf-8dbc-63fbd2dd982b&displaylang=en
    'http://www.jkp-ads.com/articles/apideclarations.asp
'Windows API functions that were modified/added for 64-bit Windows:
    'http://msdn.microsoft.com/en-us/library/aa383663(VS.85).aspx

'PtrSafe:
    'For Excel 2010 and later (#Vba7 = True), change "Declare" to "Declare PtrSafe".
'LongPtr:
    'For Excel 2010 and later (#Vba7 = True), change the data type of handles and pointers
    'from Long to LongPtr. Leave pointers to strings as String.
'LongLong:
    'For 64-bit Excel (#Win64 = True), change Long (except for handles and pointers!) to LongLong

#If Mac Then
    'Running on MacIntosh. Do nothing.
#ElseIf VBA7 Then
    'Excel 2010 or later:
     #If Win64 Then
        '64-bit Excel, 2010 or later:
        'Use PtrSafe, LongPtr, and LongLong:
        
            Private Declare PtrSafe Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" _
                (ByVal Destination As Any, ByVal Source As Any, ByVal Length As LongLong)

     #Else
        '32-bit Excel 2010 or later:
        'Use PtrSafe and LongPtr, but NOT LongLong:

            Private Declare PtrSafe Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" _
                (ByVal Destination As Any, ByVal Source As Any, ByVal Length As Long)
        
     #End If
#Else
    'Excel 2007 or earlier:

        Private Declare Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" _
            (ByVal Destination As Any, ByVal Source As Any, ByVal Length As Long)

#End If

'==========================================================================================


'*******************************************************************************
' Class_Initialize (SUB)
'*******************************************************************************
Private Sub Class_Initialize()
    m_InCo(0) = &HB
    m_InCo(1) = &HD
    m_InCo(2) = &H9
    m_InCo(3) = &HE
    
    ' Could have done this with a loop calculating each value, but simply
    ' assigning the values is quicker - BITS SET FROM RIGHT
    m_bytOnBits(0) = 1          ' 00000001
    m_bytOnBits(1) = 3          ' 00000011
    m_bytOnBits(2) = 7          ' 00000111
    m_bytOnBits(3) = 15         ' 00001111
    m_bytOnBits(4) = 31         ' 00011111
    m_bytOnBits(5) = 63         ' 00111111
    m_bytOnBits(6) = 127        ' 01111111
    m_bytOnBits(7) = 255        ' 11111111
    
    ' Could have done this with a loop calculating each value, but simply
    ' assigning the values is quicker - POWERS OF 2
    m_byt2Power(0) = 1          ' 00000001
    m_byt2Power(1) = 2          ' 00000010
    m_byt2Power(2) = 4          ' 00000100
    m_byt2Power(3) = 8          ' 00001000
    m_byt2Power(4) = 16         ' 00010000
    m_byt2Power(5) = 32         ' 00100000
    m_byt2Power(6) = 64         ' 01000000
    m_byt2Power(7) = 128        ' 10000000
    
    ' Could have done this with a loop calculating each value, but simply
    ' assigning the values is quicker - BITS SET FROM RIGHT
    m_lOnBits(0) = 1            ' 00000000000000000000000000000001
    m_lOnBits(1) = 3            ' 00000000000000000000000000000011
    m_lOnBits(2) = 7            ' 00000000000000000000000000000111
    m_lOnBits(3) = 15           ' 00000000000000000000000000001111
    m_lOnBits(4) = 31           ' 00000000000000000000000000011111
    m_lOnBits(5) = 63           ' 00000000000000000000000000111111
    m_lOnBits(6) = 127          ' 00000000000000000000000001111111
    m_lOnBits(7) = 255          ' 00000000000000000000000011111111
    m_lOnBits(8) = 511          ' 00000000000000000000000111111111
    m_lOnBits(9) = 1023         ' 00000000000000000000001111111111
    m_lOnBits(10) = 2047        ' 00000000000000000000011111111111
    m_lOnBits(11) = 4095        ' 00000000000000000000111111111111
    m_lOnBits(12) = 8191        ' 00000000000000000001111111111111
    m_lOnBits(13) = 16383       ' 00000000000000000011111111111111
    m_lOnBits(14) = 32767       ' 00000000000000000111111111111111
    m_lOnBits(15) = 65535       ' 00000000000000001111111111111111
    m_lOnBits(16) = 131071      ' 00000000000000011111111111111111
    m_lOnBits(17) = 262143      ' 00000000000000111111111111111111
    m_lOnBits(18) = 524287      ' 00000000000001111111111111111111
    m_lOnBits(19) = 1048575     ' 00000000000011111111111111111111
    m_lOnBits(20) = 2097151     ' 00000000000111111111111111111111
    m_lOnBits(21) = 4194303     ' 00000000001111111111111111111111
    m_lOnBits(22) = 8388607     ' 00000000011111111111111111111111
    m_lOnBits(23) = 16777215    ' 00000000111111111111111111111111
    m_lOnBits(24) = 33554431    ' 00000001111111111111111111111111
    m_lOnBits(25) = 67108863    ' 00000011111111111111111111111111
    m_lOnBits(26) = 134217727   ' 00000111111111111111111111111111
    m_lOnBits(27) = 268435455   ' 00001111111111111111111111111111
    m_lOnBits(28) = 536870911   ' 00011111111111111111111111111111
    m_lOnBits(29) = 1073741823  ' 00111111111111111111111111111111
    m_lOnBits(30) = 2147483647  ' 01111111111111111111111111111111
    
    ' Could have done this with a loop calculating each value, but simply
    ' assigning the values is quicker - POWERS OF 2
    m_l2Power(0) = 1            ' 00000000000000000000000000000001
    m_l2Power(1) = 2            ' 00000000000000000000000000000010
    m_l2Power(2) = 4            ' 00000000000000000000000000000100
    m_l2Power(3) = 8            ' 00000000000000000000000000001000
    m_l2Power(4) = 16           ' 00000000000000000000000000010000
    m_l2Power(5) = 32           ' 00000000000000000000000000100000
    m_l2Power(6) = 64           ' 00000000000000000000000001000000
    m_l2Power(7) = 128          ' 00000000000000000000000010000000
    m_l2Power(8) = 256          ' 00000000000000000000000100000000
    m_l2Power(9) = 512          ' 00000000000000000000001000000000
    m_l2Power(10) = 1024        ' 00000000000000000000010000000000
    m_l2Power(11) = 2048        ' 00000000000000000000100000000000
    m_l2Power(12) = 4096        ' 00000000000000000001000000000000
    m_l2Power(13) = 8192        ' 00000000000000000010000000000000
    m_l2Power(14) = 16384       ' 00000000000000000100000000000000
    m_l2Power(15) = 32768       ' 00000000000000001000000000000000
    m_l2Power(16) = 65536       ' 00000000000000010000000000000000
    m_l2Power(17) = 131072      ' 00000000000000100000000000000000
    m_l2Power(18) = 262144      ' 00000000000001000000000000000000
    m_l2Power(19) = 524288      ' 00000000000010000000000000000000
    m_l2Power(20) = 1048576     ' 00000000000100000000000000000000
    m_l2Power(21) = 2097152     ' 00000000001000000000000000000000
    m_l2Power(22) = 4194304     ' 00000000010000000000000000000000
    m_l2Power(23) = 8388608     ' 00000000100000000000000000000000
    m_l2Power(24) = 16777216    ' 00000001000000000000000000000000
    m_l2Power(25) = 33554432    ' 00000010000000000000000000000000
    m_l2Power(26) = 67108864    ' 00000100000000000000000000000000
    m_l2Power(27) = 134217728   ' 00001000000000000000000000000000
    m_l2Power(28) = 268435456   ' 00010000000000000000000000000000
    m_l2Power(29) = 536870912   ' 00100000000000000000000000000000
    m_l2Power(30) = 1073741824  ' 01000000000000000000000000000000
End Sub

'*******************************************************************************
' LShift (FUNCTION)
'*******************************************************************************
Private Function LShift(ByVal lValue As Long, _
                        ByVal iShiftBits As Integer) As Long
    If iShiftBits = 0 Then
        LShift = lValue
        Exit Function
    ElseIf iShiftBits = 31 Then
        If lValue And 1 Then
            LShift = &H80000000
        Else
            LShift = 0
        End If
        Exit Function
    ElseIf iShiftBits < 0 Or iShiftBits > 31 Then
        Err.Raise 6
    End If
    
    If (lValue And m_l2Power(31 - iShiftBits)) Then
        LShift = ((lValue And m_lOnBits(31 - (iShiftBits + 1))) * _
            m_l2Power(iShiftBits)) Or &H80000000
    Else
        LShift = ((lValue And m_lOnBits(31 - iShiftBits)) * _
            m_l2Power(iShiftBits))
    End If
End Function

'*******************************************************************************
' RShift (FUNCTION)
'*******************************************************************************
Private Function RShift(ByVal lValue As Long, _
                        ByVal iShiftBits As Integer) As Long
    If iShiftBits = 0 Then
        RShift = lValue
        Exit Function
    ElseIf iShiftBits = 31 Then
        If lValue And &H80000000 Then
            RShift = 1
        Else
            RShift = 0
        End If
        Exit Function
    ElseIf iShiftBits < 0 Or iShiftBits > 31 Then
        Err.Raise 6
    End If
    
    RShift = (lValue And &H7FFFFFFE) \ m_l2Power(iShiftBits)
    
    If (lValue And &H80000000) Then
        RShift = (RShift Or (&H40000000 \ m_l2Power(iShiftBits - 1)))
    End If
End Function

'*******************************************************************************
' LShiftByte (FUNCTION)
'*******************************************************************************
Private Function LShiftByte(ByVal bytValue As Byte, _
                            ByVal bytShiftBits As Byte) As Byte
    If bytShiftBits = 0 Then
        LShiftByte = bytValue
        Exit Function
    ElseIf bytShiftBits = 7 Then
        If bytValue And 1 Then
            LShiftByte = &H80
        Else
            LShiftByte = 0
        End If
        Exit Function
    ElseIf bytShiftBits < 0 Or bytShiftBits > 7 Then
        Err.Raise 6
    End If
    
    LShiftByte = ((bytValue And m_bytOnBits(7 - bytShiftBits)) * _
        m_byt2Power(bytShiftBits))
End Function

'*******************************************************************************
' RShiftByte (FUNCTION)
'*******************************************************************************
Private Function RShiftByte(ByVal bytValue As Byte, _
                            ByVal bytShiftBits As Byte) As Byte
    If bytShiftBits = 0 Then
        RShiftByte = bytValue
        Exit Function
    ElseIf bytShiftBits = 7 Then
        If bytValue And &H80 Then
            RShiftByte = 1
        Else
            RShiftByte = 0
        End If
        Exit Function
    ElseIf bytShiftBits < 0 Or bytShiftBits > 7 Then
        Err.Raise 6
    End If
    
    RShiftByte = bytValue \ m_byt2Power(bytShiftBits)
End Function

'*******************************************************************************
' RotateLeft (FUNCTION)
'*******************************************************************************
Private Function RotateLeft(ByVal lValue As Long, _
                            ByVal iShiftBits As Integer) As Long
    RotateLeft = LShift(lValue, iShiftBits) Or RShift(lValue, (32 - iShiftBits))
End Function

''*******************************************************************************
'' RotateLeftByte (FUNCTION)
'*******************************************************************************
Private Function RotateLeftByte(ByVal bytValue As Byte, _
                                ByVal bytShiftBits As Byte) As Byte
    RotateLeftByte = LShiftByte(bytValue, bytShiftBits) Or _
        RShiftByte(bytValue, (8 - bytShiftBits))
End Function

'*******************************************************************************
' Pack (FUNCTION)
'*******************************************************************************
Private Function Pack(b() As Byte) As Long
    Dim lCount As Long
    Dim lTemp  As Long
    
    For lCount = 0 To 3
        lTemp = b(lCount)
        Pack = Pack Or LShift(lTemp, (lCount * 8))
    Next
End Function

'*******************************************************************************
' PackFrom (FUNCTION)
'*******************************************************************************
Private Function PackFrom(b() As Byte, _
                          ByVal K As Long) As Long
    Dim lCount As Long
    Dim lTemp  As Long
    
    For lCount = 0 To 3
        lTemp = b(lCount + K)
        PackFrom = PackFrom Or LShift(lTemp, (lCount * 8))
    Next
End Function

'*******************************************************************************
' Unpack (SUB)
'*******************************************************************************
Private Sub Unpack(ByVal a As Long, _
                   b() As Byte)
    b(0) = a And m_lOnBits(7)
    b(1) = RShift(a, 8) And m_lOnBits(7)
    b(2) = RShift(a, 16) And m_lOnBits(7)
    b(3) = RShift(a, 24) And m_lOnBits(7)
End Sub

'*******************************************************************************
' UnpackFrom (SUB)
'*******************************************************************************
Private Sub UnpackFrom(ByVal a As Long, _
                       b() As Byte, _
                       ByVal K As Long)
    b(0 + K) = a And m_lOnBits(7)
    b(1 + K) = RShift(a, 8) And m_lOnBits(7)
    b(2 + K) = RShift(a, 16) And m_lOnBits(7)
    b(3 + K) = RShift(a, 24) And m_lOnBits(7)
End Sub

'*******************************************************************************
' xtime (FUNCTION)
'*******************************************************************************
Private Function xtime(ByVal a As Byte) As Byte
    Dim b As Byte
    
    If (a And &H80) Then
        b = &H1B
    Else
        b = 0
    End If
    
    a = LShiftByte(a, 1)
    a = a Xor b
    
    xtime = a
End Function

'*******************************************************************************
' bmul (FUNCTION)
'*******************************************************************************
Private Function bmul(ByVal x As Byte, _
                      y As Byte) As Byte
    If x <> 0 And y <> 0 Then
        bmul = m_ptab((CLng(m_ltab(x)) + CLng(m_ltab(y))) Mod 255)
    Else
        bmul = 0
    End If
End Function

'*******************************************************************************
' SubByte (FUNCTION)
'*******************************************************************************
Private Function SubByte(ByVal a As Long) As Long
    Dim b(3) As Byte
    
    Unpack a, b
    b(0) = m_fbsub(b(0))
    b(1) = m_fbsub(b(1))
    b(2) = m_fbsub(b(2))
    b(3) = m_fbsub(b(3))
    
    SubByte = Pack(b)
End Function

'*******************************************************************************
' product (FUNCTION)
'*******************************************************************************
Private Function product(ByVal x As Long, _
                         ByVal y As Long) As Long
    Dim xb(3) As Byte
    Dim yb(3) As Byte
    
    Unpack x, xb
    Unpack y, yb
    product = bmul(xb(0), yb(0)) Xor bmul(xb(1), yb(1)) Xor bmul(xb(2), yb(2)) _
        Xor bmul(xb(3), yb(3))
End Function

'*******************************************************************************
' InvMixCol (FUNCTION)
'*******************************************************************************
Private Function InvMixCol(ByVal x As Long) As Long
    Dim y       As Long
    Dim m       As Long
    Dim b(3)    As Byte
    
    m = Pack(m_InCo)
    b(3) = product(m, x)
    m = RotateLeft(m, 24)
    b(2) = product(m, x)
    m = RotateLeft(m, 24)
    b(1) = product(m, x)
    m = RotateLeft(m, 24)
    b(0) = product(m, x)
    y = Pack(b)
    
    InvMixCol = y
End Function

'*******************************************************************************
' ByteSub (FUNCTION)
'*******************************************************************************
Private Function ByteSub(ByVal x As Byte) As Byte
    Dim y As Byte
    
    y = m_ptab(255 - m_ltab(x))
    x = y
    x = RotateLeftByte(x, 1)
    y = y Xor x
    x = RotateLeftByte(x, 1)
    y = y Xor x
    x = RotateLeftByte(x, 1)
    y = y Xor x
    x = RotateLeftByte(x, 1)
    y = y Xor x
    y = y Xor &H63
    
    ByteSub = y
End Function

'*******************************************************************************
' gentables (SUB)
'*******************************************************************************
Public Sub gentables()
    Dim i       As Long
    Dim y       As Byte
    Dim b(3)    As Byte
    Dim ib      As Byte
    
    m_ltab(0) = 0
    m_ptab(0) = 1
    m_ltab(1) = 0
    m_ptab(1) = 3
    m_ltab(3) = 1
    
    For i = 2 To 255
        m_ptab(i) = m_ptab(i - 1) Xor xtime(m_ptab(i - 1))
        m_ltab(m_ptab(i)) = i
    Next
    
    m_fbsub(0) = &H63
    m_rbsub(&H63) = 0
    
    For i = 1 To 255
        ib = i
        y = ByteSub(ib)
        m_fbsub(i) = y
        m_rbsub(y) = i
    Next
    
        y = 1
    For i = 0 To 29
        m_rco(i) = y
        y = xtime(y)
    Next
    
    For i = 0 To 255
        y = m_fbsub(i)
        b(3) = y Xor xtime(y)
        b(2) = y
        b(1) = y
        b(0) = xtime(y)
        m_ftable(i) = Pack(b)
        
        y = m_rbsub(i)
        b(3) = bmul(m_InCo(0), y)
        b(2) = bmul(m_InCo(1), y)
        b(1) = bmul(m_InCo(2), y)
        b(0) = bmul(m_InCo(3), y)
        m_rtable(i) = Pack(b)
    Next
End Sub

'*******************************************************************************
' gkey (SUB)
'*******************************************************************************
Public Sub gkey(ByVal nb As Long, _
                ByVal nk As Long, _
                key() As Byte)
                
    Dim i               As Long
    Dim J               As Long
    Dim K               As Long
    Dim m               As Long
    Dim N               As Long
    Dim C1              As Long
    Dim C2              As Long
    Dim C3              As Long
    Dim CipherKey(7)    As Long
    
    m_Nb = nb
    m_Nk = nk
    
    If m_Nb >= m_Nk Then
        m_Nr = 6 + m_Nb
    Else
        m_Nr = 6 + m_Nk
    End If
    
    C1 = 1
    If m_Nb < 8 Then
        C2 = 2
        C3 = 3
    Else
        C2 = 3
        C3 = 4
    End If
    
    For J = 0 To nb - 1
        m = J * 3
        
        m_fi(m) = (J + C1) Mod nb
        m_fi(m + 1) = (J + C2) Mod nb
        m_fi(m + 2) = (J + C3) Mod nb
        m_ri(m) = (nb + J - C1) Mod nb
        m_ri(m + 1) = (nb + J - C2) Mod nb
        m_ri(m + 2) = (nb + J - C3) Mod nb
    Next
    
    N = m_Nb * (m_Nr + 1)
    
    For i = 0 To m_Nk - 1
        J = i * 4
        CipherKey(i) = PackFrom(key, J)
    Next
    
    For i = 0 To m_Nk - 1
        m_fkey(i) = CipherKey(i)
    Next
    
    J = m_Nk
    K = 0
    Do While J < N
        m_fkey(J) = m_fkey(J - m_Nk) Xor _
            SubByte(RotateLeft(m_fkey(J - 1), 24)) Xor m_rco(K)
        If m_Nk <= 6 Then
            i = 1
            Do While i < m_Nk And (i + J) < N
                m_fkey(i + J) = m_fkey(i + J - m_Nk) Xor _
                    m_fkey(i + J - 1)
                i = i + 1
            Loop
        Else
            ' Problem fixed here
            i = 1
            Do While i < 4 And (i + J) < N
                m_fkey(i + J) = m_fkey(i + J - m_Nk) Xor _
                    m_fkey(i + J - 1)
                i = i + 1
            Loop
            If J + 4 < N Then
                m_fkey(J + 4) = m_fkey(J + 4 - m_Nk) Xor _
                    SubByte(m_fkey(J + 3))
            End If
            i = 5
            Do While i < m_Nk And (i + J) < N
                m_fkey(i + J) = m_fkey(i + J - m_Nk) Xor _
                    m_fkey(i + J - 1)
                i = i + 1
            Loop
        End If
        
        J = J + m_Nk
        K = K + 1
    Loop
    
    For J = 0 To m_Nb - 1
        m_rkey(J + N - nb) = m_fkey(J)
    Next
    
    i = m_Nb
    Do While i < N - m_Nb
        K = N - m_Nb - i
        For J = 0 To m_Nb - 1
            m_rkey(K + J) = InvMixCol(m_fkey(i + J))
        Next
        i = i + m_Nb
    Loop
    
    J = N - m_Nb
    Do While J < N
        m_rkey(J - N + m_Nb) = m_fkey(J)
        J = J + 1
    Loop
End Sub

'*******************************************************************************
' encrypt (SUB)
'*******************************************************************************
Public Sub Encrypt(buff() As Byte)
    Dim i       As Long
    Dim J       As Long
    Dim K       As Long
    Dim m       As Long
    Dim a(7)    As Long
    Dim b(7)    As Long
    Dim x()     As Long
    Dim y()     As Long
    Dim t()     As Long
    
    For i = 0 To m_Nb - 1
        J = i * 4
        
        a(i) = PackFrom(buff, J)
        a(i) = a(i) Xor m_fkey(i)
    Next
    
    K = m_Nb
    x = a
    y = b
    
    For i = 1 To m_Nr - 1
        For J = 0 To m_Nb - 1
            m = J * 3
            y(J) = m_fkey(K) Xor m_ftable(x(J) And m_lOnBits(7)) Xor _
                RotateLeft(m_ftable(RShift(x(m_fi(m)), 8) And m_lOnBits(7)), 8) Xor _
                RotateLeft(m_ftable(RShift(x(m_fi(m + 1)), 16) And m_lOnBits(7)), 16) Xor _
                RotateLeft(m_ftable(RShift(x(m_fi(m + 2)), 24) And m_lOnBits(7)), 24)
            K = K + 1
        Next
        t = x
        x = y
        y = t
    Next
    
    For J = 0 To m_Nb - 1
        m = J * 3
        y(J) = m_fkey(K) Xor m_fbsub(x(J) And m_lOnBits(7)) Xor _
            RotateLeft(m_fbsub(RShift(x(m_fi(m)), 8) And m_lOnBits(7)), 8) Xor _
            RotateLeft(m_fbsub(RShift(x(m_fi(m + 1)), 16) And m_lOnBits(7)), 16) Xor _
            RotateLeft(m_fbsub(RShift(x(m_fi(m + 2)), 24) And m_lOnBits(7)), 24)
        K = K + 1
    Next
    
    For i = 0 To m_Nb - 1
        J = i * 4
        UnpackFrom y(i), buff, J
        x(i) = 0
        y(i) = 0
    Next
End Sub

'*******************************************************************************
' decrypt (SUB)
'*******************************************************************************
Public Sub Decrypt(buff() As Byte)
    Dim i As Long
    Dim J As Long
    Dim K As Long
    Dim m As Long
    Dim a(7) As Long
    Dim b(7) As Long
    Dim x() As Long
    Dim y() As Long
    Dim t() As Long
    
    For i = 0 To m_Nb - 1
        J = i * 4
        a(i) = PackFrom(buff, J)
        a(i) = a(i) Xor m_rkey(i)
    Next
    
    K = m_Nb
    x = a
    y = b
    
    For i = 1 To m_Nr - 1
        For J = 0 To m_Nb - 1
            m = J * 3
            y(J) = m_rkey(K) Xor m_rtable(x(J) And m_lOnBits(7)) Xor _
                RotateLeft(m_rtable(RShift(x(m_ri(m)), 8) And m_lOnBits(7)), 8) Xor _
                RotateLeft(m_rtable(RShift(x(m_ri(m + 1)), 16) And m_lOnBits(7)), 16) Xor _
                RotateLeft(m_rtable(RShift(x(m_ri(m + 2)), 24) And m_lOnBits(7)), 24)
            K = K + 1
        Next
        t = x
        x = y
        y = t
    Next
    
    For J = 0 To m_Nb - 1
        m = J * 3
        
        y(J) = m_rkey(K) Xor m_rbsub(x(J) And m_lOnBits(7)) Xor _
            RotateLeft(m_rbsub(RShift(x(m_ri(m)), 8) And m_lOnBits(7)), 8) Xor _
            RotateLeft(m_rbsub(RShift(x(m_ri(m + 1)), 16) And m_lOnBits(7)), 16) Xor _
            RotateLeft(m_rbsub(RShift(x(m_ri(m + 2)), 24) And m_lOnBits(7)), 24)
        K = K + 1
    Next
    
    For i = 0 To m_Nb - 1
        J = i * 4
        
        UnpackFrom y(i), buff, J
        x(i) = 0
        y(i) = 0
    Next
End Sub

''*******************************************************************************
'' CopyBytesASP (SUB)
''
'' Slower non-API function you can use to copy array data
''*******************************************************************************
'Private Sub CopyBytesASP(bytDest() As Byte, _
'                         lDestStart As Long, _
'                         bytSource() As Byte, _
'                         lSourceStart As Long, _
'                         lLength As Long)
'    Dim lCount As Long
'
'    lCount = 0
'    Do
'        bytDest(lDestStart + lCount) = bytSource(lSourceStart + lCount)
'        lCount = lCount + 1
'    Loop Until lCount = lLength
'End Sub

'*******************************************************************************
' IsInitialized (FUNCTION)
'*******************************************************************************
Private Function IsInitialized(ByRef vArray As Variant) As Boolean
    On Error Resume Next
    
    IsInitialized = IsNumeric(UBound(vArray))
End Function

'*******************************************************************************
' EncryptData (FUNCTION)
'
' Takes the message, whatever the size, and password in one call and does
' everything for you to return an encoded/encrypted message
'*******************************************************************************
Public Function EncryptData(bytMessage() As Byte, _
                            bytPassword() As Byte) As Byte()
    Dim bytKey(31)      As Byte
    Dim bytIn()         As Byte
    Dim bytOut()        As Byte
    Dim bytTemp(31)     As Byte
    Dim lCount          As Long
    Dim lLength         As Long
    Dim lEncodedLength  As Long
    Dim bytLen(3)       As Byte
    Dim lPosition       As Long
    
    If Not IsInitialized(bytMessage) Then
        Exit Function
    End If
    If Not IsInitialized(bytPassword) Then
        Exit Function
    End If
    
    ' Use first 32 bytes of the password for the key
    For lCount = 0 To UBound(bytPassword)
        bytKey(lCount) = bytPassword(lCount)
        If lCount = 31 Then
            Exit For
        End If
    Next
    
    ' Prepare the key; assume 256 bit block and key size
    gentables
    gkey 8, 8, bytKey
    
    ' We are going to put the message size on the front of the message
    ' in the first 4 bytes. If the length is more than a max int we are
    ' in trouble
    lLength = UBound(bytMessage) + 1
    lEncodedLength = lLength + 4
    
    ' The encoded length includes the 4 bytes stuffed on the front
    ' and is padded out to be modulus 32
    If lEncodedLength Mod 32 <> 0 Then
        lEncodedLength = lEncodedLength + 32 - (lEncodedLength Mod 32)
    End If
    ReDim bytIn(lEncodedLength - 1)
    ReDim bytOut(lEncodedLength - 1)
    
    ' Put the length on the front
    '* Unpack lLength, bytIn
    CopyMemory VarPtr(bytIn(0)), VarPtr(lLength), 4
    ' Put the rest of the message after it
    '* CopyBytesASP bytIn, 4, bytMessage, 0, lLength
    CopyMemory VarPtr(bytIn(4)), VarPtr(bytMessage(0)), lLength

    ' Encrypt a block at a time
    For lCount = 0 To lEncodedLength - 1 Step 32
        '* CopyBytesASP bytTemp, 0, bytIn, lCount, 32
        CopyMemory VarPtr(bytTemp(0)), VarPtr(bytIn(lCount)), 32
        Encrypt bytTemp
        '* CopyBytesASP bytOut, lCount, bytTemp, 0, 32
        CopyMemory VarPtr(bytOut(lCount)), VarPtr(bytTemp(0)), 32
    Next
    
    EncryptData = bytOut
End Function

'*******************************************************************************
' DecryptData (FUNCTION)
'
' Opposite of Encryptdata
'*******************************************************************************
Public Function DecryptData(bytIn() As Byte, _
                            bytPassword() As Byte) As Byte()
    Dim bytMessage()    As Byte
    Dim bytKey(31)      As Byte
    Dim bytOut()        As Byte
    Dim bytTemp(31)     As Byte
    Dim lCount          As Long
    Dim lLength         As Long
    Dim lEncodedLength  As Long
    Dim bytLen(3)       As Byte
    Dim lPosition       As Long
    
    If Not IsInitialized(bytIn) Then
        Exit Function
    End If
    If Not IsInitialized(bytPassword) Then
        Exit Function
    End If
    
    lEncodedLength = UBound(bytIn) + 1
    
    If lEncodedLength Mod 32 <> 0 Then
        Exit Function
    End If
    
    ' Use first 32 bytes of the password for the key
    For lCount = 0 To UBound(bytPassword)
        bytKey(lCount) = bytPassword(lCount)
        If lCount = 31 Then
            Exit For
        End If
    Next
    
    ' Prepare the key; assume 256 bit block and key size
    gentables
    gkey 8, 8, bytKey

    ' The output array needs to be the same size as the input array
    ReDim bytOut(lEncodedLength - 1)
    
    ' Decrypt a block at a time
    For lCount = 0 To lEncodedLength - 1 Step 32
        '* CopyBytesASP bytTemp, 0, bytIn, lCount, 32
        CopyMemory VarPtr(bytTemp(0)), VarPtr(bytIn(lCount)), 32
        Decrypt bytTemp
        '* CopyBytesASP bytOut, lCount, bytTemp, 0, 32
        CopyMemory VarPtr(bytOut(lCount)), VarPtr(bytTemp(0)), 32
    Next

    ' Get the original length of the string from the first 4 bytes
    '* lLength = Pack(bytOut)
    CopyMemory VarPtr(lLength), VarPtr(bytOut(0)), 4
    
    ' Make sure the length is consistent with our data
    If lLength > lEncodedLength - 4 Then
        Exit Function
    End If
    
    ' Prepare the output message byte array
    ReDim bytMessage(lLength - 1)
    '* CopyBytesASP bytMessage, 0, bytOut, 4, lLength
    CopyMemory VarPtr(bytMessage(0)), VarPtr(bytOut(4)), lLength
    
    DecryptData = bytMessage
End Function
Attribute VB_Name = "CSHA256"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
' Added for MWS Integration
' Abhijit Tambe, July 2010

'*******************************************************************************
' MODULE:       CSHA256
' FILENAME:     CSHA256.cls
' AUTHOR:       Phil Fresle
' CREATED:      10-Apr-2001
' COPYRIGHT:    Copyright 2001 Phil Fresle. All Rights Reserved.
'
' DESCRIPTION:
' This class is used to generate a SHA-256 'digest' or 'signature' of a string.
' The SHA-256 algorithm is one of the industry standard methods for generating
' digital signatures. It is generically known as a digest, digital signature,
' one-way encryption, hash or checksum algorithm. A common use for SHA-256 is
' for password encryption as it is one-way in nature, that does not mean that
' your passwords are not free from a dictionary attack. If you are using the
' routine for passwords, you can make it a little more secure by concatenating
' some known random characters to the password before you generate the signature
' and on subsequent tests, so even if a hacker knows you are using SHA-256 for
' your passwords, the random characters will make it harder to dictionary attack.
'
' *** CAUTION ***
' See the comment attached to the SHA256 method below regarding use on systems
' with different character sets.
'
' This is 'free' software with the following restrictions:
'
' You may not redistribute this code as a 'sample' or 'demo'. However, you are free
' to use the source code in your own code, but you may not claim that you created
' the sample code. It is expressly forbidden to sell or profit from this source code
' other than by the knowledge gained or the enhanced value added by your own code.
'
' Use of this software is also done so at your own risk. The code is supplied as
' is without warranty or guarantee of any kind.
'
' Should you wish to commission some derivative work based on this code provided
' here, or any consultancy work, please do not hesitate to contact us.
'
' Web Site:  http://www.frez.co.uk
' E-mail:    sales@frez.co.uk
'
' MODIFICATION HISTORY:
' 10-Apr-2001   Phil Fresle     Initial Version
'*******************************************************************************
Option Explicit

Private m_lOnBits(30)   As Long
Private m_l2Power(30)   As Long
Private K(63)           As Long

Private Const BITS_TO_A_BYTE  As Long = 8
Private Const BYTES_TO_A_WORD As Long = 4
Private Const BITS_TO_A_WORD  As Long = BYTES_TO_A_WORD * BITS_TO_A_BYTE

'*******************************************************************************
' Class_Initialize (SUB)
'*******************************************************************************
Private Sub Class_Initialize()
    ' Could have done this with a loop calculating each value, but simply
    ' assigning the values is quicker - BITS SET FROM RIGHT
    m_lOnBits(0) = 1            ' 00000000000000000000000000000001
    m_lOnBits(1) = 3            ' 00000000000000000000000000000011
    m_lOnBits(2) = 7            ' 00000000000000000000000000000111
    m_lOnBits(3) = 15           ' 00000000000000000000000000001111
    m_lOnBits(4) = 31           ' 00000000000000000000000000011111
    m_lOnBits(5) = 63           ' 00000000000000000000000000111111
    m_lOnBits(6) = 127          ' 00000000000000000000000001111111
    m_lOnBits(7) = 255          ' 00000000000000000000000011111111
    m_lOnBits(8) = 511          ' 00000000000000000000000111111111
    m_lOnBits(9) = 1023         ' 00000000000000000000001111111111
    m_lOnBits(10) = 2047        ' 00000000000000000000011111111111
    m_lOnBits(11) = 4095        ' 00000000000000000000111111111111
    m_lOnBits(12) = 8191        ' 00000000000000000001111111111111
    m_lOnBits(13) = 16383       ' 00000000000000000011111111111111
    m_lOnBits(14) = 32767       ' 00000000000000000111111111111111
    m_lOnBits(15) = 65535       ' 00000000000000001111111111111111
    m_lOnBits(16) = 131071      ' 00000000000000011111111111111111
    m_lOnBits(17) = 262143      ' 00000000000000111111111111111111
    m_lOnBits(18) = 524287      ' 00000000000001111111111111111111
    m_lOnBits(19) = 1048575     ' 00000000000011111111111111111111
    m_lOnBits(20) = 2097151     ' 00000000000111111111111111111111
    m_lOnBits(21) = 4194303     ' 00000000001111111111111111111111
    m_lOnBits(22) = 8388607     ' 00000000011111111111111111111111
    m_lOnBits(23) = 16777215    ' 00000000111111111111111111111111
    m_lOnBits(24) = 33554431    ' 00000001111111111111111111111111
    m_lOnBits(25) = 67108863    ' 00000011111111111111111111111111
    m_lOnBits(26) = 134217727   ' 00000111111111111111111111111111
    m_lOnBits(27) = 268435455   ' 00001111111111111111111111111111
    m_lOnBits(28) = 536870911   ' 00011111111111111111111111111111
    m_lOnBits(29) = 1073741823  ' 00111111111111111111111111111111
    m_lOnBits(30) = 2147483647  ' 01111111111111111111111111111111
    
    ' Could have done this with a loop calculating each value, but simply
    ' assigning the values is quicker - POWERS OF 2
    m_l2Power(0) = 1            ' 00000000000000000000000000000001
    m_l2Power(1) = 2            ' 00000000000000000000000000000010
    m_l2Power(2) = 4            ' 00000000000000000000000000000100
    m_l2Power(3) = 8            ' 00000000000000000000000000001000
    m_l2Power(4) = 16           ' 00000000000000000000000000010000
    m_l2Power(5) = 32           ' 00000000000000000000000000100000
    m_l2Power(6) = 64           ' 00000000000000000000000001000000
    m_l2Power(7) = 128          ' 00000000000000000000000010000000
    m_l2Power(8) = 256          ' 00000000000000000000000100000000
    m_l2Power(9) = 512          ' 00000000000000000000001000000000
    m_l2Power(10) = 1024        ' 00000000000000000000010000000000
    m_l2Power(11) = 2048        ' 00000000000000000000100000000000
    m_l2Power(12) = 4096        ' 00000000000000000001000000000000
    m_l2Power(13) = 8192        ' 00000000000000000010000000000000
    m_l2Power(14) = 16384       ' 00000000000000000100000000000000
    m_l2Power(15) = 32768       ' 00000000000000001000000000000000
    m_l2Power(16) = 65536       ' 00000000000000010000000000000000
    m_l2Power(17) = 131072      ' 00000000000000100000000000000000
    m_l2Power(18) = 262144      ' 00000000000001000000000000000000
    m_l2Power(19) = 524288      ' 00000000000010000000000000000000
    m_l2Power(20) = 1048576     ' 00000000000100000000000000000000
    m_l2Power(21) = 2097152     ' 00000000001000000000000000000000
    m_l2Power(22) = 4194304     ' 00000000010000000000000000000000
    m_l2Power(23) = 8388608     ' 00000000100000000000000000000000
    m_l2Power(24) = 16777216    ' 00000001000000000000000000000000
    m_l2Power(25) = 33554432    ' 00000010000000000000000000000000
    m_l2Power(26) = 67108864    ' 00000100000000000000000000000000
    m_l2Power(27) = 134217728   ' 00001000000000000000000000000000
    m_l2Power(28) = 268435456   ' 00010000000000000000000000000000
    m_l2Power(29) = 536870912   ' 00100000000000000000000000000000
    m_l2Power(30) = 1073741824  ' 01000000000000000000000000000000
    
    ' Just put together the K array once
    K(0) = &H428A2F98
    K(1) = &H71374491
    K(2) = &HB5C0FBCF
    K(3) = &HE9B5DBA5
    K(4) = &H3956C25B
    K(5) = &H59F111F1
    K(6) = &H923F82A4
    K(7) = &HAB1C5ED5
    K(8) = &HD807AA98
    K(9) = &H12835B01
    K(10) = &H243185BE
    K(11) = &H550C7DC3
    K(12) = &H72BE5D74
    K(13) = &H80DEB1FE
    K(14) = &H9BDC06A7
    K(15) = &HC19BF174
    K(16) = &HE49B69C1
    K(17) = &HEFBE4786
    K(18) = &HFC19DC6
    K(19) = &H240CA1CC
    K(20) = &H2DE92C6F
    K(21) = &H4A7484AA
    K(22) = &H5CB0A9DC
    K(23) = &H76F988DA
    K(24) = &H983E5152
    K(25) = &HA831C66D
    K(26) = &HB00327C8
    K(27) = &HBF597FC7
    K(28) = &HC6E00BF3
    K(29) = &HD5A79147
    K(30) = &H6CA6351
    K(31) = &H14292967
    K(32) = &H27B70A85
    K(33) = &H2E1B2138
    K(34) = &H4D2C6DFC
    K(35) = &H53380D13
    K(36) = &H650A7354
    K(37) = &H766A0ABB
    K(38) = &H81C2C92E
    K(39) = &H92722C85
    K(40) = &HA2BFE8A1
    K(41) = &HA81A664B
    K(42) = &HC24B8B70
    K(43) = &HC76C51A3
    K(44) = &HD192E819
    K(45) = &HD6990624
    K(46) = &HF40E3585
    K(47) = &H106AA070
    K(48) = &H19A4C116
    K(49) = &H1E376C08
    K(50) = &H2748774C
    K(51) = &H34B0BCB5
    K(52) = &H391C0CB3
    K(53) = &H4ED8AA4A
    K(54) = &H5B9CCA4F
    K(55) = &H682E6FF3
    K(56) = &H748F82EE
    K(57) = &H78A5636F
    K(58) = &H84C87814
    K(59) = &H8CC70208
    K(60) = &H90BEFFFA
    K(61) = &HA4506CEB
    K(62) = &HBEF9A3F7
    K(63) = &HC67178F2
End Sub

'*******************************************************************************
' LShift (FUNCTION)
'
' PARAMETERS:
' (In) - lValue     - Long    - The value to be shifted
' (In) - iShiftBits - Integer - The number of bits to shift the value by
'
' RETURN VALUE:
' Long - The shifted long integer
'
' DESCRIPTION:
' A left shift takes all the set binary bits and moves them left, in-filling
' with zeros in the vacated bits on the right. This function is equivalent to
' the << operator in Java and C++
'*******************************************************************************
Private Function LShift(ByVal lValue As Long, _
                        ByVal iShiftBits As Integer) As Long
    ' NOTE: If you can guarantee that the Shift parameter will be in the
    ' range 1 to 30 you can safely strip of this first nested if structure for
    ' speed.
    '
    ' A shift of zero is no shift at all.
    If iShiftBits = 0 Then
        LShift = lValue
        Exit Function
        
    ' A shift of 31 will result in the right most bit becoming the left most
    ' bit and all other bits being cleared
    ElseIf iShiftBits = 31 Then
        If lValue And 1 Then
            LShift = &H80000000
        Else
            LShift = 0
        End If
        Exit Function
        
    ' A shift of less than zero or more than 31 is undefined
    ElseIf iShiftBits < 0 Or iShiftBits > 31 Then
        Err.Raise 6
    End If
    
    ' If the left most bit that remains will end up in the negative bit
    ' position (&H80000000) we would end up with an overflow if we took the
    ' standard route. We need to strip the left most bit and add it back
    ' afterwards.
    If (lValue And m_l2Power(31 - iShiftBits)) Then
    
        ' (Value And OnBits(31 - (Shift + 1))) chops off the left most bits that
        ' we are shifting into, but also the left most bit we still want as this
        ' is going to end up in the negative bit marker position (&H80000000).
        ' After the multiplication/shift we Or the result with &H80000000 to
        ' turn the negative bit on.
        LShift = ((lValue And m_lOnBits(31 - (iShiftBits + 1))) * _
            m_l2Power(iShiftBits)) Or &H80000000
    
    Else
    
        ' (Value And OnBits(31-Shift)) chops off the left most bits that we are
        ' shifting into so we do not get an overflow error when we do the
        ' multiplication/shift
        LShift = ((lValue And m_lOnBits(31 - iShiftBits)) * _
            m_l2Power(iShiftBits))
        
    End If
End Function

'*******************************************************************************
' RShift (FUNCTION)
'
' PARAMETERS:
' (In) - lValue     - Long    - The value to be shifted
' (In) - iShiftBits - Integer - The number of bits to shift the value by
'
' RETURN VALUE:
' Long - The shifted long integer
'
' DESCRIPTION:
' The right shift of an unsigned long integer involves shifting all the set bits
' to the right and in-filling on the left with zeros. This function is
' equivalent to the >>> operator in Java or the >> operator in C++ when used on
' an unsigned long.
'*******************************************************************************
Private Function RShift(ByVal lValue As Long, _
                        ByVal iShiftBits As Integer) As Long
    
    ' NOTE: If you can guarantee that the Shift parameter will be in the
    ' range 1 to 30 you can safely strip of this first nested if structure for
    ' speed.
    '
    ' A shift of zero is no shift at all
    If iShiftBits = 0 Then
        RShift = lValue
        Exit Function
        
    ' A shift of 31 will clear all bits and move the left most bit to the right
    ' most bit position
    ElseIf iShiftBits = 31 Then
        If lValue And &H80000000 Then
            RShift = 1
        Else
            RShift = 0
        End If
        Exit Function
        
    ' A shift of less than zero or more than 31 is undefined
    ElseIf iShiftBits < 0 Or iShiftBits > 31 Then
        Err.Raise 6
    End If
    
    ' We do not care about the top most bit or the final bit, the top most bit
    ' will be taken into account in the next stage, the final bit (whether it
    ' is an odd number or not) is being shifted into, so we do not give a jot
    ' about it
    RShift = (lValue And &H7FFFFFFE) \ m_l2Power(iShiftBits)
    
    ' If the top most bit (&H80000000) was set we need to do things differently
    ' as in a normal VB signed long integer the top most bit is used to indicate
    ' the sign of the number, when it is set it is a negative number, so just
    ' deviding by a factor of 2 as above would not work.
    ' NOTE: (lValue And  &H80000000) is equivalent to (lValue < 0), you could
    ' get a very marginal speed improvement by changing the test to (lValue < 0)
    If (lValue And &H80000000) Then
        ' We take the value computed so far, and then add the left most negative
        ' bit after it has been shifted to the right the appropriate number of
        ' places
        RShift = (RShift Or (&H40000000 \ m_l2Power(iShiftBits - 1)))
    End If
End Function

'*******************************************************************************
' AddUnsigned (FUNCTION)
'
' PARAMETERS:
' (In) - lX - Long - First value
' (In) - lY - Long - Second value
'
' RETURN VALUE:
' Long - Result
'
' DESCRIPTION:
' Adds two potentially large unsigned numbers without overflowing
'*******************************************************************************
Private Function AddUnsigned(ByVal lX As Long, _
                             ByVal lY As Long) As Long
    Dim lX4     As Long
    Dim lY4     As Long
    Dim lX8     As Long
    Dim lY8     As Long
    Dim lResult As Long
 
    lX8 = lX And &H80000000
    lY8 = lY And &H80000000
    lX4 = lX And &H40000000
    lY4 = lY And &H40000000
 
    lResult = (lX And &H3FFFFFFF) + (lY And &H3FFFFFFF)
 
    If lX4 And lY4 Then
        lResult = lResult Xor &H80000000 Xor lX8 Xor lY8
    ElseIf lX4 Or lY4 Then
        If lResult And &H40000000 Then
            lResult = lResult Xor &HC0000000 Xor lX8 Xor lY8
        Else
            lResult = lResult Xor &H40000000 Xor lX8 Xor lY8
        End If
    Else
        lResult = lResult Xor lX8 Xor lY8
    End If
 
    AddUnsigned = lResult
End Function

'*******************************************************************************
' Ch (FUNCTION)
'
' DESCRIPTION:
' SHA-256 function
'*******************************************************************************
Private Function Ch(ByVal x As Long, _
                    ByVal y As Long, _
                    ByVal z As Long) As Long
    Ch = ((x And y) Xor ((Not x) And z))
End Function

'*******************************************************************************
' Maj (FUNCTION)
'
' DESCRIPTION:
' SHA-256 function
'*******************************************************************************
Private Function Maj(ByVal x As Long, _
                     ByVal y As Long, _
                     ByVal z As Long) As Long
    Maj = ((x And y) Xor (x And z) Xor (y And z))
End Function

'*******************************************************************************
' S (FUNCTION)
'
' DESCRIPTION:
' SHA-256 function (rotate right)
'*******************************************************************************
Private Function s(ByVal x As Long, _
                   ByVal N As Long) As Long
    s = (RShift(x, (N And m_lOnBits(4))) Or LShift(x, (32 - (N And m_lOnBits(4)))))
End Function

'*******************************************************************************
' R (FUNCTION)
'
' DESCRIPTION:
' SHA-256 function (just a right shift)
'*******************************************************************************
Private Function R(ByVal x As Long, _
                   ByVal N As Long) As Long
    R = RShift(x, CInt(N And m_lOnBits(4)))
End Function

'*******************************************************************************
' Sigma0 (FUNCTION)
'
' DESCRIPTION:
' SHA-256 function
'*******************************************************************************
Private Function Sigma0(ByVal x As Long) As Long
    Sigma0 = (s(x, 2) Xor s(x, 13) Xor s(x, 22))
End Function

'*******************************************************************************
' Sigma1 (FUNCTION)
'
' DESCRIPTION:
' SHA-256 function
'*******************************************************************************
Private Function Sigma1(ByVal x As Long) As Long
    Sigma1 = (s(x, 6) Xor s(x, 11) Xor s(x, 25))
End Function

'*******************************************************************************
' Gamma0 (FUNCTION)
'
' DESCRIPTION:
' SHA-256 function
'*******************************************************************************
Private Function Gamma0(ByVal x As Long) As Long
    Gamma0 = (s(x, 7) Xor s(x, 18) Xor R(x, 3))
End Function

'*******************************************************************************
' Gamma1 (FUNCTION)
'
' DESCRIPTION:
' SHA-256 function
'*******************************************************************************
Private Function Gamma1(ByVal x As Long) As Long
    Gamma1 = (s(x, 17) Xor s(x, 19) Xor R(x, 10))
End Function

'*******************************************************************************
' ConvertToWordArray (FUNCTION)
'
' PARAMETERS:
' (In/Out) - sMessage - String - String message
'
' RETURN VALUE:
' Long() - Converted message as long array
'
' DESCRIPTION:
' Takes the string message and puts it in a long array with padding according to
' the SHA-256 rules (similar to MD5 routine).
'*******************************************************************************
Private Function ConvertToWordArray(sMessage As String) As Long()
    Dim lMessageLength  As Long
    Dim lNumberOfWords  As Long
    Dim lWordArray()    As Long
    Dim lBytePosition   As Long
    Dim lByteCount      As Long
    Dim lWordCount      As Long
    Dim lByte           As Long
    
    Const MODULUS_BITS      As Long = 512
    Const CONGRUENT_BITS    As Long = 448
    
    lMessageLength = Len(sMessage)
    
    ' Get padded number of words. Message needs to be congruent to 448 bits,
    ' modulo 512 bits. If it is exactly congruent to 448 bits, modulo 512 bits
    ' it must still have another 512 bits added. 512 bits = 64 bytes
    ' (or 16 * 4 byte words), 448 bits = 56 bytes. This means lNumberOfWords must
    ' be a multiple of 16 (i.e. 16 * 4 (bytes) * 8 (bits))
    lNumberOfWords = (((lMessageLength + _
        ((MODULUS_BITS - CONGRUENT_BITS) \ BITS_TO_A_BYTE)) \ _
        (MODULUS_BITS \ BITS_TO_A_BYTE)) + 1) * _
        (MODULUS_BITS \ BITS_TO_A_WORD)
    ReDim lWordArray(lNumberOfWords - 1)
    
    ' Combine each block of 4 bytes (ascii code of character) into one long
    ' value and store in the message. The high-order (most significant) bit of
    ' each byte is listed first. However, unlike MD5 we put the high-order
    ' (most significant) byte first in each word.
    lBytePosition = 0
    lByteCount = 0
    Do Until lByteCount >= lMessageLength
        ' Each word is 4 bytes
        lWordCount = lByteCount \ BYTES_TO_A_WORD
        
        lBytePosition = (3 - (lByteCount Mod BYTES_TO_A_WORD)) * BITS_TO_A_BYTE
        
        ' NOTE: This is where we are using just the first byte of each unicode
        ' character, you may want to make the change here, or to the SHA256 method
        ' so it accepts a byte array.
        
'        lByte = AscB(Mid(sMessage, lByteCount + 1, 1)) 'http://developer.amazonwebservices.com/connect/thread.jspa?threadID=33204&start=15&tstart=0
        lByte = Asc(Mid(sMessage, lByteCount + 1, 1)) 'http://developer.amazonwebservices.com/connect/thread.jspa?threadID=33204&start=15&tstart=0
        
        lWordArray(lWordCount) = lWordArray(lWordCount) Or LShift(lByte, lBytePosition)
        lByteCount = lByteCount + 1
    Loop

    ' Terminate according to SHA-256 rules with a 1 bit, zeros and the length in
    ' bits stored in the last two words
    lWordCount = lByteCount \ BYTES_TO_A_WORD
    lBytePosition = (3 - (lByteCount Mod BYTES_TO_A_WORD)) * BITS_TO_A_BYTE

    ' Add a terminating 1 bit, all the rest of the bits to the end of the
    ' word array will default to zero
    lWordArray(lWordCount) = lWordArray(lWordCount) Or _
        LShift(&H80, lBytePosition)

    ' We put the length of the message in bits into the last two words, to get
    ' the length in bits we need to multiply by 8 (or left shift 3). This left
    ' shifted value is put in the last word. Any bits shifted off the left edge
    ' need to be put in the penultimate word, we can work out which bits by shifting
    ' right the length by 29 bits.
    lWordArray(lNumberOfWords - 1) = LShift(lMessageLength, 3)
    lWordArray(lNumberOfWords - 2) = RShift(lMessageLength, 29)
    
    ConvertToWordArray = lWordArray
End Function

'*******************************************************************************
' SHA256 (FUNCTION)
'
' PARAMETERS:
' (In/Out) - sMessage - String - Message to digest
'
' RETURN VALUE:
' String - The digest
'
' DESCRIPTION:
' Takes a string and uses the SHA-256 digest to produce a signature for it.
'
' NOTE: Due to the way in which the string is processed the routine assumes a
' single byte character set. VB passes unicode (2-byte) character strings, the
' ConvertToWordArray function uses on the first byte for each character. This
' has been done this way for ease of use, to make the routine truely portable
' you could accept a byte array instead, it would then be up to the calling
' routine to make sure that the byte array is generated from their string in
' a manner consistent with the string type.
'*******************************************************************************
Public Function SHA256(sMessage As String) As String
    Dim HASH(7) As Long
    Dim m()     As Long
    Dim w(63)   As Long
    Dim a       As Long
    Dim b       As Long
    Dim c       As Long
    Dim d       As Long
    Dim e       As Long
    Dim F       As Long
    Dim G       As Long
    Dim H       As Long
    Dim i       As Long
    Dim J       As Long
    Dim T1      As Long
    Dim T2      As Long
    
    ' Initial hash values
    HASH(0) = &H6A09E667
    HASH(1) = &HBB67AE85
    HASH(2) = &H3C6EF372
    HASH(3) = &HA54FF53A
    HASH(4) = &H510E527F
    HASH(5) = &H9B05688C
    HASH(6) = &H1F83D9AB
    HASH(7) = &H5BE0CD19
    
    ' Preprocessing. Append padding bits and length and convert to words
    m = ConvertToWordArray(sMessage)
    
    ' Main loop
    For i = 0 To UBound(m) Step 16
        a = HASH(0)
        b = HASH(1)
        c = HASH(2)
        d = HASH(3)
        e = HASH(4)
        F = HASH(5)
        G = HASH(6)
        H = HASH(7)
        
        For J = 0 To 63
            If J < 16 Then
                w(J) = m(J + i)
            Else
                w(J) = AddUnsigned(AddUnsigned(AddUnsigned(Gamma1(w(J - 2)), _
                    w(J - 7)), Gamma0(w(J - 15))), w(J - 16))
            End If
                
            T1 = AddUnsigned(AddUnsigned(AddUnsigned(AddUnsigned(H, Sigma1(e)), _
                Ch(e, F, G)), K(J)), w(J))
            T2 = AddUnsigned(Sigma0(a), Maj(a, b, c))
            
            H = G
            G = F
            F = e
            e = AddUnsigned(d, T1)
            d = c
            c = b
            b = a
            a = AddUnsigned(T1, T2)
        Next
        
        HASH(0) = AddUnsigned(a, HASH(0))
        HASH(1) = AddUnsigned(b, HASH(1))
        HASH(2) = AddUnsigned(c, HASH(2))
        HASH(3) = AddUnsigned(d, HASH(3))
        HASH(4) = AddUnsigned(e, HASH(4))
        HASH(5) = AddUnsigned(F, HASH(5))
        HASH(6) = AddUnsigned(G, HASH(6))
        HASH(7) = AddUnsigned(H, HASH(7))
    Next
    
    ' Output the 256 bit digest
    SHA256 = LCase(Right("00000000" & Hex(HASH(0)), 8) & _
        Right("00000000" & Hex(HASH(1)), 8) & _
        Right("00000000" & Hex(HASH(2)), 8) & _
        Right("00000000" & Hex(HASH(3)), 8) & _
        Right("00000000" & Hex(HASH(4)), 8) & _
        Right("00000000" & Hex(HASH(5)), 8) & _
        Right("00000000" & Hex(HASH(6)), 8) & _
        Right("00000000" & Hex(HASH(7)), 8))
End Function


Attribute VB_Name = "ImageDisplay"
Attribute VB_Base = "0{44086C6E-DE42-4EA3-946C-683E8FDC0793}{C72F2B68-F3B9-4DEB-8089-C24C29C0D5B4}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Public TargetRow As Integer
Public TargetCol As Integer


Private Sub UserForm_Initialize()
    ' added 10/12/10 by atambe
    TranslateFormControls Me
End Sub
Attribute VB_Name = "MD5"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
' Modified for MWS Integration
' Abhijit Tambe, August 2010

Option Explicit

'/******************************************************************************
' *  Copyright (C) 2000 by Robert Hubley.                                      *
' *  All rights reserved.                                                      *
' *                                                                            *
' *  This software is provided ``AS IS'' and any express or implied            *
' *  warranties, including, but not limited to, the implied warranties of      *
' *  merchantability and fitness for a particular purpose, are disclaimed.     *
' *  In no event shall the authors be liable for any direct, indirect,         *
' *  incidental, special, exemplary, or consequential damages (including, but  *
' *  not limited to, procurement of substitute goods or services; loss of use, *
' *  data, or profits; or business interruption) however caused and on any     *
' *  theory of liability, whether in contract, strict liability, or tort       *
' *  (including negligence or otherwise) arising in any way out of the use of  *
' *  this software, even if advised of the possibility of such damage.         *
' *                                                                            *
' ******************************************************************************
'
'  CLASS: MD5
'
'  DESCRIPTION:
'     This is a class which encapsulates a set of MD5 Message Digest functions.
'     MD5 algorithm produces a 128 bit digital fingerprint (signature) from an
'     dataset of arbitrary length.  For details see RFC 1321 (summarized below).
'     This implementation is derived from the RSA Data Security, Inc. MD5 Message-Digest
'     algorithm reference implementation (originally written in C)
'
'  AUTHOR:
'     Robert M. Hubley 12/1999
'
'
'  NOTES:
'      Network Working Group                                    R. Rivest
'      Request for Comments: 1321     MIT Laboratory for Computer Science
'                                             and RSA Data Security, Inc.
'                                                              April 1992
'
'
'                           The MD5 Message-Digest Algorithm
'
'      Summary
'
'         This document describes the MD5 message-digest algorithm. The
'         algorithm takes as input a message of arbitrary length and produces
'         as output a 128-bit "fingerprint" or "message digest" of the input.
'         It is conjectured that it is computationally infeasible to produce
'         two messages having the same message digest, or to produce any
'         message having a given prespecified target message digest. The MD5
'         algorithm is intended for digital signature applications, where a
'         large file must be "compressed" in a secure manner before being
'         encrypted with a private (secret) key under a public-key cryptosystem
'         such as RSA.
'
'         The MD5 algorithm is designed to be quite fast on 32-bit machines. In
'         addition, the MD5 algorithm does not require any large substitution
'         tables; the algorithm can be coded quite compactly.
'
'         The MD5 algorithm is an extension of the MD4 message-digest algorithm
'         1,2]. MD5 is slightly slower than MD4, but is more "conservative" in
'         design. MD5 was designed because it was felt that MD4 was perhaps
'         being adopted for use more quickly than justified by the existing
'         critical review; because MD4 was designed to be exceptionally fast,
'         it is "at the edge" in terms of risking successful cryptanalytic
'         attack. MD5 backs off a bit, giving up a little in speed for a much
'         greater likelihood of ultimate security. It incorporates some
'         suggestions made by various reviewers, and contains additional
'         optimizations. The MD5 algorithm is being placed in the public domain
'         for review and possible adoption as a standard.
'
'         RFC Author:
'         Ronald L.Rivest
'         Massachusetts Institute of Technology
'         Laboratory for Computer Science
'         NE43 -324545    Technology Square
'         Cambridge, MA  02139-1986
'         Phone: (617) 253-5880
'         EMail:    Rivest@ theory.lcs.mit.edu
'
'
'
'  CHANGE HISTORY:
'
'     0.1.0  RMH    1999/12/29      Original version
'
'


'=
'= Class Constants
'=
Private Const OFFSET_4 = 4294967296#
Private Const MAXINT_4 = 2147483647

Private Const S11 = 7
Private Const S12 = 12
Private Const S13 = 17
Private Const S14 = 22
Private Const S21 = 5
Private Const S22 = 9
Private Const S23 = 14
Private Const S24 = 20
Private Const S31 = 4
Private Const S32 = 11
Private Const S33 = 16
Private Const S34 = 23
Private Const S41 = 6
Private Const S42 = 10
Private Const S43 = 15
Private Const S44 = 21


'=
'= Class Variables
'=
Private State(4) As Long
Private ByteCounter As Long
Private ByteBuffer(63) As Byte

'==========================================================================================
'For 64-bit compatibility.

'MSDN: Compatibility Between the 32-bit and 64-bit Versions of Office 2010:
    'http://msdn.microsoft.com/en-us/library/ee691831.aspx
'Technet: Microsoft Office Code Compatibility Inspector:
    'http://technet.microsoft.com/en-us/library/ee833946.aspx
'Samples:
    'The Microsoft file Win32_PtrSafe.txt contains 64-bit Windows API Declarations and Constants for VBA:
        'http://support.microsoft.com/kb/2030490
        'http://www.microsoft.com/downloads/en/details.aspx?FamilyID=035b72a5-eef9-4baf-8dbc-63fbd2dd982b&displaylang=en
    'http://www.jkp-ads.com/articles/apideclarations.asp
'Windows API functions that were modified/added for 64-bit Windows:
    'http://msdn.microsoft.com/en-us/library/aa383663(VS.85).aspx

'PtrSafe:
    'For Excel 2010 and later (#Vba7 = True), change "Declare" to "Declare PtrSafe".
'LongPtr:
    'For Excel 2010 and later (#Vba7 = True), change the data type of handles and pointers
    'from Long to LongPtr. Leave pointers to strings as String.
'LongLong:
    'For 64-bit Excel (#Win64 = True), change Long (except for handles and pointers!) to LongLong

#If Mac Then
    'Running on MacIntosh. Do nothing.
#ElseIf VBA7 Then
    'Excel 2010 or later:
     #If Win64 Then
        '64-bit Excel, 2010 or later:
        'Use PtrSafe, LongPtr, and LongLong:
        
            Private Declare PtrSafe Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" _
                (Destination As Any, Source As Any, ByVal Length As LongLong)

     #Else
        '32-bit Excel 2010 or later:
        'Use PtrSafe and LongPtr, but NOT LongLong:

            Private Declare PtrSafe Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" _
                (Destination As Any, Source As Any, ByVal Length As Long)
        
     #End If
#Else
    'Excel 2007 or earlier:

        Private Declare Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" _
            (Destination As Any, Source As Any, ByVal Length As Long)

#End If

'==========================================================================================


'=
'= Class Properties
'=
Property Get RegisterA() As String
    RegisterA = State(1)
End Property

Property Get RegisterB() As String
    RegisterB = State(2)
End Property

Property Get RegisterC() As String
    RegisterC = State(3)
End Property

Property Get RegisterD() As String
    RegisterD = State(4)
End Property


'=
'= Class Functions
'=

'
' Function to quickly digest a file into a hex string
'
Public Function DigestFileToHexStr(FileName As String) As String
    Open FileName For Binary Access Read As #1
    MD5Init
    Do While Not EOF(1)
        Get #1, , ByteBuffer
        If Loc(1) < LOF(1) Then
            ByteCounter = ByteCounter + 64
            MD5Transform ByteBuffer
        End If
    Loop
    ByteCounter = ByteCounter + (LOF(1) Mod 64)
    Close #1
    MD5Final
    DigestFileToHexStr = GetValues
End Function

'
' Function to digest a text string and output the result as a string
' of hexadecimal characters.
'
Public Function DigestStrToHexStr(SourceString As String) As String
    MD5Init
    MD5Update Len(SourceString), StringToArray(SourceString)
    MD5Final
    DigestStrToHexStr = GetValues
End Function

'
' A utility function which converts a string into an array of
' bytes.
'
Private Function StringToArray(InString As String) As Byte()
    Dim i As Integer
    Dim bytBuffer() As Byte
    ReDim bytBuffer(Len(InString))
    For i = 0 To Len(InString) - 1
        bytBuffer(i) = Asc(Mid(InString, i + 1, 1))
    Next i
    StringToArray = bytBuffer
End Function

'
' Concatenate the four state vaules into one string
'
Public Function GetValues() As String
    Dim byteArray(0 To 15) As Byte
    
    Dim a As Long
    Dim b As Long
    Dim c As Long
    Dim d As Long
    
    a = State(1)
    b = State(2)
    c = State(3)
    d = State(4)

    CopyMemory byteArray(0), ByVal VarPtr(a), Len(a)
    CopyMemory byteArray(4), ByVal VarPtr(b), Len(b)
    CopyMemory byteArray(8), ByVal VarPtr(c), Len(c)
    CopyMemory byteArray(12), ByVal VarPtr(d), Len(d)
    
    GetValues = StrConv(byteArray, vbUnicode)
    'GetValues = LongToString(State(1)) & LongToString(State(2)) & LongToString(State(3)) & LongToString(State(4))
End Function

'
' Convert a Long to a Hex string
'
Private Function LongToString(Num As Long) As String
        Dim a As Byte
        Dim b As Byte
        Dim c As Byte
        Dim d As Byte
        
        a = Num And &HFF&
        If a < 16 Then
            LongToString = "0" & Hex(a)
        Else
            LongToString = Hex(a)
        End If
               
        b = (Num And &HFF00&) \ 256
        If b < 16 Then
            LongToString = LongToString & "0" & Hex(b)
        Else
            LongToString = LongToString & Hex(b)
        End If
        
        c = (Num And &HFF0000) \ 65536
        If c < 16 Then
            LongToString = LongToString & "0" & Hex(c)
        Else
            LongToString = LongToString & Hex(c)
        End If
       
        If Num < 0 Then
            d = ((Num And &H7F000000) \ 16777216) Or &H80&
        Else
            d = (Num And &HFF000000) \ 16777216
        End If
        
        If d < 16 Then
            LongToString = LongToString & "0" & Hex(d)
        Else
            LongToString = LongToString & Hex(d)
        End If
    
End Function

'
' Initialize the class
'   This must be called before a digest calculation is started
'
Public Sub MD5Init()
    ByteCounter = 0
    State(1) = UnsignedToLong(1732584193#)
    State(2) = UnsignedToLong(4023233417#)
    State(3) = UnsignedToLong(2562383102#)
    State(4) = UnsignedToLong(271733878#)
End Sub

'
' MD5 Final
'
Public Sub MD5Final()
    Dim dblBits As Double
    
    Dim padding(72) As Byte
    Dim lngBytesBuffered As Long
    
    padding(0) = &H80
    
    dblBits = ByteCounter * 8
    
    ' Pad out
    lngBytesBuffered = ByteCounter Mod 64
    If lngBytesBuffered <= 56 Then
        MD5Update 56 - lngBytesBuffered, padding
    Else
        MD5Update 120 - lngBytesBuffered, padding
    End If
    
    
    padding(0) = UnsignedToLong(dblBits) And &HFF&
    padding(1) = UnsignedToLong(dblBits) \ 256 And &HFF&
    padding(2) = UnsignedToLong(dblBits) \ 65536 And &HFF&
    padding(3) = UnsignedToLong(dblBits) \ 16777216 And &HFF&
    padding(4) = 0
    padding(5) = 0
    padding(6) = 0
    padding(7) = 0
    
    MD5Update 8, padding
End Sub

'
' Break up input stream into 64 byte chunks
'
Public Sub MD5Update(InputLen As Long, InputBuffer() As Byte)
    Dim II As Integer
    Dim i As Integer
    Dim J As Integer
    Dim K As Integer
    Dim lngBufferedBytes As Long
    Dim lngBufferRemaining As Long
    Dim lngRem As Long
    
    lngBufferedBytes = ByteCounter Mod 64
    lngBufferRemaining = 64 - lngBufferedBytes
    ByteCounter = ByteCounter + InputLen
    ' Use up old buffer results first
    If InputLen >= lngBufferRemaining Then
        For II = 0 To lngBufferRemaining - 1
            ByteBuffer(lngBufferedBytes + II) = InputBuffer(II)
        Next II
        MD5Transform ByteBuffer
        
        lngRem = (InputLen) Mod 64
        ' The transfer is a multiple of 64 lets do some transformations
        For i = lngBufferRemaining To InputLen - II - lngRem Step 64
            For J = 0 To 63
                ByteBuffer(J) = InputBuffer(i + J)
            Next J
            MD5Transform ByteBuffer
        Next i
        lngBufferedBytes = 0
    Else
      i = 0
    End If
    
    ' Buffer any remaining input
    For K = 0 To InputLen - i - 1
        ByteBuffer(lngBufferedBytes + K) = InputBuffer(i + K)
    Next K
    
End Sub

'
' MD5 Transform
'
Private Sub MD5Transform(Buffer() As Byte)
    Dim x(16) As Long
    Dim a As Long
    Dim b As Long
    Dim c As Long
    Dim d As Long
    
    a = State(1)
    b = State(2)
    c = State(3)
    d = State(4)
    
    Decode 64, x, Buffer

    ' Round 1
    FF a, b, c, d, x(0), S11, -680876936
    FF d, a, b, c, x(1), S12, -389564586
    FF c, d, a, b, x(2), S13, 606105819
    FF b, c, d, a, x(3), S14, -1044525330
    FF a, b, c, d, x(4), S11, -176418897
    FF d, a, b, c, x(5), S12, 1200080426
    FF c, d, a, b, x(6), S13, -1473231341
    FF b, c, d, a, x(7), S14, -45705983
    FF a, b, c, d, x(8), S11, 1770035416
    FF d, a, b, c, x(9), S12, -1958414417
    FF c, d, a, b, x(10), S13, -42063
    FF b, c, d, a, x(11), S14, -1990404162
    FF a, b, c, d, x(12), S11, 1804603682
    FF d, a, b, c, x(13), S12, -40341101
    FF c, d, a, b, x(14), S13, -1502002290
    FF b, c, d, a, x(15), S14, 1236535329
    
    ' Round 2
    GG a, b, c, d, x(1), S21, -165796510
    GG d, a, b, c, x(6), S22, -1069501632
    GG c, d, a, b, x(11), S23, 643717713
    GG b, c, d, a, x(0), S24, -373897302
    GG a, b, c, d, x(5), S21, -701558691
    GG d, a, b, c, x(10), S22, 38016083
    GG c, d, a, b, x(15), S23, -660478335
    GG b, c, d, a, x(4), S24, -405537848
    GG a, b, c, d, x(9), S21, 568446438
    GG d, a, b, c, x(14), S22, -1019803690
    GG c, d, a, b, x(3), S23, -187363961
    GG b, c, d, a, x(8), S24, 1163531501
    GG a, b, c, d, x(13), S21, -1444681467
    GG d, a, b, c, x(2), S22, -51403784
    GG c, d, a, b, x(7), S23, 1735328473
    GG b, c, d, a, x(12), S24, -1926607734
    
    ' Round 3
    HH a, b, c, d, x(5), S31, -378558
    HH d, a, b, c, x(8), S32, -2022574463
    HH c, d, a, b, x(11), S33, 1839030562
    HH b, c, d, a, x(14), S34, -35309556
    HH a, b, c, d, x(1), S31, -1530992060
    HH d, a, b, c, x(4), S32, 1272893353
    HH c, d, a, b, x(7), S33, -155497632
    HH b, c, d, a, x(10), S34, -1094730640
    HH a, b, c, d, x(13), S31, 681279174
    HH d, a, b, c, x(0), S32, -358537222
    HH c, d, a, b, x(3), S33, -722521979
    HH b, c, d, a, x(6), S34, 76029189
    HH a, b, c, d, x(9), S31, -640364487
    HH d, a, b, c, x(12), S32, -421815835
    HH c, d, a, b, x(15), S33, 530742520
    HH b, c, d, a, x(2), S34, -995338651
    
    ' Round 4
    II a, b, c, d, x(0), S41, -198630844
    II d, a, b, c, x(7), S42, 1126891415
    II c, d, a, b, x(14), S43, -1416354905
    II b, c, d, a, x(5), S44, -57434055
    II a, b, c, d, x(12), S41, 1700485571
    II d, a, b, c, x(3), S42, -1894986606
    II c, d, a, b, x(10), S43, -1051523
    II b, c, d, a, x(1), S44, -2054922799
    II a, b, c, d, x(8), S41, 1873313359
    II d, a, b, c, x(15), S42, -30611744
    II c, d, a, b, x(6), S43, -1560198380
    II b, c, d, a, x(13), S44, 1309151649
    II a, b, c, d, x(4), S41, -145523070
    II d, a, b, c, x(11), S42, -1120210379
    II c, d, a, b, x(2), S43, 718787259
    II b, c, d, a, x(9), S44, -343485551
    
    
    State(1) = LongOverflowAdd(State(1), a)
    State(2) = LongOverflowAdd(State(2), b)
    State(3) = LongOverflowAdd(State(3), c)
    State(4) = LongOverflowAdd(State(4), d)

'  /* Zeroize sensitive information.
'*/
'  MD5_memset ((POINTER)x, 0, sizeof (x));
    
End Sub

Private Sub Decode(Length As Integer, OutputBuffer() As Long, InputBuffer() As Byte)
    Dim intDblIndex As Integer
    Dim intByteIndex As Integer
    Dim dblSum As Double
    
    intDblIndex = 0
    For intByteIndex = 0 To Length - 1 Step 4
        dblSum = InputBuffer(intByteIndex) + _
                                    InputBuffer(intByteIndex + 1) * 256# + _
                                    InputBuffer(intByteIndex + 2) * 65536# + _
                                    InputBuffer(intByteIndex + 3) * 16777216#
        OutputBuffer(intDblIndex) = UnsignedToLong(dblSum)
        intDblIndex = intDblIndex + 1
    Next intByteIndex
End Sub

'
' FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4.
' Rotation is separate from addition to prevent recomputation.
'
Private Function FF(a As Long, _
                    b As Long, _
                    c As Long, _
                    d As Long, _
                    x As Long, _
                    s As Long, _
                    ac As Long) As Long
    a = LongOverflowAdd4(a, (b And c) Or (Not (b) And d), x, ac)
    a = LongLeftRotate(a, s)
    a = LongOverflowAdd(a, b)
End Function

Private Function GG(a As Long, _
                    b As Long, _
                    c As Long, _
                    d As Long, _
                    x As Long, _
                    s As Long, _
                    ac As Long) As Long
    a = LongOverflowAdd4(a, (b And d) Or (c And Not (d)), x, ac)
    a = LongLeftRotate(a, s)
    a = LongOverflowAdd(a, b)
End Function

Private Function HH(a As Long, _
                    b As Long, _
                    c As Long, _
                    d As Long, _
                    x As Long, _
                    s As Long, _
                    ac As Long) As Long
    a = LongOverflowAdd4(a, b Xor c Xor d, x, ac)
    a = LongLeftRotate(a, s)
    a = LongOverflowAdd(a, b)
End Function

Private Function II(a As Long, _
                    b As Long, _
                    c As Long, _
                    d As Long, _
                    x As Long, _
                    s As Long, _
                    ac As Long) As Long
    a = LongOverflowAdd4(a, c Xor (b Or Not (d)), x, ac)
    a = LongLeftRotate(a, s)
    a = LongOverflowAdd(a, b)
End Function

'
' Rotate a long to the right
'
Function LongLeftRotate(value As Long, bits As Long) As Long
    Dim lngSign As Long
    Dim lngI As Long
    bits = bits Mod 32
    If bits = 0 Then LongLeftRotate = value: Exit Function
    For lngI = 1 To bits
        lngSign = value And &HC0000000
        value = (value And &H3FFFFFFF) * 2
        value = value Or ((lngSign < 0) And 1) Or (CBool(lngSign And _
                &H40000000) And &H80000000)
    Next
    LongLeftRotate = value
End Function

'
' Function to add two unsigned numbers together as in C.
' Overflows are ignored!
'
Private Function LongOverflowAdd(Val1 As Long, Val2 As Long) As Long
    Dim lngHighWord As Long
    Dim lngLowWord As Long
    Dim lngOverflow As Long

    lngLowWord = (Val1 And &HFFFF&) + (Val2 And &HFFFF&)
    lngOverflow = lngLowWord \ 65536
    lngHighWord = (((Val1 And &HFFFF0000) \ 65536) + ((Val2 And &HFFFF0000) \ 65536) + lngOverflow) And &HFFFF&
    LongOverflowAdd = UnsignedToLong((lngHighWord * 65536#) + (lngLowWord And &HFFFF&))
End Function

'
' Function to add two unsigned numbers together as in C.
' Overflows are ignored!
'
Private Function LongOverflowAdd4(Val1 As Long, Val2 As Long, val3 As Long, val4 As Long) As Long
    Dim lngHighWord As Long
    Dim lngLowWord As Long
    Dim lngOverflow As Long

    lngLowWord = (Val1 And &HFFFF&) + (Val2 And &HFFFF&) + (val3 And &HFFFF&) + (val4 And &HFFFF&)
    lngOverflow = lngLowWord \ 65536
    lngHighWord = (((Val1 And &HFFFF0000) \ 65536) + _
                   ((Val2 And &HFFFF0000) \ 65536) + _
                   ((val3 And &HFFFF0000) \ 65536) + _
                   ((val4 And &HFFFF0000) \ 65536) + _
                   lngOverflow) And &HFFFF&
    LongOverflowAdd4 = UnsignedToLong((lngHighWord * 65536#) + (lngLowWord And &HFFFF&))
End Function

'
' Convert an unsigned double into a long
'
Private Function UnsignedToLong(value As Double) As Long
        If value < 0 Or value >= OFFSET_4 Then Error 6 ' Overflow
        If value <= MAXINT_4 Then
          UnsignedToLong = value
        Else
          UnsignedToLong = value - OFFSET_4
        End If
      End Function

'
' Convert a long to an unsigned Double
'
Private Function LongToUnsigned(value As Long) As Double
        If value < 0 Then
          LongToUnsigned = value + OFFSET_4
        Else
          LongToUnsigned = value
        End If
End Function

Attribute VB_Name = "Sheet1"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet2"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet3"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet4"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet5"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet6"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "ThisWorkbook"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
' Modified for MWS integration
' Abhijit Tambe, July 2010

Dim ExcelAppEventClass As clsExcelAppEvents 'Required for Excel application-level events.


Private Sub Workbook_Activate()
    Call WorkbookGotActivated
End Sub


Private Sub Workbook_Deactivate()
    Call WorkbookGotDeactivated
End Sub


Private Sub Workbook_BeforeSave(ByVal SaveAsUI As Boolean, Cancel As Boolean)
    
    '9/26/2008:
    'Warning: Do not call ResetProductIdNumberFormattingToText here in the
    'BeforeSave event, due to an Excel bug with SpecialCells(xlCellTypeConstants).
    'Here in the Before_Save event, SpecialCells(xlCellTypeConstants) reports
    '*all cells* as being occupied.
    '
    'Instead, call it from an OnTime. But don't call it even from an OnTime if currently
    'closing the workbook.
    

'    Call ResetProductIdNumberFormattingToText  'No! Don't do this here! See note above.
    
    Call DockDropdown
    
    If Not bNowClosingWorkbook Then
        Application.OnTime Now + 0.000000001, "ResetProductIdNumberFormattingToText" '0.000000001 = ~1/10,000 sec.
    End If
    
   
End Sub



Public Sub Workbook_BeforeClose(Cancel As Boolean)
    
    Call DropdownsOnWorkbookClose

    Dim bRet As Boolean
    On Error Resume Next
    Call ResetProductIdNumberFormattingToText
    DeleteToolbarToBuildInternationalTemplates
    bRet = OtherOpenWorkbookNeedsAmazonFeedManagerToolbar
    If Not bRet Then Call amazonGlobals.RemoveToolBar
'    Call DockDropdown 'now doing this in Workbook_BeforeSave instead.
    bNowClosingWorkbook = True
End Sub


Public Sub Workbook_Open()

'    Call Main 'this is the only line in this module from the original 1.9.


    Call InitExcelApplicationEvents 'Required for Excel application-level events.
    
    Call DropdownsOnWorkbookOpen

        If Not ToolbarAmazonFeedManagerExists Or Not ToolbarToBuildInternationalTemplatesExists Then
    
            DeleteToolbarToBuildInternationalTemplates
            
            Call amazonGlobals.SetUpNewToolBar
            
            AddToolbarToBuildFlatFileTemplates
    
        End If
        
    ' added 07/30/10 by atambe
    If GetLocalLanguageName = INT_TABLE_CHINESE_HEADER Then
        bChinaTemplate = True
        bDisableValidation = True
    Else
        bChinaTemplate = False
    End If
    
    ' added 08/19/10 by atambe
    If GetLocalLanguageName = INT_TABLE_ENGLISH_UK_HEADER Or GetLocalLanguageName = INT_TABLE_FRENCH_HEADER Or GetLocalLanguageName = INT_TABLE_GERMAN_HEADER Then
        Set shTemplate = GetTemplateWorksheet
        If InStr(UCase(shTemplate.Range("A1").value), "TEMPLATETYPE=COMPUTERS") > 0 Then
            bDisableValidation = True
        End If
    End If
    
    amazonGlobals.inLookupProcedure = False
    amazonGlobals.firstTimeToggleForBroadbandWarning = True
    amazonGlobals.activeModeLookup = False
    
    amazonGlobals.g_DefProdCondition = "UsedGood"
    amazonGlobals.g_DefProdTaxCode = "A_GEN_NOTAX"
    amazonGlobals.g_DefUpdateDelete = "Update"
    amazonGlobals.g_DefProductType = "Blended"
    amazonGlobals.g_AutoFillSKU = True
    
    'get template worksheet:
    Set shTemplate = GetTemplateWorksheet
    
'    AmazonMerchantLookup.WebBrowser1.Navigate "http://programs.chicagoparkdistrict.com/programBrowser/images/spinner.gif"
    Worksheets(shTemplate.Name).lastcolorIndex = 5
    
    Application.MoveAfterReturnDirection = xlDown
    
    Call ActivateInstructionsOrDdefSheet
    
    Call CheckForAutoUpdate
    
    Application.EnableEvents = True
    
End Sub



'required for Excel application-level events:
Sub InitExcelApplicationEvents()
    Set ExcelAppEventClass = New clsExcelAppEvents
    Set ExcelAppEventClass.ExcelApp = Application
End Sub




Private Sub Workbook_SheetActivate(ByVal sh As Object)
    Set shTemplate = GetTemplateWorksheet()
End Sub









Attribute VB_Name = "amazonGlobals"
Option Private Module 'to prevent merchants from seeing & running subs from the Developer toolbar.

' Modified for MWS Integration for all Regions deprecating AIM
' Sunitha Basodi, Mar 2012

' Modified for MWS Integration
' Abhijit Tambe, July 2010


Public inLookupProcedure As Boolean
Public activeModeLookup As Boolean
Public firstTimeToggleForBroadbandWarning As Boolean
Public errorThrown As errorType
'Public HttpReq As MSXML2.XMLHTTP30
Public g_DefProdTaxCode As String
Public g_DefProdCondition As String
Public g_DefProductType As String
Public g_AutoFillSKU As Boolean
Public g_DefUpdateDelete As String
Public g_ImageSize As String
Public NoImageURL As String
Public NoImageSize As Integer
Public shTemplate As Worksheet
Public strTemplateMacrosToolbarVersionString As String 'set in Workbook_Activate.
Public arrayTemplateSheets() As Variant

Public bUploadingMultipleTemplateSheets As Boolean
Public bMultipleTemplateSheets_IsUploadSuccess As Boolean
Public strMultipleTemplateSheets_XmlhttpUploadID As String
Public strMultipleTemplateSheets_XmlhttpUploadType As String
Public strMultipleTemplateSheets_XmlhttpUploadStatus As String
Public strMultipleTemplateSheets_XmlhttpUploadDateConvertedToLocalTime As String
Public bMultipleTemplateSheets_IsXmlhttpError As Boolean
Public strMultipleTemplateSheets_XmlhttpErrorCode As String
Public strMultipleTemplateSheets_XmlhttpErrorMessage As String
Public bMultipleTemplateSheets_IsVbaError As Boolean
Public strMultipleTemplateSheets_VbaErrorNumber As String
Public strMultipleTemplateSheets_VbaErrorDescription As String
Public bMultipleTemplateSheetsStopUploading As Boolean
Public bMultipleTemplateSheetsShowLoginDlg As Boolean
Public bAllUploadsFailed As Boolean
Public bChinaTemplate As Boolean  ' added 07/30/10 by atambe ' added by sunithab@ 06-Mar-2012
Public bDisableValidation As Boolean  ' added 08/19/10 by atambe

Public Const URL_HEADER_CONTACT As String = "Contact URL"
Public Const URL_HEADER_MWS As String = "MWS URL" ' added 07/30/10 by atambe
Public Const URL_HEADER_STATUS_CHECK_PROD As String = "Status Check URL - Prod"
Public Const URL_HEADER_STATUS_CHECK_DEVO As String = "Status Check URL - Devo"
Public Const URL_HEADER_CREDENTIALS As String = "Credentials URL"   ' added 08/05/10 by atambe
Public Const URL_HEADER_CREDENTIALS_SUMMARY As String = "Credentials Summary URL"   ' added 08/05/10 by atambe
Public Const URL_HEADER_CREDENTIALS_PROCESSOR As String = "Credentials Processor URL"   ' added 08/05/10 by atambe
Public Const URL_HEADER_SECTION_END_TEXT As String = "ENDSECTION"

'2009-12-02: these are obsolete now that seamless and M@ use the same status-check urls:
'but leaving them in place in case they are needed again later.
Public Const STATUS_CHECK_URL_TYPE_DEFINED_NAME As String = "Status_Check_URL_Type"
Public Const STATUS_CHECK_URL_TYPE_NOSELLERCENTRAL As String = "No Seller Central"
Public Const STATUS_CHECK_URL_TYPE_USESELLERCENTRAL As String = "Use Seller Central"

Public Const MULTI_TEMPLATE_STATUS_IS_TEMPLATE_SHEET As String = "Is Template Sheet"
Public Const MULTI_TEMPLATE_STATUS_PASSED_VALIDATION As String = "(Passed Validation)"
Public Const MULTI_TEMPLATE_STATUS_FAILED_VALIDATION As String = "(FAILED Validation)"
Public Const MULTI_TEMPLATE_STATUS_CANCELLED_VALIDATION As String = "(Cancelled Validation)"
Public Const MULTI_TEMPLATE_STATUS_USER_SAYS_UPLOAD As String = "User Says Upload"
Public Const MULTI_TEMPLATE_STATUS_USER_SAYS_NO_UPLOAD As String = "User Says No Upload"
Public Const MULTI_TEMPLATE_STATUS_UPLOAD_SUCCESS As String = "Upload Succeeded"
Public Const MULTI_TEMPLATE_STATUS_UPLOAD_FAILURE As String = "Upload Failed"
Public Const COL_SHEET As Long = 1
Public Const COL_STATUS As Long = 2
Public Const COL_DLG_COMMENT As Long = 3
Public Const COL_IS_UPLOAD_SUCCESS_BOOL As Long = 4
Public Const COL_IS_XMLHTTP_ERROR As Long = 5
Public Const COL_XMLHTTP_UPLOAD_ID As Long = 6
Public Const COL_XMLHTTP_UPLOAD_TYPE As Long = 7
Public Const COL_XMLHTTP_UPLOAD_STATUS As Long = 8
Public Const COL_XMLHTTP_UPLOAD_DATE_CONVERTED_TO_LOCAL_TIME As Long = 9
Public Const COL_XMLHTTP_ERROR_CODE As Long = 10
Public Const COL_XMLHTTP_ERROR_MESSAGE As Long = 11
Public Const COL_IS_VBA_ERROR As Long = 12
Public Const COL_VBA_ERROR_NUMBER As Long = 13
Public Const COL_VBA_ERROR_DESCRIPTION As Long = 14

Public Const LISTBOX_COL_A As Long = 0
Public Const LISTBOX_COL_B As Long = 1
Public Const LISTBOX_COL_C As Long = 2

Type OFFER_FEED_RECORD
    
    ProductID                As String
    ProductIDType            As String
    SearchIndex              As String
    AmazonID                 As String
    Manufacturer             As String
    title                    As String
    Description              As String
    DetailPageURL            As String
    ImageURL                 As String
    ImageWidth               As Integer
    ImageHeight              As Integer
    SKU                      As String
    Price                    As String
    Quantity                 As String
    ProductTaxCode           As String
    Condition                As String
    ConditionNote            As String
    UpdateDelete             As String
    IsGiftWrapAvailable      As String
    IsGiftMessageAvailable   As String
    SalesPrice               As String
    SaleStartDate            As String
    SaleEndDate              As String
    ShipOption               As String
    ShippingAmount           As String
    ShippingAmountType       As String
    IsShippingRestricted     As String
End Type

Public Enum errorType
    noError = 0
    noInfoInAmazon = 1
    badIdentifier = 2
    multipleMatches = 3
    nullIdentifier = 4
End Enum

Public Enum imagePositionInXmlDOMNodeList
    smallImage = 2
    mediumImage
    largeImage
End Enum

' modified 07/30/10 by atambe
Public Sub SetUpNewToolBar()
    On Error Resume Next
        
        If ThisWorkbookShowsTheBuildTemplatesToolbar Then Exit Sub

       'remove any existing...
       Application.CommandBars("Amazon Feed Manager").Delete
       Dim cb As Object 'CommandBar
    
       Set cb = Application.CommandBars.Add("Amazon Feed Manager", 1, , True) '1=msoBarTop
'       cb.Visible = True 'commented out; toolbar must be hidden while icon is replaced
       
       
       'Add Amazon logo to toolbar:
       Dim cbc As Object 'CommandBarControl
       Set cbc = cb.Controls.Add(msoControlButton)
       cbc.BeginGroup = True
'       cbc.Caption = "Amazon Logo"
       strTemplateMacrosToolbarVersionString = GetTranslatedString("version") & ThisWorkbook.Names("Macros_Version").RefersToRange.value
       cbc.Caption = strTemplateMacrosToolbarVersionString
       cbc.FaceId = 176
       cbc.Style = msoButtonIcon
       
       'Put custom Amazon logo on the Amazon logo toolbar control:
       'Toolbar must be hidden while icon is replaced:
       If Application.CutCopyMode Then
            'don't mess up user's cut/copy mode.
       Else
            cb.Visible = False
            shIcons.Shapes("icon_amazon_logo").CopyPicture
'            cb.Controls("Amazon Logo").PasteFace
            cb.Controls(strTemplateMacrosToolbarVersionString).PasteFace
            'Copy any cell to overwrite the custom icon in the clipboard,
            'so that the user does not inadvertently paste another copy of the icon somewhere:
            shIcons.Range("A1").Copy
            'Remove the cut/copy marquee around the cell copied in the previous line:
            Application.CutCopyMode = False
       End If
       
       cb.Visible = True
       

       ' Make it visible & add a button...
       Set cbc = cb.Controls.Add(1) '1=msoControlButton
       cbc.BeginGroup = True
       cbc.Caption = "Batch Lookup"
       cbc.FaceId = 176
       cbc.OnAction = "shTemplate.batchLookupInformation"
       cbc.Style = msoButtonIconAndCaption
       
       
       Set cbc = cb.Controls.Add(1) '1=msoControlButton
       cbc.BeginGroup = True
       cbc.Caption = "Turn on Product Lookup"
       cbc.FaceId = 2174
       cbc.OnAction = "shTemplate.toggleActiveProductLookup"
       cbc.Style = msoButtonIconAndCaption
                    
              
       Set cbc = cb.Controls.Add(1) '1=msoControlButton
       cbc.BeginGroup = True
       cbc.Caption = GetTranslatedString("add_offer")
       cbc.FaceId = 2892
       cbc.OnAction = "Sheet3.copyRow"
       cbc.Style = msoButtonIconAndCaption
       cbc.Visible = False
       cbc.Enabled = False
       
       Set cbc = cb.Controls.Add(1) '1=msoControlButton
       cbc.BeginGroup = True
       cbc.Caption = "Preferences"
       cbc.FaceId = 548
       cbc.OnAction = "ShowPreferencesDlg"
       cbc.Style = msoButtonIconAndCaption
        
       ' added 08/11/10 by atambe
       If Not bDisableValidation Then
           Set cbc = cb.Controls.Add(msoControlButton)
           cbc.BeginGroup = True
    '       cbc.Caption = "Validate"
           cbc.Caption = ThisWorkbook.Names(TOOLBAR_BUTTON_CAPTION_VALIDATE_DEFINED_NAME).RefersToRange.value
           cbc.FaceId = 1745 '1745 'magnifying glass over paper    '25 'magnifying glass
           cbc.OnAction = "ValidateTemplate"
           cbc.Style = msoButtonIconAndCaption
       End If

''=======================================================================================================
'       'MAKE VALIDATE A DROPDOWN WITH TWO MENU CHOICES:
'            'VALIDATE ALL
'            'VALIDATE SELECTION
'       Set cbc = cb.Controls.Add(msoControlPopup)
'       cbc.BeginGroup = True
'       cbc.Caption = "Validate"
'       cbc.Caption = ThisWorkbook.Names(TOOLBAR_BUTTON_CAPTION_VALIDATE_DEFINED_NAME).RefersToRange.value
'
'                'add menu item Validate All:
'                Dim cbcDD As Object
'                Set cbcDD = cbc.Controls.Add(msoControlButton)
'                cbcDD.Caption = "Validate All"
'                cbcDD.FaceId = 1745 '1745 'magnifying glass over paper    '25 'magnifying glass
'                cbc.OnAction = "ValidateTemplate"
'                cbcDD.Style = msoButtonIconAndCaption
'
'                'add menu item Validate Selection:
'                Set cbcDD = cbc.Controls.Add(msoControlButton)
'                cbcDD.Caption = "Validate Selection"
'                cbcDD.FaceId = 1745 '1745 'magnifying glass over paper    '25 'magnifying glass
'                cbc.OnAction = "" 'this feature not yet written........................................
'                cbcDD.Style = msoButtonIconAndCaption
''=======================================================================================================


       Set cbc = cb.Controls.Add(1) '1=msoControlButton
       cbc.BeginGroup = True
'       cbc.Caption = "Upload File"
       cbc.Caption = ThisWorkbook.Names(TOOLBAR_BUTTON_CAPTION_UPLOAD_DEFINED_NAME).RefersToRange.value
       cbc.FaceId = 270
       cbc.OnAction = "UploadFile"
       cbc.Style = msoButtonIconAndCaption
       
       ' added 07/30/10 by atambe
       'changed by sunithab 09-Mar-2010
       'If bChinaTemplate Then
           Set cbc = cb.Controls.Add(1) '1=msoControlButton
           cbc.BeginGroup = True
    '       cbc.Caption = "Credentials"
           cbc.Caption = ThisWorkbook.Names(TOOLBAR_BUTTON_CAPTION_CREDENTIALS_DEFINED_NAME).RefersToRange.value
           cbc.FaceId = 264
           cbc.OnAction = "ObtainCredentials"
           cbc.Style = msoButtonIconAndCaption
       'End If
       'changed by sunithab 09-Mar-2010 END
       
       Set cbc = cb.Controls.Add(1) '1=msoControlButton
       cbc.BeginGroup = True
'       cbc.Caption = "Import File"
       cbc.Caption = ThisWorkbook.Names(TOOLBAR_BUTTON_CAPTION_IMPORT_DEFINED_NAME).RefersToRange.value
       cbc.FaceId = 1790 '(funnel on diskette)
       cbc.OnAction = "ImportFile"
       cbc.Style = msoButtonIconAndCaption

       Set cbc = cb.Controls.Add(msoControlButton)
       cbc.BeginGroup = True
'       cbc.Caption = "Update Template"
       cbc.Caption = ThisWorkbook.Names(TOOLBAR_BUTTON_CAPTION_UPDATE_DEFINED_NAME).RefersToRange.value
       cbc.FaceId = 499 'funnel with pencil)
       cbc.OnAction = "GetLatestInternationalizedData"
       cbc.Style = msoButtonIconAndCaption
       

       Set cbc = cb.Controls.Add(1) '1=msoControlButton
       cbc.BeginGroup = True
       cbc.Caption = "Search"
       cbc.FaceId = 1790 '(funnel on diskette)
       cbc.OnAction = "Sheet2.singleAmznSearch"
       cbc.Style = msoButtonIconAndCaption
       cbc.Visible = False
       cbc.Enabled = False
       
       
       'changes from OfferOnlyFeed to release 1.9:
       Application.CommandBars("Amazon Feed Manager").Controls("Batch Lookup").Visible = False
       Application.CommandBars("Amazon Feed Manager").Controls("Turn on Product Lookup").Visible = False
       Application.CommandBars("Amazon Feed Manager").Controls("Preferences").Visible = False
       
End Sub

' modified 07/30/10 by atambe
Public Sub toggleToolBar()
    Dim Btn As Office.CommandBarButton
        
    If amazonGlobals.activeModeLookup = True Then
        amazonGlobals.activeModeLookup = False
        Application.MoveAfterReturnDirection = xlDown
        Application.CommandBars("Amazon Feed Manager").Controls("Batch Lookup").Enabled = True
        Application.CommandBars("Amazon Feed Manager").Controls.Item(3).Caption = "Turn on Product Lookup"
        Set Btn = Application.CommandBars("Amazon Feed Manager").Controls.Item(3)
        Btn.State = msoButtonUp
    Else
        ' added 07/30/10 by atambe
        'If bChinaTemplate Then 'changed by sunithab 09-Mar-2010
            If Not CheckSecurityPassword Then Exit Sub
        'End If 'changed by sunithab 09-Mar-2010

        amazonGlobals.activeModeLookup = True
        Application.MoveAfterReturnDirection = xlToRight
        Application.CommandBars("Amazon Feed Manager").Controls("Batch Lookup").Enabled = False
        Application.CommandBars("Amazon Feed Manager").Controls.Item(3).Caption = "Turn off Product Lookup"
        Set Btn = Application.CommandBars("Amazon Feed Manager").Controls.Item(3)
        Btn.State = msoButtonDown
    End If
    
    
End Sub

Public Sub RemoveToolBar()
    On Error Resume Next
     Application.CommandBars("Amazon Feed Manager").Delete
End Sub

' added 07/30/10 by atambe
Public Sub ObtainCredentials()
    frmCredentials.Show vbModal
End Sub

Public Function calculateIdType(Code As String) As String
Dim checkDigit As Integer
Select Case Len(Code)
Case 10:
    checkDigit = doISBNCheckDigit(Code)
    If (checkDigit = Val(Right$(Code, 1))) Then
        calculateIdType = "ISBN"
        Exit Function
    End If
Case 12:
    checkDigit = doUPCCheckDigit(Code)
    If (checkDigit = Val(Right$(Code, 1))) Then
        calculateIdType = "UPC"
        Exit Function
    End If
Case 13:
    checkDigit = doEANCheckDigit(Code)
    If (checkDigit = Val(Right$(Code, 1))) Then
        If Left$(Code, 3) = "978" Or Left$(Code, 3) = "979" Then 'ISBN
            calculateIdType = "ISBN"
            Exit Function
        Else
            calculateIdType = "EAN"
            Exit Function
        End If
    End If
End Select
calculateIdType = "Unrecognized"
End Function


Public Function doUPCCheckDigit(Code As String) As Integer
Dim Sum As Integer
Dim i As Variant
Sum = 0
For i = 1 To (Len(Code) - 1)
Dim digit As Integer
digit = Val(Mid$(Code, i, 1))
If (i Mod 2 = 1) Then
Sum = Sum + (digit * 3)
Else
Sum = Sum + digit
End If
Next i
Sum = Sum Mod 10
doUPCCheckDigit = (10 - Sum) Mod 10
End Function

Public Function doEANCheckDigit(Code As String) As Integer
Dim Sum As Integer
Dim i As Variant
Sum = 0
For i = 1 To (Len(Code) - 1)
Dim digit As Integer
digit = Val(Mid$(Code, i, 1))
If (i Mod 2 = 0) Then
Sum = Sum + (digit * 3)
Else
Sum = Sum + digit
End If
Next i
Sum = Sum Mod 10
doEANCheckDigit = (10 - Sum) Mod 10
End Function

Public Function doISBNCheckDigit(Code As String) As Integer
Dim Sum As Integer
Dim i As Variant
Sum = 0
For i = 1 To (Len(Code) - 1)
Dim digit As Integer
digit = Val(Mid$(Code, i, 1))
Sum = Sum + (digit * (11 - i))
Next i
Sum = Sum Mod 11
doISBNCheckDigit = (11 - Sum) Mod 11
End Function

Public Function LookupItemInCategory(ItemId As String, ItemIdType As String, Category As String, ByRef Count As Integer) As OFFER_FEED_RECORD()
'    On Error Resume Next
'    If g_ImageSize = "" Then g_ImageSize = "MediumImage"
'    NoImageURL = "http://ec1.images-amazon.com/images/G/01/nav2/dp/no-image-avail-img-map._V46862177_AA192_.gif"
'    NoImageSize = 192
'
'    Dim ItemMatches() As OFFER_FEED_RECORD
'    Dim httpreq As New MSXML2.XMLHTTP30
'    Dim urlStr As String
'    urlStr = "http://ecs.amazonaws.com/onca/xml?Service=AWSECommerceService&Version=2007-06-13&Operation=ItemLookup&SubscriptionId=0525E2PQ81DD7ZTWTK82"
'
'    If StrComp(ItemIdType, "ASIN", vbTextCompare) <> 0 Then
'        urlStr = urlStr & "&SearchIndex=" & Category
'    End If
'
'    urlStr = urlStr & "&ItemId=" & ItemId & "&IdType=" & ItemIdType & "&ResponseGroup=Small,Images"
'
'
'    httpreq.Open "GET", urlStr, False
'    httpreq.send
'    'Debug.Print HttpReq.responseText
'
''    Dim xmldoc As New MSXML2.DOMDocument 'converting to late binding.
'    Dim xmldoc As Object 'MSXML2.DOMDocument
'    Set xmldoc = Get_XML_DOMDocument_Object()
'
'    xmldoc.LoadXML (httpreq.responseText)
'
'    Count = xmldoc.getElementsByTagName("Item").Length
'
'    If Count >= 1 Then
'        ReDim ItemMatches(0 To Count - 1)
'        Dim Description As Object 'MSXML2.IXMLDOMNodeList  'converting to late binding.
'        Dim itemlist As Object 'MSXML2.IXMLDOMNodeList 'converting to late binding.
'
'        Set itemlist = xmldoc.getElementsByTagName("Item")
'        Dim DescriptionText As String
'
'        For i = 0 To Count - 1
'            ItemMatches(i).SearchIndex = xmldoc.getElementsByTagName("SearchIndex").Item(0).Text
'            ItemMatches(i).ProductID = xmldoc.getElementsByTagName("ItemId").Item(0).Text
'            ItemMatches(i).ProductIDType = xmldoc.getElementsByTagName("IdType").Item(0).Text
'
'            ItemMatches(i).AmazonID = itemlist.Item(i).selectNodes("//Item/ASIN").Item(i).Text
'            ItemMatches(i).Manufacturer = itemlist.Item(i).selectNodes("//Item/ItemAttributes/Manufacturer").Item(i).Text
'            ItemMatches(i).Title = itemlist.Item(i).selectNodes("//Item/ItemAttributes/Title").Item(i).Text
'            ItemMatches(i).DetailPageURL = itemlist.Item(i).selectNodes("//Item/DetailPageURL").Item(i).Text
'            Dim index As Integer
'            Select Case amazonGlobals.g_ImageSize
'                    Case "SmallImage"
'                        index = imagePositionInXmlDOMNodeList.smallImage
'                    Case "MediumImage"
'                        index = imagePositionInXmlDOMNodeList.mediumImage
'                    Case "LargeImage"
'                        index = imagePositionInXmlDOMNodeList.largeImage
'            End Select
'            If (itemlist.Item(i).childNodes.Length >= index + 1) Then
'                If (itemlist.Item(i).childNodes.Item(index).baseName = amazonGlobals.g_ImageSize) Then
'                    ItemMatches(i).ImageURL = itemlist.Item(i).childNodes.Item(index).childNodes.Item(0).Text
'                    ItemMatches(i).ImageWidth = itemlist.Item(i).childNodes.Item(index).childNodes.Item(2).Text
'                    ItemMatches(i).ImageHeight = itemlist.Item(i).childNodes.Item(index).childNodes.Item(1).Text
'                Else
'                    ItemMatches(i).ImageURL = NoImageURL
'                    ItemMatches(i).ImageHeight = NoImageSize
'                    ItemMatches(i).ImageWidth = NoImageSize
'                End If
'            Else
'                ItemMatches(i).ImageURL = NoImageURL
'                ItemMatches(i).ImageHeight = NoImageSize
'                ItemMatches(i).ImageWidth = NoImageSize
'            End If
'            If ItemMatches(i).ImageURL = "" Then
'                ItemMatches(i).ImageURL = NoImageURL
'                ItemMatches(i).ImageHeight = NoImageSize
'                ItemMatches(i).ImageWidth = NoImageSize
'            End If
'            Set Description = itemlist.Item(i).selectNodes("//Item/ItemAttributes/Description")
'            If Description.Length <> 0 Then
'                ItemMatches(i).Description = Description.Item(0).Text
'            Else
'                ItemMatches(i).Description = " "
'            End If
'            Set Description = itemlist.Item(i).selectNodes("//Item/ItemAttributes/Description")
'            If Description.Length <> 0 Then
'                ItemMatches(i).Description = Description.Item(0).Text
'            Else
'                ItemMatches(i).Description = " "
'            End If
'        Next i
'    End If
'    LookupItemInCategory = ItemMatches
    
End Function

Public Function LookupItemInAllCategories(ItemId As String, ItemIdType As String, ByRef Count As Integer) As OFFER_FEED_RECORD()

    Dim searchIndices() As Variant
    searchIndices() = Array("Apparel", "Baby", "Beauty", "Blended", "Books", "Classical", "DigitalMusic", "DVD", "Electronics", "GourmetFood", "HealthPersonalCare", "Jewelry", "Kitchen", "Magazines", "Miscellaneous", "Music", "MusicalInstruments", "MusicTracks", "OfficeProducts", "OutdoorLiving", "PCHardware", "PetSupplies", "Photo", "Restaurants", "Software", "SportingGoods", "Tools", "Toys", "VHS", "Video", "VideoGames", "Wireless", "WirelessAccessories")
    Dim ItemMatches() As OFFER_FEED_RECORD
    Dim SearchIndex As String

    
    Count = 0
    
    For i = LBound(searchIndices) To UBound(searchIndices)
        Dim items() As OFFER_FEED_RECORD
        Dim nItems As Integer
        
        SearchIndex = searchIndices(i)
        items = LookupItemInCategory(ItemId, ItemIdType, SearchIndex, nItems)
        If nItems > 0 Then
            ReDim Preserve ItemMatches(Count + nItems)
            For J = 0 To nItems - 1
                ItemMatches(Count + J) = items(J)
            Next J
            Count = Count + nItems
        End If
    Next i
    
    If Count > 1 Then
    'more then one match
        Dim ix As Integer
        Dim firstAsin As String
        firstAsin = ItemMatches(0).AmazonID
        Dim allasinssame As Boolean
        allasinssame = True
        For ix = 0 To Count - 1
            If firstAsin <> ItemMatches(ix).AmazonID Then
                allasinssame = False
            End If
        Next ix
        
        If allasinssame = True Then
            Count = 1
        End If
        
    End If
    
    
    LookupItemInAllCategories = ItemMatches
        
End Function

Function MyASC(OneChar)
  If OneChar = "" Then MyASC = 0 Else MyASC = Asc(OneChar)
End Function

Public Sub ShowPreferencesDlg()
    Application.EnableEvents = True
    Preferences.Show
End Sub

' modified 07/30/10 by atambe
Public Sub UploadFile()
    ' added 07/30/10 by atambe
    'If bChinaTemplate Then 'changed by sunithab 09-Mar-2010
        If Not CheckSecurityPassword Then Exit Sub
    'End If 'changed by sunithab 09-Mar-2010
    
    'If this is a Japanese template, the Windows codepage must be 932 (NOT 1252) for this to work:
    Dim strTemplateLanguage As String
    Dim iWindowsCodepage As Long
    strTemplateLanguage = GetLocalLanguageName
    If strTemplateLanguage = INT_TABLE_JAPANESE_HEADER Then
        iWindowsCodepage = GetWindowsCodepage
        If iWindowsCodepage <> INT_JAPANESE_CODEPAGE Then
            'can't upload!
'            MsgBox "Unable to upload this template." & _
                   vbNewLine & vbNewLine & _
                   "This template must be running on Japanese Windows and Japanese Excel " & _
                   "to be able to upload." & _
                   vbNewLine & vbNewLine & _
                   "More Information:" & _
                   vbNewLine & _
                   "The active system codepage must be 932 for this template to successfully upload. " & _
                   "The active system codepage is " & iWindowsCodepage & ", not 932. To upload, run " & _
                   "this template in Japanese Windows and Japanese Excel.", _
                   vbCritical + vbOKOnly, "Unable to Upload Template"
            AmazonMsgBox GetTranslatedString("unable_to_upload_1") & _
                   vbNewLine & vbNewLine & _
                   GetTranslatedString("unable_to_upload_2") & _
                   vbNewLine & vbNewLine & _
                   GetTranslatedString("unable_to_upload_3") & _
                   vbNewLine & _
                   GetTranslatedString("unable_to_upload_4") & iWindowsCodepage & GetTranslatedString("unable_to_upload_5"), _
                   vbOKOnly, GetTranslatedString("unable_to_upload_short")
            Exit Sub
        End If
    End If
    
    Dim bUpload As Boolean
    
    'if more than one template sheet, offer to upload all or any combination:
    Dim iTemplateSheetCount As Long
    Dim shTemplateSheet As Worksheet
    iTemplateSheetCount = 0 'init.
    ReDim arrayTemplateSheets(COL_SHEET To COL_VBA_ERROR_DESCRIPTION, _
                              0 To iUboundTemplateSheetArray) As Variant 'init. Don't use the 0 index.
    For Each shTemplateSheet In ThisWorkbook.Worksheets
        'make sure it's a visible sheet:
        If shTemplateSheet.Visible Then
            'make sure it doesn't say "example" in the sheet name:
            If InStr("example", UCase(shTemplateSheet.Name)) = 0 Then
                If Left(shTemplateSheet.CodeName, 10) = "shTemplate" Then
                    iTemplateSheetCount = iTemplateSheetCount + 1
                    ReDim Preserve arrayTemplateSheets(COL_SHEET To COL_VBA_ERROR_DESCRIPTION, _
                                                       0 To iTemplateSheetCount) As Variant 'Don't use the 0 index.
                    arrayTemplateSheets(COL_STATUS, iTemplateSheetCount) = MULTI_TEMPLATE_STATUS_IS_TEMPLATE_SHEET
                    Set arrayTemplateSheets(COL_SHEET, iTemplateSheetCount) = shTemplateSheet
                End If
            End If
        End If
    Next shTemplateSheet
    
    If iTemplateSheetCount = 1 Then 'ONLY ONE TEMPLATE SHEET IN THIS WORKBOOK.**********************************
        bUploadingMultipleTemplateSheets = False: bMultipleTemplateSheetsStopUploading = False
        bMultipleTemplateSheetsShowLoginDlg = False
        ' modified 08/11/10 by atambe
         'changed by sunithab 09-Mar-2010
        'If bChinaTemplate Then
         '   frmUploadFileMWS.Show
        'ElseIf bDisableValidation Then
         '   frmUploadFile.Show
        'Else
         '   If ValidateTemplate(True) Then
         '       frmUploadFile.Show
         '   End If
        'End If
        If bDisableValidation Then
            frmUploadFileMWS.Show
        Else
            If ValidateTemplate(True) Then
                frmUploadFileMWS.Show
            End If
        End If
         'changed by sunithab 09-Mar-2010 END
    Else
        'more than one template sheet:
        
        'validate. If user cancels, don't validate any other sheets:
        Dim bUploadNow As Boolean
        Dim bRetValidation As Boolean
        Dim iArrayIndex As Long, iArrayIndexValidationCancelled As Long
        Dim strMsgText As String
        Dim strMsgboxErrorColumnList As String, strMultiTemplateMsgboxErrorColumnList As String
        Dim iMsgboxErrorColumnCount As Long, iMultiTemplateMsgboxErrorColumnCount As Long
        strMultiTemplateMsgboxErrorColumnList = "": iMultiTemplateMsgboxErrorColumnCount = 0 'init.
        
        ' added 08/11/10 by atambe
        If Not bDisableValidation Then
            For iArrayIndex = 1 To iTemplateSheetCount
                Set shTemplateSheet = arrayTemplateSheets(COL_SHEET, iArrayIndex)
                shTemplateSheet.Activate
                DoEvents
                bRetValidation = ValidateTemplate(, , , , , , , , , True, _
                                                  strMsgboxErrorColumnList, iMsgboxErrorColumnCount)
                If Not bRetValidation Then
                    For iArrayIndexValidationCancelled = iArrayIndex To iTemplateSheetCount
                        arrayTemplateSheets(COL_STATUS, iArrayIndexValidationCancelled) = MULTI_TEMPLATE_STATUS_CANCELLED_VALIDATION
                        arrayTemplateSheets(COL_DLG_COMMENT, iArrayIndexValidationCancelled) = MULTI_TEMPLATE_STATUS_CANCELLED_VALIDATION
                    Next iArrayIndexValidationCancelled
                    Exit For
                End If
                If iMsgboxErrorColumnCount = 0 Then
                    arrayTemplateSheets(COL_STATUS, iArrayIndex) = MULTI_TEMPLATE_STATUS_PASSED_VALIDATION
                    arrayTemplateSheets(COL_DLG_COMMENT, iArrayIndex) = MULTI_TEMPLATE_STATUS_PASSED_VALIDATION
                Else
                    arrayTemplateSheets(COL_STATUS, iArrayIndex) = MULTI_TEMPLATE_STATUS_FAILED_VALIDATION
                    arrayTemplateSheets(COL_DLG_COMMENT, iArrayIndex) = MULTI_TEMPLATE_STATUS_FAILED_VALIDATION
                End If
                strMultiTemplateMsgboxErrorColumnList = strMultiTemplateMsgboxErrorColumnList & strMsgboxErrorColumnList
                iMultiTemplateMsgboxErrorColumnCount = iMultiTemplateMsgboxErrorColumnCount + iMsgboxErrorColumnCount
            Next iArrayIndex
        Else
            iMultiTemplateMsgboxErrorColumnCount = 0
        End If
        
        If iMultiTemplateMsgboxErrorColumnCount > 0 Then
            If iMultiTemplateMsgboxErrorColumnCount = 1 Then
                strMsgboxErrorColumnSingularOrPluralPart = "column has"
            Else
                'iMsgboxErrorColumnCount > 1
                strMsgboxErrorColumnSingularOrPluralPart = "columns have"
            End If
            strMsgText = GetTranslatedString("values_not_valid_1") & _
                   vbNewLine & vbNewLine & _
                   strMultiTemplateMsgboxErrorColumnList & _
                   vbNewLine & vbNewLine & _
                   GetTranslatedString("values_not_valid_2") & _
                   vbNewLine & vbNewLine & _
                   GetTranslatedString("values_not_valid_3")
            If Len(strMsgText) > 1023 Then
                strMsgText = GetTranslatedString("invalid_values_1") & _
                       iMultiTemplateMsgboxErrorColumnCount & GetTranslatedString("invalid_values_2") & _
                       vbNewLine & vbNewLine & _
                       GetTranslatedString("values_not_valid_2") & _
                       vbNewLine & vbNewLine & _
                       GetTranslatedString("values_not_valid_3")
            End If
            iMsgboxRet = AmazonMsgBox(strMsgText, vbYesNo, GetTranslatedString("amazon_validation"))
            If iMsgboxRet = vbYes Then
                bUploadNow = True
            Else
                bUploadNow = False
                iMsgboxRet = AmazonMsgBox(GetTranslatedString("upload_cancelled"), vbOKOnly, GetTranslatedString("amazon_upload"))
                Exit Sub
            End If
        Else
            bUploadNow = True
        End If
        
        'ask user to choose what sheets to upload:
        Dim iListIndex As Long
        Dim strDlgItemText As String
        frmMultiTemplateChooseUploads.lstSelectTemplates.Clear
        frmMultiTemplateChooseUploads.lstSelectTemplates.ColumnCount = 1
        For iArrayIndex = 1 To iTemplateSheetCount
            strDlgItemText = arrayTemplateSheets(COL_SHEET, iArrayIndex).Name & " " & arrayTemplateSheets(COL_DLG_COMMENT, iArrayIndex)
            frmMultiTemplateChooseUploads.lstSelectTemplates.AddItem strDlgItemText
        Next iArrayIndex

        frmMultiTemplateChooseUploads.Show 'True

        For iArrayIndex = 1 To iTemplateSheetCount
            iListIndex = iArrayIndex - 1 'listbox list is 0-based.
            If frmMultiTemplateChooseUploads.lstSelectTemplates.Selected(iListIndex) Then
                arrayTemplateSheets(COL_STATUS, iArrayIndex) = MULTI_TEMPLATE_STATUS_USER_SAYS_UPLOAD
            Else
                arrayTemplateSheets(COL_STATUS, iArrayIndex) = MULTI_TEMPLATE_STATUS_USER_SAYS_NO_UPLOAD
            End If
        Next iArrayIndex
        
        
        
        'upload:
        If frmMultiTemplateChooseUploads.bCancel Then
            AmazonMsgBox GetTranslatedString("upload_cancelled"), vbOKOnly, GetTranslatedString("amazon_upload")
            Exit Sub
        Else
            'get count of template sheets to upload:
            Dim iTemplateSheetsToUploadCount As Long, strActivateSheetIfSingleTemplateSheetUpload As String
            iTemplateSheetsToUploadCount = 0 'init.
            For iArrayIndex = 1 To iTemplateSheetCount
                If arrayTemplateSheets(COL_STATUS, iArrayIndex) = MULTI_TEMPLATE_STATUS_USER_SAYS_UPLOAD Then
                    iTemplateSheetsToUploadCount = iTemplateSheetsToUploadCount + 1
                    'in case this is the only sheet to upload, store its name so it can be acivated:
                    strActivateSheetIfSingleTemplateSheetUpload = arrayTemplateSheets(COL_SHEET, iArrayIndex).Name
                End If
            Next iArrayIndex
            
            'if only one template sheet chose to upload, do it the way it's done with templates
            'that have only one template sheet:
            If iTemplateSheetsToUploadCount = 1 Then
                bUploadingMultipleTemplateSheets = False: bMultipleTemplateSheetsStopUploading = False
                bMultipleTemplateSheetsShowLoginDlg = False
                'activate the single sheet to be uploaded:
                ThisWorkbook.Worksheets(strActivateSheetIfSingleTemplateSheetUpload).Activate
                ' modified 07/30/10 by atambe
                'changed by sunithab 09-Mar-2010
                'If bChinaTemplate Then
                '    frmUploadFileMWS.Show
                'Else
                '    frmUploadFile.Show
                'End If
                frmUploadFileMWS.Show
                 'changed by sunithab 09-Mar-2010 END
                Exit Sub
            End If
            

            'upload the template sheets chosen by the user, of which there are more than one:
            bAllUploadsFailed = True 'init.
            bUploadingMultipleTemplateSheets = True: bMultipleTemplateSheetsStopUploading = False
            bMultipleTemplateSheetsShowLoginDlg = True
            
            ' modified 07/30/10 by atambe
            'changed by sunithab 09-Mar-2010
                'If bChinaTemplate Then
                '    frmUploadFileMWS.Show
                'Else
                '    frmUploadFile.Show
                'End If
                frmUploadFileMWS.Show
                 'changed by sunithab 09-Mar-2010 END
        
            For iArrayIndex = 1 To iTemplateSheetCount
                If arrayTemplateSheets(COL_STATUS, iArrayIndex) = MULTI_TEMPLATE_STATUS_USER_SAYS_UPLOAD Then
                
                            'init for each sheet:
                            bMultipleTemplateSheets_IsUploadSuccess = False
                            
                            strMultipleTemplateSheets_XmlhttpUploadID = ""
                            strMultipleTemplateSheets_XmlhttpUploadType = ""
                            strMultipleTemplateSheets_XmlhttpUploadStatus = ""
                            strMultipleTemplateSheets_XmlhttpUploadDateConvertedToLocalTime = ""
                            
                            bMultipleTemplateSheets_IsXmlhttpError = False
                            strMultipleTemplateSheets_XmlhttpErrorCode = ""
                            strMultipleTemplateSheets_XmlhttpErrorMessage = ""
                            
                            bMultipleTemplateSheets_IsVbaError = False
                            strMultipleTemplateSheets_VbaErrorNumber = ""
                            strMultipleTemplateSheets_VbaErrorDescription = ""
                            
                    arrayTemplateSheets(COL_SHEET, iArrayIndex).Activate
                    DoEvents
                    
                    ' added 07/30/10 by atambe
'                    If bChinaTemplate Then
'                        frmUploadFileMWS.UploadGotClicked (True)
'                    Else
'                        frmUploadFile.UploadGotClicked (True)
'                    End If
                    
                            arrayTemplateSheets(COL_IS_UPLOAD_SUCCESS_BOOL, iArrayIndex) = bMultipleTemplateSheets_IsUploadSuccess
                            arrayTemplateSheets(COL_XMLHTTP_UPLOAD_ID, iArrayIndex) = strMultipleTemplateSheets_XmlhttpUploadID
                            arrayTemplateSheets(COL_XMLHTTP_UPLOAD_TYPE, iArrayIndex) = strMultipleTemplateSheets_XmlhttpUploadType
                            arrayTemplateSheets(COL_XMLHTTP_UPLOAD_STATUS, iArrayIndex) = strMultipleTemplateSheets_XmlhttpUploadStatus
                            arrayTemplateSheets(COL_XMLHTTP_UPLOAD_DATE_CONVERTED_TO_LOCAL_TIME, iArrayIndex) = strMultipleTemplateSheets_XmlhttpUploadDateConvertedToLocalTime
                            arrayTemplateSheets(COL_IS_XMLHTTP_ERROR, iArrayIndex) = bMultipleTemplateSheets_IsXmlhttpError
                            arrayTemplateSheets(COL_XMLHTTP_ERROR_CODE, iArrayIndex) = strMultipleTemplateSheets_XmlhttpErrorCode
                            arrayTemplateSheets(COL_XMLHTTP_ERROR_MESSAGE, iArrayIndex) = strMultipleTemplateSheets_XmlhttpErrorMessage
                            arrayTemplateSheets(COL_IS_VBA_ERROR, iArrayIndex) = bMultipleTemplateSheets_IsVbaError
                            arrayTemplateSheets(COL_VBA_ERROR_NUMBER, iArrayIndex) = strMultipleTemplateSheets_VbaErrorNumber
                            arrayTemplateSheets(COL_VBA_ERROR_DESCRIPTION, iArrayIndex) = strMultipleTemplateSheets_VbaErrorDescription
                            
                            If bMultipleTemplateSheets_IsUploadSuccess Then bAllUploadsFailed = False
                    
                End If
                If bMultipleTemplateSheetsStopUploading Then Exit For
            Next iArrayIndex
        End If
    
    'show dialog with templates' upload finished status:
    frmMultiTemplateDoneUploading.lstTemplates.Clear
    frmMultiTemplateDoneUploading.lstTemplates.ColumnCount = 3
    frmMultiTemplateDoneUploading.lstTemplates.ColumnWidths = "85;-1;0"
    iListIndex = -1 'init. Will be set to 0 before first use. listbox list is 0-based.
    For iArrayIndex = 1 To iTemplateSheetCount
        If arrayTemplateSheets(COL_STATUS, iArrayIndex) = MULTI_TEMPLATE_STATUS_USER_SAYS_UPLOAD Then
            iListIndex = iListIndex + 1
            '==============================================================================================
            '==============================================================================================
            '==============================================================================================
            'WORK IN PROGRESS, PUT ON HOLD 2010-07-21 10AM:
            'populate frmMultiTemplateDoneUploading form with data from arrayTemplateSheets, so that
            'user sees list of templates, can click on each one for more information.
            '==============================================================================================
            '==============================================================================================
            '==============================================================================================
            
            
            If arrayTemplateSheets(COL_IS_UPLOAD_SUCCESS_BOOL, iArrayIndex) Then
                strDlgItemText = "Upload SUCCESS:"
            Else
                strDlgItemText = "Upload FAILURE:"
            End If
            frmMultiTemplateDoneUploading.lstTemplates.AddItem "AddItem"
            frmMultiTemplateDoneUploading.lstTemplates.Column(LISTBOX_COL_A, iListIndex) = strDlgItemText
            frmMultiTemplateDoneUploading.lstTemplates.Column(LISTBOX_COL_B, iListIndex) = arrayTemplateSheets(COL_SHEET, iArrayIndex).Name
            frmMultiTemplateDoneUploading.lstTemplates.Column(LISTBOX_COL_C, iListIndex) = iArrayIndex
    
            
        End If
    Next iArrayIndex

    frmMultiTemplateDoneUploading.Show
        
    End If
    
End Sub



' modified 07/30/10 by atambe
Public Function DoUploadFile(file As String, Optional username As String, Optional password As String, Optional sUploadType As String, Optional uploading_multiple_template_sheets As Boolean) As Boolean   ' added 07/30/10 by atambe
        On Error GoTo ErrorHandler
        
        DoUploadFile = False
        
        Dim bUploadingMultiple As Boolean
        bUploadingMultiple = uploading_multiple_template_sheets
        
'        If Not HttpReq Is Nothing Then Set HttpReq = Nothing 'converting to late binding.
        Dim httpreq As Object 'IXMLHTTPRequest
        Dim sContactURL As String
'        sContactURL = "https://merchant-query.amazon.com/query/?Service=MerchantQueryService&Action=upload&confirmed=true&purgeAndReplace=false&uploadType=" & sUploadType
        
        Dim sFeedType As String
        
        ' added 07/30/10 by atambe
         'changed by sunithab 09-Mar-2010
        'If bChinaTemplate Then
            sContactURL = GetLocalURL(URL_HEADER_MWS)
            sFeedType = ThisWorkbook.Names(FEED_TYPE_DEFINED_NAME).RefersToRange.value
            sContactURL = sContactURL & "&Action=SubmitFeed&PurgeAndReplace=false&FeedType=" & sFeedType
        'Else
        '    sContactURL = GetLocalURL(URL_HEADER_CONTACT) & sUploadType
        'End If
         'changed by sunithab 09-Mar-2010 END
        'check for devo contact (upload) url:
        Dim strDevoContactURL As String
        strDevoContactURL = ThisWorkbook.Names("Devo_Upload_URL").RefersToRange.value
        If strDevoContactURL = "" Then
            'use production contact url.    2010-06-04: No. Adding section below:
            '=================================================================
            '2010-06-04, Greg Lovern:
            'Devo upload url is blank. That could mean this is prod, or it could mean
            'a devo tester forgot or didn't know to enter the devo upload url.
            'So, check whether "Is Beta" (IS_DEVO_DEFINED_NAME) is true or false. If true, prompt user
            'to enter the devo upload url, to avoid confusing and blocking the
            'devo tester. If false, upload to prod:
            If UCase(ThisWorkbook.Names(IS_DEVO_DEFINED_NAME).RefersToRange.value) = "FALSE" Then
                'upload to prod.
            Else
                'prompt user to enter the devo upload url:
                Dim iRet As Long
                AmazonMsgBox "This template is set to upload to Devo, but no Devo upload URL is provided." & _
                vbNewLine & vbNewLine & _
                "If you are an Amazon vendor uploading product to sell on Amazon.com, contact Seller Central or your TAM for a production version of this flat-file template." & _
                vbNewLine & vbNewLine & vbNewLine & _
                "If you are an Amazon employee running test procedures on this flat-file template, unhide the ''International Settings'' sheet. Then: " & _
                vbNewLine & vbNewLine & _
                "If you want to upload to Devo, hover your mouse over the cell labeled ''Devo Upload URL''" & _
                " and follow the instructions in the cell comment that pops up to copy the desired" & _
                " Devo upload URL to the cell." & _
                vbNewLine & vbNewLine & _
                "If you want to upload to Prod, select the cell labeled ''Is Devo'' and click its dropdown" & _
                " to select False." & _
                vbNewLine & vbNewLine & _
                "When done, try uploading again.", vbOKOnly, "Devo URL Missing"
                
                ' added 07/30/10 by atambe
                 'changed by sunithab 09-Mar-2010
                'If bChinaTemplate Then
                    Unload frmUploadFileMWS
                'Else
                '    Unload fromuploadfile
                'End If
                 'changed by sunithab 09-Mar-2010 END
                DoEvents
                AmazonMsgBox GetTranslatedString("upload_cancelled"), vbOKOnly, GetTranslatedString("amazon_upload")
                
                'DO NOT PROCEED TO ATTEMPT UPLOAD:
                DoUploadFile = False
                bMultipleTemplateSheetsStopUploading = True
                Exit Function
                
            End If
            '=================================================================
        Else
            ' added 08/02/10 by atambe
             'changed by sunithab 09-Mar-2010
             'If bChinaTemplate Then
                sContactURL = strDevoContactURL
                sContactURL = sContactURL & "&Action=SubmitFeed&PurgeAndReplace=false&FeedType=" & sFeedType
            'Else
             '   'use devo contact url.
             '   sContactURL = strDevoContactURL & sUploadType
            'End If
             'changed by sunithab 09-Mar-2010 END
        End If
        
        If sContactURL = "" Then
            DoUploadFile = False
            Exit Function
        End If
        
'        Dim sText As String 'replaced by vText
        Dim vText As Variant 'must be Variant for late-binding.
'        sText = amazonGlobals.GetText(file)
        vText = amazonGlobals.GetText(file)
        Dim bytearrayUploadText() As Byte
        Dim vArray As Variant 'declare as variant, not array.
        
        bytearrayUploadText = vText 'convert string to byte array (for JP).
        vArray = bytearrayUploadText 'for JP, send as Shift-JIS byte array wrapped in Variant.
        
        'changed by sunithab 09-Mar-2010
        'If bChinaTemplate Then
            frmUploadFileMWS.UpdateStatus GetTranslatedString("decrypting_mws_credentials")    ' added 07/30/10 by atambe
        'End If
        'changed by sunithab 09-Mar-2010 END
        
        ' added 07/30/10 by atambe
        Dim marketplaceID As String
        Dim merchantID As String
        Dim accessKeyID As String
        Dim secretAccessKey As String
        Dim signedURL As String
        
        ' added 07/30/10 by atambe
        'changed by sunithab 09-Mar-2010
        'If bChinaTemplate Then
            DecryptCredentials marketplaceID, merchantID, accessKeyID, secretAccessKey, GetSecurityPassword
            
            frmUploadFileMWS.MarketplaceLabel.Caption = marketplaceID
            frmUploadFileMWS.MerchantLabel.Caption = merchantID
            frmUploadFileMWS.AccessKeyLabel.Caption = accessKeyID
            
            signedURL = GetSignedURL(sContactURL, marketplaceID, merchantID, accessKeyID, secretAccessKey)
        'End If
        'changed by sunithab 09-Mar-2010 END
        
        Dim csUserNamePassword As String
            
        ' added 07/30/10 by atambe
        'changed by sunithab 09-Mar-2010
        'If Not bChinaTemplate Then
        '    csUserNamePassword = username & ":" & password
        'End If
         'changed by sunithab 09-Mar-2010 END
         
        ' added 07/30/10 by atambe
        'changed by sunithab 09-Mar-2010
        'If bChinaTemplate Then
            CreateMWSRequestObject signedURL, httpreq
            httpreq.setRequestHeader "Content-MD5", GetContentMD5File(file)
            If GetLocalLanguageName = INT_TABLE_JAPANESE_HEADER Then
                httpreq.setRequestHeader "Content-Type", "text/tab-separated-values; charset=Shift_JIS"
            ElseIf GetLocalLanguageName = INT_TABLE_CHINESE_HEADER Then
                httpreq.setRequestHeader "Content-Type", "text/tab-separated-values; charset=UTF-8"
            Else
                httpreq.setRequestHeader "Content-Type", "text/tab-separated-values; charset=iso-8859-1"
            End If
        'Else
    '        Dim HttpReq As New MSXML2.XMLHTTP30 'converting to late binding.
          '  Set httpreq = Get_XMLHTTP_Object()
            
           ' Call httpreq.Open(bstrmethod:="POST", bstrurl:=sContactURL, varAsync:=False)
           ' Call httpreq.setRequestHeader("Authorization", "Basic " + Base64Encode(csUserNamePassword)) ' modified 07/30/10 by atambe
            
    '        Stop
           ' httpreq.setRequestHeader "Content-Type", "text/xml"
    '        Call httpreq.setRequestHeader("Content-Type", "text/xml;charset=shift-jis")
                '4/29/08:
                'maybe need to set charset on the above line; found these examples with random charsets:
                    'httpreq.setRequestHeader   ("Content-type:",   "text/xml;   charset=gb2312")
                    'oXMLHTTP.setRequestHeader "Content-Type", "text/xml;charset=ISO-8859-1"
                    'pIXMLHTTPRequest->setRequestHeader("ContentType", "text/html;charset=UTF-8");
                    'oXMLHTTP.setRequestHeader('Content-Type', 'application/xml;charset=UTF-8');
                'also see:
                'http://www.experts-exchange.com/Web_Development/Web_Languages-Standards/XML/Q_20875679.html?qid=20875679
                'http://msdn.microsoft.com/library/default.asp?url=/library/en-us/xmlsdk30/htm/xmmthsendixmlhttprequest.asp
                'http://en.wikipedia.org/wiki/ISO/IEC_2022
                'http://a4esl.org/c/charset.html
                'also found this comment:
                '"the expected encoding is always ISO/IEC 8859-1, being the default HTTP charset ever since."
       ' End If
         'changed by sunithab 09-Mar-2010 END
         
        ' added 07/30/10 by atambe
        'changed by sunithab 09-Mar-2010
        'If bChinaTemplate Then
            frmUploadFileMWS.UpdateStatus (GetTranslatedString("sending_feed"))
        'Else
        '    frmUploadFile.UpdateStatus (GetTranslatedString("sending_feed"))
        'End If
         'changed by sunithab 09-Mar-2010 END
'        Call HttpReq.send(sText)

        ' added 07/30/10 by atambe
         'changed by sunithab 09-Mar-2010
        'If Not bChinaTemplate Then
        '    SendKeys "{ESC}" 'dismiss Windows login dialog that appears if credentials are bad.
        'End If
         'changed by sunithab 09-Mar-2010 END
        
'        Call httpreq.send(vText)
'        Call httpreq.send(bytearrayUploadText)
        Call httpreq.send(vArray)

        ' added 07/30/10 by atambe
         'changed by sunithab 09-Mar-2010
        'If bChinaTemplate Then
            frmUploadFileMWS.UpdateStatus (GetTranslatedString("response_received"))
        'Else
        '    frmUploadFile.UpdateStatus (GetTranslatedString("response_received"))
        'End If
         'changed by sunithab 09-Mar-2010 END
         
        Dim xmldoc As Object 'MSXML2.DOMDocument
    
        ' added 07/30/10 by atambe
         'changed by sunithab 09-Mar-2010
        'If bChinaTemplate Then
            CreateMWSResponseObject xmldoc, httpreq
        'Else
    '        Dim xmldoc As New MSXML2.DOMDocument 'converting to late binding.
         '   Set xmldoc = Get_XML_DOMDocument_Object()
            
    '        xmldoc.LoadXML (Trim(amazonGlobals.HttpReq.responseText)) 'converting to late binding.
          '  xmldoc.LoadXML (Trim(httpreq.responseText))
        'End If
         'changed by sunithab 09-Mar-2010 END
    
        Dim UploadId As String, UploadType As String, UploadStatus As String, SubmittedDate As String
        Dim ErrorCode As String, ErrorMessage As String

        If xmldoc.ChildNodes.Length = 0 Then
            'there are no childnodes. This happened to Derek during QA. Resolved by rebooting his computer.
            bMultipleTemplateSheets_IsUploadSuccess = False
            bMultipleTemplateSheets_IsXmlhttpError = True
            strMultipleTemplateSheets_XmlhttpErrorCode = GetTranslatedString("incomplete_response") 'for single uploads too.
            strMultipleTemplateSheets_XmlhttpErrorMessage = GetTranslatedString("unable_to_evaluate") 'for single uploads too.
            
            ' added 07/30/10 by atambe
             'changed by sunithab 09-Mar-2010
            'If bChinaTemplate Then
                frmUploadFileMWS.ShowUploadFailedResults strMultipleTemplateSheets_XmlhttpUploadID, strMultipleTemplateSheets_XmlhttpErrorMessage
            'Else
            '    frmUploadFile.ShowUploadFailedResults strMultipleTemplateSheets_XmlhttpUploadID, strMultipleTemplateSheets_XmlhttpErrorMessage
            'End If
             'changed by sunithab 09-Mar-2010 END
             
            DoUploadFile = False
            Exit Function
        End If

        If xmldoc.ChildNodes(1).BaseName = "ErrorResponse" Then
            bMultipleTemplateSheets_IsUploadSuccess = False
            bMultipleTemplateSheets_IsXmlhttpError = True
            ErrorCode = xmldoc.getElementsByTagName("Code").Item(0).Text
            strMultipleTemplateSheets_XmlhttpErrorCode = "My xmlhttp error code" 'for debugging
            strMultipleTemplateSheets_XmlhttpErrorCode = ErrorCode
            ErrorMessage = xmldoc.getElementsByTagName("Message").Item(0).Text
            strMultipleTemplateSheets_XmlhttpErrorMessage = "My xmlhttp error message." 'for debugging
            strMultipleTemplateSheets_XmlhttpErrorMessage = ErrorMessage
            If Not bUploadingMultipleTemplateSheets Then
                ' added 07/30/10 by atambe
                 'changed by sunithab 09-Mar-2010
                'If bChinaTemplate Then
                    ResetSecurityPassword
                    frmUploadFileMWS.ShowUploadFailedResults ErrorCode, ErrorMessage
                'Else
                '    frmUploadFile.ShowUploadFailedResults ErrorCode, ErrorMessage   ' removed leading space character 07/30/10 by atambe
                'End If
                 'changed by sunithab 09-Mar-2010 END
                
            End If
            DoUploadFile = False
            Exit Function
            
        ElseIf xmldoc.ChildNodes(1).BaseName = "Response" Then
            bMultipleTemplateSheets_IsUploadSuccess = True
            UploadId = xmldoc.getElementsByTagName("UploadId").Item(0).Text
            strMultipleTemplateSheets_XmlhttpUploadID = "My xmlhttp 'UploadId'" 'for debugging
            strMultipleTemplateSheets_XmlhttpUploadID = UploadId
            UploadType = xmldoc.getElementsByTagName("UploadType").Item(0).Text
            strMultipleTemplateSheets_XmlhttpUploadType = "My xmlhttp 'UploadType'" 'for debugging
            strMultipleTemplateSheets_XmlhttpUploadType = UploadType
            UploadStatus = xmldoc.getElementsByTagName("UploadStatus").Item(0).Text
            strMultipleTemplateSheets_XmlhttpUploadStatus = "My xmlhttp 'UploadStatus'" 'for debugging
            strMultipleTemplateSheets_XmlhttpUploadStatus = UploadStatus
            SubmittedDate = xmldoc.getElementsByTagName("SubmittedDate").Item(0).Text
                'this returns GMT. Convert it to local time:
                Dim iYear As Integer
                Dim iMonth As Integer
                Dim iDay As Integer
                Dim iHour As Integer
                Dim iMinute As Integer
                Dim iSecond As Integer
                Dim dateSubmittedDateVB As Date
                Dim dateLocalDateVB As Date
                Dim strLocalDate As String
                Dim strDisplayDateEntireString As String
                iYear = CInt(Left(SubmittedDate, 4))
                iMonth = CInt(Mid(SubmittedDate, 6, 2))
                iDay = CInt(Mid(SubmittedDate, 9, 2))
                iHour = CInt(Mid(SubmittedDate, 12, 2))
                iMinute = CInt(Mid(SubmittedDate, 15, 2))
                iSecond = CInt(Mid(SubmittedDate, 18, 2))
                dateSubmittedDateVB = DateSerial(iYear, iMonth, iDay) + _
                                      TimeSerial(iHour, iMinute, iSecond)
                dateLocalDateVB = GetLocalTimeFromGMT(dateSubmittedDateVB)
                strLocalDate = Format(dateLocalDateVB, "yyyy-mm-dd h:mm:ss AM/PM")
                strDisplayDateEntireString = strLocalDate & " (local time)"
                strMultipleTemplateSheets_XmlhttpUploadDateConvertedToLocalTime = "My xmlhttp 'SubmittedDate' converted to local time" 'for debugging
                strMultipleTemplateSheets_XmlhttpUploadDateConvertedToLocalTime = strDisplayDateEntireString
                
            If Not bUploadingMultipleTemplateSheets Then
    '            frmUploadFile.ShowUploadResults UploadId, UploadType, UploadStatus, SubmittedDate
                ' added 07/30/10 by atambe
                 'changed by sunithab 09-Mar-2010
                'If bChinaTemplate Then
                    frmUploadFileMWS.ShowUploadResults UploadId, UploadType, UploadStatus, strDisplayDateEntireString
                'Else
                '    frmUploadFile.ShowUploadResults UploadId, UploadType, UploadStatus, strDisplayDateEntireString
                'End If
                 'changed by sunithab 09-Mar-2010 END
            End If
                
        ' added 07/30/10 by atambe
        ElseIf xmldoc.ChildNodes(1).BaseName = "SubmitFeedResponse" Then
            Dim status1 As String
            UploadId = xmldoc.getElementsByTagName("FeedSubmissionId").Item(0).Text
            UploadType = xmldoc.getElementsByTagName("FeedType").Item(0).Text
            SubmittedDate = xmldoc.getElementsByTagName("SubmittedDate").Item(0).Text
            status1 = xmldoc.getElementsByTagName("FeedProcessingStatus").Item(0).Text
            UploadStatus = Trim(Replace(status1, "_", " "))
            
            frmUploadFileMWS.ShowUploadResults UploadId, UploadType, UploadStatus, SubmittedDate
    
        Else
            bMultipleTemplateSheets_IsXmlhttpError = True
            strMultipleTemplateSheets_XmlhttpErrorCode = GetTranslatedString("unknown_response") 'for single uploads too.
            strMultipleTemplateSheets_XmlhttpErrorMessage = "My xmlhttp 'responseText'" 'for debugging. 'for single uploads too.
            strMultipleTemplateSheets_XmlhttpErrorMessage = Trim(httpreq.responseText) 'for single uploads too.
            If Not bUploadingMultipleTemplateSheets Then
    '            frmUploadFile.ShowUploadFailedResults "Unknown response received.", Trim(amazonGlobals.HttpReq.responseText) 'converting to late binding.
                ' added 07/30/10 by atambe
                 'changed by sunithab 09-Mar-2010
                'If bChinaTemplate Then
                    frmUploadFileMWS.ShowUploadFailedResults strMultipleTemplateSheets_XmlhttpErrorCode, strMultipleTemplateSheets_XmlhttpErrorMessage
                'Else
                '    frmUploadFile.ShowUploadFailedResults strMultipleTemplateSheets_XmlhttpErrorCode, strMultipleTemplateSheets_XmlhttpErrorMessage
                'End If
                 'changed by sunithab 09-Mar-2010 END
            End If
            DoUploadFile = False
            Exit Function
        End If
        DoUploadFile = True
        Exit Function
        
ErrorHandler:
        If bUploadingMultipleTemplateSheets Then
            bMultipleTemplateSheets_IsVbaError = True
            strMultipleTemplateSheets_VbaErrorNumber = "999" 'for debugging.  'for single uploads too.
            strMultipleTemplateSheets_VbaErrorNumber = Err.Number
            strMultipleTemplateSheets_VbaErrorDescription = GetTranslatedString("unknown_error") & " " & "My error description." & """" 'for debugging. 'for single uploads too.
            strMultipleTemplateSheets_VbaErrorDescription = GetTranslatedString("unknown_error") & " " & Err.Description & """"  'for single uploads too.
        Else
            'single template upload:
            Beep
            strMultipleTemplateSheets_VbaErrorNumber = " Error #" & Err.Number  'for single uploads too.
            strMultipleTemplateSheets_VbaErrorDescription = " " & "An unknown error occurred: """ & Err.Description & """" 'for single uploads too.
            ' added 07/30/10 by atambe
             'changed by sunithab 09-Mar-2010
            'If bChinaTemplate Then
                ResetSecurityPassword
                frmUploadFileMWS.ShowUploadFailedResults strMultipleTemplateSheets_VbaErrorNumber, strMultipleTemplateSheets_VbaErrorDescription
            'Else
            '    frmUploadFile.ShowUploadFailedResults strMultipleTemplateSheets_VbaErrorNumber, strMultipleTemplateSheets_VbaErrorDescription
            'End If
             'changed by sunithab 09-Mar-2010 END
        End If
        DoUploadFile = False
        If False Then
            Resume
        End If
End Function

Function GetText(sFile As String) As String
    Dim nSourceFile As Integer, sText As String

    On Error GoTo GenErr

    'REMOVE AFTER TESTING:
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    'for testing JP at Greg's desk only:
'    Stop
    If False Then
        'switch to text file saved out from JP Excel:
        Dim sJPFile As String
        sJPFile = "C:\_GJL\Release 1.9\Work\JP Apparel File saved out as xlText (plain text)\rad2E966.tmp.txt"
        sFile = sJPFile
    End If


    ''Get the number of the next free text file
    nSourceFile = FreeFile
    
    ''Write the entire file to sText
    '   Open sFile For Input As #nSourceFile
    '   sText = Input$(LOF(1), 1)
    Open sFile For Binary As #nSourceFile 'GJL 4/24/08 for JP.
    sText = InputB$(LOF(1), 1) 'GJL 4/24/08 for JP.
    Close #nSourceFile

   GetText = sText

    Exit Function

GenErr:
    If False Then
        Debug.Print Err.Description
        Resume
    End If
Exit Function
End Function

Function GetLocalURL(url_category As String) As String
'Greg Lovern 11-20-07, 4-25-08
Dim rgFind As Range
Dim iLocalRow As Long
Dim iUrlCol As Long
Dim strLocalLanguage As String
Dim strSecondaryLanguage As String

On Error GoTo GenErr

'get local and secondary languages:
strLocalLanguage = GetLocalLanguageName()
strSecondaryLanguage = GetLocalLanguageName(True)

'get the URL column for the local URL:
Set rgFind = shIntURLs.Cells.Find(What:=url_category, LookAt:=xlWhole)
Call ResetFindParametersToDefaults
If rgFind Is Nothing Then
    shIntURLs.Visible = xlSheetVisible
    shIntURLs.Activate
    DoEvents
'    MsgBox "Unable to find the upload URL column header." & _
           vbNewLine & vbNewLine & _
           "Please fix on the 'International URLs' worksheet and restart."
    AmazonMsgBox GetTranslatedString("unable_to_find_column_header")
    Exit Function
End If
iUrlCol = rgFind.Column


'get the section range in which to look for the language and url:
Dim iSectionTopRow As Long
Dim iSectionBottomRow As Long
Dim rgLookIn As Range
iSectionTopRow = rgFind.Row
Set rgLookIn = shIntURLs.Range( _
                    shIntURLs.Cells(iSectionTopRow, 1), _
                    shIntURLs.Cells(shIntURLs.Rows.Count, shIntURLs.Columns.Count))
Set rgFind = rgLookIn.Find(What:=URL_HEADER_SECTION_END_TEXT, LookAt:=xlWhole)
Call ResetFindParametersToDefaults
If rgFind Is Nothing Then
    'assume this is the last section and there is no ENDSECTION marker after it.
    iSectionBottomRow = shIntURLs.Rows.Count
Else
    iSectionBottomRow = rgFind.Row
End If
Set rgLookIn = shIntURLs.Range( _
                    shIntURLs.Cells(iSectionTopRow, 1), _
                    shIntURLs.Cells(iSectionBottomRow, shIntURLs.Columns.Count))



'get the row of the language of the local upload URL:
Set rgFind = rgLookIn.Find(What:=strLocalLanguage, LookAt:=xlWhole)
Call ResetFindParametersToDefaults
If rgFind Is Nothing Then
    Set rgFind = rgLookIn.Find(What:=strSecondaryLanguage, LookAt:=xlWhole)
    Call ResetFindParametersToDefaults
End If
If rgFind Is Nothing Then
    shIntURLs.Visible = xlSheetVisible
    shIntURLs.Activate
    DoEvents
'    MsgBox "Unable to find the URL for uploading the " & target_language & " template." & _
           vbNewLine & vbNewLine & _
           "Please fix on the 'International URLs' worksheet and restart."
    AmazonMsgBox GetTranslatedString("unable_to_find_url_1") & target_language & GetTranslatedString("unable_to_find_url_2")
    Exit Function
End If
iLocalRow = rgFind.Row


'get the upload URL:
GetLocalURL = shIntURLs.Cells(iLocalRow, iUrlCol).value

Exit Function

GenErr:
If False Then
    Resume
End If

End Function


Attribute VB_Name = "clsExcelAppEvents"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'Greg Lovern
'http://PrecisionCalc.com

Option Explicit

'Excel Application-Level Events:

Public WithEvents ExcelApp As Application 'Required for Excel application-level events. Must be in a Class Module.
Attribute ExcelApp.VB_VarHelpID = -1

Attribute VB_Name = "frmAmazonMsgBox"
Attribute VB_Base = "0{E71502AC-8888-4AFC-BE31-8767687C0C4F}{039C1CB7-2B22-45CF-82C1-3587C2839E5D}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
' Modified for CN Launch
' Abhijit Tambe, August 2010

Option Explicit

Private Sub UserForm_Initialize()
    iAmazonMsgBoxRet = -1 'indicates user cancelled the form.
                          'Must unload form or init iAmazonMsgBoxRet to -1 after every use.

    ' added 08/15/10 by atambe
    If bChinaTemplate Then
        imgAmazonServices.Visible = False
        imgAmazonJoyo.Visible = True
    End If
End Sub

Private Sub imgOkay_Click()
    iAmazonMsgBoxRet = 1
    Me.Hide
End Sub

Private Sub imgCancel_Click()
    iAmazonMsgBoxRet = 2
    Me.Hide
End Sub

Private Sub imgYes_Click()
    iAmazonMsgBoxRet = 6
    Me.Hide
End Sub

Private Sub ImgNo_Click()
    iAmazonMsgBoxRet = 7
    Me.Hide
End Sub

Private Sub UserForm_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If KeyAscii = 13 Or KeyAscii = 32 Then
        'User pressed Enter or Tab on the form:
        iAmazonMsgBoxRet = iAmazonMsgBoxDefaultRet
        Me.Hide
    End If
End Sub
Attribute VB_Name = "frmAutoIntUpdateInterval"
Attribute VB_Base = "0{30FEBA75-CA97-4C16-BB64-31A20FC87192}{B8302401-C99B-455D-B3C5-72B3736F52D7}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'Greg Lovern
'http://PrecisionCalc.com

' Modified for CN Launch
' Abhijit Tambe, August 2010

Dim vInterval As Variant


Private Sub imgCancel_Click()
    bUpdateNow = False
    Me.Hide
End Sub

Private Sub imgUpdate_Click()

If Me.optYes Then
    ThisWorkbook.Names(AUTO_UPDATE_DEFINED_NAME).RefersToRange.value = True
Else
    ThisWorkbook.Names(AUTO_UPDATE_DEFINED_NAME).RefersToRange.value = False
End If

ThisWorkbook.Names(UPDATE_INTERVAL_DAYS_DEFINED_NAME).RefersToRange.value = Me.txtDaysCount

bUpdateNow = True
Me.Hide

End Sub


Private Sub OptNo_Click()
    Me.txtDaysCount.Enabled = False
    Me.lblDaysCount.Enabled = False
    Me.lblEachTime.Enabled = False
End Sub

Private Sub optYes_Click()
    Me.txtDaysCount.Enabled = True
    Me.lblDaysCount.Enabled = True
    Me.lblEachTime.Enabled = True
End Sub

Private Sub txtDaysCount_Enter()
    vInterval = Me.txtDaysCount
End Sub

Private Sub txtDaysCount_Exit(ByVal Cancel As MSForms.ReturnBoolean)

On Error GoTo Err1

Me.txtDaysCount = CInt(Me.txtDaysCount)

Exit Sub

Err1:

'MsgBox "Interval must be a number.", vbCritical + vbOKOnly, "Invalid Interval"
AmazonMsgBox GetTranslatedString("interval_must_be_number"), vbOKOnly, GetTranslatedString("invalid_interval")
Me.txtDaysCount = vInterval

End Sub

Private Sub UserForm_Initialize()
' added 10/12/10 by atambe
TranslateFormControls Me

' added 08/15/10 by atambe
If bChinaTemplate Then
    imgAmazonServices.Visible = False
    imgAmazonJoyo.Visible = True
End If

Dim vAutoUpdate As Variant
Dim vUpdateInterval As Variant

On Error GoTo Err1

vAutoUpdate = ThisWorkbook.Names(AUTO_UPDATE_DEFINED_NAME).RefersToRange.value
vUpdateInterval = ThisWorkbook.Names(UPDATE_INTERVAL_DAYS_DEFINED_NAME).RefersToRange.value

If vAutoUpdate Then
    Me.optYes = True
Else
    Me.OptNo = True
End If

Me.txtDaysCount = CInt(vUpdateInterval)


Exit Sub

Err1:

Me.txtDaysCount = 0

End Sub
Attribute VB_Name = "frmBrowseImportFile"
Attribute VB_Base = "0{6625977F-1625-4FFA-9EAC-52EE6DCA2E2F}{E3D0E41B-1000-4F6F-91B8-2454A461B5D8}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
' Modified for CN Launch
' Abhijit Tambe, August 2010

Option Explicit

Public bCancel As Boolean
Dim strImportPath As String
Dim strPathLast4Chars As String
Public bDelimCharIsTab As Boolean
Public bDelimCharIsComma As Boolean
Dim iFormHeight As Long

Private Sub imgBrowse_Click()
    Me.Hide
    DoEvents
    strImportPath = Application.GetOpenFilename(, , GetTranslatedString("browse_file"))
    If strImportPath = "False" Then
        'user clicked Cancel.
    Else
        frmBrowseImportFile.txtBrowseImportFile = strImportPath
        

        'check whether to open as text file:
        strPathLast4Chars = UCase(Right(strImportPath, 4))
            bDelimCharIsTab = False 'init.
            bDelimCharIsComma = False 'init.
        If strPathLast4Chars = ".TXT" Then
            bDelimCharIsTab = True
            bDelimCharIsComma = False
        ElseIf strPathLast4Chars = ".CSV" Then
            bDelimCharIsComma = True
            bDelimCharIsTab = False
        End If
        
        If bDelimCharIsTab Or bDelimCharIsComma Then
            'open as text, so allow user to choose codepage:
            Me.Height = 309
        Else
            'not a textfile:
            Me.Height = 212
        End If
        
    End If
    
    Me.Show
End Sub

Private Sub imgCancel_Click()
Me.Hide
bCancel = True
End Sub

Private Sub imgChangeCodepage_Click()
Dim iTextFileCodepage As Long
Me.Hide
DoEvents
iTextFileCodepage = GetTextFileCodepage(frmBrowseImportFile.lblCodepage)
If iTextFileCodepage > -1 Then '-1 indicates error returned from GetTextFileCodepage.
    frmBrowseImportFile.lblCodepage = iTextFileCodepage
End If
Me.Show
End Sub

Private Sub imgOkay_Click()
Me.Hide
End Sub

Private Sub lstPickCodepage_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
Me.cmdOkay = True
End Sub

Private Sub UserForm_Activate()
bCancel = False
'Me.Height = iFormHeight
End Sub

Private Sub UserForm_Initialize()
' added 10/12/10 by atambe
TranslateFormControls Me

Me.Height = 212

' added 08/15/10 by atambe
If bChinaTemplate Then
    imgAmazonServices.Visible = False
    imgAmazonJoyo.Visible = True
End If
End Sub
Attribute VB_Name = "frmBrowser"
Attribute VB_Base = "0{ED167E64-FEDB-402A-994C-23A75DF2B928}{69518AA6-27BB-4803-8445-883C2926864B}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False


' Added for MWS Integration
' Abhijit Tambe, August 2010


Private Sub UserForm_Activate()
    WebBrowser.Navigate GetLocalURL(URL_HEADER_CREDENTIALS)
End Sub


Private Sub UserForm_Initialize()
    ' added 10/12/10 by atambe
    TranslateFormControls Me
End Sub


Private Sub WebBrowser_BeforeNavigate2(ByVal pDisp As Object, URL As Variant, Flags As Variant, TargetFrameName As Variant, PostData As Variant, Headers As Variant, Cancel As Boolean)
    If URL <> GetLocalURL(URL_HEADER_CREDENTIALS_SUMMARY) Then
        Me.StatusValueLabel.Caption = GetTranslatedString("loading")
    End If
End Sub


Private Sub WebBrowser_DocumentComplete(ByVal pDisp As Object, URL As Variant)
    If URL = GetLocalURL(URL_HEADER_CREDENTIALS_SUMMARY) Then
        On Error GoTo ErrorHandler
        
        Dim Length As Integer
        Dim i As Integer
        Dim htmlElement

        Length = WebBrowser.Document.getElementsByTagName("div").Length
        
        For i = 1 To Length
            Set htmlElement = WebBrowser.Document.getElementsByTagName("div").Item(i)
            If htmlElement.getAttribute("id") = "mwsCredentials" Then
                ExtractMWSCredentials htmlElement.innerhtml
                Exit Sub
            End If
        Next
        
        AmazonMsgBox GetTranslatedString("registration_complete_long"), vbOKOnly, GetTranslatedString("registration_complete")
    End If
    
    Exit Sub
    
ErrorHandler:
    AmazonMsgBox GetTranslatedString("registration_complete_long"), vbOKOnly, GetTranslatedString("registration_complete")
End Sub


Private Sub WebBrowser_NavigateComplete2(ByVal pDisp As Object, URL As Variant)
    If URL = GetLocalURL(URL_HEADER_CREDENTIALS_PROCESSOR) Then
        Me.StatusValueLabel.Caption = GetTranslatedString("mws_please_wait")
    Else
        Me.StatusValueLabel.Caption = ""
    End If
End Sub


Private Sub ExtractMWSCredentials(Text As String)
    Set xmldoc = Nothing
    DoEvents
    Set xmldoc = Get_XML_DOMDocument_Object()
    xmldoc.LoadXML (Trim(Text))

    frmCredentials.MerchantIDBox = xmldoc.getElementsByTagName("merchantid").Item(0).Text
    frmCredentials.MarketplaceIDBox = xmldoc.getElementsByTagName("marketplaceid").Item(0).Text
    frmCredentials.AccessKeyIDBox = xmldoc.getElementsByTagName("mwsaccesskey").Item(0).Text
    frmCredentials.SecretAccessKeyBox = xmldoc.getElementsByTagName("secretkey").Item(0).Text
    
    AmazonMsgBox GetTranslatedString("mws_credentials_imported"), vbOKOnly, GetTranslatedString("registration_complete")
End Sub

Attribute VB_Name = "frmCannotFindXML"
Attribute VB_Base = "0{A0E527F8-0F8C-4FCD-8164-3BBDAD1C1CC1}{E1329662-AFF6-430A-AFA1-EB0ECC5976A7}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
' Modified for CN Launch
' Abhijit Tambe, August 2010

Private Sub imgOkay_Click()
Unload Me
End Sub

Private Sub lblDownloadMSXML_Click()
'    Set oIE = CreateObject("InternetExplorer.Application")
'    oIE.Navigate "http://www.microsoft.com/downloads/details.aspx?FamilyID=993c0bcf-3bcf-4009-be21-27e85e1857b1"
'    oIE.Visible = True
    
    Call BrowseTo("http://www.microsoft.com/downloads/details.aspx?FamilyID=993c0bcf-3bcf-4009-be21-27e85e1857b1")
End Sub

Private Sub UserForm_Click()
    ' added 10/12/10 by atambe
    TranslateFormControls Me
    
    ' added 08/15/10 by atambe
    If bChinaTemplate Then
        imgAmazonServices.Visible = False
        imgAmazonJoyo.Visible = True
    End If
End Sub
Attribute VB_Name = "frmCredentials"
Attribute VB_Base = "0{9D514FC3-AA9B-4011-AF01-17CFBC2EF829}{7EEBC2EB-4088-46AE-A1E5-9054D551DC91}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
' Added for MWS integration
' Abhijit Tambe, July 2010


Private Sub CancelButton_Click()
    Unload Me
End Sub


Private Sub CancelButton2_Click()
    Unload Me
End Sub


Private Sub RemoveCredentials_Click()
    On Error GoTo ErrorHandler
    
    Dim choice As Integer
    choice = AmazonMsgBox(GetTranslatedString("remove_credentials_confirm"), vbYesNo, GetTranslatedString("remove_credentials_short"))
    If choice = vbYes Then
        DeleteSetting "Amazon", "MWS"
        AmazonMsgBox GetTranslatedString("credentials_successfully_removed_long"), vbOKOnly, GetTranslatedString("credentials_successfully_removed")
    End If
    Exit Sub
    
ErrorHandler:
    AmazonMsgBox GetTranslatedString("no_mws_credentials"), vbOKOnly, GetTranslatedString("remove_credentials_short")
End Sub


Private Sub ObtainCredentials_Click()
    frmBrowser.Show vbModal
End Sub


Private Sub OKButton_Click()
    If MerchantIDBox.Text = "" Or MarketplaceIDBox.Text = "" Or AccessKeyIDBox.Text = "" Or SecretAccessKeyBox.Text = "" Then
        AmazonMsgBox GetTranslatedString("please_complete"), vbOKOnly, GetTranslatedString("missing_information")
    Else
        DisableFields
        StatusValueLabel.Visible = True
        If Not ValidateCredentials(MarketplaceIDBox.Text, MerchantIDBox.Text, AccessKeyIDBox.Text, SecretAccessKeyBox.Text) Then
            EnableFields
            StatusValueLabel.Visible = False
        Else
            CredentialsFrame.Visible = False
            Label1.Visible = False
            SecurityPasswordFrame.Visible = True
            Label11.Visible = True
            Me.Height = 216
        End If
    End If
End Sub


Private Sub OkButton2_Click()
    If SecurityPasswordBox.Text = "" Or ConfirmSecurityPasswordBox.Text = "" Then
        AmazonMsgBox GetTranslatedString("please_complete"), vbOKOnly, GetTranslatedString("missing_information")
    Else
        If SecurityPasswordBox.Text <> ConfirmSecurityPasswordBox.Text Then
            AmazonMsgBox GetTranslatedString("values_must_match"), vbOKOnly, GetTranslatedString("incorrect_information")
        Else
            EncryptCredentials MarketplaceIDBox.Text, MerchantIDBox.Text, AccessKeyIDBox.Text, SecretAccessKeyBox.Text, SecurityPasswordBox.Text
            AmazonMsgBox GetTranslatedString("credentials_securely_stored"), vbOKOnly, GetTranslatedString("credentials_stored_successfully")
            ResetSecurityPassword
            Unload Me
        End If
    End If
End Sub


Private Sub EnableFields()
    MerchantIDBox.Enabled = True
    MarketplaceIDBox.Enabled = True
    AccessKeyIDBox.Enabled = True
    SecretAccessKeyBox.Enabled = True
End Sub


Private Sub DisableFields()
    MerchantIDBox.Enabled = False
    MarketplaceIDBox.Enabled = False
    AccessKeyIDBox.Enabled = False
    SecretAccessKeyBox.Enabled = False
End Sub


Private Sub UserForm_Initialize()
    ' added 10/12/10 by atambe
    TranslateFormControls Me

    ' added 08/15/10 by atambe
    If bChinaTemplate Then
        imgAmazonServices.Visible = False
        imgAmazonJoyo.Visible = True
    End If
End Sub
Attribute VB_Name = "frmMatchHeaders"
Attribute VB_Base = "0{C65CA51F-F02D-4189-B8F6-ED63B56E324E}{BBD45EDF-EFB2-4848-9CEA-924117080BD0}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'Greg Lovern
'http://PrecisionCalc.com

' Modified for CN Launch
' Abhijit Tambe, August 2010

Option Explicit

Private Sub imgCancel_Click()
Me.Hide
CancelImport
End Sub

Private Sub imgMatchPair_Click()
Dim iImportCol As Long
Dim iTemplateCol As Long
Dim bRet As Boolean
Dim iOneBasedIfAlpha As Long


'vArrayNonMatchedImportHeaders and vArrayNonMatchedTemplateHeaders are:
    '1-based when in alpha sort
    '0-based when in worksheet sort

If frmMatchHeaders.optSortAlpha Then
    'vArrayNonMatchedImportHeaders and vArrayNonMatchedTemplateHeaders are 1-based:
    iOneBasedIfAlpha = 1
Else
    'frmMatchHeaders.optSortByWorksheetOrder = True
    'vArrayNonMatchedImportHeaders and vArrayNonMatchedTemplateHeaders are 0-based:
    iOneBasedIfAlpha = 0
End If

iImportCol = vArrayNonMatchedImportHeaders(2, frmMatchHeaders.lstImport.ListIndex + iOneBasedIfAlpha)
iTemplateCol = vArrayNonMatchedTemplateHeaders(2, frmMatchHeaders.lstTemplate.ListIndex + iOneBasedIfAlpha)

iArrayMatchedHeaders(iTemplateCol) = iImportCol
bRet = PopulateMatchHeadersFormListboxes

'Me.cmdMatchPair.Enabled = False''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Me.imgMatchPair.Visible = False
Me.imgMatchPairDisabled.Visible = True
End Sub

Private Sub imgMatchPairDisabled_Click()
'Do nothing.
End Sub

Private Sub imgOkay_Click()
bMatchHeadersDlgClickedOK = True
Me.Hide
End Sub

Private Sub imgUnMatchPair_Click()
Dim iMatchedPairsSelectedRow As Long
Dim iArrayImportIndex As Long
Dim bRet As Boolean

Const MATCHED_PAIRS_TEMPLATE_ARRAYINDEX_COLUMN As Long = 3

iMatchedPairsSelectedRow = frmMatchHeaders.lstMatchedPairs.ListIndex
iArrayImportIndex = frmMatchHeaders.lstMatchedPairs.List(iMatchedPairsSelectedRow, MATCHED_PAIRS_TEMPLATE_ARRAYINDEX_COLUMN)
iArrayMatchedHeaders(iArrayImportIndex) = -1
bRet = PopulateMatchHeadersFormListboxes

'Me.cmdUnMatchPair.Enabled = False'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Me.imgUnMatchPair.Visible = False
Me.imgUnMatchPairDisabled.Visible = True
End Sub

Private Sub imgUnMatchPairDisabled_Click()
'Do nothing.
End Sub

Private Sub lstImport_Click()
'If Not IsNull(Me.lstTemplate.Value) Then Me.cmdMatchPair.Enabled = True''''''''''''''''''''''''''''''''''''''''''''
If Not IsNull(Me.lstTemplate.value) Then
    Me.imgMatchPair.Visible = True
    Me.imgMatchPairDisabled.Visible = False
End If
End Sub

Private Sub lstTemplate_Click()
'If Not IsNull(Me.lstImport.Value) Then Me.cmdMatchPair.Enabled = True''''''''''''''''''''''''''''''''''''''''''''''''''''
If Not IsNull(Me.lstImport.value) Then
    Me.imgMatchPair.Visible = True
    Me.imgMatchPairDisabled.Visible = False
End If
End Sub

Private Sub lstMatchedPairs_Click()
'Me.cmdUnMatchPair.Enabled = True'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Me.imgUnMatchPair.Visible = True
Me.imgUnMatchPairDisabled.Visible = False
End Sub

Private Sub optSortAlpha_Click()
PopulateMatchHeadersFormListboxes
End Sub

Private Sub optSortByWorksheetOrder_Click()
PopulateMatchHeadersFormListboxes
End Sub

Private Sub UserForm_Initialize()
' added 10/12/10 by atambe
TranslateFormControls Me

'Me.cmdUnMatchPair.Enabled = False''''''''''''''''''''''''''''''''''''''''''
'Me.cmdMatchPair.Enabled = False'''''''''''''''''''''''''''''''''''''''''''
Me.imgMatchPair.Visible = False
Me.imgMatchPairDisabled.Visible = True

Me.imgUnMatchPair.Visible = False
Me.imgUnMatchPairDisabled.Visible = True

Me.optSortByWorksheetOrder = True
    
' added 08/15/10 by atambe
If bChinaTemplate Then
    imgAmazonServices.Visible = False
    imgAmazonJoyo.Visible = True
End If
End Sub
Attribute VB_Name = "frmMultiTemplateChooseUploads"
Attribute VB_Base = "0{C1BB83E9-08F3-4966-9D6E-CDE1F6497E8F}{0A1F0E83-73BF-4202-9E51-F4F1DB6B098E}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
' Modified for CN Launch
' Abhijit Tambe, August 2010

Option Explicit

Public bCancel As Boolean

Private Sub chkDeselectAll_Click()
    Dim iTemplateSheetCount As Long, iArrayIndex As Long, iListIndex As Long
    iTemplateSheetCount = Me.lstSelectTemplates.ListCount
    For iArrayIndex = 1 To iTemplateSheetCount
        iListIndex = iArrayIndex - 1 'listbox list is 0-based.
        Me.lstSelectTemplates.Selected(iListIndex) = False
    Next iArrayIndex
End Sub

Private Sub chkSelectAll_Click()
    Dim iTemplateSheetCount As Long, iArrayIndex As Long, iListIndex As Long
    iTemplateSheetCount = Me.lstSelectTemplates.ListCount
    For iArrayIndex = 1 To iTemplateSheetCount
        iListIndex = iArrayIndex - 1 'listbox list is 0-based.
        Me.lstSelectTemplates.Selected(iListIndex) = True
    Next iArrayIndex
End Sub

Private Sub imgCancel_Click()
    Me.Hide
    bCancel = True
End Sub

Private Sub imgOkay_Click()
    Me.Hide
End Sub

Private Sub lstSelectTemplates_Change()
    Call SetCheckboxesEnabledStatus
End Sub

Private Sub UserForm_Activate()
    bCancel = False
    Call SetCheckboxesEnabledStatus
End Sub

Private Sub UserForm_Initialize()
    ' added 10/12/10 by atambe
    TranslateFormControls Me
    
    Call SetCheckboxesEnabledStatus
    ' added 08/15/10 by atambe
    If bChinaTemplate Then
        imgAmazonServices.Visible = False
        imgAmazonJoyo.Visible = True
    End If
End Sub


Sub SetCheckboxesEnabledStatus()
    Dim iTemplateSheetCount As Long, iArrayIndex As Long, iListIndex As Long, iSelectedCount As Long
    iTemplateSheetCount = Me.lstSelectTemplates.ListCount
    iSelectedCount = 0 'init.
    For iArrayIndex = 1 To iTemplateSheetCount
        iListIndex = iArrayIndex - 1 'listbox list is 0-based.
        If Me.lstSelectTemplates.Selected(iListIndex) Then iSelectedCount = iSelectedCount + 1
    Next iArrayIndex
    
    If iSelectedCount = iTemplateSheetCount Then
        chkSelectAll.Enabled = False
        chkDeselectAll.Enabled = True
    ElseIf iSelectedCount = 0 Then
        chkSelectAll.Enabled = True
        chkDeselectAll.Enabled = False
    Else
        'some are selected, but not all:
        chkSelectAll.Enabled = True
        chkDeselectAll.Enabled = True
    End If
End Sub
Attribute VB_Name = "frmMultiTemplateDoneUploading"
Attribute VB_Base = "0{61E135C5-710B-4492-89B3-39D1F48BD280}{6EB3D618-52D2-4A3B-80DC-1F7214864448}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
' Modified for CN Launch
' Abhijit Tambe, August 2010

Option Explicit

Dim iListIndex As Long
Dim iArrayIndex As Long
Dim strLabelText As String

Private Sub imgOkay_Click()
    Me.Hide
    Me.lblStatusPerTemplate.Caption = ""
End Sub


Private Sub lblCheckCurrentStatus_Click()
    Call CheckCurrentStatusGotClicked
End Sub

Private Sub lstTemplates_Change()
    iListIndex = Me.lstTemplates.ListIndex
    If iListIndex = -1 Then Exit Sub
    iArrayIndex = Me.lstTemplates.Column(LISTBOX_COL_C, iListIndex)
    If arrayTemplateSheets(COL_IS_UPLOAD_SUCCESS_BOOL, iArrayIndex) Then
        Me.lblCheckCurrentStatus.Enabled = True
        strLabelText = GetTranslatedString("batch_id") & " " & vbNewLine & _
                       arrayTemplateSheets(COL_XMLHTTP_UPLOAD_ID, iArrayIndex) & _
                       vbNewLine & vbNewLine & _
                       GetTranslatedString("upload_status") & " " & vbNewLine & _
                       arrayTemplateSheets(COL_XMLHTTP_UPLOAD_STATUS, iArrayIndex) & _
                       vbNewLine & vbNewLine & _
                       GetTranslatedString("submitted_date") & " " & vbNewLine & _
                       arrayTemplateSheets(COL_XMLHTTP_UPLOAD_DATE_CONVERTED_TO_LOCAL_TIME, iArrayIndex)
    ElseIf arrayTemplateSheets(COL_IS_XMLHTTP_ERROR, iArrayIndex) Then
        Me.lblCheckCurrentStatus.Enabled = False
        strLabelText = GetTranslatedString("error_code") & " " & vbNewLine & _
                       arrayTemplateSheets(COL_XMLHTTP_ERROR_CODE, iArrayIndex) & _
                       vbNewLine & vbNewLine & _
                       GetTranslatedString("error_message") & " " & vbNewLine & _
                       arrayTemplateSheets(COL_XMLHTTP_ERROR_MESSAGE, iArrayIndex)
    ElseIf arrayTemplateSheets(COL_IS_VBA_ERROR, iArrayIndex) Then Me.lblCheckCurrentStatus.Enabled = False
        strLabelText = GetTranslatedString("error_code") & " " & vbNewLine & _
                       arrayTemplateSheets(COL_VBA_ERROR_NUMBER, iArrayIndex) & _
                       vbNewLine & vbNewLine & _
                       GetTranslatedString("error_message") & " " & vbNewLine & _
                       arrayTemplateSheets(COL_VBA_ERROR_DESCRIPTION, iArrayIndex)
    End If
    Me.lblStatusPerTemplate.Caption = strLabelText
End Sub

Private Sub UserForm_Activate()
    Me.lblCheckCurrentStatus.Enabled = Not bAllUploadsFailed
    Me.lstTemplates.ListIndex = -1 'this triggers lstTemplates_Change.
End Sub

Private Sub UserForm_Initialize()
'    MsgBox "UserForm_Initialize"

    ' added 10/12/10 by atambe
    TranslateFormControls Me
    
    ' added 08/15/10 by atambe
    If bChinaTemplate Then
        imgAmazonServices.Visible = False
        imgAmazonJoyo.Visible = True
    End If
End Sub
Attribute VB_Name = "frmPickCodepage"
Attribute VB_Base = "0{0BFC9DF1-02E5-46E1-B960-94964DC0BF35}{0546DBFE-90BD-4FF9-BEF4-351F919935AC}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
' Modified for CN Launch
' Abhijit Tambe, August 2010

Option Explicit

Public bCancel As Boolean

Private Sub imgCancel_Click()
Me.Hide
bCancel = True
End Sub

Private Sub imgOkay_Click()
Me.Hide
End Sub

Private Sub lstPickCodepage_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
Me.imgOkay = True
End Sub

Private Sub UserForm_Activate()
bCancel = False
End Sub

Private Sub UserForm_Initialize()
    ' added 10/12/10 by atambe
    TranslateFormControls Me
    
    ' added 08/15/10 by atambe
    If bChinaTemplate Then
        imgAmazonServices.Visible = False
        imgAmazonJoyo.Visible = True
    End If
End Sub
Attribute VB_Name = "frmPickWorksheet"
Attribute VB_Base = "0{2737E71E-B0AE-4E64-88CF-54C673DAECCD}{8511ECC0-6A44-47CE-B8AC-EAC90E57AC03}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
' Modified for CN Launch
' Abhijit Tambe, August 2010

Option Explicit

Private Sub imgCancel_Click()
Me.Hide
CancelImport
End Sub

Private Sub imgOkay_Click()
Me.Hide
End Sub

Private Sub UserForm_Initialize()
    ' added 10/12/10 by atambe
    TranslateFormControls Me
    
    ' added 08/15/10 by atambe
    If bChinaTemplate Then
        imgAmazonServices.Visible = False
        imgAmazonJoyo.Visible = True
    End If
End Sub
Attribute VB_Name = "frmProgressIntTemplates"
Attribute VB_Base = "0{85653120-DEE4-4D12-8AFC-05A5B5195828}{9681767B-9A88-4AB6-8482-10F65B308FB6}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

' Modified for CN Launch
' Abhijit Tambe, August 2010

Option Explicit

Private Sub imgCancel_Click()
bCancelCreatingInternationalTemplates = True
End Sub

Private Sub UserForm_Initialize()
    ' added 10/12/10 by atambe
    TranslateFormControls Me
    
    ' added 08/15/10 by atambe
    If bChinaTemplate Then
        imgAmazonServices.Visible = False
        imgAmazonJoyo.Visible = True
    End If
End Sub
Attribute VB_Name = "frmSecurityPassword"
Attribute VB_Base = "0{F8BF44D0-0C5D-4130-B750-C2391D6D938C}{8AD8FCF8-EFF1-460A-9A01-F8D3AE45A54A}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
' Added for MWS integration
' Abhijit Tambe, July 2010


Private Sub CancelButton_Click()
    Unload Me
End Sub


Private Sub ResetSecurityPassword_Click()
    Dim choice As Integer
    choice = AmazonMsgBox(GetTranslatedString("reenter_mws_credentials"), vbOKCancel, GetTranslatedString("reset_sec_pass_short"))
    If choice = vbOK Then frmCredentials.Show vbModal
End Sub


Private Sub OKButton_Click()
    If Me.SecurityPasswordBox.Text = "" Then
        AmazonMsgBox GetTranslatedString("please_enter_sec_pass"), vbOKOnly, GetTranslatedString("sec_pass_required")
    Else
        If ValidateSecurityPassword(Me.SecurityPasswordBox.Text) Then
            SetSecurityPassword (Me.SecurityPasswordBox.Text)
            Unload Me
        End If
    End If
End Sub

Private Sub UserForm_Initialize()
    ' added 10/12/10 by atambe
    TranslateFormControls Me
    
    ' added 08/15/10 by atambe
    If bChinaTemplate Then
        imgAmazonServices.Visible = False
        imgAmazonJoyo.Visible = True
    End If
End Sub
Attribute VB_Name = "frmUpdatePleaseWait"
Attribute VB_Base = "0{B4075E46-3BB4-4F6E-893F-851CD5B409E6}{5A216F88-D8D4-4A6D-88F0-021EB3F3ED94}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

' Modified for CN Launch
' Abhijit Tambe, August 2010

Private Sub UserForm_Initialize()
    ' added 10/12/10 by atambe
    TranslateFormControls Me
    
    ' added 08/15/10 by atambe
    If bChinaTemplate Then
        imgAmazonServices.Visible = False
        imgAmazonJoyo.Visible = True
    End If
End Sub
Attribute VB_Name = "frmUploadFile"
Attribute VB_Base = "0{3B663C69-10AF-440F-A0DF-CFA487BB7BFB}{AD72D3C4-3211-45FD-B611-55070667DC83}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
' Modified for MWS Integration
' Abhijit Tambe, July 2010

Private Sub Cancel_Click()
    Unload Me
End Sub

Private Sub CommandButton1_Click()
    'Declare a variable as a FileDialog object.
    Dim fd As FileDialog

    'Create a FileDialog object as a File Picker dialog box.
    Set fd = Application.FileDialog(msoFileDialogFilePicker)

    'Use the Show method to display the File Picker dialog box
    'The user pressed the action button.
    If fd.Show = -1 Then
        FileToUpload.Text = fd.SelectedItems.Item(1)
    End If

    'Set the object variable to Nothing.
    Set fd = Nothing

End Sub

Private Sub CancelButton_Click()
    Frame3.Visible = False
    Unload Me
End Sub

' modified 07/30/10 by atambe
Private Sub Upload_Click()
        
        'On Error GoTo ErrorHandler
        
    Dim strTempFile As String
        'MsgBox Application.ActiveWorkbook.FullName
        'MsgBox Application.ActiveWorkbook.Path
        'save to a remp file in temp folder
'        Dim fso As New FileSystemObject 'switching to late binding and removing from References.
        Dim fso As Object
        Set fso = CreateObject("Scripting.FileSystemObject")
'        strTempFile = fso.GetSpecialFolder(TemporaryFolder) & "\" & fso.GetTempName & ".txt"
        strTempFile = fso.GetSpecialFolder(2) & "\" & fso.GetTempName & ".txt" '2 = TemporaryFolder.
        InitializeStatus
        SaveDown.Visible = True
        Upload.Visible = False
        Cancel.Visible = False
        CancelDown.Visible = True
        'strTempFile = Application.ActiveWorkbook.Name
        'If Application.ActiveWorkbook.FileFormat <> xlText And Application.ActiveWorkbook.FileFormat <> xlTextWindows And Application.ActiveWorkbook.FileFormat <> xlUnicodeText Then
        '    strTempFile = Replace(strTempFile, ".", "_")
        '    strTempFile = strTempFile & ".txt"
        'End If
        UpdateStatus GetTranslatedString("saving_file")
        'Dim filex As Variant
        'prompt user for filename and path
        'filex = Application.GetSaveAsFilename(InitialFileName:=strTempFile, FileFilter:="Text Files (*.txt), *.txt", Title:="Save As Tab Delimited File Name")
        'If filex <> False Then
            'MsgBox "File Saved as " & filex
        '    strTempFile = filex
        'Else
        '    ShowFrame1
        '    CloseStatus
        '    Exit Sub
        'End If
        
        Application.ScreenUpdating = False
        Application.EnableEvents = False
        Application.DisplayAlerts = False
'        Sheet1.Select
        Set shTemplate = GetTemplateWorksheet
        shTemplate.Select
        
        '6/18/2008 - find and copy only actual used range, not whole worksheet:
            '(UsedRange etc. and other conventional ways of determinging last occupied cells
            'are now broken due to .Formula = .Formula.)
        '==================================================================================
        Dim iHeaderRow As Long
        Dim iLastDataCol As Long
        Dim iLastDataRow As Long
        Dim rgFirstCol As Range
        Dim rgLastCol As Range
        Dim rgUpload As Range
        
        Const FIRST_UPLOAD_COL As Long = 1 'always upload starting with column A.
        Const FIRST_UPLOAD_ROW As Long = 1 'upload must include row 1, with the "templatetype=xxx" etc.
        
        iHeaderRow = GetTemplateHeaderRow(shTemplate)
'        iLastDataRow = iHeaderRow 'init.
'        Set rgLastCol = shTemplate.Rows(iHeaderRow).Find(What:="*", _
                                                        After:=shTemplate.Cells(iHeaderRow, 1), _
                                                        LookIn:=xlFormulas, _
                                                        SearchDirection:=xlPrevious)
        Set rgFirstCol = shTemplate.Cells(iHeaderRow, 1)
        Set rgLastCol = GetRightmostOccupiedCellInRowAsRange(shTemplate, iHeaderRow)
        iLastDataCol = rgLastCol.Column
'        Do Until IsRangeEmpty(shTemplate.Range( _
'                                    shTemplate.Cells(iLastDataRow, FIRST_UPLOAD_COL), _
'                                    shTemplate.Cells(iLastDataRow, iLastDataCol)).EntireRow)
'            iLastDataRow = iLastDataRow + 1
'        Loop
'        iLastDataRow = iLastDataRow - 1 'back up one row to last occupied row.
        iLastDataRow = GetRowNumberOfLastOccupiedRow(shTemplate.Range(rgFirstCol, rgLastCol))

        Set rgUpload = shTemplate.Range( _
                            shTemplate.Cells(FIRST_UPLOAD_ROW, FIRST_UPLOAD_COL), _
                            shTemplate.Cells(iLastDataRow, iLastDataCol))
        rgUpload.Select 'Cells.Select
        '==================================================================================
        
        Selection.Copy
        Workbooks.Add
        Selection.PasteSpecial Paste:=xlValues
        Selection.PasteSpecial Paste:=xlFormats
        'Sheets("Sheet1").Name = strTempFile
        Range("A1").Select
        Call ActiveWorkbook.SaveAs(FileName:=strTempFile, FileFormat:=xlText) 'In JP, saving as xlText saves as Shift-JIS.
        ActiveWorkbook.Close SaveChanges:=False
        Application.DisplayAlerts = True
        Application.EnableEvents = True
        Application.ScreenUpdating = True
                
        UpdateStatus "Uploading File"

        '7/1/08:
        'moving feed type from hard-coded to a setting:
        Dim strFeedType As String
        strFeedType = ThisWorkbook.Names(FEED_TYPE_DEFINED_NAME).RefersToRange.value
        '9/24/08:
        If strFeedType <> "" Then
            strFeedType = FEED_TYPE_PARAMETER_NAME & strFeedType
        End If

        '9/24/08:
        'moving upload client from hard-coded to a setting:
        Dim strUploadClient As String
        strUploadClient = ThisWorkbook.Names(UPLOAD_CLIENT_DEFINED_NAME).RefersToRange.value
        'add parameter name etc. if needed:
        If strUploadClient <> "" Then
            strUploadClient = UPLOAD_CLIENT_PARAMETER_NAME & strUploadClient
        End If
        
'    If amazonGlobals.DoUploadFile(Me.MerchantLogin.Text, Me.MerchantPassword.Text, strTempFile, "_POST_FLAT_FILE_LISTINGS_DATA_") Then CloseStatus
    ' modified parameter order 07/30/10 by atambe
    If amazonGlobals.DoUploadFile(strTempFile, Me.MerchantLogin.Text, Me.MerchantPassword.Text, strFeedType & strUploadClient) Then CloseStatus
    SaveDown.Visible = False
    Upload.Visible = True
    Cancel.Visible = True
    CancelDown.Visible = False
    Exit Sub
ErrorHandler:
        Beep
        ShowUploadFailedResults " " & Err.Number, " " & Err.Description
        Exit Sub
End Sub

Private Sub OKButton_Click()
    ShowFrame1
    CloseStatus
    Unload Me
End Sub



Private Sub TryAgainButton_Click()
    
    ShowFrame1
    CloseStatus
End Sub



Public Sub ShowUploadFailedResults(Reason As String, Details As String)
    ' modified 07/30/10 by atambe: removed leading space character
    If Reason = "InvalidAccessKeyId" Then 'note leading space character in " InvalidAccessKeyId"
        lblReason.Caption = GetTranslatedString("login_failure")
        lblDetails.Caption = GetTranslatedString("user_pass_invalid")
    Else
        lblReason.Caption = Reason
        lblDetails.Caption = Details
    End If
    
    Frame3.Height = 108
    frmUploadFile.Height = 198
    capLoginInfo.Visible = False
    Frame2.Visible = False
    Frame1.Visible = False
    Frame3.Visible = True
    uploadfailedCaption.Visible = True

End Sub
Public Sub ShowUploadResults(RefID As String, UpType As String, UpStatus As String, SubDate As String)
    Frame2.Height = 114
    frmUploadFile.Height = 211.5
    capLoginInfo.Visible = False
    Frame2.Visible = True
    Frame1.Visible = False
    ReferenceID.Caption = RefID
    'UploadType.Caption = UpType
    UploadStatus.Caption = UpStatus
    SubmittedDate.Caption = SubDate
End Sub
Public Sub InitializeStatus()
    SaveDown.Visible = True
    Upload.Visible = False
    Cancel.Visible = False
    CancelDown.Visible = True
    Frame1.Height = 108
    frmUploadFile.Height = 205.5
    StatusLabel.Visible = True
    StatusValueLabel.Visible = True
    MerchantLogin.Enabled = False
    MerchantPassword.Enabled = False
    Upload.Enabled = False
    Cancel.Enabled = False
End Sub
Public Function UpdateStatus(Text As String)
    StatusValueLabel.Caption = Text
End Function

Public Sub ShowFrame1()
    Frame2.Visible = False
    Frame3.Visible = False
    Frame1.Visible = True
    uploadfailedCaption.Visible = False
    capLoginInfo.Visible = True
End Sub
    
Public Sub CloseStatus()
    Frame1.Height = 96
    frmUploadFile.Height = 199.5
    StatusLabel.Visible = False
    StatusValueLabel.Visible = False
    Label4.Visible = True
    Label2.Visible = True
    MerchantLogin.Visible = True
    MerchantPassword.Visible = True
    Upload.Visible = True
    Cancel.Visible = True
    MerchantLogin.Enabled = True
    MerchantPassword.Enabled = True
    Upload.Enabled = True
    Cancel.Enabled = True
    SaveDown.Visible = False
    Upload.Visible = True
    Cancel.Visible = True
    CancelDown.Visible = False
End Sub

Private Sub CheckCurrentStatus_Click()
'Set objWeb = CreateObject("InternetExplorer.Application")
'objWeb.Navigate "https://sellercentral.amazon.com/gp/transactions/uploadMPInventory.html"
'objWeb.Visible = True
'
'Call BrowseTo("https://sellercentral.amazon.com/gp/transactions/uploadMPInventory.html")
'
'Call BrowseTo(GetLocalURL(URL_HEADER_STATUS_CHECK_PROD))

'========================================================================================================
'obsolete as of 2009-12-02:
'Dim strStatusCheckURLType As String
'
'strStatusCheckURLType = ThisWorkbook.Names(STATUS_CHECK_URL_TYPE_DEFINED_NAME).RefersToRange.Value
'If strStatusCheckURLType = STATUS_CHECK_URL_TYPE_NOSELLERCENTRAL Then
'    'check for devo:
'    If UCase(ThisWorkbook.Names(IS_DEVO_DEFINED_NAME).RefersToRange.Value) = "FALSE" Then 'added ucase 2009-12-02.
'        'this is production, not devo, therefore seamless uses same status check url as non-seamless:
'        strStatusCheckURLType = STATUS_CHECK_URL_TYPE_USESELLERCENTRAL
'    Else
'        'this is devo, therefore seamless uses the devo seamless status check url, so do nothing here.
'    End If
'End If
'
'bOkayToCheckStatus = True 'init '2009-10-09
'If strStatusCheckURLType = STATUS_CHECK_URL_TYPE_USESELLERCENTRAL Then
'    strStatusCheckURL = GetLocalURL(URL_HEADER_STATUS_CHECK_PROD)
'ElseIf strStatusCheckURLType = STATUS_CHECK_URL_TYPE_NOSELLERCENTRAL Then
'    strStatusCheckURL = GetLocalURL(URL_HEADER_STATUS_CHECK_DEVO)
'Else
'    bOkayToCheckStatus = False
'End If
'========================================================================================================


'2009-12-02:
'now, per Jenny, all devo goes to devo url; all prod goes to prod url:
Dim bOkayToCheckStatus As Boolean
Dim strStatusCheckURL As String
bOkayToCheckStatus = True 'init
If UCase(ThisWorkbook.Names(IS_DEVO_DEFINED_NAME).RefersToRange.value) = "FALSE" Then
    'this is prod:
    strStatusCheckURL = GetLocalURL(URL_HEADER_STATUS_CHECK_PROD)
ElseIf UCase(ThisWorkbook.Names(IS_DEVO_DEFINED_NAME).RefersToRange.value) = "TRUE" Then
    'this is devo:
    strStatusCheckURL = GetLocalURL(URL_HEADER_STATUS_CHECK_DEVO)
Else
    bOkayToCheckStatus = False
End If



If bOkayToCheckStatus Then
    Call BrowseTo(strStatusCheckURL)
Else
'    MsgBox "Unable to check status.", vbInformation + vbOKOnly, "Upload Success"
    AmazonMsgBox GetTranslatedString("unable_to_check"), vbOKOnly, GetTranslatedString("upload_success")
End If



End Sub

Private Sub UserForm_Initialize()
    ' added 10/12/10 by atambe
    TranslateFormControls Me
    
    ' added 08/15/10 by atambe
    If bChinaTemplate Then
        imgAmazonServices.Visible = False
        imgAmazonJoyo.Visible = True
    End If
End Sub
Attribute VB_Name = "frmUploadFileMWS"
Attribute VB_Base = "0{1F5CBD77-BB2B-4EBA-A0BF-69D00FBC35B9}{1721830E-740A-4380-9600-C7F8C6A85DE5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
' Modified for MWS integration
' Abhijit Tambe, July 2010


Private Sub CancelButton_Click()
    Unload Me
End Sub


' added 07/20/10 by atambe
Private Sub UserForm_Activate()
    Dim strTempFile As String
    
    Dim fso As Object
    Set fso = CreateObject("Scripting.FileSystemObject")
    strTempFile = fso.GetSpecialFolder(2) & "\" & fso.GetTempName & ".txt" '2 = TemporaryFolder.
        
    UpdateStatus GetTranslatedString("saving_file")
        
    Application.ScreenUpdating = False
    Application.EnableEvents = False
    Application.DisplayAlerts = False

    Set shTemplate = GetTemplateWorksheet
    shTemplate.Select
    
    '6/18/2008 - find and copy only actual used range, not whole worksheet:
        '(UsedRange etc. and other conventional ways of determinging last occupied cells
        'are now broken due to .Formula = .Formula.)
    '==================================================================================
    Dim iHeaderRow As Long
    Dim iLastDataCol As Long
    Dim iLastDataRow As Long
    Dim rgFirstCol As Range
    Dim rgLastCol As Range
    Dim rgUpload As Range
    
    Const FIRST_UPLOAD_COL As Long = 1 'always upload starting with column A.
    Const FIRST_UPLOAD_ROW As Long = 1 'upload must include row 1, with the "templatetype=xxx" etc.
    
    iHeaderRow = GetTemplateHeaderRow(shTemplate)
    '        iLastDataRow = iHeaderRow 'init.
    '        Set rgLastCol = shTemplate.Rows(iHeaderRow).Find(What:="*", _
                                                    After:=shTemplate.Cells(iHeaderRow, 1), _
                                                    LookIn:=xlFormulas, _
                                                    SearchDirection:=xlPrevious)
    Set rgFirstCol = shTemplate.Cells(iHeaderRow, 1)
    Set rgLastCol = GetRightmostOccupiedCellInRowAsRange(shTemplate, iHeaderRow)
    iLastDataCol = rgLastCol.Column
    '        Do Until IsRangeEmpty(shTemplate.Range( _
    '                                    shTemplate.Cells(iLastDataRow, FIRST_UPLOAD_COL), _
    '                                    shTemplate.Cells(iLastDataRow, iLastDataCol)).EntireRow)
    '            iLastDataRow = iLastDataRow + 1
    '        Loop
    '        iLastDataRow = iLastDataRow - 1 'back up one row to last occupied row.
    iLastDataRow = GetRowNumberOfLastOccupiedRow(shTemplate.Range(rgFirstCol, rgLastCol))
    
    Set rgUpload = shTemplate.Range( _
                        shTemplate.Cells(FIRST_UPLOAD_ROW, FIRST_UPLOAD_COL), _
                        shTemplate.Cells(iLastDataRow, iLastDataCol))
    rgUpload.Select 'Cells.Select
    
    Selection.Copy
    Workbooks.Add
    Selection.PasteSpecial Paste:=xlValues
    Selection.PasteSpecial Paste:=xlFormats
    'Sheets("Sheet1").Name = strTempFile
    Range("A1").Select
    
    ' added 08/06/10 by atambe
    If GetLocalLanguageName = INT_TABLE_CHINESE_HEADER Then
        Call ActiveWorkbook.SaveAs(FileName:=strTempFile, FileFormat:=xlUnicodeText) 'Save as Unicode for CN: noted 08/06/10 by atambe
    Else
        Call ActiveWorkbook.SaveAs(FileName:=strTempFile, FileFormat:=xlText) 'In JP, saving as xlText saves as Shift-JIS.
    End If
    
    ActiveWorkbook.Close SaveChanges:=False
    Application.DisplayAlerts = True
    Application.EnableEvents = True
    Application.ScreenUpdating = True
            
    UpdateStatus "Uploading File"
    
    amazonGlobals.DoUploadFile strTempFile    ' added 07/20/10 by atambe
    
    Exit Sub
    
ErrorHandler:
    Beep
    ShowUploadFailedResults Err.Number, Err.Description   ' removed leading space characters: atambe 07/27/10
End Sub


Private Sub OKButton_Click()
    Unload Me
End Sub


Private Sub TryAgainButton_Click()
    Unload Me
    amazonGlobals.UploadFile
End Sub


' modified 07/26/10 by atambe
Public Sub ShowUploadFailedResults(Reason As String, Details As String)
    ' modified on 07/29/10 by atambe
    If Reason = "InvalidAccessKeyId" Or Reason = "AccessDenied" Or Reason = "MissingClientTokenId" Or Reason = "SignatureDoesNotMatch" Or Reason = "InvalidRequest" Then
        lblReason.Caption = GetTranslatedString("login_failure")
        lblDetails.Caption = GetTranslatedString("mws_rejected")
    Else
        lblReason.Caption = Reason
        lblDetails.Caption = Details
    End If
    
    ' added 07/26/10 by atambe
    CredentialsFrame.Visible = False
    UploadProgressLabel.Visible = False
    UploadFailedFrame.Visible = True
    UploadFailedLabel.Visible = True
    Me.Height = 235.5
End Sub


' modified 07/26/10 by atambe
Public Sub ShowUploadResults(RefID As String, UpType As String, UpStatus As String, SubDate As String)
    ' added 07/26/10 by atambe
    CredentialsFrame.Visible = False
    UploadProgressLabel.Visible = False
    UploadSuccessFrame.Visible = True
    UploadSuccessLabel.Visible = True
    
    ReferenceID.Caption = RefID
    'UploadType.Caption = UpType
    UploadStatus.Caption = UpStatus
    SubmittedDate.Caption = SubDate
End Sub


Public Function UpdateStatus(Text As String)
    StatusValueLabel.Caption = Text
End Function


Private Sub CheckCurrentStatus_Click()
    '2009-12-02:
    'now, per Jenny, all devo goes to devo url; all prod goes to prod url:
    Dim bOkayToCheckStatus As Boolean
    Dim strStatusCheckURL As String
    bOkayToCheckStatus = True 'init
    If UCase(ThisWorkbook.Names(IS_DEVO_DEFINED_NAME).RefersToRange.value) = "FALSE" Then
        'this is prod:
        strStatusCheckURL = GetLocalURL(URL_HEADER_STATUS_CHECK_PROD)
    ElseIf UCase(ThisWorkbook.Names(IS_DEVO_DEFINED_NAME).RefersToRange.value) = "TRUE" Then
        'this is devo:
        strStatusCheckURL = GetLocalURL(URL_HEADER_STATUS_CHECK_DEVO)
    Else
        bOkayToCheckStatus = False
    End If
    
    If bOkayToCheckStatus Then
        Call BrowseTo(strStatusCheckURL)
    Else
    '    MsgBox "Unable to check status.", vbInformation + vbOKOnly, "Upload Success"
        AmazonMsgBox GetTranslatedString("unable_to_check"), vbOKOnly, GetTranslatedString("upload_success")
    End If
End Sub

Private Sub UserForm_Initialize()
    ' added 10/12/10 by atambe
    TranslateFormControls Me
    
    ' added 08/15/10 by atambe
    If bChinaTemplate Then
        imgAmazonServices.Visible = False
        imgAmazonJoyo.Visible = True
    End If
End Sub
Attribute VB_Name = "frmValidatePleaseWait"
Attribute VB_Base = "0{2523B4DF-539B-49FF-8C7B-11426442696A}{2D153691-3D72-4EE5-88E3-799C342F274E}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False


' Modified for CN Launch
' Abhijit Tambe, August 2010

Option Explicit



Private Sub imgCancel_Click()
    bCancelValidation = True
End Sub

Private Sub UserForm_Activate()
    bCancelValidation = False
End Sub

Private Sub UserForm_Initialize()
    ' added 10/12/10 by atambe
    TranslateFormControls Me

    bCancelValidation = False

    ' added 08/15/10 by atambe
    If bChinaTemplate Then
        imgAmazonServices.Visible = False
        imgAmazonJoyo.Visible = True
    End If
End Sub

Attribute VB_Name = "modDropdowns"
'Greg Lovern
'http://PrecisionCalc.com

Option Explicit


Dim bScreenUpdating As Boolean
Dim dblLastMouseDownTime As Double
Dim dblLastMouseUpTime As Double
Public bDisplayDropdownOneRowUp As Boolean
Public shSizer As Worksheet

'for OnTime:
Dim cboTemplate As MSForms.ComboBox
Dim rgTarget As Range
Dim rgEnterComboBoxDataHere As Range
Dim rgList As Range
Dim oShape As OLEObject

Public Const PRODUCT_TAX_CODE_DROPDOWN_LIST As String = "dropdown_list_product_tax_code"
Public Const CONDITION_DROPDOWN_LIST As String = "dropdown_list_condition"
Public Const UPDATE_DELETE_DROPDOWN_LIST As String = "dropdown_list_update_delete"

Public Const DROPDOWN_LIST_DEFINED_NAME_PREFIX As String = "dropdown_list_"

Public Const DROPDOWN_SIZER_WORKSHEET_NAME As String = "DropdownSizer"
Public Const DROPDOWN_LISTS_WORKSHEET_NAME As String = "Dropdown Lists"

Public Const COMBOBOX_OFFER_CREATION_NAME As String = "cboOfferCreation"



Public Function DropdownsOnWorkbookActivate()
    Application.OnKey "{ESCAPE}", "OnKeyEscapeKey"
End Function



Public Function DropdownsOnWorkbookDeactivate()
    Application.OnKey "{ESCAPE}" 'returns escape key to default behavior.
End Function



Public Function DropdownsOnWorkbookClose()

    On Error Resume Next
    
'    shTemplate.cboOfferCreation.Visible = False
    Workbooks(GetTemplateWorksheet.Name).cboOfferCreation.Visible = False
    
    Application.OnKey "{ESCAPE}" 'returns escape key to default behavior.
    
End Function


Sub test_GetCombobox()
'    Debug.Print GetCombobox(GetTemplateWorksheet(), COMBOBOX_OFFER_CREATION_NAME).Name
End Sub



Function GetCombobox(target_sheet As Worksheet, combobox_name As String) As MSForms.ComboBox

Dim oShape As OLEObject
Dim bFound As Boolean

For Each oShape In target_sheet.OLEObjects
    If oShape.Name = combobox_name Then
        Set GetCombobox = oShape.Object
        Exit Function
    End If
Next oShape

Set GetCombobox = target_sheet.OLEObjects.Add(ClassType:="Forms.ComboBox.1").Object

GetCombobox.Name = combobox_name
GetCombobox.SpecialEffect = fmSpecialEffectEtched

End Function



Public Function DropdownsOnWorkbookOpen()

    Dim shSheet As Worksheet
    Dim bFound As Boolean
    Dim cboTemplate As MSForms.ComboBox

    Application.OnKey "{ESCAPE}", "OnKeyEscapeKey"
    
    Set cboTemplate = GetCombobox(GetTemplateWorksheet(), COMBOBOX_OFFER_CREATION_NAME)
    DoEvents
    
    cboTemplate.Visible = False
    
    'find/set dropdown sizer sheet:
    Set shSizer = GetDropdownSizerWorksheet(DROPDOWN_SIZER_WORKSHEET_NAME)

End Function




Public Function GetDropdownSizerWorksheet(sheet_name) As Worksheet

Dim bFound As Boolean
Dim shSheet As Worksheet
Dim shSizer As Worksheet

bFound = False 'init.
For Each shSheet In ThisWorkbook.Worksheets
    If shSheet.Name = sheet_name Then
        bFound = True
        Set shSizer = shSheet
        shSizer.Visible = False
        Exit For
    End If
Next shSheet
If Not bFound Then
    Set shSizer = ThisWorkbook.Worksheets.Add
    shSizer.Visible = False
    shSizer.Name = sheet_name
End If

Set GetDropdownSizerWorksheet = shSizer

End Function




Public Function OnKeyEscapeKey()

On Error GoTo GenErr

Application.EnableCancelKey = xlErrorHandler

'get out of cutcopymode:
If Application.CutCopyMode Then
    Application.CutCopyMode = False
    Exit Function
End If

bScreenUpdating = Application.ScreenUpdating

If ActiveSheet Is GetTemplateWorksheet() Then
    If Selection.Cells.Count = 1 Then
        Application.ScreenUpdating = False
        'change selection and back to trigger worksheet's SelectionChange event. (doesn't work if called directly.)
        ActiveCell.Offset(1, 0).Select
        ActiveCell.Offset(-1, 0).Select
        Application.ScreenUpdating = bScreenUpdating
    End If
End If


'send escape key in case it's needed for other purposes:
'(this does NOT cause an infinite loop with the OnKey on the escape key.)
'BUT this breaks toggling dropdowns' visiblity. So check whether any dropdowns'
'visible status changed, and do this only if none changed:
DoEvents
'SendKeys "{ESC}", True
DoEvents

Exit Function

GenErr:

If Err.Number = 18 Then
    'macro interrupted by escape key; user probably held ESC down and wants to proceed:
    Resume
End If

Application.ScreenUpdating = bScreenUpdating

End Function



Public Function DisplayComboBoxTimerPassArgs(combo_box As MSForms.ComboBox, dropdown_cell As Range, list_range As Range) As Boolean

    Application.OnTime Now + 0.000000001, "'DisplayComboBoxTimedPassArgs """ & dropdown_cell.Parent.Name & """, """ & list_range.Parent.Name & """, """ & combo_box.Name & """, """ & dropdown_cell.Address & """, """ & list_range.Address & """'"
    '0.000000001 = ~1/10,000 sec.
End Function

Public Function DisplayComboBoxTimerPublicArgs()

    Application.OnTime Now + 0.000000001, "DisplayComboBoxTimedPublicArgs"
    '0.000000001 = ~1/10,000 sec.
End Function

Public Function DisplayComboBoxTimedPublicArgs() As Boolean

'to get the dropdown to drop down after a keyboard event that selects another cell with a dropdown, right after
'a dropdown had been active, must return control to the user for a tiny fraction of a second (not enough
'time for the user to do anything). Otherwise, the dropdown only drops down if the previous selection did not
'have a dropdown.
'
'For example, if the user has Excel set to move down after Enter, and the user presses Enter repeatedly
'on a column with a dropdown, then only the first cell (that was clicked on, for example) drops down it's
'dropdown; all others do not drop down the dropdown.

    DisplayComboBox cboTemplate, rgTarget, rgList
End Function

Public Function DisplayComboBoxTimedPassArgs(template_worksheet_name As String, lists_worksheet_name As String, _
                                             combo_box_name As String, _
                                             dropdown_cell_address As String, list_range_address As String) As Boolean

'to get the dropdown to drop down after a keyboard event that selects another cell with a dropdown, right after
'a dropdown had been active, must return control to the user for a tiny fraction of a second (not enough
'time for the user to do anything). Otherwise, the dropdown only drops down if the previous selection did not
'have a dropdown.
'
'For example, if the user has Excel set to move down after Enter, and the user presses Enter repeatedly
'on a column with a dropdown, then only the first cell (that was clicked on, for example) drops down it's
'dropdown; all others do not drop down the dropdown.

    Dim shTemplate As Worksheet
    Dim shLists As Worksheet
    
    Set shTemplate = ThisWorkbook.Worksheets(template_worksheet_name)
    Set shLists = ThisWorkbook.Worksheets(lists_worksheet_name)
    
    DisplayComboBox shTemplate.OLEObjects(combo_box_name).Object, _
                    shTemplate.Range(dropdown_cell_address), _
                    shLists.Range(list_range_address)
End Function




Public Function DisplayComboBox(combo_box As MSForms.ComboBox, dropdown_cell As Range, list_range As Range) As Boolean

'returns True on success.

'Dim shSizer As Worksheet 'this is now a public variable set in DropdownsOnWorkbookOpen.
Dim rgSizer As Range
Dim dblListItemRequiredWidth As Double
Dim bDisplayAlerts As Boolean

On Error GoTo GenErr

DisplayComboBox = False 'init.
bDisplayAlerts = Application.DisplayAlerts

'initialize combobox with the correct list:
combo_box.value = ""
combo_box.Clear

If list_range.Cells.Count = 1 Then
    combo_box.AddItem list_range.value
Else
    combo_box.List = list_range.value 'breaks if only one item to add.
End If

'check shSizer and re-initialize if necessary:
If shSizer Is Nothing Then
    Set shSizer = GetDropdownSizerWorksheet(DROPDOWN_SIZER_WORKSHEET_NAME)
End If

combo_box.Visible = False
DoEvents

'match cell's font name and font size:
combo_box.Font.Name = dropdown_cell.Font.Name
combo_box.Font.Size = dropdown_cell.Font.Size

'set combobox's width to widest localized list item, or to cell width, whichever is wider:
Set rgSizer = shSizer.Range(shSizer.Cells(1, 1), shSizer.Cells(UBound(combo_box.List) + 1, 1))
rgSizer.Font.Name = dropdown_cell.Font.Name
rgSizer.Font.Size = dropdown_cell.Font.Size
rgSizer = combo_box.List
rgSizer.EntireColumn.AutoFit
dblListItemRequiredWidth = rgSizer.Width + 30
'to avoid hash marks in dropdown edit box,
'check for dropdown_cell column being the column to the left of the
'freeze panes divider. If it is, make combo_box the same width as dropdown_cell,
'BUT, to avoid cutting off too much dropdown list item text, do it only if
'
If ActiveWindow.FreezePanes And ActiveWindow.SplitColumn = dropdown_cell.Column Then
    'make combo_box the same width as dropdown_cell,
    'to avoid hash marks in dropdown edit box:
    combo_box.Width = dropdown_cell.Width
ElseIf dblListItemRequiredWidth > dropdown_cell.Width Then
    combo_box.Width = dblListItemRequiredWidth
Else
    combo_box.Width = dropdown_cell.Width
End If

Application.DisplayAlerts = False
rgSizer.ClearContents
Application.DisplayAlerts = bDisplayAlerts



combo_box.Top = dropdown_cell.Top + 1 ' - 2.25 '+ 1 to see top cell border.
combo_box.Left = dropdown_cell.Left + 1 '- 7.5 '+ 1 to see left cell border.
combo_box.Height = dropdown_cell.Height * 1.5 '* 1.5 '* 1.5  '- 1 to see bottom cell border.
'combo_box.width = dropdown_cell.width '+ 23 '+ 1 to keep it inside cell. 'Width is now be sized dynamically based on dropdown contents.
combo_box.Visible = True
DoEvents
combo_box.Activate

combo_box.DropDown '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

combo_box.SelText = dropdown_cell.value
combo_box.SelStart = 0
combo_box.SelLength = Len(dropdown_cell.value)

'combo_box.DropDown '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

DoEvents
Set rgEnterComboBoxDataHere = dropdown_cell

DisplayComboBox = True

Exit Function

GenErr:

Application.DisplayAlerts = bDisplayAlerts

If False Then
    Resume
End If


End Function



Public Function DropdownGotClicked(combo_control As MSForms.ComboBox)
    
    If CDbl(Now) - dblLastMouseUpTime < 0.0000001 Then '~1/100sec
        rgEnterComboBoxDataHere.Formula = combo_control.value
        combo_control.Visible = False
        rgEnterComboBoxDataHere.Activate 'because otherwise the cell does not appear selected.
    End If
End Function


Public Function DropdownGotDoubleClicked(combo_control As MSForms.ComboBox)
    combo_control.Visible = False
End Function


Public Function DropdownGotMouseUpped(Optional combo_control As MSForms.ComboBox, _
                               Optional Button As Integer, Optional Shift As Integer, _
                               Optional x As Single, Optional y As Single)

    dblLastMouseUpTime = Now
End Function


Public Function DropdownGotMouseDowned(Optional combo_control As MSForms.ComboBox, _
                               Optional Button As Integer, Optional Shift As Integer, _
                               Optional x As Single, Optional y As Single)
'GJL - 2009-07-27: looks like this can cause Excel to crash. Commenting out until further investigation is possible.
'    'if user holds mouse down, assume they want to select a range, so dismiss the dropdown:
'    dblLastMouseDownTime = Now
'    Application.OnTime Now + 0.000008, "DismissDropdownIfUserHoldsMouseDownToSelectRange" 'about 0.7 seconds.
End Function



Public Function DismissDropdownIfUserHoldsMouseDownToSelectRange()

If dblLastMouseDownTime > dblLastMouseUpTime Then
    'user has held the mouse down on the combobox for about 0.7 seconds:
    For Each oShape In ActiveSheet.OLEObjects 'since the user is mousing down, this sheet must be the active sheet.
        If oShape.Name = COMBOBOX_OFFER_CREATION_NAME Then
            oShape.Visible = False
            rgEnterComboBoxDataHere.Activate 'because otherwise the cell does not appear selected.
            Exit Function
        End If
    Next oShape
End If

End Function


Public Function DropdownGotTabbed(combo_control As MSForms.ComboBox, shift_keys As Integer)

    On Error Resume Next

    If Val(Application.Version) <= 10 Then
'        MsgBox "In Excel 2002 and earlier, use the Left or Right Arrow key to select an item from this dropdown and move to the adjacent cell, " & _
               "or use the mouse." & _
               vbCrLf & vbCrLf & _
               "Using the Tab key on this dropdown requires Excel 2003 or later." & _
               vbCrLf & vbCrLf & _
               "You are using Excel " & GetExcelFriendlyVersion(Val(Application.Version)) & ".", _
               vbCritical + vbOKOnly, "Tab Key Unavailable on this Dropdown Listbox"
        AmazonMsgBox GetTranslatedString("excel_inst_tab_1") & vbCrLf & vbCrLf & _
                     GetTranslatedString("excel_inst_tab_2") & vbCrLf & vbCrLf & _
                     GetTranslatedString("excel_inst_tab_3") & GetExcelFriendlyVersion(Val(Application.Version)) & GetTranslatedString("excel_inst_tab_4"), _
                     vbOKOnly, GetTranslatedString("tab_key_unavailable")
        Exit Function
    End If

    rgEnterComboBoxDataHere.Formula = combo_control.value
    combo_control.Visible = False

    If shift_keys = 0 Then
        rgEnterComboBoxDataHere.Offset(0, 1).Select
    ElseIf shift_keys = 1 Then
        rgEnterComboBoxDataHere.Offset(0, -1).Select
    End If
    
End Function



Public Function DropdownGotEnterKeyed(combo_control As MSForms.ComboBox, shift_keys As Integer)
    
    On Error Resume Next
    Dim iRowOffset As Long
    Dim iColOffset As Long
'    Dim bColumnHasDropdown As Boolean

    If Val(Application.Version) <= 10 Then
'        MsgBox "In Excel 2002 and earlier, use the Left or Right Arrow key to select an item from this dropdown, " & _
               "or use the mouse." & _
               vbCrLf & vbCrLf & _
               "Using the Enter key on this dropdown requires Excel 2003 or later." & _
               vbCrLf & vbCrLf & _
               "You are using Excel " & GetExcelFriendlyVersion(Val(Application.Version)) & ".", _
               vbCritical + vbOKOnly, "Enter Key Unavailable on this Dropdown Listbox"
        AmazonMsgBox GetTranslatedString("excel_inst_enter_1") & vbCrLf & vbCrLf & _
                     GetTranslatedString("excel_inst_enter_2") & vbCrLf & vbCrLf & _
                     GetTranslatedString("excel_inst_enter_3") & GetExcelFriendlyVersion(Val(Application.Version)) & GetTranslatedString("excel_inst_enter_4"), _
                     vbOKOnly, GetTranslatedString("enter_key_unavailable")
        Exit Function
    End If
    
    DoEvents

    iRowOffset = 0 'init.
    iColOffset = 0 'init.

    rgEnterComboBoxDataHere.Formula = combo_control.value
    
    combo_control.Visible = False

    If Application.MoveAfterReturn Then
        If Application.MoveAfterReturnDirection = xlDown Then
            iRowOffset = 1
        ElseIf Application.MoveAfterReturnDirection = xlToRight Then
            iColOffset = 1
        ElseIf Application.MoveAfterReturnDirection = xlUp Then
            iRowOffset = -1
        Else
            'Application.MoveAfterReturnDirection = xlToLeft:
            iColOffset = -1
        End If

        If shift_keys = 1 Then
            'turn 1 into -1, and turn -1 into 1, and leave 0 as 0:
            iRowOffset = iRowOffset * -1
            iColOffset = iColOffset * -1
        End If
    End If
    
    rgEnterComboBoxDataHere.Offset(iRowOffset, iColOffset).Select

    If combo_control.Visible Then
        combo_control.Activate
    End If

End Function



Public Function DropdownGotEscapeKeyed(combo_control As MSForms.ComboBox)
    
    On Error Resume Next

    If Val(Application.Version) <= 10 Then
'        MsgBox "In Excel 2002 and earlier, use the Alt + Left Arrow or Alt + Right Arrow keys to dismiss this dropdown, " & _
               "or use the mouse." & _
               vbCrLf & vbCrLf & _
               "Using the Escape key on this dropdown requires Excel 2003 or later." & _
               vbCrLf & vbCrLf & _
               "You are using Excel " & GetExcelFriendlyVersion(Val(Application.Version)) & ".", _
               vbCritical + vbOKOnly, "Escape Key Unavailable on this Dropdown Listbox"
        AmazonMsgBox GetTranslatedString("excel_inst_esc_1") & vbCrLf & vbCrLf & _
                     GetTranslatedString("excel_inst_esc_2") & vbCrLf & vbCrLf & _
                     GetTranslatedString("excel_inst_esc_3") & GetExcelFriendlyVersion(Val(Application.Version)) & GetTranslatedString("excel_inst_esc_4"), _
                     vbOKOnly, GetTranslatedString("esc_key_unavailable")
        Exit Function
    End If

    combo_control.Visible = False
    rgEnterComboBoxDataHere.Activate 'because otherwise the cell does not appear selected.
End Function



Public Function DropdownGotRightArrowed(combo_control As MSForms.ComboBox)
    
    On Error Resume Next
    rgEnterComboBoxDataHere.Formula = combo_control.value
    combo_control.Visible = False
    rgEnterComboBoxDataHere.Offset(0, 1).Select
'    Selection.Activate
End Function



Public Function DropdownGotLeftArrowed(combo_control As MSForms.ComboBox)
    
    On Error Resume Next
    rgEnterComboBoxDataHere.Formula = combo_control.value
    combo_control.Visible = False
    rgEnterComboBoxDataHere.Offset(0, -1).Select
'    Selection.Activate
End Function


Public Function DropdownGotHomeKeyed(combo_control As MSForms.ComboBox, shift_keys As Integer)

    'shift_keys:
        '0 = none.
        '1 = Shift.
        '2 = Ctrl.
        '3 = Ctrl + Shift.
        '4 = Alt.
        '5 = Alt + Shift.
        '6 = Ctrl + Alt.
        '7 = Alt + Ctrl + Shift.
    
    On Error Resume Next
    rgEnterComboBoxDataHere.Formula = combo_control.value
    combo_control.Visible = False
    Select Case shift_keys
        Case 1
            'Shift:
            ActiveSheet.Range(ActiveSheet.Cells(rgEnterComboBoxDataHere.Row, 1), rgEnterComboBoxDataHere).Select
        Case 2
            'Ctrl:
            ActiveSheet.Range("A1").Select
        Case 3
            'Ctrl + Shift:
            ActiveSheet.Range(ActiveSheet.Range("A1"), rgEnterComboBoxDataHere).Select
        Case Else
            ActiveSheet.Cells(rgEnterComboBoxDataHere.Row, 1).Select
    End Select
'    Selection.Activate
End Function


Public Function DropdownGotEndKeyed(combo_control As MSForms.ComboBox, shift_keys As Integer)
    
    On Error Resume Next
    rgEnterComboBoxDataHere.Formula = combo_control.value
    combo_control.Visible = False
    ActiveSheet.Cells(rgEnterComboBoxDataHere.Row, ActiveSheet.Columns.Count).Select
'    Selection.Activate
End Function



Public Function DropdownGotKeyDowned(combo_control As MSForms.ComboBox, key_code As Integer, shift_keys As Integer)

    On Error Resume Next
    DoEvents
    Select Case key_code
        Case 27 'escape
            DropdownGotEscapeKeyed combo_control
        Case 39 'right arrow
            DropdownGotRightArrowed combo_control
        Case 40 'down arrow
            combo_control.DropDown
        Case 37 'left arrow
            DropdownGotLeftArrowed combo_control
        Case 9 'tab
            DropdownGotTabbed combo_control, shift_keys
        Case 13 'enter key
            DropdownGotEnterKeyed combo_control, shift_keys
        Case 36 'home key
            DropdownGotHomeKeyed combo_control, shift_keys
        Case 35 'end key
            DropdownGotEndKeyed combo_control, shift_keys
    End Select

End Function




Public Function SelectionChangeDropDown(ByVal Target As Range)

Dim bRet As Boolean
Dim iTemplateHeaderRow As Long


On Error GoTo GenErr

Set cboTemplate = GetCombobox(GetTemplateWorksheet(), COMBOBOX_OFFER_CREATION_NAME)
DoEvents

'make the dropdown invisible.
    'this takes Excel out of cutcopy mode. do not do if the dropdown is already invisible:
    'v0.080: also do not do this if excel is in cutcopy mode:
If cboTemplate.Visible Then
    If Application.CutCopyMode = False Then
        cboTemplate.Visible = False
    End If
End If


'v0.080: moving this below making the dropdown invisible,
'so that it doesn't remain visible if select cell in non-dropdown column after showing dropdown:
If Not IsOkayToShowDropdown(Target) Then
    Exit Function
End If


iTemplateHeaderRow = GetTemplateHeaderRow(Target.Parent)
Set rgList = GetDropdownListFromColumn(Target.Column, iTemplateHeaderRow, Target.Row)

If rgList Is Nothing Then
    'this column does not have a dropdown, so do not display combo box.
    'but do cycle screenupdating to avoid phantom orphaned combobox that can result from
    'holding down left or right arrow key.
'    CycleScreenUpdating
Else
    'display combobox:
'    bRet = DisplayComboBoxTimer(cboTemplate, Target, rgList)
    'make those variables public for use in OnTime: cboTemplate, Target, rgList
    Set rgTarget = Target 'rgTarget is public, used by OnTime
    bRet = DisplayComboBoxTimerPublicArgs()
End If


Exit Function

GenErr:

'Stop
If False Then
    Resume
End If

End Function



Public Function IsOkayToShowDropdown(selected_range As Range) As Boolean

IsOkayToShowDropdown = True 'init.
Dim iTemplateHeaderRow As Long

'don't show dropdown if in cutcopymode; instead assume user wants to paste:
If Not Application.CutCopyMode = False Then
    IsOkayToShowDropdown = False
End If

'don't show dropdowns on header row or above:
iTemplateHeaderRow = GetTemplateHeaderRow(selected_range.Parent)
If selected_range.Row <= iTemplateHeaderRow Then
    IsOkayToShowDropdown = False
End If

'show dropdown only if a single cell is selected:
If selected_range.Cells.Count > 1 Then
    IsOkayToShowDropdown = False
End If

'2009-07-16:
'this makes dropdowns not work on locked cells, which is a problem
'now that we're not protecting sheets, because locked is the default
'status, so a newly-created template sheet might have all cells locked, but
'with the sheet not protected. 'But what if we start protecting template sheets
'again in the future?
'So, set to False only if BOTH of the following are true:
    'selected_range.Locked = True
    'selected_range.Parent.ProtectContents = True
'don't show dropdowns on protected cells such as in example rows:
If selected_range.Parent.ProtectContents Then
    If selected_range.Locked Then
        IsOkayToShowDropdown = False
    End If
End If

End Function



Public Function GetDropdownListFromColumn(dropdown_column As Long, header_row As Long, current_row As Long) As Range

'returns Nothing if column does not have a dropdown.

Dim strTemplateHeader As String
Dim strIntTableMfaInternalNameHeader As String
Dim shIntData As Worksheet
Dim iIntTableLocalLanguageCol As Long
Dim iMfaInternalNameCol As Long
Dim strListDefinedName As String
Dim shTemplate As Worksheet

On Error GoTo GenErr

Set shTemplate = GetTemplateWorksheet()

strTemplateHeader = shTemplate.Cells(header_row, dropdown_column).value
'Set shIntData = ThisWorkbook.Worksheets(INT_TABLE_WORKSHEET_NAME)

'iMfaInternalNameCol = GetIntTableMfaInternalNameColumn(shIntData)
'iIntTableLocalLanguageCol = GetIntTableLocalLanguageColumn(shIntData)

'strIntTableMfaInternalNameHeader = GetMfaInternalNameColumnHeaderFromLocalLanguageColumnHeader( _
                                   strTemplateHeader, shIntData, _
                                   iIntTableLocalLanguageCol, iMfaInternalNameCol)

'strListDefinedName = DROPDOWN_LIST_DEFINED_NAME_PREFIX & Replace(strIntTableMfaInternalNameHeader, "-", "_")
strListDefinedName = DROPDOWN_LIST_DEFINED_NAME_PREFIX & Replace(strTemplateHeader, "-", "_")

Set GetDropdownListFromColumn = GetDropdownListRangeFromDefinedName(strListDefinedName, current_row)

'if that range has no list items, return Nothing:
'If Application.WorksheetFunction.CountA(GetDropdownListFromColumn) = 0 Then
If IsRangeEmpty(GetDropdownListFromColumn) Then
    Set GetDropdownListFromColumn = Nothing
End If


Exit Function

GenErr:

If False Then
    Resume
End If

End Function




Public Function GetIntTableMfaInternalNameColumn(int_table_sheet As Worksheet) As Long
    Dim rgFind As Range
    
    Set rgFind = int_table_sheet.Rows(INT_TABLE_HEADER_ROW).Find(INT_TABLE_MFA_INTERNAL_NAME_HEADER)
    Call ResetFindParametersToDefaults
    GetIntTableMfaInternalNameColumn = rgFind.Column
End Function


Public Function GetIntTableLocalLanguageColumn(int_table_sheet As Worksheet) As Long
    Dim strIntTableLocalLanguageHeader As String
    Dim rgFind As Range
    
    strIntTableLocalLanguageHeader = GetLocalLanguageName
    Set rgFind = int_table_sheet.Rows(INT_TABLE_HEADER_ROW).Find(strIntTableLocalLanguageHeader)
    Call ResetFindParametersToDefaults
    GetIntTableLocalLanguageColumn = rgFind.Column
End Function


Public Function GetIntTableTemplateDependencyTestColumn(int_table_sheet As Worksheet) As Long
    Dim rgFind As Range
    
    Set rgFind = int_table_sheet.Rows(INT_TABLE_HEADER_ROW).Find(INT_TABLE_TEMPLATE_DEPENDENCY_TEST_HEADER)
    Call ResetFindParametersToDefaults
    GetIntTableTemplateDependencyTestColumn = rgFind.Column
End Function


Public Function GetMfaInternalNameColumnHeaderFromLocalLanguageColumnHeader( _
                    template_header_string As String, _
                    Optional int_table_sheet As Worksheet, _
                    Optional internal_template_name As String, _
                    Optional int_table_local_language_col As Long, _
                    Optional int_table_mfa_internal_name_col As Long, _
                    Optional int_table_template_dependency_test_col As Long) As String
    
    'returns empty string ("") if not found.
    
    Dim rgFind As Range
    Dim iRow As Long
    
    On Error GoTo GenErr

    If int_table_sheet Is Nothing Then
        Set int_table_sheet = ThisWorkbook.Worksheets(INT_TABLE_WORKSHEET_NAME)
    End If

    If internal_template_name = "" Then
        internal_template_name = GetInternalTemplateName(int_table_sheet.Parent)
    End If

    If int_table_local_language_col = 0 Then
        int_table_local_language_col = GetIntTableLocalLanguageColumn(int_table_sheet)
    End If

    If int_table_mfa_internal_name_col = 0 Then
        int_table_mfa_internal_name_col = GetIntTableMfaInternalNameColumn(int_table_sheet)
    End If

    If int_table_template_dependency_test_col = 0 Then
        int_table_template_dependency_test_col = GetIntTableTemplateDependencyTestColumn(int_table_sheet)
    End If
    
    
    '==============================================================================================================
    'there may be multiple template_header_string entries in int_table_sheet, and some of them may fail the template
    'dependency test. So, need to loop until found one that does not fail the template dependency test:
    Dim rgFirstFind As Range
    Dim rgPreviousFind As Range
    Dim rgFindCheck As Range
    Dim strTemplateTestPattern As String
    DoEvents
    Set rgPreviousFind = int_table_sheet.Cells(int_table_sheet.Rows.Count, int_table_local_language_col) 'init.
    Set rgFirstFind = int_table_sheet.Columns(int_table_local_language_col).Find(What:=template_header_string, After:=rgPreviousFind, LookAt:=xlWhole)
    Call ResetFindParametersToDefaults
    DoEvents
    Do
        
        DoEvents
        Set rgFind = int_table_sheet.Columns(int_table_local_language_col).Find(What:=template_header_string, After:=rgPreviousFind, LookAt:=xlWhole)
        Call ResetFindParametersToDefaults
        DoEvents
        
        If rgFind Is Nothing Then
            'check mfa internal names too:
            DoEvents
            Set rgFind = int_table_sheet.Columns(int_table_mfa_internal_name_col).Find(template_header_string)
            Call ResetFindParametersToDefaults
            DoEvents
        End If
        
        'check template test:
        DoEvents
        strTemplateTestPattern = int_table_sheet.Cells(rgFind.Row, int_table_template_dependency_test_col).value
        DoEvents
        If RegexTest(strTemplateTestPattern, internal_template_name) Then
            'this one passes the template dependency test, so use it.
            Exit Do
        Else
            'this one does NOT pass the template dependency test, so keep looking.
        End If
        
        'check whether there is another one to find:
        Set rgFindCheck = int_table_sheet.Columns(int_table_local_language_col).Find(What:=template_header_string, After:=rgFind, LookAt:=xlWhole)
        Call ResetFindParametersToDefaults
        
        If rgFindCheck.Address = rgFirstFind.Address Then
            'you've checked them all.
            Exit Do
        Else
            DoEvents
            Set rgPreviousFind = rgFind
            DoEvents
        End If
        DoEvents
    
    Loop
    '==============================================================================================================
    
    
    
    If rgFind Is Nothing Then
        'not found.
        GetMfaInternalNameColumnHeaderFromLocalLanguageColumnHeader = ""
        Exit Function
    End If
    

    iRow = rgFind.Row
    
    GetMfaInternalNameColumnHeaderFromLocalLanguageColumnHeader = _
        int_table_sheet.Cells(iRow, int_table_mfa_internal_name_col).value
    
    Exit Function
    
GenErr:
    
    If False Then
        Resume
    End If

End Function


Public Function GetDropdownListRangeFromDefinedName(defined_name As String, current_row As Long) As Range

'returns Nothing if defined name does not exist.

Dim nmName As Name
Dim bFound As Boolean
Dim shDropdowns As Worksheet
Dim strColumnDependencyHeader As String
Dim iCol As Long
Dim bTestPass As Boolean
Dim bDependencyColumnFound As Boolean
Dim strDefinedNameSuffix As String
Dim strDefinedNameSuffixSeparator As String
Dim strDefinedNameNew As String
Dim rgCandidateList As Range

On Error GoTo GenErr

Set GetDropdownListRangeFromDefinedName = Nothing 'init.
bFound = False 'init.

For Each nmName In ThisWorkbook.Names
    If nmName.Name = defined_name Then
        bFound = True
        Exit For
    End If
Next nmName

If Not bFound Then
    Exit Function
End If

Set rgCandidateList = GetRangeFromDefinedName(defined_name)
        
If rgCandidateList Is Nothing Then
    'list not found; return Nothing:
    Exit Function
End If

Set shDropdowns = rgCandidateList.Parent
iCol = rgCandidateList.Column

bTestPass = False 'init.
strDefinedNameSuffix = "" 'init.

Do

    strColumnDependencyHeader = shDropdowns.Cells( _
                                           LOCAL_DROPDOWN_LISTS_SHEET_COLUMN_DEPENDENCY_COLUMN_HEADER_ROW, _
                                           iCol).value
    
    If strColumnDependencyHeader = "" Then
        bTestPass = True
    Else
        'test:
        Dim shTemplate As Worksheet
        Dim shIntTable As Worksheet
        Dim strColumnDependencyLocalHeader As String
        Dim iColumnDependencyLocalHeaderCol As Long
        Dim iIntTableMfaInternalNameCol As Long
        Dim iIntTableLocalNameCol As Long
        Dim iTemplateHeaderRow As Long
        Dim strColumnDependencyTest As String
        Dim strColumnDependencyItem As String

        strColumnDependencyTest = shDropdowns.Cells(LOCAL_DROPDOWN_LISTS_SHEET_COLUMN_DEPENDENCY_TEST_ROW, iCol).value
        Set shTemplate = GetTemplateWorksheet()
'        Set shIntTable = GetInternationalTableWorksheet()
'        iIntTableMfaInternalNameCol = GetIntTableMfaInternalNameColumn(shIntTable)
'        iIntTableLocalNameCol = GetIntTableLocalLanguageColumn(shIntTable)
        iTemplateHeaderRow = GetTemplateHeaderRow(shTemplate)
'        strColumnDependencyLocalHeader = _
'            GetLocalColumnHeaderFromMfaInternalName( _
'                strColumnDependencyMfaInternalHeader, shIntTable, shTemplate, _
'                iIntTableMfaInternalNameCol, iIntTableLocalNameCol, iTemplateHeaderRow)
'
'        If strColumnDependencyLocalHeader = "" Then
'            bDependencyColumnFound = False
'        Else
'            bDependencyColumnFound = True
'        End If
        
'        If bDependencyColumnFound Then
            Dim rgHeaderCell As Range
            Set rgHeaderCell = shTemplate.Rows(iTemplateHeaderRow).Find( _
                               What:=strColumnDependencyHeader, LookAt:=xlWhole)
            If rgHeaderCell Is Nothing Then
                bTestPass = False
            Else
                iColumnDependencyLocalHeaderCol = rgHeaderCell.Column
                strColumnDependencyItem = shTemplate.Cells(current_row, iColumnDependencyLocalHeaderCol).value
                Call ResetFindParametersToDefaults
    
                bTestPass = RegexTest(strColumnDependencyTest, strColumnDependencyItem)
            End If
'        Else
'            bTestPass = False
'        End If
    End If
    
    If bTestPass Then
        Set GetDropdownListRangeFromDefinedName = rgCandidateList
        Exit Function
    Else
        strDefinedNameSuffix = IncrementDefinedNameSuffix(strDefinedNameSuffix)
        strDefinedNameSuffixSeparator = GetDefinedNameSuffixSeparatorFromSuffix(strDefinedNameSuffix)
        strDefinedNameNew = defined_name & strDefinedNameSuffixSeparator & strDefinedNameSuffix
        Set rgCandidateList = GetRangeFromDefinedName(strDefinedNameNew)
        
        If rgCandidateList Is Nothing Then
            'list not found; return Nothing:
            Exit Function
        End If
        
        iCol = rgCandidateList.Column

    End If

Loop Until bTestPass


Exit Function

GenErr:

If False Then
    Resume
End If

End Function


Public Function DockDropdown()

On Error Resume Next

Dim arrayTemplateSheets() As Worksheet
    Dim iUboundTemplateSheets As Long
    Dim iArrayIndexTemplateSheets As Long
    Dim shArrayItemTemplateSheet As Worksheet
    Dim shWorksheet As Worksheet
    
'get array of template sheets:
ReDim arrayTemplateSheets(0 To 0) As Worksheet
iUboundTemplateSheets = UBound(arrayTemplateSheets)
For Each shWorksheet In ThisWorkbook.Worksheets
    If InStr(shWorksheet.CodeName, "shTemplate") > 0 Then
        iUboundTemplateSheets = iUboundTemplateSheets + 1
        ReDim Preserve arrayTemplateSheets(0 To iUboundTemplateSheets) As Worksheet
        Set arrayTemplateSheets(iUboundTemplateSheets) = shWorksheet
    End If
Next shWorksheet


'dock dropdown on each template sheet:
For iArrayIndexTemplateSheets = 1 To iUboundTemplateSheets
    Set shArrayItemTemplateSheet = arrayTemplateSheets(iArrayIndexTemplateSheets)
    Set cboTemplate = GetCombobox(shArrayItemTemplateSheet, COMBOBOX_OFFER_CREATION_NAME)
    cboTemplate.Visible = False
    cboTemplate.Width = 1
    cboTemplate.Height = 1
    cboTemplate.Top = 1
    cboTemplate.Left = 1
Next iArrayIndexTemplateSheets

End Function


'Public Sub OnTimeTest()
'
'bDisplayDropdownOneRowUp = False
'Selection.Offset(-1, 0).Select
'
'End Sub
Attribute VB_Name = "modImportFile"
'Greg Lovern
'http://PrecisionCalc.com

Option Explicit


Public wbImport As Workbook
Public bMatchHeadersDlgClickedAdd As Boolean
Public bMatchHeadersDlgClickedRemove As Boolean
Public bMatchHeadersDlgClickedOK As Boolean
Public vArrayImportHeaders() As Variant
Public vArrayTemplateHeaders() As Variant
Public iArrayMatchedHeaders() As Long 'index = Template column #, items = Import column #.
Public vArrayNonMatchedImportHeaders() As Variant
Public vArrayNonMatchedTemplateHeaders() As Variant
Public vArrayListboxMatchedHeaders() As Variant
Public bCancelImport As Boolean
Public bImportWorkbookIsFromTextFile As Boolean
Public strFullPathOfTempFileToDeleteAfterImporting As String 'if empty string, then no file to delete.


Public Sub ImportFile()

    Dim shImport As Worksheet
    Dim strImportWorkbookName As String
    Dim strImportWorksheetName As String
    Dim shTemplate As Worksheet
    Dim iTemplateHeaderRow As Long
    Dim iImportHeaderRow As Long
    Dim rgImportHeaders As Range
    Dim rgTemplateHeaders As Range

    Dim iArrayIndex As Long
    Dim iArrayImportIndex As Long
    Dim iArrayTemplateIndex As Long
    Dim iImportUbound As Long
    Dim iImportLbound As Long
    Dim iTemplateUbound As Long
    Dim iTemplateLbound As Long
    Dim vImportHeader As Variant
    Dim vTemplateHeader As Variant
    Dim strHeader As String
    Dim iImportCol As Long
    Dim iTemplateCol As Long
    Dim bRet As Long
    Dim iRet As Long
    Dim bFound As Boolean
    Dim strNotImportedList As String
    Dim iMatchedCol As Long
    Dim iImportFirstRow As Long
    Dim iTemplateFirstRow As Long
    Dim iImportLastRow As Long
    Dim iTemplateLastRow As Long
    Dim rgColImport As Range
    Dim rgDest As Range
    Dim vRange As Variant 'range set to a variant.
    Dim strSaveAsPath As String
    Dim strErrText As String
    Dim rgCheckForData As Range
    Dim rgCheckCell As Range

    On Error GoTo GenErr
    
    Application.EnableEvents = True
    
    strErrText = GetTranslatedString("getting_import_workbook")
    bCancelImport = False
    
    '...and dock the dropdown:
    Call DockDropdown

    Set shTemplate = GetTemplateWorksheet()
    
    'get the workbook to import:
    Set wbImport = GetImportWorkbook
    If wbImport Is Nothing Then Exit Sub
    
    'need to determine what worksheet to use in the import workbook:
    strErrText = GetTranslatedString("getting_import_worksheet")
    Set shImport = GetImportWorksheet(wbImport)
    If shImport Is Nothing Then Exit Sub
    
    'get arrays of column headers:
    iTemplateHeaderRow = GetTemplateHeaderRow(shTemplate)
    iImportHeaderRow = GetTemplateHeaderRow(shImport)
    If iImportHeaderRow < 0 Then
'        MsgBox "No data found in worksheet to be imported.", vbCritical + vbOKOnly, "Import Error"
        AmazonMsgBox GetTranslatedString("no_data_found"), vbOKOnly, GetTranslatedString("import_error")
        wbImport.Close SaveChanges:=False
        DoEvents
        Dim fso As Object
        Set fso = CreateObject("Scripting.FileSystemObject")
        If fso.FileExists(strFullPathOfTempFileToDeleteAfterImporting) Then
            fso.DeleteFile strFullPathOfTempFileToDeleteAfterImporting
            DoEvents
        End If
        Exit Sub
    End If
    
    ' added 10/18/10 by atambe
    If iTemplateHeaderRow > 2 Then
        vArrayTemplateHeaders = GetHeaderArray(shTemplate, iTemplateHeaderRow - 1)
    Else
        vArrayTemplateHeaders = GetHeaderArray(shTemplate, iTemplateHeaderRow)
    End If
    
    ' added 10/18/10 by atambe
    If iImportHeaderRow > 2 Then
        vArrayImportHeaders = GetHeaderArray(shImport, iImportHeaderRow - 1)
    Else
        vArrayImportHeaders = GetHeaderArray(shImport, iImportHeaderRow)
    End If
       
    iTemplateLbound = LBound(vArrayTemplateHeaders)
    iTemplateUbound = UBound(vArrayTemplateHeaders)
    iImportLbound = LBound(vArrayImportHeaders)
    iImportUbound = UBound(vArrayImportHeaders)
    ReDim iArrayMatchedHeaders(iTemplateLbound To iTemplateUbound)
    
    'Create match array:
    strErrText = GetTranslatedString("creating_match_array")
    For iArrayTemplateIndex = iTemplateLbound To iTemplateUbound
        vTemplateHeader = Replace(UCase(vArrayTemplateHeaders(iArrayTemplateIndex)), " ", "")
        bFound = False 'init.
        
        For iArrayImportIndex = iImportLbound To iImportUbound
            vImportHeader = Replace(UCase(vArrayImportHeaders(iArrayImportIndex)), " ", "")
            
            If vImportHeader = vTemplateHeader Then
                iArrayMatchedHeaders(iArrayTemplateIndex) = iArrayImportIndex 'because index of iArrayMatchedHeaders = Template column #.
                bFound = True
                Exit For
            End If
        Next iArrayImportIndex
        
        If Not bFound Then
            'did not find a match for this template header among import headers.
            iArrayMatchedHeaders(iArrayTemplateIndex) = -1
        End If
    Next iArrayTemplateIndex
    
    
    'populate frmMatchHeaders' Template and Import listboxes:
    strErrText = GetTranslatedString("populating_match_headers")
    bRet = PopulateMatchHeadersFormListboxes
    

    'let user choose additional matches:
    Dim bClickAddValidated As Boolean
    strErrText = GetTranslatedString("letting_user_choose")
    'check for lack of non-matched template columns to match up; don't display if there are no template columns left to match:
    bFound = False
    For iMatchedCol = iTemplateLbound To iTemplateUbound
        If iArrayMatchedHeaders(iMatchedCol) = -1 Then
            bFound = True
            Exit For
        End If
    Next iMatchedCol
    If bFound Then
        'there is at least one non-matched template column, so display dialog:
        Do
            'check for both listboxes having selections if user clicked match columns:
            bClickAddValidated = False
            Do Until bClickAddValidated
                bMatchHeadersDlgClickedAdd = False 'init.
                bMatchHeadersDlgClickedRemove = False 'init.
                bMatchHeadersDlgClickedOK = False 'init.
                frmMatchHeaders.Show
                If bCancelImport Then Exit Sub
                If bMatchHeadersDlgClickedAdd Then
                    If frmMatchHeaders.lstImport.ListIndex < 0 Or frmMatchHeaders.lstTemplate.ListIndex < 0 Then
'                        MsgBox "Please select a column header in each list.", vbCritical + vbOKOnly, "Column Headers Not Selected"
                        AmazonMsgBox GetTranslatedString("select_column_header"), vbOKOnly, GetTranslatedString("column_headers_not_selected")
                    Else
                        bClickAddValidated = True
                    End If
                Else
                    bClickAddValidated = True 'didn't click match, so okay to proceed.
                End If
            Loop
            
        Loop Until bMatchHeadersDlgClickedOK
    End If
    
    
    'check for no columns to import:
    strErrText = GetTranslatedString("checking_no_columns")
    bFound = False 'init
    For iArrayTemplateIndex = iTemplateLbound To iTemplateUbound
        iMatchedCol = iArrayMatchedHeaders(iArrayTemplateIndex)
        If iMatchedCol <> -1 Then
            bFound = True
            Exit For
        End If
    Next iArrayTemplateIndex
    If Not bFound Then
'        MsgBox "There are no columns to import, because no columns were exact matches and no columns were chosen to match.", vbCritical + vbOKOnly, "No Columns To Import"
        AmazonMsgBox GetTranslatedString("no_columns_to_import_long"), vbOKOnly, GetTranslatedString("no_columns_to_import")
        wbImport.Close SaveChanges:=False
        Set fso = CreateObject("Scripting.FileSystemObject")
        If fso.FileExists(strFullPathOfTempFileToDeleteAfterImporting) Then
            fso.DeleteFile strFullPathOfTempFileToDeleteAfterImporting
            DoEvents
        End If
        Exit Sub
    End If
    
    
    'import:
    strErrText = GetTranslatedString("importing_columns")
    iImportFirstRow = iImportHeaderRow + 1
    
    
    
    
    'find next unoccupied row after last usedrange row:
'    iTemplateFirstRow = shTemplate.UsedRange.Rows.Count + 1
''    Do While WorksheetFunction.CountA(shTemplate.Cells(iTemplateFirstRow - 1, 1).EntireRow) = 0
'    Do While IsRangeEmpty(shTemplate.Cells(iTemplateFirstRow - 1, 1).EntireRow)
'        iTemplateFirstRow = iTemplateFirstRow - 1
'    Loop
    iTemplateFirstRow = GetRowNumberOfLastOccupiedRow(shTemplate.Rows(1).EntireRow) + 1
    
    'look for skipped blank rows to report:
    If iTemplateFirstRow > iTemplateHeaderRow + 1 Then
        Dim bSkippedOccupiedRow
        bSkippedOccupiedRow = True
    End If
    
    
    
    
    
    
    For iArrayTemplateIndex = iTemplateLbound To iTemplateUbound
        iMatchedCol = iArrayMatchedHeaders(iArrayTemplateIndex)
        If iMatchedCol = -1 Then
            'this template column does not have a matching column in the import file,
            'so do not import anything into this template column.
        Else
            'enter the data from iMatchedCol in the import file:
'            iImportLastRow = shImport.Cells(shImport.Rows.Count, iMatchedCol).End(xlUp).Row
            If bImportWorkbookIsFromTextFile Then
                iImportLastRow = shImport.Cells(shImport.Rows.Count, iMatchedCol).End(xlUp).Row
            Else
                'import is from excel workbook. May have been saved out from template affected by .Formula = .Formula excel bug, so don't use End method etc.
'                iImportLastRow = shImport.Rows.Count 'init.
'                Do While IsRangeEmpty(Application.ActiveSheet.Cells(iImportLastRow, 1).EntireRow)
'                    iImportLastRow = iImportLastRow - 1
'                Loop
                iImportLastRow = GetRowNumberOfLastOccupiedRow(ActiveSheet.Rows(1).EntireRow)
            End If
            
            If iImportLastRow > iImportHeaderRow Then
                iTemplateLastRow = iImportLastRow + (iTemplateFirstRow - iImportFirstRow)
                Set rgColImport = shImport.Range(shImport.Cells(iImportFirstRow, iMatchedCol), shImport.Cells(iImportLastRow, iMatchedCol))
                Set rgDest = shTemplate.Range(shTemplate.Cells(iTemplateFirstRow, iArrayTemplateIndex), shTemplate.Cells(iTemplateLastRow, iArrayTemplateIndex))
                vRange = rgColImport
                rgDest = vRange
            Else
                'this column contains only the header; ignore this column.
            End If
        End If
    Next iArrayTemplateIndex


    'close import file:
    
    strErrText = GetTranslatedString("closing_import_file")
    strImportWorksheetName = shImport.Name
    strImportWorkbookName = wbImport.Name
    wbImport.Close SaveChanges:=False
    DoEvents
    Set fso = CreateObject("Scripting.FileSystemObject")
    If fso.FileExists(strFullPathOfTempFileToDeleteAfterImporting) Then
        fso.DeleteFile strFullPathOfTempFileToDeleteAfterImporting
        DoEvents
    End If
    
    If bSkippedOccupiedRow Then
'        MsgBox "Done importing worksheet """ & strImportWorksheetName & """ in workbook """ & strImportWorkbookName & """." & vbNewLine & vbNewLine & "Imported data begins at row " & iTemplateFirstRow & ", because data was found in row " & CStr(iTemplateFirstRow - 1) & ".", vbInformation + vbOKOnly, "Import Complete"
        AmazonMsgBox GetTranslatedString("done_importing_1") & strImportWorksheetName & GetTranslatedString("done_importing_2") & strImportWorkbookName & GetTranslatedString("done_importing_3") & vbNewLine & vbNewLine & GetTranslatedString("done_importing_4") & iTemplateFirstRow & GetTranslatedString("done_importing_5") & CStr(iTemplateFirstRow - 1) & GetTranslatedString("done_importing_6"), vbOKOnly, GetTranslatedString("import_complete")
    Else
        'data was imported in next row below headers:
'        MsgBox "Done importing worksheet """ & strImportWorksheetName & """ in workbook """ & strImportWorkbookName & """." & vbNewLine & vbNewLine & "Imported data begins at row " & iTemplateFirstRow & ".", vbInformation + vbOKOnly, "Import Complete"
        AmazonMsgBox GetTranslatedString("done_importing_1") & strImportWorksheetName & GetTranslatedString("done_importing_2") & strImportWorkbookName & GetTranslatedString("done_importing_3") & vbNewLine & vbNewLine & GetTranslatedString("done_importing_4") & iTemplateFirstRow & GetTranslatedString("done_importing_3"), vbOKOnly, GetTranslatedString("import_complete")
    End If



    Exit Sub
GenErr:
    'strErrText
    
    If False Then
        Resume
    End If
    
'    MsgBox "Error #" & Err.Number & " occurred while " & strErrText & ":" & _
            vbNewLine & vbNewLine & _
            Err.Description, vbCritical + vbOKOnly, "Template Error"
    AmazonMsgBox GetTranslatedString("template_error_1") & "#" & Err.Number & GetTranslatedString("template_error_2") & strErrText & GetTranslatedString("template_error_3") & _
                  vbNewLine & vbNewLine & _
                  Err.Description, vbOKOnly, GetTranslatedString("template_error_short")

End Sub




Function GetImportWorkbook() As Workbook

On Error GoTo GenErr

    Dim vArrayFieldInfo As Variant 'must be a variant containing an array.
    Dim vArrayColInfo As Variant 'must be a variant containing an array.
    Dim iColCount As Long
    Dim iCol As Long
    Dim strImportPath As String
    Dim bDelimCharIsTab As Boolean
    Dim bDelimCharIsComma As Boolean
    Dim strPathLast4Chars As String
    Dim iRet As Long
    Dim iTextFileCodepage As Long
    Dim iWindowsCodepage As Long
    
    strFullPathOfTempFileToDeleteAfterImporting = "" 'init.
    
    iWindowsCodepage = GetWindowsCodepage 'this will be the default codepage.
    Unload frmBrowseImportFile 'init.
    frmBrowseImportFile.lblCodepage = iWindowsCodepage
    frmBrowseImportFile.Show
    
    
    If frmBrowseImportFile.bCancel Then
        'user clicked Cancel:
        CancelImport
        Set GetImportWorkbook = Nothing
        Exit Function
    End If

    'get data from frmBrowseImportFile and unload:
    strImportPath = frmBrowseImportFile.txtBrowseImportFile
    bDelimCharIsTab = frmBrowseImportFile.bDelimCharIsTab
    bDelimCharIsComma = frmBrowseImportFile.bDelimCharIsComma
    iTextFileCodepage = frmBrowseImportFile.lblCodepage
    Unload frmBrowseImportFile
    
    
    If bDelimCharIsTab Or bDelimCharIsComma Then
        'open as text.
        bImportWorkbookIsFromTextFile = True
        If Val(Application.Version) >= 12 Then
            'Excel 2007 or later:
            iColCount = 16384
        Else
            'Excel 2003 or earlier:
            '(16384 works in Excel 2003 & 2002, breaks in 2000 at around 6000. Not sure if the limit is the number of elements or the size of the array.
            iColCount = 256
        End If
      
        ReDim vArrayFieldInfo(0 To iColCount - 1)
        For iCol = 1 To iColCount
            vArrayColInfo = Array(iCol, xlTextFormat)
            vArrayFieldInfo(iCol - 1) = vArrayColInfo
        Next iCol
    End If
    
    If bDelimCharIsTab Then
        Workbooks.OpenText FileName:=strImportPath, DataType:=xlDelimited, TextQualifier:=xlDoubleQuote, _
            Tab:=True, Semicolon:=False, Comma:=False, Space:=False, Other:=False, _
            FieldInfo:=vArrayFieldInfo, Origin:=iTextFileCodepage
        Set GetImportWorkbook = Workbooks(Workbooks.Count)
    ElseIf bDelimCharIsComma Then

        'to do this right, will need to use fso to change filename extension to anything other
        'than ".csv". OR, use fso to copy the file to a new name with extension not ".csv".
        'if filename extension is ".csv", then long numbers get imported as scientific notation.
'        iRet = MsgBox("Files with .csv filename extensions must be changed to another filename extension before opening importing. Click Yes to have this .csv file copied to your temp folder with a different name, imported from there, and then deleted when done." & _
               vbNewLine & vbNewLine & _
               "Alternatively, if you prefer, you can click Cancel, then open the CSV file and save as tab delimited, then click the Import File toolbar button again." & _
               vbNewLine & vbNewLine & _
                "Copy the .csv file and import the new file?", _
               vbQuestion + vbOKCancel, "Import CSV")
        iRet = AmazonMsgBox(GetTranslatedString("csv_msg_1") & _
               vbNewLine & vbNewLine & _
               GetTranslatedString("csv_msg_2") & _
               vbNewLine & vbNewLine & _
                GetTranslatedString("csv_msg_3"), _
               vbOKCancel, GetTranslatedString("import_csv"))
        If iRet = vbCancel Then
            CancelImport
            Set GetImportWorkbook = Nothing
            Exit Function
        End If
        
        
        
        
        
        
        'make local copy of the csv, with a .txt extension, then delete it when done:
        Dim fso As Object
        Dim oFile As Object
        Dim strFilename As String
        Dim strTmpImportPath As String
        Set fso = CreateObject("Scripting.FileSystemObject")
        strFilename = fso.GetFileName(strImportPath)
        fso.CopyFile strImportPath, Environ("tmp") & "\", True
        strTmpImportPath = Environ("tmp") & "\" & strFilename
        Set oFile = fso.GetFile(strTmpImportPath)
        If fso.FileExists(oFile.Path & ".txt") Then
            fso.DeleteFile oFile.Path & ".txt"
            DoEvents
        End If
        oFile.Name = oFile.Name & ".txt"
        strTmpImportPath = Environ("tmp") & "\" & oFile.Name
        strFullPathOfTempFileToDeleteAfterImporting = strTmpImportPath
        
        
        
        
        
        Workbooks.OpenText FileName:=strTmpImportPath, DataType:=xlDelimited, TextQualifier:=xlDoubleQuote, _
            Tab:=False, Semicolon:=False, Comma:=True, Space:=False, Other:=False, _
            FieldInfo:=vArrayFieldInfo, Origin:=iTextFileCodepage
        Set GetImportWorkbook = Workbooks(Workbooks.Count)


    Else
        'extension is not ".txt" and not ".csv", so open as standard workbook:
        bImportWorkbookIsFromTextFile = False
        Set GetImportWorkbook = Workbooks.Open(strImportPath)
    End If

Exit Function
GenErr:
    If False Then
        Resume
    End If

End Function


Function GetTextFileCodepage(default_codepage As Long) As Long
'returns -1 on error.

On Error GoTo GenErr

'ask user which codepage to use:

Dim strArrayLanguages() As String
Dim vArrayCodepages() As Variant
Dim strDisplayChoices() As String
Dim shIntTable As Worksheet
Dim rgIntTableHeaderRow As Range
Dim rgFind As Range
Dim iDataCategoryCol As Long
Dim iLanguageCol As Long
Dim iCodePageRow As Long
Dim vArrayItemCodepage As Variant 'in case of bad entry in data table.
Dim vDefaultCodepage As Long
Dim strDefaultDisplayChoice As String
Dim iLbound As Long, iUbound As Long
Dim iArrayIndex As Long
Dim strArrayItemLanguageName As String
Dim strArrayItemDisplayChoice As String
Dim strLocalLanguageName As String
Dim iUserPickedCodepageIndex As Long
Dim bNoListItemChosen As Boolean
Dim bUserClickedCancel As Boolean
Dim strEnterCodepage As String

Set shIntTable = GetInternationalTableWorksheet
strArrayLanguages = GetLanguageList(shIntTable)
iLbound = LBound(strArrayLanguages)
iUbound = UBound(strArrayLanguages)
ReDim vArrayCodepages(iLbound To iUbound) As Variant
ReDim strDisplayChoices(iLbound To iUbound) As String

strLocalLanguageName = GetLocalLanguageName
iDataCategoryCol = GetIntTableDataCategoryColumn(shIntTable)
iCodePageRow = GetTableCategorySingleRow(shIntTable, DATA_CATEGORY_CODEPAGE, iDataCategoryCol)
Set rgIntTableHeaderRow = shIntTable.Rows(INT_TABLE_HEADER_ROW)

For iArrayIndex = iLbound To iUbound
    'GetIntTableDataCategoryColumn
    'GetIntTableAnyLanguageColumn
    strArrayItemLanguageName = strArrayLanguages(iArrayIndex)
    'get array item language col.
    Set rgFind = rgIntTableHeaderRow.Find(strArrayItemLanguageName)
    Call ResetFindParametersToDefaults
    iLanguageCol = rgFind.Column
    'get codepage
    vArrayItemCodepage = shIntTable.Cells(iCodePageRow, iLanguageCol).value
    vArrayCodepages(iArrayIndex) = vArrayItemCodepage
    strArrayItemDisplayChoice = strArrayItemLanguageName & " (Codepage " & vArrayItemCodepage & ")"
    strDisplayChoices(iArrayIndex) = strArrayItemDisplayChoice
    If strArrayItemLanguageName = strLocalLanguageName Then
        vDefaultCodepage = vArrayItemCodepage
        strDefaultDisplayChoice = strArrayItemDisplayChoice
    End If
Next iArrayIndex

frmPickCodepage.lstPickCodepage.List = strDisplayChoices
bNoListItemChosen = False
frmPickCodepage.Show

'ListIndex is zero-based; must add one to use with the one-based arrays:
iUserPickedCodepageIndex = frmPickCodepage.lstPickCodepage.ListIndex + 1
If iUserPickedCodepageIndex = 0 Then
    'frmPickCodepage.lstPickCodepage.ListIndex was -1, indicating no item chosen:
    bNoListItemChosen = True
End If
strEnterCodepage = frmPickCodepage.txtEnterCodepage
bUserClickedCancel = frmPickCodepage.bCancel
Unload frmPickCodepage

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'what if:
    'user clicks Cancel?

'check for user clicked Cancel:
If bUserClickedCancel Then
    GetTextFileCodepage = default_codepage
'check for codepage entered in textbox:
ElseIf strEnterCodepage <> "" Then
    GetTextFileCodepage = strEnterCodepage
Else
    'cancel not clicked and textbox is blank, so check the chosen list item:
    If bNoListItemChosen Then
        'user did not choose a list item and did not enter a codepage in the textbox, so use default:
        GetTextFileCodepage = default_codepage
    Else
        'return the list item chosen by the user:
        GetTextFileCodepage = vArrayCodepages(iUserPickedCodepageIndex)
    End If
End If



Exit Function
GenErr:
    If False Then
        Resume
    End If
    
    GetTextFileCodepage = -1
End Function


Function GetImportWorksheet(import_work_book As Workbook) As Worksheet

    Dim iFound As Long
    Dim shSheet As Worksheet
    
    'first, check whether there is only one worksheet, in which case use that worksheet:
    If import_work_book.Worksheets.Count = 1 Then
        Set GetImportWorksheet = import_work_book.Worksheets(1)
        Exit Function
    End If

    'if more than one worksheet, check whether any worksheet name is a subset of workbook name:
    iFound = 0 'init.
    For Each shSheet In import_work_book.Worksheets
        If InStr(Replace(import_work_book.Name, " ", ""), Replace(shSheet.Name, " ", "")) > 0 Then
            iFound = iFound + 1
            Set GetImportWorksheet = shSheet
        End If
    Next shSheet
    
    If iFound = 1 Then
        'only one worksheet name is a subset of workbook name, so use that worksheet.
        Exit Function
    End If
    
    'either did not find a match, or found more than one, so have user pick from list:
    For Each shSheet In import_work_book.Worksheets
        frmPickWorksheet.lstPickImport.AddItem shSheet.Name
    Next shSheet
    frmPickWorksheet.Show
    
    If bCancelImport Then
        Set GetImportWorksheet = Nothing
    Else
        Set GetImportWorksheet = import_work_book.Worksheets(frmPickWorksheet.lstPickImport.value)
    End If

End Function



Public Function GetHeaderRange(work_sheet As Worksheet, header_row As Long) As Range

    Dim rgFind As Range
    Dim iFirstHeaderCol As Long
    Dim iLastHeaderCol As Long

    iFirstHeaderCol = 1 'not sure if this will always be 1.

'    Set rgFind = work_sheet.Cells(header_row, work_sheet.Columns.Count).End(xlToLeft)
    Set rgFind = GetRightmostOccupiedCellInRowAsRange(work_sheet, header_row)
    
    iLastHeaderCol = rgFind.Column
    Set GetHeaderRange = work_sheet.Range(work_sheet.Cells(header_row, iFirstHeaderCol), work_sheet.Cells(header_row, iLastHeaderCol))

End Function



Function GetHeaderArray(work_sheet As Worksheet, header_row As Long) As Variant()

    Dim iUbound As Long
    Dim vArrayTmp() As Variant
    Dim iArrayIndex As Long
    Dim rgHeaders As Range
    
    Set rgHeaders = GetHeaderRange(work_sheet, header_row)

    iUbound = rgHeaders.Cells.Count
    ReDim vArrayTmp(1 To iUbound)
    For iArrayIndex = 1 To iUbound
        vArrayTmp(iArrayIndex) = rgHeaders(iArrayIndex)
    Next iArrayIndex
    
    GetHeaderArray = vArrayTmp

End Function


Function AddNonMatchedHeaderToArray(array_headers() As Variant, array_index As Long, _
         non_matched_ubound As Long, array_non_matched_headers() As Variant) As Long

'modifies array_non_matched_headers and non_matched_ubound.

    Dim strHeader As String

    strHeader = array_headers(array_index)
    non_matched_ubound = non_matched_ubound + 1
    ReDim Preserve array_non_matched_headers(1 To 2, 0 To non_matched_ubound)
    array_non_matched_headers(1, non_matched_ubound) = strHeader
    array_non_matched_headers(2, non_matched_ubound) = array_index

    AddNonMatchedHeaderToArray = non_matched_ubound

End Function


Function AddMatchedPairsToListboxArray(array_import_headers() As Variant, array_template_headers() As Variant, _
         array_matched_headers() As Long, array_matched_headers_index As Long, _
         matched_headers_ubound As Long, array_matched_headers_listbox() As Variant) As Long

    Dim iImportIndex As Long
    Dim iTemplateIndex As Long
    Dim strImportItem As String
    Dim strTemplateItem As String
    Dim iListRow As Long
    
    Const LISTBOX_IMPORT_HEADER_COLUMN As Long = 0
    Const LISTBOX_TEMPLATE_HEADER_COLUMN As Long = 1
    Const LISTBOX_IMPORT_ARRAYINDEX_COLUMN As Long = 2
    Const LISTBOX_TEMPLATE_ARRAYINDEX_COLUMN As Long = 3
        
    iImportIndex = array_matched_headers(array_matched_headers_index)
    iTemplateIndex = array_matched_headers_index
    strImportItem = array_import_headers(iImportIndex)
    strTemplateItem = array_template_headers(iTemplateIndex)

    matched_headers_ubound = matched_headers_ubound + 1
    ReDim Preserve vArrayListboxMatchedHeaders(0 To 3, 0 To matched_headers_ubound)
    vArrayListboxMatchedHeaders(LISTBOX_IMPORT_HEADER_COLUMN, matched_headers_ubound) = strImportItem
    vArrayListboxMatchedHeaders(LISTBOX_TEMPLATE_HEADER_COLUMN, matched_headers_ubound) = strTemplateItem
    
    vArrayListboxMatchedHeaders(LISTBOX_IMPORT_ARRAYINDEX_COLUMN, matched_headers_ubound) = iImportIndex
    vArrayListboxMatchedHeaders(LISTBOX_TEMPLATE_ARRAYINDEX_COLUMN, matched_headers_ubound) = iTemplateIndex
    
    AddMatchedPairsToListboxArray = matched_headers_ubound

End Function



Function PopulateMatchHeadersFormListboxes() As Boolean

'returns True on success.

    On Error GoTo GenErr

    Dim iImportNonMatchedUbound As Long
    Dim iTemplateNonMatchedUbound As Long
    Dim iMatchedHeadersUbound As Long
    Dim iArrayTemplateIndex As Long
    Dim iArrayImportIndex As Long
    Dim iRowIndex As Long
    Dim iColumnIndex As Long
    Dim bFound As Boolean
    Dim bRet As Boolean
    Dim lstMatches As MSForms.ListBox
    Dim bSortByAlpha As Boolean
    
    Dim iImportUbound As Long
    Dim iImportLbound As Long
    Dim iTemplateUbound As Long
    Dim iTemplateLbound As Long

    Const LISTBOX_IMPORT_HEADER_COLUMN As Long = 0
    Const LISTBOX_TEMPLATE_HEADER_COLUMN As Long = 1
    Const LISTBOX_IMPORT_ARRAYINDEX_COLUMN As Long = 2
    Const LISTBOX_TEMPLATE_ARRAYINDEX_COLUMN As Long = 3
    
    iTemplateLbound = LBound(vArrayTemplateHeaders)
    iTemplateUbound = UBound(vArrayTemplateHeaders)
    iImportLbound = LBound(vArrayImportHeaders)
    iImportUbound = UBound(vArrayImportHeaders)

    ReDim vArrayNonMatchedImportHeaders(1 To 2, 0 To 0) 'init.
    ReDim vArrayNonMatchedTemplateHeaders(1 To 2, 0 To 0) 'init.
    ReDim vArrayListboxMatchedHeaders(0 To 3, 0 To 0) 'init.
    iImportNonMatchedUbound = -1 'init.
    iTemplateNonMatchedUbound = -1 'init.
    iMatchedHeadersUbound = -1 'init.
    
    'init listboxes:
    frmMatchHeaders.lstTemplate.Clear
    frmMatchHeaders.lstImport.Clear
    frmMatchHeaders.lstMatchedPairs.Clear
    

    'populate frmMatchHeaders Template and Matched Pairs listboxes:
    For iArrayTemplateIndex = iTemplateLbound To iTemplateUbound
        If iArrayMatchedHeaders(iArrayTemplateIndex) = -1 Then
        
            'add item to vArrayNonMatchedTemplateHeaders:
            iTemplateNonMatchedUbound = AddNonMatchedHeaderToArray(vArrayTemplateHeaders, iArrayTemplateIndex, _
                                        iTemplateNonMatchedUbound, vArrayNonMatchedTemplateHeaders)
        Else
        
            'add row of item to vArrayListboxMatchedHeaders:
            iMatchedHeadersUbound = AddMatchedPairsToListboxArray(vArrayImportHeaders, vArrayTemplateHeaders, _
                                  iArrayMatchedHeaders, iArrayTemplateIndex, _
                                  iMatchedHeadersUbound, vArrayListboxMatchedHeaders)
            
        End If
    Next iArrayTemplateIndex
    
    'populate frmMatchHeaders Import listbox:
    For iArrayImportIndex = iImportLbound To iImportUbound
        bFound = False 'init.
        
        For iArrayTemplateIndex = iTemplateLbound To iTemplateUbound
            If iArrayMatchedHeaders(iArrayTemplateIndex) = iArrayImportIndex Then
                bFound = True
                Exit For
            End If
        Next iArrayTemplateIndex
        
        If Not bFound Then
            'add item to vArrayNonMatchedImportHeaders:
            iImportNonMatchedUbound = AddNonMatchedHeaderToArray(vArrayImportHeaders, iArrayImportIndex, _
                                        iImportNonMatchedUbound, vArrayNonMatchedImportHeaders)
        End If
            
    Next iArrayImportIndex
    
    
    'check for alpha:
    If frmMatchHeaders.optSortAlpha Then
        bSortByAlpha = True
    Else
        bSortByAlpha = False
    End If
    
    
    'fill template listbox with vArrayNonMatchedTemplateHeaders:
    bRet = FillSingleColumnListboxFromArray(vArrayNonMatchedTemplateHeaders, frmMatchHeaders.lstTemplate, bSortByAlpha)
   
    
    'fill import listbox with vArrayNonMatchedImportHeaders:
    bRet = FillSingleColumnListboxFromArray(vArrayNonMatchedImportHeaders, frmMatchHeaders.lstImport, bSortByAlpha)
   
    
    'fill matched pairs listbox with vArrayListboxMatchedHeaders:
    bRet = FillMultiColumnListboxFromArray(vArrayListboxMatchedHeaders, frmMatchHeaders.lstMatchedPairs, bSortByAlpha)
    

    PopulateMatchHeadersFormListboxes = True
    
    Exit Function
    
GenErr:
    
   
    If False Then
        Resume
    End If

End Function



Function FillSingleColumnListboxFromArray(list_array() As Variant, list_box As MSForms.ListBox, _
                                          sort_alpha As Boolean) As Boolean

'returns True on success.
    
    Dim iUbound As Long
    Dim iLbound As Long
    Dim iLastCol As Long
    Dim iArrayIndex As Long
    
    On Error GoTo GenErr
    
    iUbound = UBound(list_array, 2)
    iLbound = LBound(list_array, 2)
    iLastCol = iUbound + 1 'because the array is 0-based.
    
    If sort_alpha Then
        'use shIcons:
        Dim rgSort As Range
        Dim vSortOld As Variant 'must be declared as a Variant.
        Dim vSortNew As Variant 'must be declared as a Variant.
        Set rgSort = shIcons.Range(shIcons.Cells(1, 1), shIcons.Cells(2, iLastCol))
        vSortOld = rgSort
        rgSort = list_array
        rgSort.Sort Key1:=shIcons.Cells(1, 1), Order1:=xlAscending, header:=xlNo, _
                    Orientation:=xlLeftToRight, SortMethod:=xlPinYin
        vSortNew = rgSort
        list_array = rgSort
        rgSort = vSortOld 'return worksheet to it's original state.
        
        'the array is now 1-based, so reset lbound and ubound:
        iUbound = UBound(list_array, 2)
        iLbound = LBound(list_array, 2)
    End If
    
    For iArrayIndex = iLbound To iUbound
        list_box.AddItem list_array(1, iArrayIndex)
    Next iArrayIndex
    
    FillSingleColumnListboxFromArray = True

    Exit Function
    
GenErr:
    
   
    If False Then
        Resume
    End If

End Function



Function FillMultiColumnListboxFromArray(list_array() As Variant, list_box As MSForms.ListBox, _
                                          sort_alpha As Boolean) As Boolean

'returns True on success.
    
    Dim iUbound As Long
    Dim iLastCol As Long
    Dim iArrayIndex As Long
    Dim iRowIndex As Long
    Dim iColumnIndex As Long
    Dim iArrayRow As Long
    Dim iArrayCol As Long
    Dim iAddOneIfSorted As Long
    
    iUbound = UBound(list_array, 2)
    iLastCol = iUbound + 1 'because the array is 0-based.

    If sort_alpha Then
        'use shIcons:
        Dim rgSort As Range
        Dim vSortOld As Variant 'must be declared as a Variant.
        Dim vSortNew As Variant 'must be declared as a Variant.
        Set rgSort = shIcons.Range(shIcons.Cells(1, 1), shIcons.Cells(4, iLastCol))
        vSortOld = rgSort
        rgSort = list_array
        rgSort.Sort Key1:=shIcons.Cells(1, 1), Order1:=xlAscending, header:=xlNo, _
                    Orientation:=xlLeftToRight, SortMethod:=xlPinYin
        vSortNew = rgSort
        list_array = rgSort
        rgSort = vSortOld 'return worksheet to it's original state.
        iAddOneIfSorted = 1 'because sorting changes it from 0,0 based to 1,1 based, while the listbox is still 0,0  based.
    Else
        iAddOneIfSorted = 0
    End If

    For iRowIndex = 0 To iUbound
        list_box.AddItem
        For iColumnIndex = 0 To 3
            list_box.List(iRowIndex, iColumnIndex) = list_array(iColumnIndex + iAddOneIfSorted, iRowIndex + iAddOneIfSorted)
        Next iColumnIndex
    Next iRowIndex
    
    FillMultiColumnListboxFromArray = True

End Function



Sub CancelImport()
    
    On Error Resume Next
    DoEvents 'to allow frmPickWorksheet to hide.
'    MsgBox "File import has been cancelled.", vbInformation + vbOKOnly, "Import Cancelled"
    AmazonMsgBox GetTranslatedString("file_import_cancelled"), vbOKOnly, GetTranslatedString("import_cancelled")
    wbImport.Close SaveChanges:=False
    
    bCancelImport = True

End Sub

Attribute VB_Name = "modInternational"
'Greg Lovern
'http://PrecisionCalc.com

' Modified for MWS Integration for all Regions deprecating AIM
' Sunitha Basodi, Mar 2012

' Modified for MWS Integration
' Abhijit Tambe, July 2010

Option Private Module 'to prevent merchants from seeing & running subs from the Developer toolbar.

Option Explicit


Dim strMsg As String
Dim dblProgress As Double
Dim strProgressPercent As String
Public bCancelCreatingInternationalTemplates As Boolean
Public bUpdateNow As Boolean
Public strLocalLanguageName As String
Public iDataValidationBlankLineStartPositions() As Long
Public bNotFoundInIntWorksheetsTable As Boolean

Public Const INTERNAL_TEMPLATE_NAME_DEFINED_NAME As String = "Internal_Template_Name"

Public Const INT_TABLE_WORKSHEET_NAME As String = "International Data"
Public Const INT_TABLE_HEADER_ROW As Long = 1
Public Const INT_TABLE_DATA_CATEGORY_HEADER As String = "Data Category"
Public Const INT_TABLE_REFERENCE_HEADER As String = "Reference"
Public Const INT_TABLE_TRANSLATION_KEY_HEADER As String = "Translation Key" ' added 10/08/10 by atambe
Public Const INT_TABLE_TRANSLATION_KEY_COLUMN As Long = 1 ' added 10/08/10 by atambe
Public Const INT_TABLE_TRANSLATION_STRING_COLUMN As Long = 2 ' added 10/08/10 by atambe

Public Const INT_TABLE_NUMBER_FORMAT_HEADER As String = "Number Format"
Public Const INT_TABLE_MASTER_NAME_HEADER As String = "Master Name"
Public Const INT_TABLE_MFA_INTERNAL_NAME_HEADER As String = "MFA Internal Name"
Public Const INT_TABLE_TEMPLATE_DEPENDENCY_TEST_HEADER As String = "Template Dependency Test"
Public Const INT_TABLE_ENGLISH_USA_HEADER As String = "English USA"
Public Const INT_TABLE_JAPANESE_HEADER As String = "Japanese"
Public Const INT_TABLE_CHINESE_HEADER As String = "Chinese"     ' added 07/30/10 by atambe
Public Const INT_TABLE_ENGLISH_UK_HEADER As String = "English UK"     ' added 08/19/10 by atambe
Public Const INT_TABLE_FRENCH_HEADER As String = "French"     ' added 08/19/10 by atambe
Public Const INT_TABLE_GERMAN_HEADER As String = "German"     ' added 08/19/10 by atambe
Public Const INT_JAPANESE_CODEPAGE As Long = 932

Public Const DATA_CATEGORY_CODEPAGE As String = "Codepage"
Public Const DATA_CATEGORY_COLUMN_HEADERS As String = "Column Headers"
Public Const DATA_CATEGORY_URL As String = "url"
Public Const DATA_CATEGORY_TOOLBAR_BUTTON_CAPTIONS As String = "Toolbar Button Captions"
Public Const DATA_CATEGORY_DATA_VALIDATION As String = "Data Validation"
Public Const DATA_CATEGORY_DROPDOWN_LIST_ITEMS As String = "Dropdown List Items"

Public Const FULL_MISC_DATA_TABLE_URL_DEFINED_NAME As String = "Full_Misc_Data_Table_URL"
Public Const LAST_UPDATE_DEFINED_NAME As String = "Last_Update"

Public Const FULL_DROPDOWN_LISTS_TABLE_URL_DEFINED_NAME As String = "Full_Dropdown_Lists_Table_URL"
Public Const DROPDOWN_LISTS_TABLE_WORKSHEET_NAME As String = "Int'l Dropdown Lists Table"

Public Const TEMPLATE_LANGUAGE_DEFINED_NAME As String = "template_language"
Public Const TEMPLATE_SECONDARY_LANGUAGE_DEFINED_NAME As String = "template_language_2"

Public Const TEMPLATE_CODEPAGE_DEFINED_NAME As String = "template_codepage"
Public Const TEMPLATE_LCID_DEFINED_NAME As String = "template_LCID"

Public Const SHOW_CREATE_TEMPLATES_TOOLBAR_DEFINED_NAME As String = "Show_Create_Templates_Toolbar"
Public Const AMAZON_FLATFILE_TEMPLATE_MASTER_COMMANDBAR_NAME As String = "Amazon - Build Flat File Templates"
Public Const AMAZON_FLAT_FILE_MANAGER_COMMANDBAR_NAME As String = "Amazon Flat File Manager"
Public Const IS_SIMPLIFIED_OFFER_FEED_WORKBOOK_DEFINED_NAME As String = "IsSimplifiedOfferFeedWorkbook"
Public Const AUTO_UPDATE_DEFINED_NAME As String = "Auto_Update"
Public Const UPDATE_INTERVAL_DAYS_DEFINED_NAME As String = "Update_Interval_Days"

Public Const LOCAL_DROPDOWN_LISTS_SHEET_COLUMN_DEPENDENCY_COLUMN_HEADER_ROW As Long = 1
Public Const LOCAL_DROPDOWN_LISTS_SHEET_COLUMN_DEPENDENCY_TEST_ROW As Long = 2
Public Const LOCAL_DROPDOWN_LISTS_SHEET_HEADER_ROW As Long = 3
Public Const LOCAL_DROPDOWN_LISTS_SHEET_FIRST_DATA_ROW As Long = 4

Public Const TOOLBAR_BUTTON_CAPTION_VALIDATE_DEFINED_NAME As String = "Toolbar_Button_Caption_Validate"
Public Const TOOLBAR_BUTTON_CAPTION_UPLOAD_DEFINED_NAME As String = "Toolbar_Button_Caption_Upload"
Public Const TOOLBAR_BUTTON_CAPTION_CREDENTIALS_DEFINED_NAME As String = "Toolbar_Button_Caption_Credentials"   ' added 07/30/10 by atambe
Public Const TOOLBAR_BUTTON_CAPTION_IMPORT_DEFINED_NAME As String = "Toolbar_Button_Caption_Import"
Public Const TOOLBAR_BUTTON_CAPTION_UPDATE_DEFINED_NAME As String = "Toolbar_Button_Caption_Update"

Public Const TOOLBAR_BUTTON_CAPTION_SPLIT_OUT_KEYSHEETS As String = "Split out Keysheets"
Public Const TOOLBAR_BUTTON_CAPTION_SET_AS_RELEASE_CANDIDATES As String = "Set As Release Candidates"
Public Const TOOLBAR_BUTTON_CAPTION_REMOVE_TAGS_FROM_FILENAMES As String = "Remove Tags From Filenames"
Public Const TOOLBAR_BUTTON_CAPTION_EXPORT_VALIDATION_TRANSLATION_LISTS As String = "Create Validation Translation Lists"
Public Const TOOLBAR_BUTTON_CAPTION_COMPARE_COLUMNS As String = "Columns Integrity Report"
Public Const TOOLBAR_BUTTON_CAPTION_CREATE_NO_MACRO_VERSION_OF_TEMPLATE As String = "Create a No-Macro Version"
Public Const TOOLBAR_BUTTON_CAPTION_VERYHIDE_UNHIDE As String = "Very-Hide or Unhide Sheets in a Flat-File Template"
Public Const TOOLBAR_BUTTON_CAPTION_EXCEL_DIFF_REPORT As String = "Excel Diff Report"

Public Const LOCAL_TEMPLATES_FOLDER_DEFINED_NAME As String = "Local_Templates_Folder_Name"

Public Const FEED_TYPE_DEFINED_NAME As String = "Feed_Type"
Public Const FEED_TYPE_PARAMETER_NAME As String = "&uploadType="
Public Const UPLOAD_CLIENT_DEFINED_NAME As String = "Upload_Client"
Public Const UPLOAD_CLIENT_PARAMETER_NAME As String = "&uploadClient="

Dim iArrayKeepRows() As Long



Sub MakeTemplatesV2()

'this is run from the "Amazon - Create Flat File Template" toolbar button.

'download and import mainkeys:
Dim wbNewTemplate As Workbook
Dim strNewWorkbookFullPath As String
Dim strNewWorkbookFilename As String
Dim strMainKeysURL As String
Dim strStartKeysItemName As String
Dim strStartKeysItemWorkbookName As String
Dim strStartKeysItemURL As String
Dim strKeysheetsURLPrefix As String
Dim shMainKeys As Worksheet
Dim shStartKeys As Worksheet
Dim shTemp As Worksheet
Dim rgFind As Range
Dim rgFormulas As Range
Dim rgCell As Range
Dim rgMainKeysKeynameCol As Range
Dim iStartKeysFirstRow As Long
Dim iStartKeysLastRow As Long
Dim iStartKeysRow As Long
Dim strNewTemplateName As String
Dim strCategoryName As String
Dim bRet As Boolean
Dim iRet As Long
Dim shArrayTemplateSheets() As Worksheet
Dim uBoundTSh As Long
Dim bDisplayAlertsStatus As Boolean
Dim wbWorkbook As Workbook
Dim shWorksheet As Worksheet
Dim bEnableEventsStatus As Boolean
Dim bIsTemplateSheet As Boolean
Dim iLastOccupiedRow As Long
Dim iFirstBlankRow As Long
Dim iHeaderRow As Long


Const START_KEY_SHEET_NAME As String = "StartKeys"
Const MAIN_KEY_SHEET_NAME As String = "MainKeys"
Const MASTER_TEMPLATE_SHEET_NAME As String = "Master Template"
Const TEMPLATE_SHEET_IDENTIFIER As String = "Template"
Const STARTKEYS_KEYSHEETS_URL_PREFIX As String = "A2"

Const STARTKEYS_FLATFILE_TEMPLATE_FILENAME_ADDRESS As String = "A5"
Const STARTKEYS_FLATFILE_TEMPLATE_CATEGORY_NAME_ADDRESS As String = "A8"

Const STARTKEYS_TEMPLATE_LANGUAGE_ADDRESS As String = "A11"
Const STARTKEYS_FEED_TYPE_ADDRESS As String = "A14"
Const STARTKEYS_UPLOAD_CLIENT_ADDRESS As String = "A17"
Const STARTKEYS_INTERNAL_TEMPLATE_NAME_ADDRESS As String = "A20"
Const STARTKEYS_STATUS_CHECK_URL_TYPE_ADDRESS As String = "A23"


Const STARTKEYS_KEYNAMES_STARTROW As Long = 27
Const CATEGORY_NAME_REPLACE_STRING As String = "<CATEGORY_NAME>"

On Error GoTo GenErr


If Val(Application.Version) >= 12 Then
    Dim iMsg As Long
'    iMsg = MsgBox( _
            "If this crashes or hangs Excel 2007, try Excel 2003. Excel 2007 bug. Google 486cf744 for fixes." & _
            vbNewLine & vbNewLine & _
            "You are currently running this in Excel 2007. Do you want to proceed?", vbCritical + vbYesNo, "Amazon Create Flat File Template")
    iMsg = AmazonMsgBox( _
            "If this crashes or hangs Excel 2007, try Excel 2003. Excel 2007 bug. Google 486cf744 for fixes." & _
            vbNewLine & vbNewLine & _
            "You are currently running this in Excel 2007. Do you want to proceed?", vbYesNo, "Amazon Create Flat File Template")

    If iMsg = vbYes Then
        'proceed.
    Else
        'cancel.
'        MsgBox "Flat file template creation has been cancelled.", vbOKOnly, "Amazon Create Flat File Template"
        AmazonMsgBox "Flat file template creation has been cancelled.", vbOKOnly, "Amazon Create Flat File Template"
        Exit Sub
    End If
End If


bEnableEventsStatus = GetEnableEventsStatusAndTurnItOff


'init:
'make sure revdates are clear from master before starting making templates:
ThisWorkbook.Names("Misc_Data_Table_Revdate").RefersToRange.value = ""
ThisWorkbook.Names("Dropdown_Lists_Table_Revdate").RefersToRange.value = ""
ThisWorkbook.Names("Data_Validation_Table_Revdate").RefersToRange.value = ""


'Loop through all workbooks in StartKeys folder:
Dim strStartKeysFolderPath As String
Dim fso As Object
Dim oFolder As Object
Dim oFile As Object
Dim cFilesInFolder
Const STARTKEYS_FOLDER_NAME As String = "StartKeys"
strStartKeysFolderPath = ThisWorkbook.Path & "\" & STARTKEYS_FOLDER_NAME & "\"
Set fso = CreateObject("Scripting.FileSystemObject")
If Not fso.FolderExists(strStartKeysFolderPath) Then
'    MsgBox "Cannot find ""StartKeys"" folder in path " & ThisWorkbook.Path & "\.", vbCritical + vbOKOnly, "Error finding StartKeys"
    AmazonMsgBox "Cannot find ""StartKeys"" folder in path " & ThisWorkbook.Path & "\.", vbOKOnly, "Error finding StartKeys"
    Application.EnableEvents = bEnableEventsStatus
    Exit Sub
End If
Set oFolder = fso.GetFolder(strStartKeysFolderPath)
Set cFilesInFolder = oFolder.Files
For Each oFile In cFilesInFolder
    
    'enableevents is getting turned back on between templates when creating more than one.
    'So, init for each template to be created:
    '(the initial enableevents state was already stored and it gets reset to that when all done.)
    Application.EnableEvents = False

    'close if already open:
    For Each wbWorkbook In Application.Workbooks
        If wbWorkbook.Name = oFile.Name Then
            wbWorkbook.Close SaveChanges:=False
        End If
        Exit For
    Next wbWorkbook

    Dim wbStartKeys As Workbook
    Set wbStartKeys = Workbooks.Open(strStartKeysFolderPath & oFile.Name, UpdateLinks:=0) '0 = do not update links. Links in JP AutoAccessory Ddef column A were causing crash.
    Set shStartKeys = wbStartKeys.Worksheets(1) 's/b only one.
    
    'copy settings from shStartKeys to International Settings:
    ThisWorkbook.Names(TEMPLATE_LANGUAGE_DEFINED_NAME).RefersToRange.value = shStartKeys.Range(STARTKEYS_TEMPLATE_LANGUAGE_ADDRESS).value
    ThisWorkbook.Names(FEED_TYPE_DEFINED_NAME).RefersToRange.value = shStartKeys.Range(STARTKEYS_FEED_TYPE_ADDRESS).value
    ThisWorkbook.Names(UPLOAD_CLIENT_DEFINED_NAME).RefersToRange.value = shStartKeys.Range(STARTKEYS_UPLOAD_CLIENT_ADDRESS).value
    ThisWorkbook.Names(INTERNAL_TEMPLATE_NAME_DEFINED_NAME).RefersToRange.value = shStartKeys.Range(STARTKEYS_INTERNAL_TEMPLATE_NAME_ADDRESS).value
    ThisWorkbook.Names(STATUS_CHECK_URL_TYPE_DEFINED_NAME).RefersToRange.value = shStartKeys.Range(STARTKEYS_STATUS_CHECK_URL_TYPE_ADDRESS).value
    

    
'    strMainKeysURL = shStartKeys.Range(STARTKEYS_MAINKEYS_URL_ADDRESS).Value
    
    
    'set filename and path:
    'then, check whether that full path exists; if it does, append timestamp to filename:
    strNewWorkbookFilename = shStartKeys.Range(STARTKEYS_FLATFILE_TEMPLATE_FILENAME_ADDRESS).value
    strNewWorkbookFullPath = ThisWorkbook.Path & "\" & strNewWorkbookFilename
'    Dim fso As Object
    Set fso = CreateObject("Scripting.FileSystemObject")
    If fso.FileExists(strNewWorkbookFullPath) Then
        Dim iLen As Long
        Dim iPosLastPeriod As Long
        Dim strBeforeLastPeriod As String
        Dim strAfterLastPeriod As String
        Dim iChr As Long
        Dim strChr As String
        Dim bFilenameHasNoPeriod As Boolean
        Dim strTimeStamp As String
        bFilenameHasNoPeriod = True 'init.
        iLen = Len(strNewWorkbookFilename)
        For iChr = iLen To 1 Step -1
            strChr = Mid(strNewWorkbookFilename, iChr, 1)
            If strChr = "." Then
                bFilenameHasNoPeriod = False
                iPosLastPeriod = iChr
                strBeforeLastPeriod = Left(strNewWorkbookFilename, iPosLastPeriod - 1)
                strAfterLastPeriod = Right(strNewWorkbookFilename, Len(strNewWorkbookFilename) - iPosLastPeriod)
                Exit For
            End If
        Next iChr
        strTimeStamp = "." & Format(Now(), "(h-mm-ss AM/PM)") & "(StartKeys = " & wbStartKeys.Name & ")."
        If bFilenameHasNoPeriod Then
            strNewWorkbookFilename = strNewWorkbookFilename & strTimeStamp
        Else
            strNewWorkbookFilename = strBeforeLastPeriod & strTimeStamp & strAfterLastPeriod
        End If
        strNewWorkbookFullPath = ThisWorkbook.Path & "\" & strNewWorkbookFilename
    End If

    
    
    
    'close if already open:
    For Each wbWorkbook In Application.Workbooks
        If wbWorkbook.Name = strNewWorkbookFilename Then
            wbWorkbook.Close SaveChanges:=False
        End If
        Exit For
    Next wbWorkbook
    
    strCategoryName = shStartKeys.Range(STARTKEYS_FLATFILE_TEMPLATE_CATEGORY_NAME_ADDRESS).value
    
    
    
    frmUpdatePleaseWait.lblUpdateCurrentAction = "Creating flat file template " & strNewWorkbookFilename & ". This may take several minutes..."
    frmUpdatePleaseWait.lblUpdatePleaseWait.Visible = False
'    frmUpdatePleaseWait.prgUpdate.Visible = False
    frmUpdatePleaseWait.lblProgressBar.Visible = False
    frmUpdatePleaseWait.frameProgressBar.Visible = False
    frmUpdatePleaseWait.Show vbModeless
    DoEvents
    
    
                             
    Set wbNewTemplate = CopyWorkbook(ThisWorkbook, strNewWorkbookFullPath, strNewWorkbookFilename)
    DoEvents
    
    'delete the Universal Master's Instructions sheet:
    bDisplayAlertsStatus = Application.DisplayAlerts
    Application.DisplayAlerts = False
    For Each shWorksheet In wbNewTemplate.Worksheets
        If shWorksheet.CodeName = "shUnivMastInst" Then
            shWorksheet.Delete
            DoEvents
            Exit For
        End If
    Next shWorksheet
    Application.DisplayAlerts = bDisplayAlertsStatus


    'delete the Universal Master's Version Notes sheet:
    bDisplayAlertsStatus = Application.DisplayAlerts
    Application.DisplayAlerts = False
    For Each shWorksheet In wbNewTemplate.Worksheets
        If shWorksheet.CodeName = "shVersionNotes" Then
            shWorksheet.Delete
            DoEvents
            Exit For
        End If
    Next shWorksheet
    Application.DisplayAlerts = bDisplayAlertsStatus
    


    '2009-06-18:
    'eliminating mainkeys:
    '===============================================================================================
    
'    Set shMainKeys = InsertWorksheetFromWorkbookURL(strMainKeysURL, , "MainKeys.xls")
'    If shMainKeys Is Nothing Then
'        Unload frmUpdatePleaseWait
'        MsgBox "Unable to make template. Unable to get MainKeys worksheet.", vbCritical + vbOKOnly, "Error making template"
'        Application.EnableEvents = bEnableEventsStatus
'        Exit Sub
'    End If
    
    'prep:
'    strKeysheetsURLPrefix = shMainKeys.Range("B2").Value
'    Set rgMainKeysKeynameCol = shMainKeys.Columns(1).EntireColumn
    ReDim shArrayTemplateSheets(0 To 0) As Worksheet
        uBoundTSh = 0
    
    strKeysheetsURLPrefix = shStartKeys.Range("A2").value
    '================================================================================================
    
   
    
    
    'get first and last rows of StartKeys:
    iStartKeysFirstRow = STARTKEYS_KEYNAMES_STARTROW
    Set rgFind = shStartKeys.Cells(shStartKeys.Rows.Count, 1).End(xlUp)
    iStartKeysLastRow = rgFind.Row
    
    'loop through startkeys rows, importing each sheet to wbNewTemplate:
    For iStartKeysRow = iStartKeysFirstRow To iStartKeysLastRow
        strStartKeysItemName = shStartKeys.Cells(iStartKeysRow, 1).value
        '2009-06-18:
        'eliminating mainkeys:
        '===============================================================================================
'        Set rgFind = rgMainKeysKeynameCol.Find(strStartKeysItemName, , xlValues, xlWhole, , , False)
'        If rgFind Is Nothing Then
'            iRet = MsgBox("Can't find " & strStartKeysItemName & " in MainKeys." & vbNewLine & vbNewLine & "Continue?", vbCritical + vbYesNo, "Error on " & strStartKeysItemName)
'            If iRet = vbYes Then
'                GoTo GoToSkipToNextStartKeysRow
'            Else
'                Unload frmUpdatePleaseWait
'                Application.EnableEvents = bEnableEventsStatus
'                DoEvents
'                Exit Sub
'            End If
'        End If
'        strStartKeysItemWorkbookName = rgFind.Offset(, 1).Value
        strStartKeysItemWorkbookName = strStartKeysItemName
        '===============================================================================================
        strStartKeysItemURL = strKeysheetsURLPrefix & strStartKeysItemWorkbookName
        Set shTemp = InsertWorksheetFromWorkbookURL(strStartKeysItemURL, wbNewTemplate)
        DoEvents
    
        'remove defined names with broken references:
        '(this may be causing a crash when saving??)
        Dim nm As Name
        For Each nm In wbNewTemplate.Names
            If InStr(nm.value, "#REF") > 0 Then
                nm.Delete
                DoEvents
            End If
        Next nm
    
        If shTemp Is Nothing Then
'            iRet = MsgBox("Unable to get " & strStartKeysItemName & " worksheet. Continue?", vbCritical + vbYesNo, "Error on " & strStartKeysItemName)
            iRet = AmazonMsgBox("Unable to get " & strStartKeysItemName & " worksheet. Continue?", vbYesNo, "Error on " & strStartKeysItemName)
            If iRet = vbNo Then
                Unload frmUpdatePleaseWait
                Application.EnableEvents = bEnableEventsStatus
                DoEvents
                Exit Sub
            End If
            GoTo GoToSkipToNextStartKeysRow
        End If
        
        
        
        'replace "<CATEGORY_NAME>":
        Dim rgFirst As Range
        Dim rgFindPrevious As Range
        Set rgFirst = Cells.Find(What:=CATEGORY_NAME_REPLACE_STRING, LookIn:=xlValues, LookAt:=xlPart)
        Call ResetFindParametersToDefaults
        Set rgFindPrevious = rgFirst
        Do
            If rgFirst Is Nothing Then Exit Do
            Set rgFind = Cells.Find(What:=CATEGORY_NAME_REPLACE_STRING, After:=rgFindPrevious, LookIn:=xlValues, LookAt:=xlPart)
            Call ResetFindParametersToDefaults
            'replace here.....
            If Not rgFind Is Nothing Then
                rgFind.value = Replace(rgFind.value, CATEGORY_NAME_REPLACE_STRING, strCategoryName)
'                Debug.Print rgFind.Address
            End If
            If rgFind.Address = rgFirst.Address Then Exit Do
            Set rgFindPrevious = rgFind
        Loop
        'this doesn't work in cells with very long text. Silent error is "Formula is too long":
'        bRet = Cells.Replace(What:=CATEGORY_NAME_REPLACE_STRING, Replacement:=strCategoryName, _
                             LookAt:=xlPart, MatchCase:=False)

        
        
        'check for whether this is a template sheet:
        bIsTemplateSheet = False 'init.
        If InStr(UCase(strStartKeysItemName), UCase(TEMPLATE_SHEET_IDENTIFIER)) > 0 Then
            'this is a template sheet:
            bIsTemplateSheet = True
            uBoundTSh = uBoundTSh + 1
            ReDim Preserve shArrayTemplateSheets(0 To uBoundTSh) As Worksheet
            Set shArrayTemplateSheets(uBoundTSh) = shTemp
    '        strNewTemplateName = shTemp.Name
        End If
        
        
        'set selection and scroll, and delete stray text below headers on template sheets:
        If Not ActiveSheet Is shTemp Then shTemp.Activate
        If bIsTemplateSheet Then
            ActiveWindow.ScrollRow = 1
            ActiveWindow.ScrollColumn = 1
            iHeaderRow = GetTemplateHeaderRow(shTemp)
            shTemp.Cells(iHeaderRow + 1, 1).Select
            shTemp.Range(shTemp.Cells(iHeaderRow + 1, 1), shTemp.Cells(shTemp.Rows.Count, shTemp.Columns.Count)).ClearContents
        Else
            'not a template sheet:
            shTemp.Range("A1").Select
            ActiveWindow.ScrollRow = 1
            ActiveWindow.ScrollColumn = 1
        End If
        
    
GoToSkipToNextStartKeysRow:
    Next iStartKeysRow
    
    'close this StartKeys workbook:
    bDisplayAlertsStatus = Application.DisplayAlerts
    Application.DisplayAlerts = False
    wbStartKeys.Close SaveChanges:=False
    Application.DisplayAlerts = bDisplayAlertsStatus
    
    
    'set master template sheet:
    Dim shMasterTemplate As Worksheet
    Set shMasterTemplate = wbNewTemplate.Worksheets(MASTER_TEMPLATE_SHEET_NAME)
    shMasterTemplate.Visible = True
    
    
    
    'move master template sheet to new template sheet's location,
    'copy from new to master, delete new, and rename master as new:
    'loop through multiple template sheets, as in CameraPhoto.
    'If strNewTemplateName = "" Then
    If uBoundTSh = 0 Then
        'no template sheets found:
        Unload frmUpdatePleaseWait
'        MsgBox "Can't find template sheet in " & wbNewTemplate.Name & ".", vbCritical + vbOKOnly, "Error finding template sheet"
        AmazonMsgBox "Can't find template sheet in " & wbNewTemplate.Name & ".", vbOKOnly, "Error finding template sheet"
        Application.EnableEvents = bEnableEventsStatus
        DoEvents
        Exit Sub
    End If
    Dim shNewTemplate As Worksheet
    Dim shTemplateSheetArrayItem As Worksheet
    Dim iArrayIndexTemplateSheets As Long
    Dim cmtNew As Comment
    Dim cmtMaster As Comment
    Dim iCommentIndex As Long
    Dim iCommentCount As Long
    Dim strNewTemplateSheetName As String
    
    
    'loop through template sheets:
    For iArrayIndexTemplateSheets = 1 To uBoundTSh
        
        Set shTemplateSheetArrayItem = shArrayTemplateSheets(iArrayIndexTemplateSheets)
        'Set shArrayTemplateSheets(iArrayIndexTemplateSheets) = Nothing 'no, this array is now being reused later.
        shTemplateSheetArrayItem.Visible = True
        
        'get selection address:
        Dim strSelectionAddress As String
        If Not wbNewTemplate Is ActiveWorkbook Then wbNewTemplate.Activate
        If Not shTemplateSheetArrayItem Is ActiveSheet Then shTemplateSheetArrayItem.Activate
        strSelectionAddress = Selection.Address
    
        
        'if this is not the first template sheet, make a new master template sheet:
        If iArrayIndexTemplateSheets > 1 Then
            DoEvents
            shMasterTemplate.Copy After:=shMasterTemplate
            DoEvents
            Dim shTmpMstr As Worksheet
            Set shTmpMstr = shMasterTemplate
            Set shMasterTemplate = wbNewTemplate.Worksheets(shMasterTemplate.index + 1)
            shMasterTemplate.Unprotect
            DoEvents


            'If Excel 2003 or earlier, copying sheet truncates cell text to 255 characters.
            'must copy/paste to fix:
            If Val(Application.Version) <= 11 Then
                'this is Excel 2003 or earlier. Fix cell text truncation:
                'wbKeysheetWorkbook is dest sheet.
                'ws is source sheet.
                Dim strUsedRangeAddress As String
                strUsedRangeAddress = shTmpMstr.UsedRange.Address
                shTmpMstr.Range(strUsedRangeAddress).Copy Destination:=shMasterTemplate.Range(strUsedRangeAddress)
                DoEvents
                Set shTmpMstr = Nothing
            End If


        End If
        
        
        'set selection:
        If Not wbNewTemplate Is ActiveWorkbook Then wbNewTemplate.Activate
        If Not shMasterTemplate Is ActiveSheet Then shMasterTemplate.Activate
        shMasterTemplate.Range(strSelectionAddress).Select
        
        
        'move:
        shMasterTemplate.Move After:=shTemplateSheetArrayItem
        DoEvents
        'copy:
        shTemplateSheetArrayItem.Cells.Copy
        shMasterTemplate.Paste Destination:=shMasterTemplate.Range("A1")
        DoEvents
        
        'position comments:
        iCommentCount = shTemplateSheetArrayItem.Comments.Count
        For iCommentIndex = 1 To iCommentCount
            Set cmtMaster = shMasterTemplate.Comments(iCommentIndex)
            Set cmtNew = shTemplateSheetArrayItem.Comments(iCommentIndex)
            cmtMaster.Shape.Top = cmtNew.Shape.Top
            cmtMaster.Shape.Left = cmtNew.Shape.Left
            cmtMaster.Shape.Height = cmtNew.Shape.Height
            cmtMaster.Shape.Width = cmtNew.Shape.Width
        Next iCommentIndex
        DoEvents
        
        'remove leading & trailing spaces and carriage returns from column names:
        Dim rgHeaderRange As Range, rgHeaderCell As Range
        Dim iLastCol As Long
        Dim strHeaderText As String, strOrigHeaderText As String
        iHeaderRow = GetTemplateHeaderRow(shTemplateSheetArrayItem)
        iLastCol = shTemplateSheetArrayItem.Cells(iHeaderRow, shTemplateSheetArrayItem.Columns.Count).End(xlToLeft).Column
        Set rgHeaderRange = shTemplateSheetArrayItem.Range( _
                                    shTemplateSheetArrayItem.Cells(iHeaderRow, 1), _
                                    shTemplateSheetArrayItem.Cells(iHeaderRow, iLastCol))
        For Each rgHeaderCell In rgHeaderRange.Cells
            strHeaderText = rgHeaderCell.value: strOrigHeaderText = strHeaderText
            strHeaderText = Trim(strHeaderText) 'removes leading and trailing spaces.
            strHeaderText = Replace(strHeaderText, Chr(10), "") 'removes carriage returns.
            If strHeaderText <> strOrigHeaderText Then rgHeaderCell.value = strHeaderText
        Next rgHeaderCell
        
        'copy freeze-panes settings:
        Dim bFreezePanes As Boolean
        Dim iSplitColumn As Long
        Dim iSplitRow As Long
        Dim bHadHiddenEnglishHeaderRow As Boolean
        Dim iHiddenEnglishHeaderRow As Long
        shTemplateSheetArrayItem.Activate
            bFreezePanes = ActiveWindow.FreezePanes
            iSplitColumn = ActiveWindow.SplitColumn
            iSplitRow = ActiveWindow.SplitRow
            If ActiveSheet.Rows(iSplitRow + 1).Hidden Then
                bHadHiddenEnglishHeaderRow = True
                iHiddenEnglishHeaderRow = iSplitRow + 1
                iSplitRow = iSplitRow + 1
            End If
        shMasterTemplate.Activate
            ActiveWindow.FreezePanes = False 'init, just in case it was turned on.
                'splitrow & splitcolumn do not refer to column and row numbers;
                'instead, they refer to the count of *visible* rows and columns
                'from the left and top. So, must first *scroll* to cell A1 in all panes.
            ActiveWindow.SplitColumn = 0 'removes vertical pane.
            ActiveWindow.SplitRow = 0 'removes horizontal pane.
            shMasterTemplate.Range("A1").Select 'scrolls to cell A1; applies to all panels when split in next lines.
            ActiveWindow.SplitColumn = iSplitColumn
            ActiveWindow.SplitRow = iSplitRow
            ActiveWindow.FreezePanes = bFreezePanes
            If bHadHiddenEnglishHeaderRow Then ActiveSheet.Rows(iHiddenEnglishHeaderRow).Hidden = True
            
        'delete:
        strNewTemplateSheetName = shTemplateSheetArrayItem.Name
        bDisplayAlertsStatus = Application.DisplayAlerts
        Application.DisplayAlerts = False
        shTemplateSheetArrayItem.Delete
        DoEvents
        Application.DisplayAlerts = bDisplayAlertsStatus
        'rename:
        shMasterTemplate.Name = strNewTemplateSheetName
        Set shArrayTemplateSheets(iArrayIndexTemplateSheets) = shMasterTemplate
        DoEvents
        
        
        'set selection and scroll:
        If Not ActiveSheet Is shMasterTemplate Then shMasterTemplate.Activate
        ActiveWindow.ScrollRow = 1
        ActiveWindow.ScrollColumn = 1
        iLastOccupiedRow = shMasterTemplate.Cells(shMasterTemplate.Rows.Count, 1).End(xlUp).Row
        iFirstBlankRow = iLastOccupiedRow + 1
        shMasterTemplate.Cells(iFirstBlankRow, 1).Select
        
        
        Call FixFormulaEqualsFormulaBug(shMasterTemplate)

        'protect the template sheet:
'        Call ProtectSheet(shMasterTemplate)
        
        DoEvents
    
    Next iArrayIndexTemplateSheets
    
    
  
    
    'don't show the 'create flat file template' toolbar:
    wbNewTemplate.Names(SHOW_CREATE_TEMPLATES_TOOLBAR_DEFINED_NAME).RefersToRange.value = False
    
    
    'hide the settings sheet:
    Dim strIntSettingsSheetName As String
    strIntSettingsSheetName = shIntSettings.Name
    wbNewTemplate.Worksheets(strIntSettingsSheetName).Visible = xlSheetVeryHidden
    
    ' added 10/08/10 by atambe
    ' remove unnecessary columns from translations sheet
    Call RemoveOtherLanguageColumnsFromIntTranslations(wbNewTemplate.Worksheets(shIntTranslations.Name), GetLocalLanguageName)
    
    ' added 10/08/10 by atambe
    ' copy defined names to translated strings
    Dim iTranslationsLastRow As Long
    Dim iTranslationsRow As Long
    Dim translationKey As String
    
    iTranslationsLastRow = wbNewTemplate.Worksheets(shIntTranslations.Name).Cells(shIntTranslations.Rows.Count, 1).End(xlUp).Row
    
    For iTranslationsRow = (INT_TABLE_HEADER_ROW + 1) To iTranslationsLastRow
        translationKey = "translation_key_" & wbNewTemplate.Worksheets(shIntTranslations.Name).Cells(iTranslationsRow, INT_TABLE_TRANSLATION_KEY_COLUMN).value
        wbNewTemplate.Names.Add translationKey, wbNewTemplate.Worksheets(shIntTranslations.Name).Cells(iTranslationsRow, INT_TABLE_TRANSLATION_STRING_COLUMN)
    Next
    
    ' added 10/08/10 by atambe
    'hide the translations sheet
    wbNewTemplate.Worksheets(shIntTranslations.Name).Visible = xlSheetVeryHidden

    'remove defined names with broken references:
    '(this may be causing a crash when saving??)
    For Each nm In wbNewTemplate.Names
        If InStr(nm.value, "#REF") > 0 Then
            nm.Delete
            DoEvents
        End If
    Next nm
    
    
    'cleanup:
'    Erase shArrayTemplateSheets 'no, it's now being reused later.
    'Set shTemp = Nothing
    Set shMasterTemplate = Nothing
    Set shTemplateSheetArrayItem = Nothing
    Set nm = Nothing
    Set cmtMaster = Nothing
    DoEvents
    
    
    'save:
    bDisplayAlertsStatus = Application.DisplayAlerts
    Application.DisplayAlerts = False
    DoEvents
    wbNewTemplate.Save
    DoEvents
    Application.DisplayAlerts = bDisplayAlertsStatus
    
    
    
    frmUpdatePleaseWait.lblUpdateCurrentAction = "Updating new flat file template " & strNewWorkbookFilename & ". This may take several minutes..."
    frmUpdatePleaseWait.lblUpdatePleaseWait.Visible = False
'    frmUpdatePleaseWait.prgUpdate.Visible = False
    frmUpdatePleaseWait.lblProgressBar.Visible = False
    frmUpdatePleaseWait.frameProgressBar.Visible = False
    frmUpdatePleaseWait.Repaint
    DoEvents
    
    
    
    'run update in new workbook:
    'need to get it to run update itself:
    Dim strAppRunTarget As String
'    bEnableEventsStatus = GetEnableEventsStatusAndTurnItOff
    wbNewTemplate.Activate
    
    
    'Stop
    'strAppRunTarget = wbNewTemplate.Name & "!SimpleTest"
    'Application.Run strAppRunTarget
    '
    '
    'Stop
    'strAppRunTarget = wbNewTemplate.Name & "!TestCallMeNoArg"
    'Application.Run strAppRunTarget
    '
    '
    'Stop
    'strAppRunTarget = wbNewTemplate.Name & "!TestCallMeOptionalArg"
    'Application.Run strAppRunTarget
    'Application.Run strAppRunTarget, True
    'Stop
    
'    Debug.Print "strAppRunTarget1"
    strAppRunTarget = "'" & wbNewTemplate.Name & "'!GetLatestInternationalizedData" '2009-10-02: added apostrophes around workbook name to allow it to work with workbook names that have hyphens (standard-book-template.xls).
    Application.Run strAppRunTarget, True
'    Debug.Print "strAppRunTarget2"
    'Stop
    'Application.EnableEvents = bEnableEventsStatus
    
    
'    Application.EnableEvents = bEnableEventsStatus
    
    
    Unload frmUpdatePleaseWait
    DoEvents
    
    'make the leftmost sheet (instructions sheet or ddef) active:
    Dim iWorksheetCount As Long
    Dim iWorksheetIndex As Long
    iWorksheetCount = wbNewTemplate.Worksheets.Count
    For iWorksheetIndex = iWorksheetCount To 1 Step -1
        wbNewTemplate.Worksheets(iWorksheetIndex).Activate
    Next iWorksheetIndex
    


    '===========================================================================================
    'bugfix:
    'close and reopen the workbook to work around Excel bug where worksheet area
    '(the cells) does not display until user clicks one of the tabs:
    DoEvents
    wbNewTemplate.Close SaveChanges:=True
    DoEvents
    Set wbNewTemplate = Workbooks.Open(FileName:=strNewWorkbookFullPath, UpdateLinks:=False)
    DoEvents

    'reset object references that were based on wbNewTemplate:
    'shArrayTemplateSheets
    Dim iShCounter As Long
    iShCounter = 0 'init.
    For Each shWorksheet In wbNewTemplate.Worksheets
        If InStr(UCase(shWorksheet.CodeName), UCase(TEMPLATE_SHEET_IDENTIFIER)) > 0 Then
            'this is a template sheet:
            iShCounter = iShCounter + 1
            Set shArrayTemplateSheets(iShCounter) = shWorksheet
                '(lBound is 0, but first sheet is index 1.)
        End If
    Next shWorksheet
    '===========================================================================================



    'remove versioned overrides for international table urls:
    DoEvents
    wbNewTemplate.Names("Versioned_Override_Misc_Data_Table_URL").RefersToRange.ClearContents
    DoEvents
    wbNewTemplate.Names("Versioned_Override_Data_Validation_Table_URL").RefersToRange.ClearContents
    DoEvents
    wbNewTemplate.Names("Versioned_Override_Dropdown_Lists_Table_URL").RefersToRange.ClearContents
    DoEvents
    
    



    'repair JP column letter formulas:
        'replace path in the formulas to point to the template sheet in the same template.
        '(this won't work with multiple template sheets, but I've never seen a template with
            'multiple template sheets that also has the column letter formulas.)
    Const REPAIR_KEY As String = "SUBSTITUTE(ADDRESS(1,MATCH("
    Dim strFormula As String, strTemplateSheetName As String
    Dim iPosOpenSquare As Long, iPosClosingSquare As Long, iRemoveLen As Long, strRemoveString As String
    Dim iPosKey As Long, iAfterPosKey As Long, iPosComma As Long, iPosBang As Long, iPosReplaceStart As Long, iReplaceLen As Long, strReplaceString As String, strBeforeReplaceString As String, strAfterReplaceString As String
    Dim bNoCellsFoundError As Boolean
    
    
    Set shTemplateSheetArrayItem = shArrayTemplateSheets(1)
    strTemplateSheetName = shTemplateSheetArrayItem.Range("A1").Address(, , , True)
    iPosOpenSquare = InStr(strTemplateSheetName, "[")
    iPosClosingSquare = InStr(strTemplateSheetName, "]")
    iRemoveLen = (iPosClosingSquare - iPosOpenSquare) + 1 'remove the square brackets too.
    strRemoveString = Mid(strTemplateSheetName, iPosOpenSquare, iRemoveLen)
    strTemplateSheetName = Replace(strTemplateSheetName, strRemoveString, "")
    iPosBang = InStr(strTemplateSheetName, "!")
    strTemplateSheetName = Left(strTemplateSheetName, iPosBang - 1)
    
    For Each shWorksheet In wbNewTemplate.Worksheets
        If shWorksheet.index <> shTemplateSheetArrayItem.index Then
            bNoCellsFoundError = False 'init.
            Set rgFormulas = shWorksheet.Cells.SpecialCells(xlCellTypeFormulas)
            If Not bNoCellsFoundError Then
                For Each rgCell In rgFormulas.Cells
                    strFormula = rgCell.Formula
                    iPosKey = InStr(strFormula, REPAIR_KEY)
                    iAfterPosKey = iPosKey + Len(REPAIR_KEY)
                    If iPosKey > 0 Then
                        'repair this formula:
                        iPosComma = InStr(iAfterPosKey, rgCell.Formula, ",")
                        strBeforeReplaceString = Left(strFormula, iPosComma)
                        iPosBang = InStr(iPosComma, rgCell.Formula, "!")
                        iPosReplaceStart = iPosBang - 1
                        iReplaceLen = Len(strFormula) - iPosReplaceStart 'include the "!" here.
                        strAfterReplaceString = Right(strFormula, iReplaceLen)
'                        strReplaceString = Mid(strFormula, iPosReplaceStart, iReplaceLen)
'                        strFormula = Replace(strFormula, strReplaceString, strTemplateSheetName) 'this doesn't work; maybe due to the Japanese characters?
                        strFormula = strBeforeReplaceString & strTemplateSheetName & strAfterReplaceString
                        rgCell.NumberFormat = "General"
                        rgCell.Formula = strFormula
                    End If
                Next rgCell
            End If
        End If
    Next shWorksheet
     

    
    
    'very--hide sheets:
    DoEvents
    Call VeryHideSheetsSub(wbNewTemplate)
    DoEvents
    
    

    bDisplayAlertsStatus = Application.DisplayAlerts
    Application.DisplayAlerts = False
    DoEvents
    wbNewTemplate.Save
    DoEvents





    'For JP, make no-macro version:
    If wbNewTemplate.Names(TEMPLATE_LANGUAGE_DEFINED_NAME).RefersToRange.value = INT_TABLE_JAPANESE_HEADER Then
        Call CreateNoMacroVersionMain(wbNewTemplate, False)
        'wbNewTemplate is no longer open after that, so reopen it:
        Set wbNewTemplate = Workbooks.Open(strNewWorkbookFullPath, UpdateLinks:=0) '0 = do not update links.
    End If
    
    
    
      


    frmUpdatePleaseWait.lblUpdateCurrentAction = "Checking column integrity and writing report..."
    frmUpdatePleaseWait.lblUpdatePleaseWait.Visible = False
'    frmUpdatePleaseWait.prgUpdate.Visible = False
    frmUpdatePleaseWait.lblProgressBar.Visible = False
    frmUpdatePleaseWait.frameProgressBar.Visible = False
    frmUpdatePleaseWait.Repaint
    DoEvents
    
'    On Error GoTo 0 ' DGM DEBUG: temporarily reset normal error handling.
        
    Dim wbColumnsReport As Workbook
    Set wbColumnsReport = AuditColumns(wbNewTemplate)
    
'    On Error GoTo GenErr ' DGM DEBUG: Resume normal operation..


'wbNewTemplate is now being closed in AuditColumns:
'    DoEvents
''    wbNewTemplate.Close SaveChanges:=True 'Excel 2007 is crashing here. No time to fix now..
'    wbNewTemplate.Close SaveChanges:=False 'Excel 2007 is crashing (SP1) or hanging (SP2) anyway,
'                                           'and need to close these templates as they are created
'                                           'when making a large batch.
    DoEvents
    Application.DisplayAlerts = bDisplayAlertsStatus


Next oFile




ThisWorkbook.Names("Misc_Data_Table_Revdate").RefersToRange.value = ""
ThisWorkbook.Names("Dropdown_Lists_Table_Revdate").RefersToRange.value = ""
ThisWorkbook.Names("Data_Validation_Table_Revdate").RefersToRange.value = ""

AmazonMsgBox "Done creating flat file templates:" & _
             vbNewLine & vbNewLine & _
             ThisWorkbook.Path & "\" & _
             vbNewLine & vbNewLine & _
             "REMEMBER TO GENERATE NEW VALIDATION ERROR TEXT TRANSLATION LISTS IF APPLICABLE!!!" & _
             vbNewLine & _
             "(in each template, run mdlMaster | ExportValidationCellCommentListToBeTranslated)", _
             vbOKOnly, "Done"

Application.EnableEvents = bEnableEventsStatus

'now that enableevents is back to true (should be), activate the universal master,
'to avoid problem of toolbar buttons pointing to wrong file:
ThisWorkbook.Activate


'at very end, activate columns report workbook:
'something broke here... return error handling to standard.
'On Error GoTo 0
DoEvents
wbColumnsReport.Activate
DoEvents



Exit Sub
GenErr:
If InStr(UCase(Err.Description), "NO CELLS") > 0 Then
    bNoCellsFoundError = True
    Resume Next
End If
If False Then
    Resume
End If

Unload frmUpdatePleaseWait
'MsgBox "Unable to make template. General Error", vbCritical + vbOKOnly, "Error making template"
AmazonMsgBox "Unable to make template. General Error", vbOKOnly, "Error making template"
If False Then
    Resume
End If
Application.EnableEvents = bEnableEventsStatus
ThisWorkbook.Activate

Application.EnableEvents = bEnableEventsStatus

End Sub




Sub MakeInternationalTemplates()

Dim bRet As Boolean
Dim bEnableEventsStatus As Boolean

Application.EnableEvents = True

bEnableEventsStatus = Application.EnableEvents
bRet = MakeTemplates(INT_TABLE_MASTER_NAME_HEADER)

If Not bRet Then Exit Sub

If Not bCancelCreatingInternationalTemplates Then
'    MsgBox strMsg, vbInformation + vbOKOnly, "Language Templates Saved"
    AmazonMsgBox strMsg, vbOKOnly, GetTranslatedString("lang_templates_saved")
End If

Application.EnableEvents = bEnableEventsStatus

End Sub


Public Sub SimpleTest()

    AmazonMsgBox "running SimpleTest."

End Sub



Public Sub TestCallMeNoArg()

AmazonMsgBox "Running TestCallMeNoArg."

End Sub


Public Sub TestCallMeOptionalArg(Optional arg)
    AmazonMsgBox "Running TestCallMeOptionalArg."
    If Not IsMissing(arg) Then AmazonMsgBox arg
End Sub



Public Sub GetLatestInternationalizedData(Optional is_external_call As Boolean)

Dim shIntTable As Worksheet
Dim shValidationTable As Worksheet
Dim shDropdownTable As Worksheet
Dim bRet As Boolean
Dim bUpdateFound As Boolean
Dim strTemplateLanguage As String
Dim shUserActiveSheet As Worksheet
Dim bScreenUpdatingSetting As Boolean
Dim bDisplayAlertsStatus As Boolean
Dim bEnableEvents As Boolean

On Error GoTo GenErr

'MsgBox "test - about to stop"
'Stop
'Debug.Print "starting GetLatestInternationalizedData..."


'Application.EnableEvents = True 'commented out 2009-10-27. Crashing building JP Auto.

'dock the dropdown:
Call DockDropdown
'Debug.Print "done with DockDropdown..."

If Not is_external_call Then
'    Debug.Print 1
    bUpdateNow = False 'init.
    frmAutoIntUpdateInterval.Show vbModal
    Unload frmAutoIntUpdateInterval
    DoEvents
End If

If Not bUpdateNow And Not is_external_call Then
'    Debug.Print 3
    DoEvents
'    Debug.Print "cancelling per bUpdateNow..."
'    MsgBox "Template update has been cancelled", vbInformation + vbOKOnly, "Template Update"
    AmazonMsgBox GetTranslatedString("template_update_cancelled"), vbOKOnly, GetTranslatedString("template_update")
    Exit Sub
End If


If Not is_external_call Then
'    Debug.Print 2
'    bUpdateNow = True
    frmUpdatePleaseWait.lblUpdateCurrentAction = "Updating " & ThisWorkbook.Name & "."
'    frmUpdatePleaseWait.prgUpdate.value = 2
    frmUpdatePleaseWait.lblProgressBar.Width = 0.02 * frmUpdatePleaseWait.frameProgressBar.Width
    frmUpdatePleaseWait.Show vbModeless
    DoEvents
End If



bScreenUpdatingSetting = Application.ScreenUpdating
Application.ScreenUpdating = False
bDisplayAlertsStatus = Application.DisplayAlerts
Application.DisplayAlerts = False
bEnableEvents = Application.EnableEvents
Application.DisplayAlerts = False

Set shUserActiveSheet = ActiveSheet

'If Not is_external_call Then
''    Debug.Print 4
'    frmUpdatePleaseWait.Show vbModeless
'    DoEvents
'End If


'download web tables:
'(see also modInternational.MakeTemplates)
Dim rgOldRevDate As Range
bUpdateFound = False 'init.
bRet = True 'init.
'======================================================================================================
If Not is_external_call Then
'    Debug.Print 5
    frmUpdatePleaseWait.lblUpdateCurrentAction = GetTranslatedString("importing_intl_table")
'    frmUpdatePleaseWait.prgUpdate.value = 5
    frmUpdatePleaseWait.lblProgressBar.Width = 0.05 * frmUpdatePleaseWait.frameProgressBar.Width
    frmUpdatePleaseWait.Repaint
DoEvents
End If
'Debug.Print "about to download miscdata..."
Set rgOldRevDate = ThisWorkbook.Names("Misc_Data_Table_Revdate").RefersToRange
Set shIntTable = DownloadInternationalTableFromWeb(FULL_MISC_DATA_TABLE_URL_DEFINED_NAME, _
                      INT_TABLE_WORKSHEET_NAME, rgOldRevDate, "international data")
If bCancelCreatingInternationalTemplates Then GoTo CancelCreatingInternationalTemplates


If Not is_external_call Then
    frmUpdatePleaseWait.lblUpdateCurrentAction = GetTranslatedString("importing_dropdown_lists")
'    frmUpdatePleaseWait.prgUpdate.value = 10
    frmUpdatePleaseWait.lblProgressBar.Width = 0.1 * frmUpdatePleaseWait.frameProgressBar.Width
    frmUpdatePleaseWait.Repaint
    DoEvents
End If
'Debug.Print "about to download dropdowns..."
Set rgOldRevDate = ThisWorkbook.Names("Dropdown_Lists_Table_Revdate").RefersToRange
Set shDropdownTable = DownloadInternationalTableFromWeb(FULL_DROPDOWN_LISTS_TABLE_URL_DEFINED_NAME, _
                      DROPDOWN_LISTS_TABLE_WORKSHEET_NAME, rgOldRevDate, "dropdown lists")
If bCancelCreatingInternationalTemplates Then GoTo CancelCreatingInternationalTemplates


If Not is_external_call Then
    frmUpdatePleaseWait.lblUpdateCurrentAction = GetTranslatedString("importint_validation_table")
'    frmUpdatePleaseWait.prgUpdate.value = 15
    frmUpdatePleaseWait.lblProgressBar.Width = 0.15 * frmUpdatePleaseWait.frameProgressBar.Width
    frmUpdatePleaseWait.Repaint
    DoEvents
End If
'Debug.Print "about to download validation table..."
Set rgOldRevDate = ThisWorkbook.Names("Data_Validation_Table_Revdate").RefersToRange
Set shValidationTable = DownloadDataValidationTableFromWeb(FULL_DATA_VALIDATION_TABLE_URL_DEFINED_NAME, rgOldRevDate)
If bCancelCreatingInternationalTemplates Then GoTo CancelCreatingInternationalTemplates
'======================================================================================================



strTemplateLanguage = GetLocalLanguageName

If Not shDropdownTable Is Nothing Then 'skip if dropdown lists table was not updated.
    bUpdateFound = True
    If Not is_external_call Then
        frmUpdatePleaseWait.lblUpdateCurrentAction = GetTranslatedString("integrating_dropdown_lists")
'        frmUpdatePleaseWait.prgUpdate.value = 20
        frmUpdatePleaseWait.lblProgressBar.Width = 0.2 * frmUpdatePleaseWait.frameProgressBar.Width
        frmUpdatePleaseWait.Repaint
        DoEvents
    End If
    'Debug.Print "about to apply dropdown lists..."
    bRet = ApplyDropDownLists(ThisWorkbook, strTemplateLanguage)
    'Debug.Print "done applying dropdown lists..."
    If Not is_external_call Then
        frmUpdatePleaseWait.lblUpdateCurrentAction = GetTranslatedString("finishing_up")
        frmUpdatePleaseWait.Repaint
        DoEvents
    End If
    
    'delete data sheets that are no longer needed:
    'shIntTable.Delete 'this is used for determining dropdown lists.
    shDropdownTable.Delete
End If
'ThisWorkbook.Save 'no, it gets saved below.

'can't reset local column headers. Getting new or changed column headers will require downloading new localized template made by new general template.


If Not shValidationTable Is Nothing Then 'skip if data validation table was not updated.
    bUpdateFound = True
    'remove unneccessary rows in validation table:
    Call RemoveUnneccessaryRowsInValidationTable(ThisWorkbook)
    
    
    'remove unneccessary columns in validation table:
    Call RemoveUnneccessaryColumnsInValidationTable(ThisWorkbook)
    
    'sort the validation table by Validate Column:
    Dim iValidateColumnCol As Long
    iValidateColumnCol = shValidationTable.Rows(DATA_VALIDATION_TABLE_HEADER_ROW).Find(What:=DATA_VALIDATION_TABLE_VALIDATE_COLUMN_HEADER, LookAt:=xlWhole).Column
    Call ResetFindParametersToDefaults
    DoEvents
    ThisWorkbook.Save 'to reset UsedRange (and LastCell, etc.) before getting range to sort.
    DoEvents
    shValidationTable.UsedRange.Sort Key1:=shValidationTable.Cells(1, iValidateColumnCol), Order1:=xlAscending, header:=xlYes, Orientation:=xlTopToBottom, SortMethod:=xlPinYin
End If


If Not shIntTable Is Nothing Then
    bUpdateFound = True
    'remove other language columns from intMiscData sheet:
    Call RemoveOtherLanguageColumnsFromIntMiscData(shIntTable, strTemplateLanguage)

    'reset toolbar button captions:
    'Debug.Print "about to apply local toolbar button settings..."
    Call ApplyLocalToolbarButtonSettings(strTemplateLanguage, shIntTable)
    'Debug.Print "done applying local toolbar button settings..."
    RemoveToolBar
    SetUpNewToolBar
End If


CancelCreatingInternationalTemplates:
If bCancelCreatingInternationalTemplates Then
    Unload frmUpdatePleaseWait
End If


'reactivate sheet that user originally had active, if it still exists and is visible:
On Error GoTo AttemptActivateOriginalSheet
shUserActiveSheet.Activate
On Error GoTo GenErr

If bRet Then
    ThisWorkbook.Save
    DoEvents
End If

Unload frmUpdatePleaseWait

Application.ScreenUpdating = bScreenUpdatingSetting
Application.DisplayAlerts = bDisplayAlertsStatus
Application.EnableEvents = bEnableEvents

If Not is_external_call Then
    If bUpdateFound And bRet Then
'        If Not bUpdateNow Then
'            MsgBox "Template has been updated.", vbInformation + vbOKOnly, "Template Update"
            AmazonMsgBox GetTranslatedString("template_updated"), vbOKOnly, GetTranslatedString("template_update")
'        End If
    ElseIf bRet Then
'        MsgBox "Updated data not yet available.", vbInformation + vbOKOnly, "Template Update"
        AmazonMsgBox "Updated data not yet available.", vbOKOnly, GetTranslatedString("template_update")
    Else
'        MsgBox "Error updating template.", vbInformation + vbOKOnly, "Template Update"
        AmazonMsgBox "Error updating template.", vbOKOnly, GetTranslatedString("template_update")
    End If
End If

Exit Sub

GenErr:

Debug.Print "Err: " & Err.Description

If False Then
    Resume
End If

Application.ScreenUpdating = bScreenUpdatingSetting
Application.DisplayAlerts = bDisplayAlertsStatus
Application.EnableEvents = bEnableEvents

Exit Sub

AttemptActivateOriginalSheet:

If False Then
    Resume
End If

Resume Next

End Sub




Sub CheckForAutoUpdate()

Dim vAutoUpdate As Variant
Dim vUpdateInterval As Variant
Dim vLastUpdate As Variant

vAutoUpdate = ThisWorkbook.Names(AUTO_UPDATE_DEFINED_NAME).RefersToRange.value

If vAutoUpdate Then
    vUpdateInterval = ThisWorkbook.Names(UPDATE_INTERVAL_DAYS_DEFINED_NAME).RefersToRange.value
    vLastUpdate = ThisWorkbook.Names(LAST_UPDATE_DEFINED_NAME).RefersToRange.value
    
    If vLastUpdate + vUpdateInterval < Now Then
        GetLatestInternationalizedData
    End If
    
End If







End Sub



Public Sub AddToolbarToBuildFlatFileTemplates()

Dim cbFlatFileMaster As CommandBar
Dim cbcBuildTemplates As CommandBarControl
Dim cbcAdminToolsMenu As CommandBarControl
Dim bRet As Boolean

If ThisWorkbookShowsTheBuildTemplatesToolbar Then

    bRet = DeleteToolbar(AMAZON_FLATFILE_TEMPLATE_MASTER_COMMANDBAR_NAME)
    
    Set cbFlatFileMaster = Application.CommandBars.Add(AMAZON_FLATFILE_TEMPLATE_MASTER_COMMANDBAR_NAME, msoBarTop, , True)
    
    cbFlatFileMaster.Visible = True
    
    Set cbcBuildTemplates = cbFlatFileMaster.Controls.Add(msoControlButton)
    cbcBuildTemplates.BeginGroup = True
    cbcBuildTemplates.Caption = AMAZON_FLATFILE_TEMPLATE_MASTER_COMMANDBAR_NAME
    cbcBuildTemplates.TooltipText = "Create flat-file templates for all StartKeys files in StartKeys folder."
    cbcBuildTemplates.FaceId = 303
    cbcBuildTemplates.OnAction = "MakeTemplatesV2"
    cbcBuildTemplates.Style = msoButtonIconAndCaption
    


'=======================================================================================================
    Set cbcAdminToolsMenu = cbFlatFileMaster.Controls.Add(msoControlPopup)
    cbcAdminToolsMenu.BeginGroup = True
    cbcAdminToolsMenu.Caption = "Flat-File Templates Tools"
    cbcAdminToolsMenu.TooltipText = "Tools for Amazon.com employees working with flat-file templates"

    'add controls to very-hide and unhide sheets:
    Set cbcBuildTemplates = cbcAdminToolsMenu.Controls.Add(msoControlPopup)
    cbcBuildTemplates.BeginGroup = True
    cbcBuildTemplates.Caption = TOOLBAR_BUTTON_CAPTION_VERYHIDE_UNHIDE

             'add menu item very-hide:
             Dim cbcDD As Object
             Set cbcDD = cbcBuildTemplates.Controls.Add(msoControlButton)
             cbcDD.Caption = "Very-Hide Sheets"
             cbcDD.TooltipText = "Set certain sheets to ""Very Hidden"" in a flat-file template."
             cbcDD.FaceId = 1640
             cbcDD.OnAction = "VeryHideSheets"
             cbcDD.Style = msoButtonIconAndCaption

             'add menu item unhide:
             Set cbcDD = cbcBuildTemplates.Controls.Add(msoControlButton)
             cbcDD.Caption = "Unhide Sheets"
             cbcDD.TooltipText = "Unhide all sheets in a flat-file template."
             cbcDD.FaceId = 1820
             cbcDD.OnAction = "UnhideSheets"
             cbcDD.Style = msoButtonIconAndCaption

            'add button for diff report:
            Set cbcDD = cbcAdminToolsMenu.Controls.Add(msoControlButton)
            cbcDD.BeginGroup = True
            cbcDD.Caption = TOOLBAR_BUTTON_CAPTION_EXCEL_DIFF_REPORT
            cbcDD.TooltipText = "Find differences between two Excel workbooks."
            cbcDD.FaceId = 660 '3415 '660* '543* '509
            cbcDD.OnAction = "ExcelSimpleDiff"
            cbcDD.Style = msoButtonIconAndCaption

            'add button for setting a template as release candidates
            Set cbcDD = cbcAdminToolsMenu.Controls.Add(msoControlButton)
            cbcDD.BeginGroup = True
            cbcDD.Caption = TOOLBAR_BUTTON_CAPTION_SET_AS_RELEASE_CANDIDATES
            cbcDD.TooltipText = "Set flat-file templates in chosen folder as Prod versions (set is_devo = false)."
            cbcDD.FaceId = 610
            cbcDD.OnAction = "SetAsReleaseCandidates"
            cbcDD.Style = msoButtonIconAndCaption
        
            'add button for columns check
            Set cbcDD = cbcAdminToolsMenu.Controls.Add(msoControlButton)
            cbcDD.BeginGroup = True
            cbcDD.Caption = TOOLBAR_BUTTON_CAPTION_COMPARE_COLUMNS
            cbcDD.TooltipText = "Run report checking column integrity for chosen flat-file template."
            cbcDD.FaceId = 250
            cbcDD.OnAction = "AuditColumns_With_SavedWorkbook"
            cbcDD.Style = msoButtonIconAndCaption
        
            'add button for creating no-macro version
            Set cbcDD = cbcAdminToolsMenu.Controls.Add(msoControlButton)
            cbcDD.BeginGroup = True
            cbcDD.Caption = TOOLBAR_BUTTON_CAPTION_CREATE_NO_MACRO_VERSION_OF_TEMPLATE
            cbcDD.TooltipText = "Create a new flat-file template with no macros from the chosen flat-file template."
            cbcDD.FaceId = 1399 '729 '2137
            cbcDD.OnAction = "CreateNoMacroVersionFromPrompt"
            cbcDD.Style = msoButtonIconAndCaption

            'add button for splitting out keysheets
            Set cbcDD = cbcAdminToolsMenu.Controls.Add(msoControlButton)
            cbcDD.BeginGroup = True
            cbcDD.Caption = TOOLBAR_BUTTON_CAPTION_SPLIT_OUT_KEYSHEETS
            cbcDD.TooltipText = "Create KeySheets from existing flat-file template."
            cbcDD.FaceId = 245
            cbcDD.OnAction = "SplitOutKeysheets"
            cbcDD.Style = msoButtonIconAndCaption

            'add button for removing tags from filenames
            Set cbcDD = cbcAdminToolsMenu.Controls.Add(msoControlButton)
            cbcDD.BeginGroup = True
            cbcDD.Caption = TOOLBAR_BUTTON_CAPTION_REMOVE_TAGS_FROM_FILENAMES
            cbcDD.TooltipText = "Remove tags (in parens) from all filenames in chosen folder."
            cbcDD.FaceId = 714
            cbcDD.OnAction = "RemoveTagsFromFilenames"
            cbcDD.Style = msoButtonIconAndCaption
'=======================================================================================================


'    'add button for exporting validation translation lists
'    Set cbcBuildTemplates = cbFlatFileMaster.Controls.Add(msoControlButton)
'    cbcBuildTemplates.BeginGroup = True
'    cbcBuildTemplates.Caption = TOOLBAR_BUTTON_CAPTION_EXPORT_VALIDATION_TRANSLATION_LISTS
'    cbcBuildTemplates.FaceId = 303
'    cbcBuildTemplates.OnAction = "ExportValidationCellCommentListsToBeTranslated"
'    cbcBuildTemplates.Style = msoButtonIconAndCaption

End If

End Sub



Public Sub DeleteToolbarToBuildInternationalTemplates()

If ThisWorkbookShowsTheBuildTemplatesToolbar Then
    DeleteToolbar AMAZON_FLATFILE_TEMPLATE_MASTER_COMMANDBAR_NAME
End If

End Sub



Public Function ToolbarToBuildInternationalTemplatesExists() As Boolean

Dim cbCommandBar As CommandBar
Dim bFound As Boolean

bFound = False
For Each cbCommandBar In Application.CommandBars
    If cbCommandBar.Name = AMAZON_FLATFILE_TEMPLATE_MASTER_COMMANDBAR_NAME Then
        bFound = True
        Exit For
    End If
Next cbCommandBar

If bFound Then
    ToolbarToBuildInternationalTemplatesExists = True
Else
    ToolbarToBuildInternationalTemplatesExists = False
End If

End Function



Public Function ToolbarAmazonFeedManagerExists() As Boolean

Dim cbCommandBar As CommandBar
Dim bFound As Boolean

bFound = False
For Each cbCommandBar In Application.CommandBars
    If cbCommandBar.Name = AMAZON_FLAT_FILE_MANAGER_COMMANDBAR_NAME Then
        bFound = True
        Exit For
    End If
Next cbCommandBar

If bFound Then
    ToolbarAmazonFeedManagerExists = True
Else
    ToolbarAmazonFeedManagerExists = False
End If

End Function


Public Function ThisWorkbookShowsTheBuildTemplatesToolbar() As Boolean

If ThisWorkbook.Names(SHOW_CREATE_TEMPLATES_TOOLBAR_DEFINED_NAME).RefersToRange.value Then
    ThisWorkbookShowsTheBuildTemplatesToolbar = True
Else
    ThisWorkbookShowsTheBuildTemplatesToolbar = False
End If

End Function


Public Function OtherOpenWorkbookNeedsAmazonFeedManagerToolbar() As Boolean

'checks whether another workbook is open that needs that toolbar. If not,
'it deletes the toolbar; otherwise, it does nothing.

'returns true if toolbar was deleted, false if not.

Dim wbWorkbook As Workbook
Dim nmName As Name
Dim bFound As Boolean

bFound = False 'init.
For Each wbWorkbook In Workbooks
    If Not wbWorkbook Is ThisWorkbook Then
        For Each nmName In wbWorkbook.Names
            If nmName.Name = IS_SIMPLIFIED_OFFER_FEED_WORKBOOK_DEFINED_NAME Then
                bFound = True
                Exit For
            End If
        Next nmName
    End If
    If bFound Then Exit For
Next wbWorkbook

If bFound Then
    OtherOpenWorkbookNeedsAmazonFeedManagerToolbar = True
Else
    OtherOpenWorkbookNeedsAmazonFeedManagerToolbar = False
End If

End Function



Public Function DeleteToolbar(toolbar_name As String)

Dim bRet As Boolean

Do
    bRet = DeleteCommandBar(toolbar_name)
Loop Until Not bRet

DeleteToolbar = True

End Function



Function DeleteCommandBar(command_bar_name As String) As Boolean

'returns true if command_bar_name existed and was deleted;
'returns false if command_bar_name was not found.
'call this function in loop until it returns false.

On Error GoTo NoBar

DeleteCommandBar = False 'init.

Application.CommandBars(command_bar_name).Delete

DeleteCommandBar = True

NoBar:

End Function



Function DownloadInternationalTableFromWeb(url_defined_name_string As String, _
                                           worksheet_name As String, _
                                           old_rev_date As Range, _
                                           msgbox_text As String) As Worksheet

Dim strURL As String
Dim qtQueryTable As QueryTable
Dim shInternationalTable As Worksheet
Dim bRet As Boolean
Dim shWorksheet As Worksheet
Dim bOldInternationalDataWorksheetExists As Boolean
Dim iRet As Long
Dim bDisplayAlertsStatus As Boolean
Dim shActiveSheet As Worksheet

On Error GoTo GenErr

bOldInternationalDataWorksheetExists = False 'init.
For Each shWorksheet In ThisWorkbook.Worksheets
    If shWorksheet.Name = worksheet_name Then
        bOldInternationalDataWorksheetExists = True
        Exit For
    End If
Next shWorksheet


strURL = ThisWorkbook.Names(url_defined_name_string).RefersToRange.value


Set shActiveSheet = ActiveSheet
'Set shInternationalTable = ThisWorkbook.Worksheets.Add(After:=ThisWorkbook.Worksheets(ThisWorkbook.Worksheets.Count))

'bRet = DownloadTableFromWebByURL(shInternationalTable.Range("A1"), strURL)

Set shInternationalTable = InsertWorksheetFromUrl(strURL)

If shInternationalTable Is Nothing Then
    bRet = False
Else
    bRet = True
End If



If bRet Then
    'download was successful:
        bDisplayAlertsStatus = Application.DisplayAlerts
        Application.DisplayAlerts = False
        Dim bUseImportedSheet As Boolean
'        If Not ThisWorkbook.Worksheets(worksheet_name) Is shInternationalTable Then
            
            
            'check revdate:
            Dim dblOldRevDate As Double
            Dim rgImportRevDate As Range
            Dim dblImportRevDate As Double
            Set rgImportRevDate = shInternationalTable.Cells.Find("REVDATE").Offset(ColumnOffset:=1)
            Call ResetFindParametersToDefaults
            If rgImportRevDate Is Nothing Then
                'imported file's revdate not found.
                bUseImportedSheet = True
            Else
                'imported file's revdate was found.
                On Error GoTo ErrGetDate
                dblImportRevDate = CDbl(Format(CVar(rgImportRevDate.value), "0.0000000000"))
                If old_rev_date.value = "" Then
                    dblOldRevDate = -1
                Else
                    dblOldRevDate = CDbl(Format(CVar(old_rev_date.value), "0.0000000000"))
                End If
                On Error GoTo GenErr
                
                If dblImportRevDate >= dblOldRevDate Then
                    'imported file is same revdate or newer:
                    bUseImportedSheet = True
                   
                Else
                    'imported file is NOT newer:
                    bUseImportedSheet = False
                    shInternationalTable.Delete
                    On Error GoTo ErrComment
                    old_rev_date.Comment.Text GetTranslatedString("import_failed_1") & _
                                              Format(Now, "mmmm d, yyyy - h:mm:ss AM/PM") & _
                                              GetTranslatedString("import_failed_2") & _
                                              Format(dblImportRevDate, "mmmm d, yyyy - h:mm:ss AM/PM") & _
                                              GetTranslatedString("import_failed_3") & _
                                              Format(dblOldRevDate, "mmmm d, yyyy - h:mm:ss AM/PM") & GetTranslatedString("import_failed_4")
'                    old_rev_date.Comment.Shape.height = 60 'breaks xl2010.
'                    old_rev_date.Comment.Shape.width = 250 'breaks xl2010.
                    On Error GoTo GenErr
                    Set DownloadInternationalTableFromWeb = Nothing
                    Exit Function
                End If
                    
            End If
            
            
'        End If
        
        
        If bUseImportedSheet = True Then
            If bOldInternationalDataWorksheetExists Then
                Dim iSheetVisibility As Long
                iSheetVisibility = ThisWorkbook.Worksheets(worksheet_name).Visible
                If iSheetVisibility = xlSheetVeryHidden Then
                    ThisWorkbook.Worksheets(worksheet_name).Visible = xlSheetHidden
                    DoEvents
                End If
                DoEvents
                ThisWorkbook.Worksheets(worksheet_name).Delete
            End If
            old_rev_date.value = dblImportRevDate
            On Error GoTo ErrComment
            old_rev_date.Comment.Text "Imported " & Format(Now, "mmmm d, yyyy - h:mm:ss AM/PM")
'            old_rev_date.Comment.Shape.height = 30 'breaks xl2010.
'            old_rev_date.Comment.Shape.width = 200 'breaks xl2010.
            On Error GoTo GenErr
            
            shInternationalTable.Name = worksheet_name
            shInternationalTable.Visible = iSheetVisibility
            DoEvents
        Else
            'bUseImportedSheet = False:
            shInternationalTable.Delete
            DoEvents
        End If
        
        
        
        Application.DisplayAlerts = bDisplayAlertsStatus

'    shActiveSheet.Activate
Else
    'download was not successful:
    bDisplayAlertsStatus = Application.DisplayAlerts
    Application.DisplayAlerts = False
'    shInternationalTable.Delete
    shActiveSheet.Activate
    Application.DisplayAlerts = bDisplayAlertsStatus
    If bOldInternationalDataWorksheetExists Then
        frmProgressIntTemplates.Hide
        DoEvents
'        iRet = MsgBox("Download of " & msgbox_text & " (from " & strURL & ") was not successful. " & _
                      vbNewLine & vbNewLine & _
                      "Use old " & msgbox_text & " already in this workbook instead?", _
               vbQuestion + vbYesNo, "Download Unsuccessful")
        iRet = AmazonMsgBox(GetTranslatedString("download_not_successful_1") & msgbox_text & GetTranslatedString("download_not_successful_2") & strURL & GetTranslatedString("download_not_successful_3") & _
                            vbNewLine & vbNewLine & _
                            GetTranslatedString("download_not_successful_4") & msgbox_text & GetTranslatedString("download_not_successful_5"), _
                            vbYesNo, GetTranslatedString("download_unsuccessful"))
        If iRet = vbYes Then
            'proceed with old data:
'            frmProgressIntTemplates.Show vbModeless
            Set DownloadInternationalTableFromWeb = ThisWorkbook.Worksheets(worksheet_name)
            Exit Function
        Else
            'cancel:
            bCancelCreatingInternationalTemplates = True
            Exit Function
        End If
    Else
        'no data (either old or new) available:
        frmProgressIntTemplates.Hide
        DoEvents
'        iRet = MsgBox("Download of " & msgbox_text & " (from " & strURL & ") was not successful. " & _
                      "Old " & msgbox_text & " not found in this workbook " & _
                      "(worksheet named """ & worksheet_name & """ not found). " & _
                      vbNewLine & vbNewLine & _
                      "Unable to proceed.", _
                      vbCritical + vbOKOnly, "Data Not Found")
        iRet = AmazonMsgBox(GetTranslatedString("download_not_successful_long_1") & msgbox_text & GetTranslatedString("download_not_successful_long_2") & strURL & GetTranslatedString("download_not_successful_long_3") & _
                            GetTranslatedString("download_not_successful_long_4") & msgbox_text & GetTranslatedString("download_not_successful_long_5") & _
                            worksheet_name & GetTranslatedString("download_not_successful_long_6") & _
                            vbNewLine & vbNewLine & _
                            GetTranslatedString("download_not_successful_long_7"), _
                            vbOKOnly, GetTranslatedString("data_not_found"))
'        frmProgressIntTemplates.Show vbModeless
        bCancelCreatingInternationalTemplates = True
        Exit Function
    End If
End If

ThisWorkbook.Names(LAST_UPDATE_DEFINED_NAME).RefersToRange.value = Now

Set DownloadInternationalTableFromWeb = shInternationalTable


Exit Function

ErrGetDate:

If False Then
    Resume
End If

'error getting revdates. Set the dates so that the imported file will be used:
dblImportRevDate = 999999
dblOldRevDate = -1

Exit Function


ErrComment:

old_rev_date.AddComment
Resume

Exit Function

GenErr:

If False Then
    Resume
End If

End Function



Public Function DownloadTableFromWebByURL(dest_range As Range, url_string As String) As Boolean

Dim strConnection As String

strConnection = "URL;" & url_string

DownloadTableFromWebByURL = DownloadTableFromWebByConnStrTryTenTimes(dest_range, strConnection)

'If Not DownloadTableFromWebByURL Then
'    shIntSettings.Activate
'    Application.ScreenUpdating = True
'    DoEvents
'    MsgBox "Unable to download HTML file " & _
'           url_string & "." & _
'           vbNewLine & vbNewLine & _
'           "Please fix on International Settings sheet and retry.", vbCritical + vbOKOnly, "Unable To Download File"
'End If

End Function



Function DownloadTableFromWebByConnStrTryTenTimes(dest_range As Range, connection_string As String) As Boolean

Dim iTryCount As Long
Dim bTry As Boolean

On Error GoTo GenErr

'try 10 times:
iTryCount = 1 'init.
DownloadTableFromWebByConnStrTryTenTimes = False 'init.

Do

    On Error GoTo ErrTry
    bTry = DownloadTableFromWebByConnStr(dest_range, connection_string)
    On Error GoTo GenErr
    
    If bTry Then
        DownloadTableFromWebByConnStrTryTenTimes = bTry
        Exit Function
    Else
        iTryCount = iTryCount + 1
        DoEvents
        DoEvents
        DoEvents
    End If
    
Loop Until iTryCount >= 10

Exit Function

GenErr:
DownloadTableFromWebByConnStrTryTenTimes = False

Exit Function

ErrTry:
bTry = False
Resume Next

End Function



Function DownloadTableFromWebByConnStr(dest_range As Range, connection_string As String) As Boolean

'returns True on success.

Dim strConnection As String
Dim qtQueryTable As QueryTable
Dim bDisplayAlertsStatus As Boolean


bDisplayAlertsStatus = Application.DisplayAlerts
Application.DisplayAlerts = False


Set qtQueryTable = dest_range.Parent.QueryTables.Add(connection_string, Destination:=dest_range)

With qtQueryTable
    .Name = "Full International Table"
    .FieldNames = True
    .RowNumbers = False
    .FillAdjacentFormulas = False
    .PreserveFormatting = False 'True 'False
    .RefreshOnFileOpen = False
    .BackgroundQuery = False
    .RefreshStyle = xlInsertDeleteCells
    .SavePassword = False
    .SaveData = True
    .AdjustColumnWidth = True
    .RefreshPeriod = 0
    .WebSelectionType = xlAllTables 'xlSpecifiedTables
    .WebFormatting = xlWebFormattingNone
'        .WebTables = "1"
    .WebPreFormattedTextToColumns = True
    .WebConsecutiveDelimitersAsOne = True
    .WebSingleBlockTextImport = False
    .WebDisableDateRecognition = False
    .WebDisableRedirections = False
    .Refresh BackgroundQuery:=False
End With

qtQueryTable.Delete

Call FixBooleansAfterImport(dest_range)

Application.DisplayAlerts = bDisplayAlertsStatus

DownloadTableFromWebByConnStr = True

End Function



Function FixBooleansAfterImport(target_range As Range)

Dim rgCell As Range
Dim rgTargetRange As Range

'Debug.Print Format(Now, "hh:mm:ss")

Set rgTargetRange = target_range.Parent.UsedRange

For Each rgCell In rgTargetRange
    If rgCell.value = True Then
        If Not rgCell.value = "-1" Then
            rgCell.NumberFormat = "@"
            rgCell.value = "True"
        End If
    ElseIf rgCell.value = "" Then
        'do nothing. Need this to prevent blank cells from being treated as Falses.
    ElseIf rgCell.value = False Then
        If Not rgCell.value = "0" Then
            rgCell.NumberFormat = "@"
            rgCell.value = "False"
        End If
    End If
Next rgCell

'Debug.Print Format(Now, "hh:mm:ss")

End Function



Function MakeTemplates(source_language As String) As Boolean

Dim wbNewTemplate As Workbook
Dim strArrayLanguages() As String
Dim iArrayIndex As Long
Dim iLbound As Long
Dim iUbound As Long
Dim strTargetLanguage As String
Dim shIntTable As Worksheet
Dim shDropdownTable As Worksheet
Dim shValidationTable As Worksheet
Dim bDisplayAlertsStatus As Boolean
Dim bEnableEventsStatus As Boolean
Dim shActiveSheet As Worksheet
Dim bFound As Boolean
Dim rgCheckForData As Range
Dim rgCheckCell As Range
Dim iRet As Long
Dim bRet As Boolean
Dim shTemplate As Worksheet
Dim iTemplateHeaderRow As Long
Dim iLastExampleRow As Long
Dim rgLastCell As Range
Dim rgFirstDataCell As Range
Dim strLocalTemplatesFolder As String
Dim rgFind As Range

On Error GoTo GenErr

'init:
bEnableEventsStatus = Application.EnableEvents
bCancelCreatingInternationalTemplates = False
bDisplayAlertsStatus = Application.DisplayAlerts
Application.DisplayAlerts = False



'check for data, prompt user and delete it:
Set shTemplate = GetTemplateWorksheet()
shTemplate.Unprotect 'for SpecialCells.
iTemplateHeaderRow = GetTemplateHeaderRow(shTemplate)
iLastExampleRow = GetLastExampleRow(shTemplate, iTemplateHeaderRow)
bEnableEventsStatus = Application.EnableEvents
Application.EnableEvents = False
Set rgLastCell = shTemplate.Cells.SpecialCells(xlCellTypeLastCell)
Application.EnableEvents = bEnableEventsStatus
If rgLastCell.Row > iLastExampleRow Then
    bEnableEventsStatus = Application.EnableEvents
    Application.EnableEvents = False
    Set rgFirstDataCell = shTemplate.Cells(iLastExampleRow + 1, 1)
    Set rgCheckForData = shTemplate.Range(rgFirstDataCell, rgLastCell)
    Application.EnableEvents = bEnableEventsStatus
    bFound = False 'init.
    For Each rgCheckCell In rgCheckForData.Cells
        If rgCheckCell.Formula <> "" Then
            bFound = True
            Exit For
        End If
    Next rgCheckCell
    If bFound Then
'        iRet = MsgBox("Data has been found within the range " & rgCheckForData.Address(False, False) & _
                      ". That data will be deleted if you proceed to generate localized templates. " & _
                      vbNewLine & vbNewLine & _
                      "Do you want to proceed?", vbQuestion + vbOKCancel, "Data Found")
        iRet = AmazonMsgBox(GetTranslatedString("data_found_range_1") & rgCheckForData.Address(False, False) & _
                            GetTranslatedString("data_found_range_2") & vbNewLine & vbNewLine & _
                            GetTranslatedString("data_found_range_3"), vbOKCancel, GetTranslatedString("data_found"))
        If iRet = vbCancel Then Exit Function  'user clicked Cancel.
        shTemplate.Range(rgFirstDataCell, rgLastCell).ClearContents
    End If
End If


'progress indicator:
frmProgressIntTemplates.lblProgressText.Caption = GetTranslatedString("downloading_intl_data")
'frmProgressIntTemplates.lblProgressPercent = "0%"
'frmProgressIntTemplates.prgIntTemplates.value = 1
frmProgressIntTemplates.lblProgressBar.Width = 0.01 * frmProgressIntTemplates.frameProgressBar.Width
frmProgressIntTemplates.Show vbModeless
DoEvents


'download tables from web:
'(see also GetLatestInternationalizedData)
'======================================================================================================
Set shActiveSheet = ActiveSheet
 'this activates a different sheet, because a new sheet is created and then hidden. Must re-activate original active sheet.
Set shIntTable = DownloadInternationalTableFromWeb(FULL_MISC_DATA_TABLE_URL_DEFINED_NAME, _
                      INT_TABLE_WORKSHEET_NAME, "international data")
If xxx Then Exit Function

'frmProgressIntTemplates.prgIntTemplates.value = 5
frmProgressIntTemplates.lblProgressBar.Width = 0.05 * frmProgressIntTemplates.frameProgressBar.Width
frmProgressIntTemplates.Repaint
DoEvents

Set shDropdownTable = DownloadInternationalTableFromWeb(FULL_DROPDOWN_LISTS_TABLE_URL_DEFINED_NAME, _
                      DROPDOWN_LISTS_TABLE_WORKSHEET_NAME, "dropdown lists")

'frmProgressIntTemplates.prgIntTemplates.value = 10
frmProgressIntTemplates.lblProgressBar.Width = 0.1 * frmProgressIntTemplates.frameProgressBar.Width
frmProgressIntTemplates.Repaint
DoEvents

Set shValidationTable = DownloadDataValidationTableFromWeb(FULL_DATA_VALIDATION_TABLE_URL_DEFINED_NAME)

'frmProgressIntTemplates.prgIntTemplates.value = 15
frmProgressIntTemplates.lblProgressBar.Width = 0.15 * frmProgressIntTemplates.frameProgressBar.Width
frmProgressIntTemplates.Repaint
DoEvents

Application.EnableEvents = False
shActiveSheet.Activate
Application.EnableEvents = bEnableEventsStatus
DoEvents
'======================================================================================================


If bCancelCreatingInternationalTemplates Then
    Unload frmProgressIntTemplates
    DoEvents
'    MsgBox "Template Creation Cancelled.", vbExclamation + vbOKOnly, "Cancelled"
    AmazonMsgBox GetTranslatedString("template_creation_cancelled"), vbOKOnly, GetTranslatedString("cancelled")
    Exit Function
End If


'apply new dropdown lists to main template:
Application.EnableEvents = False
bRet = ApplyDropDownLists(ThisWorkbook, INT_TABLE_ENGLISH_USA_HEADER)
Application.EnableEvents = bEnableEventsStatus


'get language list as array:
strArrayLanguages = GetLanguageList(shIntTable)
If strArrayLanguages(1) = "0" Then Exit Function

'get the local templates folder name:
strLocalTemplatesFolder = ThisWorkbook.Names(LOCAL_TEMPLATES_FOLDER_DEFINED_NAME).RefersToRange.value

iLbound = LBound(strArrayLanguages)
iUbound = UBound(strArrayLanguages)
strMsg = GetTranslatedString("templates_saved_1") & vbNewLine & _
         ThisWorkbook.Path & "\" & strLocalTemplatesFolder & "\:" & vbNewLine & vbNewLine
For iArrayIndex = iLbound To iUbound
    strTargetLanguage = strArrayLanguages(iArrayIndex)
    
    
    frmProgressIntTemplates.lblProgressText.Caption = GetTranslatedString("creating_template_1") & strTargetLanguage & GetTranslatedString("creating_template_2")
    dblProgress = (100 / ((iUbound * 3) + 1)) * ((iArrayIndex * 3) - 2)
    strProgressPercent = CStr(Round(dblProgress, 1)) & "%"
'    frmProgressIntTemplates.prgIntTemplates.value = dblProgress
    frmProgressIntTemplates.lblProgressBar.Width = (dblProgress / 100) * frmProgressIntTemplates.frameProgressBar.Width
'    frmProgressIntTemplates.lblProgressPercent.Caption = strProgressPercent
    frmProgressIntTemplates.Show vbModeless
    
    DoEvents
    dblProgress = (100 / ((iUbound * 3) + 1)) * ((iArrayIndex * 3) - 1)
    strProgressPercent = CStr(Round((100 / ((iUbound * 3) + 1)) * ((iArrayIndex * 3) - 1), 1)) & "%"
'    frmProgressIntTemplates.prgIntTemplates.value = dblProgress
    frmProgressIntTemplates.lblProgressBar.Width = (dblProgress / 100) * frmProgressIntTemplates.frameProgressBar.Width

    
    
    
    'check for target language in International Worksheets Table:
    Set rgFind = shIntSheetsTable.Cells.Find(strTargetLanguage)
    Call ResetFindParametersToDefaults
    If rgFind Is Nothing Then
        'that language does not exist in this product category, so don't make the template:
        GoTo Next_Template
    Else
    
    
        '*****make a template*****:
        
        Application.EnableEvents = False
        Set wbNewTemplate = MakeTemplate(shIntTable, INT_TABLE_MASTER_NAME_HEADER, strTargetLanguage, _
                                         strProgressPercent, INT_TABLE_MFA_INTERNAL_NAME_HEADER)
        Application.EnableEvents = bEnableEventsStatus
        
        
    End If
    
    
    
    If wbNewTemplate Is Nothing Then
        
        If bNotFoundInIntWorksheetsTable Then
            GoTo Next_Template
        End If
        
        frmProgressIntTemplates.Hide
'        iRet = MsgBox("Unable to create " & strTargetLanguage & " template. Continue with other templates?", vbQuestion + vbYesNo, "Problem Creating Template")
        iRet = AmazonMsgBox(GetTranslatedString("unable_to_create_1") & strTargetLanguage & GetTranslatedString("unable_to_create_2"), vbYesNo, GetTranslatedString("problem_creating_template"))
        If iRet = vbNo Then
            Unload frmProgressIntTemplates
            MakeTemplates = False
            Exit Function
        Else
            'iRet = vbYes, so resume:
            frmProgressIntTemplates.Show vbModeless
            GoTo Next_Template
        End If
    End If
    
    wbNewTemplate.Activate
    DoEvents
    If bCancelCreatingInternationalTemplates Then
        bEnableEventsStatus = Application.EnableEvents
        Application.EnableEvents = False
        wbNewTemplate.Close SaveChanges:=False
        Application.EnableEvents = bEnableEventsStatus
        frmProgressIntTemplates.Hide
'        MsgBox "Template Creation Cancelled.", vbExclamation + vbOKOnly, "Cancelled"
        AmazonMsgBox GetTranslatedString("template_creation_cancelled"), vbOKOnly, GetTranslatedString("cancelled")
        Exit Function
    End If
    
    strMsg = strMsg & strTargetLanguage & ":   """ & wbNewTemplate.Name & """" & vbNewLine

    frmProgressIntTemplates.lblProgressText.Caption = GetTranslatedString("saving_template_1") & strTargetLanguage & GetTranslatedString("saving_template_2") & ThisWorkbook.Path & "\" & strLocalTemplatesFolder & "\ " & GetTranslatedString("saving_template_3")
    dblProgress = (100 / ((iUbound * 3) + 1)) * ((iArrayIndex * 3) - 0)
    strProgressPercent = CStr(Round((100 / ((iUbound * 3) + 1)) * ((iArrayIndex * 3) - 0), 1)) & "%"
'    frmProgressIntTemplates.prgIntTemplates.value = dblProgress
    frmProgressIntTemplates.lblProgressBar.Width = (dblProgress / 100) * frmProgressIntTemplates.frameProgressBar.Width
'    frmProgressIntTemplates.lblProgressPercent.Caption = strProgressPercent
    DoEvents
    
    bEnableEventsStatus = Application.EnableEvents
    Application.EnableEvents = False
    wbNewTemplate.Close SaveChanges:=True
    Application.EnableEvents = bEnableEventsStatus
Next_Template:
Next iArrayIndex


'delete data sheets that are no longer needed:
'shIntTable.Delete 'this is used for determining dropdown lists.
shDropdownTable.Delete
ThisWorkbook.Save


frmProgressIntTemplates.Hide


'Call ProtectSheet(shTemplate)


Application.DisplayAlerts = bDisplayAlertsStatus
Application.EnableEvents = bEnableEventsStatus

MakeTemplates = True


Exit Function

GenErr:

Application.EnableEvents = bEnableEventsStatus

If False Then
    Resume
End If

End Function



Function GetLanguageList(table_worksheet As Worksheet) As String()

'on failure, returns GetLanguageList("0")

Dim rgFind As Range
Dim rgHeaderRange As Range
Dim rgCell As Range
Dim iLastCol As Long
Dim strArrayList() As String
Dim iUbound As Long

Const INT_TABLE_HEADER_ROW As Long = 1

'init return value for failure:
ReDim strArrayList(1 To 1) As String
strArrayList(1) = "0"

Set rgFind = table_worksheet.Cells(INT_TABLE_HEADER_ROW, table_worksheet.Columns.Count).End(xlToLeft)
iLastCol = rgFind.Column

Set rgHeaderRange = table_worksheet.Range(table_worksheet.Cells(INT_TABLE_HEADER_ROW, 1), table_worksheet.Cells(INT_TABLE_HEADER_ROW, iLastCol))

ReDim strArrayList(1 To 1) As String
iUbound = UBound(strArrayList)

For Each rgCell In rgHeaderRange.Cells

    Select Case rgCell.value
        Case INT_TABLE_DATA_CATEGORY_HEADER
            'skip
        Case INT_TABLE_REFERENCE_HEADER
            'skip
        Case INT_TABLE_NUMBER_FORMAT_HEADER
            'skip
        Case INT_TABLE_MASTER_NAME_HEADER
            'skip
        Case INT_TABLE_MFA_INTERNAL_NAME_HEADER
            'skip
        Case INT_TABLE_TEMPLATE_DEPENDENCY_TEST_HEADER
            'skip
        Case Else
            'add to array:
            strArrayList(iUbound) = rgCell.value
            iUbound = iUbound + 1
            ReDim Preserve strArrayList(1 To iUbound) As String
    
    End Select
    
Next rgCell

ReDim Preserve strArrayList(1 To iUbound - 1) As String

GetLanguageList = strArrayList

End Function



Function MakeTemplate(work_sheet_table As Worksheet, source_language As String, target_language As String, _
                      progress_percent As String, Optional alt_source_language As String) As Workbook

'returns Workbook on success, Nothing on failure.

Dim bRet As Boolean
Dim wbNewTemplate As Workbook
Dim shTemplateWorksheet As Worksheet

Set shTemplateWorksheet = GetTemplateWorksheet()

Set wbNewTemplate = MakeNewTemplateWorkbook(target_language)
If wbNewTemplate Is Nothing Then
    Set MakeTemplate = Nothing
    Exit Function
End If

On Error GoTo GenErr


frmProgressIntTemplates.lblProgressText.Caption = GetTranslatedString("swapping_column_headers_1") & target_language & GetTranslatedString("swapping_column_headers_2") & target_language & GetTranslatedString("swapping_column_headers_3")
'frmProgressIntTemplates.lblProgressPercent.Caption = progress_percent
DoEvents
'bRet = SwapColumnHeaders(wbNewTemplate.Worksheets(shTemplateWorksheet.Name), wbNewTemplate.Worksheets(work_sheet_table.Name), _
                         source_language, target_language, alt_source_language)
bRet = SwapColumnHeaders(wbNewTemplate, wbNewTemplate.Worksheets(work_sheet_table.Name), _
                         source_language, target_language, alt_source_language)


'=========================================================================================================
'remove unneccessary rows in validation table:
    'For v2, moving this section to modSupport (Function RemoveUnneccessaryRowsInValidationTable)
Call RemoveUnneccessaryRowsInValidationTable(wbNewTemplate) 'ignore return value.
'''''Dim vRows As Variant
'''''Dim iTemplateSheetCounter As Long
'''''Dim shFind As Worksheet
'''''Dim strFindSheetCodeName As String
'''''Dim bFound As Boolean
'''''iTemplateSheetCounter = 1 'init.
'''''Do
'''''    strFindSheetCodeName = "shTemplate" & CStr(iTemplateSheetCounter)
'''''    bFound = False 'init for each strFindSheetCodeName
'''''    For Each shFind In wbNewTemplate.Worksheets
'''''        If shFind.CodeName = strFindSheetCodeName Then
'''''            bFound = True
'''''            Exit For
'''''        End If
'''''    Next shFind
'''''
'''''    If bFound Then
'''''        shFind.Activate
'''''        Dim strTargetTemplateLanguage As String
'''''        strTargetTemplateLanguage = GetLocalLanguageName(, wbNewTemplate)
'''''        Call ValidateTemplate(True, , vRows, strTargetTemplateLanguage, True)
'''''    Else
'''''        Exit Do
'''''    End If
'''''
'''''    iTemplateSheetCounter = iTemplateSheetCounter + 1
'''''
'''''Loop
'''''Dim shValidationTable As Worksheet
'''''Dim shTmp As Worksheet, rgTmp As Range, rgDeleteRows As Range
'''''Dim iKeepRow1 As Long, iKeepRow2 As Long
'''''Dim iDeleteRow1 As Long, iDeleteRow2 As Long
'''''Dim iIndex As Long, iUbound As Long
'''''Set shValidationTable = wbNewTemplate.Worksheets(DATA_VALIDATION_TABLE_WORKSHEET_NAME)
'''''Set shTmp = wbNewTemplate.Worksheets.Add
'''''iUbound = UBound(vRows)
'''''For iIndex = 1 To iUbound
'''''    shTmp.Cells(iIndex, 1).Value = vRows(iIndex)
'''''Next iIndex
'''''Set rgTmp = shTmp.UsedRange
'''''rgTmp.Sort Key1:=shTmp.Cells(1, 1), Order1:=xlAscending, Header:=xlNo, _
'''''        Orientation:=xlTopToBottom, SortMethod:=xlPinYin
'''''For iIndex = 1 To iUbound
'''''    vRows(iIndex) = shTmp.Cells(iIndex, 1).Value
'''''Next iIndex
'''''shTmp.Delete
'''''    iKeepRow1 = 2
'''''        iDeleteRow1 = iKeepRow1 + 1
'''''    iKeepRow2 = vRows(1)
'''''        iDeleteRow2 = (iKeepRow2 - 3)
'''''Set rgDeleteRows = shValidationTable.Rows(iDeleteRow1).Resize(iDeleteRow2) 'preserves row 1 & 2 while initializing rgDeleteRows.
'''''For iIndex = 2 To iUbound
'''''    iKeepRow1 = vRows(iIndex - 1)
'''''        iDeleteRow1 = iKeepRow1 + 1
'''''    iKeepRow2 = vRows(iIndex)
'''''        iDeleteRow2 = (iKeepRow2 - iKeepRow1) - 1
'''''        If iDeleteRow2 > 0 Then
'''''            'there are rows to delete here:
'''''            Set rgDeleteRows = Union(rgDeleteRows, shValidationTable.Rows(iDeleteRow1).Resize(iDeleteRow2))
'''''        End If
'''''Next iIndex
'''''iDeleteRow1 = iKeepRow2 + 1
'''''iDeleteRow2 = (shValidationTable.Rows.Count - iKeepRow2)
'''''Set rgDeleteRows = Union(rgDeleteRows, shValidationTable.Rows(iDeleteRow1).Resize(iDeleteRow2))
'''''rgDeleteRows.Delete
'=========================================================================================================



'delete the sorting column:
Dim iSortingCol As Long
iSortingCol = shValidationTable.Rows(DATA_VALIDATION_TABLE_HEADER_ROW).Find(What:=DATA_VALIDATION_SORTING_COLUMN_HEADER, LookAt:=xlWhole).Column
Call ResetFindParametersToDefaults
shValidationTable.Columns(iSortingCol).EntireColumn.Delete

'delete the fontname column:
Dim iFontnameCol As Long
iFontnameCol = shValidationTable.Rows(DATA_VALIDATION_TABLE_HEADER_ROW).Find(What:=DATA_VALIDATION_TABLE_FONTNAME_COLUMN_HEADER, LookAt:=xlWhole).Column
Call ResetFindParametersToDefaults
shValidationTable.Columns(iFontnameCol).EntireColumn.Delete

'delete the width (cell comment width) column:
Dim iWidthCol As Long
iWidthCol = shValidationTable.Rows(DATA_VALIDATION_TABLE_HEADER_ROW).Find(What:=DATA_VALIDATION_TABLE_WIDTH_COLUMN_HEADER, LookAt:=xlWhole).Column
Call ResetFindParametersToDefaults
shValidationTable.Columns(iWidthCol).EntireColumn.Delete


If Not bRet Then
    wbNewTemplate.Close SaveChanges:=False
    Unload frmProgressIntTemplates
    Exit Function
End If
                        
frmProgressIntTemplates.lblProgressText.Caption = GetTranslatedString("applying_dropdown_lists_1") & target_language & GetTranslatedString("applying_dropdown_lists_2")
'frmProgressIntTemplates.lblProgressPercent.Caption = progress_percent
DoEvents
bRet = ApplyDropDownLists(wbNewTemplate, target_language)

If Not bRet Then
    wbNewTemplate.Close SaveChanges:=False
    Unload frmProgressIntTemplates
    Exit Function
End If


frmProgressIntTemplates.lblProgressText.Caption = GetTranslatedString("processing_localized_1") & target_language & GetTranslatedString("processing_localized_2")
'frmProgressIntTemplates.lblProgressPercent.Caption = progress_percent
DoEvents
bRet = ProcessLocalizedWorksheets(wbNewTemplate, target_language)

If Not bRet Then
    Dim strFullPath As String
    strFullPath = wbNewTemplate.Path & "\" & wbNewTemplate.Name
    wbNewTemplate.Close SaveChanges:=False
    Unload frmProgressIntTemplates
    DoEvents
    Dim fso As Object
    Set fso = CreateObject("Scripting.FileSystemObject")
    If fso.FileExists(strFullPath) Then
        fso.DeleteFile strFullPath
        DoEvents
    End If
    Exit Function
End If


'set localized toolbar button captions:
Call ApplyLocalToolbarButtonSettings(target_language, wbNewTemplate.Worksheets(work_sheet_table.Name))


'hide international settings worksheet:
wbNewTemplate.Names(TEMPLATE_LANGUAGE_DEFINED_NAME).RefersToRange.Parent.Visible = xlHidden

'hide international urls worksheet:
wbNewTemplate.Worksheets(shIntURLs.Name).Visible = xlHidden


'delete master instructions worksheet:
wbNewTemplate.Worksheets(shMasterInst.Name).Delete

'delete data sheets that are no longer needed:
'wbNewTemplate.Worksheets(INT_TABLE_WORKSHEET_NAME).Delete 'this is used for determining dropdown lists.
wbNewTemplate.Worksheets(DROPDOWN_LISTS_TABLE_WORKSHEET_NAME).Delete


wbNewTemplate.Names(SHOW_CREATE_TEMPLATES_TOOLBAR_DEFINED_NAME).RefersToRange.value = False

Set MakeTemplate = wbNewTemplate

Exit Function

GenErr:

'Stop

wbNewTemplate.Close SaveChanges:=False

If False Then
    Resume
End If

End Function





Function ProcessLocalizedWorksheets(target_workbook As Workbook, target_language As String) As Boolean

'delete other locales' worksheets, and rename this locale's worksheets:

Dim iHeaderRow As Long
Dim iFirstTemplateRow As Long
Dim iLastTemplateRow As Long
Dim iTemplateRow As Long
Dim iTemplateNameCol As Long
Dim iRawSheetNameCol As Long
Dim iTargetLanguageCol As Long
Dim iDefaultLanguageCol As Long
Dim iLastTableCol As Long
Dim iTableCol As Long
Dim strRawTemplateName As String
Dim rgFind As Range
Dim bEnableEventsStatus As Boolean
Dim bDisplayAlertsStatus As Boolean
Dim strRawPrefix As String
Dim strRawFullName As String
Dim strTargetName As String
Dim strDefaultLanguage As String
Dim shTarget As Worksheet
Dim shDelete As Worksheet
Dim shFind As Worksheet
Dim strDeleteLanguage As String
Dim bFound As Boolean
Dim shActivateTemplate As Worksheet
Dim shTemplate As Worksheet
Dim strFullPath As String

Const TEMPLATE_NAME_COLUMN_NAME As String = "Template Name"
Const RAW_WORKSHEET_STORAGE_NAME_COLUMN_NAME As String = "Raw Worksheet Storage Name"
Const DEFAULT_LANGUAGE_DEFINED_NAME As String = "Localized_Worksheets_Default_Language"

On Error GoTo GenErr

bEnableEventsStatus = Application.EnableEvents
Application.EnableEvents = False

Set shTemplate = GetTemplateWorksheet(True)

strRawTemplateName = shTemplate.Name

'get raw template name, columns and rows:
Set rgFind = shIntSheetsTable.Cells.Find(What:=TEMPLATE_NAME_COLUMN_NAME, LookAt:=xlWhole)
Call ResetFindParametersToDefaults
iHeaderRow = rgFind.Row
iTemplateNameCol = rgFind.Column

Set rgFind = shIntSheetsTable.Rows(iHeaderRow).Find(What:=RAW_WORKSHEET_STORAGE_NAME_COLUMN_NAME, LookAt:=xlWhole)
Call ResetFindParametersToDefaults
iRawSheetNameCol = rgFind.Column

Set rgFind = shIntSheetsTable.Rows(iHeaderRow).Find(What:=target_language, LookAt:=xlWhole)
Call ResetFindParametersToDefaults
If rgFind Is Nothing Then
    'language not found:
    bNotFoundInIntWorksheetsTable = True
    strFullPath = target_workbook.Path & "\" & target_workbook.Name
'    target_workbook.Close SaveChanges:=False 'now doing this in calling function.
    DoEvents
    Dim fso As Object
    Set fso = CreateObject("Scripting.FileSystemObject")
    If fso.FileExists(strFullPath) Then
        fso.DeleteFile strFullPath
        DoEvents
    End If
    Exit Function
Else
    bNotFoundInIntWorksheetsTable = False
End If
iTargetLanguageCol = rgFind.Column

strDefaultLanguage = ThisWorkbook.Names(DEFAULT_LANGUAGE_DEFINED_NAME).RefersToRange.value
Set rgFind = shIntSheetsTable.Rows(iHeaderRow).Find(What:=strDefaultLanguage, LookAt:=xlWhole)
Call ResetFindParametersToDefaults
iDefaultLanguageCol = rgFind.Column

Set rgFind = shIntSheetsTable.Columns(iTemplateNameCol).Find(What:=strRawTemplateName, LookAt:=xlWhole)
Call ResetFindParametersToDefaults
If rgFind Is Nothing Then
'    MsgBox "The Master workbook's template worksheet name is """ & _
            strRawTemplateName & """, but that name does not appear in the """ & _
            shIntSheetsTable.Name & """ worksheet in column " & _
            CStr(iTemplateNameCol) & "." & _
            vbNewLine & vbNewLine & _
            "Please fix and restart. See instructions on the """ & _
            shIntSheetsTable.Name & """ worksheet.", _
            vbCritical + vbOKOnly, _
            "Can't Find Template Name in Table"
    AmazonMsgBox GetTranslatedString("master_workbook_error_1") & _
                 strRawTemplateName & GetTranslatedString("master_workbook_error_2") & _
                 shIntSheetsTable.Name & GetTranslatedString("master_workbook_error_3") & _
                 CStr(iTemplateNameCol) & GetTranslatedString("master_workbook_error_4") & _
                 vbNewLine & vbNewLine & _
                 GetTranslatedString("master_workbook_error_5") & _
                 shIntSheetsTable.Name & GetTranslatedString("master_workbook_error_6"), _
                 vbOKOnly, _
                 GetTranslatedString("cant_find_template_name")
End If
iFirstTemplateRow = rgFind.Row

Set rgFind = shIntSheetsTable.Columns(iTemplateNameCol).Find(What:=strRawTemplateName, LookAt:=xlWhole, SearchDirection:=xlPrevious)
Call ResetFindParametersToDefaults
iLastTemplateRow = rgFind.Row

Set rgFind = shIntSheetsTable.Cells(iHeaderRow, shIntSheetsTable.Columns.Count).End(xlToLeft)
iLastTableCol = rgFind.Column


bDisplayAlertsStatus = Application.DisplayAlerts
Application.DisplayAlerts = False


For iTemplateRow = iFirstTemplateRow To iLastTemplateRow
    strRawPrefix = shIntSheetsTable.Cells(iTemplateRow, iRawSheetNameCol).value
    strRawFullName = strRawPrefix & "_" & target_language
    strTargetName = shIntSheetsTable.Cells(iTemplateRow, iTargetLanguageCol).value

    'check for blank target name:
    If strTargetName = "" Then
        'skip this template row:
        GoTo SkipToDeleteOtherLocalesLocalizedSheets 'SkipToNextTemplateRow
    End If
    
    If strRawPrefix = strRawTemplateName Then
        'this is the (first) template sheet, so just change its name:
        Set shTarget = target_workbook.Worksheets(strRawPrefix)
        shTarget.Name = strTargetName
        shTarget.Visible = True 'should already be visible anyway, but just in case.
        'mark it as the sheet to be activated when done:
        Set shActivateTemplate = shTarget
    ElseIf RegexTest("^" & strRawTemplateName & "\d+$", strRawPrefix) Then
        'this is another template sheet after the first one:
        '(it's the raw template name with one or more trailing digits.)
        Set shTarget = target_workbook.Worksheets(strRawPrefix)
        shTarget.Name = strTargetName
        shTarget.Visible = True 'should already be visible anyway, but just in case.
        
        
    Else
        'this is NOT the template sheet:
        'check for existence of that worksheet, use default if it doesn't exist:
        If Not DoesWorksheetExistByName(strRawFullName) Then
            'use default:
            strRawFullName = strRawPrefix & "_" & strDefaultLanguage
            'make sure that worksheet exists before continuing:
            If Not DoesWorksheetExistByName(strRawFullName) Then
                shIntSheetsTable.Activate
                shIntSheetsTable.Cells(iTemplateRow, iRawSheetNameCol).Address.Select
                DoEvents
'                MsgBox "Can't find hidden worksheet " & _
                       strRawFullName & ". Please fix in cell " & _
                       shIntSheetsTable.Cells(iTemplateRow, iRawSheetNameCol).Address(False, False) & _
                       "of the " & _
                       shIntSheetsTable.Name & " sheet.", _
                       vbCritical + vbOKOnly, "Can't Find Worksheet"
                AmazonMsgBox GetTranslatedString("cant_find_hidden_1") & _
                             strRawFullName & GetTranslatedString("cant_find_hidden_2") & _
                             shIntSheetsTable.Cells(iTemplateRow, iRawSheetNameCol).Address(False, False) & _
                             GetTranslatedString("cant_find_hidden_3") & _
                             shIntSheetsTable.Name & GetTranslatedString("cant_find_hidden_4"), _
                             vbOKOnly, GetTranslatedString("cant_find_worksheet")
                ProcessLocalizedWorksheets = False
                Exit Function
            End If
        End If

        Set shTarget = target_workbook.Worksheets(strRawFullName)
        
        
        shTarget.Name = strTargetName
        shTarget.Visible = True


SkipToDeleteOtherLocalesLocalizedSheets:

        'delete other locales' localized sheets:
        For iTableCol = 1 To iLastTableCol
            
            Select Case iTableCol
                Case iTemplateNameCol
                    'do nothing here.
                Case iRawSheetNameCol
                    'do nothing here.
                Case iTargetLanguageCol
                    'do nothing here.
                Case Else
                    'delete sheets:
                    strDeleteLanguage = shIntSheetsTable.Cells(iHeaderRow, iTableCol).value
                    strRawFullName = strRawPrefix & "_" & strDeleteLanguage
                    
                    bFound = False 'init.
                    For Each shDelete In target_workbook.Worksheets
                        If shDelete.Name = strRawFullName Then
                            bFound = True
                            Exit For
                        End If
                    Next shDelete
                    
                    If bFound Then
                        Set shDelete = target_workbook.Worksheets(strRawFullName)
                        shDelete.Delete
                    End If
    
            End Select
        
        Next iTableCol
    
    End If
    
SkipToNextTemplateRow:
    
Next iTemplateRow

'delete the international worksheets table worksheet:
target_workbook.Worksheets(shIntSheetsTable.Name).Delete

'scroll so that the leftmost worksheet is visible:
ActiveWindow.ScrollWorkbookTabs Position:=xlFirst

'activate the template worksheet:
shActivateTemplate.Activate

'select cell in top row:
iHeaderRow = GetTemplateHeaderRow(shActivateTemplate) 'reusing iHeaderRow.
shActivateTemplate.Cells(iHeaderRow + 1, ActiveCell.Column).Select 'to select column, would need a setting for what column to select.


Application.DisplayAlerts = bDisplayAlertsStatus
Application.EnableEvents = bEnableEventsStatus

ProcessLocalizedWorksheets = True

Exit Function

GenErr:

Application.DisplayAlerts = bDisplayAlertsStatus
Application.EnableEvents = bEnableEventsStatus

'Stop
If False Then
    Resume
End If

End Function




Public Function DoesWorksheetExistByName(sheet_name As String) As Boolean

Dim shFind As Worksheet

For Each shFind In ThisWorkbook.Worksheets
    If shFind.Name = sheet_name Then
        DoesWorksheetExistByName = True
        Exit Function
    End If
Next shFind

DoesWorksheetExistByName = False

End Function



Public Function ApplyDropDownLists(target_workbook As Workbook, target_language As String, _
                                   Optional is_external_call As Boolean) As Boolean

'replaces the Dropdown Lists worksheet with a fresh one. That's the sheet from which the
'dropdowns' lists are taken.

'returns true on success.

Dim shDropdownLists As Worksheet
Dim shIntDropdownListsTable As Worksheet
Dim shIntTable As Worksheet
Dim iDropdownColumnCol As Long
Dim iColumnDependencyCol As Long
Dim iColumnDependencyTestCol As Long
Dim iTemplateDependencyTestCol As Long
Dim iTargetLanguageCol As Long
Dim iLastCol As Long
Dim iColCount As Long
Dim iHeaderRow As Long
Dim iDataFirstRow As Long
Dim iDataLastRow As Long
Dim iDropdownListFirstRow As Long
Dim iDropdownListLastRow As Long
Dim rgFind As Range
Dim rgNextCellDown As Range
Dim rgFindInRange As Range
Dim rgFindInDropdownColumnCol As Range
Dim rgDropdownList As Range
Dim rgDestDropDownList As Range
Dim rgCellDestDropDownList As Range
Dim strCellDestDropDownList As String
Dim strTemp As String
Dim rgReferenceItem As Range
Dim iTmpRow As Long
Dim rgListboxMfaInternalColumnName As Range
Dim strListboxMfaInternalColumnName As String
Dim strListboxMfaInternalColumnNameRegexPattern As String
Dim strListboxMfaInternalColumnNamePrevious As String
Dim strDropdownListDefinedNameSuffix As String
Dim strDropdownListDefinedNameSuffixSeparator As String
Dim strInternalTemplateName As String

Dim rgColumnDependencyMfaInternalColumnName As Range
Dim strColumnDependencyMfaInternalColumnName As String
Dim strColumnDependencyLocalColumnName As String

Dim rgTemplateDependencyTest As Range
Dim strTemplateDependencyTest As String

Dim rgColumnDependencyTest As Range
Dim strColumnDependencyTest As String

Dim rgDataCategoryItem As Range
Dim iListCounter As Long
Dim strIntTableMfaInternalNameHeader As String
Dim strListDefinedName As String
Dim nameDefinedNameTmp As Name
Dim strDefinedNameTmp As String
Dim shTmp As Worksheet
Dim bDisplayAlerts As Boolean
Dim bScreenUpdating As Boolean
Dim bEnableEvents As Boolean
Dim bFound As Boolean
Dim bApplyToThisTemplate As Boolean
'Dim bDoneLooking As Boolean
'Dim iDefaultRow As Long
Dim nmName As Name
Dim rgName As Range

Dim iIntTableMfaInternalNameCol As Long
Dim iIntTableLocalNameCol As Long
Dim iIntTableTemplateDependencyTestCol As Long
Dim iTemplateHeaderRow As Long
Dim iTemplateDependencyCol As Long
Dim strTemplateDependencyItem As String

Dim bColumnDependencyColumnIsPresent As Boolean
Dim bColumnDependencyColumnTestIsPresent As Boolean
'Dim bTemplateDependencyColumnTestIsPresent As Boolean
'Dim bDependencyIsOnTemplateName As Boolean
Dim rgDropdownColumnThisItem As Range
Dim rgDropdownColumnNextItem As Range

Dim dblProgressBarValue As Double

Dim voRegex As Variant 'IRegExp2

Dim arrayTemplateSheets() As Worksheet
    Dim iUboundTemplateSheets As Long
    Dim iArrayIndexTemplateSheets As Long
    Dim shArrayItemTemplateSheet As Worksheet
    
Dim ArrayTemplateHeaders() As Range
    Dim iUboundTemplateHeaders As Long
    Dim iArrayIndexTemplateHeaders As Long
    Dim rgArrayItemTemplateHeaders As Range

Dim ArrayTemplateHeaders2() 'array of arrays, not array of ranges.

Dim ArrayItemArrayTemplateHeaders() 'array of one template sheet's headers;
                                          'each array is an item in ArrayTemplateHeaders2.
    Const merchant_facing_name_col As Long = 1
    Const mfa_internal_name_col As Long = 2


Dim shWorksheet As Worksheet
Dim iArrayInde

Const INT_DROPDOWN_LISTS_TABLE_HEADER_ROW As Long = 1

Const INT_DROPDOWN_LISTS_TABLE_DROPDOWN_COLUMN_HEADER As String = "Dropdown Column"
Const INT_DROPDOWN_LISTS_TABLE_TEMPLATE_DEPENDENCY_TEST_HEADER As String = "Template Dependency Test"
Const INT_DROPDOWN_LISTS_TABLE_COLUMN_DEPENDENCY_HEADER As String = "Column Dependency"
Const INT_DROPDOWN_LISTS_TABLE_COLUMN_DEPENDENCY_TEST_HEADER As String = "Column Dependency Test"
Const DEFAULT_LANGUAGE As String = "English USA"
'Const TEMPLATE_DEPENDENCY As String = "Template"

On Error GoTo GenErr

bScreenUpdating = Application.ScreenUpdating
bEnableEvents = Application.EnableEvents
Application.ScreenUpdating = False
Application.EnableEvents = False

ApplyDropDownLists = False 'init.

strInternalTemplateName = GetInternalTemplateName(target_workbook)

Set shIntTable = GetInternationalTableWorksheet()
'Set shTemplate = GetTemplateWorksheet() '1/29/08: now getting array of template sheets instead.
iIntTableLocalNameCol = GetIntTableLocalLanguageColumn(shIntTable)
iIntTableMfaInternalNameCol = GetIntTableMfaInternalNameColumn(shIntTable)
iIntTableTemplateDependencyTestCol = GetIntTableTemplateDependencyTestColumn(shIntTable)


'get array of template sheets:
ReDim arrayTemplateSheets(0 To 0) As Worksheet
iUboundTemplateSheets = UBound(arrayTemplateSheets)
For Each shWorksheet In ThisWorkbook.Worksheets
    If InStr(shWorksheet.CodeName, "shTemplate") > 0 Then
        iUboundTemplateSheets = iUboundTemplateSheets + 1
        ReDim Preserve arrayTemplateSheets(0 To iUboundTemplateSheets) As Worksheet
        Set arrayTemplateSheets(iUboundTemplateSheets) = shWorksheet
    End If
Next shWorksheet




Set voRegex = CreateObject("VBScript.RegExp")

'create new dropdown lists sheet:
Set shDropdownLists = target_workbook.Worksheets.Add
shDropdownLists.Rows(LOCAL_DROPDOWN_LISTS_SHEET_HEADER_ROW).Font.Bold = True
shDropdownLists.Rows(LOCAL_DROPDOWN_LISTS_SHEET_HEADER_ROW).HorizontalAlignment = xlCenter
shDropdownLists.Rows(LOCAL_DROPDOWN_LISTS_SHEET_COLUMN_DEPENDENCY_COLUMN_HEADER_ROW).HorizontalAlignment = xlCenter
shDropdownLists.Rows(LOCAL_DROPDOWN_LISTS_SHEET_COLUMN_DEPENDENCY_TEST_ROW).HorizontalAlignment = xlCenter

'get international table columns:
iHeaderRow = INT_DROPDOWN_LISTS_TABLE_HEADER_ROW
Set shIntDropdownListsTable = target_workbook.Worksheets(DROPDOWN_LISTS_TABLE_WORKSHEET_NAME)
iDropdownColumnCol = FindColumn(shIntDropdownListsTable.Rows(iHeaderRow), INT_DROPDOWN_LISTS_TABLE_DROPDOWN_COLUMN_HEADER)
iColumnDependencyCol = FindColumn(shIntDropdownListsTable.Rows(iHeaderRow), INT_DROPDOWN_LISTS_TABLE_COLUMN_DEPENDENCY_HEADER)
iColumnDependencyTestCol = FindColumn(shIntDropdownListsTable.Rows(iHeaderRow), INT_DROPDOWN_LISTS_TABLE_COLUMN_DEPENDENCY_TEST_HEADER)
iTemplateDependencyTestCol = FindColumn(shIntDropdownListsTable.Rows(iHeaderRow), INT_DROPDOWN_LISTS_TABLE_TEMPLATE_DEPENDENCY_TEST_HEADER)
iTargetLanguageCol = FindColumn(shIntDropdownListsTable.Rows(iHeaderRow), target_language, DEFAULT_LANGUAGE)

'find first and last data rows:
'Set rgFindInRange = shIntDropdownListsTable.Range(shIntDropdownListsTable.Cells(INT_DROPDOWN_LISTS_TABLE_HEADER_ROW, iCatagoryCol), shIntDropdownListsTable.Cells(shIntDropdownListsTable.Rows.Count, iCatagoryCol))
iDataFirstRow = INT_DROPDOWN_LISTS_TABLE_HEADER_ROW + 1
iDataLastRow = shIntDropdownListsTable.Range("A1").SpecialCells(xlLastCell).Row


'get dropdown columns column range:
Set rgFindInDropdownColumnCol = shIntDropdownListsTable.Range(shIntDropdownListsTable.Cells(iDataFirstRow, iDropdownColumnCol), shIntDropdownListsTable.Cells(iDataLastRow, iDropdownColumnCol))


'get column count and last column:
'Stop
'iColCount = Application.WorksheetFunction.CountA(rgFindInDropdownColumnCol)



'find list range:
iListCounter = 0 'init.
iDropdownListFirstRow = iDataFirstRow 'init.
strListboxMfaInternalColumnNamePrevious = "" 'init.

'prepare for checking whether a given column name exists in this template:
Dim rgTemplateHeaders As Range
Dim rgTemplateHeadersLeftCell As Range
Dim rgTemplateHeadersRightCell As Range
Dim iTemplateHeaderCellsCount As Long
Dim iCellLoopCounter As Long
Dim rgHeaderCell As Range
Dim strHeaderCell As String
Dim strHeaderCellMfaInternalName As String
Dim strArrayMatchingColumnHeaders() As String
    Const MFA_INTERNAL_NAME As Long = 1
    Const LOCAL_TEMPLATE_HEADER_NAME As Long = 2
Dim iArrayIndexMatchingColumnHeaders As Long
Dim iLboundMatchingColumnHeaders As Long
Dim iUboundMatchingColumnHeaders As Long
Dim strArrayItemMatchingHeader As String
Dim iArrayItemMatchingColumn As Long





'get array of arrays of template header ranges on the template sheets:
iUboundTemplateHeaders = iUboundTemplateSheets
'ReDim ArrayTemplateHeaders(1 To iUboundTemplateHeaders) As Range
ReDim ArrayTemplateHeaders2(1 To iUboundTemplateHeaders)
For iArrayIndexTemplateSheets = 1 To iUboundTemplateSheets
    Set shArrayItemTemplateSheet = arrayTemplateSheets(iArrayIndexTemplateSheets)
    iTemplateHeaderRow = GetTemplateHeaderRow(shArrayItemTemplateSheet)
    '    Set rgFind = shArrayItemTemplateSheet.Cells(iTemplateHeaderRow, shArrayItemTemplateSheet.Columns.Count)
    Set rgFind = GetRightmostOccupiedCellInRowAsRange(shArrayItemTemplateSheet, iTemplateHeaderRow)
    If rgFind Is Nothing Then
        AmazonMsgBox "No headers found in row " & iTemplateHeaderRow & " of the '" & shArrayItemTemplateSheet.Name & "' sheet."
    End If
    Set rgTemplateHeadersLeftCell = shArrayItemTemplateSheet.Cells(iTemplateHeaderRow, 1)
    Set rgTemplateHeadersRightCell = shArrayItemTemplateSheet.Cells(iTemplateHeaderRow, rgFind.Column)
    Set rgTemplateHeaders = shArrayItemTemplateSheet.Range( _
                                rgTemplateHeadersLeftCell, rgTemplateHeadersRightCell)
'    Set ArrayTemplateHeaders(iArrayIndexTemplateSheets) = rgTemplateHeaders
    iTemplateHeaderCellsCount = rgTemplateHeaders.Cells.Count
    ReDim ArrayItemArrayTemplateHeaders(1 To 2, 1 To iTemplateHeaderCellsCount)
         'Const merchant_facing_name_col As Long = 1
         'Const mfa_internal_name_col As Long = 2
    For iCellLoopCounter = 1 To iTemplateHeaderCellsCount
        strHeaderCell = rgTemplateHeaders(iCellLoopCounter).value
        strHeaderCellMfaInternalName = _
                GetMfaInternalNameColumnHeaderFromLocalLanguageColumnHeader( _
                    strHeaderCell, shIntTable, strInternalTemplateName, _
                    iIntTableLocalNameCol, iIntTableMfaInternalNameCol, iIntTableTemplateDependencyTestCol)
        ArrayItemArrayTemplateHeaders(merchant_facing_name_col, iCellLoopCounter) = strHeaderCell
        ArrayItemArrayTemplateHeaders(mfa_internal_name_col, iCellLoopCounter) = strHeaderCellMfaInternalName
    Next iCellLoopCounter
    ArrayTemplateHeaders2(iArrayIndexTemplateSheets) = ArrayItemArrayTemplateHeaders
Next iArrayIndexTemplateSheets





'delete old dropdown list defined names:
For Each nameDefinedNameTmp In target_workbook.Names
    strDefinedNameTmp = nameDefinedNameTmp.Name
    If InStr(strDefinedNameTmp, DROPDOWN_LIST_DEFINED_NAME_PREFIX) > 0 Then
        nameDefinedNameTmp.Delete
    End If
Next nameDefinedNameTmp




'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Do 'loops through all the dropdown lists to apply.

    'progress bar:
'    frmUpdatePleaseWait.prgUpdate.Value = 20
    If Not is_external_call Then
        dblProgressBarValue = 20 + (80 * (iDropdownListFirstRow / (iDataLastRow - iDataFirstRow)))
        If dblProgressBarValue > 100 Then dblProgressBarValue = 100
'        frmUpdatePleaseWait.prgUpdate.value = dblProgressBarValue
        frmUpdatePleaseWait.lblProgressBar.Width = (dblProgressBarValue / 100) * frmUpdatePleaseWait.frameProgressBar.Width
        frmUpdatePleaseWait.Repaint
        DoEvents
    End If


    'get the mfa internal name of the column for which this will be the dropdown list:
    Set rgListboxMfaInternalColumnName = shIntDropdownListsTable.Cells(iDropdownListFirstRow, iDropdownColumnCol)
    strListboxMfaInternalColumnName = rgListboxMfaInternalColumnName.value
    strListboxMfaInternalColumnNameRegexPattern = RegexPatternEnforceExactMatch(strListboxMfaInternalColumnName)
    
'    Debug.Print strListboxMfaInternalColumnName
    
    

    'check whether this column name exists in this template,
    'and make an array of matching column headers and column numbers:
    '=========================================================================================================
'    Set rgFind = rgTemplateHeaders.Find(What:=strListboxMfaInternalColumnName, LookAt:=xlWhole)
    
    bFound = False 'init.
    iLboundMatchingColumnHeaders = 1 'init.
    iUboundMatchingColumnHeaders = 1 'init.
    ReDim strArrayMatchingColumnHeaders(MFA_INTERNAL_NAME To LOCAL_TEMPLATE_HEADER_NAME, _
                                        iLboundMatchingColumnHeaders To iUboundMatchingColumnHeaders) As String 'init.

    iUboundMatchingColumnHeaders = UBound(strArrayMatchingColumnHeaders, 2)
    iLboundMatchingColumnHeaders = LBound(strArrayMatchingColumnHeaders, 2)
    For iArrayIndexTemplateHeaders = 1 To iUboundTemplateHeaders
'        Set rgArrayItemTemplateHeaders = ArrayTemplateHeaders(iArrayIndexTemplateHeaders)
        ArrayItemArrayTemplateHeaders = ArrayTemplateHeaders2(iArrayIndexTemplateHeaders) '''''''''''''''''''''''''''
                'Const merchant_facing_name_col As Long = 1
                'Const mfa_internal_name_col As Long = 2
        iTemplateHeaderCellsCount = UBound(ArrayItemArrayTemplateHeaders, 2) '''''''''''''''''''''''''''''''''''''''
        For iCellLoopCounter = 1 To iTemplateHeaderCellsCount ''''''''''''''''''''''''''''''''''''''''''''''''''''
'        For Each rgHeaderCell In rgArrayItemTemplateHeaders 'this would be faster as an array.
'            strHeaderCell = rgHeaderCell.value
            strHeaderCell = ArrayItemArrayTemplateHeaders(merchant_facing_name_col, iCellLoopCounter) '''''''''''''''''''
            
            'get the mfa internal name:
'            strHeaderCellMfaInternalName = _
                GetMfaInternalNameColumnHeaderFromLocalLanguageColumnHeader( _
                    strHeaderCell, shIntTable, strInternalTemplateName, _
                    iIntTableLocalNameCol, iIntTableMfaInternalNameCol, iIntTableTemplateDependencyTestCol)
            strHeaderCellMfaInternalName = ArrayItemArrayTemplateHeaders(mfa_internal_name_col, iCellLoopCounter) '''''''''''''''''''
            
    '        If strHeaderCell = strListboxMfaInternalColumnName Then  'change this to regextest
            If RegexTest(strListboxMfaInternalColumnNameRegexPattern, strHeaderCellMfaInternalName) Then
                bFound = True
               
                strArrayMatchingColumnHeaders(MFA_INTERNAL_NAME, iUboundMatchingColumnHeaders) = strHeaderCellMfaInternalName
                strArrayMatchingColumnHeaders(LOCAL_TEMPLATE_HEADER_NAME, iUboundMatchingColumnHeaders) = strHeaderCell
                iUboundMatchingColumnHeaders = iUboundMatchingColumnHeaders + 1
                ReDim Preserve strArrayMatchingColumnHeaders(MFA_INTERNAL_NAME To LOCAL_TEMPLATE_HEADER_NAME, _
                                                             iLboundMatchingColumnHeaders To iUboundMatchingColumnHeaders) As String
    '            Exit For 'NO! There can be multiple hits anywhere in the list.
    
'                If bFound Then Exit For 'NO!!! There can be more than one matching header in the template.
                                         'For example, "battery-type\d*" in ToysBaby.
    
            End If
'        Next rgHeaderCell
        Next iCellLoopCounter
        
        If bFound Then Exit For
        
    Next iArrayIndexTemplateHeaders
    
    'remove extra element at end:
    If bFound Then
        iUboundMatchingColumnHeaders = iUboundMatchingColumnHeaders - 1
        ReDim Preserve strArrayMatchingColumnHeaders(MFA_INTERNAL_NAME To LOCAL_TEMPLATE_HEADER_NAME, _
                                                     iLboundMatchingColumnHeaders To iUboundMatchingColumnHeaders) As String
    End If
    
    If bFound Then
        'that column IS in this template:
        bApplyToThisTemplate = True
    Else
        'that column is NOT in this template:
        bApplyToThisTemplate = False
    End If
    '=========================================================================================================
    
    

    'check for Template dependencies, and apply only the list(s) for the correct template:
    '=========================================================================================================
'    Stop
    If bApplyToThisTemplate Then
        Set rgTemplateDependencyTest = shIntDropdownListsTable.Cells(iDropdownListFirstRow, iTemplateDependencyTestCol)
        strTemplateDependencyTest = rgTemplateDependencyTest.value
        
        If strTemplateDependencyTest = "" Then
            'there is no template dependency for this row:
            bApplyToThisTemplate = True
        Else
            'test for correct template:
            bApplyToThisTemplate = RegexTest(strTemplateDependencyTest, strInternalTemplateName)
        End If
    End If

    'end of check for Template dependency.
    '=========================================================================================================






    'get the list bounds:
    Set rgDataCategoryItem = shIntDropdownListsTable.Cells(iDropdownListFirstRow, iDropdownColumnCol)
    Set rgNextCellDown = rgDataCategoryItem.Offset(RowOffset:=1, ColumnOffset:=0)
    If rgNextCellDown.value = "" Then
        Set rgFind = rgDataCategoryItem.End(xlDown)
    Else
        Set rgFind = rgNextCellDown
    End If
    iTmpRow = rgFind.Row - 1
    iDropdownListLastRow = iTmpRow
'    If iTmpRow > iDropdownListFirstRow Then
'        iDropdownListLastRow = iTmpRow
'    Else
'        'done.
'        Exit Do
'    End If



    If bApplyToThisTemplate Then
    

        'get the list:
        Set rgDropdownList = shIntDropdownListsTable.Range( _
                             shIntDropdownListsTable.Cells(iDropdownListFirstRow, iTargetLanguageCol), _
                             shIntDropdownListsTable.Cells(iDropdownListLastRow, iTargetLanguageCol))
        
        
        'shrink to fit:
        '(exclude any blank cells at the end of the list) (blank cells are due to another locale having more list items for this list)
        Dim iDropdownListLastOccupiedRow As Long
        Dim vCheckCellValue As Variant
        For iDropdownListLastOccupiedRow = iDropdownListLastRow To iDropdownListFirstRow Step -1
            vCheckCellValue = shIntDropdownListsTable.Cells(iDropdownListLastOccupiedRow, iTargetLanguageCol).value
            If vCheckCellValue <> "" Then
                Exit For
            End If
        Next iDropdownListLastOccupiedRow
        If iDropdownListLastOccupiedRow < iDropdownListFirstRow Then
            'there are no list items:
            bApplyToThisTemplate = False
            iDropdownListLastOccupiedRow = iDropdownListFirstRow
        End If
        Set rgDropdownList = shIntDropdownListsTable.Range( _
                             shIntDropdownListsTable.Cells(iDropdownListFirstRow, iTargetLanguageCol), _
                             shIntDropdownListsTable.Cells(iDropdownListLastOccupiedRow, iTargetLanguageCol))
                             

        'get the column dependency column header, if any:
        Set rgColumnDependencyMfaInternalColumnName = shIntDropdownListsTable.Cells(iDropdownListFirstRow, iColumnDependencyCol)
        strColumnDependencyMfaInternalColumnName = rgColumnDependencyMfaInternalColumnName.value
        
        '2009-06-16:
        'get local column dependency column header name from the mfa name:
            'does this need to be an array, looping through ArrayTemplateSheets to get array of
            'local column header names, and then looping through that array below?
        If strColumnDependencyMfaInternalColumnName = "" Then
            strColumnDependencyLocalColumnName = ""
        Else
            Dim shTemplate As Worksheet
'            Dim iIntTableMfaInternalNameCol As Long
'            Dim iIntTableLocalNameCol As Long
'            Dim iTemplateHeaderRow As Long
            Set shTemplate = arrayTemplateSheets(1) ''or loop through 1 To iUboundTemplateSheets
'            iIntTableMfaInternalNameCol = GetIntTableMfaInternalNameColumn(shIntTable)
'            iIntTableLocalNameCol = GetIntTableLocalLanguageColumn(shIntTable)
'            iTemplateHeaderRow = GetTemplateHeaderRow(shTemplate)
            strColumnDependencyLocalColumnName = GetLocalColumnHeaderFromMfaInternalName( _
                                                    strColumnDependencyMfaInternalColumnName, _
                                                    shIntTable, _
                                                    shTemplate, _
                                                    iIntTableMfaInternalNameCol, _
                                                    iIntTableLocalNameCol, _
                                                    iTemplateHeaderRow)
        End If
        
        
        'get the column dependency test, if any:
        Set rgColumnDependencyTest = shIntDropdownListsTable.Cells(iDropdownListFirstRow, iColumnDependencyTestCol)
        strColumnDependencyTest = rgColumnDependencyTest.value
        
        
        'loop through matching destination columns, applying the dropdown list to each one:
        For iArrayIndexMatchingColumnHeaders = iLboundMatchingColumnHeaders To iUboundMatchingColumnHeaders
'            strArrayItemMatchingHeader = strArrayMatchingColumnHeaders(iArrayIndexMatchingColumnHeaders)
            strArrayItemMatchingHeader = strArrayMatchingColumnHeaders(LOCAL_TEMPLATE_HEADER_NAME, iArrayIndexMatchingColumnHeaders)
        
            
            'move to the next destination column:
            iListCounter = iListCounter + 1
            
            
            'copy the column dependency column header, if any, to the dropdown lists sheet:
            If strColumnDependencyMfaInternalColumnName <> "" Then
                shDropdownLists.Cells(LOCAL_DROPDOWN_LISTS_SHEET_COLUMN_DEPENDENCY_COLUMN_HEADER_ROW, iListCounter).value = _
                                      strColumnDependencyLocalColumnName 'strColumnDependencyMfaInternalColumnName
                
                
                'copy the column dependency test, if any, to the dropdown lists sheet:
                shDropdownLists.Cells(LOCAL_DROPDOWN_LISTS_SHEET_COLUMN_DEPENDENCY_TEST_ROW, iListCounter).value = _
                                      strColumnDependencyTest
            End If
            
            
            'copy the list to the dropdown lists sheet:
            shDropdownLists.Cells(LOCAL_DROPDOWN_LISTS_SHEET_HEADER_ROW, iListCounter).value = strArrayItemMatchingHeader
            Set rgDestDropDownList = shDropdownLists.Range( _
                                        shDropdownLists.Cells( _
                                            LOCAL_DROPDOWN_LISTS_SHEET_FIRST_DATA_ROW, _
                                            iListCounter), _
                                        shDropdownLists.Cells( _
                                            rgDropdownList.Rows.Count + LOCAL_DROPDOWN_LISTS_SHEET_HEADER_ROW, _
                                            iListCounter))
            rgDropdownList.NumberFormat = "@"
            rgDropdownList.Copy Destination:=rgDestDropDownList
            'remove any leading or trailing spaces:
            For Each rgCellDestDropDownList In rgDestDropDownList.Cells
                strCellDestDropDownList = rgCellDestDropDownList.value
                strTemp = Trim(strCellDestDropDownList)
                If strCellDestDropDownList <> strTemp Then
                    'there are leading and/or trailing spaces, so remove them:
                    rgCellDestDropDownList.value = strTemp
                End If
            Next rgCellDestDropDownList
            shDropdownLists.Columns(iListCounter).AutoFit
            
            
            
            
            

            'remove duplicates from dropdown list:
            Dim bRemoveDupes As Boolean 'do not remove dupes if there are [ sections ] in the list.
            bRemoveDupes = True 'init.
            For Each rgCellDestDropDownList In rgDestDropDownList.Cells
                strTemp = rgCellDestDropDownList.value
                If strTemp = "" Then
                    'don't remove dupes if there are any blank cells, because they could be section separators.
                    bRemoveDupes = False
                    Exit For
                ElseIf InStr(strTemp, "[") > 0 Then
                    'could be a [ section ].
                    bRemoveDupes = False
                    Exit For
                End If
            Next rgCellDestDropDownList
            If bRemoveDupes Then
                Dim iCheckRowA As Long, iCheckRowB As Long, strCheckCellA As String, strCheckCellB As String
                Dim iStartRowA As Long, iLastRowA As Long, iStartRowB As Long, iLastRowB As Long
                iStartRowA = rgDestDropDownList.Row
                iLastRowA = (rgDestDropDownList.Row + rgDestDropDownList.Rows.Count) - 1
                For iCheckRowA = iStartRowA To iLastRowA
                    strCheckCellA = shDropdownLists.Cells(iCheckRowA, iListCounter).value
                    iStartRowB = iCheckRowA + 1: iLastRowB = iLastRowA - 1
                    For iCheckRowB = iStartRowB To iLastRowB
                        strCheckCellB = shDropdownLists.Cells(iCheckRowB, iListCounter).value
                        If strCheckCellA = strCheckCellB Then
                            If strCheckCellA <> "" Then
                                shDropdownLists.Cells(iCheckRowB, iListCounter).Delete Shift:=xlUp
                            End If
                        End If
                    Next iCheckRowB
                Next iCheckRowA
            End If
            
            
            
            
            
            'get defined name suffix, if any:
        '    Stop
            If strListboxMfaInternalColumnNamePrevious = strArrayItemMatchingHeader Then
                strDropdownListDefinedNameSuffix = IncrementDefinedNameSuffix(strDropdownListDefinedNameSuffix)
            Else
                strDropdownListDefinedNameSuffix = ""
            End If
            
            
            'get defined name suffix separator, if any:
            strDropdownListDefinedNameSuffixSeparator = GetDefinedNameSuffixSeparatorFromSuffix(strDropdownListDefinedNameSuffix)
            
            
            'get the defined name to apply for the list:
            Do
                strListDefinedName = DROPDOWN_LIST_DEFINED_NAME_PREFIX & _
                                     Replace(strArrayItemMatchingHeader, "-", "_") & _
                                     strDropdownListDefinedNameSuffixSeparator & _
                                     strDropdownListDefinedNameSuffix
                
                'check whether that defined name already exists, and increment if necessary:
                'strDefinedNameTmp
                bFound = False 'init.
                For Each nameDefinedNameTmp In target_workbook.Names
                    strDefinedNameTmp = nameDefinedNameTmp.Name
                    If strDefinedNameTmp = strListDefinedName Then
                        bFound = True
                        Exit For
                    End If
                Next nameDefinedNameTmp
                If bFound Then
                    'this one catches cases where there are multiple groups of numbered
                    'defined names, with the same base name. For example, test1, test2, test3, then
                    'test1, test2, test3 again, etc.
                    strDropdownListDefinedNameSuffix = IncrementDefinedNameSuffix(strDropdownListDefinedNameSuffix)
                    strDropdownListDefinedNameSuffixSeparator = GetDefinedNameSuffixSeparatorFromSuffix(strDropdownListDefinedNameSuffix)
                End If
            Loop Until Not bFound
            
            'apply the defined name for the list:
            target_workbook.Names.Add strListDefinedName, rgDestDropDownList
            
            strListboxMfaInternalColumnNamePrevious = strArrayItemMatchingHeader
        
        
                Next iArrayIndexMatchingColumnHeaders
    
    
    End If
    
    iDropdownListFirstRow = iDropdownListLastRow + 1
    
    
Loop Until iDropdownListFirstRow > iDataLastRow


'delete any defined names still associated with the old dropdown lists sheet:
    'do this ONLY when updating template, NOT when making new localized templates from master template;
    'otherwise, it deletes names in the master:
On Error GoTo BrokenDefinedName
Dim bSkipName As Boolean
If target_workbook Is ThisWorkbook Then
    For Each nmName In ThisWorkbook.Names
        bSkipName = False 'init for each name.
        Set rgName = nmName.RefersToRange
        If rgName.Parent.Name = DROPDOWN_LISTS_WORKSHEET_NAME Then
            If Not bSkipName Then
                nmName.Delete
            End If
        End If
    Next nmName
End If
On Error GoTo GenErr


'delete the old dropdown lists sheet:
Dim iSheetVisibility As Long
iSheetVisibility = xlSheetVeryHidden 'init.
For Each shTmp In target_workbook.Worksheets
    If shTmp.Name = DROPDOWN_LISTS_WORKSHEET_NAME Then
        bDisplayAlerts = Application.DisplayAlerts
        Application.DisplayAlerts = False
        iSheetVisibility = shTmp.Visible
        If iSheetVisibility = xlSheetVeryHidden Then
            shTmp.Visible = xlSheetHidden
            DoEvents
        End If
        shTmp.Delete
        DoEvents
        Application.DisplayAlerts = bDisplayAlerts
        Exit For
    End If
Next shTmp

'rename and hide the new dropdown lists sheet:
shDropdownLists.Name = DROPDOWN_LISTS_WORKSHEET_NAME
shDropdownLists.Visible = iSheetVisibility
DoEvents

Application.ScreenUpdating = bScreenUpdating
Application.EnableEvents = bEnableEvents

ApplyDropDownLists = True


Exit Function

GenErr:

If False Then
    Resume
End If

Application.ScreenUpdating = bScreenUpdating
Application.EnableEvents = bEnableEvents

Exit Function

BrokenDefinedName:
'delete the name if it is broken:
If InStr(nmName.RefersTo, "#REF!") > 0 Then
    'delete the name, so do nothing here.
Else
    'this name is not broken:
    bSkipName = True
End If
Resume Next

End Function




Public Function RegexTest(pattern_text As String, text_to_test As String) As Boolean

Dim voRegex As Variant 'IRegExp2

On Error GoTo GenErr

Set voRegex = CreateObject("VBScript.RegExp")

voRegex.Pattern = pattern_text
If voRegex.test(text_to_test) Then
    RegexTest = True
Else
    RegexTest = False
End If

Exit Function

GenErr:

If False Then
    Resume
End If

End Function


Public Function RegexReplace(old_string, pattern_to_find_text_to_remove, text_to_swap_in) As String
    On Error GoTo GenErr
    Dim voRegex As Variant 'IRegExp2
    Set voRegex = CreateObject("VBScript.RegExp")
    voRegex.Pattern = pattern_to_find_text_to_remove
    RegexReplace = voRegex.Replace(old_string, text_to_swap_in)

    Exit Function
GenErr:
    If False Then
        Resume
    End If
End Function



Public Function RegexPatternEnforceExactMatch(pattern_text As String)
    RegexPatternEnforceExactMatch = "^" & pattern_text & "$"
End Function




Function MakeNewTemplateWorkbook(target_language As String) As Workbook

Dim strPath As String
Dim strNewWorkbookName As String
Dim strExtension As String
Dim strNameWithoutExt As String
Dim strNameAfterSubst As String
Dim rgLanguageCell As Range
Dim iLanguageCol As Long
Dim rgTableHeaderRow As Range
Dim iTableHeaderRow As Long
Dim iUrlCategoryRow As Long
Dim strTargetLanguageName As String
Dim shIntlTable As Worksheet
Dim bEnableEventsStatus As Boolean
Dim bDisplayAlerts As Boolean
Dim rgFind As Range
Dim iLastCol As Long
Dim iTargetLanguageCol As Long
Dim iDataCategoryCol As Long
Dim shNewTemplateInternationalData As Worksheet
Dim rgCell As Range
Dim rgHeaderRange As Range
Dim rgDeleteColumns As Range
Dim strURL As String
Dim strOldFilenameSubst As String
Dim strLocalizedFilename As String
'Dim shIntFilenames As Worksheet
Dim iNewSubstCol As Long
Dim iNewSubstRow As Long
Dim strChar As String
Dim iPos As Long
Dim iLen As Long
Dim strLocalTemplatesFolder As String
Dim wbBook As Workbook

'Const FILENAME_SUBSTITUTED_PART_DEFINED_NAME As String = "Localized_Workbooks_Filename_Substituted"
Const LOCALIZED_FILENAME_HEADER As String = "Localized Filename"


On Error GoTo GenErr

bEnableEventsStatus = Application.EnableEvents

'get filename extension:
If UCase(Right(ThisWorkbook.Name, 4)) = ".XLS" Then
    strExtension = UCase(Right(ThisWorkbook.Name, 4))
Else
    strExtension = UCase(Right(ThisWorkbook.Name, 5))
End If



'get the international filenames worksheet:
'Set shIntFilenames = ThisWorkbook.Names(LOCALIZED_FILENAME_HEADER).RefersToRange.Parent

'get the old filename part that will be substituted out:
'strOldFilenameSubst = ThisWorkbook.Names(FILENAME_SUBSTITUTED_PART_DEFINED_NAME).RefersToRange.Value

'get the row of the language of the new filename part that will be substituted in:
Set rgFind = shIntFilenames.Cells.Find(What:=target_language, LookAt:=xlWhole)
Call ResetFindParametersToDefaults
If rgFind Is Nothing Then
    shIntFilenames.Visible = xlSheetVisible
    shIntFilenames.Activate
    DoEvents
'    MsgBox "Unable to find filename for saving the " & target_language & " template." & _
           vbNewLine & vbNewLine & _
           "Please fix on the 'International Filenames' worksheet and restart."
    AmazonMsgBox GetTranslatedString("unable_to_find_filename_1") & target_language & GetTranslatedString("unable_to_find_filename_2")
    Exit Function
End If
iNewSubstRow = rgFind.Row

'get the filename substitution column for the new filename part that will be substituted in:
Set rgFind = shIntFilenames.Cells.Find(What:=LOCALIZED_FILENAME_HEADER, LookAt:=xlWhole)
Call ResetFindParametersToDefaults
If rgFind Is Nothing Then
    shIntFilenames.Visible = xlSheetVisible
    shIntFilenames.Activate
    DoEvents
'    MsgBox "Unable to find filename substitution column header." & _
           vbNewLine & vbNewLine & _
           "Please fix on the 'International Filenames' worksheet and restart."
    AmazonMsgBox GetTranslatedString("unable_to_find_filename_substitution")
    Exit Function
End If
iNewSubstCol = rgFind.Column

'get the localized filename:
strLocalizedFilename = shIntFilenames.Cells(iNewSubstRow, iNewSubstCol).value

'check for invalid characters:
iLen = Len(strLocalizedFilename)
For iPos = 1 To iLen
    strChar = Mid(strLocalizedFilename, iPos, 1)
    Select Case strChar
        Case "\", "/", ":", "*", "?", """", "<", ">", "|"
            shIntFilenames.Visible = xlSheetVisible
            shIntFilenames.Activate
            DoEvents
'            MsgBox "Invalid filename for saving the " & target_language & " template." & _
                   vbNewLine & vbNewLine & _
                   "Please fix on the 'International Filenames' worksheet and restart."
            AmazonMsgBox GetTranslatedString("invalid_filename_1") & target_language & GetTranslatedString("invalid_filename_2") & _
                         vbNewLine & vbNewLine & _
                         GetTranslatedString("invalid_filename_3")
    Exit Function
    End Select
Next iPos

'get the old filename without extension:
'strNameWithoutExt = Left(ThisWorkbook.Name, Len(ThisWorkbook.Name) - Len(strExtension))

''do the substitution:
'strNameAfterSubst = Replace(strNameWithoutExt, strOldFilenameSubst, strLocalizedFilename)

'get the new full workbook name:
strNewWorkbookName = strLocalizedFilename & strExtension

'get the local templates folder name:
strLocalTemplatesFolder = ThisWorkbook.Names(LOCAL_TEMPLATES_FOLDER_DEFINED_NAME).RefersToRange.value

'get full folder path:
Dim strFullFolderPath As String
strFullFolderPath = ThisWorkbook.Path & "\" & strLocalTemplatesFolder


'check for the local templates folder name, and create it if necessary:
Dim fso As Object
Dim oFolder As Object
Set fso = CreateObject("Scripting.FileSystemObject")
If Not fso.FolderExists(strFullFolderPath) Then
    fso.CreateFolder strFullFolderPath
    DoEvents
End If


'get the full path:
strPath = strFullFolderPath & "\" & strNewWorkbookName

'close if open:
For Each wbBook In Application.Workbooks
    If wbBook.Path & "\" & wbBook.Name = strPath Then
        wbBook.Close SaveChanges:=False
        Exit For
    End If
Next wbBook

'delete if already exists:
If fso.FileExists(strPath) Then
    fso.DeleteFile strPath
    DoEvents
End If

ThisWorkbook.SaveCopyAs strPath
bEnableEventsStatus = Application.EnableEvents
Application.EnableEvents = False
Set MakeNewTemplateWorkbook = Workbooks.Open(strPath, UpdateLinks:=0) '0 = do not update links.
Application.EnableEvents = bEnableEventsStatus
Set shNewTemplateInternationalData = MakeNewTemplateWorkbook.Worksheets(INT_TABLE_WORKSHEET_NAME)


'remove columns from international table not needed for this language:
    'for v2, moved this to xxxxxxxxxxx in modSupport:
    Call RemoveOtherLanguageColumnsFromIntMiscData(shNewTemplateInternationalData, target_language)
'''''Set rgFind = shNewTemplateInternationalData.Cells(INT_TABLE_HEADER_ROW, shNewTemplateInternationalData.Columns.Count).End(xlToLeft)
'''''iLastCol = rgFind.Column
'''''Set rgHeaderRange = shNewTemplateInternationalData.Range(shNewTemplateInternationalData.Cells(INT_TABLE_HEADER_ROW, 1), shNewTemplateInternationalData.Cells(INT_TABLE_HEADER_ROW, iLastCol))
'''''For Each rgCell In rgHeaderRange.Cells
'''''    Select Case rgCell.Value
'''''        Case INT_TABLE_DATA_CATEGORY_HEADER
'''''            'skip
'''''        Case INT_TABLE_REFERENCE_HEADER
'''''            'skip
'''''        Case INT_TABLE_NUMBER_FORMAT_HEADER
'''''            'skip
'''''        Case INT_TABLE_MASTER_NAME_HEADER
'''''            'skip
'''''        Case INT_TABLE_MFA_INTERNAL_NAME_HEADER
'''''            'skip
'''''        Case INT_TABLE_TEMPLATE_DEPENDENCY_TEST_HEADER
'''''            'skip
'''''        Case target_language
'''''            'skip
'''''        Case Else
'''''            'add to rgDeleteColumns:
'''''            If rgDeleteColumns Is Nothing Then
'''''                Set rgDeleteColumns = rgCell.EntireColumn
'''''            Else
'''''                Set rgDeleteColumns = Union(rgDeleteColumns, rgCell.EntireColumn)
'''''            End If
'''''    End Select
'''''Next rgCell
'''''rgDeleteColumns.Delete Shift:=xlToLeft



'set URL for local table setting:
Set rgFind = shNewTemplateInternationalData.Rows(INT_TABLE_HEADER_ROW).Find(target_language)
Call ResetFindParametersToDefaults
iTargetLanguageCol = rgFind.Column
Set rgFind = shNewTemplateInternationalData.Rows(INT_TABLE_HEADER_ROW).Find(INT_TABLE_DATA_CATEGORY_HEADER)
Call ResetFindParametersToDefaults
iDataCategoryCol = rgFind.Column
Set rgFind = shNewTemplateInternationalData.Columns(iDataCategoryCol).Find(DATA_CATEGORY_URL)
Call ResetFindParametersToDefaults
iUrlCategoryRow = rgFind.Row
strURL = shNewTemplateInternationalData.Cells(iUrlCategoryRow, iTargetLanguageCol).value
If strURL = "" Then
'    MsgBox "Missing URL for " & target_language & " update table. Please fix and restart.", vbCritical + vbOKOnly, "Missing URL"
    AmazonMsgBox GetTranslatedString("missing_url_update_1") & target_language & GetTranslatedString("missing_url_update_2"), vbOKOnly, GetTranslatedString("missing_url")

    Set MakeNewTemplateWorkbook = Nothing
    Exit Function
End If
MakeNewTemplateWorkbook.Names(FULL_MISC_DATA_TABLE_URL_DEFINED_NAME).RefersToRange.value = strURL

'set language in International Settings:
MakeNewTemplateWorkbook.Names(TEMPLATE_LANGUAGE_DEFINED_NAME).RefersToRange.value = target_language


'delete international filenames workbook:
bDisplayAlerts = Application.DisplayAlerts
Application.DisplayAlerts = False
MakeNewTemplateWorkbook.Worksheets(shIntFilenames.Name).Delete
Application.DisplayAlerts = bDisplayAlerts


'MakeNewTemplateWorkbook.Save

Application.EnableEvents = bEnableEventsStatus


Exit Function

GenErr:

If InStr(Err.Description, "Cannot access") > 0 Then
    Workbooks(strNewWorkbookName).Close SaveChanges:=False
    ThisWorkbook.SaveCopyAs strPath
    Resume Next
Else
'    MsgBox "An error occurred while trying to create the " & target_language & " template.", _
    vbCritical + vbOKOnly, "Amazon Template Localization"
    
    AmazonMsgBox GetTranslatedString("error_occurred_1") & target_language & GetTranslatedString("error_occurred_2"), _
                 vbOKOnly, GetTranslatedString("amazon_template_localization")
End If

If False Then
    Resume
End If

Application.EnableEvents = bEnableEventsStatus

End Function

    

Function SwapColumnHeaders(work_book_feed As Workbook, work_sheet_table As Worksheet, _
                           source_language As String, target_language As String, _
                           Optional alt_source_language As String) As Boolean
                           

'returns True on success

Dim wbWorkbook As Workbook
Dim iFeedHeaderRow As Long
Dim rgFeedHeaders As Range
Dim vArrayFeedHeaders As Variant 'must be declared as Variant.
Dim vArrayFeedNumberFormats() As String
Dim rgTableAll As Range
Dim iTableAllLastRow As Long
Dim iTableDataCategoryCol As Long
Dim iTableNumberFormatCol As Long
Dim iTableHeaderSourceColMasterName As Long
Dim iTableHeaderSourceColMfaInternalName As Long
Dim iTableTemplateDependencyTestCol As Long
Dim iTableHeaderTargetCol As Long
Dim iTableCategoryFirstRow As Long
Dim iTableCategoryLastRow As Long
Dim rgTableSourceMasterName As Range
Dim rgTableSourceMfaInternalName As Range
Dim rgTableTarget As Range
Dim rgTableNumberFormat As Range
Dim rgTableTemplateDependencyTest As Range
Dim vArrayTableSourceMasterName As Variant 'must be declared as Variant.
Dim vArrayTableSourceMfaInternalName As Variant 'must be declared as Variant.
Dim vArrayTableTarget As Variant 'must be declared as Variant.
Dim vArrayTableNumberFormat As Variant 'must be declared as Variant.
Dim vArrayTableTemplateDependencyTest As Variant 'must be declared as Variant.
Dim rgTemp As Range
Dim rgFindInRange As Range
Dim iArrayIndexFeedHeaders As Long
Dim iArrayIndexFeedNumberFormat As Long
Dim iArrayIndexTableSource As Long
Dim iArrayIndexTableSourceMfaInternalName As Long
Dim iUboundFeedHeaders As Long
Dim iLboundFeedHeaders As Long
Dim iUboundTableSource As Long
Dim iLboundTableSource As Long
Dim iUboundFeedNumberFormats As Long
Dim vItemFeedHeaders As Variant
Dim vItemTableSource As Variant
Dim vItemTableSourceMasterName As Variant
Dim vItemTableSourceMfaInternalName As Variant
Dim vItemTableTarget As Variant
Dim vItemTableNumberFormat As Variant
Dim vItemTableTemplateDependencyTest As Variant
Dim vItemFeedNumberFormat As Variant
Dim bFound As Boolean
Dim iFeedColumnWidth As Double
Dim iTableColumnWidth As Double
Dim rgCell As Range
Dim rgDeleteColumnsThisLocale As Range
Dim rgColumnToDelete As Range
Dim bEnableEventsStatus As Boolean
Dim bApplyToThisTemplate As Boolean
Dim shWorksheet As Worksheet
Dim strInternalTemplateName As String

Dim arrayTemplateSheets() As Worksheet
    Dim iUboundTemplateSheets As Long
    Dim iArrayIndexTemplateSheets As Long
    Dim shArrayItemTemplateSheet As Worksheet
    
Dim ArrayTemplateHeaders() As Range
    Dim iUboundTemplateHeaders As Long
    Dim iArrayIndexTemplateHeaders As Long
    Dim rgArrayItemTemplateHeaders As Range

Const DIMENSION_HEADERS_FEED As Long = 2
Const DIMENSION_HEADERS_TABLE As Long = 1
Const ELEMENT_HEADERS As Long = 1
Const ELEMENT_NUMBERFORMATS As Long = 1
Const ELEMENT_TESTS As Long = 1
'Const DIMENSION_ROWS_FEED As Long = 2


On Error GoTo GenErr

Set wbWorkbook = ThisWorkbook 'shArrayItemTemplateSheet.Parent

strInternalTemplateName = GetInternalTemplateName(ThisWorkbook)


'create array of row numbers to *not* delete from table (IntMiscData) sheet:
'(where there is more than one template sheet, it will be easier to keep
'track of rows to keep than rows to delete.)
ReDim iArrayKeepRows(0 To 0) As Long


'get array of template sheets:
ReDim arrayTemplateSheets(0 To 0) As Worksheet
iUboundTemplateSheets = UBound(arrayTemplateSheets)
For Each shWorksheet In work_book_feed.Worksheets
    If InStr(shWorksheet.CodeName, "shTemplate") > 0 Then
        iUboundTemplateSheets = iUboundTemplateSheets + 1
        ReDim Preserve arrayTemplateSheets(0 To iUboundTemplateSheets) As Worksheet
        Set arrayTemplateSheets(iUboundTemplateSheets) = shWorksheet
    End If
Next shWorksheet



For iArrayIndexTemplateSheets = 1 To iUboundTemplateSheets

    Set shArrayItemTemplateSheet = arrayTemplateSheets(iArrayIndexTemplateSheets)
    Set rgDeleteColumnsThisLocale = Nothing
    shArrayItemTemplateSheet.Unprotect 'for NumberFormat.


    'find range of headers:
    iFeedHeaderRow = GetTemplateHeaderRow(shArrayItemTemplateSheet)
    Set rgFeedHeaders = GetHeaderRange(shArrayItemTemplateSheet, iFeedHeaderRow)
    If rgFeedHeaders.Cells.Count = 1 Then
        'add a cell to the range:
        Set rgFeedHeaders = rgFeedHeaders.Resize(, 2)
    End If
    vArrayFeedHeaders = rgFeedHeaders
    iUboundFeedNumberFormats = rgFeedHeaders.Cells.Count
    ReDim vArrayFeedNumberFormats(1 To iUboundFeedNumberFormats) As String
    DoEvents
    
    'get whole table range:
    Set rgTableAll = work_sheet_table.Range("A1").CurrentRegion
    
    'get category, number format, source, and target table columns:
    iTableDataCategoryCol = FindColumn(work_sheet_table.Rows(INT_TABLE_HEADER_ROW), INT_TABLE_DATA_CATEGORY_HEADER)
    iTableNumberFormatCol = FindColumn(work_sheet_table.Rows(INT_TABLE_HEADER_ROW), INT_TABLE_NUMBER_FORMAT_HEADER)
    iTableTemplateDependencyTestCol = FindColumn(work_sheet_table.Rows(INT_TABLE_HEADER_ROW), INT_TABLE_TEMPLATE_DEPENDENCY_TEST_HEADER)
    iTableHeaderSourceColMasterName = FindColumn(work_sheet_table.Rows(INT_TABLE_HEADER_ROW), source_language)
    iTableHeaderSourceColMfaInternalName = FindColumn(work_sheet_table.Rows(INT_TABLE_HEADER_ROW), alt_source_language)
    iTableHeaderTargetCol = FindColumn(work_sheet_table.Rows(INT_TABLE_HEADER_ROW), target_language)
    
    'find first and last rows of column headers category in table:
    Set rgFindInRange = work_sheet_table.Range(work_sheet_table.Cells(INT_TABLE_HEADER_ROW, iTableDataCategoryCol), work_sheet_table.Cells(work_sheet_table.Rows.Count, iTableDataCategoryCol))
    iTableCategoryFirstRow = FindCategoryFirstRow(rgFindInRange, DATA_CATEGORY_COLUMN_HEADERS)
    iTableCategoryLastRow = FindCategoryLastRow(rgFindInRange, DATA_CATEGORY_COLUMN_HEADERS)
    
    'get source and target ranges:
    Set rgTableSourceMasterName = work_sheet_table.Range(work_sheet_table.Cells(iTableCategoryFirstRow, iTableHeaderSourceColMasterName), work_sheet_table.Cells(iTableCategoryLastRow, iTableHeaderSourceColMasterName))
    Set rgTableSourceMfaInternalName = work_sheet_table.Range(work_sheet_table.Cells(iTableCategoryFirstRow, iTableHeaderSourceColMfaInternalName), work_sheet_table.Cells(iTableCategoryLastRow, iTableHeaderSourceColMfaInternalName))
    Set rgTableTemplateDependencyTest = work_sheet_table.Range(work_sheet_table.Cells(iTableCategoryFirstRow, iTableTemplateDependencyTestCol), work_sheet_table.Cells(iTableCategoryLastRow, iTableTemplateDependencyTestCol))
    Set rgTableTarget = work_sheet_table.Range(work_sheet_table.Cells(iTableCategoryFirstRow, iTableHeaderTargetCol), work_sheet_table.Cells(iTableCategoryLastRow, iTableHeaderTargetCol))
    Set rgTableNumberFormat = work_sheet_table.Range(work_sheet_table.Cells(iTableCategoryFirstRow, iTableNumberFormatCol), work_sheet_table.Cells(iTableCategoryLastRow, iTableNumberFormatCol))
    vArrayTableSourceMasterName = rgTableSourceMasterName
    vArrayTableSourceMfaInternalName = rgTableSourceMfaInternalName
    vArrayTableTemplateDependencyTest = rgTableTemplateDependencyTest
    vArrayTableTarget = rgTableTarget
    vArrayTableNumberFormat = rgTableNumberFormat
    
    'swap:
    iLboundFeedHeaders = LBound(vArrayFeedHeaders, DIMENSION_HEADERS_FEED)
    iUboundFeedHeaders = UBound(vArrayFeedHeaders, DIMENSION_HEADERS_FEED)
    iLboundTableSource = LBound(vArrayTableSourceMasterName, DIMENSION_HEADERS_TABLE)
    iUboundTableSource = UBound(vArrayTableSourceMasterName, DIMENSION_HEADERS_TABLE)
    For iArrayIndexFeedHeaders = iLboundFeedHeaders To iUboundFeedHeaders
        'for each of this workbook's template headers:
        DoEvents
        vItemFeedHeaders = vArrayFeedHeaders(ELEMENT_HEADERS, iArrayIndexFeedHeaders)
        bFound = False 'init.
        
        For iArrayIndexTableSource = iLboundTableSource To iUboundTableSource
            'For each of the headers in the html table:
    
            DoEvents
    
    
    
            'check for Template dependency, and
            'process only those column headers in the table whose row in the HTML table
            'doesn't fail the template dependency test:
            '=========================================================================================================
            vItemTableTemplateDependencyTest = vArrayTableTemplateDependencyTest(iArrayIndexTableSource, ELEMENT_TESTS)
            
            If vItemTableTemplateDependencyTest = "" Then
                'there is no template dependency for this table row:
                bApplyToThisTemplate = True
            Else
                'test for correct template:
                bApplyToThisTemplate = RegexTest(CStr(vItemTableTemplateDependencyTest), strInternalTemplateName)
            End If
        
            'end of check for Template dependency.
            '=========================================================================================================
    
            
            If bApplyToThisTemplate Then
    
        
                vItemTableSourceMasterName = vArrayTableSourceMasterName(iArrayIndexTableSource, ELEMENT_HEADERS)
                vItemTableSourceMfaInternalName = vArrayTableSourceMfaInternalName(iArrayIndexTableSource, ELEMENT_HEADERS)
                
    '            Debug.Print vItemTableSourceMfaInternalName, vItemTableSourceMasterName
                
                If vItemTableSourceMasterName = vItemFeedHeaders Then
                    bFound = True
                    vItemTableSource = vItemTableSourceMasterName
                '12/12/07: commented this out because it was causing headers with wrong case formatting
                'to be used in localized templates. If this is needed, then it will have to come after looking
                'through all master names first:
    '            ElseIf vItemTableSourceMfaInternalName = vItemFeedHeaders Then
    '                bFound = True
    '                vItemTableSource = vItemTableSourceMfaInternalName
                End If
                
                If bFound Then
                    vItemTableTarget = vArrayTableTarget(iArrayIndexTableSource, ELEMENT_HEADERS)
                    
                    If vItemTableTarget = "" Then
                        'remove that column from this locale:
                        Set rgColumnToDelete = rgFeedHeaders(iArrayIndexFeedHeaders).EntireColumn
                        If rgDeleteColumnsThisLocale Is Nothing Then
                            Set rgDeleteColumnsThisLocale = rgColumnToDelete
                        Else
                            Set rgDeleteColumnsThisLocale = Union( _
                                                            rgDeleteColumnsThisLocale, _
                                                            rgColumnToDelete)
                        End If
        
                    Else
                        'swap:
                        vArrayFeedHeaders(ELEMENT_HEADERS, iArrayIndexFeedHeaders) = vItemTableTarget
                        vItemTableNumberFormat = GetTableNumberFormatItem(vArrayTableNumberFormat, iArrayIndexTableSource, ELEMENT_NUMBERFORMATS)
                        vArrayFeedNumberFormats(iArrayIndexFeedHeaders) = vItemTableNumberFormat
                        
                        'keep this row in the table sheet IntMiscData:
                        ReDim Preserve iArrayKeepRows(0 To UBound(iArrayKeepRows) + 1) As Long
                        iArrayKeepRows(UBound(iArrayKeepRows)) = iArrayIndexTableSource
                        
                    End If
                    
                    
        
                    
                    Exit For
                End If
            
            End If 'If bApplyToThisTemplate Then
            
        Next iArrayIndexTableSource
        
        If Not bFound Then
            'skip blanks:
            If vItemFeedHeaders = "" Then
                'skip
            Else
                'couldn't find the column header. can't proceed.
'                MsgBox "Can't find column header """ & vItemFeedHeaders & """" & _
                       " (from " & GetRefAsString(rgFeedHeaders(iArrayIndexFeedHeaders)) & ")" & _
                       " in " & GetRefAsString(rgTableSourceMfaInternalName) & _
                       " (" & source_language & " column headers)" & _
                       " in a row that passes all dependency tests." & _
                       vbNewLine & vbNewLine & _
                       "Please fix and restart.", _
                       vbCritical + vbOKOnly, "Can't Find Header"
                AmazonMsgBox GetTranslatedString("cant_find_column_header_1") & vItemFeedHeaders & _
                             GetTranslatedString("cant_find_column_header_2") & GetRefAsString(rgFeedHeaders(iArrayIndexFeedHeaders)) & _
                             GetTranslatedString("cant_find_column_header_3") & GetRefAsString(rgTableSourceMfaInternalName) & _
                             GetTranslatedString("cant_find_column_header_4") & source_language & _
                             GetTranslatedString("cant_find_column_header_5") & vbNewLine & vbNewLine & _
                             GetTranslatedString("cant_find_column_header_6"), _
                             vbOKOnly, GetTranslatedString("cant_find_header")
                shArrayItemTemplateSheet.Parent.Close SaveChanges:=False
                SwapColumnHeaders = False
                Unload frmProgressIntTemplates
                Exit Function
            End If
        End If
        
    Next iArrayIndexFeedHeaders
    
    
    'apply number formats:
    For iArrayIndexFeedNumberFormat = 1 To iUboundFeedNumberFormats
        vItemFeedNumberFormat = vArrayFeedNumberFormats(iArrayIndexFeedNumberFormat)
        rgFeedHeaders(iArrayIndexFeedNumberFormat).EntireColumn.NumberFormat = vItemFeedNumberFormat
    Next iArrayIndexFeedNumberFormat
    
    
    'set range of column headers to the array that has been modified:
    rgFeedHeaders = vArrayFeedHeaders
    
    
    'remove columns that don't belong in this locale:
    If Not rgDeleteColumnsThisLocale Is Nothing Then
        bEnableEventsStatus = Application.EnableEvents
        Application.EnableEvents = False
        rgDeleteColumnsThisLocale.Delete
        Application.EnableEvents = bEnableEventsStatus
    End If
    
    
    'autofit, but keep columns at least as wide as original:
        'delete contents of row 1 to avoid having them affect autofit, then replace after autofit.
    Dim rgRowOne As Range
    Dim vRowOne As Variant 'must be declared as a Variant.
    Set rgRowOne = shArrayItemTemplateSheet.Rows(1)
    vRowOne = rgRowOne
    bEnableEventsStatus = Application.EnableEvents
    Application.EnableEvents = False
    rgRowOne.ClearContents
    Application.EnableEvents = bEnableEventsStatus
    For Each rgCell In rgFeedHeaders
        iFeedColumnWidth = rgCell.ColumnWidth
        rgCell.EntireColumn.AutoFit
        If iFeedColumnWidth > rgCell.ColumnWidth Then
            rgCell.ColumnWidth = iFeedColumnWidth
        End If
    Next rgCell
    rgRowOne = vRowOne


'    Call ProtectSheet(shArrayItemTemplateSheet)
    

Next iArrayIndexTemplateSheets



'delete unecessary rows in the table sheet IntMiscData:
Dim iRangeRowCount As Long
Dim iRow As Long
Dim iIndex As Long
Dim iUbound As Long
Dim iArrayItem As Long
Dim rgDeleteRows As Range
iRangeRowCount = rgTableSourceMasterName.Rows.Count
iUbound = UBound(iArrayKeepRows)
Dim bRangeStarted As Boolean
For iRow = 1 To iRangeRowCount
    bFound = False 'init for each row in range.
    
    For iIndex = 1 To iUbound
        iArrayItem = iArrayKeepRows(iIndex)
        If iRow = iArrayItem Then
            bFound = True
            Exit For
        End If
    Next iIndex
    
    If Not bFound Then
        'delete this row in range:
        If bRangeStarted Then
            Set rgDeleteRows = Union(rgDeleteRows, rgTableSourceMasterName.Rows(iRow).EntireRow)
        Else
            Set rgDeleteRows = rgTableSourceMasterName.Rows(iRow).EntireRow
            bRangeStarted = True
        End If
    End If
    
Next iRow
rgDeleteRows.Delete


SwapColumnHeaders = True

Exit Function

GenErr:

'Stop
If False Then
    Resume
End If

End Function





Function GetLocalToolbarButtonCaption(caption_master_name As String, _
                                      target_language As String, _
                                      work_sheet_table As Worksheet) As String

Dim wbWorkbook As Workbook
Dim rgTableAll As Range
Dim rgFindInRange As Range
Dim rgTableMasterName As Range
Dim rgFindMasterNameItem As Range
Dim rgTargetCaptionItem As Range

Dim iTableDataCategoryCol As Long
Dim iTableHeaderMasterNameCol As Long
Dim iTableHeaderTargetCol As Long
Dim iTableCategoryFirstRow As Long
Dim iTableCategoryLastRow As Long
Dim iFindMasterNameItemRow As Long

On Error GoTo GenErr

Set wbWorkbook = ThisWorkbook

'get whole table range:
Set rgTableAll = work_sheet_table.Range("A1").CurrentRegion

'get category, source, and target table columns:
iTableDataCategoryCol = FindColumn(work_sheet_table.Rows(INT_TABLE_HEADER_ROW), INT_TABLE_DATA_CATEGORY_HEADER)
iTableHeaderMasterNameCol = FindColumn(work_sheet_table.Rows(INT_TABLE_HEADER_ROW), INT_TABLE_MASTER_NAME_HEADER)
iTableHeaderTargetCol = FindColumn(work_sheet_table.Rows(INT_TABLE_HEADER_ROW), target_language)

'find first and last rows of column headers category in table:
Set rgFindInRange = work_sheet_table.Range(work_sheet_table.Cells(INT_TABLE_HEADER_ROW, iTableDataCategoryCol), work_sheet_table.Cells(work_sheet_table.Rows.Count, iTableDataCategoryCol))
iTableCategoryFirstRow = FindCategoryFirstRow(rgFindInRange, DATA_CATEGORY_TOOLBAR_BUTTON_CAPTIONS)
iTableCategoryLastRow = FindCategoryLastRow(rgFindInRange, DATA_CATEGORY_TOOLBAR_BUTTON_CAPTIONS)

'get master name item row:
Set rgTableMasterName = work_sheet_table.Range(work_sheet_table.Cells(iTableCategoryFirstRow, iTableHeaderMasterNameCol), work_sheet_table.Cells(iTableCategoryLastRow, iTableHeaderMasterNameCol))
Set rgFindMasterNameItem = rgTableMasterName.Find(What:=caption_master_name, LookAt:=xlWhole)
Call ResetFindParametersToDefaults
If rgFindMasterNameItem Is Nothing Then
    'not found.
    GetLocalToolbarButtonCaption = ""
    Exit Function
End If
iFindMasterNameItemRow = rgFindMasterNameItem.Row

'get target caption:
Set rgTargetCaptionItem = work_sheet_table.Range(work_sheet_table.Cells(iFindMasterNameItemRow, iTableHeaderTargetCol), work_sheet_table.Cells(iFindMasterNameItemRow, iTableHeaderTargetCol))
GetLocalToolbarButtonCaption = rgTargetCaptionItem.value

Exit Function

GenErr:

'Stop
If False Then
    Resume
End If

End Function



Public Function ApplyLocalToolbarButtonSettings(target_language As String, _
                                      work_sheet_table As Worksheet) As Boolean

Dim wbLocalWorkbook As Workbook
Dim rgSetting As Range
Dim ArrayCaptions()
Dim ArrayMasterNames()
Dim iArrayIndex As Long
Dim strCaptionDefinedNameItem As String
Dim strMasterNameItem As String

Set wbLocalWorkbook = work_sheet_table.Parent

' added 07/30/10 by atambe
If bChinaTemplate Then
    ArrayCaptions = Array(TOOLBAR_BUTTON_CAPTION_UPLOAD_DEFINED_NAME, _
                          TOOLBAR_BUTTON_CAPTION_CREDENTIALS_DEFINED_NAME, _
                          TOOLBAR_BUTTON_CAPTION_IMPORT_DEFINED_NAME, _
                          TOOLBAR_BUTTON_CAPTION_UPDATE_DEFINED_NAME)

    'need to come up with a better way than this array:
    ArrayMasterNames = Array("Upload", _
                          "Credentials", _
                          "Import", _
                          "Update")
ElseIf bDisableValidation Then
    ArrayCaptions = Array(TOOLBAR_BUTTON_CAPTION_UPLOAD_DEFINED_NAME, _
                          TOOLBAR_BUTTON_CAPTION_IMPORT_DEFINED_NAME, _
                          TOOLBAR_BUTTON_CAPTION_UPDATE_DEFINED_NAME)
    
    'need to come up with a better way than this array:
    ArrayMasterNames = Array("Upload", _
                          "Import", _
                          "Update")
Else 'changed by sunithab 09-Mar-2010 END to add credentials
    ArrayCaptions = Array(TOOLBAR_BUTTON_CAPTION_VALIDATE_DEFINED_NAME, _
                          TOOLBAR_BUTTON_CAPTION_UPLOAD_DEFINED_NAME, _
                          TOOLBAR_BUTTON_CAPTION_CREDENTIALS_DEFINED_NAME, _
                          TOOLBAR_BUTTON_CAPTION_IMPORT_DEFINED_NAME, _
                          TOOLBAR_BUTTON_CAPTION_UPDATE_DEFINED_NAME)
    
    'need to come up with a better way than this array:
    'changed by sunithab 09-Mar-2010 -- Adding credentials to toolbar tip
    ArrayMasterNames = Array("Validate", _
                          "Upload", _
                          "Credentials", _
                          "Import", _
                          "Update")
End If
'changed by sunithab 09-Mar-2010 END
 
For iArrayIndex = LBound(ArrayCaptions) To UBound(ArrayCaptions)
    strCaptionDefinedNameItem = ArrayCaptions(iArrayIndex)
    Set rgSetting = wbLocalWorkbook.Names(strCaptionDefinedNameItem).RefersToRange
    If rgSetting Is Nothing Then
        'can't find it, so skip.
    Else
        strMasterNameItem = ArrayMasterNames(iArrayIndex)
        rgSetting.value = GetLocalToolbarButtonCaption(strMasterNameItem, target_language, work_sheet_table)
    End If
Next iArrayIndex

ApplyLocalToolbarButtonSettings = True

End Function


Sub testxxx()

Dim xx As Worksheet

Set xx = ThisWorkbook.Worksheets(32)
Call ApplyLocalToolbarButtonSettings("French", xx)

End Sub


Function GetTableNumberFormatItem(array_table_number_format As Variant, array_index, array_element) As Variant

GetTableNumberFormatItem = array_table_number_format(array_index, array_element)
If Left(GetTableNumberFormatItem, 1) = "'" Then
    GetTableNumberFormatItem = Right(GetTableNumberFormatItem, Len(GetTableNumberFormatItem) - 1)
ElseIf Right(GetTableNumberFormatItem, 1) = """" And Left(GetTableNumberFormatItem, 1) = """" Then
    GetTableNumberFormatItem = Mid(GetTableNumberFormatItem, 2, Len(GetTableNumberFormatItem) - 2)
End If

End Function










Function FindColumn(find_in_range As Range, find_what As String, Optional find_alternate As String) As Long

Dim rgTemp As Range

On Error GoTo GenErr

Set rgTemp = find_in_range.Find(find_what)
Call ResetFindParametersToDefaults

If rgTemp Is Nothing Then
    Set rgTemp = find_in_range.Find(find_alternate)
    Call ResetFindParametersToDefaults
End If


FindColumn = rgTemp.Column


Exit Function

GenErr:

FindColumn = -1

End Function



Function FindCategoryFirstRow(find_in_range As Range, category_name_column_headers As String) As Long

Dim rgTemp As Range

Set rgTemp = find_in_range.Find(What:=category_name_column_headers, LookAt:=xlWhole, SearchDirection:=xlNext)
Call ResetFindParametersToDefaults
FindCategoryFirstRow = rgTemp.Row

End Function


Function FindCategoryLastRow(find_in_range As Range, category_name_column_headers As String) As Long

Dim rgTemp As Range

Set rgTemp = find_in_range.Find(What:=category_name_column_headers, LookAt:=xlWhole, SearchDirection:=xlPrevious)
Call ResetFindParametersToDefaults
FindCategoryLastRow = rgTemp.Row

End Function




Function GetRefAsString(ref_range As Range) As String

GetRefAsString = "'" & ref_range.Parent.Name & "'!" & ref_range.Address(False, False)

End Function



'Public Function GetIntItem(item_category As String, item_reference As String, language_name As String)
'
'Dim shIntData As Worksheet
'Dim rgFind As Range
'Dim rgFindInRange As Range
'Dim iDataCategoryCol As Long
'Dim iReferenceCol As Long
'Dim iLanguageCol As Long
'
'Set shIntData = ThisWorkbook.Worksheets(INT_TABLE_WORKSHEET_NAME)
'
''get column numbers:
'Set rgFind = shIntData.Rows(INT_TABLE_HEADER_ROW).Find(INT_TABLE_DATA_CATEGORY_HEADER)
'iDataCategoryCol = rgFind.Column
'Set rgFind = shIntData.Rows(INT_TABLE_HEADER_ROW).Find(INT_TABLE_REFERENCE_HEADER)
'iReferenceCol = rgFind.Column
'Set rgFind = shIntData.Rows(INT_TABLE_HEADER_ROW).Find(language_name)
'iLanguageCol = rgFind.Column
'
''find first and last rows of column headers category in table:
'Set rgFindInRange = work_sheet_table.Range(work_sheet_table.Cells(INT_TABLE_HEADER_ROW, iTableDataCategoryCol), work_sheet_table.Cells(work_sheet_table.Rows.Count, iTableDataCategoryCol))
'iTableCategoryFirstRow = FindCategoryFirstRow(rgFindInRange, DATA_CATEGORY_COLUMN_HEADERS)
'iTableCategoryLastRow = FindCategoryLastRow(rgFindInRange, DATA_CATEGORY_COLUMN_HEADERS)
'
'
'End Function



'Public Function SetTemplateFirstRowProtection( _
'                    target_workbook As Workbook, _
'                    Optional turn_on As Boolean, Optional turn_off As Boolean, _
'                    Optional toggle_status As Boolean) As Boolean
'
''usage:
''must set one, and only one, of the optional args to true. Use named args for clarity.
''if called without any of the optional args, no action will be taken.
''if more than one of the optional args is set to true, the first one wins, and the others are ignored.
'
'Dim bTurnOn As Boolean
'Dim bTurnOff As Boolean
'Dim bToggle As Boolean
'Dim shTemplate As Worksheet
'
'If turn_on Then
'    bTurnOn = True
'ElseIf turn_off Then
'    bTurnOff = True
'ElseIf toggle_status Then
'    bToggle = True
'Else
'    'no action specified:
'    Exit Function
'End If
'
'For Each shTemplate In target_workbook.Worksheets
'    If InStr(shTemplate.CodeName, "shTemplate") > 0 Then
'        If bTurnOn Then
'            '
'        ElseIf bTurnOff Then
'            '
'        Else
'            '
'        End If
'
'    End If
'Next shTemplate
'
'End Function
'
'
'
'Sub testme()
'
'Dim bRet As Boolean
'
'bRet = SetTemplateFirstRowProtection(toggle_status:=True)
'
'End Sub







Attribute VB_Name = "modMWS"
' Added for MWS integration
' Abhijit Tambe, July 2010

Option Explicit

Public securityPassword As String

'==========================================================================================
'For 64-bit compatibility.

'MSDN: Compatibility Between the 32-bit and 64-bit Versions of Office 2010:
    'http://msdn.microsoft.com/en-us/library/ee691831.aspx
'Technet: Microsoft Office Code Compatibility Inspector:
    'http://technet.microsoft.com/en-us/library/ee833946.aspx
'Samples:
    'The Microsoft file Win32_PtrSafe.txt contains 64-bit Windows API Declarations and Constants for VBA:
        'http://support.microsoft.com/kb/2030490
        'http://www.microsoft.com/downloads/en/details.aspx?FamilyID=035b72a5-eef9-4baf-8dbc-63fbd2dd982b&displaylang=en
    'http://www.jkp-ads.com/articles/apideclarations.asp
'Windows API functions that were modified/added for 64-bit Windows:
    'http://msdn.microsoft.com/en-us/library/aa383663(VS.85).aspx

'PtrSafe:
    'For Excel 2010 and later (#Vba7 = True), change "Declare" to "Declare PtrSafe".
'LongPtr:
    'For Excel 2010 and later (#Vba7 = True), change the data type of handles and pointers
    'from Long to LongPtr. Leave pointers to strings as String.
'LongLong:
    'For 64-bit Excel (#Win64 = True), change Long (except for handles and pointers!) to LongLong

#If Mac Then
    'Running on MacIntosh. Do nothing.
#ElseIf VBA7 Then
    'Excel 2010 or later:
     #If Win64 Then
        '64-bit Excel, 2010 or later:
        'Use PtrSafe, LongPtr, and LongLong:
        
            Private Declare PtrSafe Sub GetSystemTime Lib "kernel32.dll" (lpSystemTime As SYSTEMTIME)
             
            Private Type SYSTEMTIME
                wYear As Integer
                wMonth As Integer
                wDayOfWeek As Integer
                wDay As Integer
                wHour As Integer
                wMinute As Integer
                wSecond As Integer
                wMilliseconds As Integer
            End Type

     #Else
        '32-bit Excel 2010 or later:
        'Use PtrSafe and LongPtr, but NOT LongLong:

            Private Declare PtrSafe Sub GetSystemTime Lib "kernel32.dll" (lpSystemTime As SYSTEMTIME)
             
            Private Type SYSTEMTIME
                wYear As Integer
                wMonth As Integer
                wDayOfWeek As Integer
                wDay As Integer
                wHour As Integer
                wMinute As Integer
                wSecond As Integer
                wMilliseconds As Integer
            End Type
        
     #End If
#Else
    'Excel 2007 or earlier:

        Private Declare Sub GetSystemTime Lib "kernel32.dll" (lpSystemTime As SYSTEMTIME)
         
        Private Type SYSTEMTIME
            wYear As Integer
            wMonth As Integer
            wDayOfWeek As Integer
            wDay As Integer
            wHour As Integer
            wMinute As Integer
            wSecond As Integer
            wMilliseconds As Integer
        End Type

#End If

'==========================================================================================



Public Sub ResetSecurityPassword()
   securityPassword = ""
End Sub


Public Sub SetSecurityPassword(pass As String)
   securityPassword = pass
End Sub


Public Function GetSecurityPassword() As String
   GetSecurityPassword = securityPassword
End Function


' check if security password has already been entered, and prompt if not; also check to see if mws credentials are stored in the registry
Public Function CheckSecurityPassword() As Boolean
    If Not CheckCredentials Then
        Dim choice As Integer
        choice = AmazonMsgBox(GetTranslatedString("mws_credentials_required"), vbYesNo, GetTranslatedString("mws_credentials_missing"))
        If choice = vbYes Then frmCredentials.Show vbModal
    End If
    
    If CheckCredentials Then
        If securityPassword = "" Then
            frmSecurityPassword.Show vbModal
            If securityPassword = "" Then
                CheckSecurityPassword = False
                Exit Function
            End If
        End If
    Else
        CheckSecurityPassword = False
        Exit Function
    End If
    
    CheckSecurityPassword = True
End Function


' check to see if mws credentials are stored in the registry
Public Function CheckCredentials() As Boolean
    Dim credentialsArray(0 To 4) As String
    Dim i As Integer
    
    credentialsArray(0) = GetSetting("Amazon", "MWS", "Marketplace", "")
    credentialsArray(1) = GetSetting("Amazon", "MWS", "Merchant", "")
    credentialsArray(2) = GetSetting("Amazon", "MWS", "AccessKey", "")
    credentialsArray(3) = GetSetting("Amazon", "MWS", "SAK", "")
    credentialsArray(4) = GetSetting("Amazon", "MWS", "SecurityPassword", "")
    
    ' this implies that at least one credential is not in the registry
    For i = LBound(credentialsArray) To UBound(credentialsArray)
        If credentialsArray(i) = "" Then
            CheckCredentials = False
            Exit Function
        End If
    Next
        
    CheckCredentials = True
End Function


' validate the specified security password
Public Function ValidateSecurityPassword(password As String) As Boolean
    If Not CheckCredentials Then
        AmazonMsgBox GetTranslatedString("mws_credentials_invalid_missing"), vbOKOnly, GetTranslatedString("mws_credentials_invalid")
        ValidateSecurityPassword = False
        Exit Function
    End If
    
    If GetContentMD5String(password) <> GetSetting("Amazon", "MWS", "SecurityPassword", "") Then
        AmazonMsgBox GetTranslatedString("sec_pass_invalid_long"), vbOKOnly, GetTranslatedString("sec_pass_invalid")
        ValidateSecurityPassword = False
        Exit Function
    End If
    
    ValidateSecurityPassword = True
End Function


' validate the specified credentials using the mws service
Public Function ValidateCredentials(marketplaceID As String, merchantID As String, accessKeyID As String, secretAccessKey As String) As Boolean
    On Error GoTo ErrorHandler
    
    Dim sContactURL As String
    sContactURL = GetLocalURL(URL_HEADER_MWS)
    sContactURL = sContactURL & "&Action=GetFeedSubmissionCount"    ' this action will be used to check if the account exists by requesting a feed count
      
    Dim signedURL As String
    signedURL = GetSignedURL(sContactURL, marketplaceID, merchantID, accessKeyID, secretAccessKey)
    
    Dim httpreq As Object
    Dim xmldoc As Object
    
    CreateMWSRequestObject signedURL, httpreq    ' create and initialize the httpreq object
    
    Call httpreq.send
    
    CreateMWSResponseObject xmldoc, httpreq    ' create and initialize the xmldoc object
    
    If xmldoc.ChildNodes(1).BaseName = "ErrorResponse" Then
        Dim errorString As String
        errorString = xmldoc.getElementsByTagName("Code").Item(0).Text
        
        ' these parameters imply login failure
        If errorString = "InvalidAccessKeyId" Or errorString = "AccessDenied" Or errorString = "MissingClientTokenId" Or errorString = "SignatureDoesNotMatch" Or errorString = "InvalidRequest" Then
            AmazonMsgBox GetTranslatedString("mws_credentials_invalid_long"), vbOKOnly, GetTranslatedString("invalid_credentials")
            ValidateCredentials = False
            Exit Function
        End If
    End If
    
    ValidateCredentials = True
    Exit Function

ErrorHandler:
    AmazonMsgBox GetTranslatedString("internal_error_validation"), vbOKOnly, GetTranslatedString("internal_error")
    ValidateCredentials = False
End Function


' initialize the global httpreq object for mws requests
Public Sub CreateMWSRequestObject(strURL As String, Optional httpreq As Object)
    Set httpreq = Nothing
    DoEvents
    Set httpreq = Get_XMLHTTP_Object()
    'changed by sunithab; TT: 0018547747 Win-8 Compatibility
    'Call httpreq.Open(bstrmethod:="POST", bstrurl:=strURL, varAsync:=False)
    Call httpreq.Open("POST", strURL, False)
    Dim strUploadClient As String
    strUploadClient = GetTemplateWorksheet.Range("A1").value & ";" & GetLocalLanguageName & "/" & ThisWorkbook.Names("Macros_Version").RefersToRange.value
    httpreq.setRequestHeader "User-Agent", strUploadClient & " (Language=Excel/" & Application.Version & ")"
End Sub


' initialize the global xmldoc object using the mws response
Public Sub CreateMWSResponseObject(Optional xmldoc As Object, Optional httpreq As Object)
    Set xmldoc = Nothing
    DoEvents
    Set xmldoc = Get_XML_DOMDocument_Object()
    xmldoc.LoadXML (Trim(httpreq.responseText))
End Sub


' encrypt and store the specified credentials in the registry
Public Sub EncryptCredentials(marketplaceID As String, merchantID As String, accessKeyID As String, secretAccessKey As String, password As String)
    SaveSetting "Amazon", "MWS", "Marketplace", EncryptString(marketplaceID, password)
    SaveSetting "Amazon", "MWS", "Merchant", EncryptString(merchantID, password)
    SaveSetting "Amazon", "MWS", "AccessKey", EncryptString(accessKeyID, password)
    SaveSetting "Amazon", "MWS", "SAK", EncryptString(secretAccessKey, password)
    SaveSetting "Amazon", "MWS", "SecurityPassword", GetContentMD5String(password)
End Sub


' decrypt the credentials stored in the registry
Public Sub DecryptCredentials(marketplaceID As String, merchantID As String, accessKeyID As String, secretAccessKey As String, password As String)
    marketplaceID = DecryptString(GetSetting("Amazon", "MWS", "Marketplace"), password)
    merchantID = DecryptString(GetSetting("Amazon", "MWS", "Merchant"), password)
    accessKeyID = DecryptString(GetSetting("Amazon", "MWS", "AccessKey"), password)
    secretAccessKey = DecryptString(GetSetting("Amazon", "MWS", "SAK"), password)
End Sub


' calculate the Content-MD5 value of the specified file
Public Function GetContentMD5File(file As String) As String
    Dim oMD5 As MD5
    Set oMD5 = New MD5
    GetContentMD5File = Base64Encode(oMD5.DigestFileToHexStr(file))
End Function


' calculate the Content-MD5 value of the specified string
Public Function GetContentMD5String(Text As String) As String
    Dim oMD5 As MD5
    Set oMD5 = New MD5
    GetContentMD5String = Base64Encode(oMD5.DigestStrToHexStr(Text))
End Function


' get the signed url as per mws specification
Public Function GetSignedURL(strURL As String, strMarketplaceID As String, strMerchantID As String, strAccessKeyID As String, strSecretAccessKey As String) 'GJL
    'strURL must *NOT* include these parameters, which will be added to the URL returned by this function:
        'Timestamp
        'SignatureVersion
        'SignatureMethod
        'Signature
        'AWSAccessKeyId
        'Marketplace
        'Merchant
    strURL = strURL & "&Timestamp=" & GetIsoTimestamp & "&AWSAccessKeyId=" & strAccessKeyID & "&Merchant=" & strMerchantID & "&Marketplace=" & strMarketplaceID
    GetSignedURL = signEncode(strURL, strSecretAccessKey)
End Function


Private Function GetIsoTimestamp() As String
'Return an ISO 8601 compliant timestamp.
    Dim st As SYSTEMTIME
 
    'Get the local date and time.
    GetSystemTime st
    'Format the result.
    GetIsoTimestamp = _
        Format$(st.wYear, "0000") & "-" & _
        Format$(st.wMonth, "00") & "-" & _
        Format$(st.wDay, "00") & "T" & _
        Format$(st.wHour, "00") & ":" & _
        Format$(st.wMinute, "00") & ":" & _
        Format$(st.wSecond, "00") & "Z"
End Function


' modified 10/18/10 by atambe
' encode the url as per mws specification and add the Signature parameter
Function signEncode(ByVal URL As String, SKey As String) As String
    Dim http As String
    Dim i As Integer, J As Integer
    Dim tmp As String
    Dim LF As String
    Dim header As String
    Dim Signature As String
    Dim originalURL As String
    Dim PVP As Variant 'will become array, but do not declare as array.
    
    originalURL = URL
    'Encode commas and colon characters
    URL = URLClean(URL)
    
    'Split and sort your parameter/value pairs by byte value (not alphabetically, lowercase parameters will be
    'listed after uppercase ones).
    http = Left$(URL, InStr(URL, "?"))
    URL = Mid$(URL, Len(http) + 1)
    PVP = Split(URL, "&")
    For i = LBound(PVP) To UBound(PVP) - 1
        For J = i + 1 To UBound(PVP)
            If PVP(i) > PVP(J) Then
                tmp = PVP(i)
                PVP(i) = PVP(J)
                PVP(J) = tmp
            End If
        Next
    Next

    'Rejoin the sorted parameter/value list with ampersands. The result is the canonical string that we'll sign
    URL = ""
    For i = LBound(PVP) To UBound(PVP)
        If i <> UBound(PVP) Then
            URL = URL & PVP(i) & "&"
        Else
            URL = URL & PVP(i)
        End If
    Next

    'Prepend the following three lines (with line breaks) before the canonical string:
    'POST
    'mws.amazonservices.com
    '/
    LF = Chr(10)
    Dim strDomain As String
    strDomain = GetDomainFromURL(http) 'to handle mws.amazonservices.ca, mws.amazonservices.co.uk, etc.
    
    header = "POST" & LF & strDomain & LF & GetRequestURIFromURL(http) & LF     ' modified 10/18/10 by atambe
      
    'Calculate an RFC 2104-compliant HMAC with the SHA256 hash algorithm using the string above
    Signature = HMAC(header & URL, SKey)
    Signature = Replace(Signature, "=", "%3D")
    Signature = Replace(Signature, "+", "%2B")
    
    signEncode = http & URL & "&Signature=" & Signature
End Function


' calculate the hmac signature
Function HMAC(ByVal Text As String, ByVal key As String) As String
    ' make sure you change the SignatureMethod parameter in the URLs sheet in case the algorithm is changed
    Dim oSHA256 As CSHA256
    Dim i As Integer
    Dim HASH As String
    Dim arKey() As Byte
    Dim ipad As String, opad As String
    
    'HMAC(key, message) is
    'hash ((Key ^ outerpad) + hash((Key ^ innerpad) + message))
    'where + denotes concatenation, ^ denotes XOR, and outerpad and innerpad
    'are bytes 0x36 and 0x5C, respectively, repeated for the length of the
    'key, which is padded with zeros to the block size of the hash.
   
    Set oSHA256 = New CSHA256
    
    'key needs to be 64 bytes long
    ReDim arKey(0 To 63)
   
    'first hash the key if it's longer than 64 bytes
    If Len(key) > 64 Then
        HASH = oSHA256.SHA256(key)
       
        key = StringHex(HASH)
       
        For i = 0 To 63
            arKey(i) = Asc(Mid(key, i + 1, 1))
        Next
    Else
        For i = 0 To Len(key) - 1
            arKey(i) = Asc(Mid(key, i + 1, 1))
        Next
        
        'pad the key array with 0
        For i = Len(key) To 63
            arKey(i) = 0
        Next
       
    End If
    
    'generate the inner pad and outer pad strings
    ipad = ""
    opad = ""
    For i = 0 To 63
        ipad = ipad & Chr(arKey(i) Xor &H36)
        opad = opad & Chr(arKey(i) Xor &H5C)
    Next
    
    'get the hash of the inner pad and the string
    HASH = oSHA256.SHA256(ipad & Text)

    'get the hash of the outerpad and the previous hash converted to a string

    HASH = oSHA256.SHA256(opad & StringHex(HASH))
    
    'convert the final hash to a string
    HASH = StringHex(HASH)
    
    'base64 encode the hash
    HMAC = Base64Encode(HASH)
End Function


' modified 10/12/10 by atambe
Function URLClean(Text As String) As String
    'translate only the commas, colons, and spaces
    Dim i As Integer
    Dim acode As Integer
    Dim char As String

    URLClean = Text

    For i = Len(URLClean) To 1 Step -1
        acode = Asc(Mid$(URLClean, i, 1))
        Select Case acode
            ' modified 10/12/10 by atambe - added { and }
            Case 125, 123, 58, 44, 32
                'replace punctuation chars with "%hex"
                URLClean = Left$(URLClean, i - 1) & "%" & Hex$(acode) & Mid$(URLClean, i + 1)
        End Select
        If Mid$(URLClean, i, 1) = "?" Then
            Exit For
        End If
    Next

End Function


' url domain name parser
Function GetDomainFromURL(strURL As String) As String
'looks for "//", and then looks for "/" after the "//", and returns everything between.
'returns empty string on failure.

    Dim strTmp As String
    Dim iPosDoubleSlash As Long
    Dim iPosThirdSlash As Long
    
    iPosDoubleSlash = InStr(strURL, "//")
    If iPosDoubleSlash = 0 Then Exit Function 'strURL does not contain "//".
    strTmp = Right(strURL, Len(strURL) - (iPosDoubleSlash + 1))
    If Len(strURL) = iPosDoubleSlash Then Exit Function 'strURL looks like "http://".
    iPosThirdSlash = InStr(strTmp, "/")
    If iPosThirdSlash = 0 Then
        GetDomainFromURL = strTmp 'strURL looks like "http://MyDomain.com".
    Else
        GetDomainFromURL = Left(strTmp, iPosThirdSlash - 1)
    End If

End Function


' added 10/18/10 by atambe
Function GetRequestURIFromURL(strURL As String) As String
    Dim strTmp As String
    Dim requestURI As String
    Dim index As Long
    
    requestURI = "/"
    GetRequestURIFromURL = requestURI
    
    index = InStr(strURL, "//")
    If index = 0 Then Exit Function
    strTmp = Right(strURL, Len(strURL) - (index + 1))

    index = InStr(strTmp, "/")
    If index = 0 Then Exit Function
    strTmp = Right(strURL, Len(strTmp) - (index))

    index = InStr(strTmp, "?")
    If index = 0 Then Exit Function
    GetRequestURIFromURL = requestURI & Left(strTmp, index - 1)
End Function


Function StringHex(Text As String) As String
    Dim lCount 'As Long
    Dim sResult 'As String
    Dim lLength 'As Long
   
    lLength = Len(Text)
    For lCount = 1 To lLength Step 2
        sResult = sResult & Chr(Val("&H" & Mid(Text, lCount, 2)))
    Next
   
    StringHex = sResult
End Function


Public Function Base64Encode(s$) As String
    'by Nobody, 20011204
    Static Enc() As Byte
    Dim b() As Byte, Out() As Byte, i&, J&, L&
    If (Not Val(Not Enc)) = 0 Then 'Null-Ptr = not initialized
    Enc = StrConv("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", vbFromUnicode)
End If
L = Len(s): b = StrConv(s, vbFromUnicode)
ReDim Preserve b(0 To (UBound(b) \ 3) * 3 + 2)
ReDim Preserve Out(0 To (UBound(b) \ 3) * 4 + 3)
For i = 0 To UBound(b) - 1 Step 3
    Out(J) = Enc(b(i) \ 4): J = J + 1
    Out(J) = Enc((b(i + 1) \ 16) Or (b(i) And 3) * 16): J = J + 1
    Out(J) = Enc((b(i + 2) \ 64) Or (b(i + 1) And 15) * 4): J = J + 1
    Out(J) = Enc(b(i + 2) And 63): J = J + 1
Next i
For i = 1 To i - L: Out(UBound(Out) - i + 1) = 61: Next i
    Base64Encode = StrConv(Out, vbUnicode)
End Function

Attribute VB_Name = "modMaster"
Option Explicit
Option Base 1

'2009-06-24:
'This module is for code that applies only to the universal master, and can be removed from templates that it creates.

Const INT_SETTINGS_WORKBOOK_FULL_PATH_DEFINED_NAME As String = "International_Settings_Workbook_Full_Path"
Const PATH_TO_CSV_EXPORT_FOLDER_DEFINED_NAME As String = "CSV_Export_Folder"
Const UTF8_SUBFOLDER_NAME As String = "UFT8"
Const UTF16_SUBFOLDER_NAME As String = "UFT16"
Public Const IS_DEVO_DEFINED_NAME As String = "Is_Devo"




Sub Test_Regex()
'see Test_Regex_Range below to test a group of values.

Dim strText As String
Dim strPattern As String
Dim bRet As Boolean


strText = "13.5"


'strPattern = "^((1[0-4]|2[0-9]|3[0-7)\.?\d{0,2}|38\.0{0,2})$"


'strPattern = RegexPatternEnforceExactMatch(strPattern)
bRet = RegexTest(strPattern, strText)

Debug.Print bRet

End Sub


Sub Test_Regex_Range()
'tests all values in the selected range in the active worksheet.

Dim strText As String
Dim strPattern As String
Dim bRet As Boolean
Dim rgCell As Range

strPattern = "^(15.5[0-9]?|15.[6-9][0-9]?|(1[6-9]|2[0-1])\.?\d{0,2}|22|22\.0{0,2})$"


For Each rgCell In Selection.Cells
    strText = rgCell.Text
    bRet = RegexTest(strPattern, strText)
    
    
    '* * * CHOOSE ONE OR BOTH * * * :
    Debug.Print strText, bRet
'    rgCell.Offset(ColumnOffset:=1).Value = bRet
    
    
Next rgCell

End Sub





Sub SplitOutKeysheets()
Dim wb As Workbook
Dim strWorkbookPath As String
Dim strWorkbookName As String
Dim strWorkbookNameUcase As String
Dim strSheetName As String
Dim strSheetNameUcase As String
Dim strLocale As String
Dim strProductTypeName As String
Dim ws As Worksheet
Dim wbKeysheetWorkbook As Workbook
Dim wbActivateAfterErrTemplateSheetVBA As Workbook
Dim wbTmp As Workbook
Dim rgTmp As Range
Dim bErrTemplateSheetVBA
Dim bFileNotSaved As Boolean

strWorkbookPath = Application.GetOpenFilename(, , "Please browse to workbook for which to split out keysheets...")
If strWorkbookPath = "False" Then
    'user clicked Cancel:
'    MsgBox "Operation has been cancelled.", vbOKOnly, "Split out Keysheets"
    AmazonMsgBox "Operation has been cancelled.", vbOKOnly, "Split out Keysheets"
    Exit Sub
End If

Set wb = Workbooks.Open(strWorkbookPath, UpdateLinks:=0) '0 = do not update links.
DoEvents
wb.Activate
DoEvents

strWorkbookName = wb.Name
strWorkbookNameUcase = UCase(strWorkbookName)

Set wbTmp = Workbooks.Add
Set rgTmp = wbTmp.Worksheets(1).Range("A1")

'get locale abbreviation:
If InStr(strWorkbookNameUcase, ".CA.") > 0 Or InStr(strWorkbookNameUcase, ".CA_WO_MACRO") > 0 Then
    strLocale = "CA"
ElseIf InStr(strWorkbookNameUcase, ".UK.") > 0 Or InStr(strWorkbookNameUcase, ".UK_WO_MACRO") > 0 Then
    strLocale = "UK"
ElseIf InStr(strWorkbookNameUcase, ".DE.") > 0 Or InStr(strWorkbookNameUcase, ".DE_WO_MACRO") > 0 Then
    strLocale = "DE"
ElseIf InStr(strWorkbookNameUcase, ".FR.") > 0 Or InStr(strWorkbookNameUcase, ".FR_WO_MACRO") > 0 Then
    strLocale = "FR"
ElseIf InStr(strWorkbookNameUcase, ".JP.") > 0 Or InStr(strWorkbookNameUcase, ".JP_WO_MACRO") > 0 Then
    strLocale = "JP"
ElseIf InStr(strWorkbookNameUcase, ".CE.") > 0 Or InStr(strWorkbookNameUcase, ".CE_WO_MACRO") > 0 Then
    strLocale = "CE"
Else
    strLocale = "NA"
End If

'get product type name:
Dim iFirstPeriodPos As Long
Dim iSecondPeriodPos As Long
Dim iThirdPeriodPos As Long
iFirstPeriodPos = InStr(strWorkbookName, ".")
iSecondPeriodPos = InStr(iFirstPeriodPos + 1, strWorkbookName, ".")
iThirdPeriodPos = InStr(iSecondPeriodPos + 1, strWorkbookName, ".")
If iThirdPeriodPos = 0 Then
    'can't get product type name:
    strProductTypeName = "ProductType"
Else
    Dim iStartPos As Long
    Dim iLen As Long
    iStartPos = iSecondPeriodPos + 1
    iLen = iThirdPeriodPos - iStartPos
    strProductTypeName = Mid(strWorkbookName, iStartPos, iLen)
End If



For Each ws In wb.Worksheets
    If ws.Visible Then
    
        ws.Activate
        DoEvents
        
        Dim strSheetTypeAbbr As String
        Dim strFilename As String
        Dim strPath As String
        
        strSheetName = ws.Name
        strSheetNameUcase = UCase(strSheetName)

        If InStr(strSheetNameUcase, "TEMPLATE") > 0 Then
            strSheetTypeAbbr = "Template"
                ElseIf InStr(strWorkbookNameUcase, "." & strSheetNameUcase & ".") > 0 Then
                    'for example, if the sheet name is like "Home" for a file named like "Flat.File.Home.de.xls":
                    strSheetTypeAbbr = "Template"
        ElseIf InStr(strSheetNameUcase, "EXAMPL") > 0 Then
            strSheetTypeAbbr = "Example"
                ElseIf InStr(strSheetNameUcase, "EXEMPL") > 0 Then
                    strSheetTypeAbbr = "Example"
        ElseIf InStr(strSheetNameUcase, "INSTRU") > 0 Then
            strSheetTypeAbbr = "Inst"
                ElseIf InStr(strSheetNameUcase, "ANWEISUN") > 0 Then
                    strSheetTypeAbbr = "Inst"
        ElseIf InStr(strSheetNameUcase, "IMAGE") > 0 Then
            strSheetTypeAbbr = "Img"
                ElseIf InStr(strSheetNameUcase, "BILD") > 0 Then
                    strSheetTypeAbbr = "Img"
        ElseIf InStr(strSheetNameUcase, "VALID") > 0 Then
            strSheetTypeAbbr = "VV"
                ElseIf InStr(strSheetNameUcase, "WERT") > 0 Then
                    strSheetTypeAbbr = "VV"
        ElseIf InStr(strSheetNameUcase, "DEFIN") > 0 Then
            strSheetTypeAbbr = "Ddef"
                ElseIf InStr(strSheetNameUcase, "D|fffd|FIN") > 0 Then
                    strSheetTypeAbbr = "Ddef"
        Else
            strSheetTypeAbbr = ws.Name
        End If
    
        'build workbookname:
        strFilename = strProductTypeName & "." & strLocale & "." & strSheetTypeAbbr & ".xls"
        
        
        'ask user whether to split out or to use generic:
        Dim iRet As Long
'        iRet = MsgBox("Split out " & strSheetName & " Keysheet?" & _
                      vbNewLine & vbNewLine & _
                      "To use Generic Keysheet instead, click No.", _
                      vbQuestion + vbYesNo, "Split out Keysheets")
        iRet = AmazonMsgBox("Split out " & strSheetName & " Keysheet?" & _
                            vbNewLine & vbNewLine & _
                            "To use Generic Keysheet instead, click No.", _
                            vbYesNo, "Split out Keysheets")
        If iRet = vbYes Then
        
            bErrTemplateSheetVBA = False 'init.
            On Error GoTo ErrTemplateSheetVBA
            If Not ws Is ActiveSheet Then ws.Activate
            DoEvents
            ws.Unprotect
            DoEvents
            ws.Copy
            DoEvents
            
            If bErrTemplateSheetVBA Then
'                MsgBox "An error occured splitting out the """ & strSheetName & """ sheet." & _
                    vbNewLine & vbNewLine & _
                    "The """ & strSheetName & """ sheet probably has VBA macros behind it. Those macros must be deleted. " & _
                    "When done, please delete the VBA code behind the """ & strSheetName & _
                    """ sheet, then save and close the file.", _
                    vbCritical + vbOKOnly, "Error splitting out """ & strSheetName & """ Keysheet."
                AmazonMsgBox "An error occured splitting out the """ & strSheetName & """ sheet." & _
                    vbNewLine & vbNewLine & _
                    "The """ & strSheetName & """ sheet probably has VBA macros behind it. Those macros must be deleted. " & _
                    "When done, please delete the VBA code behind the """ & strSheetName & _
                    """ sheet, then save and close the file.", _
                    vbOKOnly, "Error splitting out """ & strSheetName & """ Keysheet."
                Set wbActivateAfterErrTemplateSheetVBA = ActiveWorkbook
            Else
    
                Set wbKeysheetWorkbook = Workbooks(Workbooks.Count) 'ActiveWorkbook
    
                If wbKeysheetWorkbook.Name = wb.Name Then
'                    MsgBox "An error occured. Operation has been cancelled.", vbOKOnly, "Split out Keysheets"
                    AmazonMsgBox "An error occured. Operation has been cancelled.", vbOKOnly, "Split out Keysheets"
                    Exit Sub 'error occured, so don't delete names in master.
                    wbTmp.Close SaveChanges:=False
                End If
                
                
                
                'If Excel 2003 or earlier, copying sheet to new workbook truncates cell text to 255 characters.
                'must copy/paste to fix:
                If Val(Application.Version) <= 11 Then
                    'this is Excel 2003 or earlier. Fix cell text truncation:
                    'wbKeysheetWorkbook is dest sheet.
                    'ws is source sheet.
                    Dim strUsedRangeAddress As String
                    strUsedRangeAddress = ws.UsedRange.Address
                    ws.Range(strUsedRangeAddress).Copy Destination:=wbKeysheetWorkbook.Worksheets(1).Range(strUsedRangeAddress)
                End If
                
                
                
                Dim nm As Name
                For Each nm In wbKeysheetWorkbook.Names
                    nm.Delete
                Next nm
                
                DoEvents
                'In Excel 2007 and later, the extension of InitialFileName must match the final filetype extension in FileFilter, or else InitialFileName will be blank:
                strPath = Application.GetSaveAsFilename(InitialFileName:=strFilename, FileFilter:="Excel Files (*.xlsx;*.xlsm;*.xls), *.xlsx;*.xlsm;*.xls", title:="Save the Keysheet workbook with the " & strSheetName & " sheet...")

                
                If strPath = "False" Then
                    'user clicked Cancel:
'                    iRet = MsgBox("File not saved. Do you want to continue with other sheets?", vbQuestion + vbYesNo, "Split out Keysheets")
                    iRet = AmazonMsgBox("File not saved. Do you want to continue with other sheets?", vbYesNo, "Split out Keysheets")
                    If iRet = vbNo Then
                        wbTmp.Close SaveChanges:=False
                        Exit Sub
                    End If
                    bFileNotSaved = True
                Else
                    Dim iFileFormat As Long
                    If Val(Application.Version) <= 11 Then
                        'Excel 2003 or earlier:
                        iFileFormat = xlNormal
                    Else
                        'Excel 2007 or later:
                        iFileFormat = 56 'xlExcel8
                    End If
                    wbKeysheetWorkbook.SaveAs FileName:=strPath, FileFormat:=iFileFormat
                    strFilename = wbKeysheetWorkbook.Name
                    bFileNotSaved = False
                End If
                    
                wbKeysheetWorkbook.Close SaveChanges:=False
            
            End If
        Else
            bFileNotSaved = True 'user chose to use Generic.
            
        End If
        
    
        'populate tmp sheet with keysheet workbook names list, for pasting into startkeys:
        If bFileNotSaved = True Then
            'use generic:
            strFilename = "Generic." & strLocale & "." & strSheetTypeAbbr & ".xls"
        End If
        rgTmp.value = strFilename
        rgTmp.EntireColumn.AutoFit
        wbTmp.Activate
        wbTmp.Worksheets(1).Range("A1").Resize(rgTmp.Row, 1).Select
        Set rgTmp = rgTmp.Offset(RowOffset:=1)
        
        
    End If
Next ws

wb.Close SaveChanges:=False

If Not wbActivateAfterErrTemplateSheetVBA Is Nothing Then
    wbActivateAfterErrTemplateSheetVBA.Activate
    DoEvents
'    MsgBox "Done splitting out sheets. Please delete VBA code in remaining sheets and save them.", vbOKOnly, "Split out Keysheets"
    AmazonMsgBox "Done splitting out sheets. Please delete VBA code in remaining sheets and save them.", vbOKOnly, "Split out Keysheets"
Else
'    MsgBox "Done splitting out sheets.", vbOKOnly, "Split out Keysheets"
    AmazonMsgBox "Done splitting out sheets.", vbOKOnly, "Split out Keysheets"
End If


Exit Sub
If False Then
    Resume
End If

ErrTemplateSheetVBA:
bErrTemplateSheetVBA = True
If False Then
    Resume
End If
Resume Next

End Sub



Sub SetAsReleaseCandidates()

Dim strWorkbookPath As String
Dim bRet As Boolean
Dim bAllSuccess As Boolean
Dim iRet As Long
Dim bEnableEventsStatus As Boolean

On Error GoTo GenErr

bEnableEventsStatus = GetEnableEventsStatusAndTurnItOff
bAllSuccess = True 'init; set to false on any failure.

strWorkbookPath = Application.GetOpenFilename(, , "Please browse to workbook to set as a Release Candidate...")
If strWorkbookPath = "False" Then
    'user clicked Cancel:
'    MsgBox "Operation has been cancelled.", vbOKOnly, "Set as Release Candidates"
    AmazonMsgBox "Operation has been cancelled.", vbOKOnly, "Set as Release Candidates"
    Exit Sub
End If

'check whether user wants to do whole directory:
'iRet = MsgBox("Do you want to set all workbooks in that folder as release candidates?", vbQuestion + vbYesNo, "Set as Release Candidates")
iRet = AmazonMsgBox("Do you want to set all workbooks in that folder as release candidates?", vbYesNo, "Set as Release Candidates")
If iRet = vbYes Then
    Dim fso As Object
    Dim oFile As Object
    Dim oFolder As Object
    Set fso = CreateObject("Scripting.FileSystemObject")
    Set oFile = fso.GetFile(strWorkbookPath)
    Set oFolder = fso.GetFolder(oFile.ParentFolder)
    For Each oFile In oFolder.Files
        bRet = SetOneReleaseCandidate(oFile.Path)
        If Not bRet Then
'            iRet = MsgBox(oFile.Name & " not successfully set as Release Candidate. Continue?", vbCritical + vbYesNo, "Set as Release Candidates")
            iRet = AmazonMsgBox(oFile.Name & " not successfully set as Release Candidate. Continue?", vbYesNo, "Set as Release Candidates")
        End If
    Next oFile
Else
    bRet = SetOneReleaseCandidate(strWorkbookPath)
    bAllSuccess = False
'    If Not bRet Then MsgBox oFile.Name & " not successfully set as Release Candidate.", vbCritical, "Set as Release Candidates"
    If Not bRet Then AmazonMsgBox oFile.Name & " not successfully set as Release Candidate.", vbOKOnly, "Set as Release Candidates"
End If



'check to make sure they were all successfully set:
If iRet = vbYes Then
    If bAllSuccess Then
        'check each one:
        For Each oFile In oFolder.Files
            DoEvents
            bRet = CheckOneReleaseCandidate(oFile.Path)
            If Not bRet Then bAllSuccess = False
            Exit For
        Next oFile
    End If
Else
    bAllSuccess = CheckOneReleaseCandidate(strWorkbookPath)
End If

If bAllSuccess Then
'    MsgBox "Templates successfully set as Release Candidates.", vbInformation + vbOKOnly, "Set as Release Candidates"
    AmazonMsgBox "Templates successfully set as Release Candidates.", vbOKOnly, "Set as Release Candidates"
Else
'    MsgBox "STOP! Templates NOT successfully set as Release Candidates!", vbCritical + vbOKOnly, "Set as Release Candidates"
    AmazonMsgBox "STOP! Templates NOT successfully set as Release Candidates!", vbOKOnly, "Set as Release Candidates"
End If





Application.EnableEvents = bEnableEventsStatus

Exit Sub
GenErr:

If False Then
    Resume
End If

Application.EnableEvents = bEnableEventsStatus

Application.StatusBar = False

End Sub




Function CheckOneReleaseCandidate(full_path As String) As Boolean

'checks only by defined names, not by cell addresses.

Dim wb As Workbook
Dim rg As Range

Set wb = Workbooks.Open(full_path, UpdateLinks:=0) '0 = do not update links.

Set rg = wb.Names("Versioned_Override_Misc_Data_Table_URL").RefersToRange
If rg.value <> "" Then
    CheckOneReleaseCandidate = False
    Exit Function
End If

Set rg = wb.Names("Versioned_Override_Data_Validation_Table_URL").RefersToRange
If rg.value <> "" Then
    CheckOneReleaseCandidate = False
    Exit Function
End If

Set rg = wb.Names("Versioned_Override_Dropdown_Lists_Table_URL").RefersToRange
If rg.value <> "" Then
    CheckOneReleaseCandidate = False
    Exit Function
End If

Set rg = wb.Names("Devo_Upload_URL").RefersToRange
If rg.value <> "" Then
    CheckOneReleaseCandidate = False
    Exit Function
End If

Set rg = wb.Names(IS_DEVO_DEFINED_NAME).RefersToRange
If rg.value <> False Then
    CheckOneReleaseCandidate = False
    Exit Function
End If

If wb.Worksheets("International Settings").Visible Then
    CheckOneReleaseCandidate = False
    Exit Function
End If

wb.Close SaveChanges:=False
DoEvents

Application.StatusBar = False

CheckOneReleaseCandidate = True

End Function


Function SetOneReleaseCandidate(full_path As String) As Boolean

'returns true on success.

Dim wb As Workbook
Dim rg As Range
Dim bRet As Boolean
Dim bAllSuccess As Boolean

Application.StatusBar = "Checking " & full_path & "..."

bAllSuccess = True 'init.

Application.StatusBar = "Opening " & full_path & "..."
Set wb = Workbooks.Open(full_path, UpdateLinks:=0) '0 = do not update links.
Application.StatusBar = "Setting " & full_path & " to Release Candidate..."

'set versioned overrides and devo upload url to blank cells:
bRet = DeleteCellContentsByDefinedNameOrAddress(wb, "Versioned_Override_Misc_Data_Table_URL", "International Settings", "A15")
If Not bRet Then bAllSuccess = False
bRet = DeleteCellContentsByDefinedNameOrAddress(wb, "Versioned_Override_Data_Validation_Table_URL", "International Settings", "A16")
If Not bRet Then bAllSuccess = False
bRet = DeleteCellContentsByDefinedNameOrAddress(wb, "Versioned_Override_Dropdown_Lists_Table_URL", "International Settings", "A17")
If Not bRet Then bAllSuccess = False
bRet = DeleteCellContentsByDefinedNameOrAddress(wb, "Devo_Upload_URL", "International Settings", "A22")
If Not bRet Then bAllSuccess = False

'set is_devo to false:
Dim nm As Name
Dim bFound As Boolean
bFound = False 'init.
For Each nm In wb.Names
    If nm.Name = IS_DEVO_DEFINED_NAME Then
        bFound = True
        Exit For
    End If
Next nm
If bFound Then
    wb.Names(IS_DEVO_DEFINED_NAME).RefersToRange.value = "FALSE"
Else
    wb.Worksheets("International Settings").Range("A21").value = "FALSE"
End If

'hide int settings sheet:
wb.Worksheets("International Settings").Visible = False

Application.StatusBar = "Saving changes to " & full_path & "..."
wb.Close SaveChanges:=True
DoEvents

SetOneReleaseCandidate = bAllSuccess

Application.StatusBar = False

End Function



Function RemoveTagsFromFilenames()

Dim strWorkbookPath As String
Dim bRet As Boolean
Dim bAllSuccess As Boolean
Dim iRet As Long
Dim bEnableEventsStatus As Boolean

On Error GoTo GenErr

bEnableEventsStatus = GetEnableEventsStatusAndTurnItOff
bAllSuccess = True 'init; set to false on any failure.

strWorkbookPath = Application.GetOpenFilename(, , "Please browse to workbook to remove parens from filename...")
If strWorkbookPath = "False" Then
    'user clicked Cancel:
'    MsgBox "Operation has been cancelled.", vbOKOnly, "Remove Parens from Filenames"
    AmazonMsgBox "Operation has been cancelled.", vbOKOnly, "Remove Parens from Filenames"
    Exit Function
End If

'check whether user wants to do whole directory:
'iRet = MsgBox("Do you want to do all workbooks in that folder?", vbQuestion + vbYesNo, "Remove Parens from Filenames")
iRet = AmazonMsgBox("Do you want to do all workbooks in that folder?", vbYesNo, "Remove Parens from Filenames")
If iRet = vbYes Then
    Dim fso As Object
    Dim oFile As Object
    Dim oFolder As Object
    Set fso = CreateObject("Scripting.FileSystemObject")
    Set oFile = fso.GetFile(strWorkbookPath)
    Set oFolder = fso.GetFolder(oFile.ParentFolder)
    For Each oFile In oFolder.Files
        bRet = RemoveTagsFromOneFilename(oFile.Path)
        If Not bRet Then
'            iRet = MsgBox("Unable to remove parens from filename of " & oFile.Name & ". Continue?", vbCritical + vbYesNo, "Remove Parens from Filenames")
            iRet = AmazonMsgBox("Unable to remove parens from filename of " & oFile.Name & ". Continue?", vbYesNo, "Remove Parens from Filenames")
        End If
    Next oFile
Else
    bRet = RemoveTagsFromOneFilename(strWorkbookPath)
    bAllSuccess = False
'    If Not bRet Then MsgBox "Unable to remove parens from filename of " & oFile.Name & ".", vbCritical, "Remove Parens from Filenames"
    If Not bRet Then AmazonMsgBox "Unable to remove parens from filename of " & oFile.Name & ".", vbOKOnly, "Remove Parens from Filenames"
End If



'MsgBox "Done.", vbInformation + vbOKOnly, "Remove Parens from Filenames"
AmazonMsgBox "Done.", vbOKOnly, "Remove Parens from Filenames"



Application.EnableEvents = bEnableEventsStatus

Exit Function
GenErr:

If False Then
    Resume
End If

Resume Next 'errors called out inline.

Application.EnableEvents = bEnableEventsStatus

Application.StatusBar = False

End Function



Function RemoveTagsFromOneFilename(full_path As String) As Boolean
On Error GoTo GenErr
Dim fso As Object
Dim oFile As Object
Dim strFilename As String
Dim strTemp As String
Dim strTempPrev As String
Dim oFolder As Object
Dim voRegex As Variant 'IRegExp2
Set fso = CreateObject("Scripting.FileSystemObject")
Set oFile = fso.GetFile(full_path)
strFilename = oFile.Name

Set voRegex = CreateObject("VBScript.RegExp")

'remove sets of parens with all contents:
voRegex.Pattern = "\(.*?\)"  '(*)
strTemp = strFilename
strTempPrev = strFilename
Do
    strTemp = voRegex.Replace(strTemp, "")
    If strTemp = strTempPrev Then Exit Do
    strTempPrev = strTemp
Loop

'remove doubled periods resulting from removing sets of parens:
voRegex.Pattern = "\.\."  '..
Do
    strTemp = voRegex.Replace(strTemp, ".")
    If strTemp = strTempPrev Then Exit Do
    strTempPrev = strTemp
Loop

'if "._wo_macro" exists, remove the period:
strTemp = Replace(strTemp, "._wo_macro", "_wo_macro")

'rename file:
oFile.Name = strTemp
DoEvents

RemoveTagsFromOneFilename = True

Exit Function
GenErr:
If InStr(UCase(Err.Description), "FILE ALREADY EXISTS") > 0 Then
    MsgBox Err.Description & ":  " & strTemp & vbNewLine & vbNewLine & "Cannot remove the filename tags."
ElseIf InStr(UCase(Err.Description), "PERMISSION DENIED") > 0 Then
    MsgBox Err.Description & ":  " & strTemp & vbNewLine & vbNewLine & "Cannot remove the filename tags."
End If
If False Then
    Resume
End If
End Function



Function DeleteCellContentsByDefinedNameOrAddress(work_book As Workbook, defined_name As String, Optional sheet_name As String, Optional cell_address As String)

'returns true on success.

Dim rg As Range
Dim nm As Name
Dim bFound As Boolean

bFound = False 'init.
For Each nm In work_book.Names
    If nm.Name = defined_name Then
        bFound = True
        Exit For
    End If
Next nm

If bFound Then
    work_book.Names(defined_name).RefersToRange.ClearContents
    DeleteCellContentsByDefinedNameOrAddress = True
Else
    If cell_address <> "" Then
        Set rg = work_book.Worksheets(sheet_name).Range(cell_address)
        rg.ClearContents
        DeleteCellContentsByDefinedNameOrAddress = True
    End If
End If

End Function




Sub ExportValidationCellCommentListsToBeTranslated()

'not ready to use!!
'need to work on issues with calling ValidateTemplate.
'until then, use ExportValidationCellCommentListToBeTranslated.


Dim strWorkbookPath As String
Dim bRet As Boolean
Dim bAllSuccess As Boolean
Dim iRet As Long
Dim bEnableEventsStatus As Boolean

On Error GoTo GenErr

If Val(Application.Version) < 12 Then
'    iRet = MsgBox("For best formatting in the results, run this in Excel 2007 or later. " & _
                  "However, it will work correctly in Excel 2003." & _
                  vbNewLine & vbNewLine & _
                  "Proceed with creating validation translation lists in Excel 2003?", _
                  vbQuestion + vbYesNo, "Create Validation Translation Lists")
    iRet = AmazonMsgBox("For best formatting in the results, run this in Excel 2007 or later. " & _
                        "However, it will work correctly in Excel 2003." & _
                        vbNewLine & vbNewLine & _
                        "Proceed with creating validation translation lists in Excel 2003?", _
                        vbYesNo, "Create Validation Translation Lists")
    If iRet = vbNo Then Exit Sub
End If

'iRet = MsgBox("You must run Update Template (or create new templates) right before running this, because any discrepancy between" & _
              " the current validation rules table and these workbooks' validation rules tables will result" & _
              " in incorrect lists of translations needed." & _
              vbNewLine & vbNewLine & _
              "Do you want to proceed with making the lists of translations needed?", _
              vbQuestion + vbYesNo, "Did you run Update Template first?")
iRet = AmazonMsgBox("You must run Update Template (or create new templates) right before running this, because any discrepancy between" & _
                    " the current validation rules table and these workbooks' validation rules tables will result" & _
                    " in incorrect lists of translations needed." & _
                    vbNewLine & vbNewLine & _
                    "Do you want to proceed with making the lists of translations needed?", _
                    vbYesNo, "Did you run Update Template first?")
If iRet = vbNo Then Exit Sub

bEnableEventsStatus = GetEnableEventsStatusAndTurnItOff
bAllSuccess = True 'init; set to false on any failure.

strWorkbookPath = Application.GetOpenFilename(, , "Please browse to a workbook for which to create a validation translation list...")
If strWorkbookPath = "False" Then
    'user clicked Cancel:
'    MsgBox "Operation has been cancelled.", vbOKOnly, "Create Validation Translation Lists"
    AmazonMsgBox "Operation has been cancelled.", vbOKOnly, "Create Validation Translation Lists"
    Exit Sub
End If

'check whether user wants to do whole directory:
'iRet = MsgBox("Do you want to create validation translation lists for all workbooks in that folder?", vbQuestion + vbYesNo, "Create Validation Translation Lists")
iRet = AmazonMsgBox("Do you want to create validation translation lists for all workbooks in that folder?", vbYesNo, "Create Validation Translation Lists")
If iRet = vbYes Then
    Dim fso As Object
    Dim oFile As Object
    Dim oFolder As Object
    Set fso = CreateObject("Scripting.FileSystemObject")
    Set oFile = fso.GetFile(strWorkbookPath)
    Set oFolder = fso.GetFolder(oFile.ParentFolder)
    For Each oFile In oFolder.Files
        bRet = ExportOneValidationCellCommentListToBeTranslated(oFile.Path)
        If Not bRet Then
'            iRet = MsgBox(oFile.Name & " not successfully set as Release Candidate. Continue?", vbCritical + vbYesNo, "Create Validation Translation Lists")
            iRet = AmazonMsgBox(oFile.Name & " not successfully set as Release Candidate. Continue?", vbYesNo, "Create Validation Translation Lists")
        End If
    Next oFile
Else
    bRet = SetOneReleaseCandidate(strWorkbookPath)
    bAllSuccess = False
'    If Not bRet Then MsgBox oFile.Name & " not successfully set as Release Candidate.", vbCritical, "Create Validation Translation Lists"
    If Not bRet Then AmazonMsgBox oFile.Name & " not successfully set as Release Candidate.", vbOKOnly, "Create Validation Translation Lists"
End If



'check to make sure they were all successfully set:
If iRet = vbYes Then
    If bAllSuccess Then
        'check each one:
        For Each oFile In oFolder.Files
            DoEvents
            bRet = CheckOneReleaseCandidate(oFile.Path)
            If Not bRet Then bAllSuccess = False
            Exit For
        Next oFile
    End If
Else
    bAllSuccess = CheckOneReleaseCandidate(strWorkbookPath)
End If

If bAllSuccess Then
'    MsgBox "Templates successfully Create Validation Translation Lists.", vbInformation + vbOKOnly, "Create Validation Translation Lists"
    AmazonMsgBox "Templates successfully Create Validation Translation Lists.", vbOKOnly, "Create Validation Translation Lists"
Else
'    MsgBox "STOP! Templates NOT successfully Create Validation Translation Lists!", vbCritical + vbOKOnly, "Create Validation Translation Lists"
    AmazonMsgBox "STOP! Templates NOT successfully Create Validation Translation Lists!", vbOKOnly, "Create Validation Translation Lists"
End If





Application.EnableEvents = bEnableEventsStatus

Exit Sub
GenErr:

If False Then
    Resume
End If

Application.EnableEvents = bEnableEventsStatus

Application.StatusBar = False

End Sub





Public Function ExportOneValidationCellCommentListToBeTranslated(full_path As String) As Boolean

'not ready to use!!
'need to work on issues with calling ValidateTemplate.
'until then, use ExportValidationCellCommentListToBeTranslated (below).



'Press F5 here to run.

'exports list of validation cell comments in column B, with
'english versions where applicable in column a,
'that apply to a given category and given locale.

'calls into main validation function.

Dim wbValidation As Workbook
Dim shValidation As Worksheet
Dim bFound As Boolean

Dim iRet As Long


'===================================================================================
'data validation table worksheet:
bFound = False
For Each wbValidation In Application.Workbooks
    If wbValidation.Name = "InternationalSettings.xlsm" Then
        bFound = True
        Exit For
    End If
Next wbValidation
If Not bFound Then
    Dim strOpenPath As String
    strOpenPath = Application.GetOpenFilename(, , GetTranslatedString("browse_to_data_validation"))
    Set wbValidation = Workbooks.Open(strOpenPath, UpdateLinks:=0) '0 = do not update links.
End If
Set shValidation = wbValidation.Worksheets("IntDataValidation")
'===================================================================================

Dim vRows As Variant
Dim rgValidateColumnCol As Range
Dim rgValidateItemLanguageCol As Range
Dim iUboundArrayRows As Long
Dim iArrayIndex As Long
Dim iArrayRow As Long
Dim bRet As Boolean
Dim strLanguage As String
Dim strValidateItem As String
Dim strErrorTextEnglish As String
Dim strErrorTextLocal As String
Dim strTemplateDependencyTest As String
Dim strRequiredColumn As String
Dim strReqColTest As String
Dim strValidateColumn As String
Dim strValColTest As String
Dim rgFind As Range
Dim iFirstItemRow As Long
Dim iLastItemRow As Long

Dim ArrayEnglish() As Long
Dim iArrayEnglishIndex As Long
Dim iArrayEnglishRow As Long
Dim iUboundEnglish As Long
Dim iLboundEnglish As Long


Const TEMPLATE_DEPENDENCY_TEST_COL As Long = 1
Const REQUIRED_COLUMN_COL As Long = 2
Const REQUIRED_COLUMN_TEST_COL As Long = 3
Const VALIDATE_COLUMN_COL As Long = 4
Const VALIDATE_COLUMN_TEST_COL As Long = 5
Const VALIDATE_COLUMN_LANGUAGE_COL As Long = 6
Const VALIDATE_COLUMN_ERROR_TEXT_COL As Long = 7
Const ARRAY_ROWS_DIMENSION As Long = 2
Const ARRAY_LOCAL_COL As Long = 1
Const ARRAY_ENGLISH_COL As Long = 2
Const ARRAY_TEMPLATE_DEP_TEST_COL As Long = 3
Const ARRAY_REQUIRED_COLUMN_COL As Long = 4
Const ARRAY_REQ_COL_TEST_COL As Long = 5
Const ARRAY_VALIDATE_COLUMN_COL As Long = 6
Const ARRAY_VAL_COL_TEST_COL As Long = 7

Const TEMPLATE_COL As Long = 1
Const REQ_COL As Long = 2
Const REQTEST_COL As Long = 3
Const VALTEST_COL As Long = 5
Const LANGUAGE_COL As Long = 6
Const ERRORTEXT_COL As Long = 7
Const ENGLISH_USA As String = "English USA"

Set rgValidateColumnCol = shValidation.Columns(VALIDATE_COLUMN_COL)


'bRet = ValidateTemplate(, vRows)  'ByRef. commented out 2009-06-23.
bRet = ValidateTemplate(, vRows, , , True, True, True, shValidation, True) 'ByRef. '2009-06-23.
iUboundArrayRows = UBound(vRows, ARRAY_ROWS_DIMENSION)
If iUboundArrayRows = 0 Then
'    MsgBox "Cannot proceed because there was nothing to validate." & _
            vbNewLine & vbNewLine & _
            "Enter a character in the first data row of the first column of the template sheet, and try again.", _
            vbCritical + vbOKOnly, "Cannot Create List"
    AmazonMsgBox GetTranslatedString("cannot_proceed_1") & _
                 vbNewLine & vbNewLine & _
                 GetTranslatedString("cannot_proceed_2"), _
                 vbOKOnly, GetTranslatedString("cannot_create_list")
    Exit Function
End If

strLanguage = GetLocalLanguageName() 'Don't run this proc from the master.
                                     'Even changing strLanguage won't work.
                                     'Need to run from localized version.

For iArrayIndex = 1 To iUboundArrayRows
    'loop through each row in the validation table that was processed for this template:
    iArrayRow = vRows(ARRAY_LOCAL_COL, iArrayIndex)
    strErrorTextLocal = shValidation.Cells(iArrayRow, VALIDATE_COLUMN_ERROR_TEXT_COL)
    
    strTemplateDependencyTest = shValidation.Cells(iArrayRow, TEMPLATE_DEPENDENCY_TEST_COL)
    strRequiredColumn = shValidation.Cells(iArrayRow, REQUIRED_COLUMN_COL)
    strReqColTest = shValidation.Cells(iArrayRow, REQUIRED_COLUMN_TEST_COL)
    strValidateColumn = shValidation.Cells(iArrayRow, VALIDATE_COLUMN_COL)
    strValColTest = shValidation.Cells(iArrayRow, VALIDATE_COLUMN_TEST_COL)
    
    'find top and bottom rows of that validation column item:
    strValidateItem = shValidation.Cells(iArrayRow, VALIDATE_COLUMN_COL)
    Set rgFind = rgValidateColumnCol.Find(What:=strValidateItem, LookAt:=xlWhole)
    iFirstItemRow = rgFind.Row
    Set rgFind = rgValidateColumnCol.Find( _
                  What:=strValidateItem, LookAt:=xlWhole, SearchDirection:=xlPrevious)
    iLastItemRow = rgFind.Row
    Call ResetFindParametersToDefaults
    
    'need to find the English USA row that matches source row in columns A, B, C, & E:
    'Make a simple array of row numbers that are possibilities. Delete each row number
    'from the array as it is ruled out. Only one should remain.

    iLboundEnglish = 1
    iUboundEnglish = (iLastItemRow - iFirstItemRow) + 1
    ReDim ArrayEnglish(iLboundEnglish To iUboundEnglish)
    'initialize the array with row numbers:
    iArrayEnglishRow = iFirstItemRow
    For iArrayEnglishIndex = iLboundEnglish To iUboundEnglish
        ArrayEnglish(iArrayEnglishIndex) = iArrayEnglishRow
        iArrayEnglishRow = iArrayEnglishRow + 1
    Next iArrayEnglishIndex
    'find the correct english row:
    bFound = False 'init.
    For iArrayEnglishIndex = iLboundEnglish To iUboundEnglish
        iArrayEnglishRow = ArrayEnglish(iArrayEnglishIndex)
        If shValidation.Cells(iArrayEnglishRow, LANGUAGE_COL).value <> ENGLISH_USA Then GoTo GoToSkipToNextInLoop
        If shValidation.Cells(iArrayEnglishRow, TEMPLATE_COL).value <> shValidation.Cells(iArrayRow, TEMPLATE_COL).value Then GoTo GoToSkipToNextInLoop
        If shValidation.Cells(iArrayEnglishRow, REQ_COL).value <> shValidation.Cells(iArrayRow, REQ_COL).value Then GoTo GoToSkipToNextInLoop
        If shValidation.Cells(iArrayEnglishRow, REQTEST_COL).value <> shValidation.Cells(iArrayRow, REQTEST_COL).value Then GoTo GoToSkipToNextInLoop
        If shValidation.Cells(iArrayEnglishRow, VALTEST_COL).value <> shValidation.Cells(iArrayRow, VALTEST_COL).value Then GoTo GoToSkipToNextInLoop
        bFound = True 'all tests passed, so this is the row.
        Exit For
GoToSkipToNextInLoop:
    Next iArrayEnglishIndex
    
    'add the english row number's text to the array:
    If bFound Then
        vRows(ARRAY_ENGLISH_COL, iArrayIndex) = shValidation.Cells(iArrayEnglishRow, ERRORTEXT_COL).value
    Else
        vRows(ARRAY_ENGLISH_COL, iArrayIndex) = "This validation rule does not apply to English USA " & _
                                                "(English USA version of this error text was not found in rows " & _
                                                 iFirstItemRow & " - " & iLastItemRow & _
                                                 " of the international data validation table.)"
    End If
    
    'substitute in the local text for the local row number:
    vRows(ARRAY_LOCAL_COL, iArrayIndex) = shValidation.Cells(iArrayRow, ERRORTEXT_COL).value
    
    'populate the rest of the data for that row:
    vRows(ARRAY_TEMPLATE_DEP_TEST_COL, iArrayIndex) = strTemplateDependencyTest
    vRows(ARRAY_REQUIRED_COLUMN_COL, iArrayIndex) = strRequiredColumn
    vRows(ARRAY_REQ_COL_TEST_COL, iArrayIndex) = strReqColTest
    vRows(ARRAY_VALIDATE_COLUMN_COL, iArrayIndex) = strValidateColumn
    vRows(ARRAY_VAL_COL_TEST_COL, iArrayIndex) = strValColTest

Next iArrayIndex

'make new workbook with list to be translated:
Dim wbNew As Workbook
Dim shNew As Worksheet
Dim shTmp As Worksheet
Dim rgNew As Range
Dim rgTmp As Range
Set wbNew = Workbooks.Add
Set shNew = wbNew.Worksheets(1)
Set rgNew = shNew.Range("A1", shNew.Cells(iUboundArrayRows, 7))
Dim iWorksheetsCount As Long
iWorksheetsCount = wbNew.Worksheets.Count
If iWorksheetsCount < 2 Then wbNew.Worksheets.Add After:=wbNew.Worksheets(iWorksheetsCount)
Set shTmp = wbNew.Worksheets(2)
Set rgTmp = shTmp.Range("A1", shTmp.Cells(7, iUboundArrayRows))
shNew.Columns("A:B").WrapText = True
rgTmp = vRows '<--- <--- <--- <--- <--- <--- <--- <--- <--- <--- <--- <--- <--- <--- <--- <--- <---
rgTmp.Copy
rgNew.PasteSpecial Transpose:=True, Paste:=xlPasteValues
Application.CutCopyMode = False
rgTmp.ClearContents

'insert column for Check formula:
If Not shNew Is ActiveSheet Then shNew.Activate
Columns(3).Insert Shift:=xlToRight
shNew.Columns(3).WrapText = False 'because when added this column gets wrap text from column B.

'store copy of original local error text:
shNew.Columns("I:I").value = shNew.Columns("A:A").value

'add check column to show which rows were changed:
shNew.Range("J2").Formula = "=A2<>I2"
shNew.Range("J2").AutoFill Destination:=shNew.Range("J2", shNew.Cells(iUboundArrayRows, 10))

shNew.Range("A1").value = strLanguage
shNew.Range("B1").value = ENGLISH_USA

shNew.Range("D1").value = "Template Dependency Test"
shNew.Range("E1").value = "Required Column"
shNew.Range("F1").value = "Required Column Test"
shNew.Range("G1").value = "Validate Column"
shNew.Range("H1").value = "Validate Column Test"
shNew.Range("I1").value = "Original"
shNew.Range("J1").value = "Is Changed?"

shNew.Range("C1").value = "Check"
shNew.Range("A1:H1").Font.Bold = True
'shNew.Range("C2").Formula = "=IF(A2=B2,""Same as English USA"",""OK"")"
'shNew.Range("C2").Formula = "=IF(OR(A2=B2,NOT(ISERROR(FIND(""version not found"",B2)))),""Please Translate"",""OK"")"
shNew.Range("C2").Formula = "=IF(NOT(ISERROR(FIND(""rule does not apply"",B2))),""Translate if not " & strLanguage & """,IF(A2=B2,""Please Translate"",""OK""))"
shNew.Range("C2").AutoFill Destination:=shNew.Range("C2", shNew.Cells(iUboundArrayRows, 3))
shNew.Columns("C").EntireColumn.AutoFit
    shNew.Columns("A:B").ColumnWidth = 75
    shNew.Columns(4).ColumnWidth = 25
    shNew.Columns(5).ColumnWidth = 16
    shNew.Columns(6).ColumnWidth = 21
    shNew.Columns(7).ColumnWidth = 16
    shNew.Columns(8).ColumnWidth = 20
    shNew.Columns("D:J").Font.ColorIndex = 16 '50% gray
    shNew.Columns(2).Font.ColorIndex = 16 '50% gray
    shNew.Columns("A:C").Select
    ActiveWindow.Zoom = True
    'micro adjust:
    shNew.Columns("C").EntireColumn.AutoFit
    ActiveWindow.Zoom = True
shNew.UsedRange.EntireRow.AutoFit

'conditional formatting on Check column:
    Dim rgCheckCol As Range
    Set rgCheckCol = Columns(3)
    With rgCheckCol
        If Val(Application.Version) >= 12 Then 'Excel 2007 or later.
            Const XL_CONTAINS As Long = 0 'xlContains 'for compatibility with xl2003.
            Const XL_TEXT_STRING As Long = 9 'xlTextString 'for compatibility with xl2003.
'            .FormatConditions.Add Type:=xlTextString, String:="Translate if not", TextOperator:=xlContains
            Stop 'MAKE SURE THIS WORKS IN XL2007'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
            .FormatConditions.Add XL_TEXT_STRING, "Translate if not", XL_CONTAINS
        Else
            .FormatConditions.Add Type:=xlCellValue, Formula1:="Translate if not " & strLanguage, Operator:=xlEqual
        End If
        .FormatConditions(1).Font.Color = -16776961
        If Val(Application.Version) >= 12 Then 'Excel 2007 or later.
'            .FormatConditions.Add Type:=xlTextString, String:="Please Translate", TextOperator:=xlContains
            Stop 'MAKE SURE THIS WORKS IN XL2007'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
            .FormatConditions.Add XL_TEXT_STRING, "Please Translate", XL_CONTAINS
        Else
            .FormatConditions.Add Type:=xlCellValue, Formula1:="Translate if not " & strLanguage, Operator:=xlEqual
        End If
        .FormatConditions(2).Font.Color = -16776961
        .FormatConditions(2).Interior.Color = 65535
    End With

'conditional formatting on English USA column:
    Dim rgEnglishUSACol As Range
    Set rgEnglishUSACol = Columns(2)
    With rgEnglishUSACol
        If Val(Application.Version) >= 12 Then 'Excel 2007 or later.
'            .FormatConditions.Add Type:=xlTextString, String:="This validation rule does not apply", TextOperator:=xlContains
            Stop 'MAKE SURE THIS WORKS IN XL2007'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
            .FormatConditions.Add XL_TEXT_STRING, "This validation rule does not apply", XL_CONTAINS
        Else
            'can't do in Excel 2003, so ignore.
        End If
        .FormatConditions(1).Font.Italic = True
    End With


shNew.Range("A1").Select
wbNew.Activate

'save the file:
Dim strFilename As String
Dim strSaveFullPath As String
strFilename = "Validation Error Strings to Translate to " & strLanguage & " for " & ThisWorkbook.Name
SendKeys strFilename
'strSaveFullPath = Application.GetSaveAsFilename(strFileName, , , "Save file with translation strings...")
strSaveFullPath = Application.GetSaveAsFilename(, , , "Save file with translation strings...")
If strSaveFullPath = "False" Then
    Exit Function
Else
    Dim iFileFormat As Long
    If Val(Application.Version) >= 12 And LCase(Right(strFilename, 4)) = ".xls" Then
        'this is Excel 2007 or later, saving as Excel 97-2003 file format:
        iFileFormat = 56 'xlExcel8
    Else
        'saving in the default format of this version of Excel:
        iFileFormat = xlNormal
    End If
    wbNew.SaveAs FileName:=strSaveFullPath, FileFormat:=iFileFormat
End If

End Function





Public Function ExportValidationCellCommentListToBeTranslated() As Boolean
                                                                'ExportValidationCellCommentListsToBeTranslated
                                                                'ExportOneValidationCellCommentListToBeTranslated
                                                                    'need to work on issues with calling ValidateTemplate.

'Press F5 here to run.
    'Run this from a built flat-file template, NOT from the universal master.
    'Be sure to have current versioned urls in International Settings.

'exports list of validation cell comments in column B, with
'english versions where applicable in column a,
'that apply to a given category and given locale.

'calls into main validation function.

Dim wbValidation As Workbook
Dim shValidation As Worksheet
Dim bFound As Boolean

Dim iRet As Long
'iRet = MsgBox("You must run Update Template right before running this, because any discrepancy between" & _
              " the current validation rules table and this workbook's validation rules table will result" & _
              " in an incorrect list of translations needed." & _
              vbNewLine & vbNewLine & _
              "Do you want to proceed with making the list of translations needed?", _
              vbQuestion + vbYesNo, "Did you run Update Template first?")
iRet = AmazonMsgBox("You must run Update Template right before running this, because any discrepancy between" & _
                    " the current validation rules table and this workbook's validation rules table will result" & _
                    " in an incorrect list of translations needed." & _
                    vbNewLine & vbNewLine & _
                    "Do you want to proceed with making the list of translations needed?", _
                    vbYesNo, "Did you run Update Template first?")
If iRet = vbNo Then Exit Function

'iRet = MsgBox("Getting a complete translation list REQUIRES that no rows in the universal validation table are autofiltered. ALL rows MUST be VISIBLE. If you're not sure whether any rows are filtered, click NO and check." & _
              vbNewLine & vbNewLine & _
              "Do you want to proceed with making the list of translations needed?", _
              vbQuestion + vbYesNo, "Did you make sure no rows are filtered in the validation table?")
iRet = AmazonMsgBox("Getting a complete translation list REQUIRES that no rows in the universal validation table are autofiltered. ALL rows MUST be VISIBLE. If you're not sure whether any rows are filtered, click NO and check." & _
                    vbNewLine & vbNewLine & _
                    "Do you want to proceed with making the list of translations needed?", _
                    vbYesNo, "Did you make sure no rows are filtered in the validation table?")
If iRet = vbNo Then Exit Function

'===================================================================================
'data validation table worksheet:
bFound = False
For Each wbValidation In Application.Workbooks
    If wbValidation.Name = "Flat-File Listing Feed Templates Universal Settings.xlsm" Then
        bFound = True
        Exit For
    End If
Next wbValidation
If Not bFound Then
    Dim strOpenPath As String
    strOpenPath = Application.GetOpenFilename(, , GetTranslatedString("browse_to_data_validation"))
    If strOpenPath = "False" Then Exit Function
    Set wbValidation = Workbooks.Open(strOpenPath, UpdateLinks:=0) '0 = do not update links.
End If
Set shValidation = wbValidation.Worksheets("IntDataValidation")
'===================================================================================

Dim vRows As Variant
Dim rgValidateColumnCol As Range
Dim rgValidateItemLanguageCol As Range
Dim iUboundArrayRows As Long
Dim iArrayIndex As Long
Dim iArrayRow As Long
Dim bRet As Boolean
Dim strLanguage As String
Dim strValidateItem As String
Dim strErrorTextEnglish As String
Dim strErrorTextLocal As String
Dim strTemplateDependencyTest As String
Dim strRequiredColumn As String
Dim strReqColTest As String
Dim strValidateColumn As String
Dim strValColTest As String
Dim rgFind As Range
Dim iFirstItemRow As Long
Dim iLastItemRow As Long

Dim ArrayEnglish() As Long
Dim iArrayEnglishIndex As Long
Dim iArrayEnglishRow As Long
Dim iUboundEnglish As Long
Dim iLboundEnglish As Long


Const TEMPLATE_DEPENDENCY_TEST_COL As Long = 1
Const REQUIRED_COLUMN_COL As Long = 2
Const REQUIRED_COLUMN_TEST_COL As Long = 3
Const VALIDATE_COLUMN_COL As Long = 4
Const VALIDATE_COLUMN_TEST_COL As Long = 5
Const VALIDATE_COLUMN_LANGUAGE_COL As Long = 6
Const VALIDATE_COLUMN_ERROR_TEXT_COL As Long = 7
Const ARRAY_ROWS_DIMENSION As Long = 2
Const ARRAY_LOCAL_COL As Long = 1
Const ARRAY_ENGLISH_COL As Long = 2
Const ARRAY_TEMPLATE_DEP_TEST_COL As Long = 3
Const ARRAY_REQUIRED_COLUMN_COL As Long = 4
Const ARRAY_REQ_COL_TEST_COL As Long = 5
Const ARRAY_VALIDATE_COLUMN_COL As Long = 6
Const ARRAY_VAL_COL_TEST_COL As Long = 7

Const TEMPLATE_COL As Long = 1
Const REQ_COL As Long = 2
Const REQTEST_COL As Long = 3
Const VALTEST_COL As Long = 5
Const LANGUAGE_COL As Long = 6
Const ERRORTEXT_COL As Long = 7
Const ENGLISH_USA As String = "English USA"

Set rgValidateColumnCol = shValidation.Columns(VALIDATE_COLUMN_COL)



'make new workbook with list to be translated:
Dim wbNew As Workbook
Dim shNew As Worksheet
Dim shTmp As Worksheet
Dim rgNew As Range
Dim rgTmp As Range
Dim bSavedAs2007 As Boolean
bSavedAs2007 = False 'init.
Set wbNew = Workbooks.Add
Set shNew = wbNew.Worksheets(1)


'get array of template sheets:
Dim shArrayTemplateSheets() As Worksheet
Dim iUboundTS As Long
Dim shWS As Worksheet
iUboundTS = 0 'init.
ReDim shArrayTemplateSheets(0 To 0) 'init.
For Each shWS In ThisWorkbook.Worksheets
    If InStr(shWS.CodeName, "shTemplate") > 0 Then
        'it's a template sheet:
        iUboundTS = iUboundTS + 1
        ReDim Preserve shArrayTemplateSheets(0 To iUboundTS)
        Set shArrayTemplateSheets(iUboundTS) = shWS
    End If
Next shWS


'loop through template sheets:
Dim shTemplateSheet As Worksheet
Dim iIndexTS As Long
For iIndexTS = 1 To iUboundTS
    Set shTemplateSheet = shArrayTemplateSheets(iIndexTS)
    ThisWorkbook.Activate: shTemplateSheet.Activate 'the active template will be validated.


    bRet = ValidateTemplate(, vRows, , , True, True, True, shValidation, True) 'ByRef. '2009-06-23.
    iUboundArrayRows = UBound(vRows, ARRAY_ROWS_DIMENSION)
    If iUboundArrayRows = 0 Then
    '    MsgBox "Cannot proceed because there was nothing to validate." & _
                vbNewLine & vbNewLine & _
                "Enter a character in the first data row of the first column of the template sheet, and try again.", _
                vbCritical + vbOKOnly, "Cannot Create List"
        AmazonMsgBox GetTranslatedString("cannot_proceed_1") & _
                      vbNewLine & vbNewLine & _
                      GetTranslatedString("cannot_proceed_2"), _
                      vbOKOnly, GetTranslatedString("cannot_create_list")
        Exit Function
    End If
    
    strLanguage = GetLocalLanguageName() 'Don't run this proc from the master.
                                         'Even changing strLanguage won't work.
                                         'Need to run from localized version.
    
    For iArrayIndex = 1 To iUboundArrayRows
        'loop through each row in the validation table that was processed for this template:
        iArrayRow = vRows(ARRAY_LOCAL_COL, iArrayIndex)
        strErrorTextLocal = shValidation.Cells(iArrayRow, VALIDATE_COLUMN_ERROR_TEXT_COL)
        
        strTemplateDependencyTest = shValidation.Cells(iArrayRow, TEMPLATE_DEPENDENCY_TEST_COL)
        strRequiredColumn = shValidation.Cells(iArrayRow, REQUIRED_COLUMN_COL)
        strReqColTest = shValidation.Cells(iArrayRow, REQUIRED_COLUMN_TEST_COL)
        strValidateColumn = shValidation.Cells(iArrayRow, VALIDATE_COLUMN_COL)
        strValColTest = shValidation.Cells(iArrayRow, VALIDATE_COLUMN_TEST_COL)
        
        'find top and bottom rows of that validation column item:
        strValidateItem = shValidation.Cells(iArrayRow, VALIDATE_COLUMN_COL)
        Set rgFind = rgValidateColumnCol.Find(What:=strValidateItem, LookAt:=xlWhole)
        iFirstItemRow = rgFind.Row
        Set rgFind = rgValidateColumnCol.Find( _
                      What:=strValidateItem, LookAt:=xlWhole, SearchDirection:=xlPrevious)
        iLastItemRow = rgFind.Row
        Call ResetFindParametersToDefaults
        
        'need to find the English USA row that matches source row in columns A, B, C, & E:
        'Make a simple array of row numbers that are possibilities. Delete each row number
        'from the array as it is ruled out. Only one should remain.
    
        iLboundEnglish = 1
        iUboundEnglish = (iLastItemRow - iFirstItemRow) + 1
        ReDim ArrayEnglish(iLboundEnglish To iUboundEnglish)
        'initialize the array with row numbers:
        iArrayEnglishRow = iFirstItemRow
        For iArrayEnglishIndex = iLboundEnglish To iUboundEnglish
            ArrayEnglish(iArrayEnglishIndex) = iArrayEnglishRow
            iArrayEnglishRow = iArrayEnglishRow + 1
        Next iArrayEnglishIndex
        'find the correct english row:
        bFound = False 'init.
        For iArrayEnglishIndex = iLboundEnglish To iUboundEnglish
            iArrayEnglishRow = ArrayEnglish(iArrayEnglishIndex)
            If shValidation.Cells(iArrayEnglishRow, LANGUAGE_COL).value <> ENGLISH_USA Then GoTo GoToSkipToNextInLoop
            If shValidation.Cells(iArrayEnglishRow, TEMPLATE_COL).value <> shValidation.Cells(iArrayRow, TEMPLATE_COL).value Then GoTo GoToSkipToNextInLoop
            If shValidation.Cells(iArrayEnglishRow, REQ_COL).value <> shValidation.Cells(iArrayRow, REQ_COL).value Then GoTo GoToSkipToNextInLoop
            If shValidation.Cells(iArrayEnglishRow, REQTEST_COL).value <> shValidation.Cells(iArrayRow, REQTEST_COL).value Then GoTo GoToSkipToNextInLoop
            If shValidation.Cells(iArrayEnglishRow, VALTEST_COL).value <> shValidation.Cells(iArrayRow, VALTEST_COL).value Then GoTo GoToSkipToNextInLoop
            bFound = True 'all tests passed, so this is the row.
            Exit For
GoToSkipToNextInLoop:
        Next iArrayEnglishIndex
        
        'add the english row number's text to the array:
        If bFound Then
            vRows(ARRAY_ENGLISH_COL, iArrayIndex) = shValidation.Cells(iArrayEnglishRow, ERRORTEXT_COL).value
        Else
            vRows(ARRAY_ENGLISH_COL, iArrayIndex) = "This validation rule does not apply to English USA " & _
                                                    "(English USA version of this error text was not found in rows " & _
                                                     iFirstItemRow & " - " & iLastItemRow & _
                                                     " of the international data validation table.)"
        End If
        
        'substitute in the local text for the local row number:
        vRows(ARRAY_LOCAL_COL, iArrayIndex) = shValidation.Cells(iArrayRow, ERRORTEXT_COL).value
        
        'populate the rest of the data for that row:
        vRows(ARRAY_TEMPLATE_DEP_TEST_COL, iArrayIndex) = strTemplateDependencyTest
        vRows(ARRAY_REQUIRED_COLUMN_COL, iArrayIndex) = strRequiredColumn
        vRows(ARRAY_REQ_COL_TEST_COL, iArrayIndex) = strReqColTest
        vRows(ARRAY_VALIDATE_COLUMN_COL, iArrayIndex) = strValidateColumn
        vRows(ARRAY_VAL_COL_TEST_COL, iArrayIndex) = strValColTest
    
    Next iArrayIndex
    

    '=================================================================
    '2010-06-28, part 1 of 2:
    'if iUboundArrayRows > 256, must do with Excel 2007 format:
    If iUboundArrayRows > 256 Then
        If shNew.Columns.Count = 256 Then
            If Val(Application.Version) < 12 Then
                'too many for Excel 2003 and earlier, but this is running in Excel 2003 or earlier:
                MsgBox "Too many validation rules to make translation file in Excel 2003 or earlier. Please run this in Excel 2007 or later", vbCritical + vbOKOnly, "Too Many Rules"
                Exit Function
            Else
                'save as Excel 2007 format:
                On Error Resume Next
                Kill Environ("tmp") & "\wbNew.xlsm"
                On Error GoTo 0
                DoEvents
                wbNew.SaveAs FileName:=Environ("tmp") & "\wbNew.xlsm", FileFormat:=xlOpenXMLWorkbookMacroEnabled
                wbNew.Close SaveChanges:=False
                DoEvents
                Set wbNew = Workbooks.Open(Environ("tmp") & "\wbNew.xlsm")
                Set shNew = wbNew.Worksheets(1)
                bSavedAs2007 = True
            End If
        End If
    End If
    '(see below for part 2 of 2)
    '=================================================================
    Set rgNew = shNew.Range("A1", shNew.Cells(iUboundArrayRows, 7))
    If shNew.Range("A2") <> "" Then
        'not the first template sheet; offset to avoid clobbering previous template sheet's data:
        Dim iPasteRowOffset As Long
        iPasteRowOffset = shNew.Cells(shNew.Rows.Count, 1).End(xlUp).Row
        Set rgNew = rgNew.Offset(RowOffset:=iPasteRowOffset)
    End If
    Dim iWorksheetsCount As Long
    iWorksheetsCount = wbNew.Worksheets.Count
    If iWorksheetsCount < 2 Then wbNew.Worksheets.Add After:=wbNew.Worksheets(iWorksheetsCount)
    Set shTmp = wbNew.Worksheets(2)
    Set rgTmp = shTmp.Range("A1", shTmp.Cells(7, iUboundArrayRows))
        'error on FR Video because iUboundArrayRows = 2314 and wbNew is xl97-2003 format (only 256 columns).
            'Need to make wbNew xl2007 format, to get more columns.
                'Then can change back to xl97-2003 format when done.
    shNew.Columns("A:B").WrapText = True
    rgTmp = vRows '<--- <--- <--- <--- <--- <--- <--- <--- <--- <--- <--- <--- <--- <--- <--- <--- <---
    rgTmp.Copy
    rgNew.PasteSpecial Transpose:=True, Paste:=xlPasteValues
    Application.CutCopyMode = False
    rgTmp.ClearContents
Next iIndexTS


'=================================================================
'2010-06-28, part 2 of 2:
If bSavedAs2007 Then
    'save as Excel 2003 format:
    On Error Resume Next
    Kill Environ("tmp") & "\wbNew.xls"
    On Error GoTo 0
    DoEvents
    wbNew.SaveAs FileName:=Environ("tmp") & "\wbNew.xls", FileFormat:=xlExcel8
    wbNew.Close SaveChanges:=False
    DoEvents
    Set wbNew = Workbooks.Open(Environ("tmp") & "\wbNew.xls")
    Set shNew = wbNew.Worksheets(1)
End If
'=================================================================



'if more than one template sheet, remove dupes:
Dim iNewLastRow As Long
iNewLastRow = shNew.Cells(shNew.Rows.Count, 1).End(xlUp).Row
If iUboundTS > 1 Then
    shNew.Range("H1").Formula = "=A1&B1&C1&D1&E1&F1&G1"
    shNew.Range("H1").AutoFill Destination:=shNew.Range("H1", shNew.Cells(iNewLastRow, 8))
    Application.Calculate
    shNew.Range("H1").CurrentRegion.Sort shNew.Range("H1")
    Dim iRow As Long
    iRow = 1 'init.
    Do
        If shNew.Cells(iRow, 8).value = shNew.Cells(iRow + 1, 8).value Then
            shNew.Rows(iRow).EntireRow.Delete
        Else
            iRow = iRow + 1
        End If
    Loop Until shNew.Cells(iRow + 1, 8).Formula = ""
End If
iNewLastRow = shNew.Cells(shNew.Rows.Count, 1).End(xlUp).Row
shNew.Columns(8).EntireColumn.Delete



'insert column for Check formula:
If Not shNew Is ActiveSheet Then shNew.Activate
Columns(3).Insert Shift:=xlToRight
shNew.Columns(3).WrapText = False 'because when added this column gets wrap text from column B.

'store copy of original local error text:
shNew.Columns("I:I").value = shNew.Columns("A:A").value

'add check column to show which rows were changed:
shNew.Range("J2").Formula = "=A2<>I2"
shNew.Range("J2").AutoFill Destination:=shNew.Range("J2", shNew.Cells(iNewLastRow, 10))

shNew.Range("A1").value = strLanguage
shNew.Range("B1").value = ENGLISH_USA

shNew.Range("D1").value = "Template Dependency Test"
shNew.Range("E1").value = "Required Column"
shNew.Range("F1").value = "Required Column Test"
shNew.Range("G1").value = "Validate Column"
shNew.Range("H1").value = "Validate Column Test"
shNew.Range("I1").value = "Original"
shNew.Range("J1").value = "Is Changed?"

'apply hidden CreateDate name and formula:
wbNew.Names.Add Name:="CreateDate", RefersTo:=Format(Now, "mmm d, yyyy (h:mm AM/PM)"), Visible:=False
shNew.Range("K1").NumberFormat = "General"
shNew.Range("K1").value = "=CreateDate"
shNew.Range("K1").Font.ColorIndex = 2 'white.
shNew.Range("K1").Font.Size = 1

shNew.Range("C1").value = "Check"
shNew.Range("A1:H1").Font.Bold = True
'shNew.Range("C2").Formula = "=IF(A2=B2,""Same as English USA"",""OK"")"
'shNew.Range("C2").Formula = "=IF(OR(A2=B2,NOT(ISERROR(FIND(""version not found"",B2)))),""Please Translate"",""OK"")"
shNew.Range("C2").Formula = "=IF(NOT(ISERROR(FIND(""rule does not apply"",B2))),""Translate if not " & strLanguage & """,IF(A2=B2,""Please Translate"",""OK""))"
shNew.Range("C2").AutoFill Destination:=shNew.Range("C2", shNew.Cells(iNewLastRow, 3))
shNew.Columns("C").EntireColumn.AutoFit
    shNew.Columns("A:B").ColumnWidth = 75
    shNew.Columns(4).ColumnWidth = 25
    shNew.Columns(5).ColumnWidth = 16
    shNew.Columns(6).ColumnWidth = 21
    shNew.Columns(7).ColumnWidth = 16
    shNew.Columns(8).ColumnWidth = 20
    shNew.Columns("D:J").Font.ColorIndex = 16 '50% gray
    shNew.Columns(2).Font.ColorIndex = 16 '50% gray
    shNew.Columns("A:C").Select
    ActiveWindow.Zoom = True
    'micro adjust:
    shNew.Columns("C").EntireColumn.AutoFit
    ActiveWindow.Zoom = True
shNew.UsedRange.EntireRow.AutoFit

'conditional formatting on Check column:
    Dim rgCheckCol As Range
    Set rgCheckCol = Columns(3)
    With rgCheckCol
        .FormatConditions.Add Type:=xlTextString, String:="Translate if not", TextOperator:=xlContains
        .FormatConditions(1).Font.Color = -16776961
        .FormatConditions.Add Type:=xlTextString, String:="Please Translate", TextOperator:=xlContains
        .FormatConditions(2).Font.Color = -16776961
        .FormatConditions(2).Interior.Color = 65535
    End With

'conditional formatting on English USA column:
    Dim rgEnglishUSACol As Range
    Set rgEnglishUSACol = Columns(2)
    With rgEnglishUSACol
        .FormatConditions.Add Type:=xlTextString, String:="This validation rule does not apply", TextOperator:=xlContains
        .FormatConditions(1).Font.Italic = True
    End With


shNew.Range("A1").Select
wbNew.Activate

'save the file:
Dim strFilename As String
Dim strSaveFullPath As String
strFilename = "Validation Error Strings to Translate to " & strLanguage & " for " & ThisWorkbook.Name
SendKeys strFilename
'strSaveFullPath = Application.GetSaveAsFilename(strFileName, , , "Save file with translation strings...")
strSaveFullPath = Application.GetSaveAsFilename(, , , "Save file with translation strings...")
If strSaveFullPath = "False" Then
    Exit Function
Else
    Dim iFileFormat As Long
    If Val(Application.Version) >= 12 And LCase(Right(strFilename, 4)) = ".xls" Then
        'this is Excel 2007 or later, saving as Excel 97-2003 file format:
        iFileFormat = xlExcel8
    Else
        'saving in the default format of this version of Excel:
        iFileFormat = xlNormal
    End If
    wbNew.SaveAs FileName:=strSaveFullPath, FileFormat:=iFileFormat
End If

End Function







Private Sub SwapInValidationCellCommentTextUsingNewColsAndNoTemplate()

Application.EnableEvents = False

'swap in validation cell comment translations.

Dim shMain As Worksheet
Dim shNew As Worksheet


'Settings:
'===================================================================================
'local language name:
'Stop
'Const strlanguage As String = "German"  'MUST UPDATE EACH RUN FOR NOW..................


'data validation table worksheet:
'Stop
'Set shMain = Workbooks("IntDataValidation.xls").Worksheets("DataValidation")  'MUST BE OPENED BEFORE RUN FOR NOW..................

'worksheet with new strings to swap in:
'Stop
'MUST UPDATE EACH RUN FOR NOW..................
'Set shNew = Workbooks("Kopie von Copy of DE Listingloader Data Validation Error Text 2008-06-12_translation_jsl.xls").Worksheets("Sheet1")

'Note:
'For the category templates, the debug.prints should be changed to write
'to a new worksheet in a new workbook. Otherwise too long for Immediate pane.

'===================================================================================


Dim strLanguage As String
'strLanguage = GetLocalLanguageName() 'Don't run this proc from the master.
                                     'Even changing strLanguage won't work.
                                     'Need to run from localized version.

'language name is in cell A1 of the translations workbook.


'===================================================================================
'data validation table worksheet:
Dim bFound As Boolean
Dim wbMain As Workbook
bFound = False
For Each wbMain In Application.Workbooks
'    If wbMain.Name = "IntDataValidation.xls" Then
    If InStr(wbMain.Name, "Universal Settings") > 0 Then
        bFound = True
        Exit For
    End If
Next wbMain
If Not bFound Then
    Dim strOpenPath As String
    strOpenPath = Application.GetOpenFilename(, , "Browse to Data Validation Web Table Excel workbook...")
    Set wbMain = Workbooks.Open(strOpenPath)
End If
Set shMain = wbMain.Worksheets("IntDataValidation")
'===================================================================================


'open the workbook with the translations:
strOpenPath = Application.GetOpenFilename(, , "Browse to the workbook with the translations...")
If strOpenPath = "False" Then Exit Sub
Dim wbNew As Workbook
Set wbNew = Workbooks.Open(strOpenPath)
Set shNew = wbNew.Worksheets(1)

strLanguage = shNew.Range("A1").value 'this should be a defined name instead. Fix later.


Dim rgMain As Range
Dim rgMainTextCol As Range
Dim rgMainValidationItemCol As Range
Dim rgMainValidationItemLanguageCol As Range
Dim rgEngNew As Range
Dim rgLocalNew As Range
Dim strEngNew As String
Dim strLocalNew As String
Dim strMain As String
Dim strMainValidationItem As String
Dim strMainEnglishMatchAddress As String

Dim iMainTextCol As Long
Dim iMainLangCol As Long
Dim iNewEngCol As Long
Dim iNewLocalCol As Long

Dim iMainStartRow As Long
Dim iMainLastRow As Long
Dim iMainRow As Long
Dim iMainValidateColumnCol As Long
Dim iNewStartRow As Long
Dim iNewLastRow As Long
Dim iNewRow As Long
Dim iMainFirstItemRow As Long
Dim iMainLastItemRow As Long
Dim iMainFirstLangRow As Long
Dim iFoundLangRow As Long

Dim iMainHeightCol As Long
Dim iMainTextHeightOffset As Long

Dim rgFind As Range
Dim iFoundRow As Long
Dim rgFindAfterCell As Range
Dim bDone As Boolean
Dim bComparisonSucceeded As Boolean

Dim iTemplateDependencyTestCol As Long
Dim iRequiredColumnCol As Long
Dim iRequiredColumnTestCol As Long
Dim iValidateColumnCol As Long
Dim iValidateColumnTestCol As Long
Dim strEnglishTemplateDependencyTest As String
Dim strEnglishRequiredColumn As String
Dim strEnglishRequiredColumnTest As String
Dim strEnglishValidateColumntest As String
Dim strLangTemplateDependencyTest As String
Dim strLangRequiredColumn As String
Dim strLangRequiredColumnTest As String
Dim strLangValidateColumntest As String

Dim iNewTemplateDependencyTestCol As Long
Dim iNewRequiredColumnCol As Long
Dim iNewRequiredColumnTestCol As Long
Dim iNewValidateColumnCol As Long
Dim iNewValidateColumnTestCol As Long
Dim iNewIsChangedCol As Long
Dim iNewEnglishErrorTextCol As Long

Dim strTemplateDependencyTest As String
Dim strRequiredColumn As String
Dim strRequiredColumnTest As String
Dim strRequiredColumnTestTemp As String
Dim strValidateColumn As String
Dim strValidateColumnTest As String
Dim strValidateColumnTestTemp As String

Dim strPriorNewrowTemplateDependencyTest As String
Dim strPriorNewrowRequiredColumn As String
Dim strPriorNewrowRequiredColumnTest As String
Dim strPriorNewrowValidateColumn As String
Dim strPriorNewrowValidateColumnTest As String
Dim strEnglishErrorText As String

Const PATTERN_NO_HIGH_ASCII As String = "^[ -~|7f|]*$"
Const PATTERN_NO_HIGH_ASCII_FILTER_CRITERIA As String = "*^[ -~~*~*$*"
Const PATTERN_SNIPPET_LONG_DATE_NOLEAPYEAR As String = "2012|2016|2020"
Const PATTERN_SNIPPET_LONG_DATE_NOLEAPYEAR_FILTER_CRITERIA As String = "*2012|2016|2020*"


iMainTextCol = 7
iMainLangCol = 6
iMainValidateColumnCol = 4
iMainHeightCol = 8
iMainTextHeightOffset = iMainHeightCol - iMainTextCol

iNewEngCol = 2
iNewLocalCol = 1

iNewEnglishErrorTextCol = 2
iNewTemplateDependencyTestCol = 4
iNewRequiredColumnCol = 5
iNewRequiredColumnTestCol = 6
iNewValidateColumnCol = 7
iNewValidateColumnTestCol = 8
'column 9 is "Original"; not needed in this function; used only for worksheet cell formulas.
iNewIsChangedCol = 10


iTemplateDependencyTestCol = 1
iRequiredColumnCol = 2
iRequiredColumnTestCol = 3
iValidateColumnCol = 4
iValidateColumnTestCol = 5


iMainStartRow = 2

Dim rgTmp As Range
Set rgTmp = shMain.Cells(shMain.Rows.Count, iMainValidateColumnCol)
If rgTmp.value <> "" Then
    iMainLastRow = rgTmp.Row
Else
    'all autofilters must be showing all for this to get the right row:
    shMain.Cells.AutoFilter Field:=iMainLangCol
    shMain.Cells.AutoFilter Field:=iTemplateDependencyTestCol
    shMain.Cells.AutoFilter Field:=iRequiredColumnCol
    shMain.Cells.AutoFilter Field:=iRequiredColumnTestCol
    shMain.Cells.AutoFilter Field:=iValidateColumnCol
    shMain.Cells.AutoFilter Field:=iValidateColumnTestCol
    
    iMainLastRow = rgTmp.End(xlUp).Row
End If
iNewStartRow = 2

Set rgTmp = shNew.Cells(shNew.Rows.Count, iNewLocalCol)
If rgTmp.value <> "" Then
    iNewLastRow = rgTmp.Row
Else
    iNewLastRow = rgTmp.End(xlUp).Row
End If


Set rgMainTextCol = shMain.Range(shMain.Cells(iMainStartRow, iMainTextCol), shMain.Cells(iMainLastRow, iMainTextCol))
Set rgMainValidationItemCol = shMain.Range(shMain.Cells(iMainStartRow, iMainValidateColumnCol), shMain.Cells(iMainLastRow, iMainValidateColumnCol))

Dim bIsChanged As Boolean
Dim rgReplacementCandidates As Range
Dim bNoVisibleCellsInRange As Boolean
Dim bAutoFilterFailed As Boolean

shMain.Cells.AutoFilter Field:=iMainLangCol, Criteria1:=strLanguage

        'init prior newrow settings to impossible values:
        strPriorNewrowTemplateDependencyTest = "init to impossible value before loop."
        strPriorNewrowRequiredColumn = "init to impossible value before loop."
        strPriorNewrowRequiredColumnTest = "init to impossible value before loop."
        strPriorNewrowValidateColumn = "init to impossible value before loop."
        strPriorNewrowValidateColumnTest = "init to impossible value before loop."

wbMain.Activate: shMain.Activate: DoEvents

'steps
    'loop through all english strings in new sheet:
    For iNewRow = iNewStartRow To iNewLastRow
GoToRepeatThisRow:
        
        Debug.Print "Row " & iNewRow & " of (" & iNewStartRow & " to " & iNewLastRow & ")"
        bIsChanged = shNew.Cells(iNewRow, iNewIsChangedCol)
        If bIsChanged Then
            
            strTemplateDependencyTest = shNew.Cells(iNewRow, iNewTemplateDependencyTestCol).value
            strRequiredColumn = shNew.Cells(iNewRow, iNewRequiredColumnCol).value
            strRequiredColumnTest = shNew.Cells(iNewRow, iNewRequiredColumnTestCol).value
            strValidateColumn = shNew.Cells(iNewRow, iNewValidateColumnCol).value
            strValidateColumnTest = shNew.Cells(iNewRow, iNewValidateColumnTestCol).value
            
            bAutoFilterFailed = False 'init.
            On Error GoTo ErrAutoFilterFailed
            If strTemplateDependencyTest <> strPriorNewrowTemplateDependencyTest Then
                shMain.Cells.AutoFilter Field:=iTemplateDependencyTestCol, Criteria1:=strTemplateDependencyTest
                DoEvents
            End If
            If strRequiredColumn <> strPriorNewrowRequiredColumn Then
                shMain.Cells.AutoFilter Field:=iRequiredColumnCol, Criteria1:=strRequiredColumn
                DoEvents
            End If
            If strRequiredColumnTest <> strPriorNewrowRequiredColumnTest Then
                If InStr(strRequiredColumnTest, PATTERN_SNIPPET_LONG_DATE_NOLEAPYEAR) > 0 Then
                    strRequiredColumnTestTemp = strRequiredColumnTest
                    strRequiredColumnTest = PATTERN_SNIPPET_LONG_DATE_NOLEAPYEAR_FILTER_CRITERIA
                End If
                shMain.Cells.AutoFilter Field:=iRequiredColumnTestCol, Criteria1:=strRequiredColumnTest
                If strRequiredColumnTest = PATTERN_SNIPPET_LONG_DATE_NOLEAPYEAR_FILTER_CRITERIA Then
                    strRequiredColumnTest = strRequiredColumnTestTemp
                End If
                DoEvents
            End If
            If strValidateColumn <> strPriorNewrowValidateColumn Then
                shMain.Cells.AutoFilter Field:=iValidateColumnCol, Criteria1:=strValidateColumn
                DoEvents
            End If
            If strValidateColumnTest <> strPriorNewrowValidateColumnTest Then
                If InStr(strValidateColumnTest, PATTERN_SNIPPET_LONG_DATE_NOLEAPYEAR) > 0 Then
                    strValidateColumnTestTemp = strValidateColumnTest
                    strValidateColumnTest = PATTERN_SNIPPET_LONG_DATE_NOLEAPYEAR_FILTER_CRITERIA
                ElseIf InStr(strValidateColumnTest, PATTERN_NO_HIGH_ASCII) > 0 Then
                    strValidateColumnTestTemp = strValidateColumnTest
                    strValidateColumnTest = PATTERN_NO_HIGH_ASCII_FILTER_CRITERIA
                End If
                shMain.Cells.AutoFilter Field:=iValidateColumnTestCol, Criteria1:=strValidateColumnTest
                If strValidateColumnTest = PATTERN_SNIPPET_LONG_DATE_NOLEAPYEAR_FILTER_CRITERIA Then
                    strValidateColumnTest = strValidateColumnTestTemp
                ElseIf strValidateColumnTest = PATTERN_NO_HIGH_ASCII_FILTER_CRITERIA Then
                    strValidateColumnTest = strValidateColumnTestTemp
                End If
                DoEvents
            End If
            On Error GoTo 0

            If bAutoFilterFailed Then
                'check for long date regex:
                'if application.WorksheetFunction.CountIf(
                strEnglishErrorText = shNew.Cells(iNewRow, iNewEnglishErrorTextCol).value
'                MsgBox "Autofilter failed. Check for criteria too long for AutoFilter.", vbCritical + vbOKOnly, "Error - AutoFilter Failed"
                AmazonMsgBox "Autofilter failed. Check for criteria too long for AutoFilter.", vbOKOnly, "Error - AutoFilter Failed"
                Stop
                If False Then
                    'after manually changing AutoFilter criteria to get the correct single row:
                    wbMain.Activate: shMain.Activate: DoEvents
                    shMain.Cells.AutoFilter Field:=iMainLangCol, Criteria1:=strLanguage
                    GoTo RetryAfterManuallyChangingCriteria:
                ElseIf False Then
                    'if this row in the new translations worksheet (shNew) must be skipped:
                    wbMain.Activate: shMain.Activate: DoEvents
                    shMain.Cells.AutoFilter Field:=iMainLangCol, Criteria1:=strLanguage
                    GoTo GoToSkipThisRow
                End If
            End If
            
RetryAfterManuallyChangingCriteria:
            Set rgReplacementCandidates = shMain.Range(shMain.Cells(iMainStartRow, iMainTextCol), shMain.Cells(iMainLastRow, iMainTextCol))
            bNoVisibleCellsInRange = False 'init each time through.
            On Error GoTo ErrNoVisibleCellsInRange
            Set rgReplacementCandidates = rgReplacementCandidates.SpecialCells(xlCellTypeVisible)
            On Error GoTo 0
            If bNoVisibleCellsInRange Then
                strEnglishErrorText = shNew.Cells(iNewRow, iNewEnglishErrorTextCol).value
'                MsgBox "No rows found to update. Check for changes to criteria in IntDataValidation sheet since this translations workbook was made." & vbNewLine & vbNewLine & "If strValidateColumn is ""^[ -~]*$"", try filtering Validate Column Test on 'contains' = '~~'.", vbCritical + vbOKOnly, "Error - No Rows Found To Update"
                AmazonMsgBox "No rows found to update. Check for changes to criteria in IntDataValidation sheet since this translations workbook was made." & vbNewLine & vbNewLine & "If strValidateColumn is ""^[ -~]*$"", try filtering Validate Column Test on 'contains' = '~~'.", vbOKOnly, "Error - No Rows Found To Update"
                Stop '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Debug.Print iNewRow; " of " & iNewLastRow - 1
                GoTo GoToSkipThisRow '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
                    'suggested watches:
                        'iNewRow
                        'strLanguage
                        'strTemplateDependencyTest
                        'strRequiredColumn
                        'strRequiredColumnTest
                        'strValidateColumn
                        'strValidateColumnTest
                        'strEnglishErrorText
                If False Then
                    'after manually changing AutoFilter criteria to get the correct single row:
                    wbMain.Activate: shMain.Activate: DoEvents
                    shMain.Cells.AutoFilter Field:=iMainLangCol, Criteria1:=strLanguage
                    GoTo RetryAfterManuallyChangingCriteria:
                ElseIf False Then
                    'after changing the worksheet with the new translations (shNew):
                    wbMain.Activate: shMain.Activate: DoEvents
                    shMain.Cells.AutoFilter Field:=iMainLangCol, Criteria1:=strLanguage
                    GoTo GoToRepeatThisRow
                ElseIf False Then
                    'if this row in the new translations worksheet (shNew) must be skipped:
                    wbMain.Activate: shMain.Activate: DoEvents
                    shMain.Cells.AutoFilter Field:=iMainLangCol, Criteria1:=strLanguage
                    GoTo GoToSkipThisRow
                End If
            End If
            
            'check for multiple change candidates:
            If rgReplacementCandidates.Cells.Count > 1 Then
                strEnglishErrorText = shNew.Cells(iNewRow, iNewEnglishErrorTextCol).value
'                MsgBox "Multiple rows found to update. Verify that this is correct before proceeding with update", vbCritical + vbOKOnly, "Caution - Multiple Rows Found To Update"
                AmazonMsgBox "Multiple rows found to update. Verify that this is correct before proceeding with update", vbOKOnly, "Caution - Multiple Rows Found To Update"
                Stop
                If False Then
                    'after manually changing AutoFilter criteria to get the correct single row:
                    wbMain.Activate: shMain.Activate: DoEvents
                    shMain.Cells.AutoFilter Field:=iMainLangCol, Criteria1:=strLanguage
                    GoTo RetryAfterManuallyChangingCriteria:
                ElseIf False Then
                    'after changing the worksheet with the new translations (shNew):
                    wbMain.Activate: shMain.Activate: DoEvents
                    shMain.Cells.AutoFilter Field:=iMainLangCol, Criteria1:=strLanguage
                    GoTo GoToRepeatThisRow
                ElseIf False Then
                    'if this row in the new translations worksheet (shNew) must be skipped:
                    wbMain.Activate: shMain.Activate: DoEvents
                    shMain.Cells.AutoFilter Field:=iMainLangCol, Criteria1:=strLanguage
                    GoTo GoToSkipThisRow
                End If
            End If
            
            'proceed with the update:
            rgReplacementCandidates.value = shNew.Cells(iNewRow, iNewLocalCol).value
            rgReplacementCandidates.Offset(ColumnOffset:=iMainTextHeightOffset).Interior.ColorIndex = 6
            
            
        Else
            'this row in the translation workbook is unchanged, so skip it.
        End If
        
        'Set prior newrow settings:
        strPriorNewrowTemplateDependencyTest = strTemplateDependencyTest
        strPriorNewrowRequiredColumn = strRequiredColumn
        strPriorNewrowRequiredColumnTest = strRequiredColumnTest
        strPriorNewrowValidateColumn = strValidateColumn
        strPriorNewrowValidateColumnTest = strValidateColumnTest
        
        DoEvents
        
GoToSkipThisRow:
    Next iNewRow
    

'show all autofilters:
shMain.Cells.AutoFilter Field:=iMainLangCol
shMain.Cells.AutoFilter Field:=iTemplateDependencyTestCol
shMain.Cells.AutoFilter Field:=iRequiredColumnCol
shMain.Cells.AutoFilter Field:=iRequiredColumnTestCol
shMain.Cells.AutoFilter Field:=iValidateColumnCol
shMain.Cells.AutoFilter Field:=iValidateColumnTestCol


wbNew.Close SaveChanges:=False

'MsgBox "Done." & _
       vbNewLine & vbNewLine & _
       "Check column H (Height) for yellow-highlighted cells, indicating new text to check for cell-comment height.", _
       vbInformation + vbOKOnly, "Done Swapping In Validation Translations"
AmazonMsgBox "Done." & _
             vbNewLine & vbNewLine & _
             "Check column H (Height) for yellow-highlighted cells, indicating new text to check for cell-comment height.", _
             vbOKOnly, "Done Swapping In Validation Translations"

Application.EnableEvents = True

Exit Sub

ErrNoVisibleCellsInRange:
bNoVisibleCellsInRange = True
Resume Next

ErrAutoFilterFailed:
bAutoFilterFailed = True
Resume Next

End Sub








Sub IntSettingsExportToCSV()

'This is run from the Amazon toolbar that appears when the Universal Master is the active workbook (requires v2.012 or later).

'The purpose of this procedure is to save out the sheets in International Settings.xlsm as
'Unicode CSV files that can be reviewed in Perforce and then released to production on the web.

'Unicode issues:
    'UTF8 is needed for review in perforce. Perforce can't read UTF16.
    'Excel creates UTF16 (Save As Unicode Text). Excel can't save as UTF8.
    'Word can import UTF16 saved out by Excel, and export it as UTF8. Word can be automated from Excel code.
    'Excel appears to import UTF8 with no apparent problem with the current languages.
        'HOWEVER, if Excel is processing UTF8 files as if they were UTF16, that may break with some languages.
            'Therefore, it may work for now to release UTF8 files to production on the web. But we may run into
            'issues later with languages we add in the future. So it would be safer to release UTF16 files to the
            'web after reviewing UTF8 files in Perforce.

'International Settings.xlsm has some sheets that are only instructions etc., and should not be saved out.

'What this procedure does:
    'Opens International Settings.xlsm from the setting on the Master Settings sheet.
    'Determines which sheets to save out as CSV.
        'Checks the codename of each sheet:
            'Sheets with codenames containing "NoCSV" will NOT be exported to CSV.
                'worksheets' codenames can be viewed in the VB editor (Alt + F11).
            'All other sheets are exported as CSV.
    'Saves out the sheets in International Settings.xlsm as Unicode Text (UTF16).
    'Automates Word to open each of those files and save out as UTF8.

Dim strIntSettingsWorkbookPath As String
Dim strExportFolder As String
Dim strUTF8FolderPath As String
Dim strUTF16FolderPath As String
Dim wbIntSettings As Workbook
Dim wbNew As Workbook
Dim shIntSettings As Worksheet
Dim strUTF8FileName As String
Dim strUTF8FullPath As String
Dim strArrayUFT8FilePaths() As String
Dim iUbound As Long
Dim iArrayIndex As Long

'get export paths:
strExportFolder = ThisWorkbook.Names(PATH_TO_CSV_EXPORT_FOLDER_DEFINED_NAME).RefersToRange.value
strUTF8FolderPath = strExportFolder & "\" & UTF8_SUBFOLDER_NAME
strUTF16FolderPath = strExportFolder & "\" & UTF16_SUBFOLDER_NAME

'open International Settings.xlsm:
strIntSettingsWorkbookPath = ThisWorkbook.Names(INT_SETTINGS_WORKBOOK_FULL_PATH_DEFINED_NAME).RefersToRange.value
Set wbIntSettings = Workbooks.Open(strIntSettingsWorkbookPath)

'export from Excel as UTF16 ("Save As Unicode Text"):
ReDim strArrayUFT8FilePaths(0 To 0) As String
iUbound = 0
For Each shIntSettings In wbIntSettings.Worksheets
    'check whether this sheet should be exported to csv:
    If InStr(shIntSettings.CodeName, "NoCSV") = 0 Then
        'export this sheet:
        strUTF8FileName = Left(shIntSettings.Name, InStr(shIntSettings.Name, ".")) & "txt"
        strUTF8FullPath = strUTF8FolderPath & "\" & strUTF8FileName
        iUbound = iUbound + 1
        ReDim Preserve strArrayUFT8FilePaths(0 To iUbound) As String
        strArrayUFT8FilePaths(iUbound) = strUTF8FullPath
        shIntSettings.Copy
        Set wbNew = Workbooks(Workbooks.Count)
        wbNew.SaveAs FileName:=strUTF8FullPath, FileFormat:=xlUnicodeText
        wbNew.Close SaveChanges:=False
    End If
Next shIntSettings

'Open in Word and save as UTF8:
Dim oWordApp As Object
Set oWordApp = CreateObject("Word.Application")
For iArrayIndex = 1 To iUbound
    strUTF8FullPath = strArrayUFT8FilePaths(iArrayIndex)
    Set shIntSettings = oWordApp.Open(strUTF8FullPath)
    strUTF8FileName = shIntSettings.Name
    shIntSettings.SaveAs strUTF16FullPath = strUTF16FolderPath & "\" & strUTF8FileName
    shIntSettings
Next iArrayIndex




End Sub




Sub ChangeAllKeysheetsUrlInStartkeysInFolder()

'this will change the keysheets url in ***ALL*** the startkeys workbooks in the folder of the startkeys workbook selected.

Dim strWorkbookPath As String
Dim wb As Workbook
Dim sh As Worksheet
Dim rg As Range
Dim strURL As String

strWorkbookPath = Application.GetOpenFilename(, , "Browse to any Startkeys workbook in the folder...")
If strWorkbookPath = "False" Then
    'user clicked Cancel:
'    MsgBox "Operation has been cancelled.", vbOKOnly, "Change All Keysheets URLs in All Startkeys in Folder"
    AmazonMsgBox "Operation has been cancelled.", vbOKOnly, "Change All Keysheets URLs in All Startkeys in Folder"
    Exit Sub
End If

strURL = InputBox("Enter the new Keysheets URL to use for all Startkeys in that folder.", _
                "Change All Keysheets URLs in All Startkeys in Folder", "Enter URL here")
If strURL = "" Then
'    MsgBox "Operation has been cancelled.", vbOKOnly, "Change All Keysheets URLs in All Startkeys in Folder"
    AmazonMsgBox "Operation has been cancelled.", vbOKOnly, "Change All Keysheets URLs in All Startkeys in Folder"
    Exit Sub
End If

Dim fso As Object
Dim oFile As Object
Dim oFolder As Object
Set fso = CreateObject("Scripting.FileSystemObject")
Set oFile = fso.GetFile(strWorkbookPath)
Set oFolder = fso.GetFolder(oFile.ParentFolder)
For Each oFile In oFolder.Files
    Set wb = Workbooks.Open(oFile.Path)
    DoEvents
    Set sh = wb.Worksheets(1)
    Set rg = sh.Range("A2") '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    rg.value = strURL
    wb.Close SaveChanges:=True
    DoEvents
Next oFile

End Sub





Sub ChangeAllFeedTypesInStartkeysInFolder()

'this will change the keysheets url in ***ALL*** the startkeys workbooks in the folder of the startkeys workbook selected.

Dim strWorkbookPath As String
Dim wb As Workbook
Dim sh As Worksheet
Dim rg As Range
Dim strFeedType As String

strWorkbookPath = Application.GetOpenFilename(, , "Browse to any Startkeys workbook in the folder...")
If strWorkbookPath = "False" Then
    'user clicked Cancel:
'    MsgBox "Operation has been cancelled.", vbOKOnly, "Change All Feed Types in All Startkeys in Folder"
    AmazonMsgBox "Operation has been cancelled.", vbOKOnly, "Change All Feed Types in All Startkeys in Folder"
    Exit Sub
End If

strFeedType = InputBox("Enter the new Keysheets URL to use for all Startkeys in that folder.", _
                "Change All Feed Types in All Startkeys in Folder", "Enter URL here")
If strFeedType = "" Then
'    MsgBox "Operation has been cancelled.", vbOKOnly, "Change All Feed Types in All Startkeys in Folder"
    AmazonMsgBox "Operation has been cancelled.", vbOKOnly, "Change All Feed Types in All Startkeys in Folder"
    Exit Sub
End If

Dim fso As Object
Dim oFile As Object
Dim oFolder As Object
Set fso = CreateObject("Scripting.FileSystemObject")
Set oFile = fso.GetFile(strWorkbookPath)
Set oFolder = fso.GetFolder(oFile.ParentFolder)
For Each oFile In oFolder.Files
    Set wb = Workbooks.Open(oFile.Path)
    DoEvents
    Set sh = wb.Worksheets(1)
    Set rg = sh.Range("A14") ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    If rg.ColumnWidth < 60 Then
        rg.ColumnWidth = 60
    End If
    rg.value = strFeedType
    wb.Close SaveChanges:=True
    DoEvents
Next oFile

End Sub





Sub ChangeAllFeedTypesInTemplatesInFolder()

'this will change the feed type in ***ALL*** the templates in the folder of the template selected.

Dim strWorkbookPath As String
Dim wb As Workbook
Dim sh As Worksheet
Dim rg As Range
Dim strFeedType As String

strWorkbookPath = Application.GetOpenFilename(, , "Browse to any template workbook in the folder...")
If strWorkbookPath = "False" Then
    'user clicked Cancel:
'    MsgBox "Operation has been cancelled.", vbOKOnly, "Change All Feed Types in All templates in Folder"
    AmazonMsgBox "Operation has been cancelled.", vbOKOnly, "Change All Feed Types in All templates in Folder"
    Exit Sub
End If

strFeedType = InputBox("Enter the new Feed Type to use for all templates in that folder.", _
                "Change All Feed Types in All templates in Folder", "Enter Feed Type here")
If strFeedType = "" Then
'    MsgBox "Operation has been cancelled.", vbOKOnly, "Change All Feed Types in All templates in Folder"
    AmazonMsgBox "Operation has been cancelled.", vbOKOnly, "Change All Feed Types in All templates in Folder"
    Exit Sub
End If

Dim fso As Object
Dim oFile As Object
Dim oFolder As Object
Set fso = CreateObject("Scripting.FileSystemObject")
Set oFile = fso.GetFile(strWorkbookPath)
Set oFolder = fso.GetFolder(oFile.ParentFolder)
For Each oFile In oFolder.Files
    Set wb = Workbooks.Open(oFile.Path)
    DoEvents
    Set rg = wb.Names("Feed_Type").RefersToRange
    rg.value = strFeedType
    wb.Close SaveChanges:=True
    DoEvents
Next oFile

End Sub




Sub Convert_Selected_CamelCase_to_Hyphen_Formatting()

Dim rgCell As Range
Dim strBefore As String
Dim strAfter As String
Dim iLenBefore As Long
Dim i As Long
Dim strChar As String
Dim iAsc As Long, iAsc2 As Long
Dim iCountAdjacentCapitals As Long

For Each rgCell In Selection
    strBefore = rgCell.value
    strAfter = ""
    iLenBefore = Len(strBefore)
    iCountAdjacentCapitals = 0
'    strAfter = LCase(Mid(strBefore, 1, 1)) 'first character.
    For i = 1 To iLenBefore
        strChar = Mid(strBefore, i, 1)
        iAsc = Asc(strChar)
        If iAsc >= 65 And iAsc <= 90 Then
            'capital:
            iCountAdjacentCapitals = iCountAdjacentCapitals + 1
            'if this is the last capital before a lower-case character,
            'reset iCountAdjacentCapitals to 1:
            If i < iLenBefore Then
                iAsc2 = Asc(Mid(strBefore, i + 1, 1)) 'look ahead to next character.
                If iAsc2 >= 97 And iAsc <= 122 Then
                    'next character is lowercase:
                    iCountAdjacentCapitals = 1
                End If
            End If
            
            If iCountAdjacentCapitals >= 2 Then
                strAfter = strAfter & LCase(strChar)
            Else
                If i = 1 Then
                    'first character:
                    strAfter = LCase(strChar)
                Else
                    'not the first character:
                    strAfter = strAfter & "-" & LCase(strChar)
                End If
            End If
            
        Else
            'not a capital:
            iCountAdjacentCapitals = 0
            strAfter = strAfter & strChar
        End If
        
    Next i
    rgCell.value = strAfter
Next rgCell



End Sub





Sub AuditColumns_With_SavedWorkbook()
    Dim strPath As String, wb_check As Workbook
    Dim bScreenUpdating As Boolean, bDisplayAlerts As Boolean, bEnableEvents As Boolean
    bDisplayAlerts = Application.DisplayAlerts: bScreenUpdating = Application.ScreenUpdating: bEnableEvents = Application.EnableEvents
    Application.DisplayAlerts = False: Application.ScreenUpdating = False: Application.EnableEvents = False
    strPath = Application.GetOpenFilename(, , "Browse to ff template to check...")
    If strPath = "False" Then Exit Sub
    Set wb_check = Workbooks.Open(strPath, UpdateLinks:=0) '0 = do not update links.
    Call AuditColumns(wb_check)
    Application.DisplayAlerts = bDisplayAlerts: Application.ScreenUpdating = bScreenUpdating: Application.EnableEvents = bEnableEvents
End Sub




Public Sub AuditColumnsFromSub(wb_check As Workbook)
Call AuditColumns(wb_check)
End Sub




Public Function AuditColumns(wb_check As Workbook) As Workbook 'returns report workbook.

On Error GoTo GenErr
Dim shWS As Worksheet
Dim wbRpt As Workbook
Dim shRpt As Worksheet
Dim iSheet As Long
Dim shArrayTemplateSheets() As Worksheet
Dim iUboundTS As Long
Dim iIndexTS As Long
Dim shTS As Worksheet
Dim shArrayNotTemplateSheets() As Worksheet
Dim iUboundNotTS As Long
Dim iIndexNotTs As Long
Dim shNotTS As Worksheet
Dim iArrayIndexTemplateSheets As Long
Dim strArrayTryAuditColumns() As String
Dim shTemplate As Worksheet
Dim iTemplateHeaderRow As Long
Dim iLastTemplateHeaderColNum As Long
Dim iHeaderCol As Long
Dim iHeaderRow As Long
Dim strHeader As String
Dim iIndexTAC As Long
Dim iUboundTAC As Long
Dim iArrayColsFound() As Long
    'Col 1 is row found in.
    'Col 2 is how many found in that row.
Dim iUboundRF As Long
Dim iIndexRF As Long
Dim rgFind As Range
Dim rgPrevious As Range
Dim rgFirst As Range
Dim iColFound As Long
Dim iRowFound As Long
Dim iDdefCol As Long
Dim iVVRowThisSheet As Long
Dim iVVRowAllSheets As Long
Dim bAlreadyFound As Boolean
Dim bDataDefFound As Boolean
Dim shDdef As Worksheet
Dim bVVFound As Boolean
Dim shVV As Worksheet
Dim iDdefFirstRow As Long
Dim iDdefLastRow As Long
Dim iVVLastRow As Long
Dim iTemplateLastRow As Long
Dim iDdefRow As Long
Dim iRow As Long
Dim rgCell As Range
Dim rgDdefCell As Range
Dim iPos As Long
Dim iLastNum As Long
Dim iRptCol As Long
Dim iLastRptCol As Long
Dim iRptVVColOrig As Long
Dim iRptVVColReduced As Long
Dim rgRptDdef As Range
Dim rgRptVV As Range
Dim rgRptTemplateSheet As Range
Dim rgRptAllTemplateSheets As Range
Dim iRangeIndex As Long
Dim iRangeCount As Long
Dim oComment As Comment
Dim bNotFoundInDdef As Boolean
Dim rgTmp As Range
Dim bBlockCounterOn As Boolean
Dim iBlockCounter As Long
Dim iBlockTopRow As Long
Dim rgFindNext As Range
Dim rgPrevFindNext As Range
Dim bAssumeWrongMatch As Boolean
Dim iLookaheadMatchCount As Long
Dim iLookaheadAltMatchCount As Long
Dim iAltLookaheadMatchCount As Long
Dim bAltLookaheadFound As Boolean
Dim iLookaheadLoopCounter As Long
Dim iAltLookaheadLoopCounter As Long
Dim iProbableErrorsCount As Long
Dim iOtherPossibleErrorsCount As Long
Dim iMaxFoundInARowThisSheet As Long
Dim iMaxFoundInARowAllSheets As Long
Dim iNumColsFoundInThisRow As Long
Dim shMostFoundSoFar As Worksheet
Dim strArrayDdefColNamesOutOfOrder() As String
Dim iUboundDCNOOO As Long
Dim iIndexDCNOOO As Long
Dim bLookbehindFound As Boolean
Dim bDisplayAlerts As Boolean
Dim bScreenUpdating As Boolean
Dim bNoCellsFound As Boolean
Dim rgDdefInitialRange As Range
Dim strCellAddressProbableErrors As String
Dim iErrorCountNBIDD As Long 'Not Bold in Data Definition tab.
Dim iErrorCountNBIT As Long 'Not Bold in Template tab.
Const DDEF_ORIG_COL As Long = 1
Const DDEF_EXPANDED_COL As Long = 2
Const DDEF_REDUCED_COL As Long = 3
Const FIRST_TEMPLATE_COL As Long = 4 'before removing columns.

Const RPT_FIRST_DATA_ROW As Long = 3

bDisplayAlerts = Application.DisplayAlerts
bScreenUpdating = Application.ScreenUpdating
Application.DisplayAlerts = False
Application.ScreenUpdating = False

'get array of template sheets:
iUboundTS = 0: iUboundNotTS = 0 'init.
ReDim shArrayTemplateSheets(0 To 0): ReDim shArrayNotTemplateSheets(0 To 0) 'init.
For Each shWS In wb_check.Worksheets
    If InStr(shWS.CodeName, "shTemplate") > 0 Then
        'it's a template sheet:
        iUboundTS = iUboundTS + 1
        ReDim Preserve shArrayTemplateSheets(0 To iUboundTS)
        Set shArrayTemplateSheets(iUboundTS) = shWS
    Else
        'it's not a template sheet:
        iUboundNotTS = iUboundNotTS + 1
        ReDim Preserve shArrayNotTemplateSheets(0 To iUboundNotTS)
        Set shArrayNotTemplateSheets(iUboundNotTS) = shWS
    End If
Next shWS
If iUboundTS = 0 Then
    MsgBox "No template sheets found.", vbCritical + vbOKOnly, "Columns Check"
    Application.DisplayAlerts = bDisplayAlerts: Application.ScreenUpdating = bScreenUpdating
    Exit Function
End If

'start with just one template sheet to get a list of columns to look for in ddef and vv:
Set shTemplate = shArrayTemplateSheets(1)
'get header row:
iTemplateHeaderRow = GetTemplateHeaderRow(shTemplate)
'get last header column:
iLastTemplateHeaderColNum = shTemplate.Cells(iTemplateHeaderRow, shTemplate.Columns.Count).End(xlToLeft).Column
ReDim strArrayTryAuditColumns(0 To 0) As String 'init.
iUboundTAC = 0 'init.
For iHeaderCol = 1 To iLastTemplateHeaderColNum
    strHeader = shTemplate.Cells(iTemplateHeaderRow, iHeaderCol).value
    If RegexTest("[0-9]", strHeader) Then
        'do not use, because it has a digit.
    Else
        'does not have a digit, so use it:
        iUboundTAC = iUboundTAC + 1
        ReDim Preserve strArrayTryAuditColumns(0 To iUboundTAC) As String
        strArrayTryAuditColumns(iUboundTAC) = strHeader
    End If
Next iHeaderCol


'look for ddef sheet:
bDataDefFound = False 'init.
ReDim iArrayColsFound(1 To 2, 1 To 10) As Long
    'Col 1 is row found in.
    'Col 2 is how many found in that row.
iUboundRF = 0 'init.
For iIndexNotTs = 1 To iUboundNotTS
    Set shNotTS = shArrayNotTemplateSheets(iIndexNotTs)
    If Not shNotTS.Visible Then GoTo SkipSheetDdef
    If InStr(UCase(shNotTS.Name), "DROPDOWN LISTS") > 0 Then GoTo SkipSheetDdef
    For iIndexTAC = 1 To 10 'search for 10 for ddef, all for vv.
        strHeader = strArrayTryAuditColumns(iIndexTAC)
        Set rgFind = shNotTS.Cells.Find(What:=strHeader, LookAt:=xlWhole, MatchCase:=False)
        If Not rgFind Is Nothing Then
            iColFound = rgFind.Column 'column for ddef, row for vv.
            'check for whether that Col has already been found:
            bAlreadyFound = False 'init.
            For iIndexRF = 1 To iUboundRF
                If iArrayColsFound(1, iIndexRF) = iColFound Then
                    bAlreadyFound = True
                    iArrayColsFound(2, iIndexRF) = iArrayColsFound(2, iIndexRF) + 1
                    If iArrayColsFound(2, iIndexRF) >= 7 Then
                        bDataDefFound = True
                        iDdefCol = iColFound
                    End If
                    Exit For
                End If
            Next iIndexRF
            'add if not already there:
            If Not bAlreadyFound Then
                iUboundRF = iUboundRF + 1
                iArrayColsFound(1, iUboundRF) = iColFound
                iArrayColsFound(2, iUboundRF) = 1
            End If
        End If
        If bDataDefFound Then Exit For
    Next iIndexTAC
    If bDataDefFound Then
        Set shDdef = shNotTS
        Exit For
    End If
SkipSheetDdef:
Next iIndexNotTs
If Not bDataDefFound Then
    MsgBox "No Data Definition sheet found.", vbCritical + vbOKOnly, "Columns Check"
    Application.DisplayAlerts = bDisplayAlerts
    Exit Function
End If


'start report:
Set wbRpt = Workbooks.Add
Set shRpt = wbRpt.Worksheets(1)
shRpt.Name = "~ ~ ~ DETAILS ~ ~ ~"

Do Until wbRpt.Worksheets.Count = 1
    wbRpt.Worksheets(wbRpt.Worksheets.Count).Delete
Loop
iProbableErrorsCount = 0 'init.
iOtherPossibleErrorsCount = 0 'init.
iErrorCountNBIDD = 0 'init.
iErrorCountNBIT = 0 'init.

'add ddef to report:
iDdefLastRow = shDdef.Cells(shDdef.Rows.Count, iDdefCol).End(xlUp).Row
Set rgFind = shDdef.Columns(iDdefCol).Find(What:="sku", LookAt:=xlWhole, MatchCase:=False)
If rgFind Is Nothing Then
    iDdefFirstRow = 4
Else
    iDdefFirstRow = rgFind.Row
End If
wb_check.Activate: shDdef.Activate: DoEvents
'iDdefFirstRow = InputBox("What is the first row number with a column name in the Data Definitions sheet?", "Data Def First Column-Name Row", iDdefFirstRow) 'this would break doing groups of builds overnight.
Call ResetFindParametersToDefaults
shDdef.Range(shDdef.Cells(iDdefFirstRow, iDdefCol), shDdef.Cells(iDdefLastRow, iDdefCol)).SpecialCells(xlCellTypeConstants, 23).Copy '23 = constants (deselects blank cells).
wbRpt.Activate: shRpt.Activate: shRpt.Cells(RPT_FIRST_DATA_ROW, DDEF_ORIG_COL).Select: DoEvents
ActiveSheet.Paste
Set rgDdefInitialRange = Selection
shRpt.Cells(RPT_FIRST_DATA_ROW, DDEF_EXPANDED_COL).Select: DoEvents
ActiveSheet.Paste
Selection.Offset(, -1).Resize(, 2).Select
Selection.WrapText = False
Selection.UnMerge
bNoCellsFound = False 'init.
Selection.SpecialCells(xlCellTypeBlanks).Select
If Not bNoCellsFound Then Selection.Delete (xlUp) 'delete only if blank cells found and selected; otherwise ignore.
Selection.EntireColumn.AutoFit
Call AuditCols_BadChars(rgDdefInitialRange, iProbableErrorsCount)
shRpt.Range("A1").value = "Data Def"
shRpt.Range("A2").value = """" & shDdef.Name & """ tab"
With shRpt.Range("A1:A2")
    .Font.Italic = True
    .Font.Bold = True
    .Font.ThemeColor = xlThemeColorDark1
    .Interior.ThemeColor = xlThemeColorLight1
    .Interior.TintAndShade = 0.349986266670736
End With
shRpt.Range("B1").value = "Data Def Expanded"
shRpt.Range("B1").Font.Italic = True
shRpt.Range("B1").EntireColumn.ColumnWidth = 0.2 'shRpt.Range("B1").EntireColumn.Hidden = True


'expand for numbered columns, for comparison to template sheets:
Dim rgCheckBoldface As Range
Dim rgFirstNumberedCol As Range, rgNumberedColSet As Range
iDdefLastRow = shRpt.Cells(shRpt.Rows.Count, 1).End(xlUp).Row
iRow = 1 'init.
Do
    Set rgCell = shRpt.Cells(iRow, 1)
    strHeader = rgCell.value
    iPos = InStr(strHeader, "1")
    If iPos > 0 Then
        iLastNum = GetTrailingNum(strHeader)
        If iLastNum > 1 Then
            Set rgFirstNumberedCol = rgCell.Offset(, 1)
            rgFirstNumberedCol.value = Left(strHeader, iPos)
            shRpt.Cells(iRow + 1, 1).Resize(iLastNum - 1, 2).Select
            Selection.Insert Shift:=xlDown
            Set rgNumberedColSet = rgFirstNumberedCol.Resize(iLastNum)
            rgFirstNumberedCol.AutoFill Destination:=rgNumberedColSet
            iDdefLastRow = iDdefLastRow + (iLastNum - 1)
            
            'repair boldface:
            Dim rgCheckBoldfaceCell As Range
            Dim iCheckBoldfacePos As Long, iTmpPos As Long, iCheckBoldfaceLen As Long, iCheckBoldfaceLast As Long
            Dim bIsBoldface As Boolean
            For Each rgCheckBoldfaceCell In rgNumberedColSet.Cells
                iCheckBoldfacePos = InStr(rgCell.value, rgCheckBoldfaceCell.value)
                iCheckBoldfaceLen = Len(rgCheckBoldfaceCell.value)
                iCheckBoldfaceLast = (iCheckBoldfacePos + iCheckBoldfaceLen) - 1
                If iCheckBoldfacePos > 0 Then
                    bIsBoldface = True 'init.
                    For iTmpPos = iCheckBoldfacePos To iCheckBoldfaceLast
                        If Not rgCell.Characters(iTmpPos, 1).Font.Bold Then
                            bIsBoldface = False
                            Exit For
                        End If
                    Next iTmpPos
                Else
                    bIsBoldface = False
                End If
                
                If bIsBoldface Then
                    rgCheckBoldfaceCell.Font.Bold = True
                End If
            Next rgCheckBoldfaceCell
            
            
        End If
        iRow = iRow + iLastNum
    Else
        iRow = iRow + 1
    End If
Loop Until iRow > iDdefLastRow


'reduce numbered columns, for comparison to valid values sheet:
shRpt.Columns(DDEF_EXPANDED_COL).EntireColumn.Copy Destination:=shRpt.Columns(DDEF_REDUCED_COL).EntireColumn 'copies as hidden since source is hidden.
shRpt.Range("C1").value = "Data Def Reduced"
Set rgTmp = shRpt.Range(shRpt.Cells(RPT_FIRST_DATA_ROW, DDEF_REDUCED_COL), shRpt.Cells(iDdefLastRow, DDEF_REDUCED_COL))
For Each rgCell In rgTmp.Cells
    rgCell.value = RegexReplace(rgCell.value, "[0-9]", "") 'remove digits.
Next rgCell
rgTmp.RemoveDuplicates Columns:=1


'get ddef comparision range:
Set rgRptDdef = shRpt.Range(shRpt.Cells(RPT_FIRST_DATA_ROW, DDEF_EXPANDED_COL), shRpt.Cells(iDdefLastRow, DDEF_EXPANDED_COL))

'add template sheets to report:
iRptCol = FIRST_TEMPLATE_COL 'init.
For iIndexTS = 1 To iUboundTS
    Set shTS = shArrayTemplateSheets(iIndexTS)
    iUboundDCNOOO = 0 'init for each ddef sheet.
    iHeaderRow = GetTemplateHeaderRow(shTS)
    iLastTemplateHeaderColNum = shTS.Cells(iHeaderRow, shTS.Columns.Count).End(xlToLeft).Column
    shTS.Range(shTS.Cells(iHeaderRow, 1), shTS.Cells(iHeaderRow, iLastTemplateHeaderColNum)).Copy
    wbRpt.Activate: shRpt.Activate: shRpt.Cells(RPT_FIRST_DATA_ROW, iRptCol).Select: DoEvents
    ActiveCell.PasteSpecial Transpose:=True
    shRpt.Cells(1, iRptCol).value = "Template Sheet"
    shRpt.Cells(1, iRptCol).Font.Italic = True
    shRpt.Cells(2, iRptCol).value = """" & shTS.Name & """ tab"
    shRpt.Cells(2, iRptCol).Font.Italic = True
    With shRpt.Range(shRpt.Cells(1, iRptCol), shRpt.Cells(2, iRptCol))
        .WrapText = False
        .EntireColumn.AutoFit
        .Font.Italic = True
        .Font.Bold = True
        .Font.ThemeColor = xlThemeColorDark1
        .Interior.ThemeColor = xlThemeColorLight1
        .Interior.TintAndShade = 0.349986266670736
    End With
    
    'compare template sheets to ddef:
    iTemplateLastRow = shRpt.Cells(shRpt.Rows.Count, iRptCol).End(xlUp).Row
    Set rgRptTemplateSheet = shRpt.Range(shRpt.Cells(RPT_FIRST_DATA_ROW, iRptCol), shRpt.Cells(iTemplateLastRow, iRptCol))
    'check that everything in the template sheet appears in the ddef:
    Call AuditCols_BadChars(rgRptTemplateSheet, iProbableErrorsCount)
    For Each rgCell In rgRptTemplateSheet
        Set rgFind = rgRptDdef.Find(What:=rgCell.value, LookIn:=xlValues, LookAt:=xlWhole, MatchCase:=True)
        If rgFind Is Nothing Then
            Call AuditCols_NotFoundInDdef(rgCell)
        Else
            'check boldface:
            If rgCell.Font.Bold <> rgFind.Font.Bold Then
                iProbableErrorsCount = iProbableErrorsCount + 1
                Call AuditCols_BoldfaceDiscrepancy(rgCell, rgFind.Offset(, -1), iErrorCountNBIDD, iErrorCountNBIT)
            End If
        End If
        DoEvents
    Next rgCell
    
    
    
    'check for same column order between template sheets and ddef:
    iRangeIndex = 1 'init.
    iRangeCount = rgRptDdef.Cells.Count
    For Each rgCell In rgRptTemplateSheet.Cells
        If rgRptDdef(iRangeIndex).Row > iDdefLastRow Then Exit For
'        Debug.Print rgCell.Address, rgCell.value
        Set oComment = rgCell.Comment
        If oComment Is Nothing Then
            bNotFoundInDdef = False
        Else
            'has comment:
            If InStr(UCase(oComment.Text), "NOT FOUND") > 0 Then
                bNotFoundInDdef = True
            Else
                bNotFoundInDdef = False
            End If
        End If
        
        If rgCell.value = rgRptDdef(iRangeIndex).value Then
            '=====================================================================================
            'They match, but check whether it's the right match.
            'IF:
                'there's another one later on to match on, ***AND***:
                'at least two of the next three don't match (don't just check the next one because
                'it could be a UOM for this one), ***AND***:
                'the non-matching ddef lookaheads have matches available later on in the template
                'sheet:
            'THEN:
                'assume this is not the correct match:
            '=====================================================================================
            bAssumeWrongMatch = False 'init.
            Set rgFindNext = rgRptDdef.Find(What:=rgCell.value, After:=rgRptDdef(iRangeIndex), LookIn:=xlValues, LookAt:=xlWhole)
            If rgFindNext.Row > rgRptDdef(iRangeIndex).Row Then
                'there is another possible match later on.
                iLookaheadMatchCount = 0: iLookaheadAltMatchCount = 0 'init.
                For iLookaheadLoopCounter = 1 To 3
                    If rgCell.Offset(iLookaheadLoopCounter).value = rgRptDdef(iRangeIndex).Offset(iLookaheadLoopCounter).value Then
                        iLookaheadMatchCount = iLookaheadMatchCount + 1
                    Else
                        'the lookahead doesn't match, but may still count if it appears to be
                        'not relevant to this template sheet.
                        'check for match to ddef side later on in template side:
                        Set rgFindNext = rgRptTemplateSheet.Find(What:=rgRptDdef(iRangeIndex).Offset(iLookaheadLoopCounter).value, After:=rgCell.Offset(iLookaheadLoopCounter), LookIn:=xlValues, LookAt:=xlWhole)
                            If rgFindNext Is Nothing Then
                                'count this as a match because it's a ddef col that doesn't exist
                                'in template sheet; therefore the ddef col is probably
                                'in a section for another template sheet:
                                iLookaheadAltMatchCount = iLookaheadAltMatchCount + 1
                                iLookaheadMatchCount = iLookaheadMatchCount + 1
                                
                                

                                
                                
                            Else
                                If rgFindNext.Row <= rgCell.Offset(iLookaheadLoopCounter).Row Then
                                    'count this as a match because it's a ddef col that doesn't exist
                                    '*later on* in template sheet; therefore the ddef col is probably
                                    'in a section for another template sheet:
                                    iLookaheadMatchCount = iLookaheadMatchCount + 1
                                End If
                            End If
                    End If
                    DoEvents
                Next iLookaheadLoopCounter



                'but wait, if ddef contains another match to template sheet column further
                'down, that may be the correct match. Two steps are needed here: (a) look
                'further down ddef to find matches for rgCell.value, and (b) for each match
                'found, check its lookaheads. If the lookaheads match (iAltLookaheadMatchCount)
                'for any of the further-down matches, then that is probably the correct match:
                bAltLookaheadFound = False 'init to False even if the rest of this section is skipped.
                If iLookaheadAltMatchCount > 1 Then
                Set rgPrevFindNext = rgRptDdef(iRangeIndex)
                    Do
                        Set rgFindNext = rgRptDdef.Find(What:=rgCell.value, After:=rgPrevFindNext, LookIn:=xlValues, LookAt:=xlWhole, MatchCase:=False)
                        If rgFindNext.Row = rgRptDdef(iRangeIndex).Row Then Exit Do
                        'found another match for rgCell.value, so check lookaheads:
                        iAltLookaheadMatchCount = 0 'init for each rgFindNext.
                        For iAltLookaheadLoopCounter = 1 To 3
                            If rgCell.Offset(iAltLookaheadLoopCounter).value = rgFindNext.Offset(iAltLookaheadLoopCounter).value Then
                                iAltLookaheadMatchCount = iAltLookaheadMatchCount + 1
                                'if 2 of the 3 lookaheads match, assume this lookahead may be the correct match:
                                If iAltLookaheadMatchCount >= 2 Then bAltLookaheadFound = True
                            End If
'                            If bAltLookaheadFound Then Exit For 'no, get full count.
                            DoEvents
                        Next iAltLookaheadLoopCounter
                        If bAltLookaheadFound Then Exit Do
                        Set rgPrevFindNext = rgFindNext
                        DoEvents
                    Loop
                End If



                If iLookaheadMatchCount <= 1 Or bAltLookaheadFound Then
                    'assume this is NOT the correct match. Treat the same as ddef col not found in template sheet:
                    bAssumeWrongMatch = True
                    
                    'but wait, if the first match was just as good, use it instead:
                    If iLookaheadMatchCount >= iAltLookaheadMatchCount Then
                        bAssumeWrongMatch = False
                        
                        'but in that case, if using the first match would end a block,
                        'then it's probably NOT the correct match:
                        If bBlockCounterOn Then
                            bAssumeWrongMatch = True
                        End If
                        
                    End If
                    
                End If
                
            End If
            
            If bAssumeWrongMatch Then
                iProbableErrorsCount = iProbableErrorsCount + 1
                Call AuditCols_DdefColNotFoundInTemplate(rgCell, rgRptDdef(iRangeIndex), bBlockCounterOn, iBlockCounter, iBlockTopRow)
            Else
                If bBlockCounterOn Then
                    bBlockCounterOn = False
                    If iBlockCounter > 5 Then
                        Set rgTmp = shRpt.Cells(iBlockTopRow, iRptCol)
                        rgTmp.Interior.Color = RGB(255, 255, 255) 'white.
                        rgTmp.value = "Data Definitions sheet has " & iBlockCounter & " columns here."
                        rgTmp.Offset(5).Copy Destination:=rgTmp.Offset(1).Resize(4)
                        iProbableErrorsCount = iProbableErrorsCount - iBlockCounter
                        iOtherPossibleErrorsCount = iOtherPossibleErrorsCount + iBlockCounter
                    End If
                End If
            End If
        ElseIf bNotFoundInDdef Then
            'this template sheet column wasn't found in data def:
            iProbableErrorsCount = iProbableErrorsCount + 1
            Call AuditCols_TemplateColNotFoundInDdef(rgRptDdef(iRangeIndex), rgCell, rgCell, bBlockCounterOn, iBlockCounter, iBlockTopRow, FIRST_TEMPLATE_COL, rgRptTemplateSheet.Column - 1)
        Else
            'this data def column wasn't found in template sheet:
            iProbableErrorsCount = iProbableErrorsCount + 1
            bLookbehindFound = False 'init.
            For iIndexDCNOOO = 1 To iUboundDCNOOO
                If rgCell.value = strArrayDdefColNamesOutOfOrder(iIndexDCNOOO) Then
                    bLookbehindFound = True
                    strArrayDdefColNamesOutOfOrder(iIndexDCNOOO) = "_FOUND_" 'so that it is not used more than once.
                    bBlockCounterOn = False
                    Call AuditCols_TemplateColNotFoundInDdef(rgRptDdef(iRangeIndex), rgCell, rgCell, bBlockCounterOn, iBlockCounter, iBlockTopRow, FIRST_TEMPLATE_COL, rgRptTemplateSheet.Column - 1)
                    Exit For
                End If
                DoEvents
            Next iIndexDCNOOO
            If Not bLookbehindFound Then
                iUboundDCNOOO = iUboundDCNOOO + 1
                ReDim Preserve strArrayDdefColNamesOutOfOrder(0 To iUboundDCNOOO)
                strArrayDdefColNamesOutOfOrder(iUboundDCNOOO) = rgRptDdef(iRangeIndex).value
                Call AuditCols_DdefColNotFoundInTemplate(rgCell, rgRptDdef(iRangeIndex), bBlockCounterOn, iBlockCounter, iBlockTopRow)
            End If
        End If
        iRangeIndex = iRangeIndex + 1
        DoEvents
    Next rgCell
    iRptCol = iRptCol + 1
    DoEvents
Next iIndexTS
iLastRptCol = iRptCol - 1




'look for valid values sheet:
bVVFound = False 'init.
iMaxFoundInARowAllSheets = 0 'init
iVVRowAllSheets = 0 'init.
For iIndexNotTs = 1 To iUboundNotTS
    Set shNotTS = shArrayNotTemplateSheets(iIndexNotTs)
'    Debug.Print "======================================"
'    Debug.Print shNotTS.Name
'    Debug.Print "======================================"
    If Not shNotTS.Visible Then GoTo SkipSheetVV
    If InStr(UCase(shNotTS.Name), "DROPDOWN LISTS") > 0 Then GoTo SkipSheetVV
    ReDim iArrayColsFound(1 To 2, 0 To 0) As Long 'init for each sheet
        'Col 1 is row found in.
        'Col 2 is how many found in that row.
    iMaxFoundInARowThisSheet = 0 'init for each sheet
    iVVRowThisSheet = 0 'init for each sheet
    iUboundRF = 0 'init for each sheet
    For iIndexTAC = 1 To iUboundTAC 'search for 10 for ddef, all for vv.
        strHeader = strArrayTryAuditColumns(iIndexTAC)
        Set rgFind = shNotTS.Cells.Find(What:=strHeader, LookAt:=xlWhole, MatchCase:=False)
        If Not rgFind Is Nothing Then
            iRowFound = rgFind.Row 'column for ddef, row for vv.
            'check for whether that Col has already been found:
            bAlreadyFound = False 'init.
            For iIndexRF = 1 To iUboundRF
                If iArrayColsFound(1, iIndexRF) = iRowFound Then
                    iNumColsFoundInThisRow = iArrayColsFound(2, iIndexRF) + 1
'                    Debug.Print iNumColsFoundInThisRow, strHeader
                    iArrayColsFound(2, iIndexRF) = iNumColsFoundInThisRow
                    If iNumColsFoundInThisRow > iMaxFoundInARowThisSheet Then
                        iMaxFoundInARowThisSheet = iNumColsFoundInThisRow
                        iVVRowThisSheet = iRowFound
                    End If
                    Exit For
                End If
            Next iIndexRF
            'add if not already there:
            If Not bAlreadyFound Then
'                Debug.Print 1, strHeader
                iUboundRF = iUboundRF + 1
                ReDim Preserve iArrayColsFound(1 To 2, 0 To iUboundRF) As Long
                iArrayColsFound(1, iUboundRF) = iRowFound
                iArrayColsFound(2, iUboundRF) = 1
            End If
        Else
'            Debug.Print "NOT FOUND: " & strHeader
        End If
    Next iIndexTAC
    Debug.Print shNotTS.Name, iMaxFoundInARowThisSheet
    If iMaxFoundInARowThisSheet > iMaxFoundInARowAllSheets Then
        iMaxFoundInARowAllSheets = iMaxFoundInARowThisSheet
        Set shMostFoundSoFar = shNotTS
        iVVRowAllSheets = iVVRowThisSheet
        bVVFound = True
    End If
SkipSheetVV:
Next iIndexNotTs
Set shVV = shMostFoundSoFar
If Not bVVFound Then
'    Debug.Print "No Valid Values sheet found. Skipping Valid Values check."
'    Application.DisplayAlerts = bDisplayAlerts: Application.ScreenUpdating = bScreenUpdating
'    Exit Sub
End If


iRptVVColOrig = iRptCol + 1
iRptVVColReduced = iRptVVColOrig + 1
        
If bVVFound Then
    'add vv to report:
        shVV.Rows(iVVRowAllSheets).EntireRow.SpecialCells(xlCellTypeConstants, 23).Copy '23 = constants (deselects blank cells).
        wbRpt.Activate: shRpt.Activate: shRpt.Cells(RPT_FIRST_DATA_ROW, iRptVVColOrig).Select: DoEvents
        Selection.PasteSpecial Transpose:=True
        shRpt.Cells(RPT_FIRST_DATA_ROW, iRptVVColReduced).Select: DoEvents
        Selection.PasteSpecial Transpose:=True
        Selection.Offset(, -1).Resize(, 2).Select
        Selection.WrapText = False
        Selection.EntireColumn.AutoFit
        shRpt.Cells(1, iRptVVColOrig).value = "Valid Values"
        shRpt.Cells(2, iRptVVColOrig).value = """" & shVV.Name & """ tab"
        With shRpt.Range(shRpt.Cells(1, iRptVVColOrig), shRpt.Cells(2, iRptVVColReduced))
            .Font.Italic = True
            .Font.Bold = True
            .Font.Color = 12611584 'blue; need to make vv stand out from template sheets.
            .Interior.Color = 49407 'orange; need to make vv stand out from template sheets.
        End With
        Call AuditCols_AddComment(shRpt.Cells(1, iRptVVColOrig), "For Valid Values tabs, the only checking this report does is to make sure that every column name that appears in the Valid Values tab also appears in the Data Definitions tab.", , , True)
        shRpt.Cells(1, iRptVVColReduced).value = "VV Reduced"
        shRpt.Cells(1, iRptVVColReduced).Font.Italic = True
        shRpt.Cells(1, iRptVVColReduced).EntireColumn.ColumnWidth = 0.2
        'shRpt.Cells(1, iRptVVColReduced).EntireColumn.Hidden = True
    
    'unmerge:
    Selection.UnMerge
    bNoCellsFound = False 'init.
    Selection.SpecialCells(xlCellTypeBlanks).Select
    If Not bNoCellsFound Then Selection.Delete (xlUp) 'delete only if blank cells found and selected; otherwise ignore.
    
    'reduce numbered columns in iRptVVColReduced, for comparison to data def:
    iVVLastRow = shRpt.Cells(shRpt.Rows.Count, iRptVVColReduced).End(xlUp).Row
    Set rgRptVV = shRpt.Range(shRpt.Cells(RPT_FIRST_DATA_ROW, iRptVVColReduced), shRpt.Cells(iVVLastRow, iRptVVColReduced))
    For Each rgCell In rgRptVV.Cells
        rgCell.value = Trim(RegexReplace(rgCell.value, "1.*", "")) 'remove digits, and leading & trailing spaces.
    Next rgCell
    rgRptVV.RemoveDuplicates Columns:=1
    
    'get ddef comparision range (all three ddef columns -- original, expanded, and reduce):
    Set rgRptDdef = shRpt.Range(shRpt.Cells(RPT_FIRST_DATA_ROW, DDEF_ORIG_COL), shRpt.Cells(iDdefLastRow, DDEF_REDUCED_COL))
    
    'compare vv to ddef:
    For Each rgCell In rgRptVV.Cells
        Set rgFind = rgRptDdef.Find(What:=rgCell.value, LookIn:=xlValues, LookAt:=xlWhole, MatchCase:=True)
        If rgFind Is Nothing Then
            'this vv column not found in ddef:
            iProbableErrorsCount = iProbableErrorsCount + 1
            Call AuditCols_NotFoundInDdef(rgCell.Offset(, -1))
        End If
    Next rgCell
Else
    shRpt.Cells(1, iRptVVColOrig).value = "(No Valid Values tab found.)"
End If




'look for ddef cols not found in any template col:
Dim strCommentText As String
Dim rgAllTemplateCols As Range
Dim rgDdefCommentCell As Range
If iLastRptCol = FIRST_TEMPLATE_COL Then
    strCommentText = "Not found in template sheet."
Else
    strCommentText = "Not found in any template sheet."
End If
Set rgRptDdef = shRpt.Range(shRpt.Cells(RPT_FIRST_DATA_ROW, DDEF_EXPANDED_COL), shRpt.Cells(iDdefLastRow, DDEF_EXPANDED_COL))
Set rgAllTemplateCols = shRpt.Columns(FIRST_TEMPLATE_COL).EntireColumn.Resize(, 1 + (iLastRptCol - FIRST_TEMPLATE_COL))
For Each rgDdefCell In rgRptDdef
    Set rgFind = rgAllTemplateCols.Find(What:=rgDdefCell.value, LookIn:=xlValues, LookAt:=xlWhole, MatchCase:=True)
    If rgFind Is Nothing Then
        If InStr(UCase(rgDdefCell.value), "TEMPLATE SHEET HAS") = 0 Then
        'does not contain the text "Template sheet has...", so proceed:
            Set rgDdefCommentCell = rgDdefCell.Offset(, -1)
            Call AuditCols_AddComment(rgDdefCommentCell, strCommentText)
        End If
    End If
Next rgDdefCell




'remove temp columns:
If bVVFound Then shRpt.Columns(iRptVVColReduced).EntireColumn.Delete
shRpt.Columns(DDEF_REDUCED_COL).EntireColumn.Delete
shRpt.Columns(DDEF_EXPANDED_COL).EntireColumn.Delete
shRpt.Columns.AutoFit: shRpt.Rows.AutoFit



Dim iArea As Long
For Each oComment In shRpt.Comments
    With oComment.Shape
        .Top = oComment.Parent.Top - 7.5
        .Left = oComment.Parent.Offset(0, 1).Left + 11
        .TextFrame.AutoSize = True
    End With
'    If oComment.Shape.Width > 300 Then
'        iArea = oComment.Shape.Width * oComment.Shape.Height
'        oComment.Shape.Width = 200
'        oComment.Shape.Height = (iArea / 200) * 1.1
'    End If
Next oComment

shRpt.Range("A1").Select
    With ActiveWindow
        .ScrollRow = 1
        .ScrollColumn = 1
        .SplitRow = 2
        .SplitColumn = 1
        .FreezePanes = True
    End With



'summary tab:
Const SUMMARY_TAB_TITLE_ROW As Long = 1
Const SUMMARY_TAB_PROBABLE_ERRORS_ROW As Long = 3
Const SUMMARY_TAB_POSSIBLE_ERRORS_ROW As Long = 4
Const SUMMARY_TAB_SEE_DETAILS_ROW As Long = 6
Const SUMMARY_TAB_CELL_ADDRESSES_ROW As Long = 7


wbRpt.Worksheets.Add 'Before:=1
With wbRpt.Worksheets(1)
    .Name = "Summary"
    .Cells(SUMMARY_TAB_TITLE_ROW, 1).value = "Columns Comparison Report for:  " & wb_check.Name
    .Cells(SUMMARY_TAB_TITLE_ROW, 1).Font.Bold = True
    .Cells(SUMMARY_TAB_PROBABLE_ERRORS_ROW, 1).value = "Probable errors found: " & iProbableErrorsCount
    .Cells(SUMMARY_TAB_POSSIBLE_ERRORS_ROW, 1).value = "Other possible errors found: " & iOtherPossibleErrorsCount
    With Cells(SUMMARY_TAB_SEE_DETAILS_ROW, 1)
        .value = "See details on DETAILS tab."
        .Font.Color = -16776961
        .Font.Bold = True
        .Font.Italic = True
    End With
    .Range("A1:A6").Font.Size = 14
    Range("A10").Select
End With
ActiveWindow.DisplayGridlines = False



'put addresses of cells with errors on summary page:
Dim rgComments As Range
Dim rgCommentErrorRange As Range, rgErrorTextRange As Range, rgAllErrorsRange As Range
Dim strErrorRangePrefex As String
bNoCellsFound = False 'init.
Set rgComments = wbRpt.Worksheets(2).Cells.SpecialCells(xlCellTypeComments)
If bNoCellsFound Then
    'do nothing  here.
Else
    For Each rgCell In rgComments.Cells
        If InStr(rgCell.Comment.Text, "For Valid Values tabs") = 0 Then 'excludes the comment on the vv header.
            If rgCommentErrorRange Is Nothing Then
                Set rgCommentErrorRange = rgCell
            Else
                Set rgCommentErrorRange = Application.Union(rgCommentErrorRange, rgCell)
            End If
        End If
    Next rgCell
End If
Set rgFind = wbRpt.Worksheets(2).Cells.Find(What:=" sheet has", LookIn:=xlValues, LookAt:=xlPart, SearchOrder:=xlByColumns, MatchCase:=False)
Set rgPrevious = rgFind: Set rgFirst = rgFind
If rgFind Is Nothing Then
    'do nothing here.
Else
    Set rgErrorTextRange = rgFind
    Do
        Set rgFind = wbRpt.Worksheets(2).Cells.Find(What:=" sheet has ", After:=rgPrevious, LookIn:=xlFormulas, LookAt:=xlPart, SearchOrder:=xlByColumns, MatchCase:=False)
        If rgFind.Address = rgFirst.Address Then
            Exit Do
        Else
            If InStr(rgFind.value, " columns here.") > 0 Then
                'this is a block marker; probably not an error.
                Set rgPrevious = rgFind
            Else
                Set rgErrorTextRange = Application.Union(rgErrorTextRange, rgFind)
                Set rgPrevious = rgFind
            End If
        End If
    Loop
End If
If iProbableErrorsCount = 0 Then
    'no probable errors.
Else
    If rgCommentErrorRange Is Nothing Then
        Set rgAllErrorsRange = rgErrorTextRange
    ElseIf rgErrorTextRange Is Nothing Then
        Set rgAllErrorsRange = rgCommentErrorRange
    Else
        Set rgAllErrorsRange = Application.Union(rgCommentErrorRange, rgErrorTextRange)
    End If
    If rgAllErrorsRange.Cells.Count = 1 Then
        strErrorRangePrefex = "On the Details tab, the probable error is in cell "
    Else
        strErrorRangePrefex = "On the Details tab, the probable errors are in cells "
    End If
    strCellAddressProbableErrors = strErrorRangePrefex & rgAllErrorsRange.Address(False, False) & "."
    With wbRpt.Worksheets(1).Cells(SUMMARY_TAB_CELL_ADDRESSES_ROW, 1)
        .value = strCellAddressProbableErrors
        .WrapText = True
        .EntireRow.RowHeight = 400
        .EntireColumn.AutoFit
        .EntireRow.AutoFit
    End With

End If




'consolidate excessive comments:
'Dim rgComments As Range
'Dim rgCommentErrorRange As Range, rgErrorTextRange As Range, rgAllErrorsRange As Range
'Dim strErrorRangePrefex As String
Dim iCmtCount As Long
If iErrorCountNBIDD > 20 Then
    '====================================================================
    'WORK IN PROGRESS 2011-01-19 - GJL - consolidate excessive comments
    '====================================================================
End If
Set rgComments = wbRpt.Worksheets(2).Cells.SpecialCells(xlCellTypeComments)
iCmtCount = 0 'init.
If rgComments Is Nothing Then
    'do nothing here.
Else
    If rgComments.Cells.Count = 0 Then
        'do nothing  here.
    Else
        For Each rgCell In rgComments.Cells
            If rgCommentErrorRange Is Nothing Then
                Set rgCommentErrorRange = rgCell
            Else
                Set rgCommentErrorRange = Application.Union(rgCommentErrorRange, rgCell)
            End If
        Next rgCell
    End If
End If




wb_check.Close SaveChanges:=False
Call ResetFindParametersToDefaults
Application.DisplayAlerts = bDisplayAlerts
Application.ScreenUpdating = bScreenUpdating

Set AuditColumns = wbRpt

Exit Function
GenErr:
If InStr(UCase(Err.Description), "NO CELLS WERE FOUND") > 0 Then
    bNoCellsFound = True
    Resume Next
ElseIf False Then
    Resume
End If
Application.DisplayAlerts = bDisplayAlerts
Application.ScreenUpdating = bScreenUpdating
End Function




Sub AuditCols_DdefColNotFoundInTemplate(template_cell As Range, ddef_cell As Range, _
              bBlockCounterOn As Boolean, iBlockCounter As Long, iBlockTopRow As Long)
    If bBlockCounterOn Then
        iBlockCounter = iBlockCounter + 1
    Else
        bBlockCounterOn = True
        iBlockCounter = 1
        iBlockTopRow = template_cell.Row
    End If
    template_cell.Insert Shift:=xlDown
    Set template_cell = template_cell.Offset(-1) 'reset.
    template_cell.Interior.Color = RGB(255, 255, 255) 'white.
    If InStr(UCase(ddef_cell.value), "TEMPLATE SHEET HAS") = 0 Then
        'ddef side does not contain the text "Template sheet has...", so proceed:
        If iBlockCounter <= 5 Then
            template_cell.value = "Data Definitions sheet has """ & ddef_cell.value & """ here (" & Len(ddef_cell.value) & " chars)."
            template_cell.Font.Italic = True
            template_cell.Font.Color = 255 'red.
            Call AuditCols_RedBorder(template_cell)
        End If
    End If
End Sub



Sub AuditCols_TemplateColNotFoundInDdef(ddef_cell As Range, template_cell As Range, block_write_cell As Range, _
              bBlockCounterOn As Boolean, iBlockCounter As Long, iBlockTopRow As Long, _
              Optional template_movedown_start_col As Long, Optional template_movedown_end_col As Long)
            Dim rgTmp As Range
            Set rgTmp = ddef_cell.Offset(, -1).Resize(, 2)
            rgTmp.Insert Shift:=xlDown
            Set rgTmp = rgTmp.Offset(-1)
            rgTmp.Interior.Color = RGB(255, 255, 255) 'white.
            rgTmp.value = "Template sheet has """ & template_cell.value & """ here (" & Len(template_cell.value) & " chars)."
            rgTmp.Font.Italic = True
            rgTmp.Font.Color = 255 'red.
            Call AuditCols_RedBorder(rgTmp)
            If bBlockCounterOn Then
                bBlockCounterOn = False
                If iBlockCounter > 5 Then
                    Stop 'fix block_write_cell:
                    block_write_cell.Interior.Color = RGB(255, 255, 255) 'white.
                    block_write_cell.value = "Data Definitions sheet has " & iBlockCounter & " columns here."
                End If
            End If
            
            
            If template_movedown_start_col > 0 Then
                If template_movedown_end_col >= template_movedown_start_col Then
                    Dim shTmp As Worksheet
                    Set shTmp = ddef_cell.Parent
                    'note rgTmp is reset here:
                    Set rgTmp = shTmp.Range(shTmp.Cells(ddef_cell.Row - 1, template_movedown_start_col), _
                                            shTmp.Cells(ddef_cell.Row - 1, template_movedown_end_col))
                    rgTmp.Insert Shift:=xlDown
                    Set rgTmp = rgTmp.Offset(-1)
                    rgTmp.Interior.Color = RGB(255, 255, 255) 'white.
                End If
            End If

End Sub




Sub AuditCols_NotFoundInDdef(ddef_cell As Range, Optional template_movedown_start_col As Long, Optional template_movedown_end_col As Long)
    Call AuditCols_AddComment(ddef_cell, "Not found in Data Definitions sheet.")
End Sub




Sub AuditCols_BoldfaceDiscrepancy(template_cell As Range, ddef_cell As Range, _
                                  ByRef error_count_NBIDD As Long, ByRef error_count_NBIT As Long)
    On Error GoTo GenErr
    
    If template_cell.Font.Bold Then
        Call AuditCols_AddComment(template_cell, "Not boldface in Data Definitions sheet.", 5, 8)
        Call AuditCols_AddComment(ddef_cell, "Boldface in Template sheet.", 1, 8)
        error_count_NBIDD = error_count_NBIDD + 1
    Else
        Call AuditCols_AddComment(template_cell, "Boldface in Data Definitions sheet.", 1, 8)
        Call AuditCols_AddComment(ddef_cell, "Not boldface in Template sheet.", 5, 8)
        error_count_NBIT = error_count_NBIT + 1
    End If
   
    Exit Sub
GenErr:
    If False Then
        Resume
    End If
End Sub



Sub AuditCols_AddComment(target_cell As Range, comment_text As String, _
                         Optional start_bold_pos As Long, Optional bold_len As Long, _
                         Optional omit_red_border As Boolean)
    Dim commentTmp As Comment
    Dim strNewCommentText As String, strOldCommentText As String
    Set commentTmp = target_cell.Comment
    strOldCommentText = "" 'init.
    If commentTmp Is Nothing Then
        strNewCommentText = comment_text
    Else
        strOldCommentText = target_cell.Comment.Text
        If InStr(strOldCommentText, comment_text) > 0 Then
            'same text is already there, so don't add again; just keep old text:
            strNewCommentText = comment_text
        Else
            'append new text to old text:
            strNewCommentText = comment_text & _
                                Chr(10) & "AND:" & Chr(10) & _
                                strOldCommentText 'new text goes on top to facilitate boldface. Any boldface in old text is lost here.
            commentTmp.Delete
        End If
    End If
    target_cell.AddComment
    target_cell.Comment.Visible = True
        target_cell.Comment.Text Text:=strNewCommentText
        If bold_len > 0 Then
            target_cell.Comment.Shape.TextFrame.Characters(start_bold_pos, bold_len).Font.Bold = True
        End If
    If Not omit_red_border Then
        Call AuditCols_RedBorder(target_cell)
    End If
End Sub



Sub AuditCols_RedBorder(target_range As Range, Optional omit_inside_border As Boolean)
    With target_range.Borders(xlEdgeLeft)
        .LineStyle = xlContinuous
        .Color = 255 'red.
        .TintAndShade = 0
        .Weight = xlThick
    End With
    With target_range.Borders(xlEdgeTop)
        .LineStyle = xlContinuous
        .Color = 255 'red.
        .TintAndShade = 0
        .Weight = xlThick
    End With
    With target_range.Borders(xlEdgeBottom)
        .LineStyle = xlContinuous
        .Color = 255 'red.'-16776961
        .TintAndShade = 0
        .Weight = xlThick
    End With
    With target_range.Borders(xlEdgeRight)
        .LineStyle = xlContinuous
        .Color = 255 'red.
        .TintAndShade = 0
        .Weight = xlThick
    End With
    If Not omit_inside_border Then
        With target_range.Borders(xlInsideVertical)
            .LineStyle = xlContinuous
            .Color = 255 'red.
            .TintAndShade = 0
            .Weight = xlThick
        End With
    End If
End Sub





Sub AuditCols_BadChars(check_range As Range, ByRef iProbableErrorsCount As Long)
'checks for leading & trailing spaces, and carriage returns.
Dim rgCell As Range, strCell As String
For Each rgCell In check_range
    strCell = rgCell.value
    If Left(strCell, 1) = Chr(32) Then
        iProbableErrorsCount = iProbableErrorsCount + 1
        Call AuditCols_AddComment(rgCell, "Has leading space character.")
    End If
    
    If Right(strCell, 1) = Chr(32) Then
        iProbableErrorsCount = iProbableErrorsCount + 1
        Call AuditCols_AddComment(rgCell, "Has trailing space character.")
    End If
    
    If InStr(strCell, Chr(10)) > 0 Then
        iProbableErrorsCount = iProbableErrorsCount + 1
        Call AuditCols_AddComment(rgCell, "Has carriage return character.")
    End If
    
Next rgCell
End Sub





Sub CommentFix()

Dim oComment As Comment
Dim lArea As Long
For Each oComment In MySheet.Comments
    With oComment.Shape
        .Placement = xlMoveAndSize
        .Top = oComment.Parent.Top + 5
        .Left = oComment.Parent.Offset(0, 1).Left + 5
        .TextFrame.AutoSize = True
    End With
'    If oComment.Shape.Width > 300 Then
'        lArea = oComment.Shape.Width * oComment.Shape.Height
'        oComment.Shape.Width = 200
'        oComment.Shape.Height = (lArea / 200) * 1.1
'    End If
Next oComment
End Sub






Sub CreateNoMacroVersionFromPrompt() 'call from toolbar.
    Dim strPath As String
    Dim wb_with_macro As Workbook
    Dim bEnableEvents As Boolean
    
    bEnableEvents = Application.EnableEvents
    Application.EnableEvents = False

    strPath = Application.GetOpenFilename(, , "Browse to ff template to for which to create a no-macro version...")
    If strPath = "False" Then Exit Sub
    Set wb_with_macro = Workbooks.Open(strPath, UpdateLinks:=0) '0 = do not update links.
    Call CreateNoMacroVersionMain(wb_with_macro, True)
    Application.EnableEvents = bEnableEvents
End Sub




Sub CreateNoMacroVersionMain(wb_with_macro As Workbook, Optional leave_nomacro_wb_open As Boolean)

On Error GoTo GenErr

Dim strPath As String, strXlsxPath As String, strNomacroPath As String, strTmp As String
Dim wb_xlsx As Workbook, wb_no_macro As Workbook
Dim ws As Worksheet
Dim bDisplayAlerts As Boolean, bEnableEvents As Boolean

bDisplayAlerts = Application.DisplayAlerts
Application.DisplayAlerts = False
bEnableEvents = Application.EnableEvents
Application.EnableEvents = False

strPath = wb_with_macro.Path & "/" & wb_with_macro.Name
strXlsxPath = strPath & ".xlsx"

Kill strXlsxPath 'in case same filename aready there.
DoEvents
wb_with_macro.SaveAs FileName:=strXlsxPath, FileFormat:=xlOpenXMLWorkbook
wb_with_macro.Close SaveChanges:=False
Set wb_xlsx = Workbooks.Open(strXlsxPath, UpdateLinks:=False)

strTmp = Left(strPath, Len(strXlsxPath) - 9) 'removes ".xls.xlsx".
strNomacroPath = strTmp & "_wo_macro.xls"

Kill strNomacroPath 'in case same filename aready there.
DoEvents
wb_xlsx.SaveAs FileName:=strNomacroPath, FileFormat:=xlExcel8
wb_xlsx.Close SaveChanges:=False
Set wb_no_macro = Workbooks.Open(strNomacroPath, UpdateLinks:=False)

Kill strXlsxPath
DoEvents

For Each ws In wb_no_macro.Worksheets
    If Not ws.Visible Then ws.Delete
Next ws

wb_no_macro.Save
If Not leave_nomacro_wb_open Then wb_no_macro.Close SaveChanges:=False

Application.DisplayAlerts = bDisplayAlerts: Application.EnableEvents = bEnableEvents

Exit Sub
GenErr:
If UCase(Err.Description) = "FILE NOT FOUND" Then Resume Next
If False Then
    Resume
End If
Application.DisplayAlerts = bDisplayAlerts: Application.EnableEvents = bEnableEvents
End Sub


Attribute VB_Name = "modSupport"
' Modified for MWS integration
' Abhijit Tambe, July 2010

Option Explicit

'==========================================================================================
'For 64-bit compatibility.

'MSDN: Compatibility Between the 32-bit and 64-bit Versions of Office 2010:
    'http://msdn.microsoft.com/en-us/library/ee691831.aspx
'Technet: Microsoft Office Code Compatibility Inspector:
    'http://technet.microsoft.com/en-us/library/ee833946.aspx
'Samples:
    'The Microsoft file Win32_PtrSafe.txt contains 64-bit Windows API Declarations and Constants for VBA:
        'http://support.microsoft.com/kb/2030490
        'http://www.microsoft.com/downloads/en/details.aspx?FamilyID=035b72a5-eef9-4baf-8dbc-63fbd2dd982b&displaylang=en
    'http://www.jkp-ads.com/articles/apideclarations.asp
'Windows API functions that were modified/added for 64-bit Windows:
    'http://msdn.microsoft.com/en-us/library/aa383663(VS.85).aspx

'PtrSafe:
    'For Excel 2010 and later (#Vba7 = True), change "Declare" to "Declare PtrSafe".
'LongPtr:
    'For Excel 2010 and later (#Vba7 = True), change the data type of handles and pointers
    'from Long to LongPtr. Leave pointers to strings as String.
'LongLong:
    'For 64-bit Excel (#Win64 = True), change Long (except for handles and pointers!) to LongLong

#If Mac Then
    'Running on MacIntosh. Do nothing.
#ElseIf VBA7 Then
    'Excel 2010 or later:
     #If Win64 Then
        '64-bit Excel, 2010 or later:
        'Use PtrSafe, LongPtr, and LongLong:
        
            Public Declare PtrSafe Function GetACP Lib "kernel32" () As LongLong 'ACP = ANSI Code Page
            Public Declare PtrSafe Function GetSystemDefaultLCID Lib "kernel32" () As LongLong
            
            
            
            Public Declare PtrSafe Function ShellExecute Lib "shell32.dll" Alias "ShellExecuteA" ( _
                                    ByVal hwnd As LongPtr, ByVal lpOperation As String, _
                                    ByVal lpFile As String, ByVal lpParameters As String, _
                                    ByVal lpDirectory As String, ByVal nShowCmd As LongLong) As LongLong

     #Else
        '32-bit Excel 2010 or later:
        'Use PtrSafe and LongPtr, but NOT LongLong:

            Public Declare PtrSafe Function GetACP Lib "kernel32" () As Long 'ACP = ANSI Code Page
            Public Declare PtrSafe Function GetSystemDefaultLCID Lib "kernel32" () As Long
            
            
            
            Public Declare PtrSafe Function ShellExecute Lib "shell32.dll" Alias "ShellExecuteA" ( _
                                    ByVal hwnd As LongPtr, ByVal lpOperation As String, _
                                    ByVal lpFile As String, ByVal lpParameters As String, _
                                    ByVal lpDirectory As String, ByVal nShowCmd As Long) As Long
        
     #End If
#Else
    'Excel 2007 or earlier:

        Public Declare Function GetACP Lib "kernel32" () As Long  'ACP = ANSI Code Page
        Public Declare Function GetSystemDefaultLCID Lib "kernel32" () As Long
        
        
        
        Public Declare Function ShellExecute Lib "shell32.dll" Alias "ShellExecuteA" ( _
                                ByVal hwnd As Long, ByVal lpOperation As String, _
                                ByVal lpFile As String, ByVal lpParameters As String, _
                                ByVal lpDirectory As String, ByVal nShowCmd As Long) As Long

#End If

'==========================================================================================
Public Const HWND_0 As Long = 0



Public bCannotFindXML As Boolean
Public bNowClosingWorkbook As Boolean
Public bNumberAsTextErrorCheckingStatus As Boolean
Public iAmazonMsgBoxRet As Long
Public iAmazonMsgBoxDefaultRet As Long 'used when user dismisses frmAmazonMsgBox with Enter or Tab.

Dim rgRet As Range

'''''not in use. GetSystemMetrics32 not upgraded for 64-bit compatibility.
'''''' added 07/30/10 by atambe
'''''Declare Function GetSystemMetrics32 Lib "User32" Alias "GetSystemMetrics" (ByVal nIndex As Long) As Long
'''''
'''''' added 07/30/10 by atambe
'''''Sub GetScreenResolution(width As Long, height As Long)
'''''    width = GetSystemMetrics32(0) ' width in pixels
'''''    height = GetSystemMetrics32(1) ' height in pixels
'''''End Sub


Sub test()

    Debug.Print AmazonMsgBox("my prompt", vbYesNo, "my title")

End Sub



Public Function GetTemplateHeaderRow(template_sheet As Worksheet) As Long

    On Error GoTo GenErr

    'returns 2 if cell A1 contains "templatetype", otherwise returns 1.

    If InStr(UCase(template_sheet.Range("A1").value), "TEMPLATETYPE") > 0 Then
        '2010-08-04, for compatibility with localized header rows,
        'with English header rows in the next row down, usually row 3.
        'Must find the ENGLISH header row, NOT the localized header row:
        Dim strTemplateTypeVersionString As String
        Dim iTemplateTypeVersionFirstDigit As Long
        strTemplateTypeVersionString = Trim(template_sheet.Range("B1").value) 'note, removes any spaces.
        If InStr(UCase(strTemplateTypeVersionString), "VERSION=") > 0 Then
            'There is a templatetype version string in the expected place:
            iTemplateTypeVersionFirstDigit = CLng(Mid(strTemplateTypeVersionString, 9, 1))
            If iTemplateTypeVersionFirstDigit > 1 Then
                'this is templatetype version 2 or higher, which has a row for localized header
                'even if it is not used because this is an English template:
                GetTemplateHeaderRow = 3
            Else
                'this is templatetype version 1, which does NOT have a row for localized headers:
                GetTemplateHeaderRow = 2
            End If
        Else
            'templatetype version string is missing or in an unexpected place. Try row 2:
            GetTemplateHeaderRow = 2
        End If
    Else
'        GetTemplateHeaderRow = 1
        'check for unoccupied first row, for importing, where template_sheet is the import sheet:
        If template_sheet.Rows(1).Find(What:="*") Is Nothing Then
            Call ResetFindParametersToDefaults
            'first row is blank. Indicate error by returning -1:
            
            Dim iCheckRow As Long
            Dim iLastRow As Long
            iLastRow = template_sheet.Rows.Count
            For iCheckRow = 2 To iLastRow
                If template_sheet.Rows(iCheckRow).Find(What:="*") Is Nothing Then
                    'iCheckRow is unoccupied; move on to check next iRow.
                Else
                    'here's the top occupied row:
                    GetTemplateHeaderRow = iCheckRow
                    Exit Function
                End If
                Call ResetFindParametersToDefaults
            Next iCheckRow
            
            'all rows searched, no occupied rows found:
            GetTemplateHeaderRow = -1
        Else
            'first row was occupied:
            GetTemplateHeaderRow = 1
        End If
        Call ResetFindParametersToDefaults
    End If
    
    Exit Function
    
GenErr:
If False Then
    Resume
End If
    'error looking for header row. Try row 2:
    GetTemplateHeaderRow = 2
    Exit Function

End Function


Public Function GetLastExampleRow(template_sheet As Worksheet, header_row As Long) As Long

On Error GoTo GenErr

Dim iRow As Long

If Not template_sheet.ProtectContents Then
    'sheet is not protected, so there are no example rows:
    GetLastExampleRow = header_row
    Exit Function
End If

iRow = header_row + 1

Do Until Not template_sheet.Cells(iRow, 1).Locked
    iRow = iRow + 1
Loop

GetLastExampleRow = iRow - 1

Exit Function

GenErr:
If False Then
    Resume
End If

'If any error, just validate all rows:
GetLastExampleRow = header_row

End Function



Public Function GetLocalLanguageName(Optional get_secondary_language_name As Boolean, _
                                     Optional target_workbook As Workbook) As String

    Dim strLanguageDefinedName As String
    Dim strLocalLanguageName As String
    Dim wbWorkbook As Workbook
    
    If target_workbook Is Nothing Then
        Set wbWorkbook = ThisWorkbook
    Else
        Set wbWorkbook = target_workbook
    End If

    If get_secondary_language_name Then
        strLanguageDefinedName = TEMPLATE_SECONDARY_LANGUAGE_DEFINED_NAME
    Else
        strLanguageDefinedName = TEMPLATE_LANGUAGE_DEFINED_NAME
        strLocalLanguageName = wbWorkbook.Names(strLanguageDefinedName).RefersToRange.value
        
        'check for "Master Name", and if so change to secondary language name:
        If strLocalLanguageName = INT_TABLE_MASTER_NAME_HEADER Then
            strLanguageDefinedName = TEMPLATE_SECONDARY_LANGUAGE_DEFINED_NAME
        End If
        
    End If
    
    GetLocalLanguageName = wbWorkbook.Names(strLanguageDefinedName).RefersToRange.value
    
End Function


Public Function GetTemplateCodepage() As Long
    GetTemplateCodepage = CLng(ThisWorkbook.Names(TEMPLATE_CODEPAGE_DEFINED_NAME).RefersToRange.value)
End Function

Public Function GetWindowsCodepage() As Long
    'This is the ANSI codepage, NOT the OEM/DOS/Keyboard/etc. codepage.
    'This is the "currently active" ANSI codepage.
    GetWindowsCodepage = CLng(GetACP)
End Function

Public Function GetTemplateLCID() As Long
    GetTemplateLCID = CLng(ThisWorkbook.Names(TEMPLATE_LCID_DEFINED_NAME).RefersToRange.value)
End Function

Public Function GetWindowsLCID() As Long
    'This is the "current default system" LCID.
    GetWindowsLCID = CLng(GetSystemDefaultLCID)
End Function



Public Function GetLocalLanguageColumnHeaderFromMfaInternalNameColumnHeader( _
                    MFA_INTERNAL_NAME As String, _
                    Optional int_table_sheet As Worksheet, _
                    Optional int_table_local_language_col As Long, _
                    Optional int_table_mfa_internal_name_col As Long) As String
    
    Dim rgFind As Range
    Dim iRow As Long

    If int_table_sheet Is Nothing Then
        Set int_table_sheet = ThisWorkbook.Worksheets(INT_TABLE_WORKSHEET_NAME)
    End If

    If int_table_local_language_col = 0 Then
        int_table_local_language_col = GetIntTableLocalLanguageColumn(int_table_sheet)
    End If

    If int_table_mfa_internal_name_col = 0 Then
        int_table_mfa_internal_name_col = GetIntTableMfaInternalNameColumn(int_table_sheet)
    End If
    

    Set rgFind = int_table_sheet.Columns(int_table_mfa_internal_name_col).Find(MFA_INTERNAL_NAME)
    Call ResetFindParametersToDefaults
    
    iRow = rgFind.Row
    
    GetLocalLanguageColumnHeaderFromMfaInternalNameColumnHeader = _
        int_table_sheet.Cells(iRow, int_table_local_language_col).value

End Function



Public Function GetLocalColumnHeaderFromMfaInternalName( _
                column_header_mfa_internal_name As String, _
                int_table_sheet As Worksheet, _
                template_sheet As Worksheet, _
                int_table_mfa_internal_col As Long, _
                int_table_local_name_col As Long, _
                template_header_row As Long) As String


'CHECKS FOR MULTIPLE ENTRIES OF THIS MFA INTERNAL NAME IN THE INTERNATIONAL
'TABLE, GETS EACH CORRESPONDING LOCAL NAME, AND SEARCHES FOR EACH OF THOSE LOCAL
'NAMES (AS WELL AS THE MFA INTERNAL NAME) IN THE TEMPLATE COLUMN HEADERS.

'returns empty string ("") if none found.

Dim strArrayLocalNames() As String
Dim iArrayLocalNamesIndex As Long
Dim strArrayLocalNamesItem As String
Dim iUboundArrayLocalNames As Long
Dim rgFind As Range
Dim bFound As Boolean
Dim iFindRow As Long
Dim strFoundItem As String

On Error GoTo GenErr


'Look for all entries of mfa internal name in international table,
'get the local name for each of them, and make an array of the local names:
iUboundArrayLocalNames = 2
ReDim strArrayLocalNames(1 To iUboundArrayLocalNames) As String 'init.

'include the mfa internal name:
strArrayLocalNames(iUboundArrayLocalNames - 1) = column_header_mfa_internal_name


Set rgFind = int_table_sheet.Columns(int_table_mfa_internal_col).Find( _
             What:=column_header_mfa_internal_name, LookAt:=xlWhole)
Call ResetFindParametersToDefaults
If rgFind Is Nothing Then
    'none found.
    bFound = False
Else
    'found one:
    bFound = True
    iFindRow = rgFind.Row
    strFoundItem = int_table_sheet.Cells(iFindRow, int_table_local_name_col).value
                'don't add it if it's an empty string:
    If strFoundItem = "" Then
        'don't add it to the array.
    Else
        'add it to the array:
        strArrayLocalNames(iUboundArrayLocalNames) = strFoundItem
        iUboundArrayLocalNames = iUboundArrayLocalNames + 1
        ReDim Preserve strArrayLocalNames(1 To iUboundArrayLocalNames)
    End If

    
    'look for more:
    Do
        Set rgFind = int_table_sheet.Columns(int_table_mfa_internal_col).Find( _
                     What:=column_header_mfa_internal_name, After:=rgFind, LookAt:=xlWhole)
        Call ResetFindParametersToDefaults
        If rgFind Is Nothing Then
            'none found.
            Exit Do
        Else
            'found another one, but check whether this one was already found:
            If rgFind.Row > iFindRow Then
                'found another one.
                iFindRow = rgFind.Row
                strFoundItem = int_table_sheet.Cells(iFindRow, int_table_local_name_col).value
                'don't add it if it's an empty string:
                If strFoundItem = "" Then
                    'don't add it to the array.
                Else
                    'add it to the array:
                    strArrayLocalNames(iUboundArrayLocalNames) = strFoundItem
                    iUboundArrayLocalNames = iUboundArrayLocalNames + 1
                    ReDim Preserve strArrayLocalNames(1 To iUboundArrayLocalNames)
                End If
            Else
                'it's a repeat.
                Exit Do
            End If
        End If
    Loop
End If

'if one or more local names found:
If bFound Then
    
    'init and reuse bFound:
    bFound = False
    
    'remove unused top item in array:
    iUboundArrayLocalNames = iUboundArrayLocalNames - 1
    ReDim Preserve strArrayLocalNames(1 To iUboundArrayLocalNames)
    
    
    'search for those names in the template header row:
    For iArrayLocalNamesIndex = 1 To iUboundArrayLocalNames
    
    
        strArrayLocalNamesItem = strArrayLocalNames(iArrayLocalNamesIndex)
        Set rgFind = template_sheet.Rows(template_header_row).Find( _
                     What:=strArrayLocalNamesItem, LookAt:=xlWhole)
        Call ResetFindParametersToDefaults
        If Not rgFind Is Nothing Then
            
            bFound = True
            'use this local name for validating this column:
            GetLocalColumnHeaderFromMfaInternalName = strArrayLocalNamesItem
            Exit For
            
        End If
        
    Next iArrayLocalNamesIndex
End If


'return empty string ("") if can't find required column:
If rgFind Is Nothing Then
    GetLocalColumnHeaderFromMfaInternalName = ""
End If


Exit Function

GenErr:

Stop
If False Then
    Resume
End If



End Function




Public Function GetTemplateWorksheet(Optional get_first_template As Boolean) As Worksheet
    If get_first_template Then
        Set GetTemplateWorksheet = shTemplate1
    ElseIf TypeName(ActiveSheet) = "DialogSheet" Then
        'user inserted an xl5 dialog sheet, which does not have a Codename property:
        Set GetTemplateWorksheet = shTemplate1
    ElseIf InStr(ActiveSheet.CodeName, "shTemplate") > 0 Then
        Set GetTemplateWorksheet = ActiveSheet
    Else
        Set GetTemplateWorksheet = shTemplate1
    End If
End Function


Public Function GetInternationalTableWorksheet() As Worksheet
    Set GetInternationalTableWorksheet = ThisWorkbook.Worksheets(INT_TABLE_WORKSHEET_NAME)
End Function



Public Function GetInternalTemplateName(work_book As Workbook) As String
    GetInternalTemplateName = work_book.Names(INTERNAL_TEMPLATE_NAME_DEFINED_NAME).RefersToRange.value
End Function



Public Function IncrementDefinedNameSuffix(suffix As String) As String
    If suffix = "" Then
        IncrementDefinedNameSuffix = "2"
    Else
        IncrementDefinedNameSuffix = CStr(CLng(suffix) + 1)
    End If
End Function



Public Function GetDefinedNameSuffixSeparatorFromSuffix(suffix As String)
    If suffix = "" Then
        GetDefinedNameSuffixSeparatorFromSuffix = ""
    Else
        GetDefinedNameSuffixSeparatorFromSuffix = "."
    End If
End Function



Public Function GetRangeFromDefinedName(defined_name As String) As Range

'returns Nothing if not found.

On Error Resume Next

Set GetRangeFromDefinedName = ThisWorkbook.Names(defined_name).RefersToRange

End Function


Public Function Get_XMLHTTP_Object() As Object

Dim oXMLHTTP As Object
Dim strClassString As String
Dim iLbound As Long
Dim iUbound As Long
Dim ArrayVersion()
Dim iArrayIndex As Long
Dim bSuccess As Boolean

On Error GoTo XMLErr

'init:
ArrayVersion = Array(3, 6, 5)
iLbound = LBound(ArrayVersion)
iUbound = UBound(ArrayVersion)
bSuccess = False
bCannotFindXML = True

For iArrayIndex = iLbound To iUbound
'    strClassString = "MSXML2.XMLHTTP." & ArrayVersion(iArrayIndex) & ".0"
    strClassString = "MSXML2.XMLHTTP.3.0" 'currently works only with 3.0, but note you can instantiate 3.0 from later DLL versions.
    Set oXMLHTTP = CreateObject(strClassString)
    If Not oXMLHTTP Is Nothing Then
        bSuccess = True
        Exit For
    End If
Next iArrayIndex

If bSuccess Then
    Set Get_XMLHTTP_Object = oXMLHTTP
    bCannotFindXML = False
End If

Exit Function
XMLErr:
    Resume Next

End Function


Public Function Get_XML_DOMDocument_Object() As Object

Dim oXML_DOMDocument As Object
Dim strClassString As String
Dim iLbound As Long
Dim iUbound As Long
Dim ArrayVersion()
Dim iArrayIndex As Long
Dim bSuccess As Boolean

On Error GoTo XMLErr

'init:
ArrayVersion = Array(3, 6, 5)
iLbound = LBound(ArrayVersion)
iUbound = UBound(ArrayVersion)
bSuccess = False
bCannotFindXML = True

For iArrayIndex = iLbound To iUbound
'    strClassString = "MSXML2.DOMDocument." & ArrayVersion(iArrayIndex) & ".0"
    strClassString = "MSXML2.DOMDocument.3.0" 'currently works only with 3.0, but note you can instantiate 3.0 from later DLL versions.
    Set oXML_DOMDocument = CreateObject(strClassString)
    If Not oXML_DOMDocument Is Nothing Then
        bSuccess = True
        Exit For
    End If
Next iArrayIndex

If bSuccess Then
    Set Get_XML_DOMDocument_Object = oXML_DOMDocument
    bCannotFindXML = False
End If

Exit Function
XMLErr:
    Resume Next

End Function


Sub MsgXMLErr()
'    MsgBox "You cannot use the advanced functionality in the Listing Loader because a required XML library is not available on this computer. Please install MSXML library from Microsoft.com and try again." & _
'    vbNewLine & vbNewLine & _
'    "Or you can enter the data manually and upload your listings in tab-delimited format using Seller Central.", _
'           vbCritical + vbOKOnly, "Listing Loader - Important Message"
    frmCannotFindXML.Show
End Sub



Public Function ActivateExcel2007AddInsTabTimer()

        Application.OnTime Now + 0.000000001, "ActivateExcel2007AddInsTab"
        '0.000000001 = ~1/10,000 sec.
    
End Function


Public Sub ActivateExcel2007AddInsTab()

'this is inactive in CutCopyMode, because the Escape keys would take Excel out of CutCopyMode.

    If Application.CutCopyMode = 0 Then
        DoEvents
        If Val(Application.Version) >= 12 Then
            'Excel 2007 or later:
'            SendKeys "%x{ESC 3}"
'            DoEvents
'            SendKeys "{ESC 3}"
'            DoEvents
'            SendKeys "{ESC 3}"
            SendKeys "%x{ESC 2}"
        End If
    End If
End Sub



Public Sub BrowseTo(strURL As String)
    'uses default web browser.
    On Error Resume Next
    ShellExecute HWND_0, vbNullString, strURL, vbNullString, vbNullString, vbNormalFocus
End Sub


Public Function GetExcelFriendlyVersion(excel_version As String) As String

    Dim dblVersion As Double
    
    On Error Resume Next
    
    GetExcelFriendlyVersion = excel_version 'init.
    
    dblVersion = CDbl(excel_version)
    
    Select Case dblVersion
        Case 7
            GetExcelFriendlyVersion = "95"
        Case 8
            GetExcelFriendlyVersion = "97"
        Case 9
            GetExcelFriendlyVersion = "2000"
        Case 10
            GetExcelFriendlyVersion = "2002"
        Case 11
            GetExcelFriendlyVersion = "2003"
        Case 12
            GetExcelFriendlyVersion = "2007"
        Case Else
            GetExcelFriendlyVersion = excel_version
    End Select
    
End Function




Public Function GetIntTableDataCategoryColumn(int_table_sheet As Worksheet) As Long
    Dim rgFind As Range

    Set rgFind = int_table_sheet.Rows(INT_TABLE_HEADER_ROW).Find(INT_TABLE_DATA_CATEGORY_HEADER)
    Call ResetFindParametersToDefaults
    GetIntTableDataCategoryColumn = rgFind.Column
End Function


Public Function GetIntTableAnyLanguageColumn(int_table_sheet As Worksheet, target_language As String) As Long
    Dim rgFind As Range
    
    Set rgFind = int_table_sheet.Rows(INT_TABLE_HEADER_ROW).Find(target_language)
    Call ResetFindParametersToDefaults
    GetIntTableAnyLanguageColumn = rgFind.Column
End Function


Public Function GetTableCategorySingleRow(target_sheet As Worksheet, _
                                          category_name As String, category_col As Long) As Long
    'assumes there is only *ONE ROW* for this category. Returns first row found, ignores any other rows.
    'do not use for categories with more than one row.
    Dim rgFind As Range
    
    Set rgFind = target_sheet.Columns(category_col).Find(category_name)
    Call ResetFindParametersToDefaults
    GetTableCategorySingleRow = rgFind.Row
End Function


Public Function ProtectSheet(work_sheet As Worksheet) As Boolean
'returns True on success.

work_sheet.Protect UserInterfaceOnly:=True, DrawingObjects:=False, Contents:=True, _
    Scenarios:=False, AllowFormattingCells:=True, AllowFormattingColumns:=True, _
    AllowFormattingRows:=True, AllowInsertingColumns:=True, AllowInsertingRows:=True, _
    AllowInsertingHyperlinks:=True, AllowDeletingColumns:=True, _
    AllowDeletingRows:=True, AllowSorting:=True, AllowFiltering:=True, _
    AllowUsingPivotTables:=True


End Function



Public Function GetInstructionsWorksheet() As Worksheet
'returns Nothing if not found.
    Dim bFound As Boolean
    
    bFound = False
    For Each GetInstructionsWorksheet In ThisWorkbook.Worksheets
        If InStr(UCase(GetInstructionsWorksheet.CodeName), "INSTRUCTIONS") > 0 Then
            If InStr(UCase(GetInstructionsWorksheet.Name), "MASTER") > 0 Then
                'skip the master instructions.
            Else
                bFound = True
                Exit For
            End If
        End If
    Next GetInstructionsWorksheet

    If Not bFound Then
        For Each GetInstructionsWorksheet In ThisWorkbook.Worksheets
            If InStr(UCase(GetInstructionsWorksheet.Name), "INST_ENGLISH USA") > 0 Then
                'this should only exist in the master.
                bFound = True
                Exit For
            End If
        Next GetInstructionsWorksheet
    End If
        
    If Not bFound Then
        Set GetInstructionsWorksheet = Nothing
    End If
End Function


Public Function GetDataDefinitionsWorksheet() As Worksheet
'returns Nothing if not found.
    Dim bFound As Boolean
        
    bFound = False
    For Each GetDataDefinitionsWorksheet In ThisWorkbook.Worksheets
        If InStr(UCase(GetDataDefinitionsWorksheet.CodeName), "DDEF") > 0 Then
            If InStr(UCase(GetDataDefinitionsWorksheet.Name), "MASTER") > 0 Then
                'skip the master instructions.
            Else
                bFound = True
                Exit For
            End If
        End If
    Next GetDataDefinitionsWorksheet

    If Not bFound Then
        For Each GetDataDefinitionsWorksheet In ThisWorkbook.Worksheets
            If InStr(UCase(GetDataDefinitionsWorksheet.Name), "DDEF_ENGLISH USA") > 0 Then
                'this should only exist in the master.
                bFound = True
                Exit For
            End If
        Next GetDataDefinitionsWorksheet
    End If
        
    If Not bFound Then
        Set GetDataDefinitionsWorksheet = Nothing
    End If
End Function


Public Function ActivateInstructionsOrDdefSheet()

    Dim shActivesheetOnWorkbookOpen As Worksheet
    Dim shInst As Worksheet, shDdef As Worksheet
    
    Set shInst = GetInstructionsWorksheet
    If shInst Is Nothing Then
        Set shDdef = GetDataDefinitionsWorksheet
        If Not shDdef Is Nothing Then
            Set shActivesheetOnWorkbookOpen = shDdef
        End If
    Else
        Set shActivesheetOnWorkbookOpen = shInst
    End If
    
    If Not shActivesheetOnWorkbookOpen Is Nothing Then
        shActivesheetOnWorkbookOpen.Activate
    End If

End Function


Public Function IsRangeEmpty(target_range As Range) As Boolean

On Error GoTo GenErr

Set rgRet = target_range.Find(What:="*", LookIn:=xlFormulas)
Call ResetFindParametersToDefaults

If rgRet Is Nothing Then
    IsRangeEmpty = True
Else
    IsRangeEmpty = False
End If

Exit Function
GenErr:
IsRangeEmpty = False
End Function


Public Function GetRowNumberOfLastOccupiedRow(column_range As Range) As Long
'for sheets affected by excel's .Formula = .Formula bug.
'more efficient for this to search each column than each row.

Dim shSheet As Worksheet
Dim rgFind As Range
Dim iFirstCol As Long
Dim iLastCol As Long
Dim iCol As Long
Dim iLastRow As Long

Set shSheet = column_range.Parent
iFirstCol = column_range.Cells(1).Column
iLastCol = column_range.Cells(column_range.Cells.Count).Column

iLastRow = 1 'init.
For iCol = iFirstCol To iLastCol
    Set rgFind = shSheet.Columns(iCol).EntireColumn
    Set rgFind = rgFind.Find(What:="*", After:=rgFind.Cells(rgFind.Cells.Count), LookIn:=xlFormulas, SearchDirection:=xlPrevious)
    Call ResetFindParametersToDefaults
    
    If Not rgFind Is Nothing Then
        If rgFind.Row > iLastRow Then iLastRow = rgFind.Row
    End If
Next iCol

GetRowNumberOfLastOccupiedRow = iLastRow

End Function


Public Function GetRightmostOccupiedCellInRowAsRange(work_sheet As Worksheet, row_num As Long) As Range

Dim rgFind As Range

Set rgFind = work_sheet.Rows(row_num).EntireRow
If rgFind.Cells(rgFind.Cells.Count).value = "" Then
    Set rgFind = rgFind.Find(What:="*", After:=rgFind.Cells(1), LookIn:=xlFormulas, SearchDirection:=xlPrevious)
    Call ResetFindParametersToDefaults
Else
    Set rgFind = rgFind.Cells(rgFind.Cells.Count)
    Call ResetFindParametersToDefaults
End If

Set GetRightmostOccupiedCellInRowAsRange = rgFind

End Function



Public Function ResetTargetRangeNumberFormattingToText(target_range As Range)

'do not call this from Workbook_BeforeSave due to Excel bug; see comment there.
'call this from a timer instead.

    Dim shTarget As Worksheet
    Dim rgOccupiedCells As Range
    Dim bEnableEventsSetting As Boolean
    Dim bSheetProtected As Boolean
    Dim rgArea As Range
    
    On Error GoTo GenErr
    
'    If IsRangeEmpty(target_range) Then Exit Function 'for when user presses Delete on large range.
        
    
    Set shTarget = target_range.Parent
    
    bEnableEventsSetting = Application.EnableEvents
    Application.EnableEvents = False
    
    If shTarget.ProtectContents Then
        bSheetProtected = True
        shTarget.Unprotect
    Else
        bSheetProtected = False
    End If
    
    Set rgOccupiedCells = GetRangeOfOccupiedCellsFromRange(target_range)
    
    If rgOccupiedCells Is Nothing Then
        'the range is empty.
    Else
        'the range includes occupied cells:
        rgOccupiedCells.NumberFormat = "@" 'Text.
        For Each rgArea In rgOccupiedCells.Areas
            rgArea.Formula = rgArea.Formula
        Next rgArea
    End If

   
    Call FixFormulaEqualsFormulaBug(shTarget)
    
    
'    If bSheetProtected Then Call ProtectSheet(shTarget)
    Application.EnableEvents = bEnableEventsSetting

Exit Function
GenErr:
If False Then
    Resume
End If

'error occurs on "rgArea.Formula = rgArea.Formula" if any cell in rgArea has very long text string.
'not important, so just resume next.
Resume Next

End Function



Public Sub FixFormulaEqualsFormulaBug(target_sheet As Worksheet)

'clean up unused rows affected by .Formula = .Formula bug

    Dim iLastRowActuallyOccupied As Long
    Dim iLastRowMarkedAsOccuped As Long
    Dim rgDeleteRows As Range
    Dim bSheetProtected As Boolean
    Dim bEnableEventsSetting As Boolean
    
    If target_sheet.ProtectContents Then
        bSheetProtected = True
        target_sheet.Unprotect
    Else
        bSheetProtected = False
    End If
    
    bEnableEventsSetting = GetEnableEventsStatusAndTurnItOff
    
    iLastRowActuallyOccupied = GetRowNumberOfLastOccupiedRow(target_sheet.Cells)
    iLastRowMarkedAsOccuped = target_sheet.UsedRange.Rows(target_sheet.UsedRange.Rows.Count).Row
    If iLastRowMarkedAsOccuped > iLastRowActuallyOccupied Then
        Set rgDeleteRows = target_sheet.Range( _
                                target_sheet.Rows(iLastRowActuallyOccupied + 1).EntireRow, _
                                target_sheet.Rows(iLastRowMarkedAsOccuped).EntireRow)
        rgDeleteRows.Delete Shift:=xlUp
    End If
    
'    If bSheetProtected Then Call ProtectSheet(target_sheet)
    Application.EnableEvents = bEnableEventsSetting

End Sub



Public Function GetRangeOfOccupiedCellsFromRange(target_range As Range) As Range

'do not call this from Workbook_BeforeSave due to Excel bug; see comment there.
'call this from a timer instead.

'returns Nothing if no cells in target_range are occupied.

Dim rgConstants As Range
Dim rgFormulas As Range
Dim rgOccupied As Range
Dim bConstantsFound As Boolean
Dim bFormulasFound As Boolean

On Error Resume Next 'because SpecialCells returns error if no cells found. Handling done inline.

'check for single-cell selection:
If target_range.Cells.Count = 1 Then
    'only one cell:
    If target_range.value = "" Then
        Set GetRangeOfOccupiedCellsFromRange = Nothing
    Else
        Set GetRangeOfOccupiedCellsFromRange = target_range
    End If
    Exit Function
End If


'find constants in selected range:
Set rgConstants = target_range.SpecialCells(xlCellTypeConstants)
If rgConstants Is Nothing Then
    bConstantsFound = False
Else
    bConstantsFound = True
End If


'find formulas in selected range:
Set rgFormulas = target_range.SpecialCells(xlCellTypeFormulas)
If rgFormulas Is Nothing Then
    bFormulasFound = False
Else
    bFormulasFound = True
End If


'get union of constants and formulas:
If bConstantsFound And bFormulasFound Then
    'get the union of both:
    Set rgOccupied = Application.Union(rgConstants, rgFormulas)
ElseIf bConstantsFound Then
    'get constants only:
    Set rgOccupied = rgConstants
ElseIf bFormulasFound Then
    'get formulas only:
    Set rgOccupied = rgFormulas
Else
    'nothing found
    Set rgOccupied = Nothing
End If

Set GetRangeOfOccupiedCellsFromRange = rgOccupied

End Function



Public Function ResetColumnNumberFormattingToText(array_header_variations As Variant)

'do not call this from Workbook_BeforeSave due to Excel bug; see comment there.
'call this from a timer instead.

    'loop through template sheets, resetting prod-id number formatting on each to text:
    Dim shTmp As Worksheet
    Dim rgTarget As Range
    Dim iCol As Long
    Dim iHeaderRow As Long
    Dim rgHeaderRow As Range
'    Dim vArrrayHeaderVariations As Variant
    Dim iUboundHeaderVariations As Long
    Dim iHeaderVariationItem As Long
    Dim strHeaderVariationName As String
    Dim rgFind As Range
    Dim bFound As Boolean
    
    On Error GoTo GenErr
    
'    vArrrayHeaderVariations = Array("product-id", "standard-product-id", "ProductID", "StandardProductID")
    iUboundHeaderVariations = UBound(array_header_variations)
    
    For Each shTmp In ThisWorkbook.Worksheets
        If InStr(shTmp.CodeName, "shTemplate") > 0 Then
            iHeaderRow = GetTemplateHeaderRow(shTmp)
            Set rgHeaderRow = shTmp.Rows(iHeaderRow)
            
            bFound = False 'init.
            For iHeaderVariationItem = 0 To iUboundHeaderVariations
                strHeaderVariationName = array_header_variations(iHeaderVariationItem)
                Set rgFind = rgHeaderRow.Find(What:=strHeaderVariationName, LookIn:=xlValues, LookAt:=xlWhole)
                Call ResetFindParametersToDefaults
                If Not rgFind Is Nothing Then
                    bFound = True
                    iCol = rgFind.Column
                    Exit For
                End If
            Next iHeaderVariationItem
            
            If bFound Then
                    Set rgTarget = shTmp.Range( _
                                        shTmp.Cells(iHeaderRow + 1, iCol), _
                                        shTmp.Cells(shTmp.Rows.Count, iCol))
                    Call ResetTargetRangeNumberFormattingToText(rgTarget)
            End If

        End If
    Next shTmp
Exit Function
GenErr:
If False Then
    Resume
End If
End Function




Public Function ResetProductIdNumberFormattingToText()

'do not call this from Workbook_BeforeSave due to Excel bug; see comment there.
'call this from a timer instead.

Dim vArrrayHeaderVariations As Variant

vArrrayHeaderVariations = Array("product-id", "standard-product-id", "ProductID", "StandardProductID")
Call ResetColumnNumberFormattingToText(vArrrayHeaderVariations)

End Function



Public Function UnlockCells(target_range As Range)
    'check for locked cells in target, indicating that they
    'got locked when pasted in from another source.
    'Selection.Locked is True if all cells in range are locked,
    'False if all are unlocked, or Null if mixed.
    'Changing Locked status turns off cutcopymode, so unlock only if True or Null:
    
    On Error Resume Next
    
    If target_range.Locked Or IsNull(target_range.Locked) Then
        If target_range.Row >= 3 And target_range.Rows.Count + (target_range.Row - 1) >= 3 Then
            'top row is row 1 or 2, and bottom row is also row 1 or 2:
            target_range.Locked = False
        End If
    End If
End Function



Public Function FixRepeatedPoundSigns(Optional target_range)

    'If cell value has more than 255 characters, the cell's number format must be
    'set to "General", NOT text ("@"). Otherwise the cell will display repeated
    'pound signs ("######") instead of the text.
    'This function checks the target range for that problem and fixes. Note that
    'the fix (if an affected cell is found) takes excel out of cutcopymode.
    
    Dim rgFind As Range
    
    If IsMissing(target_range) Then
        'do all template sheets:
        
        Dim shTmp As Worksheet
        Dim rgTarget As Range
        Dim iHeaderRow As Long
        
        For Each shTmp In ThisWorkbook.Worksheets
            If InStr(shTmp.CodeName, "shTemplate") > 0 Then
                iHeaderRow = GetTemplateHeaderRow(shTmp)
                
                Set rgTarget = shTmp.Range( _
                                    shTmp.Cells(iHeaderRow + 1, 1), _
                                    shTmp.Cells(shTmp.Rows.Count, shTmp.Columns.Count))

                Do
                    Set rgFind = rgTarget.Find(What:="##", LookIn:=xlValues, LookAt:=xlPart)
                    Call ResetFindParametersToDefaults
                    If rgFind Is Nothing Then Exit Function
                    If InStr(rgFind.Formula, "##") > 0 Then Exit Function 'quick fix for now.
                    If Len(rgFind.value) > 255 Then
                        If rgFind.NumberFormat = "@" Then
                            rgFind.NumberFormat = "General" 'note this takes Excel out of cutcopymode.
                        End If
                    End If
                Loop
            End If
        Next shTmp
        
    Else
    
        'target_range is provided:
        '(this loop s/b pulled out to separate function, as it is the same as above.)
        Do
            Set rgFind = target_range.Find(What:="##", LookIn:=xlValues, LookAt:=xlPart)
            Call ResetFindParametersToDefaults
            If rgFind Is Nothing Then Exit Function
            If InStr(rgFind.Formula, "##") > 0 Then Exit Function 'quick fix for now.
            If Len(rgFind.value) > 255 Then
                If rgFind.NumberFormat = "@" Then
                    rgFind.NumberFormat = "General" 'note this takes Excel out of cutcopymode.
                End If
            End If
        Loop
    End If

End Function


'Public Function CycleScreenUpdating()
'
'If Application.ScreenUpdating Then
'    Application.ScreenUpdating = False
'    Application.ScreenUpdating = True
'Else
'    Application.ScreenUpdating = True
'    Application.ScreenUpdating = False
'End If
'
'End Function


Public Function GetEnableEventsStatusAndTurnItOff() As Boolean
    GetEnableEventsStatusAndTurnItOff = Application.EnableEvents
    Application.EnableEvents = False
End Function



Public Sub GetNumberAsTextErrorCheckingStatusAndTurnItOff()
    'prevent Excel's confusing the user by telling them that there is a problem if
    'a number is entered in a cell formatted as text. But do it only when template
    'is the active workbook; store user's setting and restore it when template is not
    'the active workbook:
    bNumberAsTextErrorCheckingStatus = Application.ErrorCheckingOptions.NumberAsText
    Application.ErrorCheckingOptions.NumberAsText = False
End Sub



Public Function CopyWorkbook(source_wb As Workbook, target_fullpath As String, Optional file_name As String) As Workbook

'save a copy of source_wb to target_fullpath, deleting file if already there,
'then open it and return it as workbook object.

'should return Nothing on failure.

On Error GoTo GenErr

Dim bEnableEventsStatus As Boolean
bEnableEventsStatus = GetEnableEventsStatusAndTurnItOff

'close if file is open:
If file_name <> "" Then
    Dim wbWorkbook As Workbook
    For Each wbWorkbook In Application.Workbooks
        If wbWorkbook.Name = file_name Then
            wbWorkbook.Close SaveChanges:=False
            DoEvents
            Exit For
        End If
    Next wbWorkbook
End If

'delete if already exists:
Dim fso As Object
Dim oFolder As Object
Set fso = CreateObject("Scripting.FileSystemObject")
If fso.FileExists(target_fullpath) Then
    fso.DeleteFile target_fullpath
    DoEvents
End If


DoEvents
source_wb.SaveCopyAs target_fullpath
DoEvents
Set CopyWorkbook = Workbooks.Open(target_fullpath, UpdateLinks:=0) '0 = do not update links.
DoEvents
Application.EnableEvents = bEnableEventsStatus
DoEvents

Exit Function

GenErr:
Application.EnableEvents = bEnableEventsStatus
If False Then
    Resume
End If

End Function



Public Function RemoveUnneccessaryRowsInValidationTable(wb_template As Workbook) As Boolean

'returns true on success. Return value can be ignored by caller.

Dim vRows As Variant
Dim iTemplateSheetCounter As Long
Dim shFind As Worksheet
Dim strFindSheetCodeName As String
Dim bFound As Boolean

Dim shValidationTable As Worksheet
Dim shTmp As Worksheet, rgTmp As Range, rgDeleteRows As Range
Dim shWorksheet As Worksheet
Dim iKeepRow1 As Long, iKeepRow2 As Long
Dim iDeleteRow1 As Long, iDeleteRow2 As Long
Dim iIndex As Long, iUbound As Long

Dim arrayTemplateSheets() As Worksheet
    Dim iUboundTemplateSheets As Long
    Dim iArrayIndexTemplateSheets As Long
    Dim shArrayItemTemplateSheet As Worksheet

Set shValidationTable = wb_template.Worksheets(DATA_VALIDATION_TABLE_WORKSHEET_NAME)

On Error GoTo GenErr

Dim strTargetTemplateLanguage As String
strTargetTemplateLanguage = GetLocalLanguageName(, wb_template)


'before running ValidateTemplate to get rows to keep,
'must delete rows for other languages, because ValidateTemplate no longer checks the template test:
Dim iLastRow As Long
Dim iRow As Long
Dim iLanguageCol As Long
Dim rgDeleteThisRow As Range
Dim brgDeleteRowsIsInitialized As Boolean
brgDeleteRowsIsInitialized = False
iLastRow = shValidationTable.Cells.SpecialCells(xlLastCell).Row
iLanguageCol = shValidationTable.Rows(DATA_VALIDATION_TABLE_HEADER_ROW).Find(What:=DATA_VALIDATION_TABLE_LANGUAGE_COLUMN_HEADER, LookAt:=xlWhole).Column
Call ResetFindParametersToDefaults

        'turn off autofilter if present:
        Dim oAF As AutoFilter, rgAF As Range, rgDelete As Range
        Set oAF = shValidationTable.AutoFilter
        If Not oAF Is Nothing Then
            'autofilter is present, so remove it:
            oAF.Range.AutoFilter
        End If
        Set rgAF = shValidationTable.Range( _
                        shValidationTable.Cells(1, iLanguageCol), _
                        shValidationTable.Cells(iLastRow, iLanguageCol))
        rgAF.AutoFilter 'toggle on. Assumes no autofilter was present in the sheet.
        rgAF.AutoFilter Field:=1, Criteria1:="<>" & strTargetTemplateLanguage
        'delete rows that are not this template's language:
        shValidationTable.Rows(1).EntireRow.Hidden = True 'so that row 1 is not deleted.
        Set rgDelete = rgAF.SpecialCells(xlCellTypeVisible)
        rgDelete.EntireRow.Delete
        shValidationTable.Rows(1).EntireRow.Hidden = False
        rgAF.AutoFilter 'toggle off.

'''''old, slower way of removing rows for other languages; delete when sure new way is okay:
'''''Debug.Print "Starting RemoveUnneccessaryRowsInValidationTable at " & Now
'''''For iRow = 3 To iLastRow
'''''    If shValidationTable.Cells(iRow, iLanguageCol).value <> strTargetTemplateLanguage Then
''''''    If vLangCol(iRow, 1) <> strTargetTemplateLanguage Then
'''''        'add to range of rows to delete:
'''''        Set rgDeleteThisRow = shValidationTable.Rows(iRow)
'''''
'''''        If brgDeleteRowsIsInitialized Then
'''''            Set rgDeleteRows = Union(rgDeleteRows, rgDeleteThisRow)
'''''        Else
'''''            Set rgDeleteRows = rgDeleteThisRow
'''''            brgDeleteRowsIsInitialized = True
'''''        End If
'''''
'''''    End If
'''''    DoEvents
'''''Next iRow
'''''Debug.Print "Completed RemoveUnneccessaryRowsInValidationTable at " & Now
'''''rgDeleteRows.Delete


'get array of template sheets:

ReDim arrayTemplateSheets(0 To 0) As Worksheet
iUboundTemplateSheets = UBound(arrayTemplateSheets)
For Each shWorksheet In ThisWorkbook.Worksheets
    If InStr(shWorksheet.CodeName, "shTemplate") > 0 Then
        iUboundTemplateSheets = iUboundTemplateSheets + 1
        ReDim Preserve arrayTemplateSheets(0 To iUboundTemplateSheets) As Worksheet
        Set arrayTemplateSheets(iUboundTemplateSheets) = shWorksheet
    End If
Next shWorksheet



For iArrayIndexTemplateSheets = 1 To iUboundTemplateSheets
    Set shArrayItemTemplateSheet = arrayTemplateSheets(iArrayIndexTemplateSheets)
    shArrayItemTemplateSheet.Activate
    
    Call ValidateTemplate(True, , vRows, strTargetTemplateLanguage, True, True, True)
    
Next iArrayIndexTemplateSheets

Set shTmp = wb_template.Worksheets.Add
iUbound = UBound(vRows)
For iIndex = 1 To iUbound
    shTmp.Cells(iIndex, 1).value = vRows(iIndex)
Next iIndex
Set rgTmp = shTmp.UsedRange
rgTmp.Sort Key1:=shTmp.Cells(1, 1), Order1:=xlAscending, header:=xlNo, _
        Orientation:=xlTopToBottom, SortMethod:=xlPinYin
For iIndex = 1 To iUbound
    vRows(iIndex) = shTmp.Cells(iIndex, 1).value
Next iIndex
shTmp.Delete
Dim bDeleteRowsRangeObjectInitiated As Boolean

    iKeepRow1 = 2
        iDeleteRow1 = iKeepRow1 + 1
    iKeepRow2 = vRows(1)
        iDeleteRow2 = (iKeepRow2 - 3)
If iDeleteRow2 > 0 Then
    Set rgDeleteRows = shValidationTable.Rows(iDeleteRow1).Resize(iDeleteRow2) 'preserves row 1 & 2 while initializing rgDeleteRows. Note, for some templates, nothing is deleted here so rgDeleteRows must be initiated in next section.
    bDeleteRowsRangeObjectInitiated = True
End If

For iIndex = 2 To iUbound
    iKeepRow1 = vRows(iIndex - 1)
        iDeleteRow1 = iKeepRow1 + 1
    iKeepRow2 = vRows(iIndex)
        iDeleteRow2 = (iKeepRow2 - iKeepRow1) - 1
        If iDeleteRow2 > 0 Then
            'there are rows to delete here:
            If bDeleteRowsRangeObjectInitiated Then
                Set rgDeleteRows = Union(rgDeleteRows, shValidationTable.Rows(iDeleteRow1).Resize(iDeleteRow2))
            Else
                'must initiate rgDeleteRows:
                Set rgDeleteRows = shValidationTable.Rows(iDeleteRow1).Resize(iDeleteRow2)
                bDeleteRowsRangeObjectInitiated = True
            End If
        End If
Next iIndex

iDeleteRow1 = iKeepRow2 + 1
iDeleteRow2 = (shValidationTable.Rows.Count - iKeepRow2)
Set rgDeleteRows = Union(rgDeleteRows, shValidationTable.Rows(iDeleteRow1).Resize(iDeleteRow2))
rgDeleteRows.Delete


RemoveUnneccessaryRowsInValidationTable = True


Exit Function

GenErr:

If False Then
    Resume
End If

End Function




Public Function RemoveUnneccessaryColumnsInValidationTable(wb_template As Workbook) As Boolean

On Error Resume Next 'not important if any of this fails; just means larger workbook size.

Dim shValidationTable As Worksheet
Set shValidationTable = wb_template.Worksheets(DATA_VALIDATION_TABLE_WORKSHEET_NAME)

'delete the template dependency test column:
'(all remaining rows apply to this template)
Dim iTemplateTestCol As Long
iTemplateTestCol = shValidationTable.Rows(DATA_VALIDATION_TABLE_HEADER_ROW).Find(What:=DATA_VALIDATION_TABLE_TEMPLATE_DEPENDENCY_TEST_HEADER, LookAt:=xlWhole).Column
Call ResetFindParametersToDefaults
shValidationTable.Columns(iTemplateTestCol).EntireColumn.Delete

'delete the language column:
'(all remaining rows apply to this template)
Dim iLanguageCol As Long
iLanguageCol = shValidationTable.Rows(DATA_VALIDATION_TABLE_HEADER_ROW).Find(What:=DATA_VALIDATION_TABLE_LANGUAGE_COLUMN_HEADER, LookAt:=xlWhole).Column
Call ResetFindParametersToDefaults
shValidationTable.Columns(iLanguageCol).EntireColumn.Delete

'delete the sorting columns:
Dim iSortingCol As Long
'sorting column 1:
iSortingCol = shValidationTable.Rows(DATA_VALIDATION_TABLE_HEADER_ROW).Find(What:=DATA_VALIDATION_SORTING_COLUMN_HEADER_1, LookAt:=xlWhole).Column
Call ResetFindParametersToDefaults
shValidationTable.Columns(iSortingCol).EntireColumn.Delete
'sorting column 2:
iSortingCol = shValidationTable.Rows(DATA_VALIDATION_TABLE_HEADER_ROW).Find(What:=DATA_VALIDATION_SORTING_COLUMN_HEADER_2, LookAt:=xlWhole).Column
Call ResetFindParametersToDefaults
shValidationTable.Columns(iSortingCol).EntireColumn.Delete


'delete the fontname column:
Dim iFontnameCol As Long
iFontnameCol = shValidationTable.Rows(DATA_VALIDATION_TABLE_HEADER_ROW).Find(What:=DATA_VALIDATION_TABLE_FONTNAME_COLUMN_HEADER, LookAt:=xlWhole).Column
Call ResetFindParametersToDefaults
shValidationTable.Columns(iFontnameCol).EntireColumn.Delete

'delete the width (cell comment width) column:
Dim iWidthCol As Long
iWidthCol = shValidationTable.Rows(DATA_VALIDATION_TABLE_HEADER_ROW).Find(What:=DATA_VALIDATION_TABLE_WIDTH_COLUMN_HEADER, LookAt:=xlWhole).Column
Call ResetFindParametersToDefaults
shValidationTable.Columns(iWidthCol).EntireColumn.Delete

'delete the "test cell comment" column:
Dim iTestCellCommentCol As Long
iTestCellCommentCol = shValidationTable.Rows(DATA_VALIDATION_TABLE_HEADER_ROW).Find(What:=DATA_VALIDATION_TESTCELLCOMMENT_COLUMN_HEADER, LookAt:=xlWhole).Column
Call ResetFindParametersToDefaults
shValidationTable.Columns(iTestCellCommentCol).EntireColumn.Delete

End Function





Public Function RemoveOtherLanguageColumnsFromIntMiscData(sh_intmiscdata As Worksheet, target_language As String) As Boolean

'returns true on success. Caller can ignore return value.

On Error GoTo GenErr

Dim rgFind As Range
Dim rgCell As Range
Dim rgHeaderRange As Range
Dim rgDeleteColumns As Range
Dim iLastCol As Long

Set rgFind = sh_intmiscdata.Cells(INT_TABLE_HEADER_ROW, sh_intmiscdata.Columns.Count).End(xlToLeft)
iLastCol = rgFind.Column
Set rgHeaderRange = sh_intmiscdata.Range(sh_intmiscdata.Cells(INT_TABLE_HEADER_ROW, 1), sh_intmiscdata.Cells(INT_TABLE_HEADER_ROW, iLastCol))
For Each rgCell In rgHeaderRange.Cells
    Select Case rgCell.value
        Case INT_TABLE_DATA_CATEGORY_HEADER
            'skip
        Case INT_TABLE_REFERENCE_HEADER
            'skip
        Case INT_TABLE_NUMBER_FORMAT_HEADER
            'skip
        Case INT_TABLE_MASTER_NAME_HEADER
            'skip
        Case INT_TABLE_MFA_INTERNAL_NAME_HEADER
            'skip
        Case INT_TABLE_TEMPLATE_DEPENDENCY_TEST_HEADER
            'skip
        Case target_language
            'skip
        Case Else
            'add to rgDeleteColumns:
            If rgDeleteColumns Is Nothing Then
                Set rgDeleteColumns = rgCell.EntireColumn
            Else
                Set rgDeleteColumns = Union(rgDeleteColumns, rgCell.EntireColumn)
            End If
    End Select
Next rgCell
rgDeleteColumns.Delete Shift:=xlToLeft


Exit Function

GenErr:

If False Then
    Resume
End If

End Function


' added 10/08/10 by atambe
Public Function RemoveOtherLanguageColumnsFromIntTranslations(sh_translations As Worksheet, target_language As String) As Boolean
'returns true on success. Caller can ignore return value.

On Error GoTo GenErr

Dim rgFind As Range
Dim rgCell As Range
Dim rgHeaderRange As Range
Dim rgDeleteColumns As Range
Dim iLastCol As Long

Set rgFind = sh_translations.Cells(INT_TABLE_HEADER_ROW, sh_translations.Columns.Count).End(xlToLeft)

iLastCol = rgFind.Column

Set rgHeaderRange = sh_translations.Range(sh_translations.Cells(INT_TABLE_HEADER_ROW, 1), sh_translations.Cells(INT_TABLE_HEADER_ROW, iLastCol))

For Each rgCell In rgHeaderRange.Cells
    Select Case rgCell.value
        Case INT_TABLE_TRANSLATION_KEY_HEADER
            'skip
        Case target_language
            'skip
        Case Else
            'add to rgDeleteColumns:
            If rgDeleteColumns Is Nothing Then
                Set rgDeleteColumns = rgCell.EntireColumn
            Else
                Set rgDeleteColumns = Union(rgDeleteColumns, rgCell.EntireColumn)
            End If
    End Select
Next rgCell
rgDeleteColumns.Delete Shift:=xlToLeft

Exit Function

GenErr:
If False Then
    Resume
End If

End Function


Public Function WorkbookGotActivated()

    SetUpNewToolBar 'to make sure the OnAction properties for toolbar controls are pointed to this workbook.
                        '(they point to whatever workbook the code to create the toolbar ran from)
    If ThisWorkbookShowsTheBuildTemplatesToolbar And Not ToolbarToBuildInternationalTemplatesExists Then
        AddToolbarToBuildFlatFileTemplates
    End If

    Call DropdownsOnWorkbookActivate
    
    Call GetNumberAsTextErrorCheckingStatusAndTurnItOff
    
End Function



Public Function WorkbookGotDeactivated()

    RemoveToolBar 'To avoid problem where clicking a toolbar button in a localized
                  'template opens up the main (non-localized) template and runs the code from there,
                  'need to remove and recreate the Amazon toolbar on workbook deactivate/activate.
    
    If ThisWorkbookShowsTheBuildTemplatesToolbar And ToolbarToBuildInternationalTemplatesExists Then
        DeleteToolbarToBuildInternationalTemplates
    End If

    Call DropdownsOnWorkbookDeactivate
    
    Application.ErrorCheckingOptions.NumberAsText = bNumberAsTextErrorCheckingStatus
    
End Function


Public Function AmazonMsgBox(prompt As String, Optional buttons As Long, Optional title As String) As Long
'INPUT BUTTONS:
    'vbOKOnly = 0 (default)
    'vbOKCancel = 1
    'vbYesNo = 4
            'Note, VBA's MsgBox also offers:
                'vbAbortRetryIgnore
                'vbYesNoCancel
                'vbRetryCancel

'OUTPUT BUTTONS:
    'vbOK = 1
    'vbCancel = 2
    'vbYes = 6
    'vbNo = 7

'Note: can't run this from Immediate pane due to Enter key accepted as default. Instead,
'run this from modSupport.test (top procedure in this module).

On Error GoTo GenErr
    
Const MIN_FORM_WIDTH As Long = 250
Const MIN_FORM_HEIGHT As Long = 140
Const FORM_HEIGHT_OFFSET_FROM_LABEL_PROMPT_HEIGHT As Long = 125
Const INIT_LABEL_PROMPT_WIDTH As Long = 550
Const IMAGE_AMAZON_SERVICES_TOP As Long = 0
Const LABEL_PROMPT_TOP As Long = 45
Const LABEL_PROMPT_LEFT As Long = 10

Dim dblTwoButtonsTotalWidth As Double
Dim dblPromptLabelRatio As Double


frmAmazonMsgBox.Caption = title

frmAmazonMsgBox.lblPrompt.Top = LABEL_PROMPT_TOP
frmAmazonMsgBox.lblPrompt.Left = LABEL_PROMPT_LEFT
frmAmazonMsgBox.lblPrompt.WordWrap = False
frmAmazonMsgBox.lblPrompt.Width = INIT_LABEL_PROMPT_WIDTH
frmAmazonMsgBox.lblPrompt.Caption = prompt
frmAmazonMsgBox.lblPrompt.AutoSize = False
frmAmazonMsgBox.lblPrompt.AutoSize = True

If frmAmazonMsgBox.lblPrompt.Width > INIT_LABEL_PROMPT_WIDTH Then
    frmAmazonMsgBox.lblPrompt.WordWrap = True
    frmAmazonMsgBox.lblPrompt.Width = INIT_LABEL_PROMPT_WIDTH
    frmAmazonMsgBox.lblPrompt.AutoSize = False
    frmAmazonMsgBox.lblPrompt.AutoSize = True
End If

If frmAmazonMsgBox.lblPrompt.Width + 20 > MIN_FORM_WIDTH Then
    frmAmazonMsgBox.Width = frmAmazonMsgBox.lblPrompt.Width + 20
Else
    frmAmazonMsgBox.Width = MIN_FORM_WIDTH
End If

If frmAmazonMsgBox.lblPrompt.Height + FORM_HEIGHT_OFFSET_FROM_LABEL_PROMPT_HEIGHT > MIN_FORM_HEIGHT Then
    frmAmazonMsgBox.Height = frmAmazonMsgBox.lblPrompt.Height + FORM_HEIGHT_OFFSET_FROM_LABEL_PROMPT_HEIGHT
Else
    frmAmazonMsgBox.Height = MIN_FORM_HEIGHT
End If

' added 08/15/10 by atambe
If bChinaTemplate Then
    frmAmazonMsgBox.imgAmazonJoyo.Top = IMAGE_AMAZON_SERVICES_TOP
    frmAmazonMsgBox.imgAmazonJoyo.Left = ((frmAmazonMsgBox.Width / 2) - (frmAmazonMsgBox.imgAmazonJoyo.Width / 2)) - 3
Else
    frmAmazonMsgBox.imgAmazonServices.Top = IMAGE_AMAZON_SERVICES_TOP
    frmAmazonMsgBox.imgAmazonServices.Left = ((frmAmazonMsgBox.Width / 2) - (frmAmazonMsgBox.imgAmazonServices.Width / 2)) - 3
End If


Select Case buttons
    Case 0 'vbOKOnly
        frmAmazonMsgBox.imgOkay.Visible = True
        frmAmazonMsgBox.imgCancel.Visible = False
        frmAmazonMsgBox.imgYes.Visible = False
        frmAmazonMsgBox.ImgNo.Visible = False
        
        frmAmazonMsgBox.imgOkay.Top = frmAmazonMsgBox.Height - 55
        
        frmAmazonMsgBox.imgOkay.Left = ((frmAmazonMsgBox.Width / 2) - (frmAmazonMsgBox.imgOkay.Width / 2)) - 3
        
        iAmazonMsgBoxDefaultRet = vbOK
    Case 1 'vbOKCancel
        frmAmazonMsgBox.imgOkay.Visible = True
        frmAmazonMsgBox.imgCancel.Visible = True
        frmAmazonMsgBox.imgYes.Visible = False
        frmAmazonMsgBox.ImgNo.Visible = False
        
        frmAmazonMsgBox.imgOkay.Top = frmAmazonMsgBox.Height - 55
        frmAmazonMsgBox.imgCancel.Top = frmAmazonMsgBox.Height - 55
        
        dblTwoButtonsTotalWidth = (frmAmazonMsgBox.imgOkay.Width + frmAmazonMsgBox.imgCancel.Width) + 6
        frmAmazonMsgBox.imgOkay.Left = ((frmAmazonMsgBox.Width / 2) - (dblTwoButtonsTotalWidth / 2)) - 3
        frmAmazonMsgBox.imgCancel.Left = frmAmazonMsgBox.imgOkay.Left + frmAmazonMsgBox.imgOkay.Width + 6
        
        iAmazonMsgBoxDefaultRet = vbOK
    Case 4 'vbYesNo
        frmAmazonMsgBox.imgOkay.Visible = False
        frmAmazonMsgBox.imgCancel.Visible = False
        frmAmazonMsgBox.imgYes.Visible = True
        frmAmazonMsgBox.ImgNo.Visible = True

        frmAmazonMsgBox.imgYes.Top = frmAmazonMsgBox.Height - 55
        frmAmazonMsgBox.ImgNo.Top = frmAmazonMsgBox.Height - 55

        dblTwoButtonsTotalWidth = (frmAmazonMsgBox.imgYes.Width + frmAmazonMsgBox.ImgNo.Width) + 6
        frmAmazonMsgBox.imgYes.Left = ((frmAmazonMsgBox.Width / 2) - (dblTwoButtonsTotalWidth / 2)) - 3
        frmAmazonMsgBox.ImgNo.Left = frmAmazonMsgBox.imgYes.Left + frmAmazonMsgBox.imgYes.Width + 6
        
        iAmazonMsgBoxDefaultRet = vbYes
End Select

iAmazonMsgBoxRet = -1 'init. Must init before every use.
frmAmazonMsgBox.Show vbModal
Unload frmAmazonMsgBox
AmazonMsgBox = iAmazonMsgBoxRet


Exit Function

GenErr:
If False Then
    Resume
End If
    
End Function






Public Sub DeleteRow(ByVal RowNumber As Integer)

    shTemplate.Activate
    Application.ActiveSheet.Cells(RowNumber, ProductIDCol).Activate
    Application.ActiveCell.EntireRow.Delete
                
End Sub

Public Sub populateDefaultsAndOthers(ByVal RowNumber As Integer, ByRef feedRec() As amazonGlobals.OFFER_FEED_RECORD, Optional cnt As Integer = 1)

    If Not IsEmpty(Application.ActiveSheet.Cells(RowNumber, SKUCol).value) Then
        feedRec(0).SKU = Application.ActiveSheet.Cells(RowNumber, SKUCol).value
    Else
        If amazonGlobals.g_AutoFillSKU = True Then
            feedRec(0).SKU = "S_" & "_" & Format(Now, "mmdd") & "_" & feedRec(0).ProductID + "_" & Format(Now, "HHMMSS")
        Else
            If cnt > 1 Then
                feedRec(0).SKU = "###TEMP_S_" & "_" & Format(Now, "mmdd") & "_" & feedRec(0).ProductID + "_" & Format(Now, "HHMMSS")
            End If
        End If
    End If
    
    If Not IsEmpty(Application.ActiveSheet.Cells(RowNumber, pricecol).value) Then
        feedRec(0).Price = Application.ActiveSheet.Cells(RowNumber, pricecol).value
    End If

    If Not IsEmpty(Application.ActiveSheet.Cells(RowNumber, QuantityCol).value) Then
        feedRec(0).Quantity = Application.ActiveSheet.Cells(RowNumber, QuantityCol).value
    Else
        feedRec(0).Quantity = 1
    End If
    
    If Not IsEmpty(Application.ActiveSheet.Cells(RowNumber, ProductTaxCodeCol).value) Then
        feedRec(0).ProductTaxCode = Application.ActiveSheet.Cells(RowNumber, ProductTaxCodeCol).value
    Else
        feedRec(0).ProductTaxCode = amazonGlobals.g_DefProdTaxCode
    End If

    If Not IsEmpty(Application.ActiveSheet.Cells(RowNumber, ConditionCol).value) Then
        feedRec(0).Condition = Application.ActiveSheet.Cells(RowNumber, ConditionCol).value
    Else
        feedRec(0).Condition = amazonGlobals.g_DefProdCondition
    End If
    
    If Not IsEmpty(Application.ActiveSheet.Cells(RowNumber, ConditionNoteCol).value) Then
        feedRec(0).ConditionNote = Application.ActiveSheet.Cells(RowNumber, ConditionNoteCol).value
    End If
    
    If Not IsEmpty(Application.ActiveSheet.Cells(RowNumber, UpdateDeleteCol).value) Then
        feedRec(0).UpdateDelete = Application.ActiveSheet.Cells(RowNumber, UpdateDeleteCol).value
    Else
        feedRec(0).UpdateDelete = amazonGlobals.g_DefUpdateDelete
    End If
    
    If Not IsEmpty(Application.ActiveSheet.Cells(RowNumber, DescriptionCol).value) Then
        If feedRec(0).Description = "" Then
            feedRec(0).Description = Application.ActiveSheet.Cells(RowNumber, DescriptionCol).value
        End If
    End If
    
    If Not IsEmpty(Application.ActiveSheet.Cells(RowNumber, ManufacturerCol).value) Then
        If feedRec(0).Manufacturer = "" Then
            feedRec(0).Manufacturer = Application.ActiveSheet.Cells(RowNumber, ManufacturerCol).value
        End If
    End If
    
    If Not IsEmpty(Application.ActiveSheet.Cells(RowNumber, TitleCol).value) Then
        If feedRec(0).title = "" Then
            feedRec(0).title = Application.ActiveSheet.Cells(RowNumber, TitleCol).value
        End If
    End If
    
    If Not IsEmpty(Application.ActiveSheet.Cells(RowNumber, AmazonidCol).value) Then
        If feedRec(0).AmazonID = "" Then
            feedRec(0).AmazonID = Application.ActiveSheet.Cells(RowNumber, AmazonidCol).value
        End If
    End If
    
    
    
    If Not IsEmpty(Application.ActiveSheet.Cells(RowNumber, IsGiftWrapAvailableCol).value) Then
        feedRec(0).IsGiftWrapAvailable = Application.ActiveSheet.Cells(RowNumber, IsGiftWrapAvailableCol).value
    End If
    
    If Not IsEmpty(Application.ActiveSheet.Cells(RowNumber, IsGiftMessageAvailableCol).value) Then
        feedRec(0).IsGiftMessageAvailable = Application.ActiveSheet.Cells(RowNumber, IsGiftMessageAvailableCol).value
    End If
    
    If Not IsEmpty(Application.ActiveSheet.Cells(RowNumber, SalesPriceCol).value) Then
        feedRec(0).SalesPrice = Application.ActiveSheet.Cells(RowNumber, SalesPriceCol).value
    End If
    
    If Not IsEmpty(Application.ActiveSheet.Cells(RowNumber, SaleStartDateCol).value) Then
        feedRec(0).SaleStartDate = Application.ActiveSheet.Cells(RowNumber, SaleStartDateCol).value
    End If
    
    If Not IsEmpty(Application.ActiveSheet.Cells(RowNumber, SaleEndDateCol).value) Then
        feedRec(0).SaleEndDate = Application.ActiveSheet.Cells(RowNumber, SaleEndDateCol).value
    End If
    
    If Not IsEmpty(Application.ActiveSheet.Cells(RowNumber, ShipOptionCol).value) Then
        feedRec(0).ShipOption = Application.ActiveSheet.Cells(RowNumber, ShipOptionCol).value
    End If
    
    If Not IsEmpty(Application.ActiveSheet.Cells(RowNumber, ShippingAmountTypeCol).value) Then
        feedRec(0).ShippingAmountType = Application.ActiveSheet.Cells(RowNumber, ShippingAmountTypeCol).value
    End If
    
    If Not IsEmpty(Application.ActiveSheet.Cells(RowNumber, IsShippingRestrictedCol).value) Then
        feedRec(0).IsShippingRestricted = Application.ActiveSheet.Cells(RowNumber, IsShippingRestrictedCol).value
    End If
    
    Dim i As Integer
    For i = 1 To cnt - 1
        feedRec(i).SKU = feedRec(0).SKU
        feedRec(i).Price = feedRec(0).Price
        feedRec(i).Quantity = feedRec(0).Quantity
        feedRec(i).ProductTaxCode = feedRec(0).ProductTaxCode
        feedRec(i).Condition = feedRec(0).Condition
        feedRec(i).ConditionNote = feedRec(0).ConditionNote
        feedRec(i).UpdateDelete = feedRec(0).UpdateDelete
        feedRec(i).Description = feedRec(0).Description
        feedRec(i).IsGiftWrapAvailable = feedRec(0).IsGiftWrapAvailable
        feedRec(i).IsGiftMessageAvailable = feedRec(0).IsGiftMessageAvailable
        feedRec(i).SalesPrice = feedRec(0).SalesPrice
        feedRec(i).SaleStartDate = feedRec(0).SaleStartDate
        feedRec(i).SaleEndDate = feedRec(0).SaleEndDate
        feedRec(i).ShipOption = feedRec(0).ShipOption
        feedRec(i).ShippingAmountType = feedRec(0).ShippingAmountType
        feedRec(i).IsShippingRestricted = feedRec(0).IsShippingRestricted
    Next i
End Sub

Public Sub populateRow(ByVal RowNumber As Integer, ByRef feedRec As amazonGlobals.OFFER_FEED_RECORD)
    Dim oldval As Boolean
    oldval = Application.EnableEvents
    Application.EnableEvents = False

    Application.ActiveSheet.Cells(RowNumber, ProductTypeCol).value = feedRec.SearchIndex
    Application.ActiveSheet.Cells(RowNumber, ProductIDCol).value = feedRec.ProductID
    Application.ActiveSheet.Cells(RowNumber, ProductIDTypeCol).value = feedRec.ProductIDType
    Application.ActiveSheet.Cells(RowNumber, AmazonidCol).value = feedRec.AmazonID
    Application.ActiveSheet.Cells(RowNumber, ManufacturerCol).value = feedRec.Manufacturer
    Application.ActiveSheet.Cells(RowNumber, TitleCol).value = feedRec.title
    Application.ActiveSheet.Cells(RowNumber, DescriptionCol).value = feedRec.Description
    Application.ActiveSheet.Cells(RowNumber, SKUCol).value = feedRec.SKU
    Application.ActiveSheet.Cells(RowNumber, pricecol).value = feedRec.Price
    Application.ActiveSheet.Cells(RowNumber, QuantityCol).value = feedRec.Quantity
    Application.ActiveSheet.Cells(RowNumber, ProductTaxCodeCol).value = feedRec.ProductTaxCode
    Application.ActiveSheet.Cells(RowNumber, ConditionCol).value = feedRec.Condition
    Application.ActiveSheet.Cells(RowNumber, ConditionNoteCol).value = feedRec.ConditionNote
    Application.ActiveSheet.Cells(RowNumber, UpdateDeleteCol).value = feedRec.UpdateDelete
    Application.ActiveSheet.Cells(RowNumber, DescriptionCol).value = feedRec.Description
    Application.ActiveSheet.Cells(RowNumber, IsGiftWrapAvailableCol).value = feedRec.IsGiftWrapAvailable
    Application.ActiveSheet.Cells(RowNumber, IsGiftMessageAvailableCol).value = feedRec.IsGiftMessageAvailable
    Application.ActiveSheet.Cells(RowNumber, SalesPriceCol).value = feedRec.SalesPrice
    Application.ActiveSheet.Cells(RowNumber, SaleStartDateCol).value = feedRec.SaleStartDate
    Application.ActiveSheet.Cells(RowNumber, SaleEndDateCol).value = feedRec.SaleEndDate
    Application.ActiveSheet.Cells(RowNumber, ShipOptionCol).value = feedRec.ShipOption
    Application.ActiveSheet.Cells(RowNumber, ShippingAmountTypeCol).value = feedRec.ShippingAmountType
    Application.ActiveSheet.Cells(RowNumber, IsShippingRestrictedCol).value = feedRec.IsShippingRestricted
        
    Application.ActiveSheet.Cells(RowNumber, ProductIDCol).Activate
    Application.EnableEvents = oldval
End Sub

Public Function AppendRow(ByRef feedRec As amazonGlobals.OFFER_FEED_RECORD) As Integer
    populateRow shTemplate.UsedRange.Rows.Count + 1, feedRec
    AppendRow = shTemplate.UsedRange.Rows.Count + 1
End Function




Public Function ResetProdIdAndPriceColsNumberFormattingToText()
    'call this on template sheet's sheet activate, and before upload.
    'NO, that took too long, so this is not currently in use.
    
    Dim shIntTable As Worksheet
    Dim shTemplate As Worksheet
    Dim rgTargetRange As Range
    Dim iIntTableMfaInternalNameCol As Long
    Dim iIntTableLocalNameCol As Long
    Dim iTemplateHeaderRow As Long
    Dim iProdIdCol As Long
    Dim iPriceCol As Long
    Dim strProdIdMfaInternalName As String
    Dim strPriceMfaInternalName As String
    Dim strProdIdLocalTemplateName As String
    Dim strPriceLocalTemplateName As String
    Dim bEnableEventsSetting As Boolean
    
    Const PROD_ID_FIELDNAME As String = "product-id"
    Const PRICE_FIELDNAME As String = "price"
    
'    On Error Resume Next

    If Not Application.CutCopyMode = 0 Then
        'don't do this if in cutcopymode, because this takes Excel
        'out of cutcopymode.
        Exit Function
    End If
    
    bEnableEventsSetting = Application.EnableEvents
    Application.EnableEvents = False
    
    Set shIntTable = ThisWorkbook.Worksheets(INT_TABLE_WORKSHEET_NAME)
    Set shTemplate = GetTemplateWorksheet()
    iIntTableMfaInternalNameCol = GetIntTableMfaInternalNameColumn(shIntTable)
    iIntTableLocalNameCol = GetIntTableLocalLanguageColumn(shIntTable)
    iTemplateHeaderRow = GetTemplateHeaderRow(shTemplate)


    strProdIdMfaInternalName = GetMfaInternalNameColumnHeaderFromLocalLanguageColumnHeader(PROD_ID_FIELDNAME)
    strPriceMfaInternalName = GetMfaInternalNameColumnHeaderFromLocalLanguageColumnHeader(PRICE_FIELDNAME)

    strProdIdLocalTemplateName = GetLocalColumnHeaderFromMfaInternalName( _
                                                    strProdIdMfaInternalName, _
                                                    shIntTable, shTemplate, _
                                                    iIntTableMfaInternalNameCol, iIntTableLocalNameCol, _
                                                    iTemplateHeaderRow)
    strPriceLocalTemplateName = GetLocalColumnHeaderFromMfaInternalName( _
                                                    strPriceMfaInternalName, _
                                                    shIntTable, shTemplate, _
                                                    iIntTableMfaInternalNameCol, iIntTableLocalNameCol, _
                                                    iTemplateHeaderRow)
    'prod-id:
    If strProdIdLocalTemplateName = "" Then
        'there is no product id column, so skip.
        GoTo GoToPrice
    Else
        iProdIdCol = FindColumn(shTemplate.Rows(iTemplateHeaderRow), _
                                strProdIdLocalTemplateName)
        If iProdIdCol = -1 Then
            'not found:
            Application.EnableEvents = bEnableEventsSetting
            Exit Function
        End If
    End If
    
    Set rgTargetRange = shTemplate.Range( _
                            shTemplate.Cells(iTemplateHeaderRow + 1, iProdIdCol), _
                            shTemplate.Cells(shTemplate.Rows.Count, iProdIdCol))
'    shTemplate.Unprotect
    rgTargetRange.NumberFormat = "@" 'Text.
'    rgTargetRange.Formula = rgTargetRange.Formula
'    Call ProtectSheet(shTemplate)
    
    
    
    'price:
GoToPrice:
    If strPriceLocalTemplateName = "" Then
        'there is no price column, so exit.
        Exit Function
    Else
        iPriceCol = FindColumn(shTemplate.Rows(iTemplateHeaderRow), _
                                strPriceLocalTemplateName)
        If iPriceCol = -1 Then
            'not found:
            Application.EnableEvents = bEnableEventsSetting
            Exit Function
        End If
    End If
    
    Set rgTargetRange = shTemplate.Range( _
                            shTemplate.Cells(iTemplateHeaderRow + 1, iPriceCol), _
                            shTemplate.Cells(shTemplate.Rows.Count, iPriceCol))
'    shTemplate.Unprotect
    rgTargetRange.NumberFormat = "@" 'Text.
'    rgTargetRange.Formula = rgTargetRange.Formula
'    Call ProtectSheet(shTemplate)
    
    
'    Call ProtectSheet(shTemplate)
    Application.EnableEvents = bEnableEventsSetting

End Function





Public Sub toggleActiveProductLookup()
    amazonGlobals.toggleToolBar
    shTemplate.Select
End Sub





Public Sub TemplateWorksheetGotActivated()
    On Error Resume Next
  Application.CommandBars("Amazon Feed Manager").Controls("Batch Lookup").Enabled = True
  Application.CommandBars("Amazon Feed Manager").Controls.Item(2).Enabled = True
  'Application.CommandBars("Amazon Feed Manager").Controls("Upload File").Enabled = True
  'Application.CommandBars("Amazon Feed Manager").Controls("Preferences").Enabled = True
  'Application.CommandBars("Amazon Feed Manager").Controls("Import File").Enabled = True
  'Application.CommandBars("Amazon Feed Manager").Controls("Autofill SKU").Enabled = True
  'Application.CommandBars("Amazon Feed Manager").Controls("Default Condition").Enabled = True
  
  'Call ResetProdIdAndPriceColsNumberFormattingToText 'this takes a long time and probably isn't necessary now that ResetTargetRangeNumberFormattingToText is being called from TemplateSheetGotWorksheetChanged.
'  Call ProtectSheet(ActiveSheet)
  
  Call ActivateExcel2007AddInsTab
End Sub


Public Sub TemplateWorksheetGotChanged(ByVal Target As Range)
    Call UnlockCells(Target)
    Call OnCellEditRemoveValidationIndicators(Target)
End Sub


Public Sub TemplateWorksheetGotSelectionChanged(ByVal Target As Range)
On Error Resume Next
'If amazonGlobals.activeModeLookup = True And Target.Column = ProductIDCol + 1 And Target.Row >= DataStartRow Then
'    Dim oldval As Boolean
'    oldval = Application.EnableEvents
'
'    Application.EnableEvents = False
'
'    Dim firstrow As Integer
'
'    If shTemplate Is Nothing Then Set shTemplate = GetTemplateWorksheet()
'
'    amazonGlobals.errorThrown = noError
''    firstrow = shTemplate.singleLookupInformation(Target.Row)
'    firstrow = Worksheets(shTemplate.Name).singleLookupInformation(Target.Row)
'    Application.EnableEvents = oldval
'    If errors Then
'        Select Case (amazonGlobals.errorThrown)
'            Case noInfoInAmazon:
''                MsgBox "Not Found" & vbCrLf & "Item Does not exist in Amazon.com in the category you specified and has been moved to Sheet 'Items Not in Amazon Catalog'.", vbInformation, "Error"
'                AmazonMsgBox "Not Found" & vbCrLf & "Item Does not exist in Amazon.com in the category you specified and has been moved to Sheet 'Items Not in Amazon Catalog'.", vbOKOnly, "Error"
'            Case badIdentifier:
''                MsgBox "Bad Identifier" & vbCrLf & "Product ID should be of type UPC or EAN or ISBN. Item  and has been moved to Sheet 'Items Not in Amazon Catalog'. ", vbInformation, "Error"
'                AmazonMsgBox "Bad Identifier" & vbCrLf & "Product ID should be of type UPC or EAN or ISBN. Item  and has been moved to Sheet 'Items Not in Amazon Catalog'. ", vbOKOnly, "Error"
'            Case multipleMatches:
''                MsgBox "Multiple Matches" & vbCrLf & "Product is matched to multiple products on Amazon.com. Please select the appropriate one from Sheet 'Items with Multiple Matches'.", vbInformation, "Error"
'                AmazonMsgBox "Multiple Matches" & vbCrLf & "Product is matched to multiple products on Amazon.com. Please select the appropriate one from Sheet 'Items with Multiple Matches'.", vbOKOnly, "Error"
''                Sheet3.Activate
'                'Sheet3.Cells(Sheet3.UsedRange.Rows.Count, ProductIDCol).Activate
''                Sheet3.Cells(firstrow, 1).Activate
'            Case nullIdentifier:
''                MsgBox "Identifier Empty" & vbCrLf & "Product ID should be of type UPC or EAN or ISBN . Item  and has been moved to Sheet 'Items Not in Amazon Catalog'.", vbInformation, "Error"
'                AmazonMsgBox "Identifier Empty" & vbCrLf & "Product ID should be of type UPC or EAN or ISBN . Item  and has been moved to Sheet 'Items Not in Amazon Catalog'.", vbOKOnly, "Error"
'
'        End Select
'    End If
'Else


Call SelectionChangeDropDown(Target)


'End If
End Sub



Public Sub ResetFindParametersToDefaults()
    Dim rg As Range
    Set rg = ActiveSheet.Range("A1:A2").Find( _
                  What:="", After:=ActiveSheet.Range("A1"), LookIn:=xlFormulas, LookAt:=xlPart, _
                  SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=False, SearchFormat:=False)
    Set rg = Nothing
End Sub



Public Sub CheckCurrentStatusGotClicked()
'Set objWeb = CreateObject("InternetExplorer.Application")
'objWeb.Navigate "https://sellercentral.amazon.com/gp/transactions/uploadMPInventory.html"
'objWeb.Visible = True
'
'Call BrowseTo("https://sellercentral.amazon.com/gp/transactions/uploadMPInventory.html")
'
'Call BrowseTo(GetLocalURL(URL_HEADER_STATUS_CHECK_PROD))

'========================================================================================================
'obsolete as of 2009-12-02:
'Dim strStatusCheckURLType As String
'
'strStatusCheckURLType = ThisWorkbook.Names(STATUS_CHECK_URL_TYPE_DEFINED_NAME).RefersToRange.Value
'If strStatusCheckURLType = STATUS_CHECK_URL_TYPE_NOSELLERCENTRAL Then
'    'check for devo:
'    If UCase(ThisWorkbook.Names(IS_DEVO_DEFINED_NAME).RefersToRange.Value) = "FALSE" Then 'added ucase 2009-12-02.
'        'this is production, not devo, therefore seamless uses same status check url as non-seamless:
'        strStatusCheckURLType = STATUS_CHECK_URL_TYPE_USESELLERCENTRAL
'    Else
'        'this is devo, therefore seamless uses the devo seamless status check url, so do nothing here.
'    End If
'End If
'
'bOkayToCheckStatus = True 'init '2009-10-09
'If strStatusCheckURLType = STATUS_CHECK_URL_TYPE_USESELLERCENTRAL Then
'    strStatusCheckURL = GetLocalURL(URL_HEADER_STATUS_CHECK_PROD)
'ElseIf strStatusCheckURLType = STATUS_CHECK_URL_TYPE_NOSELLERCENTRAL Then
'    strStatusCheckURL = GetLocalURL(URL_HEADER_STATUS_CHECK_DEVO)
'Else
'    bOkayToCheckStatus = False
'End If
'========================================================================================================


'2009-12-02:
'now, per Jenny, all devo goes to devo url; all prod goes to prod url:
Dim bOkayToCheckStatus As Boolean
Dim strStatusCheckURL As String
bOkayToCheckStatus = True 'init
If UCase(ThisWorkbook.Names(IS_DEVO_DEFINED_NAME).RefersToRange.value) = "FALSE" Then
    'this is prod:
    strStatusCheckURL = GetLocalURL(URL_HEADER_STATUS_CHECK_PROD)
ElseIf UCase(ThisWorkbook.Names(IS_DEVO_DEFINED_NAME).RefersToRange.value) = "TRUE" Then
    'this is devo:
    strStatusCheckURL = GetLocalURL(URL_HEADER_STATUS_CHECK_DEVO)
Else
    bOkayToCheckStatus = False
End If



If bOkayToCheckStatus Then
    Call BrowseTo(strStatusCheckURL)
Else
'    MsgBox "Unable to check status.", vbInformation + vbOKOnly, "Upload Success"
    AmazonMsgBox GetTranslatedString("unable_to_check"), vbOKOnly, GetTranslatedString("upload_success")
End If

End Sub

' added 07/29/10 by atambe
Public Function EncryptString(Text As String, password As String) As String
' encrypt a string using the provided password
    Dim oRijndael        As CRijndael
    Dim byteIn()         As Byte
    Dim bytePassword()   As Byte
    Dim byteOut()        As Byte
    
    Set oRijndael = New CRijndael
    
    byteIn = StrConv(Text, vbFromUnicode)
    bytePassword = StrConv(password, vbFromUnicode)
    
    byteOut = oRijndael.EncryptData(byteIn, bytePassword)
    
    EncryptString = StrConv(byteOut, vbUnicode)
End Function

' added 07/29/10 by atambe
Public Function DecryptString(Text As String, password As String) As String
' decrypt a string using the provided password, returns empty string on failure
    On Error GoTo ErrorHandler
    
    Dim oRijndael        As CRijndael
    Dim byteIn()         As Byte
    Dim bytePassword()   As Byte
    Dim byteOut()        As Byte
    
    Set oRijndael = New CRijndael
    
    byteOut = StrConv(Text, vbFromUnicode)
    bytePassword = StrConv(password, vbFromUnicode)
    
    byteIn = oRijndael.DecryptData(byteOut, bytePassword)
    
    DecryptString = StrConv(byteIn, vbUnicode)
    
    Exit Function
    
ErrorHandler:
    DecryptString = ""
End Function

' added 10/07/10 by atambe
Public Function GetTranslatedString(key As String) As String
' get the correct translated version of the string depending on the template language
    On Error GoTo ErrorHandler
    
    key = "translation_key_" & key
    
    GetTranslatedString = ThisWorkbook.Names(key).RefersToRange.value
    
    Exit Function
    
ErrorHandler:
    GetTranslatedString = ""
End Function

' added 10/12/10 by atambe
Public Function TranslateFormControls(form As Object) As String
' translate all controls that have text on the form
    Dim formControl As Control
    
    form.Caption = GetTranslatedString(form.Tag)
    
    For Each formControl In form.Controls
        If formControl.Tag <> "" Then
            formControl.Caption = GetTranslatedString(formControl.Tag)
        End If
    Next
End Function



Public Function GetTrailingNum(str) As Long
    On Error GoTo GenErr
    Dim strChar As String
    Dim iChar As Long
    Dim iLen As Long
    Dim bDone As Boolean
    
    iLen = 1 'init.
    bDone = False
    
    Do
        
        strChar = Right(str, iLen)
        iChar = AscW(strChar)
        If iChar > 47 And iChar < 58 Then
            GetTrailingNum = CLng(Right(str, iLen))
        Else
            Exit Do
        End If
        iLen = iLen + 1
    Loop
    
    If iLen = 1 Then GetTrailingNum = -1
    
    Exit Function
    
GenErr:
    bDone = True
    Resume Next
End Function
Attribute VB_Name = "modTimeZones"
Option Explicit
Option Compare Text
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' modTimeZones
' By Chip Pearson, chip@cpearson.com, www.cpearson.com
' Date: 2-April-2008
' Page Specific URL: www.cpearson.com/Excel/TimeZoneAndDaylightTime.aspx
'
' This module contains functions related to time zones and GMT times.
'   Terms:
'   -------------------------
'   GMT = Greenwich Mean Time. Many applications use the term
'       UTC (Universal Coordinated Time). GMT and UTC are
'       interchangable in meaning,
'   Local Time = The local "wall clock" time of day, that time that
'       you would set a clock to.
'   DST = Daylight Savings Time

'   Functions In This Module:
'   -------------------------
'       ConvertLocalToGMT
'           Converts a local time to GMT. Optionally adjusts for DST.
'       DaylightTime
'           Returns a value indicating (1) DST is in effect, (2) DST is
'           not in effect, or (3) Windows cannot determine whether DST is
'           in effect.
'       GetLocalTimeFromGMT
'           Converts a GMT Time to a Local Time, optionally adjusting for DST.
'       LocalOffsetFromGMT
'           Returns the number of hours or minutes between the local time and GMT,
'           optionally adjusting for DST.
'       SystemTimeToVBTime
'           Converts a SYSTEMTIME structure to a valid VB/VBA date.
'       LocalOffsetFromGMT
'           Returns the number of minutes or hours that are to be added to
'           the local time to get GMT. Optionally adjusts for DST.
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


'==========================================================================================
'For 64-bit compatibility.

'MSDN: Compatibility Between the 32-bit and 64-bit Versions of Office 2010:
    'http://msdn.microsoft.com/en-us/library/ee691831.aspx
'Technet: Microsoft Office Code Compatibility Inspector:
    'http://technet.microsoft.com/en-us/library/ee833946.aspx
'Samples:
    'The Microsoft file Win32_PtrSafe.txt contains 64-bit Windows API Declarations and Constants for VBA:
        'http://support.microsoft.com/kb/2030490
        'http://www.microsoft.com/downloads/en/details.aspx?FamilyID=035b72a5-eef9-4baf-8dbc-63fbd2dd982b&displaylang=en
    'http://www.jkp-ads.com/articles/apideclarations.asp
'Windows API functions that were modified/added for 64-bit Windows:
    'http://msdn.microsoft.com/en-us/library/aa383663(VS.85).aspx

'PtrSafe:
    'For Excel 2010 and later (#Vba7 = True), change "Declare" to "Declare PtrSafe".
'LongPtr:
    'For Excel 2010 and later (#Vba7 = True), change the data type of handles and pointers
    'from Long to LongPtr. Leave pointers to strings as String.
'LongLong:
    'For 64-bit Excel (#Win64 = True), change Long (except for handles and pointers!) to LongLong

#If Mac Then
    'Running on MacIntosh. Do nothing.
#ElseIf VBA7 Then
    'Excel 2010 or later:
     #If Win64 Then
        '64-bit Excel, 2010 or later:
        'Use PtrSafe, LongPtr, and LongLong:
        
            Private Type SYSTEMTIME
                wYear As Integer
                wMonth As Integer
                wDayOfWeek As Integer
                wDay As Integer
                wHour As Integer
                wMinute As Integer
                wSecond As Integer
                wMilliseconds As Integer
            End Type
            
            Private Type TIME_ZONE_INFORMATION
                Bias As Long 'LongLong  'no, use Long here even on 64-bit Excel.
                StandardName(0 To 31) As Integer
                StandardDate As SYSTEMTIME
                StandardBias As Long 'LongLong  'no, use Long here even on 64-bit Excel.
                DaylightName(0 To 31) As Integer
                DaylightDate As SYSTEMTIME
                DaylightBias As Long 'LongLong  'no, use Long here even on 64-bit Excel.
            End Type
            
            Public Enum TIME_ZONE
                TIME_ZONE_ID_INVALID = 0
                TIME_ZONE_STANDARD = 1
                TIME_ZONE_DAYLIGHT = 2
            End Enum
                
            
            Private Declare PtrSafe Function GetTimeZoneInformation Lib "kernel32" _
                (lpTimeZoneInformation As TIME_ZONE_INFORMATION) As LongLong
            
            Private Declare PtrSafe Sub GetSystemTime Lib "kernel32" _
                (lpSystemTime As SYSTEMTIME)

     #Else
        '32-bit Excel 2010 or later:
        'Use PtrSafe and LongPtr, but NOT LongLong:

            Private Type SYSTEMTIME
                wYear As Integer
                wMonth As Integer
                wDayOfWeek As Integer
                wDay As Integer
                wHour As Integer
                wMinute As Integer
                wSecond As Integer
                wMilliseconds As Integer
            End Type
            
            Private Type TIME_ZONE_INFORMATION
                Bias As Long
                StandardName(0 To 31) As Integer
                StandardDate As SYSTEMTIME
                StandardBias As Long
                DaylightName(0 To 31) As Integer
                DaylightDate As SYSTEMTIME
                DaylightBias As Long
            End Type
            
            Public Enum TIME_ZONE
                TIME_ZONE_ID_INVALID = 0
                TIME_ZONE_STANDARD = 1
                TIME_ZONE_DAYLIGHT = 2
            End Enum
                
            
            Private Declare PtrSafe Function GetTimeZoneInformation Lib "kernel32" _
                (lpTimeZoneInformation As TIME_ZONE_INFORMATION) As Long
            
            Private Declare PtrSafe Sub GetSystemTime Lib "kernel32" _
                (lpSystemTime As SYSTEMTIME)
        
     #End If
#Else
    'Excel 2007 or earlier:

        Private Type SYSTEMTIME
            wYear As Integer
            wMonth As Integer
            wDayOfWeek As Integer
            wDay As Integer
            wHour As Integer
            wMinute As Integer
            wSecond As Integer
            wMilliseconds As Integer
        End Type
        
        Private Type TIME_ZONE_INFORMATION
            Bias As Long
            StandardName(0 To 31) As Integer
            StandardDate As SYSTEMTIME
            StandardBias As Long
            DaylightName(0 To 31) As Integer
            DaylightDate As SYSTEMTIME
            DaylightBias As Long
        End Type
        
        Public Enum TIME_ZONE
            TIME_ZONE_ID_INVALID = 0
            TIME_ZONE_STANDARD = 1
            TIME_ZONE_DAYLIGHT = 2
        End Enum
            
        
        Private Declare Function GetTimeZoneInformation Lib "kernel32" _
            (lpTimeZoneInformation As TIME_ZONE_INFORMATION) As Long
        
        Private Declare Sub GetSystemTime Lib "kernel32" _
            (lpSystemTime As SYSTEMTIME)

#End If

'==========================================================================================




Function ConvertLocalToGMT(Optional LocalTime As Date, _
    Optional AdjustForDST As Boolean = False) As Date
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' ConvertLocalToGMT
' This converts a local time to GMT. If LocalTime is present, that local
' time is converted to GMT. If LocalTime is omitted, the current time is
' converted from local to GMT. If AdjustForDST is Fasle, no adjustments
' are made to accomodate DST. If AdjustForDST is True, and DST is
' in effect, the time is adjusted for DST by adding
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Dim t As Date
Dim TZI As TIME_ZONE_INFORMATION
Dim DST As TIME_ZONE
Dim GMT As Date

If LocalTime <= 0 Then
    t = Now
Else
    t = LocalTime
End If
DST = CLng(GetTimeZoneInformation(TZI))
If AdjustForDST = True Then
    GMT = t + TimeSerial(0, TZI.Bias, 0) + _
            IIf(DST = TIME_ZONE_DAYLIGHT, TimeSerial(0, TZI.DaylightBias, 0), 0)
Else
    GMT = t + TimeSerial(0, TZI.Bias, 0)
End If
ConvertLocalToGMT = GMT

End Function


Function GetLocalTimeFromGMT(Optional StartTime As Date) As Date
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' GetLocalTimeFromGMT
' This returns the Local Time from a GMT time. If StartDate is present and
' greater than 0, it is assumed to be the GMT from which we will calculate
' Local Time. If StartTime is 0 or omitted, it is assumed to be the GMT
' local time.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Dim GMT As Date
Dim TZI As TIME_ZONE_INFORMATION
Dim DST As TIME_ZONE
Dim LocalTime As Date

If StartTime <= 0 Then
    GMT = Now
Else
    GMT = StartTime
End If
DST = CLng(GetTimeZoneInformation(TZI))
LocalTime = GMT - TimeSerial(0, TZI.Bias, 0) + _
        IIf(DST = TIME_ZONE_DAYLIGHT, TimeSerial(1, 0, 0), 0)
GetLocalTimeFromGMT = LocalTime

End Function

Function SystemTimeToVBTime(SysTime As SYSTEMTIME) As Date
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' SystemTimeToVBTime
' This converts a SYSTEMTIME structure to a VB/VBA date value.
' It assumes SysTime is valid -- no error checking is done.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
With SysTime
    SystemTimeToVBTime = DateSerial(.wYear, .wMonth, .wDay) + _
            TimeSerial(.wHour, .wMinute, .wSecond)
End With

End Function

Function LocalOffsetFromGMT(Optional AsHours As Boolean = False, _
    Optional AdjustForDST As Boolean = False) As Long
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' LocalOffsetFromGMT
' This returns the amount of time in minutes (if AsHours is omitted or
' false) or hours (if AsHours is True) that should be added to the
' local time to get GMT. If AdjustForDST is missing or false,
' the unmodified difference is returned. (e.g., Kansas City to London
' is 6 hours normally, 5 hours during DST. If AdjustForDST is False,
' the resultif 6 hours. If AdjustForDST is True, the result is 5 hours
' if DST is in effect.)
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Dim TBias As Long
Dim TZI As TIME_ZONE_INFORMATION
Dim DST As TIME_ZONE
DST = CLng(GetTimeZoneInformation(TZI))

If DST = TIME_ZONE_DAYLIGHT Then
    If AdjustForDST = True Then
        TBias = TZI.Bias + TZI.DaylightBias
    Else
        TBias = TZI.Bias
    End If
Else
    TBias = TZI.Bias
End If
If AsHours = True Then
    TBias = TBias / 60
End If

LocalOffsetFromGMT = TBias

End Function

Function DaylightTime() As TIME_ZONE
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' DaylightTime
' Returns a value indicating whether the current date is
' in Daylight Time, Standard Time, or that Windows cannot
' deterimine the time status. The result is a member or
' the TIME_ZONE enum.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Dim TZI As TIME_ZONE_INFORMATION
Dim DST As TIME_ZONE
DST = CLng(GetTimeZoneInformation(TZI))
DaylightTime = DST
End Function




'================================================================================================
'added from the web page by Greg Lovern:


Function IntArrayToString(V As Variant) As String
'GJL: to be used to convert the TIME_ZONE_INFORMATION structure's
'StandardName and DaylightName elements into strings.
    Dim N As Long
    Dim s As String
    For N = LBound(V) To UBound(V)
        s = s & Chr(V(N))
    Next N
    IntArrayToString = s
End Function


Sub Test_GetStandardName()
    Dim TZI As TIME_ZONE_INFORMATION
    Dim DST As TIME_ZONE
    Dim StandardName As String
    
    DST = CLng(GetTimeZoneInformation(TZI))
    StandardName = IntArrayToString(TZI.StandardName) 'GJL 7/31/2008: use Trim to remove trailing spaces.
    Debug.Print StandardName
End Sub


Public Function IsDST() As Boolean
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' IsDST
' Returns TRUE if the current data is within DST, FALSE
' if DST is not in effect or if Windows cannot determine
' DST setting.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    Application.Volatile True
    Dim DST As TIME_ZONE
    Dim TZI As TIME_ZONE_INFORMATION
    DST = CLng(GetTimeZoneInformation(TZI))
    IsDST = (DST = TIME_ZONE_DAYLIGHT)
End Function
Attribute VB_Name = "modURLDownloadToFile"
'Greg Lovern
'http://PrecisionCalc.com

'based on:
'http://vbnet.mvps.org/index.html?code/internet/urldownloadtofile.htm

Option Explicit

'==========================================================================================
'For 64-bit compatibility.

'MSDN: Compatibility Between the 32-bit and 64-bit Versions of Office 2010:
    'http://msdn.microsoft.com/en-us/library/ee691831.aspx
'Technet: Microsoft Office Code Compatibility Inspector:
    'http://technet.microsoft.com/en-us/library/ee833946.aspx
'Samples:
    'The Microsoft file Win32_PtrSafe.txt contains 64-bit Windows API Declarations and Constants for VBA:
        'http://support.microsoft.com/kb/2030490
        'http://www.microsoft.com/downloads/en/details.aspx?FamilyID=035b72a5-eef9-4baf-8dbc-63fbd2dd982b&displaylang=en
    'http://www.jkp-ads.com/articles/apideclarations.asp
'Windows API functions that were modified/added for 64-bit Windows:
    'http://msdn.microsoft.com/en-us/library/aa383663(VS.85).aspx

'PtrSafe:
    'For Excel 2010 and later (#Vba7 = True), change "Declare" to "Declare PtrSafe".
'LongPtr:
    'For Excel 2010 and later (#Vba7 = True), change the data type of handles and pointers
    'from Long to LongPtr. Leave pointers to strings as String.
'LongLong:
    'For 64-bit Excel (#Win64 = True), change Long (except for handles and pointers!) to LongLong

#If Mac Then
    'Running on MacIntosh. Do nothing.
#ElseIf VBA7 Then
    'Excel 2010 or later:
     #If Win64 Then
        '64-bit Excel, 2010 or later:
        'Use PtrSafe, LongPtr, and LongLong:
        
            Private Declare PtrSafe Function URLDownloadToFile Lib "urlmon" _
               Alias "URLDownloadToFileA" _
              (ByVal pCaller As LongPtr, _
               ByVal szURL As String, _
               ByVal szFileName As String, _
               ByVal dwReserved As LongLong, _
               ByVal lpfnCB As LongPtr) As LongLong
               
            Private Declare PtrSafe Function DeleteUrlCacheEntry Lib "Wininet.dll" _
               Alias "DeleteUrlCacheEntryA" _
              (ByVal lpszUrlName As String) As LongLong
            
            Private Const BINDF_GETNEWESTVERSION As LongLong = &H10

     #Else
        '32-bit Excel 2010 or later:
        'Use PtrSafe and LongPtr, but NOT LongLong:

            Private Declare PtrSafe Function URLDownloadToFile Lib "urlmon" _
               Alias "URLDownloadToFileA" _
              (ByVal pCaller As LongPtr, _
               ByVal szURL As String, _
               ByVal szFileName As String, _
               ByVal dwReserved As Long, _
               ByVal lpfnCB As LongPtr) As Long
               
            Private Declare PtrSafe Function DeleteUrlCacheEntry Lib "Wininet.dll" _
               Alias "DeleteUrlCacheEntryA" _
              (ByVal lpszUrlName As String) As Long
            
            Private Const BINDF_GETNEWESTVERSION As Long = &H10
        
     #End If
#Else
    'Excel 2007 or earlier:

        Private Declare Function URLDownloadToFile Lib "urlmon" _
           Alias "URLDownloadToFileA" _
          (ByVal pCaller As Long, _
           ByVal szURL As String, _
           ByVal szFileName As String, _
           ByVal dwReserved As Long, _
           ByVal lpfnCB As Long) As Long
           
        Private Declare Function DeleteUrlCacheEntry Lib "Wininet.dll" _
           Alias "DeleteUrlCacheEntryA" _
          (ByVal lpszUrlName As String) As Long
        
        Private Const BINDF_GETNEWESTVERSION As Long = &H10

#End If

'==========================================================================================
'Private Const ERROR_SUCCESS As Long = 0 'not in use.




Private Function test()
    Dim strURL As String
    Dim strLocalFullPath As String
    strURL = "http://precisioncalc.com/amazon/HTML_Table_All_Languages.htm"
    strLocalFullPath = "C:\_GJL\Release 1.9\Work\TestURLDownloadToFile.htm"
    
    Call OpenWorkbookFromURL(strURL, strLocalFullPath)
End Function



Public Function OpenWorkbookFromURL(strURL As String, strLocalFullPath As String) As Workbook

'returns Workbook object on success; Nothing on failure.
   
   Call DeleteDownloadedFileFromCache(strURL)
   
   If DownloadFile(strURL, strLocalFullPath) Then
        Set OpenWorkbookFromURL = Workbooks.Open(strLocalFullPath)
   End If
   
End Function



Public Function InsertWorksheetFromWorkbookURL(strURL As String, _
                                               Optional target_wb As Workbook, Optional new_wb_name As String) As Worksheet

'this is for v2.
'Download the target workbook, copy the single worksheet
'from it into this workbook, and return a reference to that inserted worksheet.
'And, delete the downloaded workbook.

'on failure, returns Nothing (instead of returning a worksheet object).

Dim strSourceWorkbookLocalFullPath As String
Dim wbSourceWorkbook As Workbook
Dim strWorksheetName As String
Dim strTargetWorkbookFilename As String
Dim wbTargetWorkbook As Workbook
Dim bRet As Boolean
Dim bScreenUpdatingStatus As Boolean
Dim shWorksheet As Worksheet
Dim wbWorkbook As Workbook
Const SOURCE_WORKBOOK_FILENAME As String = "SourceWorkbook.xls"

On Error GoTo GenErr

bScreenUpdatingStatus = Application.ScreenUpdating
Application.ScreenUpdating = False

If target_wb Is Nothing Then
    Set wbTargetWorkbook = ThisWorkbook
Else
    Set wbTargetWorkbook = target_wb
End If

If new_wb_name <> "" Then
'    strSourceWorkbookFilename = SOURCE_WORKBOOK_FILENAME
'Else
    strTargetWorkbookFilename = new_wb_name
    Set wbTargetWorkbook = Workbooks.Add
    Dim strNewWorkbookFullPath As String
    strNewWorkbookFullPath = ThisWorkbook.Path & "\" & strTargetWorkbookFilename
    For Each wbWorkbook In Application.Workbooks
        If wbWorkbook.Name = strTargetWorkbookFilename Then
            wbWorkbook.Close SaveChanges:=False
            DoEvents
            Exit For
        End If
    Next wbWorkbook
    Dim fso As Object
    Set fso = CreateObject("Scripting.FileSystemObject")
    If fso.FileExists(strNewWorkbookFullPath) Then
        fso.DeleteFile strNewWorkbookFullPath
        DoEvents
    End If
    wbTargetWorkbook.SaveAs strNewWorkbookFullPath
    DoEvents
End If

strSourceWorkbookLocalFullPath = wbTargetWorkbook.Path & "\" & SOURCE_WORKBOOK_FILENAME

'preparation:
DoEvents
Call DeleteDownloadedFileFromCache(strURL)
DoEvents
Call CloseWorkbookIfOpen(SOURCE_WORKBOOK_FILENAME)
DoEvents
Call DeleteFileIfExists(strSourceWorkbookLocalFullPath)
DoEvents

'download:
bRet = DownloadFile(strURL, strSourceWorkbookLocalFullPath)
DoEvents

If Not bRet Then
    'download not successful.
    Set InsertWorksheetFromWorkbookURL = Nothing
    Exit Function
End If

'download was successful. Open the workbook:
Set wbSourceWorkbook = Workbooks.Open(strSourceWorkbookLocalFullPath, UpdateLinks:=0) '0 = do not update links.
strWorksheetName = wbSourceWorkbook.Worksheets(1).Name
DoEvents

'delete defined names before inserting it into template:
Dim nmName As Name
For Each nmName In wbSourceWorkbook.Names
    If InStr(ActiveWorkbook.Names(1).Name, "Print_Area") > 0 Then
        'don't delete print area defined name.
    ElseIf InStr(ActiveWorkbook.Names(1).Name, "Print_Titles") > 0 Then
        'don't delete print titles defined name.
    Else
        'delete all other defined names:
        nmName.Delete
    End If
Next nmName

'insert the worksheet and delete the source workbook:
Set InsertWorksheetFromWorkbookURL = SwapInSheetAndDeleteSourceWorkbook(wbSourceWorkbook, , wbTargetWorkbook)
DoEvents

If new_wb_name <> "" Then

    Dim bDisplayAlertsStatus As Boolean
    bDisplayAlertsStatus = Application.DisplayAlerts
    Application.DisplayAlerts = False
    For Each shWorksheet In wbTargetWorkbook.Worksheets
        If shWorksheet.Name <> strWorksheetName Then
            shWorksheet.Delete
        End If
    Next shWorksheet
    Application.DisplayAlerts = bDisplayAlertsStatus
    DoEvents
    wbTargetWorkbook.Save
    DoEvents
End If

Application.ScreenUpdating = bScreenUpdatingStatus

Exit Function

GenErr:

If False Then
    Resume
End If

Application.ScreenUpdating = bScreenUpdatingStatus

End Function



Public Function OpenUnicodeTabDelimFileAsWorkbookFromURL(strURL As String, strLocalFullPath As String) As Workbook

'returns Workbook object on success; Nothing on failure.

Dim vArray() As Variant
Dim iCounter As Long
Dim iStartWorkbooksCount As Long
Dim iEndWorkbooksCount As Long

    iStartWorkbooksCount = Application.Workbooks.Count
   
   Call DeleteDownloadedFileFromCache(strURL)
   
   If DownloadFile(strURL, strLocalFullPath) Then
        
        ReDim vArray(1 To 1024) As Variant
        For iCounter = 1 To 1024
            vArray(iCounter) = Array(iCounter, 2)
        Next iCounter

        Workbooks.OpenText FileName:= _
            strLocalFullPath, Origin:= _
            xlWindows, StartRow:=1, DataType:=xlDelimited, TextQualifier:= _
            xlDoubleQuote, ConsecutiveDelimiter:=False, Tab:=True, Semicolon:=False, _
            Comma:=False, Space:=False, Other:=False, FieldInfo:=vArray ', TrailingMinusNumbers:=True
        
        DoEvents
        
        'OpenText does not return anything, so must detect whether it was successful:
        iEndWorkbooksCount = Application.Workbooks.Count
        If iEndWorkbooksCount > iStartWorkbooksCount Then
            Set OpenUnicodeTabDelimFileAsWorkbookFromURL = Application.Workbooks(Application.Workbooks.Count)
        Else
            Set OpenUnicodeTabDelimFileAsWorkbookFromURL = Nothing
        End If
   End If
   
End Function



Function DownloadFile(strURL As String, _
                              strLocalFullPath As String) As Boolean

'DownloadFile returns True on success.
'(The URLDownloadToFile API returns 0 on success.)

'BINDF_GETNEWESTVERSION forces it to download a fresh copy instead of trying to get it from the cache.
'(To allow trying to get it from the cache, use 0& instead of BINDF_GETNEWESTVERSION.)

Dim iRet As Long

DoEvents
iRet = CLng(URLDownloadToFile(0&, strURL, strLocalFullPath, BINDF_GETNEWESTVERSION, 0&))
    '0 = success.
DoEvents

If iRet = 0 Then
    DownloadFile = True
Else
    DownloadFile = False
End If
   
End Function


Function DeleteDownloadedFileFromCache(strURL As String) As Boolean
    'returns 1 on success, 0 on failure.
    
    DeleteDownloadedFileFromCache = DeleteUrlCacheEntry(strURL)
End Function


Attribute VB_Name = "modValidation"
'Greg Lovern
'http://PrecisionCalc.com

' Modified for MWS integration
' Abhijit Tambe, July 2010

'Option Explicit

Public bCancelValidation As Boolean

Public Const FULL_DATA_VALIDATION_TABLE_URL_DEFINED_NAME As String = "Full_Data_Validation_Table_URL"
Public Const DATA_VALIDATION_TABLE_WORKSHEET_NAME As String = "Data Validation"
Public Const DATA_VALIDATION_TABLE_HEADER_ROW As Long = 1


'data validation table column headers:
Public Const DATA_VALIDATION_TABLE_VALIDATE_COLUMN_HEADER As String = "Validate Column"
Public Const DATA_VALIDATION_TABLE_VALIDATE_COLUMN_TEST_HEADER As String = "Validate Column Test"
Public Const DATA_VALIDATION_TABLE_REQUIRED_COLUMN_HEADER As String = "Required Column"
Public Const DATA_VALIDATION_TABLE_REQUIRED_COLUMN_TEST_HEADER As String = "Required Column Test"
Public Const DATA_VALIDATION_TABLE_TEMPLATE_DEPENDENCY_TEST_HEADER As String = "Template Dependency Test"
Public Const DATA_VALIDATION_TABLE_LANGUAGE_COLUMN_HEADER As String = "Language"
Public Const DATA_VALIDATION_TABLE_ERROR_TEXT_HEADER As String = "Error Text"
Public Const DATA_VALIDATION_TABLE_HEIGHT_COLUMN_HEADER As String = "Height"
Public Const DATA_VALIDATION_TABLE_WIDTH_COLUMN_HEADER As String = "Width"
Public Const DATA_VALIDATION_TABLE_FONTNAME_COLUMN_HEADER As String = "Fontname"
Public Const DATA_VALIDATION_SORTING_COLUMN_HEADER_1 As String = "SortByFormulaCol1"
Public Const DATA_VALIDATION_SORTING_COLUMN_HEADER_2 As String = "SortByFormulaCol2"
Public Const DATA_VALIDATION_TESTCELLCOMMENT_COLUMN_HEADER As String = "Test Cell Comment"

Public Const DATA_VALIDATION_FONTNAME_HARDCODED As String = "Verdana"
Public Const DATA_VALIDATION_WIDTH_HARDCODED As Single = 145 'because Excel's Comment's Shape's Width property takes a Single.

' modified 07/30/10 by atambe
Public Function ValidateTemplate(Optional called_by_upload As Boolean, _
                                 Optional ByRef export_array As Variant, _
                                 Optional ByRef export_row_array As Variant, _
                                 Optional subst_template_language As String, _
                                 Optional no_highlighting_no_cellcomments As Boolean, _
                                 Optional suppress_validation_progress_dialog As Boolean, _
                                 Optional do_template_dependency_test As Boolean, _
                                 Optional use_this_validation_sheet As Worksheet, _
                                 Optional check_template_language As Boolean, _
                                 Optional is_multi_template_sheet As Boolean, _
                                 Optional ret_strMsgboxErrorColumnList As String, _
                                 Optional ret_iMsgboxErrorColumnCount As Long) As Boolean

'if called by upload, returns True if you should proceed to upload; False if
'validation failed and user chose to NOT upload now.

'if is_multi_template_sheet, returns True if user allowed validation to finish; False if user cancelled validation.

'Const OBLO As String = "O_B_L_O" 'Optional But List Only
Const PRODUCT_ID_MFA_INTERNAL_NAME As String = "product-id"
Const PRODUCT_ID_TYPE_MFA_INTERNAL_NAME As String = "product-id-type"

Dim PriceValid As Boolean
Dim ConditionNoteValid As Boolean
Dim ProductIDType As Boolean
Dim bRet As Boolean
Dim shTemplate As Worksheet
Dim shValidationData As Worksheet
Dim shIntTable As Worksheet
Dim strTemplateLanguage As String
Dim iTemplateHeaderRow As Long
Dim iLastExampleRow As Long
Dim iTemplateFirstDataRow As Long
Dim iTemplateLastDataRow As Long
Dim iTemplateValidateRow As Long
Dim iTemplateFirstDataCol As Long
Dim iTemplateLastDataCol As Long
Dim iTemplateValidateCol As Long
Dim iTemplateRequiredCol As Long
Dim voRegex As Variant 'IRegExp2
Dim strErrorTextItem As String
Dim strErrorTextRowBuilder As String
Dim strErrorTextMessageBuilder As String
Dim iErrorTextRow As Long
Dim bTemplateCellPassesAllTests As Boolean
Dim strInternalTemplateName As String

Dim iIntTableMfaInternalNameCol As Long
Dim iIntTableLocalNameCol As Long

Dim iValidationTableValidateColumnCol As Long
Dim iValidationTableValidateColumnTestCol As Long
Dim iValidationTableRequiredColumnCol As Long
Dim iValidationTableRequiredColumnTestCol As Long
Dim iValidationTableTemplateDependencyTestCol As Long
Dim iValidationTableLanguageColumnCol As Long
Dim iValidationTableErrorTextColumnCol As Long
Dim iValidationTableHeightColumnCol As Long
Dim iValidationTableWidthColumnCol As Long
Dim iValidationTableFontnameColumnCol As Long

Dim rgTemplateValidateItemCell As Range
Dim strTemplateValidateItem As String
Dim strTemplateRequiredItem As String

Dim strValidationTableRequiredColumnItem As String
Dim strValidationTableRequiredColumnItemLocalName As String
Dim strValidationTableRequiredColumnTestItem As String
Dim strValidationTableValidateColumnTestItem As String

Dim bValidationTableRequiredColumnIsPresent As Boolean
Dim bValidationTableRequiredColumnTestIsPresent As Boolean
Dim bValidationTableRequiredColumnPassesTest As Boolean

Dim bValidationTableValidateColumnTestIsPresent As Boolean
Dim bValidationTableValidateColumnPassesTest As Boolean

Dim iValidationTableFirstItemRow As Long
Dim iValidationTableLastItemRow As Long
Dim rgValidationTableFirstItemCell As Range
Dim rgValidationTableLastItemCell As Range
Dim rgValidationTableItemLanguageRange As Range
Dim iValidationTableItemRow As Long
Dim iValidationTablePiorRowProcessed As Long

Dim sngCommentHeight As Single 'because Excel's Comment's Shape's Height property takes a Single.
Dim sngCommentTotalHeight As Single 'because Excel's Comment's Shape's Height property takes a Single.
Dim sngCommentWidth As Single 'because Excel's Comment's Shape's Width property takes a Single.
Dim sngCommentMaxWidth As Single 'because Excel's Comment's Shape's Width property takes a Single.
Dim strCommentFontname As String
Dim iCountOfValidationErrorMessagesInSingleCellComment As Long

Dim rgFind As Range
'Dim iFindRow As Long
Dim rgLanguageCell As Range
Dim strTemplateHeader As String
Dim strTemplateHeaderMfaInternalName As String
Dim strMsgboxErrorColumnList As String
Dim strMsgboxErrorColumnLetter As String
Dim strMsgboxErrorColumnSingularOrPluralPart As String
Dim iMsgboxErrorColumnCount As Long
Dim bThisTemplateColumnAlreadyEnteredInErrorMsgbox As Boolean
Dim bIsMultiTemplateSheet As Boolean
Dim strMultiTemplateSheetPrefix As String
Dim bEnableEventsStatus As Boolean
Dim rgDropdownList As Range
'Dim strArrayLocalNames() As String
'Dim iArrayLocalNamesIndex As Long
'Dim strArrayLocalNamesItem As String
'Dim iUboundArrayLocalNames As Long
Dim bFound As Boolean
Dim strTemp As String
Dim rgOldArea As Range
Dim bRequiredColumnHeaderNotFoundInTemplate As Boolean
Dim bValidateColumnTestIsRegex As Boolean
Dim bValidateColumnTestIsByList As Boolean
'Dim bValidateColumnTestIsOBLO As Boolean 'Optional But List Only
Dim bIsProductIDCol As Boolean
Dim iMsgboxRet As Integer
Dim bUploadNow As Boolean
Dim bExportArray As Boolean
Dim bExportRowArray As Boolean
Dim iUboundExportArray As Long
Dim bWriteToExportArray As Boolean
Dim bFirstDataRow As Boolean
Dim bNoList As Boolean
Dim iHeight As Long


On Error GoTo GenErr

bEnableEventsStatus = Application.EnableEvents
Application.EnableEvents = False

Set shTemplate = GetTemplateWorksheet()

If is_multi_template_sheet Then
    bIsMultiTemplateSheet = True
    strMultiTemplateSheetPrefix = """" & shTemplate.Name & """: "
Else
    bIsMultiTemplateSheet = False
    strMultiTemplateSheetPrefix = ""
End If


If Not suppress_validation_progress_dialog Then
    frmValidatePleaseWait.Show vbModeless
'    frmValidatePleaseWait.prgUpdate.value = 0
    frmValidatePleaseWait.lblProgressBar.Width = 0
    frmValidatePleaseWait.Repaint
    DoEvents
End If

'first, reset prod-id number formatting to text:
Call ResetProductIdNumberFormattingToText
If CheckForCancelValidation Then GoTo CancelValidation

'...and fix repeated pound signs:
Call FixRepeatedPoundSigns
If CheckForCancelValidation Then GoTo CancelValidation

'...and dock the dropdown:
Call DockDropdown
If CheckForCancelValidation Then GoTo CancelValidation



strInternalTemplateName = GetInternalTemplateName(ThisWorkbook)

Set shIntTable = ThisWorkbook.Worksheets(INT_TABLE_WORKSHEET_NAME)
iIntTableMfaInternalNameCol = GetIntTableMfaInternalNameColumn(shIntTable)
iIntTableLocalNameCol = GetIntTableLocalLanguageColumn(shIntTable)

strMsgboxErrorColumnList = "" 'init.
iMsgboxErrorColumnCount = 0
Set voRegex = CreateObject("VBScript.RegExp")

'loop through column headers in template, find each one in validation data sheet:
'Set shTemplate = GetTemplateWorksheet()
If subst_template_language = "" Then
    strTemplateLanguage = GetLocalLanguageName()
Else
    strTemplateLanguage = subst_template_language
End If

If use_this_validation_sheet Is Nothing Then
    Set shValidationData = ThisWorkbook.Worksheets(DATA_VALIDATION_TABLE_WORKSHEET_NAME)
Else
    Set shValidationData = use_this_validation_sheet
End If


iTemplateHeaderRow = GetTemplateHeaderRow(shTemplate)
iLastExampleRow = GetLastExampleRow(shTemplate, iTemplateHeaderRow)

iTemplateFirstDataRow = iLastExampleRow + 1
iTemplateFirstDataCol = 1
'Set rgFind = shTemplate.Cells(iTemplateHeaderRow, shTemplate.Columns.Count).End(xlToLeft)
Set rgFind = GetRightmostOccupiedCellInRowAsRange(shTemplate, iTemplateHeaderRow)

iTemplateLastDataCol = rgFind.Column

'get data validation table's column numbers:
iValidationTableValidateColumnCol = shValidationData.Rows(DATA_VALIDATION_TABLE_HEADER_ROW).Find(What:=DATA_VALIDATION_TABLE_VALIDATE_COLUMN_HEADER, LookAt:=xlWhole).Column
iValidationTableValidateColumnTestCol = shValidationData.Rows(DATA_VALIDATION_TABLE_HEADER_ROW).Find(What:=DATA_VALIDATION_TABLE_VALIDATE_COLUMN_TEST_HEADER, LookAt:=xlWhole).Column
iValidationTableRequiredColumnCol = shValidationData.Rows(DATA_VALIDATION_TABLE_HEADER_ROW).Find(What:=DATA_VALIDATION_TABLE_REQUIRED_COLUMN_HEADER, LookAt:=xlWhole).Column
iValidationTableRequiredColumnTestCol = shValidationData.Rows(DATA_VALIDATION_TABLE_HEADER_ROW).Find(What:=DATA_VALIDATION_TABLE_REQUIRED_COLUMN_TEST_HEADER, LookAt:=xlWhole).Column
iValidationTableErrorTextColumnCol = shValidationData.Rows(DATA_VALIDATION_TABLE_HEADER_ROW).Find(What:=DATA_VALIDATION_TABLE_ERROR_TEXT_HEADER, LookAt:=xlWhole).Column
iValidationTableHeightColumnCol = shValidationData.Rows(DATA_VALIDATION_TABLE_HEADER_ROW).Find(What:=DATA_VALIDATION_TABLE_HEIGHT_COLUMN_HEADER, LookAt:=xlWhole).Column
'iValidationTableWidthColumnCol = shValidationData.Rows(DATA_VALIDATION_TABLE_HEADER_ROW).Find(What:=DATA_VALIDATION_TABLE_WIDTH_COLUMN_HEADER, LookAt:=xlWhole).Column
'iValidationTableFontnameColumnCol = shValidationData.Rows(DATA_VALIDATION_TABLE_HEADER_ROW).Find(What:=DATA_VALIDATION_TABLE_FONTNAME_COLUMN_HEADER, LookAt:=xlWhole).Column

If do_template_dependency_test Then
    'can't do this when running validation, because that column no longer exists.
    'only do this when doing updating template.
    iValidationTableTemplateDependencyTestCol = shValidationData.Rows(DATA_VALIDATION_TABLE_HEADER_ROW).Find(What:=DATA_VALIDATION_TABLE_TEMPLATE_DEPENDENCY_TEST_HEADER, LookAt:=xlWhole).Column
End If

If check_template_language Then
    'can't do this when running validation, because that column no longer exists.
    'only do this when exporting/importing local strings for translation.
    iValidationTableLanguageColumnCol = shValidationData.Rows(DATA_VALIDATION_TABLE_HEADER_ROW).Find(What:=DATA_VALIDATION_TABLE_LANGUAGE_COLUMN_HEADER, LookAt:=xlWhole).Column
End If

Call ResetFindParametersToDefaults


'find last row where entire row is blank:
    'if first row is blank, set iTemplateLastDataRow to one less than iTemplateFirstDataRow,
    'so that loop through template data rows is skipped.
Set rgFind = shTemplate.Rows(iTemplateFirstDataRow).EntireRow 'init.
'Do Until WorksheetFunction.CountA(rgfind) = 0
Do Until IsRangeEmpty(rgFind)
    Set rgFind = rgFind.Offset(1, 0)
    If CheckForCancelValidation Then GoTo CancelValidation
Loop
iTemplateLastDataRow = rgFind.Row - 1


'unprotect template sheet:
shTemplate.Unprotect


'start by removing any old leftover error highlighting and cell comments from the area below the last data row:
Set rgOldArea = shTemplate.Range( _
                    shTemplate.Cells(iTemplateLastDataRow + 1, iTemplateFirstDataCol), _
                    shTemplate.Cells(shTemplate.Rows.Count, iTemplateLastDataCol))
rgOldArea.ClearComments
rgOldArea.Borders.LineStyle = xlNone

If IsMissing(export_array) Then
    bExportArray = False
Else
    'for exporting translation list.
    bExportArray = True
    iUboundExportArray = 0
    ReDim export_array(1 To 7, 0 To iUboundExportArray)
End If



If IsMissing(export_row_array) Then
    bExportRowArray = False
Else
    'for deleting unneccessary rows in validation table.
    bExportRowArray = True
    
    'check for whether there are already rows in the array from previous template sheet:
    If IsArray(export_row_array) Then
        iUboundExportArray = UBound(export_row_array)
    Else
        iUboundExportArray = 0
        ReDim export_row_array(0 To iUboundExportArray)
    End If
End If




'for each column in the template:
For iTemplateValidateCol = iTemplateFirstDataCol To iTemplateLastDataCol
    
    If CheckForCancelValidation Then GoTo CancelValidation

    If Not suppress_validation_progress_dialog Then
'        frmValidatePleaseWait.prgUpdate.value = 100 * (iTemplateValidateCol / iTemplateLastDataCol)
        frmValidatePleaseWait.lblProgressBar.Width = frmValidatePleaseWait.frameProgressBar.Width * _
                                                (iTemplateValidateCol / iTemplateLastDataCol)
        frmValidatePleaseWait.Repaint
        DoEvents
    End If
    
    bThisTemplateColumnAlreadyEnteredInErrorMsgbox = False 'init.

    'get the mfa internal name for each header, because that's what is in the data validation table.
    strTemplateHeader = shTemplate.Cells(iTemplateHeaderRow, iTemplateValidateCol)
    strTemplateHeaderMfaInternalName = GetMfaInternalNameColumnHeaderFromLocalLanguageColumnHeader(strTemplateHeader)
    
    
    'check for product-id, which must be special-cased:
    If strTemplateHeaderMfaInternalName = PRODUCT_ID_MFA_INTERNAL_NAME Then
        bIsProductIDCol = True
    Else
        bIsProductIDCol = False
    End If
    
    
    
    'if running from ExportValidationCellCommentListToBeTranslated, walk through validation even if
    'there is nothing to validate:
    If bExportArray Or bExportRowArray Then
        If iTemplateFirstDataRow > iTemplateLastDataRow Then
            iTemplateLastDataRow = iTemplateFirstDataRow
        End If
    End If
        
    'for each row (single cell) in this column in the template:
    For iTemplateValidateRow = iTemplateFirstDataRow To iTemplateLastDataRow
    
        If CheckForCancelValidation Then GoTo CancelValidation
    
        iCountOfValidationErrorMessagesInSingleCellComment = 0 'init for each template row in each template column.
        
'        If strTemplateHeader = "" Then Exit For
        If strTemplateHeaderMfaInternalName = "" Then Exit For
    
        bTemplateCellPassesAllTests = True 'init. Used to determine whether cell gets data validation cell comment and cell highlighting.
        sngCommentMaxWidth = -1 'init.
        sngCommentTotalHeight = -1 'init.
        strErrorTextMessageBuilder = "" 'init.
        bRequiredColumnHeaderNotFoundInTemplate = False 'init.
        
        
        'get the item to validate:
        Set rgTemplateValidateItemCell = shTemplate.Cells(iTemplateValidateRow, iTemplateValidateCol)
        strTemplateValidateItem = rgTemplateValidateItemCell.value
        
        
        'check for, and correct, leading or trailing spaces:
        strTemp = Trim(strTemplateValidateItem)
        If strTemplateValidateItem <> strTemp Then
            'there are leading and/or trailing spaces, so remove them:
            shTemplate.Cells(iTemplateValidateRow, iTemplateValidateCol) = strTemp
            strTemplateValidateItem = strTemp
        End If
        
        
        'find first and last rows of item's column header in validation table's "Validate Column" column:
'        Dim strTry As String
'        strTry = strTemplateHeaderMfaInternalName 'init.
'        Do
'            Set rgFind = shValidationData.Columns(iValidationTableValidateColumnCol).Find( _
                         What:=strTemplateHeader, LookAt:=xlWhole)
            Set rgFind = shValidationData.Columns(iValidationTableValidateColumnCol).Find( _
                         What:=strTemplateHeaderMfaInternalName, LookAt:=xlWhole)
            Call ResetFindParametersToDefaults
'            If rgFind Is Nothing Then
'                'if last characters are numbers, try removing them one by one to get a match:
'                If IsNumeric(Right(strTry, 1)) Then
'                    strTry = Left(strTry, Len(strTry) - 1)
'                    If strTry = "" Then
'                        Exit Do
'                    End If
'                Else
'                    Exit Do
'                End If
'            Else
'                Exit Do
'            End If
'        Loop
        
        If rgFind Is Nothing Then
            'not there, so don't validate this template column.
            Exit For 'For iTemplateValidateRow = iTemplateFirstDataRow To iTemplateLastDataRow
        Else
            iValidationTableFirstItemRow = rgFind.Row
'            Set rgFind = shValidationData.Columns(iValidationTableValidateColumnCol).Find( _
                          What:=strTemplateHeader, LookAt:=xlWhole, SearchDirection:=xlPrevious)
            Set rgFind = shValidationData.Columns(iValidationTableValidateColumnCol).Find( _
                          What:=strTemplateHeaderMfaInternalName, LookAt:=xlWhole, SearchDirection:=xlPrevious)
            iValidationTableLastItemRow = rgFind.Row
            Call ResetFindParametersToDefaults
            iValidationTableItemRow = iValidationTableFirstItemRow - 1 'init
        End If
        
        

        'get range of validation data table's *language* column bounded by first and last rows of validation item:
        If check_template_language Then
            Set rgValidationTableItemLanguageRange = shValidationData.Range( _
                                                        shValidationData.Cells( _
                                                           iValidationTableFirstItemRow, _
                                                           iValidationTableLanguageColumnCol), _
                                                        shValidationData.Cells( _
                                                           iValidationTableLastItemRow, _
                                                           iValidationTableLanguageColumnCol))
        End If
                                                           
        
        'do each row in the data validation table, for this column header, with the template's language:
        iValidationTablePiorRowProcessed = -1 'init
        If check_template_language Then
            Set rgLanguageCell = rgValidationTableItemLanguageRange(rgValidationTableItemLanguageRange.Cells.Count) 'init (so that first search (in next section) will start with first item.
            If rgLanguageCell Is Nothing Then Exit For
        End If
        Do
        
            If CheckForCancelValidation Then GoTo CancelValidation
            
            'find the next row in that range with the correct language:
            bWriteToExportArray = False 'init for each row.
            If check_template_language Then
                Set rgLanguageCell = rgValidationTableItemLanguageRange.Find( _
                                     What:=strTemplateLanguage, After:=rgLanguageCell, LookAt:=xlWhole)
                If rgLanguageCell Is Nothing Then Exit For
                iValidationTableItemRow = rgLanguageCell.Row
            Else
                iValidationTableItemRow = iValidationTableItemRow + 1
            End If
            If check_template_language Then
                If iValidationTableItemRow > iValidationTablePiorRowProcessed Then
                    iValidationTablePiorRowProcessed = iValidationTableItemRow
                Else
                    Exit Do
                End If
            Else
                If iValidationTableItemRow <= iValidationTableLastItemRow Then
                    iValidationTablePiorRowProcessed = iValidationTableItemRow
    '                If bExportArray Then
    
    '                    iUboundExportArray = iUboundExportArray + 1
    '                    ReDim Preserve export_array(1 To 7, 0 To iUboundExportArray)
    '                    export_array(1, iUboundExportArray) = iValidationTableItemRow
    '                End If
                    'proceed to process this row.
                Else
                    'done processing rows. do not process this row.
                    Exit Do
                End If
            End If
            
            
            
            
            
            'check for template dependencies when removing rows from validation
            'sheet during template update, but NOT when running validation:
            Dim bValidateForThisTemplate As Boolean
            If Not do_template_dependency_test Then
                bValidateForThisTemplate = True
            Else
            'check for Template dependencies:
            '=========================================================================================================
        '    Stop
            Dim rgTemplateDependencyTest As Range
            Dim strTemplateDependencyTest As String
            
            Set rgTemplateDependencyTest = shValidationData.Cells( _
                                                iValidationTableItemRow, iValidationTableTemplateDependencyTestCol)
            strTemplateDependencyTest = rgTemplateDependencyTest.value

            If strTemplateDependencyTest = "" Then
                'there is no template dependency for this row:
                bValidateForThisTemplate = True
            Else
                'test for correct template:
                bValidateForThisTemplate = RegexTest(strTemplateDependencyTest, strInternalTemplateName)
            End If

            'end of check for Template dependency.
            '=========================================================================================================
            End If







            If bValidateForThisTemplate Then

            
            
            
                
                'find the required column item, if any:
                strValidationTableRequiredColumnItem = shValidationData.Cells(iValidationTableItemRow, iValidationTableRequiredColumnCol).value
    
    
                'set flags showing whether required column and required column test are present:
                If strValidationTableRequiredColumnItem = "" Then
                    bValidationTableRequiredColumnIsPresent = False
                    bWriteToExportArray = True
                Else
                    bValidationTableRequiredColumnIsPresent = True
                    strValidationTableRequiredColumnTestItem = shValidationData.Cells(iValidationTableItemRow, iValidationTableRequiredColumnTestCol).value
                    If strValidationTableRequiredColumnTestItem = "" Then
                        bValidationTableRequiredColumnTestIsPresent = False
                    Else
                        bValidationTableRequiredColumnTestIsPresent = True
                    End If
                End If
                
                
                
                
                'if required column is present, find that required column in template,
                'get required item from that template column, and test it:
                If bValidationTableRequiredColumnIsPresent Then
    
    
                    '========================================================================================
                    'MUST CHECK FOR MULTIPLE ENTRIES OF THIS MFA INTERNAL NAME IN THE INTERNATIONAL
                    'TABLE, GET EACH CORRESPONDING LOCAL NAME, AND SEARCH FOR EACH OF THOSE LOCAL
                    'NAMES (AS WELL AS THE MFA INTERNAL NAME) IN THE TEMPLATE COLUMN HEADERS.
                    '========================================================================================
        
                    strValidationTableRequiredColumnItemLocalName = GetLocalColumnHeaderFromMfaInternalName( _
                                                                    strValidationTableRequiredColumnItem, _
                                                                    shIntTable, shTemplate, _
                                                                    iIntTableMfaInternalNameCol, iIntTableLocalNameCol, _
                                                                    iTemplateHeaderRow)
                        '(strValidationTableRequiredColumnItemLocalName = "" if none found)
    
    
    
    
                    'exit if can't find required column:
                    If strValidationTableRequiredColumnItemLocalName = "" Then
'                        MsgBox "Cannot find required column """ & _
'                               strValidationTableRequiredColumnItemLocalName & _
'                               """." & _
'                               vbNewLine & vbNewLine & _
'                               "Unable to validate.", _
'                               vbCritical + vbOKOnly, "Amazon Validation"
'
'                               Application.EnableEvents = bEnableEventsStatus
'                               Exit Function
                        'required column not found, so data validation error text will appear in cell comment.
                        bRequiredColumnHeaderNotFoundInTemplate = True
                    Else
                        bRequiredColumnHeaderNotFoundInTemplate = False
                        bWriteToExportArray = True
                    End If
                    
                    'if column found, get column number:
    '                iTemplateRequiredCol = rgFind.Column
                    If Not bRequiredColumnHeaderNotFoundInTemplate Then
                        iTemplateRequiredCol = FindColumn(shTemplate.Rows(iTemplateHeaderRow), _
                                                          strValidationTableRequiredColumnItemLocalName)
                        
                        'get required item from that template column:
                        strTemplateRequiredItem = shTemplate.Cells(iTemplateValidateRow, iTemplateRequiredCol).value
                    End If
                    
                    
                    '========================================================================================
    
    
                    'check for, and correct, leading or trailing spaces:
                    strTemp = Trim(strTemplateRequiredItem)
                    If strTemplateRequiredItem <> strTemp Then
                        'there are leading and/or trailing spaces, so remove them:
                        shTemplate.Cells(iTemplateValidateRow, iTemplateRequiredCol) = strTemp
                        strTemplateRequiredItem = strTemp
                    End If
    
    
                    'test required column, if found:
                    If Not bRequiredColumnHeaderNotFoundInTemplate Then
                        If bValidationTableRequiredColumnTestIsPresent Then
                            'test required column against regex:
                            voRegex.Pattern = strValidationTableRequiredColumnTestItem
                            If voRegex.test(strTemplateRequiredItem) Then
                                'the required column passes the test, so
                                'the validate column must be tested:
                                bValidationTableRequiredColumnPassesTest = True
                            Else
                                'the required column fails the test, so the validation column automatically passes:
                                '(so this template cell will NOT get a data validation cell comment from
                                'this row in the validation table)
                                '(proceed to next row in template...)
                                bValidationTableRequiredColumnPassesTest = False
                                bValidationTableValidateColumnPassesTest = True
                                
                            End If
                        Else
                            'test required column against list of combobox list items:
                            bValidationTableRequiredColumnPassesTest = ValidateItemByListFromColumn( _
                                                                       strTemplateRequiredItem, _
                                                                       iTemplateRequiredCol, iTemplateValidateRow)
                                                                       
                            If Not bValidationTableRequiredColumnPassesTest Then
                                'required column fails the test, so validation column automatically passes:
                                '(so this template cell will NOT get a data validation cell comment from
                                'this row in the validation table)
                                '(proceed to next row in template...)
                                bValidationTableValidateColumnPassesTest = True
                            End If
                        End If 'If bValidationTableRequiredColumnTestIsPresent Then
                
                
                    End If 'If Not bRequiredColumnHeaderNotFoundInTemplate Then
                End If 'If bValidationTableRequiredColumnIsPresent Then
                
                
                'if required column is not present, OR if required column passes test,
                'then test the validate column:
                If Not bValidationTableRequiredColumnIsPresent Or bValidationTableRequiredColumnPassesTest Then
        
                    'check whether validate column test (regex) is present:
                    bValidateColumnTestIsRegex = False 'init.
                    bValidateColumnTestIsByList = False 'init.
'                    bValidateColumnTestIsOBLO = False 'init.
                    strValidationTableValidateColumnTestItem = shValidationData.Cells(iValidationTableItemRow, iValidationTableValidateColumnTestCol).value
                    If strValidationTableValidateColumnTestItem = "" Then
                        bValidateColumnTestIsByList = True
                    Else
                        'test validate column against regex:
                        bValidateColumnTestIsRegex = True
                        voRegex.Pattern = strValidationTableValidateColumnTestItem
                        If voRegex.test(strTemplateValidateItem) Then
                            'validate column passes the test,
                            'so this template cell will NOT get a data validation cell comment from
                            'this row in the validation table:
                            bValidationTableValidateColumnPassesTest = True
                        Else
                            'validate column fails the test,
                            'so this template cell WILL get a data validation cell comment from
                            'this row in the validation table:
                            bValidationTableValidateColumnPassesTest = False
                            
                        End If 'If voRegex.test(strTemplateValidateItem) Then
                    End If
                    
                    
                    
                    If bValidateColumnTestIsByList Then
                        'strValidationTableValidateColumnTestItem = "":
                        'regex test is not present for validate column,
                        'or is OBLO with a validate column entry present:
                        'test validate column against list of combobox list items:
                        bValidationTableValidateColumnPassesTest = ValidateItemByListFromColumn( _
                                                                   strTemplateValidateItem, _
                                                                   iTemplateValidateCol, iTemplateValidateRow)
                    End If
                        
     
                
                End If 'If Not bValidationTableRequiredColumnIsPresent Or bValidationTableRequiredColumnPassesTest Then
                
    
    
    
                'build column list for error message that will apear at the very end of validation:
                If Not bValidationTableValidateColumnPassesTest Then 'Or bRequiredColumnHeaderNotFoundInTemplate Then '3/7/2008.
                    If Not bThisTemplateColumnAlreadyEnteredInErrorMsgbox Then
                        bThisTemplateColumnAlreadyEnteredInErrorMsgbox = True
                        iMsgboxErrorColumnCount = iMsgboxErrorColumnCount + 1
                        strMsgboxErrorColumnLetter = shTemplate.Cells(1, iTemplateValidateCol).Address(False, False)
                        strMsgboxErrorColumnLetter = Left(strMsgboxErrorColumnLetter, Len(strMsgboxErrorColumnLetter) - 1)
                        strMsgboxErrorColumnList = strMsgboxErrorColumnList & _
                                                   strMultiTemplateSheetPrefix & strTemplateHeader & _
                                                   " " & GetTranslatedString("column_1") & strMsgboxErrorColumnLetter & GetTranslatedString("column_2") & _
                                                   vbNewLine 'if is_multi_template_sheet, then strMultiTemplateSheetPrefix = "".
                    End If
                End If
                
                
                'build data validation cell comment:
                If Not bValidationTableValidateColumnPassesTest Then
    
                    bTemplateCellPassesAllTests = False
                    
                    'build data validation cell comment text for this data validation table row:
                    '(when Excel imports from Web Query,
                    'table cells with multiple lines of text are imported as multiple rows)
                    
                    strErrorTextRowBuilder = shValidationData.Cells(iValidationTableItemRow, iValidationTableErrorTextColumnCol).value
                    iCountOfValidationErrorMessagesInSingleCellComment = iCountOfValidationErrorMessagesInSingleCellComment + 1

                    sngCommentHeight = shValidationData.Cells(iValidationTableItemRow, iValidationTableHeightColumnCol).value
                    sngCommentTotalHeight = sngCommentTotalHeight + sngCommentHeight + 10
                    
                    'init error cell comment's final (max) width:
'                    sngCommentMaxWidth = shValidationData.Cells(iValidationTableItemRow, iValidationTableWidthColumnCol).Value
'                    sngCommentMaxWidth = DATA_VALIDATION_WIDTH_HARDCODED
                    
                    
'                    If iValidationTableLastItemRow > iValidationTableItemRow Then
'                        'check for more error text in additional validation table rows:
'                        iErrorTextRow = iValidationTableItemRow + 1
'
'                        Do While shValidationData.Cells(iErrorTextRow, iValidationTableValidateColumnCol).Value = ""
'
'                            strErrorTextItem = shValidationData.Cells(iErrorTextRow, iValidationTableErrorTextColumnCol).Value
'                            strErrorTextRowBuilder = strErrorTextRowBuilder & vbLf & strErrorTextItem
'                            iErrorTextRow = iErrorTextRow + 1
'                        Loop
'
'                        'get error cell comment's height:
'                        sngCommentHeight = shValidationData.Cells(iValidationTableItemRow, iValidationTableHeightColumnCol).Value
'                        sngCommentTotalHeight = sngCommentTotalHeight + sngCommentHeight + 10
'
'                        'get error cell comment's width:
''                        sngCommentWidth = shValidationData.Cells(iValidationTableItemRow, iValidationTableWidthColumnCol).Value
'                        sngCommentMaxWidth = DATA_VALIDATION_WIDTH_HARDCODED
'                        If sngCommentWidth > sngCommentMaxWidth Then
'                            sngCommentMaxWidth = sngCommentWidth
'                        End If
'
'                        'get error cell comment's fontname:
''                        strCommentFontname = shValidationData.Cells(iValidationTableItemRow, iValidationTableFontnameColumnCol).Value
'                        strCommentFontname = DATA_VALIDATION_FONTNAME_HARDCODED
'                    End If '2007-06-17.
''                    Else
'                        'this can happen if validation table has only one row for this column header,
'                        'so need to set total height to this row's comment's height:
'                        If iCountOfValidationErrorMessagesInSingleCellComment < 2 Then '2009-06-17.
''                            sngCommentTotalHeight = shValidationData.Cells(iValidationTableItemRow, iValidationTableHeightColumnCol).Value
'                        End If
''                        strCommentFontname = shValidationData.Cells(iValidationTableItemRow, iValidationTableFontnameColumnCol).Value
''                        strCommentFontname = DATA_VALIDATION_FONTNAME_HARDCODED
'                    End If
    
    
    
                    'build error message for single cell comment:
                    '(build strErrorTextRowBuilder piecies into single strErrorTextMessageBuilder)
                    If strErrorTextMessageBuilder = "" Then
                        'if this row is right below the header row,
                        'avoid the strikethrough effect by
                        'adding to the comment height and starting with blank row in the comment.
                        If iTemplateValidateRow = iTemplateHeaderRow + 1 Then
                            bFirstDataRow = True
                            strErrorTextMessageBuilder = vbLf & strErrorTextRowBuilder
                        Else
                            bFirstDataRow = False
                            'this is NOT the row right below the header row:
                            strErrorTextMessageBuilder = strErrorTextRowBuilder
                        End If
                    Else
                        strErrorTextMessageBuilder = strErrorTextMessageBuilder & vbLf & vbLf & strErrorTextRowBuilder
                    End If
    
    
                End If 'If Not bValidationTableValidateColumnPassesTest Then
            
            End If 'If bValidateForThisTemplate Then
            
            

            '==============================================================================================
            'populate export_array here, for when run from ExportValidationCellCommentListToBeTranslated:
            
            If bExportArray Then
                If bWriteToExportArray Then
                    iUboundExportArray = iUboundExportArray + 1
                    ReDim Preserve export_array(1 To 7, 0 To iUboundExportArray)
                    export_array(1, iUboundExportArray) = iValidationTableItemRow
                End If
            End If
            
            '==============================================================================================

            '==============================================================================================
            'populate export_row_array here, for when run from MakeTemplate:
            
            If bExportRowArray Then
                If bWriteToExportArray Then
                    iUboundExportArray = iUboundExportArray + 1
                    ReDim Preserve export_row_array(0 To iUboundExportArray)
                    export_row_array(iUboundExportArray) = iValidationTableItemRow
                End If
            End If
            
            '==============================================================================================


        Loop 'each row in the data validation table, for this column header, with the template's language:
        
        
        
        '2009-06-17.
        sngCommentMaxWidth = DATA_VALIDATION_WIDTH_HARDCODED
        strCommentFontname = DATA_VALIDATION_FONTNAME_HARDCODED
        If iCountOfValidationErrorMessagesInSingleCellComment < 2 Then
            sngCommentTotalHeight = sngCommentHeight
'            sngCommentTotalHeight = sngCommentTotalHeight - 9
        End If
        If bFirstDataRow Then
            sngCommentTotalHeight = sngCommentTotalHeight + 10
        End If
        
        
        
        
        'add data validation cell comment to cell:
        If bTemplateCellPassesAllTests Then
            'it passed the test, so remove any highlighting and cell comment:
            ExcelHighlightCell False, rgTemplateValidateItemCell
            rgTemplateValidateItemCell.ClearComments
        Else
            'it failed the test, so apply highlighting and cell comment:
            If Not no_highlighting_no_cellcomments Then
                ExcelHighlightCell True, rgTemplateValidateItemCell
'                Debug.Print rgTemplateValidateItemCell.Address, sngCommentTotalHeight
                AddComment rgTemplateValidateItemCell, strErrorTextMessageBuilder, sngCommentTotalHeight, sngCommentMaxWidth, strCommentFontname
            End If
        End If
        
        
        
GoToSkipToNextRow:

    Next iTemplateValidateRow
    
Next iTemplateValidateCol


'reprotect template sheet:
'Call ProtectSheet(shTemplate)

If Not suppress_validation_progress_dialog Then
    Unload frmValidatePleaseWait
End If

If bIsMultiTemplateSheet Then
    ret_strMsgboxErrorColumnList = strMsgboxErrorColumnList
    ret_iMsgboxErrorColumnCount = iMsgboxErrorColumnCount
End If


If Not bExportArray And Not bExportRowArray And Not bIsMultiTemplateSheet Then
    If iMsgboxErrorColumnCount = 0 Then
        If Not called_by_upload Then    ' added 07/20/10 by atambe: stop unnecessary confirmation dialog during file upload
            'MsgBox "Validation complete. No problems found.", vbInformation + vbOKOnly, "Amazon Validation"
            AmazonMsgBox GetTranslatedString("validation_complete"), vbOKOnly, GetTranslatedString("amazon_validation")
        End If
        bUploadNow = True
    Else
        If iMsgboxErrorColumnCount = 1 Then
            strMsgboxErrorColumnSingularOrPluralPart = "column has"
        Else
            'iMsgboxErrorColumnCount > 1
            strMsgboxErrorColumnSingularOrPluralPart = "columns have"
        End If
        
        Dim strMsgText As String
        bNoList = False 'init.
        If called_by_upload Then
            'user clicked Upload toolbar button, which called
            SendKeys "{RIGHT}"
            strMsgText = GetTranslatedString("values_not_valid_1") & _
                   vbNewLine & vbNewLine & _
                   strMsgboxErrorColumnList & _
                   vbNewLine & vbNewLine & _
                   GetTranslatedString("values_not_valid_2") & _
                   vbNewLine & vbNewLine & _
                   GetTranslatedString("values_not_valid_3")
            If Len(strMsgText) > 1023 Then
                bNoList = True
                strMsgText = GetTranslatedString("invalid_values_1") & _
                       iMsgboxErrorColumnCount & GetTranslatedString("invalid_values_2") & _
                       vbNewLine & vbNewLine & _
                       GetTranslatedString("values_not_valid_2") & _
                       vbNewLine & vbNewLine & _
                       GetTranslatedString("values_not_valid_3")
            End If
'            iMsgboxRet = MsgBox(strMsgText, vbCritical + vbYesNo, "Amazon Validation")
            If bNoList Then
                iHeight = 155
            Else
                iHeight = 185 + (iMsgboxErrorColumnCount * 10) '185 plus 10 per column listed.
            End If
            iMsgboxRet = AmazonMsgBox(strMsgText, vbYesNo, GetTranslatedString("amazon_validation"))
            If iMsgboxRet = vbYes Then
                bUploadNow = True
            Else
                bUploadNow = False
            End If
        Else
            'user clicked Validate toolbar button, not Upload:
            strMsgText = GetTranslatedString("values_not_valid_1") & _
                   vbNewLine & vbNewLine & _
                   strMsgboxErrorColumnList & _
                   vbNewLine & vbNewLine & _
                   GetTranslatedString("values_not_valid_4")
            If Len(strMsgText) > 1023 Then
                bNoList = True
                strMsgText = GetTranslatedString("invalid_values_1") & _
                       iMsgboxErrorColumnCount & GetTranslatedString("invalid_values_2") & _
                       vbNewLine & vbNewLine & _
                       GetTranslatedString("values_not_valid_4")
            End If
'            MsgBox strMsgText, vbCritical + vbOKOnly, "Amazon Validation"
            If bNoList Then
                iHeight = 155
            Else
                iHeight = 185 + (iMsgboxErrorColumnCount * 10) '185 plus 10 per column listed.
            End If
            AmazonMsgBox strMsgText, vbOKOnly, GetTranslatedString("amazon_validation")
                'height:
        End If
    End If
End If

Call ResetFindParametersToDefaults

If bIsMultiTemplateSheet Then
    ValidateTemplate = True
Else
    ValidateTemplate = bUploadNow
End If


Application.EnableEvents = bEnableEventsStatus


Exit Function


CancelValidation:

Call ResetFindParametersToDefaults
Unload frmValidatePleaseWait
DoEvents
If called_by_upload And Not bIsMultiTemplateSheet Then
    strMsgText = GetTranslatedString("validation_cancelled_1") & _
       vbNewLine & vbNewLine & _
       GetTranslatedString("validation_cancelled_2") & _
       vbNewLine & vbNewLine & _
       GetTranslatedString("validation_cancelled_3")
    iRet = AmazonMsgBox(strMsgText, vbYesNo, GetTranslatedString("amazon_validation"))
    If iRet = vbYes Then
        ValidateTemplate = True
    Else
        ValidateTemplate = False
    End If
Else
    AmazonMsgBox GetTranslatedString("validation_cancelled_1"), vbOKOnly, GetTranslatedString("amazon_validation")
End If
If bIsMultiTemplateSheet Then ValidateTemplate = False
Application.EnableEvents = bEnableEventsStatus

Exit Function


GenErr:

If False Then
    Resume
End If

Application.EnableEvents = bEnableEventsStatus

If Not suppress_validation_progress_dialog Then
    Unload frmValidatePleaseWait
End If

End Function



Function CheckForCancelValidation() As Boolean
    DoEvents
    CheckForCancelValidation = bCancelValidation
End Function



Function ValidateItemByListFromColumn(validate_item As String, validate_column As Long, current_row As Long) As Boolean

Dim iTemplateHeaderRow As Long
Dim rgDropdownList As Range
Dim rgFind As Range

On Error GoTo GenErr

iTemplateHeaderRow = GetTemplateHeaderRow(GetTemplateWorksheet) 'GetTemplateWorksheet()

Set rgDropdownList = GetDropdownListFromColumn(validate_column, iTemplateHeaderRow, current_row)
If rgDropdownList Is Nothing Then
    'there is no dropdown list to validate against, so allow it to pass validation:
    ValidateItemByListFromColumn = True
    Exit Function
End If


'check for >255 characters:
If Len(validate_item) <= 255 Then
    'okay to use Find:
    Set rgFind = rgDropdownList.Find(What:=validate_item, LookAt:=xlWhole)
    
    If rgFind Is Nothing Then
        'item NOT found in list:
        ValidateItemByListFromColumn = False
    Else
        'item FOUND in list:
        ValidateItemByListFromColumn = True
    End If
    
    Exit Function
    
Else
    'Find will fail if the "What" arg is >255 characters (Excel 2007), so must check each item individually:
    Dim vDropdownList As Variant 'must declare as Variant.
    vDropdownList = rgDropdownList 'results in variant array.
    Dim iDropdownItem As Long
    Dim strDropdownItem As String
    Dim iUboundDropdownList As Long
    Dim bFound As Boolean 'inits to False here.
    iUboundDropdownList = UBound(vDropdownList, 1)

    For iDropdownItem = 1 To iUboundDropdownList
        strDropdownItem = vDropdownList(iDropdownItem, 1)
        If strDropdownItem = validate_item Then
            bFound = True
            Exit For
        End If
    Next iDropdownItem

    If bFound Then
        'item FOUND in list:
        ValidateItemByListFromColumn = True
    Else
        'item NOT found in list:
        ValidateItemByListFromColumn = False
    End If
    
    Exit Function

End If

'shouldn't get here, so fail if you do:
ValidateItemByListFromColumn = False

GenErr:
ValidateItemByListFromColumn = False

End Function







Function DownloadDataValidationTableFromWeb(url_defined_name_string As String, old_rev_date As Range) As Worksheet

Dim strURL As String
Dim qtQueryTable As QueryTable
Dim strDataValidationTableFullPath As String
Dim wbDataValidationTable As Workbook
Dim shDataValidationTable As Worksheet
Dim strDataValidationTableWorksheetName As String
Dim wbWorkbook As Workbook
Dim shWorksheet As Worksheet
Dim bRet As Boolean
Dim bOldDataValidationTableWorksheetExists As Boolean
Dim iRet As Long
Dim bDisplayAlertsStatus As Boolean
Dim shActiveSheet As Worksheet


On Error GoTo GenErr

bOldDataValidationTableWorksheetExists = False 'init.
For Each shWorksheet In ThisWorkbook.Worksheets
    If shWorksheet.Name = DATA_VALIDATION_TABLE_WORKSHEET_NAME Then
        bOldDataValidationTableWorksheetExists = True
        Exit For
    End If
Next shWorksheet


strURL = ThisWorkbook.Names(url_defined_name_string).RefersToRange.value


Set shActiveSheet = ActiveSheet
'Set shDataValidationTable = ThisWorkbook.Worksheets.Add(After:=ThisWorkbook.Worksheets(ThisWorkbook.Worksheets.Count))

'bRet = DownloadTableFromWebByURL(shDataValidationTable.Range("A1"), strURL)

Set shDataValidationTable = InsertWorksheetFromUrl(strURL)

If shDataValidationTable Is Nothing Then
    bRet = False
Else
    bRet = True
End If



If bRet Then
    'download was successful:

        bDisplayAlertsStatus = Application.DisplayAlerts
        Application.DisplayAlerts = False
        Dim bUseImportedSheet As Boolean
'        If Not ThisWorkbook.Worksheets(DATA_VALIDATION_TABLE_WORKSHEET_NAME) Is shDataValidationTable Then
        
        
        

            'check revdate:
            Dim dblOldRevDate As Double
            Dim rgImportRevDate As Range
            Dim dblImportRevDate As Double
            Set rgImportRevDate = shDataValidationTable.Cells.Find("REVDATE").Offset(ColumnOffset:=1)
            If rgImportRevDate Is Nothing Then
                'imported file's revdate not found.
                bUseImportedSheet = True
            Else
                'imported file's revdate was found.
                On Error GoTo ErrGetDate
                dblImportRevDate = CDbl(Format(CVar(rgImportRevDate.value), "0.0000000000"))
                If old_rev_date.value = "" Then
                    dblOldRevDate = -1
                Else
                    dblOldRevDate = CDbl(Format(CVar(old_rev_date.value), "0.0000000000"))
                End If
                On Error GoTo GenErr
                
                If dblImportRevDate >= dblOldRevDate Then
                    'imported file is same revdate or newer:
                    bUseImportedSheet = True
                   
                Else
                    'imported file is NOT newer:
                    bUseImportedSheet = False
                    If bOldDataValidationTableWorksheetExists Then
                        shDataValidationTable.Delete
                    End If
                    On Error GoTo ErrComment
                    old_rev_date.Comment.Text GetTranslatedString("import_failed_1") & _
                                              Format(Now, "mmmm d, yyyy - h:mm:ss AM/PM") & _
                                              GetTranslatedString("import_failed_2") & _
                                              Format(dblImportRevDate, "mmmm d, yyyy - h:mm:ss AM/PM") & _
                                              GetTranslatedString("import_failed_3") & _
                                              Format(dblOldRevDate, "mmmm d, yyyy - h:mm:ss AM/PM") & GetTranslatedString("import_failed_4")
'                    old_rev_date.Comment.Shape.height = 60 'breaks xl2010.
'                    old_rev_date.Comment.Shape.width = 250 'breaks xl2010.
                    On Error GoTo GenErr
                    Set DownloadDataValidationTableFromWeb = Nothing
                    Exit Function
                End If
                    
'            End If
            
        
        
        If bUseImportedSheet = True Then
            On Error Resume Next 'to avoid error if sheet not there.
            ThisWorkbook.Worksheets(DATA_VALIDATION_TABLE_WORKSHEET_NAME).Delete
            On Error GoTo GenErr
            old_rev_date.value = dblImportRevDate
            On Error GoTo ErrComment
            old_rev_date.Comment.Text "Imported " & Format(Now, "mmmm d, yyyy - h:mm:ss AM/PM")
'            old_rev_date.Comment.Shape.height = 30 'breaks xl2010.
'            old_rev_date.Comment.Shape.width = 200 'breaks xl2010.
            On Error GoTo GenErr
        End If
      

        
        
        End If
        Application.DisplayAlerts = bDisplayAlertsStatus

    shDataValidationTable.Name = DATA_VALIDATION_TABLE_WORKSHEET_NAME
    shDataValidationTable.Visible = False
'    shActiveSheet.Activate
Else
    'download was not successful:
    bDisplayAlertsStatus = Application.DisplayAlerts
    Application.DisplayAlerts = False
'    shDataValidationTable.Delete
    shActiveSheet.Activate
    Application.DisplayAlerts = bDisplayAlertsStatus
    If bOldDataValidationTableWorksheetExists Then
        frmProgressIntTemplates.Hide
        DoEvents
'        iRet = MsgBox("Download of data validation data (from " & strURL & ") was not successful. " & _
                      vbNewLine & vbNewLine & _
                      "Use old data validation data already in this workbook instead?", _
               vbQuestion + vbYesNo, "Download Unsuccessful")
        iRet = AmazonMsgBox(GetTranslatedString("download_validation_not_successful_1") & strURL & GetTranslatedString("download_validation_not_successful_2") & _
                            vbNewLine & vbNewLine & _
                            GetTranslatedString("download_validation_not_successful_3"), _
                            vbYesNo, GetTranslatedString("download_unsuccessful"))
        If iRet = vbYes Then
            'proceed with old data:
            Set DownloadDataValidationTableFromWeb = ThisWorkbook.Worksheets(DATA_VALIDATION_TABLE_WORKSHEET_NAME)
            Exit Function
        End If
    Else
        'no data (either old or new) available:
        DoEvents
'        iRet = MsgBox("Download of data validation data (from " & strURL & ") was not successful. " & _
                      "Old data validation data not found in this workbook " & _
                      "(worksheet named """ & DATA_VALIDATION_TABLE_WORKSHEET_NAME & """ not found). " & _
                      vbNewLine & vbNewLine & _
                      "Unable to validate.", _
                      vbCritical + vbOKOnly, "Data Not Found")
        iRet = AmazonMsgBox(GetTranslatedString("download_validation_not_successful_1") & strURL & GetTranslatedString("download_validation_not_successful_2") & _
                            GetTranslatedString("download_validation_not_successful_4") & _
                            DATA_VALIDATION_TABLE_WORKSHEET_NAME & GetTranslatedString("download_validation_not_successful_5") & _
                            vbNewLine & vbNewLine & _
                            GetTranslatedString("download_validation_not_successful_6"), _
                            vbOKOnly, GetTranslatedString("data_not_found"))
        bOldDataValidationTableWorksheetExists = True
        Exit Function
    End If
End If

Set DownloadDataValidationTableFromWeb = shDataValidationTable



Exit Function

ErrGetDate:

If False Then
    Resume
End If

'error getting revdates. Set the dates so that the imported file will be used:
dblImportRevDate = 999999
dblOldRevDate = -1

Exit Function


ErrComment:

old_rev_date.AddComment
Resume

Exit Function



GenErr:

If False Then
    Resume
End If


End Function






Public Sub ExcelHighlightCell(toggle As Boolean, highlight_cell As Range)

    If toggle Then
        highlight_cell.BorderAround Weight:=xlMedium, ColorIndex:=3
    Else
        highlight_cell.Borders(xlLeft).LineStyle = xlNone
        highlight_cell.Borders(xlRight).LineStyle = xlNone
        highlight_cell.Borders(xlTop).LineStyle = xlNone
        highlight_cell.Borders(xlBottom).LineStyle = xlNone
        highlight_cell.BorderAround LineStyle:=xlNone
    End If
End Sub



Public Function OnCellEditRemoveValidationIndicators(target_range As Range) As Boolean

'upon cell edit, removes highlight border and comment for selected cells.

Dim rgCell As Range
Dim cmtComment As Comment
Dim bProtected As Boolean

On Error GoTo GenErr

OnCellEditRemoveValidationIndicators = False 'init.

If target_range.Parent Is ActiveSheet Then
    bProtected = ActiveSheet.ProtectContents
    ActiveSheet.Unprotect
    Application.ScreenUpdating = False
    '6/9/2008 - GJL - this takes too long on a large range. Removing loop:
'    For Each rgCell In target_range
'        Set cmtComment = rgCell.Comment
'        If Not cmtComment Is Nothing Then
'            ExcelHighlightCell False, rgCell
'        End If
'    Next rgCell
    ExcelHighlightCell False, target_range '6/9/2008 - GJL - this replaces the above loop.
    target_range.ClearComments
    Application.ScreenUpdating = True
    If bProtected Then
        Call ProtectSheet(ActiveSheet)
    End If
End If

OnCellEditRemoveValidationIndicators = True

Exit Function

GenErr:
'probably bad target_range due to deleting it in ResetTargetRangeNumberFormattingToText.
Exit Function

End Function





Public Sub AddComment(comment_cell As Range, comment_text As String, _
                      comment_height As Single, comment_width As Single, _
                      comment_fontname As String)
    
    comment_cell.ClearComments
    comment_cell.AddComment comment_text
    With comment_cell.Comment.Shape
        .TextFrame.Characters.Font.Size = 10
        If comment_fontname <> "" Then
            .TextFrame.Characters.Font.Name = comment_fontname
        End If
        .Height = comment_height
        .Width = comment_width
        
        .Fill.ForeColor.RGB = RGB(221, 238, 255) 'very light blue.
        
    End With

End Sub




Function CloseWorkbookIfOpen(work_book As String) As Boolean

'true on success (workbook closed, or workbook not found).
'false on failure (workbook found but not closed, or other error).

Dim wbWorkbook As Workbook

For Each wbWorkbook In Application.Workbooks
    If wbWorkbook.Name = work_book Then
        wbWorkbook.Close SaveChanges:=False
        Exit For
    End If
Next wbWorkbook
DoEvents

CloseWorkbookIfOpen = True

End Function



Function DeleteFileIfExists(full_path As String) As Boolean

'true on success (workbook closed, or workbook not found).
'false on failure (workbook found but not closed, or other error).

Dim fso As Object
Dim oFolder As Object
Set fso = CreateObject("Scripting.FileSystemObject")
If fso.FileExists(full_path) Then
    Kill full_path
    DoEvents
End If

DeleteFileIfExists = True

End Function



Function DeleteWorksheetIfExists(sheet_name As String, Optional work_book As Workbook) As Boolean
    Dim shWorksheet As Worksheet
    Dim wbWorkbook As Workbook
    Dim bDisplayAlertsStatus As Boolean
    
    If work_book Is Nothing Then
        Set wbWorkbook = ThisWorkbook
    Else
        Set wbWorkbook = work_book
    End If
    
    For Each shWorksheet In wbWorkbook.Worksheets
        If shWorksheet.Name = sheet_name Then
            bDisplayAlertsStatus = Application.DisplayAlerts
            Application.DisplayAlerts = False
            shWorksheet.Delete
            Application.DisplayAlerts = bDisplayAlertsStatus
            Exit For
        End If
    Next shWorksheet
End Function



Function CloseWorkbookAndReopenAsExcel972003(work_book As Workbook) As Workbook
'returns Workbook object on success; Nothing on failure.

    Dim strFullPath As String
    Dim bDisplayAlertsStatus As Boolean
    Dim iFileFormat As Long
    
    bDisplayAlertsStatus = Application.DisplayAlerts
    Application.DisplayAlerts = False
    
    If Val(Application.Version) >= 12 Then
        'Excel 2007 or later:
        iFileFormat = GetxlExcel8FileFormat()
    Else
        'Excel 2003 or earlier:
        iFileFormat = xlNormal
    End If
    
    strFullPath = work_book.Path & "\" & work_book.Name
    
    Dim bEnableEventsStatus As Boolean
    bEnableEventsStatus = GetEnableEventsStatusAndTurnItOff
    work_book.SaveAs FileName:=strFullPath, FileFormat:=iFileFormat
    Application.DisplayAlerts = bDisplayAlertsStatus
    work_book.Close SaveChanges:=False
    Set CloseWorkbookAndReopenAsExcel972003 = Workbooks.Open(strFullPath, UpdateLinks:=0) '0 = do not update links.
    Application.EnableEvents = bEnableEventsStatus
End Function


Function GetxlExcel8FileFormat() As Long
'DO NOT CALL OR TRY TO COMPILE IN EXCEL 2000.
GetxlExcel8FileFormat = xlExcel8
End Function


Public Function SwapInSheetAndDeleteSourceWorkbook(source_book As Workbook, Optional source_book_full_path As String, _
                                                   Optional target_book As Workbook) As Worksheet

'assumes there is only one worksheet in workbook. Takes the first (leftmost) worksheet.

Dim strSourceWorksheet As String
Dim strSourceWorkbookFullPath As String
Dim wbTarget As Workbook
Dim bGotErrorTooManyDifferentCellFormats As Boolean
Dim bSkipCopyingFormats As Boolean '2009-10-27. Crash.

On Error GoTo GenErr

If target_book Is Nothing Then
    Set wbTarget = ThisWorkbook
Else
    Set wbTarget = target_book
End If

If source_book_full_path = "" Then
    strSourceWorkbookFullPath = source_book.Path & "\" & source_book.Name
Else
    strSourceWorkbookFullPath = source_book_full_path
End If

    strSourceWorksheet = source_book.Worksheets(1).Name
    
    'if a sheet by that name already exists, delete it:
    Call DeleteWorksheetIfExists(strSourceWorksheet, wbTarget)
    
    
    'must save as excel97-2003 file format (from Excel 2007 file format),
    'then close and reopen it, to avoid error when trying to
    'copy into workbook of excel97-2003 file format:
    Set source_book = CloseWorkbookAndReopenAsExcel972003(source_book)
    
    bGotErrorTooManyDifferentCellFormats = False 'init.
    source_book.Worksheets(1).Copy After:=wbTarget.Worksheets(wbTarget.Worksheets.Count)
    If bGotErrorTooManyDifferentCellFormats Then
'        Stop
        Dim shTempTarget As Worksheet
        Dim rgSourceUsedRange As Range
        Dim rgCellSource As Range
        Dim rgCellDest As Range
        Dim iCellCol As Long
        Dim iCellRow As Long
        Set shTempTarget = wbTarget.Worksheets.Add(After:=wbTarget.Worksheets(wbTarget.Worksheets.Count))
        source_book.Worksheets(1).Cells.Copy
'        shTempTarget.Cells.PasteSpecial xlPasteAll  'this results in the same error; "too many different cell formats."
'        shTempTarget.Cells.PasteSpecial xlPasteFormats  'this results in the same error; "too many different cell formats."
        shTempTarget.Cells.PasteSpecial xlPasteColumnWidths
        shTempTarget.Cells.PasteSpecial xlPasteComments
        shTempTarget.Cells.PasteSpecial xlPasteFormulasAndNumberFormats
        Set rgSourceUsedRange = source_book.Worksheets(1).UsedRange
        For Each rgCellSource In rgSourceUsedRange
            iCellCol = rgCellSource.Column
            iCellRow = rgCellSource.Row
            Set rgCellDest = shTempTarget.Cells(iCellRow, iCellCol)
            With rgCellSource
                rgCellDest.HorizontalAlignment = .HorizontalAlignment
                rgCellDest.VerticalAlignment = .VerticalAlignment
                rgCellDest.WrapText = .WrapText
                rgCellDest.Orientation = .Orientation
                rgCellDest.AddIndent = .AddIndent
                rgCellDest.IndentLevel = .IndentLevel
                rgCellDest.ShrinkToFit = .ShrinkToFit
                rgCellDest.ReadingOrder = .ReadingOrder
                rgCellDest.MergeCells = .MergeCells
            End With
            With rgCellSource.Font
                rgCellDest.Font.Name = .Name
                rgCellDest.Font.ColorIndex = .ColorIndex
                rgCellDest.Font.Size = .Size
                rgCellDest.Font.FontStyle = .FontStyle
                rgCellDest.Font.Underline = .Underline
                rgCellDest.Font.Strikethrough = .Strikethrough
                rgCellDest.Font.Superscript = .Superscript
                rgCellDest.Font.Subscript = .Subscript
                rgCellDest.Font.OutlineFont = .OutlineFont
                rgCellDest.Font.Shadow = .Shadow
            End With
            With rgCellSource.Interior
                rgCellDest.Interior.ColorIndex = .ColorIndex
                rgCellDest.Interior.Pattern = .Pattern
                rgCellDest.Interior.PatternColorIndex = .PatternColorIndex
            End With
            
            With rgCellSource.Borders(xlEdgeLeft)
                rgCellDest.Borders(xlEdgeLeft).LineStyle = .LineStyle
                rgCellDest.Borders(xlEdgeLeft).Weight = .Weight
                rgCellDest.Borders(xlEdgeLeft).ColorIndex = .ColorIndex
            End With
            With rgCellSource.Borders(xlEdgeTop)
                rgCellDest.Borders(xlEdgeTop).LineStyle = .LineStyle
                rgCellDest.Borders(xlEdgeTop).Weight = .Weight
                rgCellDest.Borders(xlEdgeTop).ColorIndex = .ColorIndex
            End With
            With rgCellSource.Borders(xlEdgeBottom)
                rgCellDest.Borders(xlEdgeBottom).LineStyle = .LineStyle
                rgCellDest.Borders(xlEdgeBottom).Weight = .Weight
                rgCellDest.Borders(xlEdgeBottom).ColorIndex = .ColorIndex
            End With
            With rgCellSource.Borders(xlEdgeRight)
                rgCellDest.Borders(xlEdgeRight).LineStyle = .LineStyle
                rgCellDest.Borders(xlEdgeRight).Weight = .Weight
                rgCellDest.Borders(xlEdgeRight).ColorIndex = .ColorIndex
            End With
            rgCellDest.Borders(xlDiagonalDown).LineStyle = rgCellSource.Borders(xlDiagonalDown).LineStyle
            rgCellDest.Borders(xlDiagonalUp).LineStyle = rgCellSource.Borders(xlDiagonalUp).LineStyle
            
            If bGotErrorTooManyDifferentCellFormats Then GoTo GoToSkipCopyingFormats
            
        Next rgCellSource
    End If
    bGotErrorTooManyDifferentCellFormats = False
GoToSkipCopyingFormats:
        
    
    'in Excel 2003 and earlier, copying in a sheet truncates text to 255 characters per cell.
    'so, copy/paste to get back correct cell contents:
    If Val(Application.Version) <= 11 Then
        'excel 2003 or earlier:
        Dim strUsedRangeAddress As String
        Dim bSheetProtected As Boolean
        
        Dim shSource As Worksheet
        Dim shTarget As Worksheet
        
        Set shSource = source_book.Worksheets(1)
        Set shTarget = wbTarget.Worksheets(shSource.Name)
        
        If shTarget.ProtectContents Then
            bSheetProtected = True
            shTarget.Unprotect
        Else
            bSheetProtected = False
        End If
        
        If Not source_book Is ActiveWorkbook Then source_book.Activate
        If Not shSource Is ActiveSheet Then shSource.Activate
        strUsedRangeAddress = shSource.UsedRange.Address
        
        Dim bDisplayAlertsStatus As Boolean
        bDisplayAlertsStatus = Application.DisplayAlerts
        Application.DisplayAlerts = False 'to prevent prompt to find source for links, e.g. from JP Ddef keysheets.
        DoEvents
        shSource.Range(strUsedRangeAddress).Copy Destination:=shTarget.Range(strUsedRangeAddress)
        Application.DisplayAlerts = bDisplayAlertsStatus
        DoEvents
        
        
        Application.CutCopyMode = False
        If bSheetProtected Then Call ProtectSheet(shTarget)
    End If
    

    Set SwapInSheetAndDeleteSourceWorkbook = wbTarget.Worksheets(strSourceWorksheet)
    
    
    source_book.Close SaveChanges:=False
    DoEvents
    Kill strSourceWorkbookFullPath
    DoEvents

Exit Function
GenErr:

If False Then
    Resume
End If

'2009-10-27. Crash.
If bGotErrorTooManyDifferentCellFormats Then
    bSkipCopyingFormats = True
    Resume Next
End If

If InStr(UCase(Err.Description), UCase("too many different cell formats")) > 0 Then
    bGotErrorTooManyDifferentCellFormats = True
    Resume Next
End If

Debug.Print Err.Description

End Function



Public Function InsertWorksheetFromUrl(url_source As String) As Worksheet

'returns worksheet on success; Nothing on failure.

Dim bRet As Boolean
Dim strSourceWorkbookFullPath As String
Dim wbSourceWorkbook As Workbook

Const SOURCE_WORKBOOK_FILENAME As String = "SourceWorkbook.xls"


bRet = CloseWorkbookIfOpen(SOURCE_WORKBOOK_FILENAME)

strSourceWorkbookFullPath = Environ("tmp") & "\" & SOURCE_WORKBOOK_FILENAME

Call DeleteFileIfExists(strSourceWorkbookFullPath)

Set wbSourceWorkbook = OpenUnicodeTabDelimFileAsWorkbookFromURL(url_source, strSourceWorkbookFullPath)
If wbSourceWorkbook Is Nothing Then
    bRet = False
Else
    'success:
    bRet = True
    
    Set InsertWorksheetFromUrl = SwapInSheetAndDeleteSourceWorkbook( _
                                    wbSourceWorkbook, strSourceWorkbookFullPath)

End If

End Function














Attribute VB_Name = "shIcons"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "shIntSettings"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "shIntTranslations"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "shIntURLs"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "shTemplate1"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Control = "cboOfferCreation, 7, 4, MSForms, ComboBox"
Option Explicit


Public lastcolorIndex As Integer
Public ProductIDColumnNumber As Integer


Private Sub cboOfferCreation_Click()
    'Odd behavior. Use MouseUp to determine when to run Click.
    DropdownGotClicked cboOfferCreation
End Sub

Private Sub cboOfferCreation_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    'dismiss dropdown if user double-clicks:
    DropdownGotDoubleClicked cboOfferCreation
End Sub

Private Sub cboOfferCreation_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal y As Single)
    'if user holds mouse down, assume they want to select a range, so dismiss the dropdown:
    DropdownGotMouseDowned cboOfferCreation
End Sub

Private Sub cboOfferCreation_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal y As Single)
    'Fires before dropdown's value is set to the clicked list item. Use to determine when to run Click Event.
    DropdownGotMouseUpped cboOfferCreation
End Sub


Private Sub cboOfferCreation_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
    DropdownGotKeyDowned cboOfferCreation, CInt(KeyCode), Shift
End Sub


Private Sub Worksheet_Activate()
    TemplateWorksheetGotActivated
End Sub


Private Sub Worksheet_Change(ByVal Target As Range)
    TemplateWorksheetGotChanged Target
End Sub


Public Sub Worksheet_SelectionChange(ByVal Target As Range)
    TemplateWorksheetGotSelectionChanged Target
End Sub









' InQuest injected base64 decoded content
' )]"{^
' &k:'
' Szjej
' [jwVj
' ^"{-
' *ey7
' y(^z
' *ey7
' y(^z
' *ey7
' y(^z
' *'jX
' k"'u
' y(^z
' ^"{^
' )brG
' e"th
' x)brG
' Kjx.j
' zjej
' Szjej
' zjej
' "w+zg
' zjej
' )eJ)
' .+-n
' ']zq'
' m'+y
' Szjej
' ]"{^
' zjej
' u(^z
' zYCz
' Szjej
' zw2M
' zjej
' wSzjej
' k"'u
' Szjej
' zjej
' k"'u
' k"-zc
' *'jP
' k!^y
' zw2M
' k"'u
' k"'u
' k"'u
' zw2M
' jwbu
' j{%j
' z{S{
' zw2M
' zw2M
' "{Rz
' zY@u
' zjej
' jx.j
' njYr9
' +bjX
' :-jU
' /j)ZnW
' r'v'
' ^Z'm
' zjej
' zjej
' ^>*+F
' zjej
' zjej
' xZ+N
' H|Lb
' Z,yj+
' )zp,

INQUEST-PP=macro
