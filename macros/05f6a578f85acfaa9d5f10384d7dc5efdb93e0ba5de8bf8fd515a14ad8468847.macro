Attribute VB_Name = "ButtonMacros"
Public Declare PtrSafe Function SetCurrentDirectoryA Lib "kernel32" (ByVal lpPathName As String) As Long

Sub Macro1(control As IRibbonControl)

    'Analysis & Design Criteria
    Dim Template As String
    Dim FilName As Variant

    'the first 8 macros (and ribbon buttons) import templates from the engineering drive.
    'these sheets are imported as new tabs, the named cells are replaced with values from the dashboard.
    
    'set 2 paths, current workbook path and spreadsheet path
    'spreadsheet path is network drive, must declare Lib kernel.
    'current directory drive is not reassigned, don't think it needs to be, more of precaution.
    'if problem can take more steps to reset drive and directory, but seems like overkill
    'these first 8 macros are all the same except for accessing different folders, maybe can combine?
    'just seems like it might be tough to have same macro for different buttons, not sure how to accomplish that
    
    Path1 = ActiveWorkbook.Path
    Path2 = "\\zfa.com\" & Range("Office") & _
    "\Engineering\CalcSpreadsheets & Design Tables\CBC 16_IBC 15\Analysis & Design Criteria"
    
    SetCurrentDirectoryA "\\zfa.com\" & Range("Office") & "\"
    ChDir Path2

    'open folder window so user can select workbook they want to import
    FilName = Application.GetOpenFilename("Excel Workbooks, *.xls; *.xlsx; *.xlsm", , "Specify the Template File to Add")
    
    'if no file give message, if file call copy sheets
    If FilName = False Then
        'MsgBox "No File Was Selected"
        Exit Sub
    Else
        Template = CStr(FilName)
        Call CopySheet(Template)
    End If
    
    ChDir Path1
    
    
End Sub

Sub Macro2(control As IRibbonControl)

    'Concrete
    Dim Template As String
    Dim FilName As Variant

    Path1 = ActiveWorkbook.Path
    Path2 = "\\zfa.com\" & Range("Office") & _
    "\Engineering\CalcSpreadsheets & Design Tables\CBC 16_IBC 15\Concrete"
    
    SetCurrentDirectoryA "\\zfa.com\" & Range("Office") & "\"
    ChDir Path2
    
    FilName = Application.GetOpenFilename("Excel Workbooks, *.xls; *.xlsx; *.xlsm", , "Specify the Template File to Add")
    If FilName = False Then
        'MsgBox "No File Was Selected"
        Exit Sub
    Else
        Template = CStr(FilName)
        Call CopySheet(Template)
    End If
    
    ChDir Path1
    
End Sub

Sub Macro3(control As IRibbonControl)

    'Foundation
    Dim Template As String
    Dim FilName As Variant

    Path1 = ActiveWorkbook.Path
    Path2 = "\\zfa.com\" & Range("Office") & _
    "\Engineering\CalcSpreadsheets & Design Tables\CBC 16_IBC 15\Foundation"
    
    SetCurrentDirectoryA "\\zfa.com\" & Range("Office") & "\"
    ChDir Path2

    FilName = Application.GetOpenFilename("Excel Workbooks, *.xls; *.xlsx; *.xlsm", , "Specify the Template File to Add")
    If FilName = False Then
        'MsgBox "No File Was Selected"
        Exit Sub
    Else
        Template = CStr(FilName)
        Call CopySheet(Template)
    End If
    
    ChDir Path1
    
End Sub

Sub Macro4(control As IRibbonControl)

    'Masonry
    Dim Template As String
    Dim FilName As Variant

    Path1 = ActiveWorkbook.Path
    Path2 = "\\zfa.com\" & Range("Office") & _
    "\Engineering\CalcSpreadsheets & Design Tables\CBC 16_IBC 15\Masonry"
    
    SetCurrentDirectoryA "\\zfa.com\" & Range("Office") & "\"
    ChDir Path2

    FilName = Application.GetOpenFilename("Excel Workbooks, *.xls; *.xlsx; *.xlsm", , "Specify the Template File to Add")
    If FilName = False Then
        'MsgBox "No File Was Selected"
        Exit Sub
    Else
        Template = CStr(FilName)
        Call CopySheet(Template)
    End If
    
    ChDir Path1
    
End Sub

Sub Macro5(control As IRibbonControl)

    'Metal Stud
    Dim Template As String
    Dim FilName As Variant

    Path1 = ActiveWorkbook.Path
    Path2 = "\\zfa.com\" & Range("Office") & _
    "\Engineering\CalcSpreadsheets & Design Tables\CBC 16_IBC 15\Metal Stud"
    
    SetCurrentDirectoryA "\\zfa.com\" & Range("Office") & "\"
    ChDir Path2

    FilName = Application.GetOpenFilename("Excel Workbooks, *.xls; *.xlsx; *.xlsm", , "Specify the Template File to Add")
    If FilName = False Then
        'MsgBox "No File Was Selected"
        Exit Sub
    Else
        Template = CStr(FilName)
        Call CopySheet(Template)
    End If
    
    ChDir Path1
    
End Sub

Sub Macro6(control As IRibbonControl)

    'Misc
    Dim Template As String
    Dim FilName As Variant

    Path1 = ActiveWorkbook.Path
    Path2 = "\\zfa.com\" & Range("Office") & _
    "\Engineering\CalcSpreadsheets & Design Tables\CBC 16_IBC 15\Misc"
    
    SetCurrentDirectoryA "\\zfa.com\" & Range("Office") & "\"
    ChDir Path2

    FilName = Application.GetOpenFilename("Excel Workbooks, *.xls; *.xlsx; *.xlsm", , "Specify the Template File to Add")
    If FilName = False Then
        'MsgBox "No File Was Selected"
        Exit Sub
    Else
        Template = CStr(FilName)
        Call CopySheet(Template)
    End If
    
    ChDir Path1
    
End Sub

Sub Macro7(control As IRibbonControl)

    'Steel
    Dim Template As String
    Dim FilName As Variant

    Path1 = ActiveWorkbook.Path
    Path2 = "\\zfa.com\" & Range("Office") & _
    "\Engineering\CalcSpreadsheets & Design Tables\CBC 16_IBC 15\Steel"
    
    SetCurrentDirectoryA "\\zfa.com\" & Range("Office") & "\"
    ChDir Path2

    FilName = Application.GetOpenFilename("Excel Workbooks, *.xls; *.xlsx; *.xlsm", , "Specify the Template File to Add")
    If FilName = False Then
        'MsgBox "No File Was Selected"
        Exit Sub
    Else
        Template = CStr(FilName)
        Call CopySheet(Template)
    End If
    
    ChDir Path1
    
End Sub

Sub Macro8(control As IRibbonControl)

    'Wood
    Dim Template As String
    Dim FilName As Variant

    Path1 = ActiveWorkbook.Path
    Path2 = "\\zfa.com\" & Range("Office") & _
    "\Engineering\CalcSpreadsheets & Design Tables\CBC 16_IBC 15\Wood"
   
    SetCurrentDirectoryA "\\zfa.com\" & Range("Office") & "\"
    ChDir Path2

    FilName = Application.GetOpenFilename("Excel Workbooks, *.xls; *.xlsx; *.xlsm", , "Specify the Template File to Add")
    If FilName = False Then
        'MsgBox "No File Was Selected"
        Exit Sub
    Else
        Template = CStr(FilName)
        Call CopySheet(Template)
    End If
    
    ChDir Path1
    
End Sub

Sub Macro9(control As IRibbonControl)

    'User template
    Dim Template As String
    Dim FilName As Variant

    Path1 = ActiveWorkbook.Path
    'Path2 = "\\zfa.com\" & ActiveWorkbook.Sheets("Dashboard").Range("C3").Value & _
    "\Engineering\ZFA Committees\Spreadsheet Committee\In progress - FOR TESTING ONLY\CalcSpreadsheets\Wood"
   
    'SetCurrentDirectoryA "\\zfa.com\" & ActiveWorkbook.Sheets("Dashboard").Range("C3").Value & "\"
    ChDir Path1
    MsgBox "WARNING: Make sure you have checked the name manager in your user template before import to " & _
    "make sure all names match the Dashboard. Contact Chelsea for further assistance."
    
    FilName = Application.GetOpenFilename("Excel Workbooks, *.xls; *.xlsx; *.xlsm", , "Specify the Template File to Add")
    If FilName = False Then
        'MsgBox "No File Was Selected"
        Exit Sub
    Else
        Template = CStr(FilName)
        Call CopySheet(Template)
    End If
    
    'ChDir Path1
    
End Sub

Sub macro10(control As IRibbonControl)

'Add Headers

'This code just loads the userform. To see the userform go to Forms and click on Header.
'This form calls the rest of the code which is in the Main module

Load Header

Header.TitleText.Enabled = False
Header.TitleText.BackColor = &H80000004
Header.EngText.Enabled = False
Header.EngText.BackColor = &H80000004
Header.DteText.Enabled = False
Header.DteText.BackColor = &H80000004
Header.ReplaceOne.Value = True


Header.Show

End Sub

Sub macro11(control As IRibbonControl)

    Load UpdateTOC

    UpdateTOC.AllTabsButton.Value = True
  
    UpdateTOC.Show


End Sub

Sub Macro12(control As IRibbonControl)
    'this macro opens the print to pdf user form
    
    Load PrintToPDF
    PrintToPDF.Show
    
End Sub

Sub Macro13(control As IRibbonControl)
'
' this routine exports sheet(s) to make a new template

Dim wb As Workbook
Dim owb As Workbook
Dim ws As Worksheet
Dim Holdname() As String
Dim MyNames As Names
Dim x, n, k As Byte
Dim Sh, CL As String
Dim HName As String
Dim SelectedSheets() As String

MsgBox "Update: This button can now export multiple sheets! " & _
"Select all the sheets to export as one file before pressing the button."

'no screen updating keeps from screen flicker
Application.ScreenUpdating = False

Set owb = ActiveWorkbook
 n = 0
    For Each ws In ActiveWindow.SelectedSheets
        ReDim Preserve SelectedSheets(n)
        SelectedSheets(n) = ws.Name
        n = n + 1
    Next

Fname = Application.GetSaveAsFilename(InitialFileName:="", FileFilter:="Excel Files (*.xlsx), *.xlsx", Title:="Save As")
If Fname = False Then Exit Sub
Sheets(SelectedSheets).Copy
ActiveWorkbook.SaveAs Filename:=Fname

Set wb = ActiveWorkbook
Set MyNames = ActiveWorkbook.Names

'count the number of names that need to be replaced in the template file
'weird issue with regression_int. it doesn't appear in the name manager but causes issues on
'import with some of the templates. so ignoring that as well as print area and print title
k = 0
For x = 1 To MyNames.count
    If (InStr(1, MyNames(x).Name, "Print_Area") = 0 And InStr(1, MyNames(x).Name, "Print_Titles") = 0 _
    And InStr(1, MyNames(x).Name, "_Regression_Int") = 0 And InStr(1, MyNames(x).Name, "_xlfn") = 0) Then
        k = k + 1
    End If
Next
    
'otherwise dimension the matrix to hold names and locations to right size
ReDim Preserve Holdname(1, 1 To k)

'save the names and their locations in the template
n = 0
For x = 1 To MyNames.count
    If (InStr(1, MyNames(x).Name, "Print_Area") = 0 And InStr(1, MyNames(x).Name, "Print_Titles") = 0 _
    And InStr(1, MyNames(x).Name, "_Regression_Int") = 0 And InStr(1, MyNames(x).Name, "_xlfn") = 0) Then
        n = n + 1
        Holdname(1, n) = MyNames(x).Name
    End If
Next

I = 1
For x = 1 To UBound(Holdname, 2)
       
    'Find name of cell either local or global to previous spreadsheet
    'HNLength = Len(Holdname(1, x)) - FindRightChar(Holdname(1, x))
    HName = Holdname(1, x)

    For Each ws In wb.Worksheets
    n = 0
    ws.Activate
nextcell:
        'find the name in the sheet
        Set Rng = Cells.Find(What:="=" & HName, after:=ActiveCell, LookIn:=xlFormulas, LookAt:= _
            xlWhole, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=False _
            , SearchFormat:=False)
             
        If Rng Is Nothing Then
            GoTo nextsheet
            
        'if name is there, replace text with value and make local name
        Else
            Rng.Activate
            Selection.Copy
            Selection.PasteSpecial Paste:=xlPasteValues, Operation:=xlNone, SkipBlanks _
                :=False, Transpose:=False
            
            'used names must be unique when deleting unused names later in the code
            'the newName will include a flag to make name unique
            newName = "____" & I & "____" & HName
            I = I + 1
            If n = 0 Then
                ws.Names.Add Name:=newName, RefersTo:=Rng
                n = n + 1
            Else
                nameToUse = "=" & "'" & ws.Name & "'" & "!" & newName
                Rng.Value = nameToUse
            End If
            
            Rng.Font.ColorIndex = 3
            Cells.Range("A1").Activate
            GoTo nextcell
        End If
nextsheet:
    Next
Next

'remove all remaining unused names which are workbook scoped
For Each objName In MyNames

    If (objName.Parent.Name = wb.Name Or objName.Parent.Name = owb.Name) _
    And InStr(1, objName.Name, "_xlfn") = 0 Then
    
        objName.Delete
        
    End If
Next objName

'remove flag that was added earlier on in code
For Each objName In MyNames
    If InStr(1, objName.Name, "___") <> 0 Then
    
        Finish = InStrRev(objName.Name, "___") + Len("___") - 1
        objName.Name = Right(objName.Name, Len(objName.Name) - Finish)
        
    End If
Next objName

'replace any links between sheets so that they're local
avLinks = wb.LinkSources(xlExcelLinks)

With ThisWorkbook
    On Error GoTo Endit
    .ChangeLink Name:= _
        owbname, newName:=wb.Name, Type:=xlExcelLinks
End With
    
Endit:
wb.Save
Application.ScreenUpdating = True

End Sub

Sub Macro14(control As IRibbonControl)
'opens userguide

Path1 = "\\zfa.com\" & ActiveWorkbook.Sheets("Dashboard").Range("C4").Value & _
"\Engineering\CalcSpreadsheets & Design Tables\Calc Spreadsheet Userguide.pdf"

ActiveWorkbook.FollowHyperlink Path1

End Sub

Sub Macro15(control As IRibbonControl)
'opens section divider userform

    Load InsertDivider
    InsertDivider.Show
    
End Sub

Sub Macro16(control As IRibbonControl)
'Opens dashboard updater

'Dashboard updater file path
VersionNumCell = "A2"
CurrentBook = ActiveWorkbook.Name
CurrentBookPath = ActiveWorkbook.Path & "\" & ActiveWorkbook.Name
DashUpdatePath = "\\zfa.com\" & Range("Office") & _
    "\Engineering\CalcSpreadsheets & Design Tables\Dashboard Ribbon Updater.xlsm"
VersionNumsTextFilePath = "\\zfa.com\" & Range("Office") & _
    "\Engineering\ZFA Committees\Spreadsheet Committee\In progress - FOR TESTING ONLY\Dashboard Versions.txt"
  
' Check current version and if dashboard has been updated before
CurrentVersionNum = Workbooks(CurrentBook).Sheets("Dashboard").Range(VersionNumCell).Value
If InStr(1, CurrentVersionNum, "Updated") > 0 Then
    CurrentVersionNum = Right(CurrentVersionNum, Len(CurrentVersionNum) - Len("Updated to") - InStr(1, CurrentVersionNum, "Updated"))
End If
CurrentVersionNum = Split(Split(CurrentVersionNum)(1), ".")(0) & "." & Split(Split(CurrentVersionNum)(1), ".")(1)

' Check new and in-progress dashboard versions
Open VersionNumsTextFilePath For Input As #1
Do Until EOF(1)
    Line Input #1, textline
    If textline = "ASCE 7:" Then
        Line Input #1, textline
        NewVersionNum = Split(textline, ".")(0) & "." & Split(textline, ".")(1)
    ElseIf textline = "ASCE 7 (In-Progress):" Then
        Line Input #1, textline
        InProgressVersionNum = Split(textline, ".")(0) & "." & Split(textline, ".")(1)
    End If
Loop
Close #1

If MsgBox("This Dashboard Version: " & CurrentVersionNum & Chr(13) & Chr(10) & _
        "Current Dashboard Version: " & NewVersionNum & Chr(13) & Chr(10) & _
        "Current Beta Dashboard Version: " & InProgressVersionNum & Chr(13) & Chr(10) & Chr(13) & Chr(10) & _
        "Would you like to update?", vbYesNo) = vbNo Then Exit Sub
        
If MsgBox("In order to update, the current file must be closed. Save and continue?", vbYesNo) = vbNo Then Exit Sub

'Close ribbon updater if it's already open for some reason, then open
On Error Resume Next
Workbooks("Dashboard Ribbon Updater.xlsm").Close SaveChanges:=False
Set DashUpdateBook = Workbooks.Open(DashUpdatePath)
On Error GoTo 0
DashUpdateBook.Sheets("Updater").Range("C17") = CurrentBookPath
Workbooks(CurrentBook).Close SaveChanges:=True

End Sub

Attribute VB_Name = "Header"
Attribute VB_Base = "0{A1CD6A42-BB99-442F-8B38-C912AA2FFC46}{5C8CBEB5-05D3-4366-9087-05F2E9053410}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Private Sub Cancel_Click()

Unload Me

End Sub

Private Sub Dte_Click()

If Me.Dte.Value = True Then
    Me.DteText.Enabled = True
    Me.DteText.BackColor = &H80000005
Else
    Me.DteText.Enabled = False
    Me.DteText.BackColor = &H80000004
End If

End Sub

Private Sub Eng_Click()

If Me.Eng.Value = True Then
    Me.EngText.Enabled = True
    Me.EngText.BackColor = &H80000005
Else
    Me.EngText.Enabled = False
    Me.EngText.BackColor = &H80000004
End If

End Sub

Private Sub Okay_Click()
Dim Flag, pgs, shtflag As Integer
Dim engineer, shtit, dteinp As String


If Me.ReplaceAll.Value = True Then
    Flag = 1
Else
    Flag = 0
End If

If Me.AddPgs.Value = True Then
    pgs = 1
Else
    pgs = 0
End If

If Me.Title.Value = True Then
    shtflag = 1
    shtit = Me.TitleText.Value
Else
    shtflag = 0
    shtit = "Oh hi!"
End If

If Me.Eng.Value = True Then
    engineer = "Engineer: " & Me.EngText.Value
Else
    engineer = "Engineer: " & [EngineerInitials]
End If

If Me.Dte.Value = True Then
    dteinp = Me.DteText.Value
Else
    dteinp = Date
End If


Call AddHeaders(dteinp, engineer, shtflag, shtit, Flag, pgs)

Unload Me

End Sub


Private Sub Title_Click()

If Me.Title.Value = True Then
    Me.TitleText.Enabled = True
    Me.TitleText.BackColor = &H80000005
Else
    Me.TitleText.Enabled = False
    Me.TitleText.BackColor = &H80000004
End If
    
End Sub


Private Sub UserForm_Click()

End Sub

Private Sub UserForm_Activate()
    With Me
        .Top = Int(((Application.Height / 2) + Application.Top) - (.Height / 2))
        .Left = Int(((Application.Width / 2) + Application.Left) - (.Width / 2))
    End With
End Sub
Attribute VB_Name = "InsertDivider"
Attribute VB_Base = "0{DEBDC17A-E0E9-48FF-BFEE-015B846580A6}{6871E622-9D76-4C40-9F5F-1792E420ADF7}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Private Sub InsertButton_Click()

    Dim ws As Worksheet
    actsheet = ActiveSheet.Name

    ' Exit sub if section name field is empty
    If Me.SectionName.Value = "" Then
        MsgBox "Please enter section name."
        Exit Sub
    End If
    
    ' Truncate name if too long
    SectName = Me.SectionName.Value
    If Me.TabName.Value = "" Then
        TbName = SectName
    Else:
        TbName = Me.TabName.Value
    End If
    
    TbName = "---" & Left(TbName, WorksheetFunction.Min(25, Len(TbName))) & "---"
    If Me.Dashes = True Then
        numDash = Int((31 - Len(TbName)) / 2)
        TbName = WorksheetFunction.Rept("-", numDash) & TbName & WorksheetFunction.Rept("-", 31 - Len(TbName) - numDash)
    End If

    ' Add section divider
    Application.ScreenUpdating = False
    If Me.BeforeButton.Value = True Then
        Set ws = ActiveWorkbook.Sheets.Add(before:=ActiveWorkbook.Sheets(actsheet))
    Else
        Set ws = ActiveWorkbook.Sheets.Add(after:=ActiveWorkbook.Sheets(actsheet))
    End If
    With ws.Tab
        .ThemeColor = xlThemeColorDark1
        .TintAndShade = -0.499984740745262
    End With
    
    ' Add textbox
    On Error GoTo ErrorHand
        With ws
            .Name = TbName
            .Activate
            .Cells.ColumnWidth = 8.14
            .Cells.RowHeight = 12.75
            .PageSetup.FitToPagesWide = 1
            .PageSetup.FitToPagesTall = 1
            
            If Me.Narrative = True Then
            .Shapes.AddTextbox(msoTextOrientationHorizontal, 23, 0, 425, 178).TextFrame.Characters.Text = SectName
            .Shapes.AddTextbox(msoTextOrientationHorizontal, 23, 191, 425, 472).TextFrame.Characters.Text = "Brief description of calc section"
                With .Shapes(1)
                    .Line.visible = msoFalse
                    .TextFrame.HorizontalAlignment = xlHAlignCenter
                    .TextFrame.VerticalAlignment = xlVAlignCenter
                    .Fill.visible = msoFalse
                    With .TextFrame.Characters.Font
                        If Me.Bold = True Then
                            .Bold = True
                        End If
                        If Me.Underline = True Then
                            .Underline = xlUnderlineStyleSingle
                        End If
                        .Name = "Arial"
                        .Size = 36
                    End With
                End With
                With .Shapes(2)
                    .Line.visible = msoTrue
                    .TextFrame.HorizontalAlignment = xlHAlignLeft
                    .TextFrame.VerticalAlignment = xlVAlignTop
                    .Fill.visible = msoTrue
                    With .TextFrame.Characters.Font
                        .Name = "Arial"
                        .Size = 11
                    End With
                End With
            Else
            .Shapes.AddTextbox(msoTextOrientationHorizontal, 23, 0, 425, 670).TextFrame.Characters.Text = SectName
                With .Shapes(1)
                    .Line.visible = msoFalse
                    .TextFrame.HorizontalAlignment = xlHAlignCenter
                    .TextFrame.VerticalAlignment = xlVAlignCenter
                    .Fill.visible = msoFalse
                    With .TextFrame.Characters.Font
                        If Me.Bold = True Then
                            .Bold = True
                        End If
                        If Me.Underline = True Then
                            .Underline = xlUnderlineStyleSingle
                        End If
                        .Name = "Arial"
                        .Size = 36
                    End With
                End With
            End If
            
            With ws.Range("L2")
                .Value = "Divider Type:"
                .Font.Name = "Arial"
                .HorizontalAlignment = xlRight
            End With
            
            With ws.Range("M2").Font
                .Name = "Arial"
                .Color = -16776961
            End With
            
            With ws.Range("M2").Validation
                .Delete
                .Add Type:=xlValidateList, AlertStyle:=xlValidAlertStop, Operator:= _
                xlBetween, Formula1:="Section, Subsection"
                .IgnoreBlank = True
                .InCellDropdown = True
                .InputTitle = ""
                .ErrorTitle = ""
                .InputMessage = ""
                .ErrorMessage = ""
                .ShowInput = True
                .ShowError = True
            End With
            
            If Me.SectionButton.Value = True Then
                ws.Range("M2").Value = "Section"
            Else:
                ws.Range("M2").Value = "Subsection"
            End If
            
            ws.Range("A1").Select
        End With
        
    ws.PageSetup.PrintArea = "$A$1:$J$53"
        
    Application.ScreenUpdating = True
    Unload Me
    Exit Sub
    
' This error handler will be triggered if the user has entered the name of a tab that already exists
ErrorHand:
    Application.DisplayAlerts = False
    ws.Delete
    Application.DisplayAlerts = True
    ActiveWorkbook.Sheets(actsheet).Activate
    MsgBox "This section divider already exits or an invalid character has been used. Please choose a different name."
    Application.ScreenUpdating = True
    Exit Sub
    

End Sub

Private Sub UserForm_Activate()
    With Me
        .Top = Int(((Application.Height / 2) + Application.Top) - (.Height / 2))
        .Left = Int(((Application.Width / 2) + Application.Left) - (.Width / 2))
    End With
End Sub

Private Sub CancelButton_Click()
Unload Me
End Sub
Attribute VB_Name = "ListPrinters"
Option Explicit
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' modListPrinters
' By Chip Pearson, chip@cpearson.com  www.cpearson.com
' Created 22-Sept-2012
' This provides a function named GetPrinterFullNames that
' returns a String array, each element of which is the name
' of a printer installed on the machine.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Const HKEY_CURRENT_USER As Long = &H80000001
Private Const HKCU = HKEY_CURRENT_USER
Private Const KEY_QUERY_VALUE = &H1&
Private Const ERROR_NO_MORE_ITEMS = 259&
Private Const ERROR_MORE_DATA = 234

Private Declare Function RegCloseKey Lib "advapi32.dll" ( _
    ByVal HKey As Long) As Long

Private Declare Function RegOpenKeyEx Lib "advapi32" _
    Alias "RegOpenKeyExA" ( _
    ByVal HKey As Long, _
    ByVal lpSubKey As String, _
    ByVal ulOptions As Long, _
    ByVal samDesired As Long, _
    phkResult As Long) As Long

Private Declare Function RegEnumValue Lib "advapi32.dll" _
    Alias "RegEnumValueA" ( _
    ByVal HKey As Long, _
    ByVal dwIndex As Long, _
    ByVal lpValueName As String, _
    lpcbValueName As Long, _
    ByVal lpReserved As Long, _
    lpType As Long, _
    lpData As Byte, _
    lpcbData As Long) As Long



Public Function GetPrinterFullNames() As String()
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' GetPrinterFullNames
' By Chip Pearson, chip@cpearson.com, www.cpearson.com
' Returns an array of printer names, where each printer name
' is the device name followed by the port name. The value can
' be used to assign a printer to the ActivePrinter property.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Dim Printers() As String ' array of names to be returned
Dim PNdx As Long    ' index into Printers()
Dim HKey As Long    ' registry key handle
Dim Res As Long     ' result of API calls
Dim Ndx As Long     ' index for RegEnumValue
Dim ValueName As String ' name of each value in the printer key
Dim ValueNameLen As Long    ' length of ValueName
Dim DataType As Long        ' registry value data type
Dim ValueValue() As Byte    ' byte array of registry value value
Dim ValueValueS As String   ' ValueValue converted to String
Dim CommaPos As Long        ' position of comma character in ValueValue
Dim ColonPos As Long        ' position of colon character in ValueValue
Dim M As Long               ' string index

' registry key in HCKU listing printers
Const PRINTER_KEY = "Software\Microsoft\Windows NT\CurrentVersion\Devices"

PNdx = 0
Ndx = 0
' assume printer name is less than 256 characters
ValueName = String$(256, Chr(0))
ValueNameLen = 255
' assume the port name is less than 1000 characters
ReDim ValueValue(0 To 999)
' assume there are less than 1000 printers installed
ReDim Printers(1 To 1000)

' open the key whose values enumerate installed printers
Res = RegOpenKeyEx(HKCU, PRINTER_KEY, 0&, _
    KEY_QUERY_VALUE, HKey)
' start enumeration loop of printers
Res = RegEnumValue(HKey, Ndx, ValueName, _
    ValueNameLen, 0&, DataType, ValueValue(0), 1000)
' loop until all values have been enumerated
Do Until Res = ERROR_NO_MORE_ITEMS
    M = InStr(1, ValueName, Chr(0))
    If M > 1 Then
        ' clean up the ValueName
        ValueName = Left(ValueName, M - 1)
    End If
    ' find position of a comma and colon in the port name
    CommaPos = InStr(1, ValueValue, ",")
    ColonPos = InStr(1, ValueValue, ":")
    ' ValueValue byte array to ValueValueS string
    On Error Resume Next
    ValueValueS = Mid(ValueValue, CommaPos + 1, ColonPos - CommaPos)
    On Error GoTo 0
    ' next slot in Printers
    PNdx = PNdx + 1
    Printers(PNdx) = ValueName & " on " & ValueValueS
    ' reset some variables
    ValueName = String(255, Chr(0))
    ValueNameLen = 255
    ReDim ValueValue(0 To 999)
    ValueValueS = vbNullString
    ' tell RegEnumValue to get the next registry value
    Ndx = Ndx + 1
    ' get the next printer
    Res = RegEnumValue(HKey, Ndx, ValueName, ValueNameLen, _
        0&, DataType, ValueValue(0), 1000)
    ' test for error
    If (Res <> 0) And (Res <> ERROR_MORE_DATA) Then
        Exit Do
    End If
Loop
' shrink Printers down to used size
ReDim Preserve Printers(1 To PNdx)
Res = RegCloseKey(HKey)
GetPrinterFullNames = Printers
End Function

Sub ShowPrinters()
    Dim strCount As String
    Dim strMsg As String
    Dim prtLoop As Printer
     
    On Error GoTo ShowPrinters_Err
 
    If Printers.count > 0 Then
        ' Get count of installed printers.
        strMsg = "Printers installed: " & Printers.count & vbCrLf & vbCrLf
     
        ' Enumerate printer system properties.
        For Each prtLoop In Application.Printers
            With prtLoop
                strMsg = strMsg _
                    & "Device name: " & .DeviceName & vbCrLf _
                    & "Driver name: " & .DriverName & vbCrLf _
                    & "Port: " & .Port & vbCrLf & vbCrLf
            End With
        Next prtLoop
     
    Else
        strMsg = "No printers are installed."
    End If
     
    ' Display printer information.
    MsgBox Prompt:=strMsg, Buttons:=vbOKOnly, Title:="Installed Printers"
     
ShowPrinters_End:
    Exit Sub
     
ShowPrinters_Err:
    MsgBox Prompt:=Err.Description, Buttons:=vbCritical & vbOKOnly, _
        Title:="Error Number " & Err.Number & " Occurred"
    Resume ShowPrinters_End
     
End Sub
Attribute VB_Name = "Main"
'Release 2.0, Date: April 1, 2016


Sub CopySheet(Template As String)
'
' this routine copies all worksheets from a template workbook into the main calc workbook

Dim wb As Workbook
Dim twb As Workbook
Dim ws As Worksheet
Dim Holdname() As String
Dim MyNames As Names
Dim x, n, k As Byte
Dim Sh, CL As String
Dim HName As String
Dim twbname As String
Dim SA As Shape


'no screen updating keeps from screen flicker
Application.ScreenUpdating = False
Application.DisplayAlerts = False

Set wb = ActiveWorkbook

'open template file to copy over
Workbooks.Open (Template)
Set twb = ActiveWorkbook
Set MyNames = ActiveWorkbook.Names
twbname = twb.Path & "\" & twb.Name


'count the number of names that need to be replaced in the template file
'weird issue with regression_int. it doesn't appear in the name manager but causes issues on
'import with some of the templates. so ignoring that as well as print area and print title
k = 0
For x = 1 To MyNames.count
    If (Right(MyNames(x).Name, 10) <> "Print_Area" And Right(MyNames(x).Name, 12) <> "Print_Titles" _
    And Right(MyNames(x).Name, 15) <> "_Regression_Int") _
    And InStr(MyNames(x).Name, "_xlfn") = 0 Then
        'wb.Sheets("Dashboard").Range("I24").Value = MyNames(x).Name
        k = k + 1
    End If
Next
    
'if there aren't any names besides ignored ones, jump to copying the sheets
'otherwise dimension the matrix to hold names and locations to right size
If (k = 0) Then GoTo CopyTime
ReDim Preserve Holdname(1 To 2, 1 To k)

'save the names and their locations in the template so once its copied over they can be replaced
n = 0
For x = 1 To MyNames.count
    If (Right(MyNames(x).Name, 10) <> "Print_Area" And Right(MyNames(x).Name, 12) <> "Print_Titles" _
    And Right(MyNames(x).Name, 15) <> "_Regression_Int") _
    And InStr(MyNames(x).Name, "_xlfn") = 0 Then
        n = n + 1
        Holdname(1, n) = MyNames(x).Name
        Holdname(2, n) = MyNames(x)
    End If
Next

CopyTime:
'copy over spreadsheets to master
For Each ws In twb.Worksheets
    ActiveSheet.Unprotect
    ws.Copy after:=wb.ActiveSheet
    
'problem with some pictures, this additional code is a band aid of sorts, seems to work alright now.
'concerned its a little glitchy when there are a lot of pictures, but can't find another work around
'found other workaround... but causes screen flashing. No problems with this yet, keeping it
    'SAnum = ws.Shapes.Count
    'For Each SA In ws.Shapes
       ' Sheets("Dashboard").Range("L24") = SA.Name
        'If Left(SA.Name, 7) = "Picture" Then
          '  SA.Copy
         '   ws.Pictures.Paste
       ' End If
    'Next

'add headers, user can update later if desired with button
engineer = "Engineer: " & [EngineerInitials]
Call AddHeaders(Date, engineer, 0, "hi", 0, 0)
    Application.PrintCommunication = False
    Application.PrintCommunication = True
    With ActiveSheet.PageSetup
        .ScaleWithDocHeaderFooter = False
        .AlignMarginsHeaderFooter = True
    End With
Next ws
            
'close template, don't save changes
'UPDATE: close after dashboard
'twb.Close False

'if no names to replace, skip this step
If (k = 0) Then GoTo LastStep

'determine where names are, delete local name and add global names
'originally deleted names before copying spreadsheet, but there was an issue with references then
'this seems to work well since it makes the names local when you copy a sheet in
For x = 1 To UBound(Holdname, 2)
    'find location where name is, annoying how excel saves them
    'sheet names have quotes around them if they are multiple words, but no quotes for one word
    l = Len(Holdname(2, x))
    SHlength = FindRightChar(Holdname(2, x))
    
    If Mid(Holdname(2, x), 2, 1) = "'" Then
        Sh = Right(Left(Holdname(2, x), SHlength - 2), SHlength - 4)
        CL = Right(Holdname(2, x), l - SHlength)
    Else
        Sh = Right(Left(Holdname(2, x), SHlength - 1), SHlength - 2)
        CL = Right(Holdname(2, x), l - SHlength)
    End If
    
    'Find name of cell either local or global to previous spreadsheet
    On Error GoTo ErrHandler:
    HNLength = Len(Holdname(1, x)) - FindRightChar(Holdname(1, x))
    HName = Right(Holdname(1, x), HNLength)
    wb.Sheets(Sh).Names(HName).Delete
    
    'replace cell on sheet with global name of calcs, change cell color to purple
    Sheets(Sh).Activate
    Range(CL).Select
    ActiveCell.FormulaR1C1 = "=" & HName
    ActiveCell.Font.ColorIndex = 13
Next

LastStep:
'replace any links between sheets so that they're local
avLinks = wb.LinkSources(xlExcelLinks)

With ThisWorkbook
    On Error GoTo Endit
    .ChangeLink Name:= _
        twbname, newName:=wb.Name, Type:=xlExcelLinks
End With
    twb.Names.Delete
    
Endit:

'hack to get around excel error with images. not too happy with....
'saves file then sets timer to reopen and closes it.
wb.Save
'+ TimeValue("00:00:02")
Application.OnTime Now, "OpenMe"
wb.Close

ErrHandler:
If Err.Number = 1004 Then
    MsgBox "There's been an error importing the template. This is likely caused by the template sheet having " & _
            "the same name as an existing sheet. Please rename the duplicate sheet in the calcs spreadsheet " & _
            "and try again. Any sheets with (2) after them will not have names copied properly and should be deleted.", _
            vbOKOnly
End If

End Sub

Private Sub OpenMe()
'code once reopens, close template file.

ActiveWorkbook.Close False
Application.DisplayAlerts = True

End Sub

Sub AddHeaders(dtein, engi, shtname, override, Flag, pgs)
Dim sheetname, job, proj As String
Dim SheetIndex, numsheets As Integer

'This macro adds the headers
'all the inputs come from the header userform
'I think this code might be a bit glitchy, if you try to run a macro immediately after adding
'headers the spreadsheet sometimes crashes. Not sure the glitch, but doesn't seem too problematic

'import Job number and project name, easy to reference names in vba
job = "Job #" & [JobNum]
On Error Resume Next
proj = [ProjNameShort]
If Err = 13 Then
    proj = [ProjectName]
End If

count = 0
'first section is for all worksheets, second section for one worksheet
If Flag = 1 Then
    numsheets = Sheets.count
    'Loop through each sheet, but don't set any of them to active
    For SheetIndex = 3 To numsheets
    
        'if there is a different name for the header than the sheetname
        If shtname = 1 Then
            sheetname = override
        Else
            sheetname = Sheets(SheetIndex).Name
            If Sheets(SheetIndex).Name = "----------Back Cover-----------" Then Exit Sub
        End If
        sheetname = Application.WorksheetFunction.Substitute(sheetname, "&", "&&") ' in headers, "&&" will appear as "&"
        
        'Adjust margins and add logo
        Application.PrintCommunication = True
        With Sheets(SheetIndex).PageSetup
            .ScaleWithDocHeaderFooter = False
            .AlignMarginsHeaderFooter = True
            .LeftMargin = Application.InchesToPoints(0.75)
            .RightMargin = Application.InchesToPoints(0.75)
            .TopMargin = Application.InchesToPoints(1.125)
            .BottomMargin = Application.InchesToPoints(0.75)
            .HeaderMargin = Application.InchesToPoints(0.375)
            .FooterMargin = Application.InchesToPoints(0.25)
            .LeftHeaderPicture.Filename = "\\zfa.com\" & Range("Office") & "\Engineering\CalcSpreadsheets & Design Tables\Logo for Dashboard\Logo2012_Xsmall_RGB.jpg"
            .LeftHeaderPicture.Width = 185
            .LeftHeader = "&""Arial,Regular""&G" & Chr(13) & job & Chr(13) & sheetname
            .CenterHeader = "&""Arial,Regular""" & Chr(13) & engi & Chr(13) & dtein
            .CenterFooter = ""
            .RightFooter = ""
            .LeftFooter = ""
            
        End With
        
        'if pgs is 1, add pg number. else no page numbers
        If pgs = 1 Then
            If Sheets(SheetIndex).Range("M2") <> "Section" And Sheets(SheetIndex).Range("M2") <> "Subsection" And Sheets(SheetIndex).visible = True Then
                Sheets(SheetIndex).PageSetup.RightHeader = "&""Arial,Regular""" & Chr(13) & proj & Chr(13) & "Page: " & (count) & "-" & "&P"
                count = count + 1
            Else
                Sheets(SheetIndex).PageSetup.RightHeader = "&""Arial,Regular""" & Chr(13) & proj & Chr(13)
            End If
        Else
            Sheets(SheetIndex).PageSetup.RightHeader = "&""Arial,Regular""" & Chr(13) & proj & Chr(13)
        End If
    
    Next
    
'else only one header, the active sheet
Else
    'if there is a different name for the header than the sheetname
    If shtname = 1 Then
        sheetname = override
    Else
        sheetname = ActiveSheet.Name
    End If
    sheetname = Application.WorksheetFunction.Substitute(sheetname, "&", "&&") ' in headers, "&&" will appear as "&"
    SheetIndex = ActiveSheet.Index
    
    'Adjust margins and add logo
    Application.PrintCommunication = True
    With Sheets(SheetIndex).PageSetup
        .ScaleWithDocHeaderFooter = False
        .AlignMarginsHeaderFooter = True
        .LeftMargin = Application.InchesToPoints(0.75)
        .RightMargin = Application.InchesToPoints(0.75)
        .TopMargin = Application.InchesToPoints(1.125)
        .BottomMargin = Application.InchesToPoints(0.75)
        .HeaderMargin = Application.InchesToPoints(0.375)
        .FooterMargin = Application.InchesToPoints(0.25)
        .LeftHeaderPicture.Filename = "\\zfa.com\" & Range("Office").Value & "\Engineering\CalcSpreadsheets & Design Tables\Logo for Dashboard\Logo2012_Xsmall_RGB.jpg"
        .LeftHeaderPicture.Width = 185
        .LeftHeader = "&""Arial,Regular""&G" & Chr(13) & job & Chr(13) & sheetname
        .CenterHeader = "&""Arial,Regular""" & Chr(13) & engi & Chr(13) & dtein
        .CenterFooter = ""
        .RightFooter = ""
        .LeftFooter = ""
        
    End With
        
    'if pgs is 1, add pg number. else no page numbers
    If pgs = 1 Then
        If Sheets(SheetIndex).Range("M2") = "Section" Or Sheets(SheetIndex).Range("M2") = "Subsection" Then
            ActiveSheet.PageSetup.RightHeader = "&""Arial,Regular""" & Chr(13) & proj & Chr(13)
        Else
            For I = 3 To SheetIndex
                If Sheets(I).Range("M2") <> "Section" And Sheets(I).Range("M2") <> "Subsection" And Sheets(I).visible = True Then count = count + 1
            Next
            ActiveSheet.PageSetup.RightHeader = "&""Arial,Regular""" & Chr(13) & proj & Chr(13) & "Page: " & (count - 1) & "-" & "&P"
        End If
    Else
        ActiveSheet.PageSetup.RightHeader = "&""Arial,Regular""" & Chr(13) & proj & Chr(13)
    End If
    
End If

End Sub


Sub PrintToPDFCode(PrintAllFlag, BWFlag)

 'Print to PDF Macro
    'Struggled to print to one pdf, so each tab is printed to an individual pdf
    'pdfs can then be stapled using bluebeam
    'seemed like a good method, that way other calcs can be added as well
    'to keep them ordered, their section number is first in the pdf title

    Dim ws As Worksheet
    Dim Fname As String
    Dim numsheets As Integer
    Dim SheetIndex As Integer
    Dim wb As Workbook
    
    Application.ScreenUpdating = False
    If PrintAllFlag = 0 And ActiveSheet.Name = "Dashboard" Then Exit Sub
    
    ' Due to some excel bug, if a PDF-type printer is selected when saving as PDF (not printing as PDF)
    ' there are issues with the resulting page size (e.g. 8.5" x 11" actually outputs as ~10" x 14").
    ' This code switches the current printer to a local in-office printer if needed before running the
    ' "Print to PDFs" macro.
    
    ' Store currently selected printer
    CurrentServer = Left(Environ$("COMPUTERNAME"), InStr(1, Environ$("COMPUTERNAME"), "-") - 1)
    CurrentPrinter = Application.ActivePrinter
    PrinterFlag = InStr(1, UCase(Printer), CurrentServer & "SERVER") <> 0
    PrinterChanged = False

    ' If current printer is not on current server, find one that is
    If PrinterFlag = False Then
        Printers = GetPrinterFullNames()
        For Each Printer In Printers
            If InStr(1, UCase(Printer), CurrentServer & "SERVER") <> 0 Then
                ' just in case, check if there is an error when trying to connect to the printer. if so, keep trying printers
                On Error Resume Next
                Application.ActivePrinter = Printer
                If Err.Number = 0 Then
                    PrinterChanged = True
                    Exit For
                End If
                On Error GoTo 0
            End If
        Next
        
        ' Have the user select a printer if no printer was found
        If Not PrinterChanged Then
            MsgBox "Please select a REAL printer (i.e. not a PDF-type printer) that is in your office, that you typically use, and is currently working." & vbCrLf & vbCrLf & _
            "Your calculations will still print as PDF and will NOT print out of the printer that you select. This is required to circumvent a bug that exists in Microsoft Excel 2010."
            Application.Dialogs(xlDialogPrinterSetup).Show
        End If
    End If
    On Error GoTo 0
    

    'setup for saving to pdfs
    Path1 = ActiveWorkbook.Path & "\Calc Set PDFs"
    If Len(Dir(Path1, vbDirectory)) = 0 Then
        MkDir Path1
    End If
    numsheets = Sheets.count
    Set wb = ActiveWorkbook
    
    ' Establish sheet save names
    Dim FileNames() As String
    Dim SheetNames() As String
    TotalSheets = 0
    SheetIndex = 0
    Set OrigSheet = ActiveWorkbook.ActiveSheet

    For Each ws In ActiveWorkbook.Sheets
        
        ' Only check visible sheets (not including the dashboard)
        If ws.Name <> "Dashboard" And ws.visible = xlSheetVisible Then
            
            If ws.Name <> "Calc Cover" And ws.Name <> "TOC" Then
                SheetIndex = SheetIndex + 1
            End If
        
            ' Check that sheet is one of the selected sheets
            On Error Resume Next
            x = ActiveWindow.SelectedSheets(ws.Name).Name
            
            ' No error if sheet is selected. Save file name
            If Err.Number <> 9 Or PrintAllFlag = 1 Then
                
                ReDim Preserve FileNames(TotalSheets)
                ReDim Preserve SheetNames(TotalSheets)
                SheetNames(TotalSheets) = ws.Name
                
                ' First few sections get 0, matches table of contents section numbers
                If ws.Name = "Calc Cover" Or ws.Name = "TOC" Then
                    FileNames(TotalSheets) = Path1 & "\" & "0" & "_" & ws.Name
                Else
                    FileNames(TotalSheets) = Path1 & "\" & SheetIndex & "_" & ws.Name
                End If
                
                TotalSheets = TotalSheets + 1
                
            End If
            
            On Error GoTo 0
            If ws.Name = "----------Back Cover-----------" And PrintAllFlag = 1 Then Exit For
            
        End If
    Next ws
    
    
    ' Begin process of saving sheets as PDF. Must have single sheet selected to print properly
    OrigSheet.Select
    SheetCount = 0
    Call UpdateStatusBar(SheetCount, TotalSheets, "Sheets")
    For Each nm In SheetNames
        
        Set ws = ActiveWorkbook.Sheets(nm)
            
        'Switch to black and white
        If BWFlag = 1 Then
            ws.PageSetup.BlackAndWhite = True
        End If
    
        ' Use save as pdf feature. after trying a couple different ways this seemed
        ' like best options. printing (rather than saving) to pdf via vba had bugs
        On Error Resume Next
        ws.ExportAsFixedFormat Type:=xlTypePDF, Filename:= _
            FileNames(SheetCount), Quality:=xlQualityStandard _
            , IncludeDocProperties:=True, IgnorePrintAreas:=False, OpenAfterPublish:= _
            False
        If Err.Number <> 0 Then
            MsgBox nm + ".pdf can not be created. The sheet may already be open or possess a name with invalid characters. This sheet will be skipped. Please close or rename the PDF and retry."
        End If
    
        'Update status bar
        SheetCount = SheetCount + 1
        Call UpdateStatusBar(SheetCount, TotalSheets, "Sheets")
    
        'Switch back to color
        If BWFlag = 1 Then
            ws.PageSetup.BlackAndWhite = False
        End If
                
        On Error GoTo 0
        If ws.Name = "----------Back Cover-----------" Then Exit For
            
nextws:
    Next


' Switch back to original printer
EndofMacro:
    Call ClearStatusBar
    Application.ScreenUpdating = True
    If PrinterFlag = False Then
        Application.ActivePrinter = CurrentPrinter
    End If

End Sub


Sub ImportDashboard()

Application.ScreenUpdating = False

Dim currentWorkbook As Workbook
Set currentWorkbook = Workbooks(ActiveWorkbook.Name)

' File selection dialog
Dim fd As Office.FileDialog
Set fd = Application.FileDialog(msoFileDialogFilePicker)
With fd
    .AllowMultiSelect = False
    .Title = "Select Dashboard to Import:"
    .Filters.Clear
    .Filters.Add "Excel", "*.xls; *.xlsx; *.xlsm"
    .Show
    On Error GoTo endofsub
    Filename = .SelectedItems(1)
End With

Workbooks.Open Filename:=Filename, ReadOnly:=True
Dim importDash As Workbook
Set importDash = Workbooks(ActiveWorkbook.Name)

' Import dashboard
importDash.Sheets("Dashboard").Copy after:=currentWorkbook.Sheets(currentWorkbook.Sheets.count)
importDash.Close SaveChanges:=False
currentWorkbook.ActiveSheet.Name = "ImportedDashboard"
currentWorkbook.Sheets("Dashboard").Name = "OldDashboard"

' Delete named ranges from imported dashboard
For Each nm In currentWorkbook.Names
    If InStr(nm, "ImportedDashboard") <> 0 Then
        nm.Delete
    End If
Next nm

' Relink named ranges from existing dashboard to the imported dashboard
For Each nm In currentWorkbook.Names
    If InStr(nm, "OldDashboard") <> 0 Then
        nm.RefersTo = Application.WorksheetFunction.Substitute(nm, "OldDashboard", "'ImportedDashboard'")
    End If
Next nm

' Relink external references to current workbook
Links = currentWorkbook.LinkSources(xlExcelLinks)
For Each link In Links
    currentWorkbook.ChangeLink Name:=link, newName:=currentWorkbook.Name, Type:=xlExcelLinks
Next link

' Relink other cells that do not reference named ranges
For Each ws In Worksheets
    ws.Cells.Replace What:="OldDashboard", Replacement:="'ImportedDashboard'", _
    LookAt:=xlPart, MatchCase:=False
Next

' Delete old dashboard
Application.DisplayAlerts = False
currentWorkbook.Sheets("ImportedDashboard").Move before:=currentWorkbook.Sheets("OldDashboard")
currentWorkbook.Sheets("OldDashboard").Delete
currentWorkbook.Sheets("ImportedDashboard").Name = "Dashboard"
Application.DisplayAlerts = True

endofsub:
Application.ScreenUpdating = True

End Sub


Sub ChangeNewSheetTemplateFile()
    ' This macro will replace the file that is loaded whenever adding a new blank sheet with
    ' the ZFA template file

    Dim fso As Object
    Set fso = VBA.CreateObject("Scripting.FileSystemObject")
    
    TemplateSheetSourceFile = "\\zfa.com\" & Range("Office").Value & "\Engineering\CalcSpreadsheets & Design Tables\Sheet.xltx"
    UserStartupPath = Application.StartupPath
    TemplateSheetDestFile = UserStartupPath & "\Sheet.xltx"
    
    Call fso.CopyFile(TemplateSheetSourceFile, TemplateSheetDestFile, True)
    
End Sub
Attribute VB_Name = "PrintToPDF"
Attribute VB_Base = "0{C88A10E9-FEED-4BC8-B0E6-A44401FD62B3}{8F56B66D-FD7E-4E64-ADFF-24CBC5A58A07}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Private Sub NormalViewButton_Click()

'switch all sheets to normal view
ActiveSht = ActiveWorkbook.ActiveSheet.Name

Application.ScreenUpdating = False

For Each Sheet In ActiveWorkbook.Sheets
    Sheet.Activate
    SendKeys "^{HOME}"
    ActiveWindow.View = xlNormalView
    ActiveWindow.Zoom = 100
Next Sheet

ActiveWorkbook.Sheets(ActiveSht).Activate
Application.ScreenUpdating = True
Unload Me

End Sub

Private Sub PreviewViewButton_Click()

'switch all sheets to normal view
ActiveSht = ActiveWorkbook.ActiveSheet.Name

Application.ScreenUpdating = False

For Each Sheet In ActiveWorkbook.Sheets
    Sheet.Activate
    SendKeys "^{HOME}"
    ActiveWindow.View = xlPageBreakPreview
    ActiveWindow.Zoom = 80
Next Sheet

ActiveWorkbook.Sheets(ActiveSht).Activate
Application.ScreenUpdating = True
Unload Me

End Sub

Private Sub PrintButton_Click()

'print all or print one flag
If Me.PrintAll.Value = True Then
    printFlag = 1
Else
    printFlag = 0
End If

'print in black and white flag
If Me.BlackWhite.Value = True Then
    BWFlag = 1
Else
    BWFlag = 0
End If

Call PrintToPDFCode(printFlag, BWFlag)

Unload Me

End Sub

Private Sub CancelButton_Click()

Unload Me

End Sub


Private Sub UserForm_Activate()
    With Me
        .Top = Int(((Application.Height / 2) + Application.Top) - (.Height / 2))
        .Left = Int(((Application.Width / 2) + Application.Left) - (.Width / 2))
    End With
End Sub
Attribute VB_Name = "RibbonModule"
Option Explicit
'this is all code from the website I found the ribbion tutorial on.
'this all loads the ZFA Calcs ribbon
'http://www.rondebruin.nl/win/s2/win001.htm

Dim Rib As IRibbonUI
Public MyTag As String

'Callback for customUI.onLoad
Sub RibbonOnLoad(ribbon As IRibbonUI)
    Set Rib = ribbon
End Sub

Sub GetVisible(control As IRibbonControl, ByRef visible)
    If MyTag = "show" Then
        visible = True
    Else
        If control.Tag Like MyTag Then
            visible = True
        Else
            visible = False
        End If
    End If
End Sub

Sub RefreshRibbon(Tag As String)
    MyTag = Tag
    If Rib Is Nothing Then
        MsgBox "Error, Save/Restart your workbook"
    Else
        Rib.Invalidate
    End If
End Sub

'Note: Do not change the code above


'**********************************************************************************
'Examples to show only the Tab you want with getVisible and tag in the RibbonX.
'**********************************************************************************

'Sub DisplayRibbonTab()
'Show only the Tab, Group or Control with the Tag "MyPersonalTab"
'    Call RefreshRibbon(Tag:="MyPersonalTab")
'End Sub


'Note: in this example every macro above will show you the custom tab.
'If you add more custom tabs this will be different

'Sub HideEveryTab()
'Hide every Tab, Group or Control(we use Tag:="")
'    Call RefreshRibbon(Tag:="")
'End Sub

Attribute VB_Name = "Sheet5"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet8"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet9"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "StatusBar"
Sub UpdateStatusBar(ByVal CurrentStep As Double, ByVal TotalSteps As Double, ByVal ItemName As String)

    'Sub to show progress in the status bar
    'CurrentStep = current progress step
    'TotalSteps = total number of steps
    'Item Name = label of items being iterated through (e.g. "Sheets", "Pages", "Steps")

    'Info for status bar
    StatusBarLength = 40

    'Update status bar
    Progress = Int(CurrentStep / TotalSteps * StatusBarLength)
    StatusBarText = ChrW(9609) & String(Progress, ChrW(9609)) & String(StatusBarLength - Progress, ChrW(9617)) & "  Progress: " & CurrentStep & " of " & TotalSteps & " " & ItemName & ": " & Format(CurrentStep / TotalSteps, "0%")
    Application.StatusBar = StatusBarText
    
    'Clear statusbar
    If CurrentStep >= TotalSteps Then
        Application.Wait (Now + TimeValue("00:00:01"))
        Call ClearStatusBar
    End If

End Sub

Sub ClearStatusBar()

    'Sub used to clear the status bar
    Application.StatusBar = False

End Sub

Attribute VB_Name = "Subroutines"
' first two functions are mine, the rest are from templates. If

Function FindRightChar(MyString)
Dim I, RetVal

RetVal = 0
For I = Len(MyString) To 1 Step -1
    If Mid(MyString, I, 1) = "!" Then
        RetVal = I
        Exit For
    End If
Next I

FindRightChar = RetVal
End Function

Function FindExtension(MyString)
Dim I, RetVal

For I = Len(MyString) To 0 Step -1
If Mid(MyString, I, 1) = "." Then
RetVal = I
Exit For
End If
Next I

FindExtension = RetVal
End Function
Function Mu_max(Mua, h, Pu, Ec, Icr)
'Mu is the Ultimate moment without P delta (in *lb)
'h is the unbraced height of the wall (in)
'Pu id the ultimate factored axial force (lbs)
'Ec is the concrete modulus of elasticity (ksi)
'Icr id the cracked moment of inertia


Delta = 0
n = 1

Do While n < 10

Mu1 = Mua + Pu * Delta

Delta = (5 * Mu1 * h ^ 2) / (0.75 * 48 * Ec * 1000 * Icr)

n = n + 1

Loop


Mu_max = Mu1


End Function
Function Deltau_max(Mua, h, Pu, Ec, Icr)
'Mu is the Ultimate moment without P delta (in *lb)
'h is the unbraced height of the wall (in)
'Pu id the ultimate factored axial force (lbs)
'Ec is the concrete modulus of elasticity (ksi)
'Icr id the cracked moment of inertia


Delta = 0
n = 1

Do While n < 10

Mu1 = Mua + Pu * Delta


Delta = (5 * Mu1 * h ^ 2) / (0.75 * 48 * Ec * 1000 * Icr)


n = n + 1

Loop


Deltau_max = Delta


End Function
Function Ms_max(Msa, h, P, Ec, Ig, Icr, Mcr)
'Msa is the service moment without P delta in *lb
'h is the unbraced height of the wall
'P is the service axial force
'Ec is the concrete modulus of elasticity
'Ig is the gross moment of inertia
'Icr is the cracked moment of inertia
'Mcr is the cracked moment
'Add 0.000001 to Ms to avoid dividing by o


Ms = Msa + 0.000001

n = 1

Do While n < 10

Ie = (Mcr / Ms) ^ 3 * Ig + (1 - (Mcr / Ms) ^ 3) * Icr


If Ie < Ig Then

Ie = Ie

Else

Ie = Ig

End If

Ms = (Msa + 0.000001) / (1 - (5 * P * h ^ 2 / (48 * Ec * 1000 * Ie)))

n = n + 1

Loop

Ms_max = Ms

End Function
Function Ieffective(Msa, h, P, Ec, Ig, Icr, Mcr)
'Msa is the service moment without P delta in *lb
'h is the unbraced height of the wall
'P id the service axial force
'Ec is the concrete modulus of elasticity
'Ig id the gross moment of inertia
'Icr is the cracked moment of inertia
'Mcr is the cracked moment
'Add 0.000001 to Ms to avoid dividing by o


Ms = Msa + 0.000001

n = 1

Do While n < 10

Ie = (Mcr / Ms) ^ 3 * Ig + (1 - (Mcr / Ms) ^ 3) * Icr

If Ie < Ig Then

Ie = Ie

Else

Ie = Ig

End If

Ms = (Msa + 0.000001) / (1 - (5 * P * h ^ 2 / (48 * Ec * 1000 * Ie)))

n = n + 1

Loop

Ieffective = Ie

End Function

Function Deltas_max(Msa, h, P, Ec, Ig, Icr, Mcr)
'Msa is the service moment without P delta in *lb
'h is the unbraced height of the wall
'P id the service axial force
'Ec is the concrete modulus of elasticity
'Ig id the gross moment of inertia
'Icr is the cracked moment of inertia
'Mcr is the cracked moment
'Add 0.000001 to Ms to avoid dividing by o


Ms = Msa + 0.000001

n = 1

Do While n < 10

Ie = (Mcr / Ms) ^ 3 * Ig + (1 - (Mcr / Ms) ^ 3) * Icr

If Ie < Ig Then

Ie = Ie

Else

Ie = Ig

End If

Ms = (Msa + 0.000001) / (1 - (5 * P * h ^ 2 / (48 * Ec * 1000 * Ie)))

n = n + 1

Loop

Deltas_max = 5 * Ms * h ^ 2 / (48 * Ec * 1000 * Ie)


End Function
Function Non_Constrained_Depth(Dia, h, P, Sbrg)
'This function finds the pier depth per section 1805.7.2 EQ 18-1

x = 1
D = 1

Do While x < 500

S1 = Sbrg * D / 3

a = 2.34 * P / (S1 * Dia)

D = 0.5 * a * (1 + Sqr(1 + (4.36 * h / a)))

x = x + 1

Loop

Non_Constrained_Depth = D

End Function

Function Constrained_Depth(Dia, h, P, Sbrg)
'This function finds the pier depth per section 1805.7.2 EQ 18-2

x = 1
D = 1

Do While x < 500

S3 = Sbrg * D

D = Sqr(4.25 * P * h / (S3 * Dia))

x = x + 1

Loop

Constrained_Depth = D

End Function

Function Soil_Bearing(P, M, b, l)
'this function determines the maximum bearing pressure on a footing with moment
'it checks of full and partial bearing assuming a triangular distribution
'P = axial force, M = moment, B is footing dimeinsion parallel with moment, L is footing dimesnion perp. to moment

E = M / P
x = E / b
I = b * l ^ 3 / 12
a = b * l

If x <= 0.1667 Then

Soil_Bearing = P / a + M * b * 0.5 / I

Else

Soil_Bearing = 2 * P / ((b * 0.5 - E) * 3) / l


End If


End Function

Function Mn_CMU(Ast, b, D, fm, Fy)
'this function determines moment capacity of CMU section

a = Ast * Fy / (0.8 * fm * b)

Mn_CMU = Ast * Fy * (D - a / 2)

End Function

Function Mn_Conc(Ast, b, D, fc, Fy)
'this function determines moment capacity of Concrete section

a = Ast * Fy / (0.85 * fc * b)

Mn_Conc = Ast * Fy * (D - a / 2)

End Function

Function Feet_Inches(FeetIn As Double)
    ' This function will change a decimal number of feet to the text string
    ' representation of feet, inches, and fractional inches.
    ' It will round the fractional inches to the nearest 1/x where x is the denominator.
    ' Copyright 1999 MrExcel.com
    Denominator = 2 ' must be 2, 4, 8, 16, 32, 64, 128, etc.
    NbrFeet = Fix(FeetIn)
    InchIn = (FeetIn - NbrFeet) * 12
    NbrInches = Fix(InchIn)
    FracIn = (InchIn - NbrInches) * Denominator
    Numerator = Application.WorksheetFunction.Round(FracIn, 0)
    If Numerator = 0 Then
        FracText = ""
    ElseIf InchIn >= (11 + (31.4999999 / 32)) Then
        NbrFeet = NbrFeet + 1
        NbrInches = 0
        FracText = ""
    ElseIf Numerator = Denominator Then
        NbrInches = NbrInches + 1
        FracText = ""
    Else
        Do
            ' If the numerator is even, divide both numerator and divisor by 2
            If Numerator = Application.WorksheetFunction.Even(Numerator) Then
                Numerator = Numerator / 2
                Denominator = Denominator / 2
            Else
                FracText = " " & Numerator & "/" & Denominator
                Exit Do
            End If
        Loop
    End If
    Feet_Inches = NbrFeet & "' - " & NbrInches & FracText & """"
End Function

Function Mn_masonry(fm, Fy, D, area_steel, b)

Mn_masonry = Fy * area_steel * (D - (Fy * area_steel) / (1.6 * fm * b))

End Function

Function Fcr(l, r, Fy, E)
'this function determines flexural buckling stress per section E3
'of the Steel Construction Manual; 13th edition
'Refer to section B4 for applicable sections


KL_r = 1.2 * l / r

Fe = 9.8696 * E / (KL_r ^ 2)

slender = 4.71 * Sqr(E / Fy)

If KL_r > slender Then

Fcr = 0.887 * Fe

Else

Fcr = 0.9 * (0.658 ^ (Fy / Fe)) * Fy

End If

End Function

Function DCFA(Mr, Mc, Pr, Pc)
'this function determines interaction ratio of flexure and axial per section H1
'of the Steel Construction Manual; 13th edition
'This apples to ASD applications; DCFA : demand/capcity for
'flexure and axial forces; r represents required and c represents capacity

If Pr / Pc < 0.2 Then

DCFA = (Pr * 0.5 / Pc) + (Mr / Mc)

Else

DCFA = (Pr / Pc) + (8 / 9) * (Mr / Mc)

End If

End Function

Function CompactWebh_t(E, Fy, Pu, a, phiB)
'Only applies if Pu is compression
If Pu <= 0 Then Puse = 0 Else Puse = Pu
Py = a * Fy
Select Case Pu / (phiB * Py)
    Case Is <= 0.125
        CompactWebh_t = 3.76 * Sqr(E / Fy) * (1 - 2.75 * Puse / (phiB * Py))
    Case Is > 0.125
        WCompactWebh_t = 1.12 * Sqr(E / Fy) * (2.33 - Puse / (phiB * Py))
        If CompactWebh_t < 1.49 * Sqr(E / Fy) Then CompactWebh_t = 1.49 * Sqr(E / Fy)
End Select
End Function
Function NonCompactWebh_t(E, Fy, Pu, a, phiB)
'Only applies if Pu is compression
If Pu <= 0 Then Puse = 0 Else Puse = Pu
Py = a * Fy
NonCompactWebh_t = 5.7 * Sqr(E / Fy) * (1 - 0.74 * Puse / (phiB * Py))
End Function
Function Fcritical(LambdaC, Fy, Q, Klr, Ix, Iy, G, J, Cw, E)
Select Case LambdaC * Sqr(Q)
    Case Is <= 1.5
        Power = Q * LambdaC ^ 2
        Fcritical1 = Q * Fy * 0.658 ^ Power
    Case Is > 1.5
        Fcritical1 = Fy * 0.877 / LambdaC ^ 2
End Select
'Check Torsional Buckling Appendix E3
'Assume Kz and Lz same as max Kx,Ky and Lx,Ly
Fe = ((pi# ^ 2 * E * Cw / Klr ^ 2) + G * J) * (1 / (Ix + Iy))
LambdaE = Sqr(Fy / Fe)
Select Case LambdaE * Sqr(Q)
    Case Is <= 1.5
        Power = Q * LambdaE ^ 2
        Fcritical2 = Q * Fy * 0.658 ^ Power
    Case Is > 1.5
        Fcritical2 = Fy * 0.877 / LambdaE ^ 2
End Select
Fcritical = Fcritical1
If Fcritical2 < Fcritical1 Then Fcritical = Fcritical2
End Function
Function CalcQs(b_t, E, Fy)
Select Case b_t
    Case Is < 0.56 * Sqr(E / Fy)
        CalcQs = 1#
    Case 0.56 * Sqr(E / Fy) To 1.03 * Sqr(E / Fy)
        CalcQs = 1.415 - 0.74 * b_t * Sqr(E / Fy)
    Case Is >= 1.03 * Sqr(E / Fy)
        CalcQs = 0.69 * E / (Fy * b_t ^ 2)
End Select
End Function
Function CalcQa(h_t, E, fa, a, D, Kfillet, Tf, Tw)
h = h_t * Tw
If fa = 0 Then
    CalcQa = 1
Else
        Select Case h_t
            Case Is < 1.49 * Sqr(E / fa)
                CalcQa = 1
            Case Is >= 1.49 * Sqr(E / fa)
                he = 1.91 * Tw * Sqr(E / fa) * (1 - (0.34 / h_t) * Sqr(E / fa))
                CalcQa = (a - (h - he) * Tw) / a
        End Select
End If
End Function
Function Class(S, CompactLimit, NonCompactLimit)
Select Case S
    Case Is <= CompactLimit
        Class = "Compact"
    Case Is > NonCompactLimit
        Class = "Slender"
    Case Else
        Class = "Non-Compact"
End Select
End Function
Function MnxLTB(Cb, l, Lr, Lp, Mp, Mr, X1, X2, Sx)
'Check Lateral Torsional Buckling
Select Case l
    Case Is <= Lp
        MnxLTB = Mp
    Case Lp To Lr
        MnxLTB = Cb * (Mp - (Mp - Mr) * (l - Lp) / (Lr - Lp))
    Case Is > Lr
        Fcri = (Cb * X1 * Sqr(2) / l) * Sqr(1 + X1 ^ 2 * X2 / (2 * l ^ 2))
        MnxLTB = Fcri * Sx / 12
End Select
End Function
Function MnxFLB(l, Lr, Lp, Mp, Mr, E, Sx)
Select Case l
    Case Is <= Lp
        MnxFLB = Mp
    Case Lp To Lr
        MnxFLB = Mp - (Mp - Mr) * (l - Lp) / (Lr - Lp)
    Case Is > Lr
        Fcri = 0.69 * E / l ^ 2
        MnxFLB = Fcri * Sx / 12
End Select
End Function
Function MnxWLB(l, Lr, Lp, Mp, Mr, E, RPG, Fcr, Sx)
Select Case l
    Case Is <= Lp
        MnxWLB = Mp
    Case Lp To Lr
        MnxWLB = (Mp - (Mp - Mr) * (l - Lp) / (Lr - Lp))
    Case Is > Lr
        'Critical Stress dependent on two cases
        MnxWLB = RPG * Fcr * Sx / 12
End Select
End Function
Function MnyFLB(l, Lr, Lp, Mp, Mr, E, Sy)
'Check Lateral Torsional Buckling
Select Case l
    Case Is <= Lp
        MnyFLB = Mp
    Case Lp To Lr
        MnyFLB = Mp - (Mp - Mr) * (l - Lp) / (Lr - Lp)
    Case Is > Lr
        Fcri = 0.69 * E / l ^ 2
        MnyFLB = Fcri * Sy / 12
End Select
End Function
Function CalcRPG(E, Fy, h_t, Tf, Bf, D, Tw, FcrCompFlg)
Af = Bf * Tf
Aw = (D - 2 * Tf) * Tw
Ar = Aw / Af
If Ar > 10 Then Ar = 10
Re = 1 'for non-hybrid
CalcRPG = 1 - (Ar / (1200 + 300 * Ar)) * (h_t - 5.7 * Sqr(E / FcrCompFlg))
If CalcRPG > 1 Then CalcRPG = 1
End Function
Function FcrCompFlgLTB(Cb, Lb, Rt, E, Fy)
n = 12 * Lb / Rt
Np = 1.76 * Sqr(E / Fy)
Nr = 4.44 * Sqr(E / Fy)
CPG = 286000 * Cb
Select Case n
    Case Is <= Np
        FcrCompFlgLTB = Fy
    Case Np To Nr
        FcrCompFlgLTB = Cb * Fy * (1 - (n - Np) / (2 * (Nr - Np)))
        If FcrCompFlgLTB > Fy Then FcrCompFlgLTB = Fy
    Case Is > Lr
        FcrCompFlgLTB = CPG / n ^ 2
End Select
End Function
Function FcrCompFlgFLB(b_t, h_t, Cb, Lb, Rt, E, Fy)
n = b_t
Np = 0.38 * Sqr(E / Fy)
Kc = 4 / Sqr(h_t)
If Kc < 0.35 Then Kc = 0.35
If Kc > 0.763 Then Kc = 0.763
Nr = 1.35 * Sqr(E / (Fy / Kc))
CPG = 26200 * Kc
Select Case n
    Case Is <= Np
        FcrCompFlgFLB = Fy
    Case Np To Nr
        FcrCompFlgFLB = Cb * Fy * (1 - (n - Np) / (2 * (Nr - Np)))
        If FcrCompFlgFLB > Fy Then FcrCompFlgFLB = Fy
    Case Is > Lr
        FcrCompFlgFLB = CPG / n ^ 2
End Select
End Function
Function Shear(h_t, D, Tw, Fy, E)
Select Case h_t
    Case Is <= 2.45 * Sqr(E / Fy)
        Vn = 0.6 * Fy * D * Tw
    Case 2.45 * Sqr(E / Fy) To 3.07 * Sqr(E / Fy)
        Vn = 0.6 * Fy * D * Tw * 2.45 * Sqr(E / Fy) / h_t
    Case Is > 3.07 * Sqr(E / Fy)
        Vn = D * Tw * 4.52 * E / h_t ^ 2
End Select
Shear = Vn
End Function

Function delta_pw(w, x, a, l, E, I)
'this function is to determine the maximum deflection from a partially distributed load
'The maximum deflection occurs at x, x must be less than a. The equation is given in AISC 13th ED Table 3-23 diagram 5


delta_pw = ((w * x) / (24 * E * I * l)) * (a ^ 2 * (2 * l - a) ^ 2 - 2 * a * x ^ 2 * (2 * l - a) + l * x ^ 3)


End Function
Function delta_cpap(P, a, b, l, E, I)
'this function is to determine the maximum deflection from a concentrated load at any point
'The maximum deflection occurs at the point load. The equation is given in AISC 13th ED Table 3-23 diagram 8


delta_cpap = (P * a * b * (a + 2 * b) * Sqr(3 * a * (a + 2 * b))) / (27 * E * I * l)


End Function
Function Msimple(w1, w2, P, a, l)
'Maximum moment of a simple span with cantilever at cantilver. With a different load on the simple span and cantilever and a point load on the end.
'Uses equations from #25, 26 and 27 from Table 3-23 of 13th edition steel manual
'Units: Loads and dimensions are in pounds and feet

 Mold = 0
 Mnew = 1
 x = 1
 
 
 Do While Mold < Mnew

 
 Mold = Mnew
 Mnew = w1 * x * 0.5 * (l - x) - w2 * a ^ 2 * x * 0.5 / l - P * a * x / l
 
 x = x + 1
 
 Loop
 
 Msimple = Mold

End Function
Function Delta_simple(w1, w2, P, a, l, E, I)
'deflection of a simple span with cantilever at cantilver w/ load to cantilever and simple span # 24 of Table 3-23 of 13th edition steel manual
 Dold = 0
 Dnew = 0.001
 x = 2

 Do While Abs(Dold) < Abs(Dnew)
 Dold = Dnew
 Dnew = (w1 * 0.0833 * x * 12 / (24 * E * I)) * ((l * 12) ^ 3 - 2 * l * 12 * (x * 12) ^ 2 + (x * 12) ^ 3) - ((w2 * 0.0833 * (a * 12) ^ 2 * x * 12) / (12 * E * I * l * 12)) * ((l * 12) ^ 2 - (x * 12) ^ 2) - (P * a * x * 144 / (6 * E * I * l * 12)) * ((l * 12) ^ 2 - (x * 12) ^ 2)
 
 
 x = x + 0.1
 Loop
 
 Delta_simple = Dnew

End Function

Function Delta_cant(w1, w2, a, l, P, E, I)
'deflection of a simple span with cantilever at end of cantilver w/ load to cantilever
'Units: Loads and dimensions are pounds and feet; properties are pounds and inches
 
 Delta_cant = -w1 * 0.0833 * (l * 12) ^ 3 * a * 12 / (24 * E * I) + (w2 * 0.0833 * a * 12 / (24 * E * I)) * (4 * (a * 12) ^ 2 * l * 12 + 3 * (a * 12) ^ 3) + (P * a * 12 / (6 * E * I)) * (2 * a * l * 144 - 2 * (a * 12) ^ 2)
 


End Function
Attribute VB_Name = "ThisWorkbook"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Private Sub Workbook_Open()
    MyTag = "show"
End Sub
Attribute VB_Name = "UpdateTOC"
Attribute VB_Base = "0{612A7936-1BD1-4FCD-B754-46E83914DCDF}{5232B425-AD43-493E-B4C0-FD6601916A77}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Private Sub UpdateTOCButton_Click()

    'Update Table of Contents
    
    Dim ws As Worksheet
    Dim wscount As Integer
    Dim I As Integer
    Dim count As Integer
    Dim SHname As String
    
    Application.ScreenUpdating = False
    
    wscount = Sheets.count
    
    'Clear Contents first
    Sheets("TOC").Activate
    If Me.UpdatePageNumsButton.Value = True Then
        Range("A4:G1000").Select
        Selection.ClearContents
        Selection.Hyperlinks.Delete
    Else
        Range("A4:F1000").Select
        Selection.ClearContents
        Selection.Hyperlinks.Delete
    End If
    
    Range("A4").Value = "Description"
    Range("G4").Value = "Section"
    Range("A4:G4").Font.Size = 11
    Range("A4:G4").Font.Bold = True
    Range("A4:G4").Font.Underline = True
    
    Sheets("TOC").Range("A4:G1000").Select
    Selection.Borders(xlDiagonalDown).LineStyle = xlNone
    Selection.Borders(xlDiagonalUp).LineStyle = xlNone
    Selection.Borders(xlEdgeLeft).LineStyle = xlNone
    Selection.Borders(xlEdgeTop).LineStyle = xlNone
    Selection.Borders(xlEdgeBottom).LineStyle = xlNone
    Selection.Borders(xlEdgeRight).LineStyle = xlNone
    Selection.Borders(xlInsideVertical).LineStyle = xlNone
    Selection.Borders(xlInsideHorizontal).LineStyle = xlNone
       
    'add ws name with hyperlink to tab, dots and section num
    count = 0
    col = 5
    IndentLevel = "A"
    For I = 4 To wscount
        SHname = Sheets(I).Name
        If Sheets(I).visible = True Then
            If SHname = "----------Back Cover-----------" Then GoTo endofsub
            
            If Sheets(I).Range("M2").Value = "Section" Then
                If Me.SectionsOnlyButton.Value = False And I <> 4 Then
                    col = col + 1
                End If
                
                SHname = Sheets(I).Shapes.Range(Array("TextBox 1")).TextFrame.Characters.Text
                Sheets("TOC").Range("A1").Offset(col, 0).Value = SHname
                
                Sheets("TOC").Range("A1:F1").Offset(col, 0).Select
                With Selection.Borders(xlEdgeBottom)
                    If Me.AllTabsButton.Value = True Then
                        .LineStyle = xlNone
                    Else
                        .LineStyle = xlDot
                        .ColorIndex = 0
                        .TintAndShade = 0
                        .Weight = xlThin
                    End If
                End With
                With Selection.Font
                    .Name = "Arial"
                    .Size = 11
                    .Bold = False
                    .Strikethrough = False
                    .Superscript = False
                    .Subscript = False
                    .OutlineFont = False
                    .Shadow = False
                    .ColorIndex = xlAutomatic
                    .TintAndShade = 0
                    .ThemeFont = xlThemeFontNone
                End With
                col = col + 1
                IndentLevel = "B"
            
            ElseIf Sheets(I).Range("M2").Value = "Subsection" And Me.SectionsOnlyButton.Value = False Then
                SHname = Sheets(I).Shapes.Range(Array("TextBox 1")).TextFrame.Characters.Text
                Sheets("TOC").Range("B1").Offset(col, 0).Value = SHname
                
                Sheets("TOC").Range("B1:F1").Offset(col, 0).Select
                With Selection.Borders(xlEdgeBottom)
                    If Me.AllTabsButton.Value = True Then
                        .LineStyle = xlNone
                    Else
                        .LineStyle = xlDot
                        .ColorIndex = 0
                        .TintAndShade = 0
                        .Weight = xlThin
                    End If
                End With
                With Selection.Font
                    .Name = "Arial"
                    .Size = 11
                    .Bold = False
                    .Strikethrough = False
                    .Superscript = False
                    .Subscript = False
                    .OutlineFont = False
                    .Shadow = False
                    .ColorIndex = xlAutomatic
                    .TintAndShade = 0
                    .ThemeFont = xlThemeFontNone
                End With
                col = col + 1
                IndentLevel = "C"
                    
            ElseIf Me.AllTabsButton.Value = True Then
                count = count + 1
                
                Sheets("TOC").Range(IndentLevel & "1").Offset(col, 0).Value = SHname
                'Sheets("TOC").Hyperlinks.Add Anchor:=Range("B1").Offset(I, 0), Address:="", SubAddress:= _
                '"'" & SHname & "'" & "!A1", TextToDisplay:=SHname
                
                If Me.UpdatePageNumsButton.Value = True Then
                    Sheets("TOC").Range("G1").Offset(col, 0).Value = count
                End If
                
                Sheets("TOC").Range(IndentLevel & "1:F1").Offset(col, 0).Select
                With Selection.Borders(xlEdgeBottom)
                    .LineStyle = xlDot
                    .ColorIndex = 0
                    .TintAndShade = 0
                    .Weight = xlThin
                End With
                With Selection.Font
                    .Name = "Arial"
                    .Size = 11
                    .Bold = False
                    .Strikethrough = False
                    .Superscript = False
                    .Subscript = False
                    .OutlineFont = False
                    .Shadow = False
                    .ColorIndex = xlAutomatic
                    .TintAndShade = 0
                    .ThemeFont = xlThemeFontNone
                End With
                col = col + 1
                
            End If
        End If
    Next

endofsub:
    Sheets("TOC").Range("A1").Select
    Application.ScreenUpdating = True
    Unload Me
    
End Sub

Private Sub UserForm_Activate()
    With Me
        .Top = Int(((Application.Height / 2) + Application.Top) - (.Height / 2))
        .Left = Int(((Application.Width / 2) + Application.Left) - (.Width / 2))
    End With
End Sub

Private Sub CancelButton_Click()
Unload Me
End Sub

Attribute VB_Name = "testing"
'All this is just testing code for functionality, good to save


'Public Declare PtrSafe Function SetCurrentDirectoryA Lib "kernel32" (ByVal lpPathName As String) As Long

'Test code for making changes and debugging

'Sub Test_Click()


'Dim Template As String

'Template = "Loads - Seismic Story Force Dist"
'Template = "Loads - Seismic CBC 2013"
'Template = "C:\Projects\Calcs Spreadsheet\Steel\AISC Shapes Database v14.1.xlsx"
'Template = "C:\Projects\Calcs Spreadsheet\Wood\Wood - STD_Typical 2x Framing.xlsx"


'If CheckBox1.Value = True Then
'    Call CopySheet(Template)
'    Sheets("Dashboard").Range("L24") = Template

'End If


'End Sub


'Sub Test_two()
'
'    'Analysis & Design Criteria
'    Dim Template As String
'    Dim FilName As Variant
'
'    Path1 = ActiveWorkbook.Path
'
'    Path2 = "\\zfa.com\" & ActiveWorkbook.Sheets("Dashboard").Range("C3").Value & _
'    "\Engineering\ZFA Committees\Spreadsheet Committee\In progress - FOR TESTING ONLY\CalcSpreadsheets\Analysis & Design Criteria"
'
'    SetCurrentDirectoryA "\\zfa.com\" & ActiveWorkbook.Sheets("Dashboard").Range("C3").Value & "\"
'
'    ChDir Path2
'
'    FilName = Application.GetOpenFilename("Excel Workbooks, *.xls; *.xlsx; *.xlsm", , "Specify the Template File to Add")
'    If FilName = False Then
'        MsgBox "No File Was Selected"
'        Exit Sub
'    Else
'        Template = CStr(FilName)
'        Call CopySheet(Template)
'    End If
'
'    ChDir Path1
'
'End Sub


' InQuest injected base64 decoded content
' )^J)

INQUEST-PP=macro
