Attribute VB_Name = "Language"
Option Explicit

Public text(100) As String
Public Enum IdLanguage
    IdGerman = 0
    IdEnglish = 1
    IdFrench = 2
    IdItalian = 3
    IdSpanish = 4
End Enum

'Diesse Variable initialisieren, um die Sprache zu |fffd|ndern!!!
Public Const Sprache = 0

Public Sub init_language(lang As IdLanguage)
    Select Case lang
        Case IdGerman
            'com_frm
            text(0) = "Serielle I/O"
            'main_k_frm
            text(1) = "Kontinuierliche Daten|fffd|bertragung"
            text(2) = "Anzahl der Einzelwerte"
            text(3) = "Start Wert"
            text(4) = "Start"
            text(5) = "Stop"
            text(6) = "Status"
            text(7) = "Einzelwerte |fffd|bertragen"
            text(8) = "Aktuell"
            text(9) = "Spitzenwerte"
            text(10) = "Zugfestigkeit"
            text(11) = "Zellen f|fffd|llen in"
            text(12) = "Spalten (abw|fffd|rts)"
            text(13) = "Zeilen (nach rechts)"
            text(14) = "Start Zelle"
            text(15) = "|fffd|bertragungsrate"
            'Meldungen im Status-Feld
            text(16) = "Keine Verbindung"
            text(17) = "Warten"
            text(18) = "Verf|fffd|gbar"
            text(19) = "Daten Erfassen"
            'Message_Box
            text(20) = "Verbindungsfehler!" & vbCr & "Bitte |fffd|berpr|fffd|fen Sie das Kabel" & vbCr & "und die Kommunikationseinstellungen"
            text(21) = "Sendefehler RS232"
            text(22) = "Wert = "
            'Titel der Form
            text(30) = "Schnittstelle"
            text(31) = "Alluris GmbH  -  FMI_Connect"
        Case IdEnglish
            'com_frm
            text(0) = "Serial I/O"
            'main_k_frm
            text(1) = "Continuous data transfer"
            text(2) = "Number of single values"
            text(3) = "Start value"
            text(4) = "Start"
            text(5) = "Stop"
            text(6) = "Status"
            text(7) = "Single value data transfer"
            text(8) = "Update"
            text(9) = "Peak values"
            text(10) = "Tensil strength"
            text(11) = "Data entry into"
            text(12) = "Columns (down)"
            text(13) = "Rows (to the right)"
            text(14) = "Start cell"
            text(15) = "Transfer rate"
            'Meldungen im Status-Feld
            text(16) = "No connection"
            text(17) = "Wait"
            text(18) = "Available"
            text(19) = "Capture data"
            'Message_Box
            text(20) = "Communication Error!" & vbCr & "Please check connection" & vbCr & "and communication setting."
            text(21) = "Sending Error RS232"
            text(22) = "value = "
            'Titel der Form
            text(30) = "Interface"
            text(31) = "Alluris GmbH  -  FMI_Connect"
        Case IdFrench
            'com_frm
            text(0) = "S|fffd|rie E/S"
            'main_k_frm
            text(1) = "Transmission continue"
            text(2) = "Total valeurs individuelles"
            text(3) = "Valeur de d|fffd|marrage"
            text(4) = "Start"
            text(5) = "Stop"
            text(6) = "Status"
            text(7) = "Transmission individuelles"
            text(8) = "Actuel"
            text(9) = "Valeur de pointe"
            text(10) = "R|fffd|sistance a la traction"
            text(11) = "Inscrite dans la m|fffd|me "
            text(12) = "Colonne (ver le bas)"
            text(13) = "Linie (vers la droite)"
            text(14) = "Cellule start"
            text(15) = "Taux de transmission"
            'Meldungen im Status-Feld
            text(16) = "Pas de connection"
            text(17) = "Attendez"
            text(18) = "Available"
            text(19) = "Transmission de donn|fffd|es"
            'Message_Box
            text(20) = "Erreur!" & vbCr & "S.V.P. cont|fffd|lez le c|fffd|ble et le" & vbCr & "r|fffd|glage de transmission"
            text(21) = "Erreur de transmission RS232"
            text(22) = "Valeur = "
            'Titel der Form
            text(30) = "Interface"
            text(31) = "Alluris GmbH  -  FMI_Connect"
        Case IdItalian
            'com_frm
            text(0) = "Seriale adatta I/O"
            'main_k_frm
            text(1) = "Trasmissione continua"
            text(2) = "Numero rilevazioni singole"
            text(3) = "Valore di inizio"
            text(4) = "Start"
            text(5) = "Stop"
            text(6) = "Status"
            text(7) = "Trasmissione singole"
            text(8) = "Aggiornato"
            text(9) = "Valori massimi"
            text(10) = "Resistenza alla trazione"
            text(11) = "Trascritto sulla stessa"
            text(12) = "Colonna (verso il basso)"
            text(13) = "Riga (verso destra)"
            text(14) = "Cella di Inizio"
            text(15) = "Valore de trasmissione"
            'Meldungen im Status-Feld
            text(16) = "No connection"
            text(17) = "Attendez"
            text(18) = "Available"
            text(19) = "Trasmissione dei dati"
            'Message_Box
            text(20) = "Errore!" & vbCr & "Verificate il cavo i l'installazione" & vbCr & "per la transmissione"
            text(21) = "Errore transmissione RS232"
            text(22) = "Valori = "
            'Titel der Form
            text(30) = "Interfaccia"
            text(31) = "Alluris GmbH  -  FMI_Connect"
        Case IdSpanish
            'com_frm
            text(0) = "Puerto I/O serie"
            'main_k_frm
            text(1) = "Transmisi|fffd|n continua"
            text(2) = "Total valores unitarios"
            text(3) = "Valor de inicio"
            text(4) = "Start"
            text(5) = "Stop"
            text(6) = "Status"
            text(7) = "Transmisi|fffd|n unitarios"
            text(8) = "Actual"
            text(9) = "Valores pico"
            text(10) = "Resistencia a la tracci|fffd|n"
            text(11) = "Escribe en la misma"
            text(12) = "Columna (hacia abajo)"
            text(13) = "L|fffd|nea (hacia de derecha)"
            text(14) = "Celda de inicio"
            text(15) = "Velocidad de transmisi|fffd|n"
            'Meldungen im Status-Feld
            text(16) = "No conexi|fffd|n"
            text(17) = "Attendez"
            text(18) = "Available"
            text(19) = "Transmisi|fffd|n de datos"
            'Message_Box
            text(20) = "Error!" & vbCr & "Verifique el cable et las" & vbCr & "configuraciones de transmisi|fffd|n."
            text(21) = "Error transmisi|fffd|n RS232"
            text(22) = "Valores = "
            'Titel der Form
            text(30) = "Interfaz"
            text(31) = "Alluris GmbH  -  FMI_Connect"
    End Select
End Sub



Attribute VB_Name = "Sheet1"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet2"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet3"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "ThisWorkbook"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Const MenuType = "Worksheet Menu Bar"   ' |fffd||fffd||fffd|j|fffd||fffd||fffd|[|fffd|^|fffd|C|fffd|v
Dim MainMenu As CommandBarControl       ' |fffd||fffd||fffd|C|fffd||fffd||fffd||fffd||fffd|j|fffd||fffd||fffd|[
Dim SubMenu As CommandBarControl        ' |fffd|T|fffd|u|fffd||fffd||fffd|j|fffd||fffd||fffd|[

Public mPortNo As Integer           'COM|fffd|||fffd|[|fffd|g|fffd||50d||fffd||fffd|@|fffd|O|fffd||fffd||fffd|[|fffd|o|fffd||fffd||fffd||3d0||fffd|

'*************************
'   |fffd|A|fffd|h|fffd|C|fffd||fffd||fffd||1c9||fffd||fffd||fffd|
'*************************
Private Sub Workbook_Open()
    Set MainMenu = Application.CommandBars(MenuType) _
                .Controls.Add(msoControlPopup, , , , True)
    MainMenu.Caption = XLANAME_K

    Set SubMenu = MainMenu.Controls.Add
    SubMenu.Caption = "START"
    SubMenu.OnAction = "main_k_frm_show"
    
    Set SubMenu = MainMenu.Controls.Add
    SubMenu.Caption = "Ver"
    SubMenu.OnAction = "ver_proc_k_FGCBx"
    
    Set SubMenu = MainMenu.Controls.Add
    SubMenu.Caption = "Set"
    SubMenu.OnAction = "Com_SelectProc"
    
    Set SubMenu = MainMenu.Controls.Add
    SubMenu.Caption = "Language"
    SubMenu.OnAction = "language_frm_show"
    
    

    '|fffd||fffd||fffd||fffd||fffd|||fffd|[|fffd|g|fffd||342|b|fffd|n|fffd|l|fffd|P|fffd||182||fffd||fffd||fffd|
    mPortNo = GetSetting("FMI_Connect", "Settings", "PortNo", 1)
End Sub

'*************************
'   |fffd|A|fffd|h|fffd|C|fffd||fffd||fffd||fffd||fffd||fffd||fffd|
'*************************
Private Sub Workbook_BeforeClose(Cancel As Boolean)
    ' |fffd||fffd||fffd|C|fffd||fffd||fffd||fffd||fffd|j|fffd||fffd||fffd|[|fffd||fffd||fffd|
    For Each MainMenu In Application.CommandBars(MenuType).Controls
        If MainMenu.Caption = XLANAME_K Then
            MainMenu.Delete
        End If
    Next MainMenu
    SaveSetting "FMI_Connect", "Settings", "PortNo", mPortNo
End Sub

Attribute VB_Name = "Timer"
' F|fffd|gen Sie nachfolgenden Code in ein |fffd|ffengtliches Modul ein
Private Declare Sub GetLocalTime Lib "kernel32.dll" (lpSystemTime As SYSTEMTIME)
 
Private Declare Function SetTimer Lib "user32.dll" ( _
  ByVal hWnd As Long, _
  ByVal nIDEvent As Long, _
  ByVal uElapse As Long, _
  ByVal lpTimerFunc As Long) As Long
 
Private Declare Function KillTimer Lib "user32.dll" ( _
  ByVal hWnd As Long, _
  ByVal nIDEvent As Long) As Long
 
Const WM_TIMER = &H113 ' Timer-Ereignis trifft ein
 
Private Type SYSTEMTIME
  wYear As Integer
  wMonth As Integer
  wDayOfWeek As Integer
  wDay As Integer
  wHour As Integer
  wMinute As Integer
  wSecond As Integer
  wMilliseconds As Integer
End Type
 
Private hEvent As Long

Public TimerIsOn As Boolean

' Timer-Prozedur, welche im Abstand der festgelegten
' Millisekunden ein Ereignis sendet
Public Sub TimerProc(ByVal hWnd As Long, ByVal uMsg As Long, _
    ByVal wParam As Long, ByVal lParam As Long)
    Dim ret As Integer
    Dim i
    If uMsg = WM_TIMER Then
        If buf_index >= cnt Then
            StopStreaming
        Else
            GetStreamingData cmd_bb
        End If
    End If
End Sub

' Startet den Timer
Public Function EnableTimer(ByVal msInterval As Long)
  If hEvent <> 0 Then Exit Function
  hEvent = SetTimer(0&, 0&, msInterval, AddressOf TimerProc)
  TimerIsOn = True
End Function

' Beendet den Timer
Public Function DisableTimer()
  If hEvent = 0 Then Exit Function
  KillTimer 0&, hEvent
  hEvent = 0
  TimerIsOn = False
End Function

' WARTE mindestens "second" Sekunden lang.
Public Sub wait(sec As Integer)
  Dim start As Variant
  Dim mess As Variant
  Dim diff As Long
  
  start = Now
  Do
    mess = Now
    diff = DateDiff("s", start, mess)
  Loop Until diff >= sec
End Sub

Attribute VB_Name = "com_frm"
Attribute VB_Base = "0{B3A3F119-C266-4C6C-9E06-D71A81627B32}{FEB7BC65-0A97-489D-B2C2-B53C2AF32D5D}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Public mPortNo  As Integer      'COM|fffd|||fffd|[|fffd|g|fffd||50d||fffd|


'*************************
'   OK|fffd|{|fffd|^|fffd||fffd||fffd||fffd||fffd||fffd|
'*************************
Private Sub CmdBtn_PSelOK_Click()
    '|fffd|I|fffd||fffd||fffd||fffd||fffd||102||fffd||fffd||fffd|OptionButton|fffd||249||fffd||fffd||fffd||fffd||fffd|Com|fffd|||fffd|[|fffd|g|fffd||50d||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||150||752||80b3||fffd||fffd||fffd|
    Fmi_Connect.ThisWorkbook.mPortNo = GetSelectPort()
    Unload Me
End Sub


'*************************
'   |fffd|_|fffd|C|fffd|A|fffd||fffd||fffd|O|fffd||fffd||fffd||fffd||fffd||fffd|
'*************************
Private Sub UserForm_Initialize()
    '|fffd||fffd||fffd||742||303|||fffd|[|fffd|g|fffd||50d||fffd||fffd||303|I|fffd|v|fffd|V|fffd||fffd||fffd||fffd||fffd|{|fffd|^|fffd||fffd||fffd||fffd|I|fffd||fffd||fffd||fffd||502||242||fffd||fffd||fffd|
    init_language CInt(GetSetting(XLANAME_K, "Settings", "Language", "0"))
    init_form
    SetInitialPort Fmi_Connect.ThisWorkbook.mPortNo
End Sub

'*************************
'   |fffd||fffd||fffd||742||311|I|fffd||fffd||fffd||fffd||fffd||a0bd||fffd|I|fffd|v|fffd|V|fffd||fffd||fffd||fffd||fffd|{|fffd|^|fffd||fffd||fffd||249||fffd||fffd||fffd||fffd||fffd||fffd|||fffd|[|fffd|g|fffd||50d||fffd||fffd||fffd||502||fffd|
'*************************
Private Function GetSelectPort() As Integer
    If (OptBtn_Com1.Value) Then
        GetSelectPort = 1
    ElseIf (OptBtn_Com2.Value) Then
        GetSelectPort = 2
    ElseIf (OptBtn_Com3.Value) Then
        GetSelectPort = 3
    ElseIf (OptBtn_Com4.Value) Then
        GetSelectPort = 4
    ElseIf (OptBtn_Com5.Value) Then
        GetSelectPort = 5
    End If
End Function

'*************************
'   |fffd||fffd||fffd||742||303|||fffd|[|fffd|g|fffd||50d||fffd||fffd||303|I|fffd|v|fffd|V|fffd||fffd||fffd||fffd||fffd|{|fffd|^|fffd||fffd||fffd||fffd|I|fffd||fffd||fffd||fffd||502||242||fffd||fffd||fffd|
'*************************
Private Sub SetInitialPort(num As Integer)
    
    Select Case (num)
    Case 1:
        OptBtn_Com1.Value = True
    Case 2:
        OptBtn_Com2.Value = True
    Case 3:
        OptBtn_Com3.Value = True
    Case 4:
        OptBtn_Com4.Value = True
    Case 5:
        OptBtn_Com5.Value = True
    Case Else:
        'COM|fffd|P|fffd|`|fffd|T|fffd||20a|O|fffd||314||50d||fffd||fffd||351|S|fffd||102|P|fffd||182||fffd||fffd||fffd|
        OptBtn_Com1.Value = True
    End Select
End Sub

Private Sub init_form()
    com_frm.Caption = text(30)
    Fme_ComPorts.Caption = text(0)
End Sub

Attribute VB_Name = "language_frm"
Attribute VB_Base = "0{EBB4CAE5-3788-45BA-BDB4-3464A2ED52B5}{AFD57D12-F8AB-469E-B677-D5EA4A70DE83}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Function GetSelectLanguage() As Integer
    If (LanguageBtn1.Value) Then
        GetSelectLanguage = IdGerman
    ElseIf (LanguageBtn2.Value) Then
        GetSelectLanguage = IdEnglish
    ElseIf (LanguageBtn3.Value) Then
        GetSelectLanguage = IdFrench
    ElseIf (LanguageBtn4.Value) Then
        GetSelectLanguage = IdItalian
    ElseIf (LanguageBtn5.Value) Then
        GetSelectLanguage = IdSpanish
    End If
End Function

Private Sub SetInitialLanguage(num As Integer)
    
    Select Case (num)
    Case IdGerman:
        LanguageBtn1.Value = True
    Case IdEnglish:
        LanguageBtn2.Value = True
    Case IdFrench:
        LanguageBtn3.Value = True
    Case IdItalian:
        LanguageBtn4.Value = True
    Case IdSpanish:
        LanguageBtn5.Value = True
    Case Else:
        LanguageBtn1.Value = True
    End Select
End Sub

Private Sub cmdOK_Click()
    SaveSetting XLANAME_K, "Settings", "Language", CStr(GetSelectLanguage())
    Unload Me
End Sub

Private Sub UserForm_Initialize()
    'boFMIrunning = True
    SetInitialLanguage CInt(GetSetting(XLANAME_K, "Settings", "Language", "0"))
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    'boFMIrunning = False
End Sub
Attribute VB_Name = "main_k_frm"
Attribute VB_Base = "0{BD331B54-B96B-4A7C-9C91-1FA28D93142C}{CA3EA8E9-04C5-4C6B-BDF0-C1E6F1F2C0BF}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Dim cell_dir As Integer     ' Zellausrichtung
Dim areas As Variant        ' Zellenbereich

'*********************************************************
' Erstinitialisierung und Verbindung zu Ger|fffd|t aufnehmen
'*********************************************************
Private Sub UserForm_Initialize()
    Dim ii
    Dim ret As String
    
    init_language CInt(GetSetting(XLANAME_K, "Settings", "Language", "0"))
    init_form
    
   '+++ Initialisierungen aus Registry holen +++
    'Abtastrate
    OptBtn_10.Value = 0
    OptBtn_20.Value = 0
    OptBtn_50.Value = 0
    OptBtn_100.Value = 0
    cmd_bb = GetSetting("FMI_Connect", "Settings", "bb", "BB2")
    Select Case cmd_bb
        Case "BB"
            OptBtn_10.Value = 1
        Case "BB1"
            OptBtn_20.Value = 1
        Case "BB2"
            OptBtn_50.Value = 1
        Case "BB3"
            OptBtn_100.Value = 1
    End Select
    'Anzahl Werte
    cnt = GetSetting("FMI_Connect", "Settings", "cnt", 100)
    Txt_cnt.text = CStr(cnt)
    'Triggerwert
    trg = GetSetting("FMI_Connect", "Settings", "trg", 0)
    Txt_trg.text = Abs(CStr(trg))
    If trg >= 0 Then
        OptBtn_plus.Value = 1
        OptBtn_minas.Value = 0
    Else
        OptBtn_plus.Value = 0
        OptBtn_minas.Value = 1
    End If
    
    'Zellausrichtung
    OptBtn_tate.Value = 0
    OptBtn_yoko.Value = 0
    cell_dir = GetSetting("FMI_Connect", "Settings", "cell_dir", TATE)
    Select Case cell_dir
        Case TATE
            OptBtn_tate.Value = 1
        Case YOKO
            OptBtn_yoko.Value = 1
    End Select
    
   '++++++++++++++++++++++++++++++++++++++++++++++++++++++
    
    'Falls kein Port initialisiert wurde, diesen auf 1 setzen
    If (Fmi_Connect.ThisWorkbook.mPortNo = 0) Then Fmi_Connect.ThisWorkbook.mPortNo = 1
    ' Initialize Communications
    intPortID = Fmi_Connect.ThisWorkbook.mPortNo
    lngStatus = CommOpen(intPortID, "COM" & CStr(intPortID), _
        "baud=19200 parity=N data=8 stop=1")
    If lngStatus <> 0 Then
        ' Handle error.
        lngStatus = CommGetError(strError)
        MsgBox "COM Error: " & strError
    Else
        ' Set modem control lines.
        'lngStatus = CommSetLine(intPortID, LINE_RTS, True)
        lngStatus = CommSetLine(intPortID, LINE_DTR, True)
        CommFlush intPortID 'Puffer leeren
    End If
    
    ' Je nach Ger|fffd|t und Zustand dessen Schnittstelle k|fffd|nnte noch 0B oder 0F kommen,
    ' daher mehrmals versuchen
    ret = cmd_SendRcv("AB")
    If (Left$(ret, 2) <> "AB") Then
        CommFlush intPortID 'Puffer leeren
        ret = cmd_SendRcv("AB")
        If (Left$(ret, 2) <> "AB") Then
            CommFlush intPortID 'Puffer leeren
            ret = cmd_SendRcv("AB")
            If (Left$(ret, 2) <> "AB") Then
                MsgBox text(20), vbOKOnly, "FMI_Connect"
            End If
        End If
    Else
        cmd_btn_true
    End If
    CommFlush intPortID 'Puffer leeren
End Sub

'************************************************
' Beim Beenden Verbindung zum COM-Port schlie|fffd|en
'************************************************
Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    DisableTimer
    Call CommClose(intPortID)
    'Einstellungen in Registry speichern
    SaveSetting "FMI_Connect", "Settings", "bb", cmd_bb
    SaveSetting "FMI_Connect", "Settings", "cnt", cnt
    SaveSetting "FMI_Connect", "Settings", "trg", trg
    SaveSetting "FMI_Connect", "Settings", "cell_dir", cell_dir
End Sub

'*************************
' Datenrate ausw|fffd|hlen
'*************************
Private Sub OptBtn_10_Click()
    cmd_bb = "BB"
End Sub

Private Sub OptBtn_20_Click()
    cmd_bb = "BB1"
End Sub

Private Sub OptBtn_50_Click()
    cmd_bb = "BB2"
End Sub

Private Sub OptBtn_100_Click()
    cmd_bb = "BB3"
End Sub

'*****************************
'  Zellausrichtung ausw|fffd|hlen
'*****************************
Private Sub OptBtn_tate_Click()
    cell_dir = TATE
End Sub

Private Sub OptBtn_yoko_Click()
    cell_dir = YOKO
End Sub

'****************************
'  Trigger Vorzeichen
'****************************
Private Sub OptBtn_plus_Click()
    trg = Val(Txt_trg.text)
End Sub

Private Sub OptBtn_minas_Click()
    trg = Val(Txt_trg.text) * (-1)
End Sub

'*************************
'  Data-Streaming starten
'*************************
Private Sub CmdBtn_start_Click()
    Dim msInterval As Long
    'Sinnvolle Anzahl?
    If cnt <= 0 Then
        Exit Sub
    End If
    
    areas = RefEdit1.Value
    If areas <> Empty Then
        Range(areas).Activate
    End If
    RefEdit1.text = ""
    
    ' Eingabeobjekte w|fffd|hrend |fffd|bertragung sperren
    CmdBtn_start.Enabled = False
    CmdBtn_data.Enabled = False
    CmdBtn_peak.Enabled = False
    CmdBtn_mp.Enabled = False
    Txt_cnt.Locked = True
    Txt_trg.Locked = True
    
    Txt_sts.text = text(17)
    Txt_sts.BackColor = &HFFFF&

    trg_on = False
    buf_index = 0
    LabelCount.Caption = "n = " + CStr(buf_index)
    LabelCount.Visible = True
    Label4.Caption = ""
    Label4.Visible = True

    ' |fffd|bertragungsrate ermitteln und parametrieren
    If cmd_bb = "BB" Then
        cmd_flg = BB
        msInterval = 100
    ElseIf cmd_bb = "BB1" Then
        cmd_flg = BB1
        msInterval = 50
    ElseIf cmd_bb = "BB2" Then
        cmd_flg = BB2
        msInterval = 20
    ElseIf cmd_bb = "BB3" Then
        cmd_flg = BB3
        msInterval = 10
    Else
        cmd_flg = BB
        cmd_bb = "BB"
        msInterval = 100
    End If
    CommFlush intPortID 'Puffer leeren
    nFile = 0
    boFirstStream = True
    c_work = vbNullString
    EnableTimer msInterval
End Sub

'************************************************************************************************
' Data-Streaming anhalten, allerdings geht das beim neuen Handling der Schnittstelle nicht mehr
'************************************************************************************************
Public Sub CmdBtn_stop_Click()
    StopStreaming
End Sub

'*****************************
'   Aktuellen Wert einlesen
'*****************************
Private Sub CmdBtn_data_Click()
    Dim ret As String
    areas = RefEdit1.Value
    If areas <> Empty Then
        Range(areas).Activate
    End If
        
    RefEdit1.text = ""
    cmd_btn_false
    ret = cmd_SendRcv("BA")
    data_buf(0) = Val(Mid(ret, 6, 6))
    cmd_flg = BA    'F|fffd|r cell_output
    cell_output
    ret = cmd_SendRcv("AB") 'Ende signalisieren
    cmd_btn_true
End Sub

'*************************
'   Peak-Values einlesen
'*************************
Private Sub CmdBtn_peak_Click()
    Dim ret As String
    areas = RefEdit1.Value
    If areas <> Empty Then
        Range(areas).Activate
    End If
    
    RefEdit1.text = ""
    cmd_btn_false
    ret = cmd_SendRcv("AN")
    data_buf(0) = Val(Mid(ret, 6, 6))
    data_buf(1) = Val(Mid(ret, 12, 6))
    cmd_flg = AN    'F|fffd|r cell_output
    cell_output
    ret = cmd_SendRcv("AE") 'Peaks automatisch l|fffd|schen
    ret = cmd_SendRcv("AB") 'Ende signalisieren
    cmd_btn_true
End Sub

'***************************
'   Zugfestigkeit einlesen
'***************************
Private Sub CmdBtn_mp_Click()
    Dim ret As String
    areas = RefEdit1.Value
    If areas <> Empty Then
        Range(areas).Activate
    End If
    
    RefEdit1.text = ""
    cmd_btn_false
    ret = cmd_SendRcv("BF")
    data_buf(0) = Val(Mid(ret, 6, 6))
    cmd_flg = BF    'F|fffd|r cell_output
    cell_output
    ret = cmd_SendRcv("AB") 'Ende signalisieren
    cmd_btn_true
End Sub

'*************************************
'   Ausgabe von data_buf() in Excel
'*************************************
Public Sub cell_output()
    
    Dim Row As Integer      ' Excel-Zeile
    Dim Col As Integer      ' Excel_Spalte
    Dim ii As Integer       ' Z|fffd|hlvariable Streaming

    Row = ActiveCell.Row
    Col = ActiveCell.Column
        
    'Einzelner Wert oder Zugfestigkeit
    If cmd_flg = BA Or cmd_flg = BF Then
        ActiveSheet.Cells(Row, Col).NumberFormat = "0.000"
        ActiveSheet.Cells(Row, Col) = data_buf(0)
        If cell_dir = YOKO Then
            ActiveSheet.Cells(Row, Col + 1).Select
        Else
            ActiveSheet.Cells(Row + 1, Col).Select
        End If
    'Peak-Werte
    ElseIf cmd_flg = AN Then
        ActiveSheet.Cells(Row, Col).NumberFormat = "0.000"
        ActiveSheet.Cells(Row, Col) = Round(data_buf(0), 3)
        If cell_dir = YOKO Then
            ActiveSheet.Cells(Row, Col + 1).NumberFormat = "0.000"
            ActiveSheet.Cells(Row, Col + 1) = data_buf(1)
            ActiveSheet.Cells(Row, Col + 2).Select
        Else
            ActiveSheet.Cells(Row + 1, Col).NumberFormat = "0.000"
            ActiveSheet.Cells(Row + 1, Col) = data_buf(1)
            ActiveSheet.Cells(Row + 2, Col).Select
        End If
    Else 'Data-Streaming
        If buf_index > MAX_BUF_COUNT Then buf_index = MAX_BUF_COUNT
        For ii = 0 To cnt - 1
            DoEvents
            If cell_dir = YOKO Then
                ActiveSheet.Cells(Row, Col + ii).NumberFormat = "0.000"
                ActiveSheet.Cells(Row, Col + ii) = data_buf(ii)
            Else
                ActiveSheet.Cells(Row + ii, Col).NumberFormat = "0.000"
                ActiveSheet.Cells(Row + ii, Col) = data_buf(ii)
            End If
        Next
    End If
End Sub

'****************************
' |fffd|nderung bei Anzahl Werte
'****************************
Private Sub Txt_cnt_Change()
    If Val(Txt_cnt.text) >= MAX_BUF_COUNT Then
        Txt_cnt.text = MAX_BUF_COUNT
    ElseIf Val(Txt_cnt.text) <= 0 Then
        Txt_cnt.text = 0
    Else
        Txt_cnt.text = Val(Txt_cnt.text)
    End If
    cnt = Val(Txt_cnt.text)
End Sub

Private Sub Txt_cnt_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If Not ((Asc("0") <= KeyAscii And KeyAscii <= Asc("9")) Or KeyAscii = BS) Then
        KeyAscii = 0
    End If
End Sub

'******************************************
'  |fffd|nderung bei Trigger
'******************************************
Private Sub Txt_trg_Change()
    If Val(Txt_trg.text) >= 9999 Then
        Txt_trg.text = 9999
    Else
        Txt_trg.text = Val(Txt_trg.text)
    End If
    If OptBtn_plus.Value = True Then
        trg = Val(Txt_trg.text)
    Else
        trg = Val(Txt_trg.text) * (-1)
    End If
End Sub

Private Sub Txt_trg_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    If Not ((Asc("0") <= KeyAscii And KeyAscii <= Asc("9")) Or KeyAscii = BS) Then
        KeyAscii = 0
    End If
End Sub

'**************************************************
' Buttons Enablen nach erfolgter Daten|fffd|bertragung
'***************************************************
Function cmd_btn_true()
    CmdBtn_start.Enabled = True
    CmdBtn_stop.Enabled = True
    CmdBtn_data.Enabled = True
    CmdBtn_peak.Enabled = True
    CmdBtn_mp.Enabled = True
    Txt_cnt.Locked = False
    Txt_trg.Locked = False
    Txt_sts.text = text(18)
    Txt_sts.BackColor = &H80000005
End Function

'**************************************************
' Buttons Disablen w|fffd|hrend Daten|fffd|bertragung
'***************************************************
Function cmd_btn_false()
    CmdBtn_start.Enabled = False
    CmdBtn_stop.Enabled = False
    CmdBtn_data.Enabled = False
    CmdBtn_peak.Enabled = False
    CmdBtn_mp.Enabled = False
    Txt_sts.text = text(19)
    Txt_sts.BackColor = &HFF&
End Function


Private Sub init_form()
    main_k_frm.Caption = text(31)
    Frame1.Caption = text(1)
    Label1.Caption = text(2)
    Label2.Caption = text(3)
    Frame2.Caption = text(15)
    CmdBtn_start.Caption = text(4)
    CmdBtn_stop.Caption = text(5)
    Frame8.Caption = text(6)
    Frame6.Caption = text(7)
    CmdBtn_data.Caption = text(8)
    CmdBtn_peak.Caption = text(9)
    CmdBtn_mp.Caption = text(10)
    Frame5.Caption = text(11)
    OptBtn_tate.Caption = text(12)
    OptBtn_yoko.Caption = text(13)
    Frame7.Caption = text(14)
    Txt_sts.text = text(16)
End Sub
Attribute VB_Name = "main_mdl"
Option Explicit

' |fffd|o|fffd|[|fffd|W|fffd||fffd||fffd||fffd|
Global Const XLANAME_K = "FMI_Connect_FGCB"
Global Const VERSION_K = "Ver 3.02.004 07/2015"
Global Const CORP = "Alluris GmbH & Co.KG"
Global Const INFO = "Ver"

' ASCII|fffd|R|fffd|[|fffd|h
Global Const CR = &HD   'Carriage Return
Global Const BS = &H8   'Back Space
Global Const DOT = &H2E 'Punkt

' Zellausrichtung
Global Const TATE = 0
Global Const YOKO = 1

' ASCII-Befehle an Ger|fffd|t
Global Const BB = 0     ' |fffd|A|fffd||fffd||fffd||fffd||fffd|M|fffd|v|fffd||fffd|
Global Const BB1 = 1    ' |fffd|A|fffd||fffd||fffd||fffd||fffd|M|fffd|v|fffd||fffd|
Global Const BB2 = 2    ' |fffd|A|fffd||fffd||fffd||fffd||fffd|M|fffd|v|fffd||fffd|
Global Const BB3 = 3    ' |fffd|A|fffd||fffd||fffd||fffd||fffd|M|fffd|v|fffd||fffd|
Global Const AB = 4     ' |fffd|A|fffd||fffd||fffd||fffd||fffd|M|fffd||fffd||fffd|~
Global Const BA = 5     ' |fffd|\|fffd||fffd||fffd|l
Global Const AN = 6     ' |fffd|s|fffd|[|fffd|N|fffd|v|fffd||fffd|
Global Const AE = 7     ' |fffd|s|fffd|[|fffd|N|fffd|N|fffd||fffd||fffd|A
Global Const BF = 8     ' Zugfestigkeit auslesen

Type Language
    TxtDE As String
    TxtEN As String
    TxtFR As String
    TxtSP As String
    TxtIT As String
End Type

Dim LangTxt() As Language

Global Const MAX_BUF_COUNT = 3000
Public cmd_flg As String                     ' Flags zur Signalisierung von Befehlen im Programmcode
Public data_buf(MAX_BUF_COUNT - 1) As Single 'Daten Puffer f|fffd|r Streaming
Public buf_index As Integer                  ' index von data_buf()
Public trg_on As Integer       ' Trigger erreicht
Public cnt As Integer          ' Anzahl Speicherwerte
Public trg As Integer          ' Vorzeichen Trigger
Public nFile As Long
Public boFirstStream As Boolean
Public cmd_bb As String        ' Abtastrate
Public c_work As String 'Variant   ' empfangener String
Public boTrigger As Boolean

'*************************
'   |fffd||fffd||fffd|C|fffd||fffd||fffd||fffd||295|\|fffd||fffd|
'*************************
Sub main_k_frm_show()
    main_k_frm.Show
End Sub

'*************************
'   |fffd|o|fffd|[|fffd|W|fffd||fffd||fffd||fffd||fffd||fffd||fffd|
'*************************
Sub ver_proc_k_FGCBx()
    Dim ver As String
    ver = XLANAME_K & " " & VERSION_K
    MsgBox ver & vbCrLf & vbCrLf & CORP, vbOKOnly, INFO
End Sub

'*************************
'   COM|fffd|||fffd|[|fffd|g|fffd|I|fffd||fffd||fffd||fffd||fffd|j|fffd||fffd||fffd|[
'*************************
Sub Com_SelectProc()
    com_frm.Show 1      '|fffd||fffd||fffd|[|fffd|_|fffd||fffd||fffd|_|fffd|C|fffd|A|fffd||fffd||fffd|O|fffd||182||fffd||fffd||115|\|fffd||fffd|
End Sub

Sub language_frm_show()
    language_frm.Show 1
End Sub
'Senden eines Befehls und gleichzeitig zeilenweisen Empfang der Antwort (Zeilen durch CR getrennt)
'ggf. werden mehrere Zeilen gelesen, falls mehr zur|fffd|ckkommt
Public Function cmd_SendRcv(cmd As String) As String
    Dim lngStatus As Long
    Dim nByte As Long
    Dim nTimeout As Long
    Dim strTxD As String
    Dim strRxD As String
    
    
    
    strTxD = cmd & VBA.Chr(CR)
    lngSize = Len(strTxD)
    lngStatus = CommWrite(intPortID, strTxD)
    If lngStatus <> lngSize Then    ' Handle error.
        MsgBox text(21), vbOKOnly, "FMI_Connect:cmd_SendRcv()"
    End If
    
    Select Case cmd
        Case "AN", "BA", "BF"
            nByte = 12
            wait 1  'Ansonsten wird zweite Zeile ggf. verschluckt
        Case "AN"
            nByte = 18
            wait 1  'Ansonsten wird zweite Zeile ggf. verschluckt
        Case "AB", "AE"
            nByte = 3
            wait 1
    End Select
    'Echo empfangen
    strRxD = ""
    lngStatus = 0
    'While lngStatus = 0 And nTimeout < 10000
    While lngStatus < nByte And nTimeout < 10000
        lngStatus = CommRead(intPortID, strRxD, nByte)
        nTimeout = nTimeout + 1
        DoEvents
    Wend
    
    'If lngStatus <> nByte Then
    If nTimeout >= 10000 Then
        MsgBox "Timeout cmd_SendRcv()! lngStatus=" + CStr(lngStatus) + " <> nByte=" + CStr(nByte) + ". nTimout=" + CStr(nTimeout)
    End If
    If (lngStatus > 0) Then
        cmd_SendRcv = strRxD   'Return-Value
    End If
End Function

'Ein Datum im Streaming-Modus empfangen und formatieren sowie Trigger erkennen
Public Sub GetStreamingData(cmd As String)
    Dim data As Single      ' nach Single gewandelter Messwert
    Dim ii As Integer       ' Index Dezimalstelle
    Dim jj As Integer       ' Faktor entsprechend der Dezimalstelle
    Dim strRxD As String
    Dim strTxD As String
    Dim nByte As Long
    Dim lngStatus As Long
    Dim RxD_End As Boolean
    
    If boFirstStream Then   'Beim ersten Mal den Befehl zum zyklischen Senden absetzen
        boFirstStream = False
        strTxD = cmd & VBA.Chr(CR)
        lngSize = Len(strTxD)
        lngStatus = CommWrite(intPortID, strTxD)
        If lngStatus <> lngSize Then    ' Handle error.
            MsgBox text(21), vbOKOnly, "FMI_Connect:GetStreamingData()"
        End If
        Select Case cmd
            Case "BB"
                nByte = 12
                'wait 1  'Ansonsten wird zweite Zeile ggf. verschluckt
            Case "BB1", "BB2", "BB3"
                nByte = 13
                'wait 1
        End Select
    Else
        nByte = 9
    End If
    lngStatus = CommRead(intPortID, strRxD, nByte) ' Daten blubbern im parametrierten Takt als "NAxxxxxxcr"
    If lngStatus > 0 Then      'lngStatus kann auch > nByte sein, wenn Puffer bereits mehr Daten hatte!!!
        Dim strTemp As String
        Dim nStart As Integer
        Dim nEnd As Integer
        Dim ret As Integer
        
        c_work = c_work & strRxD        'Dies kann irgend ein Stringfragment sein, weder komplett noch von Beginn
        'txt_WriteAll "C:\temp\stream.txt", c_work   'Zum Debugging Empfangspuffer in Datei schreiben
        'txt_WriteAll "C:\temp\stream.txt", strRxD   'Zum Debugging Empfangspuffer in Datei schreiben
        RxD_End = False
        nEnd = 0
        nStart = 0
        While RxD_End = False
            '"NA" und 0x0D suchen
            ret = InStr(nEnd + 1, c_work, "NA", vbTextCompare)
            If (ret > 0) Then
                nStart = ret
                ret = InStr(nStart, c_work, VBA.Chr(CR), vbTextCompare)
                If (ret > 0) Then
                    nEnd = ret
                    'Hier ist bekannt, dass in c_work sowohl NA als auch <CR> steckt
                    data = Val(Mid(c_work, nStart + 2, nEnd - nStart - 2))  'nStart zeigt auf "NA+" bzw. "NA-"
                    main_k_frm.Label4.Caption = text(22) & Format(data, "0.000")
                    
                    'Trigger erreicht?
                    If trg_on = False Then
                        'Dezimale bestimmen
                        ii = InStr(1, c_work, VBA.Chr(DOT), vbTextCompare)
                        If ii = 5 Then      ' *.***
                            jj = 1000
                        ElseIf ii = 6 Then  ' **.**
                            jj = 100
                        ElseIf ii = 7 Then  ' ***.*
                            jj = 10
                        Else                ' ****.
                            jj = 1
                        End If
                        
                        If trg > 0 Then
                            If (data * jj) > trg Then
                                trg_on = True
                                main_k_frm.Txt_sts.text = text(19)
                                main_k_frm.Txt_sts.BackColor = &HFF&
                            End If
                        ElseIf trg < 0 Then
                            If (data * jj) < trg Then
                                trg_on = True
                                main_k_frm.Txt_sts.text = text(19)
                                main_k_frm.Txt_sts.BackColor = &HFF&
                            End If
                        Else
                            trg_on = True
                            main_k_frm.Txt_sts.text = text(19)
                            main_k_frm.Txt_sts.BackColor = &HFF&
                        End If
                    End If
                    
                    If trg_on Then
                        If (boTrigger = False) Then
                            'txt_WriteAll "C:\temp\stream.txt", "**************** TRIGGER START ****************"
                            boTrigger = True
                        End If
                        If (buf_index < MAX_BUF_COUNT) Then 'Der Rest wird verworfen
                            data_buf(buf_index) = data
                            buf_index = buf_index + 1
                            main_k_frm.LabelCount = "n = " + CStr(buf_index)
                        End If
                    Else
                        boTrigger = False
                    End If
                Else 'Dann ist nicht der komplette Wert im Empfangspuffer
                    RxD_End = True
                End If
            Else    'kein "NA" mehr gefunden, dann wird der Rest von c_work f|fffd|r den n|fffd|chsten Durchgang gespeichert
                RxD_End = True
            End If
        Wend
        strTemp = Right(c_work, Len(c_work) - nEnd)
        c_work = strTemp
    End If
End Sub

'Streaming anhalten an der Stelle wo|fffd|s grad steht
Public Sub StopStreaming()
    DisableTimer
    cmd_SendRcv "AB"    '|fffd|bertragung beenden
    wait 1
    CommFlush intPortID 'Puffer leeren, falls nachtr|fffd|glich noch Werte gekommen sind
    
    'Ausgabe in Excel
    main_k_frm.cell_output
    'Objekte wieder unsichtbar bzw. zug|fffd|nglich machen
    main_k_frm.LabelCount.Visible = False
    main_k_frm.Label4.Visible = False
    main_k_frm.cmd_btn_true
End Sub

'Protokolldatei zeilenweise schreiben
'Am Ende wird von Schreibroutine <CR>+<LF> (0xD+0xA) eingef|fffd|gt
Public Sub txt_WriteAll(ByVal sFilename As String, _
  ByVal sLines As String)

  Dim F As Integer
  
  ' Datei zum Schreiben |fffd|ffnen
  F = FreeFile
  Open sFilename For Append As #F
  Print #F, CStr(nFile) & ": " & sLines
  Close #F
  nFile = nFile + 1
End Sub

Attribute VB_Name = "modCOMM"
' Quelle: http://www.thescarms.com/vbasic/CommIO.aspx

Option Explicit
Public boStreaming As Boolean

Public intPortID As Integer ' Ex. 1, 2, 3, 4 for COM1 - COM4
Public lngStatus As Long
Public strError  As String
Public strData   As String
Public lngSize   As Long

'-------------------------------------------------------------------------------
' modCOMM - Written by: David M. Hitchner
'
' This VB module is a collection of routines to perform serial port I/O without
' using the Microsoft Comm Control component.  This module uses the Windows API
' to perform the overlapped I/O operations necessary for serial communications.
'
' The routine can handle up to 4 serial ports which are identified with a
' Port ID.
'
' All routines (with the exception of CommRead and CommWrite) return an error
' code or 0 if no error occurs.  The routine CommGetError can be used to get
' the complete error message.
'-------------------------------------------------------------------------------

'-------------------------------------------------------------------------------
' Public Constants
'-------------------------------------------------------------------------------

' Output Control Lines (CommSetLine)
Public Const LINE_BREAK = 1
Public Const LINE_DTR = 2
Public Const LINE_RTS = 3

' Input Control Lines  (CommGetLine)
Public Const LINE_CTS = &H10&
Public Const LINE_DSR = &H20&
Public Const LINE_RING = &H40&
Public Const LINE_RLSD = &H80&
Public Const LINE_CD = &H80&

'-------------------------------------------------------------------------------
' System Constants
'-------------------------------------------------------------------------------
Private Const ERROR_IO_INCOMPLETE = 996&
Private Const ERROR_IO_PENDING = 997
Private Const GENERIC_READ = &H80000000
Private Const GENERIC_WRITE = &H40000000
Private Const FILE_ATTRIBUTE_NORMAL = &H80
Private Const FILE_FLAG_OVERLAPPED = &H40000000
Private Const FORMAT_MESSAGE_FROM_SYSTEM = &H1000
Private Const OPEN_EXISTING = 3

' COMM Functions
Private Const MS_CTS_ON = &H10&
Private Const MS_DSR_ON = &H20&
Private Const MS_RING_ON = &H40&
Private Const MS_RLSD_ON = &H80&
Private Const PURGE_RXABORT = &H2
Private Const PURGE_RXCLEAR = &H8
Private Const PURGE_TXABORT = &H1
Private Const PURGE_TXCLEAR = &H4

' COMM Escape Functions
Private Const CLRBREAK = 9
Private Const CLRDTR = 6
Private Const CLRRTS = 4
Private Const SETBREAK = 8
Private Const SETDTR = 5
Private Const SETRTS = 3

'-------------------------------------------------------------------------------
' System Structures
'-------------------------------------------------------------------------------
Private Type COMSTAT
        fBitFields As Long ' See Comment in Win32API.Txt
        cbInQue As Long
        cbOutQue As Long
End Type

Private Type COMMTIMEOUTS
        ReadIntervalTimeout As Long
        ReadTotalTimeoutMultiplier As Long
        ReadTotalTimeoutConstant As Long
        WriteTotalTimeoutMultiplier As Long
        WriteTotalTimeoutConstant As Long
End Type

'
' The DCB structure defines the control setting for a serial
' communications device.
'
Private Type DCB
        DCBlength As Long
        BaudRate As Long
        fBitFields As Long ' See Comments in Win32API.Txt
        wReserved As Integer
        XonLim As Integer
        XoffLim As Integer
        ByteSize As Byte
        Parity As Byte
        StopBits As Byte
        XonChar As Byte
        XoffChar As Byte
        ErrorChar As Byte
        EofChar As Byte
        EvtChar As Byte
        wReserved1 As Integer 'Reserved; Do Not Use
End Type

Private Type OVERLAPPED
        Internal As Long
        InternalHigh As Long
        offset As Long
        OffsetHigh As Long
        hEvent As Long
End Type

Private Type SECURITY_ATTRIBUTES
        nLength As Long
        lpSecurityDescriptor As Long
        bInheritHandle As Long
End Type

'-------------------------------------------------------------------------------
' System Functions
'-------------------------------------------------------------------------------
'
' Fills a specified DCB structure with values specified in
' a device-control string.
'
Declare Function BuildCommDCB Lib "kernel32" Alias "BuildCommDCBA" _
    (ByVal lpDef As String, lpDCB As DCB) As Long
'
' Retrieves information about a communications error and reports
' the current status of a communications device. The function is
' called when a communications error occurs, and it clears the
' device's error flag to enable additional input and output
' (I/O) operations.
'
Declare Function ClearCommError Lib "kernel32" _
    (ByVal hFile As Long, lpErrors As Long, lpStat As COMSTAT) As Long
'
' Closes an open communications device or file handle.
'
Declare Function CloseHandle Lib "kernel32" (ByVal hObject As Long) As Long
'
' Creates or opens a communications resource and returns a handle
' that can be used to access the resource.
'
Declare Function CreateFile Lib "kernel32" Alias "CreateFileA" _
    (ByVal lpFileName As String, ByVal dwDesiredAccess As Long, _
    ByVal dwShareMode As Long, lpSecurityAttributes As Any, _
    ByVal dwCreationDisposition As Long, ByVal dwFlagsAndAttributes As Long, _
    ByVal hTemplateFile As Long) As Long
'
' Directs a specified communications device to perform a function.
'
Declare Function EscapeCommFunction Lib "kernel32" _
    (ByVal nCid As Long, ByVal nFunc As Long) As Long
'
' Formats a message string such as an error string returned
' by anoher function.
'
Declare Function FormatMessage Lib "kernel32" Alias "FormatMessageA" _
    (ByVal dwFlags As Long, lpSource As Any, ByVal dwMessageId As Long, _
    ByVal dwLanguageId As Long, ByVal lpBuffer As String, ByVal nSize As Long, _
    Arguments As Long) As Long
'
' Retrieves modem control-register values.
'
Declare Function GetCommModemStatus Lib "kernel32" _
    (ByVal hFile As Long, lpModemStat As Long) As Long
'
' Retrieves the current control settings for a specified
' communications device.
'
Declare Function GetCommState Lib "kernel32" _
    (ByVal nCid As Long, lpDCB As DCB) As Long
'
' Retrieves the calling thread's last-error code value.
'
Declare Function GetLastError Lib "kernel32" () As Long
'
' Retrieves the results of an overlapped operation on the
' specified file, named pipe, or communications device.
'
Declare Function GetOverlappedResult Lib "kernel32" _
    (ByVal hFile As Long, lpOverlapped As OVERLAPPED, _
    lpNumberOfBytesTransferred As Long, ByVal bWait As Long) As Long
'
' Discards all characters from the output or input buffer of a
' specified communications resource. It can also terminate
' pending read or write operations on the resource.
'
Declare Function PurgeComm Lib "kernel32" _
    (ByVal hFile As Long, ByVal dwFlags As Long) As Long
'
' Reads data from a file, starting at the position indicated by the
' file pointer. After the read operation has been completed, the
' file pointer is adjusted by the number of bytes actually read,
' unless the file handle is created with the overlapped attribute.
' If the file handle is created for overlapped input and output
' (I/O), the application must adjust the position of the file pointer
' after the read operation.
'
Declare Function ReadFile Lib "kernel32" _
    (ByVal hFile As Long, ByVal lpBuffer As String, _
    ByVal nNumberOfBytesToRead As Long, ByRef lpNumberOfBytesRead As Long, _
    lpOverlapped As OVERLAPPED) As Long
'
' Configures a communications device according to the specifications
' in a device-control block (a DCB structure). The function
' reinitializes all hardware and control settings, but it does not
' empty output or input queues.
'
Declare Function SetCommState Lib "kernel32" _
    (ByVal hCommDev As Long, lpDCB As DCB) As Long
'
' Sets the time-out parameters for all read and write operations on a
' specified communications device.
'
Declare Function SetCommTimeouts Lib "kernel32" _
    (ByVal hFile As Long, lpCommTimeouts As COMMTIMEOUTS) As Long
'
' Initializes the communications parameters for a specified
' communications device.
'
Declare Function SetupComm Lib "kernel32" _
    (ByVal hFile As Long, ByVal dwInQueue As Long, ByVal dwOutQueue As Long) As Long
'
' Writes data to a file and is designed for both synchronous and a
' synchronous operation. The function starts writing data to the file
' at the position indicated by the file pointer. After the write
' operation has been completed, the file pointer is adjusted by the
' number of bytes actually written, except when the file is opened with
' FILE_FLAG_OVERLAPPED. If the file handle was created for overlapped
' input and output (I/O), the application must adjust the position of
' the file pointer after the write operation is finished.
'
Declare Function WriteFile Lib "kernel32" _
    (ByVal hFile As Long, ByVal lpBuffer As String, _
    ByVal nNumberOfBytesToWrite As Long, lpNumberOfBytesWritten As Long, _
    lpOverlapped As OVERLAPPED) As Long

'-------------------------------------------------------------------------------
' Program Constants
'-------------------------------------------------------------------------------

Private Const MAX_PORTS = 5

'-------------------------------------------------------------------------------
' Program Structures
'-------------------------------------------------------------------------------

Private Type COMM_ERROR
    lngErrorCode As Long
    strFunction As String
    strErrorMessage As String
End Type

Private Type COMM_PORT
    lngHandle As Long
    blnPortOpen As Boolean
    udtDCB As DCB
End Type

'-------------------------------------------------------------------------------
' Program Storage
'-------------------------------------------------------------------------------

Private udtCommOverlap As OVERLAPPED
Private udtCommError As COMM_ERROR
Private udtPorts(1 To MAX_PORTS) As COMM_PORT
'-------------------------------------------------------------------------------
' GetSystemMessage - Gets system error text for the specified error code.
'-------------------------------------------------------------------------------
Public Function GetSystemMessage(lngErrorCode As Long) As String
Dim intPos As Integer
Dim strMessage As String, strMsgBuff As String * 256

    Call FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, 0, lngErrorCode, 0, strMsgBuff, 255, 0)

    intPos = InStr(1, strMsgBuff, vbNullChar)
    If intPos > 0 Then
        strMessage = Trim$(Left$(strMsgBuff, intPos - 1))
    Else
        strMessage = Trim$(strMsgBuff)
    End If
    
    GetSystemMessage = strMessage
    
End Function


'-------------------------------------------------------------------------------
' CommOpen - Opens/Initializes serial port.
'
'
' Parameters:
'   intPortID   - Port ID used when port was opened.
'   strPort     - COM port name. (COM1, COM2, COM3, COM4)
'   strSettings - Communication settings.
'                 Example: "baud=9600 parity=N data=8 stop=1"
'
' Returns:
'   Error Code  - 0 = No Error.
'
'-------------------------------------------------------------------------------
Public Function CommOpen(intPortID As Integer, strPort As String, _
    strSettings As String) As Long
    
Dim lngStatus       As Long
Dim udtCommTimeOuts As COMMTIMEOUTS

    On Error GoTo Routine_Error
    
    ' See if port already in use.
    If udtPorts(intPortID).blnPortOpen Then
        lngStatus = -1
        With udtCommError
            .lngErrorCode = lngStatus
            .strFunction = "CommOpen"
            .strErrorMessage = "Port in use."
        End With
        
        GoTo Routine_Exit
    End If

    ' Open serial port.
    udtPorts(intPortID).lngHandle = CreateFile(strPort, GENERIC_READ Or _
        GENERIC_WRITE, 0, ByVal 0&, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0)

    If udtPorts(intPortID).lngHandle = -1 Then
        lngStatus = SetCommError("CommOpen (CreateFile)")
        GoTo Routine_Exit
    End If

    udtPorts(intPortID).blnPortOpen = True

    ' Setup device buffers (1K each).
    lngStatus = SetupComm(udtPorts(intPortID).lngHandle, 1024, 1024)
    
    If lngStatus = 0 Then
        lngStatus = SetCommError("CommOpen (SetupComm)")
        GoTo Routine_Exit
    End If

    ' Purge buffers.
    lngStatus = PurgeComm(udtPorts(intPortID).lngHandle, PURGE_TXABORT Or _
        PURGE_RXABORT Or PURGE_TXCLEAR Or PURGE_RXCLEAR)

    If lngStatus = 0 Then
        lngStatus = SetCommError("CommOpen (PurgeComm)")
        GoTo Routine_Exit
    End If

    ' Set serial port timeouts.
    With udtCommTimeOuts
        .ReadIntervalTimeout = -1
        .ReadTotalTimeoutMultiplier = 0
        .ReadTotalTimeoutConstant = 1000
        .WriteTotalTimeoutMultiplier = 0
        .WriteTotalTimeoutMultiplier = 1000
    End With

    lngStatus = SetCommTimeouts(udtPorts(intPortID).lngHandle, udtCommTimeOuts)

    If lngStatus = 0 Then
        lngStatus = SetCommError("CommOpen (SetCommTimeouts)")
        GoTo Routine_Exit
    End If

    ' Get the current state (DCB).
    lngStatus = GetCommState(udtPorts(intPortID).lngHandle, _
        udtPorts(intPortID).udtDCB)

    If lngStatus = 0 Then
        lngStatus = SetCommError("CommOpen (GetCommState)")
        GoTo Routine_Exit
    End If

    ' Modify the DCB to reflect the desired settings.
    lngStatus = BuildCommDCB(strSettings, udtPorts(intPortID).udtDCB)

    If lngStatus = 0 Then
        lngStatus = SetCommError("CommOpen (BuildCommDCB)")
        GoTo Routine_Exit
    End If

    ' Set the new state.
    lngStatus = SetCommState(udtPorts(intPortID).lngHandle, _
        udtPorts(intPortID).udtDCB)

    If lngStatus = 0 Then
        lngStatus = SetCommError("CommOpen (SetCommState)")
        GoTo Routine_Exit
    End If

    lngStatus = 0

Routine_Exit:
    CommOpen = lngStatus
    Exit Function

Routine_Error:
    lngStatus = Err.Number
    With udtCommError
        .lngErrorCode = lngStatus
        .strFunction = "CommOpen"
        .strErrorMessage = Err.Description
    End With
    Resume Routine_Exit
End Function


Private Function SetCommError(strFunction As String) As Long
    
    With udtCommError
        .lngErrorCode = Err.LastDllError
        .strFunction = strFunction
        .strErrorMessage = GetSystemMessage(.lngErrorCode)
        SetCommError = .lngErrorCode
    End With
    
End Function

Private Function SetCommErrorEx(strFunction As String, lngHnd As Long) As Long
Dim lngErrorFlags As Long
Dim udtCommStat As COMSTAT
    
    With udtCommError
        .lngErrorCode = GetLastError
        .strFunction = strFunction
        .strErrorMessage = GetSystemMessage(.lngErrorCode)
    
        Call ClearCommError(lngHnd, lngErrorFlags, udtCommStat)
    
        .strErrorMessage = .strErrorMessage & "  COMM Error Flags = " & _
                Hex$(lngErrorFlags)
        
        SetCommErrorEx = .lngErrorCode
    End With
    
End Function

'-------------------------------------------------------------------------------
' CommSet - Modifies the serial port settings.
'
' Parameters:
'   intPortID   - Port ID used when port was opened.
'   strSettings - Communication settings.
'                 Example: "baud=9600 parity=N data=8 stop=1"
'
' Returns:
'   Error Code  - 0 = No Error.
'-------------------------------------------------------------------------------
Public Function CommSet(intPortID As Integer, strSettings As String) As Long
    
Dim lngStatus As Long
    
    On Error GoTo Routine_Error

    lngStatus = GetCommState(udtPorts(intPortID).lngHandle, _
        udtPorts(intPortID).udtDCB)

    If lngStatus = 0 Then
        lngStatus = SetCommError("CommSet (GetCommState)")
        GoTo Routine_Exit
    End If

    lngStatus = BuildCommDCB(strSettings, udtPorts(intPortID).udtDCB)

    If lngStatus = 0 Then
        lngStatus = SetCommError("CommSet (BuildCommDCB)")
        GoTo Routine_Exit
    End If

    lngStatus = SetCommState(udtPorts(intPortID).lngHandle, _
        udtPorts(intPortID).udtDCB)

    If lngStatus = 0 Then
        lngStatus = SetCommError("CommSet (SetCommState)")
        GoTo Routine_Exit
    End If

    lngStatus = 0

Routine_Exit:
    CommSet = lngStatus
    Exit Function

Routine_Error:
    lngStatus = Err.Number
    With udtCommError
        .lngErrorCode = lngStatus
        .strFunction = "CommSet"
        .strErrorMessage = Err.Description
    End With
    Resume Routine_Exit
End Function

'-------------------------------------------------------------------------------
' CommClose - Close the serial port.
'
' Parameters:
'   intPortID   - Port ID used when port was opened.
'
' Returns:
'   Error Code  - 0 = No Error.
'-------------------------------------------------------------------------------
Public Function CommClose(intPortID As Integer) As Long
    
Dim lngStatus As Long
    
    On Error GoTo Routine_Error

    If udtPorts(intPortID).blnPortOpen Then
        lngStatus = CloseHandle(udtPorts(intPortID).lngHandle)
    
        If lngStatus = 0 Then
            lngStatus = SetCommError("CommClose (CloseHandle)")
            GoTo Routine_Exit
        End If
    
        udtPorts(intPortID).blnPortOpen = False
    End If

    lngStatus = 0

Routine_Exit:
    CommClose = lngStatus
    Exit Function

Routine_Error:
    lngStatus = Err.Number
    With udtCommError
        .lngErrorCode = lngStatus
        .strFunction = "CommClose"
        .strErrorMessage = Err.Description
    End With
    Resume Routine_Exit
End Function

'-------------------------------------------------------------------------------
' CommFlush - Flush the send and receive serial port buffers.
'
' Parameters:
'   intPortID   - Port ID used when port was opened.
'
' Returns:
'   Error Code  - 0 = No Error.
'-------------------------------------------------------------------------------
Public Function CommFlush(intPortID As Integer) As Long
    
Dim lngStatus As Long
    
    On Error GoTo Routine_Error

    lngStatus = PurgeComm(udtPorts(intPortID).lngHandle, PURGE_TXABORT Or _
        PURGE_RXABORT Or PURGE_TXCLEAR Or PURGE_RXCLEAR)

    If lngStatus = 0 Then
        lngStatus = SetCommError("CommFlush (PurgeComm)")
        GoTo Routine_Exit
    End If

    lngStatus = 0

Routine_Exit:
    CommFlush = lngStatus
    Exit Function

Routine_Error:
    lngStatus = Err.Number
    With udtCommError
        .lngErrorCode = lngStatus
        .strFunction = "CommFlush"
        .strErrorMessage = Err.Description
    End With
    Resume Routine_Exit
End Function

'-------------------------------------------------------------------------------
' CommRead - Read serial port input buffer.
'
' Parameters:
'   intPortID   - Port ID used when port was opened.
'   str         - Data buffer.
'   lngSize     - Maximum number of bytes to be read.
'
' Returns:
'   Error Code  - 0 = No Error.
'-------------------------------------------------------------------------------
Public Function CommRead(intPortID As Integer, ByRef str As String, _
    lngSize As Long) As Long

Dim lngStatus As Long
Dim lngRdSize As Long, lngBytesRead As Long
Dim lngRdStatus As Long, strRdBuffer As String * 1024
Dim lngErrorFlags As Long, udtCommStat As COMSTAT
    
    On Error GoTo Routine_Error

    str = ""
    lngBytesRead = 0
    DoEvents
    
    ' Clear any previous errors and get current status.
    lngStatus = ClearCommError(udtPorts(intPortID).lngHandle, lngErrorFlags, _
        udtCommStat)

    If lngStatus = 0 Then
        lngBytesRead = -1
        lngStatus = SetCommError("CommRead (ClearCommError)")
        GoTo Routine_Exit
    End If
        
    If udtCommStat.cbInQue > 0 Then
        'lngRdSize = 1
        If udtCommStat.cbInQue > lngSize Then
            lngRdSize = udtCommStat.cbInQue
        Else
            lngRdSize = lngSize
        End If
    Else
        lngRdSize = 0
    End If

    If lngRdSize Then
        lngRdStatus = ReadFile(udtPorts(intPortID).lngHandle, strRdBuffer, _
            lngRdSize, lngBytesRead, udtCommOverlap)

        If lngRdStatus = 0 Then
            lngStatus = GetLastError
            If lngStatus = ERROR_IO_PENDING Then
                ' Wait for read to complete.
                ' This function will timeout according to the
                ' COMMTIMEOUTS.ReadTotalTimeoutConstant variable.
                ' Every time it times out, check for port errors.

                ' Loop until operation is complete.
                While GetOverlappedResult(udtPorts(intPortID).lngHandle, _
                    udtCommOverlap, lngBytesRead, True) = 0
                                    
                    lngStatus = GetLastError
                                        
                    If lngStatus <> ERROR_IO_INCOMPLETE Then
                        lngBytesRead = -1
                        lngStatus = SetCommErrorEx( _
                            "CommRead (GetOverlappedResult)", _
                            udtPorts(intPortID).lngHandle)
                        GoTo Routine_Exit
                    End If
                Wend
            Else
                ' Some other error occurred.
                lngBytesRead = -1
                lngStatus = SetCommErrorEx("CommRead (ReadFile)", _
                    udtPorts(intPortID).lngHandle)
                GoTo Routine_Exit
            
            End If
        End If
    
        str = Left$(strRdBuffer, lngBytesRead)
    End If

Routine_Exit:
    CommRead = lngBytesRead
    Exit Function

Routine_Error:
    lngBytesRead = -1
    lngStatus = Err.Number
    With udtCommError
        .lngErrorCode = lngStatus
        .strFunction = "CommRead"
        .strErrorMessage = Err.Description
    End With
    Resume Routine_Exit
End Function

'-------------------------------------------------------------------------------
' CommWrite - Output data to the serial port.
'
' Parameters:
'   intPortID   - Port ID used when port was opened.
'   str         - Data to be transmitted.
'
' Returns:
'   Error Code  - 0 = No Error.
'-------------------------------------------------------------------------------
Public Function CommWrite(intPortID As Integer, str As String) As Long
    
Dim i As Integer
Dim lngStatus As Long, lngSize As Long
Dim lngWrSize As Long, lngWrStatus As Long
    
    On Error GoTo Routine_Error
    
    ' Get the length of the data.
    lngSize = Len(str)

    ' Output the data.
    lngWrStatus = WriteFile(udtPorts(intPortID).lngHandle, str, lngSize, _
        lngWrSize, udtCommOverlap)

    ' Note that normally the following code will not execute because the driver
    ' caches write operations. Small I/O requests (up to several thousand bytes)
    ' will normally be accepted immediately and WriteFile will return true even
    ' though an overlapped operation was specified.
        
    DoEvents
    
    If lngWrStatus = 0 Then
        lngStatus = GetLastError
        If lngStatus = 0 Then
            GoTo Routine_Exit
        ElseIf lngStatus = ERROR_IO_PENDING Then
            ' We should wait for the completion of the write operation so we know
            ' if it worked or not.
            '
            ' This is only one way to do this. It might be beneficial to place the
            ' writing operation in a separate thread so that blocking on completion
            ' will not negatively affect the responsiveness of the UI.
            '
            ' If the write takes long enough to complete, this function will timeout
            ' according to the CommTimeOuts.WriteTotalTimeoutConstant variable.
            ' At that time we can check for errors and then wait some more.

            ' Loop until operation is complete.
            While GetOverlappedResult(udtPorts(intPortID).lngHandle, _
                udtCommOverlap, lngWrSize, True) = 0
                                
                lngStatus = GetLastError
                                    
                If lngStatus <> ERROR_IO_INCOMPLETE Then
                    lngStatus = SetCommErrorEx( _
                        "CommWrite (GetOverlappedResult)", _
                        udtPorts(intPortID).lngHandle)
                    GoTo Routine_Exit
                End If
            Wend
        Else
            ' Some other error occurred.
            lngWrSize = -1
                    
            lngStatus = SetCommErrorEx("CommWrite (WriteFile)", _
                udtPorts(intPortID).lngHandle)
            GoTo Routine_Exit
        
        End If
    End If
    
    For i = 1 To 10
        DoEvents
    Next
    
Routine_Exit:
    CommWrite = lngWrSize
    Exit Function

Routine_Error:
    lngStatus = Err.Number
    With udtCommError
        .lngErrorCode = lngStatus
        .strFunction = "CommWrite"
        .strErrorMessage = Err.Description
    End With
    Resume Routine_Exit
End Function

'-------------------------------------------------------------------------------
' CommGetLine - Get the state of selected serial port control lines.
'
' Parameters:
'   intPortID   - Port ID used when port was opened.
'   intLine     - Serial port line. CTS, DSR, RING, RLSD (CD)
'   blnState    - Returns state of line (Cleared or Set).
'
' Returns:
'   Error Code  - 0 = No Error.
'-------------------------------------------------------------------------------
Public Function CommGetLine(intPortID As Integer, intLine As Integer, _
   blnState As Boolean) As Long
    
Dim lngStatus As Long
Dim lngComStatus As Long, lngModemStatus As Long
    
    On Error GoTo Routine_Error

    lngStatus = GetCommModemStatus(udtPorts(intPortID).lngHandle, lngModemStatus)

    If lngStatus = 0 Then
        lngStatus = SetCommError("CommReadCD (GetCommModemStatus)")
        GoTo Routine_Exit
    End If

    If (lngModemStatus And intLine) Then
        blnState = True
    Else
        blnState = False
    End If
        
    lngStatus = 0
        
Routine_Exit:
    CommGetLine = lngStatus
    Exit Function

Routine_Error:
    lngStatus = Err.Number
    With udtCommError
        .lngErrorCode = lngStatus
        .strFunction = "CommReadCD"
        .strErrorMessage = Err.Description
    End With
    Resume Routine_Exit
End Function

'-------------------------------------------------------------------------------
' CommSetLine - Set the state of selected serial port control lines.
'
' Parameters:
'   intPortID   - Port ID used when port was opened.
'   intLine     - Serial port line. BREAK, DTR, RTS
'                 Note: BREAK actually sets or clears a "break" condition on
'                 the transmit data line.
'   blnState    - Sets the state of line (Cleared or Set).
'
' Returns:
'   Error Code  - 0 = No Error.
'-------------------------------------------------------------------------------
Public Function CommSetLine(intPortID As Integer, intLine As Integer, _
   blnState As Boolean) As Long
   
Dim lngStatus As Long
Dim lngNewState As Long
    
    On Error GoTo Routine_Error
    
    If intLine = LINE_BREAK Then
        If blnState Then
            lngNewState = SETBREAK
        Else
            lngNewState = CLRBREAK
        End If
    
    ElseIf intLine = LINE_DTR Then
        If blnState Then
            lngNewState = SETDTR
        Else
            lngNewState = CLRDTR
        End If
    
    ElseIf intLine = LINE_RTS Then
        If blnState Then
            lngNewState = SETRTS
        Else
            lngNewState = CLRRTS
        End If
    End If

    lngStatus = EscapeCommFunction(udtPorts(intPortID).lngHandle, lngNewState)

    If lngStatus = 0 Then
        lngStatus = SetCommError("CommSetLine (EscapeCommFunction)")
        GoTo Routine_Exit
    End If

    lngStatus = 0
        
Routine_Exit:
    CommSetLine = lngStatus
    Exit Function

Routine_Error:
    lngStatus = Err.Number
    With udtCommError
        .lngErrorCode = lngStatus
        .strFunction = "CommSetLine"
        .strErrorMessage = Err.Description
    End With
    Resume Routine_Exit
End Function



'-------------------------------------------------------------------------------
' CommGetError - Get the last serial port error message.
'
' Parameters:
'   strMessage  - Error message from last serial port error.
'
' Returns:
'   Error Code  - Last serial port error code.
'-------------------------------------------------------------------------------
Public Function CommGetError(strMessage As String) As Long
    
    With udtCommError
        CommGetError = .lngErrorCode
        strMessage = "Error (" & CStr(.lngErrorCode) & "): " & .strFunction & _
            " - " & .strErrorMessage
    End With
    
End Function


' InQuest injected base64 decoded content
' y:-jT

INQUEST-PP=macro
