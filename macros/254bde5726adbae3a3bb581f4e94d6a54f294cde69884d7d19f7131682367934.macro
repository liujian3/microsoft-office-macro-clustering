Attribute VB_Name = "AAA_ExportCode"
Option Explicit

Private Sub CreateXLAXLAM()
  Application.DisplayAlerts = False
  WBRemoveTags
  ThisWorkbook.IsAddin = True
'  ThisWorkbook.SaveAs ThisWorkbook.path & "\Excel-Sheet-Checker.xlam", xlOpenXMLAddIn
  ThisWorkbook.SaveAs ThisWorkbook.path & "\Excel-Sheet-Checker.xla", xlAddIn
  ThisWorkbook.IsAddin = False
  ThisWorkbook.Saved = True
  Application.DisplayAlerts = True
End Sub


Private Sub WBRemoveTags()

    Dim nameItem As Excel.name

GoAgain:
    Dim i As Long
    If ThisWorkbook.names.count > 0 Then
      For i = 1 To ThisWorkbook.names.count
          If ThisWorkbook.names(i).Visible = False Then
              If Left(ThisWorkbook.names(i).name, Len("_IDVTracker")) = "_IDVTracker" Then
                  Debug.Print "Deleted: " & ThisWorkbook.names(i).name
                  ThisWorkbook.names.item(i).Delete
                  GoTo GoAgain
              End If
          End If
      Next i
    End If

End Sub



Private Sub ExportMyModules()

  Dim cm
  Dim counter As Long
  MkFullDir ThisWorkbook.path & "\vba"
  MyKill ThisWorkbook.path & "\vba\*.bas"
  MyKill ThisWorkbook.path & "\vba\*.cls"
  MyKill ThisWorkbook.path & "\vba\*.frx"
  MyKill ThisWorkbook.path & "\vba\*.frm"
  For Each cm In ThisWorkbook.VBProject.VBComponents
    If Not IsNull(cm) Then
      If cm.CodeModule.CountOfLines > 0 Then
        ExportVBComponent cm, ThisWorkbook.path & "\vba"
      End If
    End If
  Next

End Sub

Private Sub ExportToVB6Project()
  
  Dim pth As String
  pth = "D:\development\Excel-Sheet-QA.VB6"

  Dim cm
  Dim counter As Long
  For Each cm In ThisWorkbook.VBProject.VBComponents
    If Not IsNull(cm) Then
      If cm.CodeModule.CountOfLines > 0 Then
        ExportVBComponent cm, pth & "", , , True
      End If
    End If
  Next

End Sub

Private Sub ExportToDotNetProject()
  
  Dim pth As String
  pth = "D:\development\Exp\ESQA.NET"

  Dim cm
  Dim counter As Long
  For Each cm In ThisWorkbook.VBProject.VBComponents
    If Not IsNull(cm) Then
      If cm.CodeModule.CountOfLines > 0 Then
        ExportVBComponent cm, pth & "", , , , True
      End If
    End If
  Next

End Sub

Private Function CorrectDotNet(ByVal strFile As String) As Boolean
  Dim pos1 As Long
  Dim pos2 As Long
  Dim tFile As String
  On Error GoTo binCheck
  tFile = ReadTextfile(strFile)
  If Len(tFile) > 0 Then
  
    Dim pos As Long
    Dim newtFile As String
    Dim lastChar As String
    For pos = 1 To Len(tFile)
      If pos > 1 Then lastChar = Mid(tFile, pos - 1, 1)
      
      ' Kommentare
      If Mid(tFile, pos, 1) = "'" Then
        newtFile = newtFile & "'"
        pos = pos + 1
        Do While pos <= Len(tFile)
          If Mid(tFile, pos, 2) = vbCrLf Then
            newtFile = newtFile & vbCrLf
            pos = pos + 2
            Exit Do
          Else
            newtFile = newtFile & Mid(tFile, pos, 1)
            pos = pos + 1
          End If
        Loop
      
      ' Strings
      ElseIf Mid(tFile, pos, 1) = Chr(34) Then
        newtFile = newtFile & "'"
        pos = pos + 1
        Do While pos <= Len(tFile)
          If Mid(tFile, pos, 2) = Chr(34) & Chr(34) Then
            newtFile = newtFile & Chr(34) & Chr(34)
            pos = pos + 2
          ElseIf Mid(tFile, pos, 1) = Chr(34) Then
            newtFile = newtFile & Chr(34)
            pos = pos + 1
            Exit Do
          Else
            newtFile = newtFile & Mid(tFile, pos, 1)
            pos = pos + 1
          End If
        Loop
      ' SET
      ElseIf UCase(Mid(tFile, pos, 4)) = "SET " And (lastChar = "" Or lastChar = vbLf Or lastChar = " ") Then
        pos = pos + 3
      ' SET
      ElseIf UCase(Mid(tFile, pos, 4)) = "SET " And (lastChar = "" Or lastChar = vbLf Or lastChar = " ") Then
        pos = pos + 3
      Else
      
        Dim s As String
        s = GetNextText(tFile, pos)
      
      End If
      
      
    Next pos
  
  
    MyKill strFile
    WriteTextfile strFile, tFile
    CorrectDotNet = True
    Exit Function
  End If
  
binCheck:
End Function

Private Function ReplaceTextInTextfileVB6(ByVal strFile As String) As Boolean
  Dim pos1 As Long
  Dim pos2 As Long
  Dim tFile As String
  On Error GoTo binCheck
  tFile = ReadTextfile(strFile)
  If Len(tFile) > 0 Then
    tFile = Replace(tFile, " ActiveWorkbook", " Application.ActiveWorkbook")
    tFile = Replace(tFile, "(ActiveWorkbook", "(Application.ActiveWorkbook")
    tFile = Replace(tFile, " ActiveSheet", " Application.ActiveSheet")
    tFile = Replace(tFile, "(ActiveSheet", "(Application.ActiveSheet")
    MyKill strFile
    WriteTextfile strFile, tFile
    ReplaceTextInTextfileVB6 = True
    Exit Function
  End If
  
binCheck:
End Function



Private Function ExportVBComponent(ByRef VBComp, _
                FolderName As String, _
                Optional Filename As String, _
                Optional OverwriteExisting As Boolean = True, _
                Optional vb6Ext As Boolean = False, _
                Optional vbnetExt As Boolean = False) As Boolean
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' This function exports the code module of a VBComponent to a text
    ' file. If FileName is missing, the code will be exported to
    ' a file with the same name as the VBComponent followed by the
    ' appropriate extension.
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    Dim Extension As String
    Dim fname As String
    Extension = GetFileExtension(VBComp:=VBComp)
    If Trim(Filename) = vbNullString Then
        fname = VBComp.name & Extension
    Else
        fname = Filename
        If InStr(1, fname, ".", vbBinaryCompare) = 0 Then
            fname = fname & Extension
        End If
    End If
    
    If StrComp(Right(FolderName, 1), "\", vbBinaryCompare) = 0 Then
        fname = FolderName & fname
    Else
        fname = FolderName & "\" & fname
    End If
    
    If Dir(fname, vbNormal + vbHidden + vbSystem) <> vbNullString Then
        If OverwriteExisting = True Then
            Kill fname
        Else
            ExportVBComponent = False
            Exit Function
        End If
    End If
    
    VBComp.Export Filename:=fname
    
    If vb6Ext Then
      If Not ReplaceTextInTextfileVB6(fname) Then
        Debug.Print "No Replace in " & fname
      End If
    End If
    
    If vbnetExt Then
      Name fname As GetFileNameAndPath(fname) & ".vb"
      fname = GetFileNameAndPath(fname) & ".vb"
'      If Not CorrectDotNet(fname) Then
'        Debug.Print "No CorrectDotNet in " & fname
'      End If
    End If
    
    ExportVBComponent = True
    
    
    End Function
    
    
    
    
Private Function GetFileExtension(ByRef VBComp) As String
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' This returns the appropriate file extension based on the Type of
' the VBComponent.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    Select Case VBComp.Type
        Case 2 ' vbext_ct_ClassModule
            GetFileExtension = ".cls"
        Case 100 ' vbext_ct_Document
            GetFileExtension = ".cls"
        Case 3 ' vbext_ct_MSForm
            GetFileExtension = ".frm"
        Case 1 ' vbext_ct_StdModule
            GetFileExtension = ".bas"
        Case Else
            GetFileExtension = ".bas"
    End Select
    
End Function





Attribute VB_Name = "Analyse"
Option Explicit


' .NET START
Sub EinzelanalyseZelle()

  On Error GoTo nogo
  InitApp
  
  Beenden = False
  
  theFilename = ActiveCell.value
  
  If Not FileExists(theFilename) Then
    'MsgBox "Es kann nicht auf die Datei '" & theFilename & "' zugegriffen werden!", vbCritical, "Excel-Sheet-Checker"
    MsgBox FMT1("ANALYSE_1", theFilename), vbCritical, "Excel-Sheet-Checker"
    Exit Sub
  End If
  
  XLScriptInitDebug
  
  
  ShowStatusForm theFilename
  DoEinzelanalyse
  Exit Sub

nogo:
  'MsgBox "Es ist ein Fehler aufgetreten: " & Err.Number & " - " & Err.Description, , vbCritical, "Excel-Sheet-Checker"
  MsgBox FMT2("ANALYSE_2", Err.Number, Err.Description), , vbCritical, FMT0("MM_1")

End Sub
' .NET START


Sub EinzelanalyseStarten()

  InitApp
  
  Beenden = False
  
  Dim Filename
  
  
  'Filename = Application.GetOpenFileName(Texte(GSprache, TXT_XLFILES), 1, "Excel Datei laden")
  Filename = Application.GetOpenFileName(FMT0("TXT_XLFILES"), 1, FMT0("ANALYSE_3"))

  ' War die Eingabe ok?
  If Filename = False Then Exit Sub
  
  theFilename = Filename
  
  
  XLScriptInitDebug
  
  ShowStatusForm theFilename
  DoEinzelanalyse

End Sub



Sub MassenanalyseFortsetzen()
  
  InitApp
  
  'MsgBox "Bitte w|fffd|hlen Sie jetzt eine zuvor erzeugte Ergebnisdatei aus, mit der die Analyse fortgesetzt werden soll!", vbInformation, "Excel-Sheet-Checker"
  MsgBox FMT0("ANALYSE_4"), vbInformation, FMT0("MM_1")
  
  Dim Filename
  'Filename = Application.GetOpenFileName(Texte(GSprache, TXT_XLFILES), 1, "Excel Datei laden")
  Filename = Application.GetOpenFileName(FMT0("TXT_XLFILES"), 1, FMT0("ANALYSE_3"))

  If Filename = False Then Exit Sub
  Beenden = False
  
  
  Dim wb As Excel.Workbook
  Set wb = Application.Workbooks.Open(Filename)
  SetLiveStatus
  If Not WorksheetExists(wb, "ECCFiles") Then
    wb.Saved = True
    wb.Close False
    'MsgBox "Die Datei ist keine Ergebnisdatei einer Massenanalyse! Der Vorgang wird abgebrochen.", vbCritical
    MsgBox FMT0("ANALYSE_5"), vbCritical
    Exit Sub
  End If
  
  Dim uebersicht As String
  uebersicht = TranslationSheetExists(wb, Array("|fffd|bersicht", "Overview"))
  wb.Sheets(uebersicht).Select
  wb.Sheets(uebersicht).Range("A1").Select
  Dim r As Range
  'Set r = wb.Sheets(uebersicht).Cells.Find("Abgebrochen!", wb.Sheets("|fffd|bersicht").Range("A1"), xlValues,
  Set r = TranslationFindCells2(wb.Sheets(uebersicht), Array("Abgebrochen!", "Cancelled!"), wb.Sheets(uebersicht).Range("A1"), xlValues, _
      xlPart, xlByRows, xlNext, _
      False, False)
  
  If Not r Is Nothing Then
    If r.Row <> 1 Or r.Column <> 1 Then
      'MsgBox "Bei dieser Ergebnisdatei wurde die Analyse manuell beendet (die Ergebnisdatei wurde finalisiert). Ein Fortsetzen des Vorgangs ist nicht mehr m|fffd|glich.", vbInformation
      MsgBox FMT0("ANALYSE_6"), vbInformation
      wb.Saved = True
      wb.Close False
      Exit Sub
    End If
  End If
  
  wb.Saved = True
  wb.Close False
  
  Dim d As Date
  d = Now
  
  MassenanalyseStartSub Filename, d

End Sub


Sub MassenanalyseStarten()
  
  InitApp
  
  PathSelect.MyInit
  PathSelect.Show
  
  If PathSelect.WasOK = False Then Exit Sub

  If xlsDateien.count <= 0 Then
    'MsgBox "Es konnte keine Dateien gefunden werden, die f|fffd|r die Analyse relevant w|fffd|ren!", vbInformation, "Excel-Sheet-Checker"
    MsgBox FMT0("ANALYSE_7"), vbInformation, FMT0("MM_1")
    Exit Sub
  End If


'  If MsgBox("M|fffd|chten Sie eine Schnellanalyse durchf|fffd|hren? (bei NEIN wird eine Detailanalyse auf Formelzellebene durchgef|fffd|hrt)", vbYesNo + vbExclamation, "Excel-Sheet-Checker") = vbYes Then
'    G_Schnellanalyse = True
'  Else
'    G_Schnellanalyse = False
'  End If
  
  
  'MsgBox "Bitte geben Sie jetzt den Dateinamen f|fffd|r die Ergebnisdatei ein!", vbInformation, "Excel-Sheet-Checker"
  MsgBox FMT0("ANALYSE_8"), vbInformation, FMT0("MM_1")
  
  Dim Filename
      
  'Filename = Application.GetSaveAsFilename("*.xls", "Excel (*.xls),*.xls", , Texte(GSprache, TXT_ERGEBNISSPEICHERN))
  Filename = Application.GetSaveAsFilename("*.xlsx", "Excel (*.xlsx),*.xlsx", , FMT0("TXT_ERGEBNISSPEICHERN"))

  If Filename = False Then Exit Sub
  
  Beenden = False
  
  
  
  Dim wb As Excel.Workbook
  Dim resFile As String
  
  If G_Schnellanalyse Then
    'Set wb = Workbooks.Add(ThisWorkbook.path & "\ECC-MassenanalyseSchnell.xltx")
    If FileExists(ThisWorkbook.path & "\ECC-MassenanalyseSchnell_Indiv.xltx") Then
      resFile = gTranslation.GetLocalizedFile(ThisWorkbook.path & "\ECC-MassenanalyseSchnell_Indiv.xltx")
    Else
      resFile = gTranslation.GetLocalizedFile(ThisWorkbook.path & "\ECC-MassenanalyseSchnell.xltx")
    End If
    Set wb = Workbooks.Add(resFile)
  Else
  
    'Set wb = Workbooks.Add(ThisWorkbook.path & "\ECC-Massenanalyse.xltx")
    If FileExists(ThisWorkbook.path & "\ECC-Massenanalyse_Indiv.xltx") Then
      resFile = gTranslation.GetLocalizedFile(ThisWorkbook.path & "\ECC-Massenanalyse_Indiv.xltx")
    Else
      resFile = gTranslation.GetLocalizedFile(ThisWorkbook.path & "\ECC-Massenanalyse.xltx")
    End If
    Set wb = Workbooks.Add(resFile)
  End If
  
  On Error Resume Next
  wb.Saved = True
  
  
  Dim sfitem As ScanFile
  Dim x As Long
  x = 0
  With wb.Sheets("ECCFiles")
  For Each sfitem In xlsDateien
    If UCase(sfitem.m_Name) <> UCase(ThisWorkbook.FullName) And UCase(sfitem.m_Name) <> UCase(Filename) Then
        .Cells(2 + WorksheetFunction.RoundDown(x / 255, 0), 1 + x Mod 255) = sfitem.m_Name
        x = x + 1
    End If
  Next sfitem
  
  .Cells(1, 1) = 1
  .Cells(1, 2) = 0
  '.Cells(1, 3) = IIf(G_CheckDimension = True, "Ja", "Nein")
  .Cells(1, 3) = IIf(G_CheckDimension = True, FMT0("ANALYSE_10"), FMT0("ANALYSE_11"))
  '.Cells(1, 4) = IIf(G_Schnellanalyse = True, "Ja", "Nein")
  .Cells(1, 4) = IIf(G_Schnellanalyse = True, FMT0("ANALYSE_10"), FMT0("ANALYSE_11"))

  End With
  
  
  wb.SaveAs Filename
  On Error GoTo 0
  
  If Not wb.Saved Then
    wb.Close False
    Set wb = Nothing
    Exit Sub
  End If
  
  XLScriptInitGlobals
  
  Dim d As Date
  d = Now
  XLScriptAddSimpleVar "STARTOFSCAN", d
  
  If PathSelect.selMonate <> 10000 Then
    'XLScriptAddSimpleVar "FILTERNOTEARLIERTHAN", Texte(GSprache, TXT_NAEA) & Format(DateAdd("m", -PathSelect.selMonate, Now()), "Short Date")
    XLScriptAddSimpleVar "FILTERNOTEARLIERTHAN", FMT0("TXT_NAEA") & Format(DateAdd("m", -PathSelect.selMonate, Now()), "Short Date")
  Else
    XLScriptAddSimpleVar "FILTERNOTEARLIERTHAN", "'-/-"
  End If
  
  If PathSelect.selKB <> 0 Then
    'XLScriptAddSimpleVar "FILTERNOTSMALLERTHAN", Texte(GSprache, TXT_NKA) & PathSelect.selKB & " Kb"
    XLScriptAddSimpleVar "FILTERNOTSMALLERTHAN", FMT0("TXT_NKA") & PathSelect.selKB & " Kb"
  Else
    XLScriptAddSimpleVar "FILTERNOTSMALLERTHAN", "'-/-"
  End If
  
  If PathSelect.selUnterverzeichnisseIgnorieren = True Then
    'XLScriptAddSimpleVar "FILTERIGNORESUBDIRECTORIES", Texte(GSprache, TXT_UVI)
    XLScriptAddSimpleVar "FILTERIGNORESUBDIRECTORIES", FMT0("TXT_UVI")
  Else
    XLScriptAddSimpleVar "FILTERIGNORESUBDIRECTORIES", "'-/-"
    If PathSelect.selGleicheNamenIgnorieren = True Then
      'XLScriptAddSimpleVar "FILTERIGNOREIDENTICALNAMES", Texte(GSprache, TXT_GLEICHENAMEN)
      XLScriptAddSimpleVar "FILTERIGNOREIDENTICALNAMES", FMT0("TXT_GLEICHENAMEN")
    Else
      XLScriptAddSimpleVar "FILTERIGNOREIDENTICALNAMES", "'-/-"
    End If
  End If
  
  XLScriptAddSimpleVar "FILTERTOTALUNUSEDFILESSMALLER", TotalUnusedFilesSmaller
  XLScriptAddSimpleVar "FILTERTOTALUNUSEDFILESSMALLERKB", TotalUnusedBytesSmaller / 1024
  XLScriptAddSimpleVar "FILTERTOTALUNUSEDFILESOLDER", TotalUnusedFilesOlder
  XLScriptAddSimpleVar "FILTERTOTALUNUSEDFILESOLDERKB", TotalUnusedBytesOlder / 1024
  XLScriptAddSimpleVar "FILTERTOTALUNUSEDFILESDOUBLE", TotalUnusedFilesDouble
  XLScriptAddSimpleVar "FILTERTOTALUNUSEDFILESDOUBLEKB", TotalUnusedBytesDouble / 1024
  
  Dim scannedpaths As Object
  Set scannedpaths = XLScriptAddArray("SCANPATHS")

  Dim item
  If PathSelect.Verzeichnisse.ListCount > 0 Then
    For item = 0 To PathSelect.Verzeichnisse.ListCount - 1
      scannedpaths.AddValue "", PathSelect.Verzeichnisse.Column(0, item)
    Next item
  End If
  
  
  Dim XLScriptInaccessablePaths As Object
  Set XLScriptInaccessablePaths = XLScriptAddArray("INACCESSABLEPATHS")
  
  If inaccessablePaths.count > 0 Then
    For Each item In inaccessablePaths
      XLScriptInaccessablePaths.AddValue "", CStr(item)
    Next item
  End If
    
  
  
  Dim ws As Excel.Worksheet
  For Each ws In wb.Worksheets
    XLScriptInit ws, "ECC1"
    XLScriptExecCode ws.Cells, 0, 0
    XLScriptExit
  Next ws
  
  
  XLScriptExitGlobals
  
  wb.Save
  wb.Close True
  Set wb = Nothing
  
  
  MassenanalyseStartSub Filename, d


End Sub
  
Sub MassenanalyseStartSub(fname, d As Date)
  
  SaveSetting _
   appname:="Stromwerken", _
   Section:="ECC", _
   Key:="MAErgebnis", _
   setting:=fname
  
  SaveSetting _
   appname:="Stromwerken", _
   Section:="ECC", _
   Key:="MAStart", _
   setting:=d
  
  SaveSetting _
  appname:="Stromwerken", _
  Section:="ECC", _
  Key:="MAStatus", _
  setting:="Init"
  
  SaveSetting _
  appname:="Stromwerken", _
  Section:="ECC", _
  Key:="CheckDimensions", _
  setting:=IIf(G_CheckDimension = True, "True", "False")
  
  SaveSetting _
  appname:="Stromwerken", _
  Section:="ECC", _
  Key:="Schnellanalyse", _
  setting:=IIf(G_Schnellanalyse = True, "True", "False")
  
  
  Set xlsDateien = Nothing
  Set inaccessablePaths = Nothing
  
  ShowStatusForm ""
  DoMassenanalyse

End Sub
Attribute VB_Name = "Arrows"
Option Explicit

Function GetArrows(c As Range, ByRef col As Collection, prec As Boolean, onlyAreas As Boolean) As Boolean
  On Error GoTo nogo
  Dim ac As Range
  Set ac = ActiveCell
  Set col = New Collection
    
  Dim rLast As Range, iLinkNum As Integer, iArrowNum As Integer
  Dim stMsg As String
'  c.Parent.Activate
  c.Activate
  If prec = True Then
    ActiveCell.ShowPrecedents
  Else
    ActiveCell.ShowDependents
  End If

  Set rLast = ActiveCell
  iArrowNum = 1
  iLinkNum = 1
  
  
  Dim wasNewArrow As Boolean
  
  wasNewArrow = True
  
  Do
      Do
          Application.GoTo rLast
          If Not NavArrow(ActiveCell, iArrowNum, iLinkNum, prec) Then
            If wasNewArrow Then
              rLast.Parent.ClearArrows
              Application.GoTo rLast
'              MsgBox "Precedents are" & stMsg
              Exit Function
            Else
              Exit Do
            End If
          End If
          
          ' If iLinkNum > 10 Then
          If rLast.Address(external:=True) = ActiveCell.Address(external:=True) Then
              rLast.Parent.ClearArrows
              Application.GoTo rLast
              If col.count > 0 Then GetArrows = True
              Exit Function
          End If
          
          If onlyAreas Then
            If InStr(Selection.Address, ":") > 0 Then
              col.Add Selection
            End If
          Else
            col.Add Selection
          End If
          
          iLinkNum = iLinkNum + 1  ' try another  link
          wasNewArrow = False
       Loop
       iLinkNum = 1
       wasNewArrow = True
       iArrowNum = iArrowNum + 1  'try another arrow
  Loop
  rLast.Parent.ClearArrows
  Application.GoTo rLast

  If col.count > 0 Then GetArrows = True
  
  ac.Activate
  
nogo:

End Function

Function NavArrow(c As Range, iArrowNum As Integer, iLinkNum As Integer, prez As Boolean) As Boolean
  On Error GoTo waserror
  c.NavigateArrow TowardPrecedent:=prez, ArrowNumber:=iArrowNum, LinkNumber:=iLinkNum
  NavArrow = True
  Exit Function
waserror:
  NavArrow = False
End Function

Attribute VB_Name = "CAppCommand"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public m_Command As String
Public m_ParameterString As String
Public m_Parameter As Collection


Sub Init(ByVal cmdstring As String)
  Dim pos As Long
  pos = InStr(cmdstring, " ")
  If pos > 0 Then
    m_Command = UCase(Trim(Left(cmdstring, pos - 1)))
    m_ParameterString = Trim(Mid(cmdstring, pos + 1, 10000))
  Else
    m_Command = UCase(Trim(cmdstring))
  End If
  Set m_Parameter = New Collection
End Sub

Sub AddParameter(ByVal partype As Long, ByVal parname As String, ByVal paroptional)
  Dim cacp As New CAppCommandParameter
  cacp.Init partype, parname, paroptional
  m_Parameter.Add cacp
End Sub

Function CheckValues(ByRef errString As String) As Boolean

  Dim parstring As String
  parstring = m_ParameterString
  
  Dim cacp As CAppCommandParameter
  For Each cacp In m_Parameter
    cacp.CheckValue parstring, errString
  Next cacp
    
  If Len(Trim(parstring)) > 0 Then
    errString = errString & IIf(errString <> "", vbCrLf, "") & "Unbekannte oder nicht erlaubte Parameter '" & parstring & "'"
  End If
  
  If errString <> "" Then
    errString = "Error in Command '" & m_Command & "': " & errString
  End If
  
End Function

Function GetValue(ByRef parname As String) As Variant
  Dim cacp As CAppCommandParameter
  For Each cacp In m_Parameter
    If cacp.m_Name = parname Then
      GetValue = cacp.m_Value
      Exit Function
    End If
  Next cacp
  GetValue = ""
End Function

Function ParameterExists(ByRef parname As String) As Boolean
  Dim cacp As CAppCommandParameter
  For Each cacp In m_Parameter
    If cacp.m_Name = parname Then
      If cacp.m_Found Then
        ParameterExists = True
      End If
      Exit Function
    End If
  Next cacp
  ParameterExists = False
End Function

Attribute VB_Name = "CAppCommandParameter"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public m_Type As Long
Public m_Optional As Boolean
Public m_Name As String
Public m_Value As String
Public m_Found As Boolean

Public Sub Init(ByVal partype As Long, ByVal parname As String, ByVal paroptional As Boolean)
  m_Type = partype
  m_Name = UCase(parname)
  m_Optional = paroptional
End Sub

Function CheckValue(ByRef parstring As String, ByRef errString As String) As Boolean
  Dim startPos As Long
  Dim pos As Long
  Dim s As String
  Dim ts As String
  Dim tPos As Long
  
  If InStr(parstring, m_Name) > 0 Then
    CheckValue = True
    startPos = InStr(UCase(parstring), m_Name)
    pos = startPos + Len(m_Name)
    s = GetNextValue(parstring, pos, " ")
    
    Dim ok As Boolean
    Select Case m_Type
      Case 0    ' Kein Wert
        m_Found = True
      Case vbInteger
        If IsNumeric(s) Then
          m_Value = s
          m_Found = True
        Else
          errString = errString & IIf(errString <> "", vbCrLf, "") & "Der Wert '" & s & "' in " & m_Name & " ist nicht numerisch!"
          CheckValue = False
        End If
      Case vbTime
        ok = True
        If Not IsDate(s) Then
          ok = False
        End If
        
        If ok Then
          tPos = InStr(s, " ")
          If tPos > 0 Then
            s = Trim(Mid(s, tPos + 1))
          End If
          ts = s
          If Len(ts) <> 8 Then ok = False
          If ok Then If Mid(ts, 3, 1) <> ":" Then ok = False
          If ok Then If Mid(ts, 6, 1) <> ":" Then ok = False
          If ok Then
            If IsNumeric(Val(Mid(ts, 1, 2))) Then
              If Val(Mid(ts, 1, 2)) < 0 Or Val(Mid(ts, 1, 2)) > 23 Then ok = False
            Else
              ok = False
            End If
          End If
          If ok Then
            If IsNumeric(Val(Mid(ts, 4, 2))) Then
              If Val(Mid(ts, 4, 2)) < 0 Or Val(Mid(ts, 4, 2)) > 59 Then ok = False
            Else
              ok = False
            End If
          End If
          If ok Then
            If IsNumeric(Val(Mid(ts, 7, 2))) Then
              If Val(Mid(ts, 7, 2)) < 0 Or Val(Mid(ts, 7, 2)) > 59 Then ok = False
            Else
              ok = False
            End If
          End If
        End If
        
        If ok Then
          m_Value = s
          m_Found = True
        Else
          errString = errString & IIf(errString <> "", vbCrLf, "") & "Der Wert '" & s & "' in " & m_Name & " ist keine Uhrzeit (hh:mm:ss)!"
          CheckValue = False
        End If
      
      Case vbString
        m_Value = s
        m_Found = True
'        Else
'          errString = errString & IIf(errString <> "", vbCrLf, "") & "Der Wert '" & S & "' in " & m_Name & " ist keine String!"
'          CheckValue = False
'        End If
    
      Case vbDate
        If IsDate(s) Then
          m_Value = s
          m_Found = True
        Else
          errString = errString & IIf(errString <> "", vbCrLf, "") & "Der Wert '" & s & "' in " & m_Name & " ist keine Datum!"
          CheckValue = False
        End If
      
      Case Else
        MsgBox "UNDEFINED TYPE in CAppCommandParameter.CheckValue"
    End Select
    Dim newparstring As String
    If startPos > 1 Then
      newparstring = Left(parstring, startPos - 1)
    End If
    If pos < Len(parstring) Then
      newparstring = newparstring & Mid(parstring, pos)
    End If
    parstring = newparstring
  End If

  If m_Found = False And errString = "" And m_Optional = False Then
    CheckValue = False
    errString = errString & IIf(errString <> "", vbCrLf, "") & "Der Parameter " & m_Name & " wurde nicht angegeben, ist aber erforderlich!"
  End If

End Function

Attribute VB_Name = "CSheetProt"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public m_WorksheetProt As Long ' 0 nicht gesch|fffd|tzt, 1 schutz ohne passwort, 2 schutz mit passwort
Public m_ProtectionString As String

Attribute VB_Name = "CfgReader"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Dim m_Lines As Collection
Dim m_Sec As Collection

Private Function GetNextLine(ByRef s As String) As String

    Dim rs As String
    Do
        rs = GetLine(s)
        If Len(Trim(rs)) > 0 Then
            GetNextLine = Trim(rs)
            Exit Function
        End If
        If Len(Trim(s)) <= 0 Then
            GetNextLine = ""
            s = ""
            Exit Function
        End If
    Loop
End Function


Public Sub GetCFGString(ByVal txt As String)
    If m_Lines Is Nothing Then
      Set m_Lines = New Collection
      Set m_Sec = New Collection
    End If
    If Len(txt) = 0 Then Exit Sub
    Dim s As String
    Do
        s = GetNextLine(txt)
        If Len(s) <= 0 Then Exit Do
        If UCase(Left(s, 9)) = "MERGECFG " Then
          GetCfgUniversal Mid(s, 10)
        Else
          If Len(Trim(s)) > 0 Then
            m_Lines.Add s
          End If
          m_Sec.Add s
        End If
    Loop
End Sub

Function GetCfgUTF8(fname As String) As Boolean
  On Error GoTo couldntOpenFile
    Dim adoStream As Object
    Set adoStream = CreateObject("ADODB.Stream")
    
    adoStream.Charset = "UTF-8"
    adoStream.Open
    adoStream.LoadFromFile fname
    GetCFGString adoStream.ReadText
    adoStream.Close
    Set adoStream = Nothing
    GetCfgUTF8 = True
    Exit Function

couldntOpenFile:
  GetCfgUTF8 = False

End Function

Private Function GetEncodingString(encoding As Long) As String
    Select Case encoding
    Case CP_ACP: GetEncodingString = "ANSI"
    Case CP_UTF8: GetEncodingString = "UTF8"
    Case CP_UTF16_LE: GetEncodingString = "UTF16 LE"
    Case CP_UTF16_BE: GetEncodingString = "UTF16 BE"
    Case CP_UTF32_LE: GetEncodingString = "UTF32 LE"
    Case CP_UTF32_BE: GetEncodingString = "UTF32 BE"
    Case Else: GetEncodingString = "Codepage " & CStr(encoding)
    End Select
End Function

Private Function GetCfgUniversal(fname As String) As Boolean
  On Error GoTo couldntOpenFile
    'Dim ff As Long
    'ff = FreeFile
    'Call OpenForInput(fname, ff, encoding)
    Dim encoding As Long
    Dim fileContents As String
    Dim bom As Boolean
    fileContents = GetContents(fname, encoding, -1, bom)
    DebugPrint tinfo, fname & " opened with encoding: " & GetEncodingString(encoding) & IIf(bom, " BOM", " no BOM")
    
    Call GetCFGString(fileContents)
    GetCfgUniversal = True
    
    Exit Function

couldntOpenFile:
  GetCfgUniversal = False
End Function

Function GetCfg(fname As String) As Boolean
  On Error GoTo couldntOpenFile
  Set m_Lines = New Collection
  Set m_Sec = New Collection
  Call GetCfgUniversal(fname)
  
  GetCfg = True
  Exit Function
couldntOpenFile:
  GetCfg = False
End Function

Function GetSection(sec As String) As Boolean
  Set m_Sec = New Collection
  GetSection = GetSectionValues(sec, m_Sec)
End Function

Function GetValue(s As String) As String
  Dim i As Long
  If m_Sec Is Nothing Then Exit Function
  For i = 1 To m_Sec.count
    If Left(m_Sec(i), Len(s) + 1) = s & "=" Then
      GetValue = Trim(Mid(m_Sec(i), Len(s) + 2))
      Exit Function
    ElseIf Left(m_Sec(i), Len(s) + 1) = s & " " Then
        Dim pos As Long
        pos = InStr(m_Sec(i), "=")
        If pos > 0 Then
            GetValue = Trim(Mid(m_Sec(i), pos + 1))
            Exit Function
        End If
    End If
  Next i
  GetValue = ""
End Function

Function GetSectionValues(sec As String, ByRef c As Collection) As Boolean
  Set c = New Collection
  Dim i As Long
  Dim found As Boolean
  found = False
  If Not m_Lines Is Nothing Then
    For i = 1 To m_Lines.count
      If m_Lines(i) = "[" & sec & "]" Then
        i = i + 1
        Do While i <= m_Lines.count
          If Left(m_Lines(i), 1) <> "[" Then
            c.Add m_Lines(i)
            found = True
            i = i + 1
          Else
            Exit Do
          End If
        Loop
      End If
      If i > m_Lines.count Then Exit For
    Next i
  End If
  GetSectionValues = found
End Function


Attribute VB_Name = "CheckinStuff"
Option Explicit

#If VBA7 Then
Declare PtrSafe Sub SWCompressFile Lib "SWPacker.dll" (ByVal a As String, ByVal Level As Integer)
Declare PtrSafe Sub SWDecompressFile Lib "SWPacker.dll" (ByVal a As String)
Declare PtrSafe Sub SWTest Lib "SWPacker.dll" ()
Private Declare PtrSafe Function FreeLibrary Lib "kernel32" (ByVal hLibModule As Long) As Long
Private Declare PtrSafe Function LoadLibrary Lib "kernel32" Alias "LoadLibraryA" (ByVal lpLibFileName As String) As Long
#Else
Declare Sub SWCompressFile Lib "SWPacker.dll" (ByVal a As String, ByVal Level As Integer)
Declare Sub SWDecompressFile Lib "SWPacker.dll" (ByVal a As String)
Declare Sub SWTest Lib "SWPacker.dll" ()
Private Declare Function FreeLibrary Lib "kernel32" (ByVal hLibModule As Long) As Long
Private Declare Function LoadLibrary Lib "kernel32" Alias "LoadLibraryA" (ByVal lpLibFileName As String) As Long
#End If


Function CheckInFile(ByVal fname As String, ByRef rs As Object, checkindat As Date) As Boolean

On Error GoTo nogo

  Dim logtrack As Long
  logtrack = 0

  CheckInFile = False
  
  If Len(G_cfgTemppfad) > 0 Then
      logtrack = 1
      
      'erst mal alte killen falls vorhanden
      If FileExists(G_cfgTemppfad & "\" & rs.Fields("Hash").value) Then
          logtrack = 2
          MyKill G_cfgTemppfad & "\" & rs.Fields("Hash").value
          logtrack = 3
          If FileExists(G_cfgTemppfad & "\" & rs.Fields("Hash").value) Then
            logtrack = 4
            ' DebugPrint DebType.tERROR, "Tempor|fffd|re Datei f|fffd|r '" & rs.Fields("Dateiname").Value & "' nicht gel|fffd|scht(1)"
            ' MsgBox "FEHLER: Die tempor|fffd|re Datei '" & G_cfgTemppfad & "\" & rs.Fields("Hash").Value & "' konnte nicht gel|fffd|scht werden. Bitte informieren Sie Ihre Administration!", vbCritical + vbSystemModal, ProgNameLong & " " & MyVersion
            'AddStatus "FEHLER: Die tempor|fffd|re Datei '" & G_cfgTemppfad & "\" & rs.Fields("Hash").value & "' konnte nicht gel|fffd|scht werden. Bitte informieren Sie Ihre Administration!"
            AddStatus FMT2("CHECKIN_1", G_cfgTemppfad, rs.Fields("Hash").value)
            Exit Function
          End If
          logtrack = 5
      End If
      
      logtrack = 6
      If Not PathExists(G_cfgTemppfad) Then
        ' DebugPrint DebType.tERROR, "CheckInFile: TempPathMissing '" & rs.Fields("Dateiname").Value & "'"
        'AddStatus "FEHLER: Der tempor|fffd|re Pfad '" & G_cfgTemppfad & "' existiert nicht."
        AddStatus FMT1("CHECKIN_2", G_cfgTemppfad)
        Exit Function
      End If
      CopyFile GetDriveAndPathFromUNC(fname), G_cfgTemppfad & "\" & rs.Fields("Hash").value, 0
      logtrack = 7

      If FileExists(G_cfgTemppfad & "\" & rs.Fields("Hash").value) Then
          logtrack = 8
          Dim fehler As String
          If Not xlCheckInBinary(rs.Fields("idvDateiID").value, rs.Fields("Version").value, checkindat, G_cfgTemppfad & "\" & rs.Fields("Hash").value, fehler) Then
            ' DebugPrint DebType.tdebug, "Die Datei '" & rs.Fields("Dateiname").Value & "' konnte nicht eingecheckt werden"
            'AddStatus "FEHLER: Die Datei konnte nicht auf dem Datenbankserver eingecheckt werden! Es wird ein zweiter Versuch gestartet..."
            AddStatus FMT0("CHECKIN_7")
            Sleep 3000
            If Not xlCheckInBinary(rs.Fields("idvDateiID").value, rs.Fields("Version").value, checkindat, G_cfgTemppfad & "\" & rs.Fields("Hash").value, fehler) Then
              ' DebugPrint DebType.tdebug, "Die Datei '" & rs.Fields("Dateiname").Value & "' konnte nicht eingecheckt werden"
              ' MsgBox "Die Datei konnte nicht auf dem Datenbankserver eingecheckt werden! Bitte versuchen Sie es sp|fffd|ter noch einmal!", vbCritical + vbSystemModal, ProgNameLong & " " & MyVersion
              'AddStatus "FEHLER: Die Datei konnte nicht auf dem Datenbankserver eingecheckt werden! Bitte versuchen Sie es sp|fffd|ter noch einmal!"
              DebugPrint DebType.tERROR, "Die Datei '" & rs.Fields("Dateiname").value & "' konnte nicht eingecheckt werden. (" & fehler & ")"
              AddStatus FMT0("CHECKIN_3") & vbCrLf & "(" & fehler & ")"
            Else
              CheckInFile = True
            End If
          Else
            CheckInFile = True
          End If
          logtrack = 9
          MyKill G_cfgTemppfad & "\" & rs.Fields("Hash").value
          
          If FileExists(G_cfgTemppfad & "\" & rs.Fields("Hash").value) Then
            ' DebugPrint DebType.tdebug, "Tempor|fffd|re Datei f|fffd|r '" & rs.Fields("Dateiname").Value & "' nicht gel|fffd|scht(2)"
            ' MsgBox "FEHLER: Die tempor|fffd|re Datei '" & G_cfgTemppfad & "\" & rs.Fields("Hash").Value & "' konnte nicht gel|fffd|scht werden. Bitte informieren Sie Ihre Administration!", vbCritical + vbSystemModal, ProgNameLong & " " & MyVersion
            'AddStatus "FEHLER: Die tempor|fffd|re Datei '" & G_cfgTemppfad & "\" & rs.Fields("Hash").value & "' konnte nicht gel|fffd|scht werden. Bitte informieren Sie Ihre Administration!"
            AddStatus FMT2("CHECKIN_4", G_cfgTemppfad, rs.Fields("Hash").value)
          End If

          logtrack = 19
          Exit Function
      Else
        ' DebugPrint DebType.tERROR, "CheckInFile: No checkin (" & logtrack & "): " & rs.Fields("Dateiname").Value
        ' MsgBox "FEHLER: Die Datei konnte nicht in den tempor|fffd|ren Pfad kopiert werden! Die Datei kann nicht eingecheck werden! Bitte informieren Sie die Administration!", vbCritical + vbSystemModal, ProgNameLong & " " & MyVersion
        'AddStatus "FEHLER: Die Datei konnte nicht in den tempor|fffd|ren Pfad kopiert werden! Die Datei kann nicht eingecheck werden! Bitte informieren Sie die Administration!"
        AddStatus FMT0("CHECKIN_5")
      End If
  Else
    ' DebugPrint DebType.tERROR, "CheckInFile: No checkin (" & logtrack & "): " & rs.Fields("Dateiname").Value
    ' MsgBox "FEHLER: Es ist kein tempor|fffd|rer Pfad konfiguriert! Die Datei kann nicht eingecheck werden! Bitte informieren Sie die Administration!", vbCritical + vbSystemModal, ProgNameLong & " " & MyVersion
    'AddStatus "FEHLER: Es ist kein tempor|fffd|rer Pfad konfiguriert! Die Datei kann nicht eingecheck werden! Bitte informieren Sie die Administration!"
    AddStatus FMT0("CHECKIN_6")
  End If
  
  Exit Function
nogo:
  ' DebugPrint DebType.tERROR, "CheckInFile:" & logtrack
  ' MsgBox "FEHLER: Die Datei '" & rs.Fields("Dateiname").Value & "' kann nicht eingecheck werden!" & Err.Number & " - " & Err.Description & " - " & Err.Source, vbCritical + vbSystemModal, ProgNameLong & " " & MyVersion

End Function

Public Function PackFile(ByVal Filename As String, ByVal copyToTemp As Boolean) As String
    On Error GoTo fehlerPackFile
    
    PackFile = ""
    Dim tempFilename As String
    If copyToTemp Then
        tempFilename = GetFileNameAndPath(CreateTempFile("Tmp")) & GetFileName(Filename)
        CopyFile Filename, tempFilename
    Else
        tempFilename = Filename
    End If
    PackFile = tempFilename

    ' 57 = '0'+9, wird als Ziffer von SWCompressFile in einen String geschrieben
    If FileExists(tempFilename) Then
      Dim lb As Long, pa As Long
      lb = LoadLibrary(ThisWorkbook.path & "\..\bin\SWPacker.dll")
      If lb <> 0 Then
        SWCompressFile tempFilename, 50
        ' MsgBox "Datei gepackt!"
        PackFile = tempFilename + ".gz"
        FreeLibrary lb
      End If
    End If
    
    ' es wurde gepackt und die TempDatei wurde auch oben durch Kopieren erstellt
    ' dann m|fffd|ssen wir die hier wieder l|fffd|schen
    If PackFile <> tempFilename And copyToTemp = True Then
        MyKill tempFilename
    End If
    Exit Function
fehlerPackFile:
On Error GoTo rausAusFunktion
    If lb <> 0 Then
      FreeLibrary lb
    End If
    If PackFile <> tempFilename And copyToTemp = True Then
        MyKill tempFilename
    End If
rausAusFunktion:
End Function

Public Function GetSplitSize() As Long
    ' ab welcher Gr|fffd||fffd|e legen wir mehrere Eintr|fffd|ge in der xlBin Blobs an,
    ' damit wir bei gro|fffd|en Dateien kein OutOfMemory bekommen
    GetSplitSize = CLng(1024) * CLng(1024) * CLng(16)
End Function

Public Function xlCheckInBinary(ByVal idvDateiID As Long, ByVal Version As Long, ByVal dat As Date, ByVal fname As String, ByRef fehler As String) As Boolean
        On Error GoTo fehler
        
        LogPrint "xlCheckInBinary-Start"

        ' Erst mal eine eventuell bereits eingecheckte Datei rauswerfen!
        ' !!!! nicht mehr direkt |fffd|ber xlBin l|fffd|schen sondern |fffd|ber den xlBinUpdate View
        ' ansonsten geht das nicht mit dem Security Zeugs
        ' G_conn.Execute "DELETE FROM xlBin WHERE idvDateiID = " & idvDateiID & " and Version = " & Version
        G_conn.Execute "DELETE FROM A_XLBINUPDATE WHERE idvDateiID = " & idvDateiID & " and Version = " & Version

        Dim rs As Object
        ' !!!! hier jetzt |fffd|ber den neuen View f|fffd|r die xlBins gehen
        ' ansonsten bekommt man keinen Recordset zur|fffd|ck
'        Set rs = OpenRS("SELECT * FROM xlBin where xlBinID = -1", G_conn, MYadOpenDynamic, MYadLockOptimistic)
        
        If G_DBType <> G_SQL_Server Then
          Set rs = OpenRS("SELECT * FROM A_XLBININSERT WHERE xlBinID = -1", G_conn, MYadOpenDynamic, MYadLockOptimistic)
          If rs Is Nothing Then
            xlCheckInBinary = False
            fehler = "Der erforderliche Recordset konnte nicht ge|fffd|ffnet werden"
            Exit Function
          End If
        End If
        
        Dim zippedFilename As String
        zippedFilename = PackFile(fname, True)

        DoEvents
        
        Dim splitFilenames() As String
        Dim step As Long
        If (SplitFile(zippedFilename, GetSplitSize(), splitFilenames)) Then
        Else
            ReDim splitFilenames(0)
            splitFilenames(0) = zippedFilename
        End If
        
        LogPrint "xlCheckInBinary-1"
        For step = LBound(splitFilenames) To UBound(splitFilenames)
        
            If G_DBType = G_SQL_Server Then
                If Not CheckInBinarySQLServer(G_conn, splitFilenames(step), idvDateiID, Version, dat, step, zippedFilename, fehler) Then
                  DebugPrint tdebug, "xlCheckInBin-Datei NICHT eingef|fffd|gt"
                  xlCheckInBinary = False
                  Exit For
                Else
                  xlCheckInBinary = True
                End If
            Else
                'LogPrint "xlCheckInBinary-1"
                rs.AddNew
                rs.Fields("idvDateiID").value = idvDateiID
                rs.Fields("Version").value = Version
                rs.Fields("Datum").value = dat
                rs.Fields("Compressed").value = IIf(Right(zippedFilename, 3) = ".gz", 1, 0)
                rs.Fields("Step").value = step
                
                Dim errstr As String
                If Not CheckInBinary("Binary", rs, splitFilenames(step), errstr) Then
                  DebugPrint tdebug, "xlCheckInBin-Datei NICHT eingef|fffd|gt"
                  rs.cancelupdate
                  xlCheckInBinary = False
                  Exit For
                Else
                  rs.Update
                  xlCheckInBinary = True
                End If
            End If
        Next
        If G_DBType <> G_SQL_Server Then
          rs.Close
          Set rs = Nothing
        End If
        
        If zippedFilename <> fname Then
            MyKill zippedFilename
        End If
        For step = LBound(splitFilenames) To UBound(splitFilenames)
            If splitFilenames(step) <> fname Then
                MyKill splitFilenames(step)
            End If
        Next
        LogPrint "xlCheckInBinary-Finished"
        Exit Function
fehler:
        fehler = fehler & IIf(fehler <> "", vbCrLf, "") & "xlCheckInBinary: " & Err.Number & " - " & Err.Description
        Debug.Print fehler
'        If Not rs Is Nothing Then
'          rs.Close
          Set rs = Nothing
'        End If
        xlCheckInBinary = False
End Function


Private Function CheckInBinarySQLServer(ByRef conn As Object, ByVal datafile As String, ByVal idvDateiID As Long, ByVal Version As Long, ByVal dat As Date, ByVal step As Long, ByVal zippedFilename As String, ByRef fehler As String) As Boolean

On Error GoTo nogo
   Dim adoStream               As Object
   Dim adoCmd                  As Object
    
   Set adoStream = CreateObject("ADODB.Stream")
   Set adoCmd = CreateObject("ADODB.Command")
    
   adoStream.Type = 1 ' adTypeBinary
   adoStream.Open
   adoStream.LoadFromFile datafile 'It fails if file is open
        
   With adoCmd
        .CommandText = "INSERT INTO A_XLBININSERT (idvDateiID,Version,Datum,Compressed,Binary,Step) VALUES (?,?,?,?,?,?)" ' Query
        .CommandType = 1 ' adCmdText
        
        '---adding parameters
        ' 1 adParamInput
        
        ' 3 adInteger
        ' 20 adBigInt
        ' 7 adDate
        ' 2 adSmallInt
        ' 204 adVarBinary
        ' 205 adLongVarBinary
        ' 135 adDBTimeStamp A date/time stamp (yyyymmddhhmmss plus a fraction in billionths).
        
        .Parameters.Append .CreateParameter("@idvDateiID", 20, 1, 0, idvDateiID)
        .Parameters.Append .CreateParameter("@Version", 20, 1, 0, Version)
        .Parameters.Append .CreateParameter("@Datum", 135, 1, , CDate(dat))
        .Parameters.Append .CreateParameter("@Compressed", 3, 1, 0, IIf(Right(zippedFilename, 3) = ".gz", 1, 0))
        .Parameters.Append .CreateParameter("@Binary", 205, 1, adoStream.Size, adoStream.Read)
        .Parameters.Append .CreateParameter("@Step", 20, 1, 0, step)

        '---
   End With
    
   adoCmd.ActiveConnection = conn
   adoCmd.Execute
   CheckInBinarySQLServer = True
   Exit Function
nogo:
   fehler = fehler & IIf(fehler <> "", vbCrLf, "") & "CheckInBinarySQLServer: " & Err.Number & " - " & Err.Description
End Function

'Private Sub TestCheckInFile()
'    Dim fehler As String
'    GetDBUser
'    InitApp
'    Set G_conn = GetConnection
'    Debug.Print xlCheckInBinary(88, 1, Now, "C:\Users\norman\Documents\|fffd|berpr|fffd|fung Autokorrelationen.xlsx", fehler)
'    Debug.Print fehler
'    G_conn.Close
'    Set G_conn = Nothing
'End Sub

Public Function CheckInBinary(ByVal fieldname As String, ByRef rs As Object, ByVal fname As String, ByRef errstr As String) As Boolean

    On Error GoTo fehler
    
    If Not FileExists(fname) Then
      'errstr = errstr & IIf(errstr <> "", vbCrLf, "") & "Die Datei '" & fname & "' existiert nicht."
      errstr = errstr & IIf(errstr <> "", vbCrLf, "") & FMT1("BLOBSTUFF_1", fname)
      Exit Function
    End If
    
    Dim Doc As Object
    Set Doc = CreateObject("ADODB.Stream")
    
    Dim SavedPointer As Long
    'SavedPointer = Screen.MousePointer  ' Save mouse pointer.
    'Screen.MousePointer = 11
           
    DebugPrint tdebug, "CheckInBinary-Start"
    With Doc
        .Type = 1 ' adTypeBinary
        .Open
        .LoadFromFile fname
    End With
    rs.Fields(fieldname).value = Doc.Read
    
    DebugPrint tdebug, "CheckInBinary-Eingef|fffd|gt"
    'Screen.MousePointer = SavedPointer
    CheckInBinary = True
    DebugPrint tdebug, "CheckInBinary-Ende"
    
    Exit Function

fehler:
    errstr = Err.Number & " - " & Err.Description & " - " & Err.Source & " - Datei: " & fname
    DebugPrint tERROR, "CheckInBinary: " & Err.Number & " - " & Err.Description & " - " & Err.Source & " - Datei: " & fname
'        If Err.Number = 32755 Then Exit Function
End Function


Attribute VB_Name = "CloneStuff"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public m_CheckSum As Long
Public m_FormulaExtractedNames As String
Public m_IF As Long
Public m_Calc As Long
Public m_Sum As Long
Public m_Array As Long
Public m_Ref As Long
Public m_HasExternalRefs As Boolean

Attribute VB_Name = "CrunchRange"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public m_Name As String
Public m_Von As Long
Public m_Bis As Long


Sub Initialize(ByVal n As String, ByVal startval As Long)
  m_Name = n
  m_Von = startval
  m_Bis = startval
End Sub

Function InRange(ByVal n As String, ByVal v As Long, Optional ByVal addItem As Boolean = False) As Boolean
  If m_Name <> n Then Exit Function
  
  If v >= m_Von - 1 And v <= m_Bis + 1 Then
    InRange = True
    If addItem Then
      If v = m_Von - 1 Then
        m_Von = v
      End If
      If v = m_Bis + 1 Then
        m_Bis = v
      End If
    End If
  End If
End Function


Attribute VB_Name = "DBStuff"
Option Explicit

Public G_DBUser As String
Public G_DBUserPasswort As String
Public G_DBType As Long

Public gCHR As String
Public gCursorLocation As Long

Public Const G_SQL_Anywhere As Integer = 1
Public Const G_SQL_Server As Integer = 2
Public Const G_MySQL As Integer = 3
Public Const G_Access As Integer = 4
Public Const G_Oracle As Integer = 5

Const dhcHKeyClassesRoot = &H80000000
Const dhcHKeyCurrentUser = &H80000001
Const dhcHKeyLocalMachine = &H80000002


Private Const KEY_QUERY_VALUE = &H1
Private Const KEY_ENUMERATE_SUB_KEYS = &H8
Private Const KEY_NOTIFY = &H10

Private Const KEY_READ = KEY_QUERY_VALUE Or _
                         KEY_ENUMERATE_SUB_KEYS Or KEY_NOTIFY

Public Const ERROR_SUCCESS = 0&

#If VBA7 Then
Public Declare PtrSafe Sub Sleep Lib "kernel32" (ByVal _
              dwMilliseconds As Long)

Private Declare PtrSafe Function RegOpenKeyEx Lib "advapi32" Alias "RegOpenKeyExA" _
  (ByVal hKey As Long, ByVal lpSubKey As String, ByVal ulOptions As Long, _
  ByVal samDesired As Long, phkResult As Long) As Long

Private Declare PtrSafe Function RegQueryValue Lib "advapi32.dll" Alias "RegQueryValueA" _
    (ByVal hKey As Long, ByVal lpSubKey As String, ByVal lpValue As String, lpcbValue _
    As Long) As Long

Private Declare PtrSafe Function RegQueryValueEx Lib "advapi32.dll" Alias "RegQueryValueExA" _
    (ByVal hKey As Long, ByVal lpValueName As String, ByVal lpReserved As _
    Long, lpType As Long, lpData As Any, lpcbData As Any) As Long

Private Declare PtrSafe Function RegCloseKey Lib "advapi32.dll" (ByVal hKey As Long) As Long

#Else
Public Declare Sub Sleep Lib "kernel32" (ByVal _
              dwMilliseconds As Long)

Private Declare Function RegOpenKeyEx Lib "advapi32" Alias "RegOpenKeyExA" _
  (ByVal hKey As Long, ByVal lpSubKey As String, ByVal ulOptions As Long, _
  ByVal samDesired As Long, phkResult As Long) As Long

Private Declare Function RegQueryValue Lib "advapi32.dll" Alias "RegQueryValueA" _
    (ByVal hKey As Long, ByVal lpSubKey As String, ByVal lpValue As String, lpcbValue _
    As Long) As Long

Private Declare Function RegQueryValueEx Lib "advapi32.dll" Alias "RegQueryValueExA" _
    (ByVal hKey As Long, ByVal lpValueName As String, ByVal lpReserved As _
    Long, lpType As Long, lpData As Any, lpcbData As Any) As Long

Private Declare Function RegCloseKey Lib "advapi32.dll" (ByVal hKey As Long) As Long

#End If


Function GetConnection(Optional ByVal waitendless As Boolean = False) As Object

    DebugPrint DebType.tdebug, "Connect Start"
    
    Dim conn
    Set conn = CreateObject("ADODB.Connection")
    If G_Cursorlocation <> 2 And G_Cursorlocation <> 3 Then
      G_Cursorlocation = 3
    End If
    conn.CursorLocation = G_Cursorlocation
    On Error Resume Next

    Set GetConnection = Nothing
    Dim cnt As Long
    cnt = 0
checkAgain:
    
    conn.Open G_DBConnectionString, G_DBUser, G_DBUserPasswort
    DebugPrint DebType.tdebug, "Connect Via: " & G_DBConnectionString
       
    Dim connectError As String
    If Err.Number <> 0 Then
        connectError = Err.Description
        Err.Clear
        Sleep 50
        cnt = cnt + 1
        If Not waitendless Then
            If cnt >= 100 Then
                conn = Nothing
                Exit Function
            End If
            GoTo checkAgain
        End If
    End If
    
    If connectError <> "" Then
      DebugPrint DebType.tdebug, "Connect Error: " & connectError
    End If

    Set GetConnection = conn

End Function


Sub GetDBUser(ByRef cfg As CfgReader)

    LogPrint "GetDBUser"
    
    G_DBUser = "IDVTTECHUSER"
    G_DBUserPasswort = "12SD3Ax$!d7%fd/"
    
    Dim s As String
    If cfg.GetSection("DB") = True Then
        s = cfg.GetValue("USER")
        If s <> "" Then
            G_DBUser = Crypt(s, "uIq2%7/=}pJIi39x?", False)
        End If
        s = cfg.GetValue("PASSWORD")
        If s <> "" Then
            G_DBUserPasswort = Crypt(s, "uIq2%7/=}pJIi39x?", False)
        End If
        s = cfg.GetValue("DBTYPE")
        If s <> "" Then
            G_DBType = CLng(s)
        End If
    End If
    LogPrint "GetDBUser finished"
End Sub


Function Crypt(Inp As String, Key As String, Mode As Boolean) As String
    Dim z As String
    Dim i As Integer, Position As Integer
    Dim cptZahl As Long, orgZahl As Long
    Dim keyZahl As Long, cptString As String
    
    For i = 1 To Len(Inp)
            Position = Position + 1
            If Position > Len(Key) Then Position = 1
            keyZahl = Asc(Mid(Key, Position, 1))
            
            If Mode Then
            
                'Verschl|fffd|sseln
                orgZahl = Asc(Mid(Inp, i, 1))
                cptZahl = orgZahl Xor keyZahl
                cptString = Hex(cptZahl)
                If Len(cptString) < 2 Then cptString = "0" & cptString
                z = z & cptString
            
            Else
            
                'Entschl|fffd|sseln
                If i > Len(Inp) \ 2 Then Exit For
                cptZahl = CByte("&H" & Mid$(Inp, i * 2 - 1, 2))
                orgZahl = cptZahl Xor keyZahl
                z = z & Chr$(orgZahl)
            
            End If
    Next i
     
    Crypt = z
End Function


Function GetSafeFieldPlus(ByRef rs As Object, ByVal fieldname As String, Optional defaultVal As Variant) As Variant
  On Error Resume Next
  If Not IsNull(rs.Fields(fieldname).value) Then
    GetSafeFieldPlus = rs.Fields(fieldname).value
  Else
    If Not IsMissing(defaultVal) Then
      GetSafeFieldPlus = defaultVal
    End If
  End If
End Function



Function IDVTrackerDSNExists(ByVal printResult As Boolean) As Boolean

  Dim regtype As Long
  Dim res As Variant

  IDVTrackerDSNExists = False
  If RegValueRead(dhcHKeyCurrentUser, "software\odbc\odbc.ini\IDV-Tracker", "Driver", res, regtype) Then
    If printResult Then DebugPrint tinfo, "DSN IDV-Tracker in HK Current User"
    IDVTrackerDSNExists = True
  ElseIf RegValueRead(dhcHKeyLocalMachine, "software\odbc\odbc.ini\IDV-Tracker", "Driver", res, regtype) Then
    If printResult Then DebugPrint tinfo, "DSN IDV-Tracker in HK Local Machine"
    IDVTrackerDSNExists = True
  ElseIf RegValueRead(dhcHKeyClassesRoot, "software\odbc\odbc.ini\IDV-Tracker", "Driver", res, regtype) Then
    If printResult Then DebugPrint tinfo, "DSN IDV-Tracker in HK ClassesRoot"
    IDVTrackerDSNExists = True
  Else
    If printResult Then DebugPrint tinfo, "DSN IDV-Tracker existiert NICHT!"
    IDVTrackerDSNExists = False
  End If
End Function



Public Function RegValueRead(ByRef root As Long, ByRef path As String, _
    ByVal ValueName As String, ByRef value As Variant, ByRef regtype As Long) As Boolean
    
    Dim result As Long, hKey As Long
    Dim lngBuffer As Long, strBuffer As String, DataLength As Long
    
    If RegOpenKeyEx(CLng(root), path, 0&, CLng(KEY_READ), hKey) = ERROR_SUCCESS Then
        If hKey <> 0 Then
            DataLength = 512
            strBuffer = Space$(DataLength)
            
            If ValueName = "" Then
                result = RegQueryValue(hKey, vbNullString, ByVal strBuffer, DataLength)
                value = Left$(strBuffer, DataLength - 1)
            Else
                result = RegQueryValueEx(hKey, ValueName, 0&, regtype, ByVal 0&, DataLength)
            
                If result = ERROR_SUCCESS Then
                    
                    Select Case regtype
                      Case REG_DWORD
                        Dim tLong As Long
                        result = RegQueryValueEx(hKey, ValueName, 0&, regtype, _
                            tLong, DataLength)
                        If result = ERROR_SUCCESS Then value = CStr(tLong)
                      Case REG_SZ
                        result = RegQueryValueEx(hKey, ValueName, 0&, regtype, _
                            ByVal strBuffer, DataLength)
                        If result = ERROR_SUCCESS Then value = Left$(strBuffer, DataLength - 1)
                      Case Else
                        'MsgBox "UNKNOWN REG TYPE", vbCritical, "Excel-Sheet-Checker"
                        MsgBox FMT0("DBSTUFF_1"), vbCritical, FMT0("MM_1")
                    End Select
                End If
            End If
        End If
        
        If result = ERROR_SUCCESS Then RegValueRead = True
        Call RegCloseKey(hKey)
    End If
End Function


Function GetTargetRSFromFilename(ByRef conn As Object, ByVal uncpathfname, ByRef rs As Object, ByRef curId As Long) As Boolean
    GetTargetRSFromFilename = False
    
    Dim uncpathfnameDB As String
    uncpathfnameDB = GetDateinameInDatenbank(uncpathfname)
    
    Dim hash As String
    hash = GetFileHash(uncpathfnameDB)

    Set rs = OpenRS("SELECT * FROM idvDateien WHERE " & _
      gCHR & "HASH" & gCHR & " = '" & hash & "'" & _
      " and geloescht = 0", conn, MYadOpenDynamic, MYadLockReadOnly)

    If Not rs Is Nothing Then
        If rs.EOF = False Then
            curId = rs.Fields("idvDateiID").value
            GetTargetRSFromFilename = True
            Exit Function
        End If
        rs.Close
    End If
    Set rs = Nothing

End Function

Public Function GetDateinameInDatenbank(ByVal uncpathfname As String) As String

    GetDateinameInDatenbank = UCase(uncpathfname)
    If IsHttpFilename(uncpathfname) Then
        If True = True Then
            GetDateinameInDatenbank = uncpathfname
        End If
    End If

End Function


Public Function IsHttpFilename(ByVal uncpathfname As String) As Boolean
    IsHttpFilename = False
    If IsURL(uncpathfname) Then
        IsHttpFilename = True
    End If
    
    If UCase(Left(uncpathfname, 16)) = "\\VBOXSRV\MYWORK" Then
        IsHttpFilename = True
    End If
End Function

Attribute VB_Name = "DebugStuff"
Option Explicit

Enum DebType
    tERROR = 1
    tinfo = 2
    tTime = 3
    tdebug = 4
    tMail = 5
    tSystem = 6
    tToFile = 7
End Enum

Public G_PARAM_DebugInfosLoggen As Boolean
Public G_IgnoreFutureWriteWindows As Boolean

Public G_LogThisUser As Boolean
Public G_PARAM_CollectDebug As Boolean

Public G_LogToWindow As Boolean
Public G_LogWriteIgnore As Boolean

Private L_InDebugPrint As Boolean


Public Const G_LOG_EXTERNE_KOPIE As Long = 1              ' Die Datei wurde durch eine andere Datei au|fffd|erhalb des IDV-Tracker-Systems |fffd|berschrieben. Wahrscheinlich hat der User eine Datei mit dem Explorer |fffd|ber die Originaldatei kopiert.
Public Const G_LOG_NEUE_FREIGABE_ENTFERNT As Long = 2     ' F|fffd|r die Datei wurde eine neue Version erzeugt. Dadurch wurde die Programmfreigabe aufgehoben.
Public Const G_LOG_NEUE_VERSION As Long = 3               ' F|fffd|r die Datei wurde eine neue Version erzeugt.
Public Const G_LOG_BLATSCHUTZ_ENTFERNEN_INIT As Long = 4  ' Blattschutz-Entfernung initiiert
Public Const G_LOG_BLATTSCHUTZ_ENTFERNT As Long = 5       ' Blattschutz entfernt
Public Const G_LOG_BLATTSCHUTZ_ANGEBRACHT As Long = 6     ' Blattschutz angebracht

Private Sub SetConnectTimeout(ByRef conn)
  On Error Resume Next
  conn.Execute "SET LOCK_TIMEOUT 5000"
  conn.Properties("Jet OLEDB:Lock Delay") = 5000 ' 90 + Int(Rnd * 60)
  Err.Clear
End Sub

#If NOLOGTODB = 0 Then
Sub AddTextToLogDB(ByVal md As DebType, ByVal str As String, dur As Double, ByVal logExp As Long, ByVal idvDateiID As Long)
    
    On Error GoTo nogo
    
    Dim rs As Object
    Set rs = CreateObject("ADODB.Recordset")

    rs.Open "SELECT * FROM idvDateienEventLog WHERE EventTyp = -1", G_conn, MYadOpenDynamic, MYadLockOptimistic
    
    If rs Is Nothing Then
      Exit Sub
    End If
    
    Do While Len(str) > 0
      rs.AddNew
      rs.Fields("EventTyp").value = md
      rs.Fields("EventLogErlaeuterungID").value = logExp
      rs.Fields("Datum").value = Now
      rs.Fields("Text").value = Left(str, 255)
      rs.Fields("Zeit").value = dur
      rs.Fields("AppID").value = MyAppID
      rs.Fields("idvDateiID").value = idvDateiID
      rs.Fields("userLogonId").value = Left(GetUserName, 24)
      rs.Update
      str = Mid(str, 255, 10000)
    Loop

nogo:
'    If Not rs Is Nothing Then
'      rs.Close
      Set rs = Nothing
'    End If
    


End Sub
#End If

Sub DebugPrint(ByVal md As DebType, ByVal str As String, Optional ByVal dur As Double = 0, Optional ByVal logExp As Long = 0, Optional ByVal idvDateiID As Long = 0, Optional logToECCSCanLog As Boolean = False)

    If L_InDebugPrint Then Exit Sub

    L_InDebugPrint = True
    
    ' Ausgabe f|fffd|r Debug-Window
    If md = DebType.tERROR Then
      If UCase(Right(ThisWorkbook.name, 1)) = "S" Then
        Debug.Print "ND: " & Now() & "; " & Chr(34) & "Err: " & str & Chr(34) & "; " & dur
      End If
      If G_LogToWindow = True Then
        frmLogWindow.LogText.Text = Right(frmLogWindow.LogText.Text & vbCrLf & "*** " & Now() & "; " & Chr(34) & "Err: " & str & Chr(34) & "; " & dur, 16000)
        If Len(frmLogWindow.LogText.Text) > 0 Then
          frmLogWindow.LogText.SelStart = Len(frmLogWindow.LogText.Text)
        End If
      End If
    Else
      If UCase(Right(ThisWorkbook.name, 1)) = "S" Then
        Debug.Print "ND: " & Now() & "; " & Chr(34) & str & Chr(34) & "; " & dur
      End If
      If G_LogToWindow = True Then
        frmLogWindow.LogText.Text = Right(frmLogWindow.LogText.Text & vbCrLf & Now() & "; " & Chr(34) & str & Chr(34) & "; " & dur, 16000)
        If Len(frmLogWindow.LogText.Text) > 0 Then
          frmLogWindow.LogText.SelStart = Len(frmLogWindow.LogText.Text)
        End If
      End If
    End If
    
    If AR_StartedByApp = SWAPPID_IDVSuiteScheduler Then
      If logToECCSCanLog = True Or G_LogEnabled = True Then
        If G_cfgLogpfad <> "" Then
          If FileExists(G_cfgLogpfad & "\IDV-Suite Scheduler-" & GetUserName & ".txt") Then
            AddTextToFile Now() & ",0, Typ: 7, ID: " & idvDateiID & "," & Chr(34) & str & Chr(34), G_cfgLogpfad & "\IDV-Suite Scheduler-" & GetUserName & ".txt"
          End If
        End If
      End If
    End If
    
    If G_LogEnabled Then
      If G_cfgLogpfad = "" Then
        AddTextToFile Now() & "; " & Chr(34) & str & Chr(34), ThisWorkbook.path & "\ECC-Log-" & GetUserName & ".txt"
      Else
        AddTextToFile Now() & "; " & Chr(34) & str & Chr(34), G_cfgLogpfad & "\ECC-Log-" & GetUserName & ".txt"
      End If
    End If
    
'    If G_AllowLoggingToStorage Then
'        If md = 1 Or _
'            (md = 2 And (G_cfgDebugInfosLoggen = True Or (G_PARAM_DebugInfosLoggen = True And G_LogThisUser = True))) Or _
'            (md = 3 And (G_cfgDebugInfosLoggen = True Or (G_PARAM_DebugInfosLoggen = True And G_LogThisUser = True))) Or _
'            (md = 4 And (G_cfgDebugInfosLoggen = True Or (G_PARAM_DebugInfosLoggen = True And G_LogThisUser = True))) Or _
'             md = 5 Or _
'             md = 6 Then
'
'            If md = DebType.tError Then
'                AddTextToLogDB md, "Err: " & str, dur, logExp, idvDateiID
'            Else
'                AddTextToLogDB md, str, dur, logExp, idvDateiID
'            End If
'        End If
'    End If
    

    L_InDebugPrint = False

End Sub


Public Function AddTextToLogfile(ByVal strData As String, _
     ByVal fullpath As String, _
       Optional ByVal ErrInfo As String = "") As Boolean

    On Error GoTo CatchEx

    If G_LogWriteIgnore = True Then Exit Function
    
    Dim fn As Long
    Dim cnt As Long
    cnt = 0
    
    fn = FreeFile
    Dim s As String

GoAgain:

    If PathExists(GetPath(fullpath)) Then
      Do
        If FOpenAppend(fullpath, fn) Then
          Print #fn, strData
          Close fn
          AddTextToLogfile = True
          Exit Do
        Else
          Sleep 100
          cnt = cnt + 1
          If cnt >= 10 Then
            AddTextToLogfile = False
            G_LogWriteIgnore = True
            If Not G_IgnoreFutureWriteWindows Then
              'If MsgBox("ACHTUNG: Die Log-Datei kann nicht in '" & fullpath & "' gespeichert werden, vermutlich haben Sie keine Schreibrechte in diesem Ordner. Bitte informieren Sie die Administration. M|fffd|chten Sie, dass das Log in einem Fenster ausgegeben wird?", vbYesNo + vbCritical, ProgNameLong & " " & MyVersion) = vbYes Then
              If MsgBox(FMT1("DEBUGSTUFF_1", fullpath), vbYesNo + vbCritical, ProgNameLong & " " & MyVersion) = vbYes Then
                G_LogToWindow = True
                ' frmLogWindow.Caption = ProgNameLong & " " & MyVersion & " - Log..."
                ' frmLogWindow.Show vbModeless
                G_IgnoreFutureWriteWindows = True
              End If
            End If
            Exit Function
          End If
        End If
      Loop
    Else
      G_LogWriteIgnore = True
      'If MsgBox("ACHTUNG: Die Log-Datei kann nicht in '" & GetPath(fullpath) & "' gespeichert werden, der Pfad existiert nicht. Bitte informieren Sie die Administration. M|fffd|chten Sie, dass das Log in einem Fenster ausgegeben wird?", vbYesNo + vbCritical, ProgNameLong & " " & MyVersion) = vbYes Then
      If MsgBox(FMT1("DEBUGSTUFF_2", GetPath(fullpath)), vbYesNo + vbCritical, ProgNameLong & " " & MyVersion) = vbYes Then
        G_LogToWindow = True
        'frmLogWindow.Caption = ProgNameLong & " " & MyVersion & " - Log..."
        frmLogWindow.Caption = ProgNameLong & " " & MyVersion & " - " & FMT0("DEBUGSTUFF_3")
        frmLogWindow.Show vbModeless
      End If
    End If
    Exit Function

CatchEx:

End Function




Private Function FOpenAppend(fname As String, ByRef fn As Long) As Boolean
  On Error GoTo nogo
  Open fname For Append As fn
  FOpenAppend = True
  Exit Function
nogo:
        
End Function



Attribute VB_Name = "DieseArbeitsmappe"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Dimension"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public m_X As Long
Public m_Y As Long
Public m_XY As Long
Public m_Z As Long

Sub Check(ByRef x As Long, ByRef y As Long, ByRef z As Long, ByRef xy As Long)
  If x > m_X Then m_X = x
  If y > m_Y Then m_Y = y
  If xy > m_XY Then m_XY = xy
  If z > m_Z Then m_Z = z
End Sub
Attribute VB_Name = "DirSelect"
Option Explicit


#If VBA7 Then

        Public Type BROWSEINFO
           hOwner As LongPtr
           pidlRoot As Long
           pszDisplayName As String
           lpszTitle As String
           ulFlags As Long
           lpfn As Long
           lParam As Long
           iImage As Long
        End Type
        
        Declare PtrSafe Function SHGetPathFromIDList Lib "shell32.dll" _
           Alias "SHGetPathFromIDListA" (ByVal pidl As Long, _
           ByVal pszPath As String) As Long
        
        Declare PtrSafe Function SHBrowseForFolder Lib "shell32.dll" _
           Alias "SHBrowseForFolderA" (lpBrowseInfo As BROWSEINFO) As Long
#Else
        Public Type BROWSEINFO
           hOwner As Long
           pidlRoot As Long
           pszDisplayName As String
           lpszTitle As String
           ulFlags As Long
           lpfn As Long
           lParam As Long
           iImage As Long
        End Type
        
        Declare Function SHGetPathFromIDList Lib "shell32.dll" _
           Alias "SHGetPathFromIDListA" (ByVal pidl As Long, _
           ByVal pszPath As String) As Long
        
        Declare Function SHBrowseForFolder Lib "shell32.dll" _
           Alias "SHBrowseForFolderA" (lpBrowseInfo As BROWSEINFO) As Long
#End If

Function GetDirectory(Optional msg) As String
   Dim bInfo As BROWSEINFO
   Dim path As String
   Dim r As Long, x As Long, pos As Integer
   bInfo.pidlRoot = 0&
   If IsMissing(msg) Then
      'bInfo.lpszTitle = Texte(GSprache, TXT_ORDNERW|fffd|HLEN)
      bInfo.lpszTitle = FMT0("TXT_ORDNERW|fffd|HLEN")
   Else
      bInfo.lpszTitle = msg
   End If
   bInfo.ulFlags = &H1
   x = SHBrowseForFolder(bInfo)
   path = Space$(512)
   r = SHGetPathFromIDList(ByVal x, ByVal path)
   If r Then
      pos = InStr(path, Chr$(0))
      GetDirectory = Left(path, pos - 1)
   Else
      GetDirectory = ""
   End If
End Function
Attribute VB_Name = "ECCFindenStuff"
Option Explicit

Dim wbname As String
Dim currentWS As String
Dim currentCellx As Long
Dim currentCelly As Long

Public theSearchtext As String


Public Sub ECCFinden()

  
  On Error GoTo raffIchNet
  Dim ws As Worksheet
  Dim c As Range
  currentWS = ""
  wbname = ActiveWorkbook.name
  
  Dim ccnt As Long
  Dim rotChar
  Dim lastTime
  lastTime = Now
  rotChar = Array("|", "/", "-", "\")
  ccnt = 0
  Dim tcnt As Long
  tcnt = 0
  
  Dim i As Long
  For i = 1 To Worksheets.count
    If Worksheets(i).name = ActiveSheet.name Then
      Exit For
    End If
  Next i
  
  Dim startChecking As Boolean
  startChecking = False
  Dim endIndex As Long
  endIndex = i
  
'  For Each ws In ActiveWorkbook.Worksheets
  Do
    If startChecking = True And endIndex = i Then
      Exit Do
    End If
    Set ws = ActiveWorkbook.Worksheets(i)
    currentWS = ws.name
'    If ws.ProtectContents = True Then
'      If SheetHasPassword(ws) Then
        For Each c In ws.UsedRange
          currentCelly = c.Row
          currentCellx = c.Column
          If c.Interior.ColorIndex <> xlNone Or _
            c.Borders(xlDiagonalDown).LineStyle <> xlLineStyleNone Or _
            c.Borders(xlDiagonalUp).LineStyle <> xlLineStyleNone Or _
            c.Borders(xlEdgeLeft).LineStyle <> xlLineStyleNone Or _
            c.Borders(xlEdgeRight).LineStyle <> xlLineStyleNone Or _
            c.Borders(xlEdgeTop).LineStyle <> xlLineStyleNone Or _
            c.Borders(xlEdgeBottom).LineStyle <> xlLineStyleNone Or _
            c.Interior.Pattern <> xlPatternNone Then ' = 8 Or c.Interior.ColorIndex = 4 Or c.Interior.ColorIndex = 6 Then
            ws.Activate
            c.Activate
            Application.StatusBar = ""
            Exit Sub
          End If
          If tcnt > 100 Then
            tcnt = 0
            lastTime = Now
            'Application.StatusBar = "Bitte warten, Suche l|fffd|uft (Tabelle '" & ws.name & "'). " & rotChar(ccnt)
            Application.StatusBar = FMT2("ECCFINDEN_1", ws.name, rotChar(ccnt))
            ccnt = ccnt + 1
            If ccnt = 4 Then ccnt = 0
          End If
          tcnt = tcnt + 1
        Next c
'      End If
'    End If
    i = i + 1
    If i > Worksheets.count Then
      i = 1
    End If
    startChecking = True
  Loop
  'MsgBox "Keine Zellen gefunden.", vbInformation, "Excel-Sheet-Checker"
  MsgBox FMT0("ECCFINDEN_2"), vbInformation, FMT0("MM_1")
  currentWS = ""
  Application.StatusBar = ""
  Exit Sub
raffIchNet:
  'MsgBox "Es trat ein unvorhergesehener Fehler auf (ECCFinden): " & Err.Description, vbCritical, "Excel-Sheet-Checker"
  MsgBox FMT1("ECCFINDEN_3", Err.Description), vbCritical, FMT0("MM_1")
  Application.StatusBar = ""

End Sub

Public Sub ECCWFinden()
  
  On Error GoTo raffIchNet

  Dim ws As Worksheet
  Dim c As Range
  Dim ccnt As Long
  Dim rotChar
  rotChar = Array("|", "/", "-", "\")
  ccnt = 0
  Dim tcnt As Long
  tcnt = 0
  
  Dim r As Range
  
  Set ws = ActiveSheet
  Set r = Selection
  Dim Start As Boolean
  Start = True
  Dim endfind As Boolean
  endfind = False
  
  Do
    For Each c In ActiveSheet.UsedRange
      If endfind Then
        If c.Row >= r.Row Or (c.Row = r.Row And c.Column >= r.Column) Then
          'MsgBox "Keine Zellen gefunden", vbInformation, "Excel-Sheet-Checker"
          MsgBox FMT0("ECCFINDEN_2"), vbInformation, FMT0("MM_1")
          Application.StatusBar = ""
          Exit Sub
        End If
      End If
      If Start Then
        If c.Row > r.Row Or (c.Column > r.Column And c.Row = r.Row) Then
          Start = False
        End If
      End If
      If Not Start Then
        If c.Interior.ColorIndex <> xlNone Or _
            (c.Borders(xlEdgeLeft).LineStyle <> xlLineStyleNone And _
            c.Borders(xlEdgeRight).LineStyle <> xlLineStyleNone And _
            c.Borders(xlEdgeTop).LineStyle <> xlLineStyleNone And _
            c.Borders(xlEdgeBottom).LineStyle <> xlLineStyleNone) _
              Then ' = 8 Or c.Interior.ColorIndex = 4 Or c.Interior.ColorIndex = 6 Then
          c.Activate
          Application.StatusBar = ""
          Exit Sub
        End If
      End If
      
      If tcnt > 100 Then
        tcnt = 0
        'Application.StatusBar = "Bitte warten, Suche l|fffd|uft (Tabelle '" & ws.name & "'). " & rotChar(ccnt)
        Application.StatusBar = FMT2("ECCFINDEN_1", ws.name, rotChar(ccnt))
        ccnt = ccnt + 1
        If ccnt = 4 Then ccnt = 0
      End If
      tcnt = tcnt + 1
    Next c
    
    ' Ok, das aktuelle Worksheet "erh|fffd|hen"
    Dim i As Long
    For i = 1 To Worksheets.count
      If Sheets(i).name = ActiveSheet.name Then
        i = i + 1
        If i > Worksheets.count Then i = 1
        Sheets(i).Activate
        If Sheets(i) Is ws Then
          endfind = True
        End If
        Exit For
      End If
    Next i
  Loop
  
  Application.StatusBar = ""
  Exit Sub
raffIchNet:
  'MsgBox "Es trat ein unvorhergesehener Fehler auf (ECCWFinden): " & Err.Description, vbCritical, "Excel-Sheet-Checker"
  MsgBox FMT1("ECCFINDEN_3", Err.Description), vbCritical, FMT0("MM_1")
  Application.StatusBar = ""
End Sub

Public Sub ECCTxtFinden()
  
  On Error GoTo raffIchNet

  Dim ws As Worksheet
  Dim c As Range
  Dim ccnt As Long
  Dim rotChar
  rotChar = Array("|", "/", "-", "\")
  ccnt = 0
  Dim tcnt As Long
  tcnt = 0
  
  Dim r As Range
  
  Set ws = ActiveSheet
  Set r = Selection
  Dim Start As Boolean
  Start = True
  Dim endfind As Boolean
  endfind = False
  
  Do
    For Each c In ActiveSheet.UsedRange
      If endfind Then
        If c.Row >= r.Row Or (c.Row = r.Row And c.Column >= r.Column) Then
          'MsgBox "Keine Zellen gefunden", vbInformation, "Excel-Sheet-Checker"
          MsgBox FMT0("ECCFINDEN_2"), vbInformation, FMT0("MM_1")
          Application.StatusBar = ""
          Exit Sub
        End If
      End If
      If Start Then
        If c.Row > r.Row Or (c.Column > r.Column And c.Row = r.Row) Then
          Start = False
        End If
      End If
      If Not Start Then
        If InStr(c.Formula, theSearchtext) > 0 Then
          c.Activate
          Application.StatusBar = ""
          Exit Sub
        End If
      End If
      
      If tcnt > 100 Then
        tcnt = 0
        'Application.StatusBar = "Bitte warten, Suche l|fffd|uft (Tabelle '" & ws.name & "'). " & rotChar(ccnt)
        Application.StatusBar = FMT2("ECCFINDEN_1", ws.name, rotChar(ccnt))
        ccnt = ccnt + 1
        If ccnt = 4 Then ccnt = 0
      End If
      tcnt = tcnt + 1
    Next c
    
    ' Ok, das aktuelle Worksheet "erh|fffd|hen"
    Dim i As Long
    For i = 1 To Worksheets.count
      If Sheets(i).name = ActiveSheet.name Then
        i = i + 1
        If i > Worksheets.count Then i = 1
        Sheets(i).Activate
        If Sheets(i) Is ws Then
          endfind = True
        End If
        Exit For
      End If
    Next i
  Loop
  
  Application.StatusBar = ""
  Exit Sub
raffIchNet:
  'MsgBox "Es trat ein unvorhergesehener Fehler auf (ECCTxtFinden): " & Err.Description, vbCritical, "Excel-Sheet-Checker"
  MsgBox FMT1("ECCFINDEN_3", Err.Description), vbCritical, FMT0("MM_1")
  Application.StatusBar = ""
End Sub



Attribute VB_Name = "FFuncs"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

Public m_Name As String
Public m_Count As Long
Public m_Used As Boolean
Attribute VB_Name = "FileStuff"
Option Explicit

'  Shell File Operations

Private Const FO_MOVE = &H1
Private Const FO_COPY = &H2
Private Const FO_DELETE = &H3
Private Const FO_RENAME = &H4
Private Const FOF_MULTIDESTFILES = &H1
Private Const FOF_CONFIRMMOUSE = &H2
Private Const FOF_SILENT = &H4                      '  don't create progress/report
Private Const FOF_RENAMEONCOLLISION = &H8
Private Const FOF_NOCONFIRMATION = &H10             '  Don't prompt the user.
Private Const FOF_WANTMAPPINGHANDLE = &H20          '  Fill in SHFILEOPSTRUCT.hNameMappings
                                      '  Must be freed using SHFreeNameMappings
Private Const FOF_ALLOWUNDO = &H40
Private Const FOF_FILESONLY = &H80                  '  on *.*, do only files
Private Const FOF_SIMPLEPROGRESS = &H100            '  means don't show names of files
Private Const FOF_NOCONFIRMMKDIR = &H200            '  don't confirm making any needed dirs


#If VBA7 Then

Private Type SHFILEOPSTRUCT
        Hwnd As LongPtr
        wFunc As LongPtr
        pFrom As String
        pTo As String
        fFlags As Integer
        fAnyOperationsAborted As Boolean
        hNameMappings As LongPtr
        lpszProgressTitle As String '  only used if FOF_SIMPLEPROGRESS
End Type


Private Declare PtrSafe Function SHFileOperation Lib "shell32.dll" Alias "SHFileOperationA" (lpFileOp As SHFILEOPSTRUCT) As Long
#Else

Private Type SHFILEOPSTRUCT
        Hwnd As Long
        wFunc As Long
        pFrom As String
        pTo As String
        fFlags As Integer
        fAnyOperationsAborted As Boolean
        hNameMappings As Long
        lpszProgressTitle As String '  only used if FOF_SIMPLEPROGRESS
End Type

Private Declare Function SHFileOperation Lib "shell32.dll" Alias "SHFileOperationA" (lpFileOp As SHFILEOPSTRUCT) As Long
#End If

Const OFN_READONLY           As Long = &H1
Const OFN_EXPLORER           As Long = &H80000
Const OFN_LONGNAMES          As Long = &H200000
Const OFN_CREATEPROMPT       As Long = &H2000
Const OFN_NODEREFERENCELINKS As Long = &H100000
Const OFN_OVERWRITEPROMPT    As Long = &H2
Const OFN_HIDEREADONLY       As Long = &H4
Const OFN_PATHMUSTEXIST      As Long = &H800
Const OFN_ENABLEHOOK As Long = &H20
Const OFN_ENABLESIZING As Long = &H800000

Public Const OFS_FILE_OPEN_FLAGS    As Long = OFN_EXPLORER _
                                    Or OFN_LONGNAMES _
                                    Or OFN_CREATEPROMPT _
                                    Or OFN_NODEREFERENCELINKS
Public Const OFS_FILE_SAVE_FLAGS    As Long = OFN_EXPLORER _
                                    Or OFN_LONGNAMES _
                                    Or OFN_OVERWRITEPROMPT _
                                    Or OFN_HIDEREADONLY
Public Const OFS_FILE_SAVE_FLAGS_NO_PROMPT    As Long = OFN_EXPLORER _
                                    Or OFN_LONGNAMES _
                                    Or OFN_HIDEREADONLY




Type OPENFILENAME
    nStructSize     As Long
    hwndOwner       As Long
    hInstance       As Long
    sFilter         As String
    sCustomFilter   As String
    nCustFilterSize As Long
    nFilterIndex    As Long
    sFile           As String
    nFileSize       As Long
    sFileTitle      As String
    nTitleSize      As Long
    sInitDir        As String
    sDlgTitle       As String
    Flags           As Long
    nFileOffset     As Integer
    nFileExt        As Integer
    sDefFileExt     As String
    nCustData       As Long
    fnHook          As Long
    sTemplateName   As String
End Type

Public Type RECT
   Left As Long
   Top As Long
   Right As Long
   Bottom As Long
End Type

Public Const WM_INITDIALOG As Long = &H110
Private Const SW_SHOWNORMAL As Long = 1

#If VBA7 Then
    Private Declare PtrSafe Function GetParent Lib "user32" _
      (ByVal Hwnd As Long) As Long
    Private Declare PtrSafe Function SetWindowText Lib "user32" _
       Alias "SetWindowTextA" _
      (ByVal Hwnd As Long, _
       ByVal lpString As String) As Long
       
    Private Declare PtrSafe Function MoveWindow Lib "user32" _
      (ByVal Hwnd As Long, _
       ByVal x As Long, _
       ByVal y As Long, _
       ByVal nWidth As Long, _
       ByVal nHeight As Long, _
       ByVal bRepaint As Long) As Long
       
    Private Declare PtrSafe Function GetWindowRect Lib "user32" _
      (ByVal Hwnd As Long, _
       lpRect As RECT) As Long
       
    'defined As Any to support either the
    'OSVERSIONINFO or OSVERSIONINFOEX structure
    Private Declare PtrSafe Function GetVersionEx Lib "kernel32" _
       Alias "GetVersionExA" _
      (lpVersionInformation As Any) As Long
      
    Declare PtrSafe Function GetActiveWindow Lib "user32.dll" () As Long
    Declare PtrSafe Function GetOpenFileName Lib "comdlg32.dll" Alias _
        "GetOpenFileNameA" (pOpenfilename As OPENFILENAME) As Long
    Declare PtrSafe Function GetSaveFileName Lib "comdlg32.dll" Alias _
        "GetSaveFileNameA" (pOpenfilename As OPENFILENAME) As Long
    Declare PtrSafe Function GetShortPathName Lib "Kernel32.dll" Alias _
        "GetShortPathNameA" (ByVal lpszLongPath As String, _
                             ByVal lpszShortPath As String, _
                             ByVal cchBuffer As Long) As Long

#Else
    Private Declare Function GetParent Lib "user32" _
      (ByVal Hwnd As Long) As Long
    Private Declare Function SetWindowText Lib "user32" _
       Alias "SetWindowTextA" _
      (ByVal Hwnd As Long, _
       ByVal lpString As String) As Long
       
    Private Declare Function MoveWindow Lib "user32" _
      (ByVal Hwnd As Long, _
       ByVal x As Long, _
       ByVal y As Long, _
       ByVal nWidth As Long, _
       ByVal nHeight As Long, _
       ByVal bRepaint As Long) As Long
       
    Private Declare Function GetWindowRect Lib "user32" _
      (ByVal Hwnd As Long, _
       lpRect As RECT) As Long
       
    'defined As Any to support either the
    'OSVERSIONINFO or OSVERSIONINFOEX structure
    Private Declare Function GetVersionEx Lib "kernel32" _
       Alias "GetVersionExA" _
      (lpVersionInformation As Any) As Long
      
    Declare Function GetActiveWindow Lib "user32.dll" () As Long
    Declare Function GetOpenFileName Lib "comdlg32.dll" Alias _
        "GetOpenFileNameA" (pOpenfilename As OPENFILENAME) As Long
    Declare Function GetSaveFileName Lib "comdlg32.dll" Alias _
        "GetSaveFileNameA" (pOpenfilename As OPENFILENAME) As Long
    Declare Function GetShortPathName Lib "Kernel32.dll" Alias _
        "GetShortPathNameA" (ByVal lpszLongPath As String, _
                             ByVal lpszShortPath As String, _
                             ByVal cchBuffer As Long) As Long
#End If



Public Sub SyncCopy(Dateiname$, zielverzeichnis$)

Dim filenames$
Dim i As Integer
Dim shellinfo As SHFILEOPSTRUCT

filenames = Dateiname + Chr(0)

With shellinfo
        .Hwnd = 0 ' Screen.ActiveForm.Hwnd
        .wFunc = FO_COPY
        .pFrom = filenames
        .pTo = zielverzeichnis
        .fFlags = FOF_FILESONLY + FOF_NOCONFIRMATION + FOF_NOCONFIRMMKDIR + FOF_SILENT
End With

SHFileOperation shellinfo

End Sub

' Dateioperationen

Public Sub CopyFile(Dateiname$, zielverzeichnis$, Optional inklusiveUnterverzeichnisse)

On Error Resume Next
  Dim arr(1) As String
  arr(0) = Dateiname
  
  If UCase(Left(Dateiname, 7)) = "HTTP://" Or UCase(Left(Dateiname, 8)) = "HTTPS://" Then
    DownloadFile Dateiname, zielverzeichnis ' & "\" & GetFileNameAndExtension(Dateiname)
  Else
    CopyPlus arr, zielverzeichnis, inklusiveUnterverzeichnisse
  End If

End Sub

Public Sub CopyPlus(dateinamen$(), zielverzeichnis$, Optional inklusiveUnterverzeichnisse)

Dim filenames$
Dim i As Integer
Dim shellinfo As SHFILEOPSTRUCT

For i = 0 To UBound(dateinamen)
    filenames = filenames & dateinamen(i) + Chr(0)
Next i
filenames = filenames + Chr(0)

With shellinfo
        .Hwnd = 0 ' Screen.ActiveForm.Hwnd
        .wFunc = FO_COPY
        .pFrom = filenames
        .pTo = zielverzeichnis
        If Not IsMissing(inklusiveUnterverzeichnisse) Then
            If Not inklusiveUnterverzeichnisse Then .fFlags = FOF_FILESONLY
        End If
End With

SHFileOperation shellinfo

End Sub

Public Function Move(dateinamen$(), zielverzeichnis$, Optional inklusiveUnterverzeichnisse)

Dim filenames$
Dim i As Integer
Dim shellinfo As SHFILEOPSTRUCT

For i = 0 To UBound(dateinamen)
    filenames = filenames & dateinamen(i) + Chr(0)
Next i
filenames = filenames + Chr(0)

With shellinfo
        .Hwnd = 0 ' Screen.ActiveForm.Hwnd
        .wFunc = FO_COPY
        .pFrom = filenames
        .pTo = zielverzeichnis
        If Not IsMissing(inklusiveUnterverzeichnisse) Then
            If Not inklusiveUnterverzeichnisse Then .fFlags = FOF_FILESONLY
        End If
End With

SHFileOperation shellinfo

End Function

Public Function Delete(dateinamen$(), Optional inklusiveUnterverzeichnisse)
Dim filenames$
Dim i As Integer
Dim shellinfo As SHFILEOPSTRUCT

For i = 0 To UBound(dateinamen)
    filenames = filenames & dateinamen(i) + Chr(0)
Next i
filenames = filenames + Chr(0)

With shellinfo
        .Hwnd = 0 ' Screen.ActiveForm.Hwnd
        .wFunc = FO_DELETE
        .pFrom = filenames
        .pTo = "" + Chr(0)
        If Not IsMissing(inklusiveUnterverzeichnisse) Then
            If Not inklusiveUnterverzeichnisse Then .fFlags = FOF_FILESONLY
        End If
End With

SHFileOperation shellinfo

End Function



Public Function DelTree(ByVal path As String) As Boolean
' L?scht mithilfe des FileSystemObject (ScrRun.dll) einen
' Verzeichnisbaum (sofern m?glich).
' Kann der Baum nicht komplett gel?scht werden, wird als
' Funktionsr?ckgabewert FALSE verwendet.
' Hinweis: Die Dateien werden direkt gel?scht, nicht
' lediglich in den Papierkorb verschoben!
Dim FSO As Object
  On Error Resume Next
  ' FileSystemObject instanzieren
  Set FSO = CreateObject("Scripting.FileSystemObject")
  ' Konnte das Objekt instanziert werden?
  If Err.Number <> 0 Then
 Exit Function
  End If
  ' Die DeleteFolder-Methode des Objekts aufrufen
  FSO.DeleteFolder path, True
  ' Trat beim L?schen ein Fehler auf?
  If Err.Number <> 0 Then
 Exit Function
  End If
  ' Fehlerfreie Abarbeitung => R?ckgabewert TRUE
  DelTree = True
End Function
Function ReadTextfile(ByVal strFileName As String) As String
  Dim iFile As Integer
  Dim fileWasOpen As Boolean
  fileWasOpen = False
  iFile = FreeFile
  On Error GoTo nogo
  Open strFileName For Input As #iFile
  fileWasOpen = True
  ReadTextfile = Input(LOF(iFile), iFile)
  Close #iFile
  Exit Function
nogo:
  If fileWasOpen Then
      Close #iFile
  End If
End Function
Function WriteTextfile(ByVal strFileName As String, txt As String) As String
  Dim iFile As Integer
  iFile = FreeFile
  On Error GoTo nogo
  Open strFileName For Output As #iFile
  Print #iFile, txt
  Close #iFile
  Exit Function
nogo:
End Function
Attribute VB_Name = "Func"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False





Public name As String
Public Trans As String
Public Desc As String
Public Head As Func
Public count As Long
Public SumCount As Long

Attribute VB_Name = "Globals"
Option Explicit

Public Const MyVersion As String = "4.17"
Public Const MyProgramReleaseDate As Date = #7/14/2019#
Public Const MyInternalVersion As Long = 39
Public Const progNameShort As String = "ECC"
Public Const ProgNameLong As String = "Excel-Sheet-Checker"
Public Const MyProgramLicenseVersion As Long = 1
Public Const MyAppID = 4


' Diese Version wird in der IDV-Suite verwendet, um mit dem "richtigen" ECC zu Scannen. Version 0 ist der "Ur-ECC". Dier Versionsnummer
' |fffd|ndert sich nur, wenn sich auch der Checksummenalogrithmus |fffd|ndert.
Public Const MyECCVersion As Long = 4

Public Const C_LeakTest As Boolean = False

Public trsLngSelect As String
Public G_ECCPro As Boolean

Public G_Schnellanalyse As Boolean

Public xlsDateien As Collection
Public inaccessablePaths As Collection
Public Funcs As Collection
Public FuncArray
Public TotalUsedBytes As Long
Public TotalUsedFiles As Long
Public TotalUnusedBytes As Long
Public TotalUnusedFiles As Long
Public TotalUnusedBytesOlder As Long
Public TotalUnusedFilesOlder As Long
Public TotalUnusedBytesSmaller As Long
Public TotalUnusedFilesSmaller As Long
Public TotalUnusedBytesDouble As Long
Public TotalUnusedFilesDouble As Long
Public TotalFilesTested As Long

Private AmountScanned As Long

' Gibts ab Version V1(Ehemals StartedByTracker)
Public AR_UseDB  As Boolean

Public AR_StartedByApp As StromwerkenAppID

' Gibts ab Version V0
' OBSOLET Public G_UserStartedProgram As Boolean

' Gibts ab Version V0
Public StartedByDaemon  As Boolean

Public theTrackerShowStatusform  As Boolean
Public theTrackerFreigabe As Boolean
Public theTrackerFreigabeDatum As Date
Public theTrackerFormelnExtrahieren  As Double
' Public theTrackerFachrisiko As Double

Public NextTime As Date


Public G_InternetVersion As String
Public G_InternetAvailable As Boolean
Public G_InternetInternalVersion As Long
Public G_InternetLicenseVersion As Long
Public G_UpdateAvailable As Boolean
Public G_UpdateString As String
Public G_MyLicencseVersion As Long
Public G_Wartung As Boolean
Public G_WartungBis As Date

Public G_UpdateText As String
Public G_Lizenzen As Long
Public G_FullDemoBis As Date

Public G_Lizenznehmer As String
Public G_LizenznehmerAdresse As String

Public G_Passworte As Collection

Public G_RiskTabs As Collection ' RiskTab
Public G_RiskContains As Collection ' RiskVal
Public G_WhiteList As Collection ' RiskVal

Public G_RiskHadDimension As Boolean

Public Const C_RISK_TYPE_ECC As Long = 1
Public Const C_RISK_TYPE_FORMULA_CONTAINS As Long = 2
Public Const C_RISK_TYPE_NOT_IN_WHITE_LIST As Long = 3
Public Const C_RISK_TYPE_WHITE_LIST As Long = 4

Public Const C_RISK_COMP_TYPE_LESS As Long = 1
Public Const C_RISK_COMP_TYPE_LESSEQUAL As Long = 2
Public Const C_RISK_COMP_TYPE_EQUAL As Long = 3
Public Const C_RISK_COMP_TYPE_LARGEREQUAL As Long = 4
Public Const C_RISK_COMP_TYPE_LARGER As Long = 5


Public G_RiskLow As Double
Public G_RiskMed As Double
Public G_RiskLowCol As Long
Public G_RiskMedCol As Long
Public G_RiskHighCol As Long
Public G_ColorCells As Boolean

Public G_CheckDimension As Boolean
Public G_CheckInputs As Boolean

Public TransToLocal As Collection
Public TransToE As Collection

Public G_conn As Object

Public Const MYadOpenDynamic As Long = 2
Public Const MYadLockPessimistic As Long = 2
Public Const MYadLockOptimistic As Long = 3
Public Const MYadLockReadOnly As Long = 1

Public G_cfgLogpfad As String
Public G_cfgTemppfad As String
Public G_cfgKeypfad As String
Public G_cfgPasswortpfad As String

Public G_StartScan As Date
Public G_EndScan As Date
Public G_SchedulerTimeCheckIgnore As Boolean
'Public G_ECCNoDimension As Boolean

Public G_ModulmenueDeaktivieren As Boolean

Public G_Cursorlocation As Long

Public G_DBConnectionString As String

Public G_NoMenu As Boolean
Public G_ChecksumVBA As Boolean ' 1
Public G_ChecksumNames As Boolean ' 2
Public G_ChecksumPivot As Boolean ' 4
Public G_ChecksumQueries As Boolean ' 8
Public G_ChecksumDiagrams As Boolean ' 16
Public G_ChecksumClone As Boolean ' 32

Public G_ChecksumVBAOri As Boolean ' 1
Public G_ChecksumNamesOri As Boolean ' 2
Public G_ChecksumPivotOri As Boolean ' 4
Public G_ChecksumQueriesOri As Boolean ' 8
Public G_ChecksumDiagramsOri As Boolean ' 16
Public G_ChecksumCloneOri As Boolean ' 32

Public G_ChecksumFlags As Long
Public G_ChecksumFlagsOri As Long
Public G_cfgTeilrisikoDeckeln As Boolean

Public G_HiglyEncryptedSheetPW As Long
Public G_HiglyEncryptedWorkbookPW  As Long

Public G_cfgIgnoreHighestPriority As Boolean
Public G_cfgPwCheckLimMB As Long

Public G_VerboseFileLogName As String
Public G_VerboseFileLog As Boolean
Public G_VerboseFileLogLogName As String


Public Sub ECCCreateHeaderAndFooter(ws As Worksheet)
    On Error Resume Next
    ' Datum der Generierung in die Fu|fffd|zeile eintragen
    With ws.PageSetup
        Dim usr As String
        usr = Environ("USERNAME")
        If Len(usr) Then
            '.LeftFooter = Texte(GSprache, TXT_GENERIERTAM) & Now() & " von " & usr
            .LeftFooter = FMT2("GLOBALS_1", Now(), usr)
        Else
            '.LeftFooter = Texte(GSprache, TXT_GENERIERTAM) & Now()
            .LeftFooter = FMT1("GLOBALS_2", Now())
        End If
        .RightHeader = "&7" & ProgNameLong & " " & MyVersion & vbLf & MainMenu.Cop & " Norman Neubert / stromwerken"
        If Len(trsShrt) > 0 Then
          .LeftHeader = "&7 " & trsShrt
        Else
          '.LeftHeader = "&7Demoversion - Einsatz nur zu Testzwecken"
          .LeftHeader = "&7" & FMT0("GLOBALS_3")
        End If
    End With

End Sub

Function GenerateSheet(outputSheetName As String, Optional oldWorkbookName As String = "") As String
    
    Dim myFilename As String
    Dim i As Long
    If Len(oldWorkbookName) = 0 Then
        Workbooks.Add
        myFilename = ActiveWorkbook.name
    Else
        myFilename = oldWorkbookName
    End If
    Application.DisplayAlerts = False
    If Len(oldWorkbookName) = 0 Then
        For i = ActiveWorkbook.Sheets.count To 2 Step -1
          ActiveWorkbook.Sheets(i).Delete
        Next i
        ActiveWorkbook.Sheets(i).name = "LeeresBlatt"
        ThisWorkbook.Sheets(outputSheetName & "Leer").Activate
        ThisWorkbook.Sheets(outputSheetName & "Leer").Copy Workbooks(myFilename).Sheets(1)
        ActiveWorkbook.Sheets(outputSheetName & "Leer").name = outputSheetName
        ActiveWorkbook.Sheets("LeeresBlatt").Delete
    Else
'        ActiveWorkbook.Sheets.Add after:=ActiveWorkbook.Sheets(ActiveWorkbook.Sheets.Count)
        ThisWorkbook.Sheets(outputSheetName & "Leer").Copy After:=Workbooks(myFilename).Sheets(Workbooks(myFilename).Sheets.count)
        Workbooks(myFilename).Sheets(outputSheetName & "Leer").name = outputSheetName
    End If
    
    Application.DisplayAlerts = True

    Globals.ECCCreateHeaderAndFooter ActiveSheet
    GenerateSheet = myFilename
End Function

Function SheetHasPassword(oxlwsheet)
    SheetHasPassword = True
    On Error GoTo password_notok
    ' Wir probieren das Ganze mit einem idiotischen Passwort
    oxlwsheet.Unprotect "12%%XXy<11!A"
    SheetHasPassword = False
password_notok:
End Function

Function WorkbookHasPassword(oxlwbook)
    WorkbookHasPassword = True
    On Error GoTo password_notok
    ' Wir probieren das Ganze mit einem idiotischen Passwort
    oxlwbook.Unprotect "12%%XXy<11!A"
    WorkbookHasPassword = False
password_notok:
End Function

Public Function StringAdd(stringlist, txt As String) As Boolean
    StringAdd = False
    Dim item
    For Each item In stringlist
        If item = txt Then Exit Function
    Next item
    StringAdd = True
    stringlist.Add txt
End Function

Function CheckVBAAccessAllowed() As Boolean
  CheckVBAAccessAllowed = True
  On Error GoTo noVBA
  If ThisWorkbook.VBProject.Protection = 1 Then ' vbext_pp_locked
  End If
  Exit Function
noVBA:
  CheckVBAAccessAllowed = False
End Function

Function FormulaAnalyzable(c) As Boolean
  FormulaAnalyzable = True
  On Error GoTo notAnalyzable
  If c.Formula = "a" Then
  End If
  Exit Function
notAnalyzable:
  FormulaAnalyzable = False
End Function

Function TranslateFuncToLocal(s As String) As String
  On Error GoTo noTrans
  TranslateFuncToLocal = TransToLocal(s)
  Exit Function
noTrans:
  TranslateFuncToLocal = s
End Function
Function TranslateFuncToE(s As String) As String
  On Error GoTo noTrans
  TranslateFuncToE = TransToE(s)
  Exit Function
noTrans:
  TranslateFuncToE = s
End Function


Sub FreeAllMem()
'  ActiveSheet.UsedRange
  Set TransToLocal = Nothing
  Set TransToE = Nothing
  Set xlsDateien = Nothing
  Set inaccessablePaths = Nothing
  Set Funcs = Nothing
  Set FuncArray = Nothing
End Sub

Function FilenameDoesntExistAbove(Pfad As String, name As String) As Boolean
  Dim item As ScanFile
  Dim pos As Long
  FilenameDoesntExistAbove = True
  If Len(Pfad) <= 1 Then Exit Function
  pos = Len(Pfad)
  pos = pos - 1
  Do
    pos = InStrMyRev(Pfad, "\", pos)
    If pos < 0 Then Exit Do
    For Each item In xlsDateien
      If Left(Pfad, pos) & name = item.m_Name Then
        FilenameDoesntExistAbove = False
        Exit Function
      End If
    Next item
    pos = pos - 1
  Loop While pos > 0
End Function

Sub ScanDirs(Pfad As String, nichtaelterals As Long, nichtkleinerals As Long, gleichenamenignorieren As Boolean, unterverzeichnisseIgnorieren As Boolean, infoLabel, Optional firstscan As Boolean = True)

'   .MousePointer = fmMousePointerHourGlass
'  Me.MousePointer = fmMousePointerDefault

  If firstscan Then AmountScanned = 0

  Dim name As String
  Dim Verzeichnisse As New Collection
  ' Erst mal alle Verzeichnisse holen!
  On Error GoTo inaccessablePath
  name = Dir(Pfad & "\*.*", vbDirectory) ' Ersten Eintrag abrufen.
'    On Error GoTo 0

  Dim cnt As Long
  cnt = 0

  On Error Resume Next
    Do While name <> ""    ' Schleife beginnen.
    
        If PathSelect.WasOK = False Then Exit Do
    
        
        ' Aktuelles und |fffd|bergeordnetes Verzeichnis ignorieren.
        If name <> "." And name <> ".." Then
            ' Mit bit-weisem Vergleich sicherstellen, da|fffd| name ein
            ' Verzeichnis ist.
            Err.Number = 0
            If (GetAttr(Pfad & "\" & name) And vbDirectory) = vbDirectory Then
                If Err.Number = 0 Then Verzeichnisse.Add Pfad & "\" & name  ' Eintrag nur anzeigen, wenn es sich
            Else
                TotalFilesTested = TotalFilesTested + 1
                
                If TotalFilesTested Mod 20 = 0 Then
                   'infoLabel.Caption = "    " & TotalFilesTested & " gepr|fffd|ft, " & AmountScanned & " Dateien bisher gefunden..."
                   infoLabel.Caption = FMT2("GLOBALS_4", TotalFilesTested, AmountScanned)
                   DoEvents
                End If
                ' Ansonsten ist es eine Datei! Wenn es ein Excel-Sheet ist, dann wird
                ' es in die xlsDateien - Collection mitaufgenommen
                
                If UCase(name) Like "*.XL?" Or UCase(name) Like "*.XL??" Then
                    ' Nicht die eigene Datei!!!!!
                    If ThisWorkbook.FullName <> Pfad & "\" & name Then
                      Dim used As Boolean
                      used = False
                      ' Wenn die Dateikriterien passen
                      If MyFileLen(Pfad & "\" & name) >= nichtkleinerals * 1024 Then
                        Dim FD As Date
                        FD = Format(MyFileDateTime(Pfad & "\" & name), "Short Date")
                        If Format(DateAdd("m", -nichtaelterals, Now()), "Short Date") <= FD Then
                          If gleichenamenignorieren = True Then
                            If FilenameDoesntExistAbove(Pfad, name) Then
                              AmountScanned = AmountScanned + 1
                              If Not unterverzeichnisseIgnorieren Then
                                'infoLabel.Caption = "    " & TotalFilesTested & " gepr|fffd|ft, " & AmountScanned & " Dateien bisher gefunden..."
                                infoLabel.Caption = FMT2("GLOBALS_4", TotalFilesTested, AmountScanned)
                                DoEvents
                              End If
                              
                              Debug.Print Pfad & "\" & name
                              Dim sf As ScanFile
                              Set sf = New ScanFile
                              sf.m_Name = Pfad & "\" & name
                              sf.m_OEID = 0
                              sf.m_idvDateiID = 0
                              sf.m_CheckerSettings = -1
                              xlsDateien.Add sf
                              used = True
                            Else
                              TotalUnusedBytesDouble = TotalUnusedBytesDouble + MyFileLen(Pfad & "\" & name)
                              TotalUnusedFilesDouble = TotalUnusedFilesDouble + 1
                            End If
                          Else
                            AmountScanned = AmountScanned + 1
                            Debug.Print Pfad & "\" & name
                            Set sf = New ScanFile
                            sf.m_Name = Pfad & "\" & name
                            sf.m_OEID = 0
                            sf.m_idvDateiID = 0
                            sf.m_CheckerSettings = -1
                            xlsDateien.Add sf
                            If Not unterverzeichnisseIgnorieren Then
                              'infoLabel.Caption = "    " & TotalFilesTested & " gepr|fffd|ft, " & AmountScanned & " Dateien bisher gefunden..."
                              infoLabel.Caption = FMT2("GLOBALS_4", TotalFilesTested, AmountScanned)
                              DoEvents
                            End If
                            used = True
                          End If
                        Else
                          TotalUnusedBytesOlder = TotalUnusedBytesOlder + MyFileLen(Pfad & "\" & name)
                          TotalUnusedFilesOlder = TotalUnusedFilesOlder + 1
                        End If
                      Else
                        TotalUnusedBytesSmaller = TotalUnusedBytesSmaller + MyFileLen(Pfad & "\" & name)
                        TotalUnusedFilesSmaller = TotalUnusedFilesSmaller + 1
                      End If
                      If Not used Then
                        TotalUnusedBytes = TotalUnusedBytes + MyFileLen(Pfad & "\" & name)
                        TotalUnusedFiles = TotalUnusedFiles + 1
                      Else
                        TotalUsedBytes = TotalUsedBytes + MyFileLen(Pfad & "\" & name)
                        TotalUsedFiles = TotalUsedFiles + 1
                      End If
                    End If
                End If
            End If
        End If
        name = Dir ' N|fffd|chsten Eintrag abrufen.
    Loop
    
    Dim item
    Dim tstring As String
    If Not unterverzeichnisseIgnorieren Then
      For Each item In Verzeichnisse
          tstring = item
          ScanDirs tstring, nichtaelterals, nichtkleinerals, gleichenamenignorieren, unterverzeichnisseIgnorieren, infoLabel, False
      Next item
    End If
    
    Set Verzeichnisse = Nothing

    Exit Sub
    
inaccessablePath:
    inaccessablePaths.Add Pfad

End Sub


Sub SaveMAKriterienSettings()
  SaveSetting _
     appname:="Stromwerken", _
     Section:=progNameShort, _
     Key:="NichtAelterAls", _
     setting:=PathSelect.selMonate
  
  SaveSetting _
     appname:="Stromwerken", _
     Section:=progNameShort, _
     Key:="NichtKleinerAls", _
     setting:=PathSelect.selKB
  
  If PathSelect.selGleicheNamenIgnorieren Then
    SaveSetting _
       appname:="Stromwerken", _
       Section:=progNameShort, _
       Key:="GleicheNamenIgnorieren", _
       setting:=1
  Else
    SaveSetting _
       appname:="Stromwerken", _
       Section:=progNameShort, _
       Key:="GleicheNamenIgnorieren", _
       setting:=0
  End If
  
  If PathSelect.selUnterverzeichnisseIgnorieren Then
    SaveSetting _
       appname:="Stromwerken", _
       Section:=progNameShort, _
       Key:="UnterverzeichnisseIgnorieren", _
       setting:=1
  Else
    SaveSetting _
       appname:="Stromwerken", _
       Section:=progNameShort, _
       Key:="UnterverzeichnisseIgnorieren", _
       setting:=0
  End If
  
End Sub

Function GetKriterien(Pfad As String, nichtaelterals As Long, nichtkleinerals As Long, gleichenamenignorieren As Boolean, unterverzeichnisseIgnorieren As Boolean, infoLabel)
  Set xlsDateien = New Collection
  Set inaccessablePaths = New Collection
  
  TotalUsedBytes = 0
  TotalUsedFiles = 0
  TotalUnusedBytes = 0
  TotalUnusedFiles = 0
  TotalUnusedBytesOlder = 0
  TotalUnusedFilesOlder = 0
  TotalUnusedBytesSmaller = 0
  TotalUnusedFilesSmaller = 0
  TotalUnusedBytesDouble = 0
  TotalUnusedFilesDouble = 0

  TotalFilesTested = 0
  ScanDirs Pfad, nichtaelterals, nichtkleinerals, gleichenamenignorieren, unterverzeichnisseIgnorieren, infoLabel
  
'  If GSprache = 1 Then
'    GetKriterien = "Im Verzeichnis '" & Pfad & "' werden " & TotalUsedFiles & " Datei(en) mit " & Format((TotalUsedBytes) / 1024, "##,##0") & "Kb gescannt." & vbCrLf & vbCrLf & _
'      "Insgesamt werden " & TotalUnusedFiles & " Datei(en) mit " & Format((TotalUnusedBytes) / 1024, "##,##0") & "Kb ignoriert." & vbCrLf & _
'      "-  " & TotalUnusedFilesSmaller & " Datei(en) mit " & Format((TotalUnusedBytesSmaller) / 1024, "##,##0") & "Kb wegen der Einschr|fffd|nkung 'Gr|fffd||fffd|e'," & vbCrLf & _
'      "-  " & TotalUnusedFilesOlder & " Datei(en) mit " & Format((TotalUnusedBytesOlder) / 1024, "##,##0") & "Kb wegen der Einschr|fffd|nkung 'Monate'," & vbCrLf & _
'      "-  " & TotalUnusedFilesDouble & " Datei(en) mit " & Format((TotalUnusedBytesDouble) / 1024, "##,##0") & "Kb wegen der Einschr|fffd|nkung 'Gleiche Namen'"
'  Else
'    GetKriterien = TotalUsedFiles & " file(s) in '" & Pfad & "' with " & Format((TotalUsedBytes) / 1024, "##,##0") & "Kb will be scanned." & vbCrLf & vbCrLf & _
'      TotalUnusedFiles & " file(s) with " & Format((TotalUnusedBytes) / 1024, "##,##0") & "Kb will be ignored." & vbCrLf & _
'      "-  " & TotalUnusedFilesSmaller & " file(s) with " & Format((TotalUnusedBytesSmaller) / 1024, "##,##0") & "Kb because of limitation 'size'," & vbCrLf & _
'      "-  " & TotalUnusedFilesOlder & " file(s) with " & Format((TotalUnusedBytesOlder) / 1024, "##,##0") & "Kb because of limitation 'months'," & vbCrLf & _
'      "-  " & TotalUnusedFilesDouble & " file(s) with " & Format((TotalUnusedBytesDouble) / 1024, "##,##0") & "Kb because of limitation 'same names'"
'  End If

  GetKriterien = FMT3("GLOBALS_5", Pfad, TotalUsedFiles, Format((TotalUsedBytes) / 1024, "##,##0")) & vbCrLf & vbCrLf & _
    FMT2("PATHSEL_20", TotalUnusedFiles, Format((TotalUnusedBytes) / 1024, "##,##0")) & vbCrLf & _
    FMT6("PATHSEL_21", TotalUnusedFilesSmaller, Format((TotalUnusedBytesSmaller) / 1024, "##,##0"), TotalUnusedFilesOlder, Format((TotalUnusedBytesOlder) / 1024, "##,##0"), TotalUnusedFilesDouble, Format((TotalUnusedBytesDouble) / 1024, "##,##0"))
  
  Set xlsDateien = Nothing
  Set inaccessablePaths = Nothing

End Function


Function RemoveCommentsAndLineFeeds(ByVal txt As String) As String
  Dim i As Long
  Dim nutxt As String
  For i = 1 To Len(txt)
    If Mid(txt, i, 1) = Chr(34) Then
      nutxt = nutxt + Mid(txt, i, 1)
      i = i + 1
      While Mid(txt, i, 1) <> Chr(34)
        nutxt = nutxt + Mid(txt, i, 1)
        i = i + 1
      Wend
      nutxt = nutxt + Mid(txt, i, 1)
    ElseIf Mid(txt, i, 1) = "'" Then
      While Mid(txt, i, 1) <> Chr(10) And Mid(txt, i, 1) <> Chr(13) And i < Len(txt)
        i = i + 1
      Wend
      nutxt = nutxt + Mid(txt, i, 1)
    ElseIf Mid(txt, i, 1) <> vbCr And Mid(txt, i, 1) <> vbLf Then
      nutxt = nutxt + Mid(txt, i, 1)
    End If
  Next i
  RemoveCommentsAndLineFeeds = nutxt
End Function


Function GetRiskValues() As Boolean
  GetRiskValues = False
  Dim wb As Excel.Workbook
  Dim rs
  
  G_RiskHadDimension = False
  
  Dim riskFile As String
  
  ' Erst mal indiv XLSX mit Language
'  If FileExists(gTranslation.GetLocalizedFile(ThisWorkbook.path & "\Excel-Sheet-Checker Risk_Indiv.xlsx")) Then
'    riskFile = gTranslation.GetLocalizedFile(ThisWorkbook.path & "\Excel-Sheet-Checker Risk_Indiv.xlsx")
'  ' Dann indiv XLS mit Language
'  ElseIf FileExists(gTranslation.GetLocalizedFile(ThisWorkbook.path & "\Excel-Sheet-Checker Risk_Indiv.xls")) Then
'    riskFile = gTranslation.GetLocalizedFile(ThisWorkbook.path & "\Excel-Sheet-Checker Risk_Indiv.xls")
'  ' Dann indiv XLSX OHNE Language
  If FileExists(ThisWorkbook.path & "\Excel-Sheet-Checker Risk_Indiv.xlsx") Then
    riskFile = ThisWorkbook.path & "\Excel-Sheet-Checker Risk_Indiv.xlsx"
  ' Dann indiv XLS OHNE Language
  ElseIf FileExists(ThisWorkbook.path & "\Excel-Sheet-Checker Risk_Indiv.xls") Then
    riskFile = ThisWorkbook.path & "\Excel-Sheet-Checker Risk_Indiv.xls"
  Else
    riskFile = ThisWorkbook.path & "\Excel-Sheet-Checker Risk.xls"
  End If
  
  ' Laden der Risikodatei aus Excel oder aus der DB?
  If AR_UseDB = False Then
    If Not GetExcelFile(riskFile, wb) Then
      'MsgBox "Die Risikodatei '" & ThisWorkbook.path & "\Excel-Sheet-Checker Risk.xls' fehlt. Es kann keine Risikoanalyse vorgenommen werden!", vbCritical, "Excel-Sheet-Checker"
      MsgBox FMT1("GLOBALS_6", riskFile), vbCritical, FMT0("MM_1")
      Exit Function
    End If
    
    Dim regeln As String
    Dim risiken As String
    Dim gesamtrisiko As String
    regeln = TranslationSheetExists(wb, Array("Regeln", "Rules"))
    risiken = TranslationSheetExists(wb, Array("Risiken", "Risks"))
    gesamtrisiko = TranslationSheetExists(wb, Array("Gesamtrisiko", "Total Risk"))
    
    If Not WorksheetExists(wb, regeln) Then
      'MsgBox "Es existiert keine Tabelle mit dem Namen 'Regeln' in der Datei '" & ThisWorkbook.path & "\Excel-Sheet-Checker Risk.xls' fehlt. Es kann keine Risikoanalyse vorgenommen werden!", vbCritical, "Excel-Sheet-Checker"
      MsgBox FMT1("GLOBALS_7", riskFile), vbCritical, FMT0("MM_1")
      Exit Function
    End If
    
    If Not WorksheetExists(wb, risiken) Then
      'MsgBox "Es existiert keine Tabelle mit dem Namen 'Risiken' in der Datei '" & ThisWorkbook.path & "\Excel-Sheet-Checker Risk.xls' fehlt. Es kann keine Risikoanalyse vorgenommen werden!", vbCritical, "Excel-Sheet-Checker"
      MsgBox FMT1("GLOBALS_8", riskFile), vbCritical, FMT0("MM_1")
      Exit Function
    End If
    
    If Not WorksheetExists(wb, gesamtrisiko) Then
      'MsgBox "Es existiert keine Tabelle mit dem Namen 'Gesamtrisiko' in der Datei '" & ThisWorkbook.path & "\Excel-Sheet-Checker Risk.xls' fehlt. Es kann keine Gesamtrisikoanalyse vorgenommen werden!", vbCritical, "Excel-Sheet-Checker"
      MsgBox FMT1("GLOBALS_9", riskFile), vbCritical, FMT0("MM_1")
      Exit Function
    End If
    
    
    With wb.Sheets(gesamtrisiko)
      
      G_RiskLow = .Cells(2, 2)
      G_RiskMed = .Cells(3, 2)
      G_RiskLowCol = .Cells(2, 3).Interior.Color
      G_RiskMedCol = .Cells(3, 3).Interior.Color
      G_RiskHighCol = .Cells(4, 3).Interior.Color
    
    End With
  Else
      If G_conn Is Nothing Then Exit Function
      
      Set rs = CreateObject("ADODB.recordset")
      rs.Open "SELECT * FROM ECCRisikoGesamt", G_conn, 2, 1
      If rs.EOF Then
        'MsgBox "Es sind keine GesamtRisikodaten in der Datenbank des IDV-Trackers enthalten. Es kann keine Gesamtrisikoanalyse vorgenommen werden!", vbCritical, "Excel-Sheet-Checker"
        MsgBox FMT0("GLOBALS_10"), vbCritical, FMT0("MM_1")
        rs.Close
        Set rs = Nothing
        Exit Function
      End If
      
      G_RiskLow = rs.Fields("Gering").value
      G_RiskMed = rs.Fields("Mittel").value
      G_RiskLowCol = rs.Fields("GeringFarbe").value
      G_RiskMedCol = rs.Fields("MittelFarbe").value
      G_RiskHighCol = rs.Fields("HochFarbe").value
      
      rs.Close
      Set rs = Nothing
  End If
  
  Set G_RiskTabs = New Collection
  Set G_RiskContains = New Collection
  Set G_WhiteList = New Collection
  
  
  If AR_UseDB = False Then
    Dim y As Long
    y = 2
    Dim rt As RiskTab
    With wb.Worksheets(risiken)
      Do While Not IsEmpty(.Cells(y, 1))
      
        Set rt = New RiskTab
        If Not rt.Init(wb, y, riskFile, riskFile) Then Exit Function
        G_RiskTabs.Add rt, .Cells(y, 1)
        y = y + 1
      Loop
    End With
    wb.Close False
    Set wb = Nothing
  
  
  Else
      
      
      
      Set rs = CreateObject("ADODB.recordset")
      rs.Open "SELECT * FROM ECCRisiken", G_conn, 2, 1
      If rs.EOF Then
        'MsgBox "Es sind keine Risikodaten in der Datenbank des IDV-Trackers enthalten. Es kann keine Gesamtrisikoanalyse vorgenommen werden!", vbCritical, "Excel-Sheet-Checker"
        MsgBox FMT0("GLOBALS_11"), vbCritical, FMT0("MM_1")
        rs.Close
        Set rs = Nothing
        Exit Function
      End If
      
      
      Do While Not rs.EOF
      
        Set rt = New RiskTab
        If Not rt.InitDB(G_conn, rs) Then Exit Function
        G_RiskTabs.Add rt, rs.Fields("Risiko").value
        rs.movenext
      Loop
      rs.Close
      
      
      rs.Open "SELECT Parameter FROM ECCRegeln WHERE Parameter like 'DIMENSIONX' or Parameter like 'DIMENSIONY' or Parameter like 'DIMENSION3D'"
      If Not rs.EOF Then
        G_RiskHadDimension = True
      End If
      rs.Close
      
      Set rs = Nothing
  End If
  
  GetRiskValues = True
End Function

Public Sub ResetRisks()
    Dim rtitem As RiskTab
    Dim rvitem As RiskVal
    For Each rtitem In G_RiskTabs
        For Each rvitem In rtitem.m_Vals
            rvitem.m_Hit = False
            rvitem.m_Matches = 0
            rvitem.m_FirstMatch = ""
            rvitem.m_FirstMatchAddress = ""
        Next rvitem
    Next rtitem
    
    For Each rvitem In G_RiskContains
        rvitem.m_Hit = False
        rvitem.m_Matches = 0
        rvitem.m_FirstMatch = ""
        rvitem.m_FirstMatchAddress = ""
    Next rvitem
    
    For Each rvitem In G_WhiteList
        rvitem.m_Hit = False
        rvitem.m_Matches = 0
        rvitem.m_FirstMatch = ""
        rvitem.m_FirstMatchAddress = ""
    Next rvitem
    

End Sub

Public Function CollectionItemExists(c As Collection, name As String) As Boolean
  On Error GoTo notReadable
  Dim s As String
  s = CStr(c(name))
  CollectionItemExists = True
  Exit Function
  
notReadable:
  CollectionItemExists = False
End Function


Attribute VB_Name = "Hash"
Option Explicit

Private Const BITS_TO_A_BYTE = 8
Private Const BYTES_TO_A_WORD = 4
Private Const BITS_TO_A_WORD = 32

#If VBA7 Then
Private Declare PtrSafe Function apiGetComputerName Lib "kernel32" Alias _
    "GetComputerNameA" (ByVal lpBuffer As String, nSize As Long) As Long
#Else
Private Declare Function apiGetComputerName Lib "kernel32" Alias _
    "GetComputerNameA" (ByVal lpBuffer As String, nSize As Long) As Long
#End If

Public Function GetComputerName() As String
'Returns the computername
    Dim lngLen As Long, lngX As Long
    Dim strCompName As String
    lngLen = 16
    strCompName = String$(lngLen, 0)
    lngX = apiGetComputerName(strCompName, lngLen)
    If lngX <> 0 Then
        GetComputerName = Left$(strCompName, lngLen)
    Else
        GetComputerName = ""
    End If
End Function

Function GetDocProp(wb As Excel.Workbook, txt As String) As String
  On Error Resume Next
  GetDocProp = ""
  GetDocProp = wb.BuiltinDocumentProperties(txt)
End Function

Function GetFileHash(ByVal uncpathfname As String) As String

    If Mid(uncpathfname, 2, 1) <> ":" Then
        GetFileHash = SHA256(uncpathfname)
'        GetFileHash = SHA256(uncpathfname & "|" & GetDocProp(wb, "Author") & GetDocProp(wb, "Creation date"))
    Else
        GetFileHash = SHA256(uncpathfname & "|" & GetComputerName)
'        GetFileHash = SHA256(uncpathfname & "|" & GetComputerName & "|" & GetDocProp(wb, "Author") & GetDocProp(wb, "Creation date"))
    End If

End Function


Private Function LShift(lValue, iShiftBits)
Dim m_lOnBits
m_lOnBits = Array(CLng(1), CLng(3), CLng(7), CLng(15), CLng(31), CLng(63), CLng(127), CLng(255), CLng(511), CLng(1023), CLng(2047), CLng(4095), CLng(8191), CLng(16383), CLng(32767), CLng(65535), CLng(131071), CLng(262143), CLng(524287), CLng(1048575), CLng(2097151), CLng(4194303), CLng(8388607), CLng(16777215), CLng(33554431), CLng(67108863), CLng(134217727), CLng(268435455), CLng(536870911), CLng(1073741823), CLng(2147483647))

Dim m_l2Power
m_l2Power = Array(1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824)


    If iShiftBits = 0 Then
        LShift = lValue
        Exit Function
    ElseIf iShiftBits = 31 Then
        If lValue And 1 Then
            LShift = &H80000000
        Else
            LShift = 0
        End If
        Exit Function
    ElseIf iShiftBits < 0 Or iShiftBits > 31 Then
        Err.Raise 6
    End If
    
    If (lValue And m_l2Power(31 - iShiftBits)) Then
        LShift = ((lValue And m_lOnBits(31 - (iShiftBits + 1))) * m_l2Power(iShiftBits)) Or &H80000000
    Else
        LShift = ((lValue And m_lOnBits(31 - iShiftBits)) * m_l2Power(iShiftBits))
    End If
End Function



Private Function RShift(lValue, iShiftBits)

  Dim m_l2Power
  m_l2Power = Array(1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824)

    If iShiftBits = 0 Then
        RShift = lValue
        Exit Function
    ElseIf iShiftBits = 31 Then
        If lValue And &H80000000 Then
            RShift = 1
        Else
            RShift = 0
        End If
        Exit Function
    ElseIf iShiftBits < 0 Or iShiftBits > 31 Then
        Err.Raise 6
    End If
    
    RShift = (lValue And &H7FFFFFFE) \ m_l2Power(iShiftBits)
    
    If (lValue And &H80000000) Then
        RShift = (RShift Or (&H40000000 \ m_l2Power(iShiftBits - 1)))
    End If
End Function



Private Function AddUnsigned(lX, lY)
    Dim lX4, lY4, lX8, lY8, lResult
 
    lX8 = lX And &H80000000
    lY8 = lY And &H80000000
    lX4 = lX And &H40000000
    lY4 = lY And &H40000000
 
    lResult = (lX And &H3FFFFFFF) + (lY And &H3FFFFFFF)
 
    If lX4 And lY4 Then
        lResult = lResult Xor &H80000000 Xor lX8 Xor lY8
    ElseIf lX4 Or lY4 Then
        If lResult And &H40000000 Then
            lResult = lResult Xor &HC0000000 Xor lX8 Xor lY8
        Else
            lResult = lResult Xor &H40000000 Xor lX8 Xor lY8
        End If
    Else
        lResult = lResult Xor lX8 Xor lY8
    End If
 
    AddUnsigned = lResult
End Function



Private Function Ch(x, y, z)
    Ch = ((x And y) Xor ((Not x) And z))
End Function



Private Function Maj(x, y, z)
    Maj = ((x And y) Xor (x And z) Xor (y And z))
End Function



Private Function s(x, n)
Dim m_lOnBits, m_l2Power, K
m_lOnBits = Array(CLng(1), CLng(3), CLng(7), CLng(15), CLng(31), CLng(63), CLng(127), CLng(255), CLng(511), CLng(1023), CLng(2047), CLng(4095), CLng(8191), CLng(16383), CLng(32767), CLng(65535), CLng(131071), CLng(262143), CLng(524287), CLng(1048575), CLng(2097151), CLng(4194303), CLng(8388607), CLng(16777215), CLng(33554431), CLng(67108863), CLng(134217727), CLng(268435455), CLng(536870911), CLng(1073741823), CLng(2147483647))

m_l2Power = Array(1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824)
K = Array(&H428A2F98, &H71374491, &HB5C0FBCF, &HE9B5DBA5, &H3956C25B, &H59F111F1, &H923F82A4, &HAB1C5ED5, &HD807AA98, &H12835B01, &H243185BE, &H550C7DC3, &H72BE5D74, &H80DEB1FE, &H9BDC06A7, &HC19BF174, &HE49B69C1, &HEFBE4786, &HFC19DC6, &H240CA1CC, &H2DE92C6F, &H4A7484AA, &H5CB0A9DC, &H76F988DA, &H983E5152, &HA831C66D, &HB00327C8, &HBF597FC7, &HC6E00BF3, &HD5A79147, &H6CA6351, &H14292967, &H27B70A85, &H2E1B2138, &H4D2C6DFC, &H53380D13, &H650A7354, &H766A0ABB, &H81C2C92E, &H92722C85, &HA2BFE8A1, &HA81A664B, &HC24B8B70, &HC76C51A3, &HD192E819, &HD6990624, &HF40E3585, &H106AA070, &H19A4C116, &H1E376C08, &H2748774C, &H34B0BCB5, &H391C0CB3, &H4ED8AA4A, &H5B9CCA4F, &H682E6FF3, &H748F82EE, &H78A5636F, &H84C87814, &H8CC70208, &H90BEFFFA, &HA4506CEB, &HBEF9A3F7, &HC67178F2)

    s = (RShift(x, (n And m_lOnBits(4))) Or LShift(x, (32 - (n And m_lOnBits(4)))))
End Function



Private Function r(x, n)
Dim m_lOnBits
m_lOnBits = Array(CLng(1), CLng(3), CLng(7), CLng(15), CLng(31), CLng(63), CLng(127), CLng(255), CLng(511), CLng(1023), CLng(2047), CLng(4095), CLng(8191), CLng(16383), CLng(32767), CLng(65535), CLng(131071), CLng(262143), CLng(524287), CLng(1048575), CLng(2097151), CLng(4194303), CLng(8388607), CLng(16777215), CLng(33554431), CLng(67108863), CLng(134217727), CLng(268435455), CLng(536870911), CLng(1073741823), CLng(2147483647))

    r = RShift(x, CLng(n And m_lOnBits(4)))
End Function



Private Function Sigma0(x)
    Sigma0 = (s(x, 2) Xor s(x, 13) Xor s(x, 22))
End Function



Private Function Sigma1(x)
    Sigma1 = (s(x, 6) Xor s(x, 11) Xor s(x, 25))
End Function



Private Function Gamma0(x)
    Gamma0 = (s(x, 7) Xor s(x, 18) Xor r(x, 3))
End Function



Private Function Gamma1(x)
    Gamma1 = (s(x, 17) Xor s(x, 19) Xor r(x, 10))
End Function



Private Function ConvertToWordArray(sMessage)
    Dim lMessageLength, lNumberOfWords, lWordArray(), lBytePosition, lByteCount
    Dim lWordCount, lByte
    
    Const MODULUS_BITS = 512
    Const CONGRUENT_BITS = 448
    
    lMessageLength = Len(sMessage)
    
    lNumberOfWords = (((lMessageLength + ((MODULUS_BITS - CONGRUENT_BITS) \ BITS_TO_A_BYTE)) \ (MODULUS_BITS \ BITS_TO_A_BYTE)) + 1) * (MODULUS_BITS \ BITS_TO_A_WORD)
    ReDim lWordArray(lNumberOfWords - 1)
    
    lBytePosition = 0
    lByteCount = 0
    Do Until lByteCount >= lMessageLength
        lWordCount = lByteCount \ BYTES_TO_A_WORD
        
        lBytePosition = (3 - (lByteCount Mod BYTES_TO_A_WORD)) * BITS_TO_A_BYTE
        
        lByte = AscB(Mid(sMessage, lByteCount + 1, 1))
        
        lWordArray(lWordCount) = lWordArray(lWordCount) Or LShift(lByte, lBytePosition)
        lByteCount = lByteCount + 1
    Loop

    lWordCount = lByteCount \ BYTES_TO_A_WORD
    lBytePosition = (3 - (lByteCount Mod BYTES_TO_A_WORD)) * BITS_TO_A_BYTE

    lWordArray(lWordCount) = lWordArray(lWordCount) Or LShift(&H80, lBytePosition)

    lWordArray(lNumberOfWords - 1) = LShift(lMessageLength, 3)
    lWordArray(lNumberOfWords - 2) = RShift(lMessageLength, 29)
    
    ConvertToWordArray = lWordArray
End Function



Public Function SHA256(sMessage)

Dim K
K = Array(&H428A2F98, &H71374491, &HB5C0FBCF, &HE9B5DBA5, &H3956C25B, &H59F111F1, &H923F82A4, &HAB1C5ED5, &HD807AA98, &H12835B01, &H243185BE, &H550C7DC3, &H72BE5D74, &H80DEB1FE, &H9BDC06A7, &HC19BF174, &HE49B69C1, &HEFBE4786, &HFC19DC6, &H240CA1CC, &H2DE92C6F, &H4A7484AA, &H5CB0A9DC, &H76F988DA, &H983E5152, &HA831C66D, &HB00327C8, &HBF597FC7, &HC6E00BF3, &HD5A79147, &H6CA6351, &H14292967, &H27B70A85, &H2E1B2138, &H4D2C6DFC, &H53380D13, &H650A7354, &H766A0ABB, &H81C2C92E, &H92722C85, &HA2BFE8A1, &HA81A664B, &HC24B8B70, &HC76C51A3, &HD192E819, &HD6990624, &HF40E3585, &H106AA070, &H19A4C116, &H1E376C08, &H2748774C, &H34B0BCB5, &H391C0CB3, &H4ED8AA4A, &H5B9CCA4F, &H682E6FF3, &H748F82EE, &H78A5636F, &H84C87814, &H8CC70208, &H90BEFFFA, &HA4506CEB, &HBEF9A3F7, &HC67178F2)
    Dim hash, m, w(63), a, b, c, d, e, f, g, h, i, j, t1, t2
    
    hash = Array(&H6A09E667, &HBB67AE85, &H3C6EF372, &HA54FF53A, &H510E527F, &H9B05688C, &H1F83D9AB, &H5BE0CD19)
    
    m = ConvertToWordArray(sMessage)
    
    For i = 0 To UBound(m) Step 16
        a = hash(0)
        b = hash(1)
        c = hash(2)
        d = hash(3)
        e = hash(4)
        f = hash(5)
        g = hash(6)
        h = hash(7)
        
        For j = 0 To 63
            If j < 16 Then
                w(j) = m(j + i)
            Else
                w(j) = AddUnsigned(AddUnsigned(AddUnsigned(Gamma1(w(j - 2)), w(j - 7)), Gamma0(w(j - 15))), w(j - 16))
            End If
                
            t1 = AddUnsigned(AddUnsigned(AddUnsigned(AddUnsigned(h, Sigma1(e)), Ch(e, f, g)), K(j)), w(j))
            t2 = AddUnsigned(Sigma0(a), Maj(a, b, c))
            
            h = g
            g = f
            f = e
            e = AddUnsigned(d, t1)
            d = c
            c = b
            b = a
            a = AddUnsigned(t1, t2)
        Next
        
        hash(0) = AddUnsigned(a, hash(0))
        hash(1) = AddUnsigned(b, hash(1))
        hash(2) = AddUnsigned(c, hash(2))
        hash(3) = AddUnsigned(d, hash(3))
        hash(4) = AddUnsigned(e, hash(4))
        hash(5) = AddUnsigned(f, hash(5))
        hash(6) = AddUnsigned(g, hash(6))
        hash(7) = AddUnsigned(h, hash(7))
    Next
    
    SHA256 = LCase(Right("00000000" & Hex(hash(0)), 8) & Right("00000000" & Hex(hash(1)), 8) & Right("00000000" & Hex(hash(2)), 8) & Right("00000000" & Hex(hash(3)), 8) & Right("00000000" & Hex(hash(4)), 8) & Right("00000000" & Hex(hash(5)), 8) & Right("00000000" & Hex(hash(6)), 8) & Right("00000000" & Hex(hash(7)), 8))
End Function


Attribute VB_Name = "Helpers"
Option Explicit

'In ein Modul mit Namen "myLaufwerke"
Public Enum PRIORITY_CLASS
   NORMAL_PRIORITY_CLASS = &H20
   IDLE_PRIORITY_CLASS = &H40
   HIGH_PRIORITY_CLASS = &H80
   REALTIME_PRIORITY_CLASS = &H100
End Enum
Private Const PROCESS_DUP_HANDLE = &H40
#If VBA7 Then
Declare PtrSafe Function GetLogicalDrives& Lib "kernel32" ()
Private Declare PtrSafe Function GetDriveType Lib _
    "kernel32" Alias "GetDriveTypeA" _
    (ByVal nDrive As String) As Long

Declare PtrSafe Function WNetGetUser Lib "mpr.dll" _
      Alias "WNetGetUserA" (ByVal lpName As String, _
      ByVal lpUserName As String, lpnLength As Long) As Long


Private Declare PtrSafe Function apiGetComputerName Lib "kernel32" Alias _
    "GetComputerNameA" (ByVal lpBuffer As String, nSize As Long) As Long
Public Declare PtrSafe Function FindExecutable Lib "shell32.dll" Alias _
    "FindExecutableA" (ByVal lpFile As String, ByVal lpDirectory As String, ByVal lpResult As String) As Long

Private Declare PtrSafe Function GetShortPathName Lib "Kernel32.dll" _
  Alias "GetShortPathNameA" ( _
  ByVal lpszLongPath As String, _
  ByVal lpszShortPath As String, _
  ByVal cchBuffer As Long) As Long

Private Declare PtrSafe Function GetCurrentProcessId Lib "kernel32" () As Long
Private Declare PtrSafe Function OpenProcess Lib "kernel32" _
   (ByVal dwDesiredAccess As Long, _
    ByVal bInheritHandle As Long, _
    ByVal dwProcessId As Long) As Long
Private Declare PtrSafe Function CloseHandle Lib "kernel32" _
   (ByVal hObject As Long) As Long
Private Declare PtrSafe Function SetPriorityClass Lib "kernel32" _
  (ByVal hProcess As Long, ByVal dwPriorityClass As Long) _
   As Long

'Declare PtrSafe Function GetLogicalDrives& Lib "kernel32" ()
Public Declare PtrSafe Function apiGetTempPath Lib "kernel32" Alias "GetTempPathA" (ByVal nBufferLength As Long, ByVal lpBuffer As String) As Long

Private Declare PtrSafe Function GetTempFileName Lib "kernel32" _
         Alias "GetTempFileNameA" (ByVal lpszPath As String, _
         ByVal lpPrefixString As String, ByVal wUnique As Long, _
         ByVal lpTempFileName As String) As Long


#Else
Declare Function GetLogicalDrives& Lib "kernel32" ()
Private Declare Function GetDriveType Lib _
    "kernel32" Alias "GetDriveTypeA" _
    (ByVal nDrive As String) As Long

Declare Function WNetGetUser Lib "mpr.dll" _
      Alias "WNetGetUserA" (ByVal lpName As String, _
      ByVal lpUserName As String, lpnLength As Long) As Long


Private Declare Function apiGetComputerName Lib "kernel32" Alias _
    "GetComputerNameA" (ByVal lpBuffer As String, nSize As Long) As Long
Public Declare Function FindExecutable Lib "shell32.dll" Alias _
    "FindExecutableA" (ByVal lpFile As String, ByVal lpDirectory As String, ByVal lpResult As String) As Long

Private Declare Function GetShortPathName Lib "Kernel32.dll" _
  Alias "GetShortPathNameA" ( _
  ByVal lpszLongPath As String, _
  ByVal lpszShortPath As String, _
  ByVal cchBuffer As Long) As Long

Private Declare Function GetCurrentProcessId Lib "kernel32" () As Long
Private Declare Function OpenProcess Lib "kernel32" _
   (ByVal dwDesiredAccess As Long, _
    ByVal bInheritHandle As Long, _
    ByVal dwProcessId As Long) As Long
Private Declare Function CloseHandle Lib "kernel32" _
   (ByVal hObject As Long) As Long
Private Declare Function SetPriorityClass Lib "kernel32" _
  (ByVal hProcess As Long, ByVal dwPriorityClass As Long) _
   As Long

Public Declare Function apiGetTempPath Lib "kernel32" Alias "GetTempPathA" (ByVal nBufferLength As Long, ByVal lpBuffer As String) As Long
Private Declare Function GetTempFileName Lib "kernel32" _
         Alias "GetTempFileNameA" (ByVal lpszPath As String, _
         ByVal lpPrefixString As String, ByVal wUnique As Long, _
         ByVal lpTempFileName As String) As Long

#End If
    
    
    
    
Private Const DRIVE_CDROM = 5
Private Const DRIVE_FIXED = 3
Private Const DRIVE_RAMDISK = 6
Private Const DRIVE_REMOTE = 4
Private Const DRIVE_REMOVABLE = 2

Const NoError = 0       'The Function call was successful

Public Const vbTime As Long = 1000

Public G_LogEnabled As Boolean
Public G_Break As Boolean

   ' Declare for call to mpr.dll.

Function GetMachineName() As String
  'Returns the computername
  Dim lngLen As Long, lngX As Long
  Dim strCompName As String
  
  lngLen = 16
  strCompName = String$(lngLen, 0)
  lngX = apiGetComputerName(strCompName, lngLen)
  If lngX <> 0 Then
      GetMachineName = Left$(strCompName, lngLen)
  Else
      GetMachineName = ""
  End If
End Function


Function GetUserName() As String

   ' Buffer size for the return string.
   Const lpnLength As Integer = 255

   ' Get return buffer space.
   Dim status As Integer

   ' For getting user information.
   Dim lpName, lpUserName As String

   ' Assign the buffer size constant to lpUserName.
   lpUserName = Space$(lpnLength + 1)

   ' Get the log-on name of the person using product.
   status = WNetGetUser(lpName, lpUserName, lpnLength)

   ' See whether error occurred.
   If status = NoError Then
      ' This line removes the null character. Strings in C are null-
      ' terminated. Strings in Visual Basic are not null-terminated.
      ' The null character must be removed from the C strings to be used
      ' cleanly in Visual Basic.
      lpUserName = Left$(lpUserName, InStr(lpUserName, Chr(0)) - 1)
   Else

      ' An error occurred.
'         MsgBox "Unable to get the name."
      'lpUserName = "Unbekannt"
      lpUserName = FMT0("HELPERS_1")
   End If

   ' Display the name of the person logged on to the machine.
'      MsgBox "The person logged on this machine is: " & lpUserName

    GetUserName = lpUserName

End Function

' Localization: Wird nicht benutzt
Sub PopupErzeugen()
Dim a As Long, l As Long, CBName As String
Dim lw  As String, Prozedur  As String
Dim VBCount As Long
Dim meineLeiste As CommandBar
Dim KonBef As CommandBarButton
On Error Resume Next
VBCount = Application.VBE.VBProjects.count
'Objektvariable myLaufwerk erstellen, notfalls Komponente hinzu
With Application.VBE.VBProjects(VBCount).VBComponents("myLaufwerke").CodeModule
    'Commandbar "Laufwerk" l|fffd|schen, wenn vorhanden
    'ansonsten On Error Resume Next
    Application.CommandBars("Laufwerk").Delete
    'Commandbar "Laufwerk" hinzuf|fffd|gen
    Set meineLeiste = Application.CommandBars _
    .Add(name:="Laufwerk", Position:=msoBarPopup, Temporary:=True)
    'Bitmaske mit Laufwerken holen
    l = GetLogicalDrives
    For a = 97 To 123
        If l And 2 ^ (a - 97) Then
            'Wenn Bit 0 gesetzt, dann LW a vorhanden
            'Wenn Bit 1 gesetzt, dann LW b vorhanden
            'usw.
            lw = Chr(a)
            If Not .Find("Sub LW_" & lw & "()", 1, 1, .CountOfLines, .CountOfLines) Then
                'Prozeduren f|fffd|r die Laufwerke hinzuf|fffd|gen
                'wenn |fffd|nderungen hier, vorher alle l|fffd|schen
                Prozedur = "Sub LW_" & lw & " " & vbCrLf
                Prozedur = Prozedur & "LaufwerktypAnzeigen """ & lw & """" & vbCrLf
                Prozedur = Prozedur & "End Sub"
                .AddFromString (Prozedur)
            End If
            'Control hinzuf|fffd|gen f|fffd|r jedes Laufwerk
            Set KonBef = meineLeiste.Controls.Add(msoControlButton)
            Dim lwk As String
            lwk = "Laufwerk : "
            With KonBef
                'Im Popup angezeigter Text
                .Caption = lwk & Chr(a)
                'Im Popup angezeigtes Icon
                .FaceId = 3
                'Prozedur, die nach Klick aufgerufen wird
                .OnAction = "LW_" & Chr(a)
            End With
        End If
    Next
End With
'Wenn die Prozeduren hinzugef|fffd|gt wurden, gibt
'es beim direkten Aufruf manchmal Probleme
Application.OnTime Now + TimeSerial(0, 0, 1), "PopupAnzeigen"
End Sub


Private Sub LaufwerktypAnzeigen(a As String)
Dim Meldung As String
Select Case GetDriveType(a & ":\")
    Case DRIVE_CDROM
        Meldung = "CDROM"
    Case DRIVE_FIXED
        Meldung = "Festplatte"
    Case DRIVE_RAMDISK
        Meldung = "RAMDISK"
    Case DRIVE_REMOTE
        Meldung = "Netzlaufwerk"
    Case DRIVE_REMOVABLE
        Meldung = "Diskette"
End Select
'MsgBox "Laufwerk = " & a & vbCrLf & "Typ = " & Meldung
MsgBox FmtInternal("Laufwerk = %1\nTyp = %2", a, Meldung)
End Sub


Public Sub PopupAnzeigen()
    Application.CommandBars("Laufwerk").ShowPopup
End Sub

Function GetWorksheet(wbname As String, sheetname As String, ByRef Beenden As Boolean) As Worksheet
    Dim objApp As Object
    On Error Resume Next
    Set objApp = GetObject(wbname)
    
    Dim ws As Worksheet
    Set ws = objApp.Sheets(sheetname)
    
    If objApp Is Nothing Or ws Is Nothing Then
      Beenden = True
      Exit Function
    End If
    
    Set GetWorksheet = ws
End Function

Function RemoveStrings(ByVal txt As String, remstr As String, remstr2 As String) As String
  Dim pos As Long
  Dim pos2 As Long
  Do
    pos = InStr(txt, remstr)
    If pos <= 0 Then Exit Do
    pos2 = InStr(pos + 1, txt, remstr2)
    If pos2 <= 0 Then Exit Do
    Dim tstr As String
    tstr = ""
    If pos > 1 Then tstr = Left(txt, pos - 1)
    If pos2 < Len(txt) Then tstr = tstr & Mid(txt, pos2 + 1)
    txt = tstr
  Loop
  RemoveStrings = txt
End Function


Function FormulaLocalOK(c As Range) As Boolean
  On Error GoTo notOK
  Dim s As String
  s = c.FormulaLocal
  FormulaLocalOK = True
  Exit Function
notOK:
  FormulaLocalOK = False
End Function

Function GetNextText(s As String, ByRef pos As Long) As String
  If Len(s) > 0 And pos > 0 Then
    Dim lastpos As Long
    lastpos = pos
      
    pos = InStr(pos, s, ",")
    If pos > 0 Then
      
      GetNextText = Trim(Mid(s, lastpos, pos - lastpos))
      pos = pos + 1
      Exit Function
    ElseIf lastpos < Len(s) Then
      GetNextText = Trim(Mid(s, lastpos))
      pos = -1
      Exit Function
    Else
      pos = -1
      GetNextText = ""
      Exit Function
    End If
  Else
    pos = -1
    GetNextText = ""
    Exit Function
  End If

End Function

Function CommentExists(ByRef c As Range) As Boolean
  Dim s As String
  On Error GoTo doesntExist
  s = c.Comment.Text
  CommentExists = True
  Exit Function
doesntExist:
End Function

Function GetRangeCount(ByRef rng) As Double
  On Error Resume Next
  
  GetRangeCount = CDbl(rng.count)
  If Err.Number <> 0 Then
    Err.Clear
    GetRangeCount = CDbl(rng.Countlarge)
  End If
  
End Function

Public Function AnwendungFuerDatei(ByVal a_Datei As String) As String
  'Datei: Pfad + Dateinamen einer existierenden Datei
  Dim Pfad As String * 255
  
  Call FindExecutable(a_Datei, vbNullString, Pfad)
  
  If "" <> Trim(Pfad) Then
     Pfad = Trim(Left(Pfad, InStr(Pfad, vbNullChar) - 1))
  End If
  AnwendungFuerDatei = Trim(Pfad)
End Function

Sub StartExcelDatei(Filename As String)
   Dim s2 As String, s3 As String, n As Long
   
   s2 = AnwendungFuerDatei(Filename)
   
   If UCase(Right(s2, 9)) <> "EXCEL.EXE" Then
     DebugPrint tERROR, "Datei '" & s2 & "' ist nicht Excel! Die Datei '" & Filename & "' kann deshalb nicht ge|fffd|ffnet werden!"
     Exit Sub
   End If
   
   If "" <> s2 Then
      s3 = Chr(34) & s2 & Chr(34) & " /e /automation /r " & Chr(34) & ShortFileName(Filename) & Chr(34)
      If GetSetting(appname:="Stromwerken", Section:="ECC", Key:="TrackerShowStatusform", default:="True") = "True" Then
        n = Shell(s3, vbNormalFocus)
      Else
        n = Shell(s3, vbHide)
      End If
   Else
      'MsgBox "Anwendungprogramm f|fffd|r " & Filename & " nicht gefunden/installiert!"
      MsgBox FMT1("HELPERS_2", Filename)
   End If
End Sub

Sub OpenFileWithApp(fname As String)
  If FileExists(fname) Then
    Dim s2 As String, s3 As String, n As Long
    
    s2 = AnwendungFuerDatei(fname)
    If "" <> s2 Then
       s3 = Chr(34) & s2 & Chr(34) & " " & Chr(34) & ShortFileName(fname) & Chr(34)
       n = Shell(s3, vbNormalFocus)
    Else
       'MsgBox "Anwendungprogramm f|fffd|r " & fname & " nicht gefunden/installiert!"
       MsgBox FMT1("HELPERS_2", fname)
    End If
  Else
    'MsgBox "Datei '" & fname & "' nicht vorhanden.", vbCritical
    MsgBox FMT1("HELPERS_3", fname), vbCritical
  End If
End Sub

Sub ClearLog()
  On Error Resume Next
  If G_cfgLogpfad = "" Then
    Kill ThisWorkbook.path & "\ECC-Log-" & GetUserName & ".txt"
  Else
    Kill G_cfgTemppfad & "\ECC-Log-" & GetUserName & ".txt"
  End If
End Sub

Sub LogPrintECCSCanLog(ByVal id As Long, ByVal status As Long, ByVal str As String, Optional writeFileStatusInfoForScheduler As Boolean = False)
  If AR_StartedByApp = SWAPPID_IDVSuiteScheduler Then
    If status = 9 Then
      AddError str
    End If
    DebugPrint tToFile, progNameShort & MyECCVersion & " - " & str, 0, 0, id, True
'    If writeFileStatusInfoForScheduler Then
      SetFileStatusInfo str
'    End If
    If status > 0 Then
      SaveSetting appname:="Stromwerken", Section:="IDVSS", Key:="ECCScanResult" & status, setting:=GetSetting(appname:="Stromwerken", Section:="IDVSS", Key:="ECCScanResult" & status, default:=0) + 1
    End If
  End If
  
End Sub


Sub LogPrint(ByVal str As String)
  DebugPrint tinfo, str
End Sub

Function MyOpenFile(ByVal fullpath As String, ByVal fn As Long)
    On Error GoTo nogo:
    
    Open fullpath For Append As fn
    MyOpenFile = True
    Exit Function
nogo:
    MyOpenFile = False

End Function

Public Function AddTextToFile(ByVal strData As String, _
     ByVal fullpath As String, _
       Optional ByVal ErrInfo As String = "") As Boolean

    Dim fn As Long
    fn = FreeFile
    Dim s As String
    
    Dim i As Long
    i = 0

    While i < 5
      If MyOpenFile(fullpath, fn) Then
        Print #fn, strData
        Close fn
        AddTextToFile = True
        Exit Function
      End If
      i = i + 1
      Sleep 10
    Wend

    AddTextToFile = False
    Exit Function

End Function

Function ConvGermanDateKey(d As String) As String
    Dim sp() As String
    sp = Split(d, ".")
    If UBound(sp) - LBound(sp) + 1 = 3 Then
        ConvGermanDateKey = DateSerial(CInt(sp(2)), CInt(sp(1)), CInt(sp(0)))
    Else
        ConvGermanDateKey = d
    End If
End Function


Function ConvGermanDate(d As String) As Date
    Dim td As Date
    
    On Error GoTo errorEnd
    td = DateSerial(1900, 1, 1)
    
    If IsDate(d) Then
        td = CDate(d)
    Else
      Dim dots As Long
      Dim pos1 As Long
      Dim pos2 As Long
      Dim endPos As Long
      
      dots = 0
      
      pos1 = InStr(d, ".")
      If pos1 > 0 Then
          dots = dots + 1
          
          pos2 = InStr(pos1 + 1, d, ".")
          If pos2 > 0 Then
              dots = dots + 1
              endPos = InStr(pos2 + 1, d, " ")
              If endPos <= 0 Then endPos = Len(d) + 1
          End If
      End If
      
      If dots = 2 Then
          Dim day As String
          Dim month As String
          Dim year As String
          day = Mid(d, 1, pos1 - 1)
          month = Mid(d, pos1 + 1, pos2 - pos1 - 1)
          year = Mid(d, pos2 + 1, endPos - pos2 - 1)
          td = DateSerial(year, month, day) & IIf(CDate(d) <> DateSerial(year, month, day), " " & Hour(d) & ":" & Minute(d) & ":" & Second(d), "")
      End If
    End If
    
    If td < DateSerial(1900, 1, 1) Then
      td = DateSerial(1900, 1, 1) & " " & Hour(d) & ":" & Minute(d) & ":" & Second(d)
    End If
    
errorEnd:
    ConvGermanDate = td
End Function


Function GetRelativePath(ByVal stdpath As String, ByVal cfgpath As String) As String
  Dim s As String
  If cfgpath = "" Then s = stdpath
  
  If cfgpath = "USERTEMP" Then
    cfgpath = GetTempPath
    If Right(cfgpath, 1) = "\" Then
      cfgpath = Left(cfgpath, Len(cfgpath) - 1)
    End If
  End If
  
  If Left(cfgpath, 2) = "\\" Or Left(cfgpath, 2) = "//" Or Mid(cfgpath, 2, 1) = ":" Then
    s = cfgpath
  Else
    s = ThisWorkbook.path & "\" & cfgpath
  End If
  
  If Not PathExists(s) Then
    MkFullDir s
    If Not PathExists(s) Then
'      If Not AR_UseDB Then
'        MsgBox "ACHTUNG: Der Pfad '" & s & "' konnte nicht erzeugt werden. Das Programm wird voraussichtlich nicht korrekt funktionieren. Bitte gew|fffd|hrleisten Sie, dass der Pfad existiert!", vbCritical
'      Else
        'AddStatus "ACHTUNG: Der Pfad '" & s & "' konnte nicht erzeugt werden."
        AddStatus FMT1("HELPERS_4", s)
'      End If
    End If
  End If
  
  GetRelativePath = s
End Function

' Return the short file name for a long file name.
Public Function ShortFileName(ByVal long_name As String) As String
    
    If UCase(Left(long_name, 5)) = "HTTP:" Or UCase(Left(long_name, 6)) = "HTTPS:" Then
      ShortFileName = long_name
      Exit Function
    End If
    
    'Returns the short filename associated w
    '     ith sLongFilename
    Dim lRet As Long
    Dim sShortFilename As String
    'First attempt using 1024 character buff
    '     er.
    sShortFilename = String$(1024, " ")
    lRet = GetShortPathName(long_name, sShortFilename, Len(sShortFilename))
    
    'If buffer is too small lRet contains bu
    '     ffer size needed.


    If lRet > Len(sShortFilename) Then
        'Increase buffer size...
        sShortFilename = String$(lRet + 1, " ")
        'and try again.
        lRet = GetShortPathName(long_name, sShortFilename, Len(sShortFilename))
    End If
    
    'lRet contains the number of characters
    '     returned.


    If lRet > 0 Then
        ShortFileName = Left$(sShortFilename, lRet)
    End If
    
    If Trim(ShortFileName) = "" Then
      ShortFileName = long_name
    End If
    
End Function
 
 
 
' To convert from short to long file names, break the short name into directory pieces. Use Dir$ to get the long name for each piece.
Public Function LongFileName(ByVal short_name As String) As _
    String
Dim pos As Integer
Dim result As String
Dim long_name As String

    ' Start after the drive letter if any.
    If Mid$(short_name, 2, 1) = ":" Then
        result = Left$(short_name, 2)
        pos = 3
    Else
        LongFileName = short_name
        Exit Function
    End If

    ' Consider each section in the file name.
    Do While pos > 0
        ' Find the next \.
        pos = InStr(pos + 1, short_name, "\")

        ' Get the next piece of the path.
        If pos = 0 Then
            long_name = Dir$(short_name, vbNormal + _
                vbHidden + vbSystem + vbDirectory)
            If long_name = "" Then
              pos = InStrRev(short_name, "\")
              If pos > 0 Then
                long_name = Mid(short_name, pos + 1)
                pos = 0
              End If
            End If
        Else
            long_name = Dir$(Left$(short_name, pos - 1), _
                vbNormal + vbHidden + vbSystem + _
                vbDirectory)
        End If
        result = result & "\" & long_name
    Loop

    LongFileName = result
End Function


Function IsFullyNumeric(v As String) As Boolean
  Dim l As Long
  l = Len(v)
  If l = 0 Then Exit Function
  Dim i As Long
  For i = 1 To l
    If (Mid(v, i, 1) < "0" Or Mid(v, i, 1) > "9") And Mid(v, i, 1) <> "." Then Exit For
  Next i
  If i > l Then IsFullyNumeric = True
End Function

' Wenn d zwischen t1 und t2 liegt true, ansonsten false
' t1 und t2 sind immer die Stunden eines Tages. Wenn t2 kleiner t1 ist, dann wird |fffd|ber Mitternacht gerechnet
Function TimeInScope(d As Date, t1 As Date, t2 As Date) As Boolean
  ' Erst mal die Tagesiformationen loswerden
  t1 = GetTime(t1)
  t2 = GetTime(t2)
  d = GetTime(d)

  TimeInScope = False

  ' Z.B. zwischen 08:00:00 und 09:00:00
  If t1 < t2 Then
      If t1 <= d And d <= t2 Then
          TimeInScope = True
      End If
  Else
      If d >= t1 Or d <= t2 Then
          TimeInScope = True
      End If
  End If
End Function

Function GetTime(d As Date) As Date
  On Error Resume Next
  GetTime = CDate("00:00:00")
  GetTime = TimeValue(d)
End Function

Function IsTime(ts As String) As Boolean
  Dim ok As Boolean
  ok = True
  If Len(ts) <> 8 Then ok = False
  If ok Then If Mid(ts, 3, 1) <> ":" Then ok = False
  If ok Then If Mid(ts, 6, 1) <> ":" Then ok = False
  If ok Then
    If IsNumeric(Val(Mid(ts, 1, 2))) Then
      If Val(Mid(ts, 1, 2)) < 0 Or Val(Mid(ts, 1, 2)) > 23 Then ok = False
    Else
      ok = False
    End If
  End If
  If ok Then
    If IsNumeric(Val(Mid(ts, 4, 2))) Then
      If Val(Mid(ts, 4, 2)) < 0 Or Val(Mid(ts, 4, 2)) > 59 Then ok = False
    Else
      ok = False
    End If
  End If
  IsTime = ok
End Function

Sub MyKill(fname As String)
  On Error Resume Next
  Kill fname
End Sub

Function StrRemove(srcstring As String, removechars As String) As String
  Dim res As String
  Dim x As Long
  Dim l As Long
  l = Len(removechars)
  
  res = srcstring
  If l > 0 Then
    For x = 1 To l
      res = Replace(res, Mid(removechars, x, 1), "")
    Next x
  End If
  StrRemove = res
End Function

Function IsSimpleFormula(f As String) As Boolean
    
  Dim pos As Long
  Dim pos2 As Long
  Do
    pos = InStr(f, "N(" & Chr(34))
    If pos > 0 Then
    
' .NET START
      If pos > 1 Then
        If UCase(Mid(f, pos - 1, 1)) >= "A" And UCase(Mid(f, pos - 1, 1)) <= "Z" Then
          Exit Do
        End If
      End If
' .NET END
      pos2 = InStr(pos + 3, f, Chr(34))
      If pos2 <= 0 Then Exit Do
      If Mid(f, pos2 + 1, 1) = ")" Then
        f = Left(f, pos - 1) & Mid(f, pos2 + 2)
      Else
        Exit Do
      End If
    Else
      Exit Do
    End If
  Loop
  If Trim(StrRemove(f, "0123456789+-*/^(). " & vbCrLf & vbTab)) = "=" Then IsSimpleFormula = True
End Function

Function FileLocked(strFileName As String) As Boolean
   On Error Resume Next
   ' If the file is already opened by another process,
   ' and the specified type of access is not allowed,
   ' the Open operation fails and an error occurs.
   Dim ff As Long
   ff = FreeFile
   Open strFileName For Binary Access Read Write Lock Read Write As #ff
   Close #ff
   ' If an error occurs, the document is currently open.
   If Err.Number <> 0 Then
      ' Display the error number and description.
      FileLocked = True
      Err.Clear
   End If
End Function

Function GetFilePath(ByVal fn As String)
    Dim File As String
    Dim path As String
    Dim ext As String
    
    fileSplit fn, path, File, ext
    GetFilePath = Left(path, Len(path) - 1)
End Function

Function GetFileNameAndPath(ByVal fn As String)
    Dim File As String
    Dim path As String
    Dim ext As String
    
    fileSplit fn, path, File, ext
    GetFileNameAndPath = path & File
End Function

Function GetFileNameAndExtension(ByVal fn As String)
    Dim File As String
    Dim path As String
    Dim ext As String
    
    fileSplit fn, path, File, ext
    GetFileNameAndExtension = File & "." & ext
End Function

Function GetFileExtension(ByVal fn As String)
    Dim File As String
    Dim path As String
    Dim ext As String
    
    fileSplit fn, path, File, ext
    GetFileExtension = ext
End Function


Sub fileSplit(ByVal s$, ByRef path$, ByRef File$, ByRef ext$)
    ' die Prozedur zerlegt den Dateinamen S in Path, Name, Extension
    Dim i%
    For i = Len(s) To 1 Step -1
        If Mid(s, i, 1) = "\" Or Mid(s, i, 1) = "/" Then   ' keine Extension vorhanden
            ext = ""
            Exit For
        End If
        If Mid(s, i, 1) = "." Then
            ext = Right(s, Len(s) - i)
            s = Left(s, i - 1)
            Exit For
        End If
    Next i
    i = Len(s)
    If InStr(s, "\") <> 0 Then
        While Mid(s, i, 1) <> "\"
            i = i - 1
        Wend
    ElseIf InStr(s, "/") <> 0 Then
        While Mid(s, i, 1) <> "/"
            i = i - 1
        Wend
    End If
    path = Left(s, i)
    File = Right(s, Len(s) - i)

End Sub

Function GetPath(ByVal p As String) As String
  If InStrRev(p, "\") > 0 Then
    GetPath = Left(p, InStrRev(p, "\") - 1)
    Exit Function
  End If
  GetPath = p
End Function


Sub SetPriority()
    Const ABOVE_NORMAL = 32768
    Const HIGH = 128
    Dim strComputer As String
    Dim objWMIService As Object
    Dim colProcesses As Object
    Dim objProcess As Object
    strComputer = "."
    Set objWMIService = GetObject("winmgmts:" _
        & "{impersonationLevel=impersonate}!\\" _
        & strComputer & "\root\cimv2")
    Set colProcesses = objWMIService.ExecQuery _
        ("Select * from Win32_Process Where Name = 'excel.exe'")
    For Each objProcess In colProcesses
        objProcess.SetPriority (HIGH)
    Next
End Sub
Public Sub SetHighestPriority()
  ChangePriority REALTIME_PRIORITY_CLASS
End Sub
Public Function ChangePriority(dwPriorityClass As PRIORITY_CLASS) As Boolean
   Dim hProcess As Long
   Dim Ret As Long, pid As Long
   pid = GetCurrentProcessId()
   ' Get the Handle of the Process
   hProcess = OpenProcess(PROCESS_DUP_HANDLE, True, pid)
   If hProcess = 0 Then Exit Function
   ' Change the priority
   Ret = SetPriorityClass(hProcess, dwPriorityClass)
   ' Close the process
   Call CloseHandle(hProcess)
   ChangePriority = Ret <> 0
End Function
Function GetExcelVersion() As Long
  GetExcelVersion = 0
  On Error Resume Next
  ' >= 12 = Excel 2007
  GetExcelVersion = CLng(Val(Application.Version))
End Function

Function GetTempPath() As String
  Dim RetVal As Long
  Dim pathbuffer As String * 512
  
  Dim l As Long
  l = apiGetTempPath(512, pathbuffer)
  If l > 0 Then
    GetTempPath = Trim(Left(pathbuffer, l))
  End If
End Function


Private Function FOpen(fname As String, ByRef fn As Long) As Boolean
  On Error GoTo nogo
  Open fname For Binary Access Read As fn
  FOpen = True
  Exit Function
nogo:
        
End Function

Private Function FOpenWrite(fname As String, ByRef fn As Long) As Boolean
  On Error GoTo nogo
  Open fname For Binary Access Write As fn
  FOpenWrite = True
  Exit Function
nogo:
        
End Function

Private Function FClose(ByRef fn As Long) As Boolean
  On Error GoTo nogo
  Close fn
  FClose = True
  Exit Function
nogo:
        
End Function

Private Sub TestSplitFile()
    Dim splitFilenames() As String
    SplitFile "c:\mywork\norman\testDaten\mappe5017.xls", GetSplitSize(), splitFilenames

End Sub


Function SplitFile(ByVal Filename As String, ByVal splitSize As Long, ByRef splitFilenames() As String) As Boolean

    SplitFile = False

On Error GoTo nogo
    
    Dim fileLen As Long
    fileLen = MyFileLen(Filename)
    
    ' wenn wir kleiner sind als 1 Split, dann wird nicht gesplitted
    If fileLen <= splitSize Then
        Exit Function
    End If

    Dim steps As Long
    ' Integer Division, also \ anstatt /
    steps = (fileLen \ splitSize)
    Dim remainingSize As Long
    remainingSize = fileLen Mod splitSize
    ' wenn es genau ein Vielfaches der SplitSize ist, dann m|fffd|ssen wir einen Split weniger machen
    If remainingSize = 0 Then
        steps = steps - 1
    End If
        
    Dim fn As Long
    fn = FreeFile
    
    Dim einMB As Long
    einMB = CLng(1024) * CLng(1024)

    SplitFile = True
    
    ReDim Preserve splitFilenames(steps)

    Dim buffer(CLng(1024) * CLng(1024) - CLng(1)) As Byte
    Dim BufferRemaining() As Byte
    If FOpen(Filename, fn) Then
        Dim step
        For step = 0 To steps
            Dim fnOut As Long
            fnOut = FreeFile
            
            Dim fileNameOutput As String
            fileNameOutput = Filename & "_" & step
            If FOpenWrite(fileNameOutput, fnOut) Then
                
                splitFilenames(step) = fileNameOutput
                
                Dim internalSteps As Long
                internalSteps = splitSize / einMB
                
                Dim intStep
                For intStep = 0 To internalSteps - 1
                    Dim strData As String
                    
                    If fileLen <= einMB Then
                        ReDim BufferRemaining(fileLen - 1)
                        Get #fn, , BufferRemaining
                        Put #fnOut, , BufferRemaining
                        fileLen = 0
                        Exit For
                    Else
                        Get #fn, , buffer
                        Put #fnOut, , buffer
                    End If
                    fileLen = fileLen - einMB
                Next
                Close #fnOut
            Else
                ' nicht geklappt, alles wieder l|fffd|schen
                SplitFile = False
                ' auf jeden Fall aufh|fffd|ren
                step = steps + 1
                Exit For
            End If
        Next
        Close #fn
    End If

    Exit Function
nogo:
    SplitFile = False
End Function

Public Function CreateTempFile(sPrefix As String) As String
   Dim sTmpPath As String * 512
   Dim sTmpName As String * 576
   Dim nRet As Long

   nRet = apiGetTempPath(512, sTmpPath)
   If (nRet > 0 And nRet < 512) Then
      nRet = GetTempFileName(sTmpPath, sPrefix, 0, sTmpName)
      If nRet <> 0 Then
         CreateTempFile = Left$(sTmpName, _
            InStr(sTmpName, vbNullChar) - 1)
         MyKill CreateTempFile
      End If
   End If
End Function

Function GetFileName(ByVal fn As String) As String
    Dim File As String
    Dim path As String
    Dim ext As String

    fileSplit fn, path, File, ext
    GetFileName = File
End Function


Function WorkbookExists(ByRef xlapp, wbname As String) As Boolean
  On Error GoTo nogo
  Dim wb As Workbook
'  Set wb = Workbooks(wbname)
  
  For Each wb In xlapp.Workbooks
    If UCase(wb.name) = UCase(wbname) Then
      WorkbookExists = True
      Exit Function
    End If
  Next wb
  Set wb = Nothing
  Exit Function
nogo:
End Function


Public Function GetNextValue(ByVal sbsValue As String, ByRef startIndex As Long, Optional delim As String = ";") As String

    Dim l As Long
    l = Len(sbsValue)
    Dim startAnfuehrungsstriche As Long
    Dim anfuehrungsstriche As Long
    Dim laenge As Long
    
    Dim nextValue As String
    nextValue = ""
    
    If startIndex <= l Then
        laenge = 0
        If Mid(sbsValue, startIndex, 1) = Chr$(34) Then
            startAnfuehrungsstriche = 1
            anfuehrungsstriche = 1
            startIndex = startIndex + 1
        End If
        
        While startIndex + laenge <= l
            Dim c As String
            c = Mid(sbsValue, startIndex + laenge, 1)
            If c = Chr$(34) Then
                ' 3 Anf|fffd|hrungszeichen sind dann
                If Mid(sbsValue, startIndex + laenge, 2) = Chr$(34) & Chr$(34) Then
                    laenge = laenge + 2
                Else
                    anfuehrungsstriche = 1 - anfuehrungsstriche
                    laenge = laenge + 1
                End If
            ElseIf c = delim Then
                If anfuehrungsstriche = 0 Then
                    GoTo raus
                Else
                    laenge = laenge + 1
                End If
            Else
                laenge = laenge + 1
            End If
        Wend
raus:
        nextValue = Mid(sbsValue, startIndex, laenge - startAnfuehrungsstriche)
        ' nextValue = Replace(nextValue, Chr$(34) & Chr$(34), "'") ' Chr$(34))
        startIndex = startIndex + laenge + 1
    End If
    GetNextValue = nextValue

End Function

Public Function IsTestUser() As Boolean
  Dim curUser As String
  curUser = GetUserName
    If curUser = "dirk" Or _
        curUser = "dwinter" Or _
        curUser = "norman" Or _
        curUser = "nneubert" Or _
        curUser = "rolf" Or _
        curUser = "rlangenberg" Then
        
        IsTestUser = True
    End If
End Function

Function MyTimeValue24H(ByVal s As String) As String
  
  ' 2019/01/01 12:00:00 AM
  Debug.Print Format(s, "hh:mm:ss")
  MyTimeValue24H = Format(s, "hh:mm:ss")
    
End Function

Function IsURL(ByVal Dateiname$) As Boolean
  If UCase(Left(Dateiname, 5)) = "HTTP:" Or UCase(Left(Dateiname, 6)) = "HTTPS:" Then
    IsURL = True
  End If
End Function

Public Function DecryptPasswort(ByVal s As String) As String
    DecryptPasswort = Crypt(s, "T0)7/hJy+\1TrcpI?", False)
End Function

Attribute VB_Name = "HighResTimer"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

#If VBA7 Then
Private Declare PtrSafe Function QueryPerformanceCounter Lib "kernel32" _
                                 (x As Currency) As Boolean
Private Declare PtrSafe Function QueryPerformanceFrequency Lib "kernel32" _
                                 (x As Currency) As Boolean
      
Private Declare PtrSafe Function timeGetTime Lib "winmm.dll" () As Long

#Else

Private Declare Function QueryPerformanceCounter Lib "kernel32" _
                                 (x As Currency) As Boolean
Private Declare Function QueryPerformanceFrequency Lib "kernel32" _
                                 (x As Currency) As Boolean
      
Private Declare Function timeGetTime Lib "winmm.dll" () As Long

#End If



Enum TimeState
    started
    Stopped
End Enum


Private startTime, endTime As Long
Private dur As Double
Private state As Currency
Private m_TimeCol As Collection
Private m_TimeName As Collection
Private m_TotalTimeCol As Collection

Private m_LastCount As String

Private Sub Class_Initialize()
Static started As Boolean
    If started Then
      Dim msg As String
      msg = "HighResTimer already started!"
      MsgBox msg
      Exit Sub
    End If
    started = True
    state = TimeState.Stopped
    DoStart

    StartCounting "TotalCount"

End Sub

Private Sub Class_Terminate()
    DoStop
    Set m_TimeCol = Nothing
    Set m_TotalTimeCol = Nothing
    Set m_TimeName = Nothing
    
End Sub

Public Sub StartCounting(s As String)
  
  If m_LastCount <> "" Then
    Dim d As Double
    d = m_TotalTimeCol(m_LastCount) + CDbl(timeGetTime() - m_TimeCol(m_LastCount))
    m_TotalTimeCol.Remove m_LastCount
    m_TotalTimeCol.Add d, m_LastCount
  End If
  
  
  If CollectionItemExists(m_TimeCol, s) Then
    m_TimeCol.Remove s
  End If
  m_TimeCol.Add timeGetTime(), s
  If Not CollectionItemExists(m_TotalTimeCol, s) Then
    m_TotalTimeCol.Add 0#, s
  End If
  If Not CollectionItemExists(m_TimeName, s) Then
    m_TimeName.Add s, s
  End If
End Sub
Public Sub StopCounting(s As String)
  If Not CollectionItemExists(m_TimeCol, s) Then
    Dim msg As String
    msg = "No count for: " & s
    MsgBox msg
    Exit Sub
  End If

  Dim d As Double
  d = m_TotalTimeCol(s) + CDbl(timeGetTime() - m_TimeCol(s))
  m_TotalTimeCol.Remove s
  m_TotalTimeCol.Add d, s
  
  
  m_LastCount = s & " - After"
  
  If CollectionItemExists(m_TimeCol, m_LastCount) Then
    m_TimeCol.Remove m_LastCount
  End If
  m_TimeCol.Add timeGetTime(), m_LastCount
  If Not CollectionItemExists(m_TotalTimeCol, m_LastCount) Then
    m_TotalTimeCol.Add 0#, m_LastCount
  End If
  If Not CollectionItemExists(m_TimeName, m_LastCount) Then
    m_TimeName.Add m_LastCount, m_LastCount
  End If
  
  

End Sub

Function GetCount(s As String) As Double
  If Not CollectionItemExists(m_TotalTimeCol, s) Then
    Dim msg As String
    msg = "No count for: " & s
    MsgBox msg
    Exit Function
  End If
  
  GetCount = m_TotalTimeCol(s) / 1000
End Function


Private Sub DoStart()
    If state = TimeState.started Then
        Dim msg As String
        msg = "Cant' start, already started"
        MsgBox msg, vbCritical + vbSystemModal, ProgNameLong & " " & MyVersion
        Exit Sub
    End If
    state = TimeState.started
    startTime = timeGetTime()
    Set m_TimeCol = New Collection
    Set m_TotalTimeCol = New Collection
    Set m_TimeName = New Collection
End Sub

Private Function DoStop() As Double
    endTime = timeGetTime()
    If state = TimeState.Stopped Then
        Dim msg As String
        msg = "Cant' stop, already stopped"
        MsgBox msg, vbCritical + vbSystemModal, ProgNameLong & " " & MyVersion
        Exit Function
    End If
    state = TimeState.Stopped
    dur = CDbl((endTime - startTime) / 1000)
    DoStop = dur
End Function


Public Sub Dump()
  Dim s As String
  Dim i As Long
  Dim ts As String
  
  StopCounting "TotalCount"
  ts = ""
  
  Dim tot As Double
  tot = GetCount("TotalCount")
  
  Dim checked As Double
  checked = 0
  
  If m_TimeName.count > 0 Then
    For i = 1 To m_TimeName.count
      s = m_TimeName(i)
      ts = ts & s & ":" & IIf(Len(s) < 8, vbTab, "") & IIf(Len(s) < 16, vbTab, "") & IIf(Len(s) < 22, vbTab, "") & IIf(Len(s) < 30, vbTab, "") & vbTab & Format(GetCount(s), "000.00") & " Sec" & vbTab & Format(GetCount(s) / tot, "00.0%") & vbCrLf
      Debug.Print s & ": " & GetCount(s) & " Sec - " & Format(GetCount(s) / tot, "0.0%")
      checked = checked + GetCount(s)
    Next i
  End If
  
  ts = ts & vbCrLf & "Checked: " & Format((checked - tot) / tot, "0.0%")
 
  MyKill ThisWorkbook.path & "\ECC-Profile.txt"
  AddTextToFile ts, ThisWorkbook.path & "\ECC-Profile.txt"
  
End Sub
Function GetCurrentCount(s As String) As Double
  If Not CollectionItemExists(m_TotalTimeCol, s) Then
    Dim msg As String
    msg = "No count for: " & s
    MsgBox msg
    Exit Function
  End If
  GetCurrentCount = (m_TotalTimeCol(s) + CDbl(timeGetTime() - m_TimeCol(s))) / 1000
End Function
Attribute VB_Name = "INetCheckVersion"
Option Explicit

'Declares for direct ping
#If VBA7 Then
    Private Declare PtrSafe Function InternetOpen Lib "wininet.dll" Alias "InternetOpenA" (ByVal lpszAgent As String, ByVal dwAccessType As Long, ByVal lpszProxyName As String, ByVal lpszProxyBypass As String, ByVal dwFlags As Long) As Long
    Private Declare PtrSafe Function InternetOpenUrl Lib "wininet.dll" Alias "InternetOpenUrlA" (ByVal hInet As Long, ByVal lpszUrl As String, ByVal lpszHeaders As String, ByVal dwHeadersLength As Long, ByVal dwFlags As Long, ByVal dwContext As Long) As Long
    Private Declare PtrSafe Function InternetCloseHandle Lib "wininet.dll" (ByVal hInet As Long) As Long
    Private Declare PtrSafe Function InternetReadFile Lib "wininet.dll" _
        (ByVal hFile As Long, ByVal sBuffer As String, ByVal lNumBytesToRead As Long, _
        lNumberOfBytesRead As Long) As Integer
    Private Declare PtrSafe Function InternetGetLastResponseInfo Lib "wininet.dll" Alias "InternetGetLastResponseInfoA" _
        (lpdwError As Long, ByVal lpszBuffer As String, ByVal lpdwBufferLength As Long) As Integer
#Else
    Private Declare Function InternetOpen Lib "wininet.dll" Alias "InternetOpenA" (ByVal lpszAgent As String, ByVal dwAccessType As Long, ByVal lpszProxyName As String, ByVal lpszProxyBypass As String, ByVal dwFlags As Long) As Long
    Private Declare Function InternetOpenUrl Lib "wininet.dll" Alias "InternetOpenUrlA" (ByVal hInet As Long, ByVal lpszUrl As String, ByVal lpszHeaders As String, ByVal dwHeadersLength As Long, ByVal dwFlags As Long, ByVal dwContext As Long) As Long
    Private Declare Function InternetCloseHandle Lib "wininet.dll" (ByVal hInet As Long) As Long
    Private Declare Function InternetReadFile Lib "wininet.dll" _
        (ByVal hFile As Long, ByVal sBuffer As String, ByVal lNumBytesToRead As Long, _
        lNumberOfBytesRead As Long) As Integer
    Private Declare Function InternetGetLastResponseInfo Lib "wininet.dll" Alias "InternetGetLastResponseInfoA" _
        (lpdwError As Long, ByVal lpszBuffer As String, ByVal lpdwBufferLength As Long) As Integer
#End If

Private Const INTERNET_OPEN_TYPE_PRECONFIG = 0
Private Const INTERNET_FLAG_RELOAD = &H80000000
Private Const INTERNET_FLAG_KEEP_CONNECTION = &H400000
Private Const INTERNET_FLAG_NO_CACHE_WRITE = &H4000000

Dim hInet As Long
Dim hUrl As Long
Dim Flags As Long
Dim url As Variant


Public Function CheckINetConnection() As Boolean
  hInet = InternetOpen(" ", INTERNET_OPEN_TYPE_PRECONFIG, vbNullString, vbNullString, 0&)
  If hInet Then
    Flags = INTERNET_FLAG_KEEP_CONNECTION Or INTERNET_FLAG_NO_CACHE_WRITE Or INTERNET_FLAG_RELOAD
    hUrl = InternetOpenUrl(hInet, "http://www.stromwerke.de", vbNullString, 0, Flags, 0)
    If hUrl Then
        CheckINetConnection = True
        Call InternetCloseHandle(hUrl)
      Else
        CheckINetConnection = False
      End If
   End If
   Call InternetCloseHandle(hInet)
End Function

Public Sub CheckVersion(checkEveryDays As Long, sec As String, fname As String, fname2 As String, currentVersion As String, internalCurrentVersion As Long)

On Error GoTo exitfunc

  'G_InternetVersion = "Nicht verbunden"
  G_InternetVersion = FMT0("INETCHECK_1")
  G_InternetAvailable = False
  G_UpdateAvailable = False

  Dim d As Date
 
  SaveSetting _
     appname:="Stromwerken", _
     Section:=sec, _
     Key:="VersionDate", _
     setting:=Now
     
     
  Dim Ret As String
  Dim ret2 As String
  
     
  If LoadInetFile(fname, Ret) = True And LoadInetFile(fname2, G_UpdateText) = True Then
  
        G_InternetVersion = GetLine(Ret)
        If Left(G_InternetVersion, 2) = "<!" Then
          G_InternetAvailable = False
          'G_InternetVersion = "Nicht verf|fffd|gbar"
          G_InternetVersion = FMT0("INETCHECK_2")
          Exit Sub
        Else
        
          G_InternetInternalVersion = CLng(GetLine(Ret))
          G_UpdateString = GetLine(Ret)
          G_InternetLicenseVersion = CLng(GetLine(Ret))
          
          G_InternetAvailable = True
            
          If internalCurrentVersion < G_InternetInternalVersion Then
          
            G_UpdateAvailable = True
            
            d = GetSetting( _
               appname:="Stromwerken", _
               Section:=sec, _
               Key:="VersionDate", default:=DateSerial(2000, 1, 1))
            
            If DateAdd("d", checkEveryDays, d) <= Now Then
              CheckInternetUpdateMenu
            End If
            
          End If
        End If
  End If
  Exit Sub

exitfunc:
  Exit Sub
  
End Sub

Function DoThat(t As String) As String

    Dim i As Long
    Dim s2 As String
    For i = 1 To Len(t)
        If Mid(t, i, 1) = "@" Then
            s2 = s2 + vbLf
        ElseIf Mid(t, i, 1) = "^" Then
            s2 = s2 + " "
        ElseIf Mid(t, i, 1) >= "0" And Mid(t, i, 1) <= "9" Then
          s2 = s2 + Chr(Asc("0") + Asc("9") - Asc(Mid(t, i, 1)))
        ElseIf Mid(t, i, 1) >= "a" And Mid(t, i, 1) <= "z" Then
          s2 = s2 + Chr(Asc("a") + Asc("z") - Asc(Mid(t, i, 1)))
        ElseIf Mid(t, i, 1) >= "A" And Mid(t, i, 1) <= "Z" Then
          s2 = s2 + Chr(Asc("A") + Asc("Z") - Asc(Mid(t, i, 1)))
        Else
            s2 = s2 + Mid(t, i, 1)
        End If
    Next i
    
    DoThat = s2
End Function



Function GetSWResItem(ByVal pos As Long, ff As Long) As String
  Dim res As String
  
  If FileExists(G_cfgKeypfad & "\swres.swk") Then
    Open G_cfgKeypfad & "\swres.swk" For Binary Access Read As #ff ' Len = 4
  ElseIf FileExists(ThisWorkbook.path & "\..\swres.swk") Then
    Open ThisWorkbook.path & "\..\swres.swk" For Binary Access Read As #ff ' Len = 4
  Else
    Exit Function
  End If
  
  Dim l As Long
  Get #ff, pos, l

  Dim charc As Long

  ' ENC2
  If l = 1 Then
    Get #ff, pos + 4, l
  
  
  '  Close ff
  '  Open AktVerz & "\swres.swk" For Binary Access Read As #ff ' Len = 1
    For charc = 1 To l
      Dim tchar As Byte
      Get #ff, pos + 7 + charc, tchar
      tchar = tchar Xor (1 + 2 + 4 + 16 + 64)
      res = res & Chr(tchar)
    Next charc
    Close ff
    Do
      pos = InStr(res, "\n")
      If pos <= 0 Then Exit Do
      res = Left(res, pos - 1) & vbCrLf & Mid(res, pos + 2)
    Loop
    GetSWResItem = res
  
  ' ENC3 - LZW
  ElseIf l = 2 Then
    Get #ff, pos + 4, l
  
  '  Close ff
  '  Open AktVerz & "\swres.swk" For Binary Access Read As #ff ' Len = 1
    Dim lval As Long
    Dim arr() As Long
    ReDim arr(l)
    
    For charc = 1 To l
      Get #ff, pos + 4 + charc * 4, lval
      arr(charc - 1) = lval
    Next charc
    Close ff
    
    Dim LZW As New LZW
    res = LZW.DecompressArray(l, arr)
    Set LZW = Nothing
    
    Do
      pos = InStr(res, "\n")
      If pos <= 0 Then Exit Do
      res = Left(res, pos - 1) & vbCrLf & Mid(res, pos + 2)
    Loop
    GetSWResItem = res
  End If
End Function

Sub GetData()
  On Error GoTo noData
  
  G_Lizenzen = -3
  G_ECCPro = False
  
  If FileExists(G_cfgKeypfad & "\swres.swk") Or FileExists(ThisWorkbook.path & "\..\swres.swk") Then
    Dim ff As Long
    ff = FreeFile
    Dim s As String
    
    s = GetSWResItem(1000, ff)
    If InStr(s, "ECC,") > 0 Or InStr(s, "ECCPRO,") > 0 Then
    
      If InStr(s, "ECCPRO,") > 0 Then
        G_ECCPro = True
      End If
    
      G_Lizenznehmer = GetSWResItem(2000, ff)
      G_LizenznehmerAdresse = GetSWResItem(2400, ff)
      G_MyLicencseVersion = Val(GetSWResItem(3000, ff))
      G_Lizenzen = Val(GetSWResItem(3100, ff))
      
      
'      s = GetSWResItem(3200, ff)
      s = ConvGermanDateKey(GetSWResItem(3200, ff))
      Dim hadFullDemoDate As Boolean
      If Len(s) > 0 Then
        If IsDate(s) Then
          If CDate(s) > #1/1/1900# Then
            G_FullDemoBis = CDate(s)
            hadFullDemoDate = True
          End If
        End If
      End If
      G_Wartung = IIf(IsYes(GetSWResItem(3300, ff)), True, False)
      
      If G_Wartung Then
        ' s = GetSWResItem(3400, ff)
        s = ConvGermanDateKey(GetSWResItem(3400, ff))
        If Len(s) > 0 Then
          If IsDate(s) Then
            G_WartungBis = CDate(s)
          End If
        End If
      End If
      
      FullVersion = True
      
      If G_Lizenzen = -1 Then
        'trs = "Full-Demo" & vbCrLf & vbCrLf & G_Lizenznehmer & vbCrLf & G_LizenznehmerAdresse & vbCrLf & vbCrLf & "Einsatz nur zu Testzwecken!"
        trs = FMT2("INETCHECK_3", G_Lizenznehmer, G_LizenznehmerAdresse)
        'trsShrt = "Full-Demo " & G_Lizenznehmer & " - Einsatz nur zu Testzwecken!"
        trsShrt = FMT1("INETCHECK_4", G_Lizenznehmer)
      ElseIf G_Lizenzen = 0 And Now < G_FullDemoBis Then
        'trs = "Full-Demo bis zum " & G_FullDemoBis & vbCrLf & vbCrLf & G_Lizenznehmer & vbCrLf & vbCrLf & G_LizenznehmerAdresse
        trs = FMT3("INETCHECK_5", G_FullDemoBis, G_Lizenznehmer, G_LizenznehmerAdresse)
        'trsShrt = "Full-Demo bis zum " & G_FullDemoBis & " - " & G_Lizenznehmer
        trsShrt = FMT2("INETCHECK_6", G_FullDemoBis, G_Lizenznehmer)
      ElseIf G_Lizenzen = 0 And Now >= G_FullDemoBis Then
        'trs = "Demoversion" & vbCrLf & vbCrLf & G_Lizenznehmer & vbCrLf & vbCrLf & G_LizenznehmerAdresse
        trs = FMT2("INETCHECK_7", G_Lizenznehmer, G_LizenznehmerAdresse)
        'trsShrt = "Demoversion " & G_Lizenznehmer
        trsShrt = FMT1("INETCHECK_8", G_Lizenznehmer)
      ElseIf G_Lizenzen = -2 Then
        'trs = "Gesamthauslizenz" & vbCrLf & vbCrLf & G_Lizenznehmer & vbCrLf & vbCrLf & G_LizenznehmerAdresse
        trs = FMT2("INETCHECK_9", G_Lizenznehmer, G_LizenznehmerAdresse)
        'trsShrt = "Gesamthauslizenz " & G_Lizenznehmer
        trsShrt = FMT1("INETCHECK_10", G_Lizenznehmer)
      ElseIf G_Lizenzen = 1 Then
        'trs = G_Lizenzen & " Lizenz" & IIf(hadFullDemoDate = True, " bis " & G_FullDemoBis, "") & vbCrLf & vbCrLf & G_Lizenznehmer & vbCrLf & vbCrLf & G_LizenznehmerAdresse
        trs = FMT4("INETCHECK_11", G_Lizenzen, IIf(hadFullDemoDate = True, FMT1("INETCHECK_17", G_FullDemoBis), ""), G_Lizenznehmer, G_LizenznehmerAdresse)
        'trsShrt = G_Lizenzen & "Lizenz " & G_Lizenznehmer
        trsShrt = FMT2("INETCHECK_12", G_Lizenzen, G_Lizenznehmer)
      Else
        'trs = G_Lizenzen & " Lizenzen" & vbCrLf & vbCrLf & G_Lizenznehmer & vbCrLf & vbCrLf & G_LizenznehmerAdresse
        trs = FMT3("INETCHECK_13", G_Lizenzen, G_Lizenznehmer, G_LizenznehmerAdresse)
        'trsShrt = G_Lizenzen & "Lizenzen " & G_Lizenznehmer
        trsShrt = FMT2("INETCHECK_14", G_Lizenzen, G_Lizenznehmer)
      End If
      
      If G_Wartung Then
        'trs = trs & vbCrLf & vbCrLf & IIf(G_WartungBis <> 0, "Wartung bis: " & G_WartungBis & IIf(Now > G_WartungBis, " (ABGELAUFEN)", ""), "")
        trs = trs & vbCrLf & vbCrLf & IIf(G_WartungBis <> 0, FMT1("INETCHECK_15", G_WartungBis) & IIf(Now > G_WartungBis, FMT0("INETCHECK_16"), ""), "")
      End If
      
    End If
  End If
  
  
noData:
  Exit Sub
End Sub


Sub CheckInternetUpdateMenu()


  If G_MyLicencseVersion < G_InternetLicenseVersion And FullVersion = True Then
    'INetUpdate.Headline.Caption = "Im Internet liegt eine neue Version des Programms vor."
    INetUpdate.Headline.Caption = FMT0("INETCHECK_18")
    'INetUpdate.Kostenpflichtig.Caption = "Die neue Version ist kostenpflichtig. Bitte wenden Sie sich an info@stromwerken.de, um eine Update-Lizenz zu erwerben. Ohne neuen Lizenz-Key l|fffd|uft das Programm als DEMO!"
    INetUpdate.Kostenpflichtig.Caption = FMT0("INETCHECK_19")
  Else
    'INetUpdate.Headline.Caption = "Im Internet liegt eine neue Version des Programms vor."
    INetUpdate.Headline.Caption = FMT0("INETCHECK_18")
    INetUpdate.Kostenpflichtig.Caption = ""
  End If
  
  INetUpdate.UpdateText = G_UpdateText
  
  INetUpdate.Show
End Sub



Public Function LoadInetFile(fname As String, ByRef Ret As String, Optional fsize As Long = 0) As Boolean
  Dim hInet As Long
  Dim hUrl As Long
  Dim Flags As Long
  Dim url As Variant
  
  LoadInetFile = False
  
  hInet = InternetOpen(" ", INTERNET_OPEN_TYPE_PRECONFIG, vbNullString, vbNullString, 0&)
  If hInet Then
    Flags = INTERNET_FLAG_KEEP_CONNECTION Or INTERNET_FLAG_NO_CACHE_WRITE Or INTERNET_FLAG_RELOAD
    hUrl = InternetOpenUrl(hInet, "http://www.stromwerken.de/" & fname, vbNullString, 0, Flags, 0)
    If hUrl Then
        
        Dim sReadBuf As String * 1024
        Dim flagMoreData As Boolean
        Dim bytesRead As Long
        Dim wRet As Integer
        Dim lastErr As Long
        Dim s As String
        
        flagMoreData = True
        Do While flagMoreData
            sReadBuf = vbNullString
            wRet = InternetReadFile(hUrl, sReadBuf, Len(sReadBuf), bytesRead)
            If Err.LastDllError <> 0 Then
                lastErr = Err.LastDllError
                Ret = "Error (wininet.dll," & lastErr & ")"
                GoTo exitfunc
            End If
            If wRet <> 1 Then
                Ret = "Error"
                GoTo exitfunc
            End If
            s = s & Left$(sReadBuf, bytesRead)
            If Not CBool(bytesRead) Then flagMoreData = False
        Loop
        Ret = s
        
        Call InternetCloseHandle(hUrl)
        Call InternetCloseHandle(hInet)
        LoadInetFile = True
        Exit Function
    Else
      Call InternetCloseHandle(hInet)
    End If
  End If
  Exit Function

exitfunc:
    If hUrl <> 0 Then InternetCloseHandle (hUrl)
    If hInet <> 0 Then InternetCloseHandle (hInet)
End Function



Attribute VB_Name = "INetStuff"
Option Explicit

#If VBA7 Then
  Declare PtrSafe Function URLDownloadToFile Lib "urlmon" Alias "URLDownloadToFileA" _
  (ByVal pCaller As Long, ByVal szURL As String, ByVal szFileName As String, _
  ByVal dwReserved As Long, ByVal lpfnCB As Long) As Long
#Else
  Declare Function URLDownloadToFile Lib "urlmon" Alias "URLDownloadToFileA" _
  (ByVal pCaller As Long, ByVal szURL As String, ByVal szFileName As String, _
  ByVal dwReserved As Long, ByVal lpfnCB As Long) As Long
#End If

Public Function URLEncode(StringVal As String) As String

  ' ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~:/?#[]@!$&'()*+,;=
  Dim i As Long
  Dim r As String
  For i = 1 To Len(StringVal)
    If InStr("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~:/?#[]@!$&'()*+,;=", Mid(StringVal, i, 1)) > 0 Then
      r = r & Mid(StringVal, i, 1)
    Else
      r = r & "%" & Hex(Asc(Mid(StringVal, i, 1)))
    End If
  Next i
  
  URLEncode = r

End Function
Public Function DownloadFile(fname As String, destFName As String, Optional fsize As Long = 0) As Boolean
'    DownloadFile = IIf(URLDownloadToFile(0, fname, destFName, 0, 0) = 0, True, False)
  On Error GoTo nogo
  DownloadFile = False
  
  Dim WinHttpReq As Object
  Set WinHttpReq = CreateObject("Microsoft.XMLHTTP")
  WinHttpReq.Open "GET", URLEncode(fname), False ' , "username", "password"
  WinHttpReq.Send
  
  ' myURL = WinHttpReq.responseBody
  Dim oStream
  If WinHttpReq.status = 200 Then
      Set oStream = CreateObject("ADODB.Stream")
      oStream.Open
      oStream.Type = 1
      oStream.Write WinHttpReq.responseBody
      oStream.SaveToFile destFName, 2 ' 1 = no overwrite, 2 = overwrite
      oStream.Close
  End If
  DownloadFile = True
  
  Exit Function
nogo:
  
End Function








Attribute VB_Name = "INetUpdate"
Attribute VB_Base = "0{12D58B36-6984-4DB4-A79E-287A27AA4623}{563550E4-030D-41D7-9433-5E967ED108F1}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Sub cmdAbbrechen_Click()
  Me.Hide
End Sub

Private Sub cmdDownload_Click()
  Me.Hide
  On Error Resume Next
  Call Shell("explorer.exe " & G_UpdateString, 1)
  ThisWorkbook.Close False
End Sub

Private Sub UserForm_Initialize()
  gTranslation.TranslateForm Me
End Sub
Attribute VB_Name = "KillStuff"
Option Explicit


#If VBA7 Then
  Private Declare PtrSafe Function GetCurrentProcessId Lib "kernel32" () As Long
  
  Private Declare PtrSafe Function OpenProcess Lib "kernel32" _
    (ByVal dwDesiredAccess As Long, _
    ByVal bInheritHandle As Long, _
    ByVal dwProcessId As Long) As Long
  
  Private Declare PtrSafe Function TerminateProcess Lib "kernel32" ( _
      ByVal hProcess As Long, _
      ByVal uExitCode As Long _
      ) As Long
      
  Private Declare PtrSafe Function CloseHandle Lib "kernel32" ( _
      ByVal hObject As LongPtr _
      ) As Long
  
  Declare PtrSafe Function GetVersion Lib "kernel32" () As Long

  Private Declare PtrSafe Function GetCurrentProcess Lib "kernel32" () As Long
  Private Declare PtrSafe Function OpenProcessToken Lib "advapi32.dll" (ByVal ProcessHandle As LongPtr, ByVal DesiredAccess As Long, TokenHandle As LongPtr) As Long
  Private Declare PtrSafe Function LookupPrivilegeValue Lib "advapi32.dll" Alias "LookupPrivilegeValueA" (ByVal lpSystemName As String, ByVal lpName As String, lpLuid As LUID) As Long
  Private Declare PtrSafe Function AdjustTokenPrivileges Lib "advapi32.dll" (ByVal TokenHandle As LongPtr, ByVal DisableAllPrivileges As Long, NewState As TOKEN_PRIVILEGES, ByVal BufferLength As Long, PreviousState As Any, ReturnLength As Long) As Long

#Else
  Private Declare Function GetCurrentProcessId Lib "kernel32" () As Long
  
  Private Declare Function OpenProcess Lib "kernel32" _
    (ByVal dwDesiredAccess As Long, _
    ByVal bInheritHandle As Long, _
    ByVal dwProcessId As Long) As Long
  
  Private Declare Function TerminateProcess Lib "kernel32" ( _
      ByVal hProcess As Long, _
      ByVal uExitCode As Long _
      ) As Long
      
  Private Declare Function CloseHandle Lib "kernel32" ( _
      ByVal hObject As Long _
      ) As Long

  Private Declare Function GetVersion Lib "kernel32" () As Long
  Private Declare Function GetCurrentProcess Lib "kernel32" () As Long
  Private Declare Function OpenProcessToken Lib "advapi32" (ByVal ProcessHandle As Long, ByVal DesiredAccess As Long, TokenHandle As Long) As Long
  Private Declare Function LookupPrivilegeValue Lib "advapi32" Alias "LookupPrivilegeValueA" (ByVal lpSystemName As String, ByVal lpName As String, lpLuid As LUID) As Long
  Private Declare Function AdjustTokenPrivileges Lib "advapi32" (ByVal TokenHandle As Long, ByVal DisableAllPrivileges As Long, NewState As TOKEN_PRIVILEGES, ByVal BufferLength As Long, PreviousState As Any, ReturnLength As Any) As Long


#End If


Const MAX_PATH& = 260


Private Type LUID
  lowpart As Long
  highpart As Long
End Type

Private Type TOKEN_PRIVILEGES
  PrivilegeCount As Long
  LuidUDT As LUID
  Attributes As Long
End Type

Const TOKEN_ADJUST_PRIVILEGES = &H20
Const TOKEN_QUERY = &H8
Const SE_PRIVILEGE_ENABLED = &H2
Const PROCESS_ALL_ACCESS = &H1F0FFF


Type PROCESSENTRY32
  dwSize As Long
  cntUsage As Long
  th32ProcessID As Long
  th32DefaultHeapID As Long
  th32ModuleID As Long
  cntThreads As Long
  th32ParentProcessID As Long
  pcPriClassBase As Long
  dwFlags As Long
  szexeFile As String * MAX_PATH
End Type


Function TerminateExe(exename As String, ByVal usrname As String) As Boolean
    Dim Process As Object
    For Each Process In GetObject("winmgmts:").ExecQuery("Select Name from Win32_Process Where Name = '" & exename & "'")
        If usrname = "" Then
'            Process.Terminate
            ' Sicher ist sicher!
            KillProcess Process.Handle
            TerminateExe = True
        Else
          Dim strNameOfUser
          Process.GetOwner strNameOfUser
          If strNameOfUser = usrname Then
            KillProcess Process.Handle
'            Process.Terminate
          End If
        End If
    Next
    
    ' und den noch hinterher
'    Shell "C:\Windows\System32\TASKKILL /F /FI " & Chr(34) & "USERNAME eq " & GetUserName() & Chr(34) & " /IM " & exename & " /T", vbHide
    
End Function


'Terminate any application and return an exit code to Windows.
Function KillProcess(ByVal hProcessID As Long, Optional ByVal exitCode As Long) As Boolean
#If VBA7 Then
  Dim hToken As LongPtr
#Else
  Dim hToken As Long
#End If

  Dim hProcess As Long

  Dim tp As TOKEN_PRIVILEGES
  
  
  If GetVersion() >= 0 Then
    If OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES Or TOKEN_QUERY, hToken) = 0 Then
    GoTo CleanUp
    End If
    
    If LookupPrivilegeValue("", "SeDebugPrivilege", tp.LuidUDT) = 0 Then
    GoTo CleanUp
    End If
    
    tp.PrivilegeCount = 1
    tp.Attributes = SE_PRIVILEGE_ENABLED
    
    If AdjustTokenPrivileges(hToken, False, tp, 0, ByVal 0&, ByVal 0&) = 0 Then
    GoTo CleanUp
    End If
  End If
  
  hProcess = OpenProcess(PROCESS_ALL_ACCESS, 0, hProcessID)
  If hProcess Then
  
  KillProcess = (TerminateProcess(hProcess, exitCode) <> 0)
  ' close the process handle
  CloseHandle hProcess
  End If
  
  If GetVersion() >= 0 Then
  ' under NT restore original privileges
  tp.Attributes = 0
  AdjustTokenPrivileges hToken, False, tp, 0, ByVal 0&, ByVal 0&
  
CleanUp:
  If hToken Then CloseHandle hToken
  End If

End Function



Sub RegAddProgPID(ByVal progName As String, Optional ByVal pid As Long = -1)
  If pid = -1 Then pid = GetCurrentProcessId
  If Not RegHasProgPID(progName, pid) Then
    SaveSetting appname:="Stromwerken", Section:=progName, Key:="ProcessIDs", setting:= _
     GetSetting(appname:="Stromwerken", Section:=progName, Key:="ProcessIDs", default:="") & "(" & pid & ")"
  End If
End Sub
Sub RegRemoveProgPID(ByVal progName As String, Optional ByVal pid As Long = -1)
  If pid = -1 Then pid = GetCurrentProcessId
  Dim s As String
  s = GetSetting(appname:="Stromwerken", Section:=progName, Key:="ProcessIDs", default:="")
  s = Replace(s, "(" & pid & ")", "")
  SaveSetting appname:="Stromwerken", Section:=progName, Key:="ProcessIDs", setting:=s
End Sub
Function RegHasProgPID(ByVal progName As String, ByVal pid As Long) As Boolean
  RegHasProgPID = InStr(GetSetting(appname:="Stromwerken", Section:=progName, Key:="ProcessIDs", default:=""), "(" & pid & ")") > 0
End Function

' Returns -1 is no PID left
Function RegRemoveNextProgPID(ByVal progName As String) As Long
  Dim s As String
  s = GetSetting(appname:="Stromwerken", Section:=progName, Key:="ProcessIDs", default:="")
  If Left(s, 1) = "(" Then
    Dim v As Long
    Dim pos As Long
    pos = InStr(s, ")")
    If pos > 0 Then
      v = Mid(s, 2, pos - 2)
      RegRemoveProgPID progName, v
    Else
      v = -1
    End If
    RegRemoveNextProgPID = v
  Else
     RegRemoveNextProgPID = -1
  End If

End Function

Sub RegKillAllRunningProgPIDs(ByVal progName As String, Optional exceptForMe As Boolean = False)
  Dim v As Long
  Dim pid As Long
  Dim foundPid As Boolean
  If exceptForMe Then
    pid = GetCurrentProcessId
  Else
    pid = -1
  End If
  Do
    v = RegRemoveNextProgPID(progName)
    If v < 0 Then Exit Do
    If pid > 0 Then
      If v <> pid Then
        KillProcess v
        ' Und auch noch mal hiermit probieren!
'        Shell "C:\Windows\System32\TASKKILL.exe /PID " & v & " /F /T", vbHide
      Else
        foundPid = True
      End If
    Else
      KillProcess v
      ' Und auch noch mal hiermit probieren!
'      Shell "C:\Windows\System32\TASKKILL.exe /PID " & v & " /F /T", vbHide
    End If
  Loop
  If foundPid Then
    RegAddProgPID progName, foundPid
  End If
End Sub

Function TerminateExeByPID(ByVal pid As Long) As Boolean
    Dim Process As Object
    For Each Process In GetObject("winmgmts:").ExecQuery("Select ProcessID from Win32_Process Where ProcessID = " & pid)
      Process.Terminate
      TerminateExeByPID = True
    Next
End Function

Sub ResetScannerKeys(ByVal scanner As String)
    SaveSetting appname:="Stromwerken", Section:=scanner, Key:="LiveStatusTime", setting:=#1/1/1900#
    SaveSetting appname:="Stromwerken", Section:=scanner, Key:="LiveStatus", setting:=""
    SaveSetting appname:="Stromwerken", Section:=scanner, Key:="COMMAND", setting:=""
    SaveSetting appname:="Stromwerken", Section:=scanner, Key:="Restart", setting:=0
    SaveSetting appname:="Stromwerken", Section:=scanner, Key:="AbortAction", setting:=""
    SaveSetting appname:="Stromwerken", Section:="IDVSS", Key:=scanner & "ScanFinished", setting:="0"
    SaveSetting appname:="Stromwerken", Section:="IDVSS", Key:=scanner & "FileScanRunning", setting:="0"
End Sub

Sub DoTaskKillExcelSheetChecker()

  ' Es kann nur einen geben!
  TerminateExe "werfault.exe", GetUserName
  TerminateExe "dwwin.exe", GetUserName
  TerminateExe "dw20.exe", GetUserName
  TerminateExe "ECCdaemon.exe", GetUserName
  TerminateExe "Excelcnv.exe", GetUserName
  RegKillAllRunningProgPIDs "ECC", True
  ClearResilience
'  ResetScannerKeys "ECC"
End Sub




Attribute VB_Name = "LForItem"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public m_Prefix As String
Public m_Val As String
Public m_X As Long
Public m_Y As Long
Attribute VB_Name = "LZW"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

'Private Data Members
Private flgFirstTime As Boolean
Private arr() As String
Private m_CharacterBytesCount As Integer


'Properties
Public Property Get CharacterBytesCount() As Integer
    CharacterBytesCount = m_CharacterBytesCount
End Property

Public Property Let CharacterBytesCount(ByVal vNewValue As Integer)
    m_CharacterBytesCount = vNewValue
End Property

'Private Methods
Private Function Add(ByVal Entry As String) As Long

   If flgFirstTime Then
        flgFirstTime = False
    Else
        ReDim Preserve arr(UBound(arr) + 1)
    End If
    
    arr(UBound(arr)) = Entry
    'Arr(UBound(Arr)).Code = ubund(
    
    Add = UBound(arr)
    
End Function

Private Function IsExists(ByVal Entry As String) As Boolean
    Dim i As Long
    Dim flg As Boolean
    flg = False
    
    For i = LBound(arr) To UBound(arr)
        If arr(i) = Entry Then
            flg = True
            Exit For
        End If
    Next i
    
    IsExists = flg
    
End Function

Private Function IsIndexExists(ByVal index As Long) As Boolean
    
    Dim flg As Boolean
    flg = False
    
    If index <= UBound(arr) Then
        flg = True
    Else
        flg = False
    End If
    
    IsIndexExists = flg
    
End Function

Private Function GetValue(ByVal index As Long) As String
    If IsIndexExists(index) Then
        GetValue = arr(index)
    Else
        GetValue = ""
    End If
End Function

Private Function GetIndexOf(ByVal Entry As String) As Long
    
    Dim i As Long
    Dim ReturnCode As Long
    ReturnCode = -1
    
    For i = LBound(arr) To UBound(arr)
        If arr(i) = Entry Then
            ReturnCode = i
            Exit For
        End If
    Next i
    
    GetIndexOf = ReturnCode
    
End Function

Private Sub Class_Initialize()
    ReDim arr(0) As String
    flgFirstTime = True
    m_CharacterBytesCount = 2
End Sub

Private Function mrtLeft(ByVal InputString As String, ByVal Length As Long) As String
    If Len(InputString) >= Length Then
        mrtLeft = Left(InputString, Length)
    Else
        mrtLeft = InputString
    End If
End Function

Private Sub InitializeDictionary()
    Dim i As Long
    For i = 0 To (2 ^ (m_CharacterBytesCount * 8)) - 1
        Add (ChrW(i))
    Next
End Sub

Private Function Length() As Long
    Length = UBound(arr)
End Function

'Public methods
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Public Function Compress(ByVal UncompressedData As String, ByRef valam As Long, ByRef arr() As Long) As String

    Dim w As String
    Dim c As String
    Dim wc As String
    'Dim dic As New Dictionary
    Dim Output As String
    Dim Code As Long
    
    Dim i As Long
    InitializeDictionary
    valam = 0
    
    ReDim arr(1024)
    Dim curarrsize As Long
    curarrsize = 1024
     
    w = ""
    For i = 1 To Len(UncompressedData)
        
        c = Mid(UncompressedData, i, 1)
        wc = w + c
        If IsExists(wc) Then
            w = wc
        Else
            Code = Add(wc)
            Code = GetIndexOf(w)
            Output = Output & IIf(Output = "", "", ",") & Code
            arr(valam) = Code
            valam = valam + 1
            If valam > curarrsize Then
              curarrsize = curarrsize + 1024
              ReDim Preserve arr(curarrsize)
            End If
            w = c
        End If
        
        '?
    
    Next i
    
    Output = Output & IIf(Output = "", "", ",") & GetIndexOf(w)
    arr(valam) = GetIndexOf(w)
    valam = valam + 1
    
    Compress = Output

End Function


Public Function DecompressArray(valam As Long, arr() As Long) As String
  Dim compresseddata As String
  Dim i As Long
  For i = 0 To valam - 1
    compresseddata = compresseddata & IIf(compresseddata = "", "", ",") & arr(i)
  Next i
  DecompressArray = Decompress(compresseddata)
End Function

Public Function Decompress(ByVal compresseddata As String) As String
    
    If compresseddata = "" Then Exit Function
    
    'Dim dic As New Dictionary
    
    InitializeDictionary

    Dim Output As String
    Dim Entry As String

    Dim K As String
    Dim w As String
    Dim i As Long
    
    Dim arrCompressedData() As String
    ListSplit arrCompressedData, compresseddata, "," '  arrCompressedData = Split(compresseddata, ",")
    
    K = arrCompressedData(0)
    Output = Output & GetValue(K)
    w = K
    
    For i = 1 To UBound(arrCompressedData)
    
        K = arrCompressedData(i)
        
        If IsIndexExists(K) Then
        
            Entry = GetValue(K)
            
        ElseIf IsIndexExists(K) = False And K = Length + 1 Then
            
            Entry = GetValue(w) + mrtLeft(GetValue(w), 1)
            
        Else
            Dim msg As String
            msg = "Bad compressed."
            MsgBox msg
        End If
        
        Output = Output + Entry
        
        Add (GetValue(w) + mrtLeft(Entry, 1))
        
        w = GetIndexOf(Entry)
        
    Next
    
    Decompress = Output
    
End Function


 Function ListSplit(ArrayReturn() As String, ByVal StringToSplit As String, _
 SplitAt As String) As Integer
   Dim intInstr As Integer
   Dim intCount As Integer
   Dim strTemp As String

   intCount = -1
   intInstr = InStr(StringToSplit, SplitAt)
   Do While intInstr > 0
     intCount = intCount + 1
     ReDim Preserve ArrayReturn(0 To intCount)
     ArrayReturn(intCount) = Left(StringToSplit, intInstr - 1)
     StringToSplit = Mid(StringToSplit, intInstr + 1)
     intInstr = InStr(StringToSplit, SplitAt)
   Loop
   If Len(StringToSplit) > 0 Then
     intCount = intCount + 1
     ReDim Preserve ArrayReturn(0 To intCount)
     ArrayReturn(intCount) = StringToSplit
   End If
   ListSplit = intCount
 End Function




Attribute VB_Name = "Libs"
Option Explicit

Function InitSWLib(enginename As String) As Boolean
  InitSWLib = False
  
  Dim item
  For Each item In ActiveWorkbook.VBProject.References
    If item.name = enginename Then
      ExitSWLib enginename
      Exit For
    End If
  Next item
  
'  On Error GoTo couldntInit
  If FileExists(ThisWorkbook.path & "\" & enginename & ".xla") Then
    ThisWorkbook.VBProject.References.AddFromFile ThisWorkbook.path & "\" & enginename & ".xla"
'    Application.VBE.ActiveVBProject.References.AddFromFile ThisWorkbook.Path & "\" & enginename & ".xla"
    InitSWLib = True
  ElseIf FileExists("d:\development\excel97\" & enginename & "\" & enginename & ".xls") Then
    ThisWorkbook.VBProject.References.AddFromFile "d:\development\excel97\" & enginename & "\" & enginename & ".xls"
'    Application.VBE.ActiveVBProject.References.AddFromFile "d:\development\excel97\" & enginename & "\" & enginename & ".xls"
    InitSWLib = True
  End If
  Exit Function
couldntInit:
End Function

Sub ExitSWLib(enginename As String)
  On Error Resume Next
  ThisWorkbook.VBProject.References.Remove ThisWorkbook.VBProject.References(enginename)
  Exit Sub
End Sub


Attribute VB_Name = "MainMenu"
Attribute VB_Base = "0{B075EDC4-752B-44E2-B5FD-0BAF26134FA7}{41C1EC53-D2D5-4642-8597-ACF03A21A88B}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Const StartEnums As Long = 30
Const ChecksumMod As Long = &H100000
Const Tabellen|fffd|bersichtY As Long = 6
Const StartMassenanalyseY As Long = 11

Const ProgWidth As Long = 528
Const ProgWidth2 As Long = 96

Public VBAFailure As Long


'Private Sub cmdSprache_Click()
'  Sprache.MyInit
'  Sprache.Show
'  SaveSetting _
'     AppName:="Stromwerken", _
'     Section:=progNameShort, _
'     Key:="Sprache", _
'     Setting:=GSprache
'  TexteInit
'End Sub

Private Sub cmdUpdate_Click()
  
  CheckInternetUpdateMenu

End Sub

Private Sub HelpButton_Click()
  OpenFileWithApp ThisWorkbook.path & "\Excel-Sheet-Checker.pdf"
  
End Sub

Private Sub Label16_Click()
  On Error Resume Next
  'Call Shell("explorer.exe http://www.stromwerken.de", 1)
  Call Shell("explorer.exe http://" & FMT0("MM_9"), 1)
End Sub


Private Sub Analyse_Click()
  
  Me.Hide
  
  EinzelanalyseStarten

End Sub

 
Private Sub cmdMassenanalyseFortsetzen_Click()

  Me.Hide
  
  Dim wb As Workbook
  For Each wb In Workbooks
    If wb.name <> ThisWorkbook.name Then
      If Not wb.Saved Then
         'MsgBox "Sie haben noch ungesicherte Excel-Dateien ge|fffd|ffnet, bitte schlie|fffd|en Sie diese, bevor Sie die Massenanalyse ausf|fffd|hren.", vbInformation
         MsgBox FMT0("MM_11"), vbInformation
         Exit Sub
      End If
    End If
  Next wb
  
  MassenanalyseFortsetzen

End Sub

Private Sub ProgrammBeenden_Click()
  On Error Resume Next
'    ThisWorkbook.Close
  MainMenu.Hide
End Sub




Private Sub Massenanalyse_Click()

  Me.Hide
  
  Dim wb As Workbook
  For Each wb In Workbooks
    If wb.name <> ThisWorkbook.name Then
      If Not wb.Saved Then
         'MsgBox "Sie haben noch ungesicherte Excel-Dateien ge|fffd|ffnet, bitte schlie|fffd|en Sie diese, bevor Sie die Massenanalyse ausf|fffd|hren.", vbInformation
         MsgBox FMT0("MM_11"), vbInformation
         Exit Sub
      End If
    End If
  Next wb
  
  MassenanalyseStarten
    
End Sub
  
Private Sub UserForm_Initialize()
  gTranslation.TranslateForm Me
End Sub
Attribute VB_Name = "MemStuff"
Option Explicit

#If VBA7 Then
  Private Declare PtrSafe Sub GlobalMemoryStatus Lib "kernel32" ( _
      lpBuffer As MEMORYSTATUS)
#Else
  Private Declare Sub GlobalMemoryStatus Lib "kernel32" ( _
      lpBuffer As MEMORYSTATUS)
#End If

Private Type MEMORYSTATUS
    dwLength As Long
    dwMemoryLoad As Long
    dwTotalPhys As Long
    dwAvailPhys As Long
    dwTotalPageFile As Long
    dwAvailPageFile As Long
    dwTotalVirtual As Long
    dwAvailVirtual As Long
End Type



Function GetFreeMem() As Long
  Dim SpeicherInfos As MEMORYSTATUS
  GlobalMemoryStatus SpeicherInfos
  GetFreeMem = SpeicherInfos.dwAvailPhys
End Function


Attribute VB_Name = "PW"
Option Explicit

    Public Sub SortiereIndex(ByVal zeile As String, ByRef zIndex() As Long)
        Dim i As Long
        Dim l As Long

        For i = 1 To 8
            Dim kl As String
            kl = Mid(zeile, i, 1)
            Dim klindex As Integer
            klindex = 1
            For l = 2 To 8
                If kl = " " Or Mid(zeile, l, 1) < kl Then
                    If Mid(zeile, l, 1) <> " " Then
                        kl = Mid(zeile, l, 1)
                        klindex = l
                    End If
                End If
            Next
            zIndex(i) = klindex
            Mid(zeile, klindex, 1) = " "
        Next
    End Sub

    Public Function FirmenPasswort(ByVal firmenname As String) As String
        Dim zeichen(8) As String
        
        firmenname = Replace(firmenname, vbCr, "")
        firmenname = Replace(firmenname, vbLf, "")
        firmenname = Replace(firmenname, vbTab, "")

        zeichen(3) = "mnbvcxy&"
        zeichen(4) = "ASDFGHJK"
        zeichen(5) = "12345678"
        zeichen(6) = "QWER?\{}"
        zeichen(7) = "&[]*+-/|fffd|"
        zeichen(8) = "!(/&abcd"

        Dim zeile As String
        Dim spalte As String

        zeile = ""
        spalte = ""

        Dim i As Long
        Dim l As Long
        Dim m As Long
        If Len(firmenname) < 16 Then
            firmenname = firmenname & Left("Ein16stellenText", 16 - Len(firmenname))
        End If
        m = Len(firmenname) / 2
        For i = 0 To 3
            zeile = zeile & Mid(firmenname, m - i, 1)
            zeile = zeile & Mid(firmenname, m + i + 1, 1)
            spalte = spalte & Mid(firmenname, m - i - 4, 1)
            spalte = spalte & Mid(firmenname, m + i + 5, 1)
        Next i
        zeile = Replace(zeile, " ", "A")
        spalte = Replace(spalte, " ", "B")
        zeichen(1) = zeile
        zeichen(2) = spalte

        ' Sortieren und Indizes merken
        Dim zIndex(8) As Long
        Dim sindex(8) As Long
        SortiereIndex zeile, zIndex
        SortiereIndex spalte, sindex

        For i = 1 To 8
            Dim z As String
            z = ""
            For l = 1 To 8
                z = z & Mid(zeichen(i), zIndex(l), 1)
            Next
            zeichen(i) = z
        Next

        Dim result(8) As String

        For i = 1 To 8
            result(i) = "00000000"
        Next

        Dim s As Long
        For s = 1 To 8
            For l = 1 To 8
                Mid(result(l), s, 1) = Mid(zeichen(sindex(l)), s, 1)
            Next
        Next

        FirmenPasswort = result(1) & result(2) & result(3) & result(4) & result(7) & result(8)

    End Function

Public Function GetStandardPassword() As String
    GetStandardPassword = FirmenPasswort(G_LizenznehmerAdresse)  ' "NDR9)oio0(rrl5/mfk677&" & Left(G_Lizenznehmer & "        ", 8)
End Function


Public Function GetFilePassword(ByRef conn As Object, ByVal fname As String) As String
    GetFilePassword = ""
    
    Dim rs As Object
    Dim curId As Long
    Dim hash As String

    ' Wenn Sie bereits gespeichert wurde...
    Dim wasLocked As Boolean
    If GetTargetRSFromFilename(conn, GetUNCPath(fname), rs, curId) Then
        If Not rs Is Nothing Then
            If rs.Fields("Dateiberechtigungen").value <> 0 Then
                ' Berechtigung des aktuellen Users pr|fffd|fen
                
                Dim rsBerechtigung As Object
                Set rsBerechtigung = CreateObject("ADODB.Recordset")
                rsBerechtigung.Open "Select * from idvDateienBerechtigungen where idvDateiID = " & curId & " and typ = 1 and Berechtigungstraeger = '" & GetUserNameUCASE() & "'", conn, MYadOpenDynamic, MYadLockReadOnly
                If Not rsBerechtigung Is Nothing Then
                    If rsBerechtigung.EOF = False Then
                        GetFilePassword = GetStandardPassword()
                    End If
                    rsBerechtigung.Close
                End If
                Set rsBerechtigung = Nothing
            
                rs.Close
                Set rs = Nothing
                Exit Function
            Else
                Dim rsPW As Object
                Set rsPW = CreateObject("ADODB.Recordset")
                rsPW.Open "Select Passwort from idvDateienPW where idvDateiID = " & curId & " and PWTyp = 1", conn, MYadOpenDynamic, MYadLockReadOnly
                If Not rsPW Is Nothing Then
                    If rsPW.EOF = False Then
                        GetFilePassword = DecryptPasswort(rsPW.Fields("Passwort").value)
                    End If
                    rsPW.Close
                End If
                Set rsPW = Nothing
            End If
            rs.Close
            Set rs = Nothing
        End If
    End If
    Exit Function
    
fehler:
    GetFilePassword = ""
    
End Function



Public Function GetUserNameUCASE() As String
    GetUserNameUCASE = UCase(GetUserName)
End Function

Attribute VB_Name = "ParamAsk"
Attribute VB_Base = "0{BF4BC3CC-FA15-4F1F-986B-48071814A3F6}{DDB0E1FB-2CBB-4015-A4E7-B475D501642F}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
 
Private Sub cmdOK_Click()
  Me.Hide
End Sub

Private Sub UserForm_Initialize()
  gTranslation.TranslateForm Me
End Sub
Attribute VB_Name = "PathSelect"
Attribute VB_Base = "0{EA03D74B-42DB-4544-B387-54680D35C1E7}{71A9A24E-E25C-4B6D-805C-2A386D45DFD2}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private InUpdate As Boolean
Public WasOK As Boolean

Public Sub MyInit()

  selMonate = Val(GetSetting( _
    appname:="Stromwerken", _
    Section:=progNameShort, _
    Key:="NichtAelterAls", default:="48"))
  
  selKB = Val(GetSetting( _
    appname:="Stromwerken", _
    Section:=progNameShort, _
    Key:="NichtKleinerAls", default:="0"))
  
  selGleicheNamenIgnorieren = GetSetting( _
    appname:="Stromwerken", _
    Section:=progNameShort, _
    Key:="GleicheNamenIgnorieren", default:=True) = "1"
  
  selUnterverzeichnisseIgnorieren = GetSetting( _
    appname:="Stromwerken", _
    Section:=progNameShort, _
    Key:="UnterverzeichnisseIgnorieren", default:=False) = "1"

  WasOK = False

  GefundeneMengen = "" ' GetKriterien(SelektierterPfad, SelMonate, SelKB, selgleichenamenignorieren, selunterverzeichnisseIgnorieren, GefundeneMengen)

  Verzeichnisse.Clear

  On Error GoTo nofile
  
  
  Dim fn As Long
  fn = FreeFile
  Dim s As String
  Open G_cfgTemppfad & "\ECCMaPaths.txt" For Input As fn
  If Not EOF(fn) Then
    Input #fn, s
    Verzeichnisse.addItem s
  End If
  Close fn
  
  Exit Sub
nofile:

End Sub


Function GetRelevantFiles(nichtaelterals As Long, nichtkleinerals As Long, gleichenamenignorieren As Boolean, unterverzeichnisseIgnorieren As Boolean, infoLabel)
  Set xlsDateien = New Collection
  Set inaccessablePaths = New Collection
  
  TotalUsedBytes = 0
  TotalUsedFiles = 0
  TotalUnusedBytes = 0
  TotalUnusedFiles = 0
  TotalUnusedBytesOlder = 0
  TotalUnusedFilesOlder = 0
  TotalUnusedBytesSmaller = 0
  TotalUnusedFilesSmaller = 0
  TotalUnusedBytesDouble = 0
  TotalUnusedFilesDouble = 0

  TotalFilesTested = 0

  Dim i As Long
  If Verzeichnisse.ListCount >= 1 Then
    For i = 0 To Verzeichnisse.ListCount - 1
      Dim p As String
      p = Verzeichnisse.Column(0, i)
      If Right(p, 1) = "\" Then
        p = Left(p, Len(p) - 1)
      End If
      ScanDirs p, nichtaelterals, nichtkleinerals, gleichenamenignorieren, unterverzeichnisseIgnorieren, infoLabel
    Next i
  End If

End Function




Private Sub cmdAbbruch_Click()
  WasOK = False
  Me.Hide
End Sub


Private Sub cmdAdd_Click()
  Dim s As String
  s = GetDirectory("Pfad w|fffd|hlen...")
  If Len(s) > 0 Then
    Verzeichnisse.Clear
    Verzeichnisse.addItem s
  End If
End Sub

Private Sub cmdOK_Click()

  G_Schnellanalyse = True

  If IsNull(selMonate) Then
    'MsgBox "Bitte geben Sie einen Wert >= 1 f|fffd|r 'Nicht |fffd|lter als X Monate' ein!", vbInformation
    MsgBox FMT0("PATHSEL_14"), vbInformation
    Exit Sub
  ElseIf Not IsNumeric(selMonate) Then
    'MsgBox "Bitte geben Sie einen numerischen Wert f|fffd|r 'Nicht |fffd|lter als X Monate' ein!", vbInformation
    MsgBox FMT0("PATHSEL_15"), vbInformation
    Exit Sub
  ElseIf Val(selMonate) < 1 Then
    'MsgBox "Bitte geben Sie einen Wert >= 1 f|fffd|r 'Nicht |fffd|lter als X Monate' ein!", vbInformation
    MsgBox FMT0("PATHSEL_14"), vbInformation
    Exit Sub
  End If

  If IsNull(selKB) Then
    'MsgBox "Bitte geben Sie einen Wert >= 0 f|fffd|r 'Nicht kleiner als X Kb' ein!", vbInformation
    MsgBox FMT0("PATHSEL_16"), vbInformation
    Exit Sub
  ElseIf Not IsNumeric(selKB) Then
    'MsgBox "Bitte geben Sie einen numerischen Wert f|fffd|r 'Nicht kleiner als X Kb' ein!", vbInformation
    MsgBox FMT0("PATHSEL_17"), vbInformation
    Exit Sub
  ElseIf Val(selKB) < 0 Then
    'MsgBox "Bitte geben Sie einen Wert >= 0 f|fffd|r 'Nicht kleiner als X Kb' ein!", vbInformation
    MsgBox FMT0("PATHSEL_16"), vbInformation
    Exit Sub
  End If

  WasOK = True
  G_CheckDimension = CheckDimensions.value

  PathSelect.selGleicheNamenIgnorieren = selGleicheNamenIgnorieren
  PathSelect.selUnterverzeichnisseIgnorieren = selUnterverzeichnisseIgnorieren
  
  
  SaveMAKriterienSettings
  
  SaveMAPath
  
  GetRelevantFiles Val(PathSelect.selMonate), Val(PathSelect.selKB), PathSelect.selGleicheNamenIgnorieren, PathSelect.selUnterverzeichnisseIgnorieren, GefundeneMengen

  
'  fn = FreeFile
'  Open g_cfgTemppfad & "\ECCMaFiles.txt" For Output As fn
  
'  Dim item
'  If xlsDateien.Count > 0 Then
'    For Each item In xlsDateien
'      If UCase(item) <> UCase(ThisWorkbook.FullName) Then
'        Write #fn, item
'      End If
'    Next item
'  End If
  
'  Close fn
  
  
  
  Me.Hide
End Sub

Sub SaveMAPath()

On Error GoTo nogo
  Dim fn As Long
  fn = FreeFile
  Dim s As String
  Open G_cfgTemppfad & "\ECCMaPaths.txt" For Output As fn
  Dim i As Long
  If Verzeichnisse.ListCount >= 1 Then
    For i = 0 To Verzeichnisse.ListCount - 1
      Write #fn, Verzeichnisse.Column(0, i)
    Next i
  End If
  Close fn
  Exit Sub
  
nogo:
  'MsgBox "Auf die Datei '" & G_cfgTemppfad & "\ECCMaPaths.txt' konnte nicht schreibend zugegriffen werden (" & Err.Description & "). In dieser Datei wird der selektierte Pfad gespeichert. Erlauben Sie bitte nach M|fffd|glichkeit auf die Datei den schreibenden Zugriff. Die Analyse wird nat|fffd|rlich trotzdem durchgef|fffd|hrt.", vbExclamation
  MsgBox FMT2("PATHSEL_18", G_cfgTemppfad, Err.Description), vbExclamation
End Sub

Private Sub cmdOK2_Click()
  cmdOK_Click
  G_Schnellanalyse = False
End Sub

Private Sub MengenBerechnen_Click()
  
  WasOK = True
  
  Dim naa As Long
  naa = 10000
  Dim nka As Long
  nka = 0

  If Not IsNull(selMonate) Then
    If IsNumeric(selMonate) Then
      naa = selMonate
    End If
  End If
  If Not IsNull(selKB) Then
    If IsNumeric(selKB) Then
      nka = selKB
    End If
  End If
  
  
  Set xlsDateien = New Collection
  Set inaccessablePaths = New Collection
  
  TotalUsedBytes = 0
  TotalUsedFiles = 0
  TotalUnusedBytes = 0
  TotalUnusedFiles = 0
  TotalUnusedBytesOlder = 0
  TotalUnusedFilesOlder = 0
  TotalUnusedBytesSmaller = 0
  TotalUnusedFilesSmaller = 0
  TotalUnusedBytesDouble = 0
  TotalUnusedFilesDouble = 0
  
  TotalFilesTested = 0
  
  Dim i As Long
  If Verzeichnisse.ListCount >= 1 Then
    For i = 0 To Verzeichnisse.ListCount - 1
      ScanDirs Verzeichnisse.Column(0, i), naa, nka, selGleicheNamenIgnorieren, selUnterverzeichnisseIgnorieren, GefundeneMengen
    Next i
  End If
  
'  If GSprache = 1 Then
'    GefundeneMengen = "In den Verzeichnissen werden " & TotalUsedFiles & " Datei(en) mit " & Format((TotalUsedBytes) / 1024, "##,##0") & "Kb gescannt." & vbCrLf & vbCrLf & _
'      "Insgesamt werden " & TotalUnusedFiles & " Datei(en) mit " & Format((TotalUnusedBytes) / 1024, "##,##0") & "Kb ignoriert." & vbCrLf & _
'      "-  " & TotalUnusedFilesSmaller & " Datei(en) mit " & Format((TotalUnusedBytesSmaller) / 1024, "##,##0") & "Kb wegen der Einschr|fffd|nkung 'Gr|fffd||fffd|e'," & vbCrLf & _
'      "-  " & TotalUnusedFilesOlder & " Datei(en) mit " & Format((TotalUnusedBytesOlder) / 1024, "##,##0") & "Kb wegen der Einschr|fffd|nkung 'Monate'," & vbCrLf & _
'      "-  " & TotalUnusedFilesDouble & " Datei(en) mit " & Format((TotalUnusedBytesDouble) / 1024, "##,##0") & "Kb wegen der Einschr|fffd|nkung 'Gleiche Namen'"
'  Else
'    GefundeneMengen = TotalUsedFiles & " file(s) with " & Format((TotalUsedBytes) / 1024, "##,##0") & "Kb will be scanned." & vbCrLf & vbCrLf & _
'      TotalUnusedFiles & " file(s) with " & Format((TotalUnusedBytes) / 1024, "##,##0") & "Kb will be ignored." & vbCrLf & _
'      "-  " & TotalUnusedFilesSmaller & " file(s) with " & Format((TotalUnusedBytesSmaller) / 1024, "##,##0") & "Kb because of limitation 'size'," & vbCrLf & _
'      "-  " & TotalUnusedFilesOlder & " file(s) with " & Format((TotalUnusedBytesOlder) / 1024, "##,##0") & "Kb because of limitation 'months'," & vbCrLf & _
'      "-  " & TotalUnusedFilesDouble & " file(s) with " & Format((TotalUnusedBytesDouble) / 1024, "##,##0") & "Kb because of limitation 'same names'"
'  End If
  GefundeneMengen = FMT2("PATHSEL_19", TotalUsedFiles, Format((TotalUsedBytes) / 1024, "##,##0")) & vbCrLf & vbCrLf & _
    FMT2("PATHSEL_20", TotalUnusedFiles, Format((TotalUnusedBytes) / 1024, "##,##0")) & vbCrLf & _
    FMT6("PATHSEL_21", TotalUnusedFilesSmaller, Format((TotalUnusedBytesSmaller) / 1024, "##,##0"), TotalUnusedFilesOlder, Format((TotalUnusedBytesOlder) / 1024, "##,##0"), TotalUnusedFilesDouble, Format((TotalUnusedBytesDouble) / 1024, "##,##0"))
  
  Set xlsDateien = Nothing
  Set inaccessablePaths = Nothing
End Sub




Private Sub selUnterverzeichnisseIgnorieren_Click()
  selGleicheNamenIgnorieren.Enabled = Not selUnterverzeichnisseIgnorieren
End Sub

Private Sub UserForm_Initialize()
  gTranslation.TranslateForm Me
End Sub
Attribute VB_Name = "PrgTexte"
Option Explicit

Public STexteDE As Collection
Public STexteEN As Collection

Public Sub TexteInit()
  Set STexteDE = New Collection
  Set STexteEN = New Collection
  Dim y As Long
  y = 2
  With ThisWorkbook.Sheets("Texte")
    Do While Not IsEmpty(.Cells(y, 1))
      STexteDE.Add .Cells(y, 1 + 1), .Cells(y, 1)
      STexteEN.Add .Cells(y, 1 + 2), .Cells(y, 1)
      y = y + 1
    Loop
  End With

  ' Selektion
  PathSelect.NKAtxt.Caption = FMT0("TXT_NKA")
  PathSelect.N|fffd|Atxt.Caption = FMT0("TXT_NAEA")
  PathSelect.Monatetxt.Caption = FMT0("TXT_MONATE")
  PathSelect.selUnterverzeichnisseIgnorieren.Caption = FMT0("TXT_UNTERVERZEICHNISSEIGNORIEREN")
  PathSelect.selGleicheNamenIgnorieren.Caption = FMT0("TXT_GLEICHENAMENIGNORIEREN")
'  PathSelect.KeineWertetxt.Caption = Texte(GSprache, TXT_LEEREFELDER)
  PathSelect.MengenBerechnen.Caption = FMT0("TXT_MENGENBERECHNEN")
  PathSelect.cmdAbbruch.Caption = FMT0("TXT_ABBRUCHCMD")
End Sub

' Dirk Localization
' Wird nur an zwei Stellen im code verwendet (in der Result Class)
' Damit das auch geht wenn man mit einer en-gb Version das deutsche Risk file laedt muss das hier language agnostic werden
' Dazu die Strings nicht aus der Translation string table nehmen, sondern wie vorher aus dem "Texte" sheet laden - aber ab jetzt beide Sprachen.
'Public Function TextExists(str As String) As Boolean
'  TextExists = gTranslation.StringExists(str)
'End Function
'
'Public Function TranslateText(str As String) As String
'  TranslateText = gTranslation.GetString(str)
'End Function

Function TextExists(str As String) As Boolean
  If CollectionItemExists(STexteDE, str) Then
    TextExists = True
    Exit Function
  End If
  If CollectionItemExists(STexteEN, str) Then
    TextExists = True
    Exit Function
  End If
End Function

Function TranslateText(str As String) As String
  If CollectionItemExists(STexteDE, str) Then
    TranslateText = STexteDE(str)
    Exit Function
  End If
  If CollectionItemExists(STexteEN, str) Then
    TranslateText = STexteEN(str)
    Exit Function
  End If
End Function

'Public STexte As Collection

'Global GSprache As Long
'Const MAX_TEXTE As Long = 100
'Public Texte(2, MAX_TEXTE) As String
'Public STexte As Collection
'
'Global Const TXT_BLATTSCHUTZFEHLT As Long = 1
'Global Const TXT_SZENARIOSCHUTZFEHLT As Long = 2
'Global Const TXT_ANS_EINZELANALYSE As Long = 3
'Global Const TXT_ANS_MASSENANALYSE As Long = 4
'Global Const TXT_ANS_TABELLEN|fffd|BERSICHT As Long = 5
'Global Const TXT_ANS_FUNKTIONSANALYSE As Long = 6
'Global Const TXT_ANS_FUNKTIONS|fffd|BERSICHT As Long = 7
'Global Const TXT_ANS_FUNKTIONSEXPORT As Long = 8
'Global Const TXT_NICHTGEPR|fffd|FT As Long = 9
'Global Const TXT_ABBRUCH As Long = 10
'Global Const TXT_FERTIG As Long = 11
'Global Const TXT_KEINEZELLEN As Long = 12
'Global Const TXT_TABGESCH|fffd|TZT As Long = 13
'Global Const TXT_TABAUSGEBLENDET As Long = 14
'Global Const TXT_DATEIPASSWORTSCHUTZ As Long = 15
'Global Const TXT_VBAPR|fffd|FUNG As Long = 16
'Global Const TXT_EXCEL2000 As Long = 17
'Global Const TXT_ECCENTFERNEN As Long = 18
'Global Const TXT_ORDNERW|fffd|HLEN As Long = 19
'Global Const TXT_NAEA As Long = 20
'Global Const TXT_MONATE As Long = 21
'Global Const TXT_NKA As Long = 22
'Global Const TXT_UVI As Long = 23
'Global Const TXT_GLEICHENAMEN As Long = 24
'Global Const TXT_PFADZUGRIFFVERWEIGERT As Long = 25
'Global Const TXT_ABG As Long = 26
'Global Const TXT_BEEN As Long = 27
'Global Const TXT_DATEIENIMORDNER As Long = 28
'Global Const TXT_XLFILES As Long = 29
'Global Const TXT_FUNKTIONSVERTEILUNG As Long = 30
'Global Const TXT_FAST As Long = 31
'Global Const TXT_DEEP As Long = 32
'Global Const TXT_ANALYSIERT As Long = 33
'Global Const TXT_GESCH|fffd|TZT As Long = 34
'Global Const TXT_GESCH|fffd|TZT2 As Long = 35
'Global Const TXT_NICHTERMITTELBAR As Long = 36
'Global Const TXT_NICHTERMITTELBARKURZ As Long = 37
'Global Const TXT_JAOHNEPW As Long = 38
'Global Const TXT_JAMITPW As Long = 39
'Global Const TXT_JA As Long = 40
'Global Const TXT_SB As Long = 41
'Global Const TXT_USB As Long = 42
'Global Const TXT_SV As Long = 43
'Global Const TXT_DATEVGESCH As Long = 44
'Global Const TXT_TABK As Long = 45
'Global Const TXT_ZEILEK As Long = 46
'Global Const TXT_SPALTEK As Long = 47
'Global Const TXT_CHECKSUMME As Long = 48
'Global Const TXT_STARTECC As Long = 49
'Global Const TXT_REMOVEECC As Long = 50
'Global Const TXT_README As Long = 51
'Global Const TXT_GENERIERTAM As Long = 52
'Global Const TXT_UNTERVERZEICHNISSEIGNORIEREN As Long = 53
'Global Const TXT_GLEICHENAMENIGNORIEREN As Long = 54
'Global Const TXT_LEEREFELDER As Long = 55
'Global Const TXT_MENGENBERECHNEN As Long = 56
'Global Const TXT_ABBRUCHCMD As Long = 57
'Global Const TXT_LAUFWERKE As Long = 58
'Global Const TXT_SPRACHE As Long = 59
'Global Const TXT_PFAD As Long = 60
'Global Const TXT_XLSFILES As Long = 61
'Global Const TXT_ERRORFORMATTING As Long = 62
'Global Const TXT_ELTFILES As Long = 63
'Global Const TXT_ELTXLSFILES As Long = 64
'Global Const TXT_DATEI_FEHLT As Long = 65
'Global Const TXT_DATEI_|fffd|BERSCHREIBEN As Long = 66
'
'Global Const TXT_LADEN As Long = 67
'Global Const TXT_SPEICHERN As Long = 68
'Global Const TXT_LISTEDERZUSCANNENDENDATEIEN As Long = 69
'Global Const TXT_EINZELANALYSEANZEIGEN As Long = 70
'Global Const TXT_AUSWAHLANALYSE As Long = 71
'Global Const TXT_ERGEBNISSPEICHERN As Long = 72
'Global Const TXT_NEIN As Long = 73
'Global Const TXT_FERTIG2 As Long = 74
'
'
'Function TextExists(str As String) As Boolean
'On Error GoTo doesntExist
'  Dim s As String
'  s = STexte(str)
'  TextExists = True
'  Exit Function
'doesntExist:
'  TextExists = False
'End Function
'
'Function TranslateText(str As String) As String
'On Error GoTo doesntExist
'  TranslateText = STexte(str)
'  Exit Function
'doesntExist:
'  TranslateText = str
'End Function
'
'
'
'Sub TexteInit()
'
'  Set STexte = New Collection
'  Dim y As Long
'  y = 2
'  With ThisWorkbook.Sheets("Texte")
'    Do While Not IsEmpty(.Cells(y, 1))
'      STexte.Add .Cells(y, 1 + GSprache), .Cells(y, 1)
'      y = y + 1
'    Loop
'  End With
'
'
'  Texte(1, TXT_BLATTSCHUTZFEHLT) = "B "
'  Texte(2, TXT_BLATTSCHUTZFEHLT) = "S "
'  Texte(1, TXT_SZENARIOSCHUTZFEHLT) = "S "
'  Texte(2, TXT_SZENARIOSCHUTZFEHLT) = "C "
'  Texte(1, TXT_ANS_EINZELANALYSE) = "Einzelanalyse"
'  Texte(2, TXT_ANS_EINZELANALYSE) = "SingleFileAnalysis"
'  Texte(1, TXT_ANS_MASSENANALYSE) = "Massenanalyse"
'  Texte(2, TXT_ANS_MASSENANALYSE) = "MassAnalysis"
'  Texte(1, TXT_ANS_TABELLEN|fffd|BERSICHT) = "Tabellen|fffd|bersicht"
'  Texte(2, TXT_ANS_TABELLEN|fffd|BERSICHT) = "SheetOverview"
'  Texte(1, TXT_ANS_FUNKTIONSANALYSE) = "Funktionsanalyse"
'  Texte(2, TXT_ANS_FUNKTIONSANALYSE) = "FunctionAnalysis"
'  Texte(1, TXT_ANS_FUNKTIONS|fffd|BERSICHT) = "Funktions|fffd|bersicht"
'  Texte(2, TXT_ANS_FUNKTIONS|fffd|BERSICHT) = "FunctionOverview"
'  Texte(1, TXT_ANS_FUNKTIONSEXPORT) = "Funktionsexport"
'  Texte(2, TXT_ANS_FUNKTIONSEXPORT) = "FunctionExport"
'  Texte(1, TXT_NICHTGEPR|fffd|FT) = "Nicht gepr|fffd|ft"
'  Texte(2, TXT_NICHTGEPR|fffd|FT) = "Not tested"
'
'  Texte(1, TXT_ABBRUCH) = "Analyse abgebrochen! Zeit: "
'  Texte(2, TXT_ABBRUCH) = "Aborted! Time: "
'  Texte(1, TXT_FERTIG) = "Fertig! Zeit: "
'  Texte(2, TXT_FERTIG) = "Finished! Time: "
'  Texte(1, TXT_KEINEZELLEN) = "Diese Excel-Datei hat keine Tabellenb|fffd|tter mit genutzten Zellen."
'  Texte(2, TXT_KEINEZELLEN) = "This Excel-file doesnt have any sheets with used cells."
'
'  Texte(1, TXT_TABGESCH|fffd|TZT) = "VORSICHT!!!!" & vbCrLf & _
'                "Einige Tabellen waren mit Passw|fffd|rtern gesch|fffd|tzt. " & _
'                "Die Einf|fffd|rbung funktioniert bei diesen Tabellen nicht. Sollten Sie die Einf|fffd|rbung ben|fffd|tigen, muss der Passwortschutz entfernt werden!"
'  Texte(2, TXT_TABGESCH|fffd|TZT) = "ATTENTION!!!!" & vbCrLf & _
'                "Some sheets were protected with passwords. " & _
'                "Colouring these sheets is not possible. If you need colouring then please remove the passwords!"
'
'  Texte(1, TXT_TABAUSGEBLENDET) = "VORSICHT!!!!" & vbCrLf & _
'                "Einige Tabellen waren ausgeblendet! Da der Arbeitsmappenschutz aktiv ist, " & _
'                "kann der ECC diese Tabellen nicht einblenden! Bitte besorgen Sie sich das Passwort und entfernen den Schutz!"
'  Texte(2, TXT_TABAUSGEBLENDET) = "ATTENTION!!!!" & vbCrLf & _
'                "Some sheets were hidden! Due to the fact that the workbook protection is active " & _
'                "these sheets cannot be made visible! Please remove the passwords first!"
'
'  Texte(1, TXT_DATEIPASSWORTSCHUTZ) = "Die Datei ist evtl. Passwortgesch|fffd|tzt. Bitte entfernen Sie ggfs. den Schutz." & vbCrLf & _
'        "Bitte beachten Sie hierzu den folgenden Fehlertext!"
'  Texte(2, TXT_DATEIPASSWORTSCHUTZ) = "The file is probably password protected. Please remove the password." & vbCrLf & _
'        "Please note the following text!"
'
'  Texte(1, TXT_VBAPR|fffd|FUNG) = "MS-Excel l|fffd|sst eine |fffd|berpr|fffd|fung auf VBA-Programmcode nicht zu. Es kann nicht ermittelt werden, ob es Programmcode innerhalb der Datei gibt oder nicht. Bitte pr|fffd|fen Sie dies selbst!"
'  Texte(2, TXT_VBAPR|fffd|FUNG) = "Access to VBA-Code is prohibited by MS-Excel due to the current settings. It is not possible to detect whether there is VBA-Code or not. Please check this yourself!"
'
'  Texte(1, TXT_EXCEL2000) = "Sie benutzen eine Excel-Version (ab Excel2000), die den Zugriff auf VBA-Code nur beschr|fffd|nkt zul|fffd|sst. Um den vollen Funktionsumfag des ECC nutzen zu k|fffd|nnen, m|fffd|ssen Sie unter Extras/Makro/Sicherheit im Reiter " & _
'          "'Vertrauensw|fffd|rdige Quellen' den Punkt 'Zugriff auf Visual Basic Projekt vertrauen' anschalten. Danach ist erst die volle Analyse m|fffd|glich! Bitte schalten Sie die Funktion bei Bedarf danach wieder aus!"
'  Texte(2, TXT_EXCEL2000) = "You are using an Excel version (Excel2000 or later) that limits VBA-Code access. To be able to use the full analyzing functionality of the " & ProgNameLong & " you will have to turn on the access switch via 'Extras/Macro/Security', slider " & _
'          "'trusted sources' and there 'Trust access for visual basic projects'. Turn off the switch again if you wish to after you are finished analyzing!"
'
'  Texte(1, TXT_ECCENTFERNEN) = "Sind Sie sicher, dass Sie den ECC aus Ihrer Men|fffd|leiste entfernen m|fffd|chten?"
'  Texte(2, TXT_ECCENTFERNEN) = "Are you sure that you want to remove the ECC from your menu bar?"
'
'  Texte(1, TXT_ORDNERW|fffd|HLEN) = "W|fffd|hlen Sie bitte einen Ordner aus."
'  Texte(2, TXT_ORDNERW|fffd|HLEN) = "Please select a folder."
'
'  Texte(1, TXT_NAEA) = "Nicht |fffd|lter als "
'  Texte(2, TXT_NAEA) = "Not older than "
'  Texte(1, TXT_MONATE) = " Monate."
'  Texte(2, TXT_MONATE) = " months."
'
'  Texte(1, TXT_NKA) = "Nicht kleiner als "
'  Texte(2, TXT_NKA) = "Not smaller than "
'
'  Texte(1, TXT_UVI) = "Unterverzeichnisse wurden ignoriert!"
'  Texte(2, TXT_UVI) = "Subfolders were ignored!"
'
'  Texte(1, TXT_GLEICHENAMEN) = "Dateien mit gleichen Namen in Unterverzeichnissen ignorieren."
'  Texte(2, TXT_GLEICHENAMEN) = "Ignore files with same names in subfolders."
'
'  Texte(1, TXT_PFADZUGRIFFVERWEIGERT) = "Zugriff auf Pfad wurde verweigert!"
'  Texte(2, TXT_PFADZUGRIFFVERWEIGERT) = "Access to path denied!"
'
'  Texte(1, TXT_ABG) = "Abgebrochen!"
'  Texte(2, TXT_ABG) = "Aborted!"
'
'  Texte(1, TXT_BEEN) = "Beendet!"
'  Texte(2, TXT_BEEN) = "Finished!"
'
'  Texte(1, TXT_DATEIENIMORDNER) = " Dateie(n) im Ordner '"
'  Texte(2, TXT_DATEIENIMORDNER) = " file(s) in folder '"
'
'  Texte(1, TXT_XLFILES) = "Excel-Dateien,*.xl*"
'  Texte(2, TXT_XLFILES) = "Excel-files,*.xl*"
'
'  Texte(1, TXT_XLSFILES) = "Excel-Dateien,*.xls"
'  Texte(2, TXT_XLSFILES) = "Excel-files,*.xls"
'
'  Texte(1, TXT_FUNKTIONSVERTEILUNG) = "Funktionsverteilung"
'  Texte(2, TXT_FUNKTIONSVERTEILUNG) = "Function distribution"
'
'  Texte(1, TXT_FAST) = "Schnell"
'  Texte(2, TXT_FAST) = "Fast"
'
'  Texte(1, TXT_DEEP) = "Ausf|fffd|hrlich"
'  Texte(2, TXT_DEEP) = "Deep"
'
'  Texte(1, TXT_ANALYSIERT) = "Analysiert!"
'  Texte(2, TXT_ANALYSIERT) = "Analyzed!"
'
'  Texte(1, TXT_GESCH|fffd|TZT) = "Gesch"
'  Texte(2, TXT_GESCH|fffd|TZT) = "Prot"
'  Texte(1, TXT_GESCH|fffd|TZT2) = "Gesch"
'  Texte(2, TXT_GESCH|fffd|TZT2) = "Prot"
'
'  Texte(1, TXT_NICHTERMITTELBAR) = "NE"
'  Texte(2, TXT_NICHTERMITTELBAR) = "NA"
'  Texte(1, TXT_NICHTERMITTELBARKURZ) = "NE"
'  Texte(2, TXT_NICHTERMITTELBARKURZ) = "NA"
'
'  Texte(1, TXT_JAMITPW) = "Ja, mit PW"
'  Texte(2, TXT_JAMITPW) = "Yes, w. pw"
'  Texte(1, TXT_JAOHNEPW) = "Ja, ohne PW"
'  Texte(2, TXT_JAOHNEPW) = "Yes, w/o pw"
'  Texte(1, TXT_JA) = "Ja"
'  Texte(2, TXT_JA) = "Yes"
'
'  Texte(1, TXT_SB) = "SB"
'  Texte(2, TXT_SB) = "VB"
'  Texte(1, TXT_USB) = "USB"
'  Texte(2, TXT_USB) = "IVB"
'
'  Texte(1, TXT_SV) = " SV"
'  Texte(2, TXT_SV) = " VH"
'
'  Texte(1, TXT_DATEVGESCH) = "Die Datei ist evtl. Passwortgesch|fffd|tzt."
'  Texte(2, TXT_DATEVGESCH) = "File might be password protected."
'
'  Texte(1, TXT_TABK) = "T"
'  Texte(2, TXT_TABK) = "S"
'  Texte(1, TXT_ZEILEK) = "Z"
'  Texte(2, TXT_ZEILEK) = "R"
'  Texte(1, TXT_SPALTEK) = "Sp"
'  Texte(2, TXT_SPALTEK) = "Cl"
'  Texte(1, TXT_CHECKSUMME) = "Checksumme"
'  Texte(2, TXT_CHECKSUMME) = "Checksum"
'
'  Texte(1, TXT_STARTECC) = "Startet den " & ProgNameLong & "."
'  Texte(2, TXT_STARTECC) = "Starts the " & ProgNameLong & "."
'
'  Texte(1, TXT_REMOVEECC) = "Entfernt den " & ProgNameLong & " aus der Men|fffd|leiste."
'  Texte(2, TXT_REMOVEECC) = "Removes the " & ProgNameLong & " from the menu bar."
'
'  Texte(1, TXT_README) = "Bitte lesen Sie erst die Datei 'ReadMeDemo.txt'"
'  Texte(2, TXT_README) = "Please read the instructions in the 'ReadMeDemo.txt'-file first."
'
'  Texte(1, TXT_GENERIERTAM) = "Generiert am "
'  Texte(2, TXT_GENERIERTAM) = "Generated "
'
'  Texte(1, TXT_UNTERVERZEICHNISSEIGNORIEREN) = "Unterverzeichnisse ignorieren"
'  Texte(2, TXT_UNTERVERZEICHNISSEIGNORIEREN) = "Ignore subpaths"
'
'  Texte(1, TXT_GLEICHENAMENIGNORIEREN) = "Dateien mit gleichen Namen in Unterverzeichnissen ignorieren"
'  Texte(2, TXT_GLEICHENAMENIGNORIEREN) = "Ignore files with same names in subpaths"
'
'  Texte(1, TXT_LEEREFELDER) = "Wenn Sie keine Werte erfassen, dann werden alle Dateien ber|fffd|cksichtigt."
'  Texte(2, TXT_LEEREFELDER) = "If you do not enter any values all files will be analyzed."
'
'  Texte(1, TXT_MENGENBERECHNEN) = "Mengen berechnen"
'  Texte(2, TXT_MENGENBERECHNEN) = "Calculate amount"
'
'  Texte(1, TXT_ABBRUCHCMD) = "Abbruch"
'  Texte(2, TXT_ABBRUCHCMD) = "Abort"
'
'  Texte(1, TXT_LAUFWERKE) = "Laufwerke:"
'  Texte(2, TXT_LAUFWERKE) = "Drives:"
'
'  Texte(1, TXT_SPRACHE) = "Sprache"
'  Texte(2, TXT_SPRACHE) = "Language"
'
'  Texte(1, TXT_PFAD) = "Pfad:"
'  Texte(2, TXT_PFAD) = "Path:"
'
'  Texte(1, TXT_ERRORFORMATTING) = "Es konnte nicht alle Felder coloriert werden, da Excel f|fffd|r diese Funktion nicht mehr gen|fffd|gend Speicher zur Verf|fffd|gung hat. Bitte nutzen Sie bei der Auswertung der Datei ausschlie|fffd|lich die Ergebnistabellen und nicht die eingef|fffd|rbte Datei!"
'  Texte(2, TXT_ERRORFORMATTING) = "Not all cells could be coloured because Excel does not provide enough memory for this operation. Please do not use the coloured workbook for analysis but only refer to the figures displayed in the result sheets!"
'
'  Texte(1, TXT_ELTFILES) = "ECC-List-Dateien (*.elt),*.elt"
'  Texte(2, TXT_ELTFILES) = "ECC list files (*.elt),*.elt"
'
'  Texte(1, TXT_ELTXLSFILES) = "ECC-List-Dateien (*.elt),*.elt,Excel-Dateien (*.xls),*.xls"
'  Texte(2, TXT_ELTXLSFILES) = "ECC list files (*.elt),*.elt,Excel files (*.xls),*.xls"
'
'  Texte(1, TXT_DATEI_FEHLT) = "Datei existiert nicht."
'  Texte(2, TXT_DATEI_FEHLT) = "File missing"
'
'  Texte(1, TXT_DATEI_|fffd|BERSCHREIBEN) = "Die Datei existiert bereits. Soll Sie |fffd|berschrieben werden?"
'  Texte(2, TXT_DATEI_|fffd|BERSCHREIBEN) = "The selected file already exists. Do you want to overwrite it?"
'
'
'  Texte(1, TXT_LADEN) = "Laden"
'  Texte(2, TXT_LADEN) = "Load"
'  Texte(1, TXT_SPEICHERN) = "Speichern"
'  Texte(2, TXT_SPEICHERN) = "Save"
'  Texte(1, TXT_LISTEDERZUSCANNENDENDATEIEN) = "Liste der zu scannenden Dateien"
'  Texte(2, TXT_LISTEDERZUSCANNENDENDATEIEN) = "List of files to be scanned"
'  Texte(1, TXT_EINZELANALYSEANZEIGEN) = "Jede Datei auch als einzelanalyse anzeigen?"
'  Texte(2, TXT_EINZELANALYSEANZEIGEN) = "Show single file report for each file?"
'
'  Texte(1, TXT_ERGEBNISSPEICHERN) = "Ergebnisdatei speichern..."
'  Texte(2, TXT_ERGEBNISSPEICHERN) = "Save result file..."
'
'  Texte(1, TXT_NEIN) = "Nein"
'  Texte(2, TXT_NEIN) = "No"
'
'  Texte(1, TXT_FERTIG2) = "Fertig!"
'  Texte(2, TXT_FERTIG2) = "Finished!"
'
'  If GSprache = 2 Then
'    MainMenu.Massenanalyse.Caption = "Mass analysis"
'    MainMenu.Analyse.Caption = "Single file analysis"
'    MainMenu.ProgrammBeenden.Caption = "Quit"
'  Else
'    MainMenu.Massenanalyse.Caption = "Massenanalyse"
'    MainMenu.Analyse.Caption = "Einzelanalyse"
'    MainMenu.ProgrammBeenden.Caption = "Beenden"
'  End If
'
''  MainMenu.cmdSprache.Caption = Texte(GSprache, TXT_SPRACHE)
'
'  ' Selektion
'  PathSelect.NKAtxt.Caption = Texte(GSprache, TXT_NKA)
'  PathSelect.N|fffd|Atxt.Caption = Texte(GSprache, TXT_NAEA)
'  PathSelect.Monatetxt.Caption = Texte(GSprache, TXT_MONATE)
'  PathSelect.selUnterverzeichnisseIgnorieren.Caption = Texte(GSprache, TXT_UNTERVERZEICHNISSEIGNORIEREN)
'  PathSelect.selGleicheNamenIgnorieren.Caption = Texte(GSprache, TXT_GLEICHENAMENIGNORIEREN)
''  PathSelect.KeineWertetxt.Caption = Texte(GSprache, TXT_LEEREFELDER)
'  PathSelect.MengenBerechnen.Caption = Texte(GSprache, TXT_MENGENBERECHNEN)
'  PathSelect.cmdAbbruch.Caption = Texte(GSprache, TXT_ABBRUCHCMD)
'
'End Sub

Attribute VB_Name = "RegStuff"
Option Explicit

'API Function and Constant Declarations
'--------------------------------------
Public Enum ERegistryValueTypes
'Predefined Value Types
    REG_NONE = (0)                         'No value type
    REG_SZ = (1)                           'Unicode nul terminated string
    REG_EXPAND_SZ = (2)                    'Unicode nul terminated string w/enviornment var
    REG_BINARY = (3)                       'Free form binary
    REG_DWORD = (4)                        '32-bit number
    REG_DWORD_LITTLE_ENDIAN = (4)          '32-bit number (same as REG_DWORD)
    REG_DWORD_BIG_ENDIAN = (5)             '32-bit number
    REG_LINK = (6)                         'Symbolic Link (unicode)
    REG_MULTI_SZ = (7)                     'Multiple Unicode strings
    REG_RESOURCE_LIST = (8)                'Resource list in the resource map
    REG_FULL_RESOURCE_DESCRIPTOR = (9)     'Resource list in the hardware description
    REG_RESOURCE_REQUIREMENTS_LIST = (10)
End Enum


'***Declare the keys that should exist.
'***Typically applications will put information under HKEY_CURRENT_USER
Global Const HKEY_CLASSES_ROOT = &H80000000
Global Const HKEY_CURRENT_USER = &H80000001
Global Const HKEY_LOCAL_MACHINE = &H80000002
Global Const HKEY_USERS = &H80000003

'***Errors
Global Const ERROR_NONE = 0
Global Const ERROR_BADDB = 1
Global Const ERROR_BADKEY = 2
Global Const ERROR_CANTOPEN = 3
Global Const ERROR_CANTREAD = 4
Global Const ERROR_CANTWRITE = 5
Global Const ERROR_OUTOFMEMORY = 6
Global Const ERROR_INVALID_PARAMETER = 7
Global Const ERROR_ACCESS_DENIED = 8
Global Const ERROR_INVALID_PARAMETERS = 87
Global Const ERROR_NO_MORE_ITEMS = 259

'***Gives all users full access to the key
Global Const KEY_ALL_ACCESS = &H3F

'***Creates a key that is persistent
Global Const REG_OPTION_NON_VOLATILE = 0

Global gstrAppVersion As String

'***Registry API declarations

#If VBA7 Then
  Declare PtrSafe Function RegCloseKey Lib "advapi32.dll" ( _
      ByVal hKey As Long _
  ) As Long
  
  Declare PtrSafe Function RegCreateKeyEx Lib "advapi32.dll" Alias "RegCreateKeyExA" ( _
      ByVal hKey As Long, _
      ByVal lpSubKey As String, _
      ByVal Reserved As Long, _
      ByVal lpClass As String, _
      ByVal dwOptions As Long, _
      ByVal samDesired As Long, _
      ByVal lpSecurityAttributes As Long, _
      phkResult As Long, _
      lpdwDisposition As Long _
  ) As Long
  
  Declare PtrSafe Function RegOpenKeyEx Lib "advapi32.dll" Alias "RegOpenKeyExA" ( _
      ByVal hKey As Long, _
      ByVal lpSubKey As String, _
      ByVal ulOptions As Long, _
      ByVal samDesired As Long, _
      phkResult As Long _
  ) As Long
  
  Declare PtrSafe Function RegQueryValueExString Lib "advapi32.dll" Alias "RegQueryValueExA" ( _
      ByVal hKey As Long, _
      ByVal lpValueName As String, _
      ByVal lpReserved As Long, _
      lpType As Long, _
      ByVal lpData As String, _
      lpcbData As Long _
  ) As Long
  
  Declare PtrSafe Function RegQueryValueExLong Lib "advapi32.dll" Alias _
  "RegQueryValueExA" (ByVal hKey As Long, ByVal lpValueName As _
  String, ByVal lpReserved As Long, lpType As Long, lpData As _
  Long, lpcbData As Long) As Long
  
  Declare PtrSafe Function RegQueryValueExNULL Lib "advapi32.dll" Alias _
  "RegQueryValueExA" (ByVal hKey As Long, ByVal lpValueName As _
  String, ByVal lpReserved As Long, lpType As Long, ByVal lpData _
  As Long, lpcbData As Long) As Long
  
  Declare PtrSafe Function RegSetValueExString Lib "advapi32.dll" Alias _
  "RegSetValueExA" (ByVal hKey As Long, ByVal lpValueName As String, _
  ByVal Reserved As Long, ByVal dwType As Long, ByVal lpValue As _
  String, ByVal cbData As Long) As Long
  
  Declare PtrSafe Function RegSetValueExLong Lib "advapi32.dll" Alias _
  "RegSetValueExA" (ByVal hKey As Long, ByVal lpValueName As String, _
  ByVal Reserved As Long, ByVal dwType As Long, lpValue As Long, _
  ByVal cbData As Long) As Long

  Private Declare PtrSafe Function SHDeleteKey Lib "shlwapi.dll" Alias "SHDeleteKeyA" (ByVal hKey As Long, ByVal pszSubKey As String) As Long
#Else
  Declare Function RegCloseKey Lib "advapi32.dll" ( _
      ByVal hKey As Long _
  ) As Long
  
  Declare Function RegCreateKeyEx Lib "advapi32.dll" Alias "RegCreateKeyExA" ( _
      ByVal hKey As Long, _
      ByVal lpSubKey As String, _
      ByVal Reserved As Long, _
      ByVal lpClass As String, _
      ByVal dwOptions As Long, _
      ByVal samDesired As Long, _
      ByVal lpSecurityAttributes As Long, _
      phkResult As Long, _
      lpdwDisposition As Long _
  ) As Long
  
  Declare Function RegOpenKeyEx Lib "advapi32.dll" Alias "RegOpenKeyExA" ( _
      ByVal hKey As Long, _
      ByVal lpSubKey As String, _
      ByVal ulOptions As Long, _
      ByVal samDesired As Long, _
      phkResult As Long _
  ) As Long
  
  Declare Function RegQueryValueExString Lib "advapi32.dll" Alias "RegQueryValueExA" ( _
      ByVal hKey As Long, _
      ByVal lpValueName As String, _
      ByVal lpReserved As Long, _
      lpType As Long, _
      ByVal lpData As String, _
      lpcbData As Long _
  ) As Long
  
  Declare Function RegQueryValueExLong Lib "advapi32.dll" Alias _
  "RegQueryValueExA" (ByVal hKey As Long, ByVal lpValueName As _
  String, ByVal lpReserved As Long, lpType As Long, lpData As _
  Long, lpcbData As Long) As Long
  
  Declare Function RegQueryValueExNULL Lib "advapi32.dll" Alias _
  "RegQueryValueExA" (ByVal hKey As Long, ByVal lpValueName As _
  String, ByVal lpReserved As Long, lpType As Long, ByVal lpData _
  As Long, lpcbData As Long) As Long
  
  Declare Function RegSetValueExString Lib "advapi32.dll" Alias _
  "RegSetValueExA" (ByVal hKey As Long, ByVal lpValueName As String, _
  ByVal Reserved As Long, ByVal dwType As Long, ByVal lpValue As _
  String, ByVal cbData As Long) As Long
  
  Declare Function RegSetValueExLong Lib "advapi32.dll" Alias _
  "RegSetValueExA" (ByVal hKey As Long, ByVal lpValueName As String, _
  ByVal Reserved As Long, ByVal dwType As Long, lpValue As Long, _
  ByVal cbData As Long) As Long

  Private Declare Function SHDeleteKey Lib "shlwapi.dll" Alias "SHDeleteKeyA" (ByVal hKey As Long, ByVal pszSubKey As String) As Long
#End If


Public Function SetValueEx( _
    ByVal hKey As Long, _
    sValueName As String, _
    lType As Long, _
    vValue As Variant _
) As Long

'*** Called By: SetKeyValue
'*** Description: Wrapper function around the registry API calls
'*** RegSetValueExString/Long. Determines if the value
'*** is a string or a long and calls the appropriate API.
'*** Return Value: Returns the API call's return value, which is its
'*** status (successful, error).

Dim lValue As Long
Dim sValue As String

    Select Case lType
        '***String
        Case REG_SZ
            sValue = vValue
            SetValueEx = RegSetValueExString(hKey, sValueName, 0&, lType, sValue, Len(sValue))
        '***32-bit number
        Case REG_DWORD
            lValue = vValue
            SetValueEx = RegSetValueExLong(hKey, sValueName, 0&, lType, lValue, 4)
    End Select
    
End Function

Private Function QueryValueEx( _
    ByVal lhKey As Long, _
    ByVal szValueName As String, _
    vValue As Variant _
) As Long

'*** Called By: QueryValue
'*** Description: Wrapper function around the registry API calls to
'*** RegQueryValueExLong and RegQueryValueExString.
'*** Determines size and type of data to be read.
'*** Determines if the value is a string or a long
'*** and calls the appropriate API.
'*** Return Value: Returns the API call's return value, which is its
'*** status (successful, error). The parameter vValue
'*** contains the value queried.

Dim cch As Long
Dim lrc As Long
Dim lType As Long
Dim lValue As Long
Dim sValue As String

On Error GoTo QueryValueExError

    ' Determine the size and type of data to be read
    lrc = RegQueryValueExNULL(lhKey, szValueName, 0&, lType, 0&, cch)
    
    If lrc <> ERROR_NONE Then Error 5
    
    Select Case lType
        ' For strings
        Case REG_SZ:
            sValue = String(cch, 0)
            lrc = RegQueryValueExString(lhKey, szValueName, 0&, lType, sValue, cch)
            If lrc = ERROR_NONE Then
                If Mid(sValue, cch, 1) = Chr(0) Then
                vValue = Left$(sValue, cch - 1) ' get rid of trailing AsciiZ
            Else
                vValue = Left$(sValue, cch)
            End If
            Else
                vValue = Empty
            End If
            ' For DWORDS
        Case REG_DWORD:
            lrc = RegQueryValueExLong(lhKey, szValueName, 0&, lType, lValue, cch)
            If lrc = ERROR_NONE Then vValue = lValue
        Case Else
            'all other data types not supported
            lrc = -1
    End Select

QueryValueExExit:
QueryValueEx = lrc

Exit Function

QueryValueExError:
    Resume QueryValueExExit ' Hmmmm
End Function

Public Sub CreateNewKey(sNewKeyName As String, lPredefinedKey As Long)
'***With this procedure a call of
'*** CreateNewKey "TestKey", HKEY_CURRENT_USER
'***will create a key called TestKey immediately under HKEY_CURRENT_USER.
'***Calling CreateNewKey like this
'*** CreateNewKey "TestKey\SubKey1\SubKey2", HKEY_CURRENT_USER
'***will create a three-nested keys beginning with TestKey immediately under
'***HKEY_CURRENT_USER, Subkey1 subordinate to TestKey, and SubKey3 under
'***SubKey2.

'*** Called by: your own code to create keys
'*** Description: Wrapper around the RegCreateKeyEx API call.

Dim hNewKey As Long 'handle to the new key
Dim lRetVal As Long 'result of the RegCreateKeyEx function

    lRetVal = RegCreateKeyEx( _
        lPredefinedKey, _
        sNewKeyName, _
        0&, _
        vbNullString, _
        REG_OPTION_NON_VOLATILE, _
        KEY_ALL_ACCESS, _
        0&, _
        hNewKey, _
        lRetVal _
    )
    
    RegCloseKey hNewKey

End Sub

Public Sub SetKeyValue( _
    ByVal lpParentKey As Long, _
    sKeyName As String, _
    sValueName As String, _
    vValueSetting As Variant, _
    lValueType As Long _
)

'*** Called By: Your code when you want to set a KeyValue
'*** Description: Opens the key you want to set, calls the wrapper
'*** function SetValueEx, and closes key.
'*** ADD ERROR HANDLING!!

Dim lRetVal As Long 'result of the SetValueEx function
Dim hKey As Long 'handle of open key

    'open the specified key
    lRetVal = RegOpenKeyEx(lpParentKey, sKeyName, 0, KEY_ALL_ACCESS, hKey)
    ' write the value
    lRetVal = SetValueEx(hKey, sValueName, lValueType, vValueSetting)
    ' close the key
    RegCloseKey (hKey)
    
End Sub
Public Function QueryValue( _
    ByVal lpParentKey As Long, _
    sKeyName As String, _
    sValueName As String _
) As Variant

'*** Called By: Your code when you want to set a read a KeyValue
'*** Description: Opens the key you want to set, calls the wrapper
'*** function QueryValueEx, closes key.
'*** Return Value: The value you are querying
'*** ADD ERROR HANDLING!!

Dim lRetVal As Long 'result of the API functions
Dim hKey As Long 'handle of opened key
Dim vValue As Variant 'setting of queried value

    ' open the key
    lRetVal = RegOpenKeyEx(lpParentKey, sKeyName, 0, KEY_ALL_ACCESS, hKey)
    ' get the value
    lRetVal = QueryValueEx(hKey, sValueName, vValue)
    ' close the key
    RegCloseKey (hKey)
    
    QueryValue = vValue
    
End Function

Public Sub TestRegModule()

'
' This procedure demonstrates the use of this module
' All code below here is demo code
'
    CreateKeyDriver
    Debug.Print "Created key Cosmic Example and TestVals"
    
    SetStringValueDriver
    Debug.Print "Created the TestStringVal"
    
    SetNumberValueDriver
    Debug.Print "Created the TestNumVal"
    
    ReadValueDriver

End

End Sub

Sub CreateKeyDriver()

'
' demo code
'

'*** Calls the CreateNewKey procedure
'*** Description: Creates Cosmic Example key and TestVals subkey under
'*** HKEY_CURRENT_USER\Software\VB and VBA Program Settings
'*** If Software and/or VB and VBA Program Settings do not
'*** exist, they are created.
'*** Usage: Use this as an example of how you would use the CreateNewKey
'*** procedure.

Dim sNewKey As String
Dim lPredefinedKeyValue As Long

    sNewKey = "Software\VB and VBA Program Settings\Cosmic Example\TestVals"
    lPredefinedKeyValue = HKEY_CURRENT_USER
    
    CreateNewKey sNewKey, lPredefinedKeyValue
    
End Sub

Sub SetStringValueDriver()

'
' demo code
'

'*** Calls the SetKeyValue procedure
'*** Description: Sets the value TestStringVal under the
'*** Cosmic Example\TestVals key and sets it to
'*** VB App Created. If it doesn't exist, it creates it.
'*** Usage: Use this as an example of how you would use the SetKeyValue
'*** procedure.

Dim sKey As String '***Key under which to create the value
Dim sValue As String '***Value name to set
Dim vSetting As Variant '***What to set the Value to
Dim sType As Long '***Value type -- string or number

    sKey = "Software\VB and VBA Program Settings\Cosmic Example\TestVals"
    sValue = "TestStringVal"
    vSetting = "VB App Created"
    sType = REG_SZ

    SetKeyValue HKEY_CURRENT_USER, sKey, sValue, vSetting, sType

End Sub
Sub SetNumberValueDriver()

'
' demo code
'

'*** Calls the SetKeyValue procedure
'*** Description: Sets the value TestNumVal under the
'*** Cosmic Example\TestVals key and sets it to 5.
'*** If it doesn't exist, it creates it.
'*** Usage: Use this as an example of how you would use the SetKeyValue
'*** procedure.

Dim sKey As String '***Key under which to create the value
Dim sValue As String '***Value name to set
Dim vSetting As Variant '***Wht to set the Value to
Dim sType As Long '***Value type -- string or number

    sKey = "Software\VB and VBA Program Settings\Cosmic Example\TestVals"
    sValue = "TestNumVal"
    vSetting = 5
    sType = REG_DWORD
    
    SetKeyValue HKEY_CURRENT_USER, sKey, sValue, vSetting, sType

End Sub

Sub ReadValueDriver()

'
' demo code
'

'*** Calls the QueryValue function
'*** Description: Reads the value TestNumVal and TestStringVal under
'*** the Cosmic Example\TestVals key.
'*** Usage: Use this as an example of how you would use the QueryValue
'*** procedure.

Dim sKey As String '***Key under which to create the value
Dim sValue As String '***Value name to set
Dim vSetting As Variant

    sKey = "Software\VB and VBA Program Settings\Cosmic Example\TestVals"
    sValue = "TestStringVal"
    
    '***Read the String value
    vSetting = QueryValue(HKEY_CURRENT_USER, sKey, sValue)
    Debug.Print "TestStringVal is " & vSetting
    
    sValue = "TestNumVal"
    '***Read the number value
    vSetting = QueryValue(HKEY_CURRENT_USER, sKey, sValue)
    Debug.Print "TestNumVal is " & vSetting

End Sub

Sub TestKey()
  
  CreateNewKey "Software\Microsoft\Office\12.0\Excel\Options", HKEY_CURRENT_USER
  SetKeyValue HKEY_CURRENT_USER, "Software\Microsoft\Office\12.0\Excel\Options", "NoShowCnvMsg", 1, REG_DWORD
  Debug.Print "Test:" & QueryValue(HKEY_CURRENT_USER, "Software\Microsoft\Office\12.0\Excel\Options", "NoShowCnvMsg")
End Sub

Function RegBinaryToLong(arrValue, pos)
  Dim l As Long
  
  l = arrValue(pos)
  l = l + arrValue(pos + 1) * 256
  l = l + arrValue(pos + 2) * 256 * 256
  l = l + arrValue(pos + 3) * 256 * 256 * 256
  RegBinaryToLong = l
End Function

Function RegBinaryToStringPos(arrValue, pos, l)
  Dim strInfo As String
  strInfo = ""
  Dim i As Long
  For i = pos To pos + l - 1
   If arrValue(i) <> 0 Then strInfo = strInfo & Chr(arrValue(i))
  Next
 RegBinaryToStringPos = strInfo
End Function

Sub DeleteResilience(vernr, officeapp)
    Dim hDefKey
    Dim strSubKeyPath As String
    Dim oReg As Object
    Dim i As Long
    Dim arrValueNames ' As Object
    Dim arrTypes ' As Object
    Dim arrBytes ' As Object
    Dim strValueName ' As String
    Dim l As Long
    Dim t As String
    Dim l2 As Long
    Dim t2 As String
    
    Dim sec As String
    Dim root As String
    Dim Key As String
    Dim areaKey As Long
    
    
    hDefKey = HKEY_CURRENT_USER
    strSubKeyPath = "Software\Microsoft\Office\" & vernr & ".0\" & officeapp & "\Resiliency\DisabledItems"
    Set oReg = GetObject("winmgmts:{impersonationLevel=impersonate}!\\.\root\default:StdRegProv")
    oReg.EnumValues hDefKey, strSubKeyPath, arrValueNames, arrTypes
  
    If Not IsNull(arrValueNames) Then
        For i = LBound(arrValueNames) To UBound(arrValueNames)
      
          strValueName = arrValueNames(i)
      
          Select Case arrTypes(i)
            Case REG_BINARY
              oReg.GetBinaryValue hDefKey, strSubKeyPath, strValueName, arrBytes
              l = RegBinaryToLong(arrBytes, 4)
              t = UCase(RegBinaryToStringPos(arrBytes, 12, l))
              l2 = RegBinaryToLong(arrBytes, 8)
              t2 = UCase(RegBinaryToStringPos(arrBytes, 12 + l, l2))
              
              If InStr(t, "EXCELTRACKER") > 0 Or InStr(t2, "EXCELTRACKER") > 0 Or InStr(t, "ACCESSTRACKER") > 0 Or InStr(t2, "ACCESSTRACKER") > 0 Or _
     InStr(t, "EXCEL-SHEET-CHECKER") > 0 Or InStr(t2, "EXCEL-SHEET-CHECKER") > 0 Or InStr(t, "ACCESS-CHECKER") > 0 Or InStr(t2, "ACCESS-CHECKER") > 0 Or _
     InStr(t, "EXCEL-FILE-COMPARE") > 0 Or InStr(t2, "EXCEL-FILE-COMPARE") > 0 Or InStr(t, "EXCEL-SHEET-QA") > 0 Or InStr(t2, "EXCEL-SHEET-QA") > 0 Or _
     InStr(t, "EXCELPROTECT") > 0 Or InStr(t2, "EXCELPROTECT") > 0 Then
                oReg.DeleteValue hDefKey, strSubKeyPath, strValueName
              End If
          End Select
        Next
    End If

#If PROJECT_IDVSCHEDULER = 1 Then
    DeleteKeyAndSubkeys HKEY_CURRENT_USER, "Software\Microsoft\Office\" & vernr & ".0\" & officeapp & "\Resiliency\DocumentRecovery"
#End If

End Sub


' =====================================================================
' Clear Resilience
' =====================================================================
Sub ClearResilience()
On Error Resume Next
Dim i As Long
For i = 10 To 18
   DeleteResilience i, "Excel"
   DeleteResilience i, "Access"
Next

End Sub


Private Sub DeleteKeyAndSubkeys(ByVal root As Long, ByVal Key As String)
    Const ERROR_SUCCESS = 0&
    Const KEY_ALL_ACCESS = &H3F
    Dim strKey As String
    Dim lngPos As Long
    Dim lngHandle As Long

    lngPos = InStrRev(Key, "\")
    If lngPos = 0 Then
        strKey = Key
        Key = ""
    Else
        strKey = Mid$(Key, lngPos + 1)
        Key = Left$(Key, lngPos - 1)
    End If
    If RegOpenKeyEx(root, Key, 0&, KEY_ALL_ACCESS, lngHandle) = ERROR_SUCCESS Then
        SHDeleteKey lngHandle, strKey
        RegCloseKey lngHandle
    End If

End Sub



Attribute VB_Name = "RemovePassword"
Option Explicit

Dim LastPassword As String
Const EncodeString As String = "AbC37cGh!%9sdfP'#N'S'|fffd||fffd|PI|fffd|ip|fffd|ff034(=4324f"

Function DecodePassword(s As String)
  Dim i As Long
  Dim Ret As String
  Dim t As String
  Dim pos As Long
  pos = 1
  i = 1
  Do While pos > 0
    t = GetNextText(s, pos)
    If Len(t) > 0 Then
      Ret = Ret & Chr(Val(t) Xor Asc(Mid(EncodeString, i, 1)))
    End If
    i = i + 1
  Loop
  
  DecodePassword = Ret
  
End Function

Sub StorePasswordToFile(s As String)

  AddPasswort s
  
  Dim FileNumber

'  FileNumber = FreeFile
'  Do
'    Err.Clear
'    Open g_cfgPasswortpfad & "\ECCPW.bin" For Append As #FileNumber   ' Create file name.
'  Loop While Err.Number <> 0
'  Write #FileNumber, LastPassword
'  Close #FileNumber

  FileNumber = FreeFile
  On Error Resume Next
  
  
  Err.Clear
  Open G_cfgPasswortpfad & "\ECCPW.bin" For Append As #FileNumber    ' Create file name.
  If Err.Number <> 0 Then
    Exit Sub
  End If
  
  Dim enc As String
  Dim i As Long
  For i = 1 To Len(s)
    If Len(enc) > 0 Then
      enc = enc & "," & CStr(Asc(Mid(s, i, 1)) Xor Asc(Mid(EncodeString, i, 1)))
    Else
      enc = CStr(Asc(Mid(s, i, 1)) Xor Asc(Mid(EncodeString, i, 1)))
    End If
  Next i
  
  Write #FileNumber, enc
  Close #FileNumber

End Sub

Sub RemovePWWorkbook(oxlwbook As Excel.Workbook)
  
  If oxlwbook.ProtectStructure = False And oxlwbook.ProtectWindows = False Then
    Exit Sub
  End If
  
  On Error Resume Next
  Dim Pwc As Long
  
  'AddStatus "Entferne Passwort aus Excel-Mappe"
  AddStatus FMT0("REMOVEPWD_16")
  If Len(LastPassword) > 0 Then
    oxlwbook.Unprotect LastPassword
    If oxlwbook.ProtectStructure = False And oxlwbook.ProtectWindows = False Then
        If AR_UseDB Then
          TrackerStorePassword "#Workbook", LastPassword
        End If
        'UpdateStatus "Entferne Passwort aus Excel-Mappe - Fertig!"
        UpdateStatus FMT0("REMOVEPWD_1")
        Exit Sub
    End If
  End If
  
  
  Dim pwCnt As Long
  For pwCnt = 1 To G_Passworte.count
    oxlwbook.Unprotect G_Passworte(pwCnt)
    If oxlwbook.ProtectStructure = False And oxlwbook.ProtectWindows = False Then
      If AR_UseDB Then
        TrackerStorePassword "#Workbook", G_Passworte(pwCnt)
      End If
      'UpdateStatus "Entferne Passwort aus Excel-Mappe - Fertig!"
      UpdateStatus FMT0("REMOVEPWD_1")
      Exit Sub
    End If
  Next pwCnt

  Dim a(0 To 17) As Byte, i&, K%, b
  For i = 0 To 2 ^ 17
      For K = 0 To 17
          a(17 - K) = Asc(CStr(Abs((i And 2 ^ K) = 0)))
      Next
      Pwc = Pwc + 1
      If Pwc Mod 500 = 0 Then
        SetLiveStatus
        DoEvents
      End If
      If Pwc Mod 1000 = 0 Then
        'UpdateStatus "Entferne Passwort aus Excel-Mappe (" & Pwc & " Versuche)"
        UpdateStatus FMT1("REMOVEPWD_2", Pwc)
      End If
      oxlwbook.Unprotect StrConv(a, vbUnicode)
      If oxlwbook.ProtectStructure = False And oxlwbook.ProtectWindows = False Then
        LastPassword = StrConv(a, vbUnicode)
        'UpdateStatus "Entferne Passwort aus Excel-Mappe - Fertig! (" & Pwc & " Versuche)"
        UpdateStatus FMT1("REMOVEPWD_3", Pwc)
        If AR_UseDB Then
          TrackerStorePassword "#Workbook", LastPassword
        End If
        StorePasswordToFile LastPassword
        Exit Sub
      End If
  Next


  'UpdateStatus "Entferne Passwort aus Excel-Mappe (Fehlgeschlagen)"
  UpdateStatus FMT0("REMOVEPWD_4")

End Sub

Sub RemovePW(oxlwsheet As Excel.Worksheet)
  On Error Resume Next
  Dim Pwc As Long
  
  oxlwsheet.Activate
  
  If oxlwsheet.ProtectContents = False Then
    'UpdateStatus "Tabelle '" & oXLWsheet.name & "' ungesch|fffd|tzt!"
    UpdateStatus FMT1("REMOVEPWD_5", oxlwsheet.name)
    Exit Sub
  End If
  
  'UpdateStatus "Entferne Passwort aus Tabelle '" & oXLWsheet.name & "'"
  UpdateStatus FMT1("REMOVEPWD_6", oxlwsheet.name)
  If Len(LastPassword) > 0 Then
    oxlwsheet.Unprotect LastPassword
    If oxlwsheet.ProtectContents = False Then
        If AR_UseDB Then
          TrackerStorePassword oxlwsheet.name, LastPassword
        End If
        'UpdateStatus "Entferne Passwort aus Tabelle '" & oXLWsheet.name & "' - Fertig!"
        UpdateStatus FMT1("REMOVEPWD_7", oxlwsheet.name)
        Exit Sub
    End If
  End If
  
  Dim pwCnt As Long
  For pwCnt = 1 To G_Passworte.count
      oxlwsheet.Unprotect G_Passworte(pwCnt)
      If oxlwsheet.ProtectContents = False Then
        If AR_UseDB Then
          TrackerStorePassword oxlwsheet.name, G_Passworte(pwCnt)
        End If
        'UpdateStatus "Entferne Passwort aus Tabelle '" & oXLWsheet.name & "' - Fertig!"
        UpdateStatus FMT1("REMOVEPWD_7", oxlwsheet.name)
        Exit Sub
      End If
  Next pwCnt

  Dim a(0 To 17) As Byte, i&, K%, b
  For i = 0 To 2 ^ 17
      For K = 0 To 17
          a(17 - K) = Asc(CStr(Abs((i And 2 ^ K) = 0)))
      Next
      Pwc = Pwc + 1
      If Pwc Mod 500 = 0 Then
        SetLiveStatus
        DoEvents
      End If
      If Pwc Mod 1000 = 0 Then
        'UpdateStatus "Entferne Passwort aus Tabelle '" & oXLWsheet.name & "' (" & Pwc & " Versuche)"
        UpdateStatus FMT2("REMOVEPWD_8", oxlwsheet.name, Pwc)
        SetLiveStatus
      End If
      oxlwsheet.Unprotect StrConv(a, vbUnicode)
      If oxlwsheet.ProtectContents = False Then
        LastPassword = StrConv(a, vbUnicode)
        'UpdateStatus "Entferne Passwort aus Tabelle '" & oXLWsheet.name & "' - Fertig! (" & Pwc & " Versuche)"
        UpdateStatus FMT2("REMOVEPWD_9", oxlwsheet.name, Pwc)
        If AR_UseDB Then
          TrackerStorePassword oxlwsheet.name, LastPassword
        End If
        StorePasswordToFile LastPassword
        Exit Sub
      End If
  Next


  'UpdateStatus "Entferne Passwort aus Tabelle '" & oXLWsheet.name & "' (Fehlgeschlagen)"
  UpdateStatus FMT1("REMOVEPWD_10", oxlwsheet.name)

End Sub

Sub TestRemovePWVBA()
  RemovePWVBA Workbooks("PWCrack.xls")
End Sub

Sub CheckVBAPassword(oxlwbook As Workbook, PW As String)

  oxlwbook.Activate
  
'  Application.EnableEvents = True
  If Left(Application.Version, 3) = "8.0" Then
'    SendKeys "%{F11}%Xs{TAB 9}{RIGHT}{tab}a{tab}" & tpassword & "{TAB}" & tpassword & "{tab}{enter}%q", True
    SendKeys "%{F11}%Xs" & PW & "{enter}{esc}{esc}%{F4}", True
  ElseIf Left(Application.Version, 3) = "9.0" Then
'    SendKeys "%xkv%xi{TAB 9}{RIGHT}{tab}a{tab}" & tpassword & "{TAB}" & tpassword & "{tab}{enter}%q", True
    SendKeys "%xkv%xi" & PW & "{enter}{esc}{esc}%{F4}", True
  ElseIf Left(Application.Version, 4) = "10.0" Then
'    SendKeys "%xkv%xi{TAB 9}{RIGHT}{tab}a{tab}" & tpassword & "{TAB}" & tpassword & "{tab}{enter}%q", True
    SendKeys "%xkv%xi" & PW & "{enter}{esc}{esc}%{F4}", True
  End If
'  Application.EnableEvents = False
  
End Sub
  

Sub RemovePWVBA(oxlwbook As Excel.Workbook)
  On Error Resume Next
  Dim Pwc As Long
  
  If oxlwbook.VBProject.Protection <> 1 Then
    'UpdateStatus "VBA ungesch|fffd|tzt!"
    UpdateStatus FMT0("REMOVEPWD_11")
    Exit Sub
  End If
  
'  oxlwbook.Application.ScreenUpdating = False
   
  If Len(LastPassword) > 0 Then CheckVBAPassword oxlwbook, LastPassword
  
  'UpdateStatus "Entferne VBA-Passwort aus Projekt"
  UpdateStatus FMT0("REMOVEPWD_17")
  If oxlwbook.VBProject.Protection <> 1 Then
        If AR_UseDB Then
          TrackerStorePassword "#VBA", LastPassword
        End If
      'UpdateStatus "Entferne VBA-Passwort aus Projekt - Fertig!"
      UpdateStatus FMT0("REMOVEPWD_12")
'      oxlwbook.Application.ScreenUpdating = True
      Exit Sub
  End If
  
  Dim pwCnt As Long
  For pwCnt = 1 To G_Passworte.count
      CheckVBAPassword oxlwbook, G_Passworte(pwCnt)
      If oxlwbook.VBProject.Protection <> 1 Then
        If AR_UseDB Then
          TrackerStorePassword "#VBA", G_Passworte(pwCnt)
        End If
        'UpdateStatus "Entferne VBA-Passwort aus Projekt - Fertig!"
        UpdateStatus FMT0("REMOVEPWD_12")
'        oxlwbook.Application.ScreenUpdating = True
        Exit Sub
      End If
  Next pwCnt

  Dim a(0 To 17) As Byte, i&, K%, b
  For i = 0 To 2 ^ 17
      For K = 0 To 17
          a(17 - K) = Asc(CStr(Abs((i And 2 ^ K) = 0)))
      Next
      Pwc = Pwc + 1
      If Pwc Mod 500 = 0 Then
        SetLiveStatus
        DoEvents
      End If
      If Pwc Mod 1000 = 0 Then
        'UpdateStatus "Entferne VBA-Passwort aus Projekt (" & Pwc & " Versuche)"
        UpdateStatus FMT1("REMOVEPWD_13", Pwc)
      End If
      
      CheckVBAPassword oxlwbook, StrConv(a, vbUnicode)
'      SendKeys StrConv(a, vbUnicode) & "{enter}", True
      If oxlwbook.VBProject.Protection <> 1 Then
        LastPassword = StrConv(a, vbUnicode)
        'UpdateStatus "Entferne VBA-Passwort aus Projekt - Fertig! (" & Pwc & " Versuche)"
        UpdateStatus FMT1("REMOVEPWD_14", Pwc)
        If AR_UseDB Then
          TrackerStorePassword "#VBA", LastPassword
        End If
        StorePasswordToFile LastPassword
'        oxlwbook.Application.ScreenUpdating = True
        Exit Sub
      End If
  Next

  'UpdateStatus "Entferne VBA-Passwort aus Projekt (Fehlgeschlagen)"
  UpdateStatus FMT0("REMOVEPWD_15")

'  oxlwbook.Application.ScreenUpdating = True

End Sub

Sub TrackerStorePassword(n As String, v As String)

  If Not theTrackerPasswordLog Then Exit Sub

  Dim rs As Object
  On Error Resume Next
'  If Err.Number <> 0 Then Exit Sub
  If G_conn Is Nothing Then Exit Sub
  
  Set rs = CreateObject("ADODB.recordset")
  rs.Open "SELECT * FROM ECCPasswort where idvDateiID = - 1", G_conn, 2, 3
  rs.AddNew
  rs.Fields("idvDateiID").value = theidvDateiID
  rs.Fields("Datum").value = MyFileDateTime(theFilename)
  rs.Fields("Name").value = Left(n, 20)
  rs.Fields("Wert").value = Left(v, 18)
  rs.Update
  rs.Close
  Set rs = Nothing

End Sub


Sub AddPasswort(PW As String)
  On Error Resume Next
  G_Passworte.Add PW, PW
End Sub

Sub GetPasswoerter()
  On Error Resume Next ' Damit wir auch sch|fffd|n doppelte Passw|fffd|rter ignorieren k|fffd|nnen
  Set G_Passworte = New Collection
  
  ' Passw|fffd|rter aus der Datenbank holen
  
  If AR_UseDB Then
    Dim rs As Object
    On Error Resume Next
  '  If Err.Number <> 0 Then Exit Sub
    Set rs = CreateObject("ADODB.recordset")
    rs.Open "SELECT Wert FROM ECCPasswort GROUP BY Wert", G_conn, MYadOpenDynamic, MYadLockReadOnly
    
    Do While Not rs.EOF
      G_Passworte.Add rs.Fields("Wert").value, rs.Fields("Wert").value
      rs.movenext
    Loop
    rs.Close
    Set rs = Nothing
  End If
  
  
  
  ' Nur die aus der Datei ECCPW.bin holen
  
  Dim MyIndex, FileNumber
  Dim tpw As String
  If FileExists(G_cfgPasswortpfad & "\ECCPW.bin") Then
    FileNumber = FreeFile
    Do
      Err.Clear
      Open G_cfgPasswortpfad & "\ECCPW.bin" For Input As #FileNumber   ' Create file name.
    Loop While Err.Number <> 0
    
    Do While Not EOF(FileNumber)
      Input #FileNumber, tpw
      If Len(tpw) = 0 Then Exit Do
      tpw = DecodePassword(tpw)
      G_Passworte.Add tpw, tpw
    Loop
    Close #FileNumber   ' Close file.
  End If
  
  
  
End Sub
Sub PrepareHighlyEncryptedCheck()

  If GetExcelVersion < 12 Then
    Exit Sub
  End If
  
  ' erst mal 7z ausprobieren
  If Test7z Then
    Exit Sub
  End If

  If G_HiglyEncryptedSheetPW > 0 Then Exit Sub
  
  If Not FileExists(ThisWorkbook.path & "\PWTester.xlsx") Then Exit Sub

  Workbooks.Open ThisWorkbook.path & "\PWTester.xlsx"

  On Error Resume Next
  
  Dim oldEnableEvents As Boolean
  oldEnableEvents = Application.EnableEvents
  Dim oldScreenUpdating As Boolean
  oldScreenUpdating = Application.ScreenUpdating
  
  Application.EnableEvents = False
  Application.ScreenUpdating = False
  
  Dim hrt As New HighResTimer
  Dim i As Long
  Dim cnt As Long
  cnt = 0
  
  hrt.StartCounting "PWTest"
  Do
    Workbooks("PWTester.xlsx").Sheets("Tabelle1").Unprotect "Test"
    cnt = cnt + 1
    If hrt.GetCurrentCount("PWTest") > 0.5 Then Exit Do
  Loop
  hrt.StopCounting "PWTest"
  
  G_HiglyEncryptedSheetPW = cnt
  Set hrt = Nothing
  
  Set hrt = New HighResTimer
  cnt = 0
  hrt.StartCounting "PWTest"
  Do
    Workbooks("PWTester.xlsx").Unprotect "Test"
    cnt = cnt + 1
    If hrt.GetCurrentCount("PWTest") > 0.5 Then Exit Do
  Loop
  hrt.StopCounting "PWTest"
  
  G_HiglyEncryptedWorkbookPW = cnt
  Set hrt = Nothing
  
  Application.EnableEvents = oldEnableEvents
  Application.ScreenUpdating = oldScreenUpdating
  
  Workbooks("PWTester.xlsx").Close
  
End Sub

Function IsHighlyEncrypted(wbname As String) As Boolean

  If GetExcelVersion < 12 Then
    IsHighlyEncrypted = False
    Exit Function
  End If

  On Error Resume Next
  
  If UCase(GetFileExtension(wbname)) <> "XLSX" And _
     UCase(GetFileExtension(wbname)) <> "XLSM" And _
     UCase(GetFileExtension(wbname)) <> "XLTX" And _
     UCase(GetFileExtension(wbname)) <> "XLTM" And _
     UCase(GetFileExtension(wbname)) <> "XLSB" And _
     UCase(GetFileExtension(wbname)) <> "XLAM" Then
     IsHighlyEncrypted = False
     Exit Function
  End If
  
  ' Wenn das WB nicht gesch|fffd|tzt ist brauch auch nix entsch|fffd|tzt zu werden
  If WorksheetsProtected(wbname) = False And WorkbookProtected(wbname) = False Then Exit Function

  If G_7ZAvailable Then
    IsHighlyEncrypted = True
    Exit Function
  End If
  
  Dim oldEnableEvents As Boolean
  oldEnableEvents = Application.EnableEvents
  Dim oldScreenUpdating As Boolean
  oldScreenUpdating = Application.ScreenUpdating
  
  Application.EnableEvents = False
  Application.ScreenUpdating = False
  
  
  IsHighlyEncrypted = False
  Dim hrt As HighResTimer
  Dim i As Long
  
  Dim ws
  
  For Each ws In Workbooks(wbname).Sheets
    If TypeName(ws) = "Worksheet" Then
      If SheetHasPassword(ws) Then
      Dim wsname As String
      wsname = ws.name
      
      Set hrt = New HighResTimer
      hrt.StartCounting "PWTest"
      
      For i = 1 To G_HiglyEncryptedSheetPW
        Workbooks(wbname).Sheets(wsname).Unprotect "X_!S"
        If hrt.GetCurrentCount("PWTest") > 0.5 And i * 4 < G_HiglyEncryptedSheetPW Then
          IsHighlyEncrypted = True
          Exit For
        End If
      Next i
      
      hrt.StopCounting "PWTest"
      Set hrt = Nothing
      
      If IsHighlyEncrypted = True Then Exit For
      End If
    End If
  Next ws
  
  If Not IsHighlyEncrypted Then
    If WorkbookHasPassword(Workbooks(wbname)) Then
      Set hrt = New HighResTimer
      hrt.StartCounting "PWTest"
      For i = 1 To G_HiglyEncryptedWorkbookPW
        Workbooks(wbname).Unprotect "Test_ABC_"
      
        If hrt.GetCurrentCount("PWTest") > 0.5 And i * 4 < G_HiglyEncryptedWorkbookPW Then
          IsHighlyEncrypted = True
          Exit For
        End If
      
      Next i
      hrt.StopCounting "PWTest"
      Set hrt = Nothing
    End If
  End If
  
  Application.EnableEvents = oldEnableEvents
  Application.ScreenUpdating = oldScreenUpdating
  
End Function


' xlOpenXMLAddIn = 55 Open XML-Add-In
' xlOpenXMLStrictWorkbook = 61 Strict Open XML-Datei
' xlOpenXMLTemplate = 54 Open XML-Vorlage
' xlOpenXMLTemplateMacroEnabled = 53 Open XML-Vorlagenmakro aktiviert
' xlOpenXMLWorkbook = 51 Open XML-Arbeitsmappe
' xlOpenXMLWorkbookMacroEnabled = 52 Open XML-Arbeitsmappenmakro aktiviert


Function GetHighlyEncryptedFiletype() As Long
  Select Case UCase(G_HighlyEncryptedFileExtension)
    Case "XLSB"
      GetHighlyEncryptedFiletype = 52 ' xlOpenXMLWorkbookMacroEnabled
      G_HighlyEncryptedFileExtension = "XLSM"
    Case "XLSX"
      GetHighlyEncryptedFiletype = 51 '
      G_HighlyEncryptedFileExtension = "XLSX"
    Case "XLSM"
      GetHighlyEncryptedFiletype = 52 ' xlOpenXMLWorkbookMacroEnabled
      G_HighlyEncryptedFileExtension = "XLSM"
    Case "XLTX"
      GetHighlyEncryptedFiletype = 54 '
      G_HighlyEncryptedFileExtension = "XLTX"
    Case "XLTM"
      GetHighlyEncryptedFiletype = 53 '
      G_HighlyEncryptedFileExtension = "XLTM"
    Case "XLAM"
      GetHighlyEncryptedFiletype = 55 '
      G_HighlyEncryptedFileExtension = "XLAM"
    Case Else
      GetHighlyEncryptedFiletype = 52 ' xlOpenXMLWorkbookMacroEnabled
      G_HighlyEncryptedFileExtension = "XLSM"
  End Select

End Function


Function CreateUnprotectedFile(ByVal wbname As String, filenamedest As String, ByVal tmppth As String) As Boolean
  ' erst mal die DAtei kopieren
  
  If GetExcelVersion < 12 Then
    CreateUnprotectedFile = False
    Exit Function
  End If
  
  AddStatus FMT0("REMOVEPWD_18")
  
On Error GoTo CleanUp
  Dim wb As Workbook
  Set wb = Workbooks(wbname)
  
  SetLiveStatus
  Dim alrt As Long
  alrt = Application.DisplayAlerts
  Application.DisplayAlerts = False
  
  Dim ftype As Long
  Dim newFileType As String
  ftype = GetHighlyEncryptedFiletype

  MyKill filenamedest & "." & G_HighlyEncryptedFileExtension & ".zip"
  wb.SaveAs filenamedest & "." & G_HighlyEncryptedFileExtension & ".zip", ftype, "" ' xlOpenXMLWorkbookMacroEnabled
  
  Application.DisplayAlerts = alrt
  
  SetLiveStatus
  wb.Close
  Set wb = Nothing
  DelTree tmppth & "\" & GetUserName & ".tmp"
  MkFullDir tmppth & "\" & GetUserName & ".tmp"
  SetLiveStatusFunc "SpecialCells", True
  ExtractZip filenamedest & "." & G_HighlyEncryptedFileExtension & ".zip", tmppth & "\" & GetUserName & ".tmp"
  SetLiveStatusFunc "SpecialCells", False
  SetLiveStatus
  
  Dim cFnames As Collection
  Set cFnames = New Collection
  
  Dim strFile As String
  strFile = Dir(tmppth & "\" & GetUserName & ".tmp\xl\worksheets\*.xml")
  Do While Len(strFile) > 0
      cFnames.Add strFile
      strFile = Dir
  Loop
  
  Dim i As Long
  If cFnames.count > 0 Then
    For i = 1 To cFnames.count
      RemoveTextInTextfile tmppth & "\" & GetUserName & ".tmp\xl\worksheets\" & cFnames(i), "<sheetProtection ", "/>"
    Next i
  End If
  Set cFnames = Nothing
  
  RemoveTextInTextfile tmppth & "\" & GetUserName & ".tmp\xl\workbook.xml", "<workbookProtection ", "/>"
  SetLiveStatus
  
  MyKill filenamedest & "." & G_HighlyEncryptedFileExtension & ".zip"
  SetLiveStatusFunc "SpecialCells", True
  If Not ZipFolder(tmppth & "\" & GetUserName & ".tmp", filenamedest & "." & G_HighlyEncryptedFileExtension & ".zip") Then
    GoTo CleanUp
  End If
  SetLiveStatusFunc "SpecialCells", False
  
  SetLiveStatus
  MyKill filenamedest & "." & G_HighlyEncryptedFileExtension
  
  Name filenamedest & "." & G_HighlyEncryptedFileExtension & ".zip" As filenamedest & "." & G_HighlyEncryptedFileExtension
  CreateUnprotectedFile = True
  
CleanUp:
  DelTree tmppth & "\" & GetUserName & ".tmp"
  Exit Function
End Function


Function RemoveTextInTextfile(ByVal strFile As String, ByVal startstring As String, ByVal endstring As String) As Boolean
  Dim pos1 As Long
  Dim pos2 As Long
  Dim tFile As String
  On Error GoTo binCheck
  tFile = ReadTextfile(strFile)
  If Len(tFile) > 0 Then
    pos1 = InStr(tFile, startstring)
    If pos1 > 0 Then
      pos2 = InStr(pos1, tFile, endstring)
      If pos2 > 0 Then
        tFile = Left(tFile, pos1 - 1) & Mid(tFile, pos2 + 2)
        MyKill strFile
        WriteTextfile strFile, tFile
      End If
    End If
    RemoveTextInTextfile = True
    Exit Function
  End If
  
binCheck:
  
  ' Mist, es gab nen error oder die Datei war leer, wahrscheinlich war die Datei zu gro|fffd|, zeilenweise vorgehen
 
  AddStatus "Pr|fffd|fe " & GetFileNameAndExtension(strFile)
  
  pos1 = SearchFileForText(strFile, startstring)
  If pos1 > 0 Then
    pos2 = SearchFileForText(strFile, endstring, pos1)
    If pos2 > 0 Then
      ReplaceFileChars strFile, pos1, pos2 - pos1 + 2
    End If
  End If
  RemoveTextInTextfile = True
End Function

Sub ReplaceFileChars(ByVal sFile As String, ByVal pos As Long, ByVal amnt As Long)
  
  Dim f As Integer
  Dim sTemp As String
  sTemp = Space$(amnt)
  
  f = FreeFile
  Open sFile For Binary Access Write As #f
  Seek #f, pos
  Put #f, , sTemp
  Close #f

End Sub
' Durchsucht eine Datei nach einem bestimmten Text
' und gibt die Position der Funstelle zur|fffd|ck,
' bzw. den Wert 0, wenn der Text nicht gefunden wurde
Public Function SearchFileForText(ByVal sFile As String, _
  ByVal sText As String, _
  Optional ByVal lngStart As Long = 1) As Long
 
  Dim f As Integer
  Dim lngStrLen As Long
  Dim lngFound As Long
  Dim lngFileSize As Long
  Dim lngFilePos As Long
  Dim lngReadSize As Long
  Dim sTemp As String
  Dim sPrev As String
  Dim intProz As Integer
  
  
  Dim lastproz As Integer
  lastproz = 0
 
  ' Gr|fffd||fffd|e eines einzelnen einzulesenden Datenblocks
  Const lngBlockSize = 8192
 
  ' L|fffd|nge des gesuchten Textes
  lngStrLen = Len(sText)
 
  ' Falls die Datei gar nicht existiert, oder der
  ' kein Suchtext angegeben wurde, wird die Funktion
  ' hier verlassen
  If Dir$(sFile) = "" Or lngStrLen = 0 Then Exit Function
 
  ' Datei im Bin|fffd|rmodus |fffd|ffnen
  f = FreeFile
  Open sFile For Binary As #f
 
  ' Gr|fffd||fffd|e der Datei
  lngFileSize = LOF(f)
 
  ' Start-Position
  If lngStart > 1 Then
    Seek #f, lngStart
    lngFilePos = lngStart - 1
  End If
 
  ' Solange "blockweise" einlesen, bis entweder das
  ' Dateiende erreicht oder der Text gefunden wurde
  While lngFilePos < lngFileSize And lngFound = 0
 
    If lngFilePos + lngBlockSize > lngFileSize Then
      ' Falls aktuelle Position + Blockgr|fffd||fffd|e |fffd|ber das
      ' Dateiende hinaus geht -> Blockgr|fffd||fffd|e neu festlegen
      ' (maximal bis Dateiende)
      lngReadSize = lngFileSize - lngFilePos
    Else
      ' ansonsten: festgelegte Blockgr|fffd||fffd|e einlesen
      lngReadSize = lngBlockSize
    End If
 
    ' Variable vorbereiten (mit Leerzeichen f|fffd|len)
    sTemp = Space$(lngReadSize)
 
    ' Datenblock einlesen (Gr|fffd||fffd|e = lngReadSize)
    Get #f, , sTemp
 
    ' die letzten Zeichen des vorigen Blocks nochmals
    ' mit in den Suchvorgang einbeziehen, denn es
    ' k|fffd|nnte ja sein, dass sich der gesuchte Text
    ' genau an zwischen dem letzten und dem aktuell
    ' eingelesenen Block befindet
    sTemp = sPrev + sTemp
 
    ' Ist der gesuchte Text enthalten?
    lngFound = InStr(sTemp, sText)
    If lngFound > 0 Then
      ' JA, Suchtext ist enthalten!
      ' Position ermitteln
      lngFound = lngFilePos + lngFound - Len(sPrev) ' lngStrLen
    End If
 
    ' aktuelle Position aktualisieren
    lngFilePos = lngFilePos + lngReadSize
 
    ' Fortschritt anzeigen
    intProz = Int(lngFilePos / lngFileSize * 100 + 0.5)
    If intProz >= lastproz + 5 Then
      lastproz = intProz
      UpdateStatus FMT2("REMOVEPWD_19", GetFileNameAndExtension(sFile), CStr(intProz))
    End If
    sPrev = Right$(sTemp, lngStrLen)
  Wend
 
  ' nachfolgender Code nur zu Testzwecken
  ' (einfach sp|fffd|ter dann auskommentieren)
  If lngFound > 0 Then
    sTemp = Space$(lngStrLen)
    Seek #f, lngFound
    Get #f, , sTemp
  End If
 
  ' Datei schliessen
  Close #f
 
  UpdateStatus FMT2("REMOVEPWD_19", GetFileNameAndExtension(sFile), "100")
  
  ' Funktionsr|fffd|ckgabewert: Fundstelle (Position)
  SearchFileForText = lngFound
End Function

Function WorksheetsProtected(ByVal wbname As String) As Boolean
  On Error GoTo nogo
  Dim w
  For Each w In Workbooks(wbname).Sheets
    With w
      If .ProtectContents = True Then
        WorksheetsProtected = True
        Exit Function
      End If
    End With
  Next w
  Exit Function
nogo:
End Function

Function WorkbookProtected(ByVal wbname As String) As Boolean
  If Workbooks(wbname).ProtectWindows = True Or Workbooks(wbname).ProtectStructure = True Then
    WorkbookProtected = True
  End If
End Function


Attribute VB_Name = "Result"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

' #Const DoProfile = True

Public Filename As String
Public Mode As Long

Public oxlwbook As Workbook
  ' Die Anzahl aller gefundenen Formeln
Public foundFormulaAmount        As Long
  ' Die Anzahl aller gefundenen Matrix-Funktionen
Public foundMatrixFuncs          As Long
  ' Die Anzahl aller replizierten Matrix-Funktionen
Public foundMatrixDuplicateFuncs As Long
  ' Die Anzahl aller gefundenen "gezogenen" Formeln
Public foundFormulaDuplicateAmount As Long
  ' Die Anzahl aller gefundener Summen
Public foundSumAmount            As Long
  ' Gezogene Summen
Public foundSumDuplicateAmount   As Long
  ' Die Anzahl aller gefundenen arithmetischen Formeln
Public foundCalcAmount           As Long
  ' Gezogenen arithmetische Funktionen
Public foundCalcDuplicateAmount    As Long
  ' Die Anzahl aller gefundenen unsichtbaren Spalten
Public foundHiddenColumnAmount   As Long
Public foundHiddenColumnAmountCount   As Long
  ' Die Anzahl aller gefundenen unsichtbaren Zeilen
Public foundHiddenRowAmount      As Long
Public foundHiddenRowAmountCount      As Long
  ' Die Anzahl aller gefundenen Formeln, die WENN-Bedingungen ethalten
Public foundIfAmount             As Long
  ' Gezogene If Bedingungen
Public foundIfDuplicateAmount    As Long
  ' Die Anzahl aller gefundenen Zellen mit Formeln, die
  ' keinen Zellschutz haben!
Public foundUnlockedFormulas     As Long
  ' Zellen, die zwar gesch|fffd|tzt sind (= locked), deren Schutz aber durch den fehlenden Blattschutz nicht
  ' aktiv ist!
Public foundLockedFormulasMissingSheetprotect As Long
  ' Zellen, die zwar gesch|fffd|tzt sind, deren Tabelle aber kein Passwort hat
Public foundLockedFormulasWithoutSheetpassword As Long
  ' Die Anzahl aller gefundenen Zellen mit Formeln, die
  ' keinen Zellschutz haben aber ausgeblendet sind!
Public foundUnlockedFormulasNotVisible     As Long
  ' Simple Formeln mit =1+4/3
Public foundNumberFormula As Long
  
  ' Alle versteckten Bl|fffd|tter
Public foundHiddenWorksheetsAmount     As Long
  ' Alle sehr versteckten Bl|fffd|tter
Public foundVeryHiddenWorksheetsAmount As Long
  ' Alle Code Module
Public foundCodeModules          As Long

' .NET START
Public foundLinesOfCode As Long
' .NET END


  ' Anzahl der Zellen in der Datei
Public totalCellAmount           As Long
  
  ' Anzahl der Zellen in einer Datei, die wirklich mit Text, Formeln o.|fffd|. belegt sind
Public totalUsedCellAmount       As Long
  
  ' Anzahl aller Zellen, die gepr|fffd|ft werden
Public totalWorkbookCheckAmount As Long
  
  ' Die Anzahl aller Zellen, die externe Dateien referenzieren
Public foundCellsWithExternalReferences As Long
  ' Die Anzahl aller Dateien, die referenziert werden
Public foundExternalReferences As Long
  
  ' Alle Formelzellen, die einen Fehler haben
Public foundNonAnalyzableCells As Long
  
  ' Alle diagramme
Public foundDiagrams As Long

' .NET START
Public foundQueries As Long
Public foundPivots As Long
' .NET END


Public foundHyperlinks As Long
Public foundInternalHyperlinks As Long
Public foundExternalHyperlinks As Long
  
  ' Checksumme f|fffd|r die Unver|fffd|nderbarkeit der Dateien
Public checksum As Long

  ' Collection, die aufnimmt, ob und wie die Sheets gesch|fffd|tzt waren
Public protectedSheetsColl As Collection

Public longestFormula As Long
Public maxopenbracam As Long

  ' Die Anzahl aller gesch|fffd|tzten Worksheets
Public protectedWorksheets As Long
Public unprotectedWorksheets As Long
Public protectedWorksheetsWithPassword As Long
Public crackedWorksheetsWithPassword As Long
Public protectedWorksheetsWithoutPassword As Long
  


Public m_Clones As Collection
Public m_FoundFuncs As Collection

Public wbvars As XLScriptArray2D
Public tabProt As Object
Public unlockedFormulaAreas As Object
Public errorFormulaCells As Object
Public errorFormulaValueCells As Object
Public hiddenSheets As Object
Public hiddenColumns As Object
Public hiddenRows As Object
Public hiddenColumnsRanges As Object
Public hiddenRowsRanges As Object
Public externalFiles As Object
Public missingexternalFiles As Object
Public mods As Object
Public sda As Object
Public dda As Object
' .NET START
Public queryda As Object
Public pivotda As Object
' .NET END
Public nonAnalyzableCells As Object
Public circref As XLScriptArray2D

Public foundCellreferencesAmount As Long
Public foundCellreferencesDuplicateAmount As Long



' -----------------------------------------------
' TAB Stuff
' -----------------------------------------------

  Public tabTotalUsedCellAmount As Long
  Public tabFoundFormulaAmount As Long
  Public tabFoundIfAmount As Long
  Public tabFoundCalcAmount As Long
  Public tabFoundSumAmount As Long
  Public tabFoundMatrixFuncs As Long
  Public tabFoundMatrixDuplicateFuncs As Long
  Public tabFoundUnlockedFormulas As Long
  Public tabFoundLockedFormulasMissingSheetprotect As Long
  Public tabFoundLockedFormulasWithoutSheetpassword As Long
  Public tabFoundUnlockedFormulasNotVisible As Long
  Public tabFoundHiddenColumnAmount As Long
  Public tabFoundHiddenRowAmount As Long
  Public tabFoundHiddenWorksheetsAmount As Long
  Public tabFoundVeryHiddenWorksheetsAmount As Long
  Public tabFoundCellsWithExternalReferences As Long
  Public tabFoundFormulaDuplicateAmount As Long
  Public tabFoundIfDuplicateAmount As Long
  Public tabfoundNumberFormula As Long
  Public tabFoundCalcDuplicateAmount As Long
  Public tabFoundSumDuplicateAmount As Long
  Public tabFoundDiagrams As Long
' .NET START
  Public tabFoundQueries As Long
  Public tabfoundPivots As Long
' .NET END
  Public tabFoundHyperlinks As Long
  Public tabFoundInternalHyperlinks As Long
  Public tabFoundExternalHyperlinks As Long
  Public tabFoundNonAnalyzableCells As Long
  Public tabLongestFormula As Long
  Public tabMaxopenbracam As Long
  Public tabFoundCellreferencesAmount As Long
  Public tabFoundCellreferencesDuplicateAmount As Long


  Public m_Dimension As Dimension
  Public m_TabDimension As Dimension
  
  Public m_CUnlockedFormulas As Collection
  Public m_CErrorFormulas As Collection
  Public m_CErrorFormulaValues As Collection

Function IsErrorItemValue(item) As Boolean
On Error GoTo yeserror
  Dim s As String
  s = CStr(item.value)
  IsErrorItemValue = False
  Exit Function

yeserror:
  IsErrorItemValue = True
End Function

Public Sub SetWB(owbook As Workbook)
  Set oxlwbook = owbook
End Sub
Public Sub InitWB(owbook As Workbook)
  Set oxlwbook = owbook

  Dim item
  
  Dim arr As XLScriptArray
  Set arr = wbvars.AddXLScriptArray("BUILTINPROPERTIES")
  For Each item In oxlwbook.BuiltinDocumentProperties
'    Debug.Print item.name
    If Not IsErrorItemValue(item) Then
      If Len(CStr(item.value)) > 0 Then
        If TextExists(item.name) Then
          'arr.AddNameAndValue STexte(item.name), CStr(item.value)
          arr.AddNameAndValue TranslateText(item.name), CStr(item.value)
        Else
          arr.AddNameAndValue item.name, CStr(item.value)
        End If
      End If
    End If
  Next item
    
  Set arr = wbvars.AddXLScriptArray("CUSTOMDOCUMENTPROPERTIES")
  For Each item In oxlwbook.CustomDocumentProperties
'    Debug.Print item.name
    If Not IsErrorItemValue(item) Then
      If Len(CStr(item.value)) > 0 Then
        If TextExists(item.name) Then
          'arr.AddNameAndValue STexte(item.name), CStr(item.value)
          arr.AddNameAndValue TranslateText(item.name), CStr(item.value)
        Else
          arr.AddNameAndValue item.name, CStr(item.value)
        End If
      End If
    End If
  Next item




End Sub

Public Sub Init(fname As String, m As Long)

  Filename = fname
  Mode = m
  
  Set m_Dimension = New Dimension
  Set m_TabDimension = New Dimension
  
  Set m_CUnlockedFormulas = New Collection
  Set m_CErrorFormulas = New Collection
  Set m_CErrorFormulaValues = New Collection
  
  m_Dimension.m_X = 0
  m_Dimension.m_Y = 0
  m_Dimension.m_XY = 0
  m_Dimension.m_Z = 0

  ' Initialisierung f|fffd|r Z|fffd|hlvariablen
  foundFormulaAmount = 0
  foundMatrixFuncs = 0
  foundMatrixDuplicateFuncs = 0
  foundFormulaDuplicateAmount = 0
  foundSumDuplicateAmount = 0
  foundCalcDuplicateAmount = 0
  foundIfDuplicateAmount = 0
  foundNumberFormula = 0
  ' Alle Summenformeln (z.B. =SUMME(A4:A7)
  foundSumAmount = 0
  ' Alle mathematischen Formeln (z.B. A3 + A5 * A9)
  foundCalcAmount = 0
  ' Versteckte Zeilen, Spalten und Tabellen
  foundHiddenColumnAmount = 0
  foundHiddenRowAmount = 0
  foundHiddenColumnAmountCount = 0
  foundHiddenRowAmountCount = 0
  foundUnlockedFormulas = 0
  foundLockedFormulasMissingSheetprotect = 0
  foundLockedFormulasWithoutSheetpassword = 0
  foundUnlockedFormulasNotVisible = 0
  foundHiddenWorksheetsAmount = 0
  foundVeryHiddenWorksheetsAmount = 0
  foundCellreferencesAmount = 0
  ' Code Module
  foundCodeModules = 0
' .NET START
  foundLinesOfCode = 0
' .NET END

  ' Wieviele Formeln mit WENN-Bedingungen gibt es
  foundIfAmount = 0
  
  ' Z|fffd|hler f|fffd|r externe Referenzen initialisieren
  foundCellsWithExternalReferences = 0
  foundExternalReferences = 0
  
  foundNonAnalyzableCells = 0
  
  ' Alles was mit Schutz zu tun hat
  protectedWorksheets = 0
  unprotectedWorksheets = 0
  protectedWorksheetsWithPassword = 0
  crackedWorksheetsWithPassword = 0
  protectedWorksheetsWithoutPassword = 0
  foundDiagrams = 0
' .NET START
  foundQueries = 0
  foundPivots = 0
' .NET END
  
  foundHyperlinks = 0
  foundInternalHyperlinks = 0
  foundExternalHyperlinks = 0

  
  checksum = 0
  
  ' Initialisierung Laufvariablen
  totalCellAmount = 0
  totalUsedCellAmount = 0
  totalWorkbookCheckAmount = 0
  
  longestFormula = 0
  maxopenbracam = 0
  


  Set protectedSheetsColl = New Collection
  
  Set m_Clones = New Collection
  Set m_FoundFuncs = New Collection

  ' --------------------------------------------------------
  ' Script Engine stuff
  ' --------------------------------------------------------

  ' SpecialCells Zeug
  XLScriptAddSimpleVar "NUMBERAMOUNT", ""
  XLScriptAddSimpleVar "TEXTAMOUNT", ""
  XLScriptAddSimpleVar "BOOLAMOUNT", ""
  XLScriptAddSimpleVar "FORMULANUMBERAMOUNT", ""
  XLScriptAddSimpleVar "FORMULATEXTAMOUNT", ""
  XLScriptAddSimpleVar "FORMULABOOLAMOUNT", ""
  XLScriptAddSimpleVar "FORMULAERRORAMOUNT", "0"
  XLScriptAddSimpleVar "FORMULAVALUEERRORAMOUNT", "0"
  XLScriptAddSimpleVar "ERRORNULLAM", "0"
  XLScriptAddSimpleVar "ERRORDIV0AM", "0"
  XLScriptAddSimpleVar "ERRORVALUEAM", "0"
  XLScriptAddSimpleVar "ERRORREFAM", "0"
  XLScriptAddSimpleVar "ERRORNAMEAM", "0"
  XLScriptAddSimpleVar "ERRORNUMAM", "0"
  XLScriptAddSimpleVar "ERRORNAAM", "0"
  XLScriptAddSimpleVar "VBAMODULEAMOUNT", 0
  XLScriptAddSimpleVar "LINESOFCODE", 0
  XLScriptAddSimpleVar "QUERYAMOUNT", 0
  XLScriptAddSimpleVar "PIVOTAMOUNT", 0
  XLScriptAddSimpleVar "NAMEAMOUNTINVISIBLE", 0
  XLScriptAddSimpleVar "NAMEAMOUNTVISIBLE", 0
  XLScriptAddSimpleVar "VBAPROTECTED", 0
  
  XLScriptAddSimpleVar "FILE", Filename
  XLScriptAddSimpleVar "NAME", Filename
  XLScriptAddSimpleVar "SAVEDATE", Format(MyFileDateTime(Filename), "Short Date") & " - " & Format(MyFileDateTime(Filename), "Short Time")
  XLScriptAddSimpleVar "FILESIZEKB", CLng(MyFileLen(Filename) / 1024)
  XLScriptAddSimpleVar "FILESIZE", MyFileLen(Filename)


  Set wbvars = XLScriptAddArray2D("WB")
  
  
  
  
  
  Set tabProt = XLScriptAddArray("TABLEPROTECTION")
  Set unlockedFormulaAreas = XLScriptAddArray("UNLOCKEDFORMULAAREAS")
  
  ' XXX EINBAUEN
  Set errorFormulaCells = XLScriptAddArray("ERRORFORMULAAREAS")
  Set errorFormulaValueCells = XLScriptAddArray("ERRORFORMULAVALUEAREAS")
  ' XXX EINBAUEN
  Set nonAnalyzableCells = XLScriptAddArray("NONANALYZABLECELLS")
  
  Set hiddenSheets = XLScriptAddArray("HIDDENSHEETS")
  Set hiddenColumns = XLScriptAddArray("HIDDENCOLUMNS")
  Set hiddenRows = XLScriptAddArray("HIDDENROWS")
  
  Set hiddenColumnsRanges = New Collection
  Set hiddenRowsRanges = New Collection
  
  Set externalFiles = XLScriptAddArray("EXTERNALFILES")
  ' XXX EINBAUEN
  Set missingexternalFiles = XLScriptAddArray("MISSINGEXTERNALFILES")
  ' XXX EINBAUEN
  Set mods = XLScriptAddArray("MODULES")
  
  Set sda = XLScriptAddArray2D("SHEETS")
  ' XXX EINBAUEN
  Set dda = XLScriptAddArray2D("DIAGRAMS")
  
' .NET START
  Set queryda = XLScriptAddArray2D("QUERIES")
  Set pivotda = XLScriptAddArray2D("PIVOTS")
' .NET END
  
  Set circref = XLScriptAddArray2D("SHEETSWITHCIRCULARREFERENCES")
  
End Sub



Public Sub SetTab()

    m_TabDimension.m_X = 0
    m_TabDimension.m_Y = 0
    m_TabDimension.m_XY = 0
    m_TabDimension.m_Z = 0

    tabTotalUsedCellAmount = totalUsedCellAmount
    tabFoundFormulaAmount = foundFormulaAmount
    tabFoundIfAmount = foundIfAmount
    tabFoundCalcAmount = foundCalcAmount
    tabFoundSumAmount = foundSumAmount
    tabFoundMatrixFuncs = foundMatrixFuncs
    tabFoundMatrixDuplicateFuncs = foundMatrixDuplicateFuncs
    tabFoundCellreferencesAmount = foundCellreferencesAmount
    tabFoundCellreferencesDuplicateAmount = foundCellreferencesDuplicateAmount
    tabFoundUnlockedFormulas = foundUnlockedFormulas
    tabFoundLockedFormulasMissingSheetprotect = foundLockedFormulasMissingSheetprotect
    tabFoundLockedFormulasWithoutSheetpassword = foundLockedFormulasWithoutSheetpassword
    tabFoundUnlockedFormulasNotVisible = foundUnlockedFormulasNotVisible
    tabFoundHiddenColumnAmount = foundHiddenColumnAmount
    tabFoundHiddenRowAmount = foundHiddenRowAmount
    tabFoundHiddenWorksheetsAmount = foundHiddenWorksheetsAmount
    tabFoundVeryHiddenWorksheetsAmount = foundVeryHiddenWorksheetsAmount
    tabFoundCellsWithExternalReferences = foundCellsWithExternalReferences
    tabFoundFormulaDuplicateAmount = foundFormulaDuplicateAmount
    tabFoundIfDuplicateAmount = foundIfDuplicateAmount
    tabfoundNumberFormula = foundNumberFormula
    tabFoundCalcDuplicateAmount = foundCalcDuplicateAmount
    tabFoundSumDuplicateAmount = foundSumDuplicateAmount
    tabFoundDiagrams = foundDiagrams
' .NET START
    tabFoundQueries = foundQueries
    tabfoundPivots = foundPivots
' .NET END

    tabFoundHyperlinks = foundHyperlinks
    tabFoundInternalHyperlinks = foundInternalHyperlinks
    tabFoundExternalHyperlinks = foundExternalHyperlinks
    tabFoundNonAnalyzableCells = foundNonAnalyzableCells
    tabLongestFormula = 0
    tabMaxopenbracam = 0

End Sub





Sub AnalyzeCodeModules()
  On Error GoTo nogo
  
  If UCase(GetFileExtension(oxlwbook.FullName)) = "XLSX" Or UCase(GetFileExtension(oxlwbook.FullName)) = "XLTX" Then
    XLScriptAddSimpleVar "VBAMODULEAMOUNT", 0
    Exit Sub
  End If
  ' Bevor irgendetwas berchnet wird, kann gleich ausgegeben werden,
  ' ob es sich hier um ein Sheet mit Programmmodulen handelt.
  ' Wenn dies der Fall ist, hat sich die gesamte Berechnung
  ' eigentlich erledigt.
  Dim cm
  Dim counter As Long
  If VBAFailure = 0 Then
    For Each cm In oxlwbook.VBProject.VBComponents
      If Not IsNull(cm) Then
        If cm.CodeModule.CountOfLines > 0 Then
          Dim tLine As String
          tLine = cm.CodeModule.Lines(1, cm.CodeModule.CountOfLines)
          
          Dim red As String
          red = Trim(RemoveCommentsAndLineFeeds(tLine))
          If Len(red) > 0 Then
            If UCase(Left(red, 15)) <> "OPTION EXPLICIT" Or Len(red) <> 15 Then
              If G_ChecksumVBA Then
                For counter = 1 To Len(tLine)
                  checksum = (checksum + CLng(Asc(Mid(tLine, counter, 1))) * counter) Mod ChecksumMod
                Next counter
                If G_VerboseFileLog Then
                  AddTextToFile "VBA: " & checksum & " - " & tLine, G_VerboseFileLogLogName
                End If
              End If
            
              foundCodeModules = foundCodeModules + 1
              foundLinesOfCode = foundLinesOfCode + cm.CodeModule.CountOfLines
            End If
          End If
        End If
      End If
    Next
  
    XLScriptAddSimpleVar "VBAMODULEAMOUNT", foundCodeModules
' .NET START
    XLScriptAddSimpleVar "LINESOFCODE", foundLinesOfCode
' .NET END
  ElseIf VBAFailure = 1 Then
    XLScriptAddSimpleVar "VBAMODULEAMOUNT", "0" ' Texte(GSprache, TXT_GESCH|fffd|TZT)
    XLScriptAddSimpleVar "VBAPROTECTED", "1"
  Else
    XLScriptAddSimpleVar "VBAMODULEAMOUNT", "0"
    XLScriptAddSimpleVar "VBAPROTECTED", "2"
  End If
  
  'AddStatus "Module analysiert"
  AddStatus FMT0("RESULT_1")
  Exit Sub
nogo:
    XLScriptAddSimpleVar "VBAMODULEAMOUNT", "0"
  XLScriptAddSimpleVar "VBAPROTECTED", "2"
End Sub

Function CountCells() As Boolean

  '-------------------------------------
  ' Zellen z|fffd|hlen
  '-------------------------------------
  totalCellAmount = 0
  Dim oxlwsheet As Worksheet
  For Each oxlwsheet In oxlwbook.Worksheets
    ' und wird auch nur dann ausgef|fffd|hrt, wenn es wirklich
    ' ein Worksheet ist.
    If TypeName(oxlwsheet) = "Worksheet" Then
        totalCellAmount = totalCellAmount + GetRangeCount(oxlwsheet.UsedRange)
    End If
  Next
  
  If totalCellAmount = 0 Then
    'XLScriptAddSimpleVar "USEDCELLAMOUNT", "Texte(GSprache, TXT_KEINEZELLEN)"
    XLScriptAddSimpleVar "USEDCELLAMOUNT", FMT0("TXT_KEINEZELLEN")
    CountCells = False
  Else
    CountCells = True
  End If
End Function


Sub CheckProtectedWorkbook(ByRef oxlwbook As Workbook)
  
  '-------------------------------------
  ' Workbook gesch|fffd|tzt?
  '-------------------------------------
  If oxlwbook.ProtectStructure = True Or oxlwbook.ProtectWindows = True Then
    ' Struturschutz
    If oxlwbook.ProtectStructure = True Then
      'XLScriptAddSimpleVar "STRUCTUREPROTECTED", Texte(GSprache, TXT_JA)
      XLScriptAddSimpleVar "STRUCTUREPROTECTED", FMT0("TXT_JA")
    Else
      'XLScriptAddSimpleVar "STRUCTUREPROTECTED", Texte(GSprache, TXT_NEIN)
      XLScriptAddSimpleVar "STRUCTUREPROTECTED", FMT0("TXT_NEIN")
    End If
      
    ' Fensterschutz
    If oxlwbook.ProtectWindows = True Then
      XLScriptAddSimpleVar "WINDOWSPROTECTED", FMT0("TXT_JA")
    Else
      XLScriptAddSimpleVar "WINDOWSPROTECTED", FMT0("TXT_NEIN")
    End If
    
    If WorkbookHasPassword(oxlwbook) Then
      XLScriptAddSimpleVar "WBPROTECTED", FMT0("TXT_JAMITPW")
    Else
      XLScriptAddSimpleVar "WBPROTECTED", FMT0("TXT_JAOHNEPW")
    End If
  Else
    XLScriptAddSimpleVar "WBPROTECTED", FMT0("TXT_NEIN")
    XLScriptAddSimpleVar "STRUCTUREPROTECTED", FMT0("TXT_NEIN")
    XLScriptAddSimpleVar "WINDOWSPROTECTED", FMT0("TXT_NEIN")
  End If
End Sub


Sub GetNames()
  '---------------------------------------
  ' Namensliste ausgeben
  '---------------------------------------
  Dim nameItem As name
  Dim da As Object
  Set da = XLScriptAddArray2D("NAMES")
  
  For Each nameItem In oxlwbook.names
    If Left(nameItem.name, 11) <> "_IDVTracker" Then
    
      If UCase(Right(nameItem.name, Len("!Print_Area"))) <> "!PRINT_AREA" And UCase(Right(nameItem.name, Len(".PrintArea"))) <> ".PRINTAREA" And UCase(Right(nameItem.name, Len(".FILTERDATA"))) <> ".FILTERDATA" And UCase(Left(nameItem.name, Len("=SOLVER!"))) <> "=SOLVER!" Then
        da.AddLine
        da.AddValue "NAME", nameItem.Parent.name & " - " & nameItem.NameLocal
  '      da.AddValue "TYPE", "N"
        If nameItem.Visible = True Then
          da.AddValue "VISIBLE", FMT0("TXT_SB")
        Else
          da.AddValue "VISIBLE", FMT0("TXT_USB")
        End If
        da.AddValue "REFERSTO", "'" & nameItem.RefersToLocal
      End If
      
      If nameItem.Visible = True Then
        If UCase(Right(nameItem.name, Len("!Print_Area"))) <> "!PRINT_AREA" And UCase(Right(nameItem.name, Len(".PrintArea"))) <> ".PRINTAREA" And UCase(Right(nameItem.name, Len(".FITLERDATA"))) <> ".FITLERDATA" Then
          Dim counter As Long
          If G_ChecksumNames Then
            If Not IsSimpleFormula(nameItem.RefersTo) Then
'              For counter = 1 To Len(nameItem.RefersToLocal)
'                checksum = (checksum + CLng(Asc(Mid(nameItem.RefersToLocal, counter, 1))) * counter) Mod ChecksumMod
              Dim linkResolvedFormula As String
              linkResolvedFormula = ResolveLink(nameItem.RefersToLocal)
   
              For counter = 1 To Len(linkResolvedFormula)
                checksum = (checksum + CLng(Asc(Mid(linkResolvedFormula, counter, 1))) * counter) Mod ChecksumMod
              Next counter
              If G_VerboseFileLog Then
                AddTextToFile "NAME: " & checksum & " - " & nameItem.RefersToLocal, G_VerboseFileLogLogName
              End If
            End If
          End If
        End If
      End If
    End If
  Next nameItem
End Sub



Sub CheckExternalReferences()
  On Error GoTo nogo
  Dim aLinks
  Dim i As Long
  aLinks = ActiveWorkbook.LinkSources(xlExcelLinks)
  If Not IsEmpty(aLinks) Then
      For i = 1 To UBound(aLinks)
        If Not FileExists(GetUNCPath(CStr(aLinks(i)))) Then
          If FullVersion = True Or missingexternalFiles.items.count <= 3 Then
            missingexternalFiles.AddValue "", LongFileName(GetUNCPath(CStr(aLinks(i))))
          Else
            'missingexternalFiles.AddValue "", "Demo"
            missingexternalFiles.AddValue "", FMT0("RESULT_2")
          End If
        Else
          If FullVersion = True Or i <= 3 Then
            externalFiles.AddValue "", LongFileName(GetUNCPath(CStr(aLinks(i))))
          Else
            'externalFiles.AddValue "", "Demo"
            externalFiles.AddValue "", FMT0("RESULT_2")
          End If
        End If
      Next i
      foundExternalReferences = UBound(aLinks)
  End If
  Exit Sub
nogo:
  foundExternalReferences = 0
  
End Sub

Sub CheckSheetPasswords()
  
  
  'AddStatus "Pr|fffd|fe Blattschutz-Passw|fffd|rter"
  AddStatus FMT0("RESULT_3")
  Dim oxlwsheet As Worksheet
  For Each oxlwsheet In oxlwbook.Worksheets
    If TypeName(oxlwsheet) = "Worksheet" Then
      
      ' Ist ein Blattschutz vorhanden?
      Dim csp As CSheetProt
      Set csp = New CSheetProt
      If oxlwsheet.ProtectContents = True Then
        ' Sehr sch|fffd|n, dann schaun wir mal, ob auch ein Passwort daf|fffd|r eingesetzt wurde
        If Not SheetHasPassword(oxlwsheet) Then
          csp.m_WorksheetProt = 1
          csp.m_ProtectionString = csp.m_ProtectionString + FMT0("TXT_BSPASSWORTFEHLT") & " "
        Else
          csp.m_WorksheetProt = 2
          If oxlwsheet.ProtectContents = False Then
            crackedWorksheetsWithPassword = crackedWorksheetsWithPassword + 1
          End If
        End If
      Else
        csp.m_ProtectionString = csp.m_ProtectionString + FMT0("TXT_BLATTSCHUTZFEHLT") & " "
        csp.m_WorksheetProt = 0
      End If
      
      ' Objekte
      If oxlwsheet.ProtectDrawingObjects = False Then
        csp.m_ProtectionString = csp.m_ProtectionString + FMT0("TXT_OBJEKTSCHUTZFEHLT") & " "
      End If
      
      ' Szenarios
      If oxlwsheet.ProtectScenarios = False Then
        csp.m_ProtectionString = csp.m_ProtectionString + FMT0("TXT_SZENARIOSCHUTZFEHLT") & " "
      End If
      
      protectedSheetsColl.Add csp, oxlwsheet.name
    End If
  Next oxlwsheet
End Sub
      
Sub RemoveSheetPasswords()
  'AddStatus "Entferne Passwort aus Tabellen"
  AddStatus FMT0("RESULT_4")
  Dim oxlwsheet As Worksheet
  For Each oxlwsheet In oxlwbook.Worksheets
    If TypeName(oxlwsheet) = "Worksheet" Then
      ' Ist ein Blattschutz vorhanden?
      If oxlwsheet.ProtectContents = True Then
        ' Sehr sch|fffd|n, dann schaun wir mal, ob auch ein Passwort daf|fffd|r eingesetzt wurde
        If SheetHasPassword(oxlwsheet) Then
          ' Die Tabelle cracken!
          If Left(Application.Version, 3) = "8.0" Then
            CrackSheet oxlwsheet
          End If
          
          If oxlwsheet.ProtectContents = True Then
            RemovePW oxlwsheet
          End If
    
        
        End If
      End If
    
    
    End If
  Next oxlwsheet
  
  
End Sub

Sub CheckSheetProtection(oxlwsheet As Worksheet)
      
'  Dim protectionString As String
'  protectionString = ""
  ' Ist ein Blattschutz vorhanden?
  If protectedSheetsColl(oxlwsheet.name).m_WorksheetProt > 0 Then
    protectedWorksheets = protectedWorksheets + 1
    ' Sehr sch|fffd|n, dann schaun wir mal, ob auch ein Passwort daf|fffd|r eingesetzt wurde
    If protectedSheetsColl(oxlwsheet.name).m_WorksheetProt = 1 Then
        ' Wenn's bis hierhin durchgeht, dann war kein Passwort drauf!!!!
'        protectionString = protectionString + "P "
        protectedWorksheetsWithoutPassword = protectedWorksheetsWithoutPassword + 1
    Else
        protectedWorksheetsWithPassword = protectedWorksheetsWithPassword + 1
    End If
  Else
'    protectionString = protectionString + FMT0("TXT_BLATTSCHUTZFEHLT")
    unprotectedWorksheets = unprotectedWorksheets + 1
  End If
  
  ' Objekte
'  If oxlwsheet.ProtectDrawingObjects = False Then
'    protectionString = protectionString + "O "
'  End If
  
  ' Szenarios
'  If oxlwsheet.ProtectScenarios = False Then
'    protectionString = protectionString + FMT0("TXT_SZENARIOSCHUTZFEHLT")
'  End If
  
  If Len(protectedSheetsColl(oxlwsheet.name).m_ProtectionString) > 0 Then
    If FullVersion = True Or tabProt.items.count <= 3 Then
      tabProt.AddValue "", oxlwsheet.name & " (" & Left(protectedSheetsColl(oxlwsheet.name).m_ProtectionString, Len(protectedSheetsColl(oxlwsheet.name).m_ProtectionString) - 1) & ")"
    Else
      tabProt.AddValue "", "Demo"
    End If
  End If

End Sub


Function GetPivotText(var As String, ByRef pt As PivotTable)

On Error GoTo nogo

  Dim s As String
  Dim objPivotFld As Object
  Dim objCubeFld As CubeField
  Dim pivotForm As PivotFormula
  Select Case var
    
    Case "PageFields"
        For Each objPivotFld In pt.PageFields
            s = s & IIf(s <> "", ", ", "") & objPivotFld.name
        Next objPivotFld
    Case "ColumnFields"
        For Each objPivotFld In pt.ColumnFields
            s = s & IIf(s <> "", ", ", "") & objPivotFld.name
        Next objPivotFld
    Case "RowFields"
        For Each objPivotFld In pt.RowFields
            s = s & IIf(s <> "", ", ", "") & objPivotFld.name
        Next objPivotFld
    Case "DataFields"
        For Each objPivotFld In pt.DataFields
            s = s & IIf(s <> "", ", ", "") & objPivotFld.name
        Next objPivotFld
    Case "CubeFields"
        For Each objCubeFld In pt.CubeFields
'            If objCubeFld.Orientation = xlDataField Then
                s = s & IIf(s <> "", ", ", "") & objCubeFld.name
'            End If
        Next objCubeFld
    Case "PivotFormulasLocal"
        For Each pivotForm In pt.PivotFormulas
             s = s & IIf(s <> "", vbCrLf, "") & pivotForm.Formula
        Next pivotForm
    Case "PivotFormulas"
        For Each pivotForm In pt.PivotFormulas
             s = s & IIf(s <> "", vbCrLf, "") & pivotForm.StandardFormula
        Next pivotForm
  End Select
  If s <> "" Then
    GetPivotText = s
  Else
    GetPivotText = "-\-"
  End If
  Exit Function
nogo:
  GetPivotText = "-\-"

End Function



Function PivotHasSourceData(ByRef pt As PivotTable) As Boolean
On Error GoTo nogo
          
  Dim s As String
  s = pt.SourceData
  PivotHasSourceData = True
  Exit Function
nogo:
  PivotHasSourceData = False
End Function

Function PivotHasCommandText(ByRef pt As PivotTable) As Boolean
On Error GoTo nogo
          
  Dim s As String
  s = pt.PivotCache.CommandText
  PivotHasCommandText = True
  Exit Function
nogo:
  PivotHasCommandText = False
End Function

Sub CheckPivots(ByRef oxlwsheet As Worksheet)
On Error GoTo nogo
      
   Dim pt As PivotTable
   If oxlwsheet.PivotTables.count > 0 Then
     For Each pt In oxlwsheet.PivotTables
          foundPivots = foundPivots + 1
       
          Dim s As String
          Dim counter As Long
          Dim sourcestr As String
          
          If PivotHasSourceData(pt) Then
            s = pt.SourceData
            sourcestr = s
            counter = InStr(s, "!")
            If counter > 0 Then
              Dim news As String
              If counter > 1 Then
                news = Left(s, counter - 1)
              End If
              For counter = counter To Len(s)
                If UCase(Mid(s, counter, 1)) >= "A" And UCase(Mid(s, counter, 1)) <= "Z" Then
                  news = news & "-"
                Else
                  news = news & Mid(s, counter, 1)
                End If
              Next counter
              s = news
            End If
          ElseIf PivotHasCommandText(pt) Then
            s = pt.PivotCache.CommandText & " (" & pt.PivotCache.Connection & ")"
            sourcestr = s
          End If
          
          If G_ChecksumPivot Then
            For counter = 1 To Len(s)
              checksum = (checksum + CLng(Asc(Mid(s, counter, 1))) * counter) Mod ChecksumMod
            Next counter
            If G_VerboseFileLog Then
              AddTextToFile "PIVOT1: " & checksum & " - " & s, G_VerboseFileLogLogName
            End If
            
            s = GetPivotText("PageFields", pt)
            For counter = 1 To Len(s)
              checksum = (checksum + CLng(Asc(Mid(s, counter, 1))) * counter) Mod ChecksumMod
            Next counter
            If G_VerboseFileLog Then
              AddTextToFile "PIVOT2: " & checksum & " - " & s, G_VerboseFileLogLogName
            End If
            s = GetPivotText("ColumnFields", pt)
            For counter = 1 To Len(s)
              checksum = (checksum + CLng(Asc(Mid(s, counter, 1))) * counter) Mod ChecksumMod
            Next counter
            If G_VerboseFileLog Then
              AddTextToFile "PIVOT3: " & checksum & " - " & s, G_VerboseFileLogLogName
            End If
            s = GetPivotText("RowFields", pt)
            For counter = 1 To Len(s)
              checksum = (checksum + CLng(Asc(Mid(s, counter, 1))) * counter) Mod ChecksumMod
            Next counter
            If G_VerboseFileLog Then
              AddTextToFile "PIVOT4: " & checksum & " - " & s, G_VerboseFileLogLogName
            End If
            s = GetPivotText("CubeFields", pt)
            For counter = 1 To Len(s)
              checksum = (checksum + CLng(Asc(Mid(s, counter, 1))) * counter) Mod ChecksumMod
            Next counter
            If G_VerboseFileLog Then
              AddTextToFile "PIVOT5: " & checksum & " - " & s, G_VerboseFileLogLogName
            End If
            s = GetPivotText("DataFields", pt)
            For counter = 1 To Len(s)
              checksum = (checksum + CLng(Asc(Mid(s, counter, 1))) * counter) Mod ChecksumMod
            Next counter
            If G_VerboseFileLog Then
              AddTextToFile "PIVOT6: " & checksum & " - " & s, G_VerboseFileLogLogName
            End If
            s = GetPivotText("PivotFormulas", pt)
            For counter = 1 To Len(s)
              checksum = (checksum + CLng(Asc(Mid(s, counter, 1))) * counter) Mod ChecksumMod
            Next counter
            If G_VerboseFileLog Then
              AddTextToFile "PIVOT7: " & checksum & " - " & s, G_VerboseFileLogLogName
            End If
          End If
          
          pivotda.AddLine
          pivotda.AddValue "NAME", pt.name
'          pivotda.AddValue "REFERSTO", "Quelle: " & pt.SourceData & vbCrLf & _
'            "Seitenfelder: " & GetPivotText("PageFields", pt) & vbCrLf & _
'            "Spaltenfelder: " & GetPivotText("ColumnFields", pt) & vbCrLf & _
'            "Zeilenfelder: " & GetPivotText("RowFields", pt) & vbCrLf & _
'            "W|fffd|rfelfelder: " & GetPivotText("CubeFields", pt) & vbCrLf & _
'            "Datenfelder: " & GetPivotText("DataFields", pt) & vbCrLf & _
'            "Formeln: " & IIf(GetPivotText("PivotFormulasLocal", pt) <> "-/-", vbCrLf & GetPivotText("PivotFormulasLocal", pt), GetPivotText("PivotFormulasLocal", pt))
          pivotda.AddValue "REFERSTO", FMT0("RESULT_5") & sourcestr & vbCrLf & _
            FMT0("RESULT_6") & GetPivotText("PageFields", pt) & vbCrLf & _
            FMT0("RESULT_7") & GetPivotText("ColumnFields", pt) & vbCrLf & _
            FMT0("RESULT_8") & GetPivotText("RowFields", pt) & vbCrLf & _
            FMT0("RESULT_9") & GetPivotText("CubeFields", pt) & vbCrLf & _
            FMT0("RESULT_10") & GetPivotText("DataFields", pt) & vbCrLf & _
            FMT0("RESULT_11") & IIf(GetPivotText("PivotFormulasLocal", pt) <> "-/-", vbCrLf & GetPivotText("PivotFormulasLocal", pt), GetPivotText("PivotFormulasLocal", pt))
            
     Next pt
   End If
   Exit Sub
nogo:
End Sub

Private Function GetCommandText(qt) As String
  On Error Resume Next
  GetCommandText = qt.CommandText
End Function
Private Function GetConnectionText(qt) As String
  On Error Resume Next
  GetConnectionText = qt.Connection
End Function


Sub CheckQueries(oxlwsheet As Worksheet)
      
On Error GoTo nogo
  Dim counter As Long
   
  Dim qt As QueryTable
  Dim querycount As Long
  If oxlwsheet.QueryTables.count > 0 Then
     For Each qt In oxlwsheet.QueryTables
          foundQueries = foundQueries + 1
       
          If G_ChecksumQueries Then
            For counter = 1 To Len(GetCommandText(qt))
              checksum = (checksum + CLng(Asc(Mid(qt.CommandText, counter, 1))) * counter) Mod ChecksumMod
            Next counter
            If G_VerboseFileLog Then
              AddTextToFile "QUERY1: " & checksum & " - " & qt.CommandText, G_VerboseFileLogLogName
            End If
            For counter = 1 To Len(GetConnectionText(qt))
              checksum = (checksum + CLng(Asc(Mid(qt.Connection, counter, 1))) * counter) Mod ChecksumMod
            Next counter
            If G_VerboseFileLog Then
              AddTextToFile "QUERY2: " & checksum & " - " & qt.CommandText, G_VerboseFileLogLogName
            End If
          End If
          querycount = querycount + 1
          queryda.AddLine
          queryda.AddValue "NAME", oxlwsheet.name & ".Query." & querycount
'          queryda.AddValue "REFERSTO", "'Adresse: " & StripChars(qt.ResultRange.Address, "$") & vbCrLf & vbCrLf & _
'          "Connect: " & GetConnectionText(qt) & vbCrLf & vbCrLf & _
'          "Abfrage: " & GetCommandText(qt)
          queryda.AddValue "REFERSTO", FMT0("RESULT_12") & StripChars(qt.ResultRange.Address, "$") & vbCrLf & vbCrLf & _
          FMT0("RESULT_13") & GetConnectionText(qt) & vbCrLf & vbCrLf & _
          FMT0("RESULT_14") & GetCommandText(qt)

     Next qt
  End If
   
  Dim lo As ListObject
  
  For Each lo In ActiveSheet.ListObjects
          Dim o As ListColumn
          foundQueries = foundQueries + 1
       
          Dim felder As String
          For Each o In lo.QueryTable.ListObject.ListColumns
            If felder = "" Then
              felder = o.name
            Else
              felder = felder & ", " & o.name
            End If
          Next o
          
          If G_ChecksumQueries Then
            For counter = 1 To Len(GetConnectionText(lo.QueryTable))
              checksum = (checksum + CLng(Asc(Mid(GetConnectionText(lo.QueryTable), counter, 1))) * counter) Mod ChecksumMod
            Next counter
            If G_VerboseFileLog Then
              AddTextToFile "QUERY3: " & checksum & " - " & qt.CommandText, G_VerboseFileLogLogName
            End If
            For counter = 1 To Len(GetCommandText(lo.QueryTable))
              checksum = (checksum + CLng(Asc(Mid(GetCommandText(lo.QueryTable), counter, 1))) * counter) Mod ChecksumMod
            Next counter
            If G_VerboseFileLog Then
              AddTextToFile "QUERY4: " & checksum & " - " & qt.CommandText, G_VerboseFileLogLogName
            End If
            For counter = 1 To Len(felder)
                checksum = (checksum + CLng(Asc(Mid(felder, counter, 1))) * counter) Mod ChecksumMod
            Next counter
            If G_VerboseFileLog Then
              AddTextToFile "QUERY5: " & checksum & " - " & qt.CommandText, G_VerboseFileLogLogName
            End If
          End If
          querycount = querycount + 1
          queryda.AddLine
          queryda.AddValue "NAME", oxlwsheet.name & ".Query." & querycount
'          queryda.AddValue "REFERSTO", "'Adresse: " & StripChars(lo.QueryTable.Destination.Address, "$") & vbCrLf & vbCrLf & _
'          "Connect: " & GetConnectionText(lo.QueryTable) & vbCrLf & vbCrLf & _
'          "Abfrage: " & GetCommandText(lo.QueryTable) & vbCrLf & vbCrLf & _
'          "Felder: " & felder
          queryda.AddValue "REFERSTO", FMT0("RESULT_12") & StripChars(lo.QueryTable.Destination.Address, "$") & vbCrLf & vbCrLf & _
          FMT0("RESULT_13") & GetConnectionText(lo.QueryTable) & vbCrLf & vbCrLf & _
          FMT0("RESULT_14") & GetCommandText(lo.QueryTable) & vbCrLf & vbCrLf & _
          FMT0("RESULT_15") & felder
      
      
  Next lo
   
   
nogo:
End Sub



Sub CheckDiagrams(oxlwsheet As Worksheet)
      
   ' Diagramme betrachten
   Dim coitem As ChartObject
   Dim cgitem As ChartGroup
   Dim scitem As Series
   
   If oxlwsheet.ChartObjects.count > 0 Then
     For Each coitem In oxlwsheet.ChartObjects
       foundDiagrams = foundDiagrams + 1
       
'       Dim dda As XLScriptArray2D
'       Set dda = da.AddArr("DIAGRAMS")
       
       
       dda.AddLine
       dda.AddValue "NAME", coitem.Chart.name
       dda.AddValue "ADDRESS", StripChars(coitem.TopLeftCell.Address, "$")
       Dim s As String
       s = ""
       Dim diagrammformelHatFehler As Boolean
       diagrammformelHatFehler = False
       For Each cgitem In coitem.Chart.ChartGroups
         For Each scitem In cgitem.SeriesCollection
           If IsReadableFormula(scitem) Then
             Dim counter As Long
             If G_ChecksumDiagrams Then
'               For counter = 1 To Len(scitem.Formula)
'                 checksum = (checksum + CLng(Asc(Mid(scitem.Formula, counter, 1))) * counter) Mod ChecksumMod
               Dim linkResolvedFormula As String
               linkResolvedFormula = ResolveLink(scitem.Formula)
               
               For counter = 1 To Len(linkResolvedFormula)
                 checksum = (checksum + CLng(Asc(Mid(linkResolvedFormula, counter, 1))) * counter) Mod ChecksumMod
               Next counter
                If G_VerboseFileLog Then
                  AddTextToFile "DIAG: " & checksum & " - " & scitem.Formula, G_VerboseFileLogLogName
                End If
             End If
             s = s & IIf(s <> "", vbCrLf, "") & scitem.Formula
           Else
             diagrammformelHatFehler = True
           End If
         Next scitem
       Next cgitem
       If diagrammformelHatFehler Then
         'dda.AddValue "REFERSTO", "'Diagrammformel nicht lesbar!!!"
         dda.AddValue "REFERSTO", FMT0("RESULT_16")
       Else
         dda.AddValue "REFERSTO", "'" & s
       End If
     Next coitem
   End If
End Sub



Function StoreErrorType(ByRef c As Range, analysetyp As String) As Long
  On Error Resume Next
  StoreErrorType = 0
  Select Case c.value
    Case CVErr(xlErrNull)
      If analysetyp <> "m" Then
        sda.AddValue "ERRORNULLAM", 1
      End If
      XLScriptGetSimpleVar("ERRORNULLAM").m_Value = CStr(Val(XLScriptGetSimpleVar("ERRORNULLAM").m_Value) + 1)
      StoreErrorType = 1
    Case CVErr(xlErrDiv0)
      If analysetyp <> "m" Then
        sda.AddValue "ERRORDIV0AM", 1
      End If
      XLScriptGetSimpleVar("ERRORDIV0AM").m_Value = CStr(Val(XLScriptGetSimpleVar("ERRORDIV0AM").m_Value) + 1)
      StoreErrorType = 2
    Case CVErr(xlErrValue)
      If analysetyp <> "m" Then
        sda.AddValue "ERRORVALUEAM", 1
      End If
      XLScriptGetSimpleVar("ERRORVALUEAM").m_Value = CStr(Val(XLScriptGetSimpleVar("ERRORVALUEAM").m_Value) + 1)
      StoreErrorType = 2
    Case CVErr(xlErrRef)
      If analysetyp <> "m" Then
        sda.AddValue "ERRORREFAM", 1
      End If
      XLScriptGetSimpleVar("ERRORREFAM").m_Value = CStr(Val(XLScriptGetSimpleVar("ERRORREFAM").m_Value) + 1)
      StoreErrorType = 1
    Case CVErr(xlErrName)
      If analysetyp <> "m" Then
        sda.AddValue "ERRORNAMEAM", 1
      End If
      XLScriptGetSimpleVar("ERRORNAMEAM").m_Value = CStr(Val(XLScriptGetSimpleVar("ERRORNAMEAM").m_Value) + 1)
      StoreErrorType = 1
    Case CVErr(xlErrNum)
      If analysetyp <> "m" Then
        sda.AddValue "ERRORNUMAM", 1
      End If
      XLScriptGetSimpleVar("ERRORNUMAM").m_Value = CStr(Val(XLScriptGetSimpleVar("ERRORNUMAM").m_Value) + 1)
      StoreErrorType = 2
    Case CVErr(xlErrNA)
      If analysetyp <> "m" Then
        sda.AddValue "ERRORNAAM", 1
      End If
      XLScriptGetSimpleVar("ERRORNAAM").m_Value = CStr(Val(XLScriptGetSimpleVar("ERRORNAAM").m_Value) + 1)
      StoreErrorType = 2
  End Select
End Function



'#If DoProfile Then
'Sub StoreSheetCellTypeNumbers(oXLWsheet As Worksheet, analysetyp As String, ByRef hrt As HighResTimer)
'#Else
Sub StoreSheetCellTypeNumbers(oxlwsheet As Worksheet, analysetyp As String)
  Exit Sub
'#End If
  '**************************************************
  ' Special Cells Zeug
  '**************************************************
  
  Dim numberamount As Long
  Dim textamount As Long
  Dim boolamount As Long
  Dim formulanumberamount As Long
  Dim formulatextamount As Long
  Dim formulaboolamount As Long
  Dim formulaerroramount As Long
  
  
' #If DoProfile Then
'   hrt.StartCounting "xlCellTypeConstants1"
' #End If
'   numberamount = GetAmountType(oXLWsheet, xlCellTypeConstants, 1)
' #If DoProfile Then
'   hrt.StopCounting "xlCellTypeConstants1"
' #End If
'   DoEvents
'   SetLiveStatus
  
' #If DoProfile Then
'   hrt.StartCounting "xlCellTypeConstants2"
' #End If
'   textamount = GetAmountType(oXLWsheet, xlCellTypeConstants, 2)
' #If DoProfile Then
'   hrt.StopCounting "xlCellTypeConstants2"
' #End If
'   DoEvents
'   SetLiveStatus
  
' #If DoProfile Then
'   hrt.StartCounting "xlCellTypeConstants4"
' #End If
'   boolamount = GetAmountType(oXLWsheet, xlCellTypeConstants, 4)
' #If DoProfile Then
'   hrt.StopCounting "xlCellTypeConstants4"
' #End If
'   DoEvents
'   SetLiveStatus
  
' #If DoProfile Then
'   hrt.StartCounting "xlCellTypeFormulas1"
' #End If
'   formulanumberamount = GetAmountType(oXLWsheet, xlCellTypeFormulas, 1)
' #If DoProfile Then
'   hrt.StopCounting "xlCellTypeFormulas1"
' #End If
'   DoEvents
'   SetLiveStatus
  
' #If DoProfile Then
'   hrt.StartCounting "xlCellTypeFormulas2"
' #End If
'   formulatextamount = GetAmountType(oXLWsheet, xlCellTypeFormulas, 2)
' #If DoProfile Then
'   hrt.StopCounting "xlCellTypeFormulas2"
' #End If
'   DoEvents
'   SetLiveStatus
  
' #If DoProfile Then
'   hrt.StartCounting "xlCellTypeFormulas4"
' #End If
'   formulaboolamount = GetAmountType(oXLWsheet, xlCellTypeFormulas, 4)
' #If DoProfile Then
'   hrt.StopCounting "xlCellTypeFormulas4"
' #End If
'   DoEvents
'   SetLiveStatus
  
  Dim nullam As Long, div0am  As Long, valueam As Long, refam As Long, nameam As Long, numam As Long, naam As Long
  formulaerroramount = GetAmountErrors(oxlwsheet, nullam, div0am, valueam, refam, nameam, numam, naam)
 
  DoEvents
  SetLiveStatus
  
  XLScriptGetSimpleVar("NUMBERAMOUNT").m_Value = CStr(Val(XLScriptGetSimpleVar("NUMBERAMOUNT").m_Value) + numberamount)
  XLScriptGetSimpleVar("TEXTAMOUNT").m_Value = CStr(Val(XLScriptGetSimpleVar("TEXTAMOUNT").m_Value) + textamount)
  XLScriptGetSimpleVar("BOOLAMOUNT").m_Value = CStr(Val(XLScriptGetSimpleVar("BOOLAMOUNT").m_Value) + boolamount)
  XLScriptGetSimpleVar("FORMULANUMBERAMOUNT").m_Value = CStr(Val(XLScriptGetSimpleVar("FORMULANUMBERAMOUNT").m_Value) + formulanumberamount)
  XLScriptGetSimpleVar("FORMULATEXTAMOUNT").m_Value = CStr(Val(XLScriptGetSimpleVar("FORMULATEXTAMOUNT").m_Value) + formulatextamount)
  XLScriptGetSimpleVar("FORMULABOOLAMOUNT").m_Value = CStr(Val(XLScriptGetSimpleVar("FORMULABOOLAMOUNT").m_Value) + formulaboolamount)
  XLScriptGetSimpleVar("FORMULAERRORAMOUNT").m_Value = CStr(Val(XLScriptGetSimpleVar("FORMULAERRORAMOUNT").m_Value) + formulaerroramount)
  
  XLScriptGetSimpleVar("ERRORNULLAM").m_Value = CStr(Val(XLScriptGetSimpleVar("ERRORNULLAM").m_Value) + nullam)
  XLScriptGetSimpleVar("ERRORDIV0AM").m_Value = CStr(Val(XLScriptGetSimpleVar("ERRORDIV0AM").m_Value) + div0am)
  XLScriptGetSimpleVar("ERRORVALUEAM").m_Value = CStr(Val(XLScriptGetSimpleVar("ERRORVALUEAM").m_Value) + valueam)
  XLScriptGetSimpleVar("ERRORREFAM").m_Value = CStr(Val(XLScriptGetSimpleVar("ERRORREFAM").m_Value) + refam)
  XLScriptGetSimpleVar("ERRORNAMEAM").m_Value = CStr(Val(XLScriptGetSimpleVar("ERRORNAMEAM").m_Value) + nameam)
  XLScriptGetSimpleVar("ERRORNUMAM").m_Value = CStr(Val(XLScriptGetSimpleVar("ERRORNUMAM").m_Value) + numam)
  XLScriptGetSimpleVar("ERRORNAAM").m_Value = CStr(Val(XLScriptGetSimpleVar("ERRORNAAM").m_Value) + naam)
  
  
  If analysetyp <> "m" Then
    sda.AddValue "NUMBERAMOUNT", CStr(numberamount)
    sda.AddValue "TEXTAMOUNT", CStr(textamount)
    sda.AddValue "BOOLAMOUNT", CStr(boolamount)
    sda.AddValue "FORMULANUMBERAMOUNT", CStr(formulanumberamount)
    sda.AddValue "FORMULATEXTAMOUNT", CStr(formulatextamount)
    sda.AddValue "FORMULABOOLAMOUNT", CStr(formulaboolamount)
    sda.AddValue "FORMULAERRORAMOUNT", CStr(formulaerroramount)
  
    sda.AddValue "ERRORNULLAM", CStr(nullam)
    sda.AddValue "ERRORDIV0AM", CStr(div0am)
    sda.AddValue "ERRORVALUEAM", CStr(valueam)
    sda.AddValue "ERRORREFAM", CStr(refam)
    sda.AddValue "ERRORNAMEAM", CStr(nameam)
    sda.AddValue "ERRORNUMAM", CStr(numam)
    sda.AddValue "ERRORNAAM", CStr(naam)
  
  End If
  
End Sub


Sub CheckSheetVisibility(oxlwsheet As Worksheet)
      
  ' Existiert ein "unsichtbares" worksheet?
  If oxlwsheet.Visible <> xlSheetVisible Then
    
    If oxlwsheet.Visible = xlSheetVeryHidden Then
      foundVeryHiddenWorksheetsAmount = foundVeryHiddenWorksheetsAmount + 1
    End If
    
    ' Text speichern
    If StartEnums + foundHiddenWorksheetsAmount <= 65536 Then
      If FullVersion = True Or hiddenSheets.items.count <= 3 Then
        If oxlwsheet.Visible = xlSheetVeryHidden Then
          hiddenSheets.AddValue "", oxlwsheet.name & FMT0("TXT_SV")
        Else
          hiddenSheets.AddValue "", oxlwsheet.name
        End If
      Else
          'hiddenSheets.AddValue "", "Demo"
          hiddenSheets.AddValue "", FMT0("RESULT_2")
      End If
    End If
  
    ' Und einblenden...
'          If Not oXLWbook.ProtectStructure Then
      oxlwsheet.Visible = xlSheetVisible
'          End If
    
    foundHiddenWorksheetsAmount = foundHiddenWorksheetsAmount + 1
  End If
End Sub

Function GetColumString(ByVal c As Long) As String

  Dim r As Range
  Set r = Cells(1, c)
  GetColumString = StripChars(r.Address, "$0123456789")
End Function

Sub CreateHiddenStuff()
  Dim c As Collection
  Dim i As Long
  Dim cr As CrunchRange
  Dim found As Boolean
  
  If FullVersion = False Then
    hiddenColumns.AddValue "", "Demo"
  Else
    For Each cr In hiddenColumnsRanges
      hiddenColumns.AddValue "", FMT0("TXT_TABK") & ": '" & cr.m_Name & "', " & FMT0("TXT_SPALTEK") & ": " & IIf(cr.m_Von = cr.m_Bis, GetColumString(cr.m_Von), GetColumString(cr.m_Von) & ":" & GetColumString(cr.m_Bis))
    Next cr
  End If


  If FullVersion = False Then
    hiddenRows.AddValue "", "Demo"
  Else
    For Each cr In hiddenRowsRanges
      hiddenRows.AddValue "", FMT0("TXT_TABK") & ": '" & cr.m_Name & "', " & FMT0("TXT_ZEILEK") & ": " & IIf(cr.m_Von = cr.m_Bis, cr.m_Von, cr.m_Von & ":" & cr.m_Bis)
    Next cr
  End If
End Sub


Sub CheckHiddenColumns(oxlwsheet As Worksheet)
  
  Dim c As Range
  Dim tColumn                   As String
  
  For Each c In oxlwsheet.Columns
    ' Ist die Spalte des Textes sichtbar???
    If c.ColumnWidth <= 0 Then
      
      Dim cr As CrunchRange
      Dim found As Boolean
      found = False
      For Each cr In hiddenColumnsRanges
        If cr.InRange(oxlwsheet.name, c.Column, True) Then
            found = True
            Exit For
        End If
      Next cr
      If Not found Then
        Set cr = New CrunchRange
        cr.Initialize oxlwsheet.name, c.Column
        hiddenColumnsRanges.Add cr
      End If

      foundHiddenColumnAmountCount = foundHiddenColumnAmountCount + 1
      foundHiddenColumnAmount = foundHiddenColumnAmount + 1
    End If
  Next c
End Sub


Sub CheckHiddenRows(oxlwsheet As Worksheet)
  
  Dim c As Range
  For Each c In oxlwsheet.UsedRange.Rows
    If c.RowHeight <= 0 Then
      If c.Column = 1 Then
        
        Dim cr As CrunchRange
        Dim found As Boolean
        found = False
        For Each cr In hiddenRowsRanges
          If cr.InRange(oxlwsheet.name, c.Row, True) Then
              found = True
              Exit For
          End If
        Next cr
        If Not found Then
          Set cr = New CrunchRange
          cr.Initialize oxlwsheet.name, c.Row
          hiddenRowsRanges.Add cr
        End If
        
        foundHiddenRowAmountCount = foundHiddenRowAmountCount + 1
        foundHiddenRowAmount = foundHiddenRowAmount + 1
      End If
    End If
  Next c
End Sub

Function FormulaR1C1Readable(ByRef c As Range) As Boolean
  Dim s As String
  On Error GoTo notReadable
  s = c.FormulaR1C1
  FormulaR1C1Readable = True
  Exit Function
  
notReadable:
  FormulaR1C1Readable = False
End Function

Function IsClone(ByRef c As Range, ByRef cs As CloneStuff) As Boolean
  
  If Not FormulaR1C1Readable(c) Then
    IsClone = False
    Exit Function
  End If

  On Error GoTo notExistant
  Dim a As String
  a = c.FormulaR1C1
  Set cs = m_Clones(a)
  IsClone = True
  Exit Function
notExistant:
  IsClone = False
  Set cs = New CloneStuff
  m_Clones.Add cs, a
End Function


Sub StoreCellList(oxlwsheet As Worksheet, ByRef c As Collection, ByRef xlsarr As XLScriptArray)
    Dim item As Range
    Dim cs As String
    Dim r As Range
    If c.count > 0 Then
      For Each item In c
        If r Is Nothing Then
          Set r = item
         Else
          Set r = Union(r, item)
        End If
      Next item
      Dim r2 As Range
      For Each r2 In r.Areas
        If FullVersion = True Or xlsarr.items.count <= 3 Then
          xlsarr.AddValue "", oxlwsheet.name & "!" & StripChars(r2.Address, "$")
        Else
          'xlsarr.AddValue "", "Demo"
          xlsarr.AddValue "", FMT0("RESULT_2")
        End If
      Next r2
    End If

End Sub

Sub StoreSheetResulsts(oxlwsheet As Worksheet)

    StoreCellList oxlwsheet, m_CUnlockedFormulas, unlockedFormulaAreas
    Set m_CUnlockedFormulas = New Collection
    
    StoreCellList oxlwsheet, m_CErrorFormulas, errorFormulaCells
    Set m_CErrorFormulas = New Collection
    
    StoreCellList oxlwsheet, m_CErrorFormulaValues, errorFormulaValueCells
    Set m_CErrorFormulaValues = New Collection
    
    ' Die Ergebnisse
    sda.AddValue "NAME", oxlwsheet.name
    sda.AddValue "USEDCELLAMOUNT", totalUsedCellAmount - tabTotalUsedCellAmount
    sda.AddValue "FORMULAAMOUNT", foundFormulaAmount - tabFoundFormulaAmount
    
      
    ' *********************
    ' Und die Tabellenmappe
    ' *********************
    sda.AddValue "IFAMOUNT", foundIfAmount - tabFoundIfAmount
    sda.AddValue "CALCAMOUNT", foundCalcAmount - tabFoundCalcAmount
    If FullVersion Then
      sda.AddValue "SUMAMOUNT", foundSumAmount - tabFoundSumAmount
    Else
      sda.AddValue "SUMAMOUNT", "Demo"
    End If
    sda.AddValue "MATRIXAMOUNT", foundMatrixFuncs - tabFoundMatrixFuncs
    sda.AddValue "CELLREFERENCESAMOUNT", foundCellreferencesAmount - tabFoundCellreferencesAmount
    sda.AddValue "UNLOCKEDFORMULAS", foundUnlockedFormulas - tabFoundUnlockedFormulas
    sda.AddValue "UNLOCKEDFORMULASMISSINGSHEETPROTECTION", foundLockedFormulasMissingSheetprotect - tabFoundLockedFormulasMissingSheetprotect
    sda.AddValue "LOCKEDFORMULASWITHOUTSHEETPASSWORD", foundLockedFormulasWithoutSheetpassword - tabFoundLockedFormulasWithoutSheetpassword
    sda.AddValue "UNLOCKEDFORMULASNOTVISIBLE", foundUnlockedFormulasNotVisible - tabFoundUnlockedFormulasNotVisible
    sda.AddValue "HIDDENCOLUMNAMOUNT", foundHiddenColumnAmount - tabFoundHiddenColumnAmount
    sda.AddValue "HIDDENROWAMOUNT", foundHiddenRowAmount - tabFoundHiddenRowAmount
    If FullVersion Then
      sda.AddValue "HIDDENSHEETAMOUNT", foundHiddenWorksheetsAmount - tabFoundHiddenWorksheetsAmount - (foundVeryHiddenWorksheetsAmount - tabFoundVeryHiddenWorksheetsAmount)
    Else
      'sda.AddValue "HIDDENSHEETAMOUNT", "Demo"
      sda.AddValue "HIDDENSHEETAMOUNT", FMT0("RESULT_2")
    End If
    
    sda.AddValue "VERYHIDDENSHEETAMOUNT", foundVeryHiddenWorksheetsAmount - tabFoundVeryHiddenWorksheetsAmount
    
    sda.AddValue "CELLSWITHEXTERNALREFERENCESAMOUNT", foundCellsWithExternalReferences - tabFoundCellsWithExternalReferences
    
    If FullVersion Then
      sda.AddValue "FORMULADUPAMOUNT", foundFormulaDuplicateAmount - tabFoundFormulaDuplicateAmount
      sda.AddValue "FORMULAINDIVAMOUNT", foundFormulaAmount - tabFoundFormulaAmount - (foundFormulaDuplicateAmount - tabFoundFormulaDuplicateAmount)
    Else
      'sda.AddValue "FORMULADUPAMOUNT", "Demo"
      sda.AddValue "FORMULADUPAMOUNT", FMT0("RESULT_2")
      'sda.AddValue "FORMULAINDIVAMOUNT", "Demo"
      sda.AddValue "FORMULAINDIVAMOUNT", FMT0("RESULT_2")
    End If
    
    sda.AddValue "NUMBERFORMULAAMOUNT", foundNumberFormula - tabfoundNumberFormula
    
    sda.AddValue "IFDUPAMOUNT", foundIfDuplicateAmount - tabFoundIfDuplicateAmount
    sda.AddValue "IFINDIVAMOUNT", foundIfAmount - tabFoundIfAmount - (foundIfDuplicateAmount - tabFoundIfDuplicateAmount)
    
    sda.AddValue "CALCDUPAMOUNT", foundCalcDuplicateAmount - tabFoundCalcDuplicateAmount
    sda.AddValue "CALCINDIVAMOUNT", foundCalcAmount - tabFoundCalcAmount - (foundCalcDuplicateAmount - tabFoundCalcDuplicateAmount)
    
    
' .NET START
    sda.AddValue "DIAGRAMAMOUNT", foundDiagrams - tabFoundDiagrams
    sda.AddValue "QUERYAMOUNT", foundQueries - tabFoundQueries
    sda.AddValue "PIVOTAMOUNT", foundPivots - tabfoundPivots
' .NET END
    
    
    
    If FullVersion Then
      sda.AddValue "SUMDUPAMOUNT", foundSumDuplicateAmount - tabFoundSumDuplicateAmount
      sda.AddValue "SUMINDIVAMOUNT", foundSumAmount - tabFoundSumAmount - (foundSumDuplicateAmount - tabFoundSumDuplicateAmount)
      
      sda.AddValue "MATRIXDUPAMOUNT", foundMatrixDuplicateFuncs - tabFoundMatrixDuplicateFuncs
      sda.AddValue "MATRIXINDIVAMOUNT", foundMatrixFuncs - tabFoundMatrixFuncs - (foundMatrixDuplicateFuncs - tabFoundMatrixDuplicateFuncs)
    
      sda.AddValue "CELLREFERENCESDUPAMOUNT", foundCellreferencesAmount - tabFoundCellreferencesDuplicateAmount
      sda.AddValue "CELLREFERENCESINDIVAMOUNT", foundCellreferencesAmount - tabFoundCellreferencesAmount - (foundCellreferencesDuplicateAmount - tabFoundCellreferencesDuplicateAmount)
    
    Else
      'sda.AddValue "SUMDUPAMOUNT", "Demo"
      sda.AddValue "SUMDUPAMOUNT", FMT0("RESULT_2")
      'sda.AddValue "MATRIXDUPAMOUNT", "Demo"
      sda.AddValue "MATRIXDUPAMOUNT", FMT0("RESULT_2")
      'sda.AddValue "SUMINDIVAMOUNT", "Demo"
      sda.AddValue "SUMINDIVAMOUNT", FMT0("RESULT_2")
      'sda.AddValue "MATRIXINDIVAMOUNT", "Demo"
      sda.AddValue "MATRIXINDIVAMOUNT", FMT0("RESULT_2")
      'sda.AddValue "CELLREFERENCESDUPAMOUNT", "Demo"
      sda.AddValue "CELLREFERENCESDUPAMOUNT", FMT0("RESULT_2")
      'sda.AddValue "CELLREFERENCESINDIVAMOUNT", "Demo"
      sda.AddValue "CELLREFERENCESINDIVAMOUNT", FMT0("RESULT_2")
    End If
    
    sda.AddValue "NONANALYZABLECELLSAMOUNT", foundNonAnalyzableCells - tabFoundNonAnalyzableCells
        
    If FullVersion Then
      sda.AddValue "LONGESTFORMULA", CStr(tabLongestFormula)
    Else
      'sda.AddValue "LONGESTFORMULA", "Demo"
      sda.AddValue "LONGESTFORMULA", FMT0("RESULT_2")
    End If
    sda.AddValue "MAXOPENBRACCOUNT", CStr(tabMaxopenbracam)
        
    If G_CheckDimension Then
        sda.AddValue "DIMENSIONX", CStr(m_TabDimension.m_X)
        sda.AddValue "DIMENSIONY", CStr(m_TabDimension.m_Y)
        sda.AddValue "DIMENSION2D", CStr(m_TabDimension.m_XY)
        sda.AddValue "DIMENSION3D", CStr(m_TabDimension.m_Z)
    Else
        sda.AddValue "DIMENSIONX", "'-/-"
        sda.AddValue "DIMENSIONY", "'-/-"
        sda.AddValue "DIMENSION2D", "'-/-"
        sda.AddValue "DIMENSION3D", "'-/-"
    End If
        
End Sub


Sub StoreResults()

  XLScriptAddSimpleVar "SHEETAMOUNT", oxlwbook.Worksheets.count
  XLScriptAddSimpleVar "USEDCELLAMOUNT", totalUsedCellAmount
  XLScriptAddSimpleVar "NONANALYZABLECELLSAMOUNT", foundNonAnalyzableCells
  
  XLScriptAddSimpleVar "DIAGRAMAMOUNT", dda.items.count
  
  XLScriptAddSimpleVar "LONGESTFORMULA", longestFormula
  XLScriptAddSimpleVar "MAXOPENBRACCOUNT", maxopenbracam
  
  XLScriptAddSimpleVar "FORMULAAMOUNT", foundFormulaAmount
  XLScriptAddSimpleVar "FORMULAAMOUNTNOREFS", foundFormulaAmount - foundCellreferencesAmount
  XLScriptAddSimpleVar "IFAMOUNT", foundIfAmount
  XLScriptAddSimpleVar "CALCAMOUNT", foundCalcAmount
  XLScriptAddSimpleVar "SUMAMOUNT", foundSumAmount
  If FullVersion Then
    XLScriptAddSimpleVar "FORMULADUPAMOUNT", foundFormulaDuplicateAmount
    XLScriptAddSimpleVar "FORMULAINDIVAMOUNT", foundFormulaAmount - foundFormulaDuplicateAmount
    XLScriptAddSimpleVar "FORMULADUPAMOUNTNOREFS", foundFormulaDuplicateAmount - foundCellreferencesDuplicateAmount
    XLScriptAddSimpleVar "FORMULAINDIVAMOUNTNOREFS", foundFormulaAmount - foundFormulaDuplicateAmount - (foundCellreferencesAmount - foundCellreferencesDuplicateAmount)
    XLScriptAddSimpleVar "IFDUPAMOUNT", foundIfDuplicateAmount
    XLScriptAddSimpleVar "NUMBERFORMULAAMOUNT", foundNumberFormula
    XLScriptAddSimpleVar "IFINDIVAMOUNT", foundIfAmount - foundIfDuplicateAmount
    XLScriptAddSimpleVar "CALCDUPAMOUNT", foundCalcDuplicateAmount
    XLScriptAddSimpleVar "CALCINDIVAMOUNT", foundCalcAmount - foundCalcDuplicateAmount
    XLScriptAddSimpleVar "SUMDUPAMOUNT", foundSumDuplicateAmount
    XLScriptAddSimpleVar "SUMINDIVAMOUNT", foundSumAmount - foundSumDuplicateAmount
  Else
'    XLScriptAddSimpleVar "NUMBERFORMULAAMOUNT", "Demo"
'    XLScriptAddSimpleVar "FORMULADUPAMOUNT", "Demo"
'    XLScriptAddSimpleVar "FORMULAINDIVAMOUNT", "Demo"
'    XLScriptAddSimpleVar "FORMULADUPAMOUNTNOREFS", "Demo"
'    XLScriptAddSimpleVar "FORMULAINDIVAMOUNTNOREFS", "Demo"
'    XLScriptAddSimpleVar "CALCDUPAMOUNT", "Demo"
'    XLScriptAddSimpleVar "SUMDUPAMOUNT", "Demo"
'    XLScriptAddSimpleVar "FORMULAINDIVAMOUNT", "Demo"
'    XLScriptAddSimpleVar "IFINDIVAMOUNT", "Demo"
'    XLScriptAddSimpleVar "CALCINDIVAMOUNT", "Demo"
'    XLScriptAddSimpleVar "SUMINDIVAMOUNT", "Demo"
    XLScriptAddSimpleVar "NUMBERFORMULAAMOUNT", FMT0("RESULT_2")
    XLScriptAddSimpleVar "FORMULADUPAMOUNT", FMT0("RESULT_2")
    XLScriptAddSimpleVar "FORMULAINDIVAMOUNT", FMT0("RESULT_2")
    XLScriptAddSimpleVar "FORMULADUPAMOUNTNOREFS", FMT0("RESULT_2")
    XLScriptAddSimpleVar "FORMULAINDIVAMOUNTNOREFS", FMT0("RESULT_2")
    XLScriptAddSimpleVar "CALCDUPAMOUNT", FMT0("RESULT_2")
    XLScriptAddSimpleVar "SUMDUPAMOUNT", FMT0("RESULT_2")
    XLScriptAddSimpleVar "FORMULAINDIVAMOUNT", FMT0("RESULT_2")
    XLScriptAddSimpleVar "IFINDIVAMOUNT", FMT0("RESULT_2")
    XLScriptAddSimpleVar "CALCINDIVAMOUNT", FMT0("RESULT_2")
    XLScriptAddSimpleVar "SUMINDIVAMOUNT", FMT0("RESULT_2")
  End If
  
  
  ' SpecialCells Zeug
'  XLScriptAddSimpleVar "SUMDUPAMOUNT", foundSumDuplicateAmount
  XLScriptAddSimpleVar "MATRIXAMOUNT", foundMatrixFuncs
  XLScriptAddSimpleVar "MATRIXDUPAMOUNT", foundMatrixDuplicateFuncs
  XLScriptAddSimpleVar "MATRIXINDIVAMOUNT", foundMatrixFuncs - foundMatrixDuplicateFuncs
  
  XLScriptAddSimpleVar "CELLREFERENCESAMOUNT", foundCellreferencesAmount
  XLScriptAddSimpleVar "CELLREFERENCESDUPAMOUNT", foundCellreferencesDuplicateAmount
  XLScriptAddSimpleVar "CELLREFERENCESINDIVAMOUNT", foundCellreferencesAmount - foundCellreferencesDuplicateAmount
  
  
  XLScriptAddSimpleVar "UNLOCKEDFORMULAS", foundUnlockedFormulas
  XLScriptAddSimpleVar "UNLOCKEDFORMULASMISSINGSHEETPROTECTION", foundLockedFormulasMissingSheetprotect
  XLScriptAddSimpleVar "LOCKEDFORMULASWITHOUTSHEETPASSWORD", foundLockedFormulasWithoutSheetpassword
  XLScriptAddSimpleVar "UNLOCKEDFORMULASNOTVISIBLE", foundUnlockedFormulasNotVisible
  XLScriptAddSimpleVar "HIDDENCOLUMNAMOUNT", foundHiddenColumnAmount
  XLScriptAddSimpleVar "HIDDENROWAMOUNT", foundHiddenRowAmount
  
  If FullVersion Then
    XLScriptAddSimpleVar "HIDDENSHEETAMOUNT", foundHiddenWorksheetsAmount
    XLScriptAddSimpleVar "VERYHIDDENSHEETAMOUNT", foundVeryHiddenWorksheetsAmount
  Else
    'XLScriptAddSimpleVar "HIDDENSHEETAMOUNT", "Demo"
    XLScriptAddSimpleVar "HIDDENSHEETAMOUNT", FMT0("RESULT_2")
    'XLScriptAddSimpleVar "VERYHIDDENSHEETAMOUNT", "Demo"
    XLScriptAddSimpleVar "VERYHIDDENSHEETAMOUNT", FMT0("RESULT_2")
  End If
  XLScriptAddSimpleVar "DIAGRAMAMOUNT", foundDiagrams
' .NET START
  XLScriptAddSimpleVar "QUERYAMOUNT", foundQueries
  XLScriptAddSimpleVar "PIVOTAMOUNT", foundPivots
' .NET END
  
  XLScriptAddSimpleVar "CELLSWITHHYPERLINKSAMOUNT", foundHyperlinks
  XLScriptAddSimpleVar "CELLSWITHINTERNALHYPERLINKSAMOUNT", foundInternalHyperlinks
  XLScriptAddSimpleVar "CELLSWITHEXTERNALHYPERLINKSAMOUNT", foundExternalHyperlinks
  XLScriptAddSimpleVar "CELLSWITHEXTERNALREFERENCESAMOUNT", foundCellsWithExternalReferences
  
  If FullVersion Then
    XLScriptAddSimpleVar "EXTERNALREFERENCESAMOUNT", foundExternalReferences
    XLScriptAddSimpleVar "MISSINGEXTERNALREFERENCESAMOUNT", missingexternalFiles.items.count
  Else
    'XLScriptAddSimpleVar "EXTERNALREFERENCESAMOUNT", "Demo"
    XLScriptAddSimpleVar "EXTERNALREFERENCESAMOUNT", FMT0("RESULT_2")
    'XLScriptAddSimpleVar "MISSINGEXTERNALREFERENCESAMOUNT", "Demo"
    XLScriptAddSimpleVar "MISSINGEXTERNALREFERENCESAMOUNT", FMT0("RESULT_2")
  End If
  
  XLScriptAddSimpleVar "SHEETSWITHCIRCULARREFERENCESAMOUNT", circref.items.count
  XLScriptAddSimpleVar "PROTECTEDWORKSHEETS", protectedWorksheets
  XLScriptAddSimpleVar "UNPROTECTEDWORKSHEETS", unprotectedWorksheets
  XLScriptAddSimpleVar "PROTECTEDWORKSHEETSWITHPASSWORD", protectedWorksheetsWithPassword
  If FullVersion Then
    XLScriptAddSimpleVar "PROTECTEDWOKRSHEETSWITHOUTPASSWORD", protectedWorksheetsWithoutPassword
  Else
    'XLScriptAddSimpleVar "PROTECTEDWOKRSHEETSWITHOUTPASSWORD", "Demo"
    XLScriptAddSimpleVar "PROTECTEDWOKRSHEETSWITHOUTPASSWORD", FMT0("RESULT_2")
  End If
  
  CalculateNameAmount oxlwbook
  
  If G_CheckDimension Then
      XLScriptAddSimpleVar "DIMENSIONX", CStr(m_Dimension.m_X)
      XLScriptAddSimpleVar "DIMENSIONY", CStr(m_Dimension.m_Y)
      XLScriptAddSimpleVar "DIMENSION2D", CStr(m_Dimension.m_XY)
      XLScriptAddSimpleVar "DIMENSION3D", CStr(m_Dimension.m_Z)
  Else
      XLScriptAddSimpleVar "DIMENSIONX", "'-/-"
      XLScriptAddSimpleVar "DIMENSIONY", "'-/-"
      XLScriptAddSimpleVar "DIMENSION2D", "'-/-"
      XLScriptAddSimpleVar "DIMENSION3D", "'-/-"
  End If
  
  ' Ans Ende der mitprotokollierten Zellen, Spalten und Tabellen
  ' ein Endekennzeichen setzen.
    
  ' 18.4.03 - Nt - Checksummenausgabe
  XLScriptAddSimpleVar "CHECKSUM", Hex(checksum)
End Sub

Sub CalculateNameAmount(oxlwbook As Excel.Workbook)
  Dim item As name
  Dim cnt As Long
  Dim cntVisible As Long
  Dim cntInvisible As Long
  cnt = 0
  cntVisible = 0
  cntInvisible = 0
  For Each item In oxlwbook.names
    If Left(item.name, 11) <> "_IDVTracker" Then
      If UCase(Right(item.name, Len("!Print_Area"))) <> "!PRINT_AREA" And UCase(Right(item.name, Len(".PrintArea"))) <> ".PRINTAREA" And UCase(Right(item.name, Len(".FILTERDATA"))) <> ".FILTERDATA" Then
        cnt = cnt + 1
        If item.Visible Then
          cntVisible = cntVisible + 1
        Else
          cntInvisible = cntInvisible + 1
        End If
      End If
    End If
  Next item
  
  XLScriptAddSimpleVar "NAMEAMOUNT", cnt
  XLScriptAddSimpleVar "NAMEAMOUNTVISIBLE", cntVisible
  XLScriptAddSimpleVar "NAMEAMOUNTINVISIBLE", cntInvisible

End Sub

Sub CreateGlobalFuncArray()
  
  If Funcs Is Nothing Then Exit Sub
  
  Dim FuncArray
  Set FuncArray = XLScriptAddArray2D("XLFunctions")
  Dim item
  Dim first As Boolean
  first = True
  
  Dim res As Long
  For Each item In Funcs
    If Left(item.name, 4) <> "### " Then
      res = GetFuncResult(item.name)
      If res > 0 Then
        If Not item.Head Is Nothing Then
          item.Head.count = item.Head.count + res
          item.Head.SumCount = item.Head.SumCount + res
        End If
        item.count = item.count + res
      End If
    End If
  Next item
  
  FuncArray.AddXLScriptArray "Sonstige", "0"
  
  For Each item In Funcs
    If TypeName(item.Head) = "Nothing" Then
      If item.count > 0 Then
        FuncArray.AddXLScriptArray item.Trans, item.count ' Mid(item.name, 5), item.Count
      End If
    Else
      If item.count > 0 Then
        FuncArray.CurrentLine.AddNameAndValue item.Trans, item.count
      End If
    End If
  Next item
'  XLScriptRegisterGlobalObject "XLFunctions", FuncArray
  
  For Each item In m_FoundFuncs
    If Not item.m_Used Then
      XLScriptGetArray2D("XLFunctions").items( _
          "Sonstige").AddToValue "VAL", item.m_Count
      XLScriptGetArray2D("XLFunctions").items( _
          "Sonstige").AddNameAndValue item.m_Name, item.m_Count
    End If
  Next item
  
'  For Each funcItem In Funcs
'    If Left(funcItem.name, 4) <> "### " Then
'      res = GetFuncResult(funcItem.name)
'      If res > 0 Then
'        XLScriptGetArray2D("XLFunctions").items( _
'          Mid(funcItem.Head.name, 5)).items(funcItem.name).AddToValue "VAL", res
'      End If
'    End If
'  Next funcItem
  
  
  
End Sub

Sub CheckFunc(s As String)
  
  On Error GoTo notExistant
  Dim l As Long
  m_FoundFuncs(s).m_Count = m_FoundFuncs(s).m_Count + 1
  Exit Sub
notExistant:
  Dim ff As New FFuncs
  ff.m_Name = s
  ff.m_Count = 1
  m_FoundFuncs.Add ff, s
End Sub

Function GetFuncResult(s As String) As Long
  
  On Error GoTo notExistant
  Dim l As Long
  GetFuncResult = m_FoundFuncs(s).m_Count
  m_FoundFuncs(s).m_Used = True
  Exit Function
notExistant:
  GetFuncResult = 0
End Function



Sub StoreCircle(oxlwsheet As Worksheet)
      
  Dim c
  c = oxlwsheet.Parent.Parent.Calculation
  oxlwsheet.Parent.Parent.Calculation = xlCalculationAutomatic
      
  If Not oxlwsheet.CircularReference Is Nothing Then
    sda.AddValue "SHEETSWITHCIRCULARREFERENCESAMOUNT", "1"
    circref.AddLine
    circref.AddValue "TABLENAME", oxlwsheet.name
    circref.AddValue "FIRSTCIRCLE", StripChars(oxlwsheet.CircularReference.Address, "$")
  Else
    sda.AddValue "SHEETSWITHCIRCULARREFERENCESAMOUNT", "0"
  End If
  oxlwsheet.Parent.Parent.Calculation = c

End Sub


Sub CheckRiskContains(ByRef c As Range, uformula As String)

    If G_RiskContains Is Nothing Then Exit Sub

    Dim item As RiskVal
    For Each item In G_RiskContains
    
      Dim i As Long
      
      
      Dim truecnt As Long
      truecnt = 0
      For i = 1 To item.m_ParameterList.count
        Dim pos As Long
        pos = 1
        Do
'          If Left(item.m_ParameterList(i), 1) = "$" Then
'            pos = InStr(pos, uformula, Mid(item.m_ParameterList(i), 2))
'          Else
            pos = InStr(pos, uformula, item.m_ParameterList(i) & "(")
'          End If
          If pos <= 0 Then Exit Do
          ' Jetzt noch pr|fffd|fen, ob das wirklich die Formel ist oder nur ein Teil der Formel!
          Dim a As String
          a = Mid(uformula, pos - 1, 1)
          If (a >= "a" And a <= "z") Or (a >= "A" And a <= "Z") Then
            ' Wenn vor der Funktion noch Buchstaben sind, dann z|fffd|hlt die Funktion nicht!
          Else
            truecnt = truecnt + 1
          End If
          pos = pos + 1
        Loop
      Next i
    
      If truecnt >= item.m_IdenticalAm Then
        item.m_Matches = item.m_Matches + 1
        If item.m_Matches = 1 Then
          item.m_FirstMatch = uformula
          item.m_FirstMatchAddress = StripChars(c.Address, "$")
        End If
      End If
                
        
    Next item
    

End Sub
Function CheckOpenBracAm(ByRef c As Range, ByRef cs As CloneStuff) As Long
    Dim pos As Long
    Dim posopen As Long
    Dim posclose As Long
    Dim bracam As Long
    
    bracam = 0
    pos = 1
    
    
    Dim formulaStr As String
    formulaStr = RemoveStrings(c.Formula, Chr(34), Chr(34))
    formulaStr = RemoveStrings(formulaStr, "'", "'")
'    formulaStr = RemoveStrings(formulaStr, "[", "]")
    
    ' Sehr sch|fffd|n, wenn jetzt eine Klammer drin ist, dann ist es keine Referenz
    If InStr(formulaStr, "(") <= 0 Then
      ' So, jetzt d|fffd|rfen nur noch Buchstaben, der underscore, Zahlen und das Ausrufungszeichen enthalten sein
      Dim i As Long
      Dim ok As Boolean
      ok = True
      For i = 2 To Len(formulaStr)
        Dim tval As String
        tval = Mid(formulaStr, i, 1)
        If Not ((tval >= "a" And tval <= "z") Or _
                (tval >= "A" And tval <= "Z") Or _
                (tval >= "0" And tval <= "9") Or _
                tval = "_" Or _
                tval = "$" Or _
                tval = "!") Then
                ok = False
                Exit For
        End If
      Next i
      If ok Then
        foundCellreferencesAmount = foundCellreferencesAmount + 1
        cs.m_Ref = 1
      End If
    End If
    
    
    Do
      
      
      posopen = InStr(pos, formulaStr, "(")
      posclose = InStr(pos, formulaStr, ")")
      
      If posopen <= 0 Then
        Exit Do
      ElseIf posopen < posclose Then
        bracam = bracam + 1
        pos = posopen + 1
      ElseIf posclose > 0 And posclose < posopen Then
        bracam = bracam - 1
        pos = posclose + 1
      End If
      
      If bracam > maxopenbracam Then
        maxopenbracam = bracam
      End If
      If bracam > tabMaxopenbracam Then
        tabMaxopenbracam = bracam
      End If
    Loop
    
    CheckOpenBracAm = bracam

End Function



Sub CheckDimensions(ByRef wb As Workbook, ByRef c As Range, ByRef x As Long, ByRef y As Long, ByRef z As Long, ByRef xy As Long)
  
  x = 0
  y = 0
  z = 0
  xy = 0
  Dim deps As Collection
  
  Set deps = Nothing
  If GetArrows(c, deps, True, False) Then
    If Not deps Is Nothing Then
      Dim cc As Range
      For Each cc In deps
        If Abs(c.Column - cc.Column) > x Then x = Abs(c.Column - cc.Column)
        If Abs(c.Row - cc.Row) > y Then y = Abs(c.Row - cc.Row)
        
        Dim txy As Long
        If x = 0 And y = 0 Then
          txy = 0
        Else
          txy = IIf(Abs(c.Column - cc.Column) <= 0, 1, Abs(c.Column - cc.Column)) * IIf(Abs(c.Row - cc.Row) <= 0, 1, Abs(c.Row - cc.Row))
        End If
        
        If txy > xy Then xy = txy
        
        Dim pos1 As Long
        Dim pos2 As Long
        Dim s As Worksheet
        Dim i As Long
        i = 1
        pos1 = 0
        pos2 = 0
        
        Dim cnt As Long
        For cnt = 1 To wb.Sheets.count
'          Set s = wb.Sheets(cnt)
          If wb.Sheets(cnt).name = c.Parent.name Then pos1 = i
          If wb.Sheets(cnt).name = cc.Parent.name Then pos2 = i
          If pos1 > 0 And pos2 > 0 Then Exit For
          i = i + 1
        Next cnt
        If Abs(pos1 - pos2) > z Then z = Abs(pos1 - pos2)
        
        
      Next cc
    End If
  End If

End Sub

Sub CheckLibs(ByRef oxlwbook As Workbook)
On Error Resume Next
  Dim libs As Object
  Set libs = XLScriptAddArray2D("LIBS")
  
  Dim x As Long
  With ActiveWorkbook.VBProject
    For x = 1 To .References.count
      libs.AddLine
      libs.AddValue "LIBNAME", UCase(.References(x).name)
      libs.AddValue "LIBDESCRIPTION", .References(x).Description
      libs.AddValue "LIBTYPE", .References(x).Type
      libs.AddValue "MAJOR", .References(x).Major
      libs.AddValue "MINOR", .References(x).Minor
      libs.AddValue "PATH", UCase(.References(x).fullpath)
      libs.AddValue "GUID", .References(x).GUID
      libs.AddValue "BUILTIN", .References(x).BuiltIn
      libs.AddValue "ISBROKEN", .References(x).isbroken
    Next x
  End With

  Set libs = Nothing
End Sub
Attribute VB_Name = "RiskRange"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public m_Comparison As Long
Public m_Value As Long
Public m_Risk As Double

Attribute VB_Name = "RiskTab"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public m_TabName As String
Public m_Vals As Collection

Public m_Weight As Double
Public m_Low As Double
Public m_LowColour As Long
Public m_LowMulti As Double
Public m_Med As Double
Public m_MedColour As Long
Public m_MedMulti As Double
Public m_HighColour As Long
Public m_HighMulti As Double

Private Sub Class_Initialize()
  Set m_Vals = New Collection
End Sub

Public Function Init(wb As Workbook, y As Long, path As String, ByVal resultfname As String)
  Init = False
  
  Dim risiken As String
  Dim regeln As String
  risiken = TranslationSheetExists(wb, Array("Risiken", "Risks"))
  regeln = TranslationSheetExists(wb, Array("Regeln", "Rules"))
  
  m_TabName = wb.Worksheets(risiken).Cells(y, 1)
  
  If Not WorksheetExists(wb, regeln) Then
    'MsgBox "Es existiert keine Tabelle mit dem Namen 'Regeln' in der Datei '" & ThisWorkbook.path & "\Excel-Sheet-Checker Risk.xls' fehlt. F|fffd|r den Bereich '" & m_TabName & "' kann keine Risikoanalyse vorgenommen werden!", vbCritical, "Excel-Sheet-Checker"
    MsgBox FMT2("RISKTAB_1", path, m_TabName), vbCritical, ProgNameLong
    Exit Function
  End If
  
  Dim y2 As Long
  y2 = 2
  Dim rv As RiskVal
  Do While Not IsEmpty(wb.Sheets(regeln).Cells(y2, 1)) Or Not IsEmpty(wb.Sheets(regeln).Cells(y2 + 1, 1)) Or Not IsEmpty(wb.Sheets(regeln).Cells(y2 + 2, 1))
    If Not IsEmpty(wb.Sheets(regeln).Cells(y2, 1)) Then
      If wb.Sheets(regeln).Cells(y2, 1) = m_TabName Then
        Set rv = New RiskVal
        If Not rv.Init(wb.Sheets(regeln), y2, resultfname) Then
          Exit Function
        End If
        If wb.Sheets(regeln).Cells(y2, 3).value = "DIMENSIONX" Or wb.Sheets(regeln).Cells(y2, 3).value = "DIMENSIONY" Or wb.Sheets(regeln).Cells(y2, 3).value = "DIMENSION3D" Then
          G_RiskHadDimension = True
        End If
        m_Vals.Add rv
      End If
    End If
    y2 = y2 + 1
  Loop
  
  With wb.Worksheets(risiken)
    m_Weight = .Cells(y, 2)
    m_Low = .Cells(y, 3)
    m_LowColour = .Cells(y, 4).Interior.Color
    m_LowMulti = .Cells(y, 5)
    m_Med = .Cells(y, 6)
    m_MedColour = .Cells(y, 7).Interior.Color
    m_MedMulti = .Cells(y, 8)
    m_HighColour = .Cells(y, 9).Interior.Color
    m_HighMulti = .Cells(y, 10)
  End With
  
  ' Und dann noch die Einzelwerte besorgen
  
  
  
  Init = True
End Function


Public Function InitDB(conn, riskrs)
  InitDB = False
  
  m_TabName = riskrs.Fields("Risiko").value
  
  Dim rs
  Set rs = CreateObject("ADODB.recordset")
  rs.Open "SELECT * FROM ECCRegeln WHERE ECCRisikoID = " & riskrs.Fields("ECCRisikoID").value, conn, 2, 1
  If rs.EOF Then
    'MsgBox "Es sind keine Regeln f|fffd|r das Risiko '" & riskrs.Fields("ECCRisikoID").value & "' in der Datenbank des IDV-Trackers enthalten. Es kann keine Gesamtrisikoanalyse vorgenommen werden!", vbCritical, "Excel-Sheet-Checker"
    MsgBox FMT1("RISKTAB_2", riskrs.Fields("ECCRisikoID").value), vbCritical, ProgNameLong
    rs.Close
    Set rs = Nothing
    Exit Function
  End If
  
  Dim rv As RiskVal
  Do While Not rs.EOF
    Set rv = New RiskVal
    If Not rv.InitDB(conn, rs) Then
      Exit Function
    End If
    m_Vals.Add rv
    rs.movenext
  Loop
  
  rs.Close
  Set rs = Nothing
  
  With riskrs
    m_Weight = .Fields("Gewichtung").value
    m_Low = .Fields("Gering").value
    m_LowColour = .Fields("GeringFarbe").value
    m_LowMulti = .Fields("GeringMultiplikator").value
    m_Med = .Fields("Mittel").value
    m_MedColour = .Fields("MittelFarbe").value
    m_MedMulti = .Fields("MittelMultiplikator").value
    m_HighColour = .Fields("HochFarbe").value
    m_HighMulti = .Fields("HochMultiplikator").value
  End With
  
  ' Und dann noch die Einzelwerte besorgen
  
  
  
  InitDB = True
End Function

Attribute VB_Name = "RiskVal"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public m_Type As Long
Public m_Parameter As String
Public m_Vals As Collection
Public m_ParameterList As Collection
Public m_IdenticalAm As Long
Public m_Matches As Long
Public m_FirstMatch As String
Public m_FirstMatchAddress As String
Public m_Hit As Boolean

Private Sub Class_Initialize()
  Set m_Vals = New Collection
End Sub


Public Function Init(ws As Worksheet, line As Long, ByVal resultfname As String) As Boolean
  
  Dim pos As Long
  Dim param As String
  
  Init = False
  Select Case ws.Cells(line, 2)
    Case "ECC"
          m_Type = C_RISK_TYPE_ECC
    Case "Formula contains", "Formel enth|fffd|lt"
          m_Type = C_RISK_TYPE_FORMULA_CONTAINS
          
          Set m_ParameterList = New Collection
          
          m_Matches = 0
          m_FirstMatch = ""
          
          param = ws.Cells(line, 3)
    
          pos = InStr(param, ",")
          If pos <= 0 Then
            'MsgBox "ERROR: 'Formel enth|fffd|lt' muss als ersten Wert in 'Parameter / Schl|fffd|ssewort' einen numerischen Wert aufweisen! Datei 'Excel-Sheet-Checker Risk.xls' Tabelle '" & ws.name & " Zeile " & line, vbCritical, "Excel-Sheet-Checker"
            MsgBox FMT3("RISKFILEERR_1", ws.name, line, resultfname), vbCritical, ProgNameLong
            Exit Function
          End If
          If Not IsNumeric(Trim(Left(param, pos - 1))) Then
            'MsgBox "ERROR: 'Formel enth|fffd|lt' muss als ersten Wert in 'Parameter / Schl|fffd|ssewort' einen numerischen Wert aufweisen! Datei 'Excel-Sheet-Checker Risk.xls' Tabelle '" & ws.name & " Zeile " & line, vbCritical, "Excel-Sheet-Checker"
            MsgBox FMT3("RISKFILEERR_1", ws.name, line, resultfname), vbCritical, ProgNameLong
            Exit Function
          End If
          
          m_IdenticalAm = CLng(Trim(Left(param, pos - 1)))
          param = Mid(param, pos + 1)
          
          Do
            pos = InStr(param, ",")
            If pos <= 0 Then Exit Do
            If Left(Trim(Left(param, pos - 1)), 1) = "$" Or Left(Trim(Left(param, pos - 1)), 1) = "|" Then
              m_ParameterList.Add UCase(Trim(Left(param, pos - 1)))
            Else
              m_ParameterList.Add UCase(TranslateFuncToE(Trim(Left(param, pos - 1))))
            End If
            param = Mid(param, pos + 1)
          Loop
                
          If Len(param) > 0 Then
            m_ParameterList.Add Trim(param)
          End If
          
          G_RiskContains.Add Me
      
    Case "In list", "Not in list", "Nicht in Liste"
          
          Set m_ParameterList = New Collection
          
          m_Matches = 0
          m_FirstMatch = ""
          
          If ws.Cells(line, 2) = "Whitelist" Then
            m_Type = C_RISK_TYPE_WHITE_LIST
          Else
            m_Type = C_RISK_TYPE_NOT_IN_WHITE_LIST
          End If
          
          param = ws.Cells(line, 3)
    
          Do
            pos = InStr(param, ",")
            If pos <= 0 Then Exit Do
            If Left(Trim(Left(param, pos - 1)), 1) = "$" Or Left(Trim(Left(param, pos - 1)), 1) = "|" Then
              m_ParameterList.Add UCase(Trim(Left(param, pos - 1)))
            Else
              m_ParameterList.Add UCase(TranslateFuncToE(Trim(Left(param, pos - 1))))
            End If
            param = Mid(param, pos + 1)
          Loop
                
          If Len(param) > 0 Then
            m_ParameterList.Add Trim(param)
          End If
          
          
          G_WhiteList.Add Me
      
    Case Else
      'MsgBox "ERROR: Unbekannter Typ '" & ws.Cells(line, 2) & "' in 'Excel-Sheet-Checker Risk.xls' Tabelle '" & ws.name & " Zeile " & line, vbCritical, "Excel-Sheet-Checker"
      MsgBox FMT4("RISKFILEERR_2", ws.Cells(line, 2), ws.name, line, resultfname), vbCritical, ProgNameLong
      Exit Function
  End Select
  
  m_Parameter = ws.Cells(line, 3)
  If m_Parameter = "MODULEAMOUNT" Then
    m_Parameter = "VBAMODULEAMOUNT"
  End If
  Dim x As Long
  x = 4
  With ws
    Do While Not IsEmpty(.Cells(line, x))
      If Not AddVal(ws, x, .Cells(line, x), .Cells(line, x + 1), .Cells(line, x + 2), ws.name, line, resultfname) Then Exit Function
      x = x + 3
    Loop
  End With
  Init = True
  
End Function

Public Function AddVal(ws As Worksheet, x As Long, comp As String, v As String, risk As Double, sheetname As String, line As Long, ByVal resultfname As String) As Boolean
  AddVal = False
  Dim rr As New RiskRange
  Select Case comp
    Case "<"
      rr.m_Comparison = C_RISK_COMP_TYPE_LESS
    Case "<="
      rr.m_Comparison = C_RISK_COMP_TYPE_LESSEQUAL
    Case "="
      rr.m_Comparison = C_RISK_COMP_TYPE_EQUAL
    Case ">="
      rr.m_Comparison = C_RISK_COMP_TYPE_LARGEREQUAL
    Case ">"
      rr.m_Comparison = C_RISK_COMP_TYPE_LARGER
    Case Else
      'MsgBox "ERROR: Unbekannter Vergleichsoperator '" & comp & "' in 'Excel-Sheet-Checker Risk.xls' Tabelle '" & sheetname & " Zelle " & ws.Cells(line, x).Address, vbCritical, "Excel-Sheet-Checker"
      MsgBox FMT4("RISKFILEERR_3", comp, sheetname, ws.Cells(line, x).Address, resultfname), vbCritical, ProgNameLong
      Exit Function
  End Select
  
  If Not IsNumeric(v) Then
    'MsgBox "ERROR: Nicht numerischer Wert in 'Excel-Sheet-Checker Risk.xls' Tabelle '" & sheetname & " Zelle " & ws.Cells(line, x + 1).Address, vbCritical, "Excel-Sheet-Checker"
    MsgBox FMT3("RISKFILEERR_4", sheetname, ws.Cells(line, x + 1).Address, resultfname), vbCritical, ProgNameLong
    Exit Function
  End If
  
  If Not IsNumeric(risk) Then
    'MsgBox "ERROR: Nicht numerischer Wert in 'Excel-Sheet-Checker Risk.xls' Tabelle '" & sheetname & " Zelle " & ws.Cells(line, x + 2).Address, vbCritical, "Excel-Sheet-Checker"
    MsgBox FMT3("RISKFILEERR_4", sheetname, ws.Cells(line, x + 1).Address, resultfname), vbCritical, ProgNameLong
    Exit Function
  End If
  
  If Val(risk) < 0 Or Val(risk) > 1 Then
    'MsgBox "ERROR: Risiko muss zwischen 0% und 100% liegen in 'Excel-Sheet-Checker Risk.xls' Tabelle '" & sheetname & " Zelle " & ws.Cells(line, x + 1).Address, vbCritical, "Excel-Sheet-Checker"
    MsgBox FMT3("RISKFILEERR_5", sheetname, ws.Cells(line, x + 1).Address, resultfname), vbCritical, ProgNameLong
    Exit Function
  End If
  
  
  rr.m_Value = v
  rr.m_Risk = risk
  
  m_Vals.Add rr
  
  AddVal = True
End Function




Sub CheckFunc(s As String)
  Dim i As Long
  If m_ParameterList.count <= 0 Then Exit Sub
  Dim foundone As Boolean
  For i = 1 To m_ParameterList.count
    If m_ParameterList(i) = s Then
      foundone = True
      Exit For
    End If
  Next i

  If foundone Then
    If m_Type = C_RISK_TYPE_WHITE_LIST Then
      m_Hit = True
      m_Matches = m_Matches + 1
    End If
  Else
    If m_Type = C_RISK_TYPE_NOT_IN_WHITE_LIST Then
      m_Hit = True
      m_Matches = m_Matches + 1
    End If
  End If

End Sub


Public Function InitDB(conn, rs) As Boolean
  
  Dim pos As Long
  Dim param As String
  
  InitDB = False
  
  Select Case rs.Fields("ECCTypID").value
    Case C_RISK_TYPE_ECC
          m_Type = C_RISK_TYPE_ECC
    Case C_RISK_TYPE_FORMULA_CONTAINS
          m_Type = C_RISK_TYPE_FORMULA_CONTAINS
          
          Set m_ParameterList = New Collection
          
          m_Matches = 0
          m_FirstMatch = ""
          
          param = rs.Fields("Parameter").value
    
          pos = InStr(param, ",")
          If pos <= 0 Then
            'MsgBox "ERROR: 'Formul enth|fffd|lt' muss als ersten Wert in 'Parameter / Schl|fffd|ssewort' einen numerischen Wert aufweisen! Tabelle 'ECCRegeln'", vbCritical, "Excel-Sheet-Checker"
            MsgBox FMT0("RISKVAL_6"), vbCritical, ProgNameLong
            Exit Function
          End If
          If Not IsNumeric(Trim(Left(param, pos - 1))) Then
            'MsgBox "ERROR: 'Formul enth|fffd|lt' muss als ersten Wert in 'Parameter / Schl|fffd|ssewort' einen numerischen Wert aufweisen! Tabelle 'ECCRegeln'", vbCritical, "Excel-Sheet-Checker"
            MsgBox FMT0("RISKVAL_6"), vbCritical, ProgNameLong
            Exit Function
          End If
          
          m_IdenticalAm = CLng(Trim(Left(param, pos - 1)))
          param = Mid(param, pos + 1)
          
          Do
            pos = InStr(param, ",")
            If pos <= 0 Then Exit Do
            If Left(Trim(Left(param, pos - 1)), 1) = "$" Or Left(Trim(Left(param, pos - 1)), 1) = "|" Then
              m_ParameterList.Add UCase(Trim(Left(param, pos - 1)))
            Else
              m_ParameterList.Add UCase(TranslateFuncToE(Trim(Left(param, pos - 1))))
            End If
            param = Mid(param, pos + 1)
          Loop
                
          If Len(param) > 0 Then
            m_ParameterList.Add Trim(param)
          End If
          
          G_RiskContains.Add Me
      
    Case C_RISK_TYPE_WHITE_LIST, C_RISK_TYPE_NOT_IN_WHITE_LIST
          
          m_Type = rs.Fields("ECCTypID").value
          
          Set m_ParameterList = New Collection
          
          m_Matches = 0
          m_FirstMatch = ""
          
          m_Type = rs.Fields("ECCTypID").value
          
          param = rs.Fields("Parameter").value
    
          Do
            pos = InStr(param, ",")
            If pos <= 0 Then Exit Do
            If Left(Trim(Left(param, pos - 1)), 1) = "$" Or Left(Trim(Left(param, pos - 1)), 1) = "|" Then
              m_ParameterList.Add UCase(Trim(Left(param, pos - 1)))
            Else
              m_ParameterList.Add UCase(TranslateFuncToE(Trim(Left(param, pos - 1))))
            End If
            param = Mid(param, pos + 1)
          Loop
                
          If Len(param) > 0 Then
            m_ParameterList.Add Trim(param)
          End If
          
          
          G_WhiteList.Add Me
      
    Case Else
      'MsgBox "ERROR: Unbekannter Typ in Tabelle 'ECCRegeln'", vbCritical, "Excel-Sheet-Checker"
      MsgBox FMT0("RISKVAL_7"), vbCritical, ProgNameLong
      Exit Function
  End Select
  
  m_Parameter = rs.Fields("Parameter").value
  If m_Parameter = "MODULEAMOUNT" Then
    m_Parameter = "VBAMODULEAMOUNT"
  End If
  
  
  Dim errs
  Set errs = CreateObject("ADODB.recordset")
  errs.Open "SELECT * FROM ECCEinzelregeln WHERE ECCRegelID = " & rs.Fields("ECCRegelID").value & " ORDER BY id", conn, 2, 1
  If errs.EOF Then
    'MsgBox "Es sind keine Einzelregeln f|fffd|r die Regel '" & rs.Fields("ECCRegelID").value & "' in der Datenbank des IDV-Trackers enthalten. Es kann keine Gesamtrisikoanalyse vorgenommen werden!", vbCritical, "Excel-Sheet-Checker"
    MsgBox FMT1("RISKVAL_8", rs.Fields("ECCRegelID").value), vbCritical, ProgNameLong
    errs.Close
    Set errs = Nothing
    Exit Function
  End If
  
  
  Do While Not errs.EOF
    If Not AddValDB(errs.Fields("OperatorID").value, errs.Fields("GefundeneZellen").value, errs.Fields("Risiko").value) Then Exit Function
    errs.movenext
  Loop
  InitDB = True
  
End Function


Public Function AddValDB(comp As String, v As String, risk As Double) As Boolean
  AddValDB = False
  Dim rr As New RiskRange
  
  rr.m_Comparison = comp
  
  If Val(risk) < 0 Or Val(risk) > 1 Then
    'MsgBox "ERROR: Risiko muss zwischen 0% und 100% liegen in Tabelle 'ECCEinzelregeln', Spalte 'Risiko'", vbCritical, "Excel-Sheet-Checker"
    MsgBox FMT0("RISKVAL_9"), vbCritical, ProgNameLong
    Exit Function
  End If
  
  rr.m_Value = v
  rr.m_Risk = risk
  
  m_Vals.Add rr
  
  AddValDB = True
End Function

Attribute VB_Name = "SWAPPIds"
Option Explicit

Public Enum StromwerkenAppID
SWAPPID_IDVSuite = 1
SWAPPID_ExcelTracker = 2
SWAPPID_AccessTracker = 3
SWAPPID_ExcelSheetChecker = 4
SWAPPID_IDVSuiteScheduler = 5
SWAPPID_PluginCheck = 6
SWAPPID_ECCDaemon = 7
SWAPPID_ExcelFileCompare = 8
SWAPPID_ExcelSheetQA = 9
SWAPPID_ExcelProtect = 10
SWAPPID_ACCDaemon = 11
SWAPPID_SWKeyManager = 12
SWAPPID_AccessChecker = 13
SWAPPID_FileTracker = 14
End Enum

Attribute VB_Name = "SWFuncsHelpers"
Option Explicit

Private Const INTERNET_OPEN_TYPE_PRECONFIG = 0
Private Const INTERNET_FLAG_RELOAD = &H80000000
Private Const INTERNET_FLAG_KEEP_CONNECTION = &H400000
Private Const INTERNET_FLAG_NO_CACHE_WRITE = &H4000000

Private Const PROCESS_QUERY_INFORMATION = &H400
Private Const PROCESS_ALL_ACCESS = &H1F0FFF
Private Const STILL_ACTIVE = &H103

Private Const NORMAL_PRIORITY_CLASS = &H20
Private Const IDLE_PRIORITY_CLASS = &H40
Private Const HIGH_PRIORITY_CLASS = &H80
Private Const REALTIME_PRIORITY_CLASS = &H100

#If VBA7 Then
        Private Declare PtrSafe Function SetPriorityClass Lib _
          "kernel32" (ByVal hProcess As Long, _
          dwPriorityClass As Long) As Long
        
        Private Declare PtrSafe Function GetExitCodeProcess Lib _
          "kernel32" (ByVal hProcess As Long, _
          lpExitCode As Long) As Long
        
        Public Declare PtrSafe Sub Sleep Lib "kernel32" (ByVal _
          dwMilliseconds As Long)
        
        Private Declare PtrSafe Function OpenProcess Lib "kernel32" _
          (ByVal dwDesiredAccess As Long, _
          ByVal bInheritHandle As Long, _
          ByVal dwProcessId As Long) As Long
        
        Private Declare PtrSafe Function TerminateProcess Lib "kernel32" ( _
            ByVal hProcess As Long, _
            ByVal uExitCode As Long _
            ) As Long
            
        Public Declare PtrSafe Function CloseHandle Lib "kernel32" ( _
            ByVal hObject As LongPtr _
            ) As Long

#Else

        Private Declare Function SetPriorityClass Lib _
          "kernel32" (ByVal hProcess As Long, _
          dwPriorityClass As Long) As Long
        
        Private Declare Function GetExitCodeProcess Lib _
          "kernel32" (ByVal hProcess As Long, _
          lpExitCode As Long) As Long
        
        Public Declare Sub Sleep Lib "kernel32" (ByVal _
          dwMilliseconds As Long)
        
        Private Declare Function OpenProcess Lib "kernel32" _
          (ByVal dwDesiredAccess As Long, _
          ByVal bInheritHandle As Long, _
          ByVal dwProcessId As Long) As Long
        
        Private Declare Function TerminateProcess Lib "kernel32" ( _
            ByVal hProcess As Long, _
            ByVal uExitCode As Long _
            ) As Long
            
        Public Declare Function CloseHandle Lib "kernel32" ( _
            ByVal hObject As Long _
            ) As Long
#End If
Public trs As String
Public trsShrt As String
Public FullVersion As Boolean

Function GetLine(ByRef txt As String) As String
  Dim pos As Long
  Dim res As String
  pos = InStr(txt, vbCr)
  If pos > 0 Then
    res = Left(txt, pos - 1)
  Else
    res = txt
  End If
  If pos > 0 Then
    txt = Mid(txt, 2 + pos)
  Else
    txt = ""
  End If
  
  GetLine = res

End Function

Function MyFileLen(fname As String) As Long
  On Error GoTo nogo:
  MyFileLen = 0
  If UCase(Left(fname, 5)) = "HTTP:" Or UCase(Left(fname, 6)) = "HTTPS:" Then
    Dim sz As Long
    Dim modDate As Date
    If URLExists(fname, sz, modDate) Then
      MyFileLen = sz
    End If
  Else
    MyFileLen = fileLen(fname)
  End If
  Exit Function
nogo:
End Function
Function MyFileDateTime(ByVal fname As String) As Date
  MyFileDateTime = 0
  On Error GoTo nogo
  If UCase(Left(fname, 5)) = "HTTP:" Or UCase(Left(fname, 6)) = "HTTPS:" Then
    Dim sz As Long
    Dim modDate As Date
    If URLExists(fname, sz, modDate) Then
      MyFileDateTime = modDate
    End If
  Else
    MyFileDateTime = FileDateTime(fname)
  End If
  Exit Function
nogo:
  If Len(fname) > 260 Then
     MyFileDateTime = MyFileDateTimeLongName(fname)
  Else
    DebugPrint tdebug, "MyFileDateTime failed for: '" & fname & "' - " & Err.Number & " - " & Err.Description
  End If
End Function

Function MyFileDateTimeLongName(fname As String) As Date
On Error GoTo nogo
    If Len(fname) > 260 Then
        fname = "\\?\UNC\" & Mid$(fname, 3)
    End If
    
    Dim fs
    Dim f
    Set fs = CreateObject("Scripting.FileSystemObject")
    Set f = fs.GetFile(fname)
    
    MyFileDateTimeLongName = f.DateLastModified
    Exit Function
nogo:
    DebugPrint tdebug, "MyFileDateTimeLongName failed for: '" & fname & "' - " & Err.Number & " - " & Err.Description
    MyFileDateTimeLongName = 0
End Function

Function FileExists(ByVal Dateiname$) As Boolean
    'Die Funktion pr|fffd|ft, ob eine Datei vorhanden ist
On Error GoTo fehler:
  Dim res As Boolean
  If UCase(Left(Dateiname, 5)) = "HTTP:" Or UCase(Left(Dateiname, 6)) = "HTTPS:" Then
    Dim sz As Long
    Dim modDate As Date
    FileExists = URLExists(Dateiname, sz, modDate)
  Else
    res = Dir$(Dateiname) <> ""
    If res = False Then
      res = Dir$(GetDriveAndPathFromUNC(Dateiname)) <> ""
    End If
    FileExists = res
  End If
    Exit Function
fehler:
    FileExists = False
    If Len(Dateiname) > 260 Then
        FileExists = MyFileExistsLongName(Dateiname)
    End If
End Function

Function MyFileExistsLongName(ByVal fname As String) As Boolean
On Error GoTo nogo
    If Len(fname) > 260 Then
        fname = "\\?\UNC\" & Mid$(fname, 3)
    End If
    
    Dim fs
    Set fs = CreateObject("Scripting.FileSystemObject")
    MyFileExistsLongName = fs.FileExists(fname)
    Exit Function
nogo:
    MyFileExistsLongName = False
End Function

Function URLExists(url As String, ByRef sz As Long, ByRef modDate As Date) As Boolean
    Dim Request As Object
    Dim ff As Integer
    Dim rc As Variant
    On Error GoTo EndNow
    sz = 0
    modDate = 0
    URLExists = False
    Set Request = CreateObject("MSXML2.XMLHTTP")
    With Request
      .Open "HEAD", url, False
      Request.SetRequestHeader "Cache-Control", "no-store, no-cache"
      Request.SetRequestHeader "Pragma", "no-cache"
      .Send
      If .readyState = 4 Then
        URLExists = True
        sz = .getResponseHeader("Content-Length")
        Dim s As String
        s = Mid(Request.getResponseHeader("Last-Modified"), 6, 1000)
        s = Left(s, Len(s) - 4)
        modDate = CDate(s)
      Else
        .abort
      End If
    End With
    Set Request = Nothing
    Exit Function
EndNow:
    Debug.Print Err.Description
    Set Request = Nothing
End Function

Function MySpc(l As Long) As String
  If l > 0 Then
    Dim i As Long
    For i = 1 To l
      MySpc = MySpc + " "
    Next i
  End If
End Function

Function MakeFileName(n As String)
  Dim newn As String
  Dim i As Long
  If Len(i) > 0 Then
    For i = 1 To Len(n)
      Select Case Mid(n, i, 1)
        Case ":"
          newn = newn & "-"
        Case "\", "/", "*", "?", Chr(34), "<", ">", "|"
          newn = newn & "_"
        Case Else
          newn = newn + Mid(n, i, 1)
      End Select
    Next i
  End If
  MakeFileName = newn
End Function

Function InStrMyRev(str As String, v As String, Optional pos As Long = 0) As Long
  Dim i As Long
  If Not IsMissing(pos) And pos > 0 Then
    i = pos
  Else
    i = Len(str)
  End If
  Do While i > 0
    If Mid(str, i, Len(v)) = v Then
      InStrMyRev = i
      Exit Function
    End If
    i = i - 1
  Loop
  InStrMyRev = 0
End Function

Function FileUpToDate(dst As String, src As String)
  FileUpToDate = True
'  If Not FileExists(dst) Then
'    FileUpToDate = False
'    Exit Function
'  ElseIf MyFileDateTime(dst) < MyFileDateTime(src) Then
  On Error GoTo dstFileMissing
  
  If MyFileDateTime(dst) < MyFileDateTime(src) Then
    FileUpToDate = False
    Exit Function
  End If
  
  Exit Function
dstFileMissing:
  FileUpToDate = False
  
End Function

Function PathExists(Dateiname$) As Boolean
  On Error GoTo fehler:
  Dim b As Boolean
  
  b = Dir$(Dateiname, vbDirectory) <> ""
  If Not b Then
    b = Dir$(Dateiname & "\", vbDirectory) <> ""
  End If
  PathExists = b
  Exit Function
fehler:
    PathExists = False
    Resume Next
End Function


Sub MkFullDir(ByVal p As String)
  On Error Resume Next
  Dim pos As Long
  pos = 4
  Do
    pos = InStr(pos, p, "\")
    If pos > 0 Then
      MkDir Left(p, pos - 1)
    Else
      MkDir p
      Exit Sub
    End If
    pos = pos + 1
  Loop While pos > 0
End Sub

Public Sub CallAndWaitForProg(Programmname As String)
  Dim hwndShell As Long, hwndProzess As Long
  Dim lngL|fffd|uft As Long
  hwndShell = Shell(Programmname, 1)
  hwndProzess = OpenProcess(PROCESS_ALL_ACCESS, _
    0&, hwndShell)
  Do While ProgStillActive(hwndProzess)
    Sleep 10
  Loop
  CloseHandle hwndProzess
End Sub

Public Function CallProg(Programmname As String) As Long
  Dim hwndShell As Long
  Dim lngL|fffd|uft As Long
  hwndShell = Shell(Programmname, vbMinimizedNoFocus)
  CallProg = OpenProcess(PROCESS_ALL_ACCESS, 0&, hwndShell)
  SetPriorityClass CallProg, HIGH_PRIORITY_CLASS
End Function

Public Function ProgStillActive(ByVal hwndProzess As Long) As Long
  Dim lngL|fffd|uft As Long
  
  GetExitCodeProcess hwndProzess, lngL|fffd|uft
  If lngL|fffd|uft = STILL_ACTIVE Then
    ProgStillActive = True
  Else
    ProgStillActive = False
  End If
    
End Function

Public Sub KillProg(ByVal hwndProzess As Long)
  TerminateProcess hwndProzess, 0&
'  CloseHandle hwndProzess
End Sub

Function WorksheetExists(wb As Workbook, wsname As String)
  On Error GoTo doesntExist
  WorksheetExists = False
  
  Dim s As String
  s = wb.Sheets(wsname).name
  WorksheetExists = True
  Exit Function
doesntExist:
End Function

Function StripChars(txt As String, charstobestripped As String)
  If Len(txt) <= 0 Or Len(charstobestripped) <= 0 Then
    StripChars = ""
    Exit Function
  End If
  Dim n As String
  Dim i As Long
  For i = 1 To Len(txt)
    If InStr(charstobestripped, Mid(txt, i, 1)) <= 0 Then
      n = n & Mid(txt, i, 1)
    End If
  Next i
  StripChars = n
End Function

Public Function VarValueExists(par, name As String) As Boolean
  On Error GoTo notReadable
  Dim s As String
  s = CStr(par(name))
  VarValueExists = True
  Exit Function
  
notReadable:
  VarValueExists = False
End Function


Public Function PropertyNameExists(par, name As String) As Boolean
  On Error Resume Next
  PropertyNameExists = True
  Dim s As String
  s = CStr(par.Properties(UCase(name)))
  If Err.Number = 0 Then Exit Function
  
  Err.Clear
  Dim t
  Set t = par.Properties(UCase(name))
  If Err.Number = 0 Then Exit Function
  
  PropertyNameExists = False
End Function

Attribute VB_Name = "Scan"
Option Explicit

#Const DoProfile = False


Dim cfgAusf|fffd|hrlich As Long
Dim cfgProgressVisible As Long
Dim cfgFunktionenAuswerten As Long

Dim CurrentStatus As Long
Public VBAFailure As Long
Public Beenden As Boolean

Public theFilename As String
Public theidvDateiID As Long
Public theOEID As Long
Public theFreigabekommentar As String
' Public theFreigabeCCListe  As String
Public theFreigabeuser As String

Public G_HighlyEncryptedFileExtension As String

Public theTrackerPasswordLog As Boolean

Private LastProgText As String
Private ProgText As String


Global Const ChecksumMod As Long = &H100000
Global Const StartEnums As Long = 30
Const StartMassenanalyseY As Long = 11

Public G_MoreFilesInQueue As Boolean

#If VBA7 Then

Private Declare PtrSafe Function GetCurrentProcess Lib "kernel32" () As Long

Public Declare PtrSafe Function FindWindow Lib "user32" Alias "FindWindowA" _
      (ByVal lpClassName As String, ByVal lpWindowName As String) As Long

#Else
Private Declare Function GetCurrentProcess Lib "kernel32" () As Long

Public Declare Function FindWindow Lib "user32" Alias "FindWindowA" _
      (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
#End If

Public LastTimeStamp As Date

Const C_MarkRisk As Long = 13158600

'Sub GetTrans()
'  Dim ty As Long
'  ty = 4
'  Set TransToLocal = New Collection
'  Set TransToE = New Collection
'  With ThisWorkbook.Sheets("Translate")
'      Do While Not IsEmpty(.Cells(ty, 1))
'          TransToLocal.Add .Cells(ty, GSprache + 1).value, .Cells(ty, 1).value
'          TransToE.Add UCase(CStr(.Cells(ty, 1).value)), UCase(CStr(.Cells(ty, GSprache + 1).value))
'          ty = ty + 1
'      Loop
'  End With
'End Sub

Sub DoMassenanalyse()

  LogPrintECCSCanLog 0, 0, "V" & MyVersion & " (Rel: " & MyECCVersion & ") Start!"
  
  G_ColorCells = False
  G_CheckInputs = False
        
  Dim sp|fffd|terfortsetzen As Boolean
  sp|fffd|terfortsetzen = False
  
  
  Dim resultWB As Workbook
  ' Und jetzt die RiskValues holen
  
  'GetTrans
  
  If Not GetRiskValues Then
    EndDaemon
    Exit Sub
  End If
  LogPrint "DoMassenanalyse Start 1"
  
  GetPasswoerter
    
'  DoEvents
  LogPrint "DoMassenanalyse Start 1.1"
  
  cfgAusf|fffd|hrlich = 1
  cfgProgressVisible = 1
  cfgFunktionenAuswerten = 1
    
  Dim startTime

  ' Die Excel-Tabelle
  LogPrint "DoMassenanalyse Start 1.2"
  Dim oxlwsheet                 As New Excel.Worksheet
   
  ' Zeit holen
  Dim v As String
  Dim resultFileName As String

  LogPrint "DoMassenanalyse Start 1.3"
  resultFileName = GetSetting( _
   appname:="Stromwerken", _
   Section:="ECC", _
   Key:="MAErgebnis", _
   default:="")

  LogPrint "DoMassenanalyse Start 2"
  
  Dim currentEntry As Long

  Dim totalFileAm As Long
  totalFileAm = 0

  Set xlsDateien = New Collection
  
  LogPrint "DoMassenanalyse Start 3"
  
  Dim rs As Object
  
  G_CheckDimension = False
  
  If AR_UseDB Then
  
          Set rs = CreateObject("ADODB.recordset")
          
          rs.Open "SELECT ECCScan.idvDateiID, ECCScan.Dateiname, ECCScan.OEID, ECCScan.ScanStatus, idvDateien.LetzterScan, idvDateien.FreigabeStatus, idvDateien.CheckerVersion, idvDateien.CheckerSettings FROM ECCScan INNER JOIN idvDateien ON ECCScan.idvDateiID = idvDateien.idvDateiID WHERE ECCScan.idvDateiID > 0 and (idvDateien.CheckerVersion = " & MyECCVersion & " OR idvDateien.CheckerVersion = -1 OR idvDateien.CheckerVersion is NULL OR idvDateien.FreigabeStatus = 0)", G_conn, MYadOpenDynamic, MYadLockOptimistic
          
          currentEntry = 1
          Do While Not rs.EOF
              Dim sf As ScanFile
              If GetSafeFieldPlus(rs, "idvDateiID", 0) > 0 Then
                Set sf = New ScanFile
                sf.m_Name = GetDriveAndPathFromUNC(rs.Fields("Dateiname").value)
                If Not IsNull(rs.Fields("OEID").value) Then
                  sf.m_OEID = rs.Fields("OEID").value
                Else
                  sf.m_OEID = 0
                End If
                If IsNull(rs.Fields("idvDateiID").value) Then
                  sf.m_idvDateiID = 0
                Else
                  sf.m_idvDateiID = rs.Fields("idvDateiID").value
                End If
                
                sf.m_CheckerSettings = -1
                If FieldItemExists(rs, "CheckerSettings") Then
                  If IsNull(rs.Fields("LetzterScan").value) = False Or rs.Fields("FreigabeStatus").value = 2 Then
                    If Not IsNull(rs.Fields("CheckerSettings").value) Then
                      sf.m_CheckerSettings = rs.Fields("CheckerSettings").value
                    End If
                  End If
                End If
                
                xlsDateien.Add sf
                totalFileAm = totalFileAm + 1
              End If
              
              rs.movenext
          
              If totalFileAm > 31 Then
                If rs.EOF <> True Then
                  G_MoreFilesInQueue = True
                End If
                Exit Do
              End If
          
          Loop
          rs.Close
          Set rs = Nothing
          
'          If G_ECCNoDimension = True Or theTrackerFreigabe = True Then
'            G_CheckDimension = False
'          Else
'            G_CheckDimension = True
'          End If
          
          If theTrackerFreigabe = False Then
              If G_RiskHadDimension = True Then
                G_CheckDimension = True
              End If
          End If
          
          G_CheckInputs = False
          G_Schnellanalyse = False
  
  Else
          LogPrint "DoMassenanalyse Start 4"
          
          
          ' Wenn das ResultFilename gelockt ist....
          If FileLocked(resultFileName) Then
            ' ... wird einfach eine neue Version angelegt!
            Set resultWB = Application.Workbooks.Open(resultFileName, , True)
            Dim newfname As String
            
            ' Ist das schon eine Datei mit Uhrzeit und Datum???
            If Right(GetFileNameAndPath(resultFileName), 20) Like ".??-??-???? ??_??_??" Then
              newfname = Left(GetFileNameAndPath(resultFileName), Len(GetFileNameAndPath(resultFileName)) - 20) & "." & Replace(Replace(Now, ":", "_"), ".", "-") & "." & GetFileExtension(resultFileName)
            Else
              newfname = GetFileNameAndPath(resultFileName) & "." & Replace(Replace(Now, ":", "_"), ".", "-") & "." & GetFileExtension(resultFileName)
            End If
            resultWB.SaveAs newfname
            resultFileName = newfname
            SaveSetting _
             appname:="Stromwerken", _
             Section:="ECC", _
             Key:="MAErgebnis", _
             setting:=newfname
          Else
            Set resultWB = Application.Workbooks.Open(resultFileName)
          End If
          
          SetLiveStatus
          Dim x As Long
          x = 0
          LogPrint "DoMassenanalyse Start 5"
          With resultWB.Sheets("ECCFiles")
            Do While Not IsEmpty(.Cells(2 + WorksheetFunction.RoundDown(x / 255, 0), 1 + x Mod 255))
              LogPrint "DoMassenanalyse Start 5.1 y:" & 2 + WorksheetFunction.RoundDown(x / 255, 0) & " x:" & 1 + x Mod 255
              Set sf = New ScanFile
              sf.m_Name = .Cells(2 + WorksheetFunction.RoundDown(x / 255, 0), 1 + x Mod 255)
              LogPrint "DoMassenanalyse Start 5.2 F:" & sf.m_Name
              sf.m_OEID = 0
              sf.m_idvDateiID = 0
              sf.m_CheckerSettings = -1
              xlsDateien.Add sf
              totalFileAm = totalFileAm + 1
              x = x + 1
            Loop
            
            currentEntry = .Cells(1, 1)
            If IsYes(.Cells(1, 3)) Then
              G_CheckDimension = True
            Else
              G_CheckDimension = False
            End If
            If IsYes(.Cells(1, 4)) Then
              G_Schnellanalyse = True
            Else
              G_Schnellanalyse = False
            End If
          End With
          LogPrint "DoMassenanalyse Start 6"
  End If
  
  
  
  Dim item
  Dim tstring As String
  Dim i As Long
  Dim analyseResult As Boolean
  
  LogPrint "DoMassenanalyse 0"
  StartDaemon
  ' Lieber noch nicht, die Welt ist noch nicht weit genug daf|fffd|r
'  If Not G_cfgIgnoreHighestPriority Then
'    SetHighestPriority
'  End If
  LogPrint "DoMassenanalyse 1"
  If currentEntry <= xlsDateien.count Then
      
      
      
      LogPrint "DoMassenanalyse CurEntry: " & currentEntry
      
      
      Dim memu As Long
'      Dim memf As Long
      
      If Application.Version = "11.0" Then
        memu = Application.MemoryUsed
      Else
        memu = 0
      End If
      
'      memf = Application.MemoryFree
      
      If C_LeakTest Then
        If Application.Version = "11.0" Then
          'AddStatus "Genutzter Speicher: " & memu
          AddStatus FMT1("SCAN_47", memu)
        Else
          'AddStatus "Datei #: " & memu
          AddStatus FMT1("SCAN_48", memu)
        End If
'        AddStatus "Freier Speicher:    " & memf
      End If
      
      For i = currentEntry To xlsDateien.count
        
        If Not TrackerTimeInScope() Then Exit For
        
        If GetSetting(appname:="Stromwerken", Section:="ECC", Key:="AbortAction", default:="") <> "" Then
          Beenden = True
        End If
        
        If Beenden = False Then
          
          Dim didCheck As Boolean
          didCheck = True
          If Not FileAllowed(xlsDateien(i).m_Name) = True Then
            theFilename = xlsDateien(i).m_Name
            theidvDateiID = xlsDateien(i).m_idvDateiID
            didCheck = False
            ' Datei '%1' wird aufgrund des unbekannten Dateityps ignoriert.
            If xlsDateien(i).m_Name <> "" Then
              AddStatus FMT1("SCAN_54", xlsDateien(i).m_Name)
              LogPrintECCSCanLog theidvDateiID, 0, "Datei aufgrund des unbekannten Dateityps ignoriert.", True
            End If
            ' MsgBox "STOP"
          Else
          
            Dim currentscanstatus As Long
            
            If AR_UseDB Then
            
              Set rs = CreateObject("ADODB.recordset")
              rs.Open "SELECT ScanStatus FROM ECCScan WHERE idvDateiID=" & xlsDateien(i).m_idvDateiID, G_conn, MYadOpenDynamic, MYadLockReadOnly
              If Not rs.EOF Then
                currentscanstatus = rs.Fields("ScanStatus").value
              Else
                currentscanstatus = -1
              End If
              rs.Close
              Set rs = Nothing
            
            Else
            
              currentscanstatus = resultWB.Sheets("ECCFiles").Cells(1, 2).value
              
            End If
            
            
            
            ResetRisks
            
            theFilename = xlsDateien(i).m_Name
            theidvDateiID = xlsDateien(i).m_idvDateiID
            ' Starte Analyse
            LogPrintECCSCanLog theidvDateiID, 0, "Starte Analyse: " & theFilename, True
            
            ' Nur wenn die Checker settings gesetzt sind ist auch schon ein Scan gemacht worden
            G_ChecksumFlags = G_ChecksumFlagsOri
            G_ChecksumVBA = G_ChecksumVBAOri
            G_ChecksumNames = G_ChecksumNamesOri
            G_ChecksumPivot = G_ChecksumPivotOri
            G_ChecksumQueries = G_ChecksumQueriesOri
            G_ChecksumDiagrams = G_ChecksumDiagramsOri
            G_ChecksumClone = G_ChecksumCloneOri
            
            If xlsDateien(i).m_CheckerSettings > -1 Then
              G_ChecksumFlags = xlsDateien(i).m_CheckerSettings
              G_ChecksumVBA = True ' 1
              If (G_ChecksumFlags And 1) = 1 Then
                G_ChecksumVBA = False
              End If
              G_ChecksumNames = True  ' 2
              If (G_ChecksumFlags And 2) = 2 Then
                G_ChecksumNames = False
              End If
              G_ChecksumPivot = True  ' 4
              If (G_ChecksumFlags And 4) = 4 Then
                G_ChecksumPivot = False
              End If
              G_ChecksumQueries = True  ' 8
              If (G_ChecksumFlags And 8) = 8 Then
                G_ChecksumQueries = False
              End If
              G_ChecksumDiagrams = True  ' 16
              If (G_ChecksumFlags And 16) = 16 Then
                G_ChecksumDiagrams = False
              End If
              G_ChecksumClone = True ' 32
              If (G_ChecksumFlags And 32) = 32 Then
                G_ChecksumClone = False
              End If
            End If
  
            ' MsgBox "xlsDateien(i).m_CheckerSettings: " & xlsDateien(i).m_CheckerSettings & vbCrLf & "FLAGS:" & vbCrLf & _
            '   "G_ChecksumVBA: " & G_ChecksumVBA & vbCrLf & _
            '   "G_ChecksumNames: " & G_ChecksumNames & vbCrLf & _
            '   "G_ChecksumPivot: " & G_ChecksumPivot & vbCrLf & _
            '   "G_ChecksumQueries: " & G_ChecksumQueries & vbCrLf & _
            '   "G_ChecksumDiagrams: " & G_ChecksumDiagrams & vbCrLf & _
            '   "G_ChecksumClone: " & G_ChecksumClone
  
  
            If IsNull(xlsDateien(i).m_OEID) Then
              theOEID = 0
            Else
              theOEID = xlsDateien(i).m_OEID
            End If
            StatusForm.Filename.Caption = theFilename
            DoEvents
            
            If AR_UseDB Then
              StoreComm True
            End If
            
            XLScriptInitDebug
            
            XLScriptInitGlobals
            
            analyseResult = False
            
            ' Wenn der letzte Scan schief ging, dann muss die Zeile als fehlerhaft markiert werden!!!!
            ' If GetSetting( _
            '     AppName:="Stromwerken", _
            '     Section:="ECC", _
            '     Key:="MAStatus", _
            '     default:="") = "Start" And currentscanstatus >= 1 Then
                
            If currentscanstatus >= 1 Then
                
                XLScriptAddSimpleVar "FILE", theFilename
                XLScriptAddSimpleVar "NAME", theFilename
                XLScriptAddSimpleVar "SAVEDATE", Format(MyFileDateTime(theFilename), "Short Date") & " - " & Format(MyFileDateTime(theFilename), "Short Time")
                XLScriptAddSimpleVar "FILESIZEKB", CLng(MyFileLen(theFilename) / 1024)
                XLScriptAddSimpleVar "FILESIZE", MyFileLen(theFilename)
                XLScriptAddSimpleVar "STATUS", FMT0("SCANERG_1") ' "Datei/Analyse fehlerhaft"
                XLScriptAddSimpleVar "STATUSID", "1"
                XLStoreValsToDB False
                LogPrintECCSCanLog theidvDateiID, 1, "Ergebnis: Analyse mehrfach fehlerhaft, Analyse wird abgebrochen", True
                If Not resultWB Is Nothing Then
                  resultWB.Sheets("ECCFiles").Cells(1, 2).value = 0
                End If
            
            ElseIf currentscanstatus <> -1 Then
            
                SaveSetting _
                appname:="Stromwerken", _
                Section:="ECC", _
                Key:="MAStatus", _
                setting:="Start"
                
                If AR_UseDB Then
                      Set rs = CreateObject("ADODB.recordset")
                      rs.Open "SELECT * FROM ECCScan WHERE idvDateiID=" & theidvDateiID, G_conn, MYadOpenDynamic, MYadLockOptimistic
                      If Not rs.EOF Then
                        rs.Fields("ScanStatus").value = rs.Fields("ScanStatus").value + 1
                        rs.Update
                      End If
                      rs.Close
                      Set rs = Nothing
                Else
                
                      resultWB.Sheets("ECCFiles").Cells(1, 2).value = resultWB.Sheets("ECCFiles").Cells(1, 2).value + 1
                      resultWB.Sheets("ECCFiles").Cells(1, 1).value = i
                
                      Application.DisplayAlerts = False
                      resultWB.Save
                      Application.DisplayAlerts = True
                
                End If
                
                
                Application.ScreenUpdating = False
      '          Dim oldcalc
      '          oldcalc = Application.Calculation
      '          Application.Calculation = xlCalculationManual
      
                If Not FileExists(xlsDateien(i).m_Name) Then
                    XLScriptAddSimpleVar "FILE", theFilename
                    XLScriptAddSimpleVar "NAME", theFilename
                    XLScriptAddSimpleVar "STATUS", FMT0("SCANERG_8")
                    XLScriptAddSimpleVar "STATUSID", "8"
                    XLStoreValsToDB False
                    LogPrintECCSCanLog theidvDateiID, 8, "Ergebnis: Datei gel|fffd|scht, Analyse wird abgebrochen", True
                Else
                    LogPrint "DoMassenanalyse: " & xlsDateien(i).m_Name
                    Dim oldenev As Boolean
                    oldenev = Application.EnableEvents
                    Application.EnableEvents = False
                    'analyseResult = DoAnalyse("m", Texte(GSprache, TXT_ANS_MASSENANALYSE), GetDriveAndPathFromUNC(xlsDateien(i).m_Name), False)
                    analyseResult = DoAnalyse("m", FMT0("TXT_ANS_MASSENANALYSE"), GetDriveAndPathFromUNC(xlsDateien(i).m_Name), False)
                    Application.EnableEvents = oldenev
                End If
      '          Application.Calculation = oldcalc
                Application.ScreenUpdating = True
                
                If Not AR_UseDB Then
                  If Beenden = True Then
                    EndDaemon
                    'If MsgBox("Sie haben die Analyse abgebrochen." & vbCrLf & vbCrLf & "Falls Sie die Analyse zu einem sp|fffd|teren Zeitpunkt fortsetzen m|fffd|chten, dr|fffd|cken Sie bitte auf 'Ja'. Falls Sie die Analyseergebnisse finalisieren m|fffd|chten (ein sp|fffd|teres Fortsetzen der Analyse ist NICHT m|fffd|glich!!!), dann dr|fffd|cken Sie bitte auf 'Nein'.", vbYesNo + vbCritical) = vbYes Then
                    If MsgBox(FMT0("SCAN_1"), vbYesNo + vbCritical) = vbYes Then
                      sp|fffd|terfortsetzen = True
                    End If
                  Else
                    resultWB.Sheets("ECCFiles").Cells(1, 2).value = 0
                  End If
                End If
            
            
            End If
            
            SaveSetting _
            appname:="Stromwerken", _
            Section:="ECC", _
            Key:="MAStatus", _
            setting:="End"
            
  
            
            
            If totalFileAm > 0 Then
              StatusForm.ProgressBT.Width = i / totalFileAm * StatusForm.Filename.Width
            End If
            DoEvents
            
            If Not sp|fffd|terfortsetzen Then
              SaveSetting _
                 appname:="Stromwerken", _
                 Section:=progNameShort, _
                 Key:="LiveStatusCaption", _
                 setting:=Application.Caption
            End If
            
            If Not AR_UseDB Then
              If Not sp|fffd|terfortsetzen Then
                Application.Calculation = xlCalculationManual
                Application.ScreenUpdating = False
                
                Dim ws As Worksheet
                For Each ws In resultWB.Worksheets
                  'UpdateStatus "Generiere Ergebnisbl|fffd|tter (" & ws.name & ")"
                  UpdateStatus FMT1("SCAN_2", ws.name)
                  XLScriptInit ws, "ECC2"
                  XLScriptExecCode ws.Cells, 0, 0
                  XLScriptExit
                  XLScriptInit ws, "ECC3"
                  XLScriptExecCode ws.Cells, 0, 0
                  XLScriptExit
                Next ws
              
                Application.ScreenUpdating = True
                Application.Calculation = xlCalculationAutomatic
              End If
            End If
            
            
  '          XLDumpNonprinted
  
  
            If AR_UseDB = True Then
              If TrackerTimeInScope() Then
                If analyseResult = True And Beenden = False Then
                  XLStoreValsToDB True
                End If
              End If
              If analyseResult = False Then
                'AddStatus "Der Vorgang war fehlerhaft und wurde beendet"
'                MsgBox "STOP2"
                AddStatus FMT0("SCAN_3")
              ElseIf Beenden = True Then
                'AddStatus "Der Vorgang wurde abgebrochen"
                AddStatus FMT0("SCAN_4")
              End If
            End If
            
            XLScriptExitGlobals
          End If
          
        Else
          Exit For
        End If
        
        
    '      MainMenu.Progress2.Width = ProgWidth2 / xlsDateien.Count * itemcount
        LogPrint "ECCScan Tabelle l|fffd|schen"
        If AR_UseDB Then
            If TrackerTimeInScope() Then
              Set rs = CreateObject("ADODB.recordset")
              rs.Open "SELECT * FROM ECCScan WHERE idvDateiID=" & theidvDateiID, G_conn, MYadOpenDynamic, MYadLockOptimistic
              If Not rs.EOF Then
                rs.Delete
              End If
              rs.Close
              Set rs = Nothing
            End If
        End If
        
        LogPrint "LeakTest"
      
        If C_LeakTest Then
          If Application.Version = "11.0" Then
            'AddStatus "Genutzter Speicher: " & Application.MemoryUsed & " - Ver|fffd|nderung: " & memu - Application.MemoryUsed
            AddStatus FMT2("SCAN_5", Application.MemoryUsed, memu - Application.MemoryUsed)
          End If
'          AddStatus "Freier Speicher:    " & Application.MemoryFree & " - Ver|fffd|nderung: " & memf - Application.MemoryFree
'          If memf - Application.MemoryUsed <> 0 Then
'            MsgBox "Leak"
'          End If
        End If
        
        LogPrint "LeakTest Ende"
        
        Dim dashes As String
        dashes = "-----------------------------------------------------------------------------------------------------------------------------------------------"
        AddStatus dashes
        
        If Application.Version = "11.0" Then
            Debug.Print memu - Application.MemoryUsed
            If memu - Application.MemoryUsed < -1000000 Then
              'AddStatus "Schlie|fffd|e ECC f|fffd|r Neustart!"
              AddStatus FMT0("SCAN_6")
               
              GConnClose
              
              If Not AR_UseDB Then
                    Application.DisplayAlerts = False
                    resultWB.Close True
                    Application.DisplayAlerts = True
              End If
              
              RestartScanner
              Exit Sub
            End If
        Else
            If didCheck Then
              memu = memu + 1
            End If
            If memu > 30 Then
              'AddStatus "Schlie|fffd|e ECC f|fffd|r Neustart!"
              AddStatus FMT0("SCAN_6")
               
              GConnClose
              
              If Not AR_UseDB Then
                    Application.DisplayAlerts = False
                    resultWB.Close True
                    Application.DisplayAlerts = True
              End If
              
              RestartScanner
              Exit Sub
            End If
        End If
        
      
      Next i
      
      ' Ok, hier sind die bereits gelesenen abgearbeitet, wenn wir beim Start nicht alle hatten, dann muss hier ein Restart rein!
      If AR_UseDB Then
          If TrackerTimeInScope() Then
            If G_MoreFilesInQueue Then
              'AddStatus "Schlie|fffd|e ECC f|fffd|r Neustart!"
              AddStatus FMT0("SCAN_6")
               
              GConnClose
              
              If Not AR_UseDB Then
                    Application.DisplayAlerts = False
                    resultWB.Close True
                    Application.DisplayAlerts = True
              End If
              
              RestartScanner
              Exit Sub
            End If
          End If
      End If
      
  End If
  
  EndDaemon
  
  If AR_UseDB = True And Beenden = False Then
  
  
  
    If TrackerTimeInScope() Then
            If GetSetting(appname:="Stromwerken", Section:="IDVSS", Key:="ECCFileScanRunning", default:="0") <> 1 Then
          
                  ' das hier wird nur gemacht, wenn das auch wirklich der aktuelle Scanner ist UND wenn das Aufnehmen der zu scannenden Dateien durch den Scheduler noch nicht fertig ist
                  Dim eccNewVer As Long
                  eccNewVer = -1
                  Set rs = CreateObject("ADODB.recordset")
                  rs.Open "SELECT * FROM ECCScan WHERE CheckerVersion < " & MyECCVersion & " AND CheckerVersion >= 0 ORDER BY CheckerVersion DESC", G_conn, MYadOpenDynamic, MYadLockOptimistic
                  If Not rs.EOF Then
                    eccNewVer = rs.Fields("CheckerVersion").value
                  End If
                  rs.Close
                  
                  If InStr(UCase(ThisWorkbook.name), "CHECKER") > 0 Then
                    
                    ' Es k|fffd|nnten noch Dateien in ECCScan drin sein, dann muss weiter gescannt werden
                    Dim am As Long
                    am = 0
                    ' rs.Open "SELECT count(idvDateiID) as cnt FROM ECCScan WHERE CheckerVersion = " & MyECCVersion & " or CheckerVersion < 0", G_conn, MYadOpenDynamic, MYadLockOptimistic
                    rs.Open "SELECT count(ECCScan.idvDateiID) as cnt FROM ECCScan INNER JOIN idvDateien ON ECCScan.idvDateiID = idvDateien.idvDateiID WHERE ECCScan.idvDateiID > 0 and (idvDateien.CheckerVersion = " & MyECCVersion & " OR idvDateien.CheckerVersion = -1 OR idvDateien.CheckerVersion is NULL OR idvDateien.FreigabeStatus = 0)", G_conn, MYadOpenDynamic, MYadLockOptimistic
                    If Not rs.EOF Then
                      am = rs.Fields("cnt").value
                    End If
                    rs.Close
                    
                    If am > 0 Then
                      Set rs = Nothing
                      RestartScanner
                      Exit Sub
                    End If
                    
                    
                    am = 0
                    rs.Open "SELECT count(idvDateiID) as cnt FROM ECCScan WHERE CheckerVersion >= 0 and CheckerVersion < " & MyECCVersion, G_conn, MYadOpenDynamic, MYadLockOptimistic
                    If Not rs.EOF Then
                      am = rs.Fields("cnt").value
                    End If
                    rs.Close
                    
                    ' Es werden %1 Dateien mit |fffd|lteren Versionen des Excel-Sheet-Checkers gescannt.
                    LogPrintECCSCanLog 0, 0, FMT1("SCAN_53", am), True
                    If InStr(UCase(ThisWorkbook.name), "EXCEL-SHEET-CHECKER") > 0 Then
                      SaveSetting appname:="Stromwerken", Section:="IDVSS", Key:="ECCScanResult10", setting:=am
                    End If
                  End If
                  
                  
                  Set rs = Nothing
        
                  If eccNewVer >= 0 Then
                    'AddStatus "Schlie|fffd|e ECC f|fffd|r Neustart als Version " & eccNewVer
                    AddStatus FMT1("SCAN_7", eccNewVer)
                    LogPrintECCSCanLog 0, 0, "Restart als Version " & eccNewVer
                    
                    Sleep 2000
                    
                    SaveSetting appname:="Stromwerken", Section:="ECC", Key:="StartedByTracker", setting:="True"
                    SaveSetting appname:="Stromwerken", Section:="ECC", Key:="StartedByTrackerFirstTime", setting:="True"
                    SaveSetting appname:="Stromwerken", Section:="ECC", Key:="StartedByDaemon", setting:="False"
                    ' SaveSetting appname:="Stromwerken", Section:="ECC", Key:="StartedByDaemon", setting:="True"
                    
                    ' OLD VERSION STUFF!
                    SaveSetting appname:="Stromwerken", Section:="ECC", Key:="TrackerFile", setting:="@"
                    SaveSetting appname:="Stromwerken", Section:="ECC", Key:="TrackerLogPassword", setting:="true"
                    SaveSetting appname:="Stromwerken", Section:="ECC", Key:="TrackerShowStatusform", setting:="True"
                    SaveSetting appname:="Stromwerken", Section:="ECC", Key:="TrackerFreigabe", setting:="False"
                    
                    SaveSetting appname:="Stromwerken", Section:="ECC", Key:="StartScan", setting:=G_StartScan
                    SaveSetting appname:="Stromwerken", Section:="ECC", Key:="EndScan", setting:=G_EndScan
                    
                    ' OLD VERSION STUFF END!
                     
                    ThisWorkbook.Saved = True
                    GConnClose
                     
                    SetLiveStatus
                    LogPrint "ECC Restart (Rel: " & eccNewVer & ")"
                    If FileExists(ThisWorkbook.path & "\ECCV" & eccNewVer & ".xls") Then
                      SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="LiveStatusExec", setting:="ECCV" & eccNewVer & ".xls"
                      SaveSetting appname:="Stromwerken", Section:="ECC", Key:="StartedByTracker", setting:=IIf(AR_UseDB, "True", "False")
                      SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="ProcessID", setting:=""
                      RegRemoveProgPID "ECC"
                      StartExcelDatei ThisWorkbook.path & "\ECCV" & eccNewVer & ".xls"
                    Else
                      SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="LiveStatusExec", setting:="ECCV" & eccNewVer & ".xla"
                      SaveSetting appname:="Stromwerken", Section:="ECC", Key:="StartedByTracker", setting:=IIf(AR_UseDB, "True", "False")
                      SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="ProcessID", setting:=""
                      RegRemoveProgPID "ECC"
                      StartExcelDatei ThisWorkbook.path & "\ECCV" & eccNewVer & ".xla"
                    End If
                   
                    Application.EnableEvents = True
                    Application.Quit
                    Exit Sub
                    
                  End If
            End If
    End If
  End If
  
    
'  If Beenden = True Then
'      resultWB.Sheets(Texte(GSprache, TXT_ANS_MASSENANALYSE)).Cells(5, 2).Value = Texte(GSprache, TXT_ABG)
'  Else
'      resultWB.Sheets(Texte(GSprache, TXT_ANS_MASSENANALYSE)).Cells(5, 2).Value = Texte(GSprache, TXT_BEEN)
'  End If
'  resultWB.Sheets(Texte(GSprache, TXT_ANS_MASSENANALYSE)).Cells(1, 2).Value = MainMenu.Verzeichnis
'  resultWB.Sheets(Texte(GSprache, TXT_ANS_MASSENANALYSE)).Cells(3, 2).Value = Now
'  resultWB.Sheets(Texte(GSprache, TXT_ANS_MASSENANALYSE)).Cells(4, 2).Value = Format(Time - starttime, "hh:mm:ss")
'    MainMenu.Progress2.Width = ProgWidth2
'  Beep
  
'  MsgBox "EndDaemon"
  
  SaveSetting _
     appname:="Stromwerken", _
     Section:=progNameShort, _
     Key:="LiveStatusCaption", _
     setting:=Application.Caption
  
  If Not AR_UseDB Then
        
        Application.Calculation = xlCalculationManual
        Application.ScreenUpdating = False
        
        If Not sp|fffd|terfortsetzen Then
          XLScriptInitGlobals
          If GetSetting(appname:="Stromwerken", Section:="ECC", Key:="AbortAction", default:="") <> "" Then
            SaveSetting appname:="Stromwerken", Section:="ECC", Key:="AbortAction", setting:=""
            Beenden = True
          End If
          
          If Beenden = True Then
            XLScriptAddSimpleVar "SCANSTATUS", FMT0("TXT_ABG")
          Else
            XLScriptAddSimpleVar "SCANSTATUS", FMT0("TXT_FERTIG2")
          End If
          XLScriptAddSimpleVar "ENDOFSCAN", Now
          For Each ws In resultWB.Worksheets
            XLScriptInit ws, "ECC4"
            XLScriptExecCode ws.Cells, 0, 0
            XLScriptCleanUpTags ws.Cells
            XLScriptExit
          Next ws
          XLScriptExitGlobals
          
          For Each ws In resultWB.Worksheets
            ECCCreateHeaderAndFooter ws
          Next ws
        End If
        
      
      '  If Beenden = True Then
      '      MsgBox Now & vbCrLf & Texte(GSprache, TXT_ABBRUCH) & Format(Now - starttime, "hh:mm:ss")
      '  Else
      '      MsgBox Now & vbCrLf & Texte(GSprache, TXT_FERTIG) & Format(Now - starttime, "hh:mm:ss")
      '  End If
        
        Application.ScreenUpdating = True
        Application.Calculation = xlCalculationAutomatic
        resultWB.Application.DisplayAlerts = False
        resultWB.Activate
        resultWB.Worksheets(1).Activate
        resultWB.Save
        resultWB.Application.DisplayAlerts = True
        
        resultWB.Activate
        resultWB.Worksheets(1).Activate
        If sp|fffd|terfortsetzen Then
          resultWB.Close False
        End If
        
        Set resultWB = Nothing
  End If
  
  
  FreeAllMem
  
  ThisWorkbook.Saved = True
  
  StatusForm.Hide
  
  
  If AR_UseDB Then
    
    StoreComm False
    If GetSetting(appname:="Stromwerken", Section:="IDVSS", Key:="ECCFileScanRunning", default:="0") <> 1 Then
      LogPrintECCSCanLog 0, 0, "Schlie|fffd|e ECC, alle Analysen beendet"
      SaveSetting appname:="Stromwerken", Section:="IDVSS", Key:="ECCScanFinished", setting:="1"
    End If
    
    If Not C_IDVTrackerTest Then
      GConnClose
      Application.EnableEvents = True
      RegRemoveProgPID "ECC"
      Application.Quit
    End If
  End If
  
  Application.EnableEvents = True
  
End Sub

Function FileAllowed(ByVal Filename As String) As Boolean
  
' .xls |fffd| Legacy Excel worksheets; officially designated "Microsoft Excel 97-2003 Worksheet"
' .xlt |fffd| Legacy Excel templates; officially designated "Microsoft Excel 97-2003 Template"
' .xlm |fffd| Legacy Excel macro
' OOXMLOffice Open XML (OOXML) format was introduced with Microsoft Office 2007 and became the default format of Microsoft Excel ever since. Excel-related file extensions of this format include:.xlsx |fffd| Excel workbook
' .xlsm |fffd| Excel macro-enabled workbook; same as xlsx but may contain macros and scripts
' .xltx |fffd| Excel template
' .xltm |fffd| Excel macro-enabled template; same as xltx but may contain macros and scripts
' Other formatsMicrosoft Excel uses dedicated file format that are not part of OOXML and use the following extensions:.xlsb |fffd| Excel binary worksheet (BIFF12)
' .xla |fffd| Excel add-in or macro
' .xlam |fffd| Excel add-in
' .xll |fffd| Excel XLL add-in; a form of DLL-based add-in[1]
' .xlw |fffd| Excel work space; previously known as "workbook"
  
  Select Case UCase(GetFileExtension(Filename))
    Case "XLS", "XLT", "XLSX", "XLSM", "XLTX", "XLTM", "XLA", "XLAM", "XLW", "XLSB"
      FileAllowed = True
  End Select
End Function


Sub RestartScanner()
  
  LogPrintECCSCanLog 0, 0, "Restart"
  SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="Restart", setting:=1
  SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="COMMAND", setting:=G_DaemonCommand
  RegRemoveProgPID "ECC"
  StartExcelDatei ThisWorkbook.FullName
  ThisWorkbook.Saved = True
  Application.EnableEvents = True
  Application.Quit
End Sub


Sub DoEinzelanalyse()

  Dim resultWB As Workbook
  ' Und jetzt die RiskValues holen
  
  'GetTrans
  GetRiskValues
  
  GetPasswoerter
    
  DoEvents
  
  cfgAusf|fffd|hrlich = 1
  cfgProgressVisible = 1
  cfgFunktionenAuswerten = 1
  
  
  If cfgFunktionenAuswerten = 1 Then
    GetFuncs
  End If
  
  G_ColorCells = False
  G_CheckInputs = True
  G_CheckDimension = False
  
  G_Schnellanalyse = False
  If AR_UseDB = False Then
  
      If G_FileAlreadyOpen = False And G_NoParamAsk = False Then
        ParamAsk.Show vbModal
      
        G_ColorCells = ParamAsk.ColorCells
        G_CheckDimension = ParamAsk.CheckDimension
      Else
        G_CheckDimension = G_RiskHadDimension
      End If
  End If
      
  Dim app As Excel.Application
  If AR_UseDB = False Or G_CreateResfile > 0 Then
      Set app = New Excel.Application
      If AR_UseDB = False Then CheckForET app
      
      Dim resultFile As String
      If G_ResfileTemplate <> "" Then
        resultFile = gTranslation.GetLocalizedFile(G_ResfileTemplate)
        app.EnableEvents = False
        Set resultWB = app.Workbooks.Add(resultFile)
        app.EnableEvents = True
      ElseIf G_Resfile <> "" Then
        resultFile = gTranslation.GetLocalizedFile(G_Resfile)
        app.EnableEvents = False
        Set resultWB = app.Workbooks.Open(resultFile)
        app.EnableEvents = True
      ElseIf FileExists(ThisWorkbook.path & "\ECC-Einzelanalyse_Indiv.xltx") Then
        resultFile = gTranslation.GetLocalizedFile(ThisWorkbook.path & "\ECC-Einzelanalyse_Indiv.xltx")
        app.EnableEvents = False
        Set resultWB = app.Workbooks.Add(resultFile)
        app.EnableEvents = True
      Else
        resultFile = gTranslation.GetLocalizedFile(ThisWorkbook.path & "\ECC-Einzelanalyse.xltx")
        app.EnableEvents = False
        Set resultWB = app.Workbooks.Add(resultFile)
        app.EnableEvents = True
      End If
      
      app.Calculation = xlCalculationManual
      
  End If
  
  XLScriptInitGlobals
  
  XLScriptAddSimpleVar "STARTOFSCAN", Now
  
  Dim ws As Excel.Worksheet
'  For Each ws In resultWB.Worksheets
'    XLScriptInit ws, "S"
'    XLScriptExecCode ws.Cells, 0,0
'    XLScriptExit
'  Next ws
  
  If AR_UseDB = False Or G_CreateResfile > 0 Then
    app.Visible = False
    app.ScreenUpdating = False
  End If
  Application.ScreenUpdating = False
'  Dim oldcalc
'  oldcalc = Application.Calculation
'  Application.Calculation = xlCalculationManual

  If AR_UseDB Then
      If G_RiskHadDimension = True Then
        G_CheckDimension = True
      Else
        G_CheckDimension = False
      End If
      G_Schnellanalyse = False
  End If
  
  LogPrint "DoEinzelanalyse-Start"
  
  Dim analyseResult As Boolean
  Dim oldenev As Boolean
  oldenev = Application.EnableEvents
  Application.EnableEvents = False
  analyseResult = DoAnalyse("e", FMT0("TXT_ANS_EINZELANALYSE"), GetDriveAndPathFromUNC(theFilename), True)
  Application.EnableEvents = oldenev
  
'  Application.Calculation = oldcalc
  Application.ScreenUpdating = True

  SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="TPLog", setting:=Right(StatusForm.ProgText, 2048)
  If Beenden = True Then
    SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="TPResult", setting:=1 ' Abgebrochen
    SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="TPResultStatus", setting:=FMT0("TXT_ABG")
    XLScriptAddSimpleVar "SCANSTATUS", FMT0("TXT_ABG")
  Else
    If analyseResult = False And XLScriptGetSimpleVarValue("STATUS") <> "" Then
      SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="TPResult", setting:=2 ' Fehler mit status
    SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="TPResultStatus", setting:=XLScriptGetSimpleVarValue("STATUS")
      XLScriptAddSimpleVar "SCANSTATUS", XLScriptGetSimpleVarValue("STATUS")
    Else
      SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="TPResult", setting:=0 ' OK
    SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="TPResultStatus", setting:=FMT0("TXT_FERTIG2")
      XLScriptAddSimpleVar "SCANSTATUS", FMT0("TXT_FERTIG2")
    End If
  End If
  XLScriptAddSimpleVar "ENDOFSCAN", Now

  LogPrint "DoEinzelanalyse-1"

  If AR_UseDB = False Or G_CreateResfile > 0 Then

        For Each ws In resultWB.Worksheets
          'UpdateStatus "Generiere Ergebnisbl|fffd|tter (" & ws.name & ")"
          UpdateStatus FMT1("SCAN_2", ws.name)
          XLScriptInit ws, "ECC1"
          XLScriptExecCode ws.Cells, 0, 1
          XLScriptExit
        Next ws
        For Each ws In resultWB.Worksheets
          XLScriptInit ws, "ECC2"
          XLScriptExecCode ws.Cells, 0, 0
          XLScriptExit
        Next ws
       
        For Each ws In resultWB.Worksheets
          ECCCreateHeaderAndFooter ws
        Next ws
       
'        If Not AR_UseDB Then
'            AddStatus "F|fffd|ge Kommentare hinzu"
'            AddKommentare resultWB
'        End If

        app.Visible = True
        app.ScreenUpdating = True
        app.Calculation = xlCalculationAutomatic

        resultWB.Worksheets(1).Activate

        ' Und Resultfile speichern!
        Select Case G_CreateResfile ' 1 Save in Command. 2 Just open, don't save. 3 Save in ZusDateien. 4 Save in RESFILE
            ' In Current Command!
          Case 1
            If G_ResfileDestID <= 0 Then
              CloseWB resultWB
            Else
              Dim fname As String
              fname = StoreTempResultFile(resultWB)
              CloseWB resultWB
              
              Dim rs As Object
              Dim errstr As String
              Set rs = OpenRS("select ResultBlob, ResultBlobFileExtension, idvDateiID, Dateiname FROM gCommunicate WHERE InternalID = " & G_ResfileDestID, G_conn, MYadOpenDynamic, MYadLockOptimistic)
              If Not rs Is Nothing Then
                If Not rs.EOF Then
                  CheckInBinary "ResultBlob", rs, fname, errstr
                  rs.Fields("ResultBlobFileExtension").value = "xlsx"
                  rs.Fields("idvDateiID").value = theidvDateiID
                  rs.Fields("Dateiname").value = theFilename
                  rs.Update
                Else
                  DebugPrint tERROR, "ECC-Ergebnisdatei konnte nicht zum Scheduler Kommando (gCommunicate) mit der ID " & G_ResfileDestID & " hinzugef|fffd|gt werden."
                End If
                rs.Close
                Set rs = Nothing
              End If
            End If
            
          Case 2  ' Do Nothing
          
          Case 3
          
          Case 4  ' Save in RESFfile
            resultWB.Save
            CloseWB resultWB
            
          Case 5  ' Save in G_DestResfile and Store Checksum
            If G_DestResfile <> "" Then
              MyKill G_DestResfile
              resultWB.SaveAs G_DestResfile
              CloseWB resultWB
            End If
            ' Ansonsten bleibt das Resultfile einfach offen
          
        End Select


       
  End If

  ' LogPrint "DoEinzelanalyse-2"
  ' XLDumpNonprinted
  LogPrint "DoEinzelanalyse-3"
  
  If AR_UseDB = True Then
    If analyseResult = True And Beenden = False Then
      XLStoreValsToDB True
      SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="ProcResult", setting:=Right(StatusForm.ProgText, 2048)
    ElseIf analyseResult = False Then
      'AddStatus "Der Vorgang war fehlerhaft und wurde beendet"
'              MsgBox "STOP2"
      AddStatus FMT0("SCAN_3")
      SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="ProcResult", setting:=Right(StatusForm.ProgText, 2048)
    ElseIf Beenden = True Then
      'AddStatus "Der Vorgang wurde abgebrochen"
      AddStatus FMT0("SCAN_4")
      SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="ProcResult", setting:=Right(StatusForm.ProgText, 2048)
    End If
  End If
  
  LogPrint "DoEinzelanalyse-4"
  XLScriptExitGlobals
  
  StatusForm.Hide
  Application.Cursor = xlWait
  LogPrint "DoEinzelanalyse-5"

  FreeAllMem
  
  LogPrint "DoEinzelanalyse-6"
  
  ThisWorkbook.Saved = True

  LogPrint "DoEinzelanalyse-Finished"
  Application.Cursor = xlDefault
  If AR_UseDB Then
      GConnClose
      Application.EnableEvents = True
  End If
  
  Application.ScreenUpdating = True
 
  If AR_UseDB = False Or G_CreateResfile > 0 Then
      If G_CreateResfile = 2 Then
        resultWB.Worksheets(1).Activate
      End If
  End If
  
  RegRemoveProgPID "ECC"
  SaveSetting appname:="Stromwerken", Section:="IDVSS", Key:="ECCScanFinished", setting:="1"
  If (AR_UseDB = False Or AR_StartedByApp = SWAPPID_ExcelTracker Or G_CreateResfile = 2) And theTrackerFreigabe = False And G_ForceAppCloseAfterScan = False Then
      If Not C_IDVTrackerTest Then
        If G_FileAlreadyOpen = False Then
          ThisWorkbook.Close False
        End If
        Exit Sub
      End If
  Else
      If Not C_IDVTrackerTest Then
          Application.Quit
      End If
  End If
End Sub

Function StoreTempResultFile(ByRef resultWB As Workbook)
On Error GoTo nogo
  Dim fname As String
  fname = CreateTempFile("Tmp") & ".xlsx"
  resultWB.SaveAs fname
  StoreTempResultFile = fname
  SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="StoredResultFile", setting:=fname
  Exit Function
nogo:

End Function


Sub CloseWB(ByRef subWB As Workbook)
  On Error Resume Next
  subWB.Close False
  Set subWB = Nothing

End Sub


Public Function DoAnalyse(ByVal outputsheet As String, ByVal outputSheetName As String, ByVal Filename As String, ByVal modifyOriginal As Boolean) As Boolean
' Die Zeile "On Error Resume Next" kann bei Bedarf wieder
' eingesetzt werden, hier wurde darauf verzichtet um eventuelle
' Programmfehler auch mitzubekommen :)
'  On Error Resume Next
  
' Alternativ kann ich diese Zeile genutzt werden, die
' Fehler geregelt abf|fffd|ngt
  On Error GoTo cmdExcel_Err
  
  Dim subWB As Workbook
  DoAnalyse = True

  cfgAusf|fffd|hrlich = 1
  cfgProgressVisible = 1
  cfgFunktionenAuswerten = 1

  Dim ignoreAllFurtherErrors As Boolean
  
  ' Die Excel-Datei
  Dim oxlwbook                  As Excel.Workbook
  ' Die Excel-Tabelle
  Dim oxlwsheet                 As Excel.Worksheet
  ' Eine Zelle
  Dim c                         As Range
  
  Dim res As New result
  
  Dim startOfScan As Date
  startOfScan = Now
  
  ' Berechnungsmodus schnell oder langsam?
  Dim Mode As Long
  
  
  ' Eine Laufvariable
  Dim cellCount                 As Long
  
  ' Zeit f|fffd|r die Updates
  Dim lastTime As Date
  
  ' Eine Laufvariable
  Dim threshCount               As Long
  ' Eine Laufvariable
  Dim threshSubCunt             As Long
    
  ' Die Uhrzeit des Starts der Auswertung
  Dim startTime
  
  
  
  Dim counter As Long
  
  Dim formulaCells As Range
  
  Dim i As Long
  
  LogPrint "DoAnalyse"
  
  ' Zeit holen
  startTime = Time
  
  
  ignoreAllFurtherErrors = False
  
  
  cellCount = 0
  threshCount = 0
  
  
  ' Ausf|fffd|hrlich oder kurz????
  If cfgAusf|fffd|hrlich = 0 Then
    XLScriptAddSimpleVar "MODE", FMT0("TXT_FAST")
    Mode = 0
  Else
    XLScriptAddSimpleVar "MODE", FMT0("TXT_DEEP")
    Mode = 1
  End If
  
  
  res.Init Filename, Mode
  
'  SaveSetting "Stromwerken", "ECCEngine" & cfgSlotID, "FILE", Filename
  
  CurrentStatus = 1
  
  Dim foundWBook As Boolean
  foundWBook = False
  If G_FileAlreadyOpen Then
    LogPrint "DoAnalyse-Sub1"
    For Each oxlwbook In Workbooks
      If UCase(oxlwbook.name) = UCase(GetFileNameAndExtension(Filename)) Then
        foundWBook = True
        Exit For
      End If
    Next oxlwbook
    If Not foundWBook Then
      LogPrint "DoAnalyse-Sub2"
      'XLScriptAddSimpleVar "STATUS", "Datei geschlossen"
      XLScriptAddSimpleVar "STATUS", FMT0("SCANERG_3") '
      XLScriptAddSimpleVar "STATUSID", "3"
      XLScriptAddSimpleVar "ENDOFFILESCAN", Now
      'AddStatus "Datei geschlossen"
      AddStatus FMT0("SCAN_14")
      AddStatus "-"
  '    GetIDVTIDs Nothing, Filename, G_conn
      Set res = Nothing
      DoAnalyse = False
      If Not AR_UseDB Then
        'MsgBox "Die Datei '" & Filename & "' wurde bereits geschlossen!"
        MsgBox FMT1("SCAN_15", Filename)
'      Else
'        LogPrintECCSCanLog theidvDateiID, 3, theFilename & " (ID: " & theidvDateiID & ") - Ergebnis: FEHLER: Die Datei wurde bereits geschlossen!", True
      End If
      Exit Function
    End If
  Else
    LogPrint "DoAnalyse-Sub3"
    If UCase(GetUNCPath(ThisWorkbook.FullName)) = UCase(GetUNCPath(Filename)) Then
      LogPrint "DoAnalyse-Sub4"
      'XLScriptAddSimpleVar "STATUS", "Keine Analyse"
      XLScriptAddSimpleVar "STATUS", FMT0("SCANERG_2")
      XLScriptAddSimpleVar "STATUSID", "2"
      XLScriptAddSimpleVar "ENDOFFILESCAN", Now
      'AddStatus "Wird nicht analysiert"
      AddStatus FMT0("SCAN_17")
      AddStatus "-"
  '    GetIDVTIDs Nothing, Filename, G_conn
      Set res = Nothing
      DoAnalyse = False
      LogPrintECCSCanLog theidvDateiID, 2, "Ergebnis: Die Datei wird nicht analysiert!", True
      Exit Function
    ElseIf GetFile(Filename, oxlwbook, outputsheet) = False Then
      LogPrint "DoAnalyse-Sub5"
      ' Datei passwortgesch|fffd|tzt
      XLScriptAddSimpleVar "STATUS", FMT0("SCANERG_5")
      XLScriptAddSimpleVar "STATUSID", "5"
      XLScriptAddSimpleVar "ENDOFFILESCAN", Now
      AddStatus "---------------------------------------"
      'AddStatus "Datei passwortgesch|fffd|tzt / defekt"
      AddStatus FMT0("SCAN_19")
      If theTrackerFreigabe Then
        'AddStatus "Hinterlegen Sie bitte ggf. das korrekte Passwort zum |fffd|ffnen der Datei im Reiter 'Hinterlegte Passw|fffd|rter' im Dokufenster."
        AddStatus FMT0("SCAN_20")
      AddStatus "---------------------------------------"
      End If
      XLStoreValsToDB False
'      LogPrintECCSCanLog theidvDateiID, 5, theFilename & " (ID: " & theidvDateiID & ") - Ergebnis: FEHLER: Datei Passwortgesch|fffd|tzt / defekt!", True
  '    GetIDVTIDs Nothing, Filename, G_conn
      Set res = Nothing
      DoAnalyse = False
      Exit Function
    End If
  End If
  LogPrint "DoAnalyse-Sub6"
  
      
  ' wenn das ne Datei mit Code sein k|fffd|nnte....
  If CheckVBAAccessAllowed = False And UCase(GetFileExtension(Filename)) <> "XLTX" And UCase(GetFileExtension(Filename)) <> "XLSX" Then
      ' Kein Zugriff auf VBA-Projekt m|fffd|glich
      XLScriptAddSimpleVar "STATUS", FMT0("SCANERG_6")
      XLScriptAddSimpleVar "STATUSID", "6"
      XLScriptAddSimpleVar "ENDOFFILESCAN", Now
      AddStatus "---------------------------------------"
      'AddStatus "Kein Zugriff auf VBA-Projekt m|fffd|glich"
      AddStatus FMT0("SCANERG_6")
      If theTrackerFreigabe Then
        ' Es ist kein Zugriff auf den VBA-Code / das VBA-Projekt m|fffd|glich. Um die Funktion auszuf|fffd|hren, m|fffd|ssen Sie unter Datei/Optionen/Sicherheitscenter/Einstellungen f|fffd|r das Sicherheitscenter/Einstellungen f|fffd|r Makros den Punkt 'Zugriff auf das VBA-Projektobjektmodell vertrauen' anschalten.
        AddStatus FMT0("SCAN_55")
      AddStatus "---------------------------------------"
      End If
      XLStoreValsToDB False
      LogPrintECCSCanLog theidvDateiID, 6, FMT0("SCANERG_6"), True
      oxlwbook.Saved = True
      oxlwbook.Close False
      Set oxlwbook = Nothing
      Set res = Nothing
      DoAnalyse = False
      Exit Function
  End If
  
  
  G_VerboseFileLog = False
  If G_VerboseFileLogName <> "" Then
    If InStr(UCase(Filename), UCase(G_VerboseFileLogName)) > 0 Or UCase(G_VerboseFileLogName) = "ALL" Then
      G_VerboseFileLogLogName = G_cfgTemppfad & "\ECC-FileLog-" & GetFileNameAndExtension(Filename) & "-" & Replace(Now(), ":", "_") & ".txt"
      G_VerboseFileLog = True
    
      If Not CheckVBAAccessAllowed() Then
        AddTextToFile "VBA-Zugriff: NICHT ERLAUBT!!! FEHLER! (Datei / Optionen / Sicherheitscenter / Einstellungen f|fffd|r das Sicherheitscenter / Einstellungen f|fffd|r Makros / Zugriff auf das VBA-Projektmodell vertrauen = JA", G_VerboseFileLogLogName
      Else
        AddTextToFile "VBA-Zugriff: Erlaub, OK!", G_VerboseFileLogLogName
      End If
    
    End If
  End If
  
'  Dim subWBs As Collection
'  Set subWBs = New Collection
'  If (outputsheet <> "m" And AR_UseDB = False) Then
'    Dim openRefsErr As String
'    If Not OpenExternalReferences(oxlwbook, outputsheet, subWBs, openRefsErr) Then
'      XLScriptAddSimpleVar "INFOREFFILES", openRefsErr
'    End If
'  End If
  
  XLScriptAddSimpleVar "AUTHOR", GetDocProp(oxlwbook, "Author")
  XLScriptAddSimpleVar "CREATIONDATE", GetDocProp(oxlwbook, "Creation date")
  
'  If Not GetIDVTIDs(oxlwbook, Filename, G_conn) Then
'    XLScriptAddSimpleVar "STATUS", "Kein Eintrag"
'    XLScriptAddSimpleVar "STATUSID", "2"
'    XLScriptAddSimpleVar "ENDOFFILESCAN", Now
'    XLScriptAddSimpleVar "AUTHOR", GetDocProp(oxlwbook, "Author")
'    XLScriptAddSimpleVar "CREATIONDATE", GetDocProp(oxlwbook, "Creation date")
'    Exit Sub
'  End If
  res.InitWB oxlwbook
  
  CurrentStatus = 2
  'AddStatus "Datei geladen"
  AddStatus FMT0("SCAN_21")
  
  
  
  
  '---------------------------------------
  ' Funktionsexport vorbereiten
  '---------------------------------------
  Dim funcEx As Object
  Set funcEx = XLScriptAddArray2D("FORMULAS")
  
  Dim inputs As Object
  Set inputs = XLScriptAddArray2D("INPUTS")
  
  Dim todos As Object
  Set todos = XLScriptAddArray2D("TODOS")
  
  '-------------------------------------
  '-------------------------------------
  '-------------------------------------
  ' Analyse
  '-------------------------------------
  '-------------------------------------
  '-------------------------------------
  
#If DoProfile Then
  Dim hrt As New HighResTimer
#End If

  
#If DoProfile Then
  hrt.StartCounting "Prestuff"
#End If
  
  LogPrint "DoAnalyse-Sub7"
  
  res.AnalyzeCodeModules
  
  If Not res.CountCells() Then GoTo closeAndLeave
  
  LogPrint "DoAnalyse-Sub8"
  res.CheckProtectedWorkbook oxlwbook
  
  LogPrint "DoAnalyse-Sub9"
  res.CheckSheetPasswords

  LogPrint "DoAnalyse-Sub10"
  res.GetNames
  LogPrint "DoAnalyse-Sub11"
  
  res.CheckExternalReferences
  LogPrint "DoAnalyse-Sub12"
  
  '-------------------------------------
  
  
  
'  AddStatus "Passw|fffd|rter entfernen wird vorbereitet"
  
  PrepareHighlyEncryptedCheck
  Dim wasHighlyEncrypted As Boolean
  wasHighlyEncrypted = False
  
  ' Wenn das WB nicht gesch|fffd|tzt ist brauch auch nix entsch|fffd|tzt zu werden
  If WorksheetsProtected(oxlwbook.name) = False And WorkbookProtected(oxlwbook.name) = False Then
      AddStatus FMT0("SCAN_50")
  Else
      If IsHighlyEncrypted(oxlwbook.name) = False Then
        LogPrint "DoAnalyse-Sub12.1"
        RemovePWWorkbook oxlwbook
        LogPrint "DoAnalyse-Sub12.1"
        res.RemoveSheetPasswords
      Else
      
        ' In diesem Fall wird der Ausschlussparameter gecheckt!
        If G_cfgPwCheckLimMB > 0 Then
          If WorksheetsProtected(oxlwbook.name) = True Or WorkbookProtected(oxlwbook.name) = True Then
            If G_cfgPwCheckLimMB * 1024 * 1024 < MyFileLen(oxlwbook.FullName) Then
                'XLScriptAddSimpleVar "STATUS", "Passwortgesch|fffd|tzt / defekt"
                XLScriptAddSimpleVar "STATUS", FMT1("SCAN_51", G_cfgPwCheckLimMB)
                XLScriptAddSimpleVar "STATUSID", "5"
                XLScriptAddSimpleVar "ENDOFFILESCAN", Now
                AddStatus "---------------------------------------"
                'AddStatus "Datei passwortgesch|fffd|tzt und gr|fffd||fffd|er als die im Haus zul|fffd|ssigen %1 MB. Eine Analyse ist deshalb nicht m|fffd|glich"
                AddStatus FMT1("SCAN_51", G_cfgPwCheckLimMB)
                If theTrackerFreigabe Then
                  'AddStatus "Damit die Datei freigegeben werden kann m|fffd|ssen alle Passw|fffd|rter in den Tabellen und ggf. f|fffd|r die Arbeitsmappe entfernt werden und die Datei gespeichert werden. Nach der Freigabe k|fffd|nnen die Passw|fffd|rter wieder angebracht werden."
                  AddStatus FMT0("SCAN_52")
                End If
                AddStatus "---------------------------------------"
                XLStoreValsToDB False
                LogPrintECCSCanLog theidvDateiID, 9, FMT1("SCAN_51", G_cfgPwCheckLimMB), True
            '    GetIDVTIDs Nothing, Filename, G_conn
                Set res = Nothing
                
                oxlwbook.Saved = True
                oxlwbook.Close False
                Set oxlwbook = Nothing
                
                DoAnalyse = False
                Exit Function
            End If
          End If
        End If
      
        wasHighlyEncrypted = True
        G_HighlyEncryptedFileExtension = GetFileExtension(oxlwbook.name)
        If CreateUnprotectedFile(oxlwbook.name, GetTempPath & "ECC-" & GetUserName, G_cfgTemppfad) Then
          GetFile GetTempPath & "ECC-" & GetUserName & "." & G_HighlyEncryptedFileExtension, oxlwbook, outputsheet
          res.SetWB oxlwbook
        Else
          'XLScriptAddSimpleVar "STATUS", "Passwortgesch|fffd|tzt"
          XLScriptAddSimpleVar "STATUS", FMT0("SCANERG_5")
          XLScriptAddSimpleVar "STATUSID", "5"
          XLScriptAddSimpleVar "ENDOFFILESCAN", Now
          AddStatus "---------------------------------------"
          'AddStatus "Datei passwortgesch|fffd|tzt / defekt"
          AddStatus FMT0("SCAN_19")
          If theTrackerFreigabe Then
            'AddStatus "Hinterlegen Sie bitte ggf. das korrekte Passwort zum |fffd|ffnen der Datei im Reiter 'Hinterlegte Passw|fffd|rter' im Dokufenster."
            AddStatus FMT0("SCAN_20")
          End If
          AddStatus "---------------------------------------"
          XLStoreValsToDB False
          LogPrintECCSCanLog theidvDateiID, 5, "Ergebnis: FEHLER: Datei Passwortgesch|fffd|tzt", True
      '    GetIDVTIDs Nothing, Filename, G_conn
          Set res = Nothing
          DoAnalyse = False
          Exit Function
        End If
      End If
  End If
  LogPrint "DoAnalyse-Sub13"
  
  oxlwbook.Worksheets(oxlwbook.Worksheets.count).Activate
  
  LogPrint "DoAnalyse-Sub14"
  
  Dim analyzestarttime
  analyzestarttime = Time
  
  ' Die Schleife l|fffd|uft |fffd|ber alle Worksheets (Tabellen)...
  'AddStatus "Zellanalyse"
  AddStatus FMT0("SCAN_49")
  
#If DoProfile Then
  hrt.StopCounting "Prestuff"
#End If
  
  Dim sheetCnt As Long
  sheetCnt = 0
  
  res.CheckLibs oxlwbook
  
  For Each oxlwsheet In oxlwbook.Worksheets
  
    If Not TrackerTimeInScope() Then Exit For
  
    ' Wir setzen die Clones neu pro Tabellenblatt!
    Set res.m_Clones = New Collection
  
    ' Neue Zeile f|fffd|r das Tabellenblatt einf|fffd|gen
    res.sda.AddLine
 
    ' Zwischensummen setzen
    res.SetTab
    
    ' und wird auch nur dann ausgef|fffd|hrt, wenn es wirklich
    ' ein Worksheet ist.
    If TypeName(oxlwsheet) = "Worksheet" Then
      oxlwsheet.Activate
      
'      AddStatus "Analysiere '" & oXLWSheet.name & "'" '  (" & oXLWSheet.UsedRange.Count & " Zellen)"
      
'      foundFormulaAmount = foundFormulaAmount + GetAmount(oXLWSheet, xlCellTypeFormulas)
      
      res.CheckSheetProtection oxlwsheet
      
      res.CheckDiagrams oxlwsheet
      
' .NET START
      res.CheckQueries oxlwsheet
      res.CheckPivots oxlwsheet
' .NET END
      
      res.foundHyperlinks = res.foundHyperlinks + oxlwsheet.Hyperlinks.count
      
      Dim tc As Long
      Dim interneLinks As Long
      Dim externeLinks As Long
      For tc = 1 To oxlwsheet.Hyperlinks.count
        If oxlwsheet.Hyperlinks(tc).Address = "" Then
          res.foundInternalHyperlinks = res.foundInternalHyperlinks + 1
        Else
          res.foundExternalHyperlinks = res.foundExternalHyperlinks + 1
        End If
      Next tc
      
      
'#If DoProfile Then
'  hrt.StartCounting "StoreSheetCellTypeNumbers"
'#End If

'#If DoProfile Then
'      res.StoreSheetCellTypeNumbers oXLWsheet, outputsheet, hrt
'#Else
'      res.StoreSheetCellTypeNumbers oXLWsheet, outputsheet
'#End If
      
'#If DoProfile Then
'  hrt.StopCounting "StoreSheetCellTypeNumbers"
'#End If
      
#If DoProfile Then
  hrt.StartCounting "SheetStuff"
#End If
      res.StoreCircle oxlwsheet
              
    
      res.CheckSheetVisibility oxlwsheet
             
      ' Nur in dem vom Benutzer genutzten Bereich wird
      ' etwas gemacht
      
      'UpdateStatus "Zellanalyse '" & oXLWsheet.name & "'"
      UpdateStatus FMT1("SCAN_22", oxlwsheet.name)
      
      UnfoldGroups oxlwsheet
      
      res.CheckHiddenColumns oxlwsheet
      
      res.CheckHiddenRows oxlwsheet
      
      ShowAllCells oxlwsheet
        
      If G_ColorCells Then
          With oxlwsheet.Cells
'                  .ClearComments
'                  .ClearFormats
            .Interior.Pattern = xlPatternNone
            .Interior.ColorIndex = xlNone
            .Font.ColorIndex = xlColorIndexAutomatic
            .ClearComments
            .Borders.ColorIndex = xlNone
            .Borders.LineStyle = xlLineStyleNone
            .Borders(xlDiagonalUp).LineStyle = xlLineStyleNone
          End With
      End If
#If DoProfile Then
  hrt.StopCounting "SheetStuff"
#End If
  
    
      Dim lineCount As Long
      Dim totalLineAmount As Long
      
      If Not G_Schnellanalyse Then
        Dim comCells As Range
        Set comCells = GetCommentRange(oxlwsheet)
        If Not comCells Is Nothing Then
        
          ' Erst mal nach den Todos suchen...
          For Each c In comCells
            If CommentExists(c) Then
              
              Dim tPos As Long
              tPos = InStr(UCase(c.Comment.Text), "TODO:")
              If tPos > 0 Then
                todos.AddLine
                todos.AddValue "NAME", oxlwsheet.name
                todos.AddValue "ADDRESS", StripChars(c.Address, "$")
                todos.AddValue "COMMENT", "'" & Trim(Mid(c.Comment.Text, tPos + 5))
              End If
            End If
          Next c
           
          ' Und dann noch die Input-Felder checken
          If G_CheckInputs Then
              For Each c In comCells
                If c.Locked = False Then
                  inputs.AddLine
                  inputs.AddValue "NAME", oxlwsheet.name
                  inputs.AddValue "ADDRESS", StripChars(c.Address, "$")
                  If CommentExists(c) Then
                    inputs.AddValue "COMMENT", "'" & c.Comment.Text
                  End If
                End If
              Next c
            End If
        End If
        Set comCells = Nothing
      End If
      
      
      lastTime = Now
      
      
      Dim lastRow As Long
      oxlwsheet.ScrollArea = ""
      lastRow = GetLastRow(oxlwsheet)
      
      If lastRow > 0 Then
                    
        totalLineAmount = lastRow
        
        For lineCount = 1 To lastRow
                    
                    
                    #If DoProfile Then
                      hrt.StartCounting "GetFormulaRange"
                    #End If
                    Set formulaCells = GetFormulaRangeLine(oxlwsheet, lineCount)
                    #If DoProfile Then
                      hrt.StopCounting "GetFormulaRange"
                    #End If
              
                    Dim tFormulaCount As Long
                    tFormulaCount = 0
                    If Not formulaCells Is Nothing Then
                      tFormulaCount = formulaCells.count
                    End If
                    
                    #If DoProfile Then
                      hrt.StartCounting "GetAmount"
                    #End If
                    res.totalUsedCellAmount = res.totalUsedCellAmount + GetAmountLine(oxlwsheet, xlCellTypeConstants, lineCount) + tFormulaCount ' GetAmount(oXLWsheet, xlCellTypeFormulas)
                    #If DoProfile Then
                      hrt.StopCounting "GetAmount"
                    #End If
                    
                    
'                    DoEvents
'                    SetLiveStatus
'                    DoEvents
                    
                    If GetSetting(appname:="Stromwerken", Section:="ECC", Key:="AbortAction", default:="") <> "" Then
                      SaveSetting appname:="Stromwerken", Section:="ECC", Key:="AbortAction", setting:=""
                      Beenden = True
                    End If
                    
                    If Beenden = True Then
              
          '            XLScriptAddSimpleVar "SCANSTATUS", Texte(GSprache, TXT_ABG)
                      XLScriptAddSimpleVar "STATUS", FMT0("SCANERG_3") ' abgebrochen
                      XLScriptAddSimpleVar "STATUSID", "3"
                      XLScriptAddSimpleVar "ENDOFFILESCAN", Now
                      XLScriptAddSimpleVar "AUTHOR", GetDocProp(oxlwbook, "Author")
                      XLScriptAddSimpleVar "CREATIONDATE", GetDocProp(oxlwbook, "Creation date")
                      Set res = Nothing

                      #If DoProfile Then
                        hrt.Dump
                        Set hrt = Nothing
                      #End If
                      
                      oxlwbook.Saved = True
                      oxlwbook.Close False
              
                      Set oxlwbook = Nothing
                      If wasHighlyEncrypted Then
                        MyKill GetTempPath & "ECC-" & GetUserName & "." & G_HighlyEncryptedFileExtension
                      End If
                      
                      Exit Function
                    End If
                    
                    If Not formulaCells Is Nothing Then
                    
                      If G_Schnellanalyse Then
                        res.foundFormulaAmount = res.foundFormulaAmount + formulaCells.count
                      Else
                        For Each c In formulaCells
                          If c.HasFormula Then
                                  #If DoProfile Then
                                    hrt.StartCounting "formulaCells"
                                  #End If
                          
                                  If lineCount Mod 30 = 0 Then
                                      If lastTime + TimeValue("0:00:03") < Now Then
                                        'UpdateStatus "Zellanalyse '" & oXLWsheet.name & "' (" & Format(CDbl(lineCount) / CDbl(totalLineAmount), "percent") & ")"
                                        UpdateStatus FMT2("SCAN_23", oxlwsheet.name, Format(CDbl(lineCount) / CDbl(totalLineAmount), "percent"))
                                        lastTime = Now
                                        SetLiveStatus
                                      End If
                                  End If
                                  cellCount = cellCount + 1
                          
                                  If cellCount Mod 100 = 0 Then
                                    If GetSetting(appname:="Stromwerken", Section:="ECC", Key:="AbortAction", default:="") <> "" Then
                                      SaveSetting appname:="Stromwerken", Section:="ECC", Key:="AbortAction", setting:=""
                                      Beenden = True
                                    End If
                                    
                                    If cfgProgressVisible = 1 Then
                                      StatusForm.VergangeneZeit.Caption = Format(Time - startTime, "hh:mm:ss")
                                    End If
                                  End If
                                  
                                  #If DoProfile Then
                                    hrt.StopCounting "formulaCells"
                                  #End If
                          
                          
                                  ' ******************************************************
                                  ' Formel nicht analysierbar?
                                  ' ******************************************************
                                  If Not FormulaAnalyzable(c) Then
                                          #If DoProfile Then
                                            hrt.StartCounting "FormulaAnalyzable"
                                          #End If
                                          If G_ColorCells Then
                                              c.Interior.ColorIndex = 7
                                              'AddMyComment c, "Zelle nicht analysierbar"
                                              AddMyComment c, FMT0("SCAN_24")
                                          End If
                                          res.foundNonAnalyzableCells = res.foundNonAnalyzableCells + 1
                              '            res.errorFormulaCells.AddValue "", oXLWsheet.name & "!" & c.Address
                                          res.nonAnalyzableCells.AddValue "", oxlwsheet.name & "!" & StripChars(c.Address, "$")
                                          #If DoProfile Then
                                            hrt.StopCounting "FormulaAnalyzable"
                                          #End If
                                  Else
                                        ' NEIN, Formel kann analysiert werden!
                                        Dim tformula As String
                                        tformula = c.Formula
                                
                                        ' --------------------------------------------------
                                        ' Pr|fffd|fen, ob es sich um eine einfach Formel handelt!
                                        ' --------------------------------------------------
                                        If IsSimpleFormula(tformula) Then
                                            Debug.Print "Remove: " & tformula
                                            res.foundNumberFormula = res.foundNumberFormula + 1
                                        Else
                                                  #If DoProfile Then
                                                    hrt.StartCounting "FormulaPart1"
                                                  #End If
                                                  If IsError(c) Then
                                                    Dim errType As Long
                                                    errType = res.StoreErrorType(c, outputsheet)
                                                    If errType > 0 Then
                                                        res.m_CErrorFormulas.Add c
                                                        XLScriptGetSimpleVar("FORMULAERRORAMOUNT").m_Value = CStr(Val(XLScriptGetSimpleVar("FORMULAERRORAMOUNT").m_Value) + 1)
                                          
                                                        If G_ColorCells Then
                                                                With c.Borders(xlDiagonalUp)
                                                                    .LineStyle = xlContinuous
                                                                    .Weight = xlThick
                                                                    .ColorIndex = 3
                                                                End With
                                                                AddMyComment c, FMT0("SCAN_25")
                                                        End If
                                          
                                                    End If
                                                  End If
                                          
                                                  Dim clocked As Boolean
                                                  clocked = c.Locked
                              
                                      
                                                  ' Ist das Ding gelockt?
                                                  If clocked = False Or res.protectedSheetsColl(oxlwsheet.name).m_WorksheetProt <= 1 Then
                                                      If clocked = True Then
                                                        If res.protectedSheetsColl(oxlwsheet.name).m_WorksheetProt = 1 Then
                                                          res.foundLockedFormulasWithoutSheetpassword = res.foundLockedFormulasWithoutSheetpassword + 1
                                                          If G_ColorCells Then
                                                              With c.Interior
                                                                  .ColorIndex = 0
                                                                  .Pattern = xlLightVertical
                                                                  .PatternColorIndex = 3
                                                              End With
                                                              'AddMyComment c, "Ungesch|fffd|tzte Formel (Blattschutz ohne Passwort)"
                                                              AddMyComment c, FMT0("SCAN_26")
                                                          End If
                                                        Else
                                                          res.foundLockedFormulasMissingSheetprotect = res.foundLockedFormulasMissingSheetprotect + 1
                                                          If G_ColorCells Then
                                                              With c.Interior
                                                                  .ColorIndex = 0
                                                                  .Pattern = xlLightVertical
                                                                  .PatternColorIndex = 3
                                                              End With
                                                              'AddMyComment c, "Ungesch|fffd|tzte Formel (Blattschutz fehlt)"
                                                              AddMyComment c, FMT0("SCAN_27")
                                                          End If
                                                        End If
                                                      Else
                                              
                                                        res.m_CUnlockedFormulas.Add c
                                              
                                                        res.foundUnlockedFormulas = res.foundUnlockedFormulas + 1
                                              
                                                        If G_ColorCells Then
                                                            With c.Interior
                                                                .ColorIndex = 0
                                                                .Pattern = xlLightVertical
                                                                .PatternColorIndex = 3
                                                            End With
                                                            'AddMyComment c, "Ungesch|fffd|tzte Formel"
                                                            AddMyComment c, FMT0("SCAN_28")
                                                        End If
                                              
                                                      End If
                                          
                                                  End If
                                        
                                                  ' ******************************************************
                                                  ' FORMELANALYSE
                                                  ' ******************************************************
                                            
                                                  #If DoProfile Then
                                                    hrt.StopCounting "FormulaPart1"
                                                  #End If
                                
                                                  res.foundFormulaAmount = res.foundFormulaAmount + 1
                                 
                                                  ' --------------------------------------------------
                                                  ' Clone identifizieren
                                                  ' --------------------------------------------------
                                          
                                                  Dim abweichung As Boolean
                                                  Dim cs As CloneStuff
                                                  #If DoProfile Then
                                                    hrt.StartCounting "IsClone"
                                                  #End If
                                                  abweichung = Not res.IsClone(c, cs)
                                                  #If DoProfile Then
                                                    hrt.StopCounting "IsClone"
                                                  #End If
                                          
                                                  ' --------------------------------------------------
                                                  ' Wenn Clon
                                                  ' --------------------------------------------------
                                                  ' Wenns keine Abweichung gibt ist es ein Replikat
                                                  If Not abweichung Then
                                            
                                                    If G_ColorCells Then
                                                        If c.Interior.ColorIndex = xlNone Then
                                                          c.Interior.ColorIndex = 4
                                                        End If
                                                        'AddMyComment c, "Gesch|fffd|tzte Formel (Klon)"
                                                        AddMyComment c, FMT0("SCAN_29")
                                                    End If
                                            
                                                    #If DoProfile Then
                                                      hrt.StartCounting "CloneStuff"
                                                    #End If
                                                    res.foundFormulaDuplicateAmount = res.foundFormulaDuplicateAmount + 1
                                          
                                                    If G_ChecksumClone Then
                                                      res.checksum = (res.checksum + cs.m_CheckSum) Mod ChecksumMod
                                                      If G_VerboseFileLog Then
                                                        AddTextToFile "KLON: " & res.checksum & " - " & tformula, G_VerboseFileLogLogName
                                                      End If
                                                    End If
                                                    
                                                    res.foundIfDuplicateAmount = res.foundIfDuplicateAmount + cs.m_IF
                                                    res.foundCalcDuplicateAmount = res.foundCalcDuplicateAmount + cs.m_Calc
                                                    res.foundSumDuplicateAmount = res.foundSumDuplicateAmount + cs.m_Sum
                                                    res.foundMatrixDuplicateFuncs = res.foundMatrixDuplicateFuncs + cs.m_Array
                                                    res.foundCellreferencesDuplicateAmount = res.foundCellreferencesDuplicateAmount + cs.m_Ref
                                          
                                                    res.foundIfAmount = res.foundIfAmount + cs.m_IF
                                                    res.foundCalcAmount = res.foundCalcAmount + cs.m_Calc
                                                    res.foundSumAmount = res.foundSumAmount + cs.m_Sum
                                                    res.foundMatrixFuncs = res.foundMatrixFuncs + cs.m_Array
                                                    res.foundCellreferencesAmount = res.foundCellreferencesAmount + cs.m_Ref
                                                    #If DoProfile Then
                                                      hrt.StopCounting "CloneStuff"
                                                    #End If
                                          
                                          
                                          
                                                  ' --------------------------------------------------
                                                  ' Wenn NICHT Clon
                                                  ' --------------------------------------------------
                                                  Else
                                              
                                                      #If DoProfile Then
                                                        hrt.StartCounting "NotCloneStart"
                                                      #End If
                                                      If G_ColorCells Then
                                                          If c.Interior.ColorIndex = xlNone Then
                                                            c.Interior.ColorIndex = 15
                                                            'AddMyComment c, "Gesch|fffd|tzte Formel"
                                                            AddMyComment c, FMT0("SCAN_30")
                                                          End If
                                                      End If
                                              
                                                      Dim openbracam As Long
                                                      openbracam = res.CheckOpenBracAm(c, cs)  ' XXX Ber|fffd|cksichtigt mit Absicht keine Namen!
                                              
                                                      ' Der Funktionsexporter!
                                                      funcEx.AddLine
                                                      funcEx.AddValue "NAME", oxlwsheet.name
                                                      funcEx.AddValue "ADDRESS", StripChars(c.Address, "$")
                                                      If c.HasArray = True Then
                                                        funcEx.AddValue "TYPE", "M"
                                                      Else
                                                        funcEx.AddValue "TYPE", "F"
                                                      End If
                                                      funcEx.AddValue "FORMULALEN", Len(tformula)
                                                      funcEx.AddValue "OPENBRACAM", CStr(openbracam)
                                                      funcEx.AddValue "MATRIX", IIf(c.HasArray, "x", "")
                                                      funcEx.AddValue "FORMULA", "'" & GetFormulaText(c, tformula) ' IIf(IsError(c), tFormula, c.FormulaLocal)
                                              
                                                      If Not G_ColorCells Then
                                                        If CommentExists(c) Then
                                                          funcEx.AddValue "COMMENT", "'" & c.Comment.Text
                                                        Else
                                                          ' So, jetzt schauen wir noch mal, ob in der Zelle dar|fffd|ber KEINE formel ist und ein Kommentar angebracht wurde, dann nehmen wir den
                                                          Dim foundComment As Boolean
                                                          foundComment = False
                                                          If c.Row > 1 Then
                                                            Dim TR As Range
                                                            Set TR = oxlwsheet.Cells(c.Row - 1, c.Column)
                                                            If TR.HasFormula = False Then
                                                              If CommentExists(TR) Then
                                                                funcEx.AddValue "COMMENT", "'" & TR.Comment.Text
                                                                foundComment = True
                                                              End If
                                                            End If
                                                            Set TR = Nothing
                                                          End If
                                                          If Not foundComment Then funcEx.AddValue "COMMENT", ""
                                                        End If
                                                      End If
                                              
                                              
                                                      funcEx.AddValue "ERROR", "'" & IIf(IsError(c), "X", "")
                                      '                  res.funcExportLine = res.funcExportLine + 1
                              
                                                      If Not IsError(c) Then
                                          
                                                            Dim tLen As Long
                                                            tLen = Len(RemoveStrings(tformula, "'", "'"))
                                      '                            tformula = c.FormulaLocal
                                                            If tLen > res.longestFormula Then
                                                              res.longestFormula = tLen
                                                            End If
                                                            If tLen > res.tabLongestFormula Then
                                                              res.tabLongestFormula = tLen
                                                            End If
                                                      End If
                                                      #If DoProfile Then
                                                        hrt.StopCounting "NotCloneStart"
                                                      #End If
                            
                                                      
                                                      #If DoProfile Then
                                                        hrt.StartCounting "CheckDimensions"
                                                      #End If
                                                      If G_CheckDimension Then
                                                            Dim x As Long
                                                            Dim y As Long
                                                            Dim z As Long
                                                            Dim xy As Long
                                                    
                                                            res.CheckDimensions oxlwbook, c, x, y, z, xy
                                                    
                                                            funcEx.AddValue "DIMENSIONX", CStr(x)
                                                            funcEx.AddValue "DIMENSIONY", CStr(y)
                                                            funcEx.AddValue "DIMENSION2D", CStr(xy)
                                                            funcEx.AddValue "DIMENSION3D", CStr(z)
                                                    
                                                            res.m_Dimension.Check x, y, z, xy
                                                            res.m_TabDimension.Check x, y, z, xy
                                                      Else
                                                            funcEx.AddValue "DIMENSIONX", "'-/-"
                                                            funcEx.AddValue "DIMENSIONY", "'-/-"
                                                            funcEx.AddValue "DIMENSION2D", "'-/-"
                                                            funcEx.AddValue "DIMENSION3D", "'-/-"
                                                      End If
                                                      #If DoProfile Then
                                                        hrt.StopCounting "CheckDimensions"
                                                      #End If
                                              
                                          
                                                      ' --------------------------------------------------
                                                      ' 18.4.03 - Nt - Checksummenberechnung f|fffd|r Formeln
                                                      ' --------------------------------------------------
                                                      #If DoProfile Then
                                                        hrt.StartCounting "ChecksumFormula"
                                                      #End If
                                                      Dim tchecksum As Long
                                                      tchecksum = 0
                                                      ' For counter = 1 To Len(tformula)
                                                      '  tchecksum = (tchecksum + CLng(Asc(Mid(tformula, counter, 1))) * counter) Mod ChecksumMod
                                                      'Next counter
                                                      Dim linkResolvedFormula As String
                                                      linkResolvedFormula = ResolveLink(tformula)
                                                      
                                                      For counter = 1 To Len(linkResolvedFormula)
                                                        tchecksum = (tchecksum + CLng(Asc(Mid(linkResolvedFormula, counter, 1))) * counter) Mod ChecksumMod
                                                      Next counter
                                                      
                                                      cs.m_CheckSum = tchecksum
                                                      res.checksum = (res.checksum + cs.m_CheckSum) Mod ChecksumMod
                                                      If G_VerboseFileLog Then
                                                        AddTextToFile "FORMEL: " & res.checksum & " - " & tformula, G_VerboseFileLogLogName
                                                      End If
                                                      
                                                      #If DoProfile Then
                                                        hrt.StopCounting "ChecksumFormula"
                                                      #End If
                                          
                                          
                                                      #If DoProfile Then
                                                        hrt.StartCounting "FormulaPart2"
                                                      #End If
                                          
                                                      Dim thisFormulaWithNamesExtracted As String
                                                      thisFormulaWithNamesExtracted = tformula
                                              
                                                      ' --------------------------------------------------
                                                      ' Namen ersetzen
                                                      ' --------------------------------------------------
                                                      Dim nameItem As name
                                                      For Each nameItem In oxlwbook.names
                                                        If Left(nameItem.name, 11) <> "_IDVTracker" Then
                                                          thisFormulaWithNamesExtracted = MyReplace(thisFormulaWithNamesExtracted, nameItem.name, Mid(nameItem.RefersTo, 2), True, "'", Chr(34))
                                                        End If
                                                      Next nameItem
                                              
                                                      cs.m_FormulaExtractedNames = thisFormulaWithNamesExtracted
                                              
                                                      Dim posStartRef As Long
                                                      Dim posEndRef As Long
                                                      Dim posStartBrac As Long
                                                      Dim posEndBrac As Long
                                              
                                                      posStartRef = InStr(thisFormulaWithNamesExtracted, "'")
                                                      If posStartRef > 0 Then
                                                        posEndRef = InStr(posStartRef + 2, thisFormulaWithNamesExtracted, "'")
                                                        posStartBrac = InStr(posStartRef + 2, thisFormulaWithNamesExtracted, "[")
                                                        If posStartBrac > 0 Then
                                                          posEndBrac = InStr(posStartRef + 2, thisFormulaWithNamesExtracted, "]")
                                                          If posStartBrac > posStartRef And posEndBrac > posStartRef And posEndBrac > posStartBrac And posStartBrac < posEndRef And posEndBrac < posEndRef Then
                                                            cs.m_HasExternalRefs = True
                                                          End If
                                                        End If
                                                      End If
                                              
                                                      Dim thisFormulaWithNamesExtractedNoRef As String
                                                      thisFormulaWithNamesExtractedNoRef = RemoveStrings(thisFormulaWithNamesExtracted, Chr(34), Chr(34))
                                                      thisFormulaWithNamesExtractedNoRef = RemoveStrings(thisFormulaWithNamesExtractedNoRef, "'", "'")
                                          
                                          
                                                      ' --------------------------------------------------
                                                      ' Gibt es WENN Bedingungen
                                                      ' --------------------------------------------------
                                                      If InStr(thisFormulaWithNamesExtractedNoRef, "IF(") <> 0 Then
                                                          res.foundIfAmount = res.foundIfAmount + 1
                                                          cs.m_IF = 1
                                                      End If
                                              
                                                      ' --------------------------------------------------
                                                      ' Gibt es darin plus und minus etc...
                                                      ' --------------------------------------------------
                                                      If InStr(thisFormulaWithNamesExtractedNoRef, "+") <> 0 Or InStr(thisFormulaWithNamesExtractedNoRef, "-") <> 0 Or _
                                                         InStr(thisFormulaWithNamesExtractedNoRef, "*") <> 0 Or InStr(thisFormulaWithNamesExtractedNoRef, "/") <> 0 Or InStr(thisFormulaWithNamesExtractedNoRef, "^") <> 0 Then
                                                          res.foundCalcAmount = res.foundCalcAmount + 1
                                                          cs.m_Calc = 1
                                                      End If
                                              
                                                      ' --------------------------------------------------
                                                      ' nach Summen suchen
                                                      ' --------------------------------------------------
                                                      If InStr(thisFormulaWithNamesExtractedNoRef, "SUM(") Then
                                                        res.foundSumAmount = res.foundSumAmount + 1
                                                        cs.m_Sum = 1
                                                      End If
                                              
                                                      ' --------------------------------------------------
                                                      ' Ist es eine Matrix??
                                                      ' --------------------------------------------------
                                                      If c.HasArray = True Then
                                                        res.foundMatrixFuncs = res.foundMatrixFuncs + 1
                                                        cs.m_Array = 1
                                                      End If
                                          
                                                      #If DoProfile Then
                                                        hrt.StopCounting "FormulaPart2"
                                                      #End If
                                          
                                                      res.CheckRiskContains c, cs.m_FormulaExtractedNames

                                                  End If
                                
                                                  ' --------------------------------------------------
                                                  ' Alle extern referenzierten Dateien werden gez|fffd|hlt
                                                  ' --------------------------------------------------
                                                  #If DoProfile Then
                                                    hrt.StartCounting "HasExternalRefs"
                                                  #End If
                                                  If cs.m_HasExternalRefs Then
                                                    res.foundCellsWithExternalReferences = res.foundCellsWithExternalReferences + 1
                                                    If G_ColorCells Then
                                                        With c.Borders(xlDiagonalUp)
                                                          .LineStyle = xlContinuous
                                                          .Weight = xlThick
                                                          .ColorIndex = 14
                                                        End With
                                                        'AddMyComment c, "Verlinkte Datei"
                                                        AddMyComment c, FMT0("SCAN_31")
                                                    End If
                                                  End If
                                                  
                                                  ' --------------------------------------------------
                                                  ' Funktionsauswertung
                                                  ' --------------------------------------------------
                                                  ' Wenn funcs an ist
                              
                                                  If cfgFunktionenAuswerten = 1 And Mode = 1 Then
                                                      Dim pos As Long
                                                      pos = 1
                                              
                                                      Dim rv As RiskVal
                                                      For Each rv In G_WhiteList
                                                        rv.m_Hit = False
                                                      Next rv
                                              
                                                      Do
                                                        pos = InStr(pos, cs.m_FormulaExtractedNames, "(")
                                                        If pos <= 0 Then Exit Do
                                                        Dim endPos As Long
                                                        endPos = pos
                                                        pos = pos - 1
                                                        Do While pos > 1 And IsCharOrNumber(Mid(cs.m_FormulaExtractedNames, pos, 1))
                                                          pos = pos - 1
                                                        Loop
                                                        If endPos - pos > 1 Then
                                                          Dim testfuc As String
                                                          testfuc = UCase(Mid(cs.m_FormulaExtractedNames, pos + 1, endPos - pos - 1))
                                                          res.CheckFunc testfuc
                                                          For Each rv In G_WhiteList
                                                            If Not rv.m_Hit Then
                                                              rv.CheckFunc testfuc
                                                            End If
                                                          Next rv
                                                        End If
                                                
                                                        pos = endPos + 1
                                                
                                                      Loop
                                      
                                                  End If
                                                  
                                                  #If DoProfile Then
                                                    hrt.StopCounting "HasExternalRefs"
                                                  #End If
                                
                                        End If
                                  End If
                                  
                          End If
                        Next c
                      End If
                    Else
                          If lineCount Mod 20 = 0 Then
                              If lastTime + TimeValue("0:00:03") < Now Then
                                'UpdateStatus "Zellanalyse '" & oXLWsheet.name & "' (" & Format(CDbl(lineCount) / CDbl(totalLineAmount), "percent") & ")"
                                UpdateStatus FMT2("SCAN_23", oxlwsheet.name, Format(CDbl(lineCount) / CDbl(totalLineAmount), "percent"))
                                lastTime = Now
                                SetLiveStatus
                              End If
                          End If
                    End If
        Next ' For lineCount = 1 To lastCell.Row
      End If
      
      
#If DoProfile Then
  hrt.StartCounting "Output"
#End If
      
      If G_ColorCells Then
        oxlwsheet.Cells.EntireRow.Hidden = False
        oxlwsheet.Cells.Rows.AutoFit
        oxlwsheet.Cells.EntireColumn.Hidden = False
        oxlwsheet.Cells.Columns.AutoFit
      End If
      
      
      If cfgProgressVisible = 1 Then
        StatusForm.VergangeneZeit.Caption = Format(Time - startTime, "hh:mm:ss")
        If cellCount > 0 Then
'          StatusForm.Restdauer.Caption = Format((Time - analyzestarttime) * (res.totalWorkbookCheckAmount - cellCount) / cellCount, "hh:mm:ss")
          If res.totalWorkbookCheckAmount > 0 Then
            StatusForm.ProgressTxt.Caption = Format(100 / res.totalWorkbookCheckAmount * cellCount, "###0") & "%"
            StatusForm.ProgressB.Width = StatusForm.ProgressTxt.Width / res.totalWorkbookCheckAmount * cellCount
          End If
        End If
      End If
      'UpdateStatus "Zellanalyse '" & oXLWsheet.name & "' (100%)"
      UpdateStatus FMT1("SCAN_32", oxlwsheet.name)
    
    End If
    
    If Not oxlwsheet Is Nothing Then
      res.StoreSheetResulsts oxlwsheet
      
      sheetCnt = sheetCnt + 1
      If cfgProgressVisible = 1 Then
          StatusForm.ProgressTxt.Caption = Format(100 / oxlwbook.Worksheets.count * sheetCnt, "###0") & "%"
          StatusForm.ProgressB.Width = StatusForm.ProgressTxt.Width / oxlwbook.Worksheets.count * sheetCnt
      End If
    End If
    
  Next oxlwsheet
  
  LogPrint "DoAnalyse-SheetsDone"
  
#If DoProfile Then
  hrt.StopCounting "Output"
#End If
  
  LogPrint "DoAnalyse-CreateHiddenStuff"
  res.CreateHiddenStuff
  
#If DoProfile Then
  hrt.Dump
  Set hrt = Nothing
#End If
  
  
  
'  If Not XLScriptGetArray2D("TODOS") Is Nothing Then
'    If XLScriptGetArray2D("TODOS").items.count > 0 Then
'      Dim ti As Long
'      For ti = 1 To XLScriptGetArray2D("TODOS").items.count
'        Debug.Print XLScriptGetArray2D("TODOS").items(ti)("COMMENT")
'        Debug.Print XLScriptGetArray2D("TODOS").items(ti)("NAME") & "!" & XLScriptGetArray2D("TODOS").items(ti)("ADDRESS")
'      Next ti
'    End If
'  End If

'  If (outputsheet <> "m" And AR_UseDB = False) Then
'    For Each subWB In subWBs
'      CloseWB subWB
'    Next subWB
'    Set subWBs = Nothing
'  End If
  
  
  ' ------------------------------------------
  ' Ergebnisse speichern
  ' ------------------------------------------
  If G_VerboseFileLog Then
    AddTextToFile "ENDERGEBNIS CHECKSUMME in HEX: " & Hex(res.checksum), G_VerboseFileLogLogName
  End If
  
  res.StoreResults
  
  If cfgAusf|fffd|hrlich = 1 And Mode = 1 Then
      res.CreateGlobalFuncArray
  End If
  
  LogPrint "DoAnalyse-Res-1"
  XLScriptAddSimpleVar "AUTHOR", GetDocProp(oxlwbook, "Author")
  XLScriptAddSimpleVar "CREATIONDATE", GetDocProp(oxlwbook, "Creation date")
  
  oxlwbook.Saved = True
  
  LogPrint "DoAnalyse-Res-2"
  ' Die Datei wieder freigeben
  If Not G_ColorCells Then
    If Not G_NoClose Then
      oxlwbook.Close False
      Set oxlwbook = Nothing
    End If
    If wasHighlyEncrypted Then
      MyKill GetTempPath & "ECC-" & GetUserName & "." & G_HighlyEncryptedFileExtension
    End If
  Else
    oxlwbook.Saved = True
    'MsgBox "ACHTUNG! Die analysierte Datei ist jetzt ge|fffd|ffnet und eingef|fffd|rbt!" & vbCrLf & vbCrLf & "SPEICHERN SIE DIESE DATEI UNTER KEINEN UMST|fffd|NDEN |fffd|BER DAS ORIGINAL!!!", vbCritical, "Excel-Sheet-Checker"
    MsgBox FMT0("SCAN_33"), vbCritical, FMT0("MM_1")
  End If
  
  LogPrint "DoAnalyse-Res-3"
  XLScriptAddSimpleVar "TIMEELAPSED", Format(Time - startTime, "hh:mm:ss")
  XLScriptAddSimpleVar "ENDOFFILESCAN", Now
  
  LogPrint "DoAnalyse-Res-4"
  XLScriptAddSimpleVar "STATUS", FMT0("SCANERG_4")
  XLScriptAddSimpleVar "STATUSID", "4"
  LogPrintECCSCanLog theidvDateiID, 4, "Ergebnis: Analyse erfolgreich beendet, Checksumme: " & XLScriptGetSimpleVar("CHECKSUM").m_Value, True
  
  If G_Break Then
    'MsgBox "Break possibility Analyse beendet"
    MsgBox FMT0("SCAN_35")
  End If
  
  LogPrint "DoAnalyse-Res-5"
  CreateRisk
  
  Set res = Nothing
  
  LogPrint "DoAnalyse-Finished"
  
  Exit Function
  
cmdExcel_Err:

  CurrentStatus = 99
  LogPrintECCSCanLog theidvDateiID, 9, "Ergebnis: Fehler in der Analyse: " & Err.Number & " - " & Err.Description, True
  
  If Err.Number = 0 Then Resume Next
  
  Dim errnr As Long
  errnr = Err.Number
  Dim errDesc As String
  errDesc = Err.Description
  Dim errsrc As String
  errsrc = Err.Source
  
  AddStatus Err.Description
  If cfgProgressVisible = 1 Then
    If AR_UseDB = False And StartedByDaemon = False Then
      If outputsheet = "e" Or GetUserName() = "norman" Or GetUserName() = "S0014443" Then
        If ignoreAllFurtherErrors = False Then
          MsgBox errDesc & vbCrLf & errnr & vbCrLf & errsrc, vbCritical, ProgNameLong
          
          'If MsgBox("Wollen Sie die Verarbeitung abbrechen?", vbYesNo, "Excel-Sheet-Checker") = vbYes Then
          If MsgBox(FMT0("SCAN_36"), vbYesNo, ProgNameLong) = vbYes Then
            Beenden = True
            Exit Function
          Else
            If GetUserName() = "norman" Or GetUserName() = "S0014443" Then
              Dim dbg As String
              dbg = "RESUME NEXT NORMAN?"
              If MsgBox(dbg, vbYesNo) = vbYes Then
                Resume Next
              End If
            End If
            'If MsgBox("Sollen weitere Fehler ignoriert werden?", vbYesNo, "Excel-Sheet-Checker") = vbYes Then
            If MsgBox(FMT0("SCAN_37"), vbYesNo, FMT0("MM_1")) = vbYes Then
              ignoreAllFurtherErrors = True
            End If
          End If
        End If
      End If
    End If
    Resume Next
  End If
  
  Exit Function

closeAndLeave:

  Dim oldenev As Boolean
  oldenev = Application.EnableEvents
  Application.EnableEvents = False
  oxlwbook.Close False
  Set oxlwbook = Nothing
  If wasHighlyEncrypted Then
    MyKill GetTempPath & "ECC-" & GetUserName & "." & G_HighlyEncryptedFileExtension
  End If
  Application.EnableEvents = oldenev
  Exit Function
End Function

Sub GetLastCell(ByRef oxlwsheet As Object, ByRef r As Range)
  On Error Resume Next
  Set r = Nothing
  Set r = oxlwsheet.Cells.SpecialCells(xlCellTypeLastCell)
End Sub

Function GetLastRow(ByRef oxlwsheet As Object) As Long
  On Error Resume Next
  
  GetLastRow = 0
  
  Dim r As Range
  Set r = Nothing
  Set r = oxlwsheet.Cells.SpecialCells(xlCellTypeLastCell)
  
  If r Is Nothing Then
    Set r = oxlwsheet.Range("A1")
  End If

  Dim r2 As Range
  Set r2 = Nothing
  Set r2 = oxlwsheet.Cells.SpecialCells(xlCellTypeLastCell)
  
  Set r2 = oxlwsheet.Cells.Find(What:="*", After:=oxlwsheet.Range("A1"), LookAt:=xlWhole, LookIn:=xlFormulas, SearchDirection:=xlPrevious)
  If r2 Is Nothing Then
    Set r2 = oxlwsheet.Range("A1")
  End If
  
  
  If r2.Row > 1 Then
    GetLastRow = r2.Row
  Else
    If r2.Row > r.Row Then
      GetLastRow = r2.Row
    Else
      GetLastRow = r.Row
    End If
  End If
  Set r = Nothing
  Set r2 = Nothing
End Function

Sub AddStatus(txt As String, Optional col As Long = 196)
  LastProgText = ProgText
  If Len(ProgText) > 0 Then
    ProgText = ProgText & vbCrLf & txt
  Else
    ProgText = txt
  End If
'  Debug.Print txt
  If cfgProgressVisible = 1 Then
    StatusForm.ProgText = Right(ProgText, 16000)
    StatusForm.Repaint
    StatusForm.ProgText.SelStart = Len(ProgText)
'    StatusForm.ProgText.CurLine = 10000
  Else
'    SaveSetting "Stromwerken", "ECCEngine" & cfgSlotID, "STATUS", ProgText
  End If
  
  If theTrackerFreigabe Then
    StoreUserCommunicateValue "TU", ProgText
  End If
  
  WriteTimeStamp
'  WriteToSheet cfgMappenname, Texte(GSprache, TXT_ANS_MASSENANALYSE), TheMassAnalysisY, 2, txt, col
'  WriteToSheet cfgMappenname, Texte(GSprache, TXT_ANS_MASSENANALYSE), TheMassAnalysisY, 3, CStr(CurrentStatus), col

'  SaveSetting "Stromwerken", "ECCEngine" & cfgSlotID, "SSTATUS", txt
'  SaveSetting "Stromwerken", "ECCEngine" & cfgSlotID, "CURSTATUS", CStr(CurrentStatus)

End Sub

Function OpenExternalReferences(ByRef wb As Workbook, outputsheet As String, ByRef subWBs As Collection, ByRef errTxt As String) As Boolean
  On Error GoTo nogo
  Dim aLinks
  Dim i As Long
  Dim result As Boolean
  result = True
  aLinks = wb.LinkSources(xlExcelLinks)
  If Not IsEmpty(aLinks) Then
      For i = 1 To UBound(aLinks)
        If FileExists(CStr(aLinks(i))) Then
          Dim wbsub As Workbook
          If GetFile(CStr(aLinks(i)), wbsub, outputsheet) Then
            subWBs.Add wbsub
            If Not OpenExternalReferences(wbsub, outputsheet, subWBs, errTxt) Then
              result = False
            End If
          Else
            'errTxt = errTxt & IIf(errTxt <> "", vbLf, "") & "Die Datei '" & CStr(aLinks(i)) & "' konnte nicht ge|fffd|ffnet werden."
            errTxt = errTxt & IIf(errTxt <> "", vbLf, "") & FMT1("SCAN_38", CStr(aLinks(i)))
            result = False
          End If
        Else
          'errTxt = errTxt & IIf(errTxt <> "", vbLf, "") & "Die Datei '" & CStr(aLinks(i)) & "' existiert nicht."
          errTxt = errTxt & IIf(errTxt <> "", vbLf, "") & FMT1("SCAN_39", CStr(aLinks(i)))
          result = False
        End If
      Next i
  End If
  OpenExternalReferences = result
  
  Exit Function
nogo:
  
End Function


Function GetFile(Filename As String, ByRef oxlwbook As Excel.Workbook, outputsheet As String) As Boolean
  Dim msgBoxText As String
  
  GetFile = True
  ' |fffd|ffnen der Datei - Bei Error auf Passwort pr|fffd|fen
  On Error GoTo hatPasswort
  Dim oldenev As Boolean
  oldenev = Application.EnableEvents
  Application.EnableEvents = False
  Dim oldalert As Boolean
  oldalert = ThisWorkbook.Application.DisplayAlerts
  ThisWorkbook.Application.DisplayAlerts = False
  ThisWorkbook.Application.AskToUpdateLinks = False
  Dim oldAutomation As Long
  oldAutomation = ThisWorkbook.Application.AutomationSecurity
  ThisWorkbook.Application.AutomationSecurity = msoAutomationSecurityLow

'  If UCase(right(Filename, 5)) = ".XLSX" Then
'    GetFile = False
'    Exit Function
'  End If
  
  SetLiveStatusFunc "WorkbooksOpen", True
  SetLiveStatus
  
  Dim PW As String
  If AR_UseDB Then
    PW = GetFilePassword(G_conn, Filename)
  End If
  
  'AddStatus "|fffd|ffne " & Filename
  AddStatus FMT1("SCAN_40", Filename)
  If outputsheet <> "m" And AR_UseDB = False Then
'        If Application.Version = "12.0" Or Application.Version = "13.0" Then
          Set oxlwbook = ThisWorkbook.Application.Workbooks.Open(ShortFileName(Filename), False, True, , , , True, , , IIf(UCase(Right(Filename, 5)) = ".XLTX", True, IIf(UCase(Right(Filename, 4)) = ".XLT", True, False)), False, , False)
'        Else
'          Set oxlwbook = ThisWorkbook.Application.Workbooks.Open(ShortFileName(Filename), False, True, , , , True, , , IIf(UCase(Right(Filename, 4)) = ".XLT", True, False), False, , False)
'        End If
  Else
'        If Application.Version = "12.0" Or Application.Version = "13.0" Then
          Set oxlwbook = ThisWorkbook.Application.Workbooks.Open(ShortFileName(Filename), False, True, , IIf(PW = "", "Testpasswort", PW), , True, , , IIf(UCase(Right(Filename, 5)) = ".XLTX", True, IIf(UCase(Right(Filename, 4)) = ".XLT", True, False)), False, , False)
'        Else
'          Set oxlwbook = ThisWorkbook.Application.Workbooks.Open(ShortFileName(Filename), False, True, , "Testpasswort", , True, , , IIf(UCase(Right(Filename, 4)) = ".XLT", True, False), False, , False)
'        End If
  End If
  ThisWorkbook.Application.AutomationSecurity = oldAutomation
  SetLiveStatusFunc "WorkbooksOpen", False
  SetLiveStatus
    
  ThisWorkbook.Application.AskToUpdateLinks = True
  ThisWorkbook.Application.DisplayAlerts = oldalert
  SaveSetting _
     appname:="Stromwerken", _
     Section:=progNameShort, _
     Key:="LiveStatusCaption", _
     setting:=Application.Caption
  Application.EnableEvents = oldenev
  GoTo openOk
  
hatPasswort:

    ' Sollte die Datei ein Passwort haben, dann geben wir einen enstprechenden Text aus
    If (outputsheet <> "m" And AR_UseDB = False) Then
      If Not AR_UseDB Then
        msgBoxText = FMT1("SCAN_41", Err.Description)
        MsgBox msgBoxText, vbCritical, FMT0("MM_1")
      Else
        XLScriptAddSimpleVar "OPENERROR", Err.Number & " - " & Err.Description
        LogPrintECCSCanLog theidvDateiID, 5, "Fehler beim |fffd|ffnen, Datei vermutlich Passwortgesch|fffd|tzt.", True
        AddStatus FMT1("SCAN_41", Err.Description)
      End If
    Else
      XLScriptAddSimpleVar "OPENERROR", Err.Number & " - " & Err.Description
      LogPrintECCSCanLog theidvDateiID, 5, "Fehler beim |fffd|ffnen, Datei vermutlich Passwortgesch|fffd|tzt. " & Err.Description, True
      AddStatus FMT1("SCAN_41", Err.Description)
    End If
'    If Len(MassenMappe) > 0 Then
        ' Ansonsten wird nur beim Status eingetragen, dass die Datei gesch|fffd|tzt ist
'        Workbooks(MassenMappe).Sheets(Texte(GSprache, TXT_ANS_MASSENANALYSE)).Cells(line, tabxM2).Value = Texte(GSprache, TXT_DATEVGESCH) & " (" & Err.Description & ")"
'    End If
    On Error GoTo 0
    
    ThisWorkbook.Application.AutomationSecurity = oldAutomation
    ThisWorkbook.Application.AskToUpdateLinks = True
    ThisWorkbook.Application.DisplayAlerts = oldalert
    SaveSetting _
       appname:="Stromwerken", _
       Section:=progNameShort, _
       Key:="LiveStatusCaption", _
       setting:=Application.Caption
    Application.EnableEvents = oldenev
    
    GetFile = False
    Exit Function
openOk:
  ' On Error wieder zur|fffd|cksetzen
  On Error GoTo 0
      
  ' 3.4.03 - Nt
  ' Wenn das Projekt gesch|fffd|tzt ist, muss ein gesonderter Warnvermerk ausgegeben werden!
  VBAFailure = 0
  On Error GoTo CheckNewerVersion
  
'  If Not CheckVBAAccessAllowed() Then
'  End If
  
  
  If oxlwbook.VBProject.Protection = 1 Then ' vbext_pp_locked
      VBAFailure = 1
    
    
Debug.Print "XXX Hier muss noch der VBA-Test rein"
'    If Len(EinzelMappe) > 0 Then
'      msgBoxText = "Das VBA-Projekt ist gesch|fffd|tzt, bitte entfernen Sie den Schutz zuerst."
'      MsgBox msgBoxText
'    Else
        ' Ansonsten wird nur beim Status eingetragen, dass die Datei gesch|fffd|tzt ist
'        Workbooks(massenmappe).Sheets(Texte(GSprache, TXT_ANS_MASSENANALYSE)).Cells(line, 2).Value = "Das VBA-Projekt ist gesch|fffd|tzt, bitte entfernen Sie den Schutz zuerst."
'    End If
'    oXLWBook.Close False
'    Exit Sub
  End If
  GoTo continueCheck

CheckNewerVersion:
Debug.Print "XXX Hier muss noch der VBA-Test raus"
  On Error GoTo 0
'  If Len(EinzelMappe) > 0 And Len(MassenMappe) = 0 Then
'    msgBoxText = Texte(GSprache, TXT_VBAPR|fffd|FUNG)
'    MsgBox msgBoxText
'  End If
'  If Len(MassenMappe) > 0 Then
    ' Ansonsten wird nur beim Status eingetragen, dass die Datei gesch|fffd|tzt ist
'    Workbooks(MassenMappe).Sheets(Texte(GSprache, TXT_ANS_MASSENANALYSE)).Cells(line, tabxM2).Value = Texte(GSprache, TXT_VBAPR|fffd|FUNG)
'  End If
  VBAFailure = 2
  
continueCheck:

End Function

Function GetExcelFile(Filename As String, ByRef oxlwbook As Excel.Workbook) As Boolean
  Dim msgBoxText                As String
  Dim oldenev As Boolean
  oldenev = Application.EnableEvents
  GetExcelFile = True
  On Error GoTo fehler
  Application.EnableEvents = False
  Set oxlwbook = Workbooks.Open(ShortFileName(Filename))
  SaveSetting _
     appname:="Stromwerken", _
     Section:=progNameShort, _
     Key:="LiveStatusCaption", _
     setting:=Application.Caption
  Application.EnableEvents = oldenev
  Exit Function
  
fehler:
  GetExcelFile = False
End Function


Function IsChar(t As String) As Boolean
    IsChar = False
    If (t >= "A" And t <= "Z") Or (t >= "a" And t <= "z") Then IsChar = True
End Function
Function IsCharOrNumber(t As String) As Boolean
    IsCharOrNumber = False
    If (t >= "A" And t <= "Z") Or (t >= "a" And t <= "z") Or IsNumeric(t) Then IsCharOrNumber = True
End Function

Sub CrackSheet(oxlwsheet)
  On Error Resume Next
  oxlwsheet.Protect "", userinterfaceonly:=True
  CrackSheet2 (oxlwsheet)
End Sub
Sub CrackSheet2(oxlwsheet)
  On Error Resume Next
  oxlwsheet.[A1].Copy oxlwsheet.[A1]
  oxlwsheet.[B1].Copy oxlwsheet.[B1]
  oxlwsheet.[A2].Copy oxlwsheet.[A2]
  oxlwsheet.[A3].Copy oxlwsheet.[A3]
  oxlwsheet.[AA2].Copy oxlwsheet.[AA2]
End Sub

Function GetCommentRange(oxlwsheet)
  Dim olddisplayalerts As Boolean
  olddisplayalerts = Application.DisplayAlerts
  Set GetCommentRange = Nothing
  Application.DisplayAlerts = False
  On Error Resume Next
  Dim xlCalc As Long
  xlCalc = Application.Calculation
  Application.Calculation = xlCalculationManual
  SetLiveStatusFunc "SpecialCells", True
  Set GetCommentRange = oxlwsheet.Cells.SpecialCells(xlCellTypeComments)
  SetLiveStatusFunc "SpecialCells", False
  Application.Calculation = xlCalc
  Application.DisplayAlerts = olddisplayalerts
  SetLiveStatus
End Function


Function GetFormulaRangeLine(oxlwsheet, l As Long)
  On Error Resume Next
  Dim olddisplayalerts As Boolean
  olddisplayalerts = Application.DisplayAlerts
  Set GetFormulaRangeLine = Nothing
  Application.DisplayAlerts = False
  Set GetFormulaRangeLine = oxlwsheet.Rows(l).SpecialCells(xlCellTypeFormulas)
  Application.DisplayAlerts = olddisplayalerts
End Function

Function GetAmountLine(ByRef oxlwsheet As Excel.Worksheet, t As Long, l As Long) As Long
  On Error Resume Next
  Dim olddisplayalerts As Boolean
  olddisplayalerts = Application.DisplayAlerts
  GetAmountLine = 0
  Application.DisplayAlerts = False
  GetAmountLine = oxlwsheet.Rows(l).SpecialCells(t).count
  Application.DisplayAlerts = olddisplayalerts
End Function

Function GetAmountErrors(ByRef oxlwsheet As Excel.Worksheet, ByRef nullam As Long, ByRef div0am As Long, ByRef valueam As Long, ByRef refam As Long, ByRef nameam As Long, ByRef numam As Long, ByRef naam As Long) As Long
  On Error Resume Next
  Dim olddisplayalerts As Boolean
  olddisplayalerts = Application.DisplayAlerts
  GetAmountErrors = 0
  Dim r As Range
  Dim xlCalc As Long
  xlCalc = Application.Calculation
  Application.Calculation = xlCalculationManual
  Application.DisplayAlerts = False
  SetLiveStatusFunc "SpecialCells", True
  Set r = oxlwsheet.Cells.SpecialCells(xlCellTypeFormulas, 16)
  SetLiveStatusFunc "SpecialCells", False
  Application.DisplayAlerts = olddisplayalerts
  Application.Calculation = xlCalc
  SetLiveStatus
  GetAmountErrors = r.count
  nullam = 0
  div0am = 0
  valueam = 0
  refam = 0
  nameam = 0
  numam = 0
  naam = 0
  
  Dim c As Range
  For Each c In r
    Select Case c.value
      Case CVErr(xlErrNull)
        nullam = nullam + 1
      Case CVErr(xlErrDiv0)
        div0am = div0am + 1
      Case CVErr(xlErrValue)
        valueam = valueam + 1
      Case CVErr(xlErrRef)
        refam = refam + 1
      Case CVErr(xlErrName)
        nameam = nameam + 1
      Case CVErr(xlErrNum)
        numam = numam + 1
      Case CVErr(xlErrNA)
        naam = naam + 1
    End Select
  Next c

End Function
  


Sub UpdateStatus(txt As String)
  If Len(LastProgText) > 0 Then
    ProgText = LastProgText & vbCrLf & txt
  Else
    ProgText = txt
  End If
'  Debug.Print txt
  If cfgProgressVisible = 1 Then
    StatusForm.ProgText = Right(ProgText, 16000)
    StatusForm.Repaint
    StatusForm.ProgText.SelStart = Len(ProgText)
'    StatusForm.ProgText.CurLine = 10000
  Else
'    SaveSetting "Stromwerken", "ECCEngine" & cfgSlotID, "STATUS", ProgText
  End If
  
  If theTrackerFreigabe Then
    StoreUserCommunicateValue "TU", ProgText
  End If
  
  WriteTimeStamp
  DoEvents
'  WriteToSheet cfgMappenname, Texte(GSprache, TXT_ANS_MASSENANALYSE), TheMassAnalysisY, 2, txt
'  WriteToSheet cfgMappenname, Texte(GSprache, TXT_ANS_MASSENANALYSE), TheMassAnalysisY, 3, CStr(CurrentStatus)
  
'  SaveSetting "Stromwerken", "ECCEngine" & cfgSlotID, "SSTATUS", txt
'  SaveSetting "Stromwerken", "ECCEngine" & cfgSlotID, "CURSTATUS", CStr(CurrentStatus)
End Sub

Function MyReplace(txt As String, searchtxt As String, replacetxt As String, Optional checkStartAndEnd As Boolean = False, Optional ignoreIn1 As String = "", Optional ignoreIn2 As String = "") As String
  Dim txtPos As Long
  Dim tStringRep As String
  Dim res As String
  Dim ok As Boolean
  MyReplace = txt
  If InStr(txt, searchtxt) = 0 Then Exit Function
  Dim inIgnore1 As Boolean
  Dim inIgnore2 As Boolean
  
  inIgnore1 = False
  inIgnore2 = False
  
  Dim lenIgnoreIn1 As Long
  Dim lenIgnoreIn2 As Long
  
  lenIgnoreIn1 = Len(ignoreIn1)
  lenIgnoreIn2 = Len(ignoreIn2)
  
  
  For txtPos = 1 To Len(txt)
    If Mid(txt, txtPos, lenIgnoreIn1) = ignoreIn1 Then
      If Not inIgnore1 Then
        inIgnore1 = True
      Else
        inIgnore1 = False
      End If
    End If
    
    If Mid(txt, txtPos, lenIgnoreIn2) = ignoreIn2 Then
      If Not inIgnore2 Then
        inIgnore2 = True
      Else
        inIgnore2 = False
      End If
    End If
    
    If inIgnore1 = False And inIgnore2 = False Then
      If Mid(txt, txtPos, Len(searchtxt)) = searchtxt Then
        ok = True
        Dim tval As String
        If checkStartAndEnd Then
          If txtPos > 1 Then
            tval = Mid(txt, txtPos - 1, 1)
            If (tval >= "a" And tval <= "z") Or _
               (tval >= "A" And tval <= "Z") Or _
               (tval >= "0" And tval <= "9") Or _
               tval = "_" Then
                ok = False
            End If
          End If
          If txtPos + Len(searchtxt) <= Len(txt) Then
            tval = Mid(txt, txtPos + Len(searchtxt), 1)
            If (tval >= "a" And tval <= "z") Or _
               (tval >= "A" And tval <= "Z") Or _
               (tval >= "0" And tval <= "9") Or _
               tval = "_" Then
                ok = False
            End If
          End If
        End If
        If ok Then
          res = res + replacetxt
          txtPos = txtPos + Len(searchtxt) - 1
        Else
          res = res + Mid(txt, txtPos, 1)
        End If
      Else
        res = res + Mid(txt, txtPos, 1)
      End If
    Else
      res = res + Mid(txt, txtPos, 1)
    End If
  Next txtPos
  MyReplace = res
End Function




Function MyReplace2(txt As String, searchtxt As String, replacetxt As String, Optional checkStartAndEnd As Boolean = False, Optional ignoreIn As String = "") As String
  Dim txtPos As Long
  Dim tStringRep As String
  Dim ok As Boolean
  txtPos = 1
  Do
    txtPos = InStr(txtPos, txt, searchtxt)
    If txtPos > 0 Then
      ok = True
      Dim tval As String
      If checkStartAndEnd Then
        If txtPos > 1 Then
          tval = Mid(txt, txtPos - 1, 1)
          If (tval >= "a" And tval <= "z") Or _
             (tval >= "A" And tval <= "Z") Or _
             (tval >= "0" And tval <= "9") Or _
             tval = "_" Then
              ok = False
          End If
        End If
        If txtPos + Len(searchtxt) <= Len(txt) Then
          tval = Mid(txt, txtPos + Len(searchtxt), 1)
          If (tval >= "a" And tval <= "z") Or _
             (tval >= "A" And tval <= "Z") Or _
             (tval >= "0" And tval <= "9") Or _
             tval = "_" Then
              ok = False
          End If
        End If
      End If
      If ok Then
          If txtPos - 1 > 0 Then
              tStringRep = Left(txt, txtPos - 1)
          Else
              tStringRep = ""
          End If
          tStringRep = tStringRep + replacetxt
          tStringRep = tStringRep + Mid(txt, txtPos + Len(searchtxt))
          txt = tStringRep
          txtPos = 1
      Else
        txtPos = txtPos + 1
      End If
    End If
  Loop While txtPos > 0 And txtPos < Len(txt)
  MyReplace2 = txt
End Function


Sub StripExcelSpecificStuff(ByRef tName As String)
  Dim tPos As Long
  tPos = InStr(tName, "[")
  If tPos > 0 Then
    Dim t As String
    If tPos > 1 Then
      t = Left(tName, tPos - 1)
    End If
    Dim tPosR As Long
    
    tPosR = InStr(tName, "]")
    If tPosR > 0 Then
      t = t + Mid(tName, tPos + 1, tPosR - tPos - 1)
      tName = t
    End If
  End If
  
End Sub

Public Sub WriteTimeStamp()
  On Error Resume Next
  ' Alle 30 Sekunden wird ein Timestamp gesetzt
  If LastTimeStamp + TimeValue("0:00:30") > Now Then Exit Sub
  LastTimeStamp = Now
'  SaveSetting "Stromwerken", "ECCEngine" & cfgSlotID, "TIMESTAMP", CStr(LastTimeStamp)

'  Open ThisWorkbook.Path & "\ECCEngineTimeStamp" & cfgSlotID & ".Cfg" For Output As #1
'  Write #1, LastTimeStamp
'  Close #1
End Sub

Sub GetFuncs()
  Set Funcs = New Collection
  Dim f As Func
  Dim lastHeadF As Func
  Set lastHeadF = Nothing
  Dim oxlwbook As Excel.Workbook
  On Error GoTo FuncIsMissing
  Set oxlwbook = Workbooks.Open(ThisWorkbook.path & "\ECCFuncs.xls")
  SaveSetting _
     appname:="Stromwerken", _
     Section:=progNameShort, _
     Key:="LiveStatusCaption", _
     setting:=Application.Caption
  Dim y As Long
  y = 2
  While Not IsEmpty(oxlwbook.Worksheets("Funktionen").Cells(y, 2))
    If Not IsEmpty(oxlwbook.Worksheets("Funktionen").Cells(y, 1)) Then
        Set f = New Func
        f.name = oxlwbook.Worksheets("Funktionen").Cells(y, 2)
        
        ' Localization: Das kommt jetzt aus der String table
        ' Spalte B (was jetzt in f.name ist) ist die ID
        'If Not IsEmpty(oxlwbook.Worksheets("Funktionen").Cells(y, 2 + GSprache)) Then
          'f.Trans = oxlwbook.Worksheets("Funktionen").Cells(y, 2 + GSprache)
        'Else
        '  f.Trans = TranslateFuncToLocal(oxlwbook.Worksheets("Funktionen").Cells(y, 2))
        'End If
        f.Trans = gTranslation.GetSafeString(f.name, f.name)
        
        If Left(f.name, 4) = "### " Then
            Set lastHeadF = f
            Set f.Head = Nothing
        Else
            If Not TypeName(lastHeadF) = "Nothing" Then
                Set f.Head = lastHeadF
            End If
        End If
        Funcs.Add f
        Set f = Nothing
    End If
    y = y + 1
  Wend
  oxlwbook.Close
  Set oxlwbook = Nothing

FuncIsMissing:
End Sub
  
Function GetFormulaText(c As Range, tformula As String)
  
  On Error Resume Next
  GetFormulaText = tformula
  
  If Not IsError(c) Then
    If c.HasArray Then
      GetFormulaText = "={" & Mid(c.FormulaLocal, 2) & "}"
    Else
      GetFormulaText = c.FormulaLocal
    End If
  End If

End Function

Sub ShowStatusForm(Headline As String)
  StatusForm.ProgressB.Width = 0
  StatusForm.ProgressBT.Width = 0
  StatusForm.Filename = Headline
  StatusForm.VergangeneZeit = ""
'  StatusForm.Restdauer = ""
  StatusForm.ProgText = ""
  LastProgText = ""
  ProgText = ""
  
  If AR_UseDB Then
    If Not G_SchedulerTimeCheckIgnore Then
      If Not theTrackerFreigabe Then
        'ProgText = "Scanzeitraum: " & G_StartScan & " - " & G_EndScan
        ' ProgText = FMT2("SCAN_42", G_StartScan, G_EndScan)
      End If
    End If
                 
    StatusForm.ProgText = ProgText
  End If
  
  'StatusForm.BldVersion.Caption = "Bld: " & MyInternalVersion & "." & MyECCVersion
  ' StatusForm.BldVersion.Caption = FMT2("SCAN_43", MyInternalVersion, MyECCVersion)
  StatusForm.BldVersion.Caption = MyVersion & "." & MyECCVersion & "/" & MyProgramReleaseDate
  
'  StatusForm.BitteWarten.Visible = False
  DoEvents
  
'  If AR_UseDB Then
'    StatusForm.cmdAbbrechen.Visible = False
'    StatusForm.BitteWarten.Visible = True
'  Else
'    StatusForm.cmdAbbrechen.Visible = True
'  End If
  
  If AR_UseDB = True Then
    If theTrackerShowStatusform = True Then
      StatusForm.Show 0
    End If
  Else
    StatusForm.Show 0
  End If
  
End Sub

Sub StartDaemon()

  LogPrint "StartDaemon 1"
  
  'Application.Caption = "Excel-Sheet-Checker"
  Application.Caption = FMT0("MM_1")
  'AddStatus "Starte ECCDaemon"
  AddStatus FMT0("SCAN_44")
'  SaveECCDaemon
  SetLiveStatus
  LogPrint "StartDaemon 2"
  
  SaveSetting _
     appname:="Stromwerken", _
     Section:=progNameShort, _
     Key:="LiveStatusCaption", _
     setting:=Application.Caption
  SaveSetting _
     appname:="Stromwerken", _
     Section:=progNameShort, _
     Key:="LiveStatusExec", _
     setting:=ThisWorkbook.name
  
  LogPrint "StartDaemon 3"
  
'  Debug.Print "APPHWND: " & Application.Hwnd
'  Debug.Print "PROCESS: " & GetCurrentProcess
  
'  Dim L_HWND As Long
  
  'Microsoft Excel - Mappe1.xls = Caption der Excelanwendung
'  L_HWND = FindWindow("XLMain", Application.Caption)
'  Debug.Print "PROCESS: " & L_HWND

'  Debug.Print ThisWorkbook.Path & "\ECCDaemon.exe "
  
  SetLiveStatus
  
  
  LogPrint "StartDaemon 4"

  If AR_UseDB = True And G_cfgLogpfad <> "" Then
    SaveSetting appname:="Stromwerken", Section:="ECC", Key:="DaemonLog", setting:=G_cfgLogpfad & "\IDV-Suite Scheduler-" & GetUserName & ".txt"
  Else
    SaveSetting appname:="Stromwerken", Section:="ECC", Key:="DaemonLog", setting:=""
  End If

'  Call Shell(ThisWorkbook.Path & "\ECCDaemon.exe " & Chr(34) & Application.Caption & Chr(34) & " " & ThisWorkbook.name & " 1", vbMinimizedNoFocus)
  If Not FileExists(ThisWorkbook.path & "\ECCDaemon.exe") Then
    'AddStatus "Datei '" & ThisWorkbook.path & "\ECCDaemon.exe' nicht vorhanden, der ECCDaemon kann nicht gestartet werden!"
    AddStatus FMT1("SCAN_45", ThisWorkbook.path)
  Else
    Call Shell(ThisWorkbook.path & "\ECCDaemon.exe " & Chr(34) & Application.Caption & Chr(34) & " " & ThisWorkbook.name, vbMinimizedNoFocus)
  End If
'  Call Shell(ThisWorkbook.Path & "\ECCDaemon.exe " & GetCurrentProcess & " " & ThisWorkbook.name, vbMinimizedNoFocus)
  LogPrint "StartDaemon End"
End Sub

Sub EndDaemon()
  
  SaveSetting _
     appname:="Stromwerken", _
     Section:=progNameShort, _
     Key:="LiveStatus", _
     setting:="Finished"
  
  On Error Resume Next
End Sub

Sub SetLiveStatus()

  SaveSetting _
     appname:="Stromwerken", _
     Section:=progNameShort, _
     Key:="LiveStatusTime", _
     setting:=Now
  
  SaveSetting _
     appname:="Stromwerken", _
     Section:=progNameShort, _
     Key:="LiveStatus", _
     setting:="Alive"

  NextTime = Now + TimeValue("00:10:00")
'  Application.OnTime NextTime, "SetLiveStatus"
  
End Sub

Sub AddError(nfo As String)
    Dim s As String
    s = GetSetting(appname:="Stromwerken", Section:=progNameShort, Key:="Error")
    SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="Error", setting:= _
      IIf(s <> "", s & vbCrLf, "") & nfo
End Sub
Sub SetFileStatusInfo(nfo As String)
    Dim s As String
    s = GetSetting(appname:="Stromwerken", Section:="IDVSS", Key:="FileStatusInfo")
    SaveSetting appname:="Stromwerken", Section:="IDVSS", Key:="FileStatusInfo", setting:= _
      IIf(s <> "", s & vbCrLf, "") & nfo
End Sub
Sub SetLiveStatusFunc(funcname As String, enab As Boolean)
  If enab Then
    SaveSetting _
       appname:="Stromwerken", _
       Section:=progNameShort, _
       Key:="LiveStatusFunc", _
       setting:=funcname
  Else
    SaveSetting _
       appname:="Stromwerken", _
       Section:=progNameShort, _
       Key:="LiveStatusFunc", _
       setting:=""
  End If
End Sub


Sub CreateRisk()
  Dim rt As RiskTab
  
  Dim ri As XLScriptArray2D
  Set ri = XLScriptAddArray2D("RiskItems")
  
  Dim totalrisk As Double
  
  Debug.Print "CreateRisk starten"
  LogPrint "CreateRisk starten"
  
  totalrisk = 0
  
  For Each rt In G_RiskTabs
    Debug.Print "AddLine " & rt.m_TabName
    LogPrint "AddLine " & rt.m_TabName

    ri.AddLine UCase(rt.m_TabName)
    
    'ri.AddValue "Tabname", TranslateText(rt.m_TabName)
    ri.AddValue "Tabname", gTranslation.GetSafeString(rt.m_TabName, rt.m_TabName)
    
    Dim risk As Double
    risk = 0
    
    
    Dim rv As RiskVal
    For Each rv In rt.m_Vals
    
        Debug.Print "Eval " & rv.m_Parameter
        LogPrint "Eval " & rv.m_Parameter
        
      Select Case rv.m_Type
      
        Case C_RISK_TYPE_ECC
      
'              Dim xlssv As XLScriptSimpleVar
'              Set xlssv = XLScriptGetSimpleVar(rv.m_Parameter)
              
              Dim v As String
              v = XLScriptGetVarValue(rv.m_Parameter, Nothing)
              
              If v = "" Then v = "0"
              
              If v = "" Then
                Debug.Print "Unknown risk var: " & rv.m_Parameter
                'MsgBox "Unknown risk var: " & rv.m_Parameter, vbCritical, "Excel-Sheet-Checker"
                MsgBox FMT1("SCAN_46", rv.m_Parameter), vbCritical, FMT0("MM_1")
              Else
                  
                  If Len(v) > 0 Then
                      
                        Dim rr As RiskRange
                        For Each rr In rv.m_Vals
                            
                            Select Case rr.m_Comparison
                              Case C_RISK_COMP_TYPE_LESS
                                If Val(v) < rr.m_Value Then
                                  risk = risk + rr.m_Risk
                                  XLScriptAddSimpleVar rv.m_Parameter & "BC", IIf(rr.m_Risk <= rt.m_Low, rt.m_LowColour, IIf(rr.m_Risk <= rt.m_Med, rt.m_MedColour, rt.m_HighColour))
                                  Exit For
                                End If
                              Case C_RISK_COMP_TYPE_LESSEQUAL
                                If Val(v) <= rr.m_Value Then
                                  risk = risk + rr.m_Risk
                                  XLScriptAddSimpleVar rv.m_Parameter & "BC", IIf(rr.m_Risk <= rt.m_Low, rt.m_LowColour, IIf(rr.m_Risk <= rt.m_Med, rt.m_MedColour, rt.m_HighColour))
                                  Exit For
                                End If
                              Case C_RISK_COMP_TYPE_EQUAL
                                If Val(v) = rr.m_Value Then
                                  risk = risk + rr.m_Risk
                                  XLScriptAddSimpleVar rv.m_Parameter & "BC", IIf(rr.m_Risk <= rt.m_Low, rt.m_LowColour, IIf(rr.m_Risk <= rt.m_Med, rt.m_MedColour, rt.m_HighColour))
                                  Exit For
                                End If
                              Case C_RISK_COMP_TYPE_LARGER
                                If Val(v) > rr.m_Value Then
                                  risk = risk + rr.m_Risk
                                  XLScriptAddSimpleVar rv.m_Parameter & "BC", IIf(rr.m_Risk <= rt.m_Low, rt.m_LowColour, IIf(rr.m_Risk <= rt.m_Med, rt.m_MedColour, rt.m_HighColour))
                                  Exit For
                                End If
                              Case C_RISK_COMP_TYPE_LARGEREQUAL
                                If Val(v) >= rr.m_Value Then
                                  risk = risk + rr.m_Risk
                                  XLScriptAddSimpleVar rv.m_Parameter & "BC", IIf(rr.m_Risk <= rt.m_Low, rt.m_LowColour, IIf(rr.m_Risk <= rt.m_Med, rt.m_MedColour, rt.m_HighColour))
                                  Exit For
                                End If
                            End Select
                            
                        Next rr
                  
                  
                  End If
              End If
        Case C_RISK_TYPE_FORMULA_CONTAINS, C_RISK_TYPE_WHITE_LIST, C_RISK_TYPE_NOT_IN_WHITE_LIST
        
              For Each rr In rv.m_Vals
                  
                  Select Case rr.m_Comparison
                    Case C_RISK_COMP_TYPE_LESS
                      If rv.m_Matches < rr.m_Value Then
                        risk = risk + rr.m_Risk
                        Exit For
                      End If
                    Case C_RISK_COMP_TYPE_LESSEQUAL
                      If rv.m_Matches <= rr.m_Value Then
                        risk = risk + rr.m_Risk
                        Exit For
                      End If
                    Case C_RISK_COMP_TYPE_EQUAL
                      If rv.m_Matches = rr.m_Value Then
                        risk = risk + rr.m_Risk
                        Exit For
                      End If
                    Case C_RISK_COMP_TYPE_LARGER
                      If rv.m_Matches > rr.m_Value Then
                        risk = risk + rr.m_Risk
                        Exit For
                      End If
                    Case C_RISK_COMP_TYPE_LARGEREQUAL
                      If rv.m_Matches >= rr.m_Value Then
                        risk = risk + rr.m_Risk
                        Exit For
                      End If
                  End Select
                  
              Next rr
        
      End Select
    Next rv
    
    Debug.Print "Riskio ist " & CStr(risk)
    LogPrint "Risiko ist " & CStr(risk)
    
    ri.AddValue "Risk", CStr(IIf(risk > 1, 1, risk * 1))
    
    Dim multi As Double
    
    If risk <= rt.m_Low Then
      ri.AddValue "Col", rt.m_LowColour
      multi = rt.m_LowMulti
    ElseIf risk <= rt.m_Med Then
      ri.AddValue "Col", rt.m_MedColour
      multi = rt.m_MedMulti
    Else
      ri.AddValue "Col", rt.m_HighColour
      multi = rt.m_HighMulti
    End If
    
    If G_cfgTeilrisikoDeckeln Then
      totalrisk = totalrisk + multi * IIf(risk > 1#, 1#, risk) * rt.m_Weight
    Else
      totalrisk = totalrisk + multi * risk * rt.m_Weight
    End If
    
  Next rt
  
  LogPrint "TotalRisiko ist " & CStr(totalrisk)
  
  XLScriptAddSimpleVar "TotalRisk", CStr(IIf(totalrisk > 1, 1, totalrisk))
  
  If totalrisk <= G_RiskLow Then
    XLScriptAddSimpleVar "TotalRiskCol", CStr(G_RiskLowCol)
  ElseIf totalrisk <= G_RiskMed Then
    XLScriptAddSimpleVar "TotalRiskCol", CStr(G_RiskMedCol)
  Else
    XLScriptAddSimpleVar "TotalRiskCol", CStr(G_RiskHighCol)
  End If
  
  Debug.Print "CreateRisk Ende"
  LogPrint "CreateRisk Ende"
  ' Und das Gesamtrisiko ermitteln
  
End Sub

Sub AddKommentare(ByRef wb As Workbook)
  ' Kommentare einf|fffd|gen
  Dim y As Long
  
  With Sheets("Kommentare")
    y = 1
    Do While .Cells(y, 1) <> ""
        Dim c As Range
        Dim fc As Range
        Dim first As Boolean
        first = True
        wb.Sheets(1).Activate
        Do
          Set c = wb.ActiveSheet.Cells.Find(What:=CStr(.Cells(y, 1).value), _
            LookIn:=xlValues, LookAt:=xlPart, SearchOrder:=xlByRows, _
            SearchDirection:=IIf(first, xlFirst, xlNext), MatchCase:=False, SearchFormat:=False)
            
          If c Is Nothing Then
            Exit Do
          Else
            If first Then
              Set fc = c
              first = False
            Else
              If c = fc Then Exit Do
            End If
            If CommentExists(c) Then
              c.Comment.Delete
            End If
            c.AddComment .Cells(y, 2).value
            If Len(.Cells(y, 2).value) > 50 Then
              c.Comment.Shape.Width = 240
              c.Comment.Shape.Height = 500
            End If
          End If
        Loop
        y = y + 1
    Loop
  End With
End Sub

Sub AddMyComment(c As Range, txt As String)

  Dim w As Long
  Dim h As Long
  
  w = IIf(Len(txt) > 30, IIf(Len(txt) > 60, 600, 320), 160)
  h = 12

  If c.Comment Is Nothing Then
    With c.AddComment
      .Text txt
      .Shape.Width = w
      .Shape.Height = h
    End With
  Else
    Dim neww As Long
    If c.Comment.Shape.Width < w Then
      neww = w
    Else
      neww = c.Comment.Shape.Width
    End If
    Dim newh As Long
    newh = h + c.Comment.Shape.Height '  + 12
    Dim newtxt As String
    newtxt = c.Comment.Text & vbLf & txt
    c.Comment.Delete
    With c.AddComment
      .Text newtxt
      .Shape.Width = neww
      .Shape.Height = newh
    End With
  End If
End Sub

Sub StoreComm(ison As Boolean)
  On Error Resume Next
  
  If G_conn Is Nothing Then Exit Sub
  
  Dim rsECCScan As Object
  Dim count As Long
  
  Set rsECCScan = OpenRS("select Count(idvDateiId) as count from ECCScan", G_conn, MYadOpenDynamic, MYadLockReadOnly)
  count = rsECCScan.Fields("count").value
  rsECCScan.Close
  
  Set rsECCScan = OpenRS("select * FROM gCommunicate WHERE Interface = 'ECC'", G_conn, MYadOpenDynamic, MYadLockOptimistic)
  If Not rsECCScan Is Nothing Then
    If rsECCScan.EOF Then
      rsECCScan.AddNew
      rsECCScan.Fields("Interface").value = "ECC"
    End If
    rsECCScan.Fields("COMM").value = "SCAN=" & IIf(ison, "ON", "OFF") & vbCrLf & "RESTSCAN=" & count & vbCrLf & "DATE=" & Now & vbCrLf & "FILENAME=" & theFilename
    rsECCScan.Update
    rsECCScan.Close
    Set rsECCScan = Nothing
  End If

End Sub

Sub StoreUserCommunicateValue(prefix As String, s As String)

  On Error Resume Next
  
  If G_conn Is Nothing Then Exit Sub
  
  Dim rsECCScan As Object
  Dim count As Long
  
  Set rsECCScan = OpenRS("select * FROM gCommunicate WHERE Interface = '" & prefix & "-" & IIf(theTrackerFreigabe, theFreigabeuser, GetUserName) & "'", G_conn, MYadOpenDynamic, MYadLockOptimistic)
  If Not rsECCScan Is Nothing Then
    If rsECCScan.EOF Then
      rsECCScan.AddNew
      rsECCScan.Fields("Interface").value = prefix & "-" & IIf(theTrackerFreigabe, theFreigabeuser, GetUserName)
    End If
    rsECCScan.Fields("COMM").value = s
    rsECCScan.Update
    rsECCScan.Close
    Set rsECCScan = Nothing
  End If

End Sub


Function TrackerTimeInScope() As Boolean
  
  TrackerTimeInScope = True
  
  If Not AR_UseDB Then Exit Function
  
  If theTrackerFreigabe Then Exit Function
  
  If G_SchedulerTimeCheckIgnore Then Exit Function
    
  If TimeInScope(Now, G_StartScan, G_EndScan) Then Exit Function
    
  TrackerTimeInScope = False
  
End Function

Sub GConnClose()
  On Error Resume Next
  If Not G_conn Is Nothing Then
    G_conn.Close
    Set G_conn = Nothing
  End If
End Sub

Sub ShowAllCells(ByRef oxlwsheet)
On Error Resume Next
  oxlwsheet.Rows.AutoFit
  oxlwsheet.Columns.AutoFit
End Sub

Sub UnfoldGroups(ByRef oxlwsheet)
On Error Resume Next
  oxlwsheet.Outline.ShowLevels 8, 8
  oxlwsheet.Cells.AutoFilter
End Sub

Sub CheckForET(ByRef app As Excel.Application)
On Error Resume Next
  Dim s As String
'  If WorkbookExists(ThisWorkbook.Application, "ExcelTracker.xlam") Then
'    s = "ExcelTracker.xlam"
'  ElseIf WorkbookExists(ThisWorkbook.Application, "ExcelTracker.xla") Then
'    s = "ExcelTracker.xla"
'  ElseIf WorkbookExists(ThisWorkbook.Application, "ExcelTracker.xlsm") Then
'    s = "ExcelTracker.xlsm"
'  End If
  
'  MsgBox s

  s = GetSetting(appname:="Stromwerken", Section:="ET", Key:="LoadET", default:="")
  SaveSetting appname:="Stromwerken", Section:="ET", Key:="LoadET", setting:=""
  
  If s <> "" Then
    app.Workbooks.Open s, False, True, , , , True, , , , , , False
    app.Run "'" & s & "'!MyWorkbookOpen"
    app.Workbooks(GetFileNameAndExtension(s)).Saved = True
  End If
  
  Dim CurrAddin As Excel.AddIn
  Dim destAddin As Excel.AddIn

  For Each CurrAddin In Application.AddIns
      If CurrAddin.Installed Then
        For Each destAddin In app.AddIns
          If CurrAddin.FullName = destAddin.FullName Then
            destAddin.Installed = False
            destAddin.Installed = True
            Exit For
          End If
        Next destAddin
      End If
  Next CurrAddin

  Exit Sub
    
End Sub

Function ResolveLink(ByVal t As String) As String
'='D:\development\Testdaten Excel\[110803re.xls]Risikoparameter'!$A$10
' Hier kommt das noch der Kram mit dem Flag rein
On Error GoTo nogo
  If InStr(t, "'") <= 0 Then
    ResolveLink = t
    Exit Function
  End If
  
  Dim pos As Long
  pos = 1
  Do While pos < Len(t)
  
    If Mid(t, pos, 1) <> "'" Then
      pos = pos + 1
    Else
        
        ' Jetzt wird von hier aus die eckige Klammer gesucht.
        Dim pos2 As Long
        pos2 = pos + 1
        Do While pos2 < Len(t)
          If Mid(t, pos2, 2) = "''" Then
            pos2 = pos2 + 2
          ElseIf Mid(t, pos2, 1) = "[" Then
            Exit Do
          Else
            pos2 = pos2 + 1
          End If
        Loop
        
        
        ' Wenn eine eckige Klammer gefunden wurde muss jetzt als n|fffd|chstes mindestens die schlie|fffd|ende eckige Klammer sowie das '! gefunden werden
        Dim ok As Boolean
        ok = False
        If pos2 < Len(t) Then
          If Mid(t, pos2, 1) = "[" Then
          
            ' So, jetzt wird noch bis zum hinteren apostroph gesucht
            Dim pos3 As Long
            pos3 = pos2 + 1
            
            Dim closeBracCount As Long
            closeBracCount = 0
          
            Do While pos3 < Len(t)
              If Mid(t, pos2, 2) = "''" Then
                pos3 = pos3 + 2
              ElseIf Mid(t, pos3, 2) = "'!" Then
                Exit Do
              ElseIf Mid(t, pos3, 1) = "]" Then
                closeBracCount = closeBracCount + 1
                pos3 = pos3 + 1
              Else
                pos3 = pos3 + 1
              End If
            Loop
          
            ' Wurde '! gefunden?
            If pos3 < Len(t) Then
              If Mid(t, pos3, 2) = "'!" And closeBracCount = 1 Then
                ok = True
                Dim fnameandTable As String
                fnameandTable = Mid(t, pos2, pos3 - pos2)
                
                fnameandTable = Replace(fnameandTable, "''", "'")
                
                t = Left(t, pos - 1) & fnameandTable & Mid(t, pos3 + 1)
                pos = pos + Len(fnameandTable)
              End If
            End If
          End If
        End If
        
        If Not ok Then Exit Do
    End If
  Loop
  ResolveLink = t
  Exit Function
nogo:
  ResolveLink = t
End Function

Attribute VB_Name = "ScanFile"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public m_Name As String
Public m_OEID As Long
Public m_idvDateiID As Long
Public m_CheckerSettings As Long

Attribute VB_Name = "ScanFuncs"
Option Explicit


Attribute VB_Name = "SpeedTest"
Option Explicit


Private Const L_FileLoadSecurityMultiplier = 3#
Private Const L_FormulaAccessSecurityMultiplier = 3#

Sub SpeedTest()
  
  If Not FileExists(ThisWorkbook.path & "\Speedtest.xls") Then Exit Sub
  
  Dim wb As Workbook
  
  Dim fsize As Double
  fsize = MyFileLen(ThisWorkbook.path & "\Speedtest.xls")
  
  If fsize = 0 Then Exit Sub
  
  
#If DoProfile = False Then
  Dim hrt As New HighResTimer
#End If
  
  Dim res As Boolean
  hrt.StartCounting "Speedtest1"
  res = GetExcelFile(ThisWorkbook.path & "\Speedtest.xls", wb)
  hrt.StopCounting "Speedtest1"
  Dim loadTime As Double
  loadTime = hrt.GetCount("Speedtest1")
  
  If Not res Then
#If DoProfile = False Then
  Set hrt = Nothing
#End If
    Exit Sub
  End If
  
  
  Debug.Print " 2MB LoadTime: " & loadTime / fsize * CDbl(2) * CDbl(1024) * CDbl(1024) & " sec"
  Debug.Print "10MB LoadTime: " & loadTime / fsize * CDbl(10) * CDbl(1024) * CDbl(1024) & " sec"
  Debug.Print "20MB LoadTime: " & loadTime / fsize * CDbl(20) * CDbl(1024) * CDbl(1024) & " sec"
  Debug.Print "50MB LoadTime: " & loadTime / fsize * CDbl(50) * CDbl(1024) * CDbl(1024) & " sec"
  
  
  Dim formulaAccessTime As Double
  Dim r As Range
  
  wb.Sheets(1).Unprotect
  hrt.StartCounting "Speedtest2"
  Set r = wb.Sheets(1).Cells.SpecialCells(xlCellTypeFormulas)
  hrt.StopCounting "Speedtest2"
  
  formulaAccessTime = hrt.GetCount("Speedtest2")
  
  If Not r Is Nothing Then
    If r.count > 0 Then
    
      Debug.Print r.count & " formulas access time: " & formulaAccessTime & " sec"
      Debug.Print 10 * r.count & " formulas access time: " & 10 * formulaAccessTime & " sec"
      Debug.Print 20 * r.count & " formulas access time: " & 20 * formulaAccessTime & " sec"
    
    End If
  End If
  
  wb.Saved = True
  Set wb = Nothing
  
    
#If DoProfile = False Then
  Set hrt = Nothing
#End If
    
End Sub
Attribute VB_Name = "Sprache"
Attribute VB_Base = "0{16265CB1-F666-4595-892A-0FBBF41F54C7}{F4B9F36E-3166-44C5-B366-5A97288AF131}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

'Sub MyInit()
'  ComboBox1.Clear
'  ComboBox1.addItem "Deutsch"
'  ComboBox1.addItem "English"
'  If GSprache = 1 Then
'    ComboBox1.value = "Deutsch"
'  Else
'    ComboBox1.value = "English"
'  End If
'End Sub
'
'Private Sub cmdOK_Click()
'  If ComboBox1 = "English" Then
'    GSprache = 2
'  Else
'    GSprache = 1
'  End If
'  Me.Hide
'End Sub

Private Sub UserForm_Initialize()
  gTranslation.TranslateForm Me
End Sub
Attribute VB_Name = "Start"
Option Explicit

Public Const C_IDVTrackerTest As Boolean = False
Public G_Command As String
Public G_DaemonCommand As String
Public G_FileAlreadyOpen As Boolean
Public G_NoParamAsk As Boolean
Public G_ForceAppCloseAfterScan As Boolean
Public G_CreateResfile As Long
Public G_ResfileDestID As Long
Public G_ResfileTemplate As String
Public G_Resfile As String
Public G_DestResfile As String
Public G_NoClose As Boolean

#If VBA7 Then
Private Declare PtrSafe Function GetCurrentProcessId Lib "kernel32" () As Long
Public Declare PtrSafe Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (pDest As Any, pSource As Any, ByVal cb As LongPtr)
#Else
Private Declare Function GetCurrentProcessId Lib "kernel32" () As Long
Private Declare Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (Destination As Any, Source As Any, ByVal Length As Long)
#End If


Public Function StartECCAnalyse()
  G_FileAlreadyOpen = True
  Auto_Open
End Function


Sub Auto_Open()
' MsgBox "Start"

  Dim starttimeset As Boolean
  Dim endtimeset As Boolean

'  SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="COMMAND", setting:="SCANID /IDCALLER:" & SWAPPID_IDVSuiteScheduler & " /ID:10046"
'  SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="COMMAND", setting:="DAEMON"
'  SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="COMMAND", setting:="MASSANALYSE /STARTTIME: 09:31:07 /ENDTIME:10:31:06"

  SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="TrackerFreigabe", setting:="False"
  SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="ProcResult", setting:=""
  
  SetLiveStatus
  G_HiglyEncryptedSheetPW = 0

  If GetSetting(appname:="Stromwerken", Section:="ECC", Key:="AbortAction", default:="") <> "" Then
    SaveSetting appname:="Stromwerken", Section:="ECC", Key:="AbortAction", setting:=""
    SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="LiveStatusTime", setting:=#1/1/1900#
    SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="Restart", setting:=0
    SaveSetting appname:="Stromwerken", Section:="IDVSS", Key:="CallbackExcelStart", setting:=1
    Application.Quit
  End If

  Set G_conn = Nothing
  
  G_Command = ""

  Dim commandString As String
  Dim appc As New CAppCommand
  Dim errString As String
  
  commandString = GetSetting(appname:="Stromwerken", Section:=progNameShort, Key:="COMMAND", default:="")
  
  Dim errstr As String
  
  ' MsgBox "COMMAND: " & commandString
  If commandString <> "" Then
    DebugPrint tinfo, "Command String: " & commandString
    SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="COMMAND", setting:=""
    appc.Init commandString
    Select Case appc.m_Command
      
      ' Third Party
      Case "TPSCAN"
        G_NoParamAsk = True
        appc.AddParameter vbString, "/FNAME:", False
        appc.AddParameter vbString, "/RESFILE:", True
        appc.AddParameter vbString, "/RESTEMPLATE:", True
        appc.AddParameter vbString, "/DESTRESFILE:", True
        appc.CheckValues errString
        If errString = "" Then
          AR_StartedByApp = 10000
          theidvDateiID = 0
          G_CreateResfile = 5 ' 1 Save in Command. 2 Just open, don't save. 3 Save in ZusDateien. 4 Save in RESFILE. 5 store in DestRessFile
          theFilename = appc.GetValue("/FNAME:")
          G_ResfileTemplate = appc.GetValue("/RESTEMPLATE:")
          G_Resfile = appc.GetValue("/RESFILE:")
          G_DestResfile = appc.GetValue("/DESTRESFILE:")
          
          If G_DestResfile <> "" Then
            G_ForceAppCloseAfterScan = True
          End If
        End If
      
      Case "SCANID"
        AR_UseDB = True
        appc.AddParameter vbInteger, "/IDCALLER:", False
        appc.AddParameter vbInteger, "/ID:", False
        appc.AddParameter vbInteger, "/RES:", True
        appc.AddParameter vbInteger, "/DESTID:", True
        appc.AddParameter vbString, "/RESTEMPLATE:", True
        appc.AddParameter vbString, "/RESFILE:", True
        appc.AddParameter 0, "/NOCLOSE", True
        appc.AddParameter vbString, "/FNAME:", True
        appc.CheckValues errString
        If errString = "" Then
          AR_StartedByApp = Val(appc.GetValue("/IDCALLER:"))
          theidvDateiID = Val(appc.GetValue("/ID:"))
          G_CreateResfile = Val(appc.GetValue("/RES:")) ' 1 Save in Command. 2 Just open, don't save. 3 Save in ZusDateien. 4 Save in RESFILE
          G_ResfileDestID = Val(appc.GetValue("/DESTID:"))
          G_ResfileTemplate = appc.GetValue("/RESTEMPLATE:")
          G_Resfile = appc.GetValue("/RESFILE:")
          G_NoClose = appc.ParameterExists("/NOCLOSE")
          theFilename = appc.GetValue("/FNAME:")

        End If
      
      Case "DAEMON"
        StartedByDaemon = True
        appc.AddParameter vbInteger, "/IDCALLER:", False
        appc.AddParameter 0, "/DB", True
        appc.AddParameter vbTime, "/STARTTIME:", True
        appc.AddParameter vbTime, "/ENDTIME:", True
        appc.CheckValues errString
        AR_StartedByApp = Val(appc.GetValue("/IDCALLER:"))
        If errString = "" Then
          AR_UseDB = appc.ParameterExists("/DB")
          If IsTime(appc.GetValue("/STARTTIME:")) Then
            G_StartScan = CDate(appc.GetValue("/STARTTIME:"))
            starttimeset = True
          End If
          If IsTime(appc.GetValue("/ENDTIME:")) Then
            G_EndScan = CDate(appc.GetValue("/ENDTIME:"))
            endtimeset = True
          End If
        End If
      
      Case "MASSANALYSE"
        AR_UseDB = True
        appc.AddParameter vbTime, "/STARTTIME:", True
        appc.AddParameter vbTime, "/ENDTIME:", True
        appc.CheckValues errString
        AR_StartedByApp = SWAPPID_IDVSuiteScheduler
        If errString = "" Then
          If IsTime(appc.GetValue("/STARTTIME:")) Then
            G_StartScan = CDate(appc.GetValue("/STARTTIME:"))
            starttimeset = True
          End If
          If IsTime(appc.GetValue("/ENDTIME:")) Then
            G_EndScan = CDate(appc.GetValue("/ENDTIME:"))
            endtimeset = True
          End If
        End If
        
      Case "APPROVAL"
      
        AR_UseDB = True
        appc.AddParameter vbInteger, "/IDCALLER:", False
        appc.AddParameter vbInteger, "/ID:", False
        appc.AddParameter vbDate, "/DATE:", False
        appc.AddParameter vbString, "/COMMENT:", False
        appc.AddParameter vbString, "/USER:", False
        appc.AddParameter vbInteger, "/RES:", True
        appc.AddParameter vbInteger, "/DESTID:", True
        appc.AddParameter vbString, "/RESTEMPLATE:", True
        appc.AddParameter vbString, "/RESFILE:", True
        appc.CheckValues errString
        AR_StartedByApp = SWAPPID_IDVSuiteScheduler
        AR_StartedByApp = Val(appc.GetValue("/IDCALLER:"))
        If errString = "" Then
          theTrackerFreigabe = True
          theidvDateiID = Val(appc.GetValue("/ID:"))
          theTrackerFreigabeDatum = CDate(appc.GetValue("/DATE:"))
          theFreigabekommentar = appc.GetValue("/COMMENT:")
          theFreigabeuser = appc.GetValue("/USER:")
          G_CreateResfile = Val(appc.GetValue("/RES:"))
          G_ResfileDestID = Val(appc.GetValue("/DESTID:"))
          DebugPrint tinfo, "APPROVAL DateiID:" & theidvDateiID & " User: " & theFreigabeuser
          G_ResfileTemplate = appc.GetValue("/RESTEMPLATE:")
          G_Resfile = appc.GetValue("/RESFILE:")
        End If
    End Select
  End If

  If AR_UseDB Then
    G_DaemonCommand = "DAEMON /IDCALLER:" & AR_StartedByApp & " /DB" & IIf(starttimeset, " /STARTTIME:" & MyTimeValue24H(G_StartScan), "") & IIf(endtimeset, " /ENDTIME:" & MyTimeValue24H(G_EndScan), "")
    SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="DAEMONCOMMAND", setting:=G_DaemonCommand
  Else
    G_DaemonCommand = "DAEMON /IDCALLER:" & AR_StartedByApp & IIf(starttimeset, " /STARTTIME:" & MyTimeValue24H(G_StartScan), "") & IIf(endtimeset, " /ENDTIME:" & MyTimeValue24H(G_EndScan), "")
    SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="DAEMONCOMMAND", setting:=G_DaemonCommand
  End If

  ' Wird dazwischen gemacht, damit wir auch den Logpfad und alles andere haben
  InitApp
  
  If Not TrackerTimeInScope() Then
    SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="LiveStatusTime", setting:=#1/1/1900#
    SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="Restart", setting:=0
    SaveSetting appname:="Stromwerken", Section:="IDVSS", Key:="CallbackExcelStart", setting:=1
    ThisWorkbook.Saved = True
    RegRemoveProgPID "ECC"
    Application.Quit
    Exit Sub
  End If
  
  ' ------------------------------------------------------------------------------
  ' Commands
  ' ------------------------------------------------------------------------------
  If commandString <> "" Then
    If errString <> "" Then
      errString = errString & " (|fffd|bergebener Command-String: " & commandString & ")"
'      LogPrint errString
      LogPrintECCSCanLog 0, 9, errString, True
      If AR_StartedByApp <> SWAPPID_IDVSuiteScheduler Then
        MsgBox errString, vbCritical, progNameShort & " V" & MyVersion
      End If
      If G_FileAlreadyOpen = True Then
        ThisWorkbook.Close False
        Exit Sub
      Else
        ThisWorkbook.Saved = True
        RegRemoveProgPID "ECC"
        SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="LiveStatusTime", setting:=#1/1/1900#
        SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="Restart", setting:=0
        SaveSetting appname:="Stromwerken", Section:="IDVSS", Key:="CallbackExcelStart", setting:=1
        Application.Quit
        Exit Sub
      End If
    End If
  
    ' Ab hier werden die einzelnen Kommandos ausgef|fffd|hrt
    If AR_UseDB Then
    
      RegAddProgPID "ECC"
      DoTaskKillExcelSheetChecker
      SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="LiveStatusTime", setting:=#1/1/1900#
      SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="Restart", setting:=0
      SaveSetting appname:="Stromwerken", Section:="IDVSS", Key:="CallbackExcelStart", setting:=1
    
      LogPrint "CheckConnection"
      Set G_conn = GetConnection()
      
      If G_conn Is Nothing Then
        LogPrintECCSCanLog 0, 9, "Keine DB-Connection vorhanden", True
        If AR_StartedByApp <> SWAPPID_IDVSuiteScheduler Then
          If theTrackerFreigabe Then
            'MsgBox "Eine Freigabe ist kann nicht durchgef|fffd|hrt werden, da das Datenbanksystem nicht erreichbar ist.", vbCritical
            MsgBox FMT0("START_1"), vbCritical
          End If
        End If
        ThisWorkbook.Saved = True
        Application.EnableEvents = True
        RegRemoveProgPID "ECC"
        Application.Quit
        Exit Sub
      Else
        LogPrint "1. Connect erfolgreich"
      End If
      
    End If
  
    ' ------------------------------------------------------------------------------
    ' Command Execution
    ' ------------------------------------------------------------------------------
    Dim rs
    Select Case appc.m_Command
      
      Case "TPSCAN"
        If theFilename = "" Then
          AR_UseDB = False
          theidvDateiID = 0
          AR_StartedByApp = 0
          GoTo showMainmenu
        Else
          G_SchedulerTimeCheckIgnore = True
          ' G_Command = "SCANID"
          ' theFilename = Mid(commandString, 6)
          XLScriptInitDebug
          ShowStatusForm theFilename
          DoEinzelanalyse
          SaveSetting appname:="Stromwerken", Section:="IDVSS", Key:="ECCScanFinished", setting:="1"
        End If
      
      Case "SCANID", "APPROVAL"
        Set rs = OpenRS("SELECT Dateiname FROM idvDateien WHERE idvDateiID=" & theidvDateiID, G_conn, MYadLockOptimistic, MYadLockReadOnly)
        If rs Is Nothing Then
          LogPrintECCSCanLog 0, 9, "idvDateien konnte nicht ge|fffd|ffnet werden", True
        ElseIf rs.EOF Then
          LogPrintECCSCanLog theidvDateiID, 9, "DateiID nicht vorhanden!", True
        Else
          theFilename = rs.Fields("Dateiname").value
          rs.Close
        End If
        Set rs = Nothing
        
        If theFilename = "" Then
          AR_UseDB = False
          theidvDateiID = 0
          AR_StartedByApp = 0
          GoTo showMainmenu
        Else
          G_SchedulerTimeCheckIgnore = True
          ' G_Command = "SCANID"
          ' theFilename = Mid(commandString, 6)
          XLScriptInitDebug
          ShowStatusForm theFilename
          DoEinzelanalyse
          SaveSetting appname:="Stromwerken", Section:="IDVSS", Key:="ECCScanFinished", setting:="1"
        End If
      
      Case "DAEMON"
        ShowStatusForm ""
        DoMassenanalyse
    
      Case "MASSANALYSE"
        LogPrint "MASSANALYSE: " & G_StartScan & " - " & G_EndScan
        StoreUserCommunicateValue "TU", ""
        StoreUserCommunicateValue "FG", ""
        ShowStatusForm ""
        DoMassenanalyse
      
      Case Else
'        LogPrint "Unknown Command: " & commandString
        LogPrintECCSCanLog 0, 9, "Unknown Command: " & commandString, True
        If IsTestUser Then
          MsgBox "Unknown Command: " & commandString
        End If
        If Not G_conn Is Nothing Then
          G_conn.Close
          Set G_conn = Nothing
        End If
        ThisWorkbook.Saved = True
        Application.EnableEvents = True
        RegRemoveProgPID "ECC"
        Application.Quit
    End Select
    Exit Sub
  End If
  
  ' ---------------------------------------------------------
  ' Normales Men|fffd|
  ' ---------------------------------------------------------
showMainmenu:
  LogPrint "StandardStart"
  SetMenuBar
  LogPrint "ShowMainMenu"
  If UCase(ThisWorkbook.name) = UCase(ProgNameLong) & ".XLS" Or UCase(ThisWorkbook.name) = UCase(ProgNameLong) & ".XLA" Then
      ExcelSheetCheckShowMainMenu
  End If
  
End Sub

Private Sub SetMenuBar()
        Dim found As Boolean
        Dim c
        LogPrint "Commandbar Check"
        For Each c In Application.CommandBars("Worksheet Menu Bar").Controls
            If c.Caption = "ECC" Then
                Application.CommandBars("Worksheet Menu Bar").Controls("ECC").Delete
                Exit For
            End If
        Next c
        For Each c In Application.CommandBars("Worksheet Menu Bar").Controls
            If c.Caption = "SSC" Then
                Application.CommandBars("Worksheet Menu Bar").Controls("SSC").Delete
                Exit For
            End If
        Next c
        
        Dim cbb As CommandBarPopup
        Dim scbb As CommandBarButton
        
        LogPrint "Commandbar Add"
        Set cbb = Application.CommandBars("Worksheet Menu Bar").Controls.Add(Type:=msoControlPopup)
        
        LogPrint "Commandbar Button 1"
        cbb.Caption = progNameShort
        Set scbb = cbb.Controls.Add
        scbb.BeginGroup = False
        scbb.Style = msoButtonCaption
        'scbb.Caption = "Start"
        scbb.Caption = FMT0("START_3")
        scbb.OnAction = "ExcelSheetCheckShowMainMenuFromMenu"
        'scbb.TooltipText = Texte(GSprache, TXT_STARTECC)
        scbb.TooltipText = FMT1("START_4", ProgNameLong)
        
        LogPrint "Commandbar Button 2"
        Set scbb = cbb.Controls.Add
        scbb.BeginGroup = False
        scbb.Style = msoButtonCaption
        'scbb.Caption = "Aus Men|fffd| entfernen"
        scbb.Caption = FMT0("START_5")
        scbb.OnAction = "ExcelSheetCheckRemoveMenu"
        'scbb.TooltipText = Texte(GSprache, TXT_REMOVEECC)
        scbb.TooltipText = FMT1("START_6", ProgNameLong)
        
        LogPrint "Commandbar Button 3"
        Set scbb = cbb.Controls.Add
        scbb.BeginGroup = False
        scbb.Style = msoButtonCaption
        'scbb.Caption = "Einzelanalyse"
        scbb.Caption = FMT0("START_8")
        scbb.OnAction = "EinzelanalyseStarten"
    '    scbb. =
        'scbb.TooltipText = "Startet die Einzelanalyse"
        scbb.TooltipText = FMT0("START_9")
        
        LogPrint "Commandbar Button 4"
        Set scbb = cbb.Controls.Add
        scbb.BeginGroup = False
        scbb.Style = msoButtonCaption
        'scbb.Caption = "Massenanalyse"
        scbb.Caption = FMT0("START_10")
        scbb.OnAction = "MassenanalyseStarten"
        'scbb.TooltipText = "Startet die Massenanalyse"
        scbb.TooltipText = FMT0("START_11")
        
        LogPrint "Commandbar Button 5"
        Set scbb = cbb.Controls.Add
        scbb.BeginGroup = False
        scbb.Style = msoButtonCaption
        'scbb.Caption = "Massenanalyse forsetzen"
        scbb.Caption = FMT0("START_12")
        scbb.OnAction = "MassenanalyseFortsetzen"
        'scbb.TooltipText = "Startet eine bereits begonnene Massenanalyse"
        scbb.TooltipText = FMT0("START_13")
        
        ' .NET START
        Set scbb = cbb.Controls.Add
        scbb.BeginGroup = False
        scbb.Style = msoButtonCaption
        'scbb.Caption = "Einzelanalyse der Datei in der aktiven Zelle"
        scbb.Caption = FMT0("START_14")
        scbb.OnAction = "EinzelanalyseZelle"
        scbb.TooltipText = FMT0("START_15")
        ' .NET END

        
        
        Set scbb = cbb.Controls.Add
        scbb.BeginGroup = False
        scbb.Style = msoButtonCaption
        'scbb.Caption = "Suchleiste anzeigen"
        scbb.Caption = FMT0("START_16")
        scbb.OnAction = "ECCShowBar"
        'scbb.DescriptionText = "Zeigt eine Leiste an, mit der Sie eingef|fffd|rbte Ergebniszellen finden k|fffd|nnen."
        scbb.DescriptionText = FMT0("START_17")
        
        Set scbb = cbb.Controls.Add
        scbb.BeginGroup = False
        scbb.Style = msoButtonCaption
        'scbb.Caption = "Dokumentation"
        scbb.Caption = FMT0("START_18")
        scbb.OnAction = "ECCShowDoku"
        'scbb.DescriptionText = "Zeigt die Dokumentation des Programms an."
        scbb.DescriptionText = FMT0("START_19")
        
End Sub


Sub InitApp()

  Dim cfg As New CfgReader
  Dim s As String
  
  G_NoMenu = False
  G_ChecksumVBA = True
  G_ChecksumNames = True
  G_ChecksumPivot = True
  G_ChecksumQueries = True
  G_ChecksumDiagrams = True
  G_ChecksumClone = True
  G_cfgTeilrisikoDeckeln = True
  G_cfgIgnoreHighestPriority = False
  G_cfgPwCheckLimMB = -1
            
  theTrackerPasswordLog = True
  theTrackerFormelnExtrahieren = False ' GetSetting(appname:="Stromwerken", Section:="ECC", Key:="TrackerFormelnExtrahieren", default:=-1)
  
  Set cfg = New CfgReader
  
  G_cfgKeypfad = ThisWorkbook.path
  G_cfgLogpfad = ThisWorkbook.path
  G_cfgTemppfad = ThisWorkbook.path
  G_cfgPasswortpfad = ThisWorkbook.path
  
'  ElseIf FileExists(ThisWorkbook.Path & "\..\swres.swk") Then
'    Open ThisWorkbook.Path & "\..\swres.swk" For Binary Access Read As #ff ' Len = 4
'  ElseIf FileExists(ThisWorkbook.Path & "\..\idv-suite\key\swres.swk") Then
'    Open ThisWorkbook.Path & "\..\idv-suite\key\swres.swk" For Binary Access Read As #ff ' Len = 4
  
  If FileExists(ThisWorkbook.path & "\ECC.cfg") = True Or FileExists(ThisWorkbook.path & "\..\cfg\IDV-Suite.cfg") = True Or FileExists(ThisWorkbook.path & "\..\..\cfg\IDV-Suite.cfg") = True Then

      If FileExists(ThisWorkbook.path & "\..\cfg\IDV-Suite.cfg") Then
        cfg.GetCfg (ThisWorkbook.path & "\..\cfg\IDV-Suite.cfg")
      ElseIf FileExists(ThisWorkbook.path & "\..\..\cfg\IDV-Suite.cfg") Then
        cfg.GetCfg (ThisWorkbook.path & "\..\..\cfg\IDV-Suite.cfg")
      ElseIf FileExists(ThisWorkbook.path & "\ECC.cfg") = True Then
        cfg.GetCfg (ThisWorkbook.path & "\ECC.cfg")
      End If
      
      If cfg.GetSection("GLOBALS") = True Then
          If InStr(UCase(cfg.GetValue("LOGWINDOWVISIBLEUSERS")), UCase(GetUserName())) > 0 Then
              ' G_LogToWindow = True
              ' frmLogWindow.Caption = ProgNameLong & " " & MyVersion & " - Log..."
              ' frmLogWindow.Show vbModeless
              G_LogEnabled = True
          End If
          
          Call InitTranslation(ThisWorkbook.path, "ECC", cfg)
      
      End If
      
      GetDBUser cfg

      If cfg.GetSection("DB") = True Then
        G_DBConnectionString = cfg.GetValue("CONNECTIONSTRING")
      End If
      
      If cfg.GetSection("ECC") = True Then
          s = cfg.GetValue("HELLOWORLD")
          If IsYes(s) Then
            'MsgBox "Hinweis: Der Excel-Sheet-Checker wurde gestartet. Sie k|fffd|nnen diesen Hinweis in der Datei IDV-Suite.cfg bzw. in der ECC.cfg deaktivieren. Stellen Sie dort bitte den Parameter HELLOWORLD auf Nein", vbInformation
            MsgBox FMT0("START_20"), vbInformation
          End If
          s = cfg.GetValue("LOG")
          If IsYes(s) Then
            G_LogEnabled = True
          ElseIf UCase(s) = "LAB" Then
            G_LogEnabled = True
            G_Break = True
          End If
          
          s = cfg.GetValue("NOMENU")
          If IsYes(s) Then
            G_NoMenu = True
          End If
          
          s = cfg.GetValue("CHKSUM_VBA")
          If IsNo(s) Then
            G_ChecksumVBA = False
            G_ChecksumFlags = G_ChecksumFlags Or 1
          End If
          G_ChecksumVBAOri = G_ChecksumVBA
          
          s = cfg.GetValue("CHKSUM_NAMES")
          If IsNo(s) Then
            G_ChecksumNames = False
            G_ChecksumFlags = G_ChecksumFlags Or 2
          End If
          G_ChecksumNamesOri = G_ChecksumNames

          s = cfg.GetValue("CHKSUM_PIVOT")
          If IsNo(s) Then
            G_ChecksumPivot = False
            G_ChecksumFlags = G_ChecksumFlags Or 4
          End If
          G_ChecksumPivotOri = G_ChecksumPivot

          s = cfg.GetValue("CHKSUM_QUERIES")
          If IsNo(s) Then
            G_ChecksumQueries = False
            G_ChecksumFlags = G_ChecksumFlags Or 8
          End If
          G_ChecksumQueriesOri = G_ChecksumQueries

          s = cfg.GetValue("CHKSUM_DIAGRAMS")
          If IsNo(s) Then
            G_ChecksumDiagrams = False
            G_ChecksumFlags = G_ChecksumFlags Or 16
          End If
          G_ChecksumDiagramsOri = G_ChecksumDiagrams

          s = cfg.GetValue("CHKSUM_CLONE")
          If IsNo(s) Then
            G_ChecksumClone = False
            G_ChecksumFlags = G_ChecksumFlags Or 32
          End If
          G_ChecksumCloneOri = G_ChecksumClone

          G_ChecksumFlagsOri = G_ChecksumFlags
          
          s = cfg.GetValue("TEILRISIKODECKELN")
          If IsNo(s) Then
            G_cfgTeilrisikoDeckeln = False
          End If
          
          
          s = cfg.GetValue("IGNOREHIGHESTPRIORITY")
          If IsYes(s) Then
            G_cfgIgnoreHighestPriority = True
          End If
          
          G_VerboseFileLogName = cfg.GetValue("VERBOSEFILELOG")

          If InStr(UCase(cfg.GetValue("FORCECRASH")), UCase(GetUserName())) > 0 Then
              Dim xa(1) As Byte, xb(1) As Byte
              ' ReDim b(10000)
              CopyMemory xb(0), xa(0), 10000
          End If

      End If
      
      If cfg.GetSection("GLOBALS") = True Then
          G_cfgKeypfad = GetRelativePath(G_cfgKeypfad, cfg.GetValue("KEYPFAD"))
          G_cfgLogpfad = GetRelativePath(G_cfgLogpfad, cfg.GetValue("LOGPFAD"))
          G_cfgTemppfad = GetRelativePath(G_cfgTemppfad, cfg.GetValue("TEMPPFAD"))
          G_cfgPasswortpfad = GetRelativePath(G_cfgPasswortpfad, cfg.GetValue("PASSWORTPFAD"))
          
          s = cfg.GetValue("CURSORLOCATION")
          If UCase(s) = "SERVER" Then
            G_Cursorlocation = 2 ' ADODB.adUseServer
          Else
            G_Cursorlocation = 3 ' ADODB.adUseClient
          End If
          
          If IsNo(cfg.GetValue("MODULMEN|fffd|")) Then
            G_ModulmenueDeaktivieren = True
          End If
      
          s = cfg.GetValue("PWCHECKLIMMB")
          If IsNumeric(s) Then
            G_cfgPwCheckLimMB = Val(s)
          End If
      End If
      
      If cfg.GetSection("DBCONNECTEXT") = True Then
        Dim connnectCount As Long
        Dim drv As String
        For connnectCount = 1 To 10
          drv = cfg.GetValue("DRIVER" & connnectCount)
          If drv <> "" Then
            If FileExists(drv) Then
              G_DBConnectionString = cfg.GetValue("CONNECTIONSTRING" & connnectCount)
              Exit For
            End If
          End If
        Next connnectCount
      End If
      
      If AR_UseDB Then
        If cfg.GetSection("IDV-Suite Scheduler") = True Then
            If cfg.GetValue("KEYPFAD") <> "" Then
              G_cfgKeypfad = GetRelativePath(G_cfgKeypfad, cfg.GetValue("KEYPFAD"))
            End If
            If cfg.GetValue("LOGPFAD") <> "" Then
              G_cfgLogpfad = GetRelativePath(G_cfgLogpfad, cfg.GetValue("LOGPFAD"))
            End If
            If cfg.GetValue("TEMPPFAD") <> "" Then
              G_cfgTemppfad = GetRelativePath(G_cfgTemppfad, cfg.GetValue("TEMPPFAD"))
            End If
            If cfg.GetValue("PASSWORTPFAD") <> "" Then
              G_cfgPasswortpfad = GetRelativePath(G_cfgPasswortpfad, cfg.GetValue("PASSWORTPFAD"))
            End If
        End If
      End If
  Else
    Call InitTranslation(ThisWorkbook.path, "ECC", cfg)
      
  End If
  
  ClearLog
  
  LogPrint "ECC Start"

  DebugPrint tinfo, "Keypfad: " & G_cfgKeypfad
  DebugPrint tinfo, "Logpfad: " & G_cfgLogpfad
  DebugPrint tinfo, "Temppfad: " & G_cfgTemppfad
  DebugPrint tinfo, "Passwortpfad: " & G_cfgPasswortpfad
  
  DelTree G_cfgTemppfad & "\" & GetUserName & ".tmp"

  LogPrint "Programmteilpr|fffd|fung"
  Dim tmpfname As String
  tmpfname = ThisWorkbook.path & "\ECC-Einzelanalyse.xltx"
  If Not FileExists(tmpfname) Then
    'MsgBox "Die Datei '" & tmpfname & "' existiert nicht, der Excel-Sheet-Checker kann nicht ausgef|fffd|hrt werden!"
    MsgBox FMT1("START_21", tmpfname)
    Exit Sub
  End If
  tmpfname = ThisWorkbook.path & "\ECC-Massenanalyse.xltx"
  If Not FileExists(tmpfname) Then
    'MsgBox "Die Datei '" & tmpfname & "' existiert nicht, der Excel-Sheet-Checker kann nicht ausgef|fffd|hrt werden!"
    MsgBox FMT1("START_21", tmpfname)
    Exit Sub
  End If
  tmpfname = ThisWorkbook.path & "\Excel-Sheet-Checker Risk.xls"
  If Not FileExists(tmpfname) Then
    'MsgBox "Die Datei '" & tmpfname & "' existiert nicht, der Excel-Sheet-Checker kann nicht ausgef|fffd|hrt werden!"
    MsgBox FMT1("START_21", tmpfname)
    Exit Sub
  End If
  tmpfname = ThisWorkbook.path & "\EccFuncs.xls"
  If Not FileExists(tmpfname) Then
    'MsgBox "Die Datei '" & tmpfname & "' existiert nicht, der Excel-Sheet-Checker kann nicht ausgef|fffd|hrt werden!"
    MsgBox FMT1("START_21", tmpfname)
    Exit Sub
  End If
  tmpfname = ThisWorkbook.path & "\ECCDaemon.exe"
  If Not FileExists(tmpfname) Then
    'MsgBox "Die Datei '" & tmpfname & "' existiert nicht, der Excel-Sheet-Checker kann nicht ausgef|fffd|hrt werden!"
    MsgBox FMT1("START_21", tmpfname)
    Exit Sub
  End If
  
  LogPrint "Caption setzen"
  'Application.Caption = "Excel-Sheet-Checker"
  Application.Caption = ProgNameLong
  
  theTrackerShowStatusform = True
    
  G_MyLicencseVersion = 0
  G_UpdateAvailable = False
  
  FullVersion = True
  LogPrint "GetData"
  GetData
  LogPrint "CheckLicense"
  CheckLicense
      
  LogPrint "CheckVersion"
  
  DebugPrint tinfo, "AR_UseDB: " & IIf(AR_UseDB, "True", False)
  
  LogPrint "Label"
  If Len(trs) Then MainMenu.Label1 = trs
  
'  LogPrint "Language"
'  GSprache = GetSetting( _
'    AppName:="Stromwerken", _
'    Section:=progNameShort, _
'    Key:="Sprache", default:=0)
'
'  If GSprache = 0 Then
''    If trsLngSelect = "Ja" Or FullVersion = True Then
''      Sprache.MyInit
''      Sprache.Show
''      If GSprache = 0 Then GSprache = 2
''      SaveSetting _
''         appName:="Stromwerken", _
''         section:=progNameShort, _
''         key:="Sprache", _
''         Setting:=GSprache
''    Else
'      GSprache = 1
'      SaveSetting _
'         AppName:="Stromwerken", _
'         Section:=progNameShort, _
'         Key:="Sprache", _
'         Setting:=GSprache
''    End If
'  End If
  
'  LogPrint "TexteInit"
  TexteInit
  
    gCHR = ""
    gCursorLocation = 2
    If FileExists(ThisWorkbook.path & "\" & "oracle.cfg") = True Then
        gCHR = """"
        gCursorLocation = 3
    End If
  
  
  Beenden = False
  LogPrint "InitPhase Finished"

End Sub

Sub Auto_Close()
    On Error Resume Next
    If G_ModulmenueDeaktivieren Then
      Application.CommandBars("Worksheet Menu Bar").Controls(progNameShort).Delete
    End If
End Sub



Public Sub ExcelSheetCheckShowMainMenuFromMenu()
  InitApp
  ExcelSheetCheckShowMainMenu
End Sub

Public Sub ExcelSheetCheckShowMainMenu()
  
'  CheckVersion 0, progNameShort, progNameShort & "\SWUpdate" & progNameShort & ".txt", MyInternalVersion
    
  G_MyLicencseVersion = 0
  
  FullVersion = True
  LogPrint "GetData 2"
  GetData
  
  If G_Lizenzen = 0 And Now > G_FullDemoBis Then
    FullVersion = False
  End If
    
  LogPrint "Wartungscheck"
  If G_Wartung = True And Now > G_WartungBis Then
    If G_WartungBis < MyProgramReleaseDate = True And G_MyLicencseVersion < MyProgramLicenseVersion Then
      FullVersion = False
    End If
  Else
    If G_MyLicencseVersion < MyProgramLicenseVersion And FullVersion = True Then
      FullVersion = False
    End If
  End If
      
  If AR_UseDB Then
    FullVersion = True
  End If
      
  If Len(trs) Then MainMenu.Label1 = trs
  
  
  LogPrint "Version"
'  MainMenu.CVersion = MyVersion & " vom " & MyProgramReleaseDate & vbCrLf & IIf(MyInternalVersion <> G_InternetInternalVersion, IIf(G_InternetVersion <> "", "Internet: " & G_InternetVersion & vbCrLf, ""), "") & _
'      IIf(G_InternetAvailable, _
'            IIf(FullVersion = False, _
'                  "Demoversion", _
'                  IIf(MyInternalVersion < G_InternetInternalVersion, _
'                          IIf(G_MyLicencseVersion >= G_InternetLicenseVersion, "Kostenfreies Update", "Kostenpflichtiges Update"), _
'                          "" _
'                  ) _
'            ), _
'            "" _
'      )
  MainMenu.CVersion = FMT3("START_22", MyVersion & "." & MyECCVersion, MyProgramReleaseDate, IIf(MyInternalVersion <> G_InternetInternalVersion, IIf(G_InternetVersion <> "", FMT0("START_23") & G_InternetVersion & vbCrLf, ""), "") & _
      IIf(G_InternetAvailable, _
            IIf(FullVersion = False, _
                  FMT0("START_24"), _
                  IIf(MyInternalVersion < G_InternetInternalVersion, _
                          IIf(G_MyLicencseVersion >= G_InternetLicenseVersion, FMT0("START_25"), FMT0("START_26")), _
                          "" _
                  ) _
            ), _
            "" _
      ))
  
  If G_UpdateAvailable And MyInternalVersion < G_InternetInternalVersion Then MainMenu.cmdUpdate.Visible = True
  
'  LogPrint "Sprache 2"
'  GSprache = GetSetting( _
'    AppName:="Stromwerken", _
'    Section:=progNameShort, _
'    Key:="Sprache", default:=0)
'
'
'  GSprache = 1
    
'  If GSprache = 0 Then
'    If trsLngSelect = "Ja" Or FullVersion = True Then
'      Sprache.MyInit
'      Sprache.Show
'      If GSprache = 0 Then GSprache = 2
'      SaveSetting _
'         appName:="Stromwerken", _
'         section:=progNameShort, _
'         key:="Sprache", _
'         Setting:=GSprache
'    Else
'      GSprache = 1
'      SaveSetting _
'         appName:="Stromwerken", _
'         section:=progNameShort, _
'         key:="Sprache", _
'         Setting:=GSprache
'    End If
'  End If
  
'  LogPrint "TexteInit 2"
  TexteInit
  
'  If trsLngSelect = "Ja" Then
'    MainMenu.cmdSprache.Visible = True
'  End If

'  If Not FullVersion Then
'    MainMenu.cmdSprache.Visible = True
'  End If
  
  LogPrint "VBA-Check"
  If Not CheckVBAAccessAllowed Then
      If AR_UseDB = False And StartedByDaemon = False Then
        'MsgBox Texte(GSprache, TXT_EXCEL2000), vbInformation, "Excel-Sheet-Checker"
        MsgBox FMT1("START_7", ProgNameLong), vbInformation, ProgNameLong
      End If
  End If
    
  MainMenu.Headline = ProgNameLong
  MainMenu.Cop = "|fffd|2001 - " & year(Now)
  LogPrint "MainMenu.Show"
  MainMenu.Show
End Sub

Sub ExcelSheetCheckRemoveMenu()
    On Error Resume Next
    InitApp
    'If MsgBox(Texte(GSprache, TXT_ECCENTFERNEN), vbYesNo, "Excel-Sheet-Checker") = vbYes Then
    If MsgBox(FMT0("TXT_ECCENTFERNEN"), vbYesNo, ProgNameLong) = vbYes Then
        Application.CommandBars("Worksheet Menu Bar").Controls("ECC").Delete
        Application.CommandBars("Worksheet Menu Bar").Controls("SSC").Delete
        ThisWorkbook.Close
    End If
End Sub

Function OpenRS(ByVal sqlstring As String, ByRef conn As Object, ByVal cursorytype As Long, ByVal locktype As Long) As Object
        Dim rs As Object
        Set rs = CreateObject("ADODB.Recordset")
        On Error Resume Next

        Set OpenRS = Nothing
        Dim cnt As Long
        cnt = 0
checkAgain:
        rs.Open sqlstring, conn, cursorytype, locktype
        If Err.Number <> 0 Then
            Debug.Print Err.Description
            Err.Clear
            Sleep 50
            cnt = cnt + 1
            If cnt >= 100 Then
                rs = Nothing
                Exit Function
            End If
            GoTo checkAgain
        End If

        Set OpenRS = rs
End Function


Function ShowBar() As Boolean
  On Error GoTo barMissing
  Application.CommandBars("ECCZellenFinden").Visible = True
  ShowBar = True
  Exit Function

barMissing:
  ShowBar = False
End Function

Sub ECCShowDoku()
  OpenFileWithApp ThisWorkbook.path & "\Excel-Sheet-Checker.pdf"
End Sub

Sub ECCShowBar()
    On Error GoTo ignore
    
    If ShowBar Then Exit Sub
    
    Dim myBar As CommandBar
    Set myBar = Application.CommandBars.Add(name:="ECCZellenFinden", Position:=msoBarFloating, Temporary:=True)
    ' Und die Buttons hinzuf|fffd|gen
    Dim myControl
    Set myControl = myBar.Controls.Add(Type:=msoControlButton)
    ' Speicherbutton mit Grafik
    With myControl
        .FaceId = 141
        '.Caption = "Erste Zelle finden"
        .Caption = FMT0("START_27")
        .OnAction = "ECCFinden"  ' Funktion, die Aufgerufen werden soll, siehe Modul1
        .Style = msoButtonIconAndCaption
    End With
    
    Set myControl = myBar.Controls.Add(Type:=msoControlButton)
    ' Speicherbutton mit Grafik
    With myControl
        .FaceId = 570
        '.Caption = "Weitere finden"
        .Caption = FMT0("START_28")
        .OnAction = "ECCWFinden"  ' Funktion, die Aufgerufen werden soll, siehe Modul1
        .Style = msoButtonIconAndCaption
    End With
    
'    Set myControl = myBar.Controls.Add(Type:=msoControlButton)
    ' Speicherbutton mit Grafik
'    With myControl
'        .FaceId = 570
'        .Caption = "Text in Formeln"
'        .OnAction = "ECCTextInFormelnSuchen"  ' Funktion, die Aufgerufen werden soll, siehe Modul1
'        .Style = msoButtonIconAndCaption
'    End With
    
    
    ' Mich einschalten und den Schutz an
    With myBar
        .Visible = True
'        .Protection = 31 ' Mich kann man auch nicht zumachen :)
    End With
ignore:
End Sub

Sub CheckLicense()
  If G_Lizenzen = 0 And Now > G_FullDemoBis And AR_UseDB = False Then
    'MsgBox "Die Full-Demo f|fffd|r dieses Programm ist abgelaufen. Wenden Sie sich bitte an info@stromwerken.de. Das Programm wird jetzt als Demoversion ausgef|fffd|hrt.", vbCritical, "Excel-Sheet-Checker"
    MsgBox FMT0("START_29"), vbCritical, ProgNameLong
    FullVersion = False
  ElseIf G_Lizenzen > 0 And Now > G_FullDemoBis And G_FullDemoBis <> 0 And AR_UseDB = False Then
    'MsgBox "Die Lizenz f|fffd|r das Programm ist abgelaufen, wenn Sie das Programm weiter als Vollversion nutzen m|fffd|chten, k|fffd|nnen Sie eine Lizenz per formloser Mail |fffd|ber info@stromwerken.de bestellen. Das Programm wird jetzt als Demoversion ausgef|fffd|hrt.", vbCritical, "Excel-Sheet-Checker"
    MsgBox FMT0("START_30"), vbCritical, ProgNameLong
    FullVersion = False
  End If
    
  If G_Wartung = True And Now > G_WartungBis Then
    If G_WartungBis < MyProgramReleaseDate = True And G_MyLicencseVersion < MyProgramLicenseVersion Then
      'MsgBox "Ihr Wartungsvertrag umfasst diese Programmversion nicht mehr. Um diese Version nutzen zu k|fffd|nnen, ben|fffd|tigen Sie einen neuen Lizenzkey, wenden Sie sich hierzu bitte an info@stromwerken.de. Das Programm wird jetzt als Demoversion ausgef|fffd|hrt.", vbCritical, "Excel-Sheet-Checker"
      MsgBox FMT0("START_31"), vbCritical, ProgNameLong
      FullVersion = False
    End If
  Else
    If G_MyLicencseVersion < MyProgramLicenseVersion And FullVersion = True Then
      'MsgBox "Ihr Lizenzkey f|fffd|r dieses Programm ist veraltet. Um diese Version nutzen zu k|fffd|nnen, ben|fffd|tigen Sie einen neuen Lizenzkey, wenden Sie sich hierzu bitte an info@stromwerken.de. Das Programm wird jetzt als Demoversion ausgef|fffd|hrt.", vbCritical, "Excel-Sheet-Checker"
      MsgBox FMT0("START_32"), vbCritical, ProgNameLong
      FullVersion = False
    End If
  End If
End Sub

Attribute VB_Name = "StatusForm"
Attribute VB_Base = "0{5C60978A-9450-4BD7-9A10-31297D8EE8EF}{D84A5507-76EE-4763-9742-2B13D4B5A086}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Sub cmdAbbrechen_Click()
  'cmdAbbrechen.Caption = "Bitte warten..."
  cmdAbbrechen.Caption = FMT0("STATUS_3")
  DoEvents
  Beenden = True
End Sub

Private Sub UserForm_Initialize()
  gTranslation.TranslateForm Me
End Sub
Attribute VB_Name = "Tabelle1"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Control = "CommandButton1, 1, 0, MSForms, CommandButton"
Private Sub CommandButton1_Click()
  Auto_Open
End Sub
Attribute VB_Name = "Tabelle2"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Tabelle3"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Translation"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

#If VBA6 Or VBA7 Then
    Const IS_VBA = True
#Else
    Const IS_VBA = False
#End If

' ------------------------------------------------------------------
Private Const NoError = 0       'The Function call was successful

Private Const LOCALE_USER_DEFAULT = &H400
Private Const LOCALE_SISO639LANGNAME = &H59
Private Const LOCALE_SISO3166CTRYNAME = &H5A

#If VBA7 Then
    Private Declare PtrSafe Function WNetGetUser Lib "mpr.dll" _
          Alias "WNetGetUserA" (ByVal lpName As String, _
          ByVal lpUserName As String, lpnLength As Long) As Long
          
    ' Caution:  If the user default locale is a custom locale, an application cannot accurately tag data
    ' with the value or exchange it. In this case, the application should use GetUserDefaultLocaleName
    ' (available starting with Windows Vista) in preference to GetUserDefaultLCID.
    Private Declare PtrSafe Function GetUserDefaultLCID Lib "kernel32" () As Long
    
    ' List of Language Identifier Constants and Strings:
    ' https://msdn.microsoft.com/library/dd318693.aspx
    Private Declare PtrSafe Function GetLocaleInfo Lib "kernel32" Alias "GetLocaleInfoA" ( _
        ByVal Locale As Long, _
        ByVal LCType As Long, _
        ByVal lpLCData As String, _
        ByVal cchData As Long) As Long

    ' Available since Vista
    'GetUserDefaultUILanguage
    
#Else
    Private Declare Function WNetGetUser Lib "mpr.dll" _
          Alias "WNetGetUserA" (ByVal lpName As String, _
          ByVal lpUserName As String, lpnLength As Long) As Long
    
    Private Declare Function GetUserDefaultLCID Lib "kernel32" () As Long
    
    Private Declare Function GetLocaleInfo Lib "kernel32" Alias "GetLocaleInfoA" ( _
        ByVal Locale As Long, _
        ByVal LCType As Long, _
        ByVal lpLCData As String, _
        ByVal cchData As Long) As Long
    
#End If

' ------------------------------------------------------------------


' 0 = default string table, 1 = user indiv string table
Private mStringTables(2) As Collection
Private mLangIDs(2) As String
Private mCurrentUser As String

Public Property Get CurrentUser() As String
    CurrentUser = mCurrentUser
End Property


Private Sub Class_Initialize()
    mCurrentUser = GetTranslationUserName
End Sub

Public Function StartupInit(installRoot As String, app As String, Optional overrideLang As String = "") As Boolean
    On Error GoTo nogo
    ' User Language ermitteln (xy-uv)
    Dim lang As String
    If overrideLang <> "" Then
        lang = overrideLang
    Else
        'lang = GetUserLanguage
        ' Direkt das nehmen was Windows reportet
        lang = GetWindowsLanguageString
    End If
    
    Dim path As String
    Dim paths(1) As String
    Dim userPaths(1) As String
    
    Dim tries As Long
    For tries = 0 To 1
    
      paths(0) = installRoot & "\Translate\" & app & "_" & lang & ".txt"
      userPaths(0) = installRoot & "\Translate\" & app & "_" & lang & "_indiv.txt"
      
      paths(1) = installRoot & "\..\Translate\" & app & "_" & lang & ".txt"
      userPaths(1) = installRoot & "\..\Translate\" & app & "_" & lang & "_indiv.txt"
      
      Dim i As Long
      For i = 0 To UBound(paths)
          If Init(0, paths(i), lang) = True Then
              ' Und auch versuchen die user strings zu laden (falls es die gibt)
              Init 1, userPaths(i), lang
              StartupInit = True
              Exit Function
          End If
      Next i
      
      ' Nix gefunden -> Fallback language setzen
      lang = GetFallbackLanguage(lang)
    
    Next tries
    
nogo:
    StartupInit = False
End Function

Public Function Init(index As Long, path As String, langId As String) As Boolean
    Init = False
    If index >= UBound(mLangIDs) Then
        Exit Function
    End If
    
    mLangIDs(index) = UCase(langId)
    Dim c As Collection
    Set c = LoadStringTable(path)
    If c Is Nothing Then
        Exit Function
    End If
    Set mStringTables(index) = c
    Init = True
End Function

Public Sub Clear()
    Set mStringTables(0) = New Collection
    Set mStringTables(1) = New Collection
End Sub

Public Function GetLocalizedFile(path As String) As String
    Dim lang As String
    If UBound(mLangIDs) > 0 Then
        If mLangIDs(0) <> "" Then
            lang = mLangIDs(0)
        End If
    End If
    If lang = "" Then
        lang = GetWindowsLanguageString
    End If
    
    GetLocalizedFile = LocalizedFileExists(path, lang)
End Function

' Splitted path\filename.ext aus path
' Und sucht dann nach
' path\filename_lang.ext
' Wenn nix gefunden, wird lang mit einem fallback replaced.
' de-de fuer alles was de-xy
' en-gb fuer alles andere
' Oder halt den original path wenn es nichts davon gibt.
' Der gefundene pfad wird returned oder "" wenn es gar nix gibt.
Public Function LocalizedFileExists(path As String, lang As String) As String
    On Error GoTo nogo
    
    LocalizedFileExists = path
    Dim newPath As String
    
    If lang <> "" Then
        ' Direkt nach der uebergebenen Sprache in lang suchen
        newPath = InternalLocalizedFileExists(path, lang)
        If newPath <> "" Then
            LocalizedFileExists = newPath
            Exit Function
        End If
        
        ' Nix gefunden -> fallback Sprache nehmen
        If Len(lang) > 2 Then
            ' Wenn es was deutsches ist, dann nach de-de suchen
            If UCase(lang) <> "DE-DEB" And InStr(UCase(lang), "DE") > 0 Then
                newPath = InternalLocalizedFileExists(path, "de-de")
                If newPath <> "" Then
                    LocalizedFileExists = newPath
                    Exit Function
                End If
            End If
        End If
        
        ' Bis hier hin nix gefunden -> nach "en-gb" suchen
        If UCase(lang) <> "DE-DE" Then
            newPath = InternalLocalizedFileExists(path, "en-gb")
            If newPath <> "" Then
                LocalizedFileExists = newPath
                Exit Function
            End If
        End If
    End If
    
nogo:
    If Not FileExists(LocalizedFileExists) Then
        LocalizedFileExists = ""
    End If
End Function

Private Function InternalLocalizedFileExists(path As String, lang As String) As String
    On Error GoTo nogo
    
    Dim newPath As String
    Dim p As String
    Dim Filename As String
    Dim ext As String
    fileSplit path, p, Filename, ext

    newPath = FmtInternal("%1%2_%3.%4", p, Filename, lang, ext)
    If newPath <> "" And FileExists(newPath) Then
        InternalLocalizedFileExists = newPath
        Exit Function
    End If
nogo:
End Function

Public Sub AddString(tableIdx As Long, id As String, s As String)
    mStringTables(tableIdx).Add s, id
End Sub

Public Function StringExists(id As String) As Boolean
    If id = "" Then
        StringExists = True
        Exit Function
    End If
    On Error GoTo nogo
    Dim s As String
    s = mStringTables(0).item(UCase(id))
    StringExists = True
    Exit Function
nogo:
    StringExists = False
End Function

Public Function GetString(id As String) As String
    On Error GoTo nogo
    If id = "" Then
        Exit Function
    End If
    
    If mStringTables(1) Is Nothing Then
        GetString = GetFallbackString(id)
        Exit Function
    End If
    GetString = mStringTables(1).item(UCase(id))
    Exit Function
nogo:
    GetString = GetFallbackString(id)
End Function

Public Function GetSafeString(id As String, defaultVal As String) As String
  If StringExists(id) Then
    GetSafeString = GetString(id)
    Exit Function
  End If
  GetSafeString = defaultVal
End Function

Public Function GetFallbackString(id As String) As String
    On Error GoTo nogo
    If mStringTables(0) Is Nothing Then
        GetFallbackString = id & ": ***MISSING***"
        Exit Function
    End If
    
    GetFallbackString = mStringTables(0).item(UCase(id))
    Exit Function
nogo:
    GetFallbackString = id & ": ***MISSING***"
End Function

Public Function FormatString(FMT As String, _
                             Optional arg1 As String = vbNullChar, _
                             Optional arg2 As String = vbNullChar, _
                             Optional arg3 As String = vbNullChar, _
                             Optional arg4 As String = vbNullChar, _
                             Optional arg5 As String = vbNullChar, _
                             Optional arg6 As String = vbNullChar, _
                             Optional arg7 As String = vbNullChar, _
                             Optional arg8 As String = vbNullChar, _
                             Optional arg9 As String = vbNullChar _
                             ) As String
                             
    On Error GoTo nogo
    
    Dim argarray(8) As String
    If IsTestUser Then
        argarray(0) = arg1
        argarray(1) = arg2
        argarray(2) = arg3
        argarray(3) = arg4
        argarray(4) = arg5
        argarray(5) = arg6
        argarray(6) = arg7
        argarray(7) = arg8
        argarray(8) = arg9
        
        Dim i As Long
        ' Erstmal checken ob wir fuer jeden Placeholder einen Parameter uebergeben bekommen haben
        ' Hier koennte man auch IsMissing nehmen - aber dann muessen alle args vom Type Variant sein.
        For i = 1 To 9
            If InStr(FMT, "%" & i) > 0 Then
                If argarray(i - 1) = vbNullChar Then
                    MsgBox FMT & vbCrLf & vbCrLf & "ERROR in FormatString: No arg for %" & i, vbCritical
                    Exit Function
                End If
            End If
        Next i
    Else
        argarray(0) = IIf(arg1 = vbNullChar, "", arg1)
        argarray(1) = IIf(arg2 = vbNullChar, "", arg2)
        argarray(2) = IIf(arg3 = vbNullChar, "", arg3)
        argarray(3) = IIf(arg4 = vbNullChar, "", arg4)
        argarray(4) = IIf(arg5 = vbNullChar, "", arg5)
        argarray(5) = IIf(arg6 = vbNullChar, "", arg6)
        argarray(6) = IIf(arg7 = vbNullChar, "", arg7)
        argarray(7) = IIf(arg8 = vbNullChar, "", arg8)
        argarray(8) = IIf(arg9 = vbNullChar, "", arg9)
    End If
    
    Dim r As String
    r = FMT
    
    r = Replace(r, "%%", "%")
    r = Replace(r, "\n", vbCrLf)
    r = Replace(r, "\t", vbTab)
    
    For i = 1 To 9
        If Not argarray(i - 1) = vbNullChar Then
            r = Replace(r, "%" & i, argarray(i - 1))
        End If
    Next i
    
    FormatString = r
    Exit Function

nogo:
    FormatString = "ERROR " & FMT
End Function

#If TEST_BUILD = 1 Then
#Else
#End If

'Public Function FormatString(fmt As String, _
'                             Optional arg1 As String, _
'                             Optional arg2 As String, _
'                             Optional arg3 As String, _
'                             Optional arg4 As String, _
'                             Optional arg5 As String, _
'                             Optional arg6 As String, _
'                             Optional arg7 As String, _
'                             Optional arg8 As String, _
'                             Optional arg9 As String _
'                             ) As String
'    On Error GoTo nogo
'
'    Dim argarray(8) As String
'    argarray(0) = arg1
'    argarray(1) = arg2
'    argarray(2) = arg3
'    argarray(3) = arg4
'    argarray(4) = arg5
'    argarray(5) = arg6
'    argarray(6) = arg7
'    argarray(7) = arg8
'    argarray(8) = arg9
'    Dim i As Long
'    Dim r As String
'    r = fmt
'    For i = 1 To 9
'        r = Replace(r, "%" & i, argarray(i - 1))
'    Next i
'    r = Replace(r, "%%", "%")
'    r = Replace(r, "\n", vbCrLf)
'    r = Replace(r, "\t", vbTab)
'
'    FormatString = r
'    Exit Function
'
'nogo:
'    FormatString = "ERROR " & fmt
'End Function

Private Function GetTranslationTags(controlTag As String) As String()
    Dim tags() As String
    ' Argh.  Die Split Funktion in VBA gibt ein Element zurueck bei Split("test", ",")
    ' In VB6 aber nicht.
    ' Dann haben wir eine eigene implementierung fuer Split in MailSenden.bas. Die ist wie die VB6 version
    ' Also immer stur ein ',' dranhaengen
    tags = Split(controlTag & ",", ",")
    
    Dim invalidTags() As String
    invalidTags = Split("FIXLEFT,FIXTOP,NORESIZE", ",")
    
    Dim result As String
    
    Dim t As Variant
    For Each t In tags
        t = Trim(t)
        If t <> "" And Not IsOneOf(UCase(t), invalidTags) Then
            If Len(result) > 0 Then
                result = result & "," & t
            Else
                result = t
            End If
        End If
    Next t
    GetTranslationTags = Split(result & ",", ",")
End Function

Private Function IsOneOf(s As String, arr() As String) As Boolean
    IsOneOf = False
    If Len(s) = 0 Then
        Exit Function
    End If
    
    Dim e As Variant
    For Each e In arr
        If s = e Then
            IsOneOf = True
            Exit Function
        End If
    Next e
End Function

Private Sub TranslateControl(ctl As Object)
    On Error GoTo nogo
    Dim tag As String
    tag = ctl.tag
    If tag <> "" Then
        Dim tags() As String
        tags = GetTranslationTags(tag)
    
        ' Caption
        Dim s As String
        s = FMT0(tags(0))
        If s <> "" Then
#If IS_VBA Then
            If TypeOf ctl Is MSForms.TextBox Then
#Else
            If TypeOf ctl Is TextBox Then
#End If
                ctl.Text = s
            'ElseIf TypeOf ctl Is MSForms.UserForm Then
            Else
                ctl.Caption = s
            End If
        End If
        
        ' ControlTipText
        If UBound(tags) > 0 Then
            s = FMT0(tags(1))
            If s <> "" Then
#If IS_VBA Then
                If TypeOf ctl Is MSForms.MultiPage Then
                    ' MultiPage hat keinen tooltip
                Else
                    ctl.ControlTipText = s
                End If
#Else
                ctl.TooltipText = s
#End If
            End If
        End If
    End If

    Exit Sub
nogo:
    Debug.Print Err.Description
End Sub

Public Sub TranslateForm(frm As Object)
    TranslateControl frm
    
    
    Dim ctl As Object
    For Each ctl In frm.Controls
        
        'If ctl.ControlType = acTextBox Then
#If IS_VBA Then
        If TypeOf ctl Is MSForms.MultiPage Then
#Else
        If False Then
#End If
            TranslateControl ctl
            Dim page As Object
            For Each page In ctl.Pages
                TranslateControl page
            Next page
#If IS_VBA Then
        ElseIf TypeOf ctl Is MSForms.Frame Then
            TranslateForm ctl
#Else
        'ElseIf TypeOf ctl Is Frame Then
#End If
        Else
            TranslateControl ctl
        'ElseIf ctl.ControlType = acSubform Then
        '    TranslateForm frm(ctl.name).Form
        End If
    Next ctl
    
End Sub

' Die Sprache die der user in Windows eingestellt hat
' Rueckgabewert: Eine unserer supporteten languages
Public Function GetUserLanguage() As String
    Dim lcid As Long
    lcid = GetUserDefaultLCID()
    GetUserLanguage = MapLCIDToInternalLanguage(lcid)
End Function

' Die Sprache des installierten Ms Office
' Rueckgabewert: Eine unserer supporteten languages
Public Function GetMsOfficeLanguage() As String
    Dim lcid As Long
    lcid = Application.LanguageSettings.LanguageID(msoLanguageIDUI)
    GetMsOfficeLanguage = MapLCIDToInternalLanguage(lcid)
End Function



' -------------------------------------------------------------------
'
' -------------------------------------------------------------------

Function LoadStringTable(path As String) As Collection
    On Error GoTo nogo
    Set LoadStringTable = Nothing
    
    Const ForReading = 1
    Const TristateUseDefault = -2, TristateTrue = -1, TristateFalse = 0
    
    Dim fs, f, ts
    Set ts = Nothing
    Set fs = CreateObject("Scripting.FileSystemObject")
    Set ts = fs.OpenTextFile(path, ForReading, False, TristateTrue)
    
    'Dim sheet As Worksheet
    'Set sheet = ThisWorkbook.Sheets("Test")
    'Dim y As Long
    'y = 1
    
    Dim c As New Collection
    Dim s As String
    Do While ts.AtEndOfStream <> True
        ' This really is a Unicode string, although the debugger and MsgBox show ??
        s = ts.ReadLine
        'sheet.Cells(y, 1) = s
        'y = y + 1
        If ExtractString(s, c) Then
        End If
    Loop
    Set LoadStringTable = c
nogo:
    If Not ts Is Nothing Then
        ts.Close
        Set ts = Nothing
    End If
    If Not fs Is Nothing Then
        Set fs = Nothing
    End If
End Function

Function ExtractString(line As String, c As Collection) As Boolean
    On Error GoTo nogo
    
    ExtractString = False
    If line = "" Then
        Exit Function
    End If
    If Left(line, 1) = "'" Then
        Exit Function
    End If
    
    Dim startp As Long
    Dim endp As Long
    Dim ofs As Long
    If Left(line, 1) = """" Then
        ' id ist alles zwischen den ""
        startp = 2
        endp = InStr(2, line, """")
        ofs = 2
    Else
        startp = 1
        endp = InStr(line, " ")
        ofs = 1
    End If
    
    If startp <= 0 Or endp <= 0 Then
        Exit Function
    End If
    
    Dim id As String
    Dim value As String
    id = Mid(line, startp, endp - startp)
    'value = Mid(line, endp + 1, Len(line) - endp)
    value = Mid(line, endp + ofs)
    If Not CollectionStringExists(c, id) Then
        c.Add value, id
    End If
    
    ExtractString = True
    Exit Function
nogo:
    MsgBox Err.Description
End Function

Private Function IsTestUser() As Boolean
    If mCurrentUser = "dirk" Or _
        mCurrentUser = "dwinter" Or _
        mCurrentUser = "norman" Or _
        mCurrentUser = "nneubert" Or _
        mCurrentUser = "rolf" Or _
        mCurrentUser = "rlangenberg" Then
        
        IsTestUser = True
    End If
End Function

Private Function GetTranslationUserName() As String
   ' Buffer size for the return string.
   Const lpnLength As Integer = 255

   ' Get return buffer space.
   Dim status As Integer

   ' For getting user information.
   Dim lpName, lpUserName As String

   ' Assign the buffer size constant to lpUserName.
   lpUserName = Space$(lpnLength + 1)

   ' Get the log-on name of the person using product.
   status = WNetGetUser(lpName, lpUserName, lpnLength)

   ' See whether error occurred.
   If status = NoError Then
      ' This line removes the null character. Strings in C are null-
      ' terminated. Strings in Visual Basic are not null-terminated.
      ' The null character must be removed from the C strings to be used
      ' cleanly in Visual Basic.
      lpUserName = Left$(lpUserName, InStr(lpUserName, Chr(0)) - 1)
   Else
      lpUserName = "Unbekannt"
   End If

    GetTranslationUserName = lpUserName
End Function

Private Function CollectionStringExists(c As Collection, name As String) As Boolean
  On Error GoTo notReadable
  Dim s As String
  s = c(name)
  CollectionStringExists = True
  Exit Function
  
notReadable:
  CollectionStringExists = False
End Function

Private Function LCIDToLanguageCode(lcid As Long) As String

    ' Locale IDs
    ' https://msdn.microsoft.com/en-us/goglobal/bb964664
    'Arabic (Saudi Arabia)                1025
    'Arabic (Iraq)                        2049
    'Arabic (Egypt)                       3073
    'Arabic (Libya)                       4097
    'Arabic (Algeria)                     5121
    'Arabic (Morocco)                     6145
    'Arabic (Tunisia)                     7169
    'Arabic (Oman)                        8193
    'Arabic (Yemen)                       9217
    'Arabic (Syria)                      10241
    'Arabic (Jordan)                     11265
    'Arabic (Lebanon)                    12289
    'Arabic (Kuwait)                     13313
    'Arabic (U.A.E.)                     14337
    'Arabic (Bahrain)                    15361
    'Arabic (Qatar)                      16385
    'Bulgarian                            1026
    'Catalan                              1027
    'Chinese (Taiwan)                     1028
    'Chinese (PRC)                        2052
    'Chinese (Hong Kong SAR               3076
    'Chinese (Singapore)                  4100
    'Czech                                1029
    'Danish                               1030
    'German (Germany)                     1031
    'German (Swiss)                       2055
    'German (Austrian)                    3079
    'German (Luxembourg)                  4103
    'German (Liechtenstein)               5127
    'Greek                                1032
    'English (United States)              1033
    'English (United Kingdom)             2057
    'English (Australian)                 3081
    'English (Canadian)                   4105
    'English (New Zealand)                5129
    'English (Ireland)                    6153
    'English (South Africa)               7177
    'English (Jamaica)                    8201
    'English (Caribbean)                  9225
    'English (Belize)                    10249
    'English (Trinidad)                  11273
    'Spanish (Traditional Sort)           1034
    'Spanish (Mexican)                    2058
    'Spanish (Modern Sort)                3082
    'Spanish (Guatemala)                  4106
    'Spanish (Costa Rica)                 5130
    'Spanish (Panama)                     6154
    'Spanish (Dominican Republic)         7178
    'Spanish (Venezuela)                  8202
    'Spanish (Colombia)                   9226
    'Spanish (Peru)                      10250
    'Spanish (Argentina)                 11274
    'Spanish (Ecuador)                   12298
    'Spanish (Chile)                     13322
    'Spanish (Uruguay)                   14346
    'Spanish (Paraguay)                  15370
    'Spanish (Bolivia)                   16394
    'Spanish (El Salvador)               17418
    'Spanish (Honduras)                  18442
    'Spanish (Nicaragua)                 19466
    'Spanish (Puerto Rico)               20490
    'Finnish                              1035
    'French (Standard)                    1036
    'French (Belgian)                     2060
    'French (Canadian)                    3084
    'French (Swiss)                       4108
    'French (Luxembourg)                  5132
    'Hebrew                               1037
    'Hungarian                            1038
    'Icelandic                            1039
    'Italian (Standard)                   1040
    'Italian (Swiss)                      2064
    'Japanese                             1041
    'Korean                               1042
    'Korean (Johab)                       2066
    'Dutch (Standard)                     1043
    'Dutch (Belgian)                      2067
    'Norwegian (Bokmal)                   1044
    'Norwegian (Nynorsk)                  2068
    'Polish                               1045
    'Portuguese (Brazil)                  1046
    'Portuguese (Portugal)                2070
    'Romanian                             1048
    'Russian                              1049
    'Croatian                             1050
    'Serbian (Latin)                      2074
    'Serbian (Cyrillic)                   3098
    'Slovak                               1051
    'Albanian                             1052
    'Swedish                              1053
    'Swedish (Finland)                    2077
    'Thai                                 1054
    'Turkish                              1055
    'Indonesian                           1057
    'Ukrainian                            1058
    'Belarusian                           1059
    'Slovenian                            1060
    'Estonian                             1061
    'Latvian                              1062
    'Lithuanian                           1063
    'Farsi                                1065
    'Vietnamese                           1066
    'Basque                               1069
    'Afrikaans                            1078
    'Faeroese                             1080

    'Dim langs As Variant
    'langs = [{1031, "de-de"; 2055, "de-ch"}]
    'langs = Array( _
    '        1031, "de-de" _
    '    )
    
    ' Default ist Englisch
    LCIDToLanguageCode = "en-gb"

    ' https://msdn.microsoft.com/en-us/library/ee825488(v=cs.20).aspx
    Select Case lcid
    Case 1031
        'German (Germany)
        LCIDToLanguageCode = "de-de"
    Case 2055
        'German (Swiss)
        LCIDToLanguageCode = "de-ch"
    Case 3079
        'German (Austrian)
        LCIDToLanguageCode = "de-at"
    Case 4103
        'German (Luxembourg)
        LCIDToLanguageCode = "de-lu"
    Case 5127
        'German (Liechtenstein)
        LCIDToLanguageCode = "de-li"
        
    Case 1033
        'English (United States)
        LCIDToLanguageCode = "en-us"
    Case 2057
        'English (United Kingdom)
        LCIDToLanguageCode = "en-gb"
    Case 3081
        'English (Australian)
        LCIDToLanguageCode = "en-au"
    Case 4105
        'English (Canadian)
        LCIDToLanguageCode = "en-ca"
    Case 5129
        'English (New Zealand)
        LCIDToLanguageCode = "en-nz"
    Case 6153
        'English (Ireland)
        LCIDToLanguageCode = "en-ie"
    Case 7177
        'English (South Africa)
        LCIDToLanguageCode = "en-za"
    Case 8201
        'English (Jamaica)
        LCIDToLanguageCode = "en-jm"
    Case 9225
        'English (Caribbean)
        LCIDToLanguageCode = "en-cb"
    Case 10249
        'English (Belize)
        LCIDToLanguageCode = "en-bz"
    Case 11273
        'English (Trinidad and Tobago)
        LCIDToLanguageCode = "en-tt"
    End Select
End Function

Private Function MapLCIDToInternalLanguage(lcid As Long) As String
    Dim langCulture As String
    langCulture = LCIDToLanguageCode(lcid)
    
    ' Alles was de-xy hat wird auf de-de abgebildet
    If Left(langCulture, 2) = "de" Then
        MapLCIDToInternalLanguage = LANG_DE_DE
    Else
        ' Alles andere wird en-gb
        MapLCIDToInternalLanguage = LANG_EN_GB
    End If
    
End Function

Public Function GetWindowsLanguageString() As String
    On Error GoTo nogo
    
    Dim Ret As Long
    Dim loc As String
    Dim windowsLang As String
    
    loc = Space$(255)
    Ret = GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SISO639LANGNAME, loc, 9)
    loc = Left$(loc, InStr(loc, Chr(0)) - 1)
    windowsLang = loc & "-"
    
    loc = Space$(255)
    Ret = GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SISO3166CTRYNAME, loc, 9)
    loc = Left$(loc, InStr(loc, Chr(0)) - 1)
    windowsLang = windowsLang & loc
    
    GetWindowsLanguageString = LCase(windowsLang)
    Exit Function
nogo:
    GetWindowsLanguageString = "en-gb"
End Function

Private Function GetFallbackLanguage(lang As String) As String
    ' Alles was de-xy hat wird auf de-de abgebildet
    If Left(lang, 2) = "de" Then
        GetFallbackLanguage = LANG_DE_DE
    Else
        ' Alles andere wird en-gb
        GetFallbackLanguage = LANG_EN_GB
    End If
End Function


Attribute VB_Name = "TranslationHelpers"
Option Explicit

' Fallbacksprachen
' Regeln:
 '  File APP_en-xy.txt nicht da -> APP_en-gb.txt benutzen
 '  File APP_de-xy.txt nicht da -> APP_de-de.txt benutzen
 '  File APP_xy-uv.txt nicht da -> APP_en-gb.txt benutzen
Public Const LANG_EN_GB As String = "en-gb"
Public Const LANG_DE_DE As String = "de-de"

Public gTranslation As New Translation

Public Function InitTranslation(path As String, langFile As String, cfg As CfgReader) As Boolean
    InitTranslation = False
    Dim overrideLanguage As String
    If Not cfg Is Nothing Then
        If cfg.GetSection("GLOBALS") = True Then
            overrideLanguage = cfg.GetValue("LANGUAGE")
        End If
    End If
    If Not gTranslation.StartupInit(path, langFile, overrideLanguage) Then
        ' Sprachdateien wurden nicht geladen
        MsgBox FmtInternal("Missing language files ('%1_en-gb.txt')!" & vbCrLf & vbCrLf & "Die Sprachdateien wurden nicht gefunden ('%1_de-de.txt')!", langFile), vbCritical
        Exit Function
    End If
    InitTranslation = True
End Function

Public Function FMT0(f As String) As String
    FMT0 = FmtInternal(TR(f))
End Function

Public Function FMT1(f As String, _
                     ByVal arg1 As String) As String
    FMT1 = FmtInternal(TR(f), arg1)
End Function

Public Function FMT2(f As String, _
                     ByVal arg1 As String, _
                     ByVal arg2 As String) As String
    FMT2 = FmtInternal(TR(f), arg1, arg2)
End Function

Public Function FMT3(f As String, _
                     ByVal arg1 As String, _
                     ByVal arg2 As String, _
                     ByVal arg3 As String) As String
    FMT3 = FmtInternal(TR(f), arg1, arg2, arg3)
End Function

Public Function FMT4(f As String, _
                     ByVal arg1 As String, _
                     ByVal arg2 As String, _
                     ByVal arg3 As String, _
                     ByVal arg4 As String) As String
    FMT4 = FmtInternal(TR(f), arg1, arg2, arg3, arg4)
End Function

Public Function FMT5(f As String, _
                     ByVal arg1 As String, _
                     ByVal arg2 As String, _
                     ByVal arg3 As String, _
                     ByVal arg4 As String, _
                     ByVal arg5 As String) As String
    FMT5 = FmtInternal(TR(f), arg1, arg2, arg3, arg4, arg5)
End Function

Public Function FMT6(f As String, _
                     ByVal arg1 As String, _
                     ByVal arg2 As String, _
                     ByVal arg3 As String, _
                     ByVal arg4 As String, _
                     ByVal arg5 As String, _
                     ByVal arg6 As String) As String
    FMT6 = FmtInternal(TR(f), arg1, arg2, arg3, arg4, arg5, arg6)
End Function

Public Function GetTranslationString(id As String, fallback As String) As String
    If gTranslation.StringExists(id) Then
        GetTranslationString = gTranslation.GetString(id)
        Exit Function
    End If
    GetTranslationString = fallback
End Function

Public Function TR(id As String) As String
'    If gTranslation Is Nothing Then
'        TR = "gTranslation Not Initialized"
'        Exit Function
'    End If
    TR = gTranslation.GetString(id)
End Function

Public Function FmtInternal(f As String, _
                    Optional arg1 As String = vbNullChar, _
                    Optional arg2 As String = vbNullChar, _
                    Optional arg3 As String = vbNullChar, _
                    Optional arg4 As String = vbNullChar, _
                    Optional arg5 As String = vbNullChar, _
                    Optional arg6 As String = vbNullChar, _
                    Optional arg7 As String = vbNullChar, _
                    Optional arg8 As String = vbNullChar, _
                    Optional arg9 As String = vbNullChar _
                    ) As String
    FmtInternal = gTranslation.FormatString(f, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)
End Function

Public Function IsYes(s As String) As Boolean
  If UCase(s) = "JA" Or UCase(s) = "YES" Then
    IsYes = True
  End If
End Function

Public Function IsNo(s As String) As Boolean
  If UCase(s) = "NEIN" Or UCase(s) = "NO" Then
    IsNo = True
  End If
End Function

Public Function IsTrue(s As String) As Boolean
    If UCase(s) = "WAHR" Or UCase(s) = "TRUE" Then
        IsTrue = True
    End If
End Function

Public Function IsFalse(s As String) As Boolean
    If UCase(s) = "FALSCH" Or UCase(s) = "FALSE" Then
        IsFalse = True
    End If
End Function

#If PROJECT_ACCESSTRACKER <> 1 Then
Private Function MyWorksheetExists(ByRef wb, wsname As String) As Boolean
    On Error GoTo nogo
    Dim ws
    Set ws = wb.Worksheets(wsname)
    Set ws = Nothing
    MyWorksheetExists = True
    Exit Function
nogo:
End Function

Public Function TranslationSheetExists(ByRef wb As Workbook, names As Variant) As String
    On Error GoTo nogo
    Dim name As String
    If IsArray(names) Then
        Dim n As Variant
        For Each n In names
            name = CStr(n)
            If MyWorksheetExists(wb, name) Then
                TranslationSheetExists = name
                Exit Function
            End If
        Next n
        If UBound(names) >= 0 Then
            TranslationSheetExists = CStr(names(0))
            Exit Function
        End If
    Else
        name = CStr(names)
        If MyWorksheetExists(wb, name) Then
            TranslationSheetExists = name
            Exit Function
        End If
    End If
nogo:
    
End Function

' Das gleiche wie Cells.Find - aber probiert mehrere Strings zu finden (fuer mehrere Sprachen)
Public Function TranslationFindCells(ws As Worksheet, What As Variant, LookIn As Excel.XlFindLookIn, _
                                     LookAt As Excel.XlLookAt, SearchOrder As Excel.XlSearchOrder, _
                                     SearchDirection As Excel.XlSearchDirection, MatchCase As Boolean, Optional MatchByte As Boolean = False) As Range
  Set TranslationFindCells = Nothing
  Dim s As Variant
  For Each s In What
    Dim r As Range
    Set r = ws.Cells.Find(CStr(s), LookIn:=LookIn, LookAt:=LookAt, SearchOrder:=SearchOrder, SearchDirection:=SearchDirection, MatchCase:=MatchCase, MatchByte:=MatchByte)
    If Not r Is Nothing Then
      Set TranslationFindCells = r
      Exit Function
    End If
  Next s
End Function

Public Function TranslationFindCells2(ws As Worksheet, What As Variant, After As Range, LookIn As Excel.XlFindLookIn, _
                                     LookAt As Excel.XlLookAt, SearchOrder As Excel.XlSearchOrder, _
                                     SearchDirection As Excel.XlSearchDirection, MatchCase As Boolean, Optional MatchByte As Boolean = False) As Range
  Set TranslationFindCells2 = Nothing
  Dim s As Variant
  For Each s In What
    Dim r As Range
    Set r = ws.Cells.Find(CStr(s), After:=After, LookIn:=LookIn, LookAt:=LookAt, SearchOrder:=SearchOrder, SearchDirection:=SearchDirection, MatchCase:=MatchCase, MatchByte:=MatchByte)
    If Not r Is Nothing Then
      Set TranslationFindCells2 = r
      Exit Function
    End If
  Next s
End Function


#End If

' This works because Debug.Print is omitted in the compiled code
Public Function InIDE() As Boolean
  On Error Resume Next
  Debug.Print 0 / 0
  InIDE = Err.Number <> 0
End Function



Attribute VB_Name = "UNC"
Option Explicit

#If VBA7 Then
Public Declare PtrSafe Function WNetGetConnection Lib "mpr.dll" Alias _
                       "WNetGetConnectionA" (ByVal lpszLocalName As String, _
                                             ByVal lpszRemoteName As String, _
                                                   cbRemoteName As Long) As Long
#Else
Public Declare Function WNetGetConnection Lib "mpr.dll" Alias _
                       "WNetGetConnectionA" (ByVal lpszLocalName As String, _
                                             ByVal lpszRemoteName As String, _
                                                   cbRemoteName As Long) As Long
#End If


Public Function GetUNCPath(ByVal sLocalPath As String) As String '// -----------------------------------------------------------------
'// Methode:   | Konvertiert einen Pfad in UNC-Pfad (\\SERVER\...)
'// -----------------------------------------------------------------
'// Parameter: | sLocalPath = g|fffd|ltiger, lokaler Pfad (X:\..) '// -----------------------------------------------------------------
'// R|fffd|ckgabe:  | bei Erfolg = UNC-Pfad
'//            | bei Fehler = sLocalPath
'// -----------------------------------------------------------------
    Const NO_ERROR  As Long = 0
    Dim sUNCPath    As String
    Dim sResult     As String
    Dim sDrive      As String

    On Error Resume Next
    GetUNCPath = sLocalPath
    If VBA.Mid$(sLocalPath, 2, 1) <> ":" Then Exit Function
'// Die API-Funktion ben|fffd|tigt nur das Laufwerk!
    sDrive = VBA.Left$(sLocalPath, 2)
    sUNCPath = VBA.String(260, 0)
    If WNetGetConnection(sDrive, sUNCPath, VBA.Len(sUNCPath)) = NO_ERROR Then
        sResult = VBA.Left$(sUNCPath, VBA.InStr(sUNCPath, vbNullChar) - 1)
        If VBA.Len(sResult) > 0 Then
            GetUNCPath = sResult & VBA.Mid$(sLocalPath, 3)
        End If
    End If

End Function

Public Function testShortUNC()
    Debug.Print GetDriveAndPathFromUNC("\\TABLET\C\01234567890123456789012345678901234567890123456789\01234567890123456789012345678901234567890123456789\01234567890123456789012345678901234567890123456789\01234567890123456789012345678901234567890123456789\012345678901234567890123456789\MAPPE0123456789012345678901234567890123456789012345678901234567890123456789.XLS")
End Function

' .Net

Function GetDriveAndPathFromUNC(ByVal strFullPath As String) As String

    If Mid(strFullPath, 2, 1) = ":" Then
      GetDriveAndPathFromUNC = strFullPath
      Exit Function
    End If

    Dim strUNC As String
    Dim i As Integer
    Dim s As String

    s = strFullPath

    For i = 65 To 90
        If GetUNCPathShort(Chr(i) & ":", strUNC) = 0 Then
            If UCase(strUNC) = UCase(Left(strFullPath, Len(strUNC))) Then
              If Len(Chr(i) & ":" & Mid(strFullPath, Len(strUNC) + 1, Len(strFullPath) - (Len(strUNC)))) < Len(s) Then
                s = Chr(i) & ":" & Mid(strFullPath, Len(strUNC) + 1, Len(strFullPath) - (Len(strUNC)))
              End If
            End If
        End If
    Next i
    
    GetDriveAndPathFromUNC = s
    
End Function


Function GetUNCPathShort(ByVal strDriveLetter As String, _
    ByRef strUNCPath As String) As Long
    On Local Error GoTo GetUNCPath_Err
    Dim strMsg As String
    Dim lngReturn As Long
    Dim strLocalName As String
    Dim strRemoteName As String
    Dim lngRemoteName As Long
    strLocalName = strDriveLetter
    strRemoteName = String$(255, Chr$(32))
    
    lngRemoteName = Len(strRemoteName)
    'Attempt to grab UNC
    lngReturn = WNetGetConnection(strLocalName, _
    strRemoteName, _
    lngRemoteName)


    If lngReturn = 0 Then
        
        'No problems - return the UNC
        'to the passed ByRef string
        GetUNCPathShort = 0
        
        
        ' only works for omni 2 build
        ' strUNCPath = LTrim(strRemoteName)
        ' strUNCPath = Left$(strUNCPath, Len(str
        '     UNCPath) - 1)
        
        
        ' less acurate potential for error if se
        '     rver or share contains spaces.
        
        strUNCPath = Mid(strRemoteName, 1, (InStr(1, strRemoteName, " ", 1)) - 2)
        
        
    Else
        'Problems - so return original
        'drive letter and error number
        GetUNCPathShort = lngReturn
        strUNCPath = strDriveLetter & "\"
    End If
GetUNCPath_End:
    Exit Function
GetUNCPath_Err:
    GetUNCPathShort = 1
    strUNCPath = strDriveLetter
    Resume GetUNCPath_End
End Function


' .Net END
Attribute VB_Name = "UnicodeFile"
Option Explicit

#If VBA7 And Win64 Then

  Private Declare PtrSafe Function MultiByteToWideChar Lib "Kernel32.dll" ( _
      ByVal codePage As Long, _
      ByVal dwFlags As Long, _
      ByVal lpMultiByteStr As LongPtr, _
      ByVal cbMultiByte As LongPtr, _
      ByVal lpWideCharStr As LongPtr, _
      ByVal cchWideChar As Long _
  ) As Long

  Private Declare PtrSafe Function WideCharToMultiByte Lib "kernel32" ( _
      ByVal codePage As Long, ByVal dwFlags As Long, _
      ByVal lpWideCharStr As LongPtr, ByVal cchWideChar As LongPtr, _
      ByVal lpMultiByteStr As LongPtr, ByVal cchMultiByte As LongPtr, _
      ByVal lpDefaultChar As LongPtr, ByVal lpUsedDefaultChar As LongPtr) As Long
        
#Else
  Private Declare Function MultiByteToWideChar Lib "Kernel32.dll" ( _
      ByVal codePage As Long, _
      ByVal dwFlags As Long, _
      ByVal lpMultiByteStr As Long, _
      ByVal cbMultiByte As Long, _
      ByVal lpWideCharStr As Long, _
      ByVal cchWideChar As Long _
  ) As Long
  
  Private Declare Function WideCharToMultiByte Lib "Kernel32.dll" ( _
      ByVal codePage As Long, _
      ByVal dwFlags As Long, _
      ByVal lpWideCharStr As Long, _
      ByVal cchWideChar As Long, _
      ByVal lpMultiByteStr As Long, _
      ByVal cbMultiByte As Long, _
      ByVal lpDefaultChar As Long, _
      ByVal lpUsedDefaultChar As Long _
  ) As Long
#End If

Public Const CP_ACP        As Long = 0          ' Default ANSI code page.
Public Const CP_UTF8       As Long = 65001      ' UTF8.
Public Const CP_UTF16_LE   As Long = 1200       ' UTF16 - little endian.
Public Const CP_UTF16_BE   As Long = 1201       ' UTF16 - big endian.
Public Const CP_UTF32_LE   As Long = 12000      ' UTF32 - little endian.
Public Const CP_UTF32_BE   As Long = 12001      ' UTF32 - big endian.

' Purpose:  Heuristic to determine whether bytes in a file are UTF-8.
Private Function FileBytesAreUTF8(ByVal the_iFileNo As Integer) As Boolean

    Const knSampleByteSize          As Long = 2048
    Dim nLof                        As Long
    Dim nByteCount                  As Long
    Dim nByteIndex                  As Long
    Dim nCharExtraByteCount         As Long
    Dim bytValue                    As Byte

    ' We look at the first <knSampleByteSize> bytes of the file. However, if the file is smaller, we will have to
    ' use the smaller size.
    nLof = LOF(the_iFileNo)
    If nLof < knSampleByteSize Then
        nByteCount = nLof
    Else
        nByteCount = knSampleByteSize
    End If

    ' Go to the start of the file.
    Seek #the_iFileNo, 1

    For nByteIndex = 1 To nByteCount

        Get #the_iFileNo, , bytValue

        ' If the character we are processing has bytes beyond 1, then we are onto the next character.
        If nCharExtraByteCount = 0 Then
            '
            ' The UTF-8 specification says that the first byte of a character has masking bits which indicate how many bytes follow.
            '
            ' See: http://en.wikipedia.org/wiki/UTF-8#Description
            '
            ' Bytes in
            ' sequence   Byte 1   Byte 2   Byte 3   Byte 4
            ' 1          0xxxxxxx
            ' 2          110xxxxx 10xxxxxx
            ' 3          1110xxxx 10xxxxxx 10xxxxxx
            ' 4          11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
            '
            If (bytValue And &H80) = &H0 Then
                nCharExtraByteCount = 0
            ElseIf (bytValue And &HE0) = &HC0 Then
                nCharExtraByteCount = 1
            ElseIf (bytValue And &HF0) = &HE0 Then
                nCharExtraByteCount = 2
            ElseIf (bytValue And &HF8) = &HF0 Then
                nCharExtraByteCount = 3
            Else
                ' If none of these masks were matched, then this can't be a UTF-8 character.
                FileBytesAreUTF8 = False
                Exit Function
            End If
        Else
            ' All following bytes must be masked as in the table above.
            If (bytValue And &HC0) = &H80 Then
                nCharExtraByteCount = nCharExtraByteCount - 1
                If nCharExtraByteCount = 0 Then
                    FileBytesAreUTF8 = True
                End If
            Else
                ' Not a UTF8 character.
                FileBytesAreUTF8 = False
                Exit Function
            End If
        End If

    Next nByteIndex

End Function

' Purpose:  Take a string whose bytes are in the byte array <the_abytCPString>, with code page <the_nCodePage>, convert to a VB string.
Private Function FromCPString(ByRef the_abytCPString() As Byte, ByVal the_nCodePage As Long) As String

    Dim sOutput                     As String
    Dim nValueLen                   As Long
    Dim nOutputCharLen              As Long

    ' If the code page says this is already compatible with the VB string, then just copy it into the string. No messing.
    If the_nCodePage = CP_UTF16_LE Then
        FromCPString = the_abytCPString()
    Else

        ' Cache the input length.
        nValueLen = UBound(the_abytCPString) - LBound(the_abytCPString) + 1

        ' See how big the output buffer will be.
        nOutputCharLen = MultiByteToWideChar(the_nCodePage, 0&, VarPtr(the_abytCPString(LBound(the_abytCPString))), nValueLen, 0&, 0&)

        ' Resize output byte array to the size of the UTF-8 string.
        sOutput = Space$(nOutputCharLen)

        ' Make this API call again, this time giving a pointer to the output byte array.
        MultiByteToWideChar the_nCodePage, 0&, VarPtr(the_abytCPString(LBound(the_abytCPString))), nValueLen, StrPtr(sOutput), nOutputCharLen

        ' Return the array.
        FromCPString = sOutput

    End If

End Function

Public Function GetContents(ByVal the_sTextFile As String, ByRef out_nCodePage As Long, Optional ByVal the_nDesiredCodePage As Long = -1, Optional ByRef out_bContainedBOM As Boolean) As String

    Dim iFileNo                     As Integer
    Dim abytFileContents()          As Byte
    Dim nDataSize                   As Long

    iFileNo = FreeFile

    OpenForInput the_sTextFile, iFileNo, out_nCodePage, the_nDesiredCodePage, out_bContainedBOM

    ' We want to read the entire contents of the file (not including any BOM value).
    ' After calling OpenForInput(), the file pointer should be positioned after any BOM.
    ' So size file contents buffer to <file size> - <current position> + 1.
    nDataSize = LOF(iFileNo) - Seek(iFileNo) + 1
    ReDim abytFileContents(1 To nDataSize)
    Get #iFileNo, , abytFileContents()

    Close iFileNo

    ' Now we must convert this to UTF-8. But we have to first convert to the Windows NT standard UTF-16 LE.
    GetContents = FromCPString(abytFileContents(), out_nCodePage)

End Function


' Diese Funktion ist langsam!!!!!!!!!!!!!

' Purpose:  Reads up to the end of the current line of the file, repositions to the beginning of the next line, if any, and
'           outputs all characters found.
' Inputs:   the_nFileNo     The number of the file.
' Outputs:  out_sLine       The line from the current position in the file.
' Return:   True if there is more data.
Public Function LineInputUTF8(ByVal the_nFileNo As Integer, ByRef out_sLine As String) As Boolean

    Dim bytValue            As Byte
    Dim abytLine()          As Byte
    Dim nStartOfLinePos     As Long
    Dim nEndOfLinePos       As Long
    Dim nStartOfNextLine    As Long
    Dim nLineLen            As Long

    ' Save the current file position as the beginning of the line, and cache this value.
    nStartOfLinePos = Seek(the_nFileNo)

    ' Retrieves the first byte from the current position.
    Get #the_nFileNo, , bytValue

    ' Loop until the end of file is encountered.
    Do Until EOF(the_nFileNo)

        ' Check whether this byte represents a carriage return or line feed character (indicating new line).
        If bytValue = 13 Or bytValue = 10 Then
            ' By this point, the current position is *after* the CR or LF character, so to get the position of the
            ' last byte in the line, we must go back two bytes.
            nEndOfLinePos = Seek(the_nFileNo) - 2

            ' If this is a carriage return, then we must check the next character.
            If bytValue = 13 Then
                Get #the_nFileNo, , bytValue
                ' Is this a line feed?
                If bytValue = 10 Then
                ' Yes. Assume that CR-LF counts as a single NewLine. So the start of the next line should skip over the line feed.
                    nStartOfNextLine = nEndOfLinePos + 3
                Else
                ' No. The start of the next line is the current position.
                    nStartOfNextLine = nEndOfLinePos + 2
                End If
            ElseIf bytValue = 10 Then
            ' If this is a line feed, then the start of the next line is the current position.
                nStartOfNextLine = nEndOfLinePos + 2
            End If

            ' Since we have processed all the bytes in the line, exit the loop.
            Exit Do
        End If

        ' Get the next byte.
        Get #the_nFileNo, , bytValue
    Loop

    ' Check to see if there was an end of line.
    If nEndOfLinePos = 0 Then
    ' No, this is the end of the file - so use all the remaining characters.
        nLineLen = Seek(the_nFileNo) - nStartOfLinePos - 1
    Else
    ' Yes - so use all the characters up to the end of line position.
        nLineLen = nEndOfLinePos - nStartOfLinePos + 1
    End If

    ' Is this line empty?
    If nLineLen = 0 Then
    ' Yes - just return an empty string.
        out_sLine = vbNullString
    Else
    ' No - pull all the bytes from the beginning to the end of the line into a byte array, and then convert that from UTF-8 to a VB string.
        ReDim abytLine(1 To nLineLen)
        Get #the_nFileNo, nStartOfLinePos, abytLine()
        out_sLine = FromCPString(abytLine(), CP_UTF8)
    End If

    ' If there is a line afterwards, then move to the beginning of the line, and return True.
    If nStartOfNextLine > 0 Then
        Seek #the_nFileNo, nStartOfNextLine
        LineInputUTF8 = True
    End If

End Function

' Purpose:  Analogue of 'Open "fileName" For Input As #fileNo' - but also return what type of text this is via a Code Page value.
' Inputs:   the_sFileName
'           the_iFileNo
'           (the_nDesiredCodePage)  The code page that you want to use with this file.
'                                   If this value is set to the default, -1, this indicates that the code page will be ascertained from the file.
' Outputs:  out_nCodePage           There are only six valid values that are returned if <the_nDesiredCodePage> was set to -1.
'               CP_ACP        ANSI code page
'               CP_UTF8       UTF-8
'               CP_UTF16LE    UTF-16 Little Endian (VB and NT default string encoding)
'               CP_UTF16BE    UTF-16 Big Endian
'               CP_UTF32LE    UTF-32 Little Endian
'               CP_UTF32BE    UTF-32 Big Endian
'           (out_bContainedBOM)     If this was set to True, then the file started with a BOM (Byte Order Marker).
Public Sub OpenForInput(ByRef the_sFilename As String, ByVal the_iFileNo As Integer, ByRef out_nCodePage As Long, Optional ByVal the_nDesiredCodePage As Long = -1, Optional ByRef out_bContainedBOM As Boolean)

    ' Note if we want to take account of every case, we should read in the first four bytes, and check for UTF-32 low and high endian BOMs, check
    ' the first three bytes for the UTF-8 BOM, and finally check the first two bytes for UTF-16 low and hight endian BOMs.
    Dim abytBOM(1 To 4)             As Byte
    Dim nCodePage                   As Long

    ' By default, there is no BOM.
    out_bContainedBOM = False

    Open the_sFilename For Binary Access Read As #the_iFileNo

    ' We are interested in -1 (ascertain code page), and then various UTF encodings.
    Select Case the_nDesiredCodePage
    Case -1, CP_UTF8, CP_UTF16_BE, CP_UTF16_LE, CP_UTF32_BE, CP_UTF32_LE

        ' Default code page.
        nCodePage = CP_ACP

        ' Pull in the first four bytes to determine the BOM (byte order marker).
        Get #the_iFileNo, , abytBOM()

        ' The following are the BOMs for text files:
        '
        ' FF FE         UTF-16, little endian
        ' FE FF         UTF-16, big endian
        ' EF BB BF      UTF-8
        ' FF FE 00 00   UTF-32, little endian
        ' 00 00 FE FF   UTF-32, big-endian
        '
        ' Work out the code page from this information.

        Select Case abytBOM(1)
        Case &HFF
            If abytBOM(2) = &HFE Then
                If abytBOM(3) = 0 And abytBOM(4) = 0 Then
                    nCodePage = CP_UTF32_LE
                Else
                    nCodePage = CP_UTF16_LE
                End If
            End If
        Case &HFE
            If abytBOM(2) = &HFF Then
                nCodePage = CP_UTF16_BE
            End If
        Case &HEF
            If abytBOM(2) = &HBB And abytBOM(3) = &HBF Then
                nCodePage = CP_UTF8
            End If
        Case &H0
            If abytBOM(2) = &H0 And abytBOM(3) = &HFE And abytBOM(4) = &HFF Then
                nCodePage = CP_UTF32_BE
            End If
        End Select

        ' Did we match any BOMs?
        If nCodePage = CP_ACP Then
        ' No - we are still defaulting to the ANSI code page.
            ' Special check for UTF-8. The BOM is not specified in the standard for UTF-8, but according to Wikipedia (which is always right :-) ),
            ' only Microsoft includes this marker at the beginning of files.
            If FileBytesAreUTF8(the_iFileNo) Then
                out_nCodePage = CP_UTF8
            Else
                out_nCodePage = CP_ACP
            End If
        Else
        ' Yes - we have worked out the code page from the BOM.
            ' If no code page was suggested, we now return the code page we found.
            If the_nDesiredCodePage = -1 Then
                out_nCodePage = nCodePage
            End If

            ' Inform the caller that a BOM was found.
            out_bContainedBOM = True
        End If

        ' Reset the file pointer to the beginning of the file data.
        If out_bContainedBOM Then
            ' Note that if the code page found was one of the two UTF-32 values, then we are already in the correct position.
            ' Otherwise, we have to move to just after the end of the BOM.
            Select Case nCodePage
            Case CP_UTF16_BE, CP_UTF16_LE
                Seek #the_iFileNo, 3
            Case CP_UTF8
                Seek #the_iFileNo, 4
            End Select
        Else
            ' There is no BOM, so simply go the beginning of the file.
            Seek #the_iFileNo, 1
        End If

    Case Else
        out_nCodePage = the_nDesiredCodePage
    End Select

End Sub

' Purpose:  Analogue of 'Open "fileName" For Append As #fileNo'
Public Sub OpenForAppend(ByRef the_sFilename As String, ByVal the_iFileNo As Integer, Optional ByVal the_nCodePage As Long = CP_ACP, Optional ByVal the_bPrefixWithBOM As Boolean = True)

    ' Open the file and move to the end of the file.
    Open the_sFilename For Binary Access Write As #the_iFileNo
    Seek the_iFileNo, LOF(the_iFileNo) + 1

    If the_bPrefixWithBOM Then
        WriteBOM the_iFileNo, the_nCodePage
    End If

End Sub

' Purpose:  Analogue of 'Open "fileName" For Output As #fileNo'
Public Sub OpenForOutput(ByRef the_sFilename As String, ByVal the_iFileNo As Integer, Optional ByVal the_nCodePage As Long = CP_ACP, Optional ByVal the_bPrefixWithBOM As Boolean = True)

    ' Ensure we overwrite the file by deleting it ...
    On Error Resume Next
    Kill the_sFilename
    On Error GoTo 0

    ' ... before creating it.
    Open the_sFilename For Binary Access Write As #the_iFileNo

    If the_bPrefixWithBOM Then
        WriteBOM the_iFileNo, the_nCodePage
    End If

End Sub

' Purpose:  Analogue of the 'Print #fileNo, value' statement. But only one value allowed.
'           Setting <the_bAppendNewLine> = False is analagous to 'Print #fileNo, value;'.
Public Sub Print_(ByVal the_iFileNo As Integer, ByRef the_sValue As String, Optional ByVal the_nCodePage As Long = CP_ACP, Optional ByVal the_bAppendNewLine As Boolean = True)

    Const kbytNull                  As Byte = 0
    Const kbytCarriageReturn        As Byte = 13
    Const kbytNewLine               As Byte = 10

    Put #the_iFileNo, , ToCPString(the_sValue, the_nCodePage)

    If the_bAppendNewLine Then
        Select Case the_nCodePage
        Case CP_UTF16_BE
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytCarriageReturn
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNewLine
        Case CP_UTF16_LE
            Put #the_iFileNo, , kbytCarriageReturn
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNewLine
            Put #the_iFileNo, , kbytNull
        Case CP_UTF32_BE
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytCarriageReturn
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNewLine
        Case CP_UTF32_LE
            Put #the_iFileNo, , kbytCarriageReturn
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNewLine
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNull
        Case Else
            Put #the_iFileNo, , kbytCarriageReturn
            Put #the_iFileNo, , kbytNewLine
        End Select
    End If

End Sub

Public Sub PutContents(ByRef the_sFilename As String, ByRef the_sFileContents As String, Optional ByVal the_nCodePage As Long = CP_ACP, Optional the_bPrefixWithBOM As Boolean)

    Dim iFileNo                     As Integer

    iFileNo = FreeFile
    OpenForOutput the_sFilename, iFileNo, the_nCodePage, the_bPrefixWithBOM
    Print_ iFileNo, the_sFileContents, the_nCodePage, False
    Close iFileNo

End Sub

' Purpose:  Converts a VB string (UTF-16) to UTF8 - as a binary array.
Private Function ToCPString(ByRef the_sValue As String, ByVal the_nCodePage As Long) As Byte()

    Dim abytOutput()                As Byte
    Dim nValueLen                   As Long
    Dim nOutputByteLen              As Long

    If the_nCodePage = CP_UTF16_LE Then
        ToCPString = the_sValue
    Else

        ' Cache the input length.
        nValueLen = Len(the_sValue)

        ' See how big the output buffer will be.
        nOutputByteLen = WideCharToMultiByte(the_nCodePage, 0&, StrPtr(the_sValue), nValueLen, 0&, 0&, 0&, 0&)

        If nOutputByteLen > 0 Then
            ' Resize output byte array to the size of the UTF-8 string.
            ReDim abytOutput(1 To nOutputByteLen)

            ' Make this API call again, this time giving a pointer to the output byte array.
            WideCharToMultiByte the_nCodePage, 0&, StrPtr(the_sValue), nValueLen, VarPtr(abytOutput(1)), nOutputByteLen, 0&, 0&
        End If

        ' Return the array.
        ToCPString = abytOutput()

    End If

End Function

Private Sub WriteBOM(ByVal the_iFileNo As Integer, ByVal the_nCodePage As Long)

    ' FF FE         UTF-16, little endian
    ' FE FF         UTF-16, big endian
    ' EF BB BF      UTF-8
    ' FF FE 00 00   UTF-32, little endian
    ' 00 00 FE FF   UTF-32, big-endian

    Select Case the_nCodePage
    Case CP_UTF8
        Put #the_iFileNo, , CByte(&HEF)
        Put #the_iFileNo, , CByte(&HBB)
        Put #the_iFileNo, , CByte(&HBF)
    Case CP_UTF16_LE
        Put #the_iFileNo, , CByte(&HFF)
        Put #the_iFileNo, , CByte(&HFE)
    Case CP_UTF16_BE
        Put #the_iFileNo, , CByte(&HFE)
        Put #the_iFileNo, , CByte(&HFF)
    Case CP_UTF32_LE
        Put #the_iFileNo, , CByte(&HFF)
        Put #the_iFileNo, , CByte(&HFE)
        Put #the_iFileNo, , CByte(&H0)
        Put #the_iFileNo, , CByte(&H0)
    Case CP_UTF32_BE
        Put #the_iFileNo, , CByte(&H0)
        Put #the_iFileNo, , CByte(&H0)
        Put #the_iFileNo, , CByte(&HFE)
        Put #the_iFileNo, , CByte(&HFF)
    End Select

End Sub





Attribute VB_Name = "XLFldVal"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Public m_Value As Long
Public m_Txt As String

Attribute VB_Name = "XLForNext"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Public m_Name As String
Public m_Ref
Public m_Current As Long
Public m_Width As Long
Public m_WidthCurrent As Long
Attribute VB_Name = "XLScript"
Option Explicit

' Public m_LogY As Long
Private m_WS As Excel.Worksheet
Public m_Flds As Collection
Private m_FN As Collection
Private m_CodeStart As String
Private m_Log As Collection

Private m_SimpleVars As Collection
Private m_Vars As Collection
Private m_VarArray As Collection
Private m_VarArray2D As Collection
Private m_GlobalObjects As Collection

#Const USE_LATE_BINDING_MDB = True
#Const USE_LATE_BINDING_XLS = False

#If USE_LATE_BINDING_MDB <> False Then
  Public m_App As Object
  Public m_DB As Object
  Public m_Workspace As Object
#Else
  Public m_App As Access.Application
  Public m_DB As database
  Public m_Workspace As Workspace
#End If

#If USE_LATE_BINDING_XLS = True Then
  Global m_Workbook As Object
  Global m_Excel As Object
#Else
  Global m_Workbook As Excel.Workbook
  Global m_Excel As Excel.Application
#End If

Public Const XLSCript_Debug As Boolean = False
Private m_InPrint As Boolean

Public m_AllVars As Collection

Private MyLastTime As Date

Public Function XLScriptCreateAccessApp(v As Long) As Object
  Set XLScriptCreateAccessApp = CreateObject("Access.Application." & v)
End Function

Public Function XLScriptCheckAccessVersion(v As Long) As Boolean
XLScriptCheckAccessVersion = False
On Error Resume Next
  Dim o As Object
  Set o = CreateObject("Access.Application." & v)
  If Not o Is Nothing Then
    XLScriptCheckAccessVersion = True
    o.CloseCurrentDatabase
    o.Quit
    Set o = Nothing
  End If
End Function

Public Sub XLScriptStore(fn As String)
  Dim ff As Integer
  ff = FreeFile
  Open fn For Output As #ff
    Dim item
    If m_VarArray2D.count > 0 Then
      For Each item In m_VarArray2D
        item.Store ff
      Next item
    End If
    If m_VarArray.count > 0 Then
      For Each item In m_VarArray
        item.Store ff
      Next item
    End If
    If m_Vars.count > 0 Then
      For Each item In m_Vars
        item.Store ff
      Next item
    End If
  Close #ff
End Sub

Public Sub XLScriptRegisterGlobalObject(n As String, o As Variant)
  
  On Error Resume Next
  m_GlobalObjects.Remove n
  
  Dim gob As XLScriptGlobalObject
  Set gob = New XLScriptGlobalObject
  gob.m_Name = n
  gob.m_Object = o
  m_GlobalObjects.Add gob, CStr(n)

End Sub

Public Function XLScriptGetGlobalObject(n As String) As Variant
  On Error GoTo NoObject
  Set XLScriptGetGlobalObject = Nothing
  Set XLScriptGetGlobalObject = m_GlobalObjects(n)
  
  Exit Function
NoObject:
  'If Not AR_UseDB Then MsgBox "ERROR: XLScriptGetGlobalObject: Object '" & n & "' not found!", vbCritical, "XLScript"
  If Not AR_UseDB Then MsgBox FMT1("XLSCRIPT_1", n), vbCritical, "XLScript"
End Function

Public Sub XLScriptInitDebug()
  If XLSCript_Debug = True Or AR_UseDB = True Then
    Set m_AllVars = New Collection
  End If
End Sub

Public Sub XLDumpNonprinted()
  If XLSCript_Debug Then
    Dim item
    For Each item In m_AllVars
      If Not item.m_WasPrinted Then
        Select Case TypeName(item)
          Case "XLScriptArray"
            Debug.Print TypeName(item), item.m_SortName
          Case "XLScriptArray2D"
            Debug.Print TypeName(item), item.m_SortName
          Case "XLScriptSimpleVar"
            Debug.Print TypeName(item), item.m_Txt, item.m_Value
          Case "XLScriptVar"
            Debug.Print TypeName(item), item.m_SortName
          Case Else
            Debug.Print "Unknown Type: " & TypeName(item)
        End Select
      End If
    Next item
  End If
End Sub

Public Sub XLScriptInitGlobals()
'  If m_LogY <= 0 Then m_LogY = 1
  Set m_GlobalObjects = New Collection
  Set m_FN = New Collection
  Set m_Flds = New Collection
  Set m_VarArray2D = New Collection
  Set m_VarArray = New Collection
  Set m_Vars = New Collection
  Set m_SimpleVars = New Collection
  Set m_Log = New Collection
End Sub
Public Sub XLScriptExitGlobals()
  Set m_FN = Nothing
  Set m_Flds = Nothing
  Set m_VarArray2D = Nothing
  Set m_VarArray = Nothing
  Set m_Vars = Nothing
  Set m_SimpleVars = Nothing
  Set m_Log = Nothing
  Set m_GlobalObjects = Nothing
End Sub

Public Sub XLScriptInit(ByRef ws As Excel.Worksheet, passstring As String)
  Set m_WS = ws
  m_WS.Activate
  m_CodeStart = "<!" & passstring & " "
End Sub
Public Sub XLScriptExit()
  Set m_WS = Nothing
End Sub

Public Function XLScriptCreateArray2D(n As String) As XLScriptArray2D
  Dim da As XLScriptArray2D
  Set da = New XLScriptArray2D
  da.Init n
  Set XLScriptCreateArray2D = da
  
End Function

Public Function XLScriptAddArray2D(n As String) As XLScriptArray2D
  Dim da As XLScriptArray2D
  Set da = XLScriptCreateArray2D(n)
  m_VarArray2D.Add da, CStr(n)
  Set XLScriptAddArray2D = da

  If XLSCript_Debug = True Or AR_UseDB = True Then
    If Not m_AllVars Is Nothing Then m_AllVars.Add da
  End If
End Function

Public Function XLScriptAddArray(n As String) As XLScriptArray
  Dim da As XLScriptArray
  Set da = New XLScriptArray
  da.Init n
  m_VarArray.Add da, CStr(n)
  Set XLScriptAddArray = da

  If XLSCript_Debug = True Or AR_UseDB = True Then
    If Not m_AllVars Is Nothing Then m_AllVars.Add da
  End If
End Function

Public Function XLScriptGetArray(n As String) As XLScriptArray
On Error GoTo notFound
  Set XLScriptGetArray = Nothing
  Set XLScriptGetArray = m_VarArray(CStr(n))
  Exit Function
notFound:
  'If Not AR_UseDB Then MsgBox "ERROR: XLScriptGetArray: Array '" & n & "' not found!", vbCritical, "XLScript"
  If Not AR_UseDB Then MsgBox FMT1("XLSCRIPT_2", n), vbCritical, "XLScript"
End Function

Public Function XLScriptGetArray2D(n As String) As XLScriptArray2D
On Error GoTo notFound
  Set XLScriptGetArray2D = Nothing
  Set XLScriptGetArray2D = m_VarArray2D(CStr(n))
  Exit Function
notFound:
  'If Not AR_UseDB Then MsgBox "ERROR: XLScriptGetArray2D: Array '" & n & "' not found!", vbCritical, "XLScript"
  If Not AR_UseDB Then MsgBox FMT1("XLSCRIPT_3", n), vbCritical, "XLScript"
End Function


Public Function XLScriptAddVar(n As String) As XLScriptVar
  Dim da As XLScriptVar
  Set da = New XLScriptVar
  da.Init n
  m_Vars.Add da, CStr(n)
  Set XLScriptAddVar = da
  
  If XLSCript_Debug = True Or AR_UseDB = True Then
    If Not m_AllVars Is Nothing Then m_AllVars.Add da
  End If
End Function

Public Function XLScriptAddSimpleVar(n As String, v) As XLScriptSimpleVar
  Dim da As XLScriptSimpleVar
  
  If ObjectNameExists(m_SimpleVars, n) Then
    m_SimpleVars.Remove n
  End If
  
  Set da = New XLScriptSimpleVar
  da.m_Txt = n
  da.m_Value = CStr(v)
  m_SimpleVars.Add da, CStr(n)
  Set XLScriptAddSimpleVar = da

  If XLSCript_Debug = True Or AR_UseDB = True Then
    If Not m_AllVars Is Nothing Then m_AllVars.Add da
  End If
End Function

Public Function XLScriptGetSimpleVar(n As String) As XLScriptSimpleVar
  Set XLScriptGetSimpleVar = Nothing
  On Error Resume Next
  Set XLScriptGetSimpleVar = m_SimpleVars(n)
End Function

Public Function XLScriptGetSimpleVarValue(n As String) As String
  On Error Resume Next
  XLScriptGetSimpleVarValue = m_SimpleVars(n).m_Value
End Function

' Public Sub XLScriptSetValues(c As Collection, ByRef rng As Range)
'   Dim item
'   For Each item In c
'     SetValue rng, item.m_Txt, CStr(item.m_Value)
'   Next item
' End Sub

' Private Sub SetValue(ByRef rng As Range, varTag As String, cellVal As String)
'   On Error GoTo 0
'   Dim c
'   Do
'     Set c = rng.Find(What:="<<" & varTag & ">>", LookIn:=xlValues, LookAt:= _
'           xlPart, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=True)
'     If Not c Is Nothing Then
'       c.Value = MyReplace(c.Value, "<<" & varTag & ">>", cellVal)
'     End If
'   Loop While Not c Is Nothing
'   Do
'     Set c = rng.Find(What:="__" & varTag & "__", LookIn:=xlFormulas, LookAt:= _
'           xlPart, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=True)
'     If Not c Is Nothing Then
'       c.Formula = MyReplace(c.Formula, "__" & varTag & "__", cellVal)
'     End If
'   Loop While Not c Is Nothing
' End Sub

Private Function MyReplace(txt As String, searchtxt As String, replacetxt As String, Optional checkStartAndEnd As Boolean = False, Optional ignoreIn As String = "") As String
  Dim txtPos As Long
  Dim tStringRep As String
  Dim res As String
  Dim ok As Boolean
  MyReplace = txt
  If InStr(txt, searchtxt) = 0 Then Exit Function
  Dim inIgnore As Boolean
  
  inIgnore = False
  
  For txtPos = 1 To Len(txt)
    If Len(ignoreIn) > 0 Then
      If Mid(txt, txtPos, Len(ignoreIn)) = ignoreIn Then
        If Not inIgnore Then
          inIgnore = True
        Else
          inIgnore = False
        End If
      End If
    End If
    
    If Not inIgnore Then
      If Mid(txt, txtPos, Len(searchtxt)) = searchtxt Then
        ok = True
        Dim tval As String
        If checkStartAndEnd Then
          If txtPos > 1 Then
            tval = Mid(txt, txtPos - 1, 1)
            If (tval >= "a" And tval <= "z") Or _
               (tval >= "A" And tval <= "Z") Or _
               (tval >= "0" And tval <= "9") Or _
               tval = "_" Then
                ok = False
            End If
          End If
          If txtPos + Len(searchtxt) <= Len(txt) Then
            tval = Mid(txt, txtPos + Len(searchtxt), 1)
            If (tval >= "a" And tval <= "z") Or _
               (tval >= "A" And tval <= "Z") Or _
               (tval >= "0" And tval <= "9") Or _
               tval = "_" Then
                ok = False
            End If
          End If
        End If
        If ok Then
          res = res + replacetxt
          txtPos = txtPos + Len(searchtxt) - 1
        Else
          res = res + Mid(txt, txtPos, 1)
        End If
      Else
        res = res + Mid(txt, txtPos, 1)
      End If
    Else
      res = res + Mid(txt, txtPos, 1)
    End If
  Next txtPos
  MyReplace = res
End Function

Sub XLScriptCleanUpTags(rng As Range)
'  On Error GoTo 0
  
  Dim c As Range
  Do
    Set c = rng.Find(What:="<!? INSERTLINEABOVE", LookIn:=xlValues, LookAt:= _
      xlPart, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=False)
    If c Is Nothing Then Exit Do
    c.Parent.Rows(c.Row).Delete Shift:=xlUp
  Loop
  
  Do
    Set c = rng.Find(What:="<!? PB", LookIn:=xlValues, LookAt:= _
      xlPart, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=False)
    If c Is Nothing Then Exit Do
    c.Delete Shift:=xlUp
  Loop
End Sub


Function XLScriptExecCode(rng As Range, reclevel As Long, rightoffset As Long) As Long
  Dim addedLines As Long
  addedLines = 0
  
  On Error GoTo 0
  Dim c As Range
  Dim tstring As String
  Dim tleft As String
  Dim tRight As String
  Set c = Nothing
  
  Dim firstC As Range
  Set firstC = Nothing
  Dim nextC As Range
  
  Do
    
'    Cells.Find(What:=m_CodeStart, After:=ActiveCell, LookIn:=xlValues, LookAt:= _
'        xlPart, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=True, _
'        SearchFormat:=False).Activate
    
    If GetRangeCount(rng) = 1 Then
      If InStr(rng.value, m_CodeStart) > 0 Then
        Set c = rng
      Else
        Set c = Nothing
      End If
    Else
      
      ' Erste gefundene Zelle abfragen
      If Not c Is Nothing And IsValid(c) And Not firstC Is Nothing And IsValid(firstC) = True Then
        If firstC.Row = c.Row And firstC.Column = c.Column Then
          Set c = Nothing
        End If
      ElseIf c Is Nothing Or Not IsValid(c) Then
        Set c = rng.Find(What:=m_CodeStart, LookIn:=xlValues, LookAt:= _
            xlPart, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=True)
        ' Erste gefundene Zelle speichern
        If Not c Is Nothing And firstC Is Nothing Then
          Set firstC = c
        End If
      Else
        Exit Do
      End If
    End If
    
    If Not c Is Nothing And IsValid(c) Then
    
      Set nextC = rng.FindNext(c)
        
      Dim pos As Long
      Dim pos2 As Long
      pos = 0
      ' ---------------------------------------------------
      
      Do
        
        If c Is Nothing Then Exit Do
        If Not IsValid(c) Then Exit Do
        
        pos = InStr(pos + 1, c.value, m_CodeStart)
        If pos = 0 Then Exit Do
        
        pos2 = InStr(pos, c.value, "!>")
        
        Dim codeVal As String
        Dim Code As String
        If pos2 > 0 Then
          Code = Mid(c.value, pos + Len(m_CodeStart), pos2 - pos - Len(m_CodeStart))
        Else
          Code = Mid(c.value, pos + Len(m_CodeStart))
        End If
        
        codeVal = Code
        
        Dim newcellval As String
        newcellval = ""
        
        Dim dontdeleteentry As Boolean
        dontdeleteentry = False
        
        Do
          Dim tok As String
          tok = GetToken(codeVal)
          If Len(tok) > 0 Then
            Select Case UCase(tok)
              Case "ADDRIGHT"
                tstring = GetExpression(codeVal, c)
                c.Parent.Cells(c.Row, c.Column + 1).value = _
                  c.Parent.Cells(c.Row, c.Column + 1).value + _
                  Val(MyReplace(tstring, ",", "."))
                  
              Case "INSERTLINEABOVE"
                If firstC.Row = c.Row Then
                  Set firstC = c.Parent.Cells(c.Row + 1, c.Column)
                End If
                m_WS.Rows(c.Row).Insert
                c.value = ""
                Set c = c.Parent.Cells(c.Row + 1, c.Column)
                dontdeleteentry = True
              Case "BACKCOL"
                tstring = GetExpression(codeVal, c)
                
                If IsNumeric(tstring) Then
                  c.Interior.Color = Val(tstring)
                End If
                
              Case "P"
                newcellval = DoPrint(codeVal, c, rightoffset)
              
              Case "PB"
                DoPrintBelow codeVal, c, rightoffset
                dontdeleteentry = True
              
              Case "PRINTBITFIELD"
                DoPrintBitfield codeVal, c
              
              Case "FOR"
                addedLines = addedLines + DoFor(codeVal, c, rng, reclevel + 1)
                If GetSetting(appname:="Stromwerken", Section:="ECC", Key:="AbortAction", default:="") <> "" Then
                  SaveSetting appname:="Stromwerken", Section:="ECC", Key:="AbortAction", setting:=""
                  Beenden = True
                End If
                If Beenden Then Exit Function
              
              Case "LFOR"
                addedLines = addedLines + DoLFor(codeVal, c, rng, reclevel + 1)
                If GetSetting(appname:="Stromwerken", Section:="ECC", Key:="AbortAction", default:="") <> "" Then
                  SaveSetting appname:="Stromwerken", Section:="ECC", Key:="AbortAction", setting:=""
                  Beenden = True
                End If
                If Beenden Then Exit Function
              
              Case "ROWAUTOFIT"
                c.Parent.Cells.EntireRow.AutoFit
              
              Case "COLUMNAUTOFIT"
                c.Parent.Cells.EntireColumn.AutoFit
              
              Case "DEBUG"
                Err.Raise vbObjectError + 1, "XLScript", "DEBUG forced by XLScript"
                Debug.Print "Debug forced"
              
              Case "DIAGDATA"
                addedLines = addedLines - 2
                DoDiagData codeVal, c, rng
              
              Case Else
                XLScriptAddLogEntry "Error: Unknown command '" & tok & "' in '" & Code & "'! " & m_WS.name & "!" & c.Address & " Value: " & c.value
                ' MsgBox "Error: Unknown command '" & tok & "' in '" & code & "'! " & m_WS.name & "!" & c.Address & " Value: " & c.Value, vbCritical, "XLScript"
                ' Beenden = True
                tok = ""
                ' Exit Function
            
            End Select
          End If
        Loop While tok <> ""
        
        ' Und jetzt den neuen Zellwert in die Zelle schreiben
        Dim l As String
        Dim r As String
        
        l = ""
        If pos > 1 Then
          l = Left(c.value, pos - 1)
        End If
        
        r = ""
        If pos2 > 0 Then
          If pos + 2 < Len(c.value) Then
            r = Mid(c.value, pos2 + 2)
          End If
        End If
        
        If dontdeleteentry = False Then
          If Not c Is Nothing Then
            If IsValid(c) Then
          
              If IsNumeric(MyReplace(l & newcellval & r, ",", ".")) Then
                c.value = Val(MyReplace(l & newcellval & r, ",", "."))
              ElseIf IsDate(l & newcellval & r) Then
                c.value = CStr(CDate(l & newcellval & r))
              Else
                c.value = l & newcellval & r
              End If
              pos = Len(l & newcellval) - 1
              If pos < 0 Then pos = 0
            End If
          End If
        End If
      Loop
      
    End If
  
    If Not GetRangeCount(rng) = 1 And Not c Is Nothing Then
      Set c = nextC
    End If
  
  Loop While Not c Is Nothing
  
  XLScriptExecCode = addedLines
End Function

Private Sub OverreadLine(ByRef codeValRet As String)
  On Error GoTo 0
  Dim i As Long
  i = 1
  Do While i < Len(codeValRet) And Mid(codeValRet, i, 1) <> vbCr And Mid(codeValRet, i, 1) <> vbLf
    i = i + 1
  Loop
  Do While i < Len(codeValRet) And (Mid(codeValRet, i, 1) = vbCr Or Mid(codeValRet, i, 1) = vbLf)
    i = i + 1
  Loop
  If i > 1 Then
    codeValRet = Mid(codeValRet, i)
  End If
End Sub

Private Sub OverreadBlanks(ByRef codeValRet As String)
  On Error GoTo 0
  Dim i As Long
  i = 1
  Do While Mid(codeValRet, i, 1) = " " Or Mid(codeValRet, i, 1) = vbCr Or Mid(codeValRet, i, 1) = vbLf
    i = i + 1
  Loop
  If i > 1 Then
    codeValRet = Mid(codeValRet, i)
  End If
End Sub

Private Sub GetComma(ByRef codeValRet As String, ByRef c As Range)
  On Error GoTo 0
  OverreadBlanks codeValRet
  If Left(codeValRet, 1) <> "," Then
    XLScriptAddLogEntry "Error: Missing comma! " & m_WS.name & "!" & c.Address & " Value: " & c.value
  End If
  codeValRet = Mid(codeValRet, 2)
End Sub

Private Function GetDef(ByRef codeValRet As String, ByRef c As Range) As xlFld
  On Error GoTo 0
  OverreadBlanks codeValRet
  
  Dim tok As String
  tok = GetToken(codeValRet)
  
  Dim item As xlFld
  For Each item In m_Flds
    If item.m_Name = tok Then
      Set GetDef = item
      Exit Function
    End If
  Next item
  
  XLScriptAddLogEntry "Error: Undefined Def '" & tok & "'! " & m_WS.name & "!" & c.Address & " Value: " & c.value
End Function

Private Function GetNumber(ByRef codeValRet As String) As String
  On Error GoTo 0
  Dim token As String
  Dim i As Long
  i = 0
  OverreadBlanks codeValRet
  
  Do While ((Mid(codeValRet, i + 1, 1) >= "0" And Mid(codeValRet, i + 1, 1) <= "9") Or _
    (Mid(codeValRet, i + 1, 1) = ".")) And i < Len(codeValRet)
    i = i + 1
  Loop
  If i > 0 Then
    token = Left(codeValRet, i)
    codeValRet = Mid(codeValRet, i + 1)
    OverreadBlanks codeValRet
  End If
  
  GetNumber = token
End Function

Private Function GetLine(ByRef codeValRet As String) As String
  On Error GoTo 0
  OverreadBlanks codeValRet
  Dim i As Long
  i = 0
  Do While i < Len(codeValRet) - 1 And Mid(codeValRet, i + 1, 1) <> vbCr And Mid(codeValRet, i + 1, 1) <> vbLf
    i = i + 1
  Loop
  If i > 0 Then
    GetLine = Left(codeValRet, i)
    codeValRet = Mid(codeValRet, i + 1)
  End If
End Function

Private Function GetNextChar(ByRef codeValRet As String) As String
  On Error GoTo 0
  OverreadBlanks codeValRet
  If Len(codeValRet) > 0 Then
    GetNextChar = Left(codeValRet, 1)
    codeValRet = Mid(codeValRet, 2)
  End If
End Function

Function GetString(ByRef codeValRet As String) As String
  On Error GoTo 0
  Dim token As String
  Dim i As Long
  i = 0
  OverreadBlanks codeValRet
  If Left(codeValRet, 1) = Chr(34) Then
    codeValRet = Mid(codeValRet, 2)
    Do While Mid(codeValRet, i + 1, 1) <> Chr(34) And i < Len(codeValRet)
      i = i + 1
    Loop
    If i > 0 Then
      token = Left(codeValRet, i)
      codeValRet = Mid(codeValRet, i + 1)
      If Left(codeValRet, 1) = Chr(34) Then
        codeValRet = Mid(codeValRet, 2)
      End If
      OverreadBlanks codeValRet
    End If
  End If
  
  GetString = token
End Function


Private Function GetToken(ByRef codeValRet As String) As String
  On Error GoTo 0
  Dim token As String
  Dim i As Long
  i = 0
  OverreadBlanks codeValRet
  If Left(codeValRet, 1) = Chr(34) Then
    codeValRet = Mid(codeValRet, 2)
    Do While Mid(codeValRet, i + 1, 1) <> Chr(34) And i < Len(codeValRet)
      i = i + 1
    Loop
    If i > 0 Then
      token = Left(codeValRet, i)
      codeValRet = Mid(codeValRet, i + 1)
      If Left(codeValRet, 1) = Chr(34) Then
        codeValRet = Mid(codeValRet, 2)
      End If
      OverreadBlanks codeValRet
    End If
  Else
    If ((Mid(codeValRet, i + 1, 1) >= "a" And Mid(codeValRet, i + 1, 1) <= "z") Or _
      (Mid(codeValRet, i + 1, 1) >= "A" And Mid(codeValRet, i + 1, 1) <= "Z")) And i < Len(codeValRet) Then
      Do While ((Mid(codeValRet, i + 1, 1) >= "a" And Mid(codeValRet, i + 1, 1) <= "z") Or _
        (Mid(codeValRet, i + 1, 1) >= "A" And Mid(codeValRet, i + 1, 1) <= "Z") Or _
        (Mid(codeValRet, i + 1, 1) >= "0" And Mid(codeValRet, i + 1, 1) <= "9") Or _
         Mid(codeValRet, i + 1, 1) = "_" Or _
         Mid(codeValRet, i + 1, 1) = "|fffd|" Or _
         Mid(codeValRet, i + 1, 1) = "|fffd|" Or _
         Mid(codeValRet, i + 1, 1) = "|fffd|" Or _
         Mid(codeValRet, i + 1, 1) = "|fffd|" Or _
         Mid(codeValRet, i + 1, 1) = "|fffd|" Or _
         Mid(codeValRet, i + 1, 1) = "|fffd|" Or _
         Mid(codeValRet, i + 1, 1) = "|fffd|" _
         ) And i < Len(codeValRet)
        i = i + 1
      Loop
      If i > 0 Then
        token = Left(codeValRet, i)
        codeValRet = Mid(codeValRet, i + 1)
        OverreadBlanks codeValRet
      End If
    Else
      token = GetNextChar(codeValRet)
    End If
  End If
  
  GetToken = token
End Function

Private Function DoPrint(ByRef codeValRet As String, ByRef c As Range, Optional rightoffset As Long = 0) As String
  On Error GoTo 0
  Dim res As String
  m_InPrint = True
  
  CheckSubParams codeValRet, c
  
  res = GetExpression(codeValRet, c)
  m_InPrint = False
  If res = "" Then
    DoPrint = "'-/-"
'    c.Parent.Cells(c.Row, c.Column + rightoffset).Value = "'-/-"
'    XLScriptAddLogEntry "Error: PRINT missing expression! " & m_WS.name & "!" & c.Address & " Value: " & c.Value
    Exit Function
  End If
  
  DoPrint = res
'  c.Parent.Cells(c.Row, c.Column + rightoffset).Value = res
End Function

Private Sub DoPrintBelow(ByRef codeValRet As String, ByRef c As Range, Optional rightoffset As Long = 0)
  On Error GoTo 0
  Dim res As String
  
  Dim y As Long
  y = c.Row + 1
  Do While Not IsEmpty(m_WS.Cells(y, c.Column))
    y = y + 50
  Loop
  
  If y > 1 Then
    Do While IsEmpty(m_WS.Cells(y, c.Column))
      y = y - 1
    Loop
    y = y + 1
  End If
  
'  Debug.Print codeValRet
  CheckSubParams codeValRet, m_WS.Cells(y, c.Column)
  
  res = GetExpression(codeValRet, c)
  
  If res = "" Then
    m_WS.Cells(y, c.Column).value = "'-/-"
    Exit Sub
  End If
  
  If IsFullyNumeric(MyReplace(res, ",", ".")) Then
    m_WS.Cells(y, c.Column).value = Val(MyReplace(res, ",", "."))
  Else
    m_WS.Cells(y, c.Column).value = res
  End If
'  m_WS.Cells(y, c.Column).NumberFormat = c.NumberFormat
'  m_WS.Cells(y, c.Column).Interior.Color = c.Interior.Color
'  m_WS.Cells(y, c.Column).Font.Color = c.Font.Color
End Sub

Sub CheckSubParams(ByRef codeValRet As String, ByRef c As Range)
  Dim s As String
  If Left(codeValRet, 1) <> "(" Then Exit Sub
  codeValRet = Mid(codeValRet, 2)
  s = GetToken(codeValRet)
  Select Case s
    Case "BC"
      If Left(codeValRet, 1) <> ":" Then
        XLScriptAddLogEntry "BC must be followed by ':' in " & m_WS.name & "!" & c.Address & " Value: " & c.value
        Exit Sub
      End If
      codeValRet = Mid(codeValRet, 2)
      s = GetExpression(codeValRet, c)
      If IsNumeric(s) Then
        c.Interior.Color = Val(s)
      Else
        c.Interior.Color = RGB(255, 255, 255)
      End If
      If Left(codeValRet, 1) <> ")" Then
        XLScriptAddLogEntry "Sub param must be followed by ')' or ';' in " & m_WS.name & "!" & c.Address & " Value: " & c.value
        Exit Sub
      End If
      codeValRet = Mid(codeValRet, 2)
      OverreadBlanks codeValRet
  End Select
End Sub


Private Sub DoPrintBitfield(ByRef codeValRet As String, ByRef c As Range)
  On Error GoTo 0
  Dim res As String
  Dim tCodeValRet As String
  tCodeValRet = codeValRet
  res = GetExpression(codeValRet, c)
  
  If res = "" Then
    XLScriptAddLogEntry "Error: Expression not found (" & tCodeValRet & ")! " & m_WS.name & "!" & c.Address & " Value: " & c.value
  End If
  GetComma codeValRet, c
  
  Dim f As xlFld
  Set f = GetDef(codeValRet, c)
  GetComma codeValRet, c
  
  Dim sep As String
  sep = GetExpression(codeValRet, c)
  
  Dim onlyExistant As Boolean
  onlyExistant = True
  
  Dim foundone As Boolean
  foundone = False
  c.value = ""
  Dim item As XLFldVal
  
  Dim cnt As Long
  Dim x As Long
  Dim rv As String
  Dim first As Boolean
  first = False
  x = &H80000000
  
  If Not onlyExistant Then
    c.value = "0x" & Hex(CLng(res)) & " (" & res & ")"
  End If
  
  Dim i As Long
  
  For cnt = 1 To 32
    If (res And x) <> 0 Then
    
      foundone = False
      For Each item In f.m_Col
        If x = item.m_Value Then
          foundone = True
          If Len(c.value) > 0 Then
            For i = 1 To Len(sep)
              If Mid(sep, i, 1) = "n" Then
                c.value = c.value & vbLf
              Else
                c.value = c.value & Mid(sep, i, 1)
              End If
            Next i
          End If
          
          If onlyExistant Then
            c.value = c.value & item.m_Txt
          Else
            c.value = c.value & "0x" & Hex(item.m_Value) & " - " & item.m_Txt
          End If
          
        End If
      Next item
      
      If Not onlyExistant Then
        If Not foundone Then
          If Len(c.value) > 0 Then
            For i = 1 To Len(sep)
              If Mid(sep, i, 1) = "n" Then
                c.value = c.value & vbLf
              Else
                c.value = c.value & Mid(sep, i, 1)
              End If
            Next i
          End If
          
          c.value = c.value & "0x" & Hex(x) & " - ???"
        End If
      End If
    End If
    x = x / 2
    If x < 0 Then x = x * (-1)
  Next cnt
  If Len(c.value) = 0 Then
   c.value = "'-"
  End If
'  If Not foundOne Then c.Value = res
End Sub

Private Function ValToBin(v As Long) As String
  Dim i As Long
  Dim x As Long
  Dim rv As String
  Dim first As Boolean
  first = True
  x = &H80000000
  rv = "b"
  For i = 1 To 32
    If (v And x) <> 0 Then
      first = False
      rv = rv & "1"
    Else
      If Not first Then
        rv = rv & "0"
      End If
    End If
    x = x / 2
    If x < 0 Then x = x * (-1)
  Next i
  If first Then
    rv = "b0"
  End If
  ValToBin = rv
End Function

Private Function DoFor(ByRef codeValRet As String, ByRef c As Range, rng As Range, reclevel As Long) As Long
  
  DoFor = 0
  On Error GoTo 0
  Dim tok As String
  tok = GetToken(codeValRet)
  
'  If c.Value = "<! FOR EACH item IN FuncAm" Then
'    Debug.Print "gaga"
'  End If
  

'  If c.Value = "<! FOR EACH subitem IN item.items WIDTH 4" Then
'    Debug.Print "gaga"
'  End If
  
  If UCase(tok) <> "EACH" Then
    XLScriptAddLogEntry "Error: EACH expected! " & m_WS.name & "!" & c.Address & " Value: " & c.value
    Exit Function
  End If
  
  Dim res As String
  res = GetVarName(codeValRet, c)
  If res = "" Then
    c.value = "'-/-"
'    XLScriptAddLogEntry "Error: PRINT missing expression! " & m_WS.name & "!" & c.Address & " Value: " & c.Value
    Exit Function
  End If
  
  tok = GetToken(codeValRet)
  If UCase(tok) <> "IN" Then
    XLScriptAddLogEntry "Error: IN expected! " & m_WS.name & "!" & c.Address & " Value: " & c.value
    Exit Function
  End If
  
  Dim ref
  m_InPrint = True
  Set ref = GetRef(codeValRet, c)
  m_InPrint = False
  
  Dim widthAm As Long
  widthAm = 1
  tok = GetToken(codeValRet)
  If UCase(tok) = "WIDTH" Then
    tok = GetNumber(codeValRet)
    If Not IsNumeric(tok) Then
      XLScriptAddLogEntry "Error: WIDTH must be followed by numeric value! " & m_WS.name & "!" & c.Address & " Value: " & c.value
    Else
      widthAm = CLng(tok)
    End If
  End If
  
  
  ' OK, jetzt das Ende des FOR Befehls suchen
  Dim cEnd As Range
  Set cEnd = rng.Find(What:=m_CodeStart & "NEXT " & res, LookIn:=xlValues, LookAt:= _
        xlWhole, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=False)
  
  If cEnd Is Nothing Then
    XLScriptAddLogEntry "Error: FOR EACH missing NEXT! " & m_WS.name & "!" & c.Address & " Value: " & c.value
  End If
  
  Dim forwidth As Long
  forwidth = cEnd.Column - c.Column + 1
  Dim forheight As Long
  forheight = cEnd.Row - c.Row + 1 - 2
  If CountReadable(ref) Then
  
    Dim fn As XLForNext
    Set fn = New XLForNext
    fn.m_Name = res
    Set fn.m_Ref = ref
    fn.m_Current = 1
    fn.m_Width = widthAm
    fn.m_WidthCurrent = 0
    m_FN.Add fn
    
    ' Ok, kopieren, dann exec
    
    Dim cnt As Long
    
    Dim addedLines As Long
    addedLines = 0
    Dim maxAddLines As Long
    maxAddLines = -10000
    
    If reclevel = 1 Then MyLastTime = Now
    
    If ref.count > 0 Then
      For cnt = 1 To ref.count
      
        fn.m_Current = cnt - 1 + GetCollectionStart(fn.m_Ref)
        
        If reclevel = 1 Then
          If MyLastTime + TimeValue("0:00:02") < Now Then
            'UpdateStatus ("Generiere Ergebnisbl|fffd|tter (" & m_WS.name & ") - " & fn.m_Current & " / " & ref.count)
            Call UpdateStatus(FMT3("XLSCRIPT_4", m_WS.name, fn.m_Current, ref.count))
            MyLastTime = Now
          End If
          If GetSetting(appname:="Stromwerken", Section:="ECC", Key:="AbortAction", default:="") <> "" Then
            SaveSetting appname:="Stromwerken", Section:="ECC", Key:="AbortAction", setting:=""
            Beenden = True
          End If
          If Beenden Then Exit Function
        End If
        
        If fn.m_WidthCurrent = 0 Then
          m_WS.Range(m_WS.Cells(cEnd.Row + 1 + addedLines, c.Column), _
                m_WS.Cells(cEnd.Row + 1 + addedLines + forheight - 1, c.Column + forwidth * widthAm - 1)).Insert Shift:=xlDown
          maxAddLines = -10000
        End If
        
        m_WS.Range(m_WS.Cells(c.Row + 1, c.Column), m_WS.Cells(cEnd.Row - 1, cEnd.Column)).Copy
        m_WS.Cells(cEnd.Row + 1 + addedLines, c.Column + fn.m_WidthCurrent * forwidth).PasteSpecial xlPasteAll
        
        Dim newlines As Long
        newlines = XLScriptExecCode(m_WS.Range(m_WS.Cells(cEnd.Row + 1 + addedLines, c.Column + fn.m_WidthCurrent * forwidth), m_WS.Cells(cEnd.Row + 1 + addedLines + cEnd.Row - c.Row - 2, cEnd.Column + fn.m_WidthCurrent * forwidth)), reclevel + 1, fn.m_WidthCurrent)
        If newlines > maxAddLines Then
          maxAddLines = newlines
        End If
        
        fn.m_WidthCurrent = fn.m_WidthCurrent + 1
        
        If fn.m_WidthCurrent = fn.m_Width Then
          addedLines = addedLines + maxAddLines
          addedLines = addedLines + cEnd.Row - c.Row - 1
          fn.m_WidthCurrent = 0
        End If
      Next cnt
    
      If fn.m_WidthCurrent > 0 Then
        addedLines = addedLines + maxAddLines
        addedLines = addedLines + cEnd.Row - c.Row - 1
      End If
    Else
    
      m_WS.Range(m_WS.Cells(cEnd.Row + 1, c.Column), _
            m_WS.Cells(cEnd.Row + 1 + forheight - 1, c.Column + forwidth * widthAm - 1)).Insert Shift:=xlDown
      m_WS.Cells(cEnd.Row + 1, c.Column) = "'-/-"
      addedLines = 1
    End If
    
    cnt = 1
    Dim item As XLForNext
    For Each item In m_FN
      If item.m_Name = fn.m_Name Then
        m_FN.Remove cnt
        Exit For
      End If
      cnt = cnt + 1
    Next item
  
  Else
  
    m_WS.Range(m_WS.Cells(cEnd.Row + 1, c.Column), _
          m_WS.Cells(cEnd.Row + 1 + forheight - 1, c.Column + forwidth * widthAm - 1)).Insert Shift:=xlDown
    m_WS.Cells(cEnd.Row + 1, c.Column) = "'-/-"
    addedLines = 1
  End If
  
  addedLines = addedLines - (cEnd.Row - c.Row + 1)
  m_WS.Range(m_WS.Cells(c.Row, c.Column), m_WS.Cells(cEnd.Row, c.Column + forwidth * widthAm - 1)).Delete Shift:=xlUp
  
  
  DoFor = addedLines
End Function

Private Function DoLFor(ByRef codeValRet As String, ByRef c As Range, rng As Range, reclevel As Long) As Long
  
  DoLFor = 0
  On Error GoTo 0
  Dim tok As String
  tok = GetToken(codeValRet)
  
'  If c.Value = "<! FOR EACH item IN FuncAm" Then
'    Debug.Print "gaga"
'  End If
  

'  If c.Value = "<! FOR EACH subitem IN item.items WIDTH 4" Then
'    Debug.Print "gaga"
'  End If
  
  If UCase(tok) <> "EACH" Then
    XLScriptAddLogEntry "Error: EACH expected! " & m_WS.name & "!" & c.Address & " Value: " & c.value
    Exit Function
  End If
  
  Dim res As String
  res = GetVarName(codeValRet, c)
  If res = "" Then
    c.value = "'-/-"
'    XLScriptAddLogEntry "Error: PRINT missing expression! " & m_WS.name & "!" & c.Address & " Value: " & c.Value
    Exit Function
  End If
  
  tok = GetToken(codeValRet)
  If UCase(tok) <> "IN" Then
    XLScriptAddLogEntry "Error: IN expected! " & m_WS.name & "!" & c.Address & " Value: " & c.value
    Exit Function
  End If
  
  Dim ref
  m_InPrint = True
  Set ref = GetRef(codeValRet, c)
  m_InPrint = False
  
  Dim widthAm As Long
  widthAm = 1
  tok = GetToken(codeValRet)
  If UCase(tok) = "WIDTH" Then
    tok = GetNumber(codeValRet)
    If Not IsNumeric(tok) Then
      XLScriptAddLogEntry "Error: WIDTH must be followed by numeric value! " & m_WS.name & "!" & c.Address & " Value: " & c.value
    Else
      widthAm = CLng(tok)
    End If
  End If
  
  
  ' OK, jetzt das Ende des FOR Befehls suchen
  Dim cEnd As Range
  Set cEnd = rng.Find(What:=m_CodeStart & "LNEXT " & res, LookIn:=xlValues, LookAt:= _
        xlWhole, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=False)
  
  If cEnd Is Nothing Then
    XLScriptAddLogEntry "Error: FOR EACH missing NEXT! " & m_WS.name & "!" & c.Address & " Value: " & c.value
  End If
  
  Dim forwidth As Long
  forwidth = cEnd.Column - c.Column + 1
  Dim forheight As Long
  forheight = cEnd.Row - c.Row + 1 - 2
  
  
  If CountReadable(ref) Then
  
    Dim fn As XLForNext
    Set fn = New XLForNext
    fn.m_Name = res
    Set fn.m_Ref = ref
    fn.m_Current = 1
    fn.m_Width = widthAm
    fn.m_WidthCurrent = 0
    m_FN.Add fn
    
    ' Ok, kopieren, dann exec
    
    Dim cnt As Long
    
    Dim addedLines As Long
    addedLines = 0
    Dim maxAddLines As Long
    maxAddLines = -10000
    
    If reclevel = 1 Then MyLastTime = Now
    
    
    If ref.count > 0 Then
    
      Dim lforlines As Long
      lforlines = CLng(ref.count / widthAm) + IIf(ref.count Mod widthAm = 0, 0, 1)
      
      Dim wasCut As Boolean
      wasCut = False
      
      If cEnd.Row + 1 + lforlines - 1 > 65000 Then
        lforlines = 10
        wasCut = True
      End If
      
      m_WS.Range(m_WS.Cells(cEnd.Row + 1, c.Column), _
            m_WS.Cells(cEnd.Row + 1 + lforlines - 1, c.Column + forwidth * widthAm - 1)).Insert Shift:=xlDown
      m_WS.Range(m_WS.Cells(c.Row + 1, c.Column), m_WS.Cells(cEnd.Row - 1, cEnd.Column)).Copy
      m_WS.Range(m_WS.Cells(cEnd.Row + 1, c.Column), m_WS.Cells(cEnd.Row + 1 + lforlines - 1, c.Column + forwidth * widthAm - 1)).PasteSpecial xlPasteAll
      
      cnt = 1
      Dim lforam As Long
      lforam = lforlines * widthAm
      
      Dim printvals As New Collection
      Dim tc As Range
      Dim xlf As LForItem
      For Each tc In m_WS.Range(m_WS.Cells(c.Row + 1, c.Column), m_WS.Cells(cEnd.Row - 1, cEnd.Column))
        ' F<!1 P item.FNCOUNT
        Dim tPos As Long
        Dim tleft As String
        tPos = InStr(tc.value, m_CodeStart & "P " & res)
        If tPos > 0 Then
          Set xlf = New LForItem
          xlf.m_Prefix = ""
          If tPos > 1 Then
            xlf.m_Prefix = Left(tc.value, tPos - 1)
          End If
          xlf.m_Val = Mid(tc.value, tPos + Len(m_CodeStart & "P " & res & "."))
          xlf.m_X = tc.Column - c.Column
          xlf.m_Y = tc.Row - c.Row - 1
          printvals.Add xlf
          
        End If
      Next tc
      
      
      
      For cnt = 1 To lforam
      
        fn.m_Current = cnt - 1 + GetCollectionStart(fn.m_Ref)
        
        If reclevel = 1 Then
          If MyLastTime + TimeValue("0:00:02") < Now Then
            'UpdateStatus ("Generiere Ergebnisbl|fffd|tter (" & m_WS.name & ") - " & fn.m_Current & " / " & ref.count)
            Call UpdateStatus(FMT3("XLSCRIPT_4", m_WS.name, fn.m_Current, ref.count))
            MyLastTime = Now
          End If
          If GetSetting(appname:="Stromwerken", Section:="ECC", Key:="AbortAction", default:="") <> "" Then
            SaveSetting appname:="Stromwerken", Section:="ECC", Key:="AbortAction", setting:=""
            Beenden = True
          End If
          If Beenden Then Exit Function
        End If
        
        Dim newlines As Long
        
        maxAddLines = 0
        If wasCut = True And cnt = lforam Then
          For Each xlf In printvals
            m_WS.Cells(cEnd.Row + 1 + addedLines + xlf.m_Y, c.Column + fn.m_WidthCurrent * forwidth + xlf.m_X).value = "[...]"
          Next xlf
        ElseIf cnt > ref.count Then
          For Each xlf In printvals
            m_WS.Cells(cEnd.Row + 1 + addedLines + xlf.m_Y, c.Column + fn.m_WidthCurrent * forwidth + xlf.m_X).value = ""
          Next xlf
        Else
'          newlines = XLScriptExecCode(m_WS.Range(m_WS.Cells(cEnd.Row + 1 + addedLines, c.Column + fn.m_WidthCurrent * forwidth), m_WS.Cells(cEnd.Row + 1 + addedLines + cEnd.Row - c.Row - 2, cEnd.Column + fn.m_WidthCurrent * forwidth)), reclevel + 1, fn.m_WidthCurrent)
          For Each xlf In printvals
          
            Dim tstring As String
            tstring = xlf.m_Val
            Set tc = m_WS.Cells(cEnd.Row + 1 + addedLines + xlf.m_Y, c.Column + fn.m_WidthCurrent * forwidth + xlf.m_X)
            If tstring = "" Then
              tc.value = xlf.m_Prefix & ref(cnt)
            ElseIf tstring = "FNCOUNT" Then
              tc.value = xlf.m_Prefix & cnt
            Else
              If VarValueExists(ref(cnt), tstring) Then
                tc.value = xlf.m_Prefix & ref(cnt)(tstring)
              End If
            End If
          Next xlf
        End If
        
        fn.m_WidthCurrent = fn.m_WidthCurrent + 1
        
        If fn.m_WidthCurrent = fn.m_Width Then
          addedLines = addedLines + maxAddLines
          addedLines = addedLines + cEnd.Row - c.Row - 1
          fn.m_WidthCurrent = 0
        End If
      Next cnt
    
      If fn.m_WidthCurrent > 0 Then
        addedLines = addedLines + maxAddLines
        addedLines = addedLines + cEnd.Row - c.Row - 1
      End If
    Else
    
      m_WS.Range(m_WS.Cells(cEnd.Row + 1, c.Column), _
            m_WS.Cells(cEnd.Row + 1 + forheight - 1, c.Column + forwidth * widthAm - 1)).Insert Shift:=xlDown
      m_WS.Cells(cEnd.Row + 1, c.Column) = "'-/-"
      addedLines = 1
    End If
    
    cnt = 1
    Dim item As XLForNext
    For Each item In m_FN
      If item.m_Name = fn.m_Name Then
        m_FN.Remove cnt
        Exit For
      End If
      cnt = cnt + 1
    Next item
  
  Else
  
    m_WS.Range(m_WS.Cells(cEnd.Row + 1, c.Column), _
          m_WS.Cells(cEnd.Row + 1 + forheight - 1, c.Column + forwidth * widthAm - 1)).Insert Shift:=xlDown
    m_WS.Cells(cEnd.Row + 1, c.Column) = "'-/-"
    addedLines = 1
  End If
  
  addedLines = addedLines - (cEnd.Row - c.Row + 1)
  m_WS.Range(m_WS.Cells(c.Row, c.Column), m_WS.Cells(cEnd.Row, c.Column + forwidth * widthAm - 1)).Delete Shift:=xlUp
  
  
  DoLFor = addedLines
End Function


Private Sub DoDiagData(ByRef codeValRet As String, ByRef c As Range, rng As Range)
  
  On Error GoTo 0
  
  Dim endofline As String
  endofline = codeValRet
  Dim tok As String
  tok = GetToken(codeValRet)
  
  ' OK, jetzt das Ende des DIAGDATA Befehls suchen
  Dim cEnd As Range
  Set cEnd = rng.Find(What:=m_CodeStart & "DIAGDATAEND " & endofline, LookIn:=xlValues, LookAt:= _
        xlPart, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=False)
  
  If cEnd Is Nothing Then
    XLScriptAddLogEntry "Error: DIAGDATA " & tok & " missing DIAGDATAEND " & tok & "! " & m_WS.name & "!" & c.Address & " Value: " & c.value
    c.EntireRow.Delete
    Exit Sub
  End If
  
  Dim coitem As ChartObject
  Dim cgitem As ChartGroup
  Dim scitem As Series
  If m_WS.ChartObjects.count > 0 Then
    For Each coitem In m_WS.ChartObjects
      If UCase(coitem.name) = UCase(tok) Then
        For Each cgitem In coitem.Chart.ChartGroups
          Set scitem = cgitem.SeriesCollection(1)
'          If IsReadableFormula(scitem) Then
            scitem.Formula = "=SERIES(," & m_WS.name & "!" & m_WS.Cells(c.Row + 1, c.Column).Address & _
              ":" & m_WS.Cells(cEnd.Row - 1, c.Column).Address & _
              "," & m_WS.name & "!" & m_WS.Cells(c.Row + 1, cEnd.Column).Address & ":" & _
              m_WS.Cells(cEnd.Row - 1, cEnd.Column).Address & ",1)"
'          End If
        Next cgitem
      End If
    Next coitem
  End If
  
  cEnd.EntireRow.Delete
  c.EntireRow.Delete
  
End Sub


Private Function GetCollectionStart(c)
  On Error GoTo start1
  If IsObject(c(0)) Then
  End If
  GetCollectionStart = 0
  Exit Function
start1:
  GetCollectionStart = 1
End Function

Private Function GetExpression(ByRef codeValRet As String, c As Range) As String
  Dim pos As Long
  On Error GoTo 0
  OverreadBlanks codeValRet
  ' Summe auf eine Variable eines Arrays bilden
  If UCase(Left(codeValRet, 4)) = "SUM " Then
    codeValRet = Mid(codeValRet, 4)
    Dim ref
    Set ref = GetRef(codeValRet, c)
    GetComma codeValRet, c
      Dim tok As String
    tok = GetToken(codeValRet)
    If Not ref Is Nothing Then
      Dim item
      Dim s As Long
      s = 0
      For Each item In ref
        If PropertyNameExists(item, tok) Then
          s = s + CLng(item.Properties(UCase(tok)))
        Else
          XLScriptAddLogEntry "Warning: Variable '" & tok & "' not existant! " & m_WS.name & "!" & c.Address & " Value: " & c.value
        End If
      Next item
      GetExpression = s
      Exit Function
    End If
'  ElseIf Left(codeValRet, 1) >= "0" And Left(codeValRet, 1) <= "9" Then
  ElseIf (Left(codeValRet, 1) >= "a" And Left(codeValRet, 1) <= "z") Or (Left(codeValRet, 1) >= "A" And Left(codeValRet, 1) <= "Z") Then
    GetExpression = XLScriptGetVarValue(codeValRet, c)
    Exit Function
  ElseIf (Left(codeValRet, 1) = "*") Then
    pos = InStr(codeValRet, ")")
    If pos > 0 Then
      Dim endstr As String
      endstr = Mid(codeValRet, 2, pos - 2)
      Dim tp As String
      tp = Mid(codeValRet, pos + 1) & endstr
      GetExpression = GetExpression(tp, c)
      codeValRet = Mid(codeValRet, pos)
    End If
    Exit Function
  ElseIf Left(codeValRet, 1) = Chr(34) Then
    pos = InStr(2, codeValRet, Chr(34))
    If pos > 0 Then
      GetExpression = Mid(codeValRet, 2, pos - 2)
      codeValRet = Mid(codeValRet, pos + 1)
      Exit Function
    Else
      XLScriptAddLogEntry "Error: " & Chr(22) & " missing! " & m_WS.name & "!" & c.Address & " Value: " & c.value
    End If
  End If
End Function

Private Function GetVarName(ByRef codeValRet As String, ByRef c As Range) As String
  On Error GoTo 0
  Dim tok As String
  Dim res As String
  tok = GetToken(codeValRet)
  If Len(tok) > 0 Then
    If Left(tok, 1) >= "a" Or Left(tok, 1) <= "z" Or Left(tok, 1) >= "A" Or Left(tok, 1) <= "Z" Then
      GetVarName = tok
      Exit Function
    End If
  End If
  XLScriptAddLogEntry "Error: '" & tok & "' is not a variable name! " & m_WS.name & "!" & c.Address & " Value: " & c.value
End Function

Function XLScriptGetVarValue(ByRef codeValRet As String, c As Range) As String
  On Error GoTo 0
  Dim tok As String
  Dim res As String
  Dim wasdot As Boolean
  wasdot = False
  
  Dim goitem As XLScriptGlobalObject
  
  tok = GetToken(codeValRet)
  If Len(tok) > 0 Then
  
    If Left(codeValRet, 1) = "." Then
      codeValRet = Mid(codeValRet, 2)
      wasdot = True
    End If
    
    Select Case UCase(tok)
   
'      Case "DB"
'        res = XLScriptGetDBVarValue(codeValRet, m_DB, c)
'      Case "WS"
'        res = XLScriptGetDBVarValue(codeValRet, m_Workspace, c)
'      Case "APP"
'        res = XLScriptGetDBVarValue(codeValRet, m_App, c)
      Case "XL"
        res = XLScriptGetDBVarValue(codeValRet, m_Excel, c)
      Case "XLWB"
        res = XLScriptGetDBVarValue(codeValRet, m_Workbook, c)
      Case Else
    
        Dim found As Boolean
        found = False
        
        For Each goitem In m_GlobalObjects
          If UCase(goitem.m_Name) = UCase(tok) Then
            res = XLScriptGetDBVarValue(codeValRet, goitem.m_Object, c)
            found = True
            Exit For
          End If
        Next goitem
        
        If Not found Then
          Dim item As XLForNext
          For Each item In m_FN
            If UCase(item.m_Name) = UCase(tok) Then
              res = XLScriptGetDBVarValue(codeValRet, item.m_Ref(item.m_Current), c, item)
'              If m_InPrint = True And XLSCript_Debug = True Then
'                item.m_Ref(item.m_Current).m_WasPrinted = True
'              End If
              found = True
              Exit For
            End If
          Next item
        End If
        
        ' Dann wollen wir doch mal nach "normalen" VariablenArrays schauen, die das Programm ermittelt hat
        If Not found Then
          Dim vaitem2d As XLScriptArray2D
          For Each vaitem2d In m_VarArray2D
            If UCase(vaitem2d.Properties("NAME")) = UCase(tok) Then
              
              res = XLScriptGetDBVarValue(codeValRet, vaitem2d.items, c, vaitem2d)
              
              If m_InPrint = True And XLSCript_Debug = True Then
                vaitem2d.m_WasPrinted = True
              End If
'              If wasdot Then
'                Set res = vaitem2d.items(codeValRet).items
'              End If
              found = True
              Exit For
            End If
          Next vaitem2d
        End If
        
            
        If Not found Then
          Dim svitem As XLScriptSimpleVar
          For Each svitem In m_SimpleVars
            If UCase(svitem.m_Txt) = UCase(tok) Then
              res = svitem.m_Value
              If m_InPrint = True And XLSCript_Debug = True Then
                svitem.m_WasPrinted = True
              End If
              found = True
              Exit For
            End If
          Next svitem
        End If
        
        
        If Not found Then
          Dim vaitem As XLScriptArray
          For Each vaitem In m_VarArray
            If UCase(vaitem.Properties("NAME")) = UCase(tok) Then
              res = XLScriptGetDBVarValue(codeValRet, vaitem.items, c, vaitem)
              If m_InPrint = True And XLSCript_Debug = True Then
                vaitem.m_WasPrinted = True
              End If
              found = True
              Exit For
            End If
          Next vaitem
        End If
        
        
        If Not found Then
          
          If IsValid(c) Then
            XLScriptAddLogEntry "Error: '" & tok & "' is not a variable name! " & m_WS.name & "!" & c.Address & " Value: " & c.value
          Else
            XLScriptAddLogEntry "Error: '" & tok & "' is not a variable name!"
          End If
        
          Do While wasdot
            wasdot = False
            tok = GetToken(codeValRet)
            If Len(tok) > 0 Then
              If Left(codeValRet, 1) = "." Then
                codeValRet = Mid(codeValRet, 2)
                wasdot = True
              End If
            
            End If
            
          Loop
        End If
    End Select
  End If
  XLScriptGetVarValue = res
End Function

Function XLScriptGetDBVarValue(ByRef codeValRet As String, par, c As Range, Optional obj = Nothing) As String
  On Error GoTo getError
  
  If Len(codeValRet) = 0 Or _
    (Left(codeValRet, 1) <> "." And _
    Not ((Left(codeValRet, 1) >= "a" And Left(codeValRet, 1) <= "z") Or (Left(codeValRet, 1) >= "A" And Left(codeValRet, 1) <= "Z"))) Then
    XLScriptGetDBVarValue = par
    Exit Function
  End If
  
  Dim tok As String
  Dim res As String
  
'  If Left(codeValRet, 1) = "(" Then
'    codeValRet = Mid(codeValRet, 2)
'    res = GetExpression(codeValRet, c)
  
'    If Not Left(codeValRet, 1) = ")" Then
'      XLScriptAddLogEntry "Error: '" & tok & "(' is missing ')'! " & m_WS.name & "!" & c.Address & " Value: " & c.Value
'    End If
    
  
  tok = GetToken(codeValRet)
  Dim wasdot As Long
  wasdot = False
  If Len(tok) > 0 Then
    If Left(codeValRet, 1) = "." Then
      codeValRet = Mid(codeValRet, 2)
      wasdot = True
    End If
    
    If VarValueExists(par, tok) Then
      res = par(tok)
    ElseIf wasdot = True And ObjectNameExists(par, tok) = True Then
      res = XLScriptGetDBVarValue(codeValRet, par(tok), c)
    ElseIf PropertyNameExists(par, tok) = True Then
      res = par.Properties(tok)
    Else
      Select Case UCase(tok)
        Case "FNCOUNT"
          If Not obj Is Nothing Then
            res = obj.m_Current
          Else
            XLScriptAddLogEntry "Error: '" & tok & "' is not initialized! " & m_WS.name & "!" & c.Address & " Value: " & c.value
          End If
        Case "ADAPTIVEMENUS"
          res = par.AdaptiveMenus
        Case "ADAPTIVEMENU"
          res = par.AdaptiveMenu
        Case "BUILD"
          res = par.Build
        Case "BUILTIN"
          res = par.BuiltIn
        Case "COMADDINS"
          res = XLScriptGetDBVarValue(codeValRet, par.COMAddIns, c)
        Case "COMMANDBARS"
          res = XLScriptGetDBVarValue(codeValRet, par.CommandBars, c)
        Case "CONNECT"
          res = par.Connect
        Case "CONTEXT"
          res = par.Context
        Case "COUNT"
          res = par.count
        Case "CREATOR"
          res = par.Creator
        Case "DBENGINE"
          res = XLScriptGetDBVarValue(codeValRet, par.DBEngine, c)
        Case "DESCRIPTION"
          res = par.Description
        Case "DISABLEASKAQUESTIONDROPDOWN"
          res = par.DisableAskAQuestionDropdown
        Case "DISABLECUSTOMIZE"
          res = par.DisableCustomize
        Case "DISPLAYFONTS"
          res = par.DisplayFonts
        Case "DISPLAYKEYSINTOOLTIPS"
          res = par.DisplayKeysInTooltips
        Case "DISPLAYTOOLTIPS"
          res = par.DisplayTooltips
        Case "ENABLED"
          res = par.Enabled
        Case "FIELDS"
          res = XLScriptGetDBVarValue(codeValRet, par.Fields, c)
        Case "FULLPATH"
          res = par.fullpath
        Case "GUID"
          res = par.GUID
        Case "INDEXES"
          res = XLScriptGetDBVarValue(codeValRet, par.Indexes, c)
        Case "ISBROKEN"
          res = par.isbroken
        Case "ISCOMPILED"
          res = par.IsCompiled
        Case "ITEMS"
          If wasdot Then
            res = XLScriptGetDBVarValue(codeValRet, par.items, c)
          Else
            res = par.items
          End If
        Case "NAME"
          res = par.name
        Case "NAMELOCAL"
          res = par.NameLocal
        Case "PRINTERS"
          res = XLScriptGetDBVarValue(codeValRet, par.Printers, c)
        Case "PRODUCTCODE"
          res = par.ProductCode
        Case "PROGID"
          res = par.ProgId
        Case "REFERENCES"
          res = XLScriptGetDBVarValue(codeValRet, par.References, c)
        Case "REFERSTO"
          res = par.RefersToLocal
        Case "RELATIONS"
          res = XLScriptGetDBVarValue(codeValRet, par.Relations, c)
        Case "SHEETS"
          res = par.Worksheets
        Case "VERSION"
          res = par.Version
        Case "VISIBLE"
          res = par.Visible
'        Case "CUSTOMDOCUMENTPROPERTIES"
'          res = XLScriptGetDBVarValue(codeValRet, par.CustomDocumentProperties, c)
'        Case "BUILTINDOCUMENTPROPERTIES"
'          res = XLScriptGetDBVarValue(codeValRet, par.BuiltinDocumentProperties, c)
        Case Else
          res = XLScriptGetDBVarValue(codeValRet, par.Properties(UCase(tok)), c)
      End Select
    End If
  End If
  XLScriptGetDBVarValue = res
  Exit Function
getError:
  If Len(tok) > 0 Then
    XLScriptAddLogEntry "Warning: " & Err.Description & "  - Token: '" & tok & "' - " & m_WS.name & "!" & c.Address & " Value: " & c.value
  Else
    XLScriptAddLogEntry "Warning: " & Err.Description & " - " & m_WS.name & "!" & c.Address & " Value: " & c.value
  End If
  
End Function

Private Function GetRef(ByRef codeValRet As String, c As Range)
  On Error GoTo 0
  Dim tok As String
  Dim res
  Dim wasdot As Boolean
  wasdot = False
  tok = GetToken(codeValRet)
  If Len(tok) > 0 Then
    If Left(codeValRet, 1) = "." Then
      codeValRet = Trim(Mid(codeValRet, 2))
      wasdot = True
    End If
    Select Case UCase(tok)
'      Case "DB"
'        Set res = GetDBRef(codeValRet, m_DB, c)
'      Case "WS"
'        Set res = GetDBRef(codeValRet, m_Workspace, c)
'      Case "APP"
'        Set res = GetDBRef(codeValRet, m_App, c)
      Case "XL"
        Set res = GetDBRef(codeValRet, m_Excel, c)
      Case "XLWB"
        Set res = GetDBRef(codeValRet, m_Workbook, c)
      Case Else
        Dim found As Boolean
        found = False
        
        Dim goitem As XLScriptGlobalObject
        For Each goitem In m_GlobalObjects
          If UCase(goitem.m_Name) = UCase(tok) Then
            res = GetDBRef(codeValRet, goitem.m_Object, c)
            found = True
            Exit For
          End If
        Next goitem
            
            
        ' Ansonsten muss es eigentlich eine Variable sein...
        Dim item As XLForNext
        For Each item In m_FN
          If UCase(item.m_Name) = UCase(tok) Then
            Set res = GetDBRef(codeValRet, item.m_Ref(item.m_Current), c, item)
            found = True
            Exit For
          End If
        Next item
        
        ' Dann wollen wir doch mal nach "normalen" VariablenArrays schauen, die das Programm ermittelt hat
        If Not found Then
          Dim vaitem As XLScriptArray2D
          For Each vaitem In m_VarArray2D
            If UCase(vaitem.Properties("NAME")) = UCase(tok) Then
              Set res = vaitem.items
              If m_InPrint = True And XLSCript_Debug = True Then
                vaitem.m_WasPrinted = True
              End If
              If wasdot Then
                If ObjectNameExists(vaitem.items, codeValRet) Then
                  Set res = vaitem.items(codeValRet).items
                Else
                  Set res = Nothing
                End If
              End If
              If Not res Is Nothing Then
                found = True
              End If
              Exit For
            End If
          Next vaitem
        End If
        
        If Not found Then
          Dim vasitem As XLScriptArray
          For Each vasitem In m_VarArray
            If UCase(vasitem.Properties("NAME")) = UCase(tok) Then
              Set res = vasitem.items
              If m_InPrint = True And XLSCript_Debug = True Then
                vasitem.m_WasPrinted = True
              End If
              found = True
              Exit For
            End If
          Next vasitem
        End If
        
        If Not found Then
          XLScriptAddLogEntry "Error: '" & tok & "' is not a variable name! " & m_WS.name & "!" & c.Address & " Value: " & c.value
        End If
    End Select
  End If
  If Not IsEmpty(res) Then
    Set GetRef = res
  Else
    Set GetRef = Nothing
  End If
End Function

Private Function GetDBRef(ByRef codeValRet As String, par, c As Range, Optional obj = Nothing)
  On Error GoTo getError
  
  If Len(codeValRet) = 0 Or _
    (Left(codeValRet, 1) <> "." And _
    Not ((Left(codeValRet, 1) >= "a" And Left(codeValRet, 1) <= "z") Or (Left(codeValRet, 1) >= "A" And Left(codeValRet, 1) <= "Z"))) Then
    Set GetDBRef = par
    Exit Function
  End If
  
  Dim tok As String
  Dim res
  tok = GetToken(codeValRet)
  If Len(tok) > 0 Then
    If Left(codeValRet, 1) = "." Then
      codeValRet = Mid(codeValRet, 2)
    End If
    
    
'    If PropertyNameExists(par, tok) Then
'      Set res = GetDBRef(codeValRet, par.Properties(UCase(tok)), c)
'    Else
      Select Case UCase(tok)
        Case "FNCOUNT"
          If Not obj Is Nothing Then
            res = obj.m_Current
          Else
            XLScriptAddLogEntry "Error: '" & tok & "' is not initialized! " & m_WS.name & "!" & c.Address & " Value: " & c.value
          End If
        Case "CONTAINERS"
          Set res = GetDBRef(codeValRet, par.Containers, c)
        Case "DBENGINE"
          Set res = GetDBRef(codeValRet, par.DBEngine, c)
        Case "REFERENCES"
          Set res = GetDBRef(codeValRet, par.References, c)
        Case "RELATIONS"
          Set res = GetDBRef(codeValRet, par.Relations, c)
        Case "FIELDS"
          Set res = GetDBRef(codeValRet, par.Fields, c)
        Case "INDEXES"
          Set res = GetDBRef(codeValRet, par.Indexes, c)
        Case "PRINTERS"
          Set res = GetDBRef(codeValRet, par.Printers, c)
        Case "COMADDINS"
          Set res = GetDBRef(codeValRet, par.COMAddIns, c)
        Case "COMMANDBARS"
          Set res = GetDBRef(codeValRet, par.CommandBars, c)
        Case "COUNT"
          Set res = par.count
        Case "BUILD"
          Set res = par.Build
        Case "ISCOMPILED"
          Set res = par.IsCompiled
        Case "PRODUCTCODE"
          Set res = par.ProductCode
        Case "VERSION"
          Set res = par.Version
        Case "TABLEDEFS"
          Set res = GetDBRef(codeValRet, par.TableDefs, c)
        Case "GROUPS"
          Set res = GetDBRef(codeValRet, par.Groups, c)
        Case "USERS"
          Set res = GetDBRef(codeValRet, par.Users, c)
        Case "NAMES"
          Set res = GetDBRef(codeValRet, par.names, c)
        Case "ITEMS"
          Set res = par.items
          
        Case Else
          If PropertyNameExists(par, UCase(tok)) Then
            Set res = GetDBRef(codeValRet, par.Properties(UCase(tok)), c)
          ElseIf ObjectNameExists(par, UCase(tok)) Then
            Set res = GetDBRef(codeValRet, par(UCase(tok)), c)
          End If
      End Select
'    End If
  End If
  Set GetDBRef = res
  Exit Function
getError:
  
  If Len(tok) > 0 Then
    XLScriptAddLogEntry "Warning: " & Err.Description & "  - Token: '" & tok & "' - " & m_WS.name & "!" & c.Address & " Value: " & c.value
  Else
    XLScriptAddLogEntry "Warning: " & Err.Description & " - " & m_WS.name & "!" & c.Address & " Value: " & c.value
  End If
  Set GetDBRef = Nothing
End Function


Public Sub XLScriptAddLogEntry(s As String)
'  If Not m_ResultWorkbook Is Nothing Then
'    m_ResultWorkbook.Sheets("Log").Cells(m_LogY, 1) = s
'    m_LogY = m_LogY + 1
'  End If
  Debug.Print s
  m_Log.Add s
End Sub


Private Function CountReadable(ref) As Boolean
  On Error GoTo notReadable
  Dim i As Long
  i = ref.count
  CountReadable = True
  Exit Function
  
notReadable:
  CountReadable = False
End Function


Public Function IsReadableFormula(anything) As Boolean
  On Error GoTo nopeNotReadable
  Debug.Print anything.Formula
  IsReadableFormula = True
  Exit Function
nopeNotReadable:
  IsReadableFormula = False
End Function

Function XLScriptGetNewObject(s As String) As Object
  Select Case s
    Case "XLScriptVar"
      Set XLScriptGetNewObject = New XLScriptVar
      Exit Function
    Case "XLScriptSimpleVar"
      Set XLScriptGetNewObject = New XLScriptSimpleVar
      Exit Function
    Case Else
      Err.Raise vbObjectError + 27, "XLScript.XLScript", "Unknown XLScriptGetNewObject type '" & s & "'"
  End Select
End Function


Function IsValid(c As Range) As Boolean
  IsValid = False
  On Error GoTo notValid
  Dim tstr
  tstr = c.value
  IsValid = True
  Exit Function
notValid:
End Function
Public Function VarValueExists(par, name As String) As Boolean
  On Error GoTo notReadable
  Dim s As String
  s = CStr(par(name))
  VarValueExists = True
  Exit Function
  
notReadable:
  VarValueExists = False
End Function

Public Function ObjectNameExists(par, name As String) As Variant
  On Error GoTo notReadable
  Dim s As Variant
  Set s = par(name)
  ObjectNameExists = True
  Exit Function
  
notReadable:
  ObjectNameExists = False
End Function

Public Function PropertyNameExists(par, name As String) As Boolean
  On Error Resume Next
  PropertyNameExists = True
  Dim s As String
  s = CStr(par.Properties(UCase(name)))
  If Err.Number = 0 Then Exit Function
'XXX
  Err.Clear
  Dim t
  Set t = par.Properties(UCase(name))
  If Err.Number = 0 Then Exit Function
  
  PropertyNameExists = False
End Function

Function GetValueFromField(ByRef rs As Object, fieldname As String, defvalue) As Variant
  On Error GoTo nogo
    
  GetValueFromField = defvalue
  If Not IsNull(rs.Fields(fieldname).value) Then
    GetValueFromField = rs.Fields(fieldname).value
  End If
  
nogo:
  
End Function

Function FieldItemExists(ByRef rs As Object, txt As String) As Boolean

  On Error GoTo nogo
  Dim v
  v = rs.Fields(txt).value
  FieldItemExists = True
  
nogo:

End Function

Function TranslateDBField(fn As String) As String
  Select Case UCase(fn)
    Case "UNLOCKEDFORMULASMISSINGSHEETPROTECTION"
      TranslateDBField = "UNLOCKEDFORMULASMISSSHEETPROT"
    Case "LOCKEDFORMULASWITHOUTSHEETPASSWORD"
      TranslateDBField = "LOCKEDFORMULASWOUTSHEETPWD"
    Case "CELLSWITHEXTERNALREFERENCESAMOUNT"
      TranslateDBField = "CELLSWITHEXTERNALREFAMT"
    Case "PROTECTEDWORKSHEETSWITHPASSWORD"
      TranslateDBField = "PROTECTEDWORKSHEETSWITHPWD"
    Case "PROTECTEDWOKRSHEETSWITHOUTPASSWORD"
      TranslateDBField = "PROTECTEDWOKRSHEETSWOUTPWD"
    Case "MISSINGEXTERNALREFERENCESAMOUNT"
      TranslateDBField = "MISSINGEXTERNALREFERENCESAMT"
    Case "SHEETSWITHCIRCULARREFERENCESAMOUNT"
      TranslateDBField = "SHEETSWITHCIRCULARREFAMT"
    Case "MISSINGEXTERNALREFERENCESAMOUNTBC"
      TranslateDBField = "MISSINGEXTERNALREFERENCESAMTBC"
    Case "SHEETSWITHCIRCULARREFERENCESAMOUNTBC"
      TranslateDBField = "SHEETSWITHCIRCULARREFAMTBC"
    Case "UNLOCKEDFORMULASMISSINGSHEETPROTECTIONBC"
      TranslateDBField = "UNLOCKEDFORMULASMISSHEETPROTBC"
    Case "LOCKEDFORMULASWITHOUTSHEETPASSWORDBC"
      TranslateDBField = "LOCKEDFORMULASWOUTSHEETPWDBC"
    Case "CELLSWITHEXTERNALREFERENCESAMOUNTBC"
      TranslateDBField = "CELLSWITHEXTERNALREFAMTBC"
    Case "PROTECTEDWORKSHEETSWITHPASSWORDBC"
      TranslateDBField = "PROTECTEDWORKSHEETSWITHPWDBC"
    Case "PROTECTEDWOKRSHEETSWITHOUTPASSWORDBC"
      TranslateDBField = "PROTECTEDWOKRSHEETSWOUTPBC"
    
    Case Else
      TranslateDBField = fn
  End Select
End Function


Sub XLStoreValsToDB(ByVal analyseWarErfolgreich As Boolean)

On Error GoTo nogo
  
'  LogPrintECCSCanLog theidvDateiID, 0, "ID: " & theidvDateiID & " - XLStoreValsToDB", True
  If AR_UseDB = False Then Exit Sub
  
  'AddStatus "Daten werden geschrieben. Der Vorgang kann einige Zeit in Anspruch nehmen..."
  ' MsgBox "STOP1"
  AddStatus FMT0("XLSCRIPT_5")
  
  LogPrint "XLStoreValsToDB"
  
  If theidvDateiID <= 0 Then Exit Sub
  LogPrint "XLStoreValsToDB-Start"
  
  
  Dim rs As Object
  Dim rsecc As Object
  Dim rslinks As Object
  
  If G_conn Is Nothing Then Exit Sub
  
  G_conn.Execute "DELETE FROM idvDateienTodo WHERE idvDateiID=" & theidvDateiID
  G_conn.Execute "DELETE FROM idvDateienVBALib WHERE idvDateiID=" & theidvDateiID
  
  Dim riskrs As Object
  Dim rsFormeln As Object
  Dim rsParam As Object
  Dim rsTodos As Object
  Dim rsLib As Object


  LogPrint "XLStoreValsToDB-1"

  Set rsecc = OpenRS("SELECT * FROM idvDateien WHERE idvDateiID = " & theidvDateiID, G_conn, MYadOpenDynamic, MYadLockOptimistic)
  
  ' Nur wenn das auch zu mir mit meiner aktuellen Version passt!
  ' idvDateien.CheckerVersion = " & MyECCVersion & " OR idvDateien.CheckerVersion is NULL OR idvDateien.FreigabeStatus = 0
  If Not rsecc Is Nothing Then
    If Not rsecc.EOF Then
      If GetSafeFieldPlus(rsecc, "CheckerVersion", -1) <> MyECCVersion And _
         GetSafeFieldPlus(rsecc, "CheckerVersion", -100) <> -1 And _
         IsNull(rsecc.Fields("CheckerVersion").value) = False And _
         GetSafeFieldPlus(rsecc, "FreigabeStatus", -1) <> 0 And _
         theTrackerFreigabe = False Then
         rsecc.Close
         Set rsecc = Nothing
         'AddStatus "Falsche ECC-Version, DB-Daten wurden nicht geschrieben, ID " & theidvDateiID
         AddStatus FMT1("XLSCRIPT_6", theidvDateiID)
         Exit Sub
      End If
    Else
      'AddStatus "Kein Datensatz f|fffd|r ID " & theidvDateiID
      ' AddStatus FMT1("XLSCRIPT_7", theidvDateiID)
      Exit Sub
    End If
  Else
    'AddStatus "Kein Datensatz f|fffd|r ID " & theidvDateiID
    ' AddStatus FMT1("XLSCRIPT_7", theidvDateiID)
    Exit Sub
  End If

  Set riskrs = OpenRS("SELECT * FROM ECCDateienRisiko WHERE idvDateiID = 0", G_conn, MYadOpenDynamic, MYadLockOptimistic)
  Set rs = OpenRS("SELECT * FROM ECCAnalyse WHERE idvDateiID = 0", G_conn, MYadOpenDynamic, MYadLockOptimistic)
  Set rslinks = OpenRS("SELECT * FROM ECCVerknuepfungen WHERE idvDateiID = 0", G_conn, MYadOpenDynamic, MYadLockOptimistic)
  Set rsFormeln = OpenRS("SELECT * FROM ECCDateienFormeln WHERE idvDateiID = 0", G_conn, MYadOpenDynamic, MYadLockOptimistic)
  Set rsParam = OpenRS("SELECT * FROM gParameter order by ParameterID", G_conn, MYadOpenDynamic, MYadLockReadOnly)
  Set rsTodos = OpenRS("SELECT * FROM idvDateienTodo WHERE idvDateiID = " & theidvDateiID, G_conn, MYadOpenDynamic, MYadLockOptimistic)
  Set rsLib = OpenRS("SELECT * FROM idvDateienVBALib WHERE idvDateiID = " & theidvDateiID, G_conn, MYadOpenDynamic, MYadLockOptimistic)
  
  LogPrint "XLStoreValsToDB-2"
  
  If riskrs Is Nothing Or rs Is Nothing Or rsecc Is Nothing Or rsFormeln Is Nothing Or rsParam Is Nothing Or rsTodos Is Nothing Or rsLib Is Nothing Then
    If Not riskrs Is Nothing Then
      riskrs.Close
      Set riskrs = Nothing
    End If
    If Not rs Is Nothing Then
      rs.Close
      Set rs = Nothing
    End If
    If Not rsecc Is Nothing Then
      rsecc.Close
      Set rsecc = Nothing
    End If
    If Not rslinks Is Nothing Then
      rslinks.Close
      Set rslinks = Nothing
    End If
    If Not rsFormeln Is Nothing Then
      rsFormeln.Close
      Set rsFormeln = Nothing
    End If
    If Not rsParam Is Nothing Then
      rsParam.Close
      Set rsParam = Nothing
    End If
    If Not rsTodos Is Nothing Then
      rsTodos.Close
      Set rsTodos = Nothing
    End If
    If Not rsLib Is Nothing Then
      rsLib.Close
      Set rsLib = Nothing
    End If
    Exit Sub
  End If
  
  LogPrint "XLStoreValsToDB-3"
  
  rs.AddNew
  rs.Fields("idvDateiID").value = theidvDateiID
  Dim nowdate As Date
  If theTrackerFreigabe Then
    nowdate = theTrackerFreigabeDatum
  Else
    nowdate = Now
  End If
  rs.Fields("Datum").value = nowdate
  If FileExists(theFilename) Then
    rs.Fields("Dateigroesse").value = MyFileLen(theFilename)
  End If
  
  ' Status immer speichern.
  rs.Fields("StatusID").value = XLScriptGetSimpleVar("STATUSID").m_Value
  rsecc.Fields("ScanstatusID").value = XLScriptGetSimpleVar("STATUSID").m_Value
  
  If analyseWarErfolgreich Then
  
    If Not XLScriptGetSimpleVar("AUTHOR") Is Nothing Then
      rs.Fields("Ersteller").value = Left(XLScriptGetSimpleVar("AUTHOR").m_Value, 24)
    Else
      rs.Fields("Ersteller").value = ""
    End If
    If Not XLScriptGetSimpleVar("CREATIONDATE") Is Nothing Then
      Dim d As Date
      d = IIf(IsDate(XLScriptGetSimpleVar("CREATIONDATE").m_Value) = True, XLScriptGetSimpleVar("CREATIONDATE").m_Value, DateSerial(1900, 1, 1))
      If d < #1/1/1900# Then d = #1/1/1900#
      rs.Fields("Erstellungsdatum").value = d
    Else
      rs.Fields("Erstellungsdatum").value = DateSerial(1900, 1, 1)
    End If
    
    On Error Resume Next
    
    Dim i As Long
    LogPrint "XLStoreValsToDB-4"
    
    If Not XLScriptGetArray("EXTERNALFILES") Is Nothing Then
      If XLScriptGetArray("EXTERNALFILES").items.count > 0 Then
        For i = 1 To XLScriptGetArray("EXTERNALFILES").items.count
          rslinks.AddNew
          
          rslinks.Fields("idvDateiID").value = theidvDateiID
          rslinks.Fields("Datum").value = nowdate
          If FullVersion = True Or i <= 3 Then
            rslinks.Fields("Dateiname").value = XLScriptGetArray("EXTERNALFILES").items(i).m_SortName
          Else
            rslinks.Fields("Dateiname").value = "Demo"
          End If
          rslinks.Update
        Next i
      End If
    End If
    LogPrint "XLStoreValsToDB-5"
    
    
    rslinks.Close
    Set rslinks = Nothing
    
    
    If Not XLScriptGetArray2D("TODOS") Is Nothing Then
      If XLScriptGetArray2D("TODOS").items.count > 0 Then
        For i = 1 To XLScriptGetArray2D("TODOS").items.count
          rsTodos.AddNew
          rsTodos.Fields("idvDateiID").value = theidvDateiID
          rsTodos.Fields("Todo").value = XLScriptGetArray2D("TODOS").items(i)("COMMENT")
          rsTodos.Fields("Location").value = Left(XLScriptGetArray2D("TODOS").items(i)("NAME") & "!" & XLScriptGetArray2D("TODOS").items(i)("ADDRESS"), 70)
          rsTodos.Update
        Next i
      End If
    End If
    LogPrint "XLStoreValsToDB-6"
    
    
    If Not XLScriptGetArray2D("LIBS") Is Nothing Then
      If XLScriptGetArray2D("LIBS").items.count > 0 Then
        For i = 1 To XLScriptGetArray2D("LIBS").items.count
          rsLib.AddNew
          rsLib.Fields("idvDateiID").value = theidvDateiID
          rsLib.Fields("LIBNAME").value = Left(XLScriptGetArray2D("LIBS").items(i)("LIBNAME"), rsLib.Fields("LIBNAME").DefinedSize)
          rsLib.Fields("LIBDESCRIPTION").value = Left(XLScriptGetArray2D("LIBS").items(i)("LIBDESCRIPTION"), rsLib.Fields("LIBDESCRIPTION").DefinedSize)
          rsLib.Fields("LIBTYPE").value = XLScriptGetArray2D("LIBS").items(i)("LIBTYPE")
          rsLib.Fields("MAJOR").value = XLScriptGetArray2D("LIBS").items(i)("MAJOR")
          rsLib.Fields("MINOR").value = XLScriptGetArray2D("LIBS").items(i)("MINOR")
          rsLib.Fields("PATH").value = XLScriptGetArray2D("LIBS").items(i)("PATH")
          rsLib.Fields("GUID").value = Left(XLScriptGetArray2D("LIBS").items(i)("GUID"), rsLib.Fields("GUID").DefinedSize)
          rsLib.Fields("BUILTIN").value = XLScriptGetArray2D("LIBS").items(i)("BUILTIN")
          rsLib.Fields("ISBROKEN").value = XLScriptGetArray2D("LIBS").items(i)("ISBROKEN")
          rsLib.Update
        Next i
      End If
    End If
    LogPrint "XLStoreValsToDB-6.1"
    
    i = 1
    Dim item
    Dim litem
    Dim cnt As Long
    For Each item In m_AllVars
  '    Debug.Print "AllVars: " & item.m_SortName
      Select Case TypeName(item)
        Case "XLScriptArray2D"
'          If theTrackerFreigabe = True Or (theTrackerFormelnExtrahieren >= 0 And (theTrackerFormelnExtrahieren <= CDbl(XLScriptGetSimpleVar("TotalRisk").m_Value) Or theTrackerFormelnExtrahieren <= theTrackerFachrisiko)) Then
'              If item.m_SortName = "NAMES" Then
'                cnt = 1
'                For Each litem In item.items
'                  rsFormeln.AddNew
'                  rsFormeln.Fields("idvDateiID").value = theidvDateiID
'                  rsFormeln.Fields("Datum").value = nowdate
'                  rsFormeln.Fields("Position").value = cnt
'                  rsFormeln.Fields("Tabellenname").value = Left(litem(1), 31)
'                  rsFormeln.Fields("Formel").value = IIf(Left(litem(3), 1) = "'", Mid(litem(3), 2), litem(3))
'                  rsFormeln.Fields("Typ").value = "N"
'                  rsFormeln.Update
'                  cnt = cnt + 1
'                Next litem
'              ElseIf item.m_SortName = "FORMULAS" Then
'                cnt = 1
'                For Each litem In item.items
'                  rsFormeln.AddNew
'                  rsFormeln.Fields("idvDateiID").value = theidvDateiID
'                  rsFormeln.Fields("Datum").value = nowdate
'                  rsFormeln.Fields("Position").value = cnt
'                  rsFormeln.Fields("Tabellenname").value = Left(litem(1), 31)
'                  rsFormeln.Fields("Addresse").value = Left(litem(2), 15)
'                  rsFormeln.Fields("Typ").value = litem(3)
'                  rsFormeln.Fields("Kommentar").value = IIf(Left(litem(7), 1) = "'", Mid(litem(7), 2), litem(7))
'                  rsFormeln.Fields("Formel").value = IIf(Left(litem(6), 1) = "'", Mid(litem(6), 2), litem(6))
'      '            rsFormeln.fields("Kommentar").Value = IIf(Left(litem(6), 1) = "'", Mid(litem(6), 2), litem(6)) & IIf(Len(litem(7)) > 0, vbCrLf & vbCrLf & "Erl|fffd|uterung: " & vbCrLf & IIf(Left(litem(7), 1) = "'", Mid(litem(7), 2), litem(7)), "")
'      '            rsFormeln.fields("Kommentar").Value = IIf(Left(litem(6), 1) = "'", Mid(litem(6), 2), litem(6))
'      '            rsFormeln.fields("Formel").Value = IIf(Left(litem(7), 1) = "'", Mid(litem(7), 2), litem(7))
'      '            rsFormeln.fields("Comment").Value = "GAGA"
'                  rsFormeln.Update
'                  cnt = cnt + 1
'                Next litem
'              ElseIf item.m_SortName = "DIAGRAMS" Or item.m_SortName = "QUERIES" Or item.m_SortName = "PIVOTS" Then
'                cnt = 1
'                For Each litem In item.items
'                  rsFormeln.AddNew
'                  rsFormeln.Fields("idvDateiID").value = theidvDateiID
'                  rsFormeln.Fields("Datum").value = nowdate
'                  rsFormeln.Fields("Position").value = cnt
'                  rsFormeln.Fields("Tabellenname").value = Left(litem(1), 31)
'                  If item.m_SortName = "DIAGRAMS" Then
'                    rsFormeln.Fields("Typ").value = "D"
'                  ElseIf item.m_SortName = "QUERIES" Then
'                    rsFormeln.Fields("Typ").value = "Q"
'                  ElseIf item.m_SortName = "PIVOTS" Then
'                    rsFormeln.Fields("Typ").value = "P"
'                  Else
'                    rsFormeln.Fields("Typ").value = "X"
'                  End If
'                  rsFormeln.Fields("Formel").value = IIf(Left(litem(2), 1) = "'", Mid(litem(2), 2), litem(2))
'      '            rsFormeln.fields("Kommentar").Value = "Test"
'                  rsFormeln.Update
'                  cnt = cnt + 1
'                Next litem
'              End If
'          End If
          If item.m_SortName = "RiskItems" Then
            For Each litem In item.items
              riskrs.AddNew
              riskrs.Fields("idvDateiID").value = theidvDateiID
              riskrs.Fields("Datum").value = nowdate
              riskrs.Fields("Name").value = Left(litem(1), 20)
              riskrs.Fields("Wert").value = litem(2)
              riskrs.Fields("Farbe").value = litem(3)
              riskrs.Update
            Next litem
          End If
        Case "XLScriptSimpleVar"
  '        Debug.Print TypeName(item), item.m_Txt, item.m_Value
  '        If FieldItemExists(rs, item.m_Txt) Then
  '          If rs.fields(item.m_Txt).Type = 0 Then
  '            If CDate(item.m_Value) < #1/1/1900# Then
  '              rs.fields(item.m_Txt).Value = 0
  '            Else
  '              rs.fields(item.m_Txt).Value = item.m_Value
  '            End If
  '          Else
              If item.m_Txt = "TotalRisk" Then
                  rs.Fields(TranslateDBField(item.m_Txt)).value = CDbl(item.m_Value)
              Else
                  rs.Fields(TranslateDBField(item.m_Txt)).value = item.m_Value
              End If
  
  '          End If
  '        End If
          
        Case "XLScriptVar"
          Debug.Print TypeName(item), item.m_SortName
      End Select
      i = i + 1
    Next item
    LogPrint "XLStoreValsToDB-7"
  End If
  
  rs.Update
  rs.Close
  Set rs = Nothing
  
  riskrs.Close
  Set riskrs = Nothing
  
  rsecc.Fields("LetzterScan").value = nowdate
  If FileExists(theFilename) Then
    rsecc.Fields("Dateidatum").value = FileDateTime(theFilename)
  End If
  
  If analyseWarErfolgreich Then
    If FieldItemExists(rsecc, "CheckerVersion") Then rsecc.Fields("CheckerVersion").value = MyECCVersion
    If FieldItemExists(rsecc, "CheckerSettings") Then rsecc.Fields("CheckerSettings").value = G_ChecksumFlags
  
    rsecc.Fields("ScanRisiko").value = CDbl(XLScriptGetSimpleVar("TotalRisk").m_Value)
    rsecc.Fields("Formelanzahl").value = XLScriptGetSimpleVar("FORMULAAMOUNT").m_Value
    rsecc.Fields("AnzahlNichtAbgesicherteFormeln").value = CLng(XLScriptGetSimpleVar("UNLOCKEDFORMULAS").m_Value) + CLng(XLScriptGetSimpleVar("UNLOCKEDFORMULASMISSINGSHEETPROTECTION").m_Value) + CLng(XLScriptGetSimpleVar("LOCKEDFORMULASWITHOUTSHEETPASSWORD").m_Value)
    rsecc.Fields("ECCFormelnGesamt").value = XLScriptGetSimpleVar("FORMULAAMOUNT").m_Value
    rsecc.Fields("ECCFormelnIndividuell").value = XLScriptGetSimpleVar("FORMULAINDIVAMOUNT").m_Value
    rsecc.Fields("Checksumme").value = XLScriptGetSimpleVar("CHECKSUM").m_Value
    If Not XLScriptGetSimpleVar("AUTHOR") Is Nothing Then
      rsecc.Fields("Ersteller").value = Left(XLScriptGetSimpleVar("AUTHOR").m_Value, 24)
    Else
      rsecc.Fields("Ersteller").value = ""
    End If
    If Not XLScriptGetSimpleVar("CREATIONDATE") Is Nothing Then
      d = IIf(IsDate(XLScriptGetSimpleVar("CREATIONDATE").m_Value) = True, XLScriptGetSimpleVar("CREATIONDATE").m_Value, DateSerial(1900, 1, 1))
      If d < #1/1/1900# Then d = #1/1/1900#
      rsecc.Fields("Erstellungsdatum").value = d
    Else
      rsecc.Fields("Erstellungsdatum").value = DateSerial(1900, 1, 1)
    End If
    
    LogPrint "XLStoreValsToDB-8"
    
  End If
  
  If theTrackerFreigabe Then
    
    Dim ok As Boolean
    ok = True
    
    If analyseWarErfolgreich Then
      If (rsecc.Fields("Risikowert").value >= GetValueFromField(rsParam, "DateienVersionierenAbRisk", 1) And GetValueFromField(rsParam, "DateienVersionierenAbRisk", 1) <> -1) Or _
        GetValueFromField(rsParam, "EincheckenBeiPrgfreigabe", False) <> False Then
         ok = CheckInFile(theFilename, rsecc, theTrackerFreigabeDatum)
      End If
    Else
      ok = False
    End If
    
    If ok Then
      
      ' Neu, der Checker setzt auch die Freigaben!
      ' Freigaben werden wegen Major Minor nicht mehr gel|fffd|scht
'      G_conn.Execute "DELETE FROM idvDateienFreigaben WHERE idvDateiID=" & theidvDateiID & " AND Version = " & rsecc.fields("Version")
'      G_conn.Execute "Insert into idvDateienFreigaben (idvDateiID,Version,Datum,FreigebenderUser,Kommentar,Status,FreigabeChecksumme,CCEmpfaenger) Values( '" & theidvDateiID & _
'        "', '" & rsecc.Fields("Version") & "', '" & Format(theTrackerFreigabeDatum, "YYYY-MM-DD hh:mm:ss") & "', '" & theFreigabeuser & "', '" & theFreigabekommentar & "', '0', '" & XLScriptGetSimpleVar("CHECKSUM").m_Value & "', '" & theFreigabeCCListe & "')"
      
      LogPrint "XLStoreValsToDB-9"
      
      Dim trs As Object
      Set trs = OpenRS("SELECT * FROM idvDateienFreigaben WHERE idvDateiID=" & theidvDateiID & " AND Version = " & rsecc.Fields("Version").value, G_conn, MYadOpenDynamic, MYadLockOptimistic)
      If trs Is Nothing Then
        ok = False
      Else
        If trs.EOF Then
          trs.AddNew
          trs.Fields("idvDateiID").value = theidvDateiID
          trs.Fields("Version").value = rsecc.Fields("Version").value
          ' Major/Minor
          trs.Fields("MajorVersion").value = rsecc.Fields("MajorVersion").value
          trs.Fields("MinorVersion").value = rsecc.Fields("MinorVersion").value
          ' Freigabe Initiierung speichern
          trs.Fields("FreigabeInitiierung").value = rsecc.Fields("FreigabeInitiierung").value
          trs.Fields("FreigabeInitiierendeUser").value = Left(UCase(GetSafeFieldPlus(rsecc, "SpeichernderUserLogonID", "")), 24)
        End If
        If FieldItemExists(trs, "CheckerVersion") Then trs.Fields("CheckerVersion").value = MyECCVersion
        If FieldItemExists(trs, "CheckerSettings") Then trs.Fields("CheckerSettings").value = G_ChecksumFlags
        trs.Fields("Datum").value = theTrackerFreigabeDatum
        trs.Fields("FreigebenderUser").value = Left(UCase(theFreigabeuser), 50)
        trs.Fields("Kommentar").value = theFreigabekommentar
        trs.Fields("Status").value = 0
        trs.Fields("FreigabeChecksumme").value = XLScriptGetSimpleVar("CHECKSUM").m_Value
        trs.Fields("CCEmpfaenger").value = ""
        trs.Update
        trs.Close
      End If
      Set trs = Nothing
      
      LogPrint "XLStoreValsToDB-10"
      
      If ok Then
          rsecc.Fields("FreigabeChecksumme").value = XLScriptGetSimpleVar("CHECKSUM").m_Value
          rsecc.Fields("FreigabeStatus").value = 2
          rsecc.Fields("FreigabeidvDateiID").value = theidvDateiID
          rsecc.Fields("FreigabeVersion").value = rsecc.Fields("Version")
          
          SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="FreigabeErteilt", setting:=1
          'AddStatus "Freigabe erfolgreich durchgef|fffd|hrt!"
          AddStatus FMT0("XLSCRIPT_8")
          StoreUserCommunicateValue "FG", "1"
      Else
          'AddStatus "Freigabe nicht erfolgreich!"
          AddStatus FMT0("XLSCRIPT_9")
          StoreUserCommunicateValue "FG", "0"
      End If
    Else
      'AddStatus "Freigabe nicht erfolgreich!"
      AddStatus FMT0("XLSCRIPT_9")
      StoreUserCommunicateValue "FG", "0"
    End If
                
  LogPrint "XLStoreValsToDB-11"
    
  End If
  rsecc.Update
  
nogo:
  If Err.Number <> 0 Then
'    MsgBox "STOP - " & Err.Number & " - " & Err.Description
'    EndDaemon
'    Resume Next
    DebugPrint DebType.tERROR, "XLStoreValsToDB: " & Err.Number & " - " & Err.Description
    Err.Clear
  End If
On Error Resume Next

  CloseRs rsecc
  CloseRs rsFormeln
  CloseRs rsParam
  CloseRs rsTodos
  CloseRs rsLib
  
  LogPrint "XLStoreValsToDB-Finished"
  
End Sub

Sub CloseRs(ByRef rs)
On Error Resume Next
  If rs.editmode <> 0 Then
    rs.cancelupdate
  End If
  rs.Close
  Set rs = Nothing
End Sub

Attribute VB_Name = "XLScriptArray"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

Public m_SortName As String
Public items As Collection
Public Properties As Collection
Public m_WasPrinted As Boolean

Public Sub Store(nr As Integer)
'  assert 0
  Write #nr, "XLScriptArray"
  Write #nr, m_SortName
  Dim item
  Write #nr, items.count
  Dim i As Long
  For i = 1 To items.count
    Select Case TypeName(items(i))
      Case "XLScriptVar"
        items(i).Store nr
      Case Else
        Debug.Print "Unknown type: " & TypeName(items(i))
    End Select
  Next i
  Write #nr, Properties.count
  For Each item In Properties
    item.Store nr
  Next item
End Sub
Public Sub ReStore(nr As Integer)
  Dim am As Long
  Input #nr, am
  Dim i As Long
  Set Properties = New Collection
  For i = 1 To am
    Dim otype As String
    Input #nr, otype
    Dim sortname As String
    Input #nr, sortname
    Dim tObject
    Set tObject = XLScriptGetNewObject(otype)
    tObject.m_SortName = sortname
    Properties.Add tObject, sortname
    tObject.ReStore nr
  Next i
End Sub

Public Sub Init(Optional n As String = "", Optional v As String = "")
  Set Properties = New Collection
  m_SortName = n
  Properties.Add n, "NAME"
  Properties.Add v, "VAL"
  Set items = New Collection
End Sub

Public Sub AddValue(n As String, v As String)
  If Len(n) > 0 Then
    items.Add v, UCase(n)
  Else
    items.Add v
  End If
End Sub

Function AddNameAndValue(n As String, v As String) As XLScriptVar
  Dim dv As XLScriptVar
  Set dv = New XLScriptVar
  dv.Init n
  dv.Properties.Add n, "NAME"
  dv.Properties.Add v, "VAL"
  items.Add dv, CStr(n)
  Set AddNameAndValue = dv
End Function

Sub AddXLScriptVar(ByRef xlsv As XLScriptVar)
  items.Add xlsv
End Sub

Public Sub AddToValue(propertyName As String, v)
'  On Error GoTo wasMissing
  If Len(propertyName) > 0 Then
    Dim nv
    nv = Properties(propertyName) + v
    Properties.Remove UCase(propertyName)
    Properties.Add nv, UCase(propertyName)
  End If
  Exit Sub
'wasMissing:
'    Properties.Add nv, v
End Sub


Attribute VB_Name = "XLScriptArray2D"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False



Option Explicit

Public m_SortName As String
Public items As Collection
Public itemKeys As Collection
Public Properties As Collection
Public PropertyKeys As Collection
Public m_WasPrinted As Boolean

Public Sub Store(nr As Integer)
'  assert 0
'  Close #1
  Write #nr, "XLScriptArray2D"
  Write #nr, m_SortName
  Dim item
  Write #nr, items.count
  Dim i As Long
  If items.count > 0 Then
    For i = 1 To items.count
      Select Case TypeName(items(i))
        Case "Collection"
          Dim tcoll As Collection
          Set tcoll = items(i)
          Dim tcollkeys As Collection
          Set tcollkeys = itemKeys(i)
          Dim ti As Long
          If tcoll.count > 0 Then
            For ti = 1 To tcoll.count
              Select Case TypeName(tcoll(ti))
                Case "String"
                  Write #nr, tcollkeys(ti), tcoll(ti)
                Case Else
                  Debug.Print "Unknown type: " & TypeName(tcoll(ti))
              End Select
            Next ti
          End If
          Set tcoll = Nothing
          Set tcollkeys = Nothing
        Case "XLScriptArray"
          items(i).Store nr
        Case Else
          Debug.Print "Unknown type: " & TypeName(items(i))
      End Select
  '    Write #nr, itemKeys(i)
  '    Write #nr, items(i)
    Next i
  End If
  Write #nr, Properties.count
  If Properties.count > 0 Then
    For i = 1 To Properties.count
      Write #nr, PropertyKeys(i), Properties(i)
    Next i
  End If
End Sub
Public Sub ReStore(nr As Integer)
  Dim am As Long
  Input #nr, am
  Dim i As Long
  Set Properties = New Collection
  For i = 1 To am
    Dim otype As String
    Input #nr, otype
    Dim sortname As String
    Input #nr, sortname
    Dim tObject
    Set tObject = XLScriptGetNewObject(otype)
    tObject.m_SortName = sortname
    Properties.Add tObject, sortname
    tObject.ReStore nr
  Next i
End Sub


Public Sub Init(Optional name As String = "")
  m_SortName = name
  Set items = New Collection
  Set itemKeys = New Collection
  Set Properties = New Collection
  Set PropertyKeys = New Collection
  Properties.Add name, "NAME"
  PropertyKeys.Add "NAME", "NAME"
End Sub

Public Sub AddLine(Optional linename As String = "")
  Dim al As Collection
  Set al = New Collection
  If Len(linename) = 0 Then
    items.Add al
  Else
    items.Add al, linename
  End If
  Set al = New Collection
  itemKeys.Add al
End Sub

Public Function CurrentLine() As Variant
  Set CurrentLine = items(items.count)
End Function

Public Sub AddValue(n As String, v As String)
  On Error GoTo nogo
  If Len(n) > 0 Then
    items(items.count).Add v, UCase(n)
    itemKeys(items.count).Add UCase(n), UCase(n)
  Else
    items(items.count).Add v
    itemKeys(items.count).Add ""
  End If
  Exit Sub
nogo:
End Sub

Public Sub AddToValue(n As String, v)
'  On Error Resume Next
  If Len(n) > 0 Then
    Dim nv
    nv = items(items.count).item(UCase(n)) + v
    items(items.count).Remove UCase(n)
    items(items.count).Add nv, UCase(n)
  End If
End Sub

Public Sub AddNameAndValue(n As String, v As String)
  items(items.count).AddNameAndValue n, v
End Sub

Public Function AddXLScriptArray(n As String, Optional v As String = "") As XLScriptArray
  
  Dim dsa As XLScriptArray
  Set dsa = New XLScriptArray
  dsa.Init n, v
  items.Add dsa, UCase(n)
  itemKeys.Add UCase(n), UCase(n)
  
  Set AddXLScriptArray = dsa

End Function

Public Function AddXLScriptArray2D(n As String) As XLScriptArray2D
' TODO: Funktionsname falsch, hier wird beim letzten Objekt eine 2D array geadded
  Dim da As XLScriptArray2D
  Set da = New XLScriptArray2D
  da.Init
  items(items.count).Add da, UCase(n)
  itemKeys(items.count).Add UCase(n), UCase(n)
  
  AddXLScriptArray2D = da

End Function

Public Function AddXLScriptArray2DToCurrentLine(n As String) As XLScriptArray2D
' TODO: Funktionsname falsch, hier wird beim letzten Objekt eine 2D array geadded
  Dim da As XLScriptArray2D
  Set da = New XLScriptArray2D
  da.Init
  items(items.count).Add da, UCase(n)
  itemKeys(items.count).Add UCase(n), UCase(n)
  
  AddXLScriptArray2DToCurrentLine = da

End Function

Public Function AddXLScriptArrayToCurrentLine(n As String, Optional v As String = "") As XLScriptArray
  
  Dim dsa As XLScriptArray
  Set dsa = New XLScriptArray
  dsa.Init n, v
  items(items.count).Add dsa, UCase(n)
  itemKeys(items.count).Add UCase(n), UCase(n)
  
  Set AddXLScriptArrayToCurrentLine = dsa

End Function

Attribute VB_Name = "XLScriptGlobalObject"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

Public m_Object As Variant
Public m_Name As String

Attribute VB_Name = "XLScriptSimpleVar"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False



Option Explicit

Public m_Value As String
Public m_Txt As String
Public m_WasPrinted As Boolean

Public Sub Store(nr As Integer)
  Write #nr, "XLScriptSimpleVar"
  Write #nr, m_Value
  Write #nr, m_Txt
End Sub
Public Sub ReStore(nr As Integer)
  Input #nr, m_Value
  Input #nr, m_Txt
End Sub

Attribute VB_Name = "XLScriptVar"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

Public m_SortName As String
Public Properties As Collection
Public PropertyKeys As Collection
Public m_WasPrinted As Boolean

Public Sub Store(nr As Integer)
  Write #nr, "XLScriptVar"
  Write #nr, m_SortName
  Write #nr, Properties.count
  Dim i As Long
  If Properties.count > 0 Then
    For i = 1 To Properties.count
      Write #nr, PropertyKeys(i), Properties(i)
    Next i
  End If
End Sub
Public Sub ReStore(nr As Integer)
  Dim am As Long
  Input #nr, am
  Dim i As Long
  Set Properties = New Collection
  For i = 1 To am
    Dim otype As String
    Input #nr, otype
    Dim sortname As String
    Input #nr, sortname
    Dim tObject
    Set tObject = XLScriptGetNewObject(otype)
    tObject.m_SortName = sortname
    Properties.Add tObject, sortname
    PropertyKeys.Add sortname, sortname
    tObject.ReStore nr
  Next i
End Sub
Public Sub Init(ByVal n As String)
  Set Properties = New Collection
  Set PropertyKeys = New Collection
  m_SortName = n
End Sub

Function GetScriptVar(n As String) As XLScriptVar
  If Not ScriptVarExists(n) Then
    Dim tsv As XLScriptVar
    Set tsv = New XLScriptVar
    tsv.Init n
    tsv.m_SortName = UCase(n)
    Properties.Add tsv, UCase(n)
    PropertyKeys.Add UCase(n), UCase(n)
  End If
  Set GetScriptVar = Properties(UCase(n))
End Function

Function GetScriptArray(n As String) As XLScriptArray
  If Not ScriptVarExists(n) Then
    Dim tsv As XLScriptArray
    Set tsv = New XLScriptArray
    tsv.Init n
    tsv.m_SortName = UCase(n)
    Properties.Add tsv, UCase(n)
    PropertyKeys.Add UCase(n), UCase(n)
  End If
  Set GetScriptArray = Properties(UCase(n))
End Function

Function ScriptVarExists(n As String) As Boolean
  On Error GoTo doesntExist
  ScriptVarExists = True
  Dim tobj
  Set tobj = Properties(UCase(n))
doesntExist:
  ScriptVarExists = False
End Function

Public Sub AddToValue(propertyName As String, v)
'  On Error Resume Next
  If Len(propertyName) > 0 Then
    Dim nv
    nv = Properties(propertyName) + v
    Properties.Remove UCase(propertyName)
    Properties.Add nv, UCase(propertyName)
  End If
End Sub


Attribute VB_Name = "ZipStuff"
Option Explicit

Public G_7ZAvailable As Boolean
Public G_7ZTested As Boolean


Sub ExtractZip(ByVal myZipFile, ByVal myTargetDir)
     Dim intOptions, objShell, objSource, objTarget

    If G_7ZAvailable Then
      Dim errstr As String
      If ExtractZip7Z(myZipFile, myTargetDir, errstr) Then
        Exit Sub
      End If
    End If

     Set objShell = CreateObject("Shell.Application")
     Set objSource = objShell.Namespace(myZipFile).items()
     Set objTarget = objShell.Namespace(myTargetDir)

      ' These are the available CopyHere options, according to MSDN
      ' (http://msdn2.microsoft.com/en-us/library/ms723207.aspx).
     ' On my test systems, however, the options were completely ignored.
     '      4: Do not display a progress dialog box.
     '      8: Give the file a new name in a move, copy, or rename
     '         operation if a file with the target name already exists.
     '     16: Click "Yes to All" in any dialog box that is displayed.
     '     64: Preserve undo information, if possible.
     '    128: Perform the operation on files only if a wildcard file
     '         name (*.*) is specified.
     '    256: Display a progress dialog box but do not show the file
     '         names.
     '    512: Do not confirm the creation of a new directory if the
     '         operation requires one to be created.
     '   1024: Do not display a user interface if an error occurs.
     '   4096: Only operate in the local directory.
     '         Don't operate recursively into subdirectories.
     '   8192: Do not copy connected files as a group.
     '         Only copy the specified files.
      intOptions = 256

      ' UnZIP the files
     objTarget.CopyHere objSource, intOptions

     ' Release the objects
     Set objSource = Nothing
     Set objTarget = Nothing
     Set objShell = Nothing
  End Sub
  
  
Sub NewZip(sPath)
    If Len(Dir(sPath)) > 0 Then Kill sPath
    Open sPath For Output As #1
    Print #1, Chr$(80) & Chr$(75) & Chr$(5) & Chr$(6) & String(18, 0)
    Close #1
End Sub
  
Function ZipFolder(ByVal myFolder As String, ByVal myZipFile As String) As Boolean
    Dim oFolder
    Dim oApp As Object

    If G_7ZAvailable Then
      Dim errstr As String
      If ZipFolder7Z(myFolder, myZipFile, errstr) Then
        ZipFolder = True
        Exit Function
      End If
    End If


    Set oApp = CreateObject("Shell.Application")

    NewZip myZipFile

    If Right(myFolder, 1) <> "\" Then
        myFolder = myFolder & "\"
    End If

    'Keep script waiting until Compressing is done
    On Error GoTo nogo
    
    'Copy the files to the compressed folder
    oApp.Namespace(CStr(myZipFile)).CopyHere oApp.Namespace(CStr(myFolder)).items

    Do Until oApp.Namespace(CStr(myZipFile)).items.count = _
    oApp.Namespace(CStr(myFolder)).items.count
        Application.Wait (Now + TimeValue("0:00:01"))
    Loop
    ZipFolder = True
    Exit Function
nogo:
End Function



Public Function ZipErrorDesc(Code As Long) As String
' Check the 7-zip exit codes
    '   See
    '       <a href="http://linux.die.net/man/1/7za">http://linux.die.net/man/1/7za</a>
    '   for details
    Dim errDesc$
    Select Case Code
        Case 0
            errDesc$ = ""
        Case 1
            errDesc$ = "Warning (Non fatal error(s)). For example, some files cannot be read during compressing. So they were not compressed"
        Case 2
            errDesc$ = "Fatal error"
        Case 7
            errDesc$ = "Bad command line parameters"
        Case 8
            errDesc$ = "Not enough memory for operation"
        Case 255
            errDesc$ = "User stopped the process with control-C" & _
                       "(or similar)"
        Case Else
            errDesc$ = "Unknown exit code"
    End Select
    
    ZipErrorDesc = errDesc$
    
End Function

Function ZipFolder7Z(ByVal myFolder As String, ByVal myZipFile As String, ByRef errstr As String) As Boolean
    If Not PathExists(myFolder) Then
      errstr = myFolder & " existiert nicht!"
      Exit Function
    End If
    If Not FileExists(ThisWorkbook.path & "\7za.exe") Then
      errstr = ThisWorkbook.path & "\7za.exe existiert nicht!"
      Exit Function
    End If

    Dim shellStr As String
    shellStr = Chr(34) & ThisWorkbook.path & "\7za.exe" & Chr(34) & " a " _
             & Chr(34) & myZipFile & Chr(34) & " " _
             & Chr(34) & myFolder & "\*.*" & Chr(34) & " -r"

    Dim res As Long
    res = ShellAndWait(shellStr)  ', vbHide
    If res = 0 Then
      ZipFolder7Z = True
    Else
      errstr = ZipErrorDesc(res)
    End If

End Function

Public Function ExtractZip7Z(ByVal myZipFile As String, ByVal myTargetDir As String, ByRef errstr As String) As Boolean
    
    If Not FileExists(myZipFile) Then
      errstr = myZipFile & " existiert nicht!"
      Exit Function
    End If
    If Not PathExists(myTargetDir) Then
      errstr = myTargetDir & " existiert nicht!"
      Exit Function
    End If
    If Not FileExists(ThisWorkbook.path & "\7za.exe") Then
      errstr = ThisWorkbook.path & "\7za.exe existiert nicht!"
      Exit Function
    End If
   'There are a few commands/Switches that you can change in the ShellStr
    'We use x command now to keep the folder stucture, replace it with e if you want only the files
    '-aoa Overwrite All existing files without prompt.
    '-aos Skip extracting of existing files.
    '-aou aUto rename extracting file (for example, name.txt will be renamed to name_1.txt).
    '-aot auto rename existing file (for example, name.txt will be renamed to name_1.txt).
    'Use -r if you also want to unzip the subfolders from the zip file
    'You can add -ppassword if you want to unzip a zip file with password (only .7z files)
    'Change "*.*" to for example "*.txt" if you only want to unzip the txt files
    'Use "*.xl*" for all Excel files: xls, xlsx, xlsm, xlsb
    Dim shellStr As String
    shellStr = Chr(34) & ThisWorkbook.path & "\7za.exe" & Chr(34) & " x -aoa -r " _
             & Chr(34) & myZipFile & Chr(34) _
             & " -o" & Chr(34) & myTargetDir & Chr(34) & " " & "*.*"

    Dim res As Long
    res = ShellAndWait(shellStr)  ', vbHide
    If res = 0 Then
      ExtractZip7Z = True
    Else
      errstr = ZipErrorDesc(res)
    End If
End Function

Private Function ShellAndWait(ByVal strPathName As String) As Long
    Dim WshShell As Object
    On Error GoTo Fin
    ShellAndWait = 999
    Set WshShell = CreateObject("WScript.Shell")
    ShellAndWait = WshShell.Run(strPathName, 0, True)
Fin:
    Set WshShell = Nothing
    ' If Err.Number <> 0 Then MsgBox "Error: " & _
    '     Err.Number & " " & Err.Description
End Function


Sub TestExt()
  Dim errstr As String
  If Not ExtractZip7Z("D:\IDV-SuiteNV\IDV-Suite\ESQA\PWTester.xlsx.zip", "D:\IDV-SuiteNV\IDV-Suite\ESQA\Testdepack", errstr) Then
    Debug.Print errstr
  Else
    Debug.Print "OK"
  End If

  If Not ZipFolder7Z("D:\IDV-SuiteNV\IDV-Suite\ESQA\Testdepack", "D:\IDV-SuiteNV\IDV-Suite\ESQA\PWTester.xlsx.Test.zip", errstr) Then
    Debug.Print errstr
  Else
    Debug.Print "OK"
  End If
End Sub

Function Test7z() As Boolean
  
  If G_7ZTested Then
    Test7z = G_7ZAvailable
    Exit Function
  End If
  
  G_7ZTested = True
  
  
  If Not FileExists(ThisWorkbook.path & "\7za.exe") Then
    Debug.Print ThisWorkbook.path & "\7za.exe existiert nicht!"
    Exit Function
  End If
  If Not FileExists(ThisWorkbook.path & "\PWTester.xlsx") Then
    Debug.Print ThisWorkbook.path & "\PWTester.xlsx existiert nicht!"
    Exit Function
  End If
  Dim errstr As String
  MkFullDir G_cfgTemppfad & "\" & GetUserName
  If Not PathExists(G_cfgTemppfad & "\" & GetUserName) Then
    Debug.Print G_cfgTemppfad & "\" & GetUserName & " existiert nicht!"
    Exit Function
  End If
  
  If Not ExtractZip7Z(ThisWorkbook.path & "\PWTester.xlsx", G_cfgTemppfad & "\" & GetUserName, errstr) Then
    Debug.Print errstr
  Else
    Debug.Print "OK"
  End If
  If Not FileExists(G_cfgTemppfad & "\" & GetUserName & "\xl\workbook.xml") Then
    Debug.Print ThisWorkbook.path & "\PWTester.xlsx existiert nicht!"
    Exit Function
  End If
  
  DelTree G_cfgTemppfad & "\" & GetUserName
  
  G_7ZAvailable = True
  Test7z = True

End Function
Attribute VB_Name = "frmLogWindow"
Attribute VB_Base = "0{04D5F6F7-3F60-42A0-B21E-B764BC1E438D}{DD926E93-0D59-4778-A4A7-17EA8BA9D147}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Sub PrintTags_Click()

    Dim nameItem As Excel.name

    DebugPrint tinfo, "----- " & ActiveWorkbook.name & " -----"
    Dim i As Long
    If ActiveWorkbook.names.count > 0 Then
      For i = 1 To ActiveWorkbook.names.count
          If ActiveWorkbook.names(i).Visible = False Then
              If InStr(ActiveWorkbook.names(i).name, "_IDVTracker") > 0 Then
                  DebugPrint tinfo, ActiveWorkbook.names.item(i).name & ActiveWorkbook.names.item(i).value
              End If
          End If
      Next i
    End If

End Sub

Private Sub SaveLog_Click()
  Dim Filename
  Filename = Application.GetSaveAsFilename("ECC Log.txt", "Text Datei (*.txt), *.txt", , "Datei speichern")
  If Filename = False Then Exit Sub
  
  If FileExists(CStr(Filename)) Then
    'If MsgBox("Die Datei '" & filename & "' existiert bereits. Soll sie |fffd|berschrieben werden?", vbQuestion + vbYesNo) = vbYes Then
    If MsgBox(FMT1("LOG_4", Filename), vbQuestion + vbYesNo) = vbYes Then
      MyKill CStr(Filename)
    Else
      Exit Sub
    End If
  End If
  AddTextToFile frmLogWindow.LogText.Text, Filename
End Sub

Private Sub UserForm_Initialize()
  gTranslation.TranslateForm Me
End Sub
Attribute VB_Name = "xlFld"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Public m_Name As String
Public m_Col As Collection

Public Sub Init(n As String)
  m_Name = n
  Set m_Col = New Collection
End Sub

' InQuest injected base64 decoded content
' DI@C!
' x(^rB 
' z+xx
' z{Uz
' rgLj
'  cND
' -V+"nW
' (^r@&
' jT^}
' tLmz
' tLmz
' ^uj+
' ^uj+
' RyhrG
' RyhrG
' ']zp
' ']zth
' ']zu
' ']zu
' DD4!
' DADDCB
' 9CS4
' 53NDAR
' DADDCB
' DD4!
' J'!z
' L\zT
' DD4!
' $zp^
' zw^R
' W-'+

INQUEST-PP=macro
